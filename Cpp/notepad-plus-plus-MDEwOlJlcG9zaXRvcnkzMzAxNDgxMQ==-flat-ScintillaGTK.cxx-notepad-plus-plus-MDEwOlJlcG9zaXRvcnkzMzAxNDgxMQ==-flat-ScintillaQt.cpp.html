
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaGTK.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cassert>
5  #include <cstring>
6  #include <cstdio>
7  #include <ctime>
8  #include <cmath>
9  #include <stdexcept>
10  #include <new>
11  #include <string>
12  #include <string_view>
13  #include <vector>
14  #include <map>
15  #include <set>
16  #include <optional>
17  #include <algorithm>
18  #include <memory>
19  #include <glib.h>
20  #include <gmodule.h>
21  #include <gdk/gdk.h>
22  #include <gtk/gtk.h>
23  #include <gdk/gdkkeysyms.h>
24  #if defined(GDK_WINDOWING_WAYLAND)
25  #include <gdk/gdkwayland.h>
26  #endif
27  #if defined(_WIN32)
28  #undef NOMINMAX
29  #define NOMINMAX
30  #include <windows.h>
31  #endif
32  #include "ScintillaTypes.h"
33  #include "ScintillaMessages.h"
34  #include "ScintillaStructures.h"
35  #include "ILoader.h"
36  #include "ILexer.h"
37  #include "Debugging.h"
38  #include "Geometry.h"
39  #include "Platform.h"
40  #include "Scintilla.h"
41  #include "ScintillaWidget.h"
42  #include "CharacterCategoryMap.h"
43  #include "Position.h"
44  #include "UniqueString.h"
45  #include "SplitVector.h"
46  #include "Partitioning.h"
47  #include "RunStyles.h"
48  #include "ContractionState.h"
49  #include "CellBuffer.h"
50  #include "CallTip.h"
51  #include "KeyMap.h"
52  #include "Indicator.h"
53  #include "LineMarker.h"
54  #include "Style.h"
55  #include "ViewStyle.h"
56  #include "CharClassify.h"
57  #include "Decoration.h"
58  #include "CaseFolder.h"
59  #include "Document.h"
60  #include "CaseConvert.h"
61  #include "UniConversion.h"
62  #include "Selection.h"
63  #include "PositionCache.h"
64  #include "EditModel.h"
65  #include "MarginView.h"
66  #include "EditView.h"
67  #include "Editor.h"
68  #include "AutoComplete.h"
69  #include "ScintillaBase.h"
70  #include "Wrappers.h"
71  #include "ScintillaGTK.h"
72  #include "scintilla-marshal.h"
73  #include "ScintillaGTKAccessible.h"
74  #include "Converter.h"
75  #define IS_WIDGET_REALIZED(w) (gtk_widget_get_realized(GTK_WIDGET(w)))
76  #define IS_WIDGET_MAPPED(w) (gtk_widget_get_mapped(GTK_WIDGET(w)))
77  #define SC_INDICATOR_INPUT INDICATOR_IME
78  #define SC_INDICATOR_TARGET INDICATOR_IME+1
79  #define SC_INDICATOR_CONVERTED INDICATOR_IME+2
80  #define SC_INDICATOR_UNKNOWN INDICATOR_IME_MAX
81  using namespace Scintilla;
82  using namespace Scintilla::Internal;
83  extern std::string UTF8FromLatin1(std::string_view text);
84  extern void Platform_Initialise();
85  extern void Platform_Finalise();
86  namespace {
87  enum {
88  	COMMAND_SIGNAL,
89  	NOTIFY_SIGNAL,
90  	LAST_SIGNAL
91  };
92  gint scintilla_signals[LAST_SIGNAL] = { 0 };
93  enum {
94  	TARGET_STRING,
95  	TARGET_TEXT,
96  	TARGET_COMPOUND_TEXT,
97  	TARGET_UTF8_STRING,
98  	TARGET_URI
99  };
100  const GtkTargetEntry clipboardCopyTargets[] = {
101  	{ (gchar *) "UTF8_STRING", 0, TARGET_UTF8_STRING },
102  	{ (gchar *) "STRING", 0, TARGET_STRING },
103  };
104  constexpr gint nClipboardCopyTargets = static_cast<gint>(std::size(clipboardCopyTargets));
105  const GtkTargetEntry clipboardPasteTargets[] = {
106  	{ (gchar *) "text/uri-list", 0, TARGET_URI },
107  	{ (gchar *) "UTF8_STRING", 0, TARGET_UTF8_STRING },
108  	{ (gchar *) "STRING", 0, TARGET_STRING },
109  };
110  constexpr gint nClipboardPasteTargets = static_cast<gint>(std::size(clipboardPasteTargets));
111  const GdkDragAction actionCopyOrMove = static_cast<GdkDragAction>(GDK_ACTION_COPY | GDK_ACTION_MOVE);
112  GtkWidget *PWidget(const Window &w) noexcept {
113  	return static_cast<GtkWidget *>(w.GetID());
114  }
115  GdkWindow *PWindow(const Window &w) noexcept {
116  	GtkWidget *widget = static_cast<GtkWidget *>(w.GetID());
117  	return gtk_widget_get_window(widget);
118  }
119  void MapWidget(GtkWidget *widget) noexcept {
120  	if (widget &&
121  		gtk_widget_get_visible(GTK_WIDGET(widget)) &&
122  		!IS_WIDGET_MAPPED(widget)) {
123  		gtk_widget_map(widget);
124  	}
125  }
126  const guchar *DataOfGSD(GtkSelectionData *sd) noexcept {
127  	return gtk_selection_data_get_data(sd);
128  }
129  gint LengthOfGSD(GtkSelectionData *sd) noexcept {
130  	return gtk_selection_data_get_length(sd);
131  }
132  GdkAtom TypeOfGSD(GtkSelectionData *sd) noexcept {
133  	return gtk_selection_data_get_data_type(sd);
134  }
135  GdkAtom SelectionOfGSD(GtkSelectionData *sd) noexcept {
136  	return gtk_selection_data_get_selection(sd);
137  }
138  bool SettingGet(GtkSettings *settings, const gchar *name, gpointer value) noexcept {
139  	if (!settings) {
140  		return false;
141  	}
142  	if (!g_object_class_find_property(G_OBJECT_GET_CLASS(
143  		G_OBJECT(settings)), name)) {
144  		return false;
145  	}
146  	g_object_get(G_OBJECT(settings), name, value, nullptr);
147  	return true;
148  }
149  }
150  FontOptions::FontOptions(GtkWidget *widget) noexcept {
151  	UniquePangoContext pcontext(gtk_widget_create_pango_context(widget));
152  	PLATFORM_ASSERT(pcontext);
153  	const cairo_font_options_t *options = pango_cairo_context_get_font_options(pcontext.get());
154  	if (options) {
155  		antialias = cairo_font_options_get_antialias(options);
156  		order = cairo_font_options_get_subpixel_order(options);
157  		hint = cairo_font_options_get_hint_style(options);
158  	}
159  }
160  bool FontOptions::operator==(const FontOptions &other) const noexcept {
161  	return antialias == other.antialias &&
162  		order == other.order &&
163  		hint == other.hint;
164  }
165  ScintillaGTK *ScintillaGTK::FromWidget(GtkWidget *widget) noexcept {
166  	ScintillaObject *scio = SCINTILLA(widget);
167  	return static_cast<ScintillaGTK *>(scio->pscin);
168  }
169  ScintillaGTK::ScintillaGTK(_ScintillaObject *sci_) :
170  	adjustmentv(nullptr), adjustmenth(nullptr),
171  	verticalScrollBarWidth(30), horizontalScrollBarHeight(30),
172  	buttonMouse(0),
173  	capturedMouse(false), dragWasDropped(false),
174  	lastKey(0), rectangularSelectionModifier(SCMOD_CTRL),
175  	parentClass(nullptr),
176  	atomSought(nullptr),
177  	preeditInitialized(false),
178  	im_context(nullptr),
179  	lastNonCommonScript(G_UNICODE_SCRIPT_INVALID_CODE),
180  	settings(nullptr),
181  	settingsHandlerId(0),
182  	lastWheelMouseTime(0),
183  	lastWheelMouseDirection(0),
184  	wheelMouseIntensity(0),
185  	smoothScrollY(0),
186  	smoothScrollX(0),
187  	rgnUpdate(nullptr),
188  	repaintFullWindow(false),
189  	styleIdleID(0),
190  	accessibilityEnabled(SC_ACCESSIBILITY_ENABLED),
191  	accessible(nullptr) {
192  	sci = sci_;
193  	wMain = GTK_WIDGET(sci);
194  	rectangularSelectionModifier = SCMOD_ALT;
195  #if PLAT_GTK_WIN32
196  	cfColumnSelect = static_cast<CLIPFORMAT>(
197  				 ::RegisterClipboardFormatW(L"MSDEVColumnSelect"));
198  #ifndef SPI_GETWHEELSCROLLLINES
199  #define SPI_GETWHEELSCROLLLINES   104
200  #endif
201  	::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &linesPerScroll, 0);
202  #else
203  	linesPerScroll = 4;
204  #endif
205  	primarySelection = false;
206  	Init();
207  }
208  ScintillaGTK::~ScintillaGTK() {
209  	if (styleIdleID) {
210  		g_source_remove(styleIdleID);
211  		styleIdleID = 0;
212  	}
213  	if (scrollBarIdleID) {
214  		g_source_remove(scrollBarIdleID);
215  		scrollBarIdleID = 0;
216  	}
217  	ClearPrimarySelection();
218  	wPreedit.Destroy();
219  	if (settingsHandlerId) {
220  		g_signal_handler_disconnect(settings, settingsHandlerId);
221  	}
222  }
223  void ScintillaGTK::RealizeThis(GtkWidget *widget) {
224  	gtk_widget_set_realized(widget, TRUE);
225  	GdkWindowAttr attrs {};
226  	attrs.window_type = GDK_WINDOW_CHILD;
227  	GtkAllocation allocation;
228  	gtk_widget_get_allocation(widget, &allocation);
229  	attrs.x = allocation.x;
230  	attrs.y = allocation.y;
231  	attrs.width = allocation.width;
232  	attrs.height = allocation.height;
233  	attrs.wclass = GDK_INPUT_OUTPUT;
234  	attrs.visual = gtk_widget_get_visual(widget);
235  #if !GTK_CHECK_VERSION(3,0,0)
236  	attrs.colormap = gtk_widget_get_colormap(widget);
237  #endif
238  	attrs.event_mask = gtk_widget_get_events(widget) | GDK_EXPOSURE_MASK;
239  	GdkDisplay *pdisplay = gtk_widget_get_display(widget);
240  	GdkCursor *cursor = gdk_cursor_new_for_display(pdisplay, GDK_XTERM);
241  	attrs.cursor = cursor;
242  #if GTK_CHECK_VERSION(3,0,0)
243  	gtk_widget_set_window(widget, gdk_window_new(gtk_widget_get_parent_window(widget), &attrs,
244  			      GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_CURSOR));
245  #if GTK_CHECK_VERSION(3,8,0)
246  	gtk_widget_register_window(widget, gtk_widget_get_window(widget));
247  #else
248  	gdk_window_set_user_data(gtk_widget_get_window(widget), widget);
249  #endif
250  #if !GTK_CHECK_VERSION(3,18,0)
251  	gtk_style_context_set_background(gtk_widget_get_style_context(widget),
252  					 gtk_widget_get_window(widget));
253  #endif
254  	gdk_window_show(gtk_widget_get_window(widget));
255  #else
256  	widget->window = gdk_window_new(gtk_widget_get_parent_window(widget), &attrs,
257  					GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP | GDK_WA_CURSOR);
258  	gdk_window_set_user_data(widget->window, widget);
259  	widget->style = gtk_style_attach(widget->style, widget->window);
260  	gdk_window_set_background(widget->window, &widget->style->bg[GTK_STATE_NORMAL]);
261  	gdk_window_show(widget->window);
262  #endif
263  	UnRefCursor(cursor);
264  	preeditInitialized = false;
265  	gtk_widget_realize(PWidget(wPreedit));
266  	gtk_widget_realize(PWidget(wPreeditDraw));
267  	im_context.reset(gtk_im_multicontext_new());
268  	g_signal_connect(G_OBJECT(im_context.get()), "commit",
269  			 G_CALLBACK(Commit), this);
270  	g_signal_connect(G_OBJECT(im_context.get()), "preedit_changed",
271  			 G_CALLBACK(PreeditChanged), this);
272  	g_signal_connect(G_OBJECT(im_context.get()), "retrieve-surrounding",
273  			 G_CALLBACK(RetrieveSurrounding), this);
274  	g_signal_connect(G_OBJECT(im_context.get()), "delete-surrounding",
275  			 G_CALLBACK(DeleteSurrounding), this);
276  	gtk_im_context_set_client_window(im_context.get(), WindowFromWidget(widget));
277  	GtkWidget *widtxt = PWidget(wText);	
278  	g_signal_connect_after(G_OBJECT(widtxt), "style_set",
279  			       G_CALLBACK(ScintillaGTK::StyleSetText), nullptr);
280  	g_signal_connect_after(G_OBJECT(widtxt), "realize",
281  			       G_CALLBACK(ScintillaGTK::RealizeText), nullptr);
282  	gtk_widget_realize(widtxt);
283  	gtk_widget_realize(PWidget(scrollbarv));
284  	gtk_widget_realize(PWidget(scrollbarh));
285  	cursor = gdk_cursor_new_for_display(pdisplay, GDK_XTERM);
286  	gdk_window_set_cursor(PWindow(wText), cursor);
287  	UnRefCursor(cursor);
288  	cursor = gdk_cursor_new_for_display(pdisplay, GDK_LEFT_PTR);
289  	gdk_window_set_cursor(PWindow(scrollbarv), cursor);
290  	UnRefCursor(cursor);
291  	cursor = gdk_cursor_new_for_display(pdisplay, GDK_LEFT_PTR);
292  	gdk_window_set_cursor(PWindow(scrollbarh), cursor);
293  	UnRefCursor(cursor);
294  	using NotifyLambda = void (*)(GObject *, GParamSpec *, ScintillaGTK *);
295  	if (settings) {
296  		settingsHandlerId = g_signal_connect(settings, "notify::gtk-xft-dpi",
297  			G_CALLBACK(static_cast<NotifyLambda>([](GObject *, GParamSpec *, ScintillaGTK *sciThis) {
298  				sciThis->InvalidateStyleRedraw();
299  			})),
300  			this);
301  	}
302  }
303  void ScintillaGTK::Realize(GtkWidget *widget) {
304  	ScintillaGTK *sciThis = FromWidget(widget);
305  	sciThis->RealizeThis(widget);
306  }
307  void ScintillaGTK::UnRealizeThis(GtkWidget *widget) {
308  	try {
309  		if (IS_WIDGET_MAPPED(widget)) {
310  			gtk_widget_unmap(widget);
311  		}
312  		gtk_widget_set_realized(widget, FALSE);
313  		gtk_widget_unrealize(PWidget(wText));
314  		if (PWidget(scrollbarv))
315  			gtk_widget_unrealize(PWidget(scrollbarv));
316  		if (PWidget(scrollbarh))
317  			gtk_widget_unrealize(PWidget(scrollbarh));
318  		gtk_widget_unrealize(PWidget(wPreedit));
319  		gtk_widget_unrealize(PWidget(wPreeditDraw));
320  		im_context.reset();
321  		if (GTK_WIDGET_CLASS(parentClass)->unrealize)
322  			GTK_WIDGET_CLASS(parentClass)->unrealize(widget);
323  		Finalise();
324  	} catch (...) {
325  		errorStatus = Status::Failure;
326  	}
327  }
328  void ScintillaGTK::UnRealize(GtkWidget *widget) {
329  	ScintillaGTK *sciThis = FromWidget(widget);
330  	sciThis->UnRealizeThis(widget);
331  }
332  void ScintillaGTK::MapThis() {
333  	try {
334  		gtk_widget_set_mapped(PWidget(wMain), TRUE);
335  		MapWidget(PWidget(wText));
336  		MapWidget(PWidget(scrollbarh));
337  		MapWidget(PWidget(scrollbarv));
338  		wMain.SetCursor(Window::Cursor::arrow);
339  		scrollbarv.SetCursor(Window::Cursor::arrow);
340  		scrollbarh.SetCursor(Window::Cursor::arrow);
341  		SetClientRectangle();
342  		ChangeSize();
343  		gdk_window_show(PWindow(wMain));
344  	} catch (...) {
345  		errorStatus = Status::Failure;
346  	}
347  }
348  void ScintillaGTK::Map(GtkWidget *widget) {
349  	ScintillaGTK *sciThis = FromWidget(widget);
350  	sciThis->MapThis();
351  }
352  void ScintillaGTK::UnMapThis() {
353  	try {
354  		gtk_widget_set_mapped(PWidget(wMain), FALSE);
355  		DropGraphics();
356  		gdk_window_hide(PWindow(wMain));
357  		gtk_widget_unmap(PWidget(wText));
358  		if (PWidget(scrollbarh))
359  			gtk_widget_unmap(PWidget(scrollbarh));
360  		if (PWidget(scrollbarv))
361  			gtk_widget_unmap(PWidget(scrollbarv));
362  	} catch (...) {
363  		errorStatus = Status::Failure;
364  	}
365  }
366  void ScintillaGTK::UnMap(GtkWidget *widget) {
367  	ScintillaGTK *sciThis = FromWidget(widget);
368  	sciThis->UnMapThis();
369  }
370  void ScintillaGTK::ForAll(GtkCallback callback, gpointer callback_data) {
371  	try {
372  		(*callback)(PWidget(wText), callback_data);
373  		if (PWidget(scrollbarv))
374  			(*callback)(PWidget(scrollbarv), callback_data);
375  		if (PWidget(scrollbarh))
376  			(*callback)(PWidget(scrollbarh), callback_data);
377  	} catch (...) {
378  		errorStatus = Status::Failure;
379  	}
380  }
381  void ScintillaGTK::MainForAll(GtkContainer *container, gboolean include_internals, GtkCallback callback, gpointer callback_data) {
382  	ScintillaGTK *sciThis = FromWidget(GTK_WIDGET(container));
383  	if (callback && include_internals) {
384  		sciThis->ForAll(callback, callback_data);
385  	}
386  }
387  namespace {
388  class PreEditString {
389  public:
390  	gchar *str;
391  	gint cursor_pos;
392  	PangoAttrList *attrs;
393  	gboolean validUTF8;
394  	glong uniStrLen;
395  	gunichar *uniStr;
396  	GUnicodeScript pscript;
397  	explicit PreEditString(GtkIMContext *im_context) noexcept {
398  		gtk_im_context_get_preedit_string(im_context, &str, &attrs, &cursor_pos);
399  		validUTF8 = g_utf8_validate(str, strlen(str), nullptr);
400  		uniStr = g_utf8_to_ucs4_fast(str, static_cast<glong>(strlen(str)), &uniStrLen);
401  		pscript = g_unichar_get_script(uniStr[0]);
402  	}
403  	PreEditString(const PreEditString&) = delete;
404  	PreEditString(PreEditString&&) = delete;
405  	PreEditString&operator=(const PreEditString&) = delete;
406  	PreEditString&operator=(PreEditString&&) = delete;
407  	~PreEditString() {
408  		g_free(str);
409  		g_free(uniStr);
410  		pango_attr_list_unref(attrs);
411  	}
412  };
413  }
414  gint ScintillaGTK::FocusInThis(GtkWidget *) {
415  	try {
416  		SetFocusState(true);
417  		if (im_context) {
418  			gtk_im_context_focus_in(im_context.get());
419  			PreEditString pes(im_context.get());
420  			if (PWidget(wPreedit)) {
421  				if (!preeditInitialized) {
422  					GtkWidget *top = gtk_widget_get_toplevel(PWidget(wMain));
423  					gtk_window_set_transient_for(GTK_WINDOW(PWidget(wPreedit)), GTK_WINDOW(top));
424  					preeditInitialized = true;
425  				}
426  				if (strlen(pes.str) > 0) {
427  					gtk_widget_show(PWidget(wPreedit));
428  				} else {
429  					gtk_widget_hide(PWidget(wPreedit));
430  				}
431  			}
432  		}
433  	} catch (...) {
434  		errorStatus = Status::Failure;
435  	}
436  	return FALSE;
437  }
438  gint ScintillaGTK::FocusIn(GtkWidget *widget, GdkEventFocus * &bsol;*event*/) {
439  	ScintillaGTK *sciThis = FromWidget(widget);
440  	return sciThis->FocusInThis(widget);
441  }
442  gint ScintillaGTK::FocusOutThis(GtkWidget *) {
443  	try {
444  		SetFocusState(false);
445  		if (PWidget(wPreedit))
446  			gtk_widget_hide(PWidget(wPreedit));
447  		if (im_context)
448  			gtk_im_context_focus_out(im_context.get());
449  	} catch (...) {
450  		errorStatus = Status::Failure;
451  	}
452  	return FALSE;
453  }
454  gint ScintillaGTK::FocusOut(GtkWidget *widget, GdkEventFocus * &bsol;*event*/) {
455  	ScintillaGTK *sciThis = FromWidget(widget);
456  	return sciThis->FocusOutThis(widget);
457  }
458  void ScintillaGTK::SizeRequest(GtkWidget *widget, GtkRequisition *requisition) {
459  	ScintillaGTK *sciThis = FromWidget(widget);
460  	requisition->width = 1;
461  	requisition->height = 1;
462  	GtkRequisition child_requisition;
463  #if GTK_CHECK_VERSION(3,0,0)
464  	gtk_widget_get_preferred_size(PWidget(sciThis->scrollbarh), nullptr, &child_requisition);
465  	gtk_widget_get_preferred_size(PWidget(sciThis->scrollbarv), nullptr, &child_requisition);
466  #else
467  	gtk_widget_size_request(PWidget(sciThis->scrollbarh), &child_requisition);
468  	gtk_widget_size_request(PWidget(sciThis->scrollbarv), &child_requisition);
469  #endif
470  }
471  #if GTK_CHECK_VERSION(3,0,0)
472  void ScintillaGTK::GetPreferredWidth(GtkWidget *widget, gint *minimalWidth, gint *naturalWidth) {
473  	GtkRequisition requisition;
474  	SizeRequest(widget, &requisition);
475  	*minimalWidth = *naturalWidth = requisition.width;
476  }
477  void ScintillaGTK::GetPreferredHeight(GtkWidget *widget, gint *minimalHeight, gint *naturalHeight) {
478  	GtkRequisition requisition;
479  	SizeRequest(widget, &requisition);
480  	*minimalHeight = *naturalHeight = requisition.height;
481  }
482  #endif
483  void ScintillaGTK::SizeAllocate(GtkWidget *widget, GtkAllocation *allocation) {
484  	ScintillaGTK *sciThis = FromWidget(widget);
485  	try {
486  		gtk_widget_set_allocation(widget, allocation);
487  		if (IS_WIDGET_REALIZED(widget))
488  			gdk_window_move_resize(WindowFromWidget(widget),
489  					       allocation->x,
490  					       allocation->y,
491  					       allocation->width,
492  					       allocation->height);
493  		sciThis->Resize(allocation->width, allocation->height);
494  	} catch (...) {
495  		sciThis->errorStatus = Status::Failure;
496  	}
497  }
498  void ScintillaGTK::Init() {
499  	parentClass = static_cast<GtkWidgetClass *>(
500  			      g_type_class_ref(gtk_container_get_type()));
501  	gint maskSmooth = 0;
502  #if defined(GDK_WINDOWING_WAYLAND)
503  	GdkDisplay *pdisplay = gdk_display_get_default();
504  	if (GDK_IS_WAYLAND_DISPLAY(pdisplay)) {
505  		maskSmooth = GDK_SMOOTH_SCROLL_MASK;
506  	}
507  #endif
508  	gtk_widget_set_can_focus(PWidget(wMain), TRUE);
509  	gtk_widget_set_sensitive(PWidget(wMain), TRUE);
510  	gtk_widget_set_events(PWidget(wMain),
511  			      GDK_EXPOSURE_MASK
512  			      | GDK_SCROLL_MASK
513  			      | maskSmooth
514  			      | GDK_STRUCTURE_MASK
515  			      | GDK_KEY_PRESS_MASK
516  			      | GDK_KEY_RELEASE_MASK
517  			      | GDK_FOCUS_CHANGE_MASK
518  			      | GDK_LEAVE_NOTIFY_MASK
519  			      | GDK_BUTTON_PRESS_MASK
520  			      | GDK_BUTTON_RELEASE_MASK
521  			      | GDK_POINTER_MOTION_MASK
522  			      | GDK_POINTER_MOTION_HINT_MASK);
523  	wText = gtk_drawing_area_new();
524  	gtk_widget_set_parent(PWidget(wText), PWidget(wMain));
525  	GtkWidget *widtxt = PWidget(wText);	
526  	gtk_widget_show(widtxt);
527  #if GTK_CHECK_VERSION(3,0,0)
528  	g_signal_connect(G_OBJECT(widtxt), "draw",
529  			 G_CALLBACK(ScintillaGTK::DrawText), this);
530  #else
531  	g_signal_connect(G_OBJECT(widtxt), "expose_event",
532  			 G_CALLBACK(ScintillaGTK::ExposeText), this);
533  #endif
534  #if GTK_CHECK_VERSION(3,0,0)
535  	if (gtk_check_version(3, 9, 2) != nullptr &bsol;* on < 3.9.2 */)
536  #endif
537  	{
538  #if !GTK_CHECK_VERSION(3,14,0)
539  		gtk_widget_set_double_buffered(widtxt, FALSE);
540  #endif
541  	}
542  	gtk_widget_set_events(widtxt, GDK_EXPOSURE_MASK);
543  	gtk_widget_set_size_request(widtxt, 100, 100);
544  	adjustmentv = GTK_ADJUSTMENT(gtk_adjustment_new(0.0, 0.0, 201.0, 1.0, 20.0, 20.0));
545  #if GTK_CHECK_VERSION(3,0,0)
546  	scrollbarv = gtk_scrollbar_new(GTK_ORIENTATION_VERTICAL, GTK_ADJUSTMENT(adjustmentv));
547  #else
548  	scrollbarv = gtk_vscrollbar_new(GTK_ADJUSTMENT(adjustmentv));
549  #endif
550  	gtk_widget_set_can_focus(PWidget(scrollbarv), FALSE);
551  	g_signal_connect(G_OBJECT(adjustmentv), "value_changed",
552  			 G_CALLBACK(ScrollSignal), this);
553  	gtk_widget_set_parent(PWidget(scrollbarv), PWidget(wMain));
554  	gtk_widget_show(PWidget(scrollbarv));
555  	adjustmenth = GTK_ADJUSTMENT(gtk_adjustment_new(0.0, 0.0, 101.0, 1.0, 20.0, 20.0));
556  #if GTK_CHECK_VERSION(3,0,0)
557  	scrollbarh = gtk_scrollbar_new(GTK_ORIENTATION_HORIZONTAL, GTK_ADJUSTMENT(adjustmenth));
558  #else
559  	scrollbarh = gtk_hscrollbar_new(GTK_ADJUSTMENT(adjustmenth));
560  #endif
561  	gtk_widget_set_can_focus(PWidget(scrollbarh), FALSE);
562  	g_signal_connect(G_OBJECT(adjustmenth), "value_changed",
563  			 G_CALLBACK(ScrollHSignal), this);
564  	gtk_widget_set_parent(PWidget(scrollbarh), PWidget(wMain));
565  	gtk_widget_show(PWidget(scrollbarh));
566  	gtk_widget_grab_focus(PWidget(wMain));
567  	gtk_drag_dest_set(GTK_WIDGET(PWidget(wMain)),
568  			  GTK_DEST_DEFAULT_ALL, clipboardPasteTargets, nClipboardPasteTargets,
569  			  actionCopyOrMove);
570  	wPreedit = gtk_window_new(GTK_WINDOW_POPUP);
571  	wPreeditDraw = gtk_drawing_area_new();
572  	GtkWidget *predrw = PWidget(wPreeditDraw);      
573  #if GTK_CHECK_VERSION(3,0,0)
574  	g_signal_connect(G_OBJECT(predrw), "draw",
575  			 G_CALLBACK(DrawPreedit), this);
576  #else
577  	g_signal_connect(G_OBJECT(predrw), "expose_event",
578  			 G_CALLBACK(ExposePreedit), this);
579  #endif
580  	gtk_container_add(GTK_CONTAINER(PWidget(wPreedit)), predrw);
581  	gtk_widget_show(predrw);
582  	settings = gtk_settings_get_default();
583  	gboolean blinkOn = false;
584  	SettingGet(settings, "gtk-cursor-blink", &blinkOn);
585  	if (blinkOn) {
586  		gint value = 500;
587  		if (SettingGet(settings, "gtk-cursor-blink-time", &value)) {
588  			caret.period = static_cast<int>(value / 1.75);
589  		}
590  	} else {
591  		caret.period = 0;
592  	}
593  	for (size_t tr = static_cast<size_t>(TickReason::caret); tr <= static_cast<size_t>(TickReason::dwell); tr++) {
594  		timers[tr].reason = static_cast<TickReason>(tr);
595  		timers[tr].scintilla = this;
596  	}
597  	vs.indicators[SC_INDICATOR_UNKNOWN] = Indicator(IndicatorStyle::Hidden, ColourRGBA(0, 0, 0xff));
598  	vs.indicators[SC_INDICATOR_INPUT] = Indicator(IndicatorStyle::Dots, ColourRGBA(0, 0, 0xff));
599  	vs.indicators[SC_INDICATOR_CONVERTED] = Indicator(IndicatorStyle::CompositionThick, ColourRGBA(0, 0, 0xff));
600  	vs.indicators[SC_INDICATOR_TARGET] = Indicator(IndicatorStyle::StraightBox, ColourRGBA(0, 0, 0xff));
601  	fontOptionsPrevious = FontOptions(PWidget(wText));
602  }
603  void ScintillaGTK::Finalise() {
604  	for (size_t tr = static_cast<size_t>(TickReason::caret); tr <= static_cast<size_t>(TickReason::dwell); tr++) {
605  		FineTickerCancel(static_cast<TickReason>(tr));
606  	}
607  	if (accessible) {
608  		gtk_accessible_set_widget(GTK_ACCESSIBLE(accessible), nullptr);
609  		g_object_unref(accessible);
610  		accessible = nullptr;
611  	}
612  	ScintillaBase::Finalise();
613  }
614  bool ScintillaGTK::AbandonPaint() {
615  	if ((paintState == PaintState::painting) && !paintingAllText) {
616  		repaintFullWindow = true;
617  	}
618  	return false;
619  }
620  void ScintillaGTK::DisplayCursor(Window::Cursor c) {
621  	if (cursorMode == CursorShape::Normal)
622  		wText.SetCursor(c);
623  	else
624  		wText.SetCursor(static_cast<Window::Cursor>(cursorMode));
625  }
626  bool ScintillaGTK::DragThreshold(Point ptStart, Point ptNow) {
627  	return gtk_drag_check_threshold(GTK_WIDGET(PWidget(wMain)),
628  		static_cast<gint>(ptStart.x), static_cast<gint>(ptStart.y),
629  		static_cast<gint>(ptNow.x), static_cast<gint>(ptNow.y));
630  }
631  void ScintillaGTK::StartDrag() {
632  	PLATFORM_ASSERT(evbtn);
633  	dragWasDropped = false;
634  	inDragDrop = DragDrop::dragging;
635  	GtkTargetList *tl = gtk_target_list_new(clipboardCopyTargets, nClipboardCopyTargets);
636  #if GTK_CHECK_VERSION(3,10,0)
637  	gtk_drag_begin_with_coordinates(GTK_WIDGET(PWidget(wMain)),
638  					tl,
639  					actionCopyOrMove,
640  					buttonMouse,
641  					evbtn.get(),
642  					-1, -1);
643  #else
644  	gtk_drag_begin(GTK_WIDGET(PWidget(wMain)),
645  		       tl,
646  		       actionCopyOrMove,
647  		       buttonMouse,
648  		       evbtn.get());
649  #endif
650  }
651  namespace Scintilla::Internal {
652  std::string ConvertText(const char *s, size_t len, const char *charSetDest,
653  			const char *charSetSource, bool transliterations, bool silent) {
654  	std::string destForm;
655  	Converter conv(charSetDest, charSetSource, transliterations);
656  	if (conv) {
657  		gsize outLeft = len*3+1;
658  		destForm = std::string(outLeft, '\0');
659  		char *pin = const_cast<char *>(s);
660  		gsize inLeft = len;
661  		char *putf = &destForm[0];
662  		char *pout = putf;
663  		const gsize conversions = conv.Convert(&pin, &inLeft, &pout, &outLeft);
664  		if (conversions == sizeFailure) {
665  			if (!silent) {
666  				if (len == 1)
667  					fprintf(stderr, "iconv %s->%s failed for %0x '%s'\n",
668  						charSetSource, charSetDest, static_cast<unsigned char>(*s), s);
669  				else
670  					fprintf(stderr, "iconv %s->%s failed for %s\n",
671  						charSetSource, charSetDest, s);
672  			}
673  			destForm = std::string();
674  		} else {
675  			destForm.resize(pout - putf);
676  		}
677  	} else {
678  		fprintf(stderr, "Can not iconv %s %s\n", charSetDest, charSetSource);
679  	}
680  	return destForm;
681  }
682  }
683  Sci::Position ScintillaGTK::TargetAsUTF8(char *text) const {
684  	const Sci::Position targetLength = targetRange.Length();
685  	if (IsUnicodeMode()) {
686  		if (text) {
687  			pdoc->GetCharRange(text, targetRange.start.Position(), targetLength);
688  		}
689  	} else {
690  		const char *charSetBuffer = CharacterSetID();
691  		if (*charSetBuffer) {
692  			std::string s = RangeText(targetRange.start.Position(), targetRange.end.Position());
693  			std::string tmputf = ConvertText(&s[0], targetLength, "UTF-8", charSetBuffer, false);
694  			if (text) {
695  				memcpy(text, tmputf.c_str(), tmputf.length());
696  			}
697  			return tmputf.length();
698  		} else {
699  			if (text) {
700  				pdoc->GetCharRange(text, targetRange.start.Position(), targetLength);
701  			}
702  		}
703  	}
704  	return targetLength;
705  }
706  Sci::Position ScintillaGTK::EncodedFromUTF8(const char *utf8, char *encoded) const {
707  	const Sci::Position inputLength = (lengthForEncode >= 0) ? lengthForEncode : strlen(utf8);
708  	if (IsUnicodeMode()) {
709  		if (encoded) {
710  			memcpy(encoded, utf8, inputLength);
711  		}
712  		return inputLength;
713  	} else {
714  		const char *charSetBuffer = CharacterSetID();
715  		if (*charSetBuffer) {
716  			std::string tmpEncoded = ConvertText(utf8, inputLength, charSetBuffer, "UTF-8", true);
717  			if (encoded) {
718  				memcpy(encoded, tmpEncoded.c_str(), tmpEncoded.length());
719  			}
720  			return tmpEncoded.length();
721  		} else {
722  			if (encoded) {
723  				memcpy(encoded, utf8, inputLength);
724  			}
725  			return inputLength;
726  		}
727  	}
728  	return 0;
729  }
730  bool ScintillaGTK::ValidCodePage(int codePage) const {
731  	return codePage == 0
732  	       || codePage == SC_CP_UTF8
733  	       || codePage == 932
734  	       || codePage == 936
735  	       || codePage == 949
736  	       || codePage == 950
737  	       || codePage == 1361;
738  }
739  std::string ScintillaGTK::UTF8FromEncoded(std::string_view encoded) const {
740  	if (IsUnicodeMode()) {
741  		return std::string(encoded);
742  	} else {
743  		const char *charSetBuffer = CharacterSetID();
744  		return ConvertText(encoded.data(), encoded.length(), "UTF-8", charSetBuffer, true);
745  	}
746  }
747  std::string ScintillaGTK::EncodedFromUTF8(std::string_view utf8) const {
748  	if (IsUnicodeMode()) {
749  		return std::string(utf8);
750  	} else {
751  		const char *charSetBuffer = CharacterSetID();
752  		return ConvertText(utf8.data(), utf8.length(), charSetBuffer, "UTF-8", true);
753  	}
754  }
755  sptr_t ScintillaGTK::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
756  	try {
757  		switch (iMessage) {
758  		case Message::GrabFocus:
759  			gtk_widget_grab_focus(PWidget(wMain));
760  			break;
761  		case Message::GetDirectFunction:
762  			return reinterpret_cast<sptr_t>(DirectFunction);
763  		case Message::GetDirectStatusFunction:
764  			return reinterpret_cast<sptr_t>(DirectStatusFunction);
765  		case Message::GetDirectPointer:
766  			return reinterpret_cast<sptr_t>(this);
767  		case Message::TargetAsUTF8:
768  			return TargetAsUTF8(CharPtrFromSPtr(lParam));
769  		case Message::EncodedFromUTF8:
770  			return EncodedFromUTF8(ConstCharPtrFromUPtr(wParam),
771  					       CharPtrFromSPtr(lParam));
772  		case Message::SetRectangularSelectionModifier:
773  			rectangularSelectionModifier = static_cast<int>(wParam);
774  			break;
775  		case Message::GetRectangularSelectionModifier:
776  			return rectangularSelectionModifier;
777  		case Message::SetReadOnly: {
778  				const sptr_t ret = ScintillaBase::WndProc(iMessage, wParam, lParam);
779  				if (accessible) {
780  					ScintillaGTKAccessible *sciAccessible = ScintillaGTKAccessible::FromAccessible(accessible);
781  					if (sciAccessible) {
782  						sciAccessible->NotifyReadOnly();
783  					}
784  				}
785  				return ret;
786  			}
787  		case Message::GetAccessibility:
788  			return accessibilityEnabled;
789  		case Message::SetAccessibility:
790  			accessibilityEnabled = static_cast<int>(wParam);
791  			if (accessible) {
792  				ScintillaGTKAccessible *sciAccessible = ScintillaGTKAccessible::FromAccessible(accessible);
793  				if (sciAccessible) {
794  					sciAccessible->SetAccessibility(accessibilityEnabled);
795  				}
796  			}
797  			break;
798  		default:
799  			return ScintillaBase::WndProc(iMessage, wParam, lParam);
800  		}
801  	} catch (std::bad_alloc &) {
802  		errorStatus = Status::BadAlloc;
803  	} catch (...) {
804  		errorStatus = Status::Failure;
805  	}
806  	return 0;
807  }
808  sptr_t ScintillaGTK::DefWndProc(Message, uptr_t, sptr_t) {
809  	return 0;
810  }
811  bool ScintillaGTK::FineTickerRunning(TickReason reason) {
812  	return timers[static_cast<size_t>(reason)].timer != 0;
813  }
814  void ScintillaGTK::FineTickerStart(TickReason reason, int millis, int &bsol;* tolerance */) {
815  	FineTickerCancel(reason);
816  	const size_t reasonIndex = static_cast<size_t>(reason);
817  	timers[reasonIndex].timer = gdk_threads_add_timeout(millis, TimeOut, &timers[reasonIndex]);
818  }
819  void ScintillaGTK::FineTickerCancel(TickReason reason) {
820  	const size_t reasonIndex = static_cast<size_t>(reason);
821  	if (timers[reasonIndex].timer) {
822  		g_source_remove(timers[reasonIndex].timer);
823  		timers[reasonIndex].timer = 0;
824  	}
825  }
826  bool ScintillaGTK::SetIdle(bool on) {
827  	if (on) {
828  		if (!idler.state) {
829  			idler.state = true;
830  			idler.idlerID = GUINT_TO_POINTER(
831  						gdk_threads_add_idle_full(G_PRIORITY_DEFAULT_IDLE, IdleCallback, this, nullptr));
832  		}
833  	} else {
834  		if (idler.state) {
835  			idler.state = false;
836  			g_source_remove(GPOINTER_TO_UINT(idler.idlerID));
837  		}
838  	}
839  	return true;
840  }
841  void ScintillaGTK::SetMouseCapture(bool on) {
842  	if (mouseDownCaptures) {
843  		if (on) {
844  			gtk_grab_add(GTK_WIDGET(PWidget(wMain)));
845  		} else {
846  			gtk_grab_remove(GTK_WIDGET(PWidget(wMain)));
847  		}
848  	}
849  	capturedMouse = on;
850  }
851  bool ScintillaGTK::HaveMouseCapture() {
852  	return capturedMouse;
853  }
854  #if GTK_CHECK_VERSION(3,0,0)
855  namespace {
856  bool CRectContains(const cairo_rectangle_t &crcContainer, const cairo_rectangle_t &crcTest) {
857  	return
858  		(crcTest.x >= crcContainer.x) && ((crcTest.x + crcTest.width) <= (crcContainer.x + crcContainer.width)) &&
859  		(crcTest.y >= crcContainer.y) && ((crcTest.y + crcTest.height) <= (crcContainer.y + crcContainer.height));
860  }
861  bool CRectListContains(const cairo_rectangle_list_t *crcListContainer, const cairo_rectangle_t &crcTest) {
862  	for (int r=0; r<crcListContainer->num_rectangles; r++) {
863  		if (CRectContains(crcListContainer->rectangles[r], crcTest))
864  			return true;
865  	}
866  	return false;
867  }
868  }
869  #endif
870  bool ScintillaGTK::PaintContains(PRectangle rc) {
871  	bool contains = true;
872  	if (paintState == PaintState::painting) {
873  		if (!rcPaint.Contains(rc)) {
874  			contains = false;
875  		} else if (rgnUpdate) {
876  #if GTK_CHECK_VERSION(3,0,0)
877  			cairo_rectangle_t grc = {rc.left, rc.top,
878  						 rc.right - rc.left, rc.bottom - rc.top
879  						};
880  			contains = CRectListContains(rgnUpdate, grc);
881  #else
882  			GdkRectangle grc = {static_cast<gint>(rc.left), static_cast<gint>(rc.top),
883  					    static_cast<gint>(rc.right - rc.left), static_cast<gint>(rc.bottom - rc.top)
884  					   };
885  			if (gdk_region_rect_in(rgnUpdate, &grc) != GDK_OVERLAP_RECTANGLE_IN) {
886  				contains = false;
887  			}
888  #endif
889  		}
890  	}
891  	return contains;
892  }
893  void ScintillaGTK::FullPaint() {
894  	wText.InvalidateAll();
895  }
896  void ScintillaGTK::SetClientRectangle() {
897  	rectangleClient = wMain.GetClientPosition();
898  }
899  PRectangle ScintillaGTK::GetClientRectangle() const {
900  	PRectangle rc = rectangleClient;
901  	if (verticalScrollBarVisible)
902  		rc.right -= verticalScrollBarWidth;
903  	if (horizontalScrollBarVisible && !Wrapping())
904  		rc.bottom -= horizontalScrollBarHeight;
905  	rc.right -= rc.left;
906  	rc.bottom -= rc.top;
907  	if (rc.bottom < 0)
908  		rc.bottom = 0;
909  	if (rc.right < 0)
910  		rc.right = 0;
911  	rc.left = 0;
912  	rc.top = 0;
913  	return rc;
914  }
915  void ScintillaGTK::ScrollText(Sci::Line linesToMove) {
916  	NotifyUpdateUI();
917  #if GTK_CHECK_VERSION(3,22,0)
918  	Redraw();
919  #else
920  	GtkWidget *wi = PWidget(wText);
921  	if (IS_WIDGET_REALIZED(wi)) {
922  		const Sci::Line diff = vs.lineHeight * -linesToMove;
923  		gdk_window_scroll(WindowFromWidget(wi), 0, static_cast<gint>(-diff));
924  		gdk_window_process_updates(WindowFromWidget(wi), FALSE);
925  	}
926  #endif
927  }
928  void ScintillaGTK::SetVerticalScrollPos() {
929  	DwellEnd(true);
930  	gtk_adjustment_set_value(GTK_ADJUSTMENT(adjustmentv), static_cast<gdouble>(topLine));
931  }
932  void ScintillaGTK::SetHorizontalScrollPos() {
933  	DwellEnd(true);
934  	gtk_adjustment_set_value(GTK_ADJUSTMENT(adjustmenth), xOffset);
935  }
936  bool ScintillaGTK::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) {
937  	bool modified = false;
938  	const int pageScroll = static_cast<int>(LinesToScroll());
939  	if (gtk_adjustment_get_upper(adjustmentv) != (nMax + 1) ||
940  			gtk_adjustment_get_page_size(adjustmentv) != nPage ||
941  			gtk_adjustment_get_page_increment(adjustmentv) != pageScroll) {
942  		gtk_adjustment_set_upper(adjustmentv, nMax + 1.0);
943  		gtk_adjustment_set_page_size(adjustmentv, static_cast<gdouble>(nPage));
944  		gtk_adjustment_set_page_increment(adjustmentv, pageScroll);
945  #if !GTK_CHECK_VERSION(3,18,0)
946  		gtk_adjustment_changed(GTK_ADJUSTMENT(adjustmentv));
947  #endif
948  		gtk_adjustment_set_value(GTK_ADJUSTMENT(adjustmentv), static_cast<gdouble>(topLine));
949  		modified = true;
950  	}
951  	const PRectangle rcText = GetTextRectangle();
952  	int horizEndPreferred = scrollWidth;
953  	if (horizEndPreferred < 0)
954  		horizEndPreferred = 0;
955  	const unsigned int pageWidth = static_cast<unsigned int>(rcText.Width());
956  	const unsigned int pageIncrement = pageWidth / 3;
957  	const unsigned int charWidth = static_cast<unsigned int>(vs.styles[STYLE_DEFAULT].aveCharWidth);
958  	if (gtk_adjustment_get_upper(adjustmenth) != horizEndPreferred ||
959  			gtk_adjustment_get_page_size(adjustmenth) != pageWidth ||
960  			gtk_adjustment_get_page_increment(adjustmenth) != pageIncrement ||
961  			gtk_adjustment_get_step_increment(adjustmenth) != charWidth) {
962  		gtk_adjustment_set_upper(adjustmenth, horizEndPreferred);
963  		gtk_adjustment_set_page_size(adjustmenth, pageWidth);
964  		gtk_adjustment_set_page_increment(adjustmenth, pageIncrement);
965  		gtk_adjustment_set_step_increment(adjustmenth, charWidth);
966  #if !GTK_CHECK_VERSION(3,18,0)
967  		gtk_adjustment_changed(GTK_ADJUSTMENT(adjustmenth));
968  #endif
969  		gtk_adjustment_set_value(GTK_ADJUSTMENT(adjustmenth), xOffset);
970  		modified = true;
971  	}
972  	if (modified && (paintState == PaintState::painting)) {
973  		repaintFullWindow = true;
974  	}
975  	return modified;
976  }
977  void ScintillaGTK::ReconfigureScrollBars() {
978  	const PRectangle rc = wMain.GetClientPosition();
979  	Resize(static_cast<int>(rc.Width()), static_cast<int>(rc.Height()));
980  }
981  void ScintillaGTK::SetScrollBars() {
982  	if (scrollBarIdleID) {
983  		return;
984  	}
985  	constexpr gint priorityScrollBar = GDK_PRIORITY_REDRAW + 5;
986  	scrollBarIdleID = gdk_threads_add_idle_full(priorityScrollBar,
987  		[](gpointer pSci) -> gboolean {
988  			ScintillaGTK *sciThis = static_cast<ScintillaGTK *>(pSci);
989  			sciThis->ChangeScrollBars();
990  			sciThis->scrollBarIdleID = 0;
991  			return FALSE;
992  		},
993  		this, nullptr);
994  }
995  void ScintillaGTK::NotifyChange() {
996  	g_signal_emit(G_OBJECT(sci), scintilla_signals[COMMAND_SIGNAL], 0,
997  		      Platform::LongFromTwoShorts(GetCtrlID(), SCEN_CHANGE), PWidget(wMain));
998  }
999  void ScintillaGTK::NotifyFocus(bool focus) {
1000  	if (commandEvents)
1001  		g_signal_emit(G_OBJECT(sci), scintilla_signals[COMMAND_SIGNAL], 0,
1002  			      Platform::LongFromTwoShorts
1003  			      (GetCtrlID(), focus ? SCEN_SETFOCUS : SCEN_KILLFOCUS), PWidget(wMain));
1004  	Editor::NotifyFocus(focus);
1005  }
1006  void ScintillaGTK::NotifyParent(NotificationData scn) {
1007  	scn.nmhdr.hwndFrom = PWidget(wMain);
1008  	scn.nmhdr.idFrom = GetCtrlID();
1009  	g_signal_emit(G_OBJECT(sci), scintilla_signals[NOTIFY_SIGNAL], 0,
1010  		      GetCtrlID(), &scn);
1011  }
1012  void ScintillaGTK::NotifyKey(Keys key, KeyMod modifiers) {
1013  	NotificationData scn = {};
1014  	scn.nmhdr.code = Notification::Key;
1015  	scn.ch = static_cast<int>(key);
1016  	scn.modifiers = modifiers;
1017  	NotifyParent(scn);
1018  }
1019  void ScintillaGTK::NotifyURIDropped(const char *list) {
1020  	NotificationData scn = {};
1021  	scn.nmhdr.code = Notification::URIDropped;
1022  	scn.text = list;
1023  	NotifyParent(scn);
1024  }
1025  const char *CharacterSetID(CharacterSet characterSet);
1026  const char *ScintillaGTK::CharacterSetID() const {
1027  	return ::CharacterSetID(vs.styles[STYLE_DEFAULT].characterSet);
1028  }
1029  namespace {
1030  class CaseFolderDBCS : public CaseFolderTable {
1031  	const char *charSet;
1032  public:
1033  	explicit CaseFolderDBCS(const char *charSet_) noexcept : charSet(charSet_) {
1034  	}
1035  	size_t Fold(char *folded, size_t sizeFolded, const char *mixed, size_t lenMixed) override {
1036  		if ((lenMixed == 1) && (sizeFolded > 0)) {
1037  			folded[0] = mapping[static_cast<unsigned char>(mixed[0])];
1038  			return 1;
1039  		} else if (*charSet) {
1040  			std::string sUTF8 = ConvertText(mixed, lenMixed,
1041  							"UTF-8", charSet, false);
1042  			if (!sUTF8.empty()) {
1043  				UniqueStr mapped(g_utf8_casefold(sUTF8.c_str(), sUTF8.length()));
1044  				size_t lenMapped = strlen(mapped.get());
1045  				if (lenMapped < sizeFolded) {
1046  					memcpy(folded, mapped.get(),  lenMapped);
1047  				} else {
1048  					folded[0] = '\0';
1049  					lenMapped = 1;
1050  				}
1051  				return lenMapped;
1052  			}
1053  		}
1054  		folded[0] = '\0';
1055  		return 1;
1056  	}
1057  };
1058  }
1059  std::unique_ptr<CaseFolder> ScintillaGTK::CaseFolderForEncoding() {
1060  	if (pdoc->dbcsCodePage == SC_CP_UTF8) {
1061  		return std::make_unique<CaseFolderUnicode>();
1062  	} else {
1063  		const char *charSetBuffer = CharacterSetID();
1064  		if (charSetBuffer) {
1065  			if (pdoc->dbcsCodePage == 0) {
1066  				std::unique_ptr<CaseFolderTable> pcf = std::make_unique<CaseFolderTable>();
1067  				for (int i=0x80; i<0x100; i++) {
1068  					char sCharacter[2] = "A";
1069  					sCharacter[0] = i;
1070  					std::string sUTF8 = ConvertText(sCharacter, 1,
1071  									"UTF-8", charSetBuffer, false, true);
1072  					if (!sUTF8.empty()) {
1073  						UniqueStr mapped(g_utf8_casefold(sUTF8.c_str(), sUTF8.length()));
1074  						if (mapped) {
1075  							std::string mappedBack = ConvertText(mapped.get(), strlen(mapped.get()),
1076  											     charSetBuffer, "UTF-8", false, true);
1077  							if ((mappedBack.length() == 1) && (mappedBack[0] != sCharacter[0])) {
1078  								pcf->SetTranslation(sCharacter[0], mappedBack[0]);
1079  							}
1080  						}
1081  					}
1082  				}
1083  				return pcf;
1084  			} else {
1085  				return std::make_unique<CaseFolderDBCS>(charSetBuffer);
1086  			}
1087  		}
1088  		return nullptr;
1089  	}
1090  }
1091  namespace {
1092  struct CaseMapper {
1093  	UniqueStr mapped;
1094  	CaseMapper(const std::string &sUTF8, bool toUpperCase) noexcept {
1095  		if (toUpperCase) {
1096  			mapped.reset(g_utf8_strup(sUTF8.c_str(), sUTF8.length()));
1097  		} else {
1098  			mapped.reset(g_utf8_strdown(sUTF8.c_str(), sUTF8.length()));
1099  		}
1100  	}
1101  };
1102  }
1103  std::string ScintillaGTK::CaseMapString(const std::string &s, CaseMapping caseMapping) {
1104  	if (s.empty() || (caseMapping == CaseMapping::same))
1105  		return s;
1106  	if (IsUnicodeMode()) {
1107  		std::string retMapped(s.length() * maxExpansionCaseConversion, 0);
1108  		const size_t lenMapped = CaseConvertString(&retMapped[0], retMapped.length(), s.c_str(), s.length(),
1109  					 (caseMapping == CaseMapping::upper) ? CaseConversion::upper : CaseConversion::lower);
1110  		retMapped.resize(lenMapped);
1111  		return retMapped;
1112  	}
1113  	const char *charSetBuffer = CharacterSetID();
1114  	if (!*charSetBuffer) {
1115  		CaseMapper mapper(s, caseMapping == CaseMapping::upper);
1116  		return std::string(mapper.mapped.get());
1117  	} else {
1118  		std::string sUTF8 = ConvertText(s.c_str(), s.length(),
1119  						"UTF-8", charSetBuffer, false);
1120  		CaseMapper mapper(sUTF8, caseMapping == CaseMapping::upper);
1121  		return ConvertText(mapper.mapped.get(), strlen(mapper.mapped.get()), charSetBuffer, "UTF-8", false);
1122  	}
1123  }
1124  int ScintillaGTK::KeyDefault(Keys key, KeyMod modifiers) {
1125  	NotifyKey(key, modifiers);
1126  	return 0;
1127  }
1128  void ScintillaGTK::CopyToClipboard(const SelectionText &selectedText) {
1129  	SelectionText *clipText = new SelectionText();
1130  	clipText->Copy(selectedText);
1131  	StoreOnClipboard(clipText);
1132  }
1133  void ScintillaGTK::Copy() {
1134  	if (!sel.Empty()) {
1135  		SelectionText *clipText = new SelectionText();
1136  		CopySelectionRange(clipText);
1137  		StoreOnClipboard(clipText);
1138  #if PLAT_GTK_WIN32
1139  		if (sel.IsRectangular()) {
1140  			::OpenClipboard(NULL);
1141  			::SetClipboardData(cfColumnSelect, 0);
1142  			::CloseClipboard();
1143  		}
1144  #endif
1145  	}
1146  }
1147  namespace {
1148  class SelectionReceiver : GObjectWatcher {
1149  	ScintillaGTK *sci;
1150  	void Destroyed() noexcept override {
1151  		sci = nullptr;
1152  	}
1153  public:
1154  	SelectionReceiver(ScintillaGTK *sci_) :
1155  		GObjectWatcher(G_OBJECT(sci_->MainObject())),
1156  		sci(sci_) {
1157  	}
1158  	static void ClipboardReceived(GtkClipboard *clipboard, GtkSelectionData *selection_data, gpointer data) noexcept {
1159  		SelectionReceiver *self = static_cast<SelectionReceiver *>(data);
1160  		if (self->sci) {
1161  			self->sci->ReceivedClipboard(clipboard, selection_data);
1162  		}
1163  		delete self;
1164  	}
1165  };
1166  }
1167  void ScintillaGTK::RequestSelection(GdkAtom atomSelection) {
1168  	atomSought = atomUTF8;
1169  	GtkClipboard *clipBoard =
1170  		gtk_widget_get_clipboard(GTK_WIDGET(PWidget(wMain)), atomSelection);
1171  	if (clipBoard) {
1172  		gtk_clipboard_request_contents(clipBoard, atomSought,
1173  					       SelectionReceiver::ClipboardReceived,
1174  					       new SelectionReceiver(this));
1175  	}
1176  }
1177  void ScintillaGTK::Paste() {
1178  	RequestSelection(GDK_SELECTION_CLIPBOARD);
1179  }
1180  void ScintillaGTK::CreateCallTipWindow(PRectangle rc) {
1181  	if (!ct.wCallTip.Created()) {
1182  		ct.wCallTip = gtk_window_new(GTK_WINDOW_POPUP);
1183  		ct.wDraw = gtk_drawing_area_new();
1184  		GtkWidget *widcdrw = PWidget(ct.wDraw);	
1185  		gtk_container_add(GTK_CONTAINER(PWidget(ct.wCallTip)), widcdrw);
1186  #if GTK_CHECK_VERSION(3,0,0)
1187  		g_signal_connect(G_OBJECT(widcdrw), "draw",
1188  				 G_CALLBACK(ScintillaGTK::DrawCT), &ct);
1189  #else
1190  		g_signal_connect(G_OBJECT(widcdrw), "expose_event",
1191  				 G_CALLBACK(ScintillaGTK::ExposeCT), &ct);
1192  #endif
1193  		g_signal_connect(G_OBJECT(widcdrw), "button_press_event",
1194  				 G_CALLBACK(ScintillaGTK::PressCT), this);
1195  		gtk_widget_set_events(widcdrw,
1196  				      GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK);
1197  		GtkWidget *top = gtk_widget_get_toplevel(PWidget(wMain));
1198  		gtk_window_set_transient_for(GTK_WINDOW(PWidget(ct.wCallTip)), GTK_WINDOW(top));
1199  	}
1200  	const int width = static_cast<int>(rc.Width());
1201  	const int height = static_cast<int>(rc.Height());
1202  	gtk_widget_set_size_request(PWidget(ct.wDraw), width, height);
1203  	ct.wDraw.Show();
1204  	if (PWindow(ct.wCallTip)) {
1205  		gdk_window_resize(PWindow(ct.wCallTip), width, height);
1206  	}
1207  }
1208  void ScintillaGTK::AddToPopUp(const char *label, int cmd, bool enabled) {
1209  	GtkWidget *menuItem;
1210  	if (label[0])
1211  		menuItem = gtk_menu_item_new_with_label(label);
1212  	else
1213  		menuItem = gtk_separator_menu_item_new();
1214  	gtk_menu_shell_append(GTK_MENU_SHELL(popup.GetID()), menuItem);
1215  	g_object_set_data(G_OBJECT(menuItem), "CmdNum", GINT_TO_POINTER(cmd));
1216  	g_signal_connect(G_OBJECT(menuItem), "activate", G_CALLBACK(PopUpCB), this);
1217  	if (cmd) {
1218  		if (menuItem)
1219  			gtk_widget_set_sensitive(menuItem, enabled);
1220  	}
1221  }
1222  bool ScintillaGTK::OwnPrimarySelection() {
1223  	return primarySelection;
1224  }
1225  void ScintillaGTK::ClearPrimarySelection() {
1226  	if (primarySelection) {
1227  		inClearSelection++;
1228  		gtk_clipboard_clear(gtk_clipboard_get(GDK_SELECTION_PRIMARY));
1229  		inClearSelection--;
1230  	}
1231  }
1232  void ScintillaGTK::PrimaryGetSelectionThis(GtkClipboard *clip, GtkSelectionData *selection_data, guint info) {
1233  	try {
1234  		if (SelectionOfGSD(selection_data) == GDK_SELECTION_PRIMARY) {
1235  			if (primary.Empty()) {
1236  				CopySelectionRange(&primary);
1237  			}
1238  			GetSelection(selection_data, info, &primary);
1239  		}
1240  	} catch (...) {
1241  		errorStatus = Status::Failure;
1242  	}
1243  }
1244  void ScintillaGTK::PrimaryGetSelection(GtkClipboard *clip, GtkSelectionData *selection_data, guint info, gpointer pSci) {
1245  	static_cast<ScintillaGTK *>(pSci)->PrimaryGetSelectionThis(clip, selection_data, info);
1246  }
1247  void ScintillaGTK::PrimaryClearSelectionThis(GtkClipboard *clip) {
1248  	try {
1249  		primarySelection = false;
1250  		primary.Clear();
1251  		if (!inClearSelection) {
1252  			Redraw();
1253  		}
1254  	} catch (...) {
1255  		errorStatus = Status::Failure;
1256  	}
1257  }
1258  void ScintillaGTK::PrimaryClearSelection(GtkClipboard *clip, gpointer pSci) {
1259  	static_cast<ScintillaGTK *>(pSci)->PrimaryClearSelectionThis(clip);
1260  }
1261  void ScintillaGTK::ClaimSelection() {
1262  	ClearPrimarySelection();
1263  	if (!sel.Empty()) {
1264  		if (gtk_clipboard_set_with_data(
1265  			gtk_clipboard_get(GDK_SELECTION_PRIMARY),
1266  			clipboardCopyTargets, nClipboardCopyTargets,
1267  			PrimaryGetSelection,
1268  			PrimaryClearSelection,
1269  			this)) {
1270  			primarySelection = true;
1271  		}
1272  	}
1273  }
1274  bool ScintillaGTK::IsStringAtom(GdkAtom type) {
1275  	return (type == GDK_TARGET_STRING) || (type == atomUTF8) || (type == atomUTF8Mime);
1276  }
1277  void ScintillaGTK::GetGtkSelectionText(GtkSelectionData *selectionData, SelectionText &selText) {
1278  	const char *data = reinterpret_cast<const char *>(DataOfGSD(selectionData));
1279  	int len = LengthOfGSD(selectionData);
1280  	GdkAtom selectionTypeData = TypeOfGSD(selectionData);
1281  	if (!IsStringAtom(selectionTypeData)) {
1282  		selText.Clear();
1283  		return;
1284  	}
1285  	bool isRectangular;
1286  #if PLAT_GTK_WIN32
1287  	isRectangular = ::IsClipboardFormatAvailable(cfColumnSelect) != 0;
1288  #else
1289  	isRectangular = ((len > 2) && (data[len - 1] == 0 && data[len - 2] == '\n'));
1290  	if (isRectangular)
1291  		len--;	
1292  #endif
1293  #if PLAT_GTK_WIN32
1294  	if ((len > 0) && (data[len - 1] == '\0'))
1295  		len--;
1296  #endif
1297  	std::string dest(data, len);
1298  	if (selectionTypeData == GDK_TARGET_STRING) {
1299  		if (IsUnicodeMode()) {
1300  			dest = UTF8FromLatin1(dest);
1301  			selText.Copy(dest, CpUtf8, CharacterSet::Ansi, isRectangular, false);
1302  		} else {
1303  			selText.Copy(dest, pdoc->dbcsCodePage,
1304  				     vs.styles[STYLE_DEFAULT].characterSet, isRectangular, false);
1305  		}
1306  	} else {	
1307  		const char *charSetBuffer = CharacterSetID();
1308  		if (!IsUnicodeMode() && *charSetBuffer) {
1309  			dest = ConvertText(dest.c_str(), dest.length(), charSetBuffer, "UTF-8", true);
1310  			selText.Copy(dest, pdoc->dbcsCodePage,
1311  				     vs.styles[STYLE_DEFAULT].characterSet, isRectangular, false);
1312  		} else {
1313  			selText.Copy(dest, CpUtf8, CharacterSet::Ansi, isRectangular, false);
1314  		}
1315  	}
1316  }
1317  void ScintillaGTK::InsertSelection(GtkClipboard *clipBoard, GtkSelectionData *selectionData) {
1318  	const gint length = gtk_selection_data_get_length(selectionData);
1319  	const GdkAtom selection = gtk_selection_data_get_selection(selectionData);
1320  	if (length >= 0) {
1321  		SelectionText selText;
1322  		GetGtkSelectionText(selectionData, selText);
1323  		UndoGroup ug(pdoc);
1324  		if (selection == GDK_SELECTION_CLIPBOARD) {
1325  			ClearSelection(multiPasteMode == MultiPaste::Each);
1326  		}
1327  		if (selection == GDK_SELECTION_PRIMARY) {
1328  			SetSelection(posPrimary, posPrimary);
1329  		}
1330  		InsertPasteShape(selText.Data(), selText.Length(),
1331  				 selText.rectangular ? PasteShape::rectangular : PasteShape::stream);
1332  		EnsureCaretVisible();
1333  	} else {
1334  		if (selection == GDK_SELECTION_PRIMARY) {
1335  			SetSelection(posPrimary, posPrimary);
1336  		}
1337  		GdkAtom target = gtk_selection_data_get_target(selectionData);
1338  		if (target == atomUTF8) {
1339  			gtk_clipboard_request_contents(clipBoard, atomUTF8Mime,
1340  					 SelectionReceiver::ClipboardReceived,
1341  					 new SelectionReceiver(this)
1342  			);
1343  		}
1344  	}
1345  	Redraw();
1346  }
1347  GObject *ScintillaGTK::MainObject() const noexcept {
1348  	return G_OBJECT(PWidget(wMain));
1349  }
1350  void ScintillaGTK::ReceivedClipboard(GtkClipboard *clipBoard, GtkSelectionData *selection_data) noexcept {
1351  	try {
1352  		InsertSelection(clipBoard, selection_data);
1353  	} catch (...) {
1354  		errorStatus = Status::Failure;
1355  	}
1356  }
1357  void ScintillaGTK::ReceivedSelection(GtkSelectionData *selection_data) {
1358  	try {
1359  		if ((SelectionOfGSD(selection_data) == GDK_SELECTION_CLIPBOARD) ||
1360  				(SelectionOfGSD(selection_data) == GDK_SELECTION_PRIMARY)) {
1361  			if ((atomSought == atomUTF8) && (LengthOfGSD(selection_data) <= 0)) {
1362  				atomSought = atomString;
1363  				gtk_selection_convert(GTK_WIDGET(PWidget(wMain)),
1364  						      SelectionOfGSD(selection_data), atomSought, GDK_CURRENT_TIME);
1365  			} else if ((LengthOfGSD(selection_data) > 0) && IsStringAtom(TypeOfGSD(selection_data))) {
1366  				GtkClipboard *clipBoard = gtk_widget_get_clipboard(GTK_WIDGET(PWidget(wMain)), SelectionOfGSD(selection_data));
1367  				InsertSelection(clipBoard, selection_data);
1368  			}
1369  		}
1370  	} catch (...) {
1371  		errorStatus = Status::Failure;
1372  	}
1373  }
1374  void ScintillaGTK::ReceivedDrop(GtkSelectionData *selection_data) {
1375  	dragWasDropped = true;
1376  	if (TypeOfGSD(selection_data) == atomUriList || TypeOfGSD(selection_data) == atomDROPFILES_DND) {
1377  		const char *data = reinterpret_cast<const char *>(DataOfGSD(selection_data));
1378  		std::vector<char> drop(data, data + LengthOfGSD(selection_data));
1379  		drop.push_back('\0');
1380  		NotifyURIDropped(&drop[0]);
1381  	} else if (IsStringAtom(TypeOfGSD(selection_data))) {
1382  		if (LengthOfGSD(selection_data) > 0) {
1383  			SelectionText selText;
1384  			GetGtkSelectionText(selection_data, selText);
1385  			DropAt(posDrop, selText.Data(), selText.Length(), false, selText.rectangular);
1386  		}
1387  	} else if (LengthOfGSD(selection_data) > 0) {
1388  	}
1389  	Redraw();
1390  }
1391  void ScintillaGTK::GetSelection(GtkSelectionData *selection_data, guint info, SelectionText *text) {
1392  #if PLAT_GTK_WIN32
1393  	std::unique_ptr<SelectionText> newline_normalized;
1394  	{
1395  		std::string tmpstr = Document::TransformLineEnds(text->Data(), text->Length(), EndOfLine::Lf);
1396  		newline_normalized = std::make_unique<SelectionText>();
1397  		newline_normalized->Copy(tmpstr, CpUtf8, CharacterSet::Ansi, text->rectangular, false);
1398  		text = newline_normalized.get();
1399  	}
1400  #endif
1401  	std::unique_ptr<SelectionText> converted;
1402  	if ((text->codePage != SC_CP_UTF8) && (info == TARGET_UTF8_STRING)) {
1403  		const char *charSet = ::CharacterSetID(text->characterSet);
1404  		if (*charSet) {
1405  			std::string tmputf = ConvertText(text->Data(), text->Length(), "UTF-8", charSet, false);
1406  			converted = std::make_unique<SelectionText>();
1407  			converted->Copy(tmputf, CpUtf8, CharacterSet::Ansi, text->rectangular, false);
1408  			text = converted.get();
1409  		}
1410  	}
1411  	const char *textData = text->Data();
1412  	gint len = static_cast<gint>(text->Length());
1413  #if PLAT_GTK_WIN32 == 0
1414  	if (text->rectangular)
1415  		len++;
1416  #endif
1417  	if (info == TARGET_UTF8_STRING) {
1418  		gtk_selection_data_set_text(selection_data, textData, len);
1419  	} else {
1420  		gtk_selection_data_set(selection_data,
1421  				       static_cast<GdkAtom>(GDK_SELECTION_TYPE_STRING),
1422  				       8, reinterpret_cast<const guchar *>(textData), len);
1423  	}
1424  }
1425  void ScintillaGTK::StoreOnClipboard(SelectionText *clipText) {
1426  	GtkClipboard *clipBoard =
1427  		gtk_widget_get_clipboard(GTK_WIDGET(PWidget(wMain)), GDK_SELECTION_CLIPBOARD);
1428  	if (clipBoard == nullptr) 
1429  		return;
1430  	if (gtk_clipboard_set_with_data(clipBoard, clipboardCopyTargets, nClipboardCopyTargets,
1431  					ClipboardGetSelection, ClipboardClearSelection, clipText)) {
1432  		gtk_clipboard_set_can_store(clipBoard, clipboardCopyTargets, nClipboardCopyTargets);
1433  	}
1434  }
1435  void ScintillaGTK::ClipboardGetSelection(GtkClipboard *, GtkSelectionData *selection_data, guint info, void *data) {
1436  	GetSelection(selection_data, info, static_cast<SelectionText *>(data));
1437  }
1438  void ScintillaGTK::ClipboardClearSelection(GtkClipboard *, void *data) {
1439  	SelectionText *obj = static_cast<SelectionText *>(data);
1440  	delete obj;
1441  }
1442  void ScintillaGTK::UnclaimSelection(GdkEventSelection *selection_event) {
1443  	try {
1444  		if (selection_event->selection == GDK_SELECTION_PRIMARY) {
1445  			if (!OwnPrimarySelection()) {
1446  				primary.Clear();
1447  				primarySelection = false;
1448  				FullPaint();
1449  			}
1450  		}
1451  	} catch (...) {
1452  		errorStatus = Status::Failure;
1453  	}
1454  }
1455  void ScintillaGTK::Resize(int width, int height) {
1456  	int minVScrollBarHeight, minHScrollBarWidth;
1457  #if GTK_CHECK_VERSION(3,0,0)
1458  	GtkRequisition minimum, requisition;
1459  	gtk_widget_get_preferred_size(PWidget(scrollbarv), &minimum, &requisition);
1460  	minVScrollBarHeight = minimum.height;
1461  	verticalScrollBarWidth = requisition.width;
1462  	gtk_widget_get_preferred_size(PWidget(scrollbarh), &minimum, &requisition);
1463  	minHScrollBarWidth = minimum.width;
1464  	horizontalScrollBarHeight = requisition.height;
1465  #else
1466  	minVScrollBarHeight = minHScrollBarWidth = 1;
1467  	verticalScrollBarWidth = GTK_WIDGET(PWidget(scrollbarv))->requisition.width;
1468  	horizontalScrollBarHeight = GTK_WIDGET(PWidget(scrollbarh))->requisition.height;
1469  #endif
1470  	const bool showSBHorizontal = horizontalScrollBarVisible && !Wrapping();
1471  	GtkAllocation alloc = {};
1472  	if (showSBHorizontal) {
1473  		gtk_widget_show(GTK_WIDGET(PWidget(scrollbarh)));
1474  		alloc.x = 0;
1475  		alloc.y = height - horizontalScrollBarHeight;
1476  		alloc.width = std::max(minHScrollBarWidth, width - verticalScrollBarWidth);
1477  		alloc.height = horizontalScrollBarHeight;
1478  		gtk_widget_size_allocate(GTK_WIDGET(PWidget(scrollbarh)), &alloc);
1479  	} else {
1480  		gtk_widget_hide(GTK_WIDGET(PWidget(scrollbarh)));
1481  		horizontalScrollBarHeight = 0; 
1482  	}
1483  	if (verticalScrollBarVisible) {
1484  		gtk_widget_show(GTK_WIDGET(PWidget(scrollbarv)));
1485  		alloc.x = width - verticalScrollBarWidth;
1486  		alloc.y = 0;
1487  		alloc.width = verticalScrollBarWidth;
1488  		alloc.height = std::max(minVScrollBarHeight, height - horizontalScrollBarHeight);
1489  		gtk_widget_size_allocate(GTK_WIDGET(PWidget(scrollbarv)), &alloc);
1490  	} else {
1491  		gtk_widget_hide(GTK_WIDGET(PWidget(scrollbarv)));
1492  		verticalScrollBarWidth = 0;
1493  	}
1494  	SetClientRectangle();
1495  	if (IS_WIDGET_MAPPED(PWidget(wMain))) {
1496  		ChangeSize();
1497  	} else {
1498  		const PRectangle rcTextArea = GetTextRectangle();
1499  		if (wrapWidth != rcTextArea.Width()) {
1500  			wrapWidth = rcTextArea.Width();
1501  			NeedWrapping();
1502  		}
1503  	}
1504  	alloc.x = 0;
1505  	alloc.y = 0;
1506  	alloc.width = 1;
1507  	alloc.height = 1;
1508  #if GTK_CHECK_VERSION(3, 0, 0)
1509  	gtk_widget_get_preferred_size(PWidget(wText), &requisition, nullptr);
1510  	alloc.width = requisition.width;
1511  	alloc.height = requisition.height;
1512  #endif
1513  	alloc.width = std::max(alloc.width, width - verticalScrollBarWidth);
1514  	alloc.height = std::max(alloc.height, height - horizontalScrollBarHeight);
1515  	gtk_widget_size_allocate(GTK_WIDGET(PWidget(wText)), &alloc);
1516  }
1517  namespace {
1518  void SetAdjustmentValue(GtkAdjustment *object, int value) noexcept {
1519  	GtkAdjustment *adjustment = GTK_ADJUSTMENT(object);
1520  	const int maxValue = static_cast<int>(
1521  				     gtk_adjustment_get_upper(adjustment) - gtk_adjustment_get_page_size(adjustment));
1522  	if (value > maxValue)
1523  		value = maxValue;
1524  	if (value < 0)
1525  		value = 0;
1526  	gtk_adjustment_set_value(adjustment, value);
1527  }
1528  int modifierTranslated(int sciModifier) noexcept {
1529  	switch (sciModifier) {
1530  	case SCMOD_SHIFT:
1531  		return GDK_SHIFT_MASK;
1532  	case SCMOD_CTRL:
1533  		return GDK_CONTROL_MASK;
1534  	case SCMOD_ALT:
1535  		return GDK_MOD1_MASK;
1536  	case SCMOD_SUPER:
1537  		return GDK_MOD4_MASK;
1538  	default:
1539  		return 0;
1540  	}
1541  }
1542  Point PointOfEvent(const GdkEventButton *event) noexcept {
1543  	return Point(static_cast<XYPOSITION>(std::floor(event->x)), static_cast<XYPOSITION>(std::floor(event->y)));
1544  }
1545  }
1546  gint ScintillaGTK::PressThis(GdkEventButton *event) {
1547  	try {
1548  		if (event->type != GDK_BUTTON_PRESS)
1549  			return FALSE;
1550  		evbtn.reset(gdk_event_copy(reinterpret_cast<GdkEvent *>(event)));
1551  		buttonMouse = event->button;
1552  		const Point pt = PointOfEvent(event);
1553  		const PRectangle rcClient = GetClientRectangle();
1554  		if ((pt.x > rcClient.right) || (pt.y > rcClient.bottom)) {
1555  			Platform::DebugPrintf("Bad location\n");
1556  			return FALSE;
1557  		}
1558  		const bool shift = (event->state & GDK_SHIFT_MASK) != 0;
1559  		bool ctrl = (event->state & GDK_CONTROL_MASK) != 0;
1560  		const bool alt = (event->state & modifierTranslated(rectangularSelectionModifier)) != 0;
1561  		gtk_widget_grab_focus(PWidget(wMain));
1562  		if (event->button == 1) {
1563  #if PLAT_GTK_MACOSX
1564  			const bool meta = ctrl;
1565  			ctrl = (event->state & GDK_MOD2_MASK) != 0;
1566  #else
1567  			const bool meta = false;
1568  #endif
1569  			ButtonDownWithModifiers(pt, event->time, ModifierFlags(shift, ctrl, alt, meta));
1570  		} else if (event->button == 2) {
1571  			posPrimary = SPositionFromLocation(pt, false, false, UserVirtualSpace());
1572  			if (OwnPrimarySelection() && primary.Empty())
1573  				CopySelectionRange(&primary);
1574  			sel.Clear();
1575  			RequestSelection(GDK_SELECTION_PRIMARY);
1576  		} else if (event->button == 3) {
1577  			if (!PointInSelection(pt))
1578  				SetEmptySelection(PositionFromLocation(pt));
1579  			if (ShouldDisplayPopup(pt)) {
1580  				int ox = 0;
1581  				int oy = 0;
1582  				gdk_window_get_origin(PWindow(wMain), &ox, &oy);
1583  				ContextMenu(Point(pt.x + ox, pt.y + oy));
1584  			} else {
1585  #if PLAT_GTK_MACOSX
1586  				const bool meta = ctrl;
1587  				ctrl = (event->state & GDK_MOD2_MASK) != 0;
1588  #else
1589  				const bool meta = false;
1590  #endif
1591  				RightButtonDownWithModifiers(pt, event->time, ModifierFlags(shift, ctrl, alt, meta));
1592  				return FALSE;
1593  			}
1594  		} else if (event->button == 4) {
1595  			if (ctrl)
1596  				SetAdjustmentValue(adjustmenth, xOffset - 6);
1597  			else
1598  				SetAdjustmentValue(adjustmentv, static_cast<int>(topLine) - 3);
1599  		} else if (event->button == 5) {
1600  			if (ctrl)
1601  				SetAdjustmentValue(adjustmenth, xOffset + 6);
1602  			else
1603  				SetAdjustmentValue(adjustmentv, static_cast<int>(topLine) + 3);
1604  		}
1605  	} catch (...) {
1606  		errorStatus = Status::Failure;
1607  	}
1608  	return TRUE;
1609  }
1610  gint ScintillaGTK::Press(GtkWidget *widget, GdkEventButton *event) {
1611  	if (event->window != WindowFromWidget(widget))
1612  		return FALSE;
1613  	ScintillaGTK *sciThis = FromWidget(widget);
1614  	return sciThis->PressThis(event);
1615  }
1616  gint ScintillaGTK::MouseRelease(GtkWidget *widget, GdkEventButton *event) {
1617  	ScintillaGTK *sciThis = FromWidget(widget);
1618  	try {
1619  		if (!sciThis->HaveMouseCapture())
1620  			return FALSE;
1621  		if (event->button == 1) {
1622  			Point pt = PointOfEvent(event);
1623  			if (event->window != PWindow(sciThis->wMain))
1624  				pt = sciThis->ptMouseLast;
1625  			const KeyMod modifiers = ModifierFlags(
1626  						      (event->state & GDK_SHIFT_MASK) != 0,
1627  						      (event->state & GDK_CONTROL_MASK) != 0,
1628  						      (event->state & modifierTranslated(sciThis->rectangularSelectionModifier)) != 0);
1629  			sciThis->ButtonUpWithModifiers(pt, event->time, modifiers);
1630  		}
1631  	} catch (...) {
1632  		sciThis->errorStatus = Status::Failure;
1633  	}
1634  	return FALSE;
1635  }
1636  gint ScintillaGTK::ScrollEvent(GtkWidget *widget, GdkEventScroll *event) {
1637  	ScintillaGTK *sciThis = FromWidget(widget);
1638  	try {
1639  		if (widget == nullptr || event == nullptr)
1640  			return FALSE;
1641  #if defined(GDK_WINDOWING_WAYLAND)
1642  		if (event->direction == GDK_SCROLL_SMOOTH && GDK_IS_WAYLAND_WINDOW(event->window)) {
1643  			const int smoothScrollFactor = 4;
1644  			sciThis->smoothScrollY += event->delta_y * smoothScrollFactor;
1645  			sciThis->smoothScrollX += event->delta_x * smoothScrollFactor;;
1646  			if (ABS(sciThis->smoothScrollY) >= 1.0) {
1647  				const int scrollLines = std::trunc(sciThis->smoothScrollY);
1648  				sciThis->ScrollTo(sciThis->topLine + scrollLines);
1649  				sciThis->smoothScrollY -= scrollLines;
1650  			}
1651  			if (ABS(sciThis->smoothScrollX) >= 1.0) {
1652  				const int scrollPixels = std::trunc(sciThis->smoothScrollX);
1653  				sciThis->HorizontalScrollTo(sciThis->xOffset + scrollPixels);
1654  				sciThis->smoothScrollX -= scrollPixels;
1655  			}
1656  			return TRUE;
1657  		}
1658  #endif
1659  		int cLineScroll;
1660  #if (defined(__APPLE__) || defined(PLAT_GTK_WIN32)) && !defined(GDK_WINDOWING_QUARTZ)
1661  		cLineScroll = sciThis->linesPerScroll;
1662  		if (cLineScroll == 0)
1663  			cLineScroll = 4;
1664  		sciThis->wheelMouseIntensity = cLineScroll;
1665  #else
1666  		const gint64 curTime = g_get_monotonic_time();
1667  		const gint64 timeDelta = curTime - sciThis->lastWheelMouseTime;
1668  		if ((event->direction == sciThis->lastWheelMouseDirection) && (timeDelta < 250000)) {
1669  			if (sciThis->wheelMouseIntensity < 12)
1670  				sciThis->wheelMouseIntensity++;
1671  			cLineScroll = sciThis->wheelMouseIntensity;
1672  		} else {
1673  			cLineScroll = sciThis->linesPerScroll;
1674  			if (cLineScroll == 0)
1675  				cLineScroll = 4;
1676  			sciThis->wheelMouseIntensity = cLineScroll;
1677  		}
1678  		sciThis->lastWheelMouseTime = curTime;
1679  #endif
1680  		if (event->direction == GDK_SCROLL_UP || event->direction == GDK_SCROLL_LEFT) {
1681  			cLineScroll *= -1;
1682  		}
1683  		sciThis->lastWheelMouseDirection = event->direction;
1684  #if GTK_CHECK_VERSION(3,4,0)
1685  		if (event->direction == GDK_SCROLL_SMOOTH) {
1686  			return FALSE;
1687  		}
1688  #endif
1689  		if (event->direction == GDK_SCROLL_LEFT || event->direction == GDK_SCROLL_RIGHT || event->state & GDK_SHIFT_MASK) {
1690  			int hScroll = gtk_adjustment_get_step_increment(sciThis->adjustmenth);
1691  			hScroll *= cLineScroll; 
1692  			sciThis->HorizontalScrollTo(sciThis->xOffset + hScroll);
1693  		} else if (event->state & GDK_CONTROL_MASK) {
1694  			if (cLineScroll < 0) {
1695  				sciThis->KeyCommand(Message::ZoomIn);
1696  			} else {
1697  				sciThis->KeyCommand(Message::ZoomOut);
1698  			}
1699  		} else {
1700  			sciThis->ScrollTo(sciThis->topLine + cLineScroll);
1701  		}
1702  		return TRUE;
1703  	} catch (...) {
1704  		sciThis->errorStatus = Status::Failure;
1705  	}
1706  	return FALSE;
1707  }
1708  gint ScintillaGTK::Motion(GtkWidget *widget, GdkEventMotion *event) {
1709  	ScintillaGTK *sciThis = FromWidget(widget);
1710  	try {
1711  		if (event->window != WindowFromWidget(widget))
1712  			return FALSE;
1713  		int x = 0;
1714  		int y = 0;
1715  		GdkModifierType state {};
1716  		if (event->is_hint) {
1717  #if GTK_CHECK_VERSION(3,0,0)
1718  			gdk_window_get_device_position(event->window,
1719  						       event->device, &x, &y, &state);
1720  #else
1721  			gdk_window_get_pointer(event->window, &x, &y, &state);
1722  #endif
1723  		} else {
1724  			x = static_cast<int>(event->x);
1725  			y = static_cast<int>(event->y);
1726  			state = static_cast<GdkModifierType>(event->state);
1727  		}
1728  		const Point pt(static_cast<XYPOSITION>(x), static_cast<XYPOSITION>(y));
1729  		const KeyMod modifiers = ModifierFlags(
1730  					      (event->state & GDK_SHIFT_MASK) != 0,
1731  					      (event->state & GDK_CONTROL_MASK) != 0,
1732  					      (event->state & modifierTranslated(sciThis->rectangularSelectionModifier)) != 0);
1733  		sciThis->ButtonMoveWithModifiers(pt, event->time, modifiers);
1734  	} catch (...) {
1735  		sciThis->errorStatus = Status::Failure;
1736  	}
1737  	return FALSE;
1738  }
1739  namespace {
1740  int KeyTranslate(int keyIn) noexcept {
1741  	switch (keyIn) {
1742  #if GTK_CHECK_VERSION(3,0,0)
1743  	case GDK_KEY_ISO_Left_Tab:
1744  		return SCK_TAB;
1745  	case GDK_KEY_KP_Down:
1746  		return SCK_DOWN;
1747  	case GDK_KEY_KP_Up:
1748  		return SCK_UP;
1749  	case GDK_KEY_KP_Left:
1750  		return SCK_LEFT;
1751  	case GDK_KEY_KP_Right:
1752  		return SCK_RIGHT;
1753  	case GDK_KEY_KP_Home:
1754  		return SCK_HOME;
1755  	case GDK_KEY_KP_End:
1756  		return SCK_END;
1757  	case GDK_KEY_KP_Page_Up:
1758  		return SCK_PRIOR;
1759  	case GDK_KEY_KP_Page_Down:
1760  		return SCK_NEXT;
1761  	case GDK_KEY_KP_Delete:
1762  		return SCK_DELETE;
1763  	case GDK_KEY_KP_Insert:
1764  		return SCK_INSERT;
1765  	case GDK_KEY_KP_Enter:
1766  		return SCK_RETURN;
1767  	case GDK_KEY_Down:
1768  		return SCK_DOWN;
1769  	case GDK_KEY_Up:
1770  		return SCK_UP;
1771  	case GDK_KEY_Left:
1772  		return SCK_LEFT;
1773  	case GDK_KEY_Right:
1774  		return SCK_RIGHT;
1775  	case GDK_KEY_Home:
1776  		return SCK_HOME;
1777  	case GDK_KEY_End:
1778  		return SCK_END;
1779  	case GDK_KEY_Page_Up:
1780  		return SCK_PRIOR;
1781  	case GDK_KEY_Page_Down:
1782  		return SCK_NEXT;
1783  	case GDK_KEY_Delete:
1784  		return SCK_DELETE;
1785  	case GDK_KEY_Insert:
1786  		return SCK_INSERT;
1787  	case GDK_KEY_Escape:
1788  		return SCK_ESCAPE;
1789  	case GDK_KEY_BackSpace:
1790  		return SCK_BACK;
1791  	case GDK_KEY_Tab:
1792  		return SCK_TAB;
1793  	case GDK_KEY_Return:
1794  		return SCK_RETURN;
1795  	case GDK_KEY_KP_Add:
1796  		return SCK_ADD;
1797  	case GDK_KEY_KP_Subtract:
1798  		return SCK_SUBTRACT;
1799  	case GDK_KEY_KP_Divide:
1800  		return SCK_DIVIDE;
1801  	case GDK_KEY_Super_L:
1802  		return SCK_WIN;
1803  	case GDK_KEY_Super_R:
1804  		return SCK_RWIN;
1805  	case GDK_KEY_Menu:
1806  		return SCK_MENU;
1807  #else
1808  	case GDK_ISO_Left_Tab:
1809  		return SCK_TAB;
1810  	case GDK_KP_Down:
1811  		return SCK_DOWN;
1812  	case GDK_KP_Up:
1813  		return SCK_UP;
1814  	case GDK_KP_Left:
1815  		return SCK_LEFT;
1816  	case GDK_KP_Right:
1817  		return SCK_RIGHT;
1818  	case GDK_KP_Home:
1819  		return SCK_HOME;
1820  	case GDK_KP_End:
1821  		return SCK_END;
1822  	case GDK_KP_Page_Up:
1823  		return SCK_PRIOR;
1824  	case GDK_KP_Page_Down:
1825  		return SCK_NEXT;
1826  	case GDK_KP_Delete:
1827  		return SCK_DELETE;
1828  	case GDK_KP_Insert:
1829  		return SCK_INSERT;
1830  	case GDK_KP_Enter:
1831  		return SCK_RETURN;
1832  	case GDK_Down:
1833  		return SCK_DOWN;
1834  	case GDK_Up:
1835  		return SCK_UP;
1836  	case GDK_Left:
1837  		return SCK_LEFT;
1838  	case GDK_Right:
1839  		return SCK_RIGHT;
1840  	case GDK_Home:
1841  		return SCK_HOME;
1842  	case GDK_End:
1843  		return SCK_END;
1844  	case GDK_Page_Up:
1845  		return SCK_PRIOR;
1846  	case GDK_Page_Down:
1847  		return SCK_NEXT;
1848  	case GDK_Delete:
1849  		return SCK_DELETE;
1850  	case GDK_Insert:
1851  		return SCK_INSERT;
1852  	case GDK_Escape:
1853  		return SCK_ESCAPE;
1854  	case GDK_BackSpace:
1855  		return SCK_BACK;
1856  	case GDK_Tab:
1857  		return SCK_TAB;
1858  	case GDK_Return:
1859  		return SCK_RETURN;
1860  	case GDK_KP_Add:
1861  		return SCK_ADD;
1862  	case GDK_KP_Subtract:
1863  		return SCK_SUBTRACT;
1864  	case GDK_KP_Divide:
1865  		return SCK_DIVIDE;
1866  	case GDK_Super_L:
1867  		return SCK_WIN;
1868  	case GDK_Super_R:
1869  		return SCK_RWIN;
1870  	case GDK_Menu:
1871  		return SCK_MENU;
1872  #endif
1873  	default:
1874  		return keyIn;
1875  	}
1876  }
1877  }
1878  gboolean ScintillaGTK::KeyThis(GdkEventKey *event) {
1879  	try {
1880  		if (gtk_im_context_filter_keypress(im_context.get(), event)) {
1881  			return 1;
1882  		}
1883  		if (!event->keyval) {
1884  			return true;
1885  		}
1886  		const bool shift = (event->state & GDK_SHIFT_MASK) != 0;
1887  		bool ctrl = (event->state & GDK_CONTROL_MASK) != 0;
1888  		const bool alt = (event->state & GDK_MOD1_MASK) != 0;
1889  		const bool super = (event->state & GDK_MOD4_MASK) != 0;
1890  		guint key = event->keyval;
1891  		if ((ctrl || alt) && (key < 128))
1892  			key = toupper(key);
1893  #if GTK_CHECK_VERSION(3,0,0)
1894  		else if (!ctrl && (key >= GDK_KEY_KP_Multiply && key <= GDK_KEY_KP_9))
1895  #else
1896  		else if (!ctrl && (key >= GDK_KP_Multiply && key <= GDK_KP_9))
1897  #endif
1898  			key &= 0x7F;
1899  		else if (key >= 0xFE00)
1900  			key = KeyTranslate(key);
1901  		bool consumed = false;
1902  #if !(PLAT_GTK_MACOSX)
1903  		const bool meta = false;
1904  #else
1905  		const bool meta = ctrl;
1906  		ctrl = (event->state & GDK_META_MASK) != 0;
1907  #endif
1908  		const bool added = KeyDownWithModifiers(static_cast<Keys>(key), ModifierFlags(shift, ctrl, alt, meta, super), &consumed) != 0;
1909  		if (!consumed)
1910  			consumed = added;
1911  		if (event->keyval == 0xffffff && event->length > 0) {
1912  			ClearSelection();
1913  			const Sci::Position lengthInserted = pdoc->InsertString(CurrentPosition(), event->string, strlen(event->string));
1914  			if (lengthInserted > 0) {
1915  				MovePositionTo(CurrentPosition() + lengthInserted);
1916  			}
1917  		}
1918  		return consumed;
1919  	} catch (...) {
1920  		errorStatus = Status::Failure;
1921  	}
1922  	return FALSE;
1923  }
1924  gboolean ScintillaGTK::KeyPress(GtkWidget *widget, GdkEventKey *event) {
1925  	ScintillaGTK *sciThis = FromWidget(widget);
1926  	return sciThis->KeyThis(event);
1927  }
1928  gboolean ScintillaGTK::KeyRelease(GtkWidget *widget, GdkEventKey *event) {
1929  	ScintillaGTK *sciThis = FromWidget(widget);
1930  	if (gtk_im_context_filter_keypress(sciThis->im_context.get(), event)) {
1931  		return TRUE;
1932  	}
1933  	return FALSE;
1934  }
1935  #if GTK_CHECK_VERSION(3,0,0)
1936  gboolean ScintillaGTK::DrawPreeditThis(GtkWidget *, cairo_t *cr) {
1937  	try {
1938  		PreEditString pes(im_context.get());
1939  		UniquePangoLayout layout(gtk_widget_create_pango_layout(PWidget(wText), pes.str));
1940  		pango_layout_set_attributes(layout.get(), pes.attrs);
1941  		cairo_move_to(cr, 0, 0);
1942  		pango_cairo_show_layout(cr, layout.get());
1943  	} catch (...) {
1944  		errorStatus = Status::Failure;
1945  	}
1946  	return TRUE;
1947  }
1948  gboolean ScintillaGTK::DrawPreedit(GtkWidget *widget, cairo_t *cr, ScintillaGTK *sciThis) {
1949  	return sciThis->DrawPreeditThis(widget, cr);
1950  }
1951  #else
1952  gboolean ScintillaGTK::ExposePreeditThis(GtkWidget *widget, GdkEventExpose *) {
1953  	try {
1954  		PreEditString pes(im_context.get());
1955  		UniquePangoLayout layout(gtk_widget_create_pango_layout(PWidget(wText), pes.str));
1956  		pango_layout_set_attributes(layout.get(), pes.attrs);
1957  		UniqueCairo context(gdk_cairo_create(WindowFromWidget(widget)));
1958  		cairo_move_to(context.get(), 0, 0);
1959  		pango_cairo_show_layout(context.get(), layout.get());
1960  	} catch (...) {
1961  		errorStatus = Status::Failure;
1962  	}
1963  	return TRUE;
1964  }
1965  gboolean ScintillaGTK::ExposePreedit(GtkWidget *widget, GdkEventExpose *ose, ScintillaGTK *sciThis) {
1966  	return sciThis->ExposePreeditThis(widget, ose);
1967  }
1968  #endif
1969  bool ScintillaGTK::KoreanIME() {
1970  	PreEditString pes(im_context.get());
1971  	if (pes.pscript != G_UNICODE_SCRIPT_COMMON)
1972  		lastNonCommonScript = pes.pscript;
1973  	return lastNonCommonScript == G_UNICODE_SCRIPT_HANGUL;
1974  }
1975  void ScintillaGTK::MoveImeCarets(Sci::Position pos) {
1976  	for (size_t r=0; r<sel.Count(); r++) {
1977  		const Sci::Position positionInsert = sel.Range(r).Start().Position();
1978  		sel.Range(r).caret.SetPosition(positionInsert + pos);
1979  		sel.Range(r).anchor.SetPosition(positionInsert + pos);
1980  	}
1981  }
1982  void ScintillaGTK::DrawImeIndicator(int indicator, Sci::Position len) {
1983  	if (indicator < 8 || indicator > INDICATOR_MAX) {
1984  		return;
1985  	}
1986  	pdoc->DecorationSetCurrentIndicator(indicator);
1987  	for (size_t r=0; r<sel.Count(); r++) {
1988  		const Sci::Position positionInsert = sel.Range(r).Start().Position();
1989  		pdoc->DecorationFillRange(positionInsert - len, 1, len);
1990  	}
1991  }
1992  namespace {
1993  std::vector<int> MapImeIndicators(PangoAttrList *attrs, const char *u8Str) {
1994  	const glong charactersLen = g_utf8_strlen(u8Str, strlen(u8Str));
1995  	std::vector<int> indicator(charactersLen, SC_INDICATOR_UNKNOWN);
1996  	PangoAttrIterator *iterunderline = pango_attr_list_get_iterator(attrs);
1997  	if (iterunderline) {
1998  		do {
1999  			const PangoAttribute  *attrunderline = pango_attr_iterator_get(iterunderline, PANGO_ATTR_UNDERLINE);
2000  			if (attrunderline) {
2001  				const glong start = g_utf8_strlen(u8Str, attrunderline->start_index);
2002  				const glong end = g_utf8_strlen(u8Str, attrunderline->end_index);
2003  				const int ulinevalue = reinterpret_cast<const PangoAttrInt *>(attrunderline)->value;
2004  				const PangoUnderline uline = static_cast<PangoUnderline>(ulinevalue);
2005  				for (glong i=start; i < end; ++i) {
2006  					switch (uline) {
2007  					case PANGO_UNDERLINE_NONE:
2008  						indicator[i] = SC_INDICATOR_UNKNOWN;
2009  						break;
2010  					case PANGO_UNDERLINE_SINGLE: 
2011  						indicator[i] = SC_INDICATOR_INPUT;
2012  						break;
2013  					case PANGO_UNDERLINE_DOUBLE:
2014  					case PANGO_UNDERLINE_LOW:
2015  					case PANGO_UNDERLINE_ERROR:
2016  					default:
2017  						break;
2018  					}
2019  				}
2020  			}
2021  		} while (pango_attr_iterator_next(iterunderline));
2022  		pango_attr_iterator_destroy(iterunderline);
2023  	}
2024  	PangoAttrIterator *itercolor = pango_attr_list_get_iterator(attrs);
2025  	if (itercolor) {
2026  		do {
2027  			const PangoAttribute *backcolor = pango_attr_iterator_get(itercolor, PANGO_ATTR_BACKGROUND);
2028  			if (backcolor) {
2029  				const glong start = g_utf8_strlen(u8Str, backcolor->start_index);
2030  				const glong end = g_utf8_strlen(u8Str, backcolor->end_index);
2031  				for (glong i=start; i < end; ++i) {
2032  					indicator[i] = SC_INDICATOR_TARGET;  
2033  				}
2034  			}
2035  		} while (pango_attr_iterator_next(itercolor));
2036  		pango_attr_iterator_destroy(itercolor);
2037  	}
2038  	return indicator;
2039  }
2040  }
2041  void ScintillaGTK::SetCandidateWindowPos() {
2042  	const Point pt = PointMainCaret();
2043  	GdkRectangle imeBox {};
2044  	imeBox.x = static_cast<gint>(pt.x);
2045  	imeBox.y = static_cast<gint>(pt.y + std::max(4, vs.lineHeight/4));
2046  	imeBox.height = vs.lineHeight;
2047  	gtk_im_context_set_cursor_location(im_context.get(), &imeBox);
2048  }
2049  void ScintillaGTK::CommitThis(char *commitStr) {
2050  	try {
2051  		view.imeCaretBlockOverride = false;
2052  		if (pdoc->TentativeActive()) {
2053  			pdoc->TentativeUndo();
2054  		}
2055  		const char *charSetSource = CharacterSetID();
2056  		glong uniStrLen = 0;
2057  		gunichar *uniStr = g_utf8_to_ucs4_fast(commitStr, static_cast<glong>(strlen(commitStr)), &uniStrLen);
2058  		for (glong i = 0; i < uniStrLen; i++) {
2059  			gchar u8Char[UTF8MaxBytes+2] = {0};
2060  			const gint u8CharLen = g_unichar_to_utf8(uniStr[i], u8Char);
2061  			std::string docChar = u8Char;
2062  			if (!IsUnicodeMode())
2063  				docChar = ConvertText(u8Char, u8CharLen, charSetSource, "UTF-8", true);
2064  			InsertCharacter(docChar, CharacterSource::DirectInput);
2065  		}
2066  		g_free(uniStr);
2067  		ShowCaretAtCurrentPosition();
2068  	} catch (...) {
2069  		errorStatus = Status::Failure;
2070  	}
2071  }
2072  void ScintillaGTK::Commit(GtkIMContext *, char  *str, ScintillaGTK *sciThis) {
2073  	sciThis->CommitThis(str);
2074  }
2075  void ScintillaGTK::PreeditChangedInlineThis() {
2076  	try {
2077  		if (pdoc->IsReadOnly() || SelectionContainsProtected()) {
2078  			gtk_im_context_reset(im_context.get());
2079  			return;
2080  		}
2081  		view.imeCaretBlockOverride = false; 
2082  		bool initialCompose = false;
2083  		if (pdoc->TentativeActive()) {
2084  			pdoc->TentativeUndo();
2085  		} else {
2086  			initialCompose = true;
2087  		}
2088  		PreEditString preeditStr(im_context.get());
2089  		const char *charSetSource = CharacterSetID();
2090  		if (!preeditStr.validUTF8 || (charSetSource == nullptr)) {
2091  			ShowCaretAtCurrentPosition();
2092  			return;
2093  		}
2094  		if (preeditStr.uniStrLen == 0) {
2095  			ShowCaretAtCurrentPosition();
2096  			return;
2097  		}
2098  		if (initialCompose) {
2099  			ClearBeforeTentativeStart();
2100  		}
2101  		SetCandidateWindowPos();
2102  		pdoc->TentativeStart(); 
2103  		std::vector<int> indicator = MapImeIndicators(preeditStr.attrs, preeditStr.str);
2104  		for (glong i = 0; i < preeditStr.uniStrLen; i++) {
2105  			gchar u8Char[UTF8MaxBytes+2] = {0};
2106  			const gint u8CharLen = g_unichar_to_utf8(preeditStr.uniStr[i], u8Char);
2107  			std::string docChar = u8Char;
2108  			if (!IsUnicodeMode())
2109  				docChar = ConvertText(u8Char, u8CharLen, charSetSource, "UTF-8", true);
2110  			InsertCharacter(docChar, CharacterSource::TentativeInput);
2111  			DrawImeIndicator(indicator[i], docChar.size());
2112  		}
2113  		const int imeEndToImeCaretU32 = preeditStr.cursor_pos - preeditStr.uniStrLen;
2114  		const Sci::Position imeCaretPosDoc = pdoc->GetRelativePosition(CurrentPosition(), imeEndToImeCaretU32);
2115  		MoveImeCarets(- CurrentPosition() + imeCaretPosDoc);
2116  		if (KoreanIME()) {
2117  #if !PLAT_GTK_WIN32
2118  			if (preeditStr.cursor_pos > 0) {
2119  				int oneCharBefore = pdoc->GetRelativePosition(CurrentPosition(), -1);
2120  				MoveImeCarets(- CurrentPosition() + oneCharBefore);
2121  			}
2122  #endif
2123  			view.imeCaretBlockOverride = true;
2124  		}
2125  		EnsureCaretVisible();
2126  		ShowCaretAtCurrentPosition();
2127  	} catch (...) {
2128  		errorStatus = Status::Failure;
2129  	}
2130  }
2131  void ScintillaGTK::PreeditChangedWindowedThis() {
2132  	try {
2133  		PreEditString pes(im_context.get());
2134  		if (strlen(pes.str) > 0) {
2135  			SetCandidateWindowPos();
2136  			UniquePangoLayout layout(gtk_widget_create_pango_layout(PWidget(wText), pes.str));
2137  			pango_layout_set_attributes(layout.get(), pes.attrs);
2138  			gint w, h;
2139  			pango_layout_get_pixel_size(layout.get(), &w, &h);
2140  			gint x, y;
2141  			gdk_window_get_origin(PWindow(wText), &x, &y);
2142  			Point pt = PointMainCaret();
2143  			if (pt.x < 0)
2144  				pt.x = 0;
2145  			if (pt.y < 0)
2146  				pt.y = 0;
2147  			gtk_window_move(GTK_WINDOW(PWidget(wPreedit)), x + static_cast<gint>(pt.x), y + static_cast<gint>(pt.y));
2148  			gtk_window_resize(GTK_WINDOW(PWidget(wPreedit)), w, h);
2149  			gtk_widget_show(PWidget(wPreedit));
2150  			gtk_widget_queue_draw_area(PWidget(wPreeditDraw), 0, 0, w, h);
2151  		} else {
2152  			gtk_widget_hide(PWidget(wPreedit));
2153  		}
2154  	} catch (...) {
2155  		errorStatus = Status::Failure;
2156  	}
2157  }
2158  void ScintillaGTK::PreeditChanged(GtkIMContext *, ScintillaGTK *sciThis) {
2159  	if ((sciThis->imeInteraction == IMEInteraction::Inline) || (sciThis->KoreanIME())) {
2160  		sciThis->PreeditChangedInlineThis();
2161  	} else {
2162  		sciThis->PreeditChangedWindowedThis();
2163  	}
2164  }
2165  bool ScintillaGTK::RetrieveSurroundingThis(GtkIMContext *context) {
2166  	try {
2167  		const Sci::Position pos = CurrentPosition();
2168  		const int line = pdoc->LineFromPosition(pos);
2169  		const Sci::Position startByte = pdoc->LineStart(line);
2170  		const Sci::Position endByte = pdoc->LineEnd(line);
2171  		std::string utf8Text;
2172  		gint cursorIndex; 
2173  		const char *charSetBuffer;
2174  		if (IsUnicodeMode() || ! *(charSetBuffer = CharacterSetID())) {
2175  			utf8Text = RangeText(startByte, endByte);
2176  			cursorIndex = pos - startByte;
2177  		} else {
2178  			std::string tmpbuf = RangeText(startByte, pos);
2179  			utf8Text = ConvertText(&tmpbuf[0], tmpbuf.length(), "UTF-8", charSetBuffer, false);
2180  			cursorIndex = utf8Text.length();
2181  			if (endByte > pos) {
2182  				tmpbuf = RangeText(pos, endByte);
2183  				utf8Text += ConvertText(&tmpbuf[0], tmpbuf.length(), "UTF-8", charSetBuffer, false);
2184  			}
2185  		}
2186  		gtk_im_context_set_surrounding(context, &utf8Text[0], utf8Text.length(), cursorIndex);
2187  		return true;
2188  	} catch (...) {
2189  		errorStatus = Status::Failure;
2190  	}
2191  	return false;
2192  }
2193  gboolean ScintillaGTK::RetrieveSurrounding(GtkIMContext *context, ScintillaGTK *sciThis) {
2194  	return sciThis->RetrieveSurroundingThis(context);
2195  }
2196  bool ScintillaGTK::DeleteSurroundingThis(GtkIMContext *, gint characterOffset, gint characterCount) {
2197  	try {
2198  		const Sci::Position startByte = pdoc->GetRelativePosition(CurrentPosition(), characterOffset);
2199  		if (startByte == INVALID_POSITION)
2200  			return false;
2201  		const Sci::Position endByte = pdoc->GetRelativePosition(startByte, characterCount);
2202  		if (endByte == INVALID_POSITION)
2203  			return false;
2204  		return pdoc->DeleteChars(startByte, endByte - startByte);
2205  	} catch (...) {
2206  		errorStatus = Status::Failure;
2207  	}
2208  	return false;
2209  }
2210  gboolean ScintillaGTK::DeleteSurrounding(GtkIMContext *context, gint characterOffset, gint characterCount, ScintillaGTK *sciThis) {
2211  	return sciThis->DeleteSurroundingThis(context, characterOffset, characterCount);
2212  }
2213  void ScintillaGTK::StyleSetText(GtkWidget *widget, GtkStyle *, void *) {
2214  	RealizeText(widget, nullptr);
2215  }
2216  void ScintillaGTK::RealizeText(GtkWidget *widget, void *) {
2217  	if (WindowFromWidget(widget)) {
2218  #if GTK_CHECK_VERSION(3,22,0)
2219  #elif GTK_CHECK_VERSION(3,0,0)
2220  		gdk_window_set_background_pattern(WindowFromWidget(widget), nullptr);
2221  #else
2222  		gdk_window_set_back_pixmap(WindowFromWidget(widget), nullptr, FALSE);
2223  #endif
2224  	}
2225  }
2226  static GObjectClass *scintilla_class_parent_class;
2227  void ScintillaGTK::Dispose(GObject *object) {
2228  	try {
2229  		ScintillaObject *scio = SCINTILLA(object);
2230  		ScintillaGTK *sciThis = static_cast<ScintillaGTK *>(scio->pscin);
2231  		if (PWidget(sciThis->scrollbarv)) {
2232  			gtk_widget_unparent(PWidget(sciThis->scrollbarv));
2233  			sciThis->scrollbarv = nullptr;
2234  		}
2235  		if (PWidget(sciThis->scrollbarh)) {
2236  			gtk_widget_unparent(PWidget(sciThis->scrollbarh));
2237  			sciThis->scrollbarh = nullptr;
2238  		}
2239  		scintilla_class_parent_class->dispose(object);
2240  	} catch (...) {
2241  	}
2242  }
2243  void ScintillaGTK::Destroy(GObject *object) {
2244  	try {
2245  		ScintillaObject *scio = SCINTILLA(object);
2246  		if (!scio->pscin)
2247  			return;
2248  		ScintillaGTK *sciThis = static_cast<ScintillaGTK *>(scio->pscin);
2249  		sciThis->Finalise();
2250  		delete sciThis;
2251  		scio->pscin = nullptr;
2252  		scintilla_class_parent_class->finalize(object);
2253  	} catch (...) {
2254  	}
2255  }
2256  void ScintillaGTK::CheckForFontOptionChange() {
2257  	const FontOptions fontOptionsNow(PWidget(wText));
2258  	if (!(fontOptionsNow == fontOptionsPrevious)) {
2259  		InvalidateStyleData();
2260  	}
2261  	fontOptionsPrevious = fontOptionsNow;
2262  }
2263  #if GTK_CHECK_VERSION(3,0,0)
2264  gboolean ScintillaGTK::DrawTextThis(cairo_t *cr) {
2265  	try {
2266  		CheckForFontOptionChange();
2267  		paintState = PaintState::painting;
2268  		repaintFullWindow = false;
2269  		rcPaint = GetClientRectangle();
2270  		cairo_rectangle_list_t *oldRgnUpdate = rgnUpdate;
2271  		rgnUpdate = cairo_copy_clip_rectangle_list(cr);
2272  		if (rgnUpdate && rgnUpdate->status != CAIRO_STATUS_SUCCESS) {
2273  			fprintf(stderr, "DrawTextThis failed to copy update region %d [%d]\n", rgnUpdate->status, rgnUpdate->num_rectangles);
2274  			cairo_rectangle_list_destroy(rgnUpdate);
2275  			rgnUpdate = nullptr;
2276  		}
2277  		double x1, y1, x2, y2;
2278  		cairo_clip_extents(cr, &x1, &y1, &x2, &y2);
2279  		rcPaint.left = x1;
2280  		rcPaint.top = y1;
2281  		rcPaint.right = x2;
2282  		rcPaint.bottom = y2;
<span onclick='openModal()' class='match'>2283  		PRectangle rcClient = GetClientRectangle();
2284  		paintingAllText = rcPaint.Contains(rcClient);
2285  		std::unique_ptr<Surface> surfaceWindow(Surface::Allocate(Technology::Default));
</span>2286  		surfaceWindow->Init(cr, PWidget(wText));
2287  		Paint(surfaceWindow.get(), rcPaint);
2288  		surfaceWindow->Release();
2289  		if ((paintState == PaintState::abandoned) || repaintFullWindow) {
2290  			FullPaint();
2291  		}
2292  		paintState = PaintState::notPainting;
2293  		repaintFullWindow = false;
2294  		if (rgnUpdate) {
2295  			cairo_rectangle_list_destroy(rgnUpdate);
2296  		}
2297  		rgnUpdate = oldRgnUpdate;
2298  		paintState = PaintState::notPainting;
2299  	} catch (...) {
2300  		errorStatus = Status::Failure;
2301  	}
2302  	return FALSE;
2303  }
2304  gboolean ScintillaGTK::DrawText(GtkWidget *, cairo_t *cr, ScintillaGTK *sciThis) {
2305  	return sciThis->DrawTextThis(cr);
2306  }
2307  gboolean ScintillaGTK::DrawThis(cairo_t *cr) {
2308  	try {
2309  #ifdef GTK_STYLE_CLASS_SCROLLBARS_JUNCTION &bsol;* GTK >= 3.4 */
2310  		if (verticalScrollBarVisible && horizontalScrollBarVisible && !Wrapping()) {
2311  			GtkStyleContext *styleContext = gtk_widget_get_style_context(PWidget(wMain));
2312  			PRectangle rc = GetClientRectangle();
2313  			gtk_style_context_save(styleContext);
2314  			gtk_style_context_add_class(styleContext, GTK_STYLE_CLASS_SCROLLBARS_JUNCTION);
2315  			gtk_render_background(styleContext, cr, rc.right, rc.bottom,
2316  					      verticalScrollBarWidth, horizontalScrollBarHeight);
2317  			gtk_render_frame(styleContext, cr, rc.right, rc.bottom,
2318  					 verticalScrollBarWidth, horizontalScrollBarHeight);
2319  			gtk_style_context_restore(styleContext);
2320  		}
2321  #endif
2322  		gtk_container_propagate_draw(
2323  			GTK_CONTAINER(PWidget(wMain)), PWidget(scrollbarh), cr);
2324  		gtk_container_propagate_draw(
2325  			GTK_CONTAINER(PWidget(wMain)), PWidget(scrollbarv), cr);
2326  #if GTK_CHECK_VERSION(3,0,0)
2327  		if (gtk_check_version(3, 9, 2) == nullptr) {
2328  			gtk_container_propagate_draw(
2329  				GTK_CONTAINER(PWidget(wMain)), PWidget(wText), cr);
2330  		}
2331  #endif
2332  	} catch (...) {
2333  		errorStatus = Status::Failure;
2334  	}
2335  	return FALSE;
2336  }
2337  gboolean ScintillaGTK::DrawMain(GtkWidget *widget, cairo_t *cr) {
2338  	ScintillaGTK *sciThis = FromWidget(widget);
2339  	return sciThis->DrawThis(cr);
2340  }
2341  #else
2342  gboolean ScintillaGTK::ExposeTextThis(GtkWidget * &bsol;*widget*/, GdkEventExpose *ose) {
2343  	try {
2344  		CheckForFontOptionChange();
2345  		paintState = PaintState::painting;
2346  		rcPaint = PRectangle::FromInts(
2347  				  ose->area.x,
2348  				  ose->area.y,
2349  				  ose->area.x + ose->area.width,
2350  				  ose->area.y + ose->area.height);
2351  		GdkRegion *oldRgnUpdate = rgnUpdate;
2352  		rgnUpdate = gdk_region_copy(ose->region);
2353  		const PRectangle rcClient = GetClientRectangle();
2354  		paintingAllText = rcPaint.Contains(rcClient);
2355  		{
2356  			std::unique_ptr<Surface> surfaceWindow(Surface::Allocate(Technology::Default));
2357  			UniqueCairo cr(gdk_cairo_create(PWindow(wText)));
2358  			surfaceWindow->Init(cr.get(), PWidget(wText));
2359  			Paint(surfaceWindow.get(), rcPaint);
2360  		}
2361  		if ((paintState == PaintState::abandoned) || repaintFullWindow) {
2362  			FullPaint();
2363  		}
2364  		paintState = PaintState::notPainting;
2365  		repaintFullWindow = false;
2366  		if (rgnUpdate) {
2367  			gdk_region_destroy(rgnUpdate);
2368  		}
2369  		rgnUpdate = oldRgnUpdate;
2370  	} catch (...) {
2371  		errorStatus = Status::Failure;
2372  	}
2373  	return FALSE;
2374  }
2375  gboolean ScintillaGTK::ExposeText(GtkWidget *widget, GdkEventExpose *ose, ScintillaGTK *sciThis) {
2376  	return sciThis->ExposeTextThis(widget, ose);
2377  }
2378  gboolean ScintillaGTK::ExposeMain(GtkWidget *widget, GdkEventExpose *ose) {
2379  	ScintillaGTK *sciThis = FromWidget(widget);
2380  	return sciThis->Expose(widget, ose);
2381  }
2382  gboolean ScintillaGTK::Expose(GtkWidget *, GdkEventExpose *ose) {
2383  	try {
2384  		gtk_container_propagate_expose(
2385  			GTK_CONTAINER(PWidget(wMain)), PWidget(scrollbarh), ose);
2386  		gtk_container_propagate_expose(
2387  			GTK_CONTAINER(PWidget(wMain)), PWidget(scrollbarv), ose);
2388  	} catch (...) {
2389  		errorStatus = Status::Failure;
2390  	}
2391  	return FALSE;
2392  }
2393  #endif
2394  void ScintillaGTK::ScrollSignal(GtkAdjustment *adj, ScintillaGTK *sciThis) {
2395  	try {
2396  		sciThis->ScrollTo(static_cast<int>(gtk_adjustment_get_value(adj)), false);
2397  	} catch (...) {
2398  		sciThis->errorStatus = Status::Failure;
2399  	}
2400  }
2401  void ScintillaGTK::ScrollHSignal(GtkAdjustment *adj, ScintillaGTK *sciThis) {
2402  	try {
2403  		sciThis->HorizontalScrollTo(static_cast<int>(gtk_adjustment_get_value(adj)));
2404  	} catch (...) {
2405  		sciThis->errorStatus = Status::Failure;
2406  	}
2407  }
2408  void ScintillaGTK::SelectionReceived(GtkWidget *widget,
2409  				     GtkSelectionData *selection_data, guint) {
2410  	ScintillaGTK *sciThis = FromWidget(widget);
2411  	sciThis->ReceivedSelection(selection_data);
2412  }
2413  void ScintillaGTK::SelectionGet(GtkWidget *widget,
2414  				GtkSelectionData *selection_data, guint info, guint) {
2415  	ScintillaGTK *sciThis = FromWidget(widget);
2416  	try {
2417  		if (SelectionOfGSD(selection_data) == GDK_SELECTION_PRIMARY) {
2418  			if (sciThis->primary.Empty()) {
2419  				sciThis->CopySelectionRange(&sciThis->primary);
2420  			}
2421  			sciThis->GetSelection(selection_data, info, &sciThis->primary);
2422  		}
2423  	} catch (...) {
2424  		sciThis->errorStatus = Status::Failure;
2425  	}
2426  }
2427  gint ScintillaGTK::SelectionClear(GtkWidget *widget, GdkEventSelection *selection_event) {
2428  	ScintillaGTK *sciThis = FromWidget(widget);
2429  	sciThis->UnclaimSelection(selection_event);
2430  	if (GTK_WIDGET_CLASS(sciThis->parentClass)->selection_clear_event) {
2431  		return GTK_WIDGET_CLASS(sciThis->parentClass)->selection_clear_event(widget, selection_event);
2432  	}
2433  	return TRUE;
2434  }
2435  gboolean ScintillaGTK::DragMotionThis(GdkDragContext *context,
2436  				      gint x, gint y, guint dragtime) {
2437  	try {
2438  		const Point npt = Point::FromInts(x, y);
2439  		SetDragPosition(SPositionFromLocation(npt, false, false, UserVirtualSpace()));
2440  		GdkDragAction preferredAction = gdk_drag_context_get_suggested_action(context);
2441  		const GdkDragAction actions = gdk_drag_context_get_actions(context);
2442  		const SelectionPosition pos = SPositionFromLocation(npt);
2443  		if ((inDragDrop == DragDrop::dragging) && (PositionInSelection(pos.Position()))) {
2444  			preferredAction = static_cast<GdkDragAction>(0);
2445  		} else if (actions == actionCopyOrMove) {
2446  			preferredAction = GDK_ACTION_MOVE;
2447  		}
2448  		gdk_drag_status(context, preferredAction, dragtime);
2449  	} catch (...) {
2450  		errorStatus = Status::Failure;
2451  	}
2452  	return FALSE;
2453  }
2454  gboolean ScintillaGTK::DragMotion(GtkWidget *widget, GdkDragContext *context,
2455  				  gint x, gint y, guint dragtime) {
2456  	ScintillaGTK *sciThis = FromWidget(widget);
2457  	return sciThis->DragMotionThis(context, x, y, dragtime);
2458  }
2459  void ScintillaGTK::DragLeave(GtkWidget *widget, GdkDragContext * &bsol;*context*/, guint) {
2460  	ScintillaGTK *sciThis = FromWidget(widget);
2461  	try {
2462  		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
2463  	} catch (...) {
2464  		sciThis->errorStatus = Status::Failure;
2465  	}
2466  }
2467  void ScintillaGTK::DragEnd(GtkWidget *widget, GdkDragContext * &bsol;*context*/) {
2468  	ScintillaGTK *sciThis = FromWidget(widget);
2469  	try {
2470  		if (!sciThis->dragWasDropped)
2471  			sciThis->SetEmptySelection(sciThis->posDrag);
2472  		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
2473  		sciThis->inDragDrop = DragDrop::none;
2474  	} catch (...) {
2475  		sciThis->errorStatus = Status::Failure;
2476  	}
2477  }
2478  gboolean ScintillaGTK::Drop(GtkWidget *widget, GdkDragContext * &bsol;*context*/,
2479  			    gint, gint, guint) {
2480  	ScintillaGTK *sciThis = FromWidget(widget);
2481  	try {
2482  		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
2483  	} catch (...) {
2484  		sciThis->errorStatus = Status::Failure;
2485  	}
2486  	return FALSE;
2487  }
2488  void ScintillaGTK::DragDataReceived(GtkWidget *widget, GdkDragContext * &bsol;*context*/,
2489  				    gint, gint, GtkSelectionData *selection_data, guint &bsol;*info*/, guint) {
2490  	ScintillaGTK *sciThis = FromWidget(widget);
2491  	try {
2492  		sciThis->ReceivedDrop(selection_data);
2493  		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
2494  	} catch (...) {
2495  		sciThis->errorStatus = Status::Failure;
2496  	}
2497  }
2498  void ScintillaGTK::DragDataGet(GtkWidget *widget, GdkDragContext *context,
2499  			       GtkSelectionData *selection_data, guint info, guint) {
2500  	ScintillaGTK *sciThis = FromWidget(widget);
2501  	try {
2502  		sciThis->dragWasDropped = true;
2503  		if (!sciThis->sel.Empty()) {
2504  			sciThis->GetSelection(selection_data, info, &sciThis->drag);
2505  		}
2506  		const GdkDragAction action = gdk_drag_context_get_selected_action(context);
2507  		if (action == GDK_ACTION_MOVE) {
2508  			for (size_t r=0; r<sciThis->sel.Count(); r++) {
2509  				if (sciThis->posDrop >= sciThis->sel.Range(r).Start()) {
2510  					if (sciThis->posDrop > sciThis->sel.Range(r).End()) {
2511  						sciThis->posDrop.Add(-sciThis->sel.Range(r).Length());
2512  					} else {
2513  						sciThis->posDrop.Add(-SelectionRange(sciThis->posDrop, sciThis->sel.Range(r).Start()).Length());
2514  					}
2515  				}
2516  			}
2517  			sciThis->ClearSelection();
2518  		}
2519  		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
2520  	} catch (...) {
2521  		sciThis->errorStatus = Status::Failure;
2522  	}
2523  }
2524  int ScintillaGTK::TimeOut(gpointer ptt) {
2525  	TimeThunk *tt = static_cast<TimeThunk *>(ptt);
2526  	tt->scintilla->TickFor(tt->reason);
2527  	return 1;
2528  }
2529  gboolean ScintillaGTK::IdleCallback(gpointer pSci) {
2530  	ScintillaGTK *sciThis = static_cast<ScintillaGTK *>(pSci);
2531  	const bool ret = sciThis->Idle();
2532  	if (!ret) {
2533  		sciThis->SetIdle(false);
2534  	}
2535  	return ret;
2536  }
2537  gboolean ScintillaGTK::StyleIdle(gpointer pSci) {
2538  	ScintillaGTK *sciThis = static_cast<ScintillaGTK *>(pSci);
2539  	sciThis->IdleWork();
2540  	return FALSE;
2541  }
2542  void ScintillaGTK::IdleWork() {
2543  	Editor::IdleWork();
2544  	styleIdleID = 0;
2545  }
2546  void ScintillaGTK::QueueIdleWork(WorkItems items, Sci::Position upTo) {
2547  	Editor::QueueIdleWork(items, upTo);
2548  	if (!styleIdleID) {
2549  		styleIdleID = gdk_threads_add_idle_full(G_PRIORITY_HIGH_IDLE, StyleIdle, this, nullptr);
2550  	}
2551  }
2552  void ScintillaGTK::SetDocPointer(Document *document) {
2553  	Document *oldDoc = nullptr;
2554  	ScintillaGTKAccessible *sciAccessible = nullptr;
2555  	if (accessible) {
2556  		sciAccessible = ScintillaGTKAccessible::FromAccessible(accessible);
2557  		if (sciAccessible && pdoc) {
2558  			oldDoc = pdoc;
2559  			oldDoc->AddRef();
2560  		}
2561  	}
2562  	Editor::SetDocPointer(document);
2563  	if (sciAccessible) {
2564  		sciAccessible->ChangeDocument(oldDoc, pdoc);
2565  	}
2566  	if (oldDoc) {
2567  		oldDoc->Release();
2568  	}
2569  }
2570  void ScintillaGTK::PopUpCB(GtkMenuItem *menuItem, ScintillaGTK *sciThis) {
2571  	guint const action = GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(menuItem), "CmdNum"));
2572  	if (action) {
2573  		sciThis->Command(action);
2574  	}
2575  }
2576  gboolean ScintillaGTK::PressCT(GtkWidget *widget, GdkEventButton *event, ScintillaGTK *sciThis) {
2577  	try {
2578  		if (event->window != WindowFromWidget(widget))
2579  			return FALSE;
2580  		if (event->type != GDK_BUTTON_PRESS)
2581  			return FALSE;
2582  		const Point pt = PointOfEvent(event);
2583  		sciThis->ct.MouseClick(pt);
2584  		sciThis->CallTipClick();
2585  	} catch (...) {
2586  	}
2587  	return TRUE;
2588  }
2589  #if GTK_CHECK_VERSION(3,0,0)
2590  gboolean ScintillaGTK::DrawCT(GtkWidget *widget, cairo_t *cr, CallTip *ctip) {
2591  	try {
2592  		std::unique_ptr<Surface> surfaceWindow(Surface::Allocate(Technology::Default));
2593  		surfaceWindow->Init(cr, widget);
2594  		surfaceWindow->SetMode(SurfaceMode(ctip->codePage, false));
2595  		ctip->PaintCT(surfaceWindow.get());
2596  		surfaceWindow->Release();
2597  	} catch (...) {
2598  	}
2599  	return TRUE;
2600  }
2601  #else
2602  gboolean ScintillaGTK::ExposeCT(GtkWidget *widget, GdkEventExpose * &bsol;*ose*/, CallTip *ctip) {
2603  	try {
2604  		std::unique_ptr<Surface> surfaceWindow(Surface::Allocate(Technology::Default));
2605  		UniqueCairo cr(gdk_cairo_create(WindowFromWidget(widget)));
2606  		surfaceWindow->Init(cr.get(), widget);
2607  		surfaceWindow->SetMode(SurfaceMode(ctip->codePage, false));
2608  		ctip->PaintCT(surfaceWindow.get());
2609  	} catch (...) {
2610  	}
2611  	return TRUE;
2612  }
2613  #endif
2614  AtkObject *ScintillaGTK::GetAccessibleThis(GtkWidget *widget) {
2615  	return ScintillaGTKAccessible::WidgetGetAccessibleImpl(widget, &accessible, scintilla_class_parent_class);
2616  }
2617  AtkObject *ScintillaGTK::GetAccessible(GtkWidget *widget) {
2618  	return FromWidget(widget)->GetAccessibleThis(widget);
2619  }
2620  sptr_t ScintillaGTK::DirectFunction(
2621  	sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
2622  	ScintillaGTK *sci = reinterpret_cast<ScintillaGTK *>(ptr);
2623  	return sci->WndProc(static_cast<Message>(iMessage), wParam, lParam);
2624  }
2625  sptr_t ScintillaGTK::DirectStatusFunction(
2626  	sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam, int *pStatus) {
2627  	ScintillaGTK *sci = reinterpret_cast<ScintillaGTK *>(ptr);
2628  	const sptr_t returnValue = sci->WndProc(static_cast<Message>(iMessage), wParam, lParam);
2629  	*pStatus = static_cast<int>(sci->errorStatus);
2630  	return returnValue;
2631  }
2632  sptr_t scintilla_send_message(ScintillaObject *sci, unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
2633  	ScintillaGTK *psci = static_cast<ScintillaGTK *>(sci->pscin);
2634  	return psci->WndProc(static_cast<Message>(iMessage), wParam, lParam);
2635  }
2636  gintptr scintilla_object_send_message(ScintillaObject *sci, unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
2637  	return scintilla_send_message(sci, iMessage, wParam, lParam);
2638  }
2639  static void scintilla_class_init(ScintillaClass *klass);
2640  static void scintilla_init(ScintillaObject *sci);
2641  GType scintilla_get_type() {
2642  	static GType scintilla_type = 0;
2643  	try {
2644  		if (!scintilla_type) {
2645  			scintilla_type = g_type_from_name("ScintillaObject");
2646  			if (!scintilla_type) {
2647  				static GTypeInfo scintilla_info = {
2648  					(guint16) sizeof(ScintillaObjectClass),
2649  					nullptr, 
2650  					nullptr, 
2651  					(GClassInitFunc) scintilla_class_init,
2652  					nullptr, 
2653  					nullptr, 
2654  					(guint16) sizeof(ScintillaObject),
2655  					0, 
2656  					(GInstanceInitFunc) scintilla_init,
2657  					nullptr 
2658  				};
2659  				scintilla_type = g_type_register_static(
2660  							 GTK_TYPE_CONTAINER, "ScintillaObject", &scintilla_info, (GTypeFlags) 0);
2661  			}
2662  		}
2663  	} catch (...) {
2664  	}
2665  	return scintilla_type;
2666  }
2667  GType scintilla_object_get_type() {
2668  	return scintilla_get_type();
2669  }
2670  void ScintillaGTK::ClassInit(OBJECT_CLASS *object_class, GtkWidgetClass *widget_class, GtkContainerClass *container_class) {
2671  	Platform_Initialise();
2672  	atomUTF8 = gdk_atom_intern("UTF8_STRING", FALSE);
2673  	atomUTF8Mime = gdk_atom_intern("text/plain;charset=utf-8", FALSE);
2674  	atomString = GDK_SELECTION_TYPE_STRING;
2675  	atomUriList = gdk_atom_intern("text/uri-list", FALSE);
2676  	atomDROPFILES_DND = gdk_atom_intern("DROPFILES_DND", FALSE);
2677  	object_class->dispose = Dispose;
2678  	object_class->finalize = Destroy;
2679  #if GTK_CHECK_VERSION(3,0,0)
2680  	widget_class->get_preferred_width = GetPreferredWidth;
2681  	widget_class->get_preferred_height = GetPreferredHeight;
2682  #else
2683  	widget_class->size_request = SizeRequest;
2684  #endif
2685  	widget_class->size_allocate = SizeAllocate;
2686  #if GTK_CHECK_VERSION(3,0,0)
2687  	widget_class->draw = DrawMain;
2688  #else
2689  	widget_class->expose_event = ExposeMain;
2690  #endif
2691  	widget_class->motion_notify_event = Motion;
2692  	widget_class->button_press_event = Press;
2693  	widget_class->button_release_event = MouseRelease;
2694  	widget_class->scroll_event = ScrollEvent;
2695  	widget_class->key_press_event = KeyPress;
2696  	widget_class->key_release_event = KeyRelease;
2697  	widget_class->focus_in_event = FocusIn;
2698  	widget_class->focus_out_event = FocusOut;
2699  	widget_class->selection_received = SelectionReceived;
2700  	widget_class->selection_get = SelectionGet;
2701  	widget_class->selection_clear_event = SelectionClear;
2702  	widget_class->drag_data_received = DragDataReceived;
2703  	widget_class->drag_motion = DragMotion;
2704  	widget_class->drag_leave = DragLeave;
2705  	widget_class->drag_end = DragEnd;
2706  	widget_class->drag_drop = Drop;
2707  	widget_class->drag_data_get = DragDataGet;
2708  	widget_class->realize = Realize;
2709  	widget_class->unrealize = UnRealize;
2710  	widget_class->map = Map;
2711  	widget_class->unmap = UnMap;
2712  	widget_class->get_accessible = GetAccessible;
2713  	container_class->forall = MainForAll;
2714  }
2715  static void scintilla_class_init(ScintillaClass *klass) {
2716  	try {
2717  		OBJECT_CLASS *object_class = reinterpret_cast<OBJECT_CLASS *>(klass);
2718  		GtkWidgetClass *widget_class = reinterpret_cast<GtkWidgetClass *>(klass);
2719  		GtkContainerClass *container_class = reinterpret_cast<GtkContainerClass *>(klass);
2720  		const GSignalFlags sigflags = static_cast<GSignalFlags>(G_SIGNAL_ACTION | G_SIGNAL_RUN_LAST);
2721  		scintilla_signals[COMMAND_SIGNAL] = g_signal_new(
2722  				"command",
2723  				G_TYPE_FROM_CLASS(object_class),
2724  				sigflags,
2725  				G_STRUCT_OFFSET(ScintillaClass, command),
2726  				nullptr, 
2727  				nullptr, 
2728  				scintilla_marshal_VOID__INT_OBJECT,
2729  				G_TYPE_NONE,
2730  				2, G_TYPE_INT, GTK_TYPE_WIDGET);
2731  		scintilla_signals[NOTIFY_SIGNAL] = g_signal_new(
2732  				SCINTILLA_NOTIFY,
2733  				G_TYPE_FROM_CLASS(object_class),
2734  				sigflags,
2735  				G_STRUCT_OFFSET(ScintillaClass, notify),
2736  				nullptr, 
2737  				nullptr, 
2738  				scintilla_marshal_VOID__INT_BOXED,
2739  				G_TYPE_NONE,
2740  				2, G_TYPE_INT, SCINTILLA_TYPE_NOTIFICATION);
2741  		klass->command = nullptr;
2742  		klass->notify = nullptr;
2743  		scintilla_class_parent_class = G_OBJECT_CLASS(g_type_class_peek_parent(klass));
2744  		ScintillaGTK::ClassInit(object_class, widget_class, container_class);
2745  	} catch (...) {
2746  	}
2747  }
2748  static void scintilla_init(ScintillaObject *sci) {
2749  	try {
2750  		gtk_widget_set_can_focus(GTK_WIDGET(sci), TRUE);
2751  		sci->pscin = new ScintillaGTK(sci);
2752  	} catch (...) {
2753  	}
2754  }
2755  GtkWidget *scintilla_new() {
2756  	GtkWidget *widget = GTK_WIDGET(g_object_new(scintilla_get_type(), nullptr));
2757  	gtk_widget_set_direction(widget, GTK_TEXT_DIR_LTR);
2758  	return widget;
2759  }
2760  GtkWidget *scintilla_object_new() {
2761  	return scintilla_new();
2762  }
2763  void scintilla_set_id(ScintillaObject *sci, uptr_t id) {
2764  	ScintillaGTK *psci = static_cast<ScintillaGTK *>(sci->pscin);
2765  	psci->ctrlID = static_cast<int>(id);
2766  }
2767  void scintilla_release_resources(void) {
2768  	try {
2769  		Platform_Finalise();
2770  	} catch (...) {
2771  	}
2772  }
2773  static void *copy_(void *src) { return src; }
2774  static void free_(void *) { }
2775  GType scnotification_get_type(void) {
2776  	static gsize type_id = 0;
2777  	if (g_once_init_enter(&type_id)) {
2778  		const gsize id = (gsize) g_boxed_type_register_static(
2779  					 g_intern_static_string("SCNotification"),
2780  					 (GBoxedCopyFunc) copy_,
2781  					 (GBoxedFreeFunc) free_);
2782  		g_once_init_leave(&type_id, id);
2783  	}
2784  	return (GType) type_id;
2785  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.cpp</h3>
            <pre><code>1  #include "ScintillaQt.h"
2  #include "PlatQt.h"
3  #include <QApplication>
4  #include <QDrag>
5  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
6  #include <QInputContext>
7  #endif
8  #include <QMimeData>
9  #include <QMenu>
10  #include <QTextCodec>
11  #include <QScrollBar>
12  #include <QTimer>
13  using namespace Scintilla;
14  using namespace Scintilla::Internal;
15  ScintillaQt::ScintillaQt(QAbstractScrollArea *parent)
16  : QObject(parent), scrollArea(parent), vMax(0),  hMax(0), vPage(0), hPage(0),
17   haveMouseCapture(false), dragWasDropped(false),
18   rectangularSelectionModifier(SCMOD_ALT)
19  {
20  	wMain = scrollArea->viewport();
21  	imeInteraction = IMEInteraction::Inline;
22  	view.bufferedDraw = false;
23  	Init();
24  	std::fill(timers, std::end(timers), 0);
25  }
26  ScintillaQt::~ScintillaQt()
27  {
28  	CancelTimers();
29  	ChangeIdle(false);
30  }
31  void ScintillaQt::execCommand(QAction *action)
32  {
33  	const int commandNum = action->data().toInt();
34  	Command(commandNum);
35  }
36  #if defined(Q_OS_WIN)
37  static const QString sMSDEVColumnSelect("MSDEVColumnSelect");
38  static const QString sWrappedMSDEVColumnSelect("application/x-qt-windows-mime;value=\"MSDEVColumnSelect\"");
39  static const QString sVSEditorLineCutCopy("VisualStudioEditorOperationsLineCutCopyClipboardTag");
40  static const QString sWrappedVSEditorLineCutCopy("application/x-qt-windows-mime;value=\"VisualStudioEditorOperationsLineCutCopyClipboardTag\"");
41  #elif defined(Q_OS_MAC)
42  static const QString sScintillaRecPboardType("com.scintilla.utf16-plain-text.rectangular");
43  static const QString sScintillaRecMimeType("text/x-scintilla.utf16-plain-text.rectangular");
44  #else
45  static const QString sMimeRectangularMarker("text/x-rectangular-marker");
46  #endif
47  #if defined(Q_OS_MAC) && QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
48  class ScintillaRectangularMime : public QMacPasteboardMime {
49  public:
50  	ScintillaRectangularMime() : QMacPasteboardMime(MIME_ALL) {
51  	}
52  	QString convertorName() {
53  		return QString("ScintillaRectangularMime");
54  	}
55  	bool canConvert(const QString &mime, QString flav) {
56  		return mimeFor(flav) == mime;
57  	}
58  	QString mimeFor(QString flav) {
59  		if (flav == sScintillaRecPboardType)
60  			return sScintillaRecMimeType;
61  		return QString();
62  	}
63  	QString flavorFor(const QString &mime) {
64  		if (mime == sScintillaRecMimeType)
65  			return sScintillaRecPboardType;
66  		return QString();
67  	}
68  	QVariant convertToMime(const QString & &bsol;* mime */, QList<QByteArray> data, QString &bsol;* flav */) {
69  		QByteArray all;
70  		foreach (QByteArray i, data) {
71  			all += i;
72  		}
73  		return QVariant(all);
74  	}
75  	QList<QByteArray> convertFromMime(const QString & &bsol;* mime */, QVariant data, QString &bsol;* flav */) {
76  		QByteArray a = data.toByteArray();
77  		QList<QByteArray> l;
78  		l.append(a);
79  		return l;
80  	}
81  };
82  static ScintillaRectangularMime *singletonMime = 0;
83  #endif
84  void ScintillaQt::Init()
85  {
86  	rectangularSelectionModifier = SCMOD_ALT;
87  #if defined(Q_OS_MAC) && QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
88  	if (!singletonMime) {
89  		singletonMime = new ScintillaRectangularMime();
90  		QStringList slTypes(sScintillaRecPboardType);
91  		qRegisterDraggedTypes(slTypes);
92  	}
93  #endif
94  	connect(QApplication::clipboard(), SIGNAL(selectionChanged()),
95  		this, SLOT(SelectionChanged()));
96  }
97  void ScintillaQt::Finalise()
98  {
99  	CancelTimers();
100  	ScintillaBase::Finalise();
101  }
102  void ScintillaQt::SelectionChanged()
103  {
104  	bool nowPrimary = QApplication::clipboard()->ownsSelection();
105  	if (nowPrimary != primarySelection) {
106  		primarySelection = nowPrimary;
107  		Redraw();
108  	}
109  }
110  bool ScintillaQt::DragThreshold(Point ptStart, Point ptNow)
111  {
112  	int xMove = std::abs(ptStart.x - ptNow.x);
113  	int yMove = std::abs(ptStart.y - ptNow.y);
114  	return (xMove > QApplication::startDragDistance()) ||
115  		(yMove > QApplication::startDragDistance());
116  }
117  static QString StringFromSelectedText(const SelectionText &selectedText)
118  {
119  	if (selectedText.codePage == SC_CP_UTF8) {
120  		return QString::fromUtf8(selectedText.Data(), static_cast<int>(selectedText.Length()));
121  	} else {
122  		QTextCodec *codec = QTextCodec::codecForName(
123  				CharacterSetID(selectedText.characterSet));
124  		return codec->toUnicode(selectedText.Data(), static_cast<int>(selectedText.Length()));
125  	}
126  }
127  static void AddRectangularToMime(QMimeData *mimeData, [[maybe_unused]] const QString &su)
128  {
129  #if defined(Q_OS_WIN)
130  	mimeData->setData(sMSDEVColumnSelect, QByteArray());
131  #elif defined(Q_OS_MAC)
132  	mimeData->setData(sScintillaRecMimeType, su.toUtf8());
133  #else
134  	mimeData->setData(sMimeRectangularMarker, QByteArray());
135  #endif
136  }
137  static void AddLineCutCopyToMime([[maybe_unused]] QMimeData *mimeData)
138  {
139  #if defined(Q_OS_WIN)
140  	mimeData->setData(sVSEditorLineCutCopy, QByteArray());
141  #endif
142  }
143  static bool IsRectangularInMime(const QMimeData *mimeData)
144  {
145  	QStringList formats = mimeData->formats();
146  	for (int i = 0; i < formats.size(); ++i) {
147  #if defined(Q_OS_WIN)
148  		if (formats[i] == sMSDEVColumnSelect)
149  			return true;
150  		if (formats[i] == sWrappedMSDEVColumnSelect)
151  			return true;
152  #elif defined(Q_OS_MAC)
153  		if (formats[i] == sScintillaRecMimeType)
154  			return true;
155  #else
156  		if (formats[i] == sMimeRectangularMarker)
157  			return true;
158  #endif
159  	}
160  	return false;
161  }
162  static bool IsLineCutCopyInMime(const QMimeData *mimeData)
163  {
164  	QStringList formats = mimeData->formats();
165  	for (int i = 0; i < formats.size(); ++i) {
166  #if defined(Q_OS_WIN)
167  		if (formats[i] == sVSEditorLineCutCopy)
168  			return true;
169  		if (formats[i] == sWrappedVSEditorLineCutCopy)
170  			return true;
171  #endif
172  	}
173  	return false;
174  }
175  bool ScintillaQt::ValidCodePage(int codePage) const
176  {
177  	return codePage == 0
178  	|| codePage == SC_CP_UTF8
179  	|| codePage == 932
180  	|| codePage == 936
181  	|| codePage == 949
182  	|| codePage == 950
183  	|| codePage == 1361;
184  }
185  std::string ScintillaQt::UTF8FromEncoded(std::string_view encoded) const {
186  	if (IsUnicodeMode()) {
187  		return std::string(encoded);
188  	} else {
189  		QTextCodec *codec = QTextCodec::codecForName(
190  				CharacterSetID(CharacterSetOfDocument()));
191  		QString text = codec->toUnicode(encoded.data(), static_cast<int>(encoded.length()));
192  		return text.toStdString();
193  	}
194  }
195  std::string ScintillaQt::EncodedFromUTF8(std::string_view utf8) const {
196  	if (IsUnicodeMode()) {
197  		return std::string(utf8);
198  	} else {
199  		QString text = QString::fromUtf8(utf8.data(), static_cast<int>(utf8.length()));
200  		QTextCodec *codec = QTextCodec::codecForName(
201  				CharacterSetID(CharacterSetOfDocument()));
202  		QByteArray ba = codec->fromUnicode(text);
203  		return std::string(ba.data(), ba.length());
204  	}
205  }
206  void ScintillaQt::ScrollText(Sci::Line linesToMove)
207  {
208  	int dy = vs.lineHeight * (linesToMove);
209  	scrollArea->viewport()->scroll(0, dy);
210  }
211  void ScintillaQt::SetVerticalScrollPos()
212  {
213  	scrollArea->verticalScrollBar()->setValue(topLine);
214  	emit verticalScrolled(topLine);
215  }
216  void ScintillaQt::SetHorizontalScrollPos()
217  {
218  	scrollArea->horizontalScrollBar()->setValue(xOffset);
219  	emit horizontalScrolled(xOffset);
220  }
221  bool ScintillaQt::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage)
222  {
223  	bool modified = false;
224  	int vNewPage = nPage;
225  	int vNewMax = nMax - vNewPage + 1;
226  	if (vMax != vNewMax || vPage != vNewPage) {
227  		vMax = vNewMax;
228  		vPage = vNewPage;
229  		modified = true;
230  		scrollArea->verticalScrollBar()->setMaximum(vMax);
231  		scrollArea->verticalScrollBar()->setPageStep(vPage);
232  		emit verticalRangeChanged(vMax, vPage);
233  	}
234  	int hNewPage = GetTextRectangle().Width();
235  	int hNewMax = (scrollWidth > hNewPage) ? scrollWidth - hNewPage : 0;
236  	int charWidth = vs.styles[STYLE_DEFAULT].aveCharWidth;
237  	if (hMax != hNewMax || hPage != hNewPage ||
238  	    scrollArea->horizontalScrollBar()->singleStep() != charWidth) {
239  		hMax = hNewMax;
240  		hPage = hNewPage;
241  		modified = true;
242  		scrollArea->horizontalScrollBar()->setMaximum(hMax);
243  		scrollArea->horizontalScrollBar()->setPageStep(hPage);
244  		scrollArea->horizontalScrollBar()->setSingleStep(charWidth);
245  		emit horizontalRangeChanged(hMax, hPage);
246  	}
247  	return modified;
248  }
249  void ScintillaQt::ReconfigureScrollBars()
250  {
251  	if (verticalScrollBarVisible) {
252  		scrollArea->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
253  	} else {
254  		scrollArea->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
255  	}
256  	if (horizontalScrollBarVisible && !Wrapping()) {
257  		scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
258  	} else {
259  		scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
260  	}
261  }
262  void ScintillaQt::CopyToModeClipboard(const SelectionText &selectedText, QClipboard::Mode clipboardMode_)
263  {
264  	QClipboard *clipboard = QApplication::clipboard();
265  	QString su = StringFromSelectedText(selectedText);
266  	QMimeData *mimeData = new QMimeData();
267  	mimeData->setText(su);
268  	if (selectedText.rectangular) {
269  		AddRectangularToMime(mimeData, su);
270  	}
271  	if (selectedText.lineCopy) {
272  		AddLineCutCopyToMime(mimeData);
273  	}
274  	emit aboutToCopy(mimeData);
275  	clipboard->setMimeData(mimeData, clipboardMode_);
276  }
277  void ScintillaQt::Copy()
278  {
279  	if (!sel.Empty()) {
280  		SelectionText st;
281  		CopySelectionRange(&st);
282  		CopyToClipboard(st);
283  	}
284  }
285  void ScintillaQt::CopyToClipboard(const SelectionText &selectedText)
286  {
287  	CopyToModeClipboard(selectedText, QClipboard::Clipboard);
288  }
289  void ScintillaQt::PasteFromMode(QClipboard::Mode clipboardMode_)
290  {
291  	QClipboard *clipboard = QApplication::clipboard();
292  	const QMimeData *mimeData = clipboard->mimeData(clipboardMode_);
293  	bool isRectangular = IsRectangularInMime(mimeData);
294  	bool isLine = SelectionEmpty() && IsLineCutCopyInMime(mimeData);
295  	QString text = clipboard->text(clipboardMode_);
296  	QByteArray utext = BytesForDocument(text);
297  	std::string dest(utext.constData(), utext.length());
298  	SelectionText selText;
299  	selText.Copy(dest, pdoc->dbcsCodePage, CharacterSetOfDocument(), isRectangular, false);
300  	UndoGroup ug(pdoc);
301  	ClearSelection(multiPasteMode == MultiPaste::Each);
302  	InsertPasteShape(selText.Data(), selText.Length(),
303  		isRectangular ? PasteShape::rectangular : (isLine ? PasteShape::line : PasteShape::stream));
304  	EnsureCaretVisible();
305  }
306  void ScintillaQt::Paste()
307  {
308  	PasteFromMode(QClipboard::Clipboard);
309  }
310  void ScintillaQt::ClaimSelection()
311  {
312  	if (QApplication::clipboard()->supportsSelection()) {
313  		if (!sel.Empty()) {
314  			primarySelection = true;
315  			SelectionText st;
316  			CopySelectionRange(&st);
317  			CopyToModeClipboard(st, QClipboard::Selection);
318  		} else {
319  			primarySelection = false;
320  		}
321  	}
322  }
323  void ScintillaQt::NotifyChange()
324  {
325  	emit notifyChange();
326  	emit command(
327  			Platform::LongFromTwoShorts(GetCtrlID(), SCEN_CHANGE),
328  			reinterpret_cast<sptr_t>(wMain.GetID()));
329  }
330  void ScintillaQt::NotifyFocus(bool focus)
331  {
332  	if (commandEvents) {
333  		emit command(
334  				Platform::LongFromTwoShorts
335  						(GetCtrlID(), focus ? SCEN_SETFOCUS : SCEN_KILLFOCUS),
336  				reinterpret_cast<sptr_t>(wMain.GetID()));
337  	}
338  	Editor::NotifyFocus(focus);
339  }
340  void ScintillaQt::NotifyParent(NotificationData scn)
341  {
342  	scn.nmhdr.hwndFrom = wMain.GetID();
343  	scn.nmhdr.idFrom = GetCtrlID();
344  	emit notifyParent(scn);
345  }
346  void ScintillaQt::NotifyURIDropped(const char *uri)
347  {
348  	NotificationData scn = {};
349  	scn.nmhdr.code = Notification::URIDropped;
350  	scn.text = uri;
351  	NotifyParent(scn);
352  }
353  bool ScintillaQt::FineTickerRunning(TickReason reason)
354  {
355  	return timers[static_cast<size_t>(reason)] != 0;
356  }
357  void ScintillaQt::FineTickerStart(TickReason reason, int millis, int &bsol;* tolerance */)
358  {
359  	FineTickerCancel(reason);
360  	timers[static_cast<size_t>(reason)] = startTimer(millis);
361  }
362  void ScintillaQt::CancelTimers()
363  {
364  	for (size_t tr = static_cast<size_t>(TickReason::caret); tr <= static_cast<size_t>(TickReason::dwell); tr++) {
365  		if (timers[tr]) {
366  			killTimer(timers[tr]);
367  			timers[tr] = 0;
368  		}
369  	}
370  }
371  void ScintillaQt::FineTickerCancel(TickReason reason)
372  {
373  	const size_t reasonIndex = static_cast<size_t>(reason);
374  	if (timers[reasonIndex]) {
375  		killTimer(timers[reasonIndex]);
376  		timers[reasonIndex] = 0;
377  	}
378  }
379  void ScintillaQt::onIdle()
380  {
381  	bool continueIdling = Idle();
382  	if (!continueIdling) {
383  		SetIdle(false);
384  	}
385  }
386  bool ScintillaQt::ChangeIdle(bool on)
387  {
388  	if (on) {
389  		if (!idler.state) {
390  			idler.state = true;
391  			QTimer *qIdle = new QTimer;
392  			connect(qIdle, SIGNAL(timeout()), this, SLOT(onIdle()));
393  			qIdle->start(0);
394  			idler.idlerID = qIdle;
395  		}
396  	} else {
397  		if (idler.state) {
398  			idler.state = false;
399  			QTimer *qIdle = static_cast<QTimer *>(idler.idlerID);
400  			qIdle->stop();
401  			disconnect(qIdle, SIGNAL(timeout()), nullptr, nullptr);
402  			delete qIdle;
403  			idler.idlerID = {};
404  		}
405  	}
406  	return true;
407  }
408  bool ScintillaQt::SetIdle(bool on)
409  {
410  	return ChangeIdle(on);
411  }
412  CharacterSet ScintillaQt::CharacterSetOfDocument() const
413  {
414  	return vs.styles[STYLE_DEFAULT].characterSet;
415  }
416  const char *ScintillaQt::CharacterSetIDOfDocument() const
417  {
418  	return CharacterSetID(CharacterSetOfDocument());
419  }
420  QString ScintillaQt::StringFromDocument(const char *s) const
421  {
422  	if (IsUnicodeMode()) {
423  		return QString::fromUtf8(s);
424  	} else {
425  		QTextCodec *codec = QTextCodec::codecForName(
426  				CharacterSetID(CharacterSetOfDocument()));
427  		return codec->toUnicode(s);
428  	}
429  }
430  QByteArray ScintillaQt::BytesForDocument(const QString &text) const
431  {
432  	if (IsUnicodeMode()) {
433  		return text.toUtf8();
434  	} else {
435  		QTextCodec *codec = QTextCodec::codecForName(
436  				CharacterSetID(CharacterSetOfDocument()));
437  		return codec->fromUnicode(text);
438  	}
439  }
440  namespace {
441  class CaseFolderDBCS : public CaseFolderTable {
442  	QTextCodec *codec;
443  public:
444  	explicit CaseFolderDBCS(QTextCodec *codec_) : codec(codec_) {
445  	}
446  	size_t Fold(char *folded, size_t sizeFolded, const char *mixed, size_t lenMixed) override {
447  		if ((lenMixed == 1) && (sizeFolded > 0)) {
448  			folded[0] = mapping[static_cast<unsigned char>(mixed[0])];
449  			return 1;
450  		} else if (codec) {
451  			QString su = codec->toUnicode(mixed, static_cast<int>(lenMixed));
452  			QString suFolded = su.toCaseFolded();
453  			QByteArray bytesFolded = codec->fromUnicode(suFolded);
454  			if (bytesFolded.length() < static_cast<int>(sizeFolded)) {
455  				memcpy(folded, bytesFolded,  bytesFolded.length());
456  				return bytesFolded.length();
457  			}
458  		}
459  		folded[0] = '\0';
460  		return 1;
461  	}
462  };
463  }
464  std::unique_ptr<CaseFolder> ScintillaQt::CaseFolderForEncoding()
465  {
466  	if (pdoc->dbcsCodePage == SC_CP_UTF8) {
467  		return std::make_unique<CaseFolderUnicode>();
468  	} else {
469  		const char *charSetBuffer = CharacterSetIDOfDocument();
470  		if (charSetBuffer) {
471  			if (pdoc->dbcsCodePage == 0) {
472  				std::unique_ptr<CaseFolderTable> pcf = std::make_unique<CaseFolderTable>();
473  				QTextCodec *codec = QTextCodec::codecForName(charSetBuffer);
474  				for (int i=0x80; i<0x100; i++) {
475  					char sCharacter[2] = "A";
476  					sCharacter[0] = static_cast<char>(i);
477  					QString su = codec->toUnicode(sCharacter, 1);
478  					QString suFolded = su.toCaseFolded();
479  					if (codec->canEncode(suFolded)) {
480  						QByteArray bytesFolded = codec->fromUnicode(suFolded);
481  						if (bytesFolded.length() == 1) {
482  							pcf->SetTranslation(sCharacter[0], bytesFolded[0]);
483  						}
484  					}
485  				}
486  				return pcf;
487  			} else {
488  				return std::make_unique<CaseFolderDBCS>(QTextCodec::codecForName(charSetBuffer));
489  			}
490  		}
491  		return nullptr;
492  	}
493  }
494  std::string ScintillaQt::CaseMapString(const std::string &s, CaseMapping caseMapping)
495  {
496  	if (s.empty() || (caseMapping == CaseMapping::same))
497  		return s;
498  	if (IsUnicodeMode()) {
499  		std::string retMapped(s.length() * maxExpansionCaseConversion, 0);
500  		size_t lenMapped = CaseConvertString(&retMapped[0], retMapped.length(), s.c_str(), s.length(),
501  			(caseMapping == CaseMapping::upper) ? CaseConversion::upper : CaseConversion::lower);
502  		retMapped.resize(lenMapped);
503  		return retMapped;
504  	}
505  	QTextCodec *codec = QTextCodec::codecForName(CharacterSetIDOfDocument());
506  	QString text = codec->toUnicode(s.c_str(), static_cast<int>(s.length()));
507  	if (caseMapping == CaseMapping::upper) {
508  		text = text.toUpper();
509  	} else {
510  		text = text.toLower();
511  	}
512  	QByteArray bytes = BytesForDocument(text);
513  	return std::string(bytes.data(), bytes.length());
514  }
515  void ScintillaQt::SetMouseCapture(bool on)
516  {
517  	if (mouseDownCaptures) {
518  		haveMouseCapture = on;
519  	}
520  }
521  bool ScintillaQt::HaveMouseCapture()
522  {
523  	return haveMouseCapture;
524  }
525  void ScintillaQt::StartDrag()
526  {
527  	inDragDrop = DragDrop::dragging;
528  	dropWentOutside = true;
529  	if (drag.Length()) {
530  		QMimeData *mimeData = new QMimeData;
531  		QString sText = StringFromSelectedText(drag);
532  		mimeData->setText(sText);
533  		if (drag.rectangular) {
534  			AddRectangularToMime(mimeData, sText);
535  		}
536  		QDrag *dragon = new QDrag(scrollArea);
537  		dragon->setMimeData(mimeData);
538  		Qt::DropAction dropAction = dragon->exec(static_cast<Qt::DropActions>(Qt::CopyAction|Qt::MoveAction));
539  		if ((dropAction == Qt::MoveAction) && dropWentOutside) {
540  			ClearSelection();
541  		}
542  	}
543  	inDragDrop = DragDrop::none;
544  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
545  }
546  class CallTipImpl : public QWidget {
547  public:
548  	explicit CallTipImpl(CallTip *pct_)
549  		: QWidget(nullptr, Qt::ToolTip),
550  		  pct(pct_)
551  	{
552  #if QT_VERSION >= QT_VERSION_CHECK(5, 9, 0)
553  		setWindowFlag(Qt::WindowTransparentForInput);
554  #endif
555  	}
556  	void paintEvent(QPaintEvent *) override
557  	{
558  		if (pct->inCallTipMode) {
559  			std::unique_ptr<Surface> surfaceWindow = Surface::Allocate(Technology::Default);
560  			surfaceWindow->Init(this);
561  			surfaceWindow->SetMode(SurfaceMode(pct->codePage, false));
562  			pct->PaintCT(surfaceWindow.get());
563  		}
564  	}
565  private:
566  	CallTip *pct;
567  };
568  void ScintillaQt::CreateCallTipWindow(PRectangle rc)
569  {
570  	if (!ct.wCallTip.Created()) {
571  		QWidget *pCallTip = new CallTipImpl(&ct);
572  		ct.wCallTip = pCallTip;
573  		pCallTip->move(rc.left, rc.top);
574  		pCallTip->resize(rc.Width(), rc.Height());
575  	}
576  }
577  void ScintillaQt::AddToPopUp(const char *label,
578                               int cmd,
579                               bool enabled)
580  {
581  	QMenu *menu = static_cast<QMenu *>(popup.GetID());
582  	QString text(label);
583  	if (text.isEmpty()) {
584  		menu->addSeparator();
585  	} else {
586  		QAction *action = menu->addAction(text);
587  		action->setData(cmd);
588  		action->setEnabled(enabled);
589  	}
590  	menu->disconnect();
591  	connect(menu, SIGNAL(triggered(QAction*)),
592  		this, SLOT(execCommand(QAction*)));
593  }
594  sptr_t ScintillaQt::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam)
595  {
596  	try {
597  		switch (iMessage) {
598  		case Message::SetIMEInteraction:
599  			break;
600  		case Message::GrabFocus:
601  			scrollArea->setFocus(Qt::OtherFocusReason);
602  			break;
603  		case Message::GetDirectFunction:
604  			return reinterpret_cast<sptr_t>(DirectFunction);
605  		case Message::GetDirectStatusFunction:
606  			return reinterpret_cast<sptr_t>(DirectStatusFunction);
607  		case Message::GetDirectPointer:
608  			return reinterpret_cast<sptr_t>(this);
609  		case Message::SetRectangularSelectionModifier:
610  			rectangularSelectionModifier = static_cast<int>(wParam);
611  			break;
612  		case Message::GetRectangularSelectionModifier:
613  			return rectangularSelectionModifier;
614  		default:
615  			return ScintillaBase::WndProc(iMessage, wParam, lParam);
616  		}
617  	} catch (std::bad_alloc &) {
618  		errorStatus = Status::BadAlloc;
619  	} catch (...) {
620  		errorStatus = Status::Failure;
621  	}
622  	return 0;
623  }
624  sptr_t ScintillaQt::DefWndProc(Message, uptr_t, sptr_t)
625  {
626  	return 0;
627  }
628  sptr_t ScintillaQt::DirectFunction(
629      sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam)
630  {
631  	ScintillaQt *sci = reinterpret_cast<ScintillaQt *>(ptr);
632  	return sci->WndProc(static_cast<Message>(iMessage), wParam, lParam);
633  }
634  sptr_t ScintillaQt::DirectStatusFunction(
635      sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam, int *pStatus)
636  {
637  	ScintillaQt *sci = reinterpret_cast<ScintillaQt *>(ptr);
638  	const sptr_t returnValue = sci->WndProc(static_cast<Message>(iMessage), wParam, lParam);
639  	*pStatus = static_cast<int>(sci->errorStatus);
640  	return returnValue;
641  }
642  void ScintillaQt::PartialPaint(const PRectangle &rect)
643  {
644  	rcPaint = rect;
645  	paintState = PaintState::painting;
<span onclick='openModal()' class='match'>646  	PRectangle rcClient = GetClientRectangle();
647  	paintingAllText = rcPaint.Contains(rcClient);
648  	AutoSurface surfacePaint(this);
</span>649  	Paint(surfacePaint, rcPaint);
650  	surfacePaint->Release();
651  	if (paintState == PaintState::abandoned) {
652  		paintState = PaintState::painting;
653  		paintingAllText = true;
654  		AutoSurface surface(this);
655  		Paint(surface, rcPaint);
656  		surface->Release();
657  		scrollArea->viewport()->update();
658  	}
659  	paintState = PaintState::notPainting;
660  }
661  void ScintillaQt::DragEnter(const Point &point)
662  {
663  	SetDragPosition(SPositionFromLocation(point,
664  					      false, false, UserVirtualSpace()));
665  }
666  void ScintillaQt::DragMove(const Point &point)
667  {
668  	SetDragPosition(SPositionFromLocation(point,
669  					      false, false, UserVirtualSpace()));
670  }
671  void ScintillaQt::DragLeave()
672  {
673  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
674  }
675  void ScintillaQt::Drop(const Point &point, const QMimeData *data, bool move)
676  {
677  	QString text = data->text();
678  	bool rectangular = IsRectangularInMime(data);
679  	QByteArray bytes = BytesForDocument(text);
680  	int len = bytes.length();
681  	SelectionPosition movePos = SPositionFromLocation(point,
682  				false, false, UserVirtualSpace());
683  	DropAt(movePos, bytes, len, move, rectangular);
684  }
685  void ScintillaQt::DropUrls(const QMimeData *data)
686  {
687  	foreach(const QUrl &url, data->urls()) {
688  		NotifyURIDropped(url.toString().toUtf8().constData());
689  	}
690  }
691  void ScintillaQt::timerEvent(QTimerEvent *event)
692  {
693  	for (size_t tr=static_cast<size_t>(TickReason::caret); tr<=static_cast<size_t>(TickReason::dwell); tr++) {
694  		if (timers[tr] == event->timerId()) {
695  			TickFor(static_cast<TickReason>(tr));
696  		}
697  	}
698  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaGTK.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>2283  		PRectangle rcClient = GetClientRectangle();
2284  		paintingAllText = rcPaint.Contains(rcClient);
2285  		std::unique_ptr<Surface> surfaceWindow(Surface::Allocate(Technology::Default));
</pre></code></div>
                <div class="column column_space"><pre><code>646  	PRectangle rcClient = GetClientRectangle();
647  	paintingAllText = rcPaint.Contains(rcClient);
648  	AutoSurface surfacePaint(this);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    