
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.91105463786531%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-output.cpp</h3>
            <pre><code>1  #include "output.h"
2  #include "control.h"
3  #include "tesseractclass.h"
4  #include "tessvars.h"
5  #ifndef DISABLED_LEGACY_ENGINE
6  #  include "docqual.h"
7  #  include "reject.h"
8  #endif
9  #include "helpers.h"
10  #include <cctype>
11  #include <cerrno>
12  #include <cstring>
13  #define CTRL_NEWLINE '\012'  
14  #define CTRL_HARDLINE '\015' 
15  namespace tesseract {
16  void Tesseract::output_pass( 
17      PAGE_RES_IT &page_res_it, const TBOX *target_word_box) {
18    BLOCK_RES *block_of_last_word;
19    bool force_eol;   
20    BLOCK *nextblock; 
21    WERD *nextword;   
22    page_res_it.restart_page();
23    block_of_last_word = nullptr;
24    while (page_res_it.word() != nullptr) {
25      check_debug_pt(page_res_it.word(), 120);
26      if (target_word_box) {
27        TBOX current_word_box = page_res_it.word()->word->bounding_box();
28        FCOORD center_pt((current_word_box.right() + current_word_box.left()) / 2,
29                         (current_word_box.bottom() + current_word_box.top()) / 2);
30        if (!target_word_box->contains(center_pt)) {
31          page_res_it.forward();
32          continue;
33        }
34      }
35      if (tessedit_write_block_separators && block_of_last_word != page_res_it.block()) {
36        block_of_last_word = page_res_it.block();
37      }
38      force_eol =
39          (tessedit_write_block_separators && (page_res_it.block() != page_res_it.next_block())) ||
40          (page_res_it.next_word() == nullptr);
41      if (page_res_it.next_word() != nullptr) {
42        nextword = page_res_it.next_word()->word;
43      } else {
44        nextword = nullptr;
45      }
46      if (page_res_it.next_block() != nullptr) {
47        nextblock = page_res_it.next_block()->block;
48      } else {
49        nextblock = nullptr;
50      }
51      write_results(page_res_it,
52                    determine_newline_type(page_res_it.word()->word, page_res_it.block()->block,
53                                           nextword, nextblock),
54                    force_eol);
55      page_res_it.forward();
56    }
57  }
58  void Tesseract::write_results(PAGE_RES_IT &page_res_it,
59                                char newline_type, 
60                                bool force_eol) {  
61    WERD_RES *word = page_res_it.word();
62    const UNICHARSET &uchset = *word->uch_set;
63    bool need_reject = false;
64    UNICHAR_ID space = uchset.unichar_to_id(" ");
65    if ((word->unlv_crunch_mode != CR_NONE || word->best_choice->empty()) &&
66        !tessedit_zero_kelvin_rejection && !tessedit_word_for_word) {
67      if ((word->unlv_crunch_mode != CR_DELETE) &&
68          (!stats_.tilde_crunch_written ||
69           ((word->unlv_crunch_mode == CR_KEEP_SPACE) && (word->word->space() > 0) &&
70            !word->word->flag(W_FUZZY_NON) && !word->word->flag(W_FUZZY_SP)))) {
71        if (!word->word->flag(W_BOL) && (word->word->space() > 0) && !word->word->flag(W_FUZZY_NON) &&
72            !word->word->flag(W_FUZZY_SP)) {
73          stats_.last_char_was_tilde = false;
74        }
75        need_reject = true;
76      }
77      if ((need_reject && !stats_.last_char_was_tilde) ||
78          (force_eol && stats_.write_results_empty_block)) {
79        stats_.last_char_was_tilde = true;
80        stats_.tilde_crunch_written = true;
81        stats_.last_char_was_newline = false;
82        stats_.write_results_empty_block = false;
83      }
84      if ((word->word->flag(W_EOL) && !stats_.last_char_was_newline) || force_eol) {
85        stats_.tilde_crunch_written = false;
86        stats_.last_char_was_newline = true;
87        stats_.last_char_was_tilde = false;
88      }
89      if (force_eol) {
90        stats_.write_results_empty_block = true;
91      }
92      return;
93    }
94    stats_.tilde_crunch_written = false;
95    if (newline_type) {
96      stats_.last_char_was_newline = true;
97    } else {
98      stats_.last_char_was_newline = false;
99    }
100    stats_.write_results_empty_block = force_eol; 
101    if (unlv_tilde_crunching && stats_.last_char_was_tilde && (word->word->space() == 0) &&
102        !(word->word->flag(W_REP_CHAR) && tessedit_write_rep_codes) &&
103        (word->best_choice->unichar_id(0) == space)) {
104      word->MergeAdjacentBlobs(0);
105    }
106    if (newline_type || (word->word->flag(W_REP_CHAR) && tessedit_write_rep_codes)) {
107      stats_.last_char_was_tilde = false;
108    } else {
109      if (word->reject_map.length() > 0) {
<span onclick='openModal()' class='match'>110        if (word->best_choice->unichar_id(word->reject_map.length() - 1) == space) {
111          stats_.last_char_was_tilde = true;
112        } else {
113          stats_.last_char_was_tilde = false;
114        }
115      } else if (word->word->space() > 0) {
</span>116        stats_.last_char_was_tilde = false;
117      }
118    }
119    ASSERT_HOST(word->best_choice->length() == word->reject_map.length());
120    set_unlv_suspects(word);
121    check_debug_pt(word, 120);
122    if (tessedit_rejection_debug) {
123      tprintf("Dict word: \"%s\": %d\n", word->best_choice->debug_string().c_str(),
124              dict_word(*(word->best_choice)));
125    }
126    if (!word->word->flag(W_REP_CHAR) || !tessedit_write_rep_codes) {
127      if (tessedit_zero_rejection) {
128        for (unsigned i = 0; i < word->best_choice->length(); ++i) {
129          if (word->reject_map[i].rejected()) {
130            word->reject_map[i].setrej_minimal_rej_accept();
131          }
132        }
133      }
134      if (tessedit_minimal_rejection) {
135        for (unsigned i = 0; i < word->best_choice->length(); ++i) {
136          if ((word->best_choice->unichar_id(i) != space) && word->reject_map[i].rejected()) {
137            word->reject_map[i].setrej_minimal_rej_accept();
138          }
139        }
140      }
141    }
142  }
143  char determine_newline_type( 
144      WERD *word,              
145      BLOCK *block,            
146      WERD *next_word,         
147      BLOCK *next_block        
148  ) {
149    int16_t end_gap; 
150    int16_t width;   
151    TBOX word_box;   
152    TBOX next_box;   
153    TBOX block_box;  
154    if (!word->flag(W_EOL)) {
155      return false; 
156    }
157    if (next_word == nullptr || next_block == nullptr || block != next_block) {
158      return CTRL_NEWLINE;
159    }
160    if (next_word->space() > 0) {
161      return CTRL_HARDLINE; 
162    }
163    word_box = word->bounding_box();
164    next_box = next_word->bounding_box();
165    block_box = block->pdblk.bounding_box();
166    end_gap = block_box.right() - word_box.right();
167    end_gap -= static_cast<int32_t>(block->space());
168    width = next_box.right() - next_box.left();
169    return end_gap > width ? CTRL_HARDLINE : CTRL_NEWLINE;
170  }
171  UNICHAR_ID Tesseract::get_rep_char(WERD_RES *word) { 
172    int i;
173    for (i = 0; ((i < word->reject_map.length()) && (word->reject_map[i].rejected())); ++i) {
174      ;
175    }
176    if (i < word->reject_map.length()) {
177      return word->best_choice->unichar_id(i);
178    } else {
179      return word->uch_set->unichar_to_id(unrecognised_char.c_str());
180    }
181  }
182  void Tesseract::set_unlv_suspects(WERD_RES *word_res) {
183    int len = word_res->reject_map.length();
184    const WERD_CHOICE &word = *(word_res->best_choice);
185    const UNICHARSET &uchset = *word.unicharset();
186    int i;
187    float rating_per_ch;
188    if (suspect_level == 0) {
189      for (i = 0; i < len; i++) {
190        if (word_res->reject_map[i].rejected()) {
191          word_res->reject_map[i].setrej_minimal_rej_accept();
192        }
193      }
194      return;
195    }
196    if (suspect_level >= 3) {
197      return; 
198    }
199    if (safe_dict_word(word_res) && (count_alphas(word) > suspect_short_words)) {
200      for (i = 0; i < len; ++i) {
201        if (word_res->reject_map[i].rejected() && uchset.get_isalpha(word.unichar_id(i))) {
202          word_res->reject_map[i].setrej_minimal_rej_accept();
203        }
204      }
205    }
206    rating_per_ch = word.rating() / word_res->reject_map.length();
207    if (rating_per_ch >= suspect_rating_per_ch) {
208      return; 
209    }
210    if ((word_res->tess_accepted) || (rating_per_ch < suspect_accept_rating)) {
211      for (i = 0; i < len; ++i) {
212        if (word_res->reject_map[i].rejected() && (!uchset.eq(word.unichar_id(i), " "))) {
213          word_res->reject_map[i].setrej_minimal_rej_accept();
214        }
215      }
216    }
217    for (i = 0; i < len; i++) {
218      if (word_res->reject_map[i].rejected()) {
219        if (word_res->reject_map[i].flag(R_DOC_REJ)) {
220          word_res->reject_map[i].setrej_minimal_rej_accept();
221        }
222        if (word_res->reject_map[i].flag(R_BLOCK_REJ)) {
223          word_res->reject_map[i].setrej_minimal_rej_accept();
224        }
225        if (word_res->reject_map[i].flag(R_ROW_REJ)) {
226          word_res->reject_map[i].setrej_minimal_rej_accept();
227        }
228      }
229    }
230    if (suspect_level == 2) {
231      return;
232    }
233    if (!suspect_constrain_1Il || (word_res->reject_map.length() <= suspect_short_words)) {
234      for (i = 0; i < len; i++) {
235        if (word_res->reject_map[i].rejected()) {
236          if ((word_res->reject_map[i].flag(R_1IL_CONFLICT) ||
237               word_res->reject_map[i].flag(R_POSTNN_1IL))) {
238            word_res->reject_map[i].setrej_minimal_rej_accept();
239          }
240          if (!suspect_constrain_1Il && word_res->reject_map[i].flag(R_MM_REJECT)) {
241            word_res->reject_map[i].setrej_minimal_rej_accept();
242          }
243        }
244      }
245    }
246    if (acceptable_word_string(*word_res->uch_set, word.unichar_string().c_str(),
247                               word.unichar_lengths().c_str()) != AC_UNACCEPTABLE ||
248        acceptable_number_string(word.unichar_string().c_str(), word.unichar_lengths().c_str())) {
249      if (word_res->reject_map.length() > suspect_short_words) {
250        for (i = 0; i < len; i++) {
251          if (word_res->reject_map[i].rejected() && (!word_res->reject_map[i].perm_rejected() ||
252                                                     word_res->reject_map[i].flag(R_1IL_CONFLICT) ||
253                                                     word_res->reject_map[i].flag(R_POSTNN_1IL) ||
254                                                     word_res->reject_map[i].flag(R_MM_REJECT))) {
255            word_res->reject_map[i].setrej_minimal_rej_accept();
256          }
257        }
258      }
259    }
260  }
261  int16_t Tesseract::count_alphas(const WERD_CHOICE &word) {
262    int count = 0;
263    for (unsigned i = 0; i < word.length(); ++i) {
264      if (word.unicharset()->get_isalpha(word.unichar_id(i))) {
265        count++;
266      }
267    }
268    return count;
269  }
270  int16_t Tesseract::count_alphanums(const WERD_CHOICE &word) {
271    int count = 0;
272    for (unsigned i = 0; i < word.length(); ++i) {
273      if (word.unicharset()->get_isalpha(word.unichar_id(i)) ||
274          word.unicharset()->get_isdigit(word.unichar_id(i))) {
275        count++;
276      }
277    }
278    return count;
279  }
280  bool Tesseract::acceptable_number_string(const char *s, const char *lengths) {
281    bool prev_digit = false;
282    if (*lengths == 1 && *s == '(') {
283      s++;
284    }
285    if (*lengths == 1 && ((*s == '$') || (*s == '.') || (*s == '+') || (*s == '-'))) {
286      s++;
287    }
288    for (; *s != '\0'; s += *(lengths++)) {
289      if (unicharset.get_isdigit(s, *lengths)) {
290        prev_digit = true;
291      } else if (prev_digit && (*lengths == 1 && ((*s == '.') || (*s == ',') || (*s == '-')))) {
292        prev_digit = false;
293      } else if (prev_digit && *lengths == 1 && (*(s + *lengths) == '\0') &&
294                 ((*s == '%') || (*s == ')'))) {
295        return true;
296      } else if (prev_digit && *lengths == 1 && (*s == '%') &&
297                 (*(lengths + 1) == 1 && *(s + *lengths) == ')') &&
298                 (*(s + *lengths + *(lengths + 1)) == '\0')) {
299        return true;
300      } else {
301        return false;
302      }
303    }
304    return true;
305  }
306  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-resultiterator_test.cc</h3>
            <pre><code>1  #include <allheaders.h>
2  #include <tesseract/baseapi.h>
3  #include <tesseract/resultiterator.h>
4  #include <string>
5  #include "scrollview.h"
6  #include "include_gunit.h"
7  #include "log.h" 
8  namespace tesseract {
9  class ResultIteratorTest : public testing::Test {
10  protected:
11    std::string TestDataNameToPath(const std::string &name) {
12      return file::JoinPath(TESTING_DIR, name);
13    }
14    std::string TessdataPath() {
15      return file::JoinPath(TESSDATA_DIR, "");
16    }
17    std::string OutputNameToPath(const std::string &name) {
18      file::MakeTmpdir();
19      return file::JoinPath(FLAGS_test_tmpdir, name);
20    }
21    ResultIteratorTest() {
22      src_pix_ = nullptr;
23    }
24    ~ResultIteratorTest() override = default;
25    void SetImage(const char *filename) {
26      src_pix_ = pixRead(TestDataNameToPath(filename).c_str());
27      api_.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY);
28      api_.SetPageSegMode(tesseract::PSM_AUTO);
29      api_.SetImage(src_pix_);
30      src_pix_.destroy();
31      src_pix_ = api_.GetInputImage();
32    }
33    void VerifyRebuild(int max_diff, PageIteratorLevel level, PageIterator *it) {
34      it->Begin();
35      int width = pixGetWidth(src_pix_);
36      int height = pixGetHeight(src_pix_);
37      int depth = pixGetDepth(src_pix_);
38      Image pix = pixCreate(width, height, depth);
39      EXPECT_TRUE(depth == 1 || depth == 8);
40      if (depth == 8) {
41        pixSetAll(pix);
42      }
43      do {
44        int left, top, right, bottom;
45        PageIteratorLevel im_level = level;
46        if (!it->BoundingBox(level, &left, &top, &right, &bottom)) {
47          im_level = tesseract::RIL_BLOCK;
48          EXPECT_TRUE(it->BoundingBox(im_level, &left, &top, &right, &bottom));
49        }
50        LOG(INFO) << "BBox: [L:" << left << ", T:" << top << ", R:" << right << ", B:" << bottom
51                  << "]"
52                  << "\n";
53        Image block_pix;
<span onclick='openModal()' class='match'>54        if (depth == 1) {
55          block_pix = it->GetBinaryImage(im_level);
56          pixRasterop(pix, left, top, right - left, bottom - top, PIX_SRC ^ PIX_DST, block_pix, 0, 0);
57        } else {
58          block_pix = it->GetImage(im_level, 2, src_pix_, &left, &top);
59          pixRasterop(pix, left, top, pixGetWidth(block_pix), pixGetHeight(block_pix),
60                      PIX_SRC & PIX_DST, block_pix, 0, 0);
61        }
62        CHECK(block_pix != nullptr);
63        block_pix.destroy();
64      } while (it->Next(level));
</span>65      pixRasterop(pix, 0, 0, width, height, PIX_SRC ^ PIX_DST, src_pix_, 0, 0);
66      if (depth == 8) {
67        Image binary_pix = pixThresholdToBinary(pix, 128);
68        pix.destroy();
69        pixInvert(binary_pix, binary_pix);
70        pix = binary_pix;
71      }
72      l_int32 pixcount;
73      pixCountPixels(pix, &pixcount, nullptr);
74      if (pixcount > max_diff) {
75        std::string outfile = OutputNameToPath("failedxor.png");
76        LOG(INFO) << "outfile = " << outfile << "\n";
77        pixWrite(outfile.c_str(), pix, IFF_PNG);
78      }
79      pix.destroy();
80      LOG(INFO) << "At level " << level << ": pix diff = " << pixcount << "\n";
81      EXPECT_LE(pixcount, max_diff);
82    }
83    void VerifyIteratorText(const std::string &truth, PageIteratorLevel level, ResultIterator *it) {
84      LOG(INFO) << "Text Test Level " << level << "\n";
85      it->Begin();
86      std::string result;
87      do {
88        char *text = it->GetUTF8Text(level);
89        result += text;
90        delete[] text;
91        if ((level == tesseract::RIL_WORD || level == tesseract::RIL_SYMBOL) &&
92            it->IsAtFinalElement(tesseract::RIL_WORD, level)) {
93          if (it->IsAtFinalElement(tesseract::RIL_TEXTLINE, level)) {
94            result += '\n';
95          } else {
96            result += ' ';
97          }
98          if (it->IsAtFinalElement(tesseract::RIL_PARA, level) &&
99              !(it->IsAtFinalElement(tesseract::RIL_BLOCK, level))) {
100            result += '\n';
101          }
102        }
103      } while (it->Next(level));
104      EXPECT_STREQ(truth.c_str(), result.c_str()) << "Rebuild failed at Text Level " << level;
105    }
106    void VerifyRebuilds(int block_limit, int para_limit, int line_limit, int word_limit,
107                        int symbol_limit, PageIterator *it, PageIteratorLevel maxlevel=tesseract::RIL_SYMBOL) {
108      VerifyRebuild(block_limit, tesseract::RIL_BLOCK, it);
109      VerifyRebuild(para_limit, tesseract::RIL_PARA, it);
110      VerifyRebuild(line_limit, tesseract::RIL_TEXTLINE, it);
111      VerifyRebuild(word_limit, tesseract::RIL_WORD, it);
112      if (maxlevel == tesseract::RIL_SYMBOL) {
113        VerifyRebuild(symbol_limit, maxlevel, it);
114      }
115    }
116    void VerifyAllText(const std::string &truth, ResultIterator *it) {
117      VerifyIteratorText(truth, tesseract::RIL_BLOCK, it);
118      VerifyIteratorText(truth, tesseract::RIL_PARA, it);
119      VerifyIteratorText(truth, tesseract::RIL_TEXTLINE, it);
120      VerifyIteratorText(truth, tesseract::RIL_WORD, it);
121      VerifyIteratorText(truth, tesseract::RIL_SYMBOL, it);
122    }
123    void ExpectTextlineReadingOrder(bool in_ltr_context, const StrongScriptDirection *word_dirs,
124                                    int num_words, int *expected_reading_order,
125                                    int num_reading_order_entries) const {
126      std::vector<StrongScriptDirection> gv_word_dirs;
127      for (int i = 0; i < num_words; i++) {
128        gv_word_dirs.push_back(word_dirs[i]);
129      }
130      std::vector<int> calculated_order;
131      ResultIterator::CalculateTextlineOrder(in_ltr_context, gv_word_dirs, &calculated_order);
132      std::vector<int> correct_order(expected_reading_order,
133                                     expected_reading_order + num_reading_order_entries);
134      EXPECT_EQ(correct_order, calculated_order);
135    }
136    void VerifySaneTextlineOrder(bool in_ltr_context, const StrongScriptDirection *word_dirs,
137                                 int num_words) const {
138      std::vector<StrongScriptDirection> gv_word_dirs;
139      for (int i = 0; i < num_words; i++) {
140        gv_word_dirs.push_back(word_dirs[i]);
141      }
142      std::vector<int> output;
143      ResultIterator::CalculateTextlineOrder(in_ltr_context, gv_word_dirs, &output);
144      ASSERT_GE(output.size(), num_words);
145      std::vector<int> output_copy(output);
146      std::sort(output_copy.begin(), output_copy.end());
147      bool sane = true;
148      unsigned j = 0;
149      while (j < output_copy.size() && output_copy[j] < 0) {
150        j++;
151      }
152      for (int i = 0; i < num_words; i++, j++) {
153        if (output_copy[j] != i) {
154          sane = false;
155          break;
156        }
157      }
158      if (j != output_copy.size()) {
159        sane = false;
160      }
161      if (!sane) {
162        std::vector<int> empty;
163        EXPECT_EQ(output, empty) << " permutation of 0.." << num_words - 1 << " not found in "
164                                 << (in_ltr_context ? "ltr" : "rtl") << " context.";
165      }
166    }
167    Image src_pix_; 
168    std::string ocr_text_;
169    tesseract::TessBaseAPI api_;
170  };
171  TEST_F(ResultIteratorTest, EasyTest) {
172    SetImage("phototest.tif");
173    PageIterator *p_it = api_.AnalyseLayout();
174    EXPECT_FALSE(p_it == nullptr);
175    EXPECT_TRUE(p_it->IsAtBeginningOf(tesseract::RIL_BLOCK));
176    EXPECT_FALSE(p_it->Next(tesseract::RIL_BLOCK));
177    EXPECT_FALSE(p_it->IsAtBeginningOf(tesseract::RIL_BLOCK));
178    LOG(INFO) << "Verifying image rebuilds 1 (pageiterator)"
179              << "\n";
180    VerifyRebuilds(10, 10, 0, 0, 0, p_it);
181    delete p_it;
182    char *result = api_.GetUTF8Text();
183    ocr_text_ = result;
184    delete[] result;
185    ResultIterator *r_it = api_.GetIterator();
186    LOG(INFO) << "Verifying image rebuilds 2a (resultiterator)"
187              << "\n";
188    VerifyRebuilds(8, 8, 0, 0, 40, r_it, tesseract::RIL_WORD);
189    LOG(INFO) << "Verifying text rebuilds 1 (resultiterator)"
190              << "\n";
191    VerifyAllText(ocr_text_, r_it);
192    LOG(INFO) << "Verifying image rebuilds 2b (resultiterator)"
193              << "\n";
194    VerifyRebuilds(8, 8, 0, 0, 40, r_it, tesseract::RIL_WORD);
195    r_it->Begin();
196    int x1, y1, x2, y2;
197    r_it->Baseline(tesseract::RIL_TEXTLINE, &x1, &y1, &x2, &y2);
198    LOG(INFO) << "Baseline ("
199       << x1 << ',' << y1 << ")->(" << x2 << ',' << y2 << ")\n";
200    EXPECT_GE(x2, x1 + 400);
201    int x3 = 200 - x1;
202    int y3 = 116 - y1;
203    x2 -= x1;
204    y2 -= y1;
205    int product = x2 * y3 - x3 * y2;
206    EXPECT_LE(abs(product), x2);
207    do {
208      float confidence = r_it->Confidence(tesseract::RIL_WORD);
209  #ifndef DISABLED_LEGACY_ENGINE
210      int pointsize, font_id;
211      bool bold, italic, underlined, monospace, serif, smallcaps;
212      const char *font = r_it->WordFontAttributes(&bold, &italic, &underlined, &monospace, &serif,
213                                                  &smallcaps, &pointsize, &font_id);
214      EXPECT_GE(confidence, 80.0f);
215  #endif
216      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
217  #ifdef DISABLED_LEGACY_ENGINE
218      LOG(INFO) << "Word " << word_str << ", conf " << confidence << "\n";
219  #else
220      LOG(INFO) << "Word " << word_str << " in font " << font
221        << ", id " << font_id << ", size " << pointsize
222        << ", conf " << confidence << "\n";
223  #endif 
224      delete[] word_str;
225  #ifndef DISABLED_LEGACY_ENGINE
226      EXPECT_FALSE(bold);
227      EXPECT_FALSE(italic);
228      EXPECT_FALSE(underlined);
229      EXPECT_FALSE(monospace);
230      EXPECT_FALSE(serif);
231      EXPECT_GE(pointsize, 11.16 - 1.50);
232      EXPECT_LE(pointsize, 11.16 + 1.50);
233  #endif 
234    } while (r_it->Next(tesseract::RIL_WORD));
235    delete r_it;
236  }
237  TEST_F(ResultIteratorTest, ComplexTest) {
238    SetImage("8087_054.3B.tif");
239    PageIterator *it = api_.AnalyseLayout();
240    EXPECT_FALSE(it == nullptr);
241    VerifyRebuilds(2073, 2073, 2080, 2081, 2090, it);
242    delete it;
243  }
244  TEST_F(ResultIteratorTest, GreyTest) {
245    SetImage("8087_054.3G.tif");
246    PageIterator *it = api_.AnalyseLayout();
247    EXPECT_FALSE(it == nullptr);
248    VerifyRebuilds(600, 600, 600, 600, 600, it);
249    delete it;
250  }
251  TEST_F(ResultIteratorTest, SmallCapDropCapTest) {
252  #ifdef DISABLED_LEGACY_ENGINE
253    GTEST_SKIP();
254  #else
255    SetImage("8071_093.3B.tif");
256    char *result = api_.GetUTF8Text();
257    delete[] result;
258    ResultIterator *r_it = api_.GetIterator();
259    int found_dropcaps = 0;
260    int found_smallcaps = 0;
261    int false_positives = 0;
262    do {
263      bool bold, italic, underlined, monospace, serif, smallcaps;
264      int pointsize, font_id;
265      r_it->WordFontAttributes(&bold, &italic, &underlined, &monospace, &serif, &smallcaps,
266                               &pointsize, &font_id);
267      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
268      if (word_str != nullptr) {
269        LOG(INFO) << "Word " << word_str
270          << " is " << (smallcaps ? "SMALLCAPS" : "Normal") << "\n";
271        if (r_it->SymbolIsDropcap()) {
272          ++found_dropcaps;
273        }
274        if (strcmp(word_str, "SHE") == 0 || strcmp(word_str, "MOPED") == 0 ||
275            strcmp(word_str, "RALPH") == 0 || strcmp(word_str, "KINNEY") == 0 || 
276            strcmp(word_str, "BENNETT") == 0) {
277          EXPECT_TRUE(smallcaps) << word_str;
278          ++found_smallcaps;
279        } else {
280          if (smallcaps) {
281            ++false_positives;
282          }
283        }
284        ResultIterator s_it(*r_it);
285        while (s_it.Next(tesseract::RIL_SYMBOL) && !s_it.IsAtBeginningOf(tesseract::RIL_WORD)) {
286          if (s_it.SymbolIsDropcap()) {
287            char *sym_str = s_it.GetUTF8Text(tesseract::RIL_SYMBOL);
288            LOG(ERROR) << "Symbol " << sym_str << " of word " << word_str << " is dropcap";
289            delete[] sym_str;
290          }
291          EXPECT_FALSE(s_it.SymbolIsDropcap());
292        }
293        delete[] word_str;
294      }
295    } while (r_it->Next(tesseract::RIL_WORD));
296    delete r_it;
297    EXPECT_EQ(1, found_dropcaps);
298    EXPECT_GE(4, found_smallcaps);
299    EXPECT_LE(false_positives, 3);
300  #endif 
301  }
302  #if 0
303  TEST_F(ResultIteratorTest, SubSuperTest) {
304    SetImage("0146_281.3B.tif");
305    char* result = api_.GetUTF8Text();
306    delete [] result;
307    ResultIterator* r_it = api_.GetIterator();
308    const char kAllowedSupers[] = "O0123456789-";
309    int found_subs = 0;
310    int found_supers = 0;
311    int found_normal = 0;
312    do {
313      if (r_it->SymbolIsSubscript()) {
314        ++found_subs;
315      } else if (r_it->SymbolIsSuperscript()) {
316        result = r_it->GetUTF8Text(tesseract::RIL_SYMBOL);
317        if (strchr(kAllowedSupers, result[0]) == nullptr) {
318          char* word = r_it->GetUTF8Text(tesseract::RIL_WORD);
319          LOG(ERROR) << "Char " << result << " in word " << word << " is unexpected super!";
320          delete [] word;
321          EXPECT_TRUE(strchr(kAllowedSupers, result[0]) != nullptr);
322        }
323        delete [] result;
324        ++found_supers;
325      } else {
326        ++found_normal;
327      }
328    } while (r_it->Next(tesseract::RIL_SYMBOL));
329    delete r_it;
330    LOG(INFO) << "Subs = " << found_subs << ", supers= " << found_supers
331      << ", normal = " << found_normal << "\n";
332    EXPECT_GE(found_subs, 25);
333    EXPECT_GE(found_supers, 25);
334    EXPECT_GE(found_normal, 1350);
335  }
336  #endif
337  static const StrongScriptDirection dL = DIR_LEFT_TO_RIGHT;
338  static const StrongScriptDirection dR = DIR_RIGHT_TO_LEFT;
339  static const StrongScriptDirection dN = DIR_NEUTRAL;
340  TEST_F(ResultIteratorTest, DualStartTextlineOrderTest) {
341    const StrongScriptDirection word_dirs[] = {dL, dL, dN, dL, dN, dR, dR, dR};
342    int reading_order_rtl_context[] = {7, 6, 5, 4, ResultIterator::kMinorRunStart,
343                                       0, 1, 2, 3, ResultIterator::kMinorRunEnd};
344    int reading_order_ltr_context[] = {
345        0, 1, 2, 3, 4, ResultIterator::kMinorRunStart, 7, 6, 5, ResultIterator::kMinorRunEnd};
346    ExpectTextlineReadingOrder(true, word_dirs, countof(word_dirs), reading_order_ltr_context,
347                               countof(reading_order_ltr_context));
348    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
349                               countof(reading_order_rtl_context));
350  }
351  TEST_F(ResultIteratorTest, LeftwardTextlineOrderTest) {
352    const StrongScriptDirection word_dirs[] = {dL, dL, dN, dL, dN, dN, dL, dL};
353    int reading_order_ltr_context[] = {0, 1, 2, 3, 4, 5, 6, 7};
354    int reading_order_rtl_context[] = {ResultIterator::kMinorRunStart, 0, 1, 2, 3, 4, 5, 6, 7,
355                                       ResultIterator::kMinorRunEnd};
356    ExpectTextlineReadingOrder(true, word_dirs, countof(word_dirs), reading_order_ltr_context,
357                               countof(reading_order_ltr_context));
358    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
359                               countof(reading_order_rtl_context));
360  }
361  TEST_F(ResultIteratorTest, RightwardTextlineOrderTest) {
362    const StrongScriptDirection word_dirs[] = {dR, dR, dN, dR, dN, dN, dR, dR};
363    int reading_order_rtl_context[] = {7, 6, 5, 4, 3, 2, 1, 0};
364    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
365                               countof(reading_order_rtl_context));
366  }
367  TEST_F(ResultIteratorTest, TextlineOrderSanityCheck) {
368    const int kNumWords(7);
369    const int kNumCombos = 1 << (2 * kNumWords); 
370    StrongScriptDirection word_dirs[kNumWords];
371    for (int i = 0; i < kNumCombos; i++) {
372      int tmp = i;
373      for (auto &word_dir : word_dirs) {
374        word_dir = static_cast<StrongScriptDirection>(tmp % 4);
375        tmp = tmp / 4;
376      }
377      VerifySaneTextlineOrder(true, word_dirs, kNumWords);
378      VerifySaneTextlineOrder(false, word_dirs, kNumWords);
379    }
380  }
381  TEST_F(ResultIteratorTest, DISABLED_NonNullChoicesTest) {
382    SetImage("5318c4b679264.jpg");
383    char *result = api_.GetUTF8Text();
384    delete[] result;
385    ResultIterator *r_it = api_.GetIterator();
386    do {
387      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
388      if (word_str != nullptr) {
389        LOG(INFO) << "Word " << word_str << ":\n";
390        ResultIterator s_it = *r_it;
391        do {
392          tesseract::ChoiceIterator c_it(s_it);
393          do {
394            const char *char_str = c_it.GetUTF8Text();
395            if (char_str == nullptr) {
396              LOG(INFO) << "Null char choice"
397                        << "\n";
398            } else {
399              LOG(INFO) << "Char choice " << char_str << "\n";
400            }
401            CHECK(char_str != nullptr);
402          } while (c_it.Next());
403        } while (!s_it.IsAtFinalElement(tesseract::RIL_WORD, tesseract::RIL_SYMBOL) &&
404                 s_it.Next(tesseract::RIL_SYMBOL));
405        delete[] word_str;
406      }
407    } while (r_it->Next(tesseract::RIL_WORD));
408    delete r_it;
409  }
410  TEST_F(ResultIteratorTest, NonNullConfidencesTest) {
411    SetImage("trainingitalline.tif");
412    api_.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK);
413    char *result = api_.GetUTF8Text();
414    delete[] result;
415    ResultIterator *r_it = api_.GetIterator();
416    do {
417      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
418      if (word_str != nullptr) {
419        EXPECT_FALSE(r_it->Empty(tesseract::RIL_WORD));
420        EXPECT_FALSE(r_it->Empty(tesseract::RIL_SYMBOL));
421        ResultIterator s_it = *r_it;
422        do {
423          const char *char_str = s_it.GetUTF8Text(tesseract::RIL_SYMBOL);
424          CHECK(char_str != nullptr);
425          float confidence = s_it.Confidence(tesseract::RIL_SYMBOL);
426          LOG(INFO) << "Char " << char_str << " has confidence " << confidence << "\n";
427          delete[] char_str;
428        } while (!s_it.IsAtFinalElement(tesseract::RIL_WORD, tesseract::RIL_SYMBOL) &&
429                 s_it.Next(tesseract::RIL_SYMBOL));
430        delete[] word_str;
431      } else {
432        LOG(INFO) << "Empty word found"
433                  << "\n";
434      }
435    } while (r_it->Next(tesseract::RIL_WORD));
436    delete r_it;
437  }
438  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-output.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-resultiterator_test.cc</div>
                <div class="column column_space"><pre><code>110        if (word->best_choice->unichar_id(word->reject_map.length() - 1) == space) {
111          stats_.last_char_was_tilde = true;
112        } else {
113          stats_.last_char_was_tilde = false;
114        }
115      } else if (word->word->space() > 0) {
</pre></code></div>
                <div class="column column_space"><pre><code>54        if (depth == 1) {
55          block_pix = it->GetBinaryImage(im_level);
56          pixRasterop(pix, left, top, right - left, bottom - top, PIX_SRC ^ PIX_DST, block_pix, 0, 0);
57        } else {
58          block_pix = it->GetImage(im_level, 2, src_pix_, &left, &top);
59          pixRasterop(pix, left, top, pixGetWidth(block_pix), pixGetHeight(block_pix),
60                      PIX_SRC & PIX_DST, block_pix, 0, 0);
61        }
62        CHECK(block_pix != nullptr);
63        block_pix.destroy();
64      } while (it->Next(level));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    