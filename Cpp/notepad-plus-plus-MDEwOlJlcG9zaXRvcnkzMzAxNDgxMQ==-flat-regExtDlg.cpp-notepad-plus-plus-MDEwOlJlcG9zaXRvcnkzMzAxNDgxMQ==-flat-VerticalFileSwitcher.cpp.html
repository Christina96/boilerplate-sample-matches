
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-regExtDlg.cpp</h3>
            <pre><code>1  #include "Common.h"
2  #include "regExtDlg.h"
3  #include "resource.h"
4  #include "Parameters.h"
5  const TCHAR* nppName   = TEXT("Notepad++_file");
6  const TCHAR* nppBackup = TEXT("Notepad++_backup");
7  const TCHAR* nppDoc    = TEXT("Notepad++ Document");
8  const int nbSupportedLang = 10;
9  const int nbExtMax = 27;
10  const int extNameMax = 18;
11  const TCHAR defExtArray[nbSupportedLang][nbExtMax][extNameMax] =
12  {
13  	{TEXT("Notepad"),
14  		TEXT(".txt"), TEXT(".log")
15  	},
16  	{TEXT("ms ini/inf"),
17  		TEXT(".ini"), TEXT(".inf")
18  	},
19  	{TEXT("c, c++, objc"),
20  		TEXT(".h"), TEXT(".hh"), TEXT(".hpp"), TEXT(".hxx"), TEXT(".c"), TEXT(".cpp"), TEXT(".cxx"), TEXT(".cc"),
21  		TEXT(".m"), TEXT(".mm"),
22  		TEXT(".vcxproj"), TEXT(".vcproj"), TEXT(".props"), TEXT(".vsprops"), TEXT(".manifest")
23  	},
24  	{TEXT("java, c#, pascal"),
25  		TEXT(".java"), TEXT(".cs"), TEXT(".pas"), TEXT(".pp"), TEXT(".inc")
26  	},
27  	{TEXT("web script"),
28  		TEXT(".html"), TEXT(".htm"), TEXT(".shtml"), TEXT(".shtm"), TEXT(".hta"),
29  		TEXT(".asp"), TEXT(".aspx"),
30  		TEXT(".css"), TEXT(".js"), TEXT(".json"), TEXT(".jsm"), TEXT(".jsp"),
31  		TEXT(".php"), TEXT(".php3"), TEXT(".php4"), TEXT(".php5"), TEXT(".phps"), TEXT(".phpt"), TEXT(".phtml"),
32  		TEXT(".xml"), TEXT(".xhtml"), TEXT(".xht"), TEXT(".xul"), TEXT(".kml"), TEXT(".xaml"), TEXT(".xsml")
33  	},
34  	{TEXT("public script"),
35  		TEXT(".sh"), TEXT(".bsh"), TEXT(".bash"), TEXT(".bat"), TEXT(".cmd"), TEXT(".nsi"),
36  		TEXT(".nsh"), TEXT(".lua"), TEXT(".pl"), TEXT(".pm"), TEXT(".py")
37  	},
38  	{TEXT("property script"),
39  		TEXT(".rc"), TEXT(".as"), TEXT(".mx"), TEXT(".vb"), TEXT(".vbs")
40  	},
41  	{TEXT("fortran, TeX, SQL"),
42  		TEXT(".f"), TEXT(".for"), TEXT(".f90"), TEXT(".f95"), TEXT(".f2k"), TEXT(".tex"), TEXT(".sql")
43  	},
44  	{TEXT("misc"),
45  		TEXT(".nfo"), TEXT(".mak")
46  	},
47  	{TEXT("customize")}
48  };
49  void RegExtDlg::doDialog(bool isRTL)
50  {
51  	if (isRTL)
52  	{
53  		DLGTEMPLATE *pMyDlgTemplate = nullptr;
54  		HGLOBAL hMyDlgTemplate = makeRTLResource(IDD_REGEXT_BOX, &pMyDlgTemplate);
55  		::DialogBoxIndirectParam(_hInst, pMyDlgTemplate, _hParent, dlgProc, reinterpret_cast<LPARAM>(this));
56  		::GlobalFree(hMyDlgTemplate);
57  	}
58  	else
59  		::DialogBoxParam(_hInst, MAKEINTRESOURCE(IDD_REGEXT_BOX), _hParent, dlgProc, reinterpret_cast<LPARAM>(this));
60  }
61  intptr_t CALLBACK RegExtDlg::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam)
62  {
63  	NppParameters& nppParam = NppParameters::getInstance();
64  	switch (Message)
65  	{
66  		case WM_INITDIALOG :
67  		{
68  			getRegisteredExts();
69  			getDefSupportedExts();
70  			::EnableWindow(::GetDlgItem(_hSelf, IDC_ADDFROMLANGEXT_BUTTON), false);
71  			::EnableWindow(::GetDlgItem(_hSelf, IDC_REMOVEEXT_BUTTON), false);
72  			if (!nppParam.isAdmin())
73  			{
74  				::EnableWindow(::GetDlgItem(_hSelf, IDC_REGEXT_LANG_LIST), false);
75  				::EnableWindow(::GetDlgItem(_hSelf, IDC_REGEXT_LANGEXT_LIST), false);
76  				::EnableWindow(::GetDlgItem(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST), false);
77  			}
78  			else
79  			{
80  				::ShowWindow(::GetDlgItem(_hSelf, IDC_ADMINMUSTBEONMSG_STATIC), SW_HIDE);
81  				::SendDlgItemMessage(_hSelf, IDC_CUSTOMEXT_EDIT, EM_SETLIMITTEXT, extNameMax - 1, 0);
82  			}
83  			return TRUE;
84  		}
85  		case WM_CTLCOLORLISTBOX:
86  		{
87  			if (NppDarkMode::isEnabled())
88  			{
89  				return NppDarkMode::onCtlColorListbox(wParam, lParam);
90  			}
91  			break;
92  		}
93  		case WM_CTLCOLORDLG:
94  		{
95  			if (NppDarkMode::isEnabled())
96  			{
97  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
98  			}
99  			break;
100  		}
101  		case WM_CTLCOLORSTATIC:
102  		{
103  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
104  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
105  			bool isStaticText = dlgCtrlID == IDC_SUPPORTEDEXTS_STATIC || dlgCtrlID == IDC_REGISTEREDEXTS_STATIC;
106  			if (isStaticText)
107  			{
108  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, nppParam.isAdmin());
109  			}
110  			if (NppDarkMode::isEnabled())
111  			{
112  				return NppDarkMode::onCtlColorDarker(hdcStatic);
113  			}
114  			return FALSE;
115  		}
116  		case WM_PRINTCLIENT:
117  		{
118  			if (NppDarkMode::isEnabled())
119  			{
120  				return TRUE;
121  			}
122  			break;
123  		}
124  		case WM_DRAWITEM :
125  		{
126  			HICON hIcon = ::LoadIcon(_hInst, MAKEINTRESOURCE(IDI_DELETE_ICON));
127  			DRAWITEMSTRUCT *pdis = (DRAWITEMSTRUCT *)lParam;
128  			::DrawIcon(pdis->hDC, 0, 0, hIcon);
129  			return TRUE;
130  		}
131  		case WM_COMMAND :
132  		{
133  			if (LOWORD(wParam) == IDC_REGEXT_LANGEXT_LIST || LOWORD(wParam) == IDC_REGEXT_REGISTEREDEXTS_LIST)
134  			{
135  				if (HIWORD(wParam) == LBN_DBLCLK)
136  				{
137  					if (-1 != ::SendDlgItemMessage(_hSelf, LOWORD(wParam), LB_GETCURSEL, 0, 0))
138  					{
139  						HWND(lParam) == ::GetDlgItem(_hSelf, IDC_REGEXT_LANGEXT_LIST) ?
140  							::SendMessage(_hSelf, WM_COMMAND, IDC_ADDFROMLANGEXT_BUTTON, 0) :
<span onclick='openModal()' class='match'>141  							::SendMessage(_hSelf, WM_COMMAND, IDC_REMOVEEXT_BUTTON, 0);
142  					}
143  					return TRUE;
144  				}
</span>145  			}
146  			switch (wParam)
147  			{
148  				case IDC_ADDFROMLANGEXT_BUTTON :
149  				{
150  					writeNppPath();
151  					TCHAR ext2Add[extNameMax] = TEXT("");
152  					if (!_isCustomize)
153  					{
154  						auto index2Add = ::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANGEXT_LIST, LB_GETCURSEL, 0, 0);
155  						auto lbTextLen = ::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANGEXT_LIST, LB_GETTEXTLEN, index2Add, 0);
156  						if (lbTextLen > extNameMax - 1)
157  							return TRUE;
158  						::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANGEXT_LIST, LB_GETTEXT, index2Add, reinterpret_cast<LPARAM>(ext2Add));
159  						addExt(ext2Add);
160  						::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANGEXT_LIST, LB_DELETESTRING, index2Add, 0);
161  					}
162  					else
163  					{
164  						::SendDlgItemMessage(_hSelf, IDC_CUSTOMEXT_EDIT, WM_GETTEXT, extNameMax, reinterpret_cast<LPARAM>(ext2Add));
165  						auto i = ::SendDlgItemMessage(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST, LB_FINDSTRINGEXACT, 0, reinterpret_cast<LPARAM>(ext2Add));
166  						if (i != LB_ERR)
167  							return TRUE;
168  						addExt(ext2Add);
169  						::SendDlgItemMessage(_hSelf, IDC_CUSTOMEXT_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
170  					}
171  					::SendDlgItemMessage(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(ext2Add));
172  					::EnableWindow(::GetDlgItem(_hSelf, IDC_ADDFROMLANGEXT_BUTTON), false);
173  					return TRUE;
174  				}
175  				case IDC_REMOVEEXT_BUTTON :
176  				{
177  					TCHAR ext2Sup[extNameMax] = TEXT("");
178  					auto index2Sup = ::SendDlgItemMessage(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST, LB_GETCURSEL, 0, 0);
179  					auto lbTextLen = ::SendDlgItemMessage(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST, LB_GETTEXTLEN, index2Sup, 0);
180  					if (lbTextLen > extNameMax - 1)
181  						return TRUE;
182  					::SendDlgItemMessage(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST, LB_GETTEXT, index2Sup, reinterpret_cast<LPARAM>(ext2Sup));
183  					if (deleteExts(ext2Sup))
184  						::SendDlgItemMessage(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST, LB_DELETESTRING, index2Sup, 0);
185  					auto langIndex = ::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANG_LIST, LB_GETCURSEL, 0, 0);
186  					::EnableWindow(::GetDlgItem(_hSelf, IDC_REMOVEEXT_BUTTON), false);
187  					if (langIndex != LB_ERR)
188  					{
189  						for (int i = 1 ; i < nbExtMax ; ++i)
190  						{
191  							if (!wcsicmp(ext2Sup, defExtArray[langIndex][i]))
192  							{
193  								::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANGEXT_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(ext2Sup));
194  								return TRUE;
195  							}
196  						}
197  					}
198  					return TRUE;
199  				}
200  				case IDCANCEL:
201  				{
202  					::EndDialog(_hSelf, 0);
203  					return TRUE;
204  				}
205  			}
206  			if (HIWORD(wParam) == EN_CHANGE)
207  			{
208  				TCHAR text[extNameMax] = TEXT("");
209  				::SendDlgItemMessage(_hSelf, IDC_CUSTOMEXT_EDIT, WM_GETTEXT, extNameMax, reinterpret_cast<LPARAM>(text));
210  				if ((lstrlen(text) == 1) && (text[0] != '.'))
211  				{
212  					text[1] = text[0];
213  					text[0] = '.';
214  					text[2] = '\0';
215  					::SendDlgItemMessage(_hSelf, IDC_CUSTOMEXT_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(text));
216  					::SendDlgItemMessage(_hSelf, IDC_CUSTOMEXT_EDIT, EM_SETSEL, 2, 2);
217  				}
218  				::EnableWindow(::GetDlgItem(_hSelf, IDC_ADDFROMLANGEXT_BUTTON), (lstrlen(text) > 1));
219  				return TRUE;
220  			}
221  			if (HIWORD(wParam) == LBN_SELCHANGE)
222  			{
223  				auto i = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), LB_GETCURSEL, 0, 0);
224  				if (LOWORD(wParam) == IDC_REGEXT_LANG_LIST)
225  				{
226  					if (i != LB_ERR)
227  					{
228  						const size_t itemNameLen = 32;
229  						TCHAR itemName[itemNameLen + 1] = { '\0' };
230  						size_t lbTextLen = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), LB_GETTEXTLEN, i, 0);
231  						if (lbTextLen > itemNameLen)
232  							return TRUE;
233  						::SendDlgItemMessage(_hSelf, LOWORD(wParam), LB_GETTEXT, i, reinterpret_cast<LPARAM>(itemName));
234  						if (!wcsicmp(defExtArray[nbSupportedLang-1][0], itemName))
235  						{
236  							::ShowWindow(::GetDlgItem(_hSelf, IDC_REGEXT_LANGEXT_LIST), SW_HIDE);
237  							::ShowWindow(::GetDlgItem(_hSelf, IDC_CUSTOMEXT_EDIT), SW_SHOW);
238  							_isCustomize = true;
239  						}
240  						else
241  						{
242  							if (_isCustomize)
243  							{
244  								::ShowWindow(::GetDlgItem(_hSelf, IDC_REGEXT_LANGEXT_LIST), SW_SHOW);
245  								::ShowWindow(::GetDlgItem(_hSelf, IDC_CUSTOMEXT_EDIT), SW_HIDE);
246  								_isCustomize = false;
247  							}
248  							LRESULT count = ::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANGEXT_LIST, LB_GETCOUNT, 0, 0);
249  							for (count -= 1 ; count >= 0 ; count--)
250  								::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANGEXT_LIST, LB_DELETESTRING, count, 0);
251  							for (int j = 1 ; j < nbExtMax ; ++j)
252  							{
253  								if (lstrcmp(TEXT(""), defExtArray[i][j]))
254  								{
255  									auto index = ::SendDlgItemMessage(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST, LB_FINDSTRINGEXACT, 0, reinterpret_cast<LPARAM>(defExtArray[i][j]));
256  									if (index == -1)
257  										::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANGEXT_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(defExtArray[i][j]));
258  								}
259  							}
260  						}
261  						::EnableWindow(::GetDlgItem(_hSelf, IDC_ADDFROMLANGEXT_BUTTON), false);
262  					}
263  				}
264  				else if (LOWORD(wParam) == IDC_REGEXT_LANGEXT_LIST)
265  				{
266  					if (i != LB_ERR)
267  						::EnableWindow(::GetDlgItem(_hSelf, IDC_ADDFROMLANGEXT_BUTTON), true);
268  				}
269  				else if (LOWORD(wParam) == IDC_REGEXT_REGISTEREDEXTS_LIST)
270  				{
271  					if (i != LB_ERR)
272  						::EnableWindow(::GetDlgItem(_hSelf, IDC_REMOVEEXT_BUTTON), true);
273  				}
274  			}
275  			[[fallthrough]];
276  		}
277  		default :
278  			return FALSE;
279  	}
280  	return FALSE;
281  }
282  void RegExtDlg::getRegisteredExts()
283  {
284  	int nbRegisteredKey = getNbSubKey(HKEY_CLASSES_ROOT);
285  	for (int i = 0 ; i < nbRegisteredKey ; ++i)
286  	{
287  		TCHAR extName[extNameLen];
288  		int extNameActualLen = extNameLen;
289  		int res = ::RegEnumKeyEx(HKEY_CLASSES_ROOT, i, extName, reinterpret_cast<LPDWORD>(&extNameActualLen), nullptr, nullptr, nullptr, nullptr);
290  		if ((res == ERROR_SUCCESS) && (extName[0] == '.'))
291  		{
292  			TCHAR valData[extNameLen] = { '\0' };
293  			DWORD valDataLen = extNameLen * sizeof(TCHAR);
294  			DWORD valType = 0;
295  			HKEY hKey2Check;
296  			extNameActualLen = extNameLen;
297  			::RegOpenKeyEx(HKEY_CLASSES_ROOT, extName, 0, KEY_ALL_ACCESS, &hKey2Check);
298  			::RegQueryValueEx(hKey2Check, TEXT(""), nullptr, &valType, reinterpret_cast<LPBYTE>(valData), &valDataLen);
299  			if ((valType == REG_SZ) && (!lstrcmp(valData, nppName)))
300  				::SendDlgItemMessage(_hSelf, IDC_REGEXT_REGISTEREDEXTS_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(extName));
301  			::RegCloseKey(hKey2Check);
302  		}
303  	}
304  }
305  void RegExtDlg::getDefSupportedExts()
306  {
307  	for (int i = 0 ; i < nbSupportedLang ; ++i)
308  		::SendDlgItemMessage(_hSelf, IDC_REGEXT_LANG_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(defExtArray[i][0]));
309  }
310  void RegExtDlg::addExt(TCHAR *ext)
311  {
312  	HKEY  hKey;
313  	DWORD dwDisp = 0;
314  	long  nRet;
315  	nRet = ::RegCreateKeyEx(HKEY_CLASSES_ROOT, ext, 0, nullptr, 0, KEY_ALL_ACCESS, nullptr, &hKey, &dwDisp);
316  	if (nRet == ERROR_SUCCESS)
317  	{
318  		TCHAR valData[MAX_PATH] = { '\0' };
319  		DWORD valDataLen = MAX_PATH * sizeof(TCHAR);
320  		if (dwDisp == REG_OPENED_EXISTING_KEY)
321  		{
322  			int res = ::RegQueryValueEx(hKey, TEXT(""), nullptr, nullptr, reinterpret_cast<LPBYTE>(valData), &valDataLen);
323  			if (res == ERROR_SUCCESS)
324  				::RegSetValueEx(hKey, nppBackup, 0, REG_SZ, reinterpret_cast<LPBYTE>(valData), valDataLen);
325  		}
326  		::RegSetValueEx(hKey, nullptr, 0, REG_SZ, reinterpret_cast<const BYTE *>(nppName), static_cast<DWORD>((lstrlen(nppName) + 1) * sizeof(TCHAR)));
327  		::RegCloseKey(hKey);
328  	}
329  }
330  bool RegExtDlg::deleteExts(const TCHAR *ext2Delete)
331  {
332  	HKEY hKey;
333  	::RegOpenKeyEx(HKEY_CLASSES_ROOT, ext2Delete, 0, KEY_ALL_ACCESS, &hKey);
334  	int nbValue = getNbSubValue(hKey);
335  	int nbSubkey = getNbSubKey(hKey);
336  	if ((nbValue <= 1) && (!nbSubkey))
337  	{
338  		TCHAR subKey[32] = TEXT("\\");
339  		wcscat_s(subKey, ext2Delete);
340  		::RegDeleteKey(HKEY_CLASSES_ROOT, subKey);
341  	}
342  	else
343  	{
344  		TCHAR valData[extNameLen] = { '\0' };
345  		DWORD valDataLen = extNameLen*sizeof(TCHAR);
346  		DWORD valType = 0;
347  		int res = ::RegQueryValueEx(hKey, nppBackup, nullptr, &valType, (LPBYTE)valData, &valDataLen);
348  		if (res == ERROR_SUCCESS)
349  		{
350  			::RegSetValueEx(hKey, nullptr, 0, valType, (LPBYTE)valData, valDataLen);
351  			::RegDeleteValue(hKey, nppBackup);
352  		}
353  		else
354  			::RegDeleteValue(hKey, nullptr);
355  	}
356  	return true;
357  }
358  void RegExtDlg::writeNppPath()
359  {
360  	HKEY  hKey, hRootKey;
361  	DWORD dwDisp = 0;
362  	long  nRet = 0;
363  	generic_string regStr(nppName);
364  	regStr += TEXT("\\shell\\open\\command");
365  	nRet = ::RegCreateKeyEx(HKEY_CLASSES_ROOT, regStr.c_str(), 0, nullptr, 0, KEY_ALL_ACCESS, nullptr, &hKey, &dwDisp);
366  	if (nRet == ERROR_SUCCESS)
367  	{
368  		{
369  			::RegOpenKeyEx(HKEY_CLASSES_ROOT, nppName, 0, KEY_ALL_ACCESS, &hRootKey);
370  			::RegSetValueEx(hRootKey, nullptr, 0, REG_SZ, (LPBYTE)nppDoc, static_cast<DWORD>((lstrlen(nppDoc) + 1) * sizeof(TCHAR)));
371  			RegCloseKey(hRootKey);
372  			TCHAR nppPath[MAX_PATH] = { '\0' };
373  			::GetModuleFileName(_hInst, nppPath, MAX_PATH);
374  			TCHAR nppPathParam[MAX_PATH] = TEXT("\""); 
375  			wcscat_s(nppPathParam, nppPath);
376  			wcscat_s(nppPathParam, TEXT("\" \"%1\""));
377  			::RegSetValueEx(hKey, nullptr, 0, REG_SZ, (LPBYTE)nppPathParam, static_cast<DWORD>((lstrlen(nppPathParam) + 1) * sizeof(TCHAR)));
378  		}
379  		RegCloseKey(hKey);
380  	}
381  	regStr = nppName;
382  	regStr += TEXT("\\DefaultIcon");
383  	nRet = ::RegCreateKeyEx(HKEY_CLASSES_ROOT, regStr.c_str(), 0, nullptr, 0, KEY_ALL_ACCESS, nullptr, &hKey, &dwDisp);
384  	if (nRet == ERROR_SUCCESS)
385  	{
386  		{
387  			TCHAR nppPath[MAX_PATH] = { '\0' };
388  			::GetModuleFileName(_hInst, nppPath, MAX_PATH);
389  			TCHAR nppPathParam[MAX_PATH] = TEXT("\"");
390  			wcscat_s(nppPathParam, nppPath);
391  			wcscat_s(nppPathParam, TEXT("\",0"));
392  			::RegSetValueEx(hKey, nullptr, 0, REG_SZ, (LPBYTE)nppPathParam, static_cast<DWORD>((lstrlen(nppPathParam) + 1) * sizeof(TCHAR)));
393  		}
394  		RegCloseKey(hKey);
395  	}
396  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-VerticalFileSwitcher.cpp</h3>
            <pre><code>1  #include "VerticalFileSwitcher.h"
2  #include "menuCmdID.h"
3  #include "Parameters.h"
4  #include "resource.h"
5  #include "localization.h"
6  #define GET_X_LPARAM(lp) static_cast<short>(LOWORD(lp))
7  #define GET_Y_LPARAM(lp) static_cast<short>(HIWORD(lp))
8  #define CLMNEXT_ID     1
9  #define CLMNPATH_ID    2
10  #define SEP_POS        3
11  #define LVGROUPS_ID    4
12  COLORREF VerticalFileSwitcher::_bgColor = 0xFFFFFF;
13  int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
14  {
15  	sortCompareData* sortData = (sortCompareData*)lParamSort;
16  	TCHAR str1[MAX_PATH] = { '\0' };
17  	TCHAR str2[MAX_PATH] = { '\0' };
18  	ListView_GetItemText(sortData->hListView, lParam1, sortData->columnIndex, str1, sizeof(str1));
19  	ListView_GetItemText(sortData->hListView, lParam2, sortData->columnIndex, str2, sizeof(str2));
20  	int result = lstrcmp(str1, str2);
21  	if (sortData->sortDirection == SORT_DIRECTION_UP)
22  		return result;
23  	return (0 - result);
24  }
25  LRESULT run_listViewProc(WNDPROC oldEditProc, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
26  {
27  	switch (message)
28  	{
29  		case WM_MBUTTONUP:
30  		{
31  			::SendMessage(::GetParent(hwnd), WM_PARENTNOTIFY, WM_MBUTTONUP, lParam);
32  			return TRUE;
33  		}
34  		default:
35  			break;
36  	}
37  	return ::CallWindowProc(oldEditProc, hwnd, message, wParam, lParam);
38  }
39  void VerticalFileSwitcher::startColumnSort()
40  {
41  	HWND colHeader = reinterpret_cast<HWND>(SendMessage(_fileListView.getHSelf(), LVM_GETHEADER, 0, 0));
42  	int columnCount = static_cast<int32_t>(SendMessage(colHeader, HDM_GETITEMCOUNT, 0, 0));
43  	if (_lastSortingColumn >= columnCount)
44  	{
45  		_lastSortingColumn = 0;
46  		_lastSortingDirection = SORT_DIRECTION_NONE;
47  	}
48  	if (_lastSortingDirection != SORT_DIRECTION_NONE)
49  	{
50  		sortCompareData sortData = {_fileListView.getHSelf(), _lastSortingColumn, _lastSortingDirection};
51  		ListView_SortItemsEx(_fileListView.getHSelf(), ListViewCompareProc, reinterpret_cast<LPARAM>(&sortData));
52  	}
53  	updateHeaderArrow();
54  }
55  LRESULT VerticalFileSwitcher::listViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
56  {
57  	auto lplvcd = reinterpret_cast<LPNMLVCUSTOMDRAW>(lParam);
58  	switch (lplvcd->nmcd.dwDrawStage)
59  	{
60  		case CDDS_PREPAINT:
61  		{
62  			if ((lplvcd->dwItemType == LVCDI_GROUP) && NppDarkMode::isThemeDark())
63  			{
64  				RECT rcHeader{};
65  				ListView_GetGroupRect(lplvcd->nmcd.hdr.hwndFrom, lplvcd->nmcd.dwItemSpec, LVGGR_HEADER, &rcHeader);
66  				HBRUSH hBrush = ::CreateSolidBrush(VerticalFileSwitcher::_bgColor);
67  				::FillRect(lplvcd->nmcd.hdc, &rcHeader, hBrush);
68  				::DeleteObject(hBrush);
69  				hBrush = nullptr;
70  			}
71  			return CDRF_NOTIFYITEMDRAW;
72  		}
73  		case CDDS_ITEMPREPAINT:
74  		{
75  			const RECT& rcRow = lplvcd->nmcd.rc;
76  			const bool isThemeDark = NppDarkMode::isThemeDark();
77  			const auto hHeader = ListView_GetHeader(lplvcd->nmcd.hdr.hwndFrom);
78  			const auto colCount = Header_GetItemCount(hHeader);
79  			const LONG paddingLeft = isThemeDark ? 1 : 0;
80  			const LONG paddingRight = isThemeDark ? 2 : 1;
81  			RECT rcSubItem{ rcRow };
82  			RECT rcSubItem2{};
83  			RECT rcSubItem3{};
84  			rcSubItem.right -= paddingRight;
85  			auto setRectForSubItem = [hHeader, paddingLeft, paddingRight](RECT& first, RECT& second, int idxSecond) -> void {
86  				Header_GetItemRect(hHeader, idxSecond, &second);
87  				first.right = second.left - paddingRight;
88  				second.left -= paddingLeft;
89  				second.right -= paddingRight;
90  				second.top = first.top;
91  				second.bottom = first.bottom;
92  			};
93  			if (colCount >= 2)
94  			{
95  				setRectForSubItem(rcSubItem, rcSubItem2, 1);
96  			}
97  			if (colCount == 3)
98  			{
99  				setRectForSubItem(rcSubItem2, rcSubItem3, 2);
100  			}
101  			const auto isSelected = ListView_GetItemState(lplvcd->nmcd.hdr.hwndFrom, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
102  			const bool isHot = (lplvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT;
103  			const int colorID = reinterpret_cast<TaskLstFnStatus*>(lplvcd->nmcd.lItemlParam)->_docColor;
104  			COLORREF bgColor{0xFFFFFF};
105  			bool applyColor = false;
106  			if (colorID != -1)
107  			{
108  				bgColor = NppDarkMode::getIndividualTabColour(colorID, isThemeDark, false);
109  				applyColor = true;
110  			}
111  			else if (isThemeDark)
112  			{
113  				if (isSelected)
114  				{
115  					bgColor = NppDarkMode::getSofterBackgroundColor();
116  					applyColor = true;
117  				}
118  				else if (isHot)
119  				{
120  					bgColor = NppDarkMode::getHotBackgroundColor();
121  					applyColor = true;
122  				}
123  			}
124  			if (applyColor)
125  			{
126  				if (isThemeDark)
127  				{
128  					lplvcd->clrText = NppDarkMode::getTextColor();
129  				}
130  				lplvcd->clrTextBk = bgColor;
131  				HBRUSH hBrush = ::CreateSolidBrush(bgColor);
132  				::FillRect(lplvcd->nmcd.hdc, &rcSubItem, hBrush);
133  				if (colCount >= 2)
134  				{
135  					::FillRect(lplvcd->nmcd.hdc, &rcSubItem2, hBrush);
136  				}
137  				if (colCount == 3)
138  				{
139  					::FillRect(lplvcd->nmcd.hdc, &rcSubItem3, hBrush);
140  				}
141  				::DeleteObject(hBrush);
142  				hBrush = nullptr;
143  			}
144  			if (isSelected)
145  			{
146  				::DrawFocusRect(lplvcd->nmcd.hdc, &rcRow);
147  			} 
148  			else if (isHot)
149  			{
150  				::FrameRect(lplvcd->nmcd.hdc, &rcRow, isThemeDark ? NppDarkMode::getHotEdgeBrush() : ::GetSysColorBrush(COLOR_WINDOWTEXT));
151  			}
152  			return CDRF_NEWFONT;
153  		}
154  		default:
155  			break;
156  	}
157  	return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
158  }
159  LRESULT CALLBACK VerticalFileSwitcher::FileSwitcherNotifySubclass(
160  	HWND hWnd,
161  	UINT uMsg,
162  	WPARAM wParam,
163  	LPARAM lParam,
164  	UINT_PTR uIdSubclass,
165  	DWORD_PTR &bsol;*dwRefData*/
166  )
167  {
168  	switch (uMsg)
169  	{
170  		case WM_NCDESTROY:
171  		{
172  			::RemoveWindowSubclass(hWnd, VerticalFileSwitcher::FileSwitcherNotifySubclass, uIdSubclass);
173  			break;
174  		}
175  		case WM_NOTIFY:
176  		{
177  			auto nmhdr = reinterpret_cast<LPNMHDR>(lParam);
178  			switch (nmhdr->code)
179  			{
180  				case NM_CUSTOMDRAW:
181  				{
182  					constexpr size_t classNameLen = 16;
183  					wchar_t className[classNameLen]{};
184  					GetClassName(nmhdr->hwndFrom, className, classNameLen);
185  					if (wcscmp(className, WC_LISTVIEW) == 0)
186  					{
187  						return VerticalFileSwitcher::listViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam);
188  					}
189  					break;
190  				}
191  			}
192  			break;
193  		}
194  	}
195  	return DefSubclassProc(hWnd, uMsg, wParam, lParam);
196  }
197  void VerticalFileSwitcher::autoSubclassWindowNotify(HWND hParent)
198  {
199  	::SetWindowSubclass(hParent, VerticalFileSwitcher::FileSwitcherNotifySubclass, _fileSwitcherNotifySubclassID, 0);
200  }
201  intptr_t CALLBACK VerticalFileSwitcher::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
202  {
203  	switch (message)
204  	{
205  		case WM_INITDIALOG :
206  		{
207  			VerticalFileSwitcher::initPopupMenus();
208  			_fileListView.init(_hInst, _hSelf, _hImaLst);
209  			_fileListView.initList();
210  			_fileListView.display();
211  			::SetWindowLongPtr(_fileListView.getHSelf(), GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
212  			_defaultListViewProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_fileListView.getHSelf(), GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(listViewStaticProc)));
213  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
214  			VerticalFileSwitcher::autoSubclassWindowNotify(_hSelf);
215  			return TRUE;
216  		}
217  		case NPPM_INTERNAL_REFRESHDARKMODE:
218  		{
219  			NppDarkMode::autoThemeChildControls(_hSelf);
220  			return TRUE;
221  		}
222  		case WM_PARENTNOTIFY:
223  		{
224  			switch ( wParam )
225  			{
226  				case WM_MBUTTONUP:
227  				{
228  					LVHITTESTINFO hitInfo{};
229  					hitInfo.pt.x = GET_X_LPARAM(lParam);
230  					hitInfo.pt.y = GET_Y_LPARAM(lParam);
231  					::ClientToScreen(getHSelf(), &hitInfo.pt);
232  					::ScreenToClient(_fileListView.getHSelf(), &hitInfo.pt);
233  					ListView_HitTest(_fileListView.getHSelf(), &hitInfo);
234  					if (hitInfo.iItem != -1)
235  					{
236  						LVITEM item{};
237  						item.mask = LVIF_PARAM;
238  						item.iItem = hitInfo.iItem;	
239  						ListView_GetItem(_fileListView.getHSelf(), &item);
240  						TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
241  						closeDoc(tlfs);
242  						return TRUE;
243  					}
244  				}
245  			}
246  			break;
247  		}
248  		case WM_NOTIFY:
249  		{
250  			switch (reinterpret_cast<LPNMHDR>(lParam)->code)
251  			{
252  				case DMN_CLOSE:
253  				{
254  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DOCLIST, 0);
255  					return TRUE;
256  				}
257  				case NM_DBLCLK:
258  				{
259  					LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE) lParam;
260  					int i = lpnmitem->iItem;
261  					if (i == -1)
262  					{
<span onclick='openModal()' class='match'>263  						::SendMessage(_hParent, WM_COMMAND, IDM_FILE_NEW, 0);
264  					}
265  					return TRUE;
266  				}
</span>267  				case NM_CLICK:
268  				{
269  					if ((0x80 & GetKeyState(VK_CONTROL)) || (0x80 & GetKeyState(VK_SHIFT)))
270  						return TRUE;
271  					LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE) lParam;
272  					int nbItem = ListView_GetItemCount(_fileListView.getHSelf());
273  					int i = lpnmitem->iItem;
274  					if (i == -1 || i >= nbItem)
275  						return TRUE;
276  					LVITEM item{};
277  					item.mask = LVIF_PARAM;
278  					item.iItem = i;
279  					ListView_GetItem(((LPNMHDR)lParam)->hwndFrom, &item);
280  					TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
281  					activateDoc(tlfs);
282  					return TRUE;
283  				}
284  				case NM_RCLICK :
285  				{
286  					LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE) lParam;
287  					if (lpnmitem->hdr.hwndFrom != _fileListView.getHSelf())
288  					{
289  						colHeaderRClick = true;
290  						return TRUE;
291  					}
292  					int nbItem = ListView_GetItemCount(_fileListView.getHSelf());
293  					if (nbSelectedFiles() == 1)
294  					{
295  						int i = lpnmitem->iItem;
296  						if (i == -1 || i >= nbItem)
297   							return TRUE;
298  						LVITEM item{};
299  						item.mask = LVIF_PARAM;
300  						item.iItem = i;
301  						ListView_GetItem(((LPNMHDR)lParam)->hwndFrom, &item);
302  						TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
303  						activateDoc(tlfs);
304  					}
305  					if (nbSelectedFiles() >= 1)
306  					{
307  						NMHDR nmhdr{};
308  						nmhdr.code = reinterpret_cast<LPNMHDR>(lParam)->code; 
309  						nmhdr.hwndFrom = _hSelf;
310  						nmhdr.idFrom = ::GetDlgCtrlID(nmhdr.hwndFrom);
311  						::SendMessage(_hParent, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
312  					}
313  					return TRUE;
314  				}
315  				case LVN_GETINFOTIP:
316  				{
317  					LPNMLVGETINFOTIP pGetInfoTip = (LPNMLVGETINFOTIP)lParam;
318  					int i = pGetInfoTip->iItem;
319  					if (i == -1)
320  						return TRUE;
321  					generic_string fn = getFullFilePath((size_t)i);
322  					lstrcpyn(pGetInfoTip->pszText, fn.c_str(), pGetInfoTip->cchTextMax);
323  					return TRUE;
324  				}
325  				case LVN_COLUMNCLICK:
326  				{
327  					LPNMLISTVIEW pnmLV = (LPNMLISTVIEW)lParam;
328  					_lastSortingDirection = setHeaderOrder(pnmLV->iSubItem);
329  					_lastSortingColumn = pnmLV->iSubItem;
330  					if (_lastSortingDirection != SORT_DIRECTION_NONE)
331  					{
332  						startColumnSort();
333  					}
334  					else
335  					{
336  						_fileListView.reload();
337  						updateHeaderArrow();
338  					}
339  					return TRUE;
340  				}
341  				case HDN_DIVIDERDBLCLICK:
342  				case HDN_ENDTRACK:
343  				{
344  					NppParameters& nppParams = NppParameters::getInstance();
345  					NativeLangSpeaker* pNativeSpeaker = nppParams.getNativeLangSpeaker();
346  					LPNMHEADER test = (LPNMHEADER)lParam;
347  					HWND hwndHD = ListView_GetHeader(_fileListView.getHSelf());
348  					TCHAR HDtext[MAX_PATH] = { '\0' };
349  					HDITEM hdi = {};
350  					hdi.mask = HDI_TEXT | HDI_WIDTH;
351  					hdi.pszText = HDtext;
352  					hdi.cchTextMax = MAX_PATH;
353  					Header_GetItem(hwndHD, test->iItem, &hdi);
354  					if (hdi.pszText == pNativeSpeaker->getAttrNameStr(TEXT("Ext."), FS_ROOTNODE, FS_CLMNEXT))
355  						nppParams.getNppGUI()._fileSwitcherExtWidth = hdi.cxy;
356  					else if (hdi.pszText == pNativeSpeaker->getAttrNameStr(TEXT("Path"), FS_ROOTNODE, FS_CLMNPATH))
357  						nppParams.getNppGUI()._fileSwitcherPathWidth = hdi.cxy;
358  					return TRUE;
359  				}
360  				case LVN_KEYDOWN:
361  				{
362  					switch (((LPNMLVKEYDOWN)lParam)->wVKey)
363  					{
364  						case VK_RETURN:
365  						{
366  							int i = ListView_GetSelectionMark(_fileListView.getHSelf());
367  							if (i == -1)
368  								return TRUE;
369  							LVITEM item{};
370  							item.mask = LVIF_PARAM;
371  							item.iItem = i;	
372  							ListView_GetItem(((LPNMHDR)lParam)->hwndFrom, &item);
373  							TaskLstFnStatus *tlfs = (TaskLstFnStatus *)item.lParam;
374  							activateDoc(tlfs);
375  							return TRUE;
376  						}
377  						default:
378  							break;
379  					}
380  				}
381  				break;
382  				default:
383  					break;
384  			}
385  		}
386  		return TRUE;
387          case WM_SIZE:
388          {
389  			int width = LOWORD(lParam);
390              int height = HIWORD(lParam);
391  			::MoveWindow(_fileListView.getHSelf(), 0, 0, width, height, TRUE);
392  			_fileListView.resizeColumns(width);
393              break;
394          }
395  		case WM_CONTEXTMENU:
396  		{
397  			if (nbSelectedFiles() == 0 || colHeaderRClick)
398  			{
399  				::TrackPopupMenu(_hGlobalMenu, 
400  					NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
401  					GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), 0, _hSelf, NULL);
402  				colHeaderRClick = false;
403  			}
404  			return TRUE;
405  		}
406  		case WM_COMMAND:
407  		{
408  			popupMenuCmd(LOWORD(wParam));
409  			break;
410  		}
411  		case WM_DESTROY:
412          {
413  			_fileListView.destroy();
414  			::DestroyMenu(_hGlobalMenu);
415              break;
416          }
417          default :
418              return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
419      }
420  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
421  }
422  void VerticalFileSwitcher::initPopupMenus()
423  {
424  	NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
425  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
426  	generic_string extStr = pNativeSpeaker->getAttrNameStr(TEXT("Ext."), FS_ROOTNODE, FS_CLMNEXT);
427  	generic_string pathStr = pNativeSpeaker->getAttrNameStr(TEXT("Path"), FS_ROOTNODE, FS_CLMNPATH);
428  	generic_string groupStr = pNativeSpeaker->getAttrNameStr(TEXT("Group by View"), FS_ROOTNODE, FS_LVGROUPS);
429  	_hGlobalMenu = ::CreatePopupMenu();
430  	::InsertMenu(_hGlobalMenu, CLMNEXT_ID, MF_BYCOMMAND | MF_STRING, CLMNEXT_ID, extStr.c_str());
431  	::InsertMenu(_hGlobalMenu, CLMNPATH_ID, MF_BYCOMMAND | MF_STRING, CLMNPATH_ID, pathStr.c_str());
432  	::InsertMenu(_hGlobalMenu, SEP_POS, MF_BYCOMMAND | MF_SEPARATOR, 0, nullptr);
433  	::InsertMenu(_hGlobalMenu, LVGROUPS_ID, MF_BYCOMMAND | MF_STRING, LVGROUPS_ID, groupStr.c_str());
434  	bool isExtColumn = nppGUI._fileSwitcherWithoutExtColumn;
435  	::CheckMenuItem(_hGlobalMenu, CLMNEXT_ID, MF_BYCOMMAND | (isExtColumn ? MF_UNCHECKED : MF_CHECKED));
436  	bool isPathColumn = nppGUI._fileSwitcherWithoutPathColumn;
437  	::CheckMenuItem(_hGlobalMenu, CLMNPATH_ID, MF_BYCOMMAND | (isPathColumn ? MF_UNCHECKED : MF_CHECKED));
438  	bool isListViewGroups = nppGUI._fileSwitcherDisableListViewGroups;
439  	::CheckMenuItem(_hGlobalMenu, LVGROUPS_ID, MF_BYCOMMAND | (isListViewGroups ? MF_UNCHECKED : MF_CHECKED));
440  }
441  void VerticalFileSwitcher::popupMenuCmd(int cmdID)
442  {
443  	switch (cmdID)
444  	{
445  		case CLMNEXT_ID:
446  		{
447  			bool& isExtColumn = NppParameters::getInstance().getNppGUI()._fileSwitcherWithoutExtColumn;
448  			isExtColumn = !isExtColumn;
449  			::CheckMenuItem(_hGlobalMenu, CLMNEXT_ID, MF_BYCOMMAND | (isExtColumn ? MF_UNCHECKED : MF_CHECKED));
450  			reload();
451  		}
452  		break;
453  		case CLMNPATH_ID:
454  		{
455  			bool& isPathColumn = NppParameters::getInstance().getNppGUI()._fileSwitcherWithoutPathColumn;
456  			isPathColumn = !isPathColumn;
457  			::CheckMenuItem(_hGlobalMenu, CLMNPATH_ID, MF_BYCOMMAND | (isPathColumn ? MF_UNCHECKED : MF_CHECKED));
458  			reload();
459  		}
460  		break;
461  		case LVGROUPS_ID:
462  		{
463  			bool& isListViewGroups = NppParameters::getInstance().getNppGUI()._fileSwitcherDisableListViewGroups;
464  			isListViewGroups = !isListViewGroups;
465  			::CheckMenuItem(_hGlobalMenu, LVGROUPS_ID, MF_BYCOMMAND | (isListViewGroups ? MF_UNCHECKED : MF_CHECKED));
466  			reload();
467  		}
468  		break;
469  	}
470  }
471  void VerticalFileSwitcher::display(bool toShow) const
472  {
473  	DockingDlgInterface::display(toShow);
474  	_fileListView.ensureVisibleCurrentItem();	
475  }
476  void VerticalFileSwitcher::activateDoc(TaskLstFnStatus *tlfs) const
477  {
478  	int view = tlfs->_iView;
479  	BufferID bufferID = static_cast<BufferID>(tlfs->_bufID);
480  	auto currentView = ::SendMessage(_hParent, NPPM_GETCURRENTVIEW, 0, 0);
481  	BufferID currentBufID = reinterpret_cast<BufferID>(::SendMessage(_hParent, NPPM_GETCURRENTBUFFERID, 0, 0));
482  	if (bufferID == currentBufID && view == currentView)
483  		return;
484  	int docPosInfo = static_cast<int32_t>(::SendMessage(_hParent, NPPM_GETPOSFROMBUFFERID, reinterpret_cast<WPARAM>(bufferID), view));
485  	int view2set = docPosInfo >> 30;
486  	int index2Switch = (docPosInfo << 2) >> 2;
487  	::SendMessage(_hParent, NPPM_ACTIVATEDOC, view2set, index2Switch);
488  }
489  void VerticalFileSwitcher::closeDoc(TaskLstFnStatus *tlfs) const
490  {
491  	int view = tlfs->_iView;
492  	BufferID bufferID = static_cast<BufferID>(tlfs->_bufID);
493  	int docPosInfo = static_cast<int32_t>(::SendMessage(_hParent, NPPM_GETPOSFROMBUFFERID, reinterpret_cast<WPARAM>(bufferID), view));
494  	int view2set = docPosInfo >> 30;
495  	int index2Switch = (docPosInfo << 2) >> 2;
496  	::SendMessage(_hParent, NPPM_INTERNAL_CLOSEDOC, view2set, index2Switch);
497  }
498  int VerticalFileSwitcher::setHeaderOrder(int columnIndex)
499  {
500  	HWND hListView = _fileListView.getHSelf();
501  	LVCOLUMN lvc{};
502  	lvc.mask = LVCF_FMT;
503  	if (_lastSortingColumn != columnIndex && _lastSortingDirection != SORT_DIRECTION_NONE)
504  	{
505  		HWND colHeader = reinterpret_cast<HWND>(SendMessage(hListView, LVM_GETHEADER, 0, 0));
506  		int columnCount = static_cast<int32_t>(SendMessage(colHeader, HDM_GETITEMCOUNT, 0, 0));
507  		if (_lastSortingColumn < columnCount)
508  		{
509  			SendMessage(hListView, LVM_GETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
510  			lvc.fmt = lvc.fmt & (~HDF_SORTUP) & (~HDF_SORTDOWN);
511  			SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
512  		}
513  		_lastSortingDirection = SORT_DIRECTION_NONE;
514  	}
515  	if (_lastSortingDirection == SORT_DIRECTION_NONE)
516  	{
517  		return SORT_DIRECTION_UP;
518  	}
519  	if (_lastSortingDirection == SORT_DIRECTION_UP)
520  	{
521  		return SORT_DIRECTION_DOWN;
522  	}
523  	return SORT_DIRECTION_NONE;
524  }
525  void VerticalFileSwitcher::updateHeaderArrow()
526  {
527  	HWND hListView = _fileListView.getHSelf();
528  	LVCOLUMN lvc{};
529  	lvc.mask = LVCF_FMT;
530  	SendMessage(hListView, LVM_GETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
531  	if (_lastSortingDirection == SORT_DIRECTION_UP)
532  	{
533  		lvc.fmt = (lvc.fmt | HDF_SORTUP) & ~HDF_SORTDOWN;
534  		SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
535  	}
536  	else if (_lastSortingDirection == SORT_DIRECTION_DOWN)
537  	{
538  		lvc.fmt = (lvc.fmt & ~HDF_SORTUP) | HDF_SORTDOWN;
539  		SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
540  	}
541  	else if (_lastSortingDirection == SORT_DIRECTION_NONE)
542  	{
543  		lvc.fmt = lvc.fmt & (~HDF_SORTUP) & (~HDF_SORTDOWN);
544  		SendMessage(hListView, LVM_SETCOLUMN, _lastSortingColumn, reinterpret_cast<LPARAM>(&lvc));
545  	}
546  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-regExtDlg.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-VerticalFileSwitcher.cpp</div>
                </div>
                <div class="column column_space"><pre><code>141  							::SendMessage(_hSelf, WM_COMMAND, IDC_REMOVEEXT_BUTTON, 0);
142  					}
143  					return TRUE;
144  				}
</pre></code></div>
                <div class="column column_space"><pre><code>263  						::SendMessage(_hParent, WM_COMMAND, IDM_FILE_NEW, 0);
264  					}
265  					return TRUE;
266  				}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    