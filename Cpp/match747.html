<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_transport_tcp.cpp &amp; TestValues.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_transport_tcp.cpp &amp; TestValues.cpp
      </h3>
<h1 align="center">
        2.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_transport_tcp.cpp (4.057971%)<th>TestValues.cpp (2.1472392%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(330-348)<td><a href="#" name="0">(136-167)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_transport_tcp.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;gtest/gtest.h&gt;
#include "ros/poll_set.h"
#include "ros/transport/transport_tcp.h"
#include &lt;boost/bind.hpp&gt;
#include &lt;boost/thread.hpp&gt;
using namespace ros;
class Synchronous : public testing::Test
{
public:
  Synchronous()
  {
  }
  ~Synchronous()
  {
  }
protected:
  virtual void SetUp()
  {
    transports_[0] = boost::make_shared&lt;TransportTCP&gt;(static_cast&lt;ros::PollSet*&gt;(NULL), TransportTCP::SYNCHRONOUS);
    transports_[1] = boost::make_shared&lt;TransportTCP&gt;(static_cast&lt;ros::PollSet*&gt;(NULL), TransportTCP::SYNCHRONOUS);
    if (!transports_[0]-&gt;listen(0, 100, TransportTCP::AcceptCallback()))
    {
      FAIL();
    }
    if (!transports_[1]-&gt;connect("localhost", transports_[0]-&gt;getServerPort()))
    {
      FAIL();
    }
    transports_[2] = transports_[0]-&gt;accept();
    if (!transports_[2])
    {
      FAIL();
    }
  }
  virtual void TearDown()
  {
    for (int i = 0; i &lt; 3; ++i)
    {
      if (transports_[i])
      {
        transports_[i]-&gt;close();
      }
    }
  }
  TransportTCPPtr transports_[3];
};
TEST_F(Synchronous, writeThenRead)
{
  std::string msg = "test";
  int32_t written = transports_[1]-&gt;write((uint8_t*)msg.c_str(), msg.length());
  ASSERT_EQ(written, (int32_t)msg.length());
  uint8_t buf[5];
  memset(buf, 0, sizeof(buf));
  int32_t read = transports_[2]-&gt;read(buf, msg.length());
  ASSERT_EQ(read, (int32_t)msg.length());
  ASSERT_STREQ((const char*)buf, msg.c_str());
}
TEST_F(Synchronous, writeThenReadPartial)
{
  std::string msg = "test";
  int32_t written = transports_[1]-&gt;write((uint8_t*)msg.c_str(), msg.length());
  ASSERT_EQ(written, (int32_t)msg.length());
  uint8_t buf[5];
  memset(buf, 0, sizeof(buf));
  int32_t read = transports_[2]-&gt;read(buf, 1);
  ASSERT_EQ(read, 1);
  ASSERT_STREQ((const char*)buf, msg.substr(0, 1).c_str());
}
void readThread(TransportTCPPtr transport, uint8_t* buf, uint32_t size, volatile int32_t* read_out, volatile bool* done_read)
{
  while (*read_out &lt; (int32_t)size)
  {
    *read_out += transport-&gt;read(buf + *read_out, size - *read_out);
  }
  *done_read = true;
}
TEST_F(Synchronous, readWhileWriting)
{
  for (int i = 0; i &lt; 10; ++i)
  {
    const uint32_t buf_size = 1024*1024;
    boost::shared_ptr&lt;uint8_t[]&gt; read_buf(new uint8_t[buf_size]);
    std::stringstream ss;
    for (int i = 0; i &lt; 100000; ++i)
    {
      ss &lt;&lt; i;
    }
    std::string msg = ss.str();
    ASSERT_TRUE(msg.size() &lt; buf_size);
    volatile int32_t read_out = 0;
    volatile bool done_read = false;
    boost::thread t(boost::bind(readThread, transports_[2], read_buf.get(), msg.size(), &amp;read_out, &amp;done_read));
    boost::this_thread::sleep(boost::posix_time::milliseconds(50));
    int32_t written = transports_[1]-&gt;write((uint8_t*)msg.c_str(), msg.length());
    ASSERT_EQ(written, (int32_t)msg.length());
    while (!done_read)
    {
      boost::this_thread::sleep(boost::posix_time::milliseconds(1));
    }
    ASSERT_EQ(done_read, true);
    ASSERT_EQ(read_out, (int32_t)msg.length());
    ASSERT_STREQ((const char*)read_buf.get(), msg.c_str());
  }
}
TEST_F(Synchronous, readAfterClose)
{
  transports_[1]-&gt;close();
  uint8_t buf[5];
  int32_t read = transports_[1]-&gt;read(buf, 1);
  ASSERT_EQ(read, -1);
}
TEST_F(Synchronous, writeAfterClose)
{
  transports_[1]-&gt;close();
  std::string msg = "test";
  int32_t written = transports_[1]-&gt;write((uint8_t*)msg.c_str(), msg.length());
  ASSERT_EQ(written, -1);
}
class Polled : public testing::Test
{
public:
  Polled()
  {
  }
  ~Polled()
  {
  }
protected:
  void connectionReceived(const TransportTCPPtr&amp; transport)
  {
    transports_[2] = transport;
  }
  void pollThread()
  {
    while (continue_)
    {
      poll_set_.update(10);
    }
  }
  void onReadable(const TransportPtr&amp; transport, int index)
  {
    ASSERT_EQ(transport, transports_[index]);
    uint8_t b = 0;
    while (transport-&gt;read(&amp;b, 1) &gt; 0)
    {
      ++bytes_read_[index];
    }
  }
  void onWriteable(const TransportPtr&amp; transport, int index)
  {
    ASSERT_EQ(transport, transports_[index]);
    uint8_t b = 0;
    transport-&gt;write(&amp;b, 1);
    ++bytes_written_[index];
  }
  void onDisconnect(const TransportPtr&amp; transport, int index)
  {
    ASSERT_EQ(transport, transports_[index]);
    disconnected_[index] = true;
  }
  virtual void SetUp()
  {
    bytes_read_[0] = 0;
    bytes_read_[1] = 0;
    bytes_read_[2] = 0;
    bytes_written_[0] = 0;
    bytes_written_[1] = 0;
    bytes_written_[2] = 0;
    disconnected_[0] = false;
    disconnected_[1] = false;
    disconnected_[2] = false;
    transports_[0] = boost::make_shared&lt;TransportTCP&gt;(&amp;poll_set_);
    transports_[1] = boost::make_shared&lt;TransportTCP&gt;(&amp;poll_set_);
    if (!transports_[0]-&gt;listen(0, 100, boost::bind(&amp;Polled::connectionReceived, this, boost::placeholders::_1)))
    {
      FAIL();
    }
    if (!transports_[1]-&gt;connect("localhost", transports_[0]-&gt;getServerPort()))
    {
      FAIL();
    }
    continue_ = true;
    poll_thread_ = boost::thread(boost::bind(&amp;Polled::pollThread, this));
    int count = 0;
    while (!transports_[2] &amp;&amp; count &lt; 100)
    {
      boost::this_thread::sleep(boost::posix_time::milliseconds(50));
    }
    if (!transports_[2])
    {
      FAIL();
    }
    transports_[1]-&gt;setReadCallback(boost::bind(&amp;Polled::onReadable, this, boost::placeholders::_1, 1));
    transports_[2]-&gt;setReadCallback(boost::bind(&amp;Polled::onReadable, this, boost::placeholders::_1, 2));
    transports_[1]-&gt;setWriteCallback(boost::bind(&amp;Polled::onWriteable, this, boost::placeholders::_1, 1));
    transports_[2]-&gt;setWriteCallback(boost::bind(&amp;Polled::onWriteable, this, boost::placeholders::_1, 2));
    transports_[1]-&gt;setDisconnectCallback(boost::bind(&amp;Polled::onDisconnect, this, boost::placeholders::_1, 1));
    transports_[2]-&gt;setDisconnectCallback(boost::bind(&amp;Polled::onDisconnect, this, boost::placeholders::_1, 2));
    transports_[1]-&gt;enableRead();
    transports_[2]-&gt;enableRead();
  }
  virtual void TearDown()
  {
    for (int i = 0; i &lt; 3; ++i)
    {
      transports_[i]-&gt;close();
    }
    continue_ = false;
    poll_thread_.join();
  }
  TransportTCPPtr transports_[3];
  int bytes_read_[3];
  int bytes_written_[3];
  bool disconnected_[3];
  PollSet poll_set_;
  boost::thread poll_thread_;
  volatile bool continue_;
};
TEST_F(Polled, readAndWrite)
{
  transports_[1]-&gt;enableWrite();
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  transports_[1]-&gt;disableWrite();
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_GT(bytes_read_[2], 0);
  ASSERT_EQ(bytes_read_[2], bytes_written_[1]);
  int old_read_val = bytes_read_[2];
  transports_[2]-&gt;enableWrite();
<a name="0"></a>  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  transports_[2]-&gt;disableWrite();
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_EQ(bytes_read_[1], bytes_written_[2]);
  ASSERT_EQ(old_read_val, bytes_read_[2]);
  transports_[1]-&gt;enableWrite();
  transports_[2]-&gt;enableWrite();
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  transports_[1]-&gt;disableWrite();
  transports_[2]-&gt;disableWrite();
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_GT(bytes_read_[2], 0);
  ASSERT_EQ(bytes_read_[2], bytes_written_[1]);
  ASSERT_GT(bytes_read_[1], 0);
  ASSERT_EQ(bytes_read_[1], bytes_written_[2]);
}
TEST_F(Polled, enableDisableWrite)
{</b></font>
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_EQ(bytes_read_[1], 0);
  ASSERT_EQ(bytes_read_[2], 0);
  ASSERT_EQ(bytes_written_[1], 0);
  ASSERT_EQ(bytes_written_[2], 0);
  transports_[1]-&gt;enableWrite();
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  transports_[1]-&gt;disableWrite();
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_GT(bytes_read_[2], 0);
  ASSERT_GT(bytes_written_[1], 0);
  int old_read_val = bytes_read_[2];
  int old_written_val = bytes_written_[1];
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_EQ(bytes_read_[2], old_read_val);
  ASSERT_EQ(bytes_written_[1], old_written_val);
}
TEST_F(Polled, disconnectNoTraffic)
{
  ASSERT_EQ(disconnected_[1], false);
  ASSERT_EQ(disconnected_[2], false);
  transports_[1]-&gt;close();
  ASSERT_EQ(disconnected_[1], true);
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_EQ(disconnected_[2], true);
}
TEST_F(Polled, disconnectWriter)
{
  ASSERT_EQ(disconnected_[1], false);
  ASSERT_EQ(disconnected_[2], false);
  transports_[1]-&gt;enableWrite();
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_GT(bytes_read_[2], 0);
  transports_[1]-&gt;close();
  ASSERT_EQ(disconnected_[1], true);
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_EQ(disconnected_[2], true);
}
TEST_F(Polled, disconnectReader)
{
  ASSERT_EQ(disconnected_[1], false);
  ASSERT_EQ(disconnected_[2], false);
  transports_[2]-&gt;enableWrite();
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_GT(bytes_read_[1], 0);
  transports_[1]-&gt;close();
  ASSERT_EQ(disconnected_[1], true);
  boost::this_thread::sleep(boost::posix_time::milliseconds(50));
  ASSERT_EQ(disconnected_[2], true);
}
int main(int argc, char** argv)
{
  testing::InitGoogleTest(&amp;argc, argv);
#ifndef _WIN32
  signal(SIGPIPE, SIG_IGN);
#endif
  return RUN_ALL_TESTS();
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestValues.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;climits&gt;
#include "xmlrpcpp/XmlRpcValue.h"
#include "xmlrpcpp/XmlRpcException.h"
#include "xmlrpcpp/XmlRpcUtil.h"
#include &lt;gtest/gtest.h&gt;
using namespace XmlRpc;
TEST(XmlRpc, Bool) {
  XmlRpcValue v(bool(false));
  EXPECT_EQ("&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;", v.toXml());
  XmlRpcValue v2;
  v2[0] = int(1);
  v2[1] = std::string();
  v2[2] = XmlRpcValue(false);
  EXPECT_EQ("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt;&lt;value&gt;&lt;/"
            "value&gt;&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;",
            v2.toXml());
}
TEST(XmlRpc, testBoolean) {
  const XmlRpcValue booleanFalse(false);
  XmlRpcValue booleanTrue(true);
  int offset = 0;
  XmlRpcValue booleanFalseXml("&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
  offset = 0;
  XmlRpcValue booleanTrueXml("&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_NE(booleanFalse, booleanTrue);
  EXPECT_EQ(booleanFalse, booleanFalseXml);
  EXPECT_NE(booleanFalse, booleanTrueXml);
  EXPECT_FALSE(bool(booleanFalse));
  EXPECT_TRUE(bool(booleanTrue));
  std::stringstream ss;
  ss &lt;&lt; booleanFalse;
  EXPECT_EQ("0", ss.str());
  std::stringstream ss2;
  ss2 &lt;&lt; booleanTrue;
  EXPECT_EQ("1", ss2.str());
}
TEST(XmlRpc, testInt) {
  const XmlRpcValue int0(0);
  ASSERT_EQ(XmlRpcValue::TypeInt, int0.getType());
  XmlRpcValue int1(1);
  ASSERT_EQ(XmlRpcValue::TypeInt, int1.getType());
  XmlRpcValue int10(10);
  ASSERT_EQ(XmlRpcValue::TypeInt, int10.getType());
  XmlRpcValue int_1(-1);
  ASSERT_EQ(XmlRpcValue::TypeInt, int_1.getType());
  int offset = 0;
  XmlRpcValue int0Xml("&lt;value&gt;&lt;int&gt;0&lt;/int&gt;&lt;/value&gt;", &amp;offset);
  ASSERT_EQ(XmlRpcValue::TypeInt, int0Xml.getType());
  EXPECT_EQ(0, int(int0Xml));
  offset = 0;
  XmlRpcValue int9Xml("&lt;value&gt;&lt;i4&gt;9&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
  ASSERT_EQ(XmlRpcValue::TypeInt, int9Xml.getType());
  EXPECT_EQ(9, int(int9Xml));
  EXPECT_EQ(int0, int0Xml);
  EXPECT_EQ(int(int10) - int(int1), int(int9Xml));
  EXPECT_EQ(9, int(int9Xml));
  EXPECT_EQ(int(int10) + int(int_1), int(int9Xml));
  std::stringstream ss;
  ss &lt;&lt; int9Xml;
  EXPECT_EQ("9", ss.str());
}
TEST(XmlRpc, testDouble) {
  const XmlRpcValue d(43.7);
  ASSERT_EQ(XmlRpcValue::TypeDouble, d.getType());
  EXPECT_EQ("&lt;value&gt;&lt;double&gt;43.700000000000003&lt;/double&gt;&lt;/value&gt;", d.toXml());
  EXPECT_DOUBLE_EQ(43.7, double(d));
  int offset = 0;
  XmlRpcValue dXml("&lt;value&gt;&lt;double&gt;56.3&lt;/double&gt;&lt;/value&gt;", &amp;offset);
  ASSERT_EQ(XmlRpcValue::TypeDouble, dXml.getType());
  EXPECT_DOUBLE_EQ(56.3, double(dXml));
  EXPECT_DOUBLE_EQ(100.0, double(d) + double(dXml));
  std::stringstream ss;
  ss &lt;&lt; d;
  EXPECT_EQ("43.7", ss.str());
  ss.str("");
<a name="0"></a>    const XmlRpc::XmlRpcValue a(2.0);
  ASSERT_EQ(XmlRpcValue::TypeDouble, d.getType());
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  const std::string save_format = XmlRpc::XmlRpcValue::getDoubleFormat();
  XmlRpc::XmlRpcValue::setDoubleFormat("%32.10f");
  ss &lt;&lt; a;
  EXPECT_EQ("                    2.0000000000", ss.str());
  ss.str("");
  XmlRpc::XmlRpcValue::setDoubleFormat("%10.32f");
  ss &lt;&lt; a;
  EXPECT_EQ("2.00000000000000000000000000000000", ss.str());
  ss.str("");
  XmlRpc::XmlRpcValue::setDoubleFormat("%128.10f");
  ss &lt;&lt; a;
  EXPECT_EQ("                                "
            "                                "
            "                                "
            "                    2.000000000", ss.str());
  ss.str("");
  XmlRpc::XmlRpcValue::setDoubleFormat("%10.128f");
  ss &lt;&lt; a;
  EXPECT_EQ("2.000000000000000000000000000000"
            "00000000000000000000000000000000"
            "00000000000000000000000000000000"
            "000000000000000000000000000000000", ss.str());
  ss.str("");
  XmlRpc::XmlRpcValue::setDoubleFormat(save_format.c_str());
}
TEST(XmlRpc, testString) {</b></font>
  const XmlRpcValue s("Now is the time &lt;&amp;");
  ASSERT_EQ(XmlRpcValue::TypeString, s.getType());
  EXPECT_EQ(18, s.size());
  EXPECT_EQ("&lt;value&gt;Now is the time &amp;lt;&amp;amp;&lt;/value&gt;", s.toXml());
  char csxml[] = "&lt;value&gt;&lt;string&gt;Now is the time &amp;lt;&amp;amp;&lt;/string&gt;&lt;/value&gt;";
  std::string ssxml = csxml;
  int offset = 0;
  XmlRpcValue vscXml(csxml, &amp;offset);
  EXPECT_EQ(s, vscXml);
  offset = 0;
  XmlRpcValue vssXml(ssxml, &amp;offset);
  EXPECT_EQ(s, vssXml);
  offset = 0;
  XmlRpcValue fromXml(vssXml.toXml(), &amp;offset);
  EXPECT_EQ(s, fromXml);
  std::string emptyStringXml("&lt;value&gt;&lt;/value&gt;");
  offset = 0;
  XmlRpcValue emptyStringVal1(emptyStringXml, &amp;offset);
  XmlRpcValue emptyStringVal2("");
  EXPECT_EQ(emptyStringVal1, emptyStringVal2);
  emptyStringXml = "&lt;value&gt;  &lt;/value&gt;";
  offset = 0;
  XmlRpcValue blankStringVal(emptyStringXml, &amp;offset);
  EXPECT_EQ(std::string(blankStringVal), "  ");
  XmlRpcValue s2;
  std::string tmp = s2;
  EXPECT_EQ("", tmp);
  EXPECT_EQ("", (std::string)s2);
  std::stringstream ss;
  ss &lt;&lt; s;
  EXPECT_EQ("Now is the time &lt;&amp;", ss.str());
}
TEST(XmlRpc, testOversizeString) {
  try {
    std::string xml = "&lt;tag&gt;&lt;nexttag&gt;";
    xml += std::string(INT_MAX, 'a');
    xml += "a&lt;/nexttag&gt;&lt;/tag&gt;";
    int offset;
    offset = 0;
    EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", xml, &amp;offset), std::string());
    EXPECT_EQ(offset, 0);
    offset = 0;
    EXPECT_FALSE(XmlRpcUtil::findTag("&lt;tag&gt;", xml, &amp;offset));
    EXPECT_EQ(offset, 0);
    offset = 0;
    EXPECT_FALSE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", xml, &amp;offset));
    EXPECT_EQ(offset, 0);
    offset = 0;
    EXPECT_EQ(XmlRpcUtil::getNextTag(xml, &amp;offset), std::string());
    EXPECT_EQ(offset, 0);
  }
  catch (std::bad_alloc&amp; err) {
#ifdef GTEST_SKIP
    GTEST_SKIP() &lt;&lt; "Unable to allocate memory to run test\n";
#else
    std::cerr &lt;&lt; "[ SKIPPED  ] XmlRpc.testOversizeString Unable to allocate memory to run test\n";
#endif
  }
}
TEST(XmlRpc, testParseTag) {
  int offset = 0;
  EXPECT_EQ(XmlRpcUtil::parseTag(NULL, "", &amp;offset), std::string());
  EXPECT_EQ(offset, 0);
  EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "", NULL), std::string());
  EXPECT_EQ(offset, 0);
  offset = 20;
  EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "", &amp;offset), std::string());
  EXPECT_EQ(offset, 20);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "&lt;foo&gt;&lt;/foo&gt;", &amp;offset), std::string());
  EXPECT_EQ(offset, 0);
  EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "&lt;tag&gt;", &amp;offset), std::string());
  EXPECT_EQ(offset, 0);
  EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "&lt;tag&gt;foo&lt;/tag&gt;", &amp;offset), "foo");
  EXPECT_EQ(offset, 14);
}
TEST(XmlRpc, testFindTag) {
  int offset = 0;
  EXPECT_FALSE(XmlRpcUtil::findTag(NULL, "", &amp;offset));
  EXPECT_EQ(offset, 0);
  EXPECT_FALSE(XmlRpcUtil::findTag("&lt;tag&gt;", "", NULL));
  EXPECT_EQ(offset, 0);
  offset = 20;
  EXPECT_FALSE(XmlRpcUtil::findTag("&lt;tag&gt;", "", &amp;offset));
  EXPECT_EQ(offset, 20);
  offset = 0;
  EXPECT_TRUE(XmlRpcUtil::findTag("&lt;subtag&gt;", "&lt;tag&gt;&lt;subtag&gt;&lt;/subtag&gt;&lt;/tag&gt;", &amp;offset));
  EXPECT_EQ(offset, 13);
}
TEST(XmlRpc, testNextTagIs) {
  int offset = 0;
  EXPECT_FALSE(XmlRpcUtil::nextTagIs(NULL, "", &amp;offset));
  EXPECT_EQ(offset, 0);
  EXPECT_FALSE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "", NULL));
  EXPECT_EQ(offset, 0);
  offset = 20;
  EXPECT_FALSE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "", &amp;offset));
  EXPECT_EQ(offset, 20);
  offset = 0;
  EXPECT_TRUE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "&lt;tag&gt;&lt;/tag&gt;", &amp;offset));
  EXPECT_EQ(offset, 5);
  offset = 0;
  EXPECT_TRUE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "      &lt;tag&gt;&lt;/tag&gt;", &amp;offset));
  EXPECT_EQ(offset, 11);
  offset = 0;
  EXPECT_FALSE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "      &lt;footag&gt;&lt;/footag&gt;", &amp;offset));
  EXPECT_EQ(offset, 0);
}
TEST(XmlRpc, testGetNextTag) {
  int offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag("", NULL), std::string());
  EXPECT_EQ(offset, 0);
  offset = 20;
  EXPECT_EQ(XmlRpcUtil::getNextTag("&lt;tag&gt;", &amp;offset), std::string());
  EXPECT_EQ(offset, 20);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag("&lt;tag&gt;&lt;/tag&gt;", &amp;offset), "&lt;tag&gt;");
  EXPECT_EQ(offset, 5);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag("      &lt;tag&gt;&lt;/tag&gt;", &amp;offset), "&lt;tag&gt;");
  EXPECT_EQ(offset, 11);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag("      foo", &amp;offset), std::string());
  EXPECT_EQ(offset, 0);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag("&lt;foo", &amp;offset), "&lt;foo");
  EXPECT_EQ(offset, 4);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag("&lt;&gt;", &amp;offset), "&lt;&gt;");
  EXPECT_EQ(offset, 2);
}
TEST(XmlRpc, testNextTagData)
{
  int offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData(NULL, "", &amp;offset), std::string());
  EXPECT_EQ(offset, 0);
  EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "", NULL), std::string());
  EXPECT_EQ(offset, 0);
  offset = 20;
  EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "", &amp;offset), std::string());
  EXPECT_EQ(offset, 20);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "&lt;tag&gt;&lt;/tag&gt;", &amp;offset), "");
  EXPECT_EQ(offset, 11);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;tag&gt;&lt;/tag&gt;", &amp;offset), "");
  EXPECT_EQ(offset, 14);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;tag&gt;foo&lt;/tag&gt;", &amp;offset), "foo");
  EXPECT_EQ(offset, 17);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;foo&gt;&lt;/foo&gt;", &amp;offset), "");
  EXPECT_EQ(offset, 0);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;tag&gt;&lt;foo&gt;&lt;/tag&gt;", &amp;offset), "");
  EXPECT_EQ(offset, 0);
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;tag&gt;foo", &amp;offset), "");
  EXPECT_EQ(offset, 0);
}
TEST(XmlRpc, testDateTime) {
  int offset = 0;
  const XmlRpcValue dateTime(
      "&lt;value&gt;&lt;dateTime.iso8601&gt;19040503T03:12:35&lt;/dateTime.iso8601&gt;&lt;/value&gt;",
      &amp;offset);
  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime.getType());
  struct tm t = dateTime;
  EXPECT_EQ(t.tm_year, 1904);
  EXPECT_EQ(t.tm_min, 12);
  EXPECT_EQ(t.tm_sec, 35);
  EXPECT_EQ(t.tm_hour, 3);
  EXPECT_EQ(t.tm_mday, 3);
  EXPECT_EQ(t.tm_mon, 5);
  EXPECT_EQ(
      "&lt;value&gt;&lt;dateTime.iso8601&gt;19040503T03:12:35&lt;/dateTime.iso8601&gt;&lt;/value&gt;",
      dateTime.toXml());
  XmlRpcValue dateTime2(&amp;t);
  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime2.getType());
  t = dateTime2;
  EXPECT_EQ(t.tm_year, 1904);
  EXPECT_EQ(t.tm_min, 12);
  XmlRpcValue dateTime3;
  t = dateTime3;
  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime3.getType());
  EXPECT_EQ(t.tm_year, 0);
  EXPECT_EQ(t.tm_min, 0);
  std::stringstream ss;
  ss &lt;&lt; dateTime;
  EXPECT_EQ("19040503T03:12:35", ss.str());
  EXPECT_EQ(dateTime, dateTime2);
  dateTime3 = dateTime;
  EXPECT_EQ(dateTime, dateTime3);
  t = dateTime;
  struct tm&amp; tm2 = dateTime2;
  tm2.tm_sec = 0;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);
  tm2.tm_min = 0;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);
  tm2.tm_hour = 0;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);
  tm2.tm_mday = 1;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);
  tm2.tm_mon = 1;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);
  tm2.tm_year = 1988;
  EXPECT_NE(dateTime, dateTime2);
}
TEST(XmlRpc, testArray) {
  XmlRpcValue d(43.7);
  XmlRpcValue a;
  a.setSize(4);
  a[0] = 1;
  a[1] = std::string("two");
  a[2] = 43.7;
  a[3] = "four";
  EXPECT_EQ(XmlRpcValue::TypeArray, a.getType());
  EXPECT_EQ(int(a[0]), 1);
  EXPECT_EQ(a[2], d);
  char csaXml[] = "&lt;value&gt;&lt;array&gt;\n"
                  "  &lt;data&gt;\n"
                  "    &lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt; \n"
                  "    &lt;value&gt; &lt;string&gt;two&lt;/string&gt;&lt;/value&gt;\n"
                  "    &lt;value&gt;&lt;double&gt;43.7&lt;/double&gt;&lt;/value&gt;\n"
                  "    &lt;value&gt;four&lt;/value&gt;\n"
                  "  &lt;/data&gt;\n"
                  "&lt;/array&gt;&lt;/value&gt;";
  int offset = 0;
  XmlRpcValue aXml(csaXml, &amp;offset);
  EXPECT_EQ(a, aXml);
  const XmlRpcValue copy(a);
  ASSERT_EQ(a.getType(), copy.getType());
  ASSERT_EQ(a.size(), copy.size());
  for (int i = 0; i &lt; 3; i++) {
    EXPECT_EQ(a[i], copy[i]);
  }
  EXPECT_EQ(a, copy);
  EXPECT_NE(a, d);
  std::stringstream ss;
  ss &lt;&lt; a;
  EXPECT_EQ("{1,two,43.7,four}", ss.str());
}
TEST(XmlRpc, testStruct) {
  XmlRpcValue struct1;
  struct1["i4"] = 1;
  struct1["str"] = "two";
  struct1["d"] = 43.7;
  EXPECT_EQ(3, struct1.size());
  EXPECT_EQ(XmlRpcValue::TypeStruct, struct1.getType());
  EXPECT_TRUE(struct1.hasMember("i4"));
  EXPECT_FALSE(struct1.hasMember("nowhere"));
  std::stringstream ss;
  ss &lt;&lt; struct1;
  EXPECT_EQ("[d:43.7,i4:1,str:two]", ss.str());
  XmlRpcValue a;
  a.setSize(4);
  a[0] = 1;
  a[1] = std::string("two");
  a[2] = 43.7;
  a[3] = "four";
  EXPECT_EQ(struct1["d"], a[2]);
  char csStructXml[] = "&lt;value&gt;&lt;struct&gt;\n"
                       "  &lt;member&gt;\n"
                       "    &lt;name&gt;i4&lt;/name&gt; \n"
                       "    &lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt; \n"
                       "  &lt;/member&gt;\n"
                       "  &lt;member&gt;\n"
                       "    &lt;name&gt;d&lt;/name&gt; \n"
                       "    &lt;value&gt;&lt;double&gt;43.7&lt;/double&gt;&lt;/value&gt;\n"
                       "  &lt;/member&gt;\n"
                       "  &lt;member&gt;\n"
                       "    &lt;name&gt;str&lt;/name&gt; \n"
                       "    &lt;value&gt; &lt;string&gt;two&lt;/string&gt;&lt;/value&gt;\n"
                       "  &lt;/member&gt;\n"
                       "&lt;/struct&gt;&lt;/value&gt;";
  int offset = 0;
  const XmlRpcValue structXml(csStructXml, &amp;offset);
  EXPECT_EQ(struct1, structXml);
  for (XmlRpcValue::iterator itr = struct1.begin(); itr != struct1.end();
       itr++) {
  }
  XmlRpcValue astruct;
  astruct["array"] = a;
  EXPECT_EQ(astruct["array"][2], struct1["d"]);
  for (int i = 0; i &lt; 10; i++) {
    XmlRpcValue Event;
    Event["Name"] = "string";
    Event.clear();
    const int NELMTS = 100;
    int ii;
    for (ii = 0; ii &lt; NELMTS; ++ii) {
      char buf[40];
      sprintf(buf, "%d", ii);
      Event[std::string(buf)] = buf;
    }
    Event.clear();
    for (ii = 0; ii &lt; NELMTS; ++ii) {
      char buf[40];
      sprintf(buf, "%d", ii);
      if (ii != NELMTS / 2)
        Event[std::string(buf)] = ii;
      else
        for (int jj = 0; jj &lt; NELMTS; ++jj) {
          char bufj[40];
          sprintf(bufj, "%d", jj);
          Event[std::string(buf)][std::string(bufj)] = bufj;
        }
    }
    for (ii = 0; ii &lt; NELMTS; ++ii) {
      char buf[40];
      sprintf(buf, "%d", ii);
      if (ii != NELMTS / 2)
        EXPECT_EQ(Event[std::string(buf)], XmlRpcValue(ii));
      else
        EXPECT_EQ(Event[std::string(buf)].size(), NELMTS);
    }
  }
}
TEST(XmlRpc, base64) {
  char data[] = {1, 2};
  const XmlRpcValue bin(data, 2);
  EXPECT_EQ(XmlRpcValue::TypeBase64, bin.getType());
  EXPECT_EQ(2, bin.size());
  XmlRpcValue::BinaryData d = bin;
  EXPECT_EQ(d[0], 1);
  EXPECT_EQ(d[1], 2);
  EXPECT_EQ("&lt;value&gt;&lt;base64&gt;AQI=\n&lt;/base64&gt;&lt;/value&gt;", bin.toXml());
  std::stringstream ss;
  ss &lt;&lt; bin;
  EXPECT_EQ("AQI=\n", ss.str());
  int offset = 0;
  XmlRpcValue bin2("&lt;value&gt;&lt;base64&gt;AQI=&lt;/base64&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(XmlRpcValue::TypeBase64, bin2.getType());
  EXPECT_EQ(2, bin2.size());
  d = bin2;
  EXPECT_EQ(d[0], 1);
  EXPECT_EQ(d[1], 2);
  EXPECT_EQ(bin, bin2);
  XmlRpcValue bin3;
  d = bin3;
  EXPECT_EQ(XmlRpcValue::TypeBase64, bin3.getType());
  EXPECT_EQ(0, bin3.size());
  EXPECT_EQ(0u, d.size());
  XmlRpcValue bin4;
  bin4 = bin;
  EXPECT_EQ(XmlRpcValue::TypeBase64, bin4.getType());
  EXPECT_EQ(2, bin4.size());
  d = bin4;
  EXPECT_EQ(d[0], 1);
  EXPECT_EQ(d[1], 2);
}
TEST(XmpRpc, errors) {
  XmlRpcValue value;
  EXPECT_FALSE(value.valid());
  EXPECT_EQ("", value.toXml());
  bool v = (bool)value;
  EXPECT_FALSE(v);
  EXPECT_THROW((void)(int)value, XmlRpcException);
  EXPECT_THROW(value[0], XmlRpcException);
  EXPECT_THROW(value["bar"], XmlRpcException);
  const XmlRpcValue&amp; ref = value;
  EXPECT_THROW(ref[0], XmlRpcException);
  EXPECT_FALSE(ref.hasMember("bar"));
  try {
    (void)int(value);
  } catch (XmlRpcException&amp; e) {
    EXPECT_EQ("type error", e.getMessage());
    EXPECT_EQ(-1, e.getCode());
  }
  EXPECT_THROW(value.size(), XmlRpcException);
  value.clear();
  EXPECT_FALSE(value.valid());
}
TEST(XmlRpc, int_errors) {
  XmlRpcValue value;
  int v = (int)value;
  EXPECT_EQ(0, v);
  EXPECT_EQ(0, (int)value);
  EXPECT_THROW((void)(bool)value, XmlRpcException);
}
TEST(XmlRpc, array_errors) {
  XmlRpcValue value;
  int v = value[0];
  EXPECT_EQ(0, v);
  EXPECT_THROW((void)(bool)value, XmlRpcException);
  EXPECT_EQ(1, value.size());
  EXPECT_EQ(0, (int)value[1]);
  EXPECT_EQ(2, value.size());
  const XmlRpcValue&amp; ref = value;
  EXPECT_THROW(ref[2], XmlRpcException);
}
TEST(XmlRpc, fromXmlInvalid) {
  int offset = 0;
  XmlRpcValue val;
  val.fromXml("", NULL);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  offset = 20;
  val.fromXml("", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 20);
  offset = 0;
  val.fromXml("&lt;foo&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;invalid&gt;&lt;/invalid&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
  EXPECT_EQ(offset, 15);
  EXPECT_EQ(static_cast&lt;std::string&gt;(val), "");
}
TEST(XmlRpc, fromXmlBoolean) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;boolean&gt;&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;boolean&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;boolean&gt;foo&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;boolean&gt;25&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;boolean&gt;1foo&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
  EXPECT_EQ(offset, 38);
  EXPECT_EQ(static_cast&lt;bool&gt;(val), true);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;boolean&gt;1&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
  EXPECT_EQ(offset, 25);
  EXPECT_EQ(static_cast&lt;bool&gt;(val), true);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
  EXPECT_EQ(offset, 35);
  EXPECT_EQ(static_cast&lt;bool&gt;(val), false);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
  EXPECT_EQ(offset, 35);
  EXPECT_EQ(static_cast&lt;bool&gt;(val), true);
}
TEST(XmlRpc, fromXmlI4) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;i4&gt;&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;i4&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;i4&gt;foo&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;i4&gt;25&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 26);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 25);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;i4&gt;1foo&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 28);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 1);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;i4&gt;99&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 21);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 99);
}
TEST(XmlRpc, fromXmlInt) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;int&gt;&lt;/int&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;int&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;int&gt;foo&lt;/int&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;int&gt;25&lt;/int&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 28);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 25);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;int&gt;1foo&lt;/int&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 30);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 1);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;int&gt;99&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 22);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 99);
}
TEST(XmlRpc, fromXmlDouble) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;double&gt;&lt;/double&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;double&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;double&gt;foo&lt;/double&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;double&gt;25&lt;/double&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
  EXPECT_EQ(offset, 34);
  EXPECT_EQ(static_cast&lt;double&gt;(val), 25.0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;double&gt;25.876&lt;/double&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
  EXPECT_EQ(offset, 38);
  EXPECT_NEAR(static_cast&lt;double&gt;(val), 25.876, 0.01);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;double&gt;1foo&lt;/double&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
  EXPECT_EQ(offset, 36);
  EXPECT_EQ(static_cast&lt;double&gt;(val), 1);
}
TEST(XmlRpc, fromXmlImplicitString) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;foo&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
  EXPECT_EQ(offset, 18);
  EXPECT_EQ(static_cast&lt;std::string&gt;(val), "foo");
  EXPECT_EQ(val.size(), 3);
}
TEST(XmlRpc, fromXmlExplicitString) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;string&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;string&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
  EXPECT_EQ(offset, 23);
  EXPECT_EQ(static_cast&lt;std::string&gt;(val), "");
  EXPECT_EQ(val.size(), 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;string&gt;foo&lt;/string&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
  EXPECT_EQ(offset, 35);
  EXPECT_EQ(static_cast&lt;std::string&gt;(val), "foo");
  EXPECT_EQ(val.size(), 3);
}
TEST(XmlRpc, fromXmlDateTime) {
  int offset = 0;
  XmlRpcValue val;
  struct tm expected{};
  struct tm returned;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;&lt;/dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;000000T00:00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:00&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
  EXPECT_EQ(offset, 49);
  returned = static_cast&lt;struct tm&gt;(val);
  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
  EXPECT_EQ(returned.tm_min, expected.tm_min);
  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
  EXPECT_EQ(returned.tm_year, expected.tm_year);
  EXPECT_EQ(returned.tm_isdst, -1);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:0&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
  EXPECT_EQ(offset, 66);
  returned = static_cast&lt;struct tm&gt;(val);
  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
  EXPECT_EQ(returned.tm_min, expected.tm_min);
  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
  EXPECT_EQ(returned.tm_year, expected.tm_year);
  EXPECT_EQ(returned.tm_isdst, -1);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
  EXPECT_EQ(offset, 67);
  returned = static_cast&lt;struct tm&gt;(val);
  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
  EXPECT_EQ(returned.tm_min, expected.tm_min);
  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
  EXPECT_EQ(returned.tm_year, expected.tm_year);
  EXPECT_EQ(returned.tm_isdst, -1);
}
TEST(XmlRpc, fromXmlBase64) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;base64&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;base64&gt;&lt;/base64&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
  EXPECT_EQ(offset, 32);
  EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), XmlRpc::XmlRpcValue::BinaryData());
  EXPECT_EQ(val.size(), 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;base64&gt;____&lt;/base64&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
  EXPECT_EQ(offset, 36);
  EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), XmlRpc::XmlRpcValue::BinaryData());
  EXPECT_EQ(val.size(), 0);
  XmlRpc::XmlRpcValue::BinaryData expected{'h', 'e', 'l', 'l', 'o'};
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;base64&gt;aGVsbG8=&lt;/base64&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
  EXPECT_EQ(offset, 40);
  EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), expected);
  EXPECT_EQ(val.size(), 5);
}
TEST(XmlRpc, fromXmlArray) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;array&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;array&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
  EXPECT_EQ(offset, 43);
  EXPECT_EQ(val.size(), 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
  EXPECT_EQ(offset, 78);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
  EXPECT_EQ(offset, 71);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;value&gt;&lt;double&gt;23.4&lt;/double&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
  EXPECT_EQ(offset, 114);
  EXPECT_EQ(val.size(), 2);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);
  EXPECT_NEAR(static_cast&lt;double&gt;(val[1]), 23.4, 0.01);
}
TEST(XmlRpc, fromXmlStruct) {
  int offset = 0;
  XmlRpcValue val;
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;struct&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 15);
  EXPECT_EQ(val.size(), 0);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 48);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[""]), true);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 84);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[""]), true);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;&lt;/name&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 97);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[""]), true);
  offset = 0;
  val.fromXml("&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;foo&lt;/name&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;", &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 100);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val["foo"]), true);
}
int main(int argc, char **argv)
{
  ::testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
