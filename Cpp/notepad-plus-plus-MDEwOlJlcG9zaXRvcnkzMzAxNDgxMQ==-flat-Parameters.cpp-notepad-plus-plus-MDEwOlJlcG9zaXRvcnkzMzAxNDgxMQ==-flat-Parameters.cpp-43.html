
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</h3>
            <pre><code>1  #include &lt;time.h&gt;
2  #include &lt;shlwapi.h&gt;
3  #include &lt;shlobj.h&gt;
4  #include &quot;Parameters.h&quot;
5  #include &quot;ScintillaEditView.h&quot;
6  #include &quot;keys.h&quot;
7  #include &quot;localization.h&quot;
8  #include &quot;localizationString.h&quot;
9  #include &quot;UserDefineDialog.h&quot;
10  #include &quot;WindowsDlgRc.h&quot;
11  #ifdef _MSC_VER
12  #pragma warning(disable : 4996) 
13  #endif
14  using namespace std;
15  namespace 
16  {
17  struct WinMenuKeyDefinition 
18  {
19  	int vKey;
20  	int functionId;
21  	bool isCtrl;
22  	bool isAlt;
23  	bool isShift;
24  	const TCHAR * specialName;		
25  };
26  struct ScintillaKeyDefinition
27  {
28  	const TCHAR * name;
29  	int functionId;
30  	bool isCtrl;
31  	bool isAlt;
32  	bool isShift;
33  	int vKey;
34  	int redirFunctionId;	
35  };
36  static const WinMenuKeyDefinition winKeyDefs[] =
37  {
38  	{ VK_N,       IDM_FILE_NEW,                                 true,  false, false, nullptr },
39  	{ VK_O,       IDM_FILE_OPEN,                                true,  false, false, nullptr },
40  	{ VK_NULL,    IDM_FILE_OPEN_FOLDER,                         false, false, false, TEXT(&quot;Open containing folder in Explorer&quot;) },
41  	{ VK_NULL,    IDM_FILE_OPEN_CMD,                            false, false, false, TEXT(&quot;Open containing folder in Command Prompt&quot;) },
42  	{ VK_NULL,    IDM_FILE_OPEN_DEFAULT_VIEWER,                 false, false, false, nullptr },
43  	{ VK_NULL,    IDM_FILE_OPENFOLDERASWORSPACE,                false, false, false, nullptr },
44  	{ VK_R,       IDM_FILE_RELOAD,                              true,  false, false, nullptr },
45  	{ VK_S,       IDM_FILE_SAVE,                                true,  false, false, nullptr },
46  	{ VK_S,       IDM_FILE_SAVEAS,                              true,  true,  false, nullptr },
47  	{ VK_NULL,    IDM_FILE_SAVECOPYAS,                          false, false, false, nullptr },
48  	{ VK_S,       IDM_FILE_SAVEALL,                             true,  false, true,  nullptr },
49  	{ VK_NULL,    IDM_FILE_RENAME,                              false, false, false, nullptr },
50  	{ VK_W,       IDM_FILE_CLOSE,                               true,  false, false, nullptr },
51  	{ VK_W,       IDM_FILE_CLOSEALL,                            true,  false, true,  nullptr },
52  	{ VK_NULL,    IDM_FILE_CLOSEALL_BUT_CURRENT,                false, false, false, nullptr },
53  	{ VK_NULL,    IDM_FILE_CLOSEALL_TOLEFT,                     false, false, false, nullptr },
54  	{ VK_NULL,    IDM_FILE_CLOSEALL_TORIGHT,                    false, false, false, nullptr },
55  	{ VK_NULL,    IDM_FILE_CLOSEALL_UNCHANGED,                  false, false, false, nullptr },
56  	{ VK_NULL,    IDM_FILE_DELETE,                              false, false, false, nullptr },
57  	{ VK_NULL,    IDM_FILE_LOADSESSION,                         false, false, false, nullptr },
58  	{ VK_NULL,    IDM_FILE_SAVESESSION,                         false, false, false, nullptr },
59  	{ VK_P,       IDM_FILE_PRINT,                               true,  false, false, nullptr },
60  	{ VK_NULL,    IDM_FILE_PRINTNOW,                            false, false, false, nullptr },
61  	{ VK_F4,      IDM_FILE_EXIT,                                false, true,  false, nullptr },
62  	{ VK_T,       IDM_FILE_RESTORELASTCLOSEDFILE,               true,  false, true,  TEXT(&quot;Restore Recent Closed File&quot;)},
63  	{ VK_B,       IDM_EDIT_BEGINENDSELECT,                      true,  false, true,  nullptr },
64  	{ VK_B,       IDM_EDIT_BEGINENDSELECT_COLUMNMODE,           false, true,  true,  nullptr },
65  	{ VK_NULL,    IDM_EDIT_FULLPATHTOCLIP,                      false, false, false, nullptr },
66  	{ VK_NULL,    IDM_EDIT_FILENAMETOCLIP,                      false, false, false, nullptr },
67  	{ VK_NULL,    IDM_EDIT_CURRENTDIRTOCLIP,                    false, false, false, nullptr },
68  	{ VK_NULL,    IDM_EDIT_COPY_ALL_NAMES,                      false, false, false, nullptr },
69  	{ VK_NULL,    IDM_EDIT_COPY_ALL_PATHS,                      false, false, false, nullptr },
70  	{ VK_NULL,    IDM_EDIT_INS_TAB,                             false, false, false, nullptr },
71  	{ VK_NULL,    IDM_EDIT_RMV_TAB,                             false, false, false, nullptr },
72  	{ VK_U,       IDM_EDIT_UPPERCASE,                           true,  false, true,  nullptr },
73  	{ VK_U,       IDM_EDIT_LOWERCASE,                           true,  false, false, nullptr },
74  	{ VK_U,       IDM_EDIT_PROPERCASE_FORCE,                    false, true,  false, nullptr },
75  	{ VK_U,       IDM_EDIT_PROPERCASE_BLEND,                    false, true,  true,  nullptr },
76  	{ VK_U,       IDM_EDIT_SENTENCECASE_FORCE,                  true,  true,  false, nullptr },
77  	{ VK_U,       IDM_EDIT_SENTENCECASE_BLEND,                  true,  true,  true,  nullptr },
78  	{ VK_NULL,    IDM_EDIT_INVERTCASE,                          false, false, false, nullptr },
79  	{ VK_NULL,    IDM_EDIT_RANDOMCASE,                          false, false, false, nullptr },
80  	{ VK_NULL,    IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES,        false, false, false, nullptr },
81  	{ VK_NULL,    IDM_EDIT_REMOVE_ANY_DUP_LINES,                false, false, false, nullptr },
82  	{ VK_I,       IDM_EDIT_SPLIT_LINES,                         true,  false, false, nullptr },
83  	{ VK_J,       IDM_EDIT_JOIN_LINES,                          true,  false, false, nullptr },
84  	{ VK_UP,      IDM_EDIT_LINE_UP,                             true,  false, true,  nullptr },
85  	{ VK_DOWN,    IDM_EDIT_LINE_DOWN,                           true,  false, true,  nullptr },
86  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINES,                    false, false, false, nullptr },
87  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINESWITHBLANK,           false, false, false, nullptr },
88  	{ VK_RETURN,  IDM_EDIT_BLANKLINEABOVECURRENT,               true,  true,  false, nullptr },
89  	{ VK_RETURN,  IDM_EDIT_BLANKLINEBELOWCURRENT,               true,  true,  true,  nullptr },
90  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING,   false, false, false, nullptr },
91  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING,  false, false, false, nullptr },
92  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING,   false, false, false, nullptr },
93  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING,  false, false, false, nullptr },
94  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_ASCENDING,         false, false, false, nullptr },
95  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_DESCENDING,        false, false, false, nullptr },
96  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING,    false, false, false, nullptr },
97  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING,   false, false, false, nullptr },
98  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING,      false, false, false, nullptr },
99  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING,     false, false, false, nullptr },
100  	{ VK_NULL,    IDM_EDIT_SORTLINES_REVERSE_ORDER,             false, false, false, nullptr },
101  	{ VK_NULL,    IDM_EDIT_SORTLINES_RANDOMLY,                  false, false, false, nullptr },
102  	{ VK_Q,       IDM_EDIT_BLOCK_COMMENT,                       true,  false, false, nullptr },
103  	{ VK_K,       IDM_EDIT_BLOCK_COMMENT_SET,                   true,  false, false, nullptr },
104  	{ VK_K,       IDM_EDIT_BLOCK_UNCOMMENT,                     true,  false, true,  nullptr },
105  	{ VK_Q,       IDM_EDIT_STREAM_COMMENT,                      true,  false, true,  nullptr },
106  	{ VK_NULL,    IDM_EDIT_STREAM_UNCOMMENT,                    false, false, false, nullptr },
107  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE,                        true,  false, false, nullptr },
108  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE_PATH,                   true,  true,  false, nullptr },
109  	{ VK_RETURN,  IDM_EDIT_AUTOCOMPLETE_CURRENTFILE,            true,  false, false, nullptr },
110  	{ VK_SPACE,   IDM_EDIT_FUNCCALLTIP,                         true,  false, true,  nullptr },
111  	{ VK_UP,      IDM_EDIT_FUNCCALLTIP_PREVIOUS,                false, true,  false, nullptr },
112  	{ VK_DOWN,    IDM_EDIT_FUNCCALLTIP_NEXT,                    false, true,  false, nullptr },
113  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_SHORT,               false, false, false, nullptr },
114  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_LONG,                false, false, false, nullptr },
115  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_CUSTOMIZED,          false, false, false, nullptr },
116  	{ VK_NULL,    IDM_FORMAT_TODOS,                             false, false, false, TEXT(&quot;EOL Conversion to Windows (CR LF)&quot;) },
117  	{ VK_NULL,    IDM_FORMAT_TOUNIX,                            false, false, false, TEXT(&quot;EOL Conversion to Unix (LF)&quot;) },
118  	{ VK_NULL,    IDM_FORMAT_TOMAC,                             false, false, false, TEXT(&quot;EOL Conversion to Macintosh (CR)&quot;) },
119  	{ VK_NULL,    IDM_EDIT_TRIMTRAILING,                        false, false, false, nullptr },
120  	{ VK_NULL,    IDM_EDIT_TRIMLINEHEAD,                        false, false, false, nullptr },
121  	{ VK_NULL,    IDM_EDIT_TRIM_BOTH,                           false, false, false, nullptr },
122  	{ VK_NULL,    IDM_EDIT_EOL2WS,                              false, false, false, nullptr },
123  	{ VK_NULL,    IDM_EDIT_TRIMALL,                             false, false, false, nullptr },
124  	{ VK_NULL,    IDM_EDIT_TAB2SW,                              false, false, false, nullptr },
125  	{ VK_NULL,    IDM_EDIT_SW2TAB_ALL,                          false, false, false, nullptr },
126  	{ VK_NULL,    IDM_EDIT_SW2TAB_LEADING,                      false, false, false, nullptr },
127  	{ VK_NULL,    IDM_EDIT_PASTE_AS_HTML,                       false, false, false, nullptr },
128  	{ VK_NULL,    IDM_EDIT_PASTE_AS_RTF,                        false, false, false, nullptr },
129  	{ VK_NULL,    IDM_EDIT_COPY_BINARY,                         false, false, false, nullptr },
130  	{ VK_NULL,    IDM_EDIT_CUT_BINARY,                          false, false, false, nullptr },
131  	{ VK_NULL,    IDM_EDIT_PASTE_BINARY,                        false, false, false, nullptr },
132  	{ VK_NULL,    IDM_EDIT_OPENASFILE,                          false, false, false, nullptr },
133  	{ VK_NULL,    IDM_EDIT_OPENINFOLDER,                        false, false, false, nullptr },
134  	{ VK_NULL,    IDM_EDIT_SEARCHONINTERNET,                    false, false, false, nullptr },
135  	{ VK_NULL,    IDM_EDIT_CHANGESEARCHENGINE,                  false, false, false, nullptr },
136  	{ VK_C,       IDM_EDIT_COLUMNMODE,                          false, true,  false, nullptr },
137  	{ VK_NULL,    IDM_EDIT_CHAR_PANEL,                          false, false, false, TEXT(&quot;Toggle Character Panel&quot;) },
138  	{ VK_NULL,    IDM_EDIT_CLIPBOARDHISTORY_PANEL,              false, false, false, TEXT(&quot;Toggle Clipboard History&quot;) },
139  	{ VK_NULL,    IDM_EDIT_SETREADONLY,                         false, false, false, nullptr },
140  	{ VK_NULL,    IDM_EDIT_CLEARREADONLY,                       false, false, false, nullptr },
141  	{ VK_F,       IDM_SEARCH_FIND,                              true,  false, false, nullptr },
142  	{ VK_F,       IDM_SEARCH_FINDINFILES,                       true,  false, true,  nullptr },
143  	{ VK_F3,      IDM_SEARCH_FINDNEXT,                          false, false, false, nullptr },
144  	{ VK_F3,      IDM_SEARCH_FINDPREV,                          false, false, true,  nullptr },
145  	{ VK_F3,      IDM_SEARCH_SETANDFINDNEXT,                    true,  false, false, nullptr },
146  	{ VK_F3,      IDM_SEARCH_SETANDFINDPREV,                    true,  false, true,  nullptr },
147  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDNEXT,                 true,  true,  false, nullptr },
148  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDPREV,                 true,  true,  true,  nullptr },
149  	{ VK_H,       IDM_SEARCH_REPLACE,                           true,  false, false, nullptr },
150  	{ VK_I,       IDM_SEARCH_FINDINCREMENT,                     true,  true,  false, nullptr },
151  	{ VK_F7,      IDM_FOCUS_ON_FOUND_RESULTS,                   false, false, false, nullptr },
152  	{ VK_F4,      IDM_SEARCH_GOTOPREVFOUND,                     false, false, true,  nullptr },
153  	{ VK_F4,      IDM_SEARCH_GOTONEXTFOUND,                     false, false, false, nullptr },
154  	{ VK_G,       IDM_SEARCH_GOTOLINE,                          true,  false, false, nullptr },
155  	{ VK_B,       IDM_SEARCH_GOTOMATCHINGBRACE,                 true,  false, false, nullptr },
156  	{ VK_B,       IDM_SEARCH_SELECTMATCHINGBRACES,              true,  true,  false, nullptr },
157  	{ VK_M,       IDM_SEARCH_MARK,                              true,  false, false, nullptr },
158  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT1,                       false, false, false, TEXT(&quot;Style all using 1st style&quot;) },
159  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT2,                       false, false, false, TEXT(&quot;Style all using 2nd style&quot;) },
160  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT3,                       false, false, false, TEXT(&quot;Style all using 3rd style&quot;) },
161  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT4,                       false, false, false, TEXT(&quot;Style all using 4th style&quot;) },
162  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT5,                       false, false, false, TEXT(&quot;Style all using 5th style&quot;) },
163  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT1,                       false, false, false, TEXT(&quot;Style one using 1st style&quot;) },
164  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT2,                       false, false, false, TEXT(&quot;Style one using 2nd style&quot;) },
165  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT3,                       false, false, false, TEXT(&quot;Style one using 3rd style&quot;) },
166  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT4,                       false, false, false, TEXT(&quot;Style one using 4th style&quot;) },
167  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT5,                       false, false, false, TEXT(&quot;Style one using 5th style&quot;) },
168  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT1,                     false, false, false, TEXT(&quot;Clear 1st style&quot;) },
169  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT2,                     false, false, false, TEXT(&quot;Clear 2nd style&quot;) },
170  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT3,                     false, false, false, TEXT(&quot;Clear 3rd style&quot;) },
171  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT4,                     false, false, false, TEXT(&quot;Clear 4th style&quot;) },
172  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT5,                     false, false, false, TEXT(&quot;Clear 5th style&quot;) },
173  	{ VK_NULL,    IDM_SEARCH_CLEARALLMARKS,                     false, false, false, TEXT(&quot;Clear all styles&quot;) },
174  	{ VK_1,       IDM_SEARCH_GOPREVMARKER1,                     true,  false, true,  TEXT(&quot;Previous style of 1st style&quot;) },
175  	{ VK_2,       IDM_SEARCH_GOPREVMARKER2,                     true,  false, true,  TEXT(&quot;Previous style of 2nd style&quot;) },
176  	{ VK_3,       IDM_SEARCH_GOPREVMARKER3,                     true,  false, true,  TEXT(&quot;Previous style of 3rd style&quot;) },
177  	{ VK_4,       IDM_SEARCH_GOPREVMARKER4,                     true,  false, true,  TEXT(&quot;Previous style of 4th style&quot;) },
178  	{ VK_5,       IDM_SEARCH_GOPREVMARKER5,                     true,  false, true,  TEXT(&quot;Previous style of 5th style&quot;) },
179  	{ VK_0,       IDM_SEARCH_GOPREVMARKER_DEF,                  true,  false, true,  TEXT(&quot;Previous style of Find Mark style&quot;) },
180  	{ VK_1,       IDM_SEARCH_GONEXTMARKER1,                     true,  false, false, TEXT(&quot;Next style of 1st style&quot;) },
181  	{ VK_2,       IDM_SEARCH_GONEXTMARKER2,                     true,  false, false, TEXT(&quot;Next style of 2nd style&quot;) },
182  	{ VK_3,       IDM_SEARCH_GONEXTMARKER3,                     true,  false, false, TEXT(&quot;Next style of 3rd style&quot;) },
183  	{ VK_4,       IDM_SEARCH_GONEXTMARKER4,                     true,  false, false, TEXT(&quot;Next style of 4th style&quot;) },
184  	{ VK_5,       IDM_SEARCH_GONEXTMARKER5,                     true,  false, false, TEXT(&quot;Next style of 5th style&quot;) },
185  	{ VK_0,       IDM_SEARCH_GONEXTMARKER_DEF,                  true,  false, false, TEXT(&quot;Next style of Find Mark style&quot;) },
186  	{ VK_NULL,    IDM_SEARCH_STYLE1TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 1st Style&quot;) },
187  	{ VK_NULL,    IDM_SEARCH_STYLE2TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 2nd Style&quot;) },
188  	{ VK_NULL,    IDM_SEARCH_STYLE3TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 3rd Style&quot;) },
189  	{ VK_NULL,    IDM_SEARCH_STYLE4TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 4th Style&quot;) },
190  	{ VK_NULL,    IDM_SEARCH_STYLE5TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 5th Style&quot;) },
191  	{ VK_NULL,    IDM_SEARCH_ALLSTYLESTOCLIP,                   false, false, false, TEXT(&quot;Copy Styled Text of All Styles&quot;) },
192  	{ VK_NULL,    IDM_SEARCH_MARKEDTOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of Find Mark style&quot;) },
193  	{ VK_F2,      IDM_SEARCH_TOGGLE_BOOKMARK,                   true,  false, false, nullptr },
194  	{ VK_F2,      IDM_SEARCH_NEXT_BOOKMARK,                     false, false, false, nullptr },
195  	{ VK_F2,      IDM_SEARCH_PREV_BOOKMARK,                     false, false, true, nullptr  },
196  	{ VK_NULL,    IDM_SEARCH_CLEAR_BOOKMARKS,                   false, false, false, nullptr },
197  	{ VK_NULL,    IDM_SEARCH_CUTMARKEDLINES,                    false, false, false, nullptr },
198  	{ VK_NULL,    IDM_SEARCH_COPYMARKEDLINES,                   false, false, false, nullptr },
199  	{ VK_NULL,    IDM_SEARCH_PASTEMARKEDLINES,                  false, false, false, nullptr },
200  	{ VK_NULL,    IDM_SEARCH_DELETEMARKEDLINES,                 false, false, false, nullptr },
201  	{ VK_NULL,    IDM_SEARCH_DELETEUNMARKEDLINES,               false, false, false, nullptr },
202  	{ VK_NULL,    IDM_SEARCH_INVERSEMARKS,                      false, false, false, nullptr },
203  	{ VK_NULL,    IDM_SEARCH_FINDCHARINRANGE,                   false, false, false, nullptr },
204  	{ VK_NULL,    IDM_VIEW_ALWAYSONTOP,                         false, false, false, nullptr },
205  	{ VK_F11,     IDM_VIEW_FULLSCREENTOGGLE,                    false, false, false, nullptr },
206  	{ VK_F12,     IDM_VIEW_POSTIT,                              false, false, false, nullptr },
207  	{ VK_NULL,    IDM_VIEW_DISTRACTIONFREE,                     false, false, false, nullptr },
208  	{ VK_NULL,    IDM_VIEW_IN_FIREFOX,                          false, false, false, TEXT(&quot;View current file in Firefox&quot;) },
209  	{ VK_NULL,    IDM_VIEW_IN_CHROME,                           false, false, false, TEXT(&quot;View current file in Chrome&quot;) },
210  	{ VK_NULL,    IDM_VIEW_IN_IE,                               false, false, false, TEXT(&quot;View current file in IE&quot;) },
211  	{ VK_NULL,    IDM_VIEW_IN_EDGE,                             false, false, false, TEXT(&quot;View current file in Edge&quot;)  },
212  	{ VK_NULL,    IDM_VIEW_TAB_SPACE,                           false, false, false, nullptr },
213  	{ VK_NULL,    IDM_VIEW_EOL,                                 false, false, false, nullptr },
214  	{ VK_NULL,    IDM_VIEW_ALL_CHARACTERS,                      false, false, false, nullptr },
215  	{ VK_NULL,    IDM_VIEW_NPC,                                 false, false, false, nullptr },
216  	{ VK_NULL,    IDM_VIEW_NPC_CCUNIEOL,                        false, false, false, nullptr },
217  	{ VK_NULL,    IDM_VIEW_INDENT_GUIDE,                        false, false, false, nullptr },
218  	{ VK_NULL,    IDM_VIEW_WRAP_SYMBOL,                         false, false, false, nullptr },
219  	{ VK_NULL,    IDM_VIEW_GOTO_ANOTHER_VIEW,                   false, false, false, nullptr },
220  	{ VK_NULL,    IDM_VIEW_CLONE_TO_ANOTHER_VIEW,               false, false, false, nullptr },
221  	{ VK_NULL,    IDM_VIEW_GOTO_NEW_INSTANCE,                   false, false, false, nullptr },
222  	{ VK_NULL,    IDM_VIEW_LOAD_IN_NEW_INSTANCE,                false, false, false, nullptr },
223  	{ VK_NUMPAD1, IDM_VIEW_TAB1,                                true,  false, false, nullptr },
224  	{ VK_NUMPAD2, IDM_VIEW_TAB2,                                true,  false, false, nullptr },
225  	{ VK_NUMPAD3, IDM_VIEW_TAB3,                                true,  false, false, nullptr },
226  	{ VK_NUMPAD4, IDM_VIEW_TAB4,                                true,  false, false, nullptr },
227  	{ VK_NUMPAD5, IDM_VIEW_TAB5,                                true,  false, false, nullptr },
228  	{ VK_NUMPAD6, IDM_VIEW_TAB6,                                true,  false, false, nullptr },
229  	{ VK_NUMPAD7, IDM_VIEW_TAB7,                                true,  false, false, nullptr },
230  	{ VK_NUMPAD8, IDM_VIEW_TAB8,                                true,  false, false, nullptr },
231  	{ VK_NUMPAD9, IDM_VIEW_TAB9,                                true,  false, false, nullptr },
232  	{ VK_NEXT,    IDM_VIEW_TAB_NEXT,                            true,  false, false, nullptr },
233  	{ VK_PRIOR,   IDM_VIEW_TAB_PREV,                            true,  false, false, nullptr },
234  	{ VK_NEXT,    IDM_VIEW_TAB_MOVEFORWARD,                     true,  false, true,  nullptr },
235  	{ VK_PRIOR,   IDM_VIEW_TAB_MOVEBACKWARD,                    true,  false, true,  nullptr },
236  	{ VK_TAB,     IDC_PREV_DOC,                                 true,  false, true,  TEXT(&quot;Switch to previous document&quot;) },
237  	{ VK_TAB,     IDC_NEXT_DOC,                                 true,  false, false, TEXT(&quot;Switch to next document&quot;) },
238  	{ VK_NULL,    IDM_VIEW_WRAP,                                false, false, false, nullptr },
239  	{ VK_H,       IDM_VIEW_HIDELINES,                           false, true,  false, nullptr },
240  	{ VK_F8,      IDM_VIEW_SWITCHTO_OTHER_VIEW,                 false, false, false, nullptr },
241  	{ VK_0,       IDM_VIEW_FOLDALL,                             false, true,  false, nullptr },
242  	{ VK_0,       IDM_VIEW_UNFOLDALL,                           false, true,  true,  nullptr },
243  	{ VK_F,       IDM_VIEW_FOLD_CURRENT,                        true,  true,  false, nullptr },
244  	{ VK_F,       IDM_VIEW_UNFOLD_CURRENT,                      true,  true,  true,  nullptr },
245  	{ VK_1,       IDM_VIEW_FOLD_1,                              false, true,  false, TEXT(&quot;Fold Level 1&quot;) },
246  	{ VK_2,       IDM_VIEW_FOLD_2,                              false, true,  false, TEXT(&quot;Fold Level 2&quot;) },
247  	{ VK_3,       IDM_VIEW_FOLD_3,                              false, true,  false, TEXT(&quot;Fold Level 3&quot;) },
248  	{ VK_4,       IDM_VIEW_FOLD_4,                              false, true,  false, TEXT(&quot;Fold Level 4&quot;) },
249  	{ VK_5,       IDM_VIEW_FOLD_5,                              false, true,  false, TEXT(&quot;Fold Level 5&quot;) },
250  	{ VK_6,       IDM_VIEW_FOLD_6,                              false, true,  false, TEXT(&quot;Fold Level 6&quot;) },
251  	{ VK_7,       IDM_VIEW_FOLD_7,                              false, true,  false, TEXT(&quot;Fold Level 7&quot;) },
252  	{ VK_8,       IDM_VIEW_FOLD_8,                              false, true,  false, TEXT(&quot;Fold Level 8&quot;) },
253  	{ VK_1,       IDM_VIEW_UNFOLD_1,                            false, true,  true,  TEXT(&quot;Unfold Level 1&quot;) },
254  	{ VK_2,       IDM_VIEW_UNFOLD_2,                            false, true,  true,  TEXT(&quot;Unfold Level 2&quot;) },
255  	{ VK_3,       IDM_VIEW_UNFOLD_3,                            false, true,  true,  TEXT(&quot;Unfold Level 3&quot;) },
256  	{ VK_4,       IDM_VIEW_UNFOLD_4,                            false, true,  true,  TEXT(&quot;Unfold Level 4&quot;) },
257  	{ VK_5,       IDM_VIEW_UNFOLD_5,                            false, true,  true,  TEXT(&quot;Unfold Level 5&quot;) },
258  	{ VK_6,       IDM_VIEW_UNFOLD_6,                            false, true,  true,  TEXT(&quot;Unfold Level 6&quot;) },
259  	{ VK_7,       IDM_VIEW_UNFOLD_7,                            false, true,  true,  TEXT(&quot;Unfold Level 7&quot;) },
260  	{ VK_8,       IDM_VIEW_UNFOLD_8,                            false, true,  true,  TEXT(&quot;Unfold Level 8&quot;) },
261  	{ VK_NULL,    IDM_VIEW_SUMMARY,                             false, false, false, nullptr },
262  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_1,                     false, false, false, TEXT(&quot;Toggle Project Panel 1&quot;) },
263  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_2,                     false, false, false, TEXT(&quot;Toggle Project Panel 2&quot;) },
264  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_3,                     false, false, false, TEXT(&quot;Toggle Project Panel 3&quot;) },
265  	{ VK_NULL,    IDM_VIEW_FILEBROWSER,                         false, false, false, TEXT(&quot;Toggle Folder as Workspace&quot;) },
266  	{ VK_NULL,    IDM_VIEW_DOC_MAP,                             false, false, false, TEXT(&quot;Toggle Document Map&quot;) },
267  	{ VK_NULL,    IDM_VIEW_DOCLIST,                             false, false, false, TEXT(&quot;Toggle Document List&quot;) },
268  	{ VK_NULL,    IDM_VIEW_FUNC_LIST,                           false, false, false, TEXT(&quot;Toggle Function List&quot;) },
269  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_1,            false, false, false, TEXT(&quot;Switch to Project Panel 1&quot;) },
270  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_2,            false, false, false, TEXT(&quot;Switch to Project Panel 2&quot;) },
271  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_3,            false, false, false, TEXT(&quot;Switch to Project Panel 3&quot;) },
272  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FILEBROWSER,                false, false, false, TEXT(&quot;Switch to Folder as Workspace&quot;) },
273  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FUNC_LIST,                  false, false, false, TEXT(&quot;Switch to Function List&quot;) },
274  	{ VK_NULL,    IDM_VIEW_SWITCHTO_DOCLIST,                    false, false, false, TEXT(&quot;Switch to Document List&quot;) },
275  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_NONE,                     false, false, false, TEXT(&quot;Remove Tab Colour&quot;) },
276  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_1,                        false, false, false, TEXT(&quot;Apply Tab Colour 1&quot;) },
277  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_2,                        false, false, false, TEXT(&quot;Apply Tab Colour 2&quot;) },
278  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_3,                        false, false, false, TEXT(&quot;Apply Tab Colour 3&quot;) },
279  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_4,                        false, false, false, TEXT(&quot;Apply Tab Colour 4&quot;) },
280  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_5,                        false, false, false, TEXT(&quot;Apply Tab Colour 5&quot;) },
281  	{ VK_NULL,    IDM_VIEW_SYNSCROLLV,                          false, false, false, nullptr },
282  	{ VK_NULL,    IDM_VIEW_SYNSCROLLH,                          false, false, false, nullptr },
283  	{ VK_R,       IDM_EDIT_RTL,                                 true,  true,  false, nullptr },
284  	{ VK_L,       IDM_EDIT_LTR,                                 true,  true,  false, nullptr },
285  	{ VK_NULL,    IDM_VIEW_MONITORING,                          false, false, false, nullptr },
286  	{ VK_NULL,    IDM_FORMAT_ANSI,                              false, false, false, nullptr },
287  	{ VK_NULL,    IDM_FORMAT_AS_UTF_8,                          false, false, false, nullptr },
288  	{ VK_NULL,    IDM_FORMAT_UTF_8,                             false, false, false, nullptr },
289  	{ VK_NULL,    IDM_FORMAT_UTF_16BE,                          false, false, false, nullptr },
290  	{ VK_NULL,    IDM_FORMAT_UTF_16LE,                          false, false, false, nullptr },
291  	{ VK_NULL,    IDM_FORMAT_ISO_8859_6,                        false, false, false, nullptr },
292  	{ VK_NULL,    IDM_FORMAT_WIN_1256,                          false, false, false, nullptr },
293  	{ VK_NULL,    IDM_FORMAT_ISO_8859_13,                       false, false, false, nullptr },
294  	{ VK_NULL,    IDM_FORMAT_WIN_1257,                          false, false, false, nullptr },
295  	{ VK_NULL,    IDM_FORMAT_ISO_8859_14,                       false, false, false, nullptr },
296  	{ VK_NULL,    IDM_FORMAT_ISO_8859_5,                        false, false, false, nullptr },
297  	{ VK_NULL,    IDM_FORMAT_MAC_CYRILLIC,                      false, false, false, nullptr },
298  	{ VK_NULL,    IDM_FORMAT_KOI8R_CYRILLIC,                    false, false, false, nullptr },
299  	{ VK_NULL,    IDM_FORMAT_KOI8U_CYRILLIC,                    false, false, false, nullptr },
300  	{ VK_NULL,    IDM_FORMAT_WIN_1251,                          false, false, false, nullptr },
301  	{ VK_NULL,    IDM_FORMAT_WIN_1250,                          false, false, false, nullptr },
302  	{ VK_NULL,    IDM_FORMAT_DOS_437,                           false, false, false, nullptr },
303  	{ VK_NULL,    IDM_FORMAT_DOS_720,                           false, false, false, nullptr },
304  	{ VK_NULL,    IDM_FORMAT_DOS_737,                           false, false, false, nullptr },
305  	{ VK_NULL,    IDM_FORMAT_DOS_775,                           false, false, false, nullptr },
306  	{ VK_NULL,    IDM_FORMAT_DOS_850,                           false, false, false, nullptr },
307  	{ VK_NULL,    IDM_FORMAT_DOS_852,                           false, false, false, nullptr },
308  	{ VK_NULL,    IDM_FORMAT_DOS_855,                           false, false, false, nullptr },
309  	{ VK_NULL,    IDM_FORMAT_DOS_857,                           false, false, false, nullptr },
310  	{ VK_NULL,    IDM_FORMAT_DOS_858,                           false, false, false, nullptr },
311  	{ VK_NULL,    IDM_FORMAT_DOS_860,                           false, false, false, nullptr },
312  	{ VK_NULL,    IDM_FORMAT_DOS_861,                           false, false, false, nullptr },
313  	{ VK_NULL,    IDM_FORMAT_DOS_862,                           false, false, false, nullptr },
314  	{ VK_NULL,    IDM_FORMAT_DOS_863,                           false, false, false, nullptr },
315  	{ VK_NULL,    IDM_FORMAT_DOS_865,                           false, false, false, nullptr },
316  	{ VK_NULL,    IDM_FORMAT_DOS_866,                           false, false, false, nullptr },
317  	{ VK_NULL,    IDM_FORMAT_DOS_869,                           false, false, false, nullptr },
318  	{ VK_NULL,    IDM_FORMAT_BIG5,                              false, false, false, nullptr },
319  	{ VK_NULL,    IDM_FORMAT_GB2312,                            false, false, false, nullptr },
320  	{ VK_NULL,    IDM_FORMAT_ISO_8859_2,                        false, false, false, nullptr },
321  	{ VK_NULL,    IDM_FORMAT_ISO_8859_7,                        false, false, false, nullptr },
322  	{ VK_NULL,    IDM_FORMAT_WIN_1253,                          false, false, false, nullptr },
323  	{ VK_NULL,    IDM_FORMAT_ISO_8859_8,                        false, false, false, nullptr },
324  	{ VK_NULL,    IDM_FORMAT_WIN_1255,                          false, false, false, nullptr },
325  	{ VK_NULL,    IDM_FORMAT_SHIFT_JIS,                         false, false, false, nullptr },
326  	{ VK_NULL,    IDM_FORMAT_EUC_KR,                            false, false, false, nullptr },
327  	{ VK_NULL,    IDM_FORMAT_ISO_8859_15,                       false, false, false, nullptr },
328  	{ VK_NULL,    IDM_FORMAT_ISO_8859_4,                        false, false, false, nullptr },
329  	{ VK_NULL,    IDM_FORMAT_ISO_8859_3,                        false, false, false, nullptr },
330  	{ VK_NULL,    IDM_FORMAT_TIS_620,                           false, false, false, nullptr },
331  	{ VK_NULL,    IDM_FORMAT_ISO_8859_9,                        false, false, false, nullptr },
332  	{ VK_NULL,    IDM_FORMAT_WIN_1254,                          false, false, false, nullptr },
333  	{ VK_NULL,    IDM_FORMAT_WIN_1252,                          false, false, false, nullptr },
334  	{ VK_NULL,    IDM_FORMAT_ISO_8859_1,                        false, false, false, nullptr },
335  	{ VK_NULL,    IDM_FORMAT_WIN_1258,                          false, false, false, nullptr },
336  	{ VK_NULL,    IDM_FORMAT_CONV2_ANSI,                        false, false, false, nullptr },
337  	{ VK_NULL,    IDM_FORMAT_CONV2_AS_UTF_8,                    false, false, false, nullptr },
338  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_8,                       false, false, false, nullptr },
339  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16BE,                    false, false, false, nullptr },
340  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16LE,                    false, false, false, nullptr },
341  	{ VK_NULL,    IDM_LANG_USER_DLG,                            false, false, false, nullptr },
342  	{ VK_NULL,    IDM_LANG_USER,                                false, false, false, nullptr },
343  	{ VK_NULL,    IDM_LANG_OPENUDLDIR,                          false, false, false, nullptr },
344  	{ VK_NULL,    IDM_SETTING_PREFERENCE,                       false, false, false, nullptr },
345  	{ VK_NULL,    IDM_LANGSTYLE_CONFIG_DLG,                     false, false, false, nullptr },
346  	{ VK_NULL,    IDM_SETTING_SHORTCUT_MAPPER,                  false, false, false, nullptr },
347  	{ VK_NULL,    IDM_SETTING_IMPORTPLUGIN,                     false, false, false, nullptr },
348  	{ VK_NULL,    IDM_SETTING_IMPORTSTYLETHEMS,                 false, false, false, nullptr },
349  	{ VK_NULL,    IDM_SETTING_EDITCONTEXTMENU,                  false, false, false, nullptr },
350  	{ VK_R,       IDC_EDIT_TOGGLEMACRORECORDING,                true,  false, true,  TEXT(&quot;Toggle macro recording&quot;)},
351  	{ VK_NULL,    IDM_MACRO_STARTRECORDINGMACRO,                false, false, false, nullptr },
352  	{ VK_NULL,    IDM_MACRO_STOPRECORDINGMACRO,                 false, false, false, nullptr },
353  	{ VK_P,       IDM_MACRO_PLAYBACKRECORDEDMACRO,              true,  false, true,  nullptr },
354  	{ VK_NULL,    IDM_MACRO_SAVECURRENTMACRO,                   false, false, false, nullptr },
355  	{ VK_NULL,    IDM_MACRO_RUNMULTIMACRODLG,                   false, false, false, nullptr },
356  	{ VK_F5,      IDM_EXECUTE,                                  false, false, false, nullptr },
357  	{ VK_NULL,    IDM_WINDOW_SORT_FN_ASC,                       false, false, false, TEXT(&quot;Sort By Name A to Z&quot;) },
358  	{ VK_NULL,    IDM_WINDOW_SORT_FN_DSC,                       false, false, false, TEXT(&quot;Sort By Name Z to A&quot;) },
359  	{ VK_NULL,    IDM_WINDOW_SORT_FP_ASC,                       false, false, false, TEXT(&quot;Sort By Path A to Z&quot;) },
360  	{ VK_NULL,    IDM_WINDOW_SORT_FP_DSC,                       false, false, false, TEXT(&quot;Sort By Path Z to A&quot;) },
361  	{ VK_NULL,    IDM_WINDOW_SORT_FT_ASC,                       false, false, false, TEXT(&quot;Sort By Type A to Z&quot;) },
362  	{ VK_NULL,    IDM_WINDOW_SORT_FT_DSC,                       false, false, false, TEXT(&quot;Sort By Type Z to A&quot;) },
363  	{ VK_NULL,    IDM_WINDOW_SORT_FS_ASC,                       false, false, false, TEXT(&quot;Sort By Size Smaller to Larger&quot;) },
364  	{ VK_NULL,    IDM_WINDOW_SORT_FS_DSC,                       false, false, false, TEXT(&quot;Sort By Size Larger to Smaller&quot;) },
365  	{ VK_NULL,    IDM_CMDLINEARGUMENTS,                         false, false, false, nullptr },
366  	{ VK_NULL,    IDM_HOMESWEETHOME,                            false, false, false, nullptr },
367  	{ VK_NULL,    IDM_PROJECTPAGE,                              false, false, false, nullptr },
368  	{ VK_NULL,    IDM_ONLINEDOCUMENT,                           false, false, false, nullptr },
369  	{ VK_NULL,    IDM_FORUM,                                    false, false, false, nullptr },
370  	{ VK_NULL,    IDM_UPDATE_NPP,                               false, false, false, TEXT(&quot;Update Notepad++&quot;) },
371  	{ VK_NULL,    IDM_CONFUPDATERPROXY,                         false, false, false, TEXT(&quot;Set Updater Proxy...&quot;) },
372  	{ VK_NULL,    IDM_DEBUGINFO,                                false, false, false, nullptr },
373  	{ VK_F1,      IDM_ABOUT,                                    false, false, false, nullptr }
374  };
375  static const ScintillaKeyDefinition scintKeyDefs[] =
376  {
377  	{TEXT(&quot;SCI_CUT&quot;),                     SCI_CUT,                     true,  false, false, VK_X,        IDM_EDIT_CUT},
378  	{TEXT(&quot;&quot;),                            SCI_CUT,                     false, false, true,  VK_DELETE,   0},
379  	{TEXT(&quot;SCI_COPY&quot;),                    SCI_COPY,                    true,  false, false, VK_C,        IDM_EDIT_COPY},
380  	{TEXT(&quot;&quot;),                            SCI_COPY,                    true,  false, false, VK_INSERT,   0},
381  	{TEXT(&quot;SCI_PASTE&quot;),                   SCI_PASTE,                   true,  false, false, VK_V,        IDM_EDIT_PASTE},
382  	{TEXT(&quot;&quot;),                            SCI_PASTE,                   false, false, true,  VK_INSERT,   0},
383  	{TEXT(&quot;SCI_SELECTALL&quot;),               SCI_SELECTALL,               true,  false, false, VK_A,        IDM_EDIT_SELECTALL},
384  	{TEXT(&quot;SCI_CLEAR&quot;),                   SCI_CLEAR,                   false, false, false, VK_DELETE,   IDM_EDIT_DELETE},
385  	{TEXT(&quot;SCI_CLEARALL&quot;),                SCI_CLEARALL,                false, false, false, 0,           0},
386  	{TEXT(&quot;SCI_UNDO&quot;),                    SCI_UNDO,                    true,  false, false, VK_Z,        IDM_EDIT_UNDO},
387  	{TEXT(&quot;&quot;),                            SCI_UNDO,                    false, true,  false, VK_BACK,     0},
388  	{TEXT(&quot;SCI_REDO&quot;),                    SCI_REDO,                    true,  false, false, VK_Y,        IDM_EDIT_REDO},
389  	{TEXT(&quot;&quot;),                            SCI_REDO,                    true,  false, true,  VK_Z,        0},
390  	{TEXT(&quot;SCI_NEWLINE&quot;),                 SCI_NEWLINE,                 false, false, false, VK_RETURN,   0},
391  	{TEXT(&quot;&quot;),                            SCI_NEWLINE,                 false, false, true,  VK_RETURN,   0},
392  	{TEXT(&quot;SCI_TAB&quot;),                     SCI_TAB,                     false, false, false, VK_TAB,      0},
393  	{TEXT(&quot;SCI_BACKTAB&quot;),                 SCI_BACKTAB,                 false, false, true,  VK_TAB,      0},
394  	{TEXT(&quot;SCI_FORMFEED&quot;),                SCI_FORMFEED,                false, false, false, 0,           0},
395  	{TEXT(&quot;SCI_ZOOMIN&quot;),                  SCI_ZOOMIN,                  true,  false, false, VK_ADD,      IDM_VIEW_ZOOMIN},
396  	{TEXT(&quot;SCI_ZOOMOUT&quot;),                 SCI_ZOOMOUT,                 true,  false, false, VK_SUBTRACT, IDM_VIEW_ZOOMOUT},
397  	{TEXT(&quot;SCI_SETZOOM&quot;),                 SCI_SETZOOM,                 true,  false, false, VK_DIVIDE,   IDM_VIEW_ZOOMRESTORE},
398  	{TEXT(&quot;SCI_SELECTIONDUPLICATE&quot;),      SCI_SELECTIONDUPLICATE,      true,  false, false, VK_D,        IDM_EDIT_DUP_LINE},
399  	{TEXT(&quot;SCI_LINESJOIN&quot;),               SCI_LINESJOIN,               false, false, false, 0,           0},
400  	{TEXT(&quot;SCI_SCROLLCARET&quot;),             SCI_SCROLLCARET,             false, false, false, 0,           0},
401  	{TEXT(&quot;SCI_EDITTOGGLEOVERTYPE&quot;),      SCI_EDITTOGGLEOVERTYPE,      false, false, false, VK_INSERT,   0},
402  	{TEXT(&quot;SCI_MOVECARETINSIDEVIEW&quot;),     SCI_MOVECARETINSIDEVIEW,     false, false, false, 0,           0},
403  	{TEXT(&quot;SCI_LINEDOWN&quot;),                SCI_LINEDOWN,                false, false, false, VK_DOWN,     0},
404  	{TEXT(&quot;SCI_LINEDOWNEXTEND&quot;),          SCI_LINEDOWNEXTEND,          false, false, true,  VK_DOWN,     0},
405  	{TEXT(&quot;SCI_LINEDOWNRECTEXTEND&quot;),      SCI_LINEDOWNRECTEXTEND,      false, true,  true,  VK_DOWN,     0},
406  	{TEXT(&quot;SCI_LINESCROLLDOWN&quot;),          SCI_LINESCROLLDOWN,          true,  false, false, VK_DOWN,     0},
407  	{TEXT(&quot;SCI_LINEUP&quot;),                  SCI_LINEUP,                  false, false, false, VK_UP,       0},
408  	{TEXT(&quot;SCI_LINEUPEXTEND&quot;),            SCI_LINEUPEXTEND,            false, false, true,  VK_UP,       0},
409  	{TEXT(&quot;SCI_LINEUPRECTEXTEND&quot;),        SCI_LINEUPRECTEXTEND,        false, true,  true,  VK_UP,       0},
410  	{TEXT(&quot;SCI_LINESCROLLUP&quot;),            SCI_LINESCROLLUP,            true,  false, false, VK_UP,       0},
411  	{TEXT(&quot;SCI_PARADOWN&quot;),                SCI_PARADOWN,                true,  false, false, VK_OEM_6,    0},
412  	{TEXT(&quot;SCI_PARADOWNEXTEND&quot;),          SCI_PARADOWNEXTEND,          true,  false, true,  VK_OEM_6,    0},
413  	{TEXT(&quot;SCI_PARAUP&quot;),                  SCI_PARAUP,                  true,  false, false, VK_OEM_4,    0},
414  	{TEXT(&quot;SCI_PARAUPEXTEND&quot;),            SCI_PARAUPEXTEND,            true,  false, true,  VK_OEM_4,    0},
415  	{TEXT(&quot;SCI_CHARLEFT&quot;),                SCI_CHARLEFT,                false, false, false, VK_LEFT,     0},
416  	{TEXT(&quot;SCI_CHARLEFTEXTEND&quot;),          SCI_CHARLEFTEXTEND,          false, false, true,  VK_LEFT,     0},
417  	{TEXT(&quot;SCI_CHARLEFTRECTEXTEND&quot;),      SCI_CHARLEFTRECTEXTEND,      false, true,  true,  VK_LEFT,     0},
418  	{TEXT(&quot;SCI_CHARRIGHT&quot;),               SCI_CHARRIGHT,               false, false, false, VK_RIGHT,    0},
419  	{TEXT(&quot;SCI_CHARRIGHTEXTEND&quot;),         SCI_CHARRIGHTEXTEND,         false, false, true,  VK_RIGHT,    0},
420  	{TEXT(&quot;SCI_CHARRIGHTRECTEXTEND&quot;),     SCI_CHARRIGHTRECTEXTEND,     false, true,  true,  VK_RIGHT,    0},
421  	{TEXT(&quot;SCI_WORDLEFT&quot;),                SCI_WORDLEFT,                true,  false, false, VK_LEFT,     0},
422  	{TEXT(&quot;SCI_WORDLEFTEXTEND&quot;),          SCI_WORDLEFTEXTEND,          true,  false, true,  VK_LEFT,     0},
423  	{TEXT(&quot;SCI_WORDRIGHT&quot;),               SCI_WORDRIGHT,               true,  false, false, VK_RIGHT,    0},
424  	{TEXT(&quot;SCI_WORDRIGHTEXTEND&quot;),         SCI_WORDRIGHTEXTEND,         false, false, false, 0,           0},
425  	{TEXT(&quot;SCI_WORDLEFTEND&quot;),             SCI_WORDLEFTEND,             false, false, false, 0,           0},
426  	{TEXT(&quot;SCI_WORDLEFTENDEXTEND&quot;),       SCI_WORDLEFTENDEXTEND,       false, false, false, 0,           0},
427  	{TEXT(&quot;SCI_WORDRIGHTEND&quot;),            SCI_WORDRIGHTEND,            false, false, false, 0,           0},
428  	{TEXT(&quot;SCI_WORDRIGHTENDEXTEND&quot;),      SCI_WORDRIGHTENDEXTEND,      true,  false, true,  VK_RIGHT,    0},
429  	{TEXT(&quot;SCI_WORDPARTLEFT&quot;),            SCI_WORDPARTLEFT,            true,  false, false, VK_OEM_2,    0},
430  	{TEXT(&quot;SCI_WORDPARTLEFTEXTEND&quot;),      SCI_WORDPARTLEFTEXTEND,      true,  false, true,  VK_OEM_2,    0},
431  	{TEXT(&quot;SCI_WORDPARTRIGHT&quot;),           SCI_WORDPARTRIGHT,           true,  false, false, VK_OEM_5,    0},
432  	{TEXT(&quot;SCI_WORDPARTRIGHTEXTEND&quot;),     SCI_WORDPARTRIGHTEXTEND,     true,  false, true,  VK_OEM_5,    0},
433  	{TEXT(&quot;SCI_HOME&quot;),                    SCI_HOME,                    false, false, false, 0,           0},
434  	{TEXT(&quot;SCI_HOMEEXTEND&quot;),              SCI_HOMEEXTEND,              false, false, false, 0,           0},
435  	{TEXT(&quot;SCI_HOMERECTEXTEND&quot;),          SCI_HOMERECTEXTEND,          false, false, false, 0,           0},
436  	{TEXT(&quot;SCI_HOMEDISPLAY&quot;),             SCI_HOMEDISPLAY,             false, true,  false, VK_HOME,     0},
437  	{TEXT(&quot;SCI_HOMEDISPLAYEXTEND&quot;),       SCI_HOMEDISPLAYEXTEND,       false, false, false, 0,           0},
438  	{TEXT(&quot;SCI_HOMEWRAP&quot;),                SCI_HOMEWRAP,                false, false, false, 0,           0},
439  	{TEXT(&quot;SCI_HOMEWRAPEXTEND&quot;),          SCI_HOMEWRAPEXTEND,          false, false, false, 0,           0},
440  	{TEXT(&quot;SCI_VCHOME&quot;),                  SCI_VCHOME,                  false, false, false, 0,           0},
441  	{TEXT(&quot;SCI_VCHOMEEXTEND&quot;),            SCI_VCHOMEEXTEND,            false, false, false, 0,           0},
442  	{TEXT(&quot;SCI_VCHOMERECTEXTEND&quot;),        SCI_VCHOMERECTEXTEND,        false, true,  true,  VK_HOME,     0},
443  	{TEXT(&quot;SCI_VCHOMEDISPLAY&quot;),           SCI_VCHOMEDISPLAY,           false, false, false, 0,           0},
444  	{TEXT(&quot;SCI_VCHOMEDISPLAYEXTEND&quot;),     SCI_VCHOMEDISPLAYEXTEND,     false, false, false, 0,           0},
445  	{TEXT(&quot;SCI_VCHOMEWRAP&quot;),              SCI_VCHOMEWRAP,              false, false, false, VK_HOME,     0},
446  	{TEXT(&quot;SCI_VCHOMEWRAPEXTEND&quot;),        SCI_VCHOMEWRAPEXTEND,        false, false, true,  VK_HOME,     0},
447  	{TEXT(&quot;SCI_LINEEND&quot;),                 SCI_LINEEND,                 false, false, false, 0,           0},
448  	{TEXT(&quot;SCI_LINEENDWRAPEXTEND&quot;),       SCI_LINEENDWRAPEXTEND,       false, false, true,  VK_END,      0},
449  	{TEXT(&quot;SCI_LINEENDRECTEXTEND&quot;),       SCI_LINEENDRECTEXTEND,       false, true,  true,  VK_END,      0},
450  	{TEXT(&quot;SCI_LINEENDDISPLAY&quot;),          SCI_LINEENDDISPLAY,          false, true,  false, VK_END,      0},
451  	{TEXT(&quot;SCI_LINEENDDISPLAYEXTEND&quot;),    SCI_LINEENDDISPLAYEXTEND,    false, false, false, 0,           0},
452  	{TEXT(&quot;SCI_LINEENDWRAP&quot;),             SCI_LINEENDWRAP,             false, false, false, VK_END,      0},
453  	{TEXT(&quot;SCI_LINEENDEXTEND&quot;),           SCI_LINEENDEXTEND,           false, false, false, 0,           0},
454  	{TEXT(&quot;SCI_DOCUMENTSTART&quot;),           SCI_DOCUMENTSTART,           true,  false, false, VK_HOME,     0},
455  	{TEXT(&quot;SCI_DOCUMENTSTARTEXTEND&quot;),     SCI_DOCUMENTSTARTEXTEND,     true,  false, true,  VK_HOME,     0},
456  	{TEXT(&quot;SCI_DOCUMENTEND&quot;),             SCI_DOCUMENTEND,             true,  false, false, VK_END,      0},
457  	{TEXT(&quot;SCI_DOCUMENTENDEXTEND&quot;),       SCI_DOCUMENTENDEXTEND,       true,  false, true,  VK_END,      0},
458  	{TEXT(&quot;SCI_PAGEUP&quot;),                  SCI_PAGEUP,                  false, false, false, VK_PRIOR,    0},
459  	{TEXT(&quot;SCI_PAGEUPEXTEND&quot;),            SCI_PAGEUPEXTEND,            false, false, true,  VK_PRIOR,    0},
460  	{TEXT(&quot;SCI_PAGEUPRECTEXTEND&quot;),        SCI_PAGEUPRECTEXTEND,        false, true,  true,  VK_PRIOR,    0},
461  	{TEXT(&quot;SCI_PAGEDOWN&quot;),                SCI_PAGEDOWN,                false, false, false, VK_NEXT,     0},
462  	{TEXT(&quot;SCI_PAGEDOWNEXTEND&quot;),          SCI_PAGEDOWNEXTEND,          false, false, true,  VK_NEXT,     0},
463  	{TEXT(&quot;SCI_PAGEDOWNRECTEXTEND&quot;),      SCI_PAGEDOWNRECTEXTEND,      false, true,  true,  VK_NEXT,     0},
464  	{TEXT(&quot;SCI_STUTTEREDPAGEUP&quot;),         SCI_STUTTEREDPAGEUP,         false, false, false, 0,           0},
465  	{TEXT(&quot;SCI_STUTTEREDPAGEUPEXTEND&quot;),   SCI_STUTTEREDPAGEUPEXTEND,   false, false, false, 0,           0},
466  	{TEXT(&quot;SCI_STUTTEREDPAGEDOWN&quot;),       SCI_STUTTEREDPAGEDOWN,       false, false, false, 0,           0},
467  	{TEXT(&quot;SCI_STUTTEREDPAGEDOWNEXTEND&quot;), SCI_STUTTEREDPAGEDOWNEXTEND, false, false, false, 0,           0},
468  	{TEXT(&quot;SCI_DELETEBACK&quot;),              SCI_DELETEBACK,              false, false, false, VK_BACK,     0},
469  	{TEXT(&quot;&quot;),                            SCI_DELETEBACK,              false, false, true,  VK_BACK,     0},
470  	{TEXT(&quot;SCI_DELETEBACKNOTLINE&quot;),       SCI_DELETEBACKNOTLINE,       false, false, false, 0,           0},
471  	{TEXT(&quot;SCI_DELWORDLEFT&quot;),             SCI_DELWORDLEFT,             true,  false, false, VK_BACK,     0},
472  	{TEXT(&quot;SCI_DELWORDRIGHT&quot;),            SCI_DELWORDRIGHT,            true,  false, false, VK_DELETE,   0},
473  	{TEXT(&quot;SCI_DELLINELEFT&quot;),             SCI_DELLINELEFT,             true,  false, true,  VK_BACK,     0},
474  	{TEXT(&quot;SCI_DELLINERIGHT&quot;),            SCI_DELLINERIGHT,            true,  false, true,  VK_DELETE,   0},
475  	{TEXT(&quot;SCI_LINEDELETE&quot;),              SCI_LINEDELETE,              true,  false, true,  VK_L,        0},
476  	{TEXT(&quot;SCI_LINECUT&quot;),                 SCI_LINECUT,                 true,  false, false, VK_L,        0},
477  	{TEXT(&quot;SCI_LINECOPY&quot;),                SCI_LINECOPY,                true,  false, true,  VK_X,        0},
478  	{TEXT(&quot;SCI_LINETRANSPOSE&quot;),           SCI_LINETRANSPOSE,           true,  false, false, VK_T,        0},
479  	{TEXT(&quot;SCI_LINEDUPLICATE&quot;),           SCI_LINEDUPLICATE,           false, false, false, 0,           0},
480  	{TEXT(&quot;SCI_CANCEL&quot;),                  SCI_CANCEL,                  false, false, false, VK_ESCAPE,   0},
481  	{TEXT(&quot;SCI_SWAPMAINANCHORCARET&quot;),     SCI_SWAPMAINANCHORCARET,     false, false, false, 0,           0},
482  	{TEXT(&quot;SCI_ROTATESELECTION&quot;),         SCI_ROTATESELECTION,         false, false, false, 0,           0}
483  };
484  #define NONEEDSHORTCUTSXMLBACKUP_FILENAME L&quot;v852NoNeedShortcutsBackup.xml&quot;
485  #define SHORTCUTSXML_FILENAME L&quot;shortcuts.xml&quot;
486  typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
487  int strVal(const TCHAR *str, int base)
488  {
489  	if (!str) return -1;
490  	if (!str[0]) return 0;
491  	TCHAR *finStr;
492  	int result = wcstol(str, &amp;finStr, base);
493  	if (*finStr != &#x27;\0&#x27;)
494  		return -1;
495  	return result;
496  }
497  int decStrVal(const TCHAR *str)
498  {
499  	return strVal(str, 10);
500  }
501  int hexStrVal(const TCHAR *str)
502  {
503  	return strVal(str, 16);
504  }
505  int getKwClassFromName(const TCHAR *str)
506  {
507  	if (!lstrcmp(TEXT(&quot;instre1&quot;), str)) return LANG_INDEX_INSTR;
508  	if (!lstrcmp(TEXT(&quot;instre2&quot;), str)) return LANG_INDEX_INSTR2;
509  	if (!lstrcmp(TEXT(&quot;type1&quot;), str)) return LANG_INDEX_TYPE;
510  	if (!lstrcmp(TEXT(&quot;type2&quot;), str)) return LANG_INDEX_TYPE2;
511  	if (!lstrcmp(TEXT(&quot;type3&quot;), str)) return LANG_INDEX_TYPE3;
512  	if (!lstrcmp(TEXT(&quot;type4&quot;), str)) return LANG_INDEX_TYPE4;
513  	if (!lstrcmp(TEXT(&quot;type5&quot;), str)) return LANG_INDEX_TYPE5;
514  	if (!lstrcmp(TEXT(&quot;type6&quot;), str)) return LANG_INDEX_TYPE6;
515  	if (!lstrcmp(TEXT(&quot;type7&quot;), str)) return LANG_INDEX_TYPE7;
516  	if ((str[1] == &#x27;\0&#x27;) &amp;&amp; (str[0] &gt;= &#x27;0&#x27;) &amp;&amp; (str[0] &lt;= &#x27;8&#x27;)) 
517  		return str[0] - &#x27;0&#x27;;
518  	return -1;
519  }
520  } 
521  void cutString(const TCHAR* str2cut, vector&lt;generic_string&gt;&amp; patternVect)
522  {
523  	if (str2cut == nullptr) return;
524  	const TCHAR *pBegin = str2cut;
525  	const TCHAR *pEnd = pBegin;
526  	while (*pEnd != &#x27;\0&#x27;)
527  	{
528  		if (_istspace(*pEnd))
529  		{
530  			if (pBegin != pEnd)
531  				patternVect.emplace_back(pBegin, pEnd);
532  			pBegin = pEnd + 1;
533  		}
534  		++pEnd;
535  	}
536  	if (pBegin != pEnd)
537  		patternVect.emplace_back(pBegin, pEnd);
538  }
539  void cutStringBy(const TCHAR* str2cut, vector&lt;generic_string&gt;&amp; patternVect, char byChar, bool allowEmptyStr)
540  {
541  	if (str2cut == nullptr) return;
542  	const TCHAR* pBegin = str2cut;
543  	const TCHAR* pEnd = pBegin;
544  	while (*pEnd != &#x27;\0&#x27;)
545  	{
546  		if (*pEnd == byChar)
547  		{
548  			if (allowEmptyStr)
549  				patternVect.emplace_back(pBegin, pEnd);
550  			else if (pBegin != pEnd)
551  				patternVect.emplace_back(pBegin, pEnd);
552  			pBegin = pEnd + 1;
553  		}
554  		++pEnd;
555  	}
556  	if (allowEmptyStr)
557  		patternVect.emplace_back(pBegin, pEnd);
558  	else if (pBegin != pEnd)
559  		patternVect.emplace_back(pBegin, pEnd);
560  }
561  std::wstring LocalizationSwitcher::getLangFromXmlFileName(const wchar_t *fn) const
562  {
563  	size_t nbItem = sizeof(localizationDefs)/sizeof(LocalizationSwitcher::LocalizationDefinition);
564  	for (size_t i = 0 ; i &lt; nbItem ; ++i)
565  	{
566  		if (0 == wcsicmp(fn, localizationDefs[i]._xmlFileName))
567  			return localizationDefs[i]._langName;
568  	}
569  	return std::wstring();
570  }
571  std::wstring LocalizationSwitcher::getXmlFilePathFromLangName(const wchar_t *langName) const
572  {
573  	for (size_t i = 0, len = _localizationList.size(); i &lt; len ; ++i)
574  	{
575  		if (0 == wcsicmp(langName, _localizationList[i].first.c_str()))
576  			return _localizationList[i].second;
577  	}
578  	return std::wstring();
579  }
580  bool LocalizationSwitcher::addLanguageFromXml(const std::wstring&amp; xmlFullPath)
581  {
582  	wchar_t * fn = ::PathFindFileNameW(xmlFullPath.c_str());
583  	wstring foundLang = getLangFromXmlFileName(fn);
584  	if (!foundLang.empty())
585  	{
586  		_localizationList.push_back(pair&lt;wstring, wstring&gt;(foundLang, xmlFullPath));
587  		return true;
588  	}
589  	return false;
590  }
591  bool LocalizationSwitcher::switchToLang(const wchar_t *lang2switch) const
592  {
593  	wstring langPath = getXmlFilePathFromLangName(lang2switch);
594  	if (langPath.empty())
595  		return false;
596  	return ::CopyFileW(langPath.c_str(), _nativeLangPath.c_str(), FALSE) != FALSE;
597  }
598  generic_string ThemeSwitcher::getThemeFromXmlFileName(const TCHAR *xmlFullPath) const
599  {
600  	if (!xmlFullPath || !xmlFullPath[0])
601  		return generic_string();
602  	generic_string fn(::PathFindFileName(xmlFullPath));
603  	PathRemoveExtension(const_cast&lt;TCHAR *&gt;(fn.c_str()));
604  	return fn;
605  }
606  int DynamicMenu::getTopLevelItemNumber() const
607  {
608  	int nb = 0;
609  	generic_string previousFolderName;
610  	for (const MenuItemUnit&amp; i : _menuItems)
611  	{
612  		if (i._parentFolderName.empty())
613  		{
614  			++nb;
615  		}
616  		else
617  		{
618  			if (previousFolderName.empty())
619  			{
620  				++nb;
621  				previousFolderName = i._parentFolderName;
622  			}
623  			else 
624  			{
625  				if (i._parentFolderName.empty())
626  				{
627  					++nb;
628  					previousFolderName = i._parentFolderName;
629  				}
630  				else if (previousFolderName == i._parentFolderName)
631  				{
632  				}
633  				else
634  				{
635  					++nb;
636  					previousFolderName = i._parentFolderName;
637  				}
638  			}
639  		}
640  	}
641  	return nb;
642  }
643  bool DynamicMenu::attach(HMENU hMenu, unsigned int posBase, int lastCmd, const generic_string&amp; lastCmdLabel)
644  {
645  	if (!hMenu) return false;
646  	_hMenu = hMenu;
647  	_posBase = posBase;
648  	_lastCmd = lastCmd;
649  	_lastCmdLabel = lastCmdLabel;
650  	return createMenu();
651  }
652  bool DynamicMenu::clearMenu() const
653  {
654  	if (!_hMenu) return false;
655  	int nbTopItem = getTopLevelItemNumber();
656  	for (int i = nbTopItem + 1; i &gt;= 0 ; --i)
657  	{
658  		::DeleteMenu(_hMenu, static_cast&lt;int32_t&gt;(_posBase) + i, MF_BYPOSITION);
659  	}
660  	return true;
661  }
662  bool DynamicMenu::createMenu() const
663  {
664  	if (!_hMenu) return false;
665  	bool lastIsSep = false;
666  	HMENU hParentFolder = NULL;
667  	generic_string currentParentFolderStr;
668  	int j = 0;
669  	size_t nb = _menuItems.size();
670  	size_t i = 0;
671  	for (; i &lt; nb; ++i)
672  	{
673  		const MenuItemUnit&amp; item = _menuItems[i];
674  		if (item._parentFolderName.empty())
675  		{
676  			currentParentFolderStr.clear();
677  			hParentFolder = NULL;
678  			j = 0;
679  		}
680  		else
681  		{
682  			if (item._parentFolderName != currentParentFolderStr)
683  			{
684  				currentParentFolderStr = item._parentFolderName;
685  				hParentFolder = ::CreateMenu();
686  				j = 0;
687  				::InsertMenu(_hMenu, static_cast&lt;UINT&gt;(_posBase + i), MF_BYPOSITION | MF_POPUP, (UINT_PTR)hParentFolder, currentParentFolderStr.c_str());
688  			}
689  		}
690  		unsigned int flag = MF_BYPOSITION | ((item._cmdID == 0) ? MF_SEPARATOR : 0);
691  		if (hParentFolder)
692  		{
693  			::InsertMenu(hParentFolder, j++, flag, item._cmdID, item._itemName.c_str());
694  			lastIsSep = false;
695  		}
696  		else if ((i == 0 || i == _menuItems.size() - 1) &amp;&amp; item._cmdID == 0)
697  		{
698  			lastIsSep = true;
699  		}
700  		else if (item._cmdID != 0)
701  		{
702  			::InsertMenu(_hMenu, static_cast&lt;UINT&gt;(_posBase + i), flag, item._cmdID, item._itemName.c_str());
703  			lastIsSep = false;
704  		}
705  		else if (item._cmdID == 0 &amp;&amp; !lastIsSep)
706  		{
707  			::InsertMenu(_hMenu, static_cast&lt;int32_t&gt;(_posBase + i), flag, item._cmdID, item._itemName.c_str());
708  			lastIsSep = true;
709  		}
710  		else 
711  		{
712  			lastIsSep = true;
713  		}
714  	}
715  	if (nb &gt; 0)
716  	{
717  		::InsertMenu(_hMenu, static_cast&lt;int32_t&gt;(_posBase + i), MF_BYPOSITION | MF_SEPARATOR, 0, nullptr);
718  		::InsertMenu(_hMenu, static_cast&lt;UINT&gt;(_posBase + i + 2), MF_BYCOMMAND, _lastCmd, _lastCmdLabel.c_str());
719  	}
720  	return true;
721  }
722  winVer NppParameters::getWindowsVersion()
723  {
724  	OSVERSIONINFOEX osvi;
725  	SYSTEM_INFO si;
726  	PGNSI pGNSI;
727  	ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
728  	ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
729  	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
730  	BOOL bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *)&amp;osvi);
731  	if (!bOsVersionInfoEx)
732  	{
733  		osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
734  		if (! GetVersionEx ( (OSVERSIONINFO *) &amp;osvi) )
735  			return WV_UNKNOWN;
736  	}
737  	pGNSI = (PGNSI) GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;GetNativeSystemInfo&quot;);
738  	if (pGNSI != NULL)
739  		pGNSI(&amp;si);
740  	else
741  		GetSystemInfo(&amp;si);
742  	switch (si.wProcessorArchitecture)
743  	{
744  	case PROCESSOR_ARCHITECTURE_IA64:
745  		_platForm = PF_IA64;
746  		break;
747  	case PROCESSOR_ARCHITECTURE_AMD64:
748  		_platForm = PF_X64;
749  		break;
750  	case PROCESSOR_ARCHITECTURE_INTEL:
751  		_platForm = PF_X86;
752  		break;
753  	case PROCESSOR_ARCHITECTURE_ARM64:
754  		_platForm = PF_ARM64;
755  		break;
756  	default:
757  		_platForm = PF_UNKNOWN;
758  	}
759     switch (osvi.dwPlatformId)
760     {
761  		case VER_PLATFORM_WIN32_NT:
762  		{
763  			if (osvi.dwMajorVersion == 10 &amp;&amp; osvi.dwMinorVersion == 0 &amp;&amp; osvi.dwBuildNumber &gt;= 22000)
764  				return WV_WIN11;
765  			if (osvi.dwMajorVersion == 10 &amp;&amp; osvi.dwMinorVersion == 0)
766  				return WV_WIN10;
767  			if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 3)
768  				return WV_WIN81;
769  			if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 2)
770  				return WV_WIN8;
771  			if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 1)
772  				return WV_WIN7;
773  			if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 0)
774  				return WV_VISTA;
775  			if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 2)
776  			{
777  				if (osvi.wProductType == VER_NT_WORKSTATION &amp;&amp; si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
778  					return WV_XPX64;
779  				return WV_S2003;
780  			}
781  			if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 1)
782  				return WV_XP;
783  			if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 0)
784  				return WV_W2K;
785  			if (osvi.dwMajorVersion &lt;= 4)
786  				return WV_NT;
787  			break;
788  		}
789  		case VER_PLATFORM_WIN32_WINDOWS:
790  		{
791  			if (osvi.dwMajorVersion == 4 &amp;&amp; osvi.dwMinorVersion == 0)
792  				return WV_95;
793  			if (osvi.dwMajorVersion == 4 &amp;&amp; osvi.dwMinorVersion == 10)
794  				return WV_98;
795  			if (osvi.dwMajorVersion == 4 &amp;&amp; osvi.dwMinorVersion == 90)
796  				return WV_ME;
797  			break;
798  		}
799  		case VER_PLATFORM_WIN32s:
800  			return WV_WIN32S;
801  		default:
802  			return WV_UNKNOWN;
803     }
804     return WV_UNKNOWN;
805  }
806  NppParameters::NppParameters()
807  {
808  	_winVersion = getWindowsVersion();
809  	TCHAR nppPath[MAX_PATH];
810  	::GetModuleFileName(NULL, nppPath, MAX_PATH);
811  	PathRemoveFileSpec(nppPath);
812  	_nppPath = nppPath;
813  	TCHAR curDir[MAX_PATH];
814  	::GetCurrentDirectory(MAX_PATH, curDir);
815  	_currentDirectory = curDir;
816  	_appdataNppDir.clear();
817  	generic_string notepadStylePath(_nppPath);
818  	pathAppend(notepadStylePath, notepadStyleFile);
819  	_asNotepadStyle = (PathFileExists(notepadStylePath.c_str()) == TRUE);
820  	initMenuKeys();
821  	initScintillaKeys();
822  }
823  NppParameters::~NppParameters()
824  {
825  	for (int i = 0 ; i &lt; _nbLang ; ++i)
826  		delete _langList[i];
827  	for (int i = 0 ; i &lt; _nbRecentFile ; ++i)
828  		delete _LRFileList[i];
829  	for (int i = 0 ; i &lt; _nbUserLang ; ++i)
830  		delete _userLangArray[i];
831  	for (std::vector&lt;TiXmlDocument *&gt;::iterator it = _pXmlExternalLexerDoc.begin(), end = _pXmlExternalLexerDoc.end(); it != end; ++it )
832  		delete (*it);
833  	_pXmlExternalLexerDoc.clear();
834  }
835  bool NppParameters::reloadStylers(const TCHAR* stylePath)
836  {
837  	delete _pXmlUserStylerDoc;
838  	const TCHAR* stylePathToLoad = stylePath != nullptr ? stylePath : _stylerPath.c_str();
839  	_pXmlUserStylerDoc = new TiXmlDocument(stylePathToLoad);
840  	bool loadOkay = _pXmlUserStylerDoc-&gt;LoadFile();
841  	if (!loadOkay)
842  	{
843  		if (!_pNativeLangSpeaker)
844  		{
845  			::MessageBox(NULL, stylePathToLoad, TEXT(&quot;Load stylers.xml failed&quot;), MB_OK);
846  		}
847  		else
848  		{
849  			_pNativeLangSpeaker-&gt;messageBox(&quot;LoadStylersFailed&quot;,
850  				NULL,
851  				TEXT(&quot;Load \&quot;$STR_REPLACE$\&quot; failed!&quot;),
852  				TEXT(&quot;Load stylers.xml failed&quot;),
853  				MB_OK,
854  				0,
855  				stylePathToLoad);
856  		}
857  		delete _pXmlUserStylerDoc;
858  		_pXmlUserStylerDoc = NULL;
859  		return false;
860  	}
861  	_lexerStylerVect.clear();
862  	_widgetStyleArray.clear();
863  	getUserStylersFromXmlTree();
864  	for ( size_t i = 0; i &lt; getExternalLexerDoc()-&gt;size(); ++i)
865  	{
866  		getExternalLexerFromXmlTree( getExternalLexerDoc()-&gt;at(i) );
867  	}
868  	return true;
869  }
870  bool NppParameters::reloadLang()
871  {
872  	generic_string nativeLangPath(_localizationSwitcher._nativeLangPath);
873  	if (!PathFileExists(nativeLangPath.c_str()))
874  	{
875  		nativeLangPath = _nppPath;
876  		pathAppend(nativeLangPath, generic_string(TEXT(&quot;nativeLang.xml&quot;)));
877  		if (!PathFileExists(nativeLangPath.c_str()))
878  			return false;
879  	}
880  	delete _pXmlNativeLangDocA;
881  	_pXmlNativeLangDocA = new TiXmlDocumentA();
882  	bool loadOkay = _pXmlNativeLangDocA-&gt;LoadUnicodeFilePath(nativeLangPath.c_str());
883  	if (!loadOkay)
884  	{
885  		delete _pXmlNativeLangDocA;
886  		_pXmlNativeLangDocA = nullptr;
887  		return false;
888  	}
889  	return loadOkay;
890  }
891  generic_string NppParameters::getSpecialFolderLocation(int folderKind)
892  {
893  	TCHAR path[MAX_PATH];
894  	const HRESULT specialLocationResult = SHGetFolderPath(nullptr, folderKind, nullptr, SHGFP_TYPE_CURRENT, path);
895  	generic_string result;
896  	if (SUCCEEDED(specialLocationResult))
897  	{
898  		result = path;
899  	}
900  	return result;
901  }
902  generic_string NppParameters::getSettingsFolder()
903  {
904  	if (_isLocal)
905  		return _nppPath;
906  	generic_string settingsFolderPath = getSpecialFolderLocation(CSIDL_APPDATA);
907  	if (settingsFolderPath.empty())
908  		return _nppPath;
909  	pathAppend(settingsFolderPath, TEXT(&quot;Notepad++&quot;));
910  	return settingsFolderPath;
911  }
912  bool NppParameters::load()
913  {
914  	L_END = L_EXTERNAL;
915  	bool isAllLaoded = true;
916  	_isx64 = sizeof(void *) == 8;
917  	generic_string localConfPath(_nppPath);
918  	pathAppend(localConfPath, localConfFile);
919  	_isLocal = (PathFileExists(localConfPath.c_str()) == TRUE);
920  	if (_isLocal)
921  	{
922  		if (_winVersion &gt;= WV_VISTA)
923  		{
924  			generic_string progPath = getSpecialFolderLocation(CSIDL_PROGRAM_FILES);
925  			TCHAR nppDirLocation[MAX_PATH];
926  			wcscpy_s(nppDirLocation, _nppPath.c_str());
927  			::PathRemoveFileSpec(nppDirLocation);
928  			if  (progPath == nppDirLocation)
929  				_isLocal = false;
930  		}
931  	}
932  	_pluginRootDir = _nppPath;
933  	pathAppend(_pluginRootDir, TEXT(&quot;plugins&quot;));
934  	generic_string nppPluginRootParent;
935  	if (_isLocal)
936  	{
937  		_userPath = nppPluginRootParent = _nppPath;
938  		_userPluginConfDir = _pluginRootDir;
939  		pathAppend(_userPluginConfDir, TEXT(&quot;Config&quot;));
940  	}
941  	else
942  	{
943  		_userPath = getSpecialFolderLocation(CSIDL_APPDATA);
944  		pathAppend(_userPath, TEXT(&quot;Notepad++&quot;));
945  		if (!PathFileExists(_userPath.c_str()))
946  			::CreateDirectory(_userPath.c_str(), NULL);
947  		_appdataNppDir = _userPluginConfDir = _userPath;
948  		pathAppend(_userPluginConfDir, TEXT(&quot;plugins&quot;));
949  		if (!PathFileExists(_userPluginConfDir.c_str()))
950  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
951  		pathAppend(_userPluginConfDir, TEXT(&quot;Config&quot;));
952  		if (!PathFileExists(_userPluginConfDir.c_str()))
953  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
954  		setElevationRequired(true);
955  	}
956  	_pluginConfDir = _pluginRootDir; 
957  	pathAppend(_pluginConfDir, TEXT(&quot;Config&quot;));
958  	if (!PathFileExists(nppPluginRootParent.c_str()))
959  		::CreateDirectory(nppPluginRootParent.c_str(), NULL);
960  	if (!PathFileExists(_pluginRootDir.c_str()))
961  		::CreateDirectory(_pluginRootDir.c_str(), NULL);
962  	_sessionPath = _userPath; 
963  	generic_string cloudChoicePath{_userPath};
964  	cloudChoicePath += TEXT(&quot;\\cloud\\choice&quot;);
965  	_isCloud = (::PathFileExists(cloudChoicePath.c_str()) == TRUE);
966  	if (_isCloud)
967  	{
968  		std::string cloudChoiceStr = getFileContent(cloudChoicePath.c_str());
969  		WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
970  		std::wstring cloudChoiceStrW = wmc.char2wchar(cloudChoiceStr.c_str(), SC_CP_UTF8);
971  		if (!cloudChoiceStrW.empty() &amp;&amp; ::PathFileExists(cloudChoiceStrW.c_str()))
972  		{
973  			_userPath = cloudChoiceStrW;
974  			_nppGUI._cloudPath = cloudChoiceStrW;
975  			_initialCloudChoice = _nppGUI._cloudPath;
976  		}
977  		else
978  		{
979  			_isCloud = false;
980  		}
981  	}
982  	if (!_cmdSettingsDir.empty())
983  	{
984  		if (!::PathIsDirectory(_cmdSettingsDir.c_str()))
985  		{
986  			generic_string errMsg = TEXT(&quot;The given path\r&quot;);
987  			errMsg += _cmdSettingsDir;
988  			errMsg += TEXT(&quot;\nvia command line \&quot;-settingsDir=\&quot; is not a valid directory.\rThis argument will be ignored.&quot;);
989  			::MessageBox(NULL, errMsg.c_str(), TEXT(&quot;Invalid directory&quot;), MB_OK);
990  		}
991  		else
992  		{
993  			_userPath = _cmdSettingsDir;
994  			_sessionPath = _userPath; 
995  		}
996  	}
997  	generic_string langs_xml_path(_userPath);
998  	pathAppend(langs_xml_path, TEXT(&quot;langs.xml&quot;));
999  	BOOL doRecover = FALSE;
1000  	if (::PathFileExists(langs_xml_path.c_str()))
1001  	{
1002  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
1003  		if (GetFileAttributesEx(langs_xml_path.c_str(), GetFileExInfoStandard, &amp;attributes) != 0)
1004  		{
1005  			if (attributes.nFileSizeLow == 0 &amp;&amp; attributes.nFileSizeHigh == 0)
1006  			{
1007  				if (_pNativeLangSpeaker)
1008  				{
1009  					doRecover = _pNativeLangSpeaker-&gt;messageBox(&quot;LoadLangsFailed&quot;,
1010  						NULL,
1011  						TEXT(&quot;Load langs.xml failed!\rDo you want to recover your langs.xml?&quot;),
1012  						TEXT(&quot;Configurator&quot;),
1013  						MB_YESNO);
1014  				}
1015  				else
1016  				{
1017  					doRecover = ::MessageBox(NULL, TEXT(&quot;Load langs.xml failed!\rDo you want to recover your langs.xml?&quot;), TEXT(&quot;Configurator&quot;), MB_YESNO);
1018  				}
1019  			}
1020  		}
1021  	}
1022  	else
1023  		doRecover = true;
1024  	if (doRecover)
1025  	{
1026  		generic_string srcLangsPath(_nppPath);
1027  		pathAppend(srcLangsPath, TEXT(&quot;langs.model.xml&quot;));
1028  		::CopyFile(srcLangsPath.c_str(), langs_xml_path.c_str(), FALSE);
1029  	}
1030  	_pXmlDoc = new TiXmlDocument(langs_xml_path);
1031  	bool loadOkay = _pXmlDoc-&gt;LoadFile();
1032  	if (!loadOkay)
1033  	{
1034  		if (_pNativeLangSpeaker)
1035  		{
1036  			_pNativeLangSpeaker-&gt;messageBox(&quot;LoadLangsFailedFinal&quot;,
1037  				NULL,
1038  				TEXT(&quot;Load langs.xml failed!&quot;),
1039  				TEXT(&quot;Configurator&quot;),
1040  				MB_OK);
1041  		}
1042  		else
1043  		{
1044  			::MessageBox(NULL, TEXT(&quot;Load langs.xml failed!&quot;), TEXT(&quot;Configurator&quot;), MB_OK);
1045  		}
1046  		delete _pXmlDoc;
1047  		_pXmlDoc = nullptr;
1048  		isAllLaoded = false;
1049  	}
1050  	else
1051  		getLangKeywordsFromXmlTree();
1052  	generic_string configPath(_userPath);
1053  	pathAppend(configPath, TEXT(&quot;config.xml&quot;));
1054  	generic_string srcConfigPath(_nppPath);
1055  	pathAppend(srcConfigPath, TEXT(&quot;config.model.xml&quot;));
1056  	if (!::PathFileExists(configPath.c_str()))
1057  		::CopyFile(srcConfigPath.c_str(), configPath.c_str(), FALSE);
1058  	_pXmlUserDoc = new TiXmlDocument(configPath);
1059  	loadOkay = _pXmlUserDoc-&gt;LoadFile();
1060  	if (!loadOkay)
1061  	{
1062  		TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(&quot;1.0&quot;), TEXT(&quot;UTF-8&quot;), TEXT(&quot;&quot;));
1063  		_pXmlUserDoc-&gt;LinkEndChild(decl);
1064  	}
1065  	else
1066  	{
1067  		getUserParametersFromXmlTree();
1068  	}
1069  	_stylerPath = _userPath;
1070  	pathAppend(_stylerPath, TEXT(&quot;stylers.xml&quot;));
1071  	if (!PathFileExists(_stylerPath.c_str()))
1072  	{
1073  		generic_string srcStylersPath(_nppPath);
1074  		pathAppend(srcStylersPath, TEXT(&quot;stylers.model.xml&quot;));
1075  		::CopyFile(srcStylersPath.c_str(), _stylerPath.c_str(), TRUE);
1076  	}
1077  	if (_nppGUI._themeName.empty() || (!PathFileExists(_nppGUI._themeName.c_str())))
1078  		_nppGUI._themeName.assign(_stylerPath);
1079  	_pXmlUserStylerDoc = new TiXmlDocument(_nppGUI._themeName.c_str());
1080  	loadOkay = _pXmlUserStylerDoc-&gt;LoadFile();
1081  	if (!loadOkay)
1082  	{
1083  		if (_pNativeLangSpeaker)
1084  		{
1085  			_pNativeLangSpeaker-&gt;messageBox(&quot;LoadStylersFailed&quot;,
1086  				NULL,
1087  				TEXT(&quot;Load \&quot;$STR_REPLACE$\&quot; failed!&quot;),
1088  				TEXT(&quot;Load stylers.xml failed&quot;),
1089  				MB_OK,
1090  				0,
1091  				_stylerPath.c_str());
1092  		}
1093  		else
1094  		{
1095  			::MessageBox(NULL, _stylerPath.c_str(), TEXT(&quot;Load stylers.xml failed&quot;), MB_OK);
1096  		}
1097  		delete _pXmlUserStylerDoc;
1098  		_pXmlUserStylerDoc = NULL;
1099  		isAllLaoded = false;
1100  	}
1101  	else
1102  		getUserStylersFromXmlTree();
1103  	_themeSwitcher._stylesXmlPath = _stylerPath;
1104  	_themeSwitcher.addDefaultThemeFromXml(_stylerPath);
1105  	_userDefineLangsFolderPath = _userDefineLangPath = _userPath;
1106  	pathAppend(_userDefineLangPath, TEXT(&quot;userDefineLang.xml&quot;));
1107  	pathAppend(_userDefineLangsFolderPath, TEXT(&quot;userDefineLangs&quot;));
1108  	std::vector&lt;generic_string&gt; udlFiles;
1109  	getFilesInFolder(udlFiles, TEXT(&quot;*.xml&quot;), _userDefineLangsFolderPath);
1110  	_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
1111  	loadOkay = _pXmlUserLangDoc-&gt;LoadFile();
1112  	if (!loadOkay)
1113  	{
1114  		delete _pXmlUserLangDoc;
1115  		_pXmlUserLangDoc = nullptr;
1116  		isAllLaoded = false;
1117  	}
1118  	else
1119  	{
1120  		auto r = addUserDefineLangsFromXmlTree(_pXmlUserLangDoc);
1121  		if (r.second - r.first &gt; 0)
1122  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(_pXmlUserLangDoc, false, true, r));
1123  	}
1124  	for (const auto&amp; i : udlFiles)
1125  	{
1126  		auto udlDoc = new TiXmlDocument(i);
1127  		loadOkay = udlDoc-&gt;LoadFile();
1128  		if (!loadOkay)
1129  		{
1130  			delete udlDoc;
1131  		}
1132  		else
1133  		{
1134  			auto r = addUserDefineLangsFromXmlTree(udlDoc);
1135  			if (r.second - r.first &gt; 0)
1136  				_pXmlUserLangsDoc.push_back(UdlXmlFileState(udlDoc, false, false, r));
1137  		}
1138  	}
1139  	generic_string nativeLangPath;
1140  	nativeLangPath = _userPath;
1141  	pathAppend(nativeLangPath, TEXT(&quot;nativeLang.xml&quot;));
1142  	_localizationSwitcher._nativeLangPath = nativeLangPath;
1143  	if (!_startWithLocFileName.empty()) 
1144  	{
1145  		nativeLangPath = _nppPath;
1146  		pathAppend(nativeLangPath, TEXT(&quot;localization\\&quot;));
1147  		pathAppend(nativeLangPath, _startWithLocFileName);
1148  	}
1149  	else 
1150  	{
1151  		if (!PathFileExists(nativeLangPath.c_str()))
1152  		{
1153  			nativeLangPath = _nppPath;
1154  			pathAppend(nativeLangPath, TEXT(&quot;nativeLang.xml&quot;));
1155  		}
1156  	}
1157  	_pXmlNativeLangDocA = new TiXmlDocumentA();
1158  	loadOkay = _pXmlNativeLangDocA-&gt;LoadUnicodeFilePath(nativeLangPath.c_str());
1159  	if (!loadOkay)
1160  	{
1161  		delete _pXmlNativeLangDocA;
1162  		_pXmlNativeLangDocA = nullptr;
1163  		isAllLaoded = false;
1164  	}
1165  	generic_string toolbarIconsPath(_userPath);
1166  	pathAppend(toolbarIconsPath, TEXT(&quot;toolbarIcons.xml&quot;));
1167  	_pXmlToolIconsDoc = new TiXmlDocument(toolbarIconsPath);
1168  	loadOkay = _pXmlToolIconsDoc-&gt;LoadFile();
1169  	if (!loadOkay)
1170  	{
1171  		delete _pXmlToolIconsDoc;
1172  		_pXmlToolIconsDoc = nullptr;
1173  		isAllLaoded = false;
1174  	}
1175  	wstring v852NoNeedShortcutsBackup;
1176  	_shortcutsPath = v852NoNeedShortcutsBackup = _userPath;
1177  	pathAppend(_shortcutsPath, SHORTCUTSXML_FILENAME);
1178  	pathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
1179  	if (!PathFileExists(_shortcutsPath.c_str()))
1180  	{
1181  		generic_string srcShortcutsPath(_nppPath);
1182  		pathAppend(srcShortcutsPath, SHORTCUTSXML_FILENAME);
1183  		::CopyFile(srcShortcutsPath.c_str(), _shortcutsPath.c_str(), TRUE);
1184  		HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
1185  		::FlushFileBuffers(hFile);
1186  		::CloseHandle(hFile);
1187  	}
1188  	_pXmlShortcutDocA = new TiXmlDocumentA();
1189  	loadOkay = _pXmlShortcutDocA-&gt;LoadUnicodeFilePath(_shortcutsPath.c_str());
1190  	if (!loadOkay)
1191  	{
1192  		delete _pXmlShortcutDocA;
1193  		_pXmlShortcutDocA = nullptr;
1194  		isAllLaoded = false;
1195  	}
1196  	else
1197  	{
1198  		getShortcutsFromXmlTree();
1199  		getMacrosFromXmlTree();
1200  		getUserCmdsFromXmlTree();
1201  		getScintKeysFromXmlTree();
1202  	}
1203  	_contextMenuPath = _userPath;
1204  	pathAppend(_contextMenuPath, TEXT(&quot;contextMenu.xml&quot;));
1205  	if (!PathFileExists(_contextMenuPath.c_str()))
1206  	{
1207  		generic_string srcContextMenuPath(_nppPath);
1208  		pathAppend(srcContextMenuPath, TEXT(&quot;contextMenu.xml&quot;));
1209  		::CopyFile(srcContextMenuPath.c_str(), _contextMenuPath.c_str(), TRUE);
1210  	}
1211  	_pXmlContextMenuDocA = new TiXmlDocumentA();
1212  	loadOkay = _pXmlContextMenuDocA-&gt;LoadUnicodeFilePath(_contextMenuPath.c_str());
1213  	if (!loadOkay)
1214  	{
1215  		delete _pXmlContextMenuDocA;
1216  		_pXmlContextMenuDocA = nullptr;
1217  		isAllLaoded = false;
1218  	}
1219  	_tabContextMenuPath = _userPath;
1220  	pathAppend(_tabContextMenuPath, TEXT(&quot;tabContextMenu.xml&quot;));
1221  	_pXmlTabContextMenuDocA = new TiXmlDocumentA();
1222  	loadOkay = _pXmlTabContextMenuDocA-&gt;LoadUnicodeFilePath(_tabContextMenuPath.c_str());
1223  	if (!loadOkay)
1224  	{
1225  		delete _pXmlTabContextMenuDocA;
1226  		_pXmlTabContextMenuDocA = nullptr;
1227  	}
1228  	pathAppend(_sessionPath, TEXT(&quot;session.xml&quot;));
1229  	const NppGUI &amp; nppGUI = (NppParameters::getInstance()).getNppGUI();
1230  	if (nppGUI._rememberLastSession)
1231  	{
1232  		TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(_sessionPath);
1233  		loadOkay = pXmlSessionDoc-&gt;LoadFile();
1234  		if (!loadOkay)
1235  			isAllLaoded = false;
1236  		else
1237  			getSessionFromXmlTree(pXmlSessionDoc, _session);
1238  		delete pXmlSessionDoc;
1239  		for (size_t i = 0, len = _pXmlExternalLexerDoc.size() ; i &lt; len ; ++i)
1240  			if (_pXmlExternalLexerDoc[i])
1241  				delete _pXmlExternalLexerDoc[i];
1242  	}
1243  	generic_string enableSelectFgColorPath = _userPath;
1244  	pathAppend(enableSelectFgColorPath, TEXT(&quot;enableSelectFgColor.xml&quot;));
1245  	if (PathFileExists(enableSelectFgColorPath.c_str()))
1246  	{
1247  		_isSelectFgColorEnabled = true;
1248  	}
1249  	generic_string filePath, filePath2, issueFileName;
1250  	filePath = _nppPath;
1251  	issueFileName = nppLogNetworkDriveIssue;
1252  	issueFileName += TEXT(&quot;.xml&quot;);
1253  	pathAppend(filePath, issueFileName);
1254  	_doNppLogNetworkDriveIssue = (PathFileExists(filePath.c_str()) == TRUE);
1255  	if (!_doNppLogNetworkDriveIssue)
1256  	{
1257  		filePath2 = _userPath;
1258  		pathAppend(filePath2, issueFileName);
1259  		_doNppLogNetworkDriveIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1260  	}
1261  	filePath = _nppPath;
1262  	issueFileName = nppLogNulContentCorruptionIssue;
1263  	issueFileName += TEXT(&quot;.xml&quot;);
1264  	pathAppend(filePath, issueFileName);
1265  	_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath.c_str()) == TRUE);
1266  	if (!_doNppLogNulContentCorruptionIssue)
1267  	{
1268  		filePath2 = _userPath;
1269  		pathAppend(filePath2, issueFileName);
1270  		_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1271  	}
1272  	return isAllLaoded;
1273  }
1274  void NppParameters::destroyInstance()
1275  {
1276  	delete _pXmlDoc;
1277  	delete _pXmlUserDoc;
1278  	delete _pXmlUserStylerDoc;
1279  	for (auto&amp; l : _pXmlUserLangsDoc)
1280  	{
1281  		delete l._udlXmlDoc;
1282  	}
1283  	delete _pXmlNativeLangDocA;
1284  	delete _pXmlToolIconsDoc;
1285  	delete _pXmlShortcutDocA;
1286  	delete _pXmlContextMenuDocA;
1287  	delete _pXmlTabContextMenuDocA;
1288  	delete 	getInstancePointer();
1289  }
1290  void NppParameters::saveConfig_xml()
1291  {
1292  	if (_pXmlUserDoc)
1293  		_pXmlUserDoc-&gt;SaveFile();
1294  }
1295  void NppParameters::setWorkSpaceFilePath(int i, const TCHAR* wsFile)
1296  {
1297  	if (i &lt; 0 || i &gt; 2 || !wsFile)
1298  		return;
1299  	_workSpaceFilePathes[i] = wsFile;
1300  }
1301  void NppParameters::removeTransparent(HWND hwnd)
1302  {
1303  	if (hwnd != nullptr)
1304  		::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) &amp; ~WS_EX_LAYERED);
1305  }
1306  void NppParameters::SetTransparent(HWND hwnd, int percent)
1307  {
1308  	::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);
1309  	if (percent &gt; 255)
1310  		percent = 255;
1311  	else if (percent &lt; 0)
1312  		percent = 0;
1313  	::SetLayeredWindowAttributes(hwnd, 0, static_cast&lt;BYTE&gt;(percent), LWA_ALPHA);
1314  }
1315  bool NppParameters::isExistingExternalLangName(const char* newName) const
1316  {
1317  	if ((!newName) || (!newName[0]))
1318  		return true;
1319  	for (int i = 0 ; i &lt; _nbExternalLang ; ++i)
1320  	{
1321  		if (_externalLangArray[i]-&gt;_name == newName)
1322  			return true;
1323  	}
1324  	return false;
1325  }
1326  const TCHAR* NppParameters::getUserDefinedLangNameFromExt(TCHAR *ext, TCHAR *fullName) const
1327  {
1328  	if ((!ext) || (!ext[0]))
1329  		return nullptr;
1330  	std::vector&lt;generic_string&gt; extVect;
1331  	int iMatched = -1;
1332  	for (int i = 0 ; i &lt; _nbUserLang ; ++i)
1333  	{
1334  		extVect.clear();
1335  		cutString(_userLangArray[i]-&gt;_ext.c_str(), extVect);
1336  		for (size_t j = 0, len = extVect.size(); j &lt; len; ++j)
1337  		{
1338  			if (!wcsicmp(extVect[j].c_str(), ext) || (wcschr(fullName, &#x27;.&#x27;) &amp;&amp; !wcsicmp(extVect[j].c_str(), fullName)))
1339  			{
1340  				iMatched = i;
1341  				if (((NppDarkMode::isEnabled() &amp;&amp; _userLangArray[i]-&gt;_isDarkModeTheme)) ||
1342  					((!NppDarkMode::isEnabled() &amp;&amp; !_userLangArray[i]-&gt;_isDarkModeTheme)))
1343  					return _userLangArray[i]-&gt;_name.c_str();
1344  			}
1345  		}
1346  	}
1347  	if (iMatched &gt;= 0)
1348  	{
1349  		return _userLangArray[iMatched]-&gt;_name.c_str();
1350  	}
1351  	return nullptr;
1352  }
1353  int NppParameters::getExternalLangIndexFromName(const TCHAR* externalLangName) const
1354  {
1355  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1356  	for (int i = 0 ; i &lt; _nbExternalLang ; ++i)
1357  	{
1358  		if (!lstrcmp(externalLangName, wmc.char2wchar(_externalLangArray[i]-&gt;_name.c_str(), CP_ACP)))
1359  			return i;
1360  	}
1361  	return -1;
1362  }
1363  UserLangContainer* NppParameters::getULCFromName(const TCHAR *userLangName)
1364  {
1365  	for (int i = 0 ; i &lt; _nbUserLang ; ++i)
1366  	{
1367  		if (0 == lstrcmp(userLangName, _userLangArray[i]-&gt;_name.c_str()))
1368  			return _userLangArray[i];
1369  	}
1370  	return nullptr;
1371  }
1372  COLORREF NppParameters::getCurLineHilitingColour()
1373  {
1374  	const Style * pStyle = _widgetStyleArray.findByName(TEXT(&quot;Current line background colour&quot;));
1375  	if (!pStyle)
1376  		return COLORREF(-1);
1377  	return pStyle-&gt;_bgColor;
1378  }
1379  void NppParameters::setCurLineHilitingColour(COLORREF colour2Set)
1380  {
1381  	Style * pStyle = _widgetStyleArray.findByName(TEXT(&quot;Current line background colour&quot;));
1382  	if (!pStyle)
1383  		return;
1384  	pStyle-&gt;_bgColor = colour2Set;
1385  }
1386  static int CALLBACK EnumFontFamExProc(const LOGFONT* lpelfe, const TEXTMETRIC*, DWORD, LPARAM lParam)
1387  {
1388  	std::vector&lt;generic_string&gt;&amp; strVect = *(std::vector&lt;generic_string&gt; *)lParam;
1389  	const int32_t vectSize = static_cast&lt;int32_t&gt;(strVect.size());
1390  	const TCHAR* lfFaceName = ((ENUMLOGFONTEX*)lpelfe)-&gt;elfLogFont.lfFaceName;
1391  	for (int i = vectSize - 1 ; i &gt;= 0 ; i--)
1392  	{
1393  		if (0 == lstrcmp(strVect[i].c_str(), lfFaceName))
1394  			return 1;	
1395  	}
1396  	strVect.push_back(lfFaceName);
1397  	return 1; 
1398  }
1399  void NppParameters::setFontList(HWND hWnd)
1400  {
1401  	LOGFONT lf{};
1402  	_fontlist.clear();
1403  	_fontlist.reserve(64); 
1404  	_fontlist.push_back(generic_string());
1405  	lf.lfCharSet = DEFAULT_CHARSET;
1406  	lf.lfFaceName[0]=&#x27;\0&#x27;;
1407  	lf.lfPitchAndFamily = 0;
1408  	HDC hDC = ::GetDC(hWnd);
1409  	::EnumFontFamiliesEx(hDC, &amp;lf, EnumFontFamExProc, reinterpret_cast&lt;LPARAM&gt;(&amp;_fontlist), 0);
1410  }
1411  bool NppParameters::isInFontList(const generic_string&amp; fontName2Search) const
1412  {
1413  	if (fontName2Search.empty())
1414  		return false;
1415  	for (size_t i = 0, len = _fontlist.size(); i &lt; len; i++)
1416  	{
1417  		if (_fontlist[i] == fontName2Search)
1418  			return true;
1419  	}
1420  	return false;
1421  }
1422  LOGFONT NppParameters::getDefaultGUIFont(DefaultFontType type)
1423  {
1424  	LOGFONT lf{};
1425  	NONCLIENTMETRICS ncm{};
1426  	ncm.cbSize = sizeof(NONCLIENTMETRICS);
1427  	if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &amp;ncm, 0) != FALSE)
1428  	{
1429  		switch (type)
1430  		{
1431  			case DefaultFontType::menu:
1432  			{
1433  				lf = ncm.lfMenuFont;
1434  				break;
1435  			}
1436  			case DefaultFontType::status:
1437  			{
1438  				lf = ncm.lfStatusFont;
1439  				break;
1440  			}
1441  			case DefaultFontType::caption:
1442  			{
1443  				lf = ncm.lfCaptionFont;
1444  				break;
1445  			}
1446  			case DefaultFontType::smcaption:
1447  			{
1448  				lf = ncm.lfSmCaptionFont;
1449  				break;
1450  			}
1451  			default:
1452  			{
1453  				lf = ncm.lfMessageFont;
1454  				break;
1455  			}
1456  		}
1457  	}
1458  	else 
1459  	{
1460  		auto hf = static_cast&lt;HFONT&gt;(::GetStockObject(DEFAULT_GUI_FONT));
1461  		::GetObject(hf, sizeof(LOGFONT), &amp;lf);
1462  	}
1463  	return lf;
1464  }
1465  void NppParameters::getLangKeywordsFromXmlTree()
1466  {
1467  	TiXmlNode *root =
1468  		_pXmlDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1469  		if (!root) return;
1470  	feedKeyWordsParameters(root);
1471  }
1472  void NppParameters::getExternalLexerFromXmlTree(TiXmlDocument* externalLexerDoc)
1473  {
1474  	TiXmlNode *root = externalLexerDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1475  		if (!root) return;
1476  	feedKeyWordsParameters(root);
1477  	feedStylerArray(root);
1478  }
1479  int NppParameters::addExternalLangToEnd(ExternalLangContainer * externalLang)
1480  {
1481  	_externalLangArray[_nbExternalLang] = externalLang;
1482  	++_nbExternalLang;
1483  	++L_END;
1484  	return _nbExternalLang-1;
1485  }
1486  bool NppParameters::getUserStylersFromXmlTree()
1487  {
1488  	TiXmlNode *root = _pXmlUserStylerDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1489  		if (!root) return false;
1490  	return feedStylerArray(root);
1491  }
1492  bool NppParameters::getUserParametersFromXmlTree()
1493  {
1494  	if (!_pXmlUserDoc)
1495  		return false;
1496  	TiXmlNode *root = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1497  	if (!root)
1498  		return false;
1499  	feedGUIParameters(root);
1500  	feedFileListParameters(root);
1501  	TiXmlNode *node = root-&gt;FirstChildElement(TEXT(&quot;History&quot;));
1502  	root-&gt;RemoveChild(node);
1503  	TiXmlElement HistoryNode(TEXT(&quot;History&quot;));
1504  	root-&gt;InsertEndChild(HistoryNode);
1505  	feedFindHistoryParameters(root);
1506  	feedProjectPanelsParameters(root);
1507  	feedFileBrowserParameters(root);
1508  	feedColumnEditorParameters(root);
1509  	return true;
1510  }
1511  std::pair&lt;unsigned char, unsigned char&gt; NppParameters::addUserDefineLangsFromXmlTree(TiXmlDocument *tixmldoc)
1512  {
1513  	if (!tixmldoc)
1514  		return std::make_pair(static_cast&lt;unsigned char&gt;(0), static_cast&lt;unsigned char&gt;(0));
1515  	TiXmlNode *root = tixmldoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1516  	if (!root)
1517  		return std::make_pair(static_cast&lt;unsigned char&gt;(0), static_cast&lt;unsigned char&gt;(0));
1518  	return feedUserLang(root);
1519  }
1520  bool NppParameters::getShortcutsFromXmlTree()
1521  {
1522  	if (!_pXmlShortcutDocA)
1523  		return false;
1524  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1525  	if (!root)
1526  		return false;
1527  	feedShortcut(root);
1528  	return true;
1529  }
1530  bool NppParameters::getMacrosFromXmlTree()
1531  {
1532  	if (!_pXmlShortcutDocA)
1533  		return false;
1534  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1535  	if (!root)
1536  		return false;
1537  	feedMacros(root);
1538  	return true;
1539  }
1540  bool NppParameters::getUserCmdsFromXmlTree()
1541  {
1542  	if (!_pXmlShortcutDocA)
1543  		return false;
1544  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1545  	if (!root)
1546  		return false;
1547  	feedUserCmds(root);
1548  	return true;
1549  }
1550  bool NppParameters::getPluginCmdsFromXmlTree()
1551  {
1552  	if (!_pXmlShortcutDocA)
1553  		return false;
1554  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1555  	if (!root)
1556  		return false;
1557  	feedPluginCustomizedCmds(root);
1558  	return true;
1559  }
1560  bool NppParameters::getScintKeysFromXmlTree()
1561  {
1562  	if (!_pXmlShortcutDocA)
1563  		return false;
1564  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1565  	if (!root)
1566  		return false;
1567  	feedScintKeys(root);
1568  	return true;
1569  }
1570  void NppParameters::initMenuKeys()
1571  {
1572  	int nbCommands = sizeof(winKeyDefs)/sizeof(WinMenuKeyDefinition);
1573  	WinMenuKeyDefinition wkd;
1574  	for (int i = 0; i &lt; nbCommands; ++i)
1575  	{
1576  		wkd = winKeyDefs[i];
1577  		Shortcut sc((wkd.specialName ? wstring2string(wkd.specialName, CP_UTF8).c_str() : &quot;&quot;), wkd.isCtrl, wkd.isAlt, wkd.isShift, static_cast&lt;unsigned char&gt;(wkd.vKey));
1578  		_shortcuts.push_back( CommandShortcut(sc, wkd.functionId) );
1579  	}
1580  }
1581  void NppParameters::initScintillaKeys()
1582  {
1583  	int nbCommands = sizeof(scintKeyDefs)/sizeof(ScintillaKeyDefinition);
1584  	ScintillaKeyDefinition skd;
1585  	int prevIndex = -1;
1586  	int prevID = -1;
1587  	for (int i = 0; i &lt; nbCommands; ++i)
1588  	{
1589  		skd = scintKeyDefs[i];
1590  		if (skd.functionId == prevID)
1591  		{
1592  			KeyCombo kc;
1593  			kc._isCtrl = skd.isCtrl;
1594  			kc._isAlt = skd.isAlt;
1595  			kc._isShift = skd.isShift;
1596  			kc._key = static_cast&lt;unsigned char&gt;(skd.vKey);
1597  			_scintillaKeyCommands[prevIndex].addKeyCombo(kc);
1598  		}
1599  		else
1600  		{
1601  			Shortcut s = Shortcut(wstring2string(skd.name, CP_UTF8).c_str(), skd.isCtrl, skd.isAlt, skd.isShift, static_cast&lt;unsigned char&gt;(skd.vKey));
1602  			ScintillaKeyMap sm = ScintillaKeyMap(s, skd.functionId, skd.redirFunctionId);
1603  			_scintillaKeyCommands.push_back(sm);
1604  			++prevIndex;
1605  		}
1606  		prevID = skd.functionId;
1607  	}
1608  }
1609  bool NppParameters::reloadContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu)
1610  {
1611  	_contextMenuItems.clear();
1612  	return getContextMenuFromXmlTree(mainMenuHadle, pluginsMenu);
1613  }
1614  int NppParameters::getCmdIdFromMenuEntryItemName(HMENU mainMenuHadle, const generic_string&amp; menuEntryName, const generic_string&amp; menuItemName)
1615  {
1616  	int nbMenuEntry = ::GetMenuItemCount(mainMenuHadle);
1617  	for (int i = 0; i &lt; nbMenuEntry; ++i)
1618  	{
1619  		TCHAR menuEntryString[menuItemStrLenMax];
1620  		::GetMenuString(mainMenuHadle, i, menuEntryString, menuItemStrLenMax, MF_BYPOSITION);
1621  		if (wcsicmp(menuEntryName.c_str(), purgeMenuItemString(menuEntryString).c_str()) == 0)
1622  		{
1623  			vector&lt; pair&lt;HMENU, int&gt; &gt; parentMenuPos;
1624  			HMENU topMenu = ::GetSubMenu(mainMenuHadle, i);
1625  			int maxTopMenuPos = ::GetMenuItemCount(topMenu);
1626  			HMENU currMenu = topMenu;
1627  			int currMaxMenuPos = maxTopMenuPos;
1628  			int currMenuPos = 0;
1629  			bool notFound = false;
1630  			do {
1631  				if (::GetSubMenu(currMenu, currMenuPos))
1632  				{
1633  					parentMenuPos.push_back(::make_pair(currMenu, currMenuPos));
1634  					currMenu = ::GetSubMenu(currMenu, currMenuPos);
1635  					currMenuPos = 0;
1636  					currMaxMenuPos = ::GetMenuItemCount(currMenu);
1637  				}
1638  				else
1639  				{
1640  					TCHAR cmdStr[menuItemStrLenMax];
1641  					::GetMenuString(currMenu, currMenuPos, cmdStr, menuItemStrLenMax, MF_BYPOSITION);
1642  					if (wcsicmp(menuItemName.c_str(), purgeMenuItemString(cmdStr).c_str()) == 0)
1643  					{
1644  						return ::GetMenuItemID(currMenu, currMenuPos);
1645  					}
1646  					if ((currMenuPos &gt;= currMaxMenuPos) &amp;&amp; (parentMenuPos.size() &gt; 0))
1647  					{
1648  						currMenu = parentMenuPos.back().first;
1649  						currMenuPos = parentMenuPos.back().second;
1650  						parentMenuPos.pop_back();
1651  						currMaxMenuPos = ::GetMenuItemCount(currMenu);
1652  					}
1653  					if ((currMenu == topMenu) &amp;&amp; (currMenuPos &gt;= maxTopMenuPos))
1654  					{
1655  						notFound = true;
1656  					}
1657  					else
1658  					{
1659  						++currMenuPos;
1660  					}
1661  				}
1662  			} while (!notFound);
1663  		}
1664  	}
1665  	return -1;
1666  }
1667  int NppParameters::getPluginCmdIdFromMenuEntryItemName(HMENU pluginsMenu, const generic_string&amp; pluginName, const generic_string&amp; pluginCmdName)
1668  {
1669  	int nbPlugins = ::GetMenuItemCount(pluginsMenu);
1670  	for (int i = 0; i &lt; nbPlugins; ++i)
1671  	{
1672  		TCHAR menuItemString[menuItemStrLenMax];
1673  		::GetMenuString(pluginsMenu, i, menuItemString, menuItemStrLenMax, MF_BYPOSITION);
1674  		if (wcsicmp(pluginName.c_str(), purgeMenuItemString(menuItemString).c_str()) == 0)
1675  		{
1676  			HMENU pluginMenu = ::GetSubMenu(pluginsMenu, i);
1677  			int nbPluginCmd = ::GetMenuItemCount(pluginMenu);
1678  			for (int j = 0; j &lt; nbPluginCmd; ++j)
1679  			{
1680  				TCHAR pluginCmdStr[menuItemStrLenMax];
1681  				::GetMenuString(pluginMenu, j, pluginCmdStr, menuItemStrLenMax, MF_BYPOSITION);
1682  				if (wcsicmp(pluginCmdName.c_str(), purgeMenuItemString(pluginCmdStr).c_str()) == 0)
1683  				{
1684  					return ::GetMenuItemID(pluginMenu, j);
1685  				}
1686  			}
1687  		}
1688  	}
1689  	return -1;
1690  }
1691  bool NppParameters::getContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu, bool isEditCM)
1692  {
1693  	std::vector&lt;MenuItemUnit&gt;&amp; contextMenuItems = isEditCM ? _contextMenuItems : _tabContextMenuItems;
1694  	TiXmlDocumentA* pXmlContextMenuDocA = isEditCM ? _pXmlContextMenuDocA : _pXmlTabContextMenuDocA;
1695  	std::string cmName = isEditCM ? &quot;ScintillaContextMenu&quot; : &quot;TabContextMenu&quot;;
1696  	if (!pXmlContextMenuDocA)
1697  		return false;
1698  	TiXmlNodeA *root = pXmlContextMenuDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1699  	if (!root)
1700  		return false;
1701  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1702  	NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
1703  	TiXmlNodeA *contextMenuRoot = root-&gt;FirstChildElement(cmName.c_str());
1704  	if (contextMenuRoot)
1705  	{
1706  		for (TiXmlNodeA *childNode = contextMenuRoot-&gt;FirstChildElement(&quot;Item&quot;);
1707  			childNode ;
1708  			childNode = childNode-&gt;NextSibling(&quot;Item&quot;) )
1709  		{
1710  			const char *folderNameDefaultA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;FolderName&quot;);
1711  			const char *folderNameTranslateID_A = (childNode-&gt;ToElement())-&gt;Attribute(&quot;TranslateID&quot;);
1712  			const char *displayAsA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;ItemNameAs&quot;);
1713  			generic_string folderName;
1714  			generic_string displayAs;
1715  			folderName = folderNameDefaultA ? wmc.char2wchar(folderNameDefaultA, SC_CP_UTF8) : TEXT(&quot;&quot;);
1716  			displayAs = displayAsA ? wmc.char2wchar(displayAsA, SC_CP_UTF8) : TEXT(&quot;&quot;);
1717  			if (folderNameTranslateID_A)
1718  			{
1719  				folderName = pNativeSpeaker-&gt;getLocalizedStrFromID(folderNameTranslateID_A, folderName);
1720  			}
1721  			int id;
1722  			const char *idStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;id&quot;, &amp;id);
1723  			if (idStr)
1724  			{
1725  				contextMenuItems.push_back(MenuItemUnit(id, displayAs.c_str(), folderName.c_str()));
1726  			}
1727  			else
1728  			{
1729  				const char *menuEntryNameA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;MenuEntryName&quot;);
1730  				const char *menuItemNameA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;MenuItemName&quot;);
1731  				generic_string menuEntryName;
1732  				generic_string menuItemName;
1733  				menuEntryName = menuEntryNameA?wmc.char2wchar(menuEntryNameA, SC_CP_UTF8):TEXT(&quot;&quot;);
1734  				menuItemName = menuItemNameA?wmc.char2wchar(menuItemNameA, SC_CP_UTF8):TEXT(&quot;&quot;);
1735  				if (!menuEntryName.empty() &amp;&amp; !menuItemName.empty())
1736  				{
1737  					int cmd = getCmdIdFromMenuEntryItemName(mainMenuHadle, menuEntryName, menuItemName);
1738  					if (cmd != -1)
1739  						contextMenuItems.push_back(MenuItemUnit(cmd, displayAs.c_str(), folderName.c_str()));
1740  				}
1741  				else
1742  				{
1743  					const char *pluginNameA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;PluginEntryName&quot;);
1744  					const char *pluginCmdNameA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;PluginCommandItemName&quot;);
1745  					generic_string pluginName;
1746  					generic_string pluginCmdName;
1747  					pluginName = pluginNameA?wmc.char2wchar(pluginNameA, SC_CP_UTF8):TEXT(&quot;&quot;);
1748  					pluginCmdName = pluginCmdNameA?wmc.char2wchar(pluginCmdNameA, SC_CP_UTF8):TEXT(&quot;&quot;);
1749  					if (pluginsMenu &amp;&amp; !pluginName.empty() &amp;&amp; !pluginCmdName.empty())
1750  					{
1751  						int pluginCmdId = getPluginCmdIdFromMenuEntryItemName(pluginsMenu, pluginName, pluginCmdName);
1752  						if (pluginCmdId != -1)
1753  							contextMenuItems.push_back(MenuItemUnit(pluginCmdId, displayAs.c_str(), folderName.c_str()));
1754  					}
1755  				}
1756  			}
1757  		}
1758  	}
1759  	return true;
1760  }
1761  void NppParameters::setWorkingDir(const TCHAR * newPath)
1762  {
1763  	if (newPath &amp;&amp; newPath[0])
1764  	{
1765  		_currentDirectory = newPath;
1766  	}
1767  	else
1768  	{
1769  		if (PathFileExists(_nppGUI._defaultDirExp))
1770  			_currentDirectory = _nppGUI._defaultDirExp;
1771  		else
1772  			_currentDirectory = _nppPath.c_str();
1773  	}
1774  }
1775  bool NppParameters::loadSession(Session &amp; session, const TCHAR *sessionFileName)
1776  {
1777  	TiXmlDocument *pXmlSessionDocument = new TiXmlDocument(sessionFileName);
1778  	bool loadOkay = pXmlSessionDocument-&gt;LoadFile();
1779  	if (loadOkay)
1780  		loadOkay = getSessionFromXmlTree(pXmlSessionDocument, session);
1781  	delete pXmlSessionDocument;
1782  	return loadOkay;
1783  }
1784  bool NppParameters::getSessionFromXmlTree(TiXmlDocument *pSessionDoc, Session&amp; session)
1785  {
1786  	if (!pSessionDoc)
1787  		return false;
1788  	TiXmlNode *root = pSessionDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1789  	if (!root)
1790  		return false;
1791  	TiXmlNode *sessionRoot = root-&gt;FirstChildElement(TEXT(&quot;Session&quot;));
1792  	if (!sessionRoot)
1793  		return false;
1794  	TiXmlElement *actView = sessionRoot-&gt;ToElement();
1795  	int index = 0;
1796  	const TCHAR *str = actView-&gt;Attribute(TEXT(&quot;activeView&quot;), &amp;index);
1797  	if (str)
1798  	{
1799  		session._activeView = index;
1800  	}
1801  	const size_t nbView = 2;
1802  	TiXmlNode *viewRoots[nbView];
1803  	viewRoots[0] = sessionRoot-&gt;FirstChildElement(TEXT(&quot;mainView&quot;));
1804  	viewRoots[1] = sessionRoot-&gt;FirstChildElement(TEXT(&quot;subView&quot;));
1805  	for (size_t k = 0; k &lt; nbView; ++k)
1806  	{
1807  		if (viewRoots[k])
1808  		{
1809  			int index2 = 0;
1810  			TiXmlElement *actIndex = viewRoots[k]-&gt;ToElement();
1811  			str = actIndex-&gt;Attribute(TEXT(&quot;activeIndex&quot;), &amp;index2);
1812  			if (str)
1813  			{
1814  				if (k == 0)
1815  					session._activeMainIndex = index2;
1816  				else 
1817  					session._activeSubIndex = index2;
1818  			}
1819  			for (TiXmlNode *childNode = viewRoots[k]-&gt;FirstChildElement(TEXT(&quot;File&quot;));
1820  				childNode ;
1821  				childNode = childNode-&gt;NextSibling(TEXT(&quot;File&quot;)) )
1822  			{
1823  				const TCHAR *fileName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;filename&quot;));
1824  				if (fileName)
1825  				{
1826  					Position position;
1827  					const TCHAR* posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;firstVisibleLine&quot;));
1828  					if (posStr)
1829  						position._firstVisibleLine = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1830  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;xOffset&quot;));
1831  					if (posStr)
1832  						position._xOffset = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1833  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;startPos&quot;));
1834  					if (posStr)
1835  						position._startPos = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1836  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;endPos&quot;));
1837  					if (posStr)
1838  						position._endPos = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1839  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;selMode&quot;));
1840  					if (posStr)
1841  						position._selMode = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1842  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;scrollWidth&quot;));
1843  					if (posStr)
1844  						position._scrollWidth = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1845  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;offset&quot;));
1846  					if (posStr)
1847  						position._offset = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1848  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;wrapCount&quot;));
1849  					if (posStr)
1850  						position._wrapCount = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1851  					MapPosition mapPosition;
1852  					const TCHAR* mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapFirstVisibleDisplayLine&quot;));
1853  					if (mapPosStr)
1854  						mapPosition._firstVisibleDisplayLine = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1855  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapFirstVisibleDocLine&quot;));
1856  					if (mapPosStr)
1857  						mapPosition._firstVisibleDocLine = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1858  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapLastVisibleDocLine&quot;));
1859  					if (mapPosStr)
1860  						mapPosition._lastVisibleDocLine = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1861  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapNbLine&quot;));
1862  					if (mapPosStr)
1863  						mapPosition._nbLine = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1864  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapHigherPos&quot;));
1865  					if (mapPosStr)
1866  						mapPosition._higherPos = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1867  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapWidth&quot;));
1868  					if (mapPosStr)
1869  						mapPosition._width = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1870  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapHeight&quot;));
1871  					if (mapPosStr)
1872  						mapPosition._height = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1873  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapKByteInDoc&quot;));
1874  					if (mapPosStr)
1875  						mapPosition._KByteInDoc = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1876  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapWrapIndentMode&quot;));
1877  					if (mapPosStr)
1878  						mapPosition._wrapIndentMode = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1879  					const TCHAR *boolStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapIsWrap&quot;));
1880  					if (boolStr)
1881  						mapPosition._isWrap = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
1882  					const TCHAR *langName;
1883  					langName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;lang&quot;));
1884  					int encoding = -1;
1885  					const TCHAR *encStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;encoding&quot;), &amp;encoding);
1886  					const TCHAR *backupFilePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;backupFilePath&quot;));
1887  					FILETIME fileModifiedTimestamp{};
1888  					(childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;originalFileLastModifTimestamp&quot;), reinterpret_cast&lt;int32_t*&gt;(&amp;fileModifiedTimestamp.dwLowDateTime));
1889  					(childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;originalFileLastModifTimestampHigh&quot;), reinterpret_cast&lt;int32_t*&gt;(&amp;fileModifiedTimestamp.dwHighDateTime));
1890  					bool isUserReadOnly = false;
1891  					const TCHAR *boolStrReadOnly = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;userReadOnly&quot;));
1892  					if (boolStrReadOnly)
1893  						isUserReadOnly = _wcsicmp(TEXT(&quot;yes&quot;), boolStrReadOnly) == 0;
1894  					sessionFileInfo sfi(fileName, langName, encStr ? encoding : -1, isUserReadOnly, position, backupFilePath, fileModifiedTimestamp, mapPosition);
1895  					const TCHAR* intStrTabColour = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;tabColourId&quot;));
1896  					if (intStrTabColour)
1897  					{
1898  						sfi._individualTabColour = _wtoi(intStrTabColour);
1899  					}
1900  					for (TiXmlNode *markNode = childNode-&gt;FirstChildElement(TEXT(&quot;Mark&quot;));
1901  						markNode;
1902  						markNode = markNode-&gt;NextSibling(TEXT(&quot;Mark&quot;)))
1903  					{
1904  						const TCHAR* lineNumberStr = (markNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;line&quot;));
1905  						if (lineNumberStr)
1906  						{
1907  							sfi._marks.push_back(static_cast&lt;size_t&gt;(_ttoi64(lineNumberStr)));
1908  						}
1909  					}
1910  					for (TiXmlNode *foldNode = childNode-&gt;FirstChildElement(TEXT(&quot;Fold&quot;));
1911  						foldNode;
1912  						foldNode = foldNode-&gt;NextSibling(TEXT(&quot;Fold&quot;)))
1913  					{
1914  						const TCHAR *lineNumberStr = (foldNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;line&quot;));
1915  						if (lineNumberStr)
1916  						{
1917  							sfi._foldStates.push_back(static_cast&lt;size_t&gt;(_ttoi64(lineNumberStr)));
1918  						}
1919  					}
1920  					if (k == 0)
1921  						session._mainViewFiles.push_back(sfi);
1922  					else 
1923  						session._subViewFiles.push_back(sfi);
1924  				}
1925  			}
1926  		}
1927  	}
1928  	TiXmlNode *fileBrowserRoot = sessionRoot-&gt;FirstChildElement(TEXT(&quot;FileBrowser&quot;));
1929  	if (fileBrowserRoot)
1930  	{
1931  		const TCHAR *selectedItemPath = (fileBrowserRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;latestSelectedItem&quot;));
1932  		if (selectedItemPath)
1933  		{
1934  			session._fileBrowserSelectedItem = selectedItemPath;
1935  		}
1936  		for (TiXmlNode *childNode = fileBrowserRoot-&gt;FirstChildElement(TEXT(&quot;root&quot;));
1937  			childNode;
1938  			childNode = childNode-&gt;NextSibling(TEXT(&quot;root&quot;)))
1939  		{
1940  			const TCHAR *fileName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;foldername&quot;));
1941  			if (fileName)
1942  			{
1943  				session._fileBrowserRoots.push_back({ fileName });
1944  			}
1945  		}
1946  	}
1947  	return true;
1948  }
1949  void NppParameters::feedFileListParameters(TiXmlNode *node)
1950  {
1951  	TiXmlNode *historyRoot = node-&gt;FirstChildElement(TEXT(&quot;History&quot;));
1952  	if (!historyRoot) return;
1953  	int nbMaxFile = _nbMaxRecentFile;
1954  	const TCHAR *strVal = (historyRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFile&quot;), &amp;nbMaxFile);
1955  	if (strVal &amp;&amp; (nbMaxFile &gt;= 0) &amp;&amp; (nbMaxFile &lt;= NB_MAX_LRF_FILE))
1956  		_nbMaxRecentFile = nbMaxFile;
1957  	int customLen = RECENTFILES_SHOWFULLPATH;
1958  	strVal = (historyRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;customLength&quot;), &amp;customLen);
1959  	if (strVal)
1960  		_recentFileCustomLength = std::min&lt;int&gt;(customLen, NB_MAX_LRF_CUSTOMLENGTH);
1961  	strVal = (historyRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;inSubMenu&quot;));
1962  	if (strVal)
1963  		_putRecentFileInSubMenu = (lstrcmp(strVal, TEXT(&quot;yes&quot;)) == 0);
1964  	for (TiXmlNode *childNode = historyRoot-&gt;FirstChildElement(TEXT(&quot;File&quot;));
1965  		childNode &amp;&amp; (_nbRecentFile &lt; NB_MAX_LRF_FILE);
1966  		childNode = childNode-&gt;NextSibling(TEXT(&quot;File&quot;)) )
1967  	{
1968  		const TCHAR *filePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;filename&quot;));
1969  		if (filePath)
1970  		{
1971  			_LRFileList[_nbRecentFile] = new generic_string(filePath);
1972  			++_nbRecentFile;
1973  		}
1974  	}
1975  }
1976  void NppParameters::feedFileBrowserParameters(TiXmlNode *node)
1977  {
1978  	TiXmlNode *fileBrowserRoot = node-&gt;FirstChildElement(TEXT(&quot;FileBrowser&quot;));
1979  	if (!fileBrowserRoot) return;
1980  	const TCHAR *selectedItemPath = (fileBrowserRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;latestSelectedItem&quot;));
1981  	if (selectedItemPath)
1982  	{
1983  		_fileBrowserSelectedItemPath = selectedItemPath;
1984  	}
1985  	for (TiXmlNode *childNode = fileBrowserRoot-&gt;FirstChildElement(TEXT(&quot;root&quot;));
1986  		childNode;
1987  		childNode = childNode-&gt;NextSibling(TEXT(&quot;root&quot;)) )
1988  	{
1989  		const TCHAR *filePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;foldername&quot;));
1990  		if (filePath)
1991  		{
1992  			_fileBrowserRoot.push_back(filePath);
1993  		}
1994  	}
1995  }
1996  void NppParameters::feedProjectPanelsParameters(TiXmlNode *node)
1997  {
1998  	TiXmlNode *projPanelRoot = node-&gt;FirstChildElement(TEXT(&quot;ProjectPanels&quot;));
1999  	if (!projPanelRoot) return;
2000  	for (TiXmlNode *childNode = projPanelRoot-&gt;FirstChildElement(TEXT(&quot;ProjectPanel&quot;));
2001  		childNode;
2002  		childNode = childNode-&gt;NextSibling(TEXT(&quot;ProjectPanel&quot;)) )
2003  	{
2004  		int index = 0;
2005  		const TCHAR *idStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;id&quot;), &amp;index);
2006  		if (idStr &amp;&amp; (index &gt;= 0 &amp;&amp; index &lt;= 2))
2007  		{
2008  			const TCHAR *filePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;workSpaceFile&quot;));
2009  			if (filePath)
2010  			{
2011  				_workSpaceFilePathes[index] = filePath;
2012  			}
2013  		}
2014  	}
2015  }
2016  void NppParameters::feedColumnEditorParameters(TiXmlNode *node)
2017  {
2018  	TiXmlNode * columnEditorRoot = node-&gt;FirstChildElement(TEXT(&quot;ColumnEditor&quot;));
2019  	if (!columnEditorRoot) return;
2020  	const TCHAR* strVal = (columnEditorRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;choice&quot;));
2021  	if (strVal)
2022  	{
2023  		if (lstrcmp(strVal, TEXT(&quot;text&quot;)) == 0)
2024  			_columnEditParam._mainChoice = activeText;
2025  		else
2026  			_columnEditParam._mainChoice = activeNumeric;
2027  	}
2028  	TiXmlNode *childNode = columnEditorRoot-&gt;FirstChildElement(TEXT(&quot;text&quot;));
2029  	if (!childNode) return;
2030  	const TCHAR* content = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;content&quot;));
2031  	if (content)
2032  	{
2033  		_columnEditParam._insertedTextContent = content;
2034  	}
2035  	childNode = columnEditorRoot-&gt;FirstChildElement(TEXT(&quot;number&quot;));
2036  	if (!childNode) return;
2037  	int val;
2038  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;initial&quot;), &amp;val);
2039  	if (strVal)
2040  		_columnEditParam._initialNum = val;
2041  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;increase&quot;), &amp;val);
2042  	if (strVal)
2043  		_columnEditParam._increaseNum = val;
2044  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;repeat&quot;), &amp;val);
2045  	if (strVal)
2046  		_columnEditParam._repeatNum = val;
2047  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;formatChoice&quot;));
2048  	if (strVal)
2049  	{
2050  		if (lstrcmp(strVal, TEXT(&quot;hex&quot;)) == 0)
2051  			_columnEditParam._formatChoice = 1;
2052  		else if (lstrcmp(strVal, TEXT(&quot;oct&quot;)) == 0)
2053  			_columnEditParam._formatChoice = 2;
2054  		else if (lstrcmp(strVal, TEXT(&quot;bin&quot;)) == 0)
2055  			_columnEditParam._formatChoice = 3;
2056  		else 
2057  			_columnEditParam._formatChoice = 0;
2058  	}
2059  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;leadingChoice&quot;));
2060  	if (strVal)
2061  	{
2062  		_columnEditParam._leadingChoice = ColumnEditorParam::noneLeading;
2063  		if (lstrcmp(strVal, TEXT(&quot;zeros&quot;)) == 0)
2064  		{
2065  			_columnEditParam._leadingChoice = ColumnEditorParam::zeroLeading;
2066  		}
2067  		else if (lstrcmp(strVal, TEXT(&quot;spaces&quot;)) == 0)
2068  		{
2069  			_columnEditParam._leadingChoice = ColumnEditorParam::spaceLeading;
2070  		}
2071  	}
2072  }
2073  void NppParameters::feedFindHistoryParameters(TiXmlNode *node)
2074  {
2075  	TiXmlNode *findHistoryRoot = node-&gt;FirstChildElement(TEXT(&quot;FindHistory&quot;));
2076  	if (!findHistoryRoot) return;
2077  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFindHistoryPath&quot;), &amp;_findHistory._nbMaxFindHistoryPath);
2078  	if (_findHistory._nbMaxFindHistoryPath &gt; NB_MAX_FINDHISTORY_PATH)
2079  	{
2080  		_findHistory._nbMaxFindHistoryPath = NB_MAX_FINDHISTORY_PATH;
2081  	}
2082  	if ((_findHistory._nbMaxFindHistoryPath &gt; 0) &amp;&amp; (_findHistory._nbMaxFindHistoryPath &lt;= NB_MAX_FINDHISTORY_PATH))
2083  	{
2084  		for (TiXmlNode *childNode = findHistoryRoot-&gt;FirstChildElement(TEXT(&quot;Path&quot;));
2085  			childNode &amp;&amp; (_findHistory._findHistoryPaths.size() &lt; NB_MAX_FINDHISTORY_PATH);
2086  			childNode = childNode-&gt;NextSibling(TEXT(&quot;Path&quot;)) )
2087  		{
2088  			const TCHAR *filePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2089  			if (filePath)
2090  			{
2091  				_findHistory._findHistoryPaths.push_back(generic_string(filePath));
2092  			}
2093  		}
2094  	}
2095  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFindHistoryFilter&quot;), &amp;_findHistory._nbMaxFindHistoryFilter);
2096  	if (_findHistory._nbMaxFindHistoryFilter &gt; NB_MAX_FINDHISTORY_FILTER)
2097  	{
2098  		_findHistory._nbMaxFindHistoryFilter = NB_MAX_FINDHISTORY_FILTER;
2099  	}
2100  	if ((_findHistory._nbMaxFindHistoryFilter &gt; 0) &amp;&amp; (_findHistory._nbMaxFindHistoryFilter &lt;= NB_MAX_FINDHISTORY_FILTER))
2101  	{
2102  		for (TiXmlNode *childNode = findHistoryRoot-&gt;FirstChildElement(TEXT(&quot;Filter&quot;));
2103  			childNode &amp;&amp; (_findHistory._findHistoryFilters.size() &lt; NB_MAX_FINDHISTORY_FILTER);
2104  			childNode = childNode-&gt;NextSibling(TEXT(&quot;Filter&quot;)))
2105  		{
2106  			const TCHAR *fileFilter = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2107  			if (fileFilter)
2108  			{
2109  				_findHistory._findHistoryFilters.push_back(generic_string(fileFilter));
2110  			}
2111  		}
2112  	}
2113  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFindHistoryFind&quot;), &amp;_findHistory._nbMaxFindHistoryFind);
2114  	if (_findHistory._nbMaxFindHistoryFind &gt; NB_MAX_FINDHISTORY_FIND)
2115  	{
2116  		_findHistory._nbMaxFindHistoryFind = NB_MAX_FINDHISTORY_FIND;
2117  	}
2118  	if ((_findHistory._nbMaxFindHistoryFind &gt; 0) &amp;&amp; (_findHistory._nbMaxFindHistoryFind &lt;= NB_MAX_FINDHISTORY_FIND))
2119  	{
2120  		for (TiXmlNode *childNode = findHistoryRoot-&gt;FirstChildElement(TEXT(&quot;Find&quot;));
2121  			childNode &amp;&amp; (_findHistory._findHistoryFinds.size() &lt; NB_MAX_FINDHISTORY_FIND);
2122  			childNode = childNode-&gt;NextSibling(TEXT(&quot;Find&quot;)))
2123  		{
2124  			const TCHAR *fileFind = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2125  			if (fileFind)
2126  			{
2127  				_findHistory._findHistoryFinds.push_back(generic_string(fileFind));
2128  			}
2129  		}
2130  	}
2131  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFindHistoryReplace&quot;), &amp;_findHistory._nbMaxFindHistoryReplace);
2132  	if (_findHistory._nbMaxFindHistoryReplace &gt; NB_MAX_FINDHISTORY_REPLACE)
2133  	{
2134  		_findHistory._nbMaxFindHistoryReplace = NB_MAX_FINDHISTORY_REPLACE;
2135  	}
2136  	if ((_findHistory._nbMaxFindHistoryReplace &gt; 0) &amp;&amp; (_findHistory._nbMaxFindHistoryReplace &lt;= NB_MAX_FINDHISTORY_REPLACE))
2137  	{
2138  		for (TiXmlNode *childNode = findHistoryRoot-&gt;FirstChildElement(TEXT(&quot;Replace&quot;));
2139  			childNode &amp;&amp; (_findHistory._findHistoryReplaces.size() &lt; NB_MAX_FINDHISTORY_REPLACE);
2140  			childNode = childNode-&gt;NextSibling(TEXT(&quot;Replace&quot;)))
2141  		{
2142  			const TCHAR *fileReplace = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2143  			if (fileReplace)
2144  			{
2145  				_findHistory._findHistoryReplaces.push_back(generic_string(fileReplace));
2146  			}
2147  		}
2148  	}
2149  	const TCHAR *boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;matchWord&quot;));
2150  	if (boolStr)
2151  		_findHistory._isMatchWord = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2152  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;matchCase&quot;));
2153  	if (boolStr)
2154  		_findHistory._isMatchCase = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2155  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;wrap&quot;));
2156  	if (boolStr)
2157  		_findHistory._isWrap = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2158  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;directionDown&quot;));
2159  	if (boolStr)
2160  		_findHistory._isDirectionDown = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2161  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifRecuisive&quot;));
2162  	if (boolStr)
2163  		_findHistory._isFifRecuisive = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2164  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifInHiddenFolder&quot;));
2165  	if (boolStr)
2166  		_findHistory._isFifInHiddenFolder = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2167  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifProjectPanel1&quot;));
2168  	if (boolStr)
2169  		_findHistory._isFifProjectPanel_1 = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2170  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifProjectPanel2&quot;));
2171  	if (boolStr)
2172  		_findHistory._isFifProjectPanel_2 = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2173  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifProjectPanel3&quot;));
2174  	if (boolStr)
2175  		_findHistory._isFifProjectPanel_3 = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2176  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifFilterFollowsDoc&quot;));
2177  	if (boolStr)
2178  		_findHistory._isFilterFollowDoc = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2179  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifFolderFollowsDoc&quot;));
2180  	if (boolStr)
2181  		_findHistory._isFolderFollowDoc = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2182  	int mode = 0;
2183  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;searchMode&quot;), &amp;mode);
2184  	if (boolStr)
2185  		_findHistory._searchMode = (FindHistory::searchMode)mode;
2186  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;transparencyMode&quot;), &amp;mode);
2187  	if (boolStr)
2188  		_findHistory._transparencyMode = (FindHistory::transparencyMode)mode;
2189  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;transparency&quot;), &amp;_findHistory._transparency);
2190  	if (_findHistory._transparency &lt;= 0 || _findHistory._transparency &gt; 200)
2191  		_findHistory._transparency = 150;
2192  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;dotMatchesNewline&quot;));
2193  	if (boolStr)
2194  		_findHistory._dotMatchesNewline = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2195  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;isSearch2ButtonsMode&quot;));
2196  	if (boolStr)
2197  		_findHistory._isSearch2ButtonsMode = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2198  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;regexBackward4PowerUser&quot;));
2199  	if (boolStr)
2200  		_findHistory._regexBackward4PowerUser = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2201  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;bookmarkLine&quot;));
2202  	if (boolStr)
2203  		_findHistory._isBookmarkLine = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2204  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;purge&quot;));
2205  	if (boolStr)
2206  		_findHistory._isPurge = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2207  }
2208  void NppParameters::feedShortcut(TiXmlNodeA *node)
2209  {
2210  	TiXmlNodeA *shortcutsRoot = node-&gt;FirstChildElement(&quot;InternalCommands&quot;);
2211  	if (!shortcutsRoot) return;
2212  	for (TiXmlNodeA *childNode = shortcutsRoot-&gt;FirstChildElement(&quot;Shortcut&quot;);
2213  		childNode ;
2214  		childNode = childNode-&gt;NextSibling(&quot;Shortcut&quot;))
2215  	{
2216  		int id;
2217  		const char* idStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;id&quot;, &amp;id);
2218  		if (idStr)
2219  		{
2220  			size_t len = _shortcuts.size();
2221  			for (size_t i = 0; i &lt; len; ++i)
2222  			{
2223  				if (_shortcuts[i].getID() == (unsigned long)id)
2224  				{	
2225  					getShortcuts(childNode, _shortcuts[i]);
2226  					addUserModifiedIndex(i);
2227  				}
2228  			}
2229  		}
2230  	}
2231  }
2232  void NppParameters::feedMacros(TiXmlNodeA *node)
2233  {
2234  	TiXmlNodeA *macrosRoot = node-&gt;FirstChildElement(&quot;Macros&quot;);
2235  	if (!macrosRoot) return;
2236  	for (TiXmlNodeA *childNode = macrosRoot-&gt;FirstChildElement(&quot;Macro&quot;);
2237  		childNode ;
2238  		childNode = childNode-&gt;NextSibling(&quot;Macro&quot;))
2239  	{
2240  		Shortcut sc;
2241  		string fdnm;
2242  		if (getShortcuts(childNode, sc, &amp;fdnm))
2243  		{
2244  			Macro macro;
2245  			getActions(childNode, macro);
2246  			int cmdID = ID_MACRO + static_cast&lt;int32_t&gt;(_macros.size());
2247  			_macros.push_back(MacroShortcut(sc, macro, cmdID));
2248  			_macroMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2249  		}
2250  	}
2251  }
2252  void NppParameters::getActions(TiXmlNodeA *node, Macro &amp; macro)
2253  {
2254  	for (TiXmlNodeA *childNode = node-&gt;FirstChildElement(&quot;Action&quot;);
2255  		childNode ;
2256  		childNode = childNode-&gt;NextSibling(&quot;Action&quot;) )
2257  	{
2258  		int type;
2259  		const char *typeStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;type&quot;, &amp;type);
2260  		if ((!typeStr) || (type &gt; 3))
2261  			continue;
2262  		int msg = 0;
2263  		(childNode-&gt;ToElement())-&gt;Attribute(&quot;message&quot;, &amp;msg);
2264  		int wParam = 0;
2265  		(childNode-&gt;ToElement())-&gt;Attribute(&quot;wParam&quot;, &amp;wParam);
2266  		int lParam = 0;
2267  		(childNode-&gt;ToElement())-&gt;Attribute(&quot;lParam&quot;, &amp;lParam);
2268  		const char *sParam = (childNode-&gt;ToElement())-&gt;Attribute(&quot;sParam&quot;);
2269  		if (!sParam)
2270  			sParam = &quot;&quot;;
2271  		recordedMacroStep step(msg, wParam, lParam, sParam, type);
2272  		if (step.isValid())
2273  			macro.push_back(step);
2274  	}
2275  }
2276  void NppParameters::feedUserCmds(TiXmlNodeA *node)
2277  {
2278  	TiXmlNodeA *userCmdsRoot = node-&gt;FirstChildElement(&quot;UserDefinedCommands&quot;);
2279  	if (!userCmdsRoot) return;
2280  	for (TiXmlNodeA *childNode = userCmdsRoot-&gt;FirstChildElement(&quot;Command&quot;);
2281  		childNode ;
2282  		childNode = childNode-&gt;NextSibling(&quot;Command&quot;) )
2283  	{
2284  		Shortcut sc;
2285  		string fdnm;
2286  		if (getShortcuts(childNode, sc, &amp;fdnm))
2287  		{
2288  			TiXmlNodeA *aNode = childNode-&gt;FirstChild();
2289  			if (aNode)
2290  			{
2291  				const char* cmdStr = aNode-&gt;Value();
2292  				if (cmdStr)
2293  				{
2294  					int cmdID = ID_USER_CMD + static_cast&lt;int32_t&gt;(_userCommands.size());
2295  					_userCommands.push_back(UserCommand(sc, cmdStr, cmdID));
2296  					_runMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2297  				}
2298  			}
2299  		}
2300  	}
2301  }
2302  void NppParameters::feedPluginCustomizedCmds(TiXmlNodeA *node)
2303  {
2304  	TiXmlNodeA *pluginCustomizedCmdsRoot = node-&gt;FirstChildElement(&quot;PluginCommands&quot;);
2305  	if (!pluginCustomizedCmdsRoot) return;
2306  	for (TiXmlNodeA *childNode = pluginCustomizedCmdsRoot-&gt;FirstChildElement(&quot;PluginCommand&quot;);
2307  		childNode ;
2308  		childNode = childNode-&gt;NextSibling(&quot;PluginCommand&quot;) )
2309  	{
2310  		const char *moduleName = (childNode-&gt;ToElement())-&gt;Attribute(&quot;moduleName&quot;);
2311  		if (!moduleName)
2312  			continue;
2313  		int internalID = -1;
2314  		const char *internalIDStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;internalID&quot;, &amp;internalID);
2315  		if (!internalIDStr)
2316  			continue;
2317  		size_t len = _pluginCommands.size();
2318  		for (size_t i = 0; i &lt; len; ++i)
2319  		{
2320  			PluginCmdShortcut &amp; pscOrig = _pluginCommands[i];
2321  			if (!strnicmp(pscOrig.getModuleName(), moduleName, strlen(moduleName)) &amp;&amp; pscOrig.getInternalID() == internalID)
2322  			{
2323  				getShortcuts(childNode, _pluginCommands[i]);
2324  				addPluginModifiedIndex(i);
2325  				break;
2326  			}
2327  		}
2328  	}
2329  }
2330  void NppParameters::feedScintKeys(TiXmlNodeA *node)
2331  {
2332  	TiXmlNodeA *scintKeysRoot = node-&gt;FirstChildElement(&quot;ScintillaKeys&quot;);
2333  	if (!scintKeysRoot) return;
2334  	for (TiXmlNodeA *childNode = scintKeysRoot-&gt;FirstChildElement(&quot;ScintKey&quot;);
2335  		childNode ;
2336  		childNode = childNode-&gt;NextSibling(&quot;ScintKey&quot;) )
2337  	{
2338  		int scintKey;
2339  		const char *keyStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;ScintID&quot;, &amp;scintKey);
2340  		if (!keyStr)
2341  			continue;
2342  		int menuID;
2343  		keyStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;menuCmdID&quot;, &amp;menuID);
2344  		if (!keyStr)
2345  			continue;
2346  		size_t len = _scintillaKeyCommands.size();
2347  		for (int32_t i = 0; i &lt; static_cast&lt;int32_t&gt;(len); ++i)
2348  		{
2349  			ScintillaKeyMap &amp; skmOrig = _scintillaKeyCommands[i];
2350  			if (skmOrig.getScintillaKeyID() == (unsigned long)scintKey &amp;&amp; skmOrig.getMenuCmdID() == menuID)
2351  			{
2352  				_scintillaKeyCommands[i].clearDups();
2353  				getShortcuts(childNode, _scintillaKeyCommands[i]);
2354  				_scintillaKeyCommands[i].setKeyComboByIndex(0, _scintillaKeyCommands[i].getKeyCombo());
2355  				addScintillaModifiedIndex(i);
2356  				KeyCombo kc;
2357  				for (TiXmlNodeA *nextNode = childNode-&gt;FirstChildElement(&quot;NextKey&quot;);
2358  					nextNode ;
2359  					nextNode = nextNode-&gt;NextSibling(&quot;NextKey&quot;))
2360  				{
2361  					const char *str = (nextNode-&gt;ToElement())-&gt;Attribute(&quot;Ctrl&quot;);
2362  					if (!str)
2363  						continue;
2364  					kc._isCtrl = (strcmp(&quot;yes&quot;, str) == 0);
2365  					str = (nextNode-&gt;ToElement())-&gt;Attribute(&quot;Alt&quot;);
2366  					if (!str)
2367  						continue;
2368  					kc._isAlt = (strcmp(&quot;yes&quot;, str) == 0);
2369  					str = (nextNode-&gt;ToElement())-&gt;Attribute(&quot;Shift&quot;);
2370  					if (!str)
2371  						continue;
2372  					kc._isShift = (strcmp(&quot;yes&quot;, str) == 0);
2373  					int key;
2374  					str = (nextNode-&gt;ToElement())-&gt;Attribute(&quot;Key&quot;, &amp;key);
2375  					if (!str)
2376  						continue;
2377  					kc._key = static_cast&lt;unsigned char&gt;(key);
2378  					_scintillaKeyCommands[i].addKeyCombo(kc);
2379  				}
2380  				break;
2381  			}
2382  		}
2383  	}
2384  }
2385  bool NppParameters::getShortcuts(TiXmlNodeA *node, Shortcut &amp; sc, string* folderName)
2386  {
2387  	if (!node) return false;
2388  	const char* name = (node-&gt;ToElement())-&gt;Attribute(&quot;name&quot;);
2389  	if (!name)
2390  		name = &quot;&quot;;
2391  	bool isCtrl = false;
2392  	const char* isCtrlStr = (node-&gt;ToElement())-&gt;Attribute(&quot;Ctrl&quot;);
2393  	if (isCtrlStr)
2394  		isCtrl = (strcmp(&quot;yes&quot;, isCtrlStr) == 0);
2395  	bool isAlt = false;
2396  	const char* isAltStr = (node-&gt;ToElement())-&gt;Attribute(&quot;Alt&quot;);
2397  	if (isAltStr)
2398  		isAlt = (strcmp(&quot;yes&quot;, isAltStr) == 0);
2399  	bool isShift = false;
2400  	const char* isShiftStr = (node-&gt;ToElement())-&gt;Attribute(&quot;Shift&quot;);
2401  	if (isShiftStr)
2402  		isShift = (strcmp(&quot;yes&quot;, isShiftStr) == 0);
2403  	int key;
2404  	const char* keyStr = (node-&gt;ToElement())-&gt;Attribute(&quot;Key&quot;, &amp;key);
2405  	if (!keyStr)
2406  		return false;
2407  	if (folderName)
2408  	{
2409  		const char* fn = (node-&gt;ToElement())-&gt;Attribute(&quot;FolderName&quot;);
2410  		*folderName = fn ? fn : &quot;&quot;;
2411  	}
2412  	sc = Shortcut(name, isCtrl, isAlt, isShift, static_cast&lt;unsigned char&gt;(key));
2413  	return true;
2414  }
2415  std::pair&lt;unsigned char, unsigned char&gt; NppParameters::feedUserLang(TiXmlNode *node)
2416  {
2417  	int iBegin = _nbUserLang;
2418  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;UserLang&quot;));
2419  		childNode &amp;&amp; (_nbUserLang &lt; NB_MAX_USER_LANG);
2420  		childNode = childNode-&gt;NextSibling(TEXT(&quot;UserLang&quot;)) )
2421  	{
2422  		const TCHAR* name = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2423  		const TCHAR* ext = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;ext&quot;));
2424  		const TCHAR* darkModeTheme = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;darkModeTheme&quot;));
2425  		const TCHAR* udlVersion = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;udlVersion&quot;));
2426  		if (!name || !name[0] || !ext)
2427  		{
2428  			continue;
2429  		}
2430  		bool isDarkModeTheme = false;
2431  		if (darkModeTheme &amp;&amp; darkModeTheme[0])
2432  		{
2433  			isDarkModeTheme = (lstrcmp(TEXT(&quot;yes&quot;), darkModeTheme) == 0);
2434  		}
2435  		try {
2436  			_userLangArray[_nbUserLang] = new UserLangContainer(name, ext, isDarkModeTheme, udlVersion ? udlVersion : TEXT(&quot;&quot;));
2437  			++_nbUserLang;
2438  			TiXmlNode *settingsRoot = childNode-&gt;FirstChildElement(TEXT(&quot;Settings&quot;));
2439  			if (!settingsRoot)
2440  				throw std::runtime_error(&quot;NppParameters::feedUserLang : Settings node is missing&quot;);
2441  			feedUserSettings(settingsRoot);
2442  			TiXmlNode *keywordListsRoot = childNode-&gt;FirstChildElement(TEXT(&quot;KeywordLists&quot;));
2443  			if (!keywordListsRoot)
2444  				throw std::runtime_error(&quot;NppParameters::feedUserLang : KeywordLists node is missing&quot;);
2445  			feedUserKeywordList(keywordListsRoot);
2446  			TiXmlNode *stylesRoot = childNode-&gt;FirstChildElement(TEXT(&quot;Styles&quot;));
2447  			if (!stylesRoot)
2448  				throw std::runtime_error(&quot;NppParameters::feedUserLang : Styles node is missing&quot;);
2449  			feedUserStyles(stylesRoot);
2450  			for (int i = 0 ; i &lt; SCE_USER_STYLE_TOTAL_STYLES ; ++i)
2451  			{
2452  				const Style * pStyle = _userLangArray[_nbUserLang - 1]-&gt;_styles.findByID(i);
2453  				if (!pStyle)
2454  					_userLangArray[_nbUserLang - 1]-&gt;_styles.addStyler(i, globalMappper().styleNameMapper[i]);
2455  			}
2456  		}
2457  		catch (const std::exception&amp;)
2458  		{
2459  			delete _userLangArray[--_nbUserLang];
2460  		}
2461  	}
2462  	int iEnd = _nbUserLang;
2463  	return pair&lt;unsigned char, unsigned char&gt;(static_cast&lt;unsigned char&gt;(iBegin), static_cast&lt;unsigned char&gt;(iEnd));
2464  }
2465  bool NppParameters::importUDLFromFile(const generic_string&amp; sourceFile)
2466  {
2467  	TiXmlDocument *pXmlUserLangDoc = new TiXmlDocument(sourceFile);
2468  	bool loadOkay = pXmlUserLangDoc-&gt;LoadFile();
2469  	if (loadOkay)
2470  	{
2471  		auto r = addUserDefineLangsFromXmlTree(pXmlUserLangDoc);
2472  		loadOkay = (r.second - r.first) != 0;
2473  		if (loadOkay)
2474  		{
2475  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, r));
2476  			setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
2477  		}
2478  	}
2479  	delete pXmlUserLangDoc;
2480  	return loadOkay;
2481  }
2482  bool NppParameters::exportUDLToFile(size_t langIndex2export, const generic_string&amp; fileName2save)
2483  {
2484  	if (langIndex2export &gt;= NB_MAX_USER_LANG)
2485  		return false;
2486  	if (static_cast&lt;int32_t&gt;(langIndex2export) &gt;= _nbUserLang)
2487  		return false;
2488  	TiXmlDocument *pNewXmlUserLangDoc = new TiXmlDocument(fileName2save);
2489  	TiXmlNode *newRoot2export = pNewXmlUserLangDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2490  	insertUserLang2Tree(newRoot2export, _userLangArray[langIndex2export]);
2491  	bool result = pNewXmlUserLangDoc-&gt;SaveFile();
2492  	delete pNewXmlUserLangDoc;
2493  	return result;
2494  }
2495  LangType NppParameters::getLangFromExt(const TCHAR *ext)
2496  {
2497  	int i = getNbLang();
2498  	i--;
2499  	while (i &gt;= 0)
2500  	{
2501  		Lang *l = getLangFromIndex(i--);
2502  		const TCHAR *defList = l-&gt;getDefaultExtList();
2503  		const TCHAR *userList = NULL;
2504  		LexerStylerArray &amp;lsa = getLStylerArray();
2505  		const TCHAR *lName = l-&gt;getLangName();
2506  		LexerStyler *pLS = lsa.getLexerStylerByName(lName);
2507  		if (pLS)
2508  			userList = pLS-&gt;getLexerUserExt();
2509  		generic_string list;
2510  		if (defList)
2511  			list += defList;
2512  		if (userList)
2513  		{
2514  			list += TEXT(&quot; &quot;);
2515  			list += userList;
2516  		}
2517  		if (isInList(ext, list.c_str()))
2518  			return l-&gt;getLangID();
2519  	}
2520  	return L_TEXT;
2521  }
2522  void NppParameters::setCloudChoice(const TCHAR *pathChoice)
2523  {
2524  	generic_string cloudChoicePath = getSettingsFolder();
2525  	cloudChoicePath += TEXT(&quot;\\cloud\\&quot;);
2526  	if (!PathFileExists(cloudChoicePath.c_str()))
2527  	{
2528  		::CreateDirectory(cloudChoicePath.c_str(), NULL);
2529  	}
2530  	cloudChoicePath += TEXT(&quot;choice&quot;);
2531  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
2532  	std::string cloudPathA = wmc.wchar2char(pathChoice, SC_CP_UTF8);
2533  	writeFileContent(cloudChoicePath.c_str(), cloudPathA.c_str());
2534  }
2535  void NppParameters::removeCloudChoice()
2536  {
2537  	generic_string cloudChoicePath = getSettingsFolder();
2538  	cloudChoicePath += TEXT(&quot;\\cloud\\choice&quot;);
2539  	if (PathFileExists(cloudChoicePath.c_str()))
2540  	{
2541  		::DeleteFile(cloudChoicePath.c_str());
2542  	}
2543  }
2544  bool NppParameters::isCloudPathChanged() const
2545  {
2546  	if (_initialCloudChoice == _nppGUI._cloudPath)
2547  		return false;
2548  	else if (_initialCloudChoice.size() - _nppGUI._cloudPath.size() == 1)
2549  	{
2550  		TCHAR c = _initialCloudChoice.at(_initialCloudChoice.size()-1);
2551  		if (c == &#x27;\\&#x27; || c == &#x27;/&#x27;)
2552  		{
2553  			if (_initialCloudChoice.find(_nppGUI._cloudPath) == 0)
2554  				return false;
2555  		}
2556  	}
2557  	else if (_nppGUI._cloudPath.size() - _initialCloudChoice.size() == 1)
2558  	{
2559  		TCHAR c = _nppGUI._cloudPath.at(_nppGUI._cloudPath.size() - 1);
2560  		if (c == &#x27;\\&#x27; || c == &#x27;/&#x27;)
2561  		{
2562  			if (_nppGUI._cloudPath.find(_initialCloudChoice) == 0)
2563  				return false;
2564  		}
2565  	}
2566  	return true;
2567  }
2568  bool NppParameters::writeSettingsFilesOnCloudForThe1stTime(const generic_string &amp; cloudSettingsPath)
2569  {
2570  	bool isOK = false;
2571  	if (cloudSettingsPath.empty())
2572  		return false;
2573  	generic_string cloudConfigPath = cloudSettingsPath;
2574  	pathAppend(cloudConfigPath, TEXT(&quot;config.xml&quot;));
2575  	if (!::PathFileExists(cloudConfigPath.c_str()) &amp;&amp; _pXmlUserDoc)
2576  	{
2577  		isOK = _pXmlUserDoc-&gt;SaveFile(cloudConfigPath.c_str());
2578  		if (!isOK)
2579  			return false;
2580  	}
2581  	generic_string cloudStylersPath = cloudSettingsPath;
2582  	pathAppend(cloudStylersPath, TEXT(&quot;stylers.xml&quot;));
2583  	if (!::PathFileExists(cloudStylersPath.c_str()) &amp;&amp; _pXmlUserStylerDoc)
2584  	{
2585  		isOK = _pXmlUserStylerDoc-&gt;SaveFile(cloudStylersPath.c_str());
2586  		if (!isOK)
2587  			return false;
2588  	}
2589  	generic_string cloudLangsPath = cloudSettingsPath;
2590  	pathAppend(cloudLangsPath, TEXT(&quot;langs.xml&quot;));
2591  	if (!::PathFileExists(cloudLangsPath.c_str()) &amp;&amp; _pXmlUserDoc)
2592  	{
2593  		isOK = _pXmlDoc-&gt;SaveFile(cloudLangsPath.c_str());
2594  		if (!isOK)
2595  			return false;
2596  	}
2597  	generic_string cloudUserLangsPath = cloudSettingsPath;
2598  	pathAppend(cloudUserLangsPath, TEXT(&quot;userDefineLang.xml&quot;));
2599  	if (!::PathFileExists(cloudUserLangsPath.c_str()) &amp;&amp; _pXmlUserLangDoc)
2600  	{
2601  		isOK = _pXmlUserLangDoc-&gt;SaveFile(cloudUserLangsPath.c_str());
2602  		if (!isOK)
2603  			return false;
2604  	}
2605  	generic_string cloudShortcutsPath = cloudSettingsPath;
2606  	pathAppend(cloudShortcutsPath, SHORTCUTSXML_FILENAME);
2607  	if (!::PathFileExists(cloudShortcutsPath.c_str()) &amp;&amp; _pXmlShortcutDocA)
2608  	{
2609  		isOK = _pXmlShortcutDocA-&gt;SaveUnicodeFilePath(cloudShortcutsPath.c_str());
2610  		if (!isOK)
2611  			return false;
2612  	}
2613  	generic_string cloudContextMenuPath = cloudSettingsPath;
2614  	pathAppend(cloudContextMenuPath, TEXT(&quot;contextMenu.xml&quot;));
2615  	if (!::PathFileExists(cloudContextMenuPath.c_str()) &amp;&amp; _pXmlContextMenuDocA)
2616  	{
2617  		isOK = _pXmlContextMenuDocA-&gt;SaveUnicodeFilePath(cloudContextMenuPath.c_str());
2618  		if (!isOK)
2619  			return false;
2620  	}
2621  	generic_string cloudNativeLangPath = cloudSettingsPath;
2622  	pathAppend(cloudNativeLangPath, TEXT(&quot;nativeLang.xml&quot;));
2623  	if (!::PathFileExists(cloudNativeLangPath.c_str()) &amp;&amp; _pXmlNativeLangDocA)
2624  	{
2625  		isOK = _pXmlNativeLangDocA-&gt;SaveUnicodeFilePath(cloudNativeLangPath.c_str());
2626  		if (!isOK)
2627  			return false;
2628  	}
2629  	return true;
2630  }
2631  void NppParameters::writeDefaultUDL()
2632  {
2633  	bool firstCleanDone = false;
2634  	std::vector&lt;std::pair&lt;bool, bool&gt;&gt; deleteState; 
2635  	for (const auto&amp; udl : _pXmlUserLangsDoc)
2636  	{
2637  		if (!_pXmlUserLangDoc)
2638  		{
2639  			_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
2640  			TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(&quot;1.0&quot;), TEXT(&quot;UTF-8&quot;), TEXT(&quot;&quot;));
2641  			_pXmlUserLangDoc-&gt;LinkEndChild(decl);
2642  			_pXmlUserLangDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2643  		}
2644  		bool toDelete = (udl._indexRange.second - udl._indexRange.first) == 0;
2645  		deleteState.push_back(std::pair(toDelete, udl._isInDefaultSharedContainer));
2646  		if ((!udl._udlXmlDoc || udl._udlXmlDoc == _pXmlUserLangDoc) &amp;&amp; udl._isDirty &amp;&amp; !toDelete) 
2647  		{
2648  			TiXmlNode *root = _pXmlUserLangDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
2649  			if (root &amp;&amp; !firstCleanDone)
2650  			{
2651  				_pXmlUserLangDoc-&gt;RemoveChild(root);
2652  				_pXmlUserLangDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2653  				firstCleanDone = true;
2654  			}
2655  			root = _pXmlUserLangDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
2656  			for (int i = udl._indexRange.first; i &lt; udl._indexRange.second; ++i)
2657  			{
2658  				insertUserLang2Tree(root, _userLangArray[i]);
2659  			}
2660  		}
2661  	}
2662  	bool deleteAll = true;
2663  	for (std::pair&lt;bool, bool&gt; udlState : deleteState)
2664  	{
2665  		if (!udlState.first &amp;&amp; udlState.second) 
2666  		{
2667  			deleteAll = false; 
2668  			break;
2669  		}
2670  	}
2671  	if (firstCleanDone) 
2672  	{
2673  		_pXmlUserLangDoc-&gt;SaveFile();
2674  	}
2675  	else if (deleteAll)
2676  	{
2677  		if (::PathFileExists(_userDefineLangPath.c_str()))
2678  		{
2679  			::DeleteFile(_userDefineLangPath.c_str());
2680  		}
2681  	}
2682  }
2683  void NppParameters::writeNonDefaultUDL()
2684  {
2685  	for (auto&amp; udl : _pXmlUserLangsDoc)
2686  	{
2687  		if (udl._isDirty &amp;&amp; udl._udlXmlDoc != nullptr &amp;&amp; udl._udlXmlDoc != _pXmlUserLangDoc)
2688  		{
2689  			if (udl._indexRange.second == udl._indexRange.first) 
2690  			{
2691  				const TCHAR* docFilePath = udl._udlXmlDoc-&gt;Value();
2692  				if (docFilePath &amp;&amp; ::PathFileExists(docFilePath))
2693  				{
2694  					::DeleteFile(docFilePath);
2695  				}
2696  			}
2697  			else
2698  			{
2699  				TiXmlNode *root = udl._udlXmlDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
2700  				if (root)
2701  				{
2702  					udl._udlXmlDoc-&gt;RemoveChild(root);
2703  				}
2704  				udl._udlXmlDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2705  				root = udl._udlXmlDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
2706  				for (int i = udl._indexRange.first; i &lt; udl._indexRange.second; ++i)
2707  				{
2708  					insertUserLang2Tree(root, _userLangArray[i]);
2709  				}
2710  				udl._udlXmlDoc-&gt;SaveFile();
2711  			}
2712  		}
2713  	}
2714  }
2715  void NppParameters::writeNeed2SaveUDL()
2716  {
2717  	writeDefaultUDL();
2718  	writeNonDefaultUDL();
2719  }
2720  void NppParameters::insertCmd(TiXmlNodeA *shortcutsRoot, const CommandShortcut &amp; cmd)
2721  {
2722  	const KeyCombo &amp; key = cmd.getKeyCombo();
2723  	TiXmlNodeA *sc = shortcutsRoot-&gt;InsertEndChild(TiXmlElementA(&quot;Shortcut&quot;));
2724  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;id&quot;, cmd.getID());
2725  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2726  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2727  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2728  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2729  }
2730  void NppParameters::insertMacro(TiXmlNodeA *macrosRoot, const MacroShortcut &amp; macro, const string&amp; folderName)
2731  {
2732  	const KeyCombo &amp; key = macro.getKeyCombo();
2733  	TiXmlNodeA *macroRoot = macrosRoot-&gt;InsertEndChild(TiXmlElementA(&quot;Macro&quot;));
2734  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;name&quot;, macro.getMenuName());
2735  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2736  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2737  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2738  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2739  	if (!folderName.empty())
2740  	{
2741  		macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;FolderName&quot;, folderName);
2742  	}
2743  	for (size_t i = 0, len = macro._macro.size(); i &lt; len ; ++i)
2744  	{
2745  		TiXmlNodeA *actionNode = macroRoot-&gt;InsertEndChild(TiXmlElementA(&quot;Action&quot;));
2746  		const recordedMacroStep &amp; action = macro._macro[i];
2747  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;type&quot;, action._macroType);
2748  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;message&quot;, action._message);
2749  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;wParam&quot;, static_cast&lt;int&gt;(action._wParameter));
2750  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;lParam&quot;, static_cast&lt;int&gt;(action._lParameter));
2751  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;sParam&quot;, action._sParameter.c_str());
2752  	}
2753  }
2754  void NppParameters::insertUserCmd(TiXmlNodeA *userCmdRoot, const UserCommand &amp; userCmd, const string&amp; folderName)
2755  {
2756  	const KeyCombo &amp; key = userCmd.getKeyCombo();
2757  	TiXmlNodeA *cmdRoot = userCmdRoot-&gt;InsertEndChild(TiXmlElementA(&quot;Command&quot;));
2758  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;name&quot;, userCmd.getMenuName());
2759  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2760  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2761  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2762  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2763  	cmdRoot-&gt;InsertEndChild(TiXmlTextA(userCmd._cmd.c_str()));
2764  	if (!folderName.empty())
2765  	{
2766  		cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;FolderName&quot;, folderName);
2767  	}
2768  }
2769  void NppParameters::insertPluginCmd(TiXmlNodeA *pluginCmdRoot, const PluginCmdShortcut &amp; pluginCmd)
2770  {
2771  	const KeyCombo &amp; key = pluginCmd.getKeyCombo();
2772  	TiXmlNodeA *pluginCmdNode = pluginCmdRoot-&gt;InsertEndChild(TiXmlElementA(&quot;PluginCommand&quot;));
2773  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;moduleName&quot;, pluginCmd.getModuleName());
2774  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;internalID&quot;, pluginCmd.getInternalID());
2775  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2776  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2777  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2778  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2779  }
2780  void NppParameters::insertScintKey(TiXmlNodeA *scintKeyRoot, const ScintillaKeyMap &amp; scintKeyMap)
2781  {
2782  	TiXmlNodeA *keyRoot = scintKeyRoot-&gt;InsertEndChild(TiXmlElementA(&quot;ScintKey&quot;));
2783  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;ScintID&quot;, scintKeyMap.getScintillaKeyID());
2784  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;menuCmdID&quot;, scintKeyMap.getMenuCmdID());
2785  	KeyCombo key = scintKeyMap.getKeyComboByIndex(0);
2786  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2787  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2788  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2789  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2790  	size_t size = scintKeyMap.getSize();
2791  	if (size &gt; 1)
2792  	{
2793  		for (size_t i = 1; i &lt; size; ++i)
2794  		{
2795  			TiXmlNodeA *keyNext = keyRoot-&gt;InsertEndChild(TiXmlElementA(&quot;NextKey&quot;));
2796  			key = scintKeyMap.getKeyComboByIndex(i);
2797  			keyNext-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2798  			keyNext-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2799  			keyNext-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2800  			keyNext-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2801  		}
2802  	}
2803  }
2804  void NppParameters::writeSession(const Session &amp; session, const TCHAR *fileName)
2805  {
2806  	const TCHAR *sessionPathName = fileName ? fileName : _sessionPath.c_str();
2807  	TCHAR backupPathName[MAX_PATH]{};
2808  	if (PathFileExists(sessionPathName))
2809  	{
2810  		_tcscpy(backupPathName, sessionPathName);
2811  		_tcscat(backupPathName, TEXT(&quot;.inCaseOfCorruption.bak&quot;));
2812  		CopyFile(sessionPathName, backupPathName, FALSE);
2813  	}
2814  	TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(sessionPathName);
2815  	TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(&quot;1.0&quot;), TEXT(&quot;UTF-8&quot;), TEXT(&quot;&quot;));
2816  	pXmlSessionDoc-&gt;LinkEndChild(decl);
2817  	TiXmlNode *root = pXmlSessionDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2818  	if (root)
2819  	{
2820  		TiXmlNode *sessionNode = root-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Session&quot;)));
2821  		(sessionNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;activeView&quot;), static_cast&lt;int32_t&gt;(session._activeView));
2822  		struct ViewElem {
2823  			TiXmlNode *viewNode;
2824  			vector&lt;sessionFileInfo&gt; *viewFiles;
2825  			size_t activeIndex;
2826  		};
2827  		const int nbElem = 2;
2828  		ViewElem viewElems[nbElem];
2829  		viewElems[0].viewNode = sessionNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;mainView&quot;)));
2830  		viewElems[1].viewNode = sessionNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;subView&quot;)));
2831  		viewElems[0].viewFiles = (vector&lt;sessionFileInfo&gt; *)(&amp;(session._mainViewFiles));
2832  		viewElems[1].viewFiles = (vector&lt;sessionFileInfo&gt; *)(&amp;(session._subViewFiles));
2833  		viewElems[0].activeIndex = session._activeMainIndex;
2834  		viewElems[1].activeIndex = session._activeSubIndex;
2835  		for (size_t k = 0; k &lt; nbElem ; ++k)
2836  		{
2837  			(viewElems[k].viewNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;activeIndex&quot;), static_cast&lt;int32_t&gt;(viewElems[k].activeIndex));
2838  			vector&lt;sessionFileInfo&gt; &amp; viewSessionFiles = *(viewElems[k].viewFiles);
2839  			for (size_t i = 0, len = viewElems[k].viewFiles-&gt;size(); i &lt; len ; ++i)
2840  			{
2841  				TiXmlNode *fileNameNode = viewElems[k].viewNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;File&quot;)));
2842  				TCHAR szInt64[64];
2843  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;firstVisibleLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._firstVisibleLine), szInt64, 10));
2844  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;xOffset&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._xOffset), szInt64, 10));
2845  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;scrollWidth&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._scrollWidth), szInt64, 10));
2846  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;startPos&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._startPos), szInt64, 10));
2847  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;endPos&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._endPos), szInt64, 10));
2848  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;selMode&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._selMode), szInt64, 10));
2849  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;offset&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._offset), szInt64, 10));
2850  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;wrapCount&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._wrapCount), szInt64, 10));
2851  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;lang&quot;), viewSessionFiles[i]._langName.c_str());
2852  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;encoding&quot;), viewSessionFiles[i]._encoding);
2853  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;userReadOnly&quot;), (viewSessionFiles[i]._isUserReadOnly &amp;&amp; !viewSessionFiles[i]._isMonitoring) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
2854  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;filename&quot;), viewSessionFiles[i]._fileName.c_str());
2855  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;backupFilePath&quot;), viewSessionFiles[i]._backupFilePath.c_str());
2856  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;originalFileLastModifTimestamp&quot;), static_cast&lt;int32_t&gt;(viewSessionFiles[i]._originalFileLastModifTimestamp.dwLowDateTime));
2857  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;originalFileLastModifTimestampHigh&quot;), static_cast&lt;int32_t&gt;(viewSessionFiles[i]._originalFileLastModifTimestamp.dwHighDateTime));
2858  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;tabColourId&quot;), static_cast&lt;int32_t&gt;(viewSessionFiles[i]._individualTabColour));
2859  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapFirstVisibleDisplayLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._firstVisibleDisplayLine), szInt64, 10));
2860  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapFirstVisibleDocLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._firstVisibleDocLine), szInt64, 10));
2861  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapLastVisibleDocLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._lastVisibleDocLine), szInt64, 10));
2862  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapNbLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._nbLine), szInt64, 10));
2863  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapHigherPos&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._higherPos), szInt64, 10));
2864  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapWidth&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._width), szInt64, 10));
2865  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapHeight&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._height), szInt64, 10));
2866  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapKByteInDoc&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._KByteInDoc), szInt64, 10));
2867  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapWrapIndentMode&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._wrapIndentMode), szInt64, 10));
2868  				fileNameNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;mapIsWrap&quot;), viewSessionFiles[i]._mapPos._isWrap ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
2869  				for (size_t j = 0, len = viewSessionFiles[i]._marks.size() ; j &lt; len ; ++j)
2870  				{
2871  					size_t markLine = viewSessionFiles[i]._marks[j];
2872  					TiXmlNode *markNode = fileNameNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Mark&quot;)));
2873  					markNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;line&quot;), _ui64tot(static_cast&lt;ULONGLONG&gt;(markLine), szInt64, 10));
2874  				}
2875  				for (size_t j = 0, len = viewSessionFiles[i]._foldStates.size() ; j &lt; len ; ++j)
2876  				{
2877  					size_t foldLine = viewSessionFiles[i]._foldStates[j];
2878  					TiXmlNode *foldNode = fileNameNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Fold&quot;)));
2879  					foldNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;line&quot;), _ui64tot(static_cast&lt;ULONGLONG&gt;(foldLine), szInt64, 10));
2880  				}
2881  			}
2882  		}
2883  		if (session._includeFileBrowser)
2884  		{
2885  			TiXmlNode* fileBrowserRootNode = sessionNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;FileBrowser&quot;)));
2886  			fileBrowserRootNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;latestSelectedItem&quot;), session._fileBrowserSelectedItem.c_str());
2887  			for (const auto&amp; root : session._fileBrowserRoots)
2888  			{
2889  				TiXmlNode *fileNameNode = fileBrowserRootNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;root&quot;)));
2890  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;foldername&quot;), root.c_str());
2891  			}
2892  		}
2893  	}
2894  	bool sessionSaveOK = pXmlSessionDoc-&gt;SaveFile();
2895  	if (sessionSaveOK)
2896  	{
2897  		TiXmlDocument* pXmlSessionCheck = new TiXmlDocument(sessionPathName);
2898  		sessionSaveOK = pXmlSessionCheck-&gt;LoadFile();
2899  		delete pXmlSessionCheck;
2900  	}
2901  	if (!sessionSaveOK)
2902  	{
2903  		if (backupPathName[0]) 
2904  		{
2905  			_pNativeLangSpeaker-&gt;messageBox(&quot;ErrorOfSavingSessionFile&quot;,
2906  				nullptr,
2907  				TEXT(&quot;The old session file will be restored.&quot;),
2908  				TEXT(&quot;Error of saving session file&quot;),
2909  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2910  			wstring sessionPathNameFail2Load = sessionPathName;
2911  			sessionPathNameFail2Load += L&quot;.fail2Load&quot;;
2912  			MoveFileEx(sessionPathName, sessionPathNameFail2Load.c_str(), MOVEFILE_REPLACE_EXISTING);
2913  			CopyFile(backupPathName, sessionPathName, FALSE);
2914  		}
2915  	}
2916  	else
2917  	{
2918  		if (backupPathName[0]) 
2919  		{
2920  			::DeleteFile(backupPathName);
2921  		}
2922  	}
2923  	delete pXmlSessionDoc;
2924  }
2925  void NppParameters::writeShortcuts()
2926  {
2927  	if (!_isAnyShortcutModified) return;
2928  	if (!_pXmlShortcutDocA)
2929  	{
2930  		_pXmlShortcutDocA = new TiXmlDocumentA();
2931  		TiXmlDeclarationA* decl = new TiXmlDeclarationA(&quot;1.0&quot;, &quot;UTF-8&quot;, &quot;&quot;);
2932  		_pXmlShortcutDocA-&gt;LinkEndChild(decl);
2933  	}
2934  	else
2935  	{
2936  		wchar_t v852NoNeedShortcutsBackup[MAX_PATH]{};
2937  		::wcscpy_s(v852NoNeedShortcutsBackup, _shortcutsPath.c_str());
2938  		::PathRemoveFileSpec(v852NoNeedShortcutsBackup);
2939  		::PathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
2940  		if (!::PathFileExists(v852NoNeedShortcutsBackup))
2941  		{
2942  			HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
2943  			::FlushFileBuffers(hFile);
2944  			::CloseHandle(hFile);
2945  			wstring v852ShortcutsBackupPath = _shortcutsPath;
2946  			v852ShortcutsBackupPath += L&quot;.v8.5.2.backup&quot;;
2947  			::CopyFile(_shortcutsPath.c_str(), v852ShortcutsBackupPath.c_str(), TRUE);
2948  			_pNativeLangSpeaker-&gt;messageBox(&quot;MacroAndRunCmdlWarning&quot;,
2949  				nullptr,
2950  				TEXT(&quot;Your Macro and Run commands saved in Notepad++ v.8.5.2 (or older) may not be compatible with the current version of Notepad++.\nPlease test those commands and, if needed, re-edit them.\n\nAlternatively, you can downgrade to Notepad++ v8.5.2 and restore your previous data.\nNotepad++ will backup your old \&quot;shortcuts.xml\&quot; and save it as \&quot;shortcuts.xml.v8.5.2.backup\&quot;.\nRenaming \&quot;shortcuts.xml.v8.5.2.backup\&quot; -&gt; \&quot;shortcuts.xml\&quot;, your commands should be restored and work properly.&quot;),
2951  				TEXT(&quot;Macro and Run Commands Compatibility&quot;),
2952  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2953  		}
2954  	}
2955  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
2956  	if (!root)
2957  	{
2958  		root = _pXmlShortcutDocA-&gt;InsertEndChild(TiXmlElementA(&quot;NotepadPlus&quot;));
2959  	}
2960  	TiXmlNodeA *cmdRoot = root-&gt;FirstChild(&quot;InternalCommands&quot;);
2961  	if (cmdRoot)
2962  		root-&gt;RemoveChild(cmdRoot);
2963  	cmdRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;InternalCommands&quot;));
2964  	for (size_t i = 0, len = _customizedShortcuts.size(); i &lt; len ; ++i)
2965  	{
2966  		size_t index = _customizedShortcuts[i];
2967  		CommandShortcut csc = _shortcuts[index];
2968  		insertCmd(cmdRoot, csc);
2969  	}
2970  	TiXmlNodeA *macrosRoot = root-&gt;FirstChild(&quot;Macros&quot;);
2971  	if (macrosRoot)
2972  		root-&gt;RemoveChild(macrosRoot);
2973  	macrosRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;Macros&quot;));
2974  	for (size_t i = 0, len = _macros.size(); i &lt; len ; ++i)
2975  	{
2976  		insertMacro(macrosRoot, _macros[i], wstring2string(_macroMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2977  	}
2978  	TiXmlNodeA *userCmdRoot = root-&gt;FirstChild(&quot;UserDefinedCommands&quot;);
2979  	if (userCmdRoot)
2980  		root-&gt;RemoveChild(userCmdRoot);
2981  	userCmdRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;UserDefinedCommands&quot;));
2982  	for (size_t i = 0, len = _userCommands.size(); i &lt; len ; ++i)
2983  	{
2984  		insertUserCmd(userCmdRoot, _userCommands[i], wstring2string(_runMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2985  	}
2986  	TiXmlNodeA *pluginCmdRoot = root-&gt;FirstChild(&quot;PluginCommands&quot;);
2987  	if (pluginCmdRoot)
2988  		root-&gt;RemoveChild(pluginCmdRoot);
2989  	pluginCmdRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;PluginCommands&quot;));
2990  	for (size_t i = 0, len = _pluginCustomizedCmds.size(); i &lt; len ; ++i)
2991  	{
2992  		insertPluginCmd(pluginCmdRoot, _pluginCommands[_pluginCustomizedCmds[i]]);
2993  	}
2994  	TiXmlNodeA *scitillaKeyRoot = root-&gt;FirstChild(&quot;ScintillaKeys&quot;);
2995  	if (scitillaKeyRoot)
2996  		root-&gt;RemoveChild(scitillaKeyRoot);
2997  	scitillaKeyRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;ScintillaKeys&quot;));
2998  	for (size_t i = 0, len = _scintillaModifiedKeyIndices.size(); i &lt; len ; ++i)
2999  	{
3000  		insertScintKey(scitillaKeyRoot, _scintillaKeyCommands[_scintillaModifiedKeyIndices[i]]);
3001  	}
3002  	_pXmlShortcutDocA-&gt;SaveUnicodeFilePath(_shortcutsPath.c_str());
3003  }
3004  int NppParameters::addUserLangToEnd(const UserLangContainer &amp; userLang, const TCHAR *newName)
3005  {
3006  	if (isExistingUserLangName(newName))
3007  		return -1;
3008  	unsigned char iBegin = _nbUserLang;
3009  	_userLangArray[_nbUserLang] = new UserLangContainer();
3010  	*(_userLangArray[_nbUserLang]) = userLang;
3011  	_userLangArray[_nbUserLang]-&gt;_name = newName;
3012  	++_nbUserLang;
3013  	unsigned char iEnd = _nbUserLang;
3014  	_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, make_pair(iBegin, iEnd)));
3015  	setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
3016  	return _nbUserLang-1;
3017  }
3018  void NppParameters::removeUserLang(size_t index)
3019  {
3020  	if (static_cast&lt;int32_t&gt;(index) &gt;= _nbUserLang)
3021  		return;
3022  	delete _userLangArray[index];
3023  	for (int32_t i = static_cast&lt;int32_t&gt;(index); i &lt; (_nbUserLang - 1); ++i)
3024  		_userLangArray[i] = _userLangArray[i+1];
3025  	_nbUserLang--;
3026  	removeIndexFromXmlUdls(index);
3027  }
3028  void NppParameters::feedUserSettings(TiXmlNode *settingsRoot)
3029  {
3030  	const TCHAR *boolStr;
3031  	TiXmlNode *globalSettingNode = settingsRoot-&gt;FirstChildElement(TEXT(&quot;Global&quot;));
3032  	if (globalSettingNode)
3033  	{
3034  		boolStr = (globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;caseIgnored&quot;));
3035  		if (boolStr)
3036  			_userLangArray[_nbUserLang - 1]-&gt;_isCaseIgnored = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3037  		boolStr = (globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;allowFoldOfComments&quot;));
3038  		if (boolStr)
3039  			_userLangArray[_nbUserLang - 1]-&gt;_allowFoldOfComments = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3040  		(globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;forcePureLC&quot;), &amp;_userLangArray[_nbUserLang - 1]-&gt;_forcePureLC);
3041  		(globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;decimalSeparator&quot;), &amp;_userLangArray[_nbUserLang - 1]-&gt;_decimalSeparator);
3042  		boolStr = (globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;foldCompact&quot;));
3043  		if (boolStr)
3044  			_userLangArray[_nbUserLang - 1]-&gt;_foldCompact = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3045  	}
3046  	TiXmlNode *prefixNode = settingsRoot-&gt;FirstChildElement(TEXT(&quot;Prefix&quot;));
3047  	if (prefixNode)
3048  	{
3049  		const TCHAR *udlVersion = _userLangArray[_nbUserLang - 1]-&gt;_udlVersion.c_str();
3050  		if (!lstrcmp(udlVersion, TEXT(&quot;2.1&quot;)) || !lstrcmp(udlVersion, TEXT(&quot;2.0&quot;)))
3051  		{
3052  			for (int i = 0 ; i &lt; SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
3053  			{
3054  				boolStr = (prefixNode-&gt;ToElement())-&gt;Attribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1]);
3055  				if (boolStr)
3056  					_userLangArray[_nbUserLang - 1]-&gt;_isPrefix[i] = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3057  			}
3058  		}
3059  		else	
3060  		{
3061  			TCHAR names[SCE_USER_TOTAL_KEYWORD_GROUPS][7] = {TEXT(&quot;words1&quot;), TEXT(&quot;words2&quot;), TEXT(&quot;words3&quot;), TEXT(&quot;words4&quot;)};
3062  			for (int i = 0 ; i &lt; 4 ; ++i)
3063  			{
3064  				boolStr = (prefixNode-&gt;ToElement())-&gt;Attribute(names[i]);
3065  				if (boolStr)
3066  					_userLangArray[_nbUserLang - 1]-&gt;_isPrefix[i] = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3067  			}
3068  		}
3069  	}
3070  }
3071  void NppParameters::feedUserKeywordList(TiXmlNode *node)
3072  {
3073  	const TCHAR * udlVersion = _userLangArray[_nbUserLang - 1]-&gt;_udlVersion.c_str();
3074  	int id = -1;
3075  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;Keywords&quot;));
3076  		childNode ;
3077  		childNode = childNode-&gt;NextSibling(TEXT(&quot;Keywords&quot;)))
3078  	{
3079  		const TCHAR * keywordsName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
3080  		TiXmlNode *valueNode = childNode-&gt;FirstChild();
3081  		if (valueNode)
3082  		{
3083  			const TCHAR *kwl = nullptr;
3084  			if (!lstrcmp(udlVersion, TEXT(&quot;&quot;)) &amp;&amp; !lstrcmp(keywordsName, TEXT(&quot;Delimiters&quot;)))	
3085  			{
3086  				basic_string&lt;TCHAR&gt; temp;
3087  				kwl = (valueNode)?valueNode-&gt;Value():TEXT(&quot;000000&quot;);
3088  				temp += TEXT(&quot;00&quot;);	 if (kwl[0] != &#x27;0&#x27;) temp += kwl[0];	 temp += TEXT(&quot; 01&quot;);
3089  				temp += TEXT(&quot; 02&quot;);	if (kwl[3] != &#x27;0&#x27;) temp += kwl[3];
3090  				temp += TEXT(&quot; 03&quot;);	if (kwl[1] != &#x27;0&#x27;) temp += kwl[1];	 temp += TEXT(&quot; 04&quot;);
3091  				temp += TEXT(&quot; 05&quot;);	if (kwl[4] != &#x27;0&#x27;) temp += kwl[4];
3092  				temp += TEXT(&quot; 06&quot;);	if (kwl[2] != &#x27;0&#x27;) temp += kwl[2];	 temp += TEXT(&quot; 07&quot;);
3093  				temp += TEXT(&quot; 08&quot;);	if (kwl[5] != &#x27;0&#x27;) temp += kwl[5];
3094  				temp += TEXT(&quot; 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23&quot;);
3095  				wcscpy_s(_userLangArray[_nbUserLang - 1]-&gt;_keywordLists[SCE_USER_KWLIST_DELIMITERS], temp.c_str());
3096  			}
3097  			else if (!lstrcmp(keywordsName, TEXT(&quot;Comment&quot;)))
3098  			{
3099  				kwl = (valueNode)?valueNode-&gt;Value():TEXT(&quot;&quot;);
3100  				basic_string&lt;TCHAR&gt; temp{TEXT(&quot; &quot;)};
3101  				temp += kwl;
3102  				size_t pos = 0;
3103  				pos = temp.find(TEXT(&quot; 0&quot;));
3104  				while (pos != string::npos)
3105  				{
3106  					temp.replace(pos, 2, TEXT(&quot; 00&quot;));
3107  					pos = temp.find(TEXT(&quot; 0&quot;), pos+1);
3108  				}
3109  				pos = temp.find(TEXT(&quot; 1&quot;));
3110  				while (pos != string::npos)
3111  				{
3112  					temp.replace(pos, 2, TEXT(&quot; 03&quot;));
3113  					pos = temp.find(TEXT(&quot; 1&quot;));
3114  				}
3115  				pos = temp.find(TEXT(&quot; 2&quot;));
3116  				while (pos != string::npos)
3117  				{
3118  					temp.replace(pos, 2, TEXT(&quot; 04&quot;));
3119  					pos = temp.find(TEXT(&quot; 2&quot;));
3120  				}
3121  				temp += TEXT(&quot; 01 02&quot;);
3122  				if (temp[0] == &#x27; &#x27;)
3123  					temp.erase(0, 1);
3124  				wcscpy_s(_userLangArray[_nbUserLang - 1]-&gt;_keywordLists[SCE_USER_KWLIST_COMMENTS], temp.c_str());
3125  			}
3126  			else
3127  			{
3128  				kwl = (valueNode)?valueNode-&gt;Value():TEXT(&quot;&quot;);
3129  				if (globalMappper().keywordIdMapper.find(keywordsName) != globalMappper().keywordIdMapper.end())
3130  				{
3131  					id = globalMappper().keywordIdMapper[keywordsName];
3132  					if (wcslen(kwl) &lt; max_char)
3133  					{
3134  						wcscpy_s(_userLangArray[_nbUserLang - 1]-&gt;_keywordLists[id], kwl);
3135  					}
3136  					else
3137  					{
3138  						wcscpy_s(_userLangArray[_nbUserLang - 1]-&gt;_keywordLists[id], TEXT(&quot;imported string too long, needs to be &lt; max_char(30720)&quot;));
3139  					}
3140  				}
3141  			}
3142  		}
3143  	}
3144  }
3145  void NppParameters::feedUserStyles(TiXmlNode *node)
3146  {
3147  	int id = -1;
3148  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;WordsStyle&quot;));
3149  		childNode ;
3150  		childNode = childNode-&gt;NextSibling(TEXT(&quot;WordsStyle&quot;)))
3151  	{
3152  		const TCHAR *styleName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
3153  		if (styleName)
3154  		{
3155  			if (globalMappper().styleIdMapper.find(styleName) != globalMappper().styleIdMapper.end())
3156  			{
3157  				id = globalMappper().styleIdMapper[styleName];
3158  				_userLangArray[_nbUserLang - 1]-&gt;_styles.addStyler((id | L_USER &lt;&lt; 16), childNode);
3159  			}
3160  		}
3161  	}
3162  }
3163  bool NppParameters::feedStylerArray(TiXmlNode *node)
3164  {
3165  	TiXmlNode *styleRoot = node-&gt;FirstChildElement(TEXT(&quot;LexerStyles&quot;));
3166  	if (!styleRoot) return false;
3167  	for (TiXmlNode *childNode = styleRoot-&gt;FirstChildElement(TEXT(&quot;LexerType&quot;));
3168  		 childNode ;
3169  		 childNode = childNode-&gt;NextSibling(TEXT(&quot;LexerType&quot;)) )
3170  	{
3171  		TiXmlElement *element = childNode-&gt;ToElement();
3172  		const TCHAR *lexerName = element-&gt;Attribute(TEXT(&quot;name&quot;));
3173  		const TCHAR *lexerDesc = element-&gt;Attribute(TEXT(&quot;desc&quot;));
3174  		const TCHAR *lexerUserExt = element-&gt;Attribute(TEXT(&quot;ext&quot;));
3175  		const TCHAR *lexerExcluded = element-&gt;Attribute(TEXT(&quot;excluded&quot;));
3176  		if (lexerName)
3177  		{
3178  			_lexerStylerVect.addLexerStyler(lexerName, lexerDesc, lexerUserExt, childNode);
3179  			if (lexerExcluded != NULL &amp;&amp; (lstrcmp(lexerExcluded, TEXT(&quot;yes&quot;)) == 0))
3180  			{
3181  				int index = getExternalLangIndexFromName(lexerName);
3182  				if (index != -1)
3183  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)(index + L_EXTERNAL)));
3184  			}
3185  		}
3186  	}
3187  	_lexerStylerVect.sort();
3188  	TiXmlNode *globalStyleRoot = node-&gt;FirstChildElement(TEXT(&quot;GlobalStyles&quot;));
3189  	if (!globalStyleRoot) return false;
3190  	for (TiXmlNode *childNode = globalStyleRoot-&gt;FirstChildElement(TEXT(&quot;WidgetStyle&quot;));
3191  		 childNode ;
3192  		 childNode = childNode-&gt;NextSibling(TEXT(&quot;WidgetStyle&quot;)) )
3193  	{
3194  		TiXmlElement *element = childNode-&gt;ToElement();
3195  		const TCHAR *styleIDStr = element-&gt;Attribute(TEXT(&quot;styleID&quot;));
3196  		int styleID = -1;
3197  		if ((styleID = decStrVal(styleIDStr)) != -1)
3198  		{
3199  			_widgetStyleArray.addStyler(styleID, childNode);
3200  		}
3201  	}
3202  	constexpr auto rgbhex = [](COLORREF bbggrr) -&gt; int {
3203  		return
3204  			((bbggrr &amp; 0xFF0000) &gt;&gt; 16) |
3205  			((bbggrr &amp; 0x00FF00)) |
3206  			((bbggrr &amp; 0x0000FF) &lt;&lt; 16);
3207  	};
3208  	const Style* pStyle = _widgetStyleArray.findByName(TEXT(&quot;EOL custom color&quot;));
3209  	if (!pStyle)
3210  	{
3211  		TiXmlNode* eolColorkNode = globalStyleRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;WidgetStyle&quot;)));
3212  		eolColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;EOL custom color&quot;));
3213  		eolColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;styleID&quot;), TEXT(&quot;0&quot;));
3214  		eolColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;fgColor&quot;), TEXT(&quot;DADADA&quot;));
3215  		_widgetStyleArray.addStyler(0, eolColorkNode);
3216  	}
3217  	const Style* pStyleNpc = _widgetStyleArray.findByName(g_npcStyleName);
3218  	if (!pStyleNpc)
3219  	{
3220  		TiXmlNode* npcColorkNode = globalStyleRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;WidgetStyle&quot;)));
3221  		npcColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;name&quot;), g_npcStyleName);
3222  		npcColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;styleID&quot;), TEXT(&quot;0&quot;));
3223  		const Style* pStyleWS = _widgetStyleArray.findByName(TEXT(&quot;White space symbol&quot;));
3224  		if (pStyleWS)
3225  		{
3226  			constexpr size_t bufSize = 7;
3227  			wchar_t strColor[bufSize] = { &#x27;\0&#x27; };
3228  			swprintf(strColor, bufSize, L&quot;%6X&quot;, rgbhex(pStyleWS-&gt;_fgColor));
3229  			npcColorkNode-&gt;ToElement()-&gt;SetAttribute(L&quot;fgColor&quot;, strColor);
3230  		}
3231  		else
3232  		{
3233  			npcColorkNode-&gt;ToElement()-&gt;SetAttribute(L&quot;fgColor&quot;, L&quot;DADADA&quot;);
3234  		}
3235  		_widgetStyleArray.addStyler(0, npcColorkNode);
3236  	}
3237  	return true;
3238  }
3239  void LexerStylerArray::addLexerStyler(const TCHAR *lexerName, const TCHAR *lexerDesc, const TCHAR *lexerUserExt , TiXmlNode *lexerNode)
3240  {
3241  	_lexerStylerVect.emplace_back();
3242  	LexerStyler &amp; ls = _lexerStylerVect.back();
3243  	ls.setLexerName(lexerName);
3244  	if (lexerDesc)
3245  		ls.setLexerDesc(lexerDesc);
3246  	if (lexerUserExt)
3247  		ls.setLexerUserExt(lexerUserExt);
3248  	for (TiXmlNode *childNode = lexerNode-&gt;FirstChildElement(TEXT(&quot;WordsStyle&quot;));
3249  		 childNode ;
3250  		 childNode = childNode-&gt;NextSibling(TEXT(&quot;WordsStyle&quot;)) )
3251  	{
3252  		TiXmlElement *element = childNode-&gt;ToElement();
3253  		const TCHAR *styleIDStr = element-&gt;Attribute(TEXT(&quot;styleID&quot;));
3254  		if (styleIDStr)
3255  		{
3256  			int styleID = -1;
3257  			if ((styleID = decStrVal(styleIDStr)) != -1)
3258  			{
3259  				ls.addStyler(styleID, childNode);
3260  			}
3261  		}
3262  	}
3263  }
3264  void StyleArray::addStyler(int styleID, TiXmlNode *styleNode)
3265  {
3266  	bool isUser = styleID &gt;&gt; 16 == L_USER;
3267  	if (isUser)
3268  	{
3269  		styleID = (styleID &amp; 0xFFFF);
3270  		if (styleID &gt;= SCE_USER_STYLE_TOTAL_STYLES || findByID(styleID))
3271  			return;
3272  	}
3273  	_styleVect.emplace_back();
3274  	Style &amp; s = _styleVect.back();
3275  	s._styleID = styleID;
3276  	if (styleNode)
3277  	{
3278  		TiXmlElement *element = styleNode-&gt;ToElement();
3279  		const TCHAR *str = element-&gt;Attribute(TEXT(&quot;name&quot;));
3280  		if (str)
3281  		{
3282  			if (isUser)
3283  				s._styleDesc = globalMappper().styleNameMapper[styleID];
3284  			else
3285  				s._styleDesc = str;
3286  		}
3287  		str = element-&gt;Attribute(TEXT(&quot;fgColor&quot;));
3288  		if (str)
3289  		{
3290  			unsigned long result = hexStrVal(str);
3291  			s._fgColor = (RGB((result &gt;&gt; 16) &amp; 0xFF, (result &gt;&gt; 8) &amp; 0xFF, result &amp; 0xFF)) | (result &amp; 0xFF000000);
3292  		}
3293  		str = element-&gt;Attribute(TEXT(&quot;bgColor&quot;));
3294  		if (str)
3295  		{
3296  			unsigned long result = hexStrVal(str);
3297  			s._bgColor = (RGB((result &gt;&gt; 16) &amp; 0xFF, (result &gt;&gt; 8) &amp; 0xFF, result &amp; 0xFF)) | (result &amp; 0xFF000000);
3298  		}
3299  		str = element-&gt;Attribute(TEXT(&quot;colorStyle&quot;));
3300  		if (str)
3301  		{
3302  			s._colorStyle = decStrVal(str);
3303  		}
3304  		str = element-&gt;Attribute(TEXT(&quot;fontName&quot;));
3305  		if (str)
3306  		{
3307  			s._fontName = str;
3308  			s._isFontEnabled = true;
3309  		}
3310  		str = element-&gt;Attribute(TEXT(&quot;fontStyle&quot;));
3311  		if (str)
3312  		{
3313  			s._fontStyle = decStrVal(str);
3314  		}
3315  		str = element-&gt;Attribute(TEXT(&quot;fontSize&quot;));
3316  		if (str)
3317  		{
3318  			s._fontSize = decStrVal(str);
3319  		}
3320  		str = element-&gt;Attribute(TEXT(&quot;nesting&quot;));
3321  		if (str)
3322  		{
3323  			s._nesting = decStrVal(str);
3324  		}
3325  		str = element-&gt;Attribute(TEXT(&quot;keywordClass&quot;));
3326  		if (str)
3327  		{
3328  			s._keywordClass = getKwClassFromName(str);
3329  		}
3330  		TiXmlNode *v = styleNode-&gt;FirstChild();
3331  		if (v)
3332  		{
3333  			s._keywords = v-&gt;Value();
3334  		}
3335  	}
3336  }
3337  bool NppParameters::writeRecentFileHistorySettings(int nbMaxFile) const
3338  {
3339  	if (!_pXmlUserDoc) return false;
3340  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3341  	if (!nppRoot)
3342  	{
3343  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3344  	}
3345  	TiXmlNode *historyNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;History&quot;));
3346  	if (!historyNode)
3347  	{
3348  		historyNode = nppRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;History&quot;)));
3349  	}
3350  	(historyNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFile&quot;), nbMaxFile!=-1?nbMaxFile:_nbMaxRecentFile);
3351  	(historyNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;inSubMenu&quot;), _putRecentFileInSubMenu?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
3352  	(historyNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;customLength&quot;), _recentFileCustomLength);
3353  	return true;
3354  }
3355  bool NppParameters::writeColumnEditorSettings() const
3356  {
3357  	if (!_pXmlUserDoc) return false;
3358  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3359  	if (!nppRoot)
3360  	{
3361  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3362  	}
3363  	TiXmlNode *oldColumnEditorNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;ColumnEditor&quot;));
3364  	if (oldColumnEditorNode)
3365  	{
3366  		nppRoot-&gt;RemoveChild(oldColumnEditorNode);
3367  	}
3368  	TiXmlElement columnEditorRootNode{TEXT(&quot;ColumnEditor&quot;)};
3369  	(columnEditorRootNode.ToElement())-&gt;SetAttribute(TEXT(&quot;choice&quot;), _columnEditParam._mainChoice == activeNumeric ? L&quot;number&quot; : L&quot;text&quot;);
3370  	TiXmlElement textNode{ TEXT(&quot;text&quot;) };
3371  	(textNode.ToElement())-&gt;SetAttribute(TEXT(&quot;content&quot;), _columnEditParam._insertedTextContent.c_str());
3372  	(columnEditorRootNode.ToElement())-&gt;InsertEndChild(textNode);
3373  	TiXmlElement numberNode{ TEXT(&quot;number&quot;) };
3374  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;initial&quot;), _columnEditParam._initialNum);
3375  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;increase&quot;), _columnEditParam._increaseNum);
3376  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;repeat&quot;), _columnEditParam._repeatNum);
3377  	wstring format = TEXT(&quot;dec&quot;);
3378  	if (_columnEditParam._formatChoice == 1)
3379  		format = TEXT(&quot;hex&quot;);
3380  	else if (_columnEditParam._formatChoice == 2)
3381  		format = TEXT(&quot;oct&quot;);
3382  	else if (_columnEditParam._formatChoice == 3)
3383  		format = TEXT(&quot;bin&quot;);
3384  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;formatChoice&quot;), format);
3385  	wstring leading = TEXT(&quot;none&quot;);
3386  	if (_columnEditParam._leadingChoice == ColumnEditorParam::zeroLeading)
3387  		leading = TEXT(&quot;zeros&quot;);
3388  	else if (_columnEditParam._leadingChoice == ColumnEditorParam::spaceLeading)
3389  		leading = TEXT(&quot;spaces&quot;);
3390  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;leadingChoice&quot;), leading);
3391  	(columnEditorRootNode.ToElement())-&gt;InsertEndChild(numberNode);
3392  	(nppRoot-&gt;ToElement())-&gt;InsertEndChild(columnEditorRootNode);
3393  	return true;
3394  }
3395  bool NppParameters::writeProjectPanelsSettings() const
3396  {
3397  	if (!_pXmlUserDoc) return false;
3398  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3399  	if (!nppRoot)
3400  	{
3401  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3402  	}
3403  	TiXmlNode *oldProjPanelRootNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;ProjectPanels&quot;));
3404  	if (oldProjPanelRootNode)
3405  	{
3406  		nppRoot-&gt;RemoveChild(oldProjPanelRootNode);
3407  	}
3408  	TiXmlElement projPanelRootNode{TEXT(&quot;ProjectPanels&quot;)};
3409  	for (int32_t i = 0 ; i &lt; 3 ; ++i)
3410  	{
3411  		TiXmlElement projPanelNode{TEXT(&quot;ProjectPanel&quot;)};
3412  		(projPanelNode.ToElement())-&gt;SetAttribute(TEXT(&quot;id&quot;), i);
3413  		(projPanelNode.ToElement())-&gt;SetAttribute(TEXT(&quot;workSpaceFile&quot;), _workSpaceFilePathes[i]);
3414  		(projPanelRootNode.ToElement())-&gt;InsertEndChild(projPanelNode);
3415  	}
3416  	(nppRoot-&gt;ToElement())-&gt;InsertEndChild(projPanelRootNode);
3417  	return true;
3418  }
3419  bool NppParameters::writeFileBrowserSettings(const vector&lt;generic_string&gt; &amp; rootPaths, const generic_string &amp; latestSelectedItemPath) const
3420  {
3421  	if (!_pXmlUserDoc) return false;
3422  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3423  	if (!nppRoot)
3424  	{
3425  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3426  	}
3427  	TiXmlNode *oldFileBrowserRootNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;FileBrowser&quot;));
3428  	if (oldFileBrowserRootNode)
3429  	{
3430  		nppRoot-&gt;RemoveChild(oldFileBrowserRootNode);
3431  	}
3432  	TiXmlElement fileBrowserRootNode{ TEXT(&quot;FileBrowser&quot;) };
3433  	if (rootPaths.size() != 0)
3434  	{
3435  		fileBrowserRootNode.SetAttribute(TEXT(&quot;latestSelectedItem&quot;), latestSelectedItemPath.c_str());
3436  		size_t len = rootPaths.size();
3437  		for (size_t i = 0; i &lt; len; ++i)
3438  		{
3439  			TiXmlElement fbRootNode{ TEXT(&quot;root&quot;) };
3440  			(fbRootNode.ToElement())-&gt;SetAttribute(TEXT(&quot;foldername&quot;), rootPaths[i].c_str());
3441  			(fileBrowserRootNode.ToElement())-&gt;InsertEndChild(fbRootNode);
3442  		}
3443  	}
3444  	(nppRoot-&gt;ToElement())-&gt;InsertEndChild(fileBrowserRootNode);
3445  	return true;
3446  }
3447  bool NppParameters::writeHistory(const TCHAR *fullpath)
3448  {
3449  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3450  	if (!nppRoot)
3451  	{
3452  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3453  	}
3454  	TiXmlNode *historyNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;History&quot;));
3455  	if (!historyNode)
3456  	{
3457  		historyNode = nppRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;History&quot;)));
3458  	}
3459  	TiXmlElement recentFileNode(TEXT(&quot;File&quot;));
3460  	(recentFileNode.ToElement())-&gt;SetAttribute(TEXT(&quot;filename&quot;), fullpath);
3461  	(historyNode-&gt;ToElement())-&gt;InsertEndChild(recentFileNode);
3462  	return true;
3463  }
3464  TiXmlNode * NppParameters::getChildElementByAttribut(TiXmlNode *pere, const TCHAR *childName,\
3465  			const TCHAR *attributName, const TCHAR *attributVal) const
3466  {
3467  	for (TiXmlNode *childNode = pere-&gt;FirstChildElement(childName);
3468  		childNode ;
3469  		childNode = childNode-&gt;NextSibling(childName))
3470  	{
3471  		TiXmlElement *element = childNode-&gt;ToElement();
3472  		const TCHAR *val = element-&gt;Attribute(attributName);
3473  		if (val)
3474  		{
3475  			if (!lstrcmp(val, attributVal))
3476  				return childNode;
3477  		}
3478  	}
3479  	return NULL;
3480  }
3481  LangType NppParameters::getLangIDFromStr(const TCHAR *langName)
3482  {
3483  	int lang = static_cast&lt;int32_t&gt;(L_TEXT);
3484  	for (; lang &lt; L_EXTERNAL; ++lang)
3485  	{
3486  		const TCHAR * name = ScintillaEditView::_langNameInfoArray[lang]._langName;
3487  		if (!lstrcmp(name, langName)) 
3488  		{
3489  			return (LangType)lang;
3490  		}
3491  	}
3492  	LangType l = (LangType)lang;
3493  	if (l == L_EXTERNAL) 
3494  	{
3495  		int id = NppParameters::getInstance().getExternalLangIndexFromName(langName);
3496  		if (id != -1) return (LangType)(id + L_EXTERNAL);
3497  	}
3498  	return L_TEXT;
3499  }
3500  generic_string NppParameters::getLocPathFromStr(const generic_string &amp; localizationCode)
3501  {
3502  	if (localizationCode == TEXT(&quot;en&quot;) || localizationCode == TEXT(&quot;en-au&quot;) || localizationCode == TEXT(&quot;en-bz&quot;) || localizationCode == TEXT(&quot;en-ca&quot;) || localizationCode == TEXT(&quot;en-cb&quot;) || localizationCode == TEXT(&quot;en-gb&quot;) || localizationCode == TEXT(&quot;en-ie&quot;) || localizationCode == TEXT(&quot;en-jm&quot;) || localizationCode == TEXT(&quot;en-nz&quot;) || localizationCode == TEXT(&quot;en-ph&quot;) || localizationCode == TEXT(&quot;en-tt&quot;) || localizationCode == TEXT(&quot;en-us&quot;) || localizationCode == TEXT(&quot;en-za&quot;) || localizationCode == TEXT(&quot;en-zw&quot;))
3503  		return TEXT(&quot;english.xml&quot;);
3504  	if (localizationCode == TEXT(&quot;af&quot;))
3505  		return TEXT(&quot;afrikaans.xml&quot;);
3506  	if (localizationCode == TEXT(&quot;sq&quot;))
3507  		return TEXT(&quot;albanian.xml&quot;);
3508  	if (localizationCode == TEXT(&quot;ar&quot;) || localizationCode == TEXT(&quot;ar-dz&quot;) || localizationCode == TEXT(&quot;ar-bh&quot;) || localizationCode == TEXT(&quot;ar-eg&quot;) ||localizationCode == TEXT(&quot;ar-iq&quot;) || localizationCode == TEXT(&quot;ar-jo&quot;) || localizationCode == TEXT(&quot;ar-kw&quot;) || localizationCode == TEXT(&quot;ar-lb&quot;) || localizationCode == TEXT(&quot;ar-ly&quot;) || localizationCode == TEXT(&quot;ar-ma&quot;) || localizationCode == TEXT(&quot;ar-om&quot;) || localizationCode == TEXT(&quot;ar-qa&quot;) || localizationCode == TEXT(&quot;ar-sa&quot;) || localizationCode == TEXT(&quot;ar-sy&quot;) || localizationCode == TEXT(&quot;ar-tn&quot;) || localizationCode == TEXT(&quot;ar-ae&quot;) || localizationCode == TEXT(&quot;ar-ye&quot;))
3509  		return TEXT(&quot;arabic.xml&quot;);
3510  	if (localizationCode == TEXT(&quot;an&quot;))
3511  		return TEXT(&quot;aragonese.xml&quot;);
3512  	if (localizationCode == TEXT(&quot;az&quot;))
3513  		return TEXT(&quot;azerbaijani.xml&quot;);
3514  	if (localizationCode == TEXT(&quot;eu&quot;))
3515  		return TEXT(&quot;basque.xml&quot;);
3516  	if (localizationCode == TEXT(&quot;be&quot;))
3517  		return TEXT(&quot;belarusian.xml&quot;);
3518  	if (localizationCode == TEXT(&quot;bn&quot;))
3519  		return TEXT(&quot;bengali.xml&quot;);
3520  	if (localizationCode == TEXT(&quot;bs&quot;))
3521  		return TEXT(&quot;bosnian.xml&quot;);
3522  	if (localizationCode == TEXT(&quot;pt-br&quot;))
3523  		return TEXT(&quot;brazilian_portuguese.xml&quot;);
3524  	if (localizationCode == TEXT(&quot;br-fr&quot;))
3525  		return TEXT(&quot;breton.xml&quot;);
3526  	if (localizationCode == TEXT(&quot;bg&quot;))
3527  		return TEXT(&quot;bulgarian.xml&quot;);
3528  	if (localizationCode == TEXT(&quot;ca&quot;))
3529  		return TEXT(&quot;catalan.xml&quot;);
3530  	if (localizationCode == TEXT(&quot;zh-tw&quot;) || localizationCode == TEXT(&quot;zh-hk&quot;) || localizationCode == TEXT(&quot;zh-sg&quot;))
3531  		return TEXT(&quot;taiwaneseMandarin.xml&quot;);
3532  	if (localizationCode == TEXT(&quot;zh&quot;) || localizationCode == TEXT(&quot;zh-cn&quot;))
3533  		return TEXT(&quot;chineseSimplified.xml&quot;);
3534  	if (localizationCode == TEXT(&quot;co&quot;) || localizationCode == TEXT(&quot;co-fr&quot;))
3535  		return TEXT(&quot;corsican.xml&quot;);
3536  	if (localizationCode == TEXT(&quot;hr&quot;))
3537  		return TEXT(&quot;croatian.xml&quot;);
3538  	if (localizationCode == TEXT(&quot;cs&quot;))
3539  		return TEXT(&quot;czech.xml&quot;);
3540  	if (localizationCode == TEXT(&quot;da&quot;))
3541  		return TEXT(&quot;danish.xml&quot;);
3542  	if (localizationCode == TEXT(&quot;nl&quot;) || localizationCode == TEXT(&quot;nl-be&quot;))
3543  		return TEXT(&quot;dutch.xml&quot;);
3544  	if (localizationCode == TEXT(&quot;eo&quot;))
3545  		return TEXT(&quot;esperanto.xml&quot;);
3546  	if (localizationCode == TEXT(&quot;et&quot;))
3547  		return TEXT(&quot;estonian.xml&quot;);
3548  	if (localizationCode == TEXT(&quot;fa&quot;))
3549  		return TEXT(&quot;farsi.xml&quot;);
3550  	if (localizationCode == TEXT(&quot;fi&quot;))
3551  		return TEXT(&quot;finnish.xml&quot;);
3552  	if (localizationCode == TEXT(&quot;fr&quot;) || localizationCode == TEXT(&quot;fr-be&quot;) || localizationCode == TEXT(&quot;fr-ca&quot;) || localizationCode == TEXT(&quot;fr-fr&quot;) || localizationCode == TEXT(&quot;fr-lu&quot;) || localizationCode == TEXT(&quot;fr-mc&quot;) || localizationCode == TEXT(&quot;fr-ch&quot;))
3553  		return TEXT(&quot;french.xml&quot;);
3554  	if (localizationCode == TEXT(&quot;fur&quot;))
3555  		return TEXT(&quot;friulian.xml&quot;);
3556  	if (localizationCode == TEXT(&quot;gl&quot;))
3557  		return TEXT(&quot;galician.xml&quot;);
3558  	if (localizationCode == TEXT(&quot;ka&quot;))
3559  		return TEXT(&quot;georgian.xml&quot;);
3560  	if (localizationCode == TEXT(&quot;de&quot;) || localizationCode == TEXT(&quot;de-at&quot;) || localizationCode == TEXT(&quot;de-de&quot;) || localizationCode == TEXT(&quot;de-li&quot;) || localizationCode == TEXT(&quot;de-lu&quot;) || localizationCode == TEXT(&quot;de-ch&quot;))
3561  		return TEXT(&quot;german.xml&quot;);
3562  	if (localizationCode == TEXT(&quot;el&quot;))
3563  		return TEXT(&quot;greek.xml&quot;);
3564  	if (localizationCode == TEXT(&quot;gu&quot;))
3565  		return TEXT(&quot;gujarati.xml&quot;);
3566  	if (localizationCode == TEXT(&quot;he&quot;))
3567  		return TEXT(&quot;hebrew.xml&quot;);
3568  	if (localizationCode == TEXT(&quot;hi&quot;))
3569  		return TEXT(&quot;hindi.xml&quot;);
3570  	if (localizationCode == TEXT(&quot;hu&quot;))
3571  		return TEXT(&quot;hungarian.xml&quot;);
3572  	if (localizationCode == TEXT(&quot;id&quot;))
3573  		return TEXT(&quot;indonesian.xml&quot;);
3574  	if (localizationCode == TEXT(&quot;it&quot;) || localizationCode == TEXT(&quot;it-ch&quot;))
3575  		return TEXT(&quot;italian.xml&quot;);
3576  	if (localizationCode == TEXT(&quot;ja&quot;))
3577  		return TEXT(&quot;japanese.xml&quot;);
3578  	if (localizationCode == TEXT(&quot;kn&quot;))
3579  		return TEXT(&quot;kannada.xml&quot;);
3580  	if (localizationCode == TEXT(&quot;kk&quot;))
3581  		return TEXT(&quot;kazakh.xml&quot;);
3582  	if (localizationCode == TEXT(&quot;ko&quot;) || localizationCode == TEXT(&quot;ko-kp&quot;) || localizationCode == TEXT(&quot;ko-kr&quot;))
3583  		return TEXT(&quot;korean.xml&quot;);
3584  	if (localizationCode == TEXT(&quot;ku&quot;))
3585  		return TEXT(&quot;kurdish.xml&quot;);
3586  	if (localizationCode == TEXT(&quot;ky&quot;))
3587  		return TEXT(&quot;kyrgyz.xml&quot;);
3588  	if (localizationCode == TEXT(&quot;lv&quot;))
3589  		return TEXT(&quot;latvian.xml&quot;);
3590  	if (localizationCode == TEXT(&quot;lt&quot;))
3591  		return TEXT(&quot;lithuanian.xml&quot;);
3592  	if (localizationCode == TEXT(&quot;lb&quot;))
3593  		return TEXT(&quot;luxembourgish.xml&quot;);
3594  	if (localizationCode == TEXT(&quot;mk&quot;))
3595  		return TEXT(&quot;macedonian.xml&quot;);
3596  	if (localizationCode == TEXT(&quot;ms&quot;))
3597  		return TEXT(&quot;malay.xml&quot;);
3598  	if (localizationCode == TEXT(&quot;mr&quot;))
3599  		return TEXT(&quot;marathi.xml&quot;);
3600  	if (localizationCode == TEXT(&quot;mn&quot;))
3601  		return TEXT(&quot;mongolian.xml&quot;);
3602  	if (localizationCode == TEXT(&quot;no&quot;) || localizationCode == TEXT(&quot;nb&quot;))
3603  		return TEXT(&quot;norwegian.xml&quot;);
3604  	if (localizationCode == TEXT(&quot;nn&quot;))
3605  		return TEXT(&quot;nynorsk.xml&quot;);
3606  	if (localizationCode == TEXT(&quot;oc&quot;))
3607  		return TEXT(&quot;occitan.xml&quot;);
3608  	if (localizationCode == TEXT(&quot;pl&quot;))
3609  		return TEXT(&quot;polish.xml&quot;);
3610  	if (localizationCode == TEXT(&quot;pt&quot;) || localizationCode == TEXT(&quot;pt-pt&quot;))
3611  		return TEXT(&quot;portuguese.xml&quot;);
3612  	if (localizationCode == TEXT(&quot;pa&quot;) || localizationCode == TEXT(&quot;pa-in&quot;))
3613  		return TEXT(&quot;punjabi.xml&quot;);
3614  	if (localizationCode == TEXT(&quot;ro&quot;) || localizationCode == TEXT(&quot;ro-mo&quot;))
3615  		return TEXT(&quot;romanian.xml&quot;);
3616  	if (localizationCode == TEXT(&quot;ru&quot;) || localizationCode == TEXT(&quot;ru-mo&quot;))
3617  		return TEXT(&quot;russian.xml&quot;);
3618  	if (localizationCode == TEXT(&quot;sc&quot;))
3619  		return TEXT(&quot;sardinian.xml&quot;);
3620  	if (localizationCode == TEXT(&quot;sr&quot;))
3621  		return TEXT(&quot;serbian.xml&quot;);
3622  	if (localizationCode == TEXT(&quot;sr-cyrl-ba&quot;) || localizationCode == TEXT(&quot;sr-cyrl-sp&quot;))
3623  		return TEXT(&quot;serbianCyrillic.xml&quot;);
3624  	if (localizationCode == TEXT(&quot;si&quot;))
3625  		return TEXT(&quot;sinhala.xml&quot;);
3626  	if (localizationCode == TEXT(&quot;sk&quot;))
3627  		return TEXT(&quot;slovak.xml&quot;);
3628  	if (localizationCode == TEXT(&quot;sl&quot;))
3629  		return TEXT(&quot;slovenian.xml&quot;);
3630  	if (localizationCode == TEXT(&quot;es&quot;) || localizationCode == TEXT(&quot;es-bo&quot;) || localizationCode == TEXT(&quot;es-cl&quot;) || localizationCode == TEXT(&quot;es-co&quot;) || localizationCode == TEXT(&quot;es-cr&quot;) || localizationCode == TEXT(&quot;es-do&quot;) || localizationCode == TEXT(&quot;es-ec&quot;) || localizationCode == TEXT(&quot;es-sv&quot;) || localizationCode == TEXT(&quot;es-gt&quot;) || localizationCode == TEXT(&quot;es-hn&quot;) || localizationCode == TEXT(&quot;es-mx&quot;) || localizationCode == TEXT(&quot;es-ni&quot;) || localizationCode == TEXT(&quot;es-pa&quot;) || localizationCode == TEXT(&quot;es-py&quot;) || localizationCode == TEXT(&quot;es-pe&quot;) || localizationCode == TEXT(&quot;es-pr&quot;) || localizationCode == TEXT(&quot;es-es&quot;) || localizationCode == TEXT(&quot;es-uy&quot;) || localizationCode == TEXT(&quot;es-ve&quot;))
3631  		return TEXT(&quot;spanish.xml&quot;);
3632  	if (localizationCode == TEXT(&quot;es-ar&quot;))
3633  		return TEXT(&quot;spanish_ar.xml&quot;);
3634  	if (localizationCode == TEXT(&quot;sv&quot;))
3635  		return TEXT(&quot;swedish.xml&quot;);
3636  	if (localizationCode == TEXT(&quot;tl&quot;))
3637  		return TEXT(&quot;tagalog.xml&quot;);
3638  	if (localizationCode == TEXT(&quot;tg-cyrl-tj&quot;))
3639  		return TEXT(&quot;tajikCyrillic.xml&quot;);
3640  	if (localizationCode == TEXT(&quot;ta&quot;))
3641  		return TEXT(&quot;tamil.xml&quot;);
3642  	if (localizationCode == TEXT(&quot;tt&quot;))
3643  		return TEXT(&quot;tatar.xml&quot;);
3644  	if (localizationCode == TEXT(&quot;te&quot;))
3645  		return TEXT(&quot;telugu.xml&quot;);
3646  	if (localizationCode == TEXT(&quot;th&quot;))
3647  		return TEXT(&quot;thai.xml&quot;);
3648  	if (localizationCode == TEXT(&quot;tr&quot;))
3649  		return TEXT(&quot;turkish.xml&quot;);
3650  	if (localizationCode == TEXT(&quot;uk&quot;))
3651  		return TEXT(&quot;ukrainian.xml&quot;);
3652  	if (localizationCode == TEXT(&quot;ur&quot;) || localizationCode == TEXT(&quot;ur-pk&quot;))
3653  		return TEXT(&quot;urdu.xml&quot;);
3654  	if (localizationCode == TEXT(&quot;ug-cn&quot;))
3655  		return TEXT(&quot;uyghur.xml&quot;);
3656  	if (localizationCode == TEXT(&quot;uz&quot;))
3657  		return TEXT(&quot;uzbek.xml&quot;);
3658  	if (localizationCode == TEXT(&quot;uz-cyrl-uz&quot;))
3659  		return TEXT(&quot;uzbekCyrillic.xml&quot;);
3660  	if (localizationCode == TEXT(&quot;vec&quot;))
3661  		return TEXT(&quot;venetian.xml&quot;);
3662  	if (localizationCode == TEXT(&quot;vi&quot;) || localizationCode == TEXT(&quot;vi-vn&quot;))
3663  		return TEXT(&quot;vietnamese.xml&quot;);
3664  	if (localizationCode == TEXT(&quot;cy-gb&quot;))
3665  		return TEXT(&quot;welsh.xml&quot;);
3666  	if (localizationCode == TEXT(&quot;zu&quot;) || localizationCode == TEXT(&quot;zu-za&quot;))
3667  		return TEXT(&quot;zulu.xml&quot;);
3668  	if (localizationCode == TEXT(&quot;ne&quot;) || localizationCode == TEXT(&quot;nep&quot;))
3669  		return TEXT(&quot;nepali.xml&quot;);
3670  	if (localizationCode == TEXT(&quot;oc-aranes&quot;))
3671  		return TEXT(&quot;aranese.xml&quot;);
3672  	if (localizationCode == TEXT(&quot;exy&quot;))
3673  		return TEXT(&quot;extremaduran.xml&quot;);
3674  	if (localizationCode == TEXT(&quot;keb&quot;))
3675  		return TEXT(&quot;kabyle.xml&quot;);
3676  	if (localizationCode == TEXT(&quot;lij&quot;))
3677  		return TEXT(&quot;ligurian.xml&quot;);
3678  	if (localizationCode == TEXT(&quot;ga&quot;))
3679  		return TEXT(&quot;irish.xml&quot;);
3680  	if (localizationCode == TEXT(&quot;sgs&quot;))
3681  		return TEXT(&quot;samogitian.xml&quot;);
3682  	if (localizationCode == TEXT(&quot;yue&quot;))
3683  		return TEXT(&quot;hongKongCantonese.xml&quot;);
3684  	if (localizationCode == TEXT(&quot;ab&quot;) || localizationCode == TEXT(&quot;abk&quot;))
3685  		return TEXT(&quot;abkhazian.xml&quot;);
3686  	return generic_string();
3687  }
3688  void NppParameters::feedKeyWordsParameters(TiXmlNode *node)
3689  {
3690  	TiXmlNode *langRoot = node-&gt;FirstChildElement(TEXT(&quot;Languages&quot;));
3691  	if (!langRoot)
3692  		return;
3693  	for (TiXmlNode *langNode = langRoot-&gt;FirstChildElement(TEXT(&quot;Language&quot;));
3694  		langNode ;
3695  		langNode = langNode-&gt;NextSibling(TEXT(&quot;Language&quot;)) )
3696  	{
3697  		if (_nbLang &lt; NB_LANG)
3698  		{
3699  			TiXmlElement* element = langNode-&gt;ToElement();
3700  			const TCHAR* name = element-&gt;Attribute(TEXT(&quot;name&quot;));
3701  			if (name)
3702  			{
3703  				_langList[_nbLang] = new Lang(getLangIDFromStr(name), name);
3704  				_langList[_nbLang]-&gt;setDefaultExtList(element-&gt;Attribute(TEXT(&quot;ext&quot;)));
3705  				_langList[_nbLang]-&gt;setCommentLineSymbol(element-&gt;Attribute(TEXT(&quot;commentLine&quot;)));
3706  				_langList[_nbLang]-&gt;setCommentStart(element-&gt;Attribute(TEXT(&quot;commentStart&quot;)));
<span onclick='openModal()' class='match'>3707  				_langList[_nbLang]-&gt;setCommentEnd(element-&gt;Attribute(TEXT(&quot;commentEnd&quot;)));
3708  				int tabSettings;
</span>3709  				if (element-&gt;Attribute(TEXT(&quot;tabSettings&quot;), &amp;tabSettings))
3710  					_langList[_nbLang]-&gt;setTabInfo(tabSettings);
3711  				for (TiXmlNode *kwNode = langNode-&gt;FirstChildElement(TEXT(&quot;Keywords&quot;));
3712  					kwNode ;
3713  					kwNode = kwNode-&gt;NextSibling(TEXT(&quot;Keywords&quot;)) )
3714  				{
3715  					const TCHAR *indexName = (kwNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
3716  					TiXmlNode *kwVal = kwNode-&gt;FirstChild();
3717  					const TCHAR *keyWords = TEXT(&quot;&quot;);
3718  					if ((indexName) &amp;&amp; (kwVal))
3719  						keyWords = kwVal-&gt;Value();
3720  					int i = getKwClassFromName(indexName);
3721  					if (i &gt;= 0 &amp;&amp; i &lt;= KEYWORDSET_MAX)
3722  						_langList[_nbLang]-&gt;setWords(keyWords, i);
3723  				}
3724  				++_nbLang;
3725  			}
3726  		}
3727  	}
3728  }
3729  extern &quot;C&quot; {
3730  typedef DWORD (WINAPI * EESFUNC) (LPCTSTR, LPTSTR, DWORD);
3731  }
3732  void NppParameters::feedGUIParameters(TiXmlNode *node)
3733  {
3734  	TiXmlNode *GUIRoot = node-&gt;FirstChildElement(TEXT(&quot;GUIConfigs&quot;));
3735  	if (nullptr == GUIRoot)
3736  		return;
3737  	for (TiXmlNode *childNode = GUIRoot-&gt;FirstChildElement(TEXT(&quot;GUIConfig&quot;));
3738  		childNode ;
3739  		childNode = childNode-&gt;NextSibling(TEXT(&quot;GUIConfig&quot;)) )
3740  	{
3741  		TiXmlElement* element = childNode-&gt;ToElement();
3742  		const TCHAR* nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
3743  		if (nullptr == nm)
3744  			continue;
3745  		auto parseYesNoBoolAttribute = [&amp;element](const TCHAR* name, bool defaultValue = false) -&gt; bool {
3746  			const TCHAR* val = element-&gt;Attribute(name);
3747  			if (val != nullptr)
3748  			{
3749  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3750  					return true;
3751  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3752  					return false;
3753  			}
3754  			return defaultValue;
3755  		};
3756  		if (!lstrcmp(nm, TEXT(&quot;ToolBar&quot;)))
3757  		{
3758  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;visible&quot;));
3759  			if (val)
3760  			{
3761  				if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3762  					_nppGUI._toolbarShow = false;
3763  				else
3764  					_nppGUI._toolbarShow = true;
3765  			}
3766  			TiXmlNode *n = childNode-&gt;FirstChild();
3767  			if (n)
3768  			{
3769  				val = n-&gt;Value();
3770  				if (val)
3771  				{
3772  					if (!lstrcmp(val, TEXT(&quot;small&quot;)))
3773  						_nppGUI._toolBarStatus = TB_SMALL;
3774  					else if (!lstrcmp(val, TEXT(&quot;large&quot;)))
3775  						_nppGUI._toolBarStatus = TB_LARGE;
3776  					else if (!lstrcmp(val, TEXT(&quot;small2&quot;)))
3777  						_nppGUI._toolBarStatus = TB_SMALL2;
3778  					else if (!lstrcmp(val, TEXT(&quot;large2&quot;)))
3779  						_nppGUI._toolBarStatus = TB_LARGE2;
3780  					else 
3781  						_nppGUI._toolBarStatus = TB_STANDARD;
3782  				}
3783  			}
3784  		}
3785  		else if (!lstrcmp(nm, TEXT(&quot;StatusBar&quot;)))
3786  		{
3787  			TiXmlNode *n = childNode-&gt;FirstChild();
3788  			if (n)
3789  			{
3790  				const TCHAR* val = n-&gt;Value();
3791  				if (val)
3792  				{
3793  					if (!lstrcmp(val, TEXT(&quot;hide&quot;)))
3794  						_nppGUI._statusBarShow = false;
3795  					else if (!lstrcmp(val, TEXT(&quot;show&quot;)))
3796  						_nppGUI._statusBarShow = true;
3797  				}
3798  			}
3799  		}
3800  		else if (!lstrcmp(nm, TEXT(&quot;MenuBar&quot;)))
3801  		{
3802  			TiXmlNode *n = childNode-&gt;FirstChild();
3803  			if (n)
3804  			{
3805  				const TCHAR* val = n-&gt;Value();
3806  				if (val)
3807  				{
3808  					if (!lstrcmp(val, TEXT(&quot;hide&quot;)))
3809  						_nppGUI._menuBarShow = false;
3810  					else if (!lstrcmp(val, TEXT(&quot;show&quot;)))
3811  						_nppGUI._menuBarShow = true;
3812  				}
3813  			}
3814  		}
3815  		else if (!lstrcmp(nm, TEXT(&quot;TabBar&quot;)))
3816  		{
3817  			bool isFailed = false;
3818  			int oldValue = _nppGUI._tabStatus;
3819  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;dragAndDrop&quot;));
3820  			if (val)
3821  			{
3822  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3823  					_nppGUI._tabStatus = TAB_DRAGNDROP;
3824  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3825  					_nppGUI._tabStatus = 0;
3826  				else
3827  					isFailed = true;
3828  			}
3829  			val = element-&gt;Attribute(TEXT(&quot;drawTopBar&quot;));
3830  			if (val)
3831  			{
3832  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3833  					_nppGUI._tabStatus |= TAB_DRAWTOPBAR;
3834  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3835  					_nppGUI._tabStatus |= 0;
3836  				else
3837  					isFailed = true;
3838  			}
3839  			val = element-&gt;Attribute(TEXT(&quot;drawInactiveTab&quot;));
3840  			if (val)
3841  			{
3842  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3843  					_nppGUI._tabStatus |= TAB_DRAWINACTIVETAB;
3844  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3845  					_nppGUI._tabStatus |= 0;
3846  				else
3847  					isFailed = true;
3848  			}
3849  			val = element-&gt;Attribute(TEXT(&quot;reduce&quot;));
3850  			if (val)
3851  			{
3852  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3853  					_nppGUI._tabStatus |= TAB_REDUCE;
3854  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3855  					_nppGUI._tabStatus |= 0;
3856  				else
3857  					isFailed = true;
3858  			}
3859  			val = element-&gt;Attribute(TEXT(&quot;closeButton&quot;));
3860  			if (val)
3861  			{
3862  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3863  					_nppGUI._tabStatus |= TAB_CLOSEBUTTON;
3864  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3865  					_nppGUI._tabStatus |= 0;
3866  				else
3867  					isFailed = true;
3868  			}
3869  			val = element-&gt;Attribute(TEXT(&quot;doubleClick2Close&quot;));
3870  			if (val)
3871  			{
3872  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3873  					_nppGUI._tabStatus |= TAB_DBCLK2CLOSE;
3874  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3875  					_nppGUI._tabStatus |= 0;
3876  				else
3877  					isFailed = true;
3878  			}
3879  			val = element-&gt;Attribute(TEXT(&quot;vertical&quot;));
3880  			if (val)
3881  			{
3882  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3883  					_nppGUI._tabStatus |= TAB_VERTICAL;
3884  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3885  					_nppGUI._tabStatus |= 0;
3886  				else
3887  					isFailed = true;
3888  			}
3889  			val = element-&gt;Attribute(TEXT(&quot;multiLine&quot;));
3890  			if (val)
3891  			{
3892  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3893  					_nppGUI._tabStatus |= TAB_MULTILINE;
3894  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3895  					_nppGUI._tabStatus |= 0;
3896  				else
3897  					isFailed = true;
3898  			}
3899  			val = element-&gt;Attribute(TEXT(&quot;hide&quot;));
3900  			if (val)
3901  			{
3902  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3903  					_nppGUI._tabStatus |= TAB_HIDE;
3904  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3905  					_nppGUI._tabStatus |= 0;
3906  				else
3907  					isFailed = true;
3908  			}
3909  			val = element-&gt;Attribute(TEXT(&quot;quitOnEmpty&quot;));
3910  			if (val)
3911  			{
3912  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3913  					_nppGUI._tabStatus |= TAB_QUITONEMPTY;
3914  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3915  					_nppGUI._tabStatus |= 0;
3916  				else
3917  					isFailed = true;
3918  			}
3919  			val = element-&gt;Attribute(TEXT(&quot;iconSetNumber&quot;));
3920  			if (val)
3921  			{
3922  				if (!lstrcmp(val, TEXT(&quot;1&quot;)))
3923  					_nppGUI._tabStatus |= TAB_ALTICONS;
3924  				else if (!lstrcmp(val, TEXT(&quot;0&quot;)))
3925  					_nppGUI._tabStatus |= 0;
3926  				else
3927  					isFailed = true;
3928  			}
3929  			if (isFailed)
3930  				_nppGUI._tabStatus = oldValue;
3931  		}
3932  		else if (!lstrcmp(nm, TEXT(&quot;Auto-detection&quot;)))
3933  		{
3934  			TiXmlNode *n = childNode-&gt;FirstChild();
3935  			if (n)
3936  			{
3937  				const TCHAR* val = n-&gt;Value();
3938  				if (val)
3939  				{
3940  					if (!lstrcmp(val, TEXT(&quot;yesOld&quot;)))
3941  						_nppGUI._fileAutoDetection = cdEnabledOld;
3942  					else if (!lstrcmp(val, TEXT(&quot;autoOld&quot;)))
3943  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate);
3944  					else if (!lstrcmp(val, TEXT(&quot;Update2EndOld&quot;)))
3945  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdGo2end);
3946  					else if (!lstrcmp(val, TEXT(&quot;autoUpdate2EndOld&quot;)))
3947  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate | cdGo2end);
3948  					else if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3949  						_nppGUI._fileAutoDetection = cdEnabledNew;
3950  					else if (!lstrcmp(val, TEXT(&quot;auto&quot;)))
3951  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate);
3952  					else if (!lstrcmp(val, TEXT(&quot;Update2End&quot;)))
3953  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdGo2end);
3954  					else if (!lstrcmp(val, TEXT(&quot;autoUpdate2End&quot;)))
3955  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate | cdGo2end);
3956  					else 
3957  						_nppGUI._fileAutoDetection = cdDisabled;
3958  				}
3959  			}
3960  		}
3961  		else if (!lstrcmp(nm, TEXT(&quot;TrayIcon&quot;)))
3962  		{
3963  			TiXmlNode *n = childNode-&gt;FirstChild();
3964  			if (n)
3965  			{
3966  				const TCHAR* val = n-&gt;Value();
3967  				if (val)
3968  				{
3969  					_nppGUI._isMinimizedToTray = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
3970  				}
3971  			}
3972  		}
3973  		else if (!lstrcmp(nm, TEXT(&quot;RememberLastSession&quot;)))
3974  		{
3975  			TiXmlNode *n = childNode-&gt;FirstChild();
3976  			if (n)
3977  			{
3978  				const TCHAR* val = n-&gt;Value();
3979  				if (val)
3980  				{
3981  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
3982  						_nppGUI._rememberLastSession = true;
3983  					else
3984  						_nppGUI._rememberLastSession = false;
3985  				}
3986  			}
3987  		}
3988  		else if (!lstrcmp(nm, TEXT(&quot;DetectEncoding&quot;)))
3989  		{
3990  			TiXmlNode *n = childNode-&gt;FirstChild();
3991  			if (n)
3992  			{
3993  				const TCHAR* val = n-&gt;Value();
3994  				if (val)
3995  				{
3996  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
3997  						_nppGUI._detectEncoding = true;
3998  					else
3999  						_nppGUI._detectEncoding = false;
4000  				}
4001  			}
4002  		}
4003  		else if (!lstrcmp(nm, TEXT(&quot;SaveAllConfirm&quot;)))
4004  		{
4005  			TiXmlNode *n = childNode-&gt;FirstChild();
4006  			if (n)
4007  			{
4008  				const TCHAR* val = n-&gt;Value();
4009  				if (val)
4010  				{
4011  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4012  						_nppGUI._saveAllConfirm = true;
4013  					else
4014  						_nppGUI._saveAllConfirm = false;
4015  				}
4016  			}
4017  		}
4018  		else if (lstrcmp(nm, TEXT(&quot;MaitainIndent&quot;)) == 0)
4019  		{
4020  			TiXmlNode *n = childNode-&gt;FirstChild();
4021  			if (n)
4022  			{
4023  				const TCHAR* val = n-&gt;Value();
4024  				if (val)
4025  				{
4026  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4027  						_nppGUI._maitainIndent = true;
4028  					else
4029  						_nppGUI._maitainIndent = false;
4030  				}
4031  			}
4032  		}
4033  		else if (!lstrcmp(nm, TEXT(&quot;MarkAll&quot;)))
4034  		{
4035  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;matchCase&quot;));
4036  			if (val)
4037  			{
4038  				if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4039  					_nppGUI._markAllCaseSensitive = true;
4040  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4041  					_nppGUI._markAllCaseSensitive = false;
4042  			}
4043  			val = element-&gt;Attribute(TEXT(&quot;wholeWordOnly&quot;));
4044  			if (val)
4045  			{
4046  				if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4047  					_nppGUI._markAllWordOnly = true;
4048  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4049  					_nppGUI._markAllWordOnly = false;
4050  			}
4051  		}
4052  		else if (!lstrcmp(nm, TEXT(&quot;SmartHighLight&quot;)))
4053  		{
4054  			TiXmlNode *n = childNode-&gt;FirstChild();
4055  			if (n)
4056  			{
4057  				const TCHAR* val = n-&gt;Value();
4058  				if (val)
4059  				{
4060  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4061  						_nppGUI._enableSmartHilite = true;
4062  					else
4063  						_nppGUI._enableSmartHilite = false;
4064  				}
4065  				val = element-&gt;Attribute(TEXT(&quot;matchCase&quot;));
4066  				if (val)
4067  				{
4068  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4069  						_nppGUI._smartHiliteCaseSensitive = true;
4070  					else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4071  						_nppGUI._smartHiliteCaseSensitive = false;
4072  				}
4073  				val = element-&gt;Attribute(TEXT(&quot;wholeWordOnly&quot;));
4074  				if (val)
4075  				{
4076  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4077  						_nppGUI._smartHiliteWordOnly = true;
4078  					else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4079  						_nppGUI._smartHiliteWordOnly = false;
4080  				}
4081  				val = element-&gt;Attribute(TEXT(&quot;useFindSettings&quot;));
4082  				if (val)
4083  				{
4084  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4085  						_nppGUI._smartHiliteUseFindSettings = true;
4086  					else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4087  						_nppGUI._smartHiliteUseFindSettings = false;
4088  				}
4089  				val = element-&gt;Attribute(TEXT(&quot;onAnotherView&quot;));
4090  				if (val)
4091  				{
4092  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4093  						_nppGUI._smartHiliteOnAnotherView = true;
4094  					else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4095  						_nppGUI._smartHiliteOnAnotherView = false;
4096  				}
4097  			}
4098  		}
4099  		else if (!lstrcmp(nm, TEXT(&quot;TagsMatchHighLight&quot;)))
4100  		{
4101  			TiXmlNode *n = childNode-&gt;FirstChild();
4102  			if (n)
4103  			{
4104  				const TCHAR* val = n-&gt;Value();
4105  				if (val)
4106  				{
4107  					_nppGUI._enableTagsMatchHilite = !lstrcmp(val, TEXT(&quot;yes&quot;));
4108  					const TCHAR *tahl = element-&gt;Attribute(TEXT(&quot;TagAttrHighLight&quot;));
4109  					if (tahl)
4110  						_nppGUI._enableTagAttrsHilite = !lstrcmp(tahl, TEXT(&quot;yes&quot;));
4111  					tahl = element-&gt;Attribute(TEXT(&quot;HighLightNonHtmlZone&quot;));
4112  					if (tahl)
4113  						_nppGUI._enableHiliteNonHTMLZone = !lstrcmp(tahl, TEXT(&quot;yes&quot;));
4114  				}
4115  			}
4116  		}
4117  		else if (!lstrcmp(nm, TEXT(&quot;TaskList&quot;)))
4118  		{
4119  			TiXmlNode *n = childNode-&gt;FirstChild();
4120  			if (n)
4121  			{
4122  				const TCHAR* val = n-&gt;Value();
4123  				if (val)
4124  				{
4125  					_nppGUI._doTaskList = (!lstrcmp(val, TEXT(&quot;yes&quot;)))?true:false;
4126  				}
4127  			}
4128  		}
4129  		else if (!lstrcmp(nm, TEXT(&quot;MRU&quot;)))
4130  		{
4131  			TiXmlNode *n = childNode-&gt;FirstChild();
4132  			if (n)
4133  			{
4134  				const TCHAR* val = n-&gt;Value();
4135  				if (val)
4136  					_nppGUI._styleMRU = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4137  			}
4138  		}
4139  		else if (!lstrcmp(nm, TEXT(&quot;URL&quot;)))
4140  		{
4141  			TiXmlNode *n = childNode-&gt;FirstChild();
4142  			if (n)
4143  			{
4144  				const TCHAR* val = n-&gt;Value();
4145  				if (val)
4146  				{
4147  					int const i = _wtoi (val);
4148  					if ((i &gt;= urlMin) &amp;&amp; (i &lt;= urlMax))
4149  						_nppGUI._styleURL = urlMode(i);
4150  				}
4151  			}
4152  		}
4153  		else if (!lstrcmp(nm, TEXT(&quot;uriCustomizedSchemes&quot;)))
4154  		{
4155  			TiXmlNode *n = childNode-&gt;FirstChild();
4156  			if (n)
4157  			{
4158  				const TCHAR* val = n-&gt;Value();
4159  				if (val)
4160  				_nppGUI._uriSchemes = val;
4161  			}
4162  		}
4163  		else if (!lstrcmp(nm, TEXT(&quot;CheckHistoryFiles&quot;)))
4164  		{
4165  			TiXmlNode *n = childNode-&gt;FirstChild();
4166  			if (n)
4167  			{
4168  				const TCHAR* val = n-&gt;Value();
4169  				if (val)
4170  				{
4171  					if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4172  						_nppGUI._checkHistoryFiles = false;
4173  					else if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
4174  						_nppGUI._checkHistoryFiles = true;
4175  				}
4176  			}
4177  		}
4178  		else if (!lstrcmp(nm, TEXT(&quot;ScintillaViewsSplitter&quot;)))
4179  		{
4180  			TiXmlNode *n = childNode-&gt;FirstChild();
4181  			if (n)
4182  			{
4183  				const TCHAR* val = n-&gt;Value();
4184  				if (val)
4185  				{
4186  					if (!lstrcmp(val, TEXT(&quot;vertical&quot;)))
4187  						_nppGUI._splitterPos = POS_VERTICAL;
4188  					else if (!lstrcmp(val, TEXT(&quot;horizontal&quot;)))
4189  						_nppGUI._splitterPos = POS_HORIZOTAL;
4190  				}
4191  			}
4192  		}
4193  		else if (!lstrcmp(nm, TEXT(&quot;UserDefineDlg&quot;)))
4194  		{
4195  			bool isFailed = false;
4196  			int oldValue = _nppGUI._userDefineDlgStatus;
4197  			TiXmlNode *n = childNode-&gt;FirstChild();
4198  			if (n)
4199  			{
4200  				const TCHAR* val = n-&gt;Value();
4201  				if (val)
4202  				{
4203  					if (!lstrcmp(val, TEXT(&quot;hide&quot;)))
4204  						_nppGUI._userDefineDlgStatus = 0;
4205  					else if (!lstrcmp(val, TEXT(&quot;show&quot;)))
4206  						_nppGUI._userDefineDlgStatus = UDD_SHOW;
4207  					else
4208  						isFailed = true;
4209  				}
4210  			}
4211  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;position&quot;));
4212  			if (val)
4213  			{
4214  				if (!lstrcmp(val, TEXT(&quot;docked&quot;)))
4215  					_nppGUI._userDefineDlgStatus |= UDD_DOCKED;
4216  				else if (!lstrcmp(val, TEXT(&quot;undocked&quot;)))
4217  					_nppGUI._userDefineDlgStatus |= 0;
4218  				else
4219  					isFailed = true;
4220  			}
4221  			if (isFailed)
4222  				_nppGUI._userDefineDlgStatus = oldValue;
4223  		}
4224  		else if (!lstrcmp(nm, TEXT(&quot;TabSetting&quot;)))
4225  		{
4226  			int i;
4227  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;size&quot;), &amp;i);
4228  			if (val)
4229  				_nppGUI._tabSize = i;
4230  			if ((_nppGUI._tabSize == -1) || (_nppGUI._tabSize == 0))
4231  				_nppGUI._tabSize = 4;
4232  			val = element-&gt;Attribute(TEXT(&quot;replaceBySpace&quot;));
4233  			if (val)
4234  				_nppGUI._tabReplacedBySpace = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4235  		}
4236  		else if (!lstrcmp(nm, TEXT(&quot;Caret&quot;)))
4237  		{
4238  			int i;
4239  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;width&quot;), &amp;i);
4240  			if (val)
4241  				_nppGUI._caretWidth = i;
4242  			val = element-&gt;Attribute(TEXT(&quot;blinkRate&quot;), &amp;i);
4243  			if (val)
4244  				_nppGUI._caretBlinkRate = i;
4245  		}
4246  		else if (!lstrcmp(nm, TEXT(&quot;ScintillaGlobalSettings&quot;)))
4247  		{
4248  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;enableMultiSelection&quot;));
4249  			if (val)
4250  			{
4251  				if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4252  					_nppGUI._enableMultiSelection = true;
4253  				else if (lstrcmp(val, TEXT(&quot;no&quot;)) == 0)
4254  					_nppGUI._enableMultiSelection = false;
4255  			}
4256  		}
4257  		else if (!lstrcmp(nm, TEXT(&quot;AppPosition&quot;)))
4258  		{
4259  			RECT oldRect = _nppGUI._appPos;
4260  			bool fuckUp = true;
4261  			int i;
4262  			if (element-&gt;Attribute(TEXT(&quot;x&quot;), &amp;i))
4263  			{
4264  				_nppGUI._appPos.left = i;
4265  				if (element-&gt;Attribute(TEXT(&quot;y&quot;), &amp;i))
4266  				{
4267  					_nppGUI._appPos.top = i;
4268  					if (element-&gt;Attribute(TEXT(&quot;width&quot;), &amp;i))
4269  					{
4270  						_nppGUI._appPos.right = i;
4271  						if (element-&gt;Attribute(TEXT(&quot;height&quot;), &amp;i))
4272  						{
4273  							_nppGUI._appPos.bottom = i;
4274  							fuckUp = false;
4275  						}
4276  					}
4277  				}
4278  			}
4279  			if (fuckUp)
4280  				_nppGUI._appPos = oldRect;
4281  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;isMaximized&quot;));
4282  			if (val)
4283  				_nppGUI._isMaximized = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
4284  		}
4285  		else if (!lstrcmp(nm, TEXT(&quot;FindWindowPosition&quot;)))
4286  		{
4287  			RECT oldRect = _nppGUI._findWindowPos;
4288  			bool incomplete = true;
4289  			int i;
4290  			if (element-&gt;Attribute(TEXT(&quot;left&quot;), &amp;i))
4291  			{
4292  				_nppGUI._findWindowPos.left = i;
4293  				if (element-&gt;Attribute(TEXT(&quot;top&quot;), &amp;i))
4294  				{
4295  					_nppGUI._findWindowPos.top = i;
4296  					if (element-&gt;Attribute(TEXT(&quot;right&quot;), &amp;i))
4297  					{
4298  						_nppGUI._findWindowPos.right = i;
4299  						if (element-&gt;Attribute(TEXT(&quot;bottom&quot;), &amp;i))
4300  						{
4301  							_nppGUI._findWindowPos.bottom = i;
4302  							incomplete = false;
4303  						}
4304  					}
4305  				}
4306  			}
4307  			if (incomplete)
4308  			{
4309  				_nppGUI._findWindowPos = oldRect;
4310  			}
4311  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;isLessModeOn&quot;));
4312  			if (val)
4313  				_nppGUI._findWindowLessMode = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
4314  		}
4315  		else if (!lstrcmp(nm, TEXT(&quot;FinderConfig&quot;)))
4316  		{
4317  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;wrappedLines&quot;));
4318  			if (val)
4319  			{
4320  				_nppGUI._finderLinesAreCurrentlyWrapped = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4321  			}
4322  			val = element-&gt;Attribute(TEXT(&quot;purgeBeforeEverySearch&quot;));
4323  			if (val)
4324  			{
4325  				_nppGUI._finderPurgeBeforeEverySearch = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4326  			}
4327  			val = element-&gt;Attribute(TEXT(&quot;showOnlyOneEntryPerFoundLine&quot;));
4328  			if (val)
4329  			{
4330  				_nppGUI._finderShowOnlyOneEntryPerFoundLine = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4331  			}
4332  		}
4333  		else if (!lstrcmp(nm, TEXT(&quot;NewDocDefaultSettings&quot;)))
4334  		{
4335  			int i;
4336  			if (element-&gt;Attribute(TEXT(&quot;format&quot;), &amp;i))
4337  			{
4338  				EolType newFormat = EolType::osdefault;
4339  				switch (i)
4340  				{
4341  					case static_cast&lt;LPARAM&gt;(EolType::windows) :
4342  						newFormat = EolType::windows;
4343  						break;
4344  					case static_cast&lt;LPARAM&gt;(EolType::macos) :
4345  						newFormat = EolType::macos;
4346  						break;
4347  					case static_cast&lt;LPARAM&gt;(EolType::unix) :
4348  						newFormat = EolType::unix;
4349  						break;
4350  					default:
4351  						assert(false and &quot;invalid buffer format - fallback to default&quot;);
4352  				}
4353  				_nppGUI._newDocDefaultSettings._format = newFormat;
4354  			}
4355  			if (element-&gt;Attribute(TEXT(&quot;encoding&quot;), &amp;i))
4356  				_nppGUI._newDocDefaultSettings._unicodeMode = (UniMode)i;
4357  			if (element-&gt;Attribute(TEXT(&quot;lang&quot;), &amp;i))
4358  				_nppGUI._newDocDefaultSettings._lang = (LangType)i;
4359  			if (element-&gt;Attribute(TEXT(&quot;codepage&quot;), &amp;i))
4360  				_nppGUI._newDocDefaultSettings._codepage = (LangType)i;
4361  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;openAnsiAsUTF8&quot;));
4362  			if (val)
4363  				_nppGUI._newDocDefaultSettings._openAnsiAsUtf8 = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
4364  			val = element-&gt;Attribute(TEXT(&quot;addNewDocumentOnStartup&quot;));
4365  			if (val)
4366  				_nppGUI._newDocDefaultSettings._addNewDocumentOnStartup = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
4367  		}
4368  		else if (!lstrcmp(nm, TEXT(&quot;langsExcluded&quot;)))
4369  		{
4370  			int g0 = 0; 
4371  			int g1 = 0; 
4372  			int g2 = 0; 
4373  			int g3 = 0; 
4374  			int g4 = 0; 
4375  			int g5 = 0; 
4376  			int g6 = 0; 
4377  			int g7 = 0; 
4378  			int g8 = 0; 
4379  			int g9 = 0; 
4380  			int g10= 0; 
4381  			int g11= 0; 
4382  			int g12= 0; 
4383  			{
4384  				int i;
4385  				if (element-&gt;Attribute(TEXT(&quot;gr0&quot;), &amp;i))
4386  				{
4387  					if (i &lt;= 255)
4388  						g0 = i;
4389  				}
4390  				if (element-&gt;Attribute(TEXT(&quot;gr1&quot;), &amp;i))
4391  				{
4392  					if (i &lt;= 255)
4393  						g1 = i;
4394  				}
4395  				if (element-&gt;Attribute(TEXT(&quot;gr2&quot;), &amp;i))
4396  				{
4397  					if (i &lt;= 255)
4398  						g2 = i;
4399  				}
4400  				if (element-&gt;Attribute(TEXT(&quot;gr3&quot;), &amp;i))
4401  				{
4402  					if (i &lt;= 255)
4403  						g3 = i;
4404  				}
4405  				if (element-&gt;Attribute(TEXT(&quot;gr4&quot;), &amp;i))
4406  				{
4407  					if (i &lt;= 255)
4408  						g4 = i;
4409  				}
4410  				if (element-&gt;Attribute(TEXT(&quot;gr5&quot;), &amp;i))
4411  				{
4412  					if (i &lt;= 255)
4413  						g5 = i;
4414  				}
4415  				if (element-&gt;Attribute(TEXT(&quot;gr6&quot;), &amp;i))
4416  				{
4417  					if (i &lt;= 255)
4418  						g6 = i;
4419  				}
4420  				if (element-&gt;Attribute(TEXT(&quot;gr7&quot;), &amp;i))
4421  				{
4422  					if (i &lt;= 255)
4423  						g7 = i;
4424  				}
4425  				if (element-&gt;Attribute(TEXT(&quot;gr8&quot;), &amp;i))
4426  				{
4427  					if (i &lt;= 255)
4428  						g8 = i;
4429  				}
4430  				if (element-&gt;Attribute(TEXT(&quot;gr9&quot;), &amp;i))
4431  				{
4432  					if (i &lt;= 255)
4433  						g9 = i;
4434  				}
4435  				if (element-&gt;Attribute(TEXT(&quot;gr10&quot;), &amp;i))
4436  				{
4437  					if (i &lt;= 255)
4438  						g10 = i;
4439  				}
4440  				if (element-&gt;Attribute(TEXT(&quot;gr11&quot;), &amp;i))
4441  				{
4442  					if (i &lt;= 255)
4443  						g11 = i;
4444  				}
4445  				if (element-&gt;Attribute(TEXT(&quot;gr12&quot;), &amp;i))
4446  				{
4447  					if (i &lt;= 255)
4448  						g12 = i;
4449  				}
4450  			}
4451  			UCHAR mask = 1;
4452  			for (int i = 0 ; i &lt; 8 ; ++i)
4453  			{
4454  				if (mask &amp; g0)
4455  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4456  				mask &lt;&lt;= 1;
4457  			}
4458  			mask = 1;
4459  			for (int i = 8 ; i &lt; 16 ; ++i)
4460  			{
4461  				if (mask &amp; g1)
4462  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4463  				mask &lt;&lt;= 1;
4464  			}
4465  			mask = 1;
4466  			for (int i = 16 ; i &lt; 24 ; ++i)
4467  			{
4468  				if (mask &amp; g2)
4469  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4470  				mask &lt;&lt;= 1;
4471  			}
4472  			mask = 1;
4473  			for (int i = 24 ; i &lt; 32 ; ++i)
4474  			{
4475  				if (mask &amp; g3)
4476  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4477  				mask &lt;&lt;= 1;
4478  			}
4479  			mask = 1;
4480  			for (int i = 32 ; i &lt; 40 ; ++i)
4481  			{
4482  				if (mask &amp; g4)
4483  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4484  				mask &lt;&lt;= 1;
4485  			}
4486  			mask = 1;
4487  			for (int i = 40 ; i &lt; 48 ; ++i)
4488  			{
4489  				if (mask &amp; g5)
4490  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4491  				mask &lt;&lt;= 1;
4492  			}
4493  			mask = 1;
4494  			for (int i = 48 ; i &lt; 56 ; ++i)
4495  			{
4496  				if (mask &amp; g6)
4497  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4498  				mask &lt;&lt;= 1;
4499  			}
4500  			mask = 1;
4501  			for (int i = 56 ; i &lt; 64 ; ++i)
4502  			{
4503  				if (mask &amp; g7)
4504  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4505  				mask &lt;&lt;= 1;
4506  			}
4507  			mask = 1;
4508  			for (int i = 64; i &lt; 72; ++i)
4509  			{
4510  				if (mask &amp; g8)
4511  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4512  				mask &lt;&lt;= 1;
4513  			}
4514  			mask = 1;
4515  			for (int i = 72; i &lt; 80; ++i)
4516  			{
4517  				if (mask &amp; g9)
4518  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4519  				mask &lt;&lt;= 1;
4520  			}
4521  			mask = 1;
4522  			for (int i = 80; i &lt; 88; ++i)
4523  			{
4524  				if (mask &amp; g10)
4525  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4526  				mask &lt;&lt;= 1;
4527  			}
4528  			mask = 1;
4529  			for (int i = 88; i &lt; 96; ++i)
4530  			{
4531  				if (mask &amp; g11)
4532  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4533  				mask &lt;&lt;= 1;
4534  			}
4535  			mask = 1;
4536  			for (int i = 96; i &lt; 104; ++i)
4537  			{
4538  				if (mask &amp; g12)
4539  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4540  				mask &lt;&lt;= 1;
4541  			}
4542  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;langMenuCompact&quot;));
4543  			if (val)
4544  				_nppGUI._isLangMenuCompact = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4545  		}
4546  		else if (!lstrcmp(nm, TEXT(&quot;Print&quot;)))
4547  		{
4548  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;lineNumber&quot;));
4549  			if (val)
4550  				_nppGUI._printSettings._printLineNumber = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4551  			int i;
4552  			if (element-&gt;Attribute(TEXT(&quot;printOption&quot;), &amp;i))
4553  				_nppGUI._printSettings._printOption = i;
4554  			val = element-&gt;Attribute(TEXT(&quot;headerLeft&quot;));
4555  			if (val)
4556  				_nppGUI._printSettings._headerLeft = val;
4557  			val = element-&gt;Attribute(TEXT(&quot;headerMiddle&quot;));
4558  			if (val)
4559  				_nppGUI._printSettings._headerMiddle = val;
4560  			val = element-&gt;Attribute(TEXT(&quot;headerRight&quot;));
4561  			if (val)
4562  				_nppGUI._printSettings._headerRight = val;
4563  			val = element-&gt;Attribute(TEXT(&quot;footerLeft&quot;));
4564  			if (val)
4565  				_nppGUI._printSettings._footerLeft = val;
4566  			val = element-&gt;Attribute(TEXT(&quot;footerMiddle&quot;));
4567  			if (val)
4568  				_nppGUI._printSettings._footerMiddle = val;
4569  			val = element-&gt;Attribute(TEXT(&quot;footerRight&quot;));
4570  			if (val)
4571  				_nppGUI._printSettings._footerRight = val;
4572  			val = element-&gt;Attribute(TEXT(&quot;headerFontName&quot;));
4573  			if (val)
4574  				_nppGUI._printSettings._headerFontName = val;
4575  			val = element-&gt;Attribute(TEXT(&quot;footerFontName&quot;));
4576  			if (val)
4577  				_nppGUI._printSettings._footerFontName = val;
4578  			if (element-&gt;Attribute(TEXT(&quot;headerFontStyle&quot;), &amp;i))
4579  				_nppGUI._printSettings._headerFontStyle = i;
4580  			if (element-&gt;Attribute(TEXT(&quot;footerFontStyle&quot;), &amp;i))
4581  				_nppGUI._printSettings._footerFontStyle = i;
4582  			if (element-&gt;Attribute(TEXT(&quot;headerFontSize&quot;), &amp;i))
4583  				_nppGUI._printSettings._headerFontSize = i;
4584  			if (element-&gt;Attribute(TEXT(&quot;footerFontSize&quot;), &amp;i))
4585  				_nppGUI._printSettings._footerFontSize = i;
4586  			if (element-&gt;Attribute(TEXT(&quot;margeLeft&quot;), &amp;i))
4587  				_nppGUI._printSettings._marge.left = i;
4588  			if (element-&gt;Attribute(TEXT(&quot;margeTop&quot;), &amp;i))
4589  				_nppGUI._printSettings._marge.top = i;
4590  			if (element-&gt;Attribute(TEXT(&quot;margeRight&quot;), &amp;i))
4591  				_nppGUI._printSettings._marge.right = i;
4592  			if (element-&gt;Attribute(TEXT(&quot;margeBottom&quot;), &amp;i))
4593  				_nppGUI._printSettings._marge.bottom = i;
4594  		}
4595  		else if (!lstrcmp(nm, TEXT(&quot;ScintillaPrimaryView&quot;)))
4596  		{
4597  			feedScintillaParam(element);
4598  		}
4599  		else if (!lstrcmp(nm, TEXT(&quot;Backup&quot;)))
4600  		{
4601  			int i;
4602  			if (element-&gt;Attribute(TEXT(&quot;action&quot;), &amp;i))
4603  				_nppGUI._backup = (BackupFeature)i;
4604  			const TCHAR *bDir = element-&gt;Attribute(TEXT(&quot;useCustumDir&quot;));
4605  			if (bDir)
4606  			{
4607  				_nppGUI._useDir = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4608  			}
4609  			const TCHAR *pDir = element-&gt;Attribute(TEXT(&quot;dir&quot;));
4610  			if (pDir)
4611  				_nppGUI._backupDir = pDir;
4612  			const TCHAR *isSnapshotModeStr = element-&gt;Attribute(TEXT(&quot;isSnapshotMode&quot;));
4613  			if (isSnapshotModeStr &amp;&amp; !lstrcmp(isSnapshotModeStr, TEXT(&quot;no&quot;)))
4614  				_nppGUI._isSnapshotMode = false;
4615  			int timing;
4616  			if (element-&gt;Attribute(TEXT(&quot;snapshotBackupTiming&quot;), &amp;timing))
4617  				_nppGUI._snapshotBackupTiming = timing;
4618  		}
4619  		else if (!lstrcmp(nm, TEXT(&quot;DockingManager&quot;)))
4620  		{
4621  			feedDockingManager(element);
4622  		}
4623  		else if (!lstrcmp(nm, TEXT(&quot;globalOverride&quot;)))
4624  		{
4625  			const TCHAR *bDir = element-&gt;Attribute(TEXT(&quot;fg&quot;));
4626  			if (bDir)
4627  				_nppGUI._globalOverride.enableFg = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4628  			bDir = element-&gt;Attribute(TEXT(&quot;bg&quot;));
4629  			if (bDir)
4630  				_nppGUI._globalOverride.enableBg = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4631  			bDir = element-&gt;Attribute(TEXT(&quot;font&quot;));
4632  			if (bDir)
4633  				_nppGUI._globalOverride.enableFont = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4634  			bDir = element-&gt;Attribute(TEXT(&quot;fontSize&quot;));
4635  			if (bDir)
4636  				_nppGUI._globalOverride.enableFontSize = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4637  			bDir = element-&gt;Attribute(TEXT(&quot;bold&quot;));
4638  			if (bDir)
4639  				_nppGUI._globalOverride.enableBold = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4640  			bDir = element-&gt;Attribute(TEXT(&quot;italic&quot;));
4641  			if (bDir)
4642  				_nppGUI._globalOverride.enableItalic = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4643  			bDir = element-&gt;Attribute(TEXT(&quot;underline&quot;));
4644  			if (bDir)
4645  				_nppGUI._globalOverride.enableUnderLine = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4646  		}
4647  		else if (!lstrcmp(nm, TEXT(&quot;auto-completion&quot;)))
4648  		{
4649  			int i;
4650  			if (element-&gt;Attribute(TEXT(&quot;autoCAction&quot;), &amp;i))
4651  				_nppGUI._autocStatus = static_cast&lt;NppGUI::AutocStatus&gt;(i);
4652  			if (element-&gt;Attribute(TEXT(&quot;triggerFromNbChar&quot;), &amp;i))
4653  				_nppGUI._autocFromLen = i;
4654  			const TCHAR * optName = element-&gt;Attribute(TEXT(&quot;autoCIgnoreNumbers&quot;));
4655  			if (optName)
4656  				_nppGUI._autocIgnoreNumbers = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4657  			optName = element-&gt;Attribute(TEXT(&quot;insertSelectedItemUseENTER&quot;));
4658  			if (optName)
4659  				_nppGUI._autocInsertSelectedUseENTER = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4660  			optName = element-&gt;Attribute(TEXT(&quot;insertSelectedItemUseTAB&quot;));
4661  			if (optName)
4662  				_nppGUI._autocInsertSelectedUseTAB = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4663  			optName = element-&gt;Attribute(TEXT(&quot;autoCBrief&quot;));
4664  			if (optName)
4665  				_nppGUI._autocBrief = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4666  			optName = element-&gt;Attribute(TEXT(&quot;funcParams&quot;));
4667  			if (optName)
4668  				_nppGUI._funcParams = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4669  		}
4670  		else if (!lstrcmp(nm, TEXT(&quot;auto-insert&quot;)))
4671  		{
4672  			const TCHAR * optName = element-&gt;Attribute(TEXT(&quot;htmlXmlTag&quot;));
4673  			if (optName)
4674  				_nppGUI._matchedPairConf._doHtmlXmlTag = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4675  			optName = element-&gt;Attribute(TEXT(&quot;parentheses&quot;));
4676  			if (optName)
4677  				_nppGUI._matchedPairConf._doParentheses = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4678  			optName = element-&gt;Attribute(TEXT(&quot;brackets&quot;));
4679  			if (optName)
4680  				_nppGUI._matchedPairConf._doBrackets = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4681  			optName = element-&gt;Attribute(TEXT(&quot;curlyBrackets&quot;));
4682  			if (optName)
4683  				_nppGUI._matchedPairConf._doCurlyBrackets = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4684  			optName = element-&gt;Attribute(TEXT(&quot;quotes&quot;));
4685  			if (optName)
4686  				_nppGUI._matchedPairConf._doQuotes = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4687  			optName = element-&gt;Attribute(TEXT(&quot;doubleQuotes&quot;));
4688  			if (optName)
4689  				_nppGUI._matchedPairConf._doDoubleQuotes = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4690  			for (TiXmlNode *subChildNode = childNode-&gt;FirstChildElement(TEXT(&quot;UserDefinePair&quot;));
4691  				 subChildNode;
4692  				 subChildNode = subChildNode-&gt;NextSibling(TEXT(&quot;UserDefinePair&quot;)) )
4693  			{
4694  				int open = -1;
4695  				int openVal = 0;
4696  				const TCHAR *openValStr = (subChildNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;open&quot;), &amp;openVal);
4697  				if (openValStr &amp;&amp; (openVal &gt;= 0 &amp;&amp; openVal &lt; 128))
4698  					open = openVal;
4699  				int close = -1;
4700  				int closeVal = 0;
4701  				const TCHAR *closeValStr = (subChildNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;close&quot;), &amp;closeVal);
4702  				if (closeValStr &amp;&amp; (closeVal &gt;= 0 &amp;&amp; closeVal &lt;= 128))
4703  					close = closeVal;
4704  				if (open != -1 &amp;&amp; close != -1)
4705  					_nppGUI._matchedPairConf._matchedPairsInit.push_back(pair&lt;char, char&gt;(char(open), char(close)));
4706  			}
4707  		}
4708  		else if (!lstrcmp(nm, TEXT(&quot;sessionExt&quot;)))
4709  		{
4710  			TiXmlNode *n = childNode-&gt;FirstChild();
4711  			if (n)
4712  			{
4713  				const TCHAR* val = n-&gt;Value();
4714  				if (val)
4715  					_nppGUI._definedSessionExt = val;
4716  			}
4717  		}
4718  		else if (!lstrcmp(nm, TEXT(&quot;workspaceExt&quot;)))
4719  		{
4720  			TiXmlNode *n = childNode-&gt;FirstChild();
4721  			if (n)
4722  			{
4723  				const TCHAR* val = n-&gt;Value();
4724  				if (val)
4725  					_nppGUI._definedWorkspaceExt = val;
4726  			}
4727  		}
4728  		else if (!lstrcmp(nm, TEXT(&quot;noUpdate&quot;)))
4729  		{
4730  			TiXmlNode *n = childNode-&gt;FirstChild();
4731  			if (n)
4732  			{
4733  				const TCHAR* val = n-&gt;Value();
4734  				if (val)
4735  					_nppGUI._autoUpdateOpt._doAutoUpdate = (!lstrcmp(val, TEXT(&quot;yes&quot;)))?false:true;
4736  				int i;
4737  				val = element-&gt;Attribute(TEXT(&quot;intervalDays&quot;), &amp;i);
4738  				if (val)
4739  					_nppGUI._autoUpdateOpt._intervalDays = i;
4740  				val = element-&gt;Attribute(TEXT(&quot;nextUpdateDate&quot;));
4741  				if (val)
4742  					_nppGUI._autoUpdateOpt._nextUpdateDate = Date(val);
4743  			}
4744  		}
4745  		else if (!lstrcmp(nm, TEXT(&quot;openSaveDir&quot;)))
4746  		{
4747  			const TCHAR * value = element-&gt;Attribute(TEXT(&quot;value&quot;));
4748  			if (value &amp;&amp; value[0])
4749  			{
4750  				if (lstrcmp(value, TEXT(&quot;1&quot;)) == 0)
4751  					_nppGUI._openSaveDir = dir_last;
4752  				else if (lstrcmp(value, TEXT(&quot;2&quot;)) == 0)
4753  					_nppGUI._openSaveDir = dir_userDef;
4754  				else
4755  					_nppGUI._openSaveDir = dir_followCurrent;
4756  			}
4757  			const TCHAR * path = element-&gt;Attribute(TEXT(&quot;defaultDirPath&quot;));
4758  			if (path &amp;&amp; path[0])
4759  			{
4760  				lstrcpyn(_nppGUI._defaultDir, path, MAX_PATH);
4761  				::ExpandEnvironmentStrings(_nppGUI._defaultDir, _nppGUI._defaultDirExp, MAX_PATH);
4762  			}
4763   		}
4764  		else if (!lstrcmp(nm, TEXT(&quot;titleBar&quot;)))
4765  		{
4766  			const TCHAR * value = element-&gt;Attribute(TEXT(&quot;short&quot;));
4767  			_nppGUI._shortTitlebar = false;	
4768  			if (value &amp;&amp; value[0])
4769  			{
4770  				if (lstrcmp(value, TEXT(&quot;yes&quot;)) == 0)
4771  					_nppGUI._shortTitlebar = true;
4772  				else if (lstrcmp(value, TEXT(&quot;no&quot;)) == 0)
4773  					_nppGUI._shortTitlebar = false;
4774  			}
4775  		}
4776  		else if (!lstrcmp(nm, TEXT(&quot;insertDateTime&quot;)))
4777  		{
4778  			const TCHAR* customFormat = element-&gt;Attribute(TEXT(&quot;customizedFormat&quot;));
4779  			if (customFormat != NULL &amp;&amp; customFormat[0])
4780  				_nppGUI._dateTimeFormat = customFormat;
4781  			const TCHAR* value = element-&gt;Attribute(TEXT(&quot;reverseDefaultOrder&quot;));
4782  			if (value &amp;&amp; value[0])
4783  			{
4784  				if (lstrcmp(value, TEXT(&quot;yes&quot;)) == 0)
4785  					_nppGUI._dateTimeReverseDefaultOrder = true;
4786  				else if (lstrcmp(value, TEXT(&quot;no&quot;)) == 0)
4787  					_nppGUI._dateTimeReverseDefaultOrder = false;
4788  			}
4789  		}
4790  		else if (!lstrcmp(nm, TEXT(&quot;wordCharList&quot;)))
4791  		{
4792  			const TCHAR * value = element-&gt;Attribute(TEXT(&quot;useDefault&quot;));
4793  			if (value &amp;&amp; value[0])
4794  			{
4795  				if (lstrcmp(value, TEXT(&quot;yes&quot;)) == 0)
4796  					_nppGUI._isWordCharDefault = true;
4797  				else if (lstrcmp(value, TEXT(&quot;no&quot;)) == 0)
4798  					_nppGUI._isWordCharDefault = false;
4799  			}
4800  			const TCHAR *charsAddedW = element-&gt;Attribute(TEXT(&quot;charsAdded&quot;));
4801  			if (charsAddedW)
4802  			{
4803  				WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
4804  				_nppGUI._customWordChars = wmc.wchar2char(charsAddedW, SC_CP_UTF8);
4805  			}
4806  		}
4807  		else if (!lstrcmp(nm, TEXT(&quot;delimiterSelection&quot;)))
4808  		{
4809  			int leftmost = 0;
4810  			element-&gt;Attribute(TEXT(&quot;leftmostDelimiter&quot;), &amp;leftmost);
4811  			if (leftmost &gt; 0 &amp;&amp; leftmost &lt; 256)
4812  				_nppGUI._leftmostDelimiter = static_cast&lt;char&gt;(leftmost);
4813  			int rightmost = 0;
4814  			element-&gt;Attribute(TEXT(&quot;rightmostDelimiter&quot;), &amp;rightmost);
4815  			if (rightmost &gt; 0 &amp;&amp; rightmost &lt; 256)
4816  				_nppGUI._rightmostDelimiter = static_cast&lt;char&gt;(rightmost);
4817  			const TCHAR *delimiterSelectionOnEntireDocument = element-&gt;Attribute(TEXT(&quot;delimiterSelectionOnEntireDocument&quot;));
4818  			if (delimiterSelectionOnEntireDocument != NULL &amp;&amp; !lstrcmp(delimiterSelectionOnEntireDocument, TEXT(&quot;yes&quot;)))
4819  				_nppGUI._delimiterSelectionOnEntireDocument = true;
4820  			else
4821  				_nppGUI._delimiterSelectionOnEntireDocument = false;
4822  		}
4823  		else if (!lstrcmp(nm, TEXT(&quot;largeFileRestriction&quot;)))
4824  		{
4825  			int fileSizeLimit4StylingMB = 0;
4826  			element-&gt;Attribute(TEXT(&quot;fileSizeMB&quot;), &amp;fileSizeLimit4StylingMB);
4827  			if (fileSizeLimit4StylingMB &gt; 0 &amp;&amp; fileSizeLimit4StylingMB &lt;= 4096)
4828  				_nppGUI._largeFileRestriction._largeFileSizeDefInByte = (static_cast&lt;int64_t&gt;(fileSizeLimit4StylingMB) * 1024 * 1024);
4829  			const TCHAR* boolVal = element-&gt;Attribute(TEXT(&quot;isEnabled&quot;));
4830  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;no&quot;)))
4831  				_nppGUI._largeFileRestriction._isEnabled = false;
4832  			else
4833  				_nppGUI._largeFileRestriction._isEnabled = true;
4834  			boolVal = element-&gt;Attribute(TEXT(&quot;allowAutoCompletion&quot;));
4835  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;yes&quot;)))
4836  				_nppGUI._largeFileRestriction._allowAutoCompletion = true;
4837  			else
4838  				_nppGUI._largeFileRestriction._allowAutoCompletion = false;
4839  			boolVal = element-&gt;Attribute(TEXT(&quot;allowBraceMatch&quot;));
4840  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;yes&quot;)))
4841  				_nppGUI._largeFileRestriction._allowBraceMatch = true;
4842  			else
4843  				_nppGUI._largeFileRestriction._allowBraceMatch = false;
4844  			boolVal = element-&gt;Attribute(TEXT(&quot;allowSmartHilite&quot;));
4845  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;yes&quot;)))
4846  				_nppGUI._largeFileRestriction._allowSmartHilite = true;
4847  			else
4848  				_nppGUI._largeFileRestriction._allowSmartHilite = false;
4849  			boolVal = element-&gt;Attribute(TEXT(&quot;allowClickableLink&quot;));
4850  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;yes&quot;)))
4851  				_nppGUI._largeFileRestriction._allowClickableLink = true;
4852  			else
4853  				_nppGUI._largeFileRestriction._allowClickableLink = false;
4854  			boolVal = element-&gt;Attribute(TEXT(&quot;deactivateWordWrap&quot;));
4855  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;no&quot;)))
4856  				_nppGUI._largeFileRestriction._deactivateWordWrap = false;
4857  			else
4858  				_nppGUI._largeFileRestriction._deactivateWordWrap = true;
4859  		}
4860  		else if (!lstrcmp(nm, TEXT(&quot;multiInst&quot;)))
4861  		{
4862  			int val = 0;
4863  			element-&gt;Attribute(TEXT(&quot;setting&quot;), &amp;val);
4864  			if (val &lt; 0 || val &gt; 2)
4865  				val = 0;
4866  			_nppGUI._multiInstSetting = (MultiInstSetting)val;
4867  			_nppGUI._clipboardHistoryPanelKeepState = parseYesNoBoolAttribute(TEXT(&quot;clipboardHistory&quot;));
4868  			_nppGUI._docListKeepState = parseYesNoBoolAttribute(TEXT(&quot;documentList&quot;));
4869  			_nppGUI._charPanelKeepState = parseYesNoBoolAttribute(TEXT(&quot;characterPanel&quot;));
4870  			_nppGUI._fileBrowserKeepState = parseYesNoBoolAttribute(TEXT(&quot;folderAsWorkspace&quot;));
4871  			_nppGUI._projectPanelKeepState = parseYesNoBoolAttribute(TEXT(&quot;projectPanels&quot;));
4872  			_nppGUI._docMapKeepState = parseYesNoBoolAttribute(TEXT(&quot;documentMap&quot;));
4873  			_nppGUI._funcListKeepState = parseYesNoBoolAttribute(TEXT(&quot;fuctionList&quot;));
4874  			_nppGUI._pluginPanelKeepState = parseYesNoBoolAttribute(TEXT(&quot;pluginPanels&quot;));
4875  		}
4876  		else if (!lstrcmp(nm, TEXT(&quot;searchEngine&quot;)))
4877  		{
4878  			int i;
4879  			if (element-&gt;Attribute(TEXT(&quot;searchEngineChoice&quot;), &amp;i))
4880  				_nppGUI._searchEngineChoice = static_cast&lt;NppGUI::SearchEngineChoice&gt;(i);
4881  			const TCHAR * searchEngineCustom = element-&gt;Attribute(TEXT(&quot;searchEngineCustom&quot;));
4882  			if (searchEngineCustom &amp;&amp; searchEngineCustom[0])
4883  				_nppGUI._searchEngineCustom = searchEngineCustom;
4884  		}
4885  		else if (!lstrcmp(nm, TEXT(&quot;Searching&quot;)))
4886  		{
4887  			const TCHAR* optNameMonoFont = element-&gt;Attribute(TEXT(&quot;monospacedFontFindDlg&quot;));
4888  			if (optNameMonoFont)
4889  				_nppGUI._monospacedFontFindDlg = (lstrcmp(optNameMonoFont, TEXT(&quot;yes&quot;)) == 0);
4890  			const TCHAR* optStopFillingFindField = element-&gt;Attribute(TEXT(&quot;stopFillingFindField&quot;));
4891  			if (optStopFillingFindField) 
4892  			{
4893  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optStopFillingFindField, TEXT(&quot;no&quot;)) == 0);
4894  				_nppGUI._fillFindFieldSelectCaret = _nppGUI._fillFindFieldWithSelected;
4895  			}
4896  			const TCHAR* optFillFindFieldWithSelected = element-&gt;Attribute(TEXT(&quot;fillFindFieldWithSelected&quot;));
4897  			if (optFillFindFieldWithSelected)
4898  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optFillFindFieldWithSelected, TEXT(&quot;yes&quot;)) == 0);
4899  			const TCHAR* optFillFindFieldSelectCaret = element-&gt;Attribute(TEXT(&quot;fillFindFieldSelectCaret&quot;));
4900  			if (optFillFindFieldSelectCaret)
4901  				_nppGUI._fillFindFieldSelectCaret = (lstrcmp(optFillFindFieldSelectCaret, TEXT(&quot;yes&quot;)) == 0);
4902  			const TCHAR* optFindDlgAlwaysVisible = element-&gt;Attribute(TEXT(&quot;findDlgAlwaysVisible&quot;));
4903  			if (optFindDlgAlwaysVisible)
4904  				_nppGUI._findDlgAlwaysVisible = (lstrcmp(optFindDlgAlwaysVisible, TEXT(&quot;yes&quot;)) == 0);
4905  			const TCHAR* optConfirmReplaceOpenDocs = element-&gt;Attribute(TEXT(&quot;confirmReplaceInAllOpenDocs&quot;));
4906  			if (optConfirmReplaceOpenDocs)
4907  				_nppGUI._confirmReplaceInAllOpenDocs = (lstrcmp(optConfirmReplaceOpenDocs, TEXT(&quot;yes&quot;)) == 0);
4908  			const TCHAR* optReplaceStopsWithoutFindingNext = element-&gt;Attribute(TEXT(&quot;replaceStopsWithoutFindingNext&quot;));
4909  			if (optReplaceStopsWithoutFindingNext)
4910  				_nppGUI._replaceStopsWithoutFindingNext = (lstrcmp(optReplaceStopsWithoutFindingNext, TEXT(&quot;yes&quot;)) == 0);
4911  		}
4912  		else if (!lstrcmp(nm, TEXT(&quot;MISC&quot;)))
4913  		{
4914  			const TCHAR * optName = element-&gt;Attribute(TEXT(&quot;fileSwitcherWithoutExtColumn&quot;));
4915  			if (optName)
4916  				_nppGUI._fileSwitcherWithoutExtColumn = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4917  			int i = 0;
4918  			if (element-&gt;Attribute(TEXT(&quot;fileSwitcherExtWidth&quot;), &amp;i))
4919  				_nppGUI._fileSwitcherExtWidth = i;
4920  			const TCHAR * optNamePath = element-&gt;Attribute(TEXT(&quot;fileSwitcherWithoutPathColumn&quot;));
4921  			if (optNamePath)
4922  				_nppGUI._fileSwitcherWithoutPathColumn = (lstrcmp(optNamePath, TEXT(&quot;yes&quot;)) == 0);
4923  			if (element-&gt;Attribute(TEXT(&quot;fileSwitcherPathWidth&quot;), &amp;i))
4924  				_nppGUI._fileSwitcherPathWidth = i;
4925  			_nppGUI._fileSwitcherDisableListViewGroups = parseYesNoBoolAttribute(TEXT(&quot;fileSwitcherNoGroups&quot;));
4926  			const TCHAR * optNameBackSlashEscape = element-&gt;Attribute(TEXT(&quot;backSlashIsEscapeCharacterForSql&quot;));
4927  			if (optNameBackSlashEscape &amp;&amp; !lstrcmp(optNameBackSlashEscape, TEXT(&quot;no&quot;)))
4928  				_nppGUI._backSlashIsEscapeCharacterForSql = false;
4929  			const TCHAR * optNameWriteTechnologyEngine = element-&gt;Attribute(TEXT(&quot;writeTechnologyEngine&quot;));
4930  			if (optNameWriteTechnologyEngine)
4931  				_nppGUI._writeTechnologyEngine = (lstrcmp(optNameWriteTechnologyEngine, TEXT(&quot;1&quot;)) == 0) ? directWriteTechnology : defaultTechnology;
4932  			const TCHAR * optNameFolderDroppedOpenFiles = element-&gt;Attribute(TEXT(&quot;isFolderDroppedOpenFiles&quot;));
4933  			if (optNameFolderDroppedOpenFiles)
4934  				_nppGUI._isFolderDroppedOpenFiles = (lstrcmp(optNameFolderDroppedOpenFiles, TEXT(&quot;yes&quot;)) == 0);
4935  			const TCHAR * optDocPeekOnTab = element-&gt;Attribute(TEXT(&quot;docPeekOnTab&quot;));
4936  			if (optDocPeekOnTab)
4937  				_nppGUI._isDocPeekOnTab = (lstrcmp(optDocPeekOnTab, TEXT(&quot;yes&quot;)) == 0);
4938  			const TCHAR * optDocPeekOnMap = element-&gt;Attribute(TEXT(&quot;docPeekOnMap&quot;));
4939  			if (optDocPeekOnMap)
4940  				_nppGUI._isDocPeekOnMap = (lstrcmp(optDocPeekOnMap, TEXT(&quot;yes&quot;)) == 0);
4941  			const TCHAR* optSortFunctionList = element-&gt;Attribute(TEXT(&quot;sortFunctionList&quot;));
4942  			if (optSortFunctionList)
4943  				_nppGUI._shouldSortFunctionList = (lstrcmp(optSortFunctionList, TEXT(&quot;yes&quot;)) == 0);
4944  			const TCHAR* saveDlgExtFilterToAllTypes = element-&gt;Attribute(TEXT(&quot;saveDlgExtFilterToAllTypes&quot;));
4945  			if (saveDlgExtFilterToAllTypes)
4946  				_nppGUI._setSaveDlgExtFiltToAllTypes = (lstrcmp(saveDlgExtFilterToAllTypes, TEXT(&quot;yes&quot;)) == 0);
4947  			const TCHAR * optMuteSounds = element-&gt;Attribute(TEXT(&quot;muteSounds&quot;));
4948  			if (optMuteSounds)
4949  				_nppGUI._muteSounds = lstrcmp(optMuteSounds, TEXT(&quot;yes&quot;)) == 0;
4950  			const TCHAR * optEnableFoldCmdToggable = element-&gt;Attribute(TEXT(&quot;enableFoldCmdToggable&quot;));
4951  			if (optEnableFoldCmdToggable)
4952  				_nppGUI._enableFoldCmdToggable = lstrcmp(optEnableFoldCmdToggable, TEXT(&quot;yes&quot;)) == 0;
4953  			const TCHAR * hideMenuRightShortcuts = element-&gt;Attribute(TEXT(&quot;hideMenuRightShortcuts&quot;));
4954  			if (hideMenuRightShortcuts)
4955  				_nppGUI._hideMenuRightShortcuts = lstrcmp(hideMenuRightShortcuts, TEXT(&quot;yes&quot;)) == 0;
4956  		}
4957  		else if (!lstrcmp(nm, TEXT(&quot;commandLineInterpreter&quot;)))
4958  		{
4959  			TiXmlNode *node = childNode-&gt;FirstChild();
4960  			if (node)
4961  			{
4962  				const TCHAR *cli = node-&gt;Value();
4963  				if (cli &amp;&amp; cli[0])
4964  					_nppGUI._commandLineInterpreter.assign(cli);
4965  			}
4966  		}
4967  		else if (!lstrcmp(nm, TEXT(&quot;DarkMode&quot;)))
4968  		{
4969  			_nppGUI._darkmode._isEnabled = parseYesNoBoolAttribute(TEXT(&quot;enable&quot;));
4970  			int i;
4971  			const TCHAR* val;
4972  			val = element-&gt;Attribute(TEXT(&quot;colorTone&quot;), &amp;i);
4973  			if (val)
4974  				_nppGUI._darkmode._colorTone = static_cast&lt;NppDarkMode::ColorTone&gt;(i);
4975  			val = element-&gt;Attribute(TEXT(&quot;customColorTop&quot;), &amp;i);
4976  			if (val)
4977  				_nppGUI._darkmode._customColors.pureBackground = i;
4978  			val = element-&gt;Attribute(TEXT(&quot;customColorMenuHotTrack&quot;), &amp;i);
4979  			if (val)
4980  				_nppGUI._darkmode._customColors.hotBackground = i;
4981  			val = element-&gt;Attribute(TEXT(&quot;customColorActive&quot;), &amp;i);
4982  			if (val)
4983  				_nppGUI._darkmode._customColors.softerBackground = i;
4984  			val = element-&gt;Attribute(TEXT(&quot;customColorMain&quot;), &amp;i);
4985  			if (val)
4986  				_nppGUI._darkmode._customColors.background = i;
4987  			val = element-&gt;Attribute(TEXT(&quot;customColorError&quot;), &amp;i);
4988  			if (val)
4989  				_nppGUI._darkmode._customColors.errorBackground = i;
4990  			val = element-&gt;Attribute(TEXT(&quot;customColorText&quot;), &amp;i);
4991  			if (val)
4992  				_nppGUI._darkmode._customColors.text = i;
4993  			val = element-&gt;Attribute(TEXT(&quot;customColorDarkText&quot;), &amp;i);
4994  			if (val)
4995  				_nppGUI._darkmode._customColors.darkerText = i;
4996  			val = element-&gt;Attribute(TEXT(&quot;customColorDisabledText&quot;), &amp;i);
4997  			if (val)
4998  				_nppGUI._darkmode._customColors.disabledText = i;
4999  			val = element-&gt;Attribute(TEXT(&quot;customColorLinkText&quot;), &amp;i);
5000  			if (val)
5001  				_nppGUI._darkmode._customColors.linkText = i;
5002  			val = element-&gt;Attribute(TEXT(&quot;customColorEdge&quot;), &amp;i);
5003  			if (val)
5004  				_nppGUI._darkmode._customColors.edge = i;
5005  			val = element-&gt;Attribute(TEXT(&quot;customColorHotEdge&quot;), &amp;i);
5006  			if (val)
5007  				_nppGUI._darkmode._customColors.hotEdge = i;
5008  			val = element-&gt;Attribute(TEXT(&quot;customColorDisabledEdge&quot;), &amp;i);
5009  			if (val)
5010  				_nppGUI._darkmode._customColors.disabledEdge = i;
5011  			auto parseStringAttribute = [&amp;element](const TCHAR* name, const TCHAR* defaultName = TEXT(&quot;&quot;)) -&gt; const TCHAR* {
5012  				const TCHAR* val = element-&gt;Attribute(name);
5013  				if (val != nullptr &amp;&amp; val[0])
5014  				{
5015  					return element-&gt;Attribute(name);
5016  				}
5017  				return defaultName;
5018  			};
5019  			auto parseToolBarIconsAttribute = [&amp;element](const TCHAR* name, int defaultValue = -1) -&gt; int {
5020  				int val;
5021  				const TCHAR* valStr = element-&gt;Attribute(name, &amp;val);
5022  				if (valStr != nullptr &amp;&amp; (val &gt;= 0 &amp;&amp; val &lt;= 4))
5023  				{
5024  					return val;
5025  				}
5026  				return defaultValue;
5027  			};
5028  			auto parseTabIconsAttribute = [&amp;element](const TCHAR* name, int defaultValue = -1) -&gt; int {
5029  				int val;
5030  				const TCHAR* valStr = element-&gt;Attribute(name, &amp;val);
5031  				if (valStr != nullptr &amp;&amp; (val &gt;= 0 &amp;&amp; val &lt;= 2))
5032  				{
5033  					return val;
5034  				}
5035  				return defaultValue;
5036  			};
5037  			auto&amp; windowsMode = _nppGUI._darkmode._advOptions._enableWindowsMode;
5038  			windowsMode = parseYesNoBoolAttribute(TEXT(&quot;enableWindowsMode&quot;));
5039  			auto&amp; darkDefaults = _nppGUI._darkmode._advOptions._darkDefaults;
5040  			auto&amp; darkThemeName = darkDefaults._xmlFileName;
5041  			darkThemeName = parseStringAttribute(TEXT(&quot;darkThemeName&quot;), TEXT(&quot;DarkModeDefault.xml&quot;));
5042  			darkDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT(&quot;darkToolBarIconSet&quot;), 0);
5043  			darkDefaults._tabIconSet = parseTabIconsAttribute(TEXT(&quot;darkTabIconSet&quot;), 2);
5044  			darkDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT(&quot;darkTabUseTheme&quot;));
5045  			auto&amp; lightDefaults = _nppGUI._darkmode._advOptions._lightDefaults;
5046  			auto&amp; lightThemeName = lightDefaults._xmlFileName;
5047  			lightThemeName = parseStringAttribute(TEXT(&quot;lightThemeName&quot;));
5048  			lightDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT(&quot;lightToolBarIconSet&quot;), 4);
5049  			lightDefaults._tabIconSet = parseTabIconsAttribute(TEXT(&quot;lightTabIconSet&quot;), 0);
5050  			lightDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT(&quot;lightTabUseTheme&quot;), true);
5051  			if (!windowsMode)
5052  			{
5053  				generic_string themePath;
5054  				generic_string xmlFileName = _nppGUI._darkmode._isEnabled ? darkThemeName : lightThemeName;
5055  				const bool isLocalOnly = _isLocal &amp;&amp; !_isCloud;
5056  				if (!xmlFileName.empty() &amp;&amp; lstrcmp(xmlFileName.c_str(), TEXT(&quot;stylers.xml&quot;)) != 0)
5057  				{
5058  					themePath = isLocalOnly ? _nppPath : _userPath;
5059  					pathAppend(themePath, TEXT(&quot;themes\\&quot;));
5060  					pathAppend(themePath, xmlFileName);
5061  					if (!isLocalOnly &amp;&amp; ::PathFileExists(themePath.c_str()) == FALSE)
5062  					{
5063  						themePath = _nppPath;
5064  						pathAppend(themePath, TEXT(&quot;themes\\&quot;));
5065  						pathAppend(themePath, xmlFileName);
5066  					}
5067  				}
5068  				else
5069  				{
5070  					themePath = isLocalOnly ? _nppPath : _userPath;
5071  					pathAppend(themePath, TEXT(&quot;stylers.xml&quot;));
5072  					if (!isLocalOnly &amp;&amp; ::PathFileExists(themePath.c_str()) == FALSE)
5073  					{
5074  						themePath = _nppPath;
5075  						pathAppend(themePath, TEXT(&quot;stylers.xml&quot;));
5076  					}
5077  				}
5078  				if (::PathFileExists(themePath.c_str()) == TRUE)
5079  				{
5080  					_nppGUI._themeName.assign(themePath);
5081  				}
5082  			}
5083  		}
5084  	}
5085  }
5086  void NppParameters::feedScintillaParam(TiXmlNode *node)
5087  {
5088  	TiXmlElement* element = node-&gt;ToElement();
5089  	auto parseYesNoBoolAttribute = [&amp;element](const TCHAR* name, bool defaultValue = false) -&gt; bool {
5090  		const TCHAR* nm = element-&gt;Attribute(name);
5091  		if (nm)
5092  		{
5093  			if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5094  				return true;
5095  			else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5096  				return false;
5097  		}
5098  		return defaultValue;
5099  	};
5100  	auto parseShowHideBoolAttribute = [&amp;element](const TCHAR* name, bool defaultValue = false) -&gt; bool {
5101  		const TCHAR* nm = element-&gt;Attribute(name);
5102  		if (nm)
5103  		{
5104  			if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5105  				return true;
5106  			else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5107  				return false;
5108  		}
5109  		return defaultValue;
5110  	};
5111  	const TCHAR *nm = element-&gt;Attribute(TEXT(&quot;lineNumberMargin&quot;));
5112  	if (nm)
5113  	{
5114  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5115  			_svp._lineNumberMarginShow = true;
5116  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5117  			_svp._lineNumberMarginShow = false;
5118  	}
5119  	nm = element-&gt;Attribute(TEXT(&quot;lineNumberDynamicWidth&quot;));
5120  	if (nm)
5121  	{
5122  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5123  			_svp._lineNumberMarginDynamicWidth = true;
5124  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5125  			_svp._lineNumberMarginDynamicWidth = false;
5126  	}
5127  	nm = element-&gt;Attribute(TEXT(&quot;bookMarkMargin&quot;));
5128  	if (nm)
5129  	{
5130  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5131  			_svp._bookMarkMarginShow = true;
5132  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5133  			_svp._bookMarkMarginShow = false;
5134  	}
5135  	nm = element-&gt;Attribute(TEXT(&quot;isChangeHistoryEnabled&quot;));
5136  	if (nm)
5137  	{
5138  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5139  		{
5140  			_svp._isChangeHistoryEnabled = true;
5141  			_svp._isChangeHistoryEnabled4NextSession = true;
5142  		}
5143  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5144  		{
5145  			_svp._isChangeHistoryEnabled = false;
5146  			_svp._isChangeHistoryEnabled4NextSession = false;
5147  		}
5148  	}
5149  	nm = element-&gt;Attribute(TEXT(&quot;indentGuideLine&quot;));
5150  	if (nm)
5151  	{
5152  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5153  			_svp._indentGuideLineShow = true;
5154  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5155  			_svp._indentGuideLineShow= false;
5156  	}
5157  	nm = element-&gt;Attribute(TEXT(&quot;folderMarkStyle&quot;));
5158  	if (nm)
5159  	{
5160  		if (!lstrcmp(nm, TEXT(&quot;box&quot;)))
5161  			_svp._folderStyle = FOLDER_STYLE_BOX;
5162  		else if (!lstrcmp(nm, TEXT(&quot;circle&quot;)))
5163  			_svp._folderStyle = FOLDER_STYLE_CIRCLE;
5164  		else if (!lstrcmp(nm, TEXT(&quot;arrow&quot;)))
5165  			_svp._folderStyle = FOLDER_STYLE_ARROW;
5166  		else if (!lstrcmp(nm, TEXT(&quot;simple&quot;)))
5167  			_svp._folderStyle = FOLDER_STYLE_SIMPLE;
5168  		else if (!lstrcmp(nm, TEXT(&quot;none&quot;)))
5169  			_svp._folderStyle = FOLDER_STYLE_NONE;
5170  	}
5171  	nm = element-&gt;Attribute(TEXT(&quot;lineWrapMethod&quot;));
5172  	if (nm)
5173  	{
5174  		if (!lstrcmp(nm, TEXT(&quot;default&quot;)))
5175  			_svp._lineWrapMethod = LINEWRAP_DEFAULT;
5176  		else if (!lstrcmp(nm, TEXT(&quot;aligned&quot;)))
5177  			_svp._lineWrapMethod = LINEWRAP_ALIGNED;
5178  		else if (!lstrcmp(nm, TEXT(&quot;indent&quot;)))
5179  			_svp._lineWrapMethod = LINEWRAP_INDENT;
5180  	}
5181  	nm = element-&gt;Attribute(TEXT(&quot;currentLineHilitingShow&quot;));
5182  	if (nm)
5183  	{
5184  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5185  			_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5186  		else
5187  			_svp._currentLineHiliteMode = LINEHILITE_NONE;
5188  	}
5189  	else
5190  	{
5191  		const TCHAR* currentLineModeStr = element-&gt;Attribute(TEXT(&quot;currentLineIndicator&quot;));
5192  		if (currentLineModeStr &amp;&amp; currentLineModeStr[0])
5193  		{
5194  			if (lstrcmp(currentLineModeStr, TEXT(&quot;1&quot;)) == 0)
5195  				_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5196  			else if (lstrcmp(currentLineModeStr, TEXT(&quot;2&quot;)) == 0)
5197  				_svp._currentLineHiliteMode = LINEHILITE_FRAME;
5198  			else
5199  				_svp._currentLineHiliteMode = LINEHILITE_NONE;
5200  		}
5201  	}
5202  	nm = element-&gt;Attribute(TEXT(&quot;currentLineFrameWidth&quot;));
5203  	if (nm)
5204  	{
5205  		unsigned char frameWidth{ 1 };
5206  		try
5207  		{
5208  			frameWidth = static_cast&lt;unsigned char&gt;(std::stoi(nm));
5209  		}
5210  		catch (...)
5211  		{
5212  		}
5213  		_svp._currentLineFrameWidth = (frameWidth &lt; 1) ? 1 : (frameWidth &gt; 6) ? 6 : frameWidth;
5214  	}
5215  	nm = element-&gt;Attribute(TEXT(&quot;virtualSpace&quot;));
5216  	if (nm)
5217  	{
5218  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5219  			_svp._virtualSpace = true;
5220  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5221  			_svp._virtualSpace = false;
5222  	}
5223  	nm = element-&gt;Attribute(TEXT(&quot;scrollBeyondLastLine&quot;));
5224  	if (nm)
5225  	{
5226  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5227  			_svp._scrollBeyondLastLine = true;
5228  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5229  			_svp._scrollBeyondLastLine = false;
5230  	}
5231  	nm = element-&gt;Attribute(TEXT(&quot;rightClickKeepsSelection&quot;));
5232  	if (nm)
5233  	{
5234  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5235  			_svp._rightClickKeepsSelection = true;
5236  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5237  			_svp._rightClickKeepsSelection = false;
5238  	}
5239  	nm = element-&gt;Attribute(TEXT(&quot;disableAdvancedScrolling&quot;));
5240  	if (nm)
5241  	{
5242  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5243  			_svp._disableAdvancedScrolling = true;
5244  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5245  			_svp._disableAdvancedScrolling = false;
5246  	}
5247  	nm = element-&gt;Attribute(TEXT(&quot;wrapSymbolShow&quot;));
5248  	if (nm)
5249  	{
5250  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5251  			_svp._wrapSymbolShow = true;
5252  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5253  			_svp._wrapSymbolShow = false;
5254  	}
5255  	nm = element-&gt;Attribute(TEXT(&quot;Wrap&quot;));
5256  	if (nm)
5257  	{
5258  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5259  			_svp._doWrap = true;
5260  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5261  			_svp._doWrap = false;
5262  	}
5263  	nm = element-&gt;Attribute(TEXT(&quot;isEdgeBgMode&quot;));
5264  	if (nm)
5265  	{
5266  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5267  			_svp._isEdgeBgMode = true;
5268  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5269  			_svp._isEdgeBgMode = false;
5270  	}
5271  	nm = element-&gt;Attribute(TEXT(&quot;borderEdge&quot;));
5272  	if (nm)
5273  	{
5274  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5275  			_svp._showBorderEdge = true;
5276  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5277  			_svp._showBorderEdge = false;
5278  	}
5279  	nm = element-&gt;Attribute(TEXT(&quot;edgeMultiColumnPos&quot;));
5280  	if (nm)
5281  	{
5282  		str2numberVector(nm, _svp._edgeMultiColumnPos);
5283  	}
5284  	int val;
5285  	nm = element-&gt;Attribute(TEXT(&quot;zoom&quot;), &amp;val);
5286  	if (nm)
5287  	{
5288  		_svp._zoom = val;
5289  	}
5290  	nm = element-&gt;Attribute(TEXT(&quot;zoom2&quot;), &amp;val);
5291  	if (nm)
5292  	{
5293  		_svp._zoom2 = val;
5294  	}
5295  	nm = element-&gt;Attribute(TEXT(&quot;whiteSpaceShow&quot;));
5296  	if (nm)
5297  	{
5298  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5299  			_svp._whiteSpaceShow = true;
5300  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5301  			_svp._whiteSpaceShow = false;
5302  	}
5303  	nm = element-&gt;Attribute(TEXT(&quot;eolShow&quot;));
5304  	if (nm)
5305  	{
5306  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5307  			_svp._eolShow = true;
5308  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5309  			_svp._eolShow = false;
5310  	}
5311  	nm = element-&gt;Attribute(TEXT(&quot;eolMode&quot;), &amp;val);
5312  	if (nm)
5313  	{
5314  		if (val &gt;= 0 &amp;&amp; val &lt;= 3)
5315  			_svp._eolMode = static_cast&lt;ScintillaViewParams::crlfMode&gt;(val);
5316  	}
5317  	_svp._npcShow = parseShowHideBoolAttribute(TEXT(&quot;npcShow&quot;), true);
5318  	nm = element-&gt;Attribute(TEXT(&quot;npcMode&quot;), &amp;val);
5319  	if (nm)
5320  	{
5321  		if (val &gt;= 1 &amp;&amp; val &lt;= 2)
5322  			_svp._npcMode = static_cast&lt;ScintillaViewParams::npcMode&gt;(val);
5323  	}
5324  	_svp._npcCustomColor = parseYesNoBoolAttribute(TEXT(&quot;npcCustomColor&quot;));
5325  	_svp._npcIncludeCcUniEol = parseYesNoBoolAttribute(TEXT(&quot;npcIncludeCcUniEOL&quot;));
5326  	_svp._ccUniEolShow = parseYesNoBoolAttribute(TEXT(&quot;ccShow&quot;), true);
5327  	nm = element-&gt;Attribute(TEXT(&quot;borderWidth&quot;), &amp;val);
5328  	if (nm)
5329  	{
5330  		if (val &gt;= 0 &amp;&amp; val &lt;= 30)
5331  			_svp._borderWidth = val;
5332  	}
5333  	nm = element-&gt;Attribute(TEXT(&quot;smoothFont&quot;));
5334  	if (nm)
5335  	{
5336  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5337  			_svp._doSmoothFont = true;
5338  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5339  			_svp._doSmoothFont = false;
5340  	}
5341  	nm = element-&gt;Attribute(TEXT(&quot;paddingLeft&quot;), &amp;val);
5342  	if (nm)
5343  	{
5344  		if (val &gt;= 0 &amp;&amp; val &lt;= 30)
5345  			_svp._paddingLeft = static_cast&lt;unsigned char&gt;(val);
5346  	}
5347  	nm = element-&gt;Attribute(TEXT(&quot;paddingRight&quot;), &amp;val);
5348  	if (nm)
5349  	{
5350  		if (val &gt;= 0 &amp;&amp; val &lt;= 30)
5351  			_svp._paddingRight = static_cast&lt;unsigned char&gt;(val);
5352  	}
5353  	nm = element-&gt;Attribute(TEXT(&quot;distractionFreeDivPart&quot;), &amp;val);
5354  	if (nm)
5355  	{
5356  		if (val &gt;= 3 &amp;&amp; val &lt;= 9)
5357  			_svp._distractionFreeDivPart = static_cast&lt;unsigned char&gt;(val);
5358  	}
5359  }
5360  void NppParameters::feedDockingManager(TiXmlNode *node)
5361  {
5362  	TiXmlElement *element = node-&gt;ToElement();
5363  	int i;
5364  	if (element-&gt;Attribute(TEXT(&quot;leftWidth&quot;), &amp;i))
5365  		_nppGUI._dockingData._leftWidth = i;
5366  	if (element-&gt;Attribute(TEXT(&quot;rightWidth&quot;), &amp;i))
5367  		_nppGUI._dockingData._rightWidth = i;
5368  	if (element-&gt;Attribute(TEXT(&quot;topHeight&quot;), &amp;i))
5369  		_nppGUI._dockingData._topHeight = i;
5370  	if (element-&gt;Attribute(TEXT(&quot;bottomHeight&quot;), &amp;i))
5371  		_nppGUI._dockingData._bottomHight = i;
5372  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;FloatingWindow&quot;));
5373  		childNode ;
5374  		childNode = childNode-&gt;NextSibling(TEXT(&quot;FloatingWindow&quot;)) )
5375  	{
5376  		TiXmlElement *floatElement = childNode-&gt;ToElement();
5377  		int cont;
5378  		if (floatElement-&gt;Attribute(TEXT(&quot;cont&quot;), &amp;cont))
5379  		{
5380  			int x = 0;
5381  			int y = 0;
5382  			int w = 100;
5383  			int h = 100;
5384  			floatElement-&gt;Attribute(TEXT(&quot;x&quot;), &amp;x);
5385  			floatElement-&gt;Attribute(TEXT(&quot;y&quot;), &amp;y);
5386  			floatElement-&gt;Attribute(TEXT(&quot;width&quot;), &amp;w);
5387  			floatElement-&gt;Attribute(TEXT(&quot;height&quot;), &amp;h);
5388  			_nppGUI._dockingData._flaotingWindowInfo.push_back(FloatingWindowInfo(cont, x, y, w, h));
5389  		}
5390  	}
5391  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;PluginDlg&quot;));
5392  		childNode ;
5393  		childNode = childNode-&gt;NextSibling(TEXT(&quot;PluginDlg&quot;)) )
5394  	{
5395  		TiXmlElement *dlgElement = childNode-&gt;ToElement();
5396  		const TCHAR *name = dlgElement-&gt;Attribute(TEXT(&quot;pluginName&quot;));
5397  		int id;
5398  		const TCHAR *idStr = dlgElement-&gt;Attribute(TEXT(&quot;id&quot;), &amp;id);
5399  		if (name &amp;&amp; idStr)
5400  		{
5401  			int curr = 0; 
5402  			int prev = 0; 
5403  			dlgElement-&gt;Attribute(TEXT(&quot;curr&quot;), &amp;curr);
5404  			dlgElement-&gt;Attribute(TEXT(&quot;prev&quot;), &amp;prev);
5405  			bool isVisible = false;
5406  			const TCHAR *val = dlgElement-&gt;Attribute(TEXT(&quot;isVisible&quot;));
5407  			if (val)
5408  			{
5409  				isVisible = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
5410  			}
5411  			_nppGUI._dockingData._pluginDockInfo.push_back(PluginDlgDockingInfo(name, id, curr, prev, isVisible));
5412  		}
5413  	}
5414  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;ActiveTabs&quot;));
5415  		childNode ;
5416  		childNode = childNode-&gt;NextSibling(TEXT(&quot;ActiveTabs&quot;)) )
5417  	{
5418  		TiXmlElement *dlgElement = childNode-&gt;ToElement();
5419  		int cont;
5420  		if (dlgElement-&gt;Attribute(TEXT(&quot;cont&quot;), &amp;cont))
5421  		{
5422  			int activeTab = 0;
5423  			dlgElement-&gt;Attribute(TEXT(&quot;activeTab&quot;), &amp;activeTab);
5424  			_nppGUI._dockingData._containerTabInfo.push_back(ContainerTabInfo(cont, activeTab));
5425  		}
5426  	}
5427  }
5428  void NppParameters::duplicateDockingManager(TiXmlNode* dockMngNode, TiXmlElement* dockMngElmt2Clone)
5429  {
5430  	if (!dockMngNode || !dockMngElmt2Clone) return;
5431  	TiXmlElement *dockMngElmt = dockMngNode-&gt;ToElement();
5432  	int i;
5433  	if (dockMngElmt-&gt;Attribute(TEXT(&quot;leftWidth&quot;), &amp;i))
5434  		dockMngElmt2Clone-&gt;SetAttribute(TEXT(&quot;leftWidth&quot;), i);
5435  	if (dockMngElmt-&gt;Attribute(TEXT(&quot;rightWidth&quot;), &amp;i))
5436  		dockMngElmt2Clone-&gt;SetAttribute(TEXT(&quot;rightWidth&quot;), i);
5437  	if (dockMngElmt-&gt;Attribute(TEXT(&quot;topHeight&quot;), &amp;i))
5438  		dockMngElmt2Clone-&gt;SetAttribute(TEXT(&quot;topHeight&quot;), i);
5439  	if (dockMngElmt-&gt;Attribute(TEXT(&quot;bottomHeight&quot;), &amp;i))
5440  		dockMngElmt2Clone-&gt;SetAttribute(TEXT(&quot;bottomHeight&quot;), i);
5441  	for (TiXmlNode *childNode = dockMngNode-&gt;FirstChildElement(TEXT(&quot;FloatingWindow&quot;));
5442  		childNode;
5443  		childNode = childNode-&gt;NextSibling(TEXT(&quot;FloatingWindow&quot;)))
5444  	{
5445  		TiXmlElement *floatElement = childNode-&gt;ToElement();
5446  		int cont;
5447  		if (floatElement-&gt;Attribute(TEXT(&quot;cont&quot;), &amp;cont))
5448  		{
5449  			TiXmlElement FWNode(TEXT(&quot;FloatingWindow&quot;));
5450  			FWNode.SetAttribute(TEXT(&quot;cont&quot;), cont);
5451  			int x = 0;
5452  			int y = 0;
5453  			int w = 100;
5454  			int h = 100;
5455  			floatElement-&gt;Attribute(TEXT(&quot;x&quot;), &amp;x);
5456  			FWNode.SetAttribute(TEXT(&quot;x&quot;), x);
5457  			floatElement-&gt;Attribute(TEXT(&quot;y&quot;), &amp;y);
5458  			FWNode.SetAttribute(TEXT(&quot;y&quot;), y);
5459  			floatElement-&gt;Attribute(TEXT(&quot;width&quot;), &amp;w);
5460  			FWNode.SetAttribute(TEXT(&quot;width&quot;), w);
5461  			floatElement-&gt;Attribute(TEXT(&quot;height&quot;), &amp;h);
5462  			FWNode.SetAttribute(TEXT(&quot;height&quot;), h);
5463  			dockMngElmt2Clone-&gt;InsertEndChild(FWNode);
5464  		}
5465  	}
5466  	for (TiXmlNode *childNode = dockMngNode-&gt;FirstChildElement(TEXT(&quot;PluginDlg&quot;));
5467  		childNode;
5468  		childNode = childNode-&gt;NextSibling(TEXT(&quot;PluginDlg&quot;)))
5469  	{
5470  		TiXmlElement *dlgElement = childNode-&gt;ToElement();
5471  		const TCHAR *name = dlgElement-&gt;Attribute(TEXT(&quot;pluginName&quot;));
5472  		TiXmlElement PDNode(TEXT(&quot;PluginDlg&quot;));
5473  		int id;
5474  		const TCHAR *idStr = dlgElement-&gt;Attribute(TEXT(&quot;id&quot;), &amp;id);
5475  		if (name &amp;&amp; idStr)
5476  		{
5477  			int curr = 0; 
5478  			int prev = 0; 
5479  			dlgElement-&gt;Attribute(TEXT(&quot;curr&quot;), &amp;curr);
5480  			dlgElement-&gt;Attribute(TEXT(&quot;prev&quot;), &amp;prev);
5481  			bool isVisible = false;
5482  			const TCHAR *val = dlgElement-&gt;Attribute(TEXT(&quot;isVisible&quot;));
5483  			if (val)
5484  			{
5485  				isVisible = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
5486  			}
5487  			PDNode.SetAttribute(TEXT(&quot;pluginName&quot;), name);
5488  			PDNode.SetAttribute(TEXT(&quot;id&quot;), idStr);
5489  			PDNode.SetAttribute(TEXT(&quot;curr&quot;), curr);
5490  			PDNode.SetAttribute(TEXT(&quot;prev&quot;), prev);
5491  			PDNode.SetAttribute(TEXT(&quot;isVisible&quot;), isVisible ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5492  			dockMngElmt2Clone-&gt;InsertEndChild(PDNode);
5493  		}
5494  	}
5495  	for (TiXmlNode *childNode = dockMngNode-&gt;FirstChildElement(TEXT(&quot;ActiveTabs&quot;));
5496  		childNode;
5497  		childNode = childNode-&gt;NextSibling(TEXT(&quot;ActiveTabs&quot;)))
5498  	{
5499  		TiXmlElement *dlgElement = childNode-&gt;ToElement();
5500  		TiXmlElement CTNode(TEXT(&quot;ActiveTabs&quot;));
5501  		int cont;
5502  		if (dlgElement-&gt;Attribute(TEXT(&quot;cont&quot;), &amp;cont))
5503  		{
5504  			int activeTab = 0;
5505  			dlgElement-&gt;Attribute(TEXT(&quot;activeTab&quot;), &amp;activeTab);
5506  			CTNode.SetAttribute(TEXT(&quot;cont&quot;), cont);
5507  			CTNode.SetAttribute(TEXT(&quot;activeTab&quot;), activeTab);
5508  			dockMngElmt2Clone-&gt;InsertEndChild(CTNode);
5509  		}
5510  	}
5511  }
5512  bool NppParameters::writeScintillaParams()
5513  {
5514  	if (!_pXmlUserDoc) return false;
5515  	const TCHAR *pViewName = TEXT(&quot;ScintillaPrimaryView&quot;);
5516  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
5517  	if (!nppRoot)
5518  	{
5519  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
5520  	}
5521  	TiXmlNode *configsRoot = nppRoot-&gt;FirstChildElement(TEXT(&quot;GUIConfigs&quot;));
5522  	if (!configsRoot)
5523  	{
5524  		configsRoot = nppRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfigs&quot;)));
5525  	}
5526  	TiXmlNode *scintNode = getChildElementByAttribut(configsRoot, TEXT(&quot;GUIConfig&quot;), TEXT(&quot;name&quot;), pViewName);
5527  	if (!scintNode)
5528  	{
5529  		scintNode = configsRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;)));
5530  		(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), pViewName);
5531  	}
5532  	auto setYesNoBoolAttribute = [&amp;scintNode](const TCHAR* name, bool value) -&gt; void {
5533  		const TCHAR* pStr = value ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5534  		(scintNode-&gt;ToElement())-&gt;SetAttribute(name, pStr);
5535  	};
5536  	auto setShowHideBoolAttribute = [&amp;scintNode](const TCHAR* name, bool value) -&gt; void {
5537  		const TCHAR* pStr = value ? TEXT(&quot;show&quot;) : TEXT(&quot;hide&quot;);
5538  		(scintNode-&gt;ToElement())-&gt;SetAttribute(name, pStr);
5539  	};
5540  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;lineNumberMargin&quot;), _svp._lineNumberMarginShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5541  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;lineNumberDynamicWidth&quot;), _svp._lineNumberMarginDynamicWidth ?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5542  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;bookMarkMargin&quot;), _svp._bookMarkMarginShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5543  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;indentGuideLine&quot;), _svp._indentGuideLineShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5544  	const TCHAR *pFolderStyleStr = (_svp._folderStyle == FOLDER_STYLE_SIMPLE)?TEXT(&quot;simple&quot;):
5545  									(_svp._folderStyle == FOLDER_STYLE_ARROW)?TEXT(&quot;arrow&quot;):
5546  										(_svp._folderStyle == FOLDER_STYLE_CIRCLE)?TEXT(&quot;circle&quot;):
5547  										(_svp._folderStyle == FOLDER_STYLE_NONE)?TEXT(&quot;none&quot;):TEXT(&quot;box&quot;);
5548  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;folderMarkStyle&quot;), pFolderStyleStr);
5549  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;isChangeHistoryEnabled&quot;), _svp._isChangeHistoryEnabled4NextSession ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5550  	const TCHAR *pWrapMethodStr = (_svp._lineWrapMethod == LINEWRAP_ALIGNED)?TEXT(&quot;aligned&quot;):
5551  								(_svp._lineWrapMethod == LINEWRAP_INDENT)?TEXT(&quot;indent&quot;):TEXT(&quot;default&quot;);
5552  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;lineWrapMethod&quot;), pWrapMethodStr);
5553  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;currentLineIndicator&quot;), _svp._currentLineHiliteMode);
5554  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;currentLineFrameWidth&quot;), _svp._currentLineFrameWidth);
5555  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;virtualSpace&quot;), _svp._virtualSpace?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5556  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;scrollBeyondLastLine&quot;), _svp._scrollBeyondLastLine?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5557  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;rightClickKeepsSelection&quot;), _svp._rightClickKeepsSelection ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5558  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;disableAdvancedScrolling&quot;), _svp._disableAdvancedScrolling?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5559  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;wrapSymbolShow&quot;), _svp._wrapSymbolShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5560  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;Wrap&quot;), _svp._doWrap?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5561  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;borderEdge&quot;), _svp._showBorderEdge ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5562  	generic_string edgeColumnPosStr;
5563  	for (auto i : _svp._edgeMultiColumnPos)
5564  	{
5565  		std::string s = std::to_string(i);
5566  		edgeColumnPosStr += generic_string(s.begin(), s.end());
5567  		edgeColumnPosStr += TEXT(&quot; &quot;);
5568  	}
5569  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;isEdgeBgMode&quot;), _svp._isEdgeBgMode ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5570  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;edgeMultiColumnPos&quot;), edgeColumnPosStr);
5571  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;zoom&quot;), static_cast&lt;int&gt;(_svp._zoom));
5572  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;zoom2&quot;), static_cast&lt;int&gt;(_svp._zoom2));
5573  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;whiteSpaceShow&quot;), _svp._whiteSpaceShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5574  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;eolShow&quot;), _svp._eolShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5575  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;eolMode&quot;), _svp._eolMode);
5576  	setShowHideBoolAttribute(TEXT(&quot;npcShow&quot;), _svp._npcShow);
5577  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;npcMode&quot;), static_cast&lt;int&gt;(_svp._npcMode));
5578  	setYesNoBoolAttribute(TEXT(&quot;npcCustomColor&quot;), _svp._npcCustomColor);
5579  	setYesNoBoolAttribute(TEXT(&quot;npcIncludeCcUniEOL&quot;), _svp._npcIncludeCcUniEol);
5580  	setYesNoBoolAttribute(TEXT(&quot;ccShow&quot;), _svp._ccUniEolShow);
5581  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;borderWidth&quot;), _svp._borderWidth);
5582  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;smoothFont&quot;), _svp._doSmoothFont ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5583  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;paddingLeft&quot;), _svp._paddingLeft);
5584  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;paddingRight&quot;), _svp._paddingRight);
5585  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;distractionFreeDivPart&quot;), _svp._distractionFreeDivPart);
5586  	return true;
5587  }
5588  void NppParameters::createXmlTreeFromGUIParams()
5589  {
5590  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
5591  	if (!nppRoot)
5592  	{
5593  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
5594  	}
5595  	TiXmlNode *oldGUIRoot = nppRoot-&gt;FirstChildElement(TEXT(&quot;GUIConfigs&quot;));
5596  	TiXmlElement* dockMngNodeDup = nullptr;
5597  	TiXmlNode* dockMngNodeOriginal = nullptr;
5598  	if (oldGUIRoot &amp;&amp; _nppGUI._isCmdlineNosessionActivated)
5599  	{
5600  		for (TiXmlNode *childNode = oldGUIRoot-&gt;FirstChildElement(TEXT(&quot;GUIConfig&quot;));
5601  			childNode;
5602  			childNode = childNode-&gt;NextSibling(TEXT(&quot;GUIConfig&quot;)))
5603  		{
5604  			TiXmlElement* element = childNode-&gt;ToElement();
5605  			const TCHAR* nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
5606  			if (nullptr == nm)
5607  				continue;
5608  			if (!lstrcmp(nm, TEXT(&quot;DockingManager&quot;)))
5609  			{
5610  				dockMngNodeOriginal = childNode;
5611  				break;
5612  			}
5613  		}
5614  		if (dockMngNodeOriginal)
5615  		{
5616  			dockMngNodeDup = new TiXmlElement(TEXT(&quot;GUIConfig&quot;));
5617  			dockMngNodeDup-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;DockingManager&quot;));
5618  			duplicateDockingManager(dockMngNodeOriginal, dockMngNodeDup);
5619  		}
5620  	}
5621  	if (oldGUIRoot)
5622  	{
5623  		nppRoot-&gt;RemoveChild(oldGUIRoot);
5624  	}
5625  	TiXmlNode *newGUIRoot = nppRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfigs&quot;)));
5626  	{
5627  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5628  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;ToolBar&quot;));
5629  		const TCHAR *pStr = (_nppGUI._toolbarShow) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5630  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;visible&quot;), pStr);
5631  		if (_nppGUI._toolBarStatus == TB_SMALL)
5632  			pStr = TEXT(&quot;small&quot;);
5633  		else if (_nppGUI._toolBarStatus == TB_LARGE)
5634  			pStr = TEXT(&quot;large&quot;);
5635  		else if (_nppGUI._toolBarStatus == TB_SMALL2)
5636  			pStr = TEXT(&quot;small2&quot;);
5637  		else if (_nppGUI._toolBarStatus == TB_LARGE2)
5638  			pStr = TEXT(&quot;large2&quot;);
5639  		else 
5640  			pStr = TEXT(&quot;standard&quot;);
5641  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5642  	}
5643  	{
5644  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5645  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;StatusBar&quot;));
5646  		const TCHAR *pStr = _nppGUI._statusBarShow ? TEXT(&quot;show&quot;) : TEXT(&quot;hide&quot;);
5647  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5648  	}
5649  	{
5650  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5651  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;TabBar&quot;));
5652  		const TCHAR *pStr = (_nppGUI._tabStatus &amp; TAB_DRAWTOPBAR) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5653  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;dragAndDrop&quot;), pStr);
5654  		pStr = (_nppGUI._tabStatus &amp; TAB_DRAGNDROP) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5655  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;drawTopBar&quot;), pStr);
5656  		pStr = (_nppGUI._tabStatus &amp; TAB_DRAWINACTIVETAB) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5657  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;drawInactiveTab&quot;), pStr);
5658  		pStr = (_nppGUI._tabStatus &amp; TAB_REDUCE) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5659  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;reduce&quot;), pStr);
5660  		pStr = (_nppGUI._tabStatus &amp; TAB_CLOSEBUTTON) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5661  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;closeButton&quot;), pStr);
5662  		pStr = (_nppGUI._tabStatus &amp; TAB_DBCLK2CLOSE) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5663  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;doubleClick2Close&quot;), pStr);
5664  		pStr = (_nppGUI._tabStatus &amp; TAB_VERTICAL) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5665  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;vertical&quot;), pStr);
5666  		pStr = (_nppGUI._tabStatus &amp; TAB_MULTILINE) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5667  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;multiLine&quot;), pStr);
5668  		pStr = (_nppGUI._tabStatus &amp; TAB_HIDE) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5669  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;hide&quot;), pStr);
5670  		pStr = (_nppGUI._tabStatus &amp; TAB_QUITONEMPTY) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5671  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;quitOnEmpty&quot;), pStr);
5672  		pStr = (_nppGUI._tabStatus &amp; TAB_ALTICONS) ? TEXT(&quot;1&quot;) : TEXT(&quot;0&quot;);
5673  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;iconSetNumber&quot;), pStr);
5674  	}
5675  	{
5676  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5677  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;ScintillaViewsSplitter&quot;));
5678  		const TCHAR *pStr = _nppGUI._splitterPos == POS_VERTICAL ? TEXT(&quot;vertical&quot;) : TEXT(&quot;horizontal&quot;);
5679  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5680  	}
5681  	{
5682  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5683  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;UserDefineDlg&quot;));
5684  		const TCHAR *pStr = (_nppGUI._userDefineDlgStatus &amp; UDD_DOCKED) ? TEXT(&quot;docked&quot;) : TEXT(&quot;undocked&quot;);
5685  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;position&quot;), pStr);
5686  		pStr = (_nppGUI._userDefineDlgStatus &amp; UDD_SHOW) ? TEXT(&quot;show&quot;) : TEXT(&quot;hide&quot;);
5687  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5688  	}
5689  	{
5690  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5691  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;TabSetting&quot;));
5692  		const TCHAR *pStr = _nppGUI._tabReplacedBySpace ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5693  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;replaceBySpace&quot;), pStr);
5694  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;size&quot;), _nppGUI._tabSize);
5695  	}
5696  	{
5697  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5698  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;AppPosition&quot;));
5699  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;x&quot;), _nppGUI._appPos.left);
5700  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;y&quot;), _nppGUI._appPos.top);
5701  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;width&quot;), _nppGUI._appPos.right);
5702  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;height&quot;), _nppGUI._appPos.bottom);
5703  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isMaximized&quot;), _nppGUI._isMaximized ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5704  	}
5705  	{
5706  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5707  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;FindWindowPosition&quot;));
5708  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;left&quot;), _nppGUI._findWindowPos.left);
5709  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;top&quot;), _nppGUI._findWindowPos.top);
5710  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;right&quot;), _nppGUI._findWindowPos.right);
5711  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;bottom&quot;), _nppGUI._findWindowPos.bottom);
5712  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isLessModeOn&quot;), _nppGUI._findWindowLessMode ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5713  	}
5714  	{
5715  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5716  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;FinderConfig&quot;));
5717  		const TCHAR* pStr = _nppGUI._finderLinesAreCurrentlyWrapped ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5718  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;wrappedLines&quot;), pStr);
5719  		pStr = _nppGUI._finderPurgeBeforeEverySearch ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5720  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;purgeBeforeEverySearch&quot;), pStr);
5721  		pStr = _nppGUI._finderShowOnlyOneEntryPerFoundLine ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5722  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;showOnlyOneEntryPerFoundLine&quot;), pStr);
5723  	}
5724  	{
5725  		TiXmlElement *element = insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;noUpdate&quot;), !_nppGUI._autoUpdateOpt._doAutoUpdate);
5726  		element-&gt;SetAttribute(TEXT(&quot;intervalDays&quot;), _nppGUI._autoUpdateOpt._intervalDays);
5727  		element-&gt;SetAttribute(TEXT(&quot;nextUpdateDate&quot;), _nppGUI._autoUpdateOpt._nextUpdateDate.toString().c_str());
5728  	}
5729  	{
5730  		const TCHAR *pStr = TEXT(&quot;no&quot;);
5731  		if (_nppGUI._fileAutoDetection &amp; cdEnabledOld)
5732  		{
5733  			pStr = TEXT(&quot;yesOld&quot;);
5734  			if ((_nppGUI._fileAutoDetection &amp; cdAutoUpdate) &amp;&amp; (_nppGUI._fileAutoDetection &amp; cdGo2end))
5735  			{
5736  				pStr = TEXT(&quot;autoUpdate2EndOld&quot;);
5737  			}
5738  			else if (_nppGUI._fileAutoDetection &amp; cdAutoUpdate)
5739  			{
5740  				pStr = TEXT(&quot;autoOld&quot;);
5741  			}
5742  			else if (_nppGUI._fileAutoDetection &amp; cdGo2end)
5743  			{
5744  				pStr = TEXT(&quot;Update2EndOld&quot;);
5745  			}
5746  		}
5747  		else if (_nppGUI._fileAutoDetection &amp; cdEnabledNew)
5748  		{
5749  			pStr = TEXT(&quot;yes&quot;);
5750  			if ((_nppGUI._fileAutoDetection &amp; cdAutoUpdate) &amp;&amp; (_nppGUI._fileAutoDetection &amp; cdGo2end))
5751  			{
5752  				pStr = TEXT(&quot;autoUpdate2End&quot;);
5753  			}
5754  			else if (_nppGUI._fileAutoDetection &amp; cdAutoUpdate)
5755  			{
5756  				pStr = TEXT(&quot;auto&quot;);
5757  			}
5758  			else if (_nppGUI._fileAutoDetection &amp; cdGo2end)
5759  			{
5760  				pStr = TEXT(&quot;Update2End&quot;);
5761  			}
5762  		}
5763  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5764  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Auto-detection&quot;));
5765  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5766  	}
5767  	{
5768  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;CheckHistoryFiles&quot;), _nppGUI._checkHistoryFiles);
5769  	}
5770  	{
5771  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;TrayIcon&quot;), _nppGUI._isMinimizedToTray);
5772  	}
5773  	{
5774  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;MaitainIndent&quot;), _nppGUI._maitainIndent);
5775  	}
5776  	{
5777  		TiXmlElement * ele = insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;TagsMatchHighLight&quot;), _nppGUI._enableTagsMatchHilite);
5778  		ele-&gt;SetAttribute(TEXT(&quot;TagAttrHighLight&quot;), _nppGUI._enableTagAttrsHilite ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5779  		ele-&gt;SetAttribute(TEXT(&quot;HighLightNonHtmlZone&quot;), _nppGUI._enableHiliteNonHTMLZone ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5780  	}
5781  	{
5782  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;RememberLastSession&quot;), _nppGUI._rememberLastSession);
5783  	}
5784  	{
5785  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;DetectEncoding&quot;), _nppGUI._detectEncoding);
5786  	}
5787  	{
5788  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;SaveAllConfirm&quot;), _nppGUI._saveAllConfirm);
5789  	}
5790  	{
5791  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5792  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;NewDocDefaultSettings&quot;));
5793  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;format&quot;), static_cast&lt;int32_t&gt;(_nppGUI._newDocDefaultSettings._format));
5794  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;encoding&quot;), _nppGUI._newDocDefaultSettings._unicodeMode);
5795  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;lang&quot;), _nppGUI._newDocDefaultSettings._lang);
5796  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;codepage&quot;), _nppGUI._newDocDefaultSettings._codepage);
5797  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;openAnsiAsUTF8&quot;), _nppGUI._newDocDefaultSettings._openAnsiAsUtf8 ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5798  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;addNewDocumentOnStartup&quot;), _nppGUI._newDocDefaultSettings._addNewDocumentOnStartup ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5799  	}
5800  	{
5801  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5802  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;langsExcluded&quot;));
5803  		writeExcludedLangList(GUIConfigElement);
5804  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;langMenuCompact&quot;), _nppGUI._isLangMenuCompact ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5805  	}
5806  	{
5807  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5808  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Print&quot;));
5809  		writePrintSetting(GUIConfigElement);
5810  	}
5811  	{
5812  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5813  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Backup&quot;));
5814  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;action&quot;), _nppGUI._backup);
5815  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;useCustumDir&quot;), _nppGUI._useDir ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5816  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;dir&quot;), _nppGUI._backupDir.c_str());
5817  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isSnapshotMode&quot;), _nppGUI._isSnapshotMode ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5818  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;snapshotBackupTiming&quot;), static_cast&lt;int32_t&gt;(_nppGUI._snapshotBackupTiming));
5819  	}
5820  	{
5821  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;TaskList&quot;), _nppGUI._doTaskList);
5822  	}
5823  	{
5824  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;MRU&quot;), _nppGUI._styleMRU);
5825  	}
5826  	{
5827  		TCHAR szStr [12] = TEXT(&quot;0&quot;);
5828  		_itow(_nppGUI._styleURL, szStr, 10);
5829  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5830  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;URL&quot;));
5831  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(szStr));
5832  	}
5833  	{
5834  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5835  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;uriCustomizedSchemes&quot;));
5836  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._uriSchemes.c_str()));
5837  	}
5838  	{
5839  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5840  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;globalOverride&quot;));
5841  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fg&quot;), _nppGUI._globalOverride.enableFg ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5842  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;bg&quot;), _nppGUI._globalOverride.enableBg ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5843  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;font&quot;), _nppGUI._globalOverride.enableFont ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5844  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), _nppGUI._globalOverride.enableFontSize ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5845  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;bold&quot;), _nppGUI._globalOverride.enableBold ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5846  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;italic&quot;), _nppGUI._globalOverride.enableItalic ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5847  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;underline&quot;), _nppGUI._globalOverride.enableUnderLine ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5848  	}
5849  	{
5850  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5851  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;auto-completion&quot;));
5852  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;autoCAction&quot;), _nppGUI._autocStatus);
5853  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;triggerFromNbChar&quot;), static_cast&lt;int32_t&gt;(_nppGUI._autocFromLen));
5854  		const TCHAR * pStr = _nppGUI._autocIgnoreNumbers ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5855  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;autoCIgnoreNumbers&quot;), pStr);
5856  		pStr = _nppGUI._autocInsertSelectedUseENTER ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5857  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;insertSelectedItemUseENTER&quot;), pStr);
5858  		pStr = _nppGUI._autocInsertSelectedUseTAB ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5859  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;insertSelectedItemUseTAB&quot;), pStr);
5860  		pStr = _nppGUI._autocBrief ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5861  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;autoCBrief&quot;), pStr);
5862  		pStr = _nppGUI._funcParams ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5863  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;funcParams&quot;), pStr);
5864  	}
5865  	{
5866  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5867  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;auto-insert&quot;));
5868  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;parentheses&quot;), _nppGUI._matchedPairConf._doParentheses ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5869  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;brackets&quot;), _nppGUI._matchedPairConf._doBrackets ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5870  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;curlyBrackets&quot;), _nppGUI._matchedPairConf._doCurlyBrackets ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5871  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;quotes&quot;), _nppGUI._matchedPairConf._doQuotes ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5872  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;doubleQuotes&quot;), _nppGUI._matchedPairConf._doDoubleQuotes ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5873  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;htmlXmlTag&quot;), _nppGUI._matchedPairConf._doHtmlXmlTag ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5874  		TiXmlElement hist_element{ TEXT(&quot;&quot;) };
5875  		hist_element.SetValue(TEXT(&quot;UserDefinePair&quot;));
5876  		for (size_t i = 0, nb = _nppGUI._matchedPairConf._matchedPairs.size(); i &lt; nb; ++i)
5877  		{
5878  			int open = _nppGUI._matchedPairConf._matchedPairs[i].first;
5879  			int close = _nppGUI._matchedPairConf._matchedPairs[i].second;
5880  			(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;open&quot;), open);
5881  			(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;close&quot;), close);
5882  			GUIConfigElement-&gt;InsertEndChild(hist_element);
5883  		}
5884  	}
5885  	{
5886  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5887  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;sessionExt&quot;));
5888  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._definedSessionExt.c_str()));
5889  	}
5890  	{
5891  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5892  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;workspaceExt&quot;));
5893  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._definedWorkspaceExt.c_str()));
5894  	}
5895  	{
5896  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5897  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;MenuBar&quot;));
5898  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._menuBarShow ? TEXT(&quot;show&quot;) : TEXT(&quot;hide&quot;)));
5899  	}
5900  	{
5901  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5902  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Caret&quot;));
5903  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;width&quot;), _nppGUI._caretWidth);
5904  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;blinkRate&quot;), _nppGUI._caretBlinkRate);
5905  	}
5906  	{
5907  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5908  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;ScintillaGlobalSettings&quot;));
5909  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;enableMultiSelection&quot;), _nppGUI._enableMultiSelection ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5910  	}
5911  	{
5912  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5913  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;openSaveDir&quot;));
5914  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;value&quot;), _nppGUI._openSaveDir);
5915  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;defaultDirPath&quot;), _nppGUI._defaultDir);
5916  	}
5917  	{
5918  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5919  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;titleBar&quot;));
5920  		const TCHAR *pStr = (_nppGUI._shortTitlebar) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5921  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;short&quot;), pStr);
5922  	}
5923  	{
5924  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5925  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;insertDateTime&quot;));
5926  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customizedFormat&quot;), _nppGUI._dateTimeFormat.c_str());
5927  		const TCHAR* pStr = (_nppGUI._dateTimeReverseDefaultOrder) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5928  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;reverseDefaultOrder&quot;), pStr);
5929  	}
5930  	{
5931  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5932  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;wordCharList&quot;));
5933  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;useDefault&quot;), _nppGUI._isWordCharDefault ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5934  		WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
5935  		const wchar_t* charsAddStr = wmc.char2wchar(_nppGUI._customWordChars.c_str(), SC_CP_UTF8);
5936  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;charsAdded&quot;), charsAddStr);
5937  	}
5938  	{
5939  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5940  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;delimiterSelection&quot;));
5941  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;leftmostDelimiter&quot;), _nppGUI._leftmostDelimiter);
5942  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;rightmostDelimiter&quot;), _nppGUI._rightmostDelimiter);
5943  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;delimiterSelectionOnEntireDocument&quot;), _nppGUI._delimiterSelectionOnEntireDocument ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5944  	}
5945  	{
5946  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5947  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;largeFileRestriction&quot;));
5948  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSizeMB&quot;), static_cast&lt;int&gt;((_nppGUI._largeFileRestriction._largeFileSizeDefInByte / 1024) / 1024));
5949  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isEnabled&quot;), _nppGUI._largeFileRestriction._isEnabled ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5950  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;allowAutoCompletion&quot;), _nppGUI._largeFileRestriction._allowAutoCompletion ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5951  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;allowBraceMatch&quot;), _nppGUI._largeFileRestriction._allowBraceMatch ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5952  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;allowSmartHilite&quot;), _nppGUI._largeFileRestriction._allowSmartHilite ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5953  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;allowClickableLink&quot;), _nppGUI._largeFileRestriction._allowClickableLink ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5954  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;deactivateWordWrap&quot;), _nppGUI._largeFileRestriction._deactivateWordWrap ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5955  	}
5956  	{
5957  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5958  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;multiInst&quot;));
5959  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;setting&quot;), _nppGUI._multiInstSetting);
5960  		auto setYesNoBoolAttribute = [&amp;GUIConfigElement](const TCHAR* name, bool value) -&gt; void {
5961  			const TCHAR* pStr = value ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5962  			GUIConfigElement-&gt;SetAttribute(name, pStr);
5963  		};
5964  		setYesNoBoolAttribute(TEXT(&quot;clipboardHistory&quot;), _nppGUI._clipboardHistoryPanelKeepState);
5965  		setYesNoBoolAttribute(TEXT(&quot;documentList&quot;), _nppGUI._docListKeepState);
5966  		setYesNoBoolAttribute(TEXT(&quot;characterPanel&quot;), _nppGUI._charPanelKeepState);
5967  		setYesNoBoolAttribute(TEXT(&quot;folderAsWorkspace&quot;), _nppGUI._fileBrowserKeepState);
5968  		setYesNoBoolAttribute(TEXT(&quot;projectPanels&quot;), _nppGUI._projectPanelKeepState);
5969  		setYesNoBoolAttribute(TEXT(&quot;documentMap&quot;), _nppGUI._docMapKeepState);
5970  		setYesNoBoolAttribute(TEXT(&quot;fuctionList&quot;), _nppGUI._funcListKeepState);
5971  		setYesNoBoolAttribute(TEXT(&quot;pluginPanels&quot;), _nppGUI._pluginPanelKeepState);
5972  	}
5973  	{
5974  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5975  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;MISC&quot;));
5976  		auto setYesNoBoolAttribute = [&amp;GUIConfigElement](const TCHAR* name, bool value) -&gt; void {
5977  			const TCHAR* pStr = value ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5978  			GUIConfigElement-&gt;SetAttribute(name, pStr);
5979  		};
5980  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSwitcherWithoutExtColumn&quot;), _nppGUI._fileSwitcherWithoutExtColumn ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5981  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSwitcherExtWidth&quot;), _nppGUI._fileSwitcherExtWidth);
5982  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSwitcherWithoutPathColumn&quot;), _nppGUI._fileSwitcherWithoutPathColumn ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5983  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSwitcherPathWidth&quot;), _nppGUI._fileSwitcherPathWidth);
5984  		setYesNoBoolAttribute(TEXT(&quot;fileSwitcherNoGroups&quot;), _nppGUI._fileSwitcherDisableListViewGroups);
5985  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;backSlashIsEscapeCharacterForSql&quot;), _nppGUI._backSlashIsEscapeCharacterForSql ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5986  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;writeTechnologyEngine&quot;), _nppGUI._writeTechnologyEngine);
5987  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isFolderDroppedOpenFiles&quot;), _nppGUI._isFolderDroppedOpenFiles ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5988  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;docPeekOnTab&quot;), _nppGUI._isDocPeekOnTab ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5989  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;docPeekOnMap&quot;), _nppGUI._isDocPeekOnMap ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5990  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;sortFunctionList&quot;), _nppGUI._shouldSortFunctionList ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5991  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;saveDlgExtFilterToAllTypes&quot;), _nppGUI._setSaveDlgExtFiltToAllTypes ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5992  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;muteSounds&quot;), _nppGUI._muteSounds ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5993  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;enableFoldCmdToggable&quot;), _nppGUI._enableFoldCmdToggable ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5994  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;hideMenuRightShortcuts&quot;), _nppGUI._hideMenuRightShortcuts ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5995  	}
5996  	{
5997  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5998  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Searching&quot;));
5999  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;monospacedFontFindDlg&quot;), _nppGUI._monospacedFontFindDlg ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6000  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fillFindFieldWithSelected&quot;), _nppGUI._fillFindFieldWithSelected ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6001  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fillFindFieldSelectCaret&quot;), _nppGUI._fillFindFieldSelectCaret ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6002  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;findDlgAlwaysVisible&quot;), _nppGUI._findDlgAlwaysVisible ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6003  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;confirmReplaceInAllOpenDocs&quot;), _nppGUI._confirmReplaceInAllOpenDocs ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6004  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;replaceStopsWithoutFindingNext&quot;), _nppGUI._replaceStopsWithoutFindingNext ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6005  	}
6006  	{
6007  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6008  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;searchEngine&quot;));
6009  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;searchEngineChoice&quot;), _nppGUI._searchEngineChoice);
6010  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;searchEngineCustom&quot;), _nppGUI._searchEngineCustom);
6011  	}
6012  	{
6013  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6014  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;MarkAll&quot;));
6015  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;matchCase&quot;), _nppGUI._markAllCaseSensitive ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6016  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;wholeWordOnly&quot;), _nppGUI._markAllWordOnly ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6017  	}
6018  	{
6019  		TiXmlElement *GUIConfigElement = insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;SmartHighLight&quot;), _nppGUI._enableSmartHilite);
6020  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;matchCase&quot;), _nppGUI._smartHiliteCaseSensitive ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6021  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;wholeWordOnly&quot;), _nppGUI._smartHiliteWordOnly ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6022  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;useFindSettings&quot;), _nppGUI._smartHiliteUseFindSettings ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6023  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;onAnotherView&quot;), _nppGUI._smartHiliteOnAnotherView ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6024  	}
6025  	if (_nppGUI._commandLineInterpreter.compare(CMD_INTERPRETER))
6026  	{
6027  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6028  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;commandLineInterpreter&quot;));
6029  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._commandLineInterpreter.c_str()));
6030  	}
6031  	{
6032  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6033  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;DarkMode&quot;));
6034  		NppDarkMode::setAdvancedOptions();
6035  		auto setYesNoBoolAttribute = [&amp;GUIConfigElement](const TCHAR* name, bool value) {
6036  			const TCHAR* pStr = value ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
6037  			GUIConfigElement-&gt;SetAttribute(name, pStr);
6038  		};
6039  		setYesNoBoolAttribute(TEXT(&quot;enable&quot;), _nppGUI._darkmode._isEnabled);
6040  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;colorTone&quot;), _nppGUI._darkmode._colorTone);
6041  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorTop&quot;), _nppGUI._darkmode._customColors.pureBackground);
6042  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorMenuHotTrack&quot;), _nppGUI._darkmode._customColors.hotBackground);
6043  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorActive&quot;), _nppGUI._darkmode._customColors.softerBackground);
6044  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorMain&quot;), _nppGUI._darkmode._customColors.background);
6045  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorError&quot;), _nppGUI._darkmode._customColors.errorBackground);
6046  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorText&quot;), _nppGUI._darkmode._customColors.text);
6047  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorDarkText&quot;), _nppGUI._darkmode._customColors.darkerText);
6048  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorDisabledText&quot;), _nppGUI._darkmode._customColors.disabledText);
6049  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorLinkText&quot;), _nppGUI._darkmode._customColors.linkText);
6050  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorEdge&quot;), _nppGUI._darkmode._customColors.edge);
6051  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorHotEdge&quot;), _nppGUI._darkmode._customColors.hotEdge);
6052  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorDisabledEdge&quot;), _nppGUI._darkmode._customColors.disabledEdge);
6053  		setYesNoBoolAttribute(TEXT(&quot;enableWindowsMode&quot;), _nppGUI._darkmode._advOptions._enableWindowsMode);
6054  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;darkThemeName&quot;), _nppGUI._darkmode._advOptions._darkDefaults._xmlFileName.c_str());
6055  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;darkToolBarIconSet&quot;), _nppGUI._darkmode._advOptions._darkDefaults._toolBarIconSet);
6056  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;darkTabIconSet&quot;), _nppGUI._darkmode._advOptions._darkDefaults._tabIconSet);
6057  		setYesNoBoolAttribute(TEXT(&quot;darkTabUseTheme&quot;), _nppGUI._darkmode._advOptions._darkDefaults._tabUseTheme);
6058  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;lightThemeName&quot;), _nppGUI._darkmode._advOptions._lightDefaults._xmlFileName.c_str());
6059  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;lightToolBarIconSet&quot;), _nppGUI._darkmode._advOptions._lightDefaults._toolBarIconSet);
6060  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;lightTabIconSet&quot;), _nppGUI._darkmode._advOptions._lightDefaults._tabIconSet);
6061  		setYesNoBoolAttribute(TEXT(&quot;lightTabUseTheme&quot;), _nppGUI._darkmode._advOptions._lightDefaults._tabUseTheme);
6062  	}
6063  	writeScintillaParams();
6064  	if (_nppGUI._isCmdlineNosessionActivated &amp;&amp; dockMngNodeDup)
6065  	{
6066  		newGUIRoot-&gt;InsertEndChild(*dockMngNodeDup);
6067  		delete dockMngNodeDup;
6068  	}
6069  	else
6070  	{
6071  		insertDockingParamNode(newGUIRoot);
6072  	}
6073  }
6074  bool NppParameters::writeFindHistory()
6075  {
6076  	if (!_pXmlUserDoc) return false;
6077  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
6078  	if (!nppRoot)
6079  	{
6080  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
6081  	}
6082  	TiXmlNode *findHistoryRoot = nppRoot-&gt;FirstChildElement(TEXT(&quot;FindHistory&quot;));
6083  	if (!findHistoryRoot)
6084  	{
6085  		TiXmlElement element(TEXT(&quot;FindHistory&quot;));
6086  		findHistoryRoot = nppRoot-&gt;InsertEndChild(element);
6087  	}
6088  	findHistoryRoot-&gt;Clear();
6089  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFindHistoryPath&quot;),	_findHistory._nbMaxFindHistoryPath);
6090  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFindHistoryFilter&quot;),  _findHistory._nbMaxFindHistoryFilter);
6091  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFindHistoryFind&quot;),	_findHistory._nbMaxFindHistoryFind);
6092  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFindHistoryReplace&quot;), _findHistory._nbMaxFindHistoryReplace);
6093  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;matchWord&quot;),				_findHistory._isMatchWord?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6094  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;matchCase&quot;),				_findHistory._isMatchCase?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6095  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;wrap&quot;),					_findHistory._isWrap?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6096  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;directionDown&quot;),			_findHistory._isDirectionDown?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6097  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifRecuisive&quot;),			_findHistory._isFifRecuisive?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6098  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifInHiddenFolder&quot;),		_findHistory._isFifInHiddenFolder?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6099  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifProjectPanel1&quot;),	    	_findHistory._isFifProjectPanel_1?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6100  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifProjectPanel2&quot;),	      	_findHistory._isFifProjectPanel_2?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6101  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifProjectPanel3&quot;),	       	_findHistory._isFifProjectPanel_3?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6102  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifFilterFollowsDoc&quot;),	_findHistory._isFilterFollowDoc?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6103  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifFolderFollowsDoc&quot;),	_findHistory._isFolderFollowDoc?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6104  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;searchMode&quot;), _findHistory._searchMode);
6105  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;transparencyMode&quot;), _findHistory._transparencyMode);
6106  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;transparency&quot;), _findHistory._transparency);
6107  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;dotMatchesNewline&quot;),		_findHistory._dotMatchesNewline?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6108  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;isSearch2ButtonsMode&quot;),		_findHistory._isSearch2ButtonsMode?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6109  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;regexBackward4PowerUser&quot;),		_findHistory._regexBackward4PowerUser ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6110  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;bookmarkLine&quot;), _findHistory._isBookmarkLine ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6111  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;purge&quot;), _findHistory._isPurge ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6112  	TiXmlElement hist_element{TEXT(&quot;&quot;)};
6113  	hist_element.SetValue(TEXT(&quot;Path&quot;));
6114  	for (size_t i = 0, len = _findHistory._findHistoryPaths.size(); i &lt; len; ++i)
6115  	{
6116  		(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), _findHistory._findHistoryPaths[i].c_str());
6117  		findHistoryRoot-&gt;InsertEndChild(hist_element);
6118  	}
6119  	hist_element.SetValue(TEXT(&quot;Filter&quot;));
6120  	for (size_t i = 0, len = _findHistory._findHistoryFilters.size(); i &lt; len; ++i)
6121  	{
6122  		(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), _findHistory._findHistoryFilters[i].c_str());
6123  		findHistoryRoot-&gt;InsertEndChild(hist_element);
6124  	}
6125  	hist_element.SetValue(TEXT(&quot;Find&quot;));
6126  	for (size_t i = 0, len = _findHistory._findHistoryFinds.size(); i &lt; len; ++i)
6127  	{
6128  		(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), _findHistory._findHistoryFinds[i].c_str());
6129  		findHistoryRoot-&gt;InsertEndChild(hist_element);
6130  	}
6131  	hist_element.SetValue(TEXT(&quot;Replace&quot;));
6132  	for (size_t i = 0, len = _findHistory._findHistoryReplaces.size(); i &lt; len; ++i)
6133  	{
6134  		(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), _findHistory._findHistoryReplaces[i].c_str());
6135  		findHistoryRoot-&gt;InsertEndChild(hist_element);
6136  	}
6137  	return true;
6138  }
6139  void NppParameters::insertDockingParamNode(TiXmlNode *GUIRoot)
6140  {
6141  	TiXmlElement DMNode(TEXT(&quot;GUIConfig&quot;));
6142  	DMNode.SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;DockingManager&quot;));
6143  	DMNode.SetAttribute(TEXT(&quot;leftWidth&quot;), _nppGUI._dockingData._leftWidth);
6144  	DMNode.SetAttribute(TEXT(&quot;rightWidth&quot;), _nppGUI._dockingData._rightWidth);
6145  	DMNode.SetAttribute(TEXT(&quot;topHeight&quot;), _nppGUI._dockingData._topHeight);
6146  	DMNode.SetAttribute(TEXT(&quot;bottomHeight&quot;), _nppGUI._dockingData._bottomHight);
6147  	for (size_t i = 0, len = _nppGUI._dockingData._flaotingWindowInfo.size(); i &lt; len ; ++i)
6148  	{
6149  		FloatingWindowInfo &amp; fwi = _nppGUI._dockingData._flaotingWindowInfo[i];
6150  		TiXmlElement FWNode(TEXT(&quot;FloatingWindow&quot;));
6151  		FWNode.SetAttribute(TEXT(&quot;cont&quot;), fwi._cont);
6152  		FWNode.SetAttribute(TEXT(&quot;x&quot;), fwi._pos.left);
6153  		FWNode.SetAttribute(TEXT(&quot;y&quot;), fwi._pos.top);
6154  		FWNode.SetAttribute(TEXT(&quot;width&quot;), fwi._pos.right);
6155  		FWNode.SetAttribute(TEXT(&quot;height&quot;), fwi._pos.bottom);
6156  		DMNode.InsertEndChild(FWNode);
6157  	}
6158  	for (size_t i = 0, len = _nppGUI._dockingData._pluginDockInfo.size() ; i &lt; len ; ++i)
6159  	{
6160  		PluginDlgDockingInfo &amp; pdi = _nppGUI._dockingData._pluginDockInfo[i];
6161  		TiXmlElement PDNode(TEXT(&quot;PluginDlg&quot;));
6162  		PDNode.SetAttribute(TEXT(&quot;pluginName&quot;), pdi._name);
6163  		PDNode.SetAttribute(TEXT(&quot;id&quot;), pdi._internalID);
6164  		PDNode.SetAttribute(TEXT(&quot;curr&quot;), pdi._currContainer);
6165  		PDNode.SetAttribute(TEXT(&quot;prev&quot;), pdi._prevContainer);
6166  		PDNode.SetAttribute(TEXT(&quot;isVisible&quot;), pdi._isVisible?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6167  		DMNode.InsertEndChild(PDNode);
6168  	}
6169  	for (size_t i = 0, len = _nppGUI._dockingData._containerTabInfo.size(); i &lt; len ; ++i)
6170  	{
6171  		ContainerTabInfo &amp; cti = _nppGUI._dockingData._containerTabInfo[i];
6172  		TiXmlElement CTNode(TEXT(&quot;ActiveTabs&quot;));
6173  		CTNode.SetAttribute(TEXT(&quot;cont&quot;), cti._cont);
6174  		CTNode.SetAttribute(TEXT(&quot;activeTab&quot;), cti._activeTab);
6175  		DMNode.InsertEndChild(CTNode);
6176  	}
6177  	GUIRoot-&gt;InsertEndChild(DMNode);
6178  }
6179  void NppParameters::writePrintSetting(TiXmlElement *element)
6180  {
6181  	const TCHAR *pStr = _nppGUI._printSettings._printLineNumber?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;);
6182  	element-&gt;SetAttribute(TEXT(&quot;lineNumber&quot;), pStr);
6183  	element-&gt;SetAttribute(TEXT(&quot;printOption&quot;), _nppGUI._printSettings._printOption);
6184  	element-&gt;SetAttribute(TEXT(&quot;headerLeft&quot;), _nppGUI._printSettings._headerLeft.c_str());
6185  	element-&gt;SetAttribute(TEXT(&quot;headerMiddle&quot;), _nppGUI._printSettings._headerMiddle.c_str());
6186  	element-&gt;SetAttribute(TEXT(&quot;headerRight&quot;), _nppGUI._printSettings._headerRight.c_str());
6187  	element-&gt;SetAttribute(TEXT(&quot;footerLeft&quot;), _nppGUI._printSettings._footerLeft.c_str());
6188  	element-&gt;SetAttribute(TEXT(&quot;footerMiddle&quot;), _nppGUI._printSettings._footerMiddle.c_str());
6189  	element-&gt;SetAttribute(TEXT(&quot;footerRight&quot;), _nppGUI._printSettings._footerRight.c_str());
6190  	element-&gt;SetAttribute(TEXT(&quot;headerFontName&quot;), _nppGUI._printSettings._headerFontName.c_str());
6191  	element-&gt;SetAttribute(TEXT(&quot;headerFontStyle&quot;), _nppGUI._printSettings._headerFontStyle);
6192  	element-&gt;SetAttribute(TEXT(&quot;headerFontSize&quot;), _nppGUI._printSettings._headerFontSize);
6193  	element-&gt;SetAttribute(TEXT(&quot;footerFontName&quot;), _nppGUI._printSettings._footerFontName.c_str());
6194  	element-&gt;SetAttribute(TEXT(&quot;footerFontStyle&quot;), _nppGUI._printSettings._footerFontStyle);
6195  	element-&gt;SetAttribute(TEXT(&quot;footerFontSize&quot;), _nppGUI._printSettings._footerFontSize);
6196  	element-&gt;SetAttribute(TEXT(&quot;margeLeft&quot;), _nppGUI._printSettings._marge.left);
6197  	element-&gt;SetAttribute(TEXT(&quot;margeRight&quot;), _nppGUI._printSettings._marge.right);
6198  	element-&gt;SetAttribute(TEXT(&quot;margeTop&quot;), _nppGUI._printSettings._marge.top);
6199  	element-&gt;SetAttribute(TEXT(&quot;margeBottom&quot;), _nppGUI._printSettings._marge.bottom);
6200  }
6201  void NppParameters::writeExcludedLangList(TiXmlElement *element)
6202  {
6203  	int g0 = 0; 
6204  	int g1 = 0; 
6205  	int g2 = 0; 
6206  	int g3 = 0; 
6207  	int g4 = 0; 
6208  	int g5 = 0; 
6209  	int g6 = 0; 
6210  	int g7 = 0; 
6211  	int g8 = 0; 
6212  	int g9 = 0; 
6213  	int g10= 0; 
6214  	int g11= 0; 
6215  	int g12= 0; 
6216  	const int groupNbMember = 8;
6217  	for (size_t i = 0, len = _nppGUI._excludedLangList.size(); i &lt; len ; ++i)
6218  	{
6219  		LangType langType = _nppGUI._excludedLangList[i]._langType;
6220  		if (langType &gt;= L_EXTERNAL &amp;&amp; langType &lt; L_END)
6221  			continue;
6222  		int nGrp = langType / groupNbMember;
6223  		int nMask = 1 &lt;&lt; langType % groupNbMember;
6224  		switch (nGrp)
6225  		{
6226  			case 0 :
6227  				g0 |= nMask;
6228  				break;
6229  			case 1 :
6230  				g1 |= nMask;
6231  				break;
6232  			case 2 :
6233  				g2 |= nMask;
6234  				break;
6235  			case 3 :
6236  				g3 |= nMask;
6237  				break;
6238  			case 4 :
6239  				g4 |= nMask;
6240  				break;
6241  			case 5 :
6242  				g5 |= nMask;
6243  				break;
6244  			case 6 :
6245  				g6 |= nMask;
6246  				break;
6247  			case 7 :
6248  				g7 |= nMask;
6249  				break;
6250  			case 8:
6251  				g8 |= nMask;
6252  				break;
6253  			case 9:
6254  				g9 |= nMask;
6255  				break;
6256  			case 10:
6257  				g10 |= nMask;
6258  				break;
6259  			case 11:
6260  				g11 |= nMask;
6261  				break;
6262  			case 12:
6263  				g12 |= nMask;
6264  				break;
6265  		}
6266  	}
6267  	element-&gt;SetAttribute(TEXT(&quot;gr0&quot;), g0);
6268  	element-&gt;SetAttribute(TEXT(&quot;gr1&quot;), g1);
6269  	element-&gt;SetAttribute(TEXT(&quot;gr2&quot;), g2);
6270  	element-&gt;SetAttribute(TEXT(&quot;gr3&quot;), g3);
6271  	element-&gt;SetAttribute(TEXT(&quot;gr4&quot;), g4);
6272  	element-&gt;SetAttribute(TEXT(&quot;gr5&quot;), g5);
6273  	element-&gt;SetAttribute(TEXT(&quot;gr6&quot;), g6);
6274  	element-&gt;SetAttribute(TEXT(&quot;gr7&quot;), g7);
6275  	element-&gt;SetAttribute(TEXT(&quot;gr8&quot;), g8);
6276  	element-&gt;SetAttribute(TEXT(&quot;gr9&quot;), g9);
6277  	element-&gt;SetAttribute(TEXT(&quot;gr10&quot;), g10);
6278  	element-&gt;SetAttribute(TEXT(&quot;gr11&quot;), g11);
6279  	element-&gt;SetAttribute(TEXT(&quot;gr12&quot;), g12);
6280  }
6281  TiXmlElement * NppParameters::insertGUIConfigBoolNode(TiXmlNode *r2w, const TCHAR *name, bool bVal)
6282  {
6283  	const TCHAR *pStr = bVal?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;);
6284  	TiXmlElement *GUIConfigElement = (r2w-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6285  	GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), name);
6286  	GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
6287  	return GUIConfigElement;
6288  }
6289  int RGB2int(COLORREF color)
6290  {
6291  	return (((((DWORD)color) &amp; 0x0000FF) &lt;&lt; 16) | ((((DWORD)color) &amp; 0x00FF00)) | ((((DWORD)color) &amp; 0xFF0000) &gt;&gt; 16));
6292  }
6293  int NppParameters::langTypeToCommandID(LangType lt) const
6294  {
6295  	int id;
6296  	switch (lt)
6297  	{
6298  		case L_C :
6299  			id = IDM_LANG_C; break;
6300  		case L_CPP :
6301  			id = IDM_LANG_CPP; break;
6302  		case L_JAVA :
6303  			id = IDM_LANG_JAVA;	break;
6304  		case L_CS :
6305  			id = IDM_LANG_CS; break;
6306  		case L_OBJC :
6307  			id = IDM_LANG_OBJC;	break;
6308  		case L_HTML :
6309  			id = IDM_LANG_HTML;	break;
6310  		case L_XML :
6311  			id = IDM_LANG_XML; break;
6312  		case L_JS :
6313  		case L_JAVASCRIPT:
6314  			id = IDM_LANG_JS; break;
6315  		case L_JSON:
6316  			id = IDM_LANG_JSON; break;
6317  		case L_JSON5:
6318  			id = IDM_LANG_JSON5; break;
6319  		case L_PHP :
6320  			id = IDM_LANG_PHP; break;
6321  		case L_ASP :
6322  			id = IDM_LANG_ASP; break;
6323  		case L_JSP :
6324  			id = IDM_LANG_JSP; break;
6325  		case L_CSS :
6326  			id = IDM_LANG_CSS; break;
6327  		case L_LUA :
6328  			id = IDM_LANG_LUA; break;
6329  		case L_PERL :
6330  			id = IDM_LANG_PERL; break;
6331  		case L_PYTHON :
6332  			id = IDM_LANG_PYTHON; break;
6333  		case L_BATCH :
6334  			id = IDM_LANG_BATCH; break;
6335  		case L_PASCAL :
6336  			id = IDM_LANG_PASCAL; break;
6337  		case L_MAKEFILE :
6338  			id = IDM_LANG_MAKEFILE;	break;
6339  		case L_INI :
6340  			id = IDM_LANG_INI; break;
6341  		case L_ASCII :
6342  			id = IDM_LANG_ASCII; break;
6343  		case L_RC :
6344  			id = IDM_LANG_RC; break;
6345  		case L_TEX :
6346  			id = IDM_LANG_TEX; break;
6347  		case L_FORTRAN :
6348  			id = IDM_LANG_FORTRAN; break;
6349  		case L_FORTRAN_77 :
6350  			id = IDM_LANG_FORTRAN_77; break;
6351  		case L_BASH :
6352  			id = IDM_LANG_BASH; break;
6353  		case L_FLASH :
6354  			id = IDM_LANG_FLASH; break;
6355  		case L_NSIS :
6356  			id = IDM_LANG_NSIS; break;
6357  		case L_USER :
6358  			id = IDM_LANG_USER; break;
6359  		case L_SQL :
6360  			id = IDM_LANG_SQL; break;
6361  		case L_MSSQL :
6362  			id = IDM_LANG_MSSQL; break;
6363  		case L_VB :
6364  			id = IDM_LANG_VB; break;
6365  		case L_TCL :
6366  			id = IDM_LANG_TCL; break;
6367  		case L_LISP :
6368  			id = IDM_LANG_LISP; break;
6369  		case L_SCHEME :
6370  			id = IDM_LANG_SCHEME; break;
6371  		case L_ASM :
6372  			id = IDM_LANG_ASM; break;
6373  		case L_DIFF :
6374  			id = IDM_LANG_DIFF; break;
6375  		case L_PROPS :
6376  			id = IDM_LANG_PROPS; break;
6377  		case L_PS :
6378  			id = IDM_LANG_PS; break;
6379  		case L_RUBY :
6380  			id = IDM_LANG_RUBY; break;
6381  		case L_SMALLTALK :
6382  			id = IDM_LANG_SMALLTALK; break;
6383  		case L_VHDL :
6384  			id = IDM_LANG_VHDL; break;
6385  		case L_ADA :
6386  			id = IDM_LANG_ADA; break;
6387  		case L_MATLAB :
6388  			id = IDM_LANG_MATLAB; break;
6389  		case L_HASKELL :
6390  			id = IDM_LANG_HASKELL; break;
6391  		case L_KIX :
6392  			id = IDM_LANG_KIX; break;
6393  		case L_AU3 :
6394  			id = IDM_LANG_AU3; break;
6395  		case L_VERILOG :
6396  			id = IDM_LANG_VERILOG; break;
6397  		case L_CAML :
6398  			id = IDM_LANG_CAML; break;
6399  		case L_INNO :
6400  			id = IDM_LANG_INNO; break;
6401  		case L_CMAKE :
6402  			id = IDM_LANG_CMAKE; break;
6403  		case L_YAML :
6404  			id = IDM_LANG_YAML; break;
6405  		case L_COBOL :
6406  			id = IDM_LANG_COBOL; break;
6407  		case L_D :
6408  			id = IDM_LANG_D; break;
6409  		case L_GUI4CLI :
6410  			id = IDM_LANG_GUI4CLI; break;
6411  		case L_POWERSHELL :
6412  			id = IDM_LANG_POWERSHELL; break;
6413  		case L_R :
6414  			id = IDM_LANG_R; break;
6415  		case L_COFFEESCRIPT :
6416  			id = IDM_LANG_COFFEESCRIPT; break;
6417  		case L_BAANC:
6418  			id = IDM_LANG_BAANC; break;
6419  		case L_SREC :
6420  			id = IDM_LANG_SREC; break;
6421  		case L_IHEX :
6422  			id = IDM_LANG_IHEX; break;
6423  		case L_TEHEX :
6424  			id = IDM_LANG_TEHEX; break;
6425  		case L_SWIFT:
6426  			id = IDM_LANG_SWIFT; break;
6427  		case L_ASN1 :
6428  			id = IDM_LANG_ASN1; break;
6429          case L_AVS :
6430  			id = IDM_LANG_AVS; break;
6431  		case L_BLITZBASIC :
6432  			id = IDM_LANG_BLITZBASIC; break;
6433  		case L_PUREBASIC :
6434  			id = IDM_LANG_PUREBASIC; break;
6435  		case L_FREEBASIC :
6436  			id = IDM_LANG_FREEBASIC; break;
6437  		case L_CSOUND :
6438  			id = IDM_LANG_CSOUND; break;
6439  		case L_ERLANG :
6440  			id = IDM_LANG_ERLANG; break;
6441  		case L_ESCRIPT :
6442  			id = IDM_LANG_ESCRIPT; break;
6443  		case L_FORTH :
6444  			id = IDM_LANG_FORTH; break;
6445  		case L_LATEX :
6446  			id = IDM_LANG_LATEX; break;
6447  		case L_MMIXAL :
6448  			id = IDM_LANG_MMIXAL; break;
6449  		case L_NIM :
6450  			id = IDM_LANG_NIM; break;
6451  		case L_NNCRONTAB :
6452  			id = IDM_LANG_NNCRONTAB; break;
6453  		case L_OSCRIPT :
6454  			id = IDM_LANG_OSCRIPT; break;
6455  		case L_REBOL :
6456  			id = IDM_LANG_REBOL; break;
6457  		case L_REGISTRY :
6458  			id = IDM_LANG_REGISTRY; break;
6459  		case L_RUST :
6460  			id = IDM_LANG_RUST; break;
6461  		case L_SPICE :
6462  			id = IDM_LANG_SPICE; break;
6463  		case L_TXT2TAGS :
6464  			id = IDM_LANG_TXT2TAGS; break;
6465  		case L_VISUALPROLOG:
6466  			id = IDM_LANG_VISUALPROLOG; break;
6467  		case L_TYPESCRIPT:
6468  			id = IDM_LANG_TYPESCRIPT; break;
6469  		case L_GDSCRIPT:
6470  			id = IDM_LANG_GDSCRIPT; break;
6471  		case L_HOLLYWOOD:
6472  			id = IDM_LANG_HOLLYWOOD; break;
6473  		case L_SEARCHRESULT :
6474  			id = -1;	break;
6475  		case L_TEXT :
6476  			id = IDM_LANG_TEXT;	break;
6477  		default :
6478  			if (lt &gt;= L_EXTERNAL &amp;&amp; lt &lt; L_END)
6479  				id = lt - L_EXTERNAL + IDM_LANG_EXTERNAL;
6480  			else
6481  				id = IDM_LANG_TEXT;
6482  	}
6483  	return id;
6484  }
6485  generic_string NppParameters:: getWinVersionStr() const
6486  {
6487  	switch (_winVersion)
6488  	{
6489  		case WV_WIN32S: return TEXT(&quot;Windows 3.1&quot;);
6490  		case WV_95: return TEXT(&quot;Windows 95&quot;);
6491  		case WV_98: return TEXT(&quot;Windows 98&quot;);
6492  		case WV_ME: return TEXT(&quot;Windows Millennium Edition&quot;);
6493  		case WV_NT: return TEXT(&quot;Windows NT&quot;);
6494  		case WV_W2K: return TEXT(&quot;Windows 2000&quot;);
6495  		case WV_XP: return TEXT(&quot;Windows XP&quot;);
6496  		case WV_S2003: return TEXT(&quot;Windows Server 2003&quot;);
6497  		case WV_XPX64: return TEXT(&quot;Windows XP 64 bits&quot;);
6498  		case WV_VISTA: return TEXT(&quot;Windows Vista&quot;);
6499  		case WV_WIN7: return TEXT(&quot;Windows 7&quot;);
6500  		case WV_WIN8: return TEXT(&quot;Windows 8&quot;);
6501  		case WV_WIN81: return TEXT(&quot;Windows 8.1&quot;);
6502  		case WV_WIN10: return TEXT(&quot;Windows 10&quot;);
6503  		case WV_WIN11: return TEXT(&quot;Windows 11&quot;);
6504  		default: &amp;bsol;*case WV_UNKNOWN:*/ return TEXT(&quot;Windows unknown version&quot;);
6505  	}
6506  }
6507  generic_string NppParameters::getWinVerBitStr() const
6508  {
6509  	switch (_platForm)
6510  	{
6511  	case PF_X86:
6512  		return TEXT(&quot;32-bit&quot;);
6513  	case PF_X64:
6514  	case PF_IA64:
6515  	case PF_ARM64:
6516  		return TEXT(&quot;64-bit&quot;);
6517  	default:
6518  		return TEXT(&quot;Unknown-bit&quot;);
6519  	}
6520  }
6521  generic_string NppParameters::writeStyles(LexerStylerArray &amp; lexersStylers, StyleArray &amp; globalStylers)
6522  {
6523  	TiXmlNode *lexersRoot = (_pXmlUserStylerDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;)))-&gt;FirstChildElement(TEXT(&quot;LexerStyles&quot;));
6524  	for (TiXmlNode *childNode = lexersRoot-&gt;FirstChildElement(TEXT(&quot;LexerType&quot;));
6525  		childNode ;
6526  		childNode = childNode-&gt;NextSibling(TEXT(&quot;LexerType&quot;)))
6527  	{
6528  		TiXmlElement *element = childNode-&gt;ToElement();
6529  		const TCHAR *nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
6530  		LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6531  		LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6532  		if (pLs)
6533  		{
6534  			const TCHAR *extStr = pLs-&gt;getLexerUserExt();
6535  			element-&gt;SetAttribute(TEXT(&quot;ext&quot;), extStr);
6536  			for (TiXmlNode *grChildNode = childNode-&gt;FirstChildElement(TEXT(&quot;WordsStyle&quot;));
6537  					grChildNode ;
6538  					grChildNode = grChildNode-&gt;NextSibling(TEXT(&quot;WordsStyle&quot;)))
6539  			{
6540  				TiXmlElement *grElement = grChildNode-&gt;ToElement();
6541  				const TCHAR *styleName = grElement-&gt;Attribute(TEXT(&quot;name&quot;));
6542  				const Style * pStyle = pLs-&gt;findByName(styleName);
6543  				Style * pStyle2Sync = pLs2 ? pLs2-&gt;findByName(styleName) : nullptr;
6544  				if (pStyle &amp;&amp; pStyle2Sync)
6545  				{
6546  					writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6547  				}
6548  			}
6549  		}
6550  	}
6551  	for (size_t x = 0; x &lt; _pXmlExternalLexerDoc.size(); ++x)
6552  	{
6553  		TiXmlNode* lexersRoot2 = ( _pXmlExternalLexerDoc[x]-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;)))-&gt;FirstChildElement(TEXT(&quot;LexerStyles&quot;));
6554  		for (TiXmlNode* childNode = lexersRoot2-&gt;FirstChildElement(TEXT(&quot;LexerType&quot;));
6555  			childNode ;
6556  			childNode = childNode-&gt;NextSibling(TEXT(&quot;LexerType&quot;)))
6557  		{
6558  			TiXmlElement *element = childNode-&gt;ToElement();
6559  			const TCHAR *nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
6560  			LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6561  			LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6562  			if (pLs)
6563  			{
6564  				const TCHAR *extStr = pLs-&gt;getLexerUserExt();
6565  				element-&gt;SetAttribute(TEXT(&quot;ext&quot;), extStr);
6566  				for (TiXmlNode *grChildNode = childNode-&gt;FirstChildElement(TEXT(&quot;WordsStyle&quot;));
6567  						grChildNode ;
6568  						grChildNode = grChildNode-&gt;NextSibling(TEXT(&quot;WordsStyle&quot;)))
6569  				{
6570  					TiXmlElement *grElement = grChildNode-&gt;ToElement();
6571  					const TCHAR *styleName = grElement-&gt;Attribute(TEXT(&quot;name&quot;));
6572  					const Style * pStyle = pLs-&gt;findByName(styleName);
6573  					Style * pStyle2Sync = pLs2 ? pLs2-&gt;findByName(styleName) : nullptr;
6574  					if (pStyle &amp;&amp; pStyle2Sync)
6575  					{
6576  						writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6577  					}
6578  				}
6579  			}
6580  		}
6581  		_pXmlExternalLexerDoc[x]-&gt;SaveFile();
6582  	}
6583  	TiXmlNode *globalStylesRoot = (_pXmlUserStylerDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;)))-&gt;FirstChildElement(TEXT(&quot;GlobalStyles&quot;));
6584  	for (TiXmlNode *childNode = globalStylesRoot-&gt;FirstChildElement(TEXT(&quot;WidgetStyle&quot;));
6585  		childNode ;
6586  		childNode = childNode-&gt;NextSibling(TEXT(&quot;WidgetStyle&quot;)))
6587  	{
6588  		TiXmlElement *pElement = childNode-&gt;ToElement();
6589  		const TCHAR *styleName = pElement-&gt;Attribute(TEXT(&quot;name&quot;));
6590  		const Style * pStyle = _widgetStyleArray.findByName(styleName);
6591  		Style * pStyle2Sync = globalStylers.findByName(styleName);
6592  		if (pStyle &amp;&amp; pStyle2Sync)
6593  		{
6594  			writeStyle2Element(*pStyle, *pStyle2Sync, pElement);
6595  		}
6596  	}
6597  	bool isSaved = _pXmlUserStylerDoc-&gt;SaveFile();
6598  	if (!isSaved)
6599  	{
6600  		auto savePath = _themeSwitcher.getSavePathFrom(_pXmlUserStylerDoc-&gt;Value());
6601  		if (!savePath.empty())
6602  		{
6603  			_pXmlUserStylerDoc-&gt;SaveFile(savePath.c_str());
6604  			return savePath;
6605  		}
6606  	}
6607  	return TEXT(&quot;&quot;);
6608  }
6609  bool NppParameters::insertTabInfo(const TCHAR *langName, int tabInfo)
6610  {
6611  	if (!_pXmlDoc) return false;
6612  	TiXmlNode *langRoot = (_pXmlDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;)))-&gt;FirstChildElement(TEXT(&quot;Languages&quot;));
6613  	for (TiXmlNode *childNode = langRoot-&gt;FirstChildElement(TEXT(&quot;Language&quot;));
6614  		childNode ;
6615  		childNode = childNode-&gt;NextSibling(TEXT(&quot;Language&quot;)))
6616  	{
6617  		TiXmlElement *element = childNode-&gt;ToElement();
6618  		const TCHAR *nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
6619  		if (nm &amp;&amp; lstrcmp(langName, nm) == 0)
6620  		{
6621  			childNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;tabSettings&quot;), tabInfo);
6622  			_pXmlDoc-&gt;SaveFile();
6623  			return true;
6624  		}
6625  	}
6626  	return false;
6627  }
6628  void NppParameters::writeStyle2Element(const Style &amp; style2Write, Style &amp; style2Sync, TiXmlElement *element)
6629  {
6630  	if (HIBYTE(HIWORD(style2Write._fgColor)) != 0xFF)
6631  	{
6632  		int rgbVal = RGB2int(style2Write._fgColor);
6633  		TCHAR fgStr[7];
6634  		wsprintf(fgStr, TEXT(&quot;%.6X&quot;), rgbVal);
6635  		element-&gt;SetAttribute(TEXT(&quot;fgColor&quot;), fgStr);
6636  	}
6637  	if (HIBYTE(HIWORD(style2Write._bgColor)) != 0xFF)
6638  	{
6639  		int rgbVal = RGB2int(style2Write._bgColor);
6640  		TCHAR bgStr[7];
6641  		wsprintf(bgStr, TEXT(&quot;%.6X&quot;), rgbVal);
6642  		element-&gt;SetAttribute(TEXT(&quot;bgColor&quot;), bgStr);
6643  	}
6644  	if (style2Write._colorStyle != COLORSTYLE_ALL)
6645  	{
6646  		element-&gt;SetAttribute(TEXT(&quot;colorStyle&quot;), style2Write._colorStyle);
6647  	}
6648  	if (!style2Write._fontName.empty())
6649  	{
6650  		const TCHAR * oldFontName = element-&gt;Attribute(TEXT(&quot;fontName&quot;));
6651  		if (oldFontName &amp;&amp; oldFontName != style2Write._fontName)
6652  		{
6653  			element-&gt;SetAttribute(TEXT(&quot;fontName&quot;), style2Write._fontName);
6654  			style2Sync._fontName = style2Write._fontName;
6655  		}
6656  	}
6657  	if (style2Write._fontSize != STYLE_NOT_USED)
6658  	{
6659  		if (!style2Write._fontSize)
6660  			element-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), TEXT(&quot;&quot;));
6661  		else
6662  			element-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), style2Write._fontSize);
6663  	}
6664  	if (style2Write._fontStyle != STYLE_NOT_USED)
6665  	{
6666  		element-&gt;SetAttribute(TEXT(&quot;fontStyle&quot;), style2Write._fontStyle);
6667  	}
6668  	if (!style2Write._keywords.empty())
6669  	{
6670  		TiXmlNode *teteDeNoeud = element-&gt;LastChild();
6671  		if (teteDeNoeud)
6672  			teteDeNoeud-&gt;SetValue(style2Write._keywords.c_str());
6673  		else
6674  			element-&gt;InsertEndChild(TiXmlText(style2Write._keywords.c_str()));
6675  	}
6676  }
6677  void NppParameters::insertUserLang2Tree(TiXmlNode *node, UserLangContainer *userLang)
6678  {
6679  	TiXmlElement *rootElement = (node-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;UserLang&quot;))))-&gt;ToElement();
6680  	TCHAR temp[32];
6681  	generic_string udlVersion;
6682  	udlVersion += _itow(SCE_UDL_VERSION_MAJOR, temp, 10);
6683  	udlVersion += TEXT(&quot;.&quot;);
6684  	udlVersion += _itow(SCE_UDL_VERSION_MINOR, temp, 10);
6685  	rootElement-&gt;SetAttribute(TEXT(&quot;name&quot;), userLang-&gt;_name);
6686  	rootElement-&gt;SetAttribute(TEXT(&quot;ext&quot;), userLang-&gt;_ext);
6687  	if (userLang-&gt;_isDarkModeTheme)
6688  		rootElement-&gt;SetAttribute(TEXT(&quot;darkModeTheme&quot;), TEXT(&quot;yes&quot;));
6689  	rootElement-&gt;SetAttribute(TEXT(&quot;udlVersion&quot;), udlVersion.c_str());
6690  	TiXmlElement *settingsElement = (rootElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Settings&quot;))))-&gt;ToElement();
6691  	{
6692  		TiXmlElement *globalElement = (settingsElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Global&quot;))))-&gt;ToElement();
6693  		globalElement-&gt;SetAttribute(TEXT(&quot;caseIgnored&quot;),			userLang-&gt;_isCaseIgnored ? TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6694  		globalElement-&gt;SetAttribute(TEXT(&quot;allowFoldOfComments&quot;),	userLang-&gt;_allowFoldOfComments ? TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6695  		globalElement-&gt;SetAttribute(TEXT(&quot;foldCompact&quot;),			userLang-&gt;_foldCompact ? TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6696  		globalElement-&gt;SetAttribute(TEXT(&quot;forcePureLC&quot;),			userLang-&gt;_forcePureLC);
6697  		globalElement-&gt;SetAttribute(TEXT(&quot;decimalSeparator&quot;),	   userLang-&gt;_decimalSeparator);
6698  		TiXmlElement *prefixElement = (settingsElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Prefix&quot;))))-&gt;ToElement();
6699  		for (int i = 0 ; i &lt; SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
6700  			prefixElement-&gt;SetAttribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1], userLang-&gt;_isPrefix[i]?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6701  	}
6702  	TiXmlElement *kwlElement = (rootElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;KeywordLists&quot;))))-&gt;ToElement();
6703  	for (int i = 0 ; i &lt; SCE_USER_KWLIST_TOTAL ; ++i)
6704  	{
6705  		TiXmlElement *kwElement = (kwlElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Keywords&quot;))))-&gt;ToElement();
6706  		kwElement-&gt;SetAttribute(TEXT(&quot;name&quot;), globalMappper().keywordNameMapper[i]);
6707  		kwElement-&gt;InsertEndChild(TiXmlText(userLang-&gt;_keywordLists[i]));
6708  	}
6709  	TiXmlElement *styleRootElement = (rootElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Styles&quot;))))-&gt;ToElement();
6710  	for (const Style &amp; style2Write : userLang-&gt;_styles)
6711  	{
6712  		TiXmlElement *styleElement = (styleRootElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;WordsStyle&quot;))))-&gt;ToElement();
6713  		if (style2Write._styleID == -1)
6714  			continue;
6715  		styleElement-&gt;SetAttribute(TEXT(&quot;name&quot;), style2Write._styleDesc);
6716  		{
6717  			int rgbVal = RGB2int(style2Write._fgColor);
6718  			TCHAR fgStr[7];
6719  			wsprintf(fgStr, TEXT(&quot;%.6X&quot;), rgbVal);
6720  			styleElement-&gt;SetAttribute(TEXT(&quot;fgColor&quot;), fgStr);
6721  		}
6722  		{
6723  			int rgbVal = RGB2int(style2Write._bgColor);
6724  			TCHAR bgStr[7];
6725  			wsprintf(bgStr, TEXT(&quot;%.6X&quot;), rgbVal);
6726  			styleElement-&gt;SetAttribute(TEXT(&quot;bgColor&quot;), bgStr);
6727  		}
6728  		if (style2Write._colorStyle != COLORSTYLE_ALL)
6729  		{
6730  			styleElement-&gt;SetAttribute(TEXT(&quot;colorStyle&quot;), style2Write._colorStyle);
6731  		}
6732  		if (!style2Write._fontName.empty())
6733  		{
6734  			styleElement-&gt;SetAttribute(TEXT(&quot;fontName&quot;), style2Write._fontName);
6735  		}
6736  		if (style2Write._fontStyle == STYLE_NOT_USED)
6737  		{
6738  			styleElement-&gt;SetAttribute(TEXT(&quot;fontStyle&quot;), TEXT(&quot;0&quot;));
6739  		}
6740  		else
6741  		{
6742  			styleElement-&gt;SetAttribute(TEXT(&quot;fontStyle&quot;), style2Write._fontStyle);
6743  		}
6744  		if (style2Write._fontSize != STYLE_NOT_USED)
6745  		{
6746  			if (!style2Write._fontSize)
6747  				styleElement-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), TEXT(&quot;&quot;));
6748  			else
6749  				styleElement-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), style2Write._fontSize);
6750  		}
6751  		styleElement-&gt;SetAttribute(TEXT(&quot;nesting&quot;), style2Write._nesting);
6752  	}
6753  }
6754  void NppParameters::addUserModifiedIndex(size_t index)
6755  {
6756  	size_t len = _customizedShortcuts.size();
6757  	bool found = false;
6758  	for (size_t i = 0; i &lt; len; ++i)
6759  	{
6760  		if (_customizedShortcuts[i] == index)
6761  		{
6762  			found = true;
6763  			break;
6764  		}
6765  	}
6766  	if (!found)
6767  	{
6768  		_customizedShortcuts.push_back(index);
6769  	}
6770  }
6771  void NppParameters::addPluginModifiedIndex(size_t index)
6772  {
6773  	size_t len = _pluginCustomizedCmds.size();
6774  	bool found = false;
6775  	for (size_t i = 0; i &lt; len; ++i)
6776  	{
6777  		if (_pluginCustomizedCmds[i] == index)
6778  		{
6779  			found = true;
6780  			break;
6781  		}
6782  	}
6783  	if (!found)
6784  	{
6785  		_pluginCustomizedCmds.push_back(index);
6786  	}
6787  }
6788  void NppParameters::addScintillaModifiedIndex(int index)
6789  {
6790  	size_t len = _scintillaModifiedKeyIndices.size();
6791  	bool found = false;
6792  	for (size_t i = 0; i &lt; len; ++i)
6793  	{
6794  		if (_scintillaModifiedKeyIndices[i] == index)
6795  		{
6796  			found = true;
6797  			break;
6798  		}
6799  	}
6800  	if (!found)
6801  	{
6802  		_scintillaModifiedKeyIndices.push_back(index);
6803  	}
6804  }
6805  void NppParameters::safeWow64EnableWow64FsRedirection(BOOL Wow64FsEnableRedirection)
6806  {
6807  	HMODULE kernel = GetModuleHandle(TEXT(&quot;kernel32&quot;));
6808  	if (kernel)
6809  	{
6810  		BOOL isWow64 = FALSE;
6811  		typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
6812  		LPFN_ISWOW64PROCESS IsWow64ProcessFunc = (LPFN_ISWOW64PROCESS) GetProcAddress(kernel,&quot;IsWow64Process&quot;);
6813  		if (IsWow64ProcessFunc)
6814  		{
6815  			IsWow64ProcessFunc(GetCurrentProcess(),&amp;isWow64);
6816  			if (isWow64)
6817  			{
6818  				typedef BOOL (WINAPI *LPFN_WOW64ENABLEWOW64FSREDIRECTION)(BOOL);
6819  				LPFN_WOW64ENABLEWOW64FSREDIRECTION Wow64EnableWow64FsRedirectionFunc = (LPFN_WOW64ENABLEWOW64FSREDIRECTION)GetProcAddress(kernel, &quot;Wow64EnableWow64FsRedirection&quot;);
6820  				if (Wow64EnableWow64FsRedirectionFunc)
6821  				{
6822  					Wow64EnableWow64FsRedirectionFunc(Wow64FsEnableRedirection);
6823  				}
6824  			}
6825  		}
6826  	}
6827  }
6828  void NppParameters::setUdlXmlDirtyFromIndex(size_t i)
6829  {
6830  	for (auto&amp; uxfs : _pXmlUserLangsDoc)
6831  	{
6832  		if (i &gt;= uxfs._indexRange.first &amp;&amp; i &lt; uxfs._indexRange.second)
6833  		{
6834  			uxfs._isDirty = true;
6835  			return;
6836  		}
6837  	}
6838  }
6839  void NppParameters::removeIndexFromXmlUdls(size_t i)
6840  {
6841  	bool isUpdateBegin = false;
6842  	for (auto&amp; uxfs : _pXmlUserLangsDoc)
6843  	{
6844  		if (!isUpdateBegin &amp;&amp; (i &gt;= uxfs._indexRange.first &amp;&amp; i &lt; uxfs._indexRange.second)) 
6845  		{
6846  			if (uxfs._indexRange.second &gt; 0)
6847  				uxfs._indexRange.second -= 1;
6848  			uxfs._isDirty = true;
6849  			isUpdateBegin = true;
6850  		}
6851  		else if (isUpdateBegin)
6852  		{
6853  			if (uxfs._indexRange.first &gt; 0)
6854  				uxfs._indexRange.first -= 1;
6855  			if (uxfs._indexRange.second &gt; 0)
6856  				uxfs._indexRange.second -= 1;
6857  		}
6858  	}
6859  }
6860  void NppParameters::setUdlXmlDirtyFromXmlDoc(const TiXmlDocument* xmlDoc)
6861  {
6862  	for (auto&amp; uxfs : _pXmlUserLangsDoc)
6863  	{
6864  		if (xmlDoc == uxfs._udlXmlDoc)
6865  		{
6866  			uxfs._isDirty = true;
6867  			return;
6868  		}
6869  	}
6870  }
6871  Date::Date(const TCHAR *dateStr)
6872  {
6873  	assert(dateStr);
6874  	int D = lstrlen(dateStr);
6875  	if ( 8==D )
6876  	{
6877  		generic_string ds(dateStr);
6878  		generic_string yyyy(ds, 0, 4);
6879  		generic_string mm(ds, 4, 2);
6880  		generic_string dd(ds, 6, 2);
6881  		int y = _wtoi(yyyy.c_str());
6882  		int m = _wtoi(mm.c_str());
6883  		int d = _wtoi(dd.c_str());
6884  		if ((y &gt; 0 &amp;&amp; y &lt;= 9999) &amp;&amp; (m &gt; 0 &amp;&amp; m &lt;= 12) &amp;&amp; (d &gt; 0 &amp;&amp; d &lt;= 31))
6885  		{
6886  			_year = y;
6887  			_month = m;
6888  			_day = d;
6889  			return;
6890  		}
6891  	}
6892  	now();
6893  }
6894  Date::Date(int nbDaysFromNow)
6895  {
6896  	const time_t oneDay = (60 * 60 * 24);
6897  	time_t rawtime;
6898  	tm* timeinfo;
6899  	time(&amp;rawtime);
6900  	rawtime += (nbDaysFromNow * oneDay);
6901  	timeinfo = localtime(&amp;rawtime);
6902  	if (timeinfo)
6903  	{
6904  		_year = timeinfo-&gt;tm_year + 1900;
6905  		_month = timeinfo-&gt;tm_mon + 1;
6906  		_day = timeinfo-&gt;tm_mday;
6907  	}
6908  }
6909  void Date::now()
6910  {
6911  	time_t rawtime;
6912  	tm* timeinfo;
6913  	time(&amp;rawtime);
6914  	timeinfo = localtime(&amp;rawtime);
6915  	if (timeinfo)
6916  	{
6917  		_year = timeinfo-&gt;tm_year + 1900;
6918  		_month = timeinfo-&gt;tm_mon + 1;
6919  		_day = timeinfo-&gt;tm_mday;
6920  	}
6921  }
6922  EolType convertIntToFormatType(int value, EolType defvalue)
6923  {
6924  	switch (value)
6925  	{
6926  		case static_cast&lt;LPARAM&gt;(EolType::windows) :
6927  			return EolType::windows;
6928  		case static_cast&lt;LPARAM&gt;(EolType::macos) :
6929  				return EolType::macos;
6930  		case static_cast&lt;LPARAM&gt;(EolType::unix) :
6931  			return EolType::unix;
6932  		default:
6933  			return defvalue;
6934  	}
6935  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</h3>
            <pre><code>1  #include &lt;time.h&gt;
2  #include &lt;shlwapi.h&gt;
3  #include &lt;shlobj.h&gt;
4  #include &quot;Parameters.h&quot;
5  #include &quot;ScintillaEditView.h&quot;
6  #include &quot;keys.h&quot;
7  #include &quot;localization.h&quot;
8  #include &quot;localizationString.h&quot;
9  #include &quot;UserDefineDialog.h&quot;
10  #include &quot;WindowsDlgRc.h&quot;
11  #ifdef _MSC_VER
12  #pragma warning(disable : 4996) 
13  #endif
14  using namespace std;
15  namespace 
16  {
17  struct WinMenuKeyDefinition 
18  {
19  	int vKey;
20  	int functionId;
21  	bool isCtrl;
22  	bool isAlt;
23  	bool isShift;
24  	const TCHAR * specialName;		
25  };
26  struct ScintillaKeyDefinition
27  {
28  	const TCHAR * name;
29  	int functionId;
30  	bool isCtrl;
31  	bool isAlt;
32  	bool isShift;
33  	int vKey;
34  	int redirFunctionId;	
35  };
36  static const WinMenuKeyDefinition winKeyDefs[] =
37  {
38  	{ VK_N,       IDM_FILE_NEW,                                 true,  false, false, nullptr },
39  	{ VK_O,       IDM_FILE_OPEN,                                true,  false, false, nullptr },
40  	{ VK_NULL,    IDM_FILE_OPEN_FOLDER,                         false, false, false, TEXT(&quot;Open containing folder in Explorer&quot;) },
41  	{ VK_NULL,    IDM_FILE_OPEN_CMD,                            false, false, false, TEXT(&quot;Open containing folder in Command Prompt&quot;) },
42  	{ VK_NULL,    IDM_FILE_OPEN_DEFAULT_VIEWER,                 false, false, false, nullptr },
43  	{ VK_NULL,    IDM_FILE_OPENFOLDERASWORSPACE,                false, false, false, nullptr },
44  	{ VK_R,       IDM_FILE_RELOAD,                              true,  false, false, nullptr },
45  	{ VK_S,       IDM_FILE_SAVE,                                true,  false, false, nullptr },
46  	{ VK_S,       IDM_FILE_SAVEAS,                              true,  true,  false, nullptr },
47  	{ VK_NULL,    IDM_FILE_SAVECOPYAS,                          false, false, false, nullptr },
48  	{ VK_S,       IDM_FILE_SAVEALL,                             true,  false, true,  nullptr },
49  	{ VK_NULL,    IDM_FILE_RENAME,                              false, false, false, nullptr },
50  	{ VK_W,       IDM_FILE_CLOSE,                               true,  false, false, nullptr },
51  	{ VK_W,       IDM_FILE_CLOSEALL,                            true,  false, true,  nullptr },
52  	{ VK_NULL,    IDM_FILE_CLOSEALL_BUT_CURRENT,                false, false, false, nullptr },
53  	{ VK_NULL,    IDM_FILE_CLOSEALL_TOLEFT,                     false, false, false, nullptr },
54  	{ VK_NULL,    IDM_FILE_CLOSEALL_TORIGHT,                    false, false, false, nullptr },
55  	{ VK_NULL,    IDM_FILE_CLOSEALL_UNCHANGED,                  false, false, false, nullptr },
56  	{ VK_NULL,    IDM_FILE_DELETE,                              false, false, false, nullptr },
57  	{ VK_NULL,    IDM_FILE_LOADSESSION,                         false, false, false, nullptr },
58  	{ VK_NULL,    IDM_FILE_SAVESESSION,                         false, false, false, nullptr },
59  	{ VK_P,       IDM_FILE_PRINT,                               true,  false, false, nullptr },
60  	{ VK_NULL,    IDM_FILE_PRINTNOW,                            false, false, false, nullptr },
61  	{ VK_F4,      IDM_FILE_EXIT,                                false, true,  false, nullptr },
62  	{ VK_T,       IDM_FILE_RESTORELASTCLOSEDFILE,               true,  false, true,  TEXT(&quot;Restore Recent Closed File&quot;)},
63  	{ VK_B,       IDM_EDIT_BEGINENDSELECT,                      true,  false, true,  nullptr },
64  	{ VK_B,       IDM_EDIT_BEGINENDSELECT_COLUMNMODE,           false, true,  true,  nullptr },
65  	{ VK_NULL,    IDM_EDIT_FULLPATHTOCLIP,                      false, false, false, nullptr },
66  	{ VK_NULL,    IDM_EDIT_FILENAMETOCLIP,                      false, false, false, nullptr },
67  	{ VK_NULL,    IDM_EDIT_CURRENTDIRTOCLIP,                    false, false, false, nullptr },
68  	{ VK_NULL,    IDM_EDIT_COPY_ALL_NAMES,                      false, false, false, nullptr },
69  	{ VK_NULL,    IDM_EDIT_COPY_ALL_PATHS,                      false, false, false, nullptr },
70  	{ VK_NULL,    IDM_EDIT_INS_TAB,                             false, false, false, nullptr },
71  	{ VK_NULL,    IDM_EDIT_RMV_TAB,                             false, false, false, nullptr },
72  	{ VK_U,       IDM_EDIT_UPPERCASE,                           true,  false, true,  nullptr },
73  	{ VK_U,       IDM_EDIT_LOWERCASE,                           true,  false, false, nullptr },
74  	{ VK_U,       IDM_EDIT_PROPERCASE_FORCE,                    false, true,  false, nullptr },
75  	{ VK_U,       IDM_EDIT_PROPERCASE_BLEND,                    false, true,  true,  nullptr },
76  	{ VK_U,       IDM_EDIT_SENTENCECASE_FORCE,                  true,  true,  false, nullptr },
77  	{ VK_U,       IDM_EDIT_SENTENCECASE_BLEND,                  true,  true,  true,  nullptr },
78  	{ VK_NULL,    IDM_EDIT_INVERTCASE,                          false, false, false, nullptr },
79  	{ VK_NULL,    IDM_EDIT_RANDOMCASE,                          false, false, false, nullptr },
80  	{ VK_NULL,    IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES,        false, false, false, nullptr },
81  	{ VK_NULL,    IDM_EDIT_REMOVE_ANY_DUP_LINES,                false, false, false, nullptr },
82  	{ VK_I,       IDM_EDIT_SPLIT_LINES,                         true,  false, false, nullptr },
83  	{ VK_J,       IDM_EDIT_JOIN_LINES,                          true,  false, false, nullptr },
84  	{ VK_UP,      IDM_EDIT_LINE_UP,                             true,  false, true,  nullptr },
85  	{ VK_DOWN,    IDM_EDIT_LINE_DOWN,                           true,  false, true,  nullptr },
86  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINES,                    false, false, false, nullptr },
87  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINESWITHBLANK,           false, false, false, nullptr },
88  	{ VK_RETURN,  IDM_EDIT_BLANKLINEABOVECURRENT,               true,  true,  false, nullptr },
89  	{ VK_RETURN,  IDM_EDIT_BLANKLINEBELOWCURRENT,               true,  true,  true,  nullptr },
90  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING,   false, false, false, nullptr },
91  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING,  false, false, false, nullptr },
92  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING,   false, false, false, nullptr },
93  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING,  false, false, false, nullptr },
94  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_ASCENDING,         false, false, false, nullptr },
95  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_DESCENDING,        false, false, false, nullptr },
96  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING,    false, false, false, nullptr },
97  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING,   false, false, false, nullptr },
98  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING,      false, false, false, nullptr },
99  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING,     false, false, false, nullptr },
100  	{ VK_NULL,    IDM_EDIT_SORTLINES_REVERSE_ORDER,             false, false, false, nullptr },
101  	{ VK_NULL,    IDM_EDIT_SORTLINES_RANDOMLY,                  false, false, false, nullptr },
102  	{ VK_Q,       IDM_EDIT_BLOCK_COMMENT,                       true,  false, false, nullptr },
103  	{ VK_K,       IDM_EDIT_BLOCK_COMMENT_SET,                   true,  false, false, nullptr },
104  	{ VK_K,       IDM_EDIT_BLOCK_UNCOMMENT,                     true,  false, true,  nullptr },
105  	{ VK_Q,       IDM_EDIT_STREAM_COMMENT,                      true,  false, true,  nullptr },
106  	{ VK_NULL,    IDM_EDIT_STREAM_UNCOMMENT,                    false, false, false, nullptr },
107  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE,                        true,  false, false, nullptr },
108  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE_PATH,                   true,  true,  false, nullptr },
109  	{ VK_RETURN,  IDM_EDIT_AUTOCOMPLETE_CURRENTFILE,            true,  false, false, nullptr },
110  	{ VK_SPACE,   IDM_EDIT_FUNCCALLTIP,                         true,  false, true,  nullptr },
111  	{ VK_UP,      IDM_EDIT_FUNCCALLTIP_PREVIOUS,                false, true,  false, nullptr },
112  	{ VK_DOWN,    IDM_EDIT_FUNCCALLTIP_NEXT,                    false, true,  false, nullptr },
113  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_SHORT,               false, false, false, nullptr },
114  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_LONG,                false, false, false, nullptr },
115  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_CUSTOMIZED,          false, false, false, nullptr },
116  	{ VK_NULL,    IDM_FORMAT_TODOS,                             false, false, false, TEXT(&quot;EOL Conversion to Windows (CR LF)&quot;) },
117  	{ VK_NULL,    IDM_FORMAT_TOUNIX,                            false, false, false, TEXT(&quot;EOL Conversion to Unix (LF)&quot;) },
118  	{ VK_NULL,    IDM_FORMAT_TOMAC,                             false, false, false, TEXT(&quot;EOL Conversion to Macintosh (CR)&quot;) },
119  	{ VK_NULL,    IDM_EDIT_TRIMTRAILING,                        false, false, false, nullptr },
120  	{ VK_NULL,    IDM_EDIT_TRIMLINEHEAD,                        false, false, false, nullptr },
121  	{ VK_NULL,    IDM_EDIT_TRIM_BOTH,                           false, false, false, nullptr },
122  	{ VK_NULL,    IDM_EDIT_EOL2WS,                              false, false, false, nullptr },
123  	{ VK_NULL,    IDM_EDIT_TRIMALL,                             false, false, false, nullptr },
124  	{ VK_NULL,    IDM_EDIT_TAB2SW,                              false, false, false, nullptr },
125  	{ VK_NULL,    IDM_EDIT_SW2TAB_ALL,                          false, false, false, nullptr },
126  	{ VK_NULL,    IDM_EDIT_SW2TAB_LEADING,                      false, false, false, nullptr },
127  	{ VK_NULL,    IDM_EDIT_PASTE_AS_HTML,                       false, false, false, nullptr },
128  	{ VK_NULL,    IDM_EDIT_PASTE_AS_RTF,                        false, false, false, nullptr },
129  	{ VK_NULL,    IDM_EDIT_COPY_BINARY,                         false, false, false, nullptr },
130  	{ VK_NULL,    IDM_EDIT_CUT_BINARY,                          false, false, false, nullptr },
131  	{ VK_NULL,    IDM_EDIT_PASTE_BINARY,                        false, false, false, nullptr },
132  	{ VK_NULL,    IDM_EDIT_OPENASFILE,                          false, false, false, nullptr },
133  	{ VK_NULL,    IDM_EDIT_OPENINFOLDER,                        false, false, false, nullptr },
134  	{ VK_NULL,    IDM_EDIT_SEARCHONINTERNET,                    false, false, false, nullptr },
135  	{ VK_NULL,    IDM_EDIT_CHANGESEARCHENGINE,                  false, false, false, nullptr },
136  	{ VK_C,       IDM_EDIT_COLUMNMODE,                          false, true,  false, nullptr },
137  	{ VK_NULL,    IDM_EDIT_CHAR_PANEL,                          false, false, false, TEXT(&quot;Toggle Character Panel&quot;) },
138  	{ VK_NULL,    IDM_EDIT_CLIPBOARDHISTORY_PANEL,              false, false, false, TEXT(&quot;Toggle Clipboard History&quot;) },
139  	{ VK_NULL,    IDM_EDIT_SETREADONLY,                         false, false, false, nullptr },
140  	{ VK_NULL,    IDM_EDIT_CLEARREADONLY,                       false, false, false, nullptr },
141  	{ VK_F,       IDM_SEARCH_FIND,                              true,  false, false, nullptr },
142  	{ VK_F,       IDM_SEARCH_FINDINFILES,                       true,  false, true,  nullptr },
143  	{ VK_F3,      IDM_SEARCH_FINDNEXT,                          false, false, false, nullptr },
144  	{ VK_F3,      IDM_SEARCH_FINDPREV,                          false, false, true,  nullptr },
145  	{ VK_F3,      IDM_SEARCH_SETANDFINDNEXT,                    true,  false, false, nullptr },
146  	{ VK_F3,      IDM_SEARCH_SETANDFINDPREV,                    true,  false, true,  nullptr },
147  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDNEXT,                 true,  true,  false, nullptr },
148  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDPREV,                 true,  true,  true,  nullptr },
149  	{ VK_H,       IDM_SEARCH_REPLACE,                           true,  false, false, nullptr },
150  	{ VK_I,       IDM_SEARCH_FINDINCREMENT,                     true,  true,  false, nullptr },
151  	{ VK_F7,      IDM_FOCUS_ON_FOUND_RESULTS,                   false, false, false, nullptr },
152  	{ VK_F4,      IDM_SEARCH_GOTOPREVFOUND,                     false, false, true,  nullptr },
153  	{ VK_F4,      IDM_SEARCH_GOTONEXTFOUND,                     false, false, false, nullptr },
154  	{ VK_G,       IDM_SEARCH_GOTOLINE,                          true,  false, false, nullptr },
155  	{ VK_B,       IDM_SEARCH_GOTOMATCHINGBRACE,                 true,  false, false, nullptr },
156  	{ VK_B,       IDM_SEARCH_SELECTMATCHINGBRACES,              true,  true,  false, nullptr },
157  	{ VK_M,       IDM_SEARCH_MARK,                              true,  false, false, nullptr },
158  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT1,                       false, false, false, TEXT(&quot;Style all using 1st style&quot;) },
159  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT2,                       false, false, false, TEXT(&quot;Style all using 2nd style&quot;) },
160  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT3,                       false, false, false, TEXT(&quot;Style all using 3rd style&quot;) },
161  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT4,                       false, false, false, TEXT(&quot;Style all using 4th style&quot;) },
162  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT5,                       false, false, false, TEXT(&quot;Style all using 5th style&quot;) },
163  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT1,                       false, false, false, TEXT(&quot;Style one using 1st style&quot;) },
164  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT2,                       false, false, false, TEXT(&quot;Style one using 2nd style&quot;) },
165  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT3,                       false, false, false, TEXT(&quot;Style one using 3rd style&quot;) },
166  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT4,                       false, false, false, TEXT(&quot;Style one using 4th style&quot;) },
167  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT5,                       false, false, false, TEXT(&quot;Style one using 5th style&quot;) },
168  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT1,                     false, false, false, TEXT(&quot;Clear 1st style&quot;) },
169  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT2,                     false, false, false, TEXT(&quot;Clear 2nd style&quot;) },
170  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT3,                     false, false, false, TEXT(&quot;Clear 3rd style&quot;) },
171  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT4,                     false, false, false, TEXT(&quot;Clear 4th style&quot;) },
172  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT5,                     false, false, false, TEXT(&quot;Clear 5th style&quot;) },
173  	{ VK_NULL,    IDM_SEARCH_CLEARALLMARKS,                     false, false, false, TEXT(&quot;Clear all styles&quot;) },
174  	{ VK_1,       IDM_SEARCH_GOPREVMARKER1,                     true,  false, true,  TEXT(&quot;Previous style of 1st style&quot;) },
175  	{ VK_2,       IDM_SEARCH_GOPREVMARKER2,                     true,  false, true,  TEXT(&quot;Previous style of 2nd style&quot;) },
176  	{ VK_3,       IDM_SEARCH_GOPREVMARKER3,                     true,  false, true,  TEXT(&quot;Previous style of 3rd style&quot;) },
177  	{ VK_4,       IDM_SEARCH_GOPREVMARKER4,                     true,  false, true,  TEXT(&quot;Previous style of 4th style&quot;) },
178  	{ VK_5,       IDM_SEARCH_GOPREVMARKER5,                     true,  false, true,  TEXT(&quot;Previous style of 5th style&quot;) },
179  	{ VK_0,       IDM_SEARCH_GOPREVMARKER_DEF,                  true,  false, true,  TEXT(&quot;Previous style of Find Mark style&quot;) },
180  	{ VK_1,       IDM_SEARCH_GONEXTMARKER1,                     true,  false, false, TEXT(&quot;Next style of 1st style&quot;) },
181  	{ VK_2,       IDM_SEARCH_GONEXTMARKER2,                     true,  false, false, TEXT(&quot;Next style of 2nd style&quot;) },
182  	{ VK_3,       IDM_SEARCH_GONEXTMARKER3,                     true,  false, false, TEXT(&quot;Next style of 3rd style&quot;) },
183  	{ VK_4,       IDM_SEARCH_GONEXTMARKER4,                     true,  false, false, TEXT(&quot;Next style of 4th style&quot;) },
184  	{ VK_5,       IDM_SEARCH_GONEXTMARKER5,                     true,  false, false, TEXT(&quot;Next style of 5th style&quot;) },
185  	{ VK_0,       IDM_SEARCH_GONEXTMARKER_DEF,                  true,  false, false, TEXT(&quot;Next style of Find Mark style&quot;) },
186  	{ VK_NULL,    IDM_SEARCH_STYLE1TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 1st Style&quot;) },
187  	{ VK_NULL,    IDM_SEARCH_STYLE2TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 2nd Style&quot;) },
188  	{ VK_NULL,    IDM_SEARCH_STYLE3TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 3rd Style&quot;) },
189  	{ VK_NULL,    IDM_SEARCH_STYLE4TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 4th Style&quot;) },
190  	{ VK_NULL,    IDM_SEARCH_STYLE5TOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of 5th Style&quot;) },
191  	{ VK_NULL,    IDM_SEARCH_ALLSTYLESTOCLIP,                   false, false, false, TEXT(&quot;Copy Styled Text of All Styles&quot;) },
192  	{ VK_NULL,    IDM_SEARCH_MARKEDTOCLIP,                      false, false, false, TEXT(&quot;Copy Styled Text of Find Mark style&quot;) },
193  	{ VK_F2,      IDM_SEARCH_TOGGLE_BOOKMARK,                   true,  false, false, nullptr },
194  	{ VK_F2,      IDM_SEARCH_NEXT_BOOKMARK,                     false, false, false, nullptr },
195  	{ VK_F2,      IDM_SEARCH_PREV_BOOKMARK,                     false, false, true, nullptr  },
196  	{ VK_NULL,    IDM_SEARCH_CLEAR_BOOKMARKS,                   false, false, false, nullptr },
197  	{ VK_NULL,    IDM_SEARCH_CUTMARKEDLINES,                    false, false, false, nullptr },
198  	{ VK_NULL,    IDM_SEARCH_COPYMARKEDLINES,                   false, false, false, nullptr },
199  	{ VK_NULL,    IDM_SEARCH_PASTEMARKEDLINES,                  false, false, false, nullptr },
200  	{ VK_NULL,    IDM_SEARCH_DELETEMARKEDLINES,                 false, false, false, nullptr },
201  	{ VK_NULL,    IDM_SEARCH_DELETEUNMARKEDLINES,               false, false, false, nullptr },
202  	{ VK_NULL,    IDM_SEARCH_INVERSEMARKS,                      false, false, false, nullptr },
203  	{ VK_NULL,    IDM_SEARCH_FINDCHARINRANGE,                   false, false, false, nullptr },
204  	{ VK_NULL,    IDM_VIEW_ALWAYSONTOP,                         false, false, false, nullptr },
205  	{ VK_F11,     IDM_VIEW_FULLSCREENTOGGLE,                    false, false, false, nullptr },
206  	{ VK_F12,     IDM_VIEW_POSTIT,                              false, false, false, nullptr },
207  	{ VK_NULL,    IDM_VIEW_DISTRACTIONFREE,                     false, false, false, nullptr },
208  	{ VK_NULL,    IDM_VIEW_IN_FIREFOX,                          false, false, false, TEXT(&quot;View current file in Firefox&quot;) },
209  	{ VK_NULL,    IDM_VIEW_IN_CHROME,                           false, false, false, TEXT(&quot;View current file in Chrome&quot;) },
210  	{ VK_NULL,    IDM_VIEW_IN_IE,                               false, false, false, TEXT(&quot;View current file in IE&quot;) },
211  	{ VK_NULL,    IDM_VIEW_IN_EDGE,                             false, false, false, TEXT(&quot;View current file in Edge&quot;)  },
212  	{ VK_NULL,    IDM_VIEW_TAB_SPACE,                           false, false, false, nullptr },
213  	{ VK_NULL,    IDM_VIEW_EOL,                                 false, false, false, nullptr },
214  	{ VK_NULL,    IDM_VIEW_ALL_CHARACTERS,                      false, false, false, nullptr },
215  	{ VK_NULL,    IDM_VIEW_NPC,                                 false, false, false, nullptr },
216  	{ VK_NULL,    IDM_VIEW_NPC_CCUNIEOL,                        false, false, false, nullptr },
217  	{ VK_NULL,    IDM_VIEW_INDENT_GUIDE,                        false, false, false, nullptr },
218  	{ VK_NULL,    IDM_VIEW_WRAP_SYMBOL,                         false, false, false, nullptr },
219  	{ VK_NULL,    IDM_VIEW_GOTO_ANOTHER_VIEW,                   false, false, false, nullptr },
220  	{ VK_NULL,    IDM_VIEW_CLONE_TO_ANOTHER_VIEW,               false, false, false, nullptr },
221  	{ VK_NULL,    IDM_VIEW_GOTO_NEW_INSTANCE,                   false, false, false, nullptr },
222  	{ VK_NULL,    IDM_VIEW_LOAD_IN_NEW_INSTANCE,                false, false, false, nullptr },
223  	{ VK_NUMPAD1, IDM_VIEW_TAB1,                                true,  false, false, nullptr },
224  	{ VK_NUMPAD2, IDM_VIEW_TAB2,                                true,  false, false, nullptr },
225  	{ VK_NUMPAD3, IDM_VIEW_TAB3,                                true,  false, false, nullptr },
226  	{ VK_NUMPAD4, IDM_VIEW_TAB4,                                true,  false, false, nullptr },
227  	{ VK_NUMPAD5, IDM_VIEW_TAB5,                                true,  false, false, nullptr },
228  	{ VK_NUMPAD6, IDM_VIEW_TAB6,                                true,  false, false, nullptr },
229  	{ VK_NUMPAD7, IDM_VIEW_TAB7,                                true,  false, false, nullptr },
230  	{ VK_NUMPAD8, IDM_VIEW_TAB8,                                true,  false, false, nullptr },
231  	{ VK_NUMPAD9, IDM_VIEW_TAB9,                                true,  false, false, nullptr },
232  	{ VK_NEXT,    IDM_VIEW_TAB_NEXT,                            true,  false, false, nullptr },
233  	{ VK_PRIOR,   IDM_VIEW_TAB_PREV,                            true,  false, false, nullptr },
234  	{ VK_NEXT,    IDM_VIEW_TAB_MOVEFORWARD,                     true,  false, true,  nullptr },
235  	{ VK_PRIOR,   IDM_VIEW_TAB_MOVEBACKWARD,                    true,  false, true,  nullptr },
236  	{ VK_TAB,     IDC_PREV_DOC,                                 true,  false, true,  TEXT(&quot;Switch to previous document&quot;) },
237  	{ VK_TAB,     IDC_NEXT_DOC,                                 true,  false, false, TEXT(&quot;Switch to next document&quot;) },
238  	{ VK_NULL,    IDM_VIEW_WRAP,                                false, false, false, nullptr },
239  	{ VK_H,       IDM_VIEW_HIDELINES,                           false, true,  false, nullptr },
240  	{ VK_F8,      IDM_VIEW_SWITCHTO_OTHER_VIEW,                 false, false, false, nullptr },
241  	{ VK_0,       IDM_VIEW_FOLDALL,                             false, true,  false, nullptr },
242  	{ VK_0,       IDM_VIEW_UNFOLDALL,                           false, true,  true,  nullptr },
243  	{ VK_F,       IDM_VIEW_FOLD_CURRENT,                        true,  true,  false, nullptr },
244  	{ VK_F,       IDM_VIEW_UNFOLD_CURRENT,                      true,  true,  true,  nullptr },
245  	{ VK_1,       IDM_VIEW_FOLD_1,                              false, true,  false, TEXT(&quot;Fold Level 1&quot;) },
246  	{ VK_2,       IDM_VIEW_FOLD_2,                              false, true,  false, TEXT(&quot;Fold Level 2&quot;) },
247  	{ VK_3,       IDM_VIEW_FOLD_3,                              false, true,  false, TEXT(&quot;Fold Level 3&quot;) },
248  	{ VK_4,       IDM_VIEW_FOLD_4,                              false, true,  false, TEXT(&quot;Fold Level 4&quot;) },
249  	{ VK_5,       IDM_VIEW_FOLD_5,                              false, true,  false, TEXT(&quot;Fold Level 5&quot;) },
250  	{ VK_6,       IDM_VIEW_FOLD_6,                              false, true,  false, TEXT(&quot;Fold Level 6&quot;) },
251  	{ VK_7,       IDM_VIEW_FOLD_7,                              false, true,  false, TEXT(&quot;Fold Level 7&quot;) },
252  	{ VK_8,       IDM_VIEW_FOLD_8,                              false, true,  false, TEXT(&quot;Fold Level 8&quot;) },
253  	{ VK_1,       IDM_VIEW_UNFOLD_1,                            false, true,  true,  TEXT(&quot;Unfold Level 1&quot;) },
254  	{ VK_2,       IDM_VIEW_UNFOLD_2,                            false, true,  true,  TEXT(&quot;Unfold Level 2&quot;) },
255  	{ VK_3,       IDM_VIEW_UNFOLD_3,                            false, true,  true,  TEXT(&quot;Unfold Level 3&quot;) },
256  	{ VK_4,       IDM_VIEW_UNFOLD_4,                            false, true,  true,  TEXT(&quot;Unfold Level 4&quot;) },
257  	{ VK_5,       IDM_VIEW_UNFOLD_5,                            false, true,  true,  TEXT(&quot;Unfold Level 5&quot;) },
258  	{ VK_6,       IDM_VIEW_UNFOLD_6,                            false, true,  true,  TEXT(&quot;Unfold Level 6&quot;) },
259  	{ VK_7,       IDM_VIEW_UNFOLD_7,                            false, true,  true,  TEXT(&quot;Unfold Level 7&quot;) },
260  	{ VK_8,       IDM_VIEW_UNFOLD_8,                            false, true,  true,  TEXT(&quot;Unfold Level 8&quot;) },
261  	{ VK_NULL,    IDM_VIEW_SUMMARY,                             false, false, false, nullptr },
262  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_1,                     false, false, false, TEXT(&quot;Toggle Project Panel 1&quot;) },
263  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_2,                     false, false, false, TEXT(&quot;Toggle Project Panel 2&quot;) },
264  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_3,                     false, false, false, TEXT(&quot;Toggle Project Panel 3&quot;) },
265  	{ VK_NULL,    IDM_VIEW_FILEBROWSER,                         false, false, false, TEXT(&quot;Toggle Folder as Workspace&quot;) },
266  	{ VK_NULL,    IDM_VIEW_DOC_MAP,                             false, false, false, TEXT(&quot;Toggle Document Map&quot;) },
267  	{ VK_NULL,    IDM_VIEW_DOCLIST,                             false, false, false, TEXT(&quot;Toggle Document List&quot;) },
268  	{ VK_NULL,    IDM_VIEW_FUNC_LIST,                           false, false, false, TEXT(&quot;Toggle Function List&quot;) },
269  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_1,            false, false, false, TEXT(&quot;Switch to Project Panel 1&quot;) },
270  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_2,            false, false, false, TEXT(&quot;Switch to Project Panel 2&quot;) },
271  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_3,            false, false, false, TEXT(&quot;Switch to Project Panel 3&quot;) },
272  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FILEBROWSER,                false, false, false, TEXT(&quot;Switch to Folder as Workspace&quot;) },
273  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FUNC_LIST,                  false, false, false, TEXT(&quot;Switch to Function List&quot;) },
274  	{ VK_NULL,    IDM_VIEW_SWITCHTO_DOCLIST,                    false, false, false, TEXT(&quot;Switch to Document List&quot;) },
275  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_NONE,                     false, false, false, TEXT(&quot;Remove Tab Colour&quot;) },
276  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_1,                        false, false, false, TEXT(&quot;Apply Tab Colour 1&quot;) },
277  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_2,                        false, false, false, TEXT(&quot;Apply Tab Colour 2&quot;) },
278  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_3,                        false, false, false, TEXT(&quot;Apply Tab Colour 3&quot;) },
279  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_4,                        false, false, false, TEXT(&quot;Apply Tab Colour 4&quot;) },
280  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_5,                        false, false, false, TEXT(&quot;Apply Tab Colour 5&quot;) },
281  	{ VK_NULL,    IDM_VIEW_SYNSCROLLV,                          false, false, false, nullptr },
282  	{ VK_NULL,    IDM_VIEW_SYNSCROLLH,                          false, false, false, nullptr },
283  	{ VK_R,       IDM_EDIT_RTL,                                 true,  true,  false, nullptr },
284  	{ VK_L,       IDM_EDIT_LTR,                                 true,  true,  false, nullptr },
285  	{ VK_NULL,    IDM_VIEW_MONITORING,                          false, false, false, nullptr },
286  	{ VK_NULL,    IDM_FORMAT_ANSI,                              false, false, false, nullptr },
287  	{ VK_NULL,    IDM_FORMAT_AS_UTF_8,                          false, false, false, nullptr },
288  	{ VK_NULL,    IDM_FORMAT_UTF_8,                             false, false, false, nullptr },
289  	{ VK_NULL,    IDM_FORMAT_UTF_16BE,                          false, false, false, nullptr },
290  	{ VK_NULL,    IDM_FORMAT_UTF_16LE,                          false, false, false, nullptr },
291  	{ VK_NULL,    IDM_FORMAT_ISO_8859_6,                        false, false, false, nullptr },
292  	{ VK_NULL,    IDM_FORMAT_WIN_1256,                          false, false, false, nullptr },
293  	{ VK_NULL,    IDM_FORMAT_ISO_8859_13,                       false, false, false, nullptr },
294  	{ VK_NULL,    IDM_FORMAT_WIN_1257,                          false, false, false, nullptr },
295  	{ VK_NULL,    IDM_FORMAT_ISO_8859_14,                       false, false, false, nullptr },
296  	{ VK_NULL,    IDM_FORMAT_ISO_8859_5,                        false, false, false, nullptr },
297  	{ VK_NULL,    IDM_FORMAT_MAC_CYRILLIC,                      false, false, false, nullptr },
298  	{ VK_NULL,    IDM_FORMAT_KOI8R_CYRILLIC,                    false, false, false, nullptr },
299  	{ VK_NULL,    IDM_FORMAT_KOI8U_CYRILLIC,                    false, false, false, nullptr },
300  	{ VK_NULL,    IDM_FORMAT_WIN_1251,                          false, false, false, nullptr },
301  	{ VK_NULL,    IDM_FORMAT_WIN_1250,                          false, false, false, nullptr },
302  	{ VK_NULL,    IDM_FORMAT_DOS_437,                           false, false, false, nullptr },
303  	{ VK_NULL,    IDM_FORMAT_DOS_720,                           false, false, false, nullptr },
304  	{ VK_NULL,    IDM_FORMAT_DOS_737,                           false, false, false, nullptr },
305  	{ VK_NULL,    IDM_FORMAT_DOS_775,                           false, false, false, nullptr },
306  	{ VK_NULL,    IDM_FORMAT_DOS_850,                           false, false, false, nullptr },
307  	{ VK_NULL,    IDM_FORMAT_DOS_852,                           false, false, false, nullptr },
308  	{ VK_NULL,    IDM_FORMAT_DOS_855,                           false, false, false, nullptr },
309  	{ VK_NULL,    IDM_FORMAT_DOS_857,                           false, false, false, nullptr },
310  	{ VK_NULL,    IDM_FORMAT_DOS_858,                           false, false, false, nullptr },
311  	{ VK_NULL,    IDM_FORMAT_DOS_860,                           false, false, false, nullptr },
312  	{ VK_NULL,    IDM_FORMAT_DOS_861,                           false, false, false, nullptr },
313  	{ VK_NULL,    IDM_FORMAT_DOS_862,                           false, false, false, nullptr },
314  	{ VK_NULL,    IDM_FORMAT_DOS_863,                           false, false, false, nullptr },
315  	{ VK_NULL,    IDM_FORMAT_DOS_865,                           false, false, false, nullptr },
316  	{ VK_NULL,    IDM_FORMAT_DOS_866,                           false, false, false, nullptr },
317  	{ VK_NULL,    IDM_FORMAT_DOS_869,                           false, false, false, nullptr },
318  	{ VK_NULL,    IDM_FORMAT_BIG5,                              false, false, false, nullptr },
319  	{ VK_NULL,    IDM_FORMAT_GB2312,                            false, false, false, nullptr },
320  	{ VK_NULL,    IDM_FORMAT_ISO_8859_2,                        false, false, false, nullptr },
321  	{ VK_NULL,    IDM_FORMAT_ISO_8859_7,                        false, false, false, nullptr },
322  	{ VK_NULL,    IDM_FORMAT_WIN_1253,                          false, false, false, nullptr },
323  	{ VK_NULL,    IDM_FORMAT_ISO_8859_8,                        false, false, false, nullptr },
324  	{ VK_NULL,    IDM_FORMAT_WIN_1255,                          false, false, false, nullptr },
325  	{ VK_NULL,    IDM_FORMAT_SHIFT_JIS,                         false, false, false, nullptr },
326  	{ VK_NULL,    IDM_FORMAT_EUC_KR,                            false, false, false, nullptr },
327  	{ VK_NULL,    IDM_FORMAT_ISO_8859_15,                       false, false, false, nullptr },
328  	{ VK_NULL,    IDM_FORMAT_ISO_8859_4,                        false, false, false, nullptr },
329  	{ VK_NULL,    IDM_FORMAT_ISO_8859_3,                        false, false, false, nullptr },
330  	{ VK_NULL,    IDM_FORMAT_TIS_620,                           false, false, false, nullptr },
331  	{ VK_NULL,    IDM_FORMAT_ISO_8859_9,                        false, false, false, nullptr },
332  	{ VK_NULL,    IDM_FORMAT_WIN_1254,                          false, false, false, nullptr },
333  	{ VK_NULL,    IDM_FORMAT_WIN_1252,                          false, false, false, nullptr },
334  	{ VK_NULL,    IDM_FORMAT_ISO_8859_1,                        false, false, false, nullptr },
335  	{ VK_NULL,    IDM_FORMAT_WIN_1258,                          false, false, false, nullptr },
336  	{ VK_NULL,    IDM_FORMAT_CONV2_ANSI,                        false, false, false, nullptr },
337  	{ VK_NULL,    IDM_FORMAT_CONV2_AS_UTF_8,                    false, false, false, nullptr },
338  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_8,                       false, false, false, nullptr },
339  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16BE,                    false, false, false, nullptr },
340  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16LE,                    false, false, false, nullptr },
341  	{ VK_NULL,    IDM_LANG_USER_DLG,                            false, false, false, nullptr },
342  	{ VK_NULL,    IDM_LANG_USER,                                false, false, false, nullptr },
343  	{ VK_NULL,    IDM_LANG_OPENUDLDIR,                          false, false, false, nullptr },
344  	{ VK_NULL,    IDM_SETTING_PREFERENCE,                       false, false, false, nullptr },
345  	{ VK_NULL,    IDM_LANGSTYLE_CONFIG_DLG,                     false, false, false, nullptr },
346  	{ VK_NULL,    IDM_SETTING_SHORTCUT_MAPPER,                  false, false, false, nullptr },
347  	{ VK_NULL,    IDM_SETTING_IMPORTPLUGIN,                     false, false, false, nullptr },
348  	{ VK_NULL,    IDM_SETTING_IMPORTSTYLETHEMS,                 false, false, false, nullptr },
349  	{ VK_NULL,    IDM_SETTING_EDITCONTEXTMENU,                  false, false, false, nullptr },
350  	{ VK_R,       IDC_EDIT_TOGGLEMACRORECORDING,                true,  false, true,  TEXT(&quot;Toggle macro recording&quot;)},
351  	{ VK_NULL,    IDM_MACRO_STARTRECORDINGMACRO,                false, false, false, nullptr },
352  	{ VK_NULL,    IDM_MACRO_STOPRECORDINGMACRO,                 false, false, false, nullptr },
353  	{ VK_P,       IDM_MACRO_PLAYBACKRECORDEDMACRO,              true,  false, true,  nullptr },
354  	{ VK_NULL,    IDM_MACRO_SAVECURRENTMACRO,                   false, false, false, nullptr },
355  	{ VK_NULL,    IDM_MACRO_RUNMULTIMACRODLG,                   false, false, false, nullptr },
356  	{ VK_F5,      IDM_EXECUTE,                                  false, false, false, nullptr },
357  	{ VK_NULL,    IDM_WINDOW_SORT_FN_ASC,                       false, false, false, TEXT(&quot;Sort By Name A to Z&quot;) },
358  	{ VK_NULL,    IDM_WINDOW_SORT_FN_DSC,                       false, false, false, TEXT(&quot;Sort By Name Z to A&quot;) },
359  	{ VK_NULL,    IDM_WINDOW_SORT_FP_ASC,                       false, false, false, TEXT(&quot;Sort By Path A to Z&quot;) },
360  	{ VK_NULL,    IDM_WINDOW_SORT_FP_DSC,                       false, false, false, TEXT(&quot;Sort By Path Z to A&quot;) },
361  	{ VK_NULL,    IDM_WINDOW_SORT_FT_ASC,                       false, false, false, TEXT(&quot;Sort By Type A to Z&quot;) },
362  	{ VK_NULL,    IDM_WINDOW_SORT_FT_DSC,                       false, false, false, TEXT(&quot;Sort By Type Z to A&quot;) },
363  	{ VK_NULL,    IDM_WINDOW_SORT_FS_ASC,                       false, false, false, TEXT(&quot;Sort By Size Smaller to Larger&quot;) },
364  	{ VK_NULL,    IDM_WINDOW_SORT_FS_DSC,                       false, false, false, TEXT(&quot;Sort By Size Larger to Smaller&quot;) },
365  	{ VK_NULL,    IDM_CMDLINEARGUMENTS,                         false, false, false, nullptr },
366  	{ VK_NULL,    IDM_HOMESWEETHOME,                            false, false, false, nullptr },
367  	{ VK_NULL,    IDM_PROJECTPAGE,                              false, false, false, nullptr },
368  	{ VK_NULL,    IDM_ONLINEDOCUMENT,                           false, false, false, nullptr },
369  	{ VK_NULL,    IDM_FORUM,                                    false, false, false, nullptr },
370  	{ VK_NULL,    IDM_UPDATE_NPP,                               false, false, false, TEXT(&quot;Update Notepad++&quot;) },
371  	{ VK_NULL,    IDM_CONFUPDATERPROXY,                         false, false, false, TEXT(&quot;Set Updater Proxy...&quot;) },
372  	{ VK_NULL,    IDM_DEBUGINFO,                                false, false, false, nullptr },
373  	{ VK_F1,      IDM_ABOUT,                                    false, false, false, nullptr }
374  };
375  static const ScintillaKeyDefinition scintKeyDefs[] =
376  {
377  	{TEXT(&quot;SCI_CUT&quot;),                     SCI_CUT,                     true,  false, false, VK_X,        IDM_EDIT_CUT},
378  	{TEXT(&quot;&quot;),                            SCI_CUT,                     false, false, true,  VK_DELETE,   0},
379  	{TEXT(&quot;SCI_COPY&quot;),                    SCI_COPY,                    true,  false, false, VK_C,        IDM_EDIT_COPY},
380  	{TEXT(&quot;&quot;),                            SCI_COPY,                    true,  false, false, VK_INSERT,   0},
381  	{TEXT(&quot;SCI_PASTE&quot;),                   SCI_PASTE,                   true,  false, false, VK_V,        IDM_EDIT_PASTE},
382  	{TEXT(&quot;&quot;),                            SCI_PASTE,                   false, false, true,  VK_INSERT,   0},
383  	{TEXT(&quot;SCI_SELECTALL&quot;),               SCI_SELECTALL,               true,  false, false, VK_A,        IDM_EDIT_SELECTALL},
384  	{TEXT(&quot;SCI_CLEAR&quot;),                   SCI_CLEAR,                   false, false, false, VK_DELETE,   IDM_EDIT_DELETE},
385  	{TEXT(&quot;SCI_CLEARALL&quot;),                SCI_CLEARALL,                false, false, false, 0,           0},
386  	{TEXT(&quot;SCI_UNDO&quot;),                    SCI_UNDO,                    true,  false, false, VK_Z,        IDM_EDIT_UNDO},
387  	{TEXT(&quot;&quot;),                            SCI_UNDO,                    false, true,  false, VK_BACK,     0},
388  	{TEXT(&quot;SCI_REDO&quot;),                    SCI_REDO,                    true,  false, false, VK_Y,        IDM_EDIT_REDO},
389  	{TEXT(&quot;&quot;),                            SCI_REDO,                    true,  false, true,  VK_Z,        0},
390  	{TEXT(&quot;SCI_NEWLINE&quot;),                 SCI_NEWLINE,                 false, false, false, VK_RETURN,   0},
391  	{TEXT(&quot;&quot;),                            SCI_NEWLINE,                 false, false, true,  VK_RETURN,   0},
392  	{TEXT(&quot;SCI_TAB&quot;),                     SCI_TAB,                     false, false, false, VK_TAB,      0},
393  	{TEXT(&quot;SCI_BACKTAB&quot;),                 SCI_BACKTAB,                 false, false, true,  VK_TAB,      0},
394  	{TEXT(&quot;SCI_FORMFEED&quot;),                SCI_FORMFEED,                false, false, false, 0,           0},
395  	{TEXT(&quot;SCI_ZOOMIN&quot;),                  SCI_ZOOMIN,                  true,  false, false, VK_ADD,      IDM_VIEW_ZOOMIN},
396  	{TEXT(&quot;SCI_ZOOMOUT&quot;),                 SCI_ZOOMOUT,                 true,  false, false, VK_SUBTRACT, IDM_VIEW_ZOOMOUT},
397  	{TEXT(&quot;SCI_SETZOOM&quot;),                 SCI_SETZOOM,                 true,  false, false, VK_DIVIDE,   IDM_VIEW_ZOOMRESTORE},
398  	{TEXT(&quot;SCI_SELECTIONDUPLICATE&quot;),      SCI_SELECTIONDUPLICATE,      true,  false, false, VK_D,        IDM_EDIT_DUP_LINE},
399  	{TEXT(&quot;SCI_LINESJOIN&quot;),               SCI_LINESJOIN,               false, false, false, 0,           0},
400  	{TEXT(&quot;SCI_SCROLLCARET&quot;),             SCI_SCROLLCARET,             false, false, false, 0,           0},
401  	{TEXT(&quot;SCI_EDITTOGGLEOVERTYPE&quot;),      SCI_EDITTOGGLEOVERTYPE,      false, false, false, VK_INSERT,   0},
402  	{TEXT(&quot;SCI_MOVECARETINSIDEVIEW&quot;),     SCI_MOVECARETINSIDEVIEW,     false, false, false, 0,           0},
403  	{TEXT(&quot;SCI_LINEDOWN&quot;),                SCI_LINEDOWN,                false, false, false, VK_DOWN,     0},
404  	{TEXT(&quot;SCI_LINEDOWNEXTEND&quot;),          SCI_LINEDOWNEXTEND,          false, false, true,  VK_DOWN,     0},
405  	{TEXT(&quot;SCI_LINEDOWNRECTEXTEND&quot;),      SCI_LINEDOWNRECTEXTEND,      false, true,  true,  VK_DOWN,     0},
406  	{TEXT(&quot;SCI_LINESCROLLDOWN&quot;),          SCI_LINESCROLLDOWN,          true,  false, false, VK_DOWN,     0},
407  	{TEXT(&quot;SCI_LINEUP&quot;),                  SCI_LINEUP,                  false, false, false, VK_UP,       0},
408  	{TEXT(&quot;SCI_LINEUPEXTEND&quot;),            SCI_LINEUPEXTEND,            false, false, true,  VK_UP,       0},
409  	{TEXT(&quot;SCI_LINEUPRECTEXTEND&quot;),        SCI_LINEUPRECTEXTEND,        false, true,  true,  VK_UP,       0},
410  	{TEXT(&quot;SCI_LINESCROLLUP&quot;),            SCI_LINESCROLLUP,            true,  false, false, VK_UP,       0},
411  	{TEXT(&quot;SCI_PARADOWN&quot;),                SCI_PARADOWN,                true,  false, false, VK_OEM_6,    0},
412  	{TEXT(&quot;SCI_PARADOWNEXTEND&quot;),          SCI_PARADOWNEXTEND,          true,  false, true,  VK_OEM_6,    0},
413  	{TEXT(&quot;SCI_PARAUP&quot;),                  SCI_PARAUP,                  true,  false, false, VK_OEM_4,    0},
414  	{TEXT(&quot;SCI_PARAUPEXTEND&quot;),            SCI_PARAUPEXTEND,            true,  false, true,  VK_OEM_4,    0},
415  	{TEXT(&quot;SCI_CHARLEFT&quot;),                SCI_CHARLEFT,                false, false, false, VK_LEFT,     0},
416  	{TEXT(&quot;SCI_CHARLEFTEXTEND&quot;),          SCI_CHARLEFTEXTEND,          false, false, true,  VK_LEFT,     0},
417  	{TEXT(&quot;SCI_CHARLEFTRECTEXTEND&quot;),      SCI_CHARLEFTRECTEXTEND,      false, true,  true,  VK_LEFT,     0},
418  	{TEXT(&quot;SCI_CHARRIGHT&quot;),               SCI_CHARRIGHT,               false, false, false, VK_RIGHT,    0},
419  	{TEXT(&quot;SCI_CHARRIGHTEXTEND&quot;),         SCI_CHARRIGHTEXTEND,         false, false, true,  VK_RIGHT,    0},
420  	{TEXT(&quot;SCI_CHARRIGHTRECTEXTEND&quot;),     SCI_CHARRIGHTRECTEXTEND,     false, true,  true,  VK_RIGHT,    0},
421  	{TEXT(&quot;SCI_WORDLEFT&quot;),                SCI_WORDLEFT,                true,  false, false, VK_LEFT,     0},
422  	{TEXT(&quot;SCI_WORDLEFTEXTEND&quot;),          SCI_WORDLEFTEXTEND,          true,  false, true,  VK_LEFT,     0},
423  	{TEXT(&quot;SCI_WORDRIGHT&quot;),               SCI_WORDRIGHT,               true,  false, false, VK_RIGHT,    0},
424  	{TEXT(&quot;SCI_WORDRIGHTEXTEND&quot;),         SCI_WORDRIGHTEXTEND,         false, false, false, 0,           0},
425  	{TEXT(&quot;SCI_WORDLEFTEND&quot;),             SCI_WORDLEFTEND,             false, false, false, 0,           0},
426  	{TEXT(&quot;SCI_WORDLEFTENDEXTEND&quot;),       SCI_WORDLEFTENDEXTEND,       false, false, false, 0,           0},
427  	{TEXT(&quot;SCI_WORDRIGHTEND&quot;),            SCI_WORDRIGHTEND,            false, false, false, 0,           0},
428  	{TEXT(&quot;SCI_WORDRIGHTENDEXTEND&quot;),      SCI_WORDRIGHTENDEXTEND,      true,  false, true,  VK_RIGHT,    0},
429  	{TEXT(&quot;SCI_WORDPARTLEFT&quot;),            SCI_WORDPARTLEFT,            true,  false, false, VK_OEM_2,    0},
430  	{TEXT(&quot;SCI_WORDPARTLEFTEXTEND&quot;),      SCI_WORDPARTLEFTEXTEND,      true,  false, true,  VK_OEM_2,    0},
431  	{TEXT(&quot;SCI_WORDPARTRIGHT&quot;),           SCI_WORDPARTRIGHT,           true,  false, false, VK_OEM_5,    0},
432  	{TEXT(&quot;SCI_WORDPARTRIGHTEXTEND&quot;),     SCI_WORDPARTRIGHTEXTEND,     true,  false, true,  VK_OEM_5,    0},
433  	{TEXT(&quot;SCI_HOME&quot;),                    SCI_HOME,                    false, false, false, 0,           0},
434  	{TEXT(&quot;SCI_HOMEEXTEND&quot;),              SCI_HOMEEXTEND,              false, false, false, 0,           0},
435  	{TEXT(&quot;SCI_HOMERECTEXTEND&quot;),          SCI_HOMERECTEXTEND,          false, false, false, 0,           0},
436  	{TEXT(&quot;SCI_HOMEDISPLAY&quot;),             SCI_HOMEDISPLAY,             false, true,  false, VK_HOME,     0},
437  	{TEXT(&quot;SCI_HOMEDISPLAYEXTEND&quot;),       SCI_HOMEDISPLAYEXTEND,       false, false, false, 0,           0},
438  	{TEXT(&quot;SCI_HOMEWRAP&quot;),                SCI_HOMEWRAP,                false, false, false, 0,           0},
439  	{TEXT(&quot;SCI_HOMEWRAPEXTEND&quot;),          SCI_HOMEWRAPEXTEND,          false, false, false, 0,           0},
440  	{TEXT(&quot;SCI_VCHOME&quot;),                  SCI_VCHOME,                  false, false, false, 0,           0},
441  	{TEXT(&quot;SCI_VCHOMEEXTEND&quot;),            SCI_VCHOMEEXTEND,            false, false, false, 0,           0},
442  	{TEXT(&quot;SCI_VCHOMERECTEXTEND&quot;),        SCI_VCHOMERECTEXTEND,        false, true,  true,  VK_HOME,     0},
443  	{TEXT(&quot;SCI_VCHOMEDISPLAY&quot;),           SCI_VCHOMEDISPLAY,           false, false, false, 0,           0},
444  	{TEXT(&quot;SCI_VCHOMEDISPLAYEXTEND&quot;),     SCI_VCHOMEDISPLAYEXTEND,     false, false, false, 0,           0},
445  	{TEXT(&quot;SCI_VCHOMEWRAP&quot;),              SCI_VCHOMEWRAP,              false, false, false, VK_HOME,     0},
446  	{TEXT(&quot;SCI_VCHOMEWRAPEXTEND&quot;),        SCI_VCHOMEWRAPEXTEND,        false, false, true,  VK_HOME,     0},
447  	{TEXT(&quot;SCI_LINEEND&quot;),                 SCI_LINEEND,                 false, false, false, 0,           0},
448  	{TEXT(&quot;SCI_LINEENDWRAPEXTEND&quot;),       SCI_LINEENDWRAPEXTEND,       false, false, true,  VK_END,      0},
449  	{TEXT(&quot;SCI_LINEENDRECTEXTEND&quot;),       SCI_LINEENDRECTEXTEND,       false, true,  true,  VK_END,      0},
450  	{TEXT(&quot;SCI_LINEENDDISPLAY&quot;),          SCI_LINEENDDISPLAY,          false, true,  false, VK_END,      0},
451  	{TEXT(&quot;SCI_LINEENDDISPLAYEXTEND&quot;),    SCI_LINEENDDISPLAYEXTEND,    false, false, false, 0,           0},
452  	{TEXT(&quot;SCI_LINEENDWRAP&quot;),             SCI_LINEENDWRAP,             false, false, false, VK_END,      0},
453  	{TEXT(&quot;SCI_LINEENDEXTEND&quot;),           SCI_LINEENDEXTEND,           false, false, false, 0,           0},
454  	{TEXT(&quot;SCI_DOCUMENTSTART&quot;),           SCI_DOCUMENTSTART,           true,  false, false, VK_HOME,     0},
455  	{TEXT(&quot;SCI_DOCUMENTSTARTEXTEND&quot;),     SCI_DOCUMENTSTARTEXTEND,     true,  false, true,  VK_HOME,     0},
456  	{TEXT(&quot;SCI_DOCUMENTEND&quot;),             SCI_DOCUMENTEND,             true,  false, false, VK_END,      0},
457  	{TEXT(&quot;SCI_DOCUMENTENDEXTEND&quot;),       SCI_DOCUMENTENDEXTEND,       true,  false, true,  VK_END,      0},
458  	{TEXT(&quot;SCI_PAGEUP&quot;),                  SCI_PAGEUP,                  false, false, false, VK_PRIOR,    0},
459  	{TEXT(&quot;SCI_PAGEUPEXTEND&quot;),            SCI_PAGEUPEXTEND,            false, false, true,  VK_PRIOR,    0},
460  	{TEXT(&quot;SCI_PAGEUPRECTEXTEND&quot;),        SCI_PAGEUPRECTEXTEND,        false, true,  true,  VK_PRIOR,    0},
461  	{TEXT(&quot;SCI_PAGEDOWN&quot;),                SCI_PAGEDOWN,                false, false, false, VK_NEXT,     0},
462  	{TEXT(&quot;SCI_PAGEDOWNEXTEND&quot;),          SCI_PAGEDOWNEXTEND,          false, false, true,  VK_NEXT,     0},
463  	{TEXT(&quot;SCI_PAGEDOWNRECTEXTEND&quot;),      SCI_PAGEDOWNRECTEXTEND,      false, true,  true,  VK_NEXT,     0},
464  	{TEXT(&quot;SCI_STUTTEREDPAGEUP&quot;),         SCI_STUTTEREDPAGEUP,         false, false, false, 0,           0},
465  	{TEXT(&quot;SCI_STUTTEREDPAGEUPEXTEND&quot;),   SCI_STUTTEREDPAGEUPEXTEND,   false, false, false, 0,           0},
466  	{TEXT(&quot;SCI_STUTTEREDPAGEDOWN&quot;),       SCI_STUTTEREDPAGEDOWN,       false, false, false, 0,           0},
467  	{TEXT(&quot;SCI_STUTTEREDPAGEDOWNEXTEND&quot;), SCI_STUTTEREDPAGEDOWNEXTEND, false, false, false, 0,           0},
468  	{TEXT(&quot;SCI_DELETEBACK&quot;),              SCI_DELETEBACK,              false, false, false, VK_BACK,     0},
469  	{TEXT(&quot;&quot;),                            SCI_DELETEBACK,              false, false, true,  VK_BACK,     0},
470  	{TEXT(&quot;SCI_DELETEBACKNOTLINE&quot;),       SCI_DELETEBACKNOTLINE,       false, false, false, 0,           0},
471  	{TEXT(&quot;SCI_DELWORDLEFT&quot;),             SCI_DELWORDLEFT,             true,  false, false, VK_BACK,     0},
472  	{TEXT(&quot;SCI_DELWORDRIGHT&quot;),            SCI_DELWORDRIGHT,            true,  false, false, VK_DELETE,   0},
473  	{TEXT(&quot;SCI_DELLINELEFT&quot;),             SCI_DELLINELEFT,             true,  false, true,  VK_BACK,     0},
474  	{TEXT(&quot;SCI_DELLINERIGHT&quot;),            SCI_DELLINERIGHT,            true,  false, true,  VK_DELETE,   0},
475  	{TEXT(&quot;SCI_LINEDELETE&quot;),              SCI_LINEDELETE,              true,  false, true,  VK_L,        0},
476  	{TEXT(&quot;SCI_LINECUT&quot;),                 SCI_LINECUT,                 true,  false, false, VK_L,        0},
477  	{TEXT(&quot;SCI_LINECOPY&quot;),                SCI_LINECOPY,                true,  false, true,  VK_X,        0},
478  	{TEXT(&quot;SCI_LINETRANSPOSE&quot;),           SCI_LINETRANSPOSE,           true,  false, false, VK_T,        0},
479  	{TEXT(&quot;SCI_LINEDUPLICATE&quot;),           SCI_LINEDUPLICATE,           false, false, false, 0,           0},
480  	{TEXT(&quot;SCI_CANCEL&quot;),                  SCI_CANCEL,                  false, false, false, VK_ESCAPE,   0},
481  	{TEXT(&quot;SCI_SWAPMAINANCHORCARET&quot;),     SCI_SWAPMAINANCHORCARET,     false, false, false, 0,           0},
482  	{TEXT(&quot;SCI_ROTATESELECTION&quot;),         SCI_ROTATESELECTION,         false, false, false, 0,           0}
483  };
484  #define NONEEDSHORTCUTSXMLBACKUP_FILENAME L&quot;v852NoNeedShortcutsBackup.xml&quot;
485  #define SHORTCUTSXML_FILENAME L&quot;shortcuts.xml&quot;
486  typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
487  int strVal(const TCHAR *str, int base)
488  {
489  	if (!str) return -1;
490  	if (!str[0]) return 0;
491  	TCHAR *finStr;
492  	int result = wcstol(str, &amp;finStr, base);
493  	if (*finStr != &#x27;\0&#x27;)
494  		return -1;
495  	return result;
496  }
497  int decStrVal(const TCHAR *str)
498  {
499  	return strVal(str, 10);
500  }
501  int hexStrVal(const TCHAR *str)
502  {
503  	return strVal(str, 16);
504  }
505  int getKwClassFromName(const TCHAR *str)
506  {
507  	if (!lstrcmp(TEXT(&quot;instre1&quot;), str)) return LANG_INDEX_INSTR;
508  	if (!lstrcmp(TEXT(&quot;instre2&quot;), str)) return LANG_INDEX_INSTR2;
509  	if (!lstrcmp(TEXT(&quot;type1&quot;), str)) return LANG_INDEX_TYPE;
510  	if (!lstrcmp(TEXT(&quot;type2&quot;), str)) return LANG_INDEX_TYPE2;
511  	if (!lstrcmp(TEXT(&quot;type3&quot;), str)) return LANG_INDEX_TYPE3;
512  	if (!lstrcmp(TEXT(&quot;type4&quot;), str)) return LANG_INDEX_TYPE4;
513  	if (!lstrcmp(TEXT(&quot;type5&quot;), str)) return LANG_INDEX_TYPE5;
514  	if (!lstrcmp(TEXT(&quot;type6&quot;), str)) return LANG_INDEX_TYPE6;
515  	if (!lstrcmp(TEXT(&quot;type7&quot;), str)) return LANG_INDEX_TYPE7;
516  	if ((str[1] == &#x27;\0&#x27;) &amp;&amp; (str[0] &gt;= &#x27;0&#x27;) &amp;&amp; (str[0] &lt;= &#x27;8&#x27;)) 
517  		return str[0] - &#x27;0&#x27;;
518  	return -1;
519  }
520  } 
521  void cutString(const TCHAR* str2cut, vector&lt;generic_string&gt;&amp; patternVect)
522  {
523  	if (str2cut == nullptr) return;
524  	const TCHAR *pBegin = str2cut;
525  	const TCHAR *pEnd = pBegin;
526  	while (*pEnd != &#x27;\0&#x27;)
527  	{
528  		if (_istspace(*pEnd))
529  		{
530  			if (pBegin != pEnd)
531  				patternVect.emplace_back(pBegin, pEnd);
532  			pBegin = pEnd + 1;
533  		}
534  		++pEnd;
535  	}
536  	if (pBegin != pEnd)
537  		patternVect.emplace_back(pBegin, pEnd);
538  }
539  void cutStringBy(const TCHAR* str2cut, vector&lt;generic_string&gt;&amp; patternVect, char byChar, bool allowEmptyStr)
540  {
541  	if (str2cut == nullptr) return;
542  	const TCHAR* pBegin = str2cut;
543  	const TCHAR* pEnd = pBegin;
544  	while (*pEnd != &#x27;\0&#x27;)
545  	{
546  		if (*pEnd == byChar)
547  		{
548  			if (allowEmptyStr)
549  				patternVect.emplace_back(pBegin, pEnd);
550  			else if (pBegin != pEnd)
551  				patternVect.emplace_back(pBegin, pEnd);
552  			pBegin = pEnd + 1;
553  		}
554  		++pEnd;
555  	}
556  	if (allowEmptyStr)
557  		patternVect.emplace_back(pBegin, pEnd);
558  	else if (pBegin != pEnd)
559  		patternVect.emplace_back(pBegin, pEnd);
560  }
561  std::wstring LocalizationSwitcher::getLangFromXmlFileName(const wchar_t *fn) const
562  {
563  	size_t nbItem = sizeof(localizationDefs)/sizeof(LocalizationSwitcher::LocalizationDefinition);
564  	for (size_t i = 0 ; i &lt; nbItem ; ++i)
565  	{
566  		if (0 == wcsicmp(fn, localizationDefs[i]._xmlFileName))
567  			return localizationDefs[i]._langName;
568  	}
569  	return std::wstring();
570  }
571  std::wstring LocalizationSwitcher::getXmlFilePathFromLangName(const wchar_t *langName) const
572  {
573  	for (size_t i = 0, len = _localizationList.size(); i &lt; len ; ++i)
574  	{
575  		if (0 == wcsicmp(langName, _localizationList[i].first.c_str()))
576  			return _localizationList[i].second;
577  	}
578  	return std::wstring();
579  }
580  bool LocalizationSwitcher::addLanguageFromXml(const std::wstring&amp; xmlFullPath)
581  {
582  	wchar_t * fn = ::PathFindFileNameW(xmlFullPath.c_str());
583  	wstring foundLang = getLangFromXmlFileName(fn);
584  	if (!foundLang.empty())
585  	{
586  		_localizationList.push_back(pair&lt;wstring, wstring&gt;(foundLang, xmlFullPath));
587  		return true;
588  	}
589  	return false;
590  }
591  bool LocalizationSwitcher::switchToLang(const wchar_t *lang2switch) const
592  {
593  	wstring langPath = getXmlFilePathFromLangName(lang2switch);
594  	if (langPath.empty())
595  		return false;
596  	return ::CopyFileW(langPath.c_str(), _nativeLangPath.c_str(), FALSE) != FALSE;
597  }
598  generic_string ThemeSwitcher::getThemeFromXmlFileName(const TCHAR *xmlFullPath) const
599  {
600  	if (!xmlFullPath || !xmlFullPath[0])
601  		return generic_string();
602  	generic_string fn(::PathFindFileName(xmlFullPath));
603  	PathRemoveExtension(const_cast&lt;TCHAR *&gt;(fn.c_str()));
604  	return fn;
605  }
606  int DynamicMenu::getTopLevelItemNumber() const
607  {
608  	int nb = 0;
609  	generic_string previousFolderName;
610  	for (const MenuItemUnit&amp; i : _menuItems)
611  	{
612  		if (i._parentFolderName.empty())
613  		{
614  			++nb;
615  		}
616  		else
617  		{
618  			if (previousFolderName.empty())
619  			{
620  				++nb;
621  				previousFolderName = i._parentFolderName;
622  			}
623  			else 
624  			{
625  				if (i._parentFolderName.empty())
626  				{
627  					++nb;
628  					previousFolderName = i._parentFolderName;
629  				}
630  				else if (previousFolderName == i._parentFolderName)
631  				{
632  				}
633  				else
634  				{
635  					++nb;
636  					previousFolderName = i._parentFolderName;
637  				}
638  			}
639  		}
640  	}
641  	return nb;
642  }
643  bool DynamicMenu::attach(HMENU hMenu, unsigned int posBase, int lastCmd, const generic_string&amp; lastCmdLabel)
644  {
645  	if (!hMenu) return false;
646  	_hMenu = hMenu;
647  	_posBase = posBase;
648  	_lastCmd = lastCmd;
649  	_lastCmdLabel = lastCmdLabel;
650  	return createMenu();
651  }
652  bool DynamicMenu::clearMenu() const
653  {
654  	if (!_hMenu) return false;
655  	int nbTopItem = getTopLevelItemNumber();
656  	for (int i = nbTopItem + 1; i &gt;= 0 ; --i)
657  	{
658  		::DeleteMenu(_hMenu, static_cast&lt;int32_t&gt;(_posBase) + i, MF_BYPOSITION);
659  	}
660  	return true;
661  }
662  bool DynamicMenu::createMenu() const
663  {
664  	if (!_hMenu) return false;
665  	bool lastIsSep = false;
666  	HMENU hParentFolder = NULL;
667  	generic_string currentParentFolderStr;
668  	int j = 0;
669  	size_t nb = _menuItems.size();
670  	size_t i = 0;
671  	for (; i &lt; nb; ++i)
672  	{
673  		const MenuItemUnit&amp; item = _menuItems[i];
674  		if (item._parentFolderName.empty())
675  		{
676  			currentParentFolderStr.clear();
677  			hParentFolder = NULL;
678  			j = 0;
679  		}
680  		else
681  		{
682  			if (item._parentFolderName != currentParentFolderStr)
683  			{
684  				currentParentFolderStr = item._parentFolderName;
685  				hParentFolder = ::CreateMenu();
686  				j = 0;
687  				::InsertMenu(_hMenu, static_cast&lt;UINT&gt;(_posBase + i), MF_BYPOSITION | MF_POPUP, (UINT_PTR)hParentFolder, currentParentFolderStr.c_str());
688  			}
689  		}
690  		unsigned int flag = MF_BYPOSITION | ((item._cmdID == 0) ? MF_SEPARATOR : 0);
691  		if (hParentFolder)
692  		{
693  			::InsertMenu(hParentFolder, j++, flag, item._cmdID, item._itemName.c_str());
694  			lastIsSep = false;
695  		}
696  		else if ((i == 0 || i == _menuItems.size() - 1) &amp;&amp; item._cmdID == 0)
697  		{
698  			lastIsSep = true;
699  		}
700  		else if (item._cmdID != 0)
701  		{
702  			::InsertMenu(_hMenu, static_cast&lt;UINT&gt;(_posBase + i), flag, item._cmdID, item._itemName.c_str());
703  			lastIsSep = false;
704  		}
705  		else if (item._cmdID == 0 &amp;&amp; !lastIsSep)
706  		{
707  			::InsertMenu(_hMenu, static_cast&lt;int32_t&gt;(_posBase + i), flag, item._cmdID, item._itemName.c_str());
708  			lastIsSep = true;
709  		}
710  		else 
711  		{
712  			lastIsSep = true;
713  		}
714  	}
715  	if (nb &gt; 0)
716  	{
717  		::InsertMenu(_hMenu, static_cast&lt;int32_t&gt;(_posBase + i), MF_BYPOSITION | MF_SEPARATOR, 0, nullptr);
718  		::InsertMenu(_hMenu, static_cast&lt;UINT&gt;(_posBase + i + 2), MF_BYCOMMAND, _lastCmd, _lastCmdLabel.c_str());
719  	}
720  	return true;
721  }
722  winVer NppParameters::getWindowsVersion()
723  {
724  	OSVERSIONINFOEX osvi;
725  	SYSTEM_INFO si;
726  	PGNSI pGNSI;
727  	ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
728  	ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
729  	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
730  	BOOL bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *)&amp;osvi);
731  	if (!bOsVersionInfoEx)
732  	{
733  		osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
734  		if (! GetVersionEx ( (OSVERSIONINFO *) &amp;osvi) )
735  			return WV_UNKNOWN;
736  	}
737  	pGNSI = (PGNSI) GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;GetNativeSystemInfo&quot;);
738  	if (pGNSI != NULL)
739  		pGNSI(&amp;si);
740  	else
741  		GetSystemInfo(&amp;si);
742  	switch (si.wProcessorArchitecture)
743  	{
744  	case PROCESSOR_ARCHITECTURE_IA64:
745  		_platForm = PF_IA64;
746  		break;
747  	case PROCESSOR_ARCHITECTURE_AMD64:
748  		_platForm = PF_X64;
749  		break;
750  	case PROCESSOR_ARCHITECTURE_INTEL:
751  		_platForm = PF_X86;
752  		break;
753  	case PROCESSOR_ARCHITECTURE_ARM64:
754  		_platForm = PF_ARM64;
755  		break;
756  	default:
757  		_platForm = PF_UNKNOWN;
758  	}
759     switch (osvi.dwPlatformId)
760     {
761  		case VER_PLATFORM_WIN32_NT:
762  		{
763  			if (osvi.dwMajorVersion == 10 &amp;&amp; osvi.dwMinorVersion == 0 &amp;&amp; osvi.dwBuildNumber &gt;= 22000)
764  				return WV_WIN11;
765  			if (osvi.dwMajorVersion == 10 &amp;&amp; osvi.dwMinorVersion == 0)
766  				return WV_WIN10;
767  			if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 3)
768  				return WV_WIN81;
769  			if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 2)
770  				return WV_WIN8;
771  			if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 1)
772  				return WV_WIN7;
773  			if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 0)
774  				return WV_VISTA;
775  			if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 2)
776  			{
777  				if (osvi.wProductType == VER_NT_WORKSTATION &amp;&amp; si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
778  					return WV_XPX64;
779  				return WV_S2003;
780  			}
781  			if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 1)
782  				return WV_XP;
783  			if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 0)
784  				return WV_W2K;
785  			if (osvi.dwMajorVersion &lt;= 4)
786  				return WV_NT;
787  			break;
788  		}
789  		case VER_PLATFORM_WIN32_WINDOWS:
790  		{
791  			if (osvi.dwMajorVersion == 4 &amp;&amp; osvi.dwMinorVersion == 0)
792  				return WV_95;
793  			if (osvi.dwMajorVersion == 4 &amp;&amp; osvi.dwMinorVersion == 10)
794  				return WV_98;
795  			if (osvi.dwMajorVersion == 4 &amp;&amp; osvi.dwMinorVersion == 90)
796  				return WV_ME;
797  			break;
798  		}
799  		case VER_PLATFORM_WIN32s:
800  			return WV_WIN32S;
801  		default:
802  			return WV_UNKNOWN;
803     }
804     return WV_UNKNOWN;
805  }
806  NppParameters::NppParameters()
807  {
808  	_winVersion = getWindowsVersion();
809  	TCHAR nppPath[MAX_PATH];
810  	::GetModuleFileName(NULL, nppPath, MAX_PATH);
811  	PathRemoveFileSpec(nppPath);
812  	_nppPath = nppPath;
813  	TCHAR curDir[MAX_PATH];
814  	::GetCurrentDirectory(MAX_PATH, curDir);
815  	_currentDirectory = curDir;
816  	_appdataNppDir.clear();
817  	generic_string notepadStylePath(_nppPath);
818  	pathAppend(notepadStylePath, notepadStyleFile);
819  	_asNotepadStyle = (PathFileExists(notepadStylePath.c_str()) == TRUE);
820  	initMenuKeys();
821  	initScintillaKeys();
822  }
823  NppParameters::~NppParameters()
824  {
825  	for (int i = 0 ; i &lt; _nbLang ; ++i)
826  		delete _langList[i];
827  	for (int i = 0 ; i &lt; _nbRecentFile ; ++i)
828  		delete _LRFileList[i];
829  	for (int i = 0 ; i &lt; _nbUserLang ; ++i)
830  		delete _userLangArray[i];
831  	for (std::vector&lt;TiXmlDocument *&gt;::iterator it = _pXmlExternalLexerDoc.begin(), end = _pXmlExternalLexerDoc.end(); it != end; ++it )
832  		delete (*it);
833  	_pXmlExternalLexerDoc.clear();
834  }
835  bool NppParameters::reloadStylers(const TCHAR* stylePath)
836  {
837  	delete _pXmlUserStylerDoc;
838  	const TCHAR* stylePathToLoad = stylePath != nullptr ? stylePath : _stylerPath.c_str();
839  	_pXmlUserStylerDoc = new TiXmlDocument(stylePathToLoad);
840  	bool loadOkay = _pXmlUserStylerDoc-&gt;LoadFile();
841  	if (!loadOkay)
842  	{
843  		if (!_pNativeLangSpeaker)
844  		{
845  			::MessageBox(NULL, stylePathToLoad, TEXT(&quot;Load stylers.xml failed&quot;), MB_OK);
846  		}
847  		else
848  		{
849  			_pNativeLangSpeaker-&gt;messageBox(&quot;LoadStylersFailed&quot;,
850  				NULL,
851  				TEXT(&quot;Load \&quot;$STR_REPLACE$\&quot; failed!&quot;),
852  				TEXT(&quot;Load stylers.xml failed&quot;),
853  				MB_OK,
854  				0,
855  				stylePathToLoad);
856  		}
857  		delete _pXmlUserStylerDoc;
858  		_pXmlUserStylerDoc = NULL;
859  		return false;
860  	}
861  	_lexerStylerVect.clear();
862  	_widgetStyleArray.clear();
863  	getUserStylersFromXmlTree();
864  	for ( size_t i = 0; i &lt; getExternalLexerDoc()-&gt;size(); ++i)
865  	{
866  		getExternalLexerFromXmlTree( getExternalLexerDoc()-&gt;at(i) );
867  	}
868  	return true;
869  }
870  bool NppParameters::reloadLang()
871  {
872  	generic_string nativeLangPath(_localizationSwitcher._nativeLangPath);
873  	if (!PathFileExists(nativeLangPath.c_str()))
874  	{
875  		nativeLangPath = _nppPath;
876  		pathAppend(nativeLangPath, generic_string(TEXT(&quot;nativeLang.xml&quot;)));
877  		if (!PathFileExists(nativeLangPath.c_str()))
878  			return false;
879  	}
880  	delete _pXmlNativeLangDocA;
881  	_pXmlNativeLangDocA = new TiXmlDocumentA();
882  	bool loadOkay = _pXmlNativeLangDocA-&gt;LoadUnicodeFilePath(nativeLangPath.c_str());
883  	if (!loadOkay)
884  	{
885  		delete _pXmlNativeLangDocA;
886  		_pXmlNativeLangDocA = nullptr;
887  		return false;
888  	}
889  	return loadOkay;
890  }
891  generic_string NppParameters::getSpecialFolderLocation(int folderKind)
892  {
893  	TCHAR path[MAX_PATH];
894  	const HRESULT specialLocationResult = SHGetFolderPath(nullptr, folderKind, nullptr, SHGFP_TYPE_CURRENT, path);
895  	generic_string result;
896  	if (SUCCEEDED(specialLocationResult))
897  	{
898  		result = path;
899  	}
900  	return result;
901  }
902  generic_string NppParameters::getSettingsFolder()
903  {
904  	if (_isLocal)
905  		return _nppPath;
906  	generic_string settingsFolderPath = getSpecialFolderLocation(CSIDL_APPDATA);
907  	if (settingsFolderPath.empty())
908  		return _nppPath;
909  	pathAppend(settingsFolderPath, TEXT(&quot;Notepad++&quot;));
910  	return settingsFolderPath;
911  }
912  bool NppParameters::load()
913  {
914  	L_END = L_EXTERNAL;
915  	bool isAllLaoded = true;
916  	_isx64 = sizeof(void *) == 8;
917  	generic_string localConfPath(_nppPath);
918  	pathAppend(localConfPath, localConfFile);
919  	_isLocal = (PathFileExists(localConfPath.c_str()) == TRUE);
920  	if (_isLocal)
921  	{
922  		if (_winVersion &gt;= WV_VISTA)
923  		{
924  			generic_string progPath = getSpecialFolderLocation(CSIDL_PROGRAM_FILES);
925  			TCHAR nppDirLocation[MAX_PATH];
926  			wcscpy_s(nppDirLocation, _nppPath.c_str());
927  			::PathRemoveFileSpec(nppDirLocation);
928  			if  (progPath == nppDirLocation)
929  				_isLocal = false;
930  		}
931  	}
932  	_pluginRootDir = _nppPath;
933  	pathAppend(_pluginRootDir, TEXT(&quot;plugins&quot;));
934  	generic_string nppPluginRootParent;
935  	if (_isLocal)
936  	{
937  		_userPath = nppPluginRootParent = _nppPath;
938  		_userPluginConfDir = _pluginRootDir;
939  		pathAppend(_userPluginConfDir, TEXT(&quot;Config&quot;));
940  	}
941  	else
942  	{
943  		_userPath = getSpecialFolderLocation(CSIDL_APPDATA);
944  		pathAppend(_userPath, TEXT(&quot;Notepad++&quot;));
945  		if (!PathFileExists(_userPath.c_str()))
946  			::CreateDirectory(_userPath.c_str(), NULL);
947  		_appdataNppDir = _userPluginConfDir = _userPath;
948  		pathAppend(_userPluginConfDir, TEXT(&quot;plugins&quot;));
949  		if (!PathFileExists(_userPluginConfDir.c_str()))
950  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
951  		pathAppend(_userPluginConfDir, TEXT(&quot;Config&quot;));
952  		if (!PathFileExists(_userPluginConfDir.c_str()))
953  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
954  		setElevationRequired(true);
955  	}
956  	_pluginConfDir = _pluginRootDir; 
957  	pathAppend(_pluginConfDir, TEXT(&quot;Config&quot;));
958  	if (!PathFileExists(nppPluginRootParent.c_str()))
959  		::CreateDirectory(nppPluginRootParent.c_str(), NULL);
960  	if (!PathFileExists(_pluginRootDir.c_str()))
961  		::CreateDirectory(_pluginRootDir.c_str(), NULL);
962  	_sessionPath = _userPath; 
963  	generic_string cloudChoicePath{_userPath};
964  	cloudChoicePath += TEXT(&quot;\\cloud\\choice&quot;);
965  	_isCloud = (::PathFileExists(cloudChoicePath.c_str()) == TRUE);
966  	if (_isCloud)
967  	{
968  		std::string cloudChoiceStr = getFileContent(cloudChoicePath.c_str());
969  		WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
970  		std::wstring cloudChoiceStrW = wmc.char2wchar(cloudChoiceStr.c_str(), SC_CP_UTF8);
971  		if (!cloudChoiceStrW.empty() &amp;&amp; ::PathFileExists(cloudChoiceStrW.c_str()))
972  		{
973  			_userPath = cloudChoiceStrW;
974  			_nppGUI._cloudPath = cloudChoiceStrW;
975  			_initialCloudChoice = _nppGUI._cloudPath;
976  		}
977  		else
978  		{
979  			_isCloud = false;
980  		}
981  	}
982  	if (!_cmdSettingsDir.empty())
983  	{
984  		if (!::PathIsDirectory(_cmdSettingsDir.c_str()))
985  		{
986  			generic_string errMsg = TEXT(&quot;The given path\r&quot;);
987  			errMsg += _cmdSettingsDir;
988  			errMsg += TEXT(&quot;\nvia command line \&quot;-settingsDir=\&quot; is not a valid directory.\rThis argument will be ignored.&quot;);
989  			::MessageBox(NULL, errMsg.c_str(), TEXT(&quot;Invalid directory&quot;), MB_OK);
990  		}
991  		else
992  		{
993  			_userPath = _cmdSettingsDir;
994  			_sessionPath = _userPath; 
995  		}
996  	}
997  	generic_string langs_xml_path(_userPath);
998  	pathAppend(langs_xml_path, TEXT(&quot;langs.xml&quot;));
999  	BOOL doRecover = FALSE;
1000  	if (::PathFileExists(langs_xml_path.c_str()))
1001  	{
1002  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
1003  		if (GetFileAttributesEx(langs_xml_path.c_str(), GetFileExInfoStandard, &amp;attributes) != 0)
1004  		{
1005  			if (attributes.nFileSizeLow == 0 &amp;&amp; attributes.nFileSizeHigh == 0)
1006  			{
1007  				if (_pNativeLangSpeaker)
1008  				{
1009  					doRecover = _pNativeLangSpeaker-&gt;messageBox(&quot;LoadLangsFailed&quot;,
1010  						NULL,
1011  						TEXT(&quot;Load langs.xml failed!\rDo you want to recover your langs.xml?&quot;),
1012  						TEXT(&quot;Configurator&quot;),
1013  						MB_YESNO);
1014  				}
1015  				else
1016  				{
1017  					doRecover = ::MessageBox(NULL, TEXT(&quot;Load langs.xml failed!\rDo you want to recover your langs.xml?&quot;), TEXT(&quot;Configurator&quot;), MB_YESNO);
1018  				}
1019  			}
1020  		}
1021  	}
1022  	else
1023  		doRecover = true;
1024  	if (doRecover)
1025  	{
1026  		generic_string srcLangsPath(_nppPath);
1027  		pathAppend(srcLangsPath, TEXT(&quot;langs.model.xml&quot;));
1028  		::CopyFile(srcLangsPath.c_str(), langs_xml_path.c_str(), FALSE);
1029  	}
1030  	_pXmlDoc = new TiXmlDocument(langs_xml_path);
1031  	bool loadOkay = _pXmlDoc-&gt;LoadFile();
1032  	if (!loadOkay)
1033  	{
1034  		if (_pNativeLangSpeaker)
1035  		{
1036  			_pNativeLangSpeaker-&gt;messageBox(&quot;LoadLangsFailedFinal&quot;,
1037  				NULL,
1038  				TEXT(&quot;Load langs.xml failed!&quot;),
1039  				TEXT(&quot;Configurator&quot;),
1040  				MB_OK);
1041  		}
1042  		else
1043  		{
1044  			::MessageBox(NULL, TEXT(&quot;Load langs.xml failed!&quot;), TEXT(&quot;Configurator&quot;), MB_OK);
1045  		}
1046  		delete _pXmlDoc;
1047  		_pXmlDoc = nullptr;
1048  		isAllLaoded = false;
1049  	}
1050  	else
1051  		getLangKeywordsFromXmlTree();
1052  	generic_string configPath(_userPath);
1053  	pathAppend(configPath, TEXT(&quot;config.xml&quot;));
1054  	generic_string srcConfigPath(_nppPath);
1055  	pathAppend(srcConfigPath, TEXT(&quot;config.model.xml&quot;));
1056  	if (!::PathFileExists(configPath.c_str()))
1057  		::CopyFile(srcConfigPath.c_str(), configPath.c_str(), FALSE);
1058  	_pXmlUserDoc = new TiXmlDocument(configPath);
1059  	loadOkay = _pXmlUserDoc-&gt;LoadFile();
1060  	if (!loadOkay)
1061  	{
1062  		TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(&quot;1.0&quot;), TEXT(&quot;UTF-8&quot;), TEXT(&quot;&quot;));
1063  		_pXmlUserDoc-&gt;LinkEndChild(decl);
1064  	}
1065  	else
1066  	{
1067  		getUserParametersFromXmlTree();
1068  	}
1069  	_stylerPath = _userPath;
1070  	pathAppend(_stylerPath, TEXT(&quot;stylers.xml&quot;));
1071  	if (!PathFileExists(_stylerPath.c_str()))
1072  	{
1073  		generic_string srcStylersPath(_nppPath);
1074  		pathAppend(srcStylersPath, TEXT(&quot;stylers.model.xml&quot;));
1075  		::CopyFile(srcStylersPath.c_str(), _stylerPath.c_str(), TRUE);
1076  	}
1077  	if (_nppGUI._themeName.empty() || (!PathFileExists(_nppGUI._themeName.c_str())))
1078  		_nppGUI._themeName.assign(_stylerPath);
1079  	_pXmlUserStylerDoc = new TiXmlDocument(_nppGUI._themeName.c_str());
1080  	loadOkay = _pXmlUserStylerDoc-&gt;LoadFile();
1081  	if (!loadOkay)
1082  	{
1083  		if (_pNativeLangSpeaker)
1084  		{
1085  			_pNativeLangSpeaker-&gt;messageBox(&quot;LoadStylersFailed&quot;,
1086  				NULL,
1087  				TEXT(&quot;Load \&quot;$STR_REPLACE$\&quot; failed!&quot;),
1088  				TEXT(&quot;Load stylers.xml failed&quot;),
1089  				MB_OK,
1090  				0,
1091  				_stylerPath.c_str());
1092  		}
1093  		else
1094  		{
1095  			::MessageBox(NULL, _stylerPath.c_str(), TEXT(&quot;Load stylers.xml failed&quot;), MB_OK);
1096  		}
1097  		delete _pXmlUserStylerDoc;
1098  		_pXmlUserStylerDoc = NULL;
1099  		isAllLaoded = false;
1100  	}
1101  	else
1102  		getUserStylersFromXmlTree();
1103  	_themeSwitcher._stylesXmlPath = _stylerPath;
1104  	_themeSwitcher.addDefaultThemeFromXml(_stylerPath);
1105  	_userDefineLangsFolderPath = _userDefineLangPath = _userPath;
1106  	pathAppend(_userDefineLangPath, TEXT(&quot;userDefineLang.xml&quot;));
1107  	pathAppend(_userDefineLangsFolderPath, TEXT(&quot;userDefineLangs&quot;));
1108  	std::vector&lt;generic_string&gt; udlFiles;
1109  	getFilesInFolder(udlFiles, TEXT(&quot;*.xml&quot;), _userDefineLangsFolderPath);
1110  	_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
1111  	loadOkay = _pXmlUserLangDoc-&gt;LoadFile();
1112  	if (!loadOkay)
1113  	{
1114  		delete _pXmlUserLangDoc;
1115  		_pXmlUserLangDoc = nullptr;
1116  		isAllLaoded = false;
1117  	}
1118  	else
1119  	{
1120  		auto r = addUserDefineLangsFromXmlTree(_pXmlUserLangDoc);
1121  		if (r.second - r.first &gt; 0)
1122  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(_pXmlUserLangDoc, false, true, r));
1123  	}
1124  	for (const auto&amp; i : udlFiles)
1125  	{
1126  		auto udlDoc = new TiXmlDocument(i);
1127  		loadOkay = udlDoc-&gt;LoadFile();
1128  		if (!loadOkay)
1129  		{
1130  			delete udlDoc;
1131  		}
1132  		else
1133  		{
1134  			auto r = addUserDefineLangsFromXmlTree(udlDoc);
1135  			if (r.second - r.first &gt; 0)
1136  				_pXmlUserLangsDoc.push_back(UdlXmlFileState(udlDoc, false, false, r));
1137  		}
1138  	}
1139  	generic_string nativeLangPath;
1140  	nativeLangPath = _userPath;
1141  	pathAppend(nativeLangPath, TEXT(&quot;nativeLang.xml&quot;));
1142  	_localizationSwitcher._nativeLangPath = nativeLangPath;
1143  	if (!_startWithLocFileName.empty()) 
1144  	{
1145  		nativeLangPath = _nppPath;
1146  		pathAppend(nativeLangPath, TEXT(&quot;localization\\&quot;));
1147  		pathAppend(nativeLangPath, _startWithLocFileName);
1148  	}
1149  	else 
1150  	{
1151  		if (!PathFileExists(nativeLangPath.c_str()))
1152  		{
1153  			nativeLangPath = _nppPath;
1154  			pathAppend(nativeLangPath, TEXT(&quot;nativeLang.xml&quot;));
1155  		}
1156  	}
1157  	_pXmlNativeLangDocA = new TiXmlDocumentA();
1158  	loadOkay = _pXmlNativeLangDocA-&gt;LoadUnicodeFilePath(nativeLangPath.c_str());
1159  	if (!loadOkay)
1160  	{
1161  		delete _pXmlNativeLangDocA;
1162  		_pXmlNativeLangDocA = nullptr;
1163  		isAllLaoded = false;
1164  	}
1165  	generic_string toolbarIconsPath(_userPath);
1166  	pathAppend(toolbarIconsPath, TEXT(&quot;toolbarIcons.xml&quot;));
1167  	_pXmlToolIconsDoc = new TiXmlDocument(toolbarIconsPath);
1168  	loadOkay = _pXmlToolIconsDoc-&gt;LoadFile();
1169  	if (!loadOkay)
1170  	{
1171  		delete _pXmlToolIconsDoc;
1172  		_pXmlToolIconsDoc = nullptr;
1173  		isAllLaoded = false;
1174  	}
1175  	wstring v852NoNeedShortcutsBackup;
1176  	_shortcutsPath = v852NoNeedShortcutsBackup = _userPath;
1177  	pathAppend(_shortcutsPath, SHORTCUTSXML_FILENAME);
1178  	pathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
1179  	if (!PathFileExists(_shortcutsPath.c_str()))
1180  	{
1181  		generic_string srcShortcutsPath(_nppPath);
1182  		pathAppend(srcShortcutsPath, SHORTCUTSXML_FILENAME);
1183  		::CopyFile(srcShortcutsPath.c_str(), _shortcutsPath.c_str(), TRUE);
1184  		HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
1185  		::FlushFileBuffers(hFile);
1186  		::CloseHandle(hFile);
1187  	}
1188  	_pXmlShortcutDocA = new TiXmlDocumentA();
1189  	loadOkay = _pXmlShortcutDocA-&gt;LoadUnicodeFilePath(_shortcutsPath.c_str());
1190  	if (!loadOkay)
1191  	{
1192  		delete _pXmlShortcutDocA;
1193  		_pXmlShortcutDocA = nullptr;
1194  		isAllLaoded = false;
1195  	}
1196  	else
1197  	{
1198  		getShortcutsFromXmlTree();
1199  		getMacrosFromXmlTree();
1200  		getUserCmdsFromXmlTree();
1201  		getScintKeysFromXmlTree();
1202  	}
1203  	_contextMenuPath = _userPath;
1204  	pathAppend(_contextMenuPath, TEXT(&quot;contextMenu.xml&quot;));
1205  	if (!PathFileExists(_contextMenuPath.c_str()))
1206  	{
1207  		generic_string srcContextMenuPath(_nppPath);
1208  		pathAppend(srcContextMenuPath, TEXT(&quot;contextMenu.xml&quot;));
1209  		::CopyFile(srcContextMenuPath.c_str(), _contextMenuPath.c_str(), TRUE);
1210  	}
1211  	_pXmlContextMenuDocA = new TiXmlDocumentA();
1212  	loadOkay = _pXmlContextMenuDocA-&gt;LoadUnicodeFilePath(_contextMenuPath.c_str());
1213  	if (!loadOkay)
1214  	{
1215  		delete _pXmlContextMenuDocA;
1216  		_pXmlContextMenuDocA = nullptr;
1217  		isAllLaoded = false;
1218  	}
1219  	_tabContextMenuPath = _userPath;
1220  	pathAppend(_tabContextMenuPath, TEXT(&quot;tabContextMenu.xml&quot;));
1221  	_pXmlTabContextMenuDocA = new TiXmlDocumentA();
1222  	loadOkay = _pXmlTabContextMenuDocA-&gt;LoadUnicodeFilePath(_tabContextMenuPath.c_str());
1223  	if (!loadOkay)
1224  	{
1225  		delete _pXmlTabContextMenuDocA;
1226  		_pXmlTabContextMenuDocA = nullptr;
1227  	}
1228  	pathAppend(_sessionPath, TEXT(&quot;session.xml&quot;));
1229  	const NppGUI &amp; nppGUI = (NppParameters::getInstance()).getNppGUI();
1230  	if (nppGUI._rememberLastSession)
1231  	{
1232  		TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(_sessionPath);
1233  		loadOkay = pXmlSessionDoc-&gt;LoadFile();
1234  		if (!loadOkay)
1235  			isAllLaoded = false;
1236  		else
1237  			getSessionFromXmlTree(pXmlSessionDoc, _session);
1238  		delete pXmlSessionDoc;
1239  		for (size_t i = 0, len = _pXmlExternalLexerDoc.size() ; i &lt; len ; ++i)
1240  			if (_pXmlExternalLexerDoc[i])
1241  				delete _pXmlExternalLexerDoc[i];
1242  	}
1243  	generic_string enableSelectFgColorPath = _userPath;
1244  	pathAppend(enableSelectFgColorPath, TEXT(&quot;enableSelectFgColor.xml&quot;));
1245  	if (PathFileExists(enableSelectFgColorPath.c_str()))
1246  	{
1247  		_isSelectFgColorEnabled = true;
1248  	}
1249  	generic_string filePath, filePath2, issueFileName;
1250  	filePath = _nppPath;
1251  	issueFileName = nppLogNetworkDriveIssue;
1252  	issueFileName += TEXT(&quot;.xml&quot;);
1253  	pathAppend(filePath, issueFileName);
1254  	_doNppLogNetworkDriveIssue = (PathFileExists(filePath.c_str()) == TRUE);
1255  	if (!_doNppLogNetworkDriveIssue)
1256  	{
1257  		filePath2 = _userPath;
1258  		pathAppend(filePath2, issueFileName);
1259  		_doNppLogNetworkDriveIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1260  	}
1261  	filePath = _nppPath;
1262  	issueFileName = nppLogNulContentCorruptionIssue;
1263  	issueFileName += TEXT(&quot;.xml&quot;);
1264  	pathAppend(filePath, issueFileName);
1265  	_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath.c_str()) == TRUE);
1266  	if (!_doNppLogNulContentCorruptionIssue)
1267  	{
1268  		filePath2 = _userPath;
1269  		pathAppend(filePath2, issueFileName);
1270  		_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1271  	}
1272  	return isAllLaoded;
1273  }
1274  void NppParameters::destroyInstance()
1275  {
1276  	delete _pXmlDoc;
1277  	delete _pXmlUserDoc;
1278  	delete _pXmlUserStylerDoc;
1279  	for (auto&amp; l : _pXmlUserLangsDoc)
1280  	{
1281  		delete l._udlXmlDoc;
1282  	}
1283  	delete _pXmlNativeLangDocA;
1284  	delete _pXmlToolIconsDoc;
1285  	delete _pXmlShortcutDocA;
1286  	delete _pXmlContextMenuDocA;
1287  	delete _pXmlTabContextMenuDocA;
1288  	delete 	getInstancePointer();
1289  }
1290  void NppParameters::saveConfig_xml()
1291  {
1292  	if (_pXmlUserDoc)
1293  		_pXmlUserDoc-&gt;SaveFile();
1294  }
1295  void NppParameters::setWorkSpaceFilePath(int i, const TCHAR* wsFile)
1296  {
1297  	if (i &lt; 0 || i &gt; 2 || !wsFile)
1298  		return;
1299  	_workSpaceFilePathes[i] = wsFile;
1300  }
1301  void NppParameters::removeTransparent(HWND hwnd)
1302  {
1303  	if (hwnd != nullptr)
1304  		::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) &amp; ~WS_EX_LAYERED);
1305  }
1306  void NppParameters::SetTransparent(HWND hwnd, int percent)
1307  {
1308  	::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);
1309  	if (percent &gt; 255)
1310  		percent = 255;
1311  	else if (percent &lt; 0)
1312  		percent = 0;
1313  	::SetLayeredWindowAttributes(hwnd, 0, static_cast&lt;BYTE&gt;(percent), LWA_ALPHA);
1314  }
1315  bool NppParameters::isExistingExternalLangName(const char* newName) const
1316  {
1317  	if ((!newName) || (!newName[0]))
1318  		return true;
1319  	for (int i = 0 ; i &lt; _nbExternalLang ; ++i)
1320  	{
1321  		if (_externalLangArray[i]-&gt;_name == newName)
1322  			return true;
1323  	}
1324  	return false;
1325  }
1326  const TCHAR* NppParameters::getUserDefinedLangNameFromExt(TCHAR *ext, TCHAR *fullName) const
1327  {
1328  	if ((!ext) || (!ext[0]))
1329  		return nullptr;
1330  	std::vector&lt;generic_string&gt; extVect;
1331  	int iMatched = -1;
1332  	for (int i = 0 ; i &lt; _nbUserLang ; ++i)
1333  	{
1334  		extVect.clear();
1335  		cutString(_userLangArray[i]-&gt;_ext.c_str(), extVect);
1336  		for (size_t j = 0, len = extVect.size(); j &lt; len; ++j)
1337  		{
1338  			if (!wcsicmp(extVect[j].c_str(), ext) || (wcschr(fullName, &#x27;.&#x27;) &amp;&amp; !wcsicmp(extVect[j].c_str(), fullName)))
1339  			{
1340  				iMatched = i;
1341  				if (((NppDarkMode::isEnabled() &amp;&amp; _userLangArray[i]-&gt;_isDarkModeTheme)) ||
1342  					((!NppDarkMode::isEnabled() &amp;&amp; !_userLangArray[i]-&gt;_isDarkModeTheme)))
1343  					return _userLangArray[i]-&gt;_name.c_str();
1344  			}
1345  		}
1346  	}
1347  	if (iMatched &gt;= 0)
1348  	{
1349  		return _userLangArray[iMatched]-&gt;_name.c_str();
1350  	}
1351  	return nullptr;
1352  }
1353  int NppParameters::getExternalLangIndexFromName(const TCHAR* externalLangName) const
1354  {
1355  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1356  	for (int i = 0 ; i &lt; _nbExternalLang ; ++i)
1357  	{
1358  		if (!lstrcmp(externalLangName, wmc.char2wchar(_externalLangArray[i]-&gt;_name.c_str(), CP_ACP)))
1359  			return i;
1360  	}
1361  	return -1;
1362  }
1363  UserLangContainer* NppParameters::getULCFromName(const TCHAR *userLangName)
1364  {
1365  	for (int i = 0 ; i &lt; _nbUserLang ; ++i)
1366  	{
1367  		if (0 == lstrcmp(userLangName, _userLangArray[i]-&gt;_name.c_str()))
1368  			return _userLangArray[i];
1369  	}
1370  	return nullptr;
1371  }
1372  COLORREF NppParameters::getCurLineHilitingColour()
1373  {
1374  	const Style * pStyle = _widgetStyleArray.findByName(TEXT(&quot;Current line background colour&quot;));
1375  	if (!pStyle)
1376  		return COLORREF(-1);
1377  	return pStyle-&gt;_bgColor;
1378  }
1379  void NppParameters::setCurLineHilitingColour(COLORREF colour2Set)
1380  {
1381  	Style * pStyle = _widgetStyleArray.findByName(TEXT(&quot;Current line background colour&quot;));
1382  	if (!pStyle)
1383  		return;
1384  	pStyle-&gt;_bgColor = colour2Set;
1385  }
1386  static int CALLBACK EnumFontFamExProc(const LOGFONT* lpelfe, const TEXTMETRIC*, DWORD, LPARAM lParam)
1387  {
1388  	std::vector&lt;generic_string&gt;&amp; strVect = *(std::vector&lt;generic_string&gt; *)lParam;
1389  	const int32_t vectSize = static_cast&lt;int32_t&gt;(strVect.size());
1390  	const TCHAR* lfFaceName = ((ENUMLOGFONTEX*)lpelfe)-&gt;elfLogFont.lfFaceName;
1391  	for (int i = vectSize - 1 ; i &gt;= 0 ; i--)
1392  	{
1393  		if (0 == lstrcmp(strVect[i].c_str(), lfFaceName))
1394  			return 1;	
1395  	}
1396  	strVect.push_back(lfFaceName);
1397  	return 1; 
1398  }
1399  void NppParameters::setFontList(HWND hWnd)
1400  {
1401  	LOGFONT lf{};
1402  	_fontlist.clear();
1403  	_fontlist.reserve(64); 
1404  	_fontlist.push_back(generic_string());
1405  	lf.lfCharSet = DEFAULT_CHARSET;
1406  	lf.lfFaceName[0]=&#x27;\0&#x27;;
1407  	lf.lfPitchAndFamily = 0;
1408  	HDC hDC = ::GetDC(hWnd);
1409  	::EnumFontFamiliesEx(hDC, &amp;lf, EnumFontFamExProc, reinterpret_cast&lt;LPARAM&gt;(&amp;_fontlist), 0);
1410  }
1411  bool NppParameters::isInFontList(const generic_string&amp; fontName2Search) const
1412  {
1413  	if (fontName2Search.empty())
1414  		return false;
1415  	for (size_t i = 0, len = _fontlist.size(); i &lt; len; i++)
1416  	{
1417  		if (_fontlist[i] == fontName2Search)
1418  			return true;
1419  	}
1420  	return false;
1421  }
1422  LOGFONT NppParameters::getDefaultGUIFont(DefaultFontType type)
1423  {
1424  	LOGFONT lf{};
1425  	NONCLIENTMETRICS ncm{};
1426  	ncm.cbSize = sizeof(NONCLIENTMETRICS);
1427  	if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &amp;ncm, 0) != FALSE)
1428  	{
1429  		switch (type)
1430  		{
1431  			case DefaultFontType::menu:
1432  			{
1433  				lf = ncm.lfMenuFont;
1434  				break;
1435  			}
1436  			case DefaultFontType::status:
1437  			{
1438  				lf = ncm.lfStatusFont;
1439  				break;
1440  			}
1441  			case DefaultFontType::caption:
1442  			{
1443  				lf = ncm.lfCaptionFont;
1444  				break;
1445  			}
1446  			case DefaultFontType::smcaption:
1447  			{
1448  				lf = ncm.lfSmCaptionFont;
1449  				break;
1450  			}
1451  			default:
1452  			{
1453  				lf = ncm.lfMessageFont;
1454  				break;
1455  			}
1456  		}
1457  	}
1458  	else 
1459  	{
1460  		auto hf = static_cast&lt;HFONT&gt;(::GetStockObject(DEFAULT_GUI_FONT));
1461  		::GetObject(hf, sizeof(LOGFONT), &amp;lf);
1462  	}
1463  	return lf;
1464  }
1465  void NppParameters::getLangKeywordsFromXmlTree()
1466  {
1467  	TiXmlNode *root =
1468  		_pXmlDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1469  		if (!root) return;
1470  	feedKeyWordsParameters(root);
1471  }
1472  void NppParameters::getExternalLexerFromXmlTree(TiXmlDocument* externalLexerDoc)
1473  {
1474  	TiXmlNode *root = externalLexerDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1475  		if (!root) return;
1476  	feedKeyWordsParameters(root);
1477  	feedStylerArray(root);
1478  }
1479  int NppParameters::addExternalLangToEnd(ExternalLangContainer * externalLang)
1480  {
1481  	_externalLangArray[_nbExternalLang] = externalLang;
1482  	++_nbExternalLang;
1483  	++L_END;
1484  	return _nbExternalLang-1;
1485  }
1486  bool NppParameters::getUserStylersFromXmlTree()
1487  {
1488  	TiXmlNode *root = _pXmlUserStylerDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1489  		if (!root) return false;
1490  	return feedStylerArray(root);
1491  }
1492  bool NppParameters::getUserParametersFromXmlTree()
1493  {
1494  	if (!_pXmlUserDoc)
1495  		return false;
1496  	TiXmlNode *root = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1497  	if (!root)
1498  		return false;
1499  	feedGUIParameters(root);
1500  	feedFileListParameters(root);
1501  	TiXmlNode *node = root-&gt;FirstChildElement(TEXT(&quot;History&quot;));
1502  	root-&gt;RemoveChild(node);
1503  	TiXmlElement HistoryNode(TEXT(&quot;History&quot;));
1504  	root-&gt;InsertEndChild(HistoryNode);
1505  	feedFindHistoryParameters(root);
1506  	feedProjectPanelsParameters(root);
1507  	feedFileBrowserParameters(root);
1508  	feedColumnEditorParameters(root);
1509  	return true;
1510  }
1511  std::pair&lt;unsigned char, unsigned char&gt; NppParameters::addUserDefineLangsFromXmlTree(TiXmlDocument *tixmldoc)
1512  {
1513  	if (!tixmldoc)
1514  		return std::make_pair(static_cast&lt;unsigned char&gt;(0), static_cast&lt;unsigned char&gt;(0));
1515  	TiXmlNode *root = tixmldoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1516  	if (!root)
1517  		return std::make_pair(static_cast&lt;unsigned char&gt;(0), static_cast&lt;unsigned char&gt;(0));
1518  	return feedUserLang(root);
1519  }
1520  bool NppParameters::getShortcutsFromXmlTree()
1521  {
1522  	if (!_pXmlShortcutDocA)
1523  		return false;
1524  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1525  	if (!root)
1526  		return false;
1527  	feedShortcut(root);
1528  	return true;
1529  }
1530  bool NppParameters::getMacrosFromXmlTree()
1531  {
1532  	if (!_pXmlShortcutDocA)
1533  		return false;
1534  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1535  	if (!root)
1536  		return false;
1537  	feedMacros(root);
1538  	return true;
1539  }
1540  bool NppParameters::getUserCmdsFromXmlTree()
1541  {
1542  	if (!_pXmlShortcutDocA)
1543  		return false;
1544  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1545  	if (!root)
1546  		return false;
1547  	feedUserCmds(root);
1548  	return true;
1549  }
1550  bool NppParameters::getPluginCmdsFromXmlTree()
1551  {
1552  	if (!_pXmlShortcutDocA)
1553  		return false;
1554  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1555  	if (!root)
1556  		return false;
1557  	feedPluginCustomizedCmds(root);
1558  	return true;
1559  }
1560  bool NppParameters::getScintKeysFromXmlTree()
1561  {
1562  	if (!_pXmlShortcutDocA)
1563  		return false;
1564  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1565  	if (!root)
1566  		return false;
1567  	feedScintKeys(root);
1568  	return true;
1569  }
1570  void NppParameters::initMenuKeys()
1571  {
1572  	int nbCommands = sizeof(winKeyDefs)/sizeof(WinMenuKeyDefinition);
1573  	WinMenuKeyDefinition wkd;
1574  	for (int i = 0; i &lt; nbCommands; ++i)
1575  	{
1576  		wkd = winKeyDefs[i];
1577  		Shortcut sc((wkd.specialName ? wstring2string(wkd.specialName, CP_UTF8).c_str() : &quot;&quot;), wkd.isCtrl, wkd.isAlt, wkd.isShift, static_cast&lt;unsigned char&gt;(wkd.vKey));
1578  		_shortcuts.push_back( CommandShortcut(sc, wkd.functionId) );
1579  	}
1580  }
1581  void NppParameters::initScintillaKeys()
1582  {
1583  	int nbCommands = sizeof(scintKeyDefs)/sizeof(ScintillaKeyDefinition);
1584  	ScintillaKeyDefinition skd;
1585  	int prevIndex = -1;
1586  	int prevID = -1;
1587  	for (int i = 0; i &lt; nbCommands; ++i)
1588  	{
1589  		skd = scintKeyDefs[i];
1590  		if (skd.functionId == prevID)
1591  		{
1592  			KeyCombo kc;
1593  			kc._isCtrl = skd.isCtrl;
1594  			kc._isAlt = skd.isAlt;
1595  			kc._isShift = skd.isShift;
1596  			kc._key = static_cast&lt;unsigned char&gt;(skd.vKey);
1597  			_scintillaKeyCommands[prevIndex].addKeyCombo(kc);
1598  		}
1599  		else
1600  		{
1601  			Shortcut s = Shortcut(wstring2string(skd.name, CP_UTF8).c_str(), skd.isCtrl, skd.isAlt, skd.isShift, static_cast&lt;unsigned char&gt;(skd.vKey));
1602  			ScintillaKeyMap sm = ScintillaKeyMap(s, skd.functionId, skd.redirFunctionId);
1603  			_scintillaKeyCommands.push_back(sm);
1604  			++prevIndex;
1605  		}
1606  		prevID = skd.functionId;
1607  	}
1608  }
1609  bool NppParameters::reloadContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu)
1610  {
1611  	_contextMenuItems.clear();
1612  	return getContextMenuFromXmlTree(mainMenuHadle, pluginsMenu);
1613  }
1614  int NppParameters::getCmdIdFromMenuEntryItemName(HMENU mainMenuHadle, const generic_string&amp; menuEntryName, const generic_string&amp; menuItemName)
1615  {
1616  	int nbMenuEntry = ::GetMenuItemCount(mainMenuHadle);
1617  	for (int i = 0; i &lt; nbMenuEntry; ++i)
1618  	{
1619  		TCHAR menuEntryString[menuItemStrLenMax];
1620  		::GetMenuString(mainMenuHadle, i, menuEntryString, menuItemStrLenMax, MF_BYPOSITION);
1621  		if (wcsicmp(menuEntryName.c_str(), purgeMenuItemString(menuEntryString).c_str()) == 0)
1622  		{
1623  			vector&lt; pair&lt;HMENU, int&gt; &gt; parentMenuPos;
1624  			HMENU topMenu = ::GetSubMenu(mainMenuHadle, i);
1625  			int maxTopMenuPos = ::GetMenuItemCount(topMenu);
1626  			HMENU currMenu = topMenu;
1627  			int currMaxMenuPos = maxTopMenuPos;
1628  			int currMenuPos = 0;
1629  			bool notFound = false;
1630  			do {
1631  				if (::GetSubMenu(currMenu, currMenuPos))
1632  				{
1633  					parentMenuPos.push_back(::make_pair(currMenu, currMenuPos));
1634  					currMenu = ::GetSubMenu(currMenu, currMenuPos);
1635  					currMenuPos = 0;
1636  					currMaxMenuPos = ::GetMenuItemCount(currMenu);
1637  				}
1638  				else
1639  				{
1640  					TCHAR cmdStr[menuItemStrLenMax];
1641  					::GetMenuString(currMenu, currMenuPos, cmdStr, menuItemStrLenMax, MF_BYPOSITION);
1642  					if (wcsicmp(menuItemName.c_str(), purgeMenuItemString(cmdStr).c_str()) == 0)
1643  					{
1644  						return ::GetMenuItemID(currMenu, currMenuPos);
1645  					}
1646  					if ((currMenuPos &gt;= currMaxMenuPos) &amp;&amp; (parentMenuPos.size() &gt; 0))
1647  					{
1648  						currMenu = parentMenuPos.back().first;
1649  						currMenuPos = parentMenuPos.back().second;
1650  						parentMenuPos.pop_back();
1651  						currMaxMenuPos = ::GetMenuItemCount(currMenu);
1652  					}
1653  					if ((currMenu == topMenu) &amp;&amp; (currMenuPos &gt;= maxTopMenuPos))
1654  					{
1655  						notFound = true;
1656  					}
1657  					else
1658  					{
1659  						++currMenuPos;
1660  					}
1661  				}
1662  			} while (!notFound);
1663  		}
1664  	}
1665  	return -1;
1666  }
1667  int NppParameters::getPluginCmdIdFromMenuEntryItemName(HMENU pluginsMenu, const generic_string&amp; pluginName, const generic_string&amp; pluginCmdName)
1668  {
1669  	int nbPlugins = ::GetMenuItemCount(pluginsMenu);
1670  	for (int i = 0; i &lt; nbPlugins; ++i)
1671  	{
1672  		TCHAR menuItemString[menuItemStrLenMax];
1673  		::GetMenuString(pluginsMenu, i, menuItemString, menuItemStrLenMax, MF_BYPOSITION);
1674  		if (wcsicmp(pluginName.c_str(), purgeMenuItemString(menuItemString).c_str()) == 0)
1675  		{
1676  			HMENU pluginMenu = ::GetSubMenu(pluginsMenu, i);
1677  			int nbPluginCmd = ::GetMenuItemCount(pluginMenu);
1678  			for (int j = 0; j &lt; nbPluginCmd; ++j)
1679  			{
1680  				TCHAR pluginCmdStr[menuItemStrLenMax];
1681  				::GetMenuString(pluginMenu, j, pluginCmdStr, menuItemStrLenMax, MF_BYPOSITION);
1682  				if (wcsicmp(pluginCmdName.c_str(), purgeMenuItemString(pluginCmdStr).c_str()) == 0)
1683  				{
1684  					return ::GetMenuItemID(pluginMenu, j);
1685  				}
1686  			}
1687  		}
1688  	}
1689  	return -1;
1690  }
1691  bool NppParameters::getContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu, bool isEditCM)
1692  {
1693  	std::vector&lt;MenuItemUnit&gt;&amp; contextMenuItems = isEditCM ? _contextMenuItems : _tabContextMenuItems;
1694  	TiXmlDocumentA* pXmlContextMenuDocA = isEditCM ? _pXmlContextMenuDocA : _pXmlTabContextMenuDocA;
1695  	std::string cmName = isEditCM ? &quot;ScintillaContextMenu&quot; : &quot;TabContextMenu&quot;;
1696  	if (!pXmlContextMenuDocA)
1697  		return false;
1698  	TiXmlNodeA *root = pXmlContextMenuDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
1699  	if (!root)
1700  		return false;
1701  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
1702  	NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
1703  	TiXmlNodeA *contextMenuRoot = root-&gt;FirstChildElement(cmName.c_str());
1704  	if (contextMenuRoot)
1705  	{
1706  		for (TiXmlNodeA *childNode = contextMenuRoot-&gt;FirstChildElement(&quot;Item&quot;);
1707  			childNode ;
1708  			childNode = childNode-&gt;NextSibling(&quot;Item&quot;) )
1709  		{
1710  			const char *folderNameDefaultA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;FolderName&quot;);
1711  			const char *folderNameTranslateID_A = (childNode-&gt;ToElement())-&gt;Attribute(&quot;TranslateID&quot;);
1712  			const char *displayAsA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;ItemNameAs&quot;);
1713  			generic_string folderName;
1714  			generic_string displayAs;
1715  			folderName = folderNameDefaultA ? wmc.char2wchar(folderNameDefaultA, SC_CP_UTF8) : TEXT(&quot;&quot;);
1716  			displayAs = displayAsA ? wmc.char2wchar(displayAsA, SC_CP_UTF8) : TEXT(&quot;&quot;);
1717  			if (folderNameTranslateID_A)
1718  			{
1719  				folderName = pNativeSpeaker-&gt;getLocalizedStrFromID(folderNameTranslateID_A, folderName);
1720  			}
1721  			int id;
1722  			const char *idStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;id&quot;, &amp;id);
1723  			if (idStr)
1724  			{
1725  				contextMenuItems.push_back(MenuItemUnit(id, displayAs.c_str(), folderName.c_str()));
1726  			}
1727  			else
1728  			{
1729  				const char *menuEntryNameA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;MenuEntryName&quot;);
1730  				const char *menuItemNameA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;MenuItemName&quot;);
1731  				generic_string menuEntryName;
1732  				generic_string menuItemName;
1733  				menuEntryName = menuEntryNameA?wmc.char2wchar(menuEntryNameA, SC_CP_UTF8):TEXT(&quot;&quot;);
1734  				menuItemName = menuItemNameA?wmc.char2wchar(menuItemNameA, SC_CP_UTF8):TEXT(&quot;&quot;);
1735  				if (!menuEntryName.empty() &amp;&amp; !menuItemName.empty())
1736  				{
1737  					int cmd = getCmdIdFromMenuEntryItemName(mainMenuHadle, menuEntryName, menuItemName);
1738  					if (cmd != -1)
1739  						contextMenuItems.push_back(MenuItemUnit(cmd, displayAs.c_str(), folderName.c_str()));
1740  				}
1741  				else
1742  				{
1743  					const char *pluginNameA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;PluginEntryName&quot;);
1744  					const char *pluginCmdNameA = (childNode-&gt;ToElement())-&gt;Attribute(&quot;PluginCommandItemName&quot;);
1745  					generic_string pluginName;
1746  					generic_string pluginCmdName;
1747  					pluginName = pluginNameA?wmc.char2wchar(pluginNameA, SC_CP_UTF8):TEXT(&quot;&quot;);
1748  					pluginCmdName = pluginCmdNameA?wmc.char2wchar(pluginCmdNameA, SC_CP_UTF8):TEXT(&quot;&quot;);
1749  					if (pluginsMenu &amp;&amp; !pluginName.empty() &amp;&amp; !pluginCmdName.empty())
1750  					{
1751  						int pluginCmdId = getPluginCmdIdFromMenuEntryItemName(pluginsMenu, pluginName, pluginCmdName);
1752  						if (pluginCmdId != -1)
1753  							contextMenuItems.push_back(MenuItemUnit(pluginCmdId, displayAs.c_str(), folderName.c_str()));
1754  					}
1755  				}
1756  			}
1757  		}
1758  	}
1759  	return true;
1760  }
1761  void NppParameters::setWorkingDir(const TCHAR * newPath)
1762  {
1763  	if (newPath &amp;&amp; newPath[0])
1764  	{
1765  		_currentDirectory = newPath;
1766  	}
1767  	else
1768  	{
1769  		if (PathFileExists(_nppGUI._defaultDirExp))
1770  			_currentDirectory = _nppGUI._defaultDirExp;
1771  		else
1772  			_currentDirectory = _nppPath.c_str();
1773  	}
1774  }
1775  bool NppParameters::loadSession(Session &amp; session, const TCHAR *sessionFileName)
1776  {
1777  	TiXmlDocument *pXmlSessionDocument = new TiXmlDocument(sessionFileName);
1778  	bool loadOkay = pXmlSessionDocument-&gt;LoadFile();
1779  	if (loadOkay)
1780  		loadOkay = getSessionFromXmlTree(pXmlSessionDocument, session);
1781  	delete pXmlSessionDocument;
1782  	return loadOkay;
1783  }
1784  bool NppParameters::getSessionFromXmlTree(TiXmlDocument *pSessionDoc, Session&amp; session)
1785  {
1786  	if (!pSessionDoc)
1787  		return false;
1788  	TiXmlNode *root = pSessionDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
1789  	if (!root)
1790  		return false;
1791  	TiXmlNode *sessionRoot = root-&gt;FirstChildElement(TEXT(&quot;Session&quot;));
1792  	if (!sessionRoot)
1793  		return false;
1794  	TiXmlElement *actView = sessionRoot-&gt;ToElement();
1795  	int index = 0;
1796  	const TCHAR *str = actView-&gt;Attribute(TEXT(&quot;activeView&quot;), &amp;index);
1797  	if (str)
1798  	{
1799  		session._activeView = index;
1800  	}
1801  	const size_t nbView = 2;
1802  	TiXmlNode *viewRoots[nbView];
1803  	viewRoots[0] = sessionRoot-&gt;FirstChildElement(TEXT(&quot;mainView&quot;));
1804  	viewRoots[1] = sessionRoot-&gt;FirstChildElement(TEXT(&quot;subView&quot;));
1805  	for (size_t k = 0; k &lt; nbView; ++k)
1806  	{
1807  		if (viewRoots[k])
1808  		{
1809  			int index2 = 0;
1810  			TiXmlElement *actIndex = viewRoots[k]-&gt;ToElement();
1811  			str = actIndex-&gt;Attribute(TEXT(&quot;activeIndex&quot;), &amp;index2);
1812  			if (str)
1813  			{
1814  				if (k == 0)
1815  					session._activeMainIndex = index2;
1816  				else 
1817  					session._activeSubIndex = index2;
1818  			}
1819  			for (TiXmlNode *childNode = viewRoots[k]-&gt;FirstChildElement(TEXT(&quot;File&quot;));
1820  				childNode ;
1821  				childNode = childNode-&gt;NextSibling(TEXT(&quot;File&quot;)) )
1822  			{
1823  				const TCHAR *fileName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;filename&quot;));
1824  				if (fileName)
1825  				{
1826  					Position position;
1827  					const TCHAR* posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;firstVisibleLine&quot;));
1828  					if (posStr)
1829  						position._firstVisibleLine = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1830  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;xOffset&quot;));
1831  					if (posStr)
1832  						position._xOffset = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1833  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;startPos&quot;));
1834  					if (posStr)
1835  						position._startPos = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1836  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;endPos&quot;));
1837  					if (posStr)
1838  						position._endPos = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1839  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;selMode&quot;));
1840  					if (posStr)
1841  						position._selMode = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1842  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;scrollWidth&quot;));
1843  					if (posStr)
1844  						position._scrollWidth = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1845  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;offset&quot;));
1846  					if (posStr)
1847  						position._offset = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1848  					posStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;wrapCount&quot;));
1849  					if (posStr)
1850  						position._wrapCount = static_cast&lt;intptr_t&gt;(_ttoi64(posStr));
1851  					MapPosition mapPosition;
1852  					const TCHAR* mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapFirstVisibleDisplayLine&quot;));
1853  					if (mapPosStr)
1854  						mapPosition._firstVisibleDisplayLine = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1855  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapFirstVisibleDocLine&quot;));
1856  					if (mapPosStr)
1857  						mapPosition._firstVisibleDocLine = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1858  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapLastVisibleDocLine&quot;));
1859  					if (mapPosStr)
1860  						mapPosition._lastVisibleDocLine = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1861  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapNbLine&quot;));
1862  					if (mapPosStr)
1863  						mapPosition._nbLine = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1864  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapHigherPos&quot;));
1865  					if (mapPosStr)
1866  						mapPosition._higherPos = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1867  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapWidth&quot;));
1868  					if (mapPosStr)
1869  						mapPosition._width = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1870  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapHeight&quot;));
1871  					if (mapPosStr)
1872  						mapPosition._height = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1873  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapKByteInDoc&quot;));
1874  					if (mapPosStr)
1875  						mapPosition._KByteInDoc = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1876  					mapPosStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapWrapIndentMode&quot;));
1877  					if (mapPosStr)
1878  						mapPosition._wrapIndentMode = static_cast&lt;intptr_t&gt;(_ttoi64(mapPosStr));
1879  					const TCHAR *boolStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;mapIsWrap&quot;));
1880  					if (boolStr)
1881  						mapPosition._isWrap = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
1882  					const TCHAR *langName;
1883  					langName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;lang&quot;));
1884  					int encoding = -1;
1885  					const TCHAR *encStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;encoding&quot;), &amp;encoding);
1886  					const TCHAR *backupFilePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;backupFilePath&quot;));
1887  					FILETIME fileModifiedTimestamp{};
1888  					(childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;originalFileLastModifTimestamp&quot;), reinterpret_cast&lt;int32_t*&gt;(&amp;fileModifiedTimestamp.dwLowDateTime));
1889  					(childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;originalFileLastModifTimestampHigh&quot;), reinterpret_cast&lt;int32_t*&gt;(&amp;fileModifiedTimestamp.dwHighDateTime));
1890  					bool isUserReadOnly = false;
1891  					const TCHAR *boolStrReadOnly = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;userReadOnly&quot;));
1892  					if (boolStrReadOnly)
1893  						isUserReadOnly = _wcsicmp(TEXT(&quot;yes&quot;), boolStrReadOnly) == 0;
1894  					sessionFileInfo sfi(fileName, langName, encStr ? encoding : -1, isUserReadOnly, position, backupFilePath, fileModifiedTimestamp, mapPosition);
1895  					const TCHAR* intStrTabColour = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;tabColourId&quot;));
1896  					if (intStrTabColour)
1897  					{
1898  						sfi._individualTabColour = _wtoi(intStrTabColour);
1899  					}
1900  					for (TiXmlNode *markNode = childNode-&gt;FirstChildElement(TEXT(&quot;Mark&quot;));
1901  						markNode;
1902  						markNode = markNode-&gt;NextSibling(TEXT(&quot;Mark&quot;)))
1903  					{
1904  						const TCHAR* lineNumberStr = (markNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;line&quot;));
1905  						if (lineNumberStr)
1906  						{
1907  							sfi._marks.push_back(static_cast&lt;size_t&gt;(_ttoi64(lineNumberStr)));
1908  						}
1909  					}
1910  					for (TiXmlNode *foldNode = childNode-&gt;FirstChildElement(TEXT(&quot;Fold&quot;));
1911  						foldNode;
1912  						foldNode = foldNode-&gt;NextSibling(TEXT(&quot;Fold&quot;)))
1913  					{
1914  						const TCHAR *lineNumberStr = (foldNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;line&quot;));
1915  						if (lineNumberStr)
1916  						{
1917  							sfi._foldStates.push_back(static_cast&lt;size_t&gt;(_ttoi64(lineNumberStr)));
1918  						}
1919  					}
1920  					if (k == 0)
1921  						session._mainViewFiles.push_back(sfi);
1922  					else 
1923  						session._subViewFiles.push_back(sfi);
1924  				}
1925  			}
1926  		}
1927  	}
1928  	TiXmlNode *fileBrowserRoot = sessionRoot-&gt;FirstChildElement(TEXT(&quot;FileBrowser&quot;));
1929  	if (fileBrowserRoot)
1930  	{
1931  		const TCHAR *selectedItemPath = (fileBrowserRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;latestSelectedItem&quot;));
1932  		if (selectedItemPath)
1933  		{
1934  			session._fileBrowserSelectedItem = selectedItemPath;
1935  		}
1936  		for (TiXmlNode *childNode = fileBrowserRoot-&gt;FirstChildElement(TEXT(&quot;root&quot;));
1937  			childNode;
1938  			childNode = childNode-&gt;NextSibling(TEXT(&quot;root&quot;)))
1939  		{
1940  			const TCHAR *fileName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;foldername&quot;));
1941  			if (fileName)
1942  			{
1943  				session._fileBrowserRoots.push_back({ fileName });
1944  			}
1945  		}
1946  	}
1947  	return true;
1948  }
1949  void NppParameters::feedFileListParameters(TiXmlNode *node)
1950  {
1951  	TiXmlNode *historyRoot = node-&gt;FirstChildElement(TEXT(&quot;History&quot;));
1952  	if (!historyRoot) return;
1953  	int nbMaxFile = _nbMaxRecentFile;
1954  	const TCHAR *strVal = (historyRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFile&quot;), &amp;nbMaxFile);
1955  	if (strVal &amp;&amp; (nbMaxFile &gt;= 0) &amp;&amp; (nbMaxFile &lt;= NB_MAX_LRF_FILE))
1956  		_nbMaxRecentFile = nbMaxFile;
1957  	int customLen = RECENTFILES_SHOWFULLPATH;
1958  	strVal = (historyRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;customLength&quot;), &amp;customLen);
1959  	if (strVal)
1960  		_recentFileCustomLength = std::min&lt;int&gt;(customLen, NB_MAX_LRF_CUSTOMLENGTH);
1961  	strVal = (historyRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;inSubMenu&quot;));
1962  	if (strVal)
1963  		_putRecentFileInSubMenu = (lstrcmp(strVal, TEXT(&quot;yes&quot;)) == 0);
1964  	for (TiXmlNode *childNode = historyRoot-&gt;FirstChildElement(TEXT(&quot;File&quot;));
1965  		childNode &amp;&amp; (_nbRecentFile &lt; NB_MAX_LRF_FILE);
1966  		childNode = childNode-&gt;NextSibling(TEXT(&quot;File&quot;)) )
1967  	{
1968  		const TCHAR *filePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;filename&quot;));
1969  		if (filePath)
1970  		{
1971  			_LRFileList[_nbRecentFile] = new generic_string(filePath);
1972  			++_nbRecentFile;
1973  		}
1974  	}
1975  }
1976  void NppParameters::feedFileBrowserParameters(TiXmlNode *node)
1977  {
1978  	TiXmlNode *fileBrowserRoot = node-&gt;FirstChildElement(TEXT(&quot;FileBrowser&quot;));
1979  	if (!fileBrowserRoot) return;
1980  	const TCHAR *selectedItemPath = (fileBrowserRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;latestSelectedItem&quot;));
1981  	if (selectedItemPath)
1982  	{
1983  		_fileBrowserSelectedItemPath = selectedItemPath;
1984  	}
1985  	for (TiXmlNode *childNode = fileBrowserRoot-&gt;FirstChildElement(TEXT(&quot;root&quot;));
1986  		childNode;
1987  		childNode = childNode-&gt;NextSibling(TEXT(&quot;root&quot;)) )
1988  	{
1989  		const TCHAR *filePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;foldername&quot;));
1990  		if (filePath)
1991  		{
1992  			_fileBrowserRoot.push_back(filePath);
1993  		}
1994  	}
1995  }
1996  void NppParameters::feedProjectPanelsParameters(TiXmlNode *node)
1997  {
1998  	TiXmlNode *projPanelRoot = node-&gt;FirstChildElement(TEXT(&quot;ProjectPanels&quot;));
1999  	if (!projPanelRoot) return;
2000  	for (TiXmlNode *childNode = projPanelRoot-&gt;FirstChildElement(TEXT(&quot;ProjectPanel&quot;));
2001  		childNode;
2002  		childNode = childNode-&gt;NextSibling(TEXT(&quot;ProjectPanel&quot;)) )
2003  	{
2004  		int index = 0;
2005  		const TCHAR *idStr = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;id&quot;), &amp;index);
2006  		if (idStr &amp;&amp; (index &gt;= 0 &amp;&amp; index &lt;= 2))
2007  		{
2008  			const TCHAR *filePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;workSpaceFile&quot;));
2009  			if (filePath)
2010  			{
2011  				_workSpaceFilePathes[index] = filePath;
2012  			}
2013  		}
2014  	}
2015  }
2016  void NppParameters::feedColumnEditorParameters(TiXmlNode *node)
2017  {
2018  	TiXmlNode * columnEditorRoot = node-&gt;FirstChildElement(TEXT(&quot;ColumnEditor&quot;));
2019  	if (!columnEditorRoot) return;
2020  	const TCHAR* strVal = (columnEditorRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;choice&quot;));
2021  	if (strVal)
2022  	{
2023  		if (lstrcmp(strVal, TEXT(&quot;text&quot;)) == 0)
2024  			_columnEditParam._mainChoice = activeText;
2025  		else
2026  			_columnEditParam._mainChoice = activeNumeric;
2027  	}
2028  	TiXmlNode *childNode = columnEditorRoot-&gt;FirstChildElement(TEXT(&quot;text&quot;));
2029  	if (!childNode) return;
2030  	const TCHAR* content = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;content&quot;));
2031  	if (content)
2032  	{
2033  		_columnEditParam._insertedTextContent = content;
2034  	}
2035  	childNode = columnEditorRoot-&gt;FirstChildElement(TEXT(&quot;number&quot;));
2036  	if (!childNode) return;
2037  	int val;
2038  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;initial&quot;), &amp;val);
2039  	if (strVal)
2040  		_columnEditParam._initialNum = val;
2041  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;increase&quot;), &amp;val);
2042  	if (strVal)
2043  		_columnEditParam._increaseNum = val;
2044  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;repeat&quot;), &amp;val);
2045  	if (strVal)
2046  		_columnEditParam._repeatNum = val;
2047  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;formatChoice&quot;));
2048  	if (strVal)
2049  	{
2050  		if (lstrcmp(strVal, TEXT(&quot;hex&quot;)) == 0)
2051  			_columnEditParam._formatChoice = 1;
2052  		else if (lstrcmp(strVal, TEXT(&quot;oct&quot;)) == 0)
2053  			_columnEditParam._formatChoice = 2;
2054  		else if (lstrcmp(strVal, TEXT(&quot;bin&quot;)) == 0)
2055  			_columnEditParam._formatChoice = 3;
2056  		else 
2057  			_columnEditParam._formatChoice = 0;
2058  	}
2059  	strVal = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;leadingChoice&quot;));
2060  	if (strVal)
2061  	{
2062  		_columnEditParam._leadingChoice = ColumnEditorParam::noneLeading;
2063  		if (lstrcmp(strVal, TEXT(&quot;zeros&quot;)) == 0)
2064  		{
2065  			_columnEditParam._leadingChoice = ColumnEditorParam::zeroLeading;
2066  		}
2067  		else if (lstrcmp(strVal, TEXT(&quot;spaces&quot;)) == 0)
2068  		{
2069  			_columnEditParam._leadingChoice = ColumnEditorParam::spaceLeading;
2070  		}
2071  	}
2072  }
2073  void NppParameters::feedFindHistoryParameters(TiXmlNode *node)
2074  {
2075  	TiXmlNode *findHistoryRoot = node-&gt;FirstChildElement(TEXT(&quot;FindHistory&quot;));
2076  	if (!findHistoryRoot) return;
2077  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFindHistoryPath&quot;), &amp;_findHistory._nbMaxFindHistoryPath);
2078  	if (_findHistory._nbMaxFindHistoryPath &gt; NB_MAX_FINDHISTORY_PATH)
2079  	{
2080  		_findHistory._nbMaxFindHistoryPath = NB_MAX_FINDHISTORY_PATH;
2081  	}
2082  	if ((_findHistory._nbMaxFindHistoryPath &gt; 0) &amp;&amp; (_findHistory._nbMaxFindHistoryPath &lt;= NB_MAX_FINDHISTORY_PATH))
2083  	{
2084  		for (TiXmlNode *childNode = findHistoryRoot-&gt;FirstChildElement(TEXT(&quot;Path&quot;));
2085  			childNode &amp;&amp; (_findHistory._findHistoryPaths.size() &lt; NB_MAX_FINDHISTORY_PATH);
2086  			childNode = childNode-&gt;NextSibling(TEXT(&quot;Path&quot;)) )
2087  		{
2088  			const TCHAR *filePath = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2089  			if (filePath)
2090  			{
2091  				_findHistory._findHistoryPaths.push_back(generic_string(filePath));
2092  			}
2093  		}
2094  	}
2095  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFindHistoryFilter&quot;), &amp;_findHistory._nbMaxFindHistoryFilter);
2096  	if (_findHistory._nbMaxFindHistoryFilter &gt; NB_MAX_FINDHISTORY_FILTER)
2097  	{
2098  		_findHistory._nbMaxFindHistoryFilter = NB_MAX_FINDHISTORY_FILTER;
2099  	}
2100  	if ((_findHistory._nbMaxFindHistoryFilter &gt; 0) &amp;&amp; (_findHistory._nbMaxFindHistoryFilter &lt;= NB_MAX_FINDHISTORY_FILTER))
2101  	{
2102  		for (TiXmlNode *childNode = findHistoryRoot-&gt;FirstChildElement(TEXT(&quot;Filter&quot;));
2103  			childNode &amp;&amp; (_findHistory._findHistoryFilters.size() &lt; NB_MAX_FINDHISTORY_FILTER);
2104  			childNode = childNode-&gt;NextSibling(TEXT(&quot;Filter&quot;)))
2105  		{
2106  			const TCHAR *fileFilter = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2107  			if (fileFilter)
2108  			{
2109  				_findHistory._findHistoryFilters.push_back(generic_string(fileFilter));
2110  			}
2111  		}
2112  	}
2113  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFindHistoryFind&quot;), &amp;_findHistory._nbMaxFindHistoryFind);
2114  	if (_findHistory._nbMaxFindHistoryFind &gt; NB_MAX_FINDHISTORY_FIND)
2115  	{
2116  		_findHistory._nbMaxFindHistoryFind = NB_MAX_FINDHISTORY_FIND;
2117  	}
2118  	if ((_findHistory._nbMaxFindHistoryFind &gt; 0) &amp;&amp; (_findHistory._nbMaxFindHistoryFind &lt;= NB_MAX_FINDHISTORY_FIND))
2119  	{
2120  		for (TiXmlNode *childNode = findHistoryRoot-&gt;FirstChildElement(TEXT(&quot;Find&quot;));
2121  			childNode &amp;&amp; (_findHistory._findHistoryFinds.size() &lt; NB_MAX_FINDHISTORY_FIND);
2122  			childNode = childNode-&gt;NextSibling(TEXT(&quot;Find&quot;)))
2123  		{
2124  			const TCHAR *fileFind = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2125  			if (fileFind)
2126  			{
2127  				_findHistory._findHistoryFinds.push_back(generic_string(fileFind));
2128  			}
2129  		}
2130  	}
2131  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;nbMaxFindHistoryReplace&quot;), &amp;_findHistory._nbMaxFindHistoryReplace);
2132  	if (_findHistory._nbMaxFindHistoryReplace &gt; NB_MAX_FINDHISTORY_REPLACE)
2133  	{
2134  		_findHistory._nbMaxFindHistoryReplace = NB_MAX_FINDHISTORY_REPLACE;
2135  	}
2136  	if ((_findHistory._nbMaxFindHistoryReplace &gt; 0) &amp;&amp; (_findHistory._nbMaxFindHistoryReplace &lt;= NB_MAX_FINDHISTORY_REPLACE))
2137  	{
2138  		for (TiXmlNode *childNode = findHistoryRoot-&gt;FirstChildElement(TEXT(&quot;Replace&quot;));
2139  			childNode &amp;&amp; (_findHistory._findHistoryReplaces.size() &lt; NB_MAX_FINDHISTORY_REPLACE);
2140  			childNode = childNode-&gt;NextSibling(TEXT(&quot;Replace&quot;)))
2141  		{
2142  			const TCHAR *fileReplace = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2143  			if (fileReplace)
2144  			{
2145  				_findHistory._findHistoryReplaces.push_back(generic_string(fileReplace));
2146  			}
2147  		}
2148  	}
2149  	const TCHAR *boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;matchWord&quot;));
2150  	if (boolStr)
2151  		_findHistory._isMatchWord = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2152  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;matchCase&quot;));
2153  	if (boolStr)
2154  		_findHistory._isMatchCase = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2155  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;wrap&quot;));
2156  	if (boolStr)
2157  		_findHistory._isWrap = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2158  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;directionDown&quot;));
2159  	if (boolStr)
2160  		_findHistory._isDirectionDown = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2161  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifRecuisive&quot;));
2162  	if (boolStr)
2163  		_findHistory._isFifRecuisive = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2164  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifInHiddenFolder&quot;));
2165  	if (boolStr)
2166  		_findHistory._isFifInHiddenFolder = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2167  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifProjectPanel1&quot;));
2168  	if (boolStr)
2169  		_findHistory._isFifProjectPanel_1 = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2170  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifProjectPanel2&quot;));
2171  	if (boolStr)
2172  		_findHistory._isFifProjectPanel_2 = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2173  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifProjectPanel3&quot;));
2174  	if (boolStr)
2175  		_findHistory._isFifProjectPanel_3 = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2176  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifFilterFollowsDoc&quot;));
2177  	if (boolStr)
2178  		_findHistory._isFilterFollowDoc = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2179  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;fifFolderFollowsDoc&quot;));
2180  	if (boolStr)
2181  		_findHistory._isFolderFollowDoc = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2182  	int mode = 0;
2183  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;searchMode&quot;), &amp;mode);
2184  	if (boolStr)
2185  		_findHistory._searchMode = (FindHistory::searchMode)mode;
2186  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;transparencyMode&quot;), &amp;mode);
2187  	if (boolStr)
2188  		_findHistory._transparencyMode = (FindHistory::transparencyMode)mode;
2189  	(findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;transparency&quot;), &amp;_findHistory._transparency);
2190  	if (_findHistory._transparency &lt;= 0 || _findHistory._transparency &gt; 200)
2191  		_findHistory._transparency = 150;
2192  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;dotMatchesNewline&quot;));
2193  	if (boolStr)
2194  		_findHistory._dotMatchesNewline = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2195  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;isSearch2ButtonsMode&quot;));
2196  	if (boolStr)
2197  		_findHistory._isSearch2ButtonsMode = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2198  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;regexBackward4PowerUser&quot;));
2199  	if (boolStr)
2200  		_findHistory._regexBackward4PowerUser = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2201  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;bookmarkLine&quot;));
2202  	if (boolStr)
2203  		_findHistory._isBookmarkLine = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2204  	boolStr = (findHistoryRoot-&gt;ToElement())-&gt;Attribute(TEXT(&quot;purge&quot;));
2205  	if (boolStr)
2206  		_findHistory._isPurge = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
2207  }
2208  void NppParameters::feedShortcut(TiXmlNodeA *node)
2209  {
2210  	TiXmlNodeA *shortcutsRoot = node-&gt;FirstChildElement(&quot;InternalCommands&quot;);
2211  	if (!shortcutsRoot) return;
2212  	for (TiXmlNodeA *childNode = shortcutsRoot-&gt;FirstChildElement(&quot;Shortcut&quot;);
2213  		childNode ;
2214  		childNode = childNode-&gt;NextSibling(&quot;Shortcut&quot;))
2215  	{
2216  		int id;
2217  		const char* idStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;id&quot;, &amp;id);
2218  		if (idStr)
2219  		{
2220  			size_t len = _shortcuts.size();
2221  			for (size_t i = 0; i &lt; len; ++i)
2222  			{
2223  				if (_shortcuts[i].getID() == (unsigned long)id)
2224  				{	
2225  					getShortcuts(childNode, _shortcuts[i]);
2226  					addUserModifiedIndex(i);
2227  				}
2228  			}
2229  		}
2230  	}
2231  }
2232  void NppParameters::feedMacros(TiXmlNodeA *node)
2233  {
2234  	TiXmlNodeA *macrosRoot = node-&gt;FirstChildElement(&quot;Macros&quot;);
2235  	if (!macrosRoot) return;
2236  	for (TiXmlNodeA *childNode = macrosRoot-&gt;FirstChildElement(&quot;Macro&quot;);
2237  		childNode ;
2238  		childNode = childNode-&gt;NextSibling(&quot;Macro&quot;))
2239  	{
2240  		Shortcut sc;
2241  		string fdnm;
2242  		if (getShortcuts(childNode, sc, &amp;fdnm))
2243  		{
2244  			Macro macro;
2245  			getActions(childNode, macro);
2246  			int cmdID = ID_MACRO + static_cast&lt;int32_t&gt;(_macros.size());
2247  			_macros.push_back(MacroShortcut(sc, macro, cmdID));
2248  			_macroMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2249  		}
2250  	}
2251  }
2252  void NppParameters::getActions(TiXmlNodeA *node, Macro &amp; macro)
2253  {
2254  	for (TiXmlNodeA *childNode = node-&gt;FirstChildElement(&quot;Action&quot;);
2255  		childNode ;
2256  		childNode = childNode-&gt;NextSibling(&quot;Action&quot;) )
2257  	{
2258  		int type;
2259  		const char *typeStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;type&quot;, &amp;type);
2260  		if ((!typeStr) || (type &gt; 3))
2261  			continue;
2262  		int msg = 0;
2263  		(childNode-&gt;ToElement())-&gt;Attribute(&quot;message&quot;, &amp;msg);
2264  		int wParam = 0;
2265  		(childNode-&gt;ToElement())-&gt;Attribute(&quot;wParam&quot;, &amp;wParam);
2266  		int lParam = 0;
2267  		(childNode-&gt;ToElement())-&gt;Attribute(&quot;lParam&quot;, &amp;lParam);
2268  		const char *sParam = (childNode-&gt;ToElement())-&gt;Attribute(&quot;sParam&quot;);
2269  		if (!sParam)
2270  			sParam = &quot;&quot;;
2271  		recordedMacroStep step(msg, wParam, lParam, sParam, type);
2272  		if (step.isValid())
2273  			macro.push_back(step);
2274  	}
2275  }
2276  void NppParameters::feedUserCmds(TiXmlNodeA *node)
2277  {
2278  	TiXmlNodeA *userCmdsRoot = node-&gt;FirstChildElement(&quot;UserDefinedCommands&quot;);
2279  	if (!userCmdsRoot) return;
2280  	for (TiXmlNodeA *childNode = userCmdsRoot-&gt;FirstChildElement(&quot;Command&quot;);
2281  		childNode ;
2282  		childNode = childNode-&gt;NextSibling(&quot;Command&quot;) )
2283  	{
2284  		Shortcut sc;
2285  		string fdnm;
2286  		if (getShortcuts(childNode, sc, &amp;fdnm))
2287  		{
2288  			TiXmlNodeA *aNode = childNode-&gt;FirstChild();
2289  			if (aNode)
2290  			{
2291  				const char* cmdStr = aNode-&gt;Value();
2292  				if (cmdStr)
2293  				{
2294  					int cmdID = ID_USER_CMD + static_cast&lt;int32_t&gt;(_userCommands.size());
2295  					_userCommands.push_back(UserCommand(sc, cmdStr, cmdID));
2296  					_runMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2297  				}
2298  			}
2299  		}
2300  	}
2301  }
2302  void NppParameters::feedPluginCustomizedCmds(TiXmlNodeA *node)
2303  {
2304  	TiXmlNodeA *pluginCustomizedCmdsRoot = node-&gt;FirstChildElement(&quot;PluginCommands&quot;);
2305  	if (!pluginCustomizedCmdsRoot) return;
2306  	for (TiXmlNodeA *childNode = pluginCustomizedCmdsRoot-&gt;FirstChildElement(&quot;PluginCommand&quot;);
2307  		childNode ;
2308  		childNode = childNode-&gt;NextSibling(&quot;PluginCommand&quot;) )
2309  	{
2310  		const char *moduleName = (childNode-&gt;ToElement())-&gt;Attribute(&quot;moduleName&quot;);
2311  		if (!moduleName)
2312  			continue;
2313  		int internalID = -1;
2314  		const char *internalIDStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;internalID&quot;, &amp;internalID);
2315  		if (!internalIDStr)
2316  			continue;
2317  		size_t len = _pluginCommands.size();
2318  		for (size_t i = 0; i &lt; len; ++i)
2319  		{
2320  			PluginCmdShortcut &amp; pscOrig = _pluginCommands[i];
2321  			if (!strnicmp(pscOrig.getModuleName(), moduleName, strlen(moduleName)) &amp;&amp; pscOrig.getInternalID() == internalID)
2322  			{
2323  				getShortcuts(childNode, _pluginCommands[i]);
2324  				addPluginModifiedIndex(i);
2325  				break;
2326  			}
2327  		}
2328  	}
2329  }
2330  void NppParameters::feedScintKeys(TiXmlNodeA *node)
2331  {
2332  	TiXmlNodeA *scintKeysRoot = node-&gt;FirstChildElement(&quot;ScintillaKeys&quot;);
2333  	if (!scintKeysRoot) return;
2334  	for (TiXmlNodeA *childNode = scintKeysRoot-&gt;FirstChildElement(&quot;ScintKey&quot;);
2335  		childNode ;
2336  		childNode = childNode-&gt;NextSibling(&quot;ScintKey&quot;) )
2337  	{
2338  		int scintKey;
2339  		const char *keyStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;ScintID&quot;, &amp;scintKey);
2340  		if (!keyStr)
2341  			continue;
2342  		int menuID;
2343  		keyStr = (childNode-&gt;ToElement())-&gt;Attribute(&quot;menuCmdID&quot;, &amp;menuID);
2344  		if (!keyStr)
2345  			continue;
2346  		size_t len = _scintillaKeyCommands.size();
2347  		for (int32_t i = 0; i &lt; static_cast&lt;int32_t&gt;(len); ++i)
2348  		{
2349  			ScintillaKeyMap &amp; skmOrig = _scintillaKeyCommands[i];
2350  			if (skmOrig.getScintillaKeyID() == (unsigned long)scintKey &amp;&amp; skmOrig.getMenuCmdID() == menuID)
2351  			{
2352  				_scintillaKeyCommands[i].clearDups();
2353  				getShortcuts(childNode, _scintillaKeyCommands[i]);
2354  				_scintillaKeyCommands[i].setKeyComboByIndex(0, _scintillaKeyCommands[i].getKeyCombo());
2355  				addScintillaModifiedIndex(i);
2356  				KeyCombo kc;
2357  				for (TiXmlNodeA *nextNode = childNode-&gt;FirstChildElement(&quot;NextKey&quot;);
2358  					nextNode ;
2359  					nextNode = nextNode-&gt;NextSibling(&quot;NextKey&quot;))
2360  				{
2361  					const char *str = (nextNode-&gt;ToElement())-&gt;Attribute(&quot;Ctrl&quot;);
2362  					if (!str)
2363  						continue;
2364  					kc._isCtrl = (strcmp(&quot;yes&quot;, str) == 0);
2365  					str = (nextNode-&gt;ToElement())-&gt;Attribute(&quot;Alt&quot;);
2366  					if (!str)
2367  						continue;
2368  					kc._isAlt = (strcmp(&quot;yes&quot;, str) == 0);
2369  					str = (nextNode-&gt;ToElement())-&gt;Attribute(&quot;Shift&quot;);
2370  					if (!str)
2371  						continue;
2372  					kc._isShift = (strcmp(&quot;yes&quot;, str) == 0);
2373  					int key;
2374  					str = (nextNode-&gt;ToElement())-&gt;Attribute(&quot;Key&quot;, &amp;key);
2375  					if (!str)
2376  						continue;
2377  					kc._key = static_cast&lt;unsigned char&gt;(key);
2378  					_scintillaKeyCommands[i].addKeyCombo(kc);
2379  				}
2380  				break;
2381  			}
2382  		}
2383  	}
2384  }
2385  bool NppParameters::getShortcuts(TiXmlNodeA *node, Shortcut &amp; sc, string* folderName)
2386  {
2387  	if (!node) return false;
2388  	const char* name = (node-&gt;ToElement())-&gt;Attribute(&quot;name&quot;);
2389  	if (!name)
2390  		name = &quot;&quot;;
2391  	bool isCtrl = false;
2392  	const char* isCtrlStr = (node-&gt;ToElement())-&gt;Attribute(&quot;Ctrl&quot;);
2393  	if (isCtrlStr)
2394  		isCtrl = (strcmp(&quot;yes&quot;, isCtrlStr) == 0);
2395  	bool isAlt = false;
2396  	const char* isAltStr = (node-&gt;ToElement())-&gt;Attribute(&quot;Alt&quot;);
2397  	if (isAltStr)
2398  		isAlt = (strcmp(&quot;yes&quot;, isAltStr) == 0);
2399  	bool isShift = false;
2400  	const char* isShiftStr = (node-&gt;ToElement())-&gt;Attribute(&quot;Shift&quot;);
2401  	if (isShiftStr)
2402  		isShift = (strcmp(&quot;yes&quot;, isShiftStr) == 0);
2403  	int key;
2404  	const char* keyStr = (node-&gt;ToElement())-&gt;Attribute(&quot;Key&quot;, &amp;key);
2405  	if (!keyStr)
2406  		return false;
2407  	if (folderName)
2408  	{
2409  		const char* fn = (node-&gt;ToElement())-&gt;Attribute(&quot;FolderName&quot;);
2410  		*folderName = fn ? fn : &quot;&quot;;
2411  	}
2412  	sc = Shortcut(name, isCtrl, isAlt, isShift, static_cast&lt;unsigned char&gt;(key));
2413  	return true;
2414  }
2415  std::pair&lt;unsigned char, unsigned char&gt; NppParameters::feedUserLang(TiXmlNode *node)
2416  {
2417  	int iBegin = _nbUserLang;
2418  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;UserLang&quot;));
2419  		childNode &amp;&amp; (_nbUserLang &lt; NB_MAX_USER_LANG);
2420  		childNode = childNode-&gt;NextSibling(TEXT(&quot;UserLang&quot;)) )
2421  	{
2422  		const TCHAR* name = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
2423  		const TCHAR* ext = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;ext&quot;));
2424  		const TCHAR* darkModeTheme = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;darkModeTheme&quot;));
2425  		const TCHAR* udlVersion = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;udlVersion&quot;));
2426  		if (!name || !name[0] || !ext)
2427  		{
2428  			continue;
2429  		}
2430  		bool isDarkModeTheme = false;
2431  		if (darkModeTheme &amp;&amp; darkModeTheme[0])
2432  		{
2433  			isDarkModeTheme = (lstrcmp(TEXT(&quot;yes&quot;), darkModeTheme) == 0);
2434  		}
2435  		try {
2436  			_userLangArray[_nbUserLang] = new UserLangContainer(name, ext, isDarkModeTheme, udlVersion ? udlVersion : TEXT(&quot;&quot;));
2437  			++_nbUserLang;
2438  			TiXmlNode *settingsRoot = childNode-&gt;FirstChildElement(TEXT(&quot;Settings&quot;));
2439  			if (!settingsRoot)
2440  				throw std::runtime_error(&quot;NppParameters::feedUserLang : Settings node is missing&quot;);
2441  			feedUserSettings(settingsRoot);
2442  			TiXmlNode *keywordListsRoot = childNode-&gt;FirstChildElement(TEXT(&quot;KeywordLists&quot;));
2443  			if (!keywordListsRoot)
2444  				throw std::runtime_error(&quot;NppParameters::feedUserLang : KeywordLists node is missing&quot;);
2445  			feedUserKeywordList(keywordListsRoot);
2446  			TiXmlNode *stylesRoot = childNode-&gt;FirstChildElement(TEXT(&quot;Styles&quot;));
2447  			if (!stylesRoot)
2448  				throw std::runtime_error(&quot;NppParameters::feedUserLang : Styles node is missing&quot;);
2449  			feedUserStyles(stylesRoot);
2450  			for (int i = 0 ; i &lt; SCE_USER_STYLE_TOTAL_STYLES ; ++i)
2451  			{
2452  				const Style * pStyle = _userLangArray[_nbUserLang - 1]-&gt;_styles.findByID(i);
2453  				if (!pStyle)
2454  					_userLangArray[_nbUserLang - 1]-&gt;_styles.addStyler(i, globalMappper().styleNameMapper[i]);
2455  			}
2456  		}
2457  		catch (const std::exception&amp;)
2458  		{
2459  			delete _userLangArray[--_nbUserLang];
2460  		}
2461  	}
2462  	int iEnd = _nbUserLang;
2463  	return pair&lt;unsigned char, unsigned char&gt;(static_cast&lt;unsigned char&gt;(iBegin), static_cast&lt;unsigned char&gt;(iEnd));
2464  }
2465  bool NppParameters::importUDLFromFile(const generic_string&amp; sourceFile)
2466  {
2467  	TiXmlDocument *pXmlUserLangDoc = new TiXmlDocument(sourceFile);
2468  	bool loadOkay = pXmlUserLangDoc-&gt;LoadFile();
2469  	if (loadOkay)
2470  	{
2471  		auto r = addUserDefineLangsFromXmlTree(pXmlUserLangDoc);
2472  		loadOkay = (r.second - r.first) != 0;
2473  		if (loadOkay)
2474  		{
2475  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, r));
2476  			setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
2477  		}
2478  	}
2479  	delete pXmlUserLangDoc;
2480  	return loadOkay;
2481  }
2482  bool NppParameters::exportUDLToFile(size_t langIndex2export, const generic_string&amp; fileName2save)
2483  {
2484  	if (langIndex2export &gt;= NB_MAX_USER_LANG)
2485  		return false;
2486  	if (static_cast&lt;int32_t&gt;(langIndex2export) &gt;= _nbUserLang)
2487  		return false;
2488  	TiXmlDocument *pNewXmlUserLangDoc = new TiXmlDocument(fileName2save);
2489  	TiXmlNode *newRoot2export = pNewXmlUserLangDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2490  	insertUserLang2Tree(newRoot2export, _userLangArray[langIndex2export]);
2491  	bool result = pNewXmlUserLangDoc-&gt;SaveFile();
2492  	delete pNewXmlUserLangDoc;
2493  	return result;
2494  }
2495  LangType NppParameters::getLangFromExt(const TCHAR *ext)
2496  {
2497  	int i = getNbLang();
2498  	i--;
2499  	while (i &gt;= 0)
2500  	{
2501  		Lang *l = getLangFromIndex(i--);
2502  		const TCHAR *defList = l-&gt;getDefaultExtList();
2503  		const TCHAR *userList = NULL;
2504  		LexerStylerArray &amp;lsa = getLStylerArray();
2505  		const TCHAR *lName = l-&gt;getLangName();
2506  		LexerStyler *pLS = lsa.getLexerStylerByName(lName);
2507  		if (pLS)
2508  			userList = pLS-&gt;getLexerUserExt();
2509  		generic_string list;
2510  		if (defList)
2511  			list += defList;
2512  		if (userList)
2513  		{
2514  			list += TEXT(&quot; &quot;);
2515  			list += userList;
2516  		}
2517  		if (isInList(ext, list.c_str()))
2518  			return l-&gt;getLangID();
2519  	}
2520  	return L_TEXT;
2521  }
2522  void NppParameters::setCloudChoice(const TCHAR *pathChoice)
2523  {
2524  	generic_string cloudChoicePath = getSettingsFolder();
2525  	cloudChoicePath += TEXT(&quot;\\cloud\\&quot;);
2526  	if (!PathFileExists(cloudChoicePath.c_str()))
2527  	{
2528  		::CreateDirectory(cloudChoicePath.c_str(), NULL);
2529  	}
2530  	cloudChoicePath += TEXT(&quot;choice&quot;);
2531  	WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
2532  	std::string cloudPathA = wmc.wchar2char(pathChoice, SC_CP_UTF8);
2533  	writeFileContent(cloudChoicePath.c_str(), cloudPathA.c_str());
2534  }
2535  void NppParameters::removeCloudChoice()
2536  {
2537  	generic_string cloudChoicePath = getSettingsFolder();
2538  	cloudChoicePath += TEXT(&quot;\\cloud\\choice&quot;);
2539  	if (PathFileExists(cloudChoicePath.c_str()))
2540  	{
2541  		::DeleteFile(cloudChoicePath.c_str());
2542  	}
2543  }
2544  bool NppParameters::isCloudPathChanged() const
2545  {
2546  	if (_initialCloudChoice == _nppGUI._cloudPath)
2547  		return false;
2548  	else if (_initialCloudChoice.size() - _nppGUI._cloudPath.size() == 1)
2549  	{
2550  		TCHAR c = _initialCloudChoice.at(_initialCloudChoice.size()-1);
2551  		if (c == &#x27;\\&#x27; || c == &#x27;/&#x27;)
2552  		{
2553  			if (_initialCloudChoice.find(_nppGUI._cloudPath) == 0)
2554  				return false;
2555  		}
2556  	}
2557  	else if (_nppGUI._cloudPath.size() - _initialCloudChoice.size() == 1)
2558  	{
2559  		TCHAR c = _nppGUI._cloudPath.at(_nppGUI._cloudPath.size() - 1);
2560  		if (c == &#x27;\\&#x27; || c == &#x27;/&#x27;)
2561  		{
2562  			if (_nppGUI._cloudPath.find(_initialCloudChoice) == 0)
2563  				return false;
2564  		}
2565  	}
2566  	return true;
2567  }
2568  bool NppParameters::writeSettingsFilesOnCloudForThe1stTime(const generic_string &amp; cloudSettingsPath)
2569  {
2570  	bool isOK = false;
2571  	if (cloudSettingsPath.empty())
2572  		return false;
2573  	generic_string cloudConfigPath = cloudSettingsPath;
2574  	pathAppend(cloudConfigPath, TEXT(&quot;config.xml&quot;));
2575  	if (!::PathFileExists(cloudConfigPath.c_str()) &amp;&amp; _pXmlUserDoc)
2576  	{
2577  		isOK = _pXmlUserDoc-&gt;SaveFile(cloudConfigPath.c_str());
2578  		if (!isOK)
2579  			return false;
2580  	}
2581  	generic_string cloudStylersPath = cloudSettingsPath;
2582  	pathAppend(cloudStylersPath, TEXT(&quot;stylers.xml&quot;));
2583  	if (!::PathFileExists(cloudStylersPath.c_str()) &amp;&amp; _pXmlUserStylerDoc)
2584  	{
2585  		isOK = _pXmlUserStylerDoc-&gt;SaveFile(cloudStylersPath.c_str());
2586  		if (!isOK)
2587  			return false;
2588  	}
2589  	generic_string cloudLangsPath = cloudSettingsPath;
2590  	pathAppend(cloudLangsPath, TEXT(&quot;langs.xml&quot;));
2591  	if (!::PathFileExists(cloudLangsPath.c_str()) &amp;&amp; _pXmlUserDoc)
2592  	{
2593  		isOK = _pXmlDoc-&gt;SaveFile(cloudLangsPath.c_str());
2594  		if (!isOK)
2595  			return false;
2596  	}
2597  	generic_string cloudUserLangsPath = cloudSettingsPath;
2598  	pathAppend(cloudUserLangsPath, TEXT(&quot;userDefineLang.xml&quot;));
2599  	if (!::PathFileExists(cloudUserLangsPath.c_str()) &amp;&amp; _pXmlUserLangDoc)
2600  	{
2601  		isOK = _pXmlUserLangDoc-&gt;SaveFile(cloudUserLangsPath.c_str());
2602  		if (!isOK)
2603  			return false;
2604  	}
2605  	generic_string cloudShortcutsPath = cloudSettingsPath;
2606  	pathAppend(cloudShortcutsPath, SHORTCUTSXML_FILENAME);
2607  	if (!::PathFileExists(cloudShortcutsPath.c_str()) &amp;&amp; _pXmlShortcutDocA)
2608  	{
2609  		isOK = _pXmlShortcutDocA-&gt;SaveUnicodeFilePath(cloudShortcutsPath.c_str());
2610  		if (!isOK)
2611  			return false;
2612  	}
2613  	generic_string cloudContextMenuPath = cloudSettingsPath;
2614  	pathAppend(cloudContextMenuPath, TEXT(&quot;contextMenu.xml&quot;));
2615  	if (!::PathFileExists(cloudContextMenuPath.c_str()) &amp;&amp; _pXmlContextMenuDocA)
2616  	{
2617  		isOK = _pXmlContextMenuDocA-&gt;SaveUnicodeFilePath(cloudContextMenuPath.c_str());
2618  		if (!isOK)
2619  			return false;
2620  	}
2621  	generic_string cloudNativeLangPath = cloudSettingsPath;
2622  	pathAppend(cloudNativeLangPath, TEXT(&quot;nativeLang.xml&quot;));
2623  	if (!::PathFileExists(cloudNativeLangPath.c_str()) &amp;&amp; _pXmlNativeLangDocA)
2624  	{
2625  		isOK = _pXmlNativeLangDocA-&gt;SaveUnicodeFilePath(cloudNativeLangPath.c_str());
2626  		if (!isOK)
2627  			return false;
2628  	}
2629  	return true;
2630  }
2631  void NppParameters::writeDefaultUDL()
2632  {
2633  	bool firstCleanDone = false;
2634  	std::vector&lt;std::pair&lt;bool, bool&gt;&gt; deleteState; 
2635  	for (const auto&amp; udl : _pXmlUserLangsDoc)
2636  	{
2637  		if (!_pXmlUserLangDoc)
2638  		{
2639  			_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
2640  			TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(&quot;1.0&quot;), TEXT(&quot;UTF-8&quot;), TEXT(&quot;&quot;));
2641  			_pXmlUserLangDoc-&gt;LinkEndChild(decl);
2642  			_pXmlUserLangDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2643  		}
2644  		bool toDelete = (udl._indexRange.second - udl._indexRange.first) == 0;
2645  		deleteState.push_back(std::pair(toDelete, udl._isInDefaultSharedContainer));
2646  		if ((!udl._udlXmlDoc || udl._udlXmlDoc == _pXmlUserLangDoc) &amp;&amp; udl._isDirty &amp;&amp; !toDelete) 
2647  		{
2648  			TiXmlNode *root = _pXmlUserLangDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
2649  			if (root &amp;&amp; !firstCleanDone)
2650  			{
2651  				_pXmlUserLangDoc-&gt;RemoveChild(root);
2652  				_pXmlUserLangDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2653  				firstCleanDone = true;
2654  			}
2655  			root = _pXmlUserLangDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
2656  			for (int i = udl._indexRange.first; i &lt; udl._indexRange.second; ++i)
2657  			{
2658  				insertUserLang2Tree(root, _userLangArray[i]);
2659  			}
2660  		}
2661  	}
2662  	bool deleteAll = true;
2663  	for (std::pair&lt;bool, bool&gt; udlState : deleteState)
2664  	{
2665  		if (!udlState.first &amp;&amp; udlState.second) 
2666  		{
2667  			deleteAll = false; 
2668  			break;
2669  		}
2670  	}
2671  	if (firstCleanDone) 
2672  	{
2673  		_pXmlUserLangDoc-&gt;SaveFile();
2674  	}
2675  	else if (deleteAll)
2676  	{
2677  		if (::PathFileExists(_userDefineLangPath.c_str()))
2678  		{
2679  			::DeleteFile(_userDefineLangPath.c_str());
2680  		}
2681  	}
2682  }
2683  void NppParameters::writeNonDefaultUDL()
2684  {
2685  	for (auto&amp; udl : _pXmlUserLangsDoc)
2686  	{
2687  		if (udl._isDirty &amp;&amp; udl._udlXmlDoc != nullptr &amp;&amp; udl._udlXmlDoc != _pXmlUserLangDoc)
2688  		{
2689  			if (udl._indexRange.second == udl._indexRange.first) 
2690  			{
2691  				const TCHAR* docFilePath = udl._udlXmlDoc-&gt;Value();
2692  				if (docFilePath &amp;&amp; ::PathFileExists(docFilePath))
2693  				{
2694  					::DeleteFile(docFilePath);
2695  				}
2696  			}
2697  			else
2698  			{
2699  				TiXmlNode *root = udl._udlXmlDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
2700  				if (root)
2701  				{
2702  					udl._udlXmlDoc-&gt;RemoveChild(root);
2703  				}
2704  				udl._udlXmlDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2705  				root = udl._udlXmlDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
2706  				for (int i = udl._indexRange.first; i &lt; udl._indexRange.second; ++i)
2707  				{
2708  					insertUserLang2Tree(root, _userLangArray[i]);
2709  				}
2710  				udl._udlXmlDoc-&gt;SaveFile();
2711  			}
2712  		}
2713  	}
2714  }
2715  void NppParameters::writeNeed2SaveUDL()
2716  {
2717  	writeDefaultUDL();
2718  	writeNonDefaultUDL();
2719  }
2720  void NppParameters::insertCmd(TiXmlNodeA *shortcutsRoot, const CommandShortcut &amp; cmd)
2721  {
2722  	const KeyCombo &amp; key = cmd.getKeyCombo();
2723  	TiXmlNodeA *sc = shortcutsRoot-&gt;InsertEndChild(TiXmlElementA(&quot;Shortcut&quot;));
2724  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;id&quot;, cmd.getID());
2725  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2726  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2727  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2728  	sc-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2729  }
2730  void NppParameters::insertMacro(TiXmlNodeA *macrosRoot, const MacroShortcut &amp; macro, const string&amp; folderName)
2731  {
2732  	const KeyCombo &amp; key = macro.getKeyCombo();
2733  	TiXmlNodeA *macroRoot = macrosRoot-&gt;InsertEndChild(TiXmlElementA(&quot;Macro&quot;));
2734  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;name&quot;, macro.getMenuName());
2735  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2736  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2737  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2738  	macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2739  	if (!folderName.empty())
2740  	{
2741  		macroRoot-&gt;ToElement()-&gt;SetAttribute(&quot;FolderName&quot;, folderName);
2742  	}
2743  	for (size_t i = 0, len = macro._macro.size(); i &lt; len ; ++i)
2744  	{
2745  		TiXmlNodeA *actionNode = macroRoot-&gt;InsertEndChild(TiXmlElementA(&quot;Action&quot;));
2746  		const recordedMacroStep &amp; action = macro._macro[i];
2747  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;type&quot;, action._macroType);
2748  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;message&quot;, action._message);
2749  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;wParam&quot;, static_cast&lt;int&gt;(action._wParameter));
2750  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;lParam&quot;, static_cast&lt;int&gt;(action._lParameter));
2751  		actionNode-&gt;ToElement()-&gt;SetAttribute(&quot;sParam&quot;, action._sParameter.c_str());
2752  	}
2753  }
2754  void NppParameters::insertUserCmd(TiXmlNodeA *userCmdRoot, const UserCommand &amp; userCmd, const string&amp; folderName)
2755  {
2756  	const KeyCombo &amp; key = userCmd.getKeyCombo();
2757  	TiXmlNodeA *cmdRoot = userCmdRoot-&gt;InsertEndChild(TiXmlElementA(&quot;Command&quot;));
2758  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;name&quot;, userCmd.getMenuName());
2759  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2760  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2761  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2762  	cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2763  	cmdRoot-&gt;InsertEndChild(TiXmlTextA(userCmd._cmd.c_str()));
2764  	if (!folderName.empty())
2765  	{
2766  		cmdRoot-&gt;ToElement()-&gt;SetAttribute(&quot;FolderName&quot;, folderName);
2767  	}
2768  }
2769  void NppParameters::insertPluginCmd(TiXmlNodeA *pluginCmdRoot, const PluginCmdShortcut &amp; pluginCmd)
2770  {
2771  	const KeyCombo &amp; key = pluginCmd.getKeyCombo();
2772  	TiXmlNodeA *pluginCmdNode = pluginCmdRoot-&gt;InsertEndChild(TiXmlElementA(&quot;PluginCommand&quot;));
2773  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;moduleName&quot;, pluginCmd.getModuleName());
2774  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;internalID&quot;, pluginCmd.getInternalID());
2775  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2776  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2777  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2778  	pluginCmdNode-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2779  }
2780  void NppParameters::insertScintKey(TiXmlNodeA *scintKeyRoot, const ScintillaKeyMap &amp; scintKeyMap)
2781  {
2782  	TiXmlNodeA *keyRoot = scintKeyRoot-&gt;InsertEndChild(TiXmlElementA(&quot;ScintKey&quot;));
2783  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;ScintID&quot;, scintKeyMap.getScintillaKeyID());
2784  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;menuCmdID&quot;, scintKeyMap.getMenuCmdID());
2785  	KeyCombo key = scintKeyMap.getKeyComboByIndex(0);
2786  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2787  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2788  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2789  	keyRoot-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2790  	size_t size = scintKeyMap.getSize();
2791  	if (size &gt; 1)
2792  	{
2793  		for (size_t i = 1; i &lt; size; ++i)
2794  		{
2795  			TiXmlNodeA *keyNext = keyRoot-&gt;InsertEndChild(TiXmlElementA(&quot;NextKey&quot;));
2796  			key = scintKeyMap.getKeyComboByIndex(i);
2797  			keyNext-&gt;ToElement()-&gt;SetAttribute(&quot;Ctrl&quot;, key._isCtrl?&quot;yes&quot;:&quot;no&quot;);
2798  			keyNext-&gt;ToElement()-&gt;SetAttribute(&quot;Alt&quot;, key._isAlt?&quot;yes&quot;:&quot;no&quot;);
2799  			keyNext-&gt;ToElement()-&gt;SetAttribute(&quot;Shift&quot;, key._isShift?&quot;yes&quot;:&quot;no&quot;);
2800  			keyNext-&gt;ToElement()-&gt;SetAttribute(&quot;Key&quot;, key._key);
2801  		}
2802  	}
2803  }
2804  void NppParameters::writeSession(const Session &amp; session, const TCHAR *fileName)
2805  {
2806  	const TCHAR *sessionPathName = fileName ? fileName : _sessionPath.c_str();
2807  	TCHAR backupPathName[MAX_PATH]{};
2808  	if (PathFileExists(sessionPathName))
2809  	{
2810  		_tcscpy(backupPathName, sessionPathName);
2811  		_tcscat(backupPathName, TEXT(&quot;.inCaseOfCorruption.bak&quot;));
2812  		CopyFile(sessionPathName, backupPathName, FALSE);
2813  	}
2814  	TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(sessionPathName);
2815  	TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(&quot;1.0&quot;), TEXT(&quot;UTF-8&quot;), TEXT(&quot;&quot;));
2816  	pXmlSessionDoc-&gt;LinkEndChild(decl);
2817  	TiXmlNode *root = pXmlSessionDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
2818  	if (root)
2819  	{
2820  		TiXmlNode *sessionNode = root-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Session&quot;)));
2821  		(sessionNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;activeView&quot;), static_cast&lt;int32_t&gt;(session._activeView));
2822  		struct ViewElem {
2823  			TiXmlNode *viewNode;
2824  			vector&lt;sessionFileInfo&gt; *viewFiles;
2825  			size_t activeIndex;
2826  		};
2827  		const int nbElem = 2;
2828  		ViewElem viewElems[nbElem];
2829  		viewElems[0].viewNode = sessionNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;mainView&quot;)));
2830  		viewElems[1].viewNode = sessionNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;subView&quot;)));
2831  		viewElems[0].viewFiles = (vector&lt;sessionFileInfo&gt; *)(&amp;(session._mainViewFiles));
2832  		viewElems[1].viewFiles = (vector&lt;sessionFileInfo&gt; *)(&amp;(session._subViewFiles));
2833  		viewElems[0].activeIndex = session._activeMainIndex;
2834  		viewElems[1].activeIndex = session._activeSubIndex;
2835  		for (size_t k = 0; k &lt; nbElem ; ++k)
2836  		{
2837  			(viewElems[k].viewNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;activeIndex&quot;), static_cast&lt;int32_t&gt;(viewElems[k].activeIndex));
2838  			vector&lt;sessionFileInfo&gt; &amp; viewSessionFiles = *(viewElems[k].viewFiles);
2839  			for (size_t i = 0, len = viewElems[k].viewFiles-&gt;size(); i &lt; len ; ++i)
2840  			{
2841  				TiXmlNode *fileNameNode = viewElems[k].viewNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;File&quot;)));
2842  				TCHAR szInt64[64];
2843  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;firstVisibleLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._firstVisibleLine), szInt64, 10));
2844  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;xOffset&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._xOffset), szInt64, 10));
2845  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;scrollWidth&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._scrollWidth), szInt64, 10));
2846  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;startPos&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._startPos), szInt64, 10));
2847  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;endPos&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._endPos), szInt64, 10));
2848  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;selMode&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._selMode), szInt64, 10));
2849  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;offset&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._offset), szInt64, 10));
2850  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;wrapCount&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._wrapCount), szInt64, 10));
2851  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;lang&quot;), viewSessionFiles[i]._langName.c_str());
2852  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;encoding&quot;), viewSessionFiles[i]._encoding);
2853  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;userReadOnly&quot;), (viewSessionFiles[i]._isUserReadOnly &amp;&amp; !viewSessionFiles[i]._isMonitoring) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
2854  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;filename&quot;), viewSessionFiles[i]._fileName.c_str());
2855  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;backupFilePath&quot;), viewSessionFiles[i]._backupFilePath.c_str());
2856  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;originalFileLastModifTimestamp&quot;), static_cast&lt;int32_t&gt;(viewSessionFiles[i]._originalFileLastModifTimestamp.dwLowDateTime));
2857  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;originalFileLastModifTimestampHigh&quot;), static_cast&lt;int32_t&gt;(viewSessionFiles[i]._originalFileLastModifTimestamp.dwHighDateTime));
2858  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;tabColourId&quot;), static_cast&lt;int32_t&gt;(viewSessionFiles[i]._individualTabColour));
2859  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapFirstVisibleDisplayLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._firstVisibleDisplayLine), szInt64, 10));
2860  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapFirstVisibleDocLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._firstVisibleDocLine), szInt64, 10));
2861  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapLastVisibleDocLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._lastVisibleDocLine), szInt64, 10));
2862  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapNbLine&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._nbLine), szInt64, 10));
2863  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapHigherPos&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._higherPos), szInt64, 10));
2864  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapWidth&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._width), szInt64, 10));
2865  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapHeight&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._height), szInt64, 10));
2866  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapKByteInDoc&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._KByteInDoc), szInt64, 10));
2867  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;mapWrapIndentMode&quot;), _i64tot(static_cast&lt;LONGLONG&gt;(viewSessionFiles[i]._mapPos._wrapIndentMode), szInt64, 10));
2868  				fileNameNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;mapIsWrap&quot;), viewSessionFiles[i]._mapPos._isWrap ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
2869  				for (size_t j = 0, len = viewSessionFiles[i]._marks.size() ; j &lt; len ; ++j)
2870  				{
2871  					size_t markLine = viewSessionFiles[i]._marks[j];
2872  					TiXmlNode *markNode = fileNameNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Mark&quot;)));
2873  					markNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;line&quot;), _ui64tot(static_cast&lt;ULONGLONG&gt;(markLine), szInt64, 10));
2874  				}
2875  				for (size_t j = 0, len = viewSessionFiles[i]._foldStates.size() ; j &lt; len ; ++j)
2876  				{
2877  					size_t foldLine = viewSessionFiles[i]._foldStates[j];
2878  					TiXmlNode *foldNode = fileNameNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Fold&quot;)));
2879  					foldNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;line&quot;), _ui64tot(static_cast&lt;ULONGLONG&gt;(foldLine), szInt64, 10));
2880  				}
2881  			}
2882  		}
2883  		if (session._includeFileBrowser)
2884  		{
2885  			TiXmlNode* fileBrowserRootNode = sessionNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;FileBrowser&quot;)));
2886  			fileBrowserRootNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;latestSelectedItem&quot;), session._fileBrowserSelectedItem.c_str());
2887  			for (const auto&amp; root : session._fileBrowserRoots)
2888  			{
2889  				TiXmlNode *fileNameNode = fileBrowserRootNode-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;root&quot;)));
2890  				(fileNameNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;foldername&quot;), root.c_str());
2891  			}
2892  		}
2893  	}
2894  	bool sessionSaveOK = pXmlSessionDoc-&gt;SaveFile();
2895  	if (sessionSaveOK)
2896  	{
2897  		TiXmlDocument* pXmlSessionCheck = new TiXmlDocument(sessionPathName);
2898  		sessionSaveOK = pXmlSessionCheck-&gt;LoadFile();
2899  		delete pXmlSessionCheck;
2900  	}
2901  	if (!sessionSaveOK)
2902  	{
2903  		if (backupPathName[0]) 
2904  		{
2905  			_pNativeLangSpeaker-&gt;messageBox(&quot;ErrorOfSavingSessionFile&quot;,
2906  				nullptr,
2907  				TEXT(&quot;The old session file will be restored.&quot;),
2908  				TEXT(&quot;Error of saving session file&quot;),
2909  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2910  			wstring sessionPathNameFail2Load = sessionPathName;
2911  			sessionPathNameFail2Load += L&quot;.fail2Load&quot;;
2912  			MoveFileEx(sessionPathName, sessionPathNameFail2Load.c_str(), MOVEFILE_REPLACE_EXISTING);
2913  			CopyFile(backupPathName, sessionPathName, FALSE);
2914  		}
2915  	}
2916  	else
2917  	{
2918  		if (backupPathName[0]) 
2919  		{
2920  			::DeleteFile(backupPathName);
2921  		}
2922  	}
2923  	delete pXmlSessionDoc;
2924  }
2925  void NppParameters::writeShortcuts()
2926  {
2927  	if (!_isAnyShortcutModified) return;
2928  	if (!_pXmlShortcutDocA)
2929  	{
2930  		_pXmlShortcutDocA = new TiXmlDocumentA();
2931  		TiXmlDeclarationA* decl = new TiXmlDeclarationA(&quot;1.0&quot;, &quot;UTF-8&quot;, &quot;&quot;);
2932  		_pXmlShortcutDocA-&gt;LinkEndChild(decl);
2933  	}
2934  	else
2935  	{
2936  		wchar_t v852NoNeedShortcutsBackup[MAX_PATH]{};
2937  		::wcscpy_s(v852NoNeedShortcutsBackup, _shortcutsPath.c_str());
2938  		::PathRemoveFileSpec(v852NoNeedShortcutsBackup);
2939  		::PathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
2940  		if (!::PathFileExists(v852NoNeedShortcutsBackup))
2941  		{
2942  			HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
2943  			::FlushFileBuffers(hFile);
2944  			::CloseHandle(hFile);
2945  			wstring v852ShortcutsBackupPath = _shortcutsPath;
2946  			v852ShortcutsBackupPath += L&quot;.v8.5.2.backup&quot;;
2947  			::CopyFile(_shortcutsPath.c_str(), v852ShortcutsBackupPath.c_str(), TRUE);
2948  			_pNativeLangSpeaker-&gt;messageBox(&quot;MacroAndRunCmdlWarning&quot;,
2949  				nullptr,
2950  				TEXT(&quot;Your Macro and Run commands saved in Notepad++ v.8.5.2 (or older) may not be compatible with the current version of Notepad++.\nPlease test those commands and, if needed, re-edit them.\n\nAlternatively, you can downgrade to Notepad++ v8.5.2 and restore your previous data.\nNotepad++ will backup your old \&quot;shortcuts.xml\&quot; and save it as \&quot;shortcuts.xml.v8.5.2.backup\&quot;.\nRenaming \&quot;shortcuts.xml.v8.5.2.backup\&quot; -&gt; \&quot;shortcuts.xml\&quot;, your commands should be restored and work properly.&quot;),
2951  				TEXT(&quot;Macro and Run Commands Compatibility&quot;),
2952  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2953  		}
2954  	}
2955  	TiXmlNodeA *root = _pXmlShortcutDocA-&gt;FirstChild(&quot;NotepadPlus&quot;);
2956  	if (!root)
2957  	{
2958  		root = _pXmlShortcutDocA-&gt;InsertEndChild(TiXmlElementA(&quot;NotepadPlus&quot;));
2959  	}
2960  	TiXmlNodeA *cmdRoot = root-&gt;FirstChild(&quot;InternalCommands&quot;);
2961  	if (cmdRoot)
2962  		root-&gt;RemoveChild(cmdRoot);
2963  	cmdRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;InternalCommands&quot;));
2964  	for (size_t i = 0, len = _customizedShortcuts.size(); i &lt; len ; ++i)
2965  	{
2966  		size_t index = _customizedShortcuts[i];
2967  		CommandShortcut csc = _shortcuts[index];
2968  		insertCmd(cmdRoot, csc);
2969  	}
2970  	TiXmlNodeA *macrosRoot = root-&gt;FirstChild(&quot;Macros&quot;);
2971  	if (macrosRoot)
2972  		root-&gt;RemoveChild(macrosRoot);
2973  	macrosRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;Macros&quot;));
2974  	for (size_t i = 0, len = _macros.size(); i &lt; len ; ++i)
2975  	{
2976  		insertMacro(macrosRoot, _macros[i], wstring2string(_macroMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2977  	}
2978  	TiXmlNodeA *userCmdRoot = root-&gt;FirstChild(&quot;UserDefinedCommands&quot;);
2979  	if (userCmdRoot)
2980  		root-&gt;RemoveChild(userCmdRoot);
2981  	userCmdRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;UserDefinedCommands&quot;));
2982  	for (size_t i = 0, len = _userCommands.size(); i &lt; len ; ++i)
2983  	{
2984  		insertUserCmd(userCmdRoot, _userCommands[i], wstring2string(_runMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2985  	}
2986  	TiXmlNodeA *pluginCmdRoot = root-&gt;FirstChild(&quot;PluginCommands&quot;);
2987  	if (pluginCmdRoot)
2988  		root-&gt;RemoveChild(pluginCmdRoot);
2989  	pluginCmdRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;PluginCommands&quot;));
2990  	for (size_t i = 0, len = _pluginCustomizedCmds.size(); i &lt; len ; ++i)
2991  	{
2992  		insertPluginCmd(pluginCmdRoot, _pluginCommands[_pluginCustomizedCmds[i]]);
2993  	}
2994  	TiXmlNodeA *scitillaKeyRoot = root-&gt;FirstChild(&quot;ScintillaKeys&quot;);
2995  	if (scitillaKeyRoot)
2996  		root-&gt;RemoveChild(scitillaKeyRoot);
2997  	scitillaKeyRoot = root-&gt;InsertEndChild(TiXmlElementA(&quot;ScintillaKeys&quot;));
2998  	for (size_t i = 0, len = _scintillaModifiedKeyIndices.size(); i &lt; len ; ++i)
2999  	{
3000  		insertScintKey(scitillaKeyRoot, _scintillaKeyCommands[_scintillaModifiedKeyIndices[i]]);
3001  	}
3002  	_pXmlShortcutDocA-&gt;SaveUnicodeFilePath(_shortcutsPath.c_str());
3003  }
3004  int NppParameters::addUserLangToEnd(const UserLangContainer &amp; userLang, const TCHAR *newName)
3005  {
3006  	if (isExistingUserLangName(newName))
3007  		return -1;
3008  	unsigned char iBegin = _nbUserLang;
3009  	_userLangArray[_nbUserLang] = new UserLangContainer();
3010  	*(_userLangArray[_nbUserLang]) = userLang;
3011  	_userLangArray[_nbUserLang]-&gt;_name = newName;
3012  	++_nbUserLang;
3013  	unsigned char iEnd = _nbUserLang;
3014  	_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, make_pair(iBegin, iEnd)));
3015  	setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
3016  	return _nbUserLang-1;
3017  }
3018  void NppParameters::removeUserLang(size_t index)
3019  {
3020  	if (static_cast&lt;int32_t&gt;(index) &gt;= _nbUserLang)
3021  		return;
3022  	delete _userLangArray[index];
3023  	for (int32_t i = static_cast&lt;int32_t&gt;(index); i &lt; (_nbUserLang - 1); ++i)
3024  		_userLangArray[i] = _userLangArray[i+1];
3025  	_nbUserLang--;
3026  	removeIndexFromXmlUdls(index);
3027  }
3028  void NppParameters::feedUserSettings(TiXmlNode *settingsRoot)
3029  {
3030  	const TCHAR *boolStr;
3031  	TiXmlNode *globalSettingNode = settingsRoot-&gt;FirstChildElement(TEXT(&quot;Global&quot;));
3032  	if (globalSettingNode)
3033  	{
3034  		boolStr = (globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;caseIgnored&quot;));
3035  		if (boolStr)
3036  			_userLangArray[_nbUserLang - 1]-&gt;_isCaseIgnored = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3037  		boolStr = (globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;allowFoldOfComments&quot;));
3038  		if (boolStr)
3039  			_userLangArray[_nbUserLang - 1]-&gt;_allowFoldOfComments = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3040  		(globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;forcePureLC&quot;), &amp;_userLangArray[_nbUserLang - 1]-&gt;_forcePureLC);
3041  		(globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;decimalSeparator&quot;), &amp;_userLangArray[_nbUserLang - 1]-&gt;_decimalSeparator);
3042  		boolStr = (globalSettingNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;foldCompact&quot;));
3043  		if (boolStr)
3044  			_userLangArray[_nbUserLang - 1]-&gt;_foldCompact = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3045  	}
3046  	TiXmlNode *prefixNode = settingsRoot-&gt;FirstChildElement(TEXT(&quot;Prefix&quot;));
3047  	if (prefixNode)
3048  	{
3049  		const TCHAR *udlVersion = _userLangArray[_nbUserLang - 1]-&gt;_udlVersion.c_str();
3050  		if (!lstrcmp(udlVersion, TEXT(&quot;2.1&quot;)) || !lstrcmp(udlVersion, TEXT(&quot;2.0&quot;)))
3051  		{
3052  			for (int i = 0 ; i &lt; SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
3053  			{
3054  				boolStr = (prefixNode-&gt;ToElement())-&gt;Attribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1]);
3055  				if (boolStr)
3056  					_userLangArray[_nbUserLang - 1]-&gt;_isPrefix[i] = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3057  			}
3058  		}
3059  		else	
3060  		{
3061  			TCHAR names[SCE_USER_TOTAL_KEYWORD_GROUPS][7] = {TEXT(&quot;words1&quot;), TEXT(&quot;words2&quot;), TEXT(&quot;words3&quot;), TEXT(&quot;words4&quot;)};
3062  			for (int i = 0 ; i &lt; 4 ; ++i)
3063  			{
3064  				boolStr = (prefixNode-&gt;ToElement())-&gt;Attribute(names[i]);
3065  				if (boolStr)
3066  					_userLangArray[_nbUserLang - 1]-&gt;_isPrefix[i] = (lstrcmp(TEXT(&quot;yes&quot;), boolStr) == 0);
3067  			}
3068  		}
3069  	}
3070  }
3071  void NppParameters::feedUserKeywordList(TiXmlNode *node)
3072  {
3073  	const TCHAR * udlVersion = _userLangArray[_nbUserLang - 1]-&gt;_udlVersion.c_str();
3074  	int id = -1;
3075  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;Keywords&quot;));
3076  		childNode ;
3077  		childNode = childNode-&gt;NextSibling(TEXT(&quot;Keywords&quot;)))
3078  	{
3079  		const TCHAR * keywordsName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
3080  		TiXmlNode *valueNode = childNode-&gt;FirstChild();
3081  		if (valueNode)
3082  		{
3083  			const TCHAR *kwl = nullptr;
3084  			if (!lstrcmp(udlVersion, TEXT(&quot;&quot;)) &amp;&amp; !lstrcmp(keywordsName, TEXT(&quot;Delimiters&quot;)))	
3085  			{
3086  				basic_string&lt;TCHAR&gt; temp;
3087  				kwl = (valueNode)?valueNode-&gt;Value():TEXT(&quot;000000&quot;);
3088  				temp += TEXT(&quot;00&quot;);	 if (kwl[0] != &#x27;0&#x27;) temp += kwl[0];	 temp += TEXT(&quot; 01&quot;);
3089  				temp += TEXT(&quot; 02&quot;);	if (kwl[3] != &#x27;0&#x27;) temp += kwl[3];
3090  				temp += TEXT(&quot; 03&quot;);	if (kwl[1] != &#x27;0&#x27;) temp += kwl[1];	 temp += TEXT(&quot; 04&quot;);
3091  				temp += TEXT(&quot; 05&quot;);	if (kwl[4] != &#x27;0&#x27;) temp += kwl[4];
3092  				temp += TEXT(&quot; 06&quot;);	if (kwl[2] != &#x27;0&#x27;) temp += kwl[2];	 temp += TEXT(&quot; 07&quot;);
3093  				temp += TEXT(&quot; 08&quot;);	if (kwl[5] != &#x27;0&#x27;) temp += kwl[5];
3094  				temp += TEXT(&quot; 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23&quot;);
3095  				wcscpy_s(_userLangArray[_nbUserLang - 1]-&gt;_keywordLists[SCE_USER_KWLIST_DELIMITERS], temp.c_str());
3096  			}
3097  			else if (!lstrcmp(keywordsName, TEXT(&quot;Comment&quot;)))
3098  			{
3099  				kwl = (valueNode)?valueNode-&gt;Value():TEXT(&quot;&quot;);
3100  				basic_string&lt;TCHAR&gt; temp{TEXT(&quot; &quot;)};
3101  				temp += kwl;
3102  				size_t pos = 0;
3103  				pos = temp.find(TEXT(&quot; 0&quot;));
3104  				while (pos != string::npos)
3105  				{
3106  					temp.replace(pos, 2, TEXT(&quot; 00&quot;));
3107  					pos = temp.find(TEXT(&quot; 0&quot;), pos+1);
3108  				}
3109  				pos = temp.find(TEXT(&quot; 1&quot;));
3110  				while (pos != string::npos)
3111  				{
3112  					temp.replace(pos, 2, TEXT(&quot; 03&quot;));
3113  					pos = temp.find(TEXT(&quot; 1&quot;));
3114  				}
3115  				pos = temp.find(TEXT(&quot; 2&quot;));
3116  				while (pos != string::npos)
3117  				{
3118  					temp.replace(pos, 2, TEXT(&quot; 04&quot;));
3119  					pos = temp.find(TEXT(&quot; 2&quot;));
3120  				}
3121  				temp += TEXT(&quot; 01 02&quot;);
3122  				if (temp[0] == &#x27; &#x27;)
3123  					temp.erase(0, 1);
3124  				wcscpy_s(_userLangArray[_nbUserLang - 1]-&gt;_keywordLists[SCE_USER_KWLIST_COMMENTS], temp.c_str());
3125  			}
3126  			else
3127  			{
3128  				kwl = (valueNode)?valueNode-&gt;Value():TEXT(&quot;&quot;);
3129  				if (globalMappper().keywordIdMapper.find(keywordsName) != globalMappper().keywordIdMapper.end())
3130  				{
3131  					id = globalMappper().keywordIdMapper[keywordsName];
3132  					if (wcslen(kwl) &lt; max_char)
3133  					{
3134  						wcscpy_s(_userLangArray[_nbUserLang - 1]-&gt;_keywordLists[id], kwl);
3135  					}
3136  					else
3137  					{
3138  						wcscpy_s(_userLangArray[_nbUserLang - 1]-&gt;_keywordLists[id], TEXT(&quot;imported string too long, needs to be &lt; max_char(30720)&quot;));
3139  					}
3140  				}
3141  			}
3142  		}
3143  	}
3144  }
3145  void NppParameters::feedUserStyles(TiXmlNode *node)
3146  {
3147  	int id = -1;
3148  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;WordsStyle&quot;));
3149  		childNode ;
3150  		childNode = childNode-&gt;NextSibling(TEXT(&quot;WordsStyle&quot;)))
3151  	{
3152  		const TCHAR *styleName = (childNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
3153  		if (styleName)
3154  		{
3155  			if (globalMappper().styleIdMapper.find(styleName) != globalMappper().styleIdMapper.end())
3156  			{
3157  				id = globalMappper().styleIdMapper[styleName];
3158  				_userLangArray[_nbUserLang - 1]-&gt;_styles.addStyler((id | L_USER &lt;&lt; 16), childNode);
3159  			}
3160  		}
3161  	}
3162  }
3163  bool NppParameters::feedStylerArray(TiXmlNode *node)
3164  {
3165  	TiXmlNode *styleRoot = node-&gt;FirstChildElement(TEXT(&quot;LexerStyles&quot;));
3166  	if (!styleRoot) return false;
3167  	for (TiXmlNode *childNode = styleRoot-&gt;FirstChildElement(TEXT(&quot;LexerType&quot;));
3168  		 childNode ;
3169  		 childNode = childNode-&gt;NextSibling(TEXT(&quot;LexerType&quot;)) )
3170  	{
3171  		TiXmlElement *element = childNode-&gt;ToElement();
3172  		const TCHAR *lexerName = element-&gt;Attribute(TEXT(&quot;name&quot;));
3173  		const TCHAR *lexerDesc = element-&gt;Attribute(TEXT(&quot;desc&quot;));
3174  		const TCHAR *lexerUserExt = element-&gt;Attribute(TEXT(&quot;ext&quot;));
3175  		const TCHAR *lexerExcluded = element-&gt;Attribute(TEXT(&quot;excluded&quot;));
3176  		if (lexerName)
3177  		{
3178  			_lexerStylerVect.addLexerStyler(lexerName, lexerDesc, lexerUserExt, childNode);
3179  			if (lexerExcluded != NULL &amp;&amp; (lstrcmp(lexerExcluded, TEXT(&quot;yes&quot;)) == 0))
3180  			{
3181  				int index = getExternalLangIndexFromName(lexerName);
3182  				if (index != -1)
3183  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)(index + L_EXTERNAL)));
3184  			}
3185  		}
3186  	}
3187  	_lexerStylerVect.sort();
3188  	TiXmlNode *globalStyleRoot = node-&gt;FirstChildElement(TEXT(&quot;GlobalStyles&quot;));
3189  	if (!globalStyleRoot) return false;
3190  	for (TiXmlNode *childNode = globalStyleRoot-&gt;FirstChildElement(TEXT(&quot;WidgetStyle&quot;));
3191  		 childNode ;
3192  		 childNode = childNode-&gt;NextSibling(TEXT(&quot;WidgetStyle&quot;)) )
3193  	{
3194  		TiXmlElement *element = childNode-&gt;ToElement();
3195  		const TCHAR *styleIDStr = element-&gt;Attribute(TEXT(&quot;styleID&quot;));
3196  		int styleID = -1;
3197  		if ((styleID = decStrVal(styleIDStr)) != -1)
3198  		{
3199  			_widgetStyleArray.addStyler(styleID, childNode);
3200  		}
3201  	}
3202  	constexpr auto rgbhex = [](COLORREF bbggrr) -&gt; int {
3203  		return
3204  			((bbggrr &amp; 0xFF0000) &gt;&gt; 16) |
3205  			((bbggrr &amp; 0x00FF00)) |
3206  			((bbggrr &amp; 0x0000FF) &lt;&lt; 16);
3207  	};
3208  	const Style* pStyle = _widgetStyleArray.findByName(TEXT(&quot;EOL custom color&quot;));
3209  	if (!pStyle)
3210  	{
3211  		TiXmlNode* eolColorkNode = globalStyleRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;WidgetStyle&quot;)));
3212  		eolColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;EOL custom color&quot;));
3213  		eolColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;styleID&quot;), TEXT(&quot;0&quot;));
3214  		eolColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;fgColor&quot;), TEXT(&quot;DADADA&quot;));
3215  		_widgetStyleArray.addStyler(0, eolColorkNode);
3216  	}
3217  	const Style* pStyleNpc = _widgetStyleArray.findByName(g_npcStyleName);
3218  	if (!pStyleNpc)
3219  	{
3220  		TiXmlNode* npcColorkNode = globalStyleRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;WidgetStyle&quot;)));
3221  		npcColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;name&quot;), g_npcStyleName);
3222  		npcColorkNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;styleID&quot;), TEXT(&quot;0&quot;));
3223  		const Style* pStyleWS = _widgetStyleArray.findByName(TEXT(&quot;White space symbol&quot;));
3224  		if (pStyleWS)
3225  		{
3226  			constexpr size_t bufSize = 7;
3227  			wchar_t strColor[bufSize] = { &#x27;\0&#x27; };
3228  			swprintf(strColor, bufSize, L&quot;%6X&quot;, rgbhex(pStyleWS-&gt;_fgColor));
3229  			npcColorkNode-&gt;ToElement()-&gt;SetAttribute(L&quot;fgColor&quot;, strColor);
3230  		}
3231  		else
3232  		{
3233  			npcColorkNode-&gt;ToElement()-&gt;SetAttribute(L&quot;fgColor&quot;, L&quot;DADADA&quot;);
3234  		}
3235  		_widgetStyleArray.addStyler(0, npcColorkNode);
3236  	}
3237  	return true;
3238  }
3239  void LexerStylerArray::addLexerStyler(const TCHAR *lexerName, const TCHAR *lexerDesc, const TCHAR *lexerUserExt , TiXmlNode *lexerNode)
3240  {
3241  	_lexerStylerVect.emplace_back();
3242  	LexerStyler &amp; ls = _lexerStylerVect.back();
3243  	ls.setLexerName(lexerName);
3244  	if (lexerDesc)
3245  		ls.setLexerDesc(lexerDesc);
3246  	if (lexerUserExt)
3247  		ls.setLexerUserExt(lexerUserExt);
3248  	for (TiXmlNode *childNode = lexerNode-&gt;FirstChildElement(TEXT(&quot;WordsStyle&quot;));
3249  		 childNode ;
3250  		 childNode = childNode-&gt;NextSibling(TEXT(&quot;WordsStyle&quot;)) )
3251  	{
3252  		TiXmlElement *element = childNode-&gt;ToElement();
3253  		const TCHAR *styleIDStr = element-&gt;Attribute(TEXT(&quot;styleID&quot;));
3254  		if (styleIDStr)
3255  		{
3256  			int styleID = -1;
3257  			if ((styleID = decStrVal(styleIDStr)) != -1)
3258  			{
3259  				ls.addStyler(styleID, childNode);
3260  			}
3261  		}
3262  	}
3263  }
3264  void StyleArray::addStyler(int styleID, TiXmlNode *styleNode)
3265  {
3266  	bool isUser = styleID &gt;&gt; 16 == L_USER;
3267  	if (isUser)
3268  	{
3269  		styleID = (styleID &amp; 0xFFFF);
3270  		if (styleID &gt;= SCE_USER_STYLE_TOTAL_STYLES || findByID(styleID))
3271  			return;
3272  	}
3273  	_styleVect.emplace_back();
3274  	Style &amp; s = _styleVect.back();
3275  	s._styleID = styleID;
3276  	if (styleNode)
3277  	{
3278  		TiXmlElement *element = styleNode-&gt;ToElement();
3279  		const TCHAR *str = element-&gt;Attribute(TEXT(&quot;name&quot;));
3280  		if (str)
3281  		{
3282  			if (isUser)
3283  				s._styleDesc = globalMappper().styleNameMapper[styleID];
3284  			else
3285  				s._styleDesc = str;
3286  		}
3287  		str = element-&gt;Attribute(TEXT(&quot;fgColor&quot;));
3288  		if (str)
3289  		{
3290  			unsigned long result = hexStrVal(str);
3291  			s._fgColor = (RGB((result &gt;&gt; 16) &amp; 0xFF, (result &gt;&gt; 8) &amp; 0xFF, result &amp; 0xFF)) | (result &amp; 0xFF000000);
3292  		}
3293  		str = element-&gt;Attribute(TEXT(&quot;bgColor&quot;));
3294  		if (str)
3295  		{
3296  			unsigned long result = hexStrVal(str);
3297  			s._bgColor = (RGB((result &gt;&gt; 16) &amp; 0xFF, (result &gt;&gt; 8) &amp; 0xFF, result &amp; 0xFF)) | (result &amp; 0xFF000000);
3298  		}
3299  		str = element-&gt;Attribute(TEXT(&quot;colorStyle&quot;));
3300  		if (str)
3301  		{
3302  			s._colorStyle = decStrVal(str);
3303  		}
3304  		str = element-&gt;Attribute(TEXT(&quot;fontName&quot;));
3305  		if (str)
3306  		{
3307  			s._fontName = str;
3308  			s._isFontEnabled = true;
3309  		}
3310  		str = element-&gt;Attribute(TEXT(&quot;fontStyle&quot;));
3311  		if (str)
3312  		{
3313  			s._fontStyle = decStrVal(str);
3314  		}
3315  		str = element-&gt;Attribute(TEXT(&quot;fontSize&quot;));
3316  		if (str)
3317  		{
3318  			s._fontSize = decStrVal(str);
3319  		}
3320  		str = element-&gt;Attribute(TEXT(&quot;nesting&quot;));
3321  		if (str)
3322  		{
3323  			s._nesting = decStrVal(str);
3324  		}
3325  		str = element-&gt;Attribute(TEXT(&quot;keywordClass&quot;));
3326  		if (str)
3327  		{
3328  			s._keywordClass = getKwClassFromName(str);
3329  		}
3330  		TiXmlNode *v = styleNode-&gt;FirstChild();
3331  		if (v)
3332  		{
3333  			s._keywords = v-&gt;Value();
3334  		}
3335  	}
3336  }
3337  bool NppParameters::writeRecentFileHistorySettings(int nbMaxFile) const
3338  {
3339  	if (!_pXmlUserDoc) return false;
3340  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3341  	if (!nppRoot)
3342  	{
3343  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3344  	}
3345  	TiXmlNode *historyNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;History&quot;));
3346  	if (!historyNode)
3347  	{
3348  		historyNode = nppRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;History&quot;)));
3349  	}
3350  	(historyNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFile&quot;), nbMaxFile!=-1?nbMaxFile:_nbMaxRecentFile);
3351  	(historyNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;inSubMenu&quot;), _putRecentFileInSubMenu?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
3352  	(historyNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;customLength&quot;), _recentFileCustomLength);
3353  	return true;
3354  }
3355  bool NppParameters::writeColumnEditorSettings() const
3356  {
3357  	if (!_pXmlUserDoc) return false;
3358  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3359  	if (!nppRoot)
3360  	{
3361  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3362  	}
3363  	TiXmlNode *oldColumnEditorNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;ColumnEditor&quot;));
3364  	if (oldColumnEditorNode)
3365  	{
3366  		nppRoot-&gt;RemoveChild(oldColumnEditorNode);
3367  	}
3368  	TiXmlElement columnEditorRootNode{TEXT(&quot;ColumnEditor&quot;)};
3369  	(columnEditorRootNode.ToElement())-&gt;SetAttribute(TEXT(&quot;choice&quot;), _columnEditParam._mainChoice == activeNumeric ? L&quot;number&quot; : L&quot;text&quot;);
3370  	TiXmlElement textNode{ TEXT(&quot;text&quot;) };
3371  	(textNode.ToElement())-&gt;SetAttribute(TEXT(&quot;content&quot;), _columnEditParam._insertedTextContent.c_str());
3372  	(columnEditorRootNode.ToElement())-&gt;InsertEndChild(textNode);
3373  	TiXmlElement numberNode{ TEXT(&quot;number&quot;) };
3374  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;initial&quot;), _columnEditParam._initialNum);
3375  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;increase&quot;), _columnEditParam._increaseNum);
3376  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;repeat&quot;), _columnEditParam._repeatNum);
3377  	wstring format = TEXT(&quot;dec&quot;);
3378  	if (_columnEditParam._formatChoice == 1)
3379  		format = TEXT(&quot;hex&quot;);
3380  	else if (_columnEditParam._formatChoice == 2)
3381  		format = TEXT(&quot;oct&quot;);
3382  	else if (_columnEditParam._formatChoice == 3)
3383  		format = TEXT(&quot;bin&quot;);
3384  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;formatChoice&quot;), format);
3385  	wstring leading = TEXT(&quot;none&quot;);
3386  	if (_columnEditParam._leadingChoice == ColumnEditorParam::zeroLeading)
3387  		leading = TEXT(&quot;zeros&quot;);
3388  	else if (_columnEditParam._leadingChoice == ColumnEditorParam::spaceLeading)
3389  		leading = TEXT(&quot;spaces&quot;);
3390  	(numberNode.ToElement())-&gt;SetAttribute(TEXT(&quot;leadingChoice&quot;), leading);
3391  	(columnEditorRootNode.ToElement())-&gt;InsertEndChild(numberNode);
3392  	(nppRoot-&gt;ToElement())-&gt;InsertEndChild(columnEditorRootNode);
3393  	return true;
3394  }
3395  bool NppParameters::writeProjectPanelsSettings() const
3396  {
3397  	if (!_pXmlUserDoc) return false;
3398  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3399  	if (!nppRoot)
3400  	{
3401  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3402  	}
3403  	TiXmlNode *oldProjPanelRootNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;ProjectPanels&quot;));
3404  	if (oldProjPanelRootNode)
3405  	{
3406  		nppRoot-&gt;RemoveChild(oldProjPanelRootNode);
3407  	}
3408  	TiXmlElement projPanelRootNode{TEXT(&quot;ProjectPanels&quot;)};
3409  	for (int32_t i = 0 ; i &lt; 3 ; ++i)
3410  	{
3411  		TiXmlElement projPanelNode{TEXT(&quot;ProjectPanel&quot;)};
3412  		(projPanelNode.ToElement())-&gt;SetAttribute(TEXT(&quot;id&quot;), i);
3413  		(projPanelNode.ToElement())-&gt;SetAttribute(TEXT(&quot;workSpaceFile&quot;), _workSpaceFilePathes[i]);
3414  		(projPanelRootNode.ToElement())-&gt;InsertEndChild(projPanelNode);
3415  	}
3416  	(nppRoot-&gt;ToElement())-&gt;InsertEndChild(projPanelRootNode);
3417  	return true;
3418  }
3419  bool NppParameters::writeFileBrowserSettings(const vector&lt;generic_string&gt; &amp; rootPaths, const generic_string &amp; latestSelectedItemPath) const
3420  {
3421  	if (!_pXmlUserDoc) return false;
3422  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3423  	if (!nppRoot)
3424  	{
3425  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3426  	}
3427  	TiXmlNode *oldFileBrowserRootNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;FileBrowser&quot;));
3428  	if (oldFileBrowserRootNode)
3429  	{
3430  		nppRoot-&gt;RemoveChild(oldFileBrowserRootNode);
3431  	}
3432  	TiXmlElement fileBrowserRootNode{ TEXT(&quot;FileBrowser&quot;) };
3433  	if (rootPaths.size() != 0)
3434  	{
3435  		fileBrowserRootNode.SetAttribute(TEXT(&quot;latestSelectedItem&quot;), latestSelectedItemPath.c_str());
3436  		size_t len = rootPaths.size();
3437  		for (size_t i = 0; i &lt; len; ++i)
3438  		{
3439  			TiXmlElement fbRootNode{ TEXT(&quot;root&quot;) };
3440  			(fbRootNode.ToElement())-&gt;SetAttribute(TEXT(&quot;foldername&quot;), rootPaths[i].c_str());
3441  			(fileBrowserRootNode.ToElement())-&gt;InsertEndChild(fbRootNode);
3442  		}
3443  	}
3444  	(nppRoot-&gt;ToElement())-&gt;InsertEndChild(fileBrowserRootNode);
3445  	return true;
3446  }
3447  bool NppParameters::writeHistory(const TCHAR *fullpath)
3448  {
3449  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
3450  	if (!nppRoot)
3451  	{
3452  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
3453  	}
3454  	TiXmlNode *historyNode = nppRoot-&gt;FirstChildElement(TEXT(&quot;History&quot;));
3455  	if (!historyNode)
3456  	{
3457  		historyNode = nppRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;History&quot;)));
3458  	}
3459  	TiXmlElement recentFileNode(TEXT(&quot;File&quot;));
3460  	(recentFileNode.ToElement())-&gt;SetAttribute(TEXT(&quot;filename&quot;), fullpath);
3461  	(historyNode-&gt;ToElement())-&gt;InsertEndChild(recentFileNode);
3462  	return true;
3463  }
3464  TiXmlNode * NppParameters::getChildElementByAttribut(TiXmlNode *pere, const TCHAR *childName,\
3465  			const TCHAR *attributName, const TCHAR *attributVal) const
3466  {
3467  	for (TiXmlNode *childNode = pere-&gt;FirstChildElement(childName);
3468  		childNode ;
3469  		childNode = childNode-&gt;NextSibling(childName))
3470  	{
3471  		TiXmlElement *element = childNode-&gt;ToElement();
3472  		const TCHAR *val = element-&gt;Attribute(attributName);
3473  		if (val)
3474  		{
3475  			if (!lstrcmp(val, attributVal))
3476  				return childNode;
3477  		}
3478  	}
3479  	return NULL;
3480  }
3481  LangType NppParameters::getLangIDFromStr(const TCHAR *langName)
3482  {
3483  	int lang = static_cast&lt;int32_t&gt;(L_TEXT);
3484  	for (; lang &lt; L_EXTERNAL; ++lang)
3485  	{
3486  		const TCHAR * name = ScintillaEditView::_langNameInfoArray[lang]._langName;
3487  		if (!lstrcmp(name, langName)) 
3488  		{
3489  			return (LangType)lang;
3490  		}
3491  	}
3492  	LangType l = (LangType)lang;
3493  	if (l == L_EXTERNAL) 
3494  	{
3495  		int id = NppParameters::getInstance().getExternalLangIndexFromName(langName);
3496  		if (id != -1) return (LangType)(id + L_EXTERNAL);
3497  	}
3498  	return L_TEXT;
3499  }
3500  generic_string NppParameters::getLocPathFromStr(const generic_string &amp; localizationCode)
3501  {
3502  	if (localizationCode == TEXT(&quot;en&quot;) || localizationCode == TEXT(&quot;en-au&quot;) || localizationCode == TEXT(&quot;en-bz&quot;) || localizationCode == TEXT(&quot;en-ca&quot;) || localizationCode == TEXT(&quot;en-cb&quot;) || localizationCode == TEXT(&quot;en-gb&quot;) || localizationCode == TEXT(&quot;en-ie&quot;) || localizationCode == TEXT(&quot;en-jm&quot;) || localizationCode == TEXT(&quot;en-nz&quot;) || localizationCode == TEXT(&quot;en-ph&quot;) || localizationCode == TEXT(&quot;en-tt&quot;) || localizationCode == TEXT(&quot;en-us&quot;) || localizationCode == TEXT(&quot;en-za&quot;) || localizationCode == TEXT(&quot;en-zw&quot;))
3503  		return TEXT(&quot;english.xml&quot;);
3504  	if (localizationCode == TEXT(&quot;af&quot;))
3505  		return TEXT(&quot;afrikaans.xml&quot;);
3506  	if (localizationCode == TEXT(&quot;sq&quot;))
3507  		return TEXT(&quot;albanian.xml&quot;);
3508  	if (localizationCode == TEXT(&quot;ar&quot;) || localizationCode == TEXT(&quot;ar-dz&quot;) || localizationCode == TEXT(&quot;ar-bh&quot;) || localizationCode == TEXT(&quot;ar-eg&quot;) ||localizationCode == TEXT(&quot;ar-iq&quot;) || localizationCode == TEXT(&quot;ar-jo&quot;) || localizationCode == TEXT(&quot;ar-kw&quot;) || localizationCode == TEXT(&quot;ar-lb&quot;) || localizationCode == TEXT(&quot;ar-ly&quot;) || localizationCode == TEXT(&quot;ar-ma&quot;) || localizationCode == TEXT(&quot;ar-om&quot;) || localizationCode == TEXT(&quot;ar-qa&quot;) || localizationCode == TEXT(&quot;ar-sa&quot;) || localizationCode == TEXT(&quot;ar-sy&quot;) || localizationCode == TEXT(&quot;ar-tn&quot;) || localizationCode == TEXT(&quot;ar-ae&quot;) || localizationCode == TEXT(&quot;ar-ye&quot;))
3509  		return TEXT(&quot;arabic.xml&quot;);
3510  	if (localizationCode == TEXT(&quot;an&quot;))
3511  		return TEXT(&quot;aragonese.xml&quot;);
3512  	if (localizationCode == TEXT(&quot;az&quot;))
3513  		return TEXT(&quot;azerbaijani.xml&quot;);
3514  	if (localizationCode == TEXT(&quot;eu&quot;))
3515  		return TEXT(&quot;basque.xml&quot;);
3516  	if (localizationCode == TEXT(&quot;be&quot;))
3517  		return TEXT(&quot;belarusian.xml&quot;);
3518  	if (localizationCode == TEXT(&quot;bn&quot;))
3519  		return TEXT(&quot;bengali.xml&quot;);
3520  	if (localizationCode == TEXT(&quot;bs&quot;))
3521  		return TEXT(&quot;bosnian.xml&quot;);
3522  	if (localizationCode == TEXT(&quot;pt-br&quot;))
3523  		return TEXT(&quot;brazilian_portuguese.xml&quot;);
3524  	if (localizationCode == TEXT(&quot;br-fr&quot;))
3525  		return TEXT(&quot;breton.xml&quot;);
3526  	if (localizationCode == TEXT(&quot;bg&quot;))
3527  		return TEXT(&quot;bulgarian.xml&quot;);
3528  	if (localizationCode == TEXT(&quot;ca&quot;))
3529  		return TEXT(&quot;catalan.xml&quot;);
3530  	if (localizationCode == TEXT(&quot;zh-tw&quot;) || localizationCode == TEXT(&quot;zh-hk&quot;) || localizationCode == TEXT(&quot;zh-sg&quot;))
3531  		return TEXT(&quot;taiwaneseMandarin.xml&quot;);
3532  	if (localizationCode == TEXT(&quot;zh&quot;) || localizationCode == TEXT(&quot;zh-cn&quot;))
3533  		return TEXT(&quot;chineseSimplified.xml&quot;);
3534  	if (localizationCode == TEXT(&quot;co&quot;) || localizationCode == TEXT(&quot;co-fr&quot;))
3535  		return TEXT(&quot;corsican.xml&quot;);
3536  	if (localizationCode == TEXT(&quot;hr&quot;))
3537  		return TEXT(&quot;croatian.xml&quot;);
3538  	if (localizationCode == TEXT(&quot;cs&quot;))
3539  		return TEXT(&quot;czech.xml&quot;);
3540  	if (localizationCode == TEXT(&quot;da&quot;))
3541  		return TEXT(&quot;danish.xml&quot;);
3542  	if (localizationCode == TEXT(&quot;nl&quot;) || localizationCode == TEXT(&quot;nl-be&quot;))
3543  		return TEXT(&quot;dutch.xml&quot;);
3544  	if (localizationCode == TEXT(&quot;eo&quot;))
3545  		return TEXT(&quot;esperanto.xml&quot;);
3546  	if (localizationCode == TEXT(&quot;et&quot;))
3547  		return TEXT(&quot;estonian.xml&quot;);
3548  	if (localizationCode == TEXT(&quot;fa&quot;))
3549  		return TEXT(&quot;farsi.xml&quot;);
3550  	if (localizationCode == TEXT(&quot;fi&quot;))
3551  		return TEXT(&quot;finnish.xml&quot;);
3552  	if (localizationCode == TEXT(&quot;fr&quot;) || localizationCode == TEXT(&quot;fr-be&quot;) || localizationCode == TEXT(&quot;fr-ca&quot;) || localizationCode == TEXT(&quot;fr-fr&quot;) || localizationCode == TEXT(&quot;fr-lu&quot;) || localizationCode == TEXT(&quot;fr-mc&quot;) || localizationCode == TEXT(&quot;fr-ch&quot;))
3553  		return TEXT(&quot;french.xml&quot;);
3554  	if (localizationCode == TEXT(&quot;fur&quot;))
3555  		return TEXT(&quot;friulian.xml&quot;);
3556  	if (localizationCode == TEXT(&quot;gl&quot;))
3557  		return TEXT(&quot;galician.xml&quot;);
3558  	if (localizationCode == TEXT(&quot;ka&quot;))
3559  		return TEXT(&quot;georgian.xml&quot;);
3560  	if (localizationCode == TEXT(&quot;de&quot;) || localizationCode == TEXT(&quot;de-at&quot;) || localizationCode == TEXT(&quot;de-de&quot;) || localizationCode == TEXT(&quot;de-li&quot;) || localizationCode == TEXT(&quot;de-lu&quot;) || localizationCode == TEXT(&quot;de-ch&quot;))
3561  		return TEXT(&quot;german.xml&quot;);
3562  	if (localizationCode == TEXT(&quot;el&quot;))
3563  		return TEXT(&quot;greek.xml&quot;);
3564  	if (localizationCode == TEXT(&quot;gu&quot;))
3565  		return TEXT(&quot;gujarati.xml&quot;);
3566  	if (localizationCode == TEXT(&quot;he&quot;))
3567  		return TEXT(&quot;hebrew.xml&quot;);
3568  	if (localizationCode == TEXT(&quot;hi&quot;))
3569  		return TEXT(&quot;hindi.xml&quot;);
3570  	if (localizationCode == TEXT(&quot;hu&quot;))
3571  		return TEXT(&quot;hungarian.xml&quot;);
3572  	if (localizationCode == TEXT(&quot;id&quot;))
3573  		return TEXT(&quot;indonesian.xml&quot;);
3574  	if (localizationCode == TEXT(&quot;it&quot;) || localizationCode == TEXT(&quot;it-ch&quot;))
3575  		return TEXT(&quot;italian.xml&quot;);
3576  	if (localizationCode == TEXT(&quot;ja&quot;))
3577  		return TEXT(&quot;japanese.xml&quot;);
3578  	if (localizationCode == TEXT(&quot;kn&quot;))
3579  		return TEXT(&quot;kannada.xml&quot;);
3580  	if (localizationCode == TEXT(&quot;kk&quot;))
3581  		return TEXT(&quot;kazakh.xml&quot;);
3582  	if (localizationCode == TEXT(&quot;ko&quot;) || localizationCode == TEXT(&quot;ko-kp&quot;) || localizationCode == TEXT(&quot;ko-kr&quot;))
3583  		return TEXT(&quot;korean.xml&quot;);
3584  	if (localizationCode == TEXT(&quot;ku&quot;))
3585  		return TEXT(&quot;kurdish.xml&quot;);
3586  	if (localizationCode == TEXT(&quot;ky&quot;))
3587  		return TEXT(&quot;kyrgyz.xml&quot;);
3588  	if (localizationCode == TEXT(&quot;lv&quot;))
3589  		return TEXT(&quot;latvian.xml&quot;);
3590  	if (localizationCode == TEXT(&quot;lt&quot;))
3591  		return TEXT(&quot;lithuanian.xml&quot;);
3592  	if (localizationCode == TEXT(&quot;lb&quot;))
3593  		return TEXT(&quot;luxembourgish.xml&quot;);
3594  	if (localizationCode == TEXT(&quot;mk&quot;))
3595  		return TEXT(&quot;macedonian.xml&quot;);
3596  	if (localizationCode == TEXT(&quot;ms&quot;))
3597  		return TEXT(&quot;malay.xml&quot;);
3598  	if (localizationCode == TEXT(&quot;mr&quot;))
3599  		return TEXT(&quot;marathi.xml&quot;);
3600  	if (localizationCode == TEXT(&quot;mn&quot;))
3601  		return TEXT(&quot;mongolian.xml&quot;);
3602  	if (localizationCode == TEXT(&quot;no&quot;) || localizationCode == TEXT(&quot;nb&quot;))
3603  		return TEXT(&quot;norwegian.xml&quot;);
3604  	if (localizationCode == TEXT(&quot;nn&quot;))
3605  		return TEXT(&quot;nynorsk.xml&quot;);
3606  	if (localizationCode == TEXT(&quot;oc&quot;))
3607  		return TEXT(&quot;occitan.xml&quot;);
3608  	if (localizationCode == TEXT(&quot;pl&quot;))
3609  		return TEXT(&quot;polish.xml&quot;);
3610  	if (localizationCode == TEXT(&quot;pt&quot;) || localizationCode == TEXT(&quot;pt-pt&quot;))
3611  		return TEXT(&quot;portuguese.xml&quot;);
3612  	if (localizationCode == TEXT(&quot;pa&quot;) || localizationCode == TEXT(&quot;pa-in&quot;))
3613  		return TEXT(&quot;punjabi.xml&quot;);
3614  	if (localizationCode == TEXT(&quot;ro&quot;) || localizationCode == TEXT(&quot;ro-mo&quot;))
3615  		return TEXT(&quot;romanian.xml&quot;);
3616  	if (localizationCode == TEXT(&quot;ru&quot;) || localizationCode == TEXT(&quot;ru-mo&quot;))
3617  		return TEXT(&quot;russian.xml&quot;);
3618  	if (localizationCode == TEXT(&quot;sc&quot;))
3619  		return TEXT(&quot;sardinian.xml&quot;);
3620  	if (localizationCode == TEXT(&quot;sr&quot;))
3621  		return TEXT(&quot;serbian.xml&quot;);
3622  	if (localizationCode == TEXT(&quot;sr-cyrl-ba&quot;) || localizationCode == TEXT(&quot;sr-cyrl-sp&quot;))
3623  		return TEXT(&quot;serbianCyrillic.xml&quot;);
3624  	if (localizationCode == TEXT(&quot;si&quot;))
3625  		return TEXT(&quot;sinhala.xml&quot;);
3626  	if (localizationCode == TEXT(&quot;sk&quot;))
3627  		return TEXT(&quot;slovak.xml&quot;);
3628  	if (localizationCode == TEXT(&quot;sl&quot;))
3629  		return TEXT(&quot;slovenian.xml&quot;);
3630  	if (localizationCode == TEXT(&quot;es&quot;) || localizationCode == TEXT(&quot;es-bo&quot;) || localizationCode == TEXT(&quot;es-cl&quot;) || localizationCode == TEXT(&quot;es-co&quot;) || localizationCode == TEXT(&quot;es-cr&quot;) || localizationCode == TEXT(&quot;es-do&quot;) || localizationCode == TEXT(&quot;es-ec&quot;) || localizationCode == TEXT(&quot;es-sv&quot;) || localizationCode == TEXT(&quot;es-gt&quot;) || localizationCode == TEXT(&quot;es-hn&quot;) || localizationCode == TEXT(&quot;es-mx&quot;) || localizationCode == TEXT(&quot;es-ni&quot;) || localizationCode == TEXT(&quot;es-pa&quot;) || localizationCode == TEXT(&quot;es-py&quot;) || localizationCode == TEXT(&quot;es-pe&quot;) || localizationCode == TEXT(&quot;es-pr&quot;) || localizationCode == TEXT(&quot;es-es&quot;) || localizationCode == TEXT(&quot;es-uy&quot;) || localizationCode == TEXT(&quot;es-ve&quot;))
3631  		return TEXT(&quot;spanish.xml&quot;);
3632  	if (localizationCode == TEXT(&quot;es-ar&quot;))
3633  		return TEXT(&quot;spanish_ar.xml&quot;);
3634  	if (localizationCode == TEXT(&quot;sv&quot;))
3635  		return TEXT(&quot;swedish.xml&quot;);
3636  	if (localizationCode == TEXT(&quot;tl&quot;))
3637  		return TEXT(&quot;tagalog.xml&quot;);
3638  	if (localizationCode == TEXT(&quot;tg-cyrl-tj&quot;))
3639  		return TEXT(&quot;tajikCyrillic.xml&quot;);
3640  	if (localizationCode == TEXT(&quot;ta&quot;))
3641  		return TEXT(&quot;tamil.xml&quot;);
3642  	if (localizationCode == TEXT(&quot;tt&quot;))
3643  		return TEXT(&quot;tatar.xml&quot;);
3644  	if (localizationCode == TEXT(&quot;te&quot;))
3645  		return TEXT(&quot;telugu.xml&quot;);
3646  	if (localizationCode == TEXT(&quot;th&quot;))
3647  		return TEXT(&quot;thai.xml&quot;);
3648  	if (localizationCode == TEXT(&quot;tr&quot;))
3649  		return TEXT(&quot;turkish.xml&quot;);
3650  	if (localizationCode == TEXT(&quot;uk&quot;))
3651  		return TEXT(&quot;ukrainian.xml&quot;);
3652  	if (localizationCode == TEXT(&quot;ur&quot;) || localizationCode == TEXT(&quot;ur-pk&quot;))
3653  		return TEXT(&quot;urdu.xml&quot;);
3654  	if (localizationCode == TEXT(&quot;ug-cn&quot;))
3655  		return TEXT(&quot;uyghur.xml&quot;);
3656  	if (localizationCode == TEXT(&quot;uz&quot;))
3657  		return TEXT(&quot;uzbek.xml&quot;);
3658  	if (localizationCode == TEXT(&quot;uz-cyrl-uz&quot;))
3659  		return TEXT(&quot;uzbekCyrillic.xml&quot;);
3660  	if (localizationCode == TEXT(&quot;vec&quot;))
3661  		return TEXT(&quot;venetian.xml&quot;);
3662  	if (localizationCode == TEXT(&quot;vi&quot;) || localizationCode == TEXT(&quot;vi-vn&quot;))
3663  		return TEXT(&quot;vietnamese.xml&quot;);
3664  	if (localizationCode == TEXT(&quot;cy-gb&quot;))
3665  		return TEXT(&quot;welsh.xml&quot;);
3666  	if (localizationCode == TEXT(&quot;zu&quot;) || localizationCode == TEXT(&quot;zu-za&quot;))
3667  		return TEXT(&quot;zulu.xml&quot;);
3668  	if (localizationCode == TEXT(&quot;ne&quot;) || localizationCode == TEXT(&quot;nep&quot;))
3669  		return TEXT(&quot;nepali.xml&quot;);
3670  	if (localizationCode == TEXT(&quot;oc-aranes&quot;))
3671  		return TEXT(&quot;aranese.xml&quot;);
3672  	if (localizationCode == TEXT(&quot;exy&quot;))
3673  		return TEXT(&quot;extremaduran.xml&quot;);
3674  	if (localizationCode == TEXT(&quot;keb&quot;))
3675  		return TEXT(&quot;kabyle.xml&quot;);
3676  	if (localizationCode == TEXT(&quot;lij&quot;))
3677  		return TEXT(&quot;ligurian.xml&quot;);
3678  	if (localizationCode == TEXT(&quot;ga&quot;))
3679  		return TEXT(&quot;irish.xml&quot;);
3680  	if (localizationCode == TEXT(&quot;sgs&quot;))
3681  		return TEXT(&quot;samogitian.xml&quot;);
3682  	if (localizationCode == TEXT(&quot;yue&quot;))
3683  		return TEXT(&quot;hongKongCantonese.xml&quot;);
3684  	if (localizationCode == TEXT(&quot;ab&quot;) || localizationCode == TEXT(&quot;abk&quot;))
3685  		return TEXT(&quot;abkhazian.xml&quot;);
3686  	return generic_string();
3687  }
3688  void NppParameters::feedKeyWordsParameters(TiXmlNode *node)
3689  {
3690  	TiXmlNode *langRoot = node-&gt;FirstChildElement(TEXT(&quot;Languages&quot;));
3691  	if (!langRoot)
3692  		return;
3693  	for (TiXmlNode *langNode = langRoot-&gt;FirstChildElement(TEXT(&quot;Language&quot;));
3694  		langNode ;
3695  		langNode = langNode-&gt;NextSibling(TEXT(&quot;Language&quot;)) )
3696  	{
3697  		if (_nbLang &lt; NB_LANG)
3698  		{
3699  			TiXmlElement* element = langNode-&gt;ToElement();
3700  			const TCHAR* name = element-&gt;Attribute(TEXT(&quot;name&quot;));
3701  			if (name)
3702  			{
3703  				_langList[_nbLang] = new Lang(getLangIDFromStr(name), name);
<span onclick='openModal()' class='match'>3704  				_langList[_nbLang]-&gt;setDefaultExtList(element-&gt;Attribute(TEXT(&quot;ext&quot;)));
3705  				_langList[_nbLang]-&gt;setCommentLineSymbol(element-&gt;Attribute(TEXT(&quot;commentLine&quot;)));
</span>3706  				_langList[_nbLang]-&gt;setCommentStart(element-&gt;Attribute(TEXT(&quot;commentStart&quot;)));
3707  				_langList[_nbLang]-&gt;setCommentEnd(element-&gt;Attribute(TEXT(&quot;commentEnd&quot;)));
3708  				int tabSettings;
3709  				if (element-&gt;Attribute(TEXT(&quot;tabSettings&quot;), &amp;tabSettings))
3710  					_langList[_nbLang]-&gt;setTabInfo(tabSettings);
3711  				for (TiXmlNode *kwNode = langNode-&gt;FirstChildElement(TEXT(&quot;Keywords&quot;));
3712  					kwNode ;
3713  					kwNode = kwNode-&gt;NextSibling(TEXT(&quot;Keywords&quot;)) )
3714  				{
3715  					const TCHAR *indexName = (kwNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;name&quot;));
3716  					TiXmlNode *kwVal = kwNode-&gt;FirstChild();
3717  					const TCHAR *keyWords = TEXT(&quot;&quot;);
3718  					if ((indexName) &amp;&amp; (kwVal))
3719  						keyWords = kwVal-&gt;Value();
3720  					int i = getKwClassFromName(indexName);
3721  					if (i &gt;= 0 &amp;&amp; i &lt;= KEYWORDSET_MAX)
3722  						_langList[_nbLang]-&gt;setWords(keyWords, i);
3723  				}
3724  				++_nbLang;
3725  			}
3726  		}
3727  	}
3728  }
3729  extern &quot;C&quot; {
3730  typedef DWORD (WINAPI * EESFUNC) (LPCTSTR, LPTSTR, DWORD);
3731  }
3732  void NppParameters::feedGUIParameters(TiXmlNode *node)
3733  {
3734  	TiXmlNode *GUIRoot = node-&gt;FirstChildElement(TEXT(&quot;GUIConfigs&quot;));
3735  	if (nullptr == GUIRoot)
3736  		return;
3737  	for (TiXmlNode *childNode = GUIRoot-&gt;FirstChildElement(TEXT(&quot;GUIConfig&quot;));
3738  		childNode ;
3739  		childNode = childNode-&gt;NextSibling(TEXT(&quot;GUIConfig&quot;)) )
3740  	{
3741  		TiXmlElement* element = childNode-&gt;ToElement();
3742  		const TCHAR* nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
3743  		if (nullptr == nm)
3744  			continue;
3745  		auto parseYesNoBoolAttribute = [&amp;element](const TCHAR* name, bool defaultValue = false) -&gt; bool {
3746  			const TCHAR* val = element-&gt;Attribute(name);
3747  			if (val != nullptr)
3748  			{
3749  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3750  					return true;
3751  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3752  					return false;
3753  			}
3754  			return defaultValue;
3755  		};
3756  		if (!lstrcmp(nm, TEXT(&quot;ToolBar&quot;)))
3757  		{
3758  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;visible&quot;));
3759  			if (val)
3760  			{
3761  				if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3762  					_nppGUI._toolbarShow = false;
3763  				else
3764  					_nppGUI._toolbarShow = true;
3765  			}
3766  			TiXmlNode *n = childNode-&gt;FirstChild();
3767  			if (n)
3768  			{
3769  				val = n-&gt;Value();
3770  				if (val)
3771  				{
3772  					if (!lstrcmp(val, TEXT(&quot;small&quot;)))
3773  						_nppGUI._toolBarStatus = TB_SMALL;
3774  					else if (!lstrcmp(val, TEXT(&quot;large&quot;)))
3775  						_nppGUI._toolBarStatus = TB_LARGE;
3776  					else if (!lstrcmp(val, TEXT(&quot;small2&quot;)))
3777  						_nppGUI._toolBarStatus = TB_SMALL2;
3778  					else if (!lstrcmp(val, TEXT(&quot;large2&quot;)))
3779  						_nppGUI._toolBarStatus = TB_LARGE2;
3780  					else 
3781  						_nppGUI._toolBarStatus = TB_STANDARD;
3782  				}
3783  			}
3784  		}
3785  		else if (!lstrcmp(nm, TEXT(&quot;StatusBar&quot;)))
3786  		{
3787  			TiXmlNode *n = childNode-&gt;FirstChild();
3788  			if (n)
3789  			{
3790  				const TCHAR* val = n-&gt;Value();
3791  				if (val)
3792  				{
3793  					if (!lstrcmp(val, TEXT(&quot;hide&quot;)))
3794  						_nppGUI._statusBarShow = false;
3795  					else if (!lstrcmp(val, TEXT(&quot;show&quot;)))
3796  						_nppGUI._statusBarShow = true;
3797  				}
3798  			}
3799  		}
3800  		else if (!lstrcmp(nm, TEXT(&quot;MenuBar&quot;)))
3801  		{
3802  			TiXmlNode *n = childNode-&gt;FirstChild();
3803  			if (n)
3804  			{
3805  				const TCHAR* val = n-&gt;Value();
3806  				if (val)
3807  				{
3808  					if (!lstrcmp(val, TEXT(&quot;hide&quot;)))
3809  						_nppGUI._menuBarShow = false;
3810  					else if (!lstrcmp(val, TEXT(&quot;show&quot;)))
3811  						_nppGUI._menuBarShow = true;
3812  				}
3813  			}
3814  		}
3815  		else if (!lstrcmp(nm, TEXT(&quot;TabBar&quot;)))
3816  		{
3817  			bool isFailed = false;
3818  			int oldValue = _nppGUI._tabStatus;
3819  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;dragAndDrop&quot;));
3820  			if (val)
3821  			{
3822  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3823  					_nppGUI._tabStatus = TAB_DRAGNDROP;
3824  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3825  					_nppGUI._tabStatus = 0;
3826  				else
3827  					isFailed = true;
3828  			}
3829  			val = element-&gt;Attribute(TEXT(&quot;drawTopBar&quot;));
3830  			if (val)
3831  			{
3832  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3833  					_nppGUI._tabStatus |= TAB_DRAWTOPBAR;
3834  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3835  					_nppGUI._tabStatus |= 0;
3836  				else
3837  					isFailed = true;
3838  			}
3839  			val = element-&gt;Attribute(TEXT(&quot;drawInactiveTab&quot;));
3840  			if (val)
3841  			{
3842  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3843  					_nppGUI._tabStatus |= TAB_DRAWINACTIVETAB;
3844  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3845  					_nppGUI._tabStatus |= 0;
3846  				else
3847  					isFailed = true;
3848  			}
3849  			val = element-&gt;Attribute(TEXT(&quot;reduce&quot;));
3850  			if (val)
3851  			{
3852  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3853  					_nppGUI._tabStatus |= TAB_REDUCE;
3854  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3855  					_nppGUI._tabStatus |= 0;
3856  				else
3857  					isFailed = true;
3858  			}
3859  			val = element-&gt;Attribute(TEXT(&quot;closeButton&quot;));
3860  			if (val)
3861  			{
3862  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3863  					_nppGUI._tabStatus |= TAB_CLOSEBUTTON;
3864  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3865  					_nppGUI._tabStatus |= 0;
3866  				else
3867  					isFailed = true;
3868  			}
3869  			val = element-&gt;Attribute(TEXT(&quot;doubleClick2Close&quot;));
3870  			if (val)
3871  			{
3872  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3873  					_nppGUI._tabStatus |= TAB_DBCLK2CLOSE;
3874  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3875  					_nppGUI._tabStatus |= 0;
3876  				else
3877  					isFailed = true;
3878  			}
3879  			val = element-&gt;Attribute(TEXT(&quot;vertical&quot;));
3880  			if (val)
3881  			{
3882  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3883  					_nppGUI._tabStatus |= TAB_VERTICAL;
3884  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3885  					_nppGUI._tabStatus |= 0;
3886  				else
3887  					isFailed = true;
3888  			}
3889  			val = element-&gt;Attribute(TEXT(&quot;multiLine&quot;));
3890  			if (val)
3891  			{
3892  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3893  					_nppGUI._tabStatus |= TAB_MULTILINE;
3894  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3895  					_nppGUI._tabStatus |= 0;
3896  				else
3897  					isFailed = true;
3898  			}
3899  			val = element-&gt;Attribute(TEXT(&quot;hide&quot;));
3900  			if (val)
3901  			{
3902  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3903  					_nppGUI._tabStatus |= TAB_HIDE;
3904  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3905  					_nppGUI._tabStatus |= 0;
3906  				else
3907  					isFailed = true;
3908  			}
3909  			val = element-&gt;Attribute(TEXT(&quot;quitOnEmpty&quot;));
3910  			if (val)
3911  			{
3912  				if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3913  					_nppGUI._tabStatus |= TAB_QUITONEMPTY;
3914  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
3915  					_nppGUI._tabStatus |= 0;
3916  				else
3917  					isFailed = true;
3918  			}
3919  			val = element-&gt;Attribute(TEXT(&quot;iconSetNumber&quot;));
3920  			if (val)
3921  			{
3922  				if (!lstrcmp(val, TEXT(&quot;1&quot;)))
3923  					_nppGUI._tabStatus |= TAB_ALTICONS;
3924  				else if (!lstrcmp(val, TEXT(&quot;0&quot;)))
3925  					_nppGUI._tabStatus |= 0;
3926  				else
3927  					isFailed = true;
3928  			}
3929  			if (isFailed)
3930  				_nppGUI._tabStatus = oldValue;
3931  		}
3932  		else if (!lstrcmp(nm, TEXT(&quot;Auto-detection&quot;)))
3933  		{
3934  			TiXmlNode *n = childNode-&gt;FirstChild();
3935  			if (n)
3936  			{
3937  				const TCHAR* val = n-&gt;Value();
3938  				if (val)
3939  				{
3940  					if (!lstrcmp(val, TEXT(&quot;yesOld&quot;)))
3941  						_nppGUI._fileAutoDetection = cdEnabledOld;
3942  					else if (!lstrcmp(val, TEXT(&quot;autoOld&quot;)))
3943  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate);
3944  					else if (!lstrcmp(val, TEXT(&quot;Update2EndOld&quot;)))
3945  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdGo2end);
3946  					else if (!lstrcmp(val, TEXT(&quot;autoUpdate2EndOld&quot;)))
3947  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate | cdGo2end);
3948  					else if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
3949  						_nppGUI._fileAutoDetection = cdEnabledNew;
3950  					else if (!lstrcmp(val, TEXT(&quot;auto&quot;)))
3951  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate);
3952  					else if (!lstrcmp(val, TEXT(&quot;Update2End&quot;)))
3953  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdGo2end);
3954  					else if (!lstrcmp(val, TEXT(&quot;autoUpdate2End&quot;)))
3955  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate | cdGo2end);
3956  					else 
3957  						_nppGUI._fileAutoDetection = cdDisabled;
3958  				}
3959  			}
3960  		}
3961  		else if (!lstrcmp(nm, TEXT(&quot;TrayIcon&quot;)))
3962  		{
3963  			TiXmlNode *n = childNode-&gt;FirstChild();
3964  			if (n)
3965  			{
3966  				const TCHAR* val = n-&gt;Value();
3967  				if (val)
3968  				{
3969  					_nppGUI._isMinimizedToTray = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
3970  				}
3971  			}
3972  		}
3973  		else if (!lstrcmp(nm, TEXT(&quot;RememberLastSession&quot;)))
3974  		{
3975  			TiXmlNode *n = childNode-&gt;FirstChild();
3976  			if (n)
3977  			{
3978  				const TCHAR* val = n-&gt;Value();
3979  				if (val)
3980  				{
3981  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
3982  						_nppGUI._rememberLastSession = true;
3983  					else
3984  						_nppGUI._rememberLastSession = false;
3985  				}
3986  			}
3987  		}
3988  		else if (!lstrcmp(nm, TEXT(&quot;DetectEncoding&quot;)))
3989  		{
3990  			TiXmlNode *n = childNode-&gt;FirstChild();
3991  			if (n)
3992  			{
3993  				const TCHAR* val = n-&gt;Value();
3994  				if (val)
3995  				{
3996  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
3997  						_nppGUI._detectEncoding = true;
3998  					else
3999  						_nppGUI._detectEncoding = false;
4000  				}
4001  			}
4002  		}
4003  		else if (!lstrcmp(nm, TEXT(&quot;SaveAllConfirm&quot;)))
4004  		{
4005  			TiXmlNode *n = childNode-&gt;FirstChild();
4006  			if (n)
4007  			{
4008  				const TCHAR* val = n-&gt;Value();
4009  				if (val)
4010  				{
4011  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4012  						_nppGUI._saveAllConfirm = true;
4013  					else
4014  						_nppGUI._saveAllConfirm = false;
4015  				}
4016  			}
4017  		}
4018  		else if (lstrcmp(nm, TEXT(&quot;MaitainIndent&quot;)) == 0)
4019  		{
4020  			TiXmlNode *n = childNode-&gt;FirstChild();
4021  			if (n)
4022  			{
4023  				const TCHAR* val = n-&gt;Value();
4024  				if (val)
4025  				{
4026  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4027  						_nppGUI._maitainIndent = true;
4028  					else
4029  						_nppGUI._maitainIndent = false;
4030  				}
4031  			}
4032  		}
4033  		else if (!lstrcmp(nm, TEXT(&quot;MarkAll&quot;)))
4034  		{
4035  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;matchCase&quot;));
4036  			if (val)
4037  			{
4038  				if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4039  					_nppGUI._markAllCaseSensitive = true;
4040  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4041  					_nppGUI._markAllCaseSensitive = false;
4042  			}
4043  			val = element-&gt;Attribute(TEXT(&quot;wholeWordOnly&quot;));
4044  			if (val)
4045  			{
4046  				if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4047  					_nppGUI._markAllWordOnly = true;
4048  				else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4049  					_nppGUI._markAllWordOnly = false;
4050  			}
4051  		}
4052  		else if (!lstrcmp(nm, TEXT(&quot;SmartHighLight&quot;)))
4053  		{
4054  			TiXmlNode *n = childNode-&gt;FirstChild();
4055  			if (n)
4056  			{
4057  				const TCHAR* val = n-&gt;Value();
4058  				if (val)
4059  				{
4060  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4061  						_nppGUI._enableSmartHilite = true;
4062  					else
4063  						_nppGUI._enableSmartHilite = false;
4064  				}
4065  				val = element-&gt;Attribute(TEXT(&quot;matchCase&quot;));
4066  				if (val)
4067  				{
4068  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4069  						_nppGUI._smartHiliteCaseSensitive = true;
4070  					else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4071  						_nppGUI._smartHiliteCaseSensitive = false;
4072  				}
4073  				val = element-&gt;Attribute(TEXT(&quot;wholeWordOnly&quot;));
4074  				if (val)
4075  				{
4076  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4077  						_nppGUI._smartHiliteWordOnly = true;
4078  					else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4079  						_nppGUI._smartHiliteWordOnly = false;
4080  				}
4081  				val = element-&gt;Attribute(TEXT(&quot;useFindSettings&quot;));
4082  				if (val)
4083  				{
4084  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4085  						_nppGUI._smartHiliteUseFindSettings = true;
4086  					else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4087  						_nppGUI._smartHiliteUseFindSettings = false;
4088  				}
4089  				val = element-&gt;Attribute(TEXT(&quot;onAnotherView&quot;));
4090  				if (val)
4091  				{
4092  					if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4093  						_nppGUI._smartHiliteOnAnotherView = true;
4094  					else if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4095  						_nppGUI._smartHiliteOnAnotherView = false;
4096  				}
4097  			}
4098  		}
4099  		else if (!lstrcmp(nm, TEXT(&quot;TagsMatchHighLight&quot;)))
4100  		{
4101  			TiXmlNode *n = childNode-&gt;FirstChild();
4102  			if (n)
4103  			{
4104  				const TCHAR* val = n-&gt;Value();
4105  				if (val)
4106  				{
4107  					_nppGUI._enableTagsMatchHilite = !lstrcmp(val, TEXT(&quot;yes&quot;));
4108  					const TCHAR *tahl = element-&gt;Attribute(TEXT(&quot;TagAttrHighLight&quot;));
4109  					if (tahl)
4110  						_nppGUI._enableTagAttrsHilite = !lstrcmp(tahl, TEXT(&quot;yes&quot;));
4111  					tahl = element-&gt;Attribute(TEXT(&quot;HighLightNonHtmlZone&quot;));
4112  					if (tahl)
4113  						_nppGUI._enableHiliteNonHTMLZone = !lstrcmp(tahl, TEXT(&quot;yes&quot;));
4114  				}
4115  			}
4116  		}
4117  		else if (!lstrcmp(nm, TEXT(&quot;TaskList&quot;)))
4118  		{
4119  			TiXmlNode *n = childNode-&gt;FirstChild();
4120  			if (n)
4121  			{
4122  				const TCHAR* val = n-&gt;Value();
4123  				if (val)
4124  				{
4125  					_nppGUI._doTaskList = (!lstrcmp(val, TEXT(&quot;yes&quot;)))?true:false;
4126  				}
4127  			}
4128  		}
4129  		else if (!lstrcmp(nm, TEXT(&quot;MRU&quot;)))
4130  		{
4131  			TiXmlNode *n = childNode-&gt;FirstChild();
4132  			if (n)
4133  			{
4134  				const TCHAR* val = n-&gt;Value();
4135  				if (val)
4136  					_nppGUI._styleMRU = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4137  			}
4138  		}
4139  		else if (!lstrcmp(nm, TEXT(&quot;URL&quot;)))
4140  		{
4141  			TiXmlNode *n = childNode-&gt;FirstChild();
4142  			if (n)
4143  			{
4144  				const TCHAR* val = n-&gt;Value();
4145  				if (val)
4146  				{
4147  					int const i = _wtoi (val);
4148  					if ((i &gt;= urlMin) &amp;&amp; (i &lt;= urlMax))
4149  						_nppGUI._styleURL = urlMode(i);
4150  				}
4151  			}
4152  		}
4153  		else if (!lstrcmp(nm, TEXT(&quot;uriCustomizedSchemes&quot;)))
4154  		{
4155  			TiXmlNode *n = childNode-&gt;FirstChild();
4156  			if (n)
4157  			{
4158  				const TCHAR* val = n-&gt;Value();
4159  				if (val)
4160  				_nppGUI._uriSchemes = val;
4161  			}
4162  		}
4163  		else if (!lstrcmp(nm, TEXT(&quot;CheckHistoryFiles&quot;)))
4164  		{
4165  			TiXmlNode *n = childNode-&gt;FirstChild();
4166  			if (n)
4167  			{
4168  				const TCHAR* val = n-&gt;Value();
4169  				if (val)
4170  				{
4171  					if (!lstrcmp(val, TEXT(&quot;no&quot;)))
4172  						_nppGUI._checkHistoryFiles = false;
4173  					else if (!lstrcmp(val, TEXT(&quot;yes&quot;)))
4174  						_nppGUI._checkHistoryFiles = true;
4175  				}
4176  			}
4177  		}
4178  		else if (!lstrcmp(nm, TEXT(&quot;ScintillaViewsSplitter&quot;)))
4179  		{
4180  			TiXmlNode *n = childNode-&gt;FirstChild();
4181  			if (n)
4182  			{
4183  				const TCHAR* val = n-&gt;Value();
4184  				if (val)
4185  				{
4186  					if (!lstrcmp(val, TEXT(&quot;vertical&quot;)))
4187  						_nppGUI._splitterPos = POS_VERTICAL;
4188  					else if (!lstrcmp(val, TEXT(&quot;horizontal&quot;)))
4189  						_nppGUI._splitterPos = POS_HORIZOTAL;
4190  				}
4191  			}
4192  		}
4193  		else if (!lstrcmp(nm, TEXT(&quot;UserDefineDlg&quot;)))
4194  		{
4195  			bool isFailed = false;
4196  			int oldValue = _nppGUI._userDefineDlgStatus;
4197  			TiXmlNode *n = childNode-&gt;FirstChild();
4198  			if (n)
4199  			{
4200  				const TCHAR* val = n-&gt;Value();
4201  				if (val)
4202  				{
4203  					if (!lstrcmp(val, TEXT(&quot;hide&quot;)))
4204  						_nppGUI._userDefineDlgStatus = 0;
4205  					else if (!lstrcmp(val, TEXT(&quot;show&quot;)))
4206  						_nppGUI._userDefineDlgStatus = UDD_SHOW;
4207  					else
4208  						isFailed = true;
4209  				}
4210  			}
4211  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;position&quot;));
4212  			if (val)
4213  			{
4214  				if (!lstrcmp(val, TEXT(&quot;docked&quot;)))
4215  					_nppGUI._userDefineDlgStatus |= UDD_DOCKED;
4216  				else if (!lstrcmp(val, TEXT(&quot;undocked&quot;)))
4217  					_nppGUI._userDefineDlgStatus |= 0;
4218  				else
4219  					isFailed = true;
4220  			}
4221  			if (isFailed)
4222  				_nppGUI._userDefineDlgStatus = oldValue;
4223  		}
4224  		else if (!lstrcmp(nm, TEXT(&quot;TabSetting&quot;)))
4225  		{
4226  			int i;
4227  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;size&quot;), &amp;i);
4228  			if (val)
4229  				_nppGUI._tabSize = i;
4230  			if ((_nppGUI._tabSize == -1) || (_nppGUI._tabSize == 0))
4231  				_nppGUI._tabSize = 4;
4232  			val = element-&gt;Attribute(TEXT(&quot;replaceBySpace&quot;));
4233  			if (val)
4234  				_nppGUI._tabReplacedBySpace = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4235  		}
4236  		else if (!lstrcmp(nm, TEXT(&quot;Caret&quot;)))
4237  		{
4238  			int i;
4239  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;width&quot;), &amp;i);
4240  			if (val)
4241  				_nppGUI._caretWidth = i;
4242  			val = element-&gt;Attribute(TEXT(&quot;blinkRate&quot;), &amp;i);
4243  			if (val)
4244  				_nppGUI._caretBlinkRate = i;
4245  		}
4246  		else if (!lstrcmp(nm, TEXT(&quot;ScintillaGlobalSettings&quot;)))
4247  		{
4248  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;enableMultiSelection&quot;));
4249  			if (val)
4250  			{
4251  				if (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0)
4252  					_nppGUI._enableMultiSelection = true;
4253  				else if (lstrcmp(val, TEXT(&quot;no&quot;)) == 0)
4254  					_nppGUI._enableMultiSelection = false;
4255  			}
4256  		}
4257  		else if (!lstrcmp(nm, TEXT(&quot;AppPosition&quot;)))
4258  		{
4259  			RECT oldRect = _nppGUI._appPos;
4260  			bool fuckUp = true;
4261  			int i;
4262  			if (element-&gt;Attribute(TEXT(&quot;x&quot;), &amp;i))
4263  			{
4264  				_nppGUI._appPos.left = i;
4265  				if (element-&gt;Attribute(TEXT(&quot;y&quot;), &amp;i))
4266  				{
4267  					_nppGUI._appPos.top = i;
4268  					if (element-&gt;Attribute(TEXT(&quot;width&quot;), &amp;i))
4269  					{
4270  						_nppGUI._appPos.right = i;
4271  						if (element-&gt;Attribute(TEXT(&quot;height&quot;), &amp;i))
4272  						{
4273  							_nppGUI._appPos.bottom = i;
4274  							fuckUp = false;
4275  						}
4276  					}
4277  				}
4278  			}
4279  			if (fuckUp)
4280  				_nppGUI._appPos = oldRect;
4281  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;isMaximized&quot;));
4282  			if (val)
4283  				_nppGUI._isMaximized = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
4284  		}
4285  		else if (!lstrcmp(nm, TEXT(&quot;FindWindowPosition&quot;)))
4286  		{
4287  			RECT oldRect = _nppGUI._findWindowPos;
4288  			bool incomplete = true;
4289  			int i;
4290  			if (element-&gt;Attribute(TEXT(&quot;left&quot;), &amp;i))
4291  			{
4292  				_nppGUI._findWindowPos.left = i;
4293  				if (element-&gt;Attribute(TEXT(&quot;top&quot;), &amp;i))
4294  				{
4295  					_nppGUI._findWindowPos.top = i;
4296  					if (element-&gt;Attribute(TEXT(&quot;right&quot;), &amp;i))
4297  					{
4298  						_nppGUI._findWindowPos.right = i;
4299  						if (element-&gt;Attribute(TEXT(&quot;bottom&quot;), &amp;i))
4300  						{
4301  							_nppGUI._findWindowPos.bottom = i;
4302  							incomplete = false;
4303  						}
4304  					}
4305  				}
4306  			}
4307  			if (incomplete)
4308  			{
4309  				_nppGUI._findWindowPos = oldRect;
4310  			}
4311  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;isLessModeOn&quot;));
4312  			if (val)
4313  				_nppGUI._findWindowLessMode = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
4314  		}
4315  		else if (!lstrcmp(nm, TEXT(&quot;FinderConfig&quot;)))
4316  		{
4317  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;wrappedLines&quot;));
4318  			if (val)
4319  			{
4320  				_nppGUI._finderLinesAreCurrentlyWrapped = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4321  			}
4322  			val = element-&gt;Attribute(TEXT(&quot;purgeBeforeEverySearch&quot;));
4323  			if (val)
4324  			{
4325  				_nppGUI._finderPurgeBeforeEverySearch = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4326  			}
4327  			val = element-&gt;Attribute(TEXT(&quot;showOnlyOneEntryPerFoundLine&quot;));
4328  			if (val)
4329  			{
4330  				_nppGUI._finderShowOnlyOneEntryPerFoundLine = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4331  			}
4332  		}
4333  		else if (!lstrcmp(nm, TEXT(&quot;NewDocDefaultSettings&quot;)))
4334  		{
4335  			int i;
4336  			if (element-&gt;Attribute(TEXT(&quot;format&quot;), &amp;i))
4337  			{
4338  				EolType newFormat = EolType::osdefault;
4339  				switch (i)
4340  				{
4341  					case static_cast&lt;LPARAM&gt;(EolType::windows) :
4342  						newFormat = EolType::windows;
4343  						break;
4344  					case static_cast&lt;LPARAM&gt;(EolType::macos) :
4345  						newFormat = EolType::macos;
4346  						break;
4347  					case static_cast&lt;LPARAM&gt;(EolType::unix) :
4348  						newFormat = EolType::unix;
4349  						break;
4350  					default:
4351  						assert(false and &quot;invalid buffer format - fallback to default&quot;);
4352  				}
4353  				_nppGUI._newDocDefaultSettings._format = newFormat;
4354  			}
4355  			if (element-&gt;Attribute(TEXT(&quot;encoding&quot;), &amp;i))
4356  				_nppGUI._newDocDefaultSettings._unicodeMode = (UniMode)i;
4357  			if (element-&gt;Attribute(TEXT(&quot;lang&quot;), &amp;i))
4358  				_nppGUI._newDocDefaultSettings._lang = (LangType)i;
4359  			if (element-&gt;Attribute(TEXT(&quot;codepage&quot;), &amp;i))
4360  				_nppGUI._newDocDefaultSettings._codepage = (LangType)i;
4361  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;openAnsiAsUTF8&quot;));
4362  			if (val)
4363  				_nppGUI._newDocDefaultSettings._openAnsiAsUtf8 = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
4364  			val = element-&gt;Attribute(TEXT(&quot;addNewDocumentOnStartup&quot;));
4365  			if (val)
4366  				_nppGUI._newDocDefaultSettings._addNewDocumentOnStartup = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
4367  		}
4368  		else if (!lstrcmp(nm, TEXT(&quot;langsExcluded&quot;)))
4369  		{
4370  			int g0 = 0; 
4371  			int g1 = 0; 
4372  			int g2 = 0; 
4373  			int g3 = 0; 
4374  			int g4 = 0; 
4375  			int g5 = 0; 
4376  			int g6 = 0; 
4377  			int g7 = 0; 
4378  			int g8 = 0; 
4379  			int g9 = 0; 
4380  			int g10= 0; 
4381  			int g11= 0; 
4382  			int g12= 0; 
4383  			{
4384  				int i;
4385  				if (element-&gt;Attribute(TEXT(&quot;gr0&quot;), &amp;i))
4386  				{
4387  					if (i &lt;= 255)
4388  						g0 = i;
4389  				}
4390  				if (element-&gt;Attribute(TEXT(&quot;gr1&quot;), &amp;i))
4391  				{
4392  					if (i &lt;= 255)
4393  						g1 = i;
4394  				}
4395  				if (element-&gt;Attribute(TEXT(&quot;gr2&quot;), &amp;i))
4396  				{
4397  					if (i &lt;= 255)
4398  						g2 = i;
4399  				}
4400  				if (element-&gt;Attribute(TEXT(&quot;gr3&quot;), &amp;i))
4401  				{
4402  					if (i &lt;= 255)
4403  						g3 = i;
4404  				}
4405  				if (element-&gt;Attribute(TEXT(&quot;gr4&quot;), &amp;i))
4406  				{
4407  					if (i &lt;= 255)
4408  						g4 = i;
4409  				}
4410  				if (element-&gt;Attribute(TEXT(&quot;gr5&quot;), &amp;i))
4411  				{
4412  					if (i &lt;= 255)
4413  						g5 = i;
4414  				}
4415  				if (element-&gt;Attribute(TEXT(&quot;gr6&quot;), &amp;i))
4416  				{
4417  					if (i &lt;= 255)
4418  						g6 = i;
4419  				}
4420  				if (element-&gt;Attribute(TEXT(&quot;gr7&quot;), &amp;i))
4421  				{
4422  					if (i &lt;= 255)
4423  						g7 = i;
4424  				}
4425  				if (element-&gt;Attribute(TEXT(&quot;gr8&quot;), &amp;i))
4426  				{
4427  					if (i &lt;= 255)
4428  						g8 = i;
4429  				}
4430  				if (element-&gt;Attribute(TEXT(&quot;gr9&quot;), &amp;i))
4431  				{
4432  					if (i &lt;= 255)
4433  						g9 = i;
4434  				}
4435  				if (element-&gt;Attribute(TEXT(&quot;gr10&quot;), &amp;i))
4436  				{
4437  					if (i &lt;= 255)
4438  						g10 = i;
4439  				}
4440  				if (element-&gt;Attribute(TEXT(&quot;gr11&quot;), &amp;i))
4441  				{
4442  					if (i &lt;= 255)
4443  						g11 = i;
4444  				}
4445  				if (element-&gt;Attribute(TEXT(&quot;gr12&quot;), &amp;i))
4446  				{
4447  					if (i &lt;= 255)
4448  						g12 = i;
4449  				}
4450  			}
4451  			UCHAR mask = 1;
4452  			for (int i = 0 ; i &lt; 8 ; ++i)
4453  			{
4454  				if (mask &amp; g0)
4455  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4456  				mask &lt;&lt;= 1;
4457  			}
4458  			mask = 1;
4459  			for (int i = 8 ; i &lt; 16 ; ++i)
4460  			{
4461  				if (mask &amp; g1)
4462  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4463  				mask &lt;&lt;= 1;
4464  			}
4465  			mask = 1;
4466  			for (int i = 16 ; i &lt; 24 ; ++i)
4467  			{
4468  				if (mask &amp; g2)
4469  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4470  				mask &lt;&lt;= 1;
4471  			}
4472  			mask = 1;
4473  			for (int i = 24 ; i &lt; 32 ; ++i)
4474  			{
4475  				if (mask &amp; g3)
4476  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4477  				mask &lt;&lt;= 1;
4478  			}
4479  			mask = 1;
4480  			for (int i = 32 ; i &lt; 40 ; ++i)
4481  			{
4482  				if (mask &amp; g4)
4483  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4484  				mask &lt;&lt;= 1;
4485  			}
4486  			mask = 1;
4487  			for (int i = 40 ; i &lt; 48 ; ++i)
4488  			{
4489  				if (mask &amp; g5)
4490  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4491  				mask &lt;&lt;= 1;
4492  			}
4493  			mask = 1;
4494  			for (int i = 48 ; i &lt; 56 ; ++i)
4495  			{
4496  				if (mask &amp; g6)
4497  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4498  				mask &lt;&lt;= 1;
4499  			}
4500  			mask = 1;
4501  			for (int i = 56 ; i &lt; 64 ; ++i)
4502  			{
4503  				if (mask &amp; g7)
4504  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4505  				mask &lt;&lt;= 1;
4506  			}
4507  			mask = 1;
4508  			for (int i = 64; i &lt; 72; ++i)
4509  			{
4510  				if (mask &amp; g8)
4511  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4512  				mask &lt;&lt;= 1;
4513  			}
4514  			mask = 1;
4515  			for (int i = 72; i &lt; 80; ++i)
4516  			{
4517  				if (mask &amp; g9)
4518  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4519  				mask &lt;&lt;= 1;
4520  			}
4521  			mask = 1;
4522  			for (int i = 80; i &lt; 88; ++i)
4523  			{
4524  				if (mask &amp; g10)
4525  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4526  				mask &lt;&lt;= 1;
4527  			}
4528  			mask = 1;
4529  			for (int i = 88; i &lt; 96; ++i)
4530  			{
4531  				if (mask &amp; g11)
4532  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4533  				mask &lt;&lt;= 1;
4534  			}
4535  			mask = 1;
4536  			for (int i = 96; i &lt; 104; ++i)
4537  			{
4538  				if (mask &amp; g12)
4539  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4540  				mask &lt;&lt;= 1;
4541  			}
4542  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;langMenuCompact&quot;));
4543  			if (val)
4544  				_nppGUI._isLangMenuCompact = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4545  		}
4546  		else if (!lstrcmp(nm, TEXT(&quot;Print&quot;)))
4547  		{
4548  			const TCHAR* val = element-&gt;Attribute(TEXT(&quot;lineNumber&quot;));
4549  			if (val)
4550  				_nppGUI._printSettings._printLineNumber = (!lstrcmp(val, TEXT(&quot;yes&quot;)));
4551  			int i;
4552  			if (element-&gt;Attribute(TEXT(&quot;printOption&quot;), &amp;i))
4553  				_nppGUI._printSettings._printOption = i;
4554  			val = element-&gt;Attribute(TEXT(&quot;headerLeft&quot;));
4555  			if (val)
4556  				_nppGUI._printSettings._headerLeft = val;
4557  			val = element-&gt;Attribute(TEXT(&quot;headerMiddle&quot;));
4558  			if (val)
4559  				_nppGUI._printSettings._headerMiddle = val;
4560  			val = element-&gt;Attribute(TEXT(&quot;headerRight&quot;));
4561  			if (val)
4562  				_nppGUI._printSettings._headerRight = val;
4563  			val = element-&gt;Attribute(TEXT(&quot;footerLeft&quot;));
4564  			if (val)
4565  				_nppGUI._printSettings._footerLeft = val;
4566  			val = element-&gt;Attribute(TEXT(&quot;footerMiddle&quot;));
4567  			if (val)
4568  				_nppGUI._printSettings._footerMiddle = val;
4569  			val = element-&gt;Attribute(TEXT(&quot;footerRight&quot;));
4570  			if (val)
4571  				_nppGUI._printSettings._footerRight = val;
4572  			val = element-&gt;Attribute(TEXT(&quot;headerFontName&quot;));
4573  			if (val)
4574  				_nppGUI._printSettings._headerFontName = val;
4575  			val = element-&gt;Attribute(TEXT(&quot;footerFontName&quot;));
4576  			if (val)
4577  				_nppGUI._printSettings._footerFontName = val;
4578  			if (element-&gt;Attribute(TEXT(&quot;headerFontStyle&quot;), &amp;i))
4579  				_nppGUI._printSettings._headerFontStyle = i;
4580  			if (element-&gt;Attribute(TEXT(&quot;footerFontStyle&quot;), &amp;i))
4581  				_nppGUI._printSettings._footerFontStyle = i;
4582  			if (element-&gt;Attribute(TEXT(&quot;headerFontSize&quot;), &amp;i))
4583  				_nppGUI._printSettings._headerFontSize = i;
4584  			if (element-&gt;Attribute(TEXT(&quot;footerFontSize&quot;), &amp;i))
4585  				_nppGUI._printSettings._footerFontSize = i;
4586  			if (element-&gt;Attribute(TEXT(&quot;margeLeft&quot;), &amp;i))
4587  				_nppGUI._printSettings._marge.left = i;
4588  			if (element-&gt;Attribute(TEXT(&quot;margeTop&quot;), &amp;i))
4589  				_nppGUI._printSettings._marge.top = i;
4590  			if (element-&gt;Attribute(TEXT(&quot;margeRight&quot;), &amp;i))
4591  				_nppGUI._printSettings._marge.right = i;
4592  			if (element-&gt;Attribute(TEXT(&quot;margeBottom&quot;), &amp;i))
4593  				_nppGUI._printSettings._marge.bottom = i;
4594  		}
4595  		else if (!lstrcmp(nm, TEXT(&quot;ScintillaPrimaryView&quot;)))
4596  		{
4597  			feedScintillaParam(element);
4598  		}
4599  		else if (!lstrcmp(nm, TEXT(&quot;Backup&quot;)))
4600  		{
4601  			int i;
4602  			if (element-&gt;Attribute(TEXT(&quot;action&quot;), &amp;i))
4603  				_nppGUI._backup = (BackupFeature)i;
4604  			const TCHAR *bDir = element-&gt;Attribute(TEXT(&quot;useCustumDir&quot;));
4605  			if (bDir)
4606  			{
4607  				_nppGUI._useDir = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4608  			}
4609  			const TCHAR *pDir = element-&gt;Attribute(TEXT(&quot;dir&quot;));
4610  			if (pDir)
4611  				_nppGUI._backupDir = pDir;
4612  			const TCHAR *isSnapshotModeStr = element-&gt;Attribute(TEXT(&quot;isSnapshotMode&quot;));
4613  			if (isSnapshotModeStr &amp;&amp; !lstrcmp(isSnapshotModeStr, TEXT(&quot;no&quot;)))
4614  				_nppGUI._isSnapshotMode = false;
4615  			int timing;
4616  			if (element-&gt;Attribute(TEXT(&quot;snapshotBackupTiming&quot;), &amp;timing))
4617  				_nppGUI._snapshotBackupTiming = timing;
4618  		}
4619  		else if (!lstrcmp(nm, TEXT(&quot;DockingManager&quot;)))
4620  		{
4621  			feedDockingManager(element);
4622  		}
4623  		else if (!lstrcmp(nm, TEXT(&quot;globalOverride&quot;)))
4624  		{
4625  			const TCHAR *bDir = element-&gt;Attribute(TEXT(&quot;fg&quot;));
4626  			if (bDir)
4627  				_nppGUI._globalOverride.enableFg = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4628  			bDir = element-&gt;Attribute(TEXT(&quot;bg&quot;));
4629  			if (bDir)
4630  				_nppGUI._globalOverride.enableBg = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4631  			bDir = element-&gt;Attribute(TEXT(&quot;font&quot;));
4632  			if (bDir)
4633  				_nppGUI._globalOverride.enableFont = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4634  			bDir = element-&gt;Attribute(TEXT(&quot;fontSize&quot;));
4635  			if (bDir)
4636  				_nppGUI._globalOverride.enableFontSize = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4637  			bDir = element-&gt;Attribute(TEXT(&quot;bold&quot;));
4638  			if (bDir)
4639  				_nppGUI._globalOverride.enableBold = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4640  			bDir = element-&gt;Attribute(TEXT(&quot;italic&quot;));
4641  			if (bDir)
4642  				_nppGUI._globalOverride.enableItalic = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4643  			bDir = element-&gt;Attribute(TEXT(&quot;underline&quot;));
4644  			if (bDir)
4645  				_nppGUI._globalOverride.enableUnderLine = (lstrcmp(bDir, TEXT(&quot;yes&quot;)) == 0);
4646  		}
4647  		else if (!lstrcmp(nm, TEXT(&quot;auto-completion&quot;)))
4648  		{
4649  			int i;
4650  			if (element-&gt;Attribute(TEXT(&quot;autoCAction&quot;), &amp;i))
4651  				_nppGUI._autocStatus = static_cast&lt;NppGUI::AutocStatus&gt;(i);
4652  			if (element-&gt;Attribute(TEXT(&quot;triggerFromNbChar&quot;), &amp;i))
4653  				_nppGUI._autocFromLen = i;
4654  			const TCHAR * optName = element-&gt;Attribute(TEXT(&quot;autoCIgnoreNumbers&quot;));
4655  			if (optName)
4656  				_nppGUI._autocIgnoreNumbers = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4657  			optName = element-&gt;Attribute(TEXT(&quot;insertSelectedItemUseENTER&quot;));
4658  			if (optName)
4659  				_nppGUI._autocInsertSelectedUseENTER = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4660  			optName = element-&gt;Attribute(TEXT(&quot;insertSelectedItemUseTAB&quot;));
4661  			if (optName)
4662  				_nppGUI._autocInsertSelectedUseTAB = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4663  			optName = element-&gt;Attribute(TEXT(&quot;autoCBrief&quot;));
4664  			if (optName)
4665  				_nppGUI._autocBrief = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4666  			optName = element-&gt;Attribute(TEXT(&quot;funcParams&quot;));
4667  			if (optName)
4668  				_nppGUI._funcParams = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4669  		}
4670  		else if (!lstrcmp(nm, TEXT(&quot;auto-insert&quot;)))
4671  		{
4672  			const TCHAR * optName = element-&gt;Attribute(TEXT(&quot;htmlXmlTag&quot;));
4673  			if (optName)
4674  				_nppGUI._matchedPairConf._doHtmlXmlTag = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4675  			optName = element-&gt;Attribute(TEXT(&quot;parentheses&quot;));
4676  			if (optName)
4677  				_nppGUI._matchedPairConf._doParentheses = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4678  			optName = element-&gt;Attribute(TEXT(&quot;brackets&quot;));
4679  			if (optName)
4680  				_nppGUI._matchedPairConf._doBrackets = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4681  			optName = element-&gt;Attribute(TEXT(&quot;curlyBrackets&quot;));
4682  			if (optName)
4683  				_nppGUI._matchedPairConf._doCurlyBrackets = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4684  			optName = element-&gt;Attribute(TEXT(&quot;quotes&quot;));
4685  			if (optName)
4686  				_nppGUI._matchedPairConf._doQuotes = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4687  			optName = element-&gt;Attribute(TEXT(&quot;doubleQuotes&quot;));
4688  			if (optName)
4689  				_nppGUI._matchedPairConf._doDoubleQuotes = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4690  			for (TiXmlNode *subChildNode = childNode-&gt;FirstChildElement(TEXT(&quot;UserDefinePair&quot;));
4691  				 subChildNode;
4692  				 subChildNode = subChildNode-&gt;NextSibling(TEXT(&quot;UserDefinePair&quot;)) )
4693  			{
4694  				int open = -1;
4695  				int openVal = 0;
4696  				const TCHAR *openValStr = (subChildNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;open&quot;), &amp;openVal);
4697  				if (openValStr &amp;&amp; (openVal &gt;= 0 &amp;&amp; openVal &lt; 128))
4698  					open = openVal;
4699  				int close = -1;
4700  				int closeVal = 0;
4701  				const TCHAR *closeValStr = (subChildNode-&gt;ToElement())-&gt;Attribute(TEXT(&quot;close&quot;), &amp;closeVal);
4702  				if (closeValStr &amp;&amp; (closeVal &gt;= 0 &amp;&amp; closeVal &lt;= 128))
4703  					close = closeVal;
4704  				if (open != -1 &amp;&amp; close != -1)
4705  					_nppGUI._matchedPairConf._matchedPairsInit.push_back(pair&lt;char, char&gt;(char(open), char(close)));
4706  			}
4707  		}
4708  		else if (!lstrcmp(nm, TEXT(&quot;sessionExt&quot;)))
4709  		{
4710  			TiXmlNode *n = childNode-&gt;FirstChild();
4711  			if (n)
4712  			{
4713  				const TCHAR* val = n-&gt;Value();
4714  				if (val)
4715  					_nppGUI._definedSessionExt = val;
4716  			}
4717  		}
4718  		else if (!lstrcmp(nm, TEXT(&quot;workspaceExt&quot;)))
4719  		{
4720  			TiXmlNode *n = childNode-&gt;FirstChild();
4721  			if (n)
4722  			{
4723  				const TCHAR* val = n-&gt;Value();
4724  				if (val)
4725  					_nppGUI._definedWorkspaceExt = val;
4726  			}
4727  		}
4728  		else if (!lstrcmp(nm, TEXT(&quot;noUpdate&quot;)))
4729  		{
4730  			TiXmlNode *n = childNode-&gt;FirstChild();
4731  			if (n)
4732  			{
4733  				const TCHAR* val = n-&gt;Value();
4734  				if (val)
4735  					_nppGUI._autoUpdateOpt._doAutoUpdate = (!lstrcmp(val, TEXT(&quot;yes&quot;)))?false:true;
4736  				int i;
4737  				val = element-&gt;Attribute(TEXT(&quot;intervalDays&quot;), &amp;i);
4738  				if (val)
4739  					_nppGUI._autoUpdateOpt._intervalDays = i;
4740  				val = element-&gt;Attribute(TEXT(&quot;nextUpdateDate&quot;));
4741  				if (val)
4742  					_nppGUI._autoUpdateOpt._nextUpdateDate = Date(val);
4743  			}
4744  		}
4745  		else if (!lstrcmp(nm, TEXT(&quot;openSaveDir&quot;)))
4746  		{
4747  			const TCHAR * value = element-&gt;Attribute(TEXT(&quot;value&quot;));
4748  			if (value &amp;&amp; value[0])
4749  			{
4750  				if (lstrcmp(value, TEXT(&quot;1&quot;)) == 0)
4751  					_nppGUI._openSaveDir = dir_last;
4752  				else if (lstrcmp(value, TEXT(&quot;2&quot;)) == 0)
4753  					_nppGUI._openSaveDir = dir_userDef;
4754  				else
4755  					_nppGUI._openSaveDir = dir_followCurrent;
4756  			}
4757  			const TCHAR * path = element-&gt;Attribute(TEXT(&quot;defaultDirPath&quot;));
4758  			if (path &amp;&amp; path[0])
4759  			{
4760  				lstrcpyn(_nppGUI._defaultDir, path, MAX_PATH);
4761  				::ExpandEnvironmentStrings(_nppGUI._defaultDir, _nppGUI._defaultDirExp, MAX_PATH);
4762  			}
4763   		}
4764  		else if (!lstrcmp(nm, TEXT(&quot;titleBar&quot;)))
4765  		{
4766  			const TCHAR * value = element-&gt;Attribute(TEXT(&quot;short&quot;));
4767  			_nppGUI._shortTitlebar = false;	
4768  			if (value &amp;&amp; value[0])
4769  			{
4770  				if (lstrcmp(value, TEXT(&quot;yes&quot;)) == 0)
4771  					_nppGUI._shortTitlebar = true;
4772  				else if (lstrcmp(value, TEXT(&quot;no&quot;)) == 0)
4773  					_nppGUI._shortTitlebar = false;
4774  			}
4775  		}
4776  		else if (!lstrcmp(nm, TEXT(&quot;insertDateTime&quot;)))
4777  		{
4778  			const TCHAR* customFormat = element-&gt;Attribute(TEXT(&quot;customizedFormat&quot;));
4779  			if (customFormat != NULL &amp;&amp; customFormat[0])
4780  				_nppGUI._dateTimeFormat = customFormat;
4781  			const TCHAR* value = element-&gt;Attribute(TEXT(&quot;reverseDefaultOrder&quot;));
4782  			if (value &amp;&amp; value[0])
4783  			{
4784  				if (lstrcmp(value, TEXT(&quot;yes&quot;)) == 0)
4785  					_nppGUI._dateTimeReverseDefaultOrder = true;
4786  				else if (lstrcmp(value, TEXT(&quot;no&quot;)) == 0)
4787  					_nppGUI._dateTimeReverseDefaultOrder = false;
4788  			}
4789  		}
4790  		else if (!lstrcmp(nm, TEXT(&quot;wordCharList&quot;)))
4791  		{
4792  			const TCHAR * value = element-&gt;Attribute(TEXT(&quot;useDefault&quot;));
4793  			if (value &amp;&amp; value[0])
4794  			{
4795  				if (lstrcmp(value, TEXT(&quot;yes&quot;)) == 0)
4796  					_nppGUI._isWordCharDefault = true;
4797  				else if (lstrcmp(value, TEXT(&quot;no&quot;)) == 0)
4798  					_nppGUI._isWordCharDefault = false;
4799  			}
4800  			const TCHAR *charsAddedW = element-&gt;Attribute(TEXT(&quot;charsAdded&quot;));
4801  			if (charsAddedW)
4802  			{
4803  				WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
4804  				_nppGUI._customWordChars = wmc.wchar2char(charsAddedW, SC_CP_UTF8);
4805  			}
4806  		}
4807  		else if (!lstrcmp(nm, TEXT(&quot;delimiterSelection&quot;)))
4808  		{
4809  			int leftmost = 0;
4810  			element-&gt;Attribute(TEXT(&quot;leftmostDelimiter&quot;), &amp;leftmost);
4811  			if (leftmost &gt; 0 &amp;&amp; leftmost &lt; 256)
4812  				_nppGUI._leftmostDelimiter = static_cast&lt;char&gt;(leftmost);
4813  			int rightmost = 0;
4814  			element-&gt;Attribute(TEXT(&quot;rightmostDelimiter&quot;), &amp;rightmost);
4815  			if (rightmost &gt; 0 &amp;&amp; rightmost &lt; 256)
4816  				_nppGUI._rightmostDelimiter = static_cast&lt;char&gt;(rightmost);
4817  			const TCHAR *delimiterSelectionOnEntireDocument = element-&gt;Attribute(TEXT(&quot;delimiterSelectionOnEntireDocument&quot;));
4818  			if (delimiterSelectionOnEntireDocument != NULL &amp;&amp; !lstrcmp(delimiterSelectionOnEntireDocument, TEXT(&quot;yes&quot;)))
4819  				_nppGUI._delimiterSelectionOnEntireDocument = true;
4820  			else
4821  				_nppGUI._delimiterSelectionOnEntireDocument = false;
4822  		}
4823  		else if (!lstrcmp(nm, TEXT(&quot;largeFileRestriction&quot;)))
4824  		{
4825  			int fileSizeLimit4StylingMB = 0;
4826  			element-&gt;Attribute(TEXT(&quot;fileSizeMB&quot;), &amp;fileSizeLimit4StylingMB);
4827  			if (fileSizeLimit4StylingMB &gt; 0 &amp;&amp; fileSizeLimit4StylingMB &lt;= 4096)
4828  				_nppGUI._largeFileRestriction._largeFileSizeDefInByte = (static_cast&lt;int64_t&gt;(fileSizeLimit4StylingMB) * 1024 * 1024);
4829  			const TCHAR* boolVal = element-&gt;Attribute(TEXT(&quot;isEnabled&quot;));
4830  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;no&quot;)))
4831  				_nppGUI._largeFileRestriction._isEnabled = false;
4832  			else
4833  				_nppGUI._largeFileRestriction._isEnabled = true;
4834  			boolVal = element-&gt;Attribute(TEXT(&quot;allowAutoCompletion&quot;));
4835  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;yes&quot;)))
4836  				_nppGUI._largeFileRestriction._allowAutoCompletion = true;
4837  			else
4838  				_nppGUI._largeFileRestriction._allowAutoCompletion = false;
4839  			boolVal = element-&gt;Attribute(TEXT(&quot;allowBraceMatch&quot;));
4840  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;yes&quot;)))
4841  				_nppGUI._largeFileRestriction._allowBraceMatch = true;
4842  			else
4843  				_nppGUI._largeFileRestriction._allowBraceMatch = false;
4844  			boolVal = element-&gt;Attribute(TEXT(&quot;allowSmartHilite&quot;));
4845  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;yes&quot;)))
4846  				_nppGUI._largeFileRestriction._allowSmartHilite = true;
4847  			else
4848  				_nppGUI._largeFileRestriction._allowSmartHilite = false;
4849  			boolVal = element-&gt;Attribute(TEXT(&quot;allowClickableLink&quot;));
4850  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;yes&quot;)))
4851  				_nppGUI._largeFileRestriction._allowClickableLink = true;
4852  			else
4853  				_nppGUI._largeFileRestriction._allowClickableLink = false;
4854  			boolVal = element-&gt;Attribute(TEXT(&quot;deactivateWordWrap&quot;));
4855  			if (boolVal != NULL &amp;&amp; !lstrcmp(boolVal, TEXT(&quot;no&quot;)))
4856  				_nppGUI._largeFileRestriction._deactivateWordWrap = false;
4857  			else
4858  				_nppGUI._largeFileRestriction._deactivateWordWrap = true;
4859  		}
4860  		else if (!lstrcmp(nm, TEXT(&quot;multiInst&quot;)))
4861  		{
4862  			int val = 0;
4863  			element-&gt;Attribute(TEXT(&quot;setting&quot;), &amp;val);
4864  			if (val &lt; 0 || val &gt; 2)
4865  				val = 0;
4866  			_nppGUI._multiInstSetting = (MultiInstSetting)val;
4867  			_nppGUI._clipboardHistoryPanelKeepState = parseYesNoBoolAttribute(TEXT(&quot;clipboardHistory&quot;));
4868  			_nppGUI._docListKeepState = parseYesNoBoolAttribute(TEXT(&quot;documentList&quot;));
4869  			_nppGUI._charPanelKeepState = parseYesNoBoolAttribute(TEXT(&quot;characterPanel&quot;));
4870  			_nppGUI._fileBrowserKeepState = parseYesNoBoolAttribute(TEXT(&quot;folderAsWorkspace&quot;));
4871  			_nppGUI._projectPanelKeepState = parseYesNoBoolAttribute(TEXT(&quot;projectPanels&quot;));
4872  			_nppGUI._docMapKeepState = parseYesNoBoolAttribute(TEXT(&quot;documentMap&quot;));
4873  			_nppGUI._funcListKeepState = parseYesNoBoolAttribute(TEXT(&quot;fuctionList&quot;));
4874  			_nppGUI._pluginPanelKeepState = parseYesNoBoolAttribute(TEXT(&quot;pluginPanels&quot;));
4875  		}
4876  		else if (!lstrcmp(nm, TEXT(&quot;searchEngine&quot;)))
4877  		{
4878  			int i;
4879  			if (element-&gt;Attribute(TEXT(&quot;searchEngineChoice&quot;), &amp;i))
4880  				_nppGUI._searchEngineChoice = static_cast&lt;NppGUI::SearchEngineChoice&gt;(i);
4881  			const TCHAR * searchEngineCustom = element-&gt;Attribute(TEXT(&quot;searchEngineCustom&quot;));
4882  			if (searchEngineCustom &amp;&amp; searchEngineCustom[0])
4883  				_nppGUI._searchEngineCustom = searchEngineCustom;
4884  		}
4885  		else if (!lstrcmp(nm, TEXT(&quot;Searching&quot;)))
4886  		{
4887  			const TCHAR* optNameMonoFont = element-&gt;Attribute(TEXT(&quot;monospacedFontFindDlg&quot;));
4888  			if (optNameMonoFont)
4889  				_nppGUI._monospacedFontFindDlg = (lstrcmp(optNameMonoFont, TEXT(&quot;yes&quot;)) == 0);
4890  			const TCHAR* optStopFillingFindField = element-&gt;Attribute(TEXT(&quot;stopFillingFindField&quot;));
4891  			if (optStopFillingFindField) 
4892  			{
4893  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optStopFillingFindField, TEXT(&quot;no&quot;)) == 0);
4894  				_nppGUI._fillFindFieldSelectCaret = _nppGUI._fillFindFieldWithSelected;
4895  			}
4896  			const TCHAR* optFillFindFieldWithSelected = element-&gt;Attribute(TEXT(&quot;fillFindFieldWithSelected&quot;));
4897  			if (optFillFindFieldWithSelected)
4898  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optFillFindFieldWithSelected, TEXT(&quot;yes&quot;)) == 0);
4899  			const TCHAR* optFillFindFieldSelectCaret = element-&gt;Attribute(TEXT(&quot;fillFindFieldSelectCaret&quot;));
4900  			if (optFillFindFieldSelectCaret)
4901  				_nppGUI._fillFindFieldSelectCaret = (lstrcmp(optFillFindFieldSelectCaret, TEXT(&quot;yes&quot;)) == 0);
4902  			const TCHAR* optFindDlgAlwaysVisible = element-&gt;Attribute(TEXT(&quot;findDlgAlwaysVisible&quot;));
4903  			if (optFindDlgAlwaysVisible)
4904  				_nppGUI._findDlgAlwaysVisible = (lstrcmp(optFindDlgAlwaysVisible, TEXT(&quot;yes&quot;)) == 0);
4905  			const TCHAR* optConfirmReplaceOpenDocs = element-&gt;Attribute(TEXT(&quot;confirmReplaceInAllOpenDocs&quot;));
4906  			if (optConfirmReplaceOpenDocs)
4907  				_nppGUI._confirmReplaceInAllOpenDocs = (lstrcmp(optConfirmReplaceOpenDocs, TEXT(&quot;yes&quot;)) == 0);
4908  			const TCHAR* optReplaceStopsWithoutFindingNext = element-&gt;Attribute(TEXT(&quot;replaceStopsWithoutFindingNext&quot;));
4909  			if (optReplaceStopsWithoutFindingNext)
4910  				_nppGUI._replaceStopsWithoutFindingNext = (lstrcmp(optReplaceStopsWithoutFindingNext, TEXT(&quot;yes&quot;)) == 0);
4911  		}
4912  		else if (!lstrcmp(nm, TEXT(&quot;MISC&quot;)))
4913  		{
4914  			const TCHAR * optName = element-&gt;Attribute(TEXT(&quot;fileSwitcherWithoutExtColumn&quot;));
4915  			if (optName)
4916  				_nppGUI._fileSwitcherWithoutExtColumn = (lstrcmp(optName, TEXT(&quot;yes&quot;)) == 0);
4917  			int i = 0;
4918  			if (element-&gt;Attribute(TEXT(&quot;fileSwitcherExtWidth&quot;), &amp;i))
4919  				_nppGUI._fileSwitcherExtWidth = i;
4920  			const TCHAR * optNamePath = element-&gt;Attribute(TEXT(&quot;fileSwitcherWithoutPathColumn&quot;));
4921  			if (optNamePath)
4922  				_nppGUI._fileSwitcherWithoutPathColumn = (lstrcmp(optNamePath, TEXT(&quot;yes&quot;)) == 0);
4923  			if (element-&gt;Attribute(TEXT(&quot;fileSwitcherPathWidth&quot;), &amp;i))
4924  				_nppGUI._fileSwitcherPathWidth = i;
4925  			_nppGUI._fileSwitcherDisableListViewGroups = parseYesNoBoolAttribute(TEXT(&quot;fileSwitcherNoGroups&quot;));
4926  			const TCHAR * optNameBackSlashEscape = element-&gt;Attribute(TEXT(&quot;backSlashIsEscapeCharacterForSql&quot;));
4927  			if (optNameBackSlashEscape &amp;&amp; !lstrcmp(optNameBackSlashEscape, TEXT(&quot;no&quot;)))
4928  				_nppGUI._backSlashIsEscapeCharacterForSql = false;
4929  			const TCHAR * optNameWriteTechnologyEngine = element-&gt;Attribute(TEXT(&quot;writeTechnologyEngine&quot;));
4930  			if (optNameWriteTechnologyEngine)
4931  				_nppGUI._writeTechnologyEngine = (lstrcmp(optNameWriteTechnologyEngine, TEXT(&quot;1&quot;)) == 0) ? directWriteTechnology : defaultTechnology;
4932  			const TCHAR * optNameFolderDroppedOpenFiles = element-&gt;Attribute(TEXT(&quot;isFolderDroppedOpenFiles&quot;));
4933  			if (optNameFolderDroppedOpenFiles)
4934  				_nppGUI._isFolderDroppedOpenFiles = (lstrcmp(optNameFolderDroppedOpenFiles, TEXT(&quot;yes&quot;)) == 0);
4935  			const TCHAR * optDocPeekOnTab = element-&gt;Attribute(TEXT(&quot;docPeekOnTab&quot;));
4936  			if (optDocPeekOnTab)
4937  				_nppGUI._isDocPeekOnTab = (lstrcmp(optDocPeekOnTab, TEXT(&quot;yes&quot;)) == 0);
4938  			const TCHAR * optDocPeekOnMap = element-&gt;Attribute(TEXT(&quot;docPeekOnMap&quot;));
4939  			if (optDocPeekOnMap)
4940  				_nppGUI._isDocPeekOnMap = (lstrcmp(optDocPeekOnMap, TEXT(&quot;yes&quot;)) == 0);
4941  			const TCHAR* optSortFunctionList = element-&gt;Attribute(TEXT(&quot;sortFunctionList&quot;));
4942  			if (optSortFunctionList)
4943  				_nppGUI._shouldSortFunctionList = (lstrcmp(optSortFunctionList, TEXT(&quot;yes&quot;)) == 0);
4944  			const TCHAR* saveDlgExtFilterToAllTypes = element-&gt;Attribute(TEXT(&quot;saveDlgExtFilterToAllTypes&quot;));
4945  			if (saveDlgExtFilterToAllTypes)
4946  				_nppGUI._setSaveDlgExtFiltToAllTypes = (lstrcmp(saveDlgExtFilterToAllTypes, TEXT(&quot;yes&quot;)) == 0);
4947  			const TCHAR * optMuteSounds = element-&gt;Attribute(TEXT(&quot;muteSounds&quot;));
4948  			if (optMuteSounds)
4949  				_nppGUI._muteSounds = lstrcmp(optMuteSounds, TEXT(&quot;yes&quot;)) == 0;
4950  			const TCHAR * optEnableFoldCmdToggable = element-&gt;Attribute(TEXT(&quot;enableFoldCmdToggable&quot;));
4951  			if (optEnableFoldCmdToggable)
4952  				_nppGUI._enableFoldCmdToggable = lstrcmp(optEnableFoldCmdToggable, TEXT(&quot;yes&quot;)) == 0;
4953  			const TCHAR * hideMenuRightShortcuts = element-&gt;Attribute(TEXT(&quot;hideMenuRightShortcuts&quot;));
4954  			if (hideMenuRightShortcuts)
4955  				_nppGUI._hideMenuRightShortcuts = lstrcmp(hideMenuRightShortcuts, TEXT(&quot;yes&quot;)) == 0;
4956  		}
4957  		else if (!lstrcmp(nm, TEXT(&quot;commandLineInterpreter&quot;)))
4958  		{
4959  			TiXmlNode *node = childNode-&gt;FirstChild();
4960  			if (node)
4961  			{
4962  				const TCHAR *cli = node-&gt;Value();
4963  				if (cli &amp;&amp; cli[0])
4964  					_nppGUI._commandLineInterpreter.assign(cli);
4965  			}
4966  		}
4967  		else if (!lstrcmp(nm, TEXT(&quot;DarkMode&quot;)))
4968  		{
4969  			_nppGUI._darkmode._isEnabled = parseYesNoBoolAttribute(TEXT(&quot;enable&quot;));
4970  			int i;
4971  			const TCHAR* val;
4972  			val = element-&gt;Attribute(TEXT(&quot;colorTone&quot;), &amp;i);
4973  			if (val)
4974  				_nppGUI._darkmode._colorTone = static_cast&lt;NppDarkMode::ColorTone&gt;(i);
4975  			val = element-&gt;Attribute(TEXT(&quot;customColorTop&quot;), &amp;i);
4976  			if (val)
4977  				_nppGUI._darkmode._customColors.pureBackground = i;
4978  			val = element-&gt;Attribute(TEXT(&quot;customColorMenuHotTrack&quot;), &amp;i);
4979  			if (val)
4980  				_nppGUI._darkmode._customColors.hotBackground = i;
4981  			val = element-&gt;Attribute(TEXT(&quot;customColorActive&quot;), &amp;i);
4982  			if (val)
4983  				_nppGUI._darkmode._customColors.softerBackground = i;
4984  			val = element-&gt;Attribute(TEXT(&quot;customColorMain&quot;), &amp;i);
4985  			if (val)
4986  				_nppGUI._darkmode._customColors.background = i;
4987  			val = element-&gt;Attribute(TEXT(&quot;customColorError&quot;), &amp;i);
4988  			if (val)
4989  				_nppGUI._darkmode._customColors.errorBackground = i;
4990  			val = element-&gt;Attribute(TEXT(&quot;customColorText&quot;), &amp;i);
4991  			if (val)
4992  				_nppGUI._darkmode._customColors.text = i;
4993  			val = element-&gt;Attribute(TEXT(&quot;customColorDarkText&quot;), &amp;i);
4994  			if (val)
4995  				_nppGUI._darkmode._customColors.darkerText = i;
4996  			val = element-&gt;Attribute(TEXT(&quot;customColorDisabledText&quot;), &amp;i);
4997  			if (val)
4998  				_nppGUI._darkmode._customColors.disabledText = i;
4999  			val = element-&gt;Attribute(TEXT(&quot;customColorLinkText&quot;), &amp;i);
5000  			if (val)
5001  				_nppGUI._darkmode._customColors.linkText = i;
5002  			val = element-&gt;Attribute(TEXT(&quot;customColorEdge&quot;), &amp;i);
5003  			if (val)
5004  				_nppGUI._darkmode._customColors.edge = i;
5005  			val = element-&gt;Attribute(TEXT(&quot;customColorHotEdge&quot;), &amp;i);
5006  			if (val)
5007  				_nppGUI._darkmode._customColors.hotEdge = i;
5008  			val = element-&gt;Attribute(TEXT(&quot;customColorDisabledEdge&quot;), &amp;i);
5009  			if (val)
5010  				_nppGUI._darkmode._customColors.disabledEdge = i;
5011  			auto parseStringAttribute = [&amp;element](const TCHAR* name, const TCHAR* defaultName = TEXT(&quot;&quot;)) -&gt; const TCHAR* {
5012  				const TCHAR* val = element-&gt;Attribute(name);
5013  				if (val != nullptr &amp;&amp; val[0])
5014  				{
5015  					return element-&gt;Attribute(name);
5016  				}
5017  				return defaultName;
5018  			};
5019  			auto parseToolBarIconsAttribute = [&amp;element](const TCHAR* name, int defaultValue = -1) -&gt; int {
5020  				int val;
5021  				const TCHAR* valStr = element-&gt;Attribute(name, &amp;val);
5022  				if (valStr != nullptr &amp;&amp; (val &gt;= 0 &amp;&amp; val &lt;= 4))
5023  				{
5024  					return val;
5025  				}
5026  				return defaultValue;
5027  			};
5028  			auto parseTabIconsAttribute = [&amp;element](const TCHAR* name, int defaultValue = -1) -&gt; int {
5029  				int val;
5030  				const TCHAR* valStr = element-&gt;Attribute(name, &amp;val);
5031  				if (valStr != nullptr &amp;&amp; (val &gt;= 0 &amp;&amp; val &lt;= 2))
5032  				{
5033  					return val;
5034  				}
5035  				return defaultValue;
5036  			};
5037  			auto&amp; windowsMode = _nppGUI._darkmode._advOptions._enableWindowsMode;
5038  			windowsMode = parseYesNoBoolAttribute(TEXT(&quot;enableWindowsMode&quot;));
5039  			auto&amp; darkDefaults = _nppGUI._darkmode._advOptions._darkDefaults;
5040  			auto&amp; darkThemeName = darkDefaults._xmlFileName;
5041  			darkThemeName = parseStringAttribute(TEXT(&quot;darkThemeName&quot;), TEXT(&quot;DarkModeDefault.xml&quot;));
5042  			darkDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT(&quot;darkToolBarIconSet&quot;), 0);
5043  			darkDefaults._tabIconSet = parseTabIconsAttribute(TEXT(&quot;darkTabIconSet&quot;), 2);
5044  			darkDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT(&quot;darkTabUseTheme&quot;));
5045  			auto&amp; lightDefaults = _nppGUI._darkmode._advOptions._lightDefaults;
5046  			auto&amp; lightThemeName = lightDefaults._xmlFileName;
5047  			lightThemeName = parseStringAttribute(TEXT(&quot;lightThemeName&quot;));
5048  			lightDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT(&quot;lightToolBarIconSet&quot;), 4);
5049  			lightDefaults._tabIconSet = parseTabIconsAttribute(TEXT(&quot;lightTabIconSet&quot;), 0);
5050  			lightDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT(&quot;lightTabUseTheme&quot;), true);
5051  			if (!windowsMode)
5052  			{
5053  				generic_string themePath;
5054  				generic_string xmlFileName = _nppGUI._darkmode._isEnabled ? darkThemeName : lightThemeName;
5055  				const bool isLocalOnly = _isLocal &amp;&amp; !_isCloud;
5056  				if (!xmlFileName.empty() &amp;&amp; lstrcmp(xmlFileName.c_str(), TEXT(&quot;stylers.xml&quot;)) != 0)
5057  				{
5058  					themePath = isLocalOnly ? _nppPath : _userPath;
5059  					pathAppend(themePath, TEXT(&quot;themes\\&quot;));
5060  					pathAppend(themePath, xmlFileName);
5061  					if (!isLocalOnly &amp;&amp; ::PathFileExists(themePath.c_str()) == FALSE)
5062  					{
5063  						themePath = _nppPath;
5064  						pathAppend(themePath, TEXT(&quot;themes\\&quot;));
5065  						pathAppend(themePath, xmlFileName);
5066  					}
5067  				}
5068  				else
5069  				{
5070  					themePath = isLocalOnly ? _nppPath : _userPath;
5071  					pathAppend(themePath, TEXT(&quot;stylers.xml&quot;));
5072  					if (!isLocalOnly &amp;&amp; ::PathFileExists(themePath.c_str()) == FALSE)
5073  					{
5074  						themePath = _nppPath;
5075  						pathAppend(themePath, TEXT(&quot;stylers.xml&quot;));
5076  					}
5077  				}
5078  				if (::PathFileExists(themePath.c_str()) == TRUE)
5079  				{
5080  					_nppGUI._themeName.assign(themePath);
5081  				}
5082  			}
5083  		}
5084  	}
5085  }
5086  void NppParameters::feedScintillaParam(TiXmlNode *node)
5087  {
5088  	TiXmlElement* element = node-&gt;ToElement();
5089  	auto parseYesNoBoolAttribute = [&amp;element](const TCHAR* name, bool defaultValue = false) -&gt; bool {
5090  		const TCHAR* nm = element-&gt;Attribute(name);
5091  		if (nm)
5092  		{
5093  			if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5094  				return true;
5095  			else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5096  				return false;
5097  		}
5098  		return defaultValue;
5099  	};
5100  	auto parseShowHideBoolAttribute = [&amp;element](const TCHAR* name, bool defaultValue = false) -&gt; bool {
5101  		const TCHAR* nm = element-&gt;Attribute(name);
5102  		if (nm)
5103  		{
5104  			if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5105  				return true;
5106  			else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5107  				return false;
5108  		}
5109  		return defaultValue;
5110  	};
5111  	const TCHAR *nm = element-&gt;Attribute(TEXT(&quot;lineNumberMargin&quot;));
5112  	if (nm)
5113  	{
5114  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5115  			_svp._lineNumberMarginShow = true;
5116  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5117  			_svp._lineNumberMarginShow = false;
5118  	}
5119  	nm = element-&gt;Attribute(TEXT(&quot;lineNumberDynamicWidth&quot;));
5120  	if (nm)
5121  	{
5122  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5123  			_svp._lineNumberMarginDynamicWidth = true;
5124  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5125  			_svp._lineNumberMarginDynamicWidth = false;
5126  	}
5127  	nm = element-&gt;Attribute(TEXT(&quot;bookMarkMargin&quot;));
5128  	if (nm)
5129  	{
5130  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5131  			_svp._bookMarkMarginShow = true;
5132  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5133  			_svp._bookMarkMarginShow = false;
5134  	}
5135  	nm = element-&gt;Attribute(TEXT(&quot;isChangeHistoryEnabled&quot;));
5136  	if (nm)
5137  	{
5138  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5139  		{
5140  			_svp._isChangeHistoryEnabled = true;
5141  			_svp._isChangeHistoryEnabled4NextSession = true;
5142  		}
5143  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5144  		{
5145  			_svp._isChangeHistoryEnabled = false;
5146  			_svp._isChangeHistoryEnabled4NextSession = false;
5147  		}
5148  	}
5149  	nm = element-&gt;Attribute(TEXT(&quot;indentGuideLine&quot;));
5150  	if (nm)
5151  	{
5152  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5153  			_svp._indentGuideLineShow = true;
5154  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5155  			_svp._indentGuideLineShow= false;
5156  	}
5157  	nm = element-&gt;Attribute(TEXT(&quot;folderMarkStyle&quot;));
5158  	if (nm)
5159  	{
5160  		if (!lstrcmp(nm, TEXT(&quot;box&quot;)))
5161  			_svp._folderStyle = FOLDER_STYLE_BOX;
5162  		else if (!lstrcmp(nm, TEXT(&quot;circle&quot;)))
5163  			_svp._folderStyle = FOLDER_STYLE_CIRCLE;
5164  		else if (!lstrcmp(nm, TEXT(&quot;arrow&quot;)))
5165  			_svp._folderStyle = FOLDER_STYLE_ARROW;
5166  		else if (!lstrcmp(nm, TEXT(&quot;simple&quot;)))
5167  			_svp._folderStyle = FOLDER_STYLE_SIMPLE;
5168  		else if (!lstrcmp(nm, TEXT(&quot;none&quot;)))
5169  			_svp._folderStyle = FOLDER_STYLE_NONE;
5170  	}
5171  	nm = element-&gt;Attribute(TEXT(&quot;lineWrapMethod&quot;));
5172  	if (nm)
5173  	{
5174  		if (!lstrcmp(nm, TEXT(&quot;default&quot;)))
5175  			_svp._lineWrapMethod = LINEWRAP_DEFAULT;
5176  		else if (!lstrcmp(nm, TEXT(&quot;aligned&quot;)))
5177  			_svp._lineWrapMethod = LINEWRAP_ALIGNED;
5178  		else if (!lstrcmp(nm, TEXT(&quot;indent&quot;)))
5179  			_svp._lineWrapMethod = LINEWRAP_INDENT;
5180  	}
5181  	nm = element-&gt;Attribute(TEXT(&quot;currentLineHilitingShow&quot;));
5182  	if (nm)
5183  	{
5184  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5185  			_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5186  		else
5187  			_svp._currentLineHiliteMode = LINEHILITE_NONE;
5188  	}
5189  	else
5190  	{
5191  		const TCHAR* currentLineModeStr = element-&gt;Attribute(TEXT(&quot;currentLineIndicator&quot;));
5192  		if (currentLineModeStr &amp;&amp; currentLineModeStr[0])
5193  		{
5194  			if (lstrcmp(currentLineModeStr, TEXT(&quot;1&quot;)) == 0)
5195  				_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5196  			else if (lstrcmp(currentLineModeStr, TEXT(&quot;2&quot;)) == 0)
5197  				_svp._currentLineHiliteMode = LINEHILITE_FRAME;
5198  			else
5199  				_svp._currentLineHiliteMode = LINEHILITE_NONE;
5200  		}
5201  	}
5202  	nm = element-&gt;Attribute(TEXT(&quot;currentLineFrameWidth&quot;));
5203  	if (nm)
5204  	{
5205  		unsigned char frameWidth{ 1 };
5206  		try
5207  		{
5208  			frameWidth = static_cast&lt;unsigned char&gt;(std::stoi(nm));
5209  		}
5210  		catch (...)
5211  		{
5212  		}
5213  		_svp._currentLineFrameWidth = (frameWidth &lt; 1) ? 1 : (frameWidth &gt; 6) ? 6 : frameWidth;
5214  	}
5215  	nm = element-&gt;Attribute(TEXT(&quot;virtualSpace&quot;));
5216  	if (nm)
5217  	{
5218  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5219  			_svp._virtualSpace = true;
5220  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5221  			_svp._virtualSpace = false;
5222  	}
5223  	nm = element-&gt;Attribute(TEXT(&quot;scrollBeyondLastLine&quot;));
5224  	if (nm)
5225  	{
5226  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5227  			_svp._scrollBeyondLastLine = true;
5228  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5229  			_svp._scrollBeyondLastLine = false;
5230  	}
5231  	nm = element-&gt;Attribute(TEXT(&quot;rightClickKeepsSelection&quot;));
5232  	if (nm)
5233  	{
5234  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5235  			_svp._rightClickKeepsSelection = true;
5236  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5237  			_svp._rightClickKeepsSelection = false;
5238  	}
5239  	nm = element-&gt;Attribute(TEXT(&quot;disableAdvancedScrolling&quot;));
5240  	if (nm)
5241  	{
5242  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5243  			_svp._disableAdvancedScrolling = true;
5244  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5245  			_svp._disableAdvancedScrolling = false;
5246  	}
5247  	nm = element-&gt;Attribute(TEXT(&quot;wrapSymbolShow&quot;));
5248  	if (nm)
5249  	{
5250  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5251  			_svp._wrapSymbolShow = true;
5252  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5253  			_svp._wrapSymbolShow = false;
5254  	}
5255  	nm = element-&gt;Attribute(TEXT(&quot;Wrap&quot;));
5256  	if (nm)
5257  	{
5258  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5259  			_svp._doWrap = true;
5260  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5261  			_svp._doWrap = false;
5262  	}
5263  	nm = element-&gt;Attribute(TEXT(&quot;isEdgeBgMode&quot;));
5264  	if (nm)
5265  	{
5266  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5267  			_svp._isEdgeBgMode = true;
5268  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5269  			_svp._isEdgeBgMode = false;
5270  	}
5271  	nm = element-&gt;Attribute(TEXT(&quot;borderEdge&quot;));
5272  	if (nm)
5273  	{
5274  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5275  			_svp._showBorderEdge = true;
5276  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5277  			_svp._showBorderEdge = false;
5278  	}
5279  	nm = element-&gt;Attribute(TEXT(&quot;edgeMultiColumnPos&quot;));
5280  	if (nm)
5281  	{
5282  		str2numberVector(nm, _svp._edgeMultiColumnPos);
5283  	}
5284  	int val;
5285  	nm = element-&gt;Attribute(TEXT(&quot;zoom&quot;), &amp;val);
5286  	if (nm)
5287  	{
5288  		_svp._zoom = val;
5289  	}
5290  	nm = element-&gt;Attribute(TEXT(&quot;zoom2&quot;), &amp;val);
5291  	if (nm)
5292  	{
5293  		_svp._zoom2 = val;
5294  	}
5295  	nm = element-&gt;Attribute(TEXT(&quot;whiteSpaceShow&quot;));
5296  	if (nm)
5297  	{
5298  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5299  			_svp._whiteSpaceShow = true;
5300  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5301  			_svp._whiteSpaceShow = false;
5302  	}
5303  	nm = element-&gt;Attribute(TEXT(&quot;eolShow&quot;));
5304  	if (nm)
5305  	{
5306  		if (!lstrcmp(nm, TEXT(&quot;show&quot;)))
5307  			_svp._eolShow = true;
5308  		else if (!lstrcmp(nm, TEXT(&quot;hide&quot;)))
5309  			_svp._eolShow = false;
5310  	}
5311  	nm = element-&gt;Attribute(TEXT(&quot;eolMode&quot;), &amp;val);
5312  	if (nm)
5313  	{
5314  		if (val &gt;= 0 &amp;&amp; val &lt;= 3)
5315  			_svp._eolMode = static_cast&lt;ScintillaViewParams::crlfMode&gt;(val);
5316  	}
5317  	_svp._npcShow = parseShowHideBoolAttribute(TEXT(&quot;npcShow&quot;), true);
5318  	nm = element-&gt;Attribute(TEXT(&quot;npcMode&quot;), &amp;val);
5319  	if (nm)
5320  	{
5321  		if (val &gt;= 1 &amp;&amp; val &lt;= 2)
5322  			_svp._npcMode = static_cast&lt;ScintillaViewParams::npcMode&gt;(val);
5323  	}
5324  	_svp._npcCustomColor = parseYesNoBoolAttribute(TEXT(&quot;npcCustomColor&quot;));
5325  	_svp._npcIncludeCcUniEol = parseYesNoBoolAttribute(TEXT(&quot;npcIncludeCcUniEOL&quot;));
5326  	_svp._ccUniEolShow = parseYesNoBoolAttribute(TEXT(&quot;ccShow&quot;), true);
5327  	nm = element-&gt;Attribute(TEXT(&quot;borderWidth&quot;), &amp;val);
5328  	if (nm)
5329  	{
5330  		if (val &gt;= 0 &amp;&amp; val &lt;= 30)
5331  			_svp._borderWidth = val;
5332  	}
5333  	nm = element-&gt;Attribute(TEXT(&quot;smoothFont&quot;));
5334  	if (nm)
5335  	{
5336  		if (!lstrcmp(nm, TEXT(&quot;yes&quot;)))
5337  			_svp._doSmoothFont = true;
5338  		else if (!lstrcmp(nm, TEXT(&quot;no&quot;)))
5339  			_svp._doSmoothFont = false;
5340  	}
5341  	nm = element-&gt;Attribute(TEXT(&quot;paddingLeft&quot;), &amp;val);
5342  	if (nm)
5343  	{
5344  		if (val &gt;= 0 &amp;&amp; val &lt;= 30)
5345  			_svp._paddingLeft = static_cast&lt;unsigned char&gt;(val);
5346  	}
5347  	nm = element-&gt;Attribute(TEXT(&quot;paddingRight&quot;), &amp;val);
5348  	if (nm)
5349  	{
5350  		if (val &gt;= 0 &amp;&amp; val &lt;= 30)
5351  			_svp._paddingRight = static_cast&lt;unsigned char&gt;(val);
5352  	}
5353  	nm = element-&gt;Attribute(TEXT(&quot;distractionFreeDivPart&quot;), &amp;val);
5354  	if (nm)
5355  	{
5356  		if (val &gt;= 3 &amp;&amp; val &lt;= 9)
5357  			_svp._distractionFreeDivPart = static_cast&lt;unsigned char&gt;(val);
5358  	}
5359  }
5360  void NppParameters::feedDockingManager(TiXmlNode *node)
5361  {
5362  	TiXmlElement *element = node-&gt;ToElement();
5363  	int i;
5364  	if (element-&gt;Attribute(TEXT(&quot;leftWidth&quot;), &amp;i))
5365  		_nppGUI._dockingData._leftWidth = i;
5366  	if (element-&gt;Attribute(TEXT(&quot;rightWidth&quot;), &amp;i))
5367  		_nppGUI._dockingData._rightWidth = i;
5368  	if (element-&gt;Attribute(TEXT(&quot;topHeight&quot;), &amp;i))
5369  		_nppGUI._dockingData._topHeight = i;
5370  	if (element-&gt;Attribute(TEXT(&quot;bottomHeight&quot;), &amp;i))
5371  		_nppGUI._dockingData._bottomHight = i;
5372  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;FloatingWindow&quot;));
5373  		childNode ;
5374  		childNode = childNode-&gt;NextSibling(TEXT(&quot;FloatingWindow&quot;)) )
5375  	{
5376  		TiXmlElement *floatElement = childNode-&gt;ToElement();
5377  		int cont;
5378  		if (floatElement-&gt;Attribute(TEXT(&quot;cont&quot;), &amp;cont))
5379  		{
5380  			int x = 0;
5381  			int y = 0;
5382  			int w = 100;
5383  			int h = 100;
5384  			floatElement-&gt;Attribute(TEXT(&quot;x&quot;), &amp;x);
5385  			floatElement-&gt;Attribute(TEXT(&quot;y&quot;), &amp;y);
5386  			floatElement-&gt;Attribute(TEXT(&quot;width&quot;), &amp;w);
5387  			floatElement-&gt;Attribute(TEXT(&quot;height&quot;), &amp;h);
5388  			_nppGUI._dockingData._flaotingWindowInfo.push_back(FloatingWindowInfo(cont, x, y, w, h));
5389  		}
5390  	}
5391  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;PluginDlg&quot;));
5392  		childNode ;
5393  		childNode = childNode-&gt;NextSibling(TEXT(&quot;PluginDlg&quot;)) )
5394  	{
5395  		TiXmlElement *dlgElement = childNode-&gt;ToElement();
5396  		const TCHAR *name = dlgElement-&gt;Attribute(TEXT(&quot;pluginName&quot;));
5397  		int id;
5398  		const TCHAR *idStr = dlgElement-&gt;Attribute(TEXT(&quot;id&quot;), &amp;id);
5399  		if (name &amp;&amp; idStr)
5400  		{
5401  			int curr = 0; 
5402  			int prev = 0; 
5403  			dlgElement-&gt;Attribute(TEXT(&quot;curr&quot;), &amp;curr);
5404  			dlgElement-&gt;Attribute(TEXT(&quot;prev&quot;), &amp;prev);
5405  			bool isVisible = false;
5406  			const TCHAR *val = dlgElement-&gt;Attribute(TEXT(&quot;isVisible&quot;));
5407  			if (val)
5408  			{
5409  				isVisible = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
5410  			}
5411  			_nppGUI._dockingData._pluginDockInfo.push_back(PluginDlgDockingInfo(name, id, curr, prev, isVisible));
5412  		}
5413  	}
5414  	for (TiXmlNode *childNode = node-&gt;FirstChildElement(TEXT(&quot;ActiveTabs&quot;));
5415  		childNode ;
5416  		childNode = childNode-&gt;NextSibling(TEXT(&quot;ActiveTabs&quot;)) )
5417  	{
5418  		TiXmlElement *dlgElement = childNode-&gt;ToElement();
5419  		int cont;
5420  		if (dlgElement-&gt;Attribute(TEXT(&quot;cont&quot;), &amp;cont))
5421  		{
5422  			int activeTab = 0;
5423  			dlgElement-&gt;Attribute(TEXT(&quot;activeTab&quot;), &amp;activeTab);
5424  			_nppGUI._dockingData._containerTabInfo.push_back(ContainerTabInfo(cont, activeTab));
5425  		}
5426  	}
5427  }
5428  void NppParameters::duplicateDockingManager(TiXmlNode* dockMngNode, TiXmlElement* dockMngElmt2Clone)
5429  {
5430  	if (!dockMngNode || !dockMngElmt2Clone) return;
5431  	TiXmlElement *dockMngElmt = dockMngNode-&gt;ToElement();
5432  	int i;
5433  	if (dockMngElmt-&gt;Attribute(TEXT(&quot;leftWidth&quot;), &amp;i))
5434  		dockMngElmt2Clone-&gt;SetAttribute(TEXT(&quot;leftWidth&quot;), i);
5435  	if (dockMngElmt-&gt;Attribute(TEXT(&quot;rightWidth&quot;), &amp;i))
5436  		dockMngElmt2Clone-&gt;SetAttribute(TEXT(&quot;rightWidth&quot;), i);
5437  	if (dockMngElmt-&gt;Attribute(TEXT(&quot;topHeight&quot;), &amp;i))
5438  		dockMngElmt2Clone-&gt;SetAttribute(TEXT(&quot;topHeight&quot;), i);
5439  	if (dockMngElmt-&gt;Attribute(TEXT(&quot;bottomHeight&quot;), &amp;i))
5440  		dockMngElmt2Clone-&gt;SetAttribute(TEXT(&quot;bottomHeight&quot;), i);
5441  	for (TiXmlNode *childNode = dockMngNode-&gt;FirstChildElement(TEXT(&quot;FloatingWindow&quot;));
5442  		childNode;
5443  		childNode = childNode-&gt;NextSibling(TEXT(&quot;FloatingWindow&quot;)))
5444  	{
5445  		TiXmlElement *floatElement = childNode-&gt;ToElement();
5446  		int cont;
5447  		if (floatElement-&gt;Attribute(TEXT(&quot;cont&quot;), &amp;cont))
5448  		{
5449  			TiXmlElement FWNode(TEXT(&quot;FloatingWindow&quot;));
5450  			FWNode.SetAttribute(TEXT(&quot;cont&quot;), cont);
5451  			int x = 0;
5452  			int y = 0;
5453  			int w = 100;
5454  			int h = 100;
5455  			floatElement-&gt;Attribute(TEXT(&quot;x&quot;), &amp;x);
5456  			FWNode.SetAttribute(TEXT(&quot;x&quot;), x);
5457  			floatElement-&gt;Attribute(TEXT(&quot;y&quot;), &amp;y);
5458  			FWNode.SetAttribute(TEXT(&quot;y&quot;), y);
5459  			floatElement-&gt;Attribute(TEXT(&quot;width&quot;), &amp;w);
5460  			FWNode.SetAttribute(TEXT(&quot;width&quot;), w);
5461  			floatElement-&gt;Attribute(TEXT(&quot;height&quot;), &amp;h);
5462  			FWNode.SetAttribute(TEXT(&quot;height&quot;), h);
5463  			dockMngElmt2Clone-&gt;InsertEndChild(FWNode);
5464  		}
5465  	}
5466  	for (TiXmlNode *childNode = dockMngNode-&gt;FirstChildElement(TEXT(&quot;PluginDlg&quot;));
5467  		childNode;
5468  		childNode = childNode-&gt;NextSibling(TEXT(&quot;PluginDlg&quot;)))
5469  	{
5470  		TiXmlElement *dlgElement = childNode-&gt;ToElement();
5471  		const TCHAR *name = dlgElement-&gt;Attribute(TEXT(&quot;pluginName&quot;));
5472  		TiXmlElement PDNode(TEXT(&quot;PluginDlg&quot;));
5473  		int id;
5474  		const TCHAR *idStr = dlgElement-&gt;Attribute(TEXT(&quot;id&quot;), &amp;id);
5475  		if (name &amp;&amp; idStr)
5476  		{
5477  			int curr = 0; 
5478  			int prev = 0; 
5479  			dlgElement-&gt;Attribute(TEXT(&quot;curr&quot;), &amp;curr);
5480  			dlgElement-&gt;Attribute(TEXT(&quot;prev&quot;), &amp;prev);
5481  			bool isVisible = false;
5482  			const TCHAR *val = dlgElement-&gt;Attribute(TEXT(&quot;isVisible&quot;));
5483  			if (val)
5484  			{
5485  				isVisible = (lstrcmp(val, TEXT(&quot;yes&quot;)) == 0);
5486  			}
5487  			PDNode.SetAttribute(TEXT(&quot;pluginName&quot;), name);
5488  			PDNode.SetAttribute(TEXT(&quot;id&quot;), idStr);
5489  			PDNode.SetAttribute(TEXT(&quot;curr&quot;), curr);
5490  			PDNode.SetAttribute(TEXT(&quot;prev&quot;), prev);
5491  			PDNode.SetAttribute(TEXT(&quot;isVisible&quot;), isVisible ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5492  			dockMngElmt2Clone-&gt;InsertEndChild(PDNode);
5493  		}
5494  	}
5495  	for (TiXmlNode *childNode = dockMngNode-&gt;FirstChildElement(TEXT(&quot;ActiveTabs&quot;));
5496  		childNode;
5497  		childNode = childNode-&gt;NextSibling(TEXT(&quot;ActiveTabs&quot;)))
5498  	{
5499  		TiXmlElement *dlgElement = childNode-&gt;ToElement();
5500  		TiXmlElement CTNode(TEXT(&quot;ActiveTabs&quot;));
5501  		int cont;
5502  		if (dlgElement-&gt;Attribute(TEXT(&quot;cont&quot;), &amp;cont))
5503  		{
5504  			int activeTab = 0;
5505  			dlgElement-&gt;Attribute(TEXT(&quot;activeTab&quot;), &amp;activeTab);
5506  			CTNode.SetAttribute(TEXT(&quot;cont&quot;), cont);
5507  			CTNode.SetAttribute(TEXT(&quot;activeTab&quot;), activeTab);
5508  			dockMngElmt2Clone-&gt;InsertEndChild(CTNode);
5509  		}
5510  	}
5511  }
5512  bool NppParameters::writeScintillaParams()
5513  {
5514  	if (!_pXmlUserDoc) return false;
5515  	const TCHAR *pViewName = TEXT(&quot;ScintillaPrimaryView&quot;);
5516  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
5517  	if (!nppRoot)
5518  	{
5519  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
5520  	}
5521  	TiXmlNode *configsRoot = nppRoot-&gt;FirstChildElement(TEXT(&quot;GUIConfigs&quot;));
5522  	if (!configsRoot)
5523  	{
5524  		configsRoot = nppRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfigs&quot;)));
5525  	}
5526  	TiXmlNode *scintNode = getChildElementByAttribut(configsRoot, TEXT(&quot;GUIConfig&quot;), TEXT(&quot;name&quot;), pViewName);
5527  	if (!scintNode)
5528  	{
5529  		scintNode = configsRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;)));
5530  		(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), pViewName);
5531  	}
5532  	auto setYesNoBoolAttribute = [&amp;scintNode](const TCHAR* name, bool value) -&gt; void {
5533  		const TCHAR* pStr = value ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5534  		(scintNode-&gt;ToElement())-&gt;SetAttribute(name, pStr);
5535  	};
5536  	auto setShowHideBoolAttribute = [&amp;scintNode](const TCHAR* name, bool value) -&gt; void {
5537  		const TCHAR* pStr = value ? TEXT(&quot;show&quot;) : TEXT(&quot;hide&quot;);
5538  		(scintNode-&gt;ToElement())-&gt;SetAttribute(name, pStr);
5539  	};
5540  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;lineNumberMargin&quot;), _svp._lineNumberMarginShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5541  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;lineNumberDynamicWidth&quot;), _svp._lineNumberMarginDynamicWidth ?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5542  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;bookMarkMargin&quot;), _svp._bookMarkMarginShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5543  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;indentGuideLine&quot;), _svp._indentGuideLineShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5544  	const TCHAR *pFolderStyleStr = (_svp._folderStyle == FOLDER_STYLE_SIMPLE)?TEXT(&quot;simple&quot;):
5545  									(_svp._folderStyle == FOLDER_STYLE_ARROW)?TEXT(&quot;arrow&quot;):
5546  										(_svp._folderStyle == FOLDER_STYLE_CIRCLE)?TEXT(&quot;circle&quot;):
5547  										(_svp._folderStyle == FOLDER_STYLE_NONE)?TEXT(&quot;none&quot;):TEXT(&quot;box&quot;);
5548  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;folderMarkStyle&quot;), pFolderStyleStr);
5549  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;isChangeHistoryEnabled&quot;), _svp._isChangeHistoryEnabled4NextSession ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5550  	const TCHAR *pWrapMethodStr = (_svp._lineWrapMethod == LINEWRAP_ALIGNED)?TEXT(&quot;aligned&quot;):
5551  								(_svp._lineWrapMethod == LINEWRAP_INDENT)?TEXT(&quot;indent&quot;):TEXT(&quot;default&quot;);
5552  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;lineWrapMethod&quot;), pWrapMethodStr);
5553  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;currentLineIndicator&quot;), _svp._currentLineHiliteMode);
5554  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;currentLineFrameWidth&quot;), _svp._currentLineFrameWidth);
5555  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;virtualSpace&quot;), _svp._virtualSpace?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5556  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;scrollBeyondLastLine&quot;), _svp._scrollBeyondLastLine?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5557  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;rightClickKeepsSelection&quot;), _svp._rightClickKeepsSelection ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5558  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;disableAdvancedScrolling&quot;), _svp._disableAdvancedScrolling?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5559  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;wrapSymbolShow&quot;), _svp._wrapSymbolShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5560  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;Wrap&quot;), _svp._doWrap?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
5561  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;borderEdge&quot;), _svp._showBorderEdge ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5562  	generic_string edgeColumnPosStr;
5563  	for (auto i : _svp._edgeMultiColumnPos)
5564  	{
5565  		std::string s = std::to_string(i);
5566  		edgeColumnPosStr += generic_string(s.begin(), s.end());
5567  		edgeColumnPosStr += TEXT(&quot; &quot;);
5568  	}
5569  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;isEdgeBgMode&quot;), _svp._isEdgeBgMode ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5570  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;edgeMultiColumnPos&quot;), edgeColumnPosStr);
5571  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;zoom&quot;), static_cast&lt;int&gt;(_svp._zoom));
5572  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;zoom2&quot;), static_cast&lt;int&gt;(_svp._zoom2));
5573  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;whiteSpaceShow&quot;), _svp._whiteSpaceShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5574  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;eolShow&quot;), _svp._eolShow?TEXT(&quot;show&quot;):TEXT(&quot;hide&quot;));
5575  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;eolMode&quot;), _svp._eolMode);
5576  	setShowHideBoolAttribute(TEXT(&quot;npcShow&quot;), _svp._npcShow);
5577  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;npcMode&quot;), static_cast&lt;int&gt;(_svp._npcMode));
5578  	setYesNoBoolAttribute(TEXT(&quot;npcCustomColor&quot;), _svp._npcCustomColor);
5579  	setYesNoBoolAttribute(TEXT(&quot;npcIncludeCcUniEOL&quot;), _svp._npcIncludeCcUniEol);
5580  	setYesNoBoolAttribute(TEXT(&quot;ccShow&quot;), _svp._ccUniEolShow);
5581  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;borderWidth&quot;), _svp._borderWidth);
5582  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;smoothFont&quot;), _svp._doSmoothFont ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5583  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;paddingLeft&quot;), _svp._paddingLeft);
5584  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;paddingRight&quot;), _svp._paddingRight);
5585  	(scintNode-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;distractionFreeDivPart&quot;), _svp._distractionFreeDivPart);
5586  	return true;
5587  }
5588  void NppParameters::createXmlTreeFromGUIParams()
5589  {
5590  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
5591  	if (!nppRoot)
5592  	{
5593  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
5594  	}
5595  	TiXmlNode *oldGUIRoot = nppRoot-&gt;FirstChildElement(TEXT(&quot;GUIConfigs&quot;));
5596  	TiXmlElement* dockMngNodeDup = nullptr;
5597  	TiXmlNode* dockMngNodeOriginal = nullptr;
5598  	if (oldGUIRoot &amp;&amp; _nppGUI._isCmdlineNosessionActivated)
5599  	{
5600  		for (TiXmlNode *childNode = oldGUIRoot-&gt;FirstChildElement(TEXT(&quot;GUIConfig&quot;));
5601  			childNode;
5602  			childNode = childNode-&gt;NextSibling(TEXT(&quot;GUIConfig&quot;)))
5603  		{
5604  			TiXmlElement* element = childNode-&gt;ToElement();
5605  			const TCHAR* nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
5606  			if (nullptr == nm)
5607  				continue;
5608  			if (!lstrcmp(nm, TEXT(&quot;DockingManager&quot;)))
5609  			{
5610  				dockMngNodeOriginal = childNode;
5611  				break;
5612  			}
5613  		}
5614  		if (dockMngNodeOriginal)
5615  		{
5616  			dockMngNodeDup = new TiXmlElement(TEXT(&quot;GUIConfig&quot;));
5617  			dockMngNodeDup-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;DockingManager&quot;));
5618  			duplicateDockingManager(dockMngNodeOriginal, dockMngNodeDup);
5619  		}
5620  	}
5621  	if (oldGUIRoot)
5622  	{
5623  		nppRoot-&gt;RemoveChild(oldGUIRoot);
5624  	}
5625  	TiXmlNode *newGUIRoot = nppRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfigs&quot;)));
5626  	{
5627  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5628  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;ToolBar&quot;));
5629  		const TCHAR *pStr = (_nppGUI._toolbarShow) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5630  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;visible&quot;), pStr);
5631  		if (_nppGUI._toolBarStatus == TB_SMALL)
5632  			pStr = TEXT(&quot;small&quot;);
5633  		else if (_nppGUI._toolBarStatus == TB_LARGE)
5634  			pStr = TEXT(&quot;large&quot;);
5635  		else if (_nppGUI._toolBarStatus == TB_SMALL2)
5636  			pStr = TEXT(&quot;small2&quot;);
5637  		else if (_nppGUI._toolBarStatus == TB_LARGE2)
5638  			pStr = TEXT(&quot;large2&quot;);
5639  		else 
5640  			pStr = TEXT(&quot;standard&quot;);
5641  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5642  	}
5643  	{
5644  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5645  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;StatusBar&quot;));
5646  		const TCHAR *pStr = _nppGUI._statusBarShow ? TEXT(&quot;show&quot;) : TEXT(&quot;hide&quot;);
5647  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5648  	}
5649  	{
5650  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5651  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;TabBar&quot;));
5652  		const TCHAR *pStr = (_nppGUI._tabStatus &amp; TAB_DRAWTOPBAR) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5653  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;dragAndDrop&quot;), pStr);
5654  		pStr = (_nppGUI._tabStatus &amp; TAB_DRAGNDROP) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5655  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;drawTopBar&quot;), pStr);
5656  		pStr = (_nppGUI._tabStatus &amp; TAB_DRAWINACTIVETAB) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5657  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;drawInactiveTab&quot;), pStr);
5658  		pStr = (_nppGUI._tabStatus &amp; TAB_REDUCE) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5659  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;reduce&quot;), pStr);
5660  		pStr = (_nppGUI._tabStatus &amp; TAB_CLOSEBUTTON) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5661  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;closeButton&quot;), pStr);
5662  		pStr = (_nppGUI._tabStatus &amp; TAB_DBCLK2CLOSE) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5663  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;doubleClick2Close&quot;), pStr);
5664  		pStr = (_nppGUI._tabStatus &amp; TAB_VERTICAL) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5665  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;vertical&quot;), pStr);
5666  		pStr = (_nppGUI._tabStatus &amp; TAB_MULTILINE) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5667  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;multiLine&quot;), pStr);
5668  		pStr = (_nppGUI._tabStatus &amp; TAB_HIDE) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5669  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;hide&quot;), pStr);
5670  		pStr = (_nppGUI._tabStatus &amp; TAB_QUITONEMPTY) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5671  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;quitOnEmpty&quot;), pStr);
5672  		pStr = (_nppGUI._tabStatus &amp; TAB_ALTICONS) ? TEXT(&quot;1&quot;) : TEXT(&quot;0&quot;);
5673  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;iconSetNumber&quot;), pStr);
5674  	}
5675  	{
5676  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5677  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;ScintillaViewsSplitter&quot;));
5678  		const TCHAR *pStr = _nppGUI._splitterPos == POS_VERTICAL ? TEXT(&quot;vertical&quot;) : TEXT(&quot;horizontal&quot;);
5679  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5680  	}
5681  	{
5682  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5683  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;UserDefineDlg&quot;));
5684  		const TCHAR *pStr = (_nppGUI._userDefineDlgStatus &amp; UDD_DOCKED) ? TEXT(&quot;docked&quot;) : TEXT(&quot;undocked&quot;);
5685  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;position&quot;), pStr);
5686  		pStr = (_nppGUI._userDefineDlgStatus &amp; UDD_SHOW) ? TEXT(&quot;show&quot;) : TEXT(&quot;hide&quot;);
5687  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5688  	}
5689  	{
5690  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5691  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;TabSetting&quot;));
5692  		const TCHAR *pStr = _nppGUI._tabReplacedBySpace ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5693  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;replaceBySpace&quot;), pStr);
5694  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;size&quot;), _nppGUI._tabSize);
5695  	}
5696  	{
5697  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5698  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;AppPosition&quot;));
5699  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;x&quot;), _nppGUI._appPos.left);
5700  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;y&quot;), _nppGUI._appPos.top);
5701  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;width&quot;), _nppGUI._appPos.right);
5702  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;height&quot;), _nppGUI._appPos.bottom);
5703  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isMaximized&quot;), _nppGUI._isMaximized ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5704  	}
5705  	{
5706  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5707  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;FindWindowPosition&quot;));
5708  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;left&quot;), _nppGUI._findWindowPos.left);
5709  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;top&quot;), _nppGUI._findWindowPos.top);
5710  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;right&quot;), _nppGUI._findWindowPos.right);
5711  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;bottom&quot;), _nppGUI._findWindowPos.bottom);
5712  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isLessModeOn&quot;), _nppGUI._findWindowLessMode ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5713  	}
5714  	{
5715  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5716  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;FinderConfig&quot;));
5717  		const TCHAR* pStr = _nppGUI._finderLinesAreCurrentlyWrapped ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5718  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;wrappedLines&quot;), pStr);
5719  		pStr = _nppGUI._finderPurgeBeforeEverySearch ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5720  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;purgeBeforeEverySearch&quot;), pStr);
5721  		pStr = _nppGUI._finderShowOnlyOneEntryPerFoundLine ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5722  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;showOnlyOneEntryPerFoundLine&quot;), pStr);
5723  	}
5724  	{
5725  		TiXmlElement *element = insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;noUpdate&quot;), !_nppGUI._autoUpdateOpt._doAutoUpdate);
5726  		element-&gt;SetAttribute(TEXT(&quot;intervalDays&quot;), _nppGUI._autoUpdateOpt._intervalDays);
5727  		element-&gt;SetAttribute(TEXT(&quot;nextUpdateDate&quot;), _nppGUI._autoUpdateOpt._nextUpdateDate.toString().c_str());
5728  	}
5729  	{
5730  		const TCHAR *pStr = TEXT(&quot;no&quot;);
5731  		if (_nppGUI._fileAutoDetection &amp; cdEnabledOld)
5732  		{
5733  			pStr = TEXT(&quot;yesOld&quot;);
5734  			if ((_nppGUI._fileAutoDetection &amp; cdAutoUpdate) &amp;&amp; (_nppGUI._fileAutoDetection &amp; cdGo2end))
5735  			{
5736  				pStr = TEXT(&quot;autoUpdate2EndOld&quot;);
5737  			}
5738  			else if (_nppGUI._fileAutoDetection &amp; cdAutoUpdate)
5739  			{
5740  				pStr = TEXT(&quot;autoOld&quot;);
5741  			}
5742  			else if (_nppGUI._fileAutoDetection &amp; cdGo2end)
5743  			{
5744  				pStr = TEXT(&quot;Update2EndOld&quot;);
5745  			}
5746  		}
5747  		else if (_nppGUI._fileAutoDetection &amp; cdEnabledNew)
5748  		{
5749  			pStr = TEXT(&quot;yes&quot;);
5750  			if ((_nppGUI._fileAutoDetection &amp; cdAutoUpdate) &amp;&amp; (_nppGUI._fileAutoDetection &amp; cdGo2end))
5751  			{
5752  				pStr = TEXT(&quot;autoUpdate2End&quot;);
5753  			}
5754  			else if (_nppGUI._fileAutoDetection &amp; cdAutoUpdate)
5755  			{
5756  				pStr = TEXT(&quot;auto&quot;);
5757  			}
5758  			else if (_nppGUI._fileAutoDetection &amp; cdGo2end)
5759  			{
5760  				pStr = TEXT(&quot;Update2End&quot;);
5761  			}
5762  		}
5763  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5764  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Auto-detection&quot;));
5765  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
5766  	}
5767  	{
5768  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;CheckHistoryFiles&quot;), _nppGUI._checkHistoryFiles);
5769  	}
5770  	{
5771  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;TrayIcon&quot;), _nppGUI._isMinimizedToTray);
5772  	}
5773  	{
5774  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;MaitainIndent&quot;), _nppGUI._maitainIndent);
5775  	}
5776  	{
5777  		TiXmlElement * ele = insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;TagsMatchHighLight&quot;), _nppGUI._enableTagsMatchHilite);
5778  		ele-&gt;SetAttribute(TEXT(&quot;TagAttrHighLight&quot;), _nppGUI._enableTagAttrsHilite ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5779  		ele-&gt;SetAttribute(TEXT(&quot;HighLightNonHtmlZone&quot;), _nppGUI._enableHiliteNonHTMLZone ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5780  	}
5781  	{
5782  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;RememberLastSession&quot;), _nppGUI._rememberLastSession);
5783  	}
5784  	{
5785  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;DetectEncoding&quot;), _nppGUI._detectEncoding);
5786  	}
5787  	{
5788  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;SaveAllConfirm&quot;), _nppGUI._saveAllConfirm);
5789  	}
5790  	{
5791  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5792  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;NewDocDefaultSettings&quot;));
5793  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;format&quot;), static_cast&lt;int32_t&gt;(_nppGUI._newDocDefaultSettings._format));
5794  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;encoding&quot;), _nppGUI._newDocDefaultSettings._unicodeMode);
5795  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;lang&quot;), _nppGUI._newDocDefaultSettings._lang);
5796  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;codepage&quot;), _nppGUI._newDocDefaultSettings._codepage);
5797  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;openAnsiAsUTF8&quot;), _nppGUI._newDocDefaultSettings._openAnsiAsUtf8 ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5798  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;addNewDocumentOnStartup&quot;), _nppGUI._newDocDefaultSettings._addNewDocumentOnStartup ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5799  	}
5800  	{
5801  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5802  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;langsExcluded&quot;));
5803  		writeExcludedLangList(GUIConfigElement);
5804  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;langMenuCompact&quot;), _nppGUI._isLangMenuCompact ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5805  	}
5806  	{
5807  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5808  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Print&quot;));
5809  		writePrintSetting(GUIConfigElement);
5810  	}
5811  	{
5812  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5813  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Backup&quot;));
5814  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;action&quot;), _nppGUI._backup);
5815  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;useCustumDir&quot;), _nppGUI._useDir ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5816  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;dir&quot;), _nppGUI._backupDir.c_str());
5817  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isSnapshotMode&quot;), _nppGUI._isSnapshotMode ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5818  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;snapshotBackupTiming&quot;), static_cast&lt;int32_t&gt;(_nppGUI._snapshotBackupTiming));
5819  	}
5820  	{
5821  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;TaskList&quot;), _nppGUI._doTaskList);
5822  	}
5823  	{
5824  		insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;MRU&quot;), _nppGUI._styleMRU);
5825  	}
5826  	{
5827  		TCHAR szStr [12] = TEXT(&quot;0&quot;);
5828  		_itow(_nppGUI._styleURL, szStr, 10);
5829  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5830  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;URL&quot;));
5831  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(szStr));
5832  	}
5833  	{
5834  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5835  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;uriCustomizedSchemes&quot;));
5836  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._uriSchemes.c_str()));
5837  	}
5838  	{
5839  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5840  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;globalOverride&quot;));
5841  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fg&quot;), _nppGUI._globalOverride.enableFg ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5842  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;bg&quot;), _nppGUI._globalOverride.enableBg ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5843  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;font&quot;), _nppGUI._globalOverride.enableFont ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5844  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), _nppGUI._globalOverride.enableFontSize ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5845  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;bold&quot;), _nppGUI._globalOverride.enableBold ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5846  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;italic&quot;), _nppGUI._globalOverride.enableItalic ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5847  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;underline&quot;), _nppGUI._globalOverride.enableUnderLine ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5848  	}
5849  	{
5850  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5851  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;auto-completion&quot;));
5852  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;autoCAction&quot;), _nppGUI._autocStatus);
5853  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;triggerFromNbChar&quot;), static_cast&lt;int32_t&gt;(_nppGUI._autocFromLen));
5854  		const TCHAR * pStr = _nppGUI._autocIgnoreNumbers ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5855  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;autoCIgnoreNumbers&quot;), pStr);
5856  		pStr = _nppGUI._autocInsertSelectedUseENTER ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5857  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;insertSelectedItemUseENTER&quot;), pStr);
5858  		pStr = _nppGUI._autocInsertSelectedUseTAB ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5859  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;insertSelectedItemUseTAB&quot;), pStr);
5860  		pStr = _nppGUI._autocBrief ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5861  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;autoCBrief&quot;), pStr);
5862  		pStr = _nppGUI._funcParams ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5863  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;funcParams&quot;), pStr);
5864  	}
5865  	{
5866  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5867  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;auto-insert&quot;));
5868  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;parentheses&quot;), _nppGUI._matchedPairConf._doParentheses ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5869  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;brackets&quot;), _nppGUI._matchedPairConf._doBrackets ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5870  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;curlyBrackets&quot;), _nppGUI._matchedPairConf._doCurlyBrackets ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5871  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;quotes&quot;), _nppGUI._matchedPairConf._doQuotes ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5872  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;doubleQuotes&quot;), _nppGUI._matchedPairConf._doDoubleQuotes ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5873  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;htmlXmlTag&quot;), _nppGUI._matchedPairConf._doHtmlXmlTag ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5874  		TiXmlElement hist_element{ TEXT(&quot;&quot;) };
5875  		hist_element.SetValue(TEXT(&quot;UserDefinePair&quot;));
5876  		for (size_t i = 0, nb = _nppGUI._matchedPairConf._matchedPairs.size(); i &lt; nb; ++i)
5877  		{
5878  			int open = _nppGUI._matchedPairConf._matchedPairs[i].first;
5879  			int close = _nppGUI._matchedPairConf._matchedPairs[i].second;
5880  			(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;open&quot;), open);
5881  			(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;close&quot;), close);
5882  			GUIConfigElement-&gt;InsertEndChild(hist_element);
5883  		}
5884  	}
5885  	{
5886  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5887  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;sessionExt&quot;));
5888  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._definedSessionExt.c_str()));
5889  	}
5890  	{
5891  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5892  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;workspaceExt&quot;));
5893  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._definedWorkspaceExt.c_str()));
5894  	}
5895  	{
5896  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5897  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;MenuBar&quot;));
5898  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._menuBarShow ? TEXT(&quot;show&quot;) : TEXT(&quot;hide&quot;)));
5899  	}
5900  	{
5901  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5902  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Caret&quot;));
5903  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;width&quot;), _nppGUI._caretWidth);
5904  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;blinkRate&quot;), _nppGUI._caretBlinkRate);
5905  	}
5906  	{
5907  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5908  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;ScintillaGlobalSettings&quot;));
5909  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;enableMultiSelection&quot;), _nppGUI._enableMultiSelection ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5910  	}
5911  	{
5912  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5913  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;openSaveDir&quot;));
5914  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;value&quot;), _nppGUI._openSaveDir);
5915  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;defaultDirPath&quot;), _nppGUI._defaultDir);
5916  	}
5917  	{
5918  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5919  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;titleBar&quot;));
5920  		const TCHAR *pStr = (_nppGUI._shortTitlebar) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5921  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;short&quot;), pStr);
5922  	}
5923  	{
5924  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5925  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;insertDateTime&quot;));
5926  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customizedFormat&quot;), _nppGUI._dateTimeFormat.c_str());
5927  		const TCHAR* pStr = (_nppGUI._dateTimeReverseDefaultOrder) ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5928  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;reverseDefaultOrder&quot;), pStr);
5929  	}
5930  	{
5931  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5932  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;wordCharList&quot;));
5933  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;useDefault&quot;), _nppGUI._isWordCharDefault ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5934  		WcharMbcsConvertor&amp; wmc = WcharMbcsConvertor::getInstance();
5935  		const wchar_t* charsAddStr = wmc.char2wchar(_nppGUI._customWordChars.c_str(), SC_CP_UTF8);
5936  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;charsAdded&quot;), charsAddStr);
5937  	}
5938  	{
5939  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5940  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;delimiterSelection&quot;));
5941  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;leftmostDelimiter&quot;), _nppGUI._leftmostDelimiter);
5942  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;rightmostDelimiter&quot;), _nppGUI._rightmostDelimiter);
5943  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;delimiterSelectionOnEntireDocument&quot;), _nppGUI._delimiterSelectionOnEntireDocument ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5944  	}
5945  	{
5946  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5947  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;largeFileRestriction&quot;));
5948  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSizeMB&quot;), static_cast&lt;int&gt;((_nppGUI._largeFileRestriction._largeFileSizeDefInByte / 1024) / 1024));
5949  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isEnabled&quot;), _nppGUI._largeFileRestriction._isEnabled ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5950  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;allowAutoCompletion&quot;), _nppGUI._largeFileRestriction._allowAutoCompletion ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5951  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;allowBraceMatch&quot;), _nppGUI._largeFileRestriction._allowBraceMatch ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5952  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;allowSmartHilite&quot;), _nppGUI._largeFileRestriction._allowSmartHilite ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5953  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;allowClickableLink&quot;), _nppGUI._largeFileRestriction._allowClickableLink ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5954  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;deactivateWordWrap&quot;), _nppGUI._largeFileRestriction._deactivateWordWrap ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5955  	}
5956  	{
5957  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5958  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;multiInst&quot;));
5959  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;setting&quot;), _nppGUI._multiInstSetting);
5960  		auto setYesNoBoolAttribute = [&amp;GUIConfigElement](const TCHAR* name, bool value) -&gt; void {
5961  			const TCHAR* pStr = value ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5962  			GUIConfigElement-&gt;SetAttribute(name, pStr);
5963  		};
5964  		setYesNoBoolAttribute(TEXT(&quot;clipboardHistory&quot;), _nppGUI._clipboardHistoryPanelKeepState);
5965  		setYesNoBoolAttribute(TEXT(&quot;documentList&quot;), _nppGUI._docListKeepState);
5966  		setYesNoBoolAttribute(TEXT(&quot;characterPanel&quot;), _nppGUI._charPanelKeepState);
5967  		setYesNoBoolAttribute(TEXT(&quot;folderAsWorkspace&quot;), _nppGUI._fileBrowserKeepState);
5968  		setYesNoBoolAttribute(TEXT(&quot;projectPanels&quot;), _nppGUI._projectPanelKeepState);
5969  		setYesNoBoolAttribute(TEXT(&quot;documentMap&quot;), _nppGUI._docMapKeepState);
5970  		setYesNoBoolAttribute(TEXT(&quot;fuctionList&quot;), _nppGUI._funcListKeepState);
5971  		setYesNoBoolAttribute(TEXT(&quot;pluginPanels&quot;), _nppGUI._pluginPanelKeepState);
5972  	}
5973  	{
5974  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5975  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;MISC&quot;));
5976  		auto setYesNoBoolAttribute = [&amp;GUIConfigElement](const TCHAR* name, bool value) -&gt; void {
5977  			const TCHAR* pStr = value ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
5978  			GUIConfigElement-&gt;SetAttribute(name, pStr);
5979  		};
5980  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSwitcherWithoutExtColumn&quot;), _nppGUI._fileSwitcherWithoutExtColumn ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5981  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSwitcherExtWidth&quot;), _nppGUI._fileSwitcherExtWidth);
5982  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSwitcherWithoutPathColumn&quot;), _nppGUI._fileSwitcherWithoutPathColumn ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5983  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fileSwitcherPathWidth&quot;), _nppGUI._fileSwitcherPathWidth);
5984  		setYesNoBoolAttribute(TEXT(&quot;fileSwitcherNoGroups&quot;), _nppGUI._fileSwitcherDisableListViewGroups);
5985  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;backSlashIsEscapeCharacterForSql&quot;), _nppGUI._backSlashIsEscapeCharacterForSql ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5986  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;writeTechnologyEngine&quot;), _nppGUI._writeTechnologyEngine);
5987  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;isFolderDroppedOpenFiles&quot;), _nppGUI._isFolderDroppedOpenFiles ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5988  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;docPeekOnTab&quot;), _nppGUI._isDocPeekOnTab ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5989  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;docPeekOnMap&quot;), _nppGUI._isDocPeekOnMap ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5990  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;sortFunctionList&quot;), _nppGUI._shouldSortFunctionList ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5991  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;saveDlgExtFilterToAllTypes&quot;), _nppGUI._setSaveDlgExtFiltToAllTypes ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5992  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;muteSounds&quot;), _nppGUI._muteSounds ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5993  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;enableFoldCmdToggable&quot;), _nppGUI._enableFoldCmdToggable ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5994  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;hideMenuRightShortcuts&quot;), _nppGUI._hideMenuRightShortcuts ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
5995  	}
5996  	{
5997  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
5998  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;Searching&quot;));
5999  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;monospacedFontFindDlg&quot;), _nppGUI._monospacedFontFindDlg ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6000  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fillFindFieldWithSelected&quot;), _nppGUI._fillFindFieldWithSelected ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6001  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;fillFindFieldSelectCaret&quot;), _nppGUI._fillFindFieldSelectCaret ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6002  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;findDlgAlwaysVisible&quot;), _nppGUI._findDlgAlwaysVisible ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6003  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;confirmReplaceInAllOpenDocs&quot;), _nppGUI._confirmReplaceInAllOpenDocs ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6004  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;replaceStopsWithoutFindingNext&quot;), _nppGUI._replaceStopsWithoutFindingNext ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6005  	}
6006  	{
6007  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6008  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;searchEngine&quot;));
6009  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;searchEngineChoice&quot;), _nppGUI._searchEngineChoice);
6010  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;searchEngineCustom&quot;), _nppGUI._searchEngineCustom);
6011  	}
6012  	{
6013  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6014  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;MarkAll&quot;));
6015  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;matchCase&quot;), _nppGUI._markAllCaseSensitive ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6016  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;wholeWordOnly&quot;), _nppGUI._markAllWordOnly ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6017  	}
6018  	{
6019  		TiXmlElement *GUIConfigElement = insertGUIConfigBoolNode(newGUIRoot, TEXT(&quot;SmartHighLight&quot;), _nppGUI._enableSmartHilite);
6020  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;matchCase&quot;), _nppGUI._smartHiliteCaseSensitive ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6021  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;wholeWordOnly&quot;), _nppGUI._smartHiliteWordOnly ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6022  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;useFindSettings&quot;), _nppGUI._smartHiliteUseFindSettings ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6023  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;onAnotherView&quot;), _nppGUI._smartHiliteOnAnotherView ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6024  	}
6025  	if (_nppGUI._commandLineInterpreter.compare(CMD_INTERPRETER))
6026  	{
6027  		TiXmlElement *GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6028  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;commandLineInterpreter&quot;));
6029  		GUIConfigElement-&gt;InsertEndChild(TiXmlText(_nppGUI._commandLineInterpreter.c_str()));
6030  	}
6031  	{
6032  		TiXmlElement* GUIConfigElement = (newGUIRoot-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6033  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;DarkMode&quot;));
6034  		NppDarkMode::setAdvancedOptions();
6035  		auto setYesNoBoolAttribute = [&amp;GUIConfigElement](const TCHAR* name, bool value) {
6036  			const TCHAR* pStr = value ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;);
6037  			GUIConfigElement-&gt;SetAttribute(name, pStr);
6038  		};
6039  		setYesNoBoolAttribute(TEXT(&quot;enable&quot;), _nppGUI._darkmode._isEnabled);
6040  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;colorTone&quot;), _nppGUI._darkmode._colorTone);
6041  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorTop&quot;), _nppGUI._darkmode._customColors.pureBackground);
6042  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorMenuHotTrack&quot;), _nppGUI._darkmode._customColors.hotBackground);
6043  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorActive&quot;), _nppGUI._darkmode._customColors.softerBackground);
6044  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorMain&quot;), _nppGUI._darkmode._customColors.background);
6045  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorError&quot;), _nppGUI._darkmode._customColors.errorBackground);
6046  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorText&quot;), _nppGUI._darkmode._customColors.text);
6047  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorDarkText&quot;), _nppGUI._darkmode._customColors.darkerText);
6048  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorDisabledText&quot;), _nppGUI._darkmode._customColors.disabledText);
6049  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorLinkText&quot;), _nppGUI._darkmode._customColors.linkText);
6050  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorEdge&quot;), _nppGUI._darkmode._customColors.edge);
6051  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorHotEdge&quot;), _nppGUI._darkmode._customColors.hotEdge);
6052  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;customColorDisabledEdge&quot;), _nppGUI._darkmode._customColors.disabledEdge);
6053  		setYesNoBoolAttribute(TEXT(&quot;enableWindowsMode&quot;), _nppGUI._darkmode._advOptions._enableWindowsMode);
6054  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;darkThemeName&quot;), _nppGUI._darkmode._advOptions._darkDefaults._xmlFileName.c_str());
6055  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;darkToolBarIconSet&quot;), _nppGUI._darkmode._advOptions._darkDefaults._toolBarIconSet);
6056  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;darkTabIconSet&quot;), _nppGUI._darkmode._advOptions._darkDefaults._tabIconSet);
6057  		setYesNoBoolAttribute(TEXT(&quot;darkTabUseTheme&quot;), _nppGUI._darkmode._advOptions._darkDefaults._tabUseTheme);
6058  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;lightThemeName&quot;), _nppGUI._darkmode._advOptions._lightDefaults._xmlFileName.c_str());
6059  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;lightToolBarIconSet&quot;), _nppGUI._darkmode._advOptions._lightDefaults._toolBarIconSet);
6060  		GUIConfigElement-&gt;SetAttribute(TEXT(&quot;lightTabIconSet&quot;), _nppGUI._darkmode._advOptions._lightDefaults._tabIconSet);
6061  		setYesNoBoolAttribute(TEXT(&quot;lightTabUseTheme&quot;), _nppGUI._darkmode._advOptions._lightDefaults._tabUseTheme);
6062  	}
6063  	writeScintillaParams();
6064  	if (_nppGUI._isCmdlineNosessionActivated &amp;&amp; dockMngNodeDup)
6065  	{
6066  		newGUIRoot-&gt;InsertEndChild(*dockMngNodeDup);
6067  		delete dockMngNodeDup;
6068  	}
6069  	else
6070  	{
6071  		insertDockingParamNode(newGUIRoot);
6072  	}
6073  }
6074  bool NppParameters::writeFindHistory()
6075  {
6076  	if (!_pXmlUserDoc) return false;
6077  	TiXmlNode *nppRoot = _pXmlUserDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;));
6078  	if (!nppRoot)
6079  	{
6080  		nppRoot = _pXmlUserDoc-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;NotepadPlus&quot;)));
6081  	}
6082  	TiXmlNode *findHistoryRoot = nppRoot-&gt;FirstChildElement(TEXT(&quot;FindHistory&quot;));
6083  	if (!findHistoryRoot)
6084  	{
6085  		TiXmlElement element(TEXT(&quot;FindHistory&quot;));
6086  		findHistoryRoot = nppRoot-&gt;InsertEndChild(element);
6087  	}
6088  	findHistoryRoot-&gt;Clear();
6089  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFindHistoryPath&quot;),	_findHistory._nbMaxFindHistoryPath);
6090  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFindHistoryFilter&quot;),  _findHistory._nbMaxFindHistoryFilter);
6091  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFindHistoryFind&quot;),	_findHistory._nbMaxFindHistoryFind);
6092  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;nbMaxFindHistoryReplace&quot;), _findHistory._nbMaxFindHistoryReplace);
6093  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;matchWord&quot;),				_findHistory._isMatchWord?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6094  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;matchCase&quot;),				_findHistory._isMatchCase?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6095  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;wrap&quot;),					_findHistory._isWrap?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6096  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;directionDown&quot;),			_findHistory._isDirectionDown?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6097  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifRecuisive&quot;),			_findHistory._isFifRecuisive?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6098  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifInHiddenFolder&quot;),		_findHistory._isFifInHiddenFolder?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6099  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifProjectPanel1&quot;),	    	_findHistory._isFifProjectPanel_1?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6100  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifProjectPanel2&quot;),	      	_findHistory._isFifProjectPanel_2?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6101  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifProjectPanel3&quot;),	       	_findHistory._isFifProjectPanel_3?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6102  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifFilterFollowsDoc&quot;),	_findHistory._isFilterFollowDoc?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6103  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;fifFolderFollowsDoc&quot;),	_findHistory._isFolderFollowDoc?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6104  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;searchMode&quot;), _findHistory._searchMode);
6105  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;transparencyMode&quot;), _findHistory._transparencyMode);
6106  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;transparency&quot;), _findHistory._transparency);
6107  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;dotMatchesNewline&quot;),		_findHistory._dotMatchesNewline?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6108  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;isSearch2ButtonsMode&quot;),		_findHistory._isSearch2ButtonsMode?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6109  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;regexBackward4PowerUser&quot;),		_findHistory._regexBackward4PowerUser ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6110  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;bookmarkLine&quot;), _findHistory._isBookmarkLine ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6111  	(findHistoryRoot-&gt;ToElement())-&gt;SetAttribute(TEXT(&quot;purge&quot;), _findHistory._isPurge ? TEXT(&quot;yes&quot;) : TEXT(&quot;no&quot;));
6112  	TiXmlElement hist_element{TEXT(&quot;&quot;)};
6113  	hist_element.SetValue(TEXT(&quot;Path&quot;));
6114  	for (size_t i = 0, len = _findHistory._findHistoryPaths.size(); i &lt; len; ++i)
6115  	{
6116  		(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), _findHistory._findHistoryPaths[i].c_str());
6117  		findHistoryRoot-&gt;InsertEndChild(hist_element);
6118  	}
6119  	hist_element.SetValue(TEXT(&quot;Filter&quot;));
6120  	for (size_t i = 0, len = _findHistory._findHistoryFilters.size(); i &lt; len; ++i)
6121  	{
6122  		(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), _findHistory._findHistoryFilters[i].c_str());
6123  		findHistoryRoot-&gt;InsertEndChild(hist_element);
6124  	}
6125  	hist_element.SetValue(TEXT(&quot;Find&quot;));
6126  	for (size_t i = 0, len = _findHistory._findHistoryFinds.size(); i &lt; len; ++i)
6127  	{
6128  		(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), _findHistory._findHistoryFinds[i].c_str());
6129  		findHistoryRoot-&gt;InsertEndChild(hist_element);
6130  	}
6131  	hist_element.SetValue(TEXT(&quot;Replace&quot;));
6132  	for (size_t i = 0, len = _findHistory._findHistoryReplaces.size(); i &lt; len; ++i)
6133  	{
6134  		(hist_element.ToElement())-&gt;SetAttribute(TEXT(&quot;name&quot;), _findHistory._findHistoryReplaces[i].c_str());
6135  		findHistoryRoot-&gt;InsertEndChild(hist_element);
6136  	}
6137  	return true;
6138  }
6139  void NppParameters::insertDockingParamNode(TiXmlNode *GUIRoot)
6140  {
6141  	TiXmlElement DMNode(TEXT(&quot;GUIConfig&quot;));
6142  	DMNode.SetAttribute(TEXT(&quot;name&quot;), TEXT(&quot;DockingManager&quot;));
6143  	DMNode.SetAttribute(TEXT(&quot;leftWidth&quot;), _nppGUI._dockingData._leftWidth);
6144  	DMNode.SetAttribute(TEXT(&quot;rightWidth&quot;), _nppGUI._dockingData._rightWidth);
6145  	DMNode.SetAttribute(TEXT(&quot;topHeight&quot;), _nppGUI._dockingData._topHeight);
6146  	DMNode.SetAttribute(TEXT(&quot;bottomHeight&quot;), _nppGUI._dockingData._bottomHight);
6147  	for (size_t i = 0, len = _nppGUI._dockingData._flaotingWindowInfo.size(); i &lt; len ; ++i)
6148  	{
6149  		FloatingWindowInfo &amp; fwi = _nppGUI._dockingData._flaotingWindowInfo[i];
6150  		TiXmlElement FWNode(TEXT(&quot;FloatingWindow&quot;));
6151  		FWNode.SetAttribute(TEXT(&quot;cont&quot;), fwi._cont);
6152  		FWNode.SetAttribute(TEXT(&quot;x&quot;), fwi._pos.left);
6153  		FWNode.SetAttribute(TEXT(&quot;y&quot;), fwi._pos.top);
6154  		FWNode.SetAttribute(TEXT(&quot;width&quot;), fwi._pos.right);
6155  		FWNode.SetAttribute(TEXT(&quot;height&quot;), fwi._pos.bottom);
6156  		DMNode.InsertEndChild(FWNode);
6157  	}
6158  	for (size_t i = 0, len = _nppGUI._dockingData._pluginDockInfo.size() ; i &lt; len ; ++i)
6159  	{
6160  		PluginDlgDockingInfo &amp; pdi = _nppGUI._dockingData._pluginDockInfo[i];
6161  		TiXmlElement PDNode(TEXT(&quot;PluginDlg&quot;));
6162  		PDNode.SetAttribute(TEXT(&quot;pluginName&quot;), pdi._name);
6163  		PDNode.SetAttribute(TEXT(&quot;id&quot;), pdi._internalID);
6164  		PDNode.SetAttribute(TEXT(&quot;curr&quot;), pdi._currContainer);
6165  		PDNode.SetAttribute(TEXT(&quot;prev&quot;), pdi._prevContainer);
6166  		PDNode.SetAttribute(TEXT(&quot;isVisible&quot;), pdi._isVisible?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6167  		DMNode.InsertEndChild(PDNode);
6168  	}
6169  	for (size_t i = 0, len = _nppGUI._dockingData._containerTabInfo.size(); i &lt; len ; ++i)
6170  	{
6171  		ContainerTabInfo &amp; cti = _nppGUI._dockingData._containerTabInfo[i];
6172  		TiXmlElement CTNode(TEXT(&quot;ActiveTabs&quot;));
6173  		CTNode.SetAttribute(TEXT(&quot;cont&quot;), cti._cont);
6174  		CTNode.SetAttribute(TEXT(&quot;activeTab&quot;), cti._activeTab);
6175  		DMNode.InsertEndChild(CTNode);
6176  	}
6177  	GUIRoot-&gt;InsertEndChild(DMNode);
6178  }
6179  void NppParameters::writePrintSetting(TiXmlElement *element)
6180  {
6181  	const TCHAR *pStr = _nppGUI._printSettings._printLineNumber?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;);
6182  	element-&gt;SetAttribute(TEXT(&quot;lineNumber&quot;), pStr);
6183  	element-&gt;SetAttribute(TEXT(&quot;printOption&quot;), _nppGUI._printSettings._printOption);
6184  	element-&gt;SetAttribute(TEXT(&quot;headerLeft&quot;), _nppGUI._printSettings._headerLeft.c_str());
6185  	element-&gt;SetAttribute(TEXT(&quot;headerMiddle&quot;), _nppGUI._printSettings._headerMiddle.c_str());
6186  	element-&gt;SetAttribute(TEXT(&quot;headerRight&quot;), _nppGUI._printSettings._headerRight.c_str());
6187  	element-&gt;SetAttribute(TEXT(&quot;footerLeft&quot;), _nppGUI._printSettings._footerLeft.c_str());
6188  	element-&gt;SetAttribute(TEXT(&quot;footerMiddle&quot;), _nppGUI._printSettings._footerMiddle.c_str());
6189  	element-&gt;SetAttribute(TEXT(&quot;footerRight&quot;), _nppGUI._printSettings._footerRight.c_str());
6190  	element-&gt;SetAttribute(TEXT(&quot;headerFontName&quot;), _nppGUI._printSettings._headerFontName.c_str());
6191  	element-&gt;SetAttribute(TEXT(&quot;headerFontStyle&quot;), _nppGUI._printSettings._headerFontStyle);
6192  	element-&gt;SetAttribute(TEXT(&quot;headerFontSize&quot;), _nppGUI._printSettings._headerFontSize);
6193  	element-&gt;SetAttribute(TEXT(&quot;footerFontName&quot;), _nppGUI._printSettings._footerFontName.c_str());
6194  	element-&gt;SetAttribute(TEXT(&quot;footerFontStyle&quot;), _nppGUI._printSettings._footerFontStyle);
6195  	element-&gt;SetAttribute(TEXT(&quot;footerFontSize&quot;), _nppGUI._printSettings._footerFontSize);
6196  	element-&gt;SetAttribute(TEXT(&quot;margeLeft&quot;), _nppGUI._printSettings._marge.left);
6197  	element-&gt;SetAttribute(TEXT(&quot;margeRight&quot;), _nppGUI._printSettings._marge.right);
6198  	element-&gt;SetAttribute(TEXT(&quot;margeTop&quot;), _nppGUI._printSettings._marge.top);
6199  	element-&gt;SetAttribute(TEXT(&quot;margeBottom&quot;), _nppGUI._printSettings._marge.bottom);
6200  }
6201  void NppParameters::writeExcludedLangList(TiXmlElement *element)
6202  {
6203  	int g0 = 0; 
6204  	int g1 = 0; 
6205  	int g2 = 0; 
6206  	int g3 = 0; 
6207  	int g4 = 0; 
6208  	int g5 = 0; 
6209  	int g6 = 0; 
6210  	int g7 = 0; 
6211  	int g8 = 0; 
6212  	int g9 = 0; 
6213  	int g10= 0; 
6214  	int g11= 0; 
6215  	int g12= 0; 
6216  	const int groupNbMember = 8;
6217  	for (size_t i = 0, len = _nppGUI._excludedLangList.size(); i &lt; len ; ++i)
6218  	{
6219  		LangType langType = _nppGUI._excludedLangList[i]._langType;
6220  		if (langType &gt;= L_EXTERNAL &amp;&amp; langType &lt; L_END)
6221  			continue;
6222  		int nGrp = langType / groupNbMember;
6223  		int nMask = 1 &lt;&lt; langType % groupNbMember;
6224  		switch (nGrp)
6225  		{
6226  			case 0 :
6227  				g0 |= nMask;
6228  				break;
6229  			case 1 :
6230  				g1 |= nMask;
6231  				break;
6232  			case 2 :
6233  				g2 |= nMask;
6234  				break;
6235  			case 3 :
6236  				g3 |= nMask;
6237  				break;
6238  			case 4 :
6239  				g4 |= nMask;
6240  				break;
6241  			case 5 :
6242  				g5 |= nMask;
6243  				break;
6244  			case 6 :
6245  				g6 |= nMask;
6246  				break;
6247  			case 7 :
6248  				g7 |= nMask;
6249  				break;
6250  			case 8:
6251  				g8 |= nMask;
6252  				break;
6253  			case 9:
6254  				g9 |= nMask;
6255  				break;
6256  			case 10:
6257  				g10 |= nMask;
6258  				break;
6259  			case 11:
6260  				g11 |= nMask;
6261  				break;
6262  			case 12:
6263  				g12 |= nMask;
6264  				break;
6265  		}
6266  	}
6267  	element-&gt;SetAttribute(TEXT(&quot;gr0&quot;), g0);
6268  	element-&gt;SetAttribute(TEXT(&quot;gr1&quot;), g1);
6269  	element-&gt;SetAttribute(TEXT(&quot;gr2&quot;), g2);
6270  	element-&gt;SetAttribute(TEXT(&quot;gr3&quot;), g3);
6271  	element-&gt;SetAttribute(TEXT(&quot;gr4&quot;), g4);
6272  	element-&gt;SetAttribute(TEXT(&quot;gr5&quot;), g5);
6273  	element-&gt;SetAttribute(TEXT(&quot;gr6&quot;), g6);
6274  	element-&gt;SetAttribute(TEXT(&quot;gr7&quot;), g7);
6275  	element-&gt;SetAttribute(TEXT(&quot;gr8&quot;), g8);
6276  	element-&gt;SetAttribute(TEXT(&quot;gr9&quot;), g9);
6277  	element-&gt;SetAttribute(TEXT(&quot;gr10&quot;), g10);
6278  	element-&gt;SetAttribute(TEXT(&quot;gr11&quot;), g11);
6279  	element-&gt;SetAttribute(TEXT(&quot;gr12&quot;), g12);
6280  }
6281  TiXmlElement * NppParameters::insertGUIConfigBoolNode(TiXmlNode *r2w, const TCHAR *name, bool bVal)
6282  {
6283  	const TCHAR *pStr = bVal?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;);
6284  	TiXmlElement *GUIConfigElement = (r2w-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;GUIConfig&quot;))))-&gt;ToElement();
6285  	GUIConfigElement-&gt;SetAttribute(TEXT(&quot;name&quot;), name);
6286  	GUIConfigElement-&gt;InsertEndChild(TiXmlText(pStr));
6287  	return GUIConfigElement;
6288  }
6289  int RGB2int(COLORREF color)
6290  {
6291  	return (((((DWORD)color) &amp; 0x0000FF) &lt;&lt; 16) | ((((DWORD)color) &amp; 0x00FF00)) | ((((DWORD)color) &amp; 0xFF0000) &gt;&gt; 16));
6292  }
6293  int NppParameters::langTypeToCommandID(LangType lt) const
6294  {
6295  	int id;
6296  	switch (lt)
6297  	{
6298  		case L_C :
6299  			id = IDM_LANG_C; break;
6300  		case L_CPP :
6301  			id = IDM_LANG_CPP; break;
6302  		case L_JAVA :
6303  			id = IDM_LANG_JAVA;	break;
6304  		case L_CS :
6305  			id = IDM_LANG_CS; break;
6306  		case L_OBJC :
6307  			id = IDM_LANG_OBJC;	break;
6308  		case L_HTML :
6309  			id = IDM_LANG_HTML;	break;
6310  		case L_XML :
6311  			id = IDM_LANG_XML; break;
6312  		case L_JS :
6313  		case L_JAVASCRIPT:
6314  			id = IDM_LANG_JS; break;
6315  		case L_JSON:
6316  			id = IDM_LANG_JSON; break;
6317  		case L_JSON5:
6318  			id = IDM_LANG_JSON5; break;
6319  		case L_PHP :
6320  			id = IDM_LANG_PHP; break;
6321  		case L_ASP :
6322  			id = IDM_LANG_ASP; break;
6323  		case L_JSP :
6324  			id = IDM_LANG_JSP; break;
6325  		case L_CSS :
6326  			id = IDM_LANG_CSS; break;
6327  		case L_LUA :
6328  			id = IDM_LANG_LUA; break;
6329  		case L_PERL :
6330  			id = IDM_LANG_PERL; break;
6331  		case L_PYTHON :
6332  			id = IDM_LANG_PYTHON; break;
6333  		case L_BATCH :
6334  			id = IDM_LANG_BATCH; break;
6335  		case L_PASCAL :
6336  			id = IDM_LANG_PASCAL; break;
6337  		case L_MAKEFILE :
6338  			id = IDM_LANG_MAKEFILE;	break;
6339  		case L_INI :
6340  			id = IDM_LANG_INI; break;
6341  		case L_ASCII :
6342  			id = IDM_LANG_ASCII; break;
6343  		case L_RC :
6344  			id = IDM_LANG_RC; break;
6345  		case L_TEX :
6346  			id = IDM_LANG_TEX; break;
6347  		case L_FORTRAN :
6348  			id = IDM_LANG_FORTRAN; break;
6349  		case L_FORTRAN_77 :
6350  			id = IDM_LANG_FORTRAN_77; break;
6351  		case L_BASH :
6352  			id = IDM_LANG_BASH; break;
6353  		case L_FLASH :
6354  			id = IDM_LANG_FLASH; break;
6355  		case L_NSIS :
6356  			id = IDM_LANG_NSIS; break;
6357  		case L_USER :
6358  			id = IDM_LANG_USER; break;
6359  		case L_SQL :
6360  			id = IDM_LANG_SQL; break;
6361  		case L_MSSQL :
6362  			id = IDM_LANG_MSSQL; break;
6363  		case L_VB :
6364  			id = IDM_LANG_VB; break;
6365  		case L_TCL :
6366  			id = IDM_LANG_TCL; break;
6367  		case L_LISP :
6368  			id = IDM_LANG_LISP; break;
6369  		case L_SCHEME :
6370  			id = IDM_LANG_SCHEME; break;
6371  		case L_ASM :
6372  			id = IDM_LANG_ASM; break;
6373  		case L_DIFF :
6374  			id = IDM_LANG_DIFF; break;
6375  		case L_PROPS :
6376  			id = IDM_LANG_PROPS; break;
6377  		case L_PS :
6378  			id = IDM_LANG_PS; break;
6379  		case L_RUBY :
6380  			id = IDM_LANG_RUBY; break;
6381  		case L_SMALLTALK :
6382  			id = IDM_LANG_SMALLTALK; break;
6383  		case L_VHDL :
6384  			id = IDM_LANG_VHDL; break;
6385  		case L_ADA :
6386  			id = IDM_LANG_ADA; break;
6387  		case L_MATLAB :
6388  			id = IDM_LANG_MATLAB; break;
6389  		case L_HASKELL :
6390  			id = IDM_LANG_HASKELL; break;
6391  		case L_KIX :
6392  			id = IDM_LANG_KIX; break;
6393  		case L_AU3 :
6394  			id = IDM_LANG_AU3; break;
6395  		case L_VERILOG :
6396  			id = IDM_LANG_VERILOG; break;
6397  		case L_CAML :
6398  			id = IDM_LANG_CAML; break;
6399  		case L_INNO :
6400  			id = IDM_LANG_INNO; break;
6401  		case L_CMAKE :
6402  			id = IDM_LANG_CMAKE; break;
6403  		case L_YAML :
6404  			id = IDM_LANG_YAML; break;
6405  		case L_COBOL :
6406  			id = IDM_LANG_COBOL; break;
6407  		case L_D :
6408  			id = IDM_LANG_D; break;
6409  		case L_GUI4CLI :
6410  			id = IDM_LANG_GUI4CLI; break;
6411  		case L_POWERSHELL :
6412  			id = IDM_LANG_POWERSHELL; break;
6413  		case L_R :
6414  			id = IDM_LANG_R; break;
6415  		case L_COFFEESCRIPT :
6416  			id = IDM_LANG_COFFEESCRIPT; break;
6417  		case L_BAANC:
6418  			id = IDM_LANG_BAANC; break;
6419  		case L_SREC :
6420  			id = IDM_LANG_SREC; break;
6421  		case L_IHEX :
6422  			id = IDM_LANG_IHEX; break;
6423  		case L_TEHEX :
6424  			id = IDM_LANG_TEHEX; break;
6425  		case L_SWIFT:
6426  			id = IDM_LANG_SWIFT; break;
6427  		case L_ASN1 :
6428  			id = IDM_LANG_ASN1; break;
6429          case L_AVS :
6430  			id = IDM_LANG_AVS; break;
6431  		case L_BLITZBASIC :
6432  			id = IDM_LANG_BLITZBASIC; break;
6433  		case L_PUREBASIC :
6434  			id = IDM_LANG_PUREBASIC; break;
6435  		case L_FREEBASIC :
6436  			id = IDM_LANG_FREEBASIC; break;
6437  		case L_CSOUND :
6438  			id = IDM_LANG_CSOUND; break;
6439  		case L_ERLANG :
6440  			id = IDM_LANG_ERLANG; break;
6441  		case L_ESCRIPT :
6442  			id = IDM_LANG_ESCRIPT; break;
6443  		case L_FORTH :
6444  			id = IDM_LANG_FORTH; break;
6445  		case L_LATEX :
6446  			id = IDM_LANG_LATEX; break;
6447  		case L_MMIXAL :
6448  			id = IDM_LANG_MMIXAL; break;
6449  		case L_NIM :
6450  			id = IDM_LANG_NIM; break;
6451  		case L_NNCRONTAB :
6452  			id = IDM_LANG_NNCRONTAB; break;
6453  		case L_OSCRIPT :
6454  			id = IDM_LANG_OSCRIPT; break;
6455  		case L_REBOL :
6456  			id = IDM_LANG_REBOL; break;
6457  		case L_REGISTRY :
6458  			id = IDM_LANG_REGISTRY; break;
6459  		case L_RUST :
6460  			id = IDM_LANG_RUST; break;
6461  		case L_SPICE :
6462  			id = IDM_LANG_SPICE; break;
6463  		case L_TXT2TAGS :
6464  			id = IDM_LANG_TXT2TAGS; break;
6465  		case L_VISUALPROLOG:
6466  			id = IDM_LANG_VISUALPROLOG; break;
6467  		case L_TYPESCRIPT:
6468  			id = IDM_LANG_TYPESCRIPT; break;
6469  		case L_GDSCRIPT:
6470  			id = IDM_LANG_GDSCRIPT; break;
6471  		case L_HOLLYWOOD:
6472  			id = IDM_LANG_HOLLYWOOD; break;
6473  		case L_SEARCHRESULT :
6474  			id = -1;	break;
6475  		case L_TEXT :
6476  			id = IDM_LANG_TEXT;	break;
6477  		default :
6478  			if (lt &gt;= L_EXTERNAL &amp;&amp; lt &lt; L_END)
6479  				id = lt - L_EXTERNAL + IDM_LANG_EXTERNAL;
6480  			else
6481  				id = IDM_LANG_TEXT;
6482  	}
6483  	return id;
6484  }
6485  generic_string NppParameters:: getWinVersionStr() const
6486  {
6487  	switch (_winVersion)
6488  	{
6489  		case WV_WIN32S: return TEXT(&quot;Windows 3.1&quot;);
6490  		case WV_95: return TEXT(&quot;Windows 95&quot;);
6491  		case WV_98: return TEXT(&quot;Windows 98&quot;);
6492  		case WV_ME: return TEXT(&quot;Windows Millennium Edition&quot;);
6493  		case WV_NT: return TEXT(&quot;Windows NT&quot;);
6494  		case WV_W2K: return TEXT(&quot;Windows 2000&quot;);
6495  		case WV_XP: return TEXT(&quot;Windows XP&quot;);
6496  		case WV_S2003: return TEXT(&quot;Windows Server 2003&quot;);
6497  		case WV_XPX64: return TEXT(&quot;Windows XP 64 bits&quot;);
6498  		case WV_VISTA: return TEXT(&quot;Windows Vista&quot;);
6499  		case WV_WIN7: return TEXT(&quot;Windows 7&quot;);
6500  		case WV_WIN8: return TEXT(&quot;Windows 8&quot;);
6501  		case WV_WIN81: return TEXT(&quot;Windows 8.1&quot;);
6502  		case WV_WIN10: return TEXT(&quot;Windows 10&quot;);
6503  		case WV_WIN11: return TEXT(&quot;Windows 11&quot;);
6504  		default: &amp;bsol;*case WV_UNKNOWN:*/ return TEXT(&quot;Windows unknown version&quot;);
6505  	}
6506  }
6507  generic_string NppParameters::getWinVerBitStr() const
6508  {
6509  	switch (_platForm)
6510  	{
6511  	case PF_X86:
6512  		return TEXT(&quot;32-bit&quot;);
6513  	case PF_X64:
6514  	case PF_IA64:
6515  	case PF_ARM64:
6516  		return TEXT(&quot;64-bit&quot;);
6517  	default:
6518  		return TEXT(&quot;Unknown-bit&quot;);
6519  	}
6520  }
6521  generic_string NppParameters::writeStyles(LexerStylerArray &amp; lexersStylers, StyleArray &amp; globalStylers)
6522  {
6523  	TiXmlNode *lexersRoot = (_pXmlUserStylerDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;)))-&gt;FirstChildElement(TEXT(&quot;LexerStyles&quot;));
6524  	for (TiXmlNode *childNode = lexersRoot-&gt;FirstChildElement(TEXT(&quot;LexerType&quot;));
6525  		childNode ;
6526  		childNode = childNode-&gt;NextSibling(TEXT(&quot;LexerType&quot;)))
6527  	{
6528  		TiXmlElement *element = childNode-&gt;ToElement();
6529  		const TCHAR *nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
6530  		LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6531  		LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6532  		if (pLs)
6533  		{
6534  			const TCHAR *extStr = pLs-&gt;getLexerUserExt();
6535  			element-&gt;SetAttribute(TEXT(&quot;ext&quot;), extStr);
6536  			for (TiXmlNode *grChildNode = childNode-&gt;FirstChildElement(TEXT(&quot;WordsStyle&quot;));
6537  					grChildNode ;
6538  					grChildNode = grChildNode-&gt;NextSibling(TEXT(&quot;WordsStyle&quot;)))
6539  			{
6540  				TiXmlElement *grElement = grChildNode-&gt;ToElement();
6541  				const TCHAR *styleName = grElement-&gt;Attribute(TEXT(&quot;name&quot;));
6542  				const Style * pStyle = pLs-&gt;findByName(styleName);
6543  				Style * pStyle2Sync = pLs2 ? pLs2-&gt;findByName(styleName) : nullptr;
6544  				if (pStyle &amp;&amp; pStyle2Sync)
6545  				{
6546  					writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6547  				}
6548  			}
6549  		}
6550  	}
6551  	for (size_t x = 0; x &lt; _pXmlExternalLexerDoc.size(); ++x)
6552  	{
6553  		TiXmlNode* lexersRoot2 = ( _pXmlExternalLexerDoc[x]-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;)))-&gt;FirstChildElement(TEXT(&quot;LexerStyles&quot;));
6554  		for (TiXmlNode* childNode = lexersRoot2-&gt;FirstChildElement(TEXT(&quot;LexerType&quot;));
6555  			childNode ;
6556  			childNode = childNode-&gt;NextSibling(TEXT(&quot;LexerType&quot;)))
6557  		{
6558  			TiXmlElement *element = childNode-&gt;ToElement();
6559  			const TCHAR *nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
6560  			LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6561  			LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6562  			if (pLs)
6563  			{
6564  				const TCHAR *extStr = pLs-&gt;getLexerUserExt();
6565  				element-&gt;SetAttribute(TEXT(&quot;ext&quot;), extStr);
6566  				for (TiXmlNode *grChildNode = childNode-&gt;FirstChildElement(TEXT(&quot;WordsStyle&quot;));
6567  						grChildNode ;
6568  						grChildNode = grChildNode-&gt;NextSibling(TEXT(&quot;WordsStyle&quot;)))
6569  				{
6570  					TiXmlElement *grElement = grChildNode-&gt;ToElement();
6571  					const TCHAR *styleName = grElement-&gt;Attribute(TEXT(&quot;name&quot;));
6572  					const Style * pStyle = pLs-&gt;findByName(styleName);
6573  					Style * pStyle2Sync = pLs2 ? pLs2-&gt;findByName(styleName) : nullptr;
6574  					if (pStyle &amp;&amp; pStyle2Sync)
6575  					{
6576  						writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6577  					}
6578  				}
6579  			}
6580  		}
6581  		_pXmlExternalLexerDoc[x]-&gt;SaveFile();
6582  	}
6583  	TiXmlNode *globalStylesRoot = (_pXmlUserStylerDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;)))-&gt;FirstChildElement(TEXT(&quot;GlobalStyles&quot;));
6584  	for (TiXmlNode *childNode = globalStylesRoot-&gt;FirstChildElement(TEXT(&quot;WidgetStyle&quot;));
6585  		childNode ;
6586  		childNode = childNode-&gt;NextSibling(TEXT(&quot;WidgetStyle&quot;)))
6587  	{
6588  		TiXmlElement *pElement = childNode-&gt;ToElement();
6589  		const TCHAR *styleName = pElement-&gt;Attribute(TEXT(&quot;name&quot;));
6590  		const Style * pStyle = _widgetStyleArray.findByName(styleName);
6591  		Style * pStyle2Sync = globalStylers.findByName(styleName);
6592  		if (pStyle &amp;&amp; pStyle2Sync)
6593  		{
6594  			writeStyle2Element(*pStyle, *pStyle2Sync, pElement);
6595  		}
6596  	}
6597  	bool isSaved = _pXmlUserStylerDoc-&gt;SaveFile();
6598  	if (!isSaved)
6599  	{
6600  		auto savePath = _themeSwitcher.getSavePathFrom(_pXmlUserStylerDoc-&gt;Value());
6601  		if (!savePath.empty())
6602  		{
6603  			_pXmlUserStylerDoc-&gt;SaveFile(savePath.c_str());
6604  			return savePath;
6605  		}
6606  	}
6607  	return TEXT(&quot;&quot;);
6608  }
6609  bool NppParameters::insertTabInfo(const TCHAR *langName, int tabInfo)
6610  {
6611  	if (!_pXmlDoc) return false;
6612  	TiXmlNode *langRoot = (_pXmlDoc-&gt;FirstChild(TEXT(&quot;NotepadPlus&quot;)))-&gt;FirstChildElement(TEXT(&quot;Languages&quot;));
6613  	for (TiXmlNode *childNode = langRoot-&gt;FirstChildElement(TEXT(&quot;Language&quot;));
6614  		childNode ;
6615  		childNode = childNode-&gt;NextSibling(TEXT(&quot;Language&quot;)))
6616  	{
6617  		TiXmlElement *element = childNode-&gt;ToElement();
6618  		const TCHAR *nm = element-&gt;Attribute(TEXT(&quot;name&quot;));
6619  		if (nm &amp;&amp; lstrcmp(langName, nm) == 0)
6620  		{
6621  			childNode-&gt;ToElement()-&gt;SetAttribute(TEXT(&quot;tabSettings&quot;), tabInfo);
6622  			_pXmlDoc-&gt;SaveFile();
6623  			return true;
6624  		}
6625  	}
6626  	return false;
6627  }
6628  void NppParameters::writeStyle2Element(const Style &amp; style2Write, Style &amp; style2Sync, TiXmlElement *element)
6629  {
6630  	if (HIBYTE(HIWORD(style2Write._fgColor)) != 0xFF)
6631  	{
6632  		int rgbVal = RGB2int(style2Write._fgColor);
6633  		TCHAR fgStr[7];
6634  		wsprintf(fgStr, TEXT(&quot;%.6X&quot;), rgbVal);
6635  		element-&gt;SetAttribute(TEXT(&quot;fgColor&quot;), fgStr);
6636  	}
6637  	if (HIBYTE(HIWORD(style2Write._bgColor)) != 0xFF)
6638  	{
6639  		int rgbVal = RGB2int(style2Write._bgColor);
6640  		TCHAR bgStr[7];
6641  		wsprintf(bgStr, TEXT(&quot;%.6X&quot;), rgbVal);
6642  		element-&gt;SetAttribute(TEXT(&quot;bgColor&quot;), bgStr);
6643  	}
6644  	if (style2Write._colorStyle != COLORSTYLE_ALL)
6645  	{
6646  		element-&gt;SetAttribute(TEXT(&quot;colorStyle&quot;), style2Write._colorStyle);
6647  	}
6648  	if (!style2Write._fontName.empty())
6649  	{
6650  		const TCHAR * oldFontName = element-&gt;Attribute(TEXT(&quot;fontName&quot;));
6651  		if (oldFontName &amp;&amp; oldFontName != style2Write._fontName)
6652  		{
6653  			element-&gt;SetAttribute(TEXT(&quot;fontName&quot;), style2Write._fontName);
6654  			style2Sync._fontName = style2Write._fontName;
6655  		}
6656  	}
6657  	if (style2Write._fontSize != STYLE_NOT_USED)
6658  	{
6659  		if (!style2Write._fontSize)
6660  			element-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), TEXT(&quot;&quot;));
6661  		else
6662  			element-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), style2Write._fontSize);
6663  	}
6664  	if (style2Write._fontStyle != STYLE_NOT_USED)
6665  	{
6666  		element-&gt;SetAttribute(TEXT(&quot;fontStyle&quot;), style2Write._fontStyle);
6667  	}
6668  	if (!style2Write._keywords.empty())
6669  	{
6670  		TiXmlNode *teteDeNoeud = element-&gt;LastChild();
6671  		if (teteDeNoeud)
6672  			teteDeNoeud-&gt;SetValue(style2Write._keywords.c_str());
6673  		else
6674  			element-&gt;InsertEndChild(TiXmlText(style2Write._keywords.c_str()));
6675  	}
6676  }
6677  void NppParameters::insertUserLang2Tree(TiXmlNode *node, UserLangContainer *userLang)
6678  {
6679  	TiXmlElement *rootElement = (node-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;UserLang&quot;))))-&gt;ToElement();
6680  	TCHAR temp[32];
6681  	generic_string udlVersion;
6682  	udlVersion += _itow(SCE_UDL_VERSION_MAJOR, temp, 10);
6683  	udlVersion += TEXT(&quot;.&quot;);
6684  	udlVersion += _itow(SCE_UDL_VERSION_MINOR, temp, 10);
6685  	rootElement-&gt;SetAttribute(TEXT(&quot;name&quot;), userLang-&gt;_name);
6686  	rootElement-&gt;SetAttribute(TEXT(&quot;ext&quot;), userLang-&gt;_ext);
6687  	if (userLang-&gt;_isDarkModeTheme)
6688  		rootElement-&gt;SetAttribute(TEXT(&quot;darkModeTheme&quot;), TEXT(&quot;yes&quot;));
6689  	rootElement-&gt;SetAttribute(TEXT(&quot;udlVersion&quot;), udlVersion.c_str());
6690  	TiXmlElement *settingsElement = (rootElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Settings&quot;))))-&gt;ToElement();
6691  	{
6692  		TiXmlElement *globalElement = (settingsElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Global&quot;))))-&gt;ToElement();
6693  		globalElement-&gt;SetAttribute(TEXT(&quot;caseIgnored&quot;),			userLang-&gt;_isCaseIgnored ? TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6694  		globalElement-&gt;SetAttribute(TEXT(&quot;allowFoldOfComments&quot;),	userLang-&gt;_allowFoldOfComments ? TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6695  		globalElement-&gt;SetAttribute(TEXT(&quot;foldCompact&quot;),			userLang-&gt;_foldCompact ? TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6696  		globalElement-&gt;SetAttribute(TEXT(&quot;forcePureLC&quot;),			userLang-&gt;_forcePureLC);
6697  		globalElement-&gt;SetAttribute(TEXT(&quot;decimalSeparator&quot;),	   userLang-&gt;_decimalSeparator);
6698  		TiXmlElement *prefixElement = (settingsElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Prefix&quot;))))-&gt;ToElement();
6699  		for (int i = 0 ; i &lt; SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
6700  			prefixElement-&gt;SetAttribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1], userLang-&gt;_isPrefix[i]?TEXT(&quot;yes&quot;):TEXT(&quot;no&quot;));
6701  	}
6702  	TiXmlElement *kwlElement = (rootElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;KeywordLists&quot;))))-&gt;ToElement();
6703  	for (int i = 0 ; i &lt; SCE_USER_KWLIST_TOTAL ; ++i)
6704  	{
6705  		TiXmlElement *kwElement = (kwlElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Keywords&quot;))))-&gt;ToElement();
6706  		kwElement-&gt;SetAttribute(TEXT(&quot;name&quot;), globalMappper().keywordNameMapper[i]);
6707  		kwElement-&gt;InsertEndChild(TiXmlText(userLang-&gt;_keywordLists[i]));
6708  	}
6709  	TiXmlElement *styleRootElement = (rootElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;Styles&quot;))))-&gt;ToElement();
6710  	for (const Style &amp; style2Write : userLang-&gt;_styles)
6711  	{
6712  		TiXmlElement *styleElement = (styleRootElement-&gt;InsertEndChild(TiXmlElement(TEXT(&quot;WordsStyle&quot;))))-&gt;ToElement();
6713  		if (style2Write._styleID == -1)
6714  			continue;
6715  		styleElement-&gt;SetAttribute(TEXT(&quot;name&quot;), style2Write._styleDesc);
6716  		{
6717  			int rgbVal = RGB2int(style2Write._fgColor);
6718  			TCHAR fgStr[7];
6719  			wsprintf(fgStr, TEXT(&quot;%.6X&quot;), rgbVal);
6720  			styleElement-&gt;SetAttribute(TEXT(&quot;fgColor&quot;), fgStr);
6721  		}
6722  		{
6723  			int rgbVal = RGB2int(style2Write._bgColor);
6724  			TCHAR bgStr[7];
6725  			wsprintf(bgStr, TEXT(&quot;%.6X&quot;), rgbVal);
6726  			styleElement-&gt;SetAttribute(TEXT(&quot;bgColor&quot;), bgStr);
6727  		}
6728  		if (style2Write._colorStyle != COLORSTYLE_ALL)
6729  		{
6730  			styleElement-&gt;SetAttribute(TEXT(&quot;colorStyle&quot;), style2Write._colorStyle);
6731  		}
6732  		if (!style2Write._fontName.empty())
6733  		{
6734  			styleElement-&gt;SetAttribute(TEXT(&quot;fontName&quot;), style2Write._fontName);
6735  		}
6736  		if (style2Write._fontStyle == STYLE_NOT_USED)
6737  		{
6738  			styleElement-&gt;SetAttribute(TEXT(&quot;fontStyle&quot;), TEXT(&quot;0&quot;));
6739  		}
6740  		else
6741  		{
6742  			styleElement-&gt;SetAttribute(TEXT(&quot;fontStyle&quot;), style2Write._fontStyle);
6743  		}
6744  		if (style2Write._fontSize != STYLE_NOT_USED)
6745  		{
6746  			if (!style2Write._fontSize)
6747  				styleElement-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), TEXT(&quot;&quot;));
6748  			else
6749  				styleElement-&gt;SetAttribute(TEXT(&quot;fontSize&quot;), style2Write._fontSize);
6750  		}
6751  		styleElement-&gt;SetAttribute(TEXT(&quot;nesting&quot;), style2Write._nesting);
6752  	}
6753  }
6754  void NppParameters::addUserModifiedIndex(size_t index)
6755  {
6756  	size_t len = _customizedShortcuts.size();
6757  	bool found = false;
6758  	for (size_t i = 0; i &lt; len; ++i)
6759  	{
6760  		if (_customizedShortcuts[i] == index)
6761  		{
6762  			found = true;
6763  			break;
6764  		}
6765  	}
6766  	if (!found)
6767  	{
6768  		_customizedShortcuts.push_back(index);
6769  	}
6770  }
6771  void NppParameters::addPluginModifiedIndex(size_t index)
6772  {
6773  	size_t len = _pluginCustomizedCmds.size();
6774  	bool found = false;
6775  	for (size_t i = 0; i &lt; len; ++i)
6776  	{
6777  		if (_pluginCustomizedCmds[i] == index)
6778  		{
6779  			found = true;
6780  			break;
6781  		}
6782  	}
6783  	if (!found)
6784  	{
6785  		_pluginCustomizedCmds.push_back(index);
6786  	}
6787  }
6788  void NppParameters::addScintillaModifiedIndex(int index)
6789  {
6790  	size_t len = _scintillaModifiedKeyIndices.size();
6791  	bool found = false;
6792  	for (size_t i = 0; i &lt; len; ++i)
6793  	{
6794  		if (_scintillaModifiedKeyIndices[i] == index)
6795  		{
6796  			found = true;
6797  			break;
6798  		}
6799  	}
6800  	if (!found)
6801  	{
6802  		_scintillaModifiedKeyIndices.push_back(index);
6803  	}
6804  }
6805  void NppParameters::safeWow64EnableWow64FsRedirection(BOOL Wow64FsEnableRedirection)
6806  {
6807  	HMODULE kernel = GetModuleHandle(TEXT(&quot;kernel32&quot;));
6808  	if (kernel)
6809  	{
6810  		BOOL isWow64 = FALSE;
6811  		typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
6812  		LPFN_ISWOW64PROCESS IsWow64ProcessFunc = (LPFN_ISWOW64PROCESS) GetProcAddress(kernel,&quot;IsWow64Process&quot;);
6813  		if (IsWow64ProcessFunc)
6814  		{
6815  			IsWow64ProcessFunc(GetCurrentProcess(),&amp;isWow64);
6816  			if (isWow64)
6817  			{
6818  				typedef BOOL (WINAPI *LPFN_WOW64ENABLEWOW64FSREDIRECTION)(BOOL);
6819  				LPFN_WOW64ENABLEWOW64FSREDIRECTION Wow64EnableWow64FsRedirectionFunc = (LPFN_WOW64ENABLEWOW64FSREDIRECTION)GetProcAddress(kernel, &quot;Wow64EnableWow64FsRedirection&quot;);
6820  				if (Wow64EnableWow64FsRedirectionFunc)
6821  				{
6822  					Wow64EnableWow64FsRedirectionFunc(Wow64FsEnableRedirection);
6823  				}
6824  			}
6825  		}
6826  	}
6827  }
6828  void NppParameters::setUdlXmlDirtyFromIndex(size_t i)
6829  {
6830  	for (auto&amp; uxfs : _pXmlUserLangsDoc)
6831  	{
6832  		if (i &gt;= uxfs._indexRange.first &amp;&amp; i &lt; uxfs._indexRange.second)
6833  		{
6834  			uxfs._isDirty = true;
6835  			return;
6836  		}
6837  	}
6838  }
6839  void NppParameters::removeIndexFromXmlUdls(size_t i)
6840  {
6841  	bool isUpdateBegin = false;
6842  	for (auto&amp; uxfs : _pXmlUserLangsDoc)
6843  	{
6844  		if (!isUpdateBegin &amp;&amp; (i &gt;= uxfs._indexRange.first &amp;&amp; i &lt; uxfs._indexRange.second)) 
6845  		{
6846  			if (uxfs._indexRange.second &gt; 0)
6847  				uxfs._indexRange.second -= 1;
6848  			uxfs._isDirty = true;
6849  			isUpdateBegin = true;
6850  		}
6851  		else if (isUpdateBegin)
6852  		{
6853  			if (uxfs._indexRange.first &gt; 0)
6854  				uxfs._indexRange.first -= 1;
6855  			if (uxfs._indexRange.second &gt; 0)
6856  				uxfs._indexRange.second -= 1;
6857  		}
6858  	}
6859  }
6860  void NppParameters::setUdlXmlDirtyFromXmlDoc(const TiXmlDocument* xmlDoc)
6861  {
6862  	for (auto&amp; uxfs : _pXmlUserLangsDoc)
6863  	{
6864  		if (xmlDoc == uxfs._udlXmlDoc)
6865  		{
6866  			uxfs._isDirty = true;
6867  			return;
6868  		}
6869  	}
6870  }
6871  Date::Date(const TCHAR *dateStr)
6872  {
6873  	assert(dateStr);
6874  	int D = lstrlen(dateStr);
6875  	if ( 8==D )
6876  	{
6877  		generic_string ds(dateStr);
6878  		generic_string yyyy(ds, 0, 4);
6879  		generic_string mm(ds, 4, 2);
6880  		generic_string dd(ds, 6, 2);
6881  		int y = _wtoi(yyyy.c_str());
6882  		int m = _wtoi(mm.c_str());
6883  		int d = _wtoi(dd.c_str());
6884  		if ((y &gt; 0 &amp;&amp; y &lt;= 9999) &amp;&amp; (m &gt; 0 &amp;&amp; m &lt;= 12) &amp;&amp; (d &gt; 0 &amp;&amp; d &lt;= 31))
6885  		{
6886  			_year = y;
6887  			_month = m;
6888  			_day = d;
6889  			return;
6890  		}
6891  	}
6892  	now();
6893  }
6894  Date::Date(int nbDaysFromNow)
6895  {
6896  	const time_t oneDay = (60 * 60 * 24);
6897  	time_t rawtime;
6898  	tm* timeinfo;
6899  	time(&amp;rawtime);
6900  	rawtime += (nbDaysFromNow * oneDay);
6901  	timeinfo = localtime(&amp;rawtime);
6902  	if (timeinfo)
6903  	{
6904  		_year = timeinfo-&gt;tm_year + 1900;
6905  		_month = timeinfo-&gt;tm_mon + 1;
6906  		_day = timeinfo-&gt;tm_mday;
6907  	}
6908  }
6909  void Date::now()
6910  {
6911  	time_t rawtime;
6912  	tm* timeinfo;
6913  	time(&amp;rawtime);
6914  	timeinfo = localtime(&amp;rawtime);
6915  	if (timeinfo)
6916  	{
6917  		_year = timeinfo-&gt;tm_year + 1900;
6918  		_month = timeinfo-&gt;tm_mon + 1;
6919  		_day = timeinfo-&gt;tm_mday;
6920  	}
6921  }
6922  EolType convertIntToFormatType(int value, EolType defvalue)
6923  {
6924  	switch (value)
6925  	{
6926  		case static_cast&lt;LPARAM&gt;(EolType::windows) :
6927  			return EolType::windows;
6928  		case static_cast&lt;LPARAM&gt;(EolType::macos) :
6929  				return EolType::macos;
6930  		case static_cast&lt;LPARAM&gt;(EolType::unix) :
6931  			return EolType::unix;
6932  		default:
6933  			return defvalue;
6934  	}
6935  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</div>
                </div>
                <div class="column column_space"><pre><code>3707  				_langList[_nbLang]-&gt;setCommentEnd(element-&gt;Attribute(TEXT(&quot;commentEnd&quot;)));
3708  				int tabSettings;
</pre></code></div>
                <div class="column column_space"><pre><code>3704  				_langList[_nbLang]-&gt;setDefaultExtList(element-&gt;Attribute(TEXT(&quot;ext&quot;)));
3705  				_langList[_nbLang]-&gt;setCommentLineSymbol(element-&gt;Attribute(TEXT(&quot;commentLine&quot;)));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    