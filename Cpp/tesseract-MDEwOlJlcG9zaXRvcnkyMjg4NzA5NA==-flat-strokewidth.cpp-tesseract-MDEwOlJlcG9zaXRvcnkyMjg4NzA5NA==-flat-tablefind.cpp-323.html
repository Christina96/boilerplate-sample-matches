
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-strokewidth.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #include &quot;strokewidth.h&quot;
5  #include &lt;algorithm&gt;
6  #include &lt;cmath&gt;
7  #include &quot;blobbox.h&quot;
8  #include &quot;colpartition.h&quot;
9  #include &quot;colpartitiongrid.h&quot;
10  #include &quot;helpers.h&quot; 
11  #include &quot;imagefind.h&quot;
12  #include &quot;linlsq.h&quot;
13  #include &quot;statistc.h&quot;
14  #include &quot;tabfind.h&quot;
15  #include &quot;textlineprojection.h&quot;
16  #include &quot;tordmain.h&quot; 
17  namespace tesseract {
18  #ifndef GRAPHICS_DISABLED
19  static INT_VAR(textord_tabfind_show_strokewidths, 0, &quot;Show stroke widths (ScrollView)&quot;);
20  #else
21  static INT_VAR(textord_tabfind_show_strokewidths, 0, &quot;Show stroke widths&quot;);
22  #endif
23  static BOOL_VAR(textord_tabfind_only_strokewidths, false, &quot;Only run stroke widths&quot;);
24  const double kStrokeWidthFractionTolerance = 0.125;
25  const double kStrokeWidthTolerance = 1.5;
26  const double kStrokeWidthFractionCJK = 0.25;
27  const double kStrokeWidthCJK = 2.0;
28  const int kCJKRadius = 2;
29  const double kCJKBrokenDistanceFraction = 0.25;
30  const int kCJKMaxComponents = 8;
31  const double kCJKAspectRatio = 1.25;
32  const double kCJKAspectRatioIncrease = 1.0625;
33  const int kMaxCJKSizeRatio = 5;
34  const double kBrokenCJKIterationFraction = 0.125;
35  const double kDiacriticXPadRatio = 7.0;
36  const double kDiacriticYPadRatio = 1.75;
37  const double kMinDiacriticSizeRatio = 1.0625;
38  const double kMaxDiacriticDistanceRatio = 1.25;
39  const double kMaxDiacriticGapToBaseCharHeight = 1.0;
40  const int kLineTrapLongest = 4;
41  const int kLineTrapShortest = 2;
42  const int kMostlyOneDirRatio = 3;
43  const double kLineResidueAspectRatio = 8.0;
44  const int kLineResiduePadRatio = 3;
45  const double kLineResidueSizeRatio = 1.75;
46  const float kSizeRatioToReject = 2.0;
47  const double kNeighbourSearchFactor = 2.5;
48  const double kNoiseOverlapGrowthFactor = 4.0;
49  const double kNoiseOverlapAreaFactor = 1.0 / 512;
50  StrokeWidth::StrokeWidth(int gridsize, const ICOORD &amp;bleft, const ICOORD &amp;tright)
51      : BlobGrid(gridsize, bleft, tright)
52      , nontext_map_(nullptr)
53      , projection_(nullptr)
54      , denorm_(nullptr)
55      , grid_box_(bleft, tright)
56      , rerotation_(1.0f, 0.0f) {
57  }
58  StrokeWidth::~StrokeWidth() {
59  #ifndef GRAPHICS_DISABLED
60    if (widths_win_ != nullptr) {
61      widths_win_-&gt;AwaitEvent(SVET_DESTROY);
62      if (textord_tabfind_only_strokewidths) {
63        exit(0);
64      }
65      delete widths_win_;
66    }
67    delete leaders_win_;
68    delete initial_widths_win_;
69    delete chains_win_;
70    delete textlines_win_;
71    delete smoothed_win_;
72    delete diacritics_win_;
73  #endif
74  }
75  void StrokeWidth::SetNeighboursOnMediumBlobs(TO_BLOCK *block) {
76    InsertBlobList(&amp;block-&gt;blobs);
77    BLOBNBOX_IT blob_it(&amp;block-&gt;blobs);
78    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
79      SetNeighbours(false, false, blob_it.data());
80    }
81    Clear();
82  }
83  void StrokeWidth::FindTextlineDirectionAndFixBrokenCJK(PageSegMode pageseg_mode, bool cjk_merge,
84                                                         TO_BLOCK *input_block) {
85    InsertBlobs(input_block);
86    while (cjk_merge &amp;&amp; FixBrokenCJK(input_block)) {
87    }
88    FindTextlineFlowDirection(pageseg_mode, false);
89    Clear();
90  }
91  static void CollectHorizVertBlobs(BLOBNBOX_LIST *input_blobs, int *num_vertical_blobs,
92                                    int *num_horizontal_blobs, BLOBNBOX_CLIST *vertical_blobs,
93                                    BLOBNBOX_CLIST *horizontal_blobs,
94                                    BLOBNBOX_CLIST *nondescript_blobs) {
95    BLOBNBOX_C_IT v_it(vertical_blobs);
96    BLOBNBOX_C_IT h_it(horizontal_blobs);
97    BLOBNBOX_C_IT n_it(nondescript_blobs);
98    BLOBNBOX_IT blob_it(input_blobs);
99    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
100      BLOBNBOX *blob = blob_it.data();
101      const TBOX &amp;box = blob-&gt;bounding_box();
102      float y_x = static_cast&lt;float&gt;(box.height()) / box.width();
103      float x_y = 1.0f / y_x;
104      float ratio = x_y &gt; y_x ? x_y : y_x;
105      bool ok_blob = ratio &lt;= kSizeRatioToReject;
106      if (blob-&gt;UniquelyVertical()) {
107        ++*num_vertical_blobs;
108        if (ok_blob) {
109          v_it.add_after_then_move(blob);
110        }
111      } else if (blob-&gt;UniquelyHorizontal()) {
112        ++*num_horizontal_blobs;
113        if (ok_blob) {
114          h_it.add_after_then_move(blob);
115        }
116      } else if (ok_blob) {
117        n_it.add_after_then_move(blob);
118      }
119    }
120  }
121  bool StrokeWidth::TestVerticalTextDirection(double find_vertical_text_ratio, TO_BLOCK *block,
122                                              BLOBNBOX_CLIST *osd_blobs) {
123    int vertical_boxes = 0;
124    int horizontal_boxes = 0;
125    BLOBNBOX_CLIST vertical_blobs;
126    BLOBNBOX_CLIST horizontal_blobs;
127    BLOBNBOX_CLIST nondescript_blobs;
128    CollectHorizVertBlobs(&amp;block-&gt;blobs, &amp;vertical_boxes, &amp;horizontal_boxes, &amp;vertical_blobs,
129                          &amp;horizontal_blobs, &amp;nondescript_blobs);
130    CollectHorizVertBlobs(&amp;block-&gt;large_blobs, &amp;vertical_boxes, &amp;horizontal_boxes, &amp;vertical_blobs,
131                          &amp;horizontal_blobs, &amp;nondescript_blobs);
132    if (textord_debug_tabfind) {
133      tprintf(&quot;TextDir hbox=%d vs vbox=%d, %dH, %dV, %dN osd blobs\n&quot;, horizontal_boxes,
134              vertical_boxes, horizontal_blobs.length(), vertical_blobs.length(),
135              nondescript_blobs.length());
136    }
137    if (osd_blobs != nullptr &amp;&amp; vertical_boxes == 0 &amp;&amp; horizontal_boxes == 0) {
138      BLOBNBOX_C_IT osd_it(osd_blobs);
139      osd_it.add_list_after(&amp;nondescript_blobs);
140      return false;
141    }
142    int min_vert_boxes =
143        static_cast&lt;int&gt;((vertical_boxes + horizontal_boxes) * find_vertical_text_ratio);
144    if (vertical_boxes &gt;= min_vert_boxes) {
145      if (osd_blobs != nullptr) {
146        BLOBNBOX_C_IT osd_it(osd_blobs);
147        osd_it.add_list_after(&amp;vertical_blobs);
148      }
149      return true;
150    } else {
151      if (osd_blobs != nullptr) {
152        BLOBNBOX_C_IT osd_it(osd_blobs);
153        osd_it.add_list_after(&amp;horizontal_blobs);
154      }
155      return false;
156    }
157  }
158  void StrokeWidth::CorrectForRotation(const FCOORD &amp;rotation, ColPartitionGrid *part_grid) {
159    Init(part_grid-&gt;gridsize(), part_grid-&gt;bleft(), part_grid-&gt;tright());
160    grid_box_ = TBOX(bleft(), tright());
161    rerotation_.set_x(rotation.x());
162    rerotation_.set_y(-rotation.y());
163  }
164  void StrokeWidth::FindLeaderPartitions(TO_BLOCK *block, ColPartitionGrid *part_grid) {
<span onclick='openModal()' class='match'>165    Clear();
166    ColPartition_LIST leader_parts;
167    FindLeadersAndMarkNoise(block, &amp;leader_parts);
168    InsertBlobList(&amp;block-&gt;blobs);
</span>169    for (ColPartition_IT it(&amp;leader_parts); !it.empty(); it.forward()) {
170      ColPartition *part = it.extract();
171      part-&gt;ClaimBoxes();
172      MarkLeaderNeighbours(part, LR_LEFT);
173      MarkLeaderNeighbours(part, LR_RIGHT);
174      part_grid-&gt;InsertBBox(true, true, part);
175    }
176  }
177  void StrokeWidth::RemoveLineResidue(ColPartition_LIST *big_part_list) {
178    BlobGridSearch gsearch(this);
179    BLOBNBOX *bbox;
180    gsearch.StartFullSearch();
181    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
182      TBOX box = bbox-&gt;bounding_box();
183      if (box.height() &lt; box.width() * kLineResidueAspectRatio) {
184        continue;
185      }
186      int padding = box.height() * kLineResiduePadRatio;
187      TBOX search_box = box;
188      search_box.pad(padding, padding);
189      bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
190      BlobGridSearch rsearch(this);
191      int max_height = 0;
192      BLOBNBOX *n;
193      rsearch.StartRectSearch(search_box);
194      while ((n = rsearch.NextRectSearch()) != nullptr) {
195        if (n == bbox) {
196          continue;
197        }
198        TBOX nbox = n-&gt;bounding_box();
199        if (nbox.height() &gt; max_height) {
200          max_height = nbox.height();
201        }
202      }
203      if (debug) {
204        tprintf(&quot;Max neighbour size=%d for candidate line box at:&quot;, max_height);
205        box.print();
206      }
207      if (max_height * kLineResidueSizeRatio &lt; box.height()) {
208  #ifndef GRAPHICS_DISABLED
209        if (leaders_win_ != nullptr) {
210          leaders_win_-&gt;Pen(ScrollView::PINK);
211          leaders_win_-&gt;Rectangle(box.left(), box.bottom(), box.right(), box.top());
212        }
213  #endif 
214        ColPartition::MakeBigPartition(bbox, big_part_list);
215      }
216    }
217  }
218  void StrokeWidth::GradeBlobsIntoPartitions(PageSegMode pageseg_mode, const FCOORD &amp;rerotation,
219                                             TO_BLOCK *block, Image nontext_pix, const DENORM *denorm,
220                                             bool cjk_script, TextlineProjection *projection,
221                                             BLOBNBOX_LIST *diacritic_blobs,
222                                             ColPartitionGrid *part_grid,
223                                             ColPartition_LIST *big_parts) {
224    nontext_map_ = nontext_pix;
225    projection_ = projection;
226    denorm_ = denorm;
227    Clear();
228    InsertBlobs(block);
229    if (cjk_script) {
230      FixBrokenCJK(block);
231    }
232    FindTextlineFlowDirection(pageseg_mode, false);
233    projection_-&gt;ConstructProjection(block, rerotation, nontext_map_);
234  #ifndef GRAPHICS_DISABLED
235    if (textord_tabfind_show_strokewidths) {
236      ScrollView *line_blobs_win = MakeWindow(0, 0, &quot;Initial textline Blobs&quot;);
237      projection_-&gt;PlotGradedBlobs(&amp;block-&gt;blobs, line_blobs_win);
238      projection_-&gt;PlotGradedBlobs(&amp;block-&gt;small_blobs, line_blobs_win);
239    }
240  #endif
241    projection_-&gt;MoveNonTextlineBlobs(&amp;block-&gt;blobs, &amp;block-&gt;noise_blobs);
242    projection_-&gt;MoveNonTextlineBlobs(&amp;block-&gt;small_blobs, &amp;block-&gt;noise_blobs);
243    Clear();
244    InsertBlobs(block);
245    FCOORD skew;
246    FindTextlineFlowDirection(pageseg_mode, true);
247    PartitionFindResult r = FindInitialPartitions(pageseg_mode, rerotation, true, block,
248                                                  diacritic_blobs, part_grid, big_parts, &amp;skew);
249    if (r == PFR_NOISE) {
250      tprintf(&quot;Detected %d diacritics\n&quot;, diacritic_blobs-&gt;length());
251      Clear();
252      InsertBlobs(block);
253      FindTextlineFlowDirection(pageseg_mode, true);
254      r = FindInitialPartitions(pageseg_mode, rerotation, false, block, diacritic_blobs, part_grid,
255                                big_parts, &amp;skew);
256    }
257    nontext_map_ = nullptr;
258    projection_ = nullptr;
259    denorm_ = nullptr;
260  }
261  static void PrintBoxWidths(BLOBNBOX *neighbour) {
262    const TBOX &amp;nbox = neighbour-&gt;bounding_box();
263    tprintf(&quot;Box (%d,%d)-&gt;(%d,%d): h-width=%.1f, v-width=%.1f p-width=%1.f\n&quot;, nbox.left(),
264            nbox.bottom(), nbox.right(), nbox.top(), neighbour-&gt;horz_stroke_width(),
265            neighbour-&gt;vert_stroke_width(),
266            2.0 * neighbour-&gt;cblob()-&gt;area() / neighbour-&gt;cblob()-&gt;perimeter());
267  }
268  void StrokeWidth::HandleClick(int x, int y) {
269    BBGrid&lt;BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT&gt;::HandleClick(x, y);
270    BlobGridSearch radsearch(this);
271    radsearch.StartRadSearch(x, y, 1);
272    BLOBNBOX *neighbour;
273    FCOORD click(static_cast&lt;float&gt;(x), static_cast&lt;float&gt;(y));
274    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
275      TBOX nbox = neighbour-&gt;bounding_box();
276      if (nbox.contains(click) &amp;&amp; neighbour-&gt;cblob() != nullptr) {
277        PrintBoxWidths(neighbour);
278        if (neighbour-&gt;neighbour(BND_LEFT) != nullptr) {
279          PrintBoxWidths(neighbour-&gt;neighbour(BND_LEFT));
280        }
281        if (neighbour-&gt;neighbour(BND_RIGHT) != nullptr) {
282          PrintBoxWidths(neighbour-&gt;neighbour(BND_RIGHT));
283        }
284        if (neighbour-&gt;neighbour(BND_ABOVE) != nullptr) {
285          PrintBoxWidths(neighbour-&gt;neighbour(BND_ABOVE));
286        }
287        if (neighbour-&gt;neighbour(BND_BELOW) != nullptr) {
288          PrintBoxWidths(neighbour-&gt;neighbour(BND_BELOW));
289        }
290        int gaps[BND_COUNT];
291        neighbour-&gt;NeighbourGaps(gaps);
292        tprintf(
293            &quot;Left gap=%d, right=%d, above=%d, below=%d, horz=%d, vert=%d\n&quot;
294            &quot;Good=    %d        %d        %d        %d\n&quot;,
295            gaps[BND_LEFT], gaps[BND_RIGHT], gaps[BND_ABOVE], gaps[BND_BELOW],
296            neighbour-&gt;horz_possible(), neighbour-&gt;vert_possible(),
297            neighbour-&gt;good_stroke_neighbour(BND_LEFT), neighbour-&gt;good_stroke_neighbour(BND_RIGHT),
298            neighbour-&gt;good_stroke_neighbour(BND_ABOVE), neighbour-&gt;good_stroke_neighbour(BND_BELOW));
299        break;
300      }
301    }
302  }
303  void StrokeWidth::FindLeadersAndMarkNoise(TO_BLOCK *block, ColPartition_LIST *leader_parts) {
304    InsertBlobList(&amp;block-&gt;small_blobs);
305    InsertBlobList(&amp;block-&gt;noise_blobs);
306    BlobGridSearch gsearch(this);
307    BLOBNBOX *bbox;
308    gsearch.StartFullSearch();
309    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
310      SetNeighbours(true, false, bbox);
311    }
312    ColPartition_IT part_it(leader_parts);
313    gsearch.StartFullSearch();
314    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
315      if (bbox-&gt;flow() == BTFT_NONE) {
316        if (bbox-&gt;neighbour(BND_RIGHT) == nullptr &amp;&amp; bbox-&gt;neighbour(BND_LEFT) == nullptr) {
317          continue;
318        }
319        auto *part = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
320        BLOBNBOX *blob;
321        for (blob = bbox; blob != nullptr &amp;&amp; blob-&gt;flow() == BTFT_NONE;
322             blob = blob-&gt;neighbour(BND_RIGHT)) {
323          part-&gt;AddBox(blob);
324        }
325        for (blob = bbox-&gt;neighbour(BND_LEFT); blob != nullptr &amp;&amp; blob-&gt;flow() == BTFT_NONE;
326             blob = blob-&gt;neighbour(BND_LEFT)) {
327          part-&gt;AddBox(blob);
328        }
329        if (part-&gt;MarkAsLeaderIfMonospaced()) {
330          part_it.add_after_then_move(part);
331        } else {
332          delete part;
333        }
334      }
335    }
336  #ifndef GRAPHICS_DISABLED
337    if (textord_tabfind_show_strokewidths) {
338      leaders_win_ = DisplayGoodBlobs(&quot;LeaderNeighbours&quot;, 0, 0);
339    }
340  #endif
341    BLOBNBOX_IT blob_it(&amp;block-&gt;blobs);
342    BLOBNBOX_IT small_it(&amp;block-&gt;small_blobs);
343    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
344      BLOBNBOX *blob = small_it.data();
345      if (blob-&gt;flow() != BTFT_LEADER) {
346        if (blob-&gt;flow() == BTFT_NEIGHBOURS) {
347          blob-&gt;set_flow(BTFT_NONE);
348        }
349        blob-&gt;ClearNeighbours();
350        blob_it.add_to_end(small_it.extract());
351      }
352    }
353    BLOBNBOX_IT noise_it(&amp;block-&gt;noise_blobs);
354    for (noise_it.mark_cycle_pt(); !noise_it.cycled_list(); noise_it.forward()) {
355      BLOBNBOX *blob = noise_it.data();
356      if (blob-&gt;flow() == BTFT_LEADER || blob-&gt;joined_to_prev()) {
357        small_it.add_to_end(noise_it.extract());
358      } else if (blob-&gt;flow() == BTFT_NEIGHBOURS) {
359        blob-&gt;set_flow(BTFT_NONE);
360        blob-&gt;ClearNeighbours();
361      }
362    }
363    Clear();
364  }
365  void StrokeWidth::InsertBlobs(TO_BLOCK *block) {
366    InsertBlobList(&amp;block-&gt;blobs);
367    InsertBlobList(&amp;block-&gt;large_blobs);
368  }
369  void StrokeWidth::MarkLeaderNeighbours(const ColPartition *part, LeftOrRight side) {
370    const TBOX &amp;part_box = part-&gt;bounding_box();
371    BlobGridSearch blobsearch(this);
372    BLOBNBOX *best_blob = nullptr;
373    int best_gap = 0;
374    blobsearch.StartSideSearch(side == LR_LEFT ? part_box.left() : part_box.right(),
375                               part_box.bottom(), part_box.top());
376    BLOBNBOX *blob;
377    while ((blob = blobsearch.NextSideSearch(side == LR_LEFT)) != nullptr) {
378      const TBOX &amp;blob_box = blob-&gt;bounding_box();
379      if (!blob_box.y_overlap(part_box)) {
380        continue;
381      }
382      int x_gap = blob_box.x_gap(part_box);
383      if (x_gap &gt; 2 * gridsize()) {
384        break;
385      } else if (best_blob == nullptr || x_gap &lt; best_gap) {
386        best_blob = blob;
387        best_gap = x_gap;
388      }
389    }
390    if (best_blob != nullptr) {
391      if (side == LR_LEFT) {
392        best_blob-&gt;set_leader_on_right(true);
393      } else {
394        best_blob-&gt;set_leader_on_left(true);
395      }
396  #ifndef GRAPHICS_DISABLED
397      if (leaders_win_ != nullptr) {
398        leaders_win_-&gt;Pen(side == LR_LEFT ? ScrollView::RED : ScrollView::GREEN);
399        const TBOX &amp;blob_box = best_blob-&gt;bounding_box();
400        leaders_win_-&gt;Rectangle(blob_box.left(), blob_box.bottom(), blob_box.right(), blob_box.top());
401      }
402  #endif 
403    }
404  }
405  static int UpperQuartileCJKSize(int gridsize, BLOBNBOX_LIST *blobs) {
406    STATS sizes(0, gridsize * kMaxCJKSizeRatio - 1);
407    BLOBNBOX_IT it(blobs);
408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
409      BLOBNBOX *blob = it.data();
410      int width = blob-&gt;bounding_box().width();
411      int height = blob-&gt;bounding_box().height();
412      if (width &lt;= height * kCJKAspectRatio &amp;&amp; height &lt; width * kCJKAspectRatio) {
413        sizes.add(height, 1);
414      }
415    }
416    return static_cast&lt;int&gt;(sizes.ile(0.75f) + 0.5);
417  }
418  bool StrokeWidth::FixBrokenCJK(TO_BLOCK *block) {
419    BLOBNBOX_LIST *blobs = &amp;block-&gt;blobs;
420    int median_height = UpperQuartileCJKSize(gridsize(), blobs);
421    int max_dist = static_cast&lt;int&gt;(median_height * kCJKBrokenDistanceFraction);
422    int max_height = static_cast&lt;int&gt;(median_height * kCJKAspectRatio);
423    int num_fixed = 0;
424    BLOBNBOX_IT blob_it(blobs);
425    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
426      BLOBNBOX *blob = blob_it.data();
427      if (blob-&gt;cblob() == nullptr || blob-&gt;cblob()-&gt;out_list()-&gt;empty()) {
428        continue;
429      }
430      TBOX bbox = blob-&gt;bounding_box();
431      bool debug = AlignedBlob::WithinTestRegion(3, bbox.left(), bbox.bottom());
432      if (debug) {
433        tprintf(&quot;Checking for Broken CJK (max size=%d):&quot;, max_height);
434        bbox.print();
435      }
436      BLOBNBOX_CLIST overlapped_blobs;
437      AccumulateOverlaps(blob, debug, max_height, max_dist, &amp;bbox, &amp;overlapped_blobs);
438      if (!overlapped_blobs.empty()) {
439        if (bbox.width() &gt; bbox.height() * kCJKAspectRatio ||
440            bbox.height() &gt; bbox.width() * kCJKAspectRatio) {
441          if (debug) {
442            tprintf(&quot;Bad final aspectratio:&quot;);
443            bbox.print();
444          }
445          continue;
446        }
447        if (overlapped_blobs.length() &gt;= kCJKMaxComponents) {
448          if (debug) {
449            tprintf(&quot;Too many neighbours: %d\n&quot;, overlapped_blobs.length());
450          }
451          continue;
452        }
453        BLOBNBOX_C_IT n_it(&amp;overlapped_blobs);
454        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
455          BLOBNBOX *neighbour = nullptr;
456          neighbour = n_it.data();
457          if (!blob-&gt;MatchingStrokeWidth(*neighbour, kStrokeWidthFractionCJK, kStrokeWidthCJK)) {
458            break;
459          }
460        }
461        if (!n_it.cycled_list()) {
462          if (debug) {
463            tprintf(&quot;Bad stroke widths:&quot;);
464            PrintBoxWidths(blob);
465          }
466          continue; 
467        }
468        RemoveBBox(blob);
469        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
470          BLOBNBOX *neighbour = n_it.data();
471          RemoveBBox(neighbour);
472          neighbour-&gt;set_region_type(BRT_NOISE);
473          blob-&gt;really_merge(neighbour);
474          if (rerotation_.x() != 1.0f || rerotation_.y() != 0.0f) {
475            blob-&gt;rotate_box(rerotation_);
476          }
477        }
478        InsertBBox(true, true, blob);
479        ++num_fixed;
480        if (debug) {
481          tprintf(&quot;Done! Final box:&quot;);
482          bbox.print();
483        }
484      }
485    }
486    int num_remaining = 0;
487    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
488      BLOBNBOX *blob = blob_it.data();
489      if (blob-&gt;cblob() != nullptr &amp;&amp; !blob-&gt;cblob()-&gt;out_list()-&gt;empty()) {
490        ++num_remaining;
491      }
492    }
493    block-&gt;DeleteUnownedNoise();
494    return num_fixed &gt; num_remaining * kBrokenCJKIterationFraction;
495  }
496  static bool AcceptableCJKMerge(const TBOX &amp;bbox, const TBOX &amp;nbox, bool debug, int max_size,
497                                 int max_dist, int *x_gap, int *y_gap) {
498    *x_gap = bbox.x_gap(nbox);
499    *y_gap = bbox.y_gap(nbox);
500    TBOX merged(nbox);
501    merged += bbox;
502    if (debug) {
503      tprintf(&quot;gaps = %d, %d, merged_box:&quot;, *x_gap, *y_gap);
504      merged.print();
505    }
506    if (*x_gap &lt;= max_dist &amp;&amp; *y_gap &lt;= max_dist &amp;&amp; merged.width() &lt;= max_size &amp;&amp;
507        merged.height() &lt;= max_size) {
508      double old_ratio = static_cast&lt;double&gt;(bbox.width()) / bbox.height();
509      if (old_ratio &lt; 1.0) {
510        old_ratio = 1.0 / old_ratio;
511      }
512      double new_ratio = static_cast&lt;double&gt;(merged.width()) / merged.height();
513      if (new_ratio &lt; 1.0) {
514        new_ratio = 1.0 / new_ratio;
515      }
516      if (new_ratio &lt;= old_ratio * kCJKAspectRatioIncrease) {
517        return true;
518      }
519    }
520    return false;
521  }
522  void StrokeWidth::AccumulateOverlaps(const BLOBNBOX *not_this, bool debug, int max_size,
523                                       int max_dist, TBOX *bbox, BLOBNBOX_CLIST *blobs) {
524    BLOBNBOX *nearests[BND_COUNT];
525    for (auto &amp;nearest : nearests) {
526      nearest = nullptr;
527    }
528    int x = (bbox-&gt;left() + bbox-&gt;right()) / 2;
529    int y = (bbox-&gt;bottom() + bbox-&gt;top()) / 2;
530    BlobGridSearch radsearch(this);
531    radsearch.StartRadSearch(x, y, kCJKRadius);
532    BLOBNBOX *neighbour;
533    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
534      if (neighbour == not_this) {
535        continue;
536      }
537      TBOX nbox = neighbour-&gt;bounding_box();
538      int x_gap, y_gap;
539      if (AcceptableCJKMerge(*bbox, nbox, debug, max_size, max_dist, &amp;x_gap, &amp;y_gap)) {
540        *bbox += nbox;
541        blobs-&gt;add_sorted(SortByBoxLeft&lt;BLOBNBOX&gt;, true, neighbour);
542        if (debug) {
543          tprintf(&quot;Added:&quot;);
544          nbox.print();
545        }
546        for (int dir = 0; dir &lt; BND_COUNT; ++dir) {
547          if (nearests[dir] == nullptr) {
548            continue;
549          }
550          nbox = nearests[dir]-&gt;bounding_box();
551          if (AcceptableCJKMerge(*bbox, nbox, debug, max_size, max_dist, &amp;x_gap, &amp;y_gap)) {
552            *bbox += nbox;
553            blobs-&gt;add_sorted(SortByBoxLeft&lt;BLOBNBOX&gt;, true, nearests[dir]);
554            if (debug) {
555              tprintf(&quot;Added:&quot;);
556              nbox.print();
557            }
558            nearests[dir] = nullptr;
559            dir = -1; 
560          }
561        }
562      } else if (x_gap &lt; 0 &amp;&amp; x_gap &lt;= y_gap) {
563        BlobNeighbourDir dir = nbox.top() &gt; bbox-&gt;top() ? BND_ABOVE : BND_BELOW;
564        if (nearests[dir] == nullptr || y_gap &lt; bbox-&gt;y_gap(nearests[dir]-&gt;bounding_box())) {
565          nearests[dir] = neighbour;
566        }
567      } else if (y_gap &lt; 0 &amp;&amp; y_gap &lt;= x_gap) {
568        BlobNeighbourDir dir = nbox.left() &gt; bbox-&gt;left() ? BND_RIGHT : BND_LEFT;
569        if (nearests[dir] == nullptr || x_gap &lt; bbox-&gt;x_gap(nearests[dir]-&gt;bounding_box())) {
570          nearests[dir] = neighbour;
571        }
572      }
573      if (nearests[BND_LEFT] &amp;&amp; nearests[BND_RIGHT] &amp;&amp; nearests[BND_ABOVE] &amp;&amp; nearests[BND_BELOW]) {
574        break;
575      }
576    }
577    for (auto &amp;nearest : nearests) {
578      if (nearest == nullptr) {
579        continue;
580      }
581      const TBOX &amp;nbox = nearest-&gt;bounding_box();
582      if (debug) {
583        tprintf(&quot;Testing for overlap with:&quot;);
584        nbox.print();
585      }
586      if (bbox-&gt;overlap(nbox)) {
587        blobs-&gt;shallow_clear();
588        if (debug) {
589          tprintf(&quot;Final box overlaps nearest\n&quot;);
590        }
591        return;
592      }
593    }
594  }
595  void StrokeWidth::FindTextlineFlowDirection(PageSegMode pageseg_mode, bool display_if_debugging) {
596    BlobGridSearch gsearch(this);
597    BLOBNBOX *bbox;
598    gsearch.StartFullSearch();
599    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
600      SetNeighbours(false, display_if_debugging, bbox);
601    }
602    gsearch.StartFullSearch();
603    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
604      SimplifyObviousNeighbours(bbox);
605    }
606    gsearch.StartFullSearch();
607    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
608      if (FindingVerticalOnly(pageseg_mode)) {
609        bbox-&gt;set_vert_possible(true);
610        bbox-&gt;set_horz_possible(false);
611      } else if (FindingHorizontalOnly(pageseg_mode)) {
612        bbox-&gt;set_vert_possible(false);
613        bbox-&gt;set_horz_possible(true);
614      } else {
615        SetNeighbourFlows(bbox);
616      }
617    }
618  #ifndef GRAPHICS_DISABLED
619    if ((textord_tabfind_show_strokewidths &amp;&amp; display_if_debugging) ||
620        textord_tabfind_show_strokewidths &gt; 1) {
621      initial_widths_win_ = DisplayGoodBlobs(&quot;InitialStrokewidths&quot;, 400, 0);
622    }
623  #endif
624    gsearch.StartFullSearch();
625    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
626      SmoothNeighbourTypes(pageseg_mode, false, bbox);
627    }
628    gsearch.StartFullSearch();
629    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
630      SmoothNeighbourTypes(pageseg_mode, true, bbox);
631    }
632    gsearch.StartFullSearch();
633    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
634      SmoothNeighbourTypes(pageseg_mode, true, bbox);
635    }
636  #ifndef GRAPHICS_DISABLED
637    if ((textord_tabfind_show_strokewidths &amp;&amp; display_if_debugging) ||
638        textord_tabfind_show_strokewidths &gt; 1) {
639      widths_win_ = DisplayGoodBlobs(&quot;ImprovedStrokewidths&quot;, 800, 0);
640    }
641  #endif
642  }
643  void StrokeWidth::SetNeighbours(bool leaders, bool activate_line_trap, BLOBNBOX *blob) {
644    int line_trap_count = 0;
645    for (int dir = 0; dir &lt; BND_COUNT; ++dir) {
646      auto bnd = static_cast&lt;BlobNeighbourDir&gt;(dir);
647      line_trap_count += FindGoodNeighbour(bnd, leaders, blob);
648    }
649    if (line_trap_count &gt; 0 &amp;&amp; activate_line_trap) {
650      blob-&gt;ClearNeighbours();
651      const TBOX &amp;box = blob-&gt;bounding_box();
652      blob-&gt;set_region_type(box.width() &gt; box.height() ? BRT_HLINE : BRT_VLINE);
653    }
654  }
655  int StrokeWidth::FindGoodNeighbour(BlobNeighbourDir dir, bool leaders, BLOBNBOX *blob) {
656    TBOX blob_box = blob-&gt;bounding_box();
657    bool debug = AlignedBlob::WithinTestRegion(2, blob_box.left(), blob_box.bottom());
658    if (debug) {
659      tprintf(&quot;FGN in dir %d for blob:&quot;, dir);
660      blob_box.print();
661    }
662    int top = blob_box.top();
663    int bottom = blob_box.bottom();
664    int left = blob_box.left();
665    int right = blob_box.right();
666    int width = right - left;
667    int height = top - bottom;
668    int line_trap_max = std::max(width, height) / kLineTrapLongest;
669    int line_trap_min = std::min(width, height) * kLineTrapShortest;
670    int line_trap_count = 0;
671    int min_good_overlap = (dir == BND_LEFT || dir == BND_RIGHT) ? height / 2 : width / 2;
672    int min_decent_overlap = (dir == BND_LEFT || dir == BND_RIGHT) ? height / 3 : width / 3;
673    if (leaders) {
674      min_good_overlap = min_decent_overlap = 1;
675    }
676    int search_pad =
677        static_cast&lt;int&gt;(sqrt(static_cast&lt;double&gt;(width * height)) * kNeighbourSearchFactor);
678    if (gridsize() &gt; search_pad) {
679      search_pad = gridsize();
680    }
681    TBOX search_box = blob_box;
682    switch (dir) {
683      case BND_LEFT:
684        search_box.set_left(search_box.left() - search_pad);
685        break;
686      case BND_RIGHT:
687        search_box.set_right(search_box.right() + search_pad);
688        break;
689      case BND_BELOW:
690        search_box.set_bottom(search_box.bottom() - search_pad);
691        break;
692      case BND_ABOVE:
693        search_box.set_top(search_box.top() + search_pad);
694        break;
695      case BND_COUNT:
696        return 0;
697    }
698    BlobGridSearch rectsearch(this);
699    rectsearch.StartRectSearch(search_box);
700    BLOBNBOX *best_neighbour = nullptr;
701    double best_goodness = 0.0;
702    bool best_is_good = false;
703    BLOBNBOX *neighbour;
704    while ((neighbour = rectsearch.NextRectSearch()) != nullptr) {
705      TBOX nbox = neighbour-&gt;bounding_box();
706      if (neighbour == blob) {
707        continue;
708      }
709      int mid_x = (nbox.left() + nbox.right()) / 2;
710      if (mid_x &lt; blob-&gt;left_rule() || mid_x &gt; blob-&gt;right_rule()) {
711        continue; 
712      }
713      if (debug) {
714        tprintf(&quot;Neighbour at:&quot;);
715        nbox.print();
716      }
717      int n_width = nbox.width();
718      int n_height = nbox.height();
719      if (std::min(n_width, n_height) &gt; line_trap_min &amp;&amp;
720          std::max(n_width, n_height) &lt; line_trap_max) {
721        ++line_trap_count;
722      }
723      if (TabFind::VeryDifferentSizes(std::max(n_width, n_height), std::max(width, height)) &amp;&amp;
724          (((dir == BND_LEFT || dir == BND_RIGHT) &amp;&amp; TabFind::DifferentSizes(n_height, height)) ||
725           ((dir == BND_BELOW || dir == BND_ABOVE) &amp;&amp; TabFind::DifferentSizes(n_width, width)))) {
726        if (debug) {
727          tprintf(&quot;Bad size\n&quot;);
728        }
729        continue; 
730      }
731      int overlap;
732      int perp_overlap;
733      int gap;
734      if (dir == BND_LEFT || dir == BND_RIGHT) {
735        overlap = std::min(static_cast&lt;int&gt;(nbox.top()), top) -
736                  std::max(static_cast&lt;int&gt;(nbox.bottom()), bottom);
737        if (overlap == nbox.height() &amp;&amp; nbox.width() &gt; nbox.height()) {
738          perp_overlap = nbox.width();
739        } else {
740          perp_overlap = overlap;
741        }
742        gap = dir == BND_LEFT ? left - nbox.left() : nbox.right() - right;
743        if (gap &lt;= 0) {
744          if (debug) {
745            tprintf(&quot;On wrong side\n&quot;);
746          }
747          continue; 
748        }
749        gap -= n_width;
750      } else {
751        overlap = std::min(static_cast&lt;int&gt;(nbox.right()), right) -
752                  std::max(static_cast&lt;int&gt;(nbox.left()), left);
753        if (overlap == nbox.width() &amp;&amp; nbox.height() &gt; nbox.width()) {
754          perp_overlap = nbox.height();
755        } else {
756          perp_overlap = overlap;
757        }
758        gap = dir == BND_BELOW ? bottom - nbox.bottom() : nbox.top() - top;
759        if (gap &lt;= 0) {
760          if (debug) {
761            tprintf(&quot;On wrong side\n&quot;);
762          }
763          continue; 
764        }
765        gap -= n_height;
766      }
767      if (-gap &gt; overlap) {
768        if (debug) {
769          tprintf(&quot;Overlaps wrong way\n&quot;);
770        }
771        continue; 
772      }
773      if (perp_overlap &lt; min_decent_overlap) {
774        if (debug) {
775          tprintf(&quot;Doesn&#x27;t overlap enough\n&quot;);
776        }
777        continue; 
778      }
779      bool bad_sizes =
780          TabFind::DifferentSizes(height, n_height) &amp;&amp; TabFind::DifferentSizes(width, n_width);
781      bool is_good =
782          overlap &gt;= min_good_overlap &amp;&amp; !bad_sizes &amp;&amp;
783          blob-&gt;MatchingStrokeWidth(*neighbour, kStrokeWidthFractionTolerance, kStrokeWidthTolerance);
784      if (gap &lt; 1) {
785        gap = 1;
786      }
787      double goodness = (1.0 + is_good) * overlap / gap;
788      if (debug) {
789        tprintf(&quot;goodness = %g vs best of %g, good=%d, overlap=%d, gap=%d\n&quot;, goodness, best_goodness,
790                is_good, overlap, gap);
791      }
792      if (goodness &gt; best_goodness) {
793        best_neighbour = neighbour;
794        best_goodness = goodness;
795        best_is_good = is_good;
796      }
797    }
798    blob-&gt;set_neighbour(dir, best_neighbour, best_is_good);
799    return line_trap_count;
800  }
801  static void ListNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
802    for (int dir = 0; dir &lt; BND_COUNT; ++dir) {
803      auto bnd = static_cast&lt;BlobNeighbourDir&gt;(dir);
804      BLOBNBOX *neighbour = blob-&gt;neighbour(bnd);
805      if (neighbour != nullptr) {
806        neighbours-&gt;add_sorted(SortByBoxLeft&lt;BLOBNBOX&gt;, true, neighbour);
807      }
808    }
809  }
810  static void List2ndNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
811    ListNeighbours(blob, neighbours);
812    for (int dir = 0; dir &lt; BND_COUNT; ++dir) {
813      auto bnd = static_cast&lt;BlobNeighbourDir&gt;(dir);
814      BLOBNBOX *neighbour = blob-&gt;neighbour(bnd);
815      if (neighbour != nullptr) {
816        ListNeighbours(neighbour, neighbours);
817      }
818    }
819  }
820  static void List3rdNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
821    List2ndNeighbours(blob, neighbours);
822    for (int dir = 0; dir &lt; BND_COUNT; ++dir) {
823      auto bnd = static_cast&lt;BlobNeighbourDir&gt;(dir);
824      BLOBNBOX *neighbour = blob-&gt;neighbour(bnd);
825      if (neighbour != nullptr) {
826        List2ndNeighbours(neighbour, neighbours);
827      }
828    }
829  }
830  static void CountNeighbourGaps(bool debug, BLOBNBOX_CLIST *neighbours, int *pure_h_count,
831                                 int *pure_v_count) {
832    if (neighbours-&gt;length() &lt;= kMostlyOneDirRatio) {
833      return;
834    }
835    BLOBNBOX_C_IT it(neighbours);
836    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
837      BLOBNBOX *blob = it.data();
838      int h_min, h_max, v_min, v_max;
839      blob-&gt;MinMaxGapsClipped(&amp;h_min, &amp;h_max, &amp;v_min, &amp;v_max);
840      if (debug) {
841        tprintf(&quot;Hgaps [%d,%d], vgaps [%d,%d]:&quot;, h_min, h_max, v_min, v_max);
842      }
843      if (h_max &lt; v_min || blob-&gt;leader_on_left() || blob-&gt;leader_on_right()) {
844        ++*pure_h_count;
845        if (debug) {
846          tprintf(&quot;Horz at:&quot;);
847        }
848      } else if (v_max &lt; h_min) {
849        ++*pure_v_count;
850        if (debug) {
851          tprintf(&quot;Vert at:&quot;);
852        }
853      } else {
854        if (debug) {
855          tprintf(&quot;Neither at:&quot;);
856        }
857      }
858      if (debug) {
859        blob-&gt;bounding_box().print();
860      }
861    }
862  }
863  void StrokeWidth::SetNeighbourFlows(BLOBNBOX *blob) {
864    if (blob-&gt;DefiniteIndividualFlow()) {
865      return;
866    }
867    bool debug =
868        AlignedBlob::WithinTestRegion(2, blob-&gt;bounding_box().left(), blob-&gt;bounding_box().bottom());
869    if (debug) {
870      tprintf(&quot;SetNeighbourFlows (current flow=%d, type=%d) on:&quot;, blob-&gt;flow(), blob-&gt;region_type());
871      blob-&gt;bounding_box().print();
872    }
873    BLOBNBOX_CLIST neighbours;
874    List3rdNeighbours(blob, &amp;neighbours);
875    int pure_h_count = 0;
876    int pure_v_count = 0;
877    CountNeighbourGaps(debug, &amp;neighbours, &amp;pure_h_count, &amp;pure_v_count);
878    if (debug) {
879      HandleClick(blob-&gt;bounding_box().left() + 1, blob-&gt;bounding_box().bottom() + 1);
880      tprintf(&quot;SetFlows: h_count=%d, v_count=%d\n&quot;, pure_h_count, pure_v_count);
881    }
882    if (!neighbours.empty()) {
883      blob-&gt;set_vert_possible(true);
884      blob-&gt;set_horz_possible(true);
885      if (pure_h_count &gt; 2 * pure_v_count) {
886        blob-&gt;set_vert_possible(false);
887      } else if (pure_v_count &gt; 2 * pure_h_count) {
888        blob-&gt;set_horz_possible(false);
889      }
890    } else {
891      blob-&gt;set_vert_possible(false);
892      blob-&gt;set_horz_possible(false);
893    }
894  }
895  static void CountNeighbourTypes(BLOBNBOX_CLIST *neighbours, int *pure_h_count, int *pure_v_count) {
896    BLOBNBOX_C_IT it(neighbours);
897    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
898      BLOBNBOX *blob = it.data();
899      if (blob-&gt;UniquelyHorizontal()) {
900        ++*pure_h_count;
901      }
902      if (blob-&gt;UniquelyVertical()) {
903        ++*pure_v_count;
904      }
905    }
906  }
907  void StrokeWidth::SimplifyObviousNeighbours(BLOBNBOX *blob) {
908    if ((blob-&gt;bounding_box().width() &gt; 3 * blob-&gt;area_stroke_width() &amp;&amp;
909         blob-&gt;bounding_box().height() &gt; 3 * blob-&gt;area_stroke_width())) {
910      if (blob-&gt;bounding_box().width() &gt; 4 * blob-&gt;bounding_box().height()) {
911        blob-&gt;set_neighbour(BND_ABOVE, nullptr, false);
912        blob-&gt;set_neighbour(BND_BELOW, nullptr, false);
913        return;
914      }
915      if (blob-&gt;bounding_box().height() &gt; 4 * blob-&gt;bounding_box().width()) {
916        blob-&gt;set_neighbour(BND_LEFT, nullptr, false);
917        blob-&gt;set_neighbour(BND_RIGHT, nullptr, false);
918        return;
919      }
920    }
921    int margin = gridsize() / 2;
922    int h_min, h_max, v_min, v_max;
923    blob-&gt;MinMaxGapsClipped(&amp;h_min, &amp;h_max, &amp;v_min, &amp;v_max);
924    if ((h_max + margin &lt; v_min &amp;&amp; h_max &lt; margin / 2) || blob-&gt;leader_on_left() ||
925        blob-&gt;leader_on_right()) {
926      blob-&gt;set_neighbour(BND_ABOVE, nullptr, false);
927      blob-&gt;set_neighbour(BND_BELOW, nullptr, false);
928    } else if (v_max + margin &lt; h_min &amp;&amp; v_max &lt; margin / 2) {
929      blob-&gt;set_neighbour(BND_LEFT, nullptr, false);
930      blob-&gt;set_neighbour(BND_RIGHT, nullptr, false);
931    }
932  }
933  void StrokeWidth::SmoothNeighbourTypes(PageSegMode pageseg_mode, bool reset_all, BLOBNBOX *blob) {
934    if ((blob-&gt;vert_possible() &amp;&amp; blob-&gt;horz_possible()) || reset_all) {
935      BLOBNBOX_CLIST neighbours;
936      List2ndNeighbours(blob, &amp;neighbours);
937      int pure_h_count = 0;
938      int pure_v_count = 0;
939      CountNeighbourTypes(&amp;neighbours, &amp;pure_h_count, &amp;pure_v_count);
940      if (AlignedBlob::WithinTestRegion(2, blob-&gt;bounding_box().left(),
941                                        blob-&gt;bounding_box().bottom())) {
942        HandleClick(blob-&gt;bounding_box().left() + 1, blob-&gt;bounding_box().bottom() + 1);
943        tprintf(&quot;pure_h=%d, pure_v=%d\n&quot;, pure_h_count, pure_v_count);
944      }
945      if (pure_h_count &gt; pure_v_count &amp;&amp; !FindingVerticalOnly(pageseg_mode)) {
946        blob-&gt;set_vert_possible(false);
947        blob-&gt;set_horz_possible(true);
948      } else if (pure_v_count &gt; pure_h_count &amp;&amp; !FindingHorizontalOnly(pageseg_mode)) {
949        blob-&gt;set_horz_possible(false);
950        blob-&gt;set_vert_possible(true);
951      }
952    } else if (AlignedBlob::WithinTestRegion(2, blob-&gt;bounding_box().left(),
953                                             blob-&gt;bounding_box().bottom())) {
954      HandleClick(blob-&gt;bounding_box().left() + 1, blob-&gt;bounding_box().bottom() + 1);
955      tprintf(&quot;Clean on pass 3!\n&quot;);
956    }
957  }
958  PartitionFindResult StrokeWidth::FindInitialPartitions(
959      PageSegMode pageseg_mode, const FCOORD &amp;rerotation, bool find_problems, TO_BLOCK *block,
960      BLOBNBOX_LIST *diacritic_blobs, ColPartitionGrid *part_grid, ColPartition_LIST *big_parts,
961      FCOORD *skew_angle) {
962    if (!FindingHorizontalOnly(pageseg_mode)) {
963      FindVerticalTextChains(part_grid);
964    }
965    if (!FindingVerticalOnly(pageseg_mode)) {
966      FindHorizontalTextChains(part_grid);
967    }
968  #ifndef GRAPHICS_DISABLED
969    if (textord_tabfind_show_strokewidths) {
970      chains_win_ = MakeWindow(0, 400, &quot;Initial text chains&quot;);
971      part_grid-&gt;DisplayBoxes(chains_win_);
972      projection_-&gt;DisplayProjection();
973    }
974  #endif
975    if (find_problems) {
976    }
977    part_grid-&gt;SplitOverlappingPartitions(big_parts);
978    EasyMerges(part_grid);
979    RemoveLargeUnusedBlobs(block, part_grid, big_parts);
980    TBOX grid_box(bleft(), tright());
981    while (part_grid-&gt;GridSmoothNeighbours(BTFT_CHAIN, nontext_map_, grid_box, rerotation)) {
982      ;
983    }
984    while (part_grid-&gt;GridSmoothNeighbours(BTFT_NEIGHBOURS, nontext_map_, grid_box, rerotation)) {
985      ;
986    }
987    int pre_overlap = part_grid-&gt;ComputeTotalOverlap(nullptr);
988    TestDiacritics(part_grid, block);
989    MergeDiacritics(block, part_grid);
990    if (find_problems &amp;&amp; diacritic_blobs != nullptr &amp;&amp;
991        DetectAndRemoveNoise(pre_overlap, grid_box, block, part_grid, diacritic_blobs)) {
992      return PFR_NOISE;
993    }
994  #ifndef GRAPHICS_DISABLED
995    if (textord_tabfind_show_strokewidths) {
996      textlines_win_ = MakeWindow(400, 400, &quot;GoodTextline blobs&quot;);
997      part_grid-&gt;DisplayBoxes(textlines_win_);
998      diacritics_win_ = DisplayDiacritics(&quot;Diacritics&quot;, 0, 0, block);
999    }
1000  #endif
1001    PartitionRemainingBlobs(pageseg_mode, part_grid);
1002    part_grid-&gt;SplitOverlappingPartitions(big_parts);
1003    EasyMerges(part_grid);
1004    while (part_grid-&gt;GridSmoothNeighbours(BTFT_CHAIN, nontext_map_, grid_box, rerotation)) {
1005      ;
1006    }
1007    while (part_grid-&gt;GridSmoothNeighbours(BTFT_NEIGHBOURS, nontext_map_, grid_box, rerotation)) {
1008      ;
1009    }
1010    while (part_grid-&gt;GridSmoothNeighbours(BTFT_STRONG_CHAIN, nontext_map_, grid_box, rerotation)) {
1011      ;
1012    }
1013  #ifndef GRAPHICS_DISABLED
1014    if (textord_tabfind_show_strokewidths) {
1015      smoothed_win_ = MakeWindow(800, 400, &quot;Smoothed blobs&quot;);
1016      part_grid-&gt;DisplayBoxes(smoothed_win_);
1017    }
1018  #endif
1019    return PFR_OK;
1020  }
1021  bool StrokeWidth::DetectAndRemoveNoise(int pre_overlap, const TBOX &amp;grid_box, TO_BLOCK *block,
1022                                         ColPartitionGrid *part_grid,
1023                                         BLOBNBOX_LIST *diacritic_blobs) {
1024    ColPartitionGrid *noise_grid = nullptr;
1025    int post_overlap = part_grid-&gt;ComputeTotalOverlap(&amp;noise_grid);
1026    if (pre_overlap == 0) {
1027      pre_overlap = 1;
1028    }
1029    BLOBNBOX_IT diacritic_it(diacritic_blobs);
1030    if (noise_grid != nullptr) {
1031      if (post_overlap &gt; pre_overlap * kNoiseOverlapGrowthFactor &amp;&amp;
1032          post_overlap &gt; grid_box.area() * kNoiseOverlapAreaFactor) {
1033  #ifndef GRAPHICS_DISABLED
1034        if (textord_tabfind_show_strokewidths) {
1035          ScrollView *noise_win = MakeWindow(1000, 500, &quot;Noise Areas&quot;);
1036          noise_grid-&gt;DisplayBoxes(noise_win);
1037        }
1038  #endif
1039        part_grid-&gt;DeleteNonLeaderParts();
1040        BLOBNBOX_IT blob_it(&amp;block-&gt;noise_blobs);
1041        ColPartitionGridSearch rsearch(noise_grid);
1042        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1043          BLOBNBOX *blob = blob_it.data();
1044          blob-&gt;ClearNeighbours();
1045          if (!blob-&gt;IsDiacritic() || blob-&gt;owner() != nullptr) {
1046            continue; 
1047          }
1048          TBOX search_box(blob-&gt;bounding_box());
1049          search_box.pad(gridsize(), gridsize());
1050          rsearch.StartRectSearch(search_box);
1051          ColPartition *part = rsearch.NextRectSearch();
1052          if (part != nullptr) {
1053            blob-&gt;set_owns_cblob(true);
1054            blob-&gt;compute_bounding_box();
1055            diacritic_it.add_after_then_move(blob_it.extract());
1056          }
1057        }
1058        noise_grid-&gt;DeleteParts();
1059        delete noise_grid;
1060        return true;
1061      }
1062      noise_grid-&gt;DeleteParts();
1063      delete noise_grid;
1064    }
1065    return false;
1066  }
1067  static BLOBNBOX *MutualUnusedVNeighbour(const BLOBNBOX *blob, BlobNeighbourDir dir) {
1068    BLOBNBOX *next_blob = blob-&gt;neighbour(dir);
1069    if (next_blob == nullptr || next_blob-&gt;owner() != nullptr || next_blob-&gt;UniquelyHorizontal()) {
1070      return nullptr;
1071    }
1072    if (next_blob-&gt;neighbour(DirOtherWay(dir)) == blob) {
1073      return next_blob;
1074    }
1075    return nullptr;
1076  }
1077  void StrokeWidth::FindVerticalTextChains(ColPartitionGrid *part_grid) {
1078    PageSegMode pageseg_mode =
1079        rerotation_.y() == 0.0f ? PSM_SINGLE_BLOCK_VERT_TEXT : PSM_SINGLE_COLUMN;
1080    BlobGridSearch gsearch(this);
1081    BLOBNBOX *bbox;
1082    gsearch.StartFullSearch();
1083    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1084      BLOBNBOX *blob;
1085      if (bbox-&gt;owner() == nullptr &amp;&amp; bbox-&gt;UniquelyVertical() &amp;&amp;
1086          (blob = MutualUnusedVNeighbour(bbox, BND_ABOVE)) != nullptr) {
1087        auto *part = new ColPartition(BRT_VERT_TEXT, ICOORD(0, 1));
1088        part-&gt;AddBox(bbox);
1089        while (blob != nullptr) {
1090          part-&gt;AddBox(blob);
1091          blob = MutualUnusedVNeighbour(blob, BND_ABOVE);
1092        }
1093        blob = MutualUnusedVNeighbour(bbox, BND_BELOW);
1094        while (blob != nullptr) {
1095          part-&gt;AddBox(blob);
1096          blob = MutualUnusedVNeighbour(blob, BND_BELOW);
1097        }
1098        CompletePartition(pageseg_mode, part, part_grid);
1099      }
1100    }
1101  }
1102  static BLOBNBOX *MutualUnusedHNeighbour(const BLOBNBOX *blob, BlobNeighbourDir dir) {
1103    BLOBNBOX *next_blob = blob-&gt;neighbour(dir);
1104    if (next_blob == nullptr || next_blob-&gt;owner() != nullptr || next_blob-&gt;UniquelyVertical()) {
1105      return nullptr;
1106    }
1107    if (next_blob-&gt;neighbour(DirOtherWay(dir)) == blob) {
1108      return next_blob;
1109    }
1110    return nullptr;
1111  }
1112  void StrokeWidth::FindHorizontalTextChains(ColPartitionGrid *part_grid) {
1113    PageSegMode pageseg_mode =
1114        rerotation_.y() == 0.0f ? PSM_SINGLE_COLUMN : PSM_SINGLE_BLOCK_VERT_TEXT;
1115    BlobGridSearch gsearch(this);
1116    BLOBNBOX *bbox;
1117    gsearch.StartFullSearch();
1118    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1119      BLOBNBOX *blob;
1120      if (bbox-&gt;owner() == nullptr &amp;&amp; bbox-&gt;UniquelyHorizontal() &amp;&amp;
1121          (blob = MutualUnusedHNeighbour(bbox, BND_RIGHT)) != nullptr) {
1122        auto *part = new ColPartition(BRT_TEXT, ICOORD(0, 1));
1123        part-&gt;AddBox(bbox);
1124        while (blob != nullptr) {
1125          part-&gt;AddBox(blob);
1126          blob = MutualUnusedHNeighbour(blob, BND_RIGHT);
1127        }
1128        blob = MutualUnusedHNeighbour(bbox, BND_LEFT);
1129        while (blob != nullptr) {
1130          part-&gt;AddBox(blob);
1131          blob = MutualUnusedVNeighbour(blob, BND_LEFT);
1132        }
1133        CompletePartition(pageseg_mode, part, part_grid);
1134      }
1135    }
1136  }
1137  void StrokeWidth::TestDiacritics(ColPartitionGrid *part_grid, TO_BLOCK *block) {
1138    BlobGrid small_grid(gridsize(), bleft(), tright());
1139    small_grid.InsertBlobList(&amp;block-&gt;noise_blobs);
1140    small_grid.InsertBlobList(&amp;block-&gt;blobs);
1141    int medium_diacritics = 0;
1142    int small_diacritics = 0;
1143    BLOBNBOX_IT small_it(&amp;block-&gt;noise_blobs);
1144    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
1145      BLOBNBOX *blob = small_it.data();
1146      if (blob-&gt;owner() == nullptr &amp;&amp; !blob-&gt;IsDiacritic() &amp;&amp; DiacriticBlob(&amp;small_grid, blob)) {
1147        ++small_diacritics;
1148      }
1149    }
1150    BLOBNBOX_IT blob_it(&amp;block-&gt;blobs);
1151    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1152      BLOBNBOX *blob = blob_it.data();
1153      if (blob-&gt;IsDiacritic()) {
1154        small_it.add_to_end(blob_it.extract());
1155        continue; 
1156      }
1157      ColPartition *part = blob-&gt;owner();
1158      if (part == nullptr &amp;&amp; DiacriticBlob(&amp;small_grid, blob)) {
1159        ++medium_diacritics;
1160        RemoveBBox(blob);
1161        small_it.add_to_end(blob_it.extract());
1162      } else if (part != nullptr &amp;&amp; !part-&gt;block_owned() &amp;&amp; part-&gt;boxes_count() &lt; 3) {
1163        BLOBNBOX_C_IT box_it(part-&gt;boxes());
1164        for (box_it.mark_cycle_pt();
1165             !box_it.cycled_list() &amp;&amp; DiacriticBlob(&amp;small_grid, box_it.data()); box_it.forward()) {
1166          ;
1167        }
1168        if (box_it.cycled_list()) {
1169          while (!box_it.empty()) {
1170            BLOBNBOX *box = box_it.extract();
1171            box-&gt;set_owner(nullptr);
1172            box_it.forward();
1173            ++medium_diacritics;
1174            RemoveBBox(box);
1175          }
1176          small_it.add_to_end(blob_it.extract());
1177          part_grid-&gt;RemoveBBox(part);
1178          delete part;
1179        }
1180      } else if (AlignedBlob::WithinTestRegion(2, blob-&gt;bounding_box().left(),
1181                                               blob-&gt;bounding_box().bottom())) {
1182        tprintf(&quot;Blob not available to be a diacritic at:&quot;);
1183        blob-&gt;bounding_box().print();
1184      }
1185    }
1186    if (textord_tabfind_show_strokewidths) {
1187      tprintf(&quot;Found %d small diacritics, %d medium\n&quot;, small_diacritics, medium_diacritics);
1188    }
1189  }
1190  bool StrokeWidth::DiacriticBlob(BlobGrid *small_grid, BLOBNBOX *blob) {
1191    if (BLOBNBOX::UnMergeableType(blob-&gt;region_type()) || blob-&gt;region_type() == BRT_VERT_TEXT) {
1192      return false;
1193    }
1194    TBOX small_box(blob-&gt;bounding_box());
1195    bool debug = AlignedBlob::WithinTestRegion(2, small_box.left(), small_box.bottom());
1196    if (debug) {
1197      tprintf(&quot;Testing blob for diacriticness at:&quot;);
1198      small_box.print();
1199    }
1200    int x = (small_box.left() + small_box.right()) / 2;
1201    int y = (small_box.bottom() + small_box.top()) / 2;
1202    int grid_x, grid_y;
1203    GridCoords(x, y, &amp;grid_x, &amp;grid_y);
1204    int height = small_box.height();
1205    BLOBNBOX *best_x_overlap = nullptr;
1206    BLOBNBOX *best_y_overlap = nullptr;
1207    int best_total_dist = 0;
1208    int best_y_gap = 0;
1209    TBOX best_xbox;
1210    TBOX search_box(small_box);
1211    int x_pad = IntCastRounded(gridsize() * kDiacriticXPadRatio);
1212    int y_pad = IntCastRounded(gridsize() * kDiacriticYPadRatio);
1213    search_box.pad(x_pad, y_pad);
1214    BlobGridSearch rsearch(this);
1215    rsearch.SetUniqueMode(true);
1216    int min_height = height * kMinDiacriticSizeRatio;
1217    rsearch.StartRectSearch(search_box);
1218    BLOBNBOX *neighbour;
1219    while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1220      if (BLOBNBOX::UnMergeableType(neighbour-&gt;region_type()) || neighbour == blob ||
1221          neighbour-&gt;owner() == blob-&gt;owner()) {
1222        continue;
1223      }
1224      TBOX nbox = neighbour-&gt;bounding_box();
1225      if (neighbour-&gt;owner() == nullptr || neighbour-&gt;owner()-&gt;IsVerticalType() ||
1226          (neighbour-&gt;flow() != BTFT_CHAIN &amp;&amp; neighbour-&gt;flow() != BTFT_STRONG_CHAIN)) {
1227        if (debug) {
1228          tprintf(&quot;Neighbour not strong enough:&quot;);
1229          nbox.print();
1230        }
1231        continue; 
1232      }
1233      if (nbox.height() &lt; min_height) {
1234        if (debug) {
1235          tprintf(&quot;Neighbour not big enough:&quot;);
1236          nbox.print();
1237        }
1238        continue; 
1239      }
1240      int x_gap = small_box.x_gap(nbox);
1241      int y_gap = small_box.y_gap(nbox);
1242      int total_distance = projection_-&gt;DistanceOfBoxFromBox(small_box, nbox, true, denorm_, debug);
1243      if (debug) {
1244        tprintf(&quot;xgap=%d, y=%d, total dist=%d\n&quot;, x_gap, y_gap, total_distance);
1245      }
1246      if (total_distance &gt; neighbour-&gt;owner()-&gt;median_height() * kMaxDiacriticDistanceRatio) {
1247        if (debug) {
1248          tprintf(&quot;Neighbour with median size %d too far away:&quot;, neighbour-&gt;owner()-&gt;median_height());
1249          neighbour-&gt;bounding_box().print();
1250        }
1251        continue; 
1252      }
1253      if (x_gap &lt;= 0) {
1254        if (debug) {
1255          tprintf(&quot;Computing reduced box for :&quot;);
1256          nbox.print();
1257        }
1258        int left = small_box.left() - small_box.width();
1259        int right = small_box.right() + small_box.width();
1260        nbox = neighbour-&gt;BoundsWithinLimits(left, right);
1261        y_gap = small_box.y_gap(nbox);
1262        if (best_x_overlap == nullptr || y_gap &lt; best_y_gap) {
1263          best_x_overlap = neighbour;
1264          best_xbox = nbox;
1265          best_y_gap = y_gap;
1266          if (debug) {
1267            tprintf(&quot;New best:&quot;);
1268            nbox.print();
1269          }
1270        } else if (debug) {
1271          tprintf(&quot;Shrunken box doesn&#x27;t win:&quot;);
1272          nbox.print();
1273        }
1274      } else if (blob-&gt;ConfirmNoTabViolation(*neighbour)) {
1275        if (best_y_overlap == nullptr || total_distance &lt; best_total_dist) {
1276          if (debug) {
1277            tprintf(&quot;New best y overlap:&quot;);
1278            nbox.print();
1279          }
1280          best_y_overlap = neighbour;
1281          best_total_dist = total_distance;
1282        } else if (debug) {
1283          tprintf(&quot;New y overlap box doesn&#x27;t win:&quot;);
1284          nbox.print();
1285        }
1286      } else if (debug) {
1287        tprintf(&quot;Neighbour wrong side of a tab:&quot;);
1288        nbox.print();
1289      }
1290    }
1291    if (best_x_overlap != nullptr &amp;&amp;
1292        (best_y_overlap == nullptr || best_xbox.major_y_overlap(best_y_overlap-&gt;bounding_box()))) {
1293      blob-&gt;set_diacritic_box(best_xbox);
1294      blob-&gt;set_base_char_blob(best_x_overlap);
1295      if (debug) {
1296        tprintf(&quot;DiacriticBlob OK! (x-overlap:&quot;);
1297        small_box.print();
1298        best_xbox.print();
1299      }
1300      return true;
1301    }
1302    if (best_y_overlap != nullptr &amp;&amp;
1303        DiacriticXGapFilled(small_grid, small_box, best_y_overlap-&gt;bounding_box()) &amp;&amp;
1304        NoNoiseInBetween(small_box, best_y_overlap-&gt;bounding_box())) {
1305      blob-&gt;set_diacritic_box(best_y_overlap-&gt;bounding_box());
1306      blob-&gt;set_base_char_blob(best_y_overlap);
1307      if (debug) {
1308        tprintf(&quot;DiacriticBlob OK! (y-overlap:&quot;);
1309        small_box.print();
1310        best_y_overlap-&gt;bounding_box().print();
1311      }
1312      return true;
1313    }
1314    if (debug) {
1315      tprintf(&quot;DiacriticBlob fails:&quot;);
1316      small_box.print();
1317      tprintf(&quot;Best x+y gap = %d, y = %d\n&quot;, best_total_dist, best_y_gap);
1318      if (best_y_overlap != nullptr) {
1319        tprintf(&quot;XGapFilled=%d, NoiseBetween=%d\n&quot;,
1320                DiacriticXGapFilled(small_grid, small_box, best_y_overlap-&gt;bounding_box()),
1321                NoNoiseInBetween(small_box, best_y_overlap-&gt;bounding_box()));
1322      }
1323    }
1324    return false;
1325  }
1326  bool StrokeWidth::DiacriticXGapFilled(BlobGrid *grid, const TBOX &amp;diacritic_box,
1327                                        const TBOX &amp;base_box) {
1328    int max_gap = IntCastRounded(base_box.height() * kMaxDiacriticGapToBaseCharHeight);
1329    TBOX occupied_box(base_box);
1330    int diacritic_gap;
1331    while ((diacritic_gap = diacritic_box.x_gap(occupied_box)) &gt; max_gap) {
1332      TBOX search_box(occupied_box);
1333      if (diacritic_box.left() &gt; search_box.right()) {
1334        search_box.set_left(search_box.right());
1335        search_box.set_right(search_box.left() + max_gap);
1336      } else {
1337        search_box.set_right(search_box.left());
1338        search_box.set_left(search_box.left() - max_gap);
1339      }
1340      BlobGridSearch rsearch(grid);
1341      rsearch.StartRectSearch(search_box);
1342      BLOBNBOX *neighbour;
1343      while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1344        const TBOX &amp;nbox = neighbour-&gt;bounding_box();
1345        if (nbox.x_gap(diacritic_box) &lt; diacritic_gap) {
1346          if (nbox.left() &lt; occupied_box.left()) {
1347            occupied_box.set_left(nbox.left());
1348          }
1349          if (nbox.right() &gt; occupied_box.right()) {
1350            occupied_box.set_right(nbox.right());
1351          }
1352          break;
1353        }
1354      }
1355      if (neighbour == nullptr) {
1356        return false; 
1357      }
1358    }
1359    return true; 
1360  }
1361  void StrokeWidth::MergeDiacritics(TO_BLOCK *block, ColPartitionGrid *part_grid) {
1362    BLOBNBOX_IT small_it(&amp;block-&gt;noise_blobs);
1363    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
1364      BLOBNBOX *blob = small_it.data();
1365      if (blob-&gt;base_char_blob() != nullptr) {
1366        ColPartition *part = blob-&gt;base_char_blob()-&gt;owner();
1367        if (part != nullptr &amp;&amp; !part-&gt;block_owned() &amp;&amp; blob-&gt;owner() == nullptr &amp;&amp;
1368            blob-&gt;IsDiacritic()) {
1369          part_grid-&gt;RemoveBBox(part);
1370          part-&gt;AddBox(blob);
1371          blob-&gt;set_region_type(part-&gt;blob_type());
1372          blob-&gt;set_flow(part-&gt;flow());
1373          blob-&gt;set_owner(part);
1374          part_grid-&gt;InsertBBox(true, true, part);
1375        }
1376        blob-&gt;set_base_char_blob(nullptr);
1377      }
1378    }
1379  }
1380  void StrokeWidth::RemoveLargeUnusedBlobs(TO_BLOCK *block, ColPartitionGrid *part_grid,
1381                                           ColPartition_LIST *big_parts) {
1382    BLOBNBOX_IT large_it(&amp;block-&gt;large_blobs);
1383    for (large_it.mark_cycle_pt(); !large_it.cycled_list(); large_it.forward()) {
1384      BLOBNBOX *blob = large_it.data();
1385      ColPartition *big_part = blob-&gt;owner();
1386      if (big_part == nullptr) {
1387        ColPartition::MakeBigPartition(blob, big_parts);
1388      }
1389    }
1390  }
1391  void StrokeWidth::PartitionRemainingBlobs(PageSegMode pageseg_mode, ColPartitionGrid *part_grid) {
1392    BlobGridSearch gsearch(this);
1393    BLOBNBOX *bbox;
1394    int prev_grid_x = -1;
1395    int prev_grid_y = -1;
1396    BLOBNBOX_CLIST cell_list;
1397    BLOBNBOX_C_IT cell_it(&amp;cell_list);
1398    bool cell_all_noise = true;
1399    gsearch.StartFullSearch();
1400    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1401      int grid_x = gsearch.GridX();
1402      int grid_y = gsearch.GridY();
1403      if (grid_x != prev_grid_x || grid_y != prev_grid_y) {
1404        MakePartitionsFromCellList(pageseg_mode, cell_all_noise, part_grid, &amp;cell_list);
1405        cell_it.set_to_list(&amp;cell_list);
1406        prev_grid_x = grid_x;
1407        prev_grid_y = grid_y;
1408        cell_all_noise = true;
1409      }
1410      if (bbox-&gt;owner() == nullptr) {
1411        cell_it.add_to_end(bbox);
1412        if (bbox-&gt;flow() != BTFT_NONTEXT) {
1413          cell_all_noise = false;
1414        }
1415      } else {
1416        cell_all_noise = false;
1417      }
1418    }
1419    MakePartitionsFromCellList(pageseg_mode, cell_all_noise, part_grid, &amp;cell_list);
1420  }
1421  void StrokeWidth::MakePartitionsFromCellList(PageSegMode pageseg_mode, bool combine,
1422                                               ColPartitionGrid *part_grid,
1423                                               BLOBNBOX_CLIST *cell_list) {
1424    if (cell_list-&gt;empty()) {
1425      return;
1426    }
1427    BLOBNBOX_C_IT cell_it(cell_list);
1428    if (combine) {
1429      BLOBNBOX *bbox = cell_it.extract();
1430      auto *part = new ColPartition(bbox-&gt;region_type(), ICOORD(0, 1));
1431      part-&gt;AddBox(bbox);
1432      part-&gt;set_flow(bbox-&gt;flow());
1433      for (cell_it.forward(); !cell_it.empty(); cell_it.forward()) {
1434        part-&gt;AddBox(cell_it.extract());
1435      }
1436      CompletePartition(pageseg_mode, part, part_grid);
1437    } else {
1438      for (; !cell_it.empty(); cell_it.forward()) {
1439        BLOBNBOX *bbox = cell_it.extract();
1440        auto *part = new ColPartition(bbox-&gt;region_type(), ICOORD(0, 1));
1441        part-&gt;set_flow(bbox-&gt;flow());
1442        part-&gt;AddBox(bbox);
1443        CompletePartition(pageseg_mode, part, part_grid);
1444      }
1445    }
1446  }
1447  void StrokeWidth::CompletePartition(PageSegMode pageseg_mode, ColPartition *part,
1448                                      ColPartitionGrid *part_grid) {
1449    part-&gt;ComputeLimits();
1450    TBOX box = part-&gt;bounding_box();
1451    bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
1452    int value = projection_-&gt;EvaluateColPartition(*part, denorm_, debug);
1453    if (value &gt; 0 &amp;&amp; FindingVerticalOnly(pageseg_mode)) {
1454      value = part-&gt;boxes_count() == 1 ? 0 : -2;
1455    } else if (value &lt; 0 &amp;&amp; FindingHorizontalOnly(pageseg_mode)) {
1456      value = part-&gt;boxes_count() == 1 ? 0 : 2;
1457    }
1458    part-&gt;SetRegionAndFlowTypesFromProjectionValue(value);
1459    part-&gt;ClaimBoxes();
1460    part_grid-&gt;InsertBBox(true, true, part);
1461  }
1462  void StrokeWidth::EasyMerges(ColPartitionGrid *part_grid) {
1463    using namespace std::placeholders; 
1464    part_grid-&gt;Merges(std::bind(&amp;StrokeWidth::OrientationSearchBox, this, _1, _2),
1465                      std::bind(&amp;StrokeWidth::ConfirmEasyMerge, this, _1, _2));
1466  }
1467  bool StrokeWidth::OrientationSearchBox(ColPartition *part, TBOX *box) {
1468    if (part-&gt;IsVerticalType()) {
1469      box-&gt;set_top(box-&gt;top() + box-&gt;width());
1470      box-&gt;set_bottom(box-&gt;bottom() - box-&gt;width());
1471    } else {
1472      box-&gt;set_left(box-&gt;left() - box-&gt;height());
1473      box-&gt;set_right(box-&gt;right() + box-&gt;height());
1474    }
1475    return true;
1476  }
1477  bool StrokeWidth::ConfirmEasyMerge(const ColPartition *p1, const ColPartition *p2) {
1478    ASSERT_HOST(p1 != nullptr &amp;&amp; p2 != nullptr);
1479    ASSERT_HOST(!p1-&gt;IsEmpty() &amp;&amp; !p2-&gt;IsEmpty());
1480    if ((p1-&gt;flow() == BTFT_NONTEXT &amp;&amp; p2-&gt;flow() &gt;= BTFT_CHAIN) ||
1481        (p1-&gt;flow() &gt;= BTFT_CHAIN &amp;&amp; p2-&gt;flow() == BTFT_NONTEXT)) {
1482      return false; 
1483    }
1484    if ((p1-&gt;IsVerticalType() || p2-&gt;IsVerticalType()) &amp;&amp; p1-&gt;HCoreOverlap(*p2) &lt;= 0 &amp;&amp;
1485        ((!p1-&gt;IsSingleton() &amp;&amp; !p2-&gt;IsSingleton()) ||
1486         !p1-&gt;bounding_box().major_overlap(p2-&gt;bounding_box()))) {
1487      return false; 
1488    }
1489    if ((p1-&gt;IsHorizontalType() || p2-&gt;IsHorizontalType()) &amp;&amp; p1-&gt;VCoreOverlap(*p2) &lt;= 0 &amp;&amp;
1490        ((!p1-&gt;IsSingleton() &amp;&amp; !p2-&gt;IsSingleton()) ||
1491         (!p1-&gt;bounding_box().major_overlap(p2-&gt;bounding_box()) &amp;&amp;
1492          !p1-&gt;OKDiacriticMerge(*p2, false) &amp;&amp; !p2-&gt;OKDiacriticMerge(*p1, false)))) {
1493      return false; 
1494    }
1495    if (!p1-&gt;ConfirmNoTabViolation(*p2)) {
1496      return false;
1497    }
1498    if (p1-&gt;flow() &lt;= BTFT_NONTEXT &amp;&amp; p2-&gt;flow() &lt;= BTFT_NONTEXT) {
1499      return true;
1500    }
1501    return NoNoiseInBetween(p1-&gt;bounding_box(), p2-&gt;bounding_box());
1502  }
1503  bool StrokeWidth::NoNoiseInBetween(const TBOX &amp;box1, const TBOX &amp;box2) const {
1504    return ImageFind::BlankImageInBetween(box1, box2, grid_box_, rerotation_, nontext_map_);
1505  }
1506  #ifndef GRAPHICS_DISABLED
1507  ScrollView *StrokeWidth::DisplayGoodBlobs(const char *window_name, int x, int y) {
1508    auto window = MakeWindow(x, y, window_name);
1509    window-&gt;Brush(ScrollView::NONE);
1510    BlobGridSearch gsearch(this);
1511    gsearch.StartFullSearch();
1512    BLOBNBOX *bbox;
1513    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1514      const TBOX &amp;box = bbox-&gt;bounding_box();
1515      int left_x = box.left();
1516      int right_x = box.right();
1517      int top_y = box.top();
1518      int bottom_y = box.bottom();
1519      int goodness = bbox-&gt;GoodTextBlob();
1520      BlobRegionType blob_type = bbox-&gt;region_type();
1521      if (bbox-&gt;UniquelyVertical()) {
1522        blob_type = BRT_VERT_TEXT;
1523      }
1524      if (bbox-&gt;UniquelyHorizontal()) {
1525        blob_type = BRT_TEXT;
1526      }
1527      BlobTextFlowType flow = bbox-&gt;flow();
1528      if (flow == BTFT_NONE) {
1529        if (goodness == 0) {
1530          flow = BTFT_NEIGHBOURS;
1531        } else if (goodness == 1) {
1532          flow = BTFT_CHAIN;
1533        } else {
1534          flow = BTFT_STRONG_CHAIN;
1535        }
1536      }
1537      window-&gt;Pen(BLOBNBOX::TextlineColor(blob_type, flow));
1538      window-&gt;Rectangle(left_x, bottom_y, right_x, top_y);
1539    }
1540    window-&gt;Update();
1541    return window;
1542  }
1543  static void DrawDiacriticJoiner(const BLOBNBOX *blob, ScrollView *window) {
1544    const TBOX &amp;blob_box(blob-&gt;bounding_box());
1545    int top = std::max(static_cast&lt;int&gt;(blob_box.top()), blob-&gt;base_char_top());
1546    int bottom = std::min(static_cast&lt;int&gt;(blob_box.bottom()), blob-&gt;base_char_bottom());
1547    int x = (blob_box.left() + blob_box.right()) / 2;
1548    window-&gt;Line(x, top, x, bottom);
1549  }
1550  ScrollView *StrokeWidth::DisplayDiacritics(const char *window_name, int x, int y, TO_BLOCK *block) {
1551    auto window = MakeWindow(x, y, window_name);
1552    window-&gt;Brush(ScrollView::NONE);
1553    BLOBNBOX_IT it(&amp;block-&gt;blobs);
1554    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1555      BLOBNBOX *blob = it.data();
1556      if (blob-&gt;IsDiacritic()) {
1557        window-&gt;Pen(ScrollView::GREEN);
1558        DrawDiacriticJoiner(blob, window);
1559      } else {
1560        window-&gt;Pen(blob-&gt;BoxColor());
1561      }
1562      const TBOX &amp;box = blob-&gt;bounding_box();
1563      window-&gt;Rectangle(box.left(), box.bottom(), box.right(), box.top());
1564    }
1565    it.set_to_list(&amp;block-&gt;noise_blobs);
1566    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1567      BLOBNBOX *blob = it.data();
1568      if (blob-&gt;IsDiacritic()) {
1569        window-&gt;Pen(ScrollView::GREEN);
1570        DrawDiacriticJoiner(blob, window);
1571      } else {
1572        window-&gt;Pen(ScrollView::WHITE);
1573      }
1574      const TBOX &amp;box = blob-&gt;bounding_box();
1575      window-&gt;Rectangle(box.left(), box.bottom(), box.right(), box.top());
1576    }
1577    window-&gt;Update();
1578    return window;
1579  }
1580  #endif 
1581  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #include &lt;algorithm&gt;
5  #include &lt;cmath&gt;
6  #include &lt;utility&gt;
7  #include &quot;tablefind.h&quot;
8  #include &lt;allheaders.h&gt;
9  #include &quot;colpartitionset.h&quot;
10  #include &quot;tablerecog.h&quot;
11  namespace tesseract {
12  const int kMaxVerticalSpacing = 500;
13  const int kMaxBlobWidth = 500;
14  const double kSplitPartitionSize = 2.0;
15  const double kAllowTextHeight = 0.5;
16  const double kAllowTextWidth = 0.6;
17  const double kAllowTextArea = 0.8;
18  const double kAllowBlobHeight = 0.3;
19  const double kAllowBlobWidth = 0.4;
20  const double kAllowBlobArea = 0.05;
21  const int kMinBoxesInTextPartition = 10;
22  const int kMaxBoxesInDataPartition = 20;
23  const double kMaxGapInTextPartition = 4.0;
24  const double kMinMaxGapInTextPartition = 0.5;
25  const double kMaxBlobOverlapFactor = 4.0;
26  const double kMaxTableCellXheight = 2.0;
27  const int kMaxColumnHeaderDistance = 4;
28  const double kTableColumnThreshold = 3.0;
29  const double kMinOverlapWithTable = 0.6;
30  const int kSideSpaceMargin = 10;
31  const double kSmallTableProjectionThreshold = 0.35;
32  const double kLargeTableProjectionThreshold = 0.45;
33  const int kLargeTableRowCount = 6;
34  const int kMinRowsInTable = 3;
35  const int kAdjacentLeaderSearchPadding = 2;
36  const double kParagraphEndingPreviousLineRatio = 1.3;
37  const double kMaxParagraphEndingLeftSpaceMultiple = 3.0;
38  const double kMinParagraphEndingTextToWhitespaceRatio = 3.0;
39  const double kMaxXProjectionGapFactor = 2.0;
40  const double kStrokeWidthFractionalTolerance = 0.25;
41  const double kStrokeWidthConstantTolerance = 2.0;
42  #ifndef GRAPHICS_DISABLED
43  static BOOL_VAR(textord_show_tables, false, &quot;Show table regions (ScrollView)&quot;);
44  static BOOL_VAR(textord_tablefind_show_mark, false,
45                  &quot;Debug table marking steps in detail (ScrollView)&quot;);
46  static BOOL_VAR(textord_tablefind_show_stats, false,
47                  &quot;Show page stats used in table finding (ScrollView)&quot;);
48  #endif
49  static BOOL_VAR(textord_tablefind_recognize_tables, false,
50                  &quot;Enables the table recognizer for table layout and filtering.&quot;);
51  template &lt;typename T&gt;
52  void DeleteObject(T *object) {
53    delete object;
54  }
55  TableFinder::TableFinder()
56      : resolution_(0),
57        global_median_xheight_(0),
58        global_median_blob_width_(0),
59        global_median_ledding_(0),
60        left_to_right_language_(true) {}
61  TableFinder::~TableFinder() {
62    clean_part_grid_.ClearGridData(&amp;DeleteObject&lt;ColPartition&gt;);
63    leader_and_ruling_grid_.ClearGridData(&amp;DeleteObject&lt;ColPartition&gt;);
64    fragmented_text_grid_.ClearGridData(&amp;DeleteObject&lt;ColPartition&gt;);
65    col_seg_grid_.ClearGridData(&amp;DeleteObject&lt;ColSegment&gt;);
66    table_grid_.ClearGridData(&amp;DeleteObject&lt;ColSegment&gt;);
67  }
68  void TableFinder::set_left_to_right_language(bool order) {
69    left_to_right_language_ = order;
70  }
71  void TableFinder::Init(int grid_size, const ICOORD &amp;bottom_left,
72                         const ICOORD &amp;top_right) {
73    clean_part_grid_.Init(grid_size, bottom_left, top_right);
74    leader_and_ruling_grid_.Init(grid_size, bottom_left, top_right);
75    fragmented_text_grid_.Init(grid_size, bottom_left, top_right);
76    col_seg_grid_.Init(grid_size, bottom_left, top_right);
77    table_grid_.Init(grid_size, bottom_left, top_right);
78  }
79  void TableFinder::InsertCleanPartitions(ColPartitionGrid *grid,
80                                          TO_BLOCK *block) {
81    SetGlobalSpacings(grid);
82    ColPartitionGridSearch gsearch(grid);
83    gsearch.SetUniqueMode(true);
84    gsearch.StartFullSearch();
85    ColPartition *part = nullptr;
86    while ((part = gsearch.NextFullSearch()) != nullptr) {
87      if (part-&gt;blob_type() == BRT_NOISE || part-&gt;bounding_box().area() &lt;= 0) {
88        continue;
89      }
90      ColPartition *clean_part = part-&gt;ShallowCopy();
91      ColPartition *leader_part = nullptr;
92      if (part-&gt;IsLineType()) {
93        InsertRulingPartition(clean_part);
94        continue;
95      }
96      if (!part-&gt;IsTextType()) {
97        InsertImagePartition(clean_part);
98        continue;
99      }
100      BLOBNBOX_CLIST *part_boxes = part-&gt;boxes();
101      BLOBNBOX_C_IT pit(part_boxes);
102      for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
103        BLOBNBOX *pblob = pit.data();
104        if (!AllowBlob(*pblob)) {
105          continue;
106        }
107        if (pblob-&gt;flow() == BTFT_LEADER) {
108          if (leader_part == nullptr) {
109            leader_part = part-&gt;ShallowCopy();
110            leader_part-&gt;set_flow(BTFT_LEADER);
111          }
112          leader_part-&gt;AddBox(pblob);
113        } else if (pblob-&gt;region_type() != BRT_NOISE) {
114          clean_part-&gt;AddBox(pblob);
115        }
116      }
117      clean_part-&gt;ComputeLimits();
118      ColPartition *fragmented = clean_part-&gt;CopyButDontOwnBlobs();
119      InsertTextPartition(clean_part);
120      SplitAndInsertFragmentedTextPartition(fragmented);
121      if (leader_part != nullptr) {
122        leader_part-&gt;ComputeLimits();
123        InsertLeaderPartition(leader_part);
124      }
125    }
126    clean_part_grid_.FindPartitionPartners();
127    clean_part_grid_.RefinePartitionPartners(false);
128  }
129  void TableFinder::LocateTables(ColPartitionGrid *grid,
130                                 ColPartitionSet **all_columns,
131                                 WidthCallback width_cb, const FCOORD &amp;reskew) {
132    InitializePartitions(all_columns);
133  #ifndef GRAPHICS_DISABLED
134    if (textord_show_tables) {
135      ScrollView *table_win = MakeWindow(0, 300, &quot;Column Partitions &amp; Neighbors&quot;);
136      DisplayColPartitions(table_win, &amp;clean_part_grid_, ScrollView::BLUE);
137      DisplayColPartitions(table_win, &amp;leader_and_ruling_grid_,
138                           ScrollView::AQUAMARINE);
139      DisplayColPartitionConnections(table_win, &amp;clean_part_grid_,
140                                     ScrollView::ORANGE);
141      table_win = MakeWindow(100, 300, &quot;Fragmented Text&quot;);
142      DisplayColPartitions(table_win, &amp;fragmented_text_grid_, ScrollView::BLUE);
143    }
144  #endif 
<span onclick='openModal()' class='match'>145    MarkTablePartitions();
146    ColSegment_LIST column_blocks;
147    GetColumnBlocks(all_columns, &amp;column_blocks);
148    SetColumnsType(&amp;column_blocks);
</span>149    MoveColSegmentsToGrid(&amp;column_blocks, &amp;col_seg_grid_);
150    GridMergeColumnBlocks();
151    ColSegment_LIST table_columns;
152    GetTableColumns(&amp;table_columns);
153    ColSegment_LIST table_regions;
154    GetTableRegions(&amp;table_columns, &amp;table_regions);
155  #ifndef GRAPHICS_DISABLED
156    if (textord_tablefind_show_mark) {
157      ScrollView *table_win = MakeWindow(1200, 300, &quot;Table Columns and Regions&quot;);
158      DisplayColSegments(table_win, &amp;table_columns, ScrollView::DARK_TURQUOISE);
159      DisplayColSegments(table_win, &amp;table_regions, ScrollView::YELLOW);
160    }
161  #endif 
162    MoveColSegmentsToGrid(&amp;table_regions, &amp;table_grid_);
163    GridMergeTableRegions();
164    AdjustTableBoundaries();
165    GridMergeTableRegions();
166    if (textord_tablefind_recognize_tables) {
167      DeleteSingleColumnTables();
168  #ifndef GRAPHICS_DISABLED
169      if (textord_show_tables) {
170        ScrollView *table_win = MakeWindow(1200, 300, &quot;Detected Table Locations&quot;);
171        DisplayColPartitions(table_win, &amp;clean_part_grid_, ScrollView::BLUE);
172        DisplayColSegments(table_win, &amp;table_columns, ScrollView::KHAKI);
173        table_grid_.DisplayBoxes(table_win);
174      }
175  #endif 
176      RecognizeTables();
177      GridMergeTableRegions();
178      RecognizeTables();
179  #ifndef GRAPHICS_DISABLED
180      if (textord_show_tables) {
181        ScrollView *table_win = MakeWindow(1400, 600, &quot;Recognized Tables&quot;);
182        DisplayColPartitions(table_win, &amp;clean_part_grid_, ScrollView::BLUE,
183                             ScrollView::BLUE);
184        table_grid_.DisplayBoxes(table_win);
185      }
186  #endif 
187    } else {
188      DeleteSingleColumnTables();
189  #ifndef GRAPHICS_DISABLED
190      if (textord_show_tables) {
191        ScrollView *table_win = MakeWindow(1500, 300, &quot;Detected Tables&quot;);
192        DisplayColPartitions(table_win, &amp;clean_part_grid_, ScrollView::BLUE,
193                             ScrollView::BLUE);
194        table_grid_.DisplayBoxes(table_win);
195      }
196  #endif 
197    }
198    MakeTableBlocks(grid, all_columns, width_cb);
199  }
200  int TableFinder::gridsize() const {
201    return clean_part_grid_.gridsize();
202  }
203  int TableFinder::gridwidth() const {
204    return clean_part_grid_.gridwidth();
205  }
206  int TableFinder::gridheight() const {
207    return clean_part_grid_.gridheight();
208  }
209  const ICOORD &amp;TableFinder::bleft() const {
210    return clean_part_grid_.bleft();
211  }
212  const ICOORD &amp;TableFinder::tright() const {
213    return clean_part_grid_.tright();
214  }
215  void TableFinder::InsertTextPartition(ColPartition *part) {
216    ASSERT_HOST(part != nullptr);
217    if (AllowTextPartition(*part)) {
218      clean_part_grid_.InsertBBox(true, true, part);
219    } else {
220      delete part;
221    }
222  }
223  void TableFinder::InsertFragmentedTextPartition(ColPartition *part) {
224    ASSERT_HOST(part != nullptr);
225    if (AllowTextPartition(*part)) {
226      fragmented_text_grid_.InsertBBox(true, true, part);
227    } else {
228      delete part;
229    }
230  }
231  void TableFinder::InsertLeaderPartition(ColPartition *part) {
232    ASSERT_HOST(part != nullptr);
233    if (!part-&gt;IsEmpty() &amp;&amp; part-&gt;bounding_box().area() &gt; 0) {
234      leader_and_ruling_grid_.InsertBBox(true, true, part);
235    } else {
236      delete part;
237    }
238  }
239  void TableFinder::InsertRulingPartition(ColPartition *part) {
240    leader_and_ruling_grid_.InsertBBox(true, true, part);
241  }
242  void TableFinder::InsertImagePartition(ColPartition *part) {
243    clean_part_grid_.InsertBBox(true, true, part);
244  }
245  void TableFinder::SplitAndInsertFragmentedTextPartition(ColPartition *part) {
246    ASSERT_HOST(part != nullptr);
247    if (part-&gt;boxes()-&gt;empty()) {
248      delete part;
249      return;
250    }
251    ASSERT_HOST(part-&gt;median_width() &gt; 0);
252    const double kThreshold = part-&gt;median_width() * kSplitPartitionSize;
253    ColPartition *right_part = part;
254    bool found_split = true;
255    while (found_split) {
256      found_split = false;
257      BLOBNBOX_C_IT box_it(right_part-&gt;boxes());
258      int previous_right = INT32_MIN;
259      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
260        const TBOX &amp;box = box_it.data()-&gt;bounding_box();
261        if (previous_right != INT32_MIN &amp;&amp;
262            box.left() - previous_right &gt; kThreshold) {
263          int mid_x = (box.left() + previous_right) / 2;
264          ColPartition *left_part = right_part;
265          right_part = left_part-&gt;SplitAt(mid_x);
266          InsertFragmentedTextPartition(left_part);
267          found_split = true;
268          break;
269        }
270        previous_right = std::max(previous_right, static_cast&lt;int&gt;(box.right()));
271      }
272    }
273    InsertFragmentedTextPartition(right_part);
274  }
275  bool TableFinder::AllowTextPartition(const ColPartition &amp;part) const {
276    const double kHeightRequired = global_median_xheight_ * kAllowTextHeight;
277    const double kWidthRequired = global_median_blob_width_ * kAllowTextWidth;
278    const int median_area = global_median_xheight_ * global_median_blob_width_;
279    const double kAreaPerBlobRequired = median_area * kAllowTextArea;
280    return part.median_height() &gt; kHeightRequired &amp;&amp;
281           part.median_width() &gt; kWidthRequired &amp;&amp;
282           part.bounding_box().area() &gt; kAreaPerBlobRequired * part.boxes_count();
283  }
284  bool TableFinder::AllowBlob(const BLOBNBOX &amp;blob) const {
285    const TBOX &amp;box = blob.bounding_box();
286    const double kHeightRequired = global_median_xheight_ * kAllowBlobHeight;
287    const double kWidthRequired = global_median_blob_width_ * kAllowBlobWidth;
288    const int median_area = global_median_xheight_ * global_median_blob_width_;
289    const double kAreaRequired = median_area * kAllowBlobArea;
290    return box.height() &gt; kHeightRequired &amp;&amp; box.width() &gt; kWidthRequired &amp;&amp;
291           box.area() &gt; kAreaRequired;
292  }
293  #ifndef GRAPHICS_DISABLED
294  ScrollView *TableFinder::MakeWindow(int x, int y, const char *window_name) {
295    return clean_part_grid_.MakeWindow(x, y, window_name);
296  }
297  #endif
298  void TableFinder::GetColumnBlocks(ColPartitionSet **all_columns,
299                                    ColSegment_LIST *column_blocks) {
300    for (int i = 0; i &lt; gridheight(); ++i) {
301      ColPartitionSet *columns = all_columns[i];
302      if (columns != nullptr) {
303        ColSegment_LIST new_blocks;
304        columns-&gt;GetColumnBoxes(i * gridsize(), (i + 1) * gridsize(),
305                                &amp;new_blocks);
306        GroupColumnBlocks(&amp;new_blocks, column_blocks);
307      }
308    }
309  }
310  void TableFinder::GroupColumnBlocks(ColSegment_LIST *new_blocks,
311                                      ColSegment_LIST *column_blocks) {
312    ColSegment_IT src_it(new_blocks);
313    ColSegment_IT dest_it(column_blocks);
314    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
315      ColSegment *src_seg = src_it.data();
316      const TBOX &amp;src_box = src_seg-&gt;bounding_box();
317      bool match_found = false;
318      for (dest_it.mark_cycle_pt(); !dest_it.cycled_list(); dest_it.forward()) {
319        ColSegment *dest_seg = dest_it.data();
320        TBOX dest_box = dest_seg-&gt;bounding_box();
321        if (ConsecutiveBoxes(src_box, dest_box)) {
322          dest_seg-&gt;InsertBox(src_box);
323          match_found = true;
324          delete src_it.extract();
325          break;
326        }
327      }
328      if (!match_found) {
329        dest_it.add_after_then_move(src_it.extract());
330      }
331    }
332  }
333  bool TableFinder::ConsecutiveBoxes(const TBOX &amp;b1, const TBOX &amp;b2) {
334    int x_margin = 20;
335    int y_margin = 5;
336    return (abs(b1.left() - b2.left()) &lt; x_margin) &amp;&amp;
337           (abs(b1.right() - b2.right()) &lt; x_margin) &amp;&amp;
338           (abs(b1.top() - b2.bottom()) &lt; y_margin ||
339            abs(b2.top() - b1.bottom()) &lt; y_margin);
340  }
341  void TableFinder::InitializePartitions(ColPartitionSet **all_columns) {
342    FindNeighbors();
343    SetPartitionSpacings(&amp;clean_part_grid_, all_columns);
344    SetGlobalSpacings(&amp;clean_part_grid_);
345  }
346  void TableFinder::SetPartitionSpacings(ColPartitionGrid *grid,
347                                         ColPartitionSet **all_columns) {
348    ColPartitionGridSearch gsearch(grid);
349    gsearch.StartFullSearch();
350    ColPartition *part = nullptr;
351    while ((part = gsearch.NextFullSearch()) != nullptr) {
352      ColPartitionSet *columns = all_columns[gsearch.GridY()];
353      TBOX box = part-&gt;bounding_box();
354      int y = part-&gt;MidY();
355      ColPartition *left_column = columns-&gt;ColumnContaining(box.left(), y);
356      ColPartition *right_column = columns-&gt;ColumnContaining(box.right(), y);
357      if (left_column) {
358        int left_space = std::max(0, box.left() - left_column-&gt;LeftAtY(y));
359        part-&gt;set_space_to_left(left_space);
360      }
361      if (right_column) {
362        int right_space = std::max(0, right_column-&gt;RightAtY(y) - box.right());
363        part-&gt;set_space_to_right(right_space);
364      }
365      ColPartitionGridSearch hsearch(grid);
366      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
367      ColPartition *neighbor = nullptr;
368      while ((neighbor = hsearch.NextSideSearch(true)) != nullptr) {
369        if (neighbor-&gt;type() == PT_PULLOUT_IMAGE ||
370            neighbor-&gt;type() == PT_FLOWING_IMAGE ||
371            neighbor-&gt;type() == PT_HEADING_IMAGE) {
372          int right = neighbor-&gt;bounding_box().right();
373          if (right &lt; box.left()) {
374            int space = std::min(box.left() - right, part-&gt;space_to_left());
375            part-&gt;set_space_to_left(space);
376          }
377        }
378      }
379      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
380      neighbor = nullptr;
381      while ((neighbor = hsearch.NextSideSearch(false)) != nullptr) {
382        if (neighbor-&gt;type() == PT_PULLOUT_IMAGE ||
383            neighbor-&gt;type() == PT_FLOWING_IMAGE ||
384            neighbor-&gt;type() == PT_HEADING_IMAGE) {
385          int left = neighbor-&gt;bounding_box().left();
386          if (left &gt; box.right()) {
387            int space = std::min(left - box.right(), part-&gt;space_to_right());
388            part-&gt;set_space_to_right(space);
389          }
390        }
391      }
392      ColPartition *upper_part = part-&gt;SingletonPartner(true);
393      if (upper_part) {
394        int space =
395            std::max(0, static_cast&lt;int&gt;(upper_part-&gt;bounding_box().bottom() -
396                                         part-&gt;bounding_box().bottom()));
397        part-&gt;set_space_above(space);
398      } else {
399        part-&gt;set_space_above(INT32_MAX);
400      }
401      ColPartition *lower_part = part-&gt;SingletonPartner(false);
402      if (lower_part) {
403        int space =
404            std::max(0, static_cast&lt;int&gt;(part-&gt;bounding_box().bottom() -
405                                         lower_part-&gt;bounding_box().bottom()));
406        part-&gt;set_space_below(space);
407      } else {
408        part-&gt;set_space_below(INT32_MAX);
409      }
410    }
411  }
412  void TableFinder::SetVerticalSpacing(ColPartition *part) {
413    TBOX box = part-&gt;bounding_box();
414    int top_range =
415        std::min(box.top() + kMaxVerticalSpacing, static_cast&lt;int&gt;(tright().y()));
416    int bottom_range = std::max(box.bottom() - kMaxVerticalSpacing,
417                                static_cast&lt;int&gt;(bleft().y()));
418    box.set_top(top_range);
419    box.set_bottom(bottom_range);
420    TBOX part_box = part-&gt;bounding_box();
421    GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; rectsearch(
422        &amp;clean_part_grid_);
423    rectsearch.StartRectSearch(box);
424    ColPartition *neighbor;
425    int min_space_above = kMaxVerticalSpacing;
426    int min_space_below = kMaxVerticalSpacing;
427    ColPartition *above_neighbor = nullptr;
428    ColPartition *below_neighbor = nullptr;
429    while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
430      if (neighbor == part) {
431        continue;
432      }
433      TBOX neighbor_box = neighbor-&gt;bounding_box();
434      if (neighbor_box.major_x_overlap(part_box)) {
435        int gap = abs(part-&gt;median_bottom() - neighbor-&gt;median_bottom());
436        if (neighbor_box.top() &lt; part_box.bottom() &amp;&amp; gap &lt; min_space_below) {
437          min_space_below = gap;
438          below_neighbor = neighbor;
439        } 
440        else if (part_box.top() &lt; neighbor_box.bottom() &amp;&amp;
441                 gap &lt; min_space_above) {
442          min_space_above = gap;
443          above_neighbor = neighbor;
444        }
445      }
446    }
447    part-&gt;set_space_above(min_space_above);
448    part-&gt;set_space_below(min_space_below);
449    part-&gt;set_nearest_neighbor_above(above_neighbor);
450    part-&gt;set_nearest_neighbor_below(below_neighbor);
451  }
452  void TableFinder::SetGlobalSpacings(ColPartitionGrid *grid) {
453    STATS xheight_stats(0, kMaxVerticalSpacing);
454    STATS width_stats(0, kMaxBlobWidth);
455    STATS ledding_stats(0, kMaxVerticalSpacing);
456    ColPartitionGridSearch gsearch(grid);
457    gsearch.SetUniqueMode(true);
458    gsearch.StartFullSearch();
459    ColPartition *part = nullptr;
460    while ((part = gsearch.NextFullSearch()) != nullptr) {
461      if (part-&gt;IsTextType()) {
462        BLOBNBOX_C_IT it(part-&gt;boxes());
463        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
464          xheight_stats.add(it.data()-&gt;bounding_box().height(), 1);
465          width_stats.add(it.data()-&gt;bounding_box().width(), 1);
466        }
467        ledding_stats.add(part-&gt;space_above(), 1);
468        ledding_stats.add(part-&gt;space_below(), 1);
469      }
470    }
471    set_global_median_xheight(static_cast&lt;int&gt;(xheight_stats.median() + 0.5));
472    set_global_median_blob_width(static_cast&lt;int&gt;(width_stats.median() + 0.5));
473    set_global_median_ledding(static_cast&lt;int&gt;(ledding_stats.median() + 0.5));
474  #ifndef GRAPHICS_DISABLED
475    if (textord_tablefind_show_stats) {
476      const char *kWindowName = &quot;X-height (R), X-width (G), and ledding (B)&quot;;
477      ScrollView *stats_win = MakeWindow(500, 10, kWindowName);
478      xheight_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::RED);
479      width_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::GREEN);
480      ledding_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::BLUE);
481    }
482  #endif 
483  }
484  void TableFinder::set_global_median_xheight(int xheight) {
485    global_median_xheight_ = xheight;
486  }
487  void TableFinder::set_global_median_blob_width(int width) {
488    global_median_blob_width_ = width;
489  }
490  void TableFinder::set_global_median_ledding(int ledding) {
491    global_median_ledding_ = ledding;
492  }
493  void TableFinder::FindNeighbors() {
494    ColPartitionGridSearch gsearch(&amp;clean_part_grid_);
495    gsearch.StartFullSearch();
496    ColPartition *part = nullptr;
497    while ((part = gsearch.NextFullSearch()) != nullptr) {
498      ColPartition *upper = part-&gt;SingletonPartner(true);
499      if (upper) {
500        part-&gt;set_nearest_neighbor_above(upper);
501      }
502      ColPartition *lower = part-&gt;SingletonPartner(false);
503      if (lower) {
504        part-&gt;set_nearest_neighbor_below(lower);
505      }
506    }
507  }
508  void TableFinder::MarkTablePartitions() {
509    MarkPartitionsUsingLocalInformation();
510  #ifndef GRAPHICS_DISABLED
511    if (textord_tablefind_show_mark) {
512      ScrollView *table_win = MakeWindow(300, 300, &quot;Initial Table Partitions&quot;);
513      DisplayColPartitions(table_win, &amp;clean_part_grid_, ScrollView::BLUE);
514      DisplayColPartitions(table_win, &amp;leader_and_ruling_grid_,
515                           ScrollView::AQUAMARINE);
516    }
517  #endif
518    FilterFalseAlarms();
519  #ifndef GRAPHICS_DISABLED
520    if (textord_tablefind_show_mark) {
521      ScrollView *table_win = MakeWindow(600, 300, &quot;Filtered Table Partitions&quot;);
522      DisplayColPartitions(table_win, &amp;clean_part_grid_, ScrollView::BLUE);
523      DisplayColPartitions(table_win, &amp;leader_and_ruling_grid_,
524                           ScrollView::AQUAMARINE);
525    }
526  #endif
527    SmoothTablePartitionRuns();
528  #ifndef GRAPHICS_DISABLED
529    if (textord_tablefind_show_mark) {
530      ScrollView *table_win = MakeWindow(900, 300, &quot;Smoothed Table Partitions&quot;);
531      DisplayColPartitions(table_win, &amp;clean_part_grid_, ScrollView::BLUE);
532      DisplayColPartitions(table_win, &amp;leader_and_ruling_grid_,
533                           ScrollView::AQUAMARINE);
534    }
535  #endif
536    FilterFalseAlarms();
537  #ifndef GRAPHICS_DISABLED
538    if (textord_tablefind_show_mark || textord_show_tables) {
539      ScrollView *table_win = MakeWindow(900, 300, &quot;Final Table Partitions&quot;);
540      DisplayColPartitions(table_win, &amp;clean_part_grid_, ScrollView::BLUE);
541      DisplayColPartitions(table_win, &amp;leader_and_ruling_grid_,
542                           ScrollView::AQUAMARINE);
543    }
544  #endif
545  }
546  void TableFinder::MarkPartitionsUsingLocalInformation() {
547    GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; gsearch(
548        &amp;clean_part_grid_);
549    gsearch.StartFullSearch();
550    ColPartition *part = nullptr;
551    while ((part = gsearch.NextFullSearch()) != nullptr) {
552      if (!part-&gt;IsTextType()) { 
553        continue;
554      }
555      if (part-&gt;median_height() &gt; kMaxTableCellXheight * global_median_xheight_) {
556        continue;
557      }
558      if (HasWideOrNoInterWordGap(part) || HasLeaderAdjacent(*part)) {
559        part-&gt;set_table_type();
560      }
561    }
562  }
563  bool TableFinder::HasWideOrNoInterWordGap(ColPartition *part) const {
564    ASSERT_HOST(part-&gt;IsTextType());
565    BLOBNBOX_CLIST *part_boxes = part-&gt;boxes();
566    BLOBNBOX_C_IT it(part_boxes);
567    if (part-&gt;bounding_box().width() &lt;
568            kMinBoxesInTextPartition * part-&gt;median_height() &amp;&amp;
569        part_boxes-&gt;length() &lt; kMinBoxesInTextPartition) {
570      return true;
571    }
572    int current_x0 = -1;
573    int current_x1 = -1;
574    int previous_x1 = -1;
575    int largest_partition_gap_found = -1;
576    const double max_gap = kMaxGapInTextPartition * part-&gt;median_height();
577    const double min_gap = kMinMaxGapInTextPartition * part-&gt;median_height();
578    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
579      BLOBNBOX *blob = it.data();
580      current_x0 = blob-&gt;bounding_box().left();
581      current_x1 = blob-&gt;bounding_box().right();
582      if (previous_x1 != -1) {
583        int gap = current_x0 - previous_x1;
584        if (gap &lt; 0) {
585          if (-gap &lt; part-&gt;median_height() * kMaxBlobOverlapFactor) {
586            previous_x1 = std::max(previous_x1, current_x1);
587            continue;
588          }
589          else {
590          }
591        }
592        if (gap &gt; max_gap) {
593          return true;
594        }
595        if (gap &gt; largest_partition_gap_found) {
596          largest_partition_gap_found = gap;
597        }
598      }
599      previous_x1 = current_x1;
600    }
601    if (part-&gt;bounding_box().width() &gt;
602            kMaxBoxesInDataPartition * part-&gt;median_height() ||
603        part_boxes-&gt;length() &gt; kMaxBoxesInDataPartition) {
604      return false;
605    }
606    if (largest_partition_gap_found == -1) {
607      return true;
608    }
609    return largest_partition_gap_found &lt; min_gap;
610  }
611  bool TableFinder::HasLeaderAdjacent(const ColPartition &amp;part) {
612    if (part.flow() == BTFT_LEADER) {
613      return true;
614    }
615    const TBOX &amp;box = part.bounding_box();
616    const int search_size = kAdjacentLeaderSearchPadding * global_median_xheight_;
617    const int top = box.top() + search_size;
618    const int bottom = box.bottom() - search_size;
619    ColPartitionGridSearch hsearch(&amp;leader_and_ruling_grid_);
620    for (int direction = 0; direction &lt; 2; ++direction) {
621      bool right_to_left = (direction == 0);
622      int x = right_to_left ? box.right() : box.left();
623      hsearch.StartSideSearch(x, bottom, top);
624      ColPartition *leader = nullptr;
625      while ((leader = hsearch.NextSideSearch(right_to_left)) != nullptr) {
626        if (leader-&gt;flow() != BTFT_LEADER) {
627          continue;
628        }
629        ASSERT_HOST(&amp;part != leader);
630        if (!part.IsInSameColumnAs(*leader)) {
631          break;
632        }
633        if (!leader-&gt;VSignificantCoreOverlap(part)) {
634          continue;
635        }
636        return true;
637      }
638    }
639    return false;
640  }
641  void TableFinder::FilterFalseAlarms() {
642    FilterParagraphEndings();
643    FilterHeaderAndFooter();
644  }
645  void TableFinder::FilterParagraphEndings() {
646    ColPartitionGridSearch gsearch(&amp;clean_part_grid_);
647    gsearch.StartFullSearch();
648    ColPartition *part = nullptr;
649    while ((part = gsearch.NextFullSearch()) != nullptr) {
650      if (part-&gt;type() != PT_TABLE) {
651        continue; 
652      }
653      ColPartition *upper_part = part-&gt;nearest_neighbor_above();
654      if (!upper_part) {
655        continue;
656      }
657      if (upper_part-&gt;type() != PT_FLOWING_TEXT) {
658        continue;
659      }
660      if (upper_part-&gt;bounding_box().width() &lt; 2 * part-&gt;bounding_box().width()) {
661        continue;
662      }
663      int mid = (part-&gt;bounding_box().left() + part-&gt;bounding_box().right()) / 2;
664      int upper_mid = (upper_part-&gt;bounding_box().left() +
665                       upper_part-&gt;bounding_box().right()) /
666                      2;
667      int current_spacing = 0; 
668      int upper_spacing = 0;   
669      if (left_to_right_language_) {
670        int left = std::min(part-&gt;bounding_box().left(),
671                            upper_part-&gt;bounding_box().left());
672        current_spacing = mid - left;
673        upper_spacing = upper_mid - left;
674      } else {
675        int right = std::max(part-&gt;bounding_box().right(),
676                             upper_part-&gt;bounding_box().right());
677        current_spacing = right - mid;
678        upper_spacing = right - upper_mid;
679      }
680      if (current_spacing * kParagraphEndingPreviousLineRatio &gt; upper_spacing) {
681        continue;
682      }
683      if (!part-&gt;MatchingSizes(*upper_part) ||
684          !part-&gt;MatchingStrokeWidth(*upper_part, kStrokeWidthFractionalTolerance,
685                                     kStrokeWidthConstantTolerance)) {
686        continue;
687      }
688      if (part-&gt;space_to_left() &gt;
689          kMaxParagraphEndingLeftSpaceMultiple * part-&gt;median_height()) {
690        continue;
691      }
692      if (upper_part-&gt;bounding_box().width() &lt;
693          kMinParagraphEndingTextToWhitespaceRatio *
694              upper_part-&gt;space_to_right()) {
695        continue;
696      }
697      if (part-&gt;space_above() &gt;= part-&gt;space_below() ||
698          part-&gt;space_above() &gt; 2 * global_median_ledding_) {
699        continue;
700      }
701      part-&gt;clear_table_type();
702    }
703  }
704  void TableFinder::FilterHeaderAndFooter() {
705    ColPartition *header = nullptr;
706    ColPartition *footer = nullptr;
707    int max_top = INT32_MIN;
708    int min_bottom = INT32_MAX;
709    ColPartitionGridSearch gsearch(&amp;clean_part_grid_);
710    gsearch.StartFullSearch();
711    ColPartition *part = nullptr;
712    while ((part = gsearch.NextFullSearch()) != nullptr) {
713      if (!part-&gt;IsTextType()) {
714        continue; 
715      }
716      int top = part-&gt;bounding_box().top();
717      int bottom = part-&gt;bounding_box().bottom();
718      if (top &gt; max_top) {
719        max_top = top;
720        header = part;
721      }
722      if (bottom &lt; min_bottom) {
723        min_bottom = bottom;
724        footer = part;
725      }
726    }
727    if (header) {
728      header-&gt;clear_table_type();
729    }
730    if (footer) {
731      footer-&gt;clear_table_type();
732    }
733  }
734  void TableFinder::SmoothTablePartitionRuns() {
735    ColPartitionGridSearch gsearch(&amp;clean_part_grid_);
736    gsearch.StartFullSearch();
737    ColPartition *part = nullptr;
738    while ((part = gsearch.NextFullSearch()) != nullptr) {
739      if (part-&gt;type() &gt;= PT_TABLE || part-&gt;type() == PT_UNKNOWN) {
740        continue; 
741      }
742      ColPartition *upper_part = part-&gt;nearest_neighbor_above();
743      ColPartition *lower_part = part-&gt;nearest_neighbor_below();
744      if (!upper_part || !lower_part) {
745        continue;
746      }
747      if (upper_part-&gt;type() == PT_TABLE &amp;&amp; lower_part-&gt;type() == PT_TABLE) {
748        part-&gt;set_table_type();
749      }
750    }
751    gsearch.StartFullSearch();
752    part = nullptr;
753    while ((part = gsearch.NextFullSearch()) != nullptr) {
754      if (part-&gt;type() != PT_TABLE) {
755        continue; 
756      }
757      ColPartition *upper_part = part-&gt;nearest_neighbor_above();
758      ColPartition *lower_part = part-&gt;nearest_neighbor_below();
759      if ((upper_part &amp;&amp; upper_part-&gt;type() != PT_TABLE) &amp;&amp;
760          (lower_part &amp;&amp; lower_part-&gt;type() != PT_TABLE)) {
761        part-&gt;clear_table_type();
762      }
763    }
764  }
765  void TableFinder::SetColumnsType(ColSegment_LIST *column_blocks) {
766    ColSegment_IT it(column_blocks);
767    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
768      ColSegment *seg = it.data();
769      TBOX box = seg-&gt;bounding_box();
770      int num_table_cells = 0;
771      int num_text_cells = 0;
772      GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; rsearch(
773          &amp;clean_part_grid_);
774      rsearch.SetUniqueMode(true);
775      rsearch.StartRectSearch(box);
776      ColPartition *part = nullptr;
777      while ((part = rsearch.NextRectSearch()) != nullptr) {
778        if (part-&gt;type() == PT_TABLE) {
779          num_table_cells++;
780        } else if (part-&gt;type() == PT_FLOWING_TEXT) {
781          num_text_cells++;
782        }
783      }
784      if (!num_table_cells &amp;&amp; !num_text_cells) {
785        delete it.extract();
786      } else {
787        seg-&gt;set_num_table_cells(num_table_cells);
788        seg-&gt;set_num_text_cells(num_text_cells);
789        seg-&gt;set_type();
790      }
791    }
792  }
793  void TableFinder::MoveColSegmentsToGrid(ColSegment_LIST *segments,
794                                          ColSegmentGrid *col_seg_grid) {
795    ColSegment_IT it(segments);
796    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
797      ColSegment *seg = it.extract();
798      col_seg_grid-&gt;InsertBBox(true, true, seg);
799    }
800  }
801  void TableFinder::GridMergeColumnBlocks() {
802    int margin = gridsize();
803    GridSearch&lt;ColSegment, ColSegment_CLIST, ColSegment_C_IT&gt; gsearch(
804        &amp;col_seg_grid_);
805    gsearch.StartFullSearch();
806    ColSegment *seg;
807    while ((seg = gsearch.NextFullSearch()) != nullptr) {
808      if (seg-&gt;type() != COL_TEXT) {
809        continue; 
810      }
811      bool neighbor_found = false;
812      bool modified = false; 
813      do {
814        TBOX box = seg-&gt;bounding_box();
815        int top_range =
816            std::min(box.top() + margin, static_cast&lt;int&gt;(tright().y()));
817        int bottom_range =
818            std::max(box.bottom() - margin, static_cast&lt;int&gt;(bleft().y()));
819        box.set_top(top_range);
820        box.set_bottom(bottom_range);
821        neighbor_found = false;
822        GridSearch&lt;ColSegment, ColSegment_CLIST, ColSegment_C_IT&gt; rectsearch(
823            &amp;col_seg_grid_);
824        rectsearch.StartRectSearch(box);
825        ColSegment *neighbor = nullptr;
826        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
827          if (neighbor == seg) {
828            continue;
829          }
830          const TBOX &amp;neighbor_box = neighbor-&gt;bounding_box();
831          if (neighbor_box.overlap_fraction(box) &gt;= 0.9) {
832            seg-&gt;InsertBox(neighbor_box);
833            modified = true;
834            rectsearch.RemoveBBox();
835            gsearch.RepositionIterator();
836            delete neighbor;
837            continue;
838          }
839          if (neighbor-&gt;type() != COL_TABLE) {
840            continue;
841          }
842          if (neighbor_box.major_x_overlap(box) &amp;&amp; !box.contains(neighbor_box)) {
843            seg-&gt;InsertBox(neighbor_box);
844            neighbor_found = true;
845            modified = true;
846            rectsearch.RemoveBBox();
847            gsearch.RepositionIterator();
848            delete neighbor;
849          }
850        }
851      } while (neighbor_found);
852      if (modified) {
853        gsearch.RemoveBBox();
854        col_seg_grid_.InsertBBox(true, true, seg);
855        gsearch.RepositionIterator();
856      }
857    }
858  }
859  void TableFinder::GetTableColumns(ColSegment_LIST *table_columns) {
860    ColSegment_IT it(table_columns);
861    GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; gsearch(
862        &amp;clean_part_grid_);
863    gsearch.StartFullSearch();
864    ColPartition *part;
865    while ((part = gsearch.NextFullSearch()) != nullptr) {
866      if (part-&gt;inside_table_column() || part-&gt;type() != PT_TABLE) {
867        continue; 
868      }
869      const TBOX &amp;box = part-&gt;bounding_box();
870      auto *col = new ColSegment();
871      col-&gt;InsertBox(box);
872      part-&gt;set_inside_table_column(true);
873      GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; vsearch(
874          &amp;clean_part_grid_);
875      vsearch.StartVerticalSearch(box.left(), box.right(), box.bottom());
876      ColPartition *neighbor = nullptr;
877      bool found_neighbours = false;
878      while ((neighbor = vsearch.NextVerticalSearch(true)) != nullptr) {
879        if (neighbor-&gt;inside_table_column()) {
880          continue;
881        }
882        if (neighbor-&gt;IsHorizontalLine()) {
883          continue;
884        }
885        if (neighbor-&gt;type() != PT_TABLE) {
886          break;
887        }
888        const TBOX &amp;neighbor_box = neighbor-&gt;bounding_box();
889        col-&gt;InsertBox(neighbor_box);
890        neighbor-&gt;set_inside_table_column(true);
891        found_neighbours = true;
892      }
893      if (found_neighbours) {
894        it.add_after_then_move(col);
895      } else {
896        part-&gt;set_inside_table_column(false);
897        delete col;
898      }
899    }
900  }
901  void TableFinder::GetTableRegions(ColSegment_LIST *table_columns,
902                                    ColSegment_LIST *table_regions) {
903    ColSegment_IT cit(table_columns);
904    ColSegment_IT rit(table_regions);
905    GridSearch&lt;ColSegment, ColSegment_CLIST, ColSegment_C_IT&gt; gsearch(
906        &amp;col_seg_grid_);
907    gsearch.StartFullSearch();
908    ColSegment *part;
909    int page_height = tright().y() - bleft().y();
910    ASSERT_HOST(page_height &gt; 0);
911    bool *table_region = new bool[page_height];
912    while ((part = gsearch.NextFullSearch()) != nullptr) {
913      const TBOX &amp;part_box = part-&gt;bounding_box();
914      for (int i = 0; i &lt; page_height; i++) {
915        table_region[i] = false;
916      }
917      cit.move_to_first();
918      for (cit.mark_cycle_pt(); !cit.cycled_list(); cit.forward()) {
919        TBOX col_box = cit.data()-&gt;bounding_box();
920        TBOX intersection_box = col_box.intersection(part_box);
921        for (int i = intersection_box.bottom(); i &lt; intersection_box.top(); i++) {
922          table_region[i - bleft().y()] = true;
923        }
924      }
925      TBOX current_table_box;
926      current_table_box.set_left(part_box.left());
927      current_table_box.set_right(part_box.right());
928      for (int i = 1; i &lt; page_height; i++) {
929        if (!table_region[i - 1] &amp;&amp; table_region[i]) {
930          current_table_box.set_bottom(i + bleft().y());
931        }
932        if (table_region[i - 1] &amp;&amp; !table_region[i]) {
933          current_table_box.set_top(i + bleft().y());
934          if (!current_table_box.null_box()) {
935            auto *seg = new ColSegment();
936            seg-&gt;InsertBox(current_table_box);
937            rit.add_after_then_move(seg);
938          }
939        }
940      }
941    }
942    delete[] table_region;
943  }
944  void TableFinder::GridMergeTableRegions() {
945    GridSearch&lt;ColSegment, ColSegment_CLIST, ColSegment_C_IT&gt; gsearch(
946        &amp;table_grid_);
947    gsearch.StartFullSearch();
948    ColSegment *seg = nullptr;
949    while ((seg = gsearch.NextFullSearch()) != nullptr) {
950      bool neighbor_found = false;
951      bool modified = false; 
952      do {
953        const TBOX &amp;box = seg-&gt;bounding_box();
954        TBOX search_region(box);
955        search_region.set_left(bleft().x());
956        search_region.set_right(tright().x());
957        neighbor_found = false;
958        GridSearch&lt;ColSegment, ColSegment_CLIST, ColSegment_C_IT&gt; rectsearch(
959            &amp;table_grid_);
960        rectsearch.StartRectSearch(search_region);
961        ColSegment *neighbor = nullptr;
962        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
963          if (neighbor == seg) {
964            continue;
965          }
966          const TBOX &amp;neighbor_box = neighbor-&gt;bounding_box();
967          if (neighbor_box.overlap_fraction(box) &gt;= 0.9) {
968            seg-&gt;InsertBox(neighbor_box);
969            rectsearch.RemoveBBox();
970            gsearch.RepositionIterator();
971            delete neighbor;
972            modified = true;
973            continue;
974          }
975          if (BelongToOneTable(box, neighbor_box)) {
976            seg-&gt;InsertBox(neighbor_box);
977            neighbor_found = true;
978            modified = true;
979            rectsearch.RemoveBBox();
980            gsearch.RepositionIterator();
981            delete neighbor;
982          }
983        }
984      } while (neighbor_found);
985      if (modified) {
986        gsearch.RemoveBBox();
987        table_grid_.InsertBBox(true, true, seg);
988        gsearch.RepositionIterator();
989      }
990    }
991  }
992  bool TableFinder::BelongToOneTable(const TBOX &amp;box1, const TBOX &amp;box2) {
993    if (box1.overlap(box2)) {
994      return true;
995    }
996    TBOX bbox = box1.bounding_union(box2);
997    GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; rectsearch(
998        &amp;clean_part_grid_);
999    rectsearch.StartRectSearch(bbox);
1000    ColPartition *part = nullptr;
1001    while ((part = rectsearch.NextRectSearch()) != nullptr) {
1002      const TBOX &amp;part_box = part-&gt;bounding_box();
1003      if (part_box.overlap(box1) &amp;&amp; part_box.overlap(box2) &amp;&amp;
1004          !part-&gt;IsImageType()) {
1005        return true;
1006      }
1007    }
1008    return false;
1009  }
1010  void TableFinder::AdjustTableBoundaries() {
1011    ColSegment_CLIST adjusted_tables;
1012    ColSegment_C_IT it(&amp;adjusted_tables);
1013    ColSegmentGridSearch gsearch(&amp;table_grid_);
1014    gsearch.StartFullSearch();
1015    ColSegment *table = nullptr;
1016    while ((table = gsearch.NextFullSearch()) != nullptr) {
1017      const TBOX &amp;table_box = table-&gt;bounding_box();
1018      TBOX grown_box = table_box;
1019      GrowTableBox(table_box, &amp;grown_box);
1020      if (!grown_box.null_box()) {
1021        auto *col = new ColSegment();
1022        col-&gt;InsertBox(grown_box);
1023        it.add_after_then_move(col);
1024      }
1025      gsearch.RemoveBBox();
1026      delete table;
1027    }
1028    table_grid_.Clear();
1029    it.move_to_first();
1030    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1031      ColSegment *seg = it.extract();
1032      table_grid_.InsertBBox(true, true, seg);
1033    }
1034  }
1035  void TableFinder::GrowTableBox(const TBOX &amp;table_box, TBOX *result_box) {
1036    TBOX search_box = table_box;
1037    GrowTableToIncludePartials(table_box, search_box, result_box);
1038    GrowTableToIncludeLines(table_box, search_box, result_box);
1039    IncludeLeftOutColumnHeaders(result_box);
1040  }
1041  void TableFinder::GrowTableToIncludePartials(const TBOX &amp;table_box,
1042                                               const TBOX &amp;search_range,
1043                                               TBOX *result_box) {
1044    for (int i = 0; i &lt; 2; ++i) {
1045      ColPartitionGrid *grid =
1046          (i == 0) ? &amp;fragmented_text_grid_ : &amp;leader_and_ruling_grid_;
1047      ColPartitionGridSearch rectsearch(grid);
1048      rectsearch.StartRectSearch(search_range);
1049      ColPartition *part = nullptr;
1050      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1051        if (part-&gt;IsImageType()) {
1052          continue;
1053        }
1054        const TBOX &amp;part_box = part-&gt;bounding_box();
1055        if (part_box.overlap_fraction(table_box) &gt; kMinOverlapWithTable) {
1056          *result_box = result_box-&gt;bounding_union(part_box);
1057          continue;
1058        }
1059      }
1060    }
1061  }
1062  void TableFinder::GrowTableToIncludeLines(const TBOX &amp;table_box,
1063                                            const TBOX &amp;search_range,
1064                                            TBOX *result_box) {
1065    ColPartitionGridSearch rsearch(&amp;leader_and_ruling_grid_);
1066    rsearch.SetUniqueMode(true);
1067    rsearch.StartRectSearch(search_range);
1068    ColPartition *part = nullptr;
1069    while ((part = rsearch.NextRectSearch()) != nullptr) {
1070      if (!part-&gt;IsLineType()) {
1071        continue;
1072      }
1073      const TBOX &amp;part_box = part-&gt;bounding_box();
1074      if (result_box-&gt;contains(part_box)) {
1075        continue;
1076      }
1077      if (HLineBelongsToTable(*part, table_box)) {
1078        *result_box = result_box-&gt;bounding_union(part_box);
1079      }
1080    }
1081  }
1082  bool TableFinder::HLineBelongsToTable(const ColPartition &amp;part,
1083                                        const TBOX &amp;table_box) {
1084    if (!part.IsHorizontalLine()) {
1085      return false;
1086    }
1087    const TBOX &amp;part_box = part.bounding_box();
1088    if (!part_box.major_x_overlap(table_box)) {
1089      return false;
1090    }
1091    const TBOX bbox = part_box.bounding_union(table_box);
1092    int num_extra_partitions = 0;
1093    int extra_space_to_right = 0;
1094    int extra_space_to_left = 0;
1095    for (int i = 0; i &lt; 2; ++i) {
1096      ColPartitionGrid *grid =
1097          (i == 0) ? &amp;clean_part_grid_ : &amp;leader_and_ruling_grid_;
1098      ColPartitionGridSearch rectsearch(grid);
1099      rectsearch.SetUniqueMode(true);
1100      rectsearch.StartRectSearch(bbox);
1101      ColPartition *extra_part = nullptr;
1102      while ((extra_part = rectsearch.NextRectSearch()) != nullptr) {
1103        const TBOX &amp;extra_part_box = extra_part-&gt;bounding_box();
1104        if (extra_part_box.overlap_fraction(table_box) &gt; kMinOverlapWithTable) {
1105          continue;
1106        }
1107        if (extra_part-&gt;IsImageType()) {
1108          continue;
1109        }
1110        num_extra_partitions++;
1111        if (extra_part-&gt;type() == PT_TABLE || extra_part-&gt;IsLineType()) {
1112          extra_space_to_right++;
1113          extra_space_to_left++;
1114          continue;
1115        }
1116        int space_threshold = kSideSpaceMargin * part.median_height();
1117        if (extra_part-&gt;space_to_right() &gt; space_threshold) {
1118          extra_space_to_right++;
1119        }
1120        if (extra_part-&gt;space_to_left() &gt; space_threshold) {
1121          extra_space_to_left++;
1122        }
1123      }
1124    }
1125    return (extra_space_to_right &gt; num_extra_partitions / 2) ||
1126           (extra_space_to_left &gt; num_extra_partitions / 2);
1127  }
1128  void TableFinder::IncludeLeftOutColumnHeaders(TBOX *table_box) {
1129    ColPartitionGridSearch vsearch(&amp;clean_part_grid_);
1130    vsearch.StartVerticalSearch(table_box-&gt;left(), table_box-&gt;right(),
1131                                table_box-&gt;top());
1132    ColPartition *neighbor = nullptr;
1133    ColPartition *previous_neighbor = nullptr;
1134    while ((neighbor = vsearch.NextVerticalSearch(false)) != nullptr) {
1135      const int max_distance =
1136          kMaxColumnHeaderDistance * neighbor-&gt;median_height();
1137      int table_top = table_box-&gt;top();
1138      const TBOX &amp;box = neighbor-&gt;bounding_box();
1139      if (box.bottom() - table_top &gt; max_distance) {
1140        break;
1141      }
1142      if (neighbor-&gt;type() == PT_TABLE || neighbor-&gt;IsLineType()) {
1143        table_box-&gt;set_top(box.top());
1144        previous_neighbor = nullptr;
1145        continue;
1146      }
1147      if (previous_neighbor == nullptr) {
1148        previous_neighbor = neighbor;
1149      } else {
1150        const TBOX &amp;previous_box = previous_neighbor-&gt;bounding_box();
1151        if (!box.major_y_overlap(previous_box)) {
1152          break;
1153        }
1154      }
1155    }
1156  }
1157  void TableFinder::DeleteSingleColumnTables() {
1158    int page_width = tright().x() - bleft().x();
1159    ASSERT_HOST(page_width &gt; 0);
1160    int *table_xprojection = new int[page_width];
1161    GridSearch&lt;ColSegment, ColSegment_CLIST, ColSegment_C_IT&gt; table_search(
1162        &amp;table_grid_);
1163    table_search.StartFullSearch();
1164    ColSegment *table;
1165    while ((table = table_search.NextFullSearch()) != nullptr) {
1166      TBOX table_box = table-&gt;bounding_box();
1167      for (int i = 0; i &lt; page_width; i++) {
1168        table_xprojection[i] = 0;
1169      }
1170      GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; rectsearch(
1171          &amp;clean_part_grid_);
1172      rectsearch.SetUniqueMode(true);
1173      rectsearch.StartRectSearch(table_box);
1174      ColPartition *part;
1175      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1176        if (!part-&gt;IsTextType()) {
1177          continue; 
1178        }
1179        if (part-&gt;flow() == BTFT_LEADER) {
1180          continue; 
1181        }
1182        TBOX part_box = part-&gt;bounding_box();
1183        if (part_box.overlap_fraction(table_box) &lt; kMinOverlapWithTable) {
1184          continue;
1185        }
1186        BLOBNBOX_CLIST *part_boxes = part-&gt;boxes();
1187        BLOBNBOX_C_IT pit(part_boxes);
1188        int next_position_to_write = 0;
1189        for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
1190          BLOBNBOX *pblob = pit.data();
1191          int xstart = pblob-&gt;bounding_box().left();
1192          int xend = pblob-&gt;bounding_box().right();
1193          xstart = std::max(xstart, next_position_to_write);
1194          for (int i = xstart; i &lt; xend; i++) {
1195            table_xprojection[i - bleft().x()]++;
1196          }
1197          next_position_to_write = xend;
1198        }
1199      }
1200      if (!GapInXProjection(table_xprojection, page_width)) {
1201        table_search.RemoveBBox();
1202        delete table;
1203      }
1204    }
1205    delete[] table_xprojection;
1206  }
1207  bool TableFinder::GapInXProjection(int *xprojection, int length) {
1208    int peak_value = 0;
1209    for (int i = 0; i &lt; length; i++) {
1210      if (xprojection[i] &gt; peak_value) {
1211        peak_value = xprojection[i];
1212      }
1213    }
1214    if (peak_value &lt; kMinRowsInTable) {
1215      return false;
1216    }
1217    double projection_threshold = kSmallTableProjectionThreshold * peak_value;
1218    if (peak_value &gt;= kLargeTableRowCount) {
1219      projection_threshold = kLargeTableProjectionThreshold * peak_value;
1220    }
1221    for (int i = 0; i &lt; length; i++) {
1222      xprojection[i] = (xprojection[i] &gt;= projection_threshold) ? 1 : 0;
1223    }
1224    int largest_gap = 0;
1225    int run_start = -1;
1226    for (int i = 1; i &lt; length; i++) {
1227      if (xprojection[i - 1] &amp;&amp; !xprojection[i]) {
1228        run_start = i;
1229      }
1230      if (run_start != -1 &amp;&amp; !xprojection[i - 1] &amp;&amp; xprojection[i]) {
1231        int gap = i - run_start;
1232        if (gap &gt; largest_gap) {
1233          largest_gap = gap;
1234        }
1235        run_start = -1;
1236      }
1237    }
1238    return largest_gap &gt; kMaxXProjectionGapFactor * global_median_xheight_;
1239  }
1240  void TableFinder::RecognizeTables() {
1241  #ifndef GRAPHICS_DISABLED
1242    ScrollView *table_win = nullptr;
1243    if (textord_show_tables) {
1244      table_win = MakeWindow(0, 0, &quot;Table Structure&quot;);
1245      DisplayColPartitions(table_win, &amp;fragmented_text_grid_, ScrollView::BLUE,
1246                           ScrollView::LIGHT_BLUE);
1247    }
1248  #endif
1249    TableRecognizer recognizer;
1250    recognizer.Init();
1251    recognizer.set_line_grid(&amp;leader_and_ruling_grid_);
1252    recognizer.set_text_grid(&amp;fragmented_text_grid_);
1253    recognizer.set_max_text_height(global_median_xheight_ * 2.0);
1254    recognizer.set_min_height(1.5 * gridheight());
1255    ColSegment_CLIST good_tables;
1256    ColSegment_C_IT good_it(&amp;good_tables);
1257    ColSegmentGridSearch gsearch(&amp;table_grid_);
1258    gsearch.StartFullSearch();
1259    ColSegment *found_table = nullptr;
1260    while ((found_table = gsearch.NextFullSearch()) != nullptr) {
1261      gsearch.RemoveBBox();
1262      const TBOX &amp;found_box = found_table-&gt;bounding_box();
1263      StructuredTable *table_structure = recognizer.RecognizeTable(found_box);
1264      if (table_structure != nullptr) {
1265  #ifndef GRAPHICS_DISABLED
1266        if (textord_show_tables) {
1267          table_structure-&gt;Display(table_win, ScrollView::LIME_GREEN);
1268        }
1269  #endif
1270        found_table-&gt;set_bounding_box(table_structure-&gt;bounding_box());
1271        delete table_structure;
1272        good_it.add_after_then_move(found_table);
1273      } else {
1274        delete found_table;
1275      }
1276    }
1277    for (good_it.mark_cycle_pt(); !good_it.cycled_list(); good_it.forward()) {
1278      table_grid_.InsertBBox(true, true, good_it.extract());
1279    }
1280  }
1281  #ifndef GRAPHICS_DISABLED
1282  void TableFinder::DisplayColSegments(ScrollView *win, ColSegment_LIST *segments,
1283                                       ScrollView::Color color) {
1284    win-&gt;Pen(color);
1285    win-&gt;Brush(ScrollView::NONE);
1286    ColSegment_IT it(segments);
1287    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1288      ColSegment *col = it.data();
1289      const TBOX &amp;box = col-&gt;bounding_box();
1290      int left_x = box.left();
1291      int right_x = box.right();
1292      int top_y = box.top();
1293      int bottom_y = box.bottom();
1294      win-&gt;Rectangle(left_x, bottom_y, right_x, top_y);
1295    }
1296    win-&gt;UpdateWindow();
1297  }
1298  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1299                                         ScrollView::Color default_color,
1300                                         ScrollView::Color table_color) {
1301    ScrollView::Color color = default_color;
1302    GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; gsearch(grid);
1303    gsearch.StartFullSearch();
1304    ColPartition *part = nullptr;
1305    while ((part = gsearch.NextFullSearch()) != nullptr) {
1306      color = default_color;
1307      if (part-&gt;type() == PT_TABLE) {
1308        color = table_color;
1309      }
1310      const TBOX &amp;box = part-&gt;bounding_box();
1311      int left_x = box.left();
1312      int right_x = box.right();
1313      int top_y = box.top();
1314      int bottom_y = box.bottom();
1315      win-&gt;Brush(ScrollView::NONE);
1316      win-&gt;Pen(color);
1317      win-&gt;Rectangle(left_x, bottom_y, right_x, top_y);
1318    }
1319    win-&gt;UpdateWindow();
1320  }
1321  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1322                                         ScrollView::Color default_color) {
1323    DisplayColPartitions(win, grid, default_color, ScrollView::YELLOW);
1324  }
1325  void TableFinder::DisplayColPartitionConnections(ScrollView *win,
1326                                                   ColPartitionGrid *grid,
1327                                                   ScrollView::Color color) {
1328    GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; gsearch(grid);
1329    gsearch.StartFullSearch();
1330    ColPartition *part = nullptr;
1331    while ((part = gsearch.NextFullSearch()) != nullptr) {
1332      const TBOX &amp;box = part-&gt;bounding_box();
1333      int left_x = box.left();
1334      int right_x = box.right();
1335      int top_y = box.top();
1336      int bottom_y = box.bottom();
1337      ColPartition *upper_part = part-&gt;nearest_neighbor_above();
1338      if (upper_part) {
1339        const TBOX &amp;upper_box = upper_part-&gt;bounding_box();
1340        int mid_x = (left_x + right_x) / 2;
1341        int mid_y = (top_y + bottom_y) / 2;
1342        int other_x = (upper_box.left() + upper_box.right()) / 2;
1343        int other_y = (upper_box.top() + upper_box.bottom()) / 2;
1344        win-&gt;Brush(ScrollView::NONE);
1345        win-&gt;Pen(color);
1346        win-&gt;Line(mid_x, mid_y, other_x, other_y);
1347      }
1348      ColPartition *lower_part = part-&gt;nearest_neighbor_below();
1349      if (lower_part) {
1350        const TBOX &amp;lower_box = lower_part-&gt;bounding_box();
1351        int mid_x = (left_x + right_x) / 2;
1352        int mid_y = (top_y + bottom_y) / 2;
1353        int other_x = (lower_box.left() + lower_box.right()) / 2;
1354        int other_y = (lower_box.top() + lower_box.bottom()) / 2;
1355        win-&gt;Brush(ScrollView::NONE);
1356        win-&gt;Pen(color);
1357        win-&gt;Line(mid_x, mid_y, other_x, other_y);
1358      }
1359    }
1360    win-&gt;UpdateWindow();
1361  }
1362  #endif
1363  void TableFinder::MakeTableBlocks(ColPartitionGrid *grid,
1364                                    ColPartitionSet **all_columns,
1365                                    const WidthCallback &amp;width_cb) {
1366    GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; gsearch(grid);
1367    gsearch.StartFullSearch();
1368    ColPartition *part = nullptr;
1369    while ((part = gsearch.NextFullSearch()) != nullptr) {
1370      if (part-&gt;type() == PT_TABLE) {
1371        part-&gt;clear_table_type();
1372      }
1373    }
1374    GridSearch&lt;ColSegment, ColSegment_CLIST, ColSegment_C_IT&gt; table_search(
1375        &amp;table_grid_);
1376    table_search.StartFullSearch();
1377    ColSegment *table;
1378    while ((table = table_search.NextFullSearch()) != nullptr) {
1379      const TBOX &amp;table_box = table-&gt;bounding_box();
1380      GridSearch&lt;ColPartition, ColPartition_CLIST, ColPartition_C_IT&gt; rectsearch(
1381          grid);
1382      rectsearch.StartRectSearch(table_box);
1383      ColPartition *part;
1384      ColPartition *table_partition = nullptr;
1385      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1386        if (!part-&gt;IsTextType()) {
1387          continue;
1388        }
1389        TBOX part_box = part-&gt;bounding_box();
1390        if (part_box.overlap_fraction(table_box) &gt; kMinOverlapWithTable) {
1391          rectsearch.RemoveBBox();
1392          if (table_partition) {
1393            table_partition-&gt;Absorb(part, width_cb);
1394          } else {
1395            table_partition = part;
1396          }
1397        }
1398      }
1399      if (table_partition) {
1400        const TBOX &amp;table_box = table_partition-&gt;bounding_box();
1401        int grid_x, grid_y;
1402        grid-&gt;GridCoords(table_box.left(), table_box.bottom(), &amp;grid_x, &amp;grid_y);
1403        table_partition-&gt;SetPartitionType(resolution_, all_columns[grid_y]);
1404        table_partition-&gt;set_table_type();
1405        table_partition-&gt;set_blob_type(BRT_TEXT);
1406        table_partition-&gt;set_flow(BTFT_CHAIN);
1407        table_partition-&gt;SetBlobTypes();
1408        grid-&gt;InsertBBox(true, true, table_partition);
1409      }
1410    }
1411  }
1412  ColSegment::ColSegment()
1413      : ELIST_LINK(),
1414        num_table_cells_(0),
1415        num_text_cells_(0),
1416        type_(COL_UNKNOWN) {}
1417  ScrollView::Color ColSegment::BoxColor() const {
1418    const ScrollView::Color kBoxColors[PT_COUNT] = {
1419        ScrollView::YELLOW,
1420        ScrollView::BLUE,
1421        ScrollView::YELLOW,
1422        ScrollView::MAGENTA,
1423    };
1424    return kBoxColors[type_];
1425  }
1426  void ColSegment::InsertBox(const TBOX &amp;other) {
1427    bounding_box_ = bounding_box_.bounding_union(other);
1428  }
1429  void ColSegment::set_type() {
1430    if (num_table_cells_ &gt; kTableColumnThreshold * num_text_cells_) {
1431      type_ = COL_TABLE;
1432    } else if (num_text_cells_ &gt; num_table_cells_) {
1433      type_ = COL_TEXT;
1434    } else {
1435      type_ = COL_MIXED;
1436    }
1437  }
1438  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-strokewidth.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</div>
                </div>
                <div class="column column_space"><pre><code>165    Clear();
166    ColPartition_LIST leader_parts;
167    FindLeadersAndMarkNoise(block, &amp;leader_parts);
168    InsertBlobList(&amp;block-&gt;blobs);
</pre></code></div>
                <div class="column column_space"><pre><code>145    MarkTablePartitions();
146    ColSegment_LIST column_blocks;
147    GetColumnBlocks(all_columns, &amp;column_blocks);
148    SetColumnsType(&amp;column_blocks);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    