
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.1516314779270633%, Tokens: 9</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-death-test.cc</h3>
            <pre><code>1  #include "gtest/gtest-death-test.h"
2  #include "gtest/internal/gtest-port.h"
3  #if GTEST_HAS_DEATH_TEST
4  # if GTEST_OS_MAC
5  #  include <crt_externs.h>
6  # endif  
7  # include <errno.h>
8  # include <fcntl.h>
9  # include <limits.h>
10  # if GTEST_OS_LINUX
11  #  include <signal.h>
12  # endif  
13  # include <stdarg.h>
14  # if GTEST_OS_WINDOWS
15  #  include <windows.h>
16  # else
17  #  include <sys/mman.h>
18  #  include <sys/wait.h>
19  # endif  
20  # if GTEST_OS_QNX
21  #  include <spawn.h>
22  # endif  
23  #endif  
24  #include "gtest/gtest-message.h"
25  #include "gtest/internal/gtest-string.h"
26  #define GTEST_IMPLEMENTATION_ 1
27  #include "src/gtest-internal-inl.h"
28  #undef GTEST_IMPLEMENTATION_
29  namespace testing {
30  static const char kDefaultDeathTestStyle[] = "fast";
31  GTEST_DEFINE_string_(
32      death_test_style,
33      internal::StringFromGTestEnv("death_test_style", kDefaultDeathTestStyle),
34      "Indicates how to run a death test in a forked child process: "
35      "\"threadsafe\" (child process re-executes the test binary "
36      "from the beginning, running only the specific death test) or "
37      "\"fast\" (child process runs the death test immediately "
38      "after forking).");
39  GTEST_DEFINE_bool_(
40      death_test_use_fork,
41      internal::BoolFromGTestEnv("death_test_use_fork", false),
42      "Instructs to use fork()/_exit() instead of clone() in death tests. "
43      "Ignored and always uses fork() on POSIX systems where clone() is not "
44      "implemented. Useful when running under valgrind or similar tools if "
45      "those do not support clone(). Valgrind 3.3.1 will just fail if "
46      "it sees an unsupported combination of clone() flags. "
47      "It is not recommended to use this flag w/o valgrind though it will "
48      "work in 99% of the cases. Once valgrind is fixed, this flag will "
49      "most likely be removed.");
50  namespace internal {
51  GTEST_DEFINE_string_(
52      internal_run_death_test, "",
53      "Indicates the file, line number, temporal index of "
54      "the single death test to run, and a file descriptor to "
55      "which a success code may be sent, all separated by "
56      "the '|' characters.  This flag is specified if and only if the current "
57      "process is a sub-process launched for running a thread-safe "
58      "death test.  FOR INTERNAL USE ONLY.");
59  }  
60  #if GTEST_HAS_DEATH_TEST
61  namespace internal {
62  static bool g_in_fast_death_test_child = false;
63  bool InDeathTestChild() {
64  # if GTEST_OS_WINDOWS
65    return !GTEST_FLAG(internal_run_death_test).empty();
66  # else
67    if (GTEST_FLAG(death_test_style) == "threadsafe")
68      return !GTEST_FLAG(internal_run_death_test).empty();
69    else
70      return g_in_fast_death_test_child;
71  #endif
72  }
73  }  
74  ExitedWithCode::ExitedWithCode(int exit_code) : exit_code_(exit_code) {
75  }
76  bool ExitedWithCode::operator()(int exit_status) const {
77  # if GTEST_OS_WINDOWS
78    return exit_status == exit_code_;
79  # else
80    return WIFEXITED(exit_status) && WEXITSTATUS(exit_status) == exit_code_;
81  # endif  
82  }
83  # if !GTEST_OS_WINDOWS
84  KilledBySignal::KilledBySignal(int signum) : signum_(signum) {
85  }
86  bool KilledBySignal::operator()(int exit_status) const {
87    return WIFSIGNALED(exit_status) && WTERMSIG(exit_status) == signum_;
88  }
89  # endif  
90  namespace internal {
91  static std::string ExitSummary(int exit_code) {
92    Message m;
93  # if GTEST_OS_WINDOWS
94    m << "Exited with exit status " << exit_code;
95  # else
96    if (WIFEXITED(exit_code)) {
97      m << "Exited with exit status " << WEXITSTATUS(exit_code);
98    } else if (WIFSIGNALED(exit_code)) {
99      m << "Terminated by signal " << WTERMSIG(exit_code);
100    }
101  #  ifdef WCOREDUMP
102    if (WCOREDUMP(exit_code)) {
103      m << " (core dumped)";
104    }
105  #  endif
106  # endif  
107    return m.GetString();
108  }
109  bool ExitedUnsuccessfully(int exit_status) {
110    return !ExitedWithCode(0)(exit_status);
111  }
112  # if !GTEST_OS_WINDOWS
113  static std::string DeathTestThreadWarning(size_t thread_count) {
114    Message msg;
115    msg << "Death tests use fork(), which is unsafe particularly"
116        << " in a threaded context. For this test, " << GTEST_NAME_ << " ";
117    if (thread_count == 0)
118      msg << "couldn't detect the number of threads.";
119    else
120      msg << "detected " << thread_count << " threads.";
121    return msg.GetString();
122  }
123  # endif  
124  static const char kDeathTestLived = 'L';
125  static const char kDeathTestReturned = 'R';
126  static const char kDeathTestThrew = 'T';
127  static const char kDeathTestInternalError = 'I';
128  enum DeathTestOutcome { IN_PROGRESS, DIED, LIVED, RETURNED, THREW };
129  void DeathTestAbort(const std::string& message) {
130    const InternalRunDeathTestFlag* const flag =
131        GetUnitTestImpl()->internal_run_death_test_flag();
132    if (flag != NULL) {
133      FILE* parent = posix::FDOpen(flag->write_fd(), "w");
134      fputc(kDeathTestInternalError, parent);
135      fprintf(parent, "%s", message.c_str());
136      fflush(parent);
137      _exit(1);
138    } else {
139      fprintf(stderr, "%s", message.c_str());
140      fflush(stderr);
141      posix::Abort();
142    }
143  }
144  # define GTEST_DEATH_TEST_CHECK_(expression) \
145    do { \
146      if (!::testing::internal::IsTrue(expression)) { \
147        DeathTestAbort( \
148            ::std::string("CHECK failed: File ") + __FILE__ +  ", line " \
149            + ::testing::internal::StreamableToString(__LINE__) + ": " \
150            + #expression); \
151      } \
152    } while (::testing::internal::AlwaysFalse())
153  # define GTEST_DEATH_TEST_CHECK_SYSCALL_(expression) \
154    do { \
155      int gtest_retval; \
156      do { \
157        gtest_retval = (expression); \
158      } while (gtest_retval == -1 && errno == EINTR); \
159      if (gtest_retval == -1) { \
160        DeathTestAbort( \
161            ::std::string("CHECK failed: File ") + __FILE__ + ", line " \
162            + ::testing::internal::StreamableToString(__LINE__) + ": " \
163            + #expression + " != -1"); \
164      } \
165    } while (::testing::internal::AlwaysFalse())
166  std::string GetLastErrnoDescription() {
167      return errno == 0 ? "" : posix::StrError(errno);
168  }
169  static void FailFromInternalError(int fd) {
170    Message error;
171    char buffer[256];
172    int num_read;
173    do {
174      while ((num_read = posix::Read(fd, buffer, 255)) > 0) {
175        buffer[num_read] = '\0';
176        error << buffer;
177      }
178    } while (num_read == -1 && errno == EINTR);
179    if (num_read == 0) {
180      GTEST_LOG_(FATAL) << error.GetString();
181    } else {
182      const int last_error = errno;
183      GTEST_LOG_(FATAL) << "Error while reading death test internal: "
184                        << GetLastErrnoDescription() << " [" << last_error << "]";
185    }
186  }
187  DeathTest::DeathTest() {
188    TestInfo* const info = GetUnitTestImpl()->current_test_info();
189    if (info == NULL) {
190      DeathTestAbort("Cannot run a death test outside of a TEST or "
191                     "TEST_F construct");
192    }
193  }
194  bool DeathTest::Create(const char* statement, const RE* regex,
195                         const char* file, int line, DeathTest** test) {
196    return GetUnitTestImpl()->death_test_factory()->Create(
197        statement, regex, file, line, test);
198  }
199  const char* DeathTest::LastMessage() {
200    return last_death_test_message_.c_str();
201  }
202  void DeathTest::set_last_death_test_message(const std::string& message) {
203    last_death_test_message_ = message;
204  }
205  std::string DeathTest::last_death_test_message_;
206  class DeathTestImpl : public DeathTest {
207   protected:
208    DeathTestImpl(const char* a_statement, const RE* a_regex)
209        : statement_(a_statement),
210          regex_(a_regex),
211          spawned_(false),
212          status_(-1),
213          outcome_(IN_PROGRESS),
214          read_fd_(-1),
215          write_fd_(-1) {}
216    ~DeathTestImpl() { GTEST_DEATH_TEST_CHECK_(read_fd_ == -1); }
217    void Abort(AbortReason reason);
218    virtual bool Passed(bool status_ok);
219    const char* statement() const { return statement_; }
220    const RE* regex() const { return regex_; }
221    bool spawned() const { return spawned_; }
222    void set_spawned(bool is_spawned) { spawned_ = is_spawned; }
223    int status() const { return status_; }
224    void set_status(int a_status) { status_ = a_status; }
225    DeathTestOutcome outcome() const { return outcome_; }
226    void set_outcome(DeathTestOutcome an_outcome) { outcome_ = an_outcome; }
227    int read_fd() const { return read_fd_; }
228    void set_read_fd(int fd) { read_fd_ = fd; }
229    int write_fd() const { return write_fd_; }
230    void set_write_fd(int fd) { write_fd_ = fd; }
231    void ReadAndInterpretStatusByte();
232   private:
233    const char* const statement_;
234    const RE* const regex_;
235    bool spawned_;
236    int status_;
237    DeathTestOutcome outcome_;
238    int read_fd_;
239    int write_fd_;
240  };
241  void DeathTestImpl::ReadAndInterpretStatusByte() {
242    char flag;
243    int bytes_read;
244    do {
245      bytes_read = posix::Read(read_fd(), &flag, 1);
246    } while (bytes_read == -1 && errno == EINTR);
247    if (bytes_read == 0) {
248      set_outcome(DIED);
249    } else if (bytes_read == 1) {
250      switch (flag) {
251        case kDeathTestReturned:
252          set_outcome(RETURNED);
253          break;
254        case kDeathTestThrew:
255          set_outcome(THREW);
256          break;
257        case kDeathTestLived:
258          set_outcome(LIVED);
259          break;
260        case kDeathTestInternalError:
261          FailFromInternalError(read_fd());  
262          break;
263        default:
264          GTEST_LOG_(FATAL) << "Death test child process reported "
265                            << "unexpected status byte ("
266                            << static_cast<unsigned int>(flag) << ")";
267      }
268    } else {
269      GTEST_LOG_(FATAL) << "Read from death test child process failed: "
270                        << GetLastErrnoDescription();
271    }
272    GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Close(read_fd()));
273    set_read_fd(-1);
274  }
275  void DeathTestImpl::Abort(AbortReason reason) {
276    const char status_ch =
277        reason == TEST_DID_NOT_DIE ? kDeathTestLived :
278        reason == TEST_THREW_EXCEPTION ? kDeathTestThrew : kDeathTestReturned;
279    GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Write(write_fd(), &status_ch, 1));
280    _exit(1);  
281  }
282  static ::std::string FormatDeathTestOutput(const ::std::string& output) {
283    ::std::string ret;
284    for (size_t at = 0; ; ) {
285      const size_t line_end = output.find('\n', at);
286      ret += "[  DEATH   ] ";
287      if (line_end == ::std::string::npos) {
288        ret += output.substr(at);
289        break;
290      }
291      ret += output.substr(at, line_end + 1 - at);
292      at = line_end + 1;
293    }
294    return ret;
295  }
296  bool DeathTestImpl::Passed(bool status_ok) {
297    if (!spawned())
298      return false;
299    const std::string error_message = GetCapturedStderr();
300    bool success = false;
301    Message buffer;
302    buffer << "Death test: " << statement() << "\n";
303    switch (outcome()) {
304      case LIVED:
305        buffer << "    Result: failed to die.\n"
306               << " Error msg:\n" << FormatDeathTestOutput(error_message);
307        break;
308      case THREW:
309        buffer << "    Result: threw an exception.\n"
310               << " Error msg:\n" << FormatDeathTestOutput(error_message);
311        break;
312      case RETURNED:
313        buffer << "    Result: illegal return in test statement.\n"
314               << " Error msg:\n" << FormatDeathTestOutput(error_message);
315        break;
316      case DIED:
<span onclick='openModal()' class='match'>317        if (status_ok) {
318          const bool matched = RE::PartialMatch(error_message.c_str(), *regex());
319          if (matched) {
320            success = true;
321          } else {
</span>322            buffer << "    Result: died but not with expected error.\n"
323                   << "  Expected: " << regex()->pattern() << "\n"
324                   << "Actual msg:\n" << FormatDeathTestOutput(error_message);
325          }
326        } else {
327          buffer << "    Result: died but not with expected exit code:\n"
328                 << "            " << ExitSummary(status()) << "\n"
329                 << "Actual msg:\n" << FormatDeathTestOutput(error_message);
330        }
331        break;
332      case IN_PROGRESS:
333      default:
334        GTEST_LOG_(FATAL)
335            << "DeathTest::Passed somehow called before conclusion of test";
336    }
337    DeathTest::set_last_death_test_message(buffer.GetString());
338    return success;
339  }
340  # if GTEST_OS_WINDOWS
341  class WindowsDeathTest : public DeathTestImpl {
342   public:
343    WindowsDeathTest(const char* a_statement,
344                     const RE* a_regex,
345                     const char* file,
346                     int line)
347        : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) {}
348    virtual int Wait();
349    virtual TestRole AssumeRole();
350   private:
351    const char* const file_;
352    const int line_;
353    AutoHandle write_handle_;
354    AutoHandle child_handle_;
355    AutoHandle event_handle_;
356  };
357  int WindowsDeathTest::Wait() {
358    if (!spawned())
359      return 0;
360    const HANDLE wait_handles[2] = { child_handle_.Get(), event_handle_.Get() };
361    switch (::WaitForMultipleObjects(2,
362                                     wait_handles,
363                                     FALSE,  
364                                     INFINITE)) {
365      case WAIT_OBJECT_0:
366      case WAIT_OBJECT_0 + 1:
367        break;
368      default:
369        GTEST_DEATH_TEST_CHECK_(false);  
370    }
371    write_handle_.Reset();
372    event_handle_.Reset();
373    ReadAndInterpretStatusByte();
374    GTEST_DEATH_TEST_CHECK_(
375        WAIT_OBJECT_0 == ::WaitForSingleObject(child_handle_.Get(),
376                                               INFINITE));
377    DWORD status_code;
378    GTEST_DEATH_TEST_CHECK_(
379        ::GetExitCodeProcess(child_handle_.Get(), &status_code) != FALSE);
380    child_handle_.Reset();
381    set_status(static_cast<int>(status_code));
382    return status();
383  }
384  DeathTest::TestRole WindowsDeathTest::AssumeRole() {
385    const UnitTestImpl* const impl = GetUnitTestImpl();
386    const InternalRunDeathTestFlag* const flag =
387        impl->internal_run_death_test_flag();
388    const TestInfo* const info = impl->current_test_info();
389    const int death_test_index = info->result()->death_test_count();
390    if (flag != NULL) {
391      set_write_fd(flag->write_fd());
392      return EXECUTE_TEST;
393    }
394    SECURITY_ATTRIBUTES handles_are_inheritable = {
395      sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
396    HANDLE read_handle, write_handle;
397    GTEST_DEATH_TEST_CHECK_(
398        ::CreatePipe(&read_handle, &write_handle, &handles_are_inheritable,
399                     0)  
400        != FALSE);
401    set_read_fd(::_open_osfhandle(reinterpret_cast<intptr_t>(read_handle),
402                                  O_RDONLY));
403    write_handle_.Reset(write_handle);
404    event_handle_.Reset(::CreateEvent(
405        &handles_are_inheritable,
406        TRUE,    
407        FALSE,   
408        NULL));  
409    GTEST_DEATH_TEST_CHECK_(event_handle_.Get() != NULL);
410    const std::string filter_flag =
411        std::string("--") + GTEST_FLAG_PREFIX_ + kFilterFlag + "=" +
412        info->test_case_name() + "." + info->name();
413    const std::string internal_flag =
414        std::string("--") + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag +
415        "=" + file_ + "|" + StreamableToString(line_) + "|" +
416        StreamableToString(death_test_index) + "|" +
417        StreamableToString(static_cast<unsigned int>(::GetCurrentProcessId())) +
418        "|" + StreamableToString(reinterpret_cast<size_t>(write_handle)) +
419        "|" + StreamableToString(reinterpret_cast<size_t>(event_handle_.Get()));
420    char executable_path[_MAX_PATH + 1];  
421    GTEST_DEATH_TEST_CHECK_(
422        _MAX_PATH + 1 != ::GetModuleFileNameA(NULL,
423                                              executable_path,
424                                              _MAX_PATH));
425    std::string command_line =
426        std::string(::GetCommandLineA()) + " " + filter_flag + " \"" +
427        internal_flag + "\"";
428    DeathTest::set_last_death_test_message("");
429    CaptureStderr();
430    FlushInfoLog();
431    STARTUPINFOA startup_info;
432    memset(&startup_info, 0, sizeof(STARTUPINFO));
433    startup_info.dwFlags = STARTF_USESTDHANDLES;
434    startup_info.hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);
435    startup_info.hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);
436    startup_info.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);
437    PROCESS_INFORMATION process_info;
438    GTEST_DEATH_TEST_CHECK_(::CreateProcessA(
439        executable_path,
440        const_cast<char*>(command_line.c_str()),
441        NULL,   
442        NULL,   
443        TRUE,   
444        0x0,    
445        NULL,   
446        UnitTest::GetInstance()->original_working_dir(),
447        &startup_info,
448        &process_info) != FALSE);
449    child_handle_.Reset(process_info.hProcess);
450    ::CloseHandle(process_info.hThread);
451    set_spawned(true);
452    return OVERSEE_TEST;
453  }
454  # else  
455  class ForkingDeathTest : public DeathTestImpl {
456   public:
457    ForkingDeathTest(const char* statement, const RE* regex);
458    virtual int Wait();
459   protected:
460    void set_child_pid(pid_t child_pid) { child_pid_ = child_pid; }
461   private:
462    pid_t child_pid_;
463  };
464  ForkingDeathTest::ForkingDeathTest(const char* a_statement, const RE* a_regex)
465      : DeathTestImpl(a_statement, a_regex),
466        child_pid_(-1) {}
467  int ForkingDeathTest::Wait() {
468    if (!spawned())
469      return 0;
470    ReadAndInterpretStatusByte();
471    int status_value;
472    GTEST_DEATH_TEST_CHECK_SYSCALL_(waitpid(child_pid_, &status_value, 0));
473    set_status(status_value);
474    return status_value;
475  }
476  class NoExecDeathTest : public ForkingDeathTest {
477   public:
478    NoExecDeathTest(const char* a_statement, const RE* a_regex) :
479        ForkingDeathTest(a_statement, a_regex) { }
480    virtual TestRole AssumeRole();
481  };
482  DeathTest::TestRole NoExecDeathTest::AssumeRole() {
483    const size_t thread_count = GetThreadCount();
484    if (thread_count != 1) {
485      GTEST_LOG_(WARNING) << DeathTestThreadWarning(thread_count);
486    }
487    int pipe_fd[2];
488    GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);
489    DeathTest::set_last_death_test_message("");
490    CaptureStderr();
491    FlushInfoLog();
492    const pid_t child_pid = fork();
493    GTEST_DEATH_TEST_CHECK_(child_pid != -1);
494    set_child_pid(child_pid);
495    if (child_pid == 0) {
496      GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[0]));
497      set_write_fd(pipe_fd[1]);
498      LogToStderr();
499      GetUnitTestImpl()->listeners()->SuppressEventForwarding();
500      g_in_fast_death_test_child = true;
501      return EXECUTE_TEST;
502    } else {
503      GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));
504      set_read_fd(pipe_fd[0]);
505      set_spawned(true);
506      return OVERSEE_TEST;
507    }
508  }
509  class ExecDeathTest : public ForkingDeathTest {
510   public:
511    ExecDeathTest(const char* a_statement, const RE* a_regex,
512                  const char* file, int line) :
513        ForkingDeathTest(a_statement, a_regex), file_(file), line_(line) { }
514    virtual TestRole AssumeRole();
515   private:
516    static ::std::vector<testing::internal::string>
517    GetArgvsForDeathTestChildProcess() {
518      ::std::vector<testing::internal::string> args = GetInjectableArgvs();
519      return args;
520    }
521    const char* const file_;
522    const int line_;
523  };
524  class Arguments {
525   public:
526    Arguments() {
527      args_.push_back(NULL);
528    }
529    ~Arguments() {
530      for (std::vector<char*>::iterator i = args_.begin(); i != args_.end();
531           ++i) {
532        free(*i);
533      }
534    }
535    void AddArgument(const char* argument) {
536      args_.insert(args_.end() - 1, posix::StrDup(argument));
537    }
538    template <typename Str>
539    void AddArguments(const ::std::vector<Str>& arguments) {
540      for (typename ::std::vector<Str>::const_iterator i = arguments.begin();
541           i != arguments.end();
542           ++i) {
543        args_.insert(args_.end() - 1, posix::StrDup(i->c_str()));
544      }
545    }
546    char* const* Argv() {
547      return &args_[0];
548    }
549   private:
550    std::vector<char*> args_;
551  };
552  struct ExecDeathTestArgs {
553    char* const* argv;  
554    int close_fd;       
555  };
556  #  if GTEST_OS_MAC
557  inline char** GetEnviron() {
558    return *_NSGetEnviron();
559  }
560  #  else
561  extern "C" char** environ;
562  inline char** GetEnviron() { return environ; }
563  #  endif  
564  #  if !GTEST_OS_QNX
565  static int ExecDeathTestChildMain(void* child_arg) {
566    ExecDeathTestArgs* const args = static_cast<ExecDeathTestArgs*>(child_arg);
567    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(args->close_fd));
568    const char* const original_dir =
569        UnitTest::GetInstance()->original_working_dir();
570    if (chdir(original_dir) != 0) {
571      DeathTestAbort(std::string("chdir(\"") + original_dir + "\") failed: " +
572                     GetLastErrnoDescription());
573      return EXIT_FAILURE;
574    }
575    execve(args->argv[0], args->argv, GetEnviron());
576    DeathTestAbort(std::string("execve(") + args->argv[0] + ", ...) in " +
577                   original_dir + " failed: " +
578                   GetLastErrnoDescription());
579    return EXIT_FAILURE;
580  }
581  #  endif  
582  void StackLowerThanAddress(const void* ptr, bool* result) GTEST_NO_INLINE_;
583  void StackLowerThanAddress(const void* ptr, bool* result) {
584    int dummy;
585    *result = (&dummy < ptr);
586  }
587  bool StackGrowsDown() {
588    int dummy;
589    bool result;
590    StackLowerThanAddress(&dummy, &result);
591    return result;
592  }
593  static pid_t ExecDeathTestSpawnChild(char* const* argv, int close_fd) {
594    ExecDeathTestArgs args = { argv, close_fd };
595    pid_t child_pid = -1;
596  #  if GTEST_OS_QNX
597    const int cwd_fd = open(".", O_RDONLY);
598    GTEST_DEATH_TEST_CHECK_(cwd_fd != -1);
599    GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(cwd_fd, F_SETFD, FD_CLOEXEC));
600    const char* const original_dir =
601        UnitTest::GetInstance()->original_working_dir();
602    if (chdir(original_dir) != 0) {
603      DeathTestAbort(std::string("chdir(\"") + original_dir + "\") failed: " +
604                     GetLastErrnoDescription());
605      return EXIT_FAILURE;
606    }
607    int fd_flags;
608    GTEST_DEATH_TEST_CHECK_SYSCALL_(fd_flags = fcntl(close_fd, F_GETFD));
609    GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(close_fd, F_SETFD,
610                                          fd_flags | FD_CLOEXEC));
611    struct inheritance inherit = {0};
612    child_pid = spawn(args.argv[0], 0, NULL, &inherit, args.argv, GetEnviron());
613    GTEST_DEATH_TEST_CHECK_(fchdir(cwd_fd) != -1);
614    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(cwd_fd));
615  #  else   
616  #   if GTEST_OS_LINUX
617    struct sigaction saved_sigprof_action;
618    struct sigaction ignore_sigprof_action;
619    memset(&ignore_sigprof_action, 0, sizeof(ignore_sigprof_action));
620    sigemptyset(&ignore_sigprof_action.sa_mask);
621    ignore_sigprof_action.sa_handler = SIG_IGN;
622    GTEST_DEATH_TEST_CHECK_SYSCALL_(sigaction(
623        SIGPROF, &ignore_sigprof_action, &saved_sigprof_action));
624  #   endif  
625  #   if GTEST_HAS_CLONE
626    const bool use_fork = GTEST_FLAG(death_test_use_fork);
627    if (!use_fork) {
628      static const bool stack_grows_down = StackGrowsDown();
629      const size_t stack_size = getpagesize();
630      void* const stack = mmap(NULL, stack_size, PROT_READ | PROT_WRITE,
631                               MAP_ANON | MAP_PRIVATE, -1, 0);
632      GTEST_DEATH_TEST_CHECK_(stack != MAP_FAILED);
633      const size_t kMaxStackAlignment = 64;
634      void* const stack_top =
635          static_cast<char*>(stack) +
636              (stack_grows_down ? stack_size - kMaxStackAlignment : 0);
637      GTEST_DEATH_TEST_CHECK_(stack_size > kMaxStackAlignment &&
638          reinterpret_cast<intptr_t>(stack_top) % kMaxStackAlignment == 0);
639      child_pid = clone(&ExecDeathTestChildMain, stack_top, SIGCHLD, &args);
640      GTEST_DEATH_TEST_CHECK_(munmap(stack, stack_size) != -1);
641    }
642  #   else
643    const bool use_fork = true;
644  #   endif  
645    if (use_fork && (child_pid = fork()) == 0) {
646        ExecDeathTestChildMain(&args);
647        _exit(0);
648    }
649  #  endif  
650  #  if GTEST_OS_LINUX
651    GTEST_DEATH_TEST_CHECK_SYSCALL_(
652        sigaction(SIGPROF, &saved_sigprof_action, NULL));
653  #  endif  
654    GTEST_DEATH_TEST_CHECK_(child_pid != -1);
655    return child_pid;
656  }
657  DeathTest::TestRole ExecDeathTest::AssumeRole() {
658    const UnitTestImpl* const impl = GetUnitTestImpl();
659    const InternalRunDeathTestFlag* const flag =
660        impl->internal_run_death_test_flag();
661    const TestInfo* const info = impl->current_test_info();
662    const int death_test_index = info->result()->death_test_count();
663    if (flag != NULL) {
664      set_write_fd(flag->write_fd());
665      return EXECUTE_TEST;
666    }
667    int pipe_fd[2];
668    GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);
669    GTEST_DEATH_TEST_CHECK_(fcntl(pipe_fd[1], F_SETFD, 0) != -1);
670    const std::string filter_flag =
671        std::string("--") + GTEST_FLAG_PREFIX_ + kFilterFlag + "="
672        + info->test_case_name() + "." + info->name();
673    const std::string internal_flag =
674        std::string("--") + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag + "="
675        + file_ + "|" + StreamableToString(line_) + "|"
676        + StreamableToString(death_test_index) + "|"
677        + StreamableToString(pipe_fd[1]);
678    Arguments args;
679    args.AddArguments(GetArgvsForDeathTestChildProcess());
680    args.AddArgument(filter_flag.c_str());
681    args.AddArgument(internal_flag.c_str());
682    DeathTest::set_last_death_test_message("");
683    CaptureStderr();
684    FlushInfoLog();
685    const pid_t child_pid = ExecDeathTestSpawnChild(args.Argv(), pipe_fd[0]);
686    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));
687    set_child_pid(child_pid);
688    set_read_fd(pipe_fd[0]);
689    set_spawned(true);
690    return OVERSEE_TEST;
691  }
692  # endif  
693  bool DefaultDeathTestFactory::Create(const char* statement, const RE* regex,
694                                       const char* file, int line,
695                                       DeathTest** test) {
696    UnitTestImpl* const impl = GetUnitTestImpl();
697    const InternalRunDeathTestFlag* const flag =
698        impl->internal_run_death_test_flag();
699    const int death_test_index = impl->current_test_info()
700        ->increment_death_test_count();
701    if (flag != NULL) {
702      if (death_test_index > flag->index()) {
703        DeathTest::set_last_death_test_message(
704            "Death test count (" + StreamableToString(death_test_index)
705            + ") somehow exceeded expected maximum ("
706            + StreamableToString(flag->index()) + ")");
707        return false;
708      }
709      if (!(flag->file() == file && flag->line() == line &&
710            flag->index() == death_test_index)) {
711        *test = NULL;
712        return true;
713      }
714    }
715  # if GTEST_OS_WINDOWS
716    if (GTEST_FLAG(death_test_style) == "threadsafe" ||
717        GTEST_FLAG(death_test_style) == "fast") {
718      *test = new WindowsDeathTest(statement, regex, file, line);
719    }
720  # else
721    if (GTEST_FLAG(death_test_style) == "threadsafe") {
722      *test = new ExecDeathTest(statement, regex, file, line);
723    } else if (GTEST_FLAG(death_test_style) == "fast") {
724      *test = new NoExecDeathTest(statement, regex);
725    }
726  # endif  
727    else {  
728      DeathTest::set_last_death_test_message(
729          "Unknown death test style \"" + GTEST_FLAG(death_test_style)
730          + "\" encountered");
731      return false;
732    }
733    return true;
734  }
735  static void SplitString(const ::std::string& str, char delimiter,
736                          ::std::vector< ::std::string>* dest) {
737    ::std::vector< ::std::string> parsed;
738    ::std::string::size_type pos = 0;
739    while (::testing::internal::AlwaysTrue()) {
740      const ::std::string::size_type colon = str.find(delimiter, pos);
741      if (colon == ::std::string::npos) {
742        parsed.push_back(str.substr(pos));
743        break;
744      } else {
745        parsed.push_back(str.substr(pos, colon - pos));
746        pos = colon + 1;
747      }
748    }
749    dest->swap(parsed);
750  }
751  # if GTEST_OS_WINDOWS
752  int GetStatusFileDescriptor(unsigned int parent_process_id,
753                              size_t write_handle_as_size_t,
754                              size_t event_handle_as_size_t) {
755    AutoHandle parent_process_handle(::OpenProcess(PROCESS_DUP_HANDLE,
756                                                     FALSE,  
757                                                     parent_process_id));
758    if (parent_process_handle.Get() == INVALID_HANDLE_VALUE) {
759      DeathTestAbort("Unable to open parent process " +
760                     StreamableToString(parent_process_id));
761    }
762    GTEST_CHECK_(sizeof(HANDLE) <= sizeof(size_t));
763    const HANDLE write_handle =
764        reinterpret_cast<HANDLE>(write_handle_as_size_t);
765    HANDLE dup_write_handle;
766    if (!::DuplicateHandle(parent_process_handle.Get(), write_handle,
767                           ::GetCurrentProcess(), &dup_write_handle,
768                           0x0,    
769                           FALSE,  
770                           DUPLICATE_SAME_ACCESS)) {
771      DeathTestAbort("Unable to duplicate the pipe handle " +
772                     StreamableToString(write_handle_as_size_t) +
773                     " from the parent process " +
774                     StreamableToString(parent_process_id));
775    }
776    const HANDLE event_handle = reinterpret_cast<HANDLE>(event_handle_as_size_t);
777    HANDLE dup_event_handle;
778    if (!::DuplicateHandle(parent_process_handle.Get(), event_handle,
779                           ::GetCurrentProcess(), &dup_event_handle,
780                           0x0,
781                           FALSE,
782                           DUPLICATE_SAME_ACCESS)) {
783      DeathTestAbort("Unable to duplicate the event handle " +
784                     StreamableToString(event_handle_as_size_t) +
785                     " from the parent process " +
786                     StreamableToString(parent_process_id));
787    }
788    const int write_fd =
789        ::_open_osfhandle(reinterpret_cast<intptr_t>(dup_write_handle), O_APPEND);
790    if (write_fd == -1) {
791      DeathTestAbort("Unable to convert pipe handle " +
792                     StreamableToString(write_handle_as_size_t) +
793                     " to a file descriptor");
794    }
795    ::SetEvent(dup_event_handle);
796    return write_fd;
797  }
798  # endif  
799  InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag() {
800    if (GTEST_FLAG(internal_run_death_test) == "") return NULL;
801    int line = -1;
802    int index = -1;
803    ::std::vector< ::std::string> fields;
804    SplitString(GTEST_FLAG(internal_run_death_test).c_str(), '|', &fields);
805    int write_fd = -1;
806  # if GTEST_OS_WINDOWS
807    unsigned int parent_process_id = 0;
808    size_t write_handle_as_size_t = 0;
809    size_t event_handle_as_size_t = 0;
810    if (fields.size() != 6
811        || !ParseNaturalNumber(fields[1], &line)
812        || !ParseNaturalNumber(fields[2], &index)
813        || !ParseNaturalNumber(fields[3], &parent_process_id)
814        || !ParseNaturalNumber(fields[4], &write_handle_as_size_t)
815        || !ParseNaturalNumber(fields[5], &event_handle_as_size_t)) {
816      DeathTestAbort("Bad --gtest_internal_run_death_test flag: " +
817                     GTEST_FLAG(internal_run_death_test));
818    }
819    write_fd = GetStatusFileDescriptor(parent_process_id,
820                                       write_handle_as_size_t,
821                                       event_handle_as_size_t);
822  # else
823    if (fields.size() != 4
824        || !ParseNaturalNumber(fields[1], &line)
825        || !ParseNaturalNumber(fields[2], &index)
826        || !ParseNaturalNumber(fields[3], &write_fd)) {
827      DeathTestAbort("Bad --gtest_internal_run_death_test flag: "
828          + GTEST_FLAG(internal_run_death_test));
829    }
830  # endif  
831    return new InternalRunDeathTestFlag(fields[0], line, index, write_fd);
832  }
833  }  
834  #endif  
835  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cache.h</h3>
            <pre><code>1  #ifndef CACHE_H
2  #define CACHE_H
3  template <class TVal>
4  class TValCache {
5  private:
6  	ClassTP(TValDat, PValDat)
7  	public:
8  		TVal Val;
9  	public:
10  		TValDat(const TVal& _Val): Val(_Val) { }
11  		static PValDat New(const TVal& Val) { return new TValDat(Val); }
12          int64 GetMemUsed() const { return (int64)Val.GetMemUsed(); }
13          void OnDelFromCache(const TInt& ValId, void* ValCache) { }
14  	};
15  private:
16      TStr FNmPrefix;
17      TFAccess Access;
18      int64 CacheResetThreshold;
19      int64 NewCacheSizeInc;
20  	mutable TCache<TInt, PValDat> ValCache;
21      TBlobPtV ValBlobPtV;
22  	PBlobBs ValBlobBs;
23  private:
24      void AssertReadOnly() const {
25          EAssertR(((Access==faCreate)||(Access==faUpdate)), 
26              FNmPrefix + " opened in Read-Only mode!"); }
27      void* GetVoidThis() const { return (void*)this; }
28  	UndefDefaultCopyAssign(TValCache);
29  public:
30      TValCache(const TStr& _FNmPrefix, const TFAccess& _Access, const int64& MxCacheMem);
31  	~TValCache();
32      bool IsReadOnly() const { return Access == faRdOnly; }
33  	int AddVal(const TVal& Val);
34  	int Len() const { return ValBlobPtV.Len(); }
35  	bool IsValId(const int& ValId) const { return (ValId >= 0) && (ValId < ValBlobPtV.Len()); }
36  	void GetVal(const int& ValId, TVal& Val) const;
37  };
38  template <class TVal>
39  TValCache<TVal>::TValCache(const TStr& _FNmPrefix, const TFAccess& _Access, 
40  	const int64& MxCacheMem): ValCache(MxCacheMem, 1000000, GetVoidThis()) {
41      FNmPrefix = _FNmPrefix;
42      Access = _Access;
43      CacheResetThreshold = int64(0.1 * double(MxCacheMem));
44  	NewCacheSizeInc = 0;
45      ValBlobBs = TMBlobBs::New(FNmPrefix + "BlobBs", Access);
46      if (Access == faCreate) {
47  	} else {
48  		TFIn FIn(FNmPrefix + ".Dat");
49  		ValBlobPtV.Load(FIn);
50  	}
51  }
52  template <class TVal>
53  TValCache<TVal>::~TValCache() {
54      if ((Access == faCreate) || (Access == faUpdate)) {
55          TFOut FOut(FNmPrefix + ".Dat"); ValBlobPtV.Save(FOut);
56      }
57  }
58  template <class TVal>
59  int TValCache<TVal>::AddVal(const TVal& Val) {
60  	AssertReadOnly();
61      TMOut MOut; Val.Save(MOut);
62  	const TBlobPt& ValBlobPt = ValBlobBs->PutBlob(MOut.GetSIn());
63  	const int ValId = ValBlobPtV.Add(ValBlobPt);
64  	PValDat ValDat = TValDat::New(Val);
65      NewCacheSizeInc += int64(sizeof(TInt) + ValDat->GetMemUsed());
66  	ValCache.Put(ValId, ValDat);
67      if (NewCacheSizeInc > CacheResetThreshold) {
68          printf("Cache clean-up [%s] ... ", TUInt64::GetMegaStr(NewCacheSizeInc).CStr());
69  		ValCache.RefreshMemUsed();
70  		printf("Done\n");
71          NewCacheSizeInc = 0; 
72  	}
73  	return ValId;
74  }
75  template <class TVal>
76  void TValCache<TVal>::GetVal(const int& _ValId, TVal& Val) const {
77  	const int ValId = (int)_ValId;
78  	PValDat ValDat;
79  	if (!ValCache.Get(ValId, ValDat)) {
80  		const TBlobPt& ValBlobPt = ValBlobPtV[ValId];
81  		PSIn SIn = ValBlobBs->GetBlob(ValBlobPt); 
82  		Val.Load(*SIn);
83  		ValDat = TValDat::New(Val);
84  	} else {
85  		Val = ValDat->Val;
86  	}
87  	ValCache.Put(ValId, ValDat);
88  }
89  template <class TVal>
90  class TBlockCache {
91  private:
92  	typedef TVec<TVal> TValV;
93  	ClassTP(TBlockDat, PBlockDat)
94  	private:
95  		TBool ChangedP;
96  		TVec<TVal> ValV;
97  	public:
98  		TBlockDat(): ChangedP(true) { }
99  		static PBlockDat New() { return new TBlockDat; }
100  		TBlockDat(TSIn& SIn): ChangedP(false) { ValV.Load(SIn); }
101  		static PBlockDat Load(TSIn& SIn) { return new TBlockDat(SIn); }
102  		void Save(TSOut& SOut) const { ValV.Save(SOut); }
103  		int GetVals() const { return ValV.Len(); }
104  		bool IsFull(const int& BlockSize) const { return !(ValV.Len() < BlockSize); }
105  		int AddVal(const TVal& Val) { ChangedP = true; return ValV.Add(Val); }
106  		void SetVal(const int& ValId, const TVal& Val) { ChangedP = true; ValV[ValId] = Val; }
107  		bool IsValId(const int& ValId) const { return (ValId >= 0) && (ValId < ValV.Len()); }
108  		const TVal& GetVal(const int& ValId) const { return ValV[ValId]; }
109          int64 GetMemUsed() const {
110  			int64 MemUsed = (int64)sizeof(TVec<TVal>);
111  			for (int ValN = 0; ValN < ValV.Len(); ValN++) {
112  				MemUsed += (int64)ValV[ValN].GetMemUsed(); }
113  			return MemUsed;
114  		}
115          void OnDelFromCache(const TInt& BlockId, void* BlockCache) {
116  			if (ChangedP && !((TBlockCache*)BlockCache)->IsReadOnly()) {
117  				((TBlockCache*)BlockCache)->StoreBlock(BlockId); }
118  		}
119  	};
120  private:
121      TStr FNmPrefix;
122      TFAccess Access;
123      int64 CacheResetThreshold;
124      int64 NewCacheSizeInc;
125  	TInt Vals;
126  	TInt BlockSize;
127  	mutable TCache<TInt, PBlockDat> BlockCache;
128      TBlobPtV BlockBlobPtV;
129  	PBlobBs BlockBlobBs;
130  private:
131      void AssertReadOnly() const {
132          EAssertR(((Access==faCreate)||(Access==faUpdate)), 
133              FNmPrefix + " opened in Read-Only mode!"); }
134      void* GetVoidThis() const { return (void*)this; }
135  	void StoreBlock(const int& BlockId);
136  	int AddBlock();
137  	void GetBlock(const int& BlockId, PBlockDat& BlockDat) const;
138  	int GetLastBlock(PBlockDat& BlockDat);
139  	uint64 GetValId(const int& BlockId, const int& BlockValId) const {
140  		return (uint64)BlockId*(uint64)BlockSize + (uint64)BlockValId; }
141  	void GetBlockId(const uint64& ValId, int& BlockId, int& BlockValId) const {
142  		BlockId = (int)(ValId / (uint64)BlockSize);
143  		BlockValId = (int)(ValId % (uint64)BlockSize); 
144  	}
145  	UndefDefaultCopyAssign(TBlockCache);
146  public:
147      TBlockCache(const TStr& _FNmPrefix, const int64& MxCacheMem, const int& _BlockSize);
148      TBlockCache(const TStr& _FNmPrefix, const TFAccess& _Access, const int64& MxCacheMem);
149  	~TBlockCache();
150      bool IsReadOnly() const { return Access == faRdOnly; }
151  	uint64 AddVal(const TVal& Val);
152  	void SetVal(const uint64& ValId, const TVal& Val);
153  	int Len() const { return Vals; }
154  	bool IsValId(const uint64& ValId) const;
155  	void GetVal(const uint64& ValId, TVal& Val) const;
156  };
157  template <class TVal>
<span onclick='openModal()' class='match'>158  void TBlockCache<TVal>::StoreBlock(const int& BlockId) {
159  	AssertReadOnly();
160      PBlockDat BlockDat; EAssert(BlockCache.Get(BlockId, BlockDat));
161  	TMOut MOut; BlockDat->Save(MOut);
162  	const TBlobPt& BlockBlobPt = BlockBlobPtV[BlockId];
163  	if (BlockBlobPt.Empty()) {
164  		BlockBlobPtV[BlockId] = BlockBlobBs->PutBlob(MOut.GetSIn());
165  	} else {
</span>166  		BlockBlobPtV[BlockId] = BlockBlobBs->PutBlob(BlockBlobPt, MOut.GetSIn());
167  	}
168  }
169  template <class TVal>
170  void TBlockCache<TVal>::GetBlock(const int& BlockId, PBlockDat& BlockDat) const {
171  	if (!BlockCache.Get(BlockId, BlockDat)) {
172  		const TBlobPt& BlockBlobPt = BlockBlobPtV[(int)BlockId];
173  		PSIn SIn = BlockBlobBs->GetBlob(BlockBlobPt); 
174  		BlockDat = TBlockDat::Load(*SIn);
175  	}
176  	BlockCache.Put(BlockId, BlockDat);
177  }
178  template <class TVal>
179  int TBlockCache<TVal>::AddBlock() {
180  	PBlockDat BlockDat = TBlockDat::New();
181  	const int BlockId = BlockBlobPtV.Add(TBlobPt());
182  	BlockCache.Put(BlockId, BlockDat);
183  	NewCacheSizeInc += sizeof(TInt) + BlockDat->GetMemUsed(); 
184  	return BlockId;
185  }
186  template <class TVal>
187  int TBlockCache<TVal>::GetLastBlock(PBlockDat& BlockDat) {
188  	const int LastBlockId = BlockBlobPtV.Len()-1;
189  	GetBlock(LastBlockId, BlockDat);
190  	if (BlockDat->IsFull(BlockSize)) {
191  		const int NewBlockId = AddBlock();
192  		GetBlock(NewBlockId, BlockDat);
193  		return NewBlockId;
194  	}
195  	return LastBlockId;
196  }
197  template <class TVal>
198  TBlockCache<TVal>::TBlockCache(const TStr& _FNmPrefix, const int64& MxCacheMem,
199  		const int& _BlockSize): BlockSize(_BlockSize), BlockCache(MxCacheMem, 1000000, GetVoidThis()) {
200      FNmPrefix = _FNmPrefix;
201      Access = faCreate;
202      CacheResetThreshold = int64(0.1 * double(MxCacheMem));
203  	NewCacheSizeInc = 0;
204  	try {
205  		BlockBlobBs = TMBlobBs::New(FNmPrefix + "BlobBs", Access);
206  	} catch (...) { 
207  		TMBlobBs::New(FNmPrefix + "BlobBs", faRestore);
208  		BlockBlobBs = TMBlobBs::New(FNmPrefix + "BlobBs", Access);
209  	}
210      BlockBlobBs = TMBlobBs::New(FNmPrefix + "BlobBs", Access);
211  	EAssertR(AddBlock() == 0, "Error creating first cache block");
212  }
213  template <class TVal>
214  TBlockCache<TVal>::TBlockCache(const TStr& _FNmPrefix, const TFAccess& _Access,
215  		const int64& MxCacheMem): BlockCache(MxCacheMem, 1000000, GetVoidThis()) {
216      FNmPrefix = _FNmPrefix;
217      Access = _Access;
218      CacheResetThreshold = int64(0.1 * double(MxCacheMem));
219  	NewCacheSizeInc = 0;
220      BlockBlobBs = TMBlobBs::New(FNmPrefix + "BlobBs", Access);
221  	EAssertR(Access != faCreate, "First call create constructor!");
222  	TFIn FIn(FNmPrefix + ".Dat");
223  	Vals.Load(FIn);
224  	BlockSize.Load(FIn);
225  	BlockBlobPtV.Load(FIn);
226  }
227  template <class TVal>
228  TBlockCache<TVal>::~TBlockCache() {
229      if ((Access == faCreate) || (Access == faUpdate)) {
230          BlockCache.Flush();
231          TFOut FOut(FNmPrefix + ".Dat");
232  		Vals.Save(FOut);
233  		BlockSize.Save(FOut);
234  		BlockBlobPtV.Save(FOut);
235      }
236  }
237  template <class TVal>
238  uint64 TBlockCache<TVal>::AddVal(const TVal& Val) {
239  	PBlockDat BlockDat; 
240  	const int BlockId = GetLastBlock(BlockDat);
241  	const int BlockValId = BlockDat->AddVal(Val);
242      NewCacheSizeInc += BlockDat->GetVal(BlockValId).GetMemUsed();
243      if (NewCacheSizeInc > CacheResetThreshold) {
244          printf("Cache clean-up [%s] ... ", TUInt64::GetMegaStr(NewCacheSizeInc).CStr());
245  		BlockCache.RefreshMemUsed();
246  		printf("Done\n");
247          NewCacheSizeInc = 0; 
248  	}
249  	Vals++;
250  	return GetValId(BlockId, BlockValId);
251  }
252  template <class TVal>
253  void TBlockCache<TVal>::SetVal(const uint64& ValId, const TVal& Val) {
254  	int BlockId = -1, BlockValId = -1;
255  	GetBlockId(ValId, BlockId, BlockValId);
256  	PBlockDat BlockDat; GetBlock(BlockId, BlockDat);
257  	BlockDat->SetVal(BlockValId, Val);
258  }
259  template <class TVal>
260  bool TBlockCache<TVal>::IsValId(const uint64& ValId) const { 
261  	int BlockId = -1, BlockValId = -1;
262  	GetBlockId(ValId, BlockId, BlockValId);
263  	if (BlockId < 0 || BlockId >= BlockBlobPtV.Len()) { return false; }
264  	PBlockDat BlockDat; GetBlock(BlockId, BlockDat);
265  	return BlockDat->IsValId(BlockValId);	
266  }
267  template <class TVal>
268  void TBlockCache<TVal>::GetVal(const uint64& ValId, TVal& Val) const {
269  	int BlockId = -1, BlockValId = -1;
270  	GetBlockId(ValId, BlockId, BlockValId);
271  	PBlockDat BlockDat; GetBlock(BlockId, BlockDat);
272  	Val = BlockDat->GetVal(BlockValId);
273  }
274  template <class TVal>
275  class TWndBlockCache {
276  private:
277  	typedef TVec<TVal> TValV;
278  	ClassTP(TBlockDat, PBlockDat)
279  	private:
280  		TBool ChangedP;
281  		TVec<TVal> ValV;
282  	public:
283  		TBlockDat(): ChangedP(true) { }
284  		static PBlockDat New() { return new TBlockDat; }
285  		TBlockDat(TSIn& SIn): ChangedP(false) { ValV.Load(SIn); }
286  		static PBlockDat Load(TSIn& SIn) { return new TBlockDat(SIn); }
287  		void Save(TSOut& SOut) const { ValV.Save(SOut); }
288  		int GetVals() const { return ValV.Len(); }
289  		bool IsFull(const int& BlockSize) const { return !(ValV.Len() < BlockSize); }
290  		int AddVal(const TVal& Val) { ChangedP = true; return ValV.Add(Val); }
291  		void SetVal(const int& ValId, const TVal& Val) { ChangedP = true; ValV[ValId] = Val; }
292  		bool IsValId(const int& ValId) const { return (ValId >= 0) && (ValId < ValV.Len()); }
293  		const TVal& GetVal(const int& ValId) const { return ValV[ValId]; }
294  		int64 GetMemUsed() const {
295  			int64 MemUsed = (int64)sizeof(TVec<TVal>);
296  			for (int ValN = 0; ValN < ValV.Len(); ValN++) {
297  				MemUsed += (int64)ValV[ValN].GetMemUsed(); }
298  			return MemUsed;
299  		}
300  		void OnDelFromCache(const TInt& BlockId, void* WndBlockCache) {
301  			if (ChangedP && !((TWndBlockCache*)WndBlockCache)->IsReadOnly()) {
302  				((TWndBlockCache*)WndBlockCache)->StoreBlock(BlockId); }
303  		}
304  	};
305  private:
306  	TStr FNmPrefix;
307  	TFAccess Access;
308  	int64 CacheResetThreshold;
309  	int64 NewCacheSizeInc;
310  	TInt Vals;
311  	TInt BlockSize;
312  	mutable TCache<TInt, PBlockDat> BlockCache;
313  	TBlobPtV BlockBlobPtV;
314  	PBlobBs BlockBlobBs;
315  	TInt FirstBlockOffset;
316  	TInt FirstValOffset;
317  private:
318  	void AssertReadOnly() const {
319  		EAssertR(((Access==faCreate)||(Access==faUpdate)), FNmPrefix + " opened in Read-Only mode!"); 
320  	}
321  	void* GetVoidThis() const { return (void*)this; }
322  	void StoreBlock(const int& BlockId);
323  	int AddBlock();
324  	void GetBlock(const int& BlockId, PBlockDat& BlockDat) const;
325  	int GetLastBlock(PBlockDat& BlockDat);
326  	void DelBlock();
327  	uint64 GetValId(const int& BlockId, const int& BlockValId) const {
328  		return (uint64)BlockId*(uint64)BlockSize + (uint64)BlockValId; 
329  	}
330  	void GetBlockId(const uint64& ValId, int& BlockId, int& BlockValId) const {
331  		BlockId = (int)(ValId / (uint64)BlockSize);
332  		BlockValId = (int)(ValId % (uint64)BlockSize); 
333  	}
334  public:
335  	TWndBlockCache(const TStr& _FNmPrefix, const int64& MxCacheMem, const int& _BlockSize);
336  	TWndBlockCache(const TStr& _FNmPrefix, const TFAccess& _Access, const int64& MxCacheMem);
337  	~TWndBlockCache();
338  	bool IsReadOnly() const { return Access == faRdOnly; }
339  	uint64 AddVal(const TVal& Val);
340  	void SetVal(const uint64& ValId, const TVal& Val);
341  	bool Empty() const { return Vals == 0; }
342  	int Len() const { return Vals; }
343  	uint64 GetFirstValId() const;
344  	uint64 GetLastValId() const;
345  	bool IsValId(const uint64& ValId) const;
346  	void GetVal(const uint64& ValId, TVal& Val) const;	
347  	uint64 GetFirstVal(TVal& Val) const;	
348  	bool DelVal();
349  	int DelVals(const int& _Vals);
350  };
351  template <class TVal>
352  void TWndBlockCache<TVal>::StoreBlock(const int& BlockId) {
353  	AssertReadOnly();
354  	PBlockDat BlockDat; 
355  	EAssert(BlockCache.Get(BlockId, BlockDat));
356  	TMOut MOut; 
357  	BlockDat->Save(MOut);
358  	int _BlockId = BlockId - FirstBlockOffset;
359  	const TBlobPt& BlockBlobPt = BlockBlobPtV[_BlockId];
360  	if (BlockBlobPt.Empty()) {
361  		BlockBlobPtV[_BlockId] = BlockBlobBs->PutBlob(MOut.GetSIn());
362  	} else {
363  		BlockBlobPtV[_BlockId] = BlockBlobBs->PutBlob(BlockBlobPt, MOut.GetSIn());
364  	}
365  }
366  template <class TVal>
367  void TWndBlockCache<TVal>::GetBlock(const int& BlockId, PBlockDat& BlockDat) const {
368  	if (!BlockCache.Get(BlockId, BlockDat)) {
369  		int _BlockId = BlockId - FirstBlockOffset;
370  		const TBlobPt& BlockBlobPt = BlockBlobPtV[_BlockId];
371  		PSIn SIn = BlockBlobBs->GetBlob(BlockBlobPt); 
372  		BlockDat = TBlockDat::Load(*SIn);
373  	}
374  	BlockCache.Put(BlockId, BlockDat);
375  }
376  template <class TVal>
377  int TWndBlockCache<TVal>::AddBlock() {
378  	PBlockDat BlockDat = TBlockDat::New();
379  	const int BlockId = BlockBlobPtV.Add(TBlobPt()) + FirstBlockOffset;
380  	BlockCache.Put(BlockId, BlockDat);
381  	NewCacheSizeInc += sizeof(TInt) + BlockDat->GetMemUsed(); 
382  	return BlockId;
383  }
384  template <class TVal>
385  int TWndBlockCache<TVal>::GetLastBlock(PBlockDat& BlockDat) {
386  	const int LastBlockId = BlockBlobPtV.Len() - 1 + FirstBlockOffset;
387  	GetBlock(LastBlockId, BlockDat);
388  	if (BlockDat->IsFull(BlockSize)) {
389  		const int NewBlockId = AddBlock();
390  		GetBlock(NewBlockId, BlockDat);
391  		return NewBlockId;
392  	}
393  	return LastBlockId;
394  }
395  template <class TVal>
396  void TWndBlockCache<TVal>::DelBlock() { 
397  	const int FirstBlockId = FirstBlockOffset;
398  	BlockCache.Del(FirstBlockId, false);
399  	if (!BlockBlobPtV[0].Empty()) { 
400  		BlockBlobBs->DelBlob(BlockBlobPtV[0]);
401  	}
402  	BlockBlobPtV.Del(0);
403  }
404  template <class TVal>
405  TWndBlockCache<TVal>::TWndBlockCache(const TStr& _FNmPrefix, const int64& MxCacheMem, 
406  		const int& _BlockSize): BlockSize(_BlockSize), BlockCache(MxCacheMem, 1000000, GetVoidThis()) {
407  	FNmPrefix = _FNmPrefix;
408  	Access = faCreate;
409  	CacheResetThreshold = int64(0.1 * double(MxCacheMem));
410  	NewCacheSizeInc = 0;
411  	try {
412  		BlockBlobBs = TMBlobBs::New(FNmPrefix + "BlobBs", Access);
413  	} catch (...) { 
414  		TMBlobBs::New(FNmPrefix + "BlobBs", faRestore);
415  		BlockBlobBs = TMBlobBs::New(FNmPrefix + "BlobBs", Access);
416  	}
417  	EAssertR(AddBlock() == 0, "Error creating first cache block");
418  }
419  template <class TVal>
420  TWndBlockCache<TVal>::TWndBlockCache(const TStr& _FNmPrefix, const TFAccess& _Access,
421  		const int64& MxCacheMem): BlockCache(MxCacheMem, 1000000, GetVoidThis()) {
422  	FNmPrefix = _FNmPrefix;
423  	Access = _Access;
424  	CacheResetThreshold = int64(0.1 * double(MxCacheMem));
425  	NewCacheSizeInc = 0;
426  	BlockBlobBs = TMBlobBs::New(FNmPrefix + "BlobBs", Access);
427  	EAssertR(Access != faCreate, "First call create constructor!");
428  	TFIn FIn(FNmPrefix + ".Dat");
429  	Vals.Load(FIn);
430  	BlockSize.Load(FIn);
431  	BlockBlobPtV.Load(FIn);		
432  	FirstBlockOffset.Load(FIn);
433  	FirstValOffset.Load(FIn);
434  }
435  template <class TVal>
436  TWndBlockCache<TVal>::~TWndBlockCache() {
437  	if ((Access == faCreate) || (Access == faUpdate)) {
438  		BlockCache.Flush();
439  		TFOut FOut(FNmPrefix + ".Dat");		    
440  		Vals.Save(FOut);
441  		BlockSize.Save(FOut);
442  		BlockBlobPtV.Save(FOut);
443  		FirstBlockOffset.Save(FOut);
444  		FirstValOffset.Save(FOut);
445  	}
446  }
447  template <class TVal>
448  uint64 TWndBlockCache<TVal>::AddVal(const TVal& Val) {
449  	PBlockDat BlockDat; 
450  	const int BlockId = GetLastBlock(BlockDat);
451  	const int BlockValId = BlockDat->AddVal(Val);
452  	NewCacheSizeInc += BlockDat->GetVal(BlockValId).GetMemUsed();
453  	if (NewCacheSizeInc > CacheResetThreshold) {
454  		printf("Cache clean-up [%s] ... ", TUInt64::GetMegaStr(NewCacheSizeInc).CStr());
455  		BlockCache.RefreshMemUsed();
456  		printf("Done\n");
457  		NewCacheSizeInc = 0; 
458  	}
459  	Vals++;
460  	return GetValId(BlockId, BlockValId); 
461  }
462  template <class TVal>
463  void TWndBlockCache<TVal>::SetVal(const uint64& ValId, const TVal& Val) {
464  	int BlockId = -1, BlockValId = -1;
465  	GetBlockId(ValId, BlockId, BlockValId);
466  	PBlockDat BlockDat;
467  	GetBlock(BlockId, BlockDat);
468  	BlockDat->SetVal(BlockValId, Val);
469  }
470  template <class TVal>
471  uint64 TWndBlockCache<TVal>::GetFirstValId() const { 
472  	return (uint64)BlockSize * (uint64)FirstBlockOffset + (uint64)FirstValOffset;
473  }
474  template <class TVal>
475  uint64 TWndBlockCache<TVal>::GetLastValId() const { 
476  	return GetFirstValId() + Len() - 1; 
477  }
478  template <class TVal>
479  bool TWndBlockCache<TVal>::IsValId(const uint64& ValId) const { 
480  	int BlockId = -1, BlockValId = -1;
481  	GetBlockId(ValId, BlockId, BlockValId);
482  	if (BlockId < FirstBlockOffset) { return false; }
483  	if (BlockId >= (BlockBlobPtV.Len() + FirstBlockOffset)) { return false; }
484  	if (BlockId == FirstBlockOffset && BlockValId < FirstValOffset) { return false; }
485  	PBlockDat BlockDat; GetBlock(BlockId, BlockDat);
486  	return BlockDat->IsValId(BlockValId);
487  }
488  template <class TVal>
489  uint64 TWndBlockCache<TVal>::GetFirstVal(TVal& Val) const {
490  	int BlockId = FirstBlockOffset, BlockValId = FirstValOffset;
491  	PBlockDat BlockDat;
492  	GetBlock(BlockId, BlockDat);
493  	Val = BlockDat->GetVal(BlockValId);
494  	return (uint64)FirstBlockOffset * (uint64)BlockSize + (uint64)FirstValOffset;
495  }
496  template <class TVal>
497  void TWndBlockCache<TVal>::GetVal(const uint64& ValId, TVal& Val) const {
498  	int BlockId = -1, BlockValId = -1;
499  	GetBlockId(ValId, BlockId, BlockValId);
500  	PBlockDat BlockDat;
501  	GetBlock(BlockId, BlockDat);
502  	Val = BlockDat->GetVal(BlockValId);
503  }
504  template <class TVal>
505  bool TWndBlockCache<TVal>::DelVal() {		
506  	if (Empty()) { return false; }
507  	FirstValOffset++; Vals--;
508  	if (FirstValOffset >= BlockSize) {
509  		DelBlock();
510  		FirstBlockOffset++;
511  		FirstValOffset = 0;
512  	}
513  	return true;
514  }
515  template <class TVal>
516  int TWndBlockCache<TVal>::DelVals(const int& _Vals) {
517  	int DeletedVals = 0;
518  	for (int ValN = 0; ValN < _Vals; ValN++) {
519  		if (!DelVal()) { break; }
520  		DeletedVals++;
521  	}
522  	return DeletedVals;
523  }
524  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-death-test.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cache.h</div>
                <div class="column column_space"><pre><code>317        if (status_ok) {
318          const bool matched = RE::PartialMatch(error_message.c_str(), *regex());
319          if (matched) {
320            success = true;
321          } else {
</pre></code></div>
                <div class="column column_space"><pre><code>158  void TBlockCache<TVal>::StoreBlock(const int& BlockId) {
159  	AssertReadOnly();
160      PBlockDat BlockDat; EAssert(BlockCache.Get(BlockId, BlockDat));
161  	TMOut MOut; BlockDat->Save(MOut);
162  	const TBlobPt& BlockBlobPt = BlockBlobPtV[BlockId];
163  	if (BlockBlobPt.Empty()) {
164  		BlockBlobPtV[BlockId] = BlockBlobBs->PutBlob(MOut.GetSIn());
165  	} else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    