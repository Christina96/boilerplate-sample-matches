
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.73448496481126%, Tokens: 18</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-stemming.h</h3>
            <pre><code>1  typedef enum {stmtNone, stmtPorter} TStemmerType;
2  ClassTP(TStemmer, PStemmer)
3  private:
4    TInt StemmerType; 
5    TBool RealWordP;
6    TStrStrH StemStrToRealWordStrH;
7    TStrStrH SynonymStrToWordStr;
8  public:
9    TStemmer(
10     const TStemmerType& _StemmerType=stmtNone, const bool& _RealWordP=false):
11      StemmerType(_StemmerType), RealWordP(_RealWordP),
12      StemStrToRealWordStrH(), SynonymStrToWordStr(){}
13    static PStemmer New(
<span onclick='openModal()' class='match'>14     const TStemmerType& StemmerType=stmtNone, const bool& RealWordP=false){
15      return PStemmer(new TStemmer(StemmerType, RealWordP));}
16    TStemmer(TSIn& SIn):
17      StemmerType(SIn), RealWordP(SIn),
18      StemStrToRealWordStrH(SIn), SynonymStrToWordStr(SIn){}
19    static PStemmer Load(TSIn& SIn){return new TStemmer(SIn);}
20    void Save(TSOut& SOut) const {
21      StemmerType.Save(SOut); RealWordP.Save(SOut);
22      StemStrToRealWordStrH.Save(SOut); SynonymStrToWordStr.Save(SOut);}
23    TStemmer& operator=(const TStemmer& Stemmer){
</span>24      StemmerType=Stemmer.StemmerType;
25      RealWordP=Stemmer.RealWordP;
26      StemStrToRealWordStrH=Stemmer.StemStrToRealWordStrH;
27      SynonymStrToWordStr=Stemmer.SynonymStrToWordStr;
28      return *this;}
29    void AddSynonym(const TStr& SynonymStr, const TStr& WordStr){
30      SynonymStrToWordStr.AddDat(SynonymStr.GetUc(), WordStr.GetUc());}
31    TStr GetStem(const TStr& WordStr);
32    TStemmerType GetStemmerType(){
33      return (TStemmerType)(int)StemmerType;}
34    static void GetStemmerTypeNmV(TStrV& StemmerTypeNmV, TStrV& StemmerTypeDNmV);
35    static TStr GetStemmerTypeNmVStr();
36    static TStemmerType GetStemmerType(const TStr& StemmerTypeNm);
37    static PStemmer GetStemmer(const TStemmerType& StemmerType){
38      return TStemmer::New(StemmerType, true);}
39    static PStemmer GetStemmer(const bool& StemmerP, const TStemmerType& StemmerType){
40      if (StemmerP){return GetStemmer(StemmerType);} else {return NULL;}}
41    static PStemmer GetStemmer(const TStr& StemmerTypeNm){
42      return GetStemmer(true, GetStemmerType(StemmerTypeNm));}
43  };
44  class TPorterStemmer{
45  protected:
46    static inline bool IsVowel(bool prevVowel, char ch) { return ch == 'E' ||
47      ch == 'O' || ch == 'A' || ch == 'I' || ch == 'U' || (ch == 'Y' && ! prevVowel); }
48    static inline int Measure(const char *pStart, const char *pEnd){
49      if (pStart == pEnd) return 0;
50      int m = 0; bool vowel = IsVowel(true, *pStart++);
51      while (pStart < pEnd)
52      {
53        bool newVowel = IsVowel(vowel, *pStart++);
54        if (vowel && ! newVowel) m++;
55        vowel = newVowel;
56      }
57      return m;
58    }
59    static inline bool MeasureG0(const char *pStart, const char *pEnd){
60      if (pEnd <= pStart) return false; 
61      bool vowel = IsVowel(true, *pStart++);
62      while (pStart < pEnd)
63      {
64        bool newVowel = IsVowel(vowel, *pStart++);
65        if (vowel && ! newVowel) return true;
66        vowel = newVowel;
67      }
68      return false;
69    }
70    static inline bool HasVowels(const char *pStart, const char *pEnd){
71      bool vowel = true;
72      while (pStart < pEnd)
73        { vowel = IsVowel(vowel, *pStart++); if (vowel) return true; }
74      return false;
75    }
76    static inline bool EndsWithDoubleConsonant(const char *pStart, const char *pEnd){
77      if (pEnd - pStart < 2) return false;
78      char ch = pEnd[-1];
79      if (pEnd[-2] != ch) return false;
80      return !(ch == 'E' || ch == 'A' || ch == 'O' || ch == 'I' || ch == 'U' || ch == 'Y');
81    }
82    static inline bool IsCvc(const char *pStart, const char *pEnd){
83      if (pEnd - pStart < 3) return false;
84      bool vowel = IsVowel(true, *pStart); if (vowel) return false;
85      while (pStart < pEnd && ! vowel) vowel = IsVowel(vowel, *(++pStart));
86      if (pStart != pEnd - 2) return false;
87      vowel = IsVowel(vowel, *(++pStart));
88      if (vowel) return false;
89      char last = *pStart++;
90      return !(last == 'W' || last == 'X' || last == 'Y');
91    }
92  public:
93    static char *StemInPlace(char *pWord); 
94    static TStr Stem(const TStr& s); 
95    static TStr StemX(const TStr& s); 
96  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowbs.h</h3>
            <pre><code>1  ClassHdTP(TBowDocBs, PBowDocBs);
2  ClassTP(TBowKWordSet, PBowKWordSet)
3  private:
4    TStr Nm;
5    THash<TStr, TFlt> WStrToWWgtH;
6  public:
7    TBowKWordSet(const TStr& _Nm=""): Nm(_Nm), WStrToWWgtH(){}
8    static PBowKWordSet New(const TStr& Nm=""){return new TBowKWordSet(Nm);}
9    TBowKWordSet(const TBowKWordSet& BowKWordSet):
10      Nm(BowKWordSet.Nm), WStrToWWgtH(BowKWordSet.WStrToWWgtH){}
11    TBowKWordSet(TSIn& SIn): Nm(SIn), WStrToWWgtH(SIn){}
12    static PBowKWordSet Load(TSIn& SIn){return new TBowKWordSet(SIn);}
13    void Save(TSOut& SOut) const {Nm.Save(SOut); WStrToWWgtH.Save(SOut);}
14    TBowKWordSet& operator=(const TBowKWordSet& BowKWordSet){
15      Nm=BowKWordSet.Nm; WStrToWWgtH=BowKWordSet.WStrToWWgtH; return *this;}
16    void PutNm(const TStr& _Nm){Nm=_Nm;}
17    TStr GetNm() const {return Nm;}
18    void AddKWord(const TStr& KWordStr, const double& KWordWgt){
19      WStrToWWgtH.AddDat(KWordStr, KWordWgt);}
20    int GetKWords() const {return WStrToWWgtH.Len();}
21    bool IsKWordStr(const TStr& KWordStr) const {return WStrToWWgtH.IsKey(KWordStr);}
22    int GetKWordN(const TStr& KWordStr) const {return WStrToWWgtH.GetKeyId(KWordStr);}
23    TStr GetKWordStr(const int& KWordN) const {return WStrToWWgtH.GetKey(KWordN);}
24    double GetKWordWgt(const int& KWordN) const {return WStrToWWgtH[KWordN];}
25    void GetWordStrV(TStrV& WordStrV) const;
26    TStr GetKWordsStr() const;
27    void SortByStr();
28    void SortByWgt();
29    PBowKWordSet GetTopKWords(const int& MxKWords, const double& WgtSumPrc) const;
30    void SaveTxt(const PSOut& SOut) const;
31    void SaveTxt(const TStr& FNm) const {
32      PSOut SOut=TFOut::New(FNm); SaveTxt(SOut);}
33    void SaveXml(const PSOut& SOut) const;
34    void SaveXml(const TStr& FNm) const {
35      PSOut SOut=TFOut::New(FNm); SaveXml(SOut);}
36    void SaveBin(const PSOut& SOut) const {
37      Save(*SOut);}
38    void SaveBin(const TStr& FNm) const {
39      PSOut SOut=TFOut::New(FNm); SaveBin(SOut);}
40  };
41  ClassTP(TBowKWordBs, PBowKWordBs)
42  private:
43    THash<TStr, PBowKWordSet> SetNmToSetH;
44  public:
45    TBowKWordBs(): SetNmToSetH(){}
46    static PBowKWordBs New(){return new TBowKWordBs();}
47    TBowKWordBs(const TBowKWordBs& BowKWordBs):
48      SetNmToSetH(BowKWordBs.SetNmToSetH){}
49    TBowKWordBs(TSIn& SIn): SetNmToSetH(SIn){}
50    static PBowKWordBs Load(TSIn& SIn){return new TBowKWordBs(SIn);}
51    void Save(TSOut& SOut) const {SetNmToSetH.Save(SOut);}
52    TBowKWordBs& operator=(const TBowKWordBs& BowKWordBs){
53      SetNmToSetH=BowKWordBs.SetNmToSetH; return *this;}
54    void AddKWordSet(const TStr& KWordSetNm, const PBowKWordSet& KWordSet){
55      SetNmToSetH.AddDat(KWordSetNm, KWordSet);}
56    void AddKWordSet(const PBowKWordSet& KWordSet){
57      SetNmToSetH.AddDat(KWordSet->GetNm(), KWordSet);}
58    int GetKWordSets() const {return SetNmToSetH.Len();}
59    bool IsKWordSset(const TStr& KWordSetNm) const {return SetNmToSetH.IsKey(KWordSetNm);}
60    PBowKWordSet GetKWordSet(const int& KWordSetN) const {return SetNmToSetH[KWordSetN];}
61    PBowKWordSet GetKWordSet(const TStr& KWordSetNm) const {return SetNmToSetH.GetDat(KWordSetNm);}
62    void SaveTxt(const PSOut& SOut) const;
63    void SaveTxt(const TStr& FNm) const {
64      PSOut SOut=TFOut::New(FNm); SaveTxt(SOut);}
65    void SaveXml(const PSOut& SOut) const;
66    void SaveXml(const TStr& FNm) const {
67      PSOut SOut=TFOut::New(FNm); SaveXml(SOut);}
68    static PBowKWordBs LoadBin(const TStr& FNm){
69      TFIn SIn(FNm); return Load(SIn);}
70    void SaveBin(const PSOut& SOut) const {
71      Save(*SOut);}
72    void SaveBin(const TStr& FNm) const {
73      PSOut SOut=TFOut::New(FNm); SaveBin(SOut);}
74  };
75  typedef TIntSFltKd TBowWIdWgtKd;
76  typedef TBowWIdWgtKd* PBowWIdWgtKd;
77  typedef TVec<TBowWIdWgtKd> TBowWIdWgtKdV;
78  typedef TVec<TBowWIdWgtKdV> TBowWIdWgtKdVV;
79  ClassTPV(TBowSpV, PBowSpV, TBowSpVV)
80  private:
81    TInt DId;
82    TFlt Norm;
83    TBowWIdWgtKdV WIdWgtKdV;
84    UndefCopyAssign(TBowSpV);
85  public:
86    TBowSpV(const int& _DId=-1, const int& ExpWIds=0):
87      DId(_DId), Norm(-1), WIdWgtKdV(ExpWIds, 0){}
88    static PBowSpV New(const int& DId=-1, const int& ExpWIds=0){
89      return PBowSpV(new TBowSpV(DId, ExpWIds));}
90    TBowSpV(const int& DId, const TFltV& FullVec, const double& Eps=1e-14);
91    static PBowSpV New(const int& DId, const TFltV& FullVec,
92      const double& Eps=1e-14) { return PBowSpV(new TBowSpV(DId, FullVec, Eps));}
93    TBowSpV(const int& DId, const TIntFltKdV& SpV);
94    static PBowSpV New(const int& DId, const TIntFltKdV& SpV) {
95      return PBowSpV(new TBowSpV(DId, SpV));}
96    TBowSpV(TSIn& SIn):
97      DId(SIn), Norm(SIn), WIdWgtKdV(SIn){}
98    static PBowSpV Load(TSIn& SIn){return new TBowSpV(SIn);}
99    void Save(TSOut& SOut) const {
100      DId.Save(SOut); Norm.Save(SOut); WIdWgtKdV.Save(SOut);}
101    void Clr(){DId=-1; WIdWgtKdV.Clr();}
102    void GenMx(const int& MxWIds){WIdWgtKdV.Gen(MxWIds, 0);}
103    void Sort(){WIdWgtKdV.Sort();}
104    void Trunc(){WIdWgtKdV.Trunc();}
105    int Len() const {return WIdWgtKdV.Len();}
106    int Reserved() const {return WIdWgtKdV.Reserved();}
107    void PutDId(const int& _DId){DId=_DId;}
108    int GetDId() const {return DId;}
109    bool IsDId() const {return DId!=-1;}
110    PBowWIdWgtKd BegI() const {return WIdWgtKdV.BegI();}
111    PBowWIdWgtKd EndI() const {return WIdWgtKdV.EndI();}
112    PBowWIdWgtKd GetI(const int& ValN) const {return WIdWgtKdV.GetI(ValN);}
113    void AssignNorm(const double& _Norm){Norm=_Norm;}
114    void PutUnitNorm();
115    double GetNorm();
116    void AddWIdWgt(const int& WId, const double& Wgt){
117      WIdWgtKdV.Add(TBowWIdWgtKd(WId, (sdouble)Wgt));}
118    int GetWIds() const {return WIdWgtKdV.Len();}
119    int GetWIdN(const int& WId) const {return WIdWgtKdV.SearchForw(TBowWIdWgtKd(WId));}
120    bool IsWId(const int& WId) const {return WIdWgtKdV.SearchForw(TBowWIdWgtKd(WId))!=-1;}
121    int GetWId(const int& WIdN) const {return WIdWgtKdV[WIdN].Key;}
122    TSFlt& GetWgt(const int& WIdN){return WIdWgtKdV[WIdN].Dat;}
123    void GetWIdWgt(const int& WIdN, int& WId, double& Wgt) const {
124      const TBowWIdWgtKd& WIdWgtKd=WIdWgtKdV[WIdN];
125      WId=WIdWgtKd.Key; Wgt=WIdWgtKd.Dat;}
126    void GetWordStrWgtPrV(const PBowDocBs& BowDocBs,
127     const int& TopWords, const double& TopWordsWgtPrc,
128     TStrFltPrV& WordStrWgtPrV) const;
129    PBowKWordSet GetKWordSet(const PBowDocBs& BowDocBs) const;
130    int GetLastWId() const { return WIdWgtKdV.Last().Key; }
131    void GetIntFltKdV(TIntFltKdV& SpV) const;
132    void CutLowWgtWords(const double& CutWordWgtSumPrc);
133    TStr GetStr(const PBowDocBs& BowDocBs,
134     const int& TopWords=-1, const double& TopWordsWgtPrc=1, const TStr& SepStr=" ",
135     const bool& ShowWeightsP=true, const bool& KeepUndelineP=true) const;
136    void SaveTxt(const PSOut& SOut, const PBowDocBs& BowDocBs,
137     const int& TopWords=-1, const double& TopWordsWgtPrc=1,
138     const char& SepCh=' ') const;
139    void SaveXml(const PSOut& SOut, const PBowDocBs& BowDocBs) const;
140  };
141  ClassTP(TBowSimMtx, PBowSimMtx)
142  private:
143    TIntV MtxDIdV;
144    TIntPrFltH DIdPrToSimH;
145  public:
146    TBowSimMtx(): MtxDIdV(), DIdPrToSimH(){}
<span onclick='openModal()' class='match'>147    static PBowSimMtx New(){return new TBowSimMtx();}
148    TBowSimMtx(TSIn& SIn): MtxDIdV(SIn), DIdPrToSimH(SIn){}
149    static PBowSimMtx Load(TSIn& SIn){return new TBowSimMtx(SIn);}
150    void Save(TSOut& SOut) const {MtxDIdV.Save(SOut); DIdPrToSimH.Save(SOut);}
151    TBowSimMtx& operator=(const TBowSimMtx&){Fail; return *this;}
</span>152    int GetDocs() const {return MtxDIdV.Len();}
153    int GetMtxDId(const int& MtxDIdN) const {return MtxDIdV[MtxDIdN];}
154    void GetDIdV(TIntV& _MtxDIdV) const {_MtxDIdV=MtxDIdV;}
155    double GetSim(const int& DId1, const int& DId2) const;
156    static PBowSimMtx LoadTxt(const TStr& FNm);
157  };
158  typedef enum {bstUndef, bstBlock, bstEucl, bstCos, bstMtx} TBowSimType;
159  ClassTP(TBowSim, PBowSim)
160  private:
161    TInt SimType; 
162    PBowSimMtx SimMtx;
163  public:
164    TBowSim(const TBowSimType& _Type=bstUndef, const PBowSimMtx& _SimMtx=NULL):
165      SimType(_Type), SimMtx(_SimMtx){}
166    static PBowSim New(const TBowSimType& SimType, const PBowSimMtx& SimMtx=NULL){
167      return new TBowSim(SimType, SimMtx);}
168    TBowSim(TSIn& SIn): SimType(SIn), SimMtx(SIn){}
169    static PBowSim Load(TSIn& SIn){return new TBowSim(SIn);}
170    void Save(TSOut& SOut) const {SimType.Save(SOut); SimMtx.Save(SOut);}
171    TBowSim& operator=(const TBowSim&){Fail; return *this;}
172    TBowSimType GetSimType() const {return TBowSimType(int(SimType));}
173    double GetSim(const int& DId1, const int& DId2) const;
174    double GetSim(const PBowSpV& SpV1, const PBowSpV& SpV2) const;
175    double GetSim(const TBowSpVV& SpVV1, const TBowSpVV& SpVV2) const;
176    static double GetBlockSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
177    static double GetEuclSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
178    static double GetCosSim(const PBowSpV& SpV1, const PBowSpV& SpV2);
179    static double GetCosSim(const PBowSpV& SpV1, const PBowSpV& SpV2,
180     TFltIntPrV& WgtWIdPrV);
181    static TBowSimType GetSimType(const TStr& Nm);
182  };
183  typedef enum {bwwtUndef,
184    bwwtEq, 
185    bwwtNrmEq, 
186    bwwtBin, 
187    bwwtNrmBin, 
188    bwwtNrm01, 
189    bwwtNrmTFIDF, 
190    bwwtLogDFNrmTFIDF, 
191    bwwtNrmTFICF, 
192    bwwtPreCalc, 
193    bwwtSvm 
194  } TBowWordWgtType;
195  ClassTP(TBowDocWgtBs, PBowDocWgtBs)
196  private:
197    TInt Sig; 
198    TInt BowDocBsSig; 
199    TInt WordWgtType;
200    TFlt CutWordWgtSumPrc;
201    TInt MnWordFq;
202    TIntV DIdV;
203    TFltV WordFqV;
204    TBowSpVV DocSpVV;
205  public:
206    TBowDocWgtBs(const int& _BowDocBsSig):
207      Sig(TSecTm::GetCurTm().GetAbsSecs()), BowDocBsSig(_BowDocBsSig),
208      WordWgtType(), CutWordWgtSumPrc(), MnWordFq(),
209      DIdV(), WordFqV(), DocSpVV(){}
210    static PBowDocWgtBs New(const int& BowDocBsSig){
211      return PBowDocWgtBs(new TBowDocWgtBs(BowDocBsSig));}
212    static PBowDocWgtBs New(
213     const PBowDocBs& BowDocBs, const TBowWordWgtType& _WordWgtType,
214     const double& _CutWordWgtSumPrc=0, const int& _MnWordFq=0,
215     const TIntV& _DIdV=TIntV(), const TIntV& BaseDIdV=TIntV(),
216     const PNotify& Notify=TNotify::NullNotify);
217    static PBowDocWgtBs New(const TVec<PBowSpV>& BowSpVV);
218    static PBowDocWgtBs NewPreCalcWgt(const PBowDocBs& BowDocBs,
219     const TFltV& WordWgtV, const bool& PutUniteNorm = false,
220     const double& _CutWordWgtSumPrc=0, const int& _MnWordFq=0,
221     const TIntV& _DIdV=TIntV());
222    static PBowDocWgtBs NewSvmWgt(
223     const PBowDocBs& BowDocBs,
224     const PBowDocWgtBs& BowDocWgtBs,
225     const TIntV& _TrainDIdV = TIntV(),
226     const double& SvmCostParam = 1.0,
227     const int& MxTimePerCat = 60,
228     const bool& NegFeaturesP = false,
229     const TIntV& _DIdV = TIntV(),
230     const bool& PutUniteNormP = false,
231     const double& _CutWordWgtSumPrc = 0.0,
232     const int& _MnWordFq = 0);
233    static PBowDocWgtBs NewBinSvmWgt(
234     const PBowDocBs& BowDocBs,
235     const PBowDocWgtBs& BowDocWgtBs,
236     const TStr& CatNm,
237     const TIntV& TrainDIdV = TIntV(),
238     const double& SvmCostParam = 1.0,
239     const double& SvmUnbalanceParam = 1.0,
240     const double& MnWgt = 0.0,
241     const bool& NegFeaturesP = false,
242     const bool& PutUniteNormP = true,
243     const bool& AvgNormalP = true,
244     const TIntV& _DIdV = TIntV(),
245     const double& _CutWordWgtSumPrc = 0.0,
246     const int& _MnWordFq = 0);
247    TBowDocWgtBs(TSIn& SIn):
248      Sig(SIn), BowDocBsSig(SIn),
249      WordWgtType(SIn), CutWordWgtSumPrc(SIn), MnWordFq(SIn),
250      DIdV(SIn), WordFqV(SIn), DocSpVV(SIn){}
251    static PBowDocWgtBs Load(TSIn& SIn){return new TBowDocWgtBs(SIn);}
252    void Save(TSOut& SOut) const {
253      Sig.Save(SOut); BowDocBsSig.Save(SOut);
254      WordWgtType.Save(SOut); CutWordWgtSumPrc.Save(SOut); MnWordFq.Save(SOut);
255      DIdV.Save(SOut); WordFqV.Save(SOut); DocSpVV.Save(SOut);}
256    TBowDocWgtBs& operator=(const TBowDocWgtBs& BowDocWgtBs){
257      Sig=BowDocWgtBs.Sig;
258      BowDocBsSig=BowDocWgtBs.BowDocBsSig;
259      WordWgtType=BowDocWgtBs.WordWgtType;
260      CutWordWgtSumPrc=BowDocWgtBs.CutWordWgtSumPrc;
261      MnWordFq=BowDocWgtBs.MnWordFq;
262      DIdV=BowDocWgtBs.DIdV;
263      WordFqV=BowDocWgtBs.WordFqV;
264      DocSpVV=BowDocWgtBs.DocSpVV;
265      return *this;}
266    PBowDocWgtBs GetSubSet(const TIntV& IdSubSet){
267      PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBsSig);
268      *BowDocWgtBs=*this;
269      BowDocWgtBs->DIdV=IdSubSet;
270      return BowDocWgtBs;}
271    int GetSig() const {return Sig;}
272    int GetBowDocBsSig() const {return BowDocBsSig;}
273    TBowWordWgtType GetWordWgtType() const {
274      return TBowWordWgtType(int(WordWgtType));}
275    static TBowWordWgtType GetWordWgtTypeFromStr(const TStr& Nm);
276    double GetCutWordWgtSumPrc() const {return CutWordWgtSumPrc;}
277    int GetMnWordFq() const {return MnWordFq;}
278    int GetDocs() const {return DIdV.Len();}
279    int GetDId(const int& DIdN) const {return DIdV[DIdN];}
280    PBowSpV GetSpV(const int& DId) const {return DocSpVV[DId];}
281    void SetSpV(const int& DId, PBowSpV DocSpV) { DocSpVV[DId] = DocSpV; } 
282    void GetDIdV(TIntV& _DIdV) const {_DIdV=DIdV;}
283    void SetDIdV(const TIntV& _DIdV){DIdV=_DIdV;}
284    const TBowSpVV& GetDocSpVV() const { return DocSpVV; }
285    int GetWords() const {return WordFqV.Len();}
286    double GetWordFq(const int& WId) const {return WordFqV[WId];}
287    void GetSimDIdV(
288     const PBowSpV& RefBowSpV, const PBowSim& BowSim,
289     TFltIntKdV& SimDIdKdV, const bool& RefBowSpVInclude=false) const;
290    void SaveTxtSimDIdV(
291     const PSOut& SOut, const PBowDocBs& BowDocBs,
292     const PBowSpV& RefBowSpV, const TFltIntKdV& SimDIdKdV,
293     const int& TopHits=-1, const double& MnSim=0, const int& TopDocWords=-1,
294     const char& SepCh=' ') const;
295    void SaveXmlSimDIdV(
296     const PSOut& SOut, const PBowDocBs& BowDocBs,
297     const PBowSpV& RefBowSpV, const TFltIntKdV& SimDIdKdV,
298     const int& TopHits=-1, const double& MnSim=0) const;
299    void SaveTxtStat(
300     const TStr& StatFNm, const PBowDocBs& BowDocBs,
301     const bool& SaveWordsP=true, const bool& SaveCatsP=true,
302     const bool& SaveDocsP=true) const;
303    static const TStr BowDocWgtBsFExt;
304    static PBowDocWgtBs LoadBin(const TStr& FNm){
305      TFIn SIn(FNm); return Load(SIn);}
306    void SaveBin(const TStr& FNm) const {
307      TFOut SOut(FNm); Save(SOut);}
308  };
309  class TBowWordDesc{
310  public:
311    TInt Fq;
312    TFlt MnVal;
313    TFlt MxVal;
314  public:
315    TBowWordDesc():
316      Fq(0), MnVal(0), MxVal(0){}
317    TBowWordDesc(const int& _Fq, const double& _MnVal, const double& _MxVal):
318      Fq(_Fq), MnVal(_MnVal), MxVal(_MxVal){}
319    TBowWordDesc(TSIn& SIn):
320      Fq(SIn), MnVal(SIn), MxVal(SIn){}
321    void Save(TSOut& SOut) const {
322      Fq.Save(SOut); MnVal.Save(SOut); MxVal.Save(SOut);}
323    TBowWordDesc& operator=(const TBowWordDesc& BowWordDesc){
324      Fq=BowWordDesc.Fq; MnVal=BowWordDesc.MnVal; MxVal=BowWordDesc.MxVal;
325      return *this;}
326    bool operator==(const TBowWordDesc& BowWordDesc) const {
327      return Fq==BowWordDesc.Fq;}
328    bool operator<(const TBowWordDesc& BowWordDesc) const {
329      return Fq<BowWordDesc.Fq;}
330  };
331  typedef TPair<TBowWordDesc, TStr> TBowWordDescStrPr;
332  typedef TVec<TBowWordDescStrPr> TBowWordDescStrPrV;
333  ClassTP(TBowDocBs, PBowDocBs)
334  private:
335    TInt Sig; 
336    PNGramBs NGramBs; 
337    PSwSet SwSet; 
338    PStemmer Stemmer; 
339    TStrStrH DocNmToDescStrH; 
340    THash<TStr, TBowWordDesc> WordStrToDescH; 
341    TStrIntH CatNmToFqH; 
342    TBowSpVV DocSpVV; 
343    TStrV DocStrV; 
344    TVec<TIntV> DocCIdVV; 
345    TIntV TrainDIdV; 
346    TIntV TestDIdV; 
347  public:
348    TBowDocBs():
349      Sig(TSecTm::GetCurTm().GetAbsSecs()),
350      NGramBs(), SwSet(), Stemmer(),
351      DocNmToDescStrH(), WordStrToDescH(), CatNmToFqH(),
352      DocSpVV(), DocStrV(), DocCIdVV(),
353      TrainDIdV(), TestDIdV(){}
354    static PBowDocBs New(){return new TBowDocBs();}
355    static PBowDocBs New(
356     const PSwSet& SwSet, const PStemmer& Stemmer, const PNGramBs& NGramBs);
357    TBowDocBs(TSIn& SIn):
358      Sig(SIn),
359      NGramBs(SIn), SwSet(SIn), Stemmer(SIn),
360      DocNmToDescStrH(SIn), WordStrToDescH(SIn), CatNmToFqH(SIn),
361      DocSpVV(SIn), DocStrV(SIn), DocCIdVV(SIn),
362      TrainDIdV(SIn), TestDIdV(SIn){}
363    static PBowDocBs Load(TSIn& SIn){return new TBowDocBs(SIn);}
364    void Save(TSOut& SOut) const {
365      Sig.Save(SOut);
366      NGramBs.Save(SOut); SwSet.Save(SOut); Stemmer.Save(SOut);
367      DocNmToDescStrH.Save(SOut); WordStrToDescH.Save(SOut); CatNmToFqH.Save(SOut);
368      DocSpVV.Save(SOut); DocStrV.Save(SOut); DocCIdVV.Save(SOut);
369      TrainDIdV.Save(SOut); TestDIdV.Save(SOut);}
370    TBowDocBs& operator=(const TBowDocBs& BowDocBs){
371      Sig=BowDocBs.Sig;
372      NGramBs=BowDocBs.NGramBs;
373      SwSet=BowDocBs.SwSet;
374      Stemmer=BowDocBs.Stemmer;
375      DocNmToDescStrH=BowDocBs.DocNmToDescStrH;
376      WordStrToDescH=BowDocBs.WordStrToDescH;
377      CatNmToFqH=BowDocBs.CatNmToFqH;
378      DocSpVV=BowDocBs.DocSpVV;
379      DocStrV=BowDocBs.DocStrV;
380      DocCIdVV=BowDocBs.DocCIdVV;
381      TrainDIdV=BowDocBs.TrainDIdV;
382      TestDIdV=BowDocBs.TestDIdV;
383      return *this;}
384    void AddDocs(const PBowDocBs& BowDocBs);
385    void AssertOk() const;
386    int GetSig() const {return Sig;}
387    void PutNGramBs(const PNGramBs& _NGramBs){NGramBs=_NGramBs;}
388    PNGramBs GetNGramBs() const {return NGramBs;}
389    void PutSwSet(const PSwSet& _SwSet){SwSet=_SwSet;}
390    PSwSet GetSwSet() const {return SwSet;}
391    void PutStemmer(const PStemmer& _Stemmer){Stemmer=_Stemmer;}
392    PStemmer GetStemmer() const {return Stemmer;}
393    int GetWords() const {return WordStrToDescH.Len();}
394    int AddWordStr(const TStr& WordStr){return WordStrToDescH.AddKey(WordStr);}
395    bool IsWordStr(const TStr& WordStr) const {
396      return WordStrToDescH.IsKey(WordStr);}
397    bool IsWordStr(const TStr& WordStr, int& WId) const {
398      return WordStrToDescH.IsKey(WordStr, WId);}
399    bool IsWId(const int& WId) const {
400      return WordStrToDescH.IsKeyId(WId);}
401    int GetWId(const TStr& WordStr) const {
402      return WordStrToDescH.GetKeyId(WordStr);}
403    TStr GetWordStr(const int& WId) const {
404      return WordStrToDescH.GetKey(WId);}
405    double GetWordMnVal(const int& WId) const {
406      return WordStrToDescH[WId].MnVal;}
407    double GetWordMxVal(const int& WId) const {
408      return WordStrToDescH[WId].MxVal;}
409    void PutWordFq(const int& WId, const int& Fq){
410      WordStrToDescH[WId].Fq=Fq;}
411    int GetWordFq(const int& WId) const {
412      return WordStrToDescH[WId].Fq;}
413    void GetWordStrVFromHtml(const TStr& HtmlStr, TStrV& WordStrV) const;
414    int AddDoc(const TStr& DocNm,
415     const TStrV& CatNmV, const TIntFltPrV& WIdWgtPrV);
416    int AddDoc(const TStr& DocNm,
417     const TStrV& CatNmV, const TStrV& WordStrV, const TStr& DocStr=TStr());
418    int AddDoc(const TStr& DocNm,
419     const TStr& CatNm, const TStrV& WordStrV, const TStr& DocStr=TStr()){
420      TStrV CatNmV; CatNmV.Add(CatNm);
421      return AddDoc(DocNm, CatNmV, WordStrV, DocStr);}
422    int AddHtmlDoc(const TStr& DocNm, const TStrV& CatNmV,
423     const TStr& HtmlDocStr, const bool& SaveDocP=false);
424    int GetDocs() const {return DocSpVV.Len();}
425    PBowSpV GetDocSpV(const int& DId) const {return DocSpVV[DId];}
426    void PutDocStr(const int& DId, const TStr& DocStr){DocStrV[DId]=DocStr; }
427    TStr GetDocStr(const int& DId) const {return DocStrV[DId];}
428    bool IsDocNm(const TStr& DocNm) const {
429      return DocNmToDescStrH.IsKey(DocNm);}
430    bool IsDocNm(const TStr& DocNm, int& DId) const {
431      DId=DocNmToDescStrH.GetKeyId(DocNm); return DId!=-1;}
432    TStr GetDocNm(const int& DId) const {
433      if (DocNmToDescStrH.Empty()){return TInt::GetStr(DId);}
434      else {return DocNmToDescStrH.GetKey(DId);}}
435    bool IsDId(const int& DId) const {
436      return (0<=DId)&&(DId<DocSpVV.Len());}
437    int GetDId(const TStr& DocNm) const {
438      return DocNmToDescStrH.GetKeyId(DocNm);}
439    void GetAllDIdV(TIntV& DIdV) const;
440    int GetDocWIds(const int& DId) const {
441      return DocSpVV[DId]->GetWIds();}
442    void GetDocWIdFq(
443     const int& DId, const int& DocWIdN, int& WId, double& WordFq) const {
444      DocSpVV[DId]->GetWIdWgt(DocWIdN, WId, WordFq);}
445    int GetDocWIdN(const int& DId, const int& DocWId) const {
446      return DocSpVV[DId]->GetWId(DocWId);}
447    int GetDocWId(const int& DId, const int& DocWIdN) const {
448      return DocSpVV[DId]->GetWId(DocWIdN);}
449    void PutDocWFq(const int& DId, const int& DocWIdN, double& WordFq){
450      DocSpVV[DId]->GetWgt(DocWIdN)=sdouble(WordFq);}
451    double GetDocWFq(const int& DId, const int& DocWIdN) const {
452      return DocSpVV[DId]->GetWgt(DocWIdN);}
453    bool IsDocWordStr(const int& DId, const TStr& WordStr) const;
454    int GetDocCIds(const int& DId) const {
455      return DocCIdVV.Empty() ? 0 : DocCIdVV[DId].Len();}
456    int GetDocCId(const int& DId, const int& DocCIdN) const {
457      return DocCIdVV[DId][DocCIdN];}
458    bool IsCatInDoc(const int& DId, const int& CId) const {
459      return DocCIdVV[DId].IsIn(CId);}
460    void PutDocDescStr(const int& DId, const TStr& DocDescStr){
461      DocNmToDescStrH[DId]=DocDescStr;}
462    TStr GetDocDescStr(const int& DId) const {
463      return DocNmToDescStrH[DId];}
464    void PutDateStr(const int& DId, const TStr& DateStr){
465      PutDocDescStr(DId, DateStr);}
466    TStr GetDateStr(const int& DId) const {
467      return GetDocDescStr(DId);}
468    bool IsCats() const {return GetCats()>0;}
469    int GetCats() const {return CatNmToFqH.Len();}
470    bool IsCatNm(const TStr& CatNm) const {
471      return CatNmToFqH.IsKey(CatNm);}
472    bool IsCatNm(const TStr& CatNm, int& CId) const {
473      return CatNmToFqH.IsKey(CatNm, CId);}
474    bool IsCId(const int& CId) const {
475      return CatNmToFqH.IsKeyId(CId);}
476    int GetCId(const TStr& CatNm) const {
477      return CatNmToFqH.GetKeyId(CatNm);}
478    TStr GetCatNm(const int& CId) const {
479      return CatNmToFqH.GetKey(CId);}
480    int GetCatFq(const int& CId) const {
481      return CatNmToFqH[CId];}
482    void GetTopCatV(const int& TopCats, TIntStrPrV& FqCatNmPrV) const;
483    void AddDocCId(const int& DId, const int& CId){
484      CatNmToFqH[CId]++; DocCIdVV[DId].AddUnique(CId);}
485    int AddCatNm(const TStr& CatNm){
486      return CatNmToFqH.AddKey(CatNm);}
487    void PutTrainDIdV(const TIntV& DIdV){TrainDIdV=DIdV;}
488    void PutTestDIdV(const TIntV& DIdV){TestDIdV=DIdV;}
489    void PutTrainDocNmV(const TStrV& DocNmV){
490      TrainDIdV.Gen(DocNmV.Len(), 0);
491      for (int DocNmN=0; DocNmN<DocNmV.Len(); DocNmN++){
492        TrainDIdV.Add(GetDId(DocNmV[DocNmN]));}}
493    void PutTestDocNmV(const TStrV& DocNmV){
494      TestDIdV.Gen(DocNmV.Len(), 0);
495      for (int DocNmN=0; DocNmN<DocNmV.Len(); DocNmN++){
496        TestDIdV.Add(GetDId(DocNmV[DocNmN]));}}
497    void AddTrainDId(const int& DId){TrainDIdV.Add(DId);}
498    int GetTrainDocs() const {return TrainDIdV.Len();}
499    int GetTrainDId(const int& DIdN) const {return TrainDIdV[DIdN];}
500    void GetTrainDIdV(TIntV& _TrainDIdV){_TrainDIdV=TrainDIdV;}
501    void AddTestDId(const int& DId){TestDIdV.Add(DId);}
502    int GetTestDocs() const {return TestDIdV.Len();}
503    int GetTestDId(const int& DIdN) const {return TestDIdV[DIdN];}
504    void GetTestDIdV(TIntV& _TestDIdV){_TestDIdV=TestDIdV;}
505    void SetHOTrainTestDIdV(const double& TestDocsPrc, TRnd& Rnd);
506    void SetCVTrainTestDIdV(const int& Folds, const int& FoldN, TRnd& Rnd);
507    void GetAbsSampleDIdV(const int& Docs, TRnd& Rnd, TIntV& DIdV) const {
508      GetAllDIdV(DIdV); DIdV.Shuffle(Rnd); DIdV.Trunc(Docs);}
509    void GetRelSampleDIdV(const double& DocsPrc, TRnd& Rnd, TIntV& DIdV) const {
510      IAssert((0<=DocsPrc)&&(DocsPrc<=1));
511      int Docs=int(DocsPrc*GetDocs()); GetAbsSampleDIdV(Docs, Rnd, DIdV);}
512    PBowDocBs GetLimWordRelFqDocBs(
513     const double& MnWordFqPrc, const double& MxWordFqPrc) const;
514    PBowDocBs GetLimWordAbsFqDocBs(const int& MnWordFq) const;
515    PBowDocBs GetSubDocSet(const TIntV& DIdV) const;
516    PBowDocBs GetInvDocBs() const;
517    PBowSpV GetSpVFromHtmlStr(
518     const TStr& HtmlStr, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
519    PBowSpV GetSpVFromHtmlFile(
520     const TStr& HtmlFNm, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
521    PBowSpV GetSpVFromWIdWgtPrV(
522     const TIntFltPrV& WIdWgtPrV, const PBowDocWgtBs& BowDocWgtBs=NULL) const;
523    void SaveTxtStat(const TStr& StatFNm, const bool& SaveWordsP=true,
524     const bool& SaveCatsP=true, const bool& SaveDocsP=true) const;
525    static const TStr BowDocBsFExt;
526    static PBowDocBs LoadBin(const TStr& FNm){
527      TFIn SIn(FNm); return Load(SIn);}
528    void SaveBin(const TStr& FNm) const {
529      TFOut SOut(FNm); Save(SOut);}
530    friend class TBowFl;
531  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-stemming.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowbs.h</div>
                <div class="column column_space"><pre><code>14     const TStemmerType& StemmerType=stmtNone, const bool& RealWordP=false){
15      return PStemmer(new TStemmer(StemmerType, RealWordP));}
16    TStemmer(TSIn& SIn):
17      StemmerType(SIn), RealWordP(SIn),
18      StemStrToRealWordStrH(SIn), SynonymStrToWordStr(SIn){}
19    static PStemmer Load(TSIn& SIn){return new TStemmer(SIn);}
20    void Save(TSOut& SOut) const {
21      StemmerType.Save(SOut); RealWordP.Save(SOut);
22      StemStrToRealWordStrH.Save(SOut); SynonymStrToWordStr.Save(SOut);}
23    TStemmer& operator=(const TStemmer& Stemmer){
</pre></code></div>
                <div class="column column_space"><pre><code>147    static PBowSimMtx New(){return new TBowSimMtx();}
148    TBowSimMtx(TSIn& SIn): MtxDIdV(SIn), DIdPrToSimH(SIn){}
149    static PBowSimMtx Load(TSIn& SIn){return new TBowSimMtx(SIn);}
150    void Save(TSOut& SOut) const {MtxDIdV.Save(SOut); DIdPrToSimH.Save(SOut);}
151    TBowSimMtx& operator=(const TBowSimMtx&){Fail; return *this;}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    