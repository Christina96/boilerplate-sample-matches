
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.580029368575625%, Tokens: 10</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_lrn_layer.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include <vector>
3  #include "caffe/layer.hpp"
4  #include "caffe/layers/mkl_layers.hpp"
5  #include "caffe/util/math_functions.hpp"
6  #include "caffe/util/performance.hpp"
7  namespace caffe {
8  template <typename Dtype>
9  MKLLRNLayer<Dtype>::~MKLLRNLayer() {
10    dnnDelete<Dtype>(lrnFwd);
11    dnnDelete<Dtype>(lrnBwd);
12    dnnReleaseBuffer<Dtype>(lrn_buffer_);
13  }
14  template <typename Dtype>
15  void MKLLRNLayer<Dtype>::Init(const vector<Blob<Dtype>*>& bottom,
16        const vector<Blob<Dtype>*>& top) {
17    size_ = this->layer_param_.lrn_param().local_size();
18    CHECK_EQ(size_ % 2, 1) << "LRN only supports odd values for local_size";
19    alpha_ = this->layer_param_.lrn_param().alpha();
20    beta_ = this->layer_param_.lrn_param().beta();
21    k_ = this->layer_param_.lrn_param().k();
22    size_t dim = 4, sizes[4], strides[4];
23    channels_ = bottom[0]->channels();
24    height_   = bottom[0]->height();
25    width_    = bottom[0]->width();
26    num_      = bottom[0]->num();
27    sizes[0] = width_;
28    sizes[1] = height_;
29    sizes[2] = channels_;
30    sizes[3] = num_;
31    strides[0] = 1;
32    strides[1] = sizes[0];
33    strides[2] = sizes[0]*sizes[1];
34    strides[3] = sizes[0]*sizes[1]*sizes[2];
35    fwd_bottom_data->name = "fwd_bottom_data   @ " + this->layer_param_.name();
36    fwd_top_data->name =    "fwd_top_data      @ " + this->layer_param_.name();
37    bwd_top_diff->name =    "bwd_top_diff      @ " + this->layer_param_.name();
38    bwd_bottom_diff->name = "bwd_bottom_diff   @ " + this->layer_param_.name();
39    fwd_bottom_data->create_user_layout(dim, sizes, strides, false);
40    fwd_top_data   ->create_user_layout(dim, sizes, strides, false);
41    bwd_bottom_diff->create_user_layout(dim, sizes, strides, false);
42    bwd_top_diff   ->create_user_layout(dim, sizes, strides, false);
43    dnnDelete<Dtype>(lrnFwd);
44    dnnDelete<Dtype>(lrnBwd);
45    dnnReleaseBuffer<Dtype>(lrn_buffer_);
46    lrn_buffer_ = NULL;
47  }
48  template <typename Dtype>
49  void MKLLRNLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
50        const vector<Blob<Dtype>*>& top) {
51    Init(bottom, top);
52  }
53  template <typename Dtype>
54  void MKLLRNLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
55        const vector<Blob<Dtype>*>& top) {
56    CHECK_EQ(4, bottom[0]->num_axes()) << "Input must have 4 axes, "
57        << "corresponding to (num, channels, height, width)";
58    bool reshaping = true;
59    if ((num_ == bottom[0]->num()) &&
60        channels_ == bottom[0]->channels() &&
61        height_ == bottom[0]->height() &&
62        width_ == bottom[0]->width()) {
63      reshaping = false;
64    }
65    channels_ = bottom[0]->channels();
66    height_ = bottom[0]->height();
67    width_ = bottom[0]->width();
68    num_ = bottom[0]->num();
69    switch (this->layer_param_.lrn_param().norm_region()) {
70    case LRNParameter_NormRegion_ACROSS_CHANNELS:
71      top[0]->Reshape(num_, channels_, height_, width_);
72      break;
73    case LRNParameter_NormRegion_WITHIN_CHANNEL:
74      NOT_IMPLEMENTED;
75      break;
76    default:
77      LOG(FATAL) << "Unknown normalization region.";
78    }
79    if (reshaping == true) {
80      Init(bottom, top);
81    }
82  }
83  template <typename Dtype>
84  void MKLLRNLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
85      const vector<Blob<Dtype>*>& top) {
86    switch (this->layer_param_.lrn_param().norm_region()) {
87    case LRNParameter_NormRegion_ACROSS_CHANNELS:
88      CrossChannelForward_cpu(bottom, top);
89      break;
90    case LRNParameter_NormRegion_WITHIN_CHANNEL:
91      NOT_IMPLEMENTED;
92      break;
93    default:
94      LOG(FATAL) << "Unknown normalization region.";
95    }
96  }
97  template <typename Dtype>
98  void MKLLRNLayer<Dtype>::CrossChannelForward_cpu(
99      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
100    const void* bottom_data =
101      reinterpret_cast<const void*>(bottom[0]->prv_data());
102    if (NULL != bottom_data) {
103      if (lrnFwd == NULL) {
104        CHECK_EQ((bottom[0]->get_prv_data_descriptor())->get_descr_type(),
105                PrvMemDescr::PRV_DESCR_MKL2017);
106        shared_ptr<MKLData<Dtype> > mem_descr
107          =  boost::static_pointer_cast<MKLData<Dtype> >
108                (bottom[0]->get_prv_data_descriptor());
109        CHECK(mem_descr != NULL);
110        fwd_bottom_data = mem_descr;
111        dnnError_t e;
112        dnnLayout_t lrn_buffer_l = NULL;
113        e = dnnLRNCreateForward<Dtype>(&lrnFwd, NULL, fwd_bottom_data->layout_int,
114                size_, alpha_, beta_, k_);
115        CHECK_EQ(e, E_SUCCESS);
116        fwd_top_data->create_internal_layout(lrnFwd, dnnResourceDst);
117        e = dnnLRNCreateBackward<Dtype>(&lrnBwd, NULL,
118                fwd_bottom_data->layout_int, fwd_bottom_data->layout_int,
119                size_, alpha_, beta_, k_);
120        CHECK_EQ(e, E_SUCCESS);
121        e = dnnLayoutCreateFromPrimitive<Dtype>(
122                &lrn_buffer_l, lrnFwd, dnnResourceWorkspace);
123        CHECK_EQ(e, E_SUCCESS);
124        e = dnnAllocateBuffer<Dtype>(
125                reinterpret_cast<void **>(&lrn_buffer_), lrn_buffer_l);
126        CHECK_EQ(e, E_SUCCESS);
127        dnnLayoutDelete<Dtype>(lrn_buffer_l);
128        bwd_top_diff->create_internal_layout(lrnBwd, dnnResourceDiffDst);
129        bwd_bottom_diff->create_internal_layout(lrnBwd, dnnResourceDiffSrc);
130      }
131    } else {
132      DLOG(INFO) << "Using cpu_data in MKLLRNLayer.";
133      if (lrnFwd == NULL) {
134        dnnError_t e;
135        dnnLayout_t lrn_buffer_l = NULL;
136        e = dnnLRNCreateForward<Dtype>(&lrnFwd, NULL, fwd_bottom_data->layout_usr,
137                size_, alpha_, beta_, k_);
138        CHECK_EQ(e, E_SUCCESS);
139        e = dnnLayoutCreateFromPrimitive<Dtype>(
140                &lrn_buffer_l, lrnFwd, dnnResourceWorkspace);
141        CHECK_EQ(e, E_SUCCESS);
142        e = dnnAllocateBuffer<Dtype>(
143                reinterpret_cast<void **>(&lrn_buffer_), lrn_buffer_l);
144        CHECK_EQ(e, E_SUCCESS);
145        dnnLayoutDelete<Dtype>(lrn_buffer_l);
146        e = dnnLRNCreateBackward<Dtype>(&lrnBwd, NULL,
147                fwd_bottom_data->layout_usr, fwd_bottom_data->layout_usr,
148                size_, alpha_, beta_, k_);
149        CHECK_EQ(e, E_SUCCESS);
150      }
151      bottom_data = reinterpret_cast<const void*>(bottom[0]->cpu_data());
152    }
153    dnnError_t e;
154    void* lrn_res[dnnResourceNumber];
155    lrn_res[dnnResourceSrc] = const_cast<void*>(bottom_data);
156    if (fwd_top_data->conversion_needed()) {
157      top[0]->set_prv_data_descriptor(fwd_top_data);
158      lrn_res[dnnResourceDst] =
159              reinterpret_cast<void *>(top[0]->mutable_prv_data());
160    } else {
161      lrn_res[dnnResourceDst] =
162              reinterpret_cast<void *>(top[0]->mutable_cpu_data());
163      DLOG(INFO) << "Using cpu_data for top in DnnLRN.";
164    }
165    lrn_res[dnnResourceWorkspace] = lrn_buffer_;
166    PERFORMANCE_EVENT_ID_INIT(perf_id_fw_, PERFORMANCE_MKL_NAME("FW"));
167    PERFORMANCE_MEASUREMENT_BEGIN();
168    e = dnnExecute<Dtype>(lrnFwd, lrn_res);
169    PERFORMANCE_MEASUREMENT_END_ID(perf_id_fw_);
170    CHECK_EQ(e, E_SUCCESS);
171  }
172  template <typename Dtype>
173  void MKLLRNLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
174      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
175    switch (this->layer_param_.lrn_param().norm_region()) {
176    case LRNParameter_NormRegion_ACROSS_CHANNELS:
177      CrossChannelBackward_cpu(top, propagate_down, bottom);
178      break;
179    case LRNParameter_NormRegion_WITHIN_CHANNEL:
180      NOT_IMPLEMENTED;
181      break;
182    default:
183      LOG(FATAL) << "Unknown normalization region.";
184    }
185  }
186  template <typename Dtype>
187  void MKLLRNLayer<Dtype>::CrossChannelBackward_cpu(
188      const vector<Blob<Dtype>*>& top, const vector<bool>& propagate_down,
189      const vector<Blob<Dtype>*>& bottom) {
190    dnnError_t e;
191    void* lrn_res[dnnResourceNumber];
192    lrn_res[dnnResourceDiffDst] =
193            bwd_top_diff->get_converted_prv(top[0], true);
194    lrn_res[dnnResourceWorkspace] = lrn_buffer_;
195    lrn_res[dnnResourceSrc] =
196            fwd_bottom_data->get_converted_prv(bottom[0], false);
<span onclick='openModal()' class='match'>197    if (bwd_bottom_diff->conversion_needed()) {
198      bottom[0]->set_prv_diff_descriptor(bwd_bottom_diff);
199      lrn_res[dnnResourceDiffSrc] = bottom[0]->mutable_prv_diff();
200    } else {
201      lrn_res[dnnResourceDiffSrc] = bottom[0]->mutable_cpu_diff();
202    }
203    PERFORMANCE_EVENT_ID_INIT(perf_id_bw_, PERFORMANCE_MKL_NAME("BW"));
204    PERFORMANCE_MEASUREMENT_BEGIN();
205    e = dnnExecute<Dtype>(lrnBwd, lrn_res);
206    PERFORMANCE_MEASUREMENT_END_ID(perf_id_bw_);
207    CHECK_EQ(e, E_SUCCESS);
208  }
</span>209  #ifdef CPU_ONLY
210  STUB_GPU(MKLLRNLayer);
211  STUB_GPU_FORWARD(MKLLRNLayer, CrossChannelForward);
212  STUB_GPU_BACKWARD(MKLLRNLayer, CrossChannelBackward);
213  #else
214  template <typename Dtype>
215  void MKLLRNLayer<Dtype>::Forward_gpu(const vector<Blob<Dtype>*>& bottom,
216      const vector<Blob<Dtype>*>& top) {NOT_IMPLEMENTED;}
217  template <typename Dtype>
218  void MKLLRNLayer<Dtype>::Backward_gpu(const vector<Blob<Dtype>*>& top,
219      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom)
220    {NOT_IMPLEMENTED;}
221  template <typename Dtype>
222  void MKLLRNLayer<Dtype>::CrossChannelForward_gpu(
223      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top)
224    {NOT_IMPLEMENTED;}
225  template <typename Dtype>
226  void MKLLRNLayer<Dtype>::CrossChannelBackward_gpu(
227      const vector<Blob<Dtype>*>& top, const vector<bool>& propagate_down,
228      const vector<Blob<Dtype>*>& bottom) {NOT_IMPLEMENTED;}
229  #endif
230  INSTANTIATE_CLASS(MKLLRNLayer);
231  }  
232  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_bounded.cpp</h3>
            <pre><code>1  #include <nano/lib/logger_mt.hpp>
2  #include <nano/lib/stats.hpp>
3  #include <nano/node/confirmation_height_bounded.hpp>
4  #include <nano/node/logging.hpp>
5  #include <nano/node/write_database_queue.hpp>
6  #include <nano/secure/ledger.hpp>
7  #include <boost/format.hpp>
8  #include <numeric>
9  nano::confirmation_height_bounded::confirmation_height_bounded (nano::ledger & ledger_a, nano::write_database_queue & write_database_queue_a, std::chrono::milliseconds batch_separate_pending_min_time_a, nano::logging const & logging_a, nano::logger_mt & logger_a, std::atomic<bool> & stopped_a, uint64_t & batch_write_size_a, std::function<void (std::vector<std::shared_ptr<nano::block>> const &)> const & notify_observers_callback_a, std::function<void (nano::block_hash const &)> const & notify_block_already_cemented_observers_callback_a, std::function<uint64_t ()> const & awaiting_processing_size_callback_a) :
10  	ledger (ledger_a),
11  	write_database_queue (write_database_queue_a),
12  	batch_separate_pending_min_time (batch_separate_pending_min_time_a),
13  	logging (logging_a),
14  	logger (logger_a),
15  	stopped (stopped_a),
16  	batch_write_size (batch_write_size_a),
17  	notify_observers_callback (notify_observers_callback_a),
18  	notify_block_already_cemented_observers_callback (notify_block_already_cemented_observers_callback_a),
19  	awaiting_processing_size_callback (awaiting_processing_size_callback_a)
20  {
21  }
22  nano::confirmation_height_bounded::top_and_next_hash nano::confirmation_height_bounded::get_next_block (boost::optional<top_and_next_hash> const & next_in_receive_chain_a, boost::circular_buffer_space_optimized<nano::block_hash> const & checkpoints_a, boost::circular_buffer_space_optimized<receive_source_pair> const & receive_source_pairs, boost::optional<receive_chain_details> & receive_details_a, nano::block const & original_block)
23  {
24  	top_and_next_hash next;
25  	if (next_in_receive_chain_a.is_initialized ())
26  	{
27  		next = *next_in_receive_chain_a;
28  	}
29  	else if (!receive_source_pairs.empty ())
30  	{
31  		auto next_receive_source_pair = receive_source_pairs.back ();
32  		receive_details_a = next_receive_source_pair.receive_details;
33  		next = { next_receive_source_pair.source_hash, receive_details_a->next, receive_details_a->height + 1 };
34  	}
35  	else if (!checkpoints_a.empty ())
36  	{
37  		next = { checkpoints_a.back (), boost::none, 0 };
38  	}
39  	else
40  	{
41  		next = { original_block.hash (), boost::none, 0 };
42  	}
43  	return next;
44  }
45  void nano::confirmation_height_bounded::process (std::shared_ptr<nano::block> original_block)
46  {
47  	if (pending_empty ())
48  	{
49  		clear_process_vars ();
50  		timer.restart ();
51  	}
52  	boost::optional<top_and_next_hash> next_in_receive_chain;
53  	boost::circular_buffer_space_optimized<nano::block_hash> checkpoints{ max_items };
54  	boost::circular_buffer_space_optimized<receive_source_pair> receive_source_pairs{ max_items };
55  	nano::block_hash current;
56  	bool first_iter = true;
57  	auto transaction (ledger.store.tx_begin_read ());
58  	do
59  	{
60  		boost::optional<receive_chain_details> receive_details;
61  		auto hash_to_process = get_next_block (next_in_receive_chain, checkpoints, receive_source_pairs, receive_details, *original_block);
62  		current = hash_to_process.top;
63  		auto top_level_hash = current;
64  		std::shared_ptr<nano::block> block;
65  		if (first_iter)
66  		{
67  			debug_assert (current == original_block->hash ());
68  			block = original_block;
69  		}
70  		else
71  		{
72  			block = ledger.store.block.get (transaction, current);
73  		}
74  		if (!block)
75  		{
76  			if (ledger.pruning && ledger.store.pruned.exists (transaction, current))
77  			{
78  				if (!receive_source_pairs.empty ())
79  				{
80  					receive_source_pairs.pop_back ();
81  				}
82  				continue;
83  			}
84  			else
85  			{
86  				auto error_str = (boost::format ("Ledger mismatch trying to set confirmation height for block %1% (bounded processor)") % current.to_string ()).str ();
87  				logger.always_log (error_str);
88  				std::cerr << error_str << std::endl;
89  				release_assert (block);
90  			}
91  		}
92  		nano::account account (block->account ());
93  		if (account.is_zero ())
94  		{
95  			account = block->sideband ().account;
96  		}
97  		nano::confirmation_height_info confirmation_height_info;
98  		auto account_it = accounts_confirmed_info.find (account);
99  		if (account_it != accounts_confirmed_info.cend ())
100  		{
101  			confirmation_height_info.height = account_it->second.confirmed_height;
102  			confirmation_height_info.frontier = account_it->second.iterated_frontier;
103  		}
104  		else
105  		{
106  			ledger.store.confirmation_height.get (transaction, account, confirmation_height_info);
107  			if (first_iter && confirmation_height_info.height >= block->sideband ().height && current == original_block->hash ())
108  			{
109  				notify_block_already_cemented_observers_callback (original_block->hash ());
110  			}
111  		}
112  		auto block_height = block->sideband ().height;
113  		bool already_cemented = confirmation_height_info.height >= block_height;
114  		if (!already_cemented && block_height - confirmation_height_info.height > 1)
115  		{
116  			if (block_height - confirmation_height_info.height == 2)
117  			{
118  				current = block->previous ();
119  				--block_height;
120  			}
121  			else if (!next_in_receive_chain.is_initialized ())
122  			{
123  				current = get_least_unconfirmed_hash_from_top_level (transaction, current, account, confirmation_height_info, block_height);
124  			}
125  			else
126  			{
127  				current = *hash_to_process.next;
128  				block_height = hash_to_process.next_height;
129  			}
130  		}
131  		auto top_most_non_receive_block_hash = current;
132  		bool hit_receive = false;
133  		if (!already_cemented)
134  		{
135  			hit_receive = iterate (transaction, block_height, current, checkpoints, top_most_non_receive_block_hash, top_level_hash, receive_source_pairs, account);
136  		}
137  		if (stopped)
138  		{
139  			break;
140  		}
141  		auto is_set = next_in_receive_chain.is_initialized ();
142  		next_in_receive_chain = boost::none;
143  		if (!hit_receive || (receive_source_pairs.size () == 1 && top_most_non_receive_block_hash != current))
144  		{
145  			preparation_data preparation_data{ transaction, top_most_non_receive_block_hash, already_cemented, checkpoints, account_it, confirmation_height_info, account, block_height, current, receive_details, next_in_receive_chain };
146  			prepare_iterated_blocks_for_cementing (preparation_data);
147  			if (!is_set && !receive_source_pairs.empty ())
148  			{
149  				receive_source_pairs.pop_back ();
150  			}
151  			auto total_pending_write_block_count = std::accumulate (pending_writes.cbegin (), pending_writes.cend (), uint64_t (0), [] (uint64_t total, auto const & write_details_a) {
152  				return total += write_details_a.top_height - write_details_a.bottom_height + 1;
153  			});
154  			auto max_batch_write_size_reached = (total_pending_write_block_count >= batch_write_size);
155  			auto min_time_exceeded = (timer.since_start () >= batch_separate_pending_min_time);
156  			auto finished_iterating = current == original_block->hash ();
157  			auto non_awaiting_processing = awaiting_processing_size_callback () == 0;
158  			auto should_output = finished_iterating && (non_awaiting_processing || min_time_exceeded);
159  			auto force_write = pending_writes.size () >= pending_writes_max_size || accounts_confirmed_info.size () >= pending_writes_max_size;
160  			if ((max_batch_write_size_reached || should_output || force_write) && !pending_writes.empty ())
161  			{
162  				if (write_database_queue.process (nano::writer::confirmation_height))
163  				{
164  					auto scoped_write_guard = write_database_queue.pop ();
165  					cement_blocks (scoped_write_guard);
166  				}
167  				else if (force_write)
168  				{
169  					auto scoped_write_guard = write_database_queue.wait (nano::writer::confirmation_height);
170  					cement_blocks (scoped_write_guard);
171  				}
172  			}
173  		}
174  		first_iter = false;
175  		transaction.refresh ();
176  	} while ((!receive_source_pairs.empty () || current != original_block->hash ()) && !stopped);
177  	debug_assert (checkpoints.empty ());
178  }
179  nano::block_hash nano::confirmation_height_bounded::get_least_unconfirmed_hash_from_top_level (nano::transaction const & transaction_a, nano::block_hash const & hash_a, nano::account const & account_a, nano::confirmation_height_info const & confirmation_height_info_a, uint64_t & block_height_a)
180  {
181  	nano::block_hash least_unconfirmed_hash = hash_a;
182  	if (confirmation_height_info_a.height != 0)
183  	{
184  		if (block_height_a > confirmation_height_info_a.height)
185  		{
186  			auto block (ledger.store.block.get (transaction_a, confirmation_height_info_a.frontier));
187  			release_assert (block != nullptr);
188  			least_unconfirmed_hash = block->sideband ().successor;
189  			block_height_a = block->sideband ().height + 1;
190  		}
191  	}
192  	else
193  	{
194  		auto info = ledger.account_info (transaction_a, account_a);
195  		release_assert (info);
196  		least_unconfirmed_hash = info->open_block;
197  		block_height_a = 1;
198  	}
199  	return least_unconfirmed_hash;
200  }
201  bool nano::confirmation_height_bounded::iterate (nano::read_transaction const & transaction_a, uint64_t bottom_height_a, nano::block_hash const & bottom_hash_a, boost::circular_buffer_space_optimized<nano::block_hash> & checkpoints_a, nano::block_hash & top_most_non_receive_block_hash_a, nano::block_hash const & top_level_hash_a, boost::circular_buffer_space_optimized<receive_source_pair> & receive_source_pairs_a, nano::account const & account_a)
202  {
203  	bool reached_target = false;
204  	bool hit_receive = false;
205  	auto hash = bottom_hash_a;
206  	uint64_t num_blocks = 0;
207  	while (!hash.is_zero () && !reached_target && !stopped)
208  	{
209  		++num_blocks;
210  		auto block = ledger.store.block.get (transaction_a, hash);
211  		auto source (block->source ());
212  		if (source.is_zero ())
213  		{
214  			source = block->link ().as_block_hash ();
215  		}
216  		if (!source.is_zero () && !ledger.is_epoch_link (source) && ledger.store.block.exists (transaction_a, source))
217  		{
218  			hit_receive = true;
219  			reached_target = true;
220  			auto const & sideband (block->sideband ());
221  			auto next = !sideband.successor.is_zero () && sideband.successor != top_level_hash_a ? boost::optional<nano::block_hash> (sideband.successor) : boost::none;
222  			receive_source_pairs_a.push_back ({ receive_chain_details{ account_a, sideband.height, hash, top_level_hash_a, next, bottom_height_a, bottom_hash_a }, source });
223  			if (receive_source_pairs_a.size () % max_items == 0)
224  			{
225  				checkpoints_a.push_back (top_level_hash_a);
226  			}
227  		}
228  		else
229  		{
230  			top_most_non_receive_block_hash_a = hash;
231  			if (hash == top_level_hash_a)
232  			{
233  				reached_target = true;
234  			}
235  			else
236  			{
237  				hash = block->sideband ().successor;
238  			}
239  		}
240  		if ((num_blocks > 0) && num_blocks % batch_read_size == 0)
241  		{
242  			transaction_a.refresh ();
243  		}
244  	}
245  	return hit_receive;
246  }
247  void nano::confirmation_height_bounded::prepare_iterated_blocks_for_cementing (preparation_data & preparation_data_a)
248  {
249  	if (!preparation_data_a.already_cemented)
250  	{
251  		auto block_height = (ledger.store.block.account_height (preparation_data_a.transaction, preparation_data_a.top_most_non_receive_block_hash));
252  		if (block_height > preparation_data_a.confirmation_height_info.height)
253  		{
254  			confirmed_info confirmed_info_l{ block_height, preparation_data_a.top_most_non_receive_block_hash };
<span onclick='openModal()' class='match'>255  			if (preparation_data_a.account_it != accounts_confirmed_info.cend ())
256  			{
257  				preparation_data_a.account_it->second = confirmed_info_l;
258  			}
259  			else
260  			{
261  				accounts_confirmed_info.emplace (preparation_data_a.account, confirmed_info_l);
262  				++accounts_confirmed_info_size;
263  			}
264  			preparation_data_a.checkpoints.erase (std::remove (preparation_data_a.checkpoints.begin (), preparation_data_a.checkpoints.end (), preparation_data_a.top_most_non_receive_block_hash), preparation_data_a.checkpoints.end ());
265  			pending_writes.emplace_back (preparation_data_a.account, preparation_data_a.bottom_height, preparation_data_a.bottom_most, block_height, preparation_data_a.top_most_non_receive_block_hash);
266  			++pending_writes_size;
267  		}
</span>268  	}
269  	auto & receive_details = preparation_data_a.receive_details;
270  	if (receive_details)
271  	{
272  		auto receive_confirmed_info_it = accounts_confirmed_info.find (receive_details->account);
273  		if (receive_confirmed_info_it != accounts_confirmed_info.cend ())
274  		{
275  			auto & receive_confirmed_info = receive_confirmed_info_it->second;
276  			receive_confirmed_info.confirmed_height = receive_details->height;
277  			receive_confirmed_info.iterated_frontier = receive_details->hash;
278  		}
279  		else
280  		{
281  			accounts_confirmed_info.emplace (std::piecewise_construct, std::forward_as_tuple (receive_details->account), std::forward_as_tuple (receive_details->height, receive_details->hash));
282  			++accounts_confirmed_info_size;
283  		}
284  		if (receive_details->next.is_initialized ())
285  		{
286  			preparation_data_a.next_in_receive_chain = top_and_next_hash{ receive_details->top_level, receive_details->next, receive_details->height + 1 };
287  		}
288  		else
289  		{
290  			preparation_data_a.checkpoints.erase (std::remove (preparation_data_a.checkpoints.begin (), preparation_data_a.checkpoints.end (), receive_details->hash), preparation_data_a.checkpoints.end ());
291  		}
292  		pending_writes.emplace_back (receive_details->account, receive_details->bottom_height, receive_details->bottom_most, receive_details->height, receive_details->hash);
293  		++pending_writes_size;
294  	}
295  }
296  void nano::confirmation_height_bounded::cement_blocks (nano::write_guard & scoped_write_guard_a)
297  {
298  	std::vector<std::shared_ptr<nano::block>> cemented_blocks;
299  	auto const maximum_batch_write_time = 250; 
300  	auto const maximum_batch_write_time_increase_cutoff = maximum_batch_write_time - (maximum_batch_write_time / 5);
301  	auto const amount_to_change = batch_write_size / 10; 
302  	auto const minimum_batch_write_size = 16384u;
303  	nano::timer<> cemented_batch_timer;
304  	auto error = false;
305  	{
306  		auto transaction (ledger.store.tx_begin_write ({}, { nano::tables::confirmation_height }));
307  		cemented_batch_timer.start ();
308  		while (!error && !pending_writes.empty ())
309  		{
310  			auto const & pending = pending_writes.front ();
311  			auto const & account = pending.account;
312  			auto write_confirmation_height = [&account, &ledger = ledger, &transaction] (uint64_t num_blocks_cemented, uint64_t confirmation_height, nano::block_hash const & confirmed_frontier) {
313  #ifndef NDEBUG
314  				nano::confirmation_height_info confirmation_height_info;
315  				ledger.store.confirmation_height.get (transaction, account, confirmation_height_info);
316  				auto block (ledger.store.block.get (transaction, confirmed_frontier));
317  				debug_assert (block != nullptr);
318  				debug_assert (block->sideband ().height == confirmation_height_info.height + num_blocks_cemented);
319  #endif
320  				ledger.store.confirmation_height.put (transaction, account, nano::confirmation_height_info{ confirmation_height, confirmed_frontier });
321  				ledger.cache.cemented_count += num_blocks_cemented;
322  				ledger.stats.add (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in, num_blocks_cemented);
323  				ledger.stats.add (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in, num_blocks_cemented);
324  			};
325  			nano::confirmation_height_info confirmation_height_info;
326  			ledger.store.confirmation_height.get (transaction, pending.account, confirmation_height_info);
327  			if (pending.top_height > confirmation_height_info.height)
328  			{
329  				nano::block_hash new_cemented_frontier;
330  				uint64_t num_blocks_confirmed = 0;
331  				uint64_t start_height = 0;
332  				if (pending.bottom_height > confirmation_height_info.height)
333  				{
334  					new_cemented_frontier = pending.bottom_hash;
335  					debug_assert (pending.bottom_height == confirmation_height_info.height + 1);
336  					num_blocks_confirmed = pending.top_height - pending.bottom_height + 1;
337  					start_height = pending.bottom_height;
338  				}
339  				else
340  				{
341  					auto block = ledger.store.block.get (transaction, confirmation_height_info.frontier);
342  					new_cemented_frontier = block->sideband ().successor;
343  					num_blocks_confirmed = pending.top_height - confirmation_height_info.height;
344  					start_height = confirmation_height_info.height + 1;
345  				}
346  				auto total_blocks_cemented = 0;
347  				auto block = ledger.store.block.get (transaction, new_cemented_frontier);
348  				for (auto num_blocks_iterated = 0; num_blocks_confirmed - num_blocks_iterated != 0; ++num_blocks_iterated)
349  				{
350  					if (!block)
351  					{
352  						auto error_str = (boost::format ("Failed to write confirmation height for block %1% (bounded processor)") % new_cemented_frontier.to_string ()).str ();
353  						logger.always_log (error_str);
354  						std::cerr << error_str << std::endl;
355  						cemented_blocks.erase (cemented_blocks.end () - num_blocks_iterated, cemented_blocks.end ());
356  						error = true;
357  						break;
358  					}
359  					auto last_iteration = (num_blocks_confirmed - num_blocks_iterated) == 1;
360  					cemented_blocks.emplace_back (block);
361  					if (cemented_blocks.size () > batch_write_size + (batch_write_size / 10))
362  					{
363  						auto time_spent_cementing = cemented_batch_timer.since_start ().count ();
364  						auto num_blocks_cemented = num_blocks_iterated - total_blocks_cemented + 1;
365  						total_blocks_cemented += num_blocks_cemented;
366  						write_confirmation_height (num_blocks_cemented, start_height + total_blocks_cemented - 1, new_cemented_frontier);
367  						transaction.commit ();
368  						if (logging.timing_logging ())
369  						{
370  							logger.always_log (boost::str (boost::format ("Cemented %1% blocks in %2% %3% (bounded processor)") % cemented_blocks.size () % time_spent_cementing % cemented_batch_timer.unit ()));
371  						}
372  						if (time_spent_cementing > maximum_batch_write_time)
373  						{
374  							batch_write_size = std::max<uint64_t> (minimum_batch_write_size, batch_write_size - amount_to_change);
375  						}
376  						else if (time_spent_cementing < maximum_batch_write_time_increase_cutoff)
377  						{
378  							batch_write_size += amount_to_change;
379  						}
380  						scoped_write_guard_a.release ();
381  						notify_observers_callback (cemented_blocks);
382  						cemented_blocks.clear ();
383  						if (!(last_iteration && pending_writes.size () == 1))
384  						{
385  							scoped_write_guard_a = write_database_queue.wait (nano::writer::confirmation_height);
386  							transaction.renew ();
387  						}
388  						cemented_batch_timer.restart ();
389  					}
390  					if (!last_iteration)
391  					{
392  						new_cemented_frontier = block->sideband ().successor;
393  						block = ledger.store.block.get (transaction, new_cemented_frontier);
394  					}
395  					else
396  					{
397  						debug_assert (new_cemented_frontier == pending.top_hash);
398  					}
399  				}
400  				if (error)
401  				{
402  					break;
403  				}
404  				auto num_blocks_cemented = num_blocks_confirmed - total_blocks_cemented;
405  				if (num_blocks_cemented > 0)
406  				{
407  					write_confirmation_height (num_blocks_cemented, pending.top_height, new_cemented_frontier);
408  				}
409  			}
410  			auto it = accounts_confirmed_info.find (pending.account);
411  			if (it != accounts_confirmed_info.cend () && it->second.confirmed_height == pending.top_height)
412  			{
413  				accounts_confirmed_info.erase (pending.account);
414  				--accounts_confirmed_info_size;
415  			}
416  			pending_writes.pop_front ();
417  			--pending_writes_size;
418  		}
419  	}
420  	auto time_spent_cementing = cemented_batch_timer.since_start ().count ();
421  	if (logging.timing_logging () && time_spent_cementing > 50)
422  	{
423  		logger.always_log (boost::str (boost::format ("Cemented %1% blocks in %2% %3% (bounded processor)") % cemented_blocks.size () % time_spent_cementing % cemented_batch_timer.unit ()));
424  	}
425  	if (scoped_write_guard_a.is_owned () && !cemented_blocks.empty ())
426  	{
427  		scoped_write_guard_a.release ();
428  		notify_observers_callback (cemented_blocks);
429  	}
430  	release_assert (!error);
431  	if (time_spent_cementing > maximum_batch_write_time)
432  	{
433  		batch_write_size = std::max<uint64_t> (minimum_batch_write_size, batch_write_size - amount_to_change);
434  	}
435  	debug_assert (pending_writes.empty ());
436  	debug_assert (pending_writes_size == 0);
437  	timer.restart ();
438  }
439  bool nano::confirmation_height_bounded::pending_empty () const
440  {
441  	return pending_writes.empty ();
442  }
443  void nano::confirmation_height_bounded::clear_process_vars ()
444  {
445  	accounts_confirmed_info.clear ();
446  	accounts_confirmed_info_size = 0;
447  }
448  nano::confirmation_height_bounded::receive_chain_details::receive_chain_details (nano::account const & account_a, uint64_t height_a, nano::block_hash const & hash_a, nano::block_hash const & top_level_a, boost::optional<nano::block_hash> next_a, uint64_t bottom_height_a, nano::block_hash const & bottom_most_a) :
449  	account (account_a),
450  	height (height_a),
451  	hash (hash_a),
452  	top_level (top_level_a),
453  	next (next_a),
454  	bottom_height (bottom_height_a),
455  	bottom_most (bottom_most_a)
456  {
457  }
458  nano::confirmation_height_bounded::write_details::write_details (nano::account const & account_a, uint64_t bottom_height_a, nano::block_hash const & bottom_hash_a, uint64_t top_height_a, nano::block_hash const & top_hash_a) :
459  	account (account_a),
460  	bottom_height (bottom_height_a),
461  	bottom_hash (bottom_hash_a),
462  	top_height (top_height_a),
463  	top_hash (top_hash_a)
464  {
465  }
466  nano::confirmation_height_bounded::receive_source_pair::receive_source_pair (confirmation_height_bounded::receive_chain_details const & receive_details_a, const block_hash & source_a) :
467  	receive_details (receive_details_a),
468  	source_hash (source_a)
469  {
470  }
471  nano::confirmation_height_bounded::confirmed_info::confirmed_info (uint64_t confirmed_height_a, nano::block_hash const & iterated_frontier_a) :
472  	confirmed_height (confirmed_height_a),
473  	iterated_frontier (iterated_frontier_a)
474  {
475  }
476  std::unique_ptr<nano::container_info_component> nano::collect_container_info (confirmation_height_bounded & confirmation_height_bounded, std::string const & name_a)
477  {
478  	auto composite = std::make_unique<container_info_composite> (name_a);
479  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "pending_writes", confirmation_height_bounded.pending_writes_size, sizeof (decltype (confirmation_height_bounded.pending_writes)::value_type) }));
480  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "accounts_confirmed_info", confirmation_height_bounded.accounts_confirmed_info_size, sizeof (decltype (confirmation_height_bounded.accounts_confirmed_info)::value_type) }));
481  	return composite;
482  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_lrn_layer.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_bounded.cpp</div>
                <div class="column column_space"><pre><code>197    if (bwd_bottom_diff->conversion_needed()) {
198      bottom[0]->set_prv_diff_descriptor(bwd_bottom_diff);
199      lrn_res[dnnResourceDiffSrc] = bottom[0]->mutable_prv_diff();
200    } else {
201      lrn_res[dnnResourceDiffSrc] = bottom[0]->mutable_cpu_diff();
202    }
203    PERFORMANCE_EVENT_ID_INIT(perf_id_bw_, PERFORMANCE_MKL_NAME("BW"));
204    PERFORMANCE_MEASUREMENT_BEGIN();
205    e = dnnExecute<Dtype>(lrnBwd, lrn_res);
206    PERFORMANCE_MEASUREMENT_END_ID(perf_id_bw_);
207    CHECK_EQ(e, E_SUCCESS);
208  }
</pre></code></div>
                <div class="column column_space"><pre><code>255  			if (preparation_data_a.account_it != accounts_confirmed_info.cend ())
256  			{
257  				preparation_data_a.account_it->second = confirmed_info_l;
258  			}
259  			else
260  			{
261  				accounts_confirmed_info.emplace (preparation_data_a.account, confirmed_info_l);
262  				++accounts_confirmed_info_size;
263  			}
264  			preparation_data_a.checkpoints.erase (std::remove (preparation_data_a.checkpoints.begin (), preparation_data_a.checkpoints.end (), preparation_data_a.top_most_non_receive_block_hash), preparation_data_a.checkpoints.end ());
265  			pending_writes.emplace_back (preparation_data_a.account, preparation_data_a.bottom_height, preparation_data_a.bottom_most, block_height, preparation_data_a.top_most_non_receive_block_hash);
266  			++pending_writes_size;
267  		}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    