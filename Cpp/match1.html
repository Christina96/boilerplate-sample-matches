<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for interactive_marker_client.cpp &amp; single_client.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for interactive_marker_client.cpp &amp; single_client.cpp
      </h3>
<h1 align="center">
        5.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>interactive_marker_client.cpp (5.6603775%)<th>single_client.cpp (5.479452%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(106-121)<td><a href="#" name="0">(138-153)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>interactive_marker_client.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Willow Garage, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Author: David Gossow
 */

#include "interactive_markers/interactive_marker_client.h"
#include "interactive_markers/detail/single_client.h"

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/make_shared.hpp&gt;

//#define DBG_MSG( ... ) ROS_DEBUG_NAMED( "interactive_markers", __VA_ARGS__ );
#define DBG_MSG( ... ) ROS_DEBUG( __VA_ARGS__ );
//#define DBG_MSG( ... ) printf("   "); printf( __VA_ARGS__ ); printf("\n");

namespace interactive_markers
{

InteractiveMarkerClient::InteractiveMarkerClient(
    tf2_ros::Buffer&amp; tf,
    const std::string&amp; target_frame,
    const std::string &amp;topic_ns )
: state_("InteractiveMarkerClient",IDLE)
, tf_(tf)
, last_num_publishers_(0)
, enable_autocomplete_transparency_(true)
{
  target_frame_ = target_frame;
  if ( !topic_ns.empty() )
  {
    subscribe( topic_ns );
  }
  callbacks_.setStatusCb( boost::bind( &amp;InteractiveMarkerClient::statusCb, this, _1, _2, _3 ) );
}

InteractiveMarkerClient::~InteractiveMarkerClient()
{
  shutdown();
}

/// Subscribe to given topic
void InteractiveMarkerClient::subscribe( std::string topic_ns )
{
  topic_ns_ = topic_ns;
  subscribeUpdate();
  subscribeInit();
}

void InteractiveMarkerClient::setInitCb( const InitCallback&amp; cb )
{
  callbacks_.setInitCb( cb );
}

void InteractiveMarkerClient::setUpdateCb( const UpdateCallback&amp; cb )
{
  callbacks_.setUpdateCb( cb );
}

void InteractiveMarkerClient::setResetCb( const ResetCallback&amp; cb )
{
  callbacks_.setResetCb( cb );
}

void InteractiveMarkerClient::setStatusCb( const StatusCallback&amp; cb )
{
  status_cb_ = cb;
}

void InteractiveMarkerClient::setTargetFrame( std::string target_frame )
{
  target_frame_ = target_frame;
  DBG_MSG("Target frame is now %s", target_frame_.c_str() );

  switch ( state_ )
  {
  case IDLE:
<a name="0"></a>    break;

  case INIT:
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case RUNNING:
    shutdown();
    subscribeUpdate();
    subscribeInit();
    break;
  }
}

void InteractiveMarkerClient::shutdown()
{
  switch ( state_ )
  {
  case IDLE:
    break;

  case INIT:</b></font>
  case RUNNING:
    init_sub_.shutdown();
    update_sub_.shutdown();
    boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);
    publisher_contexts_.clear();
    last_num_publishers_=0;
    state_=IDLE;
    break;
  }
}

void InteractiveMarkerClient::subscribeUpdate()
{
  if ( !topic_ns_.empty() )
  {
    try
    {
      update_sub_ = nh_.subscribe( topic_ns_+"/update", 100, &amp;InteractiveMarkerClient::processUpdate, this );
      DBG_MSG( "Subscribed to update topic: %s", (topic_ns_+"/update").c_str() );
    }
    catch( ros::Exception&amp; e )
    {
      callbacks_.statusCb( ERROR, "General", "Error subscribing: " + std::string(e.what()) );
      return;
    }
  }
  callbacks_.statusCb( OK, "General", "Waiting for messages.");
}

void InteractiveMarkerClient::subscribeInit()
{
  if ( state_ != INIT &amp;&amp; !topic_ns_.empty() )
  {
    try
    {
      init_sub_ = nh_.subscribe( topic_ns_+"/update_full", 100, &amp;InteractiveMarkerClient::processInit, this );
      DBG_MSG( "Subscribed to init topic: %s", (topic_ns_+"/update_full").c_str() );
      state_ = INIT;
    }
    catch( ros::Exception&amp; e )
    {
      callbacks_.statusCb( ERROR, "General", "Error subscribing: " + std::string(e.what()) );
    }
  }
}

template&lt;class MsgConstPtrT&gt;
void InteractiveMarkerClient::process( const MsgConstPtrT&amp; msg )
{
  callbacks_.statusCb( OK, "General", "Receiving messages.");

  // get caller ID of the sending entity
  if ( msg-&gt;server_id.empty() )
  {
    callbacks_.statusCb( ERROR, "General", "Received message with empty server_id!");
    return;
  }

  SingleClientPtr client;
  {
    boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);

    M_SingleClient::iterator context_it = publisher_contexts_.find(msg-&gt;server_id);

    // If we haven't seen this publisher before, we need to reset the
    // display and listen to the init topic, plus of course add this
    // publisher to our list.
    if ( context_it == publisher_contexts_.end() )
    {
      DBG_MSG( "New publisher detected: %s", msg-&gt;server_id.c_str() );

      SingleClientPtr pc(new SingleClient( msg-&gt;server_id, tf_, target_frame_, callbacks_ ));
      context_it = publisher_contexts_.insert( std::make_pair(msg-&gt;server_id,pc) ).first;
      client = pc;

      // we need to subscribe to the init topic again
      subscribeInit();
    }

    client = context_it-&gt;second;
  }

  // forward init/update to respective context
  client-&gt;process( msg, enable_autocomplete_transparency_ );
}

void InteractiveMarkerClient::processInit( const InitConstPtr&amp; msg )
{
  process&lt;InitConstPtr&gt;(msg);
}

void InteractiveMarkerClient::processUpdate( const UpdateConstPtr&amp; msg )
{
  process&lt;UpdateConstPtr&gt;(msg);
}

void InteractiveMarkerClient::update()
{
  switch ( state_ )
  {
  case IDLE:
    break;

  case INIT:
  case RUNNING:
  {
    // check if one publisher has gone offline
    if ( update_sub_.getNumPublishers() &lt; last_num_publishers_ )
    {
      callbacks_.statusCb( ERROR, "General", "Server is offline. Resetting." );
      shutdown();
      subscribeUpdate();
      subscribeInit();
      return;
    }
    last_num_publishers_ = update_sub_.getNumPublishers();

    // check if all single clients are finished with the init channels
    bool initialized = true;
    boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);
    M_SingleClient::iterator it;
    for ( it = publisher_contexts_.begin(); it!=publisher_contexts_.end(); ++it )
    {
      // Explicitly reference the pointer to the client here, because the client
      // might call user code, which might call shutdown(), which will delete
      // the publisher_contexts_ map...

      SingleClientPtr single_client = it-&gt;second;
      single_client-&gt;update();
      if ( !single_client-&gt;isInitialized() )
      {
        initialized = false;
      }

      if ( publisher_contexts_.empty() )
        break; // Yep, someone called shutdown()...
    }
    if ( state_ == INIT &amp;&amp; initialized )
    {
      init_sub_.shutdown();
      state_ = RUNNING;
    }
    if ( state_ == RUNNING &amp;&amp; !initialized )
    {
      subscribeInit();
    }
    break;
  }
  }
}

void InteractiveMarkerClient::statusCb( StatusT status, const std::string&amp; server_id, const std::string&amp; msg )
{
  switch ( status )
  {
  case OK:
    DBG_MSG( "%s: %s (Status: OK)", server_id.c_str(), msg.c_str() );
    break;
  case WARN:
    DBG_MSG( "%s: %s (Status: WARNING)", server_id.c_str(), msg.c_str() );
    break;
  case ERROR:
    DBG_MSG( "%s: %s (Status: ERROR)", server_id.c_str(), msg.c_str() );
    break;
  }

  if ( status_cb_ )
  {
    status_cb_( status, server_id, msg );
  }
}

}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>single_client.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Willow Garage, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: David Gossow
 */

#include "interactive_markers/detail/single_client.h"

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/make_shared.hpp&gt;

#define DBG_MSG( ... ) ROS_DEBUG( __VA_ARGS__ );
//#define DBG_MSG( ... ) printf("   "); printf( __VA_ARGS__ ); printf("\n");

namespace interactive_markers
{

SingleClient::SingleClient(
    const std::string&amp; server_id,
    tf2_ros::Buffer &amp;tf,
    const std::string&amp; target_frame,
    const InteractiveMarkerClient::CbCollection&amp; callbacks
)
: state_(server_id,INIT)
, first_update_seq_num_(-1)
, last_update_seq_num_(-1)
, tf_(tf)
, target_frame_(target_frame)
, callbacks_(callbacks)
, server_id_(server_id)
, warn_keepalive_(false)
{
  callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Waiting for init message." );
}

SingleClient::~SingleClient()
{
  callbacks_.resetCb( server_id_ );
}

void SingleClient::process(const visualization_msgs::InteractiveMarkerInit::ConstPtr&amp; msg, bool enable_autocomplete_transparency)
{
  DBG_MSG( "%s: received init #%lu", server_id_.c_str(), msg-&gt;seq_num );

  switch (state_)
  {
  case INIT:
    if ( init_queue_.size() &gt; 5 )
    {
      DBG_MSG( "Init queue too large. Erasing init message with id %lu.", init_queue_.begin()-&gt;msg-&gt;seq_num );
      init_queue_.pop_back();
    }
    init_queue_.push_front( InitMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency ) );
    callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Init message received." );
    break;

  case RECEIVING:
  case TF_ERROR:
    break;
  }
}

void SingleClient::process(const visualization_msgs::InteractiveMarkerUpdate::ConstPtr&amp; msg, bool enable_autocomplete_transparency)
{
  if ( first_update_seq_num_ == (uint64_t)-1 )
  {
    first_update_seq_num_ = msg-&gt;seq_num;
  }

  last_update_time_ = ros::Time::now();

  if ( msg-&gt;type == msg-&gt;KEEP_ALIVE )
  {
    DBG_MSG( "%s: received keep-alive #%lu", server_id_.c_str(), msg-&gt;seq_num );
    if (last_update_seq_num_ != (uint64_t)-1 &amp;&amp; msg-&gt;seq_num != last_update_seq_num_ )
    {
      std::ostringstream s;
      s &lt;&lt; "Sequence number of update is out of order. Expected: " &lt;&lt; last_update_seq_num_ &lt;&lt; " Received: " &lt;&lt; msg-&gt;seq_num;
      errorReset( s.str() );
      return;
    }
    last_update_seq_num_ = msg-&gt;seq_num;
    return;
  }
  else
  {
    DBG_MSG( "%s: received update #%lu", server_id_.c_str(), msg-&gt;seq_num );
    if (last_update_seq_num_ != (uint64_t)-1 &amp;&amp; msg-&gt;seq_num != last_update_seq_num_+1 )
    {
      std::ostringstream s;
      s &lt;&lt; "Sequence number of update is out of order. Expected: " &lt;&lt; last_update_seq_num_+1 &lt;&lt; " Received: " &lt;&lt; msg-&gt;seq_num;
      errorReset( s.str() );
      return;
    }
    last_update_seq_num_ = msg-&gt;seq_num;
  }

  switch (state_)
  {
  case INIT:
    if ( update_queue_.size() &gt; 100 )
    {
      DBG_MSG( "Update queue too large. Erasing update message with id %lu.", update_queue_.begin()-&gt;msg-&gt;seq_num );
      update_queue_.pop_back();
    }
    update_queue_.push_front( UpdateMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency) );
    break;

  case RECEIVING:
<a name="0"></a>    update_queue_.push_front( UpdateMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency) );
    break;

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case TF_ERROR:
    break;
  }
}

void SingleClient::update()
{
  switch (state_)
  {
  case INIT:
    transformInitMsgs();
    transformUpdateMsgs();
    checkInitFinished();
    break;

  case RECEIVING:</b></font>
    transformUpdateMsgs();
    pushUpdates();
    checkKeepAlive();
    if ( update_queue_.size() &gt; 100 )
    {
      errorReset( "Update queue overflow. Resetting connection." );
    }
    break;

  case TF_ERROR:
    if ( state_.getDuration().toSec() &gt; 1.0 )
    {
      callbacks_.statusCb( InteractiveMarkerClient::ERROR, server_id_, "1 second has passed. Re-initializing." );
      state_ = INIT;
    }
    break;
  }
}

void SingleClient::checkKeepAlive()
{
  double time_since_upd = (ros::Time::now() - last_update_time_).toSec();
  if ( time_since_upd &gt; 2.0 )
  {
    std::ostringstream s;
    s &lt;&lt; "No update received for " &lt;&lt; round(time_since_upd) &lt;&lt; " seconds.";
    callbacks_.statusCb( InteractiveMarkerClient::WARN, server_id_, s.str() );
    warn_keepalive_ = true;
  }
  else if ( warn_keepalive_ )
  {
    warn_keepalive_ = false;
    callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "OK" );
  }
}

void SingleClient::checkInitFinished()
{
  // check for all init messages received so far if tf info is ready
  // and the consecutive update exists.
  // If so, omit all updates with lower sequence number,
  // switch to RECEIVING mode and treat the init message like a regular update.

  if (last_update_seq_num_ == (uint64_t)-1)
  {
    callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Initialization: Waiting for first update/keep-alive message." );
    return;
  }

  M_InitMessageContext::iterator init_it;
  for ( init_it = init_queue_.begin(); init_it!=init_queue_.end(); ++init_it )
  {
    uint64_t init_seq_num = init_it-&gt;msg-&gt;seq_num;
    bool next_up_exists = init_seq_num &gt;= first_update_seq_num_ &amp;&amp; init_seq_num &lt;= last_update_seq_num_;

    if ( !init_it-&gt;isReady() )
    {
      // Do not override previous, more detailed status message generated in transformInitMsgs()
      // callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Initialization: Waiting for tf info." );
    }
    else if ( next_up_exists )
    {
      DBG_MSG( "Init message with seq_id=%lu is ready &amp; in line with updates. Switching to receive mode.", init_seq_num );
      while ( !update_queue_.empty() &amp;&amp; update_queue_.back().msg-&gt;seq_num &lt;= init_seq_num )
      {
        DBG_MSG( "Omitting update with seq_id=%lu", update_queue_.back().msg-&gt;seq_num );
        update_queue_.pop_back();
      }

      callbacks_.initCb( init_it-&gt;msg );
      callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Receiving updates." );

      init_queue_.clear();
      state_ = RECEIVING;

      pushUpdates();
      break;
    }
  }
}

void SingleClient::transformInitMsgs()
{
  M_InitMessageContext::iterator it;
  for ( it = init_queue_.begin(); it!=init_queue_.end(); )
  {
    try
    {
      it-&gt;getTfTransforms();
    }
    catch ( std::runtime_error&amp; e )
    {
      // we want to notify the user, but also keep the init message
      // in case it is the only one we will receive.
      std::ostringstream s;
      s &lt;&lt; "Cannot get tf info for init message with sequence number " &lt;&lt; it-&gt;msg-&gt;seq_num &lt;&lt; ". Error: " &lt;&lt; e.what();
      callbacks_.statusCb( InteractiveMarkerClient::WARN, server_id_, s.str() );
    }
    ++it;
  }
}

void SingleClient::transformUpdateMsgs( )
{
  M_UpdateMessageContext::iterator it;
  for ( it = update_queue_.begin(); it!=update_queue_.end(); ++it )
  {
    try
    {
      it-&gt;getTfTransforms();
    }
    catch ( std::runtime_error&amp; e )
    {
      std::ostringstream s;
      s &lt;&lt; "Resetting due to tf error: " &lt;&lt; e.what();
      errorReset( s.str() );
      return;
    }
    catch ( ... )
    {
      std::ostringstream s;
      s &lt;&lt; "Resetting due to unknown exception";
      errorReset( s.str() );
    }
  }
}

void SingleClient::errorReset( std::string error_msg )
{
  // if we get an error here, we re-initialize everything
  state_ = TF_ERROR;
  update_queue_.clear();
  init_queue_.clear();
  first_update_seq_num_ = -1;
  last_update_seq_num_ = -1;
  warn_keepalive_ = false;

  callbacks_.statusCb( InteractiveMarkerClient::ERROR, server_id_, error_msg );
  callbacks_.resetCb( server_id_ );
}

void SingleClient::pushUpdates()
{
  if( !update_queue_.empty() &amp;&amp; update_queue_.back().isReady() )
  {
    callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "OK" );
  }
  while( !update_queue_.empty() &amp;&amp; update_queue_.back().isReady() )
  {
    DBG_MSG("Pushing out update #%lu.", update_queue_.back().msg-&gt;seq_num );
    callbacks_.updateCb( update_queue_.back().msg );
    update_queue_.pop_back();
  }
}

bool SingleClient::isInitialized()
{
  return (state_ != INIT);
}

}

</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
