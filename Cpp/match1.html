<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for interactive_marker_client.cpp &amp; single_client.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for interactive_marker_client.cpp &amp; single_client.cpp
      </h3>
<h1 align="center">
        5.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>interactive_marker_client.cpp (5.6603775%)<th>single_client.cpp (5.479452%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(106-121)<td><a href="#" name="0">(138-153)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>interactive_marker_client.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "interactive_markers/interactive_marker_client.h"
2 #include "interactive_markers/detail/single_client.h"
3 #include &lt;boost/bind.hpp&gt;
4 #include &lt;boost/make_shared.hpp&gt;
5 #define DBG_MSG( ... ) ROS_DEBUG( __VA_ARGS__ );
6 namespace interactive_markers
7 {
8 InteractiveMarkerClient::InteractiveMarkerClient(
9     tf2_ros::Buffer&amp; tf,
10     const std::string&amp; target_frame,
11     const std::string &amp;topic_ns )
12 : state_("InteractiveMarkerClient",IDLE)
13 , tf_(tf)
14 , last_num_publishers_(0)
15 , enable_autocomplete_transparency_(true)
16 {
17   target_frame_ = target_frame;
18   if ( !topic_ns.empty() )
19   {
20     subscribe( topic_ns );
21   }
22   callbacks_.setStatusCb( boost::bind( &amp;InteractiveMarkerClient::statusCb, this, _1, _2, _3 ) );
23 }
24 InteractiveMarkerClient::~InteractiveMarkerClient()
25 {
26   shutdown();
27 }
28 void InteractiveMarkerClient::subscribe( std::string topic_ns )
29 {
30   topic_ns_ = topic_ns;
31   subscribeUpdate();
32   subscribeInit();
33 }
34 void InteractiveMarkerClient::setInitCb( const InitCallback&amp; cb )
35 {
36   callbacks_.setInitCb( cb );
37 }
38 void InteractiveMarkerClient::setUpdateCb( const UpdateCallback&amp; cb )
39 {
40   callbacks_.setUpdateCb( cb );
41 }
42 void InteractiveMarkerClient::setResetCb( const ResetCallback&amp; cb )
43 {
44   callbacks_.setResetCb( cb );
45 }
46 void InteractiveMarkerClient::setStatusCb( const StatusCallback&amp; cb )
47 {
48   status_cb_ = cb;
49 }
50 void InteractiveMarkerClient::setTargetFrame( std::string target_frame )
51 {
52   target_frame_ = target_frame;
53   DBG_MSG("Target frame is now %s", target_frame_.c_str() );
54   switch ( state_ )
55   {
56   case IDLE:
57 <a name="0"></a>    break;
58   case INIT:
59 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case RUNNING:
60     shutdown();
61     subscribeUpdate();
62     subscribeInit();
63     break;
64   }
65 }
66 void InteractiveMarkerClient::shutdown()
67 {
68   switch ( state_ )
69   {
70   case IDLE:
71     break;
72   case INIT:</b></font>
73   case RUNNING:
74     init_sub_.shutdown();
75     update_sub_.shutdown();
76     boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);
77     publisher_contexts_.clear();
78     last_num_publishers_=0;
79     state_=IDLE;
80     break;
81   }
82 }
83 void InteractiveMarkerClient::subscribeUpdate()
84 {
85   if ( !topic_ns_.empty() )
86   {
87     try
88     {
89       update_sub_ = nh_.subscribe( topic_ns_+"/update", 100, &amp;InteractiveMarkerClient::processUpdate, this );
90       DBG_MSG( "Subscribed to update topic: %s", (topic_ns_+"/update").c_str() );
91     }
92     catch( ros::Exception&amp; e )
93     {
94       callbacks_.statusCb( ERROR, "General", "Error subscribing: " + std::string(e.what()) );
95       return;
96     }
97   }
98   callbacks_.statusCb( OK, "General", "Waiting for messages.");
99 }
100 void InteractiveMarkerClient::subscribeInit()
101 {
102   if ( state_ != INIT &amp;&amp; !topic_ns_.empty() )
103   {
104     try
105     {
106       init_sub_ = nh_.subscribe( topic_ns_+"/update_full", 100, &amp;InteractiveMarkerClient::processInit, this );
107       DBG_MSG( "Subscribed to init topic: %s", (topic_ns_+"/update_full").c_str() );
108       state_ = INIT;
109     }
110     catch( ros::Exception&amp; e )
111     {
112       callbacks_.statusCb( ERROR, "General", "Error subscribing: " + std::string(e.what()) );
113     }
114   }
115 }
116 template&lt;class MsgConstPtrT&gt;
117 void InteractiveMarkerClient::process( const MsgConstPtrT&amp; msg )
118 {
119   callbacks_.statusCb( OK, "General", "Receiving messages.");
120   if ( msg-&gt;server_id.empty() )
121   {
122     callbacks_.statusCb( ERROR, "General", "Received message with empty server_id!");
123     return;
124   }
125   SingleClientPtr client;
126   {
127     boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);
128     M_SingleClient::iterator context_it = publisher_contexts_.find(msg-&gt;server_id);
129     if ( context_it == publisher_contexts_.end() )
130     {
131       DBG_MSG( "New publisher detected: %s", msg-&gt;server_id.c_str() );
132       SingleClientPtr pc(new SingleClient( msg-&gt;server_id, tf_, target_frame_, callbacks_ ));
133       context_it = publisher_contexts_.insert( std::make_pair(msg-&gt;server_id,pc) ).first;
134       client = pc;
135       subscribeInit();
136     }
137     client = context_it-&gt;second;
138   }
139   client-&gt;process( msg, enable_autocomplete_transparency_ );
140 }
141 void InteractiveMarkerClient::processInit( const InitConstPtr&amp; msg )
142 {
143   process&lt;InitConstPtr&gt;(msg);
144 }
145 void InteractiveMarkerClient::processUpdate( const UpdateConstPtr&amp; msg )
146 {
147   process&lt;UpdateConstPtr&gt;(msg);
148 }
149 void InteractiveMarkerClient::update()
150 {
151   switch ( state_ )
152   {
153   case IDLE:
154     break;
155   case INIT:
156   case RUNNING:
157   {
158     if ( update_sub_.getNumPublishers() &lt; last_num_publishers_ )
159     {
160       callbacks_.statusCb( ERROR, "General", "Server is offline. Resetting." );
161       shutdown();
162       subscribeUpdate();
163       subscribeInit();
164       return;
165     }
166     last_num_publishers_ = update_sub_.getNumPublishers();
167     bool initialized = true;
168     boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);
169     M_SingleClient::iterator it;
170     for ( it = publisher_contexts_.begin(); it!=publisher_contexts_.end(); ++it )
171     {
172       SingleClientPtr single_client = it-&gt;second;
173       single_client-&gt;update();
174       if ( !single_client-&gt;isInitialized() )
175       {
176         initialized = false;
177       }
178       if ( publisher_contexts_.empty() )
179         break;     }
180     if ( state_ == INIT &amp;&amp; initialized )
181     {
182       init_sub_.shutdown();
183       state_ = RUNNING;
184     }
185     if ( state_ == RUNNING &amp;&amp; !initialized )
186     {
187       subscribeInit();
188     }
189     break;
190   }
191   }
192 }
193 void InteractiveMarkerClient::statusCb( StatusT status, const std::string&amp; server_id, const std::string&amp; msg )
194 {
195   switch ( status )
196   {
197   case OK:
198     DBG_MSG( "%s: %s (Status: OK)", server_id.c_str(), msg.c_str() );
199     break;
200   case WARN:
201     DBG_MSG( "%s: %s (Status: WARNING)", server_id.c_str(), msg.c_str() );
202     break;
203   case ERROR:
204     DBG_MSG( "%s: %s (Status: ERROR)", server_id.c_str(), msg.c_str() );
205     break;
206   }
207   if ( status_cb_ )
208   {
209     status_cb_( status, server_id, msg );
210   }
211 }
212 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>single_client.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "interactive_markers/detail/single_client.h"
2 #include &lt;boost/bind.hpp&gt;
3 #include &lt;boost/make_shared.hpp&gt;
4 #define DBG_MSG( ... ) ROS_DEBUG( __VA_ARGS__ );
5 namespace interactive_markers
6 {
7 SingleClient::SingleClient(
8     const std::string&amp; server_id,
9     tf2_ros::Buffer &amp;tf,
10     const std::string&amp; target_frame,
11     const InteractiveMarkerClient::CbCollection&amp; callbacks
12 )
13 : state_(server_id,INIT)
14 , first_update_seq_num_(-1)
15 , last_update_seq_num_(-1)
16 , tf_(tf)
17 , target_frame_(target_frame)
18 , callbacks_(callbacks)
19 , server_id_(server_id)
20 , warn_keepalive_(false)
21 {
22   callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Waiting for init message." );
23 }
24 SingleClient::~SingleClient()
25 {
26   callbacks_.resetCb( server_id_ );
27 }
28 void SingleClient::process(const visualization_msgs::InteractiveMarkerInit::ConstPtr&amp; msg, bool enable_autocomplete_transparency)
29 {
30   DBG_MSG( "%s: received init #%lu", server_id_.c_str(), msg-&gt;seq_num );
31   switch (state_)
32   {
33   case INIT:
34     if ( init_queue_.size() &gt; 5 )
35     {
36       DBG_MSG( "Init queue too large. Erasing init message with id %lu.", init_queue_.begin()-&gt;msg-&gt;seq_num );
37       init_queue_.pop_back();
38     }
39     init_queue_.push_front( InitMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency ) );
40     callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Init message received." );
41     break;
42   case RECEIVING:
43   case TF_ERROR:
44     break;
45   }
46 }
47 void SingleClient::process(const visualization_msgs::InteractiveMarkerUpdate::ConstPtr&amp; msg, bool enable_autocomplete_transparency)
48 {
49   if ( first_update_seq_num_ == (uint64_t)-1 )
50   {
51     first_update_seq_num_ = msg-&gt;seq_num;
52   }
53   last_update_time_ = ros::Time::now();
54   if ( msg-&gt;type == msg-&gt;KEEP_ALIVE )
55   {
56     DBG_MSG( "%s: received keep-alive #%lu", server_id_.c_str(), msg-&gt;seq_num );
57     if (last_update_seq_num_ != (uint64_t)-1 &amp;&amp; msg-&gt;seq_num != last_update_seq_num_ )
58     {
59       std::ostringstream s;
60       s &lt;&lt; "Sequence number of update is out of order. Expected: " &lt;&lt; last_update_seq_num_ &lt;&lt; " Received: " &lt;&lt; msg-&gt;seq_num;
61       errorReset( s.str() );
62       return;
63     }
64     last_update_seq_num_ = msg-&gt;seq_num;
65     return;
66   }
67   else
68   {
69     DBG_MSG( "%s: received update #%lu", server_id_.c_str(), msg-&gt;seq_num );
70     if (last_update_seq_num_ != (uint64_t)-1 &amp;&amp; msg-&gt;seq_num != last_update_seq_num_+1 )
71     {
72       std::ostringstream s;
73       s &lt;&lt; "Sequence number of update is out of order. Expected: " &lt;&lt; last_update_seq_num_+1 &lt;&lt; " Received: " &lt;&lt; msg-&gt;seq_num;
74       errorReset( s.str() );
75       return;
76     }
77     last_update_seq_num_ = msg-&gt;seq_num;
78   }
79   switch (state_)
80   {
81   case INIT:
82     if ( update_queue_.size() &gt; 100 )
83     {
84       DBG_MSG( "Update queue too large. Erasing update message with id %lu.", update_queue_.begin()-&gt;msg-&gt;seq_num );
85       update_queue_.pop_back();
86     }
87     update_queue_.push_front( UpdateMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency) );
88     break;
89   case RECEIVING:
90 <a name="0"></a>    update_queue_.push_front( UpdateMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency) );
91     break;
92 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case TF_ERROR:
93     break;
94   }
95 }
96 void SingleClient::update()
97 {
98   switch (state_)
99   {
100   case INIT:
101     transformInitMsgs();
102     transformUpdateMsgs();
103     checkInitFinished();
104     break;
105   case RECEIVING:</b></font>
106     transformUpdateMsgs();
107     pushUpdates();
108     checkKeepAlive();
109     if ( update_queue_.size() &gt; 100 )
110     {
111       errorReset( "Update queue overflow. Resetting connection." );
112     }
113     break;
114   case TF_ERROR:
115     if ( state_.getDuration().toSec() &gt; 1.0 )
116     {
117       callbacks_.statusCb( InteractiveMarkerClient::ERROR, server_id_, "1 second has passed. Re-initializing." );
118       state_ = INIT;
119     }
120     break;
121   }
122 }
123 void SingleClient::checkKeepAlive()
124 {
125   double time_since_upd = (ros::Time::now() - last_update_time_).toSec();
126   if ( time_since_upd &gt; 2.0 )
127   {
128     std::ostringstream s;
129     s &lt;&lt; "No update received for " &lt;&lt; round(time_since_upd) &lt;&lt; " seconds.";
130     callbacks_.statusCb( InteractiveMarkerClient::WARN, server_id_, s.str() );
131     warn_keepalive_ = true;
132   }
133   else if ( warn_keepalive_ )
134   {
135     warn_keepalive_ = false;
136     callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "OK" );
137   }
138 }
139 void SingleClient::checkInitFinished()
140 {
141   if (last_update_seq_num_ == (uint64_t)-1)
142   {
143     callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Initialization: Waiting for first update/keep-alive message." );
144     return;
145   }
146   M_InitMessageContext::iterator init_it;
147   for ( init_it = init_queue_.begin(); init_it!=init_queue_.end(); ++init_it )
148   {
149     uint64_t init_seq_num = init_it-&gt;msg-&gt;seq_num;
150     bool next_up_exists = init_seq_num &gt;= first_update_seq_num_ &amp;&amp; init_seq_num &lt;= last_update_seq_num_;
151     if ( !init_it-&gt;isReady() )
152     {
153     }
154     else if ( next_up_exists )
155     {
156       DBG_MSG( "Init message with seq_id=%lu is ready &amp; in line with updates. Switching to receive mode.", init_seq_num );
157       while ( !update_queue_.empty() &amp;&amp; update_queue_.back().msg-&gt;seq_num &lt;= init_seq_num )
158       {
159         DBG_MSG( "Omitting update with seq_id=%lu", update_queue_.back().msg-&gt;seq_num );
160         update_queue_.pop_back();
161       }
162       callbacks_.initCb( init_it-&gt;msg );
163       callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "Receiving updates." );
164       init_queue_.clear();
165       state_ = RECEIVING;
166       pushUpdates();
167       break;
168     }
169   }
170 }
171 void SingleClient::transformInitMsgs()
172 {
173   M_InitMessageContext::iterator it;
174   for ( it = init_queue_.begin(); it!=init_queue_.end(); )
175   {
176     try
177     {
178       it-&gt;getTfTransforms();
179     }
180     catch ( std::runtime_error&amp; e )
181     {
182       std::ostringstream s;
183       s &lt;&lt; "Cannot get tf info for init message with sequence number " &lt;&lt; it-&gt;msg-&gt;seq_num &lt;&lt; ". Error: " &lt;&lt; e.what();
184       callbacks_.statusCb( InteractiveMarkerClient::WARN, server_id_, s.str() );
185     }
186     ++it;
187   }
188 }
189 void SingleClient::transformUpdateMsgs( )
190 {
191   M_UpdateMessageContext::iterator it;
192   for ( it = update_queue_.begin(); it!=update_queue_.end(); ++it )
193   {
194     try
195     {
196       it-&gt;getTfTransforms();
197     }
198     catch ( std::runtime_error&amp; e )
199     {
200       std::ostringstream s;
201       s &lt;&lt; "Resetting due to tf error: " &lt;&lt; e.what();
202       errorReset( s.str() );
203       return;
204     }
205     catch ( ... )
206     {
207       std::ostringstream s;
208       s &lt;&lt; "Resetting due to unknown exception";
209       errorReset( s.str() );
210     }
211   }
212 }
213 void SingleClient::errorReset( std::string error_msg )
214 {
215   state_ = TF_ERROR;
216   update_queue_.clear();
217   init_queue_.clear();
218   first_update_seq_num_ = -1;
219   last_update_seq_num_ = -1;
220   warn_keepalive_ = false;
221   callbacks_.statusCb( InteractiveMarkerClient::ERROR, server_id_, error_msg );
222   callbacks_.resetCb( server_id_ );
223 }
224 void SingleClient::pushUpdates()
225 {
226   if( !update_queue_.empty() &amp;&amp; update_queue_.back().isReady() )
227   {
228     callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, "OK" );
229   }
230   while( !update_queue_.empty() &amp;&amp; update_queue_.back().isReady() )
231   {
232     DBG_MSG("Pushing out update #%lu.", update_queue_.back().msg-&gt;seq_num );
233     callbacks_.updateCb( update_queue_.back().msg );
234     update_queue_.pop_back();
235   }
236 }
237 bool SingleClient::isInitialized()
238 {
239   return (state_ != INIT);
240 }
241 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
