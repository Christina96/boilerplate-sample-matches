<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for interactive_marker_client.cpp & single_client.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for interactive_marker_client.cpp & single_client.cpp
      </h3>
      <h1 align="center">
        5.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>interactive_marker_client.cpp (5.6603775%)<TH>single_client.cpp (5.479452%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1-0.html#0',2,'match1-1.html#0',3)" NAME="0">(106-121)<TD><A HREF="javascript:ZweiFrames('match1-0.html#0',2,'match1-1.html#0',3)" NAME="0">(138-153)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>interactive_marker_client.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Willow Garage, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Author: David Gossow
 */

#include &quot;interactive_markers/interactive_marker_client.h&quot;
#include &quot;interactive_markers/detail/single_client.h&quot;

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/make_shared.hpp&gt;

//#define DBG_MSG( ... ) ROS_DEBUG_NAMED( &quot;interactive_markers&quot;, __VA_ARGS__ );
#define DBG_MSG( ... ) ROS_DEBUG( __VA_ARGS__ );
//#define DBG_MSG( ... ) printf(&quot;   &quot;); printf( __VA_ARGS__ ); printf(&quot;\n&quot;);

namespace interactive_markers
{

InteractiveMarkerClient::InteractiveMarkerClient(
    tf2_ros::Buffer&amp; tf,
    const std::string&amp; target_frame,
    const std::string &amp;topic_ns )
: state_(&quot;InteractiveMarkerClient&quot;,IDLE)
, tf_(tf)
, last_num_publishers_(0)
, enable_autocomplete_transparency_(true)
{
  target_frame_ = target_frame;
  if ( !topic_ns.empty() )
  {
    subscribe( topic_ns );
  }
  callbacks_.setStatusCb( boost::bind( &amp;InteractiveMarkerClient::statusCb, this, _1, _2, _3 ) );
}

InteractiveMarkerClient::~InteractiveMarkerClient()
{
  shutdown();
}

/// Subscribe to given topic
void InteractiveMarkerClient::subscribe( std::string topic_ns )
{
  topic_ns_ = topic_ns;
  subscribeUpdate();
  subscribeInit();
}

void InteractiveMarkerClient::setInitCb( const InitCallback&amp; cb )
{
  callbacks_.setInitCb( cb );
}

void InteractiveMarkerClient::setUpdateCb( const UpdateCallback&amp; cb )
{
  callbacks_.setUpdateCb( cb );
}

void InteractiveMarkerClient::setResetCb( const ResetCallback&amp; cb )
{
  callbacks_.setResetCb( cb );
}

void InteractiveMarkerClient::setStatusCb( const StatusCallback&amp; cb )
{
  status_cb_ = cb;
}

void InteractiveMarkerClient::setTargetFrame( std::string target_frame )
{
  target_frame_ = target_frame;
  DBG_MSG(&quot;Target frame is now %s&quot;, target_frame_.c_str() );

  switch ( state_ )
  {
  case IDLE:
<A NAME="0"></A>    break;

  case INIT:
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1-1.html#0',3,'match1-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  case RUNNING:
    shutdown();
    subscribeUpdate();
    subscribeInit();
    break;
  }
}

void InteractiveMarkerClient::shutdown()
{
  switch ( state_ )
  {
  case IDLE:
    break;

  case INIT:</B></FONT>
  case RUNNING:
    init_sub_.shutdown();
    update_sub_.shutdown();
    boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);
    publisher_contexts_.clear();
    last_num_publishers_=0;
    state_=IDLE;
    break;
  }
}

void InteractiveMarkerClient::subscribeUpdate()
{
  if ( !topic_ns_.empty() )
  {
    try
    {
      update_sub_ = nh_.subscribe( topic_ns_+&quot;/update&quot;, 100, &amp;InteractiveMarkerClient::processUpdate, this );
      DBG_MSG( &quot;Subscribed to update topic: %s&quot;, (topic_ns_+&quot;/update&quot;).c_str() );
    }
    catch( ros::Exception&amp; e )
    {
      callbacks_.statusCb( ERROR, &quot;General&quot;, &quot;Error subscribing: &quot; + std::string(e.what()) );
      return;
    }
  }
  callbacks_.statusCb( OK, &quot;General&quot;, &quot;Waiting for messages.&quot;);
}

void InteractiveMarkerClient::subscribeInit()
{
  if ( state_ != INIT &amp;&amp; !topic_ns_.empty() )
  {
    try
    {
      init_sub_ = nh_.subscribe( topic_ns_+&quot;/update_full&quot;, 100, &amp;InteractiveMarkerClient::processInit, this );
      DBG_MSG( &quot;Subscribed to init topic: %s&quot;, (topic_ns_+&quot;/update_full&quot;).c_str() );
      state_ = INIT;
    }
    catch( ros::Exception&amp; e )
    {
      callbacks_.statusCb( ERROR, &quot;General&quot;, &quot;Error subscribing: &quot; + std::string(e.what()) );
    }
  }
}

template&lt;class MsgConstPtrT&gt;
void InteractiveMarkerClient::process( const MsgConstPtrT&amp; msg )
{
  callbacks_.statusCb( OK, &quot;General&quot;, &quot;Receiving messages.&quot;);

  // get caller ID of the sending entity
  if ( msg-&gt;server_id.empty() )
  {
    callbacks_.statusCb( ERROR, &quot;General&quot;, &quot;Received message with empty server_id!&quot;);
    return;
  }

  SingleClientPtr client;
  {
    boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);

    M_SingleClient::iterator context_it = publisher_contexts_.find(msg-&gt;server_id);

    // If we haven't seen this publisher before, we need to reset the
    // display and listen to the init topic, plus of course add this
    // publisher to our list.
    if ( context_it == publisher_contexts_.end() )
    {
      DBG_MSG( &quot;New publisher detected: %s&quot;, msg-&gt;server_id.c_str() );

      SingleClientPtr pc(new SingleClient( msg-&gt;server_id, tf_, target_frame_, callbacks_ ));
      context_it = publisher_contexts_.insert( std::make_pair(msg-&gt;server_id,pc) ).first;
      client = pc;

      // we need to subscribe to the init topic again
      subscribeInit();
    }

    client = context_it-&gt;second;
  }

  // forward init/update to respective context
  client-&gt;process( msg, enable_autocomplete_transparency_ );
}

void InteractiveMarkerClient::processInit( const InitConstPtr&amp; msg )
{
  process&lt;InitConstPtr&gt;(msg);
}

void InteractiveMarkerClient::processUpdate( const UpdateConstPtr&amp; msg )
{
  process&lt;UpdateConstPtr&gt;(msg);
}

void InteractiveMarkerClient::update()
{
  switch ( state_ )
  {
  case IDLE:
    break;

  case INIT:
  case RUNNING:
  {
    // check if one publisher has gone offline
    if ( update_sub_.getNumPublishers() &lt; last_num_publishers_ )
    {
      callbacks_.statusCb( ERROR, &quot;General&quot;, &quot;Server is offline. Resetting.&quot; );
      shutdown();
      subscribeUpdate();
      subscribeInit();
      return;
    }
    last_num_publishers_ = update_sub_.getNumPublishers();

    // check if all single clients are finished with the init channels
    bool initialized = true;
    boost::lock_guard&lt;boost::mutex&gt; lock(publisher_contexts_mutex_);
    M_SingleClient::iterator it;
    for ( it = publisher_contexts_.begin(); it!=publisher_contexts_.end(); ++it )
    {
      // Explicitly reference the pointer to the client here, because the client
      // might call user code, which might call shutdown(), which will delete
      // the publisher_contexts_ map...

      SingleClientPtr single_client = it-&gt;second;
      single_client-&gt;update();
      if ( !single_client-&gt;isInitialized() )
      {
        initialized = false;
      }

      if ( publisher_contexts_.empty() )
        break; // Yep, someone called shutdown()...
    }
    if ( state_ == INIT &amp;&amp; initialized )
    {
      init_sub_.shutdown();
      state_ = RUNNING;
    }
    if ( state_ == RUNNING &amp;&amp; !initialized )
    {
      subscribeInit();
    }
    break;
  }
  }
}

void InteractiveMarkerClient::statusCb( StatusT status, const std::string&amp; server_id, const std::string&amp; msg )
{
  switch ( status )
  {
  case OK:
    DBG_MSG( &quot;%s: %s (Status: OK)&quot;, server_id.c_str(), msg.c_str() );
    break;
  case WARN:
    DBG_MSG( &quot;%s: %s (Status: WARNING)&quot;, server_id.c_str(), msg.c_str() );
    break;
  case ERROR:
    DBG_MSG( &quot;%s: %s (Status: ERROR)&quot;, server_id.c_str(), msg.c_str() );
    break;
  }

  if ( status_cb_ )
  {
    status_cb_( status, server_id, msg );
  }
}

}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>single_client.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Willow Garage, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: David Gossow
 */

#include &quot;interactive_markers/detail/single_client.h&quot;

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/make_shared.hpp&gt;

#define DBG_MSG( ... ) ROS_DEBUG( __VA_ARGS__ );
//#define DBG_MSG( ... ) printf(&quot;   &quot;); printf( __VA_ARGS__ ); printf(&quot;\n&quot;);

namespace interactive_markers
{

SingleClient::SingleClient(
    const std::string&amp; server_id,
    tf2_ros::Buffer &amp;tf,
    const std::string&amp; target_frame,
    const InteractiveMarkerClient::CbCollection&amp; callbacks
)
: state_(server_id,INIT)
, first_update_seq_num_(-1)
, last_update_seq_num_(-1)
, tf_(tf)
, target_frame_(target_frame)
, callbacks_(callbacks)
, server_id_(server_id)
, warn_keepalive_(false)
{
  callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, &quot;Waiting for init message.&quot; );
}

SingleClient::~SingleClient()
{
  callbacks_.resetCb( server_id_ );
}

void SingleClient::process(const visualization_msgs::InteractiveMarkerInit::ConstPtr&amp; msg, bool enable_autocomplete_transparency)
{
  DBG_MSG( &quot;%s: received init #%lu&quot;, server_id_.c_str(), msg-&gt;seq_num );

  switch (state_)
  {
  case INIT:
    if ( init_queue_.size() &gt; 5 )
    {
      DBG_MSG( &quot;Init queue too large. Erasing init message with id %lu.&quot;, init_queue_.begin()-&gt;msg-&gt;seq_num );
      init_queue_.pop_back();
    }
    init_queue_.push_front( InitMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency ) );
    callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, &quot;Init message received.&quot; );
    break;

  case RECEIVING:
  case TF_ERROR:
    break;
  }
}

void SingleClient::process(const visualization_msgs::InteractiveMarkerUpdate::ConstPtr&amp; msg, bool enable_autocomplete_transparency)
{
  if ( first_update_seq_num_ == (uint64_t)-1 )
  {
    first_update_seq_num_ = msg-&gt;seq_num;
  }

  last_update_time_ = ros::Time::now();

  if ( msg-&gt;type == msg-&gt;KEEP_ALIVE )
  {
    DBG_MSG( &quot;%s: received keep-alive #%lu&quot;, server_id_.c_str(), msg-&gt;seq_num );
    if (last_update_seq_num_ != (uint64_t)-1 &amp;&amp; msg-&gt;seq_num != last_update_seq_num_ )
    {
      std::ostringstream s;
      s &lt;&lt; &quot;Sequence number of update is out of order. Expected: &quot; &lt;&lt; last_update_seq_num_ &lt;&lt; &quot; Received: &quot; &lt;&lt; msg-&gt;seq_num;
      errorReset( s.str() );
      return;
    }
    last_update_seq_num_ = msg-&gt;seq_num;
    return;
  }
  else
  {
    DBG_MSG( &quot;%s: received update #%lu&quot;, server_id_.c_str(), msg-&gt;seq_num );
    if (last_update_seq_num_ != (uint64_t)-1 &amp;&amp; msg-&gt;seq_num != last_update_seq_num_+1 )
    {
      std::ostringstream s;
      s &lt;&lt; &quot;Sequence number of update is out of order. Expected: &quot; &lt;&lt; last_update_seq_num_+1 &lt;&lt; &quot; Received: &quot; &lt;&lt; msg-&gt;seq_num;
      errorReset( s.str() );
      return;
    }
    last_update_seq_num_ = msg-&gt;seq_num;
  }

  switch (state_)
  {
  case INIT:
    if ( update_queue_.size() &gt; 100 )
    {
      DBG_MSG( &quot;Update queue too large. Erasing update message with id %lu.&quot;, update_queue_.begin()-&gt;msg-&gt;seq_num );
      update_queue_.pop_back();
    }
    update_queue_.push_front( UpdateMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency) );
    break;

  case RECEIVING:
<A NAME="0"></A>    update_queue_.push_front( UpdateMessageContext(tf_, target_frame_, msg, enable_autocomplete_transparency) );
    break;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1-0.html#0',2,'match1-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  case TF_ERROR:
    break;
  }
}

void SingleClient::update()
{
  switch (state_)
  {
  case INIT:
    transformInitMsgs();
    transformUpdateMsgs();
    checkInitFinished();
    break;

  case RECEIVING:</B></FONT>
    transformUpdateMsgs();
    pushUpdates();
    checkKeepAlive();
    if ( update_queue_.size() &gt; 100 )
    {
      errorReset( &quot;Update queue overflow. Resetting connection.&quot; );
    }
    break;

  case TF_ERROR:
    if ( state_.getDuration().toSec() &gt; 1.0 )
    {
      callbacks_.statusCb( InteractiveMarkerClient::ERROR, server_id_, &quot;1 second has passed. Re-initializing.&quot; );
      state_ = INIT;
    }
    break;
  }
}

void SingleClient::checkKeepAlive()
{
  double time_since_upd = (ros::Time::now() - last_update_time_).toSec();
  if ( time_since_upd &gt; 2.0 )
  {
    std::ostringstream s;
    s &lt;&lt; &quot;No update received for &quot; &lt;&lt; round(time_since_upd) &lt;&lt; &quot; seconds.&quot;;
    callbacks_.statusCb( InteractiveMarkerClient::WARN, server_id_, s.str() );
    warn_keepalive_ = true;
  }
  else if ( warn_keepalive_ )
  {
    warn_keepalive_ = false;
    callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, &quot;OK&quot; );
  }
}

void SingleClient::checkInitFinished()
{
  // check for all init messages received so far if tf info is ready
  // and the consecutive update exists.
  // If so, omit all updates with lower sequence number,
  // switch to RECEIVING mode and treat the init message like a regular update.

  if (last_update_seq_num_ == (uint64_t)-1)
  {
    callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, &quot;Initialization: Waiting for first update/keep-alive message.&quot; );
    return;
  }

  M_InitMessageContext::iterator init_it;
  for ( init_it = init_queue_.begin(); init_it!=init_queue_.end(); ++init_it )
  {
    uint64_t init_seq_num = init_it-&gt;msg-&gt;seq_num;
    bool next_up_exists = init_seq_num &gt;= first_update_seq_num_ &amp;&amp; init_seq_num &lt;= last_update_seq_num_;

    if ( !init_it-&gt;isReady() )
    {
      // Do not override previous, more detailed status message generated in transformInitMsgs()
      // callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, &quot;Initialization: Waiting for tf info.&quot; );
    }
    else if ( next_up_exists )
    {
      DBG_MSG( &quot;Init message with seq_id=%lu is ready &amp; in line with updates. Switching to receive mode.&quot;, init_seq_num );
      while ( !update_queue_.empty() &amp;&amp; update_queue_.back().msg-&gt;seq_num &lt;= init_seq_num )
      {
        DBG_MSG( &quot;Omitting update with seq_id=%lu&quot;, update_queue_.back().msg-&gt;seq_num );
        update_queue_.pop_back();
      }

      callbacks_.initCb( init_it-&gt;msg );
      callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, &quot;Receiving updates.&quot; );

      init_queue_.clear();
      state_ = RECEIVING;

      pushUpdates();
      break;
    }
  }
}

void SingleClient::transformInitMsgs()
{
  M_InitMessageContext::iterator it;
  for ( it = init_queue_.begin(); it!=init_queue_.end(); )
  {
    try
    {
      it-&gt;getTfTransforms();
    }
    catch ( std::runtime_error&amp; e )
    {
      // we want to notify the user, but also keep the init message
      // in case it is the only one we will receive.
      std::ostringstream s;
      s &lt;&lt; &quot;Cannot get tf info for init message with sequence number &quot; &lt;&lt; it-&gt;msg-&gt;seq_num &lt;&lt; &quot;. Error: &quot; &lt;&lt; e.what();
      callbacks_.statusCb( InteractiveMarkerClient::WARN, server_id_, s.str() );
    }
    ++it;
  }
}

void SingleClient::transformUpdateMsgs( )
{
  M_UpdateMessageContext::iterator it;
  for ( it = update_queue_.begin(); it!=update_queue_.end(); ++it )
  {
    try
    {
      it-&gt;getTfTransforms();
    }
    catch ( std::runtime_error&amp; e )
    {
      std::ostringstream s;
      s &lt;&lt; &quot;Resetting due to tf error: &quot; &lt;&lt; e.what();
      errorReset( s.str() );
      return;
    }
    catch ( ... )
    {
      std::ostringstream s;
      s &lt;&lt; &quot;Resetting due to unknown exception&quot;;
      errorReset( s.str() );
    }
  }
}

void SingleClient::errorReset( std::string error_msg )
{
  // if we get an error here, we re-initialize everything
  state_ = TF_ERROR;
  update_queue_.clear();
  init_queue_.clear();
  first_update_seq_num_ = -1;
  last_update_seq_num_ = -1;
  warn_keepalive_ = false;

  callbacks_.statusCb( InteractiveMarkerClient::ERROR, server_id_, error_msg );
  callbacks_.resetCb( server_id_ );
}

void SingleClient::pushUpdates()
{
  if( !update_queue_.empty() &amp;&amp; update_queue_.back().isReady() )
  {
    callbacks_.statusCb( InteractiveMarkerClient::OK, server_id_, &quot;OK&quot; );
  }
  while( !update_queue_.empty() &amp;&amp; update_queue_.back().isReady() )
  {
    DBG_MSG(&quot;Pushing out update #%lu.&quot;, update_queue_.back().msg-&gt;seq_num );
    callbacks_.updateCb( update_queue_.back().msg );
    update_queue_.pop_back();
  }
}

bool SingleClient::isInitialized()
{
  return (state_ != INIT);
}

}

</PRE>
</div>
  </div>
</body>
</html>
