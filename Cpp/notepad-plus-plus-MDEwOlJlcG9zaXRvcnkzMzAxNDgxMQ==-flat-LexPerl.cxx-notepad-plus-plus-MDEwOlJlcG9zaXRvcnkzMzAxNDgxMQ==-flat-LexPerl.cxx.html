
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPerl.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "WordList.h"
15  #include "LexAccessor.h"
16  #include "StyleContext.h"
17  #include "CharacterSet.h"
18  #include "LexerModule.h"
19  #include "OptionSet.h"
20  #include "DefaultLexer.h"
21  using namespace Scintilla;
22  using namespace Lexilla;
23  #define HERE_DELIM_MAX 256		
24  #define PERLNUM_BINARY		1	
25  #define PERLNUM_OCTAL		2
26  #define PERLNUM_FLOAT_EXP	3	
27  #define PERLNUM_HEX			4	
28  #define PERLNUM_DECIMAL		5	
29  #define PERLNUM_VECTOR		6
30  #define PERLNUM_V_VECTOR	7
31  #define PERLNUM_BAD			8
32  #define BACK_NONE		0	
33  #define BACK_OPERATOR	1	
34  #define BACK_KEYWORD	2	
35  #define SUB_BEGIN		0	
36  #define SUB_HAS_PROTO	1	
37  #define SUB_HAS_ATTRIB	2	
38  #define SUB_HAS_MODULE	3	
39  #define SUB_HAS_SUB		4	
40  #define	INTERPOLATE_SHIFT	(SCE_PL_STRING_VAR - SCE_PL_STRING)
41  static bool isPerlKeyword(Sci_PositionU start, Sci_PositionU end, WordList &keywords, LexAccessor &styler) {
42  	char s[100];
43  	Sci_PositionU i, len = end - start;
44  	if (len > 30) { len = 30; }
45  	for (i = 0; i < len; i++, start++) s[i] = styler[start];
46  	s[i] = '\0';
47  	return keywords.InList(s);
48  }
49  static int disambiguateBareword(LexAccessor &styler, Sci_PositionU bk, Sci_PositionU fw,
50          int backFlag, Sci_PositionU backPos, Sci_PositionU endPos) {
51  	int result = 0;
52  	bool moreback = false;		
53  	bool brace = false;			
54  	if (backFlag == BACK_NONE)
55  		return result;
56  	if (backPos <= static_cast<Sci_PositionU>(styler.LineStart(styler.GetLine(bk))))
57  		moreback = true;
58  	bk = backPos - 1;
59  	int ch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
60  	if (ch == '{' && !moreback) {
61  		brace = true;
62  	} else if ((ch == '&' && styler.SafeGetCharAt(bk - 1) != '&')
63  	        || styler.Match(bk - 1, "->")
64  	        || styler.Match(bk - 1, "::")
65  	        || styler.Match(bk - 2, "sub")) {
66  		result |= 1;
67  	}
68  	if ((ch == '{' || ch == '(' || ch == '['|| ch == ',')
69  	        && fw < endPos) {
70  		while (IsASpaceOrTab(ch = static_cast<unsigned char>(styler.SafeGetCharAt(fw)))
71  		        && fw < endPos) {
72  			fw++;
73  		}
74  		if ((ch == '}' && brace)
75  		        || styler.Match(fw, "=>")) {
76  			result |= 2;
77  		}
78  	}
79  	return result;
80  }
81  static void skipWhitespaceComment(LexAccessor &styler, Sci_PositionU &p) {
82  	while (p > 0) {
83  		const int style = styler.StyleAt(p);
84  		if (style != SCE_PL_DEFAULT && style != SCE_PL_COMMENTLINE)
85  			break;
86  		p--;
87  	}
88  }
89  static int findPrevLexeme(LexAccessor &styler, Sci_PositionU &bk, int &style) {
90  	skipWhitespaceComment(styler, bk);
91  	if (bk == 0)
92  		return 0;
93  	int sz = 1;
94  	style = styler.StyleAt(bk);
95  	while (bk > 0) {	
96  		if (styler.StyleAt(bk - 1) == style) {
97  			bk--; sz++;
98  		} else
99  			break;
100  	}
101  	return sz;
102  }
103  static int styleBeforeBracePair(LexAccessor &styler, Sci_PositionU bk) {
104  	int braceCount = 1;
105  	if (bk == 0)
106  		return SCE_PL_DEFAULT;
107  	while (--bk > 0) {
108  		if (styler.StyleAt(bk) == SCE_PL_OPERATOR) {
109  			int bkch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
110  			if (bkch == ';') {	
111  				break;
112  			} else if (bkch == '}') {
113  				braceCount++;
114  			} else if (bkch == '{') {
115  				if (--braceCount == 0) break;
116  			}
117  		}
118  	}
119  	if (bk > 0 && braceCount == 0) {
120  		bk--;
121  		skipWhitespaceComment(styler, bk);
122  		return styler.StyleAt(bk);
123  	}
124  	return SCE_PL_DEFAULT;
125  }
126  static int styleCheckIdentifier(LexAccessor &styler, Sci_PositionU bk) {
127  	if (styler.SafeGetCharAt(bk) == '>')	
128  		return 1;
129  	while (bk > 0 && styler.StyleAt(bk) == SCE_PL_IDENTIFIER) {
130  		bk--;
131  	}
132  	while (bk > 0) {
133  		int bkstyle = styler.StyleAt(bk);
134  		if (bkstyle == SCE_PL_DEFAULT
135  		        || bkstyle == SCE_PL_COMMENTLINE) {
136  		} else if (bkstyle == SCE_PL_OPERATOR) {
137  			if (styler.Match(bk - 1, "->") || styler.Match(bk - 1, "::"))
138  				return 2;
139  		} else
140  			return 3;	
141  		bk--;
142  	}
143  	return 0;
144  }
145  static int podLineScan(LexAccessor &styler, Sci_PositionU &pos, Sci_PositionU endPos) {
146  	int state = -1;
147  	while (pos < endPos) {
148  		int ch = static_cast<unsigned char>(styler.SafeGetCharAt(pos));
149  		if (ch == '\n' || ch == '\r') {
150  			if (ch == '\r' && styler.SafeGetCharAt(pos + 1) == '\n') pos++;
151  			break;
152  		}
153  		if (IsASpaceOrTab(ch)) {	
154  			if (state == -1)
155  				state = SCE_PL_DEFAULT;
156  		} else if (state == SCE_PL_DEFAULT) {	
157  			state = SCE_PL_POD_VERB;
158  		} else if (state != SCE_PL_POD_VERB) {	
159  			state = SCE_PL_POD;
160  		}
161  		pos++;
162  	}
163  	if (state == -1)
164  		state = SCE_PL_DEFAULT;
165  	return state;
166  }
167  static bool styleCheckSubPrototype(LexAccessor &styler, Sci_PositionU bk) {
168  	styler.Flush();
169  	int state = SUB_BEGIN;
170  	do {
171  		int style2 = SCE_PL_DEFAULT;
172  		Sci_PositionU pos2 = bk;
173  		int len2 = findPrevLexeme(styler, pos2, style2);
174  		int style1 = SCE_PL_DEFAULT;
175  		Sci_PositionU pos1 = pos2;
176  		if (pos1 > 0) pos1--;
177  		int len1 = findPrevLexeme(styler, pos1, style1);
178  		if (len1 == 0 || len2 == 0)		
179  			break;
180  		if (style1 == SCE_PL_OPERATOR && len1 == 1 &&
181  		    styler.SafeGetCharAt(pos1) == ':') {	
182  			if (style2 == SCE_PL_IDENTIFIER || style2 == SCE_PL_WORD) {
183  				if (len2 == 9 && styler.Match(pos2, "prototype")) {	
184  					if (state == SUB_BEGIN) {
185  						state = SUB_HAS_PROTO;
186  					} else
187  						break;
188  				} else {	
189  					if (state == SUB_HAS_PROTO || state == SUB_HAS_ATTRIB) {
190  						state = SUB_HAS_ATTRIB;
191  					} else
192  						break;
193  				}
194  			} else
195  				break;
196  		} else if (style1 == SCE_PL_OPERATOR && len1 == 2 &&
<span onclick='openModal()' class='match'>197  		           styler.Match(pos1, "::")) {	
198  			if (style2 == SCE_PL_IDENTIFIER) {	
199  				state = SUB_HAS_MODULE;
200  			} else
201  				break;
202  		} else if (style1 == SCE_PL_WORD && len1 == 3 &&
</span>203  		           styler.Match(pos1, "sub")) {	
204  			if (style2 == SCE_PL_IDENTIFIER) {	
205  				state = SUB_HAS_SUB;
206  			} else
207  				break;
208  		} else
209  			break;
210  		bk = pos1;			
211  		if (bk > 0) bk--;
212  	} while (state != SUB_HAS_SUB);
213  	return (state == SUB_HAS_SUB);
214  }
215  static int actualNumStyle(int numberStyle) {
216  	if (numberStyle == PERLNUM_VECTOR || numberStyle == PERLNUM_V_VECTOR) {
217  		return SCE_PL_STRING;
218  	} else if (numberStyle == PERLNUM_BAD) {
219  		return SCE_PL_ERROR;
220  	}
221  	return SCE_PL_NUMBER;
222  }
223  static int opposite(int ch) {
224  	if (ch == '(') return ')';
225  	if (ch == '[') return ']';
226  	if (ch == '{') return '}';
227  	if (ch == '<') return '>';
228  	return ch;
229  }
230  static bool IsCommentLine(Sci_Position line, LexAccessor &styler) {
231  	Sci_Position pos = styler.LineStart(line);
232  	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
233  	for (Sci_Position i = pos; i < eol_pos; i++) {
234  		char ch = styler[i];
235  		int style = styler.StyleAt(i);
236  		if (ch == '#' && style == SCE_PL_COMMENTLINE)
237  			return true;
238  		else if (!IsASpaceOrTab(ch))
239  			return false;
240  	}
241  	return false;
242  }
243  static bool IsPackageLine(Sci_Position line, LexAccessor &styler) {
244  	Sci_Position pos = styler.LineStart(line);
245  	int style = styler.StyleAt(pos);
246  	if (style == SCE_PL_WORD && styler.Match(pos, "package")) {
247  		return true;
248  	}
249  	return false;
250  }
251  static int PodHeadingLevel(Sci_Position pos, LexAccessor &styler) {
252  	int lvl = static_cast<unsigned char>(styler.SafeGetCharAt(pos + 5));
253  	if (lvl >= '1' && lvl <= '4') {
254  		return lvl - '0';
255  	}
256  	return 0;
257  }
258  struct OptionsPerl {
259  	bool fold;
260  	bool foldComment;
261  	bool foldCompact;
262  	bool foldPOD;            
263  	bool foldPackage;        
264  	bool foldCommentExplicit;
265  	bool foldAtElse;
266  	OptionsPerl() {
267  		fold = false;
268  		foldComment = false;
269  		foldCompact = true;
270  		foldPOD = true;
271  		foldPackage = true;
272  		foldCommentExplicit = true;
273  		foldAtElse = false;
274  	}
275  };
276  static const char *const perlWordListDesc[] = {
277  	"Keywords",
278  	0
279  };
280  struct OptionSetPerl : public OptionSet<OptionsPerl> {
281  	OptionSetPerl() {
282  		DefineProperty("fold", &OptionsPerl::fold);
283  		DefineProperty("fold.comment", &OptionsPerl::foldComment);
284  		DefineProperty("fold.compact", &OptionsPerl::foldCompact);
285  		DefineProperty("fold.perl.pod", &OptionsPerl::foldPOD,
286  		        "Set to 0 to disable folding Pod blocks when using the Perl lexer.");
287  		DefineProperty("fold.perl.package", &OptionsPerl::foldPackage,
288  		        "Set to 0 to disable folding packages when using the Perl lexer.");
289  		DefineProperty("fold.perl.comment.explicit", &OptionsPerl::foldCommentExplicit,
290  		        "Set to 0 to disable explicit folding.");
291  		DefineProperty("fold.perl.at.else", &OptionsPerl::foldAtElse,
292  		               "This option enables Perl folding on a \"} else {\" line of an if statement.");
293  		DefineWordListSets(perlWordListDesc);
294  	}
295  };
296  class LexerPerl : public DefaultLexer {
297  	CharacterSet setWordStart;
298  	CharacterSet setWord;
299  	CharacterSet setSpecialVar;
300  	CharacterSet setControlVar;
301  	WordList keywords;
302  	OptionsPerl options;
303  	OptionSetPerl osPerl;
304  public:
305  	LexerPerl() :
306  		DefaultLexer("perl", SCLEX_PERL),
307  		setWordStart(CharacterSet::setAlpha, "_", 0x80, true),
308  		setWord(CharacterSet::setAlphaNum, "_", 0x80, true),
309  		setSpecialVar(CharacterSet::setNone, "\"$;<>&`'+,./\\%:=~!?@[]"),
310  		setControlVar(CharacterSet::setNone, "ACDEFHILMNOPRSTVWX") {
311  	}
312  	virtual ~LexerPerl() {
313  	}
314  	void SCI_METHOD Release() override {
315  		delete this;
316  	}
317  	int SCI_METHOD Version() const override {
318  		return lvRelease5;
319  	}
320  	const char *SCI_METHOD PropertyNames() override {
321  		return osPerl.PropertyNames();
322  	}
323  	int SCI_METHOD PropertyType(const char *name) override {
324  		return osPerl.PropertyType(name);
325  	}
326  	const char *SCI_METHOD DescribeProperty(const char *name) override {
327  		return osPerl.DescribeProperty(name);
328  	}
329  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
330  	const char * SCI_METHOD PropertyGet(const char *key) override {
331  		return osPerl.PropertyGet(key);
332  	}
333  	const char *SCI_METHOD DescribeWordListSets() override {
334  		return osPerl.DescribeWordListSets();
335  	}
336  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
337  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
338  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
339  	void *SCI_METHOD PrivateCall(int, void *) override {
340  		return 0;
341  	}
342  	static ILexer5 *LexerFactoryPerl() {
343  		return new LexerPerl();
344  	}
345  	int InputSymbolScan(StyleContext &sc);
346  	void InterpolateSegment(StyleContext &sc, int maxSeg, bool isPattern=false);
347  };
348  Sci_Position SCI_METHOD LexerPerl::PropertySet(const char *key, const char *val) {
349  	if (osPerl.PropertySet(&options, key, val)) {
350  		return 0;
351  	}
352  	return -1;
353  }
354  Sci_Position SCI_METHOD LexerPerl::WordListSet(int n, const char *wl) {
355  	WordList *wordListN = 0;
356  	switch (n) {
357  	case 0:
358  		wordListN = &keywords;
359  		break;
360  	}
361  	Sci_Position firstModification = -1;
362  	if (wordListN) {
363  		WordList wlNew;
364  		wlNew.Set(wl);
365  		if (*wordListN != wlNew) {
366  			wordListN->Set(wl);
367  			firstModification = 0;
368  		}
369  	}
370  	return firstModification;
371  }
372  int LexerPerl::InputSymbolScan(StyleContext &sc) {
373  	int c, sLen = 0;
374  	while ((c = sc.GetRelativeCharacter(++sLen)) != 0) {
375  		if (c == '\r' || c == '\n') {
376  			return 0;
377  		} else if (c == '>') {
378  			if (sc.Match("<=>"))	
379  				return 0;
380  			return sLen;
381  		}
382  	}
383  	return 0;
384  }
385  void LexerPerl::InterpolateSegment(StyleContext &sc, int maxSeg, bool isPattern) {
386  	while (maxSeg > 0) {
387  		bool isVar = false;
388  		int sLen = 0;
389  		if ((maxSeg > 1) && (sc.ch == '$' || sc.ch == '@')) {
390  			bool braces = false;
391  			sLen = 1;
392  			if (sc.ch == '$' && sc.chNext == '#') {	
393  				sLen++;
394  			}
395  			while ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '$'))	
396  				sLen++;
397  			if ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '{')) {	
398  				sLen++;
399  				braces = true;
400  			}
401  			if (maxSeg > sLen) {
402  				int c = sc.GetRelativeCharacter(sLen);
403  				if (setWordStart.Contains(c)) {	
404  					sLen++;
405  					isVar = true;
406  					while (maxSeg > sLen) {
407  						if (!setWord.Contains(sc.GetRelativeCharacter(sLen)))
408  							break;
409  						sLen++;
410  					}
411  				} else if (braces && IsADigit(c) && (sLen == 2)) {	
412  					sLen++;
413  					isVar = true;
414  				}
415  			}
416  			if (braces) {
417  				if ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '}')) {	
418  					sLen++;
419  				} else
420  					isVar = false;
421  			}
422  		}
423  		if (!isVar && (maxSeg > 1)) {	
424  			int c = sc.chNext;
425  			if (sc.ch == '$') {
426  				sLen = 1;
427  				if (IsADigit(c)) {	
428  					sLen++;
429  					isVar = true;
430  					while ((maxSeg > sLen) && IsADigit(sc.GetRelativeCharacter(sLen)))
431  						sLen++;
432  				} else if (setSpecialVar.Contains(c)) {	
433  					sLen++;
434  					isVar = true;
435  				} else if (!isPattern && ((c == '(') || (c == ')') || (c == '|'))) {	
436  					sLen++;
437  					isVar = true;
438  				} else if (c == '^') {	
439  					sLen++;
440  					if ((maxSeg > sLen) && setControlVar.Contains(sc.GetRelativeCharacter(sLen))) {
441  						sLen++;
442  						isVar = true;
443  					}
444  				}
445  			} else if (sc.ch == '@') {
446  				sLen = 1;
447  				if (!isPattern && ((c == '+') || (c == '-'))) {	
448  					sLen++;
449  					isVar = true;
450  				}
451  			}
452  		}
453  		if (isVar) {	
454  			if (sc.state < SCE_PL_STRING_VAR)
455  				sc.SetState(sc.state + INTERPOLATE_SHIFT);
456  			sc.Forward(sLen);
457  			maxSeg -= sLen;
458  		} else {
459  			if (sc.state >= SCE_PL_STRING_VAR)
460  				sc.SetState(sc.state - INTERPOLATE_SHIFT);
461  			sc.Forward();
462  			maxSeg--;
463  		}
464  	}
465  	if (sc.state >= SCE_PL_STRING_VAR)
466  		sc.SetState(sc.state - INTERPOLATE_SHIFT);
467  }
468  void SCI_METHOD LexerPerl::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
469  	LexAccessor styler(pAccess);
470  	WordList reWords;
471  	reWords.Set("elsif if split while");
472  	CharacterSet setSingleCharOp(CharacterSet::setNone, "rwxoRWXOezsfdlpSbctugkTBMAC");
473  	CharacterSet setPerlOperator(CharacterSet::setNone, "^&\\()-+=|{}[]:;>,?!.~");
474  	CharacterSet setQDelim(CharacterSet::setNone, "qrwx");
475  	CharacterSet setModifiers(CharacterSet::setAlpha);
476  	CharacterSet setPreferRE(CharacterSet::setNone, "*/<%");
477  	CharacterSet setVar(CharacterSet::setAlphaNum, "#$_'", 0x80, true);
478  	CharacterSet setArray(CharacterSet::setAlpha, "#$_+-", 0x80, true);
479  	CharacterSet setHash(CharacterSet::setAlpha, "#$_!^+-", 0x80, true);
480  	CharacterSet &setPOD = setModifiers;
481  	CharacterSet setNonHereDoc(CharacterSet::setDigits, "=$@");
482  	CharacterSet setHereDocDelim(CharacterSet::setAlphaNum, "_");
483  	CharacterSet setSubPrototype(CharacterSet::setNone, "\\[$@%&*+];_ \t");
484  	CharacterSet setRepetition(CharacterSet::setDigits, ")\"'");
485  	CharacterSet setFormatStart(CharacterSet::setAlpha, "_=");
486  	CharacterSet &setFormat = setHereDocDelim;
487  	class HereDocCls {	
488  	public:
489  		int State;
490  		int Quote;		
491  		bool Quoted;		
492  		bool StripIndent;	
493  		int DelimiterLength;	
494  		char Delimiter[HERE_DELIM_MAX];	
495  		HereDocCls() {
496  			State = 0;
497  			Quote = 0;
498  			Quoted = false;
499  			StripIndent = false;
500  			DelimiterLength = 0;
501  			Delimiter[0] = '\0';
502  		}
503  		void Append(int ch) {
504  			Delimiter[DelimiterLength++] = static_cast<char>(ch);
505  			Delimiter[DelimiterLength] = '\0';
506  		}
507  		~HereDocCls() {
508  		}
509  	};
510  	HereDocCls HereDoc;		
511  	class QuoteCls {	
512  	public:
513  		int Rep;
514  		int Count;
515  		int Up, Down;
516  		QuoteCls() {
517  			New(1);
518  		}
519  		void New(int r = 1) {
520  			Rep   = r;
521  			Count = 0;
522  			Up    = '\0';
523  			Down  = '\0';
524  		}
525  		void Open(int u) {
526  			Count++;
527  			Up    = u;
528  			Down  = opposite(Up);
529  		}
530  	};
531  	QuoteCls Quote;
532  	int numState = PERLNUM_DECIMAL;
533  	int dotCount = 0;
534  	Sci_PositionU endPos = startPos + length;
535  	if (initStyle == SCE_PL_HERE_Q
536  	    || initStyle == SCE_PL_HERE_QQ
537  	    || initStyle == SCE_PL_HERE_QX
538  	    || initStyle == SCE_PL_FORMAT
539  	    || initStyle == SCE_PL_HERE_QQ_VAR
540  	    || initStyle == SCE_PL_HERE_QX_VAR
541  	   ) {
542  		int delim = (initStyle == SCE_PL_FORMAT) ? SCE_PL_FORMAT_IDENT:SCE_PL_HERE_DELIM;
543  		while ((startPos > 1) && (styler.StyleAt(startPos) != delim)) {
544  			startPos--;
545  		}
546  		startPos = styler.LineStart(styler.GetLine(startPos));
547  		initStyle = styler.StyleAt(startPos - 1);
548  	}
549  	if (initStyle == SCE_PL_STRING
550  	    || initStyle == SCE_PL_STRING_QQ
551  	    || initStyle == SCE_PL_BACKTICKS
552  	    || initStyle == SCE_PL_STRING_QX
553  	    || initStyle == SCE_PL_REGEX
554  	    || initStyle == SCE_PL_STRING_QR
555  	    || initStyle == SCE_PL_REGSUBST
556  	    || initStyle == SCE_PL_STRING_VAR
557  	    || initStyle == SCE_PL_STRING_QQ_VAR
558  	    || initStyle == SCE_PL_BACKTICKS_VAR
559  	    || initStyle == SCE_PL_STRING_QX_VAR
560  	    || initStyle == SCE_PL_REGEX_VAR
561  	    || initStyle == SCE_PL_STRING_QR_VAR
562  	    || initStyle == SCE_PL_REGSUBST_VAR
563  	   ) {
564  		int otherStyle = (initStyle >= SCE_PL_STRING_VAR) ?
565  			initStyle - INTERPOLATE_SHIFT : initStyle + INTERPOLATE_SHIFT;
566  		while (startPos > 1) {
567  			int st = styler.StyleAt(startPos - 1);
568  			if ((st != initStyle) && (st != otherStyle))
569  				break;
570  			startPos--;
571  		}
572  		initStyle = SCE_PL_DEFAULT;
573  	} else if (initStyle == SCE_PL_STRING_Q
574  	        || initStyle == SCE_PL_STRING_QW
575  	        || initStyle == SCE_PL_XLAT
576  	        || initStyle == SCE_PL_CHARACTER
577  	        || initStyle == SCE_PL_NUMBER
578  	        || initStyle == SCE_PL_IDENTIFIER
579  	        || initStyle == SCE_PL_ERROR
580  	        || initStyle == SCE_PL_SUB_PROTOTYPE
581  	   ) {
582  		while ((startPos > 1) && (styler.StyleAt(startPos - 1) == initStyle)) {
583  			startPos--;
584  		}
585  		initStyle = SCE_PL_DEFAULT;
586  	} else if (initStyle == SCE_PL_POD
587  	        || initStyle == SCE_PL_POD_VERB
588  	          ) {
589  		Sci_Position ln = styler.GetLine(startPos);
590  		if (ln > 0) {
591  			initStyle = styler.StyleAt(styler.LineStart(--ln));
592  			if (initStyle == SCE_PL_POD || initStyle == SCE_PL_POD_VERB) {
593  				while (ln > 0 && styler.GetLineState(ln) == SCE_PL_DEFAULT)
594  					ln--;
595  			}
596  			startPos = styler.LineStart(++ln);
597  			initStyle = styler.StyleAt(startPos - 1);
598  		} else {
599  			startPos = 0;
600  			initStyle = SCE_PL_DEFAULT;
601  		}
602  	}
603  	int backFlag = BACK_NONE;
604  	Sci_PositionU backPos = startPos;
605  	if (backPos > 0) {
606  		backPos--;
607  		skipWhitespaceComment(styler, backPos);
608  		if (styler.StyleAt(backPos) == SCE_PL_OPERATOR)
609  			backFlag = BACK_OPERATOR;
610  		else if (styler.StyleAt(backPos) == SCE_PL_WORD)
611  			backFlag = BACK_KEYWORD;
612  		backPos++;
613  	}
614  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
615  	for (; sc.More(); sc.Forward()) {
616  		switch (sc.state) {
617  		case SCE_PL_OPERATOR:
618  			sc.SetState(SCE_PL_DEFAULT);
619  			backFlag = BACK_OPERATOR;
620  			backPos = sc.currentPos;
621  			break;
622  		case SCE_PL_IDENTIFIER:		
623  			if ((!setWord.Contains(sc.ch) && sc.ch != '\'')
624  			        || sc.Match('.', '.')
625  			        || sc.chPrev == '>') {	
626  				sc.SetState(SCE_PL_DEFAULT);
627  			}
628  			break;
629  		case SCE_PL_WORD:		
630  			if (!setWord.Contains(sc.ch)) {
631  				char s[100];
632  				sc.GetCurrent(s, sizeof(s));
633  				if ((strcmp(s, "__DATA__") == 0) || (strcmp(s, "__END__") == 0)) {
634  					sc.ChangeState(SCE_PL_DATASECTION);
635  				} else {
636  					if ((strcmp(s, "format") == 0)) {
637  						sc.SetState(SCE_PL_FORMAT_IDENT);
638  						HereDoc.State = 0;
639  					} else {
640  						sc.SetState(SCE_PL_DEFAULT);
641  					}
642  					backFlag = BACK_KEYWORD;
643  					backPos = sc.currentPos;
644  				}
645  			}
646  			break;
647  		case SCE_PL_SCALAR:
648  		case SCE_PL_ARRAY:
649  		case SCE_PL_HASH:
650  		case SCE_PL_SYMBOLTABLE:
651  			if (sc.Match(':', ':')) {	
652  				sc.Forward();
653  			} else if (!setVar.Contains(sc.ch)) {
654  				if (sc.LengthCurrent() == 1) {
655  					sc.Forward();
656  				}
657  				sc.SetState(SCE_PL_DEFAULT);
658  			}
659  			break;
660  		case SCE_PL_NUMBER:
661  			if (sc.ch == '.') {
662  				if (sc.chNext == '.') {
663  				} else if (numState <= PERLNUM_FLOAT_EXP) {
664  					sc.SetState(SCE_PL_OPERATOR);
665  					break;
666  				} else {	
667  					dotCount++;
668  					if (numState == PERLNUM_DECIMAL) {
669  						if (dotCount <= 1)	
670  							break;
671  						if (IsADigit(sc.chNext)) {	
672  							numState = PERLNUM_VECTOR;
673  							break;
674  						}
675  					} else if (numState == PERLNUM_HEX) {
676  						if (dotCount <= 1 && IsADigit(sc.chNext, 16)) {
677  							break;	
678  						} else {
679  							sc.SetState(SCE_PL_OPERATOR);
680  							break;
681  						}
682  					} else if (IsADigit(sc.chNext))	
683  						break;
684  				}
685  			} else if (sc.ch == '_') {
686  				break;
687  			} else if (numState == PERLNUM_DECIMAL) {
688  				if (sc.ch == 'E' || sc.ch == 'e') {	
689  					numState = PERLNUM_FLOAT_EXP;
690  					if (sc.chNext == '+' || sc.chNext == '-') {
691  						sc.Forward();
692  					}
693  					break;
694  				} else if (IsADigit(sc.ch))
695  					break;
696  			} else if (numState == PERLNUM_HEX) {
697  				if (sc.ch == 'P' || sc.ch == 'p') {	
698  					numState = PERLNUM_FLOAT_EXP;
699  					if (sc.chNext == '+' || sc.chNext == '-') {
700  						sc.Forward();
701  					}
702  					break;
703  				} else if (IsADigit(sc.ch, 16))
704  					break;
705  			} else if (numState == PERLNUM_VECTOR || numState == PERLNUM_V_VECTOR) {
706  				if (IsADigit(sc.ch))	
707  					break;
708  				if (setWord.Contains(sc.ch) && dotCount == 0) {	
709  					sc.ChangeState(SCE_PL_IDENTIFIER);
710  					break;
711  				}
712  			} else if (IsADigit(sc.ch)) {
713  				if (numState == PERLNUM_FLOAT_EXP) {
714  					break;
715  				} else if (numState == PERLNUM_OCTAL) {
716  					if (sc.ch <= '7') break;
717  				} else if (numState == PERLNUM_BINARY) {
718  					if (sc.ch <= '1') break;
719  				}
720  				numState = PERLNUM_BAD;
721  				break;
722  			}
723  			sc.ChangeState(actualNumStyle(numState));
724  			sc.SetState(SCE_PL_DEFAULT);
725  			break;
726  		case SCE_PL_COMMENTLINE:
727  			if (sc.atLineStart) {
728  				sc.SetState(SCE_PL_DEFAULT);
729  			}
730  			break;
731  		case SCE_PL_HERE_DELIM:
732  			if (HereDoc.State == 0) { 
733  				int delim_ch = sc.chNext;
734  				Sci_Position ws_skip = 0;
735  				HereDoc.State = 1;	
736  				HereDoc.Quote = sc.chNext;
737  				HereDoc.Quoted = false;
738  				HereDoc.StripIndent = false;
739  				HereDoc.DelimiterLength = 0;
740  				HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
741  				if (delim_ch == '~') { 
742  					sc.Forward();
743  					HereDoc.StripIndent = true;
744  					HereDoc.Quote = delim_ch = sc.chNext;
745  				}
746  				if (IsASpaceOrTab(delim_ch)) {
747  					Sci_PositionU i = sc.currentPos + 1;
748  					while ((i < endPos) && IsASpaceOrTab(delim_ch)) {
749  						i++;
750  						delim_ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
751  					}
752  					ws_skip = i - sc.currentPos - 1;
753  				}
754  				if (delim_ch == '\'' || delim_ch == '"' || delim_ch == '`') {
755  					sc.Forward(ws_skip + 1);
756  					HereDoc.Quote = delim_ch;
757  					HereDoc.Quoted = true;
758  				} else if ((ws_skip == 0 && setNonHereDoc.Contains(sc.chNext))
759  				        || ws_skip > 0) {
760  					sc.ChangeState(SCE_PL_OPERATOR);
761  					sc.ForwardSetState(SCE_PL_DEFAULT);
762  					backFlag = BACK_OPERATOR;
763  					backPos = sc.currentPos;
764  					HereDoc.State = 0;
765  				} else {
766  					if (ws_skip == 0 && HereDoc.Quote == '\\')
767  						sc.Forward();
768  				}
769  			} else if (HereDoc.State == 1) { 
770  				backFlag = BACK_NONE;
771  				if (HereDoc.Quoted) { 
772  					if (sc.ch == HereDoc.Quote) { 
773  						sc.ForwardSetState(SCE_PL_DEFAULT);
774  					} else if (!sc.atLineEnd) {
775  						if (sc.Match('\\', static_cast<char>(HereDoc.Quote))) { 
776  							sc.Forward();
777  						}
778  						if (sc.ch != '\r') {	
779  							int i = 0;			
780  							while (i < sc.width) {
781  								HereDoc.Append(static_cast<unsigned char>(styler.SafeGetCharAt(sc.currentPos + i)));
782  								i++;
783  							}
784  						}
785  					}
786  				} else { 
787  					if (setHereDocDelim.Contains(sc.ch)) {
788  						HereDoc.Append(sc.ch);
789  					} else {
790  						sc.SetState(SCE_PL_DEFAULT);
791  					}
792  				}
793  				if (HereDoc.DelimiterLength >= HERE_DELIM_MAX - 1) {
794  					sc.SetState(SCE_PL_ERROR);
795  					HereDoc.State = 0;
796  				}
797  			}
798  			break;
799  		case SCE_PL_HERE_Q:
800  		case SCE_PL_HERE_QQ:
801  		case SCE_PL_HERE_QX:
802  			sc.Complete();
803  			if (HereDoc.StripIndent) {
804  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
805  					sc.Forward();
806  			}
807  			if (HereDoc.DelimiterLength == 0 || sc.Match(HereDoc.Delimiter)) {
808  				int c = sc.GetRelative(HereDoc.DelimiterLength);
809  				if (c == '\r' || c == '\n') {	
810  					sc.ForwardBytes(HereDoc.DelimiterLength);
811  					sc.SetState(SCE_PL_DEFAULT);
812  					backFlag = BACK_NONE;
813  					HereDoc.State = 0;
814  					if (!sc.atLineEnd)
815  						sc.Forward();
816  					break;
817  				}
818  			}
819  			if (sc.state == SCE_PL_HERE_Q) {	
820  				while (!sc.atLineEnd)
821  					sc.Forward();
822  				break;
823  			}
824  			while (!sc.atLineEnd) {		
825  				int c, sLen = 0, endType = 0;
826  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
827  					if (c == '\\') {
828  						endType = 1; break;
829  					} else if (c == '\r' || c == '\n') {
830  						endType = 2; break;
831  					}
832  					sLen++;
833  				}
834  				if (sLen > 0)	
835  					InterpolateSegment(sc, sLen);
836  				if (endType == 1) {
837  					sc.Forward();
838  					if (sc.ch != '\r' && sc.ch != '\n')
839  						sc.Forward();
840  				} else if (endType == 2) {
841  					if (!sc.atLineEnd)
842  						sc.Forward();
843  				}
844  			}
845  			break;
846  		case SCE_PL_POD:
847  		case SCE_PL_POD_VERB: {
848  				Sci_PositionU fw = sc.currentPos;
849  				Sci_Position ln = styler.GetLine(fw);
850  				if (sc.atLineStart && sc.Match("=cut")) {	
851  					sc.SetState(SCE_PL_POD);
852  					sc.Forward(4);
853  					sc.SetState(SCE_PL_DEFAULT);
854  					styler.SetLineState(ln, SCE_PL_POD);
855  					break;
856  				}
857  				int pod = podLineScan(styler, fw, endPos);	
858  				styler.SetLineState(ln, pod);
859  				if (pod == SCE_PL_DEFAULT) {
860  					if (sc.state == SCE_PL_POD_VERB) {
861  						Sci_PositionU fw2 = fw;
862  						while (fw2 < (endPos - 1) && pod == SCE_PL_DEFAULT) {
863  							fw = fw2++;	
864  							pod = podLineScan(styler, fw2, endPos);
865  							styler.SetLineState(styler.GetLine(fw2), pod);
866  						}
867  						if (pod == SCE_PL_POD) {	
868  							sc.SetState(SCE_PL_POD);
869  						} else
870  							fw = fw2;
871  					}
872  				} else {
873  					if (pod == SCE_PL_POD_VERB	
874  					        && (styler.GetLineState(ln - 1) == SCE_PL_POD)) {
875  						pod = SCE_PL_POD;
876  						styler.SetLineState(ln, pod);
877  					} else if (pod == SCE_PL_POD
878  					        && (styler.GetLineState(ln - 1) == SCE_PL_POD_VERB)) {
879  						pod = SCE_PL_POD_VERB;
880  						styler.SetLineState(ln, pod);
881  					}
882  					sc.SetState(pod);
883  				}
884  				sc.ForwardBytes(fw - sc.currentPos);	
885  			}
886  			break;
887  		case SCE_PL_REGEX:
888  		case SCE_PL_STRING_QR:
889  			if (Quote.Rep <= 0) {
890  				if (!setModifiers.Contains(sc.ch))
891  					sc.SetState(SCE_PL_DEFAULT);
892  			} else if (!Quote.Up && !IsASpace(sc.ch)) {
893  				Quote.Open(sc.ch);
894  			} else {
895  				int c, sLen = 0, endType = 0;
896  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
897  					if (IsASpace(c)) {
898  						break;
899  					} else if (c == '\\' && Quote.Up != '\\') {
900  						endType = 1; break;
901  					} else if (c == Quote.Down) {
902  						Quote.Count--;
903  						if (Quote.Count == 0) {
904  							Quote.Rep--;
905  							break;
906  						}
907  					} else if (c == Quote.Up)
908  						Quote.Count++;
909  					sLen++;
910  				}
911  				if (sLen > 0) {	
912  					if (Quote.Up != '\'') {
913  						InterpolateSegment(sc, sLen, true);
914  					} else		
915  						sc.Forward(sLen);
916  				}
917  				if (endType == 1)
918  					sc.Forward();
919  			}
920  			break;
921  		case SCE_PL_REGSUBST:
922  		case SCE_PL_XLAT:
923  			if (Quote.Rep <= 0) {
924  				if (!setModifiers.Contains(sc.ch))
925  					sc.SetState(SCE_PL_DEFAULT);
926  			} else if (!Quote.Up && !IsASpace(sc.ch)) {
927  				Quote.Open(sc.ch);
928  			} else {
929  				int c, sLen = 0, endType = 0;
930  				bool isPattern = (Quote.Rep == 2);
931  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
932  					if (c == '\\' && Quote.Up != '\\') {
933  						endType = 2; break;
934  					} else if (Quote.Count == 0 && Quote.Rep == 1) {
935  						if (IsASpace(c)) {
936  						} else if (c == '#' && IsASpaceOrTab(sc.GetRelativeCharacter(sLen - 1))) {
937  							endType = 3;
938  						} else
939  							Quote.Open(c);
940  						break;
941  					} else if (c == Quote.Down) {
942  						Quote.Count--;
943  						if (Quote.Count == 0) {
944  							Quote.Rep--;
945  							endType = 1;
946  						}
947  						if (Quote.Up == Quote.Down)
948  							Quote.Count++;
949  						if (endType == 1)
950  							break;
951  					} else if (c == Quote.Up) {
952  						Quote.Count++;
953  					} else if (IsASpace(c))
954  						break;
955  					sLen++;
956  				}
957  				if (sLen > 0) {	
958  					if (sc.state == SCE_PL_REGSUBST && Quote.Up != '\'') {
959  						InterpolateSegment(sc, sLen, isPattern);
960  					} else		
961  						sc.Forward(sLen);
962  				}
963  				if (endType == 2) {
964  					sc.Forward();
965  				} else if (endType == 3)
966  					sc.SetState(SCE_PL_DEFAULT);
967  			}
968  			break;
969  		case SCE_PL_STRING_Q:
970  		case SCE_PL_STRING_QQ:
971  		case SCE_PL_STRING_QX:
972  		case SCE_PL_STRING_QW:
973  		case SCE_PL_STRING:
974  		case SCE_PL_CHARACTER:
975  		case SCE_PL_BACKTICKS:
976  			if (!Quote.Down && !IsASpace(sc.ch)) {
977  				Quote.Open(sc.ch);
978  			} else {
979  				int c, sLen = 0, endType = 0;
980  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
981  					if (IsASpace(c)) {
982  						break;
983  					} else if (c == '\\' && Quote.Up != '\\') {
984  						endType = 2; break;
985  					} else if (c == Quote.Down) {
986  						Quote.Count--;
987  						if (Quote.Count == 0) {
988  							endType = 3; break;
989  						}
990  					} else if (c == Quote.Up)
991  						Quote.Count++;
992  					sLen++;
993  				}
994  				if (sLen > 0) {	
995  					switch (sc.state) {
996  					case SCE_PL_STRING:
997  					case SCE_PL_STRING_QQ:
998  					case SCE_PL_BACKTICKS:
999  						InterpolateSegment(sc, sLen);
1000  						break;
1001  					case SCE_PL_STRING_QX:
1002  						if (Quote.Up != '\'') {
1003  							InterpolateSegment(sc, sLen);
1004  							break;
1005  						}
1006  					default:	
1007  						sc.Forward(sLen);
1008  					}
1009  				}
1010  				if (endType == 2) {
1011  					sc.Forward();
1012  				} else if (endType == 3)
1013  					sc.ForwardSetState(SCE_PL_DEFAULT);
1014  			}
1015  			break;
1016  		case SCE_PL_SUB_PROTOTYPE: {
1017  				int i = 0;
1018  				while (setSubPrototype.Contains(sc.GetRelative(i)))
1019  					i++;
1020  				if (sc.GetRelative(i) == ')') {	
1021  					sc.ForwardBytes(i);
1022  					sc.ForwardSetState(SCE_PL_DEFAULT);
1023  				} else {
1024  					sc.ChangeState(SCE_PL_OPERATOR);
1025  					sc.SetState(SCE_PL_DEFAULT);
1026  				}
1027  			}
1028  			break;
1029  		case SCE_PL_FORMAT: {
1030  				sc.Complete();
1031  				if (sc.Match('.')) {
1032  					sc.Forward();
1033  					if (sc.atLineEnd || ((sc.ch == '\r' && sc.chNext == '\n')))
1034  						sc.SetState(SCE_PL_DEFAULT);
1035  				}
1036  				while (!sc.atLineEnd)
1037  					sc.Forward();
1038  			}
1039  			break;
1040  		case SCE_PL_ERROR:
1041  			break;
1042  		}
1043  		switch (sc.state) {
1044  		case SCE_PL_FORMAT_IDENT:
1045  			if (IsASpaceOrTab(sc.ch)) {		
1046  				sc.ChangeState(SCE_PL_DEFAULT);
1047  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
1048  					sc.Forward();
1049  				sc.SetState(SCE_PL_FORMAT_IDENT);
1050  			}
1051  			if (setFormatStart.Contains(sc.ch)) {	
1052  				if (sc.ch != '=') {
1053  					do {
1054  						sc.Forward();
1055  					} while (setFormat.Contains(sc.ch));
1056  				}
1057  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
1058  					sc.Forward();
1059  				if (sc.ch == '=') {
1060  					sc.ForwardSetState(SCE_PL_DEFAULT);
1061  					HereDoc.State = 3;
1062  				} else {
1063  					sc.ChangeState(SCE_PL_IDENTIFIER);
1064  					sc.SetState(SCE_PL_DEFAULT);
1065  				}
1066  			} else {
1067  				sc.ChangeState(SCE_PL_DEFAULT);	
1068  			}
1069  			backFlag = BACK_NONE;
1070  			break;
1071  		}
1072  		if (HereDoc.State == 1 && sc.atLineEnd) {
1073  			int st_new = SCE_PL_HERE_QQ;
1074  			HereDoc.State = 2;
1075  			if (HereDoc.Quoted) {
1076  				if (sc.state == SCE_PL_HERE_DELIM) {
1077  					sc.ChangeState(SCE_PL_ERROR);
1078  				}
1079  				switch (HereDoc.Quote) {
1080  				case '\'':
1081  					st_new = SCE_PL_HERE_Q;
1082  					break;
1083  				case '"' :
1084  					st_new = SCE_PL_HERE_QQ;
1085  					break;
1086  				case '`' :
1087  					st_new = SCE_PL_HERE_QX;
1088  					break;
1089  				}
1090  			} else {
1091  				if (HereDoc.Quote == '\\')
1092  					st_new = SCE_PL_HERE_Q;
1093  			}
1094  			sc.SetState(st_new);
1095  		}
1096  		if (HereDoc.State == 3 && sc.atLineEnd) {
1097  			HereDoc.State = 0;
1098  			sc.SetState(SCE_PL_FORMAT);
1099  		}
1100  		if (sc.state == SCE_PL_DEFAULT) {
1101  			if (IsADigit(sc.ch) ||
1102  			        (IsADigit(sc.chNext) && (sc.ch == '.' || sc.ch == 'v'))) {
1103  				sc.SetState(SCE_PL_NUMBER);
1104  				backFlag = BACK_NONE;
1105  				numState = PERLNUM_DECIMAL;
1106  				dotCount = 0;
1107  				if (sc.ch == '0') {		
1108  					if (sc.chNext == 'x' || sc.chNext == 'X') {
1109  						numState = PERLNUM_HEX;
1110  					} else if (sc.chNext == 'b' || sc.chNext == 'B') {
1111  						numState = PERLNUM_BINARY;
1112  					} else if (IsADigit(sc.chNext)) {
1113  						numState = PERLNUM_OCTAL;
1114  					}
1115  					if (numState != PERLNUM_DECIMAL) {
1116  						sc.Forward();
1117  					}
1118  				} else if (sc.ch == 'v') {		
1119  					numState = PERLNUM_V_VECTOR;
1120  				}
1121  			} else if (setWord.Contains(sc.ch)) {
1122  				sc.SetState(SCE_PL_WORD);
1123  				if (sc.chPrev == ':' && sc.GetRelative(-2) == ':') {
1124  					sc.ChangeState(SCE_PL_IDENTIFIER);
1125  				}
1126  				Sci_PositionU bk = sc.currentPos;
1127  				Sci_PositionU fw = sc.currentPos + 1;
1128  				if (sc.ch == 's' && !setWord.Contains(sc.chNext)) {
1129  					sc.ChangeState(SCE_PL_REGSUBST);
1130  					Quote.New(2);
1131  				} else if (sc.ch == 'm' && !setWord.Contains(sc.chNext)) {
1132  					sc.ChangeState(SCE_PL_REGEX);
1133  					Quote.New();
1134  				} else if (sc.ch == 'q' && !setWord.Contains(sc.chNext)) {
1135  					sc.ChangeState(SCE_PL_STRING_Q);
1136  					Quote.New();
1137  				} else if (sc.ch == 'y' && !setWord.Contains(sc.chNext)) {
1138  					sc.ChangeState(SCE_PL_XLAT);
1139  					Quote.New(2);
1140  				} else if (sc.Match('t', 'r') && !setWord.Contains(sc.GetRelative(2))) {
1141  					sc.ChangeState(SCE_PL_XLAT);
1142  					Quote.New(2);
1143  					sc.Forward();
1144  					fw++;
1145  				} else if (sc.ch == 'q' && setQDelim.Contains(sc.chNext)
1146  				        && !setWord.Contains(sc.GetRelative(2))) {
1147  					if (sc.chNext == 'q') sc.ChangeState(SCE_PL_STRING_QQ);
1148  					else if (sc.chNext == 'x') sc.ChangeState(SCE_PL_STRING_QX);
1149  					else if (sc.chNext == 'r') sc.ChangeState(SCE_PL_STRING_QR);
1150  					else sc.ChangeState(SCE_PL_STRING_QW);	
1151  					Quote.New();
1152  					sc.Forward();
1153  					fw++;
1154  				} else if (sc.ch == 'x' && (sc.chNext == '=' ||	
1155  				        !setWord.Contains(sc.chNext) ||
1156  				        (setRepetition.Contains(sc.chPrev) && IsADigit(sc.chNext)))) {
1157  					sc.ChangeState(SCE_PL_OPERATOR);
1158  				}
1159  				if (sc.state == SCE_PL_WORD) {
1160  					while (setWord.Contains(static_cast<unsigned char>(styler.SafeGetCharAt(fw))))
1161  						fw++;
1162  					if (!isPerlKeyword(styler.GetStartSegment(), fw, keywords, styler)) {
1163  						sc.ChangeState(SCE_PL_IDENTIFIER);
1164  					}
1165  				}
1166  				if (sc.state != SCE_PL_IDENTIFIER && bk > 0) {
1167  					if (disambiguateBareword(styler, bk, fw, backFlag, backPos, endPos))
1168  						sc.ChangeState(SCE_PL_IDENTIFIER);
1169  				}
1170  				backFlag = BACK_NONE;
1171  			} else if (sc.ch == '#') {
1172  				sc.SetState(SCE_PL_COMMENTLINE);
1173  			} else if (sc.ch == '\"') {
1174  				sc.SetState(SCE_PL_STRING);
1175  				Quote.New();
1176  				Quote.Open(sc.ch);
1177  				backFlag = BACK_NONE;
1178  			} else if (sc.ch == '\'') {
1179  				if (sc.chPrev == '&' && setWordStart.Contains(sc.chNext)) {
1180  					sc.SetState(SCE_PL_IDENTIFIER);
1181  				} else {
1182  					sc.SetState(SCE_PL_CHARACTER);
1183  					Quote.New();
1184  					Quote.Open(sc.ch);
1185  				}
1186  				backFlag = BACK_NONE;
1187  			} else if (sc.ch == '`') {
1188  				sc.SetState(SCE_PL_BACKTICKS);
1189  				Quote.New();
1190  				Quote.Open(sc.ch);
1191  				backFlag = BACK_NONE;
1192  			} else if (sc.ch == '$') {
1193  				sc.SetState(SCE_PL_SCALAR);
1194  				if (sc.chNext == '{') {
1195  					sc.ForwardSetState(SCE_PL_OPERATOR);
1196  				} else if (IsASpace(sc.chNext)) {
1197  					sc.ForwardSetState(SCE_PL_DEFAULT);
1198  				} else {
1199  					sc.Forward();
1200  					if (sc.Match('`', '`') || sc.Match(':', ':')) {
1201  						sc.Forward();
1202  					}
1203  				}
1204  				backFlag = BACK_NONE;
1205  			} else if (sc.ch == '@') {
1206  				sc.SetState(SCE_PL_ARRAY);
1207  				if (setArray.Contains(sc.chNext)) {
1208  				} else if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1209  					sc.ForwardBytes(2);
1210  				} else if (sc.chNext == '{' || sc.chNext == '[') {
1211  					sc.ForwardSetState(SCE_PL_OPERATOR);
1212  				} else {
1213  					sc.ChangeState(SCE_PL_OPERATOR);
1214  				}
1215  				backFlag = BACK_NONE;
1216  			} else if (setPreferRE.Contains(sc.ch)) {
1217  				bool preferRE = false;
1218  				bool isHereDoc = sc.Match('<', '<');
1219  				bool hereDocSpace = false;		
1220  				Sci_PositionU bk = (sc.currentPos > 0) ? sc.currentPos - 1: 0;
1221  				sc.Complete();
1222  				styler.Flush();
1223  				if (styler.StyleAt(bk) == SCE_PL_DEFAULT)
1224  					hereDocSpace = true;
1225  				skipWhitespaceComment(styler, bk);
1226  				if (bk == 0) {
1227  					preferRE = true;
1228  				} else {
1229  					int bkstyle = styler.StyleAt(bk);
1230  					int bkch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
1231  					switch (bkstyle) {
1232  					case SCE_PL_OPERATOR:
1233  						preferRE = true;
1234  						if (bkch == ')' || bkch == ']') {
1235  							preferRE = false;
1236  						} else if (bkch == '}') {
1237  							bkstyle = styleBeforeBracePair(styler, bk);
1238  							if (bkstyle == SCE_PL_SCALAR
1239  							        || bkstyle == SCE_PL_ARRAY
1240  							        || bkstyle == SCE_PL_HASH
1241  							        || bkstyle == SCE_PL_SYMBOLTABLE
1242  							        || bkstyle == SCE_PL_OPERATOR) {
1243  								preferRE = false;
1244  							}
1245  						} else if (bkch == '+' || bkch == '-') {
1246  							if (bkch == static_cast<unsigned char>(styler.SafeGetCharAt(bk - 1))
1247  							        && bkch != static_cast<unsigned char>(styler.SafeGetCharAt(bk - 2)))
1248  								preferRE = false;
1249  						}
1250  						break;
1251  					case SCE_PL_IDENTIFIER:
1252  						preferRE = true;
1253  						bkstyle = styleCheckIdentifier(styler, bk);
1254  						if ((bkstyle == 1) || (bkstyle == 2)) {
1255  							preferRE = false;
1256  						} else if (bkstyle == 3) {
1257  							if (sc.ch == '/') {
1258  								if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.chNext == '/')
1259  									preferRE = false;
1260  							} else if (sc.ch == '*' || sc.ch == '%') {
1261  								if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.Match('*', '*'))
1262  									preferRE = false;
1263  							} else if (sc.ch == '<') {
1264  								if (IsASpace(sc.chNext) || sc.chNext == '=')
1265  									preferRE = false;
1266  							}
1267  						}
1268  						break;
1269  					case SCE_PL_SCALAR:		
1270  						if (isHereDoc && hereDocSpace)	
1271  							preferRE = true;
1272  						break;
1273  					case SCE_PL_WORD:
1274  						preferRE = true;
1275  						if (sc.ch == '/') {
1276  							Sci_PositionU bkend = bk + 1;
1277  							while (bk > 0 && styler.StyleAt(bk - 1) == SCE_PL_WORD) {
1278  								bk--;
1279  							}
1280  							if (isPerlKeyword(bk, bkend, reWords, styler))
1281  								break;
1282  							if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.chNext == '/')
1283  								preferRE = false;
1284  						} else if (sc.ch == '*' || sc.ch == '%') {
1285  							if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.Match('*', '*'))
1286  								preferRE = false;
1287  						} else if (sc.ch == '<') {
1288  							if (IsASpace(sc.chNext) || sc.chNext == '=')
1289  								preferRE = false;
1290  						}
1291  						break;
1292  					case SCE_PL_POD:
1293  					case SCE_PL_HERE_Q:
1294  					case SCE_PL_HERE_QQ:
1295  					case SCE_PL_HERE_QX:
1296  						preferRE = true;
1297  						break;
1298  					}
1299  				}
1300  				backFlag = BACK_NONE;
1301  				if (isHereDoc) {	
1302  					if (sc.Match("<<>>")) {		
1303  						sc.SetState(SCE_PL_OPERATOR);
1304  						sc.Forward(3);
1305  					} else if (preferRE) {
1306  						sc.SetState(SCE_PL_HERE_DELIM);
1307  						HereDoc.State = 0;
1308  					} else {		
1309  						sc.SetState(SCE_PL_OPERATOR);
1310  						sc.Forward();
1311  					}
1312  				} else if (sc.ch == '*') {	
1313  					if (preferRE) {
1314  						sc.SetState(SCE_PL_SYMBOLTABLE);
1315  						if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1316  							sc.ForwardBytes(2);
1317  						} else if (sc.chNext == '{') {
1318  							sc.ForwardSetState(SCE_PL_OPERATOR);
1319  						} else {
1320  							sc.Forward();
1321  						}
1322  					} else {
1323  						sc.SetState(SCE_PL_OPERATOR);
1324  						if (sc.chNext == '*') 	
1325  							sc.Forward();
1326  					}
1327  				} else if (sc.ch == '%') {	
1328  					if (preferRE) {
1329  						sc.SetState(SCE_PL_HASH);
1330  						if (setHash.Contains(sc.chNext)) {
1331  							sc.Forward();
1332  						} else if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1333  							sc.ForwardBytes(2);
1334  						} else if (sc.chNext == '{') {
1335  							sc.ForwardSetState(SCE_PL_OPERATOR);
1336  						} else {
1337  							sc.ChangeState(SCE_PL_OPERATOR);
1338  						}
1339  					} else {
1340  						sc.SetState(SCE_PL_OPERATOR);
1341  					}
1342  				} else if (sc.ch == '<') {	
1343  					if (preferRE) {
1344  						int i = InputSymbolScan(sc);
1345  						if (i > 0) {
1346  							sc.SetState(SCE_PL_IDENTIFIER);
1347  							sc.Forward(i);
1348  						} else {
1349  							sc.SetState(SCE_PL_OPERATOR);
1350  						}
1351  					} else {
1352  						sc.SetState(SCE_PL_OPERATOR);
1353  					}
1354  				} else {			
1355  					if (preferRE) {
1356  						sc.SetState(SCE_PL_REGEX);
1357  						Quote.New();
1358  						Quote.Open(sc.ch);
1359  					} else {		
1360  						sc.SetState(SCE_PL_OPERATOR);
1361  						if (sc.chNext == '/') {
1362  							sc.Forward();
1363  						}
1364  					}
1365  				}
1366  			} else if (sc.ch == '='		
1367  			        && setPOD.Contains(sc.chNext)
1368  			        && sc.atLineStart) {
1369  				sc.SetState(SCE_PL_POD);
1370  				backFlag = BACK_NONE;
1371  			} else if (sc.ch == '-' && setWordStart.Contains(sc.chNext)) {	
1372  				Sci_PositionU bk = sc.currentPos;
1373  				Sci_PositionU fw = 2;
1374  				if (setSingleCharOp.Contains(sc.chNext) &&	
1375  				        !setWord.Contains(sc.GetRelative(2))) {
1376  					sc.SetState(SCE_PL_WORD);
1377  				} else {
1378  					while (setWord.Contains(sc.GetRelative(fw)))
1379  						fw++;
1380  					sc.SetState(SCE_PL_OPERATOR);
1381  				}
1382  				if (disambiguateBareword(styler, bk, bk + fw, backFlag, backPos, endPos) & 2) {
1383  					sc.ChangeState(SCE_PL_IDENTIFIER);
1384  				}
1385  				backFlag = BACK_NONE;
1386  			} else if (sc.ch == '(' && sc.currentPos > 0) {	
1387  				sc.Complete();
1388  				if (styleCheckSubPrototype(styler, sc.currentPos - 1)) {
1389  					sc.SetState(SCE_PL_SUB_PROTOTYPE);
1390  					backFlag = BACK_NONE;
1391  				} else {
1392  					sc.SetState(SCE_PL_OPERATOR);
1393  				}
1394  			} else if (setPerlOperator.Contains(sc.ch)) {	
1395  				sc.SetState(SCE_PL_OPERATOR);
1396  				if (sc.Match('.', '.')) {	
1397  					sc.Forward();
1398  					if (sc.chNext == '.') sc.Forward();
1399  				}
1400  			} else if (sc.ch == 4 || sc.ch == 26) {		
1401  				sc.SetState(SCE_PL_DATASECTION);
1402  			} else {
1403  				sc.Complete();
1404  			}
1405  		}
1406  	}
1407  	sc.Complete();
1408  	if (sc.state == SCE_PL_HERE_Q
1409  	        || sc.state == SCE_PL_HERE_QQ
1410  	        || sc.state == SCE_PL_HERE_QX
1411  	        || sc.state == SCE_PL_FORMAT) {
1412  		styler.ChangeLexerState(sc.currentPos, styler.Length());
1413  	}
1414  	sc.Complete();
1415  }
1416  #define PERL_HEADFOLD_SHIFT		4
1417  #define PERL_HEADFOLD_MASK		0xF0
1418  void SCI_METHOD LexerPerl::Fold(Sci_PositionU startPos, Sci_Position length, int &bsol;* initStyle */, IDocument *pAccess) {
1419  	if (!options.fold)
1420  		return;
1421  	LexAccessor styler(pAccess);
1422  	Sci_PositionU endPos = startPos + length;
1423  	int visibleChars = 0;
1424  	Sci_Position lineCurrent = styler.GetLine(startPos);
1425  	if (startPos > 0) {
1426  		if (lineCurrent > 0) {
1427  			lineCurrent--;
1428  			startPos = styler.LineStart(lineCurrent);
1429  		}
1430  	}
1431  	int levelPrev = SC_FOLDLEVELBASE;
1432  	if (lineCurrent > 0)
1433  		levelPrev = styler.LevelAt(lineCurrent - 1) >> 16;
1434  	int levelCurrent = levelPrev;
1435  	char chNext = styler[startPos];
1436  	char chPrev = styler.SafeGetCharAt(startPos - 1);
1437  	int styleNext = styler.StyleAt(startPos);
1438  	bool isPackageLine = false;
1439  	int podHeading = 0;
1440  	for (Sci_PositionU i = startPos; i < endPos; i++) {
1441  		char ch = chNext;
1442  		chNext = styler.SafeGetCharAt(i + 1);
1443  		int style = styleNext;
1444  		styleNext = styler.StyleAt(i + 1);
1445  		int stylePrevCh = (i) ? styler.StyleAt(i - 1):SCE_PL_DEFAULT;
1446  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
1447  		bool atLineStart = ((chPrev == '\r') || (chPrev == '\n')) || i == 0;
1448  		if (options.foldComment && atEOL && IsCommentLine(lineCurrent, styler)) {
1449  			if (!IsCommentLine(lineCurrent - 1, styler)
1450  			        && IsCommentLine(lineCurrent + 1, styler))
1451  				levelCurrent++;
1452  			else if (IsCommentLine(lineCurrent - 1, styler)
1453  			        && !IsCommentLine(lineCurrent + 1, styler))
1454  				levelCurrent--;
1455  		}
1456  		if (style == SCE_PL_OPERATOR) {
1457  			if (ch == '{') {
1458  				if (options.foldAtElse && levelCurrent < levelPrev)
1459  					--levelPrev;
1460  				levelCurrent++;
1461  			} else if (ch == '}') {
1462  				levelCurrent--;
1463  			}
1464  			if (ch == '[') {
1465  				if (options.foldAtElse && levelCurrent < levelPrev)
1466  					--levelPrev;
1467  				levelCurrent++;
1468  			} else if (ch == ']') {
1469  				levelCurrent--;
1470  			}
1471  		} else if (style == SCE_PL_STRING_QW) {
1472  			if (stylePrevCh != style)
1473  				levelCurrent++;
1474  			else if (styleNext != style)
1475  				levelCurrent--;
1476  		}
1477  		if (options.foldPOD && atLineStart) {
1478  			if (style == SCE_PL_POD) {
1479  				if (stylePrevCh != SCE_PL_POD && stylePrevCh != SCE_PL_POD_VERB)
1480  					levelCurrent++;
1481  				else if (styler.Match(i, "=cut"))
1482  					levelCurrent = (levelCurrent & ~PERL_HEADFOLD_MASK) - 1;
1483  				else if (styler.Match(i, "=head"))
1484  					podHeading = PodHeadingLevel(i, styler);
1485  			} else if (style == SCE_PL_DATASECTION) {
1486  				if (ch == '=' && IsASCII(chNext) && isalpha(chNext) && levelCurrent == SC_FOLDLEVELBASE)
1487  					levelCurrent++;
1488  				else if (styler.Match(i, "=cut") && levelCurrent > SC_FOLDLEVELBASE)
1489  					levelCurrent = (levelCurrent & ~PERL_HEADFOLD_MASK) - 1;
1490  				else if (styler.Match(i, "=head"))
1491  					podHeading = PodHeadingLevel(i, styler);
1492  				else if (stylePrevCh != SCE_PL_DATASECTION)
1493  					levelCurrent = SC_FOLDLEVELBASE;
1494  			}
1495  		}
1496  		if (options.foldPackage && atLineStart) {
1497  			if (IsPackageLine(lineCurrent, styler)
1498  			        && !IsPackageLine(lineCurrent + 1, styler))
1499  				isPackageLine = true;
1500  		}
1501  		switch (style) {
1502  		case SCE_PL_HERE_QQ :
1503  		case SCE_PL_HERE_Q :
1504  		case SCE_PL_HERE_QX :
1505  			switch (stylePrevCh) {
1506  			case SCE_PL_HERE_QQ :
1507  			case SCE_PL_HERE_Q :
1508  			case SCE_PL_HERE_QX :
1509  				break;
1510  			default :
1511  				levelCurrent++;
1512  				break;
1513  			}
1514  			break;
1515  		default:
1516  			switch (stylePrevCh) {
1517  			case SCE_PL_HERE_QQ :
1518  			case SCE_PL_HERE_Q :
1519  			case SCE_PL_HERE_QX :
1520  				levelCurrent--;
1521  				break;
1522  			default :
1523  				break;
1524  			}
1525  			break;
1526  		}
1527  		if (options.foldCommentExplicit && style == SCE_PL_COMMENTLINE && ch == '#') {
1528  			if (chNext == '{') {
1529  				levelCurrent++;
1530  			} else if (levelCurrent > SC_FOLDLEVELBASE  && chNext == '}') {
1531  				levelCurrent--;
1532  			}
1533  		}
1534  		if (atEOL) {
1535  			int lev = levelPrev;
1536  			if (podHeading > 0) {
1537  				levelCurrent = (lev & ~PERL_HEADFOLD_MASK) | (podHeading << PERL_HEADFOLD_SHIFT);
1538  				lev = levelCurrent - 1;
1539  				lev |= SC_FOLDLEVELHEADERFLAG;
1540  				podHeading = 0;
1541  			}
1542  			if (isPackageLine) {
1543  				lev = SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG;
1544  				levelCurrent = SC_FOLDLEVELBASE + 1;
1545  				isPackageLine = false;
1546  			}
1547  			lev |= levelCurrent << 16;
1548  			if (visibleChars == 0 && options.foldCompact)
1549  				lev |= SC_FOLDLEVELWHITEFLAG;
1550  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
1551  				lev |= SC_FOLDLEVELHEADERFLAG;
1552  			if (lev != styler.LevelAt(lineCurrent)) {
1553  				styler.SetLevel(lineCurrent, lev);
1554  			}
1555  			lineCurrent++;
1556  			levelPrev = levelCurrent;
1557  			visibleChars = 0;
1558  		}
1559  		if (!isspacechar(ch))
1560  			visibleChars++;
1561  		chPrev = ch;
1562  	}
1563  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
1564  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1565  }
1566  LexerModule lmPerl(SCLEX_PERL, LexerPerl::LexerFactoryPerl, "perl", perlWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPerl.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "WordList.h"
15  #include "LexAccessor.h"
16  #include "StyleContext.h"
17  #include "CharacterSet.h"
18  #include "LexerModule.h"
19  #include "OptionSet.h"
20  #include "DefaultLexer.h"
21  using namespace Scintilla;
22  using namespace Lexilla;
23  #define HERE_DELIM_MAX 256		
24  #define PERLNUM_BINARY		1	
25  #define PERLNUM_OCTAL		2
26  #define PERLNUM_FLOAT_EXP	3	
27  #define PERLNUM_HEX			4	
28  #define PERLNUM_DECIMAL		5	
29  #define PERLNUM_VECTOR		6
30  #define PERLNUM_V_VECTOR	7
31  #define PERLNUM_BAD			8
32  #define BACK_NONE		0	
33  #define BACK_OPERATOR	1	
34  #define BACK_KEYWORD	2	
35  #define SUB_BEGIN		0	
36  #define SUB_HAS_PROTO	1	
37  #define SUB_HAS_ATTRIB	2	
38  #define SUB_HAS_MODULE	3	
39  #define SUB_HAS_SUB		4	
40  #define	INTERPOLATE_SHIFT	(SCE_PL_STRING_VAR - SCE_PL_STRING)
41  static bool isPerlKeyword(Sci_PositionU start, Sci_PositionU end, WordList &keywords, LexAccessor &styler) {
42  	char s[100];
43  	Sci_PositionU i, len = end - start;
44  	if (len > 30) { len = 30; }
45  	for (i = 0; i < len; i++, start++) s[i] = styler[start];
46  	s[i] = '\0';
47  	return keywords.InList(s);
48  }
49  static int disambiguateBareword(LexAccessor &styler, Sci_PositionU bk, Sci_PositionU fw,
50          int backFlag, Sci_PositionU backPos, Sci_PositionU endPos) {
51  	int result = 0;
52  	bool moreback = false;		
53  	bool brace = false;			
54  	if (backFlag == BACK_NONE)
55  		return result;
56  	if (backPos <= static_cast<Sci_PositionU>(styler.LineStart(styler.GetLine(bk))))
57  		moreback = true;
58  	bk = backPos - 1;
59  	int ch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
60  	if (ch == '{' && !moreback) {
61  		brace = true;
62  	} else if ((ch == '&' && styler.SafeGetCharAt(bk - 1) != '&')
63  	        || styler.Match(bk - 1, "->")
64  	        || styler.Match(bk - 1, "::")
65  	        || styler.Match(bk - 2, "sub")) {
66  		result |= 1;
67  	}
68  	if ((ch == '{' || ch == '(' || ch == '['|| ch == ',')
69  	        && fw < endPos) {
70  		while (IsASpaceOrTab(ch = static_cast<unsigned char>(styler.SafeGetCharAt(fw)))
71  		        && fw < endPos) {
72  			fw++;
73  		}
74  		if ((ch == '}' && brace)
75  		        || styler.Match(fw, "=>")) {
76  			result |= 2;
77  		}
78  	}
79  	return result;
80  }
81  static void skipWhitespaceComment(LexAccessor &styler, Sci_PositionU &p) {
82  	while (p > 0) {
83  		const int style = styler.StyleAt(p);
84  		if (style != SCE_PL_DEFAULT && style != SCE_PL_COMMENTLINE)
85  			break;
86  		p--;
87  	}
88  }
89  static int findPrevLexeme(LexAccessor &styler, Sci_PositionU &bk, int &style) {
90  	skipWhitespaceComment(styler, bk);
91  	if (bk == 0)
92  		return 0;
93  	int sz = 1;
94  	style = styler.StyleAt(bk);
95  	while (bk > 0) {	
96  		if (styler.StyleAt(bk - 1) == style) {
97  			bk--; sz++;
98  		} else
99  			break;
100  	}
101  	return sz;
102  }
103  static int styleBeforeBracePair(LexAccessor &styler, Sci_PositionU bk) {
104  	int braceCount = 1;
105  	if (bk == 0)
106  		return SCE_PL_DEFAULT;
107  	while (--bk > 0) {
108  		if (styler.StyleAt(bk) == SCE_PL_OPERATOR) {
109  			int bkch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
110  			if (bkch == ';') {	
111  				break;
112  			} else if (bkch == '}') {
113  				braceCount++;
114  			} else if (bkch == '{') {
115  				if (--braceCount == 0) break;
116  			}
117  		}
118  	}
119  	if (bk > 0 && braceCount == 0) {
120  		bk--;
121  		skipWhitespaceComment(styler, bk);
122  		return styler.StyleAt(bk);
123  	}
124  	return SCE_PL_DEFAULT;
125  }
126  static int styleCheckIdentifier(LexAccessor &styler, Sci_PositionU bk) {
127  	if (styler.SafeGetCharAt(bk) == '>')	
128  		return 1;
129  	while (bk > 0 && styler.StyleAt(bk) == SCE_PL_IDENTIFIER) {
130  		bk--;
131  	}
132  	while (bk > 0) {
133  		int bkstyle = styler.StyleAt(bk);
134  		if (bkstyle == SCE_PL_DEFAULT
135  		        || bkstyle == SCE_PL_COMMENTLINE) {
136  		} else if (bkstyle == SCE_PL_OPERATOR) {
137  			if (styler.Match(bk - 1, "->") || styler.Match(bk - 1, "::"))
138  				return 2;
139  		} else
140  			return 3;	
141  		bk--;
142  	}
143  	return 0;
144  }
145  static int podLineScan(LexAccessor &styler, Sci_PositionU &pos, Sci_PositionU endPos) {
146  	int state = -1;
147  	while (pos < endPos) {
148  		int ch = static_cast<unsigned char>(styler.SafeGetCharAt(pos));
149  		if (ch == '\n' || ch == '\r') {
150  			if (ch == '\r' && styler.SafeGetCharAt(pos + 1) == '\n') pos++;
151  			break;
152  		}
153  		if (IsASpaceOrTab(ch)) {	
154  			if (state == -1)
155  				state = SCE_PL_DEFAULT;
156  		} else if (state == SCE_PL_DEFAULT) {	
157  			state = SCE_PL_POD_VERB;
158  		} else if (state != SCE_PL_POD_VERB) {	
159  			state = SCE_PL_POD;
160  		}
161  		pos++;
162  	}
163  	if (state == -1)
164  		state = SCE_PL_DEFAULT;
165  	return state;
166  }
167  static bool styleCheckSubPrototype(LexAccessor &styler, Sci_PositionU bk) {
168  	styler.Flush();
169  	int state = SUB_BEGIN;
170  	do {
171  		int style2 = SCE_PL_DEFAULT;
172  		Sci_PositionU pos2 = bk;
173  		int len2 = findPrevLexeme(styler, pos2, style2);
174  		int style1 = SCE_PL_DEFAULT;
175  		Sci_PositionU pos1 = pos2;
176  		if (pos1 > 0) pos1--;
177  		int len1 = findPrevLexeme(styler, pos1, style1);
178  		if (len1 == 0 || len2 == 0)		
179  			break;
180  		if (style1 == SCE_PL_OPERATOR && len1 == 1 &&
181  		    styler.SafeGetCharAt(pos1) == ':') {	
182  			if (style2 == SCE_PL_IDENTIFIER || style2 == SCE_PL_WORD) {
183  				if (len2 == 9 && styler.Match(pos2, "prototype")) {	
184  					if (state == SUB_BEGIN) {
185  						state = SUB_HAS_PROTO;
186  					} else
187  						break;
188  				} else {	
189  					if (state == SUB_HAS_PROTO || state == SUB_HAS_ATTRIB) {
190  						state = SUB_HAS_ATTRIB;
191  					} else
192  						break;
193  				}
194  			} else
195  				break;
196  		} else if (style1 == SCE_PL_OPERATOR && len1 == 2 &&
197  		           styler.Match(pos1, "::")) {	
198  			if (style2 == SCE_PL_IDENTIFIER) {	
199  				state = SUB_HAS_MODULE;
200  			} else
201  				break;
202  		} else if (style1 == SCE_PL_WORD && len1 == 3 &&
<span onclick='openModal()' class='match'>203  		           styler.Match(pos1, "sub")) {	
204  			if (style2 == SCE_PL_IDENTIFIER) {	
205  				state = SUB_HAS_SUB;
206  			} else
207  				break;
208  		} else
209  			break;
</span>210  		bk = pos1;			
211  		if (bk > 0) bk--;
212  	} while (state != SUB_HAS_SUB);
213  	return (state == SUB_HAS_SUB);
214  }
215  static int actualNumStyle(int numberStyle) {
216  	if (numberStyle == PERLNUM_VECTOR || numberStyle == PERLNUM_V_VECTOR) {
217  		return SCE_PL_STRING;
218  	} else if (numberStyle == PERLNUM_BAD) {
219  		return SCE_PL_ERROR;
220  	}
221  	return SCE_PL_NUMBER;
222  }
223  static int opposite(int ch) {
224  	if (ch == '(') return ')';
225  	if (ch == '[') return ']';
226  	if (ch == '{') return '}';
227  	if (ch == '<') return '>';
228  	return ch;
229  }
230  static bool IsCommentLine(Sci_Position line, LexAccessor &styler) {
231  	Sci_Position pos = styler.LineStart(line);
232  	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
233  	for (Sci_Position i = pos; i < eol_pos; i++) {
234  		char ch = styler[i];
235  		int style = styler.StyleAt(i);
236  		if (ch == '#' && style == SCE_PL_COMMENTLINE)
237  			return true;
238  		else if (!IsASpaceOrTab(ch))
239  			return false;
240  	}
241  	return false;
242  }
243  static bool IsPackageLine(Sci_Position line, LexAccessor &styler) {
244  	Sci_Position pos = styler.LineStart(line);
245  	int style = styler.StyleAt(pos);
246  	if (style == SCE_PL_WORD && styler.Match(pos, "package")) {
247  		return true;
248  	}
249  	return false;
250  }
251  static int PodHeadingLevel(Sci_Position pos, LexAccessor &styler) {
252  	int lvl = static_cast<unsigned char>(styler.SafeGetCharAt(pos + 5));
253  	if (lvl >= '1' && lvl <= '4') {
254  		return lvl - '0';
255  	}
256  	return 0;
257  }
258  struct OptionsPerl {
259  	bool fold;
260  	bool foldComment;
261  	bool foldCompact;
262  	bool foldPOD;            
263  	bool foldPackage;        
264  	bool foldCommentExplicit;
265  	bool foldAtElse;
266  	OptionsPerl() {
267  		fold = false;
268  		foldComment = false;
269  		foldCompact = true;
270  		foldPOD = true;
271  		foldPackage = true;
272  		foldCommentExplicit = true;
273  		foldAtElse = false;
274  	}
275  };
276  static const char *const perlWordListDesc[] = {
277  	"Keywords",
278  	0
279  };
280  struct OptionSetPerl : public OptionSet<OptionsPerl> {
281  	OptionSetPerl() {
282  		DefineProperty("fold", &OptionsPerl::fold);
283  		DefineProperty("fold.comment", &OptionsPerl::foldComment);
284  		DefineProperty("fold.compact", &OptionsPerl::foldCompact);
285  		DefineProperty("fold.perl.pod", &OptionsPerl::foldPOD,
286  		        "Set to 0 to disable folding Pod blocks when using the Perl lexer.");
287  		DefineProperty("fold.perl.package", &OptionsPerl::foldPackage,
288  		        "Set to 0 to disable folding packages when using the Perl lexer.");
289  		DefineProperty("fold.perl.comment.explicit", &OptionsPerl::foldCommentExplicit,
290  		        "Set to 0 to disable explicit folding.");
291  		DefineProperty("fold.perl.at.else", &OptionsPerl::foldAtElse,
292  		               "This option enables Perl folding on a \"} else {\" line of an if statement.");
293  		DefineWordListSets(perlWordListDesc);
294  	}
295  };
296  class LexerPerl : public DefaultLexer {
297  	CharacterSet setWordStart;
298  	CharacterSet setWord;
299  	CharacterSet setSpecialVar;
300  	CharacterSet setControlVar;
301  	WordList keywords;
302  	OptionsPerl options;
303  	OptionSetPerl osPerl;
304  public:
305  	LexerPerl() :
306  		DefaultLexer("perl", SCLEX_PERL),
307  		setWordStart(CharacterSet::setAlpha, "_", 0x80, true),
308  		setWord(CharacterSet::setAlphaNum, "_", 0x80, true),
309  		setSpecialVar(CharacterSet::setNone, "\"$;<>&`'+,./\\%:=~!?@[]"),
310  		setControlVar(CharacterSet::setNone, "ACDEFHILMNOPRSTVWX") {
311  	}
312  	virtual ~LexerPerl() {
313  	}
314  	void SCI_METHOD Release() override {
315  		delete this;
316  	}
317  	int SCI_METHOD Version() const override {
318  		return lvRelease5;
319  	}
320  	const char *SCI_METHOD PropertyNames() override {
321  		return osPerl.PropertyNames();
322  	}
323  	int SCI_METHOD PropertyType(const char *name) override {
324  		return osPerl.PropertyType(name);
325  	}
326  	const char *SCI_METHOD DescribeProperty(const char *name) override {
327  		return osPerl.DescribeProperty(name);
328  	}
329  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
330  	const char * SCI_METHOD PropertyGet(const char *key) override {
331  		return osPerl.PropertyGet(key);
332  	}
333  	const char *SCI_METHOD DescribeWordListSets() override {
334  		return osPerl.DescribeWordListSets();
335  	}
336  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
337  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
338  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
339  	void *SCI_METHOD PrivateCall(int, void *) override {
340  		return 0;
341  	}
342  	static ILexer5 *LexerFactoryPerl() {
343  		return new LexerPerl();
344  	}
345  	int InputSymbolScan(StyleContext &sc);
346  	void InterpolateSegment(StyleContext &sc, int maxSeg, bool isPattern=false);
347  };
348  Sci_Position SCI_METHOD LexerPerl::PropertySet(const char *key, const char *val) {
349  	if (osPerl.PropertySet(&options, key, val)) {
350  		return 0;
351  	}
352  	return -1;
353  }
354  Sci_Position SCI_METHOD LexerPerl::WordListSet(int n, const char *wl) {
355  	WordList *wordListN = 0;
356  	switch (n) {
357  	case 0:
358  		wordListN = &keywords;
359  		break;
360  	}
361  	Sci_Position firstModification = -1;
362  	if (wordListN) {
363  		WordList wlNew;
364  		wlNew.Set(wl);
365  		if (*wordListN != wlNew) {
366  			wordListN->Set(wl);
367  			firstModification = 0;
368  		}
369  	}
370  	return firstModification;
371  }
372  int LexerPerl::InputSymbolScan(StyleContext &sc) {
373  	int c, sLen = 0;
374  	while ((c = sc.GetRelativeCharacter(++sLen)) != 0) {
375  		if (c == '\r' || c == '\n') {
376  			return 0;
377  		} else if (c == '>') {
378  			if (sc.Match("<=>"))	
379  				return 0;
380  			return sLen;
381  		}
382  	}
383  	return 0;
384  }
385  void LexerPerl::InterpolateSegment(StyleContext &sc, int maxSeg, bool isPattern) {
386  	while (maxSeg > 0) {
387  		bool isVar = false;
388  		int sLen = 0;
389  		if ((maxSeg > 1) && (sc.ch == '$' || sc.ch == '@')) {
390  			bool braces = false;
391  			sLen = 1;
392  			if (sc.ch == '$' && sc.chNext == '#') {	
393  				sLen++;
394  			}
395  			while ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '$'))	
396  				sLen++;
397  			if ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '{')) {	
398  				sLen++;
399  				braces = true;
400  			}
401  			if (maxSeg > sLen) {
402  				int c = sc.GetRelativeCharacter(sLen);
403  				if (setWordStart.Contains(c)) {	
404  					sLen++;
405  					isVar = true;
406  					while (maxSeg > sLen) {
407  						if (!setWord.Contains(sc.GetRelativeCharacter(sLen)))
408  							break;
409  						sLen++;
410  					}
411  				} else if (braces && IsADigit(c) && (sLen == 2)) {	
412  					sLen++;
413  					isVar = true;
414  				}
415  			}
416  			if (braces) {
417  				if ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '}')) {	
418  					sLen++;
419  				} else
420  					isVar = false;
421  			}
422  		}
423  		if (!isVar && (maxSeg > 1)) {	
424  			int c = sc.chNext;
425  			if (sc.ch == '$') {
426  				sLen = 1;
427  				if (IsADigit(c)) {	
428  					sLen++;
429  					isVar = true;
430  					while ((maxSeg > sLen) && IsADigit(sc.GetRelativeCharacter(sLen)))
431  						sLen++;
432  				} else if (setSpecialVar.Contains(c)) {	
433  					sLen++;
434  					isVar = true;
435  				} else if (!isPattern && ((c == '(') || (c == ')') || (c == '|'))) {	
436  					sLen++;
437  					isVar = true;
438  				} else if (c == '^') {	
439  					sLen++;
440  					if ((maxSeg > sLen) && setControlVar.Contains(sc.GetRelativeCharacter(sLen))) {
441  						sLen++;
442  						isVar = true;
443  					}
444  				}
445  			} else if (sc.ch == '@') {
446  				sLen = 1;
447  				if (!isPattern && ((c == '+') || (c == '-'))) {	
448  					sLen++;
449  					isVar = true;
450  				}
451  			}
452  		}
453  		if (isVar) {	
454  			if (sc.state < SCE_PL_STRING_VAR)
455  				sc.SetState(sc.state + INTERPOLATE_SHIFT);
456  			sc.Forward(sLen);
457  			maxSeg -= sLen;
458  		} else {
459  			if (sc.state >= SCE_PL_STRING_VAR)
460  				sc.SetState(sc.state - INTERPOLATE_SHIFT);
461  			sc.Forward();
462  			maxSeg--;
463  		}
464  	}
465  	if (sc.state >= SCE_PL_STRING_VAR)
466  		sc.SetState(sc.state - INTERPOLATE_SHIFT);
467  }
468  void SCI_METHOD LexerPerl::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
469  	LexAccessor styler(pAccess);
470  	WordList reWords;
471  	reWords.Set("elsif if split while");
472  	CharacterSet setSingleCharOp(CharacterSet::setNone, "rwxoRWXOezsfdlpSbctugkTBMAC");
473  	CharacterSet setPerlOperator(CharacterSet::setNone, "^&\\()-+=|{}[]:;>,?!.~");
474  	CharacterSet setQDelim(CharacterSet::setNone, "qrwx");
475  	CharacterSet setModifiers(CharacterSet::setAlpha);
476  	CharacterSet setPreferRE(CharacterSet::setNone, "*/<%");
477  	CharacterSet setVar(CharacterSet::setAlphaNum, "#$_'", 0x80, true);
478  	CharacterSet setArray(CharacterSet::setAlpha, "#$_+-", 0x80, true);
479  	CharacterSet setHash(CharacterSet::setAlpha, "#$_!^+-", 0x80, true);
480  	CharacterSet &setPOD = setModifiers;
481  	CharacterSet setNonHereDoc(CharacterSet::setDigits, "=$@");
482  	CharacterSet setHereDocDelim(CharacterSet::setAlphaNum, "_");
483  	CharacterSet setSubPrototype(CharacterSet::setNone, "\\[$@%&*+];_ \t");
484  	CharacterSet setRepetition(CharacterSet::setDigits, ")\"'");
485  	CharacterSet setFormatStart(CharacterSet::setAlpha, "_=");
486  	CharacterSet &setFormat = setHereDocDelim;
487  	class HereDocCls {	
488  	public:
489  		int State;
490  		int Quote;		
491  		bool Quoted;		
492  		bool StripIndent;	
493  		int DelimiterLength;	
494  		char Delimiter[HERE_DELIM_MAX];	
495  		HereDocCls() {
496  			State = 0;
497  			Quote = 0;
498  			Quoted = false;
499  			StripIndent = false;
500  			DelimiterLength = 0;
501  			Delimiter[0] = '\0';
502  		}
503  		void Append(int ch) {
504  			Delimiter[DelimiterLength++] = static_cast<char>(ch);
505  			Delimiter[DelimiterLength] = '\0';
506  		}
507  		~HereDocCls() {
508  		}
509  	};
510  	HereDocCls HereDoc;		
511  	class QuoteCls {	
512  	public:
513  		int Rep;
514  		int Count;
515  		int Up, Down;
516  		QuoteCls() {
517  			New(1);
518  		}
519  		void New(int r = 1) {
520  			Rep   = r;
521  			Count = 0;
522  			Up    = '\0';
523  			Down  = '\0';
524  		}
525  		void Open(int u) {
526  			Count++;
527  			Up    = u;
528  			Down  = opposite(Up);
529  		}
530  	};
531  	QuoteCls Quote;
532  	int numState = PERLNUM_DECIMAL;
533  	int dotCount = 0;
534  	Sci_PositionU endPos = startPos + length;
535  	if (initStyle == SCE_PL_HERE_Q
536  	    || initStyle == SCE_PL_HERE_QQ
537  	    || initStyle == SCE_PL_HERE_QX
538  	    || initStyle == SCE_PL_FORMAT
539  	    || initStyle == SCE_PL_HERE_QQ_VAR
540  	    || initStyle == SCE_PL_HERE_QX_VAR
541  	   ) {
542  		int delim = (initStyle == SCE_PL_FORMAT) ? SCE_PL_FORMAT_IDENT:SCE_PL_HERE_DELIM;
543  		while ((startPos > 1) && (styler.StyleAt(startPos) != delim)) {
544  			startPos--;
545  		}
546  		startPos = styler.LineStart(styler.GetLine(startPos));
547  		initStyle = styler.StyleAt(startPos - 1);
548  	}
549  	if (initStyle == SCE_PL_STRING
550  	    || initStyle == SCE_PL_STRING_QQ
551  	    || initStyle == SCE_PL_BACKTICKS
552  	    || initStyle == SCE_PL_STRING_QX
553  	    || initStyle == SCE_PL_REGEX
554  	    || initStyle == SCE_PL_STRING_QR
555  	    || initStyle == SCE_PL_REGSUBST
556  	    || initStyle == SCE_PL_STRING_VAR
557  	    || initStyle == SCE_PL_STRING_QQ_VAR
558  	    || initStyle == SCE_PL_BACKTICKS_VAR
559  	    || initStyle == SCE_PL_STRING_QX_VAR
560  	    || initStyle == SCE_PL_REGEX_VAR
561  	    || initStyle == SCE_PL_STRING_QR_VAR
562  	    || initStyle == SCE_PL_REGSUBST_VAR
563  	   ) {
564  		int otherStyle = (initStyle >= SCE_PL_STRING_VAR) ?
565  			initStyle - INTERPOLATE_SHIFT : initStyle + INTERPOLATE_SHIFT;
566  		while (startPos > 1) {
567  			int st = styler.StyleAt(startPos - 1);
568  			if ((st != initStyle) && (st != otherStyle))
569  				break;
570  			startPos--;
571  		}
572  		initStyle = SCE_PL_DEFAULT;
573  	} else if (initStyle == SCE_PL_STRING_Q
574  	        || initStyle == SCE_PL_STRING_QW
575  	        || initStyle == SCE_PL_XLAT
576  	        || initStyle == SCE_PL_CHARACTER
577  	        || initStyle == SCE_PL_NUMBER
578  	        || initStyle == SCE_PL_IDENTIFIER
579  	        || initStyle == SCE_PL_ERROR
580  	        || initStyle == SCE_PL_SUB_PROTOTYPE
581  	   ) {
582  		while ((startPos > 1) && (styler.StyleAt(startPos - 1) == initStyle)) {
583  			startPos--;
584  		}
585  		initStyle = SCE_PL_DEFAULT;
586  	} else if (initStyle == SCE_PL_POD
587  	        || initStyle == SCE_PL_POD_VERB
588  	          ) {
589  		Sci_Position ln = styler.GetLine(startPos);
590  		if (ln > 0) {
591  			initStyle = styler.StyleAt(styler.LineStart(--ln));
592  			if (initStyle == SCE_PL_POD || initStyle == SCE_PL_POD_VERB) {
593  				while (ln > 0 && styler.GetLineState(ln) == SCE_PL_DEFAULT)
594  					ln--;
595  			}
596  			startPos = styler.LineStart(++ln);
597  			initStyle = styler.StyleAt(startPos - 1);
598  		} else {
599  			startPos = 0;
600  			initStyle = SCE_PL_DEFAULT;
601  		}
602  	}
603  	int backFlag = BACK_NONE;
604  	Sci_PositionU backPos = startPos;
605  	if (backPos > 0) {
606  		backPos--;
607  		skipWhitespaceComment(styler, backPos);
608  		if (styler.StyleAt(backPos) == SCE_PL_OPERATOR)
609  			backFlag = BACK_OPERATOR;
610  		else if (styler.StyleAt(backPos) == SCE_PL_WORD)
611  			backFlag = BACK_KEYWORD;
612  		backPos++;
613  	}
614  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
615  	for (; sc.More(); sc.Forward()) {
616  		switch (sc.state) {
617  		case SCE_PL_OPERATOR:
618  			sc.SetState(SCE_PL_DEFAULT);
619  			backFlag = BACK_OPERATOR;
620  			backPos = sc.currentPos;
621  			break;
622  		case SCE_PL_IDENTIFIER:		
623  			if ((!setWord.Contains(sc.ch) && sc.ch != '\'')
624  			        || sc.Match('.', '.')
625  			        || sc.chPrev == '>') {	
626  				sc.SetState(SCE_PL_DEFAULT);
627  			}
628  			break;
629  		case SCE_PL_WORD:		
630  			if (!setWord.Contains(sc.ch)) {
631  				char s[100];
632  				sc.GetCurrent(s, sizeof(s));
633  				if ((strcmp(s, "__DATA__") == 0) || (strcmp(s, "__END__") == 0)) {
634  					sc.ChangeState(SCE_PL_DATASECTION);
635  				} else {
636  					if ((strcmp(s, "format") == 0)) {
637  						sc.SetState(SCE_PL_FORMAT_IDENT);
638  						HereDoc.State = 0;
639  					} else {
640  						sc.SetState(SCE_PL_DEFAULT);
641  					}
642  					backFlag = BACK_KEYWORD;
643  					backPos = sc.currentPos;
644  				}
645  			}
646  			break;
647  		case SCE_PL_SCALAR:
648  		case SCE_PL_ARRAY:
649  		case SCE_PL_HASH:
650  		case SCE_PL_SYMBOLTABLE:
651  			if (sc.Match(':', ':')) {	
652  				sc.Forward();
653  			} else if (!setVar.Contains(sc.ch)) {
654  				if (sc.LengthCurrent() == 1) {
655  					sc.Forward();
656  				}
657  				sc.SetState(SCE_PL_DEFAULT);
658  			}
659  			break;
660  		case SCE_PL_NUMBER:
661  			if (sc.ch == '.') {
662  				if (sc.chNext == '.') {
663  				} else if (numState <= PERLNUM_FLOAT_EXP) {
664  					sc.SetState(SCE_PL_OPERATOR);
665  					break;
666  				} else {	
667  					dotCount++;
668  					if (numState == PERLNUM_DECIMAL) {
669  						if (dotCount <= 1)	
670  							break;
671  						if (IsADigit(sc.chNext)) {	
672  							numState = PERLNUM_VECTOR;
673  							break;
674  						}
675  					} else if (numState == PERLNUM_HEX) {
676  						if (dotCount <= 1 && IsADigit(sc.chNext, 16)) {
677  							break;	
678  						} else {
679  							sc.SetState(SCE_PL_OPERATOR);
680  							break;
681  						}
682  					} else if (IsADigit(sc.chNext))	
683  						break;
684  				}
685  			} else if (sc.ch == '_') {
686  				break;
687  			} else if (numState == PERLNUM_DECIMAL) {
688  				if (sc.ch == 'E' || sc.ch == 'e') {	
689  					numState = PERLNUM_FLOAT_EXP;
690  					if (sc.chNext == '+' || sc.chNext == '-') {
691  						sc.Forward();
692  					}
693  					break;
694  				} else if (IsADigit(sc.ch))
695  					break;
696  			} else if (numState == PERLNUM_HEX) {
697  				if (sc.ch == 'P' || sc.ch == 'p') {	
698  					numState = PERLNUM_FLOAT_EXP;
699  					if (sc.chNext == '+' || sc.chNext == '-') {
700  						sc.Forward();
701  					}
702  					break;
703  				} else if (IsADigit(sc.ch, 16))
704  					break;
705  			} else if (numState == PERLNUM_VECTOR || numState == PERLNUM_V_VECTOR) {
706  				if (IsADigit(sc.ch))	
707  					break;
708  				if (setWord.Contains(sc.ch) && dotCount == 0) {	
709  					sc.ChangeState(SCE_PL_IDENTIFIER);
710  					break;
711  				}
712  			} else if (IsADigit(sc.ch)) {
713  				if (numState == PERLNUM_FLOAT_EXP) {
714  					break;
715  				} else if (numState == PERLNUM_OCTAL) {
716  					if (sc.ch <= '7') break;
717  				} else if (numState == PERLNUM_BINARY) {
718  					if (sc.ch <= '1') break;
719  				}
720  				numState = PERLNUM_BAD;
721  				break;
722  			}
723  			sc.ChangeState(actualNumStyle(numState));
724  			sc.SetState(SCE_PL_DEFAULT);
725  			break;
726  		case SCE_PL_COMMENTLINE:
727  			if (sc.atLineStart) {
728  				sc.SetState(SCE_PL_DEFAULT);
729  			}
730  			break;
731  		case SCE_PL_HERE_DELIM:
732  			if (HereDoc.State == 0) { 
733  				int delim_ch = sc.chNext;
734  				Sci_Position ws_skip = 0;
735  				HereDoc.State = 1;	
736  				HereDoc.Quote = sc.chNext;
737  				HereDoc.Quoted = false;
738  				HereDoc.StripIndent = false;
739  				HereDoc.DelimiterLength = 0;
740  				HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
741  				if (delim_ch == '~') { 
742  					sc.Forward();
743  					HereDoc.StripIndent = true;
744  					HereDoc.Quote = delim_ch = sc.chNext;
745  				}
746  				if (IsASpaceOrTab(delim_ch)) {
747  					Sci_PositionU i = sc.currentPos + 1;
748  					while ((i < endPos) && IsASpaceOrTab(delim_ch)) {
749  						i++;
750  						delim_ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
751  					}
752  					ws_skip = i - sc.currentPos - 1;
753  				}
754  				if (delim_ch == '\'' || delim_ch == '"' || delim_ch == '`') {
755  					sc.Forward(ws_skip + 1);
756  					HereDoc.Quote = delim_ch;
757  					HereDoc.Quoted = true;
758  				} else if ((ws_skip == 0 && setNonHereDoc.Contains(sc.chNext))
759  				        || ws_skip > 0) {
760  					sc.ChangeState(SCE_PL_OPERATOR);
761  					sc.ForwardSetState(SCE_PL_DEFAULT);
762  					backFlag = BACK_OPERATOR;
763  					backPos = sc.currentPos;
764  					HereDoc.State = 0;
765  				} else {
766  					if (ws_skip == 0 && HereDoc.Quote == '\\')
767  						sc.Forward();
768  				}
769  			} else if (HereDoc.State == 1) { 
770  				backFlag = BACK_NONE;
771  				if (HereDoc.Quoted) { 
772  					if (sc.ch == HereDoc.Quote) { 
773  						sc.ForwardSetState(SCE_PL_DEFAULT);
774  					} else if (!sc.atLineEnd) {
775  						if (sc.Match('\\', static_cast<char>(HereDoc.Quote))) { 
776  							sc.Forward();
777  						}
778  						if (sc.ch != '\r') {	
779  							int i = 0;			
780  							while (i < sc.width) {
781  								HereDoc.Append(static_cast<unsigned char>(styler.SafeGetCharAt(sc.currentPos + i)));
782  								i++;
783  							}
784  						}
785  					}
786  				} else { 
787  					if (setHereDocDelim.Contains(sc.ch)) {
788  						HereDoc.Append(sc.ch);
789  					} else {
790  						sc.SetState(SCE_PL_DEFAULT);
791  					}
792  				}
793  				if (HereDoc.DelimiterLength >= HERE_DELIM_MAX - 1) {
794  					sc.SetState(SCE_PL_ERROR);
795  					HereDoc.State = 0;
796  				}
797  			}
798  			break;
799  		case SCE_PL_HERE_Q:
800  		case SCE_PL_HERE_QQ:
801  		case SCE_PL_HERE_QX:
802  			sc.Complete();
803  			if (HereDoc.StripIndent) {
804  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
805  					sc.Forward();
806  			}
807  			if (HereDoc.DelimiterLength == 0 || sc.Match(HereDoc.Delimiter)) {
808  				int c = sc.GetRelative(HereDoc.DelimiterLength);
809  				if (c == '\r' || c == '\n') {	
810  					sc.ForwardBytes(HereDoc.DelimiterLength);
811  					sc.SetState(SCE_PL_DEFAULT);
812  					backFlag = BACK_NONE;
813  					HereDoc.State = 0;
814  					if (!sc.atLineEnd)
815  						sc.Forward();
816  					break;
817  				}
818  			}
819  			if (sc.state == SCE_PL_HERE_Q) {	
820  				while (!sc.atLineEnd)
821  					sc.Forward();
822  				break;
823  			}
824  			while (!sc.atLineEnd) {		
825  				int c, sLen = 0, endType = 0;
826  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
827  					if (c == '\\') {
828  						endType = 1; break;
829  					} else if (c == '\r' || c == '\n') {
830  						endType = 2; break;
831  					}
832  					sLen++;
833  				}
834  				if (sLen > 0)	
835  					InterpolateSegment(sc, sLen);
836  				if (endType == 1) {
837  					sc.Forward();
838  					if (sc.ch != '\r' && sc.ch != '\n')
839  						sc.Forward();
840  				} else if (endType == 2) {
841  					if (!sc.atLineEnd)
842  						sc.Forward();
843  				}
844  			}
845  			break;
846  		case SCE_PL_POD:
847  		case SCE_PL_POD_VERB: {
848  				Sci_PositionU fw = sc.currentPos;
849  				Sci_Position ln = styler.GetLine(fw);
850  				if (sc.atLineStart && sc.Match("=cut")) {	
851  					sc.SetState(SCE_PL_POD);
852  					sc.Forward(4);
853  					sc.SetState(SCE_PL_DEFAULT);
854  					styler.SetLineState(ln, SCE_PL_POD);
855  					break;
856  				}
857  				int pod = podLineScan(styler, fw, endPos);	
858  				styler.SetLineState(ln, pod);
859  				if (pod == SCE_PL_DEFAULT) {
860  					if (sc.state == SCE_PL_POD_VERB) {
861  						Sci_PositionU fw2 = fw;
862  						while (fw2 < (endPos - 1) && pod == SCE_PL_DEFAULT) {
863  							fw = fw2++;	
864  							pod = podLineScan(styler, fw2, endPos);
865  							styler.SetLineState(styler.GetLine(fw2), pod);
866  						}
867  						if (pod == SCE_PL_POD) {	
868  							sc.SetState(SCE_PL_POD);
869  						} else
870  							fw = fw2;
871  					}
872  				} else {
873  					if (pod == SCE_PL_POD_VERB	
874  					        && (styler.GetLineState(ln - 1) == SCE_PL_POD)) {
875  						pod = SCE_PL_POD;
876  						styler.SetLineState(ln, pod);
877  					} else if (pod == SCE_PL_POD
878  					        && (styler.GetLineState(ln - 1) == SCE_PL_POD_VERB)) {
879  						pod = SCE_PL_POD_VERB;
880  						styler.SetLineState(ln, pod);
881  					}
882  					sc.SetState(pod);
883  				}
884  				sc.ForwardBytes(fw - sc.currentPos);	
885  			}
886  			break;
887  		case SCE_PL_REGEX:
888  		case SCE_PL_STRING_QR:
889  			if (Quote.Rep <= 0) {
890  				if (!setModifiers.Contains(sc.ch))
891  					sc.SetState(SCE_PL_DEFAULT);
892  			} else if (!Quote.Up && !IsASpace(sc.ch)) {
893  				Quote.Open(sc.ch);
894  			} else {
895  				int c, sLen = 0, endType = 0;
896  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
897  					if (IsASpace(c)) {
898  						break;
899  					} else if (c == '\\' && Quote.Up != '\\') {
900  						endType = 1; break;
901  					} else if (c == Quote.Down) {
902  						Quote.Count--;
903  						if (Quote.Count == 0) {
904  							Quote.Rep--;
905  							break;
906  						}
907  					} else if (c == Quote.Up)
908  						Quote.Count++;
909  					sLen++;
910  				}
911  				if (sLen > 0) {	
912  					if (Quote.Up != '\'') {
913  						InterpolateSegment(sc, sLen, true);
914  					} else		
915  						sc.Forward(sLen);
916  				}
917  				if (endType == 1)
918  					sc.Forward();
919  			}
920  			break;
921  		case SCE_PL_REGSUBST:
922  		case SCE_PL_XLAT:
923  			if (Quote.Rep <= 0) {
924  				if (!setModifiers.Contains(sc.ch))
925  					sc.SetState(SCE_PL_DEFAULT);
926  			} else if (!Quote.Up && !IsASpace(sc.ch)) {
927  				Quote.Open(sc.ch);
928  			} else {
929  				int c, sLen = 0, endType = 0;
930  				bool isPattern = (Quote.Rep == 2);
931  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
932  					if (c == '\\' && Quote.Up != '\\') {
933  						endType = 2; break;
934  					} else if (Quote.Count == 0 && Quote.Rep == 1) {
935  						if (IsASpace(c)) {
936  						} else if (c == '#' && IsASpaceOrTab(sc.GetRelativeCharacter(sLen - 1))) {
937  							endType = 3;
938  						} else
939  							Quote.Open(c);
940  						break;
941  					} else if (c == Quote.Down) {
942  						Quote.Count--;
943  						if (Quote.Count == 0) {
944  							Quote.Rep--;
945  							endType = 1;
946  						}
947  						if (Quote.Up == Quote.Down)
948  							Quote.Count++;
949  						if (endType == 1)
950  							break;
951  					} else if (c == Quote.Up) {
952  						Quote.Count++;
953  					} else if (IsASpace(c))
954  						break;
955  					sLen++;
956  				}
957  				if (sLen > 0) {	
958  					if (sc.state == SCE_PL_REGSUBST && Quote.Up != '\'') {
959  						InterpolateSegment(sc, sLen, isPattern);
960  					} else		
961  						sc.Forward(sLen);
962  				}
963  				if (endType == 2) {
964  					sc.Forward();
965  				} else if (endType == 3)
966  					sc.SetState(SCE_PL_DEFAULT);
967  			}
968  			break;
969  		case SCE_PL_STRING_Q:
970  		case SCE_PL_STRING_QQ:
971  		case SCE_PL_STRING_QX:
972  		case SCE_PL_STRING_QW:
973  		case SCE_PL_STRING:
974  		case SCE_PL_CHARACTER:
975  		case SCE_PL_BACKTICKS:
976  			if (!Quote.Down && !IsASpace(sc.ch)) {
977  				Quote.Open(sc.ch);
978  			} else {
979  				int c, sLen = 0, endType = 0;
980  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
981  					if (IsASpace(c)) {
982  						break;
983  					} else if (c == '\\' && Quote.Up != '\\') {
984  						endType = 2; break;
985  					} else if (c == Quote.Down) {
986  						Quote.Count--;
987  						if (Quote.Count == 0) {
988  							endType = 3; break;
989  						}
990  					} else if (c == Quote.Up)
991  						Quote.Count++;
992  					sLen++;
993  				}
994  				if (sLen > 0) {	
995  					switch (sc.state) {
996  					case SCE_PL_STRING:
997  					case SCE_PL_STRING_QQ:
998  					case SCE_PL_BACKTICKS:
999  						InterpolateSegment(sc, sLen);
1000  						break;
1001  					case SCE_PL_STRING_QX:
1002  						if (Quote.Up != '\'') {
1003  							InterpolateSegment(sc, sLen);
1004  							break;
1005  						}
1006  					default:	
1007  						sc.Forward(sLen);
1008  					}
1009  				}
1010  				if (endType == 2) {
1011  					sc.Forward();
1012  				} else if (endType == 3)
1013  					sc.ForwardSetState(SCE_PL_DEFAULT);
1014  			}
1015  			break;
1016  		case SCE_PL_SUB_PROTOTYPE: {
1017  				int i = 0;
1018  				while (setSubPrototype.Contains(sc.GetRelative(i)))
1019  					i++;
1020  				if (sc.GetRelative(i) == ')') {	
1021  					sc.ForwardBytes(i);
1022  					sc.ForwardSetState(SCE_PL_DEFAULT);
1023  				} else {
1024  					sc.ChangeState(SCE_PL_OPERATOR);
1025  					sc.SetState(SCE_PL_DEFAULT);
1026  				}
1027  			}
1028  			break;
1029  		case SCE_PL_FORMAT: {
1030  				sc.Complete();
1031  				if (sc.Match('.')) {
1032  					sc.Forward();
1033  					if (sc.atLineEnd || ((sc.ch == '\r' && sc.chNext == '\n')))
1034  						sc.SetState(SCE_PL_DEFAULT);
1035  				}
1036  				while (!sc.atLineEnd)
1037  					sc.Forward();
1038  			}
1039  			break;
1040  		case SCE_PL_ERROR:
1041  			break;
1042  		}
1043  		switch (sc.state) {
1044  		case SCE_PL_FORMAT_IDENT:
1045  			if (IsASpaceOrTab(sc.ch)) {		
1046  				sc.ChangeState(SCE_PL_DEFAULT);
1047  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
1048  					sc.Forward();
1049  				sc.SetState(SCE_PL_FORMAT_IDENT);
1050  			}
1051  			if (setFormatStart.Contains(sc.ch)) {	
1052  				if (sc.ch != '=') {
1053  					do {
1054  						sc.Forward();
1055  					} while (setFormat.Contains(sc.ch));
1056  				}
1057  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
1058  					sc.Forward();
1059  				if (sc.ch == '=') {
1060  					sc.ForwardSetState(SCE_PL_DEFAULT);
1061  					HereDoc.State = 3;
1062  				} else {
1063  					sc.ChangeState(SCE_PL_IDENTIFIER);
1064  					sc.SetState(SCE_PL_DEFAULT);
1065  				}
1066  			} else {
1067  				sc.ChangeState(SCE_PL_DEFAULT);	
1068  			}
1069  			backFlag = BACK_NONE;
1070  			break;
1071  		}
1072  		if (HereDoc.State == 1 && sc.atLineEnd) {
1073  			int st_new = SCE_PL_HERE_QQ;
1074  			HereDoc.State = 2;
1075  			if (HereDoc.Quoted) {
1076  				if (sc.state == SCE_PL_HERE_DELIM) {
1077  					sc.ChangeState(SCE_PL_ERROR);
1078  				}
1079  				switch (HereDoc.Quote) {
1080  				case '\'':
1081  					st_new = SCE_PL_HERE_Q;
1082  					break;
1083  				case '"' :
1084  					st_new = SCE_PL_HERE_QQ;
1085  					break;
1086  				case '`' :
1087  					st_new = SCE_PL_HERE_QX;
1088  					break;
1089  				}
1090  			} else {
1091  				if (HereDoc.Quote == '\\')
1092  					st_new = SCE_PL_HERE_Q;
1093  			}
1094  			sc.SetState(st_new);
1095  		}
1096  		if (HereDoc.State == 3 && sc.atLineEnd) {
1097  			HereDoc.State = 0;
1098  			sc.SetState(SCE_PL_FORMAT);
1099  		}
1100  		if (sc.state == SCE_PL_DEFAULT) {
1101  			if (IsADigit(sc.ch) ||
1102  			        (IsADigit(sc.chNext) && (sc.ch == '.' || sc.ch == 'v'))) {
1103  				sc.SetState(SCE_PL_NUMBER);
1104  				backFlag = BACK_NONE;
1105  				numState = PERLNUM_DECIMAL;
1106  				dotCount = 0;
1107  				if (sc.ch == '0') {		
1108  					if (sc.chNext == 'x' || sc.chNext == 'X') {
1109  						numState = PERLNUM_HEX;
1110  					} else if (sc.chNext == 'b' || sc.chNext == 'B') {
1111  						numState = PERLNUM_BINARY;
1112  					} else if (IsADigit(sc.chNext)) {
1113  						numState = PERLNUM_OCTAL;
1114  					}
1115  					if (numState != PERLNUM_DECIMAL) {
1116  						sc.Forward();
1117  					}
1118  				} else if (sc.ch == 'v') {		
1119  					numState = PERLNUM_V_VECTOR;
1120  				}
1121  			} else if (setWord.Contains(sc.ch)) {
1122  				sc.SetState(SCE_PL_WORD);
1123  				if (sc.chPrev == ':' && sc.GetRelative(-2) == ':') {
1124  					sc.ChangeState(SCE_PL_IDENTIFIER);
1125  				}
1126  				Sci_PositionU bk = sc.currentPos;
1127  				Sci_PositionU fw = sc.currentPos + 1;
1128  				if (sc.ch == 's' && !setWord.Contains(sc.chNext)) {
1129  					sc.ChangeState(SCE_PL_REGSUBST);
1130  					Quote.New(2);
1131  				} else if (sc.ch == 'm' && !setWord.Contains(sc.chNext)) {
1132  					sc.ChangeState(SCE_PL_REGEX);
1133  					Quote.New();
1134  				} else if (sc.ch == 'q' && !setWord.Contains(sc.chNext)) {
1135  					sc.ChangeState(SCE_PL_STRING_Q);
1136  					Quote.New();
1137  				} else if (sc.ch == 'y' && !setWord.Contains(sc.chNext)) {
1138  					sc.ChangeState(SCE_PL_XLAT);
1139  					Quote.New(2);
1140  				} else if (sc.Match('t', 'r') && !setWord.Contains(sc.GetRelative(2))) {
1141  					sc.ChangeState(SCE_PL_XLAT);
1142  					Quote.New(2);
1143  					sc.Forward();
1144  					fw++;
1145  				} else if (sc.ch == 'q' && setQDelim.Contains(sc.chNext)
1146  				        && !setWord.Contains(sc.GetRelative(2))) {
1147  					if (sc.chNext == 'q') sc.ChangeState(SCE_PL_STRING_QQ);
1148  					else if (sc.chNext == 'x') sc.ChangeState(SCE_PL_STRING_QX);
1149  					else if (sc.chNext == 'r') sc.ChangeState(SCE_PL_STRING_QR);
1150  					else sc.ChangeState(SCE_PL_STRING_QW);	
1151  					Quote.New();
1152  					sc.Forward();
1153  					fw++;
1154  				} else if (sc.ch == 'x' && (sc.chNext == '=' ||	
1155  				        !setWord.Contains(sc.chNext) ||
1156  				        (setRepetition.Contains(sc.chPrev) && IsADigit(sc.chNext)))) {
1157  					sc.ChangeState(SCE_PL_OPERATOR);
1158  				}
1159  				if (sc.state == SCE_PL_WORD) {
1160  					while (setWord.Contains(static_cast<unsigned char>(styler.SafeGetCharAt(fw))))
1161  						fw++;
1162  					if (!isPerlKeyword(styler.GetStartSegment(), fw, keywords, styler)) {
1163  						sc.ChangeState(SCE_PL_IDENTIFIER);
1164  					}
1165  				}
1166  				if (sc.state != SCE_PL_IDENTIFIER && bk > 0) {
1167  					if (disambiguateBareword(styler, bk, fw, backFlag, backPos, endPos))
1168  						sc.ChangeState(SCE_PL_IDENTIFIER);
1169  				}
1170  				backFlag = BACK_NONE;
1171  			} else if (sc.ch == '#') {
1172  				sc.SetState(SCE_PL_COMMENTLINE);
1173  			} else if (sc.ch == '\"') {
1174  				sc.SetState(SCE_PL_STRING);
1175  				Quote.New();
1176  				Quote.Open(sc.ch);
1177  				backFlag = BACK_NONE;
1178  			} else if (sc.ch == '\'') {
1179  				if (sc.chPrev == '&' && setWordStart.Contains(sc.chNext)) {
1180  					sc.SetState(SCE_PL_IDENTIFIER);
1181  				} else {
1182  					sc.SetState(SCE_PL_CHARACTER);
1183  					Quote.New();
1184  					Quote.Open(sc.ch);
1185  				}
1186  				backFlag = BACK_NONE;
1187  			} else if (sc.ch == '`') {
1188  				sc.SetState(SCE_PL_BACKTICKS);
1189  				Quote.New();
1190  				Quote.Open(sc.ch);
1191  				backFlag = BACK_NONE;
1192  			} else if (sc.ch == '$') {
1193  				sc.SetState(SCE_PL_SCALAR);
1194  				if (sc.chNext == '{') {
1195  					sc.ForwardSetState(SCE_PL_OPERATOR);
1196  				} else if (IsASpace(sc.chNext)) {
1197  					sc.ForwardSetState(SCE_PL_DEFAULT);
1198  				} else {
1199  					sc.Forward();
1200  					if (sc.Match('`', '`') || sc.Match(':', ':')) {
1201  						sc.Forward();
1202  					}
1203  				}
1204  				backFlag = BACK_NONE;
1205  			} else if (sc.ch == '@') {
1206  				sc.SetState(SCE_PL_ARRAY);
1207  				if (setArray.Contains(sc.chNext)) {
1208  				} else if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1209  					sc.ForwardBytes(2);
1210  				} else if (sc.chNext == '{' || sc.chNext == '[') {
1211  					sc.ForwardSetState(SCE_PL_OPERATOR);
1212  				} else {
1213  					sc.ChangeState(SCE_PL_OPERATOR);
1214  				}
1215  				backFlag = BACK_NONE;
1216  			} else if (setPreferRE.Contains(sc.ch)) {
1217  				bool preferRE = false;
1218  				bool isHereDoc = sc.Match('<', '<');
1219  				bool hereDocSpace = false;		
1220  				Sci_PositionU bk = (sc.currentPos > 0) ? sc.currentPos - 1: 0;
1221  				sc.Complete();
1222  				styler.Flush();
1223  				if (styler.StyleAt(bk) == SCE_PL_DEFAULT)
1224  					hereDocSpace = true;
1225  				skipWhitespaceComment(styler, bk);
1226  				if (bk == 0) {
1227  					preferRE = true;
1228  				} else {
1229  					int bkstyle = styler.StyleAt(bk);
1230  					int bkch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
1231  					switch (bkstyle) {
1232  					case SCE_PL_OPERATOR:
1233  						preferRE = true;
1234  						if (bkch == ')' || bkch == ']') {
1235  							preferRE = false;
1236  						} else if (bkch == '}') {
1237  							bkstyle = styleBeforeBracePair(styler, bk);
1238  							if (bkstyle == SCE_PL_SCALAR
1239  							        || bkstyle == SCE_PL_ARRAY
1240  							        || bkstyle == SCE_PL_HASH
1241  							        || bkstyle == SCE_PL_SYMBOLTABLE
1242  							        || bkstyle == SCE_PL_OPERATOR) {
1243  								preferRE = false;
1244  							}
1245  						} else if (bkch == '+' || bkch == '-') {
1246  							if (bkch == static_cast<unsigned char>(styler.SafeGetCharAt(bk - 1))
1247  							        && bkch != static_cast<unsigned char>(styler.SafeGetCharAt(bk - 2)))
1248  								preferRE = false;
1249  						}
1250  						break;
1251  					case SCE_PL_IDENTIFIER:
1252  						preferRE = true;
1253  						bkstyle = styleCheckIdentifier(styler, bk);
1254  						if ((bkstyle == 1) || (bkstyle == 2)) {
1255  							preferRE = false;
1256  						} else if (bkstyle == 3) {
1257  							if (sc.ch == '/') {
1258  								if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.chNext == '/')
1259  									preferRE = false;
1260  							} else if (sc.ch == '*' || sc.ch == '%') {
1261  								if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.Match('*', '*'))
1262  									preferRE = false;
1263  							} else if (sc.ch == '<') {
1264  								if (IsASpace(sc.chNext) || sc.chNext == '=')
1265  									preferRE = false;
1266  							}
1267  						}
1268  						break;
1269  					case SCE_PL_SCALAR:		
1270  						if (isHereDoc && hereDocSpace)	
1271  							preferRE = true;
1272  						break;
1273  					case SCE_PL_WORD:
1274  						preferRE = true;
1275  						if (sc.ch == '/') {
1276  							Sci_PositionU bkend = bk + 1;
1277  							while (bk > 0 && styler.StyleAt(bk - 1) == SCE_PL_WORD) {
1278  								bk--;
1279  							}
1280  							if (isPerlKeyword(bk, bkend, reWords, styler))
1281  								break;
1282  							if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.chNext == '/')
1283  								preferRE = false;
1284  						} else if (sc.ch == '*' || sc.ch == '%') {
1285  							if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.Match('*', '*'))
1286  								preferRE = false;
1287  						} else if (sc.ch == '<') {
1288  							if (IsASpace(sc.chNext) || sc.chNext == '=')
1289  								preferRE = false;
1290  						}
1291  						break;
1292  					case SCE_PL_POD:
1293  					case SCE_PL_HERE_Q:
1294  					case SCE_PL_HERE_QQ:
1295  					case SCE_PL_HERE_QX:
1296  						preferRE = true;
1297  						break;
1298  					}
1299  				}
1300  				backFlag = BACK_NONE;
1301  				if (isHereDoc) {	
1302  					if (sc.Match("<<>>")) {		
1303  						sc.SetState(SCE_PL_OPERATOR);
1304  						sc.Forward(3);
1305  					} else if (preferRE) {
1306  						sc.SetState(SCE_PL_HERE_DELIM);
1307  						HereDoc.State = 0;
1308  					} else {		
1309  						sc.SetState(SCE_PL_OPERATOR);
1310  						sc.Forward();
1311  					}
1312  				} else if (sc.ch == '*') {	
1313  					if (preferRE) {
1314  						sc.SetState(SCE_PL_SYMBOLTABLE);
1315  						if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1316  							sc.ForwardBytes(2);
1317  						} else if (sc.chNext == '{') {
1318  							sc.ForwardSetState(SCE_PL_OPERATOR);
1319  						} else {
1320  							sc.Forward();
1321  						}
1322  					} else {
1323  						sc.SetState(SCE_PL_OPERATOR);
1324  						if (sc.chNext == '*') 	
1325  							sc.Forward();
1326  					}
1327  				} else if (sc.ch == '%') {	
1328  					if (preferRE) {
1329  						sc.SetState(SCE_PL_HASH);
1330  						if (setHash.Contains(sc.chNext)) {
1331  							sc.Forward();
1332  						} else if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1333  							sc.ForwardBytes(2);
1334  						} else if (sc.chNext == '{') {
1335  							sc.ForwardSetState(SCE_PL_OPERATOR);
1336  						} else {
1337  							sc.ChangeState(SCE_PL_OPERATOR);
1338  						}
1339  					} else {
1340  						sc.SetState(SCE_PL_OPERATOR);
1341  					}
1342  				} else if (sc.ch == '<') {	
1343  					if (preferRE) {
1344  						int i = InputSymbolScan(sc);
1345  						if (i > 0) {
1346  							sc.SetState(SCE_PL_IDENTIFIER);
1347  							sc.Forward(i);
1348  						} else {
1349  							sc.SetState(SCE_PL_OPERATOR);
1350  						}
1351  					} else {
1352  						sc.SetState(SCE_PL_OPERATOR);
1353  					}
1354  				} else {			
1355  					if (preferRE) {
1356  						sc.SetState(SCE_PL_REGEX);
1357  						Quote.New();
1358  						Quote.Open(sc.ch);
1359  					} else {		
1360  						sc.SetState(SCE_PL_OPERATOR);
1361  						if (sc.chNext == '/') {
1362  							sc.Forward();
1363  						}
1364  					}
1365  				}
1366  			} else if (sc.ch == '='		
1367  			        && setPOD.Contains(sc.chNext)
1368  			        && sc.atLineStart) {
1369  				sc.SetState(SCE_PL_POD);
1370  				backFlag = BACK_NONE;
1371  			} else if (sc.ch == '-' && setWordStart.Contains(sc.chNext)) {	
1372  				Sci_PositionU bk = sc.currentPos;
1373  				Sci_PositionU fw = 2;
1374  				if (setSingleCharOp.Contains(sc.chNext) &&	
1375  				        !setWord.Contains(sc.GetRelative(2))) {
1376  					sc.SetState(SCE_PL_WORD);
1377  				} else {
1378  					while (setWord.Contains(sc.GetRelative(fw)))
1379  						fw++;
1380  					sc.SetState(SCE_PL_OPERATOR);
1381  				}
1382  				if (disambiguateBareword(styler, bk, bk + fw, backFlag, backPos, endPos) & 2) {
1383  					sc.ChangeState(SCE_PL_IDENTIFIER);
1384  				}
1385  				backFlag = BACK_NONE;
1386  			} else if (sc.ch == '(' && sc.currentPos > 0) {	
1387  				sc.Complete();
1388  				if (styleCheckSubPrototype(styler, sc.currentPos - 1)) {
1389  					sc.SetState(SCE_PL_SUB_PROTOTYPE);
1390  					backFlag = BACK_NONE;
1391  				} else {
1392  					sc.SetState(SCE_PL_OPERATOR);
1393  				}
1394  			} else if (setPerlOperator.Contains(sc.ch)) {	
1395  				sc.SetState(SCE_PL_OPERATOR);
1396  				if (sc.Match('.', '.')) {	
1397  					sc.Forward();
1398  					if (sc.chNext == '.') sc.Forward();
1399  				}
1400  			} else if (sc.ch == 4 || sc.ch == 26) {		
1401  				sc.SetState(SCE_PL_DATASECTION);
1402  			} else {
1403  				sc.Complete();
1404  			}
1405  		}
1406  	}
1407  	sc.Complete();
1408  	if (sc.state == SCE_PL_HERE_Q
1409  	        || sc.state == SCE_PL_HERE_QQ
1410  	        || sc.state == SCE_PL_HERE_QX
1411  	        || sc.state == SCE_PL_FORMAT) {
1412  		styler.ChangeLexerState(sc.currentPos, styler.Length());
1413  	}
1414  	sc.Complete();
1415  }
1416  #define PERL_HEADFOLD_SHIFT		4
1417  #define PERL_HEADFOLD_MASK		0xF0
1418  void SCI_METHOD LexerPerl::Fold(Sci_PositionU startPos, Sci_Position length, int &bsol;* initStyle */, IDocument *pAccess) {
1419  	if (!options.fold)
1420  		return;
1421  	LexAccessor styler(pAccess);
1422  	Sci_PositionU endPos = startPos + length;
1423  	int visibleChars = 0;
1424  	Sci_Position lineCurrent = styler.GetLine(startPos);
1425  	if (startPos > 0) {
1426  		if (lineCurrent > 0) {
1427  			lineCurrent--;
1428  			startPos = styler.LineStart(lineCurrent);
1429  		}
1430  	}
1431  	int levelPrev = SC_FOLDLEVELBASE;
1432  	if (lineCurrent > 0)
1433  		levelPrev = styler.LevelAt(lineCurrent - 1) >> 16;
1434  	int levelCurrent = levelPrev;
1435  	char chNext = styler[startPos];
1436  	char chPrev = styler.SafeGetCharAt(startPos - 1);
1437  	int styleNext = styler.StyleAt(startPos);
1438  	bool isPackageLine = false;
1439  	int podHeading = 0;
1440  	for (Sci_PositionU i = startPos; i < endPos; i++) {
1441  		char ch = chNext;
1442  		chNext = styler.SafeGetCharAt(i + 1);
1443  		int style = styleNext;
1444  		styleNext = styler.StyleAt(i + 1);
1445  		int stylePrevCh = (i) ? styler.StyleAt(i - 1):SCE_PL_DEFAULT;
1446  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
1447  		bool atLineStart = ((chPrev == '\r') || (chPrev == '\n')) || i == 0;
1448  		if (options.foldComment && atEOL && IsCommentLine(lineCurrent, styler)) {
1449  			if (!IsCommentLine(lineCurrent - 1, styler)
1450  			        && IsCommentLine(lineCurrent + 1, styler))
1451  				levelCurrent++;
1452  			else if (IsCommentLine(lineCurrent - 1, styler)
1453  			        && !IsCommentLine(lineCurrent + 1, styler))
1454  				levelCurrent--;
1455  		}
1456  		if (style == SCE_PL_OPERATOR) {
1457  			if (ch == '{') {
1458  				if (options.foldAtElse && levelCurrent < levelPrev)
1459  					--levelPrev;
1460  				levelCurrent++;
1461  			} else if (ch == '}') {
1462  				levelCurrent--;
1463  			}
1464  			if (ch == '[') {
1465  				if (options.foldAtElse && levelCurrent < levelPrev)
1466  					--levelPrev;
1467  				levelCurrent++;
1468  			} else if (ch == ']') {
1469  				levelCurrent--;
1470  			}
1471  		} else if (style == SCE_PL_STRING_QW) {
1472  			if (stylePrevCh != style)
1473  				levelCurrent++;
1474  			else if (styleNext != style)
1475  				levelCurrent--;
1476  		}
1477  		if (options.foldPOD && atLineStart) {
1478  			if (style == SCE_PL_POD) {
1479  				if (stylePrevCh != SCE_PL_POD && stylePrevCh != SCE_PL_POD_VERB)
1480  					levelCurrent++;
1481  				else if (styler.Match(i, "=cut"))
1482  					levelCurrent = (levelCurrent & ~PERL_HEADFOLD_MASK) - 1;
1483  				else if (styler.Match(i, "=head"))
1484  					podHeading = PodHeadingLevel(i, styler);
1485  			} else if (style == SCE_PL_DATASECTION) {
1486  				if (ch == '=' && IsASCII(chNext) && isalpha(chNext) && levelCurrent == SC_FOLDLEVELBASE)
1487  					levelCurrent++;
1488  				else if (styler.Match(i, "=cut") && levelCurrent > SC_FOLDLEVELBASE)
1489  					levelCurrent = (levelCurrent & ~PERL_HEADFOLD_MASK) - 1;
1490  				else if (styler.Match(i, "=head"))
1491  					podHeading = PodHeadingLevel(i, styler);
1492  				else if (stylePrevCh != SCE_PL_DATASECTION)
1493  					levelCurrent = SC_FOLDLEVELBASE;
1494  			}
1495  		}
1496  		if (options.foldPackage && atLineStart) {
1497  			if (IsPackageLine(lineCurrent, styler)
1498  			        && !IsPackageLine(lineCurrent + 1, styler))
1499  				isPackageLine = true;
1500  		}
1501  		switch (style) {
1502  		case SCE_PL_HERE_QQ :
1503  		case SCE_PL_HERE_Q :
1504  		case SCE_PL_HERE_QX :
1505  			switch (stylePrevCh) {
1506  			case SCE_PL_HERE_QQ :
1507  			case SCE_PL_HERE_Q :
1508  			case SCE_PL_HERE_QX :
1509  				break;
1510  			default :
1511  				levelCurrent++;
1512  				break;
1513  			}
1514  			break;
1515  		default:
1516  			switch (stylePrevCh) {
1517  			case SCE_PL_HERE_QQ :
1518  			case SCE_PL_HERE_Q :
1519  			case SCE_PL_HERE_QX :
1520  				levelCurrent--;
1521  				break;
1522  			default :
1523  				break;
1524  			}
1525  			break;
1526  		}
1527  		if (options.foldCommentExplicit && style == SCE_PL_COMMENTLINE && ch == '#') {
1528  			if (chNext == '{') {
1529  				levelCurrent++;
1530  			} else if (levelCurrent > SC_FOLDLEVELBASE  && chNext == '}') {
1531  				levelCurrent--;
1532  			}
1533  		}
1534  		if (atEOL) {
1535  			int lev = levelPrev;
1536  			if (podHeading > 0) {
1537  				levelCurrent = (lev & ~PERL_HEADFOLD_MASK) | (podHeading << PERL_HEADFOLD_SHIFT);
1538  				lev = levelCurrent - 1;
1539  				lev |= SC_FOLDLEVELHEADERFLAG;
1540  				podHeading = 0;
1541  			}
1542  			if (isPackageLine) {
1543  				lev = SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG;
1544  				levelCurrent = SC_FOLDLEVELBASE + 1;
1545  				isPackageLine = false;
1546  			}
1547  			lev |= levelCurrent << 16;
1548  			if (visibleChars == 0 && options.foldCompact)
1549  				lev |= SC_FOLDLEVELWHITEFLAG;
1550  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
1551  				lev |= SC_FOLDLEVELHEADERFLAG;
1552  			if (lev != styler.LevelAt(lineCurrent)) {
1553  				styler.SetLevel(lineCurrent, lev);
1554  			}
1555  			lineCurrent++;
1556  			levelPrev = levelCurrent;
1557  			visibleChars = 0;
1558  		}
1559  		if (!isspacechar(ch))
1560  			visibleChars++;
1561  		chPrev = ch;
1562  	}
1563  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
1564  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1565  }
1566  LexerModule lmPerl(SCLEX_PERL, LexerPerl::LexerFactoryPerl, "perl", perlWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPerl.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPerl.cxx</div>
                </div>
                <div class="column column_space"><pre><code>197  		           styler.Match(pos1, "::")) {	
198  			if (style2 == SCE_PL_IDENTIFIER) {	
199  				state = SUB_HAS_MODULE;
200  			} else
201  				break;
202  		} else if (style1 == SCE_PL_WORD && len1 == 3 &&
</pre></code></div>
                <div class="column column_space"><pre><code>203  		           styler.Match(pos1, "sub")) {	
204  			if (style2 == SCE_PL_IDENTIFIER) {	
205  				state = SUB_HAS_SUB;
206  			} else
207  				break;
208  		} else
209  			break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    