
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.57222029788708%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-infonet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "infonet.h"
3  TStr TThermalSch::GetFldVal(const PXmlTok& RecXmlTok, const TStr& FldNm) const {
4    PXmlTok FldTagTok;
5    if (RecXmlTok->IsTagTok(FldNm, FldTagTok)){
6      return FldTagTok->GetTokStr(false);}
7    else {return "";}
8  }
9  TStr TThermalSch::GetFldVal(const PXmlDoc& RecXmlDoc, const TStr& FldNm) const {
10    PXmlTok FldTagTok;
11    if (RecXmlDoc->IsTagTok(FldNm, FldTagTok)){
12      return FldTagTok->GetTokStr(false);}
13    else {return "";}
14  }
15  TStr TThermalSch::GetFldDateVal(const PXmlTok& RecXmlTok, const TStr& FldNm) const {
16    TStr DateVal=TThermalSch::GetFldVal(RecXmlTok, FldNm);
17    DateVal.DelChAll('-');
18    return DateVal;
19  }
20  TStr TThermalSch::GetFldDateVal(const PXmlDoc& RecXmlDoc, const TStr& FldNm) const {
21    TStr DateVal=TThermalSch::GetFldVal(RecXmlDoc, FldNm);
22    DateVal.DelChAll('-');
23    return DateVal;
24  }
25  TStrV TThermalSch::GetFldValV(const PXmlTok& RecXmlTok, const TStr& FldNm,
26   const TStr& XFldNm, const TStr& SubFldNm) const {
27    TStrV FldValV;
28    PXmlTok FldTagTok;
29    if (RecXmlTok->IsTagTok(FldNm, FldTagTok)){
30      if (SubFldNm.Empty()){
31        FldTagTok->GetTagValV(XFldNm, false, FldValV);
32      } else {
33        TXmlTokV XmlTokV; FldTagTok->GetTagTokV(XFldNm, XmlTokV);
34        for (int FldN=0; FldN<XmlTokV.Len(); FldN++){
35          TStr FldVal=GetFldVal(XmlTokV[FldN], SubFldNm);
36          FldValV.Add(FldVal);
37        }
38      }
39    }
40    return FldValV;
41  }
42  TStr TThermalSch::GetXmlOut_Ok(const TStr& OpNm){
43    TChA ChA;
44    ChA+="<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
45    ChA+="<ParamOut>\n";
46    ChA+="<OperationName>";
47    ChA+=TXmlLx::GetXmlStrFromPlainStr(OpNm);
48    ChA+="</OperationName>\n";
49    ChA+="<Success>Ok</Success>\n";
50    ChA+="</ParamOut>\n";
51    return ChA;
52  }
53  TStr TThermalSch::GetXmlOut_Error(const TStr& OpNm, const TStr& MsgStr){
54    TChA ChA;
55    ChA+="<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
56    ChA+="<ParamOut>\n";
57    ChA+="<OperationName>";
58    ChA+=TXmlLx::GetXmlStrFromPlainStr(OpNm);
59    ChA+="</OperationName>\n";
60    ChA+="<Success>Error</Success>\n";
61    ChA+="<ResultMessage>";
62    ChA+=TXmlLx::GetXmlStrFromPlainStr(MsgStr);
63    ChA+="</ResultMessage>\n";
64    ChA+="</ParamOut>\n";
65    return ChA;
66  }
67  TStr TThermalSch::ExeCmFromXml(const PSIn& SIn){
68    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn);
69    if (XmlDoc->IsOk()){
70      TStr CmTagNm="Operation|OperationName";
71      if (XmlDoc->IsTagTok(CmTagNm)){
72        TStr CmNm=XmlDoc->GetTagTokStr(CmTagNm);
73        if (CmNm=="SetCatalogueTherapyPlaces"){
74          return ExeCm_SetCatalogueTherapyPlaces(XmlDoc);
75        } else if (CmNm=="SetCatalogueActivities"){
76          return ExeCm_SetCatalogueActivities(XmlDoc);
77        } else if (CmNm=="SetCatalogueAvailableTherapyPlaces"){
78          return ExeCm_SetCatalogueAvailableTherapyPlaces(XmlDoc);
79        } else if (CmNm=="SetCatalogueAvailableActivities"){
80          return ExeCm_SetCatalogueAvailableActivities(XmlDoc);
81        } else if (CmNm=="SetScheduledActivities"){
82          return ExeCm_SetScheduledActivities(XmlDoc);
83        } else if (CmNm=="SetCatalogueHolidays"){
84          return ExeCm_SetCatalogueHolidays(XmlDoc);
85        } else if (CmNm=="MakeSchedule"){
86          return ExeCm_MakeSchedule(XmlDoc);
87        } else if (CmNm=="CheckSchedule"){
88          return ExeCm_CheckSchedule(XmlDoc);
89        } else {
90          TStr CmXmlStr=TXmlLx::GetXmlStrFromPlainStr(CmNm);
91          return GetXmlOut_Error(CmXmlStr, TStr("Invalid Command: '")+CmXmlStr+"'.");
92        }
93      } else {
94        TStr CmTagXmlStr=TXmlLx::GetXmlStrFromPlainStr(CmTagNm);
95        return GetXmlOut_Error("NoCommand", TStr("Command tag not found: '")+CmTagXmlStr+"'.");
96      }
97    } else {
98      return GetXmlOut_Error("NoCommand", TStr("Invalid XML Format: '")+XmlDoc->GetMsgStr()+"'.");
99    }
100  }
101  TStr TThermalSch::ExeCmFromXmlFile(const TStr& FNm, const TStr& FPath){
102    TStr FullFNm=TStr::GetNrFPath(FPath)+FNm;
103    bool OpenedP;
<span onclick='openModal()' class='match'>104    PSIn SIn=TFIn::New(FullFNm, OpenedP);
105    if (OpenedP){
106      return ExeCmFromXml(SIn);
107    } else {
108      return GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+FNm+"'.");
</span>109    }
110  }
111  TStr TThermalSch::ExeCmFromXmlStr(const TStr& Str){
112    PSIn SIn=TStrIn::New(Str);
113    return ExeCmFromXml(SIn);
114  }
115  TStr TThermalSch::ExeCm_SetCatalogueTherapyPlaces(const PXmlDoc& XmlDoc){
116    TherapyPlacesXmlDoc=XmlDoc;
117    TStr MsgStr;
118    if (IsTherapyPlacesOk(MsgStr)){
119      return TThermalSch::GetXmlOut_Ok("SetCatalogueTherapyPlaces");
120    } else {
121      TherapyPlacesXmlDoc=NULL;
122      return MsgStr;
123    }
124  }
125  TStr TThermalSch::ExeCm_SetCatalogueActivities(const PXmlDoc& XmlDoc){
126    ActivitiesXmlDoc=XmlDoc;
127    TStr MsgStr;
128    if (IsActivitiesOk(MsgStr)){
129      return TThermalSch::GetXmlOut_Ok("SetCatalogueActivities");
130    } else {
131      ActivitiesXmlDoc=NULL;
132      return MsgStr;
133    }
134  }
135  TStr TThermalSch::ExeCm_SetCatalogueAvailableTherapyPlaces(const PXmlDoc& XmlDoc){
136    AvailableTherapyPlacesXmlDoc=XmlDoc;
137    TStr MsgStr;
138    if (IsAvailableTherapyPlacesOk(MsgStr)){
139      return TThermalSch::GetXmlOut_Ok("SetCatalogueAvailableTherapyPlaces");
140    } else {
141      AvailableTherapyPlacesXmlDoc=NULL;
142      return MsgStr;
143    }
144  }
145  TStr TThermalSch::ExeCm_SetCatalogueAvailableActivities(const PXmlDoc& XmlDoc){
146    AvailableActivitiesXmlDoc=XmlDoc;
147    TStr MsgStr;
148    if (IsAvailableActivitiesOk(MsgStr)){
149      return TThermalSch::GetXmlOut_Ok("SetCatalogueAvailableActivities");
150    } else {
151      AvailableActivitiesXmlDoc=NULL;
152      return MsgStr;
153    }
154  }
155  TStr TThermalSch::ExeCm_SetScheduledActivities(const PXmlDoc& XmlDoc){
156    ScheduledActivitiesXmlDoc=XmlDoc;
157    TStr MsgStr;
158    if (IsScheduledActivitiesOk(MsgStr)){
159      return TThermalSch::GetXmlOut_Ok("SetScheduledActivities");
160    } else {
161      ScheduledActivitiesXmlDoc=NULL;
162      return MsgStr;
163    }
164  }
165  TStr TThermalSch::ExeCm_SetCatalogueHolidays(const PXmlDoc& XmlDoc){
166    HolidaysXmlDoc=XmlDoc;
167    TStr MsgStr;
168    if (IsHolidaysOk(MsgStr)){
169      return TThermalSch::GetXmlOut_Ok("SetCatalogueHolidays");
170    } else {
171      HolidaysXmlDoc=NULL;
172      return MsgStr;
173    }
174  }
175  TStr TThermalSch::ExeCm_MakeSchedule(const PXmlDoc& XmlDoc){
176    MakeScheduleXmlDoc=XmlDoc;
177    TStr MsgStr;
178    if (IsMakeScheduleOk(MsgStr)){
179      SaveOldCsv();
180      TChA CmLn;
181      CmLn+="genscher.exe";
182      CmLn+=" -dir"; CmLn+=GetMakeSchedule_PatientATPCode();
183      CmLn+=" -pass";
184      system(CmLn.CStr());
185      TThermalSch::SaveCsvToXml("URNIKXXG.TXT", "URNIKXX0.TXT", "Out.Xml");
186      TThermalSch::SaveCsvToXmlParamOut("URNIKXXG.TXT", "URNIKXX0.TXT", "ParamOut.Xml");
187      TStr XmlStr=TStr::LoadTxt("ParamOut.Xml");
188      return XmlStr;
189    } else {
190      MakeScheduleXmlDoc=NULL;
191      return MsgStr;
192    }
193  }
194  TStr TThermalSch::ExeCm_CheckSchedule(const PXmlDoc& XmlDoc){
195    CheckScheduleXmlDoc=XmlDoc;
196    TStr MsgStr;
197    if (IsCheckScheduleOk(MsgStr)){
198      return TThermalSch::GetXmlOut_Ok("CheckSchedule");
199    } else {
200      CheckScheduleXmlDoc=NULL;
201      return MsgStr;
202    }
203  }
204  bool TThermalSch::IsTherapyPlacesOk(TStr& MsgStr) const {
205    if (TherapyPlacesXmlDoc.Empty()){
206      MsgStr=GetXmlOut_Error("SetCatalogueTherapyPlaces", "TherapyPlaces doesn't exists.");
207    }
208    int TherapyPlaces=TThermalSch::GetTherapyPlaces();
209    for (int TherapyPlaceN=0; TherapyPlaceN<TherapyPlaces; TherapyPlaceN++){
210      PXmlTok TherapyPlace=TThermalSch::GetTherapyPlace(TherapyPlaceN);
211      if (TherapyPlace->IsTag("TherapyPlace")){
212        GetTherapyPlace_Code(TherapyPlace);
213        GetTherapyPlace_Type(TherapyPlace);
214        GetTherapyPlace_Location(TherapyPlace);
215        GetTherapyPlace_Capacity(TherapyPlace);
216        GetTherapyPlace_Distance(TherapyPlace);
217        GetTherapyPlace_Gender(TherapyPlace);
218        GetTherapyPlace_AlternateScheduling(TherapyPlace);
219        GetTherapyPlace_FamilyScheduling(TherapyPlace);
220        GetTherapyPlace_TherapistType(TherapyPlace);
221      } else {
222        MsgStr=GetXmlOut_Error("SetCatalogueTherapyPlaces", "Invalid TherapyPlaces.");
223        return false;
224      }
225    }
226    return true;
227  }
228  int TThermalSch::GetTherapyPlaces() const {
229    if (TherapyPlacesXmlDoc.Empty()){return 0;}
230    TXmlTokV XmlTokV;
231    TherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|TherapyPlaces|TherapyPlace", XmlTokV);
232    return XmlTokV.Len();
233  }
234  PXmlTok TThermalSch::GetTherapyPlace(const int& TherapyPlaceN) const {
235    TXmlTokV XmlTokV;
236    TherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|TherapyPlaces|TherapyPlace", XmlTokV);
237    return XmlTokV[TherapyPlaceN];
238  }
239  bool TThermalSch::IsActivitiesOk(TStr& MsgStr) const {
240    if (ActivitiesXmlDoc.Empty()){
241      MsgStr=GetXmlOut_Error("SetCatalogueActivities", "Activities doesn't exists.");
242    }
243    int Activities=TThermalSch::GetActivities();
244    for (int ActivityN=0; ActivityN<Activities; ActivityN++){
245      PXmlTok Activity=TThermalSch::GetActivity(ActivityN);
246      if (Activity->IsTag("Activity")){
247        GetActivity_Code(Activity);
248        GetActivity_Type(Activity);
249        GetActivity_Name(Activity);
250        GetActivity_Priority(Activity);
251        GetActivity_Duration(Activity);
252        GetActivity_TPDuration(Activity);
253        GetActivity_PatientDuration(Activity);
254        GetActivity_TherapistDurationPreparation(Activity);
255        GetActivity_TherapistDurationExecution(Activity);
256        GetActivity_TherapistDurationAdditionalTime(Activity);
257        GetActivity_Weariness(Activity);
258        GetActivity_Dry(Activity);
259      } else {
260        MsgStr=GetXmlOut_Error("SetCatalogueActivities", "Invalid Activities.");
261        return false;
262      }
263    }
264    return true;
265  }
266  int TThermalSch::GetActivities() const {
267    if (ActivitiesXmlDoc.Empty()){return 0;}
268    TXmlTokV XmlTokV;
269    ActivitiesXmlDoc->GetTagTokV("Operation|Parameter|Activities|Activity", XmlTokV);
270    return XmlTokV.Len();
271  }
272  PXmlTok TThermalSch::GetActivity(const int& ActivityN) const {
273    TXmlTokV XmlTokV;
274    ActivitiesXmlDoc->GetTagTokV("Operation|Parameter|Activities|Activity", XmlTokV);
275    return XmlTokV[ActivityN];
276  }
277  bool TThermalSch::IsAvailableTherapyPlacesOk(TStr& MsgStr) const {
278    if (AvailableTherapyPlacesXmlDoc.Empty()){
279      MsgStr=GetXmlOut_Error("SetCatalogueAvailableTherapyPlaces", "Available-Therapy-Places doesn't exists.");
280      return false;
281    }
282    int AvailableTherapyPlaces=TThermalSch::GetAvailableTherapyPlaces();
283    for (int AvailableTherapyPlaceN=0; AvailableTherapyPlaceN<AvailableTherapyPlaces; AvailableTherapyPlaceN++){
284      PXmlTok AvailableTherapyPlace=TThermalSch::GetAvailableTherapyPlace(AvailableTherapyPlaceN);
285      if (AvailableTherapyPlace->IsTag("AvailableTherapyPlace")){
286        GetAvailableTherapyPlace_Code(AvailableTherapyPlace);
287        int TherapyPlaceSchedules=GetTherapyPlaceSchedules(AvailableTherapyPlace);
288        for (int TherapyPlaceScheduleN=0; TherapyPlaceScheduleN<TherapyPlaceSchedules; TherapyPlaceScheduleN++){
289          PXmlTok TherapyPlaceSchedule=GetTherapyPlaceSchedule(AvailableTherapyPlace, TherapyPlaceScheduleN);
290          if (TherapyPlaceSchedule->IsTag("TherapyPlaceSchedule")){
291            GetTherapyPlaceSchedule_WeekDays(TherapyPlaceSchedule);
292            GetTherapyPlaceSchedule_OpenFrom(TherapyPlaceSchedule);
293            GetTherapyPlaceSchedule_OpenTill(TherapyPlaceSchedule);
294            GetTherapyPlaceSchedule_ValidFrom(TherapyPlaceSchedule);
295            GetTherapyPlaceSchedule_ValidTo(TherapyPlaceSchedule);
296          }
297        }
298      } else {
299        MsgStr=GetXmlOut_Error("SetCatalogueAvailableTherapyPlaces", "Invalid Available-Therapy-Places.");
300        return false;
301      }
302    }
303    return true;
304  }
305  int TThermalSch::GetAvailableTherapyPlaces() const {
306    if (AvailableTherapyPlacesXmlDoc.Empty()){return 0;}
307    TXmlTokV XmlTokV;
308    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace", XmlTokV);
309    return XmlTokV.Len();
310  }
311  PXmlTok TThermalSch::GetAvailableTherapyPlace(const int& AvailableTherapyPlaceN) const {
312    TXmlTokV XmlTokV;
313    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace", XmlTokV);
314    return XmlTokV[AvailableTherapyPlaceN];
315  }
316  int TThermalSch::GetTherapyPlaceSchedules(const PXmlTok& AvailableTherapyPlace) const {
317    TXmlTokV XmlTokV;
318    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace|TherapyPlaceSchedules|TherapyPlaceSchedule", XmlTokV);
319    return XmlTokV.Len();
320  }
321  PXmlTok TThermalSch::GetTherapyPlaceSchedule(const PXmlTok& AvailableTherapyPlace, const int& TherapyPlaceScheduleN) const {
322    TXmlTokV XmlTokV;
323    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace|TherapyPlaceSchedules|TherapyPlaceSchedule", XmlTokV);
324    return XmlTokV[TherapyPlaceScheduleN];
325  }
326  bool TThermalSch::IsAvailableActivitiesOk(TStr& MsgStr) const {
327    if (AvailableActivitiesXmlDoc.Empty()){
328      MsgStr=GetXmlOut_Error("SetCatalogueAvailableActivities", "Available-Activities doesn't exists.");
329      return false;
330    }
331    int AvailableActivities=TThermalSch::GetAvailableActivities();
332    for (int AvailableActivityN=0; AvailableActivityN<AvailableActivities; AvailableActivityN++){
333      PXmlTok AvailableActivity=TThermalSch::GetAvailableActivity(AvailableActivityN);
334      if (AvailableActivity->IsTag("AvailableActivity")){
335        GetAvailableActivity_Code(AvailableActivity);
336        int ActivitySchedules=GetActivitySchedules(AvailableActivity);
337        for (int ActivityScheduleN=0; ActivityScheduleN<ActivitySchedules; ActivityScheduleN++){
338          PXmlTok ActivitySchedule=GetActivitySchedule(AvailableActivity, ActivityScheduleN);
339          if (ActivitySchedule->IsTag("ActivitySchedule")){
340            GetActivitySchedule_WeekDays(ActivitySchedule);
341            GetActivitySchedule_StartTime(ActivitySchedule);
342            GetActivitySchedule_EndTime(ActivitySchedule);
343            GetActivitySchedule_TherapyPlaceType(ActivitySchedule);
344            GetActivitySchedule_ValidFrom(ActivitySchedule);
345            GetActivitySchedule_ValidTo(ActivitySchedule);
346          }
347        }
348      } else {
349        MsgStr=GetXmlOut_Error("SetCatalogueAvailableActivities", "Invalid Available-Activities.");
350        return false;
351      }
352    }
353    return true;
354  }
355  int TThermalSch::GetAvailableActivities() const {
356    if (AvailableActivitiesXmlDoc.Empty()){return 0;}
357    TXmlTokV XmlTokV;
358    AvailableActivitiesXmlDoc->GetTagTokV("Operation|Parameter|AvailableActivities|AvailableActivity", XmlTokV);
359    return XmlTokV.Len();
360  }
361  PXmlTok TThermalSch::GetAvailableActivity(const int& AvailableActivityN) const {
362    TXmlTokV XmlTokV;
363    AvailableActivitiesXmlDoc->GetTagTokV("Operation|Parameter|AvailableActivities|AvailableActivity", XmlTokV);
364    return XmlTokV[AvailableActivityN];
365  }
366  int TThermalSch::GetActivitySchedules(const PXmlTok& AvailableActivity) const {
367    TXmlTokV XmlTokV;
368    AvailableActivity->GetTagTokV("ActivitySchedules|ActivitySchedule", XmlTokV);
369    return XmlTokV.Len();
370  }
371  PXmlTok TThermalSch::GetActivitySchedule(const PXmlTok& AvailableActivity, const int& ActivityScheduleN) const {
372    TXmlTokV XmlTokV;
373    AvailableActivity->GetTagTokV("ActivitySchedules|ActivitySchedule", XmlTokV);
374    return XmlTokV[ActivityScheduleN];
375  }
376  bool TThermalSch::IsScheduledActivitiesOk(TStr& MsgStr) const {
377    if (ScheduledActivitiesXmlDoc.Empty()){
378      MsgStr=GetXmlOut_Error("SetScheduledActivities", "Scheduled-Activities doesn't exists.");
379      return false;
380    }
381    int ScheduledActivities=TThermalSch::GetScheduledActivities();
382    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
383      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
384      if (ScheduledActivity->IsTag("ScheduledActivity")){
385        GetScheduledActivity_Code(ScheduledActivity);
386        GetScheduledActivity_Code(ScheduledActivity);
387        GetScheduledActivity_PatientATPCode(ScheduledActivity);
388        GetScheduledActivity_Patient(ScheduledActivity);
389        GetScheduledActivity_TherapistCode(ScheduledActivity);
390        GetScheduledActivity_TherapyPlaceCode(ScheduledActivity);
391        GetScheduledActivity_ActivityCode(ScheduledActivity);
392        GetScheduledActivity_StartDateTime(ScheduledActivity);
393        GetScheduledActivity_RepetitionNumber(ScheduledActivity);
394        GetScheduledActivity_StartingPoint(ScheduledActivity);
395        GetScheduledActivity_PatientDuration(ScheduledActivity);
396      } else {
397        MsgStr=GetXmlOut_Error("SetScheduledActivities", "Invalid Scheduled-Activities.");
398        return false;
399      }
400    }
401    return true;
402  }
403  int TThermalSch::GetScheduledActivities() const {
404    if (ScheduledActivitiesXmlDoc.Empty()){return 0;}
405    TXmlTokV XmlTokV;
406    ScheduledActivitiesXmlDoc->GetTagTokV("Operation|Parameter|ScheduledActivities|ScheduledActivity", XmlTokV);
407    return XmlTokV.Len();
408  }
409  PXmlTok TThermalSch::GetScheduledActivity(const int& ScheduledActivityN) const {
410    TXmlTokV XmlTokV;
411    ScheduledActivitiesXmlDoc->GetTagTokV("Operation|Parameter|ScheduledActivities|ScheduledActivity", XmlTokV);
412    return XmlTokV[ScheduledActivityN];
413  }
414  bool TThermalSch::IsHolidaysOk(TStr& MsgStr) const {
415    if (HolidaysXmlDoc.Empty()){
416      MsgStr=GetXmlOut_Error("SetCatalogueHolidays", "Holidays doesn't exists.");
417      return false;
418    }
419    int Holidays=TThermalSch::GetHolidays();
420    for (int HolidayN=0; HolidayN<Holidays; HolidayN++){
421      PXmlTok Holiday=TThermalSch::GetHoliday(HolidayN);
422      if (Holiday->IsTag("Holiday")){
423        TStr Str=GetHoliday_Date(Holiday);
424      } else {
425        MsgStr=GetXmlOut_Error("SetCatalogueHolidays", "Invalid Holidays.");
426        return false;
427      }
428    }
429    return true;
430  }
431  int TThermalSch::GetHolidays() const {
432    if (HolidaysXmlDoc.Empty()){return 0;}
433    TXmlTokV XmlTokV;
434    HolidaysXmlDoc->GetTagTokV("Operation|Parameter|Holidays|Holiday", XmlTokV);
435    return XmlTokV.Len();
436  }
437  PXmlTok TThermalSch::GetHoliday(const int& HolidayN) const {
438    TXmlTokV XmlTokV;
439    HolidaysXmlDoc->GetTagTokV("Operation|Parameter|Holidays|Holiday", XmlTokV);
440    return XmlTokV[HolidayN];
441  }
442  bool TThermalSch::IsMakeScheduleOk(TStr& MsgStr) const {
443    if (MakeScheduleXmlDoc.Empty()){
444      MsgStr=GetXmlOut_Error("MakeSchedule", "Make-Schedule doesn't exists.");
445      return false;
446    }
447    GetMakeSchedule_PatientCode();
448    GetMakeSchedule_PatientGender();
449    GetMakeSchedule_PatientATPCode();
450    int PlanRequests=TThermalSch::GetMakeSchedule_PlanRequests();
451    for (int PlanRequestN=0; PlanRequestN<PlanRequests; PlanRequestN++){
452      PXmlTok PlanRequest=TThermalSch::GetMakeSchedule_PlanRequest(PlanRequestN);
453      if (PlanRequest->IsTag("PlanRequest")){
454        GetMakeSchedule_PlanRequest_ActivityCode(PlanRequest);
455        GetMakeSchedule_PlanRequest_Quantity(PlanRequest);
456        GetMakeSchedule_PlanRequest_DayQuantity(PlanRequest);
457        GetMakeSchedule_PlanRequest_Frequency(PlanRequest);
458        GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest);
459        GetMakeSchedule_PlanRequest_ExcludedActivities_ActivityCode(PlanRequest);
460        GetMakeSchedule_PlanRequest_ExcludedActivities_Time(PlanRequest);
461        GetMakeSchedule_PlanRequest_FamilyActivity(PlanRequest);
462        GetMakeSchedule_PlanRequest_TreatmentDate(PlanRequest);
463        GetMakeSchedule_PlanRequest_DesiredStartTime(PlanRequest);
464        GetMakeSchedule_PlanRequest_DesiredFinishTime(PlanRequest);
465      } else {
466        MsgStr=GetXmlOut_Error("MakeSchedule", "Invalid Make-Schedule.");
467        return false;
468      }
469    }
470    return true;
471  }
472  int TThermalSch::GetMakeSchedule_PlanRequests() const {
473    if (MakeScheduleXmlDoc.Empty()){return 0;}
474    TXmlTokV XmlTokV;
475    MakeScheduleXmlDoc->GetTagTokV("Operation|Parameter|PlanRequests|PlanRequest", XmlTokV);
476    return XmlTokV.Len();
477  }
478  PXmlTok TThermalSch::GetMakeSchedule_PlanRequest(const int& PlanRequestN) const {
479    TXmlTokV XmlTokV;
480    MakeScheduleXmlDoc->GetTagTokV("Operation|Parameter|PlanRequests|PlanRequest", XmlTokV);
481    return XmlTokV[PlanRequestN];
482  }
483  bool TThermalSch::IsCheckScheduleOk(TStr& MsgStr) const {
484    if (CheckScheduleXmlDoc.Empty()){
485      MsgStr=GetXmlOut_Error("CheckSchedule", "Check-Schedule doesn't exists.");
486      return false;
487    }
488    GetCheckSchedule_PatientCode();
489    GetCheckSchedule_PatientGender();
490    GetCheckSchedule_PatientATPCode();
491    GetCheckSchedule_IntRequestedActivityActivityCode();
492    GetCheckSchedule_IntRequestedActivityDayQuantity();
493    GetCheckSchedule_IntRequestedActivityTreatmentDate();
494    GetCheckSchedule_IntRequestedActivityDesiredStartTime();
495    GetCheckSchedule_IntRequestedActivityDesiredFinishTime();
496    return true;
497  }
498  void TThermalSch::SaveCsvToXml(
499   const TStr& DefFNm, const TStr& DatFNm, const TStr& XmlFNm){
500    if (!TFile::Exists(DefFNm)){
501      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
502      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DefFNm+"'."));
503      return;
504    }
505    if (!TFile::Exists(DatFNm)){
506      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
507      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DatFNm+"'."));
508      return;
509    }
510    PSs DefSs=TSs::LoadTxt(ssfCommaSep, DefFNm);
511    TStrV FldNmV;
512    for (int Y=0; Y<DefSs->GetYLen(); Y++){
513      FldNmV.Add(DefSs->GetVal(0, Y));}
514    PSs DatSs=TSs::LoadTxt(ssfCommaSep, DatFNm);
515    TVec<TStrV> RecFldValVV;
516    {for (int Y=0; Y<DatSs->GetYLen(); Y++){
517      TStrV FldValV;
518      for (int X=0; X<DatSs->GetXLen(Y); X++){
519        TStr FldVal=DatSs->GetVal(X, Y);
520        FldValV.Add(FldVal);
521      }
522      RecFldValVV.Add(FldValV);
523    }}
524    TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
525    if ((DefFNm=="URNIKXXG.TXT")&&(DatFNm=="URNIKXX0.TXT")){
526      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
527      fprintf(XmlFId, "<!-- edited with DarMar XML v3.14 by Darko Zupanic & Marko Grobelnik -->\n");
528      fprintf(XmlFId, "<Operation xmlns:xsi=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"D:\\App\\zdr\\te\\ParamIN.xsd\">\n");
529      fprintf(XmlFId, "<OperationName>SetScheduledActivities</OperationName>\n");
530      fprintf(XmlFId, "<Parameter xsi:type=\"tParamInSetScheduledActivities\">\n");
531      fprintf(XmlFId, "<ScheduledActivities>\n");
532      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
533        TStrV& FldValV=RecFldValVV[RecN];
534        fprintf(XmlFId, "<ScheduledActivity>\n");
535        for (int FldN=0; FldN<FldValV.Len(); FldN++){
536          TStr FldNm=FldNmV[FldN];
537          if (FldNm=="SIFRA101"){FldNm="PatientCode";}
538          else if (FldNm=="SIFRA060"){FldNm="ActivityCode";}
539          else if (FldNm=="SIFRA052"){FldNm="TherapyPlaceCode";}
540          else if (FldNm=="DATUM060"){FldNm="Date";}
541          else if (FldNm=="START060"){FldNm="StartTime";}
542          else if (FldNm=="NARP_060"){FldNm="PatientDuration";}
543          else if (FldNm=="NARA_060"){FldNm="TPDuration";}
544          else if (FldNm=="UJEMANJE"){FldNm="Accordance";}
545          fprintf(XmlFId, "<%s>%s</%s>\n",
546           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr(),
547           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr(),
548           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr());
549        }
550        fprintf(XmlFId, "</ScheduledActivity>\n");
551      }
552      fprintf(XmlFId, "</ScheduledActivities>\n");
553      fprintf(XmlFId, "</Parameter>\n");
554      fprintf(XmlFId, "</Operation>\n");
555    } else {
556      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
557      fprintf(XmlFId, "<Data>\n");
558      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
559        TStrV& FldValV=RecFldValVV[RecN];
560        fprintf(XmlFId, "<Record>\n");
561        for (int FldN=0; FldN<FldValV.Len(); FldN++){
562          fprintf(XmlFId, "<Field Name=\"%s\" Value=\"%s\"/>\n",
563           TXmlLx::GetXmlStrFromPlainStr(FldNmV[FldN]).CStr(),
564           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr());
565        }
566        fprintf(XmlFId, "</Record>\n");
567      }
568      fprintf(XmlFId, "</Data>\n");
569    }
570  }
571  void TThermalSch::SaveCsvToXmlParamOut(
572   const TStr& DefFNm, const TStr& DatFNm, const TStr& XmlFNm){
573    if (!TFile::Exists(DefFNm)){
574      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
575      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DefFNm+"'."));
576      return;
577    }
578    if (!TFile::Exists(DatFNm)){
579      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
580      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DatFNm+"'."));
581      return;
582    }
583    PSs DefSs=TSs::LoadTxt(ssfCommaSep, DefFNm);
584    TStrV FldNmV;
585    for (int Y=0; Y<DefSs->GetYLen(); Y++){
586      FldNmV.Add(DefSs->GetVal(0, Y));}
587    PSs DatSs=TSs::LoadTxt(ssfCommaSep, DatFNm);
588    TVec<TStrV> RecFldValVV;
589    {for (int Y=0; Y<DatSs->GetYLen(); Y++){
590      TStrV FldValV;
591      for (int X=0; X<DatSs->GetXLen(Y); X++){
592        TStr FldVal=DatSs->GetVal(X, Y);
593        FldValV.Add(FldVal);
594      }
595      RecFldValVV.Add(FldValV);
596    }}
597    TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
598    if ((DefFNm=="URNIKXXG.TXT")&&(DatFNm=="URNIKXX0.TXT")){
599      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
600      fprintf(XmlFId, "<ParamOut>\n");
601      fprintf(XmlFId, "<OperationName>");
602      fprintf(XmlFId, "MakeSchedule");
603      fprintf(XmlFId, "</OperationName>\n");
604      fprintf(XmlFId, "<Success>Ok</Success>\n");
605      fprintf(XmlFId, "<Data>\n");
606      fprintf(XmlFId, "<Operation xmlns:xsi=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"D:\\App\\zdr\\te\\ParamIN.xsd\">\n");
607      fprintf(XmlFId, "<OperationName>SetScheduledActivities</OperationName>\n");
608      fprintf(XmlFId, "<Parameter xsi:type=\"tParamInSetScheduledActivities\">\n");
609      fprintf(XmlFId, "<ScheduledActivities>\n");
610      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
611        TStrV& FldValV=RecFldValVV[RecN];
612        fprintf(XmlFId, "<ScheduledActivity>\n");
613        for (int FldN=0; FldN<FldValV.Len(); FldN++){
614          TStr FldNm=FldNmV[FldN];
615          if (FldNm=="SIFRA101"){FldNm="PatientCode";}
616          else if (FldNm=="SIFRA060"){FldNm="ActivityCode";}
617          else if (FldNm=="SIFRA052"){FldNm="TherapyPlaceCode";}
618          else if (FldNm=="DATUM060"){FldNm="Date";}
619          else if (FldNm=="START060"){FldNm="StartTime";}
620          else if (FldNm=="NARP_060"){FldNm="PatientDuration";}
621          else if (FldNm=="NARA_060"){FldNm="TPDuration";}
622          else if (FldNm=="UJEMANJE"){FldNm="Accordance";}
623          fprintf(XmlFId, "<%s>%s</%s>\n",
624           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr(),
625           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr(),
626           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr());
627        }
628        fprintf(XmlFId, "</ScheduledActivity>\n");
629      }
630      fprintf(XmlFId, "</ScheduledActivities>\n");
631      fprintf(XmlFId, "</Parameter>\n");
632      fprintf(XmlFId, "</Operation>\n");
633      fprintf(XmlFId, "</Data>\n");
634      fprintf(XmlFId, "</ParamOut>\n");
635    } else {
636      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
637      fprintf(XmlFId, "<Data>\n");
638      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
639        TStrV& FldValV=RecFldValVV[RecN];
640        fprintf(XmlFId, "<Record>\n");
641        for (int FldN=0; FldN<FldValV.Len(); FldN++){
642          fprintf(XmlFId, "<Field Name=\"%s\" Value=\"%s\"/>\n",
643           TXmlLx::GetXmlStrFromPlainStr(FldNmV[FldN]).CStr(),
644           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr());
645        }
646        fprintf(XmlFId, "</Record>\n");
647      }
648      fprintf(XmlFId, "</Data>\n");
649    }
650  }
651  void TThermalSch::SaveOldCsv() const {
652    SaveOldCsv_KatalogZdrDelavcev();
653    SaveOldCsv_KatalogAparatov();
654    SaveOldCsv_KatalogAktivnosti();
655    SaveOldCsv_UrnikZaTerapevte();
656    SaveOldCsv_UrnikZaAparate();
657    SaveOldCsv_UrnikAktivnosti();
658    SaveOldCsv_MozniTerminiVDnevu();
659    SaveOldCsv_Prazniki();
660    SaveOldCsv_PredpisaneTerapije();
661    SaveOldCsv_PlaniraneAktivnosti();
662    SaveOldCsv_UrnikXX();
663  }
664  void TThermalSch::SaveOldCsv_KatalogZdrDelavcev() const {
665    TFOut DefSOut("KA051ZDG.TXT"); FILE* fDef=DefSOut.GetFileId();
666    SaveFldDef(fDef, "PRIM_051");
667    SaveFldDef(fDef, "SSIF_S23");
668    SaveFldDef(fDef, "SIFRA039");
669    SaveFldDef(fDef, "STAT_051");
670    SaveFldDef(fDef, "SIFRA051");
671    SaveFldDef(fDef, "POZ__051");
672    SaveFldDef(fDef, "EMSO_051");
673    SaveFldDef(fDef, "DATUMIPL");
674    SaveFldDef(fDef, "TIP__051");
675    TFOut DatSOut("KA051ZD0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
676  }
677  void TThermalSch::SaveOldCsv_KatalogAparatov() const {
678    TFOut DefSOut("KA052APG.TXT"); FILE* fDef=DefSOut.GetFileId();
679    SaveFldDef(fDef, "SIFRA052"); 
680    SaveFldDef(fDef, "SSIF_T05"); 
681    SaveFldDef(fDef, "OPIS_052"); 
682    SaveFldDef(fDef, "SSIF_NE4"); 
683    SaveFldDef(fDef, "ST_P_052"); 
684    SaveFldDef(fDef, "SIFR1052"); 
685    SaveFldDef(fDef, "PODAL052"); 
686    SaveFldDef(fDef, "TR_DO052"); 
687    SaveFldDef(fDef, "RAZD_052"); 
688    SaveFldDef(fDef, "SPOL_052"); 
689    SaveFldDef(fDef, "ALTERSCH"); 
690    SaveFldDef(fDef, "FAMILSCH"); 
691    TFOut DatSOut("KA052AP0.TXT"); FILE* fDat=DatSOut.GetFileId();
692    int TherapyPlaces=TThermalSch::GetTherapyPlaces();
693    for (int TherapyPlaceN=0; TherapyPlaceN<TherapyPlaces; TherapyPlaceN++){
694      PXmlTok TherapyPlace=TThermalSch::GetTherapyPlace(TherapyPlaceN);
695      SaveFldVal(fDat, GetTherapyPlace_Code(TherapyPlace)); 
696      SaveFldVal(fDat, GetTherapyPlace_Type(TherapyPlace)); 
697      SaveFldVal(fDat, GetTherapyPlace_Location(TherapyPlace)); 
698      SaveFldVal(fDat, GetTherapyPlace_TherapistType(TherapyPlace)); 
699      SaveFldVal(fDat, GetTherapyPlace_Capacity(TherapyPlace)); 
700      SaveFldVal(fDat, ""); 
701      SaveFldVal(fDat, ""); 
702      SaveFldVal(fDat, ""); 
703      SaveFldVal(fDat, GetTherapyPlace_Distance(TherapyPlace)); 
704      SaveFldVal(fDat, GetTherapyPlace_Gender(TherapyPlace)); 
705      SaveFldVal(fDat, GetTherapyPlace_AlternateScheduling(TherapyPlace));
706      SaveFldVal(fDat, GetTherapyPlace_FamilyScheduling(TherapyPlace), true);
707    }
708  }
709  void TThermalSch::SaveOldCsv_KatalogAktivnosti() const {
710    TFOut DefSOut("KA060AOG.TXT"); FILE* fDef=DefSOut.GetFileId();
711    SaveFldDef(fDef, "SIFRA060"); 
712    SaveFldDef(fDef, "SSIF_T05"); 
713    SaveFldDef(fDef, "TRAJ_060"); 
714    SaveFldDef(fDef, "STMAX060"); 
715    SaveFldDef(fDef, "STOPT060"); 
716    SaveFldDef(fDef, "RAZ1_060"); 
717    SaveFldDef(fDef, "RAZ2_060"); 
718    SaveFldDef(fDef, "RAZ3_060"); 
719    SaveFldDef(fDef, "NARP_060"); 
720    SaveFldDef(fDef, "NARA_060"); 
721    SaveFldDef(fDef, "SSIF_T01"); 
722    SaveFldDef(fDef, "SS_T2_T3"); 
723    SaveFldDef(fDef, "TEZA_060"); 
724    SaveFldDef(fDef, "SUHA_060"); 
725    SaveFldDef(fDef, "PRIORITY"); 
726    TFOut DatSOut("KA060AO0.TXT"); FILE* fDat=DatSOut.GetFileId();
727    int Activities=TThermalSch::GetActivities();
728    for (int ActivityN=0; ActivityN<Activities; ActivityN++){
729      PXmlTok Activity=TThermalSch::GetActivity(ActivityN);
730      SaveFldVal(fDat, GetActivity_Code(Activity)); 
731      SaveFldVal(fDat, GetActivity_Type(Activity)); 
732      SaveFldVal(fDat, GetActivity_Duration(Activity)); 
733      SaveFldVal(fDat, ""); 
734      SaveFldVal(fDat, ""); 
735      SaveFldVal(fDat, GetActivity_TherapistDurationPreparation(Activity)); 
736      SaveFldVal(fDat, GetActivity_TherapistDurationExecution(Activity)); 
737      SaveFldVal(fDat, GetActivity_TherapistDurationAdditionalTime(Activity)); 
738      SaveFldVal(fDat, GetActivity_PatientDuration(Activity)); 
739      SaveFldVal(fDat, GetActivity_TPDuration(Activity)); 
740      SaveFldVal(fDat, ""); 
741      SaveFldVal(fDat, ""); 
742      SaveFldVal(fDat, GetActivity_Weariness(Activity)); 
743      SaveFldVal(fDat, GetActivity_Dry(Activity)); 
744      SaveFldVal(fDat, GetActivity_Priority(Activity), true); 
745    }
746  }
747  void TThermalSch::SaveOldCsv_UrnikZaTerapevte() const {
748    TFOut DefSOut("PR350UIG.TXT"); FILE* fDef=DefSOut.GetFileId();
749    SaveFldDef(fDef, "TIP__051");
750    SaveFldDef(fDef, "DAN__350");
751    SaveFldDef(fDef, "STEV_350");
752    SaveFldDef(fDef, "DATOD350");
753    SaveFldDef(fDef, "DATDO350");
754    TFOut DatSOut("PR350UI0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
755  }
756  void TThermalSch::SaveOldCsv_UrnikZaAparate() const {
757    TFOut DefSOut("PR351UPG.TXT"); FILE* fDef=DefSOut.GetFileId();
758    SaveFldDef(fDef, "SIFRA052"); 
759    SaveFldDef(fDef, "AKTIV351"); 
760    SaveFldDef(fDef, "DATOD351"); 
761    SaveFldDef(fDef, "DATDO351"); 
762    SaveFldDef(fDef, "CASOD351"); 
763    SaveFldDef(fDef, "CASDO351"); 
764    SaveFldDef(fDef, "DAN"); 
765    TFOut DatSOut("PR351UP0.TXT"); FILE* fDat=DatSOut.GetFileId();
766    int AvailableTherapyPlaces=TThermalSch::GetAvailableTherapyPlaces();
767    for (int AvailableTherapyPlaceN=0; AvailableTherapyPlaceN<AvailableTherapyPlaces; AvailableTherapyPlaceN++){
768      PXmlTok AvailableTherapyPlace=TThermalSch::GetAvailableTherapyPlace(AvailableTherapyPlaceN);
769      int TherapyPlaceSchedules=GetTherapyPlaceSchedules(AvailableTherapyPlace);
770      for (int TherapyPlaceScheduleN=0; TherapyPlaceScheduleN<TherapyPlaceSchedules; TherapyPlaceScheduleN++){
771        PXmlTok TherapyPlaceSchedule=GetTherapyPlaceSchedule(AvailableTherapyPlace, TherapyPlaceScheduleN);
772        TStrV DayV=GetTherapyPlaceSchedule_WeekDays(TherapyPlaceSchedule);
773        for (int DayN=0; DayN<DayV.Len(); DayN++){
774          SaveFldVal(fDat, GetAvailableTherapyPlace_Code(AvailableTherapyPlace)); 
775          SaveFldVal(fDat, "D"); 
776          SaveFldVal(fDat, GetTherapyPlaceSchedule_ValidFrom(TherapyPlaceSchedule)); 
777          SaveFldVal(fDat, GetTherapyPlaceSchedule_ValidTo(TherapyPlaceSchedule)); 
778          SaveFldVal(fDat, GetTherapyPlaceSchedule_OpenFrom(TherapyPlaceSchedule)); 
779          SaveFldVal(fDat, GetTherapyPlaceSchedule_OpenTill(TherapyPlaceSchedule)); 
780          SaveFldVal(fDat, DayV[DayN], true); 
781        }
782      }
783    }
784  }
785  void TThermalSch::SaveOldCsv_UrnikAktivnosti() const {
786    TFOut DefSOut("PR352UAG.TXT"); FILE* fDef=DefSOut.GetFileId();
787    SaveFldDef(fDef, "SIFRA060"); 
788    SaveFldDef(fDef, "DAN__352"); 
789    SaveFldDef(fDef, "SIFRA352"); 
790    SaveFldDef(fDef, "DATOD352"); 
791    SaveFldDef(fDef, "DATDO352"); 
792    SaveFldDef(fDef, "CASOD352"); 
793    SaveFldDef(fDef, "CASDO352"); 
794    SaveFldDef(fDef, "SIFRA052"); 
795    SaveFldDef(fDef, "SPOL052"); 
796    TFOut DatSOut("PR352UA0.TXT"); FILE* fDat=DatSOut.GetFileId();
797    int AvailableActivities=TThermalSch::GetAvailableActivities();
798    for (int AvailableActivityN=0; AvailableActivityN<AvailableActivities; AvailableActivityN++){
799      PXmlTok AvailableActivity=TThermalSch::GetAvailableActivity(AvailableActivityN);
800      int ActivitySchedules=GetActivitySchedules(AvailableActivity);
801      for (int ActivityScheduleN=0; ActivityScheduleN<ActivitySchedules; ActivityScheduleN++){
802        PXmlTok ActivitySchedule=GetActivitySchedule(AvailableActivity, ActivityScheduleN);
803        TStrV DayV=GetActivitySchedule_WeekDays(ActivitySchedule);
804        for (int DayN=0; DayN<DayV.Len(); DayN++){
805          SaveFldVal(fDat, GetAvailableActivity_Code(AvailableActivity)); 
806          SaveFldVal(fDat, DayV[DayN]); 
807          SaveFldVal(fDat, ""); 
808          SaveFldVal(fDat, GetActivitySchedule_ValidFrom(ActivitySchedule)); 
809          SaveFldVal(fDat, GetActivitySchedule_ValidTo(ActivitySchedule)); 
810          SaveFldVal(fDat, GetActivitySchedule_StartTime(ActivitySchedule)); 
811          SaveFldVal(fDat, GetActivitySchedule_EndTime(ActivitySchedule)); 
812          SaveFldVal(fDat, GetActivitySchedule_TherapyPlaceType(ActivitySchedule)); 
813          SaveFldVal(fDat, GetActivitySchedule_Gender(ActivitySchedule), true);  
814        }
815      }
816    }
817  }
818  void TThermalSch::SaveOldCsv_MozniTerminiVDnevu() const {
819    TFOut DefSOut("PR352URG.TXT"); FILE* fDef=DefSOut.GetFileId();
820    SaveFldDef(fDef, "SIFRA352");
821    SaveFldDef(fDef, "ZAPST352");
822    SaveFldDef(fDef, "URAOD352");
823    SaveFldDef(fDef, "URADO352");
824    TFOut DatSOut("PR352UR0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
825  }
826  void TThermalSch::SaveOldCsv_Prazniki() const {
827    TFOut DefSOut("PRAZNIKG.TXT"); FILE* fDef=DefSOut.GetFileId();
828    SaveFldDef(fDef, "DATUM000");
829    TFOut DatSOut("PRAZNIK0.TXT"); FILE* fDat=DatSOut.GetFileId();
830    int Holidays=TThermalSch::GetHolidays();
831    for (int HolidayN=0; HolidayN<Holidays; HolidayN++){
832      PXmlTok Holiday=TThermalSch::GetHoliday(HolidayN);
833      SaveFldVal(fDat, GetHoliday_Date(Holiday), true); 
834    }
835  }
836  void TThermalSch::SaveOldCsv_PredpisaneTerapije() const {
837    TFOut DefSOut("PR300NSG.TXT"); FILE* fDef=DefSOut.GetFileId();
838    SaveFldDef(fDef, "SIFRA210"); 
839    SaveFldDef(fDef, "SIFRA101"); 
840    SaveFldDef(fDef, "SIFRA060"); 
841    SaveFldDef(fDef, "ZAPST300"); 
842    SaveFldDef(fDef, "STPON300"); 
843    SaveFldDef(fDef, "S_P_D300"); 
844    SaveFldDef(fDef, "SSIF_T11"); 
845    SaveFldDef(fDef, "SIFR1060"); 
846    SaveFldDef(fDef, "SIFR2060"); 
847    SaveFldDef(fDef, "URAOD300"); 
848    SaveFldDef(fDef, "URADO300"); 
849    SaveFldDef(fDef, "DATOD300"); 
850    SaveFldDef(fDef, "STAT_300"); 
851    SaveFldDef(fDef, "PLAN_300"); 
852    SaveFldDef(fDef, "DATUMIPL"); 
853    SaveFldDef(fDef, "OPER_300"); 
854    SaveFldDef(fDef, "SIFRA051"); 
855    SaveFldDef(fDef, "SPOL_300"); 
856    SaveFldDef(fDef, "DRUZINA"); 
857    SaveFldDef(fDef, "ATTRNAME"); 
858    SaveFldDef(fDef, "EXCLACT"); 
859    SaveFldDef(fDef, "EXCLTIME"); 
860    TFOut DatSOut("PR300NS0.TXT"); FILE* fDat=DatSOut.GetFileId();
861    int PlanRequests=TThermalSch::GetMakeSchedule_PlanRequests();
862    for (int PlanRequestN=0; PlanRequestN<PlanRequests; PlanRequestN++){
863      PXmlTok PlanRequest=TThermalSch::GetMakeSchedule_PlanRequest(PlanRequestN);
864      SaveFldVal(fDat, GetMakeSchedule_PatientATPCode()); 
865      SaveFldVal(fDat, GetMakeSchedule_PatientCode()); 
866      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_ActivityCode(PlanRequest)); 
867      SaveFldVal(fDat, ""); 
868      TStr AlternatingActivityCode=GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest);
869      TStr QuantityStr=GetMakeSchedule_PlanRequest_Quantity(PlanRequest);
870      if (AlternatingActivityCode.Empty()){
871        SaveFldVal(fDat, GetMakeSchedule_PlanRequest_Quantity(PlanRequest)); 
872      } else {
873        int Quantity=2*QuantityStr.GetInt(0);
874        SaveFldVal(fDat, TInt::GetStr(Quantity)); 
875      }
876      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DayQuantity(PlanRequest)); 
877      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_Frequency(PlanRequest)); 
878      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest)); 
879      SaveFldVal(fDat, ""); 
880      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DesiredStartTime(PlanRequest)); 
881      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DesiredFinishTime(PlanRequest)); 
882      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_TreatmentDate(PlanRequest)); 
883      SaveFldVal(fDat, ""); 
884      SaveFldVal(fDat, ""); 
885      SaveFldVal(fDat, ""); 
886      SaveFldVal(fDat, ""); 
887      SaveFldVal(fDat, ""); 
888      SaveFldVal(fDat, GetMakeSchedule_PatientGender()); 
889      SaveFldVal(fDat, GetMakeSchedule_PatientFamily()); 
890      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_AttrNm(PlanRequest)); 
891      SaveFldValV(fDat, GetMakeSchedule_PlanRequest_ExcludedActivities_ActivityCode(PlanRequest)); 
892      SaveFldValV(fDat, GetMakeSchedule_PlanRequest_ExcludedActivities_Time(PlanRequest), true); 
893    }
894  }
895  void TThermalSch::SaveOldCsv_PlaniraneAktivnosti() const {
896    TFOut DefSOut("PR360AKG.TXT"); FILE* fDef=DefSOut.GetFileId();
897    SaveFldDef(fDef, "SIFRA360"); 
898    SaveFldDef(fDef, "SIFRA210"); 
899    SaveFldDef(fDef, "SIFRA101"); 
900    SaveFldDef(fDef, "SIFRA051"); 
901    SaveFldDef(fDef, "SIFRA052"); 
902    SaveFldDef(fDef, "SIFRA060"); 
903    SaveFldDef(fDef, "DATUM360"); 
904    SaveFldDef(fDef, "STAT_360"); 
905    SaveFldDef(fDef, "Z_ST_360"); 
906    SaveFldDef(fDef, "C_OD_360"); 
907    SaveFldDef(fDef, "TRAJ_060"); 
908    SaveFldDef(fDef, "URA__360"); 
909    SaveFldDef(fDef, "SSIF_T07"); 
910    TFOut DatSOut("PR360AK0.TXT"); FILE* fDat=DatSOut.GetFileId();
911    int ScheduledActivities=TThermalSch::GetScheduledActivities();
912    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
913      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
914      SaveFldVal(fDat, GetScheduledActivity_Code(ScheduledActivity)); 
915      SaveFldVal(fDat, GetScheduledActivity_PatientATPCode(ScheduledActivity)); 
916      SaveFldVal(fDat, GetScheduledActivity_Patient(ScheduledActivity)); 
917      SaveFldVal(fDat, GetScheduledActivity_TherapistCode(ScheduledActivity)); 
918      SaveFldVal(fDat, GetScheduledActivity_TherapyPlaceCode(ScheduledActivity)); 
919      SaveFldVal(fDat, GetScheduledActivity_ActivityCode(ScheduledActivity)); 
920      SaveFldVal(fDat, GetScheduledActivity_StartDateTime(ScheduledActivity)); 
921      SaveFldVal(fDat, ""); 
922      SaveFldVal(fDat, GetScheduledActivity_RepetitionNumber(ScheduledActivity)); 
923      SaveFldVal(fDat, GetScheduledActivity_StartingPoint(ScheduledActivity)); 
924      SaveFldVal(fDat, GetScheduledActivity_PatientDuration(ScheduledActivity)); 
925      SaveFldVal(fDat, GetScheduledActivity_StartDateTime(ScheduledActivity)); 
926      SaveFldVal(fDat, "", true); 
927    }
928  }
929  void TThermalSch::SaveOldCsv_UrnikXX() const {
930    TFOut DefSOut("URNIKXXG.TXT"); FILE* fDef=DefSOut.GetFileId();
931    SaveFldDef(fDef, "SIFRA101");
932    SaveFldDef(fDef, "SIFRA060");
933    SaveFldDef(fDef, "SIFRA052");
934    SaveFldDef(fDef, "DATUM060");
935    SaveFldDef(fDef, "START060");
936    SaveFldDef(fDef, "NARP_060");
937    SaveFldDef(fDef, "NARA_060");
938    SaveFldDef(fDef, "UJEMANJE");
939    TFOut DatSOut("URNIKXX0.TXT"); FILE* fDat=DatSOut.GetFileId();
940    int ScheduledActivities=TThermalSch::GetScheduledActivities();
941    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
942      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
943      SaveFldVal(fDat, GetScheduledActivity_PatientCode(ScheduledActivity)); 
944      SaveFldVal(fDat, GetScheduledActivity_ActivityCode(ScheduledActivity)); 
945      SaveFldVal(fDat, GetScheduledActivity_TherapyPlaceCode(ScheduledActivity)); 
946      SaveFldVal(fDat, GetScheduledActivity_Date(ScheduledActivity)); 
947      SaveFldVal(fDat, GetScheduledActivity_StartTime(ScheduledActivity)); 
948      SaveFldVal(fDat, GetScheduledActivity_PatientDuration(ScheduledActivity)); 
949      SaveFldVal(fDat, GetScheduledActivity_TPDuration(ScheduledActivity)); 
950      SaveFldVal(fDat, GetScheduledActivity_Accordance(ScheduledActivity), true); 
951    }
952  }
953  PThermalSch TThermalSch::DllThermalSch=TThermalSch::New();
954  char* TThermalSch::DllExeCmFromXmlFile(char* FNm, char* FPath){
955    TStr MsgXmlStr=DllThermalSch->ExeCmFromXmlFile(FNm, FPath);
956    return MsgXmlStr.GetCStr();
957  }
958  char* TThermalSch::DllExeCmFromXmlStr(char* XmlStr){
959    TStr MsgXmlStr=DllThermalSch->ExeCmFromXmlStr(XmlStr);
960    return MsgXmlStr.GetCStr();
961  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</h3>
            <pre><code>1  #ifdef GLib_LINUX
2  extern "C" {
3  	#include <sys/mman.h>
4  }
5  #endif
6  const int TCs::MxMask=0x0FFFFFFF;
7  TCs TCs::GetCsFromBf(char* Bf, const int& BfL){
8    TCs Cs;
9    for (int BfC=0; BfC<BfL; BfC++){Cs+=Bf[BfC];}
10    return Cs;
11  }
12  TStr TSBase::GetSNm() const {
13    return TStr(SNm.CStr());
14  }
15  TSIn::TSIn(const TStr& Str) : TSBase(Str.CStr()), FastMode(false){}
16  void TSIn::LoadCs(){
17    TCs CurCs=Cs; TCs TestCs;
18    Cs+=GetBf(&TestCs, sizeof(TestCs));
19    EAssertR(CurCs==TestCs, "Invalid checksum reading '"+GetSNm()+"'.");
20  }
21  void TSIn::Load(char*& CStr){
22    char Ch; Load(Ch);
23    int CStrLen=int(Ch);
24    EAssertR(CStrLen>=0, "Error reading stream '"+GetSNm()+"'.");
25    CStr=new char[CStrLen+1];
26    if (CStrLen>0){Cs+=GetBf(CStr, CStrLen);}
27    CStr[CStrLen]=TCh::NullCh;
28  }
29  bool TSIn::GetNextLn(TStr& LnStr){
30    TChA LnChA;
31    const bool IsNext=GetNextLn(LnChA);
32    LnStr=LnChA;
33    return IsNext;
34  }
35  bool TSIn::GetNextLn(TChA& LnChA){
36    LnChA.Clr();
37    while (!Eof()){
38      const char Ch=GetCh();
39      if (Ch=='\n'){return true;}
40      if (Ch=='\r' && PeekCh()=='\n'){GetCh(); return true;}
41      LnChA.AddCh(Ch);
42    }
43    return !LnChA.Empty();
44  }
45  const PSIn TSIn::StdIn=PSIn(new TStdIn());
46  TStdIn::TStdIn(): TSBase("Standard input"), TSIn("Standard input") {}
47  TSOut::TSOut(const TStr& Str):
48    TSBase(Str.CStr()), MxLnLen(-1), LnLen(0){}
49  int TSOut::UpdateLnLen(const int& StrLen, const bool& ForceInLn){
50    int Cs=0;
51    if (MxLnLen!=-1){
52      if ((!ForceInLn)&&(LnLen+StrLen>MxLnLen)){Cs+=PutLn();}
53      LnLen+=StrLen;
54    }
55    return Cs;
56  }
57  int TSOut::PutMem(const TMem& Mem){
58    return PutBf(Mem(), Mem.Len());
59  }
60  int TSOut::PutCh(const char& Ch, const int& Chs){
61    int Cs=0;
62    for (int ChN=0; ChN<Chs; ChN++){Cs+=PutCh(Ch);}
63    return Cs;
64  }
65  int TSOut::PutBool(const bool& Bool){
66    return PutStr(TBool::GetStr(Bool));
67  }
68  int TSOut::PutInt(const int& Int){
69    return PutStr(TInt::GetStr(Int));
70  }
71  int TSOut::PutInt(const int& Int, const char* FmtStr){
72    return PutStr(TInt::GetStr(Int, FmtStr));
73  }
74  int TSOut::PutUInt(const uint& UInt){
75    return PutStr(TUInt::GetStr(UInt));
76  }
77  int TSOut::PutUInt(const uint& UInt, const char* FmtStr){
78    return PutStr(TUInt::GetStr(UInt, FmtStr));
79  }
80  int TSOut::PutFlt(const double& Flt){
81    return PutStr(TFlt::GetStr(Flt));
82  }
83  int TSOut::PutFlt(const double& Flt, const char* FmtStr){
84    return PutStr(TFlt::GetStr(Flt, FmtStr));
85  }
86  int TSOut::PutStr(const char* CStr){
87    int Cs=UpdateLnLen(int(strlen(CStr)));
88    return Cs+PutBf(CStr, int(strlen(CStr)));
89  }
90  int TSOut::PutStr(const TChA& ChA){
91    int Cs=UpdateLnLen(ChA.Len());
92    return Cs+PutBf(ChA.CStr(), ChA.Len());
93  }
94  int TSOut::PutStr(const TStr& Str, const char* FmtStr){
95    return PutStr(TStr::GetStr(Str, FmtStr));
96  }
97  int TSOut::PutStr(const TStr& Str, const bool& ForceInLn){
98    int Cs=UpdateLnLen(Str.Len(), ForceInLn);
99    return Cs+PutBf(Str.CStr(), Str.Len());
100  }
101  int TSOut::PutStrFmt(const char *FmtStr, ...){
102    char Bf[10*1024];
103    va_list valist;
104    va_start(valist, FmtStr);
105    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
106    va_end(valist);
107    return RetVal!=-1 ? PutStr(TStr(Bf)) : 0;	
108  }
109  int TSOut::PutStrFmtLn(const char *FmtStr, ...){
110    char Bf[10*1024];
111    va_list valist;
112    va_start(valist, FmtStr);
113    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
114    va_end(valist);
115    return RetVal!=-1 ? PutStrLn(TStr(Bf)) : PutLn();	
116  }
117  int TSOut::PutIndent(const int& IndentLev){
118    return PutCh(' ', IndentLev*2);
119  }
120  int TSOut::PutLn(const int& Lns){
121    LnLen=0; int Cs=0;
122    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh('\n');}
123    return Cs;
124  }
125  int TSOut::PutDosLn(const int& Lns){
126    LnLen=0; int Cs=0;
127    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh(TCh::CrCh)+PutCh(TCh::LfCh);}
128    return Cs;
129  }
130  int TSOut::PutSep(const int& NextStrLen){
131    int Cs=0;
132    if (MxLnLen==-1){
133      Cs+=PutCh(' ');
134    } else {
135      if (LnLen>0){
136        if (LnLen+1+NextStrLen>MxLnLen){Cs+=PutLn();} else {Cs+=PutCh(' ');}
137      }
138    }
139    return Cs;
140  }
141  int TSOut::PutSepLn(const int& Lns){
142    int Cs=0;
143    if (LnLen>0){Cs+=PutLn();}
144    Cs+=PutLn(Lns);
145    return Cs;
146  }
147  void TSOut::Save(const char* CStr){
148    int CStrLen=int(strlen(CStr));
149    EAssertR(CStrLen<=127, "Error writting stream '"+GetSNm()+"'.");
150    Save(char(CStrLen));
151    if (CStrLen>0){Cs+=PutBf(CStr, CStrLen);}
152  }
153  void TSOut::Save(TSIn& SIn, const TSize& BfL){
154    Fail;
155    if (BfL==0){ 
156      while (!SIn.Eof()){Save(SIn.GetCh());}
157    } else {
158      for (TSize BfC=0; BfC<BfL; BfC++){Save(SIn.GetCh());}
159    }
160  }
161  TSOut& TSOut::operator<<(TSIn& SIn) {
162    while (!SIn.Eof())
163      operator<<((char)SIn.GetCh());
164    return *this;
165  }
166  const PSOut TSOut::StdOut=PSOut(new TStdOut());
167  TStdOut::TStdOut(): TSBase(TSStr("Standard output")), TSOut("Standard output"){}
168  int TStdIn::GetBf(const void* LBf, const TSize& LBfL){
169    int LBfS=0;
170    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
171      LBfS+=(((char*)LBf)[LBfC]=GetCh());}
172    return LBfS;
173  }
174  bool TStdIn::GetNextLnBf(TChA& LnChA){
175    FailR(TStr::Fmt("TStdIn::GetNextLnBf: not implemented").CStr());
176    return false;
177  }
178  int TStdOut::PutBf(const void* LBf, const TSize& LBfL){
179    int LBfS=0;
180    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
181      LBfS+=PutCh(((char*)LBf)[LBfC]);}
182    return LBfS;
183  }
184  const int TFIn::MxBfL=16*1024;
185  void TFIn::SetFPos(const int& FPos) const {
186    EAssertR(
187     fseek(FileId, FPos, SEEK_SET)==0,
188     "Error seeking into file '"+GetSNm()+"'.");
189  }
190  int TFIn::GetFPos() const {
191    const int FPos=(int)ftell(FileId);
192    EAssertR(FPos!=-1, "Error seeking into file '"+GetSNm()+"'.");
193    return FPos;
194  }
195  int TFIn::GetFLen() const {
196    const int FPos=GetFPos();
197    EAssertR(
198     fseek(FileId, 0, SEEK_END)==0,
199     "Error seeking into file '"+GetSNm()+"'.");
200    const int FLen=GetFPos(); SetFPos(FPos);
201    return FLen;
202  }
203  void TFIn::FillBf(){
204    EAssertR(
205     (BfC==BfL)&&((BfL==-1)||(BfL==MxBfL)),
206     "Error reading file '"+GetSNm()+"'.");
207    BfL=int(fread(Bf, 1, MxBfL, FileId));
208    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
209    BfC=0;
210  }
211  TFIn::TFIn(const TStr& FNm):
212    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
213    EAssertR(!FNm.Empty(), "Empty file-name.");
214    FileId=fopen(FNm.CStr(), "rb");
215    EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
216    Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();
217  }
218  TFIn::TFIn(const TStr& FNm, bool& OpenedP):
219    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
220    EAssertR(!FNm.Empty(), "Empty file-name.");
221    FileId=fopen(FNm.CStr(), "rb");
222    OpenedP=(FileId!=NULL);
223    if (OpenedP){
224      Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();}
225  }
226  PSIn TFIn::New(const TStr& FNm){
227    try {
228      return PSIn(new TFIn(FNm));
229    } catch (PExcept& Except) {
230      printf("*** Exception: %s\n", Except->GetMsgStr().CStr());
231      EFailR(Except->GetMsgStr());
232    }
233    return PSIn(new TFIn(FNm));
234  }
235  PSIn TFIn::New(const TStr& FNm, bool& OpenedP){
236    return PSIn(new TFIn(FNm, OpenedP));
237  }
238  TFIn::~TFIn(){
239    if (FileId!=NULL){
240      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
241    if (Bf!=NULL){delete[] Bf;}
242  }
243  int TFIn::GetBf(const void* LBf, const TSize& LBfL){
244    int LBfS=0;
245    if (TSize(BfC+LBfL)>TSize(BfL)){
246      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
247        if (BfC==BfL){FillBf();}
248        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
249    } else {
250      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
251        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
252    }
253    return LBfS;
254  }
255  bool TFIn::GetNextLnBf(TChA& LnChA) {
256    int Status;
257    int BfN;        
258    int BfP;        
259    bool CrEnd;     
260    LnChA.Clr();
261    CrEnd = false;
262    do {
263      if (BfC >= BfL) {
264        BfP = 0;
265      } else {
266        BfP = BfC;
267      }
268      Status = FindEol(BfN,CrEnd);
269      if (Status >= 0) {
270        if (BfN-BfP > 0) {
271          LnChA.AddBf(&Bf[BfP],BfN-BfP);
272        }
273        if (Status == 1) {
274          return true;
275        }
276      }
277    } while (Status == 0);
278    return !LnChA.Empty();
279  }
280  int TFIn::FindEol(int& BfN, bool& CrEnd) {
281    char Ch;
282    if (BfC >= BfL) {
283      if (Eof()) {
284        return -1;
285      }
286      if (CrEnd && Bf[BfC]=='\n') {
287        BfC++;
288        BfN = BfC-1;
289        return 1;
290      }
291    }
292    CrEnd = false;
293    while (BfC < BfL) {
294      Ch = Bf[BfC++];
295      if (Ch=='\n') {
296        BfN = BfC-1;
297        return 1;
298      }
299      if (Ch=='\r') {
300        if (BfC == BfL) {
301          CrEnd = true;
302          BfN = BfC-1;
303          return 0;
304        } else if (Bf[BfC]=='\n') {
305          BfC++;
306          BfN = BfC-2;
307          return 1;
308        }
309      }
310    }
311    BfN = BfC;
312    return 0;
313  }
314  const TSize TFOut::MxBfL=16*1024;;
315  void TFOut::FlushBf(){
316    EAssertR(
317     fwrite(Bf, 1, BfL, FileId)==BfL,
318     "Error writting to the file '"+GetSNm()+"'.");
319    BfL=0;
320  }
321  TFOut::TFOut(const TStr& FNm, const bool& Append):
322    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
323    if (FNm.GetUc()=="CON"){
324      FileId=stdout;
325    } else {
326      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
327      else {FileId=fopen(FNm.CStr(), "w+b");}
328      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
329      Bf=new char[MxBfL]; BfL=0;
330    }
331  }
332  TFOut::TFOut(const TStr& FNm, const bool& Append, bool& OpenedP):
333    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
334    if (FNm.GetUc()=="CON"){
335      FileId=stdout;
336    } else {
337      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
338      else {FileId=fopen(FNm.CStr(), "w+b");}
339      OpenedP=(FileId!=NULL);
340      if (OpenedP){
341        Bf=new char[MxBfL]; BfL=0;}
342    }
343  }
344  PSOut TFOut::New(const TStr& FNm, const bool& Append){
345    return PSOut(new TFOut(FNm, Append));
346  }
347  PSOut TFOut::New(const TStr& FNm, const bool& Append, bool& OpenedP){
<span onclick='openModal()' class='match'>348    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
349    if (OpenedP){return SOut;} else {return NULL;}
</span>350  }
351  TFOut::~TFOut(){
352    if (FileId!=NULL){FlushBf();}
353    if (Bf!=NULL){delete[] Bf;}
354    if (FileId!=NULL){
355      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
356  }
357  int TFOut::PutCh(const char& Ch){
358    if (BfL==TSize(MxBfL)){FlushBf();}
359    return Bf[BfL++]=Ch;
360  }
361  int TFOut::PutBf(const void* LBf, const TSize& LBfL){
362    int LBfS=0;
363    if (BfL+LBfL>MxBfL){
364      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
365        LBfS+=PutCh(((char*)LBf)[LBfC]);}
366    } else {
367      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
368        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
369    }
370    return LBfS;
371  }
372  void TFOut::Flush(){
373    FlushBf();
374    EAssertR(fflush(FileId)==0, "Can not flush file '"+GetSNm()+"'.");
375  }
376  TFInOut::TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) :
377   TSBase(TSStr(FNm.CStr())), FileId(NULL) {
378    switch (FAccess){
379      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
380      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
381      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
382        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
383      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
384      default: Fail;
385    }
386    if ((FileId==NULL)&&(CreateIfNo)){FileId=fopen(FNm.CStr(), "w+b");}
387    IAssert(FileId!=NULL);
388  }
389  PSInOut TFInOut::New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) {
390    return PSInOut(new TFInOut(FNm, FAccess, CreateIfNo));
391  }
392  int TFInOut::GetSize() const {
393    const int FPos = GetPos();
394    IAssert(fseek(FileId, 0, SEEK_END) == 0);
395    const int FLen = GetPos();
396    IAssert(fseek(FileId, FPos, SEEK_SET) == 0);
397    return FLen;
398  }
399  int TFInOut::PutBf(const void* LBf, const TSize& LBfL) {
400    int LBfS = 0;
401    for (TSize i = 0; i < LBfL; i++) {
402      LBfS += ((char *)LBf)[i];
403    }
404    IAssert(fwrite(LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
405    return LBfS;
406  }
407  int TFInOut::GetBf(const void* LBf, const TSize& LBfL) {
408    IAssert(fread((void *)LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
409    int LBfS = 0;
410    for (TSize i = 0; i < LBfL; i++) {
411      LBfS += ((char *)LBf)[i];
412    }
413    return LBfS;
414  }
415  bool TFInOut::GetNextLnBf(TChA& LnChA){
416    FailR(TStr::Fmt("TFInOut::GetNextLnBf: not implemented").CStr());
417    return false;
418  }
419  TStr TFInOut::GetFNm() const {
420    return GetSNm();
421  }
422  TShMIn::TShMIn(const TStr& Str): TSBase("Input-Shared_Memory"), 
423      TSIn("Input-Shared_Memory"), TotalLength(0),
424      SizeLeft(0) {
425  #ifdef GLib_LINUX
426        TStr FNm = Str;
427        TFileId FileId;
428        int fd;
429        uint64 FLen;
430        EAssertR(!FNm.Empty(), "Empty file-name.");
431        FileId=fopen(FNm.CStr(), "rb");
432        fd = fileno(FileId);
433        EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
434        EAssertR(
435            fseek(FileId, 0, SEEK_END)==0,
436            "Error seeking into file '"+TStr(FNm)+"'.");
437        FLen=(uint64)ftell(FileId);
438        EAssertR(
439            fseek(FileId, 0, SEEK_SET)==0,
440            "Error seeking into file '"+TStr(FNm)+"'.");
441        char *Mapped;
442        Mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
443        EAssertR(Mapped!=MAP_FAILED, "mmap failed in TShMIn.");
444        OriginalBuffer = Mapped;
445        Cursor = OriginalBuffer;
446        SizeLeft = FLen;
447        TotalLength = FLen;
448        IsMemoryMapped = true;
449  #else
450        TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
451  #endif
452      }
453  TShMIn::TShMIn(void* _Bf, const TSize& _BfL): TSBase("Input-Shared_Memory"), 
454    TSIn("Input-Shared_Memory"), TotalLength(_BfL), SizeLeft(_BfL), IsMemoryMapped(false) {
455      OriginalBuffer = (char*)_Bf;
456      Cursor = (char*)_Bf;
457    }
458  void TShMIn::CloseMapping() {
459    if (OriginalBuffer!=NULL){
460      if (IsMemoryMapped) {
461  #ifdef GLib_LINUX
462        munmap(OriginalBuffer, TotalLength);
463        IsMemoryMapped = false;
464        OriginalBuffer = NULL;
465        Cursor = NULL;
466        TotalLength= 0;
467        SizeLeft = 0;
468  #endif
469      }
470    }
471  }
472  TMIn::TMIn(const void* _Bf, const uint64& _BfL, const bool& TakeBf):
473    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(_BfL), IsMemoryMapped(false){
474    if (TakeBf){
475      Bf=(char*)_Bf;
476    } else {
477      Bf=new char[static_cast<size_t>(BfL)]; memmove(Bf, _Bf, static_cast<size_t>(BfL));
478    }
479  }
480  TMIn::TMIn(TSIn& SIn):
481    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
482    BfL=SIn.Len(); Bf=new char[static_cast<size_t>(BfL)];
483    for (uint64 BfC=0; BfC<BfL; BfC++){Bf[BfC]=SIn.GetCh();}
484  }
485  TMIn::TMIn(const char* CStr):
486    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
487    BfL=uint64(strlen(CStr)); Bf=new char[static_cast<size_t>(BfL+1)]; strcpy(Bf, CStr);
488  }
489  TMIn::TMIn(const TStr& Str, bool FromFile):
490    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
491    if (FromFile == false) {
492      BfL=Str.Len(); Bf=new char[static_cast<size_t>(BfL)]; strncpy(Bf, Str.CStr(), static_cast<size_t>(BfL));
493      IsMemoryMapped = false;
494    }
495    else {
496  #ifdef GLib_LINUX
497      TStr FNm = Str;
498      TFileId FileId;
499      int fd;
500      uint64 FLen;
501      EAssertR(!FNm.Empty(), "Empty file-name.");
502      FileId=fopen(FNm.CStr(), "rb");
503      fd = fileno(FileId);
504      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
505      EAssertR(
506          fseek(FileId, 0, SEEK_END)==0,
507          "Error seeking into file '"+TStr(FNm)+"'.");
508      FLen=(uint64)ftell(FileId);
509      EAssertR(
510          fseek(FileId, 0, SEEK_SET)==0,
511          "Error seeking into file '"+TStr(FNm)+"'.");
512      char *mapped;
513      mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
514      IsMemoryMapped = true;
515      if (mapped == MAP_FAILED) {
516        printf("mmap failed: %d %s\n", fd, strerror (errno));
517        Bf = NULL;
518        BfC = BfL = 0;
519      }
520      else {
521        Bf = mapped;
522        BfC = 0;
523        BfL = FLen;
524      }
525      IsMemoryMapped = true;
526  #else
527      TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
528  #endif
529    }
530  }
531  TMIn::TMIn(const TChA& ChA):
532    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
533    BfL=ChA.Len(); Bf=new char[static_cast<size_t>(BfL)]; strncpy(Bf, ChA.CStr(), static_cast<size_t>(BfL));
534  }
535  PSIn TMIn::New(const void* _Bf, const uint64& _BfL, const bool& TakeBf){
536    return PSIn(new TMIn(_Bf, _BfL, TakeBf));
537  }
538  PSIn TMIn::New(const char* CStr){
539    return PSIn(new TMIn(CStr));
540  }
541  PSIn TMIn::New(const TStr& Str){
542    return PSIn(new TMIn(Str));
543  }
544  PMIn TMIn::New(const TStr& Str, bool FromFile){
545    return new TMIn(Str, FromFile);
546  }
547  PSIn TMIn::New(const TChA& ChA){
548    return PSIn(new TMIn(ChA));
549  }
550  TMIn::~TMIn(){
551    if (Bf!=NULL){
552      if (IsMemoryMapped) {
553  #ifdef GLib_LINUX
554        munmap(Bf, BfL);
555  #endif
556      }
557      else {
558        delete[] Bf;
559      }
560    }
561  }
562  char TMIn::GetCh(){
563    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
564    return Bf[BfC++];
565  }
566  char TMIn::PeekCh(){
567    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
568    return Bf[BfC];
569  }
570  int TMIn::GetBf(const void* LBf, const TSize& LBfL){
571    EAssertR(TSize(BfC+LBfL)<=TSize(BfL), "Reading beyond the end of stream.");
572    int LBfS=0;
573    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
574      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
575    return LBfS;
576  }
577  int TMIn::FindEol(uint64& BfN, bool& CrEnd) {
578    char Ch;
579    if (BfC >= BfL) {
580      if (Eof()) {
581        return -1;
582      }
583      if (CrEnd && Bf[BfC]=='\n') {
584        BfC++;
585        BfN = BfC-1;
586        return 1;
587      }
588    }
589    CrEnd = false;
590    while (BfC < BfL) {
591      Ch = Bf[BfC++];
592      if (Ch=='\n') {
593        BfN = BfC-1;
594        return 1;
595      }
596      if (Ch=='\r') {
597        if (BfC == BfL) {
598          CrEnd = true;
599          BfN = BfC-1;
600          return 0;
601        } else if (Bf[BfC]=='\n') {
602          BfC++;
603          BfN = BfC-2;
604          return 1;
605        }
606      }
607    }
608    BfN = BfC;
609    return 0;
610  }
611  bool TMIn::GetNextLnBf(TChA& LnChA){
612    FailR(TStr::Fmt("TMIn::GetNextLnBf: not implemented").CStr());
613    return false;
614  }
615  uint64 TMIn::GetBfC() {
616    return BfC;
617  }
618  uint64 TMIn::GetBfL() {
619    return BfL;
620  }
621  void TMIn::SetBfC(uint64 Pos) {
622    BfC = Pos;
623  }
624  uint64 TMIn::CountNewLinesInRange(uint64 Lb, uint64 Ub) {
625    uint64 Cnt = 0;
626    if (Lb >= BfL) {
627      return 0;
628    }
629    for (uint64 i = Lb; i < Ub; i++) {
630      if (Bf[i] == '\n') {
631        Cnt += 1;
632      }
633    }
634    return Cnt;
635  }
636  uint64 TMIn::GetLineStartPos(uint64 Ind) {
637    while (Ind > 0 && Bf[Ind-1] != '\n') {
638      Ind--;
639    }
640    return Ind;
641  }
642  uint64 TMIn::GetLineEndPos(uint64 Ind) {
643    while (Ind < BfL && Bf[Ind] != '\n') {
644      Ind++;
645    }
646    if (Ind == BfL) Ind--;
647    return Ind;
648  }
649  char* TMIn::GetLine(uint64 Index) {
650    return &Bf[Index];
651  }
652  void TMIn::SkipCommentLines() {
653    while (BfC < BfL && TCh::IsHashCh(Bf[BfC])) {
654      while (BfC < BfL && Bf[BfC] != '\n') {
655        BfC++;
656      }
657      BfC++;
658    }
659  }
660  void TMOut::Resize(const int& ReqLen){
661    IAssert(OwnBf&&(BfL==MxBfL || ReqLen >= 0));
662    if (Bf==NULL){
663      IAssert(MxBfL==0); 
664      if (ReqLen < 0) Bf=new char[MxBfL=1024];
665      else Bf=new char[MxBfL=ReqLen];
666    } else {
667      if (ReqLen < 0){ MxBfL*=2; }
668      else if (ReqLen < MxBfL){ return; } 
669      else { MxBfL=(2*MxBfL < ReqLen ? ReqLen : 2*MxBfL); }
670      char* NewBf=new char[MxBfL];
671      memmove(NewBf, Bf, BfL); delete[] Bf; Bf=NewBf;
672    }
673  }
674  TMOut::TMOut(const int& _MxBfL):
675    TSBase("Output-Memory"), TSOut("Output-Memory"),
676    Bf(NULL), BfL(0), MxBfL(0), OwnBf(true){
677    MxBfL=_MxBfL>0?_MxBfL:1024;
678    Bf=new char[MxBfL];
679  }
680  TMOut::TMOut(char* _Bf, const int& _MxBfL):
681    TSBase("Output-Memory"), TSOut("Output-Memory"),
682    Bf(_Bf), BfL(0), MxBfL(_MxBfL), OwnBf(false){}
683  void TMOut::AppendBf(const void* LBf, const TSize& LBfL) {
684    Resize(Len() + (int)LBfL);
685    memcpy(Bf + BfL, LBf, LBfL);
686    BfL += (int)LBfL;
687  }
688  int TMOut::PutBf(const void* LBf, const TSize& LBfL){
689    int LBfS=0;
690    if (TSize(BfL+LBfL)>TSize(MxBfL)){
691      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
692        LBfS+=PutCh(((char*)LBf)[LBfC]);}
693    } else {
694      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
695        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
696    }
697    return LBfS;
698  }
699  TStr TMOut::GetAsStr() const {
700    TChA ChA(BfL);
701    for (int BfC=0; BfC<BfL; BfC++){ChA+=Bf[BfC];}
702    return ChA;
703  }
704  void TMOut::CutBf(const int& CutBfL){
705    IAssert((0<=CutBfL)&&(CutBfL<=BfL));
706    if (CutBfL==BfL){BfL=0;}
707    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
708  }
709  PSIn TMOut::GetSIn(const bool& IsCut, const int& CutBfL){
710    IAssert((CutBfL==-1)||((0<=CutBfL)));
711    int SInBfL= (CutBfL==-1) ? BfL : TInt::GetMn(BfL, CutBfL);
712    PSIn SIn;
713    if (OwnBf&&IsCut&&(SInBfL==BfL)){
714      SIn=PSIn(new TMIn(Bf, SInBfL, true));
715      Bf=NULL; BfL=MxBfL=0; OwnBf=true;
716    } else {
717      SIn=PSIn(new TMIn(Bf, SInBfL, false));
718      if (IsCut){CutBf(SInBfL);}
719    }
720    return SIn;
721  }
722  bool TMOut::IsCrLfLn() const {
723    for (int BfC=0; BfC<BfL; BfC++){
724      if ((Bf[BfC]==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){return true;}}
725    return false;
726  }
727  TStr TMOut::GetCrLfLn(){
728    IAssert(IsCrLfLn());
729    TChA Ln;
730    for (int BfC=0; BfC<BfL; BfC++){
731      char Ch=Bf[BfC];
732      if ((Ch==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){
733        Ln+=TCh::CrCh; Ln+=TCh::LfCh; CutBf(BfC+1+1); break;
734      } else {
735        Ln+=Ch;
736      }
737    }
738    return Ln;
739  }
740  bool TMOut::IsEolnLn() const {
741    for (int BfC=0; BfC<BfL; BfC++){
742      if ((Bf[BfC]==TCh::CrCh)||(Bf[BfC]==TCh::LfCh)){return true;}
743    }
744    return false;
745  }
746  TStr TMOut::GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf){
747    IAssert(IsEolnLn());
748    int LnChs=0; TChA Ln;
749    for (int BfC=0; BfC<BfL; BfC++){
750      char Ch=Bf[BfC];
751      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
752        LnChs++; if (DoAddEoln){Ln+=Ch;}
753        if (BfC+1<BfL){
754          char NextCh=Bf[BfC+1];
755          if (((Ch==TCh::CrCh)&&(NextCh==TCh::LfCh))||
756           ((Ch==TCh::LfCh)&&(NextCh==TCh::CrCh))){
757            LnChs++; if (DoAddEoln){Ln+=NextCh;}
758          }
759        }
760        break;
761      } else {
762        LnChs++; Ln+=Ch;
763      }
764    }
765    if (DoCutBf){
766      CutBf(LnChs);
767    }
768    return Ln;
769  }
770  void TMOut::MkEolnLn(){
771    if (!IsEolnLn()){
772      PutCh(TCh::CrCh); PutCh(TCh::LfCh);}
773  }
774  bool TLnRet::NextLn(TStr& LnStr) {
775      if (SIn->Eof()) { return false; }
776      TChA LnChA; char Ch = TCh::EofCh;
777      while (!SIn->Eof() && ((Ch=SIn->GetCh())!='\n')) {
778          if (Ch != '\r') { LnChA += Ch; }
779      }
780      LnStr = LnChA; return true;
781  }
782  #ifndef SEEK_SET
783  #define SEEK_CUR    1
784  #define SEEK_END    2
785  #define SEEK_SET    0
786  #endif
787  void TFRnd::RefreshFPos(){
788    EAssertR(
789     fseek(FileId, 0, SEEK_CUR)==0,
790     "Error seeking into file '"+TStr(FNm)+"'.");
791  }
792  TFRnd::TFRnd(const TStr& _FNm, const TFAccess& FAccess,
793   const bool& CreateIfNo, const int& _HdLen, const int& _RecLen):
794    FileId(NULL), FNm(_FNm.CStr()),
795    RecAct(false), HdLen(_HdLen), RecLen(_RecLen){
796    RecAct=(HdLen>=0)&&(RecLen>0);
797    switch (FAccess){
798      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
799      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
800      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
801        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
802      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
803      default: Fail;
804    }
805    if ((FileId==NULL)&&(CreateIfNo)){
806      FileId=fopen(FNm.CStr(), "w+b");}
807    EAssertR(FileId!=NULL, "Can not open file '"+_FNm+"'.");
808  }
809  TFRnd::~TFRnd(){
810    EAssertR(fclose(FileId)==0, "Can not close file '"+TStr(FNm)+"'.");
811  }
812  TStr TFRnd::GetFNm() const {
813    return FNm.CStr();
814  }
815  void TFRnd::SetFPos(const int& FPos){
816    EAssertR(
817     fseek(FileId, FPos, SEEK_SET)==0,
818     "Error seeking into file '"+TStr(FNm)+"'.");
819  }
820  void TFRnd::MoveFPos(const int& DFPos){
821    EAssertR(
822     fseek(FileId, DFPos, SEEK_CUR)==0,
823     "Error seeking into file '"+TStr(FNm)+"'.");
824  }
825  int TFRnd::GetFPos(){
826    int FPos= (int) ftell(FileId);
827    EAssertR(FPos!=-1, "Error seeking into file '"+TStr(FNm)+"'.");
828    return FPos;
829  }
830  int TFRnd::GetFLen(){
831    int FPos=GetFPos();
832    EAssertR(
833     fseek(FileId, 0, SEEK_END)==0,
834     "Error seeking into file '"+TStr(FNm)+"'.");
835    int FLen=GetFPos(); SetFPos(FPos); return FLen;
836  }
837  void TFRnd::SetRecN(const int& RecN){
838    IAssert(RecAct);
839    SetFPos(HdLen+RecN*RecLen);
840  }
841  int TFRnd::GetRecN(){
842    IAssert(RecAct);
843    int FPos=GetFPos()-HdLen;
844    EAssertR(FPos%RecLen==0, "Invalid position in file'"+TStr(FNm)+"'.");
845    return FPos/RecLen;
846  }
847  int TFRnd::GetRecs(){
848    IAssert(RecAct);
849    int FLen=GetFLen()-HdLen;
850    EAssertR(FLen%RecLen==0, "Invalid length of file'"+TStr(FNm)+"'.");
851    return FLen/RecLen;
852  }
853  void TFRnd::GetBf(void* Bf, const TSize& BfL){
854    RefreshFPos();
855    EAssertR(
856     fread(Bf, 1, BfL, FileId)==BfL,
857     "Error reading file '"+TStr(FNm)+"'.");
858  }
859  void TFRnd::PutBf(const void* Bf, const TSize& BfL){
860    RefreshFPos();
861    EAssertR(
862     fwrite(Bf, 1, BfL, FileId)==BfL,
863     "Error writting to the file '"+TStr(FNm)+"'.");
864  }
865  void TFRnd::Flush(){
866    EAssertR(fflush(FileId)==0, "Can not flush file '"+TStr(FNm)+"'.");
867  }
868  void TFRnd::PutCh(const char& Ch, const int& Chs){
869    if (Chs>0){
870      char* CStr=new char[Chs];
871      for (int ChN=0; ChN<Chs; ChN++){CStr[ChN]=Ch;}
872      PutBf(CStr, Chs);
873      delete[] CStr;
874    }
875  }
876  void TFRnd::PutStr(const TStr& Str){
877    PutBf(Str.CStr(), Str.Len()+1);
878  }
879  TStr TFRnd::GetStr(const int& StrLen, bool& IsOk){
880    IsOk=false; TStr Str;
881    if (GetFPos()+StrLen+1<=GetFLen()){
882      char* CStr=new char[StrLen+1];
883      GetBf(CStr, StrLen+1);
884      if (CStr[StrLen+1-1]==TCh::NullCh){IsOk=true; Str=CStr;}
885      delete[] CStr;
886    }
887    return Str;
888  }
889  TStr TFRnd::GetStr(const int& StrLen){
890    TStr Str;
891    char* CStr=new char[StrLen+1];
892    GetBf(CStr, StrLen+1);
893    EAssertR(CStr[StrLen+1-1]==TCh::NullCh, "Error reading file '"+TStr(FNm)+"'.");
894    Str=CStr;
895    delete[] CStr;
896    return Str;
897  }
898  void TFRnd::PutSIn(const PSIn& SIn, TCs& Cs){
899    int BfL=SIn->Len();
900    char* Bf=new char[BfL];
901    SIn->GetBf(Bf, BfL);
902    Cs=TCs::GetCsFromBf(Bf, BfL);
903    PutBf(Bf, BfL);
904    delete[] Bf;
905  }
906  PSIn TFRnd::GetSIn(const int& BfL, TCs& Cs){
907    char* Bf=new char[BfL];
908    GetBf(Bf, BfL);
909    Cs=TCs::GetCsFromBf(Bf, BfL);
910    PSIn SIn=PSIn(new TMIn(Bf, BfL, true));
911    return SIn;
912  }
913  TStr TFRnd::GetStrFromFAccess(const TFAccess& FAccess){
914    switch (FAccess){
915      case faCreate: return "Create";
916      case faUpdate: return "Update";
917      case faAppend: return "Append";
918      case faRdOnly: return "ReadOnly";
919      case faRestore: return "Restore";
920      default: Fail; return TStr();
921    }
922  }
923  TFAccess TFRnd::GetFAccessFromStr(const TStr& Str){
924    TStr UcStr=Str.GetUc();
925    if (UcStr=="CREATE"){return faCreate;}
926    if (UcStr=="UPDATE"){return faUpdate;}
927    if (UcStr=="APPEND"){return faAppend;}
928    if (UcStr=="READONLY"){return faRdOnly;}
929    if (UcStr=="RESTORE"){return faRestore;}
930    if (UcStr=="NEW"){return faCreate;}
931    if (UcStr=="CONT"){return faUpdate;}
932    if (UcStr=="CONTINUE"){return faUpdate;}
933    if (UcStr=="REST"){return faRestore;}
934    if (UcStr=="RESTORE"){return faRestore;}
935    return faUndef;
936  }
937  const TStr TFile::TxtFExt=".Txt";
938  const TStr TFile::HtmlFExt=".Html";
939  const TStr TFile::HtmFExt=".Htm";
940  const TStr TFile::GifFExt=".Gif";
941  const TStr TFile::JarFExt=".Jar";
942  bool TFile::Exists(const TStr& FNm){
943    if (FNm.Empty()) { return false; }
944    bool DoExists;
945    TFIn FIn(FNm, DoExists);
946    return DoExists;
947  }
948  #if defined(GLib_WIN32)
949  void TFile::Copy(const TStr& SrcFNm, const TStr& DstFNm, 
950   const bool& ThrowExceptP, const bool& FailIfExistsP){
951    if (ThrowExceptP){
952      if (CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP) == 0) {
953          int ErrorCode = (int)GetLastError();
954          TExcept::Throw(TStr::Fmt(
955              "Error %d copying file '%s' to '%s'.", 
956              ErrorCode, SrcFNm.CStr(), DstFNm.CStr()));
957      }
958    } else {
959      CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP);
960    }
961  }
962  #elif defined(GLib_LINUX)
963  void TFile::Copy(const TStr& SrcFNm, const TStr& DstFNm,
964   const bool& ThrowExceptP, const bool& FailIfExistsP){
965  	int input, output;
966  	size_t filesize;
967  	void *source, *target;
968  	if( (input = open(SrcFNm.CStr(), O_RDONLY)) == -1) {
969  		if (ThrowExceptP) {
970  			TExcept::Throw(TStr::Fmt(
971  			            "Error copying file '%s' to '%s': cannot open source file for reading.",
972  			            SrcFNm.CStr(), DstFNm.CStr()));
973  		} else {
974  			return;
975  		}
976  	}
977  	if( (output = open(DstFNm.CStr(), O_RDWR | O_CREAT | O_TRUNC, 0666)) == -1)	{
978  		close(input);
979  		if (ThrowExceptP) {
980  			TExcept::Throw(TStr::Fmt(
981  			            "Error copying file '%s' to '%s': cannot open destination file for writing.",
982  			            SrcFNm.CStr(), DstFNm.CStr()));
983  		} else {
984  			return;
985  		}
986  	}
987  	filesize = lseek(input, 0, SEEK_END);
988  	lseek(output, filesize - 1, SEEK_SET);
989  	write(output, '\0', 1);
990  	if((source = mmap(0, filesize, PROT_READ, MAP_SHARED, input, 0)) == (void *) -1) {
991  		close(input);
992  		close(output);
993  		if (ThrowExceptP) {
994  			TExcept::Throw(TStr::Fmt(
995  						"Error copying file '%s' to '%s': cannot mmap input file.",
996  						SrcFNm.CStr(), DstFNm.CStr()));
997  		} else {
998  			return;
999  		}
1000  	}
1001  	if((target = mmap(0, filesize, PROT_WRITE, MAP_SHARED, output, 0)) == (void *) -1) {
1002  		munmap(source, filesize);
1003  		close(input);
1004  		close(output);
1005  		if (ThrowExceptP) {
1006  			TExcept::Throw(TStr::Fmt(
1007  						"Error copying file '%s' to '%s': cannot mmap output file.",
1008  						SrcFNm.CStr(), DstFNm.CStr()));
1009  		} else {
1010  			return;
1011  		}
1012  	}
1013  	memcpy(target, source, filesize);
1014  	munmap(source, filesize);
1015  	munmap(target, filesize);
1016  	close(input);
1017  	close(output);
1018  }
1019  #endif
1020  void TFile::Del(const TStr& FNm, const bool& ThrowExceptP){
1021    if (ThrowExceptP){
1022      EAssertR(
1023       remove(FNm.CStr())==0,
1024       "Error removing file '"+FNm+"'.");
1025    } else {
1026      remove(FNm.CStr());
1027    }
1028  }
1029  void TFile::DelWc(const TStr& WcStr, const bool& RecurseDirP){
1030    TStrV FNmV;
1031    TFFile FFile(WcStr, RecurseDirP); TStr FNm;
1032    while (FFile.Next(FNm)){
1033      FNmV.Add(FNm);}
1034    for (int FNmN=0; FNmN<FNmV.Len(); FNmN++){
1035      Del(FNmV[FNmN], false);}
1036  }
1037  void TFile::Rename(const TStr& SrcFNm, const TStr& DstFNm){
1038    EAssertR(
1039     rename(SrcFNm.CStr(), DstFNm.CStr())==0,
1040     "Error renaming file '"+SrcFNm+"' to "+DstFNm+"'.");
1041  }
1042  TStr TFile::GetUniqueFNm(const TStr& FNm){
1043    int Cnt=1; int ch;
1044    TStr NewFNm; TStr TmpFNm=FNm;
1045    if (FNm.SearchCh('#') == -1) {
1046      for (ch = FNm.Len()-1; ch >= 0; ch--) if (FNm[ch] == '.') break;
1047      if (ch != -1) TmpFNm.InsStr(ch, ".#");
1048      else TmpFNm += ".#";
1049    }
1050    forever{
1051      NewFNm=TmpFNm;
1052      NewFNm.ChangeStr("#", TStr::Fmt("%03d", Cnt)); Cnt++;
1053      if (!TFile::Exists(NewFNm)){break;}
1054    }
1055    return NewFNm;
1056  }
1057  #ifdef GLib_WIN
1058  uint64 TFile::GetSize(const TStr& FNm) {
1059      HANDLE hFile = CreateFile(
1060         FNm.CStr(),            
1061         GENERIC_READ,          
1062         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1063         NULL,                  
1064         OPEN_EXISTING,         
1065         FILE_ATTRIBUTE_NORMAL, 
1066         NULL);                 
1067      if (hFile == INVALID_HANDLE_VALUE) {
1068          TExcept::Throw("Can not open file " + FNm + "!"); }
1069      LARGE_INTEGER lpFileSizeHigh;
1070  	if (!GetFileSizeEx(hFile, &lpFileSizeHigh)) {
1071          TExcept::Throw("Can not read size of file " + FNm + "!"); }
1072      CloseHandle(hFile);
1073  	return uint64(lpFileSizeHigh.QuadPart);
1074  }
1075  uint64 TFile::GetCreateTm(const TStr& FNm) {
1076      HANDLE hFile = CreateFile(
1077         FNm.CStr(),            
1078         GENERIC_READ,          
1079         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1080         NULL,                  
1081         OPEN_EXISTING,         
1082         FILE_ATTRIBUTE_NORMAL, 
1083         NULL);                 
1084      if (hFile == INVALID_HANDLE_VALUE) {
1085          TExcept::Throw("Can not open file " + FNm + "!"); }
1086      FILETIME lpCreationTime;
1087      if (!GetFileTime(hFile, &lpCreationTime, NULL, NULL)) {
1088          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1089      CloseHandle(hFile);
1090      TUInt64 UInt64(uint(lpCreationTime.dwHighDateTime), 
1091          uint(lpCreationTime.dwLowDateTime));
1092      return UInt64.Val / uint64(10000);
1093  }
1094  uint64 TFile::GetLastAccessTm(const TStr& FNm) {
1095      HANDLE hFile = CreateFile(
1096         FNm.CStr(),            
1097         GENERIC_READ,          
1098         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1099         NULL,                  
1100         OPEN_EXISTING,         
1101         FILE_ATTRIBUTE_NORMAL, 
1102         NULL);                 
1103      if (hFile == INVALID_HANDLE_VALUE) {
1104          TExcept::Throw("Can not open file " + FNm + "!"); }
1105      FILETIME lpLastAccessTime;
1106      if (!GetFileTime(hFile, NULL, &lpLastAccessTime, NULL)) {
1107          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1108      CloseHandle(hFile);
1109      TUInt64 UInt64(uint(lpLastAccessTime.dwHighDateTime), 
1110          uint(lpLastAccessTime.dwLowDateTime));
1111      return UInt64.Val / uint64(10000);
1112  }
1113  uint64 TFile::GetLastWriteTm(const TStr& FNm) {
1114      HANDLE hFile = CreateFile(
1115         FNm.CStr(),            
1116         GENERIC_READ,          
1117         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1118         NULL,                  
1119         OPEN_EXISTING,         
1120         FILE_ATTRIBUTE_NORMAL, 
1121         NULL);                 
1122      if (hFile == INVALID_HANDLE_VALUE) {
1123          TExcept::Throw("Can not open file " + FNm + "!"); }
1124      FILETIME lpLastWriteTime;
1125      if (!GetFileTime(hFile, NULL, NULL, &lpLastWriteTime)) {
1126          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1127      CloseHandle(hFile);
1128      TUInt64 UInt64(uint(lpLastWriteTime.dwHighDateTime), 
1129          uint(lpLastWriteTime.dwLowDateTime));
1130      return UInt64.Val / uint64(10000);
1131  }
1132  #elif defined(GLib_LINUX)
1133  uint64 TFile::GetSize(const TStr& FNm) {
1134  	Fail; return 0;
1135  }
1136  uint64 TFile::GetCreateTm(const TStr& FNm) {
1137  	return GetLastWriteTm(FNm);
1138  }
1139  uint64 TFile::GetLastWriteTm(const TStr& FNm) {
1140  	struct stat st;
1141  	if (stat(FNm.CStr(), &st) != 0) {
1142  		TExcept::Throw("Cannot read tile from file " + FNm + "!");
1143  	}
1144  	return uint64(st.st_mtime);
1145  }
1146  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-infonet.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</div>
                <div class="column column_space"><pre><code>104    PSIn SIn=TFIn::New(FullFNm, OpenedP);
105    if (OpenedP){
106      return ExeCmFromXml(SIn);
107    } else {
108      return GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+FNm+"'.");
</pre></code></div>
                <div class="column column_space"><pre><code>348    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
349    if (OpenedP){return SOut;} else {return NULL;}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    