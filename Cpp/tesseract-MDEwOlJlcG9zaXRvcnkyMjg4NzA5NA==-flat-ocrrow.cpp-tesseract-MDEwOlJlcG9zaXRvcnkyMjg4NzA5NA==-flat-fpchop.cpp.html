
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.6417489421720735%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ocrrow.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "blobbox.h"
5  #include "ocrrow.h"
6  namespace tesseract {
7  ROW::ROW(                
8      int32_t spline_size, 
9      int32_t *xstarts,    
10      double *coeffs,      
11      float x_height,      
12      float ascenders,     
13      float descenders,    
14      int16_t kern,        
15      int16_t space        
16      )
17      : baseline(spline_size, xstarts, coeffs), para_(nullptr) {
18    kerning = kern; 
19    spacing = space;
20    xheight = x_height;
21    ascrise = ascenders;
22    bodysize = 0.0f;
23    descdrop = descenders;
24    has_drop_cap_ = false;
25    lmargin_ = 0;
26    rmargin_ = 0;
27  }
28  ROW::ROW(           
29      TO_ROW *to_row, 
30      int16_t kern,   
31      int16_t space   
32      )
33      : para_(nullptr) {
34    kerning = kern; 
35    spacing = space;
36    xheight = to_row->xheight;
37    bodysize = to_row->body_size;
38    ascrise = to_row->ascrise;
39    descdrop = to_row->descdrop;
40    baseline = to_row->baseline;
41    has_drop_cap_ = false;
42    lmargin_ = 0;
43    rmargin_ = 0;
44  }
45  TBOX ROW::restricted_bounding_box(bool upper_dots, bool lower_dots) const {
46    TBOX box;
47    WERD_IT it(const_cast<WERD_LIST *>(&words));
48    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
49      box += it.data()->restricted_bounding_box(upper_dots, lower_dots);
50    }
51    return box;
52  }
53  void ROW::recalc_bounding_box() { 
54    WERD *word;                     
55    WERD_IT it = &words;            
56    int16_t left;                   
57    int16_t prev_left;              
58    if (!it.empty()) {
59      word = it.data();
60      prev_left = word->bounding_box().left();
61      it.forward();
62      while (!it.at_first()) {
63        word = it.data();
64        left = word->bounding_box().left();
65        if (left < prev_left) {
66          it.move_to_first();
67          it.sort(word_comparator);
68          break;
69        }
70        prev_left = left;
71        it.forward();
72      }
73    }
74    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
75      word = it.data();
76      if (it.at_first()) {
77        word->set_flag(W_BOL, true);
78      } else {
79        word->set_flag(W_BOL, false);
80      }
81      if (it.at_last()) {
82        word->set_flag(W_EOL, true);
83      } else {
84        word->set_flag(W_EOL, false);
85      }
86      bound_box += word->bounding_box();
87    }
88  }
89  void ROW::move(      
90      const ICOORD vec 
91  ) {
92    WERD_IT it(&words); 
93    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
94      it.data()->move(vec);
95    }
96    bound_box.move(vec);
97    baseline.move(vec);
98  }
99  void ROW::print( 
100      FILE *fp     
101  ) const {
102    tprintf("Kerning= %d\n", kerning);
103    tprintf("Spacing= %d\n", spacing);
104    bound_box.print();
105    tprintf("Xheight= %f\n", xheight);
106    tprintf("Ascrise= %f\n", ascrise);
107    tprintf("Descdrop= %f\n", descdrop);
108    tprintf("has_drop_cap= %d\n", has_drop_cap_);
109    tprintf("lmargin= %d, rmargin= %d\n", lmargin_, rmargin_);
110  }
111  #ifndef GRAPHICS_DISABLED
112  void ROW::plot(              
113      ScrollView *window,      
114      ScrollView::Color colour 
115  ) {
116    WERD *word;          
117    WERD_IT it = &words; 
118    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
119      word = it.data();
120      word->plot(window, colour); 
121    }
122  }
123  void ROW::plot(        
124      ScrollView *window 
125  ) {
126    WERD *word;          
127    WERD_IT it = &words; 
128    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
129      word = it.data();
130      word->plot(window); 
131    }
132  }
133  #endif 
134  ROW &ROW::operator=(const ROW &source) {
135    this->ELIST_LINK::operator=(source);
136    kerning = source.kerning;
<span onclick='openModal()' class='match'>137    spacing = source.spacing;
138    xheight = source.xheight;
139    bodysize = source.bodysize;
140    ascrise = source.ascrise;
141    descdrop = source.descdrop;
142    if (!words.empty()) {
143      words.clear();
144    }
145    baseline = source.baseline; 
146    bound_box = source.bound_box;
147    has_drop_cap_ = source.has_drop_cap_;
</span>148    lmargin_ = source.lmargin_;
149    rmargin_ = source.rmargin_;
150    para_ = source.para_;
151    return *this;
152  }
153  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-fpchop.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "fpchop.h"
5  #include "blobbox.h"
6  #include "drawtord.h"
7  #include "statistc.h"
8  #include "topitch.h"
9  #include "tovars.h"
10  namespace tesseract {
11  INT_VAR(textord_fp_chop_error, 2, "Max allowed bending of chop cells");
12  static WERD *add_repeated_word(WERD_IT *rep_it, int16_t &rep_left, int16_t &prev_chop_coord,
13                                 uint8_t &blanks, float pitch, WERD_IT *word_it);
14  static void fixed_chop_cblob(C_BLOB *blob, int16_t chop_coord, float pitch_error,
15                               C_OUTLINE_LIST *left_outlines, C_OUTLINE_LIST *right_outlines);
16  static void fixed_split_coutline(C_OUTLINE *srcline, int16_t chop_coord, float pitch_error,
17                                   C_OUTLINE_IT *left_it, C_OUTLINE_IT *right_it);
18  static bool fixed_chop_coutline(C_OUTLINE *srcline, int16_t chop_coord, float pitch_error,
19                                  C_OUTLINE_FRAG_LIST *left_frags, C_OUTLINE_FRAG_LIST *right_frags);
20  static void save_chop_cfragment(int16_t head_index, ICOORD head_pos, int16_t tail_index,
21                                  ICOORD tail_pos, C_OUTLINE *srcline, C_OUTLINE_FRAG_LIST *frags);
22  static void add_frag_to_list(C_OUTLINE_FRAG *frag, C_OUTLINE_FRAG_LIST *frags);
23  static void close_chopped_cfragments(C_OUTLINE_FRAG_LIST *frags, C_OUTLINE_LIST *children,
24                                       float pitch_error, C_OUTLINE_IT *dest_it);
25  static C_OUTLINE *join_chopped_fragments(C_OUTLINE_FRAG *bottom, C_OUTLINE_FRAG *top);
26  static void join_segments(C_OUTLINE_FRAG *bottom, C_OUTLINE_FRAG *top);
27  ROW *fixed_pitch_words( 
28      TO_ROW *row,        
29      FCOORD rotation     
30  ) {
31    bool bol;                
32    uint8_t blanks;          
33    uint8_t new_blanks;      
34    int16_t chop_coord;      
35    int16_t prev_chop_coord; 
36    int16_t rep_left;        
37    ROW *real_row;           
38    C_OUTLINE_LIST left_coutlines;
39    C_OUTLINE_LIST right_coutlines;
40    C_BLOB_LIST cblobs;
<span onclick='openModal()' class='match'>41    C_BLOB_IT cblob_it = &cblobs;
42    WERD_LIST words;
43    WERD_IT word_it = &words; 
44    WERD_IT rep_it = &row->rep_words;
45    WERD *word;         
46    int32_t xstarts[2]; 
47    int32_t prev_x;     
48    BLOBNBOX_IT box_it = row->blob_list();
49    ICOORDELT_IT cell_it = &row->char_cells;
50  #ifndef GRAPHICS_DISABLED
51    if (textord_show_page_cuts && to_win != nullptr) {
52      plot_row_cells(to_win, ScrollView::RED, row, 0, &row->char_cells);
53    }
54  #endif
55    prev_x = -INT16_MAX;
56    bol = true;
57    blanks = 0;
</span>58    if (rep_it.empty()) {
59      rep_left = INT16_MAX;
60    } else {
61      rep_left = rep_it.data()->bounding_box().left();
62    }
63    if (box_it.empty()) {
64      return nullptr; 
65    }
66    xstarts[0] = box_it.data()->bounding_box().left();
67    if (rep_left < xstarts[0]) {
68      xstarts[0] = rep_left;
69    }
70    if (cell_it.empty() || row->char_cells.singleton()) {
71      tprintf("Row without enough char cells!\n");
72      tprintf("Leftmost blob is at (%d,%d)\n", box_it.data()->bounding_box().left(),
73              box_it.data()->bounding_box().bottom());
74      return nullptr;
75    }
76    ASSERT_HOST(!cell_it.empty() && !row->char_cells.singleton());
77    prev_chop_coord = cell_it.data()->x();
78    word = nullptr;
79    while (rep_left < cell_it.data()->x()) {
80      word =
81          add_repeated_word(&rep_it, rep_left, prev_chop_coord, blanks, row->fixed_pitch, &word_it);
82    }
83    cell_it.mark_cycle_pt();
84    if (prev_chop_coord >= cell_it.data()->x()) {
85      cell_it.forward();
86    }
87    for (; !cell_it.cycled_list(); cell_it.forward()) {
88      chop_coord = cell_it.data()->x();
89      while (!box_it.empty() && box_it.data()->bounding_box().left() <= chop_coord) {
90        if (box_it.data()->bounding_box().right() > prev_x) {
91          prev_x = box_it.data()->bounding_box().right();
92        }
93        split_to_blob(box_it.extract(), chop_coord, textord_fp_chop_error + 0.5f, &left_coutlines,
94                      &right_coutlines);
95        box_it.forward();
96        while (!box_it.empty() && box_it.data()->cblob() == nullptr) {
97          delete box_it.extract();
98          box_it.forward();
99        }
100      }
101      if (!right_coutlines.empty() && left_coutlines.empty()) {
102        split_to_blob(nullptr, chop_coord, textord_fp_chop_error + 0.5f, &left_coutlines,
103                      &right_coutlines);
104      }
105      if (!left_coutlines.empty()) {
106        cblob_it.add_after_then_move(new C_BLOB(&left_coutlines));
107      } else {
108        if (rep_left < chop_coord) {
109          if (rep_left > prev_chop_coord) {
110            new_blanks =
111                static_cast<uint8_t>(floor((rep_left - prev_chop_coord) / row->fixed_pitch + 0.5));
112          } else {
113            new_blanks = 0;
114          }
115        } else {
116          if (chop_coord > prev_chop_coord) {
117            new_blanks =
118                static_cast<uint8_t>(floor((chop_coord - prev_chop_coord) / row->fixed_pitch + 0.5));
119          } else {
120            new_blanks = 0;
121          }
122        }
123        if (!cblob_it.empty()) {
124          if (blanks < 1 && word != nullptr && !word->flag(W_REP_CHAR)) {
125            blanks = 1;
126          }
127          word = new WERD(&cblobs, blanks, nullptr);
128          cblob_it.set_to_list(&cblobs);
129          word->set_flag(W_DONT_CHOP, true);
130          word_it.add_after_then_move(word);
131          if (bol) {
132            word->set_flag(W_BOL, true);
133            bol = false;
134          }
135          blanks = new_blanks;
136        } else {
137          blanks += new_blanks;
138        }
139        while (rep_left < chop_coord) {
140          word = add_repeated_word(&rep_it, rep_left, prev_chop_coord, blanks, row->fixed_pitch,
141                                   &word_it);
142        }
143      }
144      if (prev_chop_coord < chop_coord) {
145        prev_chop_coord = chop_coord;
146      }
147    }
148    if (!cblob_it.empty()) {
149      word = new WERD(&cblobs, blanks, nullptr);
150      word->set_flag(W_DONT_CHOP, true);
151      word_it.add_after_then_move(word);
152      if (bol) {
153        word->set_flag(W_BOL, true);
154      }
155    }
156    ASSERT_HOST(word != nullptr);
157    while (!rep_it.empty()) {
158      add_repeated_word(&rep_it, rep_left, prev_chop_coord, blanks, row->fixed_pitch, &word_it);
159    }
160    word_it.data()->set_flag(W_EOL, true);
161    if (prev_chop_coord > prev_x) {
162      prev_x = prev_chop_coord;
163    }
164    xstarts[1] = prev_x + 1;
165    real_row =
166        new ROW(row, static_cast<int16_t>(row->kern_size), static_cast<int16_t>(row->space_size));
167    word_it.set_to_list(real_row->word_list());
168    word_it.add_list_after(&words);
169    real_row->recalc_bounding_box();
170    return real_row;
171  }
172  static WERD *add_repeated_word( 
173      WERD_IT *rep_it,            
174      int16_t &rep_left,          
175      int16_t &prev_chop_coord,   
176      uint8_t &blanks,            
177      float pitch,                
178      WERD_IT *word_it            
179  ) {
180    WERD *word;         
181    int16_t new_blanks; 
182    if (rep_left > prev_chop_coord) {
183      new_blanks = static_cast<uint8_t>(floor((rep_left - prev_chop_coord) / pitch + 0.5));
184      blanks += new_blanks;
185    }
186    word = rep_it->extract();
187    prev_chop_coord = word->bounding_box().right();
188    word_it->add_after_then_move(word);
189    word->set_blanks(blanks);
190    rep_it->forward();
191    if (rep_it->empty()) {
192      rep_left = INT16_MAX;
193    } else {
194      rep_left = rep_it->data()->bounding_box().left();
195    }
196    blanks = 0;
197    return word;
198  }
199  void split_to_blob(                 
200      BLOBNBOX *blob,                 
201      int16_t chop_coord,             
202      float pitch_error,              
203      C_OUTLINE_LIST *left_coutlines, 
204      C_OUTLINE_LIST *right_coutlines) {
205    C_BLOB *real_cblob; 
206    if (blob != nullptr) {
207      real_cblob = blob->remove_cblob();
208    } else {
209      real_cblob = nullptr;
210    }
211    if (!right_coutlines->empty() || real_cblob != nullptr) {
212      fixed_chop_cblob(real_cblob, chop_coord, pitch_error, left_coutlines, right_coutlines);
213    }
214    delete blob;
215  }
216  static void fixed_chop_cblob(      
217      C_BLOB *blob,                  
218      int16_t chop_coord,            
219      float pitch_error,             
220      C_OUTLINE_LIST *left_outlines, 
221      C_OUTLINE_LIST *right_outlines 
222  ) {
223    C_OUTLINE *old_right;        
224    C_OUTLINE_LIST new_outlines; 
225    C_OUTLINE_IT left_it = left_outlines;
226    C_OUTLINE_IT right_it = right_outlines;
227    C_OUTLINE_IT new_it = &new_outlines;
228    C_OUTLINE_IT blob_it; 
229    if (!right_it.empty()) {
230      while (!right_it.empty()) {
231        old_right = right_it.extract();
232        right_it.forward();
233        fixed_split_coutline(old_right, chop_coord, pitch_error, &left_it, &new_it);
234      }
235      right_it.add_list_before(&new_outlines);
236    }
237    if (blob != nullptr) {
238      blob_it.set_to_list(blob->out_list());
239      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
240        fixed_split_coutline(blob_it.extract(), chop_coord, pitch_error, &left_it, &right_it);
241      }
242      delete blob;
243    }
244  }
245  static void fixed_split_coutline( 
246      C_OUTLINE *srcline,           
247      int16_t chop_coord,           
248      float pitch_error,            
249      C_OUTLINE_IT *left_it,        
250      C_OUTLINE_IT *right_it        
251  ) {
252    C_OUTLINE *child;               
253    TBOX srcbox;                    
254    C_OUTLINE_LIST left_ch;         
255    C_OUTLINE_LIST right_ch;        
256    C_OUTLINE_FRAG_LIST left_frags; 
257    C_OUTLINE_FRAG_LIST right_frags;
258    ;
259    C_OUTLINE_IT left_ch_it = &left_ch;
260    C_OUTLINE_IT right_ch_it = &right_ch;
261    C_OUTLINE_IT child_it = srcline->child();
262    srcbox = srcline->bounding_box();
263    if (srcbox.left() + srcbox.right() <= chop_coord * 2 &&
264        srcbox.right() < chop_coord + pitch_error) {
265      left_it->add_after_then_move(srcline);
266    } else if (srcbox.left() + srcbox.right() > chop_coord * 2 &&
267               srcbox.left() > chop_coord - pitch_error) {
268      right_it->add_before_stay_put(srcline);
269    } else {
270      if (fixed_chop_coutline(srcline, chop_coord, pitch_error, &left_frags, &right_frags)) {
271        for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
272          child = child_it.extract();
273          srcbox = child->bounding_box();
274          if (srcbox.right() < chop_coord) {
275            left_ch_it.add_after_then_move(child);
276          } else if (srcbox.left() > chop_coord) {
277            right_ch_it.add_after_then_move(child);
278          } else {
279            if (fixed_chop_coutline(child, chop_coord, 0.0f, &left_frags, &right_frags)) {
280              delete child;
281            } else {
282              if (srcbox.left() + srcbox.right() <= chop_coord * 2) {
283                left_ch_it.add_after_then_move(child);
284              } else {
285                right_ch_it.add_after_then_move(child);
286              }
287            }
288          }
289        }
290        close_chopped_cfragments(&left_frags, &left_ch, pitch_error, left_it);
291        close_chopped_cfragments(&right_frags, &right_ch, pitch_error, right_it);
292        ASSERT_HOST(left_ch.empty() && right_ch.empty());
293        delete srcline; 
294      } else {
295        if (srcbox.left() + srcbox.right() <= chop_coord * 2) {
296          left_it->add_after_then_move(srcline); 
297        } else {
298          right_it->add_before_stay_put(srcline);
299        }
300      }
301    }
302  }
303  static bool fixed_chop_coutline(     
304      C_OUTLINE *srcline,              
305      int16_t chop_coord,              
306      float pitch_error,               
307      C_OUTLINE_FRAG_LIST *left_frags, 
308      C_OUTLINE_FRAG_LIST *right_frags 
309  ) {
310    bool first_frag;         
311    int16_t left_edge;       
312    int16_t startindex;      
313    int32_t length;          
314    int16_t stepindex;       
315    int16_t head_index;      
316    ICOORD head_pos;         
317    int16_t tail_index;      
318    ICOORD tail_pos;         
319    ICOORD pos;              
320    int16_t first_index = 0; 
321    ICOORD first_pos;        
322    length = srcline->pathlength();
323    pos = srcline->start_pos();
324    left_edge = pos.x();
325    tail_index = 0;
326    tail_pos = pos;
327    for (stepindex = 0; stepindex < length; stepindex++) {
328      if (pos.x() < left_edge) {
329        left_edge = pos.x();
330        tail_index = stepindex;
331        tail_pos = pos;
332      }
333      pos += srcline->step(stepindex);
334    }
335    if (left_edge >= chop_coord - pitch_error) {
336      return false; 
337    }
338    startindex = tail_index;
339    first_frag = true;
340    head_index = tail_index;
341    head_pos = tail_pos;
342    do {
343      do {
344        tail_pos += srcline->step(tail_index);
345        tail_index++;
346        if (tail_index == length) {
347          tail_index = 0;
348        }
349      } while (tail_pos.x() != chop_coord && tail_index != startindex);
350      if (tail_index == startindex) {
351        if (first_frag) {
352          return false; 
353        } else {
354          break;
355        }
356      }
357      ASSERT_HOST(head_index != tail_index);
358      if (!first_frag) {
359        save_chop_cfragment(head_index, head_pos, tail_index, tail_pos, srcline, left_frags);
360      } else {
361        first_index = tail_index;
362        first_pos = tail_pos;
363        first_frag = false;
364      }
365      while (srcline->step(tail_index).x() == 0) {
366        tail_pos += srcline->step(tail_index);
367        tail_index++;
368        if (tail_index == length) {
369          tail_index = 0;
370        }
371      }
372      head_index = tail_index;
373      head_pos = tail_pos;
374      while (srcline->step(tail_index).x() > 0) {
375        do {
376          tail_pos += srcline->step(tail_index);
377          tail_index++;
378          if (tail_index == length) {
379            tail_index = 0;
380          }
381        } while (tail_pos.x() != chop_coord);
382        ASSERT_HOST(head_index != tail_index);
383        save_chop_cfragment(head_index, head_pos, tail_index, tail_pos, srcline, right_frags);
384        while (srcline->step(tail_index).x() == 0) {
385          tail_pos += srcline->step(tail_index);
386          tail_index++;
387          if (tail_index == length) {
388            tail_index = 0;
389          }
390        }
391        head_index = tail_index;
392        head_pos = tail_pos;
393      }
394    } while (tail_index != startindex);
395    save_chop_cfragment(head_index, head_pos, first_index, first_pos, srcline, left_frags);
396    return true; 
397  }
398  static void save_chop_cfragment( 
399      int16_t head_index,          
400      ICOORD head_pos,             
401      int16_t tail_index,          
402      ICOORD tail_pos,             
403      C_OUTLINE *srcline,          
404      C_OUTLINE_FRAG_LIST *frags   
405  ) {
406    int16_t jump;         
407    int16_t stepcount;    
408    C_OUTLINE_FRAG *head; 
409    C_OUTLINE_FRAG *tail; 
410    int16_t tail_y;       
411    ASSERT_HOST(tail_pos.x() == head_pos.x());
412    ASSERT_HOST(tail_index != head_index);
413    stepcount = tail_index - head_index;
414    if (stepcount < 0) {
415      stepcount += srcline->pathlength();
416    }
417    jump = tail_pos.y() - head_pos.y();
418    if (jump < 0) {
419      jump = -jump;
420    }
421    if (jump == stepcount) {
422      return; 
423    }
424    tail_y = tail_pos.y();
425    head = new C_OUTLINE_FRAG(head_pos, tail_pos, srcline, head_index, tail_index);
426    tail = new C_OUTLINE_FRAG(head, tail_y);
427    head->other_end = tail;
428    add_frag_to_list(head, frags);
429    add_frag_to_list(tail, frags);
430  }
431  C_OUTLINE_FRAG::C_OUTLINE_FRAG( 
432      ICOORD start_pt,            
433      ICOORD end_pt,              
434      C_OUTLINE *outline,         
435      int16_t start_index, int16_t end_index) {
436    start = start_pt;
437    end = end_pt;
438    ycoord = start_pt.y();
439    stepcount = end_index - start_index;
440    if (stepcount < 0) {
441      stepcount += outline->pathlength();
442    }
443    ASSERT_HOST(stepcount > 0);
444    steps = new DIR128[stepcount];
445    if (end_index > start_index) {
446      for (int i = start_index; i < end_index; ++i) {
447        steps[i - start_index] = outline->step_dir(i);
448      }
449    } else {
450      int len = outline->pathlength();
451      int i = start_index;
452      for (; i < len; ++i) {
453        steps[i - start_index] = outline->step_dir(i);
454      }
455      if (end_index > 0) {
456        for (; i < end_index + len; ++i) {
457          steps[i - start_index] = outline->step_dir(i - len);
458        }
459      }
460    }
461    other_end = nullptr;
462    delete close();
463  }
464  C_OUTLINE_FRAG::C_OUTLINE_FRAG( 
465      C_OUTLINE_FRAG *head,       
466      int16_t tail_y) {
467    ycoord = tail_y;
468    other_end = head;
469    start = head->start;
470    end = head->end;
471    steps = nullptr;
472    stepcount = 0;
473  }
474  static void add_frag_to_list(  
475      C_OUTLINE_FRAG *frag,      
476      C_OUTLINE_FRAG_LIST *frags 
477  ) {
478    C_OUTLINE_FRAG_IT frag_it = frags;
479    if (!frags->empty()) {
480      for (frag_it.mark_cycle_pt(); !frag_it.cycled_list(); frag_it.forward()) {
481        if (frag_it.data()->ycoord > frag->ycoord ||
482            (frag_it.data()->ycoord == frag->ycoord && frag->other_end->ycoord < frag->ycoord)) {
483          frag_it.add_before_then_move(frag);
484          return;
485        }
486      }
487    }
488    frag_it.add_to_end(frag);
489  }
490  static void close_chopped_cfragments( 
491      C_OUTLINE_FRAG_LIST *frags,       
492      C_OUTLINE_LIST *children,         
493      float pitch_error,                
494      C_OUTLINE_IT *dest_it             
495  ) {
496    C_OUTLINE_FRAG_IT frag_it = frags;
497    C_OUTLINE_FRAG *bottom_frag; 
498    C_OUTLINE_FRAG *top_frag;    
499    C_OUTLINE *outline;          
500    C_OUTLINE *child;            
501    C_OUTLINE_IT child_it = children;
502    C_OUTLINE_IT olchild_it; 
503    while (!frag_it.empty()) {
504      frag_it.move_to_first();
505      bottom_frag = frag_it.extract();
506      frag_it.forward();
507      top_frag = frag_it.data(); 
508      if ((bottom_frag->steps == nullptr && top_frag->steps == nullptr) ||
509          (bottom_frag->steps != nullptr && top_frag->steps != nullptr)) {
510        if (frag_it.data_relative(1)->ycoord == top_frag->ycoord) {
511          frag_it.forward();
512        }
513      }
514      top_frag = frag_it.extract();
515      if (top_frag->other_end != bottom_frag) {
516        outline = join_chopped_fragments(bottom_frag, top_frag);
517        ASSERT_HOST(outline == nullptr);
518      } else {
519        outline = join_chopped_fragments(bottom_frag, top_frag);
520        if (outline != nullptr) {
521          olchild_it.set_to_list(outline->child());
522          for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
523            child = child_it.data();
524            if (*child < *outline) {
525              olchild_it.add_to_end(child_it.extract());
526            }
527          }
528          if (outline->bounding_box().width() > pitch_error) {
529            dest_it->add_after_then_move(outline);
530          } else {
531            delete outline; 
532          }
533        }
534      }
535    }
536    while (!child_it.empty()) {
537      dest_it->add_after_then_move(child_it.extract());
538      child_it.forward();
539    }
540  }
541  static C_OUTLINE *join_chopped_fragments( 
542      C_OUTLINE_FRAG *bottom,               
543      C_OUTLINE_FRAG *top                   
544  ) {
545    C_OUTLINE *outline; 
546    if (bottom->other_end == top) {
547      if (bottom->steps == nullptr) {
548        outline = top->close(); 
549      } else {
550        outline = bottom->close();
551      }
552      delete top;
553      delete bottom;
554      return outline;
555    }
556    if (bottom->steps == nullptr) {
557      ASSERT_HOST(top->steps != nullptr);
558      join_segments(bottom->other_end, top);
559    } else {
560      ASSERT_HOST(top->steps == nullptr);
561      join_segments(top->other_end, bottom);
562    }
563    top->other_end->other_end = bottom->other_end;
564    bottom->other_end->other_end = top->other_end;
565    delete bottom;
566    delete top;
567    return nullptr;
568  }
569  static void join_segments(  
570      C_OUTLINE_FRAG *bottom, 
571      C_OUTLINE_FRAG *top     
572  ) {
573    DIR128 *steps;      
574    int32_t stepcount;  
575    int16_t fake_count; 
576    DIR128 fake_step;   
577    ASSERT_HOST(bottom->end.x() == top->start.x());
578    fake_count = top->start.y() - bottom->end.y();
579    if (fake_count < 0) {
580      fake_count = -fake_count;
581      fake_step = 32;
582    } else {
583      fake_step = 96;
584    }
585    stepcount = bottom->stepcount + fake_count + top->stepcount;
586    steps = new DIR128[stepcount];
587    memmove(steps, bottom->steps, bottom->stepcount);
588    memset(steps + bottom->stepcount, fake_step.get_dir(), fake_count);
589    memmove(steps + bottom->stepcount + fake_count, top->steps, top->stepcount);
590    delete[] bottom->steps;
591    bottom->steps = steps;
592    bottom->stepcount = stepcount;
593    bottom->end = top->end;
594    bottom->other_end->end = top->end;
595  }
596  C_OUTLINE *C_OUTLINE_FRAG::close() { 
597    DIR128 *new_steps;                 
598    int32_t new_stepcount;             
599    int16_t fake_count;                
600    DIR128 fake_step;                  
601    ASSERT_HOST(start.x() == end.x());
602    fake_count = start.y() - end.y();
603    if (fake_count < 0) {
604      fake_count = -fake_count;
605      fake_step = 32;
606    } else {
607      fake_step = 96;
608    }
609    new_stepcount = stepcount + fake_count;
610    if (new_stepcount > C_OUTLINE::kMaxOutlineLength) {
611      return nullptr; 
612    }
613    new_steps = new DIR128[new_stepcount];
614    memmove(new_steps, steps, stepcount);
615    memset(new_steps + stepcount, fake_step.get_dir(), fake_count);
616    auto *result = new C_OUTLINE(start, new_steps, new_stepcount);
617    delete[] new_steps;
618    return result;
619  }
620  C_OUTLINE_FRAG &C_OUTLINE_FRAG::operator=(const C_OUTLINE_FRAG &src 
621  ) {
622    delete[] steps;
623    stepcount = src.stepcount;
624    steps = new DIR128[stepcount];
625    memmove(steps, src.steps, stepcount);
626    start = src.start;
627    end = src.end;
628    ycoord = src.ycoord;
629    return *this;
630  }
631  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ocrrow.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-fpchop.cpp</div>
                <div class="column column_space"><pre><code>137    spacing = source.spacing;
138    xheight = source.xheight;
139    bodysize = source.bodysize;
140    ascrise = source.ascrise;
141    descdrop = source.descdrop;
142    if (!words.empty()) {
143      words.clear();
144    }
145    baseline = source.baseline; 
146    bound_box = source.bound_box;
147    has_drop_cap_ = source.has_drop_cap_;
</pre></code></div>
                <div class="column column_space"><pre><code>41    C_BLOB_IT cblob_it = &cblobs;
42    WERD_LIST words;
43    WERD_IT word_it = &words; 
44    WERD_IT rep_it = &row->rep_words;
45    WERD *word;         
46    int32_t xstarts[2]; 
47    int32_t prev_x;     
48    BLOBNBOX_IT box_it = row->blob_list();
49    ICOORDELT_IT cell_it = &row->char_cells;
50  #ifndef GRAPHICS_DISABLED
51    if (textord_show_page_cuts && to_win != nullptr) {
52      plot_row_cells(to_win, ScrollView::RED, row, 0, &row->char_cells);
53    }
54  #endif
55    prev_x = -INT16_MAX;
56    bol = true;
57    blanks = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    