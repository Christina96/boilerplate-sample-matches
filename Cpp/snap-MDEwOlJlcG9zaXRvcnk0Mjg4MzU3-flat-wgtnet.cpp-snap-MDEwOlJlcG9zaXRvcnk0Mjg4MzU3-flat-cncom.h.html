
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.757404795486601%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wgtnet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "wgtnet.h"
3  #include "dblp.h"
4  #include "arxiv.h"
5  double TWgtNet::GetEdgeWgt() const {
6    double wgt = 0;
7    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
8      for (int e = 0; e < NI.GetOutDeg(); e++) {
9        wgt += NI.GetOutEDat(e);
10      }
11    }
12    return wgt;
13  }
14  void TWgtNet::MulEdgeWgt(const double& MulBy) {
15    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
16      for (int e = 0; e < NI.GetOutDeg(); e++) {
17        NI.GetOutEDat(e) *= MulBy;
18      }
19    }
20  }
21  void TWgtNet::PermEdgeWgt() {
22    TFltV WgtV;
23    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
24      for (int e = 0; e < NI.GetOutDeg(); e++) {
25        WgtV.Add(NI.GetOutEDat(e)); 
26      }
27    }
28    WgtV.Shuffle(TInt::Rnd);
29    int w = 0;
30    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
31      for (int e = 0; e < NI.GetOutDeg(); e++) {
32        NI.GetOutEDat(e) = WgtV[w++]; 
33      }
34    }
35  }
36  void TWgtNet::PermOutEdgeWgt() {
37    TFltV WgtV;
38    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
39      WgtV.Clr(false);
40      for (int e = 0; e < NI.GetOutDeg(); e++) {
41        WgtV.Add(NI.GetOutEDat(e)); 
42      }
43      WgtV.Shuffle(TInt::Rnd);
44      for (int e = 0; e < NI.GetOutDeg(); e++) {
45        NI.GetOutEDat(e) = WgtV[e]; 
46      }
47    }
48  }
49  void TWgtNet::PutAllWgts() {
50    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
51      for (int e = 0; e < NI.GetOutDeg(); e++) {
52        NI.GetOutEDat(e) = TInt::Rnd.GetUniDev();
53      }
54    }
55  }
56  void TWgtNet::PutRnd01Wgts() {
57    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
58      for (int e = 0; e < NI.GetOutDeg(); e++) {
59        NI.GetOutEDat(e) = TInt::Rnd.GetUniDev();
60      }
61    }
62  }
63  void TWgtNet::AddBiDirEdges(const double& Wgt) {
64    TIntPrV EdgeV;
65    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
66      for (int e = 0; e < NI.GetOutDeg(); e++) { 
67        if (! IsEdge(NI.GetOutNId(e), NI.GetId())) {
68          EdgeV.Add(TIntPr(NI.GetOutNId(e), NI.GetId())); }
69      }
70    }
71    for (int e = 0; e < EdgeV.Len(); e++) {
72      if (Wgt != -1) {
73        AddEdge(EdgeV[e].Val1, EdgeV[e].Val2, Wgt);
74      } else { 
75        AddEdge(EdgeV[e].Val1, EdgeV[e].Val2, GetEDat(EdgeV[e].Val2, EdgeV[e].Val1));
76      }
77    }
78  }
79  void TWgtNet::DelMinWgtNodes(const double MinWgt) {
80    printf("Deleting Min Wgt %g nodes\n", MinWgt);
81    printf("  (%d,%d)  -->", GetNodes(), GetEdges());
82    TIntV DelNIdV;  
83    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
84      double wgt = 0;
85      for (int e = 0; e < NI.GetOutDeg(); e++) { 
86        wgt += NI.GetOutEDat(e);
87      }
88      if (wgt < MinWgt) { DelNIdV.Add(NI.GetId()); }
89    }
90    for (int d = 0; d < DelNIdV.Len(); d++) {
91      DelNode(DelNIdV[d]);
92    }
93    printf("  (%d,%d)\n", GetNodes(), GetEdges());
94  }
95  void TWgtNet::ReinforceEdges(const int& NIters) {
96    THash<TInt, TFlt> OutWgtSumH;
97    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
98      double wgt = 0;
99      for (int e = 0; e < NI.GetOutDeg(); e++) { 
100        wgt += NI.GetOutEDat(e); }
101      OutWgtSumH.AddDat(NI.GetId(), wgt);
102    }
103    printf("Reinforcing edges for %d iterations\n", NIters);
104    TExeTm ExeTm;
105    for (int iter = 0; iter < NIters; iter++) {
106      for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
107        const double X = TInt::Rnd.GetUniDev() * OutWgtSumH.GetDat(NI.GetId());
108        double x = 0;  int e = 0;
109        for ( ; x + NI.GetOutEDat(e) < X; e++) {
110          x += NI.GetOutEDat(e); }
111        IAssert(IsEdge(NI.GetOutNId(e), NI.GetId()));
112        GetEDat(NI.GetOutNId(e), NI.GetId()) += 1; 
113        OutWgtSumH.GetDat(NI.GetOutNId(e)) += 1; 
114      }
115      if (iter % (NIters/100) == 0) {
116        printf("\r%d [%s]", iter, ExeTm.GetStr()); 
117      }
118    }
119    printf(" done.\n");
120  }
121  PWgtNet TWgtNet::GetRngWgtNet(const int& Nodes, const int& Edges, const double& Wgt) {
122    PWgtNet Net = TWgtNet::New();
123    for (int n = 0; n < Nodes; n++) {
124      Net->AddNode();
125    }
126    for (int edges = 0; edges < Edges; ) {
127      int nid1 = TInt::Rnd.GetUniDevInt(Nodes);
128      int nid2 = TInt::Rnd.GetUniDevInt(Nodes);
129      if (nid1 == nid2) { continue; }
130      if (nid1 > nid2) { Swap(nid1, nid2); }
131      if (Net->AddEdge(nid1, nid2, Wgt==-1?TInt::Rnd.GetUniDev():Wgt) == -1) { 
132        edges++; 
133      }
134      if (Net->AddEdge(nid2, nid1, Wgt==-1?TInt::Rnd.GetUniDev():Wgt) == -1) { 
135        edges++; 
136      }
137    }
138    return Net;
139  }
140  PWgtNet TWgtNet::LoadCiteSeerCoAuth(const TStr& FNm) {
141    PWgtNet Net = TWgtNet::New();
142    TStrSet AuthorSet;
143    TSsParser Ss(FNm, ssfCommaSep);
144    while (Ss.Next()) {
145      for (int a1 = 2; a1 < Ss.Len(); a1++) {
146        const int n1 = AuthorSet.AddKey(Ss[a1]);
147        for (int a2 = 2; a2 < Ss.Len(); a2++) {
148          if (a1 == a2) { continue; }
149          const int n2 = AuthorSet.AddKey(Ss[a2]);
150          if (! Net->IsNode(n1)) { Net->AddNode(n1, Ss[a1]); }
151          if (! Net->IsNode(n2)) { Net->AddNode(n2, Ss[a2]); }
152          if (Net->IsEdge(n1, n2)) { Net->GetEDat(n1, n2) += 1; }
153          else { Net->AddEdge(n1, n2, 1); }
154        }
155      }
156    }
157    TGBase::PrintInfo(Net);
158    printf("  Edge weight: %f\n", Net->GetEdgeWgt());
159    return Net;
160  }
161  PWgtNet TWgtNet::LoadDblpCoAuth(const TStr& FNm) {
162    TDblpLoader Dblp(FNm);
163    TStrSet AuthorSet;
164    PWgtNet Net = TWgtNet::New();
<span onclick='openModal()' class='match'>165    for (int c = 0; Dblp.Next(); c++) {
166      for (int a1 = 0; a1 < Dblp.AuthorV.Len(); a1++) {
167        const int n1 = AuthorSet.AddKey(Dblp.AuthorV[a1]);
</span>168        for (int a2 = 0; a2 < Dblp.AuthorV.Len(); a2++) {
169          if (a1 == a2) { continue; }
170          const int n2 = AuthorSet.AddKey(Dblp.AuthorV[a2]);
171          if (! Net->IsNode(n1)) { Net->AddNode(n1, Dblp.AuthorV[a1]); }
172          if (! Net->IsNode(n2)) { Net->AddNode(n2, Dblp.AuthorV[a2]); }
173          if (Net->IsEdge(n1, n2)) { Net->GetEDat(n1, n2) += 1; }
174          else { Net->AddEdge(n1, n2, 1); }
175        }
176      }
177      if (c % 1000 == 0) { printf("\r%d", c); }
178    }
179    printf("\n");
180    TGBase::PrintInfo(Net);
181    printf("  Edge weight: %f\n", Net->GetEdgeWgt());
182    return Net;
183  }
184  PWgtNet TWgtNet::LoadArxivCoAuth(const TStr& FNm) {
185    TArxivPaperList Arxiv(FNm);
186    PWgtNet Net = TWgtNet::New();
187    TStrSet AuthorSet;
188    while (Arxiv.Next()) {
189      for (int a1 = 0; a1 < Arxiv.AuthorV.Len(); a1++) {
190        const int n1 = AuthorSet.AddKey(Arxiv.AuthorV[a1]);
191        for (int a2 = 0; a2 < Arxiv.AuthorV.Len(); a2++) {
192          if (a1 == a2) { continue; }
193          const int n2 = AuthorSet.AddKey(Arxiv.AuthorV[a2]);
194          if (! Net->IsNode(n1)) { Net->AddNode(n1, Arxiv.AuthorV[a1]); }
195          if (! Net->IsNode(n2)) { Net->AddNode(n2, Arxiv.AuthorV[a2]); }
196          if (Net->IsEdge(n1, n2)) { Net->GetEDat(n1, n2) += 1; }
197          else { Net->AddEdge(n1, n2, 1); }
198        }
199      }
200    }
201    TGBase::PrintInfo(Net);
202    printf("  Edge weight: %f\n", Net->GetEdgeWgt());
203    return Net;
204  }
205  PWgtNet TWgtNet::LoadEveCommNet(const TStr& FNm) {
206    PWgtNet Net = TWgtNet::New();
207    TStrSet AuthorSet;
208    TChA Ln;
209    TVec<char*> WrdV;
210    TFIn FIn(FNm);
211    for (int c=0; FIn.GetNextLn(Ln); c++) {
212      TStrUtil::SplitOnCh(Ln, WrdV, ';');
213      const int n1 = AuthorSet.AddKey(WrdV[0]);
214      const int n2 = AuthorSet.AddKey(WrdV[1]);
215      if (! Net->IsNode(n1)) { Net->AddNode(n1, WrdV[0]); }
216      if (! Net->IsNode(n2)) { Net->AddNode(n2, WrdV[1]); }
217      if (Net->IsEdge(n1, n2)) { Net->GetEDat(n1, n2) += 1; }
218      else { Net->AddEdge(n1, n2, 1); }
219      if (c % Kilo(10) == 0) { printf("\r%dk", c/1000); }
220    }
221    printf("\n");
222    TGBase::PrintInfo(Net);
223    printf("  Edge weight: %f\n", Net->GetEdgeWgt());
224    return Net;
225  }
226  void TTop2FriendNet::SetTop2() {
227    Top2NIdH.Gen(Net->GetNodes());
228    TFltIntPrV WgtNIdV;
229    for (TWgtNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
230      WgtNIdV.Clr(false);
231      for (int e = 0; e < NI.GetOutDeg(); e++) {
232        WgtNIdV.Add(TFltIntPr(NI.GetOutEDat(e), NI.GetOutNId(e)));
233      }
234      WgtNIdV.Shuffle(TInt::Rnd); 
235      WgtNIdV.Sort(false);
236      if (WgtNIdV.Len() == 0) { Top2NIdH.AddDat(NI.GetId(), TIntPr(-1, -1)); }
237      else if (WgtNIdV.Len() == 1) { Top2NIdH.AddDat(NI.GetId(), TIntPr(WgtNIdV[0].Val2, -1)); } 
238      else if (WgtNIdV.Len() >= 2) {
239        Top2NIdH.AddDat(NI.GetId(), TIntPr(WgtNIdV[0].Val2, WgtNIdV[1].Val2)); }
240    }
241    PNGraph Top1Net = GetTop1Net();
242    Top1UF = TUnionFind(Top1Net->GetNodes());
243    TCnComV CnComV; 
244    TCnCom::GetWccs(Top1Net, CnComV);
245    for (TWgtNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
246      Top1UF.Add(NI.GetId());
247    }
248    for (int c = 0; c < CnComV.Len(); c++) {
249      for (int i = 1; i < CnComV[c].Len(); i++) {
250        Top1UF.Union(CnComV[c][0], CnComV[c][i]); }
251    }
252  }
253  PNGraph TTop2FriendNet::GetTop1Net() {
254    PNGraph Top1Net = TNGraph::New();
255    for (int i = 0; i < Top2NIdH.Len(); i++) {
256      const int n1 = Top2NIdH.GetKey(i);
257      const int n2 = Top2NIdH[i].Val1;
258      if (n2 == -1) { continue; }
259      if (! Top1Net->IsNode(n1)) { Top1Net->AddNode(n1); }
260      if (! Top1Net->IsNode(n2)) { Top1Net->AddNode(n2); }
261      Top1Net->AddEdge(n1, n2);
262    }
263    return Top1Net;
264  }
265  int TTop2FriendNet::GetTop2WccSz(const double ProbPick2nd) const {
266    TUnionFind UF(Top1UF);
267    for (int n = 0; n < Top2NIdH.Len(); n++) {
268      if (TInt::Rnd.GetUniDev() <= ProbPick2nd && Top2NIdH[n].Val2 != -1) {
269        UF.Union(Top2NIdH.GetKey(n), Top2NIdH[n].Val2);
270      }
271    }
272    TIntH CcSzH;
273    for (int i = 0; i < UF.Len(); i++) {
274      CcSzH.AddDat(UF.Find(UF.GetKeyI(i))) += 1;
275    }
276    int MxCcSz = -1;
277    for (int c = 0; c < CcSzH.Len(); c++) {
278      if (CcSzH[c] > MxCcSz) { MxCcSz = CcSzH[c]; }
279    }
280    return MxCcSz;
281  }
282  int TTop2FriendNet::GetRnd2WccSz(const double ProbPick2nd) const {
283    TCnComV CnComV;
284    PNGraph G = TNGraph::New();
285    for (TWgtNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
286      if (NI.GetOutDeg() == 0) { continue; }
287      const int NId1 = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg()));
288      G->AddNode(NI.GetId());
289      G->AddNode(NId1);
290      G->AddEdge(NI.GetId(), NId1);
291      if (NI.GetOutDeg() > 1 && TInt::Rnd.GetUniDev() <= ProbPick2nd) {
292        int NId2 = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg()));
293        while (NId2 == NId1) { NId2 = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg())); }
294        G->AddNode(NId2);
295        G->AddEdge(NI.GetId(), NId2);
296      }
297    }
298    TCnCom::GetWccs(G, CnComV);
299    return CnComV[0].Len();
300  }
301  void TTop2FriendNet::GetAvgSDevV(const THash<TFlt, TMom>& MomH, TFltTrV& ValAvgSDevV) {
302    ValAvgSDevV.Clr(false);
303    for (int i = 0; i < MomH.Len(); i++) {
304      TMom Mom=MomH[i];
305      Mom.Def();
306      ValAvgSDevV.Add(TFltTr(MomH.GetKey(i), Mom.GetMean(), Mom.GetSDev()));
307    }
308    ValAvgSDevV.Sort();
309  }
310  void TTop2FriendNet::PlotPick2VsProb2nd(const PWgtNet& Net, const int& NRuns, const double& StepP, const TStr& OutFNm, 
311                                          TStr Desc, bool PlotTop2, bool PlotBtm2, bool PlotRnd2) {
312    TTop2FriendNet Top2(Net);  Net->MulEdgeWgt(-1.0); 
313    TTop2FriendNet Btm2(Net);  Net->MulEdgeWgt(-1.0); 
314    THash<TFlt, TMom> Top2H, Btm2H, Rnd2H;
315    for (int run = 0; run < NRuns; run++) {
316      TExeTm ExeTm;
317      printf("run %d\n", run);
318      for (double p = 0; p <= 1; p += StepP) {
319        if (PlotTop2) { Top2H.AddDat(p).Add(Top2.GetTop2WccSz(p)); }
320        if (PlotBtm2) { Btm2H.AddDat(p).Add(Btm2.GetTop2WccSz(p)); }
321        if (PlotRnd2) { Rnd2H.AddDat(p).Add(Top2.GetRnd2WccSz(p)); }
322        printf(".");
323      }
324      printf("[%s]\n", ExeTm.GetStr());
325      TFltTrV Top2V, Btm2V, Rnd2V;
326      GetAvgSDevV(Top2H, Top2V);
327      GetAvgSDevV(Btm2H, Btm2V);
328      GetAvgSDevV(Rnd2H, Rnd2V);
329      TGnuPlot GP("ccVsP-"+OutFNm, TStr::Fmt("%s (%d, %d, %f)", Desc.CStr(), Net->GetNodes(), 
330        Net->GetEdges(), Net->GetEdgeWgt()));
331      GP.SetXYLabel("Prob of taking 2nd edge", "Size of largest connected component");
332      if (! Top2V.Empty()) { GP.AddErrBar(Top2V, "TOP", ""); }
333      if (! Rnd2V.Empty()) { GP.AddErrBar(Rnd2V, "RND", ""); }
334      if (! Btm2V.Empty()) { GP.AddErrBar(Btm2V, "BTM", ""); }
335      GP.SavePng();
336    }
337  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cncom.h</h3>
            <pre><code>1  class TCnCom;
2  typedef TVec<TCnCom> TCnComV;
3  namespace TSnap {
4  template <class PGraph> void GetNodeWcc(const PGraph& Graph, const int& NId, TIntV& CnCom);
5  template <class PGraph> bool IsConnected(const PGraph& Graph);
6  template <class PGraph> bool IsWeaklyConn(const PGraph& Graph);
7  template <class PGraph> void GetWccSzCnt(const PGraph& Graph, TIntPrV& WccSzCnt);
8  template <class PGraph> void GetWccs(const PGraph& Graph, TCnComV& CnComV);
9  template <class PGraph> void GetSccSzCnt(const PGraph& Graph, TIntPrV& SccSzCnt);
10  template <class PGraph> void GetSccs(const PGraph& Graph, TCnComV& CnComV);
11  template <class PGraph> double GetMxWccSz(const PGraph& Graph);
12  template <class PGraph> double GetMxSccSz(const PGraph& Graph);
13  template <class PGraph> PGraph GetMxWcc(const PGraph& Graph);
14  template <class PGraph> PGraph GetMxScc(const PGraph& Graph);
15  template <class PGraph> PGraph GetMxBiCon(const PGraph& Graph);
16  void GetBiConSzCnt(const PUNGraph& Graph, TIntPrV& SzCntV);
17  void GetBiCon(const PUNGraph& Graph, TCnComV& BiCnComV);
18  void GetArtPoints(const PUNGraph& Graph, TIntV& ArtNIdV);
19  void GetEdgeBridges(const PUNGraph& Graph, TIntPrV& EdgeV);
20  void Get1CnComSzCnt(const PUNGraph& Graph, TIntPrV& SzCntV);
21  void Get1CnCom(const PUNGraph& Graph, TCnComV& Cn1ComV);
22  PUNGraph GetMxBiCon(const PUNGraph& Graph, const bool& RenumberNodes=false);
23  }; 
24  class TCnCom {
25  public:
26    TIntV NIdV;
27  public:
28    TCnCom() : NIdV() { }
29    TCnCom(const TIntV& NodeIdV) : NIdV(NodeIdV) { }
30    TCnCom(const TCnCom& CC) : NIdV(CC.NIdV) { }
31    TCnCom(TSIn& SIn) : NIdV(SIn) { }
32    void Save(TSOut& SOut) const { NIdV.Save(SOut); }
33    TCnCom& operator = (const TCnCom& CC) { if (this != &CC) NIdV = CC.NIdV;  return *this; }
34    bool operator == (const TCnCom& CC) const { return NIdV == CC.NIdV; }
35    bool operator < (const TCnCom& CC) const { return NIdV < CC.NIdV; }
36    int Len() const { return NIdV.Len(); }
37    bool Empty() const { return NIdV.Empty(); }
38    void Clr() { NIdV.Clr(); }
39    void Add(const int& NodeId) { NIdV.Add(NodeId); }
40    const TInt& operator [] (const int& NIdN) const { return NIdV[NIdN]; }
41    const TIntV& operator () () const { return NIdV; }
42    TIntV& operator () () { return NIdV; }
43    const TInt& GetVal(const int& NIdN) const { return operator[](NIdN); }
44    void Sort(const bool& Asc = true) { NIdV.Sort(Asc); }
45    bool IsNIdIn(const int& NId) const { return NIdV.SearchBin(NId) != -1; }
46    const TInt& GetRndNId() const { return NIdV[TInt::Rnd.GetUniDevInt(Len())]; }
47    static void Dump(const TCnComV& CnComV, const TStr& Desc=TStr());
48    static void SaveTxt(const TCnComV& CnComV, const TStr& FNm, const TStr& Desc=TStr());
49    template <class PGraph, class TVisitor>
50    static void GetDfsVisitor(const PGraph& Graph, TVisitor& Visitor);
51    int GetPrimHashCd() const { return NIdV.GetPrimHashCd(); }
52    int GetSecHashCd() const { return NIdV.GetSecHashCd(); }
53  };
54  template <class PGraph, class TVisitor>
55  void TCnCom::GetDfsVisitor(const PGraph& Graph, TVisitor& Visitor) {
56    const int Nodes = Graph->GetNodes();
57    TSStack<TIntTr> Stack(Nodes);
58    int edge=0, Deg=0, U=0;
59    TIntH ColorH(Nodes);
60    typename PGraph::TObj::TNodeI NI, UI;
61    for (NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
62      U = NI.GetId();
63      if (! ColorH.IsKey(U)) {         
64        ColorH.AddDat(U, 1); 
65        Visitor.DiscoverNode(U);       
66        Stack.Push(TIntTr(U, 0, Graph->GetNI(U).GetOutDeg()));
67        while (! Stack.Empty()) {
68          const TIntTr& Top = Stack.Top();
69          U=Top.Val1; edge=Top.Val2; Deg=Top.Val3;
70          typename PGraph::TObj::TNodeI UI = Graph->GetNI(U);
71          Stack.Pop();
72          while (edge != Deg) {
73            const int V = UI.GetOutNId(edge);
74            Visitor.ExamineEdge(U, V); 
75            if (! ColorH.IsKey(V)) {
76              Visitor.TreeEdge(U, V);  
77              Stack.Push(TIntTr(U, ++edge, Deg));
78              U = V;
79              ColorH.AddDat(U, 1); 
80              Visitor.DiscoverNode(U); 
81              UI = Graph->GetNI(U);
82              edge = 0;  Deg = UI.GetOutDeg();
83            }
84            else if (ColorH.GetDat(V) == 1) {
85              Visitor.BackEdge(U, V);  
86              ++edge; }
87            else {
88              Visitor.FwdEdge(U, V);   
89              ++edge; }
90          }
91          ColorH.AddDat(U, 2); 
92          Visitor.FinishNode(U);       
93        }
94      }
95    }
96  }
97  class TArtPointVisitor {
98  public:
99    THash<TInt, TIntPr> VnLowH;
100    THash<TInt, TInt> ParentH;
101    TIntSet ArtSet;
102    TInt Time;
103  public:
104    TArtPointVisitor() { }
105    TArtPointVisitor(const int& Nodes) : VnLowH(Nodes), ParentH(Nodes)  { }
106    void DiscoverNode(int NId) { Time++; VnLowH.AddDat(NId, TIntPr(Time, Time)); }
107    void FinishNode(const int& NId) {
108      if (! ParentH.IsKey(NId)) { return; }  const int Prn = ParentH.GetDat(NId);
109      VnLowH.GetDat(Prn).Val2 = TMath::Mn(VnLowH.GetDat(Prn).Val2, VnLowH.GetDat(NId).Val2);
110      if (VnLowH.GetDat(Prn).Val1==1 && VnLowH.GetDat(NId).Val1!=2) { ArtSet.AddKey(Prn); }
111      if (VnLowH.GetDat(Prn).Val1!=1 && VnLowH.GetDat(NId).Val2>=VnLowH.GetDat(Prn).Val1) { ArtSet.AddKey(Prn); } }
112    void ExamineEdge(const int& NId1, const int& NId2) { }
113    void TreeEdge(const int& NId1, const int& NId2) { ParentH.AddDat(NId2, NId1); }
114    void BackEdge(const int& NId1, const int& NId2) {
115      if (ParentH.IsKey(NId1) && ParentH.GetDat(NId1)!=NId2) {
116        VnLowH.GetDat(NId1).Val2 = TMath::Mn(VnLowH.GetDat(NId1).Val2, VnLowH.GetDat(NId2).Val1); } }
117    void FwdEdge(const int& NId1, const int& NId2) {
118      VnLowH.GetDat(NId1).Val2 = TMath::Mn(VnLowH.GetDat(NId1).Val2, VnLowH.GetDat(NId2).Val1); }
119  };
120  class TBiConVisitor {
121  public:
122    THash<TInt, TIntPr> VnLowH;
123    THash<TInt, TInt> ParentH;
124    TSStack<TIntPr> Stack;
125    TCnComV CnComV;
126    TIntSet NSet;
127    TInt Time;
128  public:
129    TBiConVisitor() { }
130    TBiConVisitor(const int& Nodes) : VnLowH(Nodes), ParentH(Nodes), Stack(Nodes) { }
131    void DiscoverNode(int NId) { Time++; VnLowH.AddDat(NId, TIntPr(Time, Time)); }
132    void FinishNode(const int& NId) {
133      if (! ParentH.IsKey(NId)) { return; }  const int Prn = ParentH.GetDat(NId);
134      VnLowH.GetDat(Prn).Val2 = TMath::Mn(VnLowH.GetDat(Prn).Val2, VnLowH.GetDat(NId).Val2);
135      if (VnLowH.GetDat(NId).Val2 >= VnLowH.GetDat(Prn).Val1) {
136        NSet.Clr(false);
137        while (! Stack.Empty() && Stack.Top() != TIntPr(Prn, NId)) {
138          const TIntPr& Top = Stack.Top();
139          NSet.AddKey(Top.Val1);  NSet.AddKey(Top.Val2); Stack.Pop();  }
140        if (! Stack.Empty()) {
141          const TIntPr& Top = Stack.Top();
142          NSet.AddKey(Top.Val1);  NSet.AddKey(Top.Val2); Stack.Pop(); }
143        TIntV NIdV; NSet.GetKeyV(NIdV);  NIdV.Sort();
144        CnComV.Add(NIdV); } }
145    void ExamineEdge(const int& NId1, const int& NId2) { }
146    void TreeEdge(const int& NId1, const int& NId2) {
147      ParentH.AddDat(NId2, NId1);
148      Stack.Push(TIntPr(NId1, NId2)); }
149    void BackEdge(const int& NId1, const int& NId2) {
150      if (ParentH.IsKey(NId1) && ParentH.GetDat(NId1)!=NId2) {
151        Stack.Push(TIntPr(NId1, NId2));
152        VnLowH.GetDat(NId1).Val2 = TMath::Mn(VnLowH.GetDat(NId1).Val2, VnLowH.GetDat(NId2).Val1); } }
153    void FwdEdge(const int& NId1, const int& NId2) { }
154  };
155  template <class PGraph, bool OnlyCount = false>
156  class TSccVisitor {
157  public:
158    PGraph Graph;
159    THash<TInt, TIntPr> TmRtH;
160    TSStack<TInt> Stack;
161    TInt Time;
162    TIntH SccCntH;
163    TCnComV CnComV;
164  public:
165    TSccVisitor(const PGraph& _Graph) :
166        Graph(_Graph), TmRtH(Graph->GetNodes()), Stack(Graph->GetNodes()) { }
167    void DiscoverNode(int NId) {
168      Time++; TmRtH.AddDat(NId, TIntPr(-Time, NId)); 
169      Stack.Push(NId); }
170    void FinishNode(const int& NId) {
171      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
172      TIntPr& TmRtN = TmRtH.GetDat(NId);
173      int W = -1, Cnt = 0;
174      for (int i = 0; i < NI.GetOutDeg(); i++) {
175        W = NI.GetOutNId(i);
176        const TIntPr& TmRtW = TmRtH.GetDat(W);
177        if (TmRtW.Val1 < 0) { 
178          TmRtN.Val2 = GetMinDiscTm(TmRtN.Val2, TmRtW.Val2); } }
179      if (TmRtN.Val2 == NId) {
180        if (! OnlyCount) { CnComV.Add(); }
181        do { W = Stack.Top();  Stack.Pop();
182        if (OnlyCount) { Cnt++; } else { CnComV.Last().Add(W); }
183        TmRtH.GetDat(W).Val1 = abs(TmRtH.GetDat(W).Val1); 
184        } while (W != NId);
185        if (OnlyCount) { SccCntH.AddDat(Cnt) += 1; } } }
186    void ExamineEdge(const int& NId1, const int& NId2) { }
187    void TreeEdge(const int& NId1, const int& NId2) { }
188    void BackEdge(const int& NId1, const int& NId2) { }
189    void FwdEdge(const int& NId1, const int& NId2) { }
190    int GetMinDiscTm(const int& NId1, const int& NId2) const {
191      return abs(TmRtH.GetDat(NId1).Val1) < abs(TmRtH.GetDat(NId2).Val1) ? NId1 : NId2; }
192  };
193  namespace TSnap {
194  template <class PGraph> 
195  void GetNodeWcc(const PGraph& Graph, const int& NId, TIntV& CnCom) {
196    typename PGraph::TObj::TNodeI NI;
197    THashSet<TInt> VisitedNId(Graph->GetNodes()+1);
198    TSnapQueue<int> NIdQ(Graph->GetNodes()+1);
199    VisitedNId.AddKey(NId);
200    NIdQ.Push(NId);
201    while (! NIdQ.Empty()) {
202      const typename PGraph::TObj::TNodeI Node = Graph->GetNI(NIdQ.Top());  NIdQ.Pop();
203      if (HasGraphFlag(typename PGraph::TObj, gfDirected)) {
204        for (int e = 0; e < Node.GetInDeg(); e++) {
205          const int InNId = Node.GetInNId(e);
206          if (! VisitedNId.IsKey(InNId)) {
207            NIdQ.Push(InNId);  VisitedNId.AddKey(InNId); }
208        }
209      }
210      for (int e = 0; e < Node.GetOutDeg(); e++) {
211        const int OutNId = Node.GetOutNId(e);
212        if (! VisitedNId.IsKey(OutNId)) {
213          NIdQ.Push(OutNId);  VisitedNId.AddKey(OutNId); }
214      }
215    }
216    CnCom.Gen(VisitedNId.Len(), 0);
217    for (int i = 0; i < VisitedNId.Len(); i++) {
218      CnCom.Add(VisitedNId.GetKey(i));
219    }
220  }
221  template <class PGraph> 
222  bool IsConnected(const PGraph& Graph) {
223    return IsWeaklyConn(Graph);
224  }
225  template <class PGraph>
226  bool IsWeaklyConn(const PGraph& Graph) {
227    if (Graph->Empty()) {
228      return true;
229    }
230    THashSet<TInt> VisitedNId(Graph->GetNodes());
231    TSnapQueue<int> NIdQ(Graph->GetNodes()+1);
232    typename PGraph::TObj::TNodeI NI;
233    NIdQ.Push(Graph->BegNI().GetId());
234    while (! NIdQ.Empty()) {
235      const typename PGraph::TObj::TNodeI Node = Graph->GetNI(NIdQ.Top());  NIdQ.Pop();
<span onclick='openModal()' class='match'>236      if (HasGraphFlag(typename PGraph::TObj, gfDirected)) {
237        for (int e = 0; e < Node.GetInDeg(); e++) {
238          const int InNId = Node.GetInNId(e);
</span>239          if (! VisitedNId.IsKey(InNId)) { NIdQ.Push(InNId);  VisitedNId.AddKey(InNId); }
240        }
241      }
242      for (int e = 0; e < Node.GetOutDeg(); e++) {
243        const int OutNId = Node.GetOutNId(e);
244        if (! VisitedNId.IsKey(OutNId)) { NIdQ.Push(OutNId);  VisitedNId.AddKey(OutNId); }
245      }
246    }
247    if (VisitedNId.Len() < Graph->GetNodes()) { return false; }
248    return true;
249  }
250  template <class PGraph>
251  void GetWccSzCnt(const PGraph& Graph, TIntPrV& WccSzCnt) {
252    THashSet<TInt> VisitedNId(Graph->GetNodes());
253    TIntH SzToCntH;
254    TSnapQueue<int> NIdQ(Graph->GetNodes()+1);
255    typename PGraph::TObj::TNodeI NI;
256    int Cnt = 0;
257    for (NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
258      if (NI.GetDeg() == 0) { Cnt++;  VisitedNId.AddKey(NI.GetId()); }
259    }
260    if (Cnt > 0) SzToCntH.AddDat(1, Cnt);
261    for (NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
262      if (! VisitedNId.IsKey(NI.GetId())) {
263        VisitedNId.AddKey(NI.GetId());
264        NIdQ.Clr(false);  NIdQ.Push(NI.GetId());
265        Cnt = 0;
266        while (! NIdQ.Empty()) {
267          const typename PGraph::TObj::TNodeI Node = Graph->GetNI(NIdQ.Top());  NIdQ.Pop();
268          if (HasGraphFlag(typename PGraph::TObj, gfDirected)) {
269            for (int e = 0; e < Node.GetInDeg(); e++) {
270              const int InNId = Node.GetInNId(e);
271              if (! VisitedNId.IsKey(InNId)) { NIdQ.Push(InNId);  VisitedNId.AddKey(InNId); }
272            }
273          }
274          for (int e = 0; e < Node.GetOutDeg(); e++) {
275            const int OutNId = Node.GetOutNId(e);
276            if (! VisitedNId.IsKey(OutNId)) { NIdQ.Push(OutNId);  VisitedNId.AddKey(OutNId); }
277          }
278          Cnt++;
279        }
280        SzToCntH.AddDat(Cnt) += 1;
281      }
282    }
283    SzToCntH.GetKeyDatPrV(WccSzCnt);
284    WccSzCnt.Sort(true);
285  }
286  template <class PGraph>
287  void GetWccs(const PGraph& Graph, TCnComV& CnComV) {
288    typename PGraph::TObj::TNodeI NI;
289    THashSet<TInt> VisitedNId(Graph->GetNodes()+1);
290    TSnapQueue<int> NIdQ(Graph->GetNodes()+1);
291    TIntV CcNIdV;
292    CnComV.Clr();  CcNIdV.Gen(1);
293    for (NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
294      if (NI.GetDeg() == 0) {
295        const int NId = NI.GetId();
296        VisitedNId.AddKey(NId);
297        CcNIdV[0] = NId;  CnComV.Add(CcNIdV);
298      }
299    }
300    for (NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
301      const int NId = NI.GetId();
302      if (! VisitedNId.IsKey(NId)) {
303        VisitedNId.AddKey(NId);
304        NIdQ.Clr(false);  NIdQ.Push(NId);
305        CcNIdV.Clr();  CcNIdV.Add(NId);
306        while (! NIdQ.Empty()) {
307          const typename PGraph::TObj::TNodeI Node = Graph->GetNI(NIdQ.Top());  NIdQ.Pop();
308          if (HasGraphFlag(typename PGraph::TObj, gfDirected)) {
309            for (int e = 0; e < Node.GetInDeg(); e++) {
310              const int InNId = Node.GetInNId(e);
311              if (! VisitedNId.IsKey(InNId)) {
312                NIdQ.Push(InNId);  VisitedNId.AddKey(InNId);  CcNIdV.Add(InNId); }
313            }
314          }
315          for (int e = 0; e < Node.GetOutDeg(); e++) {
316            const int OutNId = Node.GetOutNId(e);
317            if (! VisitedNId.IsKey(OutNId)) {
318              NIdQ.Push(OutNId);  VisitedNId.AddKey(OutNId);  CcNIdV.Add(OutNId); }
319          }
320        }
321        CcNIdV.Sort(true);
322        CnComV.Add(TCnCom(CcNIdV)); 
323      }
324    }
325    CnComV.Sort(false);
326  }
327  template <class PGraph>
328  void GetSccSzCnt(const PGraph& Graph, TIntPrV& SccSzCnt) {
329    TSccVisitor<PGraph, true> Visitor(Graph);
330    TCnCom::GetDfsVisitor(Graph, Visitor);
331    Visitor.SccCntH.GetKeyDatPrV(SccSzCnt);
332    SccSzCnt.Sort(true);
333  }
334  template <class PGraph>
335  void GetSccs(const PGraph& Graph, TCnComV& CnComV) {
336    TSccVisitor<PGraph, false> Visitor(Graph);
337    TCnCom::GetDfsVisitor(Graph, Visitor);
338    CnComV = Visitor.CnComV;
339    CnComV.Sort(false);
340  }
341  template <class PGraph> 
342  double GetMxWccSz(const PGraph& Graph) {
343    TCnComV CnComV;
344    GetWccs(Graph, CnComV);
345    if (Graph->GetNodes() == 0) { return 0; }
346    else { return CnComV[0].Len() / double(Graph->GetNodes()); }
347  }
348  template <class PGraph>
349  double GetMxSccSz(const PGraph& Graph) {
350    TCnComV CnComV;
351    GetSccs(Graph, CnComV);
352    if (Graph->GetNodes() == 0) { return 0; }
353    else { return CnComV[0].Len() / double(Graph->GetNodes()); }
354  }
355  template <class PGraph>
356  PGraph GetMxWcc(const PGraph& Graph) {
357    TCnComV CnComV;
358    GetWccs(Graph, CnComV);
359    if (CnComV.Empty()) { return PGraph::TObj::New(); }
360    int CcId = 0, MxSz = 0;
361    for (int i = 0; i < CnComV.Len(); i++) {
362      if (MxSz < CnComV[i].Len()) {
363        MxSz=CnComV[i].Len();  CcId=i; }
364    }
365    if (CnComV[CcId].Len()==Graph->GetNodes()) { 
366      return Graph; }
367    else { 
368      return TSnap::GetSubGraph(Graph, CnComV[CcId]()); 
369    }
370  }
371  template <class PGraph>
372  PGraph GetMxScc(const PGraph& Graph) {
373    TCnComV CnComV;
374    GetSccs(Graph, CnComV);
375    if (CnComV.Empty()) { return PGraph::TObj::New(); }
376    int CcId = 0, MxSz = 0;
377    for (int i = 0; i < CnComV.Len(); i++) {
378      if (MxSz < CnComV[i].Len()) {
379        MxSz=CnComV[i].Len();  CcId=i; }
380    }
381    if (CnComV[CcId].Len()==Graph->GetNodes()) { 
382      return Graph; }
383    else { 
384      return TSnap::GetSubGraph(Graph, CnComV[CcId]()); 
385    }
386  }
387  template <class PGraph>
388  PGraph GetMxBiCon(const PGraph& Graph) {
389    TCnComV CnComV;
390    GetBiCon(TSnap::ConvertGraph<PUNGraph, PGraph>(Graph), CnComV);
391    if (CnComV.Empty()) { return PGraph::TObj::New(); }
392    int CcId = 0, MxSz = 0;
393    for (int i = 0; i < CnComV.Len(); i++) {
394      if (MxSz < CnComV[i].Len()) {
395        MxSz=CnComV[i].Len();  CcId=i; }
396    }
397    if (CnComV[CcId].Len()==Graph->GetNodes()) { 
398      return Graph; }
399    else { 
400      return TSnap::GetSubGraph(Graph, CnComV[CcId]()); 
401    }
402  }
403  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wgtnet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cncom.h</div>
                </div>
                <div class="column column_space"><pre><code>165    for (int c = 0; Dblp.Next(); c++) {
166      for (int a1 = 0; a1 < Dblp.AuthorV.Len(); a1++) {
167        const int n1 = AuthorSet.AddKey(Dblp.AuthorV[a1]);
</pre></code></div>
                <div class="column column_space"><pre><code>236      if (HasGraphFlag(typename PGraph::TObj, gfDirected)) {
237        for (int e = 0; e < Node.GetInDeg(); e++) {
238          const int InNId = Node.GetInNId(e);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    