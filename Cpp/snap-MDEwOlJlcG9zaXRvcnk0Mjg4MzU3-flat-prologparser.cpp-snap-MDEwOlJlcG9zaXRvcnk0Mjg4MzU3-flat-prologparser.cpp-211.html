
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-prologparser.cpp</h3>
            <pre><code>1  #include &quot;prologparser.h&quot;
2  TPlChDef::TPlChDef(){
3    ChTypeV.Gen(TPlChDef::MxChar-TPlChDef::MnChar+1);
4    IAssert(TPlChDef::MnChar==0); IAssert(TPlChDef::MxChar==255);
5    for (int Ch=MnChar; Ch&lt;=MxChar; Ch++){ChTypeV[Ch]=plctUnDef;}
6    for (int Ch=MnChar; Ch&lt;=&#x27; &#x27;; Ch++){ChTypeV[Ch]=plctBl;}
7    ChTypeV[EofCh]=plctEof;
8    ChTypeV[&#x27;!&#x27;]=plctSolo;
9    ChTypeV[&#x27;&quot;&#x27;]=plctDQuo;
10    ChTypeV[&#x27;#&#x27;]=plctSym;
11    ChTypeV[&#x27;$&#x27;]=plctSym;
12    ChTypeV[&#x27;%&#x27;]=plctComm;
13    ChTypeV[&#x27;&amp;&#x27;]=plctSym;
14    ChTypeV[&#x27;\&#x27;&#x27;]=plctSQuo;
15    ChTypeV[&#x27;(&#x27;]=plctMeta;
16    ChTypeV[&#x27;)&#x27;]=plctMeta;
17    ChTypeV[&#x27;*&#x27;]=plctSym;
18    ChTypeV[&#x27;+&#x27;]=plctSym;
19    ChTypeV[&#x27;,&#x27;]=plctSolo;
20    ChTypeV[&#x27;-&#x27;]=plctSym;
21    ChTypeV[&#x27;.&#x27;]=plctSym;
22    ChTypeV[&#x27;/&#x27;]=plctSym;
23    for (int Ch=&#x27;0&#x27;; Ch&lt;=&#x27;9&#x27;; Ch++){ChTypeV[Ch]=plctNum;}
24    ChTypeV[&#x27;:&#x27;]=plctSym;
25    ChTypeV[&#x27;;&#x27;]=plctSolo;
26    ChTypeV[&#x27;&lt;&#x27;]=plctSym;
27    ChTypeV[&#x27;=&#x27;]=plctSym;
28    ChTypeV[&#x27;&gt;&#x27;]=plctSym;
29    ChTypeV[&#x27;?&#x27;]=plctSym;
30    ChTypeV[&#x27;@&#x27;]=plctSym;
31    for (int Ch=&#x27;A&#x27;; Ch&lt;=&#x27;Z&#x27;; Ch++){ChTypeV[Ch]=plctUpCs;}
32    ChTypeV[&#x27;[&#x27;]=plctMeta;
33    ChTypeV[&#x27;\\&#x27;]=plctSym;
34    ChTypeV[&#x27;]&#x27;]=plctMeta;
35    ChTypeV[&#x27;^&#x27;]=plctSym;
36    ChTypeV[&#x27;_&#x27;]=plctUnderLn;
37    ChTypeV[&#x27;`&#x27;]=plctSym;
38    for (int Ch=&#x27;a&#x27;; Ch&lt;=&#x27;z&#x27;; Ch++){ChTypeV[Ch]=plctLwCs;}
39    ChTypeV[&#x27;{&#x27;]=plctMeta;
40    ChTypeV[&#x27;|&#x27;]=plctMeta;
41    ChTypeV[&#x27;}&#x27;]=plctMeta;
42    ChTypeV[&#x27;~&#x27;]=plctSym;
43    ChTypeV[DelCh]=plctBl;
44    IdChPV.Gen(MxChar-MnChar+1);
45    for (int Ch=MnChar; Ch&lt;=MxChar; Ch++){IdChPV[Ch]=false;}
46    for (int Ch=&#x27;0&#x27;; Ch&lt;=&#x27;9&#x27;; Ch++){IdChPV[Ch]=true;}
47    for (int Ch=&#x27;A&#x27;; Ch&lt;=&#x27;Z&#x27;; Ch++){IdChPV[Ch]=true;}
48    IdChPV[&#x27;_&#x27;]=true;
49    for (int Ch=&#x27;a&#x27;; Ch&lt;=&#x27;z&#x27;; Ch++){IdChPV[Ch]=true;}
50    ChEscChPV.Gen(MxChar-MnChar+1);
51    for (int Ch=MnChar; Ch&lt;=MxChar; Ch++){ChEscChPV[Ch]=false;}
52    ChEscChPV[HTabCh]=true;
53    ChEscChPV[&#x27; &#x27;]=true;
54    for (int Ch=MnPrintableCh; Ch&lt;=MxPrintableCh; Ch++){ChEscChPV[Ch]=true;}
55  }
56  void TPlAtomDef::SetOp(const TPlOpType&amp; OpType, const uint&amp; OpPrec){
57    switch (OpType){
58      case plot_fx: (AtomFSet&amp;=AFlgOpPrefixReset)|=AFlgOp_fx; PrefixOpPrec=OpPrec; break;
59      case plot_fy: (AtomFSet&amp;=AFlgOpPrefixReset)|=AFlgOp_fy; PrefixOpPrec=OpPrec; break;
60      case plot_yfx: (AtomFSet&amp;=AFlgOpInfixReset)|=AFlgOp_yfx; InfixOpPrec=OpPrec; break;
61      case plot_xfx: (AtomFSet&amp;=AFlgOpInfixReset)|=AFlgOp_xfx; InfixOpPrec=OpPrec; break;
62      case plot_xfy: (AtomFSet&amp;=AFlgOpInfixReset)|=AFlgOp_xfy; InfixOpPrec=OpPrec; break;
63      case plot_xf: (AtomFSet&amp;=AFlgOpPostfixReset)|=AFlgOp_xf; PostfixOpPrec=OpPrec; break;
64      case plot_yf: (AtomFSet&amp;=AFlgOpPostfixReset)|=AFlgOp_yf; PostfixOpPrec=OpPrec; break;
65      default: Fail;
66    }
67  }
68  void TPlAtomBs::PrepImpAtoms(){
69    ImpAtomIdV.Gen(plaMx);
70    ImpAtomIdV[pla_Impl]=AddAtomStr(&quot;:-&quot;);
71    ImpAtomIdV[pla_ImplDCG]=AddAtomStr(&quot;--&gt;&quot;);
72    ImpAtomIdV[pla_Query]=AddAtomStr(&quot;?-&quot;);
73    ImpAtomIdV[pla_Mode]=AddAtomStr(&quot;mode&quot;);
74    ImpAtomIdV[pla_Public]=AddAtomStr(&quot;public&quot;);
75    ImpAtomIdV[pla_Dynamic]=AddAtomStr(&quot;dynamic&quot;);
76    ImpAtomIdV[pla_MultiFile]=AddAtomStr(&quot;multifile&quot;);
77    ImpAtomIdV[pla_MetaPredicate]=AddAtomStr(&quot;meta_predicate&quot;);
78    ImpAtomIdV[pla_Semicolon]=AddAtomStr(&quot;;&quot;);
79    ImpAtomIdV[pla_VerticalBar]=AddAtomStr(&quot;|&quot;);
80    ImpAtomIdV[pla_If]=AddAtomStr(&quot;-&gt;&quot;);
81    ImpAtomIdV[pla_Comma]=AddAtomStr(&quot;,&quot;);
82    ImpAtomIdV[pla_Not]=AddAtomStr(&quot;\\+&quot;);
83    ImpAtomIdV[pla_Spy]=AddAtomStr(&quot;spy&quot;);
84    ImpAtomIdV[pla_NoSpy]=AddAtomStr(&quot;nospy&quot;);
85    ImpAtomIdV[pla_Unify]=AddAtomStr(&quot;=&quot;);
86    ImpAtomIdV[pla_Is]=AddAtomStr(&quot;is&quot;);
87    ImpAtomIdV[pla_Uni]=AddAtomStr(&quot;=..&quot;);
88    ImpAtomIdV[pla_Identical]=AddAtomStr(&quot;==&quot;);
89    ImpAtomIdV[pla_NotIdentical]=AddAtomStr(&quot;\\==&quot;);
90    ImpAtomIdV[pla_SOLess]=AddAtomStr(&quot;@&lt;&quot;);
91    ImpAtomIdV[pla_SOGreater]=AddAtomStr(&quot;@&gt;&quot;);
92    ImpAtomIdV[pla_SOLessOrEqual]=AddAtomStr(&quot;@=&lt;&quot;);
93    ImpAtomIdV[pla_SOGreaterOrEqual]=AddAtomStr(&quot;@&gt;=&quot;);
94    ImpAtomIdV[pla_AEqual]=AddAtomStr(&quot;=:=&quot;);
95    ImpAtomIdV[pla_ANotEqual]=AddAtomStr(&quot;=\\=&quot;);
96    ImpAtomIdV[pla_ALess]=AddAtomStr(&quot;&lt;&quot;);
97    ImpAtomIdV[pla_AGreater]=AddAtomStr(&quot;&gt;&quot;);
98    ImpAtomIdV[pla_ALessOrEqual]=AddAtomStr(&quot;=&lt;&quot;);
99    ImpAtomIdV[pla_AGreaterOrEqual]=AddAtomStr(&quot;&gt;=&quot;);
100    ImpAtomIdV[pla_Colon]=AddAtomStr(&quot;:&quot;);
101    ImpAtomIdV[pla_Plus]=AddAtomStr(&quot;+&quot;);
102    ImpAtomIdV[pla_Minus]=AddAtomStr(&quot;-&quot;);
103    ImpAtomIdV[pla_BitOr]=AddAtomStr(&quot;\\/&quot;);
104    ImpAtomIdV[pla_BitAnd]=AddAtomStr(&quot;/\\&quot;);
105    ImpAtomIdV[pla_Divide]=AddAtomStr(&quot;/&quot;);
106    ImpAtomIdV[pla_IntDivide]=AddAtomStr(&quot;&amp;bsol;&amp;bsol;&quot;);
107    ImpAtomIdV[pla_Times]=AddAtomStr(&quot;*&quot;);
108    ImpAtomIdV[pla_ShiftLeft]=AddAtomStr(&quot;&lt;&lt;&quot;);
109    ImpAtomIdV[pla_ShiftRight]=AddAtomStr(&quot;&gt;&gt;&quot;);
110    ImpAtomIdV[pla_Mod]=AddAtomStr(&quot;mod&quot;);
111    ImpAtomIdV[pla_ExistQuantifier]=AddAtomStr(&quot;^&quot;);
112    ImpAtomIdV[pla_ExclPoint]=AddAtomStr(&quot;!&quot;);
113    ImpAtomIdV[pla_EmptyList]=AddAtomStr(&quot;[]&quot;);
114    ImpAtomIdV[pla_EmptyBrace]=AddAtomStr(&quot;{}&quot;);
115    ImpAtomIdV[pla_EmptyParen]=AddAtomStr(&quot;()&quot;);
116    ImpAtomIdV[pla_Period]=AddAtomStr(&quot;.&quot;);
117    ImpAtomIdV[pla_VAR_N]=AddAtomStr(&quot;$VAR&quot;);
118    ImpAtomIdV[pla_EndOfFile]=AddAtomStr(&quot;end_of_file&quot;);
119    GetAtomDef(ImpAtomIdV[pla_Impl]).SetOp(plot_xfx, 1200);
120    GetAtomDef(ImpAtomIdV[pla_ImplDCG]).SetOp(plot_xfx, 1200);
121    GetAtomDef(ImpAtomIdV[pla_Impl]).SetOp(plot_fx, 1200);
122    GetAtomDef(ImpAtomIdV[pla_Query]).SetOp(plot_fx, 1200);
123    GetAtomDef(ImpAtomIdV[pla_Mode]).SetOp(plot_fx, 1150);
124    GetAtomDef(ImpAtomIdV[pla_Public]).SetOp(plot_fx, 1150);
125    GetAtomDef(ImpAtomIdV[pla_Dynamic]).SetOp(plot_fx, 1150);
126    GetAtomDef(ImpAtomIdV[pla_MultiFile]).SetOp(plot_fx, 1150);
127    GetAtomDef(ImpAtomIdV[pla_MetaPredicate]).SetOp(plot_fx, 1150);
128    GetAtomDef(ImpAtomIdV[pla_Semicolon]).SetOp(plot_xfy, 1100);
129    GetAtomDef(ImpAtomIdV[pla_VerticalBar]).SetOp(plot_xfy, 1100);
130    GetAtomDef(ImpAtomIdV[pla_If]).SetOp(plot_xfy, 1050);
131    GetAtomDef(ImpAtomIdV[pla_Comma]).SetOp(plot_xfy, 1000);
132    GetAtomDef(ImpAtomIdV[pla_Not]).SetOp(plot_fy, 900);
133    GetAtomDef(ImpAtomIdV[pla_Spy]).SetOp(plot_fy, 900);
134    GetAtomDef(ImpAtomIdV[pla_NoSpy]).SetOp(plot_fy, 900);
135    GetAtomDef(ImpAtomIdV[pla_Unify]).SetOp(plot_xfx, 700);
136    GetAtomDef(ImpAtomIdV[pla_Is]).SetOp(plot_xfx, 700);
137    GetAtomDef(ImpAtomIdV[pla_Uni]).SetOp(plot_xfx, 700);
138    GetAtomDef(ImpAtomIdV[pla_Identical]).SetOp(plot_xfx, 700);
139    GetAtomDef(ImpAtomIdV[pla_NotIdentical]).SetOp(plot_xfx, 700);
140    GetAtomDef(ImpAtomIdV[pla_SOLess]).SetOp(plot_xfx, 700);
141    GetAtomDef(ImpAtomIdV[pla_SOGreater]).SetOp(plot_xfx, 700);
142    GetAtomDef(ImpAtomIdV[pla_SOLessOrEqual]).SetOp(plot_xfx, 700);
143    GetAtomDef(ImpAtomIdV[pla_SOGreaterOrEqual]).SetOp(plot_xfx, 700);
144    GetAtomDef(ImpAtomIdV[pla_AEqual]).SetOp(plot_xfx, 700);
145    GetAtomDef(ImpAtomIdV[pla_ANotEqual]).SetOp(plot_xfx, 700);
146    GetAtomDef(ImpAtomIdV[pla_ALess]).SetOp(plot_xfx, 700);
147    GetAtomDef(ImpAtomIdV[pla_AGreater]).SetOp(plot_xfx, 700);
148    GetAtomDef(ImpAtomIdV[pla_ALessOrEqual]).SetOp(plot_xfx, 700);
149    GetAtomDef(ImpAtomIdV[pla_AGreaterOrEqual]).SetOp(plot_xfx, 700);
150    GetAtomDef(ImpAtomIdV[pla_Colon]).SetOp(plot_xfy, 600);
151    GetAtomDef(ImpAtomIdV[pla_Plus]).SetOp(plot_yfx, 500);
152    GetAtomDef(ImpAtomIdV[pla_Minus]).SetOp(plot_yfx, 500);
153    GetAtomDef(ImpAtomIdV[pla_BitOr]).SetOp(plot_yfx, 500);
154    GetAtomDef(ImpAtomIdV[pla_BitAnd]).SetOp(plot_yfx, 500);
155    GetAtomDef(ImpAtomIdV[pla_Plus]).SetOp(plot_fx, 500);
156    GetAtomDef(ImpAtomIdV[pla_Minus]).SetOp(plot_fx, 500);
157    GetAtomDef(ImpAtomIdV[pla_Divide]).SetOp(plot_yfx, 400);
158    GetAtomDef(ImpAtomIdV[pla_IntDivide]).SetOp(plot_yfx, 400);
159    GetAtomDef(ImpAtomIdV[pla_Times]).SetOp(plot_yfx, 400);
160    GetAtomDef(ImpAtomIdV[pla_ShiftLeft]).SetOp(plot_yfx, 400);
161    GetAtomDef(ImpAtomIdV[pla_ShiftRight]).SetOp(plot_yfx, 400);
162    GetAtomDef(ImpAtomIdV[pla_Mod]).SetOp(plot_xfx, 300);
163    GetAtomDef(ImpAtomIdV[pla_ExistQuantifier]).SetOp(plot_xfy, 200);
164  }
165  TPlAtomBs::TPlAtomBs():
166    StrToAtomDefH(), ImpAtomIdV(){
167    PrepImpAtoms();
168  }
169  TPlLx::TPlLx(const PSIn&amp; _SIn, const PPlAtomBs&amp; _AtomBs, const PPlVarBs&amp; _VarBs):
170    ChDef(), SIn(_SIn), RSIn(*SIn),
171    CCh(&#x27; &#x27;), NCh(&#x27; &#x27;), ChX(0), ChEscBf(), ChType(plctBl), Sym(plstUndef),
172    AtomBs(_AtomBs), VarBs(_VarBs){}
173  void TPlLx::EThrow(const TStr&amp; MsgStr) const {
174    TChA FPosChA;
175    FPosChA+=&quot; [File:&quot;; FPosChA+=SIn-&gt;GetSNm();
176    FPosChA+=&quot; Char:&quot;; FPosChA+=TInt::GetStr(ChX);
177    FPosChA+=&quot;]&quot;;
178    TStr FullMsgStr=MsgStr+FPosChA;
179    TExcept::Throw(FullMsgStr);
180  }
181  void TPlLx::SkipComment(){
182    while (!((CCh==&#x27;*&#x27;)&amp;&amp;(NCh==&#x27;/&#x27;))){
183      if ((CCh==&#x27;/&#x27;)&amp;&amp;(NCh==&#x27;*&#x27;)){
184        GetCh(); GetCh(); SkipComment();
185      } else {
186        GetCh();
187        if (CCh==TPlChDef::EofCh){EThrow(&quot;Comment not concluded with &#x27;*/&#x27;&quot;);}
188      }
189    }
190    GetCh(); GetCh();
191  }
192  void TPlLx::SkipWs(){
193    forever {
194      while (ChType==plctBl){GetCh();}
195      if ((CCh==&#x27;/&#x27;)&amp;&amp;(NCh==&#x27;*&#x27;)){
196        GetCh(); GetCh(); SkipComment();
197      } else
198      if (CCh==&#x27;%&#x27;){
199        forever{
200          GetCh();
201          if ((CCh==TPlChDef::CrCh)||(CCh==TPlChDef::LfCh)||(CCh==TPlChDef::EofCh)){break;}
202        }
203        if (CCh==TPlChDef::EofCh){break;} else {GetCh();}
204      } else {
205        break;
206      }
207    }
208  }
209  void TPlLx::GetChEscBf(){
210    ChEscBf.Clr(); GetCh();
211    switch (toupper(CCh)){
212      case &#x27;B&#x27;: ChEscBf+=TPlChDef::BsCh; GetCh(); break;
213      case &#x27;T&#x27;: ChEscBf+=TPlChDef::HTabCh; GetCh(); break;
214      case &#x27;N&#x27;: ChEscBf+=TPlChDef::LfCh; GetCh(); break;
215      case &#x27;V&#x27;: ChEscBf+=TPlChDef::VTabCh; GetCh(); break;
216      case &#x27;F&#x27;: ChEscBf+=TPlChDef::FfCh; GetCh(); break;
217      case &#x27;R&#x27;: ChEscBf+=TPlChDef::CrCh; GetCh(); break;
218      case &#x27;E&#x27;: ChEscBf+=TPlChDef::EscCh; GetCh(); break;
219      case &#x27;D&#x27;: ChEscBf+=TPlChDef::DelCh; GetCh(); break;
220      case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;:
221      case &#x27;4&#x27;: case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: 
222        {int Cd=0; int Chs=0;
223        forever{
224          Chs++;
225          Cd=Cd*8+(CCh-48);
226          if (Cd&gt;TPlChDef::MxChar){EThrow(&quot;Octal number overflow&quot;);}
227          GetCh();
228          if ((Chs==3)||(CCh&lt;&#x27;0&#x27;)||(CCh&gt;&#x27;7&#x27;)){break;}
229        }
230        ChEscBf+=char(Cd); GetCh(); break;}
231      case &#x27;^&#x27;: 
232        GetCh();
233        if ((CCh&lt;&#x27;@&#x27;)||(CCh&gt;&#x27;_&#x27;)){
234          EThrow(&quot;Invalid escaped control character&quot;);}
235        ChEscBf+=CCh-&#x27;@&#x27;; GetCh(); break;
236      case &#x27;C&#x27; : 
237        forever{
238          GetCh();
239          if (CCh==TPlChDef::EofCh){EThrow(&quot;Unexpected end-of-file&quot;);}
240          if ((CCh&gt;=TPlChDef::MnPrintableCh)&amp;&amp;(CCh&lt;=TPlChDef::MxPrintableCh)){
241            break;}
242        }
243      default:
244        ChEscBf+=CCh; GetCh(); break;
245    }
246  }
247  void TPlLx::GetVar(){
248    Sym=plsyVar; ChA.Clr();
249    do {
250      ChA+=CCh; GetCh();
251    } while (ChDef.IsIdCh(CCh));
252    VarId=VarBs-&gt;AddVarStr(ChA);
253  }
254  void TPlLx::GetAtomNm(){
255    Sym=plsyAtom; ChA.Clr();
256    do {
257      ChA+=CCh; GetCh();
258    } while (ChDef.IsIdCh(CCh));
259    if (CCh==&#x27;(&#x27;){GetCh(); Sym=plsyFAtom;}
260    AtomId=AtomBs-&gt;AddAtomStr(ChA);
261  }
262  void TPlLx::GetAtomSym(){
263    Sym=plsyAtom; ChA.Clr();
264    do {
265      ChA+=CCh; GetCh();
266    } while (ChType==plctSym);
267    if (CCh==&#x27;(&#x27;){GetCh(); Sym=plsyFAtom;}
268    AtomId=AtomBs-&gt;AddAtomStr(ChA);
269  }
270  void TPlLx::GetAtomQ(){
271    Sym=plsyAtom; ChA.Clr();
272    GetCh();
273    forever{
274      if ((CCh==&#x27;\&#x27;&#x27;)&amp;&amp;(NCh!=&#x27;\&#x27;&#x27;)){GetCh(); break;}
275      if ((CCh==&#x27;\&#x27;&#x27;)&amp;&amp;(NCh==&#x27;\&#x27;&#x27;)){GetCh();}
276      if (ChEscapingP&amp;&amp;(CCh==ChDef.StartChEscCh)){
277        GetChEscBf(); ChA+=ChEscBf;
278      } else {
279        ChA+=CCh; GetCh();
280      }
281    }
282    if (CCh==&#x27;(&#x27;){GetCh(); Sym=plsyFAtom;}
283    AtomId=AtomBs-&gt;AddAtomStr(ChA);
284    AtomBs-&gt;GetAtomDef(AtomId).AtomFSet|=TPlAtomDef::AFlgWriteQ;
285  }
286  void TPlLx::GetListStr(){
287    Sym=plsyList; ChA.Clr();
288    GetCh();
289    forever{
290      if ((CCh==&#x27;&quot;&#x27;)&amp;&amp;(NCh!=&#x27;&quot;&#x27;)){GetCh(); break;}
291      if ((CCh==&#x27;&quot;&#x27;)&amp;&amp;(NCh==&#x27;&quot;&#x27;)){GetCh();}
292      if (ChEscapingP&amp;&amp;(CCh==ChDef.StartChEscCh)){
293        GetChEscBf(); ChA+=ChEscBf;
294      } else {
295        ChA+=CCh; GetCh();
296      }
297    }
298  }
299  void TPlLx::GetNum(){
300    Sym=plsyInt; ChA.Clr(); Int=0;
301    do {
302      Int=Int*10+CCh; ChA+=CCh; GetCh();
303    } while (ChType==plctNum);
304    if (CCh==&#x27;\&#x27;&#x27;){ 
305      int IntBase=Int;
306      if (IntBase&gt;MxIntBase){EThrow(&quot;Integer-Base too large.&quot;);}
307      GetCh();
308      if (IntBase==0){ 
309        if (ChEscapingP&amp;&amp;(CCh==ChDef.StartChEscCh)){
310          GetChEscBf();
311          if (ChEscBf.Len()&gt;0){Int=ChEscBf[0];} else {Int=0;}
312        } else {
313          Int=uint(CCh); GetCh();
314        }
315      } else { 
316        Int=0;
317        do {
318          int Digit=0;
319          if (ChType==plctNum){ 
320            Digit=CCh-&#x27;0&#x27;;
321          } else
322          if ((ChType==plctUpCs)||(ChType==plctLwCs)){ 
323            Digit=toupper(CCh)-&#x27;A&#x27;+10;
324          }
325          if (Digit&gt;=IntBase){EThrow(&quot;To large digit for integer base.&quot;);}
326          Int=Int*IntBase+Digit;
327          GetCh();
328        } while ((ChType==plctNum)||(ChType==plctUpCs)||(ChType==plctLwCs));
329      }
330    } else
331    if ((CCh==&#x27;.&#x27;)||(CCh==&#x27;e&#x27;)||(CCh==&#x27;E&#x27;)){
332      if (CCh==&#x27;.&#x27;){
333        do {
334          ChA+=CCh; GetCh();
335        } while (ChType==plctNum);
336      }
337      if ((CCh==&#x27;e&#x27;)||(CCh==&#x27;E&#x27;)){
338        ChA+=CCh; GetCh();
339        if ((CCh==&#x27;+&#x27;)||(CCh==&#x27;-&#x27;)){ChA+=CCh; GetCh();}
340        while (ChType==plctNum){ChA+=CCh; GetCh();}
341      }
342      Sym=plsyFlt; Flt=atof(ChA.CStr());
343    }
344  }
345  TPlLxSym TPlLx::GetSym(){
346    SkipWs();
347    switch (ChType){
348      case plctUpCs: 
349        GetVar(); break;
350      case plctUnderLn: 
351        if (ChDef.IsIdCh(CCh)){GetVar();}
352        else {Sym=plsyVoid; GetCh();}
353        break;
354      case plctLwCs: 
355        GetAtomNm(); break;
356      case plctSym: 
357        if ((CCh==&#x27;-&#x27;)&amp;&amp;(ChDef.GetChType(NCh)==plctNum)){
358          GetCh(); GetNum();
359          if (Sym==plsyInt){Int=-Int;}
360          else if (Sym==plsyFlt){Flt=-Flt;}
361        } else
362        if ((CCh==&#x27;.&#x27;)&amp;&amp;(NCh&lt;=&#x27; &#x27;)){
363          Sym=plsyFullStop; GetCh();
364        } else {
365          GetAtomSym();
366        }
367        break;
368      case plctSolo: 
369        Sym=plsyAtom;
370        if (CCh==&#x27;!&#x27;){AtomId=AtomBs-&gt;GetImpAtomId(pla_ExclPoint);}
371        else if (CCh==&#x27;;&#x27;){AtomId=AtomBs-&gt;GetImpAtomId(pla_Semicolon);}
372        else if (CCh==&#x27;,&#x27;){AtomId=AtomBs-&gt;GetImpAtomId(pla_Comma);}
373        else {Fail;}
374        GetCh(); break;
375      case plctSQuo: 
376        GetAtomQ(); break;
377      case plctDQuo: 
378        GetListStr(); break;
379      case plctMeta: 
380        switch (CCh){
381          case &#x27;(&#x27;:
382            GetCh(); SkipWs();
383            if (CCh==&#x27;)&#x27;){
384              Sym=plsyAtom; AtomId=AtomBs-&gt;GetImpAtomId(pla_EmptyParen); GetCh();
385            } else {
386              Sym=plsyLPar;
387            }
388            break;
389          case &#x27;)&#x27;:
390            Sym=plsyRPar; GetCh(); break;
391          case &#x27;[&#x27;:
392            GetCh(); SkipWs();
393            if (CCh==&#x27;]&#x27;){
394              Sym==plsyAtom; AtomId=AtomBs-&gt;GetImpAtomId(pla_EmptyList); GetCh();
395            } else {
396              Sym=plsyLBracket;
397            }
398            break;
399          case &#x27;]&#x27;:
400            Sym=plsyRBracket; GetCh(); break;
401          case &#x27;{&#x27;:
402            GetCh(); SkipWs();
403            if (CCh==&#x27;}&#x27;){
404              Sym=plsyAtom; AtomId=AtomBs-&gt;GetImpAtomId(pla_EmptyBrace); GetCh();
405            } else {
<span onclick='openModal()' class='match'>406              Sym=plsyLBrace;
407            }
408            break;
409          case &#x27;}&#x27;:
410            Sym=plsyRBrace; GetCh(); break;
411          case &#x27;|&#x27;:
412            if (ParseInsideListExpP){
</span>413              Sym=plsyVBar; GetCh();
414            } else {
415              Sym=plsyAtom; AtomId=AtomBs-&gt;GetImpAtomId(pla_VerticalBar); GetCh();
416            }
417            break;
418          default:
419            EThrow(&quot;Unknown meta character.&quot;);
420        }
421      case plctNum: 
422        GetNum(); break;
423      case plctEof: 
424        Sym=plsyEof; break;
425      default:
426        EThrow(&quot;Invalid character type&quot;);
427    }
428    return Sym;
429  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-prologparser.cpp</h3>
            <pre><code>1  #include &quot;prologparser.h&quot;
2  TPlChDef::TPlChDef(){
3    ChTypeV.Gen(TPlChDef::MxChar-TPlChDef::MnChar+1);
4    IAssert(TPlChDef::MnChar==0); IAssert(TPlChDef::MxChar==255);
5    for (int Ch=MnChar; Ch&lt;=MxChar; Ch++){ChTypeV[Ch]=plctUnDef;}
6    for (int Ch=MnChar; Ch&lt;=&#x27; &#x27;; Ch++){ChTypeV[Ch]=plctBl;}
7    ChTypeV[EofCh]=plctEof;
8    ChTypeV[&#x27;!&#x27;]=plctSolo;
9    ChTypeV[&#x27;&quot;&#x27;]=plctDQuo;
10    ChTypeV[&#x27;#&#x27;]=plctSym;
11    ChTypeV[&#x27;$&#x27;]=plctSym;
12    ChTypeV[&#x27;%&#x27;]=plctComm;
13    ChTypeV[&#x27;&amp;&#x27;]=plctSym;
14    ChTypeV[&#x27;\&#x27;&#x27;]=plctSQuo;
15    ChTypeV[&#x27;(&#x27;]=plctMeta;
16    ChTypeV[&#x27;)&#x27;]=plctMeta;
17    ChTypeV[&#x27;*&#x27;]=plctSym;
18    ChTypeV[&#x27;+&#x27;]=plctSym;
19    ChTypeV[&#x27;,&#x27;]=plctSolo;
20    ChTypeV[&#x27;-&#x27;]=plctSym;
21    ChTypeV[&#x27;.&#x27;]=plctSym;
22    ChTypeV[&#x27;/&#x27;]=plctSym;
23    for (int Ch=&#x27;0&#x27;; Ch&lt;=&#x27;9&#x27;; Ch++){ChTypeV[Ch]=plctNum;}
24    ChTypeV[&#x27;:&#x27;]=plctSym;
25    ChTypeV[&#x27;;&#x27;]=plctSolo;
26    ChTypeV[&#x27;&lt;&#x27;]=plctSym;
27    ChTypeV[&#x27;=&#x27;]=plctSym;
28    ChTypeV[&#x27;&gt;&#x27;]=plctSym;
29    ChTypeV[&#x27;?&#x27;]=plctSym;
30    ChTypeV[&#x27;@&#x27;]=plctSym;
31    for (int Ch=&#x27;A&#x27;; Ch&lt;=&#x27;Z&#x27;; Ch++){ChTypeV[Ch]=plctUpCs;}
32    ChTypeV[&#x27;[&#x27;]=plctMeta;
33    ChTypeV[&#x27;\\&#x27;]=plctSym;
34    ChTypeV[&#x27;]&#x27;]=plctMeta;
35    ChTypeV[&#x27;^&#x27;]=plctSym;
36    ChTypeV[&#x27;_&#x27;]=plctUnderLn;
37    ChTypeV[&#x27;`&#x27;]=plctSym;
38    for (int Ch=&#x27;a&#x27;; Ch&lt;=&#x27;z&#x27;; Ch++){ChTypeV[Ch]=plctLwCs;}
39    ChTypeV[&#x27;{&#x27;]=plctMeta;
40    ChTypeV[&#x27;|&#x27;]=plctMeta;
41    ChTypeV[&#x27;}&#x27;]=plctMeta;
42    ChTypeV[&#x27;~&#x27;]=plctSym;
43    ChTypeV[DelCh]=plctBl;
44    IdChPV.Gen(MxChar-MnChar+1);
45    for (int Ch=MnChar; Ch&lt;=MxChar; Ch++){IdChPV[Ch]=false;}
46    for (int Ch=&#x27;0&#x27;; Ch&lt;=&#x27;9&#x27;; Ch++){IdChPV[Ch]=true;}
47    for (int Ch=&#x27;A&#x27;; Ch&lt;=&#x27;Z&#x27;; Ch++){IdChPV[Ch]=true;}
48    IdChPV[&#x27;_&#x27;]=true;
49    for (int Ch=&#x27;a&#x27;; Ch&lt;=&#x27;z&#x27;; Ch++){IdChPV[Ch]=true;}
50    ChEscChPV.Gen(MxChar-MnChar+1);
51    for (int Ch=MnChar; Ch&lt;=MxChar; Ch++){ChEscChPV[Ch]=false;}
52    ChEscChPV[HTabCh]=true;
53    ChEscChPV[&#x27; &#x27;]=true;
54    for (int Ch=MnPrintableCh; Ch&lt;=MxPrintableCh; Ch++){ChEscChPV[Ch]=true;}
55  }
56  void TPlAtomDef::SetOp(const TPlOpType&amp; OpType, const uint&amp; OpPrec){
57    switch (OpType){
58      case plot_fx: (AtomFSet&amp;=AFlgOpPrefixReset)|=AFlgOp_fx; PrefixOpPrec=OpPrec; break;
59      case plot_fy: (AtomFSet&amp;=AFlgOpPrefixReset)|=AFlgOp_fy; PrefixOpPrec=OpPrec; break;
60      case plot_yfx: (AtomFSet&amp;=AFlgOpInfixReset)|=AFlgOp_yfx; InfixOpPrec=OpPrec; break;
61      case plot_xfx: (AtomFSet&amp;=AFlgOpInfixReset)|=AFlgOp_xfx; InfixOpPrec=OpPrec; break;
62      case plot_xfy: (AtomFSet&amp;=AFlgOpInfixReset)|=AFlgOp_xfy; InfixOpPrec=OpPrec; break;
63      case plot_xf: (AtomFSet&amp;=AFlgOpPostfixReset)|=AFlgOp_xf; PostfixOpPrec=OpPrec; break;
64      case plot_yf: (AtomFSet&amp;=AFlgOpPostfixReset)|=AFlgOp_yf; PostfixOpPrec=OpPrec; break;
65      default: Fail;
66    }
67  }
68  void TPlAtomBs::PrepImpAtoms(){
69    ImpAtomIdV.Gen(plaMx);
70    ImpAtomIdV[pla_Impl]=AddAtomStr(&quot;:-&quot;);
71    ImpAtomIdV[pla_ImplDCG]=AddAtomStr(&quot;--&gt;&quot;);
72    ImpAtomIdV[pla_Query]=AddAtomStr(&quot;?-&quot;);
73    ImpAtomIdV[pla_Mode]=AddAtomStr(&quot;mode&quot;);
74    ImpAtomIdV[pla_Public]=AddAtomStr(&quot;public&quot;);
75    ImpAtomIdV[pla_Dynamic]=AddAtomStr(&quot;dynamic&quot;);
76    ImpAtomIdV[pla_MultiFile]=AddAtomStr(&quot;multifile&quot;);
77    ImpAtomIdV[pla_MetaPredicate]=AddAtomStr(&quot;meta_predicate&quot;);
78    ImpAtomIdV[pla_Semicolon]=AddAtomStr(&quot;;&quot;);
79    ImpAtomIdV[pla_VerticalBar]=AddAtomStr(&quot;|&quot;);
80    ImpAtomIdV[pla_If]=AddAtomStr(&quot;-&gt;&quot;);
81    ImpAtomIdV[pla_Comma]=AddAtomStr(&quot;,&quot;);
82    ImpAtomIdV[pla_Not]=AddAtomStr(&quot;\\+&quot;);
83    ImpAtomIdV[pla_Spy]=AddAtomStr(&quot;spy&quot;);
84    ImpAtomIdV[pla_NoSpy]=AddAtomStr(&quot;nospy&quot;);
85    ImpAtomIdV[pla_Unify]=AddAtomStr(&quot;=&quot;);
86    ImpAtomIdV[pla_Is]=AddAtomStr(&quot;is&quot;);
87    ImpAtomIdV[pla_Uni]=AddAtomStr(&quot;=..&quot;);
88    ImpAtomIdV[pla_Identical]=AddAtomStr(&quot;==&quot;);
89    ImpAtomIdV[pla_NotIdentical]=AddAtomStr(&quot;\\==&quot;);
90    ImpAtomIdV[pla_SOLess]=AddAtomStr(&quot;@&lt;&quot;);
91    ImpAtomIdV[pla_SOGreater]=AddAtomStr(&quot;@&gt;&quot;);
92    ImpAtomIdV[pla_SOLessOrEqual]=AddAtomStr(&quot;@=&lt;&quot;);
93    ImpAtomIdV[pla_SOGreaterOrEqual]=AddAtomStr(&quot;@&gt;=&quot;);
94    ImpAtomIdV[pla_AEqual]=AddAtomStr(&quot;=:=&quot;);
95    ImpAtomIdV[pla_ANotEqual]=AddAtomStr(&quot;=\\=&quot;);
96    ImpAtomIdV[pla_ALess]=AddAtomStr(&quot;&lt;&quot;);
97    ImpAtomIdV[pla_AGreater]=AddAtomStr(&quot;&gt;&quot;);
98    ImpAtomIdV[pla_ALessOrEqual]=AddAtomStr(&quot;=&lt;&quot;);
99    ImpAtomIdV[pla_AGreaterOrEqual]=AddAtomStr(&quot;&gt;=&quot;);
100    ImpAtomIdV[pla_Colon]=AddAtomStr(&quot;:&quot;);
101    ImpAtomIdV[pla_Plus]=AddAtomStr(&quot;+&quot;);
102    ImpAtomIdV[pla_Minus]=AddAtomStr(&quot;-&quot;);
103    ImpAtomIdV[pla_BitOr]=AddAtomStr(&quot;\\/&quot;);
104    ImpAtomIdV[pla_BitAnd]=AddAtomStr(&quot;/\\&quot;);
105    ImpAtomIdV[pla_Divide]=AddAtomStr(&quot;/&quot;);
106    ImpAtomIdV[pla_IntDivide]=AddAtomStr(&quot;&amp;bsol;&amp;bsol;&quot;);
107    ImpAtomIdV[pla_Times]=AddAtomStr(&quot;*&quot;);
108    ImpAtomIdV[pla_ShiftLeft]=AddAtomStr(&quot;&lt;&lt;&quot;);
109    ImpAtomIdV[pla_ShiftRight]=AddAtomStr(&quot;&gt;&gt;&quot;);
110    ImpAtomIdV[pla_Mod]=AddAtomStr(&quot;mod&quot;);
111    ImpAtomIdV[pla_ExistQuantifier]=AddAtomStr(&quot;^&quot;);
112    ImpAtomIdV[pla_ExclPoint]=AddAtomStr(&quot;!&quot;);
113    ImpAtomIdV[pla_EmptyList]=AddAtomStr(&quot;[]&quot;);
114    ImpAtomIdV[pla_EmptyBrace]=AddAtomStr(&quot;{}&quot;);
115    ImpAtomIdV[pla_EmptyParen]=AddAtomStr(&quot;()&quot;);
116    ImpAtomIdV[pla_Period]=AddAtomStr(&quot;.&quot;);
117    ImpAtomIdV[pla_VAR_N]=AddAtomStr(&quot;$VAR&quot;);
118    ImpAtomIdV[pla_EndOfFile]=AddAtomStr(&quot;end_of_file&quot;);
119    GetAtomDef(ImpAtomIdV[pla_Impl]).SetOp(plot_xfx, 1200);
120    GetAtomDef(ImpAtomIdV[pla_ImplDCG]).SetOp(plot_xfx, 1200);
121    GetAtomDef(ImpAtomIdV[pla_Impl]).SetOp(plot_fx, 1200);
122    GetAtomDef(ImpAtomIdV[pla_Query]).SetOp(plot_fx, 1200);
123    GetAtomDef(ImpAtomIdV[pla_Mode]).SetOp(plot_fx, 1150);
124    GetAtomDef(ImpAtomIdV[pla_Public]).SetOp(plot_fx, 1150);
125    GetAtomDef(ImpAtomIdV[pla_Dynamic]).SetOp(plot_fx, 1150);
126    GetAtomDef(ImpAtomIdV[pla_MultiFile]).SetOp(plot_fx, 1150);
127    GetAtomDef(ImpAtomIdV[pla_MetaPredicate]).SetOp(plot_fx, 1150);
128    GetAtomDef(ImpAtomIdV[pla_Semicolon]).SetOp(plot_xfy, 1100);
129    GetAtomDef(ImpAtomIdV[pla_VerticalBar]).SetOp(plot_xfy, 1100);
130    GetAtomDef(ImpAtomIdV[pla_If]).SetOp(plot_xfy, 1050);
131    GetAtomDef(ImpAtomIdV[pla_Comma]).SetOp(plot_xfy, 1000);
132    GetAtomDef(ImpAtomIdV[pla_Not]).SetOp(plot_fy, 900);
133    GetAtomDef(ImpAtomIdV[pla_Spy]).SetOp(plot_fy, 900);
134    GetAtomDef(ImpAtomIdV[pla_NoSpy]).SetOp(plot_fy, 900);
135    GetAtomDef(ImpAtomIdV[pla_Unify]).SetOp(plot_xfx, 700);
136    GetAtomDef(ImpAtomIdV[pla_Is]).SetOp(plot_xfx, 700);
137    GetAtomDef(ImpAtomIdV[pla_Uni]).SetOp(plot_xfx, 700);
138    GetAtomDef(ImpAtomIdV[pla_Identical]).SetOp(plot_xfx, 700);
139    GetAtomDef(ImpAtomIdV[pla_NotIdentical]).SetOp(plot_xfx, 700);
140    GetAtomDef(ImpAtomIdV[pla_SOLess]).SetOp(plot_xfx, 700);
141    GetAtomDef(ImpAtomIdV[pla_SOGreater]).SetOp(plot_xfx, 700);
142    GetAtomDef(ImpAtomIdV[pla_SOLessOrEqual]).SetOp(plot_xfx, 700);
143    GetAtomDef(ImpAtomIdV[pla_SOGreaterOrEqual]).SetOp(plot_xfx, 700);
144    GetAtomDef(ImpAtomIdV[pla_AEqual]).SetOp(plot_xfx, 700);
145    GetAtomDef(ImpAtomIdV[pla_ANotEqual]).SetOp(plot_xfx, 700);
146    GetAtomDef(ImpAtomIdV[pla_ALess]).SetOp(plot_xfx, 700);
147    GetAtomDef(ImpAtomIdV[pla_AGreater]).SetOp(plot_xfx, 700);
148    GetAtomDef(ImpAtomIdV[pla_ALessOrEqual]).SetOp(plot_xfx, 700);
149    GetAtomDef(ImpAtomIdV[pla_AGreaterOrEqual]).SetOp(plot_xfx, 700);
150    GetAtomDef(ImpAtomIdV[pla_Colon]).SetOp(plot_xfy, 600);
151    GetAtomDef(ImpAtomIdV[pla_Plus]).SetOp(plot_yfx, 500);
152    GetAtomDef(ImpAtomIdV[pla_Minus]).SetOp(plot_yfx, 500);
153    GetAtomDef(ImpAtomIdV[pla_BitOr]).SetOp(plot_yfx, 500);
154    GetAtomDef(ImpAtomIdV[pla_BitAnd]).SetOp(plot_yfx, 500);
155    GetAtomDef(ImpAtomIdV[pla_Plus]).SetOp(plot_fx, 500);
156    GetAtomDef(ImpAtomIdV[pla_Minus]).SetOp(plot_fx, 500);
157    GetAtomDef(ImpAtomIdV[pla_Divide]).SetOp(plot_yfx, 400);
158    GetAtomDef(ImpAtomIdV[pla_IntDivide]).SetOp(plot_yfx, 400);
159    GetAtomDef(ImpAtomIdV[pla_Times]).SetOp(plot_yfx, 400);
160    GetAtomDef(ImpAtomIdV[pla_ShiftLeft]).SetOp(plot_yfx, 400);
161    GetAtomDef(ImpAtomIdV[pla_ShiftRight]).SetOp(plot_yfx, 400);
162    GetAtomDef(ImpAtomIdV[pla_Mod]).SetOp(plot_xfx, 300);
163    GetAtomDef(ImpAtomIdV[pla_ExistQuantifier]).SetOp(plot_xfy, 200);
164  }
165  TPlAtomBs::TPlAtomBs():
166    StrToAtomDefH(), ImpAtomIdV(){
167    PrepImpAtoms();
168  }
169  TPlLx::TPlLx(const PSIn&amp; _SIn, const PPlAtomBs&amp; _AtomBs, const PPlVarBs&amp; _VarBs):
170    ChDef(), SIn(_SIn), RSIn(*SIn),
171    CCh(&#x27; &#x27;), NCh(&#x27; &#x27;), ChX(0), ChEscBf(), ChType(plctBl), Sym(plstUndef),
172    AtomBs(_AtomBs), VarBs(_VarBs){}
173  void TPlLx::EThrow(const TStr&amp; MsgStr) const {
174    TChA FPosChA;
175    FPosChA+=&quot; [File:&quot;; FPosChA+=SIn-&gt;GetSNm();
176    FPosChA+=&quot; Char:&quot;; FPosChA+=TInt::GetStr(ChX);
177    FPosChA+=&quot;]&quot;;
178    TStr FullMsgStr=MsgStr+FPosChA;
179    TExcept::Throw(FullMsgStr);
180  }
181  void TPlLx::SkipComment(){
182    while (!((CCh==&#x27;*&#x27;)&amp;&amp;(NCh==&#x27;/&#x27;))){
183      if ((CCh==&#x27;/&#x27;)&amp;&amp;(NCh==&#x27;*&#x27;)){
184        GetCh(); GetCh(); SkipComment();
185      } else {
186        GetCh();
187        if (CCh==TPlChDef::EofCh){EThrow(&quot;Comment not concluded with &#x27;*/&#x27;&quot;);}
188      }
189    }
190    GetCh(); GetCh();
191  }
192  void TPlLx::SkipWs(){
193    forever {
194      while (ChType==plctBl){GetCh();}
195      if ((CCh==&#x27;/&#x27;)&amp;&amp;(NCh==&#x27;*&#x27;)){
196        GetCh(); GetCh(); SkipComment();
197      } else
198      if (CCh==&#x27;%&#x27;){
199        forever{
200          GetCh();
201          if ((CCh==TPlChDef::CrCh)||(CCh==TPlChDef::LfCh)||(CCh==TPlChDef::EofCh)){break;}
202        }
203        if (CCh==TPlChDef::EofCh){break;} else {GetCh();}
204      } else {
205        break;
206      }
207    }
208  }
209  void TPlLx::GetChEscBf(){
210    ChEscBf.Clr(); GetCh();
211    switch (toupper(CCh)){
212      case &#x27;B&#x27;: ChEscBf+=TPlChDef::BsCh; GetCh(); break;
213      case &#x27;T&#x27;: ChEscBf+=TPlChDef::HTabCh; GetCh(); break;
214      case &#x27;N&#x27;: ChEscBf+=TPlChDef::LfCh; GetCh(); break;
215      case &#x27;V&#x27;: ChEscBf+=TPlChDef::VTabCh; GetCh(); break;
216      case &#x27;F&#x27;: ChEscBf+=TPlChDef::FfCh; GetCh(); break;
217      case &#x27;R&#x27;: ChEscBf+=TPlChDef::CrCh; GetCh(); break;
218      case &#x27;E&#x27;: ChEscBf+=TPlChDef::EscCh; GetCh(); break;
219      case &#x27;D&#x27;: ChEscBf+=TPlChDef::DelCh; GetCh(); break;
220      case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;:
221      case &#x27;4&#x27;: case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: 
222        {int Cd=0; int Chs=0;
223        forever{
224          Chs++;
225          Cd=Cd*8+(CCh-48);
226          if (Cd&gt;TPlChDef::MxChar){EThrow(&quot;Octal number overflow&quot;);}
227          GetCh();
228          if ((Chs==3)||(CCh&lt;&#x27;0&#x27;)||(CCh&gt;&#x27;7&#x27;)){break;}
229        }
230        ChEscBf+=char(Cd); GetCh(); break;}
231      case &#x27;^&#x27;: 
232        GetCh();
233        if ((CCh&lt;&#x27;@&#x27;)||(CCh&gt;&#x27;_&#x27;)){
234          EThrow(&quot;Invalid escaped control character&quot;);}
235        ChEscBf+=CCh-&#x27;@&#x27;; GetCh(); break;
236      case &#x27;C&#x27; : 
237        forever{
238          GetCh();
239          if (CCh==TPlChDef::EofCh){EThrow(&quot;Unexpected end-of-file&quot;);}
240          if ((CCh&gt;=TPlChDef::MnPrintableCh)&amp;&amp;(CCh&lt;=TPlChDef::MxPrintableCh)){
241            break;}
242        }
243      default:
244        ChEscBf+=CCh; GetCh(); break;
245    }
246  }
247  void TPlLx::GetVar(){
248    Sym=plsyVar; ChA.Clr();
249    do {
250      ChA+=CCh; GetCh();
251    } while (ChDef.IsIdCh(CCh));
252    VarId=VarBs-&gt;AddVarStr(ChA);
253  }
254  void TPlLx::GetAtomNm(){
255    Sym=plsyAtom; ChA.Clr();
256    do {
257      ChA+=CCh; GetCh();
258    } while (ChDef.IsIdCh(CCh));
259    if (CCh==&#x27;(&#x27;){GetCh(); Sym=plsyFAtom;}
260    AtomId=AtomBs-&gt;AddAtomStr(ChA);
261  }
262  void TPlLx::GetAtomSym(){
263    Sym=plsyAtom; ChA.Clr();
264    do {
265      ChA+=CCh; GetCh();
266    } while (ChType==plctSym);
267    if (CCh==&#x27;(&#x27;){GetCh(); Sym=plsyFAtom;}
268    AtomId=AtomBs-&gt;AddAtomStr(ChA);
269  }
270  void TPlLx::GetAtomQ(){
271    Sym=plsyAtom; ChA.Clr();
272    GetCh();
273    forever{
274      if ((CCh==&#x27;\&#x27;&#x27;)&amp;&amp;(NCh!=&#x27;\&#x27;&#x27;)){GetCh(); break;}
275      if ((CCh==&#x27;\&#x27;&#x27;)&amp;&amp;(NCh==&#x27;\&#x27;&#x27;)){GetCh();}
276      if (ChEscapingP&amp;&amp;(CCh==ChDef.StartChEscCh)){
277        GetChEscBf(); ChA+=ChEscBf;
278      } else {
279        ChA+=CCh; GetCh();
280      }
281    }
282    if (CCh==&#x27;(&#x27;){GetCh(); Sym=plsyFAtom;}
283    AtomId=AtomBs-&gt;AddAtomStr(ChA);
284    AtomBs-&gt;GetAtomDef(AtomId).AtomFSet|=TPlAtomDef::AFlgWriteQ;
285  }
286  void TPlLx::GetListStr(){
287    Sym=plsyList; ChA.Clr();
288    GetCh();
289    forever{
290      if ((CCh==&#x27;&quot;&#x27;)&amp;&amp;(NCh!=&#x27;&quot;&#x27;)){GetCh(); break;}
291      if ((CCh==&#x27;&quot;&#x27;)&amp;&amp;(NCh==&#x27;&quot;&#x27;)){GetCh();}
292      if (ChEscapingP&amp;&amp;(CCh==ChDef.StartChEscCh)){
293        GetChEscBf(); ChA+=ChEscBf;
294      } else {
295        ChA+=CCh; GetCh();
296      }
297    }
298  }
299  void TPlLx::GetNum(){
300    Sym=plsyInt; ChA.Clr(); Int=0;
301    do {
302      Int=Int*10+CCh; ChA+=CCh; GetCh();
303    } while (ChType==plctNum);
304    if (CCh==&#x27;\&#x27;&#x27;){ 
305      int IntBase=Int;
306      if (IntBase&gt;MxIntBase){EThrow(&quot;Integer-Base too large.&quot;);}
307      GetCh();
308      if (IntBase==0){ 
309        if (ChEscapingP&amp;&amp;(CCh==ChDef.StartChEscCh)){
310          GetChEscBf();
311          if (ChEscBf.Len()&gt;0){Int=ChEscBf[0];} else {Int=0;}
312        } else {
313          Int=uint(CCh); GetCh();
314        }
315      } else { 
316        Int=0;
317        do {
318          int Digit=0;
319          if (ChType==plctNum){ 
320            Digit=CCh-&#x27;0&#x27;;
321          } else
322          if ((ChType==plctUpCs)||(ChType==plctLwCs)){ 
323            Digit=toupper(CCh)-&#x27;A&#x27;+10;
324          }
325          if (Digit&gt;=IntBase){EThrow(&quot;To large digit for integer base.&quot;);}
326          Int=Int*IntBase+Digit;
327          GetCh();
328        } while ((ChType==plctNum)||(ChType==plctUpCs)||(ChType==plctLwCs));
329      }
330    } else
331    if ((CCh==&#x27;.&#x27;)||(CCh==&#x27;e&#x27;)||(CCh==&#x27;E&#x27;)){
332      if (CCh==&#x27;.&#x27;){
333        do {
334          ChA+=CCh; GetCh();
335        } while (ChType==plctNum);
336      }
337      if ((CCh==&#x27;e&#x27;)||(CCh==&#x27;E&#x27;)){
338        ChA+=CCh; GetCh();
339        if ((CCh==&#x27;+&#x27;)||(CCh==&#x27;-&#x27;)){ChA+=CCh; GetCh();}
340        while (ChType==plctNum){ChA+=CCh; GetCh();}
341      }
342      Sym=plsyFlt; Flt=atof(ChA.CStr());
343    }
344  }
345  TPlLxSym TPlLx::GetSym(){
346    SkipWs();
347    switch (ChType){
348      case plctUpCs: 
349        GetVar(); break;
350      case plctUnderLn: 
351        if (ChDef.IsIdCh(CCh)){GetVar();}
352        else {Sym=plsyVoid; GetCh();}
353        break;
354      case plctLwCs: 
355        GetAtomNm(); break;
356      case plctSym: 
357        if ((CCh==&#x27;-&#x27;)&amp;&amp;(ChDef.GetChType(NCh)==plctNum)){
358          GetCh(); GetNum();
359          if (Sym==plsyInt){Int=-Int;}
360          else if (Sym==plsyFlt){Flt=-Flt;}
361        } else
362        if ((CCh==&#x27;.&#x27;)&amp;&amp;(NCh&lt;=&#x27; &#x27;)){
363          Sym=plsyFullStop; GetCh();
364        } else {
365          GetAtomSym();
366        }
367        break;
368      case plctSolo: 
369        Sym=plsyAtom;
370        if (CCh==&#x27;!&#x27;){AtomId=AtomBs-&gt;GetImpAtomId(pla_ExclPoint);}
371        else if (CCh==&#x27;;&#x27;){AtomId=AtomBs-&gt;GetImpAtomId(pla_Semicolon);}
372        else if (CCh==&#x27;,&#x27;){AtomId=AtomBs-&gt;GetImpAtomId(pla_Comma);}
373        else {Fail;}
374        GetCh(); break;
375      case plctSQuo: 
376        GetAtomQ(); break;
377      case plctDQuo: 
378        GetListStr(); break;
379      case plctMeta: 
380        switch (CCh){
381          case &#x27;(&#x27;:
382            GetCh(); SkipWs();
383            if (CCh==&#x27;)&#x27;){
384              Sym=plsyAtom; AtomId=AtomBs-&gt;GetImpAtomId(pla_EmptyParen); GetCh();
385            } else {
<span onclick='openModal()' class='match'>386              Sym=plsyLPar;
387            }
388            break;
389          case &#x27;)&#x27;:
390            Sym=plsyRPar; GetCh(); break;
391          case &#x27;[&#x27;:
392            GetCh(); SkipWs();
</span>393            if (CCh==&#x27;]&#x27;){
394              Sym==plsyAtom; AtomId=AtomBs-&gt;GetImpAtomId(pla_EmptyList); GetCh();
395            } else {
396              Sym=plsyLBracket;
397            }
398            break;
399          case &#x27;]&#x27;:
400            Sym=plsyRBracket; GetCh(); break;
401          case &#x27;{&#x27;:
402            GetCh(); SkipWs();
403            if (CCh==&#x27;}&#x27;){
404              Sym=plsyAtom; AtomId=AtomBs-&gt;GetImpAtomId(pla_EmptyBrace); GetCh();
405            } else {
406              Sym=plsyLBrace;
407            }
408            break;
409          case &#x27;}&#x27;:
410            Sym=plsyRBrace; GetCh(); break;
411          case &#x27;|&#x27;:
412            if (ParseInsideListExpP){
413              Sym=plsyVBar; GetCh();
414            } else {
415              Sym=plsyAtom; AtomId=AtomBs-&gt;GetImpAtomId(pla_VerticalBar); GetCh();
416            }
417            break;
418          default:
419            EThrow(&quot;Unknown meta character.&quot;);
420        }
421      case plctNum: 
422        GetNum(); break;
423      case plctEof: 
424        Sym=plsyEof; break;
425      default:
426        EThrow(&quot;Invalid character type&quot;);
427    }
428    return Sym;
429  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-prologparser.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-prologparser.cpp</div>
                </div>
                <div class="column column_space"><pre><code>406              Sym=plsyLBrace;
407            }
408            break;
409          case &#x27;}&#x27;:
410            Sym=plsyRBrace; GetCh(); break;
411          case &#x27;|&#x27;:
412            if (ParseInsideListExpP){
</pre></code></div>
                <div class="column column_space"><pre><code>386              Sym=plsyLPar;
387            }
388            break;
389          case &#x27;)&#x27;:
390            Sym=plsyRPar; GetCh(); break;
391          case &#x27;[&#x27;:
392            GetCh(); SkipWs();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    