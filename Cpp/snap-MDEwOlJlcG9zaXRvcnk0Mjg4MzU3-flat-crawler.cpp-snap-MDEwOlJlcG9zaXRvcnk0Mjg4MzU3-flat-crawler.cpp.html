
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 29, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.cpp</h3>
            <pre><code>1  #include "crawler.h"
2  bool TCrawlerDef::IsHostNmOk(const TStr& HostNm){
3    bool HostNmOkP=false;
4    if (RqDmNmV.Empty()){
5      HostNmOkP=true;
6    } else {
7      for (int RqDmNmN=0; RqDmNmN<RqDmNmV.Len(); RqDmNmN++){
8        if (HostNm.IsSuffix(RqDmNmV[RqDmNmN])){
9          HostNmOkP=true; break;
10        }
11      }
12    }
13    if (HostNmOkP){
14      for (int BadDmNmN=0; BadDmNmN<BadDmNmV.Len(); BadDmNmN++){
15        if (HostNm.IsSuffix(BadDmNmV[BadDmNmN])){
16          HostNmOkP=false; break;
17        }
18      }
19    }
20    return HostNmOkP;
21  }
22  bool TCrawlerDef::IsContTypeNmOk(const TStr& ContTypeNm){
23    if (RqContTypeNmV.Empty()){
24      return true;
25    } else {
26      TStr LcContTypeNm=ContTypeNm.GetLc();
27      for (int ContTypeNmN=0; ContTypeNmN<RqContTypeNmV.Len(); ContTypeNmN++){
28        if (LcContTypeNm.IsWcMatch(RqContTypeNmV[ContTypeNmN])){return true;}
29      }
30      return false;
31    }
32  }
33  bool TCrawlerDef::IsFExtOk(const PUrl& Url) const {
34    if (BadFExtV.Empty()||(Url->GetPathSegs()==0)){
35      return true;
36    } else {
37      TStr UrlStr=Url->GetUrlStr();
38      TStr FBase=Url->GetPathSeg(Url->GetPathSegs()-1);
39      TStr FExt=FBase.GetFExt().GetUc();
40      return (!BadFExtH.IsKey(FExt));
41    }
42  }
43  void TCrawlerDef::OptHtmlCrawling(){
44    AddBadFExt(".JPEG"); AddBadFExt(".JPG"); AddBadFExt(".GIF"); AddBadFExt(".BMP");
45    AddBadFExt(".MPEG"); AddBadFExt(".MPG"); AddBadFExt(".AVI"); AddBadFExt(".MOV");
46    AddBadFExt(".MP3"); AddBadFExt(".WAV"); AddBadFExt(".MID"); AddBadFExt(".RA");
47    AddBadFExt(".ZIP"); AddBadFExt(".RAR"); AddBadFExt(".GZ"); AddBadFExt(".TAR");
48    AddBadFExt(".PDF"); AddBadFExt(".DOC"); AddBadFExt(".XSL"); AddBadFExt(".PPT");
49    AddRqContTypeNm("text&bsol;*");
50  }
51  void TCrawlerDef::AddSiteUrlStr(const TStr& SiteUrlStr){
52    PUrl Url=TUrl::New(SiteUrlStr);
53    if (Url->IsOk(usHttp)){
54      AddRqDmNm(Url->GetHostNm());
55      AddStartUrlStr(SiteUrlStr);
56    }
57  }
58  void TCrawlerDef::AddSiteUrlStrV(const TStrV& SiteUrlStrV){
59    for (int UrlStrN=0; UrlStrN<SiteUrlStrV.Len(); UrlStrN++){
60      AddSiteUrlStr(SiteUrlStrV[UrlStrN]);
61    }
62  }
63  void TCrawlerDef::LoadUrlStrV(const TStr& SiteUrlStrVFNm){
64    if (SiteUrlStrVFNm.Empty()){return;}
65    PSIn SIn=TFIn::New(SiteUrlStrVFNm);
66    TILx Lx(SIn);
67    while (Lx.GetSym(syLn, syEof)!=syEof){
68      TStr UrlStr=TStr(Lx.Str).GetTrunc();
69      AddSiteUrlStr(UrlStr);
70    }
71  }
72  TStr TCrawlerDef::GetStr(){
73    TChA ChA;
74    ChA+=TStr::Fmt("                  Max. Urls: %d\n", GetMxUrls());
75    ChA+=TStr::Fmt("           Min. Connections: %d\n", GetMnConns());
76    ChA+=TStr::Fmt("           Max. Connections: %d\n", GetMxConns());
77    ChA+=TStr::Fmt("Max. Connections Per Server: %d\n", GetMxConnsPerSrv());
78    ChA+=TStr::Fmt("          After Fetch Delay: %d\n", GetAfterFetchDelaySecs());
79    ChA+=TStr::Fmt("                 Max. Level: %d\n", GetMxLev());
80    ChA+=TStr::Fmt("                 Max. Depth: %d\n", GetMxDep());
81    ChA+=TStr::Fmt("        Max. Content Length: %d\n", GetMxContLen());
82    ChA+=TStr::Fmt("          Min. Queue Length: %d\n", GetMnQLen());
83    ChA+=TStr::Fmt("         Queue Reset Modulo: %d\n", GetQResetMod());
84    ChA+=TStr::Fmt("  Max. Queue Segment Length: %d\n", GetMxQSegLen());
85    ChA+=TStr::Fmt("               Max. Retries: %d\n", GetMxRetries());
86    ChA+=TStr::Fmt("           Revisits Seconds: %d\n", GetRevisitSecs());
87    ChA+=TStr::Fmt("Redirection Domains Allowed: %d\n", TBool::GetYesNoStr(IsRedirDmAllowed()));
88    ChA+=TStr::Fmt("                 Start Urls:");
89    for (int UrlN=0; UrlN<GetStartUrls(); UrlN++){
90      ChA+=" "; ChA+=GetStartUrl(UrlN);}
91    ChA+="\n";
92    ChA+=TStr::Fmt("           Required Domains:");
93    for (int DmNmN=0; DmNmN<RqDmNmV.Len(); DmNmN++){
94      ChA+=" "; ChA+=RqDmNmV[DmNmN];}
95    ChA+="\n";
96    ChA+=TStr::Fmt("                Bad Domains:");
97    for (int DmNmN=0; DmNmN<BadDmNmV.Len(); DmNmN++){
98      ChA+=" "; ChA+=BadDmNmV[DmNmN];}
99    ChA+="\n";
100    ChA+=TStr::Fmt("                Geo-IP Base: %s\n", TBool::GetYesNoStr(IsGeoIpBs()).CStr());
101    ChA+=TStr::Fmt("                  Countries:");
102    for (int CountryNmN=0; CountryNmN<RqCountryNmV.Len(); CountryNmN++){
103      ChA+=" "; ChA+=RqCountryNmV[CountryNmN];}
104    ChA+="\n";
105    ChA+=TStr::Fmt("              Content Types:");
106    for (int ContTypeNmN=0; ContTypeNmN<RqContTypeNmV.Len(); ContTypeNmN++){
107      ChA+=" "; ChA+=RqContTypeNmV[ContTypeNmN];}
108    ChA+="\n";
109    ChA+=TStr::Fmt("        Bad File Extensions:");
110    for (int FExtN=0; FExtN<BadFExtV.Len(); FExtN++){
111      ChA+=" "; ChA+=BadFExtV[FExtN];}
112    ChA+="\n";
113    return ChA;
114  }
115  TCrawlerUrlDescBs::TCrawlerUrlDescBs(TCrawler* _Crawler):
116    Crawler(_Crawler){
117    IAssert(Crawler->GetDef()->GetMxUrls()!=-1);
118    UrlMd5SigToDescH.Gen(Crawler->GetDef()->GetMxUrls());
119  }
120  TStr TCrawlerUrlDescBs::GetFNm() const {
121    return
122     Crawler->GetDocBs()->GetDocBsNrFPath()+
123     Crawler->GetDocBs()->GetDocBsNm()+".UrlBs";
124  }
125  void TCrawlerUrlDescBs::Load(){
126    TFIn SIn(GetFNm()); UrlMd5SigToDescH.Load(SIn);
127  }
128  void TCrawlerUrlDescBs::Save(){
129    TFOut SOut(GetFNm()); UrlMd5SigToDescH.Save(SOut);
130  }
131  TCrawlerHostBs::TCrawlerHostBs(TCrawler* _Crawler):
132    Crawler(_Crawler){
133  }
134  PCrawlerHost TCrawlerHostBs::AddGetHost(const TStr& HostNm){
135    int HostId;
136    if (!NmToHostH.IsKey(HostNm, HostId)){
137      HostId=NmToHostH.AddKey(HostNm);
138      NmToHostH[HostId]=TCrawlerHost::New(HostNm);
139    }
140    return NmToHostH[HostId];
141  }
142  void TCrawlerHostBs::GetSortedHostV(TCrawlerHostV& HostV, const TStr& SortOrderNm){
143    typedef TKeyDat<TStr, PCrawlerHost> TNmHostKd;
144    TVec<TNmHostKd> NmHostKdV;
145    int Hosts=GetHosts(); bool SortAscP=true;
146    for (int HostN=0; HostN<Hosts; HostN++){
147      PCrawlerHost Host=GetHost(HostN);
148      TStr KeyStr;
149      if (SortOrderNm=="Host"){KeyStr=Host->GetRevHostNm(); SortAscP=true;}
150      else if (SortOrderNm=="Active"){KeyStr=TInt::GetStr(Host->GetActiveConns(), "%012d"); SortAscP=false;}
151      else if (SortOrderNm=="Fetched"){KeyStr=TInt::GetStr(Host->GetFetchedUrls(), "%012d"); SortAscP=false;}
152      else if (SortOrderNm=="Errors"){KeyStr=TInt::GetStr(Host->GetFetchErrors(), "%012d"); SortAscP=false;}
153      else if (SortOrderNm=="Queue"){KeyStr=TInt::GetStr(Host->GetQueueUrls(), "%012d"); SortAscP=false;}
154      else if (SortOrderNm=="Bytes"){KeyStr=TFlt::GetStr(double(Host->GetTransferBytes()), "%012.0f"); SortAscP=false;}
155      else if (SortOrderNm=="Time"){KeyStr=TFlt::GetStr(Host->GetTransferMSecs(), "%012.0f"); SortAscP=false;}
156      else if (SortOrderNm=="PageLen"){KeyStr=TFlt::GetStr(Host->GetAvgHttpRespLen(), "%012.0f"); SortAscP=false;}
157      else if (SortOrderNm=="Speed"){KeyStr=TFlt::GetStr(Host->GetAvgTransferBps(), "%012.0f"); SortAscP=false;}
158      else {KeyStr=Host->GetRevHostNm(); SortAscP=true;}
159      NmHostKdV.Add(TNmHostKd(KeyStr, Host));
160    }
161    NmHostKdV.Sort(SortAscP);
162    HostV.Gen(NmHostKdV.Len(), 0);
163    for (int HostN=0; HostN<NmHostKdV.Len(); HostN++){
164      HostV.Add(NmHostKdV[HostN].Dat);
165    }
166  }
167  void TCrawlerHostBs::GetSummaryInfo(
168   int& ActiveConns, int& FetchedUrls, int& FetchErrors, int& QueueUrls, 
169   double& TransferBytes, double& TransferMSecs, double& AvgHttpRespLen, 
170   double& AvgTransferBps){
171    ActiveConns=0; FetchedUrls=0; FetchErrors=0; QueueUrls=0;
172    TransferBytes=0; TransferMSecs=0; 
173    AvgHttpRespLen=0; AvgTransferBps=0;
174    int Hosts=GetHosts();
175    for (int HostN=0; HostN<Hosts; HostN++){
176      PCrawlerHost Host=GetHost(HostN);
177      ActiveConns+=Host->GetActiveConns();
178      FetchedUrls+=Host->GetFetchedUrls();
179      FetchErrors+=Host->GetFetchErrors();
180      QueueUrls+=Host->GetQueueUrls();
181      TransferBytes+=Host->GetTransferBytes();
182      TransferMSecs+=Host->GetTransferMSecs();
183      AvgHttpRespLen+=Host->GetAvgHttpRespLen();
184      AvgTransferBps+=Host->GetAvgTransferBps();
185    }
186    if (Hosts>0){
187      AvgHttpRespLen=AvgHttpRespLen/Hosts;
188      AvgTransferBps=AvgTransferBps/Hosts;
189    }
190  }
191  TCrawlerQueue::TCrawlerQueue(TCrawler* _Crawler):
192    Crawler(_Crawler), UrlMd5SigToUrlStrHostNmLevDepQuH(){
193  }
194  void TCrawlerQueue::GetQUrlsHostPrV(TIntStrPrV& QUrlsHostPrV){
195    QUrlsHostPrV.Clr();
196    TStrIntH HostToQUrlsH;
197    int QUrlP=UrlMd5SigToUrlStrHostNmLevDepQuH.FFirstKeyId();
198    while (UrlMd5SigToUrlStrHostNmLevDepQuH.FNextKeyId(QUrlP)){
199      TStr HostNm=GetQHostNm(QUrlP);
200      int Lev=GetQUrlLev(QUrlP);
201      HostToQUrlsH.AddDat(HostNm+":"+TInt::GetStr(Lev))++;
202    }
203    HostToQUrlsH.GetDatKeyPrV(QUrlsHostPrV);
204    QUrlsHostPrV.Sort(false);
205  }
206  void TCrawlerQueue::PushQUrl(const PUrl& Url, const int& Lev, const int& Dep){
207    PCrawlerDef Def=Crawler->GetDef();
208    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
209    PCrawlerHostBs HostBs=Crawler->GetHostBs();
210    IAssert(Url->IsOk(usHttp));
211    TMd5Sig UrlMd5Sig=TCrawler::GetUrlMd5Sig(Url->GetUrlStr());
212    if (UrlDescBs->IsUrl(UrlMd5Sig)){ 
213      if (UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev>Lev){
214        UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev=Lev;}
215    } else
216    if (IsQUrl(UrlMd5Sig)){ 
217    } else
218    if ((Def->GetMxLev()==-1)||(Lev<=Def->GetMxLev())&&
219     ((Def->GetMxDep()==-1)||(Dep<=Def->GetMxDep()))){
220      int QUrlId=AddQUrl(UrlMd5Sig, Url->GetUrlStr(), Url->GetHostNm(), Lev, Dep);
221      while (LevUrlIdQV.Len()-1<Lev){LevUrlIdQV.Add();}
222      LevUrlIdQV[Lev].Push(QUrlId);
223      HostBs->AddGetHost(Url->GetHostNm())->GetQueueUrls()++;
224    }
225  }
226  void TCrawlerQueue::PushQUrl(const TStr& UrlStr, const int& Lev, const int& Dep){
227    PUrl Url=TUrl::New(UrlStr);
228    if (Url->IsOk(usHttp)){
229      PushQUrl(Url, Lev, Dep);
230    }
231  }
232  bool TCrawlerQueue::PopQUrl(int& QUrlId, TStr& UrlStr){
233    PCrawlerDef Def=Crawler->GetDef();
234    PCrawlerHostBs HostBs=Crawler->GetHostBs();
235    int MxCheckedUrlsPerLev=100; 
236    while (MxCheckedUrlsPerLev<=100000){
237      for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
238        int CheckedUrls=0;
239        if (!LevUrlIdQV[Lev].Empty()){
240          bool FirstP=true; int FirstQUrlId;
241          forever {
242            QUrlId=LevUrlIdQV[Lev].Top();
243            if (FirstP){FirstQUrlId=QUrlId; FirstP=false;}
244            else if (QUrlId==FirstQUrlId){break;}
245            CheckedUrls++;
246            if (CheckedUrls>MxCheckedUrlsPerLev){break;}
247            LevUrlIdQV[Lev].Pop();
248            UrlStr=GetQUrlStr(QUrlId);
249            TStr HostNm=GetQHostNm(QUrlId);
250            PCrawlerHost Host=HostBs->AddGetHost(HostNm);
251            int ActiveConns=Host->GetActiveConns();
252            int MxConnsPerSrv=Def->GetMxConnsPerSrv();
253            TSecTm LastFetchTm=Host->GetLastFetchTm();
254            TSecTm CurTm=TSecTm::GetCurTm();
255            int AfterFetchDelaySecs=Def->GetAfterFetchDelaySecs();
256  		  int FetchDSecs=TInt::Abs(TSecTm::GetDSecs(LastFetchTm, CurTm));
257            if ((ActiveConns<MxConnsPerSrv)&&(FetchDSecs>=AfterFetchDelaySecs)){
258              Host->GetQueueUrls()--;
259              return true;
260            } else {
261              LevUrlIdQV[Lev].Push(QUrlId);
262            }
263          }
264        }
265      }
266      MxCheckedUrlsPerLev=MxCheckedUrlsPerLev*10;
267    }
268    return false;
269  }
270  void TCrawlerQueue::ShuffleUrlQ(){
271    if (Crawler->GetUrlDescBs()->GetUrls()%1000==0){
272      printf("*** Shuffle Queues\n");
273      for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
274        TRnd Rnd(0); LevUrlIdQV[Lev].Shuffle(Rnd);
275        printf("    Queue Level %d: %d\n", Lev, LevUrlIdQV[Lev].Len());
276      }
277    }
278  }
279  void TCrawlerQueue::ResetQUrlBs(){
280    PCrawlerDef Def=Crawler->GetDef();
281    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
282    if ((Def->GetQResetMod()>0)&&(UrlDescBs->GetUrls()%Def->GetQResetMod()==0)){
283      PopSaveQUrlBs();
284      PushQUrlBs();
285    }
286  }
287  TStr TCrawlerQueue::GetUrlQBBsFNm() const {
288    TStr UrlQBBsFNm=
289     Crawler->GetDocBs()->GetDocBsNrFPath()+
290     Crawler->GetDocBs()->GetDocBsNm()+"."+
291     TTm::GetUniqueCurUniTm().GetIdStr()+".UrlQBs";
292    return UrlQBBsFNm;
293  }
294  TStr TCrawlerQueue::GetUrlQBBsWcFNm() const {
295    TStr UrlQBBsFNm=
296     Crawler->GetDocBs()->GetDocBsNrFPath()+
297     Crawler->GetDocBs()->GetDocBsNm()+".*.UrlQBs";
298    return UrlQBBsFNm;
299  }
300  void TCrawlerQueue::PushQUrlBs(){
301    if (Empty()){
302      UrlMd5SigToUrlStrHostNmLevDepQuH.Clr(); 
303      LevUrlIdQV.Clr(); 
304    }
305    UrlQBBs=NULL; 
306    if (!ToDelUrlQBBsFNm.Empty()){ 
307      TFile::Del(ToDelUrlQBBsFNm); ToDelUrlQBBsFNm="";
308    }
309    TFFile FFile(GetUrlQBBsWcFNm(), false); TStr UrlQBBsFNm;
310    if (FFile.Next(UrlQBBsFNm)){
311      PBlobBs UrlQBBs=TGBlobBs::New(UrlQBBsFNm);
312      ToDelUrlQBBsFNm=UrlQBBsFNm;
313      TBlobPt TrvUrlQBlobPt=UrlQBBs->FFirstBlobPt();
314      TBlobPt UrlQBlobPt; PSIn UrlQBlobSIn;
315      while (UrlQBBs->FNextBlobPt(TrvUrlQBlobPt, UrlQBlobPt, UrlQBlobSIn)){
316        TStr UrlStr=TStr(*UrlQBlobSIn);
317        int Lev=TInt(*UrlQBlobSIn);
318        int Dep=TInt(*UrlQBlobSIn);
319        PushQUrl(UrlStr, Lev, Dep);
320      }
321    }
322  }
323  void TCrawlerQueue::PushQUrlToUrlQBs(const PUrl& Url, const int& Lev, const int& Dep){
324    PCrawlerDef Def=Crawler->GetDef();
325    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
326    PCrawlerHostBs HostBs=Crawler->GetHostBs();
327    IAssert(Url->IsOk(usHttp));
328    TMd5Sig UrlMd5Sig=TCrawler::GetUrlMd5Sig(Url->GetUrlStr());
329    if (UrlDescBs->IsUrl(UrlMd5Sig)){ 
330      if (UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev>Lev){
331        UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev=Lev;}
332    } else
333    if (IsQUrl(UrlMd5Sig)){ 
334    } else
335    if ((Def->GetMxLev()==-1)||(Lev<=Def->GetMxLev())&&
336     ((Def->GetMxDep()==-1)||(Dep<=Def->GetMxDep()))){
337      if (UrlQBBs.Empty()){
338        TStr UrlQBBsFNm=GetUrlQBBsFNm(); printf("*** %s\n", UrlQBBsFNm.CStr());
339        UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate, Def->GetMxQSegLen());
340      }
341      TMOut UrlQSOut(Url->GetUrlStr().Len()+100);
342      Url->GetUrlStr().Save(UrlQSOut);
343      TInt(Lev).Save(UrlQSOut);
<span onclick='openModal()' class='match'>344      TInt(Dep).Save(UrlQSOut);
345      PSIn UrlQSIn=UrlQSOut.GetSIn();
346      TBlobPt UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
347      if (UrlQBlobPt.Empty()){
</span>348        TStr UrlQBBsFNm=GetUrlQBBsFNm(); printf("*** %s\n", UrlQBBsFNm.CStr());
349        UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate, Def->GetMxQSegLen());
350        UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
351        IAssert(!UrlQBlobPt.Empty());
352      }
353    }
354  }
355  void TCrawlerQueue::PushQUrlToUrlQBs(const TStr& UrlStr, const int& Lev, const int& Dep){
356    PUrl Url=TUrl::New(UrlStr);
357    if (Url->IsOk(usHttp)){
358      PushQUrlToUrlQBs(Url, Lev, Dep);
359    }
360  }
361  void TCrawlerQueue::PopSaveQUrlBs(){
362    PCrawlerHostBs HostBs=Crawler->GetHostBs();
363    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
364    TStr UrlQBBsFNm=GetUrlQBBsFNm(); 
365    printf("*** Saving Active Queue-Url-Base To %s\n", UrlQBBsFNm.CStr());
366    UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate);
367    for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
368      while (!LevUrlIdQV[Lev].Empty()){
369        int QUrlId=LevUrlIdQV[Lev].Top();
370        TStr HostNm=GetQHostNm(QUrlId);
371        PCrawlerHost Host=HostBs->GetHost(HostNm);
372        TStr UrlStr=GetQUrlStr(QUrlId);
373        int Dep=GetQUrlDep(QUrlId);
374        LevUrlIdQV[Lev].Pop();
375        Host->GetQueueUrls()--;
376        DelQUrl(QUrlId);
377        TMOut UrlQSOut(UrlStr.Len()+100);
378        UrlStr.Save(UrlQSOut);
379        TInt(Lev).Save(UrlQSOut);
380        TInt(Dep).Save(UrlQSOut);
381        PSIn UrlQSIn=UrlQSOut.GetSIn();
382        TBlobPt UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
383      }
384    }
385  }
386  void TCrawlerFetcher::DelCrawlerFetcherConn(const int& ConnId){
387    PCrawlerHostBs HostBs=Crawler->GetHostBs();
388    int QUrlId; PUrl Url; int FetchMSecs; GetDelConn(ConnId, QUrlId, Url, FetchMSecs);
389    Crawler->GetQueue()->DelQUrl(QUrlId);
390    PCrawlerHost Host=HostBs->GetHost(Url->GetHostNm());
391    Host->GetActiveConns()--;
392    Host->GetFetchErrors()++;
393    Host->GetLastFetchTm()=TSecTm::GetCurTm();
394  }
395  TCrawlerFetcher::TCrawlerFetcher(TCrawler* _Crawler):
396    TWebPgFetch(), Crawler(_Crawler), CurMxConns(-1), 
397    LastClrZombiesTm(), Zombies(0), ZombieConnIdToFetchSizeH(){
398    IAssert(Crawler->GetDef()->GetMxConns()!=-1);
399    PutMxConns(Crawler->GetDef()->GetMxConns());
400    CurMxConns=1;
401    PutMxContLen(Crawler->GetDef()->GetMxContLen());
402    PutMxRetries(Crawler->GetDef()->GetMxRetries());
403    if (Crawler->GetDef()->GetUserAgentStr()=="ie8"){
404      PutUserAgentStrIE8();
405    } else {
406      PutUserAgentStr(Crawler->GetDef()->GetUserAgentStr());
407    }
408  }
409  void TCrawlerFetcher::GetConnV(TIntStrIntIntQuV& ConnIdUrlStrMSecsSizeQuV){
410    ConnIdUrlStrMSecsSizeQuV.Gen(GetConns(), 0);
411    int ConnP=ConnIdToQUrlIdUrlTmTrH.FFirstKeyId();
412    while (ConnIdToQUrlIdUrlTmTrH.FNextKeyId(ConnP)){
413      int ConnId=ConnIdToQUrlIdUrlTmTrH.GetKey(ConnP);
414      TStr UrlStr=ConnIdToQUrlIdUrlTmTrH[ConnP].Val2->GetUrlStr();
415      int FetchMSecs=int(TTm::GetCurUniMSecs()-ConnIdToQUrlIdUrlTmTrH[ConnP].Val3);
416      int FetchSize=GetConnBytesRead(ConnId);
417      ConnIdUrlStrMSecsSizeQuV.Add(TIntStrIntIntQu(ConnId, UrlStr, FetchMSecs, FetchSize));
418    }
419    ConnIdUrlStrMSecsSizeQuV.Sort();
420  }
421  void TCrawlerFetcher::ClrZombies(){
422    PCrawlerDef Def=Crawler->GetDef();
423    PCrawlerQueue Queue=Crawler->GetQueue();
424    if ((LastClrZombiesTm.IsDef())&&(TTm::GetDiffMSecs(LastClrZombiesTm, TTm::GetCurUniTm())<100000)){return;}
425    LastClrZombiesTm=TTm::GetCurUniTm();
426    TIntStrIntIntQuV ConnIdUrlStrMSecsSizeQuV; GetConnV(ConnIdUrlStrMSecsSizeQuV);
427    int ConnIds=ConnIdUrlStrMSecsSizeQuV.Len();
428    for (int ConnN=0; ConnN<ConnIds; ConnN++){
429      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
430      TStr UrlStr=ConnIdUrlStrMSecsSizeQuV[ConnN].Val2;
431      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
432      if (ZombieConnIdToFetchSizeH.IsKey(ConnId)){
433        int PrevFetchSize=ZombieConnIdToFetchSizeH.GetDat(ConnId);
434        if (FetchSize==PrevFetchSize){
435          printf("*** Zombie: %s\n", UrlStr.CStr()); 
436          Zombies++; 
437          DelConn(ConnId); 
438          DelCrawlerFetcherConn(ConnId); 
439          Queue()->PushQUrl(UrlStr, 0, 0); 
440          PutCurMxConns(Def->GetMnConns()); 
441        }
442      }
443    }
444    ZombieConnIdToFetchSizeH.Clr(false);
445    for (int ConnN=0; ConnN<ConnIds; ConnN++){
446      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
447      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
448      ZombieConnIdToFetchSizeH.AddDat(ConnId)=FetchSize;
449    }
450  }
451  void TCrawlerFetcher::Fetch(){
452    PCrawlerHostBs HostBs=Crawler->GetHostBs();
453    PCrawlerQueue Queue=Crawler->GetQueue();
454    int QUrlId; TStr UrlStr;
455    while ((GetConns()<=GetCurMxConns())&&(GetWaitUrls()==0)&&
456     (Queue->PopQUrl(QUrlId, UrlStr))){
457      PUrl IpUrl=TUrl::New(UrlStr);
458      PCrawlerHost Host=HostBs->AddGetHost(IpUrl->GetHostNm());
459      if (Host->IsIpNum()){
460        IpUrl->PutIpNum(Host->GetIpNum());}
461      int ConnId=FetchUrl(IpUrl);
462      PUrl Url=TUrl::New(UrlStr);
463      AddConn(ConnId, QUrlId, Url);
464      Host->GetActiveConns()++;
465    }
466    int QUrls=Queue->GetQUrls();
467    int MnQLen=Crawler->GetDef()->GetMnQLen();
468    if ((QUrls%100==0)&&(QUrls<MnQLen)){
469      Queue->PushQUrlBs();
470    }
471  }
472  void TCrawlerFetcher::OnFetch(const int& ConnId, const PWebPg& WebPg){
473    PCrawlerDef Def=Crawler->GetDef();
474    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
475    PCrawlerHostBs HostBs=Crawler->GetHostBs();
476    PCrawlerQueue Queue=Crawler->GetQueue();
477    PCrawlerDocBs DocBs=Crawler->GetDocBs();
478    int QUrlId; PUrl Url; int FetchMSecs; GetDelConn(ConnId, QUrlId, Url, FetchMSecs);
479    TMd5Sig UrlMd5Sig; int Lev; int Dep;
480    Queue->GetQUrl(QUrlId, UrlMd5Sig, Lev, Dep);
481    Queue->DelQUrl(QUrlId);
482    if (!UrlDescBs->IsUrl(UrlMd5Sig)){
483      /&bsol;**IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));
484      if (UrlMd5Sig!=TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0))){
485        SaveToErrLog("Begin:IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));");
486        SaveToErrLog(TStr::Fmt("Urls: %d", WebPg->GetUrls()).CStr());
487        SaveToErrLog(TStr::Fmt("Md5: %s", UrlMd5Sig.GetStr().CStr()).CStr());
488        for (int WebPgUrlN=0; WebPgUrlN<WebPg->GetUrls(); WebPgUrlN++){
489          SaveToErrLog(TStr::Fmt("Url #%d: %s",
490           WebPgUrlN,
491           WebPg->GetUrlStr(WebPgUrlN).CStr()).CStr());
492        }
493        SaveToErrLog("End:IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));");
494      }
495      for (int WebPgUrlN=0; WebPgUrlN<WebPg->GetUrls(); WebPgUrlN++){
496        TStr DocUrlStr=WebPg->GetUrlStr(WebPgUrlN);
497        TMd5Sig DocUrlMd5Sig=TCrawler::GetUrlMd5Sig(DocUrlStr);
498        if (!UrlDescBs->IsUrl(DocUrlMd5Sig)){
499          TBlobPt DocBlobPt; TMd5Sig DocMemMd5Sig;
500          TStr ContTypeNm=WebPg->GetHttpResp()->GetFldVal(THttp::ContTypeFldNm);
501          if (Def->IsContTypeNmOk(ContTypeNm)){
502            if (WebPgUrlN==WebPg->GetUrls()-1){
503              TMem DocMem; WebPg->GetHttpResp()->GetAsMem(DocMem);
504              DocMemMd5Sig=TMd5Sig(DocMem);
505              DocBlobPt=DocBs->AddDoc(DocUrlStr, DocMem);
506            } else {
507              TStr FinalUrlStr=WebPg->GetUrlStr(WebPg->GetUrls()-1);
508              PHttpResp RedirHttpResp=THttpResp::New(
509               THttp::RedirStatusCd, THttp::TextPlainFldVal, false, NULL, FinalUrlStr);
510              TMem DocMem; RedirHttpResp->GetAsMem(DocMem);
511              DocMemMd5Sig=TMd5Sig(DocMem);
512              DocBlobPt=DocBs->AddDoc(DocUrlStr, DocMem);
513            }
514          }
515          if (Def->IsRedirDmAllowed()){
516            PUrl Url=TUrl::New(DocUrlStr);
517            TStr HostNm=Url->GetHostNm();
518            Def->AddRqDmNm(HostNm);
519          }
520          TCrawlerUrlDesc UrlDesc(
521           DocBlobPt, DocMemMd5Sig, TSecTm::GetCurTm(), TUCh(Lev), TUCh(Dep));
522          UrlDescBs->AddUrlDesc(DocUrlMd5Sig, UrlDesc);
523        }
524      }
525    }
526    PCrawlerHost Host=HostBs->GetHost(Url->GetHostNm());
527    Host->GetIpNum()=WebPg->GetIpNum(0);
528    Host->GetActiveConns()--;
529    Host->GetFetchedUrls()++;
530    Host->GetTransferBytes()+=WebPg->GetHttpResp()->Len();
531    Host->GetTransferMSecs()+=int(WebPg->GetFetchMSecs());
532    Host->GetLastFetchTm()=TSecTm::GetCurTm();
533    TStr HostNm=Url->GetHostNm();
534    if (WebPg->GetHttpResp()->IsContType(THttp::TextFldVal)){
535      TUrlV OutUrlV; TUrlV OutRedirUrlV; WebPg->GetOutUrlV(OutUrlV, OutRedirUrlV);
536      if (Def->IsRedirDmAllowed()){
537        for (int UrlN=0; UrlN<OutRedirUrlV.Len(); UrlN++){
538          TStr HostNm=OutRedirUrlV[UrlN]->GetHostNm();
539          Def->AddRqDmNm(HostNm);
540        }
541      }
542      for (int UrlN=0; UrlN<OutUrlV.Len(); UrlN++){
543        TStr OutHostNm=OutUrlV[UrlN]->GetHostNm();
544        if (Def->IsHostNmOk(OutHostNm)){
545          if (Def->IsFExtOk(OutUrlV[UrlN])){
546            if (HostNm==OutHostNm){
547              Queue->PushQUrlToUrlQBs(OutUrlV[UrlN], Lev+1, Dep+1);
548            } else {
549              Queue->PushQUrlToUrlQBs(OutUrlV[UrlN], 0, Dep+1);
550            }
551          }
552        }
553      }
554    }
555    printf("Fetched [Lev:%d Dep:%d Queue:%d Fetched:%d Time:%d Size:%d]: %s\n",
556     Lev, Dep, Queue->GetQUrls(), UrlDescBs->GetUrls(), FetchMSecs,
557     WebPg->GetHttpResp()->Len(), WebPg->GetUrlStr().CStr());
558    Queue->ResetQUrlBs();
559    Queue->ShuffleUrlQ();
560    ClrZombies();
561    Fetch();
562    if (UrlDescBs->GetUrls()>=Def->GetMxUrls()){
563      TSysMsg::Quit();
564    }
565  }
566  void TCrawlerFetcher::OnError(const int& ConnId, const TStr& MsgStr){
567    DelCrawlerFetcherConn(ConnId);
568    Fetch();
569    printf("Error: %s\n", MsgStr.CStr());
570  }
571  void TCrawlerTimer::OnTimeOut(){
572    PCrawlerDef Def=Crawler->GetDef();
573    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
574    PCrawlerStat Stat=Crawler->GetStat();
575    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
576    uint64 InterEventMSecs=CurEventMSecs-LastEventMSecs;
577    uint64 ToutMSecs=GetTimeOut();
578    double TimerEventPrecision=(ToutMSecs==0) ? 0 : double(InterEventMSecs)/ToutMSecs;
579    if (TimerEventPrecision>1.01){
580      Fetcher->PutCurMxConns(int(Fetcher->GetCurMxConns()*0.90));
581    } else {
582      Fetcher->PutCurMxConns(Fetcher->GetCurMxConns()+1);
583    }
584    if (Fetcher->GetCurMxConns()<Def->GetMnConns()){
585      Fetcher->PutCurMxConns(Def->GetMnConns());}
586    if (Fetcher->GetCurMxConns()>Def->GetMxConns()){
587      Fetcher->PutCurMxConns(Def->GetMxConns());}
588    printf("---------------------------------------------------------------\n"); 
589    printf("*** Crawler-Timer: Timeout-Precision=%.3f CurMxConns=%d\n", 
590     TimerEventPrecision, Fetcher->GetCurMxConns());
591    if (Crawler->GetFetcher()->Empty()&&Crawler->GetQueue()->Empty()){
592      Crawler->GetQueue()->PushQUrlBs();
593      if (Crawler->GetQueue()->Empty()){
594        TSysMsg::Quit();
595      }
596    } else {
597      int QUrls=Crawler->GetQueue()->GetQUrls();
598      int MnQLen=Crawler->GetDef()->GetMnQLen();
599      if ((QUrls%100==0)&&(QUrls<MnQLen)){
600        Crawler->GetQueue()->PushQUrlBs();
601      }
602      Crawler->GetFetcher()->Fetch();
603    }
604    if (Last100SecsEventMSecs==0){
605      Last100SecsEventMSecs=CurEventMSecs;
606    } else 
607    if (CurEventMSecs-Last100SecsEventMSecs>=100000){
608      Stat->On100Secs();
609      Last100SecsEventMSecs=CurEventMSecs;
610    }
611    if (Last1000SecsEventMSecs==0){
612      Last1000SecsEventMSecs=CurEventMSecs;
613    } else 
614    if (CurEventMSecs-Last1000SecsEventMSecs>=1000000){
615      Stat->On1000Secs();
616      Last1000SecsEventMSecs=CurEventMSecs;
617    }
618    LastEventMSecs=CurEventMSecs;
619  }
620  TStr TCrawlerWebSrv::GetUrlStr(const int& RefreshSecs, const TStr& SortOrderNm){
621    TChA UrlChA;
622    UrlChA+='/';
623    UrlChA+='?';
624    UrlChA+=TStr::Fmt("Refresh=%d", RefreshSecs);
625    UrlChA+='&';
626    UrlChA+=TStr::Fmt("Sort=%s", SortOrderNm.CStr());
627    return UrlChA;
628  }
629  TStr TCrawlerWebSrv::GetAnchorStr(const TStr& DescStr, 
630   const int& RefreshSecs, const TStr& SortOrderNm){
631    TChA AnchorChA;
632    TStr UrlStr=GetUrlStr(RefreshSecs, SortOrderNm);
633    AnchorChA+=TStr::Fmt("<a href=\"%s\">", UrlStr.CStr());
634    AnchorChA+=DescStr;
635    AnchorChA+="</a>";
636    return AnchorChA;
637  }
638  void TCrawlerWebSrv::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
639    PCrawlerHostBs HostBs=Crawler->GetHostBs();
640    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
641    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
642    PCrawlerQueue Queue=Crawler->GetQueue();
643    PCrawlerStat Stat=Crawler->GetStat();
644    TStr UrlStr=HttpRq->GetUrl()->GetUrlStr();
645    TStr UrlPathStr=HttpRq->GetUrl()->GetPathStr();
646    PUrlEnv UrlEnv=HttpRq->GetUrlEnv();
647    bool StopCrawlingP=false;
648    if (UrlPathStr=="/Stop"){
649      StopCrawlingP=true;
650      TSysMsg::Quit();
651    }
652    int RefreshSecs=UrlEnv->GetVal("Refresh").GetInt(100);
653    TStr SortOrderNm=UrlEnv->GetVal("Sort");
654    TChA HtmlChA;
655    int ActiveConns; int FetchedUrls; int FetchErrors; int QueueUrls;
656    double TransferBytes; double TransferMSecs; 
657    double AvgHttpRespLen; double AvgTransferBps;
658    HostBs->GetSummaryInfo(ActiveConns, FetchedUrls, FetchErrors, QueueUrls, 
659     TransferBytes, TransferMSecs, AvgHttpRespLen, AvgTransferBps);
660    {HtmlChA+="<html><head><title>Crawling</title>";
661    if ((!StopCrawlingP)&&(RefreshSecs>0)){
662      HtmlChA+=TStr::Fmt("<meta http-equiv=\"refresh\" content=\"%d\">", RefreshSecs);}
663    HtmlChA+="</head><body>";
664    HtmlChA+="<h1>WebBird-Crawler</h1>";
665    HtmlChA+=TSecTm::GetCurTm().GetStr(); HtmlChA+="<br>";
666    HtmlChA+="<form method=get action=\"/Stop\">";
667    HtmlChA+="<input type=submit value=Stop>";
668    HtmlChA+="</form>";
669    HtmlChA+="<form method=get action=\"/\">";
670    HtmlChA+="<input type=submit value=\"Refresh Seconds\">";
671    HtmlChA+=TStr::Fmt("<input type=text name=\"Refresh\" value=\"%d\" size=2>", RefreshSecs);
672    HtmlChA+="</form>";}
673    {HtmlChA+="<h2>General Info</h2>\n";
674    uint64 StartMSecs=TTm::GetMSecsFromTm(Crawler->GetStartTm());
675    uint64 CurMSecs=TTm::GetCurUniMSecs();
676    uint64 CrawlingMSecs=CurMSecs-StartMSecs;
677    double CrawlingSecs=CrawlingMSecs/1000.0;
678    double CrawlingPpsSpeed=CrawlingSecs<=0 ? 0 : FetchedUrls/CrawlingSecs;
679    double AvgPgLen=(FetchedUrls>0)&&(TransferBytes>0) ? TransferBytes/FetchedUrls : 0;
680    HtmlChA+="<table border=1>\n";
681    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Urls Fetched<td align=right>%d</tr>\n", UrlDescBs->GetUrls());
682    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Queue Length<td align=right>%d</tr>\n", Queue->GetQUrls());
683    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Time<td align=right>%.0fs</tr>\n", CrawlingSecs);
684    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed<td align=right>%.3fpps</tr>\n", CrawlingPpsSpeed);
685    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed (last 1000secs)<td align=right>%.3fpps</tr>\n", 
686      Stat->GetLast1000SecsCrawlingSpeed());
687    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed (last 100secs)<td align=right>%.3fpps</tr>\n", 
688      Stat->GetLast100SecsCrawlingSpeed());
689    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Avg. Page Length<td align=right>%sb</tr>\n", 
690     TFlt::GetGigaStr(AvgPgLen).CStr());
691    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Cleaned Zombies<td align=right>%d</tr>\n", Fetcher->GetZombies());
692    HtmlChA+="</table>\n";}
693    {HtmlChA+="<h2>Hosts</h2>\n";
694    HtmlChA+="<table border=1>\n";
695    HtmlChA+=TStr::Fmt("<tr><th>%s (%d)<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s</tr>\n", 
696     GetAnchorStr("Hosts", RefreshSecs, "Host").CStr(),
697     HostBs->GetHosts(),
698     GetAnchorStr("Active", RefreshSecs, "Active").CStr(),
699     GetAnchorStr("Fetched", RefreshSecs, "Fetched").CStr(),
700     GetAnchorStr("Errors", RefreshSecs, "Errors").CStr(),
701     GetAnchorStr("Queue", RefreshSecs, "Queue").CStr(),
702     GetAnchorStr("Bytes", RefreshSecs, "Bytes").CStr(),
703     GetAnchorStr("Time", RefreshSecs, "Time").CStr(),
704     GetAnchorStr("PageLen", RefreshSecs, "PageLen").CStr(),
705     GetAnchorStr("Speed", RefreshSecs, "Speed").CStr());
706    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Summary</b>"
707      "<td align=right><b>%d</b><td align=right><b>%d</b><td align=right><b>%d</b><td align=right><b>%d</b>"
708      "<td align=right><b>%sb</b><td align=right><b>%ss</b><td align=right><b>%sb</b><td align=right><b>%sbps</b></tr>\n",
709     ActiveConns, FetchedUrls, FetchErrors, QueueUrls, 
710     TFlt::GetGigaStr(TransferBytes).CStr(), 
711     TFlt::GetGigaStr(TransferMSecs/1000).CStr(), 
712     TFlt::GetGigaStr(AvgHttpRespLen).CStr(),
713     TFlt::GetGigaStr(AvgTransferBps).CStr());
714    TCrawlerHostV HostV; HostBs->GetSortedHostV(HostV, SortOrderNm);
715    for (int HostN=0; HostN<HostV.Len(); HostN++){
716      PCrawlerHost Host=HostV[HostN];
717      HtmlChA+=TStr::Fmt("<tr><td align=right><a href=\"http:&bsol;&bsol;%s\">%s<a>"
718       "<td align=right>%d<td align=right>%d<td align=right>%d<td align=right>%d"
719       "<td align=right>%sb<td align=right>%ss<td align=right>%sb<td align=right>%sbps</tr>\n",
720       Host->GetHostNm().CStr(), 
721       Host->GetHostNm().CStr(), 
722       Host->GetActiveConns(),
723       Host->GetFetchedUrls(), 
724       Host->GetFetchErrors(), 
725       Host->GetQueueUrls(),
726       TFlt::GetGigaStr(double(Host->GetTransferBytes())).CStr(), 
727       TFlt::GetGigaStr(Host->GetTransferMSecs()/1000).CStr(),
728       TFlt::GetGigaStr(Host->GetAvgHttpRespLen()).CStr(),
729       TFlt::GetGigaStr(Host->GetAvgTransferBps()).CStr()); 
730    }
731    HtmlChA+="</table>";}
732    {HtmlChA+="<h2>Queue Levels</h2>\n";
733    HtmlChA+="<table border=1>\n";
734    int AllQUrls=Queue->GetQUrls();
735    HtmlChA+=TStr::Fmt("<tr><td align=right>%s<td align=right>%d</tr>\n",
736     "All Queue Urls", AllQUrls);
737    HtmlChA+=TStr::Fmt("<tr><td align=right>%s<td align=right>%d</tr>\n",
738      "Unconn Queue Urls", Queue->GetUnconnQUrls());
739    for (int Lev=0; Lev<Queue->GetQLevs(); Lev++){
740      HtmlChA+=TStr::Fmt("<tr><td align=right>Level-%d Urls<td align=right>%d</tr>\n",
741       Lev, Queue->GetQLevUrls(Lev));
742    }
743    HtmlChA+="</table>";}
744    {HtmlChA+="<h2>Queue</h2>\n";
745    TIntStrPrV QUrlsHostPrV; Queue->GetQUrlsHostPrV(QUrlsHostPrV);
746    HtmlChA+="<table border=1>\n";
747    HtmlChA+=TStr::Fmt("<tr><th>#<th>Host<th>Queue-Urls<th>%%</tr>\n");
748    int AllQUrls=Queue->GetQUrls();
749    for (int HostN=0; HostN<QUrlsHostPrV.Len(); HostN++){
750      TStr HostLevNm=QUrlsHostPrV[HostN].Val2;
751      TStr HostNm; TStr LevStr; HostLevNm.SplitOnCh(HostNm, ':', LevStr);
752      int QUrls=QUrlsHostPrV[HostN].Val1;
753      double QUrlsPrc=double(QUrls)/double(AllQUrls);
754      HtmlChA+=TStr::Fmt("<tr><td align=right>%d<td align=right><a href=\"http:&bsol;&bsol;%s/\">%s</a> / %s"
755       "<td align=right>%d<td align=right>%.3f%%</tr>\n",
756       1+HostN, HostNm.CStr(), HostNm.CStr(), LevStr.CStr(), QUrls, 100*QUrlsPrc);
757    }
758    HtmlChA+="</table>";}
759    {TIntStrIntIntQuV ConnIdUrlStrMSecsSizeQuV;
760    Fetcher->GetConnV(ConnIdUrlStrMSecsSizeQuV);
761    int ConnIds=ConnIdUrlStrMSecsSizeQuV.Len();
762    HtmlChA+="<h2>Connections</h2>\n";
763    HtmlChA+="<table border=1>\n";
764    HtmlChA+="<tr><th>#<th>Connection<th>Time<th>Size<th>Url</tr>\n";
765    for (int ConnN=0; ConnN<ConnIds; ConnN++){
766      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
767      TStr UrlStr=ConnIdUrlStrMSecsSizeQuV[ConnN].Val2;
768      int FetchMSecs=ConnIdUrlStrMSecsSizeQuV[ConnN].Val3;
769      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
770      HtmlChA+=TStr::Fmt("<tr><td>%d<td>%d<td>%ss<td>%sb<td><a href=\"%s\">%s</a></tr>\n",
771       1+ConnN, ConnId, 
772       TFlt::GetGigaStr(FetchMSecs/1000).CStr(), TFlt::GetGigaStr(FetchSize).CStr(), 
773       UrlStr.CStr(), UrlStr.CStr());
774    }
775    HtmlChA+="</table>\n";}
776    HtmlChA+="</body></html>";
777    PSIn BodySIn=TMIn::New(HtmlChA);
778    PHttpResp HttpResp=THttpResp::New(
779     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, BodySIn);
780    SendHttpResp(SockId, HttpResp);
781  }
782  TFAccess TCrawlerDocBs::Open(){
783    TFAccess DocBsFAccess=TFRnd::GetFAccessFromStr(DocBsFAccessNm);
784    IAssert((DocBsFAccess==faCreate)||(DocBsFAccess==faUpdate)||(DocBsFAccess==faRestore));
785    DocBBs=TMBlobBs::New(DocBsNrFPath+DocBsNm, DocBsFAccess, DocBsMxSegLen);
786    return DocBsFAccess;
787  }
788  void TCrawlerDocBs::Close(){
789    DocBBs=NULL;
790  }
791  TBlobPt TCrawlerDocBs::AddDoc(const TStr& DocUrlStr, const TMem& DocMem){
792    TMOut SOut(DocUrlStr.Len()+DocMem.Len()+100);
793    TTm::GetCurUniTm().GetWebLogDateTimeStr().Save(SOut);
794    DocUrlStr.Save(SOut);
795    DocMem.Save(SOut);
796    PSIn SIn=SOut.GetSIn();
797    TBlobPt BPt=DocBBs->PutBlob(SIn);
798    return BPt;
799  }
800  bool TCrawlerDocBs::FNextDocBlobPt(TBlobPt& TrvDocBlobPt,
801   TBlobPt& DocBlobPt, TStr& DateTimeStr, TStr& DocUrlStr, TMem& DocMem){
802    PSIn DocBlobSIn;
803    if (DocBBs->FNextBlobPt(TrvDocBlobPt, DocBlobPt, DocBlobSIn)){
804      DateTimeStr=TStr(*DocBlobSIn); 
805      DocUrlStr=TStr(*DocBlobSIn); 
806      DocMem=TMem(*DocBlobSIn); 
807      return true;
808    } else {
809      return false;
810    }
811  }
812  void TCrawlerStat::On100Secs(){
813    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
814    uint64 CurFetchedUrls=Crawler->GetUrlDescBs()->GetUrls();
815    double DiffSecs=(CurEventMSecs-Last100SecsEventMSecs)/double(1000);
816    if (DiffSecs<1){
817      Last100SecsCrawlingSpeed=0;
818    } else {
819      Last100SecsCrawlingSpeed=(CurFetchedUrls-Last100SecsFetchedUrls)/DiffSecs;
820    }
821    Last100SecsEventMSecs=CurEventMSecs;
822    Last100SecsFetchedUrls=CurFetchedUrls;
823  }
824  void TCrawlerStat::On1000Secs(){
825    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
826    uint64 CurFetchedUrls=Crawler->GetUrlDescBs()->GetUrls();
827    double DiffSecs=(CurEventMSecs-Last1000SecsEventMSecs)/double(1000);
828    if (DiffSecs<1){
829      Last1000SecsCrawlingSpeed=0;
830    } else {
831      Last1000SecsCrawlingSpeed=(CurFetchedUrls-Last1000SecsFetchedUrls)/DiffSecs;
832    }
833    Last1000SecsEventMSecs=CurEventMSecs;
834    Last1000SecsFetchedUrls=CurFetchedUrls;
835  }
836  TCrawler::TCrawler():
837    Def(TCrawlerDef::New()),
838    UrlDescBs(), HostBs(), Queue(), Fetcher(), DocBs(), Timer(), WebSrv(),
839    StartTm(TTm::GetCurUniTm()){
840    DocBs=TCrawlerDocBs::New(this);
841  }
842  void TCrawler::DefCrawlBs(const TStr& CrawlBsNm, const TStr& CrawlBsFPath,
843   const TStr& CrawlBsFAccessNm, const int& CrawlBsMxSegLen){
844    PCrawlerDocBs DocBs=GetDocBs();
845    DocBs->PutDocBsNm(CrawlBsNm);
846    DocBs->PutDocBsNrFPath(TStr::GetNrFPath(CrawlBsFPath));
847    DocBs->PutDocBsFAccessNm(CrawlBsFAccessNm);
848    DocBs->PutDocBsMxSegLen(CrawlBsMxSegLen);
849  }
850  void TCrawler::StartCrawling(){
851    UrlDescBs=TCrawlerUrlDescBs::New(this);
852    HostBs=TCrawlerHostBs::New(this);
853    Queue=TCrawlerQueue::New(this);
854    Fetcher=TCrawlerFetcher::New(this);
855    Stat=TCrawlerStat::New(this);
856    TFAccess DocBsFAccess=GetDocBs()->Open();
857    if (DocBsFAccess==faCreate){
858      PCrawlerDef Def=GetDef();
859      int StartUrls=Def->GetStartUrls();
860      for (int UrlN=0; UrlN<StartUrls; UrlN++){
861        Queue->PushQUrl(Def->GetStartUrl(UrlN), 0, 0);}
862    }
863    if (DocBsFAccess==faRestore){
864      printf("Restoring Crawled Documents...\n");
865      TBlobPt TrvDocBlobPt=GetDocBs()->FFirstDocBlobPt();
866      TBlobPt DocBlobPt; TStr DateTimeStr; TStr DocUrlStr; TMem DocMem; int DocN=0;
867      while (GetDocBs()->FNextDocBlobPt(TrvDocBlobPt, DocBlobPt, DateTimeStr, DocUrlStr, DocMem)){
868        DocN++; printf("%d\r", DocN);
869        TMd5Sig DocUrlMd5Sig=TCrawler::GetUrlMd5Sig(DocUrlStr);
870        TMd5Sig DocMemMd5Sig(DocMem);
871        TCrawlerUrlDesc UrlDesc(DocBlobPt, DocMemMd5Sig, TSecTm::GetCurTm(), TUCh(0), TUCh(0));
872        UrlDescBs->AddUrlDesc(DocUrlMd5Sig, UrlDesc);
873      }
874      printf("\nDone.\n");
875    }
876    if (DocBsFAccess==faUpdate){
877      GetUrlDescBs()->Load();
878    }
879    Timer=TCrawlerTimer::New(this, 1000);
880    WebSrv=TCrawlerWebSrv::New(this);
881    Fetcher->Fetch();
882  }
883  void TCrawler::StopCrawling(){
884    WebSrv=NULL;
885    Timer->StopTimer();
886    GetDocBs()->Close();
887    GetUrlDescBs()->Save();
888    GetQueue()->PopSaveQUrlBs();
889  }
890  TMd5Sig TCrawler::GetUrlMd5Sig(const TStr& UrlStr){
891    TStr LcUrlStr=UrlStr.GetLc();
892    return TMd5Sig(LcUrlStr);
893  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.cpp</h3>
            <pre><code>1  #include "crawler.h"
2  bool TCrawlerDef::IsHostNmOk(const TStr& HostNm){
3    bool HostNmOkP=false;
4    if (RqDmNmV.Empty()){
5      HostNmOkP=true;
6    } else {
7      for (int RqDmNmN=0; RqDmNmN<RqDmNmV.Len(); RqDmNmN++){
8        if (HostNm.IsSuffix(RqDmNmV[RqDmNmN])){
9          HostNmOkP=true; break;
10        }
11      }
12    }
13    if (HostNmOkP){
14      for (int BadDmNmN=0; BadDmNmN<BadDmNmV.Len(); BadDmNmN++){
15        if (HostNm.IsSuffix(BadDmNmV[BadDmNmN])){
16          HostNmOkP=false; break;
17        }
18      }
19    }
20    return HostNmOkP;
21  }
22  bool TCrawlerDef::IsContTypeNmOk(const TStr& ContTypeNm){
23    if (RqContTypeNmV.Empty()){
24      return true;
25    } else {
26      TStr LcContTypeNm=ContTypeNm.GetLc();
27      for (int ContTypeNmN=0; ContTypeNmN<RqContTypeNmV.Len(); ContTypeNmN++){
28        if (LcContTypeNm.IsWcMatch(RqContTypeNmV[ContTypeNmN])){return true;}
29      }
30      return false;
31    }
32  }
33  bool TCrawlerDef::IsFExtOk(const PUrl& Url) const {
34    if (BadFExtV.Empty()||(Url->GetPathSegs()==0)){
35      return true;
36    } else {
37      TStr UrlStr=Url->GetUrlStr();
38      TStr FBase=Url->GetPathSeg(Url->GetPathSegs()-1);
39      TStr FExt=FBase.GetFExt().GetUc();
40      return (!BadFExtH.IsKey(FExt));
41    }
42  }
43  void TCrawlerDef::OptHtmlCrawling(){
44    AddBadFExt(".JPEG"); AddBadFExt(".JPG"); AddBadFExt(".GIF"); AddBadFExt(".BMP");
45    AddBadFExt(".MPEG"); AddBadFExt(".MPG"); AddBadFExt(".AVI"); AddBadFExt(".MOV");
46    AddBadFExt(".MP3"); AddBadFExt(".WAV"); AddBadFExt(".MID"); AddBadFExt(".RA");
47    AddBadFExt(".ZIP"); AddBadFExt(".RAR"); AddBadFExt(".GZ"); AddBadFExt(".TAR");
48    AddBadFExt(".PDF"); AddBadFExt(".DOC"); AddBadFExt(".XSL"); AddBadFExt(".PPT");
49    AddRqContTypeNm("text&bsol;*");
50  }
51  void TCrawlerDef::AddSiteUrlStr(const TStr& SiteUrlStr){
52    PUrl Url=TUrl::New(SiteUrlStr);
53    if (Url->IsOk(usHttp)){
54      AddRqDmNm(Url->GetHostNm());
55      AddStartUrlStr(SiteUrlStr);
56    }
57  }
58  void TCrawlerDef::AddSiteUrlStrV(const TStrV& SiteUrlStrV){
59    for (int UrlStrN=0; UrlStrN<SiteUrlStrV.Len(); UrlStrN++){
60      AddSiteUrlStr(SiteUrlStrV[UrlStrN]);
61    }
62  }
63  void TCrawlerDef::LoadUrlStrV(const TStr& SiteUrlStrVFNm){
64    if (SiteUrlStrVFNm.Empty()){return;}
65    PSIn SIn=TFIn::New(SiteUrlStrVFNm);
66    TILx Lx(SIn);
67    while (Lx.GetSym(syLn, syEof)!=syEof){
68      TStr UrlStr=TStr(Lx.Str).GetTrunc();
69      AddSiteUrlStr(UrlStr);
70    }
71  }
72  TStr TCrawlerDef::GetStr(){
73    TChA ChA;
74    ChA+=TStr::Fmt("                  Max. Urls: %d\n", GetMxUrls());
75    ChA+=TStr::Fmt("           Min. Connections: %d\n", GetMnConns());
76    ChA+=TStr::Fmt("           Max. Connections: %d\n", GetMxConns());
77    ChA+=TStr::Fmt("Max. Connections Per Server: %d\n", GetMxConnsPerSrv());
78    ChA+=TStr::Fmt("          After Fetch Delay: %d\n", GetAfterFetchDelaySecs());
79    ChA+=TStr::Fmt("                 Max. Level: %d\n", GetMxLev());
80    ChA+=TStr::Fmt("                 Max. Depth: %d\n", GetMxDep());
81    ChA+=TStr::Fmt("        Max. Content Length: %d\n", GetMxContLen());
82    ChA+=TStr::Fmt("          Min. Queue Length: %d\n", GetMnQLen());
83    ChA+=TStr::Fmt("         Queue Reset Modulo: %d\n", GetQResetMod());
84    ChA+=TStr::Fmt("  Max. Queue Segment Length: %d\n", GetMxQSegLen());
85    ChA+=TStr::Fmt("               Max. Retries: %d\n", GetMxRetries());
86    ChA+=TStr::Fmt("           Revisits Seconds: %d\n", GetRevisitSecs());
87    ChA+=TStr::Fmt("Redirection Domains Allowed: %d\n", TBool::GetYesNoStr(IsRedirDmAllowed()));
88    ChA+=TStr::Fmt("                 Start Urls:");
89    for (int UrlN=0; UrlN<GetStartUrls(); UrlN++){
90      ChA+=" "; ChA+=GetStartUrl(UrlN);}
91    ChA+="\n";
92    ChA+=TStr::Fmt("           Required Domains:");
93    for (int DmNmN=0; DmNmN<RqDmNmV.Len(); DmNmN++){
94      ChA+=" "; ChA+=RqDmNmV[DmNmN];}
95    ChA+="\n";
96    ChA+=TStr::Fmt("                Bad Domains:");
97    for (int DmNmN=0; DmNmN<BadDmNmV.Len(); DmNmN++){
98      ChA+=" "; ChA+=BadDmNmV[DmNmN];}
99    ChA+="\n";
100    ChA+=TStr::Fmt("                Geo-IP Base: %s\n", TBool::GetYesNoStr(IsGeoIpBs()).CStr());
101    ChA+=TStr::Fmt("                  Countries:");
102    for (int CountryNmN=0; CountryNmN<RqCountryNmV.Len(); CountryNmN++){
103      ChA+=" "; ChA+=RqCountryNmV[CountryNmN];}
104    ChA+="\n";
105    ChA+=TStr::Fmt("              Content Types:");
106    for (int ContTypeNmN=0; ContTypeNmN<RqContTypeNmV.Len(); ContTypeNmN++){
107      ChA+=" "; ChA+=RqContTypeNmV[ContTypeNmN];}
108    ChA+="\n";
109    ChA+=TStr::Fmt("        Bad File Extensions:");
110    for (int FExtN=0; FExtN<BadFExtV.Len(); FExtN++){
111      ChA+=" "; ChA+=BadFExtV[FExtN];}
112    ChA+="\n";
113    return ChA;
114  }
115  TCrawlerUrlDescBs::TCrawlerUrlDescBs(TCrawler* _Crawler):
116    Crawler(_Crawler){
117    IAssert(Crawler->GetDef()->GetMxUrls()!=-1);
118    UrlMd5SigToDescH.Gen(Crawler->GetDef()->GetMxUrls());
119  }
120  TStr TCrawlerUrlDescBs::GetFNm() const {
121    return
122     Crawler->GetDocBs()->GetDocBsNrFPath()+
123     Crawler->GetDocBs()->GetDocBsNm()+".UrlBs";
124  }
125  void TCrawlerUrlDescBs::Load(){
126    TFIn SIn(GetFNm()); UrlMd5SigToDescH.Load(SIn);
127  }
128  void TCrawlerUrlDescBs::Save(){
129    TFOut SOut(GetFNm()); UrlMd5SigToDescH.Save(SOut);
130  }
131  TCrawlerHostBs::TCrawlerHostBs(TCrawler* _Crawler):
132    Crawler(_Crawler){
133  }
134  PCrawlerHost TCrawlerHostBs::AddGetHost(const TStr& HostNm){
135    int HostId;
136    if (!NmToHostH.IsKey(HostNm, HostId)){
137      HostId=NmToHostH.AddKey(HostNm);
138      NmToHostH[HostId]=TCrawlerHost::New(HostNm);
139    }
140    return NmToHostH[HostId];
141  }
142  void TCrawlerHostBs::GetSortedHostV(TCrawlerHostV& HostV, const TStr& SortOrderNm){
143    typedef TKeyDat<TStr, PCrawlerHost> TNmHostKd;
144    TVec<TNmHostKd> NmHostKdV;
145    int Hosts=GetHosts(); bool SortAscP=true;
146    for (int HostN=0; HostN<Hosts; HostN++){
147      PCrawlerHost Host=GetHost(HostN);
148      TStr KeyStr;
149      if (SortOrderNm=="Host"){KeyStr=Host->GetRevHostNm(); SortAscP=true;}
150      else if (SortOrderNm=="Active"){KeyStr=TInt::GetStr(Host->GetActiveConns(), "%012d"); SortAscP=false;}
151      else if (SortOrderNm=="Fetched"){KeyStr=TInt::GetStr(Host->GetFetchedUrls(), "%012d"); SortAscP=false;}
152      else if (SortOrderNm=="Errors"){KeyStr=TInt::GetStr(Host->GetFetchErrors(), "%012d"); SortAscP=false;}
153      else if (SortOrderNm=="Queue"){KeyStr=TInt::GetStr(Host->GetQueueUrls(), "%012d"); SortAscP=false;}
154      else if (SortOrderNm=="Bytes"){KeyStr=TFlt::GetStr(double(Host->GetTransferBytes()), "%012.0f"); SortAscP=false;}
155      else if (SortOrderNm=="Time"){KeyStr=TFlt::GetStr(Host->GetTransferMSecs(), "%012.0f"); SortAscP=false;}
156      else if (SortOrderNm=="PageLen"){KeyStr=TFlt::GetStr(Host->GetAvgHttpRespLen(), "%012.0f"); SortAscP=false;}
157      else if (SortOrderNm=="Speed"){KeyStr=TFlt::GetStr(Host->GetAvgTransferBps(), "%012.0f"); SortAscP=false;}
158      else {KeyStr=Host->GetRevHostNm(); SortAscP=true;}
159      NmHostKdV.Add(TNmHostKd(KeyStr, Host));
160    }
161    NmHostKdV.Sort(SortAscP);
162    HostV.Gen(NmHostKdV.Len(), 0);
163    for (int HostN=0; HostN<NmHostKdV.Len(); HostN++){
164      HostV.Add(NmHostKdV[HostN].Dat);
165    }
166  }
167  void TCrawlerHostBs::GetSummaryInfo(
168   int& ActiveConns, int& FetchedUrls, int& FetchErrors, int& QueueUrls, 
169   double& TransferBytes, double& TransferMSecs, double& AvgHttpRespLen, 
170   double& AvgTransferBps){
171    ActiveConns=0; FetchedUrls=0; FetchErrors=0; QueueUrls=0;
172    TransferBytes=0; TransferMSecs=0; 
173    AvgHttpRespLen=0; AvgTransferBps=0;
174    int Hosts=GetHosts();
175    for (int HostN=0; HostN<Hosts; HostN++){
176      PCrawlerHost Host=GetHost(HostN);
177      ActiveConns+=Host->GetActiveConns();
178      FetchedUrls+=Host->GetFetchedUrls();
179      FetchErrors+=Host->GetFetchErrors();
180      QueueUrls+=Host->GetQueueUrls();
181      TransferBytes+=Host->GetTransferBytes();
182      TransferMSecs+=Host->GetTransferMSecs();
183      AvgHttpRespLen+=Host->GetAvgHttpRespLen();
184      AvgTransferBps+=Host->GetAvgTransferBps();
185    }
186    if (Hosts>0){
187      AvgHttpRespLen=AvgHttpRespLen/Hosts;
188      AvgTransferBps=AvgTransferBps/Hosts;
189    }
190  }
191  TCrawlerQueue::TCrawlerQueue(TCrawler* _Crawler):
192    Crawler(_Crawler), UrlMd5SigToUrlStrHostNmLevDepQuH(){
193  }
194  void TCrawlerQueue::GetQUrlsHostPrV(TIntStrPrV& QUrlsHostPrV){
195    QUrlsHostPrV.Clr();
196    TStrIntH HostToQUrlsH;
197    int QUrlP=UrlMd5SigToUrlStrHostNmLevDepQuH.FFirstKeyId();
198    while (UrlMd5SigToUrlStrHostNmLevDepQuH.FNextKeyId(QUrlP)){
199      TStr HostNm=GetQHostNm(QUrlP);
200      int Lev=GetQUrlLev(QUrlP);
201      HostToQUrlsH.AddDat(HostNm+":"+TInt::GetStr(Lev))++;
202    }
203    HostToQUrlsH.GetDatKeyPrV(QUrlsHostPrV);
204    QUrlsHostPrV.Sort(false);
205  }
206  void TCrawlerQueue::PushQUrl(const PUrl& Url, const int& Lev, const int& Dep){
207    PCrawlerDef Def=Crawler->GetDef();
208    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
209    PCrawlerHostBs HostBs=Crawler->GetHostBs();
210    IAssert(Url->IsOk(usHttp));
211    TMd5Sig UrlMd5Sig=TCrawler::GetUrlMd5Sig(Url->GetUrlStr());
212    if (UrlDescBs->IsUrl(UrlMd5Sig)){ 
213      if (UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev>Lev){
214        UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev=Lev;}
215    } else
216    if (IsQUrl(UrlMd5Sig)){ 
217    } else
218    if ((Def->GetMxLev()==-1)||(Lev<=Def->GetMxLev())&&
219     ((Def->GetMxDep()==-1)||(Dep<=Def->GetMxDep()))){
220      int QUrlId=AddQUrl(UrlMd5Sig, Url->GetUrlStr(), Url->GetHostNm(), Lev, Dep);
221      while (LevUrlIdQV.Len()-1<Lev){LevUrlIdQV.Add();}
222      LevUrlIdQV[Lev].Push(QUrlId);
223      HostBs->AddGetHost(Url->GetHostNm())->GetQueueUrls()++;
224    }
225  }
226  void TCrawlerQueue::PushQUrl(const TStr& UrlStr, const int& Lev, const int& Dep){
227    PUrl Url=TUrl::New(UrlStr);
228    if (Url->IsOk(usHttp)){
229      PushQUrl(Url, Lev, Dep);
230    }
231  }
232  bool TCrawlerQueue::PopQUrl(int& QUrlId, TStr& UrlStr){
233    PCrawlerDef Def=Crawler->GetDef();
234    PCrawlerHostBs HostBs=Crawler->GetHostBs();
235    int MxCheckedUrlsPerLev=100; 
236    while (MxCheckedUrlsPerLev<=100000){
237      for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
238        int CheckedUrls=0;
239        if (!LevUrlIdQV[Lev].Empty()){
240          bool FirstP=true; int FirstQUrlId;
241          forever {
242            QUrlId=LevUrlIdQV[Lev].Top();
243            if (FirstP){FirstQUrlId=QUrlId; FirstP=false;}
244            else if (QUrlId==FirstQUrlId){break;}
245            CheckedUrls++;
246            if (CheckedUrls>MxCheckedUrlsPerLev){break;}
247            LevUrlIdQV[Lev].Pop();
248            UrlStr=GetQUrlStr(QUrlId);
249            TStr HostNm=GetQHostNm(QUrlId);
250            PCrawlerHost Host=HostBs->AddGetHost(HostNm);
251            int ActiveConns=Host->GetActiveConns();
252            int MxConnsPerSrv=Def->GetMxConnsPerSrv();
253            TSecTm LastFetchTm=Host->GetLastFetchTm();
254            TSecTm CurTm=TSecTm::GetCurTm();
255            int AfterFetchDelaySecs=Def->GetAfterFetchDelaySecs();
256  		  int FetchDSecs=TInt::Abs(TSecTm::GetDSecs(LastFetchTm, CurTm));
257            if ((ActiveConns<MxConnsPerSrv)&&(FetchDSecs>=AfterFetchDelaySecs)){
258              Host->GetQueueUrls()--;
259              return true;
260            } else {
261              LevUrlIdQV[Lev].Push(QUrlId);
262            }
263          }
264        }
265      }
266      MxCheckedUrlsPerLev=MxCheckedUrlsPerLev*10;
267    }
268    return false;
269  }
270  void TCrawlerQueue::ShuffleUrlQ(){
271    if (Crawler->GetUrlDescBs()->GetUrls()%1000==0){
272      printf("*** Shuffle Queues\n");
273      for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
274        TRnd Rnd(0); LevUrlIdQV[Lev].Shuffle(Rnd);
275        printf("    Queue Level %d: %d\n", Lev, LevUrlIdQV[Lev].Len());
276      }
277    }
278  }
279  void TCrawlerQueue::ResetQUrlBs(){
280    PCrawlerDef Def=Crawler->GetDef();
281    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
282    if ((Def->GetQResetMod()>0)&&(UrlDescBs->GetUrls()%Def->GetQResetMod()==0)){
283      PopSaveQUrlBs();
284      PushQUrlBs();
285    }
286  }
287  TStr TCrawlerQueue::GetUrlQBBsFNm() const {
288    TStr UrlQBBsFNm=
289     Crawler->GetDocBs()->GetDocBsNrFPath()+
290     Crawler->GetDocBs()->GetDocBsNm()+"."+
291     TTm::GetUniqueCurUniTm().GetIdStr()+".UrlQBs";
292    return UrlQBBsFNm;
293  }
294  TStr TCrawlerQueue::GetUrlQBBsWcFNm() const {
295    TStr UrlQBBsFNm=
296     Crawler->GetDocBs()->GetDocBsNrFPath()+
297     Crawler->GetDocBs()->GetDocBsNm()+".*.UrlQBs";
298    return UrlQBBsFNm;
299  }
300  void TCrawlerQueue::PushQUrlBs(){
301    if (Empty()){
302      UrlMd5SigToUrlStrHostNmLevDepQuH.Clr(); 
303      LevUrlIdQV.Clr(); 
304    }
305    UrlQBBs=NULL; 
306    if (!ToDelUrlQBBsFNm.Empty()){ 
307      TFile::Del(ToDelUrlQBBsFNm); ToDelUrlQBBsFNm="";
308    }
309    TFFile FFile(GetUrlQBBsWcFNm(), false); TStr UrlQBBsFNm;
310    if (FFile.Next(UrlQBBsFNm)){
311      PBlobBs UrlQBBs=TGBlobBs::New(UrlQBBsFNm);
312      ToDelUrlQBBsFNm=UrlQBBsFNm;
313      TBlobPt TrvUrlQBlobPt=UrlQBBs->FFirstBlobPt();
314      TBlobPt UrlQBlobPt; PSIn UrlQBlobSIn;
315      while (UrlQBBs->FNextBlobPt(TrvUrlQBlobPt, UrlQBlobPt, UrlQBlobSIn)){
316        TStr UrlStr=TStr(*UrlQBlobSIn);
317        int Lev=TInt(*UrlQBlobSIn);
318        int Dep=TInt(*UrlQBlobSIn);
319        PushQUrl(UrlStr, Lev, Dep);
320      }
321    }
322  }
323  void TCrawlerQueue::PushQUrlToUrlQBs(const PUrl& Url, const int& Lev, const int& Dep){
324    PCrawlerDef Def=Crawler->GetDef();
325    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
326    PCrawlerHostBs HostBs=Crawler->GetHostBs();
327    IAssert(Url->IsOk(usHttp));
328    TMd5Sig UrlMd5Sig=TCrawler::GetUrlMd5Sig(Url->GetUrlStr());
329    if (UrlDescBs->IsUrl(UrlMd5Sig)){ 
330      if (UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev>Lev){
331        UrlDescBs->GetUrlDesc(UrlMd5Sig).DocLev=Lev;}
332    } else
333    if (IsQUrl(UrlMd5Sig)){ 
334    } else
335    if ((Def->GetMxLev()==-1)||(Lev<=Def->GetMxLev())&&
336     ((Def->GetMxDep()==-1)||(Dep<=Def->GetMxDep()))){
337      if (UrlQBBs.Empty()){
338        TStr UrlQBBsFNm=GetUrlQBBsFNm(); printf("*** %s\n", UrlQBBsFNm.CStr());
339        UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate, Def->GetMxQSegLen());
340      }
341      TMOut UrlQSOut(Url->GetUrlStr().Len()+100);
342      Url->GetUrlStr().Save(UrlQSOut);
343      TInt(Lev).Save(UrlQSOut);
344      TInt(Dep).Save(UrlQSOut);
345      PSIn UrlQSIn=UrlQSOut.GetSIn();
346      TBlobPt UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
347      if (UrlQBlobPt.Empty()){
348        TStr UrlQBBsFNm=GetUrlQBBsFNm(); printf("*** %s\n", UrlQBBsFNm.CStr());
349        UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate, Def->GetMxQSegLen());
350        UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
351        IAssert(!UrlQBlobPt.Empty());
352      }
353    }
354  }
355  void TCrawlerQueue::PushQUrlToUrlQBs(const TStr& UrlStr, const int& Lev, const int& Dep){
356    PUrl Url=TUrl::New(UrlStr);
357    if (Url->IsOk(usHttp)){
358      PushQUrlToUrlQBs(Url, Lev, Dep);
359    }
360  }
361  void TCrawlerQueue::PopSaveQUrlBs(){
362    PCrawlerHostBs HostBs=Crawler->GetHostBs();
363    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
364    TStr UrlQBBsFNm=GetUrlQBBsFNm(); 
365    printf("*** Saving Active Queue-Url-Base To %s\n", UrlQBBsFNm.CStr());
366    UrlQBBs=TGBlobBs::New(UrlQBBsFNm, faCreate);
367    for (int Lev=0; Lev<LevUrlIdQV.Len(); Lev++){
368      while (!LevUrlIdQV[Lev].Empty()){
369        int QUrlId=LevUrlIdQV[Lev].Top();
370        TStr HostNm=GetQHostNm(QUrlId);
371        PCrawlerHost Host=HostBs->GetHost(HostNm);
372        TStr UrlStr=GetQUrlStr(QUrlId);
373        int Dep=GetQUrlDep(QUrlId);
374        LevUrlIdQV[Lev].Pop();
375        Host->GetQueueUrls()--;
376        DelQUrl(QUrlId);
377        TMOut UrlQSOut(UrlStr.Len()+100);
378        UrlStr.Save(UrlQSOut);
379        TInt(Lev).Save(UrlQSOut);
<span onclick='openModal()' class='match'>380        TInt(Dep).Save(UrlQSOut);
381        PSIn UrlQSIn=UrlQSOut.GetSIn();
382        TBlobPt UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
383      }
</span>384    }
385  }
386  void TCrawlerFetcher::DelCrawlerFetcherConn(const int& ConnId){
387    PCrawlerHostBs HostBs=Crawler->GetHostBs();
388    int QUrlId; PUrl Url; int FetchMSecs; GetDelConn(ConnId, QUrlId, Url, FetchMSecs);
389    Crawler->GetQueue()->DelQUrl(QUrlId);
390    PCrawlerHost Host=HostBs->GetHost(Url->GetHostNm());
391    Host->GetActiveConns()--;
392    Host->GetFetchErrors()++;
393    Host->GetLastFetchTm()=TSecTm::GetCurTm();
394  }
395  TCrawlerFetcher::TCrawlerFetcher(TCrawler* _Crawler):
396    TWebPgFetch(), Crawler(_Crawler), CurMxConns(-1), 
397    LastClrZombiesTm(), Zombies(0), ZombieConnIdToFetchSizeH(){
398    IAssert(Crawler->GetDef()->GetMxConns()!=-1);
399    PutMxConns(Crawler->GetDef()->GetMxConns());
400    CurMxConns=1;
401    PutMxContLen(Crawler->GetDef()->GetMxContLen());
402    PutMxRetries(Crawler->GetDef()->GetMxRetries());
403    if (Crawler->GetDef()->GetUserAgentStr()=="ie8"){
404      PutUserAgentStrIE8();
405    } else {
406      PutUserAgentStr(Crawler->GetDef()->GetUserAgentStr());
407    }
408  }
409  void TCrawlerFetcher::GetConnV(TIntStrIntIntQuV& ConnIdUrlStrMSecsSizeQuV){
410    ConnIdUrlStrMSecsSizeQuV.Gen(GetConns(), 0);
411    int ConnP=ConnIdToQUrlIdUrlTmTrH.FFirstKeyId();
412    while (ConnIdToQUrlIdUrlTmTrH.FNextKeyId(ConnP)){
413      int ConnId=ConnIdToQUrlIdUrlTmTrH.GetKey(ConnP);
414      TStr UrlStr=ConnIdToQUrlIdUrlTmTrH[ConnP].Val2->GetUrlStr();
415      int FetchMSecs=int(TTm::GetCurUniMSecs()-ConnIdToQUrlIdUrlTmTrH[ConnP].Val3);
416      int FetchSize=GetConnBytesRead(ConnId);
417      ConnIdUrlStrMSecsSizeQuV.Add(TIntStrIntIntQu(ConnId, UrlStr, FetchMSecs, FetchSize));
418    }
419    ConnIdUrlStrMSecsSizeQuV.Sort();
420  }
421  void TCrawlerFetcher::ClrZombies(){
422    PCrawlerDef Def=Crawler->GetDef();
423    PCrawlerQueue Queue=Crawler->GetQueue();
424    if ((LastClrZombiesTm.IsDef())&&(TTm::GetDiffMSecs(LastClrZombiesTm, TTm::GetCurUniTm())<100000)){return;}
425    LastClrZombiesTm=TTm::GetCurUniTm();
426    TIntStrIntIntQuV ConnIdUrlStrMSecsSizeQuV; GetConnV(ConnIdUrlStrMSecsSizeQuV);
427    int ConnIds=ConnIdUrlStrMSecsSizeQuV.Len();
428    for (int ConnN=0; ConnN<ConnIds; ConnN++){
429      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
430      TStr UrlStr=ConnIdUrlStrMSecsSizeQuV[ConnN].Val2;
431      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
432      if (ZombieConnIdToFetchSizeH.IsKey(ConnId)){
433        int PrevFetchSize=ZombieConnIdToFetchSizeH.GetDat(ConnId);
434        if (FetchSize==PrevFetchSize){
435          printf("*** Zombie: %s\n", UrlStr.CStr()); 
436          Zombies++; 
437          DelConn(ConnId); 
438          DelCrawlerFetcherConn(ConnId); 
439          Queue()->PushQUrl(UrlStr, 0, 0); 
440          PutCurMxConns(Def->GetMnConns()); 
441        }
442      }
443    }
444    ZombieConnIdToFetchSizeH.Clr(false);
445    for (int ConnN=0; ConnN<ConnIds; ConnN++){
446      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
447      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
448      ZombieConnIdToFetchSizeH.AddDat(ConnId)=FetchSize;
449    }
450  }
451  void TCrawlerFetcher::Fetch(){
452    PCrawlerHostBs HostBs=Crawler->GetHostBs();
453    PCrawlerQueue Queue=Crawler->GetQueue();
454    int QUrlId; TStr UrlStr;
455    while ((GetConns()<=GetCurMxConns())&&(GetWaitUrls()==0)&&
456     (Queue->PopQUrl(QUrlId, UrlStr))){
457      PUrl IpUrl=TUrl::New(UrlStr);
458      PCrawlerHost Host=HostBs->AddGetHost(IpUrl->GetHostNm());
459      if (Host->IsIpNum()){
460        IpUrl->PutIpNum(Host->GetIpNum());}
461      int ConnId=FetchUrl(IpUrl);
462      PUrl Url=TUrl::New(UrlStr);
463      AddConn(ConnId, QUrlId, Url);
464      Host->GetActiveConns()++;
465    }
466    int QUrls=Queue->GetQUrls();
467    int MnQLen=Crawler->GetDef()->GetMnQLen();
468    if ((QUrls%100==0)&&(QUrls<MnQLen)){
469      Queue->PushQUrlBs();
470    }
471  }
472  void TCrawlerFetcher::OnFetch(const int& ConnId, const PWebPg& WebPg){
473    PCrawlerDef Def=Crawler->GetDef();
474    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
475    PCrawlerHostBs HostBs=Crawler->GetHostBs();
476    PCrawlerQueue Queue=Crawler->GetQueue();
477    PCrawlerDocBs DocBs=Crawler->GetDocBs();
478    int QUrlId; PUrl Url; int FetchMSecs; GetDelConn(ConnId, QUrlId, Url, FetchMSecs);
479    TMd5Sig UrlMd5Sig; int Lev; int Dep;
480    Queue->GetQUrl(QUrlId, UrlMd5Sig, Lev, Dep);
481    Queue->DelQUrl(QUrlId);
482    if (!UrlDescBs->IsUrl(UrlMd5Sig)){
483      /&bsol;**IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));
484      if (UrlMd5Sig!=TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0))){
485        SaveToErrLog("Begin:IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));");
486        SaveToErrLog(TStr::Fmt("Urls: %d", WebPg->GetUrls()).CStr());
487        SaveToErrLog(TStr::Fmt("Md5: %s", UrlMd5Sig.GetStr().CStr()).CStr());
488        for (int WebPgUrlN=0; WebPgUrlN<WebPg->GetUrls(); WebPgUrlN++){
489          SaveToErrLog(TStr::Fmt("Url #%d: %s",
490           WebPgUrlN,
491           WebPg->GetUrlStr(WebPgUrlN).CStr()).CStr());
492        }
493        SaveToErrLog("End:IAssert(UrlMd5Sig==TCrawler::GetUrlMd5Sig(WebPg->GetUrlStr(0)));");
494      }
495      for (int WebPgUrlN=0; WebPgUrlN<WebPg->GetUrls(); WebPgUrlN++){
496        TStr DocUrlStr=WebPg->GetUrlStr(WebPgUrlN);
497        TMd5Sig DocUrlMd5Sig=TCrawler::GetUrlMd5Sig(DocUrlStr);
498        if (!UrlDescBs->IsUrl(DocUrlMd5Sig)){
499          TBlobPt DocBlobPt; TMd5Sig DocMemMd5Sig;
500          TStr ContTypeNm=WebPg->GetHttpResp()->GetFldVal(THttp::ContTypeFldNm);
501          if (Def->IsContTypeNmOk(ContTypeNm)){
502            if (WebPgUrlN==WebPg->GetUrls()-1){
503              TMem DocMem; WebPg->GetHttpResp()->GetAsMem(DocMem);
504              DocMemMd5Sig=TMd5Sig(DocMem);
505              DocBlobPt=DocBs->AddDoc(DocUrlStr, DocMem);
506            } else {
507              TStr FinalUrlStr=WebPg->GetUrlStr(WebPg->GetUrls()-1);
508              PHttpResp RedirHttpResp=THttpResp::New(
509               THttp::RedirStatusCd, THttp::TextPlainFldVal, false, NULL, FinalUrlStr);
510              TMem DocMem; RedirHttpResp->GetAsMem(DocMem);
511              DocMemMd5Sig=TMd5Sig(DocMem);
512              DocBlobPt=DocBs->AddDoc(DocUrlStr, DocMem);
513            }
514          }
515          if (Def->IsRedirDmAllowed()){
516            PUrl Url=TUrl::New(DocUrlStr);
517            TStr HostNm=Url->GetHostNm();
518            Def->AddRqDmNm(HostNm);
519          }
520          TCrawlerUrlDesc UrlDesc(
521           DocBlobPt, DocMemMd5Sig, TSecTm::GetCurTm(), TUCh(Lev), TUCh(Dep));
522          UrlDescBs->AddUrlDesc(DocUrlMd5Sig, UrlDesc);
523        }
524      }
525    }
526    PCrawlerHost Host=HostBs->GetHost(Url->GetHostNm());
527    Host->GetIpNum()=WebPg->GetIpNum(0);
528    Host->GetActiveConns()--;
529    Host->GetFetchedUrls()++;
530    Host->GetTransferBytes()+=WebPg->GetHttpResp()->Len();
531    Host->GetTransferMSecs()+=int(WebPg->GetFetchMSecs());
532    Host->GetLastFetchTm()=TSecTm::GetCurTm();
533    TStr HostNm=Url->GetHostNm();
534    if (WebPg->GetHttpResp()->IsContType(THttp::TextFldVal)){
535      TUrlV OutUrlV; TUrlV OutRedirUrlV; WebPg->GetOutUrlV(OutUrlV, OutRedirUrlV);
536      if (Def->IsRedirDmAllowed()){
537        for (int UrlN=0; UrlN<OutRedirUrlV.Len(); UrlN++){
538          TStr HostNm=OutRedirUrlV[UrlN]->GetHostNm();
539          Def->AddRqDmNm(HostNm);
540        }
541      }
542      for (int UrlN=0; UrlN<OutUrlV.Len(); UrlN++){
543        TStr OutHostNm=OutUrlV[UrlN]->GetHostNm();
544        if (Def->IsHostNmOk(OutHostNm)){
545          if (Def->IsFExtOk(OutUrlV[UrlN])){
546            if (HostNm==OutHostNm){
547              Queue->PushQUrlToUrlQBs(OutUrlV[UrlN], Lev+1, Dep+1);
548            } else {
549              Queue->PushQUrlToUrlQBs(OutUrlV[UrlN], 0, Dep+1);
550            }
551          }
552        }
553      }
554    }
555    printf("Fetched [Lev:%d Dep:%d Queue:%d Fetched:%d Time:%d Size:%d]: %s\n",
556     Lev, Dep, Queue->GetQUrls(), UrlDescBs->GetUrls(), FetchMSecs,
557     WebPg->GetHttpResp()->Len(), WebPg->GetUrlStr().CStr());
558    Queue->ResetQUrlBs();
559    Queue->ShuffleUrlQ();
560    ClrZombies();
561    Fetch();
562    if (UrlDescBs->GetUrls()>=Def->GetMxUrls()){
563      TSysMsg::Quit();
564    }
565  }
566  void TCrawlerFetcher::OnError(const int& ConnId, const TStr& MsgStr){
567    DelCrawlerFetcherConn(ConnId);
568    Fetch();
569    printf("Error: %s\n", MsgStr.CStr());
570  }
571  void TCrawlerTimer::OnTimeOut(){
572    PCrawlerDef Def=Crawler->GetDef();
573    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
574    PCrawlerStat Stat=Crawler->GetStat();
575    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
576    uint64 InterEventMSecs=CurEventMSecs-LastEventMSecs;
577    uint64 ToutMSecs=GetTimeOut();
578    double TimerEventPrecision=(ToutMSecs==0) ? 0 : double(InterEventMSecs)/ToutMSecs;
579    if (TimerEventPrecision>1.01){
580      Fetcher->PutCurMxConns(int(Fetcher->GetCurMxConns()*0.90));
581    } else {
582      Fetcher->PutCurMxConns(Fetcher->GetCurMxConns()+1);
583    }
584    if (Fetcher->GetCurMxConns()<Def->GetMnConns()){
585      Fetcher->PutCurMxConns(Def->GetMnConns());}
586    if (Fetcher->GetCurMxConns()>Def->GetMxConns()){
587      Fetcher->PutCurMxConns(Def->GetMxConns());}
588    printf("---------------------------------------------------------------\n"); 
589    printf("*** Crawler-Timer: Timeout-Precision=%.3f CurMxConns=%d\n", 
590     TimerEventPrecision, Fetcher->GetCurMxConns());
591    if (Crawler->GetFetcher()->Empty()&&Crawler->GetQueue()->Empty()){
592      Crawler->GetQueue()->PushQUrlBs();
593      if (Crawler->GetQueue()->Empty()){
594        TSysMsg::Quit();
595      }
596    } else {
597      int QUrls=Crawler->GetQueue()->GetQUrls();
598      int MnQLen=Crawler->GetDef()->GetMnQLen();
599      if ((QUrls%100==0)&&(QUrls<MnQLen)){
600        Crawler->GetQueue()->PushQUrlBs();
601      }
602      Crawler->GetFetcher()->Fetch();
603    }
604    if (Last100SecsEventMSecs==0){
605      Last100SecsEventMSecs=CurEventMSecs;
606    } else 
607    if (CurEventMSecs-Last100SecsEventMSecs>=100000){
608      Stat->On100Secs();
609      Last100SecsEventMSecs=CurEventMSecs;
610    }
611    if (Last1000SecsEventMSecs==0){
612      Last1000SecsEventMSecs=CurEventMSecs;
613    } else 
614    if (CurEventMSecs-Last1000SecsEventMSecs>=1000000){
615      Stat->On1000Secs();
616      Last1000SecsEventMSecs=CurEventMSecs;
617    }
618    LastEventMSecs=CurEventMSecs;
619  }
620  TStr TCrawlerWebSrv::GetUrlStr(const int& RefreshSecs, const TStr& SortOrderNm){
621    TChA UrlChA;
622    UrlChA+='/';
623    UrlChA+='?';
624    UrlChA+=TStr::Fmt("Refresh=%d", RefreshSecs);
625    UrlChA+='&';
626    UrlChA+=TStr::Fmt("Sort=%s", SortOrderNm.CStr());
627    return UrlChA;
628  }
629  TStr TCrawlerWebSrv::GetAnchorStr(const TStr& DescStr, 
630   const int& RefreshSecs, const TStr& SortOrderNm){
631    TChA AnchorChA;
632    TStr UrlStr=GetUrlStr(RefreshSecs, SortOrderNm);
633    AnchorChA+=TStr::Fmt("<a href=\"%s\">", UrlStr.CStr());
634    AnchorChA+=DescStr;
635    AnchorChA+="</a>";
636    return AnchorChA;
637  }
638  void TCrawlerWebSrv::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
639    PCrawlerHostBs HostBs=Crawler->GetHostBs();
640    PCrawlerUrlDescBs UrlDescBs=Crawler->GetUrlDescBs();
641    PCrawlerFetcher Fetcher=Crawler->GetFetcher();
642    PCrawlerQueue Queue=Crawler->GetQueue();
643    PCrawlerStat Stat=Crawler->GetStat();
644    TStr UrlStr=HttpRq->GetUrl()->GetUrlStr();
645    TStr UrlPathStr=HttpRq->GetUrl()->GetPathStr();
646    PUrlEnv UrlEnv=HttpRq->GetUrlEnv();
647    bool StopCrawlingP=false;
648    if (UrlPathStr=="/Stop"){
649      StopCrawlingP=true;
650      TSysMsg::Quit();
651    }
652    int RefreshSecs=UrlEnv->GetVal("Refresh").GetInt(100);
653    TStr SortOrderNm=UrlEnv->GetVal("Sort");
654    TChA HtmlChA;
655    int ActiveConns; int FetchedUrls; int FetchErrors; int QueueUrls;
656    double TransferBytes; double TransferMSecs; 
657    double AvgHttpRespLen; double AvgTransferBps;
658    HostBs->GetSummaryInfo(ActiveConns, FetchedUrls, FetchErrors, QueueUrls, 
659     TransferBytes, TransferMSecs, AvgHttpRespLen, AvgTransferBps);
660    {HtmlChA+="<html><head><title>Crawling</title>";
661    if ((!StopCrawlingP)&&(RefreshSecs>0)){
662      HtmlChA+=TStr::Fmt("<meta http-equiv=\"refresh\" content=\"%d\">", RefreshSecs);}
663    HtmlChA+="</head><body>";
664    HtmlChA+="<h1>WebBird-Crawler</h1>";
665    HtmlChA+=TSecTm::GetCurTm().GetStr(); HtmlChA+="<br>";
666    HtmlChA+="<form method=get action=\"/Stop\">";
667    HtmlChA+="<input type=submit value=Stop>";
668    HtmlChA+="</form>";
669    HtmlChA+="<form method=get action=\"/\">";
670    HtmlChA+="<input type=submit value=\"Refresh Seconds\">";
671    HtmlChA+=TStr::Fmt("<input type=text name=\"Refresh\" value=\"%d\" size=2>", RefreshSecs);
672    HtmlChA+="</form>";}
673    {HtmlChA+="<h2>General Info</h2>\n";
674    uint64 StartMSecs=TTm::GetMSecsFromTm(Crawler->GetStartTm());
675    uint64 CurMSecs=TTm::GetCurUniMSecs();
676    uint64 CrawlingMSecs=CurMSecs-StartMSecs;
677    double CrawlingSecs=CrawlingMSecs/1000.0;
678    double CrawlingPpsSpeed=CrawlingSecs<=0 ? 0 : FetchedUrls/CrawlingSecs;
679    double AvgPgLen=(FetchedUrls>0)&&(TransferBytes>0) ? TransferBytes/FetchedUrls : 0;
680    HtmlChA+="<table border=1>\n";
681    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Urls Fetched<td align=right>%d</tr>\n", UrlDescBs->GetUrls());
682    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Queue Length<td align=right>%d</tr>\n", Queue->GetQUrls());
683    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Time<td align=right>%.0fs</tr>\n", CrawlingSecs);
684    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed<td align=right>%.3fpps</tr>\n", CrawlingPpsSpeed);
685    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed (last 1000secs)<td align=right>%.3fpps</tr>\n", 
686      Stat->GetLast1000SecsCrawlingSpeed());
687    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Crawling Speed (last 100secs)<td align=right>%.3fpps</tr>\n", 
688      Stat->GetLast100SecsCrawlingSpeed());
689    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Avg. Page Length<td align=right>%sb</tr>\n", 
690     TFlt::GetGigaStr(AvgPgLen).CStr());
691    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Cleaned Zombies<td align=right>%d</tr>\n", Fetcher->GetZombies());
692    HtmlChA+="</table>\n";}
693    {HtmlChA+="<h2>Hosts</h2>\n";
694    HtmlChA+="<table border=1>\n";
695    HtmlChA+=TStr::Fmt("<tr><th>%s (%d)<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s<th>%s</tr>\n", 
696     GetAnchorStr("Hosts", RefreshSecs, "Host").CStr(),
697     HostBs->GetHosts(),
698     GetAnchorStr("Active", RefreshSecs, "Active").CStr(),
699     GetAnchorStr("Fetched", RefreshSecs, "Fetched").CStr(),
700     GetAnchorStr("Errors", RefreshSecs, "Errors").CStr(),
701     GetAnchorStr("Queue", RefreshSecs, "Queue").CStr(),
702     GetAnchorStr("Bytes", RefreshSecs, "Bytes").CStr(),
703     GetAnchorStr("Time", RefreshSecs, "Time").CStr(),
704     GetAnchorStr("PageLen", RefreshSecs, "PageLen").CStr(),
705     GetAnchorStr("Speed", RefreshSecs, "Speed").CStr());
706    HtmlChA+=TStr::Fmt("<tr><td align=right><b>Summary</b>"
707      "<td align=right><b>%d</b><td align=right><b>%d</b><td align=right><b>%d</b><td align=right><b>%d</b>"
708      "<td align=right><b>%sb</b><td align=right><b>%ss</b><td align=right><b>%sb</b><td align=right><b>%sbps</b></tr>\n",
709     ActiveConns, FetchedUrls, FetchErrors, QueueUrls, 
710     TFlt::GetGigaStr(TransferBytes).CStr(), 
711     TFlt::GetGigaStr(TransferMSecs/1000).CStr(), 
712     TFlt::GetGigaStr(AvgHttpRespLen).CStr(),
713     TFlt::GetGigaStr(AvgTransferBps).CStr());
714    TCrawlerHostV HostV; HostBs->GetSortedHostV(HostV, SortOrderNm);
715    for (int HostN=0; HostN<HostV.Len(); HostN++){
716      PCrawlerHost Host=HostV[HostN];
717      HtmlChA+=TStr::Fmt("<tr><td align=right><a href=\"http:&bsol;&bsol;%s\">%s<a>"
718       "<td align=right>%d<td align=right>%d<td align=right>%d<td align=right>%d"
719       "<td align=right>%sb<td align=right>%ss<td align=right>%sb<td align=right>%sbps</tr>\n",
720       Host->GetHostNm().CStr(), 
721       Host->GetHostNm().CStr(), 
722       Host->GetActiveConns(),
723       Host->GetFetchedUrls(), 
724       Host->GetFetchErrors(), 
725       Host->GetQueueUrls(),
726       TFlt::GetGigaStr(double(Host->GetTransferBytes())).CStr(), 
727       TFlt::GetGigaStr(Host->GetTransferMSecs()/1000).CStr(),
728       TFlt::GetGigaStr(Host->GetAvgHttpRespLen()).CStr(),
729       TFlt::GetGigaStr(Host->GetAvgTransferBps()).CStr()); 
730    }
731    HtmlChA+="</table>";}
732    {HtmlChA+="<h2>Queue Levels</h2>\n";
733    HtmlChA+="<table border=1>\n";
734    int AllQUrls=Queue->GetQUrls();
735    HtmlChA+=TStr::Fmt("<tr><td align=right>%s<td align=right>%d</tr>\n",
736     "All Queue Urls", AllQUrls);
737    HtmlChA+=TStr::Fmt("<tr><td align=right>%s<td align=right>%d</tr>\n",
738      "Unconn Queue Urls", Queue->GetUnconnQUrls());
739    for (int Lev=0; Lev<Queue->GetQLevs(); Lev++){
740      HtmlChA+=TStr::Fmt("<tr><td align=right>Level-%d Urls<td align=right>%d</tr>\n",
741       Lev, Queue->GetQLevUrls(Lev));
742    }
743    HtmlChA+="</table>";}
744    {HtmlChA+="<h2>Queue</h2>\n";
745    TIntStrPrV QUrlsHostPrV; Queue->GetQUrlsHostPrV(QUrlsHostPrV);
746    HtmlChA+="<table border=1>\n";
747    HtmlChA+=TStr::Fmt("<tr><th>#<th>Host<th>Queue-Urls<th>%%</tr>\n");
748    int AllQUrls=Queue->GetQUrls();
749    for (int HostN=0; HostN<QUrlsHostPrV.Len(); HostN++){
750      TStr HostLevNm=QUrlsHostPrV[HostN].Val2;
751      TStr HostNm; TStr LevStr; HostLevNm.SplitOnCh(HostNm, ':', LevStr);
752      int QUrls=QUrlsHostPrV[HostN].Val1;
753      double QUrlsPrc=double(QUrls)/double(AllQUrls);
754      HtmlChA+=TStr::Fmt("<tr><td align=right>%d<td align=right><a href=\"http:&bsol;&bsol;%s/\">%s</a> / %s"
755       "<td align=right>%d<td align=right>%.3f%%</tr>\n",
756       1+HostN, HostNm.CStr(), HostNm.CStr(), LevStr.CStr(), QUrls, 100*QUrlsPrc);
757    }
758    HtmlChA+="</table>";}
759    {TIntStrIntIntQuV ConnIdUrlStrMSecsSizeQuV;
760    Fetcher->GetConnV(ConnIdUrlStrMSecsSizeQuV);
761    int ConnIds=ConnIdUrlStrMSecsSizeQuV.Len();
762    HtmlChA+="<h2>Connections</h2>\n";
763    HtmlChA+="<table border=1>\n";
764    HtmlChA+="<tr><th>#<th>Connection<th>Time<th>Size<th>Url</tr>\n";
765    for (int ConnN=0; ConnN<ConnIds; ConnN++){
766      int ConnId=ConnIdUrlStrMSecsSizeQuV[ConnN].Val1;
767      TStr UrlStr=ConnIdUrlStrMSecsSizeQuV[ConnN].Val2;
768      int FetchMSecs=ConnIdUrlStrMSecsSizeQuV[ConnN].Val3;
769      int FetchSize=ConnIdUrlStrMSecsSizeQuV[ConnN].Val4;
770      HtmlChA+=TStr::Fmt("<tr><td>%d<td>%d<td>%ss<td>%sb<td><a href=\"%s\">%s</a></tr>\n",
771       1+ConnN, ConnId, 
772       TFlt::GetGigaStr(FetchMSecs/1000).CStr(), TFlt::GetGigaStr(FetchSize).CStr(), 
773       UrlStr.CStr(), UrlStr.CStr());
774    }
775    HtmlChA+="</table>\n";}
776    HtmlChA+="</body></html>";
777    PSIn BodySIn=TMIn::New(HtmlChA);
778    PHttpResp HttpResp=THttpResp::New(
779     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, BodySIn);
780    SendHttpResp(SockId, HttpResp);
781  }
782  TFAccess TCrawlerDocBs::Open(){
783    TFAccess DocBsFAccess=TFRnd::GetFAccessFromStr(DocBsFAccessNm);
784    IAssert((DocBsFAccess==faCreate)||(DocBsFAccess==faUpdate)||(DocBsFAccess==faRestore));
785    DocBBs=TMBlobBs::New(DocBsNrFPath+DocBsNm, DocBsFAccess, DocBsMxSegLen);
786    return DocBsFAccess;
787  }
788  void TCrawlerDocBs::Close(){
789    DocBBs=NULL;
790  }
791  TBlobPt TCrawlerDocBs::AddDoc(const TStr& DocUrlStr, const TMem& DocMem){
792    TMOut SOut(DocUrlStr.Len()+DocMem.Len()+100);
793    TTm::GetCurUniTm().GetWebLogDateTimeStr().Save(SOut);
794    DocUrlStr.Save(SOut);
795    DocMem.Save(SOut);
796    PSIn SIn=SOut.GetSIn();
797    TBlobPt BPt=DocBBs->PutBlob(SIn);
798    return BPt;
799  }
800  bool TCrawlerDocBs::FNextDocBlobPt(TBlobPt& TrvDocBlobPt,
801   TBlobPt& DocBlobPt, TStr& DateTimeStr, TStr& DocUrlStr, TMem& DocMem){
802    PSIn DocBlobSIn;
803    if (DocBBs->FNextBlobPt(TrvDocBlobPt, DocBlobPt, DocBlobSIn)){
804      DateTimeStr=TStr(*DocBlobSIn); 
805      DocUrlStr=TStr(*DocBlobSIn); 
806      DocMem=TMem(*DocBlobSIn); 
807      return true;
808    } else {
809      return false;
810    }
811  }
812  void TCrawlerStat::On100Secs(){
813    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
814    uint64 CurFetchedUrls=Crawler->GetUrlDescBs()->GetUrls();
815    double DiffSecs=(CurEventMSecs-Last100SecsEventMSecs)/double(1000);
816    if (DiffSecs<1){
817      Last100SecsCrawlingSpeed=0;
818    } else {
819      Last100SecsCrawlingSpeed=(CurFetchedUrls-Last100SecsFetchedUrls)/DiffSecs;
820    }
821    Last100SecsEventMSecs=CurEventMSecs;
822    Last100SecsFetchedUrls=CurFetchedUrls;
823  }
824  void TCrawlerStat::On1000Secs(){
825    uint64 CurEventMSecs=TTm::GetCurUniMSecs();
826    uint64 CurFetchedUrls=Crawler->GetUrlDescBs()->GetUrls();
827    double DiffSecs=(CurEventMSecs-Last1000SecsEventMSecs)/double(1000);
828    if (DiffSecs<1){
829      Last1000SecsCrawlingSpeed=0;
830    } else {
831      Last1000SecsCrawlingSpeed=(CurFetchedUrls-Last1000SecsFetchedUrls)/DiffSecs;
832    }
833    Last1000SecsEventMSecs=CurEventMSecs;
834    Last1000SecsFetchedUrls=CurFetchedUrls;
835  }
836  TCrawler::TCrawler():
837    Def(TCrawlerDef::New()),
838    UrlDescBs(), HostBs(), Queue(), Fetcher(), DocBs(), Timer(), WebSrv(),
839    StartTm(TTm::GetCurUniTm()){
840    DocBs=TCrawlerDocBs::New(this);
841  }
842  void TCrawler::DefCrawlBs(const TStr& CrawlBsNm, const TStr& CrawlBsFPath,
843   const TStr& CrawlBsFAccessNm, const int& CrawlBsMxSegLen){
844    PCrawlerDocBs DocBs=GetDocBs();
845    DocBs->PutDocBsNm(CrawlBsNm);
846    DocBs->PutDocBsNrFPath(TStr::GetNrFPath(CrawlBsFPath));
847    DocBs->PutDocBsFAccessNm(CrawlBsFAccessNm);
848    DocBs->PutDocBsMxSegLen(CrawlBsMxSegLen);
849  }
850  void TCrawler::StartCrawling(){
851    UrlDescBs=TCrawlerUrlDescBs::New(this);
852    HostBs=TCrawlerHostBs::New(this);
853    Queue=TCrawlerQueue::New(this);
854    Fetcher=TCrawlerFetcher::New(this);
855    Stat=TCrawlerStat::New(this);
856    TFAccess DocBsFAccess=GetDocBs()->Open();
857    if (DocBsFAccess==faCreate){
858      PCrawlerDef Def=GetDef();
859      int StartUrls=Def->GetStartUrls();
860      for (int UrlN=0; UrlN<StartUrls; UrlN++){
861        Queue->PushQUrl(Def->GetStartUrl(UrlN), 0, 0);}
862    }
863    if (DocBsFAccess==faRestore){
864      printf("Restoring Crawled Documents...\n");
865      TBlobPt TrvDocBlobPt=GetDocBs()->FFirstDocBlobPt();
866      TBlobPt DocBlobPt; TStr DateTimeStr; TStr DocUrlStr; TMem DocMem; int DocN=0;
867      while (GetDocBs()->FNextDocBlobPt(TrvDocBlobPt, DocBlobPt, DateTimeStr, DocUrlStr, DocMem)){
868        DocN++; printf("%d\r", DocN);
869        TMd5Sig DocUrlMd5Sig=TCrawler::GetUrlMd5Sig(DocUrlStr);
870        TMd5Sig DocMemMd5Sig(DocMem);
871        TCrawlerUrlDesc UrlDesc(DocBlobPt, DocMemMd5Sig, TSecTm::GetCurTm(), TUCh(0), TUCh(0));
872        UrlDescBs->AddUrlDesc(DocUrlMd5Sig, UrlDesc);
873      }
874      printf("\nDone.\n");
875    }
876    if (DocBsFAccess==faUpdate){
877      GetUrlDescBs()->Load();
878    }
879    Timer=TCrawlerTimer::New(this, 1000);
880    WebSrv=TCrawlerWebSrv::New(this);
881    Fetcher->Fetch();
882  }
883  void TCrawler::StopCrawling(){
884    WebSrv=NULL;
885    Timer->StopTimer();
886    GetDocBs()->Close();
887    GetUrlDescBs()->Save();
888    GetQueue()->PopSaveQUrlBs();
889  }
890  TMd5Sig TCrawler::GetUrlMd5Sig(const TStr& UrlStr){
891    TStr LcUrlStr=UrlStr.GetLc();
892    return TMd5Sig(LcUrlStr);
893  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.cpp</div>
                </div>
                <div class="column column_space"><pre><code>344      TInt(Dep).Save(UrlQSOut);
345      PSIn UrlQSIn=UrlQSOut.GetSIn();
346      TBlobPt UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
347      if (UrlQBlobPt.Empty()){
</pre></code></div>
                <div class="column column_space"><pre><code>380        TInt(Dep).Save(UrlQSOut);
381        PSIn UrlQSIn=UrlQSOut.GetSIn();
382        TBlobPt UrlQBlobPt=UrlQBBs->PutBlob(UrlQSIn);
383      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    