
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-duration.cc</h3>
            <pre><code>1  #if defined(_MSC_VER)
2  #include &lt;winsock2.h&gt;  
3  #endif
4  #include &lt;algorithm&gt;
5  #include &lt;cassert&gt;
6  #include &lt;cctype&gt;
7  #include &lt;cerrno&gt;
8  #include &lt;cmath&gt;
9  #include &lt;cstdint&gt;
10  #include &lt;cstdlib&gt;
11  #include &lt;cstring&gt;
12  #include &lt;ctime&gt;
13  #include &lt;functional&gt;
14  #include &lt;limits&gt;
15  #include &lt;string&gt;
16  #include &quot;absl/base/casts.h&quot;
17  #include &quot;absl/base/macros.h&quot;
18  #include &quot;absl/numeric/int128.h&quot;
19  #include &quot;absl/strings/string_view.h&quot;
20  #include &quot;absl/strings/strip.h&quot;
21  #include &quot;absl/time/time.h&quot;
22  namespace absl {
23  ABSL_NAMESPACE_BEGIN
24  namespace {
25  using time_internal::kTicksPerNanosecond;
26  using time_internal::kTicksPerSecond;
27  constexpr int64_t kint64max = std::numeric_limits&lt;int64_t&gt;::max();
28  constexpr int64_t kint64min = std::numeric_limits&lt;int64_t&gt;::min();
29  inline bool IsFinite(double d) {
30    if (std::isnan(d)) return false;
31    return d != std::numeric_limits&lt;double&gt;::infinity() &amp;&amp;
32           d != -std::numeric_limits&lt;double&gt;::infinity();
33  }
34  inline bool IsValidDivisor(double d) {
35    if (std::isnan(d)) return false;
36    return d != 0.0;
37  }
38  inline void NormalizeTicks(int64_t* sec, int64_t* ticks) {
39    if (*ticks &lt; 0) {
40      --*sec;
41      *ticks += kTicksPerSecond;
42    }
43  }
44  inline uint128 MakeU128(int64_t a) {
45    uint128 u128 = 0;
46    if (a &lt; 0) {
47      ++u128;
48      ++a;  
49      a = -a;
50    }
51    u128 += static_cast&lt;uint64_t&gt;(a);
52    return u128;
53  }
54  inline uint128 MakeU128Ticks(Duration d) {
55    int64_t rep_hi = time_internal::GetRepHi(d);
56    uint32_t rep_lo = time_internal::GetRepLo(d);
57    if (rep_hi &lt; 0) {
58      ++rep_hi;
59      rep_hi = -rep_hi;
60      rep_lo = kTicksPerSecond - rep_lo;
61    }
62    uint128 u128 = static_cast&lt;uint64_t&gt;(rep_hi);
63    u128 *= static_cast&lt;uint64_t&gt;(kTicksPerSecond);
64    u128 += rep_lo;
65    return u128;
66  }
67  inline Duration MakeDurationFromU128(uint128 u128, bool is_neg) {
68    int64_t rep_hi;
69    uint32_t rep_lo;
70    const uint64_t h64 = Uint128High64(u128);
71    const uint64_t l64 = Uint128Low64(u128);
72    if (h64 == 0) {  
73      const uint64_t hi = l64 / kTicksPerSecond;
74      rep_hi = static_cast&lt;int64_t&gt;(hi);
75      rep_lo = static_cast&lt;uint32_t&gt;(l64 - hi * kTicksPerSecond);
76    } else {
77      const uint64_t kMaxRepHi64 = 0x77359400UL;
78      if (h64 &gt;= kMaxRepHi64) {
79        if (is_neg &amp;&amp; h64 == kMaxRepHi64 &amp;&amp; l64 == 0) {
80          return time_internal::MakeDuration(kint64min);
81        }
82        return is_neg ? -InfiniteDuration() : InfiniteDuration();
83      }
84      const uint128 kTicksPerSecond128 = static_cast&lt;uint64_t&gt;(kTicksPerSecond);
85      const uint128 hi = u128 / kTicksPerSecond128;
86      rep_hi = static_cast&lt;int64_t&gt;(Uint128Low64(hi));
87      rep_lo =
88          static_cast&lt;uint32_t&gt;(Uint128Low64(u128 - hi * kTicksPerSecond128));
89    }
90    if (is_neg) {
91      rep_hi = -rep_hi;
92      if (rep_lo != 0) {
93        --rep_hi;
94        rep_lo = kTicksPerSecond - rep_lo;
95      }
96    }
97    return time_internal::MakeDuration(rep_hi, rep_lo);
98  }
99  inline uint64_t EncodeTwosComp(int64_t v) {
100    return absl::bit_cast&lt;uint64_t&gt;(v);
101  }
102  inline int64_t DecodeTwosComp(uint64_t v) { return absl::bit_cast&lt;int64_t&gt;(v); }
103  inline bool SafeAddRepHi(double a_hi, double b_hi, Duration* d) {
104    double c = a_hi + b_hi;
105    if (c &gt;= static_cast&lt;double&gt;(kint64max)) {
106      *d = InfiniteDuration();
107      return false;
108    }
109    if (c &lt;= static_cast&lt;double&gt;(kint64min)) {
110      *d = -InfiniteDuration();
111      return false;
112    }
113    *d = time_internal::MakeDuration(c, time_internal::GetRepLo(*d));
114    return true;
115  }
116  template &lt;typename Ignored&gt;
117  struct SafeMultiply {
118    uint128 operator()(uint128 a, uint128 b) const {
119      assert(Uint128High64(b) == 0);
120      if (Uint128High64(a) == 0) {
121        return (((Uint128Low64(a) | Uint128Low64(b)) &gt;&gt; 32) == 0)
122                   ? static_cast&lt;uint128&gt;(Uint128Low64(a) * Uint128Low64(b))
123                   : a * b;
124      }
125      return b == 0 ? b : (a &gt; kuint128max / b) ? kuint128max : a * b;
126    }
127  };
128  template &lt;template &lt;typename&gt; class Operation&gt;
129  inline Duration ScaleFixed(Duration d, int64_t r) {
130    const uint128 a = MakeU128Ticks(d);
131    const uint128 b = MakeU128(r);
132    const uint128 q = Operation&lt;uint128&gt;()(a, b);
133    const bool is_neg = (time_internal::GetRepHi(d) &lt; 0) != (r &lt; 0);
134    return MakeDurationFromU128(q, is_neg);
135  }
136  template &lt;template &lt;typename&gt; class Operation&gt;
137  inline Duration ScaleDouble(Duration d, double r) {
138    Operation&lt;double&gt; op;
139    double hi_doub = op(time_internal::GetRepHi(d), r);
140    double lo_doub = op(time_internal::GetRepLo(d), r);
141    double hi_int = 0;
142    double hi_frac = std::modf(hi_doub, &amp;hi_int);
143    lo_doub /= kTicksPerSecond;
144    lo_doub += hi_frac;
145    double lo_int = 0;
146    double lo_frac = std::modf(lo_doub, &amp;lo_int);
147    int64_t lo64 = std::round(lo_frac * kTicksPerSecond);
148    Duration ans;
149    if (!SafeAddRepHi(hi_int, lo_int, &amp;ans)) return ans;
150    int64_t hi64 = time_internal::GetRepHi(ans);
151    if (!SafeAddRepHi(hi64, lo64 / kTicksPerSecond, &amp;ans)) return ans;
152    hi64 = time_internal::GetRepHi(ans);
153    lo64 %= kTicksPerSecond;
154    NormalizeTicks(&amp;hi64, &amp;lo64);
155    return time_internal::MakeDuration(hi64, lo64);
156  }
157  inline bool IDivFastPath(const Duration num, const Duration den, int64_t* q,
158                           Duration* rem) {
159    if (time_internal::IsInfiniteDuration(num) ||
160        time_internal::IsInfiniteDuration(den))
161      return false;
162    int64_t num_hi = time_internal::GetRepHi(num);
163    uint32_t num_lo = time_internal::GetRepLo(num);
164    int64_t den_hi = time_internal::GetRepHi(den);
165    uint32_t den_lo = time_internal::GetRepLo(den);
166    if (den_hi == 0 &amp;&amp; den_lo == kTicksPerNanosecond) {
167      if (num_hi &gt;= 0 &amp;&amp; num_hi &lt; (kint64max - kTicksPerSecond) / 1000000000) {
168        *q = num_hi * 1000000000 + num_lo / kTicksPerNanosecond;
169        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
170        return true;
171      }
172    } else if (den_hi == 0 &amp;&amp; den_lo == 100 * kTicksPerNanosecond) {
173      if (num_hi &gt;= 0 &amp;&amp; num_hi &lt; (kint64max - kTicksPerSecond) / 10000000) {
174        *q = num_hi * 10000000 + num_lo / (100 * kTicksPerNanosecond);
175        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
176        return true;
177      }
178    } else if (den_hi == 0 &amp;&amp; den_lo == 1000 * kTicksPerNanosecond) {
179      if (num_hi &gt;= 0 &amp;&amp; num_hi &lt; (kint64max - kTicksPerSecond) / 1000000) {
180        *q = num_hi * 1000000 + num_lo / (1000 * kTicksPerNanosecond);
181        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
182        return true;
183      }
184    } else if (den_hi == 0 &amp;&amp; den_lo == 1000000 * kTicksPerNanosecond) {
185      if (num_hi &gt;= 0 &amp;&amp; num_hi &lt; (kint64max - kTicksPerSecond) / 1000) {
186        *q = num_hi * 1000 + num_lo / (1000000 * kTicksPerNanosecond);
187        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
188        return true;
189      }
190    } else if (den_hi &gt; 0 &amp;&amp; den_lo == 0) {
191      if (num_hi &gt;= 0) {
192        if (den_hi == 1) {
193          *q = num_hi;
194          *rem = time_internal::MakeDuration(0, num_lo);
195          return true;
196        }
197        *q = num_hi / den_hi;
198        *rem = time_internal::MakeDuration(num_hi % den_hi, num_lo);
199        return true;
200      }
201      if (num_lo != 0) {
202        num_hi += 1;
203      }
204      int64_t quotient = num_hi / den_hi;
205      int64_t rem_sec = num_hi % den_hi;
206      if (rem_sec &gt; 0) {
207        rem_sec -= den_hi;
208        quotient += 1;
209      }
210      if (num_lo != 0) {
211        rem_sec -= 1;
212      }
213      *q = quotient;
214      *rem = time_internal::MakeDuration(rem_sec, num_lo);
215      return true;
216    }
217    return false;
218  }
219  }  
220  namespace time_internal {
221  int64_t IDivDuration(bool satq, const Duration num, const Duration den,
222                       Duration* rem) {
223    int64_t q = 0;
224    if (IDivFastPath(num, den, &amp;q, rem)) {
225      return q;
226    }
227    const bool num_neg = num &lt; ZeroDuration();
228    const bool den_neg = den &lt; ZeroDuration();
229    const bool quotient_neg = num_neg != den_neg;
230    if (time_internal::IsInfiniteDuration(num) || den == ZeroDuration()) {
231      *rem = num_neg ? -InfiniteDuration() : InfiniteDuration();
232      return quotient_neg ? kint64min : kint64max;
233    }
234    if (time_internal::IsInfiniteDuration(den)) {
235      *rem = num;
236      return 0;
237    }
238    const uint128 a = MakeU128Ticks(num);
239    const uint128 b = MakeU128Ticks(den);
240    uint128 quotient128 = a / b;
241    if (satq) {
242      if (quotient128 &gt; uint128(static_cast&lt;uint64_t&gt;(kint64max))) {
243        quotient128 = quotient_neg ? uint128(static_cast&lt;uint64_t&gt;(kint64min))
244                                   : uint128(static_cast&lt;uint64_t&gt;(kint64max));
245      }
246    }
247    const uint128 remainder128 = a - quotient128 * b;
248    *rem = MakeDurationFromU128(remainder128, num_neg);
249    if (!quotient_neg || quotient128 == 0) {
250      return Uint128Low64(quotient128) &amp; kint64max;
251    }
252    return -static_cast&lt;int64_t&gt;(Uint128Low64(quotient128 - 1) &amp; kint64max) - 1;
253  }
254  }  
255  Duration&amp; Duration::operator+=(Duration rhs) {
256    if (time_internal::IsInfiniteDuration(*this)) return *this;
257    if (time_internal::IsInfiniteDuration(rhs)) return *this = rhs;
258    const int64_t orig_rep_hi = rep_hi_.Get();
259    rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) +
260                             EncodeTwosComp(rhs.rep_hi_.Get()));
261    if (rep_lo_ &gt;= kTicksPerSecond - rhs.rep_lo_) {
262      rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) + 1);
263      rep_lo_ -= kTicksPerSecond;
264    }
265    rep_lo_ += rhs.rep_lo_;
266    if (rhs.rep_hi_.Get() &lt; 0 ? rep_hi_.Get() &gt; orig_rep_hi
267                              : rep_hi_.Get() &lt; orig_rep_hi) {
268      return *this =
269                 rhs.rep_hi_.Get() &lt; 0 ? -InfiniteDuration() : InfiniteDuration();
270    }
271    return *this;
272  }
273  Duration&amp; Duration::operator-=(Duration rhs) {
274    if (time_internal::IsInfiniteDuration(*this)) return *this;
275    if (time_internal::IsInfiniteDuration(rhs)) {
276      return *this = rhs.rep_hi_.Get() &gt;= 0 ? -InfiniteDuration()
277                                            : InfiniteDuration();
278    }
279    const int64_t orig_rep_hi = rep_hi_.Get();
280    rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) -
281                             EncodeTwosComp(rhs.rep_hi_.Get()));
282    if (rep_lo_ &lt; rhs.rep_lo_) {
283      rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) - 1);
284      rep_lo_ += kTicksPerSecond;
285    }
286    rep_lo_ -= rhs.rep_lo_;
287    if (rhs.rep_hi_.Get() &lt; 0 ? rep_hi_.Get() &lt; orig_rep_hi
288                              : rep_hi_.Get() &gt; orig_rep_hi) {
289      return *this = rhs.rep_hi_.Get() &gt;= 0 ? -InfiniteDuration()
290                                            : InfiniteDuration();
291    }
292    return *this;
293  }
294  Duration&amp; Duration::operator*=(int64_t r) {
295    if (time_internal::IsInfiniteDuration(*this)) {
296      const bool is_neg = (r &lt; 0) != (rep_hi_.Get() &lt; 0);
297      return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
298    }
299    return *this = ScaleFixed&lt;SafeMultiply&gt;(*this, r);
300  }
301  Duration&amp; Duration::operator*=(double r) {
302    if (time_internal::IsInfiniteDuration(*this) || !IsFinite(r)) {
303      const bool is_neg = std::signbit(r) != (rep_hi_.Get() &lt; 0);
304      return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
305    }
306    return *this = ScaleDouble&lt;std::multiplies&gt;(*this, r);
307  }
308  Duration&amp; Duration::operator/=(int64_t r) {
309    if (time_internal::IsInfiniteDuration(*this) || r == 0) {
310      const bool is_neg = (r &lt; 0) != (rep_hi_.Get() &lt; 0);
311      return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
312    }
313    return *this = ScaleFixed&lt;std::divides&gt;(*this, r);
314  }
315  Duration&amp; Duration::operator/=(double r) {
316    if (time_internal::IsInfiniteDuration(*this) || !IsValidDivisor(r)) {
317      const bool is_neg = std::signbit(r) != (rep_hi_.Get() &lt; 0);
318      return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
319    }
320    return *this = ScaleDouble&lt;std::divides&gt;(*this, r);
321  }
322  Duration&amp; Duration::operator%=(Duration rhs) {
323    time_internal::IDivDuration(false, *this, rhs, this);
324    return *this;
325  }
326  double FDivDuration(Duration num, Duration den) {
327    if (time_internal::IsInfiniteDuration(num) || den == ZeroDuration()) {
328      return (num &lt; ZeroDuration()) == (den &lt; ZeroDuration())
329                 ? std::numeric_limits&lt;double&gt;::infinity()
330                 : -std::numeric_limits&lt;double&gt;::infinity();
331    }
332    if (time_internal::IsInfiniteDuration(den)) return 0.0;
333    double a =
334        static_cast&lt;double&gt;(time_internal::GetRepHi(num)) * kTicksPerSecond +
335        time_internal::GetRepLo(num);
336    double b =
337        static_cast&lt;double&gt;(time_internal::GetRepHi(den)) * kTicksPerSecond +
338        time_internal::GetRepLo(den);
339    return a / b;
340  }
341  Duration Trunc(Duration d, Duration unit) {
342    return d - (d % unit);
343  }
344  Duration Floor(const Duration d, const Duration unit) {
345    const absl::Duration td = Trunc(d, unit);
346    return td &lt;= d ? td : td - AbsDuration(unit);
347  }
348  Duration Ceil(const Duration d, const Duration unit) {
349    const absl::Duration td = Trunc(d, unit);
350    return td &gt;= d ? td : td + AbsDuration(unit);
351  }
352  Duration DurationFromTimespec(timespec ts) {
353    if (static_cast&lt;uint64_t&gt;(ts.tv_nsec) &lt; 1000 * 1000 * 1000) {
354      int64_t ticks = ts.tv_nsec * kTicksPerNanosecond;
355      return time_internal::MakeDuration(ts.tv_sec, ticks);
356    }
357    return Seconds(ts.tv_sec) + Nanoseconds(ts.tv_nsec);
358  }
359  Duration DurationFromTimeval(timeval tv) {
360    if (static_cast&lt;uint64_t&gt;(tv.tv_usec) &lt; 1000 * 1000) {
361      int64_t ticks = tv.tv_usec * 1000 * kTicksPerNanosecond;
362      return time_internal::MakeDuration(tv.tv_sec, ticks);
363    }
364    return Seconds(tv.tv_sec) + Microseconds(tv.tv_usec);
365  }
366  int64_t ToInt64Nanoseconds(Duration d) {
367    if (time_internal::GetRepHi(d) &gt;= 0 &amp;&amp;
368        time_internal::GetRepHi(d) &gt;&gt; 33 == 0) {
369      return (time_internal::GetRepHi(d) * 1000 * 1000 * 1000) +
370             (time_internal::GetRepLo(d) / kTicksPerNanosecond);
371    }
372    return d / Nanoseconds(1);
373  }
374  int64_t ToInt64Microseconds(Duration d) {
375    if (time_internal::GetRepHi(d) &gt;= 0 &amp;&amp;
376        time_internal::GetRepHi(d) &gt;&gt; 43 == 0) {
377      return (time_internal::GetRepHi(d) * 1000 * 1000) +
378             (time_internal::GetRepLo(d) / (kTicksPerNanosecond * 1000));
379    }
380    return d / Microseconds(1);
381  }
382  int64_t ToInt64Milliseconds(Duration d) {
383    if (time_internal::GetRepHi(d) &gt;= 0 &amp;&amp;
384        time_internal::GetRepHi(d) &gt;&gt; 53 == 0) {
385      return (time_internal::GetRepHi(d) * 1000) +
386             (time_internal::GetRepLo(d) / (kTicksPerNanosecond * 1000 * 1000));
387    }
388    return d / Milliseconds(1);
389  }
390  int64_t ToInt64Seconds(Duration d) {
391    int64_t hi = time_internal::GetRepHi(d);
392    if (time_internal::IsInfiniteDuration(d)) return hi;
393    if (hi &lt; 0 &amp;&amp; time_internal::GetRepLo(d) != 0) ++hi;
394    return hi;
395  }
396  int64_t ToInt64Minutes(Duration d) {
397    int64_t hi = time_internal::GetRepHi(d);
398    if (time_internal::IsInfiniteDuration(d)) return hi;
399    if (hi &lt; 0 &amp;&amp; time_internal::GetRepLo(d) != 0) ++hi;
400    return hi / 60;
401  }
402  int64_t ToInt64Hours(Duration d) {
403    int64_t hi = time_internal::GetRepHi(d);
404    if (time_internal::IsInfiniteDuration(d)) return hi;
405    if (hi &lt; 0 &amp;&amp; time_internal::GetRepLo(d) != 0) ++hi;
406    return hi / (60 * 60);
407  }
408  double ToDoubleNanoseconds(Duration d) {
409    return FDivDuration(d, Nanoseconds(1));
410  }
411  double ToDoubleMicroseconds(Duration d) {
412    return FDivDuration(d, Microseconds(1));
413  }
414  double ToDoubleMilliseconds(Duration d) {
415    return FDivDuration(d, Milliseconds(1));
416  }
417  double ToDoubleSeconds(Duration d) {
418    return FDivDuration(d, Seconds(1));
419  }
420  double ToDoubleMinutes(Duration d) {
421    return FDivDuration(d, Minutes(1));
422  }
423  double ToDoubleHours(Duration d) {
424    return FDivDuration(d, Hours(1));
425  }
426  timespec ToTimespec(Duration d) {
427    timespec ts;
428    if (!time_internal::IsInfiniteDuration(d)) {
429      int64_t rep_hi = time_internal::GetRepHi(d);
430      uint32_t rep_lo = time_internal::GetRepLo(d);
431      if (rep_hi &lt; 0) {
432        rep_lo += kTicksPerNanosecond - 1;
433        if (rep_lo &gt;= kTicksPerSecond) {
434          rep_hi += 1;
435          rep_lo -= kTicksPerSecond;
436        }
437      }
438      ts.tv_sec = static_cast&lt;decltype(ts.tv_sec)&gt;(rep_hi);
439      if (ts.tv_sec == rep_hi) {  
440        ts.tv_nsec = rep_lo / kTicksPerNanosecond;
441        return ts;
442      }
443    }
444    if (d &gt;= ZeroDuration()) {
445      ts.tv_sec = std::numeric_limits&lt;time_t&gt;::max();
446      ts.tv_nsec = 1000 * 1000 * 1000 - 1;
447    } else {
448      ts.tv_sec = std::numeric_limits&lt;time_t&gt;::min();
449      ts.tv_nsec = 0;
450    }
451    return ts;
452  }
453  timeval ToTimeval(Duration d) {
454    timeval tv;
455    timespec ts = ToTimespec(d);
456    if (ts.tv_sec &lt; 0) {
457      ts.tv_nsec += 1000 - 1;
458      if (ts.tv_nsec &gt;= 1000 * 1000 * 1000) {
459        ts.tv_sec += 1;
460        ts.tv_nsec -= 1000 * 1000 * 1000;
461      }
462    }
463    tv.tv_sec = static_cast&lt;decltype(tv.tv_sec)&gt;(ts.tv_sec);
464    if (tv.tv_sec != ts.tv_sec) {  
465      if (ts.tv_sec &lt; 0) {
466        tv.tv_sec = std::numeric_limits&lt;decltype(tv.tv_sec)&gt;::min();
467        tv.tv_usec = 0;
468      } else {
469        tv.tv_sec = std::numeric_limits&lt;decltype(tv.tv_sec)&gt;::max();
470        tv.tv_usec = 1000 * 1000 - 1;
471      }
472      return tv;
473    }
474    tv.tv_usec = static_cast&lt;int&gt;(ts.tv_nsec / 1000);  
475    return tv;
476  }
477  std::chrono::nanoseconds ToChronoNanoseconds(Duration d) {
478    return time_internal::ToChronoDuration&lt;std::chrono::nanoseconds&gt;(d);
479  }
480  std::chrono::microseconds ToChronoMicroseconds(Duration d) {
481    return time_internal::ToChronoDuration&lt;std::chrono::microseconds&gt;(d);
482  }
483  std::chrono::milliseconds ToChronoMilliseconds(Duration d) {
484    return time_internal::ToChronoDuration&lt;std::chrono::milliseconds&gt;(d);
485  }
486  std::chrono::seconds ToChronoSeconds(Duration d) {
487    return time_internal::ToChronoDuration&lt;std::chrono::seconds&gt;(d);
488  }
489  std::chrono::minutes ToChronoMinutes(Duration d) {
490    return time_internal::ToChronoDuration&lt;std::chrono::minutes&gt;(d);
491  }
492  std::chrono::hours ToChronoHours(Duration d) {
493    return time_internal::ToChronoDuration&lt;std::chrono::hours&gt;(d);
494  }
495  namespace {
496  char* Format64(char* ep, int width, int64_t v) {
497    do {
498      --width;
499      *--ep = static_cast&lt;char&gt;(&#x27;0&#x27; + (v % 10));  
500    } while (v /= 10);
501    while (--width &gt;= 0) *--ep = &#x27;0&#x27;;  
502    return ep;
503  }
504  struct DisplayUnit {
505    absl::string_view abbr;
506    int prec;
507    double pow10;
508  };
509  ABSL_CONST_INIT const DisplayUnit kDisplayNano = {&quot;ns&quot;, 2, 1e2};
510  ABSL_CONST_INIT const DisplayUnit kDisplayMicro = {&quot;us&quot;, 5, 1e5};
511  ABSL_CONST_INIT const DisplayUnit kDisplayMilli = {&quot;ms&quot;, 8, 1e8};
512  ABSL_CONST_INIT const DisplayUnit kDisplaySec = {&quot;s&quot;, 11, 1e11};
513  ABSL_CONST_INIT const DisplayUnit kDisplayMin = {&quot;m&quot;, -1, 0.0};  
514  ABSL_CONST_INIT const DisplayUnit kDisplayHour = {&quot;h&quot;, -1,
515                                                    0.0};  
516  void AppendNumberUnit(std::string* out, int64_t n, DisplayUnit unit) {
517    char buf[sizeof(&quot;2562047788015216&quot;)];  
518    char* const ep = buf + sizeof(buf);
519    char* bp = Format64(ep, 0, n);
520    if (*bp != &#x27;0&#x27; || bp + 1 != ep) {
521      out-&gt;append(bp, static_cast&lt;size_t&gt;(ep - bp));
522      out-&gt;append(unit.abbr.data(), unit.abbr.size());
523    }
524  }
525  void AppendNumberUnit(std::string* out, double n, DisplayUnit unit) {
526    constexpr int kBufferSize = std::numeric_limits&lt;double&gt;::digits10;
527    const int prec = std::min(kBufferSize, unit.prec);
528    char buf[kBufferSize];  
529    char* ep = buf + sizeof(buf);
530    double d = 0;
531    int64_t frac_part = std::round(std::modf(n, &amp;d) * unit.pow10);
532    int64_t int_part = d;
533    if (int_part != 0 || frac_part != 0) {
534      char* bp = Format64(ep, 0, int_part);  
535      out-&gt;append(bp, static_cast&lt;size_t&gt;(ep - bp));
536      if (frac_part != 0) {
537        out-&gt;push_back(&#x27;.&#x27;);
538        bp = Format64(ep, prec, frac_part);
539        while (ep[-1] == &#x27;0&#x27;) --ep;
540        out-&gt;append(bp, static_cast&lt;size_t&gt;(ep - bp));
541      }
542      out-&gt;append(unit.abbr.data(), unit.abbr.size());
543    }
544  }
545  }  
546  std::string FormatDuration(Duration d) {
547    constexpr Duration kMinDuration = Seconds(kint64min);
548    std::string s;
549    if (d == kMinDuration) {
550      s = &quot;-2562047788015215h30m8s&quot;;
551      return s;
552    }
553    if (d &lt; ZeroDuration()) {
554      s.append(&quot;-&quot;);
555      d = -d;
556    }
557    if (d == InfiniteDuration()) {
558      s.append(&quot;inf&quot;);
559    } else if (d &lt; Seconds(1)) {
560      if (d &lt; Microseconds(1)) {
561        AppendNumberUnit(&amp;s, FDivDuration(d, Nanoseconds(1)), kDisplayNano);
562      } else if (d &lt; Milliseconds(1)) {
563        AppendNumberUnit(&amp;s, FDivDuration(d, Microseconds(1)), kDisplayMicro);
564      } else {
565        AppendNumberUnit(&amp;s, FDivDuration(d, Milliseconds(1)), kDisplayMilli);
566      }
567    } else {
568      AppendNumberUnit(&amp;s, IDivDuration(d, Hours(1), &amp;d), kDisplayHour);
569      AppendNumberUnit(&amp;s, IDivDuration(d, Minutes(1), &amp;d), kDisplayMin);
570      AppendNumberUnit(&amp;s, FDivDuration(d, Seconds(1)), kDisplaySec);
571    }
572    if (s.empty() || s == &quot;-&quot;) {
573      s = &quot;0&quot;;
574    }
575    return s;
576  }
577  namespace {
578  bool ConsumeDurationNumber(const char** dpp, const char* ep, int64_t* int_part,
579                             int64_t* frac_part, int64_t* frac_scale) {
580    *int_part = 0;
581    *frac_part = 0;
582    *frac_scale = 1;  
583    const char* start = *dpp;
584    for (; *dpp != ep; *dpp += 1) {
585      const int d = **dpp - &#x27;0&#x27;;  
586      if (d &lt; 0 || 10 &lt;= d) break;
587      if (*int_part &gt; kint64max / 10) return false;
588      *int_part *= 10;
589      if (*int_part &gt; kint64max - d) return false;
590      *int_part += d;
591    }
592    const bool int_part_empty = (*dpp == start);
593    if (*dpp == ep || **dpp != &#x27;.&#x27;) return !int_part_empty;
594    for (*dpp += 1; *dpp != ep; *dpp += 1) {
595      const int d = **dpp - &#x27;0&#x27;;  
596      if (d &lt; 0 || 10 &lt;= d) break;
597      if (*frac_scale &lt;= kint64max / 10) {
598        *frac_part *= 10;
599        *frac_part += d;
600        *frac_scale *= 10;
601      }
602    }
603    return !int_part_empty || *frac_scale != 1;
604  }
605  bool ConsumeDurationUnit(const char** start, const char* end, Duration* unit) {
606    size_t size = static_cast&lt;size_t&gt;(end - *start);
607    switch (size) {
608      case 0:
609        return false;
610      default:
611        switch (**start) {
612          case &#x27;n&#x27;:
613            if (*(*start + 1) == &#x27;s&#x27;) {
614              *start += 2;
615              *unit = Nanoseconds(1);
616              return true;
617            }
618            break;
619          case &#x27;u&#x27;:
620            if (*(*start + 1) == &#x27;s&#x27;) {
621              *start += 2;
622              *unit = Microseconds(1);
623              return true;
624            }
625            break;
626          case &#x27;m&#x27;:
627            if (*(*start + 1) == &#x27;s&#x27;) {
628              *start += 2;
629              *unit = Milliseconds(1);
630              return true;
631            }
632            break;
633          default:
634            break;
635        }
636        ABSL_FALLTHROUGH_INTENDED;
637      case 1:
638        switch (**start) {
639          case &#x27;s&#x27;:
640            *unit = Seconds(1);
641            *start += 1;
<span onclick='openModal()' class='match'>642            return true;
643          case &#x27;m&#x27;:
644            *unit = Minutes(1);
645            *start += 1;
646            return true;
647          case &#x27;h&#x27;:
</span>648            *unit = Hours(1);
649            *start += 1;
650            return true;
651          default:
652            return false;
653        }
654    }
655  }
656  }  
657  bool ParseDuration(absl::string_view dur_sv, Duration* d) {
658    int sign = 1;
659    if (absl::ConsumePrefix(&amp;dur_sv, &quot;-&quot;)) {
660      sign = -1;
661    } else {
662      absl::ConsumePrefix(&amp;dur_sv, &quot;+&quot;);
663    }
664    if (dur_sv.empty()) return false;
665    if (dur_sv == &quot;0&quot;) {
666      *d = ZeroDuration();
667      return true;
668    }
669    if (dur_sv == &quot;inf&quot;) {
670      *d = sign * InfiniteDuration();
671      return true;
672    }
673    const char* start = dur_sv.data();
674    const char* end = start + dur_sv.size();
675    Duration dur;
676    while (start != end) {
677      int64_t int_part;
678      int64_t frac_part;
679      int64_t frac_scale;
680      Duration unit;
681      if (!ConsumeDurationNumber(&amp;start, end, &amp;int_part, &amp;frac_part,
682                                 &amp;frac_scale) ||
683          !ConsumeDurationUnit(&amp;start, end, &amp;unit)) {
684        return false;
685      }
686      if (int_part != 0) dur += sign * int_part * unit;
687      if (frac_part != 0) dur += sign * frac_part * unit / frac_scale;
688    }
689    *d = dur;
690    return true;
691  }
692  bool AbslParseFlag(absl::string_view text, Duration* dst, std::string*) {
693    return ParseDuration(text, dst);
694  }
695  std::string AbslUnparseFlag(Duration d) { return FormatDuration(d); }
696  bool ParseFlag(const std::string&amp; text, Duration* dst, std::string* ) {
697    return ParseDuration(text, dst);
698  }
699  std::string UnparseFlag(Duration d) { return FormatDuration(d); }
700  ABSL_NAMESPACE_END
701  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-duration.cc</h3>
            <pre><code>1  #if defined(_MSC_VER)
2  #include &lt;winsock2.h&gt;  
3  #endif
4  #include &lt;algorithm&gt;
5  #include &lt;cassert&gt;
6  #include &lt;cctype&gt;
7  #include &lt;cerrno&gt;
8  #include &lt;cmath&gt;
9  #include &lt;cstdint&gt;
10  #include &lt;cstdlib&gt;
11  #include &lt;cstring&gt;
12  #include &lt;ctime&gt;
13  #include &lt;functional&gt;
14  #include &lt;limits&gt;
15  #include &lt;string&gt;
16  #include &quot;absl/base/casts.h&quot;
17  #include &quot;absl/base/macros.h&quot;
18  #include &quot;absl/numeric/int128.h&quot;
19  #include &quot;absl/strings/string_view.h&quot;
20  #include &quot;absl/strings/strip.h&quot;
21  #include &quot;absl/time/time.h&quot;
22  namespace absl {
23  ABSL_NAMESPACE_BEGIN
24  namespace {
25  using time_internal::kTicksPerNanosecond;
26  using time_internal::kTicksPerSecond;
27  constexpr int64_t kint64max = std::numeric_limits&lt;int64_t&gt;::max();
28  constexpr int64_t kint64min = std::numeric_limits&lt;int64_t&gt;::min();
29  inline bool IsFinite(double d) {
30    if (std::isnan(d)) return false;
31    return d != std::numeric_limits&lt;double&gt;::infinity() &amp;&amp;
32           d != -std::numeric_limits&lt;double&gt;::infinity();
33  }
34  inline bool IsValidDivisor(double d) {
35    if (std::isnan(d)) return false;
36    return d != 0.0;
37  }
38  inline void NormalizeTicks(int64_t* sec, int64_t* ticks) {
39    if (*ticks &lt; 0) {
40      --*sec;
41      *ticks += kTicksPerSecond;
42    }
43  }
44  inline uint128 MakeU128(int64_t a) {
45    uint128 u128 = 0;
46    if (a &lt; 0) {
47      ++u128;
48      ++a;  
49      a = -a;
50    }
51    u128 += static_cast&lt;uint64_t&gt;(a);
52    return u128;
53  }
54  inline uint128 MakeU128Ticks(Duration d) {
55    int64_t rep_hi = time_internal::GetRepHi(d);
56    uint32_t rep_lo = time_internal::GetRepLo(d);
57    if (rep_hi &lt; 0) {
58      ++rep_hi;
59      rep_hi = -rep_hi;
60      rep_lo = kTicksPerSecond - rep_lo;
61    }
62    uint128 u128 = static_cast&lt;uint64_t&gt;(rep_hi);
63    u128 *= static_cast&lt;uint64_t&gt;(kTicksPerSecond);
64    u128 += rep_lo;
65    return u128;
66  }
67  inline Duration MakeDurationFromU128(uint128 u128, bool is_neg) {
68    int64_t rep_hi;
69    uint32_t rep_lo;
70    const uint64_t h64 = Uint128High64(u128);
71    const uint64_t l64 = Uint128Low64(u128);
72    if (h64 == 0) {  
73      const uint64_t hi = l64 / kTicksPerSecond;
74      rep_hi = static_cast&lt;int64_t&gt;(hi);
75      rep_lo = static_cast&lt;uint32_t&gt;(l64 - hi * kTicksPerSecond);
76    } else {
77      const uint64_t kMaxRepHi64 = 0x77359400UL;
78      if (h64 &gt;= kMaxRepHi64) {
79        if (is_neg &amp;&amp; h64 == kMaxRepHi64 &amp;&amp; l64 == 0) {
80          return time_internal::MakeDuration(kint64min);
81        }
82        return is_neg ? -InfiniteDuration() : InfiniteDuration();
83      }
84      const uint128 kTicksPerSecond128 = static_cast&lt;uint64_t&gt;(kTicksPerSecond);
85      const uint128 hi = u128 / kTicksPerSecond128;
86      rep_hi = static_cast&lt;int64_t&gt;(Uint128Low64(hi));
87      rep_lo =
88          static_cast&lt;uint32_t&gt;(Uint128Low64(u128 - hi * kTicksPerSecond128));
89    }
90    if (is_neg) {
91      rep_hi = -rep_hi;
92      if (rep_lo != 0) {
93        --rep_hi;
94        rep_lo = kTicksPerSecond - rep_lo;
95      }
96    }
97    return time_internal::MakeDuration(rep_hi, rep_lo);
98  }
99  inline uint64_t EncodeTwosComp(int64_t v) {
100    return absl::bit_cast&lt;uint64_t&gt;(v);
101  }
102  inline int64_t DecodeTwosComp(uint64_t v) { return absl::bit_cast&lt;int64_t&gt;(v); }
103  inline bool SafeAddRepHi(double a_hi, double b_hi, Duration* d) {
104    double c = a_hi + b_hi;
105    if (c &gt;= static_cast&lt;double&gt;(kint64max)) {
106      *d = InfiniteDuration();
107      return false;
108    }
109    if (c &lt;= static_cast&lt;double&gt;(kint64min)) {
110      *d = -InfiniteDuration();
111      return false;
112    }
113    *d = time_internal::MakeDuration(c, time_internal::GetRepLo(*d));
114    return true;
115  }
116  template &lt;typename Ignored&gt;
117  struct SafeMultiply {
118    uint128 operator()(uint128 a, uint128 b) const {
119      assert(Uint128High64(b) == 0);
120      if (Uint128High64(a) == 0) {
121        return (((Uint128Low64(a) | Uint128Low64(b)) &gt;&gt; 32) == 0)
122                   ? static_cast&lt;uint128&gt;(Uint128Low64(a) * Uint128Low64(b))
123                   : a * b;
124      }
125      return b == 0 ? b : (a &gt; kuint128max / b) ? kuint128max : a * b;
126    }
127  };
128  template &lt;template &lt;typename&gt; class Operation&gt;
129  inline Duration ScaleFixed(Duration d, int64_t r) {
130    const uint128 a = MakeU128Ticks(d);
131    const uint128 b = MakeU128(r);
132    const uint128 q = Operation&lt;uint128&gt;()(a, b);
133    const bool is_neg = (time_internal::GetRepHi(d) &lt; 0) != (r &lt; 0);
134    return MakeDurationFromU128(q, is_neg);
135  }
136  template &lt;template &lt;typename&gt; class Operation&gt;
137  inline Duration ScaleDouble(Duration d, double r) {
138    Operation&lt;double&gt; op;
139    double hi_doub = op(time_internal::GetRepHi(d), r);
140    double lo_doub = op(time_internal::GetRepLo(d), r);
141    double hi_int = 0;
142    double hi_frac = std::modf(hi_doub, &amp;hi_int);
143    lo_doub /= kTicksPerSecond;
144    lo_doub += hi_frac;
145    double lo_int = 0;
146    double lo_frac = std::modf(lo_doub, &amp;lo_int);
147    int64_t lo64 = std::round(lo_frac * kTicksPerSecond);
148    Duration ans;
149    if (!SafeAddRepHi(hi_int, lo_int, &amp;ans)) return ans;
150    int64_t hi64 = time_internal::GetRepHi(ans);
151    if (!SafeAddRepHi(hi64, lo64 / kTicksPerSecond, &amp;ans)) return ans;
152    hi64 = time_internal::GetRepHi(ans);
153    lo64 %= kTicksPerSecond;
154    NormalizeTicks(&amp;hi64, &amp;lo64);
155    return time_internal::MakeDuration(hi64, lo64);
156  }
157  inline bool IDivFastPath(const Duration num, const Duration den, int64_t* q,
158                           Duration* rem) {
159    if (time_internal::IsInfiniteDuration(num) ||
160        time_internal::IsInfiniteDuration(den))
161      return false;
162    int64_t num_hi = time_internal::GetRepHi(num);
163    uint32_t num_lo = time_internal::GetRepLo(num);
164    int64_t den_hi = time_internal::GetRepHi(den);
165    uint32_t den_lo = time_internal::GetRepLo(den);
166    if (den_hi == 0 &amp;&amp; den_lo == kTicksPerNanosecond) {
167      if (num_hi &gt;= 0 &amp;&amp; num_hi &lt; (kint64max - kTicksPerSecond) / 1000000000) {
168        *q = num_hi * 1000000000 + num_lo / kTicksPerNanosecond;
169        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
170        return true;
171      }
172    } else if (den_hi == 0 &amp;&amp; den_lo == 100 * kTicksPerNanosecond) {
173      if (num_hi &gt;= 0 &amp;&amp; num_hi &lt; (kint64max - kTicksPerSecond) / 10000000) {
174        *q = num_hi * 10000000 + num_lo / (100 * kTicksPerNanosecond);
175        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
176        return true;
177      }
178    } else if (den_hi == 0 &amp;&amp; den_lo == 1000 * kTicksPerNanosecond) {
179      if (num_hi &gt;= 0 &amp;&amp; num_hi &lt; (kint64max - kTicksPerSecond) / 1000000) {
180        *q = num_hi * 1000000 + num_lo / (1000 * kTicksPerNanosecond);
181        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
182        return true;
183      }
184    } else if (den_hi == 0 &amp;&amp; den_lo == 1000000 * kTicksPerNanosecond) {
185      if (num_hi &gt;= 0 &amp;&amp; num_hi &lt; (kint64max - kTicksPerSecond) / 1000) {
186        *q = num_hi * 1000 + num_lo / (1000000 * kTicksPerNanosecond);
187        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
188        return true;
189      }
190    } else if (den_hi &gt; 0 &amp;&amp; den_lo == 0) {
191      if (num_hi &gt;= 0) {
192        if (den_hi == 1) {
193          *q = num_hi;
194          *rem = time_internal::MakeDuration(0, num_lo);
195          return true;
196        }
197        *q = num_hi / den_hi;
198        *rem = time_internal::MakeDuration(num_hi % den_hi, num_lo);
199        return true;
200      }
201      if (num_lo != 0) {
202        num_hi += 1;
203      }
204      int64_t quotient = num_hi / den_hi;
205      int64_t rem_sec = num_hi % den_hi;
206      if (rem_sec &gt; 0) {
207        rem_sec -= den_hi;
208        quotient += 1;
209      }
210      if (num_lo != 0) {
211        rem_sec -= 1;
212      }
213      *q = quotient;
214      *rem = time_internal::MakeDuration(rem_sec, num_lo);
215      return true;
216    }
217    return false;
218  }
219  }  
220  namespace time_internal {
221  int64_t IDivDuration(bool satq, const Duration num, const Duration den,
222                       Duration* rem) {
223    int64_t q = 0;
224    if (IDivFastPath(num, den, &amp;q, rem)) {
225      return q;
226    }
227    const bool num_neg = num &lt; ZeroDuration();
228    const bool den_neg = den &lt; ZeroDuration();
229    const bool quotient_neg = num_neg != den_neg;
230    if (time_internal::IsInfiniteDuration(num) || den == ZeroDuration()) {
231      *rem = num_neg ? -InfiniteDuration() : InfiniteDuration();
232      return quotient_neg ? kint64min : kint64max;
233    }
234    if (time_internal::IsInfiniteDuration(den)) {
235      *rem = num;
236      return 0;
237    }
238    const uint128 a = MakeU128Ticks(num);
239    const uint128 b = MakeU128Ticks(den);
240    uint128 quotient128 = a / b;
241    if (satq) {
242      if (quotient128 &gt; uint128(static_cast&lt;uint64_t&gt;(kint64max))) {
243        quotient128 = quotient_neg ? uint128(static_cast&lt;uint64_t&gt;(kint64min))
244                                   : uint128(static_cast&lt;uint64_t&gt;(kint64max));
245      }
246    }
247    const uint128 remainder128 = a - quotient128 * b;
248    *rem = MakeDurationFromU128(remainder128, num_neg);
249    if (!quotient_neg || quotient128 == 0) {
250      return Uint128Low64(quotient128) &amp; kint64max;
251    }
252    return -static_cast&lt;int64_t&gt;(Uint128Low64(quotient128 - 1) &amp; kint64max) - 1;
253  }
254  }  
255  Duration&amp; Duration::operator+=(Duration rhs) {
256    if (time_internal::IsInfiniteDuration(*this)) return *this;
257    if (time_internal::IsInfiniteDuration(rhs)) return *this = rhs;
258    const int64_t orig_rep_hi = rep_hi_.Get();
259    rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) +
260                             EncodeTwosComp(rhs.rep_hi_.Get()));
261    if (rep_lo_ &gt;= kTicksPerSecond - rhs.rep_lo_) {
262      rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) + 1);
263      rep_lo_ -= kTicksPerSecond;
264    }
265    rep_lo_ += rhs.rep_lo_;
266    if (rhs.rep_hi_.Get() &lt; 0 ? rep_hi_.Get() &gt; orig_rep_hi
267                              : rep_hi_.Get() &lt; orig_rep_hi) {
268      return *this =
269                 rhs.rep_hi_.Get() &lt; 0 ? -InfiniteDuration() : InfiniteDuration();
270    }
271    return *this;
272  }
273  Duration&amp; Duration::operator-=(Duration rhs) {
274    if (time_internal::IsInfiniteDuration(*this)) return *this;
275    if (time_internal::IsInfiniteDuration(rhs)) {
276      return *this = rhs.rep_hi_.Get() &gt;= 0 ? -InfiniteDuration()
277                                            : InfiniteDuration();
278    }
279    const int64_t orig_rep_hi = rep_hi_.Get();
280    rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) -
281                             EncodeTwosComp(rhs.rep_hi_.Get()));
282    if (rep_lo_ &lt; rhs.rep_lo_) {
283      rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) - 1);
284      rep_lo_ += kTicksPerSecond;
285    }
286    rep_lo_ -= rhs.rep_lo_;
287    if (rhs.rep_hi_.Get() &lt; 0 ? rep_hi_.Get() &lt; orig_rep_hi
288                              : rep_hi_.Get() &gt; orig_rep_hi) {
289      return *this = rhs.rep_hi_.Get() &gt;= 0 ? -InfiniteDuration()
290                                            : InfiniteDuration();
291    }
292    return *this;
293  }
294  Duration&amp; Duration::operator*=(int64_t r) {
295    if (time_internal::IsInfiniteDuration(*this)) {
296      const bool is_neg = (r &lt; 0) != (rep_hi_.Get() &lt; 0);
297      return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
298    }
299    return *this = ScaleFixed&lt;SafeMultiply&gt;(*this, r);
300  }
301  Duration&amp; Duration::operator*=(double r) {
302    if (time_internal::IsInfiniteDuration(*this) || !IsFinite(r)) {
303      const bool is_neg = std::signbit(r) != (rep_hi_.Get() &lt; 0);
304      return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
305    }
306    return *this = ScaleDouble&lt;std::multiplies&gt;(*this, r);
307  }
308  Duration&amp; Duration::operator/=(int64_t r) {
309    if (time_internal::IsInfiniteDuration(*this) || r == 0) {
310      const bool is_neg = (r &lt; 0) != (rep_hi_.Get() &lt; 0);
311      return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
312    }
313    return *this = ScaleFixed&lt;std::divides&gt;(*this, r);
314  }
315  Duration&amp; Duration::operator/=(double r) {
316    if (time_internal::IsInfiniteDuration(*this) || !IsValidDivisor(r)) {
317      const bool is_neg = std::signbit(r) != (rep_hi_.Get() &lt; 0);
318      return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
319    }
320    return *this = ScaleDouble&lt;std::divides&gt;(*this, r);
321  }
322  Duration&amp; Duration::operator%=(Duration rhs) {
323    time_internal::IDivDuration(false, *this, rhs, this);
324    return *this;
325  }
326  double FDivDuration(Duration num, Duration den) {
327    if (time_internal::IsInfiniteDuration(num) || den == ZeroDuration()) {
328      return (num &lt; ZeroDuration()) == (den &lt; ZeroDuration())
329                 ? std::numeric_limits&lt;double&gt;::infinity()
330                 : -std::numeric_limits&lt;double&gt;::infinity();
331    }
332    if (time_internal::IsInfiniteDuration(den)) return 0.0;
333    double a =
334        static_cast&lt;double&gt;(time_internal::GetRepHi(num)) * kTicksPerSecond +
335        time_internal::GetRepLo(num);
336    double b =
337        static_cast&lt;double&gt;(time_internal::GetRepHi(den)) * kTicksPerSecond +
338        time_internal::GetRepLo(den);
339    return a / b;
340  }
341  Duration Trunc(Duration d, Duration unit) {
342    return d - (d % unit);
343  }
344  Duration Floor(const Duration d, const Duration unit) {
345    const absl::Duration td = Trunc(d, unit);
346    return td &lt;= d ? td : td - AbsDuration(unit);
347  }
348  Duration Ceil(const Duration d, const Duration unit) {
349    const absl::Duration td = Trunc(d, unit);
350    return td &gt;= d ? td : td + AbsDuration(unit);
351  }
352  Duration DurationFromTimespec(timespec ts) {
353    if (static_cast&lt;uint64_t&gt;(ts.tv_nsec) &lt; 1000 * 1000 * 1000) {
354      int64_t ticks = ts.tv_nsec * kTicksPerNanosecond;
355      return time_internal::MakeDuration(ts.tv_sec, ticks);
356    }
357    return Seconds(ts.tv_sec) + Nanoseconds(ts.tv_nsec);
358  }
359  Duration DurationFromTimeval(timeval tv) {
360    if (static_cast&lt;uint64_t&gt;(tv.tv_usec) &lt; 1000 * 1000) {
361      int64_t ticks = tv.tv_usec * 1000 * kTicksPerNanosecond;
362      return time_internal::MakeDuration(tv.tv_sec, ticks);
363    }
364    return Seconds(tv.tv_sec) + Microseconds(tv.tv_usec);
365  }
366  int64_t ToInt64Nanoseconds(Duration d) {
367    if (time_internal::GetRepHi(d) &gt;= 0 &amp;&amp;
368        time_internal::GetRepHi(d) &gt;&gt; 33 == 0) {
369      return (time_internal::GetRepHi(d) * 1000 * 1000 * 1000) +
370             (time_internal::GetRepLo(d) / kTicksPerNanosecond);
371    }
372    return d / Nanoseconds(1);
373  }
374  int64_t ToInt64Microseconds(Duration d) {
375    if (time_internal::GetRepHi(d) &gt;= 0 &amp;&amp;
376        time_internal::GetRepHi(d) &gt;&gt; 43 == 0) {
377      return (time_internal::GetRepHi(d) * 1000 * 1000) +
378             (time_internal::GetRepLo(d) / (kTicksPerNanosecond * 1000));
379    }
380    return d / Microseconds(1);
381  }
382  int64_t ToInt64Milliseconds(Duration d) {
383    if (time_internal::GetRepHi(d) &gt;= 0 &amp;&amp;
384        time_internal::GetRepHi(d) &gt;&gt; 53 == 0) {
385      return (time_internal::GetRepHi(d) * 1000) +
386             (time_internal::GetRepLo(d) / (kTicksPerNanosecond * 1000 * 1000));
387    }
388    return d / Milliseconds(1);
389  }
390  int64_t ToInt64Seconds(Duration d) {
391    int64_t hi = time_internal::GetRepHi(d);
392    if (time_internal::IsInfiniteDuration(d)) return hi;
393    if (hi &lt; 0 &amp;&amp; time_internal::GetRepLo(d) != 0) ++hi;
394    return hi;
395  }
396  int64_t ToInt64Minutes(Duration d) {
397    int64_t hi = time_internal::GetRepHi(d);
398    if (time_internal::IsInfiniteDuration(d)) return hi;
399    if (hi &lt; 0 &amp;&amp; time_internal::GetRepLo(d) != 0) ++hi;
400    return hi / 60;
401  }
402  int64_t ToInt64Hours(Duration d) {
403    int64_t hi = time_internal::GetRepHi(d);
404    if (time_internal::IsInfiniteDuration(d)) return hi;
405    if (hi &lt; 0 &amp;&amp; time_internal::GetRepLo(d) != 0) ++hi;
406    return hi / (60 * 60);
407  }
408  double ToDoubleNanoseconds(Duration d) {
409    return FDivDuration(d, Nanoseconds(1));
410  }
411  double ToDoubleMicroseconds(Duration d) {
412    return FDivDuration(d, Microseconds(1));
413  }
414  double ToDoubleMilliseconds(Duration d) {
415    return FDivDuration(d, Milliseconds(1));
416  }
417  double ToDoubleSeconds(Duration d) {
418    return FDivDuration(d, Seconds(1));
419  }
420  double ToDoubleMinutes(Duration d) {
421    return FDivDuration(d, Minutes(1));
422  }
423  double ToDoubleHours(Duration d) {
424    return FDivDuration(d, Hours(1));
425  }
426  timespec ToTimespec(Duration d) {
427    timespec ts;
428    if (!time_internal::IsInfiniteDuration(d)) {
429      int64_t rep_hi = time_internal::GetRepHi(d);
430      uint32_t rep_lo = time_internal::GetRepLo(d);
431      if (rep_hi &lt; 0) {
432        rep_lo += kTicksPerNanosecond - 1;
433        if (rep_lo &gt;= kTicksPerSecond) {
434          rep_hi += 1;
435          rep_lo -= kTicksPerSecond;
436        }
437      }
438      ts.tv_sec = static_cast&lt;decltype(ts.tv_sec)&gt;(rep_hi);
439      if (ts.tv_sec == rep_hi) {  
440        ts.tv_nsec = rep_lo / kTicksPerNanosecond;
441        return ts;
442      }
443    }
444    if (d &gt;= ZeroDuration()) {
445      ts.tv_sec = std::numeric_limits&lt;time_t&gt;::max();
446      ts.tv_nsec = 1000 * 1000 * 1000 - 1;
447    } else {
448      ts.tv_sec = std::numeric_limits&lt;time_t&gt;::min();
449      ts.tv_nsec = 0;
450    }
451    return ts;
452  }
453  timeval ToTimeval(Duration d) {
454    timeval tv;
455    timespec ts = ToTimespec(d);
456    if (ts.tv_sec &lt; 0) {
457      ts.tv_nsec += 1000 - 1;
458      if (ts.tv_nsec &gt;= 1000 * 1000 * 1000) {
459        ts.tv_sec += 1;
460        ts.tv_nsec -= 1000 * 1000 * 1000;
461      }
462    }
463    tv.tv_sec = static_cast&lt;decltype(tv.tv_sec)&gt;(ts.tv_sec);
464    if (tv.tv_sec != ts.tv_sec) {  
465      if (ts.tv_sec &lt; 0) {
466        tv.tv_sec = std::numeric_limits&lt;decltype(tv.tv_sec)&gt;::min();
467        tv.tv_usec = 0;
468      } else {
469        tv.tv_sec = std::numeric_limits&lt;decltype(tv.tv_sec)&gt;::max();
470        tv.tv_usec = 1000 * 1000 - 1;
471      }
472      return tv;
473    }
474    tv.tv_usec = static_cast&lt;int&gt;(ts.tv_nsec / 1000);  
475    return tv;
476  }
477  std::chrono::nanoseconds ToChronoNanoseconds(Duration d) {
478    return time_internal::ToChronoDuration&lt;std::chrono::nanoseconds&gt;(d);
479  }
480  std::chrono::microseconds ToChronoMicroseconds(Duration d) {
481    return time_internal::ToChronoDuration&lt;std::chrono::microseconds&gt;(d);
482  }
483  std::chrono::milliseconds ToChronoMilliseconds(Duration d) {
484    return time_internal::ToChronoDuration&lt;std::chrono::milliseconds&gt;(d);
485  }
486  std::chrono::seconds ToChronoSeconds(Duration d) {
487    return time_internal::ToChronoDuration&lt;std::chrono::seconds&gt;(d);
488  }
489  std::chrono::minutes ToChronoMinutes(Duration d) {
490    return time_internal::ToChronoDuration&lt;std::chrono::minutes&gt;(d);
491  }
492  std::chrono::hours ToChronoHours(Duration d) {
493    return time_internal::ToChronoDuration&lt;std::chrono::hours&gt;(d);
494  }
495  namespace {
496  char* Format64(char* ep, int width, int64_t v) {
497    do {
498      --width;
499      *--ep = static_cast&lt;char&gt;(&#x27;0&#x27; + (v % 10));  
500    } while (v /= 10);
501    while (--width &gt;= 0) *--ep = &#x27;0&#x27;;  
502    return ep;
503  }
504  struct DisplayUnit {
505    absl::string_view abbr;
506    int prec;
507    double pow10;
508  };
509  ABSL_CONST_INIT const DisplayUnit kDisplayNano = {&quot;ns&quot;, 2, 1e2};
510  ABSL_CONST_INIT const DisplayUnit kDisplayMicro = {&quot;us&quot;, 5, 1e5};
511  ABSL_CONST_INIT const DisplayUnit kDisplayMilli = {&quot;ms&quot;, 8, 1e8};
512  ABSL_CONST_INIT const DisplayUnit kDisplaySec = {&quot;s&quot;, 11, 1e11};
513  ABSL_CONST_INIT const DisplayUnit kDisplayMin = {&quot;m&quot;, -1, 0.0};  
514  ABSL_CONST_INIT const DisplayUnit kDisplayHour = {&quot;h&quot;, -1,
515                                                    0.0};  
516  void AppendNumberUnit(std::string* out, int64_t n, DisplayUnit unit) {
517    char buf[sizeof(&quot;2562047788015216&quot;)];  
518    char* const ep = buf + sizeof(buf);
519    char* bp = Format64(ep, 0, n);
520    if (*bp != &#x27;0&#x27; || bp + 1 != ep) {
521      out-&gt;append(bp, static_cast&lt;size_t&gt;(ep - bp));
522      out-&gt;append(unit.abbr.data(), unit.abbr.size());
523    }
524  }
525  void AppendNumberUnit(std::string* out, double n, DisplayUnit unit) {
526    constexpr int kBufferSize = std::numeric_limits&lt;double&gt;::digits10;
527    const int prec = std::min(kBufferSize, unit.prec);
528    char buf[kBufferSize];  
529    char* ep = buf + sizeof(buf);
530    double d = 0;
531    int64_t frac_part = std::round(std::modf(n, &amp;d) * unit.pow10);
532    int64_t int_part = d;
533    if (int_part != 0 || frac_part != 0) {
534      char* bp = Format64(ep, 0, int_part);  
535      out-&gt;append(bp, static_cast&lt;size_t&gt;(ep - bp));
536      if (frac_part != 0) {
537        out-&gt;push_back(&#x27;.&#x27;);
538        bp = Format64(ep, prec, frac_part);
539        while (ep[-1] == &#x27;0&#x27;) --ep;
540        out-&gt;append(bp, static_cast&lt;size_t&gt;(ep - bp));
541      }
542      out-&gt;append(unit.abbr.data(), unit.abbr.size());
543    }
544  }
545  }  
546  std::string FormatDuration(Duration d) {
547    constexpr Duration kMinDuration = Seconds(kint64min);
548    std::string s;
549    if (d == kMinDuration) {
550      s = &quot;-2562047788015215h30m8s&quot;;
551      return s;
552    }
553    if (d &lt; ZeroDuration()) {
554      s.append(&quot;-&quot;);
555      d = -d;
556    }
557    if (d == InfiniteDuration()) {
558      s.append(&quot;inf&quot;);
559    } else if (d &lt; Seconds(1)) {
560      if (d &lt; Microseconds(1)) {
561        AppendNumberUnit(&amp;s, FDivDuration(d, Nanoseconds(1)), kDisplayNano);
562      } else if (d &lt; Milliseconds(1)) {
563        AppendNumberUnit(&amp;s, FDivDuration(d, Microseconds(1)), kDisplayMicro);
564      } else {
565        AppendNumberUnit(&amp;s, FDivDuration(d, Milliseconds(1)), kDisplayMilli);
566      }
567    } else {
568      AppendNumberUnit(&amp;s, IDivDuration(d, Hours(1), &amp;d), kDisplayHour);
569      AppendNumberUnit(&amp;s, IDivDuration(d, Minutes(1), &amp;d), kDisplayMin);
570      AppendNumberUnit(&amp;s, FDivDuration(d, Seconds(1)), kDisplaySec);
571    }
572    if (s.empty() || s == &quot;-&quot;) {
573      s = &quot;0&quot;;
574    }
575    return s;
576  }
577  namespace {
578  bool ConsumeDurationNumber(const char** dpp, const char* ep, int64_t* int_part,
579                             int64_t* frac_part, int64_t* frac_scale) {
580    *int_part = 0;
581    *frac_part = 0;
582    *frac_scale = 1;  
583    const char* start = *dpp;
584    for (; *dpp != ep; *dpp += 1) {
585      const int d = **dpp - &#x27;0&#x27;;  
586      if (d &lt; 0 || 10 &lt;= d) break;
587      if (*int_part &gt; kint64max / 10) return false;
588      *int_part *= 10;
589      if (*int_part &gt; kint64max - d) return false;
590      *int_part += d;
591    }
592    const bool int_part_empty = (*dpp == start);
593    if (*dpp == ep || **dpp != &#x27;.&#x27;) return !int_part_empty;
594    for (*dpp += 1; *dpp != ep; *dpp += 1) {
595      const int d = **dpp - &#x27;0&#x27;;  
596      if (d &lt; 0 || 10 &lt;= d) break;
597      if (*frac_scale &lt;= kint64max / 10) {
598        *frac_part *= 10;
599        *frac_part += d;
600        *frac_scale *= 10;
601      }
602    }
603    return !int_part_empty || *frac_scale != 1;
604  }
605  bool ConsumeDurationUnit(const char** start, const char* end, Duration* unit) {
606    size_t size = static_cast&lt;size_t&gt;(end - *start);
607    switch (size) {
608      case 0:
609        return false;
610      default:
611        switch (**start) {
612          case &#x27;n&#x27;:
613            if (*(*start + 1) == &#x27;s&#x27;) {
614              *start += 2;
615              *unit = Nanoseconds(1);
616              return true;
617            }
618            break;
619          case &#x27;u&#x27;:
620            if (*(*start + 1) == &#x27;s&#x27;) {
621              *start += 2;
622              *unit = Microseconds(1);
623              return true;
624            }
625            break;
626          case &#x27;m&#x27;:
627            if (*(*start + 1) == &#x27;s&#x27;) {
628              *start += 2;
629              *unit = Milliseconds(1);
630              return true;
631            }
632            break;
633          default:
634            break;
635        }
636        ABSL_FALLTHROUGH_INTENDED;
637      case 1:
638        switch (**start) {
639          case &#x27;s&#x27;:
640            *unit = Seconds(1);
641            *start += 1;
642            return true;
643          case &#x27;m&#x27;:
644            *unit = Minutes(1);
645            *start += 1;
<span onclick='openModal()' class='match'>646            return true;
647          case &#x27;h&#x27;:
648            *unit = Hours(1);
649            *start += 1;
650            return true;
651          default:
</span>652            return false;
653        }
654    }
655  }
656  }  
657  bool ParseDuration(absl::string_view dur_sv, Duration* d) {
658    int sign = 1;
659    if (absl::ConsumePrefix(&amp;dur_sv, &quot;-&quot;)) {
660      sign = -1;
661    } else {
662      absl::ConsumePrefix(&amp;dur_sv, &quot;+&quot;);
663    }
664    if (dur_sv.empty()) return false;
665    if (dur_sv == &quot;0&quot;) {
666      *d = ZeroDuration();
667      return true;
668    }
669    if (dur_sv == &quot;inf&quot;) {
670      *d = sign * InfiniteDuration();
671      return true;
672    }
673    const char* start = dur_sv.data();
674    const char* end = start + dur_sv.size();
675    Duration dur;
676    while (start != end) {
677      int64_t int_part;
678      int64_t frac_part;
679      int64_t frac_scale;
680      Duration unit;
681      if (!ConsumeDurationNumber(&amp;start, end, &amp;int_part, &amp;frac_part,
682                                 &amp;frac_scale) ||
683          !ConsumeDurationUnit(&amp;start, end, &amp;unit)) {
684        return false;
685      }
686      if (int_part != 0) dur += sign * int_part * unit;
687      if (frac_part != 0) dur += sign * frac_part * unit / frac_scale;
688    }
689    *d = dur;
690    return true;
691  }
692  bool AbslParseFlag(absl::string_view text, Duration* dst, std::string*) {
693    return ParseDuration(text, dst);
694  }
695  std::string AbslUnparseFlag(Duration d) { return FormatDuration(d); }
696  bool ParseFlag(const std::string&amp; text, Duration* dst, std::string* ) {
697    return ParseDuration(text, dst);
698  }
699  std::string UnparseFlag(Duration d) { return FormatDuration(d); }
700  ABSL_NAMESPACE_END
701  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-duration.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-duration.cc</div>
                </div>
                <div class="column column_space"><pre><code>642            return true;
643          case &#x27;m&#x27;:
644            *unit = Minutes(1);
645            *start += 1;
646            return true;
647          case &#x27;h&#x27;:
</pre></code></div>
                <div class="column column_space"><pre><code>646            return true;
647          case &#x27;h&#x27;:
648            *unit = Hours(1);
649            *start += 1;
650            return true;
651          default:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    