
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TabBar.cpp</h3>
            <pre><code>1  #include <stdexcept>
2  #include "TabBar.h"
3  #include "Parameters.h"
4  #define	IDC_DRAG_TAB     1404
5  #define	IDC_DRAG_INTERDIT_TAB 1405
6  #define	IDC_DRAG_PLUS_TAB 1406
7  #define	IDC_DRAG_OUT_TAB 1407
8  bool TabBarPlus::_doDragNDrop = false;
9  bool TabBarPlus::_drawTopBar = true;
10  bool TabBarPlus::_drawInactiveTab = true;
11  bool TabBarPlus::_drawTabCloseButton = false;
12  bool TabBarPlus::_isDbClk2Close = false;
13  bool TabBarPlus::_isCtrlVertical = false;
14  bool TabBarPlus::_isCtrlMultiLine = false;
15  COLORREF TabBarPlus::_activeTextColour = ::GetSysColor(COLOR_BTNTEXT);
16  COLORREF TabBarPlus::_activeTopBarFocusedColour = RGB(250, 170, 60);
17  COLORREF TabBarPlus::_activeTopBarUnfocusedColour = RGB(250, 210, 150);
18  COLORREF TabBarPlus::_inactiveTextColour = grey;
19  COLORREF TabBarPlus::_inactiveBgColour = RGB(192, 192, 192);
20  HWND TabBarPlus::_hwndArray[nbCtrlMax] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
21  int TabBarPlus::_nbCtrl = 0;
22  void TabBar::init(HINSTANCE hInst, HWND parent, bool isVertical, bool isMultiLine)
23  {
24  	Window::init(hInst, parent);
25  	int vertical = isVertical?(TCS_VERTICAL | TCS_MULTILINE | TCS_RIGHTJUSTIFY):0;
26  	_isVertical = isVertical;
27  	_isMultiLine = isMultiLine;
28  	INITCOMMONCONTROLSEX icce{};
29  	icce.dwSize = sizeof(icce);
30  	icce.dwICC = ICC_TAB_CLASSES;
31  	InitCommonControlsEx(&icce);
32  	int multiLine = isMultiLine ? TCS_MULTILINE : 0;
33  	int style = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE |\
34  		TCS_FOCUSNEVER | TCS_TABS | WS_TABSTOP | vertical | multiLine;
35  	_hSelf = ::CreateWindowEx(
36  				0,
37  				WC_TABCONTROL,
38  				TEXT("Tab"),
39  				style,
40  				0, 0, 0, 0,
41  				_hParent,
42  				NULL,
43  				_hInst,
44  				0);
45  	if (!_hSelf)
46  	{
47  		throw std::runtime_error("TabBar::init : CreateWindowEx() function return null");
48  	}
49  }
50  void TabBar::destroy()
51  {
52  	if (_hFont)
53  	{
54  		::DeleteObject(_hFont);
55  		_hFont = nullptr;
56  	}
57  	if (_hLargeFont)
58  	{
59  		::DeleteObject(_hLargeFont);
60  		_hLargeFont = nullptr;
61  	}
62  	if (_hVerticalFont)
63  	{
64  		::DeleteObject(_hVerticalFont);
65  		_hVerticalFont = nullptr;
66  	}
67  	if (_hVerticalLargeFont)
68  	{
69  		::DeleteObject(_hVerticalLargeFont);
70  		_hVerticalLargeFont = nullptr;
71  	}
72  	::DestroyWindow(_hSelf);
73  	_hSelf = nullptr;
74  }
75  int TabBar::insertAtEnd(const TCHAR *subTabName)
76  {
77  	TCITEM tie{};
78  	tie.mask = TCIF_TEXT | TCIF_IMAGE;
79  	int index = -1;
80  	if (_hasImgLst)
81  		index = 0;
82  	tie.iImage = index;
83  	tie.pszText = (TCHAR *)subTabName;
84  	return int(::SendMessage(_hSelf, TCM_INSERTITEM, _nbItem++, reinterpret_cast<LPARAM>(&tie)));
85  }
86  void TabBar::getCurrentTitle(TCHAR *title, int titleLen)
87  {
88  	TCITEM tci{};
89  	tci.mask = TCIF_TEXT;
90  	tci.pszText = title;
91  	tci.cchTextMax = titleLen-1;
92  	::SendMessage(_hSelf, TCM_GETITEM, getCurrentTabIndex(), reinterpret_cast<LPARAM>(&tci));
93  }
94  void TabBar::setFont(const TCHAR *fontName, int fontSize)
95  {
96  	if (_hFont)
97  		::DeleteObject(_hFont);
98  	_hFont = ::CreateFont( fontSize, 0,
99  						(_isVertical) ? 900:0,
100  						(_isVertical) ? 900:0,
101  						FW_NORMAL,
102  						0, 0, 0, 0,
103  						0, 0, 0, 0,
104  						fontName);
105  	if (_hFont)
106  		::SendMessage(_hSelf, WM_SETFONT, reinterpret_cast<WPARAM>(_hFont), 0);
107  }
108  void TabBar::activateAt(int index) const
109  {
110  	if (getCurrentTabIndex() != index)
111  	{
112  		if (::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS)
113  		{
114  			::SendMessage(_hSelf, TCM_SETCURFOCUS, index, 0);
115  		}
116  		::SendMessage(_hSelf, TCM_SETCURSEL, index, 0);
117  	}
118  }
119  void TabBar::deletItemAt(size_t index)
120  {
121  	if (index == _nbItem - 1)
122  	{
123  		if (_nbItem > 1)
124  		{
125  			RECT itemRect{};
126  			::SendMessage(_hSelf, TCM_GETITEMRECT, index, reinterpret_cast<LPARAM>(&itemRect));
127  			if (itemRect.left < 5) 
128  			{
129  				int wParam = MAKEWPARAM(SB_THUMBPOSITION, index - 1);
130  				::SendMessage(_hSelf, WM_HSCROLL, wParam, 0);
131  				wParam = MAKEWPARAM(SB_ENDSCROLL, index - 1);
132  				::SendMessage(_hSelf, WM_HSCROLL, wParam, 0);
133  			}
134  		}
135  	}
136  	::SendMessage(_hSelf, TCM_DELETEITEM, index, 0);
137  	_nbItem--;
138  }
139  void TabBar::setImageList(HIMAGELIST himl)
140  {
141  	_hasImgLst = true;
142  	::SendMessage(_hSelf, TCM_SETIMAGELIST, 0, reinterpret_cast<LPARAM>(himl));
143  }
144  void TabBar::reSizeTo(RECT & rc2Ajust)
145  {
146  	RECT rowRect{};
147  	int rowCount = 0, tabsHight = 0;
148  	display(rc2Ajust.right > 10);
149  	RECT rc = rc2Ajust;
150  	Window::reSizeTo(rc);
151  	rowCount = TabCtrl_GetRowCount(_hSelf);
152  	TabCtrl_GetItemRect(_hSelf, 0, &rowRect);
153  	int larger = _isVertical ? rowRect.right : rowRect.bottom;
154  	int smaller = _isVertical ? rowRect.left : rowRect.top;
155  	int marge = 0;
156  	LONG_PTR style = ::GetWindowLongPtr(_hSelf, GWL_STYLE);
157  	if (rowCount == 1)
158  	{
159  		style &= ~TCS_BUTTONS;
160  	}
161  	else 
162  	{
163  		style |= TCS_BUTTONS;
164  		marge = (rowCount - 2) * 3; 
165  	}
166  	::SetWindowLongPtr(_hSelf, GWL_STYLE, style);
167  	tabsHight = rowCount * (larger - smaller) + marge;
168  	tabsHight += GetSystemMetrics(_isVertical ? SM_CXEDGE : SM_CYEDGE);
169  	if (_isVertical)
170  	{
171  		rc2Ajust.left += tabsHight;
172  		rc2Ajust.right -= tabsHight;
173  	}
174  	else
175  	{
176  		rc2Ajust.top += tabsHight;
177  		rc2Ajust.bottom -= tabsHight;
178  	}
179  }
180  void TabBarPlus::destroy()
181  {
182  	TabBar::destroy();
183  	::DestroyWindow(_tooltips);
184  	_tooltips = NULL;
185  }
186  void TabBarPlus::init(HINSTANCE hInst, HWND parent, bool isVertical, bool isMultiLine)
187  {
188  	Window::init(hInst, parent);
189  	int vertical = isVertical?(TCS_VERTICAL | TCS_MULTILINE | TCS_RIGHTJUSTIFY):0;
190  	_isVertical = isVertical;
191  	_isMultiLine = isMultiLine;
192  	INITCOMMONCONTROLSEX icce{};
193  	icce.dwSize = sizeof(icce);
194  	icce.dwICC = ICC_TAB_CLASSES;
195  	InitCommonControlsEx(&icce);
196  	int multiLine = isMultiLine ? TCS_MULTILINE : 0;
197  	int style = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE | TCS_FOCUSNEVER | TCS_TABS | vertical | multiLine;
198  	style |= TCS_OWNERDRAWFIXED;
199  	_hSelf = ::CreateWindowEx(
200  				0,
201  				WC_TABCONTROL,
202  				TEXT("Tab"),
203  				style,
204  				0, 0, 0, 0,
205  				_hParent,
206  				NULL,
207  				_hInst,
208  				0);
209  	if (!_hSelf)
210  	{
211  		throw std::runtime_error("TabBarPlus::init : CreateWindowEx() function return null");
212  	}
213  	_tooltips = ::CreateWindowEx(
214  		0,
215  		TOOLTIPS_CLASS,
216  		NULL,
217  		TTS_ALWAYSTIP | TTS_NOPREFIX,
218  		0, 0, 0, 0,
219  		_hParent,
220  		NULL,
221  		_hInst,
222  		0);
223  	if (!_tooltips)
224  	{
225  		throw std::runtime_error("TabBarPlus::init : tooltip CreateWindowEx() function return null");
226  	}
227  	NppDarkMode::setDarkTooltips(_tooltips, NppDarkMode::ToolTipsType::tooltip);
228  	::SendMessage(_hSelf, TCM_SETTOOLTIPS, reinterpret_cast<WPARAM>(_tooltips), 0);
229  	if (!_hwndArray[_nbCtrl])
230  	{
231  		_hwndArray[_nbCtrl] = _hSelf;
232  		_ctrlID = _nbCtrl;
233  	}
234  	else
235  	{
236  		int i = 0;
237  		bool found = false;
238  		for ( ; i < nbCtrlMax && !found ; ++i)
239  			if (!_hwndArray[i])
240  				found = true;
241  		if (!found)
242  		{
243  			_ctrlID = -1;
244  			destroy();
245  			throw std::runtime_error("TabBarPlus::init : Tab Control error - Tab Control # is over its limit");
246  		}
247  		_hwndArray[i] = _hSelf;
248  		_ctrlID = i;
249  	}
250  	++_nbCtrl;
251  	::SetWindowLongPtr(_hSelf, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
252  	_tabBarDefaultProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hSelf, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(TabBarPlus_Proc)));
253  	auto& dpiManager = NppParameters::getInstance()._dpiManager;
254  	LOGFONT lf{ NppParameters::getDefaultGUIFont() };
255  	LOGFONT lfVer{ lf };
256  	_hFont = ::CreateFontIndirect(&lf);
257  	lf.lfWeight = FW_HEAVY;
258  	lf.lfHeight = -(dpiManager.pointsToPixels(10));
259  	_hLargeFont = ::CreateFontIndirect(&lf);
260  	lfVer.lfEscapement = 900;
261  	lfVer.lfOrientation = 900;
262  	_hVerticalFont = CreateFontIndirect(&lfVer);
263  	lfVer.lfWeight = FW_HEAVY;
264  	_hVerticalLargeFont = CreateFontIndirect(&lfVer);
265  }
266  void TabBarPlus::doOwnerDrawTab()
267  {
268  	::SendMessage(_hwndArray[0], TCM_SETPADDING, 0, MAKELPARAM(6, 0));
269  	for (int i = 0 ; i < _nbCtrl ; ++i)
270  	{
271  		if (_hwndArray[i])
272  		{
273  			LONG_PTR style = ::GetWindowLongPtr(_hwndArray[i], GWL_STYLE);
274  			if (isOwnerDrawTab())
275  				style |= TCS_OWNERDRAWFIXED;
276  			else
277  				style &= ~TCS_OWNERDRAWFIXED;
278  			::SetWindowLongPtr(_hwndArray[i], GWL_STYLE, style);
279  			::InvalidateRect(_hwndArray[i], NULL, TRUE);
280  			const int paddingSizeDynamicW = NppParameters::getInstance()._dpiManager.scaleX(6);
281  			const int paddingSizePlusClosebuttonDynamicW = NppParameters::getInstance()._dpiManager.scaleX(10);
282  			::SendMessage(_hwndArray[i], TCM_SETPADDING, 0, MAKELPARAM(_drawTabCloseButton ? paddingSizePlusClosebuttonDynamicW : paddingSizeDynamicW, 0));
283  		}
284  	}
285  }
286  void TabBarPlus::setColour(COLORREF colour2Set, tabColourIndex i)
287  {
288  	switch (i)
289  	{
290  		case activeText:
291  			_activeTextColour = colour2Set;
292  			break;
293  		case activeFocusedTop:
294  			_activeTopBarFocusedColour = colour2Set;
295  			break;
296  		case activeUnfocusedTop:
297  			_activeTopBarUnfocusedColour = colour2Set;
298  			break;
299  		case inactiveText:
300  			_inactiveTextColour = colour2Set;
301  			break;
302  		case inactiveBg :
303  			_inactiveBgColour = colour2Set;
304  			break;
305  		default :
306  			return;
307  	}
308  	doOwnerDrawTab();
309  }
310  void TabBarPlus::doVertical()
311  {
312  	for (int i = 0 ; i < _nbCtrl ; ++i)
313  	{
314  		if (_hwndArray[i])
315  			SendMessage(_hwndArray[i], WM_TABSETSTYLE, isVertical(), TCS_VERTICAL);
316  	}
317  }
318  void TabBarPlus::doMultiLine()
319  {
320  	for (int i = 0 ; i < _nbCtrl ; ++i)
321  	{
322  		if (_hwndArray[i])
323  			SendMessage(_hwndArray[i], WM_TABSETSTYLE, isMultiLine(), TCS_MULTILINE);
324  	}
325  }
326  void TabBarPlus::notify(int notifyCode, int tabIndex)
327  {
328  	TBHDR nmhdr{};
329  	nmhdr._hdr.hwndFrom = _hSelf;
330  	nmhdr._hdr.code = notifyCode;
331  	nmhdr._hdr.idFrom = reinterpret_cast<UINT_PTR>(this);
332  	nmhdr._tabOrigin = tabIndex;
333  	::SendMessage(_hParent, WM_NOTIFY, 0, reinterpret_cast<LPARAM>(&nmhdr));
334  }
335  void TabBarPlus::trackMouseEvent(DWORD event2check)
336  {
337  	TRACKMOUSEEVENT tme = {};
338  	tme.cbSize = sizeof(tme);
339  	tme.dwFlags = event2check;
340  	tme.hwndTrack = _hSelf;
341  	TrackMouseEvent(&tme);
342  }
343  LRESULT TabBarPlus::runProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
344  {
345  	switch (Message)
346  	{
347  		case WM_TABSETSTYLE:
348  		{
349  			LONG_PTR style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
350  			if (wParam > 0)
351  				style |= lParam;
352  			else
353  				style &= ~lParam;
354  			_isVertical  = ((style & TCS_VERTICAL) != 0);
355  			_isMultiLine = ((style & TCS_MULTILINE) != 0);
356  			::SetWindowLongPtr(hwnd, GWL_STYLE, style);
357  			::InvalidateRect(hwnd, NULL, TRUE);
358  			return TRUE;
359  		}
360  		case NPPM_INTERNAL_REFRESHDARKMODE:
361  		{
362  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::tabbar);
363  			return TRUE;
364  		}
365  		case WM_MOUSEWHEEL:
366  		{
367  			if (_isDragging)
368  				return TRUE;
369  			const bool isForward = ((short)HIWORD(wParam)) < 0; 
370  			const int lastTabIndex = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETITEMCOUNT, 0, 0) - 1);
371  			if ((wParam & MK_CONTROL) && (wParam & MK_SHIFT))
372  			{
373  				setActiveTab((isForward ? lastTabIndex : 0));
374  			}
375  			else if ((wParam & MK_SHIFT) && _doDragNDrop)
376  			{
377  				int oldTabIndex = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
378  				int newTabIndex = oldTabIndex + (isForward ? 1 : -1);
379  				if (newTabIndex < 0)
380  				{
381  					newTabIndex = lastTabIndex; 
382  				}
383  				else if (newTabIndex > lastTabIndex)
384  				{
385  					newTabIndex = 0; 
386  				}
387  				if (oldTabIndex != newTabIndex)
388  				{
389  					exchangeTabItemData(oldTabIndex, newTabIndex);
390  				}
391  			}
392  			else if (wParam & (MK_CONTROL | MK_SHIFT))
393  			{
394  				int tabIndex = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0) + (isForward ? 1 : -1));
395  				if (tabIndex < 0)
396  				{
397  					if (wParam & MK_CONTROL)
398  						tabIndex = lastTabIndex; 
399  					else
400  						return TRUE;
401  				}
402  				else if (tabIndex > lastTabIndex)
403  				{
404  					if (wParam & MK_CONTROL)
405  						tabIndex = 0; 
406  					else
407  						return TRUE;
408  				}
409  				setActiveTab(tabIndex);
410  			}
411  			else if (!_isMultiLine) 
412  			{
413  				RECT rcTabCtrl{}, rcLastTab{};
414  				::SendMessage(_hSelf, TCM_GETITEMRECT, lastTabIndex, reinterpret_cast<LPARAM>(&rcLastTab));
415  				::GetClientRect(_hSelf, &rcTabCtrl);
416  				TC_HITTESTINFO hti{};
417  				LONG xy = NppParameters::getInstance()._dpiManager.scaleX(12); 
418  				hti.pt = { xy, xy };
419  				int scrollTabIndex = static_cast<int32_t>(::SendMessage(_hSelf, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&hti)));
420  				if (scrollTabIndex < 1 && (_isVertical ? rcLastTab.bottom < rcTabCtrl.bottom : rcLastTab.right < rcTabCtrl.right)) 
421  					return TRUE;
422  				LONG maxLengthUpDownCtrl = NppParameters::getInstance()._dpiManager.scaleX(44); 
423  				if ((_isVertical ? ((rcTabCtrl.bottom - rcLastTab.bottom) < maxLengthUpDownCtrl) : ((rcTabCtrl.right - rcLastTab.right) < maxLengthUpDownCtrl)) || !isForward)
424  				{
425  					if (isForward)
426  						++scrollTabIndex;
427  					else
428  						--scrollTabIndex;
429  					if (scrollTabIndex < 0 || scrollTabIndex > lastTabIndex)
430  						return TRUE;
431  					if (_isCloseHover)
432  					{
433  						_isCloseHover = false;
434  						::InvalidateRect(_hSelf, &_currentHoverTabRect, false);
435  					}
436  					::SendMessage(_hSelf, WM_HSCROLL, MAKEWPARAM(SB_THUMBPOSITION, scrollTabIndex), 0);
437  				}
438  			}
439  			return TRUE;
440  		}
441  		case WM_LBUTTONDOWN :
442  		{
443  			if (::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS)
444  			{
445  				int nTab = getTabIndexAt(LOWORD(lParam), HIWORD(lParam));
446  				if (nTab != -1 && nTab != static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0)))
447  				{
448  					setActiveTab(nTab);
449  				}
450  			}
451  			if (_drawTabCloseButton)
452  			{
453  				int xPos = LOWORD(lParam);
454  				int yPos = HIWORD(lParam);
455  				if (_closeButtonZone.isHit(xPos, yPos, _currentHoverTabRect, _isVertical))
456  				{
457  					_whichCloseClickDown = getTabIndexAt(xPos, yPos);
458  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_REFRESHTABAR, 0);
459  					return TRUE;
460  				}
461  			}
462  			::CallWindowProc(_tabBarDefaultProc, hwnd, Message, wParam, lParam);
463  			int currentTabOn = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
464  			if (wParam == 2)
465  				return TRUE;
466  			if (_doDragNDrop)
467  			{
468  				_mightBeDragging = true;
469  			}
470  			notify(NM_CLICK, currentTabOn);
471  			return TRUE;
472  		}
473  		case WM_RBUTTONDOWN :	
474  		{
475  			if (::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS)
476  			{
477  				int nTab = getTabIndexAt(LOWORD(lParam), HIWORD(lParam));
478  				if (nTab != -1 && nTab != static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0)))
479  				{
480  					setActiveTab(nTab);
481  				}
482  			}
483  			::CallWindowProc(_tabBarDefaultProc, hwnd, WM_LBUTTONDOWN, wParam, lParam);
484  			return TRUE;
485  		}
486  		case WM_MOUSEMOVE :
487  		{
488  			if (_mightBeDragging && !_isDragging)
489  			{
490  				if (GetKeyState(VK_LBUTTON) >= 0)
491  				{
492  					_mightBeDragging = false;
493  					_dragCount = 0;
494  				}
495  				else if (++_dragCount > 2)
496  				{
497  					int tabSelected = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
498  					if (tabSelected >= 0)
499  					{
500  						_nSrcTab = _nTabDragged = tabSelected;
501  						_isDragging = true;
502  						if (::GetCapture() != _hSelf)
503  						{
504  							::SetCapture(hwnd);
505  						}
506  					}
507  				}
508  			}
509  			POINT p{};
510  			p.x = LOWORD(lParam);
511  			p.y = HIWORD(lParam);
512  			if (_isDragging)
513  			{
514  				exchangeItemData(p);
515  				::GetCursorPos(&_draggingPoint);
516  				draggingCursor(_draggingPoint);
517  				return TRUE;
518  			}
519  			else
520  			{
521  				bool isFromTabToTab = false;
522  				int iTabNow = getTabIndexAt(p.x, p.y); 
523  				if (_currentHoverTabItem == iTabNow && _currentHoverTabItem != -1) 
524  				{
525  				}
526  				else if (iTabNow == -1 && _currentHoverTabItem != -1) 
527  				{
528  					_currentHoverTabItem = -1;
529  					notify(TCN_MOUSELEAVING, -1);
530  				}
531  				else if (iTabNow != -1 && _currentHoverTabItem == -1) 
532  				{
533  					_currentHoverTabItem = iTabNow;
534  					notify(TCN_MOUSEHOVERING, _currentHoverTabItem);
535  				}
536  				else if (iTabNow != -1 && _currentHoverTabItem != -1 && _currentHoverTabItem != iTabNow) 
537  				{
538  					isFromTabToTab = true;
539  					_whichCloseClickDown = -1;
540  					_currentHoverTabItem = iTabNow;
541  					notify(TCN_MOUSEHOVERSWITCHING, _currentHoverTabItem);
542  				}
543  				else if (iTabNow == -1 && _currentHoverTabItem == -1) 
544  				{
545  				}
546  				if (_drawTabCloseButton)
547  				{
548  					RECT currentHoverTabRectOld = _currentHoverTabRect;
549  					bool isCloseHoverOld = _isCloseHover;
550  					if (_currentHoverTabItem != -1) 
551  					{
552  						::SendMessage(_hSelf, TCM_GETITEMRECT, _currentHoverTabItem, reinterpret_cast<LPARAM>(&_currentHoverTabRect));
553  						_isCloseHover = _closeButtonZone.isHit(p.x, p.y, _currentHoverTabRect, _isVertical);
554  					}
555  					else
556  					{
557  						SetRectEmpty(&_currentHoverTabRect);
558  						_isCloseHover = false;
559  					}
560  					if (isFromTabToTab || _isCloseHover != isCloseHoverOld)
561  					{
562  						if (isCloseHoverOld && (isFromTabToTab || !_isCloseHover))
563  							InvalidateRect(hwnd, &currentHoverTabRectOld, FALSE);
564  						if (_isCloseHover)
565  							InvalidateRect(hwnd, &_currentHoverTabRect, FALSE);
566  					}
567  					if (_isCloseHover)
568  					{
569  						trackMouseEvent(TME_LEAVE);
570  					}
571  				}
572  				trackMouseEvent(TME_LEAVE);
573  			}
574  			break;
575  		}
576  		case WM_MOUSELEAVE:
577  		{
578  			if (_isCloseHover)
579  				InvalidateRect(hwnd, &_currentHoverTabRect, FALSE);
580  			_currentHoverTabItem = -1;
581  			_whichCloseClickDown = -1;
582  			SetRectEmpty(&_currentHoverTabRect);
583  			_isCloseHover = false;
584  			notify(TCN_MOUSELEAVING, _currentHoverTabItem);
585  			break;
586  		}
587  		case WM_LBUTTONUP :
588  		{
589  			_mightBeDragging = false;
590  			_dragCount = 0;
591  			int xPos = LOWORD(lParam);
592  			int yPos = HIWORD(lParam);
593  			int currentTabOn = getTabIndexAt(xPos, yPos);
594  			if (_isDragging)
595  			{
596  				if (::GetCapture() == _hSelf)
597  				{
598  					::ReleaseCapture();
599  				}
600  				else
601  				{
602  					_isDragging = false;
603  				}
604  				notify(_isDraggingInside?TCN_TABDROPPED:TCN_TABDROPPEDOUTSIDE, currentTabOn);
605  				return TRUE;
606  			}
607  			if (_drawTabCloseButton)
608  			{
609  				if ((_whichCloseClickDown == currentTabOn) && _closeButtonZone.isHit(xPos, yPos, _currentHoverTabRect, _isVertical))
610  				{
611  					notify(TCN_TABDELETE, currentTabOn);
612  					_whichCloseClickDown = -1;
613  					int nextTab = getTabIndexAt(xPos, yPos);
614  					if (nextTab != -1)
615  					{
616  						::SendMessage(_hSelf, TCM_GETITEMRECT, nextTab, reinterpret_cast<LPARAM>(&_currentHoverTabRect));
617  						_isCloseHover = _closeButtonZone.isHit(xPos, yPos, _currentHoverTabRect, _isVertical);
618  					}
619  					return TRUE;
620  				}
621  				_whichCloseClickDown = -1;
622  			}
623  			break;
624  		}
625  		case WM_CAPTURECHANGED :
626  		{
627  			if (_isDragging)
628  			{
629  				_isDragging = false;
630  				return TRUE;
631  			}
632  			break;
633  		}
634  		case WM_DRAWITEM :
635  		{
636  			drawItem((DRAWITEMSTRUCT *)lParam);
637  			return TRUE;
638  		}
639  		case WM_KEYDOWN :
640  		{
641  			if (wParam == VK_LCONTROL)
642  				::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_PLUS_TAB)));
643  			return TRUE;
644  		}
645  		case WM_MBUTTONUP:
646  		{
647  			int xPos = LOWORD(lParam);
648  			int yPos = HIWORD(lParam);
649  			int currentTabOn = getTabIndexAt(xPos, yPos);
650  			notify(TCN_TABDELETE, currentTabOn);
651  			return TRUE;
652  		}
653  		case WM_LBUTTONDBLCLK:
654  		{
655  			if (_isDbClk2Close)
656  			{
657  				int xPos = LOWORD(lParam);
658  				int yPos = HIWORD(lParam);
659  				int currentTabOn = getTabIndexAt(xPos, yPos);
660  				notify(TCN_TABDELETE, currentTabOn);
661  			}
662  			return TRUE;
663  		}
664  		case WM_ERASEBKGND:
665  		{
666  			if (!NppDarkMode::isEnabled())
667  			{
668  				break;
669  			}
670  			RECT rc{};
671  			GetClientRect(hwnd, &rc);
672  			FillRect((HDC)wParam, &rc, NppDarkMode::getDarkerBackgroundBrush());
673  			return 1;
674  		}
675  		case WM_PAINT:
676  		{
677  			if (!NppDarkMode::isEnabled())
678  			{
679  				break;
680  			}
681  			LONG_PTR dwStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
682  			if (!(dwStyle & TCS_OWNERDRAWFIXED))
683  			{
684  				break;
685  			}
686  			const bool hasMultipleLines = ((dwStyle & TCS_BUTTONS) == TCS_BUTTONS);
687  			PAINTSTRUCT ps{};
688  			HDC hdc = BeginPaint(hwnd, &ps);
689  			FillRect(hdc, &ps.rcPaint, NppDarkMode::getDarkerBackgroundBrush());
690  			UINT id = ::GetDlgCtrlID(hwnd);
691  			auto holdPen = static_cast<HPEN>(::SelectObject(hdc, NppDarkMode::getEdgePen()));
692  			HRGN holdClip = CreateRectRgn(0, 0, 0, 0);
693  			if (1 != GetClipRgn(hdc, holdClip))
694  			{
695  				DeleteObject(holdClip);
696  				holdClip = nullptr;
697  			}
698  			auto& dpiManager = NppParameters::getInstance()._dpiManager;
699  			int paddingDynamicTwoX = dpiManager.scaleX(2);
700  			int paddingDynamicTwoY = dpiManager.scaleY(2);
701  			int nTabs = TabCtrl_GetItemCount(hwnd);
702  			int nFocusTab = TabCtrl_GetCurFocus(hwnd);
703  			int nSelTab = TabCtrl_GetCurSel(hwnd);
704  			for (int i = 0; i < nTabs; ++i)
705  			{
706  				DRAWITEMSTRUCT dis = { ODT_TAB, id, (UINT)i, ODA_DRAWENTIRE, ODS_DEFAULT, hwnd, hdc, {}, 0 };
707  				TabCtrl_GetItemRect(hwnd, i, &dis.rcItem);
708  				if (i == nFocusTab)
709  				{
710  					dis.itemState |= ODS_FOCUS;
711  				}
712  				if (i == nSelTab)
713  				{
714  					dis.itemState |= ODS_SELECTED;
715  				}
716  				dis.itemState |= ODS_NOFOCUSRECT; 
717  				RECT rcIntersect{};
718  				if (IntersectRect(&rcIntersect, &ps.rcPaint, &dis.rcItem))
719  				{
720  					if (!hasMultipleLines)
721  					{
722  						if (_isVertical)
723  						{
724  							POINT edges[] = {
725  								{dis.rcItem.left, dis.rcItem.bottom - 1},
726  								{dis.rcItem.right, dis.rcItem.bottom - 1}
727  							};
728  							if (i != nSelTab && (i != nSelTab - 1))
729  							{
730  								edges[0].x += paddingDynamicTwoX;
731  							}
732  							::Polyline(hdc, edges, _countof(edges));
733  							dis.rcItem.bottom -= 1;
734  						}
735  						else
736  						{
737  							POINT edges[] = {
738  								{dis.rcItem.right - 1, dis.rcItem.top},
739  								{dis.rcItem.right - 1, dis.rcItem.bottom}
740  							};
741  							if (i != nSelTab && (i != nSelTab - 1))
742  							{
743  								edges[0].y += paddingDynamicTwoY;
744  							}
745  							::Polyline(hdc, edges, _countof(edges));
746  							dis.rcItem.right -= 1;
747  						}
748  					}
749  					HRGN hClip = CreateRectRgnIndirect(&dis.rcItem);
750  					SelectClipRgn(hdc, hClip);
751  					drawItem(&dis, NppDarkMode::isEnabled());
752  					DeleteObject(hClip);
753  					SelectClipRgn(hdc, holdClip);
754  				}
755  			}
756  			if (!hasMultipleLines)
757  			{
758  				RECT rcFirstTab{};
759  				TabCtrl_GetItemRect(hwnd, 0, &rcFirstTab);
760  				if (_isVertical)
761  				{
762  					POINT edges[] = {
763  						{rcFirstTab.left, rcFirstTab.top},
764  						{rcFirstTab.right, rcFirstTab.top}
765  					};
766  					if (nSelTab != 0)
767  					{
768  						edges[0].x += paddingDynamicTwoX;
769  					}
770  					::Polyline(hdc, edges, _countof(edges));
771  				}
772  				else
773  				{
774  					POINT edges[] = {
775  						{rcFirstTab.left, rcFirstTab.top},
776  						{rcFirstTab.left, rcFirstTab.bottom}
777  					};
778  					if (nSelTab != 0)
779  					{
780  						edges[0].y += paddingDynamicTwoY;
781  					}
782  					::Polyline(hdc, edges, _countof(edges));
783  				}
784  			}
785  			SelectClipRgn(hdc, holdClip);
786  			if (holdClip)
787  			{
788  				DeleteObject(holdClip);
789  				holdClip = nullptr;
790  			}
791  			SelectObject(hdc, holdPen);
792  			EndPaint(hwnd, &ps);
793  			return 0;
794  		}
795  		case WM_PARENTNOTIFY:
796  		{
797  			switch (LOWORD(wParam))
798  			{
799  				case WM_CREATE:
800  				{
801  					auto hwndUpdown = reinterpret_cast<HWND>(lParam);
802  					if (NppDarkMode::subclassTabUpDownControl(hwndUpdown))
803  					{
804  						return 0;
805  					}
806  					break;
807  				}
808  			}
809  			return 0;
810  		}
811  	}
812  	return ::CallWindowProc(_tabBarDefaultProc, hwnd, Message, wParam, lParam);
813  }
814  void TabBarPlus::drawItem(DRAWITEMSTRUCT *pDrawItemStruct, bool isDarkMode)
815  {
816  	RECT rect = pDrawItemStruct->rcItem;
817  	int nTab = pDrawItemStruct->itemID;
818  	if (nTab < 0)
819  	{
820  		::MessageBox(NULL, TEXT("nTab < 0"), TEXT(""), MB_OK);
821  	}
822  	bool isSelected = (nTab == ::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
823  	TCHAR label[MAX_PATH] = { '\0' };
824  	TCITEM tci{};
825  	tci.mask = TCIF_TEXT|TCIF_IMAGE;
826  	tci.pszText = label;
827  	tci.cchTextMax = MAX_PATH-1;
828  	if (!::SendMessage(_hSelf, TCM_GETITEM, nTab, reinterpret_cast<LPARAM>(&tci)))
829  	{
830  		::MessageBox(NULL, TEXT("! TCM_GETITEM"), TEXT(""), MB_OK);
831  	}
832  	const COLORREF colorActiveBg = isDarkMode ? NppDarkMode::getSofterBackgroundColor() : ::GetSysColor(COLOR_BTNFACE);
833  	const COLORREF colorInactiveBgBase = isDarkMode ? NppDarkMode::getBackgroundColor() : ::GetSysColor(COLOR_BTNFACE);
834  	COLORREF colorInactiveBg = liteGrey;
835  	COLORREF colorActiveText = ::GetSysColor(COLOR_BTNTEXT);
836  	COLORREF colorInactiveText = grey;
837  	if (!NppDarkMode::useTabTheme() && isDarkMode)
838  	{
839  		colorInactiveBg = NppDarkMode::getBackgroundColor();
840  		colorActiveText = NppDarkMode::getTextColor();
841  		colorInactiveText = NppDarkMode::getDarkerTextColor();
842  	}
843  	else
844  	{
845  		colorInactiveBg = _inactiveBgColour;
846  		colorActiveText = _activeTextColour;
847  		colorInactiveText = _inactiveTextColour;
848  	}
<span onclick='openModal()' class='match'>849  	HDC hDC = pDrawItemStruct->hDC;
850  	int nSavedDC = ::SaveDC(hDC);
851  	::SetBkMode(hDC, TRANSPARENT);
</span>852  	HBRUSH hBrush = ::CreateSolidBrush(colorInactiveBgBase);
853  	::FillRect(hDC, &rect, hBrush);
854  	::DeleteObject((HGDIOBJ)hBrush);
855  	auto& dpiManager = NppParameters::getInstance()._dpiManager;
856  	int paddingDynamicTwoX = dpiManager.scaleX(2);
857  	int paddingDynamicTwoY = dpiManager.scaleY(2);
858  	if (isSelected && !isDarkMode)
859  	{
860  		rect.top += ::GetSystemMetrics(SM_CYEDGE);
861  		rect.bottom -= ::GetSystemMetrics(SM_CYEDGE);
862  		rect.left += ::GetSystemMetrics(SM_CXEDGE);
863  		rect.right -= ::GetSystemMetrics(SM_CXEDGE);
864  		if (_isVertical)
865  		{
866  			rect.left += _drawTopBar ? paddingDynamicTwoX : 0;
867  			rect.right -= _drawTopBar ? 0 : paddingDynamicTwoX;
868  		}
869  		else
870  		{
871  			rect.top += _drawTopBar ? paddingDynamicTwoY : 0;
872  			rect.bottom -= _drawTopBar ? 0 : paddingDynamicTwoY;
873  		}
874  	}
875  	else
876  	{
877  		if (_isVertical)
878  		{
879  			rect.left += paddingDynamicTwoX;
880  			rect.right += paddingDynamicTwoX;
881  			rect.top -= paddingDynamicTwoY;
882  			rect.bottom += paddingDynamicTwoY;
883  		}
884  		else
885  		{
886  			rect.left -= paddingDynamicTwoX;
887  			rect.right += paddingDynamicTwoX;
888  			rect.top += paddingDynamicTwoY;
889  			rect.bottom += paddingDynamicTwoY;
890  		}
891  	}
892  	const bool hasMultipleLines = ((::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS) == TCS_BUTTONS);
893  	if (hasMultipleLines)
894  	{
895  		if (_isVertical)
896  		{
897  			rect.left -= paddingDynamicTwoX;
898  		}
899  		else
900  		{
901  			rect.top -= paddingDynamicTwoY;
902  		}
903  	}
904  	const int individualColourId = getIndividualTabColour(nTab);
905  	RECT barRect = rect;
906  	if (isSelected)
907  	{
908  		hBrush = ::CreateSolidBrush(colorActiveBg);
909  		::FillRect(hDC, &pDrawItemStruct->rcItem, hBrush);
910  		::DeleteObject(static_cast<HGDIOBJ>(hBrush));
911  		if (_drawTopBar)
912  		{
913  			int topBarHeight = dpiManager.scaleX(4);
914  			if (_isVertical)
915  			{
916  				barRect.left -= (hasMultipleLines && isDarkMode) ? 0 : paddingDynamicTwoX;
917  				barRect.right = barRect.left + topBarHeight;
918  			}
919  			else
920  			{
921  				barRect.top -= (hasMultipleLines && isDarkMode) ? 0 : paddingDynamicTwoY;
922  				barRect.bottom = barRect.top + topBarHeight;
923  			}
924  			if (::SendMessage(_hParent, NPPM_INTERNAL_ISFOCUSEDTAB, 0, reinterpret_cast<LPARAM>(_hSelf)))
925  			{
926  				COLORREF topBarColour = _activeTopBarFocusedColour; 
927  				if (individualColourId != -1)
928  				{
929  					topBarColour = NppDarkMode::getIndividualTabColour(individualColourId, isDarkMode, true);
930  				}
931  				hBrush = ::CreateSolidBrush(topBarColour);
932  			}
933  			else
934  				hBrush = ::CreateSolidBrush(_activeTopBarUnfocusedColour); 
935  			::FillRect(hDC, &barRect, hBrush);
936  			::DeleteObject((HGDIOBJ)hBrush);
937  		}
938  	}
939  	else 
940  	{
941  		RECT rect = hasMultipleLines ? pDrawItemStruct->rcItem : barRect;
942  		COLORREF brushColour{};
943  		if (_drawInactiveTab && individualColourId == -1)
944  		{
945  			brushColour = colorInactiveBg;
946  		}
947  		else if (individualColourId != -1)
948  		{
949  			brushColour = NppDarkMode::getIndividualTabColour(individualColourId, isDarkMode, false);
950  		}
951  		else
952  		{
953  			brushColour = colorActiveBg;
954  		}
955  		hBrush = ::CreateSolidBrush(brushColour);
956  		::FillRect(hDC, &rect, hBrush);
957  		::DeleteObject((HGDIOBJ)hBrush);
958  	}
959  	if (isDarkMode && hasMultipleLines)
960  	{
961  		::FrameRect(hDC, &pDrawItemStruct->rcItem, NppDarkMode::getEdgeBrush());
962  	}
963  	if (_drawTabCloseButton)
964  	{
965  		int idCloseImg;
966  		if (_isCloseHover && (_currentHoverTabItem == nTab) && (_whichCloseClickDown == -1)) 
967  			idCloseImg = isDarkMode ? IDR_CLOSETAB_HOVER_DM : IDR_CLOSETAB_HOVER;
968  		else if (_isCloseHover && (_currentHoverTabItem == nTab) && (_whichCloseClickDown == _currentHoverTabItem)) 
969  			idCloseImg = isDarkMode ? IDR_CLOSETAB_PUSH_DM : IDR_CLOSETAB_PUSH;
970  		else
971  			idCloseImg = isSelected ? (isDarkMode ? IDR_CLOSETAB_DM : IDR_CLOSETAB) : (isDarkMode ? IDR_CLOSETAB_INACT_DM : IDR_CLOSETAB_INACT);
972  		HDC hdcMemory = ::CreateCompatibleDC(hDC);
973  		HBITMAP hBmp = ::LoadBitmap(_hInst, MAKEINTRESOURCE(idCloseImg));
974  		BITMAP bmp{};
975  		::GetObject(hBmp, sizeof(bmp), &bmp);
976  		_closeButtonZone._width = dpiManager.scaleX(bmp.bmWidth);
977  		_closeButtonZone._height = dpiManager.scaleY(bmp.bmHeight);
978  		RECT buttonRect = _closeButtonZone.getButtonRectFrom(rect, _isVertical);
979  		const bool isRTL = (::GetWindowLongPtr(::GetParent(_hSelf), GWL_EXSTYLE) & WS_EX_LAYOUTRTL) == WS_EX_LAYOUTRTL;
980  		const int offset = isRTL && (_closeButtonZone._width == bmp.bmWidth) ? -1 : 0;
981  		::SelectObject(hdcMemory, hBmp);
982  		::StretchBlt(hDC, buttonRect.left + offset, buttonRect.top, _closeButtonZone._width, _closeButtonZone._height, hdcMemory, offset, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);
983  		::DeleteDC(hdcMemory);
984  		::DeleteObject(hBmp);
985  	}
986  	HIMAGELIST hImgLst = (HIMAGELIST)::SendMessage(_hSelf, TCM_GETIMAGELIST, 0, 0);
987  	if (hImgLst && tci.iImage >= 0)
988  	{
989  		IMAGEINFO info{};
990  		ImageList_GetImageInfo(hImgLst, tci.iImage, &info);
991  		RECT& imageRect = info.rcImage;
992  		int fromBorder;
993  		int xPos, yPos;
994  		if (_isVertical)
995  		{
996  			fromBorder = (rect.right - rect.left - (imageRect.right - imageRect.left) + 1) / 2;
997  			xPos = rect.left + fromBorder;
998  			yPos = rect.bottom - fromBorder - (imageRect.bottom - imageRect.top);
999  			rect.bottom -= fromBorder + (imageRect.bottom - imageRect.top);
1000  		}
1001  		else
1002  		{
1003  			fromBorder = (rect.bottom - rect.top - (imageRect.bottom - imageRect.top) + 1) / 2;
1004  			yPos = rect.top + fromBorder;
1005  			xPos = rect.left + fromBorder;
1006  			rect.left += fromBorder + (imageRect.right - imageRect.left);
1007  		}
1008  		ImageList_Draw(hImgLst, tci.iImage, hDC, xPos, yPos, isSelected ? ILD_TRANSPARENT : ILD_SELECTED);
1009  	}
1010  	bool isStandardSize = (::SendMessage(_hParent, NPPM_INTERNAL_ISTABBARREDUCED, 0, 0) == TRUE);
1011  	if (isStandardSize)
1012  	{
1013  		if (_isVertical)
1014  			SelectObject(hDC, _hVerticalFont);
1015  		else
1016  			SelectObject(hDC, _hFont);
1017  	}
1018  	else
1019  	{
1020  		if (_isVertical)
1021  			SelectObject(hDC, _hVerticalLargeFont);
1022  		else
1023  			SelectObject(hDC, _hLargeFont);
1024  	}
1025  	SIZE charPixel{};
1026  	::GetTextExtentPoint(hDC, TEXT(" "), 1, &charPixel);
1027  	int spaceUnit = charPixel.cx;
1028  	TEXTMETRIC textMetrics{};
1029  	GetTextMetrics(hDC, &textMetrics);
1030  	int textHeight = textMetrics.tmHeight;
1031  	int textDescent = textMetrics.tmDescent;
1032  	int Flags = DT_SINGLELINE | DT_NOPREFIX;
1033  	TCHAR decodedLabel[MAX_PATH] = { '\0' };
1034  	const TCHAR* in = label;
1035  	TCHAR* out = decodedLabel;
1036  	while (*in != 0)
1037  		if (*in == '&')
1038  			while (*(++in) == '&')
1039  				*out++ = *in;
1040  		else
1041  			*out++ = *in++;
1042  	*out = '\0';
1043  	if (_isVertical)
1044  	{
1045  		Flags |= DT_LEFT;
1046  		Flags |= DT_BOTTOM;
1047  		rect.left += (rect.right - rect.left - textHeight) / 2;
1048  		rect.bottom += textHeight;
1049  		rect.left += textDescent / 2;
1050  		rect.right += textDescent / 2;
1051  		rect.bottom -= spaceUnit;
1052  	}
1053  	else
1054  	{
1055  		Flags |= DT_LEFT;
1056  		Flags |= DT_TOP;
1057  		const int paddingText = ((pDrawItemStruct->rcItem.bottom - pDrawItemStruct->rcItem.top) - (textHeight + textDescent)) / 2;
1058  		const int paddingDescent = !hasMultipleLines ? ((textDescent + ((isDarkMode || !isSelected) ? 1 : 0)) / 2) : 0;
1059  		rect.top = pDrawItemStruct->rcItem.top + paddingText + paddingDescent;
1060  		rect.bottom = pDrawItemStruct->rcItem.bottom - paddingText + paddingDescent;
1061  		if (isDarkMode || !isSelected || _drawTopBar)
1062  		{
1063  			rect.top += paddingDynamicTwoY;
1064  		}
1065  		rect.left += spaceUnit;
1066  	}
1067  	COLORREF textColor = isSelected ? colorActiveText : colorInactiveText;
1068  	::SetTextColor(hDC, textColor);
1069  	::DrawText(hDC, decodedLabel, lstrlen(decodedLabel), &rect, Flags);
1070  	::RestoreDC(hDC, nSavedDC);
1071  }
1072  void TabBarPlus::draggingCursor(POINT screenPoint)
1073  {
1074  	HWND hWin = ::WindowFromPoint(screenPoint);
1075  	if (_hSelf == hWin)
1076  		::SetCursor(::LoadCursor(NULL, IDC_ARROW));
1077  	else
1078  	{
1079  		TCHAR className[256] = { '\0' };
1080  		::GetClassName(hWin, className, 256);
1081  		if ((!lstrcmp(className, TEXT("Scintilla"))) || (!lstrcmp(className, WC_TABCONTROL)))
1082  		{
1083  			if (::GetKeyState(VK_LCONTROL) & 0x80000000)
1084  				::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_PLUS_TAB)));
1085  			else
1086  				::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_TAB)));
1087  		}
1088  		else if (isPointInParentZone(screenPoint))
1089  			::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_INTERDIT_TAB)));
1090  		else 
1091  			::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_OUT_TAB)));
1092  	}
1093  }
1094  void TabBarPlus::setActiveTab(int tabIndex)
1095  {
1096  	if (::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS)
1097  	{
1098  		::SendMessage(_hSelf, TCM_SETCURFOCUS, tabIndex, 0);
1099  	}
1100  	::SendMessage(_hSelf, TCM_SETCURSEL, tabIndex, 0);
1101  	notify(TCN_SELCHANGE, tabIndex);
1102  }
1103  void TabBarPlus::exchangeTabItemData(int oldTab, int newTab)
1104  {
1105  	TCITEM itemData_nDraggedTab{}, itemData_shift{};
1106  	itemData_nDraggedTab.mask = itemData_shift.mask = TCIF_IMAGE | TCIF_TEXT | TCIF_PARAM;
1107  	const int stringSize = 256;
1108  	TCHAR str1[stringSize] = { '\0' };
1109  	TCHAR str2[stringSize] = { '\0' };
1110  	itemData_nDraggedTab.pszText = str1;
1111  	itemData_nDraggedTab.cchTextMax = (stringSize);
1112  	itemData_shift.pszText = str2;
1113  	itemData_shift.cchTextMax = (stringSize);
1114  	::SendMessage(_hSelf, TCM_GETITEM, oldTab, reinterpret_cast<LPARAM>(&itemData_nDraggedTab));
1115  	if (oldTab > newTab)
1116  	{
1117  		for (int i = oldTab; i > newTab; i--)
1118  		{
1119  			::SendMessage(_hSelf, TCM_GETITEM, i - 1, reinterpret_cast<LPARAM>(&itemData_shift));
1120  			::SendMessage(_hSelf, TCM_SETITEM, i, reinterpret_cast<LPARAM>(&itemData_shift));
1121  		}
1122  	}
1123  	else
1124  	{
1125  		for (int i = oldTab; i < newTab; ++i)
1126  		{
1127  			::SendMessage(_hSelf, TCM_GETITEM, i + 1, reinterpret_cast<LPARAM>(&itemData_shift));
1128  			::SendMessage(_hSelf, TCM_SETITEM, i, reinterpret_cast<LPARAM>(&itemData_shift));
1129  		}
1130  	}
1131  	::SendMessage(_hSelf, TCM_SETITEM, newTab, reinterpret_cast<LPARAM>(&itemData_nDraggedTab));
1132  	::SendMessage(_hParent, NPPM_INTERNAL_DOCORDERCHANGED, 0, oldTab);
1133  	setActiveTab(newTab);
1134  }
1135  void TabBarPlus::exchangeItemData(POINT point)
1136  {
1137  	int nTab = getTabIndexAt(point);
1138  	if (nTab != -1)
1139  	{
1140  		_isDraggingInside = true;
1141  		if (nTab != _nTabDragged)
1142  		{
1143  			if (_previousTabSwapped == nTab)
1144  			{
1145  				return;
1146  			}
1147  			exchangeTabItemData(_nTabDragged, nTab);
1148  			_previousTabSwapped = _nTabDragged;
1149  			_nTabDragged = nTab;
1150  		}
1151  		else
1152  		{
1153  			_previousTabSwapped = -1;
1154  		}
1155  	}
1156  	else
1157  	{
1158  		_previousTabSwapped = -1;
1159  		_isDraggingInside = false;
1160  	}
1161  }
1162  CloseButtonZone::CloseButtonZone()
1163  {
1164  	_width = NppParameters::getInstance()._dpiManager.scaleX(g_TabCloseBtnSize);
1165  	_height = _width;
1166  }
1167  bool CloseButtonZone::isHit(int x, int y, const RECT & tabRect, bool isVertical) const
1168  {
1169  	RECT buttonRect = getButtonRectFrom(tabRect, isVertical);
1170  	if (x >= buttonRect.left && x <= buttonRect.right && y >= buttonRect.top && y <= buttonRect.bottom)
1171  		return true;
1172  	return false;
1173  }
1174  RECT CloseButtonZone::getButtonRectFrom(const RECT & tabRect, bool isVertical) const
1175  {
1176  	RECT buttonRect{};
1177  	int fromBorder = 0;
1178  	if (isVertical)
1179  	{
1180  		fromBorder = (tabRect.right - tabRect.left - _width + 1) / 2;
1181  		buttonRect.left = tabRect.left + fromBorder;
1182  	}
1183  	else
1184  	{
1185  		fromBorder = (tabRect.bottom - tabRect.top - _height + 1) / 2;
1186  		buttonRect.left = tabRect.right - fromBorder - _width;
1187  	}
1188  	buttonRect.top = tabRect.top + fromBorder;
1189  	buttonRect.bottom = buttonRect.top + _height;
1190  	buttonRect.right = buttonRect.left + _width;
1191  	return buttonRect;
1192  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingCont.cpp</h3>
            <pre><code>1  #include "dockingResource.h"
2  #include "DockingCont.h"
3  #include "SplitterContainer.h"
4  #include "ToolTip.h"
5  #include "Parameters.h"
6  #include "localization.h"
7  using namespace std;
8  #ifndef WH_MOUSE_LL
9  #define WH_MOUSE_LL 14
10  #endif
11  static HWND		hWndServer		= NULL;
12  static HHOOK	hookMouse		= NULL;
13  static LRESULT CALLBACK hookProcMouse(int nCode, WPARAM wParam, LPARAM lParam)
14  {
15  	if (nCode >= 0)
16  	{
17  		switch (wParam)
18  		{
19  		case WM_MOUSEMOVE:
20  		case WM_NCMOUSEMOVE:
21  			::PostMessage(hWndServer, UINT(wParam), 0, 0);
22  			break;
23  		case WM_LBUTTONUP:
24  		case WM_NCLBUTTONUP:
25  			::PostMessage(hWndServer, UINT(wParam), 0, 0);
26  			break;
27  		default:
28  			break;
29  		}
30  	}
31  	return ::CallNextHookEx(hookMouse, nCode, wParam, lParam);
32  }
33  DockingCont::DockingCont()
34  {
35  	_isMouseOver		= FALSE;
36  	_isMouseClose		= FALSE;
37  	_isMouseDown		= FALSE;
38  	_isFloating			= false;
39  	_isTopCaption		= CAPTION_TOP;
40  	_dragFromTab		= FALSE;
41  	_hContTab			= NULL;
42  	_hDefaultTabProc	= NULL;
43  	_beginDrag			= FALSE;
44  	_prevItem			= 0;
45  	_hFont				= NULL;
46  	_bTabTTHover		= FALSE;
47  	_bCaptionTT			= FALSE;
48  	_bCapTTHover		= FALSE;
49  	_hoverMPos			= posClose;
50  	_bDrawOgLine		= TRUE;
51  	_vTbData.clear();
52  	_captionHeightDynamic = NppParameters::getInstance()._dpiManager.scaleY(_captionHeightDynamic);
53  	_captionGapDynamic = NppParameters::getInstance()._dpiManager.scaleY(_captionGapDynamic);
54  	_closeButtonPosLeftDynamic = NppParameters::getInstance()._dpiManager.scaleX(_closeButtonPosLeftDynamic);
55  	_closeButtonPosTopDynamic = NppParameters::getInstance()._dpiManager.scaleY(_closeButtonPosTopDynamic);
56  	_closeButtonWidth = NppParameters::getInstance()._dpiManager.scaleX(12); 
57  	_closeButtonHeight = NppParameters::getInstance()._dpiManager.scaleY(12);
58  }
59  DockingCont::~DockingCont()
60  {
61  	if (_hFont != nullptr)
62  	{
63  		::DeleteObject(_hFont);
64  		_hFont = nullptr;
65  	}
66  	if (_hFontCaption != nullptr)
67  	{
68  		::DeleteObject(_hFontCaption);
69  		_hFontCaption = nullptr;
70  	}
71  }
72  void DockingCont::doDialog(bool willBeShown, bool isFloating)
73  {
74  	if (!isCreated())
75  	{
76  		NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
77  		create(IDD_CONTAINER_DLG, pNativeSpeaker->isRTL());
78  		_isFloating  = isFloating;
79  		if (_isFloating)
80  		{
81  			::SetWindowLongPtr(_hSelf, GWL_STYLE, POPUP_STYLES);
82  			::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, pNativeSpeaker->isRTL()? POPUP_EXSTYLES | WS_EX_LAYOUTRTL : POPUP_EXSTYLES);
83  			::ShowWindow(_hCaption, SW_HIDE);
84  		}
85  		else
86  		{
87  			::SetWindowLongPtr(_hSelf, GWL_STYLE, CHILD_STYLES);
88  			::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, CHILD_EXSTYLES);
89  			::ShowWindow(_hCaption, SW_SHOW);
90  		}
91  		LOGFONT lfTab{ NppParameters::getDefaultGUIFont() };
92  		_hFont = ::CreateFontIndirect(&lfTab);
93  		LOGFONT lfCaption{ NppParameters::getDefaultGUIFont(NppParameters::DefaultFontType::smcaption) };
94  		_hFontCaption = ::CreateFontIndirect(&lfCaption);
95  	}
96  	display(willBeShown);
97  }
98  tTbData* DockingCont::createToolbar(tTbData data)
99  {
100  	tTbData *pTbData = new tTbData;
101  	*pTbData = data;
102  	::SetWindowLongPtr(pTbData->hClient, GWL_STYLE, CHILD_STYLES);
103  	::SetWindowLongPtr(pTbData->hClient, GWL_EXSTYLE, CHILD_EXSTYLES);
104  	if ((_isFloating) && (::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0) == 0))
105  	{
106  		reSizeToWH(pTbData->rcFloat);
107  	}
108  	::SetParent(pTbData->hClient, ::GetDlgItem(_hSelf, IDC_CLIENT_TAB));
109  	viewToolbar(pTbData);
110  	_vTbData.push_back(pTbData);
111  	return pTbData;
112  }
113  void DockingCont::removeToolbar(tTbData TbData)
114  {
115  	for (size_t iTb = 0 ; iTb < _vTbData.size(); ++iTb)
116  	{
117  		if (_vTbData[iTb]->hClient == TbData.hClient)
118  		{
119  			removeTab(_vTbData[iTb]);
120  			delete _vTbData[iTb];
121  			vector<tTbData*>::iterator itr = _vTbData.begin() + iTb;
122  			_vTbData.erase(itr);
123  		}
124  	}
125  }
126  tTbData* DockingCont::findToolbarByWnd(HWND hClient)
127  {
128  	tTbData*	pTbData		= NULL;
129  	for (size_t iTb = 0, len = _vTbData.size(); iTb < len; ++iTb)
130  	{
131  		if (hClient == _vTbData[iTb]->hClient)
132  		{
133  			pTbData = _vTbData[iTb];
134  		}
135  	}
136  	return pTbData;
137  }
138  tTbData* DockingCont::findToolbarByName(TCHAR* pszName)
139  {
140  	tTbData*	pTbData		= NULL;
141  	for (size_t iTb = 0, len = _vTbData.size(); iTb < len; ++iTb)
142  	{
143  		if (lstrcmp(pszName, _vTbData[iTb]->pszName) == 0)
144  		{
145  			pTbData = _vTbData[iTb];
146  		}
147  	}
148  	return pTbData;
149  }
150  void DockingCont::setActiveTb(tTbData* pTbData)
151  {
152  	int iItem = searchPosInTab(pTbData);
153  	setActiveTb(iItem);
154  }
155  void DockingCont::setActiveTb(int iItem)
156  {
157  	if (iItem < ::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0))
158  	{
159  		selectTab(iItem);
160  	}
161  }
162  int DockingCont::getActiveTb()
163  {
164  	return static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETCURSEL, 0, 0));
165  }
166  tTbData* DockingCont::getDataOfActiveTb()
167  {
168  	tTbData*	pTbData	= NULL;
169  	int			iItem	= getActiveTb();
170  	if (iItem != -1)
171  	{
172  		TCITEM	tcItem	= {};
173  		tcItem.mask		= TCIF_PARAM;
174  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
175  		pTbData = (tTbData*)tcItem.lParam;
176  	}
177  	return pTbData;
178  }
179  vector<tTbData*> DockingCont::getDataOfVisTb()
180  {
181  	vector<tTbData*> vTbData;
182  	TCITEM tcItem = {};
183  	int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
184  	tcItem.mask	= TCIF_PARAM;
185  	for (int iItem = 0; iItem < iItemCnt; ++iItem)
186  	{
187  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
188  		vTbData.push_back((tTbData*)tcItem.lParam);
189  	}
190  	return vTbData;
191  }
192  bool DockingCont::isTbVis(tTbData* data)
193  {
194  	TCITEM tcItem = {};
195  	int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
196  	tcItem.mask	= TCIF_PARAM;
197  	for (int iItem = 0; iItem < iItemCnt; ++iItem)
198  	{
199  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
200  		if (!tcItem.lParam)
201  			return false;
202  		if (((tTbData*)tcItem.lParam) == data)
203  			return true;
204  	}
205  	return false;
206  }
207  LRESULT DockingCont::runProcCaption(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
208  {
209  	static ToolTip	toolTip;
210  	switch (Message)
211  	{
212  		case WM_ERASEBKGND:
213  		{
214  			if (!NppDarkMode::isEnabled())
215  			{
216  				break;
217  			}
218  			RECT rc{};
219  			::GetClientRect(hwnd, &rc);
220  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
221  			return TRUE;
222  		}
223  		case WM_LBUTTONDOWN:
224  		{
225  			_isMouseDown = TRUE;
226  			if (isInRect(hwnd, LOWORD(lParam), HIWORD(lParam)) == posClose)
227  			{
228  				_isMouseClose	= TRUE;
229  				_isMouseOver	= TRUE;
230  				hWndServer		= _hCaption;
231  				hookMouse = ::SetWindowsHookEx(WH_MOUSE_LL, hookProcMouse, _hInst, 0);
232  				if (!hookMouse)
233  				{
234  					DWORD dwError = ::GetLastError();
235  					TCHAR str[128]{};
236  					::wsprintf(str, TEXT("GetLastError() returned %lu"), dwError);
237  					::MessageBox(NULL, str, TEXT("SetWindowsHookEx(MOUSE) failed on runProcCaption"), MB_OK | MB_ICONERROR);
238  				}
239  				::RedrawWindow(hwnd, nullptr, nullptr, RDW_INVALIDATE);
240  			}
241  			focusClient();
242  			return TRUE;
243  		}
244  		case WM_LBUTTONUP:
245  		{
246  			_isMouseDown = FALSE;
247  			if (_isMouseClose == TRUE)
248  			{
249  				::UnhookWindowsHookEx(hookMouse);
250  				if (_isMouseOver == TRUE)
251  				{
252  					doClose(GetKeyState(VK_SHIFT) < 0);
253  				}
254  				_isMouseClose	= FALSE;
255  				_isMouseOver	= FALSE;
256  			}
257  			focusClient();
258  			return TRUE;
259  		}
260  		case WM_LBUTTONDBLCLK:
261  		{
262  			if (isInRect(hwnd, LOWORD(lParam), HIWORD(lParam)) == posCaption)
263  				::SendMessage(_hParent, DMM_FLOATALL, 0, reinterpret_cast<LPARAM>(this));
264  			focusClient();
265  			return TRUE;
266  		}
267  		case WM_MOUSEMOVE:
268  		{
269  			POINT	pt			= {};
270  			::GetCursorPos(&pt);
271  			::ScreenToClient(_hCaption, &pt);
272  			if (_isMouseDown == TRUE)
273  			{
274  				if (_isMouseClose == FALSE)
275  				{
276  					if ((wParam == MK_LBUTTON) && (isInRect(hwnd, pt.x, pt.y) == posCaption))
277  					{
278  						_dragFromTab = FALSE;
279  						NotifyParent(DMM_MOVE);
280  						_isMouseDown = FALSE;
281  					}
282  					else
283  					{
284  						_isMouseDown = FALSE;
285  					}
286  				}
287  				else
288  				{
289  					BOOL isMouseOver = _isMouseOver;
290  					_isMouseOver = (isInRect(hwnd, pt.x, pt.y) == posClose ? TRUE : FALSE);
291  					if (_isMouseOver != isMouseOver)
292  					{
293  						::SetFocus(NULL);
294  						::RedrawWindow(hwnd, nullptr, nullptr, RDW_INVALIDATE);
295  					}
296  				}
297  			}
298  			else if (_bCapTTHover == FALSE)
299  			{
300  				_hoverMPos = isInRect(hwnd, LOWORD(lParam), HIWORD(lParam));
301  				if ((_bCaptionTT == TRUE) || (_hoverMPos == posClose))
302  				{
303  					TRACKMOUSEEVENT tme{};
304  					tme.cbSize = sizeof(tme);
305  					tme.hwndTrack = hwnd;
306  					tme.dwFlags = TME_LEAVE | TME_HOVER;
307  					tme.dwHoverTime = 1000;
308  					_bCapTTHover = _TrackMouseEvent(&tme);
309  				}
310  			}
311  			else if ((_bCapTTHover == TRUE) &&
312  				(_hoverMPos != isInRect(hwnd, LOWORD(lParam), HIWORD(lParam))))
313  			{
314  				toolTip.destroy();
315  				_bCapTTHover = FALSE;
316  			}
317  			return TRUE;
318  		}
319  		case WM_MOUSEHOVER:
320  		{
321  			RECT	rc	= {};
322  			POINT	pt	= {};
323  			::GetCursorPos(&pt);
324  			toolTip.init(_hInst, hwnd);
325  			if (_hoverMPos == posCaption)
326  			{
327  				toolTip.Show(rc, _pszCaption.c_str(), pt.x, pt.y + 20);
328  			}
329  			else
330  			{
331  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
332  				generic_string tip = pNativeSpeaker->getLocalizedStrFromID("close-panel-tip", TEXT("Close"));
333  				toolTip.Show(rc, tip.c_str(), pt.x, pt.y + 20);
334  			}
335  			return TRUE;
336  		}
337  		case WM_MOUSELEAVE:
338  		{
339  			toolTip.destroy();
340  			_bCapTTHover = FALSE;
341  			return TRUE;
342  		}
343  		case WM_SIZE:
344  		{
345  			::GetWindowRect(hwnd, &_rcCaption);
346  			ScreenRectToClientRect(hwnd, &_rcCaption);
347  			break;
348  		}
349  		case WM_SETTEXT:
350  		{
351  			::RedrawWindow(hwnd, nullptr, nullptr, RDW_INVALIDATE);
352  			return TRUE;
353  		}
354  		default:
355  			break;
356  	}
357  	return ::CallWindowProc(_hDefaultCaptionProc, hwnd, Message, wParam, lParam);
358  }
359  void DockingCont::drawCaptionItem(DRAWITEMSTRUCT *pDrawItemStruct)
360  {
361  	HBRUSH		bgbrush		= NULL;
362  	HFONT		hOldFont	= NULL;
363  	RECT		rc			= pDrawItemStruct->rcItem;
364  	HDC			hDc			= pDrawItemStruct->hDC;
365  	HPEN		hPen		= ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW));
366  	BITMAP		bmp			= {};
367  	HBITMAP		hBmpCur		= NULL;
368  	HBITMAP		hBmpOld 	= NULL;
369  	HBITMAP		hBmpNew		= NULL;
370  	int length = static_cast<int32_t>(_pszCaption.length());
371  	int nSavedDC			= ::SaveDC(hDc);
372  	::SetBkMode(hDc, TRANSPARENT);
373  	auto holdPen = static_cast<HPEN>(::SelectObject(hDc, NppDarkMode::isEnabled() ? NppDarkMode::getEdgePen() : hPen));
374  	if (NppDarkMode::isEnabled())
375  	{
376  		bgbrush = ::CreateSolidBrush(_isActive ? NppDarkMode::getSofterBackgroundColor() : NppDarkMode::getBackgroundColor());
377  		SetTextColor(hDc, NppDarkMode::getTextColor());
378  	}
379  	else
380  	{
381  		if (_isActive == TRUE)
382  		{
383  			bgbrush = ::CreateSolidBrush(::GetSysColor(COLOR_ACTIVECAPTION));
384  			::SetTextColor(hDc, ::GetSysColor(COLOR_CAPTIONTEXT));
385  		}
386  		else
387  		{
388  			bgbrush = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
389  		}
390  	}
391  	if (_isTopCaption == TRUE)
392  	{
393  		if (_isActive == TRUE)
394  		{
395  			::FillRect(hDc, &rc, bgbrush);
396  			rc.right	-= 1;
397  			rc.bottom	-= 1;
398  		}
399  		else
400  		{
401  			rc.right	-= 1;
402  			rc.bottom	-= 1;
403  			::FillRect(hDc, &rc, bgbrush);
404  			MoveToEx(hDc, rc.left , rc.top , NULL);
405  			LineTo  (hDc, rc.right, rc.top );
406  			LineTo  (hDc, rc.right, rc.bottom );
407  			LineTo  (hDc, rc.left , rc.bottom );
408  			LineTo  (hDc, rc.left , rc.top);
409  		}
410  		rc.left		+= 2;
411  		rc.top		+= 1;
412  		rc.right	-= 16;
413  		hOldFont = static_cast<HFONT>(::SelectObject(hDc, _hFontCaption));
414  		::DrawText(hDc, _pszCaption.c_str(), length, &rc, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX);
415  		SIZE	size	= {};
416  		GetTextExtentPoint32(hDc, _pszCaption.c_str(), length, &size);
417  		_bCaptionTT = (((rc.right - rc.left) < size.cx) ? TRUE : FALSE);
418  		::SelectObject(hDc, hOldFont);
419  	}
420  	else
421  	{
422  		HFONT	hFont;
423  		if (_isActive == TRUE)
424  		{
425  			::FillRect(hDc, &rc, bgbrush);
426  			rc.right	-= 1;
427  			rc.bottom	-= 1;
428  		}
429  		else
430  		{
431  			rc.right	-= 1;
432  			rc.bottom	-= 1;
433  			::FillRect(hDc, &rc, bgbrush);
434  			MoveToEx(hDc, rc.left , rc.top , NULL);
435  			LineTo  (hDc, rc.right, rc.top );
436  			LineTo  (hDc, rc.right, rc.bottom );
437  			LineTo  (hDc, rc.left , rc.bottom );
438  			LineTo  (hDc, rc.left , rc.top);
439  		}
440  		rc.left		+= 1;
441  		rc.top += _captionHeightDynamic;
442  		rc.right	= rc.bottom - rc.top;
443  		rc.bottom	+= 14;
444  		LOGFONT lf{ NppParameters::getDefaultGUIFont(NppParameters::DefaultFontType::smcaption) };
445  		lf.lfEscapement = 900;
446  		hFont = ::CreateFontIndirect(&lf);
447  		if (hFont == nullptr)
448  		{
449  			hFont = ::CreateFont(12, 0, 90 * 10, 0,
450  				FW_NORMAL, FALSE, FALSE, FALSE,
451  				ANSI_CHARSET, OUT_DEFAULT_PRECIS,
452  				CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
453  				DEFAULT_PITCH | FF_ROMAN,
454  				TEXT("MS Shell Dlg"));
455  		}
456  		hOldFont = (HFONT)::SelectObject(hDc, hFont);
457  		::DrawText(hDc, _pszCaption.c_str(), length, &rc, DT_BOTTOM | DT_SINGLELINE | DT_END_ELLIPSIS | DT_NOPREFIX);
458  		SIZE	size	= {};
459  		GetTextExtentPoint32(hDc, _pszCaption.c_str(), length, &size);
460  		_bCaptionTT = (((rc.bottom - rc.top) < size.cy) ? TRUE : FALSE);
461  		::SelectObject(hDc, hOldFont);
462  		::DeleteObject(hFont);
463  	}
464  	::SelectObject(hDc, holdPen);
465  	::DeleteObject(hPen);
466  	::DeleteObject(bgbrush);
467  	if (NppDarkMode::isEnabled())
468  	{
469  		if (_hFont == nullptr)
470  		{
471  			LOGFONT lf{ NppParameters::getDefaultGUIFont() };
472  			_hFont = ::CreateFontIndirect(&lf);
473  		}
474  		auto hOld = static_cast<HFONT>(::SelectObject(hDc, _hFont));
475  		rc = pDrawItemStruct->rcItem;
476  		if (_isTopCaption == TRUE)
477  		{
478  			rc.left = rc.right - _closeButtonWidth - _closeButtonPosLeftDynamic;
479  		}
480  		else
481  		{
482  			rc.bottom = rc.top + _closeButtonWidth + _closeButtonPosLeftDynamic; 
483  		}
484  		if ((_isMouseOver == TRUE) && (_isMouseDown == TRUE))
485  		{
486  			::SetTextColor(hDc, RGB(0xFF, 0xFF, 0xFF));
487  		}
488  		::DrawText(hDc, L"✕", 1, &rc, DT_VCENTER | DT_CENTER | DT_SINGLELINE);
489  		::SelectObject(hDc, hOld);
490  	}
491  	else
492  	{
493  		HDC dcMem = ::CreateCompatibleDC(NULL);
494  		if ((_isMouseOver == TRUE) && (_isMouseDown == TRUE))
495  			hBmpCur = (HBITMAP)::LoadImage(_hInst, MAKEINTRESOURCE(IDB_CLOSE_DOWN), IMAGE_BITMAP, _closeButtonWidth, _closeButtonHeight, 0);
496  		else
497  			hBmpCur = (HBITMAP)::LoadImage(_hInst, MAKEINTRESOURCE(IDB_CLOSE_UP), IMAGE_BITMAP, _closeButtonWidth, _closeButtonHeight, 0);
498  		::GetObject(hBmpCur, sizeof(bmp), &bmp);
499  		hBmpOld = (HBITMAP)::SelectObject(dcMem, hBmpCur);
500  		hBmpNew = ::CreateCompatibleBitmap(dcMem, bmp.bmWidth, bmp.bmHeight);
501  		rc = pDrawItemStruct->rcItem;
502  		::SelectObject(hDc, hBmpNew);
503  		if (_isTopCaption == TRUE)
504  			::BitBlt(hDc, rc.right - bmp.bmWidth - _closeButtonPosLeftDynamic, _closeButtonPosTopDynamic, bmp.bmWidth, bmp.bmHeight, dcMem, 0, 0, SRCCOPY);
505  		else
506  			::BitBlt(hDc, _closeButtonPosLeftDynamic, _closeButtonPosLeftDynamic, bmp.bmWidth, bmp.bmHeight, dcMem, 0, 0, SRCCOPY);
507  		::SelectObject(dcMem, hBmpOld);
508  		::DeleteObject(hBmpCur);
509  		::DeleteObject(hBmpNew);
510  		::DeleteDC(dcMem);
511  	}
512  	::RestoreDC(hDc, nSavedDC);
513  }
514  eMousePos DockingCont::isInRect(HWND hwnd, int x, int y)
515  {
516  	RECT		rc;
517  	eMousePos	ret	= posOutside;
518  	::GetWindowRect(hwnd, &rc);
519  	::MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
520  	if (_isTopCaption == TRUE)
521  	{
522  		if ((x > rc.left) && (x < rc.right - _captionHeightDynamic) && (y > rc.top) && (y < rc.bottom))
523  		{
524  			ret = posCaption;
525  		}
526  		else if ((x > rc.right - (_closeButtonWidth + _closeButtonPosLeftDynamic)) && (x < (rc.right - _closeButtonPosLeftDynamic)) &&
527  			(y >(rc.top + _closeButtonPosTopDynamic)) && (y < (rc.bottom - _closeButtonPosTopDynamic)))
528  		{
529  			ret = posClose;
530  		}
531  	}
532  	else
533  	{
534  		if ((x > rc.left) && (x < rc.right) && (y > rc.top + _captionHeightDynamic) && (y < rc.bottom))
535  		{
536  			ret = posCaption;
537  		}
538  		else if ((x > rc.left + _closeButtonPosLeftDynamic) && (x < rc.right - _closeButtonPosLeftDynamic) &&
539  			(y >(rc.top + _closeButtonPosTopDynamic)) && (y < (rc.top + (_closeButtonHeight + _closeButtonPosLeftDynamic))))
540  		{
541  			ret = posClose;
542  		}
543  	}
544  	return ret;
545  }
546  LRESULT DockingCont::runProcTab(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
547  {
548  	static	ToolTip	toolTip;
549  	switch (Message)
550  	{
551  		case WM_ERASEBKGND:
552  		{
553  			if (!NppDarkMode::isEnabled())
554  			{
555  				break;
556  			}
557  			RECT rc{};
558  			::GetClientRect(hwnd, &rc);
559  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
560  			return TRUE;
561  		}
562  		case WM_PAINT:
563  		{
564  			if (!NppDarkMode::isEnabled())
565  			{
566  				break;
567  			}
568  			LONG_PTR dwStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
569  			if (!(dwStyle & TCS_OWNERDRAWFIXED))
570  			{
571  				break;
572  			}
573  			PAINTSTRUCT ps{};
574  			HDC hdc = ::BeginPaint(hwnd, &ps);
575  			::FillRect(hdc, &ps.rcPaint, NppDarkMode::getDarkerBackgroundBrush());
576  			UINT id = ::GetDlgCtrlID(hwnd);
577  			auto holdPen = static_cast<HPEN>(::SelectObject(hdc, NppDarkMode::getEdgePen()));
578  			HRGN holdClip = CreateRectRgn(0, 0, 0, 0);
579  			if (1 != GetClipRgn(hdc, holdClip))
580  			{
581  				DeleteObject(holdClip);
582  				holdClip = nullptr;
583  			}
584  			int nTabs = TabCtrl_GetItemCount(hwnd);
585  			int nFocusTab = TabCtrl_GetCurFocus(hwnd);
586  			int nSelTab = TabCtrl_GetCurSel(hwnd);
587  			for (int i = 0; i < nTabs; ++i)
588  			{
589  				DRAWITEMSTRUCT dis{};
590  				dis.CtlType = ODT_TAB;
591  				dis.CtlID = id;
592  				dis.itemID = static_cast<UINT>(i);
593  				dis.itemAction = ODA_DRAWENTIRE;
594  				dis.itemState = ODS_DEFAULT;
595  				dis.hwndItem = hwnd;
596  				dis.hDC = hdc;
597  				TabCtrl_GetItemRect(hwnd, i, &dis.rcItem);
598  				if (i == nFocusTab)
599  				{
600  					dis.itemState |= ODS_FOCUS;
601  				}
602  				if (i == nSelTab)
603  				{
604  					dis.itemState |= ODS_SELECTED;
605  				}
606  				dis.itemState |= ODS_NOFOCUSRECT; 
607  				RECT rcIntersect = {};
608  				if (IntersectRect(&rcIntersect, &ps.rcPaint, &dis.rcItem))
609  				{
610  					dis.rcItem.top += NppParameters::getInstance()._dpiManager.scaleY(1);
611  					dis.rcItem.right -= 1;
612  					dis.rcItem.bottom += 2;
613  					if (i == 0)
614  					{
615  						POINT edges[] = {
616  							{dis.rcItem.left - 1, dis.rcItem.top},
617  							{dis.rcItem.left - 1, dis.rcItem.bottom}
618  						};
619  						Polyline(hdc, edges, _countof(edges));
620  					}
621  					{
622  						POINT edges[] = {
623  							{dis.rcItem.right, dis.rcItem.top},
624  							{dis.rcItem.right, dis.rcItem.bottom}
625  						};
626  						Polyline(hdc, edges, _countof(edges));
627  					}
628  					HRGN hClip = CreateRectRgnIndirect(&dis.rcItem);
629  					SelectClipRgn(hdc, hClip);
630  					drawTabItem(&dis);
631  					DeleteObject(hClip);
632  					SelectClipRgn(hdc, holdClip);
633  				}
634  			}
635  			SelectClipRgn(hdc, holdClip);
636  			if (holdClip)
637  			{
638  				DeleteObject(holdClip);
639  				holdClip = nullptr;
640  			}
641  			SelectObject(hdc, holdPen);
642  			EndPaint(hwnd, &ps);
643  			return 0;
644  		}
645  		case WM_LBUTTONDOWN:
646  		{
647  			_beginDrag	= TRUE;
648  			return TRUE;
649  		}
650  		case WM_LBUTTONUP:
651  		{
652  			int				iItem	= 0;
653  			TCHITTESTINFO	info	= {};
654  			info.pt.x = LOWORD(lParam);
655  			info.pt.y = HIWORD(lParam);
656  			iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
657  			selectTab(iItem);
658  			_beginDrag = FALSE;
659  			return TRUE;
660  		}
661  		case WM_LBUTTONDBLCLK:
662  		{
663  			NotifyParent((_isFloating == true)?DMM_DOCK:DMM_FLOAT);
664  			return TRUE;
665  		}
666  		case WM_MBUTTONUP:
667  		{
668  			int				iItem	= 0;
669  			TCITEM			tcItem	= {};
670  			TCHITTESTINFO	info	= {};
671  			info.pt.x = LOWORD(lParam);
672  			info.pt.y = HIWORD(lParam);
673  			iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
674  			selectTab(iItem);
675  			tcItem.mask		= TCIF_PARAM;
676  			::SendMessage(hwnd, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
677  			if (!tcItem.lParam)
678  				return FALSE;
679  			if (NotifyParent(DMM_CLOSE) == 0)
680  			{
681  				hideToolbar((tTbData*)tcItem.lParam);
682  			}
683  			return TRUE;
684  		}
685  		case WM_MOUSEMOVE:
686  		{
687  			int				iItem	= 0;
688  			TCHITTESTINFO	info	= {};
689  			info.pt.x = LOWORD(lParam);
690  			info.pt.y = HIWORD(lParam);
691  			iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
692  			if ((_beginDrag == TRUE) && (wParam == MK_LBUTTON))
693  			{
694  				selectTab(iItem);
695  				_dragFromTab = TRUE;
696  				NotifyParent(DMM_MOVE);
697  				_beginDrag = FALSE;
698  			}
699  			else
700  			{
701  				int	iItemSel = static_cast<int32_t>(::SendMessage(hwnd, TCM_GETCURSEL, 0, 0));
702  				if ((_bTabTTHover == FALSE) && (iItem != iItemSel))
703  				{
704  					TRACKMOUSEEVENT tme{};
705  					tme.cbSize = sizeof(tme);
706  					tme.hwndTrack = hwnd;
707  					tme.dwFlags = TME_LEAVE | TME_HOVER;
708  					tme.dwHoverTime = 1000;
709  					_bTabTTHover = _TrackMouseEvent(&tme);
710  				}
711  				else
712  				{
713  					if (iItem == iItemSel)
714  					{
715  						toolTip.destroy();
716  						_bTabTTHover = FALSE;
717  					}
718  					else if (iItem != _iLastHovered)
719  					{
720  						TCITEM	tcItem	= {};
721  						RECT	rc		= {};
722  						toolTip.destroy();
723  						::ClientToScreen(hwnd, &info.pt);
724  						tcItem.mask		= TCIF_PARAM;
725  						::SendMessage(hwnd, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
726  						if (!tcItem.lParam)
727  							return FALSE;
728  						toolTip.init(_hInst, hwnd);
729  						toolTip.Show(rc, (reinterpret_cast<tTbData*>(tcItem.lParam))->pszName, info.pt.x, info.pt.y + 20);
730  					}
731  				}
732  				_iLastHovered = iItem;
733  				_beginDrag = FALSE;
734  			}
735  			return TRUE;
736  		}
737  		case WM_MOUSEHOVER:
738  		{
739  			int				iItem	= 0;
740  			TCITEM			tcItem	= {};
741  			RECT			rc		= {};
742  			TCHITTESTINFO	info	= {};
743  			info.pt.x = LOWORD(lParam);
744  			info.pt.y = HIWORD(lParam);
745  			iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
746  			::ClientToScreen(hwnd, &info.pt);
747  			tcItem.mask		= TCIF_PARAM;
748  			::SendMessage(hwnd, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
749  			if (!tcItem.lParam)
750  				return FALSE;
751  			toolTip.init(_hInst, hwnd);
752  			toolTip.Show(rc, ((tTbData*)tcItem.lParam)->pszName, info.pt.x, info.pt.y + 20);
753  			return TRUE;
754  		}
755  		case WM_MOUSELEAVE:
756  		{
757  			toolTip.destroy();
758  			_bTabTTHover = FALSE;
759  			return TRUE;
760  		}
761  		case WM_NOTIFY:
762  		{
763  			LPNMHDR	lpnmhdr = (LPNMHDR)lParam;
764  			if ((lpnmhdr->hwndFrom == _hContTab) && (lpnmhdr->code == TCN_GETOBJECT))
765  			{
766  				int				iItem	= 0;
767  				TCHITTESTINFO	info	= {};
768  				info.pt.x = LOWORD(lParam);
769  				info.pt.y = HIWORD(lParam);
770  				iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
771  				selectTab(iItem);
772  			}
773  			break;
774  		}
775  		case WM_PARENTNOTIFY:
776  		{
777  			switch (LOWORD(wParam))
778  			{
779  				case WM_CREATE:
780  				{
781  					auto hwndUpdown = reinterpret_cast<HWND>(lParam);
782  					if (NppDarkMode::subclassTabUpDownControl(hwndUpdown))
783  					{
784  						_hTabUpdown = hwndUpdown;
785  						return 0;
786  					}
787  					break;
788  				}
789  			}
790  			return 0;
791  		}
792  		default:
793  			break;
794  	}
795  	return ::CallWindowProc(_hDefaultTabProc, hwnd, Message, wParam, lParam);
796  }
797  void DockingCont::drawTabItem(DRAWITEMSTRUCT *pDrawItemStruct)
798  {
799  	TCITEM	tcItem		= {};
800  	RECT	rc			= pDrawItemStruct->rcItem;
801  	int		nTab		= pDrawItemStruct->itemID;
802  	bool	isSelected	= (nTab == getActiveTb());
803  	tcItem.mask = TCIF_PARAM;
804  	::SendMessage(_hContTab, TCM_GETITEM, nTab, reinterpret_cast<LPARAM>(&tcItem));
805  	if (!tcItem.lParam)
806  		return;
807  	const TCHAR *text = reinterpret_cast<tTbData*>(tcItem.lParam)->pszName;
808  	int		length = lstrlen(reinterpret_cast<tTbData*>(tcItem.lParam)->pszName);
<span onclick='openModal()' class='match'>809  	HDC hDc = pDrawItemStruct->hDC;
810  	int nSavedDC = ::SaveDC(hDc);
811  	rc.top += ::GetSystemMetrics(SM_CYEDGE);
</span>812  	::SetBkMode(hDc, TRANSPARENT);
813  	if (NppDarkMode::isEnabled())
814  	{
815  		RECT selectedRect = rc;
816  		selectedRect.top -= 2;
817  		selectedRect.bottom += 2;
818  		if (isSelected)
819  		{
820  			::FillRect(hDc, &selectedRect, NppDarkMode::getSofterBackgroundBrush());
821  		}
822  		else
823  		{
824  			::FillRect(hDc, &selectedRect, NppDarkMode::getBackgroundBrush());
825  		}
826  	}
827  	if (!NppDarkMode::isEnabled() && _bDrawOgLine && isSelected)
828  	{
829  		RECT barRect = rc;
830  		barRect.top += rc.bottom - 4;
831  		HBRUSH hBrush = ::CreateSolidBrush(RGB(250, 170, 60));
832  		::FillRect(hDc, &barRect, hBrush);
833  		::DeleteObject(hBrush);
834  	}
835  	if (((tTbData*)tcItem.lParam)->uMask & DWS_ICONTAB)
836  	{
837  		HIMAGELIST	hImageList	= (HIMAGELIST)::SendMessage(_hParent, DMM_GETIMAGELIST, 0, 0);
838  		int iPosImage = static_cast<int32_t>(::SendMessage(_hParent, DMM_GETICONPOS, 0, reinterpret_cast<LPARAM>(reinterpret_cast<tTbData*>(tcItem.lParam)->hClient)));
839  		if ((hImageList != NULL) && (iPosImage >= 0))
840  		{
841  			IMAGEINFO	info		= {};
842  			RECT &		imageRect	= info.rcImage;
843  			ImageList_GetImageInfo(hImageList, iPosImage, &info);
844  			int darkPaddingX = NppDarkMode::isEnabled() ? 1 : 0;
845  			int darkPaddingY = NppDarkMode::isEnabled() ? 2 : (isSelected ? 1 : 0);
846  			int iconDpiDynamicalX = isSelected ? rc.left + 3
847  				: rc.left + (rc.right - rc.left - imageRect.right + imageRect.left) / 2 + darkPaddingX;
848  			int iconDpiDynamicalY = NppParameters::getInstance()._dpiManager.scaleY(5) + darkPaddingY;
849  			ImageList_Draw(hImageList, iPosImage, hDc, iconDpiDynamicalX, iconDpiDynamicalY, ILD_NORMAL);
850  			if (isSelected)
851  			{
852  				rc.left += imageRect.right - imageRect.left + 5;
853  			}
854  		}
855  	}
856  	if (isSelected)
857  	{
858  		COLORREF _unselectedColor = RGB(0, 0, 0);
859  		::SetTextColor(hDc, NppDarkMode::isEnabled() ? NppDarkMode::getTextColor() : _unselectedColor);
860  		rc.top -= ::GetSystemMetrics(SM_CYEDGE);
861  		::SelectObject(hDc, _hFont);
862  		::DrawText(hDc, text, length, &rc, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX);
863  	}
864  	::RestoreDC(hDc, nSavedDC);
865  }
866  intptr_t CALLBACK DockingCont::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam)
867  {
868  	switch (Message) 
869  	{
870  		case WM_NCACTIVATE:
871  		{
872  			if (static_cast<int>(lParam) != -1)
873  			{
874  				::SendMessage(_hParent, WM_NCACTIVATE, wParam, 0);
875  			}
876  			break;
877  		}
878  		case WM_INITDIALOG:
879  		{
880  			_hContTab = ::GetDlgItem(_hSelf, IDC_TAB_CONT);
881  			_hCaption = ::GetDlgItem(_hSelf, IDC_BTN_CAPTION);
882  			::SetWindowLongPtr(_hCaption, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
883  			_hDefaultCaptionProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hCaption, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(wndCaptionProc)));
884  			::SetWindowLongPtr(_hContTab, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
885  			_hDefaultTabProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hContTab, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(wndTabProc)));
886  			int tabDpiDynamicalMinWidth = NppParameters::getInstance()._dpiManager.scaleX(24);
887  			::SendMessage(_hContTab, TCM_SETMINTABWIDTH, 0, tabDpiDynamicalMinWidth);
888  			return TRUE;
889  		}
890  		case WM_NCCALCSIZE:
891  		case WM_SIZE:
892  		{
893  			onSize();
894  			break;
895  		}
896  		case WM_ERASEBKGND:
897  		{
898  			if (!NppDarkMode::isEnabled())
899  			{
900  				break;
901  			}
902  			RECT rc{};
903  			getClientRect(rc);
904  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
905  			return TRUE;
906  		}
907  		case WM_CTLCOLORDLG:
908  		case WM_CTLCOLORSTATIC:
909  		{
910  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
911  		}
912  		case WM_DRAWITEM :
913  		{
914  			if (reinterpret_cast<DRAWITEMSTRUCT *>(lParam)->CtlID == IDC_TAB_CONT)
915  			{
916  				if (!NppDarkMode::isEnabled())
917  				{
918  					drawTabItem(reinterpret_cast<DRAWITEMSTRUCT*>(lParam));
919  					return TRUE;
920  				}
921  				break;
922  			}
923  			else
924  			{
925  				drawCaptionItem((DRAWITEMSTRUCT *)lParam);
926  				return TRUE;
927  			}
928  			break;
929  		}
930  		case WM_NCLBUTTONDBLCLK :
931  		{
932  			RECT	rcWnd		= {};
933  			RECT	rcClient	= {};
934  			POINT	pt			= {HIWORD(lParam), LOWORD(lParam)};
935  			getWindowRect(rcWnd);
936  			getClientRect(rcClient);
937  			ClientRectToScreenRect(_hSelf, &rcClient);
938  			rcWnd.bottom = rcClient.top;
939  			if ((rcWnd.top  < pt.x) && (rcWnd.bottom > pt.x) &&
940  				(rcWnd.left < pt.y) && (rcWnd.right  > pt.y))
941  			{
942  				NotifyParent(DMM_DOCKALL);
943  				return TRUE;
944  			}
945  			break;
946  		}
947  		case WM_SYSCOMMAND :
948  		{
949  			switch (wParam & 0xfff0)
950  			{
951  				case SC_MOVE:
952  					NotifyParent(DMM_MOVE);
953  					return TRUE;
954  				default: 
955  					break;
956  			}
957  			return FALSE;
958  		}
959  		case WM_COMMAND : 
960  		{
961  			switch (LOWORD(wParam))
962  			{   
963  				case IDCANCEL:
964  					doClose(GetKeyState(VK_SHIFT) < 0);
965  					return TRUE;
966  				default :
967  					break;
968  			}
969  			break;
970  		}
971  		default:
972  			break;
973  	}
974  	return FALSE;
975  }
976  void DockingCont::onSize()
977  {
978  	TCITEM tcItem = {};
979  	RECT rc = {};
980  	RECT rcTemp = {};
981  	UINT iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
982  	UINT iTabOff = 0;
983  	getClientRect(rc);
984  	if (iItemCnt >= 1)
985  	{
986  		int tabDpiDynamicalHeight = NppParameters::getInstance()._dpiManager.scaleY(16) + 8;
987  		if (_isFloating == false)
988  		{
989  			if (_isTopCaption == TRUE)
990  			{
991  				::SetWindowPos(_hCaption, NULL, rc.left, rc.top, rc.right, _captionHeightDynamic, SWP_NOZORDER | SWP_NOACTIVATE);
992  				rc.top += _captionHeightDynamic;
993  				rc.bottom -= _captionHeightDynamic;
994  			}
995  			else
996  			{
997  				::SetWindowPos(_hCaption, NULL, rc.left, rc.top, _captionHeightDynamic, rc.bottom, SWP_NOZORDER | SWP_NOACTIVATE);
998  				rc.left += _captionHeightDynamic;
999  				rc.right -= _captionHeightDynamic;
1000  			}
1001  			if (iItemCnt >= 2)
1002  			{
1003  				rcTemp = rc;
1004  				rcTemp.top = (rcTemp.bottom + rcTemp.top) - (tabDpiDynamicalHeight + _captionGapDynamic);
1005  				rcTemp.bottom	= tabDpiDynamicalHeight;
1006  				iTabOff			= tabDpiDynamicalHeight;
1007  				::SetWindowPos(_hContTab, NULL,
1008  								rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom, 
1009  								SWP_NOZORDER | SWP_SHOWWINDOW |  SWP_NOACTIVATE);
1010  				if (_hTabUpdown != nullptr)
1011  				{
1012  					::InvalidateRect(_hTabUpdown, nullptr, TRUE);
1013  					::UpdateWindow(_hTabUpdown);
1014  				}
1015  			}
1016  			rcTemp = rc;
1017  			if (_isTopCaption == TRUE)
1018  			{
1019  				rcTemp.top += _captionGapDynamic;
1020  				rcTemp.bottom -= (iTabOff + _captionGapDynamic);
1021  			}
1022  			else
1023  			{
1024  				rcTemp.left += _captionGapDynamic;
1025  				rcTemp.right -= _captionGapDynamic;
1026  				rcTemp.bottom -= iTabOff;
1027  			}
1028  			::SetWindowPos(::GetDlgItem(_hSelf, IDC_CLIENT_TAB), NULL,
1029  							rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom, 
1030  							SWP_NOZORDER | SWP_NOACTIVATE);
1031  		}
1032  		else
1033  		{
1034  			for (size_t iTb = 0, len = _vTbData.size(); iTb < len; ++iTb)
1035  			{
1036  				getWindowRect(_vTbData[iTb]->rcFloat);
1037  			}
1038  			if (iItemCnt >= 2)
1039  			{
1040  				rcTemp = rc;
1041  				rcTemp.top = rcTemp.bottom - (tabDpiDynamicalHeight + _captionGapDynamic);
1042  				rcTemp.bottom = tabDpiDynamicalHeight;
1043  				::SetWindowPos(_hContTab, NULL,
1044  								rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom, 
1045  								SWP_NOZORDER | SWP_SHOWWINDOW);
1046  				if (_hTabUpdown != nullptr)
1047  				{
1048  					::InvalidateRect(_hTabUpdown, nullptr, TRUE);
1049  					::UpdateWindow(_hTabUpdown);
1050  				}
1051  			}
1052  			rcTemp = rc;
1053  			rcTemp.bottom -= ((iItemCnt == 1)?0:tabDpiDynamicalHeight);
1054  			::SetWindowPos(::GetDlgItem(_hSelf, IDC_CLIENT_TAB), NULL,
1055  							rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom, 
1056  							SWP_NOZORDER | SWP_NOACTIVATE);
1057  		}
1058  		size_t iItemCnt2 = static_cast<size_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1059  		for (size_t iItem = 0; iItem < iItemCnt2; ++iItem)
1060  		{
1061  			tcItem.mask		= TCIF_PARAM;
1062  			::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1063  			if (!tcItem.lParam)
1064  				continue;
1065  			::SetWindowPos(((tTbData*)tcItem.lParam)->hClient, NULL,
1066  							0, 0, rcTemp.right, rcTemp.bottom, 
1067  							SWP_NOZORDER);
1068  			NMHDR nmhdr{};
1069  			nmhdr.code		= DMN_FLOATDROPPED;
1070  			nmhdr.hwndFrom	= _hSelf;
1071  			nmhdr.idFrom	= 0;
1072  			::SendMessage(((tTbData*)tcItem.lParam)->hClient, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
1073  		}
1074  	}
1075  }
1076  void DockingCont::doClose(BOOL closeAll)
1077  {
1078  	int	iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1079  	int iItemCur = getActiveTb();
1080  	TCITEM	tcItem	= {};
1081  	tcItem.mask	= TCIF_PARAM;
1082  	::SendMessage(_hContTab, TCM_GETITEM, iItemCur, reinterpret_cast<LPARAM>(&tcItem));
1083  	if (tcItem.lParam)
1084  	{
1085  		if (NotifyParent(DMM_CLOSE) == 0)
1086  		{
1087  			hideToolbar((tTbData*)tcItem.lParam);
1088  		}
1089  	}
1090  	if (closeAll)
1091  	{
1092  		iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1093  		int iItemOff = 0;
1094  		for (int iItem = 0; iItem < iItemCnt; ++iItem)
1095  		{
1096  			TCITEM	tcItem	= {};
1097  			selectTab(iItemOff);
1098  			tcItem.mask	= TCIF_PARAM;
1099  			::SendMessage(_hContTab, TCM_GETITEM, iItemOff, reinterpret_cast<LPARAM>(&tcItem));
1100  			if (!tcItem.lParam)
1101  				continue;
1102  			if (NotifyParent(DMM_CLOSE) == 0)
1103  			{
1104  				hideToolbar((tTbData*)tcItem.lParam);
1105  			}
1106  			else
1107  			{
1108  				++iItemOff;
1109  			}
1110  		}
1111  	}
1112  	iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1113  	if (iItemCnt == 0)
1114  	{
1115  		doDialog(false);
1116  		::SendMessage(_hParent, WM_SIZE, 0, 0);
1117  	}
1118  }
1119  void DockingCont::showToolbar(tTbData* pTbData, BOOL state)
1120  {
1121  	if (state == SW_SHOW)
1122  	{
1123  		viewToolbar(pTbData);
1124  	}
1125  	else
1126  	{
1127  		hideToolbar(pTbData);
1128  	}
1129  }
1130  int DockingCont::hideToolbar(tTbData *pTbData, BOOL hideClient)
1131  {
1132  	int iItem = searchPosInTab(pTbData);
1133  	BOOL hadFocus = ::IsChild (pTbData->hClient, ::GetFocus());
1134  	if (TRUE == ::SendMessage(_hContTab, TCM_DELETEITEM, iItem, 0))
1135  	{
1136  		auto iItemCnt = ::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0);
1137  		if (iItemCnt != 0)
1138  		{
1139  			if (iItem == iItemCnt)
1140  			{
1141  				iItem--;
1142  			}
1143  			_prevItem = iItem;
1144  			selectTab(iItem);
1145  			if (iItemCnt == 1)
1146  			{
1147  				::ShowWindow(_hContTab, SW_HIDE);
1148  			}
1149  		}
1150  		else 
1151  		{
1152  			doDialog(false);
1153  			if (!_isFloating)
1154  			{
1155  				::SendMessage(_hParent, WM_SIZE, 0, 0);
1156  			}
1157  			if (hadFocus)
1158  				::PostMessage(::GetParent(_hParent), WM_ACTIVATE, WA_ACTIVE, 0);
1159  		}
1160  		if (hideClient == TRUE)
1161  		{
1162  			::ShowWindow(pTbData->hClient, SW_HIDE);
1163  		}
1164  	}
1165  	onSize();
1166  	return iItem;
1167  }
1168  void DockingCont::viewToolbar(tTbData *pTbData)
1169  {
1170  	TCITEM tcItem = {};
1171  	int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1172  	if (iItemCnt > 0)
1173  	{
1174  		UINT	iItem	= getActiveTb();
1175  		tcItem.mask		= TCIF_PARAM;
1176  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1177  		if (!tcItem.lParam)
1178  			return;
1179  		::ShowWindow(((tTbData*)tcItem.lParam)->hClient, SW_HIDE);
1180  	}
1181  	int iTabPos = searchPosInTab(pTbData);
1182  	tcItem.mask			= TCIF_PARAM;
1183  	tcItem.lParam = reinterpret_cast<LPARAM>(pTbData);
1184  	if (iTabPos == -1)
1185  	{
1186  		::SendMessage(_hContTab, TCM_INSERTITEM, iItemCnt, reinterpret_cast<LPARAM>(&tcItem));
1187  		selectTab(iItemCnt);
1188  	}
1189  	else
1190  	{
1191  		::SendMessage(_hContTab, TCM_SETITEM, iTabPos, reinterpret_cast<LPARAM>(&tcItem));
1192  		selectTab(iTabPos);
1193  	}
1194  	if (isVisible() == false)
1195  	{
1196  		doDialog();
1197  		::SendMessage(_hParent, WM_SIZE, 0, 0);
1198  	}
1199  	onSize();
1200  }
1201  int DockingCont::searchPosInTab(tTbData* pTbData)
1202  {
1203  	TCITEM tcItem = {};
1204  	int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1205  	tcItem.mask	= TCIF_PARAM;
1206  	for (int iItem = 0; iItem < iItemCnt; ++iItem)
1207  	{
1208  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1209  		if (!tcItem.lParam)
1210  			continue;
1211  		if (((tTbData*)tcItem.lParam)->hClient == pTbData->hClient)
1212  			return iItem;
1213  	}
1214  	return -1;
1215  }
1216  void DockingCont::selectTab(int iTab)
1217  {
1218  	if (iTab != -1)
1219  	{
1220  		const TCHAR	*pszMaxTxt	= NULL;
1221  		TCITEM tcItem = {};
1222  		SIZE size = {};
1223  		int maxWidth = 0;
1224  		int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1225  		tcItem.mask		= TCIF_PARAM;
1226  		::SendMessage(_hContTab, TCM_GETITEM, iTab, reinterpret_cast<LPARAM>(&tcItem));
1227  		if (!tcItem.lParam)
1228  			return;
1229  		::ShowWindow(((tTbData*)tcItem.lParam)->hClient, SW_SHOW);
1230  		::SetFocus(((tTbData*)tcItem.lParam)->hClient);
1231  		NMHDR nmhdr{};
1232  		nmhdr.code		= DMN_SWITCHIN;
1233  		nmhdr.hwndFrom	= _hSelf;
1234  		nmhdr.idFrom	= 0;
1235  		::SendMessage(reinterpret_cast<tTbData*>(tcItem.lParam)->hClient, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
1236  		if (static_cast<unsigned int>(iTab) != _prevItem)
1237  		{
1238  			::SendMessage(_hContTab, TCM_GETITEM, _prevItem, reinterpret_cast<LPARAM>(&tcItem));
1239  			if (!tcItem.lParam)
1240  				return;
1241  			::ShowWindow(((tTbData*)tcItem.lParam)->hClient, SW_HIDE);
1242  			NMHDR nmhdr{};
1243  			nmhdr.code		= DMN_SWITCHOFF;
1244  			nmhdr.hwndFrom	= _hSelf;
1245  			nmhdr.idFrom	= 0;
1246  			::SendMessage(((tTbData*)tcItem.lParam)->hClient, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
1247  		}
1248  		HDC		hDc	= ::GetDC(_hContTab);
1249  		SelectObject(hDc, _hFont);
1250  		for (int iItem = 0; iItem < iItemCnt; ++iItem)
1251  		{
1252  			const TCHAR *pszTabTxt = NULL;
1253  			::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1254  			if (!tcItem.lParam)
1255  				continue;
1256  			pszTabTxt = reinterpret_cast<tTbData*>(tcItem.lParam)->pszName;
1257  			GetTextExtentPoint32(hDc, pszTabTxt, lstrlen(pszTabTxt), &size);
1258  			if (maxWidth < size.cx) 
1259  			{
1260  				maxWidth	= size.cx;
1261  				pszMaxTxt	= pszTabTxt;
1262  			}
1263  		}
1264  		::ReleaseDC(_hSelf, hDc);
1265  		tcItem.mask	= TCIF_TEXT;
1266  		for (int iItem = 0; iItem < iItemCnt; ++iItem)
1267  		{
1268  			generic_string szText;
1269  			if (iItem == iTab && pszMaxTxt)
1270  			{
1271  				szText = TEXT("        ");
1272  				szText += pszMaxTxt;
1273  			}
1274  			tcItem.pszText = (TCHAR *)szText.c_str();
1275  			::SendMessage(_hContTab, TCM_SETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1276  		}
1277  		::SendMessage(_hContTab, TCM_SETCURSEL, iTab, 0);
1278  		_prevItem = iTab;
1279  		updateCaption();
1280  		onSize();
1281  	}
1282  }
1283  bool DockingCont::updateCaption()
1284  {
1285  	if (!_hContTab)
1286  		return false;
1287  	TCITEM			tcItem	= {};
1288  	int				iItem	= getActiveTb();
1289  	if (iItem < 0)
1290  		return false;
1291  	tcItem.mask		= TCIF_PARAM;
1292  	::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1293  	if (!tcItem.lParam) return false;
1294  	_pszCaption = ((tTbData*)tcItem.lParam)->pszName;
1295  	if ((((tTbData*)tcItem.lParam)->uMask & DWS_ADDINFO) && 
1296  		(lstrlen(((tTbData*)tcItem.lParam)->pszAddInfo) != 0))
1297  	{
1298  		_pszCaption += TEXT(" - ");
1299  		_pszCaption += ((tTbData*)tcItem.lParam)->pszAddInfo; 
1300  	}
1301  	if (_isFloating == true)
1302  	{
1303  		::SetWindowText(_hSelf, _pszCaption.c_str());
1304  	}
1305  	else
1306  	{
1307  		::SetWindowText(_hCaption, _pszCaption.c_str());
1308  	}
1309  	return true;
1310  }
1311  void DockingCont::focusClient()
1312  {
1313  	TCITEM		tcItem	= {};
1314  	int			iItem	= getActiveTb();	
1315  	if (iItem != -1)
1316  	{
1317  		tcItem.mask		= TCIF_PARAM;
1318  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1319  		if (!tcItem.lParam)
1320  			return;
1321  		tTbData *tbData = (tTbData *)tcItem.lParam;
1322  		if (tbData->pszAddInfo && lstrcmp(tbData->pszAddInfo, DM_NOFOCUSWHILECLICKINGCAPTION) == 0)
1323  			return;
1324  		::SetFocus(tbData->hClient);
1325  	}
1326  }
1327  LPARAM DockingCont::NotifyParent(UINT message)
1328  {
1329  	return ::SendMessage(_hParent, message, 0, reinterpret_cast<LPARAM>(this));
1330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TabBar.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingCont.cpp</div>
                </div>
                <div class="column column_space"><pre><code>849  	HDC hDC = pDrawItemStruct->hDC;
850  	int nSavedDC = ::SaveDC(hDC);
851  	::SetBkMode(hDC, TRANSPARENT);
</pre></code></div>
                <div class="column column_space"><pre><code>809  	HDC hDc = pDrawItemStruct->hDC;
810  	int nSavedDC = ::SaveDC(hDc);
811  	rc.top += ::GetSystemMetrics(SM_CYEDGE);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    