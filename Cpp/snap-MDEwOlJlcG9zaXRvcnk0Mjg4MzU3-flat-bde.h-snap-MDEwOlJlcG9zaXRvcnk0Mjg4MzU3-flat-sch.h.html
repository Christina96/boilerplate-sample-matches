
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.339622641509434%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bde.h</h3>
            <pre><code>1  #ifndef bde_h
2  #define bde_h
3  #include <vcl\Classes.hpp>
4  #include <vcl\Controls.hpp>
5  #include <vcl\StdCtrls.hpp>
6  #include <vcl\DB.hpp>
7  #include <vcl\DBTables.hpp>
8  #include "base.h"
9  ClassTP(TBdeDb, PBdeDb)
10  protected:
11    static int LastDbId;
12    TDatabase *Db;
13    bool Ok;
14    TStr ErrMsg;
15    int GetDbId(){return ++LastDbId;}
16    void ConnDb();
17  public:
18    TBdeDb();
19    virtual ~TBdeDb();
20    TBdeDb(TSIn&){Fail;}
21    static PBdeDb Load(TSIn& SIn){Fail; return NULL;}
22    void Save(TSOut&){Fail;}
23    bool IsOk() const {return Ok;}
24    TStr GetErrMsg() const {return ErrMsg;}
25    TStr GetNm() const {return Db->DatabaseName.c_str();}
26    void Open() const {Db->Open();}
27    void Close() const {Db->Close();}
28  };
29  class TDbfDb: public TBdeDb{
30  public:
31    TDbfDb(const TStr& FPath);
32  };
33  class TPxDb: public TBdeDb{
34  public:
35    TPxDb(const TStr& FPath);
36  };
37  class TAccDb: public TBdeDb{
38  public:
39    TAccDb(const TStr& OdbcDsnNm);
40  };
41  class TIbDb: public TBdeDb{
42  public:
43    TIbDb(const TStr& FNm, const TStr& UsrNm="SYSDBA", const TStr& PwdStr="masterkey");
44  };
45  class TSqlSrvDb: public TBdeDb{
46  public:
47    TSqlSrvDb(const TStr& DbNm, const TStr& UsrNm, const TStr& PwdStr);
48    static PBdeDb New(const TStr& DbNm, const TStr& UsrNm, const TStr& PwdStr){
49      return new TSqlSrvDb(DbNm, UsrNm, PwdStr);}
50    TSqlSrvDb(const TStr& AliasNm);
51    static PBdeDb New(const TStr& AliasNm){
52      return new TSqlSrvDb(AliasNm);}
53  };
54  class TOracleDb: public TBdeDb{
55  public:
56    TOracleDb(
57     const TStr& OdbcDsnNm, const TStr& UsrNm=TStr(), const TStr& PwdStr=TStr());
58  };
59  ClassTP(TBdeQuery, PBdeQuery)
60  private:
61    TQuery* Query;
62    bool Ok;
63    TStr ErrMsg;
64    UndefDefaultCopyAssign(TBdeQuery);
65  public:
66    TBdeQuery(const PBdeDb& BdeDb);
67    static PBdeQuery New(const PBdeDb& BdeDb){
68      return PBdeQuery(new TBdeQuery(BdeDb));}
69    ~TBdeQuery();
70    static PBdeQuery Load(TSIn& SIn){Fail; return NULL;}
71    void Save(TSOut&){Fail;}
72    TQuery* GetQuery(){return Query;}
73    bool IsOk(){return Ok;}
74    TStr GetErrMsg(){return ErrMsg;}
75    void Execute(const TStr& QueryStr);
76    void Select(const TStr& QueryStr);
77    int GetRecs(){return Query->RecordCount;}
78    void First(){Query->First();}
79    void Next(){Query->Next();}
80    bool Eof(){return Query->Eof;}
81    int GetFlds(){
82      return Query->FieldCount;}
83    TStr GetFldNm(const int& FldN){
84      return Query->Fields->Fields[FldN]->FieldName.c_str();}
85    void GetFldNmV(TStrV& FldNmV){
86      int Flds=GetFlds(); FldNmV.Gen(Flds, 0);
87      for (int FldN=0; FldN<Flds; FldN++){FldNmV.Add(GetFldNm(FldN));}}
88    TStr GetValStr(const int& FldN){
89      return Query->Fields->Fields[FldN]->AsString.c_str();}
90    void GetValStrV(TStrV& ValStrV){
91      int Flds=GetFlds(); ValStrV.Gen(Flds, 0);
92      for (int FldN=0; FldN<Flds; FldN++){ValStrV.Add(GetValStr(FldN));}}
93    TStr GetValStr(const TStr& FldNm){
94      return Query->FieldByName(FldNm.CStr())->AsString.c_str();}
95    bool GetValBool(const TStr& FldNm){
96      return Query->FieldByName(FldNm.CStr())->AsInteger!=0;}
97    int GetValInt(const int& FldN){
98      return Query->Fields->Fields[FldN]->AsInteger;}
99    int GetValInt(const TStr& FldNm){
100      return Query->FieldByName(FldNm.CStr())->AsInteger;}
101    double GetValFlt(const TStr& FldNm){
102      return Query->FieldByName(FldNm.CStr())->AsFloat;}
103  };
104  ClassTP(TBdeTable, PBdeTable)
105  private:
106    TTable* Table;
107    UndefDefaultCopyAssign(TBdeTable);
108  public:
109    TBdeTable(const PBdeDb& BdeDb, const TStr& TableNm);
110    static PBdeTable New(const PBdeDb& BdeDb, const TStr& TableNm){
111      return PBdeTable(new TBdeTable(BdeDb, TableNm));}
112    ~TBdeTable();
113    static PBdeTable Load(TSIn& SIn){Fail; return NULL;}
114    void Save(TSOut&){Fail;}
115    TTable* GetTable() const {return Table;}
116    void Open() const {Table->Open();}
117    void Close() const {Table->Close();}
118    void First() const {Table->First();}
<span onclick='openModal()' class='match'>119    void Next() const {Table->Next();}
120    bool Eof() const {return Table->Eof;}
121    int GetRecs() const {return Table->RecordCount;}
122    void Edit() const {Table->Edit();}
</span>123    void Post() const {Table->Post();}
124    int GetFlds() const {
125      return Table->FieldCount;}
126    TStr GetFldNm(const int& FldN) const {
127      return Table->Fields->Fields[FldN]->FieldName.c_str();}
128    TStr GetValStr(const int& FldN) const {
129      return Table->Fields->Fields[FldN]->AsString.c_str();}
130    void PutValStr(const TStr& FldNm, const TStr& FldVal) const {
131      Table->FieldByName(FldNm.CStr())->AsString=FldVal.CStr();}
132    TStr GetValStr(const TStr& FldNm) const {
133      return Table->FieldByName(FldNm.CStr())->AsString.c_str();}
134    bool GetValBool(const TStr& FldNm) const {
135      return Table->FieldByName(FldNm.CStr())->AsInteger!=0;}
136    int GetValInt(const TStr& FldNm) const {
137      return Table->FieldByName(FldNm.CStr())->AsInteger;}
138    double GetValFlt(const TStr& FldNm) const {
139      return Table->FieldByName(FldNm.CStr())->AsFloat;}
140  };
141  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sch.h</h3>
            <pre><code>1  #ifndef Sch_h
2  #define Sch_h
3  #include "base.h"
4  class TSchTask;
5  typedef TPt<TSchTask> PSchTask;
6  class TSchObj;
7  typedef TPt<TSchObj> PSchObj;
8  class TSchDim;
9  typedef TPt<TSchDim> PSchDim;
10  class TSchCal;
11  typedef TPt<TSchCal> PSchCal;
12  class TSchRep;
13  typedef TPt<TSchRep> PSchRep;
14  class TSch;
15  typedef TPt<TSch> PSch;
16  class TSchTask{
17  private:
18    TCRef CRef;
19  private:
20    TInt TaskId;
21    TVec<TStrV> DimObjVV;
22    TSecTm StartTm, EndTm;
23    TBool Forced;
24  public:
25    TSchTask(): TaskId(-1), DimObjVV(), StartTm(), EndTm(), Forced(){}
26    TSchTask(const int& _TaskId, const TVec<TStrV>& _DimObjVV,
27     const TSecTm& _StartTm, const TSecTm& _EndTm, const bool& _Forced);
28    TSchTask(const int& _TaskId, const TStrV& DimObjV,
29     const TSecTm& _StartTm, const TSecTm& _EndTm, const bool& _Forced);
30    ~TSchTask(){}
31    TSchTask(TSIn& SIn):
32      TaskId(SIn), DimObjVV(SIn), StartTm(SIn), EndTm(SIn), Forced(SIn){}
33    void Save(TSOut& SOut){
34      TaskId.Save(SOut); DimObjVV.Save(SOut);
35      StartTm.Save(SOut); EndTm.Save(SOut); Forced.Save(SOut);}
36    TSchTask& operator=(const TSchTask&){Fail; return *this;}
37    int GetTaskId() const {return TaskId;}
38    int GetDims() const {return DimObjVV.Len();}
39    int GetDimObjs(const int& DimN) const {return DimObjVV[DimN].Len();}
40    TStr GetDimObj(const int& DimN, const int& ObjN) const {
41      return DimObjVV[DimN][ObjN];}
42    TStr GetAllDimObjStr(const int& DimN) const;
43    void GetDimObjVV(TVec<TStrV>& _DimObjVV) const {_DimObjVV=DimObjVV;}
<span onclick='openModal()' class='match'>44    TSecTm GetStartTm() const {return StartTm;}
45    TSecTm GetEndTm() const {return EndTm;}
46    int GetTmSecs() const {return TSecTm::GetDSecs(GetStartTm(), GetEndTm());}
47    bool IsForced() const {return Forced;}
</span>48    bool IsTmIn(const TSecTm& Tm) const {
49      return (StartTm<=Tm)&&(Tm<EndTm);}
50    bool IsTmInts(const TSecTm& MnTm, const TSecTm& MxTm) const {
51      IAssert(MnTm<=MxTm); return !((MxTm<StartTm)||(EndTm<=MnTm));}
52    TStr GetStr() const;
53    static bool IsCons(const PSchTask& Task1, const PSchTask& Task2);
54    static PSchTask LoadTxt(TILx& Lx);
55    void SaveTxt(TOLx& Lx) const;
56    friend PSchTask;
57  };
58  typedef TVec<PSchTask> TSchTaskV;
59  class TSchObj{
60  private:
61    TCRef CRef;
62  private:
63    typedef TKeyDat<TSecTm, PSchTask> TTmTaskKd;
64    TStr Nm;
65    TVec<TTmTaskKd> TmTaskKdV;
66    TSchTaskV FrcTaskV;
67  public:
68    TSchObj(): Nm(), TmTaskKdV(), FrcTaskV(){}
69    TSchObj(const TStr& _Nm): Nm(_Nm), TmTaskKdV(), FrcTaskV(){}
70    ~TSchObj(){}
71    TSchObj(TSIn& SIn):
72      Nm(SIn), TmTaskKdV(SIn), FrcTaskV(SIn){}
73    void Save(TSOut& SOut){
74      Nm.Save(SOut); TmTaskKdV.Save(SOut); FrcTaskV.Save(SOut);}
75    TSchObj& operator=(const TSchObj&){Fail; return *this;}
76    TStr GetNm() const {return Nm;}
77    void AddTask(const PSchTask& Task, const bool& OverlapCheckP);
78    void DelTask(const PSchTask& Task);
79    void GetTaskV(TSchTaskV& TaskV);
80    int GetTasks() const;
81    PSchTask GetTask(const int& TaskN) const;
82    bool IsRegTaskAtTm(const TSecTm& Tm, PSchTask& Task) const;
83    bool IsRegTaskInTm(
84     const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const;
85    bool IsFrcTaskInTm(
86     const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const;
87    bool IsTaskInTm(
88     const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const;
89    bool IsTaskOk(const PSchTask& Task, PSchTask& IcTask,
90     const bool& OverlapCheckP) const {
91      if (OverlapCheckP){
92       return (Task->IsForced())||
93        (!IsRegTaskInTm(Task->GetStartTm(), Task->GetEndTm()-1, IcTask));}
94      else {return true;}}
95    bool IsTaskOk(const PSchTask& Task, const bool& OverlapCheckP) const {
96      PSchTask IcTask; return IsTaskOk(Task, IcTask, OverlapCheckP);}
97    static PSchObj LoadTxt(TILx& Lx);
98    void SaveTxt(TOLx& Lx) const;
99    friend PSchObj;
100  };
101  class TSchDim{
102  private:
103    TCRef CRef;
104  private:
105    typedef THash<TStr, PSchObj> TNmToObjH;
106    TInt DimN;
107    TStr Nm;
108    TBool OverlapCheckP;
109    TNmToObjH NmToObjH;
110    TStrStrVH CObjNmToObjNmVH;
111  public:
112    TSchDim():
113      DimN(-1), Nm(), OverlapCheckP(true), NmToObjH(), CObjNmToObjNmVH(){}
114    TSchDim(const int& _DimN, const int& ExpObjs):
115      DimN(_DimN), Nm(), OverlapCheckP(true),
116      NmToObjH(ExpObjs), CObjNmToObjNmVH(ExpObjs){}
117    ~TSchDim(){}
118    TSchDim(TSIn& SIn):
119      DimN(SIn), Nm(SIn), OverlapCheckP(SIn),
120      NmToObjH(SIn), CObjNmToObjNmVH(SIn){}
121    void Save(TSOut& SOut){
122      DimN.Save(SOut); Nm.Save(SOut); OverlapCheckP.Save(SOut);
123      NmToObjH.Save(SOut); CObjNmToObjNmVH.Save(SOut);}
124    TSchDim& operator=(const TSchDim&){Fail; return *this;}
125    int GetDimN() const {return DimN;}
126    void PutNm(const TStr& _Nm){Nm=_Nm;}
127    TStr GetNm() const {return Nm;}
128    bool IsOverlapCheck() const {return OverlapCheckP;}
129    void SetOverlapCheck(const bool& _OverlapCheckP){OverlapCheckP=_OverlapCheckP;}
130    bool IsObj(const TStr& ObjNm) const {
131      return NmToObjH.IsKey(ObjNm);}
132    bool IsObjV(const TStrV& ObjNmV) const {
133      for (int ObjNmN=0; ObjNmN<ObjNmV.Len(); ObjNmN++){
134        if (!IsObj(ObjNmV[ObjNmN])){return false;}}
135      return true;}
136    void AddObj(const TStr& ObjNm);
137    void DelObj(const TStr& ObjNm){
138      IAssert(GetObj(ObjNm)->GetTasks()==0); NmToObjH.DelKey(ObjNm);}
139    PSchObj GetObj(const TStr& ObjNm) const {
140      return NmToObjH.GetDat(ObjNm);}
141    int GetObjs() const {return NmToObjH.Len();}
142    TStrV GetObjNmV() const;
143    void GetObjTaskV(const TStr& ObjNm, TSchTaskV& TaskV) const {
144      GetObj(ObjNm)->GetTaskV(TaskV);}
145    bool IsCObj(const TStr& CObjNm) const {
146      return CObjNmToObjNmVH.IsKey(CObjNm);}
147    int AddCObj(const TStr& CObjNm, const TStrV& ObjNmV);
148    void DelCObj(const TStr& CObjNm){
149      CObjNmToObjNmVH.DelKey(CObjNm);}
150    TStrV GetCObj_ObjNmV(const TStr& CObjNm) const {
151      TStrV ObjNmV=CObjNmToObjNmVH.GetDat(CObjNm); ObjNmV.Sort(); return ObjNmV;}
152    TStrV GetCObjNmV() const {
153      TStrV NmV; CObjNmToObjNmVH.GetKeyV(NmV); return NmV;}
154    TStrV GetAllObjNmV() const {
155      TStrV NmV; NmV.AddV(GetCObjNmV()); NmV.AddV(GetObjNmV()); return NmV;}
156    void GetCObjFromDesc(const TStr& DescStr, TStr& CObjNm, TStrV& ObjNmV) const;
157    TStrV GetAllObjDescV() const;
158    void AddTask(const PSchTask& Task);
159    void DelTask(const PSchTask& Task);
160    bool IsTaskOk(const PSchTask& Task, PSchTask& IcTask) const;
161    bool IsTaskOk(const PSchTask& Task) const {
162      PSchTask IcTask; return IsTaskOk(Task, IcTask);}
163    bool IsTaskInTm(const TStr& ObjNm,
164     const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const;
165    static PSchDim LoadTxt(TILx& Lx);
166    void SaveTxt(TOLx& Lx) const;
167    friend PSchDim;
168  };
169  typedef TVec<PSchDim> TSchDimV;
170  class TSchRep{
171  private:
172    TCRef CRef;
173  private:
174    TSecTmV DayTmV;
175    TSecTmV DtTmV;
176    TVec<TStrV> TaskNmVV;
177  public:
178    TSchRep(){}
179    ~TSchRep(){}
180    TSchRep(TSIn&){Fail;}
181    void Save(TSOut&){Fail;}
182    TSchRep& operator=(const TSchRep&){Fail; return *this;}
183    static PSchRep New(
184     const PSch& Sch, const TStr& DimNm, const TStr& ObjNm, const int& ResMins,
185     const bool& AllTmP, const TSecTm& StartDtTm, const TSecTm& EndDtTm);
186    int GetDayTms() const {return DayTmV.Len();}
187    TStr GetDayTmStr(const int& DayTmN) const {
188      return DayTmV[DayTmN].GetTmMinStr();}
189    int GetDtTms() const {return DtTmV.Len();}
190    TSecTm GetDtTm(const int& DtTmN) const {return DtTmV[DtTmN];}
191    TStr GetDtTmStr(const int& DtTmN) const {return DtTmV[DtTmN].GetDtStr();}
192    TStr GetTaskStr(const int& DtTmN, const int& DayTmN) const {
193      return TaskNmVV[DtTmN][DayTmN];}
194    void SaveHtml(const PSOut& SOut) const;
195    void SaveHtml(const TStr& FNm) const;
196    void SaveTxt(const PSOut& SOut) const;
197    void SaveTxt(const TStr& FNm) const;
198    static void SaveStat(const TStr& FNm, const PSch& Sch);
199    friend PSchRep;
200  };
201  typedef enum {ssUnlim, ssLim, ssWeek} TSchScope;
202  class TSchCal{
203  private:
204    TCRef CRef;
205  private:
206    TInt Scope;
207    TSecTm StartTm, EndTm;
208    TSecTmStrKdV BadDay_DtTmDescStrKdV;
209  public:
210    TSchCal(): Scope(ssUnlim), StartTm(), EndTm(){}
211    static PSchCal New(){return PSchCal(new TSchCal());}
212    ~TSchCal(){}
213    TSchCal(TSIn& SIn):
214      Scope(SIn), StartTm(SIn), EndTm(SIn){}
215    void Save(TSOut& SOut){
216      Scope.Save(SOut); StartTm.Save(SOut); EndTm.Save(SOut);}
217    TSchCal& operator=(const TSchCal&){Fail; return *this;}
218    void PutScope(const TSchScope& Scope,
219     const TSecTm& _StartTm=TSecTm(), const TSecTm& _EndTm=TSecTm());
220    TSchScope GetScope() const {return TSchScope(int(Scope));}
221    TSecTm GetStartTm() const {return StartTm;}
222    TSecTm GetEndTm() const {return EndTm;}
223    void AddBadDay(const TSecTm& DtTm, const TStr& DescStr);
224    void DelBadDay(const TSecTm& DtTm);
225    bool IsBadDay(const TSecTm& DtTm) const;
226    int GetBadDays() const {return BadDay_DtTmDescStrKdV.Len();}
227    TSecTm GetBadDay_DtTm(const int& BadDayN) const {
228      return BadDay_DtTmDescStrKdV[BadDayN].Key;}
229    TStr GetBadDay_DescStr(const int& BadDayN) const {
230      return BadDay_DtTmDescStrKdV[BadDayN].Dat;}
231    static PSchCal LoadTxt(TILx& Lx);
232    void SaveTxt(TOLx& Lx) const;
233    friend PSchCal;
234  };
235  class TSch{
236  private:
237    TCRef CRef;
238  private:
239    typedef THash<TInt, PSchTask> TIdToTaskH;
240    typedef THash<TStr, PSch> TNmToPatH;
241    TStr Nm;
242    PSchCal Cal;
243    TSchDimV DimV;
244    TInt LastTaskId;
245    PSchTask CpbTask;
246    TIdToTaskH IdToTaskH;
247    TNmToPatH NmToPatH;
248    int GetNewTaskId(){return LastTaskId++;}
249  public:
250    TSch():
251      Nm(), Cal(TSchCal::New()),
252      DimV(), LastTaskId(-1), CpbTask(),
253      IdToTaskH(), NmToPatH(){}
254    static PSch New(){return PSch(new TSch());}
255    TSch(const TStr& _Nm, const int& Dims,
256     const int& ExpObjs=100, const int& ExpTasks=1000);
257    static PSch New(const TStr& Nm, const int& Dims){
258      return PSch(new TSch(Nm, Dims));}
259    ~TSch(){}
260    TSch(TSIn& SIn):
261      Nm(SIn), Cal(SIn),
262      DimV(SIn), LastTaskId(SIn), CpbTask(SIn),
263      IdToTaskH(SIn), NmToPatH(SIn){}
264    void Save(TSOut& SOut){
265      Nm.Save(SOut); Cal.Save(SOut);
266      DimV.Save(SOut); LastTaskId.Save(SOut); CpbTask.Save(SOut);
267      IdToTaskH.Save(SOut); NmToPatH.Save(SOut);}
268    TSch& operator=(const TSch&){Fail; return *this;}
269    void PutNm(const TStr& _Nm){Nm=_Nm;}
270    TStr GetNm() const {return Nm;}
271    PSchCal GetCal() const {return Cal;}
272    int GetDims() const {return DimV.Len();}
273    TStr GetDimNm(const int& DimN) const {return DimV[DimN]->GetNm();}
274    TStrV GetDimNmV() const;
275    int GetDimN(const TStr& DimNm) const;
276    void PutDimNm(const int& DimN, const TStr& DimNm) const {
277      DimV[DimN]->PutNm(DimNm);}
278    void PutDimOverlapCheck(const int& DimN, const bool& OverlapCheckP) const {
279      DimV[DimN]->SetOverlapCheck(OverlapCheckP);}
280    bool IsObj(const int& DimN, const TStr& ObjNm) const {
281      return DimV[DimN]->IsObj(ObjNm);}
282    bool IsObjV(const int& DimN, const TStrV& ObjNmV) const {
283      return DimV[DimN]->IsObjV(ObjNmV);}
284    void AddObj(const int& DimN, const TStr& ObjNm) const {
285      DimV[DimN]->AddObj(ObjNm); SyncPatVObj();}
286    void AddObjV(const int& DimN, const TStrV& ObjNmV) const {
287      for (int ObjNmN=0; ObjNmN<ObjNmV.Len(); ObjNmN++){
288        AddObj(DimN, ObjNmV[ObjNmN]);}}
289    void AddObj(const TStr& DimNm, const TStr& ObjNm) const {
290      AddObj(GetDimN(DimNm), ObjNm);}
291    void DelObj(const int& DimN, const TStr& ObjNm);
292    int GetObjs(const int& DimN) const {
293      return DimV[DimN]->GetObjs();}
294    TStrV GetObjNmV(const int& DimN) const {
295      return DimV[DimN]->GetObjNmV();}
296    void GetObjTaskV(const int& DimN, const TStr& ObjNm, TSchTaskV& TaskV) const {
297      DimV[DimN]->GetObjTaskV(ObjNm, TaskV);}
298    bool IsCObj(const int& DimN, const TStr& CObjNm) const {
299      return DimV[DimN]->IsCObj(CObjNm);}
300    int AddCObj(const int& DimN, const TStr& CObjNm, const TStrV& ObjNmV) const {
301      return DimV[DimN]->AddCObj(CObjNm, ObjNmV);}
302    int AddCObj(const TStr& DimNm, const TStr& CObjNm, const TStrV& ObjNmV) const {
303      return AddCObj(GetDimN(DimNm), CObjNm, ObjNmV);}
304    void DelCObj(const int& DimN, const TStr& CObjNm) const {
305      DimV[DimN]->DelCObj(CObjNm);}
306    TStrV GetCObj_ObjNmV(const int& DimN, const TStr& CObjNm) const {
307      return DimV[DimN]->GetCObj_ObjNmV(CObjNm);}
308    TStrV GetCObjNmV(const int& DimN) const {
309      return DimV[DimN]->GetCObjNmV();}
310    TStrV GetAllObjNmV(const int& DimN) const {
311      return DimV[DimN]->GetAllObjNmV();}
312    void GetCObjFromDesc(
313     const int& DimN, const TStr& DescStr, TStr& CObjNm, TStrV& ObjNmV) const {
314      DimV[DimN]->GetCObjFromDesc(DescStr, CObjNm, ObjNmV);}
315    TStrV GetAllObjDescV(const int& DimN) const {
316      return DimV[DimN]->GetAllObjDescV();}
317    bool IsCpbTask(PSchTask& _CpbTask) const {
318      if (CpbTask.Empty()){return false;}
319      else {_CpbTask=CpbTask; return true;}}
320    bool IsCpbTask() const {
321      PSchTask _CpbTask; return IsCpbTask(_CpbTask);}
322    void PutCpbTask(const PSchTask& _CpbTask){
323      CpbTask=_CpbTask;}
324    bool IsOkForAddTask(TStr& MsgStr) const;
325    int AddTask(const PSchTask& Task);
326    int AddTask(
327     const TVec<TStrV>& DimObjVV,
328     const TSecTm& StartTm, const TSecTm& EndTm, const bool& Forced);
329    int AddTask(
330     const TStr& DimObj1, const TStr& DimObj2, const TStr& DimObj3,
331     const TSecTm& StartTm, const TSecTm& EndTm, const bool& Forced);
332    int AddTask(
333     const TStrV& DimObjV,
334     const TSecTm& StartTm, const TSecTm& EndTm, const bool& Forced);
335    int AddTask(
336     const TStrV& DimObjV1, const TStrV& DimObjV2, const TStrV& DimObjV3,
337     const TSecTm& StartTm, const TSecTm& EndTm, const bool& Forced);
338    void DelTask(const int& TaskId);
339    PSchTask GetTask(const int& TaskId) const {return IdToTaskH.GetDat(TaskId);}
340    void GetDayTaskV(const TSecTm& DtTm, TIntV& TaskIdV) const;
341    bool IsTask(const int& TaskId, PSchTask& Task) const;
342    bool IsTaskOk(const PSchTask& Task, TSchTaskV& DimIcTaskV) const;
343    bool IsTaskOk(const PSchTask& Task) const {
344      TSchTaskV DimIcTaskV; return IsTaskOk(Task, DimIcTaskV);}
345    bool IsTaskInTm(const TStr& DimNm, const TStr& ObjNm,
346     const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
347      int DimN=GetDimN(DimNm);
348      return DimV[DimN]->IsTaskInTm(ObjNm, MnTm, MxTm, Task);}
349    bool IsTaskSim(const PSchTask& Task, PSchTask& SimTask) const;
350    bool IsPat(const TStr& PatNm) const {
351      return NmToPatH.IsKey(PatNm);}
352    bool IsPat(const TStr& PatNm, PSch& Pat) const {
353      return NmToPatH.IsKeyGetDat(PatNm, Pat);}
354    PSch AddPat(const TStr& PatNm);
355    void DelPat(const TStr& PatNm){
356      NmToPatH.DelKey(PatNm);}
357    PSch GetPat(const TStr& PatNm) const {
358      return NmToPatH.GetDat(PatNm);}
359    TStrV GetPatNmV() const {
360      TStrV PatNmV; NmToPatH.GetKeyV(PatNmV); return PatNmV;}
361    void SyncPatObj(const TStr& PatNm) const;
362    void SyncPatVObj() const;
363    void ApplyPatAdd(
364     const PSch& Pat, const TSecTm& StartDtTm, const TSecTm& EndDtTm,
365     const bool& TestOnlyP, TStrV& LogStrV);
366    void ApplyPatDel(
367     const PSch& Pat, const TSecTm& StartDtTm, const TSecTm& EndDtTm,
368     const bool& TestOnlyP, TStrV& LogStrV);
369    static PSch LoadTxt(TILx& Lx);
370    static PSch LoadTxt(const TStr& FNm);
371    void SaveTxt(TOLx& Lx) const;
372    void SaveTxt(const TStr& FNm) const;
373    friend PSch;
374  };
375  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bde.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sch.h</div>
                </div>
                <div class="column column_space"><pre><code>119    void Next() const {Table->Next();}
120    bool Eof() const {return Table->Eof;}
121    int GetRecs() const {return Table->RecordCount;}
122    void Edit() const {Table->Edit();}
</pre></code></div>
                <div class="column column_space"><pre><code>44    TSecTm GetStartTm() const {return StartTm;}
45    TSecTm GetEndTm() const {return EndTm;}
46    int GetTmSecs() const {return TSecTm::GetDSecs(GetStartTm(), GetEndTm());}
47    bool IsForced() const {return Forced;}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    