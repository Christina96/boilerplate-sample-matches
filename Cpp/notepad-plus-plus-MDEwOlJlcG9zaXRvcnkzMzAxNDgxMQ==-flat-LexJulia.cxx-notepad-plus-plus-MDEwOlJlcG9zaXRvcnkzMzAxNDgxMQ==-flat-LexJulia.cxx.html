
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexJulia.cxx</h3>
            <pre><code>1  #include <cstdlib>
2  #include <cassert>
3  #include <cstring>
4  #include <string>
5  #include <string_view>
6  #include <vector>
7  #include <map>
8  #include <algorithm>
9  #include <functional>
10  #include "ILexer.h"
11  #include "Scintilla.h"
12  #include "SciLexer.h"
13  #include "StringCopy.h"
14  #include "PropSetSimple.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "Accessor.h"
18  #include "StyleContext.h"
19  #include "CharacterSet.h"
20  #include "CharacterCategory.h"
21  #include "LexerModule.h"
22  #include "OptionSet.h"
23  #include "DefaultLexer.h"
24  using namespace Scintilla;
25  using namespace Lexilla;
26  static const int MAX_JULIA_IDENT_CHARS = 1023;
27  struct OptionsJulia {
28      bool fold;
29      bool foldComment;
30      bool foldCompact;
31      bool foldDocstring;
32      bool foldSyntaxBased;
33      bool highlightTypeannotation;
34      bool highlightLexerror;
35  	OptionsJulia() {
36          fold = true;
37          foldComment = true;
38          foldCompact = false;
39          foldDocstring = true;
40          foldSyntaxBased = true;
41          highlightTypeannotation = false;
42          highlightLexerror = false;
43  	}
44  };
45  const char * const juliaWordLists[] = {
46      "Primary keywords and identifiers",
47      "Built in types",
48      "Other keywords",
49      "Built in functions",
50      0,
51  };
52  struct OptionSetJulia : public OptionSet<OptionsJulia> {
53  	OptionSetJulia() {
54  		DefineProperty("fold", &OptionsJulia::fold);
55  		DefineProperty("fold.compact", &OptionsJulia::foldCompact);
56  		DefineProperty("fold.comment", &OptionsJulia::foldComment);
57  		DefineProperty("fold.julia.docstring", &OptionsJulia::foldDocstring,
58  			"Fold multiline triple-doublequote strings, usually used to document a function or type above the definition.");
59  		DefineProperty("fold.julia.syntax.based", &OptionsJulia::foldSyntaxBased,
60  			"Set this property to 0 to disable syntax based folding.");
61  		DefineProperty("lexer.julia.highlight.typeannotation", &OptionsJulia::highlightTypeannotation,
62  			"This option enables highlighting of the type identifier after `::`.");
63  		DefineProperty("lexer.julia.highlight.lexerror", &OptionsJulia::highlightLexerror,
64  			"This option enables highlighting of syntax error int character or number definition.");
65  		DefineWordListSets(juliaWordLists);
66  	}
67  };
68  LexicalClass juliaLexicalClasses[] = {
69  	0,  "SCE_JULIA_DEFAULT", "default", "White space",
70  	1,  "SCE_JULIA_COMMENT", "comment", "Comment",
71  	2,  "SCE_JULIA_NUMBER", "literal numeric", "Number",
72  	3,  "SCE_JULIA_KEYWORD1", "keyword", "Reserved keywords",
73  	4,  "SCE_JULIA_KEYWORD2", "identifier", "Builtin type names",
74  	5,  "SCE_JULIA_KEYWORD3", "identifier", "Constants",
75  	6,  "SCE_JULIA_CHAR", "literal string character", "Single quoted string",
76  	7,  "SCE_JULIA_OPERATOR", "operator", "Operator",
77  	8,  "SCE_JULIA_BRACKET", "bracket operator", "Bracket operator",
78  	9,  "SCE_JULIA_IDENTIFIER", "identifier", "Identifier",
79  	10, "SCE_JULIA_STRING", "literal string", "Double quoted String",
80  	11, "SCE_JULIA_SYMBOL", "literal string symbol", "Symbol",
81  	12, "SCE_JULIA_MACRO", "macro preprocessor", "Macro",
82  	13, "SCE_JULIA_STRINGINTERP", "literal string interpolated", "String interpolation",
83  	14, "SCE_JULIA_DOCSTRING", "literal string documentation", "Docstring",
84  	15, "SCE_JULIA_STRINGLITERAL", "literal string", "String literal prefix",
85  	16, "SCE_JULIA_COMMAND", "literal string command", "Command",
86  	17, "SCE_JULIA_COMMANDLITERAL", "literal string command", "Command literal prefix",
87  	18, "SCE_JULIA_TYPEANNOT", "identifier type", "Type annotation identifier",
88  	19, "SCE_JULIA_LEXERROR", "lexer error", "Lexing error",
89  	20, "SCE_JULIA_KEYWORD4", "identifier", "Builtin function names",
90  	21, "SCE_JULIA_TYPEOPERATOR", "operator type", "Type annotation operator",
91  };
92  class LexerJulia : public DefaultLexer {
93  	WordList keywords;
94  	WordList identifiers2;
95  	WordList identifiers3;
96  	WordList identifiers4;
97  	OptionsJulia options;
98  	OptionSetJulia osJulia;
99  public:
100  	explicit LexerJulia() :
101  		DefaultLexer("julia", SCLEX_JULIA, juliaLexicalClasses, ELEMENTS(juliaLexicalClasses)) {
102  	}
103  	virtual ~LexerJulia() {
104  	}
105  	void SCI_METHOD Release() override {
106  		delete this;
107  	}
108  	int SCI_METHOD Version() const override {
109  		return lvRelease5;
110  	}
111  	const char * SCI_METHOD PropertyNames() override {
112  		return osJulia.PropertyNames();
113  	}
114  	int SCI_METHOD PropertyType(const char *name) override {
115  		return osJulia.PropertyType(name);
116  	}
117  	const char * SCI_METHOD DescribeProperty(const char *name) override {
118  		return osJulia.DescribeProperty(name);
119  	}
120  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
121  	const char * SCI_METHOD PropertyGet(const char *key) override {
122  		return osJulia.PropertyGet(key);
123  	}
124  	const char * SCI_METHOD DescribeWordListSets() override {
125  		return osJulia.DescribeWordListSets();
126  	}
127  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
128  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
129  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
130  	void * SCI_METHOD PrivateCall(int, void *) override {
131  		return 0;
132  	}
133  	static ILexer5 *LexerFactoryJulia() {
134  		return new LexerJulia();
135  	}
136  };
137  Sci_Position SCI_METHOD LexerJulia::PropertySet(const char *key, const char *val) {
138  	if (osJulia.PropertySet(&options, key, val)) {
139  		return 0;
140  	}
141  	return -1;
142  }
143  Sci_Position SCI_METHOD LexerJulia::WordListSet(int n, const char *wl) {
144  	WordList *wordListN = nullptr;
145  	switch (n) {
146  	case 0:
147  		wordListN = &keywords;
148  		break;
149  	case 1:
150  		wordListN = &identifiers2;
151  		break;
152  	case 2:
153  		wordListN = &identifiers3;
154  		break;
155  	case 3:
156  		wordListN = &identifiers4;
157  		break;
158  	}
159  	Sci_Position firstModification = -1;
160  	if (wordListN) {
161  		WordList wlNew;
162  		wlNew.Set(wl);
163  		if (*wordListN != wlNew) {
164  			wordListN->Set(wl);
165  			firstModification = 0;
166  		}
167  	}
168  	return firstModification;
169  }
170  static inline bool IsJuliaOperator(int ch) {
171      if (ch == '%' || ch == '^' || ch == '&' || ch == '*' ||
172          ch == '-' || ch == '+' || ch == '=' || ch == '|' ||
173          ch == '<' || ch == '>' || ch == '/' || ch == '~' ||
174          ch == '\\' ) {
175          return true;
176      }
177      return false;
178  }
179  static inline bool IsJuliaUnaryOperator (int ch) {
180      if (ch == 0x00ac || ch == 0x221a || ch == 0x221b ||
181          ch == 0x221c || ch == 0x22c6 || ch == 0x00b1 ||
182          ch == 0x2213 ) {
183          return true;
184      }
185      return false;
186  }
187  static inline bool IsJuliaParen (int ch) {
188      if (ch == '(' || ch == ')' || ch == '{' || ch == '}' ||
189          ch == '[' || ch == ']' ) {
190          return true;
191      }
192      return false;
193  }
194  static int is_wc_cat_id_start(uint32_t wc) {
195      const CharacterCategory cat = CategoriseCharacter((int) wc);
196      return (cat == ccLu || cat == ccLl ||
197              cat == ccLt || cat == ccLm ||
198              cat == ccLo || cat == ccNl ||
199              cat == ccSc ||  
200              (cat == ccSo && !(wc >= 0x2190 && wc <= 0x21FF) &&
201               wc != 0xfffc && wc != 0xfffd &&
202               wc != 0x233f &&  
203               wc != 0x00a6) || 
204              (wc >= 0x2140 && wc <= 0x2a1c &&
205               ((wc >= 0x2140 && wc <= 0x2144) || 
206                wc == 0x223f || wc == 0x22be || wc == 0x22bf || 
207                wc == 0x22a4 || wc == 0x22a5 ||   
208                (wc >= 0x2200 && wc <= 0x2233 &&
209                 (wc == 0x2202 || wc == 0x2205 || wc == 0x2206 || 
210                  wc == 0x2207 || wc == 0x220e || wc == 0x220f || 
211                  wc == 0x2200 || wc == 0x2203 || wc == 0x2204 || 
212                  wc == 0x2210 || wc == 0x2211 || 
213                  wc == 0x221e || wc == 0x221f || 
214                  wc >= 0x222b)) || 
215                (wc >= 0x22c0 && wc <= 0x22c3) ||  
216                (wc >= 0x25F8 && wc <= 0x25ff) ||  
217                (wc >= 0x266f &&
218                 (wc == 0x266f || wc == 0x27d8 || wc == 0x27d9 || 
219                  (wc >= 0x27c0 && wc <= 0x27c1) ||  
220                  (wc >= 0x29b0 && wc <= 0x29b4) ||  
221                  (wc >= 0x2a00 && wc <= 0x2a06) ||  
222                  (wc >= 0x2a09 && wc <= 0x2a16) ||  
223                  wc == 0x2a1b || wc == 0x2a1c)))) || 
224              (wc >= 0x1d6c1 && 
225               (wc == 0x1d6c1 || wc == 0x1d6db ||
226                wc == 0x1d6fb || wc == 0x1d715 ||
227                wc == 0x1d735 || wc == 0x1d74f ||
228                wc == 0x1d76f || wc == 0x1d789 ||
229                wc == 0x1d7a9 || wc == 0x1d7c3)) ||
230              (wc >= 0x207a && wc <= 0x207e) ||
231              (wc >= 0x208a && wc <= 0x208e) ||
232              (wc >= 0x2220 && wc <= 0x2222) || 
233              (wc >= 0x299b && wc <= 0x29af) || 
234              wc == 0x2118 || wc == 0x212E || 
235              (wc >= 0x309B && wc <= 0x309C) || 
236              (wc >= 0x1D7CE && wc <= 0x1D7E1)); 
237  }
238  static inline bool IsIdentifierFirstCharacter (int ch) {
239      if (IsASCII(ch)) {
240          return (bool) (isalpha(ch) || ch == '_');
241      }
242      if (ch < 0xA1 || ch > 0x10ffff) {
243          return false;
244      }
245      return is_wc_cat_id_start((uint32_t) ch);
246  }
247  static inline bool IsIdentifierCharacter (int ch) {
248      if (IsASCII(ch)) {
249          return (bool) (isalnum(ch) || ch == '_' || ch == '!');
250      }
251      if (ch < 0xA1 || ch > 0x10ffff) {
252          return false;
253      }
254      if (is_wc_cat_id_start((uint32_t) ch)) {
255          return true;
256      }
257      const CharacterCategory cat = CategoriseCharacter(ch);
258      if (cat == ccMn || cat == ccMc ||
259          cat == ccNd || cat == ccPc ||
260          cat == ccSk || cat == ccMe ||
261          cat == ccNo ||
262          (ch >= 0x2032 && ch <= 0x2037) || (ch == 0x2057)) {
263          return true;
264      }
265      return false;
266  }
267  static const uint32_t opsuffs[] = {
268     0x00b2, 
269     0x00b3, 
270     0x00b9, 
271     0x02b0, 
272     0x02b2, 
273     0x02b3, 
274     0x02b7, 
275     0x02b8, 
276     0x02e1, 
277     0x02e2, 
278     0x02e3, 
279     0x1d2c, 
280     0x1d2e, 
281     0x1d30, 
282     0x1d31, 
283     0x1d33, 
284     0x1d34, 
285     0x1d35, 
286     0x1d36, 
287     0x1d37, 
288     0x1d38, 
289     0x1d39, 
290     0x1d3a, 
291     0x1d3c, 
292     0x1d3e, 
293     0x1d3f, 
294     0x1d40, 
295     0x1d41, 
296     0x1d42, 
297     0x1d43, 
298     0x1d47, 
299     0x1d48, 
300     0x1d49, 
301     0x1d4d, 
302     0x1d4f, 
303     0x1d50, 
304     0x1d52, 
305     0x1d56, 
306     0x1d57, 
307     0x1d58, 
308     0x1d5b, 
309     0x1d5d, 
310     0x1d5e, 
311     0x1d5f, 
312     0x1d60, 
313     0x1d61, 
314     0x1d62, 
315     0x1d63, 
316     0x1d64, 
317     0x1d65, 
318     0x1d66, 
319     0x1d67, 
320     0x1d68, 
321     0x1d69, 
322     0x1d6a, 
323     0x1d9c, 
324     0x1da0, 
325     0x1da5, 
326     0x1da6, 
327     0x1dab, 
328     0x1db0, 
329     0x1db8, 
330     0x1dbb, 
331     0x1dbf, 
332     0x2032, 
333     0x2033, 
334     0x2034, 
335     0x2035, 
336     0x2036, 
337     0x2037, 
338     0x2057, 
339     0x2070, 
340     0x2071, 
341     0x2074, 
342     0x2075, 
343     0x2076, 
344     0x2077, 
345     0x2078, 
346     0x2079, 
347     0x207a, 
348     0x207b, 
349     0x207c, 
350     0x207d, 
351     0x207e, 
352     0x207f, 
353     0x2080, 
354     0x2081, 
355     0x2082, 
356     0x2083, 
357     0x2084, 
358     0x2085, 
359     0x2086, 
360     0x2087, 
361     0x2088, 
362     0x2089, 
363     0x208a, 
364     0x208b, 
365     0x208c, 
366     0x208d, 
367     0x208e, 
368     0x2090, 
369     0x2091, 
370     0x2092, 
371     0x2093, 
372     0x2095, 
373     0x2096, 
374     0x2097, 
375     0x2098, 
376     0x2099, 
377     0x209a, 
378     0x209b, 
379     0x209c, 
380     0x2c7c, 
381     0x2c7d, 
382     0xa71b, 
383     0xa71c, 
384     0xa71d  
385  };
386  static const size_t opsuffs_len = sizeof(opsuffs) / (sizeof(uint32_t));
387  static bool jl_op_suffix_char(uint32_t wc) {
388      if (wc < 0xA1 || wc > 0x10ffff) {
389          return false;
390      }
391      const CharacterCategory cat = CategoriseCharacter((int) wc);
392      if (cat == ccMn || cat == ccMc ||
393          cat == ccMe) {
394          return true;
395      }
396      for (size_t i = 0; i < opsuffs_len; ++i) {
397          if (wc == opsuffs[i]) {
398              return true;
399          }
400      }
401      return false;
402  }
403  static bool never_id_char(uint32_t wc) {
404       const CharacterCategory cat = CategoriseCharacter((int) wc);
405       return (
406            (cat >= ccZs && cat <= ccCs) ||
407            (wc < 0xff &&
408             cat >= ccPd && cat <= ccPo) ||
409            wc == '`' ||
410            (wc >= 0x27e6 && wc <= 0x27ef) ||
411            (wc >= 0x3008 && wc <= 0x3011) ||
412            (wc >= 0x3014 && wc <= 0x301b) ||
413            (wc == 0xff08 || wc == 0xff09) ||
414            (wc == 0xff3b || wc == 0xff3d));
415  }
416  static bool IsOperatorFirstCharacter (int ch) {
417      if (IsASCII(ch)) {
418          if (IsJuliaOperator(ch) ||
419              ch == '!' || ch == '?' ||
420              ch == ':' || ch == ';' ||
421              ch == ',' || ch == '.' ) {
422              return true;
423          }else {
424              return false;
425          }
426      } else if (is_wc_cat_id_start((uint32_t) ch)) {
427          return false;
428      } else if (IsJuliaUnaryOperator(ch) ||
429                 ! never_id_char((uint32_t) ch)) {
430          return true;
431      }
432      return false;
433  }
434  static bool IsOperatorCharacter (int ch) {
435      if (IsOperatorFirstCharacter(ch) ||
436          (!IsASCII(ch) && jl_op_suffix_char((uint32_t) ch)) ) {
437          return true;
438      }
439      return false;
440  }
441  static bool CheckBoundsIndexing(char *str) {
442      if (strcmp("begin", str) == 0 || strcmp("end", str) == 0 ) {
443          return true;
444      }
445      return false;
446  }
447  static int CheckKeywordFoldPoint(char *str) {
448      if (strcmp ("if", str) == 0 ||
449          strcmp ("for", str) == 0 ||
450          strcmp ("while", str) == 0 ||
451          strcmp ("try", str) == 0 ||
452          strcmp ("do", str) == 0 ||
453          strcmp ("begin", str) == 0 ||
454          strcmp ("let", str) == 0 ||
455          strcmp ("baremodule", str) == 0 ||
456          strcmp ("quote", str) == 0 ||
457          strcmp ("module", str) == 0 ||
458          strcmp ("struct", str) == 0 ||
459          strcmp ("type", str) == 0 ||
460          strcmp ("macro", str) == 0 ||
461          strcmp ("function", str) == 0) {
462          return 1;
463      }
464      if (strcmp("end", str) == 0) {
465          return -1;
466      }
467      return 0;
468  }
469  static bool IsNumberExpon(int ch, int base) {
470      if ((base == 10 && (ch == 'e' || ch == 'E' || ch == 'f')) ||
471          (base == 16 && (ch == 'p' || ch == 'P'))) {
472          return true;
473      }
474      return false;
475  }
476  static bool ScanDigits(StyleContext& sc, int base, bool allow_sep) {
477  	bool found = false;
478      for (;;) {
479  		if (IsADigit(sc.chNext, base) || (allow_sep && sc.chNext == '_')) {
480  			found = true;
481              sc.Forward();
482  		} else {
483  			break;
484          }
485  	}
486  	return found;
487  }
488  static inline bool ScanNHexas(StyleContext &sc, int max) {
489      int n = 0;
490      bool error = false;
491      sc.Forward();
492      if (!IsADigit(sc.ch, 16)) {
493          error = true;
494      } else {
495          while (IsADigit(sc.ch, 16) && n < max) {
496              sc.Forward();
497              n++;
498          }
499      }
500      return error;
501  }
502  static void resumeCharacter(StyleContext &sc, bool lexerror) {
503      bool error = false;
504      if (sc.chPrev == '\'' && sc.ch == '\'' && sc.chNext == '\'') {
505          sc.Forward();
506          sc.ForwardSetState(SCE_JULIA_DEFAULT);
507          return;
508      } else if (lexerror && sc.chPrev == '\'' && sc.ch == '\'') {
509          sc.ChangeState(SCE_JULIA_LEXERROR);
510          sc.ForwardSetState(SCE_JULIA_DEFAULT);
511      } else if (sc.ch == '\\') {
512          sc.Forward();
513          if (sc.ch == '\'' || sc.ch == '\\' ) {
514              sc.Forward();
515          } else if (sc.ch == 'n' || sc.ch == 't' || sc.ch == 'a' ||
516                     sc.ch == 'b' || sc.ch == 'e' || sc.ch == 'f' ||
517                     sc.ch == 'r' || sc.ch == 'v' ) {
518              sc.Forward();
519          } else if (sc.ch == 'x') {
520              error |= ScanNHexas(sc, 2);
521          } else if (sc.ch == 'u') {
522              error |= ScanNHexas(sc, 4);
523          } else if (sc.ch == 'U') {
524              error |= ScanNHexas(sc, 8);
525          } else if (IsADigit(sc.ch, 8)) {
526              int n = 1;
527              int max = 3;
528              sc.Forward();
529              while (IsADigit(sc.ch, 8) && n < max) {
530                  sc.Forward();
531                  n++;
532              }
533          }
534          if (lexerror) {
535              if (sc.ch != '\'') {
536                  error = true;
537                  while (sc.ch != '\'' &&
538                         sc.ch != '\r' &&
539                         sc.ch != '\n') {
540                      sc.Forward();
541                  }
542              }
543              if (error) {
544                  sc.ChangeState(SCE_JULIA_LEXERROR);
545                  sc.ForwardSetState(SCE_JULIA_DEFAULT);
546              }
547          }
548      } else if (lexerror) {
549          if (sc.ch < 0x20 || sc.ch > 0x10ffff) {
550              error = true;
551          } else {
552              sc.Forward();
553              if (sc.ch != '\'') {
554                  error = true;
555                  while (sc.ch != '\'' &&
556                         sc.ch != '\r' &&
557                         sc.ch != '\n') {
558                      sc.Forward();
559                  }
560              }
561          }
562          if (error) {
563              sc.ChangeState(SCE_JULIA_LEXERROR);
564              sc.ForwardSetState(SCE_JULIA_DEFAULT);
565          }
566      }
567      if (sc.ch == '\'') {
568          if (sc.chNext == '\'') {
569              sc.Forward();
570          } else {
571              sc.ForwardSetState(SCE_JULIA_DEFAULT);
572          }
573      }
574  }
575  static inline bool IsACharacter(StyleContext &sc) {
576      return (sc.chPrev == '\'' && sc.chNext == '\'');
577  }
578  static void ScanParenInterpolation(StyleContext &sc) {
579      int interp_level = 0;
580      bool allow_paren_string = false;
581      for (; sc.More(); sc.Forward()) {
582          if ( sc.ch == '\"' && sc.chPrev != '\\') {
583              allow_paren_string = !allow_paren_string;
584          } else if ( !allow_paren_string ) {
585              if ( sc.ch == '(' && !IsACharacter(sc) ) {
586                  interp_level ++;
587              } else if ( sc.ch == ')' && !IsACharacter(sc) && interp_level > 0 ) {
588                  interp_level --;
589                  if (interp_level == 0) {
590                      return;
591                  }
592              }
593          }
594      }
595  }
596  static void initNumber (StyleContext &sc, int &base, bool &with_dot) {
597      base = 10;
598      with_dot = false;
599      sc.SetState(SCE_JULIA_NUMBER);
600      if (sc.ch == '0') {
601          if (sc.chNext == 'x') {
602              sc.Forward();
603              base = 16;
604              if (sc.chNext == '.') {
605                  sc.Forward();
606                  with_dot = true;
607              }
608          } else if (sc.chNext == 'o') {
609              sc.Forward();
610              base = 8;
611          } else if (sc.chNext == 'b') {
612              sc.Forward();
613              base = 2;
614          }
615      } else if (sc.ch == '.') {
616          with_dot = true;
617      }
618  }
619  static void resumeStringLike(StyleContext &sc, int quote, bool triple, bool allow_interp, bool full_highlight) {
620      int stylePrev = sc.state;
621      bool checkcurrent = false;
622      if (sc.ch == '\\') {
623          if (sc.chNext == quote || sc.chNext == '\\' || sc.chNext == '$') {
624              sc.Forward();
625          }
626      } else if (allow_interp && sc.ch == '$') {
627          if (sc.chNext == '(') {
628              if (full_highlight) {
629                  sc.SetState(SCE_JULIA_STRINGINTERP);
630              } else {
631                  sc.ForwardSetState(SCE_JULIA_STRINGINTERP);
632              }
633              ScanParenInterpolation(sc);
634              sc.ForwardSetState(stylePrev);
635              checkcurrent = true;
636          } else if (full_highlight && IsIdentifierFirstCharacter(sc.chNext)) {
637              sc.SetState(SCE_JULIA_STRINGINTERP);
638              sc.Forward();
639              sc.Forward();
640              for (; sc.More(); sc.Forward()) {
641                  if (! IsIdentifierCharacter(sc.ch)) {
642                      break;
643                  }
644              }
645              sc.SetState(stylePrev);
646              checkcurrent = true;
647          }
648          if (checkcurrent) {
649              resumeStringLike(sc, quote, triple, allow_interp, full_highlight);
650          }
651      } else if (sc.ch == quote) {
652          if (triple) {
653              if (sc.chNext == quote && sc.GetRelativeCharacter(2) == quote) {
654                  Sci_PositionU nextIndex = sc.currentPos + 2;
655                  while (nextIndex > sc.currentPos && sc.More()) {
656                      sc.Forward();
657                  }
658                  sc.ForwardSetState(SCE_JULIA_DEFAULT);
659              }
660          } else {
661              sc.ForwardSetState(SCE_JULIA_DEFAULT);
662          }
663      }
664  }
665  static void resumeCommand(StyleContext &sc, bool triple, bool allow_interp) {
666      return resumeStringLike(sc, '`', triple, allow_interp, true);
667  }
668  static void resumeString(StyleContext &sc, bool triple, bool allow_interp) {
669      return resumeStringLike(sc, '"', triple, allow_interp, true);
670  }
671  static void resumeNumber (StyleContext &sc, int base, bool &with_dot, bool lexerror) {
672      if (IsNumberExpon(sc.ch, base)) {
673          if (IsADigit(sc.chNext) || sc.chNext == '+' || sc.chNext == '-') {
674              sc.Forward();
675              ScanDigits(sc, 10, false);
676              sc.Forward();
677          }
678          sc.SetState(SCE_JULIA_DEFAULT);
679      } else if (sc.ch == '.' && sc.chNext == '.') {
680          sc.SetState(SCE_JULIA_OPERATOR);
681          sc.Forward();
682          sc.ForwardSetState(SCE_JULIA_DEFAULT);
683      } else if (sc.ch == '.' && !with_dot) {
684          with_dot = true;
685          ScanDigits(sc, base, true);
686      } else if (IsADigit(sc.ch, base) || sc.ch == '_') {
687          ScanDigits(sc, base, true);
688      } else if (IsADigit(sc.ch) && !IsADigit(sc.ch, base)) {
689          if (lexerror) {
690              sc.ChangeState(SCE_JULIA_LEXERROR);
691          }
692          ScanDigits(sc, 10, false);
693          sc.ForwardSetState(SCE_JULIA_DEFAULT);
694      } else {
695          sc.SetState(SCE_JULIA_DEFAULT);
696      }
697  }
698  static void resumeOperator (StyleContext &sc) {
699      if (sc.chNext == ':' && (sc.ch == ':' || sc.ch == '<' ||
700                      (sc.ch == '>' && (sc.chPrev != '-' && sc.chPrev != '=')))) {
701          sc.Forward();
702          sc.ForwardSetState(SCE_JULIA_DEFAULT);
703      } else if (sc.ch == ':') {
704          sc.SetState(SCE_JULIA_DEFAULT);
705      } else if (sc.ch == '\'') {
706          sc.SetState(SCE_JULIA_DEFAULT);
707      } else if ((sc.ch == '.' && sc.chPrev != '.') || IsIdentifierFirstCharacter(sc.ch) ||
708                 (! (sc.chPrev == '.' && IsOperatorFirstCharacter(sc.ch)) &&
709                  ! IsOperatorCharacter(sc.ch)) ) {
710          sc.SetState(SCE_JULIA_DEFAULT);
711      }
712  }
713  void SCI_METHOD LexerJulia::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
714  	PropSetSimple props;
715  	Accessor styler(pAccess, &props);
716  	Sci_Position pos = startPos;
717  	styler.StartAt(pos);
718  	styler.StartSegment(pos);
719      Sci_Position curLine = styler.GetLine(startPos);
720  	int lineState = (curLine > 0) ? styler.GetLineState(curLine-1) : 0;
721      bool transpose = (lineState >> 0) & 0x01;                
722      bool istripledocstring = (lineState >> 1) & 0x01;        
723  	bool triple_backtick = (lineState >> 2) & 0x01;          
724  	bool israwstring = (lineState >> 3) & 0x01;              
725      int indexing_level = (int)((lineState >> 4) & 0x0F);     
726      int list_comprehension = (int)((lineState >> 8) & 0x0F); 
727      int commentDepth = (int)((lineState >> 12) & 0x0F);      
728      int base = 10;
729      bool with_dot = false;
730      StyleContext sc(startPos, length, initStyle, styler);
731      for (; sc.More(); sc.Forward()) {
732          switch (sc.state) {
733              case SCE_JULIA_BRACKET:
734                  sc.SetState(SCE_JULIA_DEFAULT);
735                  break;
736              case SCE_JULIA_OPERATOR:
737                  resumeOperator(sc);
738                  break;
739              case SCE_JULIA_TYPEOPERATOR:
740                  sc.SetState(SCE_JULIA_DEFAULT);
741                  break;
742              case SCE_JULIA_TYPEANNOT:
743                  if (! IsIdentifierCharacter(sc.ch)) {
744                      sc.SetState(SCE_JULIA_DEFAULT);
745                  }
746                  break;
747              case SCE_JULIA_IDENTIFIER:
748                  if (sc.ch == '\"') {
749                      israwstring = true;
750                      sc.ChangeState(SCE_JULIA_STRINGLITERAL);
751                      sc.SetState(SCE_JULIA_DEFAULT);
752                  } else if (sc.ch == '`') {
753                      israwstring = true;
754                      sc.ChangeState(SCE_JULIA_COMMANDLITERAL);
755                      sc.SetState(SCE_JULIA_DEFAULT);
756                  } else if (! IsIdentifierCharacter(sc.ch)) {
757                      char s[MAX_JULIA_IDENT_CHARS + 1];
758                      sc.GetCurrent(s, sizeof(s));
759                      if ( indexing_level > 0 && CheckBoundsIndexing(s)) {
760                          sc.ChangeState(SCE_JULIA_NUMBER);
761                          transpose = false;
762                      } else {
763                          if (keywords.InList(s)) {
764                              sc.ChangeState(SCE_JULIA_KEYWORD1);
765                              transpose = false;
766                          } else if (identifiers2.InList(s)) {
767                              sc.ChangeState(SCE_JULIA_KEYWORD2);
768                              transpose = false;
769                          } else if (identifiers3.InList(s)) {
770                              sc.ChangeState(SCE_JULIA_KEYWORD3);
771                              transpose = false;
772                          } else if (identifiers4.InList(s)) {
773                              sc.ChangeState(SCE_JULIA_KEYWORD4);
774                          }
775                      }
776                      sc.SetState(SCE_JULIA_DEFAULT);
777                  }
778                  break;
779              case SCE_JULIA_NUMBER:
780                  resumeNumber(sc, base, with_dot, options.highlightLexerror);
781                  break;
782              case SCE_JULIA_CHAR:
783                  resumeCharacter(sc, options.highlightLexerror);
784                  break;
785              case SCE_JULIA_DOCSTRING:
786                  resumeString(sc, true, !israwstring);
787                  if (sc.state == SCE_JULIA_DEFAULT && israwstring) {
788                      israwstring = false;
789                  }
790                  break;
791              case SCE_JULIA_STRING:
792                  resumeString(sc, false, !israwstring);
793                  if (sc.state == SCE_JULIA_DEFAULT && israwstring) {
794                      israwstring = false;
795                  }
796                  break;
797              case SCE_JULIA_COMMAND:
798                  resumeCommand(sc, triple_backtick, !israwstring);
799                  break;
800              case SCE_JULIA_MACRO:
801                  if (IsASpace(sc.ch) || ! IsIdentifierCharacter(sc.ch)) {
802                      sc.SetState(SCE_JULIA_DEFAULT);
803                  }
804                  break;
805              case SCE_JULIA_SYMBOL:
806                  if (! IsIdentifierCharacter(sc.ch)) {
807                      sc.SetState(SCE_JULIA_DEFAULT);
808                  }
809                  break;
810              case SCE_JULIA_COMMENT:
811                  if( commentDepth > 0 ) {
812                      if ( sc.ch == '=' && sc.chNext == '#') {
813                          commentDepth --;
814                          sc.Forward();
815                          if (commentDepth == 0) {
816                              sc.ForwardSetState(SCE_JULIA_DEFAULT);
817                          }
818                      } else if( sc.ch == '#' && sc.chNext == '=') {
819                          commentDepth ++;
820                          sc.Forward();
821                      }
822                  } else {
823                      if (sc.atLineEnd || sc.ch == '\r' || sc.ch == '\n') {
824                          sc.SetState(SCE_JULIA_DEFAULT);
825                          transpose = false;
826                      }
827                  }
828                  break;
829          }
830          if (sc.state == SCE_JULIA_DEFAULT) {
831              if (sc.ch == '#') {
832                  sc.SetState(SCE_JULIA_COMMENT);
833                  if(sc.chNext == '=') {
834                      commentDepth ++;
835                      sc.Forward();
836                  }
837              } else if (sc.ch == '!') {
838                  sc.SetState(SCE_JULIA_OPERATOR);
839                  transpose = false;
840              } else if (sc.ch == '\'') {
841                  if (transpose) {
842                      sc.SetState(SCE_JULIA_OPERATOR);
843                  } else {
844                      sc.SetState(SCE_JULIA_CHAR);
845                  }
846              } else if (sc.ch == '\"') {
847                  istripledocstring = (sc.chNext == '\"' && sc.GetRelativeCharacter(2) == '\"');
848                  if (istripledocstring) {
849                      sc.SetState(SCE_JULIA_DOCSTRING);
850                      Sci_PositionU nextIndex = sc.currentPos + 2;
851                      while (nextIndex > sc.currentPos && sc.More()) {
852                          sc.Forward();
853                      }
854                  } else {
855                      sc.SetState(SCE_JULIA_STRING);
856                  }
857              } else if (sc.ch == '`') {
858                  triple_backtick = (sc.chNext == '`' && sc.GetRelativeCharacter(2) == '`');
859                  sc.SetState(SCE_JULIA_COMMAND);
860                  if (triple_backtick) {
861                      Sci_PositionU nextIndex = sc.currentPos + 2;
862                      while (nextIndex > sc.currentPos && sc.More()) {
863                          sc.Forward();
864                      }
865                  }
866              } else if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
867                  initNumber(sc, base, with_dot);
868              } else if (IsIdentifierFirstCharacter(sc.ch)) {
869                  sc.SetState(SCE_JULIA_IDENTIFIER);
870                  transpose = true;
871              } else if (sc.ch == '@') {
872                  sc.SetState(SCE_JULIA_MACRO);
873                  transpose = false;
874              } else if ((sc.ch == ':' || sc.ch == '<' || sc.ch == '>') && sc.chNext == ':') {
875                  sc.SetState(SCE_JULIA_TYPEOPERATOR);
876                  sc.Forward();
877                  if (options.highlightTypeannotation &&
878                      IsIdentifierFirstCharacter(sc.chNext)) {
879                      sc.ForwardSetState(SCE_JULIA_TYPEANNOT);
880                  }
881              } else if (sc.ch == ':') {
882                  if (IsIdentifierFirstCharacter(sc.chNext) &&
883                      ! IsIdentifierCharacter(sc.chPrev) &&
884                      sc.chPrev != ')' && sc.chPrev != ']' ) {
885                      sc.SetState(SCE_JULIA_SYMBOL);
886                  } else {
887                      sc.SetState(SCE_JULIA_OPERATOR);
888                  }
889              } else if (IsJuliaParen(sc.ch)) {
890                  if (sc.ch == '[') {
891                      list_comprehension ++;
892                      indexing_level ++;
893                  } else if (sc.ch == ']' && (indexing_level > 0)) {
894                      list_comprehension --;
895                      indexing_level --;
896                  } else if (sc.ch == '(') {
897                      list_comprehension ++;
898                  } else if (sc.ch == ')' && (list_comprehension > 0)) {
899                      list_comprehension --;
900                  }
901                  if (sc.ch == ')' || sc.ch == ']' || sc.ch == '}') {
902                      transpose = true;
903                  } else {
904                      transpose = false;
905                  }
906                  sc.SetState(SCE_JULIA_BRACKET);
907              } else if (IsOperatorFirstCharacter(sc.ch)) {
908                  transpose = false;
909                  sc.SetState(SCE_JULIA_OPERATOR);
910              } else {
911                  transpose = false;
912              }
913          }
914          if (sc.atLineEnd) {
915              curLine = styler.GetLine(sc.currentPos);
916              lineState = ((transpose ? 1 : 0) << 0) |
917                          ((istripledocstring ? 1 : 0) << 1) |
918                          ((triple_backtick ? 1 : 0) << 2) |
919                          ((israwstring ? 1 : 0) << 3) |
920                          ((indexing_level & 0x0F) << 4) |
921                          ((list_comprehension & 0x0F) << 8) |
922                          ((commentDepth & 0x0F) << 12);
923              styler.SetLineState(curLine, lineState);
924          }
925      }
926      sc.Complete();
927  }
928  void SCI_METHOD LexerJulia::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
929  	if (!options.fold)
930  		return;
931  	LexAccessor styler(pAccess);
932  	Sci_PositionU endPos = startPos + length;
933  	int visibleChars = 0;
934  	Sci_Position lineCurrent = styler.GetLine(startPos);
935  	int levelCurrent = SC_FOLDLEVELBASE;
936      int lineState = 0;
937  	if (lineCurrent > 0) {
938  		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
939          lineState = styler.GetLineState(lineCurrent-1);
940      }
941      int indexing_level = (int)((lineState >> 4) & 0x0F);     
942      int list_comprehension = (int)((lineState >> 8) & 0x0F); 
943  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
944  	int levelNext = levelCurrent;
945  	char chNext = styler[startPos];
946  	int stylePrev = styler.StyleAt(startPos - 1);
947  	int styleNext = styler.StyleAt(startPos);
948  	int style = initStyle;
949      char word[100];
950      int wordlen = 0;
951      for (Sci_PositionU i = startPos; i < endPos; i++) {
952  		char ch = chNext;
953  		chNext = styler.SafeGetCharAt(i + 1);
954  		style = styleNext;
955  		styleNext = styler.StyleAt(i + 1);
956  		bool atEOL = i == (lineStartNext-1);
957          if (options.foldComment && style == SCE_JULIA_COMMENT) {
958              if (ch == '#' && chNext == '=') {
959                  levelNext ++;
960              }
961              if (ch == '=' && chNext == '#' && levelNext > 0) {
962                  levelNext --;
963              }
964          }
965          if (options.foldSyntaxBased) {
966              if (style == SCE_JULIA_BRACKET) {
967                  if (ch == '[') {
968                      list_comprehension ++;
<span onclick='openModal()' class='match'>969                      indexing_level ++;
970                      levelNext ++;
971                  } else if (ch == ']') {
972                      list_comprehension --;
973                      indexing_level --;
974                      levelNext --;
</span>975                  } else if (ch == '(') {
976                      list_comprehension ++;
977                      levelNext ++;
978                  } else if (ch == ')') {
979                      list_comprehension --;
980                      levelNext --;
981                  }
982                  if (indexing_level < 0) {
983                      indexing_level = 0;
984                  }
985                  if (list_comprehension < 0) {
986                      list_comprehension = 0;
987                  }
988              }
989              if (style == SCE_JULIA_KEYWORD1) {
990                  word[wordlen++] = static_cast<char>(ch);
991                  if (wordlen == 100) {  
992                      word[0] = '\0';
993                      wordlen = 1;
994                  }
995                  if (styleNext != SCE_JULIA_KEYWORD1) {
996                      word[wordlen] = '\0';
997                      wordlen = 0;
998                      if (list_comprehension <= 0 && indexing_level <= 0) {
999                          levelNext += CheckKeywordFoldPoint(word);
1000                      }
1001                  }
1002              }
1003          }
1004          if (options.foldDocstring) {
1005              if (stylePrev != SCE_JULIA_DOCSTRING && style == SCE_JULIA_DOCSTRING) {
1006                  levelNext ++;
1007              } else if (style == SCE_JULIA_DOCSTRING && styleNext != SCE_JULIA_DOCSTRING) {
1008                  levelNext --;
1009              }
1010          }
1011          if (levelNext < 0) {
1012              levelNext = 0;
1013          }
1014          if (!IsASpace(ch)) {
1015              visibleChars++;
1016          }
1017          stylePrev = style;
1018          if (atEOL || (i == endPos-1)) {
1019              int levelUse = levelCurrent;
1020              int lev = levelUse | levelNext << 16;
1021              if (visibleChars == 0 && options.foldCompact) {
1022                  lev |= SC_FOLDLEVELWHITEFLAG;
1023              }
1024              if (levelUse < levelNext) {
1025                  lev |= SC_FOLDLEVELHEADERFLAG;
1026              }
1027              if (lev != styler.LevelAt(lineCurrent)) {
1028                  styler.SetLevel(lineCurrent, lev);
1029              }
1030              lineCurrent++;
1031              lineStartNext = styler.LineStart(lineCurrent+1);
1032              levelCurrent = levelNext;
1033              if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length() - 1))) {
1034                  styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
1035              }
1036              visibleChars = 0;
1037          }
1038      }
1039  }
1040  LexerModule lmJulia(SCLEX_JULIA, LexerJulia::LexerFactoryJulia, "julia", juliaWordLists);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexJulia.cxx</h3>
            <pre><code>1  #include <cstdlib>
2  #include <cassert>
3  #include <cstring>
4  #include <string>
5  #include <string_view>
6  #include <vector>
7  #include <map>
8  #include <algorithm>
9  #include <functional>
10  #include "ILexer.h"
11  #include "Scintilla.h"
12  #include "SciLexer.h"
13  #include "StringCopy.h"
14  #include "PropSetSimple.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "Accessor.h"
18  #include "StyleContext.h"
19  #include "CharacterSet.h"
20  #include "CharacterCategory.h"
21  #include "LexerModule.h"
22  #include "OptionSet.h"
23  #include "DefaultLexer.h"
24  using namespace Scintilla;
25  using namespace Lexilla;
26  static const int MAX_JULIA_IDENT_CHARS = 1023;
27  struct OptionsJulia {
28      bool fold;
29      bool foldComment;
30      bool foldCompact;
31      bool foldDocstring;
32      bool foldSyntaxBased;
33      bool highlightTypeannotation;
34      bool highlightLexerror;
35  	OptionsJulia() {
36          fold = true;
37          foldComment = true;
38          foldCompact = false;
39          foldDocstring = true;
40          foldSyntaxBased = true;
41          highlightTypeannotation = false;
42          highlightLexerror = false;
43  	}
44  };
45  const char * const juliaWordLists[] = {
46      "Primary keywords and identifiers",
47      "Built in types",
48      "Other keywords",
49      "Built in functions",
50      0,
51  };
52  struct OptionSetJulia : public OptionSet<OptionsJulia> {
53  	OptionSetJulia() {
54  		DefineProperty("fold", &OptionsJulia::fold);
55  		DefineProperty("fold.compact", &OptionsJulia::foldCompact);
56  		DefineProperty("fold.comment", &OptionsJulia::foldComment);
57  		DefineProperty("fold.julia.docstring", &OptionsJulia::foldDocstring,
58  			"Fold multiline triple-doublequote strings, usually used to document a function or type above the definition.");
59  		DefineProperty("fold.julia.syntax.based", &OptionsJulia::foldSyntaxBased,
60  			"Set this property to 0 to disable syntax based folding.");
61  		DefineProperty("lexer.julia.highlight.typeannotation", &OptionsJulia::highlightTypeannotation,
62  			"This option enables highlighting of the type identifier after `::`.");
63  		DefineProperty("lexer.julia.highlight.lexerror", &OptionsJulia::highlightLexerror,
64  			"This option enables highlighting of syntax error int character or number definition.");
65  		DefineWordListSets(juliaWordLists);
66  	}
67  };
68  LexicalClass juliaLexicalClasses[] = {
69  	0,  "SCE_JULIA_DEFAULT", "default", "White space",
70  	1,  "SCE_JULIA_COMMENT", "comment", "Comment",
71  	2,  "SCE_JULIA_NUMBER", "literal numeric", "Number",
72  	3,  "SCE_JULIA_KEYWORD1", "keyword", "Reserved keywords",
73  	4,  "SCE_JULIA_KEYWORD2", "identifier", "Builtin type names",
74  	5,  "SCE_JULIA_KEYWORD3", "identifier", "Constants",
75  	6,  "SCE_JULIA_CHAR", "literal string character", "Single quoted string",
76  	7,  "SCE_JULIA_OPERATOR", "operator", "Operator",
77  	8,  "SCE_JULIA_BRACKET", "bracket operator", "Bracket operator",
78  	9,  "SCE_JULIA_IDENTIFIER", "identifier", "Identifier",
79  	10, "SCE_JULIA_STRING", "literal string", "Double quoted String",
80  	11, "SCE_JULIA_SYMBOL", "literal string symbol", "Symbol",
81  	12, "SCE_JULIA_MACRO", "macro preprocessor", "Macro",
82  	13, "SCE_JULIA_STRINGINTERP", "literal string interpolated", "String interpolation",
83  	14, "SCE_JULIA_DOCSTRING", "literal string documentation", "Docstring",
84  	15, "SCE_JULIA_STRINGLITERAL", "literal string", "String literal prefix",
85  	16, "SCE_JULIA_COMMAND", "literal string command", "Command",
86  	17, "SCE_JULIA_COMMANDLITERAL", "literal string command", "Command literal prefix",
87  	18, "SCE_JULIA_TYPEANNOT", "identifier type", "Type annotation identifier",
88  	19, "SCE_JULIA_LEXERROR", "lexer error", "Lexing error",
89  	20, "SCE_JULIA_KEYWORD4", "identifier", "Builtin function names",
90  	21, "SCE_JULIA_TYPEOPERATOR", "operator type", "Type annotation operator",
91  };
92  class LexerJulia : public DefaultLexer {
93  	WordList keywords;
94  	WordList identifiers2;
95  	WordList identifiers3;
96  	WordList identifiers4;
97  	OptionsJulia options;
98  	OptionSetJulia osJulia;
99  public:
100  	explicit LexerJulia() :
101  		DefaultLexer("julia", SCLEX_JULIA, juliaLexicalClasses, ELEMENTS(juliaLexicalClasses)) {
102  	}
103  	virtual ~LexerJulia() {
104  	}
105  	void SCI_METHOD Release() override {
106  		delete this;
107  	}
108  	int SCI_METHOD Version() const override {
109  		return lvRelease5;
110  	}
111  	const char * SCI_METHOD PropertyNames() override {
112  		return osJulia.PropertyNames();
113  	}
114  	int SCI_METHOD PropertyType(const char *name) override {
115  		return osJulia.PropertyType(name);
116  	}
117  	const char * SCI_METHOD DescribeProperty(const char *name) override {
118  		return osJulia.DescribeProperty(name);
119  	}
120  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
121  	const char * SCI_METHOD PropertyGet(const char *key) override {
122  		return osJulia.PropertyGet(key);
123  	}
124  	const char * SCI_METHOD DescribeWordListSets() override {
125  		return osJulia.DescribeWordListSets();
126  	}
127  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
128  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
129  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
130  	void * SCI_METHOD PrivateCall(int, void *) override {
131  		return 0;
132  	}
133  	static ILexer5 *LexerFactoryJulia() {
134  		return new LexerJulia();
135  	}
136  };
137  Sci_Position SCI_METHOD LexerJulia::PropertySet(const char *key, const char *val) {
138  	if (osJulia.PropertySet(&options, key, val)) {
139  		return 0;
140  	}
141  	return -1;
142  }
143  Sci_Position SCI_METHOD LexerJulia::WordListSet(int n, const char *wl) {
144  	WordList *wordListN = nullptr;
145  	switch (n) {
146  	case 0:
147  		wordListN = &keywords;
148  		break;
149  	case 1:
150  		wordListN = &identifiers2;
151  		break;
152  	case 2:
153  		wordListN = &identifiers3;
154  		break;
155  	case 3:
156  		wordListN = &identifiers4;
157  		break;
158  	}
159  	Sci_Position firstModification = -1;
160  	if (wordListN) {
161  		WordList wlNew;
162  		wlNew.Set(wl);
163  		if (*wordListN != wlNew) {
164  			wordListN->Set(wl);
165  			firstModification = 0;
166  		}
167  	}
168  	return firstModification;
169  }
170  static inline bool IsJuliaOperator(int ch) {
171      if (ch == '%' || ch == '^' || ch == '&' || ch == '*' ||
172          ch == '-' || ch == '+' || ch == '=' || ch == '|' ||
173          ch == '<' || ch == '>' || ch == '/' || ch == '~' ||
174          ch == '\\' ) {
175          return true;
176      }
177      return false;
178  }
179  static inline bool IsJuliaUnaryOperator (int ch) {
180      if (ch == 0x00ac || ch == 0x221a || ch == 0x221b ||
181          ch == 0x221c || ch == 0x22c6 || ch == 0x00b1 ||
182          ch == 0x2213 ) {
183          return true;
184      }
185      return false;
186  }
187  static inline bool IsJuliaParen (int ch) {
188      if (ch == '(' || ch == ')' || ch == '{' || ch == '}' ||
189          ch == '[' || ch == ']' ) {
190          return true;
191      }
192      return false;
193  }
194  static int is_wc_cat_id_start(uint32_t wc) {
195      const CharacterCategory cat = CategoriseCharacter((int) wc);
196      return (cat == ccLu || cat == ccLl ||
197              cat == ccLt || cat == ccLm ||
198              cat == ccLo || cat == ccNl ||
199              cat == ccSc ||  
200              (cat == ccSo && !(wc >= 0x2190 && wc <= 0x21FF) &&
201               wc != 0xfffc && wc != 0xfffd &&
202               wc != 0x233f &&  
203               wc != 0x00a6) || 
204              (wc >= 0x2140 && wc <= 0x2a1c &&
205               ((wc >= 0x2140 && wc <= 0x2144) || 
206                wc == 0x223f || wc == 0x22be || wc == 0x22bf || 
207                wc == 0x22a4 || wc == 0x22a5 ||   
208                (wc >= 0x2200 && wc <= 0x2233 &&
209                 (wc == 0x2202 || wc == 0x2205 || wc == 0x2206 || 
210                  wc == 0x2207 || wc == 0x220e || wc == 0x220f || 
211                  wc == 0x2200 || wc == 0x2203 || wc == 0x2204 || 
212                  wc == 0x2210 || wc == 0x2211 || 
213                  wc == 0x221e || wc == 0x221f || 
214                  wc >= 0x222b)) || 
215                (wc >= 0x22c0 && wc <= 0x22c3) ||  
216                (wc >= 0x25F8 && wc <= 0x25ff) ||  
217                (wc >= 0x266f &&
218                 (wc == 0x266f || wc == 0x27d8 || wc == 0x27d9 || 
219                  (wc >= 0x27c0 && wc <= 0x27c1) ||  
220                  (wc >= 0x29b0 && wc <= 0x29b4) ||  
221                  (wc >= 0x2a00 && wc <= 0x2a06) ||  
222                  (wc >= 0x2a09 && wc <= 0x2a16) ||  
223                  wc == 0x2a1b || wc == 0x2a1c)))) || 
224              (wc >= 0x1d6c1 && 
225               (wc == 0x1d6c1 || wc == 0x1d6db ||
226                wc == 0x1d6fb || wc == 0x1d715 ||
227                wc == 0x1d735 || wc == 0x1d74f ||
228                wc == 0x1d76f || wc == 0x1d789 ||
229                wc == 0x1d7a9 || wc == 0x1d7c3)) ||
230              (wc >= 0x207a && wc <= 0x207e) ||
231              (wc >= 0x208a && wc <= 0x208e) ||
232              (wc >= 0x2220 && wc <= 0x2222) || 
233              (wc >= 0x299b && wc <= 0x29af) || 
234              wc == 0x2118 || wc == 0x212E || 
235              (wc >= 0x309B && wc <= 0x309C) || 
236              (wc >= 0x1D7CE && wc <= 0x1D7E1)); 
237  }
238  static inline bool IsIdentifierFirstCharacter (int ch) {
239      if (IsASCII(ch)) {
240          return (bool) (isalpha(ch) || ch == '_');
241      }
242      if (ch < 0xA1 || ch > 0x10ffff) {
243          return false;
244      }
245      return is_wc_cat_id_start((uint32_t) ch);
246  }
247  static inline bool IsIdentifierCharacter (int ch) {
248      if (IsASCII(ch)) {
249          return (bool) (isalnum(ch) || ch == '_' || ch == '!');
250      }
251      if (ch < 0xA1 || ch > 0x10ffff) {
252          return false;
253      }
254      if (is_wc_cat_id_start((uint32_t) ch)) {
255          return true;
256      }
257      const CharacterCategory cat = CategoriseCharacter(ch);
258      if (cat == ccMn || cat == ccMc ||
259          cat == ccNd || cat == ccPc ||
260          cat == ccSk || cat == ccMe ||
261          cat == ccNo ||
262          (ch >= 0x2032 && ch <= 0x2037) || (ch == 0x2057)) {
263          return true;
264      }
265      return false;
266  }
267  static const uint32_t opsuffs[] = {
268     0x00b2, 
269     0x00b3, 
270     0x00b9, 
271     0x02b0, 
272     0x02b2, 
273     0x02b3, 
274     0x02b7, 
275     0x02b8, 
276     0x02e1, 
277     0x02e2, 
278     0x02e3, 
279     0x1d2c, 
280     0x1d2e, 
281     0x1d30, 
282     0x1d31, 
283     0x1d33, 
284     0x1d34, 
285     0x1d35, 
286     0x1d36, 
287     0x1d37, 
288     0x1d38, 
289     0x1d39, 
290     0x1d3a, 
291     0x1d3c, 
292     0x1d3e, 
293     0x1d3f, 
294     0x1d40, 
295     0x1d41, 
296     0x1d42, 
297     0x1d43, 
298     0x1d47, 
299     0x1d48, 
300     0x1d49, 
301     0x1d4d, 
302     0x1d4f, 
303     0x1d50, 
304     0x1d52, 
305     0x1d56, 
306     0x1d57, 
307     0x1d58, 
308     0x1d5b, 
309     0x1d5d, 
310     0x1d5e, 
311     0x1d5f, 
312     0x1d60, 
313     0x1d61, 
314     0x1d62, 
315     0x1d63, 
316     0x1d64, 
317     0x1d65, 
318     0x1d66, 
319     0x1d67, 
320     0x1d68, 
321     0x1d69, 
322     0x1d6a, 
323     0x1d9c, 
324     0x1da0, 
325     0x1da5, 
326     0x1da6, 
327     0x1dab, 
328     0x1db0, 
329     0x1db8, 
330     0x1dbb, 
331     0x1dbf, 
332     0x2032, 
333     0x2033, 
334     0x2034, 
335     0x2035, 
336     0x2036, 
337     0x2037, 
338     0x2057, 
339     0x2070, 
340     0x2071, 
341     0x2074, 
342     0x2075, 
343     0x2076, 
344     0x2077, 
345     0x2078, 
346     0x2079, 
347     0x207a, 
348     0x207b, 
349     0x207c, 
350     0x207d, 
351     0x207e, 
352     0x207f, 
353     0x2080, 
354     0x2081, 
355     0x2082, 
356     0x2083, 
357     0x2084, 
358     0x2085, 
359     0x2086, 
360     0x2087, 
361     0x2088, 
362     0x2089, 
363     0x208a, 
364     0x208b, 
365     0x208c, 
366     0x208d, 
367     0x208e, 
368     0x2090, 
369     0x2091, 
370     0x2092, 
371     0x2093, 
372     0x2095, 
373     0x2096, 
374     0x2097, 
375     0x2098, 
376     0x2099, 
377     0x209a, 
378     0x209b, 
379     0x209c, 
380     0x2c7c, 
381     0x2c7d, 
382     0xa71b, 
383     0xa71c, 
384     0xa71d  
385  };
386  static const size_t opsuffs_len = sizeof(opsuffs) / (sizeof(uint32_t));
387  static bool jl_op_suffix_char(uint32_t wc) {
388      if (wc < 0xA1 || wc > 0x10ffff) {
389          return false;
390      }
391      const CharacterCategory cat = CategoriseCharacter((int) wc);
392      if (cat == ccMn || cat == ccMc ||
393          cat == ccMe) {
394          return true;
395      }
396      for (size_t i = 0; i < opsuffs_len; ++i) {
397          if (wc == opsuffs[i]) {
398              return true;
399          }
400      }
401      return false;
402  }
403  static bool never_id_char(uint32_t wc) {
404       const CharacterCategory cat = CategoriseCharacter((int) wc);
405       return (
406            (cat >= ccZs && cat <= ccCs) ||
407            (wc < 0xff &&
408             cat >= ccPd && cat <= ccPo) ||
409            wc == '`' ||
410            (wc >= 0x27e6 && wc <= 0x27ef) ||
411            (wc >= 0x3008 && wc <= 0x3011) ||
412            (wc >= 0x3014 && wc <= 0x301b) ||
413            (wc == 0xff08 || wc == 0xff09) ||
414            (wc == 0xff3b || wc == 0xff3d));
415  }
416  static bool IsOperatorFirstCharacter (int ch) {
417      if (IsASCII(ch)) {
418          if (IsJuliaOperator(ch) ||
419              ch == '!' || ch == '?' ||
420              ch == ':' || ch == ';' ||
421              ch == ',' || ch == '.' ) {
422              return true;
423          }else {
424              return false;
425          }
426      } else if (is_wc_cat_id_start((uint32_t) ch)) {
427          return false;
428      } else if (IsJuliaUnaryOperator(ch) ||
429                 ! never_id_char((uint32_t) ch)) {
430          return true;
431      }
432      return false;
433  }
434  static bool IsOperatorCharacter (int ch) {
435      if (IsOperatorFirstCharacter(ch) ||
436          (!IsASCII(ch) && jl_op_suffix_char((uint32_t) ch)) ) {
437          return true;
438      }
439      return false;
440  }
441  static bool CheckBoundsIndexing(char *str) {
442      if (strcmp("begin", str) == 0 || strcmp("end", str) == 0 ) {
443          return true;
444      }
445      return false;
446  }
447  static int CheckKeywordFoldPoint(char *str) {
448      if (strcmp ("if", str) == 0 ||
449          strcmp ("for", str) == 0 ||
450          strcmp ("while", str) == 0 ||
451          strcmp ("try", str) == 0 ||
452          strcmp ("do", str) == 0 ||
453          strcmp ("begin", str) == 0 ||
454          strcmp ("let", str) == 0 ||
455          strcmp ("baremodule", str) == 0 ||
456          strcmp ("quote", str) == 0 ||
457          strcmp ("module", str) == 0 ||
458          strcmp ("struct", str) == 0 ||
459          strcmp ("type", str) == 0 ||
460          strcmp ("macro", str) == 0 ||
461          strcmp ("function", str) == 0) {
462          return 1;
463      }
464      if (strcmp("end", str) == 0) {
465          return -1;
466      }
467      return 0;
468  }
469  static bool IsNumberExpon(int ch, int base) {
470      if ((base == 10 && (ch == 'e' || ch == 'E' || ch == 'f')) ||
471          (base == 16 && (ch == 'p' || ch == 'P'))) {
472          return true;
473      }
474      return false;
475  }
476  static bool ScanDigits(StyleContext& sc, int base, bool allow_sep) {
477  	bool found = false;
478      for (;;) {
479  		if (IsADigit(sc.chNext, base) || (allow_sep && sc.chNext == '_')) {
480  			found = true;
481              sc.Forward();
482  		} else {
483  			break;
484          }
485  	}
486  	return found;
487  }
488  static inline bool ScanNHexas(StyleContext &sc, int max) {
489      int n = 0;
490      bool error = false;
491      sc.Forward();
492      if (!IsADigit(sc.ch, 16)) {
493          error = true;
494      } else {
495          while (IsADigit(sc.ch, 16) && n < max) {
496              sc.Forward();
497              n++;
498          }
499      }
500      return error;
501  }
502  static void resumeCharacter(StyleContext &sc, bool lexerror) {
503      bool error = false;
504      if (sc.chPrev == '\'' && sc.ch == '\'' && sc.chNext == '\'') {
505          sc.Forward();
506          sc.ForwardSetState(SCE_JULIA_DEFAULT);
507          return;
508      } else if (lexerror && sc.chPrev == '\'' && sc.ch == '\'') {
509          sc.ChangeState(SCE_JULIA_LEXERROR);
510          sc.ForwardSetState(SCE_JULIA_DEFAULT);
511      } else if (sc.ch == '\\') {
512          sc.Forward();
513          if (sc.ch == '\'' || sc.ch == '\\' ) {
514              sc.Forward();
515          } else if (sc.ch == 'n' || sc.ch == 't' || sc.ch == 'a' ||
516                     sc.ch == 'b' || sc.ch == 'e' || sc.ch == 'f' ||
517                     sc.ch == 'r' || sc.ch == 'v' ) {
518              sc.Forward();
519          } else if (sc.ch == 'x') {
520              error |= ScanNHexas(sc, 2);
521          } else if (sc.ch == 'u') {
522              error |= ScanNHexas(sc, 4);
523          } else if (sc.ch == 'U') {
524              error |= ScanNHexas(sc, 8);
525          } else if (IsADigit(sc.ch, 8)) {
526              int n = 1;
527              int max = 3;
528              sc.Forward();
529              while (IsADigit(sc.ch, 8) && n < max) {
530                  sc.Forward();
531                  n++;
532              }
533          }
534          if (lexerror) {
535              if (sc.ch != '\'') {
536                  error = true;
537                  while (sc.ch != '\'' &&
538                         sc.ch != '\r' &&
539                         sc.ch != '\n') {
540                      sc.Forward();
541                  }
542              }
543              if (error) {
544                  sc.ChangeState(SCE_JULIA_LEXERROR);
545                  sc.ForwardSetState(SCE_JULIA_DEFAULT);
546              }
547          }
548      } else if (lexerror) {
549          if (sc.ch < 0x20 || sc.ch > 0x10ffff) {
550              error = true;
551          } else {
552              sc.Forward();
553              if (sc.ch != '\'') {
554                  error = true;
555                  while (sc.ch != '\'' &&
556                         sc.ch != '\r' &&
557                         sc.ch != '\n') {
558                      sc.Forward();
559                  }
560              }
561          }
562          if (error) {
563              sc.ChangeState(SCE_JULIA_LEXERROR);
564              sc.ForwardSetState(SCE_JULIA_DEFAULT);
565          }
566      }
567      if (sc.ch == '\'') {
568          if (sc.chNext == '\'') {
569              sc.Forward();
570          } else {
571              sc.ForwardSetState(SCE_JULIA_DEFAULT);
572          }
573      }
574  }
575  static inline bool IsACharacter(StyleContext &sc) {
576      return (sc.chPrev == '\'' && sc.chNext == '\'');
577  }
578  static void ScanParenInterpolation(StyleContext &sc) {
579      int interp_level = 0;
580      bool allow_paren_string = false;
581      for (; sc.More(); sc.Forward()) {
582          if ( sc.ch == '\"' && sc.chPrev != '\\') {
583              allow_paren_string = !allow_paren_string;
584          } else if ( !allow_paren_string ) {
585              if ( sc.ch == '(' && !IsACharacter(sc) ) {
586                  interp_level ++;
587              } else if ( sc.ch == ')' && !IsACharacter(sc) && interp_level > 0 ) {
588                  interp_level --;
589                  if (interp_level == 0) {
590                      return;
591                  }
592              }
593          }
594      }
595  }
596  static void initNumber (StyleContext &sc, int &base, bool &with_dot) {
597      base = 10;
598      with_dot = false;
599      sc.SetState(SCE_JULIA_NUMBER);
600      if (sc.ch == '0') {
601          if (sc.chNext == 'x') {
602              sc.Forward();
603              base = 16;
604              if (sc.chNext == '.') {
605                  sc.Forward();
606                  with_dot = true;
607              }
608          } else if (sc.chNext == 'o') {
609              sc.Forward();
610              base = 8;
611          } else if (sc.chNext == 'b') {
612              sc.Forward();
613              base = 2;
614          }
615      } else if (sc.ch == '.') {
616          with_dot = true;
617      }
618  }
619  static void resumeStringLike(StyleContext &sc, int quote, bool triple, bool allow_interp, bool full_highlight) {
620      int stylePrev = sc.state;
621      bool checkcurrent = false;
622      if (sc.ch == '\\') {
623          if (sc.chNext == quote || sc.chNext == '\\' || sc.chNext == '$') {
624              sc.Forward();
625          }
626      } else if (allow_interp && sc.ch == '$') {
627          if (sc.chNext == '(') {
628              if (full_highlight) {
629                  sc.SetState(SCE_JULIA_STRINGINTERP);
630              } else {
631                  sc.ForwardSetState(SCE_JULIA_STRINGINTERP);
632              }
633              ScanParenInterpolation(sc);
634              sc.ForwardSetState(stylePrev);
635              checkcurrent = true;
636          } else if (full_highlight && IsIdentifierFirstCharacter(sc.chNext)) {
637              sc.SetState(SCE_JULIA_STRINGINTERP);
638              sc.Forward();
639              sc.Forward();
640              for (; sc.More(); sc.Forward()) {
641                  if (! IsIdentifierCharacter(sc.ch)) {
642                      break;
643                  }
644              }
645              sc.SetState(stylePrev);
646              checkcurrent = true;
647          }
648          if (checkcurrent) {
649              resumeStringLike(sc, quote, triple, allow_interp, full_highlight);
650          }
651      } else if (sc.ch == quote) {
652          if (triple) {
653              if (sc.chNext == quote && sc.GetRelativeCharacter(2) == quote) {
654                  Sci_PositionU nextIndex = sc.currentPos + 2;
655                  while (nextIndex > sc.currentPos && sc.More()) {
656                      sc.Forward();
657                  }
658                  sc.ForwardSetState(SCE_JULIA_DEFAULT);
659              }
660          } else {
661              sc.ForwardSetState(SCE_JULIA_DEFAULT);
662          }
663      }
664  }
665  static void resumeCommand(StyleContext &sc, bool triple, bool allow_interp) {
666      return resumeStringLike(sc, '`', triple, allow_interp, true);
667  }
668  static void resumeString(StyleContext &sc, bool triple, bool allow_interp) {
669      return resumeStringLike(sc, '"', triple, allow_interp, true);
670  }
671  static void resumeNumber (StyleContext &sc, int base, bool &with_dot, bool lexerror) {
672      if (IsNumberExpon(sc.ch, base)) {
673          if (IsADigit(sc.chNext) || sc.chNext == '+' || sc.chNext == '-') {
674              sc.Forward();
675              ScanDigits(sc, 10, false);
676              sc.Forward();
677          }
678          sc.SetState(SCE_JULIA_DEFAULT);
679      } else if (sc.ch == '.' && sc.chNext == '.') {
680          sc.SetState(SCE_JULIA_OPERATOR);
681          sc.Forward();
682          sc.ForwardSetState(SCE_JULIA_DEFAULT);
683      } else if (sc.ch == '.' && !with_dot) {
684          with_dot = true;
685          ScanDigits(sc, base, true);
686      } else if (IsADigit(sc.ch, base) || sc.ch == '_') {
687          ScanDigits(sc, base, true);
688      } else if (IsADigit(sc.ch) && !IsADigit(sc.ch, base)) {
689          if (lexerror) {
690              sc.ChangeState(SCE_JULIA_LEXERROR);
691          }
692          ScanDigits(sc, 10, false);
693          sc.ForwardSetState(SCE_JULIA_DEFAULT);
694      } else {
695          sc.SetState(SCE_JULIA_DEFAULT);
696      }
697  }
698  static void resumeOperator (StyleContext &sc) {
699      if (sc.chNext == ':' && (sc.ch == ':' || sc.ch == '<' ||
700                      (sc.ch == '>' && (sc.chPrev != '-' && sc.chPrev != '=')))) {
701          sc.Forward();
702          sc.ForwardSetState(SCE_JULIA_DEFAULT);
703      } else if (sc.ch == ':') {
704          sc.SetState(SCE_JULIA_DEFAULT);
705      } else if (sc.ch == '\'') {
706          sc.SetState(SCE_JULIA_DEFAULT);
707      } else if ((sc.ch == '.' && sc.chPrev != '.') || IsIdentifierFirstCharacter(sc.ch) ||
708                 (! (sc.chPrev == '.' && IsOperatorFirstCharacter(sc.ch)) &&
709                  ! IsOperatorCharacter(sc.ch)) ) {
710          sc.SetState(SCE_JULIA_DEFAULT);
711      }
712  }
713  void SCI_METHOD LexerJulia::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
714  	PropSetSimple props;
715  	Accessor styler(pAccess, &props);
716  	Sci_Position pos = startPos;
717  	styler.StartAt(pos);
718  	styler.StartSegment(pos);
719      Sci_Position curLine = styler.GetLine(startPos);
720  	int lineState = (curLine > 0) ? styler.GetLineState(curLine-1) : 0;
721      bool transpose = (lineState >> 0) & 0x01;                
722      bool istripledocstring = (lineState >> 1) & 0x01;        
723  	bool triple_backtick = (lineState >> 2) & 0x01;          
724  	bool israwstring = (lineState >> 3) & 0x01;              
725      int indexing_level = (int)((lineState >> 4) & 0x0F);     
726      int list_comprehension = (int)((lineState >> 8) & 0x0F); 
727      int commentDepth = (int)((lineState >> 12) & 0x0F);      
728      int base = 10;
729      bool with_dot = false;
730      StyleContext sc(startPos, length, initStyle, styler);
731      for (; sc.More(); sc.Forward()) {
732          switch (sc.state) {
733              case SCE_JULIA_BRACKET:
734                  sc.SetState(SCE_JULIA_DEFAULT);
735                  break;
736              case SCE_JULIA_OPERATOR:
737                  resumeOperator(sc);
738                  break;
739              case SCE_JULIA_TYPEOPERATOR:
740                  sc.SetState(SCE_JULIA_DEFAULT);
741                  break;
742              case SCE_JULIA_TYPEANNOT:
743                  if (! IsIdentifierCharacter(sc.ch)) {
744                      sc.SetState(SCE_JULIA_DEFAULT);
745                  }
746                  break;
747              case SCE_JULIA_IDENTIFIER:
748                  if (sc.ch == '\"') {
749                      israwstring = true;
750                      sc.ChangeState(SCE_JULIA_STRINGLITERAL);
751                      sc.SetState(SCE_JULIA_DEFAULT);
752                  } else if (sc.ch == '`') {
753                      israwstring = true;
754                      sc.ChangeState(SCE_JULIA_COMMANDLITERAL);
755                      sc.SetState(SCE_JULIA_DEFAULT);
756                  } else if (! IsIdentifierCharacter(sc.ch)) {
757                      char s[MAX_JULIA_IDENT_CHARS + 1];
758                      sc.GetCurrent(s, sizeof(s));
759                      if ( indexing_level > 0 && CheckBoundsIndexing(s)) {
760                          sc.ChangeState(SCE_JULIA_NUMBER);
761                          transpose = false;
762                      } else {
763                          if (keywords.InList(s)) {
764                              sc.ChangeState(SCE_JULIA_KEYWORD1);
765                              transpose = false;
766                          } else if (identifiers2.InList(s)) {
767                              sc.ChangeState(SCE_JULIA_KEYWORD2);
768                              transpose = false;
769                          } else if (identifiers3.InList(s)) {
770                              sc.ChangeState(SCE_JULIA_KEYWORD3);
771                              transpose = false;
772                          } else if (identifiers4.InList(s)) {
773                              sc.ChangeState(SCE_JULIA_KEYWORD4);
774                          }
775                      }
776                      sc.SetState(SCE_JULIA_DEFAULT);
777                  }
778                  break;
779              case SCE_JULIA_NUMBER:
780                  resumeNumber(sc, base, with_dot, options.highlightLexerror);
781                  break;
782              case SCE_JULIA_CHAR:
783                  resumeCharacter(sc, options.highlightLexerror);
784                  break;
785              case SCE_JULIA_DOCSTRING:
786                  resumeString(sc, true, !israwstring);
787                  if (sc.state == SCE_JULIA_DEFAULT && israwstring) {
788                      israwstring = false;
789                  }
790                  break;
791              case SCE_JULIA_STRING:
792                  resumeString(sc, false, !israwstring);
793                  if (sc.state == SCE_JULIA_DEFAULT && israwstring) {
794                      israwstring = false;
795                  }
796                  break;
797              case SCE_JULIA_COMMAND:
798                  resumeCommand(sc, triple_backtick, !israwstring);
799                  break;
800              case SCE_JULIA_MACRO:
801                  if (IsASpace(sc.ch) || ! IsIdentifierCharacter(sc.ch)) {
802                      sc.SetState(SCE_JULIA_DEFAULT);
803                  }
804                  break;
805              case SCE_JULIA_SYMBOL:
806                  if (! IsIdentifierCharacter(sc.ch)) {
807                      sc.SetState(SCE_JULIA_DEFAULT);
808                  }
809                  break;
810              case SCE_JULIA_COMMENT:
811                  if( commentDepth > 0 ) {
812                      if ( sc.ch == '=' && sc.chNext == '#') {
813                          commentDepth --;
814                          sc.Forward();
815                          if (commentDepth == 0) {
816                              sc.ForwardSetState(SCE_JULIA_DEFAULT);
817                          }
818                      } else if( sc.ch == '#' && sc.chNext == '=') {
819                          commentDepth ++;
820                          sc.Forward();
821                      }
822                  } else {
823                      if (sc.atLineEnd || sc.ch == '\r' || sc.ch == '\n') {
824                          sc.SetState(SCE_JULIA_DEFAULT);
825                          transpose = false;
826                      }
827                  }
828                  break;
829          }
830          if (sc.state == SCE_JULIA_DEFAULT) {
831              if (sc.ch == '#') {
832                  sc.SetState(SCE_JULIA_COMMENT);
833                  if(sc.chNext == '=') {
834                      commentDepth ++;
835                      sc.Forward();
836                  }
837              } else if (sc.ch == '!') {
838                  sc.SetState(SCE_JULIA_OPERATOR);
839                  transpose = false;
840              } else if (sc.ch == '\'') {
841                  if (transpose) {
842                      sc.SetState(SCE_JULIA_OPERATOR);
843                  } else {
844                      sc.SetState(SCE_JULIA_CHAR);
845                  }
846              } else if (sc.ch == '\"') {
847                  istripledocstring = (sc.chNext == '\"' && sc.GetRelativeCharacter(2) == '\"');
848                  if (istripledocstring) {
849                      sc.SetState(SCE_JULIA_DOCSTRING);
850                      Sci_PositionU nextIndex = sc.currentPos + 2;
851                      while (nextIndex > sc.currentPos && sc.More()) {
852                          sc.Forward();
853                      }
854                  } else {
855                      sc.SetState(SCE_JULIA_STRING);
856                  }
857              } else if (sc.ch == '`') {
858                  triple_backtick = (sc.chNext == '`' && sc.GetRelativeCharacter(2) == '`');
859                  sc.SetState(SCE_JULIA_COMMAND);
860                  if (triple_backtick) {
861                      Sci_PositionU nextIndex = sc.currentPos + 2;
862                      while (nextIndex > sc.currentPos && sc.More()) {
863                          sc.Forward();
864                      }
865                  }
866              } else if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
867                  initNumber(sc, base, with_dot);
868              } else if (IsIdentifierFirstCharacter(sc.ch)) {
869                  sc.SetState(SCE_JULIA_IDENTIFIER);
870                  transpose = true;
871              } else if (sc.ch == '@') {
872                  sc.SetState(SCE_JULIA_MACRO);
873                  transpose = false;
874              } else if ((sc.ch == ':' || sc.ch == '<' || sc.ch == '>') && sc.chNext == ':') {
875                  sc.SetState(SCE_JULIA_TYPEOPERATOR);
876                  sc.Forward();
877                  if (options.highlightTypeannotation &&
878                      IsIdentifierFirstCharacter(sc.chNext)) {
879                      sc.ForwardSetState(SCE_JULIA_TYPEANNOT);
880                  }
881              } else if (sc.ch == ':') {
882                  if (IsIdentifierFirstCharacter(sc.chNext) &&
883                      ! IsIdentifierCharacter(sc.chPrev) &&
884                      sc.chPrev != ')' && sc.chPrev != ']' ) {
885                      sc.SetState(SCE_JULIA_SYMBOL);
886                  } else {
887                      sc.SetState(SCE_JULIA_OPERATOR);
888                  }
889              } else if (IsJuliaParen(sc.ch)) {
890                  if (sc.ch == '[') {
891                      list_comprehension ++;
892                      indexing_level ++;
893                  } else if (sc.ch == ']' && (indexing_level > 0)) {
894                      list_comprehension --;
895                      indexing_level --;
896                  } else if (sc.ch == '(') {
897                      list_comprehension ++;
898                  } else if (sc.ch == ')' && (list_comprehension > 0)) {
899                      list_comprehension --;
900                  }
901                  if (sc.ch == ')' || sc.ch == ']' || sc.ch == '}') {
902                      transpose = true;
903                  } else {
904                      transpose = false;
905                  }
906                  sc.SetState(SCE_JULIA_BRACKET);
907              } else if (IsOperatorFirstCharacter(sc.ch)) {
908                  transpose = false;
909                  sc.SetState(SCE_JULIA_OPERATOR);
910              } else {
911                  transpose = false;
912              }
913          }
914          if (sc.atLineEnd) {
915              curLine = styler.GetLine(sc.currentPos);
916              lineState = ((transpose ? 1 : 0) << 0) |
917                          ((istripledocstring ? 1 : 0) << 1) |
918                          ((triple_backtick ? 1 : 0) << 2) |
919                          ((israwstring ? 1 : 0) << 3) |
920                          ((indexing_level & 0x0F) << 4) |
921                          ((list_comprehension & 0x0F) << 8) |
922                          ((commentDepth & 0x0F) << 12);
923              styler.SetLineState(curLine, lineState);
924          }
925      }
926      sc.Complete();
927  }
928  void SCI_METHOD LexerJulia::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
929  	if (!options.fold)
930  		return;
931  	LexAccessor styler(pAccess);
932  	Sci_PositionU endPos = startPos + length;
933  	int visibleChars = 0;
934  	Sci_Position lineCurrent = styler.GetLine(startPos);
935  	int levelCurrent = SC_FOLDLEVELBASE;
936      int lineState = 0;
937  	if (lineCurrent > 0) {
938  		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
939          lineState = styler.GetLineState(lineCurrent-1);
940      }
941      int indexing_level = (int)((lineState >> 4) & 0x0F);     
942      int list_comprehension = (int)((lineState >> 8) & 0x0F); 
943  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
944  	int levelNext = levelCurrent;
945  	char chNext = styler[startPos];
946  	int stylePrev = styler.StyleAt(startPos - 1);
947  	int styleNext = styler.StyleAt(startPos);
948  	int style = initStyle;
949      char word[100];
950      int wordlen = 0;
951      for (Sci_PositionU i = startPos; i < endPos; i++) {
952  		char ch = chNext;
953  		chNext = styler.SafeGetCharAt(i + 1);
954  		style = styleNext;
955  		styleNext = styler.StyleAt(i + 1);
956  		bool atEOL = i == (lineStartNext-1);
957          if (options.foldComment && style == SCE_JULIA_COMMENT) {
958              if (ch == '#' && chNext == '=') {
959                  levelNext ++;
960              }
961              if (ch == '=' && chNext == '#' && levelNext > 0) {
962                  levelNext --;
963              }
964          }
965          if (options.foldSyntaxBased) {
966              if (style == SCE_JULIA_BRACKET) {
967                  if (ch == '[') {
968                      list_comprehension ++;
969                      indexing_level ++;
970                      levelNext ++;
971                  } else if (ch == ']') {
972                      list_comprehension --;
973                      indexing_level --;
974                      levelNext --;
975                  } else if (ch == '(') {
<span onclick='openModal()' class='match'>976                      list_comprehension ++;
977                      levelNext ++;
978                  } else if (ch == ')') {
979                      list_comprehension --;
980                      levelNext --;
981                  }
</span>982                  if (indexing_level < 0) {
983                      indexing_level = 0;
984                  }
985                  if (list_comprehension < 0) {
986                      list_comprehension = 0;
987                  }
988              }
989              if (style == SCE_JULIA_KEYWORD1) {
990                  word[wordlen++] = static_cast<char>(ch);
991                  if (wordlen == 100) {  
992                      word[0] = '\0';
993                      wordlen = 1;
994                  }
995                  if (styleNext != SCE_JULIA_KEYWORD1) {
996                      word[wordlen] = '\0';
997                      wordlen = 0;
998                      if (list_comprehension <= 0 && indexing_level <= 0) {
999                          levelNext += CheckKeywordFoldPoint(word);
1000                      }
1001                  }
1002              }
1003          }
1004          if (options.foldDocstring) {
1005              if (stylePrev != SCE_JULIA_DOCSTRING && style == SCE_JULIA_DOCSTRING) {
1006                  levelNext ++;
1007              } else if (style == SCE_JULIA_DOCSTRING && styleNext != SCE_JULIA_DOCSTRING) {
1008                  levelNext --;
1009              }
1010          }
1011          if (levelNext < 0) {
1012              levelNext = 0;
1013          }
1014          if (!IsASpace(ch)) {
1015              visibleChars++;
1016          }
1017          stylePrev = style;
1018          if (atEOL || (i == endPos-1)) {
1019              int levelUse = levelCurrent;
1020              int lev = levelUse | levelNext << 16;
1021              if (visibleChars == 0 && options.foldCompact) {
1022                  lev |= SC_FOLDLEVELWHITEFLAG;
1023              }
1024              if (levelUse < levelNext) {
1025                  lev |= SC_FOLDLEVELHEADERFLAG;
1026              }
1027              if (lev != styler.LevelAt(lineCurrent)) {
1028                  styler.SetLevel(lineCurrent, lev);
1029              }
1030              lineCurrent++;
1031              lineStartNext = styler.LineStart(lineCurrent+1);
1032              levelCurrent = levelNext;
1033              if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length() - 1))) {
1034                  styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
1035              }
1036              visibleChars = 0;
1037          }
1038      }
1039  }
1040  LexerModule lmJulia(SCLEX_JULIA, LexerJulia::LexerFactoryJulia, "julia", juliaWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexJulia.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexJulia.cxx</div>
                </div>
                <div class="column column_space"><pre><code>969                      indexing_level ++;
970                      levelNext ++;
971                  } else if (ch == ']') {
972                      list_comprehension --;
973                      indexing_level --;
974                      levelNext --;
</pre></code></div>
                <div class="column column_space"><pre><code>976                      list_comprehension ++;
977                      levelNext ++;
978                  } else if (ch == ')') {
979                      list_comprehension --;
980                      levelNext --;
981                  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    