
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.5665961945031714%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rinetmatch.h</h3>
            <pre><code>1  #ifndef RIGRAPH_H
2  #define RIGRAPH_H
3  #include "Snap.h"
4  enum TMamaParent { mpParentTypeIn, mpParentTypeOut, mpParentTypeNull };
5  enum TMatch { mIso, mMono, mInd};
6  class TNodeList {
7  public:
8    virtual ~TNodeList() {};
9    virtual int GetNode(int Id) = 0;
10  };
11  template<class TNodeData, class TEdgeData>
12  class TInAdjList : public TNodeList {
13  private:
14    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Net;
15    int NodeId;
16  public:
17    TInAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NNet, int NNodeId):
18      Net(NNet), NodeId(NNodeId) { }
19    int GetNode(int Id) {
20      return Net->GetNI(NodeId).GetInNId(Id);
21    }
22  };
23  template<class TNodeData, class TEdgeData>
24  class TOutAdjList : public TNodeList {
25  private:
26    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Net;
27    int NodeId;
28  public:
29    TOutAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NNet, int NNodeId):
30      Net(NNet), NodeId(NNodeId) {}
31    int GetNode(int Id) {
32      return Net->GetNI(NodeId).GetOutNId(Id);
33    }
34  };
35  template<class TNodeData, class TEdgeData>
36  class TAllNodesList : public TNodeList {
37  private:
38    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Net;
39    int NodeId;
40  public:
41    TAllNodesList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NNet): Net(NNet) {}
42    int GetNode(int Id) {
43      return Net->GetNI(Id).GetId();
44    }
45  };
46  template<class TNodeData, class TEdgeData>
47  int GetAdjSize(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int Id) {
48    return Graph->GetNI(Id).GetDeg();
49  }
50  template<class TNodeData, class TEdgeData>
51  int GetInAdjSize(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int Id) {
52    return Graph->GetNI(Id).GetInDeg();
53  }
54  template<class TNodeData, class TEdgeData>
55  int GetOutAdjSize(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int Id) {
56    return Graph->GetNI(Id).GetOutDeg();
57  }
58  template<class TNodeData, class TEdgeData>
59  int GetNodeInAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int NId, int N) {
60    typename TNodeEDatNet<TNodeData, TEdgeData>::TNodeI NI;
61    NI = Graph->GetNI(NId);
62    return NI.GetNbrNId(N);
63  };
64  template<class TNodeData, class TEdgeData>
65  int GetNthOutAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int NId, int N) {
66    return Graph->GetNI(NId).GetOutNId(N);
67  }
68  template<class TNodeData, class TEdgeData>
69  int GetNthInAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int NId, int N) {
70    return Graph->GetNI(NId).GetInNId(N);
71  }
72  template<class TNodeData, class TEdgeData>
73  class TMatchingMachine {
74  public:
75    class TMaMaEdge {
76    private:
77      int Source;
78      int Target;
79      TEdgeData* Attr;
80    public:
81      int GetSource() const { return Source; }
82      int GetTarget() const { return Target; }
83      TEdgeData* GetAttr() const { return Attr; }
<span onclick='openModal()' class='match'>84      void SetSource(const int ValSource){ Source = ValSource; }
85      void SetTarget(const int ValTarget){ Target = ValTarget; }
</span>86      void SetAttr(TEdgeData* ValAttr) { Attr = ValAttr; }
87      TMaMaEdge(int NSource, int NTarget, TEdgeData* NAttr) {
88        Source = NSource;
89        Target = NTarget;
90        Attr = NAttr;
91      }
92      TMaMaEdge() {
93        Source = -1;
94        Target = -1;
95        Attr = NULL;
96      }
97    };
98  protected:
99    int NofSn;
100    TNodeData** NodesAttrs;
101    int* EdgesSizes;
102    int* OutEdgesSizes;				
103    int* InEdgesSizes;
104    TMaMaEdge** Edges;
105    int* MapNodeToState;
106    int* MapStateToNode;
107    int* ParentState;
108    TMamaParent* ParentType;
109  private:
110    int WCompare(int i, int j, int** Weights) {
111      for (int w = 0; w < 3; w++) {
112        if (Weights[i][w] != Weights[j][w]) {
113          return Weights[j][w] - Weights[i][w];
114        }
115      }
116      return i-j;
117    }
118    void Increase(int* NS, int* SIS, int i, int** Weights, int LeftLimit) {
119      int temp;
120      while (i > LeftLimit && (WCompare(NS[i], NS[i-1], Weights) < 0)) {
121        temp = NS[i-1];
122        NS[i-1] = NS[i];
123        NS[i] = temp;
124        temp = SIS[NS[i-1]];
125        SIS[NS[i-1]] = SIS[NS[i]];
126        SIS[NS[i]] = temp;
127        i--;
128      }
129    }
130  public:
131    TMatchingMachine(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Query) {
132      NofSn = Query->GetNodes();
133      NodesAttrs = new TNodeData*[NofSn];
134      EdgesSizes = (int*) calloc(NofSn, sizeof(int));
135      OutEdgesSizes = (int*) calloc(NofSn, sizeof(int));
136  	InEdgesSizes = (int*) calloc(NofSn, sizeof(int));
137      Edges = new TMaMaEdge*[NofSn];
138      MapNodeToState = (int*) calloc(NofSn, sizeof(int));
139      MapStateToNode = (int*) calloc(NofSn, sizeof(int));
140      ParentState = (int*) calloc(NofSn, sizeof(int));
141      ParentType = new TMamaParent[NofSn];
142    }
143    virtual ~TMatchingMachine() {
144      delete[] NodesAttrs;
145      for (int i = 0; i < NofSn; i++) {
146        delete[] Edges[i];
147      }
148      delete[] Edges;
149      free(EdgesSizes);
150      free(OutEdgesSizes);
151      free(InEdgesSizes);
152      free(MapNodeToState);
153      free(MapStateToNode);
154      free(ParentState);
155      delete[] ParentType;
156    }
157    void Build(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &SSG) {
158      enum TNodeFlag { nsCore, nsCNeigh, nsUnv };
159      TNodeFlag* NodeFlags = new TNodeFlag[NofSn];
160      int** Weights = new int*[NofSn];
161      int* ParentNode = (int*) calloc(NofSn, sizeof(int));
162      TMamaParent* ParentTypes = new TMamaParent[NofSn];
163      for (int i = 0; i < NofSn; i++) {
164        NodeFlags[i] = nsUnv;
165        Weights[i] = new int[3];
166        Weights[i][0] = 0;
167        Weights[i][1] = 0;
168        Weights[i][2] = GetAdjSize(SSG, i);
169        ParentNode[i] = -1;
170        ParentTypes[i] = mpParentTypeNull;
171      }
172      int SId = 0;
173      int n;
174      int NIT; int NId;
175      int NNIT; int NNId;
176      int NQueueL = 0, NQueueR = 0;
177      int MaxId, MaxV;
178      int Tmp;
179      while (SId < NofSn) {
180        if (NQueueL == NQueueR) {
181          MaxId = -1;
182          MaxV = -1;
183          NIT = 0;
184          while (NIT < NofSn) {
185            if (NodeFlags[NIT] == nsUnv && Weights[NIT][2] > MaxV) {
186              MaxV = Weights[NIT][2];
187              MaxId = NIT;
188            }
189            NIT++;
190          }
191          MapStateToNode[SId] = MaxId;
192          MapNodeToState[MaxId] = SId;
193          ParentTypes[MaxId] = mpParentTypeNull;
194          ParentNode[MaxId] = -1;
195          NQueueR++;
196          n = MaxId;
197          NIT = 0;
198          while(NIT < GetOutAdjSize(SSG, n)){ 
199            NId = GetNthOutAdjList(SSG, n, NIT);
200            if (NId != n) {
201              Weights[NId][1]++;
202            }
203            NIT++;
204          }
205          while(NIT < GetInAdjSize(SSG, n)){ 
206            NId = GetNthInAdjList(SSG, n, NIT);
207            if (NId != n) {
208              Weights[NId][1]++;
209            }
210            NIT++;
211          }
212        }
213        if (NQueueL != NQueueR-1) {
214           MaxId = NQueueL;
215           for (int mi = MaxId+1; mi < NQueueR; mi++) {
216             if (WCompare(MapStateToNode[mi], MapStateToNode[MaxId], Weights) < 0) {
217               MaxId = mi;
218             }
219           }
220           Tmp = MapStateToNode[NQueueL];
221           MapStateToNode[NQueueL] = MapStateToNode[MaxId];
222           MapStateToNode[MaxId] = Tmp;
223        }
224        n = MapStateToNode[SId];
225        MapNodeToState[n] = SId;
226        NQueueL++;
227        NodeFlags[n] = nsCore;
228        NIT = 0;
229        while (NIT < GetOutAdjSize(SSG, n)) {
230          NId = GetNthOutAdjList(SSG, n, NIT);
231          if (NId != n) {
232            Weights[NId][0]++;
233            Weights[NId][1]--;
234            if (NodeFlags[NId] == nsUnv) {
235              NodeFlags[NId] = nsCNeigh;
236              ParentNode[NId] = n;
237              if (NIT < GetOutAdjSize(SSG, n)) {
238                ParentTypes[NId] = mpParentTypeOut;
239              } else {
240                ParentTypes[NId] = mpParentTypeIn;
241              }
242              MapStateToNode[NQueueR] = NId;
243              MapNodeToState[NId] = NQueueR;
244              NQueueR++;
245              NNIT = 0;
246              while (NNIT < GetOutAdjSize(SSG, NId)) {
247                NNId = GetNthOutAdjList(SSG, NId, NNIT);
248                Weights[NNId][1]++;
249                NNIT++;
250              }
251            }
252          }
253          NIT++;
254        }
255        NIT = 0;
256        while (NIT < GetInAdjSize(SSG, n)) {
257          NId = GetNthInAdjList(SSG, n, NIT);
258          if (NId != n) {
259            Weights[NId][0]++;
260            Weights[NId][1]--;
261            if (NodeFlags[NId] == nsUnv) {
262              NodeFlags[NId] = nsCNeigh;
263              ParentNode[NId] = n;
264              if (NIT < GetOutAdjSize(SSG, n)) {
265                ParentTypes[NId] = mpParentTypeOut;
266              } else {
267                ParentTypes[NId] = mpParentTypeIn;
268              }
269              MapStateToNode[NQueueR] = NId;
270              MapNodeToState[NId] = NQueueR;
271              NQueueR++;
272              NNIT = 0;
273              while (NNIT < GetInAdjSize(SSG, NId)) {
274                NNId = GetNthInAdjList(SSG, NId, NNIT);
275                Weights[NNId][1]++;
276                NNIT++;
277              }
278            }
279          }
280          NIT++;
281        }
282        SId++;
283      }
284      int ECount, OutECount, InECount; int i;
285      for (SId = 0; SId < NofSn; SId++) {
286        n = MapStateToNode[SId];
287        if (ParentNode[n] != -1) {
288          ParentState[SId] = MapNodeToState[ParentNode[n]];
289        } else {
290          ParentState[SId] = -1;
291        }
292        ParentType[SId] = ParentTypes[n];
293        ECount = 0;
294        OutECount = 0;
295        for (i = 0; i < GetOutAdjSize(SSG, n); i++) {
296          if (MapNodeToState[GetNthOutAdjList(SSG, n, i)] < SId) {
297              ECount++;
298              OutECount++;
299          }
300        }
301        InECount = 0;
302        for (i = 0; i < GetInAdjSize(SSG, n); i++) {
303          if (MapNodeToState[GetNthInAdjList(SSG, n, i)] < SId) {
304              ECount++;
305              InECount++;
306          }
307        }
308        EdgesSizes[SId] = ECount;
309        OutEdgesSizes[SId] = OutECount;
310        InEdgesSizes[SId] = InECount;
311        Edges[SId] = new TMaMaEdge[ECount];
312        ECount = 0;
313        for (i = 0; i < GetOutAdjSize(SSG, n); i++) {
314          int m = GetNthOutAdjList(SSG, n, i);
315          if (MapNodeToState[m] < SId) {
316            Edges[SId][ECount].SetSource(MapNodeToState[n]);
317            Edges[SId][ECount].SetTarget(MapNodeToState[m]);
318            Edges[SId][ECount].SetAttr(&SSG->GetEI(n, m).GetDat());
319            ECount++;
320          }
321        }
322        for (i = 0; i < GetInAdjSize(SSG, n);i++) {
323          int m = GetNthInAdjList(SSG, n, i);
324          if (MapNodeToState[m] < SId) {
325            Edges[SId][ECount].SetTarget(MapNodeToState[n]);
326            Edges[SId][ECount].SetSource(MapNodeToState[m]);
327            Edges[SId][ECount].SetAttr(&SSG->GetEI(m, n).GetDat());
328            ECount++;
329          }
330        }
331      }
332      delete[] NodeFlags;
333      for (int i = 0; i < NofSn; i++) {
334        delete[] Weights[i];
335      }
336      delete[] Weights;
337      free(ParentNode);
338      delete[] ParentTypes;
339    }
340    void print() {
341      printf("| MatchingMachine:  nof states %d\n", NofSn);
342      printf("| \tmap state_to_node(");
343      for (int i = 0; i < NofSn; i++) {
344        printf("[%d: %d]", i, MapStateToNode[i]);
345      }
346      printf(")\n");
347      printf("| \tmap node_to_state(");
348      for (int i = 0; i < NofSn; i++) {
349        printf("[: %d]", i, MapNodeToState[i]);
350      }
351      printf(")\n");
352      printf("| \tstates (node)(parent state, parent type)\n");
353      for (int i = 0; i < NofSn; i++) {
354        printf("| \t\t[%d] (%d) (%d, ", i, MapStateToNode[i], ParentState[i]);
355        switch (ParentType[i]) {
356          case mpParentTypeIn:
357            printf("IN");
358            break;
359          case mpParentTypeOut:
360            printf("OUT");
361            break;
362          case mpParentTypeNull:
363            printf("NULL");
364            break;
365        }
366        printf(")\n");
367        printf("| \t\t\tchecking[%d] ", EdgesSizes[i]);
368        for (int j = 0; j < EdgesSizes[i]; j++) {
369          printf("{s(%d,%d):", Edges[i][j].GetSource(), Edges[i][j].GetTarget());
370          printf("n(%d,%d)}", MapStateToNode[Edges[i][j].GetSource()],
371            MapStateToNode[Edges[i][j].GetTarget()]);
372        }
373        printf("\n");
374      }
375    }
376    TMaMaEdge** GetEdges() const { return Edges; }
377    int* GetEdgesSizes() const { return EdgesSizes; }
378    int* GetOutEdgesSizes() const { return OutEdgesSizes; }
379    int* GetInEdgesSizes() const { return InEdgesSizes; }
380    int* GetMapNodeToState() const { return MapNodeToState; }
381    int* GetMapStateToNode() const { return MapStateToNode; }
382    TNodeData** GetNodesAttrs() const { return NodesAttrs; }
383    int GetNofSn() const { return NofSn; }
384    int* GetParentState() const { return ParentState;}
385    TMamaParent* GetParentType() const { return ParentType; }
386    void SetEdges(TMaMaEdge** edges) { this->Edges = edges; }
387    void SetEdgesSizes(int* edges_sizes) { this->EdgesSizes = edges_sizes; }
388    void SetMapNodeToState(int* map_node_to_state) {
389      this->MapNodeToState = map_node_to_state;
390    }
391    void SetMapStateToNode(int* map_state_to_node) {
392      this->MapStateToNode = map_state_to_node;
393    }
394    void SetNodesAttrs(TNodeData** nodes_attrs) {
395      this->NodesAttrs = nodes_attrs;
396    }
397    void SetNofSn(int nof_sn) { this->NofSn = nof_sn; }
398    void SetParentState(int* parent_state) {
399      this->ParentState = parent_state;
400    }
401    void SetParentType(TMamaParent* parent_type) {
402      this->ParentType = parent_type;
403    }
404  };
405  class TMatchListener {
406  protected:
407    long MatchCount;
408  public:
409    TMatchListener() { MatchCount = 0; }
410    virtual ~TMatchListener() {};
411    long GetMatchCount() const { return MatchCount; }
412    void SetMatchCount(long NMatchCount) { MatchCount = NMatchCount; }
413    virtual void Match(int n, int* QIds, int* RIds) = 0;
414  };
415  class TEmptyMatchListener : public TMatchListener {
416  public:
417    TEmptyMatchListener() : TMatchListener() {}
418    virtual void Match(int n, int* QIds, int* RIds) {
419      MatchCount++;
420    };
421  };
422  class TConsoleMatchListener : public TMatchListener {
423  public:
424    TConsoleMatchListener() : TMatchListener() {}
425    virtual void Match(int n, int* QIds, int* RIds) {
426      MatchCount++;
427      printf("{");
428      for (int i = 0; i < n; i++) {
429        printf("(%d,%d)", QIds[i], RIds[i]);
430      }
431      printf("}\n");
432    }
433  };
434  template<class TNodeData, class TEdgeData>
435  class TSolver {
436  protected:
437    TMatchingMachine<TNodeData, TEdgeData> &MaMa;
438    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &RGraph;
439    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &QGraph;
440    TMatchListener &MatchListener;
441  public:
442    TSolver(TMatchingMachine<TNodeData, TEdgeData> &NMaMa,
443      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NRGraph,
444      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NQGraph,
445      TMatchListener &NMatchListener) : MaMa(NMaMa),
446        RGraph(NRGraph), QGraph(NQGraph), MatchListener(NMatchListener) {
447    }
448    virtual ~TSolver() {}
449    void Solve() {
450      int IId;
451      int NofSn = MaMa.GetNofSn();
452      int* MapStateToNode = MaMa.GetMapStateToNode();
453      int* ParentState = MaMa.GetParentState();
454      TMamaParent* ParentType = MaMa.GetParentType();
455      TNodeList* ListAllRef = new TAllNodesList<TNodeData, TEdgeData>(RGraph);
456      TNodeList** Candidates = new TNodeList*[NofSn];
457      int* CandidatesIt = new int[NofSn];
458      int* CandidatesSize = new int[NofSn];
459      int* Solution = new int[NofSn];
460      for (IId = 0; IId < NofSn; IId++) {
461        Solution[IId] = -1;
462      }
463      bool* Matched = (bool*) calloc(RGraph->GetNodes(), sizeof(bool));
464      Candidates[0] = ListAllRef;
465      CandidatesSize[0] = RGraph->GetNodes();
466      CandidatesIt[0] = -1;
467      int PSId = -1;
468      int SId = 0;
469      int CId = -1;
470      int Sip1;
471      while (SId != -1) {
472        if (PSId >= SId) { Matched[Solution[SId]] = false; }
473        CId = -1;
474        CandidatesIt[SId]++;
475        while (CandidatesIt[SId] < CandidatesSize[SId]) {
476          CId = Candidates[SId]->GetNode(CandidatesIt[SId]);
477          Solution[SId] = CId;
478          if ((!Matched[CId]) &&
479               NodeCheck(SId,CId, MapStateToNode) &&
480               EdgesCheck(SId, CId, Solution, Matched)) {
481            break;
482          } else {
483            CId = -1;
484          }
485          CandidatesIt[SId]++;
486        }
487        if (CId == -1) {
488          PSId = SId;
489  	delete Candidates[SId];
490          SId--;
491        } else {
492          if (SId == NofSn -1) {
493            MatchListener.Match(NofSn, MapStateToNode, Solution);
494            PSId = SId;
495          } else {
496            Matched[Solution[SId]] = true;
497            Sip1 = SId + 1;
498            if (ParentType[Sip1] == mpParentTypeNull) {
499              Candidates[Sip1] = ListAllRef;
500              CandidatesSize[Sip1] = RGraph->GetNodes();
501            } else {
502              if (ParentType[Sip1] == mpParentTypeIn) {
503                Candidates[Sip1] = new TInAdjList<TNodeData, TEdgeData>(RGraph,
504                  Solution[ParentState[Sip1]]);
505                CandidatesSize[Sip1] = GetInAdjSize(RGraph,
506                  Solution[ParentState[Sip1]]);
507              } else {
508                Candidates[Sip1] = new TOutAdjList<TNodeData, TEdgeData>(RGraph,
509                  Solution[ParentState[Sip1]]);
510                CandidatesSize[Sip1] = GetOutAdjSize(RGraph,
511                  Solution[ParentState[Sip1]]);
512              }
513            }
514            CandidatesIt[SId+1] = -1;
515            PSId = SId;
516            SId++;
517          }
518        }
519      }
520    }
521    virtual bool NodeCheck(int SId, int CId, int* MapStateToNode) = 0;
522    virtual bool EdgesCheck(int SId, int CId, int* Solution, bool* Matched) = 0;
523  };
524  template<class TNodeData, class TEdgeData>
525  class TInducedSubGISolver : public TSolver<TNodeData, TEdgeData> {
526  using TSolver<TNodeData, TEdgeData>::RGraph;
527  using TSolver<TNodeData, TEdgeData>::QGraph;
528  using TSolver<TNodeData, TEdgeData>::MaMa;
529  public:
530    TInducedSubGISolver(TMatchingMachine<TNodeData, TEdgeData> &NMaMa,
531      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NRGraph,
532      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NQGraph,
533      TMatchListener &NMatchListener) : TSolver<TNodeData, TEdgeData>(NMaMa,
534        NRGraph, NQGraph, NMatchListener) {
535    }
536    bool NodeCheck(int SId, int CId, int* MapStateToNode) {
537      if (GetOutAdjSize(RGraph, CId) >= GetOutAdjSize(QGraph, MapStateToNode[SId]) &&
538           GetInAdjSize(RGraph, CId) >= GetInAdjSize(QGraph, MapStateToNode[SId])) {
539        return (RGraph->GetNI(CId).GetDat() ==
540                 QGraph->GetNI(MapStateToNode[SId]).GetDat());
541      }
542      return false;
543    }
544    bool EdgesCheck(int SId, int CId, int* Solution, bool* Matched) {
545      int Source, Target;
546      int IId;
547      for (int me = 0; me < MaMa.GetEdgesSizes()[SId]; me++) {
548        Source = Solution[MaMa.GetEdges()[SId][me].GetSource()];
549        Target = Solution[MaMa.GetEdges()[SId][me].GetTarget()];
550        for (IId = 0; IId < GetOutAdjSize(RGraph, Source); IId++) {
551          if (GetNthOutAdjList(RGraph, Source, IId) == Target) {
552            if (RGraph->GetEI(Source, GetNthOutAdjList(RGraph, Source, IId)).GetDat() != 
553                 *MaMa.GetEdges()[SId][me].GetAttr()) {
554              return false;
555            } else {
556              break;
557            }
558          }
559        }
560        if (IId >= GetOutAdjSize(RGraph, Source)) {
561          return false;
562        }
563      }
564      int Count = 0;
565      for (IId = 0; IId < GetOutAdjSize(RGraph, CId); IId++) {
566        if (Matched[GetNthOutAdjList(RGraph, CId, IId)]) {
567          Count++;
568          if (Count > MaMa.GetOutEdgesSizes()[SId])
569            return false;
570        }
571      }
572      Count = 0;
573      for (IId = 0; IId < GetInAdjSize(RGraph, CId); IId++) {
574        if (Matched[GetNthInAdjList(RGraph, CId, IId)]) {
575          Count++;
576          if (Count > MaMa.GetInEdgesSizes()[SId])
577            return false;
578        }
579      }
580      return true;
581    }
582  };
583  template<class TNodeData, class TEdgeData>
584  class TIsoGISolver : public TSolver<TNodeData, TEdgeData> {
585  using TSolver<TNodeData, TEdgeData>::RGraph;
586  using TSolver<TNodeData, TEdgeData>::QGraph;
587  using TSolver<TNodeData, TEdgeData>::MaMa;
588  public:
589    TIsoGISolver(TMatchingMachine<TNodeData, TEdgeData> &NMaMa,
590      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NRGraph,
591      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NQGraph,
592      TMatchListener &NMatchListener) : TSolver<TNodeData, TEdgeData>(NMaMa,
593        NRGraph, NQGraph, NMatchListener) {}
594    bool NodeCheck(int SId, int CId, int* MapStateToNode) {
595      if (GetOutAdjSize(RGraph, CId) == GetOutAdjSize(QGraph, MapStateToNode[SId]) &&
596           GetInAdjSize(RGraph, CId) == GetInAdjSize(QGraph, MapStateToNode[SId])) {
597        return (RGraph->GetNI(CId).GetDat() ==
598                QGraph->GetNI(MapStateToNode[SId]).GetDat());
599      }
600      return false;
601    }
602    bool EdgesCheck(int SId, int CId, int* Solution, bool* Matched) {
603      int Source, Target;
604      int IId;
605      for (int me = 0; me < MaMa.GetEdgesSizes()[SId]; me++) {
606        Source = Solution[MaMa.GetEdges()[SId][me].GetSource()];
607        Target = Solution[MaMa.GetEdges()[SId][me].GetTarget()];
608        for (IId = 0; IId < GetOutAdjSize(RGraph, Source); IId++) {
609          if (GetNthOutAdjList(RGraph, Source, IId) == Target) {
610            if (RGraph->GetEI(Source, GetNthOutAdjList(RGraph, Source, IId)).GetDat() !=
611                 *MaMa.GetEdges()[SId][me].GetAttr()) {
612              return false;
613            } else {
614              break;
615            }
616          }
617        }
618        if (IId >= GetOutAdjSize(RGraph, Source)) {
619          return false;
620        }
621      }
622      return true;
623    }
624  };
625  template <class TNodeData, class TEdgeData>
626  class TSubGISolver : public TSolver<TNodeData, TEdgeData> {
627  using TSolver<TNodeData, TEdgeData>::RGraph;
628  using TSolver<TNodeData, TEdgeData>::QGraph;
629  using TSolver<TNodeData, TEdgeData>::MaMa;
630  public:
631    TSubGISolver(TMatchingMachine<TNodeData, TEdgeData> &NMaMa,
632      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NRGraph,
633      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NQGraph,
634      TMatchListener &NMatchListener) : TSolver<TNodeData, TEdgeData>(NMaMa,
635        NRGraph, NQGraph, NMatchListener) {
636    }
637    bool NodeCheck(int SId, int CId, int* MapStateToNode) {
638      if (GetOutAdjSize(RGraph, CId) >= GetOutAdjSize(QGraph, MapStateToNode[SId]) &&
639           GetInAdjSize(RGraph, CId) >= GetInAdjSize(QGraph, MapStateToNode[SId])) {
640          return (RGraph->GetNI(CId).GetDat() ==
641                  QGraph->GetNI(MapStateToNode[SId]).GetDat());
642      }
643      return false;
644    }
645    bool EdgesCheck(int SId, int CId, int* Solution, bool* Matched) {
646      int Source, Target;
647      int IId;
648      for (int me = 0; me < MaMa.GetEdgesSizes()[SId]; me++) {
649        Source = Solution[MaMa.GetEdges()[SId][me].GetSource()];
650        Target = Solution[MaMa.GetEdges()[SId][me].GetTarget()];
651        for (IId = 0; IId < GetOutAdjSize(RGraph, Source); IId++) {
652          if (GetNthOutAdjList(RGraph, Source, IId) == Target) {
653            if (RGraph->GetEI(Source, GetNthOutAdjList(RGraph, Source, IId)).GetDat() !=
654                 *MaMa.GetEdges()[SId][me].GetAttr()) {
655              return false;
656            } else {
657              break;
658            }
659          }
660        }
661        if (IId >= GetOutAdjSize(RGraph, Source)) {
662          return false;
663        }
664      }
665      return true;
666    }
667  };
668  template<class TNodeData, class TEdgeData>
669  void Match(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Reference,
670    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Query,
671    TMatchingMachine<TNodeData, TEdgeData> &MatchingMachine,
672    TMatchListener &MatchListener,
673    TMatch MatchType) {
674      TSolver<TNodeData, TEdgeData>* Solver;
675      switch (MatchType) {
676        case mIso:
677          Solver = new TIsoGISolver<TNodeData, TEdgeData>(MatchingMachine,
678            Reference,
679            Query,
680            MatchListener);
681          break;
682        case mMono:
683          Solver = new TSubGISolver<TNodeData, TEdgeData>(MatchingMachine,
684            Reference,
685            Query,
686            MatchListener);
687          break;
688        case mInd:
689          Solver = new TInducedSubGISolver<TNodeData, TEdgeData>(MatchingMachine,
690            Reference,
691            Query,
692            MatchListener);
693          break;
694      }
695      Solver->Solve();
696  };
697  template <class TNodeData, class TEdgeData>
698  int Match(TMatch matchtype, TPt<TNodeEDatNet<TNodeData, TEdgeData> > &RefGraph,
699    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &QueGraph);
700  template <class TNodeData, class TEdgeData> 
701  int Match(TMatch Matchtype, 
702    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &RefGraph,
703    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &QueGraph) {
704    TMatchingMachine<TNodeData, TEdgeData>* MaMa =
705      new TMatchingMachine<TNodeData, TEdgeData>(QueGraph);
706    MaMa->Build(QueGraph);
707    long MatchCount = 0;
708    TMatchListener* MatchListener = new TEmptyMatchListener();
709    Match(RefGraph,
710      QueGraph,
711      *MaMa,
712      *MatchListener,
713      Matchtype);
714   MatchCount = MatchListener->GetMatchCount();
715   delete MatchListener;
716  #ifdef CSV_FORMAT
717  #else
718   printf("number of found matches: %d\n", MatchCount);
719  #endif
720    return 0;
721  };
722  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.h</h3>
            <pre><code>1  class TMem;
2  class TChA;
3  class TStr;
4  class TCs{
5  private:
6    static const int MxMask;
7    int Val;
8  public:
9    TCs(): Val(0){}
10    TCs(const TCs& Cs): Val(Cs.Val&MxMask){}
11    TCs(const int& Int): Val(Int&MxMask){}
12    TCs& operator=(const TCs& Cs){Val=Cs.Val; return *this;}
13    bool operator==(const TCs& Cs) const {return Val==Cs.Val;}
14    TCs& TCs::operator+=(const TCs& Cs){Val=(Val+Cs.Val)&MxMask; return *this;}
15    TCs& TCs::operator+=(const char& Ch){Val=(Val+Ch)&MxMask; return *this;}
16    TCs& TCs::operator+=(const int& Int){Val=(Val+Int)&MxMask; return *this;}
17    int Get() const {return Val;}
18    static TCs GetCsFromBf(char* Bf, const int& BfL);
19  };
20  class TSOutMnp {
21  public:
22    virtual TSOut& operator()(TSOut& SOut) const=0;
23  };
24  class TSBase{
25  protected:
26    TCRef CRef;
27    TSStr SNm;
28    TCs Cs;
29  protected:
30    TSBase(){}
31    TSBase(const TSBase&);
32    TSBase& operator=(const TSBase&);
33  public:
34    TSBase(const TSStr& Nm): SNm(Nm){}
35    virtual ~TSBase(){}
36    virtual TStr GetSNm() const;
37  };
38  class TSIn: virtual public TSBase{
39  private:
40    bool FastMode;
41  private:
42    TSIn(const TSIn&);
43    TSIn& operator=(const TSIn&);
44  public:
45    TSIn(): TSBase("Input-Stream"), FastMode(false){}
46    TSIn(const TStr& Str);
47    virtual ~TSIn(){}
48    virtual bool Eof() const=0; 
49    virtual int Len() const=0; 
50    virtual char GetCh()=0; 
51    virtual char PeekCh()=0; 
52    virtual int GetBf(const void* Bf, const int& BfL)=0;
53    bool IsFastMode() const {return FastMode;}
54    void SetFastMode(const bool& _FastMode){FastMode=_FastMode;}
55    void LoadCs();
<span onclick='openModal()' class='match'>56    void LoadBf(const void* Bf, const int& BfL){Cs+=GetBf(Bf, BfL);}
57    void* LoadNewBf(const int& BfL){
58      void* Bf=(void*)new char[BfL]; Cs+=GetBf(Bf, BfL); return Bf;}
</span>59    void Load(bool& Bool){Cs+=GetBf(&Bool, sizeof(Bool));}
60    void Load(uchar& UCh){Cs+=GetBf(&UCh, sizeof(UCh));}
61    void Load(char& Ch){Cs+=GetBf(&Ch, sizeof(Ch));}
62    void Load(short& Short){Cs+=GetBf(&Short, sizeof(Short));} 
63    void Load(ushort& UShort){Cs+=GetBf(&UShort, sizeof(UShort));} 
64    void Load(int& Int){Cs+=GetBf(&Int, sizeof(Int));}
65    void Load(uint& UInt){Cs+=GetBf(&UInt, sizeof(UInt));}
66    void Load(int64& Int){Cs+=GetBf(&Int, sizeof(Int));}
67    void Load(uint64& UInt){Cs+=GetBf(&UInt, sizeof(UInt));}
68    void Load(double& Flt){Cs+=GetBf(&Flt, sizeof(Flt));}
69    void Load(sdouble& SFlt){Cs+=GetBf(&SFlt, sizeof(SFlt));}
70    void Load(ldouble& LFlt){Cs+=GetBf(&LFlt, sizeof(LFlt));}
71    void Load(char*& CStr, const int& MxCStrLen, const int& CStrLen){
72      CStr=new char[MxCStrLen+1]; Cs+=GetBf(CStr, CStrLen+1);}
73    void Load(char*& CStr);
74    TSIn& operator>>(bool& Bool){Cs+=GetBf(&Bool, sizeof(Bool)); return *this;}
75    TSIn& operator>>(uchar& UCh){Cs+=GetBf(&UCh, sizeof(UCh)); return *this;}
76    TSIn& operator>>(char& Ch){Cs+=GetBf(&Ch, sizeof(Ch)); return *this;}
77    TSIn& operator>>(short& Sh){Cs+=GetBf(&Sh, sizeof(Sh)); return *this;}
78    TSIn& operator>>(ushort& USh){Cs+=GetBf(&USh, sizeof(USh)); return *this;}
79    TSIn& operator>>(int& Int){Cs+=GetBf(&Int, sizeof(Int)); return *this;}
80    TSIn& operator>>(uint& UInt){Cs+=GetBf(&UInt, sizeof(UInt)); return *this;}
81    TSIn& operator>>(int64& Int){Cs+=GetBf(&Int, sizeof(Int)); return *this;}
82    TSIn& operator>>(uint64& UInt){Cs+=GetBf(&UInt, sizeof(UInt)); return *this;}
83    TSIn& operator>>(float& Flt){Cs+=GetBf(&Flt, sizeof(Flt)); return *this;}
84    TSIn& operator>>(double& Double){Cs+=GetBf(&Double, sizeof(Double)); return *this;}
85    TSIn& operator>>(long double& LDouble){Cs+=GetBf(&LDouble, sizeof(LDouble)); return *this;}
86    static const TPt<TSIn> StdIn;
87    friend class TPt<TSIn>;
88  };
89  typedef TPt<TSIn> PSIn;
90  template <class T>
91  TSIn& operator>>(TSIn& SIn, T& Val) {
92    Val.Load(SIn); return SIn;
93  }
94  class TSOut: virtual public TSBase{
95  private:
96    int MxLnLen, LnLen;
97    int UpdateLnLen(const int& StrLen, const bool& ForceInLn=false);
98  private:
99    TSOut(const TSIn&);
100    TSOut& operator = (const TSOut&);
101  public:
102    TSOut(): TSBase("Output-Stream"), MxLnLen(-1), LnLen(0){}
103    TSOut(const TStr& Str);
104    virtual ~TSOut(){}
105    void EnableLnTrunc(const int& _MxLnLen){MxLnLen=_MxLnLen;}
106    void DisableLnTrunc(){MxLnLen=-1;}
107    virtual int PutCh(const char& Ch)=0;
108    virtual int PutBf(const void* LBf, const int& LBfL)=0;
109    virtual void Flush()=0;
110    virtual TFileId GetFileId() const {return NULL;}
111    int PutMem(const TMem& Mem);
112    int PutCh(const char& Ch, const int& Chs);
113    int PutBool(const bool& Bool);
114    int PutInt(const int& Int);
115    int PutInt(const int& Int, char* FmtStr);
116    int PutUInt(const uint& Int);
117    int PutUInt(const uint& Int, char* FmtStr);
118    int PutFlt(const double& Flt);
119    int PutFlt(const double& Flt, char* FmtStr);
120    int PutStr(const char* CStr);
121    int PutStr(const TChA& ChA);
122    int PutStr(const TStr& Str, char* FmtStr);
123    int PutStr(const TStr& Str, const bool& ForceInLn=false);
124    int PutStrLn(const TStr& Str, const bool& ForceInLn=false){
125      int Cs=PutStr(Str,ForceInLn); Cs+=PutLn(); return Cs;}
126    int PutIndent(const int& IndentLev=1);
127    int PutLn(const int& Lns=1);
128    int PutDosLn(const int& Lns=1);
129    int PutSep(const int& NextStrLen=0);
130    int PutSepLn(const int& Lns=0);
131    void SaveCs(){Cs+=PutBf(&Cs, sizeof(Cs));}
132    void SaveBf(const void* Bf, const int& BfL){Cs+=PutBf(Bf, BfL);}
133    void Save(const bool& Bool){Cs+=PutBf(&Bool, sizeof(Bool));}
134    void Save(const char& Ch){Cs+=PutBf(&Ch, sizeof(Ch));}
135    void Save(const uchar& UCh){Cs+=PutBf(&UCh, sizeof(UCh));}
136    void Save(const short& Short){Cs+=PutBf(&Short, sizeof(Short));}
137    void Save(const ushort& UShort){Cs+=PutBf(&UShort, sizeof(UShort));}
138    void Save(const int& Int){Cs+=PutBf(&Int, sizeof(Int));}
139    void Save(const uint& UInt){Cs+=PutBf(&UInt, sizeof(UInt));}
140    void Save(const int64& Int){Cs+=PutBf(&Int, sizeof(Int));}
141    void Save(const uint64& UInt){Cs+=PutBf(&UInt, sizeof(UInt));}
142    void Save(const double& Flt){Cs+=PutBf(&Flt, sizeof(Flt));}
143    void Save(const sdouble& SFlt){Cs+=PutBf(&SFlt, sizeof(SFlt));}
144    void Save(const ldouble& LFlt){Cs+=PutBf(&LFlt, sizeof(LFlt));}
145    void Save(const char* CStr, const int& CStrLen){Cs+=PutBf(CStr, CStrLen+1);}
146    void Save(const char* CStr);
147    void Save(TSIn& SIn, const int& BfL=-1);
148    void Save(const PSIn& SIn, const int& BfL=-1){Save(*SIn, BfL);}
149    void Save(const void* Bf, const int& BfL){Cs+=PutBf(Bf, BfL);}
150    TSOut& operator<<(const bool& Bool){Cs+=PutBf(&Bool, sizeof(Bool)); return *this;}
151    TSOut& operator<<(const uchar& UCh){Cs+=PutBf(&UCh, sizeof(UCh)); return *this;}
152    TSOut& operator<<(const char& Ch){Cs+=PutBf(&Ch, sizeof(Ch)); return *this;}
153    TSOut& operator<<(const short& Sh){Cs+=PutBf(&Sh, sizeof(Sh)); return *this;}
154    TSOut& operator<<(const ushort& USh){Cs+=PutBf(&USh, sizeof(USh)); return *this;}
155    TSOut& operator<<(const int& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
156    TSOut& operator<<(const uint& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
157    TSOut& operator<<(const int64& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
158    TSOut& operator<<(const uint64& UInt){Cs+=PutBf(&UInt, sizeof(UInt)); return *this;}
159    TSOut& operator<<(const float& Flt){Cs+=PutBf(&Flt, sizeof(Flt)); return *this;}
160    TSOut& operator<<(const double& Double){Cs+=PutBf(&Double, sizeof(Double)); return *this;}
161    TSOut& operator<<(const long double& LDouble){Cs+=PutBf(&LDouble, sizeof(LDouble)); return *this;}
162    TSOut& operator<<(const TSOutMnp& Mnp){return Mnp(*this);}
163    TSOut& operator<<(TSOut&(*FuncPt)(TSOut&)){return FuncPt(*this);}
164    TSOut& operator<<(TSIn& SIn);
165    TSOut& operator<<(PSIn& SIn){return operator<<(*SIn);}
166    static const TPt<TSOut> StdOut;
167    friend class TPt<TSOut>;
168  };
169  typedef TPt<TSOut> PSOut;
170  template <class T>
171  TSOut& operator<<(TSOut& SOut, const T& Val){
172    Val.Save(SOut); return SOut;
173  }
174  class TSInOut: public TSIn, public TSOut{
175  private:
176    TSInOut(const TSInOut&);
177    TSInOut& operator=(const TSInOut&);
178  public:
179    TSInOut(): TSBase("Input-Output-Stream"), TSIn(), TSOut() {}
180    virtual ~TSInOut(){}
181    virtual void SetPos(const int& Pos)=0;
182    virtual void MovePos(const int& DPos)=0;
183    virtual int GetPos() const=0;
184    virtual int GetSize() const=0; 
185    virtual void Clr()=0; 
186    friend class TPt<TSInOut>;
187  };
188  typedef TPt<TSInOut> PSInOut;
189  class TStdIn: public TSIn{
190  private:
191    TStdIn(const TStdIn&);
192    TStdIn& operator=(const TStdIn&);
193  public:
194    TStdIn(): TSBase("Standard input"), TSIn() {}
195    bool Eof() const {return feof(stdin)!=0;}
196    int Len() const {return -1;}
197    char GetCh(){return char(getchar());}
198    char PeekCh(){
199      int Ch=getchar(); ungetc(Ch, stdin); return char(Ch);}
200    int GetBf(const void* LBf, const int& LBfL);
201  };
202  class TStdOut: public TSOut{
203  private:
204    TStdOut(const TStdOut&);
205    TStdOut& operator=(const TStdOut&);
206  public:
207    TStdOut(): TSBase(TSStr("Standard output")), TSOut(){}
208    int PutCh(const char& Ch){putchar(Ch); return Ch;}
209    int PutBf(const void *LBf, const int& LBfL);
210    void Flush(){fflush(stdout);}
211  };
212  class TFIn: public TSIn{
213  private:
214    static const int MxBfL;
215    TFileId FileId;
216    char* Bf;
217    int BfC, BfL;
218  public:
219    void SetFPos(const int& FPos) const;
220    int GetFPos() const;
221    int GetFLen() const;
222  private:
223    void FillBf();
224  private:
225    TFIn();
226    TFIn(const TFIn&);
227    TFIn& operator=(const TFIn&);
228  public:
229    TFIn(const TStr& FNm);
230    TFIn(const TStr& FNm, bool& OpenedP);
231    static PSIn New(const TStr& FNm);
232    static PSIn New(const TStr& FNm, bool& OpenedP);
233    ~TFIn();
234    bool Eof() const {return (BfC==BfL)&&(BfL<MxBfL);}
235    int Len() const {return GetFLen()-(GetFPos()-BfL+BfC);}
236    char GetCh(){if (BfC==BfL){FillBf();} return Bf[BfC++];}
237    char PeekCh(){if (BfC==BfL){FillBf();} return Bf[BfC];}
238    int GetBf(const void* LBf, const int& LBfL);
239  };
240  class TFOut: public TSOut{
241  private:
242    static const int MxBfL;
243    TFileId FileId;
244    char* Bf;
245    int BfL;
246  private:
247    void FlushBf();
248  private:
249    TFOut();
250    TFOut(const TFOut&);
251    TFOut& operator=(const TFOut&);
252  public:
253    TFOut(const TStr& _FNm, const bool& Append=false);
254    TFOut(const TStr& _FNm, const bool& Append, bool& OpenedP);
255    static PSOut New(const TStr& FNm, const bool& Append=false);
256    static PSOut New(const TStr& FNm, const bool& Append, bool& OpenedP);
257    ~TFOut();
258    int PutCh(const char& Ch);
259    int PutBf(const void* LBf, const int& LBfL);
260    void Flush();
261    TFileId GetFileId() const {return FileId;}
262  };
263  typedef enum {faUndef, faCreate, faUpdate, faAppend, faRdOnly, faRestore} TFAccess;
264  class TFInOut : public TSInOut {
265  private:
266    TFileId FileId;
267  private:
268    TFInOut();
269    TFInOut(const TFIn&);
270    TFInOut& operator=(const TFIn&);
271  public:
272    TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo);
273    static PSInOut New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo);
274    ~TFInOut() { if (FileId!=NULL) IAssert(fclose(FileId) == 0); }
275    TStr GetFNm() const;
276    TFileId GetFileId() const {return FileId;}
277    bool Eof() const { return feof(FileId) != 0; }
278    int Len() const { return GetSize() - GetPos(); } 
279    char GetCh() { return char(fgetc(FileId)); }
280    char PeekCh() { const char Ch = GetCh();  MovePos(-1);  return Ch; }
281    int GetBf(const void* LBf, const int& LBfL);
282    void SetPos(const int& Pos) { IAssert(fseek(FileId, Pos, SEEK_SET)==0); }
283    void MovePos(const int& DPos) { IAssert(fseek(FileId, DPos, SEEK_CUR)==0); }
284    int GetPos() const { return ftell(FileId); }
285    int GetSize() const;
286    void Clr() { Fail; }
287    int PutCh(const char& Ch) { return PutBf(&Ch, sizeof(Ch)); }
288    int PutBf(const void* LBf, const int& LBfL);
289    void Flush() { IAssert(fflush(FileId) == 0); }
290  };
291  class TMIn: public TSIn{
292  private:
293    char* Bf;
294    int BfC, BfL;
295    bool Free;
296  private:
297    TMIn();
298    TMIn(const TMIn&);
299    TMIn& operator=(const TMIn&);
300  public:
301    TMIn(const void* _Bf, const int& _BfL, const bool& TakeBf=false, const bool& _Free=true);
302    TMIn(TSIn& SIn);
303    TMIn(const char* CStr);
304    TMIn(const TStr& Str);
305    TMIn(const TChA& ChA);
306    static PSIn New(const char* CStr);
307    static PSIn New(const TStr& Str);
308    static PSIn New(const TChA& ChA);
309    ~TMIn(){if (Bf!=NULL&&Free){delete[] Bf;}}
310    bool Eof() const {return BfC==BfL;}
311    int Len() const {return BfL-BfC;}
312    char GetCh();
313    char PeekCh();
314    int GetBf(const void* LBf, const int& LBfL);
315    char* GetBfAddr(){return Bf;}
316  };
317  class TMOut: public TSOut{
318  private:
319    char* Bf;
320    int BfL, MxBfL;
321    bool OwnBf;
322    void Resize();
323  private:
324    TMOut(const TMOut&);
325    TMOut& operator=(const TMOut&);
326  public:
327    TMOut(const int& _MxBfL=1024);
328    static PSOut New(const int& MxBfL=1024){
329      return PSOut(new TMOut(MxBfL));}
330    TMOut(char* _Bf, const int& _MxBfL);
331    ~TMOut(){if (OwnBf&&(Bf!=NULL)){delete[] Bf;}}
332    int PutCh(const char& Ch){if (BfL==MxBfL){
333      Resize();} return Bf[BfL++]=Ch;}
334    int PutBf(const void* LBf, const int& LBfL);
335    void Flush(){}
336    int Len() const {return BfL;}
337    void Clr(){BfL=0;}
338    char GetCh(const int& ChN) const {
339      IAssert((0<=ChN)&&(ChN<BfL)); return Bf[ChN];}
340    TStr GetAsStr() const;
341    void CutBf(const int& CutBfL);
342    PSIn GetSIn(const bool& IsCut=true, const int& CutBfL=-1);
343    char* GetBfAddr() const {return Bf;}
344    bool IsCrLfLn() const;
345    TStr GetCrLfLn();
346    bool IsEolnLn() const;
347    TStr GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf);
348    void MkEolnLn();
349  };
350  class TChRet{
351  private:
352    PSIn SIn;
353    char EofCh;
354    char Ch;
355  private:
356    TChRet();
357    TChRet(const TChRet&);
358    TChRet& operator=(const TChRet&);
359  public:
360    TChRet(const PSIn& _SIn, const char& _EofCh=0):
361      SIn(_SIn), EofCh(_EofCh), Ch(_EofCh){}
362    bool Eof() const {return Ch==EofCh;}
363    char GetCh(){
364      if (SIn->Eof()){return Ch=EofCh;} else {return Ch=SIn->GetCh();}}
365    char operator()(){return Ch;}
366  };
367  ClassTP(TFRnd, PFRnd)
368  private:
369    TFileId FileId;
370    TSStr FNm;
371    bool RecAct;
372    int HdLen, RecLen;
373  private:
374    void RefreshFPos();
375  private:
376    TFRnd(const TFRnd&);
377    TFRnd& operator=(const TFRnd&);
378  public:
379    TFRnd(const TStr& _FNm, const TFAccess& FAccess,
380     const bool& CreateIfNo=true, const int& _HdLen=-1, const int& _RecLen=-1);
381    static PFRnd New(const TStr& FNm,
382     const TFAccess& FAccess, const bool& CreateIfNo=true,
383     const int& HdLen=-1, const int& RecLen=-1){
384      return new TFRnd(FNm, FAccess, CreateIfNo, HdLen, RecLen);}
385    ~TFRnd();
386    TStr GetFNm() const;
387    void SetHdRecLen(const int& _HdLen, const int& _RecLen){
388      HdLen=_HdLen; RecLen=_RecLen; RecAct=(HdLen>=0)&&(RecLen>0);}
389    void SetFPos(const int& FPos);
390    void MoveFPos(const int& DFPos);
391    int GetFPos();
392    int GetFLen();
393    bool Empty(){return GetFLen()==0;}
394    bool Eof(){return GetFPos()==GetFLen();}
395    void SetRecN(const int& RecN);
396    int GetRecN();
397    int GetRecs();
398    void GetBf(void* Bf, const int& BfL);
399    void PutBf(const void* Bf, const int& BfL);
400    void Flush();
401    void GetHd(void* Hd){IAssert(RecAct);
402      int FPos=GetFPos(); SetFPos(0); GetBf(Hd, HdLen); SetFPos(FPos);}
403    void PutHd(const void* Hd){IAssert(RecAct);
404      int FPos=GetFPos(); SetFPos(0); PutBf(Hd, HdLen); SetFPos(FPos);}
405    void GetRec(void* Rec, const int& RecN=-1){
406      IAssert(RecAct); if (RecN!=-1){SetRecN(RecN);} GetBf(Rec, RecLen);}
407    void PutRec(const void* Rec, const int& RecN=-1){
408      IAssert(RecAct); if (RecN!=-1){SetRecN(RecN);} PutBf(Rec, RecLen);}
409    void PutCs(const TCs& Cs){PutBf(&Cs, sizeof(Cs));}
410    TCs GetCs(){TCs Cs; GetBf(&Cs, sizeof(Cs)); return Cs;}
411    void PutCh(const char& Ch){PutBf(&Ch, sizeof(Ch));}
412    void PutCh(const char& Ch, const int& Chs);
413    char GetCh(){char Ch; GetBf(&Ch, sizeof(Ch)); return Ch;}
414    void PutUCh(const uchar& UCh){PutBf(&UCh, sizeof(UCh));}
415    uchar GetUCh(){uchar UCh; GetBf(&UCh, sizeof(UCh)); return UCh;}
416    void PutInt(const int& Int){PutBf(&Int, sizeof(Int));}
417    int GetInt(){int Int; GetBf(&Int, sizeof(Int)); return Int;}
418    void PutUInt(const uint& UInt){PutBf(&UInt, sizeof(UInt));}
419    uint GetUInt(){uint UInt; GetBf(&UInt, sizeof(UInt)); return UInt;}
420    void PutStr(const TStr& Str);
421    TStr GetStr(const int& StrLen);
422    TStr GetStr(const int& MxStrLen, bool& IsOk);
423    void PutSIn(const PSIn& SIn, TCs& Cs);
424    PSIn GetSIn(const int& SInLen, TCs& Cs);
425    static TStr GetStrFromFAccess(const TFAccess& FAccess);
426    static TFAccess GetFAccessFromStr(const TStr& Str);
427  };
428  class TFile{
429  public:
430    static const TStr TxtFExt;
431    static const TStr HtmlFExt;
432    static const TStr HtmFExt;
433    static const TStr GifFExt;
434    static const TStr JarFExt;
435  public:
436    static bool Exists(const TStr& FNm);
437    static void Del(const TStr& FNm, const bool& ThrowExceptP=true);
438    static void DelWc(const TStr& WcStr, const bool& RecurseDirP=false);
439    static void Rename(const TStr& SrcFNm, const TStr& DstFNm);
440    static TStr GetUniqueFNm(const TStr& FNm);
441  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rinetmatch.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.h</div>
                <div class="column column_space"><pre><code>84      void SetSource(const int ValSource){ Source = ValSource; }
85      void SetTarget(const int ValTarget){ Target = ValTarget; }
</pre></code></div>
                <div class="column column_space"><pre><code>56    void LoadBf(const void* Bf, const int& BfL){Cs+=GetBf(Bf, BfL);}
57    void* LoadNewBf(const int& BfL){
58      void* Bf=(void*)new char[BfL]; Cs+=GetBf(Bf, BfL); return Bf;}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    