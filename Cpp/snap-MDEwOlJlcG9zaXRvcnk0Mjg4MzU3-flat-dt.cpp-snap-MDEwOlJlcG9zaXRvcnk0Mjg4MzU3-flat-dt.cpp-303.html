
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 38, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</h3>
            <pre><code>1  const int TRnd::RndSeed=0;
2  const int TRnd::a=16807;
3  const int TRnd::m=2147483647;
4  const int TRnd::q=127773; 
5  const int TRnd::r=2836; 
6  void TRnd::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
7    XLoadHd(Nm);
8    Seed=TXmlObjSer::GetIntArg(XmlTok, &quot;Seed&quot;);
9  }
10  void TRnd::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
11    XSaveBETagArg(Nm, &quot;Seed&quot;, TInt::GetStr(Seed));
12  }
13  void TRnd::PutSeed(const int&amp; _Seed){
14    Assert(_Seed&gt;=0);
15    if (_Seed==0){
16      Seed=abs(int(TSysTm::GetPerfTimerTicks()));
17    } else {
18      Seed=_Seed;
19    }
20  }
21  void TRnd::Move(const int&amp; Steps){
22    for (int StepN=0; StepN&lt;Steps; StepN++){GetNextSeed();}
23  }
24  bool TRnd::Check(){
25    int PSeed=Seed; Seed=1;
26    for (int SeedN=0; SeedN&lt;10000; SeedN++){GetNextSeed();}
27    bool Ok=Seed==1043618065; Seed=PSeed; return Ok;
28  }
29  int TRnd::GetUniDevInt(const int&amp; Range){
30    int Seed=GetNextSeed();
31    if (Range==0){return Seed;}
32    else {return Seed%Range;}
33  }
34  uint TRnd::GetUniDevUInt(const uint&amp; Range){
35    uint Seed=uint(GetNextSeed()%0x10000)*0x10000+uint(GetNextSeed()%0x10000);
36    if (Range==0){return Seed;}
37    else {return Seed%Range;}
38  }
39  int64 TRnd::GetUniDevInt64(const int64&amp; Range){
40    const int64 RndVal = int64((uint64(GetUniDevInt())&lt;&lt;32) | uint64(GetUniDevInt()));
41    if (Range==0){return RndVal;}
42    else {return RndVal%Range;}
43  }
44  uint64 TRnd::GetUniDevUInt64(const uint64&amp; Range){
45   const uint64 RndVal = uint64((uint64(GetUniDevInt())&lt;&lt;32) | uint64(GetUniDevInt()));
46   if (Range==0){return RndVal;}
47   else {return RndVal%Range;}
48  }
49  double TRnd::GetNrmDev(){
50    double v1, v2, rsq;
51    do {
52      v1=2.0*GetUniDev()-1.0; 
53      v2=2.0*GetUniDev()-1.0; 
54      rsq=v1*v1+v2*v2; 
55    } while ((rsq&gt;=1.0)||(rsq==0.0)); 
56    double fac=sqrt(-2.0*log(rsq)/rsq); 
57    return v1*fac;
58  }
59  double TRnd::GetNrmDev(
60   const double&amp; Mean, const double&amp; SDev, const double&amp; Mn, const double&amp; Mx){
61    double Val=Mean+GetNrmDev()*SDev;
62    if (Val&lt;Mn){Val=Mn;}
63    if (Val&gt;Mx){Val=Mx;}
64    return Val;
65  }
66  double TRnd::GetExpDev(){
67    double UniDev;
68    do {
69      UniDev=GetUniDev();
70    } while (UniDev==0.0);
71    return -log(UniDev);
72  }
73  double TRnd::GetExpDev(const double&amp; Lambda) {
74    return GetExpDev()/Lambda;
75  }
76  double TRnd::GetGammaDev(const int&amp; Order){
77    int j;
78    double am,e,s,v1,v2,x,y;
79    if (Order&lt;1){Fail;}
80    if (Order&lt;6) {
81      x=1.0;
82      for (j=1;j&lt;=Order;j++) x *=GetUniDev();
83      x = -log(x);
84    } else {
85      do {
86        do {
87          do {
88            v1=2.0*GetUniDev()-1.0;
89            v2=2.0*GetUniDev()-1.0;
90          } while (v1*v1+v2*v2 &gt; 1.0);
91          y=v2/v1;
92          am=Order-1;
93          s=sqrt(2.0*am+1.0);
94          x=s*y+am;
95        } while (x &lt;= 0.0);
96        e=(1.0+y*y)*exp(am*log(x/am)-s*y);
97      } while (GetUniDev()&gt;e);
98    }
99    return x;
100  }
101  double TRnd::GetPoissonDev(const double&amp; Mean){
102    static double sq,alxm,g,oldm=(-1.0);
103    double em,t,y;
104    if (Mean &lt; 12.0) {
105      if (Mean != oldm) {
106        oldm=Mean;
107        g=exp(-Mean);
108      }
109      em = -1;
110      t=1.0;
111      do {
112        ++em;
113        t *= GetUniDev();
114      } while (t&gt;g);
115    } else {
116      if (Mean != oldm) {
117        oldm=Mean;
118        sq=sqrt(2.0*Mean);
119        alxm=log(Mean);
120        g=Mean*alxm-TSpecFunc::LnGamma(Mean+1.0);
121      }
122      do {
123        do {
124          y=tan(TMath::Pi*GetUniDev());
125          em=sq*y+Mean;
126        } while (em &lt; 0.0);
127        em=floor(em);
128        t=0.9*(1.0+y*y)*exp(em*alxm-TSpecFunc::LnGamma(em+1.0)-g);
129      } while (GetUniDev()&gt;t);
130    }
131    return em;
132  }
133  double TRnd::GetBinomialDev(const double&amp; Prb, const int&amp; Trials){
134    int j;
135    static int nold=(-1);
136    double am,em,g,angle,p,bnl,sq,t,y;
137    static double pold=(-1.0),pc,plog,pclog,en,oldg;
138    p=(Prb &lt;= 0.5 ? Prb : 1.0-Prb);
139    am=Trials*p;
140    if (Trials &lt; 25) {
141      bnl=0.0;
142      for (j=1;j&lt;=Trials;j++)
143        if (GetUniDev() &lt; p) ++bnl;
144    } else if (am &lt; 1.0) {
145      g=exp(-am);
146      t=1.0;
147      for (j=0;j&lt;=Trials;j++) {
148        t *= GetUniDev();
149        if (t &lt; g) break;
150      }
151      bnl=(j &lt;= Trials ? j : Trials);
152    } else {
153      if (Trials != nold) {
154        en=Trials;
155        oldg=TSpecFunc::LnGamma(en+1.0);
156        nold=Trials;
157      } if (p != pold) {
158        pc=1.0-p;
159        plog=log(p);
160        pclog=log(pc);
161        pold=p;
162      }
163      sq=sqrt(2.0*am*pc);
164      do {
165        do {
166          angle=TMath::Pi*GetUniDev();
167          y=tan(angle);
168          em=sq*y+am;
169        } while (em &lt; 0.0 || em &gt;= (en+1.0));
170        em=floor(em);
171        t=1.2*sq*(1.0+y*y)*exp(oldg-(em+1.0)
172          -TSpecFunc::LnGamma(en-em+1.0)+em*plog+(en-em)*pclog);
173      } while (GetUniDev() &gt; t);
174      bnl=em;
175    }
176    if (p != Prb) bnl=Trials-bnl;
177    return bnl;
178  }
179  TRnd TRnd::LoadTxt(TILx&amp; Lx){
180    return TRnd(Lx.GetInt());
181  }
182  void TRnd::SaveTxt(TOLx&amp; Lx) const {
183    Lx.PutInt(Seed);
184  }
185  void TMem::Resize(const int&amp; _MxBfL){
186    if (_MxBfL&lt;=MxBfL){return;}
187    else {if (MxBfL*2&lt;_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
188    char* NewBf=new char[MxBfL]; IAssert(NewBf!=NULL);
189    if (BfL&gt;0){memcpy(NewBf, Bf, BfL);}
190    if (Bf!=NULL){delete[] Bf;}
191    Bf=NewBf;
192  }
193  TMem::TMem(const TStr&amp; Str):
194    MxBfL(Str.Len()), BfL(MxBfL), Bf(NULL){
195    if (MxBfL&gt;0){
196      Bf=new char[MxBfL];
197      if (BfL&gt;0){memcpy(Bf, Str.CStr(), BfL);}
198    }
199  }
200  void TMem::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
201    XSaveHdArg(Nm, &quot;BfL&quot;, TInt::GetStr(BfL));
202    SOut.PutStr(TXmlLx::GetXmlStrFromPlainMem(*this));
203  }
204  bool TMem::DoFitStr(const TStr&amp; Str) const {
205    return DoFitLen(Str.Len()+1);
206  }
207  TMem&amp; TMem::operator+=(const char&amp; Ch){
208    if (BfL==MxBfL){Resize(BfL+1);}
209    Bf[BfL]=Ch; BfL++; return *this;
210  }
211  TMem&amp; TMem::operator+=(const TMem&amp; Mem){
212    int LBfL=Mem.Len(); if (BfL+LBfL&gt;MxBfL){Resize(BfL+LBfL);}
213    if (LBfL&gt;0){memcpy(&amp;Bf[BfL], Mem(), LBfL);}
214    BfL+=LBfL; return *this;
215  }
216  TMem&amp; TMem::operator+=(const TStr&amp; Str){
217    int LBfL=Str.Len(); if (BfL+LBfL&gt;MxBfL){Resize(BfL+LBfL);}
218    if (LBfL&gt;0){memcpy(Bf+BfL, Str.CStr(), LBfL);}
219    BfL+=LBfL; return *this;
220  }
221  TMem&amp; TMem::operator+=(const PSIn&amp; SIn){
222    int LBfL=SIn-&gt;Len(); if (BfL+LBfL&gt;MxBfL){Resize(BfL+LBfL);}
223    char* LBf=new char[LBfL];
224    SIn-&gt;GetBf(LBf, LBfL);
225    if (LBfL&gt;0){memcpy(Bf+BfL, LBf, LBfL);}
226    delete[] LBf;
227    BfL+=LBfL; return *this;
228  }
229  void TMem::Del(const int&amp; BChN, const int&amp; EChN){
230    if (BChN&gt;EChN){return;}
231    if ((BChN==0)&amp;&amp;(EChN==BfL-1)){Clr(); return;}
232    IAssert((0&lt;=BChN)&amp;&amp;(BChN&lt;=EChN)&amp;&amp;(EChN&lt;BfL));
233    memmove(Bf+BChN, Bf+EChN+1, BfL-EChN-1);
234    BfL-=(EChN-BChN+1);
235  }
236  void TMem::AddBf(const void* _Bf, const int&amp; _BfL){
237  	IAssert((_BfL&gt;=0) &amp;&amp; (_Bf != NULL));
238    Reserve(Len() + _BfL, false);
239    memcpy(Bf + BfL, _Bf, _BfL);  
240     BfL+=_BfL;
241  }
242  TStr TMem::GetAsStr(const char&amp; NewNullCh) const {
243    if (NewNullCh!=&#x27;\0&#x27;){
244      TChA ChA(*this);
245      ChA.ChangeCh(&#x27;\0&#x27;, NewNullCh);
246      return ChA;
247    } else {
248      return TStr(*this);
249    }
250  }
251  TMemIn::TMemIn(const TMem&amp; _Mem, const int&amp; _BfC):
252    TSBase(&quot;Input-Memory&quot;), TSIn(&quot;Input-Memory&quot;), Mem(), Bf(_Mem()), BfC(_BfC), BfL(_Mem.Len()){}
253  int TMemIn::GetBf(const void* LBf, const TSize&amp; LBfL){
254    Assert(TSize(BfC+LBfL)&lt;=TSize(BfL));
255    int LBfS=0;
256    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
257      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
258    return LBfS;
259  }
260  bool TMemIn::GetNextLnBf(TChA&amp; LnChA){
261    FailR(TStr::Fmt(&quot;TMemIn::GetNextLnBf: not implemented&quot;).CStr());
262    return false;
263  }
264  TMemOut::TMemOut(const PMem&amp; _Mem): TSBase(&quot;Output-Memory&quot;), TSOut(&quot;Output-Memory&quot;), Mem(_Mem){}
265  int TMemOut::PutBf(const void* LBf, const TSize&amp; LBfL){
266    int LBfS=0;
267    TMem&amp; _Mem=*Mem;
268    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
269      char Ch=((char*)LBf)[LBfC];
270      LBfS+=Ch; _Mem+=Ch;
271    }
272    return LBfS;
273  }
274  void TChA::Resize(const int&amp; _MxBfL){
275    if (_MxBfL&lt;=MxBfL){return;}
276    else {if (MxBfL*2&lt;_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
277    char* NewBf=new char[MxBfL+1]; IAssert(NewBf!=NULL);
278    strcpy(NewBf, Bf);
279    delete[] Bf; Bf=NewBf;
280  }
281  TChA::TChA(const TStr&amp; Str){
282    Bf=new char[(MxBfL=BfL=Str.Len())+1];
283    strcpy(Bf, Str.CStr());
284  }
285  void TChA::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
286    XSaveHdArg(Nm, &quot;BfL&quot;, TInt::GetStr(BfL));
287    SOut.PutStr(TXmlLx::GetXmlStrFromPlainStr(*this));
288  }
289  TChA&amp; TChA::operator=(const TChA&amp; ChA){
290    if (this!=&amp;ChA){
291      if (ChA.BfL&gt;MxBfL){delete[] Bf; Bf=new char[(MxBfL=ChA.BfL)+1];}
292      BfL=ChA.BfL; strcpy(Bf, ChA.CStr());
293    }
294    return *this;
295  }
296  TChA&amp; TChA::operator=(const TStr&amp; Str){
297    if (Str.Len()&gt;MxBfL){delete[] Bf; Bf=new char[(MxBfL=Str.Len())+1];}
298    BfL=Str.Len(); strcpy(Bf, Str.CStr());
299    return *this;
300  }
301  TChA&amp; TChA::operator=(const char* CStr){
302    int CStrLen=int(strlen(CStr));
303    if (CStrLen&gt;MxBfL){delete[] Bf; Bf=new char[(MxBfL=CStrLen)+1];}
304    BfL=CStrLen; strcpy(Bf, CStr);
305    return *this;
306  }
307  TChA&amp; TChA::operator+=(const TMem&amp; Mem) {
308    Resize(BfL+Mem.Len());
309    strcpy(Bf+BfL, Mem.GetBf()); BfL+=Mem.Len(); return *this;
310  }
311  TChA&amp; TChA::operator+=(const TChA&amp; ChA){
312    Resize(BfL+ChA.Len());
313    strcpy(Bf+BfL, ChA.CStr()); BfL+=ChA.Len(); return *this;
314  }
315  TChA&amp; TChA::operator+=(const TStr&amp; Str){
316    Resize(BfL+Str.Len());
317    strcpy(Bf+BfL, Str.CStr()); BfL+=Str.Len(); return *this;
318  }
319  TChA&amp; TChA::operator+=(const char* CStr){
320    int CStrLen=(int)strlen(CStr); Resize(BfL+CStrLen);
321    strcpy(Bf+BfL, CStr); BfL+=CStrLen; return *this;
322  }
323  void TChA::Ins(const int&amp; BChN, const char* CStr){
324    Assert((0&lt;=BChN)&amp;&amp;(BChN&lt;=BfL)); /&amp;bsol;** ali je &lt;= v (BChN&lt;=BfL) upravicen?
325    int CStrLen=int(strlen(CStr)); Resize(BfL+CStrLen);
326    memmove(Bf+BChN+CStrLen, Bf+BChN, BfL-BChN+1);
327    memmove(Bf+BChN, CStr, CStrLen); BfL+=CStrLen;
328  }
329  void TChA::Del(const int&amp; ChN){
330    Assert((0&lt;=ChN)&amp;&amp;(ChN&lt;BfL));
331    memmove(Bf+ChN, Bf+ChN+1, BfL-ChN);
332    BfL--;
333  }
334  void TChA::Trunc(){
335    int BChN=0; while ((BChN&lt;BfL)&amp;&amp;(GetCh(BChN)&lt;=&#x27; &#x27;)){BChN++;}
336    int EChN=BfL-1; while ((0&lt;=EChN)&amp;&amp;(GetCh(EChN)&lt;=&#x27; &#x27;)){EChN--;}
337    if (BChN&lt;=EChN){
338      for (int ChN=BChN; ChN&lt;=EChN; ChN++){
339        PutCh(ChN-BChN, GetCh(ChN));}
340      Trunc(EChN-BChN+1);
341    } else {
342      Clr();
343    }
344  }
345  void TChA::Reverse(){
346    for (int ChN=0; ChN&lt;BfL/2; ChN++){
347      char Ch=Bf[ChN];
348      Bf[ChN]=Bf[BfL-ChN-1];
349      Bf[BfL-ChN-1]=Ch;
350    }
351  }
352  TChA TChA::GetSubStr(const int&amp; _BChN, const int&amp; _EChN) const {
353    int BChN=TInt::GetMx(_BChN, 0);
354    int EChN=TInt::GetMn(_EChN, Len()-1);
355    int Chs=EChN-BChN+1;
356    if (Chs&lt;=0){return TStr::GetNullStr();}
357    else if (Chs==Len()){return *this;}
358    else {
359      return TChA(CStr()+BChN, Chs);
360    }
361  }
362  int TChA::CountCh(const char&amp; Ch, const int&amp; BChN) const {
363    int ChN=TInt::GetMx(BChN, 0);
364    const int ThisLen=Len();
365    int Cnt = 0;
366    while (ChN&lt;ThisLen){if (Bf[ChN]==Ch){ Cnt++;} ChN++;}
367    return Cnt;
368  }
369  int TChA::SearchCh(const char&amp; Ch, const int&amp; BChN) const {
370    int ChN=TInt::GetMx(BChN, 0);
371    const int ThisLen=Len();
372    while (ChN&lt;ThisLen){if (Bf[ChN]==Ch){return ChN;} ChN++;}
373    return -1;
374  }
375  int TChA::SearchChBack(const char&amp; Ch, int BChN) const {
376    if (BChN &gt;= Len() || BChN &lt; 0) { BChN = Len()-1; }
377    for (int i = BChN; i &gt;= 0; i--) {
378      if (GetCh(i) == Ch) { return i; }
379    }
380    return -1;
381  }
382  int TChA::SearchStr(const TChA&amp; Str, const int&amp; BChN) const {
383    return SearchStr(Str.CStr(), BChN);
384  }
385  int TChA::SearchStr(const TStr&amp; Str, const int&amp; BChN) const {
386    return SearchStr(Str.CStr(), BChN);
387  }
388  int TChA::SearchStr(const char* CStr, const int&amp; BChN) const {
389    const char* BegPos=strstr(Bf+BChN, CStr);
390    if (BegPos==NULL){return -1;}
391    else {return int(BegPos-Bf);}
392  }
393  bool TChA::IsPrefix(const char* CStr, const int&amp; BChN) const {
394    if (BChN+(int)strlen(CStr)&gt;Len()){return false;}
395    const char* B = Bf+BChN;
396    const char* C = CStr;
397    while (*C!=0 &amp;&amp; *B==*C) {
398      B++; C++;
399    }
400    if (*C==0){return true;}
401    else {return false;}
402  }
403  bool TChA::IsPrefix(const TStr&amp; Str) const {
404    return IsPrefix(Str.CStr());
405  }
406  bool TChA::IsPrefix(const TChA&amp; Str) const {
407    return IsPrefix(Str.CStr());
408  }
409  bool TChA::IsSuffix(const char* CStr) const {
410    if ((int)strlen(CStr) &gt; Len()) { return false; }
411    const char* E = Bf+Len()-1;
412    const char* C = CStr+strlen(CStr)-1;
413    while (C &gt;= CStr &amp;&amp; *E==*C) {
414      E--;  C--;
415    }
416    if (C+1 == CStr) { return true; }
417    else { return false; }
418  }
419  bool TChA::IsSuffix(const TStr&amp; Str) const {
420    return IsSuffix(Str.CStr());
421  }
422  bool TChA::IsSuffix(const TChA&amp; Str) const {
423    return IsSuffix(Str.CStr());
424  }
425  void TChA::ChangeCh(const char&amp; SrcCh, const char&amp; DstCh){
426    int StrLen=Len();
427    for (int ChN=0; ChN&lt;StrLen; ChN++){if (Bf[ChN]==SrcCh){Bf[ChN]=DstCh;}}
428  }
429  TChA&amp; TChA::ToLc() {
430    char *c = Bf;
431    while (*c) {
432      *c = (char) tolower(*c);  c++;
433    }
434    return *this;
435  }
436  TChA&amp; TChA::ToUc() {
437    char *c = Bf;
438    while (*c) {
439      *c = (char) toupper(*c); c++;
440    }
441    return *this;
442  }
443  TChA&amp; TChA::ToTrunc(){
444    int StrLen=Len(); int BChN=0; int EChN=StrLen-1;
445    while ((BChN&lt;StrLen)&amp;&amp;TCh::IsWs(GetCh(BChN))){BChN++;}
446    while ((EChN&gt;=0)&amp;&amp;TCh::IsWs(GetCh(EChN))){EChN--;}
447    if ((BChN!=0)||(EChN!=StrLen-1)){
448      int DstChN=0;
449      for (int SrcChN=BChN; SrcChN&lt;=EChN; SrcChN++){
450        PutCh(DstChN, GetCh(SrcChN)); DstChN++;}
451      Trunc(DstChN);
452    }
453    return *this;
454  }
455  void TChA::CompressWs(){
456    int StrLen=Len(); int SrcChN=0; int DstChN=0;
457    while ((SrcChN&lt;StrLen)&amp;&amp;TCh::IsWs(GetCh(SrcChN))){SrcChN++;}
458    while (SrcChN&lt;StrLen){
459      if ((TCh::IsWs(GetCh(SrcChN)))&amp;&amp;(DstChN&gt;0)&amp;&amp;(TCh::IsWs(GetCh(DstChN-1)))){
460        SrcChN++;
461      } else {
462        PutCh(DstChN, GetCh(SrcChN)); SrcChN++; DstChN++;
463      }
464    }
465    if ((DstChN&gt;0)&amp;&amp;(TCh::IsWs(GetCh(DstChN-1)))){DstChN--;}
466    Trunc(DstChN);
467  }
468  void TChA::Swap(const int&amp; ChN1, const int&amp; ChN2){
469    char Ch=GetCh(ChN1);
470    PutCh(ChN1, GetCh(ChN2));
471    PutCh(ChN2, Ch);
472  }
473  void TChA::Swap(TChA&amp; ChA) {
474    ::Swap(MxBfL, ChA.MxBfL);
475    ::Swap(BfL, ChA.BfL);
476    ::Swap(Bf, ChA.Bf);
477  }
478  int TChA::GetPrimHashCd() const {
479    return TStrHashF_DJB::GetPrimHashCd(CStr());
480  }
481  int TChA::GetSecHashCd() const {
482    return TStrHashF_DJB::GetSecHashCd(CStr());
483  }
484  void TChA::LoadTxt(const PSIn&amp; SIn, TChA&amp; ChA){
485    delete[] ChA.Bf;
486    ChA.Bf=new char[(ChA.MxBfL=ChA.BfL=SIn-&gt;Len())+1];
487    SIn-&gt;GetBf(ChA.CStr(), SIn-&gt;Len()); ChA.Bf[ChA.BfL]=0;
488  }
489  void TChA::SaveTxt(const PSOut&amp; SOut) const {
490    SOut-&gt;SaveBf(CStr(), Len());
491  }
492  TChAIn::TChAIn(const TChA&amp; ChA, const int&amp; _BfC):
493    TSBase(&quot;Input-Char-Array&quot;), TSIn(&quot;Input-Char-Array&quot;), Bf(ChA.CStr()), BfC(_BfC), BfL(ChA.Len()){}
494  int TChAIn::GetBf(const void* LBf, const TSize&amp; LBfL){
495    Assert(TSize(BfC+LBfL)&lt;=TSize(BfL));
496    int LBfS=0;
497    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
498      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
499    return LBfS;
500  }
501  bool TChAIn::GetNextLnBf(TChA&amp; LnChA){
502    FailR(TStr::Fmt(&quot;TChAIn::GetNextLnBf: not implemented&quot;).CStr());
503    return false;
504  }
505  bool TRStr::IsUc() const {
506    int StrLen=Len();
507    for (int ChN=0; ChN&lt;StrLen; ChN++){
508      if ((&#x27;a&#x27;&lt;=Bf[ChN])&amp;&amp;(Bf[ChN]&lt;=&#x27;z&#x27;)){return false;}}
509    return true;
510  }
511  void TRStr::ToUc(){
512    int StrLen=Len();
513    for (int ChN=0; ChN&lt;StrLen; ChN++){
514      Bf[ChN]=(char)toupper(Bf[ChN]);}}
515  bool TRStr::IsLc() const {
516    int StrLen=Len();
517    for (int ChN=0; ChN&lt;StrLen; ChN++){
518      if ((&#x27;A&#x27;&lt;=Bf[ChN])&amp;&amp;(Bf[ChN]&lt;=&#x27;Z&#x27;)){return false;}}
519    return true;
520  }
521  void TRStr::ToLc(){
522    int StrLen=Len();
523    for (int ChN=0; ChN&lt;StrLen; ChN++){
524      Bf[ChN]=(char)tolower(Bf[ChN]);}
525  }
526  void TRStr::ToCap(){
527    int StrLen=Len();
528    if (StrLen&gt;0){
529      Bf[0]=(char)toupper(Bf[0]);}
530    for (int ChN=1; ChN&lt;StrLen; ChN++){
531      Bf[ChN]=(char)tolower(Bf[ChN]);}
532  }
533  void TRStr::ConvUsFromYuAscii(){
534    int StrLen=Len();
535    for (int ChN=0; ChN&lt;StrLen; ChN++){
536      Bf[ChN]=TCh::GetUsFromYuAscii(Bf[ChN]);}
537  }
538  int TRStr::CmpI(const char* p, const char* r){
539    if (!p){return r ? (*r ? -1 : 0) : 0;}
540    if (!r){return (*p ? 1 : 0);}
541    while (*p &amp;&amp; *r){
542      int i=int(toupper(*p++))-int(toupper(*r++));
543      if (i!=0){return i;}
544    }
545    return int(toupper(*p++))-int(toupper(*r++));
546  }
547  int TRStr::GetPrimHashCd() const {
548    return TStrHashF_DJB::GetPrimHashCd(Bf);
549  }
550  int TRStr::GetSecHashCd() const {
551    return TStrHashF_DJB::GetSecHashCd(Bf);
552  }
553  TRStr* TStr::GetRStr(const char* CStr){
554    int CStrLen;
555    if (CStr==NULL){CStrLen=0;} else {CStrLen=int(strlen(CStr));}
556    if (CStrLen==0){return TRStr::GetNullRStr();}
557    else {return new TRStr(CStr);}
558  }
559  void TStr::Optimize(){
560    char* CStr=RStr-&gt;CStr(); int CStrLen=int(strlen(CStr));
561    TRStr* NewRStr;
562    if (CStrLen==0){NewRStr=TRStr::GetNullRStr();}
563    else {NewRStr=RStr;}
564    NewRStr-&gt;MkRef(); RStr-&gt;UnRef(); RStr=NewRStr;
565  }
566  void TStr::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
567    XLoadHd(Nm);
568    TStr TokStr=XmlTok-&gt;GetTokStr(false);
569    operator=(TokStr);
570  }
571  void TStr::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
572    TStr XmlStr=TXmlLx::GetXmlStrFromPlainStr(*this);
573    if (XmlStr.Empty()){XSaveBETag(Nm);}
574    else {XSaveHd(Nm); SOut.PutStr(XmlStr);}
575  }
576  TStr&amp; TStr::ToUc(){
577    TRStr* NewRStr=new TRStr(RStr-&gt;CStr()); NewRStr-&gt;ToUc();
578    RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
579    Optimize(); return *this;
580  }
581  TStr&amp; TStr::ToLc(){
582    TRStr* NewRStr=new TRStr(RStr-&gt;CStr()); NewRStr-&gt;ToLc();
583    RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
584    Optimize(); return *this;
585  }
586  TStr&amp; TStr::ToCap(){
587    TRStr* NewRStr=new TRStr(RStr-&gt;CStr()); NewRStr-&gt;ToCap();
588    RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
589    Optimize(); return *this;
590  }
591  TStr&amp; TStr::ToTrunc(){
592    int ThisLen=Len(); char* ThisBf=CStr();
593    int BChN=0; int EChN=ThisLen-1;
594    while ((BChN&lt;ThisLen)&amp;&amp;TCh::IsWs(ThisBf[BChN])){BChN++;}
595    while ((EChN&gt;=0)&amp;&amp;TCh::IsWs(ThisBf[EChN])){EChN--;}
596    *this=GetSubStr(BChN, EChN);
597    return *this;
598  }
599  TStr&amp; TStr::ConvUsFromYuAscii(){
600    TRStr* NewRStr=new TRStr(RStr-&gt;CStr()); NewRStr-&gt;ConvUsFromYuAscii();
601    RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
602    Optimize(); return *this;
603  }
604  TStr&amp; TStr::ToHex(){
605    TChA ChA;
606    int StrLen=Len();
607    for (int ChN=0; ChN&lt;StrLen; ChN++){
608      uchar Ch=uchar(RStr-&gt;Bf[ChN]);
609      char MshCh=TCh::GetHexCh((Ch/16)%16);
610      char LshCh=TCh::GetHexCh(Ch%16);
611      ChA+=MshCh; ChA+=LshCh;
612    }
613    *this=ChA;
614    return *this;
615  }
616  TStr&amp; TStr::FromHex(){
617    int StrLen=Len(); IAssert(StrLen%2==0);
618    TChA ChA; int ChN=0;
619    while (ChN&lt;StrLen){
620      char MshCh=RStr-&gt;Bf[ChN]; ChN++;
621      char LshCh=RStr-&gt;Bf[ChN]; ChN++;
622      uchar Ch=uchar(TCh::GetHex(MshCh)*16+TCh::GetHex(LshCh));
623      ChA+=Ch;
624    }
625    *this=ChA;
626    return *this;
627  }
628  TStr TStr::GetSubStr(const int&amp; _BChN, const int&amp; _EChN) const {
629    int StrLen=Len();
630    int BChN=TInt::GetMx(_BChN, 0);
631    int EChN=TInt::GetMn(_EChN, StrLen-1);
632    int Chs=EChN-BChN+1;
633    if (Chs&lt;=0){return TStr();}
634    else if (Chs==StrLen){return *this;}
635    else {
636      char* Bf=new char[Chs+1]; strncpy(Bf, CStr()+BChN, Chs); Bf[Chs]=0;
637      TStr Str(Bf); delete[] Bf;
638      return Str;
639    }
640  }
641  void TStr::InsStr(const int&amp; BChN, const TStr&amp; Str){
642    int ThisLen=Len();
643    IAssert((0&lt;=BChN)&amp;&amp;(BChN&lt;=ThisLen));
644    TStr NewStr;
645    if (BChN==0){
646      NewStr=Str+*this;
647    } else
648    if (BChN==ThisLen){
649      NewStr=*this+Str;
650    } else {
651      NewStr=GetSubStr(0, BChN-1)+Str+GetSubStr(BChN, ThisLen-1);
652    }
653    *this=NewStr;
654  }
655  void TStr::DelChAll(const char&amp; Ch){
656    TChA ChA(*this);
657    int ChN=ChA.SearchCh(Ch);
658    while (ChN!=-1){
659      ChA.Del(ChN);
660      ChN=ChA.SearchCh(Ch);
661    }
662    *this=ChA;
663  }
664  void TStr::DelSubStr(const int&amp; _BChN, const int&amp; _EChN){
665    int BChN=TInt::GetMx(_BChN, 0);
666    int EChN=TInt::GetMn(_EChN, Len()-1);
667    int Chs=Len()-(EChN-BChN+1);
668    if (Chs==0){Clr();}
669    else if (Chs&lt;Len()){
670      char* Bf=new char[Chs+1]; strncpy(Bf, CStr(), BChN);
671      strncpy(Bf+BChN, CStr()+EChN+1, Len()-EChN-1); Bf[Chs]=0;
672      TStr Str(Bf); delete[] Bf;
673      *this=Str;
674    }
675  }
676  bool TStr::DelStr(const TStr&amp; Str){
677    int ChN=SearchStr(Str);
678    if (ChN==-1){
679      return false;
680    } else {
681      DelSubStr(ChN, ChN+Str.Len()-1);
682      return true;
683    }
684  }
685  TStr TStr::LeftOf(const char&amp; SplitCh) const {
686    int ThisLen=Len(); const char* ThisBf=CStr();
687    int ChN=0;
688    while ((ChN&lt;ThisLen)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN++;}
689    return (ChN==ThisLen) ? &quot;&quot; : GetSubStr(0, ChN-1);
690  }
691  TStr TStr::LeftOfLast(const char&amp; SplitCh) const {
692    const char* ThisBf=CStr();
693    int ChN=Len()-1;
694    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN--;}
695    return (ChN==-1) ? &quot;&quot; : GetSubStr(0, ChN-1);
696  }
697  TStr TStr::RightOf(const char&amp; SplitCh) const {
698    int ThisLen=Len(); const char* ThisBf=CStr();
699    int ChN=0;
700    while ((ChN&lt;ThisLen)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN++;}
701    return (ChN==ThisLen) ? &quot;&quot; : GetSubStr(ChN+1, ThisLen-1);
702  }
703  TStr TStr::RightOfLast(const char&amp; SplitCh) const {
704    int ThisLen=Len(); const char* ThisBf=CStr();
705    int ChN=Len()-1;
706    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN--;}
707    return (ChN==-1) ? &quot;&quot; : GetSubStr(ChN+1, ThisLen-1);
708  }
709  void TStr::SplitOnCh(TStr&amp; LStr, const char&amp; SplitCh, TStr&amp; RStr) const {
710    int ThisLen=Len(); const char* ThisBf=CStr();
711    int ChN=0;
712    while ((ChN&lt;ThisLen)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN++;}
713    if (ChN==ThisLen){
714      LStr=GetSubStr(0, ThisLen-1); RStr=&quot;&quot;;
715    } else {
716      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
717    }
718  }
719  void TStr::SplitOnLastCh(TStr&amp; LStr, const char&amp; SplitCh, TStr&amp; RStr) const {
720    int ThisLen=Len(); const char* ThisBf=CStr();
721    int ChN=Len()-1;
722    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN--;}
723    if (ChN==-1){
724      LStr=&quot;&quot;; RStr=*this;
725    } else
726    if (ChN==0){
727      LStr=&quot;&quot;; RStr=GetSubStr(1, ThisLen-1);
728    } else {
729      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
730    }
731  }
732  void TStr::SplitOnAllCh(
733   const char&amp; SplitCh, TStrV&amp; StrV, const bool&amp; SkipEmpty) const {
734    StrV.Clr();
735    char* Bf=new char[Len()+1];
736    strcpy(Bf, CStr());
737    char* CurStrBf=Bf;
738    forever{
739      char* BfC=CurStrBf;
740      while ((*BfC!=0)&amp;&amp;(*BfC!=SplitCh)){BfC++;}
741      bool IsEnd=(*BfC==&#x27;\0&#x27;);
742      *BfC=0;
743      if ((BfC&gt;CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
744      if (IsEnd){break;}
745      CurStrBf=BfC+1;
746    }
747    delete[] Bf;
748  }
749  void TStr::SplitOnAllAnyCh(
750   const TStr&amp; SplitChStr, TStrV&amp; StrV, const bool&amp; SkipEmpty) const {
751    StrV.Clr();
752    char* Bf=new char[Len()+1];
753    strcpy(Bf, CStr());
754    char* CurStrBf=Bf; 
755    const char* SplitChBf=SplitChStr.CStr();
756    forever{
757      char* BfC=CurStrBf; 
758      while (*BfC!=0){
759        const char* SplitChBfC=SplitChBf; 
760        while ((*SplitChBfC!=0)&amp;&amp;(*SplitChBfC!=*BfC)){SplitChBfC++;}
761        if (*SplitChBfC!=0){break;} 
762        BfC++;
763      }
764      bool IsEnd=(*BfC==0);
765      *BfC=0;
766      if ((BfC&gt;CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
767      if (IsEnd){break;}
768      CurStrBf=BfC+1;
769    }
770    delete[] Bf;
771  }
772  void TStr::SplitOnWs(TStrV&amp; StrV) const {
773    StrV.Clr();
774    char* Bf=new char[Len()+1];
775    strcpy(Bf, CStr());
776    char* StrBf=Bf;
777    forever{
778      while ((*StrBf!=0)&amp;&amp;(TCh::IsWs(*StrBf))){StrBf++;}
779      char* BfC=StrBf;
780      while ((*BfC!=0)&amp;&amp;(!TCh::IsWs(*BfC))){BfC++;}
781      bool IsEnd=(*BfC==&#x27;\0&#x27;);
782      *BfC=0;
783      if (BfC&gt;StrBf){StrV.Add(TStr(StrBf));}
784      if (IsEnd){break;}
785      StrBf=BfC+1;
786    }
787    delete[] Bf;
788  }
789  void TStr::SplitOnNonAlNum(TStrV&amp; StrV) const {
790    StrV.Clr();
791    char* Bf=new char[Len()+1];
792    strcpy(Bf, CStr());
793    char* StrBf=Bf;
794    forever{
795      while ((*StrBf!=0)&amp;&amp;(!TCh::IsAlNum(*StrBf))){StrBf++;}
796      char* BfC=StrBf;
797      while ((*BfC!=0)&amp;&amp;(TCh::IsAlNum(*BfC))){BfC++;}
798      bool IsEnd=(*BfC==&#x27;\0&#x27;);
799      *BfC=0;
800      if (BfC&gt;StrBf){StrV.Add(TStr(StrBf));}
801      if (IsEnd){break;}
802      StrBf=BfC+1;
803    }
804    delete[] Bf;
805  }
806  void TStr::SplitOnStr(const TStr&amp; SplitStr, TStrV&amp; StrV) const {
807    StrV.Clr();
808    int SplitStrLen=SplitStr.Len();
809    int PrevChN=0; int ChN=0;
810    while ((ChN=SearchStr(SplitStr, ChN))!=-1){
811      TStr SubStr=GetSubStr(PrevChN, ChN-1);
812      StrV.Add(SubStr);
813      PrevChN=ChN=ChN+SplitStrLen;
814    }
815    TStr LastSubStr=GetSubStr(PrevChN, Len()-1);
816    StrV.Add(LastSubStr);
817  }
818  void TStr::SplitOnStr(TStr&amp; LeftStr, const TStr&amp; MidStr, TStr&amp; RightStr) const {
819    const int ChN=SearchStr(MidStr);
820    if (ChN==-1){
821      LeftStr=*this; RightStr=GetNullStr();
822    } else {
823      LeftStr=GetSubStr(0, ChN-1);
824      RightStr=GetSubStr(ChN+MidStr.Len(), Len()-1);
825    }
826  }
827  int TStr::CountCh(const char&amp; Ch, const int&amp; BChN) const {
828    const int ThisLen=Len();
829    const char* ThisBf=CStr();
830    int Chs=0;
831    for (int ChN=TInt::GetMx(BChN, 0); ChN&lt;ThisLen; ChN++){
832      if (ThisBf[ChN]==Ch){Chs++;}
833    }
834    return Chs;
835  }
836  int TStr::SearchCh(const char&amp; Ch, const int&amp; BChN) const {
837    int ThisLen=Len(); const char* ThisBf=CStr();
838    int ChN=TInt::GetMx(BChN, 0);
839    while (ChN&lt;ThisLen){
840      if (ThisBf[ChN]==Ch){return ChN;}
841      ChN++;
842    }
843    return -1;
844  }
845  int TStr::SearchChBack(const char&amp; Ch, int BChN) const {
846    const int StrLen=Len();
847    if (BChN==-1||BChN&gt;=StrLen){BChN=StrLen-1;}
848    const char* ThisBf=CStr();
849    const char* Pt=ThisBf + BChN;
850    while (Pt&gt;=ThisBf) {
851      if (*Pt==Ch){return (int)(Pt-ThisBf);}
852      Pt--;
853    }
854    return -1;
855  }
856  int TStr::SearchStr(const TStr&amp; Str, const int&amp; BChN) const {
857    int NrBChN=TInt::GetMx(BChN, 0);
858    const char* StrPt=strstr((const char*)CStr()+NrBChN, Str.CStr());
859    if (StrPt==NULL){return -1;}
860    else {return int(StrPt-CStr());}
861  }
862  bool TStr::IsPrefix(const char *Str) const {
863  	size_t len = strlen(Str);
864  	size_t thisLen = Len();
865  	if (len &gt; thisLen) {
866  		return false;
867  	} else {
868          size_t minLen = MIN(len, thisLen);
869  		int cmp = strncmp(Str, RStr-&gt;Bf, minLen);
870  		return cmp == 0;
871  	}
872  }
873  bool TStr::IsSuffix(const char *Str) const {
874  	size_t len = strlen(Str);
875  	size_t thisLen = Len();
876  	if (len &gt; thisLen) {
877  		return false;
878  	} else {
879  		const char *ending = RStr-&gt;Bf + thisLen - len;
880  		int cmp = strncmp(Str, ending, len);
881  		return cmp == 0;
882  	}
883  }
884  int TStr::ChangeCh(const char&amp; SrcCh, const char&amp; DstCh, const int&amp; BChN){
885    int ChN=SearchCh(SrcCh, BChN);
886    if (ChN!=-1){PutCh(ChN, DstCh);}
887    return ChN;
888  }
889  int TStr::ChangeChAll(const char&amp; SrcCh, const char&amp; DstCh){
890    int FirstChN=SearchCh(SrcCh);
891    if (FirstChN==-1){
892      return 0;
893    } else {
894      TRStr* NewRStr=new TRStr(RStr-&gt;CStr());
895      RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
896      char* ThisBf=CStr(); int StrLen=Len(); int Changes=0;
897      for (int ChN=FirstChN; ChN&lt;StrLen; ChN++){
898        if (ThisBf[ChN]==SrcCh){ThisBf[ChN]=DstCh; Changes++;}
899      }
900      Optimize();
901      return Changes;
902    }
903  }
904  int TStr::ChangeStr(const TStr&amp; SrcStr, const TStr&amp; DstStr, const int&amp; BChN){
905    int ChN=SearchStr(SrcStr, BChN);
906    if (ChN==-1){
907      return -1;
908    } else {
909      DelSubStr(ChN, ChN+SrcStr.Len()-1);
910      InsStr(ChN, DstStr);
911      return ChN;
912    }
913  }
914  int TStr::ChangeStrAll(const TStr&amp; SrcStr, const TStr&amp; DstStr, const bool&amp; FromStartP){
915    const int DstStrLen=DstStr.Len();
916    int Changes=0-1; int BChN=0-DstStrLen;
917    do {
918      Changes++;
919      if (FromStartP){BChN=0-DstStrLen;}
920      BChN+=DstStrLen;
921      BChN=ChangeStr(SrcStr, DstStr, BChN);
922    } while (BChN!=-1);
923    return Changes;
924  }
925  bool TStr::IsBool(bool&amp; Val) const {
926    if (operator==(&quot;T&quot;)){Val=true; return true;}
927    else if (operator==(&quot;F&quot;)){Val=false; return true;}
928    else {return false;}
929  }
930  bool TStr::IsInt(
931   const bool&amp; Check, const int&amp; MnVal, const int&amp; MxVal, int&amp; Val) const {
932    int _Val=0;
933    bool Minus=false;
934    TChRet Ch(TStrIn::New(*this));
935    while (TCh::IsWs(Ch.GetCh())){}
936    if (Ch()==&#x27;+&#x27;){Minus=false; Ch.GetCh();}
937    if (Ch()==&#x27;-&#x27;){Minus=true; Ch.GetCh();}
938    if (!TCh::IsNum(Ch())){return false;}
939    _Val=TCh::GetNum(Ch());
940    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
941    if (Minus){_Val=-_Val;}
942    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
943    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
944  }
945  bool TStr::IsUInt(
946   const bool&amp; Check, const uint&amp; MnVal, const uint&amp; MxVal, uint&amp; Val) const {
947    uint _Val=0;
948    TChRet Ch(TStrIn::New(*this));
949    while (TCh::IsWs(Ch.GetCh())){}
950    if (Ch()==&#x27;+&#x27;){Ch.GetCh();}
951    if (!TCh::IsNum(Ch())){return false;}
952    _Val=TCh::GetNum(Ch());
953    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
954    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
955    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
956  }
957  bool TStr::IsHexInt( const bool&amp; Check, const int&amp; MnVal, const int&amp; MxVal, int&amp; Val) const {
958    int _Val=0;
959    bool Minus=false;
960    TChRet Ch(TStrIn::New(*this));
961    while (TCh::IsWs(Ch.GetCh())){}
962    if (Ch()==&#x27;+&#x27;){Minus=false; Ch.GetCh();}
963    if (Ch()==&#x27;-&#x27;){Minus=true; Ch.GetCh();}
964    if (Ch()==&#x27;0&#x27;){
965      Ch.GetCh();
966      if (tolower(Ch())==&#x27;x&#x27; ){
967        Ch.GetCh(); if (Ch.Eof()){return false;}
968      }
969    }
970    if (!Ch.Eof() &amp;&amp; !TCh::IsHex(Ch())){return false;}
971    if (!Ch.Eof()) _Val = TCh::GetHex(Ch());
972    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
973    if (Minus){_Val=-_Val;}
974    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
975    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
976  }
977  bool TStr::IsInt64(
978   const bool&amp; Check, const int64&amp; MnVal, const int64&amp; MxVal, int64&amp; Val) const {
979    int64 _Val=0;
980    bool Minus=false;
981    TChRet Ch(TStrIn::New(*this));
982    while (TCh::IsWs(Ch.GetCh())){}
983    if (Ch()==&#x27;+&#x27;){Minus=false; Ch.GetCh();}
984    if (Ch()==&#x27;-&#x27;){Minus=true; Ch.GetCh();}
985    if (!TCh::IsNum(Ch())){return false;}
986    _Val=TCh::GetNum(Ch());
987    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
988    if (Minus){_Val=-_Val;}
989    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
990    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
991  }
992  bool TStr::IsUInt64(
993   const bool&amp; Check, const uint64&amp; MnVal, const uint64&amp; MxVal, uint64&amp; Val) const {
994    uint64 _Val=0;
995    TChRet Ch(TStrIn::New(*this));
996    while (TCh::IsWs(Ch.GetCh())){}
997    if (Ch()==&#x27;+&#x27;){Ch.GetCh();}
998    if (!TCh::IsNum(Ch())){return false;}
999    _Val=TCh::GetNum(Ch());
1000    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
1001    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
1002    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1003  }
1004  bool TStr::IsHexInt64(
1005   const bool&amp; Check, const int64&amp; MnVal, const int64&amp; MxVal, int64&amp; Val) const {
1006    int64 _Val=0;
1007    bool Minus=false;
1008    TChRet Ch(TStrIn::New(*this));
1009    while (TCh::IsWs(Ch.GetCh())){}
1010    if (Ch()==&#x27;+&#x27;){Minus=false; Ch.GetCh();}
1011    if (Ch()==&#x27;-&#x27;){Minus=true; Ch.GetCh();}
1012    if (Ch()==&#x27;0&#x27;){
1013      Ch.GetCh();
1014      if (tolower(Ch())==&#x27;x&#x27; ){
1015        Ch.GetCh(); if (Ch.Eof()){return false;}
1016      }
1017    }
1018    if (!Ch.Eof()) _Val=TCh::GetHex(Ch());
1019    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
1020    if (Minus){_Val=-_Val;}
1021    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
1022    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1023  }
1024  bool TStr::IsFlt(const bool&amp; Check, const double&amp; MnVal, const double&amp; MxVal,
1025   double&amp; Val, const char&amp; DecDelimCh) const {
1026    TChRet Ch(TStrIn::New(*this));
1027    while (TCh::IsWs(Ch.GetCh())){}
1028    if ((Ch()==&#x27;+&#x27;)||(Ch()==&#x27;-&#x27;)){Ch.GetCh();}
1029    if (!TCh::IsNum(Ch())&amp;&amp;Ch()!=DecDelimCh){return false;}
1030    while (TCh::IsNum(Ch.GetCh())){}
1031    if (Ch()==DecDelimCh){
1032      Ch.GetCh();
1033      while (TCh::IsNum(Ch.GetCh())){}
1034    }
1035    if ((Ch()==&#x27;e&#x27;)||(Ch()==&#x27;E&#x27;)){
1036      Ch.GetCh();
1037      if ((Ch()==&#x27;+&#x27;)||(Ch()==&#x27;-&#x27;)){Ch.GetCh();}
1038      if (!TCh::IsNum(Ch())){return false;}
1039      while (TCh::IsNum(Ch.GetCh())){}
1040    }
1041    if (!Ch.Eof()){return false;}
1042    double _Val=atof(CStr());
1043    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){
1044      return false;
1045    } else {
1046      Val=_Val; return true;
1047    }
1048  }
1049  bool TStr::IsWord(const bool&amp; WsPrefixP, const bool&amp; FirstUcAllowedP) const {
1050    TChRet Ch(TStrIn::New(*this));
1051    if (WsPrefixP){while (TCh::IsWs(Ch.GetCh())){}}
1052    else {Ch.GetCh();}
1053    if (!TCh::IsAlpha(Ch())){return false;}
1054    else if (!FirstUcAllowedP&amp;&amp;(TCh::IsUc(Ch()))){return false;}
1055    while (TCh::IsAlNum(Ch.GetCh())){}
1056    if (!Ch.Eof()){return false;}
1057    return true;
1058  }
1059  bool TStr::IsWs() const {
1060    TChRet Ch(TStrIn::New(*this));
1061    while (TCh::IsWs(Ch.GetCh())){}
1062    return Ch.Eof();
1063  }
1064  bool TStr::IsWcMatch(
1065   const int&amp; StrBChN, const TStr&amp; WcStr, const int&amp; WcStrBChN, TStrV&amp; StarStrV,
1066   const char&amp; StarCh, const char&amp; QuestCh) const {
1067    int StrLen=Len(); int WcStrLen=WcStr.Len();
1068    int StrChN=StrBChN; int WcStrChN=WcStrBChN;
1069    while ((StrChN&lt;StrLen)&amp;&amp;(WcStrChN&lt;WcStrLen)){
1070      if ((WcStr[WcStrChN]==QuestCh)||(GetCh(StrChN)==WcStr[WcStrChN])){
1071        StrChN++; WcStrChN++;
1072      } else
1073      if (WcStr[WcStrChN]==StarCh){
1074        TChA StarChA; 
1075        for (int AfterStrChN=StrChN; AfterStrChN&lt;=StrLen; AfterStrChN++){
1076          if (AfterStrChN&gt;StrChN){
1077            StarChA+=GetCh(AfterStrChN-1);}
1078          if (IsWcMatch(AfterStrChN, WcStr, WcStrChN+1, StarStrV, StarCh, QuestCh)){
1079            StarStrV.Add(StarChA); return true;
1080          }
1081        }
1082        return false;
1083      } else {
1084        return false;
1085      }
1086    }
1087    if (StrChN==StrLen){
1088      for (int AfterWcStrChN=WcStrChN; AfterWcStrChN&lt;WcStrLen; AfterWcStrChN++){
1089        if (WcStr[AfterWcStrChN]!=StarCh){return false;}}
1090      return true;
1091    } else {
1092      return false;
1093    }
1094  }
1095  bool TStr::IsWcMatch(
1096   const TStr&amp; WcStr, TStrV&amp; StarStrV, const char&amp; StarCh, const char&amp; QuestCh) const {
1097    bool WcMatch=IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1098    if (WcMatch){
1099      StarStrV.Reverse();
1100      return true;
1101    } else {
1102      return false;
1103    }
1104  }
1105  bool TStr::IsWcMatch(
1106   const TStr&amp; WcStr, const char&amp; StarCh, const char&amp; QuestCh) const {
1107    TStrV StarStrV;
1108    return IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1109  }
1110  bool TStr::IsWcMatch(const TStr&amp; WcStr, const int&amp; StarStrN, TStr&amp; StarStr) const {
1111    TStrV StarStrV;
1112    if (IsWcMatch(WcStr, StarStrV)){
1113      if (StarStrV.Len()&gt;StarStrN){
1114        StarStr=StarStrV[StarStrV.Len()-StarStrN-1];
1115      } else {
1116        StarStr=&quot;&quot;;
1117      }
1118      return true;
1119    } else {
1120      return false;
1121    }
1122  }
1123  bool TStr::IsWcMatch(const TStr&amp; WcStr) const {
1124    TStrV StarStrV;
1125    return IsWcMatch(0, WcStr, 0, StarStrV);
1126  }
1127  TStr TStr::GetWcMatch(const TStr&amp; WcStr, const int&amp; StarStrN) const {
1128    TStrV StarStrV;
1129    if (IsWcMatch(WcStr, StarStrV)&amp;&amp;(StarStrV.Len()&gt;=StarStrN)){
1130      IAssert(StarStrN&gt;=0);
1131      return StarStrV[StarStrV.Len()-StarStrN-1];
1132    } else {
1133      return &quot;&quot;;
1134    }
1135  }
1136  TStr TStr::GetFPath() const {
1137    int ThisLen=Len(); const char* ThisBf=CStr();
1138    int ChN=ThisLen-1;
1139    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)){ChN--;}
1140    return GetSubStr(0, ChN);
1141  }
1142  TStr TStr::GetFBase() const {
1143    int ThisLen=Len(); const char* ThisBf=CStr();
1144    int ChN=ThisLen-1;
1145    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)){ChN--;}
1146    return GetSubStr(ChN+1, ThisLen);
1147  }
1148  TStr TStr::GetFMid() const {
1149    int ThisLen=Len(); const char* ThisBf=CStr();
1150    int ChN=ThisLen-1;
1151    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;.&#x27;)){
1152      ChN--;}
1153    if (ChN&lt;0){
1154      return *this;
1155    } else {
1156      if (ThisBf[ChN]==&#x27;.&#x27;){
1157        int EChN= --ChN;
1158        while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)){ChN--;}
1159        return GetSubStr(ChN+1, EChN);
1160      } else {
1161        return GetSubStr(ChN+1, ThisLen);
1162      }
1163    }
1164  }
1165  TStr TStr::GetFExt() const {
1166    int ThisLen=Len(); const char* ThisBf=CStr();
1167    int ChN=ThisLen-1;
1168    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)&amp;&amp;
1169     (ThisBf[ChN]!=&#x27;.&#x27;)){ChN--;}
1170    if ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]==&#x27;.&#x27;)){return GetSubStr(ChN, Len());}
1171    else {return TStr();}
1172  }
1173  TStr TStr::GetNrFPath(const TStr&amp; FPath){
1174    TChA NrFPath(FPath.Len()+4); NrFPath+=FPath;
1175    NrFPath.ChangeCh(&#x27;\\&#x27;, &#x27;/&#x27;);
1176    if (NrFPath.Empty()){NrFPath=&quot;./&quot;;}
1177    if ((NrFPath.Len()&gt;=2)&amp;&amp;isalpha(NrFPath[0])&amp;&amp;(NrFPath[1]==&#x27;:&#x27;)){
1178      if (NrFPath.Len()==2){NrFPath+=&quot;./&quot;;}
1179      if ((NrFPath[2]!=&#x27;.&#x27;)&amp;&amp;(NrFPath[2]!=&#x27;/&#x27;)){NrFPath.Ins(2, &quot;./&quot;);}
1180      if (NrFPath[NrFPath.Len()-1]!=&#x27;/&#x27;){NrFPath+=&quot;/&quot;;}
1181    } else {
1182      if ((NrFPath[0]!=&#x27;.&#x27;)&amp;&amp;(NrFPath[0]!=&#x27;/&#x27;)){NrFPath.Ins(0, &quot;./&quot;);}
1183      if (NrFPath[NrFPath.Len()-1]!=&#x27;/&#x27;){NrFPath+=&quot;/&quot;;}
1184    }
1185    return NrFPath;
1186  }
1187  TStr TStr::GetNrFMid(const TStr&amp; FMid){
1188    TChA NrFMid;
1189    int FMidLen=FMid.Len();
1190    for (int ChN=0; ChN&lt;FMidLen; ChN++){
1191      char Ch=FMid[ChN];
1192      if (TCh::IsAlNum(Ch)){NrFMid+=Ch;} else {NrFMid+=&#x27;_&#x27;;}
1193    }
1194    return NrFMid;
1195  }
1196  TStr TStr::GetNrFExt(const TStr&amp; FExt){
1197    if (FExt.Empty()||(FExt[0]==&#x27;.&#x27;)){return FExt;}
1198    else {return TStr(&quot;.&quot;)+FExt;}
1199  }
1200  TStr TStr::GetNrNumFExt(const int&amp; FExtN){
1201    TStr FExtNStr=TInt::GetStr(FExtN);
1202    while (FExtNStr.Len()&lt;3){
1203      FExtNStr=TStr(&quot;0&quot;)+FExtNStr;}
1204    return FExtNStr;
1205  }
1206  TStr TStr::GetNrFNm(const TStr&amp; FNm){
1207    return GetNrFPath(FNm.GetFPath())+FNm.GetFMid()+GetNrFExt(FNm.GetFExt());
1208  }
1209  TStr TStr::GetNrAbsFPath(const TStr&amp; FPath, const TStr&amp; BaseFPath){
1210    TStr NrBaseFPath;
1211    if (BaseFPath.Empty()){
1212      NrBaseFPath=GetNrFPath(TDir::GetCurDir());
1213    } else {
1214      NrBaseFPath=GetNrFPath(BaseFPath);
1215    }
1216    IAssert(IsAbsFPath(NrBaseFPath));
1217    TStr NrFPath=GetNrFPath(FPath);
1218    TStr NrAbsFPath;
1219    if (IsAbsFPath(NrFPath)){
1220      NrAbsFPath=NrFPath;
1221    } else {
1222      NrAbsFPath=GetNrFPath(NrBaseFPath+NrFPath);
1223    }
1224    NrAbsFPath.ChangeStrAll(&quot;/./&quot;, &quot;/&quot;);
1225    NrAbsFPath.ChangeStrAll(&quot;\\.\\&quot;, &quot;\\&quot;);
1226    return NrAbsFPath;
1227  }
1228  bool TStr::IsAbsFPath(const TStr&amp; FPath){
1229    if ((FPath.Len()&gt;=3)&amp;&amp;isalpha(FPath[0])&amp;&amp;(FPath[1]==&#x27;:&#x27;)&amp;&amp;
1230     ((FPath[2]==&#x27;/&#x27;)||(FPath[2]==&#x27;\\&#x27;))){
1231      return true;
1232    }
1233    return false;
1234  }
1235  TStr TStr::PutFExt(const TStr&amp; FNm, const TStr&amp; FExt){
1236    return FNm.GetFPath()+FNm.GetFMid()+FExt;
1237  }
1238  TStr TStr::PutFExtIfEmpty(const TStr&amp; FNm, const TStr&amp; FExt){
1239    if (FNm.GetFExt().Empty()){
1240      return FNm.GetFPath()+FNm.GetFMid()+FExt;
1241    } else {
1242      return FNm;
1243    }
1244  }
1245  TStr TStr::PutFBase(const TStr&amp; FNm, const TStr&amp; FBase){
1246    return FNm.GetFPath()+FBase;
1247  }
1248  TStr TStr::PutFBaseIfEmpty(const TStr&amp; FNm, const TStr&amp; FBase){
1249    if (FNm.GetFBase().Empty()){
1250      return FNm.GetFPath()+FBase;
1251    } else {
1252      return FNm;
1253    }
1254  }
1255  TStr TStr::AddToFMid(const TStr&amp; FNm, const TStr&amp; ExtFMid){
1256    return FNm.GetFPath()+FNm.GetFMid()+ExtFMid+FNm.GetFExt();
1257  }
1258  TStr TStr::GetNumFNm(const TStr&amp; FNm, const int&amp; Num){
1259    return FNm.GetFPath()+FNm.GetFMid()+TInt::GetStr(Num, &quot;%03d&quot;)+FNm.GetFExt();
1260  }
1261  TStr TStr::GetFNmStr(const TStr&amp; Str, const bool&amp; AlNumOnlyP){
1262    TChA FNm=Str;
1263    for (int ChN=0; ChN&lt;FNm.Len(); ChN++){
1264      uchar Ch=FNm[ChN];
1265      if (AlNumOnlyP){
1266        if (
1267         ((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;))||
1268         ((&#x27;A&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;Z&#x27;))||
1269         ((&#x27;a&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;z&#x27;))||
1270         (Ch==&#x27;-&#x27;)||(Ch==&#x27;_&#x27;)){}
1271        else {Ch=&#x27;_&#x27;;}
1272      } else {
1273        if ((Ch&lt;=&#x27; &#x27;)||(Ch==&#x27;/&#x27;)||(Ch==&#x27;\\&#x27;)||(Ch==&#x27;:&#x27;)||(Ch==&#x27;.&#x27;)){
1274          Ch=&#x27;_&#x27;;}
1275      }
1276      FNm.PutCh(ChN, Ch);
1277    }
1278    return FNm;
1279  }
1280  TStr&amp; TStr::GetChStr(const char&amp; Ch){
1281    static char MnCh=char(CHAR_MIN);
1282    static char MxCh=char(CHAR_MAX);
1283    static int Chs=int(MxCh)-int(MnCh)+1;
1284    static TStrV ChStrV;
1285    if (ChStrV.Empty()){
1286      ChStrV.Gen(Chs);
1287      for (int ChN=0; ChN&lt;Chs; ChN++){
1288        ChStrV[ChN]=TStr(char(MnCh+ChN), true);}
1289    }
1290    return ChStrV[int(Ch-MnCh)];
1291  }
1292  TStr&amp; TStr::GetDChStr(const char&amp; Ch1, const char&amp; Ch2){
1293    Fail; 
1294    static TStrVV DChStrVV;
1295    if (DChStrVV.Empty()){
1296      DChStrVV.Gen(TCh::Vals, TCh::Vals);
1297      for (int Ch1N=0; Ch1N&lt;TCh::Vals; Ch1N++){
1298        for (int Ch2N=0; Ch2N&lt;TCh::Vals; Ch2N++){
1299          DChStrVV.At(Ch1N, Ch2N)=
1300           TStr(char(TCh::Mn+Ch1N), char(TCh::Mn+Ch2N), true);
1301        }
1302      }
1303    }
1304    return DChStrVV.At(int(Ch1-TCh::Mn), int(Ch2-TCh::Mn));
1305  }
1306  TStr TStr::GetStr(const TStr&amp; Str, const char* FmtStr){
1307    if (FmtStr==NULL){
1308      return Str;
1309    } else {
1310      char Bf[1000];
1311      sprintf(Bf, FmtStr, Str.CStr());
1312      return TStr(Bf);
1313    }
1314  }
1315  TStr TStr::GetStr(const TStrV&amp; StrV, const TStr&amp; DelimiterStr){
1316    if (StrV.Empty()){return TStr();}
1317    TChA ResStr=StrV[0];
1318    for (int StrN=1; StrN&lt;StrV.Len(); StrN++){
1319      ResStr+=DelimiterStr;
1320      ResStr+=StrV[StrN];
1321    }
1322    return ResStr;
1323  }
1324  TStr TStr::Fmt(const char *FmtStr, ...){
1325    char Bf[10*1024];
1326    va_list valist;
1327    va_start(valist, FmtStr);
1328    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
1329    va_end(valist);
1330    return RetVal!=-1 ? TStr(Bf) : TStr::GetNullStr();
1331  }
1332  TStr TStr::GetSpaceStr(const int&amp; Spaces){
1333    static TStrV SpaceStrV;
1334    if (SpaceStrV.Len()==0){
1335      for (int SpaceStrN=0; SpaceStrN&lt;10; SpaceStrN++){
1336        TChA SpaceChA;
1337        for (int ChN=0; ChN&lt;SpaceStrN; ChN++){SpaceChA+=&#x27; &#x27;;}
1338        SpaceStrV.Add(SpaceChA);
1339      }
1340    }
1341    if ((0&lt;=Spaces)&amp;&amp;(Spaces&lt;SpaceStrV.Len())){
1342      return SpaceStrV[Spaces];
1343    } else {
1344      TChA SpaceChA;
1345      for (int ChN=0; ChN&lt;Spaces; ChN++){SpaceChA+=&#x27; &#x27;;}
1346      return SpaceChA;
1347    }
1348  }
1349  TStr TStr::GetNullStr(){
1350    static TStr NullStr=&quot;&quot;;
1351    return NullStr;
1352  }
1353  TStr operator+(const TStr&amp; LStr, const TStr&amp; RStr){
1354    if (LStr.Empty()){return RStr;}
1355    else if (RStr.Empty()){return LStr;}
1356    else {return TStr(LStr)+=RStr;}
1357  }
1358  TStr operator+(const TStr&amp; LStr, const char* RCStr){
1359    return TStr(LStr)+=RCStr;
1360  }
1361  TStrIn::TStrIn(const TStr&amp; _Str):
1362    TSBase(&quot;Input-String&quot;), TSIn(&quot;Input-String&quot;), Str(_Str), Bf(Str.CStr()), BfC(0), BfL(Str.Len()){}
1363  int TStrIn::GetBf(const void* LBf, const TSize&amp; LBfL){
1364    Assert(TSize(BfC+LBfL)&lt;=TSize(BfL));
1365    int LBfS=0;
1366    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
1367      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
1368    return LBfS;
1369  }
1370  bool TStrIn::GetNextLnBf(TChA&amp; LnChA){
1371    FailR(TStr::Fmt(&quot;TStrIn::GetNextLnBf: not implemented&quot;).CStr());
1372    return false;
1373  }
1374  void TStrPool::Resize(const uint&amp; _MxBfL) {
1375    uint newSize = MxBfL;
1376    while (newSize &lt; _MxBfL) {
1377      if (newSize &gt;= GrowBy &amp;&amp; GrowBy &gt; 0) newSize += GrowBy;
1378      else if (newSize &gt; 0) newSize *= 2;
1379      else newSize = TInt::GetMn(GrowBy, 1024);
1380      IAssertR(newSize &gt;= MxBfL, TStr::Fmt(&quot;TStrPool::Resize: %u, %u [Size larger than 4Gb, which is not supported by TStrPool]&quot;, newSize, MxBfL).CStr());
1381    }
1382    if (newSize &gt; MxBfL) {
<span onclick='openModal()' class='match'>1383      Bf = (char *) realloc(Bf, newSize);
1384      IAssertR(Bf, TStr::Fmt(&quot;old Bf size: %u, new size: %u&quot;, MxBfL, newSize).CStr());
1385      MxBfL = newSize;
1386    }
1387    IAssertR(MxBfL &gt;= _MxBfL, TStr::Fmt(&quot;new size: %u, requested size: %u&quot;, MxBfL, _MxBfL).CStr());
</span>1388  }
1389  TStrPool::TStrPool(const uint&amp; MxBfLen, const uint&amp; _GrowBy) : MxBfL(MxBfLen), BfL(0), GrowBy(_GrowBy), Bf(0) {
1390    if (MxBfL &gt; 0) { Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt(&quot;Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]&quot;, MxBfL).CStr()); }
1391    AddStr(&quot;&quot;); 
1392  }
1393  TStrPool::TStrPool(TSIn&amp; SIn, bool LoadCompact) : MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1394    SIn.Load(MxBfL);  SIn.Load(BfL);  SIn.Load(GrowBy);
1395    if (LoadCompact) MxBfL = BfL;
1396    if (MxBfL &gt; 0) { Bf = (char *) malloc(MxBfL); IAssertR(Bf, TStr::Fmt(&quot;Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]&quot;, MxBfL).CStr()); }
1397    if (BfL &gt; 0) SIn.LoadBf(Bf, BfL);
1398    SIn.LoadCs();
1399  }
1400  void TStrPool::Save(TSOut&amp; SOut) const {
1401    SOut.Save(MxBfL);  SOut.Save(BfL);  SOut.Save(GrowBy);
1402    SOut.SaveBf(Bf, BfL);
1403    SOut.SaveCs();
1404  }
1405  TStrPool&amp; TStrPool::operator = (const TStrPool&amp; Pool) {
1406    if (this != &amp;Pool) {
1407      GrowBy = Pool.GrowBy;  MxBfL = Pool.MxBfL;  BfL = Pool.BfL;
1408      if (Bf) free(Bf); else IAssertR(MxBfL == 0, TStr::Fmt(&quot;size: %u, expected size: 0&quot;, MxBfL).CStr());
1409      Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt(&quot;Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]&quot;, MxBfL).CStr());  memcpy(Bf, Pool.Bf, BfL);
1410    }
1411    return *this;
1412  }
1413  uint TStrPool::AddStr(const char *Str, const uint&amp; Len) {
1414    IAssertR(Len &gt; 0, &quot;String too short (length includes the null character)&quot;);  
1415    if (Len == 1 &amp;&amp; BfL &gt; 0) { return 0; } 
1416    Assert(Str);  Assert(Len &gt; 0);
1417    if (BfL + Len &gt; MxBfL) Resize(BfL + Len);
1418    memcpy(Bf + BfL, Str, Len);
1419    uint Pos = BfL;  BfL += Len;  return Pos;
1420  }
1421  int TStrPool::GetPrimHashCd(const char *CStr) {
1422    return TStrHashF_DJB::GetPrimHashCd(CStr);
1423  }
1424  int TStrPool::GetSecHashCd(const char *CStr) {
1425    return TStrHashF_DJB::GetSecHashCd(CStr);
1426  }
1427  void TStrPool64::Resize(const ::TSize&amp; _MxBfL) {
1428    ::TSize newSize = MxBfL;
1429    while (newSize &lt; _MxBfL) {
1430      if (newSize &gt;= GrowBy &amp;&amp; GrowBy &gt; 0) newSize += GrowBy;
1431      else if (newSize &gt; 0) newSize *= 2;
1432      else newSize = (GrowBy &gt; ::TSize(1024)) ? ::TSize(1024) : GrowBy;
1433      IAssert(newSize &gt;= MxBfL); 
1434    }
1435    if (newSize &gt; MxBfL) {
1436      Bf = (char *) realloc(Bf, newSize);
1437      IAssertR(Bf, TStr::Fmt(&quot;old Bf size: %u, new size: %u&quot;, MxBfL, newSize).CStr());
1438      MxBfL = newSize;
1439    }
1440    IAssert(MxBfL &gt;= _MxBfL);
1441  }
1442  TStrPool64::TStrPool64(::TSize _MxBfL, ::TSize _GrowBy):
1443      MxBfL(_MxBfL), BfL(0), GrowBy(_GrowBy), Bf(NULL) {
1444    if (MxBfL &gt; 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1445    AddStr(&quot;&quot;);
1446  }
1447  TStrPool64::TStrPool64(const TStrPool64&amp; StrPool): 
1448    MxBfL(StrPool.MxBfL), BfL(StrPool.BfL), GrowBy(StrPool.GrowBy) {
1449    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1450    Bf = (char*)malloc(StrPool.MxBfL); IAssert(Bf != NULL); 
1451    memcpy(Bf, StrPool.Bf, BfL);
1452  }
1453  TStrPool64::TStrPool64(TSIn&amp; SIn, bool LoadCompact): 
1454    MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1455    uint64 _GrowBy, _MxBfL, _BfL;
1456    SIn.Load(_GrowBy); SIn.Load(_MxBfL); SIn.Load(_BfL);
1457    GrowBy = (::TSize)_GrowBy; MxBfL = (::TSize)_MxBfL; BfL = (::TSize)_BfL;
1458    if (LoadCompact) { MxBfL = BfL; }
1459    if (MxBfL &gt; 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1460    for (::TSize BfN = 0; BfN &lt; _BfL; BfN++) { Bf[BfN] = SIn.GetCh(); }
1461    SIn.LoadCs();
1462  }
1463  void TStrPool64::Save(TSOut&amp; SOut) const {
1464    uint64 _GrowBy = GrowBy, _MxBfL = MxBfL, _BfL = BfL;
1465    SOut.Save(_GrowBy);  SOut.Save(_MxBfL);  SOut.Save(_BfL);
1466    for (::TSize BfN = 0; BfN &lt; _BfL; BfN++) { SOut.PutCh(Bf[BfN]); }
1467    SOut.SaveCs();
1468  }
1469  TStrPool64&amp; TStrPool64::operator=(const TStrPool64&amp; StrPool) {
1470    if (this != &amp;StrPool) {
1471    GrowBy = StrPool.GrowBy;  MxBfL = StrPool.MxBfL;  BfL = StrPool.BfL;
1472    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1473    Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); 
1474    memcpy(Bf, StrPool.Bf, BfL);
1475    }
1476    return *this;
1477  }
1478  void TStrPool64::Clr(bool DoDel) { 
1479    BfL = 0; 
1480    if (DoDel &amp;&amp; (Bf!=NULL)) { 
1481      free(Bf); 
1482      Bf = NULL; MxBfL = 0; 
1483    } 
1484  }
1485  uint64 TStrPool64::AddStr(const TStr&amp; Str) {
1486    const int Len = Str.Len() + 1;
1487    if (BfL + Len &gt; MxBfL) { Resize(BfL + Len); }
1488    memcpy(Bf + BfL, Str.CStr(), Len);
1489    ::TSize Offset = BfL;  BfL += Len;
1490    return uint64(Offset);
1491  }
1492  TStr TStrPool64::GetStr(const uint64&amp; StrId) const {
1493    ::TSize Offset = (::TSize)StrId;
1494    return TStr(Bf + Offset);
1495  }
1496  void TVoid::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1497    XLoadHd(Nm);
1498  }
1499  void TVoid::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1500    XSaveBETag(Nm);
1501  }
1502  const bool TBool::Mn=0;
1503  const bool TBool::Mx=1;
1504  const int TBool::Vals=TBool::Mx-TBool::Mn+1;
1505  TRnd TBool::Rnd;
1506  const TStr TBool::FalseStr=&quot;F&quot;;
1507  const TStr TBool::TrueStr=&quot;T&quot;;
1508  const TStr TBool::NStr=&quot;N&quot;;
1509  const TStr TBool::YStr=&quot;Y&quot;;
1510  const TStr TBool::NoStr=&quot;No&quot;;
1511  const TStr TBool::YesStr=&quot;Yes&quot;;
1512  void TBool::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1513    XLoadHd(Nm);
1514    Val=TXmlObjSer::GetBoolArg(XmlTok, &quot;Val&quot;);
1515  }
1516  void TBool::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1517    XSaveBETagArg(Nm, &quot;Val&quot;, TBool::GetStr(Val));
1518  }
1519  bool TBool::IsValStr(const TStr&amp; Str){
1520    TStr UcStr=Str.GetUc();
1521    return
1522     (UcStr==FalseStr)||(UcStr==TrueStr)||
1523     (UcStr==YStr)||(UcStr==NStr)||
1524     (UcStr==YesStr)||(UcStr==NoStr);
1525  }
1526  bool TBool::GetValFromStr(const TStr&amp; Str){
1527    return (Str==TrueStr)||(Str==YStr)||(Str==YesStr);
1528  }
1529  bool TBool::GetValFromStr(const TStr&amp; Str, const bool&amp; DfVal){
1530    TStr UcStr=Str.GetUc();
1531    if (IsValStr(UcStr)){
1532      return (UcStr==TrueStr)||(UcStr==YStr)||(UcStr==YesStr);
1533    } else {
1534      return DfVal;
1535    }
1536  }
1537  const char TCh::Mn=CHAR_MIN;
1538  const char TCh::Mx=CHAR_MAX;
1539  const int TCh::Vals=int(TCh::Mx)-int(TCh::Mn)+1;
1540  const char TCh::NullCh=char(0);
1541  const char TCh::TabCh=char(9);
1542  const char TCh::LfCh=char(10);
1543  const char TCh::CrCh=char(13);
1544  const char TCh::EofCh=char(26);
1545  const char TCh::HashCh=&#x27;#&#x27;;
1546  void TCh::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1547    XLoadHd(Nm);
1548    Val=char(TXmlObjSer::GetIntArg(XmlTok, &quot;Val&quot;));
1549  }
1550  void TCh::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1551    XSaveBETagArg(Nm, &quot;Val&quot;, TInt::GetStr(Val));
1552  }
1553  char TCh::GetUsFromYuAscii(const char&amp; Ch){
1554    switch (Ch){
1555      case &#x27;~&#x27;: return &#x27;c&#x27;;
1556      case &#x27;^&#x27;: return &#x27;C&#x27;;
1557      case &#x27;{&#x27;: return &#x27;s&#x27;;
1558      case &#x27;[&#x27;: return &#x27;S&#x27;;
1559      case &#x27;`&#x27;: return &#x27;z&#x27;;
1560      case &#x27;@&#x27;: return &#x27;Z&#x27;;
1561      case &#x27;|&#x27;: return &#x27;d&#x27;;
1562      case &#x27;\\&#x27;: return &#x27;D&#x27;;
1563      default: return Ch;
1564    }
1565  }
1566  const uchar TUCh::Mn=0;
1567  const uchar TUCh::Mx=UCHAR_MAX;
1568  const int TUCh::Vals=int(TUCh::Mx)-int(TUCh::Mn)+1;
1569  void TUCh::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1570    XLoadHd(Nm);
1571    Val=uchar(TXmlObjSer::GetIntArg(XmlTok, &quot;Val&quot;));
1572  }
1573  void TUCh::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1574    XSaveBETagArg(Nm, &quot;Val&quot;, TInt::GetStr(Val));
1575  }
1576  const int TInt::Mn=INT_MIN;
1577  const int TInt::Mx=INT_MAX;
1578  const int TInt::Kilo=1024;
1579  const int TInt::Mega=1024*1024;
1580  const int TInt::Giga=1024*1024*1024;
1581  TRnd TInt::Rnd;
1582  void TInt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1583    XLoadHd(Nm);
1584    Val=TXmlObjSer::GetIntArg(XmlTok, &quot;Val&quot;);
1585  }
1586  void TInt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1587    XSaveBETagArg(Nm, &quot;Val&quot;, TInt::GetStr(Val));
1588  }
1589  TStr TInt::GetStr(const int&amp; Val, const char* FmtStr){
1590    if (FmtStr==NULL){
1591      return GetStr(Val);
1592    } else {
1593      char Bf[255];
1594      sprintf(Bf, FmtStr, Val);
1595      return TStr(Bf);
1596    }
1597  }
1598  char* TInt::SaveFrugalInt(char *pDest, int i){
1599    i++;
1600    if (i &gt;= 0 &amp;&amp; i &lt;= 127) { *pDest++ = char(i); return pDest; }
1601    if (i &gt;= 128 &amp;&amp; i &lt; 128 + 8192) { i -= 128; *pDest++ = char(0x80 | (i &amp; 0x7f));
1602      *pDest++ = char((i &gt;&gt; 7) &amp; 0x3f); return pDest; }
1603    if (i &lt;= -1 &amp;&amp; i &gt; -1 - 8192) { i = -1 - i;  *pDest++ = char(0x80 | (i &amp; 0x7f));
1604      *pDest++ = char(0x40 | ((i &gt;&gt; 7) &amp; 0x3f)); return pDest; }
1605    if (i &gt;= 128 + 8192 &amp;&amp; i &lt; 128 + 8192 + 536870912) { i -= 128 + 8192;
1606      *pDest++ = char(0x80 | (i &amp; 0x7f)); *pDest++ = char(0x80 | ((i &gt;&gt; 7) &amp; 0x7f));
1607      *pDest++ = char((i &gt;&gt; 14) &amp; 0xff); *pDest++ = char((i &gt;&gt; 22) &amp; 0x7f); return pDest; }
1608    if (i &lt;= -1 - 8192 &amp;&amp; i &gt; -1 - 8192 - 536870912) { i = (-1 - 8192) - i;
1609      *pDest++ = char(0x80 | (i &amp; 0x7f)); *pDest++ = char(0x80 | ((i &gt;&gt; 7) &amp; 0x7f));
1610      *pDest++ = char((i &gt;&gt; 14) &amp; 0xff); *pDest++ = char(0x80 | ((i &gt;&gt; 22) &amp; 0x7f)); return pDest; }
1611    IAssertR(false, TInt::GetStr(i)); return 0;
1612  }
1613  char* TInt::LoadFrugalInt(char *pSrc, int&amp; i){
1614    i = 0;
1615    int ch = (int) ((unsigned char) (*pSrc++));
1616    if ((ch &amp; 0x80) == 0) { i = ch; i--; return pSrc; }
1617    i = (ch &amp; 0x7f);
1618    ch = (int) ((unsigned char) (*pSrc++));
1619    if ((ch &amp; 0x80) == 0)
1620    {
1621      i |= (ch &amp; 0x3f) &lt;&lt; 7;
1622      if ((ch &amp; 0x40) == 0) i += 128; else i = -1 - i;
1623      i--; return pSrc;
1624    }
1625    i |= (ch &amp; 0x7f) &lt;&lt; 7;
1626    ch = (int) ((unsigned char) (*pSrc++));
1627    i |= ch &lt;&lt; 14;
1628    ch = (int) ((unsigned char) (*pSrc++));
1629    i |= (ch &amp; 0x7f) &lt;&lt; 22;
1630    if ((ch &amp; 0x80) == 0) i += 128 + 8192; else i = (-1 - 8192) - i;
1631    i--; return pSrc;
1632  }
1633  void TInt::TestFrugalInt(){
1634    char buf[10], *p = &amp;buf[0], *r, *s;
1635    int i, j;
1636  #define __TEST(from, to, len) \
1637    for (i = (from); i &lt;= (to); i++) \
1638      { if ((i &amp; 0xffff) == 0) printf(&quot;%d\r&quot;, i); \
1639        r = SaveFrugalInt(p, i); s = LoadFrugalInt(p, j); \
1640        IAssert(r == s); IAssert(i == j); IAssert(r - p == len); }
1641    __TEST(-1, 126, 1);
1642    __TEST(127, 127 + 8191, 2);
1643    __TEST(-2 - 8191, -2, 2);
1644    __TEST(127 + 8192, 127 + 8191 + (1 &lt;&lt; 29), 4);
1645    __TEST(-2 - 8191 - (1 &lt;&lt; 29), -2 - 8192, 4);
1646  #undef __TEST
1647  }
1648  void TInt::SaveFrugalIntV(TSOut&amp; SOut, const TIntV&amp; v){
1649    int count = v.Len();
1650    char *buf = new char[4 * (count + 1)], *pStart, *pEnd;
1651    pStart = buf + 4; pEnd = pStart;
1652    for (int i = 0; i &lt; count; i++)
1653      pEnd = SaveFrugalInt(pEnd, v[i].Val);
1654    int size = int(pEnd - pStart);
1655    char *pSizeStart = buf;
1656    char *pSizeEnd = SaveFrugalInt(pSizeStart, size);
1657    while (pSizeEnd &gt; pSizeStart) *(--pStart) = *(--pSizeEnd);
1658    SOut.PutBf(pStart, TSize(pEnd - pStart));
1659    delete[] buf;
1660  }
1661  void TInt::LoadFrugalIntV(TSIn&amp; SIn, TIntV&amp; v, bool clearVec){
1662    if (clearVec) v.Clr();
1663    char sizeBuf[4], *p, *pEnd;
1664    sizeBuf[0] = SIn.GetCh(); int count = 1;
1665    if (sizeBuf[0] &amp; 0x80)
1666    {
1667      sizeBuf[1] = SIn.GetCh(); count++;
1668      if (sizeBuf[1] &amp; 0x80) { sizeBuf[2] = SIn.GetCh();
1669        sizeBuf[3] = SIn.GetCh(); count += 2;}
1670    }
1671    int size;
1672    pEnd = LoadFrugalInt(&amp;sizeBuf[0], size);
1673    IAssert(pEnd - &amp;sizeBuf[0] == count);
1674    if (size &lt;= 0) return;
1675    char *buf = new char[size];
1676    SIn.GetBf(buf, size);
1677    p = buf; pEnd = buf + size;
1678    while (p &lt; pEnd)
1679      { int i; p = LoadFrugalInt(p, i); v.Add(i); }
1680    IAssert(p == pEnd);
1681    delete[] buf;
1682  }
1683  const uint TUInt::Mn=0;
1684  const uint TUInt::Mx=UINT_MAX;
1685  TRnd TUInt::Rnd;
1686  void TUInt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1687    XLoadHd(Nm);
1688    Val=TXmlObjSer::GetIntArg(XmlTok, &quot;Val&quot;);
1689  }
1690  void TUInt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1691    XSaveBETagArg(Nm, &quot;Val&quot;, TInt::GetStr(Val));
1692  }
1693  TStr TUInt::GetStr(const uint&amp; Val, const char* FmtStr){
1694    if (FmtStr==NULL){
1695      return GetStr(Val);
1696    } else {
1697      char Bf[255];
1698      sprintf(Bf, FmtStr, Val);
1699      return TStr(Bf);
1700    }
1701  }
1702  bool TUInt::IsIpStr(const TStr&amp; IpStr, uint&amp; Ip, const char&amp; SplitCh) {
1703  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1704      Ip = 0; int Byte = 0;
1705  	if (IpStrV.Len() != 4) { return false; }
1706  	if (!IpStrV[0].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (uint)Byte;
1707  	if (!IpStrV[1].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1708  	if (!IpStrV[2].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1709  	if (!IpStrV[3].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1710  	return true;
1711  }
1712  uint TUInt::GetUIntFromIpStr(const TStr&amp; IpStr, const char&amp; SplitCh) {
1713  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1714      uint Ip = 0; int Byte = 0;
1715  	EAssertR(IpStrV[0].IsInt(true, 0, 255, Byte), TStr::Fmt(&quot;Bad IP: &#x27;%s;&quot;, IpStr.CStr())); Ip = (uint)Byte;
1716  	EAssertR(IpStrV[1].IsInt(true, 0, 255, Byte), TStr::Fmt(&quot;Bad IP: &#x27;%s;&quot;, IpStr.CStr())); Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1717  	EAssertR(IpStrV[2].IsInt(true, 0, 255, Byte), TStr::Fmt(&quot;Bad IP: &#x27;%s;&quot;, IpStr.CStr())); Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1718  	EAssertR(IpStrV[3].IsInt(true, 0, 255, Byte), TStr::Fmt(&quot;Bad IP: &#x27;%s;&quot;, IpStr.CStr())); Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1719  	return Ip;
1720  }
1721  TStr TUInt::GetStrFromIpUInt(const uint&amp; Ip) {
1722    return TStr::Fmt(&quot;%d.%d.%d.%d&quot;, ((Ip&gt;&gt;24) &amp; 0xFF),
1723     ((Ip&gt;&gt;16) &amp; 0xFF), ((Ip&gt;&gt;8) &amp; 0xFF), (Ip &amp; 0xFF));
1724  }
1725  bool TUInt::IsIpv6Str(const TStr&amp; IpStr, const char&amp; SplitCh) {
1726  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV, false);
1727  	if (IpStrV.Len() &gt; 8) { return false; }
1728  	int Group = 0;
1729  	for (int IpStrN = 0; IpStrN &lt; IpStrV.Len(); IpStrN++) {
1730  		if (IpStrV[IpStrN].Empty()) { continue; }
1731  		if (IpStrV[IpStrN].IsHexInt(true, 0x0000, 0xFFFF, Group)) { continue; }
1732  		return false; 
1733  	}
1734  	return true;
1735  }
1736  #if defined (GLib_WIN32)
1737  const TUInt64 TUInt64::Mn(uint64(0x0000000000000000i64));
1738  const TUInt64 TUInt64::Mx(uint64(0xFFFFFFFFFFFFFFFFi64));
1739  #elif defined (GLib_BCB)
1740  const TUInt64 TUInt64::Mn(0x0000000000000000i64);
1741  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFi64);
1742  #else
1743  const TUInt64 TUInt64::Mn((uint64)0x0000000000000000LL);
1744  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFLL);
1745  #endif
1746  void TUInt64::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1747    XLoadHd(Nm);
1748    Val=TXmlObjSer::GetInt64Arg(XmlTok, &quot;Val&quot;);
1749  }
1750  void TUInt64::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1751    XSaveBETagArg(Nm, &quot;Val&quot;, TUInt64::GetStr(Val));
1752  }
1753  const double TFlt::Mn=-DBL_MAX;
1754  const double TFlt::Mx=+DBL_MAX;
1755  const double TFlt::NInf=-DBL_MAX;
1756  const double TFlt::PInf=+DBL_MAX;
1757  const double TFlt::Eps=1e-16;
1758  const double TFlt::EpsHalf  =1e-7;
1759  TRnd TFlt::Rnd;
1760  void TFlt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1761    XLoadHd(Nm);
1762    Val=TXmlObjSer::GetFltArg(XmlTok, &quot;Val&quot;);
1763  }
1764  void TFlt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1765    XSaveBETagArg(Nm, &quot;Val&quot;, TFlt::GetStr(Val));
1766  }
1767  TStr TFlt::GetStr(const double&amp; Val, const int&amp; Width, const int&amp; Prec){
1768    char Bf[255];
1769    if ((Width==-1)&amp;&amp;(Prec==-1)){sprintf(Bf, &quot;%g&quot;, Val);}
1770    else {sprintf(Bf, &quot;%*.*f&quot;, Width, Prec, Val);}
1771    return TStr(Bf);
1772  }
1773  TStr TFlt::GetStr(const double&amp; Val, const char* FmtStr){
1774    if (FmtStr==NULL){
1775      return GetStr(Val);
1776    } else {
1777      char Bf[255];
1778      sprintf(Bf, FmtStr, Val);
1779      return TStr(Bf);
1780    }
1781  }
1782  const sdouble TSFlt::Mn=-FLT_MIN;
1783  const sdouble TSFlt::Mx=+FLT_MAX;
1784  void TSFlt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1785    XLoadHd(Nm);
1786    Val=sdouble(TXmlObjSer::GetFltArg(XmlTok, &quot;Val&quot;));
1787  }
1788  void TSFlt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1789    XSaveBETagArg(Nm, &quot;Val&quot;, TFlt::GetStr(Val));
1790  }
1791  const ldouble TLFlt::Mn=-LDBL_MAX;
1792  const ldouble TLFlt::Mx=+LDBL_MAX;
1793  void TLFlt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1794    XLoadHd(Nm);
1795    Val=TXmlObjSer::GetFltArg(XmlTok, &quot;Val&quot;);
1796  }
1797  void TLFlt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1798    XSaveBETagArg(Nm, &quot;Val&quot;, TFlt::GetStr(double(Val)));
1799  }
1800  TStr TLFlt::GetStr(const ldouble&amp; Val, const int&amp; Width, const int&amp; Prec){
1801    char Bf[255];
1802    if ((Width==-1)&amp;&amp;(Prec==-1)){sprintf(Bf, &quot;%Lg&quot;, Val);}
1803    else {sprintf(Bf, &quot;%*.*Lf&quot;, Width, Prec, Val);}
1804    return TStr(Bf);
1805  }
1806  TStr TLFlt::GetStr(const ldouble&amp; Val, const char* FmtStr){
1807    if (FmtStr==NULL){
1808      return GetStr(Val);
1809    } else {
1810      char Bf[255];
1811      sprintf(Bf, FmtStr, Val);
1812      return TStr(Bf);
1813    }
1814  }
1815  void TFltRect::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1816    XLoadHd(Nm);
1817    MnX=TXmlObjSer::GetFltArg(XmlTok, &quot;MnX&quot;);
1818    MnY=TXmlObjSer::GetFltArg(XmlTok, &quot;MnY&quot;);
1819    MxX=TXmlObjSer::GetFltArg(XmlTok, &quot;MxX&quot;);
1820    MxY=TXmlObjSer::GetFltArg(XmlTok, &quot;MxY&quot;);
1821  }
1822  void TFltRect::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1823    XSaveBETagArg4(Nm,
1824     &quot;MnX&quot;, TFlt::GetStr(double(MnX)), &quot;MnY&quot;, TFlt::GetStr(double(MnY)),
1825     &quot;MxX&quot;, TFlt::GetStr(double(MxX)), &quot;MxY&quot;, TFlt::GetStr(double(MxY)));
1826  }
1827  bool TFltRect::Intersection(const TFltRect&amp; Rect1, const TFltRect&amp; Rect2){
1828    const double MnXX = TFlt::GetMx(Rect1.GetMnX(), Rect2.GetMnX());
1829    const double MnYY = TFlt::GetMx(Rect1.GetMnY(), Rect2.GetMnY());
1830    const double MxXX = TFlt::GetMn(Rect1.GetMxX(), Rect2.GetMxX());
1831    const double MxYY = TFlt::GetMn(Rect1.GetMxY(), Rect2.GetMxY());
1832    return (MnXX &lt; MxXX) &amp;&amp; (MnYY &lt; MxYY);
1833  }
1834  TStr TFltRect::GetStr() const {
1835    TChA ChA;
1836    ChA+=&#x27;(&#x27;;
1837    ChA+=TFlt::GetStr(MnX, &quot;%0.2f&quot;); ChA+=&#x27;,&#x27;;
1838    ChA+=TFlt::GetStr(MnY, &quot;%0.2f&quot;); ChA+=&#x27;,&#x27;;
1839    ChA+=TFlt::GetStr(MxX, &quot;%0.2f&quot;); ChA+=&#x27;,&#x27;;
1840    ChA+=TFlt::GetStr(MxY, &quot;%0.2f&quot;); ChA+=&#x27;)&#x27;;
1841    return ChA;
1842  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</h3>
            <pre><code>1  const int TRnd::RndSeed=0;
2  const int TRnd::a=16807;
3  const int TRnd::m=2147483647;
4  const int TRnd::q=127773; 
5  const int TRnd::r=2836; 
6  void TRnd::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
7    XLoadHd(Nm);
8    Seed=TXmlObjSer::GetIntArg(XmlTok, &quot;Seed&quot;);
9  }
10  void TRnd::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
11    XSaveBETagArg(Nm, &quot;Seed&quot;, TInt::GetStr(Seed));
12  }
13  void TRnd::PutSeed(const int&amp; _Seed){
14    Assert(_Seed&gt;=0);
15    if (_Seed==0){
16      Seed=abs(int(TSysTm::GetPerfTimerTicks()));
17    } else {
18      Seed=_Seed;
19    }
20  }
21  void TRnd::Move(const int&amp; Steps){
22    for (int StepN=0; StepN&lt;Steps; StepN++){GetNextSeed();}
23  }
24  bool TRnd::Check(){
25    int PSeed=Seed; Seed=1;
26    for (int SeedN=0; SeedN&lt;10000; SeedN++){GetNextSeed();}
27    bool Ok=Seed==1043618065; Seed=PSeed; return Ok;
28  }
29  int TRnd::GetUniDevInt(const int&amp; Range){
30    int Seed=GetNextSeed();
31    if (Range==0){return Seed;}
32    else {return Seed%Range;}
33  }
34  uint TRnd::GetUniDevUInt(const uint&amp; Range){
35    uint Seed=uint(GetNextSeed()%0x10000)*0x10000+uint(GetNextSeed()%0x10000);
36    if (Range==0){return Seed;}
37    else {return Seed%Range;}
38  }
39  int64 TRnd::GetUniDevInt64(const int64&amp; Range){
40    const int64 RndVal = int64((uint64(GetUniDevInt())&lt;&lt;32) | uint64(GetUniDevInt()));
41    if (Range==0){return RndVal;}
42    else {return RndVal%Range;}
43  }
44  uint64 TRnd::GetUniDevUInt64(const uint64&amp; Range){
45   const uint64 RndVal = uint64((uint64(GetUniDevInt())&lt;&lt;32) | uint64(GetUniDevInt()));
46   if (Range==0){return RndVal;}
47   else {return RndVal%Range;}
48  }
49  double TRnd::GetNrmDev(){
50    double v1, v2, rsq;
51    do {
52      v1=2.0*GetUniDev()-1.0; 
53      v2=2.0*GetUniDev()-1.0; 
54      rsq=v1*v1+v2*v2; 
55    } while ((rsq&gt;=1.0)||(rsq==0.0)); 
56    double fac=sqrt(-2.0*log(rsq)/rsq); 
57    return v1*fac;
58  }
59  double TRnd::GetNrmDev(
60   const double&amp; Mean, const double&amp; SDev, const double&amp; Mn, const double&amp; Mx){
61    double Val=Mean+GetNrmDev()*SDev;
62    if (Val&lt;Mn){Val=Mn;}
63    if (Val&gt;Mx){Val=Mx;}
64    return Val;
65  }
66  double TRnd::GetExpDev(){
67    double UniDev;
68    do {
69      UniDev=GetUniDev();
70    } while (UniDev==0.0);
71    return -log(UniDev);
72  }
73  double TRnd::GetExpDev(const double&amp; Lambda) {
74    return GetExpDev()/Lambda;
75  }
76  double TRnd::GetGammaDev(const int&amp; Order){
77    int j;
78    double am,e,s,v1,v2,x,y;
79    if (Order&lt;1){Fail;}
80    if (Order&lt;6) {
81      x=1.0;
82      for (j=1;j&lt;=Order;j++) x *=GetUniDev();
83      x = -log(x);
84    } else {
85      do {
86        do {
87          do {
88            v1=2.0*GetUniDev()-1.0;
89            v2=2.0*GetUniDev()-1.0;
90          } while (v1*v1+v2*v2 &gt; 1.0);
91          y=v2/v1;
92          am=Order-1;
93          s=sqrt(2.0*am+1.0);
94          x=s*y+am;
95        } while (x &lt;= 0.0);
96        e=(1.0+y*y)*exp(am*log(x/am)-s*y);
97      } while (GetUniDev()&gt;e);
98    }
99    return x;
100  }
101  double TRnd::GetPoissonDev(const double&amp; Mean){
102    static double sq,alxm,g,oldm=(-1.0);
103    double em,t,y;
104    if (Mean &lt; 12.0) {
105      if (Mean != oldm) {
106        oldm=Mean;
107        g=exp(-Mean);
108      }
109      em = -1;
110      t=1.0;
111      do {
112        ++em;
113        t *= GetUniDev();
114      } while (t&gt;g);
115    } else {
116      if (Mean != oldm) {
117        oldm=Mean;
118        sq=sqrt(2.0*Mean);
119        alxm=log(Mean);
120        g=Mean*alxm-TSpecFunc::LnGamma(Mean+1.0);
121      }
122      do {
123        do {
124          y=tan(TMath::Pi*GetUniDev());
125          em=sq*y+Mean;
126        } while (em &lt; 0.0);
127        em=floor(em);
128        t=0.9*(1.0+y*y)*exp(em*alxm-TSpecFunc::LnGamma(em+1.0)-g);
129      } while (GetUniDev()&gt;t);
130    }
131    return em;
132  }
133  double TRnd::GetBinomialDev(const double&amp; Prb, const int&amp; Trials){
134    int j;
135    static int nold=(-1);
136    double am,em,g,angle,p,bnl,sq,t,y;
137    static double pold=(-1.0),pc,plog,pclog,en,oldg;
138    p=(Prb &lt;= 0.5 ? Prb : 1.0-Prb);
139    am=Trials*p;
140    if (Trials &lt; 25) {
141      bnl=0.0;
142      for (j=1;j&lt;=Trials;j++)
143        if (GetUniDev() &lt; p) ++bnl;
144    } else if (am &lt; 1.0) {
145      g=exp(-am);
146      t=1.0;
147      for (j=0;j&lt;=Trials;j++) {
148        t *= GetUniDev();
149        if (t &lt; g) break;
150      }
151      bnl=(j &lt;= Trials ? j : Trials);
152    } else {
153      if (Trials != nold) {
154        en=Trials;
155        oldg=TSpecFunc::LnGamma(en+1.0);
156        nold=Trials;
157      } if (p != pold) {
158        pc=1.0-p;
159        plog=log(p);
160        pclog=log(pc);
161        pold=p;
162      }
163      sq=sqrt(2.0*am*pc);
164      do {
165        do {
166          angle=TMath::Pi*GetUniDev();
167          y=tan(angle);
168          em=sq*y+am;
169        } while (em &lt; 0.0 || em &gt;= (en+1.0));
170        em=floor(em);
171        t=1.2*sq*(1.0+y*y)*exp(oldg-(em+1.0)
172          -TSpecFunc::LnGamma(en-em+1.0)+em*plog+(en-em)*pclog);
173      } while (GetUniDev() &gt; t);
174      bnl=em;
175    }
176    if (p != Prb) bnl=Trials-bnl;
177    return bnl;
178  }
179  TRnd TRnd::LoadTxt(TILx&amp; Lx){
180    return TRnd(Lx.GetInt());
181  }
182  void TRnd::SaveTxt(TOLx&amp; Lx) const {
183    Lx.PutInt(Seed);
184  }
185  void TMem::Resize(const int&amp; _MxBfL){
186    if (_MxBfL&lt;=MxBfL){return;}
187    else {if (MxBfL*2&lt;_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
188    char* NewBf=new char[MxBfL]; IAssert(NewBf!=NULL);
189    if (BfL&gt;0){memcpy(NewBf, Bf, BfL);}
190    if (Bf!=NULL){delete[] Bf;}
191    Bf=NewBf;
192  }
193  TMem::TMem(const TStr&amp; Str):
194    MxBfL(Str.Len()), BfL(MxBfL), Bf(NULL){
195    if (MxBfL&gt;0){
196      Bf=new char[MxBfL];
197      if (BfL&gt;0){memcpy(Bf, Str.CStr(), BfL);}
198    }
199  }
200  void TMem::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
201    XSaveHdArg(Nm, &quot;BfL&quot;, TInt::GetStr(BfL));
202    SOut.PutStr(TXmlLx::GetXmlStrFromPlainMem(*this));
203  }
204  bool TMem::DoFitStr(const TStr&amp; Str) const {
205    return DoFitLen(Str.Len()+1);
206  }
207  TMem&amp; TMem::operator+=(const char&amp; Ch){
208    if (BfL==MxBfL){Resize(BfL+1);}
209    Bf[BfL]=Ch; BfL++; return *this;
210  }
211  TMem&amp; TMem::operator+=(const TMem&amp; Mem){
212    int LBfL=Mem.Len(); if (BfL+LBfL&gt;MxBfL){Resize(BfL+LBfL);}
213    if (LBfL&gt;0){memcpy(&amp;Bf[BfL], Mem(), LBfL);}
214    BfL+=LBfL; return *this;
215  }
216  TMem&amp; TMem::operator+=(const TStr&amp; Str){
217    int LBfL=Str.Len(); if (BfL+LBfL&gt;MxBfL){Resize(BfL+LBfL);}
218    if (LBfL&gt;0){memcpy(Bf+BfL, Str.CStr(), LBfL);}
219    BfL+=LBfL; return *this;
220  }
221  TMem&amp; TMem::operator+=(const PSIn&amp; SIn){
222    int LBfL=SIn-&gt;Len(); if (BfL+LBfL&gt;MxBfL){Resize(BfL+LBfL);}
223    char* LBf=new char[LBfL];
224    SIn-&gt;GetBf(LBf, LBfL);
225    if (LBfL&gt;0){memcpy(Bf+BfL, LBf, LBfL);}
226    delete[] LBf;
227    BfL+=LBfL; return *this;
228  }
229  void TMem::Del(const int&amp; BChN, const int&amp; EChN){
230    if (BChN&gt;EChN){return;}
231    if ((BChN==0)&amp;&amp;(EChN==BfL-1)){Clr(); return;}
232    IAssert((0&lt;=BChN)&amp;&amp;(BChN&lt;=EChN)&amp;&amp;(EChN&lt;BfL));
233    memmove(Bf+BChN, Bf+EChN+1, BfL-EChN-1);
234    BfL-=(EChN-BChN+1);
235  }
236  void TMem::AddBf(const void* _Bf, const int&amp; _BfL){
237  	IAssert((_BfL&gt;=0) &amp;&amp; (_Bf != NULL));
238    Reserve(Len() + _BfL, false);
239    memcpy(Bf + BfL, _Bf, _BfL);  
240     BfL+=_BfL;
241  }
242  TStr TMem::GetAsStr(const char&amp; NewNullCh) const {
243    if (NewNullCh!=&#x27;\0&#x27;){
244      TChA ChA(*this);
245      ChA.ChangeCh(&#x27;\0&#x27;, NewNullCh);
246      return ChA;
247    } else {
248      return TStr(*this);
249    }
250  }
251  TMemIn::TMemIn(const TMem&amp; _Mem, const int&amp; _BfC):
252    TSBase(&quot;Input-Memory&quot;), TSIn(&quot;Input-Memory&quot;), Mem(), Bf(_Mem()), BfC(_BfC), BfL(_Mem.Len()){}
253  int TMemIn::GetBf(const void* LBf, const TSize&amp; LBfL){
254    Assert(TSize(BfC+LBfL)&lt;=TSize(BfL));
255    int LBfS=0;
256    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
257      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
258    return LBfS;
259  }
260  bool TMemIn::GetNextLnBf(TChA&amp; LnChA){
261    FailR(TStr::Fmt(&quot;TMemIn::GetNextLnBf: not implemented&quot;).CStr());
262    return false;
263  }
264  TMemOut::TMemOut(const PMem&amp; _Mem): TSBase(&quot;Output-Memory&quot;), TSOut(&quot;Output-Memory&quot;), Mem(_Mem){}
265  int TMemOut::PutBf(const void* LBf, const TSize&amp; LBfL){
266    int LBfS=0;
267    TMem&amp; _Mem=*Mem;
268    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
269      char Ch=((char*)LBf)[LBfC];
270      LBfS+=Ch; _Mem+=Ch;
271    }
272    return LBfS;
273  }
274  void TChA::Resize(const int&amp; _MxBfL){
275    if (_MxBfL&lt;=MxBfL){return;}
276    else {if (MxBfL*2&lt;_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
277    char* NewBf=new char[MxBfL+1]; IAssert(NewBf!=NULL);
278    strcpy(NewBf, Bf);
279    delete[] Bf; Bf=NewBf;
280  }
281  TChA::TChA(const TStr&amp; Str){
282    Bf=new char[(MxBfL=BfL=Str.Len())+1];
283    strcpy(Bf, Str.CStr());
284  }
285  void TChA::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
286    XSaveHdArg(Nm, &quot;BfL&quot;, TInt::GetStr(BfL));
287    SOut.PutStr(TXmlLx::GetXmlStrFromPlainStr(*this));
288  }
289  TChA&amp; TChA::operator=(const TChA&amp; ChA){
290    if (this!=&amp;ChA){
291      if (ChA.BfL&gt;MxBfL){delete[] Bf; Bf=new char[(MxBfL=ChA.BfL)+1];}
292      BfL=ChA.BfL; strcpy(Bf, ChA.CStr());
293    }
294    return *this;
295  }
296  TChA&amp; TChA::operator=(const TStr&amp; Str){
297    if (Str.Len()&gt;MxBfL){delete[] Bf; Bf=new char[(MxBfL=Str.Len())+1];}
298    BfL=Str.Len(); strcpy(Bf, Str.CStr());
299    return *this;
300  }
301  TChA&amp; TChA::operator=(const char* CStr){
302    int CStrLen=int(strlen(CStr));
303    if (CStrLen&gt;MxBfL){delete[] Bf; Bf=new char[(MxBfL=CStrLen)+1];}
304    BfL=CStrLen; strcpy(Bf, CStr);
305    return *this;
306  }
307  TChA&amp; TChA::operator+=(const TMem&amp; Mem) {
308    Resize(BfL+Mem.Len());
309    strcpy(Bf+BfL, Mem.GetBf()); BfL+=Mem.Len(); return *this;
310  }
311  TChA&amp; TChA::operator+=(const TChA&amp; ChA){
312    Resize(BfL+ChA.Len());
313    strcpy(Bf+BfL, ChA.CStr()); BfL+=ChA.Len(); return *this;
314  }
315  TChA&amp; TChA::operator+=(const TStr&amp; Str){
316    Resize(BfL+Str.Len());
317    strcpy(Bf+BfL, Str.CStr()); BfL+=Str.Len(); return *this;
318  }
319  TChA&amp; TChA::operator+=(const char* CStr){
320    int CStrLen=(int)strlen(CStr); Resize(BfL+CStrLen);
321    strcpy(Bf+BfL, CStr); BfL+=CStrLen; return *this;
322  }
323  void TChA::Ins(const int&amp; BChN, const char* CStr){
324    Assert((0&lt;=BChN)&amp;&amp;(BChN&lt;=BfL)); /&amp;bsol;** ali je &lt;= v (BChN&lt;=BfL) upravicen?
325    int CStrLen=int(strlen(CStr)); Resize(BfL+CStrLen);
326    memmove(Bf+BChN+CStrLen, Bf+BChN, BfL-BChN+1);
327    memmove(Bf+BChN, CStr, CStrLen); BfL+=CStrLen;
328  }
329  void TChA::Del(const int&amp; ChN){
330    Assert((0&lt;=ChN)&amp;&amp;(ChN&lt;BfL));
331    memmove(Bf+ChN, Bf+ChN+1, BfL-ChN);
332    BfL--;
333  }
334  void TChA::Trunc(){
335    int BChN=0; while ((BChN&lt;BfL)&amp;&amp;(GetCh(BChN)&lt;=&#x27; &#x27;)){BChN++;}
336    int EChN=BfL-1; while ((0&lt;=EChN)&amp;&amp;(GetCh(EChN)&lt;=&#x27; &#x27;)){EChN--;}
337    if (BChN&lt;=EChN){
338      for (int ChN=BChN; ChN&lt;=EChN; ChN++){
339        PutCh(ChN-BChN, GetCh(ChN));}
340      Trunc(EChN-BChN+1);
341    } else {
342      Clr();
343    }
344  }
345  void TChA::Reverse(){
346    for (int ChN=0; ChN&lt;BfL/2; ChN++){
347      char Ch=Bf[ChN];
348      Bf[ChN]=Bf[BfL-ChN-1];
349      Bf[BfL-ChN-1]=Ch;
350    }
351  }
352  TChA TChA::GetSubStr(const int&amp; _BChN, const int&amp; _EChN) const {
353    int BChN=TInt::GetMx(_BChN, 0);
354    int EChN=TInt::GetMn(_EChN, Len()-1);
355    int Chs=EChN-BChN+1;
356    if (Chs&lt;=0){return TStr::GetNullStr();}
357    else if (Chs==Len()){return *this;}
358    else {
359      return TChA(CStr()+BChN, Chs);
360    }
361  }
362  int TChA::CountCh(const char&amp; Ch, const int&amp; BChN) const {
363    int ChN=TInt::GetMx(BChN, 0);
364    const int ThisLen=Len();
365    int Cnt = 0;
366    while (ChN&lt;ThisLen){if (Bf[ChN]==Ch){ Cnt++;} ChN++;}
367    return Cnt;
368  }
369  int TChA::SearchCh(const char&amp; Ch, const int&amp; BChN) const {
370    int ChN=TInt::GetMx(BChN, 0);
371    const int ThisLen=Len();
372    while (ChN&lt;ThisLen){if (Bf[ChN]==Ch){return ChN;} ChN++;}
373    return -1;
374  }
375  int TChA::SearchChBack(const char&amp; Ch, int BChN) const {
376    if (BChN &gt;= Len() || BChN &lt; 0) { BChN = Len()-1; }
377    for (int i = BChN; i &gt;= 0; i--) {
378      if (GetCh(i) == Ch) { return i; }
379    }
380    return -1;
381  }
382  int TChA::SearchStr(const TChA&amp; Str, const int&amp; BChN) const {
383    return SearchStr(Str.CStr(), BChN);
384  }
385  int TChA::SearchStr(const TStr&amp; Str, const int&amp; BChN) const {
386    return SearchStr(Str.CStr(), BChN);
387  }
388  int TChA::SearchStr(const char* CStr, const int&amp; BChN) const {
389    const char* BegPos=strstr(Bf+BChN, CStr);
390    if (BegPos==NULL){return -1;}
391    else {return int(BegPos-Bf);}
392  }
393  bool TChA::IsPrefix(const char* CStr, const int&amp; BChN) const {
394    if (BChN+(int)strlen(CStr)&gt;Len()){return false;}
395    const char* B = Bf+BChN;
396    const char* C = CStr;
397    while (*C!=0 &amp;&amp; *B==*C) {
398      B++; C++;
399    }
400    if (*C==0){return true;}
401    else {return false;}
402  }
403  bool TChA::IsPrefix(const TStr&amp; Str) const {
404    return IsPrefix(Str.CStr());
405  }
406  bool TChA::IsPrefix(const TChA&amp; Str) const {
407    return IsPrefix(Str.CStr());
408  }
409  bool TChA::IsSuffix(const char* CStr) const {
410    if ((int)strlen(CStr) &gt; Len()) { return false; }
411    const char* E = Bf+Len()-1;
412    const char* C = CStr+strlen(CStr)-1;
413    while (C &gt;= CStr &amp;&amp; *E==*C) {
414      E--;  C--;
415    }
416    if (C+1 == CStr) { return true; }
417    else { return false; }
418  }
419  bool TChA::IsSuffix(const TStr&amp; Str) const {
420    return IsSuffix(Str.CStr());
421  }
422  bool TChA::IsSuffix(const TChA&amp; Str) const {
423    return IsSuffix(Str.CStr());
424  }
425  void TChA::ChangeCh(const char&amp; SrcCh, const char&amp; DstCh){
426    int StrLen=Len();
427    for (int ChN=0; ChN&lt;StrLen; ChN++){if (Bf[ChN]==SrcCh){Bf[ChN]=DstCh;}}
428  }
429  TChA&amp; TChA::ToLc() {
430    char *c = Bf;
431    while (*c) {
432      *c = (char) tolower(*c);  c++;
433    }
434    return *this;
435  }
436  TChA&amp; TChA::ToUc() {
437    char *c = Bf;
438    while (*c) {
439      *c = (char) toupper(*c); c++;
440    }
441    return *this;
442  }
443  TChA&amp; TChA::ToTrunc(){
444    int StrLen=Len(); int BChN=0; int EChN=StrLen-1;
445    while ((BChN&lt;StrLen)&amp;&amp;TCh::IsWs(GetCh(BChN))){BChN++;}
446    while ((EChN&gt;=0)&amp;&amp;TCh::IsWs(GetCh(EChN))){EChN--;}
447    if ((BChN!=0)||(EChN!=StrLen-1)){
448      int DstChN=0;
449      for (int SrcChN=BChN; SrcChN&lt;=EChN; SrcChN++){
450        PutCh(DstChN, GetCh(SrcChN)); DstChN++;}
451      Trunc(DstChN);
452    }
453    return *this;
454  }
455  void TChA::CompressWs(){
456    int StrLen=Len(); int SrcChN=0; int DstChN=0;
457    while ((SrcChN&lt;StrLen)&amp;&amp;TCh::IsWs(GetCh(SrcChN))){SrcChN++;}
458    while (SrcChN&lt;StrLen){
459      if ((TCh::IsWs(GetCh(SrcChN)))&amp;&amp;(DstChN&gt;0)&amp;&amp;(TCh::IsWs(GetCh(DstChN-1)))){
460        SrcChN++;
461      } else {
462        PutCh(DstChN, GetCh(SrcChN)); SrcChN++; DstChN++;
463      }
464    }
465    if ((DstChN&gt;0)&amp;&amp;(TCh::IsWs(GetCh(DstChN-1)))){DstChN--;}
466    Trunc(DstChN);
467  }
468  void TChA::Swap(const int&amp; ChN1, const int&amp; ChN2){
469    char Ch=GetCh(ChN1);
470    PutCh(ChN1, GetCh(ChN2));
471    PutCh(ChN2, Ch);
472  }
473  void TChA::Swap(TChA&amp; ChA) {
474    ::Swap(MxBfL, ChA.MxBfL);
475    ::Swap(BfL, ChA.BfL);
476    ::Swap(Bf, ChA.Bf);
477  }
478  int TChA::GetPrimHashCd() const {
479    return TStrHashF_DJB::GetPrimHashCd(CStr());
480  }
481  int TChA::GetSecHashCd() const {
482    return TStrHashF_DJB::GetSecHashCd(CStr());
483  }
484  void TChA::LoadTxt(const PSIn&amp; SIn, TChA&amp; ChA){
485    delete[] ChA.Bf;
486    ChA.Bf=new char[(ChA.MxBfL=ChA.BfL=SIn-&gt;Len())+1];
487    SIn-&gt;GetBf(ChA.CStr(), SIn-&gt;Len()); ChA.Bf[ChA.BfL]=0;
488  }
489  void TChA::SaveTxt(const PSOut&amp; SOut) const {
490    SOut-&gt;SaveBf(CStr(), Len());
491  }
492  TChAIn::TChAIn(const TChA&amp; ChA, const int&amp; _BfC):
493    TSBase(&quot;Input-Char-Array&quot;), TSIn(&quot;Input-Char-Array&quot;), Bf(ChA.CStr()), BfC(_BfC), BfL(ChA.Len()){}
494  int TChAIn::GetBf(const void* LBf, const TSize&amp; LBfL){
495    Assert(TSize(BfC+LBfL)&lt;=TSize(BfL));
496    int LBfS=0;
497    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
498      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
499    return LBfS;
500  }
501  bool TChAIn::GetNextLnBf(TChA&amp; LnChA){
502    FailR(TStr::Fmt(&quot;TChAIn::GetNextLnBf: not implemented&quot;).CStr());
503    return false;
504  }
505  bool TRStr::IsUc() const {
506    int StrLen=Len();
507    for (int ChN=0; ChN&lt;StrLen; ChN++){
508      if ((&#x27;a&#x27;&lt;=Bf[ChN])&amp;&amp;(Bf[ChN]&lt;=&#x27;z&#x27;)){return false;}}
509    return true;
510  }
511  void TRStr::ToUc(){
512    int StrLen=Len();
513    for (int ChN=0; ChN&lt;StrLen; ChN++){
514      Bf[ChN]=(char)toupper(Bf[ChN]);}}
515  bool TRStr::IsLc() const {
516    int StrLen=Len();
517    for (int ChN=0; ChN&lt;StrLen; ChN++){
518      if ((&#x27;A&#x27;&lt;=Bf[ChN])&amp;&amp;(Bf[ChN]&lt;=&#x27;Z&#x27;)){return false;}}
519    return true;
520  }
521  void TRStr::ToLc(){
522    int StrLen=Len();
523    for (int ChN=0; ChN&lt;StrLen; ChN++){
524      Bf[ChN]=(char)tolower(Bf[ChN]);}
525  }
526  void TRStr::ToCap(){
527    int StrLen=Len();
528    if (StrLen&gt;0){
529      Bf[0]=(char)toupper(Bf[0]);}
530    for (int ChN=1; ChN&lt;StrLen; ChN++){
531      Bf[ChN]=(char)tolower(Bf[ChN]);}
532  }
533  void TRStr::ConvUsFromYuAscii(){
534    int StrLen=Len();
535    for (int ChN=0; ChN&lt;StrLen; ChN++){
536      Bf[ChN]=TCh::GetUsFromYuAscii(Bf[ChN]);}
537  }
538  int TRStr::CmpI(const char* p, const char* r){
539    if (!p){return r ? (*r ? -1 : 0) : 0;}
540    if (!r){return (*p ? 1 : 0);}
541    while (*p &amp;&amp; *r){
542      int i=int(toupper(*p++))-int(toupper(*r++));
543      if (i!=0){return i;}
544    }
545    return int(toupper(*p++))-int(toupper(*r++));
546  }
547  int TRStr::GetPrimHashCd() const {
548    return TStrHashF_DJB::GetPrimHashCd(Bf);
549  }
550  int TRStr::GetSecHashCd() const {
551    return TStrHashF_DJB::GetSecHashCd(Bf);
552  }
553  TRStr* TStr::GetRStr(const char* CStr){
554    int CStrLen;
555    if (CStr==NULL){CStrLen=0;} else {CStrLen=int(strlen(CStr));}
556    if (CStrLen==0){return TRStr::GetNullRStr();}
557    else {return new TRStr(CStr);}
558  }
559  void TStr::Optimize(){
560    char* CStr=RStr-&gt;CStr(); int CStrLen=int(strlen(CStr));
561    TRStr* NewRStr;
562    if (CStrLen==0){NewRStr=TRStr::GetNullRStr();}
563    else {NewRStr=RStr;}
564    NewRStr-&gt;MkRef(); RStr-&gt;UnRef(); RStr=NewRStr;
565  }
566  void TStr::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
567    XLoadHd(Nm);
568    TStr TokStr=XmlTok-&gt;GetTokStr(false);
569    operator=(TokStr);
570  }
571  void TStr::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
572    TStr XmlStr=TXmlLx::GetXmlStrFromPlainStr(*this);
573    if (XmlStr.Empty()){XSaveBETag(Nm);}
574    else {XSaveHd(Nm); SOut.PutStr(XmlStr);}
575  }
576  TStr&amp; TStr::ToUc(){
577    TRStr* NewRStr=new TRStr(RStr-&gt;CStr()); NewRStr-&gt;ToUc();
578    RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
579    Optimize(); return *this;
580  }
581  TStr&amp; TStr::ToLc(){
582    TRStr* NewRStr=new TRStr(RStr-&gt;CStr()); NewRStr-&gt;ToLc();
583    RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
584    Optimize(); return *this;
585  }
586  TStr&amp; TStr::ToCap(){
587    TRStr* NewRStr=new TRStr(RStr-&gt;CStr()); NewRStr-&gt;ToCap();
588    RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
589    Optimize(); return *this;
590  }
591  TStr&amp; TStr::ToTrunc(){
592    int ThisLen=Len(); char* ThisBf=CStr();
593    int BChN=0; int EChN=ThisLen-1;
594    while ((BChN&lt;ThisLen)&amp;&amp;TCh::IsWs(ThisBf[BChN])){BChN++;}
595    while ((EChN&gt;=0)&amp;&amp;TCh::IsWs(ThisBf[EChN])){EChN--;}
596    *this=GetSubStr(BChN, EChN);
597    return *this;
598  }
599  TStr&amp; TStr::ConvUsFromYuAscii(){
600    TRStr* NewRStr=new TRStr(RStr-&gt;CStr()); NewRStr-&gt;ConvUsFromYuAscii();
601    RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
602    Optimize(); return *this;
603  }
604  TStr&amp; TStr::ToHex(){
605    TChA ChA;
606    int StrLen=Len();
607    for (int ChN=0; ChN&lt;StrLen; ChN++){
608      uchar Ch=uchar(RStr-&gt;Bf[ChN]);
609      char MshCh=TCh::GetHexCh((Ch/16)%16);
610      char LshCh=TCh::GetHexCh(Ch%16);
611      ChA+=MshCh; ChA+=LshCh;
612    }
613    *this=ChA;
614    return *this;
615  }
616  TStr&amp; TStr::FromHex(){
617    int StrLen=Len(); IAssert(StrLen%2==0);
618    TChA ChA; int ChN=0;
619    while (ChN&lt;StrLen){
620      char MshCh=RStr-&gt;Bf[ChN]; ChN++;
621      char LshCh=RStr-&gt;Bf[ChN]; ChN++;
622      uchar Ch=uchar(TCh::GetHex(MshCh)*16+TCh::GetHex(LshCh));
623      ChA+=Ch;
624    }
625    *this=ChA;
626    return *this;
627  }
628  TStr TStr::GetSubStr(const int&amp; _BChN, const int&amp; _EChN) const {
629    int StrLen=Len();
630    int BChN=TInt::GetMx(_BChN, 0);
631    int EChN=TInt::GetMn(_EChN, StrLen-1);
632    int Chs=EChN-BChN+1;
633    if (Chs&lt;=0){return TStr();}
634    else if (Chs==StrLen){return *this;}
635    else {
636      char* Bf=new char[Chs+1]; strncpy(Bf, CStr()+BChN, Chs); Bf[Chs]=0;
637      TStr Str(Bf); delete[] Bf;
638      return Str;
639    }
640  }
641  void TStr::InsStr(const int&amp; BChN, const TStr&amp; Str){
642    int ThisLen=Len();
643    IAssert((0&lt;=BChN)&amp;&amp;(BChN&lt;=ThisLen));
644    TStr NewStr;
645    if (BChN==0){
646      NewStr=Str+*this;
647    } else
648    if (BChN==ThisLen){
649      NewStr=*this+Str;
650    } else {
651      NewStr=GetSubStr(0, BChN-1)+Str+GetSubStr(BChN, ThisLen-1);
652    }
653    *this=NewStr;
654  }
655  void TStr::DelChAll(const char&amp; Ch){
656    TChA ChA(*this);
657    int ChN=ChA.SearchCh(Ch);
658    while (ChN!=-1){
659      ChA.Del(ChN);
660      ChN=ChA.SearchCh(Ch);
661    }
662    *this=ChA;
663  }
664  void TStr::DelSubStr(const int&amp; _BChN, const int&amp; _EChN){
665    int BChN=TInt::GetMx(_BChN, 0);
666    int EChN=TInt::GetMn(_EChN, Len()-1);
667    int Chs=Len()-(EChN-BChN+1);
668    if (Chs==0){Clr();}
669    else if (Chs&lt;Len()){
670      char* Bf=new char[Chs+1]; strncpy(Bf, CStr(), BChN);
671      strncpy(Bf+BChN, CStr()+EChN+1, Len()-EChN-1); Bf[Chs]=0;
672      TStr Str(Bf); delete[] Bf;
673      *this=Str;
674    }
675  }
676  bool TStr::DelStr(const TStr&amp; Str){
677    int ChN=SearchStr(Str);
678    if (ChN==-1){
679      return false;
680    } else {
681      DelSubStr(ChN, ChN+Str.Len()-1);
682      return true;
683    }
684  }
685  TStr TStr::LeftOf(const char&amp; SplitCh) const {
686    int ThisLen=Len(); const char* ThisBf=CStr();
687    int ChN=0;
688    while ((ChN&lt;ThisLen)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN++;}
689    return (ChN==ThisLen) ? &quot;&quot; : GetSubStr(0, ChN-1);
690  }
691  TStr TStr::LeftOfLast(const char&amp; SplitCh) const {
692    const char* ThisBf=CStr();
693    int ChN=Len()-1;
694    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN--;}
695    return (ChN==-1) ? &quot;&quot; : GetSubStr(0, ChN-1);
696  }
697  TStr TStr::RightOf(const char&amp; SplitCh) const {
698    int ThisLen=Len(); const char* ThisBf=CStr();
699    int ChN=0;
700    while ((ChN&lt;ThisLen)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN++;}
701    return (ChN==ThisLen) ? &quot;&quot; : GetSubStr(ChN+1, ThisLen-1);
702  }
703  TStr TStr::RightOfLast(const char&amp; SplitCh) const {
704    int ThisLen=Len(); const char* ThisBf=CStr();
705    int ChN=Len()-1;
706    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN--;}
707    return (ChN==-1) ? &quot;&quot; : GetSubStr(ChN+1, ThisLen-1);
708  }
709  void TStr::SplitOnCh(TStr&amp; LStr, const char&amp; SplitCh, TStr&amp; RStr) const {
710    int ThisLen=Len(); const char* ThisBf=CStr();
711    int ChN=0;
712    while ((ChN&lt;ThisLen)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN++;}
713    if (ChN==ThisLen){
714      LStr=GetSubStr(0, ThisLen-1); RStr=&quot;&quot;;
715    } else {
716      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
717    }
718  }
719  void TStr::SplitOnLastCh(TStr&amp; LStr, const char&amp; SplitCh, TStr&amp; RStr) const {
720    int ThisLen=Len(); const char* ThisBf=CStr();
721    int ChN=Len()-1;
722    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=SplitCh)){ChN--;}
723    if (ChN==-1){
724      LStr=&quot;&quot;; RStr=*this;
725    } else
726    if (ChN==0){
727      LStr=&quot;&quot;; RStr=GetSubStr(1, ThisLen-1);
728    } else {
729      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
730    }
731  }
732  void TStr::SplitOnAllCh(
733   const char&amp; SplitCh, TStrV&amp; StrV, const bool&amp; SkipEmpty) const {
734    StrV.Clr();
735    char* Bf=new char[Len()+1];
736    strcpy(Bf, CStr());
737    char* CurStrBf=Bf;
738    forever{
739      char* BfC=CurStrBf;
740      while ((*BfC!=0)&amp;&amp;(*BfC!=SplitCh)){BfC++;}
741      bool IsEnd=(*BfC==&#x27;\0&#x27;);
742      *BfC=0;
743      if ((BfC&gt;CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
744      if (IsEnd){break;}
745      CurStrBf=BfC+1;
746    }
747    delete[] Bf;
748  }
749  void TStr::SplitOnAllAnyCh(
750   const TStr&amp; SplitChStr, TStrV&amp; StrV, const bool&amp; SkipEmpty) const {
751    StrV.Clr();
752    char* Bf=new char[Len()+1];
753    strcpy(Bf, CStr());
754    char* CurStrBf=Bf; 
755    const char* SplitChBf=SplitChStr.CStr();
756    forever{
757      char* BfC=CurStrBf; 
758      while (*BfC!=0){
759        const char* SplitChBfC=SplitChBf; 
760        while ((*SplitChBfC!=0)&amp;&amp;(*SplitChBfC!=*BfC)){SplitChBfC++;}
761        if (*SplitChBfC!=0){break;} 
762        BfC++;
763      }
764      bool IsEnd=(*BfC==0);
765      *BfC=0;
766      if ((BfC&gt;CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
767      if (IsEnd){break;}
768      CurStrBf=BfC+1;
769    }
770    delete[] Bf;
771  }
772  void TStr::SplitOnWs(TStrV&amp; StrV) const {
773    StrV.Clr();
774    char* Bf=new char[Len()+1];
775    strcpy(Bf, CStr());
776    char* StrBf=Bf;
777    forever{
778      while ((*StrBf!=0)&amp;&amp;(TCh::IsWs(*StrBf))){StrBf++;}
779      char* BfC=StrBf;
780      while ((*BfC!=0)&amp;&amp;(!TCh::IsWs(*BfC))){BfC++;}
781      bool IsEnd=(*BfC==&#x27;\0&#x27;);
782      *BfC=0;
783      if (BfC&gt;StrBf){StrV.Add(TStr(StrBf));}
784      if (IsEnd){break;}
785      StrBf=BfC+1;
786    }
787    delete[] Bf;
788  }
789  void TStr::SplitOnNonAlNum(TStrV&amp; StrV) const {
790    StrV.Clr();
791    char* Bf=new char[Len()+1];
792    strcpy(Bf, CStr());
793    char* StrBf=Bf;
794    forever{
795      while ((*StrBf!=0)&amp;&amp;(!TCh::IsAlNum(*StrBf))){StrBf++;}
796      char* BfC=StrBf;
797      while ((*BfC!=0)&amp;&amp;(TCh::IsAlNum(*BfC))){BfC++;}
798      bool IsEnd=(*BfC==&#x27;\0&#x27;);
799      *BfC=0;
800      if (BfC&gt;StrBf){StrV.Add(TStr(StrBf));}
801      if (IsEnd){break;}
802      StrBf=BfC+1;
803    }
804    delete[] Bf;
805  }
806  void TStr::SplitOnStr(const TStr&amp; SplitStr, TStrV&amp; StrV) const {
807    StrV.Clr();
808    int SplitStrLen=SplitStr.Len();
809    int PrevChN=0; int ChN=0;
810    while ((ChN=SearchStr(SplitStr, ChN))!=-1){
811      TStr SubStr=GetSubStr(PrevChN, ChN-1);
812      StrV.Add(SubStr);
813      PrevChN=ChN=ChN+SplitStrLen;
814    }
815    TStr LastSubStr=GetSubStr(PrevChN, Len()-1);
816    StrV.Add(LastSubStr);
817  }
818  void TStr::SplitOnStr(TStr&amp; LeftStr, const TStr&amp; MidStr, TStr&amp; RightStr) const {
819    const int ChN=SearchStr(MidStr);
820    if (ChN==-1){
821      LeftStr=*this; RightStr=GetNullStr();
822    } else {
823      LeftStr=GetSubStr(0, ChN-1);
824      RightStr=GetSubStr(ChN+MidStr.Len(), Len()-1);
825    }
826  }
827  int TStr::CountCh(const char&amp; Ch, const int&amp; BChN) const {
828    const int ThisLen=Len();
829    const char* ThisBf=CStr();
830    int Chs=0;
831    for (int ChN=TInt::GetMx(BChN, 0); ChN&lt;ThisLen; ChN++){
832      if (ThisBf[ChN]==Ch){Chs++;}
833    }
834    return Chs;
835  }
836  int TStr::SearchCh(const char&amp; Ch, const int&amp; BChN) const {
837    int ThisLen=Len(); const char* ThisBf=CStr();
838    int ChN=TInt::GetMx(BChN, 0);
839    while (ChN&lt;ThisLen){
840      if (ThisBf[ChN]==Ch){return ChN;}
841      ChN++;
842    }
843    return -1;
844  }
845  int TStr::SearchChBack(const char&amp; Ch, int BChN) const {
846    const int StrLen=Len();
847    if (BChN==-1||BChN&gt;=StrLen){BChN=StrLen-1;}
848    const char* ThisBf=CStr();
849    const char* Pt=ThisBf + BChN;
850    while (Pt&gt;=ThisBf) {
851      if (*Pt==Ch){return (int)(Pt-ThisBf);}
852      Pt--;
853    }
854    return -1;
855  }
856  int TStr::SearchStr(const TStr&amp; Str, const int&amp; BChN) const {
857    int NrBChN=TInt::GetMx(BChN, 0);
858    const char* StrPt=strstr((const char*)CStr()+NrBChN, Str.CStr());
859    if (StrPt==NULL){return -1;}
860    else {return int(StrPt-CStr());}
861  }
862  bool TStr::IsPrefix(const char *Str) const {
863  	size_t len = strlen(Str);
864  	size_t thisLen = Len();
865  	if (len &gt; thisLen) {
866  		return false;
867  	} else {
868          size_t minLen = MIN(len, thisLen);
869  		int cmp = strncmp(Str, RStr-&gt;Bf, minLen);
870  		return cmp == 0;
871  	}
872  }
873  bool TStr::IsSuffix(const char *Str) const {
874  	size_t len = strlen(Str);
875  	size_t thisLen = Len();
876  	if (len &gt; thisLen) {
877  		return false;
878  	} else {
879  		const char *ending = RStr-&gt;Bf + thisLen - len;
880  		int cmp = strncmp(Str, ending, len);
881  		return cmp == 0;
882  	}
883  }
884  int TStr::ChangeCh(const char&amp; SrcCh, const char&amp; DstCh, const int&amp; BChN){
885    int ChN=SearchCh(SrcCh, BChN);
886    if (ChN!=-1){PutCh(ChN, DstCh);}
887    return ChN;
888  }
889  int TStr::ChangeChAll(const char&amp; SrcCh, const char&amp; DstCh){
890    int FirstChN=SearchCh(SrcCh);
891    if (FirstChN==-1){
892      return 0;
893    } else {
894      TRStr* NewRStr=new TRStr(RStr-&gt;CStr());
895      RStr-&gt;UnRef(); RStr=NewRStr; RStr-&gt;MkRef();
896      char* ThisBf=CStr(); int StrLen=Len(); int Changes=0;
897      for (int ChN=FirstChN; ChN&lt;StrLen; ChN++){
898        if (ThisBf[ChN]==SrcCh){ThisBf[ChN]=DstCh; Changes++;}
899      }
900      Optimize();
901      return Changes;
902    }
903  }
904  int TStr::ChangeStr(const TStr&amp; SrcStr, const TStr&amp; DstStr, const int&amp; BChN){
905    int ChN=SearchStr(SrcStr, BChN);
906    if (ChN==-1){
907      return -1;
908    } else {
909      DelSubStr(ChN, ChN+SrcStr.Len()-1);
910      InsStr(ChN, DstStr);
911      return ChN;
912    }
913  }
914  int TStr::ChangeStrAll(const TStr&amp; SrcStr, const TStr&amp; DstStr, const bool&amp; FromStartP){
915    const int DstStrLen=DstStr.Len();
916    int Changes=0-1; int BChN=0-DstStrLen;
917    do {
918      Changes++;
919      if (FromStartP){BChN=0-DstStrLen;}
920      BChN+=DstStrLen;
921      BChN=ChangeStr(SrcStr, DstStr, BChN);
922    } while (BChN!=-1);
923    return Changes;
924  }
925  bool TStr::IsBool(bool&amp; Val) const {
926    if (operator==(&quot;T&quot;)){Val=true; return true;}
927    else if (operator==(&quot;F&quot;)){Val=false; return true;}
928    else {return false;}
929  }
930  bool TStr::IsInt(
931   const bool&amp; Check, const int&amp; MnVal, const int&amp; MxVal, int&amp; Val) const {
932    int _Val=0;
933    bool Minus=false;
934    TChRet Ch(TStrIn::New(*this));
935    while (TCh::IsWs(Ch.GetCh())){}
936    if (Ch()==&#x27;+&#x27;){Minus=false; Ch.GetCh();}
937    if (Ch()==&#x27;-&#x27;){Minus=true; Ch.GetCh();}
938    if (!TCh::IsNum(Ch())){return false;}
939    _Val=TCh::GetNum(Ch());
940    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
941    if (Minus){_Val=-_Val;}
942    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
943    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
944  }
945  bool TStr::IsUInt(
946   const bool&amp; Check, const uint&amp; MnVal, const uint&amp; MxVal, uint&amp; Val) const {
947    uint _Val=0;
948    TChRet Ch(TStrIn::New(*this));
949    while (TCh::IsWs(Ch.GetCh())){}
950    if (Ch()==&#x27;+&#x27;){Ch.GetCh();}
951    if (!TCh::IsNum(Ch())){return false;}
952    _Val=TCh::GetNum(Ch());
953    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
954    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
955    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
956  }
957  bool TStr::IsHexInt( const bool&amp; Check, const int&amp; MnVal, const int&amp; MxVal, int&amp; Val) const {
958    int _Val=0;
959    bool Minus=false;
960    TChRet Ch(TStrIn::New(*this));
961    while (TCh::IsWs(Ch.GetCh())){}
962    if (Ch()==&#x27;+&#x27;){Minus=false; Ch.GetCh();}
963    if (Ch()==&#x27;-&#x27;){Minus=true; Ch.GetCh();}
964    if (Ch()==&#x27;0&#x27;){
965      Ch.GetCh();
966      if (tolower(Ch())==&#x27;x&#x27; ){
967        Ch.GetCh(); if (Ch.Eof()){return false;}
968      }
969    }
970    if (!Ch.Eof() &amp;&amp; !TCh::IsHex(Ch())){return false;}
971    if (!Ch.Eof()) _Val = TCh::GetHex(Ch());
972    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
973    if (Minus){_Val=-_Val;}
974    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
975    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
976  }
977  bool TStr::IsInt64(
978   const bool&amp; Check, const int64&amp; MnVal, const int64&amp; MxVal, int64&amp; Val) const {
979    int64 _Val=0;
980    bool Minus=false;
981    TChRet Ch(TStrIn::New(*this));
982    while (TCh::IsWs(Ch.GetCh())){}
983    if (Ch()==&#x27;+&#x27;){Minus=false; Ch.GetCh();}
984    if (Ch()==&#x27;-&#x27;){Minus=true; Ch.GetCh();}
985    if (!TCh::IsNum(Ch())){return false;}
986    _Val=TCh::GetNum(Ch());
987    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
988    if (Minus){_Val=-_Val;}
989    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
990    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
991  }
992  bool TStr::IsUInt64(
993   const bool&amp; Check, const uint64&amp; MnVal, const uint64&amp; MxVal, uint64&amp; Val) const {
994    uint64 _Val=0;
995    TChRet Ch(TStrIn::New(*this));
996    while (TCh::IsWs(Ch.GetCh())){}
997    if (Ch()==&#x27;+&#x27;){Ch.GetCh();}
998    if (!TCh::IsNum(Ch())){return false;}
999    _Val=TCh::GetNum(Ch());
1000    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
1001    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
1002    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1003  }
1004  bool TStr::IsHexInt64(
1005   const bool&amp; Check, const int64&amp; MnVal, const int64&amp; MxVal, int64&amp; Val) const {
1006    int64 _Val=0;
1007    bool Minus=false;
1008    TChRet Ch(TStrIn::New(*this));
1009    while (TCh::IsWs(Ch.GetCh())){}
1010    if (Ch()==&#x27;+&#x27;){Minus=false; Ch.GetCh();}
1011    if (Ch()==&#x27;-&#x27;){Minus=true; Ch.GetCh();}
1012    if (Ch()==&#x27;0&#x27;){
1013      Ch.GetCh();
1014      if (tolower(Ch())==&#x27;x&#x27; ){
1015        Ch.GetCh(); if (Ch.Eof()){return false;}
1016      }
1017    }
1018    if (!Ch.Eof()) _Val=TCh::GetHex(Ch());
1019    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
1020    if (Minus){_Val=-_Val;}
1021    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){return false;}
1022    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1023  }
1024  bool TStr::IsFlt(const bool&amp; Check, const double&amp; MnVal, const double&amp; MxVal,
1025   double&amp; Val, const char&amp; DecDelimCh) const {
1026    TChRet Ch(TStrIn::New(*this));
1027    while (TCh::IsWs(Ch.GetCh())){}
1028    if ((Ch()==&#x27;+&#x27;)||(Ch()==&#x27;-&#x27;)){Ch.GetCh();}
1029    if (!TCh::IsNum(Ch())&amp;&amp;Ch()!=DecDelimCh){return false;}
1030    while (TCh::IsNum(Ch.GetCh())){}
1031    if (Ch()==DecDelimCh){
1032      Ch.GetCh();
1033      while (TCh::IsNum(Ch.GetCh())){}
1034    }
1035    if ((Ch()==&#x27;e&#x27;)||(Ch()==&#x27;E&#x27;)){
1036      Ch.GetCh();
1037      if ((Ch()==&#x27;+&#x27;)||(Ch()==&#x27;-&#x27;)){Ch.GetCh();}
1038      if (!TCh::IsNum(Ch())){return false;}
1039      while (TCh::IsNum(Ch.GetCh())){}
1040    }
1041    if (!Ch.Eof()){return false;}
1042    double _Val=atof(CStr());
1043    if (Check&amp;&amp;((_Val&lt;MnVal)||(_Val&gt;MxVal))){
1044      return false;
1045    } else {
1046      Val=_Val; return true;
1047    }
1048  }
1049  bool TStr::IsWord(const bool&amp; WsPrefixP, const bool&amp; FirstUcAllowedP) const {
1050    TChRet Ch(TStrIn::New(*this));
1051    if (WsPrefixP){while (TCh::IsWs(Ch.GetCh())){}}
1052    else {Ch.GetCh();}
1053    if (!TCh::IsAlpha(Ch())){return false;}
1054    else if (!FirstUcAllowedP&amp;&amp;(TCh::IsUc(Ch()))){return false;}
1055    while (TCh::IsAlNum(Ch.GetCh())){}
1056    if (!Ch.Eof()){return false;}
1057    return true;
1058  }
1059  bool TStr::IsWs() const {
1060    TChRet Ch(TStrIn::New(*this));
1061    while (TCh::IsWs(Ch.GetCh())){}
1062    return Ch.Eof();
1063  }
1064  bool TStr::IsWcMatch(
1065   const int&amp; StrBChN, const TStr&amp; WcStr, const int&amp; WcStrBChN, TStrV&amp; StarStrV,
1066   const char&amp; StarCh, const char&amp; QuestCh) const {
1067    int StrLen=Len(); int WcStrLen=WcStr.Len();
1068    int StrChN=StrBChN; int WcStrChN=WcStrBChN;
1069    while ((StrChN&lt;StrLen)&amp;&amp;(WcStrChN&lt;WcStrLen)){
1070      if ((WcStr[WcStrChN]==QuestCh)||(GetCh(StrChN)==WcStr[WcStrChN])){
1071        StrChN++; WcStrChN++;
1072      } else
1073      if (WcStr[WcStrChN]==StarCh){
1074        TChA StarChA; 
1075        for (int AfterStrChN=StrChN; AfterStrChN&lt;=StrLen; AfterStrChN++){
1076          if (AfterStrChN&gt;StrChN){
1077            StarChA+=GetCh(AfterStrChN-1);}
1078          if (IsWcMatch(AfterStrChN, WcStr, WcStrChN+1, StarStrV, StarCh, QuestCh)){
1079            StarStrV.Add(StarChA); return true;
1080          }
1081        }
1082        return false;
1083      } else {
1084        return false;
1085      }
1086    }
1087    if (StrChN==StrLen){
1088      for (int AfterWcStrChN=WcStrChN; AfterWcStrChN&lt;WcStrLen; AfterWcStrChN++){
1089        if (WcStr[AfterWcStrChN]!=StarCh){return false;}}
1090      return true;
1091    } else {
1092      return false;
1093    }
1094  }
1095  bool TStr::IsWcMatch(
1096   const TStr&amp; WcStr, TStrV&amp; StarStrV, const char&amp; StarCh, const char&amp; QuestCh) const {
1097    bool WcMatch=IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1098    if (WcMatch){
1099      StarStrV.Reverse();
1100      return true;
1101    } else {
1102      return false;
1103    }
1104  }
1105  bool TStr::IsWcMatch(
1106   const TStr&amp; WcStr, const char&amp; StarCh, const char&amp; QuestCh) const {
1107    TStrV StarStrV;
1108    return IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1109  }
1110  bool TStr::IsWcMatch(const TStr&amp; WcStr, const int&amp; StarStrN, TStr&amp; StarStr) const {
1111    TStrV StarStrV;
1112    if (IsWcMatch(WcStr, StarStrV)){
1113      if (StarStrV.Len()&gt;StarStrN){
1114        StarStr=StarStrV[StarStrV.Len()-StarStrN-1];
1115      } else {
1116        StarStr=&quot;&quot;;
1117      }
1118      return true;
1119    } else {
1120      return false;
1121    }
1122  }
1123  bool TStr::IsWcMatch(const TStr&amp; WcStr) const {
1124    TStrV StarStrV;
1125    return IsWcMatch(0, WcStr, 0, StarStrV);
1126  }
1127  TStr TStr::GetWcMatch(const TStr&amp; WcStr, const int&amp; StarStrN) const {
1128    TStrV StarStrV;
1129    if (IsWcMatch(WcStr, StarStrV)&amp;&amp;(StarStrV.Len()&gt;=StarStrN)){
1130      IAssert(StarStrN&gt;=0);
1131      return StarStrV[StarStrV.Len()-StarStrN-1];
1132    } else {
1133      return &quot;&quot;;
1134    }
1135  }
1136  TStr TStr::GetFPath() const {
1137    int ThisLen=Len(); const char* ThisBf=CStr();
1138    int ChN=ThisLen-1;
1139    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)){ChN--;}
1140    return GetSubStr(0, ChN);
1141  }
1142  TStr TStr::GetFBase() const {
1143    int ThisLen=Len(); const char* ThisBf=CStr();
1144    int ChN=ThisLen-1;
1145    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)){ChN--;}
1146    return GetSubStr(ChN+1, ThisLen);
1147  }
1148  TStr TStr::GetFMid() const {
1149    int ThisLen=Len(); const char* ThisBf=CStr();
1150    int ChN=ThisLen-1;
1151    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;.&#x27;)){
1152      ChN--;}
1153    if (ChN&lt;0){
1154      return *this;
1155    } else {
1156      if (ThisBf[ChN]==&#x27;.&#x27;){
1157        int EChN= --ChN;
1158        while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)){ChN--;}
1159        return GetSubStr(ChN+1, EChN);
1160      } else {
1161        return GetSubStr(ChN+1, ThisLen);
1162      }
1163    }
1164  }
1165  TStr TStr::GetFExt() const {
1166    int ThisLen=Len(); const char* ThisBf=CStr();
1167    int ChN=ThisLen-1;
1168    while ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]!=&#x27;/&#x27;)&amp;&amp;(ThisBf[ChN]!=&#x27;\\&#x27;)&amp;&amp;
1169     (ThisBf[ChN]!=&#x27;.&#x27;)){ChN--;}
1170    if ((ChN&gt;=0)&amp;&amp;(ThisBf[ChN]==&#x27;.&#x27;)){return GetSubStr(ChN, Len());}
1171    else {return TStr();}
1172  }
1173  TStr TStr::GetNrFPath(const TStr&amp; FPath){
1174    TChA NrFPath(FPath.Len()+4); NrFPath+=FPath;
1175    NrFPath.ChangeCh(&#x27;\\&#x27;, &#x27;/&#x27;);
1176    if (NrFPath.Empty()){NrFPath=&quot;./&quot;;}
1177    if ((NrFPath.Len()&gt;=2)&amp;&amp;isalpha(NrFPath[0])&amp;&amp;(NrFPath[1]==&#x27;:&#x27;)){
1178      if (NrFPath.Len()==2){NrFPath+=&quot;./&quot;;}
1179      if ((NrFPath[2]!=&#x27;.&#x27;)&amp;&amp;(NrFPath[2]!=&#x27;/&#x27;)){NrFPath.Ins(2, &quot;./&quot;);}
1180      if (NrFPath[NrFPath.Len()-1]!=&#x27;/&#x27;){NrFPath+=&quot;/&quot;;}
1181    } else {
1182      if ((NrFPath[0]!=&#x27;.&#x27;)&amp;&amp;(NrFPath[0]!=&#x27;/&#x27;)){NrFPath.Ins(0, &quot;./&quot;);}
1183      if (NrFPath[NrFPath.Len()-1]!=&#x27;/&#x27;){NrFPath+=&quot;/&quot;;}
1184    }
1185    return NrFPath;
1186  }
1187  TStr TStr::GetNrFMid(const TStr&amp; FMid){
1188    TChA NrFMid;
1189    int FMidLen=FMid.Len();
1190    for (int ChN=0; ChN&lt;FMidLen; ChN++){
1191      char Ch=FMid[ChN];
1192      if (TCh::IsAlNum(Ch)){NrFMid+=Ch;} else {NrFMid+=&#x27;_&#x27;;}
1193    }
1194    return NrFMid;
1195  }
1196  TStr TStr::GetNrFExt(const TStr&amp; FExt){
1197    if (FExt.Empty()||(FExt[0]==&#x27;.&#x27;)){return FExt;}
1198    else {return TStr(&quot;.&quot;)+FExt;}
1199  }
1200  TStr TStr::GetNrNumFExt(const int&amp; FExtN){
1201    TStr FExtNStr=TInt::GetStr(FExtN);
1202    while (FExtNStr.Len()&lt;3){
1203      FExtNStr=TStr(&quot;0&quot;)+FExtNStr;}
1204    return FExtNStr;
1205  }
1206  TStr TStr::GetNrFNm(const TStr&amp; FNm){
1207    return GetNrFPath(FNm.GetFPath())+FNm.GetFMid()+GetNrFExt(FNm.GetFExt());
1208  }
1209  TStr TStr::GetNrAbsFPath(const TStr&amp; FPath, const TStr&amp; BaseFPath){
1210    TStr NrBaseFPath;
1211    if (BaseFPath.Empty()){
1212      NrBaseFPath=GetNrFPath(TDir::GetCurDir());
1213    } else {
1214      NrBaseFPath=GetNrFPath(BaseFPath);
1215    }
1216    IAssert(IsAbsFPath(NrBaseFPath));
1217    TStr NrFPath=GetNrFPath(FPath);
1218    TStr NrAbsFPath;
1219    if (IsAbsFPath(NrFPath)){
1220      NrAbsFPath=NrFPath;
1221    } else {
1222      NrAbsFPath=GetNrFPath(NrBaseFPath+NrFPath);
1223    }
1224    NrAbsFPath.ChangeStrAll(&quot;/./&quot;, &quot;/&quot;);
1225    NrAbsFPath.ChangeStrAll(&quot;\\.\\&quot;, &quot;\\&quot;);
1226    return NrAbsFPath;
1227  }
1228  bool TStr::IsAbsFPath(const TStr&amp; FPath){
1229    if ((FPath.Len()&gt;=3)&amp;&amp;isalpha(FPath[0])&amp;&amp;(FPath[1]==&#x27;:&#x27;)&amp;&amp;
1230     ((FPath[2]==&#x27;/&#x27;)||(FPath[2]==&#x27;\\&#x27;))){
1231      return true;
1232    }
1233    return false;
1234  }
1235  TStr TStr::PutFExt(const TStr&amp; FNm, const TStr&amp; FExt){
1236    return FNm.GetFPath()+FNm.GetFMid()+FExt;
1237  }
1238  TStr TStr::PutFExtIfEmpty(const TStr&amp; FNm, const TStr&amp; FExt){
1239    if (FNm.GetFExt().Empty()){
1240      return FNm.GetFPath()+FNm.GetFMid()+FExt;
1241    } else {
1242      return FNm;
1243    }
1244  }
1245  TStr TStr::PutFBase(const TStr&amp; FNm, const TStr&amp; FBase){
1246    return FNm.GetFPath()+FBase;
1247  }
1248  TStr TStr::PutFBaseIfEmpty(const TStr&amp; FNm, const TStr&amp; FBase){
1249    if (FNm.GetFBase().Empty()){
1250      return FNm.GetFPath()+FBase;
1251    } else {
1252      return FNm;
1253    }
1254  }
1255  TStr TStr::AddToFMid(const TStr&amp; FNm, const TStr&amp; ExtFMid){
1256    return FNm.GetFPath()+FNm.GetFMid()+ExtFMid+FNm.GetFExt();
1257  }
1258  TStr TStr::GetNumFNm(const TStr&amp; FNm, const int&amp; Num){
1259    return FNm.GetFPath()+FNm.GetFMid()+TInt::GetStr(Num, &quot;%03d&quot;)+FNm.GetFExt();
1260  }
1261  TStr TStr::GetFNmStr(const TStr&amp; Str, const bool&amp; AlNumOnlyP){
1262    TChA FNm=Str;
1263    for (int ChN=0; ChN&lt;FNm.Len(); ChN++){
1264      uchar Ch=FNm[ChN];
1265      if (AlNumOnlyP){
1266        if (
1267         ((&#x27;0&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;9&#x27;))||
1268         ((&#x27;A&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;Z&#x27;))||
1269         ((&#x27;a&#x27;&lt;=Ch)&amp;&amp;(Ch&lt;=&#x27;z&#x27;))||
1270         (Ch==&#x27;-&#x27;)||(Ch==&#x27;_&#x27;)){}
1271        else {Ch=&#x27;_&#x27;;}
1272      } else {
1273        if ((Ch&lt;=&#x27; &#x27;)||(Ch==&#x27;/&#x27;)||(Ch==&#x27;\\&#x27;)||(Ch==&#x27;:&#x27;)||(Ch==&#x27;.&#x27;)){
1274          Ch=&#x27;_&#x27;;}
1275      }
1276      FNm.PutCh(ChN, Ch);
1277    }
1278    return FNm;
1279  }
1280  TStr&amp; TStr::GetChStr(const char&amp; Ch){
1281    static char MnCh=char(CHAR_MIN);
1282    static char MxCh=char(CHAR_MAX);
1283    static int Chs=int(MxCh)-int(MnCh)+1;
1284    static TStrV ChStrV;
1285    if (ChStrV.Empty()){
1286      ChStrV.Gen(Chs);
1287      for (int ChN=0; ChN&lt;Chs; ChN++){
1288        ChStrV[ChN]=TStr(char(MnCh+ChN), true);}
1289    }
1290    return ChStrV[int(Ch-MnCh)];
1291  }
1292  TStr&amp; TStr::GetDChStr(const char&amp; Ch1, const char&amp; Ch2){
1293    Fail; 
1294    static TStrVV DChStrVV;
1295    if (DChStrVV.Empty()){
1296      DChStrVV.Gen(TCh::Vals, TCh::Vals);
1297      for (int Ch1N=0; Ch1N&lt;TCh::Vals; Ch1N++){
1298        for (int Ch2N=0; Ch2N&lt;TCh::Vals; Ch2N++){
1299          DChStrVV.At(Ch1N, Ch2N)=
1300           TStr(char(TCh::Mn+Ch1N), char(TCh::Mn+Ch2N), true);
1301        }
1302      }
1303    }
1304    return DChStrVV.At(int(Ch1-TCh::Mn), int(Ch2-TCh::Mn));
1305  }
1306  TStr TStr::GetStr(const TStr&amp; Str, const char* FmtStr){
1307    if (FmtStr==NULL){
1308      return Str;
1309    } else {
1310      char Bf[1000];
1311      sprintf(Bf, FmtStr, Str.CStr());
1312      return TStr(Bf);
1313    }
1314  }
1315  TStr TStr::GetStr(const TStrV&amp; StrV, const TStr&amp; DelimiterStr){
1316    if (StrV.Empty()){return TStr();}
1317    TChA ResStr=StrV[0];
1318    for (int StrN=1; StrN&lt;StrV.Len(); StrN++){
1319      ResStr+=DelimiterStr;
1320      ResStr+=StrV[StrN];
1321    }
1322    return ResStr;
1323  }
1324  TStr TStr::Fmt(const char *FmtStr, ...){
1325    char Bf[10*1024];
1326    va_list valist;
1327    va_start(valist, FmtStr);
1328    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
1329    va_end(valist);
1330    return RetVal!=-1 ? TStr(Bf) : TStr::GetNullStr();
1331  }
1332  TStr TStr::GetSpaceStr(const int&amp; Spaces){
1333    static TStrV SpaceStrV;
1334    if (SpaceStrV.Len()==0){
1335      for (int SpaceStrN=0; SpaceStrN&lt;10; SpaceStrN++){
1336        TChA SpaceChA;
1337        for (int ChN=0; ChN&lt;SpaceStrN; ChN++){SpaceChA+=&#x27; &#x27;;}
1338        SpaceStrV.Add(SpaceChA);
1339      }
1340    }
1341    if ((0&lt;=Spaces)&amp;&amp;(Spaces&lt;SpaceStrV.Len())){
1342      return SpaceStrV[Spaces];
1343    } else {
1344      TChA SpaceChA;
1345      for (int ChN=0; ChN&lt;Spaces; ChN++){SpaceChA+=&#x27; &#x27;;}
1346      return SpaceChA;
1347    }
1348  }
1349  TStr TStr::GetNullStr(){
1350    static TStr NullStr=&quot;&quot;;
1351    return NullStr;
1352  }
1353  TStr operator+(const TStr&amp; LStr, const TStr&amp; RStr){
1354    if (LStr.Empty()){return RStr;}
1355    else if (RStr.Empty()){return LStr;}
1356    else {return TStr(LStr)+=RStr;}
1357  }
1358  TStr operator+(const TStr&amp; LStr, const char* RCStr){
1359    return TStr(LStr)+=RCStr;
1360  }
1361  TStrIn::TStrIn(const TStr&amp; _Str):
1362    TSBase(&quot;Input-String&quot;), TSIn(&quot;Input-String&quot;), Str(_Str), Bf(Str.CStr()), BfC(0), BfL(Str.Len()){}
1363  int TStrIn::GetBf(const void* LBf, const TSize&amp; LBfL){
1364    Assert(TSize(BfC+LBfL)&lt;=TSize(BfL));
1365    int LBfS=0;
1366    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
1367      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
1368    return LBfS;
1369  }
1370  bool TStrIn::GetNextLnBf(TChA&amp; LnChA){
1371    FailR(TStr::Fmt(&quot;TStrIn::GetNextLnBf: not implemented&quot;).CStr());
1372    return false;
1373  }
1374  void TStrPool::Resize(const uint&amp; _MxBfL) {
1375    uint newSize = MxBfL;
1376    while (newSize &lt; _MxBfL) {
1377      if (newSize &gt;= GrowBy &amp;&amp; GrowBy &gt; 0) newSize += GrowBy;
1378      else if (newSize &gt; 0) newSize *= 2;
1379      else newSize = TInt::GetMn(GrowBy, 1024);
1380      IAssertR(newSize &gt;= MxBfL, TStr::Fmt(&quot;TStrPool::Resize: %u, %u [Size larger than 4Gb, which is not supported by TStrPool]&quot;, newSize, MxBfL).CStr());
1381    }
1382    if (newSize &gt; MxBfL) {
1383      Bf = (char *) realloc(Bf, newSize);
1384      IAssertR(Bf, TStr::Fmt(&quot;old Bf size: %u, new size: %u&quot;, MxBfL, newSize).CStr());
1385      MxBfL = newSize;
1386    }
1387    IAssertR(MxBfL &gt;= _MxBfL, TStr::Fmt(&quot;new size: %u, requested size: %u&quot;, MxBfL, _MxBfL).CStr());
1388  }
1389  TStrPool::TStrPool(const uint&amp; MxBfLen, const uint&amp; _GrowBy) : MxBfL(MxBfLen), BfL(0), GrowBy(_GrowBy), Bf(0) {
1390    if (MxBfL &gt; 0) { Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt(&quot;Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]&quot;, MxBfL).CStr()); }
1391    AddStr(&quot;&quot;); 
1392  }
1393  TStrPool::TStrPool(TSIn&amp; SIn, bool LoadCompact) : MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1394    SIn.Load(MxBfL);  SIn.Load(BfL);  SIn.Load(GrowBy);
1395    if (LoadCompact) MxBfL = BfL;
1396    if (MxBfL &gt; 0) { Bf = (char *) malloc(MxBfL); IAssertR(Bf, TStr::Fmt(&quot;Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]&quot;, MxBfL).CStr()); }
1397    if (BfL &gt; 0) SIn.LoadBf(Bf, BfL);
1398    SIn.LoadCs();
1399  }
1400  void TStrPool::Save(TSOut&amp; SOut) const {
1401    SOut.Save(MxBfL);  SOut.Save(BfL);  SOut.Save(GrowBy);
1402    SOut.SaveBf(Bf, BfL);
1403    SOut.SaveCs();
1404  }
1405  TStrPool&amp; TStrPool::operator = (const TStrPool&amp; Pool) {
1406    if (this != &amp;Pool) {
1407      GrowBy = Pool.GrowBy;  MxBfL = Pool.MxBfL;  BfL = Pool.BfL;
1408      if (Bf) free(Bf); else IAssertR(MxBfL == 0, TStr::Fmt(&quot;size: %u, expected size: 0&quot;, MxBfL).CStr());
1409      Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt(&quot;Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]&quot;, MxBfL).CStr());  memcpy(Bf, Pool.Bf, BfL);
1410    }
1411    return *this;
1412  }
1413  uint TStrPool::AddStr(const char *Str, const uint&amp; Len) {
1414    IAssertR(Len &gt; 0, &quot;String too short (length includes the null character)&quot;);  
1415    if (Len == 1 &amp;&amp; BfL &gt; 0) { return 0; } 
1416    Assert(Str);  Assert(Len &gt; 0);
1417    if (BfL + Len &gt; MxBfL) Resize(BfL + Len);
1418    memcpy(Bf + BfL, Str, Len);
1419    uint Pos = BfL;  BfL += Len;  return Pos;
1420  }
1421  int TStrPool::GetPrimHashCd(const char *CStr) {
1422    return TStrHashF_DJB::GetPrimHashCd(CStr);
1423  }
1424  int TStrPool::GetSecHashCd(const char *CStr) {
1425    return TStrHashF_DJB::GetSecHashCd(CStr);
1426  }
1427  void TStrPool64::Resize(const ::TSize&amp; _MxBfL) {
1428    ::TSize newSize = MxBfL;
1429    while (newSize &lt; _MxBfL) {
1430      if (newSize &gt;= GrowBy &amp;&amp; GrowBy &gt; 0) newSize += GrowBy;
1431      else if (newSize &gt; 0) newSize *= 2;
1432      else newSize = (GrowBy &gt; ::TSize(1024)) ? ::TSize(1024) : GrowBy;
1433      IAssert(newSize &gt;= MxBfL); 
1434    }
1435    if (newSize &gt; MxBfL) {
<span onclick='openModal()' class='match'>1436      Bf = (char *) realloc(Bf, newSize);
1437      IAssertR(Bf, TStr::Fmt(&quot;old Bf size: %u, new size: %u&quot;, MxBfL, newSize).CStr());
1438      MxBfL = newSize;
1439    }
1440    IAssert(MxBfL &gt;= _MxBfL);
</span>1441  }
1442  TStrPool64::TStrPool64(::TSize _MxBfL, ::TSize _GrowBy):
1443      MxBfL(_MxBfL), BfL(0), GrowBy(_GrowBy), Bf(NULL) {
1444    if (MxBfL &gt; 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1445    AddStr(&quot;&quot;);
1446  }
1447  TStrPool64::TStrPool64(const TStrPool64&amp; StrPool): 
1448    MxBfL(StrPool.MxBfL), BfL(StrPool.BfL), GrowBy(StrPool.GrowBy) {
1449    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1450    Bf = (char*)malloc(StrPool.MxBfL); IAssert(Bf != NULL); 
1451    memcpy(Bf, StrPool.Bf, BfL);
1452  }
1453  TStrPool64::TStrPool64(TSIn&amp; SIn, bool LoadCompact): 
1454    MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1455    uint64 _GrowBy, _MxBfL, _BfL;
1456    SIn.Load(_GrowBy); SIn.Load(_MxBfL); SIn.Load(_BfL);
1457    GrowBy = (::TSize)_GrowBy; MxBfL = (::TSize)_MxBfL; BfL = (::TSize)_BfL;
1458    if (LoadCompact) { MxBfL = BfL; }
1459    if (MxBfL &gt; 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1460    for (::TSize BfN = 0; BfN &lt; _BfL; BfN++) { Bf[BfN] = SIn.GetCh(); }
1461    SIn.LoadCs();
1462  }
1463  void TStrPool64::Save(TSOut&amp; SOut) const {
1464    uint64 _GrowBy = GrowBy, _MxBfL = MxBfL, _BfL = BfL;
1465    SOut.Save(_GrowBy);  SOut.Save(_MxBfL);  SOut.Save(_BfL);
1466    for (::TSize BfN = 0; BfN &lt; _BfL; BfN++) { SOut.PutCh(Bf[BfN]); }
1467    SOut.SaveCs();
1468  }
1469  TStrPool64&amp; TStrPool64::operator=(const TStrPool64&amp; StrPool) {
1470    if (this != &amp;StrPool) {
1471    GrowBy = StrPool.GrowBy;  MxBfL = StrPool.MxBfL;  BfL = StrPool.BfL;
1472    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1473    Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); 
1474    memcpy(Bf, StrPool.Bf, BfL);
1475    }
1476    return *this;
1477  }
1478  void TStrPool64::Clr(bool DoDel) { 
1479    BfL = 0; 
1480    if (DoDel &amp;&amp; (Bf!=NULL)) { 
1481      free(Bf); 
1482      Bf = NULL; MxBfL = 0; 
1483    } 
1484  }
1485  uint64 TStrPool64::AddStr(const TStr&amp; Str) {
1486    const int Len = Str.Len() + 1;
1487    if (BfL + Len &gt; MxBfL) { Resize(BfL + Len); }
1488    memcpy(Bf + BfL, Str.CStr(), Len);
1489    ::TSize Offset = BfL;  BfL += Len;
1490    return uint64(Offset);
1491  }
1492  TStr TStrPool64::GetStr(const uint64&amp; StrId) const {
1493    ::TSize Offset = (::TSize)StrId;
1494    return TStr(Bf + Offset);
1495  }
1496  void TVoid::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1497    XLoadHd(Nm);
1498  }
1499  void TVoid::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1500    XSaveBETag(Nm);
1501  }
1502  const bool TBool::Mn=0;
1503  const bool TBool::Mx=1;
1504  const int TBool::Vals=TBool::Mx-TBool::Mn+1;
1505  TRnd TBool::Rnd;
1506  const TStr TBool::FalseStr=&quot;F&quot;;
1507  const TStr TBool::TrueStr=&quot;T&quot;;
1508  const TStr TBool::NStr=&quot;N&quot;;
1509  const TStr TBool::YStr=&quot;Y&quot;;
1510  const TStr TBool::NoStr=&quot;No&quot;;
1511  const TStr TBool::YesStr=&quot;Yes&quot;;
1512  void TBool::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1513    XLoadHd(Nm);
1514    Val=TXmlObjSer::GetBoolArg(XmlTok, &quot;Val&quot;);
1515  }
1516  void TBool::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1517    XSaveBETagArg(Nm, &quot;Val&quot;, TBool::GetStr(Val));
1518  }
1519  bool TBool::IsValStr(const TStr&amp; Str){
1520    TStr UcStr=Str.GetUc();
1521    return
1522     (UcStr==FalseStr)||(UcStr==TrueStr)||
1523     (UcStr==YStr)||(UcStr==NStr)||
1524     (UcStr==YesStr)||(UcStr==NoStr);
1525  }
1526  bool TBool::GetValFromStr(const TStr&amp; Str){
1527    return (Str==TrueStr)||(Str==YStr)||(Str==YesStr);
1528  }
1529  bool TBool::GetValFromStr(const TStr&amp; Str, const bool&amp; DfVal){
1530    TStr UcStr=Str.GetUc();
1531    if (IsValStr(UcStr)){
1532      return (UcStr==TrueStr)||(UcStr==YStr)||(UcStr==YesStr);
1533    } else {
1534      return DfVal;
1535    }
1536  }
1537  const char TCh::Mn=CHAR_MIN;
1538  const char TCh::Mx=CHAR_MAX;
1539  const int TCh::Vals=int(TCh::Mx)-int(TCh::Mn)+1;
1540  const char TCh::NullCh=char(0);
1541  const char TCh::TabCh=char(9);
1542  const char TCh::LfCh=char(10);
1543  const char TCh::CrCh=char(13);
1544  const char TCh::EofCh=char(26);
1545  const char TCh::HashCh=&#x27;#&#x27;;
1546  void TCh::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1547    XLoadHd(Nm);
1548    Val=char(TXmlObjSer::GetIntArg(XmlTok, &quot;Val&quot;));
1549  }
1550  void TCh::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1551    XSaveBETagArg(Nm, &quot;Val&quot;, TInt::GetStr(Val));
1552  }
1553  char TCh::GetUsFromYuAscii(const char&amp; Ch){
1554    switch (Ch){
1555      case &#x27;~&#x27;: return &#x27;c&#x27;;
1556      case &#x27;^&#x27;: return &#x27;C&#x27;;
1557      case &#x27;{&#x27;: return &#x27;s&#x27;;
1558      case &#x27;[&#x27;: return &#x27;S&#x27;;
1559      case &#x27;`&#x27;: return &#x27;z&#x27;;
1560      case &#x27;@&#x27;: return &#x27;Z&#x27;;
1561      case &#x27;|&#x27;: return &#x27;d&#x27;;
1562      case &#x27;\\&#x27;: return &#x27;D&#x27;;
1563      default: return Ch;
1564    }
1565  }
1566  const uchar TUCh::Mn=0;
1567  const uchar TUCh::Mx=UCHAR_MAX;
1568  const int TUCh::Vals=int(TUCh::Mx)-int(TUCh::Mn)+1;
1569  void TUCh::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1570    XLoadHd(Nm);
1571    Val=uchar(TXmlObjSer::GetIntArg(XmlTok, &quot;Val&quot;));
1572  }
1573  void TUCh::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1574    XSaveBETagArg(Nm, &quot;Val&quot;, TInt::GetStr(Val));
1575  }
1576  const int TInt::Mn=INT_MIN;
1577  const int TInt::Mx=INT_MAX;
1578  const int TInt::Kilo=1024;
1579  const int TInt::Mega=1024*1024;
1580  const int TInt::Giga=1024*1024*1024;
1581  TRnd TInt::Rnd;
1582  void TInt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1583    XLoadHd(Nm);
1584    Val=TXmlObjSer::GetIntArg(XmlTok, &quot;Val&quot;);
1585  }
1586  void TInt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1587    XSaveBETagArg(Nm, &quot;Val&quot;, TInt::GetStr(Val));
1588  }
1589  TStr TInt::GetStr(const int&amp; Val, const char* FmtStr){
1590    if (FmtStr==NULL){
1591      return GetStr(Val);
1592    } else {
1593      char Bf[255];
1594      sprintf(Bf, FmtStr, Val);
1595      return TStr(Bf);
1596    }
1597  }
1598  char* TInt::SaveFrugalInt(char *pDest, int i){
1599    i++;
1600    if (i &gt;= 0 &amp;&amp; i &lt;= 127) { *pDest++ = char(i); return pDest; }
1601    if (i &gt;= 128 &amp;&amp; i &lt; 128 + 8192) { i -= 128; *pDest++ = char(0x80 | (i &amp; 0x7f));
1602      *pDest++ = char((i &gt;&gt; 7) &amp; 0x3f); return pDest; }
1603    if (i &lt;= -1 &amp;&amp; i &gt; -1 - 8192) { i = -1 - i;  *pDest++ = char(0x80 | (i &amp; 0x7f));
1604      *pDest++ = char(0x40 | ((i &gt;&gt; 7) &amp; 0x3f)); return pDest; }
1605    if (i &gt;= 128 + 8192 &amp;&amp; i &lt; 128 + 8192 + 536870912) { i -= 128 + 8192;
1606      *pDest++ = char(0x80 | (i &amp; 0x7f)); *pDest++ = char(0x80 | ((i &gt;&gt; 7) &amp; 0x7f));
1607      *pDest++ = char((i &gt;&gt; 14) &amp; 0xff); *pDest++ = char((i &gt;&gt; 22) &amp; 0x7f); return pDest; }
1608    if (i &lt;= -1 - 8192 &amp;&amp; i &gt; -1 - 8192 - 536870912) { i = (-1 - 8192) - i;
1609      *pDest++ = char(0x80 | (i &amp; 0x7f)); *pDest++ = char(0x80 | ((i &gt;&gt; 7) &amp; 0x7f));
1610      *pDest++ = char((i &gt;&gt; 14) &amp; 0xff); *pDest++ = char(0x80 | ((i &gt;&gt; 22) &amp; 0x7f)); return pDest; }
1611    IAssertR(false, TInt::GetStr(i)); return 0;
1612  }
1613  char* TInt::LoadFrugalInt(char *pSrc, int&amp; i){
1614    i = 0;
1615    int ch = (int) ((unsigned char) (*pSrc++));
1616    if ((ch &amp; 0x80) == 0) { i = ch; i--; return pSrc; }
1617    i = (ch &amp; 0x7f);
1618    ch = (int) ((unsigned char) (*pSrc++));
1619    if ((ch &amp; 0x80) == 0)
1620    {
1621      i |= (ch &amp; 0x3f) &lt;&lt; 7;
1622      if ((ch &amp; 0x40) == 0) i += 128; else i = -1 - i;
1623      i--; return pSrc;
1624    }
1625    i |= (ch &amp; 0x7f) &lt;&lt; 7;
1626    ch = (int) ((unsigned char) (*pSrc++));
1627    i |= ch &lt;&lt; 14;
1628    ch = (int) ((unsigned char) (*pSrc++));
1629    i |= (ch &amp; 0x7f) &lt;&lt; 22;
1630    if ((ch &amp; 0x80) == 0) i += 128 + 8192; else i = (-1 - 8192) - i;
1631    i--; return pSrc;
1632  }
1633  void TInt::TestFrugalInt(){
1634    char buf[10], *p = &amp;buf[0], *r, *s;
1635    int i, j;
1636  #define __TEST(from, to, len) \
1637    for (i = (from); i &lt;= (to); i++) \
1638      { if ((i &amp; 0xffff) == 0) printf(&quot;%d\r&quot;, i); \
1639        r = SaveFrugalInt(p, i); s = LoadFrugalInt(p, j); \
1640        IAssert(r == s); IAssert(i == j); IAssert(r - p == len); }
1641    __TEST(-1, 126, 1);
1642    __TEST(127, 127 + 8191, 2);
1643    __TEST(-2 - 8191, -2, 2);
1644    __TEST(127 + 8192, 127 + 8191 + (1 &lt;&lt; 29), 4);
1645    __TEST(-2 - 8191 - (1 &lt;&lt; 29), -2 - 8192, 4);
1646  #undef __TEST
1647  }
1648  void TInt::SaveFrugalIntV(TSOut&amp; SOut, const TIntV&amp; v){
1649    int count = v.Len();
1650    char *buf = new char[4 * (count + 1)], *pStart, *pEnd;
1651    pStart = buf + 4; pEnd = pStart;
1652    for (int i = 0; i &lt; count; i++)
1653      pEnd = SaveFrugalInt(pEnd, v[i].Val);
1654    int size = int(pEnd - pStart);
1655    char *pSizeStart = buf;
1656    char *pSizeEnd = SaveFrugalInt(pSizeStart, size);
1657    while (pSizeEnd &gt; pSizeStart) *(--pStart) = *(--pSizeEnd);
1658    SOut.PutBf(pStart, TSize(pEnd - pStart));
1659    delete[] buf;
1660  }
1661  void TInt::LoadFrugalIntV(TSIn&amp; SIn, TIntV&amp; v, bool clearVec){
1662    if (clearVec) v.Clr();
1663    char sizeBuf[4], *p, *pEnd;
1664    sizeBuf[0] = SIn.GetCh(); int count = 1;
1665    if (sizeBuf[0] &amp; 0x80)
1666    {
1667      sizeBuf[1] = SIn.GetCh(); count++;
1668      if (sizeBuf[1] &amp; 0x80) { sizeBuf[2] = SIn.GetCh();
1669        sizeBuf[3] = SIn.GetCh(); count += 2;}
1670    }
1671    int size;
1672    pEnd = LoadFrugalInt(&amp;sizeBuf[0], size);
1673    IAssert(pEnd - &amp;sizeBuf[0] == count);
1674    if (size &lt;= 0) return;
1675    char *buf = new char[size];
1676    SIn.GetBf(buf, size);
1677    p = buf; pEnd = buf + size;
1678    while (p &lt; pEnd)
1679      { int i; p = LoadFrugalInt(p, i); v.Add(i); }
1680    IAssert(p == pEnd);
1681    delete[] buf;
1682  }
1683  const uint TUInt::Mn=0;
1684  const uint TUInt::Mx=UINT_MAX;
1685  TRnd TUInt::Rnd;
1686  void TUInt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1687    XLoadHd(Nm);
1688    Val=TXmlObjSer::GetIntArg(XmlTok, &quot;Val&quot;);
1689  }
1690  void TUInt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1691    XSaveBETagArg(Nm, &quot;Val&quot;, TInt::GetStr(Val));
1692  }
1693  TStr TUInt::GetStr(const uint&amp; Val, const char* FmtStr){
1694    if (FmtStr==NULL){
1695      return GetStr(Val);
1696    } else {
1697      char Bf[255];
1698      sprintf(Bf, FmtStr, Val);
1699      return TStr(Bf);
1700    }
1701  }
1702  bool TUInt::IsIpStr(const TStr&amp; IpStr, uint&amp; Ip, const char&amp; SplitCh) {
1703  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1704      Ip = 0; int Byte = 0;
1705  	if (IpStrV.Len() != 4) { return false; }
1706  	if (!IpStrV[0].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (uint)Byte;
1707  	if (!IpStrV[1].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1708  	if (!IpStrV[2].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1709  	if (!IpStrV[3].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1710  	return true;
1711  }
1712  uint TUInt::GetUIntFromIpStr(const TStr&amp; IpStr, const char&amp; SplitCh) {
1713  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1714      uint Ip = 0; int Byte = 0;
1715  	EAssertR(IpStrV[0].IsInt(true, 0, 255, Byte), TStr::Fmt(&quot;Bad IP: &#x27;%s;&quot;, IpStr.CStr())); Ip = (uint)Byte;
1716  	EAssertR(IpStrV[1].IsInt(true, 0, 255, Byte), TStr::Fmt(&quot;Bad IP: &#x27;%s;&quot;, IpStr.CStr())); Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1717  	EAssertR(IpStrV[2].IsInt(true, 0, 255, Byte), TStr::Fmt(&quot;Bad IP: &#x27;%s;&quot;, IpStr.CStr())); Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1718  	EAssertR(IpStrV[3].IsInt(true, 0, 255, Byte), TStr::Fmt(&quot;Bad IP: &#x27;%s;&quot;, IpStr.CStr())); Ip = (Ip &lt;&lt; 8) | (uint)Byte;
1719  	return Ip;
1720  }
1721  TStr TUInt::GetStrFromIpUInt(const uint&amp; Ip) {
1722    return TStr::Fmt(&quot;%d.%d.%d.%d&quot;, ((Ip&gt;&gt;24) &amp; 0xFF),
1723     ((Ip&gt;&gt;16) &amp; 0xFF), ((Ip&gt;&gt;8) &amp; 0xFF), (Ip &amp; 0xFF));
1724  }
1725  bool TUInt::IsIpv6Str(const TStr&amp; IpStr, const char&amp; SplitCh) {
1726  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV, false);
1727  	if (IpStrV.Len() &gt; 8) { return false; }
1728  	int Group = 0;
1729  	for (int IpStrN = 0; IpStrN &lt; IpStrV.Len(); IpStrN++) {
1730  		if (IpStrV[IpStrN].Empty()) { continue; }
1731  		if (IpStrV[IpStrN].IsHexInt(true, 0x0000, 0xFFFF, Group)) { continue; }
1732  		return false; 
1733  	}
1734  	return true;
1735  }
1736  #if defined (GLib_WIN32)
1737  const TUInt64 TUInt64::Mn(uint64(0x0000000000000000i64));
1738  const TUInt64 TUInt64::Mx(uint64(0xFFFFFFFFFFFFFFFFi64));
1739  #elif defined (GLib_BCB)
1740  const TUInt64 TUInt64::Mn(0x0000000000000000i64);
1741  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFi64);
1742  #else
1743  const TUInt64 TUInt64::Mn((uint64)0x0000000000000000LL);
1744  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFLL);
1745  #endif
1746  void TUInt64::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1747    XLoadHd(Nm);
1748    Val=TXmlObjSer::GetInt64Arg(XmlTok, &quot;Val&quot;);
1749  }
1750  void TUInt64::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1751    XSaveBETagArg(Nm, &quot;Val&quot;, TUInt64::GetStr(Val));
1752  }
1753  const double TFlt::Mn=-DBL_MAX;
1754  const double TFlt::Mx=+DBL_MAX;
1755  const double TFlt::NInf=-DBL_MAX;
1756  const double TFlt::PInf=+DBL_MAX;
1757  const double TFlt::Eps=1e-16;
1758  const double TFlt::EpsHalf  =1e-7;
1759  TRnd TFlt::Rnd;
1760  void TFlt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1761    XLoadHd(Nm);
1762    Val=TXmlObjSer::GetFltArg(XmlTok, &quot;Val&quot;);
1763  }
1764  void TFlt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1765    XSaveBETagArg(Nm, &quot;Val&quot;, TFlt::GetStr(Val));
1766  }
1767  TStr TFlt::GetStr(const double&amp; Val, const int&amp; Width, const int&amp; Prec){
1768    char Bf[255];
1769    if ((Width==-1)&amp;&amp;(Prec==-1)){sprintf(Bf, &quot;%g&quot;, Val);}
1770    else {sprintf(Bf, &quot;%*.*f&quot;, Width, Prec, Val);}
1771    return TStr(Bf);
1772  }
1773  TStr TFlt::GetStr(const double&amp; Val, const char* FmtStr){
1774    if (FmtStr==NULL){
1775      return GetStr(Val);
1776    } else {
1777      char Bf[255];
1778      sprintf(Bf, FmtStr, Val);
1779      return TStr(Bf);
1780    }
1781  }
1782  const sdouble TSFlt::Mn=-FLT_MIN;
1783  const sdouble TSFlt::Mx=+FLT_MAX;
1784  void TSFlt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1785    XLoadHd(Nm);
1786    Val=sdouble(TXmlObjSer::GetFltArg(XmlTok, &quot;Val&quot;));
1787  }
1788  void TSFlt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1789    XSaveBETagArg(Nm, &quot;Val&quot;, TFlt::GetStr(Val));
1790  }
1791  const ldouble TLFlt::Mn=-LDBL_MAX;
1792  const ldouble TLFlt::Mx=+LDBL_MAX;
1793  void TLFlt::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1794    XLoadHd(Nm);
1795    Val=TXmlObjSer::GetFltArg(XmlTok, &quot;Val&quot;);
1796  }
1797  void TLFlt::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1798    XSaveBETagArg(Nm, &quot;Val&quot;, TFlt::GetStr(double(Val)));
1799  }
1800  TStr TLFlt::GetStr(const ldouble&amp; Val, const int&amp; Width, const int&amp; Prec){
1801    char Bf[255];
1802    if ((Width==-1)&amp;&amp;(Prec==-1)){sprintf(Bf, &quot;%Lg&quot;, Val);}
1803    else {sprintf(Bf, &quot;%*.*Lf&quot;, Width, Prec, Val);}
1804    return TStr(Bf);
1805  }
1806  TStr TLFlt::GetStr(const ldouble&amp; Val, const char* FmtStr){
1807    if (FmtStr==NULL){
1808      return GetStr(Val);
1809    } else {
1810      char Bf[255];
1811      sprintf(Bf, FmtStr, Val);
1812      return TStr(Bf);
1813    }
1814  }
1815  void TFltRect::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
1816    XLoadHd(Nm);
1817    MnX=TXmlObjSer::GetFltArg(XmlTok, &quot;MnX&quot;);
1818    MnY=TXmlObjSer::GetFltArg(XmlTok, &quot;MnY&quot;);
1819    MxX=TXmlObjSer::GetFltArg(XmlTok, &quot;MxX&quot;);
1820    MxY=TXmlObjSer::GetFltArg(XmlTok, &quot;MxY&quot;);
1821  }
1822  void TFltRect::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
1823    XSaveBETagArg4(Nm,
1824     &quot;MnX&quot;, TFlt::GetStr(double(MnX)), &quot;MnY&quot;, TFlt::GetStr(double(MnY)),
1825     &quot;MxX&quot;, TFlt::GetStr(double(MxX)), &quot;MxY&quot;, TFlt::GetStr(double(MxY)));
1826  }
1827  bool TFltRect::Intersection(const TFltRect&amp; Rect1, const TFltRect&amp; Rect2){
1828    const double MnXX = TFlt::GetMx(Rect1.GetMnX(), Rect2.GetMnX());
1829    const double MnYY = TFlt::GetMx(Rect1.GetMnY(), Rect2.GetMnY());
1830    const double MxXX = TFlt::GetMn(Rect1.GetMxX(), Rect2.GetMxX());
1831    const double MxYY = TFlt::GetMn(Rect1.GetMxY(), Rect2.GetMxY());
1832    return (MnXX &lt; MxXX) &amp;&amp; (MnYY &lt; MxYY);
1833  }
1834  TStr TFltRect::GetStr() const {
1835    TChA ChA;
1836    ChA+=&#x27;(&#x27;;
1837    ChA+=TFlt::GetStr(MnX, &quot;%0.2f&quot;); ChA+=&#x27;,&#x27;;
1838    ChA+=TFlt::GetStr(MnY, &quot;%0.2f&quot;); ChA+=&#x27;,&#x27;;
1839    ChA+=TFlt::GetStr(MxX, &quot;%0.2f&quot;); ChA+=&#x27;,&#x27;;
1840    ChA+=TFlt::GetStr(MxY, &quot;%0.2f&quot;); ChA+=&#x27;)&#x27;;
1841    return ChA;
1842  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1383      Bf = (char *) realloc(Bf, newSize);
1384      IAssertR(Bf, TStr::Fmt(&quot;old Bf size: %u, new size: %u&quot;, MxBfL, newSize).CStr());
1385      MxBfL = newSize;
1386    }
1387    IAssertR(MxBfL &gt;= _MxBfL, TStr::Fmt(&quot;new size: %u, requested size: %u&quot;, MxBfL, _MxBfL).CStr());
</pre></code></div>
                <div class="column column_space"><pre><code>1436      Bf = (char *) realloc(Bf, newSize);
1437      IAssertR(Bf, TStr::Fmt(&quot;old Bf size: %u, new size: %u&quot;, MxBfL, newSize).CStr());
1438      MxBfL = newSize;
1439    }
1440    IAssert(MxBfL &gt;= _MxBfL);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    