
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.090909090909092%, Tokens: 16</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tesseractclass.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCMAIN_TESSERACTCLASS_H_
2  #define TESSERACT_CCMAIN_TESSERACTCLASS_H_
3  #ifdef HAVE_CONFIG_H
4  #  include "config_auto.h" 
5  #endif
6  #include "control.h"               
7  #include "debugpixa.h"             
8  #include "devanagari_processing.h" 
9  #ifndef DISABLED_LEGACY_ENGINE
10  #  include "docqual.h" 
11  #endif
12  #include "genericvector.h"   
13  #include "pageres.h"         
14  #include "params.h"          
15  #include "points.h"          
16  #include "ratngs.h"          
17  #include "tessdatamanager.h" 
18  #include "textord.h"         
19  #include "wordrec.h"         
20  #include <tesseract/publictypes.h> 
21  #include <tesseract/unichar.h>     
22  #include <allheaders.h> 
23  #include <cstdint> 
24  #include <cstdio>  
25  namespace tesseract {
26  class BLOCK_LIST;
27  class ETEXT_DESC;
28  struct OSResults;
29  class PAGE_RES;
30  class PAGE_RES_IT;
31  class ROW;
32  class SVMenuNode;
33  class TBOX;
34  class TO_BLOCK_LIST;
35  class WERD;
36  class WERD_CHOICE;
37  class WERD_RES;
38  class ColumnFinder;
39  class DocumentData;
40  #ifndef DISABLED_LEGACY_ENGINE
41  class EquationDetect;
42  #endif 
43  class ImageData;
44  class LSTMRecognizer;
45  class Tesseract;
46  struct TesseractStats {
47    TesseractStats()
48        : adaption_word_number(0)
49        , doc_blob_quality(0)
50        , doc_outline_errs(0)
51        , doc_char_quality(0)
52        , good_char_count(0)
53        , doc_good_char_quality(0)
54        , word_count(0)
55        , dict_words(0)
56        , tilde_crunch_written(false)
57        , last_char_was_newline(true)
58        , last_char_was_tilde(false)
59        , write_results_empty_block(true) {}
60    int32_t adaption_word_number;
61    int16_t doc_blob_quality;
62    int16_t doc_outline_errs;
63    int16_t doc_char_quality;
64    int16_t good_char_count;
65    int16_t doc_good_char_quality;
66    int32_t word_count;    
67    int32_t dict_words;    
68    std::string dump_words_str; 
69    bool tilde_crunch_written;
70    bool last_char_was_newline;
71    bool last_char_was_tilde;
72    bool write_results_empty_block;
73  };
74  struct WordData {
75    WordData() : word(nullptr), row(nullptr), block(nullptr), prev_word(nullptr) {}
76    explicit WordData(const PAGE_RES_IT &page_res_it)
77        : word(page_res_it.word())
78        , row(page_res_it.row()->row)
79        , block(page_res_it.block()->block)
80        , prev_word(nullptr) {}
81    WordData(BLOCK *block_in, ROW *row_in, WERD_RES *word_res)
82        : word(word_res), row(row_in), block(block_in), prev_word(nullptr) {}
83    WERD_RES *word;
84    ROW *row;
85    BLOCK *block;
86    WordData *prev_word;
87    PointerVector<WERD_RES> lang_words;
88  };
89  using WordRecognizer = void (Tesseract::*)(const WordData &, WERD_RES **,
90                                             PointerVector<WERD_RES> *);
91  class TESS_API Tesseract : public Wordrec {
92  public:
93    Tesseract();
94    ~Tesseract() override;
95    Dict &getDict() override;
96    void Clear();
97    void ResetAdaptiveClassifier();
98    void ResetDocumentDictionary();
99  #ifndef DISABLED_LEGACY_ENGINE
100    void SetEquationDetect(EquationDetect *detector);
101  #endif 
102    const FCOORD &reskew() const {
103      return reskew_;
104    }
105    Image *mutable_pix_binary() {
106      pix_binary_.destroy();
107      return &pix_binary_;
108    }
109    Image pix_binary() const {
110      return pix_binary_;
111    }
112    Image pix_grey() const {
113      return pix_grey_;
114    }
115    void set_pix_grey(Image grey_pix) {
116      pix_grey_.destroy();
117      pix_grey_ = grey_pix;
118    }
119    Image pix_original() const {
120      return pix_original_;
121    }
122    void set_pix_original(Image original_pix) {
123      pix_original_.destroy();
124      pix_original_ = original_pix;
125      for (auto &lang : sub_langs_) {
126        lang->set_pix_original(original_pix ? original_pix.clone() : nullptr);
127      }
128    }
<span onclick='openModal()' class='match'>129    Image BestPix() const {
130      if (pixGetWidth(pix_original_) == ImageWidth()) {
131        return pix_original_;
132      } else if (pix_grey_ != nullptr) {
133        return pix_grey_;
134      } else {
135        return pix_binary_;
136      }
137    }
</span>138    void set_pix_thresholds(Image thresholds) {
139      pix_thresholds_.destroy();
140      pix_thresholds_ = thresholds;
141    }
142    int source_resolution() const {
143      return source_resolution_;
144    }
145    void set_source_resolution(int ppi) {
146      source_resolution_ = ppi;
147    }
148    int ImageWidth() const {
149      return pixGetWidth(pix_binary_);
150    }
151    int ImageHeight() const {
152      return pixGetHeight(pix_binary_);
153    }
154    Image scaled_color() const {
155      return scaled_color_;
156    }
157    int scaled_factor() const {
158      return scaled_factor_;
159    }
160    void SetScaledColor(int factor, Image color) {
161      scaled_factor_ = factor;
162      scaled_color_ = color;
163    }
164    const Textord &textord() const {
165      return textord_;
166    }
167    Textord *mutable_textord() {
168      return &textord_;
169    }
170    bool right_to_left() const {
171      return right_to_left_;
172    }
173    int num_sub_langs() const {
174      return sub_langs_.size();
175    }
176    Tesseract *get_sub_lang(int index) const {
177      return sub_langs_[index];
178    }
179    bool AnyTessLang() const {
180      if (tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
181        return true;
182      }
183      for (auto &lang : sub_langs_) {
184        if (lang->tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
185          return true;
186        }
187      }
188      return false;
189    }
190    bool AnyLSTMLang() const {
191      if (tessedit_ocr_engine_mode != OEM_TESSERACT_ONLY) {
192        return true;
193      }
194      for (auto &lang : sub_langs_) {
195        if (lang->tessedit_ocr_engine_mode != OEM_TESSERACT_ONLY) {
196          return true;
197        }
198      }
199      return false;
200    }
201    void SetBlackAndWhitelist();
202    void PrepareForPageseg();
203    void PrepareForTessOCR(BLOCK_LIST *block_list, Tesseract *osd_tess, OSResults *osr);
204    int SegmentPage(const char *input_file, BLOCK_LIST *blocks, Tesseract *osd_tess, OSResults *osr);
205    void SetupWordScripts(BLOCK_LIST *blocks);
206    int AutoPageSeg(PageSegMode pageseg_mode, BLOCK_LIST *blocks, TO_BLOCK_LIST *to_blocks,
207                    BLOBNBOX_LIST *diacritic_blobs, Tesseract *osd_tess, OSResults *osr);
208    ColumnFinder *SetupPageSegAndDetectOrientation(PageSegMode pageseg_mode, BLOCK_LIST *blocks,
209                                                   Tesseract *osd_tess, OSResults *osr,
210                                                   TO_BLOCK_LIST *to_blocks, Image *photo_mask_pix,
211                                                   Image *music_mask_pix);
212    void PrerecAllWordsPar(const std::vector<WordData> &words);
213    bool TrainLineRecognizer(const char *input_imagename, const std::string &output_basename,
214                             BLOCK_LIST *block_list);
215    void TrainFromBoxes(const std::vector<TBOX> &boxes, const std::vector<std::string> &texts,
216                        BLOCK_LIST *block_list, DocumentData *training_data);
217    ImageData *GetLineData(const TBOX &line_box, const std::vector<TBOX> &boxes,
218                           const std::vector<std::string> &texts, int start_box, int end_box,
219                           const BLOCK &block);
220    ImageData *GetRectImage(const TBOX &box, const BLOCK &block, int padding,
221                            TBOX *revised_box) const;
222    void LSTMRecognizeWord(const BLOCK &block, ROW *row, WERD_RES *word,
223                           PointerVector<WERD_RES> *words);
224    void SearchWords(PointerVector<WERD_RES> *words);
225    bool ProcessTargetWord(const TBOX &word_box, const TBOX &target_word_box, const char *word_config,
226                           int pass);
227    void SetupAllWordsPassN(int pass_n, const TBOX *target_word_box, const char *word_config,
228                            PAGE_RES *page_res, std::vector<WordData> *words);
229    void SetupWordPassN(int pass_n, WordData *word);
230    bool RecogAllWordsPassN(int pass_n, ETEXT_DESC *monitor, PAGE_RES_IT *pr_it,
231                            std::vector<WordData> *words);
232    bool recog_all_words(PAGE_RES *page_res, ETEXT_DESC *monitor, const TBOX *target_word_box,
233                         const char *word_config, int dopasses);
234    void rejection_passes(PAGE_RES *page_res, ETEXT_DESC *monitor, const TBOX *target_word_box,
235                          const char *word_config);
236    void bigram_correction_pass(PAGE_RES *page_res);
237    void blamer_pass(PAGE_RES *page_res);
238    void script_pos_pass(PAGE_RES *page_res);
239    int RetryWithLanguage(const WordData &word_data, WordRecognizer recognizer, bool debug,
240                          WERD_RES **in_word, PointerVector<WERD_RES> *best_words);
241    bool ReassignDiacritics(int pass, PAGE_RES_IT *pr_it, bool *make_next_word_fuzzy);
242    void AssignDiacriticsToOverlappingBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
243                                            WERD *real_word, PAGE_RES_IT *pr_it,
244                                            std::vector<bool> *word_wanted,
245                                            std::vector<bool> *overlapped_any_blob,
246                                            std::vector<C_BLOB *> *target_blobs);
247    void AssignDiacriticsToNewBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
248                                    WERD *real_word, PAGE_RES_IT *pr_it,
249                                    std::vector<bool> *word_wanted,
250                                    std::vector<C_BLOB *> *target_blobs);
251    bool SelectGoodDiacriticOutlines(int pass, float certainty_threshold, PAGE_RES_IT *pr_it,
252                                     C_BLOB *blob, const std::vector<C_OUTLINE *> &outlines,
253                                     int num_outlines, std::vector<bool> *ok_outlines);
254    float ClassifyBlobPlusOutlines(const std::vector<bool> &ok_outlines,
255                                   const std::vector<C_OUTLINE *> &outlines, int pass_n,
256                                   PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str);
257    float ClassifyBlobAsWord(int pass_n, PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str,
258                             float *c2);
259    void classify_word_and_language(int pass_n, PAGE_RES_IT *pr_it, WordData *word_data);
260    void classify_word_pass1(const WordData &word_data, WERD_RES **in_word,
261                             PointerVector<WERD_RES> *out_words);
262    void recog_pseudo_word(PAGE_RES *page_res, 
263                           TBOX &selection_box);
264    void fix_rep_char(PAGE_RES_IT *page_res_it);
265    ACCEPTABLE_WERD_TYPE acceptable_word_string(const UNICHARSET &char_set, const char *s,
266                                                const char *lengths);
267    void match_word_pass_n(int pass_n, WERD_RES *word, ROW *row, BLOCK *block);
268    void classify_word_pass2(const WordData &word_data, WERD_RES **in_word,
269                             PointerVector<WERD_RES> *out_words);
270    void ReportXhtFixResult(bool accept_new_word, float new_x_ht, WERD_RES *word, WERD_RES *new_word);
271    bool RunOldFixXht(WERD_RES *word, BLOCK *block, ROW *row);
272    bool TrainedXheightFix(WERD_RES *word, BLOCK *block, ROW *row);
273    bool TestNewNormalization(int original_misfits, float baseline_shift, float new_x_ht,
274                              WERD_RES *word, BLOCK *block, ROW *row);
275    bool recog_interactive(PAGE_RES_IT *pr_it);
276    void set_word_fonts(WERD_RES *word);
277    void font_recognition_pass(PAGE_RES *page_res);
278    void dictionary_correction_pass(PAGE_RES *page_res);
279    bool check_debug_pt(WERD_RES *word, int location);
280    bool SubAndSuperscriptFix(WERD_RES *word_res);
281    void GetSubAndSuperscriptCandidates(const WERD_RES *word, int *num_rebuilt_leading,
282                                        ScriptPos *leading_pos, float *leading_certainty,
283                                        int *num_rebuilt_trailing, ScriptPos *trailing_pos,
284                                        float *trailing_certainty, float *avg_certainty,
285                                        float *unlikely_threshold);
286    WERD_RES *TrySuperscriptSplits(int num_chopped_leading, float leading_certainty,
287                                   ScriptPos leading_pos, int num_chopped_trailing,
288                                   float trailing_certainty, ScriptPos trailing_pos, WERD_RES *word,
289                                   bool *is_good, int *retry_leading, int *retry_trailing);
290    bool BelievableSuperscript(bool debug, const WERD_RES &word, float certainty_threshold,
291                               int *left_ok, int *right_ok) const;
292    void output_pass(PAGE_RES_IT &page_res_it, const TBOX *target_word_box);
293    void write_results(PAGE_RES_IT &page_res_it, 
294                       char newline_type,        
295                       bool force_eol            
296    );
297    void set_unlv_suspects(WERD_RES *word);
298    UNICHAR_ID get_rep_char(WERD_RES *word); 
299    bool acceptable_number_string(const char *s, const char *lengths);
300    int16_t count_alphanums(const WERD_CHOICE &word);
301    int16_t count_alphas(const WERD_CHOICE &word);
302    void read_config_file(const char *filename, SetParamConstraint constraint);
303    int init_tesseract(const std::string &arg0, const std::string &textbase,
304                       const std::string &language, OcrEngineMode oem, char **configs,
305                       int configs_size, const std::vector<std::string> *vars_vec,
306                       const std::vector<std::string> *vars_values, bool set_only_non_debug_params,
307                       TessdataManager *mgr);
308    int init_tesseract(const std::string &datapath, const std::string &language, OcrEngineMode oem) {
309      TessdataManager mgr;
310      return init_tesseract(datapath, {}, language, oem, nullptr, 0, nullptr, nullptr, false, &mgr);
311    }
312    int init_tesseract_internal(const std::string &arg0, const std::string &textbase,
313                                const std::string &language, OcrEngineMode oem, char **configs,
314                                int configs_size, const std::vector<std::string> *vars_vec,
315                                const std::vector<std::string> *vars_values,
316                                bool set_only_non_debug_params, TessdataManager *mgr);
317    void SetupUniversalFontIds();
318    void recognize_page(std::string &image_name);
319    void end_tesseract();
320    bool init_tesseract_lang_data(const std::string &arg0,
321                                  const std::string &language, OcrEngineMode oem, char **configs,
322                                  int configs_size, const std::vector<std::string> *vars_vec,
323                                  const std::vector<std::string> *vars_values,
324                                  bool set_only_non_debug_params, TessdataManager *mgr);
325    void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
326                             std::vector<std::string> *not_to_load);
327    SVMenuNode *build_menu_new();
328  #ifndef GRAPHICS_DISABLED
329    void pgeditor_main(int width, int height, PAGE_RES *page_res);
330    void process_image_event( 
331        const SVEvent &event);
332    bool process_cmd_win_event( 
333        int32_t cmd_event,      
334        char *new_value         
335    );
336  #endif 
337    void debug_word(PAGE_RES *page_res, const TBOX &selection_box);
338    void do_re_display(bool (tesseract::Tesseract::*word_painter)(PAGE_RES_IT *pr_it));
339    bool word_display(PAGE_RES_IT *pr_it);
340    bool word_bln_display(PAGE_RES_IT *pr_it);
341    bool word_blank_and_set_display(PAGE_RES_IT *pr_its);
342    bool word_set_display(PAGE_RES_IT *pr_it);
343    bool word_dumper(PAGE_RES_IT *pr_it);
344    void blob_feature_display(PAGE_RES *page_res, const TBOX &selection_box);
345    void make_reject_map(WERD_RES *word, ROW *row, int16_t pass);
346    bool one_ell_conflict(WERD_RES *word_res, bool update_map);
347    int16_t first_alphanum_index(const char *word, const char *word_lengths);
348    int16_t first_alphanum_offset(const char *word, const char *word_lengths);
349    int16_t alpha_count(const char *word, const char *word_lengths);
350    bool word_contains_non_1_digit(const char *word, const char *word_lengths);
351    void dont_allow_1Il(WERD_RES *word);
352    int16_t count_alphanums( 
353        WERD_RES *word);
354    void flip_0O(WERD_RES *word);
355    bool non_0_digit(const UNICHARSET &ch_set, UNICHAR_ID unichar_id);
356    bool non_O_upper(const UNICHARSET &ch_set, UNICHAR_ID unichar_id);
357    bool repeated_nonalphanum_wd(WERD_RES *word, ROW *row);
358    void nn_match_word( 
359        WERD_RES *word, ROW *row);
360    void nn_recover_rejects(WERD_RES *word, ROW *row);
361    void set_done( 
362        WERD_RES *word, int16_t pass);
363    int16_t safe_dict_word(const WERD_RES *werd_res); 
364    void flip_hyphens(WERD_RES *word);
365    void reject_I_1_L(WERD_RES *word);
366    void reject_edge_blobs(WERD_RES *word);
367    void reject_mostly_rejects(WERD_RES *word);
368    bool word_adaptable( 
369        WERD_RES *word, uint16_t mode);
370    void recog_word_recursive(WERD_RES *word);
371    void recog_word(WERD_RES *word);
372    void split_and_recog_word(WERD_RES *word);
373    void split_word(WERD_RES *word, unsigned split_pt, WERD_RES **right_piece,
374                    BlamerBundle **orig_blamer_bundle) const;
375    void join_words(WERD_RES *word, WERD_RES *word2, BlamerBundle *orig_bb) const;
376    bool digit_or_numeric_punct(WERD_RES *word, int char_position);
377    int16_t eval_word_spacing(WERD_RES_LIST &word_res_list);
378    void match_current_words(WERD_RES_LIST &words, ROW *row, BLOCK *block);
379    int16_t fp_eval_word_spacing(WERD_RES_LIST &word_res_list);
380    void fix_noisy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block);
381    void fix_fuzzy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block);
382    void fix_sp_fp_word(WERD_RES_IT &word_res_it, ROW *row, BLOCK *block);
383    void fix_fuzzy_spaces(   
384        ETEXT_DESC *monitor, 
385        int32_t word_count,  
386        PAGE_RES *page_res);
387    void dump_words(WERD_RES_LIST &perm, int16_t score, int16_t mode, bool improved);
388    bool fixspace_thinks_word_done(WERD_RES *word);
389    int16_t worst_noise_blob(WERD_RES *word_res, float *worst_noise_score);
390    float blob_noise_score(TBLOB *blob);
391    void break_noisiest_blob_word(WERD_RES_LIST &words);
392  #ifndef DISABLED_LEGACY_ENGINE
393    GARBAGE_LEVEL garbage_word(WERD_RES *word, bool ok_dict_word);
394    bool potential_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level, bool ok_dict_word);
395  #endif
396    void tilde_crunch(PAGE_RES_IT &page_res_it);
397    void unrej_good_quality_words( 
398        PAGE_RES_IT &page_res_it);
399    void doc_and_block_rejection( 
400        PAGE_RES_IT &page_res_it, bool good_quality_doc);
401    void quality_based_rejection(PAGE_RES_IT &page_res_it, bool good_quality_doc);
402    void convert_bad_unlv_chs(WERD_RES *word_res);
403    void tilde_delete(PAGE_RES_IT &page_res_it);
404    int16_t word_blob_quality(WERD_RES *word);
405    void word_char_quality(WERD_RES *word, int16_t *match_count, int16_t *accepted_match_count);
406    void unrej_good_chs(WERD_RES *word);
407    int16_t count_outline_errs(char c, int16_t outline_count);
408    int16_t word_outline_errs(WERD_RES *word);
409  #ifndef DISABLED_LEGACY_ENGINE
410    bool terrible_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level);
411  #endif
412    CRUNCH_MODE word_deletable(WERD_RES *word, int16_t &delete_mode);
413    int16_t failure_count(WERD_RES *word);
414    bool noise_outlines(TWERD *word);
415    void process_selected_words(PAGE_RES *page_res, 
416                                TBOX &selection_box,
417                                bool (tesseract::Tesseract::*word_processor)(PAGE_RES_IT *pr_it));
418    void tess_add_doc_word(      
419        WERD_CHOICE *word_choice 
420    );
421    void tess_segment_pass_n(int pass_n, WERD_RES *word);
422    bool tess_acceptable_word(WERD_RES *word);
423    PAGE_RES *ApplyBoxes(const char *filename, bool find_segmentation, BLOCK_LIST *block_list);
424    void PreenXHeights(BLOCK_LIST *block_list);
425    PAGE_RES *SetupApplyBoxes(const std::vector<TBOX> &boxes, BLOCK_LIST *block_list);
426    void MaximallyChopWord(const std::vector<TBOX> &boxes, BLOCK *block, ROW *row,
427                           WERD_RES *word_res);
428    bool ResegmentCharBox(PAGE_RES *page_res, const TBOX *prev_box, const TBOX &box,
429                          const TBOX *next_box, const char *correct_text);
430    bool ResegmentWordBox(BLOCK_LIST *block_list, const TBOX &box, const TBOX *next_box,
431                          const char *correct_text);
432    void ReSegmentByClassification(PAGE_RES *page_res);
433    bool ConvertStringToUnichars(const char *utf8, std::vector<UNICHAR_ID> *class_ids);
434    bool FindSegmentation(const std::vector<UNICHAR_ID> &target_text, WERD_RES *word_res);
435    void SearchForText(const std::vector<BLOB_CHOICE_LIST *> *choices, int choices_pos,
436                       unsigned choices_length, const std::vector<UNICHAR_ID> &target_text,
437                       unsigned text_index, float rating, std::vector<int> *segmentation,
438                       float *best_rating, std::vector<int> *best_segmentation);
439    void TidyUp(PAGE_RES *page_res);
440    void ReportFailedBox(int boxfile_lineno, TBOX box, const char *box_ch, const char *err_msg);
441    void CorrectClassifyWords(PAGE_RES *page_res);
442    void ApplyBoxTraining(const std::string &fontname, PAGE_RES *page_res);
443    int CountMisfitTops(WERD_RES *word_res);
444    float ComputeCompatibleXheight(WERD_RES *word_res, float *baseline_shift);
445    BOOL_VAR_H(tessedit_resegment_from_boxes);
446    BOOL_VAR_H(tessedit_resegment_from_line_boxes);
447    BOOL_VAR_H(tessedit_train_from_boxes);
448    BOOL_VAR_H(tessedit_make_boxes_from_boxes);
449    BOOL_VAR_H(tessedit_train_line_recognizer);
450    BOOL_VAR_H(tessedit_dump_pageseg_images);
451    BOOL_VAR_H(tessedit_do_invert);
452    double_VAR_H(invert_threshold);
453    INT_VAR_H(tessedit_pageseg_mode);
454    INT_VAR_H(thresholding_method);
455    BOOL_VAR_H(thresholding_debug);
456    double_VAR_H(thresholding_window_size);
457    double_VAR_H(thresholding_kfactor);
458    double_VAR_H(thresholding_tile_size);
459    double_VAR_H(thresholding_smooth_kernel_size);
460    double_VAR_H(thresholding_score_fraction);
461    INT_VAR_H(tessedit_ocr_engine_mode);
462    STRING_VAR_H(tessedit_char_blacklist);
463    STRING_VAR_H(tessedit_char_whitelist);
464    STRING_VAR_H(tessedit_char_unblacklist);
465    BOOL_VAR_H(tessedit_ambigs_training);
466    INT_VAR_H(pageseg_devanagari_split_strategy);
467    INT_VAR_H(ocr_devanagari_split_strategy);
468    STRING_VAR_H(tessedit_write_params_to_file);
469    BOOL_VAR_H(tessedit_adaption_debug);
470    INT_VAR_H(bidi_debug);
471    INT_VAR_H(applybox_debug);
472    INT_VAR_H(applybox_page);
473    STRING_VAR_H(applybox_exposure_pattern);
474    BOOL_VAR_H(applybox_learn_chars_and_char_frags_mode);
475    BOOL_VAR_H(applybox_learn_ngrams_mode);
476    BOOL_VAR_H(tessedit_display_outwords);
477    BOOL_VAR_H(tessedit_dump_choices);
478    BOOL_VAR_H(tessedit_timing_debug);
479    BOOL_VAR_H(tessedit_fix_fuzzy_spaces);
480    BOOL_VAR_H(tessedit_unrej_any_wd);
481    BOOL_VAR_H(tessedit_fix_hyphens);
482    BOOL_VAR_H(tessedit_enable_doc_dict);
483    BOOL_VAR_H(tessedit_debug_fonts);
484    INT_VAR_H(tessedit_font_id);
485    BOOL_VAR_H(tessedit_debug_block_rejection);
486    BOOL_VAR_H(tessedit_enable_bigram_correction);
487    BOOL_VAR_H(tessedit_enable_dict_correction);
488    INT_VAR_H(tessedit_bigram_debug);
489    BOOL_VAR_H(enable_noise_removal);
490    INT_VAR_H(debug_noise_removal);
491    double_VAR_H(noise_cert_basechar);
492    double_VAR_H(noise_cert_disjoint);
493    double_VAR_H(noise_cert_punc);
494    double_VAR_H(noise_cert_factor);
495    INT_VAR_H(noise_maxperblob);
496    INT_VAR_H(noise_maxperword);
497    INT_VAR_H(debug_x_ht_level);
498    STRING_VAR_H(chs_leading_punct);
499    STRING_VAR_H(chs_trailing_punct1);
500    STRING_VAR_H(chs_trailing_punct2);
501    double_VAR_H(quality_rej_pc);
502    double_VAR_H(quality_blob_pc);
503    double_VAR_H(quality_outline_pc);
504    double_VAR_H(quality_char_pc);
505    INT_VAR_H(quality_min_initial_alphas_reqd);
506    INT_VAR_H(tessedit_tess_adaption_mode);
507    BOOL_VAR_H(tessedit_minimal_rej_pass1);
508    BOOL_VAR_H(tessedit_test_adaption);
509    BOOL_VAR_H(test_pt);
510    double_VAR_H(test_pt_x);
511    double_VAR_H(test_pt_y);
512    INT_VAR_H(multilang_debug_level);
513    INT_VAR_H(paragraph_debug_level);
514    BOOL_VAR_H(paragraph_text_based);
515    BOOL_VAR_H(lstm_use_matrix);
516    STRING_VAR_H(outlines_odd);
517    STRING_VAR_H(outlines_2);
518    BOOL_VAR_H(tessedit_good_quality_unrej);
519    BOOL_VAR_H(tessedit_use_reject_spaces);
520    double_VAR_H(tessedit_reject_doc_percent);
521    double_VAR_H(tessedit_reject_block_percent);
522    double_VAR_H(tessedit_reject_row_percent);
523    double_VAR_H(tessedit_whole_wd_rej_row_percent);
524    BOOL_VAR_H(tessedit_preserve_blk_rej_perfect_wds);
525    BOOL_VAR_H(tessedit_preserve_row_rej_perfect_wds);
526    BOOL_VAR_H(tessedit_dont_blkrej_good_wds);
527    BOOL_VAR_H(tessedit_dont_rowrej_good_wds);
528    INT_VAR_H(tessedit_preserve_min_wd_len);
529    BOOL_VAR_H(tessedit_row_rej_good_docs);
530    double_VAR_H(tessedit_good_doc_still_rowrej_wd);
531    BOOL_VAR_H(tessedit_reject_bad_qual_wds);
532    BOOL_VAR_H(tessedit_debug_doc_rejection);
533    BOOL_VAR_H(tessedit_debug_quality_metrics);
534    BOOL_VAR_H(bland_unrej);
535    double_VAR_H(quality_rowrej_pc);
536    BOOL_VAR_H(unlv_tilde_crunching);
537    BOOL_VAR_H(hocr_font_info);
538    BOOL_VAR_H(hocr_char_boxes);
539    BOOL_VAR_H(crunch_early_merge_tess_fails);
540    BOOL_VAR_H(crunch_early_convert_bad_unlv_chs);
541    double_VAR_H(crunch_terrible_rating);
542    BOOL_VAR_H(crunch_terrible_garbage);
543    double_VAR_H(crunch_poor_garbage_cert);
544    double_VAR_H(crunch_poor_garbage_rate);
545    double_VAR_H(crunch_pot_poor_rate);
546    double_VAR_H(crunch_pot_poor_cert);
547    double_VAR_H(crunch_del_rating);
548    double_VAR_H(crunch_del_cert);
549    double_VAR_H(crunch_del_min_ht);
550    double_VAR_H(crunch_del_max_ht);
551    double_VAR_H(crunch_del_min_width);
552    double_VAR_H(crunch_del_high_word);
553    double_VAR_H(crunch_del_low_word);
554    double_VAR_H(crunch_small_outlines_size);
555    INT_VAR_H(crunch_rating_max);
556    INT_VAR_H(crunch_pot_indicators);
557    BOOL_VAR_H(crunch_leave_ok_strings);
558    BOOL_VAR_H(crunch_accept_ok);
559    BOOL_VAR_H(crunch_leave_accept_strings);
560    BOOL_VAR_H(crunch_include_numerals);
561    INT_VAR_H(crunch_leave_lc_strings);
562    INT_VAR_H(crunch_leave_uc_strings);
563    INT_VAR_H(crunch_long_repetitions);
564    INT_VAR_H(crunch_debug);
565    INT_VAR_H(fixsp_non_noise_limit);
566    double_VAR_H(fixsp_small_outlines_size);
567    BOOL_VAR_H(tessedit_prefer_joined_punct);
568    INT_VAR_H(fixsp_done_mode);
569    INT_VAR_H(debug_fix_space_level);
570    STRING_VAR_H(numeric_punctuation);
571    INT_VAR_H(x_ht_acceptance_tolerance);
572    INT_VAR_H(x_ht_min_change);
573    INT_VAR_H(superscript_debug);
574    double_VAR_H(superscript_worse_certainty);
575    double_VAR_H(superscript_bettered_certainty);
576    double_VAR_H(superscript_scaledown_ratio);
577    double_VAR_H(subscript_max_y_top);
578    double_VAR_H(superscript_min_y_bottom);
579    BOOL_VAR_H(tessedit_write_block_separators);
580    BOOL_VAR_H(tessedit_write_rep_codes);
581    BOOL_VAR_H(tessedit_write_unlv);
582    BOOL_VAR_H(tessedit_create_txt);
583    BOOL_VAR_H(tessedit_create_hocr);
584    BOOL_VAR_H(tessedit_create_alto);
585    BOOL_VAR_H(tessedit_create_lstmbox);
586    BOOL_VAR_H(tessedit_create_tsv);
587    BOOL_VAR_H(tessedit_create_wordstrbox);
588    BOOL_VAR_H(tessedit_create_pdf);
589    BOOL_VAR_H(textonly_pdf);
590    INT_VAR_H(jpg_quality);
591    INT_VAR_H(user_defined_dpi);
592    INT_VAR_H(min_characters_to_try);
593    STRING_VAR_H(unrecognised_char);
594    INT_VAR_H(suspect_level);
595    INT_VAR_H(suspect_short_words);
596    BOOL_VAR_H(suspect_constrain_1Il);
597    double_VAR_H(suspect_rating_per_ch);
598    double_VAR_H(suspect_accept_rating);
599    BOOL_VAR_H(tessedit_minimal_rejection);
600    BOOL_VAR_H(tessedit_zero_rejection);
601    BOOL_VAR_H(tessedit_word_for_word);
602    BOOL_VAR_H(tessedit_zero_kelvin_rejection);
603    INT_VAR_H(tessedit_reject_mode);
604    BOOL_VAR_H(tessedit_rejection_debug);
605    BOOL_VAR_H(tessedit_flip_0O);
606    double_VAR_H(tessedit_lower_flip_hyphen);
607    double_VAR_H(tessedit_upper_flip_hyphen);
608    BOOL_VAR_H(rej_trust_doc_dawg);
609    BOOL_VAR_H(rej_1Il_use_dict_word);
610    BOOL_VAR_H(rej_1Il_trust_permuter_type);
611    BOOL_VAR_H(rej_use_tess_accepted);
612    BOOL_VAR_H(rej_use_tess_blanks);
613    BOOL_VAR_H(rej_use_good_perm);
614    BOOL_VAR_H(rej_use_sensible_wd);
615    BOOL_VAR_H(rej_alphas_in_number_perm);
616    double_VAR_H(rej_whole_of_mostly_reject_word_fract);
617    INT_VAR_H(tessedit_image_border);
618    STRING_VAR_H(ok_repeated_ch_non_alphanum_wds);
619    STRING_VAR_H(conflict_set_I_l_1);
620    INT_VAR_H(min_sane_x_ht_pixels);
621    BOOL_VAR_H(tessedit_create_boxfile);
622    INT_VAR_H(tessedit_page_number);
623    BOOL_VAR_H(tessedit_write_images);
624    BOOL_VAR_H(interactive_display_mode);
625    STRING_VAR_H(file_type);
626    BOOL_VAR_H(tessedit_override_permuter);
627    STRING_VAR_H(tessedit_load_sublangs);
628    BOOL_VAR_H(tessedit_use_primary_params_model);
629    double_VAR_H(min_orientation_margin);
630    BOOL_VAR_H(textord_tabfind_show_vlines);
631    BOOL_VAR_H(textord_use_cjk_fp_model);
632    BOOL_VAR_H(poly_allow_detailed_fx);
633    BOOL_VAR_H(tessedit_init_config_only);
634  #ifndef DISABLED_LEGACY_ENGINE
635    BOOL_VAR_H(textord_equation_detect);
636  #endif 
637    BOOL_VAR_H(textord_tabfind_vertical_text);
638    BOOL_VAR_H(textord_tabfind_force_vertical_text);
639    double_VAR_H(textord_tabfind_vertical_text_ratio);
640    double_VAR_H(textord_tabfind_aligned_gap_fraction);
641    INT_VAR_H(tessedit_parallelize);
642    BOOL_VAR_H(preserve_interword_spaces);
643    STRING_VAR_H(page_separator);
644    INT_VAR_H(lstm_choice_mode);
645    INT_VAR_H(lstm_choice_iterations);
646    double_VAR_H(lstm_rating_coefficient);
647    BOOL_VAR_H(pageseg_apply_music_mask);
648    FILE *init_recog_training(const char *filename);
649    void recog_training_segmented(const char *filename, PAGE_RES *page_res,
650                                  volatile ETEXT_DESC *monitor, FILE *output_file);
651    void ambigs_classify_and_output(const char *label, PAGE_RES_IT *pr_it, FILE *output_file);
652  private:
653    const char *backup_config_file_;
654    std::string word_config_;
655    Image pix_binary_;
656    Image pix_grey_;
657    Image pix_original_;
658    Image pix_thresholds_;
659    DebugPixa pixa_debug_;
660    int source_resolution_;
661    ShiroRekhaSplitter splitter_;
662    Textord textord_;
663    bool right_to_left_;
664    Image scaled_color_;
665    int scaled_factor_;
666    FCOORD deskew_;
667    FCOORD reskew_;
668    TesseractStats stats_;
669    std::vector<Tesseract *> sub_langs_;
670    Tesseract *most_recently_used_;
671    int font_table_size_;
672  #ifndef DISABLED_LEGACY_ENGINE
673    EquationDetect *equ_detect_;
674  #endif 
675    LSTMRecognizer *lstm_recognizer_;
676    int train_line_page_num_;
677  };
678  } 
679  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bd.h</h3>
            <pre><code>1  #ifndef bd_h
2  #define bd_h
3  #define forever for(;;)
4  typedef unsigned char uchar;
5  typedef unsigned int uint;
6  typedef unsigned long ulong;
7  typedef unsigned short ushort;
8  typedef float sdouble;
9  typedef long double ldouble;
10  typedef FILE* TFileId;
11  typedef char int8;
12  typedef short int16;
13  typedef int int32;
14  #ifdef GLib_WIN32
15  typedef __int64 int64;
16  #elif defined(GLib_GLIBC)
17  typedef int64_t int64;
18  #else
19  typedef long long int64;
20  #endif
21  typedef unsigned char uint8;
22  typedef unsigned short uint16;
23  typedef unsigned int uint32;
24  #ifdef GLib_WIN32
25  typedef unsigned __int64 uint64;
26  #elif defined(GLib_GLIBC)
27  typedef u_int64_t uint64;
28  #else
29  typedef unsigned long long uint64;
30  #endif
31  #if (!defined(__ssize_t_defined) && !defined(GLib_MACOSX))
32  typedef ptrdiff_t ssize_t;
33  #endif
34  #if defined(GLib_UNIX)
35  #define _isnan(x) isnan(x)
36  #if defined(GLib_MACOSX)
37    #define _finite(x) isfinite(x)
38  #else
39    #define _finite(x) finite(x)
40  #endif
41  #endif
42  #if defined(GLib_WIN32)
43  #define _vsnprintf vsnprintf
44  #endif
45  typedef size_t TSize;
46  #define TSizeMx SIZE_MAX
47  #if 0
48  #if defined(GLib_GLIBC) || defined(GLib_BSD)
49  struct __exception {
50    int    type;      &bsol;* Exception type */
51    char*  name;      &bsol;* Name of function causing exception */
52    double arg1;      &bsol;* 1st argument to function */
53    double arg2;      &bsol;* 2nd argument to function */
54    double retval;    &bsol;* Function return value */
55  };
56  #endif
57  #endif
58  typedef enum {lUndef, lUs, lSi} TLoc;
59  void WrNotify(const char* CaptionCStr, const char* NotifyCStr);
60  void SaveToErrLog(const char* MsgCStr);
61  inline void InfoNotify(const char* NotifyCStr){
62    WrNotify("Information", NotifyCStr);}
63  inline void WarnNotify(const char* NotifyCStr){
64    WrNotify("Warning", NotifyCStr);}
65  inline void ErrNotify(const char* NotifyCStr){
66    WrNotify("Error", NotifyCStr);}
67  inline void StatNotify(const char* NotifyCStr){
68    WrNotify("Status", NotifyCStr);}
69  #if defined (GLib_WIN)
70    #define snprintf _snprintf
71    #define vsnprintf  _vsnprintf
72    #pragma warning(disable: 4786)
73    #pragma warning(disable: 4996)
74  #endif
75  #if defined (GLib_GCC)
76    #define _CONSOLE
77  #endif
78  #if defined(_CONSOLE)||defined(__CONSOLE__)
79    #define GLib_Console
80  #endif
81  #if defined(GLib_Console) && (! (defined(__CONSOLE__)||defined(_CONSOLE)))
82    #define GLib_CreateConsole
83  #endif
84  #define ClassT(TNm) \
85  class TNm{
86  #define ClassTV(TNm, TNmV) \
87  class TNm; \
88  typedef TVec<TNm> TNmV; \
89  class TNm{
90  #define ClassTVQ(TNm, TNmV, TNmQ) \
91  class TNm; \
92  typedef TVec<TNm> TNmV; \
93  typedef TQQueue<TNm> TNmQ; \
94  class TNm{
95  #define ClassTP(TNm, PNm) \
96  class TNm; \
97  typedef TPt<TNm> PNm; \
98  class TNm{ \
99  private: \
100    TCRef CRef; \
101  public: \
102    friend class TPt<TNm>;
103  #define ClassHdTP(TNm, PNm) \
104  class TNm; \
105  typedef TPt<TNm> PNm;
106  #define ClassTPE(TNm, PNm, ENm) \
107  class TNm; \
108  typedef TPt<TNm> PNm; \
109  class TNm: public ENm{ \
110  private: \
111    TCRef CRef; \
112  public: \
113    friend class TPt<TNm>;
114  #define ClassTPEE(TNm, PNm, ENm1, ENm2) \
115  class TNm; \
116  typedef TPt<TNm> PNm; \
117  class TNm: public ENm1, public ENm2{ \
118  private: \
119    TCRef CRef; \
120  public: \
121    friend class TPt<TNm>;
122  #define ClassTE(TNm, ENm) \
123  class TNm; \
124  class TNm: public ENm{ \
125  public: \
126  
127  #define ClassTPV(TNm, PNm, TNmV) \
128  class TNm; \
129  typedef TPt<TNm> PNm; \
130  typedef TVec<PNm> TNmV; \
131  class TNm{ \
132  private: \
133    TCRef CRef; \
134  public: \
135    friend class TPt<TNm>;
136  #define ClassHdTPV(TNm, PNm, TNmV) \
137  class TNm; \
138  typedef TPt<TNm> PNm; \
139  typedef TVec<PNm> TNmV;
140  #define ClassTPVL(TNm, PNm, TNmV, TNmL, TNmLN) \
141  class TNm; \
142  typedef TPt<TNm> PNm; \
143  typedef TVec<PNm> TNmV; \
144  typedef TLst<PNm> TNmL; \
145  typedef TLstNd<PNm>* TNmLN; \
146  class TNm{ \
147  private: \
148    TCRef CRef; \
149  public: \
150    friend class TPt<TNm>;
151  class TSIn;
152  class TSOut;
153  class TStr;
154  class TXmlObjSer;
155  class TXmlObjSerTagNm;
156  template <class TRec> class TPt;
157  ClassHdTP(TXmlTok, PXmlTok)
158  ClassHdTP(TExcept, PExcept)
159  ClassHdTP(TXmlDoc, PXmlDoc)
160  #define UndefDefaultCopyAssign(TNm) \
161  private: \
162    TNm(){} \
163    TNm(const TNm&); \
164    TNm& operator=(const TNm&)
165  #define UndefCopyAssign(TNm) \
166  private: \
167    TNm(const TNm&); \
168    TNm& operator=(const TNm&)
169  #define UndefCopy(TNm) \
170  private: \
171    TNm(const TNm&)
172  #define UndefAssign(TNm) \
173  private: \
174    TNm& operator=(const TNm&)
175  class TOnExeStop{
176  private:
177    typedef bool (*TOnExeStopF)(char* MsgCStr);
178    static TOnExeStopF OnExeStopF;
179  public:
180    static bool IsOnExeStopF(){return OnExeStopF!=NULL;}
181    static void PutOnExeStopF(TOnExeStopF _OnExeStopF){OnExeStopF=_OnExeStopF;}
182    static TOnExeStopF GetOnExeStopF(){return OnExeStopF;}
183  };
184  void ExeStop(
185   const char* MsgStr, const char* ReasonStr,
186   const char* CondStr, const char* FNm, const int& LnN);
187  #define Fail ExeStop(NULL, NULL, "Fail", __FILE__, __LINE__)
188  #define FailR(Reason) ExeStop((Reason), NULL, "Fail", __FILE__, __LINE__)
189  #define FailRA(Reason, ArgStr) \
190    ExeStop((TStr(Reason)+" ("+ArgStr+")").CStr(), NULL, "Fail", __FILE__, __LINE__)
191  #define EFail TExcept::ThrowFull("", TStr("[")+ TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) + "]")
192  #define EFailR(Reason) TExcept::ThrowFull(Reason, TStr("[")+TStr(__FILE__)+" line "+TInt::GetStr(__LINE__)+"]")
193  #ifdef NDEBUG
194  #define Assert(Cond)
195  #else
196  #define Assert(Cond) \
197    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, NULL, #Cond, __FILE__, __LINE__))
198  #endif
199  #ifdef NDEBUG
200  #define AssertR(Cond, Reason)
201  #else
202  #define AssertR(Cond, Reason) ((Cond) ? static_cast<void>(0) : \
203    ExeStop(NULL, TStr(Reason).CStr(), #Cond, __FILE__, __LINE__))
204  #endif
205  #define IAssert(Cond) \
206    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, NULL, #Cond, __FILE__, __LINE__))
207  #define IAssertR(Cond, Reason) \
208    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, TStr(Reason).CStr(), #Cond, __FILE__, __LINE__))
209  #define WAssert(Cond, MsgCStr) \
210    ((Cond) ? static_cast<void>(0) : WarnNotify(MsgCStr))
211  #define SAssert(Cond) \
212    ((Cond) ? static_cast<void>(0) : ExeStop(TSysStr::GetLastMsgCStr(), NULL, #Cond, __FILE__, __LINE__))
213  #define FAssert(Cond, MsgCStr) \
214    ((Cond) ? static_cast<void>(0) : ExeStop(TStr(MsgCStr).CStr(), NULL, NULL, __FILE__, __LINE__))
215  #define FSAssert(Cond) \
216    ((Cond) ? static_cast<void>(0) : ExeStop(TSysStr::GetLastMsgCStr(), NULL, NULL, __FILE__, __LINE__))
217  #define EAssert(Cond) \
218    ((Cond) ? static_cast<void>(0) : TExcept::ThrowFull(#Cond, TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) +": "+ TStr(#Cond)))
219  #define EAssertR(Cond, MsgStr) \
220    ((Cond) ? static_cast<void>(0) : TExcept::ThrowFull(MsgStr, TStr(__FILE__)+" line "+TInt::GetStr(__LINE__)+": "+TStr(#Cond)))
221  #define EAssertRA(Cond, MsgStr, ArgStr) \
222    ((Cond) ? static_cast<void>(0) : TExcept::Throw(MsgStr, ArgStr))
223  #define EAssertRAA(Cond, MsgStr, ArgStr1, ArgStr2) \
224    ((Cond) ? static_cast<void>(0) : TExcept::Throw(MsgStr, ArgStr1, ArgStr2))
225  #define ESAssert(Cond) \
226    ((Cond) ? static_cast<void>(0) : TExcept::Throw(TSysStr::GetLastMsgCStr(), \
227    TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) +": "+ TStr(#Cond)))
228  template <bool BoolVal> struct TStaticAssert;
229  template <> struct TStaticAssert<true> { enum { value = 1 }; };
230  template<int IntVal> struct TStaticAssertTest{};
231  #define CAssert(Cond) \
232    
233  template <class TRec>
234  bool IsXLoadFromFileOk(const TStr& FNm, const TStr& Nm, TRec& Rec, TStr& MsgStr);
235  template <class TRec>
236  void XLoadFromFile(const TStr& FNm, const TStr& Nm, TRec& Rec);
237  #define XLoadHd(Nm) \
238    {TStr TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
239    TXmlObjSer::AssertXmlHd(XmlTok, Nm, TypeNm);}
240  #define XLoad(Nm) \
241    Nm.LoadXml(XmlTok->GetTagTok(#Nm), #Nm);
242  #define XSaveHd(Nm) \
243    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
244    TXmlObjSerTagNm XmlObjSerTagNm(SOut, false, Nm, _TypeNm);
245  #define XSaveHdArg(Nm, ArgNm, ArgVal) \
246    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
247    TXmlObjSerTagNm XmlObjSerTagNm(SOut, false, Nm, _TypeNm, ArgNm, ArgVal);
248  #define XSaveBETag(Nm) \
249    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
250    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm);
251  #define XSaveBETagArg(Nm, ArgNm, ArgVal) \
252    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
253    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm, ArgNm, ArgVal);
254  #define XSaveBETagArg4(Nm, ArgNm1, ArgVal1, ArgNm2, ArgVal2, ArgNm3, ArgVal3, ArgNm4, ArgVal4) \
255    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
256    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm, ArgNm1, ArgVal1, ArgNm2, ArgVal2, ArgNm3, ArgVal3, ArgNm4, ArgVal4);
257  #define XSave(Nm) \
258    Nm.SaveXml(SOut, #Nm)
259  #define XSaveToFile(Nm, FNm) \
260    {TFOut SOut(FNm); Nm.SaveXml(SOut, #Nm);}
261  typedef enum {loUndef, loNot, loAnd, loOr} TLogOp;
262  typedef enum {roUndef, roLs, roLEq, roEq, roNEq, roGEq, roGt} TRelOp;
263  #ifndef MIN
264    #define MIN(a,b) ((a)<(b)?(a):(b))
265  #endif
266  #ifndef MAX
267    #define MAX(a,b) ((a)>(b)?(a):(b))
268  #endif
269  template<class T>
270  class TEq{
271  public:
272    bool operator()(const T& x, const T& y) const {return x==y;}
273  };
274  template<class T>
275  class TNEq{
276  public:
277    bool operator()(const T& x, const T& y) const {return x!=y;}
278  };
279  template<class T>
280  class TLss{
281  public:
282    bool operator()(const T& x, const T& y) const {return x<y;}
<span onclick='openModal()' class='match'>283    int Cmp(const T& d1, const T& d2) const {
284      if (d1<d2){return -1;}
285      else if (d2<d1){return 1;}
286      else {return 0;}
287    }
</span>288  };
289  template<class T>
290  class TLEq{
291  public:
292    bool operator()(const T& x, const T& y) const {return x<=y;}
293  };
294  template<class T>
295  class TGtr{
296  public:
297    bool operator() (const T& x, const T& y) const { return x>y; }
298    int Cmp(const T& d1, const T& d2) const { /&bsol;** vprasaj Janeza za uporabo
299      if (d1<d2){return 1;}
300      else if (d2<d1){return -1;}
301      else {return 0;}
302    }
303  };
304  template<class T>
305  class TGEq{
306  public:
307    bool operator()(const T& x, const T& y) const {return x>=y;}
308  };
309  template<class T>
310  class TCmp{
311  public:
312    int operator()(const T& x, const T& y) const {
313      if (x < y){return -1;}
314      else if (x > y){return 1;}
315      else {return 0;}
316    }
317  };
318  template <class TRec>
319  bool operator!=(const TRec& Rec1, const TRec& Rec2){return !(Rec1==Rec2);}
320  template <class TRec>
321  bool operator>(const TRec& Rec1, const TRec& Rec2){return Rec2<Rec1;}
322  template <class TRec>
323  bool operator<=(const TRec& Rec1, const TRec& Rec2){return !(Rec2<Rec1);}
324  template <class TRec>
325  bool operator>=(const TRec& Rec1, const TRec& Rec2){return !(Rec1<Rec2);}
326  template <class TRec>
327  bool Cmp(const int& RelOp, const TRec& Rec1, const TRec& Rec2){
328    switch (RelOp){
329      case roLs: return Rec1<Rec2;
330      case roLEq: return Rec1<=Rec2;
331      case roEq: return Rec1==Rec2;
332      case roNEq: return Rec1!=Rec2;
333      case roGEq: return Rec1>=Rec2;
334      case roGt: return Rec1>Rec2;
335      default: Fail; return false;
336    }
337  }
338  class TCRef{
339  private:
340    int Refs;
341  private:
342    TCRef& operator=(const TCRef&);
343    TCRef(const TCRef&);
344  public:
345    TCRef(): Refs(0){}
346    ~TCRef(){Assert(Refs==0);}
347    void MkRef(){Refs++;}
348    void UnRef(){Assert(Refs>0); Refs--;}
349    bool NoRef() const {return Refs==0;}
350    int GetRefs() const {return Refs;}
351  };
352  template <class TRec>
353  class TPt{
354  public:
355    typedef TRec TObj;
356  private:
357    TRec* Addr;
358    void MkRef() const {
359      if (Addr!=NULL){
360        Addr->CRef.MkRef();
361      }
362    }
363    void UnRef() const {
364      if (Addr!=NULL){
365        Addr->CRef.UnRef();
366        if (Addr->CRef.NoRef()){delete Addr;}
367      }
368    }
369  public:
370    TPt(): Addr(NULL){}
371    TPt(const TPt& Pt): Addr(Pt.Addr){MkRef();}
372    TPt(TRec* _Addr): Addr(_Addr){MkRef();}
373    static TPt New(){return TObj::New();}
374    ~TPt(){UnRef();}
375    explicit TPt(TSIn& SIn);
376    explicit TPt(TSIn& SIn, void* ThisPt);
377    void Save(TSOut& SOut) const;
378    void LoadXml(const TPt<TXmlTok>& XmlTok, const TStr& Nm);
379    void SaveXml(TSOut& SOut, const TStr& Nm) const;
380    TPt& operator=(const TPt& Pt){
381      if (this!=&Pt){Pt.MkRef(); UnRef(); Addr=Pt.Addr;} return *this;}
382    bool operator==(const TPt& Pt) const {return *Addr==*Pt.Addr;}
383    bool operator!=(const TPt& Pt) const {return *Addr!=*Pt.Addr;}
384    bool operator<(const TPt& Pt) const {return *Addr<*Pt.Addr;}
385    TRec* operator->() const {Assert(Addr!=NULL); return Addr;}
386    TRec& operator*() const {Assert(Addr!=NULL); return *Addr;}
387    TRec& operator[](const int& RecN) const {
388      Assert(Addr!=NULL); return Addr[RecN];}
389    TRec* operator()() const {return Addr;}
390    bool Empty() const { return Addr==NULL;}
391    void Clr(){UnRef(); Addr=NULL;}
392    int GetRefs() const {
393      if (Addr==NULL){return -1;} else {return Addr->CRef.GetRefs();}}
394    int GetPrimHashCd() const {return Addr->GetPrimHashCd();}
395    int GetSecHashCd() const {return Addr->GetSecHashCd();}
396    TPt<TRec> Clone(){return MkClone(*this);}
397  };
398  class TSStr{
399  private:
400    char* Bf;
401  public:
402    TSStr(): Bf(NULL){
403      Bf=new char[0+1]; Bf[0]=0;}
404    TSStr(const TSStr& SStr): Bf(NULL){
405      Bf=new char[strlen(SStr.Bf)+1]; strcpy(Bf, SStr.Bf);}
406    TSStr(const char* _Bf): Bf(NULL){
407      Bf=new char[strlen(_Bf)+1]; strcpy(Bf, _Bf);}
408    ~TSStr(){delete[] Bf;}
409    TSStr& operator=(const TSStr& SStr){
410      if (this!=&SStr){
411        delete[] Bf; Bf=new char[strlen(SStr.Bf)+1]; strcpy(Bf, SStr.Bf);}
412      return *this;}
413    char* CStr() {return Bf;}
414    const char* CStr() const {return Bf;}
415    bool Empty() const {return Bf[0]==0;}
416    int Len() const {return int(strlen(Bf));}
417  };
418  class TConv_Pt64Ints32{
419  private:
420    union{
421      void* Pt;
422      uint64 UInt64;
423      struct {uint Ls; uint Ms;} UInt32;
424    } Val;
425    UndefCopyAssign(TConv_Pt64Ints32);
426  public:
427    TConv_Pt64Ints32(){
428      Val.Pt=0; Val.UInt32.Ms=0; Val.UInt32.Ls=0;}
429    TConv_Pt64Ints32(void* Pt){
430      Val.UInt32.Ms=0; Val.UInt32.Ls=0; Val.Pt=Pt;}
431    TConv_Pt64Ints32(const uint& Ms, const uint& Ls){
432      Val.Pt=0; Val.UInt32.Ms=Ms; Val.UInt32.Ls=Ls;}
433    void PutPt(void* Pt){Val.Pt=Pt;}
434    void* GetPt() const {return Val.Pt;}
435    void PutUInt64(const uint64& _UInt64){Val.UInt64=_UInt64;}
436    uint64 GetUInt64() const {return Val.UInt64;}
437    void PutMsUInt32(const uint& Ms){Val.UInt32.Ms=Ms;}
438    uint GetMsUInt32() const {return Val.UInt32.Ms;}
439    void PutLsUInt32(const uint& Ls){Val.UInt32.Ls=Ls;}
440    uint GetLsUInt32() const {return Val.UInt32.Ls;}
441  };
442  template <class TRec>
443  void Swap(TRec& Rec1, TRec& Rec2){
444    TRec Rec=Rec1; Rec1=Rec2; Rec2=Rec;
445  }
446  class TPairHashImpl1 {
447  public:
448    static inline int GetHashCd(const int hc1, const int hc2) {
449      unsigned long long sum = ((unsigned long long) hc1) + ((unsigned long long) hc2);
450      unsigned long long c = ((sum * (sum + 1)) >> 1) + hc1;
451      return (int) (c % 0x7fffffffULL); }
452  };
453  class TPairHashImpl2 {
454  public:
455    static inline int GetHashCd(const int hc1, const int hc2) {
456      unsigned long long sum = ((unsigned long long) hc1) + ((unsigned long long) hc2);
457      unsigned long long c = ((sum * (sum + 1)) >> 1) + hc1;
458      unsigned int R = (unsigned int) (c >> 31), Q = (unsigned int) (c & 0x7fffffffULL);
459      if ((R & 0x80000000U) != 0) R -= 0x7fffffffU;
460      unsigned int RQ = R + Q;
461      if (RQ < 0x7fffffffU) return (int) RQ;
462      RQ -= 0x7fffffffU;
463      return (RQ == 0x7fffffffU) ? 0 : (int) RQ; }
464  };
465  #if (defined(GLib_64Bit)) && ! (defined(DEBUG) || defined(_DEBUG))
466    typedef TPairHashImpl1 TPairHashImpl;
467  #else
468    typedef TPairHashImpl2 TPairHashImpl;
469  #endif
470  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tesseractclass.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bd.h</div>
                <div class="column column_space"><pre><code>129    Image BestPix() const {
130      if (pixGetWidth(pix_original_) == ImageWidth()) {
131        return pix_original_;
132      } else if (pix_grey_ != nullptr) {
133        return pix_grey_;
134      } else {
135        return pix_binary_;
136      }
137    }
</pre></code></div>
                <div class="column column_space"><pre><code>283    int Cmp(const T& d1, const T& d2) const {
284      if (d1<d2){return -1;}
285      else if (d2<d1){return 1;}
286      else {return 0;}
287    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    