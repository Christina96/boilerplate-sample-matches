
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.010427528675704%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-url.cpp</h3>
            <pre><code>1  class TUrlLxChDef{
2  private:
3    TBoolV IsLoAlphaV, IsHiAlphaV, IsAlphaV;
4    TBoolV IsDigitV, IsSafeV, IsExtraV;
5    TBoolV IsNationalV, IsPunctuationV;
6    TBoolV IsReservedV, IsHexV;
7    TBoolV IsUnreservedV, IsUCharV, IsXCharV;
8    TBoolV IsSchemeV, IsHostV, IsHSegmentV;
9    void InclCh(TBoolV& BoolV, const char& Ch);
10    void InclStr(TBoolV& BoolV, const TStr& Str);
11    void InclBoolV(TBoolV& BoolV, const TBoolV& OrBoolV);
12  public:
13    static const char EofCh;
14    static const char EscCh;
15    TUrlLxChDef();
16    bool IsDigitCh(const char& Ch) const {return (Ch>=0)&&IsDigitV[Ch];}
17    bool IsSchemeCh(const char& Ch) const {return (Ch>=0)&&IsSchemeV[Ch];}
18    bool IsHostCh(const char& Ch) const {return (Ch>=0)&&IsHostV[Ch];}
19    bool IsHSegmentCh(const char& Ch) const {
20      return (Ch<0)||((Ch>=0)&&IsHSegmentV[Ch]);}
21  };
22  const char TUrlLxChDef::EofCh=0;
23  const char TUrlLxChDef::EscCh='%';
24  void TUrlLxChDef::InclCh(TBoolV& BoolV, const char& Ch){BoolV[Ch]=true;}
25  void TUrlLxChDef::InclStr(TBoolV& BoolV, const TStr& Str){
26    for (int CC=0; CC<Str.Len(); CC++){BoolV[Str.GetCh(CC)]=true;}}
27  void TUrlLxChDef::InclBoolV(TBoolV& BoolV, const TBoolV& OrBoolV){
28    for (int BoolN=0; BoolN<BoolV.Len(); BoolN++){
29      BoolV[BoolN]=BoolV[BoolN]||OrBoolV[BoolN];}}
30  TUrlLxChDef::TUrlLxChDef():
31    IsLoAlphaV(TCh::Vals), IsHiAlphaV(TCh::Vals), IsAlphaV(TCh::Vals),
32    IsDigitV(TCh::Vals), IsSafeV(TCh::Vals), IsExtraV(TCh::Vals),
33    IsNationalV(TCh::Vals), IsPunctuationV(TCh::Vals),
34    IsReservedV(TCh::Vals), IsHexV(TCh::Vals),
35    IsUnreservedV(TCh::Vals), IsUCharV(TCh::Vals), IsXCharV(TCh::Vals),
36    IsSchemeV(TCh::Vals), IsHostV(TCh::Vals), IsHSegmentV(TCh::Vals){
37    InclStr(IsLoAlphaV, "abcdefghijklmnopqrstuvwxyz");
38    InclStr(IsHiAlphaV, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
39    InclBoolV(IsAlphaV, IsLoAlphaV); InclBoolV(IsAlphaV, IsHiAlphaV);
40    InclStr(IsDigitV, "0123456789");
41    InclStr(IsSafeV, "$-_.+");
42    InclStr(IsExtraV, "!*'(),");
43    InclStr(IsNationalV, "{}|\\^~[]`");
44    InclStr(IsPunctuationV, "<>#%\"");
45    InclStr(IsReservedV, ";/?:@&=");
46    InclBoolV(IsHexV, IsDigitV); InclStr(IsHexV, "ABCDEFabcdef");
47    InclBoolV(IsUnreservedV, IsAlphaV); InclBoolV(IsUnreservedV, IsDigitV);
48    InclBoolV(IsUnreservedV, IsSafeV); InclBoolV(IsUnreservedV, IsExtraV);
49    InclBoolV(IsUCharV, IsUnreservedV); InclStr(IsUCharV, TStr(EscCh));
50    InclBoolV(IsXCharV, IsUnreservedV); InclBoolV(IsXCharV, IsReservedV);
51    InclStr(IsXCharV, TStr(EscCh));
52    InclBoolV(IsSchemeV, IsAlphaV); InclBoolV(IsSchemeV, IsDigitV);
53    InclStr(IsSchemeV, "+-.");
54    InclBoolV(IsHostV, IsAlphaV); InclBoolV(IsHostV, IsDigitV);
55    InclStr(IsHostV, "-_");
56    InclBoolV(IsHSegmentV, IsUCharV); InclStr(IsHSegmentV, ";:@&=");
57    InclBoolV(IsHSegmentV, IsNationalV); InclStr(IsHSegmentV, " ");
58  }
59  class TUrlLx{
60  private:
61    static const char EofCh;
62    TChA Bf;
63    int BfC;
64  public:
65    static const TUrlLxChDef ChDef;
66    TUrlLx(const TStr& _Str): Bf(_Str), BfC(0){}
67    bool Eof() const {return BfC==Bf.Len();};
68    char GetCh(){if (Eof()){return EofCh;} else {return Bf[BfC++];}}
69    char PeekCh() const {if (Eof()){return EofCh;} else {return Bf[BfC];}}
70    char GetCh(const char& Ch){EAssertR(GetCh()==Ch, ""); return Ch;}
71    TStr GetStr(const TStr& Str){
72      for (int ChN=0; ChN<Str.Len(); ChN++){GetCh(Str[ChN]);} return Str;}
73    const char* GetStr(const char *Str){
74  	int Len = (int) strlen(Str);
75      for (int ChN=0; ChN<Len; ChN++){GetCh(Str[ChN]);} 
76  	return Str;
77    }
78    bool IsSchemeCh() const {return ChDef.IsSchemeCh(PeekCh());}
79    char GetSchemeCh(){EAssertR(IsSchemeCh(), ""); return GetCh();}
80    bool IsDigitCh() const {return ChDef.IsDigitCh(PeekCh());}
81    char GetDigitCh(){EAssertR(IsDigitCh(), ""); return GetCh();}
82    bool IsHSegmentCh() const {return ChDef.IsHSegmentCh(PeekCh());}
83    char GetHSegmentCh(){EAssertR(IsHSegmentCh(), ""); return GetCh();}
84    TStr GetToCh(const char& Ch=TUrlLxChDef::EofCh){TChA Str;
85      while ((PeekCh()!=EofCh)&&(PeekCh()!=Ch)){Str+=GetCh();} return Str;}
86    TStr GetScheme(){TChA Str;
87      Str+=GetSchemeCh(); while (IsSchemeCh()){Str+=GetCh();}
88      Str.ToLc(); return Str;}
89    TStr GetHost();
90    TStr GetDigits(){TChA Str;
91      do {Str+=GetDigitCh();} while (IsDigitCh()); return Str;}
92    TStr GetHostPort(TStr& HostNm, TStr& PortStr, int& PortN);
93    TStr GetHPath(TStrV& PathSegV);
94    TStr GetSearch(){return GetToCh('#');}
95  };
96  const TUrlLxChDef TUrlLx::ChDef;
97  const char TUrlLx::EofCh=TUrlLxChDef::EofCh;
98  TStr TUrlLx::GetHost(){TChA Str;
99    EAssertR(ChDef.IsHostCh(PeekCh()), "");
100    do {
101      while (ChDef.IsHostCh(PeekCh())){Str+=GetCh();}
102      if (PeekCh()=='.'){Str+=GetCh('.');}
103      else if (PeekCh()=='@'){GetCh('@'); Str.Clr();} 
104    } while (ChDef.IsHostCh(PeekCh()));
105    Str.ToLc();
106    return Str;
107  }
108  TStr TUrlLx::GetHostPort(TStr& HostNm, TStr& PortStr, int& PortN){TChA Str;
109    Str+=HostNm=GetHost();
110    if (PeekCh()==':'){
111      Str+=GetCh(':');
112      if (IsDigitCh()){Str+=PortStr=GetDigits(); PortN=PortStr.GetInt();}
113    }
114    return Str;
115  }
116  TStr TUrlLx::GetHPath(TStrV& PathSegV){TChA Str; TChA HSegStr; bool Cont;
117    do {
118      while (PeekCh()=='/'){GetCh('/');} 
119      HSegStr.Clr(); while (IsHSegmentCh()){HSegStr+=GetHSegmentCh();}
120      Str+=HSegStr; PathSegV.Add(HSegStr);
121      Cont=(PeekCh()=='/'); if (Cont){Str+=GetCh('/');}
122    } while (Cont);
123    return Str;
124  }
125  const TStr TUrl::UrlHttpPrefixStr="http:";
126  const TStr TUrl::UrlHttpAbsPrefixStr="http:&bsol;&bsol;";
127  void TUrl::GetAbs(const TStr& AbsUrlStr){
128    EAssertR(IsAbs(AbsUrlStr), AbsUrlStr);
129    TUrlLx Lx(AbsUrlStr); TChA Str;
130    Str+=SchemeNm=Lx.GetScheme(); Str+=Lx.GetCh(':');
131    if (SchemeNm=="http"){
132      Scheme=usHttp;
133      const char *DbSlashStr="&bsol;&bsol;";
134      Str+=Lx.GetStr(DbSlashStr);
135      Str+=Lx.GetHostPort(HostNm, PortStr, PortN);
136      if (PortN==-1){PortN=THttp::DfPortN; PortStr.Clr();}
137      else if (PortN==THttp::DfPortN){PortStr.Clr();}
138      /&bsol;**if (!PortStr.Empty()){Str+=':'; Str+=PortStr;}
139      if (Lx.PeekCh()=='/'){
140        PathStr=Lx.GetCh('/'); PathStr+=Lx.GetHPath(PathSegV); Str+=PathStr;}
141      if (PathStr.Empty()){PathStr="/"; Str+=PathStr;}
142      if (Lx.PeekCh()=='?'){
143        SearchStr=Lx.GetCh('?'); SearchStr+=Lx.GetSearch(); Str+=SearchStr;}
144    } else {
145      Scheme=usOther; Str+=Lx.GetToCh();
146    }
147    while (Lx.PeekCh()==' '){Lx.GetCh();}
148    if (Lx.PeekCh()=='#'){
149      FragIdStr=Lx.GetCh('#'); FragIdStr+=Lx.GetToCh();
150    }
151    EAssertR(Lx.Eof(), "");
152    UrlStr=Str;
153  }
154  void TUrl::GetAbsFromBase(const TStr& RelUrlStr, const TStr& BaseUrlStr){
155    EAssertR(!BaseUrlStr.Empty(), "");
156    PUrl Url=TUrl::New(BaseUrlStr); EAssertR(Url->IsOk(), "");
157    EAssertR(IsAbs(BaseUrlStr), "");
158    TStr AbsUrlStr=BaseUrlStr;
159    TStr NrRelUrlStr=RelUrlStr;
160    if (NrRelUrlStr.GetLc().IsPrefix(UrlHttpPrefixStr)){
161      NrRelUrlStr.DelSubStr(0, UrlHttpPrefixStr.Len()-1);}
162    if (NrRelUrlStr.Len()>0){
163      if (NrRelUrlStr[0]=='/'){
164        TStr SlashStr; int SlashChN=0;
165        while ((SlashChN<NrRelUrlStr.Len())&&(NrRelUrlStr[SlashChN]=='/')){
166          SlashChN++; SlashStr+="/";}
167        int ChN=0; bool Found=false;
168        while ((!Found)&&((ChN=AbsUrlStr.SearchStr(SlashStr, ChN))!=-1)){
169          TStr Str=AbsUrlStr.GetSubStr(ChN-1, ChN+SlashStr.Len()-1+1);
170          Found=((ChN==0)||(Str[0]!='/'))&&
171           ((ChN+SlashStr.Len()-1==AbsUrlStr.Len()-1)||(Str[Str.Len()-1]!='/'));
172          if (!Found){ChN++;}
173        }
174        if (Found){
175          AbsUrlStr.DelSubStr(ChN, AbsUrlStr.Len()-1);
176          AbsUrlStr+=NrRelUrlStr;
177        }
178      } else {
179        int ChN=AbsUrlStr.Len()-1;
180        while ((ChN>=0)&&(AbsUrlStr[ChN]!='/')){ChN--;}
181        AbsUrlStr.DelSubStr(ChN+1, AbsUrlStr.Len()-1);
182        AbsUrlStr+=NrRelUrlStr;
183      }
184    }
185    const char *PrevDirStr="/../";
186    {int ChN;
187    while ((ChN=AbsUrlStr.SearchStr(PrevDirStr))!=-1){
188      int BChN=ChN; int EChN=ChN+(int) strlen(PrevDirStr)-1;
189      while ((BChN-1>=0)&&(AbsUrlStr[BChN-1]!='/')){BChN--;}
190      AbsUrlStr.DelSubStr(BChN, EChN);
191    }}
192    const char *CurDirStr="/.";
193    while (AbsUrlStr.DelStr(CurDirStr)){}
194    GetAbs(AbsUrlStr);
195  }
196  TUrl::TUrl(const TStr& _RelUrlStr, const TStr& _BaseUrlStr):
197    Scheme(usUndef),
198    UrlStr(), RelUrlStr(_RelUrlStr), BaseUrlStr(_BaseUrlStr),
199    SchemeNm(), HostNm(),
200    PortStr(), PathStr(), SearchStr(), FragIdStr(),
201    PortN(-1), PathSegV(),
202    IpNum(),
203    FinalUrlStr(), FinalHostNm(),
204    HttpRqStr(){
205    RelUrlStr.ToTrunc();
206    RelUrlStr.ChangeStrAll(" ", "%20");
207    try {
<span onclick='openModal()' class='match'>208      if (IsAbs(RelUrlStr)){
209        GetAbs(RelUrlStr);
210      } else
211      if (IsAbs(BaseUrlStr)){
212        GetAbsFromBase(RelUrlStr, BaseUrlStr);
213      } else {
</span>214        Scheme=usUndef;
215      }
216    }
217    catch (PExcept&){Scheme=usUndef;}
218    /&bsol;** old version
219  }
220  TStr TUrl::GetDmNm(const int& MxDmSegs) const {
221    EAssert(IsOk());
222    TChA DmChA; int DmSegs=0;
223    for (int ChN=HostNm.Len()-1; ChN>=0; ChN--){
224      if (HostNm[ChN]=='.'){
225        DmSegs++;
226        if (DmSegs==MxDmSegs){break;} else {DmChA+='.';}
227      } else {
228        DmChA+=HostNm[ChN];
229      }
230    }
231    DmChA.Reverse();
232    return DmChA;
233  }
234  void TUrl::DefFinalUrl(const TStr& _FinalHostNm){
235    EAssert(IsOk(usHttp));
236    EAssert(!IsDefFinalUrl());
237    FinalHostNm=_FinalHostNm.GetLc();
238    if (HostNm==FinalHostNm){
239      FinalUrlStr=UrlStr;
240    } else {
241      TChA FinalUrlChA;
242      FinalUrlChA+=SchemeNm; FinalUrlChA+=":&bsol;&bsol;";
243      FinalUrlChA+=FinalHostNm;
244      if (!PortStr.Empty()){
245        FinalUrlChA+=":"; FinalUrlChA+=PortStr;}
246      FinalUrlChA+=PathStr;
247      FinalUrlChA+=SearchStr;
248      FinalUrlStr=FinalUrlChA;
249    }
250  }
251  void TUrl::ToLcPath(){
252    if (!PathStr.IsLc()){
253      PathStr.ToLc();
254      for (int PathSegN=0; PathSegN<PathSegV.Len(); PathSegN++){
255        PathSegV[PathSegN].ToLc();}
256      TChA UrlChA;
257      UrlChA+=SchemeNm; UrlChA+=":&bsol;&bsol;";
258      UrlChA+=HostNm;
259      if (!PortStr.Empty()){
260        UrlChA+=":"; UrlChA+=PortStr;}
261      UrlChA+=PathStr;
262      UrlChA+=SearchStr;
263      UrlStr=UrlChA;
264      if (IsDefFinalUrl()){
265        FinalUrlStr.Clr(); DefFinalUrl(FinalHostNm);}
266    }
267  }
268  bool TUrl::IsAbs(const TStr& UrlStr){
269    if (UrlStr.GetLc().IsPrefix(UrlHttpPrefixStr)){
270      return UrlStr.GetLc().IsPrefix(UrlHttpAbsPrefixStr);
271    } else {
272      int ColonChN=UrlStr.SearchCh(':'); int SlashChN=UrlStr.SearchCh('/');
273      return (ColonChN!=-1)&&((SlashChN==-1)||((SlashChN!=-1)&&(ColonChN<SlashChN)));
274    }
275  }
276  bool TUrl::IsScript(const TStr& UrlStr){
277    return UrlStr.IsChIn('?');
278  }
279  bool TUrl::IsSite(const TStr& UrlStr){
280    PUrl Url=TUrl::New(UrlStr);
281    return Url->IsOk(usHttp) && (Url->GetPathStr()=="/") &&
282     Url->GetSearchStr().Empty() && Url->GetFragIdStr().Empty();
283  }
284  PUrl TUrl::GetUrlFromShortcut(const TStr& ShortcutUrlStr,
285   const TStr& DfHostNmPrefix, const TStr& DfHostNmSufix){
286    TStr UrlStr=ShortcutUrlStr;
287    PUrl Url=TUrl::New(UrlStr);
288    if (Url->IsOk()){return Url;}
289    if (ShortcutUrlStr.IsChIn('.')){
290      UrlStr=TUrl::UrlHttpAbsPrefixStr+ShortcutUrlStr;
291      Url=TUrl::New(UrlStr);
292      if (Url->IsOk()){return Url;}
293    }
294    if (ShortcutUrlStr.IsChIn('.')){
295      UrlStr=TUrl::UrlHttpAbsPrefixStr+ShortcutUrlStr+"/";
296      Url=TUrl::New(UrlStr);
297      if (Url->IsOk()){return Url;}
298    }
299    UrlStr=UrlHttpAbsPrefixStr+
300     DfHostNmPrefix+"."+ShortcutUrlStr+"."+DfHostNmSufix+"/";
301    Url=TUrl::New(UrlStr);
302    return Url;
303  }
304  TStr TUrl::GetUrlSearchStr(const TStr& Str){
305    TChA InChA=Str; TChA OutChA;
306    for (int ChN=0; ChN<InChA.Len(); ChN++){
307      char Ch=InChA[ChN];
308      if (Ch==' '){
309        OutChA+='+';
310      } else
311      if ((' '<Ch)&&(Ch<='~')&&(Ch!='+')&&(Ch!='&')&&(Ch!='%')){
312        OutChA+=Ch;
313      } else {
314        OutChA+='%';
315        OutChA+=TInt::GetHexStr(uchar(Ch)/16);
316        OutChA+=TInt::GetHexStr(uchar(Ch)%16);
317      }
318    }
319    return OutChA;
320  }
321  TStr TUrl::DecodeUrlStr(const TStr& UrlStr) {
322    TChA InChA=UrlStr; TChA OutChA;
323    for (int ChN=0; ChN<InChA.Len(); ChN++){
324      char Ch=InChA[ChN];
325      if (Ch=='+'){
326        OutChA+=' ';
327      } else if (Ch=='%') {
328        ChN++; if (ChN==InChA.Len()) { break; }
329        char FirstCh = InChA[ChN];
330        if (!TCh::IsHex(FirstCh)) { break; }
331        ChN++; if (ChN==InChA.Len()) { break; }
332        char SecondCh = InChA[ChN];
333        if (!TCh::IsHex(SecondCh)) { break; }
334        OutChA+=char(TCh::GetHex(FirstCh)*16 + TCh::GetHex(SecondCh));
335      } else {
336        OutChA+=Ch;
337      }
338    }
339    return OutChA;
340  }
341  TStr TUrl::GetDocStrFromUrlStr(const TStr& UrlStr, const int& Copies){
342    TStrV StrV; UrlStr.SplitOnNonAlNum(StrV);
343    TChA DocChA;
344    for (int StrN=0; StrN<StrV.Len(); StrN++){
345      TStr UcStr=StrV[StrN].GetUc();
346      if ((UcStr.Len()>3)&&(UcStr!="HTTP")&&(UcStr!="HTML")&&(UcStr!="INDEX")&&(UcStr!="DEFAULT")){
347        for (int CopyN=0; CopyN<Copies; CopyN++){
348          if (!DocChA.Empty()){DocChA+=' ';} DocChA+=StrV[StrN];
349        }
350      }
351    }
352    return DocChA;
353  }
354  TStr TUrl::GetTopDownDocNm(
355   const TStr& UrlStr, const int& MxLen, const bool& HostOnlyP){
356    PUrl Url=TUrl::New(UrlStr);
357    TChA DocNm;
358    if (Url->IsOk()){
359      TStr HostNm=Url->GetHostNm().GetLc();
360      TStrV HostNmSegV; HostNm.SplitOnAllCh('.', HostNmSegV, false);
361      for (int HostNmSegN=0; HostNmSegN<HostNmSegV.Len(); HostNmSegN++){
362        if (HostNmSegN>0){DocNm+='.';}
363        DocNm+=HostNmSegV[HostNmSegV.Len()-HostNmSegN-1];
364      }
365      if (!HostOnlyP){
366        DocNm+=Url->GetPathStr().GetLc();
367      }
368    } else {
369      DocNm=UrlStr.GetLc();
370    }
371    if (MxLen!=-1){
372      DocNm.Trunc(MxLen);}
373    return DocNm;
374  }
375  TStr TUrlEnv::GetFullUrlStr() const {
376    if (GetKeys()==0){return TStr();}
377    TChA SearchChA;
378    SearchChA+=BaseUrlStr;
379    SearchChA+="?";
380    int KeyVals=0;
381    for (int KeyN=0; KeyN<GetKeys(); KeyN++){
382      TStr KeyNm=GetKeyNm(KeyN);
383      TStrV ValStrV=KeyNmToValH.GetDat(KeyNm);
384      for (int ValStrN=0; ValStrN<ValStrV.Len(); ValStrN++){
385        if (KeyVals>0){SearchChA+="&";}
386        SearchChA+=TUrl::GetUrlSearchStr(KeyNm);
387        SearchChA+='=';
388        SearchChA+=TUrl::GetUrlSearchStr(ValStrV[ValStrN]);
389        KeyVals++;
390      }
391    }
392    return SearchChA;
393  }
394  PUrlEnv TUrlEnv::MkClone(const PUrlEnv& UrlEnv){
395    PUrlEnv CloneUrlEnv=
396     PUrlEnv(new TUrlEnv(*UrlEnv));
397    return CloneUrlEnv;
398  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-appsrv.cpp</h3>
            <pre><code>1  TStr TAppCS::A_Result="Result";
2  TStr TAppCS::A_Msg="Msg";
3  TStr TAppCS::A_MsgType="MsgType";
4  TStr TAppCS::A_Continue="Continue";
5  TStr TAppCS::A_Browse="Browse";
6  TStr TAppCS::A_SesId="SesId";
7  TStr TAppCS::A_FetchId="FetchId";
8  TStr TAppCS::A_Redir="Redir";
9  TStr TAppCS::A_Agent="Agent";
10  TStr TAppCS::A_HostNm="HostNm";
11  TStr TAppCS::A_PortN="PortN";
12  TStr TAppCS::A_UsrNm="UsrNm";
13  TStr TAppCS::A_PwdStr="PwdStr";
14  TStr TAppCS::A_PrivNm="PrivNm";
15  TStr TAppCS::A_PrivId="PrivId";
16  TStr TAppCS::A_CltNm="CltNm";
17  TStr TAppCS::A_CltType="CltType";
18  TStr TAppCS::A_State="State";
19  TStr TAppCS::A_PrevState="PrevState";
20  TStr TAppCS::A_OldState="OldState";
21  TStr TAppCS::A_NewState="NewState";
22  TStr TAppCS::A_AbortState="AbortState";
23  TStr TAppCS::A_SetStateTm="SetStateTm";
24  TStr TAppCS::A_LogNm="LogNm";
25  TStr TAppCS::F_Info="Info";
26  TStr TAppCS::F_GetStateInfo="GetStateInfo";
27  TStr TAppCS::F_GetCltList="GetCltList";
28  TStr TAppCS::F_GetCltInfo="GetCltInfo";
29  TStr TAppCS::F_GetCltDesc="GetCltDesc";
30  TStr TAppCS::F_IsAlive="IsAlive";
31  TStr TAppCS::F_IsConn="IsConn";
32  TStr TAppCS::F_Log="Log";
33  TStr TAppCS::F_Connect="Connect";
34  TStr TAppCS::F_Disconnect="Disconnect";
35  TStr TAppCS::F_DelayTimer="DelayTimer";
36  TStr TAppCS::F_RegAgent="RegAgent";
37  TStr TAppCS::F_Confirm="Confirm";
38  TStr TAppCS::F_Cancel="Cancel";
39  TStr TAppCS::F_Notify="Notify";
40  TStr TAppCS::F_NotifyStateChange="NotifyStateChange";
41  TStr TAppCS::F_Abort="Abort";
42  TStr TAppCS::F_HBeatTimer="HBeatTimer";
43  TStr TAppCS::TmA_TimerId="TimerId";
44  TStr TAppCS::TmA_CtxNm="CtxNm";
45  TStr TAppCS::TmA_Ticks="Ticks";
46  TStr TAppCS::F_Broadcast="Broadcast";
47  TStr TAppCS::BcA_Cm="Cm";
48  TStr TAppCS::BcA_FldNm="FldNm";
49  TStr TAppCS::BcA_FldVal="FldVal";
50  TStr TAppCS::BcA_Msg="Msg";
51  TStr TAppCS::F_NotifyEvent="Log::NotifyEvent";
52  TStr TAppCS::F_NotifyRawEvent="Log::NotifyRawEvent";
53  TStr TAppCS::LogA_EventTypeNm="EventTypeNm";
54  TStr TAppCS::LogA_TestMode="TestMode";
55  TStr TAppCS::LogA_CreatorNm="CreatorNm";
56  TStr TAppCS::LogA_CreatorTime="CreatorTime";
57  int TAppCS::DTmrA_DelayTimerTout=2*1000;
58  TStr TAppCS::S_Start="Start";
59  TStr TAppCS::S_End="End";
60  TStr TAppCS::S_ConnectRq="ConnectRq";
61  TStr TAppCS::S_ConnectResp="ConnectResp";
62  TStr TAppCS::S_Connected="Connected";
63  TStr TAppCS::S_Server="Server";
64  TAppCSLog::TAppCSLog(
65  const TStr& _LogFNm, const int64& _MxFLen, const PNotify& _Notify):
66    Notify(_Notify),
67    LogFNm(_LogFNm), LogSOut(), fLog(NULL), MxFLen(_MxFLen){
68    if (LogFNm.Empty()){
69      TNotify::OnNotify(Notify, ntInfo, "Log-File Not Generated.");
70    } else {
71      if (LogFNm.GetFPath().Empty()){
72        LogFNm=GetHomeNrFPath()+LogFNm;}
73      if (false&&TFile::Exists(LogFNm)){
74        LogSOut=TFOut::New(LogFNm, true); fLog=LogSOut->GetFileId();
75        TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" opened.");
76      } else {
77        LogSOut=TFOut::New(LogFNm); fLog=LogSOut->GetFileId();
78        TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" created.");
79      }
80      PutLogHd();
81    }
82  }
83  void TAppCSLog::ResetLogIfTooBig(){
84    if ((fLog!=NULL)&&(MxFLen!=-1)){
85      int64 FLen=ftell(fLog);
86      if (FLen>MxFLen){
87        LogSOut=NULL; 
88        try {
89          TStr OldLogFNm=LogFNm+".Old";
90          TFile::Del(OldLogFNm, false);
91          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+OldLogFNm+" deleted.");
92          TFile::Rename(LogFNm, OldLogFNm);
93          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" renamed.");
94          LogSOut=TFOut::New(LogFNm, true);
95          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" opened.");
96          PutLogHd();
97        } catch (PExcept Except){
98          TNotify::OnNotify(Notify, ntErr, Except->GetMsgStr());
99        }
100      }
101    }
102  }
103  void TAppCSLog::PutLogHd(){
104    TTm CurTm=TTm::GetCurUniTm();
105    if (fLog!=NULL){
106      fprintf(fLog, "#Software: Quintelligence Application-Web-Server 1.0\n");
107      fprintf(fLog, "#Version: 1.0\n");
108      fprintf(fLog, "#Date: %s %s\n",
109       CurTm.GetWebLogDateStr().CStr(), CurTm.GetWebLogTimeStr().CStr());
110      fprintf(fLog, "#Fields: date time c-ip cs-method cs-uri sc-status\n");
111      fflush(fLog);
112    }
113    ResetLogIfTooBig();
114  }
115  void TAppCSLog::PutLogRec(
116   const PHttpRq& HttpRq, const PHttpResp& HttpResp, const TStr& PeerHostNm){
117    TTm CurTm=TTm::GetCurUniTm();
118    if (fLog!=NULL){
119      fprintf(fLog, "%s %s %s %s %s %s\n",
120       CurTm.GetWebLogDateStr().CStr(),
121       CurTm.GetWebLogTimeStr().CStr(),
122       PeerHostNm.CStr(),
123       HttpRq->GetMethodNm().CStr(),
124       HttpRq->GetUrl()->GetUrlStr().CStr(),
125       TInt::GetStr(HttpResp->GetStatusCd()).CStr());
126      fflush(fLog);
127    }
128    TStr MsgStr=TStr("Http: ")+
129     PeerHostNm+" requested "+HttpRq->GetUrl()->GetUrlStr()+
130     " responding "+THttp::GetReasonPhrase(HttpResp->GetStatusCd())
131     +" ["+CurTm.GetStr()+"]";
132    TNotify::OnNotify(Notify, ntInfo, MsgStr);
133    ResetLogIfTooBig();
134  }
135  void TAppCSLog::PutLogMsg(const TStr& MsgType, const TStr& MsgStr){
136    TTm CurTm=TTm::GetCurUniTm();
137    if (fLog!=NULL){
138      fprintf(fLog, "#%s: %s\n",
139       MsgType.CStr(),
140       MsgStr.CStr());
141      fflush(fLog);
142    }
143    TNotify::OnNotify(
144     Notify, ntInfo, MsgType+": "+MsgStr&bsol;*+" ["+CurTm.GetStr()+"]"*/);
145    ResetLogIfTooBig();
146  }
147  void TAppCSLog::PutLogMsg(
148   const TStr& MsgType, const TStr& MsgStr, const TStr& MsgArg){
149    PutLogMsg(MsgType, MsgStr+" ("+MsgArg+").");
150  }
151  TAppCSTimer::TAppCSTimer(
152   const TStr& _TimerNm, const TStr& _CtxNm,
153   const int& TimerTout, const bool& _RepeatP, TWebNetSrv* _WebNetSrv):
154    TTTimer(TimerTout), WebNetSrv(_WebNetSrv),
155    TimerNm(_TimerNm), RepeatP(_RepeatP), CtxNm(_CtxNm){
156    IAssertR(TXmlLx::IsTagNm(TimerNm),
157     TStr("Timer-name is not XML-Tag-Name (")+TimerNm+").");
158  }
159  void TAppCSTimer::OnTimeOut(){
160    if (!RepeatP){
161      StopTimer();}
162    PSoapRq SoapRq=TSoapRq::New(TimerNm,
163     TAppCS::TmA_TimerId, TInt::GetStr(GetTimerId()),
164     TAppCS::TmA_CtxNm, CtxNm,
165     TAppCS::TmA_Ticks, TInt::GetStr(GetTicks()));
166    PUrl Url=SoapRq->GetAsUrl("localhost");
167    PHttpRq HttpRq=THttpRq::New(Url);
168    WebNetSrv->OnHttpRq(-1, HttpRq);
169  }
170  TAppCSState::TAppCSState(const PAppCSLog& _Log):
171    StateId(), Log(_Log){
172    PrepState();
173  }
174  void TAppCSState::PrepState(){
175    SoapEnv=TSoapEnv::New();
176    SetState(TAppCS::S_Start);
177  }
178  void TAppCSState::SetState(const TStr& _StateId){
179    TStr PrevStateId=StateId;
180    StateId=_StateId;
181    if (!Log.Empty()){
182      Log->PutLogMsg("SetState", "From '"+PrevStateId+"' to '"+StateId+"'");
183    }
184  }
185  TAppSrv::TAppSrv(
186   const int& PortN, const TStr& LogFNm, const int& HBeatTimerTout,
187   const PNotify& Notify):
188    TWebNetSrv(PortN, true), 
189    TWebNetCltV(), 
190    Log(TAppCSLog::New(LogFNm, -1, Notify)), 
191    SesIdToCltDescH(), 
192    CltNmToSesIdH(), 
193    HBeatTimer(), 
194    ActConnBs(TAppCSActConnBs::New()), 
195    NmToLogH(),
196    Proxy(new TWebNetProxy(PortN+11,TStr("http:&bsol;&bsol;127.0.0.1:")+TInt::GetStr(PortN))) {
197    HBeatTimer=TAppCSTimer::New(TAppCS::F_HBeatTimer,
198     "Srv", HBeatTimerTout, true, this);
199  }
200  TAppSrv::~TAppSrv(){
201    HBeatTimer->StopTimer();
202  }
203  bool TAppSrv::IsLogSoapFuncNm(const TStr& SoapFuncNm){
204    return
205     (!SoapFuncNm.IsPrefix(TAppCS::F_Log))&&
206     (SoapFuncNm!=TAppCS::F_HBeatTimer)&&
207     (SoapFuncNm!=TAppCS::F_IsAlive);
208  }
209  TStr TAppSrv::GetNewSesId(){
210    TStr SesId;
211    do {
212      SesId=TTm::GetCurUniTm().GetIdStr();
213    } while (SesIdToCltDescH.IsKey(SesId));
214    return SesId;
215  }
216  bool TAppSrv::IsGetCltDescBySesId(
217   const TStr& SesId, PAppCltDesc& CltDesc) const {
218    return SesIdToCltDescH.IsKeyGetDat(SesId, CltDesc);
219  }
220  bool TAppSrv::IsGetCltDescBySockId(
221   const int& SockId, PAppCltDesc& CltDesc) const {
222    int SesIdToCltDescP=SesIdToCltDescH.FFirstKeyId();
223    while (SesIdToCltDescH.FNextKeyId(SesIdToCltDescP)){
224      CltDesc=SesIdToCltDescH[SesIdToCltDescP];
225      if (CltDesc->SockId==SockId){
226        return true;}
227    }
228    CltDesc=NULL;
229    return false;
230  }
231  bool TAppSrv::IsGetCltDescByCltNm(
232   const TStr& CltNm, PAppCltDesc& CltDesc) const {
233    TStr SesId;
234    if (CltNmToSesIdH.IsKeyGetDat(CltNm, SesId)){
235      return IsGetCltDescBySesId(SesId, CltDesc);
236    } else {
237      return false;
238    }
239  }
240  PAppCltDesc TAppSrv::AddNewCltDesc(
241   const TStr& HostNm, const int& PortN, const int& SockId,
242   const TStr& CltNm, const TStr& CltType){
243    TStr SesId=GetNewSesId();
244    PAppCltDesc CltDesc=TAppCltDesc::New(SesId, HostNm, PortN);
245    CltDesc->SockId=SockId;
246    CltDesc->CltNm=CltNm;
247    CltDesc->CltType=CltType;
248    SesIdToCltDescH.AddDat(SesId, CltDesc);
249    TStr PrevSesId;
250    if (CltNmToSesIdH.IsKeyGetDat(CltNm, PrevSesId)){
251      DelIfCltDesc(PrevSesId);}
252    CltNmToSesIdH.AddDat(CltNm, SesId);
253    CltDesc->CltType=CltType;
254    return CltDesc;
255  }
256  void TAppSrv::DelIfCltDesc(const TStr& SesId){
257    PAppCltDesc CltDesc; TStr CltNm;
258    if (IsGetCltDescBySesId(SesId, CltDesc)){
259      CltNm=CltDesc->CltNm;
260      CltNmToSesIdH.DelIfKey(CltDesc->CltNm);
261    }
262    SesIdToCltDescH.DelIfKey(SesId);
263    Log->PutLogMsg("Info",
264     TStr::Fmt("Delete client '%s' with session '%s'.", CltNm.CStr(), SesId.CStr()));
265  }
266  void TAppSrv::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
267    TTm CurTm=TTm::GetCurUniTm(); 
268    TStr FetchIdStr=HttpRq->GetFldVal(THttp::FetchIdFldNm); 
269    PUrl Url=HttpRq->GetUrl(); 
270    TStr UrlStr=Url->GetUrlStr(); 
271    TStr PeerHostNm=GetPeerHostNm(SockId); 
272    PSoapRq SoapRq=TSoapRq::New(HttpRq); 
273    TStr SoapFuncNm=SoapRq->GetFuncNm();
274    TStr SoapRqMsgStr=UrlStr+" from "+PeerHostNm; 
275    if (IsLogSoapFuncNm(SoapFuncNm)){
276      Log->PutLogMsg("SoapRequest", SoapRqMsgStr);}
277    PHttpResp HttpResp;
278    if (SoapRq->IsOk()){
279      if (SoapFuncNm==TAppCS::F_Info){
280        HttpResp=OnHttpRq_Info();
281      } else
282      if (SoapFuncNm==TAppCS::F_GetCltList){
283        HttpResp=OnHttpRq_GetCltList(SoapRq);
284      } else
285      if ((SoapFuncNm==TAppCS::F_GetCltInfo)||(SoapFuncNm==TAppCS::F_GetCltDesc)){
286        HttpResp=OnHttpRq_GetCltInfo(SoapRq);
287      } else
288      if (SoapFuncNm==TAppCS::F_Connect){
289        HttpResp=OnHttpRq_Connect(SoapRq, PeerHostNm, SockId);
290      } else
291      if (SoapFuncNm==TAppCS::F_Disconnect){
292        HttpResp=OnHttpRq_Disconnect(SoapRq, PeerHostNm);
293      } else
294      if (SoapFuncNm==TAppCS::F_Log){
295        HttpResp=OnHttpRq_OnLog(SoapRq);
296      } else
297      if (SoapFuncNm==TAppCS::F_HBeatTimer){
298        OnHttpRq_OnHBeatTimer();
299      } else
300      if (IsCltOk(SoapRq, PeerHostNm)){
301        if (SoapFuncNm==TAppCS::F_IsAlive){
302          HttpResp=TSoapResp::GetHttpResp(TAppCS::F_IsAlive);
303        } else
304        if (SoapFuncNm==TAppCS::F_Broadcast){
305          HttpResp=OnHttpRq_Broadcast(SoapRq);
306        } else {
307          HttpResp=OnFuncRq(SockId, SoapRq, Url);
308        }
309      } else {
310        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
311         "Client admin info mismatch.");
312      }
313    } else {
314      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::DataEncodingUnknownCodeNm,
315       "Invalid SOAP HTTP Request.");
316    }
317    if (SockId!=-1){
318      if (HttpResp.Empty()){
319        Log->PutLogMsg("Warning", TStr("Empty Http-Response for ")+SoapRqMsgStr);
320        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, "Empty Response.");
321      }
322      if (!FetchIdStr.Empty()){
323        HttpResp->AddFldVal(THttp::FetchIdFldNm, FetchIdStr);}
324      SendHttpResp(SockId, HttpResp);
325      if (IsLogSoapFuncNm(SoapFuncNm)){
326        Log->PutLogRec(HttpRq, HttpResp, PeerHostNm);
327        PSoapResp SoapResp=TSoapResp::New(HttpResp);
328        if (SoapResp->IsOk()){
329          Log->PutLogMsg("SoapResponse", SoapResp->GetAsUrlPathStr());
330        }
331      }
332    }
333  }
334  void TAppSrv::OnHttpRqError(const int& SockId, const TStr& MsgStr){
335    Log->PutLogMsg("HttpRqError", MsgStr);
336    PAppCltDesc CltDesc;
337    if (IsGetCltDescBySockId(SockId, CltDesc)){
338      DelIfCltDesc(CltDesc->SesId);
339    }
340  }
341  TStr TAppSrv::GetPeerHostNm(const int& SockId) const {
342    if (SockId==-1){
343      return "internal";
344    } else {
345      TStr PeerHostNm=GetCltSock(SockId)->GetPeerIpNum();
346  #if 0
347      if ((PeerHostNm.GetLc()=="localhost")||(PeerHostNm=="127.0.0.1")){
348        PSockHost LocalSockHost=TSockHost::GetLocalSockHost();
349        if (LocalSockHost->IsOk()){
350          return LocalSockHost->GetIpNum();
351        }
352      }
353  #else
354      if (PeerHostNm.GetLc()=="localhost") PeerHostNm="127.0.0.1";
355  #endif
356      return PeerHostNm;
357    }
358  }
359  void TAppSrv::ResolveCltIP(const PAppCltDesc CltDesc, int SockId, TStr &DestHost, TStr &DestProxy) {
360    static const TStr LoopbackIP("127.0.0.1");
361    static const TStr LocalhostNm("localhost");
362    if (SockId==-1) {
363      DestHost=LoopbackIP;
364    } else {
365      PSockHost Localhost=TSockHost::GetLocalSockHost();
366      PSock Sock=GetCltSock(SockId);
367      TStr PeerIP=Sock->GetPeerIpNum();
368      TStr AdapterIP=Sock->GetLocalIpNum();
369      TStr CltHostNm = CltDesc->HostNm;
370      bool LocalPeerP = (Localhost->HasIpNum(PeerIP)||(PeerIP==LoopbackIP)||(PeerIP==LocalhostNm));
371      bool LocalRedirP = (Localhost->HasIpNum(CltHostNm)||(CltHostNm==LoopbackIP)||(CltHostNm==LocalhostNm));
372      if (LocalRedirP) { 
373        DestHost=LocalPeerP?LoopbackIP:AdapterIP;
374        IAssert(LocalPeerP||(AdapterIP!=LoopbackIP));
375      } else { 
376        DestHost=CltHostNm;
377        if (!LocalPeerP) {
378          unsigned long PeerAddr = ntohl(inet_addr(PeerIP.CStr()));
379          unsigned long DestAddr = ntohl(inet_addr(DestHost.CStr()));
380          if (((PeerAddr^DestAddr) & 0xFFFFFF00) != 0) {
381            DestProxy=AdapterIP;
382          }
383        }
384      }
385    }
386  }
387  bool TAppSrv::IsCltOk(const PSoapRq& SoapRq, const TStr& PeerHostNm) const {
388    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
389    PAppCltDesc CltDesc;
390    if (IsGetCltDescBySesId(SesId, CltDesc)){
391  #if 0
392      if (PeerHostNm==CltDesc->HostNm) {
393        return true;
394      }
395  #else
396      return true;
397  #endif
398    }
399    return false;
400  }
401  PHttpResp TAppSrv::OnHttpRq_Info() const {
402    TTm CurTm=TTm::GetCurUniTm();
403    TChA HtmlChA;
404    HtmlChA+="<html><head><title>Application Server Status</title></head>";
405    HtmlChA+="<body>";
406    HtmlChA+="<h1>Application Server Status</h1>";
407    HtmlChA+="GMT-Time: ";
408    HtmlChA+=CurTm.GetWebLogDateStr()+" "+CurTm.GetWebLogTimeStr();
409    HtmlChA+="<br>";
410    HtmlChA+="Active Clients: "; HtmlChA+=TInt::GetStr(GetClts());
411    HtmlChA+="<br>";
412    HtmlChA+="Server Port: ";
413    HtmlChA+=TInt::GetStr(GetPortN());
414    HtmlChA+="<br>";
415    HtmlChA+="Server Up-Time (secs): ";
416    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetSecs());
417    HtmlChA+="<br>";
418    HtmlChA+="Log-File-Name: ";
419    HtmlChA+=GetLog()->GetLogFNm();
420    HtmlChA+="<br>";
421    HtmlChA+="Heart-Beat-TimeOut (msecs): ";
422    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTimeOut());
423    HtmlChA+="<br>";
424    HtmlChA+="Heart-Beat-Ticks: ";
425    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTicks());
426    HtmlChA+="<br>";
427    HtmlChA+="</body>";
428    HtmlChA+="</html>";
429    PHttpResp HttpResp=THttpResp::New(
430     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, TStrIn::New(HtmlChA));
431    return HttpResp;
432  }
433  PHttpResp TAppSrv::OnHttpRq_GetCltList(const PSoapRq& SoapRq){
434    PSoapResp SoapResp=TSoapResp::New(SoapRq->GetFuncNm());
435    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
436    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
437      PAppCltDesc CltDesc=CltDescV[CltDescN];
438      if (!CltDesc->CltNm.Empty()){
439        SoapResp->AddFldNmVal(CltDesc->CltNm,
440         CltDesc->HostNm+"/"+TInt::GetStr(CltDesc->PortN));
441      }
442    }
443    return SoapResp->GetHttpResp();
444  }
445  PHttpResp TAppSrv::OnHttpRq_GetCltInfo(const PSoapRq& SoapRq){
446    PHttpResp HttpResp;
447    TStr CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
448    PAppCltDesc CltDesc;
449    if (IsGetCltDescByCltNm(CltNm, CltDesc)){
450      HttpResp=TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
451       TAppCS::A_Result, "T",
452       TAppCS::A_HostNm, CltDesc->HostNm,
453       TAppCS::A_PortN, TInt::GetStr(CltDesc->PortN),
454       TAppCS::A_CltNm, CltDesc->CltNm,
455       TAppCS::A_CltType, CltDesc->CltType);
456    } else {
457      HttpResp=TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
458       TAppCS::A_Result, "F",
459       TAppCS::A_Msg, TStr::Fmt("Client '%s' not registered.", CltNm.CStr()));
460    }
461    return HttpResp;
462  }
463  PHttpResp TAppSrv::OnHttpRq_Connect(
464   const PSoapRq& SoapRq, const TStr& PeerHostNm, const int& SockId){
465    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Connect);
466    int CltPortN=SoapRq->GetFldVal(TAppCS::A_PortN).GetInt(-1);
467    if (CltPortN==-1){
468      return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
469       "Port parameter missing in Login function call.");
470    } else {
471      TStr CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
472      TStr CltType=SoapRq->GetFldVal(TAppCS::A_CltType);
473      if (!IsCltByCltNm(CltNm)){
474        PAppCltDesc CltDesc=AddNewCltDesc(PeerHostNm, CltPortN, SockId, CltNm, CltType);
475        return TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
476         TAppCS::A_SesId, CltDesc->SesId);
477      } else {
478        return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
479         TStr::Fmt("Client '%s' already registered.", CltNm.CStr()));
480      }
481    }
482  }
483  PHttpResp TAppSrv::OnHttpRq_Disconnect( 
484   const PSoapRq& SoapRq, const TStr& PeerHostNm){
485    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Disconnect);
486    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId); PAppCltDesc CltDesc;
487    if (!SesId.Empty()&&IsGetCltDescBySesId(SesId, CltDesc)){
488      DelIfCltDesc(CltDesc->SesId);
489      return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
490    } else {
491      return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
492       "Invalid disconnect request.");
493    }
494  }
495  PHttpResp TAppSrv::OnHttpRq_OnLog(const PSoapRq& SoapRq){
496    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Log);
497    PAppCSLog CltLog;
498    TStr LogNm=SoapRq->GetFldVal(TAppCS::A_LogNm);
499    if (!NmToLogH.IsKeyGetDat(LogNm, CltLog)){
500      CltLog=TAppCSLog::New(LogNm+".Log", -1, NULL);
501      NmToLogH.AddDat(LogNm, CltLog);
502    }
503    TStr MsgTypeNm=SoapRq->GetFldVal(TAppCS::A_MsgType);
504    TStr MsgStr=SoapRq->GetFldVal(TAppCS::A_Msg);
505    CltLog->PutLogMsg(MsgTypeNm, MsgStr);
506    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
507  }
508  void TAppSrv::OnHttpRq_OnHBeatTimer(){
509    TTm CurTm=TTm::GetCurUniTm();
510    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
511    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
512      PAppCltDesc CltDesc=CltDescV[CltDescN];
513      TTm LastHBeatTm=CltDesc->LastHBeatTm;
514      if (TTm::GetDiffMSecs(CurTm, LastHBeatTm)>HBeatTimer->GetTimeOut()){
515        if (CltDesc->ActiveHBeatRqP){
516          DelIfCltDesc(CltDesc->SesId);
517        } else {
518          CltDesc->ActiveHBeatRqP=true;
519          FetchSoapRq(CltDesc, TSoapRq::New(TAppCS::F_IsAlive));
520        }
521      }
522    }
523  }
524  PHttpResp TAppSrv::OnHttpRq_Broadcast(const PSoapRq& SoapRq){
525    IAssert(SoapRq->GetFuncNm()=="Broadcast");
526    TStr BcCmNm=SoapRq->GetFldVal("Cm");
527    TStr BcFldNm=SoapRq->GetFldVal("FldNm");
528    TStr BcFldVal=SoapRq->GetFldVal("FldVal");
529    TStr BcMsgStr=SoapRq->GetFldVal("Msg");
530    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
531    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
532      PAppCltDesc CltDesc=CltDescV[CltDescN];
533      FetchSoapRq(CltDesc, TSoapRq::New("Broadcast",
534       "Cm", BcCmNm, "FldNm", BcFldNm, "FldVal", BcFldVal, "Msg", BcMsgStr));
535    }
536    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
537  }
538  PHttpResp TAppSrv::OnFuncRq(const int &SockId, const PSoapRq& SoapRq, const PUrl& Url){
539    TStr FuncNm=SoapRq->GetFuncNm();
540    TStr CltNm;
541    if (SoapRq->IsFldNm(TAppCS::A_CltNm)){
542      CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
543    }
544    if (CltNm.Empty()){
545      TStr _CltFuncNm; FuncNm.SplitOnStr(CltNm, "::", _CltFuncNm);
546    }
547    PHttpResp HttpResp;
548    if (!CltNm.Empty()){
549      PAppCltDesc CltDesc;
550      if (IsGetCltDescByCltNm(CltNm, CltDesc)){
551        {TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
552        PAppCltDesc SoapRqCltDesc;
553        if (IsGetCltDescBySesId(SesId, SoapRqCltDesc)){
554          SoapRq->AddFldNmVal(TAppCS::LogA_CreatorNm, SoapRqCltDesc->CltNm);
555        }}
556        SoapRq->AddFldNmVal(TAppCS::A_Redir, "T");
557  #if 0
558        TStr RedirUrlStr=TStr()+
559         "http:&bsol;&bsol;"+CltDesc->HostNm+":"+TInt::GetStr(CltDesc->PortN)+"/"+
560         SoapRq->GetAsUrlPathStr();
561        HttpResp=THttpResp::New(300, "", false, NULL, RedirUrlStr);
562  #else
563        TStr DestHost, DestProxy, RedirHost;
564        ResolveCltIP(CltDesc,SockId,DestHost,DestProxy);
565        DestHost += ":"+TInt::GetStr(CltDesc->PortN);
566        if (!DestProxy.Empty()) {
567          DestProxy += ":"+TInt::GetStr(Proxy->GetPortN());
568          RedirHost=DestProxy;
569        } else {
570          RedirHost=DestHost;
571        }
572        TStr RedirUrlStr=TStr()+"http:&bsol;&bsol;"+RedirHost+"/"+SoapRq->GetAsUrlPathStr();
573        Log->PutLogMsg("Redirect", TStr()+GetPeerHostNm(SockId)+" -> "+RedirUrlStr);
574        HttpResp=THttpResp::New(300, "", false, NULL, RedirUrlStr);
575        if (!DestProxy.Empty()) HttpResp->AddFldVal(THttp::HostFldNm,DestHost);
576  #endif
577      } else {
578        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
579         TStr()+"Client for function call not active: "+CltNm, FuncNm);
580      }
581    } else {
582      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
583       "Unknown SOAP function call", FuncNm);
584    }
585    return HttpResp;
586  }
587  int TAppSrv::FetchSoapRq(const PAppCltDesc& CltDesc, const PSoapRq& SoapRq){
588    SoapRq->AddFldNmVal(TAppCS::A_SesId, CltDesc->SesId);
589    PUrl SoapRqUrl=SoapRq->GetAsUrl(CltDesc->HostNm, CltDesc->PortN);
590    int FetchId=FetchUrl(SoapRqUrl);
591    ActConnBs->AddActConn(FetchId,
592     TAppCSActConn::New(SoapRq, CltDesc->HostNm, CltDesc->PortN,1));
593    Log->PutLogMsg("FetchSoapRq",
594     TInt::GetStr(FetchId, "[FetchId:%d]")+SoapRq->GetAsUrlPathStr());
595    return FetchId;
596  }
597  void TAppSrv::OnHttpResp(const int& FetchId, const PHttpResp& HttpResp){
598    PSoapResp SoapResp=TSoapResp::New(HttpResp);
599    if (SoapResp->IsOk()){
600      if (SoapResp->IsResult()){
601        TStr SoapRespFuncNm=SoapResp->GetFuncNm();
602        TStr SoapRespResultVal=SoapResp->GetFldVal(TAppCS::A_Result);
603        PSoapRq SoapRq=ActConnBs->GetActConn(FetchId)->GetSoapRq();
604        TStr SoapRqFuncNm=SoapRq->GetFuncNm();
605        IAssert(SoapRqFuncNm==SoapRespFuncNm);
606        ActConnBs->DelActConn(FetchId);
607        if (SoapRespFuncNm==TAppCS::F_IsAlive){
608          TStr SoapRqSesId=SoapRq->GetFldVal(TAppCS::A_SesId); 
609          TStr SoapRespSesId=SoapResp->GetFldVal(TAppCS::A_SesId); 
610          if (SoapRqSesId==SoapRespSesId){
611            PAppCltDesc CltDesc;
612            if (IsGetCltDescBySesId(SoapRespSesId, CltDesc)){ 
613              CltDesc->LastHBeatTm=TTm::GetCurUniTm(); 
614              CltDesc->ActiveHBeatRqP=false; 
615            }
616          } else {
617            Log->PutLogMsg("Warning",
618             "Session numbers (request & response) for IsAlive don't match.");
619          }
620        } else {
621          Log->PutLogMsg("Warning",
622           "Unhandled Soap-Response", SoapResp->GetAsUrlPathStr());
623        }
624      } else {
625        IAssert(SoapResp->IsFault());
626        OnHttpRespError(FetchId, TStr("SoapFault: ")+SoapResp->GetFaultReasonStr());
627      }
628    } else {
629      PSoapResp SoapResp=TSoapResp::New(HttpResp);
630      OnHttpRespError(FetchId, "Invalid SOAP Response");
631    }
632  }
633  void TAppSrv::OnHttpRespError(const int& FetchId, const TStr& MsgStr){
634    PSoapRq SoapRq=ActConnBs->GetActConn(FetchId)->GetSoapRq();
635    Log->PutLogMsg("Error", MsgStr, SoapRq->GetAsUrlPathStr());
636    ActConnBs->DelActConn(FetchId);
637    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
638    DelIfCltDesc(SesId);
639  }
640  const int TAppSrv::DfPortN=8888;
641  TAppClt::TAppClt(
642   const TStr& LogFNm,
643   const TStr& _CltNm,
644   const TStr& _CltType,
645   const int& HBeatTimerTout,
646   const bool& _AgentP,
647   const TStr& _SrvHostNm,
648   const int& _SrvPortN,
649   const int& CltPortN,
650   const PNotify& Notify):
651    TWebNetSrv(CltPortN, false), 
652    TWebNetCltV(), 
653    Log(TAppCSLog::New(LogFNm, -1, Notify)), 
654    CltNm(_CltNm), 
655    CltType(_CltType), 
656    SrvHostNm(_SrvHostNm), SrvPortN(_SrvPortN), 
657    AgentP(_AgentP), 
658    AgentHostNmPortNPrV(), 
659    HBeatTimer(), 
660    LastHBeatTm(TTm::GetCurUniTm()), 
661    ActiveIsAliveFId(-1), 
662    ActConnBs(TAppCSActConnBs::New()), 
663    SesId(), 
664    State(TAppCSState::New(Log)), 
665    DelayTimer(), 
666    FuncFetchIdH(){ 
667    HBeatTimer=TAppCSTimer::New(TAppCS::F_HBeatTimer,
668     CltNm, HBeatTimerTout, true, this);
669    DelayTimer=TAppCSTimer::New(TAppCS::F_DelayTimer, CltNm, 0, false, this);
670  }
671  TAppClt::~TAppClt(){
672    HBeatTimer->StopTimer();
673  }
674  const int TAppClt::DfPortN=TAppSrv::DfPortN+1;
675  void TAppClt::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
676    TTm CurTm=TTm::GetCurUniTm(); 
677    TStr FetchIdStr=HttpRq->GetFldVal(THttp::FetchIdFldNm);
678    PUrl Url=HttpRq->GetUrl(); 
679    TStr UrlStr=Url->GetUrlStr(); 
680    TStr PeerHostNm=GetPeerHostNm(SockId); 
681    PSoapRq SoapRq=TSoapRq::New(HttpRq); 
682    TStr SoapFuncNm=SoapRq->GetFuncNm();
683    TStr SoapRqMsgStr=UrlStr+" from "+PeerHostNm; 
684    if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
685      PutLogMsg("SoapRequest", SoapRqMsgStr, true);}
686    PHttpResp HttpResp;
687    if (SoapRq->IsOk()){
688      if (SoapFuncNm==TAppCS::F_Info){
689        HttpResp=OnHttpRq_Info();
690      } else
691      if (SoapFuncNm==TAppCS::F_GetStateInfo){
692        HttpResp=OnHttpRq_GetStateInfo(SoapRq);
693      } else
694      if (SoapFuncNm==TAppCS::F_HBeatTimer){
695        OnHttpRq_OnHBeatTimer();
696      } else
697      if ((SoapFuncNm==TAppCS::F_IsAlive)||(SoapFuncNm==TAppCS::F_IsConn)){
698        HttpResp=TSoapResp::GetHttpResp(SoapFuncNm, TAppCS::A_SesId, SesId);
699      } else
700      if (SoapFuncNm==TAppCS::F_RegAgent){
701        HttpResp=OnHttpRq_RegAgent(SoapRq, PeerHostNm);
702      } else {
703        bool RedirP=SoapRq->GetFldVal(TAppCS::A_Redir)=="T";
704        bool AgentP=SoapRq->GetFldVal(TAppCS::A_Agent)=="T";
705        if ((SockId!=-1)&&(!RedirP)&&(!AgentP)&&(!IsSesId())){
706          HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
707           "Session not defined.");
708        } else
709        if ((SockId!=-1)&&(!RedirP)&&(!AgentP)&&
710         (GetSesId()!=SoapRq->GetFldVal(TAppCS::A_SesId))){
711          TStr SesId1=GetSesId();
712          TStr SesId2=SoapRq->GetFldVal(TAppCS::A_SesId);
713          HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
714           "Session-ids don't match.");
715        } else {
716          HttpResp=OnFuncRq(SoapRq);
717        }
718      }
719    } else {
720      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::DataEncodingUnknownCodeNm,
721       "Invalid SOAP HTTP Request.");
722    }
723    if (SockId!=-1){
724      if (HttpResp.Empty()){
725        PutLogMsg("Warning", TStr("Empty Http-Response for ")+SoapRqMsgStr, true);
726        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, "Empty Response.");
727      }
728      if (!FetchIdStr.Empty()){
729        HttpResp->AddFldVal(THttp::FetchIdFldNm, FetchIdStr);}
730      SendHttpResp(SockId, HttpResp);
731      if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
732        Log->PutLogRec(HttpRq, HttpResp, PeerHostNm);
733        PSoapResp SoapResp=TSoapResp::New(HttpResp);
734        if (SoapResp->IsOk()){
735          PutLogMsg("SoapResponse", SoapResp->GetAsUrlPathStr(), true);
736        }
737      }
738    }
739  }
740  void TAppClt::OnHttpRqError(const int& SockId, const TStr& MsgStr){
741  }
742  TStr TAppClt::GetPeerHostNm(const int& SockId) const {
743    if (SockId==-1){
744      return "internal";
745    } else {
746      TStr PeerHostNm=GetCltSock(SockId)->GetPeerIpNum();
747      if ((PeerHostNm.GetLc()=="localhost")||(PeerHostNm=="127.0.0.1")){
748        PSockHost LocalSockHost=TSockHost::GetLocalSockHost();
749        if (LocalSockHost->IsOk()){
750          return LocalSockHost->GetIpNum();
751        } else {
752          return PeerHostNm;
753        }
754      } else {
755        return PeerHostNm;
756      }
757    }
758  }
759  PHttpResp TAppClt::OnHttpRq_Info() const {
760    TTm CurTm=TTm::GetCurUniTm();
761    TChA HtmlChA;
762    HtmlChA+="<html><head><title>Application Client Status</title></head>";
763    HtmlChA+="<body>";
764    HtmlChA+="<h1>Application Client Status</h1>";
765    HtmlChA+="GMT-Time: ";
766    HtmlChA+=CurTm.GetWebLogDateStr()+" "+CurTm.GetWebLogTimeStr();
767    HtmlChA+="<br>";
768    HtmlChA+="Client Port: ";
769    HtmlChA+=TInt::GetStr(GetPortN());
770    HtmlChA+="<br>";
771    HtmlChA+="Client Up-Time (secs): ";
772    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetSecs());
773    HtmlChA+="<br>";
774    HtmlChA+="Server-Host-Name: ";
775    HtmlChA+=GetSrvHostNm();
776    HtmlChA+="<br>";
777    HtmlChA+="Server-Host-Name: ";
778    HtmlChA+=TInt::GetStr(SrvPortN);
779    HtmlChA+="<br>";
780    HtmlChA+="Log-File-Name: ";
781    HtmlChA+=GetLog()->GetLogFNm();
782    HtmlChA+="<br>";
783    HtmlChA+="Heart-Beat-TimeOut (msecs): ";
784    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTimeOut());
785    HtmlChA+="<br>";
786    HtmlChA+="Heart-Beat-Ticks: ";
787    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTicks());
788    HtmlChA+="<br>";
789    HtmlChA+="</body>";
790    HtmlChA+="</html>";
791    PHttpResp HttpResp=THttpResp::New(
792     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, TStrIn::New(HtmlChA));
793    return HttpResp;
794  }
795  PHttpResp TAppClt::OnHttpRq_GetStateInfo(const PSoapRq& SoapRq) const {
796    PSoapResp SoapResp=TSoapResp::New(SoapRq->GetFuncNm());
797    SoapResp->AddFldNmVal("StateId", State->GetStateId());
798    return SoapResp->GetHttpResp();
799  }
800  void TAppClt::OnHttpRq_OnHBeatTimer(){
801    if (IsSesId()){
802      if (ActiveIsAliveFId==-1){
803        ActiveIsAliveFId=FetchSoapRq(TSoapRq::New(TAppCS::F_IsAlive));
804      }
805    }
806  }
807  PHttpResp TAppClt::OnHttpRq_RegAgent(
808   const PSoapRq& SoapRq, const TStr& PeerHostNm){
809    TStr AgentHostNm=PeerHostNm;
810    int AgentPortN=SoapRq->GetFldVal(TAppCS::A_PortN).GetInt(0);
811    AgentHostNmPortNPrV.AddUnique(TStrIntPr(AgentHostNm, AgentPortN));
812    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm(), TAppCS::A_Result, "T");
813  }
814  void TAppClt::OnHttpResp(const int& FetchId, const PHttpResp& HttpResp){
815    PAppCSActConn ActConn=ActConnBs->GetActConn(FetchId);
816    PSoapRq SoapRq=ActConn->GetSoapRq();
817    TStr SoapFuncNm=SoapRq->GetFuncNm();
818    PSoapResp SoapResp=TSoapResp::New(HttpResp);
819    ActConnBs->DelActConn(FetchId);
820    if (ActConn->GetRetryCnt()!=3) {
821      PutLogMsg("OnFetch",
822       TStr::Fmt("[FetchId:%d] %s", FetchId,
823        (TStr()+"SoapRq retry count="+TInt::GetStr(3-ActConn->GetRetryCnt())).CStr()), false);
824    }
825    if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
826      PutLogMsg("OnFetch",
827       TStr::Fmt("[FetchId:%d] %s", FetchId, SoapResp->GetAsUrlPathStr().CStr()), false);
828    }
829    if (!SoapResp->IsOk()){
830      PHttpResp HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
831       "Invalid SOAP Response format.");
832      SoapResp=TSoapResp::New(HttpResp);
833    }
834    if ((ActiveIsAliveFId!=-1)&&(FetchId==ActiveIsAliveFId)){
835      TStr SoapRespFuncNm=SoapResp->GetFuncNm();
836      if (SoapRespFuncNm==TAppCS::F_IsAlive){
837        LastHBeatTm=TTm::GetCurUniTm(); 
838        ActiveIsAliveFId=-1; 
839      } else {
840        SesId=""; 
841        ActiveIsAliveFId=-1; 
842        SetState(TAppCS::S_Start); 
843      }
844    }
845    SoapResp->AddFldNmVal(TAppCS::A_FetchId, TInt::GetStr(FetchId));
846    OnFetchSoapResp(SoapRq, SoapResp);
847  }
848  void TAppClt::OnHttpRespError(const int& FetchId, const TStr& MsgStr){
849    PAppCSActConn ActConn=ActConnBs->GetActConn(FetchId);
850    PSoapRq SoapRq=ActConn->GetSoapRq();
851    int RetryCnt=ActConn->GetRetryCnt();
852    if (--RetryCnt>0) {
853      ActConnBs->DelActConn(FetchId);
854      IAssert(FetchId==FetchSoapRq(SoapRq,ActConn->GetHostNm(),ActConn->GetPortN(),RetryCnt,FetchId));
855      return;
856    }
857    PHttpResp HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, MsgStr);
858    PSoapResp SoapResp=TSoapResp::New(HttpResp);
859    PutLogMsg("OnFetchError",
860     TStr::Fmt("[FetchId:%d] %s", FetchId, MsgStr.CStr()), false);
861    if ((ActiveIsAliveFId!=-1)&&(FetchId==ActiveIsAliveFId)){
862      SesId=""; 
863      ActiveIsAliveFId=-1; 
864      SetState(TAppCS::S_Start); 
865    }
866    ActConnBs->DelActConn(FetchId);
867    SoapResp->AddFldNmVal(TAppCS::A_FetchId, TInt::GetStr(FetchId));
868    OnFetchSoapResp(SoapRq, SoapResp);
869  }
870  int TAppClt::FetchSoapRq(
871   const PSoapRq& SoapRq, const TStr& HostNm, const int& PortN, const int &RetryCnt, const int &_FetchId){
872    if (IsSesId()){
873      SoapRq->AddFldNmVal(TAppCS::A_SesId, GetSesId());}
874    if (IsAgent()){
875      SoapRq->AddFldNmVal(TAppCS::A_Agent, "T");}
876    PUrl SoapRqUrl;
877    if (HostNm.Empty()){
878      SoapRqUrl=SoapRq->GetAsUrl(SrvHostNm, SrvPortN);
879    } else {
880      SoapRqUrl=SoapRq->GetAsUrl(HostNm, PortN);
881    }
882  #if 0
883    TStr CltNm, FuncNm=SoapRq->GetFuncNm();
884    if ((FuncNm!=TAppCS::F_Connect)&&SoapRq->IsFldNm(TAppCS::A_CltNm)){
885      CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
886    }
887    if (CltNm.Empty()){
888      TStr _CltFuncNm;
889      FuncNm.SplitOnStr(CltNm, "::", _CltFuncNm);
890      if (_CltFuncNm.Empty()) CltNm.Clr();
891    }
892    int FetchId=FetchUrl(SoapRqUrl,_FetchId,CltNm);
893  #else
894    int FetchId=FetchUrl(SoapRqUrl,_FetchId);
895  #endif  
896    if (TAppSrv::IsLogSoapFuncNm(SoapRq->GetFuncNm())){
897      PutLogMsg("FetchSoapRq",
898       TInt::GetStr(FetchId, "[FetchId:%d]")+SoapRq->GetAsUrlPathStr(), false);
899    }
900    ActConnBs->AddActConn(FetchId,
901     TAppCSActConn::New(SoapRq, SoapRqUrl->GetHostNm(), SoapRqUrl->GetPortN(), RetryCnt));
902    return FetchId;
903  }
904  void TAppClt::OnFetchSoapResp(const PSoapRq& SoapRq, const PSoapResp& SoapResp){
905    IAssert(SoapRq->IsOk());
906    IAssert(SoapResp->IsOk());
907    if (SoapResp->IsResult()){
908      TStr SoapRespFuncNm=SoapResp->GetFuncNm();
909      if (SoapRespFuncNm==TAppCS::F_Connect){
910        SesId=SoapResp->GetFldVal(TAppCS::A_SesId); 
911        OnStateExe(setSoapResp, SoapRq, SoapResp); 
912      } else
913      if (SoapRespFuncNm==TAppCS::F_IsAlive){
914      } else
915      if (SoapRespFuncNm==TAppCS::F_NotifyStateChange){
916      } else
<span onclick='openModal()' class='match'>917      if (SoapRespFuncNm==TAppCS::F_NotifyEvent){
918      } else
919      if (SoapRespFuncNm==TAppCS::F_Log){
920      } else {
</span>921        OnFuncResp(SoapRq, SoapResp);
922      }
923    } else {
924      IAssert(SoapResp->IsFault());
925      OnStateExe(setSoapResp, SoapRq, SoapResp); 
926    }
927  }
928  void TAppClt::PutLogMsg(
929   const TStr& MsgType, const TStr& MsgStr, const bool& SendToSrvP){
930    Log->PutLogMsg(MsgType, MsgStr);
931    if ((false)&&(SendToSrvP)){
932      FetchSoapRq(TSoapRq::New(TAppCS::F_Log,
933       TAppCS::A_LogNm, CltNm,
934       TAppCS::A_MsgType, MsgType,
935       TAppCS::A_Msg, MsgStr));
936    }
937  }
938  PHttpResp TAppClt::OnConnectRqAndResp(
939   const TStr& NextSId,
940   const TAppCsSET& ExeType, const PSoapRq& SoapRq, const PSoapResp& SoapResp,
941   bool& BreakLoopP){
942    PAppCSLog Log; PAppCSState State; TStr StateId;
943    TStr RqFuncNm; TStr RespFuncNm; TStr RespFetchId; bool RespResultP;
944    GetStateExeShortcuts(Log, State, StateId,
945     SoapRq, RqFuncNm, SoapResp, RespFuncNm, RespFetchId, RespResultP);
946    BreakLoopP=true;
947    if (StateId==TAppCS::S_ConnectRq){
948      if (IsSesId()){
949        SesId="";
950      }
951      FetchSoapRqSaveFId(TSoapRq::New(TAppCS::F_Connect,
952       TAppCS::A_PortN, TInt::GetStr(GetPortN()),
953       TAppCS::A_CltNm, GetCltNm()));
954      SetState(TAppCS::S_ConnectResp);
955      return NULL;
956    } else
957    if (StateId==TAppCS::S_ConnectResp){
958      if ((GetFId(TAppCS::F_Connect)==RespFetchId)&&(RespResultP)){
959        SetState(NextSId);
960      } else {
961        StartDelayTimer();
962        SetState(TAppCS::S_ConnectRq);
963        return NULL;
964      }
965    }
966    BreakLoopP=false;
967    return NULL;
968  }
969  void TAppClt::StartDelayTimer(const int& DelayTout){
970    if (DelayTout==-1){
971      DelayTimer->StartTimer(TAppCS::DTmrA_DelayTimerTout);
972    } else {
973      DelayTimer->StartTimer(DelayTout);
974    }
975  }
976  void TAppClt::StopDelayTimer(){
977    DelayTimer->StopTimer();
978  }
979  int TAppClt::FetchSoapRqSaveFId(
980   const PSoapRq& SoapRq, const TStr& HostNm, const int& PortN){
981    int FetchId=FetchSoapRq(SoapRq, HostNm, PortN);
982    PutFId(SoapRq->GetFuncNm(), TInt::GetStr(FetchId));
983    return FetchId;
984  }
985  void TAppClt::GetStateExeShortcuts(
986   PAppCSLog& Log,
987   PAppCSState& State, TStr& StateId,
988   const PSoapRq& SoapRq, TStr& SoapRqFuncNm,
989   const PSoapResp& SoapResp, TStr& SoapRespFuncNm, TStr& SoapRespFetchId,
990   bool& SoapRespResultP){
991    Log=GetLog();
992    State=GetState();
993    StateId=State->GetStateId();
994    if (SoapRq.Empty()){
995      SoapRqFuncNm="";
996    } else {
997      SoapRqFuncNm=SoapRq->GetFuncNm();
998    }
999    if (SoapResp.Empty()){
1000      SoapRespFuncNm="";
1001      SoapRespFetchId="";
1002      SoapRespResultP=false;
1003    } else {
1004      SoapRespFuncNm=SoapResp->GetFuncNm();
1005      SoapRespFetchId=SoapResp->GetFldVal(TAppCS::A_FetchId);
1006      SoapRespResultP=SoapResp->IsResult();
1007    }
1008  }
1009  void TAppClt::BroadcastToAgents(const PSoapRq& SoapRq){
1010    if (GetAgents()>0){
1011      SoapRq->AddFldNmVal(TAppCS::A_Agent, "T");
1012      for (int AgentN=0; AgentN<GetAgents(); AgentN++){
1013        TStr HostNm; int PortN; GetAgentHostNmPortN(AgentN, HostNm, PortN);
1014        FetchSoapRq(SoapRq, HostNm, PortN);
1015      }
1016    }
1017  }
1018  void TAppClt::SetState(const TStr& StateId, const TStr& MsgStr,
1019   const TStr& TbNm1, const PSoapTb& Tb1,
1020   const TStr& TbNm2, const PSoapTb& Tb2){
1021    TStr OldStateId=State->GetStateId();
1022    State->SetState(StateId);
1023    TStr NewStateId=State->GetStateId();
1024    if (GetAgents()>0){
1025    }
1026  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-url.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-appsrv.cpp</div>
                <div class="column column_space"><pre><code>208      if (IsAbs(RelUrlStr)){
209        GetAbs(RelUrlStr);
210      } else
211      if (IsAbs(BaseUrlStr)){
212        GetAbsFromBase(RelUrlStr, BaseUrlStr);
213      } else {
</pre></code></div>
                <div class="column column_space"><pre><code>917      if (SoapRespFuncNm==TAppCS::F_NotifyEvent){
918      } else
919      if (SoapRespFuncNm==TAppCS::F_Log){
920      } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    