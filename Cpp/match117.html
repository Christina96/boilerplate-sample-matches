<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for DeadState.cpp & GameState.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for DeadState.cpp & GameState.cpp
      </h3>
      <h1 align="center">
        18.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>DeadState.cpp (27.61194%)<TH>GameState.cpp (13.405797%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-1.html#0',3)" NAME="0">(119-147)<TD><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-1.html#0',3)" NAME="0">(133-162)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-1.html#1',3)" NAME="1">(167-182)<TD><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-1.html#1',3)" NAME="1">(288-302)</A><TD ALIGN=center><FONT COLOR="#c20000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>DeadState.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Authors: see AUTHORS.md at project root.
// CopyPolicy: released under the terms of the LGPLv2.1, see LICENSE at project root.
// URL: https://github.com/asrob-uc3m/robotDevastation

#include &quot;DeadState.hpp&quot;

#include &lt;sstream&gt;

#include &lt;yarp/os/LogStream.h&gt;

#include &quot;LogComponent.hpp&quot;

const int rd::DeadState::RESPAWN_SELECTED = 1;
const int rd::DeadState::EXIT_SELECTED = 2;
const int rd::DeadState::DEFAULT_RATE_MS = 100;
const int rd::DeadState::MAX_HEALTH = 100;

rd::DeadState::DeadState(NetworkManager *networkManager, ImageManager *imageManager,
                         InputManager *inputManager, MentalMap *mentalMap,
                         asrob::IRobotManager *robotManager, AudioManager *audioManager,
                         ScreenManager *screenManager) :
                ManagerHub(networkManager, imageManager, inputManager, mentalMap, robotManager,
                           audioManager, screenManager)
{
    state_id = &quot;DeadState&quot;;
    elapsed_time = timer = 0;
    received_respawn = received_exit = false;
}

rd::DeadState::~DeadState()
{

}

bool rd::DeadState::setup()
{
    //-- Reset all variables
    elapsed_time = 0;
    timer = 10;
    received_respawn = false;
    received_exit = false;

    //-- Configure &amp; show Robot Devastation dead screen:
    if( ! screen.init() )
        return false;
    screenManager-&gt;setCurrentScreen(&amp;screen);

    Image last_camera_frame = imageManager-&gt;getImage();
    screenManager-&gt;update(DeadScreen::PARAM_LAST_CAMERA_FRAME, last_camera_frame);

    std::stringstream sstream;
    sstream &lt;&lt; timer;
    screenManager-&gt;update(DeadScreen::PARAM_REMAINING_TIME, sstream.str());

    //-- Disable camera images
    imageManager-&gt;setEnabled(false);

    //-- Disable input
    inputManager-&gt;removeInputEventListeners();

    //-- Change music to dead theme
    audioManager-&gt;stopMusic();
    audioManager-&gt;play(&quot;RD_DEAD&quot;);

    return true;
}

bool rd::DeadState::loop()
{
    //-- Get input events
    inputManager-&gt;refreshEvents();

    //-- Do countdown
    if (timer &gt; 0)
    {
        elapsed_time += DEFAULT_RATE_MS;

        if (elapsed_time == 1000)
        {
            timer--;
            elapsed_time = 0;
            std::stringstream sstream;
            sstream &lt;&lt; timer;
            screenManager-&gt;update(DeadScreen::PARAM_REMAINING_TIME, sstream.str());

            if (timer == 0)
            {
                //-- Enable input
                inputManager-&gt;addInputEventListener(this);
            }
        }
    }

    //-- Show graphics
    if(!screenManager-&gt;show())
        return false;

    return true;
}

bool rd::DeadState::cleanup()
{
    screen.cleanup();

    if (received_respawn)
    {
        //-- Restore things (health, enable stuff)
        mentalMap-&gt;respawn();

        //-- Remove this input listener (game will setup its own listener)
        inputManager-&gt;removeInputEventListeners();

        //-- Stop dead theme
        audioManager-&gt;stopMusic();

<A NAME="0"></A>        return true;

    }
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match117-1.html#0',3,'match117-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    else if (received_exit)
    {
        //-- Stop things to exit game (logout)
        imageManager-&gt;stop();
        inputManager-&gt;stop();
        inputManager-&gt;removeInputEventListeners();
        audioManager-&gt;stopMusic();
        audioManager-&gt;stop();
        networkManager-&gt;logout();
        networkManager-&gt;stop();
        return true;
    }
    else
        return false;
}

int rd::DeadState::evaluateConditions()
{
    if (received_respawn)
        return RESPAWN_SELECTED;

    if (received_exit)
        return EXIT_SELECTED;

    return -1;
}

bool rd::DeadState::onKeyDown(const Key &amp; k)
{</B></FONT>
    return true;
}

bool rd::DeadState::onKeyUp(const Key &amp; k)
{
    if (received_respawn || received_exit)
        return false;

    if (k.getValue() == Key::KEY_ENTER)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Enter was pressed!&quot;;
        received_respawn = true;
        return true;
    }

    if (k.getValue() == Key::KEY_ESCAPE)
<A NAME="1"></A>    {
        yCDebug(RD_GS) &lt;&lt; &quot;Escape was pressed!&quot;;
        received_exit = true;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match117-1.html#1',3,'match117-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        return true;
    }

    return false;
}

bool rd::DeadState::onWindowEvent(const WindowEvent &amp; event)
{
    if (event.getEvent() == WindowEvent::WINDOW_CLOSE)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Exit was triggered!&quot;;
        received_exit = true;
        return true;
    }
    return false;
}</B></FONT>
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>GameState.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Authors: see AUTHORS.md at project root.
// CopyPolicy: released under the terms of the LGPLv2.1, see LICENSE at project root.
// URL: https://github.com/asrob-uc3m/robotDevastation

#include &quot;GameState.hpp&quot;

#include &lt;yarp/os/LogStream.h&gt;

#include &quot;LogComponent.hpp&quot;

const int rd::GameState::KILLED = 1;
const int rd::GameState::EXIT_REQUESTED = 2;

const rd::Key rd::GameState::KEY_EXIT = rd::Key::KEY_ESCAPE;
const rd::Key rd::GameState::KEY_SHOOT = rd::Key::KEY_SPACE;
const rd::Key rd::GameState::KEY_RELOAD = 'r';
const rd::Key rd::GameState::KEY_MOVE_FWD = 'w';
const rd::Key rd::GameState::KEY_MOVE_BACK = 's';
const rd::Key rd::GameState::KEY_TURN_LEFT = 'a';
const rd::Key rd::GameState::KEY_TURN_RIGHT = 'd';
const rd::Key rd::GameState::KEY_PAN_LEFT = rd::Key::KEY_ARROW_LEFT;
const rd::Key rd::GameState::KEY_PAN_RIGHT = rd::Key::KEY_ARROW_RIGHT;
const rd::Key rd::GameState::KEY_TILT_UP = rd::Key::KEY_ARROW_UP;
const rd::Key rd::GameState::KEY_TILT_DOWN = rd::Key::KEY_ARROW_DOWN;

rd::GameState::GameState(NetworkManager *networkManager, ImageManager *imageManager,
                         InputManager *inputManager, MentalMap *mentalMap,
                         asrob::IRobotManager *robotManager, AudioManager *audioManager,
                         ScreenManager *screenManager) :
                    ManagerHub(networkManager, imageManager, inputManager, mentalMap, robotManager,
                               audioManager, screenManager)
{
    state_id = &quot;GameState&quot;;
    received_exit = false;
}

rd::GameState::~GameState()
{

}

bool rd::GameState::setup()
{
    //-- Connect mentalMap to networkManager to receive updates (and vice-versa)
    if (mentalMap!=NULL &amp;&amp; networkManager!=NULL)
    {
        networkManager-&gt;addNetworkEventListener(mentalMap);
        mentalMap-&gt;addMentalMapEventListener(networkManager);
    }
    else
    {
        yCError(RD_GS) &lt;&lt; &quot;Null mentalMap or networkManager&quot;;
        return false;
    }

    //-- Start video
    if (imageManager!=NULL)
    {
        imageManager-&gt;setEnabled(true);
        imageManager-&gt;addImageEventListener(&amp;processorImageEventListener);
        imageManager-&gt;addImageEventListener(this);
    }
    else
    {
        yCError(RD_GS) &lt;&lt; &quot;Null imageManager&quot;;
        return false;
    }

    //-- Start audio
    if (audioManager!=NULL)
    {
        audioManager-&gt;start();
        audioManager-&gt;play(&quot;RD_THEME&quot;, -1);
    }
    else
    {
        yCError(RD_GS) &lt;&lt; &quot;Null audioManager&quot;;
        return false;
    }

    //-- Enable input
    if (inputManager!=NULL)
    {
        inputManager-&gt;addInputEventListener(this);
    }
    else
    {
        yCError(RD_GS) &lt;&lt; &quot;Null inputManager&quot;;
        return false;
    }

    //-- Show Robot Devastation game screen:
    if (!screen.init())
    {
        yCError(RD_GS) &lt;&lt; &quot;Could not init game screen&quot;;
        return false;
    }

    //-- Set info elements on GameScreen
    screenManager-&gt;setCurrentScreen(&amp;screen);
    screenManager-&gt;update(GameScreen::PARAM_MYSELF, mentalMap-&gt;getMyself());
    screenManager-&gt;update(GameScreen::PARAM_PLAYERS, mentalMap-&gt;getPlayers());
    screenManager-&gt;update(GameScreen::PARAM_TARGETS, mentalMap-&gt;getTargets());
    screenManager-&gt;update(GameScreen::PARAM_WEAPON, mentalMap-&gt;getCurrentWeapon());

    return true;
}

bool rd::GameState::loop()
{
    //-- Get input events
    inputManager-&gt;refreshEvents();

    //-- Set info elements on GameScreen
    screenManager-&gt;update(GameScreen::PARAM_MYSELF, mentalMap-&gt;getMyself());
    screenManager-&gt;update(GameScreen::PARAM_PLAYERS, mentalMap-&gt;getPlayers());
    screenManager-&gt;update(GameScreen::PARAM_TARGETS, mentalMap-&gt;getTargets());
    screenManager-&gt;update(GameScreen::PARAM_WEAPON, mentalMap-&gt;getCurrentWeapon());

    //-- Show graphics
    if(!screenManager-&gt;show())
    {
        yCError(RD_GS) &lt;&lt; &quot;Could not show game screen&quot;;
        return false;
    }
    return true;
}

bool rd::GameState::cleanup()
<A NAME="0"></A>{
    screen.cleanup();

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    if (received_exit)
    {
        //-- Stop things to exit game (logout)
        imageManager-&gt;stop();
        inputManager-&gt;stop();
        inputManager-&gt;removeInputEventListeners();
        audioManager-&gt;stopMusic();
        audioManager-&gt;stop();
        networkManager-&gt;logout();
        networkManager-&gt;stop();
        return true;
    }
    else
        return false;

}

int rd::GameState::evaluateConditions()
{
    if (mentalMap-&gt;getMyself().getHealth()==0)
        return KILLED;

    if (received_exit)
        return EXIT_REQUESTED;

    return -1;
}

bool rd::GameState::onKeyDown(const Key &amp; k)
{</B></FONT>
    if (k == KEY_SHOOT)
    {
        mentalMap-&gt;shoot();
        return true;
    }

    if (k == KEY_RELOAD)
    {
        mentalMap-&gt;reload();
        return true;
    }

    if (k == KEY_EXIT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Exit was triggered!&quot;;
        received_exit = true;
        return true;
    }

    //-- Movement control
    if (k == KEY_TURN_LEFT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Turn left was triggered!&quot;;
        robotManager-&gt;turnLeft(1.0);
        return true;
    }
    if (k == KEY_TURN_RIGHT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Turn right was triggered!&quot;;
        robotManager-&gt;turnLeft(-1.0);
        return true;
    }
    if (k == KEY_MOVE_FWD)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Move forward was triggered!&quot;;
        robotManager-&gt;moveForward(1.0);
        return true;
    }
    if (k == KEY_MOVE_BACK)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Move backwards was triggered!&quot;;
        robotManager-&gt;moveForward(-1.0);
        return true;
    }

    //-- Pan-tilt control
    if (k == KEY_PAN_LEFT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Pan left was triggered!&quot;;
        robotManager-&gt;panLeft(30.0);
        return true;
    }
    if (k == KEY_PAN_RIGHT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Pan right was triggered!&quot;;
        robotManager-&gt;panLeft(-30.0);
        return true;
    }
    if (k == KEY_TILT_UP)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Tilt pos was triggered!&quot;;
        robotManager-&gt;tiltDown(-30.0);
        return true;
    }
    if (k == KEY_TILT_DOWN)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Tilt neg was triggered!&quot;;
        robotManager-&gt;tiltDown(30.0);
        return true;
    }

    return false;
}

bool rd::GameState::onKeyUp(const Key &amp; k)
{
    //-- Movement control
    if (k == KEY_TURN_LEFT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Turn left was released!&quot;;
        robotManager-&gt;stopMovement();
        return true;
    }
    if (k == KEY_TURN_RIGHT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Turn right was released!&quot;;
        robotManager-&gt;stopMovement();
        return true;
    }
    if (k == KEY_MOVE_FWD)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Move forward was released!&quot;;
        robotManager-&gt;stopMovement();
        return true;
    }
    if (k == KEY_MOVE_BACK)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Move backwards was released!&quot;;
        robotManager-&gt;stopMovement();
        return true;
    }

    //-- Pan-tilt control
    if (k == KEY_PAN_LEFT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Pan left was released!&quot;;
        robotManager-&gt;stopCameraMovement();
        return true;
    }
    if (k == KEY_PAN_RIGHT)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Pan right was released!&quot;;
        robotManager-&gt;stopCameraMovement();
        return true;
    }
    if (k == KEY_TILT_UP)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Tilt up was released!&quot;;
        robotManager-&gt;stopCameraMovement();
        return true;
    }
    if (k == KEY_TILT_DOWN)
<A NAME="1"></A>    {
        yCDebug(RD_GS) &lt;&lt; &quot;Tilt down was released!&quot;;
        robotManager-&gt;stopCameraMovement();
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        return true;
    }
    return false;
}

bool rd::GameState::onWindowEvent(const WindowEvent &amp; event)
{
    if (event.getEvent() == WindowEvent::WINDOW_CLOSE)
    {
        yCDebug(RD_GS) &lt;&lt; &quot;Exit was triggered!&quot;;
        received_exit = true;
        return true;
    }
    return false;
}</B></FONT>

bool rd::GameState::onImageArrived(ImageManager *manager)
{
    //-- Don't know if this is safe enough or some mutex is required
    screenManager-&gt;update(GameScreen::PARAM_CAMERA_FRAME, manager-&gt;getImage());
    return true;
}
</PRE>
</div>
  </div>
</body>
</html>
