<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_CovOptimData.cpp &amp; ibex_CovSolverData.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_CovOptimData.cpp &amp; ibex_CovSolverData.cpp
      </h3>
<h1 align="center">
        69.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_CovOptimData.cpp (78.305084%)<th>ibex_CovSolverData.cpp (62.77174%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-135)<td><a href="#" name="0">(135-176)</a><td align="center"><font color="#ff0000">60</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(140-161)<td><a href="#" name="1">(177-199)</a><td align="center"><font color="#d00000">49</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(33-58)<td><a href="#" name="2">(31-56)</a><td align="center"><font color="#ae0000">41</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(67-83)<td><a href="#" name="3">(74-90)</a><td align="center"><font color="#6a0000">25</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(200-250)<td><a href="#" name="4">(263-304)</a><td align="center"><font color="#660000">24</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(18-26)<td><a href="#" name="5">(18-26)</a><td align="center"><font color="#480000">17</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(174-182)<td><a href="#" name="6">(243-251)</a><td align="center"><font color="#3f0000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovOptimData.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "ibex_CovOptimData.h"
#include "ibex_Optimizer.h"
#include &lt;algorithm&gt;
<a name="5"></a>
using namespace std;
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>namespace ibex {
const unsigned int CovOptimData::FORMAT_VERSION = 1;
const unsigned int CovOptimData::subformat_level = 2;
const unsigned int CovOptimData::subformat_number = 1;
CovOptimData::CovOptimData(size_t n, bool is_extended_space) : CovList(n), data(new Data()), own_data(true) {</b></font>
	data-&gt;_optim_is_extended_space = is_extended_space;
	data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS; 	data-&gt;_optim_uplo=NEG_INFINITY;
<a name="2"></a>	data-&gt;_optim_uplo_of_epsboxes = POS_INFINITY;
	data-&gt;_optim_loup = POS_INFINITY;
	if (n&gt;0) data-&gt;_optim_loup_point.resize(n);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	data-&gt;_optim_time = -1;
	data-&gt;_optim_nb_cells = 0;
}
CovOptimData::CovOptimData(const char* filename) : CovOptimData((size_t) 0 	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ifstream* f = CovOptimData::read(filename, *this, format_id, format_version);
	f-&gt;close();
	delete f;
}
CovOptimData::CovOptimData(const Cov&amp; cov, bool copy) : CovList(cov, copy) {
	const CovOptimData* covOptimData = dynamic_cast&lt;const CovOptimData*&gt;(&amp;cov);
	if (covOptimData) {
		if (copy) {
			data = new Data(*covOptimData-&gt;data); 			own_data = true;
		} else {
			data = covOptimData-&gt;data;
			own_data = false;
		}
	} else {
		data = new Data();
		data-&gt;_optim_is_extended_space = false;</b></font>
		data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS; 		data-&gt;_optim_uplo=NEG_INFINITY;
		data-&gt;_optim_uplo_of_epsboxes = POS_INFINITY;
		data-&gt;_optim_loup = POS_INFINITY;
		data-&gt;_optim_loup_point.resize(n);
<a name="3"></a>		data-&gt;_optim_loup_point = IntervalVector::empty(cov.n);
		data-&gt;_optim_time = -1;
		data-&gt;_optim_nb_cells = 0;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		own_data = true;
	}
}
CovOptimData::~CovOptimData() {
	if (own_data) {
		delete data;
	}
}
void CovOptimData::save(const char* filename) const {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ofstream* of=CovOptimData::write(filename, *this, format_id, format_version);
	of-&gt;close();
	delete of;
}</b></font>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const CovOptimData&amp; optim) {
	os &lt;&lt; " f* in [" &lt;&lt; optim.uplo() &lt;&lt; "," &lt;&lt; optim.loup() &lt;&lt; "]" &lt;&lt; endl;
	size_t i;
	if (optim.loup_point().is_empty()) {
		os &lt;&lt; " no feasible point found." &lt;&lt; endl;
		i = 0;
<a name="0"></a>	} else {
		os &lt;&lt; " x* ~  " &lt;&lt; optim.loup_point() &lt;&lt; endl;
		i = 1;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
	for (size_t j=0; j&lt;optim.size()-i; j++) {
		os &lt;&lt; " pending nÂ°" &lt;&lt; (j+1) &lt;&lt; " = " &lt;&lt; optim[i] &lt;&lt; endl;
	}
	return os;
}
void CovOptimData::read_vars(ifstream&amp; f, size_t n, vector&lt;string&gt;&amp; var_names) {
	char x;
	for (size_t i=0; i&lt;n; i++) {
		stringstream s;
		do {
			f.read(&amp;x, sizeof(char));
			if (f.eof()) ibex_error("[CovManifold]: unexpected end of file.");
			if (x!='\0') s &lt;&lt; x;
		} while(x!='\0');
		var_names.push_back(s.str());
	}
}
void CovOptimData::write_vars(ofstream&amp; f, const vector&lt;string&gt;&amp; var_names) {
	for (vector&lt;string&gt;::const_iterator it=var_names.begin(); it!=var_names.end(); it++) {
		f.write(it-&gt;c_str(),it-&gt;size()*sizeof(char));
		f.put('\0');
	}
}
ifstream* CovOptimData::read(const char* filename, CovOptimData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	ifstream* f = CovList::read(filename, cov, format_id, format_version);
	if (format_id.empty() || format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION) {
		cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS;
		cov.data-&gt;_optim_is_extended_space = false;
		cov.data-&gt;_optim_uplo = NEG_INFINITY;
		cov.data-&gt;_optim_loup = POS_INFINITY;</b></font>
		cov.data-&gt;_optim_loup_point.resize((int) cov.n);
<a name="1"></a>		cov.data-&gt;_optim_loup_point = IntervalVector::empty(cov.n);
		cov.data-&gt;_optim_time = -1;
		cov.data-&gt;_optim_nb_cells = 0;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
	else {
		format_id.pop();
		format_version.pop();
		read_vars(*f, cov.n, cov.data-&gt;_optim_var_names);
		unsigned int status = read_pos_int(*f);
		switch (status) {
		case 0: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS;           break;
		case 1: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::INFEASIBLE;        break;
		case 2: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::NO_FEASIBLE_FOUND; break;
		case 3: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::UNBOUNDED_OBJ;     break;
		case 4: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::TIME_OUT;     		break;
		case 5: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::UNREACHED_PREC;    break;
		default: ibex_error("[CovOptimData]: invalid optimizer status.");
		}
		cov.data-&gt;_optim_is_extended_space = (bool) read_pos_int(*f);
		cov.data-&gt;_optim_uplo              = read_double(*f);
		cov.data-&gt;_optim_uplo_of_epsboxes  = read_double(*f);</b></font>
		cov.data-&gt;_optim_loup              = read_double(*f);
		unsigned int loup_found   = read_pos_int(*f);
		unsigned int nb_var   = cov.is_extended_space() ? cov.n-1 : cov.n;
		cov.data-&gt;_optim_loup_point.resize((int) nb_var);
		cov.data-&gt;_optim_loup_point 		  = loup_found==1? cov[0].subvector(0,nb_var-1) : IntervalVector::empty(nb_var);
		cov.data-&gt;_optim_time              = read_double(*f);
<a name="6"></a>		cov.data-&gt;_optim_nb_cells          = read_pos_int(*f);
	}
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return f;
}
ofstream* CovOptimData::write(const char* filename, const CovOptimData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);
	ofstream* f = CovList::write(filename, cov, format_id, format_version);</b></font>
	write_vars   (*f, cov.var_names());
	write_pos_int(*f, cov.optimizer_status());
	write_pos_int(*f, (uint32_t) cov.is_extended_space());
	write_double (*f, cov.uplo());
	write_double (*f, cov.uplo_of_epsboxes());
	write_double (*f, cov.loup());
	if (!cov.loup_point().is_empty()) {
		unsigned int nb_var   = cov.is_extended_space() ? cov.n-1 : cov.n;
		if (cov[0].subvector(0,nb_var-1)!=cov.loup_point()) {
			ibex_error("[CovOptimData] the first box in the list must be the 'loup-point'.");
		}
<a name="4"></a>		write_pos_int(*f, (uint32_t) 1);
	} else {
		write_pos_int(*f, (uint32_t) 0);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
	write_double(*f, cov.time());
	write_pos_int   (*f, cov.nb_cells());
	return f;
}
void CovOptimData::format(stringstream&amp; ss, const string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);
	CovList::format(ss, title, format_id, format_version);
	ss
	&lt;&lt; space &lt;&lt; " - n strings:      the names of variables. Each string is\n"
	&lt;&lt; space &lt;&lt; "                   terminated by the null character \'0\'.\n"
	&lt;&lt; space &lt;&lt; " - 1 integer:      the status of the optimizer. Possible \n"
	&lt;&lt; space &lt;&lt; "                   values are:\n"
	&lt;&lt; space &lt;&lt; "                   - 0=success\n"
	&lt;&lt; space &lt;&lt; "                   - 1=infeasible problem\n"
	&lt;&lt; "|   CovOptimData    |" &lt;&lt;
	            "                   - 2=no feasible point found\n"
	&lt;&lt; space &lt;&lt; "                   - 3=unbounded objective\n"
	&lt;&lt; space &lt;&lt; "                   - 4=time out\n"
	&lt;&lt; space &lt;&lt; "                   - 5=unreached precision\n"
	&lt;&lt; space &lt;&lt; " - 1 integer:      1 &lt;=&gt; covering of the extended space\n"
	&lt;&lt; space &lt;&lt; "                    (vars+obj), 0 &lt;=&gt; covering of the \n"
	&lt;&lt; space &lt;&lt; "                   original space (variables only).\n"
	&lt;&lt; space &lt;&lt; " - 3 real values:  'uplo', 'uplo-of-epsboxes' and 'loup'\n"
	&lt;&lt; space &lt;&lt; "                   'uplo' is the uppest lower bound of f*\n"
	&lt;&lt; space &lt;&lt; "                   'loup' is the lowest upper bound of f*\n"
	&lt;&lt; space &lt;&lt; "                   so we have:       uplo&lt;= f* &lt;=loup.\n"
	&lt;&lt; space &lt;&lt; " - 1 integer:      1 &lt;=&gt; the first box is the 'loup point'\n"
	&lt;&lt; space &lt;&lt; "                   (best feasible point found), possibly\n"
	&lt;&lt; space &lt;&lt; "                   extended (see above). 0 &lt;=&gt; no feasible\n"
	&lt;&lt; space &lt;&lt; "                   point found.\n"
	&lt;&lt; space &lt;&lt; " - 1 real value:   time (in seconds)\n"
	&lt;&lt; space &lt;&lt; " - 1 integer:      number of cells.\n"
	&lt;&lt; separator;
}
string CovOptimData::format() {
	stringstream ss;
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	format(ss, "CovOptimData", format_id, format_version);
	return ss.str();
}
} 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovSolverData.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "ibex_CovSolverData.h"
#include "ibex_Solver.h"
#include &lt;algorithm&gt;
<a name="5"></a>
using namespace std;
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>namespace ibex {
const unsigned int CovSolverData::FORMAT_VERSION = 2;
const unsigned int CovSolverData::subformat_level = 5;
const unsigned int CovSolverData::subformat_number = 0;
CovSolverData::CovSolverData(size_t n, size_t m, size_t nb_ineq, BoundaryType boundary_type, const vector&lt;string&gt;&amp; var_names) :</b></font>
		CovManifold(n, m, nb_ineq, boundary_type), data(new Data()), own_data(true) {
<a name="2"></a>
	data-&gt;_solver_var_names = var_names;
	data-&gt;_solver_solver_status = Solver::SUCCESS; <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	data-&gt;_solver_time = -1;
	data-&gt;_solver_nb_cells = 0;
}
CovSolverData::CovSolverData(const char* filename) : CovSolverData(0, 0, 0 	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ifstream* f = CovSolverData::read(filename, *this, format_id, format_version);
	f-&gt;close();
	delete f;
}
CovSolverData::CovSolverData(const Cov&amp; cov, bool copy) : CovManifold(cov, copy) {
	const CovSolverData* covSolverData = dynamic_cast&lt;const CovSolverData*&gt;(&amp;cov);
	if (covSolverData) {
		if (copy) {
			data = new Data(*covSolverData-&gt;data); 			own_data = true;
		} else {
			data = covSolverData-&gt;data;
			own_data = false;
		}
	} else {
		data = new Data();
		data-&gt;_solver_solver_status = Solver::SUCCESS; 		data-&gt;_solver_time = -1;
		data-&gt;_solver_nb_cells = 0;
		for (size_t i=0; i&lt;size(); i++) {
			switch(CovManifold::status(i)) {
			case CovManifold::SOLUTION :
				data-&gt;_solver_status.push_back(CovSolverData::SOLUTION);
				break;
			case CovManifold::BOUNDARY :
				data-&gt;_solver_status.push_back(CovSolverData::BOUNDARY);
				break;
			case CovManifold::UNKNOWN :
				data-&gt;_solver_status.push_back(CovSolverData::UNKNOWN);
				data-&gt;_solver_unknown.push_back(i);
<a name="3"></a>				break;
			}
		}
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		own_data = true;
	}
}
CovSolverData::~CovSolverData() {
	if (own_data) {
		delete data;
	}
}
void CovSolverData::save(const char* filename) const {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ofstream* of=CovSolverData::write(filename, *this, format_id, format_version);
	of-&gt;close();
	delete of;
}</b></font>
void CovSolverData::add(const IntervalVector&amp; x) {
	add_unknown(x);
}
void CovSolverData::add_inner(const IntervalVector&amp; x) {
	CovManifold::add_inner(x);
	data-&gt;_solver_status.push_back(SOLUTION);
}
void CovSolverData::add_boundary(const IntervalVector&amp; x, const VarSet&amp; varset) {
	CovManifold::add_boundary(x,varset);
	data-&gt;_solver_status.push_back(BOUNDARY);
}
void CovSolverData::add_unknown(const IntervalVector&amp; x) {
	CovManifold::add_unknown(x);
	data-&gt;_solver_status.push_back(UNKNOWN);
	data-&gt;_solver_unknown.push_back(size()-1);
}
void CovSolverData::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity, const VarSet&amp; varset) {
	CovManifold::add_solution(existence, unicity, varset);
	data-&gt;_solver_status.push_back(SOLUTION);
}
void CovSolverData::add_pending(const IntervalVector&amp; x) {
	CovManifold::add_unknown(x);
	data-&gt;_solver_status.push_back(PENDING);
	data-&gt;_solver_pending.push_back(size()-1);
}
ostream&amp; operator&lt;&lt;(ostream&amp; os, const CovSolverData&amp; solver) {
	for (size_t i=0; i&lt;solver.nb_solution(); i++) {
		os &lt;&lt; " solution nÂ°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; solver.solution(i) &lt;&lt; endl;
	}
	for (size_t i=0; i&lt;solver.nb_boundary(); i++) {
		os &lt;&lt; " boundary nÂ°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; solver.boundary(i) &lt;&lt; endl;
	}
<a name="0"></a>
	for (size_t i=0; i&lt;solver.nb_unknown(); i++) {
		os &lt;&lt; " unknown nÂ°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; solver.unknown(i) &lt;&lt; endl;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
	for (size_t i=0; i&lt;solver.nb_pending(); i++) {
		os &lt;&lt; " pending nÂ°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; solver.pending(i) &lt;&lt; endl;
	}
	return os;
}
void CovSolverData::read_vars(ifstream&amp; f, size_t n, vector&lt;string&gt;&amp; var_names) {
	char x;
	for (size_t i=0; i&lt;n; i++) {
		stringstream s;
		do {
			f.read(&amp;x, sizeof(char));
			if (f.eof()) ibex_error("[CovManifold]: unexpected end of file.");
			if (x!='\0') s &lt;&lt; x;
		} while(x!='\0');
		var_names.push_back(s.str());
	}
}
void CovSolverData::write_vars(ofstream&amp; f, const vector&lt;string&gt;&amp; var_names) {
	for (vector&lt;string&gt;::const_iterator it=var_names.begin(); it!=var_names.end(); it++) {
		f.write(it-&gt;c_str(),it-&gt;size()*sizeof(char));
		f.put('\0');
	}
}
ifstream* CovSolverData::read(const char* filename, CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	ifstream* f = CovManifold::read(filename, cov, format_id, format_version);
	size_t nb_pending;
	if (format_id.empty() || format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION) {
		cout &lt;&lt; "here\n";
		cov.data-&gt;_solver_solver_status = (unsigned int) Solver::SUCCESS;
<a name="1"></a>		cov.data-&gt;_solver_time = -1;
		cov.data-&gt;_solver_nb_cells = 0;
		nb_pending = 0;</b></font>
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
	else {
		format_id.pop();
		format_version.pop();
		read_vars(*f, cov.n, cov.data-&gt;_solver_var_names);
		unsigned int status = read_pos_int(*f);
		switch (status) {
		case 0: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::SUCCESS;           break;
		case 1: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::INFEASIBLE;        break;
		case 2: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::NOT_ALL_VALIDATED; break;
		case 3: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::TIME_OUT;          break;
		case 4: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::CELL_OVERFLOW;     break;
		case 5: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::USER_BREAK;        break;
		default: ibex_error("[CovSolverData]: invalid solver status.");
		}
		cov.data-&gt;_solver_time = read_double(*f);
		cov.data-&gt;_solver_nb_cells = read_pos_int(*f);
		nb_pending = read_pos_int(*f);</b></font>
		if (nb_pending &gt; cov.CovManifold::nb_unknown())
			ibex_error("[CovSolverData]: number of pending boxes &gt; number of CovManifold unknown boxes");
		for (size_t i=0; i&lt;nb_pending; i++) {
			uint32_t j=read_pos_int(*f);
			if (!cov.data-&gt;_solver_pending.empty()) { 				if (j&lt;cov.data-&gt;_solver_pending.back())
					ibex_error("[CovSolverData]: indices of pending boxes are not in increasing order.");
				if (j==cov.data-&gt;_solver_pending.back())
					ibex_error("[CovSolverData]: duplicated index of pending box.");
			}
			cov.data-&gt;_solver_pending.push_back(j);
		}
	}
	vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_solver_pending.begin(); 
	for (size_t i=0; i&lt;cov.size(); i++) {
		if (it!=cov.data-&gt;_solver_pending.end() &amp;&amp; i==*it) {
			if (!cov.CovManifold::is_unknown(i))
				ibex_error("[CovSolverData]: a pending box must be a CovManifold unknown box.");
			cov.data-&gt;_solver_status.push_back(CovSolverData::PENDING);
			++it;
		} else {
			switch(cov.CovManifold::status(i)) {
			case CovManifold::SOLUTION :
				cov.data-&gt;_solver_status.push_back(CovSolverData::SOLUTION);
				break;
			case CovManifold::BOUNDARY :
				cov.data-&gt;_solver_status.push_back(CovSolverData::BOUNDARY);
				break;
			default :
				cov.data-&gt;_solver_unknown.push_back(i);
				cov.data-&gt;_solver_status.push_back(CovSolverData::UNKNOWN);
			}
		}
<a name="6"></a>	}
	if (it!=cov.data-&gt;_solver_pending.end()) ibex_error("[CovSolverData]: invalid pending box index.");
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return f;
}
ofstream* CovSolverData::write(const char* filename, const CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);
	ofstream* f = CovManifold::write(filename, cov, format_id, format_version);</b></font>
	write_vars(*f, cov.data-&gt;_solver_var_names);
	write_pos_int(*f, cov.data-&gt;_solver_solver_status);
	write_double(*f, cov.data-&gt;_solver_time);
	write_pos_int(*f, cov.data-&gt;_solver_nb_cells);
	write_pos_int(*f, cov.nb_pending());
<a name="4"></a>	for (vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_solver_pending.begin(); it!=cov.data-&gt;_solver_pending.end(); ++it) {
		assert(*it&lt;numeric_limits&lt;uint32_t&gt;::max());
		write_pos_int(*f, (uint32_t) *it);
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
	return f;
}
void CovSolverData::format(stringstream&amp; ss, const string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);
	CovManifold::format(ss, title, format_id, format_version);
	ss
	&lt;&lt; space &lt;&lt; " - n strings:      the names of variables. Each string is\n"
	&lt;&lt; space &lt;&lt; "                   terminated by the null character \'\\0\'.\n"
	&lt;&lt; space &lt;&lt; " - 1 integer:      the status of the search. Possible \n"
	&lt;&lt; space &lt;&lt; "                   values are:\n"
	&lt;&lt; space &lt;&lt; "                   - 0=complete search: all output boxes\n"
	&lt;&lt; space &lt;&lt; "                     are validated\n"
	&lt;&lt; space &lt;&lt; "                   - 1=complete search: infeasible problem\n"
	&lt;&lt; "|   CovSolverData   |" &lt;&lt;
	            "                   - 2=incomplete search: minimal width\n"
	&lt;&lt; space &lt;&lt; "                     (--eps-min) reached\n"
	&lt;&lt; space &lt;&lt; "                   - 3=incomplete search: time out\n"
	&lt;&lt; space &lt;&lt; "                   - 4=incomplete search: buffer overflow\n"
	&lt;&lt; space &lt;&lt; "                   - 5=incomplete search: user break\n"
	&lt;&lt; space &lt;&lt; " - 1 real value:   time (in seconds)\n"
	&lt;&lt; space &lt;&lt; " - 1 integer:      the number of cells.\n"
	&lt;&lt; space &lt;&lt; " - 1 value:        the number Np of pending boxes\n"
	&lt;&lt; space &lt;&lt; " - Np integers:    the indices of pending boxes\n"
	&lt;&lt; space &lt;&lt; "                   (a subset of CovIUList unknown boxes).\n"
	&lt;&lt; separator;
}
string CovSolverData::format() {
	stringstream ss;
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	format(ss, "CovSolverData", format_id, format_version);
	return ss.str();
}
} 
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
