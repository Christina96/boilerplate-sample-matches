<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ibex_CovOptimData.cpp & ibex_CovSolverData.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ibex_CovOptimData.cpp & ibex_CovSolverData.cpp
      </h3>
      <h1 align="center">
        69.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ibex_CovOptimData.cpp (78.305084%)<TH>ibex_CovSolverData.cpp (62.77174%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match230-0.html#0',2,'match230-1.html#0',3)" NAME="0">(97-135)<TD><A HREF="javascript:ZweiFrames('match230-0.html#0',2,'match230-1.html#0',3)" NAME="0">(135-176)</A><TD ALIGN=center><FONT COLOR="#ff0000">60</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match230-0.html#1',2,'match230-1.html#1',3)" NAME="1">(140-161)<TD><A HREF="javascript:ZweiFrames('match230-0.html#1',2,'match230-1.html#1',3)" NAME="1">(177-199)</A><TD ALIGN=center><FONT COLOR="#d00000">49</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match230-0.html#2',2,'match230-1.html#2',3)" NAME="2">(33-58)<TD><A HREF="javascript:ZweiFrames('match230-0.html#2',2,'match230-1.html#2',3)" NAME="2">(31-56)</A><TD ALIGN=center><FONT COLOR="#ae0000">41</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match230-0.html#3',2,'match230-1.html#3',3)" NAME="3">(67-83)<TD><A HREF="javascript:ZweiFrames('match230-0.html#3',2,'match230-1.html#3',3)" NAME="3">(74-90)</A><TD ALIGN=center><FONT COLOR="#6a0000">25</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match230-0.html#4',2,'match230-1.html#4',3)" NAME="4">(200-250)<TD><A HREF="javascript:ZweiFrames('match230-0.html#4',2,'match230-1.html#4',3)" NAME="4">(263-304)</A><TD ALIGN=center><FONT COLOR="#660000">24</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match230-0.html#5',2,'match230-1.html#5',3)" NAME="5">(18-26)<TD><A HREF="javascript:ZweiFrames('match230-0.html#5',2,'match230-1.html#5',3)" NAME="5">(18-26)</A><TD ALIGN=center><FONT COLOR="#480000">17</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match230-0.html#6',2,'match230-1.html#6',3)" NAME="6">(174-182)<TD><A HREF="javascript:ZweiFrames('match230-0.html#6',2,'match230-1.html#6',3)" NAME="6">(243-251)</A><TD ALIGN=center><FONT COLOR="#3f0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovOptimData.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X
// File        : ibex_CovOptimData.cpp
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Nov 08, 2018
// Last update : Feb 28, 2019
//============================================================================

#include &quot;ibex_CovOptimData.h&quot;
#include &quot;ibex_Optimizer.h&quot;

#include &lt;algorithm&gt;
<A NAME="5"></A>
using namespace std;

<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match230-1.html#5',3,'match230-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>namespace ibex {

const unsigned int CovOptimData::FORMAT_VERSION = 1;

const unsigned int CovOptimData::subformat_level = 2;

const unsigned int CovOptimData::subformat_number = 1;

CovOptimData::CovOptimData(size_t n, bool is_extended_space) : CovList(n), data(new Data()), own_data(true) {</B></FONT>
	data-&gt;_optim_is_extended_space = is_extended_space;
	data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS; /* ? */
	data-&gt;_optim_uplo=NEG_INFINITY;
<A NAME="2"></A>	data-&gt;_optim_uplo_of_epsboxes = POS_INFINITY;
	data-&gt;_optim_loup = POS_INFINITY;
	if (n&gt;0) data-&gt;_optim_loup_point.resize(n);
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match230-1.html#2',3,'match230-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	data-&gt;_optim_time = -1;
	data-&gt;_optim_nb_cells = 0;
}

CovOptimData::CovOptimData(const char* filename) : CovOptimData((size_t) 0 /* tmp */) {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ifstream* f = CovOptimData::read(filename, *this, format_id, format_version);
	f-&gt;close();
	delete f;
}

CovOptimData::CovOptimData(const Cov&amp; cov, bool copy) : CovList(cov, copy) {
	const CovOptimData* covOptimData = dynamic_cast&lt;const CovOptimData*&gt;(&amp;cov);

	if (covOptimData) {
		if (copy) {
			data = new Data(*covOptimData-&gt;data); // implicit constructor is fine
			own_data = true;
		} else {
			data = covOptimData-&gt;data;
			own_data = false;
		}
	} else {
		data = new Data();
		data-&gt;_optim_is_extended_space = false;</B></FONT>
		data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS; /* ? */
		data-&gt;_optim_uplo=NEG_INFINITY;
		data-&gt;_optim_uplo_of_epsboxes = POS_INFINITY;
		data-&gt;_optim_loup = POS_INFINITY;
		data-&gt;_optim_loup_point.resize(n);
<A NAME="3"></A>		data-&gt;_optim_loup_point = IntervalVector::empty(cov.n);
		data-&gt;_optim_time = -1;
		data-&gt;_optim_nb_cells = 0;
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match230-1.html#3',3,'match230-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		own_data = true;
	}
}

CovOptimData::~CovOptimData() {
	if (own_data) {
		delete data;
	}
}

void CovOptimData::save(const char* filename) const {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ofstream* of=CovOptimData::write(filename, *this, format_id, format_version);
	of-&gt;close();
	delete of;
}</B></FONT>

ostream&amp; operator&lt;&lt;(ostream&amp; os, const CovOptimData&amp; optim) {

	os &lt;&lt; &quot; f* in [&quot; &lt;&lt; optim.uplo() &lt;&lt; &quot;,&quot; &lt;&lt; optim.loup() &lt;&lt; &quot;]&quot; &lt;&lt; endl;

	size_t i;

	if (optim.loup_point().is_empty()) {
		os &lt;&lt; &quot; no feasible point found.&quot; &lt;&lt; endl;
		i = 0;
<A NAME="0"></A>	} else {
		os &lt;&lt; &quot; x* ~  &quot; &lt;&lt; optim.loup_point() &lt;&lt; endl;
		i = 1;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match230-1.html#0',3,'match230-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	}

	for (size_t j=0; j&lt;optim.size()-i; j++) {
		os &lt;&lt; &quot; pending n°&quot; &lt;&lt; (j+1) &lt;&lt; &quot; = &quot; &lt;&lt; optim[i] &lt;&lt; endl;
	}

	return os;

}

void CovOptimData::read_vars(ifstream&amp; f, size_t n, vector&lt;string&gt;&amp; var_names) {
	char x;
	for (size_t i=0; i&lt;n; i++) {
		stringstream s;
		do {
			f.read(&amp;x, sizeof(char));
			if (f.eof()) ibex_error(&quot;[CovManifold]: unexpected end of file.&quot;);
			if (x!='\0') s &lt;&lt; x;
		} while(x!='\0');
		var_names.push_back(s.str());
	}
}

void CovOptimData::write_vars(ofstream&amp; f, const vector&lt;string&gt;&amp; var_names) {
	for (vector&lt;string&gt;::const_iterator it=var_names.begin(); it!=var_names.end(); it++) {
		f.write(it-&gt;c_str(),it-&gt;size()*sizeof(char));
		f.put('\0');
	}
}

ifstream* CovOptimData::read(const char* filename, CovOptimData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	ifstream* f = CovList::read(filename, cov, format_id, format_version);

	if (format_id.empty() || format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION) {
		cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS;
		cov.data-&gt;_optim_is_extended_space = false;
		cov.data-&gt;_optim_uplo = NEG_INFINITY;
		cov.data-&gt;_optim_loup = POS_INFINITY;</B></FONT>
		cov.data-&gt;_optim_loup_point.resize((int) cov.n);
<A NAME="1"></A>		cov.data-&gt;_optim_loup_point = IntervalVector::empty(cov.n);
		cov.data-&gt;_optim_time = -1;
		cov.data-&gt;_optim_nb_cells = 0;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match230-1.html#1',3,'match230-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	}
	else {
		format_id.pop();
		format_version.pop();

		read_vars(*f, cov.n, cov.data-&gt;_optim_var_names);

		unsigned int status = read_pos_int(*f);

		switch (status) {
		case 0: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS;           break;
		case 1: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::INFEASIBLE;        break;
		case 2: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::NO_FEASIBLE_FOUND; break;
		case 3: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::UNBOUNDED_OBJ;     break;
		case 4: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::TIME_OUT;     		break;
		case 5: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::UNREACHED_PREC;    break;
		default: ibex_error(&quot;[CovOptimData]: invalid optimizer status.&quot;);
		}

		cov.data-&gt;_optim_is_extended_space = (bool) read_pos_int(*f);
		cov.data-&gt;_optim_uplo              = read_double(*f);
		cov.data-&gt;_optim_uplo_of_epsboxes  = read_double(*f);</B></FONT>
		cov.data-&gt;_optim_loup              = read_double(*f);

		unsigned int loup_found   = read_pos_int(*f);
		unsigned int nb_var   = cov.is_extended_space() ? cov.n-1 : cov.n;
		cov.data-&gt;_optim_loup_point.resize((int) nb_var);
		// TODO: we assume here that the goal var is n-1
		cov.data-&gt;_optim_loup_point 		  = loup_found==1? cov[0].subvector(0,nb_var-1) : IntervalVector::empty(nb_var);

		cov.data-&gt;_optim_time              = read_double(*f);
<A NAME="6"></A>		cov.data-&gt;_optim_nb_cells          = read_pos_int(*f);
	}

<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match230-1.html#6',3,'match230-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return f;
}

ofstream* CovOptimData::write(const char* filename, const CovOptimData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);

	ofstream* f = CovList::write(filename, cov, format_id, format_version);</B></FONT>

	write_vars   (*f, cov.var_names());
	write_pos_int(*f, cov.optimizer_status());
	write_pos_int(*f, (uint32_t) cov.is_extended_space());
	write_double (*f, cov.uplo());
	write_double (*f, cov.uplo_of_epsboxes());
	write_double (*f, cov.loup());

	if (!cov.loup_point().is_empty()) {
		unsigned int nb_var   = cov.is_extended_space() ? cov.n-1 : cov.n;
		// TODO: we assume here that the goal var is n-1
		if (cov[0].subvector(0,nb_var-1)!=cov.loup_point()) {
			ibex_error(&quot;[CovOptimData] the first box in the list must be the 'loup-point'.&quot;);
		}
<A NAME="4"></A>		write_pos_int(*f, (uint32_t) 1);
	} else {
		write_pos_int(*f, (uint32_t) 0);
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match230-1.html#4',3,'match230-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	}

	write_double(*f, cov.time());
	write_pos_int   (*f, cov.nb_cells());

	return f;
}

void CovOptimData::format(stringstream&amp; ss, const string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);

	CovList::format(ss, title, format_id, format_version);

	ss
	&lt;&lt; space &lt;&lt; &quot; - n strings:      the names of variables. Each string is\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   terminated by the null character \'0\'.\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:      the status of the optimizer. Possible \n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   values are:\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 0=success\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 1=infeasible problem\n&quot;
	&lt;&lt; &quot;|   CovOptimData    |&quot; &lt;&lt;
	            &quot;                   - 2=no feasible point found\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 3=unbounded objective\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 4=time out\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 5=unreached precision\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:      1 &lt;=&gt; covering of the extended space\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                    (vars+obj), 0 &lt;=&gt; covering of the \n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   original space (variables only).\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 3 real values:  'uplo', 'uplo-of-epsboxes' and 'loup'\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   'uplo' is the uppest lower bound of f*\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   'loup' is the lowest upper bound of f*\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   so we have:       uplo&lt;= f* &lt;=loup.\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:      1 &lt;=&gt; the first box is the 'loup point'\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   (best feasible point found), possibly\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   extended (see above). 0 &lt;=&gt; no feasible\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   point found.\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 real value:   time (in seconds)\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:      number of cells.\n&quot;
	&lt;&lt; separator;
}

string CovOptimData::format() {
	stringstream ss;
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	format(ss, &quot;CovOptimData&quot;, format_id, format_version);
	return ss.str();
}

} // end namespace</B></FONT>

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovSolverData.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X
// File        : ibex_CovSolverData.cpp
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Nov 08, 2018
// Last update : Feb 28, 2019
//============================================================================

#include &quot;ibex_CovSolverData.h&quot;
#include &quot;ibex_Solver.h&quot;

#include &lt;algorithm&gt;
<A NAME="5"></A>
using namespace std;

<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match230-0.html#5',2,'match230-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>namespace ibex {

const unsigned int CovSolverData::FORMAT_VERSION = 2;

const unsigned int CovSolverData::subformat_level = 5;

const unsigned int CovSolverData::subformat_number = 0;

CovSolverData::CovSolverData(size_t n, size_t m, size_t nb_ineq, BoundaryType boundary_type, const vector&lt;string&gt;&amp; var_names) :</B></FONT>
		CovManifold(n, m, nb_ineq, boundary_type), data(new Data()), own_data(true) {
<A NAME="2"></A>
	data-&gt;_solver_var_names = var_names;
	data-&gt;_solver_solver_status = Solver::SUCCESS; /* ? */
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match230-0.html#2',2,'match230-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	data-&gt;_solver_time = -1;
	data-&gt;_solver_nb_cells = 0;
}

CovSolverData::CovSolverData(const char* filename) : CovSolverData(0, 0, 0 /* tmp */) {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ifstream* f = CovSolverData::read(filename, *this, format_id, format_version);
	f-&gt;close();
	delete f;
}

CovSolverData::CovSolverData(const Cov&amp; cov, bool copy) : CovManifold(cov, copy) {
	const CovSolverData* covSolverData = dynamic_cast&lt;const CovSolverData*&gt;(&amp;cov);

	if (covSolverData) {
		if (copy) {
			data = new Data(*covSolverData-&gt;data); // implicit constructor is fine
			own_data = true;
		} else {
			data = covSolverData-&gt;data;
			own_data = false;
		}
	} else {
		data = new Data();
		data-&gt;_solver_solver_status = Solver::SUCCESS; /* ? */</B></FONT>
		data-&gt;_solver_time = -1;
		data-&gt;_solver_nb_cells = 0;

		for (size_t i=0; i&lt;size(); i++) {
			switch(CovManifold::status(i)) {
			case CovManifold::SOLUTION :
				data-&gt;_solver_status.push_back(CovSolverData::SOLUTION);
				break;
			case CovManifold::BOUNDARY :
				data-&gt;_solver_status.push_back(CovSolverData::BOUNDARY);
				break;
			case CovManifold::UNKNOWN :
				data-&gt;_solver_status.push_back(CovSolverData::UNKNOWN);
				data-&gt;_solver_unknown.push_back(i);
<A NAME="3"></A>				break;
			}
		}
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match230-0.html#3',2,'match230-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		own_data = true;
	}
}

CovSolverData::~CovSolverData() {
	if (own_data) {
		delete data;
	}
}

void CovSolverData::save(const char* filename) const {
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	ofstream* of=CovSolverData::write(filename, *this, format_id, format_version);
	of-&gt;close();
	delete of;
}</B></FONT>

void CovSolverData::add(const IntervalVector&amp; x) {
	add_unknown(x);
}

void CovSolverData::add_inner(const IntervalVector&amp; x) {
	CovManifold::add_inner(x);
	data-&gt;_solver_status.push_back(SOLUTION);
}

void CovSolverData::add_boundary(const IntervalVector&amp; x, const VarSet&amp; varset) {
	CovManifold::add_boundary(x,varset);
	data-&gt;_solver_status.push_back(BOUNDARY);
}

void CovSolverData::add_unknown(const IntervalVector&amp; x) {
	CovManifold::add_unknown(x);
	data-&gt;_solver_status.push_back(UNKNOWN);
	data-&gt;_solver_unknown.push_back(size()-1);
}

void CovSolverData::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity, const VarSet&amp; varset) {
	CovManifold::add_solution(existence, unicity, varset);
	data-&gt;_solver_status.push_back(SOLUTION);
}

void CovSolverData::add_pending(const IntervalVector&amp; x) {
	CovManifold::add_unknown(x);
	data-&gt;_solver_status.push_back(PENDING);
	data-&gt;_solver_pending.push_back(size()-1);
}

ostream&amp; operator&lt;&lt;(ostream&amp; os, const CovSolverData&amp; solver) {

	for (size_t i=0; i&lt;solver.nb_solution(); i++) {
		os &lt;&lt; &quot; solution n°&quot; &lt;&lt; (i+1) &lt;&lt; &quot; = &quot; &lt;&lt; solver.solution(i) &lt;&lt; endl;
	}

	for (size_t i=0; i&lt;solver.nb_boundary(); i++) {
		os &lt;&lt; &quot; boundary n°&quot; &lt;&lt; (i+1) &lt;&lt; &quot; = &quot; &lt;&lt; solver.boundary(i) &lt;&lt; endl;
	}
<A NAME="0"></A>
	for (size_t i=0; i&lt;solver.nb_unknown(); i++) {
		os &lt;&lt; &quot; unknown n°&quot; &lt;&lt; (i+1) &lt;&lt; &quot; = &quot; &lt;&lt; solver.unknown(i) &lt;&lt; endl;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match230-0.html#0',2,'match230-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	}

	for (size_t i=0; i&lt;solver.nb_pending(); i++) {
		os &lt;&lt; &quot; pending n°&quot; &lt;&lt; (i+1) &lt;&lt; &quot; = &quot; &lt;&lt; solver.pending(i) &lt;&lt; endl;
	}

	return os;

}

void CovSolverData::read_vars(ifstream&amp; f, size_t n, vector&lt;string&gt;&amp; var_names) {
	char x;
	for (size_t i=0; i&lt;n; i++) {
		stringstream s;
		do {
			f.read(&amp;x, sizeof(char));
			if (f.eof()) ibex_error(&quot;[CovManifold]: unexpected end of file.&quot;);
			if (x!='\0') s &lt;&lt; x;
		} while(x!='\0');
		var_names.push_back(s.str());
	}
}

void CovSolverData::write_vars(ofstream&amp; f, const vector&lt;string&gt;&amp; var_names) {
	for (vector&lt;string&gt;::const_iterator it=var_names.begin(); it!=var_names.end(); it++) {
		f.write(it-&gt;c_str(),it-&gt;size()*sizeof(char));
		f.put('\0');
	}
}

ifstream* CovSolverData::read(const char* filename, CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	ifstream* f = CovManifold::read(filename, cov, format_id, format_version);

	size_t nb_pending;

	if (format_id.empty() || format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION) {
		cout &lt;&lt; &quot;here\n&quot;;
		cov.data-&gt;_solver_solver_status = (unsigned int) Solver::SUCCESS;
<A NAME="1"></A>		cov.data-&gt;_solver_time = -1;
		cov.data-&gt;_solver_nb_cells = 0;
		nb_pending = 0;</B></FONT>
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match230-0.html#1',2,'match230-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	}
	else {
		format_id.pop();
		format_version.pop();

		read_vars(*f, cov.n, cov.data-&gt;_solver_var_names);

		unsigned int status = read_pos_int(*f);

		switch (status) {
		case 0: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::SUCCESS;           break;
		case 1: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::INFEASIBLE;        break;
		case 2: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::NOT_ALL_VALIDATED; break;
		case 3: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::TIME_OUT;          break;
		case 4: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::CELL_OVERFLOW;     break;
		case 5: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::USER_BREAK;        break;
		default: ibex_error(&quot;[CovSolverData]: invalid solver status.&quot;);
		}

		cov.data-&gt;_solver_time = read_double(*f);
		cov.data-&gt;_solver_nb_cells = read_pos_int(*f);

		nb_pending = read_pos_int(*f);</B></FONT>

		if (nb_pending &gt; cov.CovManifold::nb_unknown())
			ibex_error(&quot;[CovSolverData]: number of pending boxes &gt; number of CovManifold unknown boxes&quot;);

		for (size_t i=0; i&lt;nb_pending; i++) {
			uint32_t j=read_pos_int(*f);
			if (!cov.data-&gt;_solver_pending.empty()) { // check ordering
				if (j&lt;cov.data-&gt;_solver_pending.back())
					ibex_error(&quot;[CovSolverData]: indices of pending boxes are not in increasing order.&quot;);
				if (j==cov.data-&gt;_solver_pending.back())
					ibex_error(&quot;[CovSolverData]: duplicated index of pending box.&quot;);
			}
			cov.data-&gt;_solver_pending.push_back(j);
		}
	}


	vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_solver_pending.begin(); // iterator of pending boxes

	for (size_t i=0; i&lt;cov.size(); i++) {

		if (it!=cov.data-&gt;_solver_pending.end() &amp;&amp; i==*it) {
			if (!cov.CovManifold::is_unknown(i))
				ibex_error(&quot;[CovSolverData]: a pending box must be a CovManifold unknown box.&quot;);
			cov.data-&gt;_solver_status.push_back(CovSolverData::PENDING);
			++it;
		} else {
			switch(cov.CovManifold::status(i)) {
			case CovManifold::SOLUTION :
				cov.data-&gt;_solver_status.push_back(CovSolverData::SOLUTION);
				break;
			case CovManifold::BOUNDARY :
				cov.data-&gt;_solver_status.push_back(CovSolverData::BOUNDARY);
				break;
			default :
				cov.data-&gt;_solver_unknown.push_back(i);
				cov.data-&gt;_solver_status.push_back(CovSolverData::UNKNOWN);
			}
		}

<A NAME="6"></A>	}
	if (it!=cov.data-&gt;_solver_pending.end()) ibex_error(&quot;[CovSolverData]: invalid pending box index.&quot;);

<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match230-0.html#6',2,'match230-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return f;
}

ofstream* CovSolverData::write(const char* filename, const CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {

	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);

	ofstream* f = CovManifold::write(filename, cov, format_id, format_version);</B></FONT>

	write_vars(*f, cov.data-&gt;_solver_var_names);
	write_pos_int(*f, cov.data-&gt;_solver_solver_status);
	write_double(*f, cov.data-&gt;_solver_time);
	write_pos_int(*f, cov.data-&gt;_solver_nb_cells);
	write_pos_int(*f, cov.nb_pending());


<A NAME="4"></A>	for (vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_solver_pending.begin(); it!=cov.data-&gt;_solver_pending.end(); ++it) {
		assert(*it&lt;numeric_limits&lt;uint32_t&gt;::max());
		write_pos_int(*f, (uint32_t) *it);
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match230-0.html#4',2,'match230-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	}

	return f;
}

void CovSolverData::format(stringstream&amp; ss, const string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
	format_id.push(subformat_number);
	format_version.push(FORMAT_VERSION);

	CovManifold::format(ss, title, format_id, format_version);

	ss
	&lt;&lt; space &lt;&lt; &quot; - n strings:      the names of variables. Each string is\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   terminated by the null character \'\\0\'.\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:      the status of the search. Possible \n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   values are:\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 0=complete search: all output boxes\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                     are validated\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 1=complete search: infeasible problem\n&quot;
	&lt;&lt; &quot;|   CovSolverData   |&quot; &lt;&lt;
	            &quot;                   - 2=incomplete search: minimal width\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                     (--eps-min) reached\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 3=incomplete search: time out\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 4=incomplete search: buffer overflow\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   - 5=incomplete search: user break\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 real value:   time (in seconds)\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 integer:      the number of cells.\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - 1 value:        the number Np of pending boxes\n&quot;
	&lt;&lt; space &lt;&lt; &quot; - Np integers:    the indices of pending boxes\n&quot;
	&lt;&lt; space &lt;&lt; &quot;                   (a subset of CovIUList unknown boxes).\n&quot;
	&lt;&lt; separator;
}

string CovSolverData::format() {
	stringstream ss;
	stack&lt;unsigned int&gt; format_id;
	stack&lt;unsigned int&gt; format_version;
	format(ss, &quot;CovSolverData&quot;, format_id, format_version);
	return ss.str();
}

} // end namespace</B></FONT>

</PRE>
</div>
  </div>
</body>
</html>
