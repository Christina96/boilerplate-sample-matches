<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_CovOptimData.cpp &amp; ibex_CovSolverData.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_CovOptimData.cpp &amp; ibex_CovSolverData.cpp
      </h3>
<h1 align="center">
        69.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_CovOptimData.cpp (78.305084%)<th>ibex_CovSolverData.cpp (62.77174%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-135)<td><a href="#" name="0">(135-176)</a><td align="center"><font color="#ff0000">60</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(140-161)<td><a href="#" name="1">(177-199)</a><td align="center"><font color="#d00000">49</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(33-58)<td><a href="#" name="2">(31-56)</a><td align="center"><font color="#ae0000">41</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(67-83)<td><a href="#" name="3">(74-90)</a><td align="center"><font color="#6a0000">25</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(200-250)<td><a href="#" name="4">(263-304)</a><td align="center"><font color="#660000">24</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(18-26)<td><a href="#" name="5">(18-26)</a><td align="center"><font color="#480000">17</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(174-182)<td><a href="#" name="6">(243-251)</a><td align="center"><font color="#3f0000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovOptimData.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_CovOptimData.h"
2 #include "ibex_Optimizer.h"
3 #include &lt;algorithm&gt;
4 <a name="5"></a>
5 using namespace std;
6 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>namespace ibex {
7 const unsigned int CovOptimData::FORMAT_VERSION = 1;
8 const unsigned int CovOptimData::subformat_level = 2;
9 const unsigned int CovOptimData::subformat_number = 1;
10 CovOptimData::CovOptimData(size_t n, bool is_extended_space) : CovList(n), data(new Data()), own_data(true) {</b></font>
11 	data-&gt;_optim_is_extended_space = is_extended_space;
12 	data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS; 	data-&gt;_optim_uplo=NEG_INFINITY;
13 <a name="2"></a>	data-&gt;_optim_uplo_of_epsboxes = POS_INFINITY;
14 	data-&gt;_optim_loup = POS_INFINITY;
15 	if (n&gt;0) data-&gt;_optim_loup_point.resize(n);
16 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	data-&gt;_optim_time = -1;
17 	data-&gt;_optim_nb_cells = 0;
18 }
19 CovOptimData::CovOptimData(const char* filename) : CovOptimData((size_t) 0 	stack&lt;unsigned int&gt; format_id;
20 	stack&lt;unsigned int&gt; format_version;
21 	ifstream* f = CovOptimData::read(filename, *this, format_id, format_version);
22 	f-&gt;close();
23 	delete f;
24 }
25 CovOptimData::CovOptimData(const Cov&amp; cov, bool copy) : CovList(cov, copy) {
26 	const CovOptimData* covOptimData = dynamic_cast&lt;const CovOptimData*&gt;(&amp;cov);
27 	if (covOptimData) {
28 		if (copy) {
29 			data = new Data(*covOptimData-&gt;data); 			own_data = true;
30 		} else {
31 			data = covOptimData-&gt;data;
32 			own_data = false;
33 		}
34 	} else {
35 		data = new Data();
36 		data-&gt;_optim_is_extended_space = false;</b></font>
37 		data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS; 		data-&gt;_optim_uplo=NEG_INFINITY;
38 		data-&gt;_optim_uplo_of_epsboxes = POS_INFINITY;
39 		data-&gt;_optim_loup = POS_INFINITY;
40 		data-&gt;_optim_loup_point.resize(n);
41 <a name="3"></a>		data-&gt;_optim_loup_point = IntervalVector::empty(cov.n);
42 		data-&gt;_optim_time = -1;
43 		data-&gt;_optim_nb_cells = 0;
44 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		own_data = true;
45 	}
46 }
47 CovOptimData::~CovOptimData() {
48 	if (own_data) {
49 		delete data;
50 	}
51 }
52 void CovOptimData::save(const char* filename) const {
53 	stack&lt;unsigned int&gt; format_id;
54 	stack&lt;unsigned int&gt; format_version;
55 	ofstream* of=CovOptimData::write(filename, *this, format_id, format_version);
56 	of-&gt;close();
57 	delete of;
58 }</b></font>
59 ostream&amp; operator&lt;&lt;(ostream&amp; os, const CovOptimData&amp; optim) {
60 	os &lt;&lt; " f* in [" &lt;&lt; optim.uplo() &lt;&lt; "," &lt;&lt; optim.loup() &lt;&lt; "]" &lt;&lt; endl;
61 	size_t i;
62 	if (optim.loup_point().is_empty()) {
63 		os &lt;&lt; " no feasible point found." &lt;&lt; endl;
64 		i = 0;
65 <a name="0"></a>	} else {
66 		os &lt;&lt; " x* ~  " &lt;&lt; optim.loup_point() &lt;&lt; endl;
67 		i = 1;
68 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
69 	for (size_t j=0; j&lt;optim.size()-i; j++) {
70 		os &lt;&lt; " pending n°" &lt;&lt; (j+1) &lt;&lt; " = " &lt;&lt; optim[i] &lt;&lt; endl;
71 	}
72 	return os;
73 }
74 void CovOptimData::read_vars(ifstream&amp; f, size_t n, vector&lt;string&gt;&amp; var_names) {
75 	char x;
76 	for (size_t i=0; i&lt;n; i++) {
77 		stringstream s;
78 		do {
79 			f.read(&amp;x, sizeof(char));
80 			if (f.eof()) ibex_error("[CovManifold]: unexpected end of file.");
81 			if (x!='\0') s &lt;&lt; x;
82 		} while(x!='\0');
83 		var_names.push_back(s.str());
84 	}
85 }
86 void CovOptimData::write_vars(ofstream&amp; f, const vector&lt;string&gt;&amp; var_names) {
87 	for (vector&lt;string&gt;::const_iterator it=var_names.begin(); it!=var_names.end(); it++) {
88 		f.write(it-&gt;c_str(),it-&gt;size()*sizeof(char));
89 		f.put('\0');
90 	}
91 }
92 ifstream* CovOptimData::read(const char* filename, CovOptimData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
93 	ifstream* f = CovList::read(filename, cov, format_id, format_version);
94 	if (format_id.empty() || format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION) {
95 		cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS;
96 		cov.data-&gt;_optim_is_extended_space = false;
97 		cov.data-&gt;_optim_uplo = NEG_INFINITY;
98 		cov.data-&gt;_optim_loup = POS_INFINITY;</b></font>
99 		cov.data-&gt;_optim_loup_point.resize((int) cov.n);
100 <a name="1"></a>		cov.data-&gt;_optim_loup_point = IntervalVector::empty(cov.n);
101 		cov.data-&gt;_optim_time = -1;
102 		cov.data-&gt;_optim_nb_cells = 0;
103 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
104 	else {
105 		format_id.pop();
106 		format_version.pop();
107 		read_vars(*f, cov.n, cov.data-&gt;_optim_var_names);
108 		unsigned int status = read_pos_int(*f);
109 		switch (status) {
110 		case 0: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::SUCCESS;           break;
111 		case 1: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::INFEASIBLE;        break;
112 		case 2: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::NO_FEASIBLE_FOUND; break;
113 		case 3: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::UNBOUNDED_OBJ;     break;
114 		case 4: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::TIME_OUT;     		break;
115 		case 5: cov.data-&gt;_optim_optimizer_status = (unsigned int) Optimizer::UNREACHED_PREC;    break;
116 		default: ibex_error("[CovOptimData]: invalid optimizer status.");
117 		}
118 		cov.data-&gt;_optim_is_extended_space = (bool) read_pos_int(*f);
119 		cov.data-&gt;_optim_uplo              = read_double(*f);
120 		cov.data-&gt;_optim_uplo_of_epsboxes  = read_double(*f);</b></font>
121 		cov.data-&gt;_optim_loup              = read_double(*f);
122 		unsigned int loup_found   = read_pos_int(*f);
123 		unsigned int nb_var   = cov.is_extended_space() ? cov.n-1 : cov.n;
124 		cov.data-&gt;_optim_loup_point.resize((int) nb_var);
125 		cov.data-&gt;_optim_loup_point 		  = loup_found==1? cov[0].subvector(0,nb_var-1) : IntervalVector::empty(nb_var);
126 		cov.data-&gt;_optim_time              = read_double(*f);
127 <a name="6"></a>		cov.data-&gt;_optim_nb_cells          = read_pos_int(*f);
128 	}
129 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return f;
130 }
131 ofstream* CovOptimData::write(const char* filename, const CovOptimData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
132 	format_id.push(subformat_number);
133 	format_version.push(FORMAT_VERSION);
134 	ofstream* f = CovList::write(filename, cov, format_id, format_version);</b></font>
135 	write_vars   (*f, cov.var_names());
136 	write_pos_int(*f, cov.optimizer_status());
137 	write_pos_int(*f, (uint32_t) cov.is_extended_space());
138 	write_double (*f, cov.uplo());
139 	write_double (*f, cov.uplo_of_epsboxes());
140 	write_double (*f, cov.loup());
141 	if (!cov.loup_point().is_empty()) {
142 		unsigned int nb_var   = cov.is_extended_space() ? cov.n-1 : cov.n;
143 		if (cov[0].subvector(0,nb_var-1)!=cov.loup_point()) {
144 			ibex_error("[CovOptimData] the first box in the list must be the 'loup-point'.");
145 		}
146 <a name="4"></a>		write_pos_int(*f, (uint32_t) 1);
147 	} else {
148 		write_pos_int(*f, (uint32_t) 0);
149 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
150 	write_double(*f, cov.time());
151 	write_pos_int   (*f, cov.nb_cells());
152 	return f;
153 }
154 void CovOptimData::format(stringstream&amp; ss, const string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
155 	format_id.push(subformat_number);
156 	format_version.push(FORMAT_VERSION);
157 	CovList::format(ss, title, format_id, format_version);
158 	ss
159 	&lt;&lt; space &lt;&lt; " - n strings:      the names of variables. Each string is\n"
160 	&lt;&lt; space &lt;&lt; "                   terminated by the null character \'0\'.\n"
161 	&lt;&lt; space &lt;&lt; " - 1 integer:      the status of the optimizer. Possible \n"
162 	&lt;&lt; space &lt;&lt; "                   values are:\n"
163 	&lt;&lt; space &lt;&lt; "                   - 0=success\n"
164 	&lt;&lt; space &lt;&lt; "                   - 1=infeasible problem\n"
165 	&lt;&lt; "|   CovOptimData    |" &lt;&lt;
166 	            "                   - 2=no feasible point found\n"
167 	&lt;&lt; space &lt;&lt; "                   - 3=unbounded objective\n"
168 	&lt;&lt; space &lt;&lt; "                   - 4=time out\n"
169 	&lt;&lt; space &lt;&lt; "                   - 5=unreached precision\n"
170 	&lt;&lt; space &lt;&lt; " - 1 integer:      1 &lt;=&gt; covering of the extended space\n"
171 	&lt;&lt; space &lt;&lt; "                    (vars+obj), 0 &lt;=&gt; covering of the \n"
172 	&lt;&lt; space &lt;&lt; "                   original space (variables only).\n"
173 	&lt;&lt; space &lt;&lt; " - 3 real values:  'uplo', 'uplo-of-epsboxes' and 'loup'\n"
174 	&lt;&lt; space &lt;&lt; "                   'uplo' is the uppest lower bound of f*\n"
175 	&lt;&lt; space &lt;&lt; "                   'loup' is the lowest upper bound of f*\n"
176 	&lt;&lt; space &lt;&lt; "                   so we have:       uplo&lt;= f* &lt;=loup.\n"
177 	&lt;&lt; space &lt;&lt; " - 1 integer:      1 &lt;=&gt; the first box is the 'loup point'\n"
178 	&lt;&lt; space &lt;&lt; "                   (best feasible point found), possibly\n"
179 	&lt;&lt; space &lt;&lt; "                   extended (see above). 0 &lt;=&gt; no feasible\n"
180 	&lt;&lt; space &lt;&lt; "                   point found.\n"
181 	&lt;&lt; space &lt;&lt; " - 1 real value:   time (in seconds)\n"
182 	&lt;&lt; space &lt;&lt; " - 1 integer:      number of cells.\n"
183 	&lt;&lt; separator;
184 }
185 string CovOptimData::format() {
186 	stringstream ss;
187 	stack&lt;unsigned int&gt; format_id;
188 	stack&lt;unsigned int&gt; format_version;
189 	format(ss, "CovOptimData", format_id, format_version);
190 	return ss.str();
191 }
192 } 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovSolverData.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_CovSolverData.h"
2 #include "ibex_Solver.h"
3 #include &lt;algorithm&gt;
4 <a name="5"></a>
5 using namespace std;
6 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>namespace ibex {
7 const unsigned int CovSolverData::FORMAT_VERSION = 2;
8 const unsigned int CovSolverData::subformat_level = 5;
9 const unsigned int CovSolverData::subformat_number = 0;
10 CovSolverData::CovSolverData(size_t n, size_t m, size_t nb_ineq, BoundaryType boundary_type, const vector&lt;string&gt;&amp; var_names) :</b></font>
11 		CovManifold(n, m, nb_ineq, boundary_type), data(new Data()), own_data(true) {
12 <a name="2"></a>
13 	data-&gt;_solver_var_names = var_names;
14 	data-&gt;_solver_solver_status = Solver::SUCCESS; <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	data-&gt;_solver_time = -1;
15 	data-&gt;_solver_nb_cells = 0;
16 }
17 CovSolverData::CovSolverData(const char* filename) : CovSolverData(0, 0, 0 	stack&lt;unsigned int&gt; format_id;
18 	stack&lt;unsigned int&gt; format_version;
19 	ifstream* f = CovSolverData::read(filename, *this, format_id, format_version);
20 	f-&gt;close();
21 	delete f;
22 }
23 CovSolverData::CovSolverData(const Cov&amp; cov, bool copy) : CovManifold(cov, copy) {
24 	const CovSolverData* covSolverData = dynamic_cast&lt;const CovSolverData*&gt;(&amp;cov);
25 	if (covSolverData) {
26 		if (copy) {
27 			data = new Data(*covSolverData-&gt;data); 			own_data = true;
28 		} else {
29 			data = covSolverData-&gt;data;
30 			own_data = false;
31 		}
32 	} else {
33 		data = new Data();
34 		data-&gt;_solver_solver_status = Solver::SUCCESS; 		data-&gt;_solver_time = -1;
35 		data-&gt;_solver_nb_cells = 0;
36 		for (size_t i=0; i&lt;size(); i++) {
37 			switch(CovManifold::status(i)) {
38 			case CovManifold::SOLUTION :
39 				data-&gt;_solver_status.push_back(CovSolverData::SOLUTION);
40 				break;
41 			case CovManifold::BOUNDARY :
42 				data-&gt;_solver_status.push_back(CovSolverData::BOUNDARY);
43 				break;
44 			case CovManifold::UNKNOWN :
45 				data-&gt;_solver_status.push_back(CovSolverData::UNKNOWN);
46 				data-&gt;_solver_unknown.push_back(i);
47 <a name="3"></a>				break;
48 			}
49 		}
50 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		own_data = true;
51 	}
52 }
53 CovSolverData::~CovSolverData() {
54 	if (own_data) {
55 		delete data;
56 	}
57 }
58 void CovSolverData::save(const char* filename) const {
59 	stack&lt;unsigned int&gt; format_id;
60 	stack&lt;unsigned int&gt; format_version;
61 	ofstream* of=CovSolverData::write(filename, *this, format_id, format_version);
62 	of-&gt;close();
63 	delete of;
64 }</b></font>
65 void CovSolverData::add(const IntervalVector&amp; x) {
66 	add_unknown(x);
67 }
68 void CovSolverData::add_inner(const IntervalVector&amp; x) {
69 	CovManifold::add_inner(x);
70 	data-&gt;_solver_status.push_back(SOLUTION);
71 }
72 void CovSolverData::add_boundary(const IntervalVector&amp; x, const VarSet&amp; varset) {
73 	CovManifold::add_boundary(x,varset);
74 	data-&gt;_solver_status.push_back(BOUNDARY);
75 }
76 void CovSolverData::add_unknown(const IntervalVector&amp; x) {
77 	CovManifold::add_unknown(x);
78 	data-&gt;_solver_status.push_back(UNKNOWN);
79 	data-&gt;_solver_unknown.push_back(size()-1);
80 }
81 void CovSolverData::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity, const VarSet&amp; varset) {
82 	CovManifold::add_solution(existence, unicity, varset);
83 	data-&gt;_solver_status.push_back(SOLUTION);
84 }
85 void CovSolverData::add_pending(const IntervalVector&amp; x) {
86 	CovManifold::add_unknown(x);
87 	data-&gt;_solver_status.push_back(PENDING);
88 	data-&gt;_solver_pending.push_back(size()-1);
89 }
90 ostream&amp; operator&lt;&lt;(ostream&amp; os, const CovSolverData&amp; solver) {
91 	for (size_t i=0; i&lt;solver.nb_solution(); i++) {
92 		os &lt;&lt; " solution n°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; solver.solution(i) &lt;&lt; endl;
93 	}
94 	for (size_t i=0; i&lt;solver.nb_boundary(); i++) {
95 		os &lt;&lt; " boundary n°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; solver.boundary(i) &lt;&lt; endl;
96 	}
97 <a name="0"></a>
98 	for (size_t i=0; i&lt;solver.nb_unknown(); i++) {
99 		os &lt;&lt; " unknown n°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; solver.unknown(i) &lt;&lt; endl;
100 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
101 	for (size_t i=0; i&lt;solver.nb_pending(); i++) {
102 		os &lt;&lt; " pending n°" &lt;&lt; (i+1) &lt;&lt; " = " &lt;&lt; solver.pending(i) &lt;&lt; endl;
103 	}
104 	return os;
105 }
106 void CovSolverData::read_vars(ifstream&amp; f, size_t n, vector&lt;string&gt;&amp; var_names) {
107 	char x;
108 	for (size_t i=0; i&lt;n; i++) {
109 		stringstream s;
110 		do {
111 			f.read(&amp;x, sizeof(char));
112 			if (f.eof()) ibex_error("[CovManifold]: unexpected end of file.");
113 			if (x!='\0') s &lt;&lt; x;
114 		} while(x!='\0');
115 		var_names.push_back(s.str());
116 	}
117 }
118 void CovSolverData::write_vars(ofstream&amp; f, const vector&lt;string&gt;&amp; var_names) {
119 	for (vector&lt;string&gt;::const_iterator it=var_names.begin(); it!=var_names.end(); it++) {
120 		f.write(it-&gt;c_str(),it-&gt;size()*sizeof(char));
121 		f.put('\0');
122 	}
123 }
124 ifstream* CovSolverData::read(const char* filename, CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
125 	ifstream* f = CovManifold::read(filename, cov, format_id, format_version);
126 	size_t nb_pending;
127 	if (format_id.empty() || format_id.top()!=subformat_number || format_version.top()!=FORMAT_VERSION) {
128 		cout &lt;&lt; "here\n";
129 		cov.data-&gt;_solver_solver_status = (unsigned int) Solver::SUCCESS;
130 <a name="1"></a>		cov.data-&gt;_solver_time = -1;
131 		cov.data-&gt;_solver_nb_cells = 0;
132 		nb_pending = 0;</b></font>
133 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
134 	else {
135 		format_id.pop();
136 		format_version.pop();
137 		read_vars(*f, cov.n, cov.data-&gt;_solver_var_names);
138 		unsigned int status = read_pos_int(*f);
139 		switch (status) {
140 		case 0: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::SUCCESS;           break;
141 		case 1: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::INFEASIBLE;        break;
142 		case 2: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::NOT_ALL_VALIDATED; break;
143 		case 3: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::TIME_OUT;          break;
144 		case 4: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::CELL_OVERFLOW;     break;
145 		case 5: cov.data-&gt;_solver_solver_status = (unsigned int) Solver::USER_BREAK;        break;
146 		default: ibex_error("[CovSolverData]: invalid solver status.");
147 		}
148 		cov.data-&gt;_solver_time = read_double(*f);
149 		cov.data-&gt;_solver_nb_cells = read_pos_int(*f);
150 		nb_pending = read_pos_int(*f);</b></font>
151 		if (nb_pending &gt; cov.CovManifold::nb_unknown())
152 			ibex_error("[CovSolverData]: number of pending boxes &gt; number of CovManifold unknown boxes");
153 		for (size_t i=0; i&lt;nb_pending; i++) {
154 			uint32_t j=read_pos_int(*f);
155 			if (!cov.data-&gt;_solver_pending.empty()) { 				if (j&lt;cov.data-&gt;_solver_pending.back())
156 					ibex_error("[CovSolverData]: indices of pending boxes are not in increasing order.");
157 				if (j==cov.data-&gt;_solver_pending.back())
158 					ibex_error("[CovSolverData]: duplicated index of pending box.");
159 			}
160 			cov.data-&gt;_solver_pending.push_back(j);
161 		}
162 	}
163 	vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_solver_pending.begin(); 
164 	for (size_t i=0; i&lt;cov.size(); i++) {
165 		if (it!=cov.data-&gt;_solver_pending.end() &amp;&amp; i==*it) {
166 			if (!cov.CovManifold::is_unknown(i))
167 				ibex_error("[CovSolverData]: a pending box must be a CovManifold unknown box.");
168 			cov.data-&gt;_solver_status.push_back(CovSolverData::PENDING);
169 			++it;
170 		} else {
171 			switch(cov.CovManifold::status(i)) {
172 			case CovManifold::SOLUTION :
173 				cov.data-&gt;_solver_status.push_back(CovSolverData::SOLUTION);
174 				break;
175 			case CovManifold::BOUNDARY :
176 				cov.data-&gt;_solver_status.push_back(CovSolverData::BOUNDARY);
177 				break;
178 			default :
179 				cov.data-&gt;_solver_unknown.push_back(i);
180 				cov.data-&gt;_solver_status.push_back(CovSolverData::UNKNOWN);
181 			}
182 		}
183 <a name="6"></a>	}
184 	if (it!=cov.data-&gt;_solver_pending.end()) ibex_error("[CovSolverData]: invalid pending box index.");
185 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return f;
186 }
187 ofstream* CovSolverData::write(const char* filename, const CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
188 	format_id.push(subformat_number);
189 	format_version.push(FORMAT_VERSION);
190 	ofstream* f = CovManifold::write(filename, cov, format_id, format_version);</b></font>
191 	write_vars(*f, cov.data-&gt;_solver_var_names);
192 	write_pos_int(*f, cov.data-&gt;_solver_solver_status);
193 	write_double(*f, cov.data-&gt;_solver_time);
194 	write_pos_int(*f, cov.data-&gt;_solver_nb_cells);
195 	write_pos_int(*f, cov.nb_pending());
196 <a name="4"></a>	for (vector&lt;size_t&gt;::const_iterator it=cov.data-&gt;_solver_pending.begin(); it!=cov.data-&gt;_solver_pending.end(); ++it) {
197 		assert(*it&lt;numeric_limits&lt;uint32_t&gt;::max());
198 		write_pos_int(*f, (uint32_t) *it);
199 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
200 	return f;
201 }
202 void CovSolverData::format(stringstream&amp; ss, const string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version) {
203 	format_id.push(subformat_number);
204 	format_version.push(FORMAT_VERSION);
205 	CovManifold::format(ss, title, format_id, format_version);
206 	ss
207 	&lt;&lt; space &lt;&lt; " - n strings:      the names of variables. Each string is\n"
208 	&lt;&lt; space &lt;&lt; "                   terminated by the null character \'\\0\'.\n"
209 	&lt;&lt; space &lt;&lt; " - 1 integer:      the status of the search. Possible \n"
210 	&lt;&lt; space &lt;&lt; "                   values are:\n"
211 	&lt;&lt; space &lt;&lt; "                   - 0=complete search: all output boxes\n"
212 	&lt;&lt; space &lt;&lt; "                     are validated\n"
213 	&lt;&lt; space &lt;&lt; "                   - 1=complete search: infeasible problem\n"
214 	&lt;&lt; "|   CovSolverData   |" &lt;&lt;
215 	            "                   - 2=incomplete search: minimal width\n"
216 	&lt;&lt; space &lt;&lt; "                     (--eps-min) reached\n"
217 	&lt;&lt; space &lt;&lt; "                   - 3=incomplete search: time out\n"
218 	&lt;&lt; space &lt;&lt; "                   - 4=incomplete search: buffer overflow\n"
219 	&lt;&lt; space &lt;&lt; "                   - 5=incomplete search: user break\n"
220 	&lt;&lt; space &lt;&lt; " - 1 real value:   time (in seconds)\n"
221 	&lt;&lt; space &lt;&lt; " - 1 integer:      the number of cells.\n"
222 	&lt;&lt; space &lt;&lt; " - 1 value:        the number Np of pending boxes\n"
223 	&lt;&lt; space &lt;&lt; " - Np integers:    the indices of pending boxes\n"
224 	&lt;&lt; space &lt;&lt; "                   (a subset of CovIUList unknown boxes).\n"
225 	&lt;&lt; separator;
226 }
227 string CovSolverData::format() {
228 	stringstream ss;
229 	stack&lt;unsigned int&gt; format_id;
230 	stack&lt;unsigned int&gt; format_version;
231 	format(ss, "CovSolverData", format_id, format_version);
232 	return ss.str();
233 }
234 } 
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
