
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <string>
3  #include <mutex>
4  #include <numeric>
5  #include <inja.hpp>
6  #include <yaml-cpp/yaml.h>
7  #include "../config/binding.h"
8  #include "../generator/config/nodemanip.h"
9  #include "../generator/config/ruleconvert.h"
10  #include "../generator/config/subexport.h"
11  #include "../generator/template/templates.h"
12  #include "../script/cron.h"
13  #include "../script/script_quickjs.h"
14  #include "../server/webserver.h"
15  #include "../utils/base64/base64.h"
16  #include "../utils/file_extra.h"
17  #include "../utils/ini_reader/ini_reader.h"
18  #include "../utils/logger.h"
19  #include "../utils/network.h"
20  #include "../utils/regexp.h"
21  #include "../utils/stl_extra.h"
22  #include "../utils/string.h"
23  #include "../utils/string_hash.h"
24  #include "../utils/system.h"
25  #include "../utils/system.h"
26  #include "../utils/urlencode.h"
27  #include "../utils/yamlcpp_extra.h"
28  #include "interfaces.h"
29  #include "multithread.h"
30  #include "settings.h"
31  #include "upload.h"
32  #include "webget.h"
33  extern WebServer webServer;
34  string_array gRegexBlacklist = {"(.*)*"};
35  void refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array);
36  std::string parseProxy(const std::string &source)
37  {
38      std::string proxy = source;
39      if(source == "SYSTEM")
40          proxy = getSystemProxy();
41      else if(source == "NONE")
42          proxy = "";
43      return proxy;
44  }
45  extern string_array ClashRuleTypes, SurgeRuleTypes, QuanXRuleTypes;
46  struct UAProfile
47  {
48      std::string head;
49      std::string version_match;
50      std::string version_target;
51      std::string target;
52      tribool clash_new_name = tribool();
53      int surge_ver = -1;
54  };
55  const std::vector<UAProfile> UAMatchList = {
56      {"ClashForAndroid","\\/([0-9.]+)","2.0","clash",true},
57      {"ClashForAndroid","\\/([0-9.]+)R","","clashr",false},
58      {"ClashForAndroid","","","clash",false},
59      {"ClashforWindows","\\/([0-9.]+)","0.11","clash",true},
60      {"ClashforWindows","","","clash",false},
61      {"ClashX Pro","","","clash",true},
62      {"ClashX","\\/([0-9.]+)","0.13","clash",true},
63      {"Clash","","","clash",true},
64      {"Kitsunebi","","","v2ray"},
65      {"Loon","","","loon"},
66      {"Pharos","","","mixed"},
67      {"Potatso","","","mixed"},
68      {"Quantumult%20X","","","quanx"},
69      {"Quantumult","","","quan"},
70      {"Qv2ray","","","v2ray"},
71      {"Shadowrocket","","","mixed"},
72      {"Surfboard","","","surfboard"},
73      {"Surge","\\/([0-9.]+).*x86","906","surge",false,4}, 
74      {"Surge","\\/([0-9.]+).*x86","368","surge",false,3}, 
75      {"Surge","\\/([0-9.]+)","1419","surge",false,4}, 
76      {"Surge","\\/([0-9.]+)","900","surge",false,3}, 
77      {"Surge","","","surge",false,2}, 
78      {"Trojan-Qt5","","","trojan"},
79      {"V2rayU","","","v2ray"},
80      {"V2RayX","","","v2ray"}
81  };
82  bool verGreaterEqual(const std::string &src_ver, const std::string &target_ver)
83  {
84      string_size src_pos_beg = 0, src_pos_end, target_pos_beg = 0, target_pos_end;
85      while(true)
86      {
87          src_pos_end = src_ver.find('.', src_pos_beg);
88          if(src_pos_end == src_ver.npos)
89              src_pos_end = src_ver.size();
90          int part_src = std::stoi(src_ver.substr(src_pos_beg, src_pos_end - src_pos_beg));
91          target_pos_end = target_ver.find('.', target_pos_beg);
92          if(target_pos_end == target_ver.npos)
93              target_pos_end = target_ver.size();
94          int part_target = std::stoi(target_ver.substr(target_pos_beg, target_pos_end - target_pos_beg));
95          if(part_src > part_target)
96              break;
97          else if(part_src < part_target)
98              return false;
99          else if(src_pos_end >= src_ver.size() - 1 || target_pos_end >= target_ver.size() - 1)
100              break;
101          src_pos_beg = src_pos_end + 1;
102          target_pos_beg = target_pos_end + 1;
103      }
104      return true;
105  }
106  void matchUserAgent(const std::string &user_agent, std::string &target, tribool &clash_new_name, int &surge_ver)
107  {
108      if(user_agent.empty())
109          return;
110      for(const UAProfile &x : UAMatchList)
111      {
112          if(startsWith(user_agent, x.head))
113          {
114              if(!x.version_match.empty())
115              {
116                  std::string version;
117                  if(regGetMatch(user_agent, x.version_match, 2, 0, &version))
118                      continue;
119                  if(!x.version_target.empty() && !verGreaterEqual(version, x.version_target))
120                      continue;
121              }
122              target = x.target;
123              clash_new_name = x.clash_new_name;
124              if(x.surge_ver != -1)
125                  surge_ver = x.surge_ver;
126              return;
127          }
128      }
129      return;
130  }
131  std::string getConvertedRuleset(RESPONSE_CALLBACK_ARGS)
132  {
133      std::string url = urlDecode(getUrlArg(request.argument, "url")), type = getUrlArg(request.argument, "type");
134      return convertRuleset(fetchFile(url, parseProxy(global.proxyRuleset), global.cacheRuleset), to_int(type));
135  }
136  std::string getRuleset(RESPONSE_CALLBACK_ARGS)
137  {
138      std::string &argument = request.argument;
139      int *status_code = &response.status_code;
140      std::string url = urlSafeBase64Decode(getUrlArg(argument, "url")), type = getUrlArg(argument, "type"), group = urlSafeBase64Decode(getUrlArg(argument, "group"));
141      std::string output_content, dummy;
142      int type_int = to_int(type, 0);
143      if(!url.size() || !type.size() || (type_int == 2 && !group.size()) || (type_int < 1 || type_int > 6))
144      {
145          *status_code = 400;
146          return "Invalid request!";
147      }
148      std::string proxy = parseProxy(global.proxyRuleset);
149      string_array vArray = split(url, "|");
150      for(std::string &x : vArray)
151          x.insert(0, "ruleset,");
152      std::vector<RulesetContent> rca;
153      RulesetConfigs confs = INIBinding::from<RulesetConfig>::from_ini(vArray);
154      refreshRulesets(confs, rca);
155      for(RulesetContent &x : rca)
156      {
157          std::string content = x.rule_content.get();
158          output_content += convertRuleset(content, x.rule_type);
159      }
160      if(!output_content.size())
161      {
162          *status_code = 400;
163          return "Invalid request!";
164      }
165      std::string strLine;
166      std::stringstream ss;
167      const std::string rule_match_regex = "^(.*?,.*?)(,.*)(,.*)$";
168      ss << output_content;
169      char delimiter = getLineBreak(output_content);
170      std::string::size_type lineSize, posb, pose;
171      auto filterLine = [&]()
172      {
173          posb = 0;
174          pose = strLine.find(',');
175          if(pose == strLine.npos)
176              return 1;
177          posb = pose + 1;
178          pose = strLine.find(',', posb);
179          if(pose == strLine.npos)
180          {
181              pose = strLine.size();
182              if(strLine[pose - 1] == '\r')
183                  pose--;
184          }
185          pose -= posb;
186          return 0;
187      };
188      lineSize = output_content.size();
189      output_content.clear();
190      output_content.reserve(lineSize);
191      if(type_int == 3 || type_int == 4 || type_int == 6)
192          output_content = "payload:\n";
193      while(getline(ss, strLine, delimiter))
194      {
195          if(strFind(strLine, "&bsol;&bsol;"))
196          {
197              strLine.erase(strLine.find("&bsol;&bsol;"));
198              strLine = trimWhitespace(strLine);
199          }
200          switch(type_int)
201          {
202          case 2:
203              if(!std::any_of(QuanXRuleTypes.begin(), QuanXRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
204                  continue;
205              break;
206          case 1:
207              if(!std::any_of(SurgeRuleTypes.begin(), SurgeRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
208                  continue;
209              break;
210          case 3:
211              if(!startsWith(strLine, "DOMAIN-SUFFIX,") && !startsWith(strLine, "DOMAIN,"))
212                  continue;
213              if(filterLine())
214                  continue;
215              output_content += "  - '";
216              if(strLine[posb - 2] == 'X')
217                  output_content += "+.";
218              output_content += strLine.substr(posb, pose);
219              output_content += "'\n";
220              continue;
221          case 4:
222              if(!startsWith(strLine, "IP-CIDR,") && !startsWith(strLine, "IP-CIDR6,"))
223                  continue;
224              if(filterLine())
225                  continue;
226              output_content += "  - '";
227              output_content += strLine.substr(posb, pose);
228              output_content += "'\n";
229              continue;
230          case 5:
231              if(!startsWith(strLine, "DOMAIN-SUFFIX,") && !startsWith(strLine, "DOMAIN,"))
232                  continue;
233              if(filterLine())
234                  continue;
235              output_content += strLine.substr(posb, pose);
236              output_content += '\n';
237              continue;
238          case 6:
239              if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
240                  continue;
241              output_content += "  - ";
242          }
243          lineSize = strLine.size();
244          if(lineSize && strLine[lineSize - 1] == '\r') 
245              strLine.erase(--lineSize);
246          if(!strLine.empty() && (strLine[0] != ';' && strLine[0] != '#' && !(lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')))
247          {
248              if(type_int == 2)
249              {
250                  if(startsWith(strLine, "IP-CIDR6"))
251                      strLine.replace(0, 8, "IP6-CIDR");
252                  strLine += "," + group;
253                  if(count_least(strLine, ',', 3) && regReplace(strLine, rule_match_regex, "$2") == ",no-resolve")
254                      strLine = regReplace(strLine, rule_match_regex, "$1$3$2");
255                  else
256                      strLine = regReplace(strLine, rule_match_regex, "$1$3");
257              }
258          }
259          output_content += strLine;
260          output_content += '\n';
261      }
262      if(output_content == "payload:\n")
263      {
264          switch(type_int)
265          {
266          case 3:
267              output_content += "  - '--placeholder--'";
268              break;
269          case 4:
270              output_content += "  - '0.0.0.0/32'";
271              break;
272          case 6:
273              output_content += "  - 'DOMAIN,--placeholder--'";
274              break;
275          }
276      }
277      return output_content;
278  }
279  void checkExternalBase(const std::string &path, std::string &dest)
280  {
281      if(isLink(path) || (startsWith(path, global.basePath) && fileExist(path)))
282          dest = path;
283  }
284  std::string subconverter(RESPONSE_CALLBACK_ARGS)
285  {
286      std::string &argument = request.argument;
287      int *status_code = &response.status_code;
288      std::string argTarget = getUrlArg(argument, "target"), argSurgeVer = getUrlArg(argument, "ver");
289      tribool argClashNewField = getUrlArg(argument, "new_name");
290      int intSurgeVer = argSurgeVer.size() ? to_int(argSurgeVer, 3) : 3;
291      if(argTarget == "auto")
292          matchUserAgent(request.headers["User-Agent"], argTarget, argClashNewField, intSurgeVer);
293      bool lSimpleSubscription = false;
294      switch(hash_(argTarget))
295      {
296      case "ss"_hash: case "ssd"_hash: case "ssr"_hash: case "sssub"_hash: case "v2ray"_hash: case "trojan"_hash: case "mixed"_hash:
297          lSimpleSubscription = true;
298          break;
299      case "clash"_hash: case "clashr"_hash: case "surge"_hash: case "quan"_hash: case "quanx"_hash: case "loon"_hash: case "surfboard"_hash: case "mellow"_hash:
300          break;
301      default:
302          *status_code = 400;
303          return "Invalid target!";
304      }
305      if((!global.APIMode || global.CFWChildProcess) && !global.generatorMode)
306          readConf();
307      std::string argUrl = urlDecode(getUrlArg(argument, "url"));
308      std::string argGroupName = urlDecode(getUrlArg(argument, "group")), argUploadPath = getUrlArg(argument, "upload_path");
309      std::string argIncludeRemark = urlDecode(getUrlArg(argument, "include")), argExcludeRemark = urlDecode(getUrlArg(argument, "exclude"));
310      std::string argCustomGroups = urlSafeBase64Decode(getUrlArg(argument, "groups")), argCustomRulesets = urlSafeBase64Decode(getUrlArg(argument, "ruleset")), argExternalConfig = urlDecode(getUrlArg(argument, "config"));
311      std::string argDeviceID = getUrlArg(argument, "dev_id"), argFilename = urlDecode(getUrlArg(argument, "filename")), argUpdateInterval = getUrlArg(argument, "interval"), argUpdateStrict = getUrlArg(argument, "strict");
312      std::string argRenames = urlDecode(getUrlArg(argument, "rename")), argFilterScript = urlDecode(getUrlArg(argument, "filter_script"));
313      tribool argUpload = getUrlArg(argument, "upload"), argEmoji = getUrlArg(argument, "emoji"), argAddEmoji = getUrlArg(argument, "add_emoji"), argRemoveEmoji = getUrlArg(argument, "remove_emoji");
314      tribool argAppendType = getUrlArg(argument, "append_type"), argTFO = getUrlArg(argument, "tfo"), argUDP = getUrlArg(argument, "udp"), argGenNodeList = getUrlArg(argument, "list");
315      tribool argSort = getUrlArg(argument, "sort"), argUseSortScript = getUrlArg(argument, "sort_script");
316      tribool argGenClashScript = getUrlArg(argument, "script"), argEnableInsert = getUrlArg(argument, "insert");
317      tribool argSkipCertVerify = getUrlArg(argument, "scv"), argFilterDeprecated = getUrlArg(argument, "fdn"), argExpandRulesets = getUrlArg(argument, "expand"), argAppendUserinfo = getUrlArg(argument, "append_info");
318      tribool argPrependInsert = getUrlArg(argument, "prepend"), argGenClassicalRuleProvider = getUrlArg(argument, "classic"), argTLS13 = getUrlArg(argument, "tls13");
319      std::string base_content, output_content;
320      ProxyGroupConfigs lCustomProxyGroups = global.customProxyGroups;
321      RulesetConfigs lCustomRulesets = global.customRulesets;
322      string_array lIncludeRemarks = global.includeRemarks, lExcludeRemarks = global.excludeRemarks;
323      std::vector<RulesetContent> lRulesetContent;
324      extra_settings ext;
325      std::string subInfo, dummy;
326      int interval = argUpdateInterval.size() ? to_int(argUpdateInterval, global.updateInterval) : global.updateInterval;
327      bool authorized = !global.APIMode || getUrlArg(argument, "token") == global.accessToken, strict = argUpdateStrict.size() ? argUpdateStrict == "true" : global.updateStrict;
328      if(std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argIncludeRemark) != gRegexBlacklist.cend() || std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argExcludeRemark) != gRegexBlacklist.cend())
329          return "Invalid request!";
330      std::string lClashBase = global.clashBase, lSurgeBase = global.surgeBase, lMellowBase = global.mellowBase, lSurfboardBase = global.surfboardBase;
331      std::string lQuanBase = global.quanBase, lQuanXBase = global.quanXBase, lLoonBase = global.loonBase, lSSSubBase = global.SSSubBase;
332      argEnableInsert.define(global.enableInsert);
333      if(!argUrl.size() && (!global.APIMode || authorized))
334          argUrl = global.defaultUrls;
335      if((!argUrl.size() && !(global.insertUrls.size() && argEnableInsert)) || !argTarget.size())
336      {
337          *status_code = 400;
338          return "Invalid request!";
339      }
340      string_array req_args = split(argument, "&");
341      string_map req_arg_map;
342      for(std::string &x : req_args)
343      {
344          string_size pos = x.find("=");
345          if(pos == x.npos)
346          {
347              req_arg_map[x] = "";
348              continue;
349          }
350          if(x.substr(0, pos) == "token")
351              continue;
352          req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
353      }
354      req_arg_map["target"] = argTarget;
355      req_arg_map["ver"] = std::to_string(intSurgeVer);
356      template_args tpl_args;
357      tpl_args.global_vars = global.templateVars;
358      tpl_args.request_params = req_arg_map;
359      std::string proxy = parseProxy(global.proxySubscription);
360      ext.authorized = authorized;
361      ext.append_proxy_type = argAppendType.get(global.appendType);
362      if((argTarget == "clash" || argTarget == "clashr") && argGenClashScript.is_undef())
363          argExpandRulesets.define(true);
364      ext.clash_proxies_style = global.clashProxiesStyle;
365      ext.tfo.define(argTFO).define(global.TFOFlag);
366      ext.udp.define(argUDP).define(global.UDPFlag);
367      ext.skip_cert_verify.define(argSkipCertVerify).define(global.skipCertVerify);
368      ext.tls13.define(argTLS13).define(global.TLS13Flag);
369      ext.sort_flag = argSort.get(global.enableSort);
370      argUseSortScript.define(global.sortScript.size() != 0);
371      if(ext.sort_flag && argUseSortScript)
372          ext.sort_script = global.sortScript;
373      ext.filter_deprecated = argFilterDeprecated.get(global.filterDeprecated);
374      ext.clash_new_field_name = argClashNewField.get(global.clashUseNewField);
375      ext.clash_script = argGenClashScript.get();
376      ext.clash_classical_ruleset = argGenClassicalRuleProvider.get();
377      if(!argExpandRulesets)
378          ext.clash_new_field_name = true;
379      else
380          ext.clash_script = false;
381      ext.nodelist = argGenNodeList;
382      ext.surge_ssr_path = global.surgeSSRPath;
383      ext.quanx_dev_id = argDeviceID.size() ? argDeviceID : global.quanXDevID;
384      ext.enable_rule_generator = global.enableRuleGen;
385      ext.overwrite_original_rules = global.overwriteOriginalRules;
386      if(!argExpandRulesets)
387          ext.managed_config_prefix = global.managedConfigPrefix;
388      if(argExternalConfig.empty())
389          argExternalConfig = global.defaultExtConfig;
390      if(argExternalConfig.size())
391      {
392          writeLog(0, "External configuration file provided. Loading...", LOG_LEVEL_INFO);
393          ExternalConfig extconf;
394          extconf.tpl_args = &tpl_args;
395          if(loadExternalConfig(argExternalConfig, extconf) == 0)
396          {
397              if(!ext.nodelist)
398              {
399                  checkExternalBase(extconf.sssub_rule_base, lSSSubBase);
400                  if(!lSimpleSubscription)
401                  {
402                      checkExternalBase(extconf.clash_rule_base, lClashBase);
403                      checkExternalBase(extconf.surge_rule_base, lSurgeBase);
404                      checkExternalBase(extconf.surfboard_rule_base, lSurfboardBase);
405                      checkExternalBase(extconf.mellow_rule_base, lMellowBase);
406                      checkExternalBase(extconf.quan_rule_base, lQuanBase);
407                      checkExternalBase(extconf.quanx_rule_base, lQuanXBase);
408                      checkExternalBase(extconf.loon_rule_base, lLoonBase);
409                      if(extconf.surge_ruleset.size())
410                          lCustomRulesets = extconf.surge_ruleset;
411                      if(extconf.custom_proxy_group.size())
412                          lCustomProxyGroups = extconf.custom_proxy_group;
413                      ext.enable_rule_generator = extconf.enable_rule_generator;
414                      ext.overwrite_original_rules = extconf.overwrite_original_rules;
415                  }
416              }
417              if(extconf.rename.size())
418                  ext.rename_array = extconf.rename;
419              if(extconf.emoji.size())
420                  ext.emoji_array = extconf.emoji;
421              if(extconf.include.size())
422                  lIncludeRemarks = extconf.include;
423              if(extconf.exclude.size())
424                  lExcludeRemarks = extconf.exclude;
425              argAddEmoji.define(extconf.add_emoji);
426              argRemoveEmoji.define(extconf.remove_old_emoji);
427          }
428      }
429      else
430      {
431          if(!lSimpleSubscription)
432          {
433              if(argCustomGroups.size() && !ext.nodelist)
434              {
435                  string_array vArray = split(argCustomGroups, "@");
<span onclick='openModal()' class='match'>436                  lCustomProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
437              }
438              if(argCustomRulesets.size() && !ext.nodelist)
</span>439              {
440                  string_array vArray = split(argCustomRulesets, "@");
441                  lCustomRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
442              }
443          }
444      }
445      if(ext.enable_rule_generator && !ext.nodelist && !lSimpleSubscription)
446      {
447          if(lCustomRulesets != global.customRulesets)
448              refreshRulesets(lCustomRulesets, lRulesetContent);
449          else
450          {
451              if(global.updateRulesetOnRequest)
452                  refreshRulesets(global.customRulesets, global.rulesetsContent);
453              lRulesetContent = global.rulesetsContent;
454          }
455      }
456      if(!argEmoji.is_undef())
457      {
458          argAddEmoji.set(argEmoji);
459          argRemoveEmoji.set(true);
460      }
461      ext.add_emoji = argAddEmoji.get(global.addEmoji);
462      ext.remove_emoji = argRemoveEmoji.get(global.removeEmoji);
463      if(ext.add_emoji && ext.emoji_array.empty())
464          ext.emoji_array = safe_get_emojis();
465      if(argRenames.size())
466          ext.rename_array = INIBinding::from<RegexMatchConfig>::from_ini(split(argRenames, "`"), "@");
467      else if(ext.rename_array.empty())
468          ext.rename_array = safe_get_renames();
469      if(argIncludeRemark.size() && regValid(argIncludeRemark))
470          lIncludeRemarks = string_array{argIncludeRemark};
471      if(argExcludeRemark.size() && regValid(argExcludeRemark))
472          lExcludeRemarks = string_array{argExcludeRemark};
473      if(authorized && !global.scriptCleanContext)
474      {
475          ext.js_runtime = new qjs::Runtime();
476          script_runtime_init(*ext.js_runtime);
477          ext.js_context = new qjs::Context(*ext.js_runtime);
478          script_context_init(*ext.js_context);
479      }
480      RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();
481      string_array urls;
482      std::vector<Proxy> nodes, insert_nodes;
483      int groupID = 0;
484      parse_settings parse_set;
485      parse_set.proxy = &proxy;
486      parse_set.exclude_remarks = &lExcludeRemarks;
487      parse_set.include_remarks = &lIncludeRemarks;
488      parse_set.stream_rules = &stream_temp;
489      parse_set.time_rules = &time_temp;
490      parse_set.sub_info = &subInfo;
491      parse_set.authorized = authorized;
492      parse_set.request_header = &request.headers;
493      parse_set.js_runtime = ext.js_runtime;
494      parse_set.js_context = ext.js_context;
495      if(global.insertUrls.size() && argEnableInsert)
496      {
497          groupID = -1;
498          urls = split(global.insertUrls, "|");
499          importItems(urls, true);
500          for(std::string &x : urls)
501          {
502              x = regTrim(x);
503              writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
504              if(addNodes(x, insert_nodes, groupID, parse_set) == -1)
505              {
506                  if(global.skipFailedLinks)
507                      writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
508                  else
509                  {
510                      *status_code = 400;
511                      return "The following link doesn't contain any valid node info: " + x;
512                  }
513              }
514              groupID--;
515          }
516      }
517      urls = split(argUrl, "|");
518      importItems(urls, true);
519      groupID = 0;
520      for(std::string &x : urls)
521      {
522          x = regTrim(x);
523          writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
524          if(addNodes(x, nodes, groupID, parse_set) == -1)
525          {
526              if(global.skipFailedLinks)
527                  writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
528              else
529              {
530                  *status_code = 400;
531                  return "The following link doesn't contain any valid node info: " + x;
532              }
533          }
534          groupID++;
535      }
536      if(!nodes.size() && !insert_nodes.size())
537      {
538          *status_code = 400;
539          return "No nodes were found!";
540      }
541      if(subInfo.size() && argAppendUserinfo.get(global.appendUserinfo))
542          response.headers.emplace("Subscription-UserInfo", subInfo);
543      if(request.method == "HEAD")
544          return "";
545      argPrependInsert.define(global.prependInsert);
546      if(argPrependInsert)
547      {
548          std::move(nodes.begin(), nodes.end(), std::back_inserter(insert_nodes));
549          nodes.swap(insert_nodes);
550      }
551      else
552      {
553          std::move(insert_nodes.begin(), insert_nodes.end(), std::back_inserter(nodes));
554      }
555      std::string filterScript = global.filterScript;
556      if(authorized && !argFilterScript.empty())
557          filterScript = argFilterScript;
558      if(filterScript.size())
559      {
560          if(startsWith(filterScript, "path:"))
561              filterScript = fileGet(filterScript.substr(5), false);
562          script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
563          {
564              try
565              {
566                  ctx.eval(filterScript);
567                  auto filter = (std::function<bool(const Proxy&)>) ctx.eval("filter");
568                  nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());
569              }
570              catch(qjs::exception)
571              {
572                  script_print_stack(ctx);
573              }
574          }, global.scriptCleanContext);
575      }
576      if(argGroupName.size())
577          for(Proxy &x : nodes)
578              x.Group = argGroupName;
579      preprocessNodes(nodes, ext);
580      ProxyGroupConfigs dummy_group;
581      std::vector<RulesetContent> dummy_ruleset;
582      std::string managed_url = base64Decode(urlDecode(getUrlArg(argument, "profile_data")));
583      if(managed_url.empty())
584          managed_url = global.managedConfigPrefix + "/sub?" + argument;
585      proxy = parseProxy(global.proxyConfig);
586      switch(hash_(argTarget))
587      {
588      case "clash"_hash: case "clashr"_hash:
589          writeLog(0, argTarget == "clashr" ? "Generate target: ClashR" : "Generate target: Clash", LOG_LEVEL_INFO);
590          tpl_args.local_vars["clash.new_field_name"] = ext.clash_new_field_name ? "true" : "false";
591          response.headers["profile-update-interval"] = std::to_string(interval / 3600);
592          if(ext.nodelist)
593          {
594              YAML::Node yamlnode;
595              proxyToClash(nodes, yamlnode, dummy_group, argTarget == "clashr", ext);
596              output_content = YAML::Dump(yamlnode);
597          }
598          else
599          {
600              if(render_template(fetchFile(lClashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
601              {
602                  *status_code = 400;
603                  return base_content;
604              }
605              output_content = proxyToClash(nodes, base_content, lRulesetContent, lCustomProxyGroups, argTarget == "clashr", ext);
606          }
607          if(argUpload)
608              uploadGist(argTarget, argUploadPath, output_content, false);
609          break;
610      case "surge"_hash:
611          writeLog(0, "Generate target: Surge " + std::to_string(intSurgeVer), LOG_LEVEL_INFO);
612          if(ext.nodelist)
613          {
614              output_content = proxyToSurge(nodes, base_content, dummy_ruleset, dummy_group, intSurgeVer, ext);
615              if(argUpload)
616                  uploadGist("surge" + argSurgeVer + "list", argUploadPath, output_content, true);
617          }
618          else
619          {
620              if(render_template(fetchFile(lSurgeBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
621              {
622                  *status_code = 400;
623                  return base_content;
624              }
625              output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, intSurgeVer, ext);
626              if(argUpload)
627                  uploadGist("surge" + argSurgeVer, argUploadPath, output_content, true);
628              if(global.writeManagedConfig && global.managedConfigPrefix.size())
629                  output_content = "#!MANAGED-CONFIG " + managed_url + (interval ? " interval=" + std::to_string(interval) : "") \
630                   + " strict=" + std::string(strict ? "true" : "false") + "\n\n" + output_content;
631          }
632          break;
633      case "surfboard"_hash:
634          writeLog(0, "Generate target: Surfboard", LOG_LEVEL_INFO);
635          if(render_template(fetchFile(lSurfboardBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
636          {
637              *status_code = 400;
638              return base_content;
639          }
640          output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, -3, ext);
641          if(argUpload)
642              uploadGist("surfboard", argUploadPath, output_content, true);
643          if(global.writeManagedConfig && global.managedConfigPrefix.size())
644              output_content = "#!MANAGED-CONFIG " + managed_url + (interval ? " interval=" + std::to_string(interval) : "") \
645                   + " strict=" + std::string(strict ? "true" : "false") + "\n\n" + output_content;
646          break;
647      case "mellow"_hash:
648          writeLog(0, "Generate target: Mellow", LOG_LEVEL_INFO);
649          if(render_template(fetchFile(lMellowBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
650          {
651              *status_code = 400;
652              return base_content;
653          }
654          output_content = proxyToMellow(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
655          if(argUpload)
656              uploadGist("mellow", argUploadPath, output_content, true);
657          break;
658      case "sssub"_hash:
659          writeLog(0, "Generate target: SS Subscription", LOG_LEVEL_INFO);
660          if(render_template(fetchFile(lSSSubBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
661          {
662              *status_code = 400;
663              return base_content;
664          }
665          output_content = proxyToSSSub(base_content, nodes, ext);
666          if(argUpload)
667              uploadGist("sssub", argUploadPath, output_content, false);
668          break;
669      case "ss"_hash:
670          writeLog(0, "Generate target: SS", LOG_LEVEL_INFO);
671          output_content = proxyToSingle(nodes, 1, ext);
672          if(argUpload)
673              uploadGist("ss", argUploadPath, output_content, false);
674          break;
675      case "ssr"_hash:
676          writeLog(0, "Generate target: SSR", LOG_LEVEL_INFO);
677          output_content = proxyToSingle(nodes, 2, ext);
678          if(argUpload)
679              uploadGist("ssr", argUploadPath, output_content, false);
680          break;
681      case "v2ray"_hash:
682          writeLog(0, "Generate target: v2rayN", LOG_LEVEL_INFO);
683          output_content = proxyToSingle(nodes, 4, ext);
684          if(argUpload)
685              uploadGist("v2ray", argUploadPath, output_content, false);
686          break;
687      case "trojan"_hash:
688          writeLog(0, "Generate target: Trojan", LOG_LEVEL_INFO);
689          output_content = proxyToSingle(nodes, 8, ext);
690          if(argUpload)
691              uploadGist("trojan", argUploadPath, output_content, false);
692          break;
693      case "mixed"_hash:
694          writeLog(0, "Generate target: Standard Subscription", LOG_LEVEL_INFO);
695          output_content = proxyToSingle(nodes, 15, ext);
696          if(argUpload)
697              uploadGist("sub", argUploadPath, output_content, false);
698          break;
699      case "quan"_hash:
700          writeLog(0, "Generate target: Quantumult", LOG_LEVEL_INFO);
701          if(!ext.nodelist)
702          {
703              if(render_template(fetchFile(lQuanBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
704              {
705                  *status_code = 400;
706                  return base_content;
707              }
708          }
709          output_content = proxyToQuan(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
710          if(argUpload)
711              uploadGist("quan", argUploadPath, output_content, false);
712          break;
713      case "quanx"_hash:
714          writeLog(0, "Generate target: Quantumult X", LOG_LEVEL_INFO);
715          if(!ext.nodelist)
716          {
717              if(render_template(fetchFile(lQuanXBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
718              {
719                  *status_code = 400;
720                  return base_content;
721              }
722          }
723          output_content = proxyToQuanX(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
724          if(argUpload)
725              uploadGist("quanx", argUploadPath, output_content, false);
726          break;
727      case "loon"_hash:
728          writeLog(0, "Generate target: Loon", LOG_LEVEL_INFO);
729          if(!ext.nodelist)
730          {
731              if(render_template(fetchFile(lLoonBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
732              {
733                  *status_code = 400;
734                  return base_content;
735              }
736          }
737          output_content = proxyToLoon(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
738          if(argUpload)
739              uploadGist("loon", argUploadPath, output_content, false);
740          break;
741      case "ssd"_hash:
742          writeLog(0, "Generate target: SSD", LOG_LEVEL_INFO);
743          output_content = proxyToSSD(nodes, argGroupName, subInfo, ext);
744          if(argUpload)
745              uploadGist("ssd", argUploadPath, output_content, false);
746          break;
747      default:
748          writeLog(0, "Generate target: Unspecified", LOG_LEVEL_INFO);
749          *status_code = 500;
750          return "Unrecognized target";
751      }
752      writeLog(0, "Generate completed.", LOG_LEVEL_INFO);
753      if(argFilename.size())
754          response.headers.emplace("Content-Disposition", "attachment; filename=\"" + argFilename + "\"; filename*=utf-8''" + urlEncode(argFilename));
755      return output_content;
756  }
757  std::string simpleToClashR(RESPONSE_CALLBACK_ARGS)
758  {
759      std::string &argument = request.argument;
760      int *status_code = &response.status_code;
761      std::string url = argument.size() <= 8 ? "" : argument.substr(8);
762      if(!url.size() || argument.substr(0, 8) != "sublink=")
763      {
764          *status_code = 400;
765          return "Invalid request!";
766      }
767      if(url == "sublink")
768      {
769          *status_code = 400;
770          return "Please insert your subscription link instead of clicking the default link.";
771      }
772      request.argument = "target=clashr&url=" + urlEncode(url);
773      return subconverter(request, response);
774  }
775  std::string surgeConfToClash(RESPONSE_CALLBACK_ARGS)
776  {
777      std::string &argument = request.argument;
778      int *status_code = &response.status_code;
779      INIReader ini;
780      string_array dummy_str_array;
781      std::vector<Proxy> nodes;
782      std::string base_content, url = argument.size() <= 5 ? "" : argument.substr(5);
783      const std::string proxygroup_name = global.clashUseNewField ? "proxy-groups" : "Proxy Group", rule_name = global.clashUseNewField ? "rules" : "Rule";
784      ini.store_any_line = true;
785      if(!url.size())
786          url = global.defaultUrls;
787      if(!url.size() || argument.substr(0, 5) != "link=")
788      {
789          *status_code = 400;
790          return "Invalid request!";
791      }
792      if(url == "link")
793      {
794          *status_code = 400;
795          return "Please insert your subscription link instead of clicking the default link.";
796      }
797      writeLog(0, "SurgeConfToClash called with url '" + url + "'.", LOG_LEVEL_INFO);
798      std::string proxy = parseProxy(global.proxyConfig);
799      YAML::Node clash;
800      template_args tpl_args;
801      tpl_args.global_vars = global.templateVars;
802      tpl_args.local_vars["clash.new_field_name"] = global.clashUseNewField ? "true" : "false";
803      tpl_args.request_params["target"] = "clash";
804      tpl_args.request_params["url"] = url;
805      if(render_template(fetchFile(global.clashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
806      {
807          *status_code = 400;
808          return base_content;
809      }
810      clash = YAML::Load(base_content);
811      base_content = fetchFile(url, proxy, global.cacheConfig);
812      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
813      {
814          std::string errmsg = "Parsing Surge config failed! Reason: " + ini.GetLastError();
815          writeLog(0, errmsg, LOG_LEVEL_ERROR);
816          *status_code = 400;
817          return errmsg;
818      }
819      if(!ini.SectionExist("Proxy") || !ini.SectionExist("Proxy Group") || !ini.SectionExist("Rule"))
820      {
821          std::string errmsg = "Incomplete surge config! Missing critical sections!";
822          writeLog(0, errmsg, LOG_LEVEL_ERROR);
823          *status_code = 400;
824          return errmsg;
825      }
826      string_multimap section;
827      ini.GetItems("Proxy Group", section);
828      std::string name, type, content;
829      string_array links;
830      links.emplace_back(url);
831      YAML::Node singlegroup;
832      for(auto &x : section)
833      {
834          singlegroup.reset();
835          name = x.first;
836          content = x.second;
837          dummy_str_array = split(content, ",");
838          if(!dummy_str_array.size())
839              continue;
840          type = dummy_str_array[0];
841          if(!(type == "select" || type == "url-test" || type == "fallback" || type == "load-balance")) 
842              continue;
843          singlegroup["name"] = name;
844          singlegroup["type"] = type;
845          for(unsigned int i = 1; i < dummy_str_array.size(); i++)
846          {
847              if(startsWith(dummy_str_array[i], "url"))
848                  singlegroup["url"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1));
849              else if(startsWith(dummy_str_array[i], "interval"))
850                  singlegroup["interval"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1));
851              else if(startsWith(dummy_str_array[i], "policy-path"))
852                  links.emplace_back(trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1)));
853              else
854                  singlegroup["proxies"].push_back(trim(dummy_str_array[i]));
855          }
856          clash[proxygroup_name].push_back(singlegroup);
857      }
858      proxy = parseProxy(global.proxySubscription);
859      eraseElements(dummy_str_array);
860      RegexMatchConfigs dummy_regex_array;
861      std::string subInfo;
862      parse_settings parse_set;
863      parse_set.proxy = &proxy;
864      parse_set.exclude_remarks = parse_set.include_remarks = &dummy_str_array;
865      parse_set.stream_rules = parse_set.time_rules = &dummy_regex_array;
866      parse_set.request_header = &request.headers;
867      parse_set.sub_info = &subInfo;
868      parse_set.authorized = !global.APIMode;
869      for(std::string &x : links)
870      {
871          writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
872          if(addNodes(x, nodes, 0, parse_set) == -1)
873          {
874              if(global.skipFailedLinks)
875                  writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
876              else
877              {
878                  *status_code = 400;
879                  return "The following link doesn't contain any valid node info: " + x;
880              }
881          }
882      }
883      if(!nodes.size())
884      {
885          *status_code = 400;
886          return "No nodes were found!";
887      }
888      extra_settings ext;
889      ext.sort_flag = global.enableSort;
890      ext.filter_deprecated = global.filterDeprecated;
891      ext.clash_new_field_name = global.clashUseNewField;
892      ext.udp = global.UDPFlag;
893      ext.tfo = global.TFOFlag;
894      ext.skip_cert_verify = global.skipCertVerify;
895      ext.tls13 = global.TLS13Flag;
896      ext.clash_proxies_style = global.clashProxiesStyle;
897      ProxyGroupConfigs dummy_groups;
898      proxyToClash(nodes, clash, dummy_groups, false, ext);
899      section.clear();
900      ini.GetItems("Proxy", section);
901      for(auto &x : section)
902      {
903          singlegroup.reset();
904          name = x.first;
905          content = x.second;
906          dummy_str_array = split(content, ",");
907          if(!dummy_str_array.size())
908              continue;
909          content = trim(dummy_str_array[0]);
910          switch(hash_(content))
911          {
912          case "direct"_hash:
913              singlegroup["name"] = name;
914              singlegroup["type"] = "select";
915              singlegroup["proxies"].push_back("DIRECT");
916              break;
917          case "reject"_hash:
918          case "reject-tinygif"_hash:
919              singlegroup["name"] = name;
920              singlegroup["type"] = "select";
921              singlegroup["proxies"].push_back("REJECT");
922              break;
923          default:
924              continue;
925          }
926          clash[proxygroup_name].push_back(singlegroup);
927      }
928      eraseElements(dummy_str_array);
929      ini.GetAll("Rule", "{NONAME}", dummy_str_array);
930      YAML::Node rule;
931      string_array strArray;
932      std::string strLine;
933      std::stringstream ss;
934      std::string::size_type lineSize;
935      for(std::string &x : dummy_str_array)
936      {
937          if(startsWith(x, "RULE-SET"))
938          {
939              strArray = split(x, ",");
940              if(strArray.size() != 3)
941                  continue;
942              content = webGet(strArray[1], proxy, global.cacheRuleset);
943              if(!content.size())
944                  continue;
945              ss << content;
946              char delimiter = getLineBreak(content);
947              while(getline(ss, strLine, delimiter))
948              {
949                  lineSize = strLine.size();
950                  if(lineSize && strLine[lineSize - 1] == '\r') 
951                      strLine.erase(--lineSize);
952                  if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) 
953                      continue;
954                  else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);})) 
955                      continue;
956                  strLine += strArray[2];
957                  if(count_least(strLine, ',', 3))
958                      strLine = regReplace(strLine, "^(.*?,.*?)(,.*)(,.*)$", "$1$3$2");
959                  rule.push_back(strLine);
960              }
961              ss.clear();
962              continue;
963          }
964          else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
965              continue;
966          rule.push_back(x);
967      }
968      clash[rule_name] = rule;
969      response.headers["profile-update-interval"] = std::to_string(global.updateInterval / 3600);
970      writeLog(0, "Conversion completed.", LOG_LEVEL_INFO);
971      return YAML::Dump(clash);
972  }
973  std::string getProfile(RESPONSE_CALLBACK_ARGS)
974  {
975      std::string &argument = request.argument;
976      int *status_code = &response.status_code;
977      std::string name = urlDecode(getUrlArg(argument, "name")), token = urlDecode(getUrlArg(argument, "token"));
978      string_array profiles = split(name, "|");
979      name = profiles[0];
980      if(token.empty() || name.empty())
981      {
982          *status_code = 403;
983          return "Forbidden";
984      }
985      std::string profile_content;
986      if(fileExist(name))
987      {
988          profile_content = fileGet(name, true);
989      }
990      else
991      {
992          *status_code = 404;
993          return "Profile not found";
994      }
995      writeLog(0, "Trying to load profile '" + name + "'.", LOG_LEVEL_INFO);
996      INIReader ini;
997      if(ini.Parse(profile_content) != INIREADER_EXCEPTION_NONE && !ini.SectionExist("Profile"))
998      {
999          writeLog(0, "Load profile failed! Reason: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1000          *status_code = 500;
1001          return "Broken profile!";
1002      }
1003      writeLog(0, "Trying to parse profile '" + name + "'.", LOG_LEVEL_INFO);
1004      string_multimap contents;
1005      ini.GetItems("Profile", contents);
1006      if(!contents.size())
1007      {
1008          writeLog(0, "Load profile failed! Reason: Empty Profile section", LOG_LEVEL_ERROR);
1009          *status_code = 500;
1010          return "Broken profile!";
1011      }
1012      auto profile_token = contents.find("profile_token");
1013      if(profiles.size() == 1 && profile_token != contents.end())
1014      {
1015          if(token != profile_token->second)
1016          {
1017              *status_code = 403;
1018              return "Forbidden";
1019          }
1020          token = global.accessToken;
1021      }
1022      else
1023      {
1024          if(token != global.accessToken)
1025          {
1026              *status_code = 403;
1027              return "Forbidden";
1028          }
1029      }
1030      if(profiles.size() > 1)
1031      {
1032          writeLog(0, "Multiple profiles are provided. Trying to combine profiles...", LOG_TYPE_INFO);
1033          std::string all_urls, url;
1034          auto iter = contents.find("url");
1035          if(iter != contents.end())
1036              all_urls = iter->second;
1037          for(size_t i = 1; i < profiles.size(); i++)
1038          {
1039              name = profiles[i];
1040              if(!fileExist(name))
1041              {
1042                  writeLog(0, "Ignoring non-exist profile '" + name + "'...", LOG_LEVEL_WARNING);
1043                  continue;
1044              }
1045              if(ini.ParseFile(name) != INIREADER_EXCEPTION_NONE && !ini.SectionExist("Profile"))
1046              {
1047                  writeLog(0, "Ignoring broken profile '" + name + "'...", LOG_LEVEL_WARNING);
1048                  continue;
1049              }
1050              url = ini.Get("Profile", "url");
1051              if(url.size())
1052              {
1053                  all_urls += "|" + url;
1054                  writeLog(0, "Profile url from '" + name + "' added.", LOG_LEVEL_INFO);
1055              }
1056              else
1057              {
1058                  writeLog(0, "Profile '" + name + "' does not have url key. Skipping...", LOG_LEVEL_INFO);
1059              }
1060          }
1061          iter->second = all_urls;
1062      }
1063      contents.emplace("token", token);
1064      contents.emplace("profile_data", base64Encode(global.managedConfigPrefix + "/getprofile?" + argument));
1065      std::string query = std::accumulate(contents.begin(), contents.end(), std::string(), [](const std::string &x, auto y){ return x + y.first + "=" + urlEncode(y.second) + "&"; });
1066      query += argument;
1067      request.argument = query;
1068      return subconverter(request, response);
1069  }
1070  inline std::string intToStream(unsigned long long stream)
1071  {
1072      char chrs[16] = {}, units[6] = {' ', 'K', 'M', 'G', 'T', 'P'};
1073      double streamval = stream;
1074      unsigned int level = 0;
1075      while(streamval > 1024.0)
1076      {
1077          if(level >= 5)
1078              break;
1079          level++;
1080          streamval /= 1024.0;
1081      }
1082      snprintf(chrs, 15, "%.2f %cB", streamval, units[level]);
1083      return std::string(chrs);
1084  }
1085  std::string subInfoToMessage(std::string subinfo)
1086  {
1087      using ull = unsigned long long;
1088      subinfo = replaceAllDistinct(subinfo, "; ", "&");
1089      std::string retdata, useddata = "N/A", totaldata = "N/A", expirydata = "N/A";
1090      std::string upload = getUrlArg(subinfo, "upload"), download = getUrlArg(subinfo, "download"), total = getUrlArg(subinfo, "total"), expire = getUrlArg(subinfo, "expire");
1091      ull used = to_number<ull>(upload, 0) + to_number<ull>(download, 0), tot = to_number<ull>(total, 0);
1092      time_t expiry = to_number<time_t>(expire, 0);
1093      if(used != 0)
1094          useddata = intToStream(used);
1095      if(tot != 0)
1096          totaldata = intToStream(tot);
1097      if(expiry != 0)
1098      {
1099          char buffer[30];
1100          struct tm *dt = localtime(&expiry);
1101          strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M", dt);
1102          expirydata.assign(buffer);
1103      }
1104      if(useddata == "N/A" && totaldata == "N/A" && expirydata == "N/A")
1105          retdata = "Not Available";
1106      else
1107          retdata += "Stream Used: " + useddata + " Stream Total: " + totaldata + " Expiry Time: " + expirydata;
1108      return retdata;
1109  }
1110  int simpleGenerator()
1111  {
1112      writeLog(0, "Reading generator configuration...", LOG_LEVEL_INFO);
1113      std::string config = fileGet("generate.ini"), path, profile, arguments, content;
1114      if(config.empty())
1115      {
1116          writeLog(0, "Generator configuration not found or empty!", LOG_LEVEL_ERROR);
1117          return -1;
1118      }
1119      INIReader ini;
1120      if(ini.Parse(config) != INIREADER_EXCEPTION_NONE)
1121      {
1122          writeLog(0, "Generator configuration broken! Reason:" + ini.GetLastError(), LOG_LEVEL_ERROR);
1123          return -2;
1124      }
1125      writeLog(0, "Read generator configuration completed.\n", LOG_LEVEL_INFO);
1126      string_array sections = ini.GetSections();
1127      if(global.generateProfiles.size())
1128      {
1129          writeLog(0, "Generating with specific artifacts: \"" + global.generateProfiles + "\"...", LOG_LEVEL_INFO);
1130          string_array targets = split(global.generateProfiles, ","), new_targets;
1131          for(std::string &x : targets)
1132          {
1133              x = trim(x);
1134              if(std::find(sections.cbegin(), sections.cend(), x) != sections.cend())
1135                  new_targets.emplace_back(std::move(x));
1136              else
1137              {
1138                  writeLog(0, "Artifact \"" + x + "\" not found in generator settings!", LOG_LEVEL_ERROR);
1139                  return -3;
1140              }
1141          }
1142          sections = new_targets;
1143          sections.shrink_to_fit();
1144      }
1145      else
1146          writeLog(0, "Generating all artifacts...", LOG_LEVEL_INFO);
1147      string_multimap allItems;
1148      std::string proxy = parseProxy(global.proxySubscription);
1149      Request request;
1150      Response response;
1151      for(std::string &x : sections)
1152      {
1153          arguments.clear();
1154          response.status_code = 200;
1155          writeLog(0, "Generating artifact '" + x + "'...", LOG_LEVEL_INFO);
1156          ini.EnterSection(x);
1157          if(ini.ItemExist("path"))
1158              path = ini.Get("path");
1159          else
1160          {
1161              writeLog(0, "Artifact '" + x + "' output path missing! Skipping...\n", LOG_LEVEL_ERROR);
1162              continue;
1163          }
1164          if(ini.ItemExist("profile"))
1165          {
1166              profile = ini.Get("profile");
1167              request.argument = "name=" + urlEncode(profile) + "&token=" + global.accessToken + "&expand=true";
1168              content = getProfile(request, response);
1169          }
1170          else
1171          {
1172              if(ini.GetBool("direct") == true)
1173              {
1174                  std::string url = ini.Get("url");
1175                  content = fetchFile(url, proxy, global.cacheSubscription);
1176                  if(content.empty())
1177                  {
1178                      writeLog(0, "Artifact '" + x + "' generate ERROR! Please check your link.\n", LOG_LEVEL_ERROR);
1179                      if(sections.size() == 1)
1180                          return -1;
1181                  }
1182                  fileWrite(path, "\xEF\xBB\xBF" + content, true);
1183                  continue;
1184              }
1185              ini.GetItems(allItems);
1186              allItems.emplace("expand", "true");
1187              for(auto &y : allItems)
1188              {
1189                  if(y.first == "path")
1190                      continue;
1191                  arguments += y.first + "=" + urlEncode(y.second) + "&";
1192              }
1193              arguments.erase(arguments.size() - 1);
1194              request.argument = arguments;
1195              content = subconverter(request, response);
1196          }
1197          if(response.status_code != 200)
1198          {
1199              writeLog(0, "Artifact '" + x + "' generate ERROR! Reason: " + content + "\n", LOG_LEVEL_ERROR);
1200              if(sections.size() == 1)
1201                  return -1;
1202              continue;
1203          }
1204          fileWrite(path, content, true);
1205          auto iter = std::find_if(response.headers.begin(), response.headers.end(), [](auto y){ return y.first == "Subscription-UserInfo"; });
1206          if(iter != response.headers.end())
1207              writeLog(0, "User Info for artifact '" + x + "': " + subInfoToMessage(iter->second), LOG_LEVEL_INFO);
1208          writeLog(0, "Artifact '" + x + "' generate SUCCESS!\n", LOG_LEVEL_INFO);
1209          eraseElements(response.headers);
1210      }
1211      writeLog(0, "All artifact generated. Exiting...", LOG_LEVEL_INFO);
1212      return 0;
1213  }
1214  std::string renderTemplate(RESPONSE_CALLBACK_ARGS)
1215  {
1216      std::string &argument = request.argument;
1217      int *status_code = &response.status_code;
1218      std::string path = urlDecode(getUrlArg(argument, "path"));
1219      writeLog(0, "Trying to render template '" + path + "'...", LOG_LEVEL_INFO);
1220      if(!startsWith(path, global.templatePath) || !fileExist(path))
1221      {
1222          *status_code = 404;
1223          return "Not found";
1224      }
1225      std::string template_content = fetchFile(path, parseProxy(global.proxyConfig), global.cacheConfig);
1226      if(template_content.empty())
1227      {
1228          *status_code = 400;
1229          return "File empty or out of scope";
1230      }
1231      template_args tpl_args;
1232      tpl_args.global_vars = global.templateVars;
1233      string_array req_args = split(argument, "&");
1234      string_size pos;
1235      string_map req_arg_map;
1236      for(std::string &x : req_args)
1237      {
1238          pos = x.find("=");
1239          if(pos == x.npos)
1240              req_arg_map[x] = "";
1241          else
1242              req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
1243      }
1244      tpl_args.request_params = req_arg_map;
1245      std::string output_content;
1246      if(render_template(template_content, tpl_args, output_content, global.templatePath) != 0)
1247      {
1248          *status_code = 400;
1249          writeLog(0, "Render failed with error.", LOG_LEVEL_WARNING);
1250      }
1251      else
1252          writeLog(0, "Render completed.", LOG_LEVEL_INFO);
1253      return output_content;
1254  }
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <string>
3  #include <mutex>
4  #include <numeric>
5  #include <inja.hpp>
6  #include <yaml-cpp/yaml.h>
7  #include "../config/binding.h"
8  #include "../generator/config/nodemanip.h"
9  #include "../generator/config/ruleconvert.h"
10  #include "../generator/config/subexport.h"
11  #include "../generator/template/templates.h"
12  #include "../script/cron.h"
13  #include "../script/script_quickjs.h"
14  #include "../server/webserver.h"
15  #include "../utils/base64/base64.h"
16  #include "../utils/file_extra.h"
17  #include "../utils/ini_reader/ini_reader.h"
18  #include "../utils/logger.h"
19  #include "../utils/network.h"
20  #include "../utils/regexp.h"
21  #include "../utils/stl_extra.h"
22  #include "../utils/string.h"
23  #include "../utils/string_hash.h"
24  #include "../utils/system.h"
25  #include "../utils/system.h"
26  #include "../utils/urlencode.h"
27  #include "../utils/yamlcpp_extra.h"
28  #include "interfaces.h"
29  #include "multithread.h"
30  #include "settings.h"
31  #include "upload.h"
32  #include "webget.h"
33  extern WebServer webServer;
34  string_array gRegexBlacklist = {"(.*)*"};
35  void refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array);
36  std::string parseProxy(const std::string &source)
37  {
38      std::string proxy = source;
39      if(source == "SYSTEM")
40          proxy = getSystemProxy();
41      else if(source == "NONE")
42          proxy = "";
43      return proxy;
44  }
45  extern string_array ClashRuleTypes, SurgeRuleTypes, QuanXRuleTypes;
46  struct UAProfile
47  {
48      std::string head;
49      std::string version_match;
50      std::string version_target;
51      std::string target;
52      tribool clash_new_name = tribool();
53      int surge_ver = -1;
54  };
55  const std::vector<UAProfile> UAMatchList = {
56      {"ClashForAndroid","\\/([0-9.]+)","2.0","clash",true},
57      {"ClashForAndroid","\\/([0-9.]+)R","","clashr",false},
58      {"ClashForAndroid","","","clash",false},
59      {"ClashforWindows","\\/([0-9.]+)","0.11","clash",true},
60      {"ClashforWindows","","","clash",false},
61      {"ClashX Pro","","","clash",true},
62      {"ClashX","\\/([0-9.]+)","0.13","clash",true},
63      {"Clash","","","clash",true},
64      {"Kitsunebi","","","v2ray"},
65      {"Loon","","","loon"},
66      {"Pharos","","","mixed"},
67      {"Potatso","","","mixed"},
68      {"Quantumult%20X","","","quanx"},
69      {"Quantumult","","","quan"},
70      {"Qv2ray","","","v2ray"},
71      {"Shadowrocket","","","mixed"},
72      {"Surfboard","","","surfboard"},
73      {"Surge","\\/([0-9.]+).*x86","906","surge",false,4}, 
74      {"Surge","\\/([0-9.]+).*x86","368","surge",false,3}, 
75      {"Surge","\\/([0-9.]+)","1419","surge",false,4}, 
76      {"Surge","\\/([0-9.]+)","900","surge",false,3}, 
77      {"Surge","","","surge",false,2}, 
78      {"Trojan-Qt5","","","trojan"},
79      {"V2rayU","","","v2ray"},
80      {"V2RayX","","","v2ray"}
81  };
82  bool verGreaterEqual(const std::string &src_ver, const std::string &target_ver)
83  {
84      string_size src_pos_beg = 0, src_pos_end, target_pos_beg = 0, target_pos_end;
85      while(true)
86      {
87          src_pos_end = src_ver.find('.', src_pos_beg);
88          if(src_pos_end == src_ver.npos)
89              src_pos_end = src_ver.size();
90          int part_src = std::stoi(src_ver.substr(src_pos_beg, src_pos_end - src_pos_beg));
91          target_pos_end = target_ver.find('.', target_pos_beg);
92          if(target_pos_end == target_ver.npos)
93              target_pos_end = target_ver.size();
94          int part_target = std::stoi(target_ver.substr(target_pos_beg, target_pos_end - target_pos_beg));
95          if(part_src > part_target)
96              break;
97          else if(part_src < part_target)
98              return false;
99          else if(src_pos_end >= src_ver.size() - 1 || target_pos_end >= target_ver.size() - 1)
100              break;
101          src_pos_beg = src_pos_end + 1;
102          target_pos_beg = target_pos_end + 1;
103      }
104      return true;
105  }
106  void matchUserAgent(const std::string &user_agent, std::string &target, tribool &clash_new_name, int &surge_ver)
107  {
108      if(user_agent.empty())
109          return;
110      for(const UAProfile &x : UAMatchList)
111      {
112          if(startsWith(user_agent, x.head))
113          {
114              if(!x.version_match.empty())
115              {
116                  std::string version;
117                  if(regGetMatch(user_agent, x.version_match, 2, 0, &version))
118                      continue;
119                  if(!x.version_target.empty() && !verGreaterEqual(version, x.version_target))
120                      continue;
121              }
122              target = x.target;
123              clash_new_name = x.clash_new_name;
124              if(x.surge_ver != -1)
125                  surge_ver = x.surge_ver;
126              return;
127          }
128      }
129      return;
130  }
131  std::string getConvertedRuleset(RESPONSE_CALLBACK_ARGS)
132  {
133      std::string url = urlDecode(getUrlArg(request.argument, "url")), type = getUrlArg(request.argument, "type");
134      return convertRuleset(fetchFile(url, parseProxy(global.proxyRuleset), global.cacheRuleset), to_int(type));
135  }
136  std::string getRuleset(RESPONSE_CALLBACK_ARGS)
137  {
138      std::string &argument = request.argument;
139      int *status_code = &response.status_code;
140      std::string url = urlSafeBase64Decode(getUrlArg(argument, "url")), type = getUrlArg(argument, "type"), group = urlSafeBase64Decode(getUrlArg(argument, "group"));
141      std::string output_content, dummy;
142      int type_int = to_int(type, 0);
143      if(!url.size() || !type.size() || (type_int == 2 && !group.size()) || (type_int < 1 || type_int > 6))
144      {
145          *status_code = 400;
146          return "Invalid request!";
147      }
148      std::string proxy = parseProxy(global.proxyRuleset);
149      string_array vArray = split(url, "|");
150      for(std::string &x : vArray)
151          x.insert(0, "ruleset,");
152      std::vector<RulesetContent> rca;
153      RulesetConfigs confs = INIBinding::from<RulesetConfig>::from_ini(vArray);
154      refreshRulesets(confs, rca);
155      for(RulesetContent &x : rca)
156      {
157          std::string content = x.rule_content.get();
158          output_content += convertRuleset(content, x.rule_type);
159      }
160      if(!output_content.size())
161      {
162          *status_code = 400;
163          return "Invalid request!";
164      }
165      std::string strLine;
166      std::stringstream ss;
167      const std::string rule_match_regex = "^(.*?,.*?)(,.*)(,.*)$";
168      ss << output_content;
169      char delimiter = getLineBreak(output_content);
170      std::string::size_type lineSize, posb, pose;
171      auto filterLine = [&]()
172      {
173          posb = 0;
174          pose = strLine.find(',');
175          if(pose == strLine.npos)
176              return 1;
177          posb = pose + 1;
178          pose = strLine.find(',', posb);
179          if(pose == strLine.npos)
180          {
181              pose = strLine.size();
182              if(strLine[pose - 1] == '\r')
183                  pose--;
184          }
185          pose -= posb;
186          return 0;
187      };
188      lineSize = output_content.size();
189      output_content.clear();
190      output_content.reserve(lineSize);
191      if(type_int == 3 || type_int == 4 || type_int == 6)
192          output_content = "payload:\n";
193      while(getline(ss, strLine, delimiter))
194      {
195          if(strFind(strLine, "&bsol;&bsol;"))
196          {
197              strLine.erase(strLine.find("&bsol;&bsol;"));
198              strLine = trimWhitespace(strLine);
199          }
200          switch(type_int)
201          {
202          case 2:
203              if(!std::any_of(QuanXRuleTypes.begin(), QuanXRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
204                  continue;
205              break;
206          case 1:
207              if(!std::any_of(SurgeRuleTypes.begin(), SurgeRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
208                  continue;
209              break;
210          case 3:
211              if(!startsWith(strLine, "DOMAIN-SUFFIX,") && !startsWith(strLine, "DOMAIN,"))
212                  continue;
213              if(filterLine())
214                  continue;
215              output_content += "  - '";
216              if(strLine[posb - 2] == 'X')
217                  output_content += "+.";
218              output_content += strLine.substr(posb, pose);
219              output_content += "'\n";
220              continue;
221          case 4:
222              if(!startsWith(strLine, "IP-CIDR,") && !startsWith(strLine, "IP-CIDR6,"))
223                  continue;
224              if(filterLine())
225                  continue;
226              output_content += "  - '";
227              output_content += strLine.substr(posb, pose);
228              output_content += "'\n";
229              continue;
230          case 5:
231              if(!startsWith(strLine, "DOMAIN-SUFFIX,") && !startsWith(strLine, "DOMAIN,"))
232                  continue;
233              if(filterLine())
234                  continue;
235              output_content += strLine.substr(posb, pose);
236              output_content += '\n';
237              continue;
238          case 6:
239              if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
240                  continue;
241              output_content += "  - ";
242          }
243          lineSize = strLine.size();
244          if(lineSize && strLine[lineSize - 1] == '\r') 
245              strLine.erase(--lineSize);
246          if(!strLine.empty() && (strLine[0] != ';' && strLine[0] != '#' && !(lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')))
247          {
248              if(type_int == 2)
249              {
250                  if(startsWith(strLine, "IP-CIDR6"))
251                      strLine.replace(0, 8, "IP6-CIDR");
252                  strLine += "," + group;
253                  if(count_least(strLine, ',', 3) && regReplace(strLine, rule_match_regex, "$2") == ",no-resolve")
254                      strLine = regReplace(strLine, rule_match_regex, "$1$3$2");
255                  else
256                      strLine = regReplace(strLine, rule_match_regex, "$1$3");
257              }
258          }
259          output_content += strLine;
260          output_content += '\n';
261      }
262      if(output_content == "payload:\n")
263      {
264          switch(type_int)
265          {
266          case 3:
267              output_content += "  - '--placeholder--'";
268              break;
269          case 4:
270              output_content += "  - '0.0.0.0/32'";
271              break;
272          case 6:
273              output_content += "  - 'DOMAIN,--placeholder--'";
274              break;
275          }
276      }
277      return output_content;
278  }
279  void checkExternalBase(const std::string &path, std::string &dest)
280  {
281      if(isLink(path) || (startsWith(path, global.basePath) && fileExist(path)))
282          dest = path;
283  }
284  std::string subconverter(RESPONSE_CALLBACK_ARGS)
285  {
286      std::string &argument = request.argument;
287      int *status_code = &response.status_code;
288      std::string argTarget = getUrlArg(argument, "target"), argSurgeVer = getUrlArg(argument, "ver");
289      tribool argClashNewField = getUrlArg(argument, "new_name");
290      int intSurgeVer = argSurgeVer.size() ? to_int(argSurgeVer, 3) : 3;
291      if(argTarget == "auto")
292          matchUserAgent(request.headers["User-Agent"], argTarget, argClashNewField, intSurgeVer);
293      bool lSimpleSubscription = false;
294      switch(hash_(argTarget))
295      {
296      case "ss"_hash: case "ssd"_hash: case "ssr"_hash: case "sssub"_hash: case "v2ray"_hash: case "trojan"_hash: case "mixed"_hash:
297          lSimpleSubscription = true;
298          break;
299      case "clash"_hash: case "clashr"_hash: case "surge"_hash: case "quan"_hash: case "quanx"_hash: case "loon"_hash: case "surfboard"_hash: case "mellow"_hash:
300          break;
301      default:
302          *status_code = 400;
303          return "Invalid target!";
304      }
305      if((!global.APIMode || global.CFWChildProcess) && !global.generatorMode)
306          readConf();
307      std::string argUrl = urlDecode(getUrlArg(argument, "url"));
308      std::string argGroupName = urlDecode(getUrlArg(argument, "group")), argUploadPath = getUrlArg(argument, "upload_path");
309      std::string argIncludeRemark = urlDecode(getUrlArg(argument, "include")), argExcludeRemark = urlDecode(getUrlArg(argument, "exclude"));
310      std::string argCustomGroups = urlSafeBase64Decode(getUrlArg(argument, "groups")), argCustomRulesets = urlSafeBase64Decode(getUrlArg(argument, "ruleset")), argExternalConfig = urlDecode(getUrlArg(argument, "config"));
311      std::string argDeviceID = getUrlArg(argument, "dev_id"), argFilename = urlDecode(getUrlArg(argument, "filename")), argUpdateInterval = getUrlArg(argument, "interval"), argUpdateStrict = getUrlArg(argument, "strict");
312      std::string argRenames = urlDecode(getUrlArg(argument, "rename")), argFilterScript = urlDecode(getUrlArg(argument, "filter_script"));
313      tribool argUpload = getUrlArg(argument, "upload"), argEmoji = getUrlArg(argument, "emoji"), argAddEmoji = getUrlArg(argument, "add_emoji"), argRemoveEmoji = getUrlArg(argument, "remove_emoji");
314      tribool argAppendType = getUrlArg(argument, "append_type"), argTFO = getUrlArg(argument, "tfo"), argUDP = getUrlArg(argument, "udp"), argGenNodeList = getUrlArg(argument, "list");
315      tribool argSort = getUrlArg(argument, "sort"), argUseSortScript = getUrlArg(argument, "sort_script");
316      tribool argGenClashScript = getUrlArg(argument, "script"), argEnableInsert = getUrlArg(argument, "insert");
317      tribool argSkipCertVerify = getUrlArg(argument, "scv"), argFilterDeprecated = getUrlArg(argument, "fdn"), argExpandRulesets = getUrlArg(argument, "expand"), argAppendUserinfo = getUrlArg(argument, "append_info");
318      tribool argPrependInsert = getUrlArg(argument, "prepend"), argGenClassicalRuleProvider = getUrlArg(argument, "classic"), argTLS13 = getUrlArg(argument, "tls13");
319      std::string base_content, output_content;
320      ProxyGroupConfigs lCustomProxyGroups = global.customProxyGroups;
321      RulesetConfigs lCustomRulesets = global.customRulesets;
322      string_array lIncludeRemarks = global.includeRemarks, lExcludeRemarks = global.excludeRemarks;
323      std::vector<RulesetContent> lRulesetContent;
324      extra_settings ext;
325      std::string subInfo, dummy;
326      int interval = argUpdateInterval.size() ? to_int(argUpdateInterval, global.updateInterval) : global.updateInterval;
327      bool authorized = !global.APIMode || getUrlArg(argument, "token") == global.accessToken, strict = argUpdateStrict.size() ? argUpdateStrict == "true" : global.updateStrict;
328      if(std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argIncludeRemark) != gRegexBlacklist.cend() || std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argExcludeRemark) != gRegexBlacklist.cend())
329          return "Invalid request!";
330      std::string lClashBase = global.clashBase, lSurgeBase = global.surgeBase, lMellowBase = global.mellowBase, lSurfboardBase = global.surfboardBase;
331      std::string lQuanBase = global.quanBase, lQuanXBase = global.quanXBase, lLoonBase = global.loonBase, lSSSubBase = global.SSSubBase;
332      argEnableInsert.define(global.enableInsert);
333      if(!argUrl.size() && (!global.APIMode || authorized))
334          argUrl = global.defaultUrls;
335      if((!argUrl.size() && !(global.insertUrls.size() && argEnableInsert)) || !argTarget.size())
336      {
337          *status_code = 400;
338          return "Invalid request!";
339      }
340      string_array req_args = split(argument, "&");
341      string_map req_arg_map;
342      for(std::string &x : req_args)
343      {
344          string_size pos = x.find("=");
345          if(pos == x.npos)
346          {
347              req_arg_map[x] = "";
348              continue;
349          }
350          if(x.substr(0, pos) == "token")
351              continue;
352          req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
353      }
354      req_arg_map["target"] = argTarget;
355      req_arg_map["ver"] = std::to_string(intSurgeVer);
356      template_args tpl_args;
357      tpl_args.global_vars = global.templateVars;
358      tpl_args.request_params = req_arg_map;
359      std::string proxy = parseProxy(global.proxySubscription);
360      ext.authorized = authorized;
361      ext.append_proxy_type = argAppendType.get(global.appendType);
362      if((argTarget == "clash" || argTarget == "clashr") && argGenClashScript.is_undef())
363          argExpandRulesets.define(true);
364      ext.clash_proxies_style = global.clashProxiesStyle;
365      ext.tfo.define(argTFO).define(global.TFOFlag);
366      ext.udp.define(argUDP).define(global.UDPFlag);
367      ext.skip_cert_verify.define(argSkipCertVerify).define(global.skipCertVerify);
368      ext.tls13.define(argTLS13).define(global.TLS13Flag);
369      ext.sort_flag = argSort.get(global.enableSort);
370      argUseSortScript.define(global.sortScript.size() != 0);
371      if(ext.sort_flag && argUseSortScript)
372          ext.sort_script = global.sortScript;
373      ext.filter_deprecated = argFilterDeprecated.get(global.filterDeprecated);
374      ext.clash_new_field_name = argClashNewField.get(global.clashUseNewField);
375      ext.clash_script = argGenClashScript.get();
376      ext.clash_classical_ruleset = argGenClassicalRuleProvider.get();
377      if(!argExpandRulesets)
378          ext.clash_new_field_name = true;
379      else
380          ext.clash_script = false;
381      ext.nodelist = argGenNodeList;
382      ext.surge_ssr_path = global.surgeSSRPath;
383      ext.quanx_dev_id = argDeviceID.size() ? argDeviceID : global.quanXDevID;
384      ext.enable_rule_generator = global.enableRuleGen;
385      ext.overwrite_original_rules = global.overwriteOriginalRules;
386      if(!argExpandRulesets)
387          ext.managed_config_prefix = global.managedConfigPrefix;
388      if(argExternalConfig.empty())
389          argExternalConfig = global.defaultExtConfig;
390      if(argExternalConfig.size())
391      {
392          writeLog(0, "External configuration file provided. Loading...", LOG_LEVEL_INFO);
393          ExternalConfig extconf;
394          extconf.tpl_args = &tpl_args;
395          if(loadExternalConfig(argExternalConfig, extconf) == 0)
396          {
397              if(!ext.nodelist)
398              {
399                  checkExternalBase(extconf.sssub_rule_base, lSSSubBase);
400                  if(!lSimpleSubscription)
401                  {
402                      checkExternalBase(extconf.clash_rule_base, lClashBase);
403                      checkExternalBase(extconf.surge_rule_base, lSurgeBase);
404                      checkExternalBase(extconf.surfboard_rule_base, lSurfboardBase);
405                      checkExternalBase(extconf.mellow_rule_base, lMellowBase);
406                      checkExternalBase(extconf.quan_rule_base, lQuanBase);
407                      checkExternalBase(extconf.quanx_rule_base, lQuanXBase);
408                      checkExternalBase(extconf.loon_rule_base, lLoonBase);
409                      if(extconf.surge_ruleset.size())
410                          lCustomRulesets = extconf.surge_ruleset;
411                      if(extconf.custom_proxy_group.size())
412                          lCustomProxyGroups = extconf.custom_proxy_group;
413                      ext.enable_rule_generator = extconf.enable_rule_generator;
414                      ext.overwrite_original_rules = extconf.overwrite_original_rules;
415                  }
416              }
417              if(extconf.rename.size())
418                  ext.rename_array = extconf.rename;
419              if(extconf.emoji.size())
420                  ext.emoji_array = extconf.emoji;
421              if(extconf.include.size())
422                  lIncludeRemarks = extconf.include;
423              if(extconf.exclude.size())
424                  lExcludeRemarks = extconf.exclude;
425              argAddEmoji.define(extconf.add_emoji);
426              argRemoveEmoji.define(extconf.remove_old_emoji);
427          }
428      }
429      else
430      {
431          if(!lSimpleSubscription)
432          {
433              if(argCustomGroups.size() && !ext.nodelist)
434              {
435                  string_array vArray = split(argCustomGroups, "@");
436                  lCustomProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
437              }
438              if(argCustomRulesets.size() && !ext.nodelist)
439              {
440                  string_array vArray = split(argCustomRulesets, "@");
<span onclick='openModal()' class='match'>441                  lCustomRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
442              }
443          }
</span>444      }
445      if(ext.enable_rule_generator && !ext.nodelist && !lSimpleSubscription)
446      {
447          if(lCustomRulesets != global.customRulesets)
448              refreshRulesets(lCustomRulesets, lRulesetContent);
449          else
450          {
451              if(global.updateRulesetOnRequest)
452                  refreshRulesets(global.customRulesets, global.rulesetsContent);
453              lRulesetContent = global.rulesetsContent;
454          }
455      }
456      if(!argEmoji.is_undef())
457      {
458          argAddEmoji.set(argEmoji);
459          argRemoveEmoji.set(true);
460      }
461      ext.add_emoji = argAddEmoji.get(global.addEmoji);
462      ext.remove_emoji = argRemoveEmoji.get(global.removeEmoji);
463      if(ext.add_emoji && ext.emoji_array.empty())
464          ext.emoji_array = safe_get_emojis();
465      if(argRenames.size())
466          ext.rename_array = INIBinding::from<RegexMatchConfig>::from_ini(split(argRenames, "`"), "@");
467      else if(ext.rename_array.empty())
468          ext.rename_array = safe_get_renames();
469      if(argIncludeRemark.size() && regValid(argIncludeRemark))
470          lIncludeRemarks = string_array{argIncludeRemark};
471      if(argExcludeRemark.size() && regValid(argExcludeRemark))
472          lExcludeRemarks = string_array{argExcludeRemark};
473      if(authorized && !global.scriptCleanContext)
474      {
475          ext.js_runtime = new qjs::Runtime();
476          script_runtime_init(*ext.js_runtime);
477          ext.js_context = new qjs::Context(*ext.js_runtime);
478          script_context_init(*ext.js_context);
479      }
480      RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();
481      string_array urls;
482      std::vector<Proxy> nodes, insert_nodes;
483      int groupID = 0;
484      parse_settings parse_set;
485      parse_set.proxy = &proxy;
486      parse_set.exclude_remarks = &lExcludeRemarks;
487      parse_set.include_remarks = &lIncludeRemarks;
488      parse_set.stream_rules = &stream_temp;
489      parse_set.time_rules = &time_temp;
490      parse_set.sub_info = &subInfo;
491      parse_set.authorized = authorized;
492      parse_set.request_header = &request.headers;
493      parse_set.js_runtime = ext.js_runtime;
494      parse_set.js_context = ext.js_context;
495      if(global.insertUrls.size() && argEnableInsert)
496      {
497          groupID = -1;
498          urls = split(global.insertUrls, "|");
499          importItems(urls, true);
500          for(std::string &x : urls)
501          {
502              x = regTrim(x);
503              writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
504              if(addNodes(x, insert_nodes, groupID, parse_set) == -1)
505              {
506                  if(global.skipFailedLinks)
507                      writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
508                  else
509                  {
510                      *status_code = 400;
511                      return "The following link doesn't contain any valid node info: " + x;
512                  }
513              }
514              groupID--;
515          }
516      }
517      urls = split(argUrl, "|");
518      importItems(urls, true);
519      groupID = 0;
520      for(std::string &x : urls)
521      {
522          x = regTrim(x);
523          writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
524          if(addNodes(x, nodes, groupID, parse_set) == -1)
525          {
526              if(global.skipFailedLinks)
527                  writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
528              else
529              {
530                  *status_code = 400;
531                  return "The following link doesn't contain any valid node info: " + x;
532              }
533          }
534          groupID++;
535      }
536      if(!nodes.size() && !insert_nodes.size())
537      {
538          *status_code = 400;
539          return "No nodes were found!";
540      }
541      if(subInfo.size() && argAppendUserinfo.get(global.appendUserinfo))
542          response.headers.emplace("Subscription-UserInfo", subInfo);
543      if(request.method == "HEAD")
544          return "";
545      argPrependInsert.define(global.prependInsert);
546      if(argPrependInsert)
547      {
548          std::move(nodes.begin(), nodes.end(), std::back_inserter(insert_nodes));
549          nodes.swap(insert_nodes);
550      }
551      else
552      {
553          std::move(insert_nodes.begin(), insert_nodes.end(), std::back_inserter(nodes));
554      }
555      std::string filterScript = global.filterScript;
556      if(authorized && !argFilterScript.empty())
557          filterScript = argFilterScript;
558      if(filterScript.size())
559      {
560          if(startsWith(filterScript, "path:"))
561              filterScript = fileGet(filterScript.substr(5), false);
562          script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
563          {
564              try
565              {
566                  ctx.eval(filterScript);
567                  auto filter = (std::function<bool(const Proxy&)>) ctx.eval("filter");
568                  nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());
569              }
570              catch(qjs::exception)
571              {
572                  script_print_stack(ctx);
573              }
574          }, global.scriptCleanContext);
575      }
576      if(argGroupName.size())
577          for(Proxy &x : nodes)
578              x.Group = argGroupName;
579      preprocessNodes(nodes, ext);
580      ProxyGroupConfigs dummy_group;
581      std::vector<RulesetContent> dummy_ruleset;
582      std::string managed_url = base64Decode(urlDecode(getUrlArg(argument, "profile_data")));
583      if(managed_url.empty())
584          managed_url = global.managedConfigPrefix + "/sub?" + argument;
585      proxy = parseProxy(global.proxyConfig);
586      switch(hash_(argTarget))
587      {
588      case "clash"_hash: case "clashr"_hash:
589          writeLog(0, argTarget == "clashr" ? "Generate target: ClashR" : "Generate target: Clash", LOG_LEVEL_INFO);
590          tpl_args.local_vars["clash.new_field_name"] = ext.clash_new_field_name ? "true" : "false";
591          response.headers["profile-update-interval"] = std::to_string(interval / 3600);
592          if(ext.nodelist)
593          {
594              YAML::Node yamlnode;
595              proxyToClash(nodes, yamlnode, dummy_group, argTarget == "clashr", ext);
596              output_content = YAML::Dump(yamlnode);
597          }
598          else
599          {
600              if(render_template(fetchFile(lClashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
601              {
602                  *status_code = 400;
603                  return base_content;
604              }
605              output_content = proxyToClash(nodes, base_content, lRulesetContent, lCustomProxyGroups, argTarget == "clashr", ext);
606          }
607          if(argUpload)
608              uploadGist(argTarget, argUploadPath, output_content, false);
609          break;
610      case "surge"_hash:
611          writeLog(0, "Generate target: Surge " + std::to_string(intSurgeVer), LOG_LEVEL_INFO);
612          if(ext.nodelist)
613          {
614              output_content = proxyToSurge(nodes, base_content, dummy_ruleset, dummy_group, intSurgeVer, ext);
615              if(argUpload)
616                  uploadGist("surge" + argSurgeVer + "list", argUploadPath, output_content, true);
617          }
618          else
619          {
620              if(render_template(fetchFile(lSurgeBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
621              {
622                  *status_code = 400;
623                  return base_content;
624              }
625              output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, intSurgeVer, ext);
626              if(argUpload)
627                  uploadGist("surge" + argSurgeVer, argUploadPath, output_content, true);
628              if(global.writeManagedConfig && global.managedConfigPrefix.size())
629                  output_content = "#!MANAGED-CONFIG " + managed_url + (interval ? " interval=" + std::to_string(interval) : "") \
630                   + " strict=" + std::string(strict ? "true" : "false") + "\n\n" + output_content;
631          }
632          break;
633      case "surfboard"_hash:
634          writeLog(0, "Generate target: Surfboard", LOG_LEVEL_INFO);
635          if(render_template(fetchFile(lSurfboardBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
636          {
637              *status_code = 400;
638              return base_content;
639          }
640          output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, -3, ext);
641          if(argUpload)
642              uploadGist("surfboard", argUploadPath, output_content, true);
643          if(global.writeManagedConfig && global.managedConfigPrefix.size())
644              output_content = "#!MANAGED-CONFIG " + managed_url + (interval ? " interval=" + std::to_string(interval) : "") \
645                   + " strict=" + std::string(strict ? "true" : "false") + "\n\n" + output_content;
646          break;
647      case "mellow"_hash:
648          writeLog(0, "Generate target: Mellow", LOG_LEVEL_INFO);
649          if(render_template(fetchFile(lMellowBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
650          {
651              *status_code = 400;
652              return base_content;
653          }
654          output_content = proxyToMellow(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
655          if(argUpload)
656              uploadGist("mellow", argUploadPath, output_content, true);
657          break;
658      case "sssub"_hash:
659          writeLog(0, "Generate target: SS Subscription", LOG_LEVEL_INFO);
660          if(render_template(fetchFile(lSSSubBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
661          {
662              *status_code = 400;
663              return base_content;
664          }
665          output_content = proxyToSSSub(base_content, nodes, ext);
666          if(argUpload)
667              uploadGist("sssub", argUploadPath, output_content, false);
668          break;
669      case "ss"_hash:
670          writeLog(0, "Generate target: SS", LOG_LEVEL_INFO);
671          output_content = proxyToSingle(nodes, 1, ext);
672          if(argUpload)
673              uploadGist("ss", argUploadPath, output_content, false);
674          break;
675      case "ssr"_hash:
676          writeLog(0, "Generate target: SSR", LOG_LEVEL_INFO);
677          output_content = proxyToSingle(nodes, 2, ext);
678          if(argUpload)
679              uploadGist("ssr", argUploadPath, output_content, false);
680          break;
681      case "v2ray"_hash:
682          writeLog(0, "Generate target: v2rayN", LOG_LEVEL_INFO);
683          output_content = proxyToSingle(nodes, 4, ext);
684          if(argUpload)
685              uploadGist("v2ray", argUploadPath, output_content, false);
686          break;
687      case "trojan"_hash:
688          writeLog(0, "Generate target: Trojan", LOG_LEVEL_INFO);
689          output_content = proxyToSingle(nodes, 8, ext);
690          if(argUpload)
691              uploadGist("trojan", argUploadPath, output_content, false);
692          break;
693      case "mixed"_hash:
694          writeLog(0, "Generate target: Standard Subscription", LOG_LEVEL_INFO);
695          output_content = proxyToSingle(nodes, 15, ext);
696          if(argUpload)
697              uploadGist("sub", argUploadPath, output_content, false);
698          break;
699      case "quan"_hash:
700          writeLog(0, "Generate target: Quantumult", LOG_LEVEL_INFO);
701          if(!ext.nodelist)
702          {
703              if(render_template(fetchFile(lQuanBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
704              {
705                  *status_code = 400;
706                  return base_content;
707              }
708          }
709          output_content = proxyToQuan(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
710          if(argUpload)
711              uploadGist("quan", argUploadPath, output_content, false);
712          break;
713      case "quanx"_hash:
714          writeLog(0, "Generate target: Quantumult X", LOG_LEVEL_INFO);
715          if(!ext.nodelist)
716          {
717              if(render_template(fetchFile(lQuanXBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
718              {
719                  *status_code = 400;
720                  return base_content;
721              }
722          }
723          output_content = proxyToQuanX(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
724          if(argUpload)
725              uploadGist("quanx", argUploadPath, output_content, false);
726          break;
727      case "loon"_hash:
728          writeLog(0, "Generate target: Loon", LOG_LEVEL_INFO);
729          if(!ext.nodelist)
730          {
731              if(render_template(fetchFile(lLoonBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
732              {
733                  *status_code = 400;
734                  return base_content;
735              }
736          }
737          output_content = proxyToLoon(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
738          if(argUpload)
739              uploadGist("loon", argUploadPath, output_content, false);
740          break;
741      case "ssd"_hash:
742          writeLog(0, "Generate target: SSD", LOG_LEVEL_INFO);
743          output_content = proxyToSSD(nodes, argGroupName, subInfo, ext);
744          if(argUpload)
745              uploadGist("ssd", argUploadPath, output_content, false);
746          break;
747      default:
748          writeLog(0, "Generate target: Unspecified", LOG_LEVEL_INFO);
749          *status_code = 500;
750          return "Unrecognized target";
751      }
752      writeLog(0, "Generate completed.", LOG_LEVEL_INFO);
753      if(argFilename.size())
754          response.headers.emplace("Content-Disposition", "attachment; filename=\"" + argFilename + "\"; filename*=utf-8''" + urlEncode(argFilename));
755      return output_content;
756  }
757  std::string simpleToClashR(RESPONSE_CALLBACK_ARGS)
758  {
759      std::string &argument = request.argument;
760      int *status_code = &response.status_code;
761      std::string url = argument.size() <= 8 ? "" : argument.substr(8);
762      if(!url.size() || argument.substr(0, 8) != "sublink=")
763      {
764          *status_code = 400;
765          return "Invalid request!";
766      }
767      if(url == "sublink")
768      {
769          *status_code = 400;
770          return "Please insert your subscription link instead of clicking the default link.";
771      }
772      request.argument = "target=clashr&url=" + urlEncode(url);
773      return subconverter(request, response);
774  }
775  std::string surgeConfToClash(RESPONSE_CALLBACK_ARGS)
776  {
777      std::string &argument = request.argument;
778      int *status_code = &response.status_code;
779      INIReader ini;
780      string_array dummy_str_array;
781      std::vector<Proxy> nodes;
782      std::string base_content, url = argument.size() <= 5 ? "" : argument.substr(5);
783      const std::string proxygroup_name = global.clashUseNewField ? "proxy-groups" : "Proxy Group", rule_name = global.clashUseNewField ? "rules" : "Rule";
784      ini.store_any_line = true;
785      if(!url.size())
786          url = global.defaultUrls;
787      if(!url.size() || argument.substr(0, 5) != "link=")
788      {
789          *status_code = 400;
790          return "Invalid request!";
791      }
792      if(url == "link")
793      {
794          *status_code = 400;
795          return "Please insert your subscription link instead of clicking the default link.";
796      }
797      writeLog(0, "SurgeConfToClash called with url '" + url + "'.", LOG_LEVEL_INFO);
798      std::string proxy = parseProxy(global.proxyConfig);
799      YAML::Node clash;
800      template_args tpl_args;
801      tpl_args.global_vars = global.templateVars;
802      tpl_args.local_vars["clash.new_field_name"] = global.clashUseNewField ? "true" : "false";
803      tpl_args.request_params["target"] = "clash";
804      tpl_args.request_params["url"] = url;
805      if(render_template(fetchFile(global.clashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
806      {
807          *status_code = 400;
808          return base_content;
809      }
810      clash = YAML::Load(base_content);
811      base_content = fetchFile(url, proxy, global.cacheConfig);
812      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
813      {
814          std::string errmsg = "Parsing Surge config failed! Reason: " + ini.GetLastError();
815          writeLog(0, errmsg, LOG_LEVEL_ERROR);
816          *status_code = 400;
817          return errmsg;
818      }
819      if(!ini.SectionExist("Proxy") || !ini.SectionExist("Proxy Group") || !ini.SectionExist("Rule"))
820      {
821          std::string errmsg = "Incomplete surge config! Missing critical sections!";
822          writeLog(0, errmsg, LOG_LEVEL_ERROR);
823          *status_code = 400;
824          return errmsg;
825      }
826      string_multimap section;
827      ini.GetItems("Proxy Group", section);
828      std::string name, type, content;
829      string_array links;
830      links.emplace_back(url);
831      YAML::Node singlegroup;
832      for(auto &x : section)
833      {
834          singlegroup.reset();
835          name = x.first;
836          content = x.second;
837          dummy_str_array = split(content, ",");
838          if(!dummy_str_array.size())
839              continue;
840          type = dummy_str_array[0];
841          if(!(type == "select" || type == "url-test" || type == "fallback" || type == "load-balance")) 
842              continue;
843          singlegroup["name"] = name;
844          singlegroup["type"] = type;
845          for(unsigned int i = 1; i < dummy_str_array.size(); i++)
846          {
847              if(startsWith(dummy_str_array[i], "url"))
848                  singlegroup["url"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1));
849              else if(startsWith(dummy_str_array[i], "interval"))
850                  singlegroup["interval"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1));
851              else if(startsWith(dummy_str_array[i], "policy-path"))
852                  links.emplace_back(trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1)));
853              else
854                  singlegroup["proxies"].push_back(trim(dummy_str_array[i]));
855          }
856          clash[proxygroup_name].push_back(singlegroup);
857      }
858      proxy = parseProxy(global.proxySubscription);
859      eraseElements(dummy_str_array);
860      RegexMatchConfigs dummy_regex_array;
861      std::string subInfo;
862      parse_settings parse_set;
863      parse_set.proxy = &proxy;
864      parse_set.exclude_remarks = parse_set.include_remarks = &dummy_str_array;
865      parse_set.stream_rules = parse_set.time_rules = &dummy_regex_array;
866      parse_set.request_header = &request.headers;
867      parse_set.sub_info = &subInfo;
868      parse_set.authorized = !global.APIMode;
869      for(std::string &x : links)
870      {
871          writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
872          if(addNodes(x, nodes, 0, parse_set) == -1)
873          {
874              if(global.skipFailedLinks)
875                  writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
876              else
877              {
878                  *status_code = 400;
879                  return "The following link doesn't contain any valid node info: " + x;
880              }
881          }
882      }
883      if(!nodes.size())
884      {
885          *status_code = 400;
886          return "No nodes were found!";
887      }
888      extra_settings ext;
889      ext.sort_flag = global.enableSort;
890      ext.filter_deprecated = global.filterDeprecated;
891      ext.clash_new_field_name = global.clashUseNewField;
892      ext.udp = global.UDPFlag;
893      ext.tfo = global.TFOFlag;
894      ext.skip_cert_verify = global.skipCertVerify;
895      ext.tls13 = global.TLS13Flag;
896      ext.clash_proxies_style = global.clashProxiesStyle;
897      ProxyGroupConfigs dummy_groups;
898      proxyToClash(nodes, clash, dummy_groups, false, ext);
899      section.clear();
900      ini.GetItems("Proxy", section);
901      for(auto &x : section)
902      {
903          singlegroup.reset();
904          name = x.first;
905          content = x.second;
906          dummy_str_array = split(content, ",");
907          if(!dummy_str_array.size())
908              continue;
909          content = trim(dummy_str_array[0]);
910          switch(hash_(content))
911          {
912          case "direct"_hash:
913              singlegroup["name"] = name;
914              singlegroup["type"] = "select";
915              singlegroup["proxies"].push_back("DIRECT");
916              break;
917          case "reject"_hash:
918          case "reject-tinygif"_hash:
919              singlegroup["name"] = name;
920              singlegroup["type"] = "select";
921              singlegroup["proxies"].push_back("REJECT");
922              break;
923          default:
924              continue;
925          }
926          clash[proxygroup_name].push_back(singlegroup);
927      }
928      eraseElements(dummy_str_array);
929      ini.GetAll("Rule", "{NONAME}", dummy_str_array);
930      YAML::Node rule;
931      string_array strArray;
932      std::string strLine;
933      std::stringstream ss;
934      std::string::size_type lineSize;
935      for(std::string &x : dummy_str_array)
936      {
937          if(startsWith(x, "RULE-SET"))
938          {
939              strArray = split(x, ",");
940              if(strArray.size() != 3)
941                  continue;
942              content = webGet(strArray[1], proxy, global.cacheRuleset);
943              if(!content.size())
944                  continue;
945              ss << content;
946              char delimiter = getLineBreak(content);
947              while(getline(ss, strLine, delimiter))
948              {
949                  lineSize = strLine.size();
950                  if(lineSize && strLine[lineSize - 1] == '\r') 
951                      strLine.erase(--lineSize);
952                  if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) 
953                      continue;
954                  else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);})) 
955                      continue;
956                  strLine += strArray[2];
957                  if(count_least(strLine, ',', 3))
958                      strLine = regReplace(strLine, "^(.*?,.*?)(,.*)(,.*)$", "$1$3$2");
959                  rule.push_back(strLine);
960              }
961              ss.clear();
962              continue;
963          }
964          else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
965              continue;
966          rule.push_back(x);
967      }
968      clash[rule_name] = rule;
969      response.headers["profile-update-interval"] = std::to_string(global.updateInterval / 3600);
970      writeLog(0, "Conversion completed.", LOG_LEVEL_INFO);
971      return YAML::Dump(clash);
972  }
973  std::string getProfile(RESPONSE_CALLBACK_ARGS)
974  {
975      std::string &argument = request.argument;
976      int *status_code = &response.status_code;
977      std::string name = urlDecode(getUrlArg(argument, "name")), token = urlDecode(getUrlArg(argument, "token"));
978      string_array profiles = split(name, "|");
979      name = profiles[0];
980      if(token.empty() || name.empty())
981      {
982          *status_code = 403;
983          return "Forbidden";
984      }
985      std::string profile_content;
986      if(fileExist(name))
987      {
988          profile_content = fileGet(name, true);
989      }
990      else
991      {
992          *status_code = 404;
993          return "Profile not found";
994      }
995      writeLog(0, "Trying to load profile '" + name + "'.", LOG_LEVEL_INFO);
996      INIReader ini;
997      if(ini.Parse(profile_content) != INIREADER_EXCEPTION_NONE && !ini.SectionExist("Profile"))
998      {
999          writeLog(0, "Load profile failed! Reason: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1000          *status_code = 500;
1001          return "Broken profile!";
1002      }
1003      writeLog(0, "Trying to parse profile '" + name + "'.", LOG_LEVEL_INFO);
1004      string_multimap contents;
1005      ini.GetItems("Profile", contents);
1006      if(!contents.size())
1007      {
1008          writeLog(0, "Load profile failed! Reason: Empty Profile section", LOG_LEVEL_ERROR);
1009          *status_code = 500;
1010          return "Broken profile!";
1011      }
1012      auto profile_token = contents.find("profile_token");
1013      if(profiles.size() == 1 && profile_token != contents.end())
1014      {
1015          if(token != profile_token->second)
1016          {
1017              *status_code = 403;
1018              return "Forbidden";
1019          }
1020          token = global.accessToken;
1021      }
1022      else
1023      {
1024          if(token != global.accessToken)
1025          {
1026              *status_code = 403;
1027              return "Forbidden";
1028          }
1029      }
1030      if(profiles.size() > 1)
1031      {
1032          writeLog(0, "Multiple profiles are provided. Trying to combine profiles...", LOG_TYPE_INFO);
1033          std::string all_urls, url;
1034          auto iter = contents.find("url");
1035          if(iter != contents.end())
1036              all_urls = iter->second;
1037          for(size_t i = 1; i < profiles.size(); i++)
1038          {
1039              name = profiles[i];
1040              if(!fileExist(name))
1041              {
1042                  writeLog(0, "Ignoring non-exist profile '" + name + "'...", LOG_LEVEL_WARNING);
1043                  continue;
1044              }
1045              if(ini.ParseFile(name) != INIREADER_EXCEPTION_NONE && !ini.SectionExist("Profile"))
1046              {
1047                  writeLog(0, "Ignoring broken profile '" + name + "'...", LOG_LEVEL_WARNING);
1048                  continue;
1049              }
1050              url = ini.Get("Profile", "url");
1051              if(url.size())
1052              {
1053                  all_urls += "|" + url;
1054                  writeLog(0, "Profile url from '" + name + "' added.", LOG_LEVEL_INFO);
1055              }
1056              else
1057              {
1058                  writeLog(0, "Profile '" + name + "' does not have url key. Skipping...", LOG_LEVEL_INFO);
1059              }
1060          }
1061          iter->second = all_urls;
1062      }
1063      contents.emplace("token", token);
1064      contents.emplace("profile_data", base64Encode(global.managedConfigPrefix + "/getprofile?" + argument));
1065      std::string query = std::accumulate(contents.begin(), contents.end(), std::string(), [](const std::string &x, auto y){ return x + y.first + "=" + urlEncode(y.second) + "&"; });
1066      query += argument;
1067      request.argument = query;
1068      return subconverter(request, response);
1069  }
1070  inline std::string intToStream(unsigned long long stream)
1071  {
1072      char chrs[16] = {}, units[6] = {' ', 'K', 'M', 'G', 'T', 'P'};
1073      double streamval = stream;
1074      unsigned int level = 0;
1075      while(streamval > 1024.0)
1076      {
1077          if(level >= 5)
1078              break;
1079          level++;
1080          streamval /= 1024.0;
1081      }
1082      snprintf(chrs, 15, "%.2f %cB", streamval, units[level]);
1083      return std::string(chrs);
1084  }
1085  std::string subInfoToMessage(std::string subinfo)
1086  {
1087      using ull = unsigned long long;
1088      subinfo = replaceAllDistinct(subinfo, "; ", "&");
1089      std::string retdata, useddata = "N/A", totaldata = "N/A", expirydata = "N/A";
1090      std::string upload = getUrlArg(subinfo, "upload"), download = getUrlArg(subinfo, "download"), total = getUrlArg(subinfo, "total"), expire = getUrlArg(subinfo, "expire");
1091      ull used = to_number<ull>(upload, 0) + to_number<ull>(download, 0), tot = to_number<ull>(total, 0);
1092      time_t expiry = to_number<time_t>(expire, 0);
1093      if(used != 0)
1094          useddata = intToStream(used);
1095      if(tot != 0)
1096          totaldata = intToStream(tot);
1097      if(expiry != 0)
1098      {
1099          char buffer[30];
1100          struct tm *dt = localtime(&expiry);
1101          strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M", dt);
1102          expirydata.assign(buffer);
1103      }
1104      if(useddata == "N/A" && totaldata == "N/A" && expirydata == "N/A")
1105          retdata = "Not Available";
1106      else
1107          retdata += "Stream Used: " + useddata + " Stream Total: " + totaldata + " Expiry Time: " + expirydata;
1108      return retdata;
1109  }
1110  int simpleGenerator()
1111  {
1112      writeLog(0, "Reading generator configuration...", LOG_LEVEL_INFO);
1113      std::string config = fileGet("generate.ini"), path, profile, arguments, content;
1114      if(config.empty())
1115      {
1116          writeLog(0, "Generator configuration not found or empty!", LOG_LEVEL_ERROR);
1117          return -1;
1118      }
1119      INIReader ini;
1120      if(ini.Parse(config) != INIREADER_EXCEPTION_NONE)
1121      {
1122          writeLog(0, "Generator configuration broken! Reason:" + ini.GetLastError(), LOG_LEVEL_ERROR);
1123          return -2;
1124      }
1125      writeLog(0, "Read generator configuration completed.\n", LOG_LEVEL_INFO);
1126      string_array sections = ini.GetSections();
1127      if(global.generateProfiles.size())
1128      {
1129          writeLog(0, "Generating with specific artifacts: \"" + global.generateProfiles + "\"...", LOG_LEVEL_INFO);
1130          string_array targets = split(global.generateProfiles, ","), new_targets;
1131          for(std::string &x : targets)
1132          {
1133              x = trim(x);
1134              if(std::find(sections.cbegin(), sections.cend(), x) != sections.cend())
1135                  new_targets.emplace_back(std::move(x));
1136              else
1137              {
1138                  writeLog(0, "Artifact \"" + x + "\" not found in generator settings!", LOG_LEVEL_ERROR);
1139                  return -3;
1140              }
1141          }
1142          sections = new_targets;
1143          sections.shrink_to_fit();
1144      }
1145      else
1146          writeLog(0, "Generating all artifacts...", LOG_LEVEL_INFO);
1147      string_multimap allItems;
1148      std::string proxy = parseProxy(global.proxySubscription);
1149      Request request;
1150      Response response;
1151      for(std::string &x : sections)
1152      {
1153          arguments.clear();
1154          response.status_code = 200;
1155          writeLog(0, "Generating artifact '" + x + "'...", LOG_LEVEL_INFO);
1156          ini.EnterSection(x);
1157          if(ini.ItemExist("path"))
1158              path = ini.Get("path");
1159          else
1160          {
1161              writeLog(0, "Artifact '" + x + "' output path missing! Skipping...\n", LOG_LEVEL_ERROR);
1162              continue;
1163          }
1164          if(ini.ItemExist("profile"))
1165          {
1166              profile = ini.Get("profile");
1167              request.argument = "name=" + urlEncode(profile) + "&token=" + global.accessToken + "&expand=true";
1168              content = getProfile(request, response);
1169          }
1170          else
1171          {
1172              if(ini.GetBool("direct") == true)
1173              {
1174                  std::string url = ini.Get("url");
1175                  content = fetchFile(url, proxy, global.cacheSubscription);
1176                  if(content.empty())
1177                  {
1178                      writeLog(0, "Artifact '" + x + "' generate ERROR! Please check your link.\n", LOG_LEVEL_ERROR);
1179                      if(sections.size() == 1)
1180                          return -1;
1181                  }
1182                  fileWrite(path, "\xEF\xBB\xBF" + content, true);
1183                  continue;
1184              }
1185              ini.GetItems(allItems);
1186              allItems.emplace("expand", "true");
1187              for(auto &y : allItems)
1188              {
1189                  if(y.first == "path")
1190                      continue;
1191                  arguments += y.first + "=" + urlEncode(y.second) + "&";
1192              }
1193              arguments.erase(arguments.size() - 1);
1194              request.argument = arguments;
1195              content = subconverter(request, response);
1196          }
1197          if(response.status_code != 200)
1198          {
1199              writeLog(0, "Artifact '" + x + "' generate ERROR! Reason: " + content + "\n", LOG_LEVEL_ERROR);
1200              if(sections.size() == 1)
1201                  return -1;
1202              continue;
1203          }
1204          fileWrite(path, content, true);
1205          auto iter = std::find_if(response.headers.begin(), response.headers.end(), [](auto y){ return y.first == "Subscription-UserInfo"; });
1206          if(iter != response.headers.end())
1207              writeLog(0, "User Info for artifact '" + x + "': " + subInfoToMessage(iter->second), LOG_LEVEL_INFO);
1208          writeLog(0, "Artifact '" + x + "' generate SUCCESS!\n", LOG_LEVEL_INFO);
1209          eraseElements(response.headers);
1210      }
1211      writeLog(0, "All artifact generated. Exiting...", LOG_LEVEL_INFO);
1212      return 0;
1213  }
1214  std::string renderTemplate(RESPONSE_CALLBACK_ARGS)
1215  {
1216      std::string &argument = request.argument;
1217      int *status_code = &response.status_code;
1218      std::string path = urlDecode(getUrlArg(argument, "path"));
1219      writeLog(0, "Trying to render template '" + path + "'...", LOG_LEVEL_INFO);
1220      if(!startsWith(path, global.templatePath) || !fileExist(path))
1221      {
1222          *status_code = 404;
1223          return "Not found";
1224      }
1225      std::string template_content = fetchFile(path, parseProxy(global.proxyConfig), global.cacheConfig);
1226      if(template_content.empty())
1227      {
1228          *status_code = 400;
1229          return "File empty or out of scope";
1230      }
1231      template_args tpl_args;
1232      tpl_args.global_vars = global.templateVars;
1233      string_array req_args = split(argument, "&");
1234      string_size pos;
1235      string_map req_arg_map;
1236      for(std::string &x : req_args)
1237      {
1238          pos = x.find("=");
1239          if(pos == x.npos)
1240              req_arg_map[x] = "";
1241          else
1242              req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
1243      }
1244      tpl_args.request_params = req_arg_map;
1245      std::string output_content;
1246      if(render_template(template_content, tpl_args, output_content, global.templatePath) != 0)
1247      {
1248          *status_code = 400;
1249          writeLog(0, "Render failed with error.", LOG_LEVEL_WARNING);
1250      }
1251      else
1252          writeLog(0, "Render completed.", LOG_LEVEL_INFO);
1253      return output_content;
1254  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</div>
                </div>
                <div class="column column_space"><pre><code>436                  lCustomProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
437              }
438              if(argCustomRulesets.size() && !ext.nodelist)
</pre></code></div>
                <div class="column column_space"><pre><code>441                  lCustomRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
442              }
443          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    