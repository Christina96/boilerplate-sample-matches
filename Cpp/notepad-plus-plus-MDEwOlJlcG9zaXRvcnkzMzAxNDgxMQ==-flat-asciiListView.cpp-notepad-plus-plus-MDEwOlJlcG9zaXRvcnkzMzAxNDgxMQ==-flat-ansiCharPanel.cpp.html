
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-asciiListView.cpp</h3>
            <pre><code>1  #include "asciiListView.h"
2  #include "Parameters.h"
3  void AsciiListView::resetValues(int codepage)
4  {
5  	if (codepage == -1)
6  		codepage = 0;
7  	if (_codepage == codepage)
8  		return;
9  	ListView_DeleteAllItems(_hSelf);
10  	setValues(codepage);
11  }
12  generic_string AsciiListView::getAscii(unsigned char value)
13  {
14  	switch (value)
15  	{
16  		case 0:
17  			return TEXT("NULL");
18  		case 1:
19  			return TEXT("SOH");
20  		case 2:
21  			return TEXT("STX");
22  		case 3:
23  			return TEXT("ETX");
24  		case 4:
25  			return TEXT("EOT");
26  		case 5:
27  			return TEXT("ENQ");
28  		case 6:
29  			return TEXT("ACK");
30  		case 7:
31  			return TEXT("BEL");
32  		case 8:
33  			return TEXT("BS");
34  		case 9:
35  			return TEXT("TAB");
36  		case 10:
37  			return TEXT("LF");
38  		case 11:
39  			return TEXT("VT");
40  		case 12:
41  			return TEXT("FF");
42  		case 13:
43  			return TEXT("CR");
44  		case 14:
45  			return TEXT("SO");
46  		case 15:
47  			return TEXT("SI");
48  		case 16:
49  			return TEXT("DLE");
50  		case 17:
51  			return TEXT("DC1");
52  		case 18:
53  			return TEXT("DC2");
54  		case 19:
55  			return TEXT("DC3");
56  		case 20:
57  			return TEXT("DC4");
58  		case 21:
59  			return TEXT("NAK");
60  		case 22:
61  			return TEXT("SYN");
62  		case 23:
63  			return TEXT("ETB");
64  		case 24:
65  			return TEXT("CAN");
66  		case 25:
67  			return TEXT("EM");
68  		case 26:
69  			return TEXT("SUB");
70  		case 27:
71  			return TEXT("ESC");
72  		case 28:
73  			return TEXT("FS");
74  		case 29:
75  			return TEXT("GS");
76  		case 30:
77  			return TEXT("RS");
78  		case 31:
79  			return TEXT("US");
80  		case 32:
81  			return TEXT("Space");
82  		case 127:
83  			return TEXT("DEL");
84  		default:
85  		{
<span onclick='openModal()' class='match'>86  			wchar_t charStr[10]{};
87  			char ascii[2]{};
88  			ascii[0] = value;
</span>89  			ascii[1] = '\0';
90  			MultiByteToWideChar(_codepage, 0, ascii, -1, charStr, _countof(charStr));
91  			return charStr;
92  		}
93  	}
94  }
95  generic_string AsciiListView::getHtmlName(unsigned char value)
96  {
97  	switch (value)
98  	{
99  		case 33:
100  			return TEXT("&excl;");
101  		case 34:
102  			return TEXT("&quot;");
103  		case 35:
104  			return TEXT("&num;");
105  		case 36:
106  			return TEXT("&dollar;");
107  		case 37:
108  			return TEXT("&percnt;");
109  		case 38:
110  			return TEXT("&amp;");
111  		case 39:
112  			return TEXT("&apos;");
113  		case 40:
114  			return TEXT("&lpar;");
115  		case 41:
116  			return TEXT("&rpar;");
117  		case 42:
118  			return TEXT("&ast;");
119  		case 43:
120  			return TEXT("&plus;");
121  		case 44:
122  			return TEXT("&comma;");
123  		case 45:
124  			return TEXT("&minus;");
125  		case 46:
126  			return TEXT("&period;");
127  		case 47:
128  			return TEXT("&sol;");
129  		case 58:
130  			return TEXT("&colon;");
131  		case 59:
132  			return TEXT("&semi;");
133  		case 60:
134  			return TEXT("&lt;");
135  		case 61:
136  			return TEXT("&equals;");
137  		case 62:
138  			return TEXT("&gt;");
139  		case 63:
140  			return TEXT("&quest;");
141  		case 64:
142  			return TEXT("&commat;");
143  		case 91:
144  			return TEXT("&lbrack;");
145  		case 92:
146  			return TEXT("&bsol;");
147  		case 93:
148  			return TEXT("&rbrack;");
149  		case 94:
150  			return TEXT("&Hat;");
151  		case 95:
152  			return TEXT("&lowbar;");
153  		case 96:
154  			return TEXT("&grave;");
155  		case 123:
156  			return TEXT("&lbrace;");
157  		case 124:
158  			return TEXT("&vert;");
159  		case 125:
160  			return TEXT("&rbrace;");
161  		case 126:
162  			return TEXT(""); 
163  		case 128:
164  			return TEXT("&euro;");
165  		case 130:
166  			return TEXT("&sbquo;");
167  		case 131:
168  			return TEXT("&fnof;");
169  		case 132:
170  			return TEXT("&bdquo;");
171  		case 133:
172  			return TEXT("&hellip;");
173  		case 134:
174  			return TEXT("&dagger;");
175  		case 135:
176  			return TEXT("&Dagger;");
177  		case 136:
178  			return TEXT("&circ;");
179  		case 137:
180  			return TEXT("&permil;");
181  		case 138:
182  			return TEXT("&Scaron;");
183  		case 139:
184  			return TEXT("&lsaquo;");
185  		case 140:
186  			return TEXT("&OElig;");
187  		case 142:
188  			return TEXT("&Zcaron;");
189  		case 145:
190  			return TEXT("&lsquo;");
191  		case 146:
192  			return TEXT("&rsquo;");
193  		case 147:
194  			return TEXT("&ldquo;");
195  		case 148:
196  			return TEXT("&rdquo;");
197  		case 149:
198  			return TEXT("&bull;");
199  		case 150:
200  			return TEXT("&ndash;");
201  		case 151:
202  			return TEXT("&mdash;");
203  		case 152:
204  			return TEXT("&tilde;");
205  		case 153:
206  			return TEXT("&trade;");
207  		case 154:
208  			return TEXT("&scaron;");
209  		case 155:
210  			return TEXT("&rsaquo;");
211  		case 156:
212  			return TEXT("&oelig;");
213  		case 158:
214  			return TEXT("&zcaron;");
215  		case 159:
216  			return TEXT("&Yuml;");
217  		case 160:
218  			return TEXT("&nbsp;");
219  		case 161:
220  			return TEXT("&iexcl;");
221  		case 162:
222  			return TEXT("&cent;");
223  		case 163:
224  			return TEXT("&pound;");
225  		case 164:
226  			return TEXT("&curren;");
227  		case 165:
228  			return TEXT("&yen;");
229  		case 166:
230  			return TEXT("&brvbar;");
231  		case 167:
232  			return TEXT("&sect;");
233  		case 168:
234  			return TEXT("&uml;");
235  		case 169:
236  			return TEXT("&copy;");
237  		case 170:
238  			return TEXT("&ordf;");
239  		case 171:
240  			return TEXT("&laquo;");
241  		case 172:
242  			return TEXT("&not;");
243  		case 173:
244  			return TEXT("&shy;");
245  		case 174:
246  			return TEXT("&reg;");
247  		case 175:
248  			return TEXT("&macr;");
249  		case 176:
250  			return TEXT("&deg;");
251  		case 177:
252  			return TEXT("&plusmn;");
253  		case 178:
254  			return TEXT("&sup2;");
255  		case 179:
256  			return TEXT("&sup3;");
257  		case 180:
258  			return TEXT("&acute;");
259  		case 181:
260  			return TEXT("&micro;");
261  		case 182:
262  			return TEXT("&para;");
263  		case 183:
264  			return TEXT("&middot;");
265  		case 184:
266  			return TEXT("&cedil;");
267  		case 185:
268  			return TEXT("&sup1;");
269  		case 186:
270  			return TEXT("&ordm;");
271  		case 187:
272  			return TEXT("&raquo;");
273  		case 188:
274  			return TEXT("&frac14;");
275  		case 189:
276  			return TEXT("&frac12;");
277  		case 190:
278  			return TEXT("&frac34;");
279  		case 191:
280  			return TEXT("&iquest;");
281  		case 192:
282  			return TEXT("&Agrave;");
283  		case 193:
284  			return TEXT("&Aacute;");
285  		case 194:
286  			return TEXT("&Acirc;");
287  		case 195:
288  			return TEXT("&Atilde;");
289  		case 196:
290  			return TEXT("&Auml;");
291  		case 197:
292  			return TEXT("&Aring;");
293  		case 198:
294  			return TEXT("&AElig;");
295  		case 199:
296  			return TEXT("&Ccedil;");
297  		case 200:
298  			return TEXT("&Egrave;");
299  		case 201:
300  			return TEXT("&Eacute;");
301  		case 202:
302  			return TEXT("&Ecirc;");
303  		case 203:
304  			return TEXT("&Euml;");
305  		case 204:
306  			return TEXT("&Igrave;");
307  		case 205:
308  			return TEXT("&Iacute;");
309  		case 206:
310  			return TEXT("&Icirc;");
311  		case 207:
312  			return TEXT("&Iuml;");
313  		case 208:
314  			return TEXT("&ETH;");
315  		case 209:
316  			return TEXT("&Ntilde;");
317  		case 210:
318  			return TEXT("&Ograve;");
319  		case 211:
320  			return TEXT("&Oacute;");
321  		case 212:
322  			return TEXT("&Ocirc;");
323  		case 213:
324  			return TEXT("&Otilde;");
325  		case 214:
326  			return TEXT("&Ouml;");
327  		case 215:
328  			return TEXT("&times;");
329  		case 216:
330  			return TEXT("&Oslash;");
331  		case 217:
332  			return TEXT("&Ugrave;");
333  		case 218:
334  			return TEXT("&Uacute;");
335  		case 219:
336  			return TEXT("&Ucirc;");
337  		case 220:
338  			return TEXT("&Uuml;");
339  		case 221:
340  			return TEXT("&Yacute;");
341  		case 222:
342  			return TEXT("&THORN;");
343  		case 223:
344  			return TEXT("&szlig;");
345  		case 224:
346  			return TEXT("&agrave;");
347  		case 225:
348  			return TEXT("&aacute;");
349  		case 226:
350  			return TEXT("&acirc;");
351  		case 227:
352  			return TEXT("&atilde;");
353  		case 228:
354  			return TEXT("&auml;");
355  		case 229:
356  			return TEXT("&aring;");
357  		case 230:
358  			return TEXT("&aelig;");
359  		case 231:
360  			return TEXT("&ccedil;");
361  		case 232:
362  			return TEXT("&egrave;");
363  		case 233:
364  			return TEXT("&eacute;");
365  		case 234:
366  			return TEXT("&ecirc;");
367  		case 235:
368  			return TEXT("&euml;");
369  		case 236:
370  			return TEXT("&igrave;");
371  		case 237:
372  			return TEXT("&iacute;");
373  		case 238:
374  			return TEXT("&icirc;");
375  		case 239:
376  			return TEXT("&iuml;");
377  		case 240:
378  			return TEXT("&eth;");
379  		case 241:
380  			return TEXT("&ntilde;");
381  		case 242:
382  			return TEXT("&ograve;");
383  		case 243:
384  			return TEXT("&oacute;");
385  		case 244:
386  			return TEXT("&ocirc;");
387  		case 245:
388  			return TEXT("&otilde;");
389  		case 246:
390  			return TEXT("&ouml;");
391  		case 247:
392  			return TEXT("&divide;");
393  		case 248:
394  			return TEXT("&oslash;");
395  		case 249:
396  			return TEXT("&ugrave;");
397  		case 250:
398  			return TEXT("&uacute;");
399  		case 251:
400  			return TEXT("&ucirc;");
401  		case 252:
402  			return TEXT("&uuml;");
403  		case 253:
404  			return TEXT("&yacute;");
405  		case 254:
406  			return TEXT("&thorn;");
407  		case 255:
408  			return TEXT("&yuml;");
409  		default:
410  		{
411  			return TEXT("");
412  		}
413  	}
414  }
415  int AsciiListView::getHtmlNumber(unsigned char value)
416  {
417  	switch (value)
418  	{
419  		case 45:
420  			return 8722;
421  		case 128:
422  			return 8364;
423  		case 130:
424  			return 8218;
425  		case 131:
426  			return 402;
427  		case 132:
428  			return 8222;
429  		case 133:
430  			return 8230;
431  		case 134:
432  			return 8224;
433  		case 135:
434  			return 8225;
435  		case 136:
436  			return 710;
437  		case 137:
438  			return 8240;
439  		case 138:
440  			return 352;
441  		case 139:
442  			return 8249;
443  		case 140:
444  			return 338;
445  		case 142:
446  			return 381;
447  		case 145:
448  			return 8216;
449  		case 146:
450  			return 8217;
451  		case 147:
452  			return 8220;
453  		case 148:
454  			return 8221;
455  		case 149:
456  			return 8226;
457  		case 150:
458  			return 8211;
459  		case 151:
460  			return 8212;
461  		case 152:
462  			return 732;
463  		case 153:
464  			return 8482;
465  		case 154:
466  			return 353;
467  		case 155:
468  			return 8250;
469  		case 156:
470  			return 339;
471  		case 158:
472  			return 382;
473  		case 159:
474  			return 376;
475  		default:
476  		{
477  			return -1;
478  		}
479  	}
480  }
481  void AsciiListView::setValues(int codepage)
482  {
483  	_codepage = codepage;
484  	for (int i = 0 ; i < 256 ; ++i)
485  	{
486  		constexpr size_t bufSize = 8;
487  		constexpr size_t bufSizeHex = 9;
488  		wchar_t dec[bufSize]{};
489  		wchar_t hex[bufSize]{};
490  		wchar_t htmlNumber[bufSize]{};
491  		wchar_t htmlHexNumber[bufSizeHex]{};
492  		generic_string htmlName;
493  		swprintf(dec, bufSize, TEXT("%d"), i);
494  		swprintf(hex, bufSize, TEXT("%02X"), i);
495  		generic_string s = getAscii(static_cast<unsigned char>(i));
496  		if (codepage == 0 || codepage == 1252)
497  		{
498  			if ((i >= 32 && i <= 126 && i != 45) || (i >= 160 && i <= 255))
499  			{
500  				swprintf(htmlNumber, bufSize, TEXT("&#%d;"), i);
501  				swprintf(htmlHexNumber, bufSize, TEXT("&#x%x;"), i);
502  			}
503  			else
504  			{
505  				int n = getHtmlNumber(static_cast<unsigned char>(i));
506  				if (n > -1)
507  				{
508  					swprintf(htmlNumber, bufSize, TEXT("&#%d;"), n);
509  					swprintf(htmlHexNumber, bufSizeHex, TEXT("&#x%x;"), n);
510  				}
511  				else
512  				{
513  					swprintf(htmlNumber, bufSize, TEXT(""));
514  					swprintf(htmlHexNumber, bufSizeHex, TEXT(""));
515  				}
516  			}
517  			htmlName = getHtmlName(static_cast<unsigned char>(i));
518  		}
519  		else
520  		{
521  			swprintf(htmlNumber, bufSize, TEXT(""));
522  			swprintf(htmlHexNumber, bufSizeHex, TEXT(""));
523  			htmlName = TEXT("");
524  		}
525  		std::vector<generic_string> values2Add;
526  		values2Add.push_back(dec);
527  		values2Add.push_back(hex);
528  		values2Add.push_back(s);
529  		values2Add.push_back(htmlName);
530  		values2Add.push_back(htmlNumber);
531  		values2Add.push_back(htmlHexNumber);
532  		addLine(values2Add);
533  	}
534  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ansiCharPanel.cpp</h3>
            <pre><code>1  #include "ansiCharPanel.h"
2  #include "ScintillaEditView.h"
3  #include "localization.h"
4  void AnsiCharPanel::switchEncoding()
5  {
6  	int codepage = (*_ppEditView)->getCurrentBuffer()->getEncoding();
7  	_listView.resetValues(codepage);
8  }
9  intptr_t CALLBACK AnsiCharPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
10  {
11  	switch (message)
12  	{
13  		case WM_INITDIALOG :
14  		{
15  			NppParameters& nppParam = NppParameters::getInstance();
16  			NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
17  			generic_string valStr = pNativeSpeaker->getAttrNameStr(TEXT("Value"), "AsciiInsertion", "ColumnVal");
18  			generic_string hexStr = pNativeSpeaker->getAttrNameStr(TEXT("Hex"), "AsciiInsertion", "ColumnHex");
19  			generic_string charStr = pNativeSpeaker->getAttrNameStr(TEXT("Character"), "AsciiInsertion", "ColumnChar");
20  			generic_string htmlNameStr = pNativeSpeaker->getAttrNameStr(L"HTML Name", "AsciiInsertion", "ColumnHtmlName");
21  			generic_string htmlNumberStr = pNativeSpeaker->getAttrNameStr(L"HTML Decimal", "AsciiInsertion", "ColumnHtmlNumber");
22  			generic_string htmlHexNbStr = pNativeSpeaker->getAttrNameStr(L"HTML Hexadecimal", "AsciiInsertion", "ColumnHtmlHexNb");
23  			_listView.addColumn(columnInfo(valStr, nppParam._dpiManager.scaleX(45)));
24  			_listView.addColumn(columnInfo(hexStr, nppParam._dpiManager.scaleX(45)));
25  			_listView.addColumn(columnInfo(charStr, nppParam._dpiManager.scaleX(70)));
26  			_listView.addColumn(columnInfo(htmlNameStr, nppParam._dpiManager.scaleX(90)));
27  			_listView.addColumn(columnInfo(htmlNumberStr, nppParam._dpiManager.scaleX(100)));
28  			_listView.addColumn(columnInfo(htmlHexNbStr, nppParam._dpiManager.scaleX(120)));
29  			_listView.init(_hInst, _hSelf);
30  			int codepage = (*_ppEditView)->getCurrentBuffer()->getEncoding();
31  			_listView.setValues(codepage==-1?0:codepage);
32  			_listView.display();
33  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
34  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
35  			return TRUE;
36  		}
37  		case NPPM_INTERNAL_REFRESHDARKMODE:
38  		{
39  			NppDarkMode::autoThemeChildControls(_hSelf);
40  			return TRUE;
41  		}
42  		case WM_NOTIFY:
43  		{
44  			switch (reinterpret_cast<LPNMHDR>(lParam)->code)
45  			{
46  				case DMN_CLOSE:
47  				{
48  					::SendMessage(_hParent, WM_COMMAND, IDM_EDIT_CHAR_PANEL, 0);
49  					return TRUE;
50  				}
51  				case NM_DBLCLK:
52  				{
53  					LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE) lParam;
54  					LVHITTESTINFO pInfo{};
55  					pInfo.pt = lpnmitem->ptAction;
56  					ListView_SubItemHitTest(_listView.getHSelf(), &pInfo);
57  					int i = pInfo.iItem;
58  					int j = pInfo.iSubItem;
59  					wchar_t buffer[10]{};
60  					LVITEM item{};
61  					item.mask = LVIF_TEXT | LVIF_PARAM;
62  					item.iItem = i;
63  					item.iSubItem = j;
64  					item.cchTextMax = 10;
65  					item.pszText = buffer;
66  					ListView_GetItem(_listView.getHSelf(), &item);
67  					if (i == -1)
68  						return TRUE;
69  					if (j != 2)
70  						insertString(item.pszText);
71  					else
72  						insertChar(static_cast<unsigned char>(i));
73  					return TRUE;
74  				}
75  				case LVN_KEYDOWN:
76  				{
77  					switch (((LPNMLVKEYDOWN)lParam)->wVKey)
78  					{
79  						case VK_RETURN:
80  						{
81  							int i = _listView.getSelectedIndex();
82  							if (i == -1)
83  								return TRUE;
84  							insertChar(static_cast<unsigned char>(i));
85  							return TRUE;
86  						}
87  						default:
88  							break;
89  					}
90  				}
91  				break;
92  				default:
93  					break;
94  			}
95  		}
96  		return TRUE;
97  		case WM_SIZE:
98  		{
99  			int width = LOWORD(lParam);
100  			int height = HIWORD(lParam);
101  			::MoveWindow(_listView.getHSelf(), 0, 0, width, height, TRUE);
102  			break;
103  		}
104  		default :
105  			return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
106  	}
107  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
108  }
109  void AnsiCharPanel::insertChar(unsigned char char2insert) const
110  {
111  	char charStr[2]{};
112  	charStr[0] = char2insert;
113  	charStr[1] = '\0';
<span onclick='openModal()' class='match'>114  	wchar_t wCharStr[10]{};
115  	char multiByteStr[10]{};
116  	int codepage = (*_ppEditView)->getCurrentBuffer()->getEncoding();
</span>117  	if (codepage == -1)
118  	{
119  		bool isUnicode = ((*_ppEditView)->execute(SCI_GETCODEPAGE) == SC_CP_UTF8);
120  		if (isUnicode)
121  		{
122  			MultiByteToWideChar(0, 0, charStr, -1, wCharStr, _countof(wCharStr));
123  			WideCharToMultiByte(CP_UTF8, 0, wCharStr, -1, multiByteStr, sizeof(multiByteStr), NULL, NULL);
124  		}
125  		else 
126  		{
127  			multiByteStr[0] = charStr[0];
128  			multiByteStr[1] = charStr[1];
129  		}
130  	}
131  	else
132  	{
133  		MultiByteToWideChar(codepage, 0, charStr, -1, wCharStr, _countof(wCharStr));
134  		WideCharToMultiByte(CP_UTF8, 0, wCharStr, -1, multiByteStr, sizeof(multiByteStr), NULL, NULL);
135  	}
136  	(*_ppEditView)->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
137  	size_t len = (char2insert < 128) ? 1 : strlen(multiByteStr);
138  	(*_ppEditView)->execute(SCI_ADDTEXT, len, reinterpret_cast<LPARAM>(multiByteStr));
139  	(*_ppEditView)->getFocus();
140  }
141  void AnsiCharPanel::insertString(LPWSTR string2insert) const
142  {
143  	char multiByteStr[10]{};
144  	int codepage = (*_ppEditView)->getCurrentBuffer()->getEncoding();
145  	if (codepage == -1)
146  	{
147  		bool isUnicode = ((*_ppEditView)->execute(SCI_GETCODEPAGE) == SC_CP_UTF8);
148  		if (isUnicode)
149  		{
150  			WideCharToMultiByte(CP_UTF8, 0, string2insert, -1, multiByteStr, sizeof(multiByteStr), NULL, NULL);
151  		}
152  		else 
153  		{
154  			wcstombs(multiByteStr, string2insert, 10);
155  		}
156  	}
157  	else
158  	{
159  		WideCharToMultiByte(CP_UTF8, 0, string2insert, -1, multiByteStr, sizeof(multiByteStr), NULL, NULL);
160  	}
161  	(*_ppEditView)->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
162  	size_t len = strlen(multiByteStr);
163  	(*_ppEditView)->execute(SCI_ADDTEXT, len, reinterpret_cast<LPARAM>(multiByteStr));
164  	(*_ppEditView)->getFocus();
165  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-asciiListView.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ansiCharPanel.cpp</div>
                </div>
                <div class="column column_space"><pre><code>86  			wchar_t charStr[10]{};
87  			char ascii[2]{};
88  			ascii[0] = value;
</pre></code></div>
                <div class="column column_space"><pre><code>114  	wchar_t wCharStr[10]{};
115  	char multiByteStr[10]{};
116  	int codepage = (*_ppEditView)->getCurrentBuffer()->getEncoding();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    