
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.666666666666664%, Tokens: 11</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.h</h3>
            <pre><code>1  #ifndef crawler_h
2  #define crawler_h
3  #include "net.h"
4  #include "mine.h"
5  ClassHdTP(TCrawler, PCrawler);
6  ClassTP(TCrawlerDef, PCrawlerDef)
7  private:
8    int MxUrls;
9    int MnConns;
10    int MxConns;
11    int MxConnsPerSrv;
12    int AfterFetchDelaySecs;
13    int MxLev;
14    int MxDep;
15    int MxContLen;
16    int MnQLen;
17    int QResetMod;
18    int MxQSegLen;
19    int MxRetries;
20    int RevisitSecs;
21    bool RedirDmAllowedP;
22    TStrV StartUrlStrV;
23    TStrV RqDmNmV;
24    TStrV BadDmNmV;
25    PGeoIpBs GeoIpBs;
26    TStrV RqCountryNmV;
27    TStrV RqContTypeNmV;
28    TStrV BadFExtV;
29    TStrH BadFExtH;
30    TStr UserAgentStr;
31    UndefCopyAssign(TCrawlerDef);
32  public:
33    TCrawlerDef():
34      MxUrls(100000), MnConns(1), MxConns(10), MxConnsPerSrv(1),
35      AfterFetchDelaySecs(1), MxLev(3), MxDep(3), MxContLen(100000),
36      MnQLen(1000), QResetMod(1000), MxQSegLen(1000000),
37      MxRetries(2), RevisitSecs(-1), RedirDmAllowedP(false),
38      StartUrlStrV(), RqDmNmV(), BadDmNmV(), GeoIpBs(), RqCountryNmV(),
39      RqContTypeNmV(), BadFExtV(), BadFExtH(), UserAgentStr(){}
40    static PCrawlerDef New(){
41      return PCrawlerDef(new TCrawlerDef());}
42    void PutMxUrls(const int& _MxUrls){MxUrls=_MxUrls;}
43    int GetMxUrls() const {return MxUrls;}
44    void PutMnConns(const int& _MnConns){MnConns=_MnConns;}
45    int GetMnConns() const {return MnConns;}
46    void PutMxConns(const int& _MxConns){MxConns=_MxConns;}
47    int GetMxConns() const {return MxConns;}
48    void PutMxConnsPerSrv(const int& _MxConnsPerSrv){
49      MxConnsPerSrv=_MxConnsPerSrv;}
50    int GetMxConnsPerSrv() const {return MxConnsPerSrv;}
51    void PutAfterFetchDelaySecs(const int& _AfterFetchDelaySecs){
52      AfterFetchDelaySecs=_AfterFetchDelaySecs;}
53    int GetAfterFetchDelaySecs() const {return AfterFetchDelaySecs;}
54    void PutMxLev(const int& _MxLev){MxLev=_MxLev;}
55    int GetMxLev() const {return MxLev;}
56    void PutMxDep(const int& _MxDep){MxDep=_MxDep;}
57    int GetMxDep() const {return MxDep;}
58    void PutMxContLen(const int& _MxContLen){MxContLen=_MxContLen;}
59    int GetMxContLen() const {return MxContLen;}
60    void PutMnQLen(const int& _MnQLen){MnQLen=_MnQLen;}
61    int GetMnQLen() const {return MnQLen;}
62    void PutQResetMod(const int& _QResetMod){QResetMod=_QResetMod;}
63    int GetQResetMod() const {return QResetMod;}
64    void PutMxQSegLen(const int& _MxQSegLen){MxQSegLen=_MxQSegLen;}
65    int GetMxQSegLen() const {return MxQSegLen;}
66    void PutMxRetries(const int& _MxRetries){MxRetries=_MxRetries;}
67    int GetMxRetries() const {return MxRetries;}
68    void PutRevisitSecs(const int& _RevisitSecs){RevisitSecs=_RevisitSecs;}
69    int GetRevisitSecs() const {return RevisitSecs;}
70    void PutRedirDmAllowed(const bool& _RedirDmAllowedP){RedirDmAllowedP=_RedirDmAllowedP;}
71    bool IsRedirDmAllowed() const {return RedirDmAllowedP;}
72    void AddStartUrlStr(const TStr& UrlStr){
73      PUrl Url=TUrl::New(UrlStr);
74      EAssertRA(Url->IsOk(usHttp), "Url must have HTTP schema", UrlStr);
75      StartUrlStrV.Add(UrlStr);}
76    void AddStartUrlStrV(const TStrV& UrlStrV){
77      for (int UrlStrN=0; UrlStrN<UrlStrV.Len(); UrlStrN++){AddStartUrlStr(UrlStrV[UrlStrN]);}}
78    int GetStartUrls() const {
79      return StartUrlStrV.Len();}
80    TStr GetStartUrl(const int& StartUrlN) const {
81      return StartUrlStrV[StartUrlN];}
82    void AddRqDmNm(const TStr& DmNm){RqDmNmV.AddUnique(DmNm);}
83    void AddRqDmNmV(const TStrV& DmNmV){
84      for (int DmNmN=0; DmNmN<DmNmV.Len(); DmNmN++){AddRqDmNm(DmNmV[DmNmN]);}}
85    void AddBadDmNm(const TStr& DmNm){BadDmNmV.AddUnique(DmNm);}
86    void AddBadDmNmV(const TStrV& DmNmV){
87      for (int DmNmN=0; DmNmN<DmNmV.Len(); DmNmN++){AddBadDmNm(DmNmV[DmNmN]);}}
88    bool IsHostNmOk(const TStr& DmNm);
89    void LoadGeoIpBs(const TStr& GeoIpBsFNm){GeoIpBs=TGeoIpBs::LoadBin(GeoIpBsFNm);}
90    PGeoIpBs GetGeoIpBs() const {return GeoIpBs;}
91    bool IsGeoIpBs() const {return GetGeoIpBs().Empty();}
92    void AddRqCountryNm(const TStr& CountryNm){RqCountryNmV.Add(CountryNm);}
93    void AddRqCountryNmV(const TStrV& CountryNmV){
94      for (int CountryNmN=0; CountryNmN<CountryNmV.Len(); CountryNmN++){
95        AddRqCountryNm(CountryNmV[CountryNmN]);}}
96    void AddRqContTypeNm(const TStr& ContTypeNm){RqContTypeNmV.Add(ContTypeNm);}
97    void AddRqContTypeNmV(const TStrV& ContTypeNmV){
98      for (int ContTypeNmN=0; ContTypeNmN<ContTypeNmV.Len(); ContTypeNmN++){
99        AddRqContTypeNm(ContTypeNmV[ContTypeNmN]);}}
100    bool IsContTypeNmOk(const TStr& ContTypeNm);
101    void AddBadFExt(const TStr& FExt){
102      BadFExtV.Add(FExt.GetUc()); BadFExtH.AddKey(FExt.GetUc());}
103    void AddBadFExtV(const TStrV& FExtV){
104      for (int FExtN=0; FExtN<FExtV.Len(); FExtN++){AddBadFExt(FExtV[FExtN]);}}
105    bool IsFExtOk(const PUrl& Url) const;
106    void PutUserAgentStr(const TStr& _UserAgentStr){UserAgentStr=_UserAgentStr;}
107    TStr GetUserAgentStr() const {return UserAgentStr;}
108    void OptHtmlCrawling();
109    void AddSiteUrlStr(const TStr& SiteUrlStr);
110    void AddSiteUrlStrV(const TStrV& SiteUrlStrV);
111    void LoadUrlStrV(const TStr& SiteUrlStrVFNm);
112    TStr GetStr();
113  };
114  class TCrawlerUrlDesc{
115  public:
116    TBlobPt DocBlobPt;
117    TMd5Sig DocMemMd5Sig;
118    TSecTm DocSecTm;
119    TUCh DocLev;
120    TUCh DocDep;
121  public:
122    TCrawlerUrlDesc():
123      DocBlobPt(), DocMemMd5Sig(), DocSecTm(), DocLev(), DocDep(){}
124    TCrawlerUrlDesc(
125     const TBlobPt& _DocBlobPt, const TMd5Sig& _DocMemMd5Sig,
126     const TSecTm& _DocSecTm, const TUCh& _DocLev, const TUCh& _DocDep):
127      DocBlobPt(_DocBlobPt), DocMemMd5Sig(_DocMemMd5Sig),
128      DocSecTm(_DocSecTm), DocLev(_DocLev), DocDep(_DocDep){}
129    TCrawlerUrlDesc(TSIn& SIn):
130      DocBlobPt(SIn), DocMemMd5Sig(SIn), DocSecTm(SIn), DocLev(SIn), DocDep(SIn){}
131    void Save(TSOut& SOut) const {
132      DocBlobPt.Save(SOut); DocMemMd5Sig.Save(SOut);
133      DocSecTm.Save(SOut); DocLev.Save(SOut); DocDep.Save(SOut);}
134    TCrawlerUrlDesc& operator=(const TCrawlerUrlDesc& UrlDesc){
135      DocBlobPt=UrlDesc.DocBlobPt; DocMemMd5Sig=UrlDesc.DocMemMd5Sig;
136      DocSecTm=UrlDesc.DocSecTm; DocLev=UrlDesc.DocLev; DocDep=UrlDesc.DocDep;
137      return *this;}
138  };
139  ClassTP(TCrawlerUrlDescBs, PCrawlerUrlDescBs)
140  private:
141    TCrawler* Crawler;
142    typedef TPair<TInt, TBlobPt> TIntBlobPtPr;
143    THash<TMd5Sig, TCrawlerUrlDesc> UrlMd5SigToDescH;
144    UndefDefaultCopyAssign(TCrawlerUrlDescBs);
145  public:
146    TCrawlerUrlDescBs(TCrawler* _Crawler);
147    static PCrawlerUrlDescBs New(TCrawler* Crawler){
148      return new TCrawlerUrlDescBs(Crawler);}
149    int GetUrls() const {return UrlMd5SigToDescH.Len();}
150    bool IsUrl(const TMd5Sig& UrlMd5Sig) const {
151      return UrlMd5SigToDescH.IsKey(UrlMd5Sig);}
152    void AddUrlDesc(const TMd5Sig& UrlMd5Sig, const TCrawlerUrlDesc& UrlDesc){
153      UrlMd5SigToDescH.AddDat(UrlMd5Sig, UrlDesc);}
154    TCrawlerUrlDesc& GetUrlDesc(const TMd5Sig& UrlMd5Sig){
155      return UrlMd5SigToDescH.GetDat(UrlMd5Sig);}
156    TStr GetFNm() const;
157    void Load();
158    void Save();
159  };
160  ClassTPV(TCrawlerHost, PCrawlerHost, TCrawlerHostV)
161  private:
162    TStr HostNm, RevHostNm;
163    TStr IpNum;
164    int ActiveConns;
165    int FetchedUrls;
166    int FetchErrors;
167    int QueueUrls;
168    uint64 TransferBytes;
169    int TransferMSecs;
170    TSecTm LastFetchTm;
171    UndefDefaultCopyAssign(TCrawlerHost);
172  public:
173    TCrawlerHost(const TStr& _HostNm):
174      HostNm(_HostNm), RevHostNm(_HostNm.Reverse()), IpNum(),
175      ActiveConns(0), FetchedUrls(0), FetchErrors(0),
176      QueueUrls(0), TransferBytes(0), TransferMSecs(0), LastFetchTm(0){}
177    static PCrawlerHost New(const TStr& HostNm){
178      return new TCrawlerHost(HostNm);}
179    TStr GetHostNm() const {return HostNm;}
180    TStr GetRevHostNm() const {return RevHostNm;}
181    bool IsIpNum() const {return !IpNum.Empty();}
182    TStr& GetIpNum(){return IpNum;}
183    int& GetActiveConns(){return ActiveConns;}
184    int& GetFetchedUrls(){return FetchedUrls;}
185    int& GetFetchErrors(){return FetchErrors;}
186    int& GetQueueUrls(){return QueueUrls;}
187    uint64& GetTransferBytes(){return TransferBytes;}
188    int& GetTransferMSecs(){return TransferMSecs;}
189    double GetAvgHttpRespLen(){
190      return FetchedUrls==0 ? 0 : TransferBytes/double(FetchedUrls);}
191    double GetAvgTransferBps(){
192      return TransferMSecs==0 ? 0 : (TransferBytes*8.0)/(TransferMSecs/1000.0);}
193    TSecTm& GetLastFetchTm(){return LastFetchTm;}
194  };
195  ClassTP(TCrawlerHostBs, PCrawlerHostBs)
196  private:
197    TCrawler* Crawler;
198    THash<TStr, PCrawlerHost> NmToHostH;
199    UndefDefaultCopyAssign(TCrawlerHostBs);
200  public:
201    TCrawlerHostBs(TCrawler* _Crawler);
202    static PCrawlerHostBs New(TCrawler* Crawler){
203      return new TCrawlerHostBs(Crawler);}
204    int GetHosts() const {return NmToHostH.Len();}
205    bool IsHost(const TStr& HostNm) const {
206      return NmToHostH.IsKey(HostNm);}
207    PCrawlerHost AddGetHost(const TStr& HostNm);
208    PCrawlerHost GetHost(const TStr& HostNm){
209      return NmToHostH.GetDat(HostNm);}
210    PCrawlerHost GetHost(const int& HostN){
211      return NmToHostH[HostN];}
212    void GetSortedHostV(TCrawlerHostV& HostV, const TStr& SortOrderNm);
213    void GetSummaryInfo(
214     int& ActiveConns, int& FetchedUrls, int& FetchErrors, int& QueueUrls,
215     double& TransferBytes, double& TransferMSecs, 
216     double& AvgHttpRespLen, double& AvgTransferBps);
217  };
218  ClassTP(TCrawlerQueue, PCrawlerQueue)
219  private:
220    TCrawler* Crawler;
221    THash<TMd5Sig, TStrStrIntIntQu> UrlMd5SigToUrlStrHostNmLevDepQuH;
222    TVec<TIntQ> LevUrlIdQV;
223    TStr ToDelUrlQBBsFNm;
224    PBlobBs UrlQBBs;
225    UndefDefaultCopyAssign(TCrawlerQueue);
226  public:
227    TCrawlerQueue(TCrawler* _Crawler);
228    static PCrawlerQueue New(TCrawler* Crawler){
229      return new TCrawlerQueue(Crawler);}
230    int GetQLevs() const {return LevUrlIdQV.Len();}
231    int GetQLevUrls(const int& Lev) const {return LevUrlIdQV[Lev].Len();}
232    int GetQUrls() const {return UrlMd5SigToUrlStrHostNmLevDepQuH.Len();}
<span onclick='openModal()' class='match'>233    int GetUnconnQUrls() const {
234      int QUrls=0; int Levs=GetQLevs();
235      for (int Lev=0; Lev<Levs; Lev++){QUrls+=GetQLevUrls(Lev);}
</span>236      return QUrls;}
237    bool Empty() const {return GetQUrls()==0;}
238    void GetQUrlsHostPrV(TIntStrPrV& QUrlsHostPrV);
239    bool IsQUrl(const TMd5Sig& UrlMd5Sig) const {
240      return UrlMd5SigToUrlStrHostNmLevDepQuH.IsKey(UrlMd5Sig);}
241    int AddQUrl(const TMd5Sig& UrlMd5Sig, const TStr& UrlStr, const TStr& HostNm, const int& Lev, const int& Dep){
242      int QUrlId=UrlMd5SigToUrlStrHostNmLevDepQuH.AddKey(UrlMd5Sig);
243      UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId]=TStrStrIntIntQu(UrlStr, HostNm, Lev, Dep);
244      return QUrlId;}
245    void DelQUrl(const int& QUrlId){
246      UrlMd5SigToUrlStrHostNmLevDepQuH.DelKeyId(QUrlId);}
247    TStr GetQUrlStr(const TMd5Sig& UrlMd5Sig) const {
248      return UrlMd5SigToUrlStrHostNmLevDepQuH.GetDat(UrlMd5Sig).Val1;}
249    TStr GetQUrlStr(const int& QUrlId) const {
250      return UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val1;}
251    TStr GetQHostNm(const int& QUrlId) const {
252      return UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val2;}
253    int GetQUrlLev(const TMd5Sig& UrlMd5Sig) const {
254      return UrlMd5SigToUrlStrHostNmLevDepQuH.GetDat(UrlMd5Sig).Val3;}
255    int GetQUrlLev(const int& QUrlId) const {
256      return UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val3;}
257    int GetQUrlDep(const TMd5Sig& UrlMd5Sig) const {
258      return UrlMd5SigToUrlStrHostNmLevDepQuH.GetDat(UrlMd5Sig).Val4;}
259    int GetQUrlDep(const int& QUrlId) const {
260      return UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val4;}
261    void GetQUrl(const int& QUrlId, TMd5Sig& UrlMd5Sig, int& Lev, int& Dep){
262      UrlMd5Sig=UrlMd5SigToUrlStrHostNmLevDepQuH.GetKey(QUrlId);
263      Lev=UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val3;
264      Dep=UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val4;}
265    void PushQUrl(const TStr& UrlStr, const int& Lev, const int& Dep);
266    void PushQUrl(const PUrl& Url, const int& Lev, const int& Dep);
267    bool PopQUrl(int& QUrlId, TStr& UrlStr);
268    void ShuffleUrlQ();
269    void ResetQUrlBs();
270    TStr GetUrlQBBsFNm() const;
271    TStr GetUrlQBBsWcFNm() const;
272    void PushQUrlBs();
273    void PushQUrlToUrlQBs(const PUrl& Url, const int& Lev, const int& Dep);
274    void PushQUrlToUrlQBs(const TStr& UrlStr, const int& Lev, const int& Dep);
275    void PopSaveQUrlBs();
276  };
277  ClassTPE(TCrawlerFetcher, PCrawlerFetcher, TWebPgFetch)
278  private:
279    TCrawler* Crawler;
280    typedef TTriple<TInt, PUrl, TUInt64> TQUrlIdUrlTmTr;
281    THash<TInt, TQUrlIdUrlTmTr> ConnIdToQUrlIdUrlTmTrH;
282    int CurMxConns;
283    TTm LastClrZombiesTm;
284    int Zombies;
285    TIntIntH ZombieConnIdToFetchSizeH;
286    UndefDefaultCopyAssign(TCrawlerFetcher);
287    void DelCrawlerFetcherConn(const int& ConnId);
288  public:
289    TCrawlerFetcher(TCrawler* _Crawler);
290    static PCrawlerFetcher New(TCrawler* Crawler){
291      return new TCrawlerFetcher(Crawler);}
292    void AddConn(const int& ConnId, const int& QUrlId, const PUrl& Url){
293      ConnIdToQUrlIdUrlTmTrH.AddDat(ConnId, TQUrlIdUrlTmTr(QUrlId, Url, TTm::GetCurUniMSecs()));}
294    void GetDelConn(const int& ConnId, int& QUrlId, PUrl& Url, int& MSecs){
295      QUrlId=ConnIdToQUrlIdUrlTmTrH.GetDat(ConnId).Val1;
296      Url=ConnIdToQUrlIdUrlTmTrH.GetDat(ConnId).Val2;
297      MSecs=int(TTm::GetCurUniMSecs()-ConnIdToQUrlIdUrlTmTrH.GetDat(ConnId).Val3);
298      ConnIdToQUrlIdUrlTmTrH.DelKey(ConnId);}
299    int GetConns() const {return ConnIdToQUrlIdUrlTmTrH.Len();}
300    void GetConnV(TIntStrIntIntQuV& ConnIdUrlStrMSecsSizeQuV);
301    void PutCurMxConns(const int& _CurMxConns){CurMxConns=_CurMxConns;}
302    int GetCurMxConns() const {return CurMxConns;}
303    void ClrZombies();
304    int GetZombies() const {return Zombies;}
305    void Fetch();
306    void OnFetch(const int& &bsol;*ConnId*/, const PWebPg& WebPg);
307    void OnError(const int& &bsol;*ConnId*/, const TStr& MsgStr);
308  };
309  ClassTP(TCrawlerDocBs, PCrawlerDocBs)
310  private:
311    TCrawler* Crawler;
312    TStr DocBsNm;
313    TStr DocBsNrFPath;
314    TStr DocBsFAccessNm;
315    int DocBsMxSegLen;
316    PBlobBs DocBBs;
317    UndefDefaultCopyAssign(TCrawlerDocBs);
318  public:
319    TCrawlerDocBs(TCrawler* _Crawler):
320      Crawler(_Crawler),
321      DocBsNm(), DocBsNrFPath(), DocBsFAccessNm(), DocBBs(){}
322    static PCrawlerDocBs New(TCrawler* Crawler){
323      return new TCrawlerDocBs(Crawler);}
324    virtual ~TCrawlerDocBs(){}
325    void PutDocBsNm(const TStr& _DocBsNm){DocBsNm=_DocBsNm;}
326    TStr GetDocBsNm() const {return DocBsNm;}
327    void PutDocBsNrFPath(const TStr& _DocBsNrFPath){DocBsNrFPath=_DocBsNrFPath;}
328    TStr GetDocBsNrFPath() const {return DocBsNrFPath;}
329    void PutDocBsFAccessNm(const TStr& _DocBsFAccessNm){DocBsFAccessNm=_DocBsFAccessNm;}
330    TStr GetDocBsFAccessNm() const {return DocBsFAccessNm;}
331    void PutDocBsMxSegLen(const int& _DocBsMxSegLen){DocBsMxSegLen=_DocBsMxSegLen;}
332    int GetDocBsMxSegLen() const {return DocBsMxSegLen;}
333    PBlobBs GetDocBBs() const {return DocBBs;}
334    TFAccess Open();
335    void Close();
336    TBlobPt AddDoc(const TStr& DocUrlStr, const TMem& DocMem);
337    TBlobPt FFirstDocBlobPt(){return DocBBs->FFirstBlobPt();}
338    bool FNextDocBlobPt(TBlobPt& TrvDocBlobPt,
339     TBlobPt& DocBlobPt, TStr& DateTimeStr, TStr& DocUrlStr, TMem& DocMem);
340  };
341  class TCrawlerTimer: public TTTimer{
342  private:
343    TCrawler* Crawler;
344    uint64 LastEventMSecs;
345    uint64 Last100SecsEventMSecs;
346    uint64 Last1000SecsEventMSecs;
347    UndefDefaultCopyAssign(TCrawlerTimer);
348  public:
349    TCrawlerTimer(TCrawler* _Crawler, const int& TimerTout):
350      TTTimer(TimerTout), Crawler(_Crawler), LastEventMSecs(0),
351      Last100SecsEventMSecs(0), Last1000SecsEventMSecs(0){}
352    static PTimer New(TCrawler* Crawler, const int& TimerTout){
353      return new TCrawlerTimer(Crawler, TimerTout);}
354    void OnTimeOut();
355  };
356  ClassTPE(TCrawlerWebSrv, PCrawlerWebSrv, TWebSrv)
357  private:
358    TCrawler* Crawler;
359    UndefCopyAssign(TCrawlerWebSrv);
360  public:
361    TCrawlerWebSrv(TCrawler* _Crawler, const int& PortN):
362      TWebSrv(PortN, false), Crawler(_Crawler){}
363    static PCrawlerWebSrv New(TCrawler* Crawler, const int& PortN=7777){
364      return new TCrawlerWebSrv(Crawler, PortN);}
365    virtual ~TCrawlerWebSrv(){}
366    TStr GetUrlStr(const int& RefreshSecs, const TStr& SortOrderNm);
367    TStr GetAnchorStr(const TStr& DescStr, 
368     const int& RefreshSecs, const TStr& SortOrderNm);
369    void OnHttpRq(const int& SockId, const PHttpRq& HttpRq);
370  };
371  ClassTP(TCrawlerStat, PCrawlerStat)
372  private:
373    TCrawler* Crawler;
374    uint64 Last100SecsEventMSecs;
375    uint64 Last1000SecsEventMSecs;
376    uint64 Last100SecsFetchedUrls;
377    uint64 Last1000SecsFetchedUrls;
378    double Last100SecsCrawlingSpeed;
379    double Last1000SecsCrawlingSpeed;
380    UndefDefaultCopyAssign(TCrawlerStat);
381  public:
382    TCrawlerStat(TCrawler* _Crawler):
383      Crawler(_Crawler),
384      Last100SecsEventMSecs(0), Last1000SecsEventMSecs(0),
385      Last100SecsFetchedUrls(0), Last1000SecsFetchedUrls(0),
386      Last100SecsCrawlingSpeed(0), Last1000SecsCrawlingSpeed(0){}
387    static PCrawlerStat New(TCrawler* Crawler){
388      return new TCrawlerStat(Crawler);}
389    ~TCrawlerStat(){}
390    void On100Secs();
391    void On1000Secs();
392    double GetLast100SecsCrawlingSpeed(){
393      return Last100SecsCrawlingSpeed;}
394    double GetLast1000SecsCrawlingSpeed(){
395      return Last1000SecsCrawlingSpeed;}
396  };
397  ClassTP(TCrawler, PCrawler)
398  private:
399    PCrawlerDef Def;
400    PCrawlerUrlDescBs UrlDescBs;
401    PCrawlerHostBs HostBs;
402    PCrawlerQueue Queue;
403    PCrawlerFetcher Fetcher;
404    PCrawlerDocBs DocBs;
405    PCrawlerStat Stat;
406    PTimer Timer;
407    PCrawlerWebSrv WebSrv;
408    TTm StartTm;
409    UndefCopyAssign(TCrawler);
410  public:
411    TCrawler();
412    static PCrawler New(){
413      return PCrawler(new TCrawler());}
414    ~TCrawler(){}
415    TCrawler(TSIn&){Fail;}
416    static PCrawler Load(TSIn& SIn){Fail; return NULL;}
417    void Save(TSOut&){Fail;}
418    PCrawlerDef GetDef() const {return Def;}
419    PCrawlerUrlDescBs GetUrlDescBs() const {return UrlDescBs;}
420    PCrawlerHostBs GetHostBs() const {return HostBs;}
421    PCrawlerQueue GetQueue() const {return Queue;}
422    PCrawlerFetcher GetFetcher() const {return Fetcher;}
423    PCrawlerDocBs GetDocBs() const {return DocBs;}
424    PCrawlerStat GetStat() const {return Stat;}
425    PTimer GetTimer() const {return Timer;}
426    PCrawlerWebSrv GetWebSrv() const {return WebSrv;}
427    TTm GetStartTm() const {return StartTm;}
428    void DefCrawlBs(const TStr& CrawlBsNm, const TStr& CrawlBsFPath,
429     const TStr& CrawlBsFAccessNm, const int& CrawlBsMxSegLen);
430    void StartCrawling();
431    void StopCrawling();
432    static TMd5Sig GetUrlMd5Sig(const TStr& UrlStr);
433  };
434  typedef PBlobBs PCrawlBs;
435  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-numbers.cpp</h3>
            <pre><code>1  #include <nano/crypto/blake2/blake2.h>
2  #include <nano/crypto_lib/random_pool.hpp>
3  #include <nano/crypto_lib/secure_memory.hpp>
4  #include <nano/lib/numbers.hpp>
5  #include <nano/lib/utility.hpp>
6  #include <nano/secure/common.hpp>
7  #include <crypto/ed25519-donna/ed25519.h>
8  #include <cryptopp/aes.h>
9  #include <cryptopp/modes.h>
10  namespace
11  {
12  char const * account_lookup ("13456789abcdefghijkmnopqrstuwxyz");
13  char const * account_reverse ("~0~1234567~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~89:;<=>?@AB~CDEFGHIJK~LMNO~~~~~");
14  char account_encode (uint8_t value)
15  {
16  	debug_assert (value < 32);
17  	auto result (account_lookup[value]);
18  	return result;
19  }
20  uint8_t account_decode (char value)
21  {
22  	debug_assert (value >= '0');
23  	debug_assert (value <= '~');
24  	auto result (account_reverse[value - 0x30]);
25  	if (result != '~')
26  	{
27  		result -= 0x30;
28  	}
29  	return result;
30  }
31  }
32  void nano::public_key::encode_account (std::string & destination_a) const
33  {
34  	debug_assert (destination_a.empty ());
35  	destination_a.reserve (65);
36  	uint64_t check (0);
37  	blake2b_state hash;
38  	blake2b_init (&hash, 5);
39  	blake2b_update (&hash, bytes.data (), bytes.size ());
40  	blake2b_final (&hash, reinterpret_cast<uint8_t *> (&check), 5);
41  	nano::uint512_t number_l (number ());
42  	number_l <<= 40;
43  	number_l |= nano::uint512_t (check);
44  	for (auto i (0); i < 60; ++i)
45  	{
46  		uint8_t r (number_l & static_cast<uint8_t> (0x1f));
47  		number_l >>= 5;
48  		destination_a.push_back (account_encode (r));
49  	}
50  	destination_a.append ("_onan"); 
51  	std::reverse (destination_a.begin (), destination_a.end ());
52  }
53  std::string nano::public_key::to_account () const
54  {
55  	std::string result;
56  	encode_account (result);
57  	return result;
58  }
59  nano::public_key::public_key () :
60  	uint256_union{ 0 }
61  {
62  }
63  nano::public_key const & nano::public_key::null ()
64  {
65  	return nano::hardened_constants::get ().not_an_account;
66  }
67  std::string nano::public_key::to_node_id () const
68  {
69  	return to_account ().replace (0, 4, "node");
70  }
71  bool nano::public_key::decode_node_id (std::string const & source_a)
72  {
73  	return decode_account (source_a);
74  }
75  bool nano::public_key::decode_account (std::string const & source_a)
76  {
77  	auto error (source_a.size () < 5);
78  	if (!error)
79  	{
80  		auto xrb_prefix (source_a[0] == 'x' && source_a[1] == 'r' && source_a[2] == 'b' && (source_a[3] == '_' || source_a[3] == '-'));
81  		auto nano_prefix (source_a[0] == 'n' && source_a[1] == 'a' && source_a[2] == 'n' && source_a[3] == 'o' && (source_a[4] == '_' || source_a[4] == '-'));
82  		auto node_id_prefix = (source_a[0] == 'n' && source_a[1] == 'o' && source_a[2] == 'd' && source_a[3] == 'e' && source_a[4] == '_');
83  		error = (xrb_prefix && source_a.size () != 64) || (nano_prefix && source_a.size () != 65);
84  		if (!error)
85  		{
86  			if (xrb_prefix || nano_prefix || node_id_prefix)
87  			{
88  				auto i (source_a.begin () + (xrb_prefix ? 4 : 5));
89  				if (*i == '1' || *i == '3')
90  				{
91  					nano::uint512_t number_l;
92  					for (auto j (source_a.end ()); !error && i != j; ++i)
93  					{
94  						uint8_t character (*i);
95  						error = character < 0x30 || character >= 0x80;
96  						if (!error)
97  						{
98  							uint8_t byte (account_decode (character));
99  							error = byte == '~';
100  							if (!error)
101  							{
102  								number_l <<= 5;
103  								number_l += byte;
104  							}
105  						}
106  					}
107  					if (!error)
108  					{
109  						nano::public_key temp = (number_l >> 40).convert_to<nano::uint256_t> ();
110  						uint64_t check (number_l & static_cast<uint64_t> (0xffffffffff));
111  						uint64_t validation (0);
112  						blake2b_state hash;
113  						blake2b_init (&hash, 5);
114  						blake2b_update (&hash, temp.bytes.data (), temp.bytes.size ());
115  						blake2b_final (&hash, reinterpret_cast<uint8_t *> (&validation), 5);
116  						error = check != validation;
117  						if (!error)
118  						{
119  							*this = temp;
120  						}
121  					}
122  				}
123  				else
124  				{
125  					error = true;
126  				}
127  			}
128  			else
129  			{
130  				error = true;
131  			}
132  		}
133  	}
134  	return error;
135  }
136  nano::uint256_union::uint256_union (nano::uint256_t const & number_a)
137  {
138  	bytes.fill (0);
139  	boost::multiprecision::export_bits (number_a, bytes.rbegin (), 8, false);
140  }
141  void nano::uint256_union::encrypt (nano::raw_key const & cleartext, nano::raw_key const & key, uint128_union const & iv)
142  {
143  	CryptoPP::AES::Encryption alg (key.bytes.data (), sizeof (key.bytes));
144  	CryptoPP::CTR_Mode_ExternalCipher::Encryption enc (alg, iv.bytes.data ());
145  	enc.ProcessData (bytes.data (), cleartext.bytes.data (), sizeof (cleartext.bytes));
146  }
147  bool nano::uint256_union::is_zero () const
148  {
149  	return qwords[0] == 0 && qwords[1] == 0 && qwords[2] == 0 && qwords[3] == 0;
150  }
151  std::string nano::uint256_union::to_string () const
152  {
153  	std::string result;
154  	encode_hex (result);
155  	return result;
156  }
157  nano::uint256_union & nano::uint256_union::operator^= (nano::uint256_union const & other_a)
158  {
159  	auto j (other_a.qwords.begin ());
160  	for (auto i (qwords.begin ()), n (qwords.end ()); i != n; ++i, ++j)
161  	{
162  		*i ^= *j;
163  	}
164  	return *this;
165  }
166  nano::uint256_union nano::uint256_union::operator^ (nano::uint256_union const & other_a) const
167  {
168  	nano::uint256_union result;
169  	auto k (result.qwords.begin ());
170  	for (auto i (qwords.begin ()), j (other_a.qwords.begin ()), n (qwords.end ()); i != n; ++i, ++j, ++k)
171  	{
172  		*k = *i ^ *j;
173  	}
174  	return result;
175  }
176  nano::uint256_union::uint256_union (std::string const & hex_a)
177  {
178  	auto error (decode_hex (hex_a));
179  	release_assert (!error);
180  }
181  void nano::uint256_union::clear ()
182  {
183  	qwords.fill (0);
184  }
185  nano::uint256_t nano::uint256_union::number () const
186  {
187  	nano::uint256_t result;
188  	boost::multiprecision::import_bits (result, bytes.begin (), bytes.end ());
189  	return result;
190  }
191  void nano::uint256_union::encode_hex (std::string & text) const
192  {
193  	debug_assert (text.empty ());
194  	std::stringstream stream;
195  	stream << std::hex << std::uppercase << std::noshowbase << std::setw (64) << std::setfill ('0');
196  	stream << number ();
197  	text = stream.str ();
198  }
199  bool nano::uint256_union::decode_hex (std::string const & text)
200  {
201  	auto error (false);
202  	if (!text.empty () && text.size () <= 64)
203  	{
204  		std::stringstream stream (text);
205  		stream << std::hex << std::noshowbase;
206  		nano::uint256_t number_l;
207  		try
208  		{
209  			stream >> number_l;
210  			*this = number_l;
211  			if (!stream.eof ())
212  			{
213  				error = true;
214  			}
215  		}
216  		catch (std::runtime_error &)
217  		{
218  			error = true;
219  		}
220  	}
221  	else
222  	{
223  		error = true;
224  	}
225  	return error;
226  }
227  void nano::uint256_union::encode_dec (std::string & text) const
228  {
229  	debug_assert (text.empty ());
230  	std::stringstream stream;
231  	stream << std::dec << std::noshowbase;
232  	stream << number ();
233  	text = stream.str ();
234  }
235  bool nano::uint256_union::decode_dec (std::string const & text)
236  {
237  	auto error (text.size () > 78 || (text.size () > 1 && text.front () == '0') || (!text.empty () && text.front () == '-'));
238  	if (!error)
239  	{
240  		std::stringstream stream (text);
241  		stream << std::dec << std::noshowbase;
242  		nano::uint256_t number_l;
243  		try
244  		{
245  			stream >> number_l;
246  			*this = number_l;
247  			if (!stream.eof ())
248  			{
249  				error = true;
250  			}
251  		}
252  		catch (std::runtime_error &)
253  		{
254  			error = true;
255  		}
256  	}
257  	return error;
258  }
259  nano::uint256_union::uint256_union (uint64_t value0)
260  {
261  	*this = nano::uint256_t (value0);
262  }
263  bool nano::uint512_union::operator== (nano::uint512_union const & other_a) const
264  {
265  	return bytes == other_a.bytes;
266  }
267  nano::uint512_union::uint512_union (nano::uint256_union const & upper, nano::uint256_union const & lower)
268  {
269  	uint256s[0] = upper;
270  	uint256s[1] = lower;
271  }
272  nano::uint512_union::uint512_union (nano::uint512_t const & number_a)
273  {
274  	bytes.fill (0);
275  	boost::multiprecision::export_bits (number_a, bytes.rbegin (), 8, false);
276  }
277  bool nano::uint512_union::is_zero () const
278  {
279  	return qwords[0] == 0 && qwords[1] == 0 && qwords[2] == 0 && qwords[3] == 0
280  	&& qwords[4] == 0 && qwords[5] == 0 && qwords[6] == 0 && qwords[7] == 0;
281  }
282  void nano::uint512_union::clear ()
283  {
284  	bytes.fill (0);
285  }
286  nano::uint512_t nano::uint512_union::number () const
287  {
288  	nano::uint512_t result;
289  	boost::multiprecision::import_bits (result, bytes.begin (), bytes.end ());
290  	return result;
291  }
292  void nano::uint512_union::encode_hex (std::string & text) const
293  {
294  	debug_assert (text.empty ());
295  	std::stringstream stream;
296  	stream << std::hex << std::uppercase << std::noshowbase << std::setw (128) << std::setfill ('0');
297  	stream << number ();
298  	text = stream.str ();
299  }
300  bool nano::uint512_union::decode_hex (std::string const & text)
301  {
302  	auto error (text.size () > 128);
303  	if (!error)
304  	{
305  		std::stringstream stream (text);
306  		stream << std::hex << std::noshowbase;
307  		nano::uint512_t number_l;
308  		try
309  		{
310  			stream >> number_l;
311  			*this = number_l;
312  			if (!stream.eof ())
313  			{
314  				error = true;
315  			}
316  		}
317  		catch (std::runtime_error &)
318  		{
319  			error = true;
320  		}
321  	}
322  	return error;
323  }
324  bool nano::uint512_union::operator!= (nano::uint512_union const & other_a) const
325  {
326  	return !(*this == other_a);
327  }
328  nano::uint512_union & nano::uint512_union::operator^= (nano::uint512_union const & other_a)
329  {
330  	uint256s[0] ^= other_a.uint256s[0];
331  	uint256s[1] ^= other_a.uint256s[1];
332  	return *this;
333  }
334  std::string nano::uint512_union::to_string () const
335  {
336  	std::string result;
337  	encode_hex (result);
338  	return result;
339  }
340  nano::raw_key::~raw_key ()
341  {
342  	secure_wipe_memory (bytes.data (), bytes.size ());
343  }
344  void nano::raw_key::decrypt (nano::uint256_union const & ciphertext, nano::raw_key const & key_a, uint128_union const & iv)
345  {
346  	CryptoPP::AES::Encryption alg (key_a.bytes.data (), sizeof (key_a.bytes));
347  	CryptoPP::CTR_Mode_ExternalCipher::Decryption dec (alg, iv.bytes.data ());
348  	dec.ProcessData (bytes.data (), ciphertext.bytes.data (), sizeof (ciphertext.bytes));
349  }
350  nano::raw_key nano::deterministic_key (nano::raw_key const & seed_a, uint32_t index_a)
351  {
352  	nano::raw_key prv_key;
353  	blake2b_state hash;
354  	blake2b_init (&hash, prv_key.bytes.size ());
355  	blake2b_update (&hash, seed_a.bytes.data (), seed_a.bytes.size ());
356  	nano::uint256_union index (index_a);
357  	blake2b_update (&hash, reinterpret_cast<uint8_t *> (&index.dwords[7]), sizeof (uint32_t));
358  	blake2b_final (&hash, prv_key.bytes.data (), prv_key.bytes.size ());
359  	return prv_key;
360  }
361  nano::public_key nano::pub_key (nano::raw_key const & raw_key_a)
362  {
363  	nano::public_key result;
364  	ed25519_publickey (raw_key_a.bytes.data (), result.bytes.data ());
365  	return result;
366  }
367  nano::signature nano::sign_message (nano::raw_key const & private_key, nano::public_key const & public_key, uint8_t const * data, size_t size)
368  {
369  	nano::signature result;
370  	ed25519_sign (data, size, private_key.bytes.data (), public_key.bytes.data (), result.bytes.data ());
371  	return result;
372  }
373  nano::signature nano::sign_message (nano::raw_key const & private_key, nano::public_key const & public_key, nano::uint256_union const & message)
374  {
375  	return nano::sign_message (private_key, public_key, message.bytes.data (), sizeof (message.bytes));
376  }
377  bool nano::validate_message (nano::public_key const & public_key, uint8_t const * data, size_t size, nano::signature const & signature)
378  {
379  	return 0 != ed25519_sign_open (data, size, public_key.bytes.data (), signature.bytes.data ());
380  }
381  bool nano::validate_message (nano::public_key const & public_key, nano::uint256_union const & message, nano::signature const & signature)
382  {
383  	return validate_message (public_key, message.bytes.data (), sizeof (message.bytes), signature);
384  }
385  bool nano::validate_message_batch (const unsigned char ** m, size_t * mlen, const unsigned char ** pk, const unsigned char ** RS, size_t num, int * valid)
386  {
387  	for (size_t i{ 0 }; i < num; ++i)
388  	{
389  		valid[i] = (0 == ed25519_sign_open (m[i], mlen[i], pk[i], RS[i]));
390  	}
391  	return true;
392  }
393  nano::uint128_union::uint128_union (std::string const & string_a)
394  {
395  	auto error (decode_hex (string_a));
396  	release_assert (!error);
397  }
398  nano::uint128_union::uint128_union (uint64_t value_a)
399  {
400  	*this = nano::uint128_t (value_a);
401  }
402  nano::uint128_union::uint128_union (nano::uint128_t const & number_a)
403  {
404  	bytes.fill (0);
405  	boost::multiprecision::export_bits (number_a, bytes.rbegin (), 8, false);
406  }
407  bool nano::uint128_union::operator== (nano::uint128_union const & other_a) const
408  {
409  	return qwords[0] == other_a.qwords[0] && qwords[1] == other_a.qwords[1];
410  }
411  bool nano::uint128_union::operator!= (nano::uint128_union const & other_a) const
412  {
413  	return !(*this == other_a);
414  }
415  bool nano::uint128_union::operator< (nano::uint128_union const & other_a) const
416  {
417  	return std::memcmp (bytes.data (), other_a.bytes.data (), 16) < 0;
418  }
419  bool nano::uint128_union::operator> (nano::uint128_union const & other_a) const
420  {
421  	return std::memcmp (bytes.data (), other_a.bytes.data (), 16) > 0;
422  }
423  nano::uint128_t nano::uint128_union::number () const
424  {
425  	nano::uint128_t result;
426  	boost::multiprecision::import_bits (result, bytes.begin (), bytes.end ());
427  	return result;
428  }
429  void nano::uint128_union::encode_hex (std::string & text) const
430  {
431  	debug_assert (text.empty ());
432  	std::stringstream stream;
433  	stream << std::hex << std::uppercase << std::noshowbase << std::setw (32) << std::setfill ('0');
434  	stream << number ();
435  	text = stream.str ();
436  }
437  bool nano::uint128_union::decode_hex (std::string const & text)
438  {
439  	auto error (text.size () > 32);
440  	if (!error)
441  	{
442  		std::stringstream stream (text);
443  		stream << std::hex << std::noshowbase;
444  		nano::uint128_t number_l;
445  		try
446  		{
447  			stream >> number_l;
448  			*this = number_l;
449  			if (!stream.eof ())
450  			{
451  				error = true;
452  			}
453  		}
454  		catch (std::runtime_error &)
455  		{
456  			error = true;
457  		}
458  	}
459  	return error;
460  }
461  void nano::uint128_union::encode_dec (std::string & text) const
462  {
463  	debug_assert (text.empty ());
464  	std::stringstream stream;
465  	stream << std::dec << std::noshowbase;
466  	stream << number ();
467  	text = stream.str ();
468  }
469  bool nano::uint128_union::decode_dec (std::string const & text, bool decimal)
470  {
471  	auto error (text.size () > 39 || (text.size () > 1 && text.front () == '0' && !decimal) || (!text.empty () && text.front () == '-'));
472  	if (!error)
473  	{
474  		std::stringstream stream (text);
475  		stream << std::dec << std::noshowbase;
476  		boost::multiprecision::checked_uint128_t number_l;
477  		try
478  		{
479  			stream >> number_l;
480  			nano::uint128_t unchecked (number_l);
481  			*this = unchecked;
482  			if (!stream.eof ())
483  			{
484  				error = true;
485  			}
486  		}
487  		catch (std::runtime_error &)
488  		{
489  			error = true;
490  		}
491  	}
492  	return error;
493  }
494  bool nano::uint128_union::decode_dec (std::string const & text, nano::uint128_t scale)
495  {
496  	bool error (text.size () > 40 || (!text.empty () && text.front () == '-'));
497  	if (!error)
498  	{
499  		auto delimiter_position (text.find (".")); 
500  		if (delimiter_position == std::string::npos)
501  		{
502  			nano::uint128_union integer;
503  			error = integer.decode_dec (text);
504  			if (!error)
505  			{
506  				try
507  				{
508  					auto result (boost::multiprecision::checked_uint128_t (integer.number ()) * boost::multiprecision::checked_uint128_t (scale));
509  					error = (result > std::numeric_limits<nano::uint128_t>::max ());
510  					if (!error)
511  					{
512  						*this = nano::uint128_t (result);
513  					}
514  				}
515  				catch (std::overflow_error &)
516  				{
517  					error = true;
518  				}
519  			}
520  		}
521  		else
522  		{
523  			nano::uint128_union integer_part;
524  			std::string integer_text (text.substr (0, delimiter_position));
525  			error = (integer_text.empty () || integer_part.decode_dec (integer_text));
526  			if (!error)
527  			{
528  				try
529  				{
530  					error = ((boost::multiprecision::checked_uint128_t (integer_part.number ()) * boost::multiprecision::checked_uint128_t (scale)) > std::numeric_limits<nano::uint128_t>::max ());
531  				}
532  				catch (std::overflow_error &)
533  				{
534  					error = true;
535  				}
536  				if (!error)
537  				{
538  					nano::uint128_union decimal_part;
539  					std::string decimal_text (text.substr (delimiter_position + 1, text.length ()));
540  					error = (decimal_text.empty () || decimal_part.decode_dec (decimal_text, true));
541  					if (!error)
542  					{
543  						auto scale_length (scale.convert_to<std::string> ().length ());
544  						error = (scale_length <= decimal_text.length ());
545  						if (!error)
546  						{
547  							auto base10 = boost::multiprecision::cpp_int (10);
548  							release_assert ((scale_length - decimal_text.length () - 1) <= std::numeric_limits<unsigned>::max ());
549  							auto pow10 = boost::multiprecision::pow (base10, static_cast<unsigned> (scale_length - decimal_text.length () - 1));
550  							auto decimal_part_num = decimal_part.number ();
551  							auto integer_part_scaled = integer_part.number () * scale;
552  							auto decimal_part_mult_pow = decimal_part_num * pow10;
553  							auto result = integer_part_scaled + decimal_part_mult_pow;
554  							error = (result > std::numeric_limits<nano::uint128_t>::max ());
555  							if (!error)
556  							{
557  								*this = nano::uint128_t (result);
558  							}
559  						}
560  					}
561  				}
562  			}
563  		}
564  	}
565  	return error;
566  }
567  void format_frac (std::ostringstream & stream, nano::uint128_t value, nano::uint128_t scale, int precision)
568  {
569  	auto reduce = scale;
570  	auto rem = value;
571  	while (reduce > 1 && rem > 0 && precision > 0)
572  	{
573  		reduce /= 10;
574  		auto val = rem / reduce;
575  		rem -= val * reduce;
576  		stream << val;
577  		precision--;
578  	}
579  }
580  void format_dec (std::ostringstream & stream, nano::uint128_t value, char group_sep, std::string const & groupings)
581  {
582  	auto largestPow10 = nano::uint256_t (1);
583  	int dec_count = 1;
584  	while (1)
585  	{
586  		auto next = largestPow10 * 10;
587  		if (next > value)
588  		{
589  			break;
590  		}
591  		largestPow10 = next;
592  		dec_count++;
593  	}
594  	if (dec_count > 39)
595  	{
596  		return;
597  	}
598  	bool emit_group[39];
599  	if (group_sep != 0)
<span onclick='openModal()' class='match'>600  	{
601  		int group_index = 0;
602  		int group_count = 0;
603  		for (int i = 0; i < dec_count; i++)
604  		{
605  			group_count++;
</span>606  			if (group_count > groupings[group_index])
607  			{
608  				group_index = std::min (group_index + 1, (int)groupings.length () - 1);
609  				group_count = 1;
610  				emit_group[i] = true;
611  			}
612  			else
613  			{
614  				emit_group[i] = false;
615  			}
616  		}
617  	}
618  	auto reduce = nano::uint128_t (largestPow10);
619  	nano::uint128_t rem = value;
620  	while (reduce > 0)
621  	{
622  		auto val = rem / reduce;
623  		rem -= val * reduce;
624  		stream << val;
625  		dec_count--;
626  		if (group_sep != 0 && emit_group[dec_count] && reduce > 1)
627  		{
628  			stream << group_sep;
629  		}
630  		reduce /= 10;
631  	}
632  }
633  std::string format_balance (nano::uint128_t balance, nano::uint128_t scale, int precision, bool group_digits, char thousands_sep, char decimal_point, std::string & grouping)
634  {
635  	std::ostringstream stream;
636  	auto int_part = balance / scale;
637  	auto frac_part = balance % scale;
638  	auto prec_scale = scale;
639  	for (int i = 0; i < precision; i++)
640  	{
641  		prec_scale /= 10;
642  	}
643  	if (int_part == 0 && frac_part > 0 && frac_part / prec_scale == 0)
644  	{
645  		stream << "< ";
646  		if (precision > 0)
647  		{
648  			stream << "0";
649  			stream << decimal_point;
650  			for (int i = 0; i < precision - 1; i++)
651  			{
652  				stream << "0";
653  			}
654  		}
655  		stream << "1";
656  	}
657  	else
658  	{
659  		format_dec (stream, int_part, group_digits && grouping.length () > 0 ? thousands_sep : 0, grouping);
660  		if (precision > 0 && frac_part > 0)
661  		{
662  			stream << decimal_point;
663  			format_frac (stream, frac_part, scale, precision);
664  		}
665  	}
666  	return stream.str ();
667  }
668  std::string nano::uint128_union::format_balance (nano::uint128_t scale, int precision, bool group_digits) const
669  {
670  	auto thousands_sep = std::use_facet<std::numpunct<char>> (std::locale ()).thousands_sep ();
671  	auto decimal_point = std::use_facet<std::numpunct<char>> (std::locale ()).decimal_point ();
672  	std::string grouping = "\3";
673  	return ::format_balance (number (), scale, precision, group_digits, thousands_sep, decimal_point, grouping);
674  }
675  std::string nano::uint128_union::format_balance (nano::uint128_t scale, int precision, bool group_digits, std::locale const & locale) const
676  {
677  	auto thousands_sep = std::use_facet<std::moneypunct<char>> (locale).thousands_sep ();
678  	auto decimal_point = std::use_facet<std::moneypunct<char>> (locale).decimal_point ();
679  	std::string grouping = std::use_facet<std::moneypunct<char>> (locale).grouping ();
680  	return ::format_balance (number (), scale, precision, group_digits, thousands_sep, decimal_point, grouping);
681  }
682  void nano::uint128_union::clear ()
683  {
684  	qwords.fill (0);
685  }
686  bool nano::uint128_union::is_zero () const
687  {
688  	return qwords[0] == 0 && qwords[1] == 0;
689  }
690  std::string nano::uint128_union::to_string () const
691  {
692  	std::string result;
693  	encode_hex (result);
694  	return result;
695  }
696  std::string nano::uint128_union::to_string_dec () const
697  {
698  	std::string result;
699  	encode_dec (result);
700  	return result;
701  }
702  nano::hash_or_account::hash_or_account () :
703  	account{}
704  {
705  }
706  nano::hash_or_account::hash_or_account (uint64_t value_a) :
707  	raw (value_a)
708  {
709  }
710  bool nano::hash_or_account::is_zero () const
711  {
712  	return raw.is_zero ();
713  }
714  void nano::hash_or_account::clear ()
715  {
716  	raw.clear ();
717  }
718  bool nano::hash_or_account::decode_hex (std::string const & text_a)
719  {
720  	return raw.decode_hex (text_a);
721  }
722  bool nano::hash_or_account::decode_account (std::string const & source_a)
723  {
724  	return account.decode_account (source_a);
725  }
726  std::string nano::hash_or_account::to_string () const
727  {
728  	return raw.to_string ();
729  }
730  std::string nano::hash_or_account::to_account () const
731  {
732  	return account.to_account ();
733  }
734  nano::block_hash const & nano::hash_or_account::as_block_hash () const
735  {
736  	return hash;
737  }
738  nano::account const & nano::hash_or_account::as_account () const
739  {
740  	return account;
741  }
742  nano::hash_or_account::operator nano::uint256_union const & () const
743  {
744  	return raw;
745  }
746  nano::block_hash const & nano::root::previous () const
747  {
748  	return hash;
749  }
750  bool nano::hash_or_account::operator== (nano::hash_or_account const & hash_or_account_a) const
751  {
752  	return bytes == hash_or_account_a.bytes;
753  }
754  bool nano::hash_or_account::operator!= (nano::hash_or_account const & hash_or_account_a) const
755  {
756  	return !(*this == hash_or_account_a);
757  }
758  std::string nano::to_string_hex (uint64_t const value_a)
759  {
760  	std::stringstream stream;
761  	stream << std::hex << std::noshowbase << std::setw (16) << std::setfill ('0');
762  	stream << value_a;
763  	return stream.str ();
764  }
765  std::string nano::to_string_hex (uint16_t const value_a)
766  {
767  	std::stringstream stream;
768  	stream << std::hex << std::noshowbase << std::setw (4) << std::setfill ('0');
769  	stream << value_a;
770  	return stream.str ();
771  }
772  bool nano::from_string_hex (std::string const & value_a, uint64_t & target_a)
773  {
774  	auto error (value_a.empty ());
775  	if (!error)
776  	{
777  		error = value_a.size () > 16;
778  		if (!error)
779  		{
780  			std::stringstream stream (value_a);
781  			stream << std::hex << std::noshowbase;
782  			try
783  			{
784  				uint64_t number_l;
785  				stream >> number_l;
786  				target_a = number_l;
787  				if (!stream.eof ())
788  				{
789  					error = true;
790  				}
791  			}
792  			catch (std::runtime_error &)
793  			{
794  				error = true;
795  			}
796  		}
797  	}
798  	return error;
799  }
800  std::string nano::to_string (double const value_a, int const precision_a)
801  {
802  	std::stringstream stream;
803  	stream << std::setprecision (precision_a) << std::fixed;
804  	stream << value_a;
805  	return stream.str ();
806  }
807  #ifdef _WIN32
808  #pragma warning(push)
809  #pragma warning(disable : 4146) 
810  #endif
811  uint64_t nano::difficulty::from_multiplier (double const multiplier_a, uint64_t const base_difficulty_a)
812  {
813  	debug_assert (multiplier_a > 0.);
814  	nano::uint128_t reverse_difficulty ((-base_difficulty_a) / multiplier_a);
815  	if (reverse_difficulty > std::numeric_limits<std::uint64_t>::max ())
816  	{
817  		return 0;
818  	}
819  	else if (reverse_difficulty != 0 || base_difficulty_a == 0 || multiplier_a < 1.)
820  	{
821  		return -(static_cast<uint64_t> (reverse_difficulty));
822  	}
823  	else
824  	{
825  		return std::numeric_limits<std::uint64_t>::max ();
826  	}
827  }
828  double nano::difficulty::to_multiplier (uint64_t const difficulty_a, uint64_t const base_difficulty_a)
829  {
830  	debug_assert (difficulty_a > 0);
831  	return static_cast<double> (-base_difficulty_a) / (-difficulty_a);
832  }
833  #ifdef _WIN32
834  #pragma warning(pop)
835  #endif
836  nano::public_key::operator nano::link const & () const
837  {
838  	return reinterpret_cast<nano::link const &> (*this);
839  }
840  nano::public_key::operator nano::root const & () const
841  {
842  	return reinterpret_cast<nano::root const &> (*this);
843  }
844  nano::public_key::operator nano::hash_or_account const & () const
845  {
846  	return reinterpret_cast<nano::hash_or_account const &> (*this);
847  }
848  bool nano::public_key::operator== (std::nullptr_t) const
849  {
850  	return bytes == null ().bytes;
851  }
852  bool nano::public_key::operator!= (std::nullptr_t) const
853  {
854  	return !(*this == nullptr);
855  }
856  nano::block_hash::operator nano::link const & () const
857  {
858  	return reinterpret_cast<nano::link const &> (*this);
859  }
860  nano::block_hash::operator nano::root const & () const
861  {
862  	return reinterpret_cast<nano::root const &> (*this);
863  }
864  nano::block_hash::operator nano::hash_or_account const & () const
865  {
866  	return reinterpret_cast<nano::hash_or_account const &> (*this);
867  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-numbers.cpp</div>
                <div class="column column_space"><pre><code>233    int GetUnconnQUrls() const {
234      int QUrls=0; int Levs=GetQLevs();
235      for (int Lev=0; Lev<Levs; Lev++){QUrls+=GetQLevUrls(Lev);}
</pre></code></div>
                <div class="column column_space"><pre><code>600  	{
601  		int group_index = 0;
602  		int group_count = 0;
603  		for (int i = 0; i < dec_count; i++)
604  		{
605  			group_count++;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    