
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 43, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-reject.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "reject.h"
5  #ifdef DISABLED_LEGACY_ENGINE
6  #  include "tesseractclass.h"
7  namespace tesseract {
8  int16_t Tesseract::safe_dict_word(const WERD_RES *werd_res) {
9    const WERD_CHOICE &word = *werd_res->best_choice;
10    int dict_word_type = werd_res->tesseract->dict_word(word);
11    return dict_word_type == DOC_DAWG_PERM ? 0 : dict_word_type;
12  }
13  } 
14  #else
15  #  include "control.h"
16  #  include "docqual.h"
17  #  include "tesseractclass.h"
18  #  include "tessvars.h"
19  #  include "helpers.h"
20  #  include <algorithm> 
21  #  include <cctype>
22  #  include <cerrno>
23  #  include <cstring>
24  #  include <vector> 
25  namespace tesseract {
26  void Tesseract::set_done(WERD_RES *word, int16_t pass) {
27    word->done =
28        word->tess_accepted && (strchr(word->best_choice->unichar_string().c_str(), ' ') == nullptr);
29    bool word_is_ambig = word->best_choice->dangerous_ambig_found();
30    bool word_from_dict = word->best_choice->permuter() == SYSTEM_DAWG_PERM ||
31                          word->best_choice->permuter() == FREQ_DAWG_PERM ||
32                          word->best_choice->permuter() == USER_DAWG_PERM;
33    if (word->done && (pass == 1) && (!word_from_dict || word_is_ambig) &&
34        one_ell_conflict(word, false)) {
35      if (tessedit_rejection_debug) {
36        tprintf("one_ell_conflict detected\n");
37      }
38      word->done = false;
39    }
40    if (word->done &&
41        ((!word_from_dict && word->best_choice->permuter() != NUMBER_PERM) || word_is_ambig)) {
42      if (tessedit_rejection_debug) {
43        tprintf("non-dict or ambig word detected\n");
44      }
45      word->done = false;
46    }
47    if (tessedit_rejection_debug) {
48      tprintf("set_done(): done=%d\n", word->done);
49      word->best_choice->print("");
50    }
51  }
52  void Tesseract::make_reject_map(WERD_RES *word, ROW *row, int16_t pass) {
53    flip_0O(word);
54    check_debug_pt(word, -1); 
55    set_done(word, pass);     
56    word->reject_map.initialise(word->best_choice->unichar_lengths().length());
57    reject_blanks(word);
58    if (tessedit_reject_mode == 0) {
59      if (!word->done) {
60        reject_poor_matches(word);
61      }
62    } else if (tessedit_reject_mode == 5) {
63      if (kBlnXHeight / word->denorm.y_scale() <= min_sane_x_ht_pixels) {
64        word->reject_map.rej_word_small_xht();
65      } else {
66        one_ell_conflict(word, true);
67        if (rej_use_tess_accepted && !word->tess_accepted) {
68          word->reject_map.rej_word_not_tess_accepted();
69        }
70        if (rej_use_tess_blanks &&
71            (strchr(word->best_choice->unichar_string().c_str(), ' ') != nullptr)) {
72          word->reject_map.rej_word_contains_blanks();
73        }
74        WERD_CHOICE *best_choice = word->best_choice;
75        if (rej_use_good_perm) {
76          if ((best_choice->permuter() == SYSTEM_DAWG_PERM ||
77               best_choice->permuter() == FREQ_DAWG_PERM ||
78               best_choice->permuter() == USER_DAWG_PERM) &&
79              (!rej_use_sensible_wd ||
80               acceptable_word_string(*word->uch_set, best_choice->unichar_string().c_str(),
81                                      best_choice->unichar_lengths().c_str()) != AC_UNACCEPTABLE)) {
82          } else if (best_choice->permuter() == NUMBER_PERM) {
83            if (rej_alphas_in_number_perm) {
84              for (int i = 0, offset = 0; best_choice->unichar_string()[offset] != '\0';
85                   offset += best_choice->unichar_lengths()[i++]) {
86                if (word->reject_map[i].accepted() &&
87                    word->uch_set->get_isalpha(best_choice->unichar_string().c_str() + offset,
88                                               best_choice->unichar_lengths()[i])) {
89                  word->reject_map[i].setrej_bad_permuter();
90                }
91              }
92            }
93          } else {
94            word->reject_map.rej_word_bad_permuter();
95          }
96        }
97      }
98    } else {
99      tprintf("BAD tessedit_reject_mode\n");
100      ASSERT_HOST("Fatal error encountered!" == nullptr);
101    }
102    if (tessedit_image_border > -1) {
103      reject_edge_blobs(word);
104    }
105    check_debug_pt(word, 10);
106    if (tessedit_rejection_debug) {
107      tprintf("Permuter Type = %d\n", word->best_choice->permuter());
108      tprintf("Certainty: %f     Rating: %f\n", word->best_choice->certainty(),
109              word->best_choice->rating());
110      tprintf("Dict word: %d\n", dict_word(*(word->best_choice)));
111    }
112    flip_hyphens(word);
113    check_debug_pt(word, 20);
114  }
115  void reject_blanks(WERD_RES *word) {
116    int16_t i;
117    int16_t offset;
118    for (i = 0, offset = 0; word->best_choice->unichar_string()[offset] != '\0';
119         offset += word->best_choice->unichar_lengths()[i], i += 1) {
120      if (word->best_choice->unichar_string()[offset] == ' ') {
121        word->reject_map[i].setrej_tess_failure();
122      }
123    }
124  }
125  void Tesseract::reject_I_1_L(WERD_RES *word) {
126    int16_t i;
127    int16_t offset;
128    for (i = 0, offset = 0; word->best_choice->unichar_string()[offset] != '\0';
129         offset += word->best_choice->unichar_lengths()[i], i += 1) {
130      if (conflict_set_I_l_1.contains(word->best_choice->unichar_string()[offset])) {
131        word->reject_map[i].setrej_1Il_conflict();
132      }
133    }
134  }
135  void reject_poor_matches(WERD_RES *word) {
136    float threshold = compute_reject_threshold(word->best_choice);
137    for (unsigned i = 0; i < word->best_choice->length(); ++i) {
138      if (word->best_choice->unichar_id(i) == UNICHAR_SPACE) {
139        word->reject_map[i].setrej_tess_failure();
140      } else if (word->best_choice->certainty(i) < threshold) {
141        word->reject_map[i].setrej_poor_match();
142      }
143    }
144  }
145  float compute_reject_threshold(WERD_CHOICE *word) {
146    float threshold;      
147    float bestgap = 0.0f; 
148    float gapstart;       
149    auto blob_count = word->length();
150    std::vector<float> ratings;
151    ratings.reserve(blob_count);
152    for (unsigned i = 0; i < blob_count; ++i) {
153      ratings.push_back(word->certainty(i));
154    }
155    std::sort(ratings.begin(), ratings.end());
156    gapstart = ratings[0] - 1; 
157    if (blob_count >= 3) {
158      for (unsigned index = 0; index < blob_count - 1; index++) {
159        if (ratings[index + 1] - ratings[index] > bestgap) {
160          bestgap = ratings[index + 1] - ratings[index];
161          gapstart = ratings[index];
162        }
163      }
164    }
165    threshold = gapstart + bestgap / 2;
166    return threshold;
167  }
168  void Tesseract::reject_edge_blobs(WERD_RES *word) {
169    TBOX word_box = word->word->bounding_box();
170    int blobcount = word->box_word->length();
171    if (word_box.left() < tessedit_image_border || word_box.bottom() < tessedit_image_border ||
172        word_box.right() + tessedit_image_border > ImageWidth() - 1 ||
173        word_box.top() + tessedit_image_border > ImageHeight() - 1) {
174      ASSERT_HOST(word->reject_map.length() == blobcount);
175      for (int blobindex = 0; blobindex < blobcount; blobindex++) {
176        TBOX blob_box = word->box_word->BlobBox(blobindex);
177        if (blob_box.left() < tessedit_image_border || blob_box.bottom() < tessedit_image_border ||
178            blob_box.right() + tessedit_image_border > ImageWidth() - 1 ||
179            blob_box.top() + tessedit_image_border > ImageHeight() - 1) {
180          word->reject_map[blobindex].setrej_edge_char();
181        }
182      }
183    }
184  }
185  bool Tesseract::one_ell_conflict(WERD_RES *word_res, bool update_map) {
186    const char *word;
187    const char *lengths;
188    int16_t word_len; 
189    int16_t first_alphanum_index_;
190    int16_t first_alphanum_offset_;
191    int16_t i;
192    int16_t offset;
193    bool non_conflict_set_char; 
194    bool conflict = false;
195    bool allow_1s;
196    ACCEPTABLE_WERD_TYPE word_type;
197    bool dict_perm_type;
198    bool dict_word_ok;
199    int dict_word_type;
200    word = word_res->best_choice->unichar_string().c_str();
201    lengths = word_res->best_choice->unichar_lengths().c_str();
202    word_len = strlen(lengths);
203    if (strpbrk(word, conflict_set_I_l_1.c_str()) == nullptr) {
204      return false;
205    }
206    for (i = 0, offset = 0, non_conflict_set_char = false; (i < word_len) && !non_conflict_set_char;
207         offset += lengths[i++]) {
208      non_conflict_set_char = (word_res->uch_set->get_isalpha(word + offset, lengths[i]) ||
209                               word_res->uch_set->get_isdigit(word + offset, lengths[i])) &&
210                              !conflict_set_I_l_1.contains(word[offset]);
211    }
212    if (!non_conflict_set_char) {
213      if (update_map) {
214        reject_I_1_L(word_res);
215      }
216      return true;
217    }
218    dict_perm_type = (word_res->best_choice->permuter() == SYSTEM_DAWG_PERM) ||
219                     (word_res->best_choice->permuter() == USER_DAWG_PERM) ||
220                     (rej_trust_doc_dawg && (word_res->best_choice->permuter() == DOC_DAWG_PERM)) ||
221                     (word_res->best_choice->permuter() == FREQ_DAWG_PERM);
222    dict_word_type = dict_word(*(word_res->best_choice));
223    dict_word_ok = (dict_word_type > 0) && (rej_trust_doc_dawg || (dict_word_type != DOC_DAWG_PERM));
224    if ((rej_1Il_use_dict_word && dict_word_ok) || (rej_1Il_trust_permuter_type && dict_perm_type) ||
225        (dict_perm_type && dict_word_ok)) {
226      first_alphanum_index_ = first_alphanum_index(word, lengths);
227      first_alphanum_offset_ = first_alphanum_offset(word, lengths);
228      if (lengths[first_alphanum_index_] == 1 && word[first_alphanum_offset_] == 'I') {
229        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
230        if (safe_dict_word(word_res) > 0) {
231          word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
232          if (update_map) {
233            word_res->reject_map[first_alphanum_index_].setrej_1Il_conflict();
234          }
235          return true;
236        } else {
237          word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
238          return false;
239        }
240      }
241      if (lengths[first_alphanum_index_] == 1 && word[first_alphanum_offset_] == 'l') {
242        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
243        if (safe_dict_word(word_res) > 0) {
244          word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
245          if (update_map) {
246            word_res->reject_map[first_alphanum_index_].setrej_1Il_conflict();
247          }
248          return true;
249        } else {
250          word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
251          return false;
252        }
253      }
254      return false;
255    }
256    first_alphanum_index_ = first_alphanum_index(word, lengths);
257    first_alphanum_offset_ = first_alphanum_offset(word, lengths);
258    if (lengths[first_alphanum_index_] == 1 && word[first_alphanum_offset_] == 'l') {
259      word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
260      if (safe_dict_word(word_res) > 0) {
261        return false;
262      } else {
263        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
264      }
265    } else if (lengths[first_alphanum_index_] == 1 && word[first_alphanum_offset_] == 'I') {
266      word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
267      if (safe_dict_word(word_res) > 0) {
268        return false;
269      } else {
270        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
271      }
272    }
273    if (word_contains_non_1_digit(word, lengths)) {
274      allow_1s =
275          (alpha_count(word, lengths) == 0) || (word_res->best_choice->permuter() == NUMBER_PERM);
276      int16_t offset;
277      conflict = false;
278      for (i = 0, offset = 0; word[offset] != '\0';
279           offset += word_res->best_choice->unichar_lengths()[i++]) {
280        if ((!allow_1s || (word[offset] != '1')) &&
281            conflict_set_I_l_1.contains(word[offset])) {
282          if (update_map) {
283            word_res->reject_map[i].setrej_1Il_conflict();
284          }
285          conflict = true;
286        }
287      }
288      return conflict;
289    }
290    word_type = acceptable_word_string(*word_res->uch_set, word, lengths);
291    if ((word_type == AC_LOWER_CASE) || (word_type == AC_INITIAL_CAP)) {
292      first_alphanum_index_ = first_alphanum_index(word, lengths);
293      first_alphanum_offset_ = first_alphanum_offset(word, lengths);
294      if (conflict_set_I_l_1.contains(word[first_alphanum_offset_])) {
295        if (update_map) {
296          word_res->reject_map[first_alphanum_index_].setrej_1Il_conflict();
297        }
298        return true;
299      } else {
300        return false;
301      }
302    } else if (word_type == AC_UPPER_CASE) {
303      return false;
304    } else {
305      if (update_map) {
306        reject_I_1_L(word_res);
307      }
308      return true;
309    }
310  }
311  int16_t Tesseract::first_alphanum_index(const char *word, const char *word_lengths) {
312    int16_t i;
313    int16_t offset;
314    for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
315      if (unicharset.get_isalpha(word + offset, word_lengths[i]) ||
316          unicharset.get_isdigit(word + offset, word_lengths[i])) {
317        return i;
318      }
319    }
320    return -1;
321  }
322  int16_t Tesseract::first_alphanum_offset(const char *word, const char *word_lengths) {
323    int16_t i;
324    int16_t offset;
325    for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
326      if (unicharset.get_isalpha(word + offset, word_lengths[i]) ||
327          unicharset.get_isdigit(word + offset, word_lengths[i])) {
328        return offset;
329      }
330    }
331    return -1;
332  }
333  int16_t Tesseract::alpha_count(const char *word, const char *word_lengths) {
334    int16_t i;
335    int16_t offset;
336    int16_t count = 0;
337    for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
338      if (unicharset.get_isalpha(word + offset, word_lengths[i])) {
339        count++;
340      }
341    }
342    return count;
343  }
344  bool Tesseract::word_contains_non_1_digit(const char *word, const char *word_lengths) {
345    int16_t i;
346    int16_t offset;
347    for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
348      if (unicharset.get_isdigit(word + offset, word_lengths[i]) &&
349          (word_lengths[i] != 1 || word[offset] != '1')) {
350        return true;
351      }
352    }
353    return false;
354  }
355  void Tesseract::dont_allow_1Il(WERD_RES *word) {
356    int word_len = word->reject_map.length();
357    const char *s = word->best_choice->unichar_string().c_str();
358    const char *lengths = word->best_choice->unichar_lengths().c_str();
359    bool accepted_1Il = false;
360    for (int i = 0, offset = 0; i < word_len; offset += word->best_choice->unichar_lengths()[i++]) {
361      if (word->reject_map[i].accepted()) {
362        if (conflict_set_I_l_1.contains(s[offset])) {
363          accepted_1Il = true;
364        } else {
365          if (word->uch_set->get_isalpha(s + offset, lengths[i]) ||
366              word->uch_set->get_isdigit(s + offset, lengths[i])) {
367            return; 
368          }
369        }
370      }
371    }
372    if (!accepted_1Il) {
373      return; 
374    }
375    for (int i = 0, offset = 0; i < word_len; offset += word->best_choice->unichar_lengths()[i++]) {
376      if (conflict_set_I_l_1.contains(s[offset]) && word->reject_map[i].accepted()) {
377        word->reject_map[i].setrej_postNN_1Il();
378      }
379    }
380  }
381  int16_t Tesseract::count_alphanums(WERD_RES *word_res) {
382    int count = 0;
383    const WERD_CHOICE *best_choice = word_res->best_choice;
384    for (unsigned i = 0; i < word_res->reject_map.length(); ++i) {
385      if ((word_res->reject_map[i].accepted()) &&
386          (word_res->uch_set->get_isalpha(best_choice->unichar_id(i)) ||
387           word_res->uch_set->get_isdigit(best_choice->unichar_id(i)))) {
388        count++;
389      }
390    }
391    return count;
392  }
393  void Tesseract::reject_mostly_rejects(WERD_RES *word) {
394    if (static_cast<float>(word->reject_map.reject_count()) / word->reject_map.length() >=
395        rej_whole_of_mostly_reject_word_fract) {
396      word->reject_map.rej_word_mostly_rej();
397    }
398  }
399  bool Tesseract::repeated_nonalphanum_wd(WERD_RES *word, ROW *row) {
400    if (word->best_choice->unichar_lengths().length() <= 1) {
401      return false;
402    }
403    if (!ok_repeated_ch_non_alphanum_wds.contains(word->best_choice->unichar_string()[0])) {
404      return false;
405    }
406    UNICHAR_ID uch_id = word->best_choice->unichar_id(0);
407    for (unsigned i = 1; i < word->best_choice->length(); ++i) {
408      if (word->best_choice->unichar_id(i) != uch_id) {
409        return false;
410      }
411    }
412    int16_t char_quality;
413    int16_t accepted_char_quality;
414    word_char_quality(word, &char_quality, &accepted_char_quality);
415    if ((word->best_choice->unichar_lengths().length() == static_cast<size_t>(char_quality)) &&
416        (char_quality == accepted_char_quality)) {
417      return true;
418    } else {
419      return false;
420    }
421  }
<span onclick='openModal()' class='match'>422  int16_t Tesseract::safe_dict_word(const WERD_RES *werd_res) {
423    const WERD_CHOICE &word = *werd_res->best_choice;
424    int dict_word_type = werd_res->tesseract->dict_word(word);
425    return dict_word_type == DOC_DAWG_PERM ? 0 : dict_word_type;
426  }
427  void Tesseract::flip_hyphens(WERD_RES *word_res) {
</span>428    WERD_CHOICE *best_choice = word_res->best_choice;
429    int prev_right = -9999;
430    int next_left;
431    TBOX out_box;
432    float aspect_ratio;
433    if (tessedit_lower_flip_hyphen <= 1) {
434      return;
435    }
436    auto num_blobs = word_res->rebuild_word->NumBlobs();
437    UNICHAR_ID unichar_dash = word_res->uch_set->unichar_to_id("-");
438    for (unsigned i = 0; i < best_choice->length() && i < num_blobs; ++i) {
439      TBLOB *blob = word_res->rebuild_word->blobs[i];
440      out_box = blob->bounding_box();
441      if (i + 1 == num_blobs) {
442        next_left = 9999;
443      } else {
444        next_left = word_res->rebuild_word->blobs[i + 1]->bounding_box().left();
445      }
446      if ((out_box.width() > 8 * word_res->denorm.x_scale()) && (out_box.left() > prev_right) &&
447          (out_box.right() < next_left)) {
448        aspect_ratio = out_box.width() / static_cast<float>(out_box.height());
449        if (word_res->uch_set->eq(best_choice->unichar_id(i), ".")) {
450          if (aspect_ratio >= tessedit_upper_flip_hyphen &&
451              word_res->uch_set->contains_unichar_id(unichar_dash) &&
452              word_res->uch_set->get_enabled(unichar_dash)) {
453            best_choice->set_unichar_id(unichar_dash, i);
454            if (word_res->reject_map[i].rejected()) {
455              word_res->reject_map[i].setrej_hyphen_accept();
456            }
457          }
458          if ((aspect_ratio > tessedit_lower_flip_hyphen) && word_res->reject_map[i].accepted()) {
459            word_res->reject_map[i].setrej_hyphen();
460          }
461        } else if (best_choice->unichar_id(i) == unichar_dash) {
462          if ((aspect_ratio >= tessedit_upper_flip_hyphen) && (word_res->reject_map[i].rejected())) {
463            word_res->reject_map[i].setrej_hyphen_accept();
464          }
465          if ((aspect_ratio <= tessedit_lower_flip_hyphen) && (word_res->reject_map[i].accepted())) {
466            word_res->reject_map[i].setrej_hyphen();
467          }
468        }
469      }
470      prev_right = out_box.right();
471    }
472  }
473  void Tesseract::flip_0O(WERD_RES *word_res) {
474    WERD_CHOICE *best_choice = word_res->best_choice;
475    TBOX out_box;
476    if (!tessedit_flip_0O) {
477      return;
478    }
479    auto num_blobs = word_res->rebuild_word->NumBlobs();
480    for (unsigned i = 0; i < best_choice->length() && i < num_blobs; ++i) {
481      TBLOB *blob = word_res->rebuild_word->blobs[i];
482      if (word_res->uch_set->get_isupper(best_choice->unichar_id(i)) ||
483          word_res->uch_set->get_isdigit(best_choice->unichar_id(i))) {
484        out_box = blob->bounding_box();
485        if ((out_box.top() < kBlnBaselineOffset + kBlnXHeight) ||
486            (out_box.bottom() > kBlnBaselineOffset + kBlnXHeight / 4)) {
487          return; 
488        }
489      }
490    }
491    UNICHAR_ID unichar_0 = word_res->uch_set->unichar_to_id("0");
492    UNICHAR_ID unichar_O = word_res->uch_set->unichar_to_id("O");
493    if (unichar_0 == INVALID_UNICHAR_ID || !word_res->uch_set->get_enabled(unichar_0) ||
494        unichar_O == INVALID_UNICHAR_ID || !word_res->uch_set->get_enabled(unichar_O)) {
495      return; 
496    }
497    for (unsigned i = 1; i < best_choice->length(); ++i) {
498      if (best_choice->unichar_id(i) == unichar_0 || best_choice->unichar_id(i) == unichar_O) {
499        if ((i + 1) < best_choice->length() &&
500            non_O_upper(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
501            non_O_upper(*word_res->uch_set, best_choice->unichar_id(i + 1))) {
502          best_choice->set_unichar_id(unichar_O, i);
503        }
504        if (non_O_upper(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
505            (i + 1) < best_choice->length() &&
506            (best_choice->unichar_id(i + 1) == unichar_0 ||
507             best_choice->unichar_id(i + 1) == unichar_O) &&
508            (i + 2) < best_choice->length() &&
509            non_O_upper(*word_res->uch_set, best_choice->unichar_id(i + 2))) {
510          best_choice->set_unichar_id(unichar_O, i);
511          i++;
512        }
513        if ((i > 1) && non_O_upper(*word_res->uch_set, best_choice->unichar_id(i - 2)) &&
514            non_O_upper(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
515            (((i + 1) < best_choice->length() &&
516              !word_res->uch_set->get_isdigit(best_choice->unichar_id(i + 1)) &&
517              !word_res->uch_set->eq(best_choice->unichar_id(i + 1), "l") &&
518              !word_res->uch_set->eq(best_choice->unichar_id(i + 1), "I")) ||
519             (i == best_choice->length() - 1))) {
520          best_choice->set_unichar_id(unichar_O, i);
521        }
522        if (non_0_digit(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
523            (i + 1) < best_choice->length() &&
524            non_0_digit(*word_res->uch_set, best_choice->unichar_id(i + 1))) {
525          best_choice->set_unichar_id(unichar_0, i);
526        }
527        if (non_0_digit(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
528            (i + 2) < best_choice->length() &&
529            (best_choice->unichar_id(i + 1) == unichar_0 ||
530             best_choice->unichar_id(i + 1) == unichar_O) &&
531            (best_choice->unichar_id(i + 2) == unichar_0 ||
532             best_choice->unichar_id(i + 2) == unichar_O)) {
533          best_choice->set_unichar_id(unichar_0, i);
534          best_choice->set_unichar_id(unichar_0, i + 1);
535          best_choice->set_unichar_id(unichar_0, i + 2);
536          i += 2;
537        }
538        if (non_0_digit(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
539            (i + 2) < best_choice->length() &&
540            (best_choice->unichar_id(i + 1) == unichar_0 ||
541             best_choice->unichar_id(i + 1) == unichar_O) &&
542            !word_res->uch_set->get_isupper(best_choice->unichar_id(i + 2))) {
543          best_choice->set_unichar_id(unichar_0, i);
544          best_choice->set_unichar_id(unichar_0, i + 1);
545          i++;
546        }
547        if (non_0_digit(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
548            (i + 1) < best_choice->length() &&
549            !word_res->uch_set->get_isupper(best_choice->unichar_id(i + 1))) {
550          best_choice->set_unichar_id(unichar_0, i);
551        }
552        if ((i > 1) &&
553            (word_res->uch_set->eq(best_choice->unichar_id(i - 1), ".") ||
554             word_res->uch_set->eq(best_choice->unichar_id(i - 1), ",")) &&
555            (word_res->uch_set->get_isdigit(best_choice->unichar_id(i - 2)) ||
556             best_choice->unichar_id(i - 2) == unichar_O)) {
557          if (best_choice->unichar_id(i - 2) == unichar_O) {
558            best_choice->set_unichar_id(unichar_0, i - 2);
559          }
560          while (i < best_choice->length() && (best_choice->unichar_id(i) == unichar_O ||
561                                               best_choice->unichar_id(i) == unichar_0)) {
562            best_choice->set_unichar_id(unichar_0, i);
563            i++;
564          }
565          i--;
566        }
567      }
568    }
569  }
570  bool Tesseract::non_O_upper(const UNICHARSET &ch_set, UNICHAR_ID unichar_id) {
571    return ch_set.get_isupper(unichar_id) && !ch_set.eq(unichar_id, "O");
572  }
573  bool Tesseract::non_0_digit(const UNICHARSET &ch_set, UNICHAR_ID unichar_id) {
574    return ch_set.get_isdigit(unichar_id) && !ch_set.eq(unichar_id, "0");
575  }
576  } 
577  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-reject.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "reject.h"
5  #ifdef DISABLED_LEGACY_ENGINE
6  #  include "tesseractclass.h"
7  namespace tesseract {
8  int16_t Tesseract::safe_dict_word(const WERD_RES *werd_res) {
9    const WERD_CHOICE &word = *werd_res->best_choice;
10    int dict_word_type = werd_res->tesseract->dict_word(word);
11    return dict_word_type == DOC_DAWG_PERM ? 0 : dict_word_type;
12  }
13  } 
14  #else
15  #  include "control.h"
16  #  include "docqual.h"
17  #  include "tesseractclass.h"
18  #  include "tessvars.h"
19  #  include "helpers.h"
20  #  include <algorithm> 
21  #  include <cctype>
22  #  include <cerrno>
23  #  include <cstring>
24  #  include <vector> 
25  namespace tesseract {
26  void Tesseract::set_done(WERD_RES *word, int16_t pass) {
27    word->done =
28        word->tess_accepted && (strchr(word->best_choice->unichar_string().c_str(), ' ') == nullptr);
29    bool word_is_ambig = word->best_choice->dangerous_ambig_found();
30    bool word_from_dict = word->best_choice->permuter() == SYSTEM_DAWG_PERM ||
31                          word->best_choice->permuter() == FREQ_DAWG_PERM ||
32                          word->best_choice->permuter() == USER_DAWG_PERM;
33    if (word->done && (pass == 1) && (!word_from_dict || word_is_ambig) &&
34        one_ell_conflict(word, false)) {
35      if (tessedit_rejection_debug) {
36        tprintf("one_ell_conflict detected\n");
37      }
38      word->done = false;
39    }
40    if (word->done &&
41        ((!word_from_dict && word->best_choice->permuter() != NUMBER_PERM) || word_is_ambig)) {
42      if (tessedit_rejection_debug) {
43        tprintf("non-dict or ambig word detected\n");
44      }
45      word->done = false;
46    }
47    if (tessedit_rejection_debug) {
48      tprintf("set_done(): done=%d\n", word->done);
49      word->best_choice->print("");
50    }
51  }
52  void Tesseract::make_reject_map(WERD_RES *word, ROW *row, int16_t pass) {
53    flip_0O(word);
54    check_debug_pt(word, -1); 
55    set_done(word, pass);     
56    word->reject_map.initialise(word->best_choice->unichar_lengths().length());
57    reject_blanks(word);
58    if (tessedit_reject_mode == 0) {
59      if (!word->done) {
60        reject_poor_matches(word);
61      }
62    } else if (tessedit_reject_mode == 5) {
63      if (kBlnXHeight / word->denorm.y_scale() <= min_sane_x_ht_pixels) {
64        word->reject_map.rej_word_small_xht();
65      } else {
66        one_ell_conflict(word, true);
67        if (rej_use_tess_accepted && !word->tess_accepted) {
68          word->reject_map.rej_word_not_tess_accepted();
69        }
70        if (rej_use_tess_blanks &&
71            (strchr(word->best_choice->unichar_string().c_str(), ' ') != nullptr)) {
72          word->reject_map.rej_word_contains_blanks();
73        }
74        WERD_CHOICE *best_choice = word->best_choice;
75        if (rej_use_good_perm) {
76          if ((best_choice->permuter() == SYSTEM_DAWG_PERM ||
77               best_choice->permuter() == FREQ_DAWG_PERM ||
78               best_choice->permuter() == USER_DAWG_PERM) &&
79              (!rej_use_sensible_wd ||
80               acceptable_word_string(*word->uch_set, best_choice->unichar_string().c_str(),
81                                      best_choice->unichar_lengths().c_str()) != AC_UNACCEPTABLE)) {
82          } else if (best_choice->permuter() == NUMBER_PERM) {
83            if (rej_alphas_in_number_perm) {
84              for (int i = 0, offset = 0; best_choice->unichar_string()[offset] != '\0';
85                   offset += best_choice->unichar_lengths()[i++]) {
86                if (word->reject_map[i].accepted() &&
87                    word->uch_set->get_isalpha(best_choice->unichar_string().c_str() + offset,
88                                               best_choice->unichar_lengths()[i])) {
89                  word->reject_map[i].setrej_bad_permuter();
90                }
91              }
92            }
93          } else {
94            word->reject_map.rej_word_bad_permuter();
95          }
96        }
97      }
98    } else {
99      tprintf("BAD tessedit_reject_mode\n");
100      ASSERT_HOST("Fatal error encountered!" == nullptr);
101    }
102    if (tessedit_image_border > -1) {
103      reject_edge_blobs(word);
104    }
105    check_debug_pt(word, 10);
106    if (tessedit_rejection_debug) {
107      tprintf("Permuter Type = %d\n", word->best_choice->permuter());
108      tprintf("Certainty: %f     Rating: %f\n", word->best_choice->certainty(),
109              word->best_choice->rating());
110      tprintf("Dict word: %d\n", dict_word(*(word->best_choice)));
111    }
112    flip_hyphens(word);
113    check_debug_pt(word, 20);
114  }
115  void reject_blanks(WERD_RES *word) {
116    int16_t i;
117    int16_t offset;
118    for (i = 0, offset = 0; word->best_choice->unichar_string()[offset] != '\0';
119         offset += word->best_choice->unichar_lengths()[i], i += 1) {
120      if (word->best_choice->unichar_string()[offset] == ' ') {
121        word->reject_map[i].setrej_tess_failure();
122      }
123    }
124  }
125  void Tesseract::reject_I_1_L(WERD_RES *word) {
126    int16_t i;
127    int16_t offset;
128    for (i = 0, offset = 0; word->best_choice->unichar_string()[offset] != '\0';
129         offset += word->best_choice->unichar_lengths()[i], i += 1) {
130      if (conflict_set_I_l_1.contains(word->best_choice->unichar_string()[offset])) {
131        word->reject_map[i].setrej_1Il_conflict();
132      }
133    }
134  }
135  void reject_poor_matches(WERD_RES *word) {
136    float threshold = compute_reject_threshold(word->best_choice);
137    for (unsigned i = 0; i < word->best_choice->length(); ++i) {
138      if (word->best_choice->unichar_id(i) == UNICHAR_SPACE) {
139        word->reject_map[i].setrej_tess_failure();
140      } else if (word->best_choice->certainty(i) < threshold) {
141        word->reject_map[i].setrej_poor_match();
142      }
143    }
144  }
145  float compute_reject_threshold(WERD_CHOICE *word) {
146    float threshold;      
147    float bestgap = 0.0f; 
148    float gapstart;       
149    auto blob_count = word->length();
150    std::vector<float> ratings;
151    ratings.reserve(blob_count);
152    for (unsigned i = 0; i < blob_count; ++i) {
153      ratings.push_back(word->certainty(i));
154    }
155    std::sort(ratings.begin(), ratings.end());
156    gapstart = ratings[0] - 1; 
157    if (blob_count >= 3) {
158      for (unsigned index = 0; index < blob_count - 1; index++) {
159        if (ratings[index + 1] - ratings[index] > bestgap) {
160          bestgap = ratings[index + 1] - ratings[index];
161          gapstart = ratings[index];
162        }
163      }
164    }
165    threshold = gapstart + bestgap / 2;
166    return threshold;
167  }
168  void Tesseract::reject_edge_blobs(WERD_RES *word) {
169    TBOX word_box = word->word->bounding_box();
170    int blobcount = word->box_word->length();
171    if (word_box.left() < tessedit_image_border || word_box.bottom() < tessedit_image_border ||
172        word_box.right() + tessedit_image_border > ImageWidth() - 1 ||
173        word_box.top() + tessedit_image_border > ImageHeight() - 1) {
174      ASSERT_HOST(word->reject_map.length() == blobcount);
175      for (int blobindex = 0; blobindex < blobcount; blobindex++) {
176        TBOX blob_box = word->box_word->BlobBox(blobindex);
177        if (blob_box.left() < tessedit_image_border || blob_box.bottom() < tessedit_image_border ||
178            blob_box.right() + tessedit_image_border > ImageWidth() - 1 ||
179            blob_box.top() + tessedit_image_border > ImageHeight() - 1) {
180          word->reject_map[blobindex].setrej_edge_char();
181        }
182      }
183    }
184  }
185  bool Tesseract::one_ell_conflict(WERD_RES *word_res, bool update_map) {
186    const char *word;
187    const char *lengths;
188    int16_t word_len; 
189    int16_t first_alphanum_index_;
190    int16_t first_alphanum_offset_;
191    int16_t i;
192    int16_t offset;
193    bool non_conflict_set_char; 
194    bool conflict = false;
195    bool allow_1s;
196    ACCEPTABLE_WERD_TYPE word_type;
197    bool dict_perm_type;
198    bool dict_word_ok;
199    int dict_word_type;
200    word = word_res->best_choice->unichar_string().c_str();
201    lengths = word_res->best_choice->unichar_lengths().c_str();
202    word_len = strlen(lengths);
203    if (strpbrk(word, conflict_set_I_l_1.c_str()) == nullptr) {
204      return false;
205    }
206    for (i = 0, offset = 0, non_conflict_set_char = false; (i < word_len) && !non_conflict_set_char;
207         offset += lengths[i++]) {
208      non_conflict_set_char = (word_res->uch_set->get_isalpha(word + offset, lengths[i]) ||
209                               word_res->uch_set->get_isdigit(word + offset, lengths[i])) &&
210                              !conflict_set_I_l_1.contains(word[offset]);
211    }
212    if (!non_conflict_set_char) {
213      if (update_map) {
214        reject_I_1_L(word_res);
215      }
216      return true;
217    }
218    dict_perm_type = (word_res->best_choice->permuter() == SYSTEM_DAWG_PERM) ||
219                     (word_res->best_choice->permuter() == USER_DAWG_PERM) ||
220                     (rej_trust_doc_dawg && (word_res->best_choice->permuter() == DOC_DAWG_PERM)) ||
221                     (word_res->best_choice->permuter() == FREQ_DAWG_PERM);
222    dict_word_type = dict_word(*(word_res->best_choice));
223    dict_word_ok = (dict_word_type > 0) && (rej_trust_doc_dawg || (dict_word_type != DOC_DAWG_PERM));
224    if ((rej_1Il_use_dict_word && dict_word_ok) || (rej_1Il_trust_permuter_type && dict_perm_type) ||
225        (dict_perm_type && dict_word_ok)) {
226      first_alphanum_index_ = first_alphanum_index(word, lengths);
227      first_alphanum_offset_ = first_alphanum_offset(word, lengths);
228      if (lengths[first_alphanum_index_] == 1 && word[first_alphanum_offset_] == 'I') {
229        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
230        if (safe_dict_word(word_res) > 0) {
231          word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
232          if (update_map) {
233            word_res->reject_map[first_alphanum_index_].setrej_1Il_conflict();
234          }
235          return true;
236        } else {
237          word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
238          return false;
239        }
240      }
241      if (lengths[first_alphanum_index_] == 1 && word[first_alphanum_offset_] == 'l') {
242        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
243        if (safe_dict_word(word_res) > 0) {
244          word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
245          if (update_map) {
246            word_res->reject_map[first_alphanum_index_].setrej_1Il_conflict();
247          }
248          return true;
249        } else {
250          word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
251          return false;
252        }
253      }
254      return false;
255    }
256    first_alphanum_index_ = first_alphanum_index(word, lengths);
257    first_alphanum_offset_ = first_alphanum_offset(word, lengths);
258    if (lengths[first_alphanum_index_] == 1 && word[first_alphanum_offset_] == 'l') {
259      word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
260      if (safe_dict_word(word_res) > 0) {
261        return false;
262      } else {
263        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
264      }
265    } else if (lengths[first_alphanum_index_] == 1 && word[first_alphanum_offset_] == 'I') {
266      word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
267      if (safe_dict_word(word_res) > 0) {
268        return false;
269      } else {
270        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
271      }
272    }
273    if (word_contains_non_1_digit(word, lengths)) {
274      allow_1s =
275          (alpha_count(word, lengths) == 0) || (word_res->best_choice->permuter() == NUMBER_PERM);
276      int16_t offset;
277      conflict = false;
278      for (i = 0, offset = 0; word[offset] != '\0';
279           offset += word_res->best_choice->unichar_lengths()[i++]) {
280        if ((!allow_1s || (word[offset] != '1')) &&
281            conflict_set_I_l_1.contains(word[offset])) {
282          if (update_map) {
283            word_res->reject_map[i].setrej_1Il_conflict();
284          }
285          conflict = true;
286        }
287      }
288      return conflict;
289    }
290    word_type = acceptable_word_string(*word_res->uch_set, word, lengths);
291    if ((word_type == AC_LOWER_CASE) || (word_type == AC_INITIAL_CAP)) {
292      first_alphanum_index_ = first_alphanum_index(word, lengths);
293      first_alphanum_offset_ = first_alphanum_offset(word, lengths);
294      if (conflict_set_I_l_1.contains(word[first_alphanum_offset_])) {
295        if (update_map) {
296          word_res->reject_map[first_alphanum_index_].setrej_1Il_conflict();
297        }
298        return true;
299      } else {
300        return false;
301      }
302    } else if (word_type == AC_UPPER_CASE) {
303      return false;
304    } else {
305      if (update_map) {
306        reject_I_1_L(word_res);
307      }
308      return true;
309    }
310  }
311  int16_t Tesseract::first_alphanum_index(const char *word, const char *word_lengths) {
312    int16_t i;
313    int16_t offset;
314    for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
315      if (unicharset.get_isalpha(word + offset, word_lengths[i]) ||
316          unicharset.get_isdigit(word + offset, word_lengths[i])) {
317        return i;
318      }
319    }
320    return -1;
321  }
322  int16_t Tesseract::first_alphanum_offset(const char *word, const char *word_lengths) {
323    int16_t i;
324    int16_t offset;
325    for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
326      if (unicharset.get_isalpha(word + offset, word_lengths[i]) ||
327          unicharset.get_isdigit(word + offset, word_lengths[i])) {
328        return offset;
329      }
330    }
331    return -1;
332  }
333  int16_t Tesseract::alpha_count(const char *word, const char *word_lengths) {
334    int16_t i;
335    int16_t offset;
336    int16_t count = 0;
337    for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
338      if (unicharset.get_isalpha(word + offset, word_lengths[i])) {
339        count++;
340      }
341    }
342    return count;
343  }
344  bool Tesseract::word_contains_non_1_digit(const char *word, const char *word_lengths) {
345    int16_t i;
346    int16_t offset;
347    for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
348      if (unicharset.get_isdigit(word + offset, word_lengths[i]) &&
349          (word_lengths[i] != 1 || word[offset] != '1')) {
350        return true;
351      }
352    }
353    return false;
354  }
355  void Tesseract::dont_allow_1Il(WERD_RES *word) {
356    int word_len = word->reject_map.length();
357    const char *s = word->best_choice->unichar_string().c_str();
358    const char *lengths = word->best_choice->unichar_lengths().c_str();
359    bool accepted_1Il = false;
360    for (int i = 0, offset = 0; i < word_len; offset += word->best_choice->unichar_lengths()[i++]) {
361      if (word->reject_map[i].accepted()) {
362        if (conflict_set_I_l_1.contains(s[offset])) {
363          accepted_1Il = true;
364        } else {
365          if (word->uch_set->get_isalpha(s + offset, lengths[i]) ||
366              word->uch_set->get_isdigit(s + offset, lengths[i])) {
367            return; 
368          }
369        }
370      }
371    }
372    if (!accepted_1Il) {
373      return; 
374    }
375    for (int i = 0, offset = 0; i < word_len; offset += word->best_choice->unichar_lengths()[i++]) {
376      if (conflict_set_I_l_1.contains(s[offset]) && word->reject_map[i].accepted()) {
377        word->reject_map[i].setrej_postNN_1Il();
378      }
379    }
380  }
381  int16_t Tesseract::count_alphanums(WERD_RES *word_res) {
382    int count = 0;
383    const WERD_CHOICE *best_choice = word_res->best_choice;
384    for (unsigned i = 0; i < word_res->reject_map.length(); ++i) {
385      if ((word_res->reject_map[i].accepted()) &&
386          (word_res->uch_set->get_isalpha(best_choice->unichar_id(i)) ||
387           word_res->uch_set->get_isdigit(best_choice->unichar_id(i)))) {
388        count++;
389      }
390    }
391    return count;
392  }
393  void Tesseract::reject_mostly_rejects(WERD_RES *word) {
394    if (static_cast<float>(word->reject_map.reject_count()) / word->reject_map.length() >=
395        rej_whole_of_mostly_reject_word_fract) {
396      word->reject_map.rej_word_mostly_rej();
397    }
398  }
399  bool Tesseract::repeated_nonalphanum_wd(WERD_RES *word, ROW *row) {
400    if (word->best_choice->unichar_lengths().length() <= 1) {
401      return false;
402    }
403    if (!ok_repeated_ch_non_alphanum_wds.contains(word->best_choice->unichar_string()[0])) {
404      return false;
405    }
406    UNICHAR_ID uch_id = word->best_choice->unichar_id(0);
407    for (unsigned i = 1; i < word->best_choice->length(); ++i) {
408      if (word->best_choice->unichar_id(i) != uch_id) {
409        return false;
410      }
411    }
412    int16_t char_quality;
413    int16_t accepted_char_quality;
414    word_char_quality(word, &char_quality, &accepted_char_quality);
415    if ((word->best_choice->unichar_lengths().length() == static_cast<size_t>(char_quality)) &&
416        (char_quality == accepted_char_quality)) {
417      return true;
418    } else {
419      return false;
420    }
421  }
<span onclick='openModal()' class='match'>422  int16_t Tesseract::safe_dict_word(const WERD_RES *werd_res) {
423    const WERD_CHOICE &word = *werd_res->best_choice;
424    int dict_word_type = werd_res->tesseract->dict_word(word);
425    return dict_word_type == DOC_DAWG_PERM ? 0 : dict_word_type;
426  }
427  void Tesseract::flip_hyphens(WERD_RES *word_res) {
</span>428    WERD_CHOICE *best_choice = word_res->best_choice;
429    int prev_right = -9999;
430    int next_left;
431    TBOX out_box;
432    float aspect_ratio;
433    if (tessedit_lower_flip_hyphen <= 1) {
434      return;
435    }
436    auto num_blobs = word_res->rebuild_word->NumBlobs();
437    UNICHAR_ID unichar_dash = word_res->uch_set->unichar_to_id("-");
438    for (unsigned i = 0; i < best_choice->length() && i < num_blobs; ++i) {
439      TBLOB *blob = word_res->rebuild_word->blobs[i];
440      out_box = blob->bounding_box();
441      if (i + 1 == num_blobs) {
442        next_left = 9999;
443      } else {
444        next_left = word_res->rebuild_word->blobs[i + 1]->bounding_box().left();
445      }
446      if ((out_box.width() > 8 * word_res->denorm.x_scale()) && (out_box.left() > prev_right) &&
447          (out_box.right() < next_left)) {
448        aspect_ratio = out_box.width() / static_cast<float>(out_box.height());
449        if (word_res->uch_set->eq(best_choice->unichar_id(i), ".")) {
450          if (aspect_ratio >= tessedit_upper_flip_hyphen &&
451              word_res->uch_set->contains_unichar_id(unichar_dash) &&
452              word_res->uch_set->get_enabled(unichar_dash)) {
453            best_choice->set_unichar_id(unichar_dash, i);
454            if (word_res->reject_map[i].rejected()) {
455              word_res->reject_map[i].setrej_hyphen_accept();
456            }
457          }
458          if ((aspect_ratio > tessedit_lower_flip_hyphen) && word_res->reject_map[i].accepted()) {
459            word_res->reject_map[i].setrej_hyphen();
460          }
461        } else if (best_choice->unichar_id(i) == unichar_dash) {
462          if ((aspect_ratio >= tessedit_upper_flip_hyphen) && (word_res->reject_map[i].rejected())) {
463            word_res->reject_map[i].setrej_hyphen_accept();
464          }
465          if ((aspect_ratio <= tessedit_lower_flip_hyphen) && (word_res->reject_map[i].accepted())) {
466            word_res->reject_map[i].setrej_hyphen();
467          }
468        }
469      }
470      prev_right = out_box.right();
471    }
472  }
473  void Tesseract::flip_0O(WERD_RES *word_res) {
474    WERD_CHOICE *best_choice = word_res->best_choice;
475    TBOX out_box;
476    if (!tessedit_flip_0O) {
477      return;
478    }
479    auto num_blobs = word_res->rebuild_word->NumBlobs();
480    for (unsigned i = 0; i < best_choice->length() && i < num_blobs; ++i) {
481      TBLOB *blob = word_res->rebuild_word->blobs[i];
482      if (word_res->uch_set->get_isupper(best_choice->unichar_id(i)) ||
483          word_res->uch_set->get_isdigit(best_choice->unichar_id(i))) {
484        out_box = blob->bounding_box();
485        if ((out_box.top() < kBlnBaselineOffset + kBlnXHeight) ||
486            (out_box.bottom() > kBlnBaselineOffset + kBlnXHeight / 4)) {
487          return; 
488        }
489      }
490    }
491    UNICHAR_ID unichar_0 = word_res->uch_set->unichar_to_id("0");
492    UNICHAR_ID unichar_O = word_res->uch_set->unichar_to_id("O");
493    if (unichar_0 == INVALID_UNICHAR_ID || !word_res->uch_set->get_enabled(unichar_0) ||
494        unichar_O == INVALID_UNICHAR_ID || !word_res->uch_set->get_enabled(unichar_O)) {
495      return; 
496    }
497    for (unsigned i = 1; i < best_choice->length(); ++i) {
498      if (best_choice->unichar_id(i) == unichar_0 || best_choice->unichar_id(i) == unichar_O) {
499        if ((i + 1) < best_choice->length() &&
500            non_O_upper(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
501            non_O_upper(*word_res->uch_set, best_choice->unichar_id(i + 1))) {
502          best_choice->set_unichar_id(unichar_O, i);
503        }
504        if (non_O_upper(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
505            (i + 1) < best_choice->length() &&
506            (best_choice->unichar_id(i + 1) == unichar_0 ||
507             best_choice->unichar_id(i + 1) == unichar_O) &&
508            (i + 2) < best_choice->length() &&
509            non_O_upper(*word_res->uch_set, best_choice->unichar_id(i + 2))) {
510          best_choice->set_unichar_id(unichar_O, i);
511          i++;
512        }
513        if ((i > 1) && non_O_upper(*word_res->uch_set, best_choice->unichar_id(i - 2)) &&
514            non_O_upper(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
515            (((i + 1) < best_choice->length() &&
516              !word_res->uch_set->get_isdigit(best_choice->unichar_id(i + 1)) &&
517              !word_res->uch_set->eq(best_choice->unichar_id(i + 1), "l") &&
518              !word_res->uch_set->eq(best_choice->unichar_id(i + 1), "I")) ||
519             (i == best_choice->length() - 1))) {
520          best_choice->set_unichar_id(unichar_O, i);
521        }
522        if (non_0_digit(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
523            (i + 1) < best_choice->length() &&
524            non_0_digit(*word_res->uch_set, best_choice->unichar_id(i + 1))) {
525          best_choice->set_unichar_id(unichar_0, i);
526        }
527        if (non_0_digit(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
528            (i + 2) < best_choice->length() &&
529            (best_choice->unichar_id(i + 1) == unichar_0 ||
530             best_choice->unichar_id(i + 1) == unichar_O) &&
531            (best_choice->unichar_id(i + 2) == unichar_0 ||
532             best_choice->unichar_id(i + 2) == unichar_O)) {
533          best_choice->set_unichar_id(unichar_0, i);
534          best_choice->set_unichar_id(unichar_0, i + 1);
535          best_choice->set_unichar_id(unichar_0, i + 2);
536          i += 2;
537        }
538        if (non_0_digit(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
539            (i + 2) < best_choice->length() &&
540            (best_choice->unichar_id(i + 1) == unichar_0 ||
541             best_choice->unichar_id(i + 1) == unichar_O) &&
542            !word_res->uch_set->get_isupper(best_choice->unichar_id(i + 2))) {
543          best_choice->set_unichar_id(unichar_0, i);
544          best_choice->set_unichar_id(unichar_0, i + 1);
545          i++;
546        }
547        if (non_0_digit(*word_res->uch_set, best_choice->unichar_id(i - 1)) &&
548            (i + 1) < best_choice->length() &&
549            !word_res->uch_set->get_isupper(best_choice->unichar_id(i + 1))) {
550          best_choice->set_unichar_id(unichar_0, i);
551        }
552        if ((i > 1) &&
553            (word_res->uch_set->eq(best_choice->unichar_id(i - 1), ".") ||
554             word_res->uch_set->eq(best_choice->unichar_id(i - 1), ",")) &&
555            (word_res->uch_set->get_isdigit(best_choice->unichar_id(i - 2)) ||
556             best_choice->unichar_id(i - 2) == unichar_O)) {
557          if (best_choice->unichar_id(i - 2) == unichar_O) {
558            best_choice->set_unichar_id(unichar_0, i - 2);
559          }
560          while (i < best_choice->length() && (best_choice->unichar_id(i) == unichar_O ||
561                                               best_choice->unichar_id(i) == unichar_0)) {
562            best_choice->set_unichar_id(unichar_0, i);
563            i++;
564          }
565          i--;
566        }
567      }
568    }
569  }
570  bool Tesseract::non_O_upper(const UNICHARSET &ch_set, UNICHAR_ID unichar_id) {
571    return ch_set.get_isupper(unichar_id) && !ch_set.eq(unichar_id, "O");
572  }
573  bool Tesseract::non_0_digit(const UNICHARSET &ch_set, UNICHAR_ID unichar_id) {
574    return ch_set.get_isdigit(unichar_id) && !ch_set.eq(unichar_id, "0");
575  }
576  } 
577  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-reject.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-reject.cpp</div>
                </div>
                <div class="column column_space"><pre><code>422  int16_t Tesseract::safe_dict_word(const WERD_RES *werd_res) {
423    const WERD_CHOICE &word = *werd_res->best_choice;
424    int dict_word_type = werd_res->tesseract->dict_word(word);
425    return dict_word_type == DOC_DAWG_PERM ? 0 : dict_word_type;
426  }
427  void Tesseract::flip_hyphens(WERD_RES *word_res) {
</pre></code></div>
                <div class="column column_space"><pre><code>422  int16_t Tesseract::safe_dict_word(const WERD_RES *werd_res) {
423    const WERD_CHOICE &word = *werd_res->best_choice;
424    int dict_word_type = werd_res->tesseract->dict_word(word);
425    return dict_word_type == DOC_DAWG_PERM ? 0 : dict_word_type;
426  }
427  void Tesseract::flip_hyphens(WERD_RES *word_res) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    