
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.473684210526317%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-elu_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <vector>
3  #include "caffe/layers/elu_layer.hpp"
4  namespace caffe {
5  template <typename Dtype>
6  void ELULayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
7      const vector<Blob<Dtype>*>& top) {
8    const Dtype* bottom_data = bottom[0]->cpu_data();
9    Dtype* top_data = top[0]->mutable_cpu_data();
10    const int count = bottom[0]->count();
<span onclick='openModal()' class='match'>11    Dtype alpha = this->layer_param_.elu_param().alpha();
12  #ifdef _OPENMP
13  #pragma omp parallel for
14  #endif
15    for (int i = 0; i < count; ++i) {
16      top_data[i] = std::max(bottom_data[i], Dtype(0))
17          + alpha * (exp(std::min(bottom_data[i], Dtype(0))) - Dtype(1));
18    }
19  }
</span>20  template <typename Dtype>
21  void ELULayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
22      const vector<bool>& propagate_down,
23      const vector<Blob<Dtype>*>& bottom) {
24    if (propagate_down[0]) {
25      const Dtype* bottom_data = bottom[0]->cpu_data();
26      const Dtype* top_data = top[0]->cpu_data();
27      const Dtype* top_diff = top[0]->cpu_diff();
28      Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
29      const int count = bottom[0]->count();
30      Dtype alpha = this->layer_param_.elu_param().alpha();
31  #ifdef _OPENMP
32  #pragma omp parallel for
33  #endif
34      for (int i = 0; i < count; ++i) {
35        bottom_diff[i] = top_diff[i] * ((bottom_data[i] > 0)
36            + (alpha + top_data[i]) * (bottom_data[i] <= 0));
37      }
38    }
39  }
40  #ifdef CPU_ONLY
41  STUB_GPU(ELULayer);
42  #endif
43  INSTANTIATE_CLASS(ELULayer);
44  REGISTER_LAYER_CLASS(ELU);
45  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_contrastive_loss_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <cmath>
3  #include <vector>
4  #include "gtest/gtest.h"
5  #include "caffe/blob.hpp"
6  #include "caffe/common.hpp"
7  #include "caffe/filler.hpp"
8  #include "caffe/layers/contrastive_loss_layer.hpp"
9  #include "caffe/test/test_caffe_main.hpp"
10  #include "caffe/test/test_gradient_check_util.hpp"
11  namespace caffe {
12  template <typename TypeParam>
13  class ContrastiveLossLayerTest : public MultiDeviceTest<TypeParam> {
14    typedef typename TypeParam::Dtype Dtype;
15   protected:
16    ContrastiveLossLayerTest()
17        : blob_bottom_data_i_(new Blob<Dtype>(512, 2, 1, 1)),
18          blob_bottom_data_j_(new Blob<Dtype>(512, 2, 1, 1)),
19          blob_bottom_y_(new Blob<Dtype>(512, 1, 1, 1)),
20          blob_top_loss_(new Blob<Dtype>()) {
21      FillerParameter filler_param;
22      filler_param.set_min(-1.0);
23      filler_param.set_max(1.0);  
24      UniformFiller<Dtype> filler(filler_param);
25      filler.Fill(this->blob_bottom_data_i_);
26      blob_bottom_vec_.push_back(blob_bottom_data_i_);
<span onclick='openModal()' class='match'>27      filler.Fill(this->blob_bottom_data_j_);
28      blob_bottom_vec_.push_back(blob_bottom_data_j_);
29      for (int i = 0; i < blob_bottom_y_->count(); ++i) {
30        blob_bottom_y_->mutable_cpu_data()[i] = caffe_rng_rand() % 2;  
31      }
32      blob_bottom_vec_.push_back(blob_bottom_y_);
33      blob_top_vec_.push_back(blob_top_loss_);
34    }
</span>35    virtual ~ContrastiveLossLayerTest() {
36      delete blob_bottom_data_i_;
37      delete blob_bottom_data_j_;
38      delete blob_bottom_y_;
39      delete blob_top_loss_;
40    }
41    Blob<Dtype>* const blob_bottom_data_i_;
42    Blob<Dtype>* const blob_bottom_data_j_;
43    Blob<Dtype>* const blob_bottom_y_;
44    Blob<Dtype>* const blob_top_loss_;
45    vector<Blob<Dtype>*> blob_bottom_vec_;
46    vector<Blob<Dtype>*> blob_top_vec_;
47  };
48  TYPED_TEST_CASE(ContrastiveLossLayerTest, TestDtypesAndDevices);
49  TYPED_TEST(ContrastiveLossLayerTest, TestForward) {
50    typedef typename TypeParam::Dtype Dtype;
51    LayerParameter layer_param;
52    ContrastiveLossLayer<Dtype> layer(layer_param);
53    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
54    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
55    const Dtype margin = layer_param.contrastive_loss_param().margin();
56    const int num = this->blob_bottom_data_i_->num();
57    const int channels = this->blob_bottom_data_i_->channels();
58    Dtype loss(0);
59    for (int i = 0; i < num; ++i) {
60      Dtype dist_sq(0);
61      for (int j = 0; j < channels; ++j) {
62        Dtype diff = this->blob_bottom_data_i_->cpu_data()[i*channels+j] -
63            this->blob_bottom_data_j_->cpu_data()[i*channels+j];
64        dist_sq += diff*diff;
65      }
66      if (this->blob_bottom_y_->cpu_data()[i]) {  
67        loss += dist_sq;
68      } else {
69        Dtype dist = std::max<Dtype>(margin - sqrt(dist_sq), 0.0);
70        loss += dist*dist;
71      }
72    }
73    loss /= static_cast<Dtype>(num) * Dtype(2);
74    EXPECT_NEAR(this->blob_top_loss_->cpu_data()[0], loss, 1e-6);
75  }
76  TYPED_TEST(ContrastiveLossLayerTest, TestGradient) {
77    typedef typename TypeParam::Dtype Dtype;
78    LayerParameter layer_param;
79    ContrastiveLossLayer<Dtype> layer(layer_param);
80    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
81    GradientChecker<Dtype> checker(1e-2, 1e-2, 1701);
82    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
83        this->blob_top_vec_, 0);
84    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
85        this->blob_top_vec_, 1);
86  }
87  TYPED_TEST(ContrastiveLossLayerTest, TestForwardLegacy) {
88    typedef typename TypeParam::Dtype Dtype;
89    LayerParameter layer_param;
90    layer_param.mutable_contrastive_loss_param()->set_legacy_version(true);
91    ContrastiveLossLayer<Dtype> layer(layer_param);
92    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
93    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
94    const Dtype margin = layer_param.contrastive_loss_param().margin();
95    const int num = this->blob_bottom_data_i_->num();
96    const int channels = this->blob_bottom_data_i_->channels();
97    Dtype loss(0);
98    for (int i = 0; i < num; ++i) {
99      Dtype dist_sq(0);
100      for (int j = 0; j < channels; ++j) {
101        Dtype diff = this->blob_bottom_data_i_->cpu_data()[i*channels+j] -
102            this->blob_bottom_data_j_->cpu_data()[i*channels+j];
103        dist_sq += diff*diff;
104      }
105      if (this->blob_bottom_y_->cpu_data()[i]) {  
106        loss += dist_sq;
107      } else {
108        loss += std::max(margin - dist_sq, Dtype(0.0));
109      }
110    }
111    loss /= static_cast<Dtype>(num) * Dtype(2);
112    EXPECT_NEAR(this->blob_top_loss_->cpu_data()[0], loss, 1e-6);
113  }
114  TYPED_TEST(ContrastiveLossLayerTest, TestGradientLegacy) {
115    typedef typename TypeParam::Dtype Dtype;
116    LayerParameter layer_param;
117    layer_param.mutable_contrastive_loss_param()->set_legacy_version(true);
118    ContrastiveLossLayer<Dtype> layer(layer_param);
119    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
120    GradientChecker<Dtype> checker(1e-2, 1e-2, 1701);
121    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
122        this->blob_top_vec_, 0);
123    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
124        this->blob_top_vec_, 1);
125  }
126  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-elu_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_contrastive_loss_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>11    Dtype alpha = this->layer_param_.elu_param().alpha();
12  #ifdef _OPENMP
13  #pragma omp parallel for
14  #endif
15    for (int i = 0; i < count; ++i) {
16      top_data[i] = std::max(bottom_data[i], Dtype(0))
17          + alpha * (exp(std::min(bottom_data[i], Dtype(0))) - Dtype(1));
18    }
19  }
</pre></code></div>
                <div class="column column_space"><pre><code>27      filler.Fill(this->blob_bottom_data_j_);
28      blob_bottom_vec_.push_back(blob_bottom_data_j_);
29      for (int i = 0; i < blob_bottom_y_->count(); ++i) {
30        blob_bottom_y_->mutable_cpu_data()[i] = caffe_rng_rand() % 2;  
31      }
32      blob_bottom_vec_.push_back(blob_bottom_y_);
33      blob_top_vec_.push_back(blob_top_loss_);
34    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    