<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for face-system.cpp & forwarder.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for face-system.cpp & forwarder.cpp
      </h3>
      <h1 align="center">
        9.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>face-system.cpp (19.337017%)<TH>forwarder.cpp (6.6666665%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match448-0.html#0',2,'match448-1.html#0',3)" NAME="0">(92-104)<TD><A HREF="javascript:ZweiFrames('match448-0.html#0',2,'match448-1.html#0',3)" NAME="0">(605-617)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match448-0.html#1',2,'match448-1.html#1',3)" NAME="1">(111-119)<TD><A HREF="javascript:ZweiFrames('match448-0.html#1',2,'match448-1.html#1',3)" NAME="1">(620-628)</A><TD ALIGN=center><FONT COLOR="#f00000">17</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>face-system.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;face-system.hpp&quot;
#include &quot;protocol-factory.hpp&quot;
#include &quot;netdev-bound.hpp&quot;
#include &quot;common/global.hpp&quot;
#include &quot;fw/face-table.hpp&quot;

namespace nfd {
namespace face {

NFD_LOG_INIT(FaceSystem);

const std::string CFGSEC_FACESYSTEM = &quot;face_system&quot;;
const std::string CFGSEC_GENERAL = &quot;general&quot;;
const std::string CFGSEC_GENERAL_FQ = CFGSEC_FACESYSTEM + &quot;.general&quot;;
const std::string CFGSEC_NETDEVBOUND = &quot;netdev_bound&quot;;

FaceSystem::FaceSystem(FaceTable&amp; faceTable, shared_ptr&lt;ndn::net::NetworkMonitor&gt; netmon)
  : m_faceTable(faceTable)
  , m_netmon(std::move(netmon))
{
  auto pfCtorParams = this-&gt;makePFCtorParams();
  for (const auto&amp; id : ProtocolFactory::listRegistered()) {
    NFD_LOG_TRACE(&quot;creating factory &quot; &lt;&lt; id);
    m_factories[id] = ProtocolFactory::create(id, pfCtorParams);
  }

  m_netdevBound = make_unique&lt;NetdevBound&gt;(pfCtorParams, *this);
}

ProtocolFactoryCtorParams
FaceSystem::makePFCtorParams()
{
  auto addFace = [this] (auto face) { m_faceTable.add(std::move(face)); };
  return {addFace, m_netmon};
}

FaceSystem::~FaceSystem() = default;

std::set&lt;const ProtocolFactory*&gt;
FaceSystem::listProtocolFactories() const
{
  std::set&lt;const ProtocolFactory*&gt; factories;
  for (const auto&amp; p : m_factories) {
    factories.insert(p.second.get());
  }
  return factories;
}

ProtocolFactory*
FaceSystem::getFactoryById(const std::string&amp; id)
{
  auto found = m_factories.find(id);
  return found == m_factories.end() ? nullptr : found-&gt;second.get();
}

ProtocolFactory*
FaceSystem::getFactoryByScheme(const std::string&amp; scheme)
{
  auto found = m_factoryByScheme.find(scheme);
  return found == m_factoryByScheme.end() ? nullptr : found-&gt;second;
}

bool
<A NAME="0"></A>FaceSystem::hasFactoryForScheme(const std::string&amp; scheme) const
{
  return m_factoryByScheme.count(scheme) &gt; 0;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match448-1.html#0',3,'match448-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

void
FaceSystem::setConfigFile(ConfigFile&amp; configFile)
{
  configFile.addSectionHandler(CFGSEC_FACESYSTEM, [this] (auto&amp;&amp;... args) {
    processConfig(std::forward&lt;decltype(args)&gt;(args)...);
  });
}

void
FaceSystem::processConfig(const ConfigSection&amp; configSection, bool isDryRun, const std::string&amp;)
{</B></FONT>
  ConfigContext context;
  context.isDryRun = isDryRun;

<A NAME="1"></A>  // process general protocol factory config section
  auto generalSection = configSection.get_child_optional(CFGSEC_GENERAL);
  if (generalSection) {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match448-1.html#1',3,'match448-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    for (const auto&amp; pair : *generalSection) {
      const std::string&amp; key = pair.first;
      if (key == &quot;enable_congestion_marking&quot;) {
        context.generalConfig.wantCongestionMarking = ConfigFile::parseYesNo(pair, CFGSEC_GENERAL_FQ);
      }
      else {
        NDN_THROW(ConfigFile::Error(&quot;Unrecognized option &quot; + CFGSEC_GENERAL_FQ + &quot;.&quot; + key));
      }
    }</B></FONT>
  }

  // process in protocol factories
  for (const auto&amp; pair : m_factories) {
    const std::string&amp; sectionName = pair.first;
    ProtocolFactory* factory = pair.second.get();

    std::set&lt;std::string&gt; oldProvidedSchemes = factory-&gt;getProvidedSchemes();
    factory-&gt;processConfig(configSection.get_child_optional(sectionName), context);

    if (!isDryRun) {
      for (const std::string&amp; scheme : factory-&gt;getProvidedSchemes()) {
        m_factoryByScheme[scheme] = factory;
        if (oldProvidedSchemes.erase(scheme) == 0) {
          NFD_LOG_TRACE(&quot;factory &quot; &lt;&lt; sectionName &lt;&lt;
                        &quot; provides &quot; &lt;&lt; scheme &lt;&lt; &quot; FaceUri scheme&quot;);
        }
      }
      for (const std::string&amp; scheme : oldProvidedSchemes) {
        m_factoryByScheme.erase(scheme);
        NFD_LOG_TRACE(&quot;factory &quot; &lt;&lt; sectionName &lt;&lt;
                      &quot; no longer provides &quot; &lt;&lt; scheme &lt;&lt; &quot; FaceUri scheme&quot;);
      }
    }
  }

  // process netdev_bound section, after factories start providing *+dev schemes
  auto netdevBoundSection = configSection.get_child_optional(CFGSEC_NETDEVBOUND);
  m_netdevBound-&gt;processConfig(netdevBoundSection, context);

  // process other sections
  std::set&lt;std::string&gt; seenSections;
  for (const auto&amp; pair : configSection) {
    const std::string&amp; sectionName = pair.first;
    // const ConfigSection&amp; subSection = pair.second;

    if (!seenSections.insert(sectionName).second) {
      NDN_THROW(ConfigFile::Error(&quot;Duplicate section &quot; + CFGSEC_FACESYSTEM + &quot;.&quot; + sectionName));
    }

    if (sectionName == CFGSEC_GENERAL || sectionName == CFGSEC_NETDEVBOUND ||
        m_factories.count(sectionName) &gt; 0) {
      continue;
    }

    NDN_THROW(ConfigFile::Error(&quot;Unrecognized option &quot; + CFGSEC_FACESYSTEM + &quot;.&quot; + sectionName));
  }
}

} // namespace face
} // namespace nfd
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>forwarder.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;forwarder.hpp&quot;

#include &quot;algorithm.hpp&quot;
#include &quot;best-route-strategy.hpp&quot;
#include &quot;scope-prefix.hpp&quot;
#include &quot;strategy.hpp&quot;
#include &quot;common/global.hpp&quot;
#include &quot;common/logger.hpp&quot;
#include &quot;table/cleanup.hpp&quot;

#include &lt;ndn-cxx/lp/pit-token.hpp&gt;
#include &lt;ndn-cxx/lp/tags.hpp&gt;

namespace nfd {

NFD_LOG_INIT(Forwarder);

const std::string CFG_FORWARDER = &quot;forwarder&quot;;

static Name
getDefaultStrategyName()
{
  return fw::BestRouteStrategy::getStrategyName();
}

Forwarder::Forwarder(FaceTable&amp; faceTable)
  : m_faceTable(faceTable)
  , m_unsolicitedDataPolicy(make_unique&lt;fw::DefaultUnsolicitedDataPolicy&gt;())
  , m_fib(m_nameTree)
  , m_pit(m_nameTree)
  , m_measurements(m_nameTree)
  , m_strategyChoice(*this)
{
  m_faceTable.afterAdd.connect([this] (const Face&amp; face) {
    face.afterReceiveInterest.connect(
      [this, &amp;face] (const Interest&amp; interest, const EndpointId&amp; endpointId) {
        this-&gt;onIncomingInterest(interest, FaceEndpoint(const_cast&lt;Face&amp;&gt;(face), endpointId));
      });
    face.afterReceiveData.connect(
      [this, &amp;face] (const Data&amp; data, const EndpointId&amp; endpointId) {
        this-&gt;onIncomingData(data, FaceEndpoint(const_cast&lt;Face&amp;&gt;(face), endpointId));
      });
    face.afterReceiveNack.connect(
      [this, &amp;face] (const lp::Nack&amp; nack, const EndpointId&amp; endpointId) {
        this-&gt;onIncomingNack(nack, FaceEndpoint(const_cast&lt;Face&amp;&gt;(face), endpointId));
      });
    face.onDroppedInterest.connect(
      [this, &amp;face] (const Interest&amp; interest) {
        this-&gt;onDroppedInterest(interest, const_cast&lt;Face&amp;&gt;(face));
      });
  });

  m_faceTable.beforeRemove.connect([this] (const Face&amp; face) {
    cleanupOnFaceRemoval(m_nameTree, m_fib, m_pit, face);
  });

  m_fib.afterNewNextHop.connect([this] (const Name&amp; prefix, const fib::NextHop&amp; nextHop) {
    this-&gt;onNewNextHop(prefix, nextHop);
  });

  m_strategyChoice.setDefaultStrategy(getDefaultStrategyName());
}

Forwarder::~Forwarder() = default;

void
Forwarder::onIncomingInterest(const Interest&amp; interest, const FaceEndpoint&amp; ingress)
{
  // receive Interest
  NFD_LOG_DEBUG(&quot;onIncomingInterest in=&quot; &lt;&lt; ingress &lt;&lt; &quot; interest=&quot; &lt;&lt; interest.getName());
  interest.setTag(make_shared&lt;lp::IncomingFaceIdTag&gt;(ingress.face.getId()));
  ++m_counters.nInInterests;

  // drop if HopLimit zero, decrement otherwise (if present)
  if (interest.getHopLimit()) {
    if (*interest.getHopLimit() == 0) {
      NFD_LOG_DEBUG(&quot;onIncomingInterest in=&quot; &lt;&lt; ingress &lt;&lt; &quot; interest=&quot; &lt;&lt; interest.getName()
                    &lt;&lt; &quot; hop-limit=0&quot;);
      ++ingress.face.getCounters().nInHopLimitZero;
      // drop
      return;
    }
    const_cast&lt;Interest&amp;&gt;(interest).setHopLimit(*interest.getHopLimit() - 1);
  }

  // /localhost scope control
  bool isViolatingLocalhost = ingress.face.getScope() == ndn::nfd::FACE_SCOPE_NON_LOCAL &amp;&amp;
                              scope_prefix::LOCALHOST.isPrefixOf(interest.getName());
  if (isViolatingLocalhost) {
    NFD_LOG_DEBUG(&quot;onIncomingInterest in=&quot; &lt;&lt; ingress
                  &lt;&lt; &quot; interest=&quot; &lt;&lt; interest.getName() &lt;&lt; &quot; violates /localhost&quot;);
    // drop
    return;
  }

  // detect duplicate Nonce with Dead Nonce List
  bool hasDuplicateNonceInDnl = m_deadNonceList.has(interest.getName(), interest.getNonce());
  if (hasDuplicateNonceInDnl) {
    // goto Interest loop pipeline
    this-&gt;onInterestLoop(interest, ingress);
    return;
  }

  // strip forwarding hint if Interest has reached producer region
  if (!interest.getForwardingHint().empty() &amp;&amp;
      m_networkRegionTable.isInProducerRegion(interest.getForwardingHint())) {
    NFD_LOG_DEBUG(&quot;onIncomingInterest in=&quot; &lt;&lt; ingress
                  &lt;&lt; &quot; interest=&quot; &lt;&lt; interest.getName() &lt;&lt; &quot; reaching-producer-region&quot;);
    const_cast&lt;Interest&amp;&gt;(interest).setForwardingHint({});
  }

  // PIT insert
  shared_ptr&lt;pit::Entry&gt; pitEntry = m_pit.insert(interest).first;

  // detect duplicate Nonce in PIT entry
  int dnw = fw::findDuplicateNonce(*pitEntry, interest.getNonce(), ingress.face);
  bool hasDuplicateNonceInPit = dnw != fw::DUPLICATE_NONCE_NONE;
  if (ingress.face.getLinkType() == ndn::nfd::LINK_TYPE_POINT_TO_POINT) {
    // for p2p face: duplicate Nonce from same incoming face is not loop
    hasDuplicateNonceInPit = hasDuplicateNonceInPit &amp;&amp; !(dnw &amp; fw::DUPLICATE_NONCE_IN_SAME);
  }
  if (hasDuplicateNonceInPit) {
    // goto Interest loop pipeline
    this-&gt;onInterestLoop(interest, ingress);
    return;
  }

  // is pending?
  if (!pitEntry-&gt;hasInRecords()) {
    m_cs.find(interest,
              [=] (const Interest&amp; i, const Data&amp; d) { onContentStoreHit(i, ingress, pitEntry, d); },
              [=] (const Interest&amp; i) { onContentStoreMiss(i, ingress, pitEntry); });
  }
  else {
    this-&gt;onContentStoreMiss(interest, ingress, pitEntry);
  }
}

void
Forwarder::onInterestLoop(const Interest&amp; interest, const FaceEndpoint&amp; ingress)
{
  // if multi-access or ad hoc face, drop
  if (ingress.face.getLinkType() != ndn::nfd::LINK_TYPE_POINT_TO_POINT) {
    NFD_LOG_DEBUG(&quot;onInterestLoop in=&quot; &lt;&lt; ingress
                  &lt;&lt; &quot; interest=&quot; &lt;&lt; interest.getName() &lt;&lt; &quot; drop&quot;);
    return;
  }

  NFD_LOG_DEBUG(&quot;onInterestLoop in=&quot; &lt;&lt; ingress &lt;&lt; &quot; interest=&quot; &lt;&lt; interest.getName()
                &lt;&lt; &quot; send-Nack-duplicate&quot;);

  // send Nack with reason=DUPLICATE
  // note: Don't enter outgoing Nack pipeline because it needs an in-record.
  lp::Nack nack(interest);
  nack.setReason(lp::NackReason::DUPLICATE);
  ingress.face.sendNack(nack);
}

void
Forwarder::onContentStoreMiss(const Interest&amp; interest, const FaceEndpoint&amp; ingress,
                              const shared_ptr&lt;pit::Entry&gt;&amp; pitEntry)
{
  NFD_LOG_DEBUG(&quot;onContentStoreMiss interest=&quot; &lt;&lt; interest.getName());
  ++m_counters.nCsMisses;

  // attach HopLimit if configured and not present in Interest
  if (m_config.defaultHopLimit &gt; 0 &amp;&amp; !interest.getHopLimit()) {
    const_cast&lt;Interest&amp;&gt;(interest).setHopLimit(m_config.defaultHopLimit);
  }

  // insert in-record
  pitEntry-&gt;insertOrUpdateInRecord(ingress.face, interest);

  // set PIT expiry timer to the time that the last PIT in-record expires
  auto lastExpiring = std::max_element(pitEntry-&gt;in_begin(), pitEntry-&gt;in_end(),
                                       [] (const auto&amp; a, const auto&amp; b) {
                                         return a.getExpiry() &lt; b.getExpiry();
                                       });
  auto lastExpiryFromNow = lastExpiring-&gt;getExpiry() - time::steady_clock::now();
  this-&gt;setExpiryTimer(pitEntry, time::duration_cast&lt;time::milliseconds&gt;(lastExpiryFromNow));

  // has NextHopFaceId?
  auto nextHopTag = interest.getTag&lt;lp::NextHopFaceIdTag&gt;();
  if (nextHopTag != nullptr) {
    // chosen NextHop face exists?
    Face* nextHopFace = m_faceTable.get(*nextHopTag);
    if (nextHopFace != nullptr) {
      NFD_LOG_DEBUG(&quot;onContentStoreMiss interest=&quot; &lt;&lt; interest.getName()
                    &lt;&lt; &quot; nexthop-faceid=&quot; &lt;&lt; nextHopFace-&gt;getId());
      // go to outgoing Interest pipeline
      // scope control is unnecessary, because privileged app explicitly wants to forward
      this-&gt;onOutgoingInterest(interest, *nextHopFace, pitEntry);
    }
    return;
  }

  // dispatch to strategy: after receive Interest
  m_strategyChoice.findEffectiveStrategy(*pitEntry)
    .afterReceiveInterest(interest, FaceEndpoint(ingress.face, 0), pitEntry);
}

void
Forwarder::onContentStoreHit(const Interest&amp; interest, const FaceEndpoint&amp; ingress,
                             const shared_ptr&lt;pit::Entry&gt;&amp; pitEntry, const Data&amp; data)
{
  NFD_LOG_DEBUG(&quot;onContentStoreHit interest=&quot; &lt;&lt; interest.getName());
  ++m_counters.nCsHits;

  data.setTag(make_shared&lt;lp::IncomingFaceIdTag&gt;(face::FACEID_CONTENT_STORE));
  data.setTag(interest.getTag&lt;lp::PitToken&gt;());
  // FIXME Should we lookup PIT for other Interests that also match the data?

  pitEntry-&gt;isSatisfied = true;
  pitEntry-&gt;dataFreshnessPeriod = data.getFreshnessPeriod();

  // set PIT expiry timer to now
  this-&gt;setExpiryTimer(pitEntry, 0_ms);

  // dispatch to strategy: after Content Store hit
  m_strategyChoice.findEffectiveStrategy(*pitEntry).afterContentStoreHit(data, ingress, pitEntry);
}

pit::OutRecord*
Forwarder::onOutgoingInterest(const Interest&amp; interest, Face&amp; egress,
                              const shared_ptr&lt;pit::Entry&gt;&amp; pitEntry)
{
  // drop if HopLimit == 0 but sending on non-local face
  if (interest.getHopLimit() == 0 &amp;&amp; egress.getScope() == ndn::nfd::FACE_SCOPE_NON_LOCAL) {
    NFD_LOG_DEBUG(&quot;onOutgoingInterest out=&quot; &lt;&lt; egress.getId() &lt;&lt; &quot; interest=&quot; &lt;&lt; pitEntry-&gt;getName()
                  &lt;&lt; &quot; non-local hop-limit=0&quot;);
    ++egress.getCounters().nOutHopLimitZero;
    return nullptr;
  }

  NFD_LOG_DEBUG(&quot;onOutgoingInterest out=&quot; &lt;&lt; egress.getId() &lt;&lt; &quot; interest=&quot; &lt;&lt; pitEntry-&gt;getName());

  // insert out-record
  auto it = pitEntry-&gt;insertOrUpdateOutRecord(egress, interest);
  BOOST_ASSERT(it != pitEntry-&gt;out_end());

  // send Interest
  egress.sendInterest(interest);
  ++m_counters.nOutInterests;
  return &amp;*it;
}

void
Forwarder::onInterestFinalize(const shared_ptr&lt;pit::Entry&gt;&amp; pitEntry)
{
  NFD_LOG_DEBUG(&quot;onInterestFinalize interest=&quot; &lt;&lt; pitEntry-&gt;getName()
                &lt;&lt; (pitEntry-&gt;isSatisfied ? &quot; satisfied&quot; : &quot; unsatisfied&quot;));

  // Dead Nonce List insert if necessary
  this-&gt;insertDeadNonceList(*pitEntry, nullptr);

  // Increment satisfied/unsatisfied Interests counter
  if (pitEntry-&gt;isSatisfied) {
    ++m_counters.nSatisfiedInterests;
  }
  else {
    ++m_counters.nUnsatisfiedInterests;
  }

  // PIT delete
  pitEntry-&gt;expiryTimer.cancel();
  m_pit.erase(pitEntry.get());
}

void
Forwarder::onIncomingData(const Data&amp; data, const FaceEndpoint&amp; ingress)
{
  // receive Data
  NFD_LOG_DEBUG(&quot;onIncomingData in=&quot; &lt;&lt; ingress &lt;&lt; &quot; data=&quot; &lt;&lt; data.getName());
  data.setTag(make_shared&lt;lp::IncomingFaceIdTag&gt;(ingress.face.getId()));
  ++m_counters.nInData;

  // /localhost scope control
  bool isViolatingLocalhost = ingress.face.getScope() == ndn::nfd::FACE_SCOPE_NON_LOCAL &amp;&amp;
                              scope_prefix::LOCALHOST.isPrefixOf(data.getName());
  if (isViolatingLocalhost) {
    NFD_LOG_DEBUG(&quot;onIncomingData in=&quot; &lt;&lt; ingress &lt;&lt; &quot; data=&quot; &lt;&lt; data.getName() &lt;&lt; &quot; violates /localhost&quot;);
    // drop
    return;
  }

  // PIT match
  pit::DataMatchResult pitMatches = m_pit.findAllDataMatches(data);
  if (pitMatches.size() == 0) {
    // goto Data unsolicited pipeline
    this-&gt;onDataUnsolicited(data, ingress);
    return;
  }

  // CS insert
  m_cs.insert(data);

  // when only one PIT entry is matched, trigger strategy: after receive Data
  if (pitMatches.size() == 1) {
    auto&amp; pitEntry = pitMatches.front();

    NFD_LOG_DEBUG(&quot;onIncomingData matching=&quot; &lt;&lt; pitEntry-&gt;getName());

    // set PIT expiry timer to now
    this-&gt;setExpiryTimer(pitEntry, 0_ms);

    // trigger strategy: after receive Data
    m_strategyChoice.findEffectiveStrategy(*pitEntry).afterReceiveData(data, ingress, pitEntry);

    // mark PIT satisfied
    pitEntry-&gt;isSatisfied = true;
    pitEntry-&gt;dataFreshnessPeriod = data.getFreshnessPeriod();

    // Dead Nonce List insert if necessary (for out-record of ingress face)
    this-&gt;insertDeadNonceList(*pitEntry, &amp;ingress.face);

    // delete PIT entry's out-record
    pitEntry-&gt;deleteOutRecord(ingress.face);
  }
  // when more than one PIT entry is matched, trigger strategy: before satisfy Interest,
  // and send Data to all matched out faces
  else {
    std::set&lt;Face*&gt; pendingDownstreams;
    auto now = time::steady_clock::now();

    for (const auto&amp; pitEntry : pitMatches) {
      NFD_LOG_DEBUG(&quot;onIncomingData matching=&quot; &lt;&lt; pitEntry-&gt;getName());

      // remember pending downstreams
      for (const pit::InRecord&amp; inRecord : pitEntry-&gt;getInRecords()) {
        if (inRecord.getExpiry() &gt; now) {
          pendingDownstreams.insert(&amp;inRecord.getFace());
        }
      }

      // set PIT expiry timer to now
      this-&gt;setExpiryTimer(pitEntry, 0_ms);

      // invoke PIT satisfy callback
      m_strategyChoice.findEffectiveStrategy(*pitEntry).beforeSatisfyInterest(data, ingress, pitEntry);

      // mark PIT satisfied
      pitEntry-&gt;isSatisfied = true;
      pitEntry-&gt;dataFreshnessPeriod = data.getFreshnessPeriod();

      // Dead Nonce List insert if necessary (for out-record of ingress face)
      this-&gt;insertDeadNonceList(*pitEntry, &amp;ingress.face);

      // clear PIT entry's in and out records
      pitEntry-&gt;clearInRecords();
      pitEntry-&gt;deleteOutRecord(ingress.face);
    }

    // foreach pending downstream
    for (const auto&amp; pendingDownstream : pendingDownstreams) {
      if (pendingDownstream-&gt;getId() == ingress.face.getId() &amp;&amp;
          pendingDownstream-&gt;getLinkType() != ndn::nfd::LINK_TYPE_AD_HOC) {
        continue;
      }
      // goto outgoing Data pipeline
      this-&gt;onOutgoingData(data, *pendingDownstream);
    }
  }
}

void
Forwarder::onDataUnsolicited(const Data&amp; data, const FaceEndpoint&amp; ingress)
{
  // accept to cache?
  auto decision = m_unsolicitedDataPolicy-&gt;decide(ingress.face, data);
  if (decision == fw::UnsolicitedDataDecision::CACHE) {
    // CS insert
    m_cs.insert(data, true);
  }

  NFD_LOG_DEBUG(&quot;onDataUnsolicited in=&quot; &lt;&lt; ingress &lt;&lt; &quot; data=&quot; &lt;&lt; data.getName()
                &lt;&lt; &quot; decision=&quot; &lt;&lt; decision);
  ++m_counters.nUnsolicitedData;
}

bool
Forwarder::onOutgoingData(const Data&amp; data, Face&amp; egress)
{
  if (egress.getId() == face::INVALID_FACEID) {
    NFD_LOG_WARN(&quot;onOutgoingData out=(invalid) data=&quot; &lt;&lt; data.getName());
    return false;
  }
  NFD_LOG_DEBUG(&quot;onOutgoingData out=&quot; &lt;&lt; egress.getId() &lt;&lt; &quot; data=&quot; &lt;&lt; data.getName());

  // /localhost scope control
  bool isViolatingLocalhost = egress.getScope() == ndn::nfd::FACE_SCOPE_NON_LOCAL &amp;&amp;
                              scope_prefix::LOCALHOST.isPrefixOf(data.getName());
  if (isViolatingLocalhost) {
    NFD_LOG_DEBUG(&quot;onOutgoingData out=&quot; &lt;&lt; egress.getId() &lt;&lt; &quot; data=&quot; &lt;&lt; data.getName()
                  &lt;&lt; &quot; violates /localhost&quot;);
    // drop
    return false;
  }

  // TODO traffic manager

  // send Data
  egress.sendData(data);
  ++m_counters.nOutData;

  return true;
}

void
Forwarder::onIncomingNack(const lp::Nack&amp; nack, const FaceEndpoint&amp; ingress)
{
  // receive Nack
  nack.setTag(make_shared&lt;lp::IncomingFaceIdTag&gt;(ingress.face.getId()));
  ++m_counters.nInNacks;

  // if multi-access or ad hoc face, drop
  if (ingress.face.getLinkType() != ndn::nfd::LINK_TYPE_POINT_TO_POINT) {
    NFD_LOG_DEBUG(&quot;onIncomingNack in=&quot; &lt;&lt; ingress
                  &lt;&lt; &quot; nack=&quot; &lt;&lt; nack.getInterest().getName() &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason()
                  &lt;&lt; &quot; link-type=&quot; &lt;&lt; ingress.face.getLinkType());
    return;
  }

  // PIT match
  shared_ptr&lt;pit::Entry&gt; pitEntry = m_pit.find(nack.getInterest());
  // if no PIT entry found, drop
  if (pitEntry == nullptr) {
    NFD_LOG_DEBUG(&quot;onIncomingNack in=&quot; &lt;&lt; ingress &lt;&lt; &quot; nack=&quot; &lt;&lt; nack.getInterest().getName()
                  &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason() &lt;&lt; &quot; no-PIT-entry&quot;);
    return;
  }

  // has out-record?
  auto outRecord = pitEntry-&gt;getOutRecord(ingress.face);
  // if no out-record found, drop
  if (outRecord == pitEntry-&gt;out_end()) {
    NFD_LOG_DEBUG(&quot;onIncomingNack in=&quot; &lt;&lt; ingress &lt;&lt; &quot; nack=&quot; &lt;&lt; nack.getInterest().getName()
                  &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason() &lt;&lt; &quot; no-out-record&quot;);
    return;
  }

  // if out-record has different Nonce, drop
  if (nack.getInterest().getNonce() != outRecord-&gt;getLastNonce()) {
    NFD_LOG_DEBUG(&quot;onIncomingNack in=&quot; &lt;&lt; ingress &lt;&lt; &quot; nack=&quot; &lt;&lt; nack.getInterest().getName()
                  &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason() &lt;&lt; &quot; wrong-Nonce &quot; &lt;&lt; nack.getInterest().getNonce()
                  &lt;&lt; &quot;!=&quot; &lt;&lt; outRecord-&gt;getLastNonce());
    return;
  }

  NFD_LOG_DEBUG(&quot;onIncomingNack in=&quot; &lt;&lt; ingress &lt;&lt; &quot; nack=&quot; &lt;&lt; nack.getInterest().getName()
                &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason() &lt;&lt; &quot; OK&quot;);

  // record Nack on out-record
  outRecord-&gt;setIncomingNack(nack);

  // set PIT expiry timer to now when all out-record receive Nack
  if (!fw::hasPendingOutRecords(*pitEntry)) {
    this-&gt;setExpiryTimer(pitEntry, 0_ms);
  }

  // trigger strategy: after receive NACK
  m_strategyChoice.findEffectiveStrategy(*pitEntry).afterReceiveNack(nack, ingress, pitEntry);
}

bool
Forwarder::onOutgoingNack(const lp::NackHeader&amp; nack, Face&amp; egress,
                          const shared_ptr&lt;pit::Entry&gt;&amp; pitEntry)
{
  if (egress.getId() == face::INVALID_FACEID) {
    NFD_LOG_WARN(&quot;onOutgoingNack out=(invalid)&quot;
                 &lt;&lt; &quot; nack=&quot; &lt;&lt; pitEntry-&gt;getInterest().getName() &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason());
    return false;
  }

  // has in-record?
  auto inRecord = pitEntry-&gt;getInRecord(egress);

  // if no in-record found, drop
  if (inRecord == pitEntry-&gt;in_end()) {
    NFD_LOG_DEBUG(&quot;onOutgoingNack out=&quot; &lt;&lt; egress.getId()
                  &lt;&lt; &quot; nack=&quot; &lt;&lt; pitEntry-&gt;getInterest().getName()
                  &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason() &lt;&lt; &quot; no-in-record&quot;);
    return false;
  }

  // if multi-access or ad hoc face, drop
  if (egress.getLinkType() != ndn::nfd::LINK_TYPE_POINT_TO_POINT) {
    NFD_LOG_DEBUG(&quot;onOutgoingNack out=&quot; &lt;&lt; egress.getId()
                  &lt;&lt; &quot; nack=&quot; &lt;&lt; pitEntry-&gt;getInterest().getName() &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason()
                  &lt;&lt; &quot; link-type=&quot; &lt;&lt; egress.getLinkType());
    return false;
  }

  NFD_LOG_DEBUG(&quot;onOutgoingNack out=&quot; &lt;&lt; egress.getId()
                &lt;&lt; &quot; nack=&quot; &lt;&lt; pitEntry-&gt;getInterest().getName()
                &lt;&lt; &quot;~&quot; &lt;&lt; nack.getReason() &lt;&lt; &quot; OK&quot;);

  // create Nack packet with the Interest from in-record
  lp::Nack nackPkt(inRecord-&gt;getInterest());
  nackPkt.setHeader(nack);

  // erase in-record
  pitEntry-&gt;deleteInRecord(egress);

  // send Nack on face
  egress.sendNack(nackPkt);
  ++m_counters.nOutNacks;

  return true;
}

void
Forwarder::onDroppedInterest(const Interest&amp; interest, Face&amp; egress)
{
  m_strategyChoice.findEffectiveStrategy(interest.getName()).onDroppedInterest(interest, egress);
}

void
Forwarder::onNewNextHop(const Name&amp; prefix, const fib::NextHop&amp; nextHop)
{
  const auto affectedEntries = this-&gt;getNameTree().partialEnumerate(prefix,
    [&amp;] (const name_tree::Entry&amp; nte) -&gt; std::pair&lt;bool, bool&gt; {
      // we ignore an NTE and skip visiting its descendants if that NTE has an
      // associated FIB entry (1st condition), since in that case the new nexthop
      // won't affect any PIT entries anywhere in that subtree, *unless* this is
      // the initial NTE from which the enumeration started (2nd condition), which
      // must always be considered
      if (nte.getFibEntry() != nullptr &amp;&amp; nte.getName().size() &gt; prefix.size()) {
        return {false, false};
      }
      return {nte.hasPitEntries(), true};
    });

  for (const auto&amp; nte : affectedEntries) {
    for (const auto&amp; pitEntry : nte.getPitEntries()) {
      m_strategyChoice.findEffectiveStrategy(*pitEntry).afterNewNextHop(nextHop, pitEntry);
    }
  }
}

void
Forwarder::setExpiryTimer(const shared_ptr&lt;pit::Entry&gt;&amp; pitEntry, time::milliseconds duration)
{
  BOOST_ASSERT(pitEntry);
  duration = std::max(duration, 0_ms);

  pitEntry-&gt;expiryTimer.cancel();
  pitEntry-&gt;expiryTimer = getScheduler().schedule(duration, [=] { onInterestFinalize(pitEntry); });
}

void
Forwarder::insertDeadNonceList(pit::Entry&amp; pitEntry, const Face* upstream)
{
  // need Dead Nonce List insert?
  bool needDnl = true;
  if (pitEntry.isSatisfied) {
    BOOST_ASSERT(pitEntry.dataFreshnessPeriod &gt;= 0_ms);
    needDnl = pitEntry.getInterest().getMustBeFresh() &amp;&amp;
              pitEntry.dataFreshnessPeriod &lt; m_deadNonceList.getLifetime();
  }

  if (!needDnl) {
    return;
  }

  // Dead Nonce List insert
  if (upstream == nullptr) {
    // insert all outgoing Nonces
    const auto&amp; outRecords = pitEntry.getOutRecords();
    std::for_each(outRecords.begin(), outRecords.end(), [&amp;] (const auto&amp; outRecord) {
      m_deadNonceList.add(pitEntry.getName(), outRecord.getLastNonce());
    });
  }
  else {
    // insert outgoing Nonce of a specific face
    auto outRecord = pitEntry.getOutRecord(*upstream);
    if (outRecord != pitEntry.getOutRecords().end()) {
<A NAME="0"></A>      m_deadNonceList.add(pitEntry.getName(), outRecord-&gt;getLastNonce());
    }
  }
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match448-0.html#0',2,'match448-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

void
Forwarder::setConfigFile(ConfigFile&amp; configFile)
{
  configFile.addSectionHandler(CFG_FORWARDER, [this] (auto&amp;&amp;... args) {
    processConfig(std::forward&lt;decltype(args)&gt;(args)...);
  });
}

void
Forwarder::processConfig(const ConfigSection&amp; configSection, bool isDryRun, const std::string&amp;)
<A NAME="1"></A>{</B></FONT>
  Config config;

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match448-0.html#1',2,'match448-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  for (const auto&amp; pair : configSection) {
    const std::string&amp; key = pair.first;
    if (key == &quot;default_hop_limit&quot;) {
      config.defaultHopLimit = ConfigFile::parseNumber&lt;uint8_t&gt;(pair, CFG_FORWARDER);
    }
    else {
      NDN_THROW(ConfigFile::Error(&quot;Unrecognized option &quot; + CFG_FORWARDER + &quot;.&quot; + key));
    }
  }</B></FONT>

  if (!isDryRun) {
    m_config = config;
  }
}

} // namespace nfd
</PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
