<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for transmission_interface.h &amp; joint_limits_interface.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for transmission_interface.h &amp; joint_limits_interface.h
      </h3>
<h1 align="center">
        16.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>transmission_interface.h (20.521173%)<th>joint_limits_interface.h (13.375796%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(364-404)<td><a href="#" name="0">(524-555)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(405-426)<td><a href="#" name="1">(588-607)</a><td align="center"><font color="#eb0000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(70-90)<td><a href="#" name="2">(321-337)</a><td align="center"><font color="#7f0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>transmission_interface.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#pragma once
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;hardware_interface/internal/resource_manager.h&gt;
#include &lt;transmission_interface/transmission.h&gt;
#include &lt;transmission_interface/transmission_interface_exception.h&gt;
namespace transmission_interface
{
class TransmissionHandle
{
public:
  std::string getName() const {return name_;}
protected:
  std::string   name_;
  Transmission* transmission_;
  ActuatorData  actuator_data_;
  JointData     joint_data_;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  TransmissionHandle(const std::string&amp;  name,
                     Transmission*       transmission,
                     const ActuatorData&amp; actuator_data,
                     const JointData&amp;    joint_data)
    : name_(name),
      transmission_(transmission),
      actuator_data_(actuator_data),
      joint_data_(joint_data)
  {
    if (!transmission_)
    {
      throw TransmissionInterfaceException("Unspecified transmission.");
    }
    if (actuator_data.position.empty() &amp;&amp; actuator_data.velocity.empty() &amp;&amp; actuator_data.effort.empty() &amp;&amp;
        joint_data.position.empty() &amp;&amp; joint_data.velocity.empty() &amp;&amp; joint_data.effort.empty())
    {
      throw TransmissionInterfaceException("All data vectors are empty. Transmission instance can't do anything!.");
    }</b></font>
    if (!actuator_data.position.empty() &amp;&amp; actuator_data.position.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator position data size does not match transmission.");
    }
    if (!actuator_data.velocity.empty() &amp;&amp; actuator_data.velocity.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator velocity data size does not match transmission.");
    }
    if (!actuator_data.effort.empty() &amp;&amp; actuator_data.effort.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator effort data size does not match transmission.");
    }
    if (!actuator_data.absolute_position.empty() &amp;&amp; actuator_data.absolute_position.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator absolute position data size does not match transmission.");
    }
    if (!actuator_data.absolute_position.empty() &amp;&amp; actuator_data.absolute_position.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator torque sensor data size does not match transmission.");
    }
    if (!joint_data.position.empty() &amp;&amp; joint_data.position.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint position data size does not match transmission.");
    }
    if (!joint_data.velocity.empty() &amp;&amp; joint_data.velocity.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint velocity data size does not match transmission.");
    }
    if (!joint_data.effort.empty() &amp;&amp; joint_data.effort.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint effort data size does not match transmission.");
    }
    if (!joint_data.absolute_position.empty() &amp;&amp; joint_data.absolute_position.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint absolute position data size does not match transmission.");
    }
    if (!joint_data.torque_sensor.empty() &amp;&amp; joint_data.torque_sensor.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint torque sensor data size does not match transmission.");
    }
    if (!hasValidPointers(actuator_data.position))
    {
      throw TransmissionInterfaceException("Actuator position data contains null pointers.");
    }
    if (!hasValidPointers(actuator_data.velocity))
    {
      throw TransmissionInterfaceException("Actuator velocity data contains null pointers.");
    }
    if (!hasValidPointers(actuator_data.effort))
    {
      throw TransmissionInterfaceException("Actuator effort data contains null pointers.");
    }
    if (!actuator_data.absolute_position.empty() &amp;&amp; !hasValidPointers(actuator_data.absolute_position))
    {
      throw TransmissionInterfaceException("Actuator absolute position data contains null pointers.");
    }
    if (!actuator_data.torque_sensor.empty() &amp;&amp; !hasValidPointers(actuator_data.torque_sensor))
    {
      throw TransmissionInterfaceException("Actuator torque sensor data contains null pointers.");
    }
    if (!hasValidPointers(joint_data.position))
    {
      throw TransmissionInterfaceException("Joint position data contains null pointers.");
    }
    if (!hasValidPointers(joint_data.velocity))
    {
      throw TransmissionInterfaceException("Joint velocity data contains null pointers.");
    }
    if (!hasValidPointers(joint_data.effort))
    {
      throw TransmissionInterfaceException("Joint effort data contains null pointers.");
    }
    if (!joint_data.absolute_position.empty() &amp;&amp; !hasValidPointers(joint_data.absolute_position))
    {
      throw TransmissionInterfaceException("Joint absolute position data contains null pointers.");
    }
    if (!joint_data.torque_sensor.empty() &amp;&amp; !hasValidPointers(joint_data.torque_sensor))
    {
      throw TransmissionInterfaceException("Joint torque sensor data contains null pointers.");
    }
  }
private:
  static bool hasValidPointers(const std::vector&lt;double*&gt;&amp; data)
  {
    for (const auto&amp; ptr : data)
    {
      if (!ptr) {return false;}
    }
    return true;
  }
};
class ActuatorToJointStateHandle : public TransmissionHandle
{
public:
  ActuatorToJointStateHandle(const std::string&amp;  name,
                             Transmission*       transmission,
                             const ActuatorData&amp; actuator_data,
                             const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
  void propagate()
  {
    transmission_-&gt;actuatorToJointPosition(actuator_data_, joint_data_);
    transmission_-&gt;actuatorToJointVelocity(actuator_data_, joint_data_);
    transmission_-&gt;actuatorToJointEffort(actuator_data_, joint_data_);
    if(!actuator_data_.absolute_position.empty() &amp;&amp; transmission_-&gt;hasActuatorToJointAbsolutePosition())
    {
       transmission_-&gt;actuatorToJointAbsolutePosition(actuator_data_, joint_data_);
    }
    if(!actuator_data_.torque_sensor.empty() &amp;&amp; transmission_-&gt;hasActuatorToJointTorqueSensor())
    {
       transmission_-&gt;actuatorToJointTorqueSensor(actuator_data_, joint_data_);
    }
  }
};
class ActuatorToJointPositionHandle : public TransmissionHandle
{
public:
  ActuatorToJointPositionHandle(const std::string&amp;  name,
                                Transmission*       transmission,
                                const ActuatorData&amp; actuator_data,
                                const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
  void propagate() {transmission_-&gt;actuatorToJointPosition(actuator_data_, joint_data_);}
};
class ActuatorToJointVelocityHandle : public TransmissionHandle
{
public:
  ActuatorToJointVelocityHandle(const std::string&amp;  name,
                                Transmission*       transmission,
                                const ActuatorData&amp; actuator_data,
                                const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
  void propagate() {transmission_-&gt;actuatorToJointVelocity(actuator_data_, joint_data_);}
};
class ActuatorToJointEffortHandle : public TransmissionHandle
{
public:
  ActuatorToJointEffortHandle(const std::string&amp;  name,
                              Transmission*       transmission,
                              const ActuatorData&amp; actuator_data,
                              const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
  void propagate() {transmission_-&gt;actuatorToJointEffort(actuator_data_, joint_data_);}
};
class JointToActuatorStateHandle : public TransmissionHandle
{
public:
  JointToActuatorStateHandle(const std::string&amp;  name,
                             Transmission*       transmission,
                             const ActuatorData&amp; actuator_data,
                             const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
  void propagate()
  {
    transmission_-&gt;jointToActuatorPosition(joint_data_, actuator_data_);
    transmission_-&gt;jointToActuatorVelocity(joint_data_, actuator_data_);
    transmission_-&gt;jointToActuatorEffort(  joint_data_, actuator_data_);
  }
};
class JointToActuatorPositionHandle : public TransmissionHandle
{
public:
  JointToActuatorPositionHandle(const std::string&amp;  name,
                                Transmission*       transmission,
                                const ActuatorData&amp; actuator_data,
                                const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
  void propagate() {transmission_-&gt;jointToActuatorPosition(joint_data_, actuator_data_);}
};
class JointToActuatorVelocityHandle : public TransmissionHandle
{
public:
  JointToActuatorVelocityHandle(const std::string&amp;  name,
                                Transmission*       transmission,
                                const ActuatorData&amp; actuator_data,
                                const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
  void propagate() {transmission_-&gt;jointToActuatorVelocity(joint_data_, actuator_data_);}
};
class JointToActuatorEffortHandle : public TransmissionHandle
{
public:
  JointToActuatorEffortHandle(const std::string&amp;  name,
                              Transmission*       transmission,
                              const ActuatorData&amp; actuator_data,
                              const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
<a name="0"></a>    void propagate() {transmission_-&gt;jointToActuatorEffort(joint_data_, actuator_data_);}
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
template &lt;class HandleType&gt;
class TransmissionInterface : public hardware_interface::ResourceManager&lt;HandleType&gt;
{
public:
  HandleType getHandle(const std::string&amp; name)
  {
    try
    {
      return this-&gt;hardware_interface::ResourceManager&lt;HandleType&gt;::getHandle(name);
    }
    catch(const std::logic_error&amp; e)
    {
      throw TransmissionInterfaceException(e.what());
    }
  }
  void propagate()</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {
    for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
    {
      resource_name_and_handle.second.propagate();
    }
  }
};
class ActuatorToJointStateInterface : public TransmissionInterface&lt;ActuatorToJointStateHandle&gt; {};
class ActuatorToJointPositionInterface : public TransmissionInterface&lt;ActuatorToJointPositionHandle&gt; {};
class ActuatorToJointVelocityInterface : public TransmissionInterface&lt;ActuatorToJointVelocityHandle&gt; {};
class ActuatorToJointEffortInterface : public TransmissionInterface&lt;ActuatorToJointEffortHandle&gt; {};</b></font>
class JointToActuatorStateInterface : public TransmissionInterface&lt;JointToActuatorStateHandle&gt; {};
class JointToActuatorPositionInterface : public TransmissionInterface&lt;JointToActuatorPositionHandle&gt; {};
class JointToActuatorVelocityInterface : public TransmissionInterface&lt;JointToActuatorVelocityHandle&gt; {};
class JointToActuatorEffortInterface : public TransmissionInterface&lt;JointToActuatorEffortHandle&gt; {};
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>joint_limits_interface.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#pragma once
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;
#include &lt;ros/duration.h&gt;
#include &lt;hardware_interface/internal/resource_manager.h&gt;
#include &lt;hardware_interface/joint_command_interface.h&gt;
#include &lt;joint_limits_interface/joint_limits.h&gt;
#include &lt;joint_limits_interface/joint_limits_interface_exception.h&gt;
namespace joint_limits_interface
{
namespace internal
{
template&lt;typename T&gt;
T saturate(const T val, const T min_val, const T max_val)
{
  return std::min(std::max(val, min_val), max_val);
}
}
class PositionJointSaturationHandle
{
public:
  PositionJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
  : jh_(jh),
    limits_(limits)
  {
    if (limits_.has_position_limits)
    {
      min_pos_limit_ = limits_.min_position;
      max_pos_limit_ = limits_.max_position;
    }
    else
    {
      min_pos_limit_ = -std::numeric_limits&lt;double&gt;::max();
      max_pos_limit_ = std::numeric_limits&lt;double&gt;::max();
    }
  }
  std::string getName() const {return jh_.getName();}
  void enforceLimits(const ros::Duration&amp; period)
  {
    if (std::isnan(prev_cmd_))
      prev_cmd_ = jh_.getPosition();
    double min_pos, max_pos;
    if (limits_.has_velocity_limits)
    {
      const double delta_pos = limits_.max_velocity * period.toSec();
      min_pos = std::max(prev_cmd_ - delta_pos, min_pos_limit_);
      max_pos = std::min(prev_cmd_ + delta_pos, max_pos_limit_);
    }
    else
    {
      min_pos = min_pos_limit_;
      max_pos = max_pos_limit_;
    }
    const double cmd = internal::saturate(jh_.getCommand(), min_pos, max_pos);
    jh_.setCommand(cmd);
    prev_cmd_ = cmd;
  }
  void reset(){
    prev_cmd_ = std::numeric_limits&lt;double&gt;::quiet_NaN();
  }
private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
  double min_pos_limit_, max_pos_limit_;
  double prev_cmd_ = {std::numeric_limits&lt;double&gt;::quiet_NaN()};
};
class PositionJointSoftLimitsHandle
{
public:
  PositionJointSoftLimitsHandle() = default;
  PositionJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh,
                                const JointLimits&amp;                     limits,
                                const SoftJointLimits&amp;                 soft_limits)
    : jh_(jh),
      limits_(limits),
      soft_limits_(soft_limits)
  {
    if (!limits.has_velocity_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no velocity limits specification.");
    }
  }
  std::string getName() const {return jh_.getName();}
  void enforceLimits(const ros::Duration&amp; period)
  {
    assert(period.toSec() &gt; 0.0);
    using internal::saturate;
    if (std::isnan(prev_cmd_)) {prev_cmd_ = jh_.getPosition();}     const double pos = prev_cmd_;
    double soft_min_vel;
    double soft_max_vel;
    if (limits_.has_position_limits)
    {
      soft_min_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
                              -limits_.max_velocity,
                               limits_.max_velocity);
      soft_max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
                              -limits_.max_velocity,
                               limits_.max_velocity);
    }
    else
    {
      soft_min_vel = -limits_.max_velocity;
      soft_max_vel =  limits_.max_velocity;
    }
    const double dt = period.toSec();
    double pos_low  = pos + soft_min_vel * dt;
    double pos_high = pos + soft_max_vel * dt;
    if (limits_.has_position_limits)
    {
      pos_low  = std::max(pos_low,  limits_.min_position);
      pos_high = std::min(pos_high, limits_.max_position);
    }
    const double pos_cmd = saturate(jh_.getCommand(),
                                    pos_low,
                                    pos_high);
    jh_.setCommand(pos_cmd);
    prev_cmd_ = jh_.getCommand();
  }
  void reset(){
    prev_cmd_ = std::numeric_limits&lt;double&gt;::quiet_NaN();
  }
private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
  SoftJointLimits soft_limits_;
  double prev_cmd_ = {std::numeric_limits&lt;double&gt;::quiet_NaN()};
};
class EffortJointSaturationHandle
{
public:
  EffortJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
    : jh_(jh)
    , limits_(limits)
  {
    if (!limits.has_velocity_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no velocity limits specification.");
    }
    if (!limits.has_effort_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                          "'. It has no efforts limits specification.");
    }
  }
  std::string getName() const {return jh_.getName();}
  void enforceLimits(const ros::Duration&amp;   {
    double min_eff = -limits_.max_effort;
    double max_eff = limits_.max_effort;
    if (limits_.has_position_limits)
    {
      const double pos = jh_.getPosition();
      if (pos &lt; limits_.min_position)
        min_eff = 0.0;
      else if (pos &gt; limits_.max_position)
        max_eff = 0.0;
    }
    const double vel = jh_.getVelocity();
    if (vel &lt; -limits_.max_velocity)
      min_eff = 0.0;
    else if (vel &gt; limits_.max_velocity)
      max_eff = 0.0;
    jh_.setCommand(internal::saturate(jh_.getCommand(), min_eff, max_eff));
  }
private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
};
class EffortJointSoftLimitsHandle
{
<a name="2"></a>public:
  EffortJointSoftLimitsHandle() = default;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  EffortJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh,
                              const JointLimits&amp;                     limits,
                              const SoftJointLimits&amp;                 soft_limits)
  : jh_(jh),
    limits_(limits),
    soft_limits_(soft_limits)
  {
    if (!limits.has_velocity_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no velocity limits specification.");
    }
    if (!limits.has_effort_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no effort limits specification.");
    }</b></font>
  }
  std::string getName() const {return jh_.getName();}
  {
    using internal::saturate;
    const double pos = jh_.getPosition();
    const double vel = jh_.getVelocity();
    double soft_min_vel;
    double soft_max_vel;
    if (limits_.has_position_limits)
    {
      soft_min_vel  = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
                               -limits_.max_velocity,
                                limits_.max_velocity);
      soft_max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
                              -limits_.max_velocity,
                               limits_.max_velocity);
    }
    else
    {
      soft_min_vel = -limits_.max_velocity;
      soft_max_vel =  limits_.max_velocity;
    }
    const double soft_min_eff = saturate(-soft_limits_.k_velocity * (vel - soft_min_vel),
                                         -limits_.max_effort,
                                          limits_.max_effort);
    const double soft_max_eff = saturate(-soft_limits_.k_velocity * (vel - soft_max_vel),
                                         -limits_.max_effort,
                                          limits_.max_effort);
    const double eff_cmd = saturate(jh_.getCommand(),
                                    soft_min_eff,
                                    soft_max_eff);
    jh_.setCommand(eff_cmd);
  }
private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
  SoftJointLimits soft_limits_;
};
class VelocityJointSaturationHandle
{
public:
  VelocityJointSaturationHandle() = default;
  VelocityJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
    : jh_(jh)
    , limits_(limits)
  {
    if (!limits.has_velocity_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no velocity limits specification.");
    }
  }
  std::string getName() const {return jh_.getName();}
  void enforceLimits(const ros::Duration&amp; period)
  {
    using internal::saturate;
    double vel_low;
    double vel_high;
    if (limits_.has_acceleration_limits)
    {
      assert(period.toSec() &gt; 0.0);
      const double dt  = period.toSec();
      vel_low  = std::max(prev_cmd_ - limits_.max_acceleration * dt, -limits_.max_velocity);
      vel_high = std::min(prev_cmd_ + limits_.max_acceleration * dt,  limits_.max_velocity);
    }
    else
    {
      vel_low  = -limits_.max_velocity;
      vel_high =  limits_.max_velocity;
    }
    const double vel_cmd = saturate(jh_.getCommand(),
                                    vel_low,
                                    vel_high);
    jh_.setCommand(vel_cmd);
    prev_cmd_ = jh_.getCommand();
  }
private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
  double prev_cmd_ = {0.0};
};
class VelocityJointSoftLimitsHandle
{
public:
  VelocityJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits,
                                const SoftJointLimits&amp; soft_limits)
      : jh_(jh)
      , limits_(limits)
      , soft_limits_(soft_limits)
  {
    if (limits.has_velocity_limits)
      max_vel_limit_ = limits.max_velocity;
    else
      max_vel_limit_ = std::numeric_limits&lt;double&gt;::max();
  }
  std::string getName() const {return jh_.getName();}
  void enforceLimits(const ros::Duration&amp; period)
  {
    using internal::saturate;
    double min_vel, max_vel;
    if (limits_.has_position_limits)
    {
      const double pos = jh_.getPosition();
      min_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
                         -max_vel_limit_, max_vel_limit_);
      max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
                         -max_vel_limit_, max_vel_limit_);
    }
    else
    {
      min_vel = -max_vel_limit_;
      max_vel = max_vel_limit_;
    }
    if (limits_.has_acceleration_limits)
    {
      const double vel = jh_.getVelocity();
      const double delta_t = period.toSec();
      min_vel = std::max(vel - limits_.max_acceleration * delta_t, min_vel);
      max_vel = std::min(vel + limits_.max_acceleration * delta_t, max_vel);
    }
    jh_.setCommand(saturate(jh_.getCommand(), min_vel, max_vel));
  }
private:
  hardware_interface::JointHandle jh_;
<a name="0"></a>  JointLimits limits_;
  SoftJointLimits soft_limits_;
  double max_vel_limit_;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
template &lt;class HandleType&gt;
class JointLimitsInterface : public hardware_interface::ResourceManager&lt;HandleType&gt;
{
public:
  HandleType getHandle(const std::string&amp; name)
  {
    try
    {
      return this-&gt;hardware_interface::ResourceManager&lt;HandleType&gt;::getHandle(name);
    }
    catch(const std::logic_error&amp; e)
    {
      throw JointLimitsInterfaceException(e.what());
    }
  }
  void enforceLimits(const ros::Duration&amp; period)</b></font>
  {
    for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
    {
      resource_name_and_handle.second.enforceLimits(period);
    }
  }
};
class PositionJointSaturationInterface : public JointLimitsInterface&lt;PositionJointSaturationHandle&gt; {
public:
  void reset()
  {
    for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
    {
      resource_name_and_handle.second.reset();
    }
  }
};
class PositionJointSoftLimitsInterface : public JointLimitsInterface&lt;PositionJointSoftLimitsHandle&gt; {
public:
  void reset()
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  {
    for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
    {
      resource_name_and_handle.second.reset();
    }
  }
};
class EffortJointSaturationInterface : public JointLimitsInterface&lt;EffortJointSaturationHandle&gt; {};
class EffortJointSoftLimitsInterface : public JointLimitsInterface&lt;EffortJointSoftLimitsHandle&gt; {};
class VelocityJointSaturationInterface : public JointLimitsInterface&lt;VelocityJointSaturationHandle&gt; {};
class VelocityJointSoftLimitsInterface : public JointLimitsInterface&lt;VelocityJointSoftLimitsHandle&gt; {};</b></font>
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
