<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for transmission_interface.h &amp; joint_limits_interface.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for transmission_interface.h &amp; joint_limits_interface.h
      </h3>
<h1 align="center">
        16.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>transmission_interface.h (20.521173%)<th>joint_limits_interface.h (13.375796%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(364-404)<td><a href="#" name="0">(524-555)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(405-426)<td><a href="#" name="1">(588-607)</a><td align="center"><font color="#eb0000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(70-90)<td><a href="#" name="2">(321-337)</a><td align="center"><font color="#7f0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>transmission_interface.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013, PAL Robotics S.L.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//   * Neither the name of PAL Robotics S.L. nor the names of its
//     contributors may be used to endorse or promote products derived from
//     this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//////////////////////////////////////////////////////////////////////////////

/// \author Adolfo Rodriguez Tsouroukdissian

#pragma once


#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;hardware_interface/internal/resource_manager.h&gt;
#include &lt;transmission_interface/transmission.h&gt;
#include &lt;transmission_interface/transmission_interface_exception.h&gt;

namespace transmission_interface
{

/**
 * \brief Handle for propagating a single map (position, velocity, or effort) on a single transmission
 * (eg. actuator to joint effort for a simple reducer).
 */
class TransmissionHandle
{
public:
  /** \return Transmission name. */
  std::string getName() const {return name_;}

protected:
  std::string   name_;
  Transmission* transmission_;
  ActuatorData  actuator_data_;
  JointData     joint_data_;

  /**
   * \param name %Transmission name.
   * \param transmission Pointer to transmission instance.
   * \param actuator_data Actuator-space variables.
   * \param joint_data Joint-space variables.
   * \note The lifecycle of the pointed-to instances passed as parameters is not handled by this class.
   * \pre Valid transmission pointer. Actuator and joint variable vectors required by this handle must contain valid
<a name="2"></a>   * data and their size should be consistent with the number of transmission actuators and joints.
   * Data vectors not used by this handle can remain empty.
   */
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  TransmissionHandle(const std::string&amp;  name,
                     Transmission*       transmission,
                     const ActuatorData&amp; actuator_data,
                     const JointData&amp;    joint_data)
    : name_(name),
      transmission_(transmission),
      actuator_data_(actuator_data),
      joint_data_(joint_data)
  {
    // Precondition: Valid transmission
    if (!transmission_)
    {
      throw TransmissionInterfaceException("Unspecified transmission.");
    }

    // Catch trivial error: All data vectors are empty (handle can't do anything without data)
    if (actuator_data.position.empty() &amp;&amp; actuator_data.velocity.empty() &amp;&amp; actuator_data.effort.empty() &amp;&amp;
        joint_data.position.empty() &amp;&amp; joint_data.velocity.empty() &amp;&amp; joint_data.effort.empty())
    {
      throw TransmissionInterfaceException("All data vectors are empty. Transmission instance can't do anything!.");
    }</b></font>

    // Precondition: All non-empty data vectors must have sizes consistent with the transmission
    if (!actuator_data.position.empty() &amp;&amp; actuator_data.position.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator position data size does not match transmission.");
    }
    if (!actuator_data.velocity.empty() &amp;&amp; actuator_data.velocity.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator velocity data size does not match transmission.");
    }
    if (!actuator_data.effort.empty() &amp;&amp; actuator_data.effort.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator effort data size does not match transmission.");
    }
    if (!actuator_data.absolute_position.empty() &amp;&amp; actuator_data.absolute_position.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator absolute position data size does not match transmission.");
    }
    if (!actuator_data.absolute_position.empty() &amp;&amp; actuator_data.absolute_position.size() != transmission_-&gt;numActuators())
    {
      throw TransmissionInterfaceException("Actuator torque sensor data size does not match transmission.");
    }

    if (!joint_data.position.empty() &amp;&amp; joint_data.position.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint position data size does not match transmission.");
    }
    if (!joint_data.velocity.empty() &amp;&amp; joint_data.velocity.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint velocity data size does not match transmission.");
    }
    if (!joint_data.effort.empty() &amp;&amp; joint_data.effort.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint effort data size does not match transmission.");
    }
    if (!joint_data.absolute_position.empty() &amp;&amp; joint_data.absolute_position.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint absolute position data size does not match transmission.");
    }
    if (!joint_data.torque_sensor.empty() &amp;&amp; joint_data.torque_sensor.size() != transmission_-&gt;numJoints())
    {
      throw TransmissionInterfaceException("Joint torque sensor data size does not match transmission.");
    }

    // Precondition: Valid pointers to raw data
    if (!hasValidPointers(actuator_data.position))
    {
      throw TransmissionInterfaceException("Actuator position data contains null pointers.");
    }
    if (!hasValidPointers(actuator_data.velocity))
    {
      throw TransmissionInterfaceException("Actuator velocity data contains null pointers.");
    }
    if (!hasValidPointers(actuator_data.effort))
    {
      throw TransmissionInterfaceException("Actuator effort data contains null pointers.");
    }
    if (!actuator_data.absolute_position.empty() &amp;&amp; !hasValidPointers(actuator_data.absolute_position))
    {
      throw TransmissionInterfaceException("Actuator absolute position data contains null pointers.");
    }
    if (!actuator_data.torque_sensor.empty() &amp;&amp; !hasValidPointers(actuator_data.torque_sensor))
    {
      throw TransmissionInterfaceException("Actuator torque sensor data contains null pointers.");
    }

    if (!hasValidPointers(joint_data.position))
    {
      throw TransmissionInterfaceException("Joint position data contains null pointers.");
    }
    if (!hasValidPointers(joint_data.velocity))
    {
      throw TransmissionInterfaceException("Joint velocity data contains null pointers.");
    }
    if (!hasValidPointers(joint_data.effort))
    {
      throw TransmissionInterfaceException("Joint effort data contains null pointers.");
    }
    if (!joint_data.absolute_position.empty() &amp;&amp; !hasValidPointers(joint_data.absolute_position))
    {
      throw TransmissionInterfaceException("Joint absolute position data contains null pointers.");
    }
    if (!joint_data.torque_sensor.empty() &amp;&amp; !hasValidPointers(joint_data.torque_sensor))
    {
      throw TransmissionInterfaceException("Joint torque sensor data contains null pointers.");
    }

  }

private:
  static bool hasValidPointers(const std::vector&lt;double*&gt;&amp; data)
  {
    for (const auto&amp; ptr : data)
    {
      if (!ptr) {return false;}
    }
    return true;
  }
};

/**
 *\brief Handle for propagating actuator state (position, velocity and effort) to joint state for a given transmission.
 */
class ActuatorToJointStateHandle : public TransmissionHandle
{
public:
  /** \sa TransmissionHandle::TransmissionHandle */
  ActuatorToJointStateHandle(const std::string&amp;  name,
                             Transmission*       transmission,
                             const ActuatorData&amp; actuator_data,
                             const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}

  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Propagate actuator state to joint state for the stored transmission. */
  void propagate()
  {
    transmission_-&gt;actuatorToJointPosition(actuator_data_, joint_data_);
    transmission_-&gt;actuatorToJointVelocity(actuator_data_, joint_data_);
    transmission_-&gt;actuatorToJointEffort(actuator_data_, joint_data_);

    if(!actuator_data_.absolute_position.empty() &amp;&amp; transmission_-&gt;hasActuatorToJointAbsolutePosition())
    {
       transmission_-&gt;actuatorToJointAbsolutePosition(actuator_data_, joint_data_);
    }

    if(!actuator_data_.torque_sensor.empty() &amp;&amp; transmission_-&gt;hasActuatorToJointTorqueSensor())
    {
       transmission_-&gt;actuatorToJointTorqueSensor(actuator_data_, joint_data_);
    }
  }
  /*\}*/
};


/** \brief Handle for propagating actuator positions to joint positions for a given transmission. */
class ActuatorToJointPositionHandle : public TransmissionHandle
{
public:
  /** \sa TransmissionHandle::TransmissionHandle */
  ActuatorToJointPositionHandle(const std::string&amp;  name,
                                Transmission*       transmission,
                                const ActuatorData&amp; actuator_data,
                                const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}

  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Propagate actuator positions to joint positions for the stored transmission. */
  void propagate() {transmission_-&gt;actuatorToJointPosition(actuator_data_, joint_data_);}
  /*\}*/
};


/** \brief Handle for propagating actuator velocities to joint velocities for a given transmission. */
class ActuatorToJointVelocityHandle : public TransmissionHandle
{
public:
  /** \sa TransmissionHandle::TransmissionHandle */
  ActuatorToJointVelocityHandle(const std::string&amp;  name,
                                Transmission*       transmission,
                                const ActuatorData&amp; actuator_data,
                                const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}

  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Propagate actuator velocities to joint velocities for the stored transmission. */
  void propagate() {transmission_-&gt;actuatorToJointVelocity(actuator_data_, joint_data_);}
  /*\}*/
};


/** \brief Handle for propagating actuator efforts to joint efforts for a given transmission. */
class ActuatorToJointEffortHandle : public TransmissionHandle
{
public:
  /** \sa TransmissionHandle::TransmissionHandle */
  ActuatorToJointEffortHandle(const std::string&amp;  name,
                              Transmission*       transmission,
                              const ActuatorData&amp; actuator_data,
                              const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}

  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Propagate actuator efforts to joint efforts for the stored transmission. */
  void propagate() {transmission_-&gt;actuatorToJointEffort(actuator_data_, joint_data_);}
  /*\}*/
};


/**
 *\brief Handle for propagating joint state (position, velocity and effort) to actuator state for a given transmission.
 */
class JointToActuatorStateHandle : public TransmissionHandle
{
public:
  /** \sa TransmissionHandle::TransmissionHandle */
  JointToActuatorStateHandle(const std::string&amp;  name,
                             Transmission*       transmission,
                             const ActuatorData&amp; actuator_data,
                             const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}

  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Propagate joint state to actuator state for the stored transmission. */
  void propagate()
  {
    transmission_-&gt;jointToActuatorPosition(joint_data_, actuator_data_);
    transmission_-&gt;jointToActuatorVelocity(joint_data_, actuator_data_);
    transmission_-&gt;jointToActuatorEffort(  joint_data_, actuator_data_);
  }
  /*\}*/
};


/** \brief Handle for propagating joint positions to actuator positions for a given transmission. */
class JointToActuatorPositionHandle : public TransmissionHandle
{
public:
  /** \sa TransmissionHandle::TransmissionHandle */
  JointToActuatorPositionHandle(const std::string&amp;  name,
                                Transmission*       transmission,
                                const ActuatorData&amp; actuator_data,
                                const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}

  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Propagate joint positions to actuator positions for the stored transmission. */
  void propagate() {transmission_-&gt;jointToActuatorPosition(joint_data_, actuator_data_);}
  /*\}*/
};


/** \brief Handle for propagating joint velocities to actuator velocities for a given transmission. */
class JointToActuatorVelocityHandle : public TransmissionHandle
{
public:
  /** \sa TransmissionHandle::TransmissionHandle */
  JointToActuatorVelocityHandle(const std::string&amp;  name,
                                Transmission*       transmission,
                                const ActuatorData&amp; actuator_data,
                                const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}

  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Propagate joint velocities to actuator velocities for the stored transmission. */
  void propagate() {transmission_-&gt;jointToActuatorVelocity(joint_data_, actuator_data_);}
  /*\}*/
};


/** \brief Handle for propagating joint efforts to actuator efforts for a given transmission. */
class JointToActuatorEffortHandle : public TransmissionHandle
{
public:
  /** \sa TransmissionHandle::TransmissionHandle */
  JointToActuatorEffortHandle(const std::string&amp;  name,
                              Transmission*       transmission,
                              const ActuatorData&amp; actuator_data,
                              const JointData&amp;    joint_data)
    : TransmissionHandle(name, transmission, actuator_data, joint_data) {}

  /** \name Real-Time Safe Functions
   *\{*/
<a name="0"></a>  /** \brief Propagate joint efforts to actuator efforts for the stored transmission. */
  void propagate() {transmission_-&gt;jointToActuatorEffort(joint_data_, actuator_data_);}
  /*\}*/
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};

/**
 * \brief Interface for propagating a given map on a set of transmissions.
 *
 * This map can consist of a single variable (eg. actuator to joint efforts, as implemented by
 * \ref ActuatorToJointEffortHandle) or multiple variables (eg. joint to actuator position, velocity and effort, as
 * implemented by \ref JointToActuatorStateHandle).
 *
 * The set of transmissions handled by this interface can be heterogeneous, (eg. an arm with a four-bar-linkage in the
 * shoulder, a differential in the wrist, and simple reducers elsewhere).
 *
 * \tparam HandleType %Transmission handle type. Must implement the following methods:
 *  \code
 *   void propagate();
 *   std::string getName() const;
 *  \endcode
 */

template &lt;class HandleType&gt;
class TransmissionInterface : public hardware_interface::ResourceManager&lt;HandleType&gt;
{
public:

  HandleType getHandle(const std::string&amp; name)
  {
    // Rethrow exception with a meaningful type
    try
    {
      return this-&gt;hardware_interface::ResourceManager&lt;HandleType&gt;::getHandle(name);
    }
    catch(const std::logic_error&amp; e)
    {
      throw TransmissionInterfaceException(e.what());
    }
  }

  /** \name Real-Time Safe Functions
<a name="1"></a>   *\{*/
  /** \brief Propagate the transmission maps of all managed handles. */
  void propagate()</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {
    for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
    {
      resource_name_and_handle.second.propagate();
    }
  }
  /*\}*/
};

// Convenience typedefs

/** Interface for propagating actuator state (position, velocity and effort) to joint state on a set of transmissions. */
class ActuatorToJointStateInterface : public TransmissionInterface&lt;ActuatorToJointStateHandle&gt; {};

/** Interface for propagating actuator positions to joint positions on a set of transmissions. */
class ActuatorToJointPositionInterface : public TransmissionInterface&lt;ActuatorToJointPositionHandle&gt; {};

/** Interface for propagating actuator velocities to joint velocities on a set of transmissions. */
class ActuatorToJointVelocityInterface : public TransmissionInterface&lt;ActuatorToJointVelocityHandle&gt; {};

/** Interface for propagating actuator efforts to joint efforts on a set of transmissions. */
class ActuatorToJointEffortInterface : public TransmissionInterface&lt;ActuatorToJointEffortHandle&gt; {};</b></font>

/** Interface for propagating joint state (position, velocity and effort) to actuator state on a set of transmissions. */
class JointToActuatorStateInterface : public TransmissionInterface&lt;JointToActuatorStateHandle&gt; {};

/** Interface for propagating joint positions to actuator positions on a set of transmissions. */
class JointToActuatorPositionInterface : public TransmissionInterface&lt;JointToActuatorPositionHandle&gt; {};

/** Interface for propagating joint velocities to actuator velocities on a set of transmissions. */
class JointToActuatorVelocityInterface : public TransmissionInterface&lt;JointToActuatorVelocityHandle&gt; {};

/** Interface for propagating joint efforts to actuator efforts on a set of transmissions. */
class JointToActuatorEffortInterface : public TransmissionInterface&lt;JointToActuatorEffortHandle&gt; {};

} // transmission_interface
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>joint_limits_interface.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013, PAL Robotics S.L.
// Copyright (c) 2008, Willow Garage, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//   * Neither the name of PAL Robotics S.L. nor the names of its
//     contributors may be used to endorse or promote products derived from
//     this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//////////////////////////////////////////////////////////////////////////////

/// \author Adolfo Rodriguez Tsouroukdissian

#pragma once


#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;

#include &lt;ros/duration.h&gt;

#include &lt;hardware_interface/internal/resource_manager.h&gt;
#include &lt;hardware_interface/joint_command_interface.h&gt;

#include &lt;joint_limits_interface/joint_limits.h&gt;
#include &lt;joint_limits_interface/joint_limits_interface_exception.h&gt;

namespace joint_limits_interface
{

namespace internal
{

template&lt;typename T&gt;
T saturate(const T val, const T min_val, const T max_val)
{
  return std::min(std::max(val, min_val), max_val);
}

}

/** \brief A handle used to enforce position and velocity limits of a position-controlled joint that does not have
    soft limits. */
class PositionJointSaturationHandle
{
public:
  PositionJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
  : jh_(jh),
    limits_(limits)
  {

    if (limits_.has_position_limits)
    {
      min_pos_limit_ = limits_.min_position;
      max_pos_limit_ = limits_.max_position;
    }
    else
    {
      min_pos_limit_ = -std::numeric_limits&lt;double&gt;::max();
      max_pos_limit_ = std::numeric_limits&lt;double&gt;::max();
    }
  }

  /** \return Joint name. */
  std::string getName() const {return jh_.getName();}

  /**
   * \brief Enforce position and velocity limits for a joint that is not subject to soft limits.
   *
   * \param period Control period.
   */
  void enforceLimits(const ros::Duration&amp; period)
  {
    if (std::isnan(prev_cmd_))
      prev_cmd_ = jh_.getPosition();

    double min_pos, max_pos;
    if (limits_.has_velocity_limits)
    {
      const double delta_pos = limits_.max_velocity * period.toSec();
      min_pos = std::max(prev_cmd_ - delta_pos, min_pos_limit_);
      max_pos = std::min(prev_cmd_ + delta_pos, max_pos_limit_);
    }
    else
    {
      min_pos = min_pos_limit_;
      max_pos = max_pos_limit_;
    }

    const double cmd = internal::saturate(jh_.getCommand(), min_pos, max_pos);
    jh_.setCommand(cmd);
    prev_cmd_ = cmd;
  }

  /**
   * \brief Reset state, in case of mode switch or e-stop
   */
  void reset(){
    prev_cmd_ = std::numeric_limits&lt;double&gt;::quiet_NaN();
  }

private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
  double min_pos_limit_, max_pos_limit_;

  double prev_cmd_ = {std::numeric_limits&lt;double&gt;::quiet_NaN()};
};

/**
 * \brief A handle used to enforce position and velocity limits of a position-controlled joint.
 *
 * This class implements a very simple position and velocity limits enforcing policy, and tries to impose the least
 * amount of requisites on the underlying hardware platform.
 * This lowers considerably the entry barrier to use it, but also implies some limitations.
 *
 * &lt;b&gt;Requisites&lt;/b&gt;
 * - Position (for non-continuous joints) and velocity limits specification.
 * - Soft limits specification. The \c k_velocity parameter is \e not used.
 *
 * &lt;b&gt;Open loop nature&lt;/b&gt;
 *
 * Joint position and velocity limits are enforced in an open-loop fashion, that is, the command is checked for
 * validity without relying on the actual position/velocity values.
 *
 * - Actual position values are \e not used because in some platforms there might be a substantial lag
 *   between sending a command and executing it (propagate command to hardware, reach control objective,
 *   read from hardware).
 *
 * - Actual velocity values are \e not used because of the above reason, and because some platforms might not expose
 *   trustworthy velocity measurements, or none at all.
 *
 * The downside of the open loop behavior is that velocity limits will not be enforced when recovering from large
 * position tracking errors. Only the command is guaranteed to comply with the limits specification.
 *
 * \note: This handle type is \e stateful, ie. it stores the previous position command to estimate the command
 * velocity.
 */

// TODO: Leverage %Reflexxes Type II library for acceleration limits handling?
class PositionJointSoftLimitsHandle
{
public:
  PositionJointSoftLimitsHandle() = default;

  PositionJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh,
                                const JointLimits&amp;                     limits,
                                const SoftJointLimits&amp;                 soft_limits)
    : jh_(jh),
      limits_(limits),
      soft_limits_(soft_limits)
  {
    if (!limits.has_velocity_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no velocity limits specification.");
    }
  }

  /** \return Joint name. */
  std::string getName() const {return jh_.getName();}

  /**
   * \brief Enforce position and velocity limits for a joint subject to soft limits.
   *
   * If the joint has no position limits (eg. a continuous joint), only velocity limits will be enforced.
   * \param period Control period.
   */
  void enforceLimits(const ros::Duration&amp; period)
  {
    assert(period.toSec() &gt; 0.0);

    using internal::saturate;

    // Current position
    // TODO: Doc!
    if (std::isnan(prev_cmd_)) {prev_cmd_ = jh_.getPosition();} // Happens only once at initialization
    const double pos = prev_cmd_;

    // Velocity bounds
    double soft_min_vel;
    double soft_max_vel;

    if (limits_.has_position_limits)
    {
      // Velocity bounds depend on the velocity limit and the proximity to the position limit
      soft_min_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
                              -limits_.max_velocity,
                               limits_.max_velocity);

      soft_max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
                              -limits_.max_velocity,
                               limits_.max_velocity);
    }
    else
    {
      // No position limits, eg. continuous joints
      soft_min_vel = -limits_.max_velocity;
      soft_max_vel =  limits_.max_velocity;
    }

    // Position bounds
    const double dt = period.toSec();
    double pos_low  = pos + soft_min_vel * dt;
    double pos_high = pos + soft_max_vel * dt;

    if (limits_.has_position_limits)
    {
      // This extra measure safeguards against pathological cases, like when the soft limit lies beyond the hard limit
      pos_low  = std::max(pos_low,  limits_.min_position);
      pos_high = std::min(pos_high, limits_.max_position);
    }

    // Saturate position command according to bounds
    const double pos_cmd = saturate(jh_.getCommand(),
                                    pos_low,
                                    pos_high);
    jh_.setCommand(pos_cmd);

    // Cache variables
    prev_cmd_ = jh_.getCommand();
  }

  /**
   * \brief Reset state, in case of mode switch or e-stop
   */
  void reset(){
    prev_cmd_ = std::numeric_limits&lt;double&gt;::quiet_NaN();
  }

private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
  SoftJointLimits soft_limits_;

  double prev_cmd_ = {std::numeric_limits&lt;double&gt;::quiet_NaN()};
};

/** \brief A handle used to enforce position, velocity, and effort limits of an effort-controlled joint that does not
    have soft limits. */
class EffortJointSaturationHandle
{
public:
  EffortJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
    : jh_(jh)
    , limits_(limits)
  {
    if (!limits.has_velocity_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no velocity limits specification.");
    }
    if (!limits.has_effort_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                          "'. It has no efforts limits specification.");
    }
  }

  /** \return Joint name. */
  std::string getName() const {return jh_.getName();}

  /**
   * \brief Enforce position, velocity, and effort limits for a joint that is not subject to soft limits.
   */
  void enforceLimits(const ros::Duration&amp; /* period */)
  {
    double min_eff = -limits_.max_effort;
    double max_eff = limits_.max_effort;

    if (limits_.has_position_limits)
    {
      const double pos = jh_.getPosition();
      if (pos &lt; limits_.min_position)
        min_eff = 0.0;
      else if (pos &gt; limits_.max_position)
        max_eff = 0.0;
    }

    const double vel = jh_.getVelocity();
    if (vel &lt; -limits_.max_velocity)
      min_eff = 0.0;
    else if (vel &gt; limits_.max_velocity)
      max_eff = 0.0;

    jh_.setCommand(internal::saturate(jh_.getCommand(), min_eff, max_eff));
  }

private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
};

/** \brief A handle used to enforce position, velocity and effort limits of an effort-controlled joint. */

// TODO: This class is untested!. Update unit tests accordingly.
class EffortJointSoftLimitsHandle
{
<a name="2"></a>public:
  EffortJointSoftLimitsHandle() = default;

<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  EffortJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh,
                              const JointLimits&amp;                     limits,
                              const SoftJointLimits&amp;                 soft_limits)
  : jh_(jh),
    limits_(limits),
    soft_limits_(soft_limits)
  {
    if (!limits.has_velocity_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no velocity limits specification.");
    }
    if (!limits.has_effort_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no effort limits specification.");
    }</b></font>
  }

  /** \return Joint name. */
  std::string getName() const {return jh_.getName();}

  /**
   * \brief Enforce position, velocity and effort limits for a joint subject to soft limits.
   *
   * If the joint has no position limits (eg. a continuous joint), only velocity and effort limits will be enforced.
   */
  void enforceLimits(const ros::Duration&amp; /*period*/)
  {
    using internal::saturate;

    // Current state
    const double pos = jh_.getPosition();
    const double vel = jh_.getVelocity();

    // Velocity bounds
    double soft_min_vel;
    double soft_max_vel;

    if (limits_.has_position_limits)
    {
      // Velocity bounds depend on the velocity limit and the proximity to the position limit
      soft_min_vel  = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
                               -limits_.max_velocity,
                                limits_.max_velocity);

      soft_max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
                              -limits_.max_velocity,
                               limits_.max_velocity);
    }
    else
    {
      // No position limits, eg. continuous joints
      soft_min_vel = -limits_.max_velocity;
      soft_max_vel =  limits_.max_velocity;
    }

    // Effort bounds depend on the velocity and effort bounds
    const double soft_min_eff = saturate(-soft_limits_.k_velocity * (vel - soft_min_vel),
                                         -limits_.max_effort,
                                          limits_.max_effort);

    const double soft_max_eff = saturate(-soft_limits_.k_velocity * (vel - soft_max_vel),
                                         -limits_.max_effort,
                                          limits_.max_effort);

    // Saturate effort command according to bounds
    const double eff_cmd = saturate(jh_.getCommand(),
                                    soft_min_eff,
                                    soft_max_eff);
    jh_.setCommand(eff_cmd);
  }

private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;
  SoftJointLimits soft_limits_;
};


/** \brief A handle used to enforce velocity and acceleration limits of a velocity-controlled joint. */
class VelocityJointSaturationHandle
{
public:
  VelocityJointSaturationHandle() = default;

  VelocityJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
    : jh_(jh)
    , limits_(limits)
  {
    if (!limits.has_velocity_limits)
    {
      throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
                                           "'. It has no velocity limits specification.");
    }
  }

  /** \return Joint name. */
  std::string getName() const {return jh_.getName();}

  /**
   * \brief Enforce joint velocity and acceleration limits.
   * \param period Control period.
   */
  void enforceLimits(const ros::Duration&amp; period)
  {
    using internal::saturate;

    // Velocity bounds
    double vel_low;
    double vel_high;

    if (limits_.has_acceleration_limits)
    {
      assert(period.toSec() &gt; 0.0);
      const double dt  = period.toSec();

      vel_low  = std::max(prev_cmd_ - limits_.max_acceleration * dt, -limits_.max_velocity);
      vel_high = std::min(prev_cmd_ + limits_.max_acceleration * dt,  limits_.max_velocity);
    }
    else
    {
      vel_low  = -limits_.max_velocity;
      vel_high =  limits_.max_velocity;
    }

    // Saturate velocity command according to limits
    const double vel_cmd = saturate(jh_.getCommand(),
                                    vel_low,
                                    vel_high);
    jh_.setCommand(vel_cmd);

    // Cache variables
    prev_cmd_ = jh_.getCommand();
  }

private:
  hardware_interface::JointHandle jh_;
  JointLimits limits_;

  double prev_cmd_ = {0.0};
};

/** \brief A handle used to enforce position, velocity, and acceleration limits of a velocity-controlled joint. */
class VelocityJointSoftLimitsHandle
{
public:
  VelocityJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits,
                                const SoftJointLimits&amp; soft_limits)
      : jh_(jh)
      , limits_(limits)
      , soft_limits_(soft_limits)
  {
    if (limits.has_velocity_limits)
      max_vel_limit_ = limits.max_velocity;
    else
      max_vel_limit_ = std::numeric_limits&lt;double&gt;::max();
  }

  /** \return Joint name. */
  std::string getName() const {return jh_.getName();}

  /**
   * \brief Enforce position, velocity, and acceleration limits for a velocity-controlled joint subject to soft limits.
   *
   * \param period Control period.
   */
  void enforceLimits(const ros::Duration&amp; period)
  {
    using internal::saturate;

    double min_vel, max_vel;
    if (limits_.has_position_limits)
    {
      // Velocity bounds depend on the velocity limit and the proximity to the position limit.
      const double pos = jh_.getPosition();
      min_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
                         -max_vel_limit_, max_vel_limit_);
      max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
                         -max_vel_limit_, max_vel_limit_);
    }
    else
    {
      min_vel = -max_vel_limit_;
      max_vel = max_vel_limit_;
    }

    if (limits_.has_acceleration_limits)
    {
      const double vel = jh_.getVelocity();
      const double delta_t = period.toSec();
      min_vel = std::max(vel - limits_.max_acceleration * delta_t, min_vel);
      max_vel = std::min(vel + limits_.max_acceleration * delta_t, max_vel);
    }

    jh_.setCommand(saturate(jh_.getCommand(), min_vel, max_vel));
  }

private:
  hardware_interface::JointHandle jh_;
<a name="0"></a>  JointLimits limits_;
  SoftJointLimits soft_limits_;
  double max_vel_limit_;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};

/**
 * \brief Interface for enforcing joint limits.
 *
 * \tparam HandleType %Handle type. Must implement the following methods:
 *  \code
 *   void enforceLimits();
 *   std::string getName() const;
 *  \endcode
 */
template &lt;class HandleType&gt;
class JointLimitsInterface : public hardware_interface::ResourceManager&lt;HandleType&gt;
{
public:
  HandleType getHandle(const std::string&amp; name)
  {
    // Rethrow exception with a meaningful type
    try
    {
      return this-&gt;hardware_interface::ResourceManager&lt;HandleType&gt;::getHandle(name);
    }
    catch(const std::logic_error&amp; e)
    {
      throw JointLimitsInterfaceException(e.what());
    }
  }

  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Enforce limits for all managed handles. */
  void enforceLimits(const ros::Duration&amp; period)</b></font>
  {
    for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
    {
      resource_name_and_handle.second.enforceLimits(period);
    }
  }
  /*\}*/
};

/** Interface for enforcing limits on a position-controlled joint through saturation. */
class PositionJointSaturationInterface : public JointLimitsInterface&lt;PositionJointSaturationHandle&gt; {
public:
  /** \name Real-Time Safe Functions
   *\{*/
  /** \brief Reset all managed handles. */
  void reset()
  {
    for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
    {
      resource_name_and_handle.second.reset();
    }
  }
  /*\}*/
};

/** Interface for enforcing limits on a position-controlled joint with soft position limits. */
class PositionJointSoftLimitsInterface : public JointLimitsInterface&lt;PositionJointSoftLimitsHandle&gt; {
public:
  /** \name Real-Time Safe Functions
<a name="1"></a>   *\{*/
  /** \brief Reset all managed handles. */
  void reset()
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  {
    for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
    {
      resource_name_and_handle.second.reset();
    }
  }
  /*\}*/
};

/** Interface for enforcing limits on an effort-controlled joint through saturation. */
class EffortJointSaturationInterface : public JointLimitsInterface&lt;EffortJointSaturationHandle&gt; {};

/** Interface for enforcing limits on an effort-controlled joint with soft position limits. */
class EffortJointSoftLimitsInterface : public JointLimitsInterface&lt;EffortJointSoftLimitsHandle&gt; {};

/** Interface for enforcing limits on a velocity-controlled joint through saturation. */
class VelocityJointSaturationInterface : public JointLimitsInterface&lt;VelocityJointSaturationHandle&gt; {};

/** Interface for enforcing limits on a velocity-controlled joint with soft position limits. */
class VelocityJointSoftLimitsInterface : public JointLimitsInterface&lt;VelocityJointSoftLimitsHandle&gt; {};</b></font>

}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
