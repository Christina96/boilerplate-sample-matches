<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for transmission_interface.h &amp; joint_limits_interface.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for transmission_interface.h &amp; joint_limits_interface.h
      </h3>
<h1 align="center">
        16.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>transmission_interface.h (20.521173%)<th>joint_limits_interface.h (13.375796%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(364-404)<td><a href="#" name="0">(524-555)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(405-426)<td><a href="#" name="1">(588-607)</a><td align="center"><font color="#eb0000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(70-90)<td><a href="#" name="2">(321-337)</a><td align="center"><font color="#7f0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>transmission_interface.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include &lt;map&gt;
3 #include &lt;string&gt;
4 #include &lt;vector&gt;
5 #include &lt;hardware_interface/internal/resource_manager.h&gt;
6 #include &lt;transmission_interface/transmission.h&gt;
7 #include &lt;transmission_interface/transmission_interface_exception.h&gt;
8 namespace transmission_interface
9 {
10 class TransmissionHandle
11 {
12 public:
13   std::string getName() const {return name_;}
14 protected:
15   std::string   name_;
16   Transmission* transmission_;
17   ActuatorData  actuator_data_;
18   JointData     joint_data_;
19 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  TransmissionHandle(const std::string&amp;  name,
20                      Transmission*       transmission,
21                      const ActuatorData&amp; actuator_data,
22                      const JointData&amp;    joint_data)
23     : name_(name),
24       transmission_(transmission),
25       actuator_data_(actuator_data),
26       joint_data_(joint_data)
27   {
28     if (!transmission_)
29     {
30       throw TransmissionInterfaceException("Unspecified transmission.");
31     }
32     if (actuator_data.position.empty() &amp;&amp; actuator_data.velocity.empty() &amp;&amp; actuator_data.effort.empty() &amp;&amp;
33         joint_data.position.empty() &amp;&amp; joint_data.velocity.empty() &amp;&amp; joint_data.effort.empty())
34     {
35       throw TransmissionInterfaceException("All data vectors are empty. Transmission instance can't do anything!.");
36     }</b></font>
37     if (!actuator_data.position.empty() &amp;&amp; actuator_data.position.size() != transmission_-&gt;numActuators())
38     {
39       throw TransmissionInterfaceException("Actuator position data size does not match transmission.");
40     }
41     if (!actuator_data.velocity.empty() &amp;&amp; actuator_data.velocity.size() != transmission_-&gt;numActuators())
42     {
43       throw TransmissionInterfaceException("Actuator velocity data size does not match transmission.");
44     }
45     if (!actuator_data.effort.empty() &amp;&amp; actuator_data.effort.size() != transmission_-&gt;numActuators())
46     {
47       throw TransmissionInterfaceException("Actuator effort data size does not match transmission.");
48     }
49     if (!actuator_data.absolute_position.empty() &amp;&amp; actuator_data.absolute_position.size() != transmission_-&gt;numActuators())
50     {
51       throw TransmissionInterfaceException("Actuator absolute position data size does not match transmission.");
52     }
53     if (!actuator_data.absolute_position.empty() &amp;&amp; actuator_data.absolute_position.size() != transmission_-&gt;numActuators())
54     {
55       throw TransmissionInterfaceException("Actuator torque sensor data size does not match transmission.");
56     }
57     if (!joint_data.position.empty() &amp;&amp; joint_data.position.size() != transmission_-&gt;numJoints())
58     {
59       throw TransmissionInterfaceException("Joint position data size does not match transmission.");
60     }
61     if (!joint_data.velocity.empty() &amp;&amp; joint_data.velocity.size() != transmission_-&gt;numJoints())
62     {
63       throw TransmissionInterfaceException("Joint velocity data size does not match transmission.");
64     }
65     if (!joint_data.effort.empty() &amp;&amp; joint_data.effort.size() != transmission_-&gt;numJoints())
66     {
67       throw TransmissionInterfaceException("Joint effort data size does not match transmission.");
68     }
69     if (!joint_data.absolute_position.empty() &amp;&amp; joint_data.absolute_position.size() != transmission_-&gt;numJoints())
70     {
71       throw TransmissionInterfaceException("Joint absolute position data size does not match transmission.");
72     }
73     if (!joint_data.torque_sensor.empty() &amp;&amp; joint_data.torque_sensor.size() != transmission_-&gt;numJoints())
74     {
75       throw TransmissionInterfaceException("Joint torque sensor data size does not match transmission.");
76     }
77     if (!hasValidPointers(actuator_data.position))
78     {
79       throw TransmissionInterfaceException("Actuator position data contains null pointers.");
80     }
81     if (!hasValidPointers(actuator_data.velocity))
82     {
83       throw TransmissionInterfaceException("Actuator velocity data contains null pointers.");
84     }
85     if (!hasValidPointers(actuator_data.effort))
86     {
87       throw TransmissionInterfaceException("Actuator effort data contains null pointers.");
88     }
89     if (!actuator_data.absolute_position.empty() &amp;&amp; !hasValidPointers(actuator_data.absolute_position))
90     {
91       throw TransmissionInterfaceException("Actuator absolute position data contains null pointers.");
92     }
93     if (!actuator_data.torque_sensor.empty() &amp;&amp; !hasValidPointers(actuator_data.torque_sensor))
94     {
95       throw TransmissionInterfaceException("Actuator torque sensor data contains null pointers.");
96     }
97     if (!hasValidPointers(joint_data.position))
98     {
99       throw TransmissionInterfaceException("Joint position data contains null pointers.");
100     }
101     if (!hasValidPointers(joint_data.velocity))
102     {
103       throw TransmissionInterfaceException("Joint velocity data contains null pointers.");
104     }
105     if (!hasValidPointers(joint_data.effort))
106     {
107       throw TransmissionInterfaceException("Joint effort data contains null pointers.");
108     }
109     if (!joint_data.absolute_position.empty() &amp;&amp; !hasValidPointers(joint_data.absolute_position))
110     {
111       throw TransmissionInterfaceException("Joint absolute position data contains null pointers.");
112     }
113     if (!joint_data.torque_sensor.empty() &amp;&amp; !hasValidPointers(joint_data.torque_sensor))
114     {
115       throw TransmissionInterfaceException("Joint torque sensor data contains null pointers.");
116     }
117   }
118 private:
119   static bool hasValidPointers(const std::vector&lt;double*&gt;&amp; data)
120   {
121     for (const auto&amp; ptr : data)
122     {
123       if (!ptr) {return false;}
124     }
125     return true;
126   }
127 };
128 class ActuatorToJointStateHandle : public TransmissionHandle
129 {
130 public:
131   ActuatorToJointStateHandle(const std::string&amp;  name,
132                              Transmission*       transmission,
133                              const ActuatorData&amp; actuator_data,
134                              const JointData&amp;    joint_data)
135     : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
136   void propagate()
137   {
138     transmission_-&gt;actuatorToJointPosition(actuator_data_, joint_data_);
139     transmission_-&gt;actuatorToJointVelocity(actuator_data_, joint_data_);
140     transmission_-&gt;actuatorToJointEffort(actuator_data_, joint_data_);
141     if(!actuator_data_.absolute_position.empty() &amp;&amp; transmission_-&gt;hasActuatorToJointAbsolutePosition())
142     {
143        transmission_-&gt;actuatorToJointAbsolutePosition(actuator_data_, joint_data_);
144     }
145     if(!actuator_data_.torque_sensor.empty() &amp;&amp; transmission_-&gt;hasActuatorToJointTorqueSensor())
146     {
147        transmission_-&gt;actuatorToJointTorqueSensor(actuator_data_, joint_data_);
148     }
149   }
150 };
151 class ActuatorToJointPositionHandle : public TransmissionHandle
152 {
153 public:
154   ActuatorToJointPositionHandle(const std::string&amp;  name,
155                                 Transmission*       transmission,
156                                 const ActuatorData&amp; actuator_data,
157                                 const JointData&amp;    joint_data)
158     : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
159   void propagate() {transmission_-&gt;actuatorToJointPosition(actuator_data_, joint_data_);}
160 };
161 class ActuatorToJointVelocityHandle : public TransmissionHandle
162 {
163 public:
164   ActuatorToJointVelocityHandle(const std::string&amp;  name,
165                                 Transmission*       transmission,
166                                 const ActuatorData&amp; actuator_data,
167                                 const JointData&amp;    joint_data)
168     : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
169   void propagate() {transmission_-&gt;actuatorToJointVelocity(actuator_data_, joint_data_);}
170 };
171 class ActuatorToJointEffortHandle : public TransmissionHandle
172 {
173 public:
174   ActuatorToJointEffortHandle(const std::string&amp;  name,
175                               Transmission*       transmission,
176                               const ActuatorData&amp; actuator_data,
177                               const JointData&amp;    joint_data)
178     : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
179   void propagate() {transmission_-&gt;actuatorToJointEffort(actuator_data_, joint_data_);}
180 };
181 class JointToActuatorStateHandle : public TransmissionHandle
182 {
183 public:
184   JointToActuatorStateHandle(const std::string&amp;  name,
185                              Transmission*       transmission,
186                              const ActuatorData&amp; actuator_data,
187                              const JointData&amp;    joint_data)
188     : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
189   void propagate()
190   {
191     transmission_-&gt;jointToActuatorPosition(joint_data_, actuator_data_);
192     transmission_-&gt;jointToActuatorVelocity(joint_data_, actuator_data_);
193     transmission_-&gt;jointToActuatorEffort(  joint_data_, actuator_data_);
194   }
195 };
196 class JointToActuatorPositionHandle : public TransmissionHandle
197 {
198 public:
199   JointToActuatorPositionHandle(const std::string&amp;  name,
200                                 Transmission*       transmission,
201                                 const ActuatorData&amp; actuator_data,
202                                 const JointData&amp;    joint_data)
203     : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
204   void propagate() {transmission_-&gt;jointToActuatorPosition(joint_data_, actuator_data_);}
205 };
206 class JointToActuatorVelocityHandle : public TransmissionHandle
207 {
208 public:
209   JointToActuatorVelocityHandle(const std::string&amp;  name,
210                                 Transmission*       transmission,
211                                 const ActuatorData&amp; actuator_data,
212                                 const JointData&amp;    joint_data)
213     : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
214   void propagate() {transmission_-&gt;jointToActuatorVelocity(joint_data_, actuator_data_);}
215 };
216 class JointToActuatorEffortHandle : public TransmissionHandle
217 {
218 public:
219   JointToActuatorEffortHandle(const std::string&amp;  name,
220                               Transmission*       transmission,
221                               const ActuatorData&amp; actuator_data,
222                               const JointData&amp;    joint_data)
223     : TransmissionHandle(name, transmission, actuator_data, joint_data) {}
224 <a name="0"></a>    void propagate() {transmission_-&gt;jointToActuatorEffort(joint_data_, actuator_data_);}
225 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
226 template &lt;class HandleType&gt;
227 class TransmissionInterface : public hardware_interface::ResourceManager&lt;HandleType&gt;
228 {
229 public:
230   HandleType getHandle(const std::string&amp; name)
231   {
232     try
233     {
234       return this-&gt;hardware_interface::ResourceManager&lt;HandleType&gt;::getHandle(name);
235     }
236     catch(const std::logic_error&amp; e)
237     {
238       throw TransmissionInterfaceException(e.what());
239     }
240   }
241   void propagate()</b></font>
242 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {
243     for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
244     {
245       resource_name_and_handle.second.propagate();
246     }
247   }
248 };
249 class ActuatorToJointStateInterface : public TransmissionInterface&lt;ActuatorToJointStateHandle&gt; {};
250 class ActuatorToJointPositionInterface : public TransmissionInterface&lt;ActuatorToJointPositionHandle&gt; {};
251 class ActuatorToJointVelocityInterface : public TransmissionInterface&lt;ActuatorToJointVelocityHandle&gt; {};
252 class ActuatorToJointEffortInterface : public TransmissionInterface&lt;ActuatorToJointEffortHandle&gt; {};</b></font>
253 class JointToActuatorStateInterface : public TransmissionInterface&lt;JointToActuatorStateHandle&gt; {};
254 class JointToActuatorPositionInterface : public TransmissionInterface&lt;JointToActuatorPositionHandle&gt; {};
255 class JointToActuatorVelocityInterface : public TransmissionInterface&lt;JointToActuatorVelocityHandle&gt; {};
256 class JointToActuatorEffortInterface : public TransmissionInterface&lt;JointToActuatorEffortHandle&gt; {};
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>joint_limits_interface.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include &lt;algorithm&gt;
3 #include &lt;cassert&gt;
4 #include &lt;cmath&gt;
5 #include &lt;limits&gt;
6 #include &lt;ros/duration.h&gt;
7 #include &lt;hardware_interface/internal/resource_manager.h&gt;
8 #include &lt;hardware_interface/joint_command_interface.h&gt;
9 #include &lt;joint_limits_interface/joint_limits.h&gt;
10 #include &lt;joint_limits_interface/joint_limits_interface_exception.h&gt;
11 namespace joint_limits_interface
12 {
13 namespace internal
14 {
15 template&lt;typename T&gt;
16 T saturate(const T val, const T min_val, const T max_val)
17 {
18   return std::min(std::max(val, min_val), max_val);
19 }
20 }
21 class PositionJointSaturationHandle
22 {
23 public:
24   PositionJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
25   : jh_(jh),
26     limits_(limits)
27   {
28     if (limits_.has_position_limits)
29     {
30       min_pos_limit_ = limits_.min_position;
31       max_pos_limit_ = limits_.max_position;
32     }
33     else
34     {
35       min_pos_limit_ = -std::numeric_limits&lt;double&gt;::max();
36       max_pos_limit_ = std::numeric_limits&lt;double&gt;::max();
37     }
38   }
39   std::string getName() const {return jh_.getName();}
40   void enforceLimits(const ros::Duration&amp; period)
41   {
42     if (std::isnan(prev_cmd_))
43       prev_cmd_ = jh_.getPosition();
44     double min_pos, max_pos;
45     if (limits_.has_velocity_limits)
46     {
47       const double delta_pos = limits_.max_velocity * period.toSec();
48       min_pos = std::max(prev_cmd_ - delta_pos, min_pos_limit_);
49       max_pos = std::min(prev_cmd_ + delta_pos, max_pos_limit_);
50     }
51     else
52     {
53       min_pos = min_pos_limit_;
54       max_pos = max_pos_limit_;
55     }
56     const double cmd = internal::saturate(jh_.getCommand(), min_pos, max_pos);
57     jh_.setCommand(cmd);
58     prev_cmd_ = cmd;
59   }
60   void reset(){
61     prev_cmd_ = std::numeric_limits&lt;double&gt;::quiet_NaN();
62   }
63 private:
64   hardware_interface::JointHandle jh_;
65   JointLimits limits_;
66   double min_pos_limit_, max_pos_limit_;
67   double prev_cmd_ = {std::numeric_limits&lt;double&gt;::quiet_NaN()};
68 };
69 class PositionJointSoftLimitsHandle
70 {
71 public:
72   PositionJointSoftLimitsHandle() = default;
73   PositionJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh,
74                                 const JointLimits&amp;                     limits,
75                                 const SoftJointLimits&amp;                 soft_limits)
76     : jh_(jh),
77       limits_(limits),
78       soft_limits_(soft_limits)
79   {
80     if (!limits.has_velocity_limits)
81     {
82       throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
83                                            "'. It has no velocity limits specification.");
84     }
85   }
86   std::string getName() const {return jh_.getName();}
87   void enforceLimits(const ros::Duration&amp; period)
88   {
89     assert(period.toSec() &gt; 0.0);
90     using internal::saturate;
91     if (std::isnan(prev_cmd_)) {prev_cmd_ = jh_.getPosition();}     const double pos = prev_cmd_;
92     double soft_min_vel;
93     double soft_max_vel;
94     if (limits_.has_position_limits)
95     {
96       soft_min_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
97                               -limits_.max_velocity,
98                                limits_.max_velocity);
99       soft_max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
100                               -limits_.max_velocity,
101                                limits_.max_velocity);
102     }
103     else
104     {
105       soft_min_vel = -limits_.max_velocity;
106       soft_max_vel =  limits_.max_velocity;
107     }
108     const double dt = period.toSec();
109     double pos_low  = pos + soft_min_vel * dt;
110     double pos_high = pos + soft_max_vel * dt;
111     if (limits_.has_position_limits)
112     {
113       pos_low  = std::max(pos_low,  limits_.min_position);
114       pos_high = std::min(pos_high, limits_.max_position);
115     }
116     const double pos_cmd = saturate(jh_.getCommand(),
117                                     pos_low,
118                                     pos_high);
119     jh_.setCommand(pos_cmd);
120     prev_cmd_ = jh_.getCommand();
121   }
122   void reset(){
123     prev_cmd_ = std::numeric_limits&lt;double&gt;::quiet_NaN();
124   }
125 private:
126   hardware_interface::JointHandle jh_;
127   JointLimits limits_;
128   SoftJointLimits soft_limits_;
129   double prev_cmd_ = {std::numeric_limits&lt;double&gt;::quiet_NaN()};
130 };
131 class EffortJointSaturationHandle
132 {
133 public:
134   EffortJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
135     : jh_(jh)
136     , limits_(limits)
137   {
138     if (!limits.has_velocity_limits)
139     {
140       throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
141                                            "'. It has no velocity limits specification.");
142     }
143     if (!limits.has_effort_limits)
144     {
145       throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
146                                           "'. It has no efforts limits specification.");
147     }
148   }
149   std::string getName() const {return jh_.getName();}
150   void enforceLimits(const ros::Duration&amp;   {
151     double min_eff = -limits_.max_effort;
152     double max_eff = limits_.max_effort;
153     if (limits_.has_position_limits)
154     {
155       const double pos = jh_.getPosition();
156       if (pos &lt; limits_.min_position)
157         min_eff = 0.0;
158       else if (pos &gt; limits_.max_position)
159         max_eff = 0.0;
160     }
161     const double vel = jh_.getVelocity();
162     if (vel &lt; -limits_.max_velocity)
163       min_eff = 0.0;
164     else if (vel &gt; limits_.max_velocity)
165       max_eff = 0.0;
166     jh_.setCommand(internal::saturate(jh_.getCommand(), min_eff, max_eff));
167   }
168 private:
169   hardware_interface::JointHandle jh_;
170   JointLimits limits_;
171 };
172 class EffortJointSoftLimitsHandle
173 {
174 <a name="2"></a>public:
175   EffortJointSoftLimitsHandle() = default;
176 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  EffortJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh,
177                               const JointLimits&amp;                     limits,
178                               const SoftJointLimits&amp;                 soft_limits)
179   : jh_(jh),
180     limits_(limits),
181     soft_limits_(soft_limits)
182   {
183     if (!limits.has_velocity_limits)
184     {
185       throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
186                                            "'. It has no velocity limits specification.");
187     }
188     if (!limits.has_effort_limits)
189     {
190       throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
191                                            "'. It has no effort limits specification.");
192     }</b></font>
193   }
194   std::string getName() const {return jh_.getName();}
195   {
196     using internal::saturate;
197     const double pos = jh_.getPosition();
198     const double vel = jh_.getVelocity();
199     double soft_min_vel;
200     double soft_max_vel;
201     if (limits_.has_position_limits)
202     {
203       soft_min_vel  = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
204                                -limits_.max_velocity,
205                                 limits_.max_velocity);
206       soft_max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
207                               -limits_.max_velocity,
208                                limits_.max_velocity);
209     }
210     else
211     {
212       soft_min_vel = -limits_.max_velocity;
213       soft_max_vel =  limits_.max_velocity;
214     }
215     const double soft_min_eff = saturate(-soft_limits_.k_velocity * (vel - soft_min_vel),
216                                          -limits_.max_effort,
217                                           limits_.max_effort);
218     const double soft_max_eff = saturate(-soft_limits_.k_velocity * (vel - soft_max_vel),
219                                          -limits_.max_effort,
220                                           limits_.max_effort);
221     const double eff_cmd = saturate(jh_.getCommand(),
222                                     soft_min_eff,
223                                     soft_max_eff);
224     jh_.setCommand(eff_cmd);
225   }
226 private:
227   hardware_interface::JointHandle jh_;
228   JointLimits limits_;
229   SoftJointLimits soft_limits_;
230 };
231 class VelocityJointSaturationHandle
232 {
233 public:
234   VelocityJointSaturationHandle() = default;
235   VelocityJointSaturationHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits)
236     : jh_(jh)
237     , limits_(limits)
238   {
239     if (!limits.has_velocity_limits)
240     {
241       throw JointLimitsInterfaceException("Cannot enforce limits for joint '" + getName() +
242                                            "'. It has no velocity limits specification.");
243     }
244   }
245   std::string getName() const {return jh_.getName();}
246   void enforceLimits(const ros::Duration&amp; period)
247   {
248     using internal::saturate;
249     double vel_low;
250     double vel_high;
251     if (limits_.has_acceleration_limits)
252     {
253       assert(period.toSec() &gt; 0.0);
254       const double dt  = period.toSec();
255       vel_low  = std::max(prev_cmd_ - limits_.max_acceleration * dt, -limits_.max_velocity);
256       vel_high = std::min(prev_cmd_ + limits_.max_acceleration * dt,  limits_.max_velocity);
257     }
258     else
259     {
260       vel_low  = -limits_.max_velocity;
261       vel_high =  limits_.max_velocity;
262     }
263     const double vel_cmd = saturate(jh_.getCommand(),
264                                     vel_low,
265                                     vel_high);
266     jh_.setCommand(vel_cmd);
267     prev_cmd_ = jh_.getCommand();
268   }
269 private:
270   hardware_interface::JointHandle jh_;
271   JointLimits limits_;
272   double prev_cmd_ = {0.0};
273 };
274 class VelocityJointSoftLimitsHandle
275 {
276 public:
277   VelocityJointSoftLimitsHandle(const hardware_interface::JointHandle&amp; jh, const JointLimits&amp; limits,
278                                 const SoftJointLimits&amp; soft_limits)
279       : jh_(jh)
280       , limits_(limits)
281       , soft_limits_(soft_limits)
282   {
283     if (limits.has_velocity_limits)
284       max_vel_limit_ = limits.max_velocity;
285     else
286       max_vel_limit_ = std::numeric_limits&lt;double&gt;::max();
287   }
288   std::string getName() const {return jh_.getName();}
289   void enforceLimits(const ros::Duration&amp; period)
290   {
291     using internal::saturate;
292     double min_vel, max_vel;
293     if (limits_.has_position_limits)
294     {
295       const double pos = jh_.getPosition();
296       min_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.min_position),
297                          -max_vel_limit_, max_vel_limit_);
298       max_vel = saturate(-soft_limits_.k_position * (pos - soft_limits_.max_position),
299                          -max_vel_limit_, max_vel_limit_);
300     }
301     else
302     {
303       min_vel = -max_vel_limit_;
304       max_vel = max_vel_limit_;
305     }
306     if (limits_.has_acceleration_limits)
307     {
308       const double vel = jh_.getVelocity();
309       const double delta_t = period.toSec();
310       min_vel = std::max(vel - limits_.max_acceleration * delta_t, min_vel);
311       max_vel = std::min(vel + limits_.max_acceleration * delta_t, max_vel);
312     }
313     jh_.setCommand(saturate(jh_.getCommand(), min_vel, max_vel));
314   }
315 private:
316   hardware_interface::JointHandle jh_;
317 <a name="0"></a>  JointLimits limits_;
318   SoftJointLimits soft_limits_;
319   double max_vel_limit_;
320 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
321 template &lt;class HandleType&gt;
322 class JointLimitsInterface : public hardware_interface::ResourceManager&lt;HandleType&gt;
323 {
324 public:
325   HandleType getHandle(const std::string&amp; name)
326   {
327     try
328     {
329       return this-&gt;hardware_interface::ResourceManager&lt;HandleType&gt;::getHandle(name);
330     }
331     catch(const std::logic_error&amp; e)
332     {
333       throw JointLimitsInterfaceException(e.what());
334     }
335   }
336   void enforceLimits(const ros::Duration&amp; period)</b></font>
337   {
338     for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
339     {
340       resource_name_and_handle.second.enforceLimits(period);
341     }
342   }
343 };
344 class PositionJointSaturationInterface : public JointLimitsInterface&lt;PositionJointSaturationHandle&gt; {
345 public:
346   void reset()
347   {
348     for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
349     {
350       resource_name_and_handle.second.reset();
351     }
352   }
353 };
354 class PositionJointSoftLimitsInterface : public JointLimitsInterface&lt;PositionJointSoftLimitsHandle&gt; {
355 public:
356   void reset()
357 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  {
358     for (auto&amp;&amp; resource_name_and_handle : this-&gt;resource_map_)
359     {
360       resource_name_and_handle.second.reset();
361     }
362   }
363 };
364 class EffortJointSaturationInterface : public JointLimitsInterface&lt;EffortJointSaturationHandle&gt; {};
365 class EffortJointSoftLimitsInterface : public JointLimitsInterface&lt;EffortJointSoftLimitsHandle&gt; {};
366 class VelocityJointSaturationInterface : public JointLimitsInterface&lt;VelocityJointSaturationHandle&gt; {};
367 class VelocityJointSoftLimitsInterface : public JointLimitsInterface&lt;VelocityJointSoftLimitsHandle&gt; {};</b></font>
368 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
