
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 93, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_benchmark.cc</h3>
            <pre><code>1  #include <string>
2  #include <type_traits>
3  #include <typeindex>
4  #include <utility>
5  #include <vector>
6  #include "absl/base/attributes.h"
7  #include "absl/container/flat_hash_set.h"
8  #include "absl/hash/hash.h"
9  #include "absl/random/random.h"
10  #include "absl/strings/cord.h"
11  #include "absl/strings/cord_test_helpers.h"
12  #include "absl/strings/string_view.h"
13  #include "benchmark/benchmark.h"
14  namespace {
15  using absl::Hash;
16  template <template <typename> class H, typename T>
17  void RunBenchmark(benchmark::State& state, T value) {
18    H<T> h;
19    for (auto _ : state) {
20      benchmark::DoNotOptimize(value);
21      benchmark::DoNotOptimize(h(value));
22    }
23  }
24  }  
25  template <typename T>
26  using AbslHash = absl::Hash<T>;
27  class TypeErasedInterface {
28   public:
29    virtual ~TypeErasedInterface() = default;
30    template <typename H>
31    friend H AbslHashValue(H state, const TypeErasedInterface& wrapper) {
32      state = H::combine(std::move(state), std::type_index(typeid(wrapper)));
33      wrapper.HashValue(absl::HashState::Create(&state));
34      return state;
35    }
36   private:
37    virtual void HashValue(absl::HashState state) const = 0;
38  };
39  template <typename T>
40  struct TypeErasedAbslHash {
41    class Wrapper : public TypeErasedInterface {
42     public:
43      explicit Wrapper(const T& value) : value_(value) {}
44     private:
45      void HashValue(absl::HashState state) const override {
46        absl::HashState::combine(std::move(state), value_);
47      }
48      const T& value_;
49    };
50    size_t operator()(const T& value) {
51      return absl::Hash<Wrapper>{}(Wrapper(value));
52    }
53  };
54  template <typename FuncType>
55  inline FuncType* ODRUseFunction(FuncType* ptr) {
56    volatile FuncType* dummy = ptr;
57    return dummy;
58  }
59  absl::Cord FlatCord(size_t size) {
60    absl::Cord result(std::string(size, 'a'));
61    result.Flatten();
62    return result;
63  }
64  absl::Cord FragmentedCord(size_t size) {
65    const size_t orig_size = size;
66    std::vector<std::string> chunks;
67    size_t chunk_size = std::max<size_t>(1, size / 10);
68    while (size > chunk_size) {
69      chunks.push_back(std::string(chunk_size, 'a'));
70      size -= chunk_size;
71    }
72    if (size > 0) {
73      chunks.push_back(std::string(size, 'a'));
74    }
75    absl::Cord result = absl::MakeFragmentedCord(chunks);
76    (void) orig_size;
77    assert(result.size() == orig_size);
78    return result;
79  }
80  template <typename T>
81  std::vector<T> Vector(size_t count) {
82    std::vector<T> result;
83    for (size_t v = 0; v < count; ++v) {
84      result.push_back(v);
85    }
86    return result;
87  }
88  template <typename T>
89  struct FastUnorderedSet {
90    explicit FastUnorderedSet(size_t count) {
91      for (size_t v = 0; v < count; ++v) {
92        values.push_back(v);
93      }
94    }
95    std::vector<T> values;
96    template <typename H>
97    friend H AbslHashValue(H h, const FastUnorderedSet& fus) {
98      return H::combine(H::combine_unordered(std::move(h), fus.values.begin(),
99                                             fus.values.end()),
100                        fus.values.size());
101    }
102  };
103  template <typename T>
104  absl::flat_hash_set<T> FlatHashSet(size_t count) {
105    absl::flat_hash_set<T> result;
106    for (size_t v = 0; v < count; ++v) {
107      result.insert(v);
108    }
109    return result;
110  }
111  #define MAKE_BENCHMARK(hash, name, ...)                          \
112    namespace {                                                    \
113    void BM_##hash##_##name(benchmark::State& state) {             \
114      RunBenchmark<hash>(state, __VA_ARGS__);                      \
115    }                                                              \
116    BENCHMARK(BM_##hash##_##name);                                 \
117    }                                                              \
118    size_t Codegen##hash##name(const decltype(__VA_ARGS__)& arg);  \
119    size_t Codegen##hash##name(const decltype(__VA_ARGS__)& arg) { \
120      return hash<decltype(__VA_ARGS__)>{}(arg);                   \
121    }                                                              \
122    bool absl_hash_test_odr_use##hash##name =                      \
123        ODRUseFunction(&Codegen##hash##name);
124  MAKE_BENCHMARK(AbslHash, Int32, int32_t{});
125  MAKE_BENCHMARK(AbslHash, Int64, int64_t{});
126  MAKE_BENCHMARK(AbslHash, Double, 1.2);
127  MAKE_BENCHMARK(AbslHash, DoubleZero, 0.0);
128  MAKE_BENCHMARK(AbslHash, PairInt32Int32, std::pair<int32_t, int32_t>{});
129  MAKE_BENCHMARK(AbslHash, PairInt64Int64, std::pair<int64_t, int64_t>{});
130  MAKE_BENCHMARK(AbslHash, TupleInt32BoolInt64,
131                 std::tuple<int32_t, bool, int64_t>{});
<span onclick='openModal()' class='match'>132  MAKE_BENCHMARK(AbslHash, String_0, std::string());
133  MAKE_BENCHMARK(AbslHash, String_10, std::string(10, 'a'));
134  MAKE_BENCHMARK(AbslHash, String_30, std::string(30, 'a'));
135  MAKE_BENCHMARK(AbslHash, String_90, std::string(90, 'a'));
136  MAKE_BENCHMARK(AbslHash, String_200, std::string(200, 'a'));
137  MAKE_BENCHMARK(AbslHash, String_5000, std::string(5000, 'a'));
138  MAKE_BENCHMARK(AbslHash, Cord_Flat_0, absl::Cord());
</span>139  MAKE_BENCHMARK(AbslHash, Cord_Flat_10, FlatCord(10));
140  MAKE_BENCHMARK(AbslHash, Cord_Flat_30, FlatCord(30));
141  MAKE_BENCHMARK(AbslHash, Cord_Flat_90, FlatCord(90));
142  MAKE_BENCHMARK(AbslHash, Cord_Flat_200, FlatCord(200));
143  MAKE_BENCHMARK(AbslHash, Cord_Flat_5000, FlatCord(5000));
144  MAKE_BENCHMARK(AbslHash, Cord_Fragmented_200, FragmentedCord(200));
145  MAKE_BENCHMARK(AbslHash, Cord_Fragmented_5000, FragmentedCord(5000));
146  MAKE_BENCHMARK(AbslHash, VectorInt64_10, Vector<int64_t>(10));
147  MAKE_BENCHMARK(AbslHash, VectorInt64_100, Vector<int64_t>(100));
148  MAKE_BENCHMARK(AbslHash, VectorInt64_1000, Vector<int64_t>(1000));
149  MAKE_BENCHMARK(AbslHash, VectorDouble_10, Vector<double>(10));
150  MAKE_BENCHMARK(AbslHash, VectorDouble_100, Vector<double>(100));
151  MAKE_BENCHMARK(AbslHash, VectorDouble_1000, Vector<double>(1000));
152  MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_10, FlatHashSet<int64_t>(10));
153  MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_100, FlatHashSet<int64_t>(100));
154  MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_1000, FlatHashSet<int64_t>(1000));
155  MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_10, FlatHashSet<double>(10));
156  MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_100, FlatHashSet<double>(100));
157  MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_1000, FlatHashSet<double>(1000));
158  MAKE_BENCHMARK(AbslHash, FastUnorderedSetInt64_1000,
159                 FastUnorderedSet<int64_t>(1000));
160  MAKE_BENCHMARK(AbslHash, FastUnorderedSetDouble_1000,
161                 FastUnorderedSet<double>(1000));
162  MAKE_BENCHMARK(AbslHash, PairStringString_0,
163                 std::make_pair(std::string(), std::string()));
164  MAKE_BENCHMARK(AbslHash, PairStringString_10,
165                 std::make_pair(std::string(10, 'a'), std::string(10, 'b')));
166  MAKE_BENCHMARK(AbslHash, PairStringString_30,
167                 std::make_pair(std::string(30, 'a'), std::string(30, 'b')));
168  MAKE_BENCHMARK(AbslHash, PairStringString_90,
169                 std::make_pair(std::string(90, 'a'), std::string(90, 'b')));
170  MAKE_BENCHMARK(AbslHash, PairStringString_200,
171                 std::make_pair(std::string(200, 'a'), std::string(200, 'b')));
172  MAKE_BENCHMARK(AbslHash, PairStringString_5000,
173                 std::make_pair(std::string(5000, 'a'), std::string(5000, 'b')));
174  MAKE_BENCHMARK(TypeErasedAbslHash, Int32, int32_t{});
175  MAKE_BENCHMARK(TypeErasedAbslHash, Int64, int64_t{});
176  MAKE_BENCHMARK(TypeErasedAbslHash, PairInt32Int32,
177                 std::pair<int32_t, int32_t>{});
178  MAKE_BENCHMARK(TypeErasedAbslHash, PairInt64Int64,
179                 std::pair<int64_t, int64_t>{});
180  MAKE_BENCHMARK(TypeErasedAbslHash, TupleInt32BoolInt64,
181                 std::tuple<int32_t, bool, int64_t>{});
182  MAKE_BENCHMARK(TypeErasedAbslHash, String_0, std::string());
183  MAKE_BENCHMARK(TypeErasedAbslHash, String_10, std::string(10, 'a'));
184  MAKE_BENCHMARK(TypeErasedAbslHash, String_30, std::string(30, 'a'));
185  MAKE_BENCHMARK(TypeErasedAbslHash, String_90, std::string(90, 'a'));
186  MAKE_BENCHMARK(TypeErasedAbslHash, String_200, std::string(200, 'a'));
187  MAKE_BENCHMARK(TypeErasedAbslHash, String_5000, std::string(5000, 'a'));
188  MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_10,
189                 std::vector<double>(10, 1.1));
190  MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_100,
191                 std::vector<double>(100, 1.1));
192  MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_1000,
193                 std::vector<double>(1000, 1.1));
194  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_10,
195                 FlatHashSet<int64_t>(10));
196  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_100,
197                 FlatHashSet<int64_t>(100));
198  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_1000,
199                 FlatHashSet<int64_t>(1000));
200  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_10,
201                 FlatHashSet<double>(10));
202  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_100,
203                 FlatHashSet<double>(100));
204  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_1000,
205                 FlatHashSet<double>(1000));
206  MAKE_BENCHMARK(TypeErasedAbslHash, FastUnorderedSetInt64_1000,
207                 FastUnorderedSet<int64_t>(1000));
208  MAKE_BENCHMARK(TypeErasedAbslHash, FastUnorderedSetDouble_1000,
209                 FastUnorderedSet<double>(1000));
210  namespace {
211  static constexpr size_t kEntropySize = 16 << 10;
212  static char entropy[kEntropySize + 1024];
213  ABSL_ATTRIBUTE_UNUSED static const bool kInitialized = [] {
214    absl::BitGen gen;
215    static_assert(sizeof(entropy) % sizeof(uint64_t) == 0, "");
216    for (int i = 0; i != sizeof(entropy); i += sizeof(uint64_t)) {
217      auto rand = absl::Uniform<uint64_t>(gen);
218      memcpy(&entropy[i], &rand, sizeof(uint64_t));
219    }
220    return true;
221  }();
222  }  
223  template <class T>
224  struct PodRand {
225    static_assert(std::is_pod<T>::value, "");
226    static_assert(kEntropySize + sizeof(T) < sizeof(entropy), "");
227    T Get(size_t i) const {
228      T v;
229      memcpy(&v, &entropy[i % kEntropySize], sizeof(T));
230      return v;
231    }
232  };
233  template <size_t N>
234  struct StringRand {
235    static_assert(kEntropySize + N < sizeof(entropy), "");
236    absl::string_view Get(size_t i) const {
237      size_t s = (i % (N - 1)) + 1;
238      return {&entropy[i % kEntropySize], s};
239    }
240  };
241  #define MAKE_LATENCY_BENCHMARK(hash, name, ...)              \
242    namespace {                                                \
243    void BM_latency_##hash##_##name(benchmark::State& state) { \
244      __VA_ARGS__ r;                                           \
245      hash<decltype(r.Get(0))> h;                              \
246      size_t i = 871401241;                                    \
247      for (auto _ : state) {                                   \
248        benchmark::DoNotOptimize(i = h(r.Get(i)));             \
249      }                                                        \
250    }                                                          \
251    BENCHMARK(BM_latency_##hash##_##name);                     \
252    }  
253  MAKE_LATENCY_BENCHMARK(AbslHash, Int32, PodRand<int32_t>);
254  MAKE_LATENCY_BENCHMARK(AbslHash, Int64, PodRand<int64_t>);
255  MAKE_LATENCY_BENCHMARK(AbslHash, String9, StringRand<9>);
256  MAKE_LATENCY_BENCHMARK(AbslHash, String33, StringRand<33>);
257  MAKE_LATENCY_BENCHMARK(AbslHash, String65, StringRand<65>);
258  MAKE_LATENCY_BENCHMARK(AbslHash, String257, StringRand<257>);
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_benchmark.cc</h3>
            <pre><code>1  #include <string>
2  #include <type_traits>
3  #include <typeindex>
4  #include <utility>
5  #include <vector>
6  #include "absl/base/attributes.h"
7  #include "absl/container/flat_hash_set.h"
8  #include "absl/hash/hash.h"
9  #include "absl/random/random.h"
10  #include "absl/strings/cord.h"
11  #include "absl/strings/cord_test_helpers.h"
12  #include "absl/strings/string_view.h"
13  #include "benchmark/benchmark.h"
14  namespace {
15  using absl::Hash;
16  template <template <typename> class H, typename T>
17  void RunBenchmark(benchmark::State& state, T value) {
18    H<T> h;
19    for (auto _ : state) {
20      benchmark::DoNotOptimize(value);
21      benchmark::DoNotOptimize(h(value));
22    }
23  }
24  }  
25  template <typename T>
26  using AbslHash = absl::Hash<T>;
27  class TypeErasedInterface {
28   public:
29    virtual ~TypeErasedInterface() = default;
30    template <typename H>
31    friend H AbslHashValue(H state, const TypeErasedInterface& wrapper) {
32      state = H::combine(std::move(state), std::type_index(typeid(wrapper)));
33      wrapper.HashValue(absl::HashState::Create(&state));
34      return state;
35    }
36   private:
37    virtual void HashValue(absl::HashState state) const = 0;
38  };
39  template <typename T>
40  struct TypeErasedAbslHash {
41    class Wrapper : public TypeErasedInterface {
42     public:
43      explicit Wrapper(const T& value) : value_(value) {}
44     private:
45      void HashValue(absl::HashState state) const override {
46        absl::HashState::combine(std::move(state), value_);
47      }
48      const T& value_;
49    };
50    size_t operator()(const T& value) {
51      return absl::Hash<Wrapper>{}(Wrapper(value));
52    }
53  };
54  template <typename FuncType>
55  inline FuncType* ODRUseFunction(FuncType* ptr) {
56    volatile FuncType* dummy = ptr;
57    return dummy;
58  }
59  absl::Cord FlatCord(size_t size) {
60    absl::Cord result(std::string(size, 'a'));
61    result.Flatten();
62    return result;
63  }
64  absl::Cord FragmentedCord(size_t size) {
65    const size_t orig_size = size;
66    std::vector<std::string> chunks;
67    size_t chunk_size = std::max<size_t>(1, size / 10);
68    while (size > chunk_size) {
69      chunks.push_back(std::string(chunk_size, 'a'));
70      size -= chunk_size;
71    }
72    if (size > 0) {
73      chunks.push_back(std::string(size, 'a'));
74    }
75    absl::Cord result = absl::MakeFragmentedCord(chunks);
76    (void) orig_size;
77    assert(result.size() == orig_size);
78    return result;
79  }
80  template <typename T>
81  std::vector<T> Vector(size_t count) {
82    std::vector<T> result;
83    for (size_t v = 0; v < count; ++v) {
84      result.push_back(v);
85    }
86    return result;
87  }
88  template <typename T>
89  struct FastUnorderedSet {
90    explicit FastUnorderedSet(size_t count) {
91      for (size_t v = 0; v < count; ++v) {
92        values.push_back(v);
93      }
94    }
95    std::vector<T> values;
96    template <typename H>
97    friend H AbslHashValue(H h, const FastUnorderedSet& fus) {
98      return H::combine(H::combine_unordered(std::move(h), fus.values.begin(),
99                                             fus.values.end()),
100                        fus.values.size());
101    }
102  };
103  template <typename T>
104  absl::flat_hash_set<T> FlatHashSet(size_t count) {
105    absl::flat_hash_set<T> result;
106    for (size_t v = 0; v < count; ++v) {
107      result.insert(v);
108    }
109    return result;
110  }
111  #define MAKE_BENCHMARK(hash, name, ...)                          \
112    namespace {                                                    \
113    void BM_##hash##_##name(benchmark::State& state) {             \
114      RunBenchmark<hash>(state, __VA_ARGS__);                      \
115    }                                                              \
116    BENCHMARK(BM_##hash##_##name);                                 \
117    }                                                              \
118    size_t Codegen##hash##name(const decltype(__VA_ARGS__)& arg);  \
119    size_t Codegen##hash##name(const decltype(__VA_ARGS__)& arg) { \
120      return hash<decltype(__VA_ARGS__)>{}(arg);                   \
121    }                                                              \
122    bool absl_hash_test_odr_use##hash##name =                      \
123        ODRUseFunction(&Codegen##hash##name);
124  MAKE_BENCHMARK(AbslHash, Int32, int32_t{});
125  MAKE_BENCHMARK(AbslHash, Int64, int64_t{});
126  MAKE_BENCHMARK(AbslHash, Double, 1.2);
127  MAKE_BENCHMARK(AbslHash, DoubleZero, 0.0);
128  MAKE_BENCHMARK(AbslHash, PairInt32Int32, std::pair<int32_t, int32_t>{});
129  MAKE_BENCHMARK(AbslHash, PairInt64Int64, std::pair<int64_t, int64_t>{});
130  MAKE_BENCHMARK(AbslHash, TupleInt32BoolInt64,
131                 std::tuple<int32_t, bool, int64_t>{});
132  MAKE_BENCHMARK(AbslHash, String_0, std::string());
133  MAKE_BENCHMARK(AbslHash, String_10, std::string(10, 'a'));
134  MAKE_BENCHMARK(AbslHash, String_30, std::string(30, 'a'));
135  MAKE_BENCHMARK(AbslHash, String_90, std::string(90, 'a'));
136  MAKE_BENCHMARK(AbslHash, String_200, std::string(200, 'a'));
137  MAKE_BENCHMARK(AbslHash, String_5000, std::string(5000, 'a'));
138  MAKE_BENCHMARK(AbslHash, Cord_Flat_0, absl::Cord());
139  MAKE_BENCHMARK(AbslHash, Cord_Flat_10, FlatCord(10));
140  MAKE_BENCHMARK(AbslHash, Cord_Flat_30, FlatCord(30));
141  MAKE_BENCHMARK(AbslHash, Cord_Flat_90, FlatCord(90));
142  MAKE_BENCHMARK(AbslHash, Cord_Flat_200, FlatCord(200));
143  MAKE_BENCHMARK(AbslHash, Cord_Flat_5000, FlatCord(5000));
144  MAKE_BENCHMARK(AbslHash, Cord_Fragmented_200, FragmentedCord(200));
145  MAKE_BENCHMARK(AbslHash, Cord_Fragmented_5000, FragmentedCord(5000));
146  MAKE_BENCHMARK(AbslHash, VectorInt64_10, Vector<int64_t>(10));
147  MAKE_BENCHMARK(AbslHash, VectorInt64_100, Vector<int64_t>(100));
148  MAKE_BENCHMARK(AbslHash, VectorInt64_1000, Vector<int64_t>(1000));
149  MAKE_BENCHMARK(AbslHash, VectorDouble_10, Vector<double>(10));
150  MAKE_BENCHMARK(AbslHash, VectorDouble_100, Vector<double>(100));
151  MAKE_BENCHMARK(AbslHash, VectorDouble_1000, Vector<double>(1000));
152  MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_10, FlatHashSet<int64_t>(10));
153  MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_100, FlatHashSet<int64_t>(100));
154  MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_1000, FlatHashSet<int64_t>(1000));
155  MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_10, FlatHashSet<double>(10));
156  MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_100, FlatHashSet<double>(100));
157  MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_1000, FlatHashSet<double>(1000));
158  MAKE_BENCHMARK(AbslHash, FastUnorderedSetInt64_1000,
159                 FastUnorderedSet<int64_t>(1000));
160  MAKE_BENCHMARK(AbslHash, FastUnorderedSetDouble_1000,
161                 FastUnorderedSet<double>(1000));
162  MAKE_BENCHMARK(AbslHash, PairStringString_0,
163                 std::make_pair(std::string(), std::string()));
164  MAKE_BENCHMARK(AbslHash, PairStringString_10,
165                 std::make_pair(std::string(10, 'a'), std::string(10, 'b')));
166  MAKE_BENCHMARK(AbslHash, PairStringString_30,
167                 std::make_pair(std::string(30, 'a'), std::string(30, 'b')));
168  MAKE_BENCHMARK(AbslHash, PairStringString_90,
169                 std::make_pair(std::string(90, 'a'), std::string(90, 'b')));
170  MAKE_BENCHMARK(AbslHash, PairStringString_200,
171                 std::make_pair(std::string(200, 'a'), std::string(200, 'b')));
172  MAKE_BENCHMARK(AbslHash, PairStringString_5000,
173                 std::make_pair(std::string(5000, 'a'), std::string(5000, 'b')));
174  MAKE_BENCHMARK(TypeErasedAbslHash, Int32, int32_t{});
175  MAKE_BENCHMARK(TypeErasedAbslHash, Int64, int64_t{});
176  MAKE_BENCHMARK(TypeErasedAbslHash, PairInt32Int32,
177                 std::pair<int32_t, int32_t>{});
178  MAKE_BENCHMARK(TypeErasedAbslHash, PairInt64Int64,
179                 std::pair<int64_t, int64_t>{});
180  MAKE_BENCHMARK(TypeErasedAbslHash, TupleInt32BoolInt64,
181                 std::tuple<int32_t, bool, int64_t>{});
<span onclick='openModal()' class='match'>182  MAKE_BENCHMARK(TypeErasedAbslHash, String_0, std::string());
183  MAKE_BENCHMARK(TypeErasedAbslHash, String_10, std::string(10, 'a'));
184  MAKE_BENCHMARK(TypeErasedAbslHash, String_30, std::string(30, 'a'));
185  MAKE_BENCHMARK(TypeErasedAbslHash, String_90, std::string(90, 'a'));
186  MAKE_BENCHMARK(TypeErasedAbslHash, String_200, std::string(200, 'a'));
187  MAKE_BENCHMARK(TypeErasedAbslHash, String_5000, std::string(5000, 'a'));
188  MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_10,
189                 std::vector<double>(10, 1.1));
</span>190  MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_100,
191                 std::vector<double>(100, 1.1));
192  MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_1000,
193                 std::vector<double>(1000, 1.1));
194  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_10,
195                 FlatHashSet<int64_t>(10));
196  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_100,
197                 FlatHashSet<int64_t>(100));
198  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_1000,
199                 FlatHashSet<int64_t>(1000));
200  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_10,
201                 FlatHashSet<double>(10));
202  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_100,
203                 FlatHashSet<double>(100));
204  MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_1000,
205                 FlatHashSet<double>(1000));
206  MAKE_BENCHMARK(TypeErasedAbslHash, FastUnorderedSetInt64_1000,
207                 FastUnorderedSet<int64_t>(1000));
208  MAKE_BENCHMARK(TypeErasedAbslHash, FastUnorderedSetDouble_1000,
209                 FastUnorderedSet<double>(1000));
210  namespace {
211  static constexpr size_t kEntropySize = 16 << 10;
212  static char entropy[kEntropySize + 1024];
213  ABSL_ATTRIBUTE_UNUSED static const bool kInitialized = [] {
214    absl::BitGen gen;
215    static_assert(sizeof(entropy) % sizeof(uint64_t) == 0, "");
216    for (int i = 0; i != sizeof(entropy); i += sizeof(uint64_t)) {
217      auto rand = absl::Uniform<uint64_t>(gen);
218      memcpy(&entropy[i], &rand, sizeof(uint64_t));
219    }
220    return true;
221  }();
222  }  
223  template <class T>
224  struct PodRand {
225    static_assert(std::is_pod<T>::value, "");
226    static_assert(kEntropySize + sizeof(T) < sizeof(entropy), "");
227    T Get(size_t i) const {
228      T v;
229      memcpy(&v, &entropy[i % kEntropySize], sizeof(T));
230      return v;
231    }
232  };
233  template <size_t N>
234  struct StringRand {
235    static_assert(kEntropySize + N < sizeof(entropy), "");
236    absl::string_view Get(size_t i) const {
237      size_t s = (i % (N - 1)) + 1;
238      return {&entropy[i % kEntropySize], s};
239    }
240  };
241  #define MAKE_LATENCY_BENCHMARK(hash, name, ...)              \
242    namespace {                                                \
243    void BM_latency_##hash##_##name(benchmark::State& state) { \
244      __VA_ARGS__ r;                                           \
245      hash<decltype(r.Get(0))> h;                              \
246      size_t i = 871401241;                                    \
247      for (auto _ : state) {                                   \
248        benchmark::DoNotOptimize(i = h(r.Get(i)));             \
249      }                                                        \
250    }                                                          \
251    BENCHMARK(BM_latency_##hash##_##name);                     \
252    }  
253  MAKE_LATENCY_BENCHMARK(AbslHash, Int32, PodRand<int32_t>);
254  MAKE_LATENCY_BENCHMARK(AbslHash, Int64, PodRand<int64_t>);
255  MAKE_LATENCY_BENCHMARK(AbslHash, String9, StringRand<9>);
256  MAKE_LATENCY_BENCHMARK(AbslHash, String33, StringRand<33>);
257  MAKE_LATENCY_BENCHMARK(AbslHash, String65, StringRand<65>);
258  MAKE_LATENCY_BENCHMARK(AbslHash, String257, StringRand<257>);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_benchmark.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_benchmark.cc</div>
                </div>
                <div class="column column_space"><pre><code>132  MAKE_BENCHMARK(AbslHash, String_0, std::string());
133  MAKE_BENCHMARK(AbslHash, String_10, std::string(10, 'a'));
134  MAKE_BENCHMARK(AbslHash, String_30, std::string(30, 'a'));
135  MAKE_BENCHMARK(AbslHash, String_90, std::string(90, 'a'));
136  MAKE_BENCHMARK(AbslHash, String_200, std::string(200, 'a'));
137  MAKE_BENCHMARK(AbslHash, String_5000, std::string(5000, 'a'));
138  MAKE_BENCHMARK(AbslHash, Cord_Flat_0, absl::Cord());
</pre></code></div>
                <div class="column column_space"><pre><code>182  MAKE_BENCHMARK(TypeErasedAbslHash, String_0, std::string());
183  MAKE_BENCHMARK(TypeErasedAbslHash, String_10, std::string(10, 'a'));
184  MAKE_BENCHMARK(TypeErasedAbslHash, String_30, std::string(30, 'a'));
185  MAKE_BENCHMARK(TypeErasedAbslHash, String_90, std::string(90, 'a'));
186  MAKE_BENCHMARK(TypeErasedAbslHash, String_200, std::string(200, 'a'));
187  MAKE_BENCHMARK(TypeErasedAbslHash, String_5000, std::string(5000, 'a'));
188  MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_10,
189                 std::vector<double>(10, 1.1));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    