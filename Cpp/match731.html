<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for serialization.cpp &amp; TestValues.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for serialization.cpp &amp; TestValues.cpp
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>serialization.cpp (5.426357%)<th>TestValues.cpp (2.1472392%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(432-442)<td><a href="#" name="0">(136-167)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>serialization.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;gtest/gtest.h&gt;
2 #include &lt;ros/static_assert.h&gt;
3 #include &lt;std_msgs/Header.h&gt;
4 #include "helpers.h"
5 using namespace ros;
6 using namespace ros::serialization;
7 using namespace test_roscpp;
8 ROS_STATIC_ASSERT(sizeof(ros::Time) == 8);
9 ROS_STATIC_ASSERT(sizeof(ros::Duration) == 8);
10 #define PRIMITIVE_SERIALIZATION_TEST(Type, SerInit, DeserInit) \
11   TEST(Serialization, Type) \
12   { \
13     Type ser_val SerInit; \
14     Type deser_val DeserInit; \
15     Array b = serializeAndDeserialize(ser_val, deser_val); \
16     EXPECT_EQ(*(Type*)b.get(), ser_val); \
17     EXPECT_EQ(ser_val, deser_val); \
18   }
19 PRIMITIVE_SERIALIZATION_TEST(uint8_t, (5), (0));
20 PRIMITIVE_SERIALIZATION_TEST(int8_t, (5), (0));
21 PRIMITIVE_SERIALIZATION_TEST(uint16_t, (5), (0));
22 PRIMITIVE_SERIALIZATION_TEST(int16_t, (5), (0));
23 PRIMITIVE_SERIALIZATION_TEST(uint32_t, (5), (0));
24 PRIMITIVE_SERIALIZATION_TEST(int32_t, (5), (0));
25 PRIMITIVE_SERIALIZATION_TEST(uint64_t, (5), (0));
26 PRIMITIVE_SERIALIZATION_TEST(int64_t, (5), (0));
27 PRIMITIVE_SERIALIZATION_TEST(float, (5.0f), (0.0f));
28 PRIMITIVE_SERIALIZATION_TEST(double, (5.0), (0.0));
29 PRIMITIVE_SERIALIZATION_TEST(Time, (500, 10000), (0, 0));
30 PRIMITIVE_SERIALIZATION_TEST(Duration, (500, 10000), (0, 0));
31 #define PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(Type, Start, Increment) \
32   TEST(Serialization, variableLengthArray_##Type) \
33   { \
34     std::vector&lt;Type&gt; ser_val, deser_val; \
35     Type val = Start; \
36     for (uint32_t i = 0; i &lt; 8; ++i) \
37     { \
38       ser_val.push_back(val); \
39       val = val + Increment; \
40     } \
41     \
42     Array b = serializeAndDeserialize(ser_val, deser_val); \
43     EXPECT_TRUE(ser_val == deser_val); \
44     \
45     EXPECT_EQ(*(uint32_t*)b.get(), (uint32_t)ser_val.size()); \
46     for(size_t i = 0; i &lt; ser_val.size(); ++i) \
47     { \
48       Type* ptr = ((Type*)(b.get() + 4)) + i; \
49       EXPECT_EQ(*ptr, ser_val[i]); \
50     } \
51   }
52 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(uint8_t, 65, 1);
53 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(int8_t, 65, 1);
54 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(uint16_t, 0, 100);
55 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(int16_t, 0, 100);
56 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(uint32_t, 0, 100);
57 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(int32_t, 0, 100);
58 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(uint64_t, 0, 100);
59 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(int64_t, 0, 100);
60 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(float, 0.0f, 100.0f);
61 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(double, 0.0, 100.0);
62 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(Time, Time(), Duration(100));
63 PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(Duration, Duration(), Duration(100));
64 #define PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(Type, Start, Increment) \
65   TEST(Serialization, fixedLengthArray_##Type) \
66   { \
67     boost::array&lt;Type, 8&gt; ser_val, deser_val; \
68     Type val = Start; \
69     for (uint32_t i = 0; i &lt; 8; ++i) \
70     { \
71       ser_val[i] = val; \
72       val = val + Increment; \
73     } \
74     \
75     Array b = serializeAndDeserialize(ser_val, deser_val); \
76     EXPECT_TRUE(ser_val == deser_val); \
77     \
78     for(size_t i = 0; i &lt; ser_val.size(); ++i) \
79     { \
80       Type* ptr = ((Type*)b.get()) + i; \
81       EXPECT_EQ(*ptr, ser_val[i]); \
82     } \
83   }
84 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(uint8_t, 65, 1);
85 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(int8_t, 65, 1);
86 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(uint16_t, 0, 100);
87 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(int16_t, 0, 100);
88 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(uint32_t, 0, 100);
89 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(int32_t, 0, 100);
90 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(uint64_t, 0, 100);
91 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(int64_t, 0, 100);
92 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(float, 0.0f, 100.0f);
93 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(double, 0.0, 100.0);
94 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(Time, Time(), Duration(100));
95 PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(Duration, Duration(), Duration(100));
96 TEST(Serialization, string)
97 {
98   std::string ser_val = "hello world";
99   std::string deser_val;
100   Array b = serializeAndDeserialize(ser_val, deser_val);
101   EXPECT_STREQ(ser_val.c_str(), deser_val.c_str());
102   EXPECT_EQ(*(uint32_t*)b.get(), (uint32_t)ser_val.size());
103   EXPECT_EQ(memcmp(b.get() + 4, ser_val.data(), ser_val.size()), 0);
104 }
105 TEST(Serialization, variableLengthArray_string)
106 {
107   std::vector&lt;std::string&gt; ser_val, deser_val;
108   ser_val.push_back("hello world");
109   ser_val.push_back("hello world22");
110   ser_val.push_back("hello world333");
111   ser_val.push_back("hello world4444");
112   ser_val.push_back("hello world55555");
113   Array b = serializeAndDeserialize(ser_val, deser_val);
114   EXPECT_TRUE(ser_val == deser_val);
115 }
116 TEST(Serialization, fixedLengthArray_string)
117 {
118   boost::array&lt;std::string, 5&gt; ser_val, deser_val;
119   ser_val[0] = "hello world";
120   ser_val[1] = "hello world22";
121   ser_val[2] = "hello world333";
122   ser_val[3] = "hello world4444";
123   ser_val[4] = "hello world55555";
124   Array b = serializeAndDeserialize(ser_val, deser_val);
125   EXPECT_TRUE(ser_val == deser_val);
126 }
127 struct FixedSizeSimple
128 {
129   FixedSizeSimple()
130   : a(0)
131   , b(0)
132   {}
133   int32_t a;
134   int32_t b;
135 };
136 namespace ros
137 {
138 namespace message_traits
139 {
140 template&lt;&gt; struct IsFixedSize&lt;FixedSizeSimple&gt; : public TrueType {};
141 template&lt;&gt; struct IsSimple&lt;FixedSizeSimple&gt; : public TrueType {};
142 } 
143 namespace serialization
144 {
145 template&lt;&gt;
146 struct Serializer&lt;FixedSizeSimple&gt;
147 {
148   template&lt;typename Stream&gt;
149   inline static void write(Stream&amp; stream, const FixedSizeSimple&amp; v)
150   {
151     serialize(stream, v.a);
152   }
153   template&lt;typename Stream&gt;
154   inline static void read(Stream&amp; stream, FixedSizeSimple&amp; v)
155   {
156     deserialize(stream, v.a);
157   }
158   inline static uint32_t serializedLength(const FixedSizeSimple&amp;)
159   {
160     return 4;
161   }
162 };
163 } } 
164 TEST(Serialization, fixedSizeSimple_vector)
165 {
166   {
167     FixedSizeSimple in, out;
168     in.a = 1;
169     in.b = 1;
170     serializeAndDeserialize(in, out);
171     ASSERT_EQ(out.a, 1);
172     ASSERT_EQ(out.b, 0);
173   }
174   {
175     std::vector&lt;FixedSizeSimple&gt; in, out;
176     in.resize(1);
177     in[0].a = 1;
178     in[0].b = 1;
179     serializeAndDeserialize(in, out);
180     ASSERT_EQ(out[0].a, 1);
181     ASSERT_EQ(out[0].b, 1);
182   }
183 }
184 TEST(Serialization, fixedSizeSimple_array)
185 {
186   boost::array&lt;FixedSizeSimple, 2&gt; in, out;
187   in[0].a = 1;
188   in[0].b = 1;
189   serializeAndDeserialize(in, out);
190   ASSERT_EQ(out[0].a, 1);
191   ASSERT_EQ(out[0].b, 1);
192 }
193 struct FixedSizeNonSimple
194 {
195   FixedSizeNonSimple()
196   : length_to_report(4)
197   {}
198   int32_t length_to_report;
199 };
200 namespace ros
201 {
202 namespace message_traits
203 {
204 template&lt;&gt; struct IsFixedSize&lt;FixedSizeNonSimple&gt; : public TrueType {};
205 } 
206 namespace serialization
207 {
208 template&lt;&gt;
209 struct Serializer&lt;FixedSizeNonSimple&gt;
210 {
211   inline static uint32_t serializedLength(const FixedSizeNonSimple&amp; v)
212   {
213     return v.length_to_report;
214   }
215 };
216 } } 
217 TEST(Serialization, fixedSizeNonSimple_vector)
218 {
219   std::vector&lt;FixedSizeNonSimple&gt; in;
220   in.resize(2);
221   in[1].length_to_report = 100;
222   int32_t len = ros::serialization::serializationLength(in);
223   ASSERT_EQ(len, 12);  }
224 TEST(Serialization, fixedSizeNonSimple_array)
225 {
226   boost::array&lt;FixedSizeNonSimple, 2&gt; in;
227   in[1].length_to_report = 100;
228   int32_t len = ros::serialization::serializationLength(in);
229   ASSERT_EQ(len, 8);  }
230 struct VariableSize
231 {
232   VariableSize()
233   : length_to_report(4)
234   {}
235   int32_t length_to_report;
236 };
237 namespace ros
238 {
239 namespace serialization
240 {
241 template&lt;&gt;
242 struct Serializer&lt;VariableSize&gt;
243 {
244   inline static uint32_t serializedLength(const VariableSize&amp; v)
245   {
246     return v.length_to_report;
247   }
248 };
249 } } 
250 TEST(Serialization, variableSize_vector)
251 {
252   std::vector&lt;VariableSize&gt; in;
253   in.resize(2);
254   in[1].length_to_report = 100;
255   int32_t len = ros::serialization::serializationLength(in);
256   ASSERT_EQ(len, 108);  }
257 TEST(Serialization, variableSize_array)
258 {
259   boost::array&lt;VariableSize, 2&gt; in;
260   in[1].length_to_report = 100;
261   int32_t len = ros::serialization::serializationLength(in);
262   ASSERT_EQ(len, 104);  }
263 struct AllInOneSerializer
264 {
265   uint32_t a;
266 };
267 namespace ros
268 {
269 namespace serialization
270 {
271 template&lt;&gt;
272 struct Serializer&lt;AllInOneSerializer&gt;
273 {
274   template&lt;typename Stream, typename T&gt;
275   inline static void allInOne(Stream&amp; stream, T t)
276   {
277     stream.next(t.a);
278   }
279   ROS_DECLARE_ALLINONE_SERIALIZER
280 };
281 } } 
282 TEST(Serialization, allInOne)
283 {
284   AllInOneSerializer in, out;
285   in.a = 5;
286   serializeAndDeserialize(in, out);
287   ASSERT_EQ(out.a, in.a);
288 }
289 struct WithHeader
290 {
291   WithHeader()
292   {}
293   std_msgs::Header header;
294 };
295 struct WithoutHeader
296 {
297   WithoutHeader()
298   {}
299 };
300 namespace ros
301 {
302 namespace message_traits
303 {
304 template&lt;&gt; struct HasHeader&lt;WithHeader&gt; : public TrueType {};
305 } } 
306 TEST(MessageTraits, headers)
307 {
308   WithHeader wh;
309   WithoutHeader woh;
310   const WithHeader cwh;
311   const WithoutHeader cwoh;
312   wh.header.seq = 100;
313   ASSERT_TRUE(ros::message_traits::header(wh) != 0);
314   ASSERT_EQ(ros::message_traits::header(wh)-&gt;seq, 100UL);
315   ASSERT_TRUE(ros::message_traits::header(woh) == 0);
316   ASSERT_TRUE(ros::message_traits::header(cwh) != 0);
317   ASSERT_TRUE(ros::message_traits::header(cwoh) == 0);
318 <a name="0"></a>
319   ASSERT_TRUE(ros::message_traits::frameId(wh) != 0);
320   ASSERT_TRUE(ros::message_traits::frameId(woh) == 0);
321 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  ASSERT_TRUE(ros::message_traits::frameId(cwh) != 0);
322   ASSERT_TRUE(ros::message_traits::frameId(cwoh) == 0);
323   ASSERT_TRUE(ros::message_traits::timeStamp(wh) != 0);
324   ASSERT_TRUE(ros::message_traits::timeStamp(woh) == 0);
325   ASSERT_TRUE(ros::message_traits::timeStamp(cwh) != 0);
326   ASSERT_TRUE(ros::message_traits::timeStamp(cwoh) == 0);
327 }
328 TEST(Serialization, bufferOverrun)
329 {</b></font>
330   Array b(new uint8_t[4]);
331   IStream stream(b.get(), 4);
332   uint32_t i;
333   deserialize(stream, i);
334   try
335   {
336     deserialize(stream, i);
337     FAIL();
338   }
339   catch(ros::Exception&amp;)
340   {
341     SUCCEED();
342   }
343 }
344 TEST(Serialization, streamOperators)
345 {
346   Array b(new uint8_t[4]);
347   OStream ostream(b.get(), 4);
348   uint32_t a = 5;
349   ostream &lt;&lt; a;
350   a = 100;
351   IStream istream(b.get(), 4);
352   istream &gt;&gt; a;
353   ASSERT_EQ(a, 5UL);
354 }
355 int main(int argc, char** argv)
356 {
357   testing::InitGoogleTest(&amp;argc, argv);
358   return RUN_ALL_TESTS();
359 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestValues.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;stdlib.h&gt;
2 #include &lt;string&gt;
3 #include &lt;climits&gt;
4 #include "xmlrpcpp/XmlRpcValue.h"
5 #include "xmlrpcpp/XmlRpcException.h"
6 #include "xmlrpcpp/XmlRpcUtil.h"
7 #include &lt;gtest/gtest.h&gt;
8 using namespace XmlRpc;
9 TEST(XmlRpc, Bool) {
10   XmlRpcValue v(bool(false));
11   EXPECT_EQ("&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;", v.toXml());
12   XmlRpcValue v2;
13   v2[0] = int(1);
14   v2[1] = std::string();
15   v2[2] = XmlRpcValue(false);
16   EXPECT_EQ("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt;&lt;value&gt;&lt;/"
17             "value&gt;&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;",
18             v2.toXml());
19 }
20 TEST(XmlRpc, testBoolean) {
21   const XmlRpcValue booleanFalse(false);
22   XmlRpcValue booleanTrue(true);
23   int offset = 0;
24   XmlRpcValue booleanFalseXml("&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
25   offset = 0;
26   XmlRpcValue booleanTrueXml("&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
27   EXPECT_NE(booleanFalse, booleanTrue);
28   EXPECT_EQ(booleanFalse, booleanFalseXml);
29   EXPECT_NE(booleanFalse, booleanTrueXml);
30   EXPECT_FALSE(bool(booleanFalse));
31   EXPECT_TRUE(bool(booleanTrue));
32   std::stringstream ss;
33   ss &lt;&lt; booleanFalse;
34   EXPECT_EQ("0", ss.str());
35   std::stringstream ss2;
36   ss2 &lt;&lt; booleanTrue;
37   EXPECT_EQ("1", ss2.str());
38 }
39 TEST(XmlRpc, testInt) {
40   const XmlRpcValue int0(0);
41   ASSERT_EQ(XmlRpcValue::TypeInt, int0.getType());
42   XmlRpcValue int1(1);
43   ASSERT_EQ(XmlRpcValue::TypeInt, int1.getType());
44   XmlRpcValue int10(10);
45   ASSERT_EQ(XmlRpcValue::TypeInt, int10.getType());
46   XmlRpcValue int_1(-1);
47   ASSERT_EQ(XmlRpcValue::TypeInt, int_1.getType());
48   int offset = 0;
49   XmlRpcValue int0Xml("&lt;value&gt;&lt;int&gt;0&lt;/int&gt;&lt;/value&gt;", &amp;offset);
50   ASSERT_EQ(XmlRpcValue::TypeInt, int0Xml.getType());
51   EXPECT_EQ(0, int(int0Xml));
52   offset = 0;
53   XmlRpcValue int9Xml("&lt;value&gt;&lt;i4&gt;9&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
54   ASSERT_EQ(XmlRpcValue::TypeInt, int9Xml.getType());
55   EXPECT_EQ(9, int(int9Xml));
56   EXPECT_EQ(int0, int0Xml);
57   EXPECT_EQ(int(int10) - int(int1), int(int9Xml));
58   EXPECT_EQ(9, int(int9Xml));
59   EXPECT_EQ(int(int10) + int(int_1), int(int9Xml));
60   std::stringstream ss;
61   ss &lt;&lt; int9Xml;
62   EXPECT_EQ("9", ss.str());
63 }
64 TEST(XmlRpc, testDouble) {
65   const XmlRpcValue d(43.7);
66   ASSERT_EQ(XmlRpcValue::TypeDouble, d.getType());
67   EXPECT_EQ("&lt;value&gt;&lt;double&gt;43.700000000000003&lt;/double&gt;&lt;/value&gt;", d.toXml());
68   EXPECT_DOUBLE_EQ(43.7, double(d));
69   int offset = 0;
70   XmlRpcValue dXml("&lt;value&gt;&lt;double&gt;56.3&lt;/double&gt;&lt;/value&gt;", &amp;offset);
71   ASSERT_EQ(XmlRpcValue::TypeDouble, dXml.getType());
72   EXPECT_DOUBLE_EQ(56.3, double(dXml));
73   EXPECT_DOUBLE_EQ(100.0, double(d) + double(dXml));
74   std::stringstream ss;
75   ss &lt;&lt; d;
76   EXPECT_EQ("43.7", ss.str());
77   ss.str("");
78 <a name="0"></a>    const XmlRpc::XmlRpcValue a(2.0);
79   ASSERT_EQ(XmlRpcValue::TypeDouble, d.getType());
80 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  const std::string save_format = XmlRpc::XmlRpcValue::getDoubleFormat();
81   XmlRpc::XmlRpcValue::setDoubleFormat("%32.10f");
82   ss &lt;&lt; a;
83   EXPECT_EQ("                    2.0000000000", ss.str());
84   ss.str("");
85   XmlRpc::XmlRpcValue::setDoubleFormat("%10.32f");
86   ss &lt;&lt; a;
87   EXPECT_EQ("2.00000000000000000000000000000000", ss.str());
88   ss.str("");
89   XmlRpc::XmlRpcValue::setDoubleFormat("%128.10f");
90   ss &lt;&lt; a;
91   EXPECT_EQ("                                "
92             "                                "
93             "                                "
94             "                    2.000000000", ss.str());
95   ss.str("");
96   XmlRpc::XmlRpcValue::setDoubleFormat("%10.128f");
97   ss &lt;&lt; a;
98   EXPECT_EQ("2.000000000000000000000000000000"
99             "00000000000000000000000000000000"
100             "00000000000000000000000000000000"
101             "000000000000000000000000000000000", ss.str());
102   ss.str("");
103   XmlRpc::XmlRpcValue::setDoubleFormat(save_format.c_str());
104 }
105 TEST(XmlRpc, testString) {</b></font>
106   const XmlRpcValue s("Now is the time &lt;&amp;");
107   ASSERT_EQ(XmlRpcValue::TypeString, s.getType());
108   EXPECT_EQ(18, s.size());
109   EXPECT_EQ("&lt;value&gt;Now is the time &amp;lt;&amp;amp;&lt;/value&gt;", s.toXml());
110   char csxml[] = "&lt;value&gt;&lt;string&gt;Now is the time &amp;lt;&amp;amp;&lt;/string&gt;&lt;/value&gt;";
111   std::string ssxml = csxml;
112   int offset = 0;
113   XmlRpcValue vscXml(csxml, &amp;offset);
114   EXPECT_EQ(s, vscXml);
115   offset = 0;
116   XmlRpcValue vssXml(ssxml, &amp;offset);
117   EXPECT_EQ(s, vssXml);
118   offset = 0;
119   XmlRpcValue fromXml(vssXml.toXml(), &amp;offset);
120   EXPECT_EQ(s, fromXml);
121   std::string emptyStringXml("&lt;value&gt;&lt;/value&gt;");
122   offset = 0;
123   XmlRpcValue emptyStringVal1(emptyStringXml, &amp;offset);
124   XmlRpcValue emptyStringVal2("");
125   EXPECT_EQ(emptyStringVal1, emptyStringVal2);
126   emptyStringXml = "&lt;value&gt;  &lt;/value&gt;";
127   offset = 0;
128   XmlRpcValue blankStringVal(emptyStringXml, &amp;offset);
129   EXPECT_EQ(std::string(blankStringVal), "  ");
130   XmlRpcValue s2;
131   std::string tmp = s2;
132   EXPECT_EQ("", tmp);
133   EXPECT_EQ("", (std::string)s2);
134   std::stringstream ss;
135   ss &lt;&lt; s;
136   EXPECT_EQ("Now is the time &lt;&amp;", ss.str());
137 }
138 TEST(XmlRpc, testOversizeString) {
139   try {
140     std::string xml = "&lt;tag&gt;&lt;nexttag&gt;";
141     xml += std::string(INT_MAX, 'a');
142     xml += "a&lt;/nexttag&gt;&lt;/tag&gt;";
143     int offset;
144     offset = 0;
145     EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", xml, &amp;offset), std::string());
146     EXPECT_EQ(offset, 0);
147     offset = 0;
148     EXPECT_FALSE(XmlRpcUtil::findTag("&lt;tag&gt;", xml, &amp;offset));
149     EXPECT_EQ(offset, 0);
150     offset = 0;
151     EXPECT_FALSE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", xml, &amp;offset));
152     EXPECT_EQ(offset, 0);
153     offset = 0;
154     EXPECT_EQ(XmlRpcUtil::getNextTag(xml, &amp;offset), std::string());
155     EXPECT_EQ(offset, 0);
156   }
157   catch (std::bad_alloc&amp; err) {
158 #ifdef GTEST_SKIP
159     GTEST_SKIP() &lt;&lt; "Unable to allocate memory to run test\n";
160 #else
161     std::cerr &lt;&lt; "[ SKIPPED  ] XmlRpc.testOversizeString Unable to allocate memory to run test\n";
162 #endif
163   }
164 }
165 TEST(XmlRpc, testParseTag) {
166   int offset = 0;
167   EXPECT_EQ(XmlRpcUtil::parseTag(NULL, "", &amp;offset), std::string());
168   EXPECT_EQ(offset, 0);
169   EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "", NULL), std::string());
170   EXPECT_EQ(offset, 0);
171   offset = 20;
172   EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "", &amp;offset), std::string());
173   EXPECT_EQ(offset, 20);
174   offset = 0;
175   EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "&lt;foo&gt;&lt;/foo&gt;", &amp;offset), std::string());
176   EXPECT_EQ(offset, 0);
177   EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "&lt;tag&gt;", &amp;offset), std::string());
178   EXPECT_EQ(offset, 0);
179   EXPECT_EQ(XmlRpcUtil::parseTag("&lt;tag&gt;", "&lt;tag&gt;foo&lt;/tag&gt;", &amp;offset), "foo");
180   EXPECT_EQ(offset, 14);
181 }
182 TEST(XmlRpc, testFindTag) {
183   int offset = 0;
184   EXPECT_FALSE(XmlRpcUtil::findTag(NULL, "", &amp;offset));
185   EXPECT_EQ(offset, 0);
186   EXPECT_FALSE(XmlRpcUtil::findTag("&lt;tag&gt;", "", NULL));
187   EXPECT_EQ(offset, 0);
188   offset = 20;
189   EXPECT_FALSE(XmlRpcUtil::findTag("&lt;tag&gt;", "", &amp;offset));
190   EXPECT_EQ(offset, 20);
191   offset = 0;
192   EXPECT_TRUE(XmlRpcUtil::findTag("&lt;subtag&gt;", "&lt;tag&gt;&lt;subtag&gt;&lt;/subtag&gt;&lt;/tag&gt;", &amp;offset));
193   EXPECT_EQ(offset, 13);
194 }
195 TEST(XmlRpc, testNextTagIs) {
196   int offset = 0;
197   EXPECT_FALSE(XmlRpcUtil::nextTagIs(NULL, "", &amp;offset));
198   EXPECT_EQ(offset, 0);
199   EXPECT_FALSE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "", NULL));
200   EXPECT_EQ(offset, 0);
201   offset = 20;
202   EXPECT_FALSE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "", &amp;offset));
203   EXPECT_EQ(offset, 20);
204   offset = 0;
205   EXPECT_TRUE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "&lt;tag&gt;&lt;/tag&gt;", &amp;offset));
206   EXPECT_EQ(offset, 5);
207   offset = 0;
208   EXPECT_TRUE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "      &lt;tag&gt;&lt;/tag&gt;", &amp;offset));
209   EXPECT_EQ(offset, 11);
210   offset = 0;
211   EXPECT_FALSE(XmlRpcUtil::nextTagIs("&lt;tag&gt;", "      &lt;footag&gt;&lt;/footag&gt;", &amp;offset));
212   EXPECT_EQ(offset, 0);
213 }
214 TEST(XmlRpc, testGetNextTag) {
215   int offset = 0;
216   EXPECT_EQ(XmlRpcUtil::getNextTag("", NULL), std::string());
217   EXPECT_EQ(offset, 0);
218   offset = 20;
219   EXPECT_EQ(XmlRpcUtil::getNextTag("&lt;tag&gt;", &amp;offset), std::string());
220   EXPECT_EQ(offset, 20);
221   offset = 0;
222   EXPECT_EQ(XmlRpcUtil::getNextTag("&lt;tag&gt;&lt;/tag&gt;", &amp;offset), "&lt;tag&gt;");
223   EXPECT_EQ(offset, 5);
224   offset = 0;
225   EXPECT_EQ(XmlRpcUtil::getNextTag("      &lt;tag&gt;&lt;/tag&gt;", &amp;offset), "&lt;tag&gt;");
226   EXPECT_EQ(offset, 11);
227   offset = 0;
228   EXPECT_EQ(XmlRpcUtil::getNextTag("      foo", &amp;offset), std::string());
229   EXPECT_EQ(offset, 0);
230   offset = 0;
231   EXPECT_EQ(XmlRpcUtil::getNextTag("&lt;foo", &amp;offset), "&lt;foo");
232   EXPECT_EQ(offset, 4);
233   offset = 0;
234   EXPECT_EQ(XmlRpcUtil::getNextTag("&lt;&gt;", &amp;offset), "&lt;&gt;");
235   EXPECT_EQ(offset, 2);
236 }
237 TEST(XmlRpc, testNextTagData)
238 {
239   int offset = 0;
240   EXPECT_EQ(XmlRpcUtil::nextTagData(NULL, "", &amp;offset), std::string());
241   EXPECT_EQ(offset, 0);
242   EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "", NULL), std::string());
243   EXPECT_EQ(offset, 0);
244   offset = 20;
245   EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "", &amp;offset), std::string());
246   EXPECT_EQ(offset, 20);
247   offset = 0;
248   EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "&lt;tag&gt;&lt;/tag&gt;", &amp;offset), "");
249   EXPECT_EQ(offset, 11);
250   offset = 0;
251   EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;tag&gt;&lt;/tag&gt;", &amp;offset), "");
252   EXPECT_EQ(offset, 14);
253   offset = 0;
254   EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;tag&gt;foo&lt;/tag&gt;", &amp;offset), "foo");
255   EXPECT_EQ(offset, 17);
256   offset = 0;
257   EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;foo&gt;&lt;/foo&gt;", &amp;offset), "");
258   EXPECT_EQ(offset, 0);
259   offset = 0;
260   EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;tag&gt;&lt;foo&gt;&lt;/tag&gt;", &amp;offset), "");
261   EXPECT_EQ(offset, 0);
262   offset = 0;
263   EXPECT_EQ(XmlRpcUtil::nextTagData("&lt;tag&gt;", "   &lt;tag&gt;foo", &amp;offset), "");
264   EXPECT_EQ(offset, 0);
265 }
266 TEST(XmlRpc, testDateTime) {
267   int offset = 0;
268   const XmlRpcValue dateTime(
269       "&lt;value&gt;&lt;dateTime.iso8601&gt;19040503T03:12:35&lt;/dateTime.iso8601&gt;&lt;/value&gt;",
270       &amp;offset);
271   ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime.getType());
272   struct tm t = dateTime;
273   EXPECT_EQ(t.tm_year, 1904);
274   EXPECT_EQ(t.tm_min, 12);
275   EXPECT_EQ(t.tm_sec, 35);
276   EXPECT_EQ(t.tm_hour, 3);
277   EXPECT_EQ(t.tm_mday, 3);
278   EXPECT_EQ(t.tm_mon, 5);
279   EXPECT_EQ(
280       "&lt;value&gt;&lt;dateTime.iso8601&gt;19040503T03:12:35&lt;/dateTime.iso8601&gt;&lt;/value&gt;",
281       dateTime.toXml());
282   XmlRpcValue dateTime2(&amp;t);
283   ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime2.getType());
284   t = dateTime2;
285   EXPECT_EQ(t.tm_year, 1904);
286   EXPECT_EQ(t.tm_min, 12);
287   XmlRpcValue dateTime3;
288   t = dateTime3;
289   ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime3.getType());
290   EXPECT_EQ(t.tm_year, 0);
291   EXPECT_EQ(t.tm_min, 0);
292   std::stringstream ss;
293   ss &lt;&lt; dateTime;
294   EXPECT_EQ("19040503T03:12:35", ss.str());
295   EXPECT_EQ(dateTime, dateTime2);
296   dateTime3 = dateTime;
297   EXPECT_EQ(dateTime, dateTime3);
298   t = dateTime;
299   struct tm&amp; tm2 = dateTime2;
300   tm2.tm_sec = 0;
301   EXPECT_NE(dateTime, dateTime2);
302   tm2 = t;
303   ASSERT_EQ(dateTime, dateTime2);
304   tm2.tm_min = 0;
305   EXPECT_NE(dateTime, dateTime2);
306   tm2 = t;
307   ASSERT_EQ(dateTime, dateTime2);
308   tm2.tm_hour = 0;
309   EXPECT_NE(dateTime, dateTime2);
310   tm2 = t;
311   ASSERT_EQ(dateTime, dateTime2);
312   tm2.tm_mday = 1;
313   EXPECT_NE(dateTime, dateTime2);
314   tm2 = t;
315   ASSERT_EQ(dateTime, dateTime2);
316   tm2.tm_mon = 1;
317   EXPECT_NE(dateTime, dateTime2);
318   tm2 = t;
319   ASSERT_EQ(dateTime, dateTime2);
320   tm2.tm_year = 1988;
321   EXPECT_NE(dateTime, dateTime2);
322 }
323 TEST(XmlRpc, testArray) {
324   XmlRpcValue d(43.7);
325   XmlRpcValue a;
326   a.setSize(4);
327   a[0] = 1;
328   a[1] = std::string("two");
329   a[2] = 43.7;
330   a[3] = "four";
331   EXPECT_EQ(XmlRpcValue::TypeArray, a.getType());
332   EXPECT_EQ(int(a[0]), 1);
333   EXPECT_EQ(a[2], d);
334   char csaXml[] = "&lt;value&gt;&lt;array&gt;\n"
335                   "  &lt;data&gt;\n"
336                   "    &lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt; \n"
337                   "    &lt;value&gt; &lt;string&gt;two&lt;/string&gt;&lt;/value&gt;\n"
338                   "    &lt;value&gt;&lt;double&gt;43.7&lt;/double&gt;&lt;/value&gt;\n"
339                   "    &lt;value&gt;four&lt;/value&gt;\n"
340                   "  &lt;/data&gt;\n"
341                   "&lt;/array&gt;&lt;/value&gt;";
342   int offset = 0;
343   XmlRpcValue aXml(csaXml, &amp;offset);
344   EXPECT_EQ(a, aXml);
345   const XmlRpcValue copy(a);
346   ASSERT_EQ(a.getType(), copy.getType());
347   ASSERT_EQ(a.size(), copy.size());
348   for (int i = 0; i &lt; 3; i++) {
349     EXPECT_EQ(a[i], copy[i]);
350   }
351   EXPECT_EQ(a, copy);
352   EXPECT_NE(a, d);
353   std::stringstream ss;
354   ss &lt;&lt; a;
355   EXPECT_EQ("{1,two,43.7,four}", ss.str());
356 }
357 TEST(XmlRpc, testStruct) {
358   XmlRpcValue struct1;
359   struct1["i4"] = 1;
360   struct1["str"] = "two";
361   struct1["d"] = 43.7;
362   EXPECT_EQ(3, struct1.size());
363   EXPECT_EQ(XmlRpcValue::TypeStruct, struct1.getType());
364   EXPECT_TRUE(struct1.hasMember("i4"));
365   EXPECT_FALSE(struct1.hasMember("nowhere"));
366   std::stringstream ss;
367   ss &lt;&lt; struct1;
368   EXPECT_EQ("[d:43.7,i4:1,str:two]", ss.str());
369   XmlRpcValue a;
370   a.setSize(4);
371   a[0] = 1;
372   a[1] = std::string("two");
373   a[2] = 43.7;
374   a[3] = "four";
375   EXPECT_EQ(struct1["d"], a[2]);
376   char csStructXml[] = "&lt;value&gt;&lt;struct&gt;\n"
377                        "  &lt;member&gt;\n"
378                        "    &lt;name&gt;i4&lt;/name&gt; \n"
379                        "    &lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt; \n"
380                        "  &lt;/member&gt;\n"
381                        "  &lt;member&gt;\n"
382                        "    &lt;name&gt;d&lt;/name&gt; \n"
383                        "    &lt;value&gt;&lt;double&gt;43.7&lt;/double&gt;&lt;/value&gt;\n"
384                        "  &lt;/member&gt;\n"
385                        "  &lt;member&gt;\n"
386                        "    &lt;name&gt;str&lt;/name&gt; \n"
387                        "    &lt;value&gt; &lt;string&gt;two&lt;/string&gt;&lt;/value&gt;\n"
388                        "  &lt;/member&gt;\n"
389                        "&lt;/struct&gt;&lt;/value&gt;";
390   int offset = 0;
391   const XmlRpcValue structXml(csStructXml, &amp;offset);
392   EXPECT_EQ(struct1, structXml);
393   for (XmlRpcValue::iterator itr = struct1.begin(); itr != struct1.end();
394        itr++) {
395   }
396   XmlRpcValue astruct;
397   astruct["array"] = a;
398   EXPECT_EQ(astruct["array"][2], struct1["d"]);
399   for (int i = 0; i &lt; 10; i++) {
400     XmlRpcValue Event;
401     Event["Name"] = "string";
402     Event.clear();
403     const int NELMTS = 100;
404     int ii;
405     for (ii = 0; ii &lt; NELMTS; ++ii) {
406       char buf[40];
407       sprintf(buf, "%d", ii);
408       Event[std::string(buf)] = buf;
409     }
410     Event.clear();
411     for (ii = 0; ii &lt; NELMTS; ++ii) {
412       char buf[40];
413       sprintf(buf, "%d", ii);
414       if (ii != NELMTS / 2)
415         Event[std::string(buf)] = ii;
416       else
417         for (int jj = 0; jj &lt; NELMTS; ++jj) {
418           char bufj[40];
419           sprintf(bufj, "%d", jj);
420           Event[std::string(buf)][std::string(bufj)] = bufj;
421         }
422     }
423     for (ii = 0; ii &lt; NELMTS; ++ii) {
424       char buf[40];
425       sprintf(buf, "%d", ii);
426       if (ii != NELMTS / 2)
427         EXPECT_EQ(Event[std::string(buf)], XmlRpcValue(ii));
428       else
429         EXPECT_EQ(Event[std::string(buf)].size(), NELMTS);
430     }
431   }
432 }
433 TEST(XmlRpc, base64) {
434   char data[] = {1, 2};
435   const XmlRpcValue bin(data, 2);
436   EXPECT_EQ(XmlRpcValue::TypeBase64, bin.getType());
437   EXPECT_EQ(2, bin.size());
438   XmlRpcValue::BinaryData d = bin;
439   EXPECT_EQ(d[0], 1);
440   EXPECT_EQ(d[1], 2);
441   EXPECT_EQ("&lt;value&gt;&lt;base64&gt;AQI=\n&lt;/base64&gt;&lt;/value&gt;", bin.toXml());
442   std::stringstream ss;
443   ss &lt;&lt; bin;
444   EXPECT_EQ("AQI=\n", ss.str());
445   int offset = 0;
446   XmlRpcValue bin2("&lt;value&gt;&lt;base64&gt;AQI=&lt;/base64&gt;&lt;/value&gt;", &amp;offset);
447   EXPECT_EQ(XmlRpcValue::TypeBase64, bin2.getType());
448   EXPECT_EQ(2, bin2.size());
449   d = bin2;
450   EXPECT_EQ(d[0], 1);
451   EXPECT_EQ(d[1], 2);
452   EXPECT_EQ(bin, bin2);
453   XmlRpcValue bin3;
454   d = bin3;
455   EXPECT_EQ(XmlRpcValue::TypeBase64, bin3.getType());
456   EXPECT_EQ(0, bin3.size());
457   EXPECT_EQ(0u, d.size());
458   XmlRpcValue bin4;
459   bin4 = bin;
460   EXPECT_EQ(XmlRpcValue::TypeBase64, bin4.getType());
461   EXPECT_EQ(2, bin4.size());
462   d = bin4;
463   EXPECT_EQ(d[0], 1);
464   EXPECT_EQ(d[1], 2);
465 }
466 TEST(XmpRpc, errors) {
467   XmlRpcValue value;
468   EXPECT_FALSE(value.valid());
469   EXPECT_EQ("", value.toXml());
470   bool v = (bool)value;
471   EXPECT_FALSE(v);
472   EXPECT_THROW((void)(int)value, XmlRpcException);
473   EXPECT_THROW(value[0], XmlRpcException);
474   EXPECT_THROW(value["bar"], XmlRpcException);
475   const XmlRpcValue&amp; ref = value;
476   EXPECT_THROW(ref[0], XmlRpcException);
477   EXPECT_FALSE(ref.hasMember("bar"));
478   try {
479     (void)int(value);
480   } catch (XmlRpcException&amp; e) {
481     EXPECT_EQ("type error", e.getMessage());
482     EXPECT_EQ(-1, e.getCode());
483   }
484   EXPECT_THROW(value.size(), XmlRpcException);
485   value.clear();
486   EXPECT_FALSE(value.valid());
487 }
488 TEST(XmlRpc, int_errors) {
489   XmlRpcValue value;
490   int v = (int)value;
491   EXPECT_EQ(0, v);
492   EXPECT_EQ(0, (int)value);
493   EXPECT_THROW((void)(bool)value, XmlRpcException);
494 }
495 TEST(XmlRpc, array_errors) {
496   XmlRpcValue value;
497   int v = value[0];
498   EXPECT_EQ(0, v);
499   EXPECT_THROW((void)(bool)value, XmlRpcException);
500   EXPECT_EQ(1, value.size());
501   EXPECT_EQ(0, (int)value[1]);
502   EXPECT_EQ(2, value.size());
503   const XmlRpcValue&amp; ref = value;
504   EXPECT_THROW(ref[2], XmlRpcException);
505 }
506 TEST(XmlRpc, fromXmlInvalid) {
507   int offset = 0;
508   XmlRpcValue val;
509   val.fromXml("", NULL);
510   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
511   offset = 20;
512   val.fromXml("", &amp;offset);
513   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
514   EXPECT_EQ(offset, 20);
515   offset = 0;
516   val.fromXml("&lt;foo&gt;", &amp;offset);
517   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
518   EXPECT_EQ(offset, 0);
519   offset = 0;
520   val.fromXml("&lt;value&gt;", &amp;offset);
521   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
522   EXPECT_EQ(offset, 0);
523   offset = 0;
524   val.fromXml("&lt;value&gt;&lt;invalid&gt;&lt;/invalid&gt;&lt;/value&gt;", &amp;offset);
525   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
526   EXPECT_EQ(offset, 0);
527   offset = 0;
528   val.fromXml("&lt;value&gt;&lt;/value&gt;", &amp;offset);
529   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
530   EXPECT_EQ(offset, 15);
531   EXPECT_EQ(static_cast&lt;std::string&gt;(val), "");
532 }
533 TEST(XmlRpc, fromXmlBoolean) {
534   int offset = 0;
535   XmlRpcValue val;
536   offset = 0;
537   val.fromXml("&lt;value&gt;&lt;boolean&gt;&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
538   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
539   EXPECT_EQ(offset, 0);
540   offset = 0;
541   val.fromXml("&lt;value&gt;&lt;boolean&gt;&lt;/value&gt;", &amp;offset);
542   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
543   EXPECT_EQ(offset, 0);
544   offset = 0;
545   val.fromXml("&lt;value&gt;&lt;boolean&gt;foo&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
546   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
547   EXPECT_EQ(offset, 0);
548   offset = 0;
549   val.fromXml("&lt;value&gt;&lt;boolean&gt;25&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
550   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
551   EXPECT_EQ(offset, 0);
552   offset = 0;
553   val.fromXml("&lt;value&gt;&lt;boolean&gt;1foo&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
554   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
555   EXPECT_EQ(offset, 38);
556   EXPECT_EQ(static_cast&lt;bool&gt;(val), true);
557   offset = 0;
558   val.fromXml("&lt;value&gt;&lt;boolean&gt;1&lt;/value&gt;", &amp;offset);
559   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
560   EXPECT_EQ(offset, 25);
561   EXPECT_EQ(static_cast&lt;bool&gt;(val), true);
562   offset = 0;
563   val.fromXml("&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
564   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
565   EXPECT_EQ(offset, 35);
566   EXPECT_EQ(static_cast&lt;bool&gt;(val), false);
567   offset = 0;
568   val.fromXml("&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;", &amp;offset);
569   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
570   EXPECT_EQ(offset, 35);
571   EXPECT_EQ(static_cast&lt;bool&gt;(val), true);
572 }
573 TEST(XmlRpc, fromXmlI4) {
574   int offset = 0;
575   XmlRpcValue val;
576   offset = 0;
577   val.fromXml("&lt;value&gt;&lt;i4&gt;&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
578   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
579   EXPECT_EQ(offset, 0);
580   offset = 0;
581   val.fromXml("&lt;value&gt;&lt;i4&gt;&lt;/value&gt;", &amp;offset);
582   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
583   EXPECT_EQ(offset, 0);
584   offset = 0;
585   val.fromXml("&lt;value&gt;&lt;i4&gt;foo&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
586   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
587   EXPECT_EQ(offset, 0);
588   offset = 0;
589   val.fromXml("&lt;value&gt;&lt;i4&gt;25&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
590   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
591   EXPECT_EQ(offset, 26);
592   EXPECT_EQ(static_cast&lt;int&gt;(val), 25);
593   offset = 0;
594   val.fromXml("&lt;value&gt;&lt;i4&gt;1foo&lt;/i4&gt;&lt;/value&gt;", &amp;offset);
595   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
596   EXPECT_EQ(offset, 28);
597   EXPECT_EQ(static_cast&lt;int&gt;(val), 1);
598   offset = 0;
599   val.fromXml("&lt;value&gt;&lt;i4&gt;99&lt;/value&gt;", &amp;offset);
600   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
601   EXPECT_EQ(offset, 21);
602   EXPECT_EQ(static_cast&lt;int&gt;(val), 99);
603 }
604 TEST(XmlRpc, fromXmlInt) {
605   int offset = 0;
606   XmlRpcValue val;
607   offset = 0;
608   val.fromXml("&lt;value&gt;&lt;int&gt;&lt;/int&gt;&lt;/value&gt;", &amp;offset);
609   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
610   EXPECT_EQ(offset, 0);
611   offset = 0;
612   val.fromXml("&lt;value&gt;&lt;int&gt;&lt;/value&gt;", &amp;offset);
613   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
614   EXPECT_EQ(offset, 0);
615   offset = 0;
616   val.fromXml("&lt;value&gt;&lt;int&gt;foo&lt;/int&gt;&lt;/value&gt;", &amp;offset);
617   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
618   EXPECT_EQ(offset, 0);
619   offset = 0;
620   val.fromXml("&lt;value&gt;&lt;int&gt;25&lt;/int&gt;&lt;/value&gt;", &amp;offset);
621   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
622   EXPECT_EQ(offset, 28);
623   EXPECT_EQ(static_cast&lt;int&gt;(val), 25);
624   offset = 0;
625   val.fromXml("&lt;value&gt;&lt;int&gt;1foo&lt;/int&gt;&lt;/value&gt;", &amp;offset);
626   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
627   EXPECT_EQ(offset, 30);
628   EXPECT_EQ(static_cast&lt;int&gt;(val), 1);
629   offset = 0;
630   val.fromXml("&lt;value&gt;&lt;int&gt;99&lt;/value&gt;", &amp;offset);
631   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
632   EXPECT_EQ(offset, 22);
633   EXPECT_EQ(static_cast&lt;int&gt;(val), 99);
634 }
635 TEST(XmlRpc, fromXmlDouble) {
636   int offset = 0;
637   XmlRpcValue val;
638   offset = 0;
639   val.fromXml("&lt;value&gt;&lt;double&gt;&lt;/double&gt;&lt;/value&gt;", &amp;offset);
640   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
641   EXPECT_EQ(offset, 0);
642   offset = 0;
643   val.fromXml("&lt;value&gt;&lt;double&gt;&lt;/value&gt;", &amp;offset);
644   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
645   EXPECT_EQ(offset, 0);
646   offset = 0;
647   val.fromXml("&lt;value&gt;&lt;double&gt;foo&lt;/double&gt;&lt;/value&gt;", &amp;offset);
648   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
649   EXPECT_EQ(offset, 0);
650   offset = 0;
651   val.fromXml("&lt;value&gt;&lt;double&gt;25&lt;/double&gt;&lt;/value&gt;", &amp;offset);
652   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
653   EXPECT_EQ(offset, 34);
654   EXPECT_EQ(static_cast&lt;double&gt;(val), 25.0);
655   offset = 0;
656   val.fromXml("&lt;value&gt;&lt;double&gt;25.876&lt;/double&gt;&lt;/value&gt;", &amp;offset);
657   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
658   EXPECT_EQ(offset, 38);
659   EXPECT_NEAR(static_cast&lt;double&gt;(val), 25.876, 0.01);
660   offset = 0;
661   val.fromXml("&lt;value&gt;&lt;double&gt;1foo&lt;/double&gt;&lt;/value&gt;", &amp;offset);
662   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
663   EXPECT_EQ(offset, 36);
664   EXPECT_EQ(static_cast&lt;double&gt;(val), 1);
665 }
666 TEST(XmlRpc, fromXmlImplicitString) {
667   int offset = 0;
668   XmlRpcValue val;
669   offset = 0;
670   val.fromXml("&lt;value&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/value&gt;", &amp;offset);
671   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
672   EXPECT_EQ(offset, 0);
673   offset = 0;
674   val.fromXml("&lt;value&gt;foo&lt;/value&gt;", &amp;offset);
675   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
676   EXPECT_EQ(offset, 18);
677   EXPECT_EQ(static_cast&lt;std::string&gt;(val), "foo");
678   EXPECT_EQ(val.size(), 3);
679 }
680 TEST(XmlRpc, fromXmlExplicitString) {
681   int offset = 0;
682   XmlRpcValue val;
683   offset = 0;
684   val.fromXml("&lt;value&gt;&lt;string&gt;", &amp;offset);
685   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
686   EXPECT_EQ(offset, 0);
687   offset = 0;
688   val.fromXml("&lt;value&gt;&lt;string&gt;&lt;/value&gt;", &amp;offset);
689   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
690   EXPECT_EQ(offset, 23);
691   EXPECT_EQ(static_cast&lt;std::string&gt;(val), "");
692   EXPECT_EQ(val.size(), 0);
693   offset = 0;
694   val.fromXml("&lt;value&gt;&lt;string&gt;foo&lt;/string&gt;&lt;/value&gt;", &amp;offset);
695   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
696   EXPECT_EQ(offset, 35);
697   EXPECT_EQ(static_cast&lt;std::string&gt;(val), "foo");
698   EXPECT_EQ(val.size(), 3);
699 }
700 TEST(XmlRpc, fromXmlDateTime) {
701   int offset = 0;
702   XmlRpcValue val;
703   struct tm expected{};
704   struct tm returned;
705   offset = 0;
706   val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;&lt;/dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
707   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
708   EXPECT_EQ(offset, 0);
709   offset = 0;
710   val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;", &amp;offset);
711   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
712   EXPECT_EQ(offset, 0);
713   offset = 0;
714   val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
715   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
716   EXPECT_EQ(offset, 0);
717   offset = 0;
718   val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
719   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
720   EXPECT_EQ(offset, 0);
721   offset = 0;
722   val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;000000T00:00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
723   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
724   EXPECT_EQ(offset, 0);
725   offset = 0;
726   val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:00&lt;/value&gt;", &amp;offset);
727   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
728   EXPECT_EQ(offset, 49);
729   returned = static_cast&lt;struct tm&gt;(val);
730   EXPECT_EQ(returned.tm_sec, expected.tm_sec);
731   EXPECT_EQ(returned.tm_min, expected.tm_min);
732   EXPECT_EQ(returned.tm_hour, expected.tm_hour);
733   EXPECT_EQ(returned.tm_mday, expected.tm_mday);
734   EXPECT_EQ(returned.tm_mon, expected.tm_mon);
735   EXPECT_EQ(returned.tm_year, expected.tm_year);
736   EXPECT_EQ(returned.tm_isdst, -1);
737   offset = 0;
738   val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:0&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
739   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
740   EXPECT_EQ(offset, 66);
741   returned = static_cast&lt;struct tm&gt;(val);
742   EXPECT_EQ(returned.tm_sec, expected.tm_sec);
743   EXPECT_EQ(returned.tm_min, expected.tm_min);
744   EXPECT_EQ(returned.tm_hour, expected.tm_hour);
745   EXPECT_EQ(returned.tm_mday, expected.tm_mday);
746   EXPECT_EQ(returned.tm_mon, expected.tm_mon);
747   EXPECT_EQ(returned.tm_year, expected.tm_year);
748   EXPECT_EQ(returned.tm_isdst, -1);
749   offset = 0;
750   val.fromXml("&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;", &amp;offset);
751   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
752   EXPECT_EQ(offset, 67);
753   returned = static_cast&lt;struct tm&gt;(val);
754   EXPECT_EQ(returned.tm_sec, expected.tm_sec);
755   EXPECT_EQ(returned.tm_min, expected.tm_min);
756   EXPECT_EQ(returned.tm_hour, expected.tm_hour);
757   EXPECT_EQ(returned.tm_mday, expected.tm_mday);
758   EXPECT_EQ(returned.tm_mon, expected.tm_mon);
759   EXPECT_EQ(returned.tm_year, expected.tm_year);
760   EXPECT_EQ(returned.tm_isdst, -1);
761 }
762 TEST(XmlRpc, fromXmlBase64) {
763   int offset = 0;
764   XmlRpcValue val;
765   offset = 0;
766   val.fromXml("&lt;value&gt;&lt;base64&gt;", &amp;offset);
767   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
768   EXPECT_EQ(offset, 0);
769   offset = 0;
770   val.fromXml("&lt;value&gt;&lt;base64&gt;&lt;/base64&gt;&lt;/value&gt;", &amp;offset);
771   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
772   EXPECT_EQ(offset, 32);
773   EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), XmlRpc::XmlRpcValue::BinaryData());
774   EXPECT_EQ(val.size(), 0);
775   offset = 0;
776   val.fromXml("&lt;value&gt;&lt;base64&gt;____&lt;/base64&gt;&lt;/value&gt;", &amp;offset);
777   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
778   EXPECT_EQ(offset, 36);
779   EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), XmlRpc::XmlRpcValue::BinaryData());
780   EXPECT_EQ(val.size(), 0);
781   XmlRpc::XmlRpcValue::BinaryData expected{'h', 'e', 'l', 'l', 'o'};
782   offset = 0;
783   val.fromXml("&lt;value&gt;&lt;base64&gt;aGVsbG8=&lt;/base64&gt;&lt;/value&gt;", &amp;offset);
784   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
785   EXPECT_EQ(offset, 40);
786   EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), expected);
787   EXPECT_EQ(val.size(), 5);
788 }
789 TEST(XmlRpc, fromXmlArray) {
790   int offset = 0;
791   XmlRpcValue val;
792   offset = 0;
793   val.fromXml("&lt;value&gt;&lt;array&gt;", &amp;offset);
794   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
795   EXPECT_EQ(offset, 0);
796   offset = 0;
797   val.fromXml("&lt;value&gt;&lt;array&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
798   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
799   EXPECT_EQ(offset, 0);
800   offset = 0;
801   val.fromXml("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
802   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
803   EXPECT_EQ(offset, 43);
804   EXPECT_EQ(val.size(), 0);
805   offset = 0;
806   val.fromXml("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
807   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
808   EXPECT_EQ(offset, 78);
809   EXPECT_EQ(val.size(), 1);
810   EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);
811   offset = 0;
812   val.fromXml("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
813   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
814   EXPECT_EQ(offset, 71);
815   EXPECT_EQ(val.size(), 1);
816   EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);
817   offset = 0;
818   val.fromXml("&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;value&gt;&lt;double&gt;23.4&lt;/double&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;", &amp;offset);
819   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
820   EXPECT_EQ(offset, 114);
821   EXPECT_EQ(val.size(), 2);
822   EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);
823   EXPECT_NEAR(static_cast&lt;double&gt;(val[1]), 23.4, 0.01);
824 }
825 TEST(XmlRpc, fromXmlStruct) {
826   int offset = 0;
827   XmlRpcValue val;
828   offset = 0;
829   val.fromXml("&lt;value&gt;&lt;struct&gt;", &amp;offset);
830   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
831   EXPECT_EQ(offset, 15);
832   EXPECT_EQ(val.size(), 0);
833   offset = 0;
834   val.fromXml("&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/value&gt;", &amp;offset);
835   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
836   EXPECT_EQ(offset, 48);
837   EXPECT_EQ(val.size(), 1);
838   EXPECT_EQ(static_cast&lt;bool&gt;(val[""]), true);
839   offset = 0;
840   val.fromXml("&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;", &amp;offset);
841   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
842   EXPECT_EQ(offset, 84);
843   EXPECT_EQ(val.size(), 1);
844   EXPECT_EQ(static_cast&lt;bool&gt;(val[""]), true);
845   offset = 0;
846   val.fromXml("&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;&lt;/name&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;", &amp;offset);
847   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
848   EXPECT_EQ(offset, 97);
849   EXPECT_EQ(val.size(), 1);
850   EXPECT_EQ(static_cast&lt;bool&gt;(val[""]), true);
851   offset = 0;
852   val.fromXml("&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;foo&lt;/name&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;", &amp;offset);
853   EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
854   EXPECT_EQ(offset, 100);
855   EXPECT_EQ(val.size(), 1);
856   EXPECT_EQ(static_cast&lt;bool&gt;(val["foo"]), true);
857 }
858 int main(int argc, char **argv)
859 {
860   ::testing::InitGoogleTest(&amp;argc, argv);
861   return RUN_ALL_TESTS();
862 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
