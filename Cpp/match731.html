<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for serialization.cpp & TestValues.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for serialization.cpp & TestValues.cpp
      </h3>
      <h1 align="center">
        3.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>serialization.cpp (5.426357%)<TH>TestValues.cpp (2.1472392%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match731-0.html#0',2,'match731-1.html#0',3)" NAME="0">(432-442)<TD><A HREF="javascript:ZweiFrames('match731-0.html#0',2,'match731-1.html#0',3)" NAME="0">(136-167)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>serialization.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2009, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Willow Garage, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/* Author: Josh Faust */

/*
 * Test serialization templates
 */

#include &lt;gtest/gtest.h&gt;
#include &lt;ros/static_assert.h&gt;
#include &lt;std_msgs/Header.h&gt;
#include &quot;helpers.h&quot;

using namespace ros;
using namespace ros::serialization;
using namespace test_roscpp;

ROS_STATIC_ASSERT(sizeof(ros::Time) == 8);
ROS_STATIC_ASSERT(sizeof(ros::Duration) == 8);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tests for compilation/validity of serialization/deserialization of primitive types
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define PRIMITIVE_SERIALIZATION_TEST(Type, SerInit, DeserInit) \
  TEST(Serialization, Type) \
  { \
    Type ser_val SerInit; \
    Type deser_val DeserInit; \
    Array b = serializeAndDeserialize(ser_val, deser_val); \
    EXPECT_EQ(*(Type*)b.get(), ser_val); \
    EXPECT_EQ(ser_val, deser_val); \
  }

PRIMITIVE_SERIALIZATION_TEST(uint8_t, (5), (0));
PRIMITIVE_SERIALIZATION_TEST(int8_t, (5), (0));
PRIMITIVE_SERIALIZATION_TEST(uint16_t, (5), (0));
PRIMITIVE_SERIALIZATION_TEST(int16_t, (5), (0));
PRIMITIVE_SERIALIZATION_TEST(uint32_t, (5), (0));
PRIMITIVE_SERIALIZATION_TEST(int32_t, (5), (0));
PRIMITIVE_SERIALIZATION_TEST(uint64_t, (5), (0));
PRIMITIVE_SERIALIZATION_TEST(int64_t, (5), (0));
PRIMITIVE_SERIALIZATION_TEST(float, (5.0f), (0.0f));
PRIMITIVE_SERIALIZATION_TEST(double, (5.0), (0.0));
PRIMITIVE_SERIALIZATION_TEST(Time, (500, 10000), (0, 0));
PRIMITIVE_SERIALIZATION_TEST(Duration, (500, 10000), (0, 0));

#define PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(Type, Start, Increment) \
  TEST(Serialization, variableLengthArray_##Type) \
  { \
    std::vector&lt;Type&gt; ser_val, deser_val; \
    Type val = Start; \
    for (uint32_t i = 0; i &lt; 8; ++i) \
    { \
      ser_val.push_back(val); \
      val = val + Increment; \
    } \
    \
    Array b = serializeAndDeserialize(ser_val, deser_val); \
    EXPECT_TRUE(ser_val == deser_val); \
    \
    EXPECT_EQ(*(uint32_t*)b.get(), (uint32_t)ser_val.size()); \
    for(size_t i = 0; i &lt; ser_val.size(); ++i) \
    { \
      Type* ptr = ((Type*)(b.get() + 4)) + i; \
      EXPECT_EQ(*ptr, ser_val[i]); \
    } \
  }

PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(uint8_t, 65, 1);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(int8_t, 65, 1);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(uint16_t, 0, 100);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(int16_t, 0, 100);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(uint32_t, 0, 100);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(int32_t, 0, 100);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(uint64_t, 0, 100);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(int64_t, 0, 100);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(float, 0.0f, 100.0f);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(double, 0.0, 100.0);
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(Time, Time(), Duration(100));
PRIMITIVE_VARIABLE_LENGTH_ARRAY_TEST(Duration, Duration(), Duration(100));

#define PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(Type, Start, Increment) \
  TEST(Serialization, fixedLengthArray_##Type) \
  { \
    boost::array&lt;Type, 8&gt; ser_val, deser_val; \
    Type val = Start; \
    for (uint32_t i = 0; i &lt; 8; ++i) \
    { \
      ser_val[i] = val; \
      val = val + Increment; \
    } \
    \
    Array b = serializeAndDeserialize(ser_val, deser_val); \
    EXPECT_TRUE(ser_val == deser_val); \
    \
    for(size_t i = 0; i &lt; ser_val.size(); ++i) \
    { \
      Type* ptr = ((Type*)b.get()) + i; \
      EXPECT_EQ(*ptr, ser_val[i]); \
    } \
  }

PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(uint8_t, 65, 1);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(int8_t, 65, 1);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(uint16_t, 0, 100);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(int16_t, 0, 100);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(uint32_t, 0, 100);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(int32_t, 0, 100);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(uint64_t, 0, 100);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(int64_t, 0, 100);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(float, 0.0f, 100.0f);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(double, 0.0, 100.0);
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(Time, Time(), Duration(100));
PRIMITIVE_FIXED_LENGTH_ARRAY_TEST(Duration, Duration(), Duration(100));

TEST(Serialization, string)
{
  std::string ser_val = &quot;hello world&quot;;
  std::string deser_val;
  Array b = serializeAndDeserialize(ser_val, deser_val);
  EXPECT_STREQ(ser_val.c_str(), deser_val.c_str());

  EXPECT_EQ(*(uint32_t*)b.get(), (uint32_t)ser_val.size());
  EXPECT_EQ(memcmp(b.get() + 4, ser_val.data(), ser_val.size()), 0);
}

TEST(Serialization, variableLengthArray_string)
{
  std::vector&lt;std::string&gt; ser_val, deser_val;
  ser_val.push_back(&quot;hello world&quot;);
  ser_val.push_back(&quot;hello world22&quot;);
  ser_val.push_back(&quot;hello world333&quot;);
  ser_val.push_back(&quot;hello world4444&quot;);
  ser_val.push_back(&quot;hello world55555&quot;);
  Array b = serializeAndDeserialize(ser_val, deser_val);
  EXPECT_TRUE(ser_val == deser_val);
}

TEST(Serialization, fixedLengthArray_string)
{
  boost::array&lt;std::string, 5&gt; ser_val, deser_val;
  ser_val[0] = &quot;hello world&quot;;
  ser_val[1] = &quot;hello world22&quot;;
  ser_val[2] = &quot;hello world333&quot;;
  ser_val[3] = &quot;hello world4444&quot;;
  ser_val[4] = &quot;hello world55555&quot;;
  Array b = serializeAndDeserialize(ser_val, deser_val);
  EXPECT_TRUE(ser_val == deser_val);
}

////////////////////////////////////////////////////////////////////////////////////////////
// Test custom types and traits
////////////////////////////////////////////////////////////////////////////////////////////

// Class used to make sure fixed-size simple structs use a memcpy when serializing an array of them
// serialization only serializes a, memcpy will get both a and b.
struct FixedSizeSimple
{
  FixedSizeSimple()
  : a(0)
  , b(0)
  {}

  int32_t a;
  int32_t b;
};

namespace ros
{
namespace message_traits
{
template&lt;&gt; struct IsFixedSize&lt;FixedSizeSimple&gt; : public TrueType {};
template&lt;&gt; struct IsSimple&lt;FixedSizeSimple&gt; : public TrueType {};
} // namespace message_traits

namespace serialization
{
template&lt;&gt;
struct Serializer&lt;FixedSizeSimple&gt;
{
  template&lt;typename Stream&gt;
  inline static void write(Stream&amp; stream, const FixedSizeSimple&amp; v)
  {
    serialize(stream, v.a);
  }

  template&lt;typename Stream&gt;
  inline static void read(Stream&amp; stream, FixedSizeSimple&amp; v)
  {
    deserialize(stream, v.a);
  }

  inline static uint32_t serializedLength(const FixedSizeSimple&amp;)
  {
    return 4;
  }
};
} // namespace serialization
} // namespace ros

TEST(Serialization, fixedSizeSimple_vector)
{
  {
    FixedSizeSimple in, out;
    in.a = 1;
    in.b = 1;

    serializeAndDeserialize(in, out);
    ASSERT_EQ(out.a, 1);
    ASSERT_EQ(out.b, 0);
  }

  {
    std::vector&lt;FixedSizeSimple&gt; in, out;
    in.resize(1);
    in[0].a = 1;
    in[0].b = 1;

    serializeAndDeserialize(in, out);
    ASSERT_EQ(out[0].a, 1);
    ASSERT_EQ(out[0].b, 1);
  }
}

TEST(Serialization, fixedSizeSimple_array)
{
  boost::array&lt;FixedSizeSimple, 2&gt; in, out;
  in[0].a = 1;
  in[0].b = 1;

  serializeAndDeserialize(in, out);
  ASSERT_EQ(out[0].a, 1);
  ASSERT_EQ(out[0].b, 1);
}

// Class used to make sure fixed-size non-simple structs only query the length of the first element
// in an array.
struct FixedSizeNonSimple
{
  FixedSizeNonSimple()
  : length_to_report(4)
  {}

  int32_t length_to_report;
};

namespace ros
{
namespace message_traits
{
template&lt;&gt; struct IsFixedSize&lt;FixedSizeNonSimple&gt; : public TrueType {};
} // namespace message_traits

namespace serialization
{
template&lt;&gt;
struct Serializer&lt;FixedSizeNonSimple&gt;
{
  inline static uint32_t serializedLength(const FixedSizeNonSimple&amp; v)
  {
    return v.length_to_report;
  }
};
} // namespace serialization
} // namespace ros

TEST(Serialization, fixedSizeNonSimple_vector)
{
  std::vector&lt;FixedSizeNonSimple&gt; in;
  in.resize(2);
  in[1].length_to_report = 100;

  int32_t len = ros::serialization::serializationLength(in);
  ASSERT_EQ(len, 12);  // 12 = 4 bytes for each item + 4-byte array length
}

TEST(Serialization, fixedSizeNonSimple_array)
{
  boost::array&lt;FixedSizeNonSimple, 2&gt; in;
  in[1].length_to_report = 100;

  int32_t len = ros::serialization::serializationLength(in);
  ASSERT_EQ(len, 8);  // 8 = 4 bytes for each item
}

// Class used to make sure variable-size structs query the length of the every element
// in an array.
struct VariableSize
{
  VariableSize()
  : length_to_report(4)
  {}

  int32_t length_to_report;
};

namespace ros
{
namespace serialization
{
template&lt;&gt;
struct Serializer&lt;VariableSize&gt;
{
  inline static uint32_t serializedLength(const VariableSize&amp; v)
  {
    return v.length_to_report;
  }
};
} // namespace serialization
} // namespace ros

TEST(Serialization, variableSize_vector)
{
  std::vector&lt;VariableSize&gt; in;
  in.resize(2);
  in[1].length_to_report = 100;

  int32_t len = ros::serialization::serializationLength(in);
  ASSERT_EQ(len, 108);  // 108 = 4 bytes for the first item + 100 bytes for the second + 4-byte array length
}

TEST(Serialization, variableSize_array)
{
  boost::array&lt;VariableSize, 2&gt; in;
  in[1].length_to_report = 100;

  int32_t len = ros::serialization::serializationLength(in);
  ASSERT_EQ(len, 104);  // 104 = 4 bytes for the first item + 100 bytes for the second
}

struct AllInOneSerializer
{
  uint32_t a;
};

namespace ros
{
namespace serialization
{
template&lt;&gt;
struct Serializer&lt;AllInOneSerializer&gt;
{
  template&lt;typename Stream, typename T&gt;
  inline static void allInOne(Stream&amp; stream, T t)
  {
    stream.next(t.a);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER
};
} // namespace serialization
} // namespace ros

TEST(Serialization, allInOne)
{
  AllInOneSerializer in, out;
  in.a = 5;
  serializeAndDeserialize(in, out);
  ASSERT_EQ(out.a, in.a);
}

// Class with a header, used to ensure message_traits::header(m) returns the header
struct WithHeader
{
  WithHeader()
  {}

  std_msgs::Header header;
};

// Class without a header, used to ensure message_traits::header(m) return NULL
struct WithoutHeader
{
  WithoutHeader()
  {}
};

namespace ros
{
namespace message_traits
{
template&lt;&gt; struct HasHeader&lt;WithHeader&gt; : public TrueType {};
} // namespace message_traits
} // namespace ros

TEST(MessageTraits, headers)
{
  WithHeader wh;
  WithoutHeader woh;
  const WithHeader cwh;
  const WithoutHeader cwoh;

  wh.header.seq = 100;
  ASSERT_TRUE(ros::message_traits::header(wh) != 0);
  ASSERT_EQ(ros::message_traits::header(wh)-&gt;seq, 100UL);

  ASSERT_TRUE(ros::message_traits::header(woh) == 0);

  ASSERT_TRUE(ros::message_traits::header(cwh) != 0);
  ASSERT_TRUE(ros::message_traits::header(cwoh) == 0);
<A NAME="0"></A>
  ASSERT_TRUE(ros::message_traits::frameId(wh) != 0);
  ASSERT_TRUE(ros::message_traits::frameId(woh) == 0);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match731-1.html#0',3,'match731-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  ASSERT_TRUE(ros::message_traits::frameId(cwh) != 0);
  ASSERT_TRUE(ros::message_traits::frameId(cwoh) == 0);

  ASSERT_TRUE(ros::message_traits::timeStamp(wh) != 0);
  ASSERT_TRUE(ros::message_traits::timeStamp(woh) == 0);
  ASSERT_TRUE(ros::message_traits::timeStamp(cwh) != 0);
  ASSERT_TRUE(ros::message_traits::timeStamp(cwoh) == 0);
}

TEST(Serialization, bufferOverrun)
{</B></FONT>
  Array b(new uint8_t[4]);
  IStream stream(b.get(), 4);
  uint32_t i;
  deserialize(stream, i);
  try
  {
    deserialize(stream, i);
    FAIL();
  }
  catch(ros::Exception&amp;)
  {
    SUCCEED();
  }
}

TEST(Serialization, streamOperators)
{
  Array b(new uint8_t[4]);
  OStream ostream(b.get(), 4);
  uint32_t a = 5;
  ostream &lt;&lt; a;
  a = 100;
  IStream istream(b.get(), 4);
  istream &gt;&gt; a;
  ASSERT_EQ(a, 5UL);
}

int main(int argc, char** argv)
{
  testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}



</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestValues.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Unit tests for XmlRpc++
 *
 * Copyright (C) 2017, Zoox Inc
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Austin Hendrix &lt;austin@zoox.com&gt;
 * Loosely based on the original TestValues.cpp by Chris Morley
 *
 */

// TestValues.cpp : Test XML encoding and decoding of XmlRpcValues.

#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;climits&gt;

#include &quot;xmlrpcpp/XmlRpcValue.h&quot;
#include &quot;xmlrpcpp/XmlRpcException.h&quot;
#include &quot;xmlrpcpp/XmlRpcUtil.h&quot;

#include &lt;gtest/gtest.h&gt;

using namespace XmlRpc;

TEST(XmlRpc, Bool) {
  XmlRpcValue v(bool(false));

  EXPECT_EQ(&quot;&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;&quot;, v.toXml());

  XmlRpcValue v2;
  v2[0] = int(1);
  v2[1] = std::string();
  v2[2] = XmlRpcValue(false);
  EXPECT_EQ(&quot;&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt;&lt;value&gt;&lt;/&quot;
            &quot;value&gt;&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;&quot;,
            v2.toXml());
}

TEST(XmlRpc, testBoolean) {
  const XmlRpcValue booleanFalse(false);
  XmlRpcValue booleanTrue(true);
  int offset = 0;
  XmlRpcValue booleanFalseXml(&quot;&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  offset = 0;
  XmlRpcValue booleanTrueXml(&quot;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_NE(booleanFalse, booleanTrue);
  EXPECT_EQ(booleanFalse, booleanFalseXml);
  EXPECT_NE(booleanFalse, booleanTrueXml);

  EXPECT_FALSE(bool(booleanFalse));

  EXPECT_TRUE(bool(booleanTrue));

  // Test stream operator.
  std::stringstream ss;
  ss &lt;&lt; booleanFalse;
  EXPECT_EQ(&quot;0&quot;, ss.str());

  std::stringstream ss2;
  ss2 &lt;&lt; booleanTrue;
  EXPECT_EQ(&quot;1&quot;, ss2.str());
}

// Int
TEST(XmlRpc, testInt) {
  const XmlRpcValue int0(0);
  ASSERT_EQ(XmlRpcValue::TypeInt, int0.getType());

  XmlRpcValue int1(1);
  ASSERT_EQ(XmlRpcValue::TypeInt, int1.getType());

  XmlRpcValue int10(10);
  ASSERT_EQ(XmlRpcValue::TypeInt, int10.getType());

  XmlRpcValue int_1(-1);
  ASSERT_EQ(XmlRpcValue::TypeInt, int_1.getType());

  int offset = 0;
  XmlRpcValue int0Xml(&quot;&lt;value&gt;&lt;int&gt;0&lt;/int&gt;&lt;/value&gt;&quot;, &amp;offset);
  ASSERT_EQ(XmlRpcValue::TypeInt, int0Xml.getType());
  EXPECT_EQ(0, int(int0Xml));

  offset = 0;
  XmlRpcValue int9Xml(&quot;&lt;value&gt;&lt;i4&gt;9&lt;/i4&gt;&lt;/value&gt;&quot;, &amp;offset);
  ASSERT_EQ(XmlRpcValue::TypeInt, int9Xml.getType());
  EXPECT_EQ(9, int(int9Xml));

  EXPECT_EQ(int0, int0Xml);
  EXPECT_EQ(int(int10) - int(int1), int(int9Xml));
  EXPECT_EQ(9, int(int9Xml));
  EXPECT_EQ(int(int10) + int(int_1), int(int9Xml));

  // Test stream operator.
  std::stringstream ss;
  ss &lt;&lt; int9Xml;
  EXPECT_EQ(&quot;9&quot;, ss.str());
}

TEST(XmlRpc, testDouble) {
  // Double
  const XmlRpcValue d(43.7);
  ASSERT_EQ(XmlRpcValue::TypeDouble, d.getType());
  EXPECT_EQ(&quot;&lt;value&gt;&lt;double&gt;43.700000000000003&lt;/double&gt;&lt;/value&gt;&quot;, d.toXml());
  EXPECT_DOUBLE_EQ(43.7, double(d));

  int offset = 0;
  XmlRpcValue dXml(&quot;&lt;value&gt;&lt;double&gt;56.3&lt;/double&gt;&lt;/value&gt;&quot;, &amp;offset);
  ASSERT_EQ(XmlRpcValue::TypeDouble, dXml.getType());
  EXPECT_DOUBLE_EQ(56.3, double(dXml));

  EXPECT_DOUBLE_EQ(100.0, double(d) + double(dXml));

  // Test stream operator.
  std::stringstream ss;
  ss &lt;&lt; d;
  EXPECT_EQ(&quot;43.7&quot;, ss.str());
  ss.str(&quot;&quot;);

<A NAME="0"></A>  // Test format
  const XmlRpc::XmlRpcValue a(2.0);
  ASSERT_EQ(XmlRpcValue::TypeDouble, d.getType());
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match731-0.html#0',2,'match731-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  const std::string save_format = XmlRpc::XmlRpcValue::getDoubleFormat();

  XmlRpc::XmlRpcValue::setDoubleFormat(&quot;%32.10f&quot;);
  ss &lt;&lt; a;
  EXPECT_EQ(&quot;                    2.0000000000&quot;, ss.str());
  ss.str(&quot;&quot;);

  XmlRpc::XmlRpcValue::setDoubleFormat(&quot;%10.32f&quot;);
  ss &lt;&lt; a;
  EXPECT_EQ(&quot;2.00000000000000000000000000000000&quot;, ss.str());
  ss.str(&quot;&quot;);

  XmlRpc::XmlRpcValue::setDoubleFormat(&quot;%128.10f&quot;);
  ss &lt;&lt; a;
  EXPECT_EQ(&quot;                                &quot;
            &quot;                                &quot;
            &quot;                                &quot;
            &quot;                    2.000000000&quot;, ss.str());
  ss.str(&quot;&quot;);

  XmlRpc::XmlRpcValue::setDoubleFormat(&quot;%10.128f&quot;);
  ss &lt;&lt; a;
  EXPECT_EQ(&quot;2.000000000000000000000000000000&quot;
            &quot;00000000000000000000000000000000&quot;
            &quot;00000000000000000000000000000000&quot;
            &quot;000000000000000000000000000000000&quot;, ss.str());
  ss.str(&quot;&quot;);

  XmlRpc::XmlRpcValue::setDoubleFormat(save_format.c_str());
}

TEST(XmlRpc, testString) {</B></FONT>
  // String
  const XmlRpcValue s(&quot;Now is the time &lt;&amp;&quot;);
  ASSERT_EQ(XmlRpcValue::TypeString, s.getType());
  EXPECT_EQ(18, s.size());
  EXPECT_EQ(&quot;&lt;value&gt;Now is the time &amp;lt;&amp;amp;&lt;/value&gt;&quot;, s.toXml());

  char csxml[] = &quot;&lt;value&gt;&lt;string&gt;Now is the time &amp;lt;&amp;amp;&lt;/string&gt;&lt;/value&gt;&quot;;
  std::string ssxml = csxml;

  int offset = 0;
  XmlRpcValue vscXml(csxml, &amp;offset);
  EXPECT_EQ(s, vscXml);

  offset = 0;
  XmlRpcValue vssXml(ssxml, &amp;offset);
  EXPECT_EQ(s, vssXml);

  offset = 0;
  XmlRpcValue fromXml(vssXml.toXml(), &amp;offset);
  EXPECT_EQ(s, fromXml);

  // Empty or blank strings with no &lt;string&gt; tags
  std::string emptyStringXml(&quot;&lt;value&gt;&lt;/value&gt;&quot;);
  offset = 0;
  XmlRpcValue emptyStringVal1(emptyStringXml, &amp;offset);
  XmlRpcValue emptyStringVal2(&quot;&quot;);
  EXPECT_EQ(emptyStringVal1, emptyStringVal2);

  emptyStringXml = &quot;&lt;value&gt;  &lt;/value&gt;&quot;;
  offset = 0;
  XmlRpcValue blankStringVal(emptyStringXml, &amp;offset);
  EXPECT_EQ(std::string(blankStringVal), &quot;  &quot;);

  // Implicitly initialized string.
  XmlRpcValue s2;
  std::string tmp = s2;
  EXPECT_EQ(&quot;&quot;, tmp);
  EXPECT_EQ(&quot;&quot;, (std::string)s2);

  // Test stream operator.
  std::stringstream ss;
  ss &lt;&lt; s;
  EXPECT_EQ(&quot;Now is the time &lt;&amp;&quot;, ss.str());
}

//Test decoding of a well-formed but overly large XML input
TEST(XmlRpc, testOversizeString) {
  try {
    std::string xml = &quot;&lt;tag&gt;&lt;nexttag&gt;&quot;;
    xml += std::string(INT_MAX, 'a');
    xml += &quot;a&lt;/nexttag&gt;&lt;/tag&gt;&quot;;
    int offset;

    offset = 0;
    EXPECT_EQ(XmlRpcUtil::parseTag(&quot;&lt;tag&gt;&quot;, xml, &amp;offset), std::string());
    EXPECT_EQ(offset, 0);

    offset = 0;
    EXPECT_FALSE(XmlRpcUtil::findTag(&quot;&lt;tag&gt;&quot;, xml, &amp;offset));
    EXPECT_EQ(offset, 0);

    offset = 0;
    EXPECT_FALSE(XmlRpcUtil::nextTagIs(&quot;&lt;tag&gt;&quot;, xml, &amp;offset));
    EXPECT_EQ(offset, 0);

    offset = 0;
    EXPECT_EQ(XmlRpcUtil::getNextTag(xml, &amp;offset), std::string());
    EXPECT_EQ(offset, 0);
  }
  catch (std::bad_alloc&amp; err) {
#ifdef GTEST_SKIP
    GTEST_SKIP() &lt;&lt; &quot;Unable to allocate memory to run test\n&quot;;
#else
    std::cerr &lt;&lt; &quot;[ SKIPPED  ] XmlRpc.testOversizeString Unable to allocate memory to run test\n&quot;;
#endif
  }
}

TEST(XmlRpc, testParseTag) {
  int offset = 0;

  // Test a null tag
  EXPECT_EQ(XmlRpcUtil::parseTag(NULL, &quot;&quot;, &amp;offset), std::string());
  EXPECT_EQ(offset, 0);

  // Test a null offset
  EXPECT_EQ(XmlRpcUtil::parseTag(&quot;&lt;tag&gt;&quot;, &quot;&quot;, NULL), std::string());
  EXPECT_EQ(offset, 0);

  // Test if the offset is beyond the end of the input xml
  offset = 20;
  EXPECT_EQ(XmlRpcUtil::parseTag(&quot;&lt;tag&gt;&quot;, &quot;&quot;, &amp;offset), std::string());
  EXPECT_EQ(offset, 20);

  // Test if the tag is not found in the input xml
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::parseTag(&quot;&lt;tag&gt;&quot;, &quot;&lt;foo&gt;&lt;/foo&gt;&quot;, &amp;offset), std::string());
  EXPECT_EQ(offset, 0);

  // Test if the tag is found, but the end tag is not
  EXPECT_EQ(XmlRpcUtil::parseTag(&quot;&lt;tag&gt;&quot;, &quot;&lt;tag&gt;&quot;, &amp;offset), std::string());
  EXPECT_EQ(offset, 0);

  // Test if the tag is found, the end tag is found, and there is a value in the middle
  EXPECT_EQ(XmlRpcUtil::parseTag(&quot;&lt;tag&gt;&quot;, &quot;&lt;tag&gt;foo&lt;/tag&gt;&quot;, &amp;offset), &quot;foo&quot;);
  EXPECT_EQ(offset, 14);
}

TEST(XmlRpc, testFindTag) {
  int offset = 0;

  // Test a null tag
  EXPECT_FALSE(XmlRpcUtil::findTag(NULL, &quot;&quot;, &amp;offset));
  EXPECT_EQ(offset, 0);

  // Test a null offset
  EXPECT_FALSE(XmlRpcUtil::findTag(&quot;&lt;tag&gt;&quot;, &quot;&quot;, NULL));
  EXPECT_EQ(offset, 0);

  // Test if the offset is beyond the end of the input xml
  offset = 20;
  EXPECT_FALSE(XmlRpcUtil::findTag(&quot;&lt;tag&gt;&quot;, &quot;&quot;, &amp;offset));
  EXPECT_EQ(offset, 20);

  // Test that the offset moves when finding a tag
  offset = 0;
  EXPECT_TRUE(XmlRpcUtil::findTag(&quot;&lt;subtag&gt;&quot;, &quot;&lt;tag&gt;&lt;subtag&gt;&lt;/subtag&gt;&lt;/tag&gt;&quot;, &amp;offset));
  EXPECT_EQ(offset, 13);
}

TEST(XmlRpc, testNextTagIs) {
  int offset = 0;

  // Test a null tag
  EXPECT_FALSE(XmlRpcUtil::nextTagIs(NULL, &quot;&quot;, &amp;offset));
  EXPECT_EQ(offset, 0);

  // Test a null offset
  EXPECT_FALSE(XmlRpcUtil::nextTagIs(&quot;&lt;tag&gt;&quot;, &quot;&quot;, NULL));
  EXPECT_EQ(offset, 0);

  // Test if the offset is beyond the end of the input xml
  offset = 20;
  EXPECT_FALSE(XmlRpcUtil::nextTagIs(&quot;&lt;tag&gt;&quot;, &quot;&quot;, &amp;offset));
  EXPECT_EQ(offset, 20);

  // Test that the offset moves when finding a tag with no whitespace
  offset = 0;
  EXPECT_TRUE(XmlRpcUtil::nextTagIs(&quot;&lt;tag&gt;&quot;, &quot;&lt;tag&gt;&lt;/tag&gt;&quot;, &amp;offset));
  EXPECT_EQ(offset, 5);

  // Test that the offset moves when finding a tag with whitespace
  offset = 0;
  EXPECT_TRUE(XmlRpcUtil::nextTagIs(&quot;&lt;tag&gt;&quot;, &quot;      &lt;tag&gt;&lt;/tag&gt;&quot;, &amp;offset));
  EXPECT_EQ(offset, 11);

  // Test that the offset doesn't move when the tag is not found
  offset = 0;
  EXPECT_FALSE(XmlRpcUtil::nextTagIs(&quot;&lt;tag&gt;&quot;, &quot;      &lt;footag&gt;&lt;/footag&gt;&quot;, &amp;offset));
  EXPECT_EQ(offset, 0);
}

TEST(XmlRpc, testGetNextTag) {
  int offset = 0;

  // Test a null offset
  EXPECT_EQ(XmlRpcUtil::getNextTag(&quot;&quot;, NULL), std::string());
  EXPECT_EQ(offset, 0);

  // Test if the offset is beyond the end of the input xml
  offset = 20;
  EXPECT_EQ(XmlRpcUtil::getNextTag(&quot;&lt;tag&gt;&quot;, &amp;offset), std::string());
  EXPECT_EQ(offset, 20);

  // Test that the offset moves when finding a tag with no whitespace
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag(&quot;&lt;tag&gt;&lt;/tag&gt;&quot;, &amp;offset), &quot;&lt;tag&gt;&quot;);
  EXPECT_EQ(offset, 5);

  // Test that the offset moves when finding a tag with whitespace
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag(&quot;      &lt;tag&gt;&lt;/tag&gt;&quot;, &amp;offset), &quot;&lt;tag&gt;&quot;);
  EXPECT_EQ(offset, 11);

  // Test that the offset doesn't move if there are no tags
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag(&quot;      foo&quot;, &amp;offset), std::string());
  EXPECT_EQ(offset, 0);

  // Test that the offset moves if there is a start &lt; but no end &gt;
  offset = 0;
  // FIXME: this should fail, but currently does not
  EXPECT_EQ(XmlRpcUtil::getNextTag(&quot;&lt;foo&quot;, &amp;offset), &quot;&lt;foo&quot;);
  EXPECT_EQ(offset, 4);

  // Test what happens if there is no data in the tag
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::getNextTag(&quot;&lt;&gt;&quot;, &amp;offset), &quot;&lt;&gt;&quot;);
  EXPECT_EQ(offset, 2);
}

TEST(XmlRpc, testNextTagData)
{
  int offset = 0;

  // Test a null tag
  EXPECT_EQ(XmlRpcUtil::nextTagData(NULL, &quot;&quot;, &amp;offset), std::string());
  EXPECT_EQ(offset, 0);

  // Test a null offset
  EXPECT_EQ(XmlRpcUtil::nextTagData(&quot;&lt;tag&gt;&quot;, &quot;&quot;, NULL), std::string());
  EXPECT_EQ(offset, 0);

  // Test if the offset is beyond the end of the input xml
  offset = 20;
  EXPECT_EQ(XmlRpcUtil::nextTagData(&quot;&lt;tag&gt;&quot;, &quot;&quot;, &amp;offset), std::string());
  EXPECT_EQ(offset, 20);

  // Test that the offset moves when finding a tag with no whitespace
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData(&quot;&lt;tag&gt;&quot;, &quot;&lt;tag&gt;&lt;/tag&gt;&quot;, &amp;offset), &quot;&quot;);
  EXPECT_EQ(offset, 11);

  // Test that the offset moves when finding a tag with whitespace
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData(&quot;&lt;tag&gt;&quot;, &quot;   &lt;tag&gt;&lt;/tag&gt;&quot;, &amp;offset), &quot;&quot;);
  EXPECT_EQ(offset, 14);

  // Test that the offset moves when finding a tag with whitespace
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData(&quot;&lt;tag&gt;&quot;, &quot;   &lt;tag&gt;foo&lt;/tag&gt;&quot;, &amp;offset), &quot;foo&quot;);
  EXPECT_EQ(offset, 17);

  // Test that the offset doesn't move when missing the tag
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData(&quot;&lt;tag&gt;&quot;, &quot;   &lt;foo&gt;&lt;/foo&gt;&quot;, &amp;offset), &quot;&quot;);
  EXPECT_EQ(offset, 0);

  // Test that the offset doesn't move when the close tag is after other tags
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData(&quot;&lt;tag&gt;&quot;, &quot;   &lt;tag&gt;&lt;foo&gt;&lt;/tag&gt;&quot;, &amp;offset), &quot;&quot;);
  EXPECT_EQ(offset, 0);

  // Test that the offset doesn't move if there is no closing tag
  offset = 0;
  EXPECT_EQ(XmlRpcUtil::nextTagData(&quot;&lt;tag&gt;&quot;, &quot;   &lt;tag&gt;foo&quot;, &amp;offset), &quot;&quot;);
  EXPECT_EQ(offset, 0);
}

TEST(XmlRpc, testDateTime) {
  // DateTime
  int offset = 0;
  // Construct from XML
  const XmlRpcValue dateTime(
      &quot;&lt;value&gt;&lt;dateTime.iso8601&gt;19040503T03:12:35&lt;/dateTime.iso8601&gt;&lt;/value&gt;&quot;,
      &amp;offset);
  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime.getType());
  struct tm t = dateTime;
  EXPECT_EQ(t.tm_year, 1904);
  EXPECT_EQ(t.tm_min, 12);
  EXPECT_EQ(t.tm_sec, 35);
  EXPECT_EQ(t.tm_hour, 3);
  EXPECT_EQ(t.tm_mday, 3);
  EXPECT_EQ(t.tm_mon, 5);

  EXPECT_EQ(
      &quot;&lt;value&gt;&lt;dateTime.iso8601&gt;19040503T03:12:35&lt;/dateTime.iso8601&gt;&lt;/value&gt;&quot;,
      dateTime.toXml());

  // Constructor from struct tm.
  XmlRpcValue dateTime2(&amp;t);
  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime2.getType());
  t = dateTime2;
  EXPECT_EQ(t.tm_year, 1904);
  EXPECT_EQ(t.tm_min, 12);

  // Implicit initialization by cast.
  XmlRpcValue dateTime3;
  t = dateTime3;
  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime3.getType());
  EXPECT_EQ(t.tm_year, 0);
  EXPECT_EQ(t.tm_min, 0);

  // Test stream operator.
  std::stringstream ss;
  ss &lt;&lt; dateTime;
  EXPECT_EQ(&quot;19040503T03:12:35&quot;, ss.str());

  // Tests for DateTime equality operator
  EXPECT_EQ(dateTime, dateTime2);

  // Copy operator
  dateTime3 = dateTime;
  EXPECT_EQ(dateTime, dateTime3);

  // Explicit mutable reference into dateTime2 so that we can modify it to make
  // it not equal to dateTime in various ways.
  t = dateTime;
  struct tm&amp; tm2 = dateTime2;
  // Seconds not equal.
  tm2.tm_sec = 0;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);

  // Minutes not equal.
  tm2.tm_min = 0;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);

  // Hours not equal.
  tm2.tm_hour = 0;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);

  // Day not equal.
  tm2.tm_mday = 1;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);

  // Month not equal.
  tm2.tm_mon = 1;
  EXPECT_NE(dateTime, dateTime2);
  tm2 = t;
  ASSERT_EQ(dateTime, dateTime2);

  // Year not equal.
  tm2.tm_year = 1988;
  EXPECT_NE(dateTime, dateTime2);
}

TEST(XmlRpc, testArray) {
  XmlRpcValue d(43.7);
  // Array
  XmlRpcValue a;
  a.setSize(4);
  a[0] = 1;
  a[1] = std::string(&quot;two&quot;);
  a[2] = 43.7;
  a[3] = &quot;four&quot;;
  EXPECT_EQ(XmlRpcValue::TypeArray, a.getType());
  EXPECT_EQ(int(a[0]), 1);
  EXPECT_EQ(a[2], d);

  char csaXml[] = &quot;&lt;value&gt;&lt;array&gt;\n&quot;
                  &quot;  &lt;data&gt;\n&quot;
                  &quot;    &lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt; \n&quot;
                  &quot;    &lt;value&gt; &lt;string&gt;two&lt;/string&gt;&lt;/value&gt;\n&quot;
                  &quot;    &lt;value&gt;&lt;double&gt;43.7&lt;/double&gt;&lt;/value&gt;\n&quot;
                  &quot;    &lt;value&gt;four&lt;/value&gt;\n&quot;
                  &quot;  &lt;/data&gt;\n&quot;
                  &quot;&lt;/array&gt;&lt;/value&gt;&quot;;

  int offset = 0;
  XmlRpcValue aXml(csaXml, &amp;offset);
  EXPECT_EQ(a, aXml);

  // Array copy works
  const XmlRpcValue copy(a);
  ASSERT_EQ(a.getType(), copy.getType());
  ASSERT_EQ(a.size(), copy.size());
  for (int i = 0; i &lt; 3; i++) {
    EXPECT_EQ(a[i], copy[i]);
  }
  // Test that comparison operator works.
  EXPECT_EQ(a, copy);

  // Test that comparison for unlike types returns false.
  EXPECT_NE(a, d);

  // Test stream operator.
  std::stringstream ss;
  ss &lt;&lt; a;
  EXPECT_EQ(&quot;{1,two,43.7,four}&quot;, ss.str());
}

TEST(XmlRpc, testStruct) {
  // Struct
  XmlRpcValue struct1;
  struct1[&quot;i4&quot;] = 1;
  struct1[&quot;str&quot;] = &quot;two&quot;;
  struct1[&quot;d&quot;] = 43.7;
  EXPECT_EQ(3, struct1.size());
  EXPECT_EQ(XmlRpcValue::TypeStruct, struct1.getType());
  EXPECT_TRUE(struct1.hasMember(&quot;i4&quot;));
  EXPECT_FALSE(struct1.hasMember(&quot;nowhere&quot;));

  // Test stream operator.
  std::stringstream ss;
  ss &lt;&lt; struct1;
  EXPECT_EQ(&quot;[d:43.7,i4:1,str:two]&quot;, ss.str());

  XmlRpcValue a;
  a.setSize(4);
  a[0] = 1;
  a[1] = std::string(&quot;two&quot;);
  a[2] = 43.7;
  a[3] = &quot;four&quot;;

  EXPECT_EQ(struct1[&quot;d&quot;], a[2]);

  char csStructXml[] = &quot;&lt;value&gt;&lt;struct&gt;\n&quot;
                       &quot;  &lt;member&gt;\n&quot;
                       &quot;    &lt;name&gt;i4&lt;/name&gt; \n&quot;
                       &quot;    &lt;value&gt;&lt;i4&gt;1&lt;/i4&gt;&lt;/value&gt; \n&quot;
                       &quot;  &lt;/member&gt;\n&quot;
                       &quot;  &lt;member&gt;\n&quot;
                       &quot;    &lt;name&gt;d&lt;/name&gt; \n&quot;
                       &quot;    &lt;value&gt;&lt;double&gt;43.7&lt;/double&gt;&lt;/value&gt;\n&quot;
                       &quot;  &lt;/member&gt;\n&quot;
                       &quot;  &lt;member&gt;\n&quot;
                       &quot;    &lt;name&gt;str&lt;/name&gt; \n&quot;
                       &quot;    &lt;value&gt; &lt;string&gt;two&lt;/string&gt;&lt;/value&gt;\n&quot;
                       &quot;  &lt;/member&gt;\n&quot;
                       &quot;&lt;/struct&gt;&lt;/value&gt;&quot;;

  int offset = 0;
  const XmlRpcValue structXml(csStructXml, &amp;offset);
  EXPECT_EQ(struct1, structXml);

  for (XmlRpcValue::iterator itr = struct1.begin(); itr != struct1.end();
       itr++) {
  }

  XmlRpcValue astruct;
  astruct[&quot;array&quot;] = a;
  EXPECT_EQ(astruct[&quot;array&quot;][2], struct1[&quot;d&quot;]);

  for (int i = 0; i &lt; 10; i++) {
    XmlRpcValue Event;
    Event[&quot;Name&quot;] = &quot;string&quot;;

    Event.clear();

    const int NELMTS = 100;
    int ii;

    for (ii = 0; ii &lt; NELMTS; ++ii) {
      char buf[40];
      sprintf(buf, &quot;%d&quot;, ii);
      Event[std::string(buf)] = buf;
    }

    Event.clear();

    for (ii = 0; ii &lt; NELMTS; ++ii) {
      char buf[40];
      sprintf(buf, &quot;%d&quot;, ii);
      if (ii != NELMTS / 2)
        Event[std::string(buf)] = ii;
      else
        for (int jj = 0; jj &lt; NELMTS; ++jj) {
          char bufj[40];
          sprintf(bufj, &quot;%d&quot;, jj);
          Event[std::string(buf)][std::string(bufj)] = bufj;
        }
    }

    for (ii = 0; ii &lt; NELMTS; ++ii) {
      char buf[40];
      sprintf(buf, &quot;%d&quot;, ii);
      if (ii != NELMTS / 2)
        EXPECT_EQ(Event[std::string(buf)], XmlRpcValue(ii));
      else
        EXPECT_EQ(Event[std::string(buf)].size(), NELMTS);
    }
  }
}

TEST(XmlRpc, base64) {
  char data[] = {1, 2};
  const XmlRpcValue bin(data, 2);

  EXPECT_EQ(XmlRpcValue::TypeBase64, bin.getType());
  EXPECT_EQ(2, bin.size());

  XmlRpcValue::BinaryData d = bin;
  EXPECT_EQ(d[0], 1);
  EXPECT_EQ(d[1], 2);

  EXPECT_EQ(&quot;&lt;value&gt;&lt;base64&gt;AQI=\n&lt;/base64&gt;&lt;/value&gt;&quot;, bin.toXml());

  // Test stream operator.
  std::stringstream ss;
  ss &lt;&lt; bin;
  EXPECT_EQ(&quot;AQI=\n&quot;, ss.str());

  // Constructor from XML
  int offset = 0;
  XmlRpcValue bin2(&quot;&lt;value&gt;&lt;base64&gt;AQI=&lt;/base64&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(XmlRpcValue::TypeBase64, bin2.getType());
  EXPECT_EQ(2, bin2.size());

  d = bin2;
  EXPECT_EQ(d[0], 1);
  EXPECT_EQ(d[1], 2);

  EXPECT_EQ(bin, bin2);

  // Implicit initialization.
  XmlRpcValue bin3;
  d = bin3;
  EXPECT_EQ(XmlRpcValue::TypeBase64, bin3.getType());
  EXPECT_EQ(0, bin3.size());
  EXPECT_EQ(0u, d.size());

  // Copy operator
  XmlRpcValue bin4;
  bin4 = bin;

  EXPECT_EQ(XmlRpcValue::TypeBase64, bin4.getType());
  EXPECT_EQ(2, bin4.size());

  d = bin4;
  EXPECT_EQ(d[0], 1);
  EXPECT_EQ(d[1], 2);
}

TEST(XmpRpc, errors) {
  // Value is initially invalid.
  XmlRpcValue value;
  EXPECT_FALSE(value.valid());
  EXPECT_EQ(&quot;&quot;, value.toXml());

  // Implicit bool initialization.
  bool v = (bool)value;
  EXPECT_FALSE(v);

  // Conversions to other types should now throw an XmlRpcException.
  EXPECT_THROW((void)(int)value, XmlRpcException);
  EXPECT_THROW(value[0], XmlRpcException);
  EXPECT_THROW(value[&quot;bar&quot;], XmlRpcException);

  // Tests on const objects.
  const XmlRpcValue&amp; ref = value;
  EXPECT_THROW(ref[0], XmlRpcException);
  // TODO(austin): is this really allowed on non-struct objects?
  EXPECT_FALSE(ref.hasMember(&quot;bar&quot;));

  // Check that the exception that is thrown is populated correctly.
  try {
    (void)int(value);
  } catch (XmlRpcException&amp; e) {
    EXPECT_EQ(&quot;type error&quot;, e.getMessage());
    EXPECT_EQ(-1, e.getCode());
  }

  // size() on bool should throw.
  EXPECT_THROW(value.size(), XmlRpcException);

  // Clear should result in invalid again.
  value.clear();
  EXPECT_FALSE(value.valid());
}

TEST(XmlRpc, int_errors) {
  XmlRpcValue value;
  // Implicit int initialization.
  int v = (int)value;
  EXPECT_EQ(0, v);
  EXPECT_EQ(0, (int)value);

  // Conversion to other types should now thrown an exception.
  EXPECT_THROW((void)(bool)value, XmlRpcException);
}

TEST(XmlRpc, array_errors) {
  XmlRpcValue value;
  // Implicit array creation.
  int v = value[0];
  EXPECT_EQ(0, v);
  EXPECT_THROW((void)(bool)value, XmlRpcException);
  EXPECT_EQ(1, value.size());

  // Access on a non-const array should implicitly create another element.
  EXPECT_EQ(0, (int)value[1]);
  EXPECT_EQ(2, value.size());

  // Access to a const array should throw an exception if the index is out of
  // bounds.
  const XmlRpcValue&amp; ref = value;
  EXPECT_THROW(ref[2], XmlRpcException);
}

TEST(XmlRpc, fromXmlInvalid) {
  int offset = 0;
  XmlRpcValue val;

  // Test what happens with a null offset
  val.fromXml(&quot;&quot;, NULL);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);

  // Test what happens with an offset far beyond the xml
  offset = 20;
  val.fromXml(&quot;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 20);

  // Test what happens with no &lt;value&gt; tag
  offset = 0;
  val.fromXml(&quot;&lt;foo&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // Test what happens with &lt;value&gt; tag but nothing else
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;invalid&gt;&lt;/invalid&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;invalid&gt;&lt;/invalid&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;/value&gt; combination is an implicit empty string
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
  EXPECT_EQ(offset, 15);
  EXPECT_EQ(static_cast&lt;std::string&gt;(val), &quot;&quot;);
}

TEST(XmlRpc, fromXmlBoolean) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;boolean&gt;&lt;/boolean&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;boolean&gt;&lt;/boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;boolean&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;boolean&gt;foo&lt;/boolean&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;boolean&gt;foo&lt;/boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;boolean&gt;25&lt;/boolean&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;boolean&gt;25&lt;/boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;boolean&gt;1foo&lt;/boolean&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;boolean&gt;1foo&lt;/boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
  EXPECT_EQ(offset, 38);
  EXPECT_EQ(static_cast&lt;bool&gt;(val), true);

  // A &lt;value&gt;&lt;boolean&gt;1&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;boolean&gt;1&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
  EXPECT_EQ(offset, 25);
  EXPECT_EQ(static_cast&lt;bool&gt;(val), true);

  // A &lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
  EXPECT_EQ(offset, 35);
  EXPECT_EQ(static_cast&lt;bool&gt;(val), false);

  // A &lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
  EXPECT_EQ(offset, 35);
  EXPECT_EQ(static_cast&lt;bool&gt;(val), true);
}

TEST(XmlRpc, fromXmlI4) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;i4&gt;&lt;/i4&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;i4&gt;&lt;/i4&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;i4&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;i4&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;i4&gt;foo&lt;/i4&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;i4&gt;foo&lt;/i4&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;i4&gt;25&lt;/i4&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;i4&gt;25&lt;/i4&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 26);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 25);

  // A &lt;value&gt;&lt;i4&gt;1foo&lt;/i4&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;i4&gt;1foo&lt;/i4&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 28);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 1);

  // A &lt;value&gt;&lt;i4&gt;1&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;i4&gt;99&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 21);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 99);
}

TEST(XmlRpc, fromXmlInt) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;int&gt;&lt;/int&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;int&gt;&lt;/int&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;int&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;int&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;int&gt;foo&lt;/int&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;int&gt;foo&lt;/int&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;int&gt;25&lt;/int&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;int&gt;25&lt;/int&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 28);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 25);

  // A &lt;value&gt;&lt;int&gt;1foo&lt;/int&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;int&gt;1foo&lt;/int&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 30);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 1);

  // A &lt;value&gt;&lt;int&gt;1&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;int&gt;99&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
  EXPECT_EQ(offset, 22);
  EXPECT_EQ(static_cast&lt;int&gt;(val), 99);
}

TEST(XmlRpc, fromXmlDouble) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;double&gt;&lt;/double&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;double&gt;&lt;/double&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;double&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;double&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;double&gt;foo&lt;/double&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;double&gt;foo&lt;/double&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;double&gt;25&lt;/double&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;double&gt;25&lt;/double&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
  EXPECT_EQ(offset, 34);
  EXPECT_EQ(static_cast&lt;double&gt;(val), 25.0);

  // A &lt;value&gt;&lt;double&gt;25.876&lt;/double&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;double&gt;25.876&lt;/double&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
  EXPECT_EQ(offset, 38);
  EXPECT_NEAR(static_cast&lt;double&gt;(val), 25.876, 0.01);

  // A &lt;value&gt;&lt;double&gt;1foo&lt;/double&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;double&gt;1foo&lt;/double&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
  EXPECT_EQ(offset, 36);
  EXPECT_EQ(static_cast&lt;double&gt;(val), 1);
}

TEST(XmlRpc, fromXmlImplicitString) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;foo&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;foo&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
  EXPECT_EQ(offset, 18);
  EXPECT_EQ(static_cast&lt;std::string&gt;(val), &quot;foo&quot;);
  EXPECT_EQ(val.size(), 3);
}

TEST(XmlRpc, fromXmlExplicitString) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;string&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;string&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;string&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;string&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
  EXPECT_EQ(offset, 23);
  EXPECT_EQ(static_cast&lt;std::string&gt;(val), &quot;&quot;);
  EXPECT_EQ(val.size(), 0);

  // A &lt;value&gt;&lt;string&gt;foo&lt;/string&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;string&gt;foo&lt;/string&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
  EXPECT_EQ(offset, 35);
  EXPECT_EQ(static_cast&lt;std::string&gt;(val), &quot;foo&quot;);
  EXPECT_EQ(val.size(), 3);
}

TEST(XmlRpc, fromXmlDateTime) {
  int offset = 0;
  XmlRpcValue val;
  struct tm expected{};
  struct tm returned;

  // A &lt;value&gt;&lt;dateTime.iso8601&gt;&lt;/dateTime.iso8601&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;&lt;/dateTime.iso8601&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;dateTime.iso8601&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;dateTime.iso8601&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00&lt;dateTime.iso8601&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;dateTime.iso8601&gt;000000T00:00:00&lt;dateTime.iso8601&gt;&lt;/value&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;000000T00:00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:00&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  // FIXME: this currently leaves the returned struct tm fields 'tm_wday' and 'tm_yday' uninitialized
  val.fromXml(&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:00&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
  EXPECT_EQ(offset, 49);
  returned = static_cast&lt;struct tm&gt;(val);
  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
  EXPECT_EQ(returned.tm_min, expected.tm_min);
  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
  EXPECT_EQ(returned.tm_year, expected.tm_year);
  EXPECT_EQ(returned.tm_isdst, -1);

  // A &lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:0&lt;dateTime.iso8601&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:0&lt;dateTime.iso8601&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
  EXPECT_EQ(offset, 66);
  returned = static_cast&lt;struct tm&gt;(val);
  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
  EXPECT_EQ(returned.tm_min, expected.tm_min);
  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
  EXPECT_EQ(returned.tm_year, expected.tm_year);
  EXPECT_EQ(returned.tm_isdst, -1);

  // A &lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:00&lt;dateTime.iso8601&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this currently leaves the returned struct tm fields 'tm_wday' and 'tm_yday' uninitialized
  val.fromXml(&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;0000000T00:00:00&lt;dateTime.iso8601&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
  EXPECT_EQ(offset, 67);
  returned = static_cast&lt;struct tm&gt;(val);
  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
  EXPECT_EQ(returned.tm_min, expected.tm_min);
  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
  EXPECT_EQ(returned.tm_year, expected.tm_year);
  EXPECT_EQ(returned.tm_isdst, -1);
}

TEST(XmlRpc, fromXmlBase64) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;base64&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;base64&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;base64&gt;&lt;/base64&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;base64&gt;&lt;/base64&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
  EXPECT_EQ(offset, 32);
  EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), XmlRpc::XmlRpcValue::BinaryData());
  EXPECT_EQ(val.size(), 0);

  // A &lt;value&gt;&lt;base64&gt;____&lt;/base64&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: the underscore character is illegal in base64, so this should thrown an error
  val.fromXml(&quot;&lt;value&gt;&lt;base64&gt;____&lt;/base64&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
  EXPECT_EQ(offset, 36);
  EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), XmlRpc::XmlRpcValue::BinaryData());
  EXPECT_EQ(val.size(), 0);

  // A &lt;value&gt;&lt;base64&gt;aGVsbG8=&lt;/base64&gt;&lt;/value&gt; is valid
  XmlRpc::XmlRpcValue::BinaryData expected{'h', 'e', 'l', 'l', 'o'};
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;base64&gt;aGVsbG8=&lt;/base64&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
  EXPECT_EQ(offset, 40);
  EXPECT_EQ(static_cast&lt;const XmlRpc::XmlRpcValue::BinaryData &amp;&gt;(val), expected);
  EXPECT_EQ(val.size(), 5);
}

TEST(XmlRpc, fromXmlArray) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;array&gt; is invalid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;array&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;array&gt;&lt;/array&gt;&lt;/value&gt; is invalid (no &lt;data&gt; tag)
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;array&gt;&lt;/array&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
  EXPECT_EQ(offset, 0);

  // A &lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
  EXPECT_EQ(offset, 43);
  EXPECT_EQ(val.size(), 0);

  // A &lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
  EXPECT_EQ(offset, 78);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);

  // A &lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/array&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail (missing an end &lt;/data&gt;), but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/array&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
  EXPECT_EQ(offset, 71);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);

  // A &lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;value&gt;&lt;double&gt;23.4&lt;/double&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;array&gt;&lt;data&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;value&gt;&lt;double&gt;23.4&lt;/double&gt;&lt;/value&gt;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
  EXPECT_EQ(offset, 114);
  EXPECT_EQ(val.size(), 2);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[0]), true);
  EXPECT_NEAR(static_cast&lt;double&gt;(val[1]), 23.4, 0.01);
}

TEST(XmlRpc, fromXmlStruct) {
  int offset = 0;
  XmlRpcValue val;

  // A &lt;value&gt;&lt;struct&gt; is valid
  offset = 0;
  // FIXME: this should fail, but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;struct&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 15);
  EXPECT_EQ(val.size(), 0);

  // A &lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail (it is missing many end tags and a &lt;name&gt; tag), but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 48);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[&quot;&quot;]), true);

  // A &lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail (it is missing a &lt;name&gt; tag), but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 84);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[&quot;&quot;]), true);

  // A &lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;&lt;/name&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt; is valid
  offset = 0;
  // FIXME: this should fail (the name tag is empty), but currently does not
  val.fromXml(&quot;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;&lt;/name&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 97);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[&quot;&quot;]), true);

  // A &lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;foo&lt;/name&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt; is valid
  offset = 0;
  val.fromXml(&quot;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;foo&lt;/name&gt;&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;&quot;, &amp;offset);
  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
  EXPECT_EQ(offset, 100);
  EXPECT_EQ(val.size(), 1);
  EXPECT_EQ(static_cast&lt;bool&gt;(val[&quot;foo&quot;]), true);
}

int main(int argc, char **argv)
{
  ::testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</PRE>
</div>
  </div>
</body>
</html>
