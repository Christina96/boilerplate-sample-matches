
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.471321238775884%, Tokens: 13</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-language_model.cpp</h3>
            <pre><code>1  #include "language_model.h"
2  #include <tesseract/unichar.h>       
3  #include <cassert>                   
4  #include <cmath>                     
5  #include "blamer.h"                  
6  #include "ccutil.h"                  
7  #include "dawg.h"                    
8  #include "errcode.h"                 
9  #include "lm_state.h"                
10  #include "matrix.h"                  
11  #include "pageres.h"                 
12  #include "params.h"                  
13  #include "params_training_featdef.h" 
14  #include "tprintf.h"                 
15  #include "unicharset.h"              
16  #include "unicity_table.h"           
17  template <typename T>
18  class UnicityTable;
19  namespace tesseract {
20  class LMPainPoints;
21  struct FontInfo;
22  #if defined(ANDROID)
23  static inline double log2(double n) {
24    return log(n) / log(2.0);
25  }
26  #endif 
27  const float LanguageModel::kMaxAvgNgramCost = 25.0f;
28  LanguageModel::LanguageModel(const UnicityTable<FontInfo> *fontinfo_table, Dict *dict)
29      : INT_MEMBER(language_model_debug_level, 0, "Language model debug level",
30                   dict->getCCUtil()->params())
31      , BOOL_INIT_MEMBER(language_model_ngram_on, false,
32                         "Turn on/off the use of character ngram model", dict->getCCUtil()->params())
33      , INT_MEMBER(language_model_ngram_order, 8, "Maximum order of the character ngram model",
34                   dict->getCCUtil()->params())
35      , INT_MEMBER(language_model_viterbi_list_max_num_prunable, 10,
36                   "Maximum number of prunable (those for which"
37                   " PrunablePath() is true) entries in each viterbi list"
38                   " recorded in BLOB_CHOICEs",
39                   dict->getCCUtil()->params())
40      , INT_MEMBER(language_model_viterbi_list_max_size, 500,
41                   "Maximum size of viterbi lists recorded in BLOB_CHOICEs",
42                   dict->getCCUtil()->params())
43      , double_MEMBER(language_model_ngram_small_prob, 0.000001,
44                      "To avoid overly small denominators use this as the "
45                      "floor of the probability returned by the ngram model.",
46                      dict->getCCUtil()->params())
47      , double_MEMBER(language_model_ngram_nonmatch_score, -40.0,
48                      "Average classifier score of a non-matching unichar.",
49                      dict->getCCUtil()->params())
50      , BOOL_MEMBER(language_model_ngram_use_only_first_uft8_step, false,
51                    "Use only the first UTF8 step of the given string"
52                    " when computing log probabilities.",
53                    dict->getCCUtil()->params())
54      , double_MEMBER(language_model_ngram_scale_factor, 0.03,
55                      "Strength of the character ngram model relative to the"
56                      " character classifier ",
57                      dict->getCCUtil()->params())
58      , double_MEMBER(language_model_ngram_rating_factor, 16.0,
59                      "Factor to bring log-probs into the same range as ratings"
60                      " when multiplied by outline length ",
61                      dict->getCCUtil()->params())
62      , BOOL_MEMBER(language_model_ngram_space_delimited_language, true,
63                    "Words are delimited by space", dict->getCCUtil()->params())
64      , INT_MEMBER(language_model_min_compound_length, 3, "Minimum length of compound words",
65                   dict->getCCUtil()->params())
66      , double_MEMBER(language_model_penalty_non_freq_dict_word, 0.1,
67                      "Penalty for words not in the frequent word dictionary",
68                      dict->getCCUtil()->params())
69      , double_MEMBER(language_model_penalty_non_dict_word, 0.15, "Penalty for non-dictionary words",
70                      dict->getCCUtil()->params())
71      , double_MEMBER(language_model_penalty_punc, 0.2, "Penalty for inconsistent punctuation",
72                      dict->getCCUtil()->params())
73      , double_MEMBER(language_model_penalty_case, 0.1, "Penalty for inconsistent case",
74                      dict->getCCUtil()->params())
75      , double_MEMBER(language_model_penalty_script, 0.5, "Penalty for inconsistent script",
76                      dict->getCCUtil()->params())
77      , double_MEMBER(language_model_penalty_chartype, 0.3, "Penalty for inconsistent character type",
78                      dict->getCCUtil()->params())
79      ,
80      double_MEMBER(language_model_penalty_font, 0.00, "Penalty for inconsistent font",
81                    dict->getCCUtil()->params())
82      , double_MEMBER(language_model_penalty_spacing, 0.05, "Penalty for inconsistent spacing",
83                      dict->getCCUtil()->params())
84      , double_MEMBER(language_model_penalty_increment, 0.01, "Penalty increment",
85                      dict->getCCUtil()->params())
86      , INT_MEMBER(wordrec_display_segmentations, 0, "Display Segmentations (ScrollView)",
87                   dict->getCCUtil()->params())
88      , BOOL_INIT_MEMBER(language_model_use_sigmoidal_certainty, false,
89                         "Use sigmoidal score for certainty", dict->getCCUtil()->params())
90      , dawg_args_(nullptr, new DawgPositionVector(), NO_PERM)
91      , fontinfo_table_(fontinfo_table)
92      , dict_(dict) {
93    ASSERT_HOST(dict_ != nullptr);
94  }
95  LanguageModel::~LanguageModel() {
96    delete dawg_args_.updated_dawgs;
97  }
98  void LanguageModel::InitForWord(const WERD_CHOICE *prev_word, bool fixed_pitch,
99                                  float max_char_wh_ratio, float rating_cert_scale) {
100    fixed_pitch_ = fixed_pitch;
101    max_char_wh_ratio_ = max_char_wh_ratio;
102    rating_cert_scale_ = rating_cert_scale;
103    acceptable_choice_found_ = false;
104    correct_segmentation_explored_ = false;
105    very_beginning_active_dawgs_.clear();
106    dict_->init_active_dawgs(&very_beginning_active_dawgs_, false);
107    beginning_active_dawgs_.clear();
108    dict_->default_dawgs(&beginning_active_dawgs_, false);
109    if (language_model_ngram_on) {
110      if (prev_word != nullptr && !prev_word->unichar_string().empty()) {
111        prev_word_str_ = prev_word->unichar_string();
112        if (language_model_ngram_space_delimited_language) {
113          prev_word_str_ += ' ';
114        }
115      } else {
116        prev_word_str_ = " ";
117      }
118      const char *str_ptr = prev_word_str_.c_str();
119      const char *str_end = str_ptr + prev_word_str_.length();
120      int step;
121      prev_word_unichar_step_len_ = 0;
122      while (str_ptr != str_end && (step = UNICHAR::utf8_step(str_ptr))) {
123        str_ptr += step;
124        ++prev_word_unichar_step_len_;
125      }
126      ASSERT_HOST(str_ptr == str_end);
127    }
128  }
129  static void ScanParentsForCaseMix(const UNICHARSET &unicharset, LanguageModelState *parent_node) {
130    if (parent_node == nullptr) {
131      return;
132    }
133    ViterbiStateEntry_IT vit(&parent_node->viterbi_state_entries);
134    for (vit.mark_cycle_pt(); !vit.cycled_list(); vit.forward()) {
135      ViterbiStateEntry *vse = vit.data();
136      vse->competing_vse = nullptr;
137      UNICHAR_ID unichar_id = vse->curr_b->unichar_id();
138      if (unicharset.get_isupper(unichar_id) || unicharset.get_islower(unichar_id)) {
139        UNICHAR_ID other_case = unicharset.get_other_case(unichar_id);
140        if (other_case == unichar_id) {
141          continue; 
142        }
143        ViterbiStateEntry_IT vit2(&parent_node->viterbi_state_entries);
144        for (vit2.mark_cycle_pt();
145             !vit2.cycled_list() && vit2.data()->curr_b->unichar_id() != other_case; vit2.forward()) {
146        }
147        if (!vit2.cycled_list()) {
148          vse->competing_vse = vit2.data();
149        }
150      }
151    }
152  }
153  static bool HasBetterCaseVariant(const UNICHARSET &unicharset, const BLOB_CHOICE *choice,
154                                   BLOB_CHOICE_LIST *choices) {
155    UNICHAR_ID choice_id = choice->unichar_id();
156    UNICHAR_ID other_case = unicharset.get_other_case(choice_id);
157    if (other_case == choice_id || other_case == INVALID_UNICHAR_ID) {
158      return false; 
159    }
160    if (unicharset.SizesDistinct(choice_id, other_case)) {
161      return false; 
162    }
163    BLOB_CHOICE_IT bc_it(choices);
164    for (bc_it.mark_cycle_pt(); !bc_it.cycled_list(); bc_it.forward()) {
165      BLOB_CHOICE *better_choice = bc_it.data();
166      if (better_choice->unichar_id() == other_case) {
167        return true; 
168      } else if (better_choice == choice) {
169        return false; 
170      }
171    }
172    return false; 
173  }
174  bool LanguageModel::UpdateState(bool just_classified, int curr_col, int curr_row,
175                                  BLOB_CHOICE_LIST *curr_list, LanguageModelState *parent_node,
176                                  LMPainPoints *pain_points, WERD_RES *word_res,
177                                  BestChoiceBundle *best_choice_bundle, BlamerBundle *blamer_bundle) {
178    if (language_model_debug_level > 0) {
179      tprintf("\nUpdateState: col=%d row=%d %s", curr_col, curr_row,
180              just_classified ? "just_classified" : "");
181      if (language_model_debug_level > 5) {
182        tprintf("(parent=%p)\n", static_cast<void *>(parent_node));
183      } else {
184        tprintf("\n");
185      }
186    }
187    bool word_end = (curr_row + 1 >= word_res->ratings->dimension());
188    bool new_changed = false;
189    float denom = (language_model_ngram_on) ? ComputeDenom(curr_list) : 1.0f;
190    const UNICHARSET &unicharset = dict_->getUnicharset();
191    BLOB_CHOICE *first_lower = nullptr;
192    BLOB_CHOICE *first_upper = nullptr;
193    BLOB_CHOICE *first_digit = nullptr;
194    bool has_alnum_mix = false;
195    if (parent_node != nullptr) {
196      int result = SetTopParentLowerUpperDigit(parent_node);
197      if (result < 0) {
198        if (language_model_debug_level > 0) {
199          tprintf("No parents found to process\n");
200        }
201        return false;
202      }
203      if (result > 0) {
204        has_alnum_mix = true;
205      }
206    }
207    if (!GetTopLowerUpperDigit(curr_list, &first_lower, &first_upper, &first_digit)) {
208      has_alnum_mix = false;
209    };
210    ScanParentsForCaseMix(unicharset, parent_node);
211    if (language_model_debug_level > 3 && parent_node != nullptr) {
212      parent_node->Print("Parent viterbi list");
213    }
214    LanguageModelState *curr_state = best_choice_bundle->beam[curr_row];
215    ViterbiStateEntry_IT vit;
216    BLOB_CHOICE_IT c_it(curr_list);
217    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
218      BLOB_CHOICE *choice = c_it.data();
219      UNICHAR_ID unichar_id = choice->unichar_id();
220      if (unicharset.get_fragment(unichar_id)) {
221        continue; 
222      }
223      LanguageModelFlagsType blob_choice_flags = kXhtConsistentFlag;
224      if (c_it.at_first() || !new_changed) {
225        blob_choice_flags |= kSmallestRatingFlag;
226      }
227      if (first_lower == choice) {
228        blob_choice_flags |= kLowerCaseFlag;
229      }
230      if (first_upper == choice) {
231        blob_choice_flags |= kUpperCaseFlag;
232      }
233      if (first_digit == choice) {
234        blob_choice_flags |= kDigitFlag;
235      }
236      if (parent_node == nullptr) {
237        if (HasBetterCaseVariant(unicharset, choice, curr_list)) {
238          continue;
239        }
240        if (blob_choice_flags & kUpperCaseFlag) {
241          blob_choice_flags |= kLowerCaseFlag;
242        }
243        new_changed |= AddViterbiStateEntry(blob_choice_flags, denom, word_end, curr_col, curr_row,
244                                            choice, curr_state, nullptr, pain_points, word_res,
245                                            best_choice_bundle, blamer_bundle);
246      } else {
247        vit.set_to_list(&parent_node->viterbi_state_entries);
248        int vit_counter = 0;
249        vit.mark_cycle_pt();
250        ViterbiStateEntry *parent_vse = nullptr;
251        LanguageModelFlagsType top_choice_flags;
252        while ((parent_vse =
253                    GetNextParentVSE(just_classified, has_alnum_mix, c_it.data(), blob_choice_flags,
254                                     unicharset, word_res, &vit, &top_choice_flags)) != nullptr) {
255          if (PrunablePath(*parent_vse) &&
256              (++vit_counter > language_model_viterbi_list_max_num_prunable ||
257               (language_model_ngram_on && parent_vse->ngram_info->pruned))) {
258            continue;
259          }
260          if (!parent_vse->HasAlnumChoice(unicharset) &&
261              HasBetterCaseVariant(unicharset, choice, curr_list)) {
262            continue;
263          }
264          new_changed |= AddViterbiStateEntry(top_choice_flags, denom, word_end, curr_col, curr_row,
265                                              c_it.data(), curr_state, parent_vse, pain_points,
266                                              word_res, best_choice_bundle, blamer_bundle);
267        }
268      }
269    }
270    return new_changed;
271  }
272  bool LanguageModel::GetTopLowerUpperDigit(BLOB_CHOICE_LIST *curr_list, BLOB_CHOICE **first_lower,
273                                            BLOB_CHOICE **first_upper,
274                                            BLOB_CHOICE **first_digit) const {
275    BLOB_CHOICE_IT c_it(curr_list);
276    const UNICHARSET &unicharset = dict_->getUnicharset();
277    BLOB_CHOICE *first_unichar = nullptr;
278    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
279      UNICHAR_ID unichar_id = c_it.data()->unichar_id();
280      if (unicharset.get_fragment(unichar_id)) {
281        continue; 
282      }
283      if (first_unichar == nullptr) {
284        first_unichar = c_it.data();
285      }
286      if (*first_lower == nullptr && unicharset.get_islower(unichar_id)) {
287        *first_lower = c_it.data();
288      }
289      if (*first_upper == nullptr && unicharset.get_isalpha(unichar_id) &&
290          !unicharset.get_islower(unichar_id)) {
291        *first_upper = c_it.data();
292      }
293      if (*first_digit == nullptr && unicharset.get_isdigit(unichar_id)) {
294        *first_digit = c_it.data();
295      }
296    }
297    ASSERT_HOST(first_unichar != nullptr);
298    bool mixed = (*first_lower != nullptr || *first_upper != nullptr) && *first_digit != nullptr;
299    if (*first_lower == nullptr) {
300      *first_lower = first_unichar;
301    }
302    if (*first_upper == nullptr) {
303      *first_upper = first_unichar;
304    }
305    if (*first_digit == nullptr) {
306      *first_digit = first_unichar;
307    }
308    return mixed;
309  }
310  int LanguageModel::SetTopParentLowerUpperDigit(LanguageModelState *parent_node) const {
311    if (parent_node == nullptr) {
312      return -1;
313    }
314    UNICHAR_ID top_id = INVALID_UNICHAR_ID;
315    ViterbiStateEntry *top_lower = nullptr;
316    ViterbiStateEntry *top_upper = nullptr;
317    ViterbiStateEntry *top_digit = nullptr;
318    ViterbiStateEntry *top_choice = nullptr;
319    float lower_rating = 0.0f;
320    float upper_rating = 0.0f;
321    float digit_rating = 0.0f;
322    float top_rating = 0.0f;
323    const UNICHARSET &unicharset = dict_->getUnicharset();
324    ViterbiStateEntry_IT vit(&parent_node->viterbi_state_entries);
325    for (vit.mark_cycle_pt(); !vit.cycled_list(); vit.forward()) {
326      ViterbiStateEntry *vse = vit.data();
327      ViterbiStateEntry *unichar_vse = vse;
328      UNICHAR_ID unichar_id = unichar_vse->curr_b->unichar_id();
329      float rating = unichar_vse->curr_b->rating();
330      while (unichar_id == INVALID_UNICHAR_ID && unichar_vse->parent_vse != nullptr) {
331        unichar_vse = unichar_vse->parent_vse;
332        unichar_id = unichar_vse->curr_b->unichar_id();
333        rating = unichar_vse->curr_b->rating();
334      }
335      if (unichar_id != INVALID_UNICHAR_ID) {
336        if (unicharset.get_islower(unichar_id)) {
337          if (top_lower == nullptr || lower_rating > rating) {
338            top_lower = vse;
339            lower_rating = rating;
340          }
341        } else if (unicharset.get_isalpha(unichar_id)) {
342          if (top_upper == nullptr || upper_rating > rating) {
343            top_upper = vse;
344            upper_rating = rating;
345          }
346        } else if (unicharset.get_isdigit(unichar_id)) {
347          if (top_digit == nullptr || digit_rating > rating) {
348            top_digit = vse;
349            digit_rating = rating;
350          }
351        }
352      }
353      if (top_choice == nullptr || top_rating > rating) {
354        top_choice = vse;
355        top_rating = rating;
356        top_id = unichar_id;
357      }
358    }
359    if (top_choice == nullptr) {
360      return -1;
361    }
362    bool mixed = (top_lower != nullptr || top_upper != nullptr) && top_digit != nullptr;
363    if (top_lower == nullptr) {
364      top_lower = top_choice;
365    }
366    top_lower->top_choice_flags |= kLowerCaseFlag;
367    if (top_upper == nullptr) {
368      top_upper = top_choice;
369    }
370    top_upper->top_choice_flags |= kUpperCaseFlag;
371    if (top_digit == nullptr) {
372      top_digit = top_choice;
373    }
374    top_digit->top_choice_flags |= kDigitFlag;
375    top_choice->top_choice_flags |= kSmallestRatingFlag;
376    if (top_id != INVALID_UNICHAR_ID && dict_->compound_marker(top_id) &&
377        (top_choice->top_choice_flags & (kLowerCaseFlag | kUpperCaseFlag | kDigitFlag))) {
378      top_choice->top_choice_flags |= kLowerCaseFlag | kUpperCaseFlag | kDigitFlag;
379    }
380    return mixed ? 1 : 0;
381  }
382  ViterbiStateEntry *LanguageModel::GetNextParentVSE(bool just_classified, bool mixed_alnum,
383                                                     const BLOB_CHOICE *bc,
384                                                     LanguageModelFlagsType blob_choice_flags,
385                                                     const UNICHARSET &unicharset, WERD_RES *word_res,
386                                                     ViterbiStateEntry_IT *vse_it,
387                                                     LanguageModelFlagsType *top_choice_flags) const {
388    for (; !vse_it->cycled_list(); vse_it->forward()) {
389      ViterbiStateEntry *parent_vse = vse_it->data();
390      if (!just_classified && !parent_vse->updated) {
391        continue;
392      }
393      if (language_model_debug_level > 2) {
394        parent_vse->Print("Considering");
395      }
396      *top_choice_flags = blob_choice_flags;
397      if ((blob_choice_flags & kUpperCaseFlag) && !parent_vse->HasAlnumChoice(unicharset)) {
398        *top_choice_flags |= kLowerCaseFlag;
399      }
400      *top_choice_flags &= parent_vse->top_choice_flags;
401      UNICHAR_ID unichar_id = bc->unichar_id();
402      const BLOB_CHOICE *parent_b = parent_vse->curr_b;
403      UNICHAR_ID parent_id = parent_b->unichar_id();
404      if (unicharset.get_isdigit(unichar_id) && unicharset.get_isalpha(parent_id) &&
405          (mixed_alnum || *top_choice_flags == 0)) {
406        continue; 
407      }
408      if (unicharset.get_isalpha(unichar_id) && unicharset.get_isdigit(parent_id) &&
409          (mixed_alnum || *top_choice_flags == 0)) {
410        continue; 
411      }
412      if (parent_vse->competing_vse != nullptr) {
413        const BLOB_CHOICE *competing_b = parent_vse->competing_vse->curr_b;
414        UNICHAR_ID other_id = competing_b->unichar_id();
415        if (language_model_debug_level >= 5) {
416          tprintf("Parent %s has competition %s\n", unicharset.id_to_unichar(parent_id),
417                  unicharset.id_to_unichar(other_id));
418        }
419        if (unicharset.SizesDistinct(parent_id, other_id)) {
420          if (bc->PosAndSizeAgree(*competing_b, word_res->x_height,
421                                  language_model_debug_level >= 5) &&
422              !bc->PosAndSizeAgree(*parent_b, word_res->x_height, language_model_debug_level >= 5)) {
423            continue; 
424          }
425        }
426      }
427      vse_it->forward();
428      return parent_vse; 
429    }
430    return nullptr; 
431  }
432  bool LanguageModel::AddViterbiStateEntry(LanguageModelFlagsType top_choice_flags, float denom,
433                                           bool word_end, int curr_col, int curr_row, BLOB_CHOICE *b,
434                                           LanguageModelState *curr_state,
435                                           ViterbiStateEntry *parent_vse, LMPainPoints *pain_points,
436                                           WERD_RES *word_res, BestChoiceBundle *best_choice_bundle,
437                                           BlamerBundle *blamer_bundle) {
438    ViterbiStateEntry_IT vit;
439    if (language_model_debug_level > 1) {
440      tprintf(
441          "AddViterbiStateEntry for unichar %s rating=%.4f"
442          " certainty=%.4f top_choice_flags=0x%x",
443          dict_->getUnicharset().id_to_unichar(b->unichar_id()), b->rating(), b->certainty(),
444          top_choice_flags);
445      if (language_model_debug_level > 5) {
446        tprintf(" parent_vse=%p\n", static_cast<void *>(parent_vse));
447      } else {
448        tprintf("\n");
449      }
450    }
451    ASSERT_HOST(curr_state != nullptr);
452    if (curr_state->viterbi_state_entries_length >= language_model_viterbi_list_max_size) {
453      if (language_model_debug_level > 1) {
454        tprintf("AddViterbiStateEntry: viterbi list is full!\n");
455      }
456      return false;
457    }
458    LanguageModelDawgInfo *dawg_info = GenerateDawgInfo(word_end, curr_col, curr_row, *b, parent_vse);
459    float outline_length = AssociateUtils::ComputeOutlineLength(rating_cert_scale_, *b);
460    LanguageModelNgramInfo *ngram_info = nullptr;
461    if (language_model_ngram_on) {
462      ngram_info =
463          GenerateNgramInfo(dict_->getUnicharset().id_to_unichar(b->unichar_id()), b->certainty(),
464                            denom, curr_col, curr_row, outline_length, parent_vse);
465      ASSERT_HOST(ngram_info != nullptr);
466    }
467    bool liked_by_language_model =
468        dawg_info != nullptr || (ngram_info != nullptr && !ngram_info->pruned);
469    if (!liked_by_language_model && top_choice_flags == 0) {
470      if (language_model_debug_level > 1) {
471        tprintf("Language model components very early pruned this entry\n");
472      }
473      delete ngram_info;
474      delete dawg_info;
475      return false;
476    }
477    LMConsistencyInfo consistency_info(parent_vse != nullptr ? &parent_vse->consistency_info
478                                                             : nullptr);
479    consistency_info.ComputeXheightConsistency(
480        b, dict_->getUnicharset().get_ispunctuation(b->unichar_id()));
481    if (consistency_info.InconsistentXHeight()) {
482      top_choice_flags &= ~kXhtConsistentFlag;
483    }
484    if (!liked_by_language_model && top_choice_flags == 0) {
485      if (language_model_debug_level > 1) {
486        tprintf("Language model components early pruned this entry\n");
487      }
488      delete ngram_info;
489      delete dawg_info;
490      return false;
491    }
492    FillConsistencyInfo(curr_col, word_end, b, parent_vse, word_res, &consistency_info);
493    if (dawg_info != nullptr && consistency_info.invalid_punc) {
494      consistency_info.invalid_punc = false; 
495    }
496    AssociateStats associate_stats;
497    ComputeAssociateStats(curr_col, curr_row, max_char_wh_ratio_, parent_vse, word_res,
498                          &associate_stats);
499    if (parent_vse != nullptr) {
500      associate_stats.shape_cost += parent_vse->associate_stats.shape_cost;
501      associate_stats.bad_shape |= parent_vse->associate_stats.bad_shape;
502    }
503    auto *new_vse = new ViterbiStateEntry(parent_vse, b, 0.0, outline_length, consistency_info,
504                                          associate_stats, top_choice_flags, dawg_info, ngram_info,
505                                          (language_model_debug_level > 0)
506                                              ? dict_->getUnicharset().id_to_unichar(b->unichar_id())
507                                              : nullptr);
508    new_vse->cost = ComputeAdjustedPathCost(new_vse);
509    if (language_model_debug_level >= 3) {
510      tprintf("Adjusted cost = %g\n", new_vse->cost);
511    }
512    if (!curr_state->viterbi_state_entries.empty() && new_vse->top_choice_flags) {
513      GenerateTopChoiceInfo(new_vse, parent_vse, curr_state);
514    }
515    bool keep = new_vse->top_choice_flags || liked_by_language_model;
516    if (!(top_choice_flags & kSmallestRatingFlag) && 
517        consistency_info.inconsistent_script) {      
518      keep = false;
519    }
520    if (!keep) {
521      if (language_model_debug_level > 1) {
522        tprintf("Language model components did not like this entry\n");
523      }
524      delete new_vse;
525      return false;
526    }
527    if (PrunablePath(*new_vse) &&
528        (curr_state->viterbi_state_entries_prunable_length >=
529         language_model_viterbi_list_max_num_prunable) &&
530        new_vse->cost >= curr_state->viterbi_state_entries_prunable_max_cost) {
531      if (language_model_debug_level > 1) {
532        tprintf("Discarded ViterbiEntry with high cost %g max cost %g\n", new_vse->cost,
533                curr_state->viterbi_state_entries_prunable_max_cost);
534      }
535      delete new_vse;
536      return false;
537    }
538    if (word_end) {
539      UpdateBestChoice(new_vse, pain_points, word_res, best_choice_bundle, blamer_bundle);
540      if (new_vse->cost >= WERD_CHOICE::kBadRating && new_vse != best_choice_bundle->best_vse) {
541        if (language_model_debug_level > 1) {
542          tprintf("Discarded ViterbiEntry with high cost %g\n", new_vse->cost);
543        }
544        delete new_vse;
545        return false;
546      }
547    }
548    curr_state->viterbi_state_entries.add_sorted(ViterbiStateEntry::Compare, false, new_vse);
549    curr_state->viterbi_state_entries_length++;
550    if (PrunablePath(*new_vse)) {
551      curr_state->viterbi_state_entries_prunable_length++;
552    }
553    if ((curr_state->viterbi_state_entries_prunable_length >=
554         language_model_viterbi_list_max_num_prunable) ||
555        new_vse->top_choice_flags) {
556      ASSERT_HOST(!curr_state->viterbi_state_entries.empty());
557      int prunable_counter = language_model_viterbi_list_max_num_prunable;
558      vit.set_to_list(&(curr_state->viterbi_state_entries));
559      for (vit.mark_cycle_pt(); !vit.cycled_list(); vit.forward()) {
560        ViterbiStateEntry *curr_vse = vit.data();
561        if (curr_vse->top_choice_flags && curr_vse != new_vse && curr_vse->cost > new_vse->cost) {
562          curr_vse->top_choice_flags &= ~(new_vse->top_choice_flags);
563        }
564        if (prunable_counter > 0 && PrunablePath(*curr_vse)) {
565          --prunable_counter;
566        }
567        if (prunable_counter == 0) {
568          curr_state->viterbi_state_entries_prunable_max_cost = vit.data()->cost;
569          if (language_model_debug_level > 1) {
570            tprintf("Set viterbi_state_entries_prunable_max_cost to %g\n",
571                    curr_state->viterbi_state_entries_prunable_max_cost);
572          }
573          prunable_counter = -1; 
574        }
575      }
576    }
577    if (language_model_debug_level > 2) {
578      new_vse->Print("New");
579      if (language_model_debug_level > 5) {
580        curr_state->Print("Updated viterbi list");
581      }
582    }
583    return true;
584  }
585  void LanguageModel::GenerateTopChoiceInfo(ViterbiStateEntry *new_vse,
586                                            const ViterbiStateEntry *parent_vse,
587                                            LanguageModelState *lms) {
588    ViterbiStateEntry_IT vit(&(lms->viterbi_state_entries));
589    for (vit.mark_cycle_pt();
590         !vit.cycled_list() && new_vse->top_choice_flags && new_vse->cost >= vit.data()->cost;
591         vit.forward()) {
592      new_vse->top_choice_flags &= ~(vit.data()->top_choice_flags);
593    }
594    if (language_model_debug_level > 2) {
595      tprintf("GenerateTopChoiceInfo: top_choice_flags=0x%x\n", new_vse->top_choice_flags);
596    }
597  }
598  LanguageModelDawgInfo *LanguageModel::GenerateDawgInfo(bool word_end, int curr_col, int curr_row,
599                                                         const BLOB_CHOICE &b,
600                                                         const ViterbiStateEntry *parent_vse) {
601    if (parent_vse == nullptr) {
602      dawg_args_.active_dawgs = &very_beginning_active_dawgs_;
603      dawg_args_.permuter = NO_PERM;
604    } else {
605      if (parent_vse->dawg_info == nullptr) {
606        return nullptr; 
607      }
608      dawg_args_.active_dawgs = &parent_vse->dawg_info->active_dawgs;
609      dawg_args_.permuter = parent_vse->dawg_info->permuter;
610    }
611    if (word_end && dict_->has_hyphen_end(&dict_->getUnicharset(), b.unichar_id(), curr_col == 0)) {
612      if (language_model_debug_level > 0) {
613        tprintf("Hyphenated word found\n");
614      }
615      return new LanguageModelDawgInfo(dawg_args_.active_dawgs, COMPOUND_PERM);
616    }
617    if (dict_->compound_marker(b.unichar_id()) &&
618        (parent_vse == nullptr || parent_vse->dawg_info->permuter != NUMBER_PERM)) {
619      if (language_model_debug_level > 0) {
620        tprintf("Found compound marker\n");
621      }
622      if (parent_vse == nullptr || word_end || dawg_args_.permuter == COMPOUND_PERM ||
623          parent_vse->length < language_model_min_compound_length) {
624        return nullptr;
625      }
626      bool has_word_ending = false;
627      for (unsigned i = 0; i < parent_vse->dawg_info->active_dawgs.size(); ++i) {
628        const DawgPosition &pos = parent_vse->dawg_info->active_dawgs[i];
629        const Dawg *pdawg = pos.dawg_index < 0 ? nullptr : dict_->GetDawg(pos.dawg_index);
630        if (pdawg == nullptr || pos.back_to_punc) {
631          continue;
632        };
633        if (pdawg->type() == DAWG_TYPE_WORD && pos.dawg_ref != NO_EDGE &&
634            pdawg->end_of_word(pos.dawg_ref)) {
635          has_word_ending = true;
636          break;
637        }
638      }
639      if (!has_word_ending) {
640        return nullptr;
641      }
642      if (language_model_debug_level > 0) {
643        tprintf("Compound word found\n");
644      }
645      return new LanguageModelDawgInfo(&beginning_active_dawgs_, COMPOUND_PERM);
646    } 
647    LanguageModelDawgInfo *dawg_info = nullptr;
648    const auto &normed_ids = dict_->getUnicharset().normed_ids(b.unichar_id());
649    DawgPositionVector tmp_active_dawgs;
650    for (unsigned i = 0; i < normed_ids.size(); ++i) {
651      if (language_model_debug_level > 2) {
652        tprintf("Test Letter OK for unichar %d, normed %d\n", b.unichar_id(), normed_ids[i]);
653      }
654      dict_->LetterIsOkay(&dawg_args_, dict_->getUnicharset(), normed_ids[i],
655                          word_end && i == normed_ids.size() - 1);
656      if (dawg_args_.permuter == NO_PERM) {
657        break;
658      } else if (i < normed_ids.size() - 1) {
659        tmp_active_dawgs = *dawg_args_.updated_dawgs;
660        dawg_args_.active_dawgs = &tmp_active_dawgs;
661      }
662      if (language_model_debug_level > 2) {
663        tprintf("Letter was OK for unichar %d, normed %d\n", b.unichar_id(), normed_ids[i]);
664      }
665    }
666    dawg_args_.active_dawgs = nullptr;
667    if (dawg_args_.permuter != NO_PERM) {
668      dawg_info = new LanguageModelDawgInfo(dawg_args_.updated_dawgs, dawg_args_.permuter);
669    } else if (language_model_debug_level > 3) {
670      tprintf("Letter %s not OK!\n", dict_->getUnicharset().id_to_unichar(b.unichar_id()));
671    }
672    return dawg_info;
673  }
674  LanguageModelNgramInfo *LanguageModel::GenerateNgramInfo(const char *unichar, float certainty,
675                                                           float denom, int curr_col, int curr_row,
676                                                           float outline_length,
677                                                           const ViterbiStateEntry *parent_vse) {
678    const char *pcontext_ptr = "";
679    int pcontext_unichar_step_len = 0;
680    if (parent_vse == nullptr) {
681      pcontext_ptr = prev_word_str_.c_str();
682      pcontext_unichar_step_len = prev_word_unichar_step_len_;
683    } else {
684      pcontext_ptr = parent_vse->ngram_info->context.c_str();
685      pcontext_unichar_step_len = parent_vse->ngram_info->context_unichar_step_len;
686    }
687    int unichar_step_len = 0;
688    bool pruned = false;
689    float ngram_cost;
690    float ngram_and_classifier_cost = ComputeNgramCost(unichar, certainty, denom, pcontext_ptr,
691                                                       &unichar_step_len, &pruned, &ngram_cost);
692    ngram_and_classifier_cost *= outline_length / language_model_ngram_rating_factor;
693    if (parent_vse != nullptr) {
694      ngram_and_classifier_cost += parent_vse->ngram_info->ngram_and_classifier_cost;
695      ngram_cost += parent_vse->ngram_info->ngram_cost;
696    }
697    int num_remove = (unichar_step_len + pcontext_unichar_step_len - language_model_ngram_order);
698    if (num_remove > 0) {
699      pcontext_unichar_step_len -= num_remove;
700    }
701    while (num_remove > 0 && *pcontext_ptr != '\0') {
702      pcontext_ptr += UNICHAR::utf8_step(pcontext_ptr);
703      --num_remove;
704    }
705    if (parent_vse != nullptr && parent_vse->ngram_info->pruned) {
706      pruned = true;
707    }
708    auto *ngram_info = new LanguageModelNgramInfo(pcontext_ptr, pcontext_unichar_step_len, pruned,
709                                                  ngram_cost, ngram_and_classifier_cost);
710    ngram_info->context += unichar;
711    ngram_info->context_unichar_step_len += unichar_step_len;
712    assert(ngram_info->context_unichar_step_len <= language_model_ngram_order);
713    return ngram_info;
714  }
715  float LanguageModel::ComputeNgramCost(const char *unichar, float certainty, float denom,
716                                        const char *context, int *unichar_step_len,
717                                        bool *found_small_prob, float *ngram_cost) {
718    const char *context_ptr = context;
719    char *modified_context = nullptr;
720    char *modified_context_end = nullptr;
721    const char *unichar_ptr = unichar;
722    const char *unichar_end = unichar_ptr + strlen(unichar_ptr);
723    float prob = 0.0f;
724    int step = 0;
725    while (unichar_ptr < unichar_end && (step = UNICHAR::utf8_step(unichar_ptr)) > 0) {
726      if (language_model_debug_level > 1) {
727        tprintf("prob(%s | %s)=%g\n", unichar_ptr, context_ptr,
728                dict_->ProbabilityInContext(context_ptr, -1, unichar_ptr, step));
729      }
730      prob += dict_->ProbabilityInContext(context_ptr, -1, unichar_ptr, step);
731      ++(*unichar_step_len);
732      if (language_model_ngram_use_only_first_uft8_step) {
733        break;
734      }
735      unichar_ptr += step;
736      if (unichar_ptr < unichar_end) {
737        if (modified_context == nullptr) {
738          size_t context_len = strlen(context);
739          modified_context = new char[context_len + strlen(unichar_ptr) + step + 1];
740          memcpy(modified_context, context, context_len);
741          modified_context_end = modified_context + context_len;
742          context_ptr = modified_context;
743        }
744        strncpy(modified_context_end, unichar_ptr - step, step);
745        modified_context_end += step;
746        *modified_context_end = '\0';
747      }
748    }
749    prob /= static_cast<float>(*unichar_step_len); 
750    if (prob < language_model_ngram_small_prob) {
751      if (language_model_debug_level > 0) {
752        tprintf("Found small prob %g\n", prob);
753      }
754      *found_small_prob = true;
755      prob = language_model_ngram_small_prob;
756    }
757    *ngram_cost = -1 * std::log2(prob);
758    float ngram_and_classifier_cost = -1 * std::log2(CertaintyScore(certainty) / denom) +
759                                      *ngram_cost * language_model_ngram_scale_factor;
760    if (language_model_debug_level > 1) {
761      tprintf("-log [ p(%s) * p(%s | %s) ] = -log2(%g*%g) = %g\n", unichar, unichar, context_ptr,
762              CertaintyScore(certainty) / denom, prob, ngram_and_classifier_cost);
763    }
764    delete[] modified_context;
765    return ngram_and_classifier_cost;
766  }
767  float LanguageModel::ComputeDenom(BLOB_CHOICE_LIST *curr_list) {
768    if (curr_list->empty()) {
769      return 1.0f;
770    }
771    float denom = 0.0f;
772    int len = 0;
773    BLOB_CHOICE_IT c_it(curr_list);
774    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
775      ASSERT_HOST(c_it.data() != nullptr);
776      ++len;
777      denom += CertaintyScore(c_it.data()->certainty());
778    }
779    assert(len != 0);
780    denom +=
781        (dict_->getUnicharset().size() - len) * CertaintyScore(language_model_ngram_nonmatch_score);
782    return denom;
783  }
784  void LanguageModel::FillConsistencyInfo(int curr_col, bool word_end, BLOB_CHOICE *b,
785                                          ViterbiStateEntry *parent_vse, WERD_RES *word_res,
786                                          LMConsistencyInfo *consistency_info) {
787    const UNICHARSET &unicharset = dict_->getUnicharset();
788    UNICHAR_ID unichar_id = b->unichar_id();
789    BLOB_CHOICE *parent_b = parent_vse != nullptr ? parent_vse->curr_b : nullptr;
790    if (unicharset.get_ispunctuation(unichar_id)) {
791      consistency_info->num_punc++;
792    }
793    if (dict_->GetPuncDawg() != nullptr && !consistency_info->invalid_punc) {
794      if (dict_->compound_marker(unichar_id) && parent_b != nullptr &&
795          (unicharset.get_isalpha(parent_b->unichar_id()) ||
796           unicharset.get_isdigit(parent_b->unichar_id()))) {
797        consistency_info->punc_ref = NO_EDGE;
798      } else {
799        bool is_apos = dict_->is_apostrophe(unichar_id);
800        bool prev_is_numalpha =
801            (parent_b != nullptr && (unicharset.get_isalpha(parent_b->unichar_id()) ||
802                                     unicharset.get_isdigit(parent_b->unichar_id())));
803        UNICHAR_ID pattern_unichar_id =
804            (unicharset.get_isalpha(unichar_id) || unicharset.get_isdigit(unichar_id) ||
805             (is_apos && prev_is_numalpha))
806                ? Dawg::kPatternUnicharID
807                : unichar_id;
808        if (consistency_info->punc_ref == NO_EDGE || pattern_unichar_id != Dawg::kPatternUnicharID ||
809            dict_->GetPuncDawg()->edge_letter(consistency_info->punc_ref) !=
810                Dawg::kPatternUnicharID) {
811          NODE_REF node = Dict::GetStartingNode(dict_->GetPuncDawg(), consistency_info->punc_ref);
812          consistency_info->punc_ref = (node != NO_EDGE) ? dict_->GetPuncDawg()->edge_char_of(
813                                                               node, pattern_unichar_id, word_end)
814                                                         : NO_EDGE;
815          if (consistency_info->punc_ref == NO_EDGE) {
816            consistency_info->invalid_punc = true;
817          }
818        }
819      }
820    }
821    if (parent_vse != nullptr && !word_end && dict_->compound_marker(unichar_id)) {
822      consistency_info->num_lower = 0;
823      consistency_info->num_non_first_upper = 0;
824    } else if (unicharset.get_islower(unichar_id)) {
825      consistency_info->num_lower++;
826    } else if ((parent_b != nullptr) && unicharset.get_isupper(unichar_id)) {
827      if (unicharset.get_isupper(parent_b->unichar_id()) || consistency_info->num_lower > 0 ||
828          consistency_info->num_non_first_upper > 0) {
829        consistency_info->num_non_first_upper++;
830      }
831    }
832    consistency_info->script_id = unicharset.get_script(unichar_id);
833    if (dict_->getUnicharset().han_sid() != dict_->getUnicharset().null_sid()) {
834      if ((unicharset.hiragana_sid() != unicharset.null_sid() &&
835           consistency_info->script_id == unicharset.hiragana_sid()) ||
836          (unicharset.katakana_sid() != unicharset.null_sid() &&
837           consistency_info->script_id == unicharset.katakana_sid())) {
838        consistency_info->script_id = dict_->getUnicharset().han_sid();
839      }
840    }
841    if (parent_vse != nullptr &&
842        (parent_vse->consistency_info.script_id != dict_->getUnicharset().common_sid())) {
843      int parent_script_id = parent_vse->consistency_info.script_id;
844      if (consistency_info->script_id == dict_->getUnicharset().common_sid()) {
845        consistency_info->script_id = parent_script_id;
846      }
847      if (consistency_info->script_id != parent_script_id) {
848        consistency_info->inconsistent_script = true;
849      }
850    }
851    if (unicharset.get_isalpha(unichar_id)) {
852      consistency_info->num_alphas++;
853    } else if (unicharset.get_isdigit(unichar_id)) {
854      consistency_info->num_digits++;
855    } else if (!unicharset.get_ispunctuation(unichar_id)) {
856      consistency_info->num_other++;
857    }
858    if (fontinfo_table_->size() > 0 && parent_b != nullptr) {
859      int fontinfo_id = -1;
860      if (parent_b->fontinfo_id() == b->fontinfo_id() ||
861          parent_b->fontinfo_id2() == b->fontinfo_id()) {
862        fontinfo_id = b->fontinfo_id();
863      } else if (parent_b->fontinfo_id() == b->fontinfo_id2() ||
864                 parent_b->fontinfo_id2() == b->fontinfo_id2()) {
865        fontinfo_id = b->fontinfo_id2();
866      }
867      if (language_model_debug_level > 1) {
868        tprintf(
869            "pfont %s pfont %s font %s font2 %s common %s(%d)\n",
870            (parent_b->fontinfo_id() >= 0) ? fontinfo_table_->at(parent_b->fontinfo_id()).name : "",
871            (parent_b->fontinfo_id2() >= 0) ? fontinfo_table_->at(parent_b->fontinfo_id2()).name
872                                            : "",
873            (b->fontinfo_id() >= 0) ? fontinfo_table_->at(b->fontinfo_id()).name : "",
874            (fontinfo_id >= 0) ? fontinfo_table_->at(fontinfo_id).name : "",
875            (fontinfo_id >= 0) ? fontinfo_table_->at(fontinfo_id).name : "", fontinfo_id);
876      }
877      if (!word_res->blob_widths.empty()) { 
878        bool expected_gap_found = false;
879        float expected_gap = 0.0f;
880        int temp_gap;
881        if (fontinfo_id >= 0) { 
882          ASSERT_HOST(fontinfo_id < fontinfo_table_->size());
883          if (fontinfo_table_->at(fontinfo_id)
884                  .get_spacing(parent_b->unichar_id(), unichar_id, &temp_gap)) {
885            expected_gap = temp_gap;
886            expected_gap_found = true;
887          }
888        } else {
889          consistency_info->inconsistent_font = true;
890          int num_addends = 0;
891          int temp_fid;
892          for (int i = 0; i < 4; ++i) {
893            if (i == 0) {
894              temp_fid = parent_b->fontinfo_id();
<span onclick='openModal()' class='match'>895            } else if (i == 1) {
896              temp_fid = parent_b->fontinfo_id2();
897            } else if (i == 2) {
898              temp_fid = b->fontinfo_id();
899            } else {
900              temp_fid = b->fontinfo_id2();
901            }
</span>902            ASSERT_HOST(temp_fid < 0 || fontinfo_table_->size());
903            if (temp_fid >= 0 && fontinfo_table_->at(temp_fid).get_spacing(parent_b->unichar_id(),
904                                                                           unichar_id, &temp_gap)) {
905              expected_gap += temp_gap;
906              num_addends++;
907            }
908          }
909          if (num_addends > 0) {
910            expected_gap /= static_cast<float>(num_addends);
911            expected_gap_found = true;
912          }
913        }
914        if (expected_gap_found) {
915          int actual_gap = word_res->GetBlobsGap(curr_col - 1);
916          if (actual_gap == 0) {
917            consistency_info->num_inconsistent_spaces++;
918          } else {
919            float gap_ratio = expected_gap / actual_gap;
920            if (gap_ratio < 0.0f || gap_ratio > 2.0f) {
921              consistency_info->num_inconsistent_spaces++;
922            }
923          }
924          if (language_model_debug_level > 1) {
925            tprintf("spacing for %s(%d) %s(%d) col %d: expected %g actual %d\n",
926                    unicharset.id_to_unichar(parent_b->unichar_id()), parent_b->unichar_id(),
927                    unicharset.id_to_unichar(unichar_id), unichar_id, curr_col, expected_gap,
928                    actual_gap);
929          }
930        }
931      }
932    }
933  }
934  float LanguageModel::ComputeAdjustedPathCost(ViterbiStateEntry *vse) {
935    ASSERT_HOST(vse != nullptr);
936    if (params_model_.Initialized()) {
937      float features[PTRAIN_NUM_FEATURE_TYPES];
938      ExtractFeaturesFromPath(*vse, features);
939      float cost = params_model_.ComputeCost(features);
940      if (language_model_debug_level > 3) {
941        tprintf("ComputeAdjustedPathCost %g ParamsModel features:\n", cost);
942        if (language_model_debug_level >= 5) {
943          for (int f = 0; f < PTRAIN_NUM_FEATURE_TYPES; ++f) {
944            tprintf("%s=%g\n", kParamsTrainingFeatureTypeName[f], features[f]);
945          }
946        }
947      }
948      return cost * vse->outline_length;
949    } else {
950      float adjustment = 1.0f;
951      if (vse->dawg_info == nullptr || vse->dawg_info->permuter != FREQ_DAWG_PERM) {
952        adjustment += language_model_penalty_non_freq_dict_word;
953      }
954      if (vse->dawg_info == nullptr) {
955        adjustment += language_model_penalty_non_dict_word;
956        if (vse->length > language_model_min_compound_length) {
957          adjustment +=
958              ((vse->length - language_model_min_compound_length) * language_model_penalty_increment);
959        }
960      }
961      if (vse->associate_stats.shape_cost > 0) {
962        adjustment += vse->associate_stats.shape_cost / static_cast<float>(vse->length);
963      }
964      if (language_model_ngram_on) {
965        ASSERT_HOST(vse->ngram_info != nullptr);
966        return vse->ngram_info->ngram_and_classifier_cost * adjustment;
967      } else {
968        adjustment += ComputeConsistencyAdjustment(vse->dawg_info, vse->consistency_info);
969        return vse->ratings_sum * adjustment;
970      }
971    }
972  }
973  void LanguageModel::UpdateBestChoice(ViterbiStateEntry *vse, LMPainPoints *pain_points,
974                                       WERD_RES *word_res, BestChoiceBundle *best_choice_bundle,
975                                       BlamerBundle *blamer_bundle) {
976    bool truth_path;
977    WERD_CHOICE *word =
978        ConstructWord(vse, word_res, &best_choice_bundle->fixpt, blamer_bundle, &truth_path);
979    ASSERT_HOST(word != nullptr);
980    if (dict_->stopper_debug_level >= 1) {
981      std::string word_str;
982      word->string_and_lengths(&word_str, nullptr);
983      vse->Print(word_str.c_str());
984    }
985    if (language_model_debug_level > 0) {
986      word->print("UpdateBestChoice() constructed word");
987    }
988    ParamsTrainingHypothesis curr_hyp;
989    if (blamer_bundle != nullptr) {
990      if (vse->dawg_info != nullptr) {
991        vse->dawg_info->permuter = static_cast<PermuterType>(word->permuter());
992      }
993      ExtractFeaturesFromPath(*vse, curr_hyp.features);
994      word->string_and_lengths(&(curr_hyp.str), nullptr);
995      curr_hyp.cost = vse->cost; 
996      if (language_model_debug_level > 0) {
997        tprintf("Raw features extracted from %s (cost=%g) [ ", curr_hyp.str.c_str(), curr_hyp.cost);
998        for (float feature : curr_hyp.features) {
999          tprintf("%g ", feature);
1000        }
1001        tprintf("]\n");
1002      }
1003      blamer_bundle->AddHypothesis(curr_hyp);
1004      if (truth_path) {
1005        blamer_bundle->UpdateBestRating(word->rating());
1006      }
1007    }
1008    if (blamer_bundle != nullptr && blamer_bundle->GuidedSegsearchStillGoing()) {
1009      delete word;
1010      return;
1011    }
1012    if (word_res->chopped_word != nullptr && !word_res->chopped_word->blobs.empty()) {
1013      word->SetScriptPositions(false, word_res->chopped_word, language_model_debug_level);
1014    }
1015    if (word_res->raw_choice == nullptr || word->rating() < word_res->raw_choice->rating()) {
1016      if (word_res->LogNewRawChoice(word) && language_model_debug_level > 0) {
1017        tprintf("Updated raw choice\n");
1018      }
1019    }
1020    word->set_rating(vse->cost);
1021    dict_->adjust_word(word, vse->dawg_info == nullptr, vse->consistency_info.xht_decision, 0.0,
1022                       false, language_model_debug_level > 0);
1023    if (!word_res->LogNewCookedChoice(dict_->tessedit_truncate_wordchoice_log,
1024                                      dict_->stopper_debug_level >= 1, word)) {
1025      return;
1026    }
1027    if (word_res->best_choice == word) {
1028      if (dict_->AcceptableChoice(*word, vse->consistency_info.xht_decision) &&
1029          AcceptablePath(*vse)) {
1030        acceptable_choice_found_ = true;
1031      }
1032      best_choice_bundle->updated = true;
1033      best_choice_bundle->best_vse = vse;
1034      if (language_model_debug_level > 0) {
1035        tprintf("Updated best choice\n");
1036        word->print_state("New state ");
1037      }
1038      if (vse->dawg_info != nullptr) {
1039        if (dict_->has_hyphen_end(*word)) {
1040          dict_->set_hyphen_word(*word, *(dawg_args_.active_dawgs));
1041        } else {
1042          dict_->reset_hyphen_vars(true);
1043        }
1044      }
1045      if (blamer_bundle != nullptr) {
1046        blamer_bundle->set_best_choice_is_dict_and_top_choice(vse->dawg_info != nullptr &&
1047                                                              vse->top_choice_flags);
1048      }
1049    }
1050  #ifndef GRAPHICS_DISABLED
1051    if (wordrec_display_segmentations && word_res->chopped_word != nullptr) {
1052      word->DisplaySegmentation(word_res->chopped_word);
1053    }
1054  #endif
1055  }
1056  void LanguageModel::ExtractFeaturesFromPath(const ViterbiStateEntry &vse, float features[]) {
1057    memset(features, 0, sizeof(float) * PTRAIN_NUM_FEATURE_TYPES);
1058    int len = vse.length <= kMaxSmallWordUnichars ? 0 : vse.length <= kMaxMediumWordUnichars ? 1 : 2;
1059    if (vse.dawg_info != nullptr) {
1060      int permuter = vse.dawg_info->permuter;
1061      if (permuter == NUMBER_PERM || permuter == USER_PATTERN_PERM) {
1062        if (vse.consistency_info.num_digits == vse.length) {
1063          features[PTRAIN_DIGITS_SHORT + len] = 1.0f;
1064        } else {
1065          features[PTRAIN_NUM_SHORT + len] = 1.0f;
1066        }
1067      } else if (permuter == DOC_DAWG_PERM) {
1068        features[PTRAIN_DOC_SHORT + len] = 1.0f;
1069      } else if (permuter == SYSTEM_DAWG_PERM || permuter == USER_DAWG_PERM ||
1070                 permuter == COMPOUND_PERM) {
1071        features[PTRAIN_DICT_SHORT + len] = 1.0f;
1072      } else if (permuter == FREQ_DAWG_PERM) {
1073        features[PTRAIN_FREQ_SHORT + len] = 1.0f;
1074      }
1075    }
1076    features[PTRAIN_SHAPE_COST_PER_CHAR] =
1077        vse.associate_stats.shape_cost / static_cast<float>(vse.length);
1078    features[PTRAIN_NGRAM_COST_PER_CHAR] = 0.0f;
1079    if (vse.ngram_info != nullptr) {
1080      features[PTRAIN_NGRAM_COST_PER_CHAR] =
1081          vse.ngram_info->ngram_cost / static_cast<float>(vse.length);
1082    }
1083    features[PTRAIN_NUM_BAD_CASE] = vse.consistency_info.NumInconsistentCase();
1084    features[PTRAIN_XHEIGHT_CONSISTENCY] = vse.consistency_info.xht_decision;
1085    features[PTRAIN_NUM_BAD_CHAR_TYPE] =
1086        vse.dawg_info == nullptr ? vse.consistency_info.NumInconsistentChartype() : 0.0f;
1087    features[PTRAIN_NUM_BAD_SPACING] = vse.consistency_info.NumInconsistentSpaces();
1088    if (vse.outline_length > 0.0f) {
1089      features[PTRAIN_RATING_PER_CHAR] = vse.ratings_sum / vse.outline_length;
1090    } else {
1091      features[PTRAIN_RATING_PER_CHAR] = 0.0f;
1092    }
1093  }
1094  WERD_CHOICE *LanguageModel::ConstructWord(ViterbiStateEntry *vse, WERD_RES *word_res,
1095                                            DANGERR *fixpt, BlamerBundle *blamer_bundle,
1096                                            bool *truth_path) {
1097    if (truth_path != nullptr) {
1098      *truth_path =
1099          (blamer_bundle != nullptr && vse->length == blamer_bundle->correct_segmentation_length());
1100    }
1101    BLOB_CHOICE *curr_b = vse->curr_b;
1102    ViterbiStateEntry *curr_vse = vse;
1103    int i;
1104    bool compound = dict_->hyphenated(); 
1105    float full_wh_ratio_mean = 0.0f;
1106    if (vse->associate_stats.full_wh_ratio_var != 0.0f) {
1107      vse->associate_stats.shape_cost -= vse->associate_stats.full_wh_ratio_var;
1108      full_wh_ratio_mean =
1109          (vse->associate_stats.full_wh_ratio_total / static_cast<float>(vse->length));
1110      vse->associate_stats.full_wh_ratio_var = 0.0f;
1111    }
1112    auto *word = new WERD_CHOICE(word_res->uch_set, vse->length);
1113    word->set_length(vse->length);
1114    int total_blobs = 0;
1115    for (i = (vse->length - 1); i >= 0; --i) {
1116      if (blamer_bundle != nullptr && truth_path != nullptr && *truth_path &&
1117          !blamer_bundle->MatrixPositionCorrect(i, curr_b->matrix_cell())) {
1118        *truth_path = false;
1119      }
1120      int num_blobs = curr_b->matrix_cell().row - curr_b->matrix_cell().col + 1;
1121      total_blobs += num_blobs;
1122      word->set_blob_choice(i, num_blobs, curr_b);
1123      if ((full_wh_ratio_mean != 0.0f &&
1124           ((curr_vse != vse && curr_vse->parent_vse != nullptr) ||
1125            !dict_->getUnicharset().get_ispunctuation(curr_b->unichar_id())))) {
1126        vse->associate_stats.full_wh_ratio_var +=
1127            pow(full_wh_ratio_mean - curr_vse->associate_stats.full_wh_ratio, 2);
1128        if (language_model_debug_level > 2) {
1129          tprintf("full_wh_ratio_var += (%g-%g)^2\n", full_wh_ratio_mean,
1130                  curr_vse->associate_stats.full_wh_ratio);
1131        }
1132      }
1133      if (!compound && curr_vse->dawg_info && curr_vse->dawg_info->permuter == COMPOUND_PERM) {
1134        compound = true;
1135      }
1136      curr_vse = curr_vse->parent_vse;
1137      if (curr_vse == nullptr) {
1138        break;
1139      }
1140      curr_b = curr_vse->curr_b;
1141    }
1142    ASSERT_HOST(i == 0); 
1143    ASSERT_HOST(total_blobs == word_res->ratings->dimension());
1144    if (full_wh_ratio_mean != 0.0f) {
1145      vse->associate_stats.shape_cost += vse->associate_stats.full_wh_ratio_var;
1146    }
1147    word->set_rating(vse->ratings_sum);
1148    word->set_certainty(vse->min_certainty);
1149    word->set_x_heights(vse->consistency_info.BodyMinXHeight(),
1150                        vse->consistency_info.BodyMaxXHeight());
1151    if (vse->dawg_info != nullptr) {
1152      word->set_permuter(compound ? COMPOUND_PERM : vse->dawg_info->permuter);
1153    } else if (language_model_ngram_on && !vse->ngram_info->pruned) {
1154      word->set_permuter(NGRAM_PERM);
1155    } else if (vse->top_choice_flags) {
1156      word->set_permuter(TOP_CHOICE_PERM);
1157    } else {
1158      word->set_permuter(NO_PERM);
1159    }
1160    word->set_dangerous_ambig_found_(!dict_->NoDangerousAmbig(word, fixpt, true, word_res->ratings));
1161    return word;
1162  }
1163  } 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-preferenceDlg.cpp</h3>
            <pre><code>1  #include <shlwapi.h>
2  #include "preferenceDlg.h"
3  #include "lesDlgs.h"
4  #include "EncodingMapper.h"
5  #include "localization.h"
6  #define MyGetGValue(rgb)      (LOBYTE((rgb)>>8))
7  using namespace std;
8  const int BLINKRATE_FASTEST = 50;
9  const int BLINKRATE_SLOWEST = 2500;
10  const int BLINKRATE_INTERVAL = 50;
11  const int CARETLINEFRAME_SMALLEST = 1;
12  const int CARETLINEFRAME_LARGEST = 6;
13  const int CARETLINEFRAME_INTERVAL = 1;
14  const int BORDERWIDTH_SMALLEST = 0;
15  const int BORDERWIDTH_LARGEST = 30;
16  const int BORDERWIDTH_INTERVAL = 1;
17  const int PADDING_SMALLEST = 0;
18  const int PADDING_LARGEST = 30;
19  const int PADDING_INTERVAL = 1;
20  const int DISTRACTIONFREE_SMALLEST = 3;
21  const int DISTRACTIONFREE_LARGEST = 9;
22  const int DISTRACTIONFREE_INTERVAL = 1;
23  constexpr int AUTOCOMPLETEFROMCHAR_SMALLEST = 1;
24  constexpr int AUTOCOMPLETEFROMCHAR_LARGEST = 9;
25  constexpr int AUTOCOMPLETEFROMCHAR_INTERVAL = 1;
26  static int encodings[] = {
27  	1250, 
28  	1251, 
29  	1252, 
30  	1253, 
31  	1254, 
32  	1255, 
33  	1256, 
34  	1257, 
35  	1258, 
36  	28591,
37  	28592,
38  	28593,
39  	28594,
40  	28595,
41  	28596,
42  	28597,
43  	28598,
44  	28599,
45  	28603,
46  	28604,
47  	28605,
48  	437,  
49  	720,  
50  	737,  
51  	775,  
52  	850,  
53  	852,  
54  	855,  
55  	857,  
56  	858,  
57  	860,  
58  	861,  
59  	862,  
60  	863,  
61  	865,  
62  	866,  
63  	869,  
64  	950,  
65  	936,  
66  	932,  
67  	949,  
68  	51949,
69  	874,
70  	10007,
71  	21866,
72  	20866
73  };
74  bool PreferenceDlg::goToSection(size_t iPage, intptr_t ctrlID)
75  {
76  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_SETCURSEL, iPage, 0);
77  	showDialogByIndex(iPage);
78  	getFocus();
79  	if (ctrlID != -1)
80  	{
81  		::SetFocus(::GetDlgItem(_wVector[iPage]._dlg->getHSelf(), int(ctrlID)));
82  	}
83  	return true;
84  }
85  intptr_t CALLBACK PreferenceDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
86  {
87  	switch (message) 
88  	{
89  		case WM_INITDIALOG :
90  		{
91  			_generalSubDlg.init(_hInst, _hSelf);
92  			_generalSubDlg.create(IDD_PREFERENCE_SUB_GENRAL, false, false);
93  			_generalSubDlg.display();
94  			_editingSubDlg.init(_hInst, _hSelf);
95  			_editingSubDlg.create(IDD_PREFERENCE_SUB_EDITING, false, false);
96  			_darkModeSubDlg.init(_hInst, _hSelf);
97  			_darkModeSubDlg.create(IDD_PREFERENCE_SUB_DARKMODE, false, false);
98  			_marginsBorderEdgeSubDlg.init(_hInst, _hSelf);
99  			_marginsBorderEdgeSubDlg.create(IDD_PREFERENCE_SUB_MARGING_BORDER_EDGE, false, false);
100  			_miscSubDlg.init(_hInst, _hSelf);
101  			_miscSubDlg.create(IDD_PREFERENCE_SUB_MISC, false, false);
102  			_newDocumentSubDlg.init(_hInst, _hSelf);
103  			_newDocumentSubDlg.create(IDD_PREFERENCE_SUB_NEWDOCUMENT, false, false);
104  			_defaultDirectorySubDlg.init(_hInst, _hSelf);
105  			_defaultDirectorySubDlg.create(IDD_PREFERENCE_SUB_DEFAULTDIRECTORY, false, false);
106  			_recentFilesHistorySubDlg.init(_hInst, _hSelf);
107  			_recentFilesHistorySubDlg.create(IDD_PREFERENCE_SUB_RECENTFILESHISTORY, false, false);
108  			_fileAssocDlg.init(_hInst, _hSelf);
109  			_fileAssocDlg.create(IDD_REGEXT_BOX, false, false);
110  			_printSubDlg.init(_hInst, _hSelf);
111  			_printSubDlg.create(IDD_PREFERENCE_SUB_PRINT, false, false);
112  			_searchingSubDlg.init(_hInst, _hSelf);
113  			_searchingSubDlg.create(IDD_PREFERENCE_SUB_SEARCHING, false, false);
114  			_languageSubDlg.init(_hInst, _hSelf);
115  			_languageSubDlg.create(IDD_PREFERENCE_SUB_LANGUAGE, false, false);
116  			_highlightingSubDlg.init(_hInst, _hSelf);
117  			_highlightingSubDlg.create(IDD_PREFERENCE_SUB_HIGHLIGHTING, false, false);
118  			_backupSubDlg.init(_hInst, _hSelf);
119  			_backupSubDlg.create(IDD_PREFERENCE_SUB_BACKUP, false, false);
120  			_autoCompletionSubDlg.init(_hInst, _hSelf);
121  			_autoCompletionSubDlg.create(IDD_PREFERENCE_SUB_AUTOCOMPLETION, false, false);
122  			_multiInstanceSubDlg.init(_hInst, _hSelf);
123  			_multiInstanceSubDlg.create(IDD_PREFERENCE_SUB_MULTIINSTANCE, false, false);
124  			_delimiterSubDlg.init(_hInst, _hSelf);
125  			_delimiterSubDlg.create(IDD_PREFERENCE_SUB_DELIMITER, false, false);
126  			_performanceSubDlg.init(_hInst, _hSelf);
127  			_performanceSubDlg.create(IDD_PREFERENCE_SUB_PERFORMANCE, false, false);
128  			_cloudAndLinkSubDlg.init(_hInst, _hSelf);
129  			_cloudAndLinkSubDlg.create(IDD_PREFERENCE_SUB_CLOUD_LINK, false, false);
130  			_searchEngineSubDlg.init(_hInst, _hSelf);
131  			_searchEngineSubDlg.create(IDD_PREFERENCE_SUB_SEARCHENGINE, false, false);			
132  			_wVector.push_back(DlgInfo(&_generalSubDlg, TEXT("General"), TEXT("Global")));
133  			_wVector.push_back(DlgInfo(&_editingSubDlg, TEXT("Editing"), TEXT("Scintillas")));
134  			_wVector.push_back(DlgInfo(&_darkModeSubDlg, TEXT("Dark Mode"), TEXT("DarkMode")));
135  			_wVector.push_back(DlgInfo(&_marginsBorderEdgeSubDlg, TEXT("Margins/Border/Edge"), TEXT("MarginsBorderEdge")));
136  			_wVector.push_back(DlgInfo(&_newDocumentSubDlg, TEXT("New Document"), TEXT("NewDoc")));
137  			_wVector.push_back(DlgInfo(&_defaultDirectorySubDlg, TEXT("Default Directory"), TEXT("DefaultDir")));
138  			_wVector.push_back(DlgInfo(&_recentFilesHistorySubDlg, TEXT("Recent Files History"), TEXT("RecentFilesHistory")));
139  			_wVector.push_back(DlgInfo(&_fileAssocDlg, TEXT("File Association"), TEXT("FileAssoc")));
140  			_wVector.push_back(DlgInfo(&_languageSubDlg, TEXT("Language"), TEXT("Language")));
141  			_wVector.push_back(DlgInfo(&_highlightingSubDlg, TEXT("Highlighting"), TEXT("Highlighting")));
142  			_wVector.push_back(DlgInfo(&_printSubDlg, TEXT("Print"), TEXT("Print")));
143  			_wVector.push_back(DlgInfo(&_searchingSubDlg, TEXT("Searching"), TEXT("Searching")));
144  			_wVector.push_back(DlgInfo(&_backupSubDlg, TEXT("Backup"), TEXT("Backup")));
145  			_wVector.push_back(DlgInfo(&_autoCompletionSubDlg, TEXT("Auto-Completion"), TEXT("AutoCompletion")));
146  			_wVector.push_back(DlgInfo(&_multiInstanceSubDlg, TEXT("Multi-Instance & Date"), TEXT("MultiInstance")));
147  			_wVector.push_back(DlgInfo(&_delimiterSubDlg, TEXT("Delimiter"), TEXT("Delimiter")));
148  			_wVector.push_back(DlgInfo(&_performanceSubDlg, TEXT("Performance"), TEXT("Performance")));
149  			_wVector.push_back(DlgInfo(&_cloudAndLinkSubDlg, TEXT("Cloud & Link"), TEXT("Cloud")));
150  			_wVector.push_back(DlgInfo(&_searchEngineSubDlg, TEXT("Search Engine"), TEXT("SearchEngine")));
151  			_wVector.push_back(DlgInfo(&_miscSubDlg, TEXT("MISC."), TEXT("MISC")));
152  			makeCategoryList();
153  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
154  			return TRUE;
155  		}
156  		case WM_CTLCOLORLISTBOX:
157  		{
158  			return NppDarkMode::onCtlColorListbox(wParam, lParam);
159  		}
160  		case WM_CTLCOLORDLG:
161  		case WM_CTLCOLORSTATIC:
162  		{
163  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
164  		}
165  		case WM_PRINTCLIENT:
166  		{
167  			if (NppDarkMode::isEnabled())
168  			{
169  				return TRUE;
170  			}
171  			break;
172  		}
173  		case NPPM_INTERNAL_REFRESHDARKMODE:
174  		{
175  			NppDarkMode::autoThemeChildControls(_hSelf);
176  			if (_editingSubDlg._tip != nullptr)
177  				NppDarkMode::setDarkTooltips(_editingSubDlg._tip, NppDarkMode::ToolTipsType::tooltip);
178  			for (auto& tip : _editingSubDlg._tips)
179  			{
180  				if (tip != nullptr)
181  				{
182  					NppDarkMode::setDarkTooltips(tip, NppDarkMode::ToolTipsType::tooltip);
183  				}
184  			}
185  			if (_delimiterSubDlg._tip != nullptr)
186  				NppDarkMode::setDarkTooltips(_delimiterSubDlg._tip, NppDarkMode::ToolTipsType::tooltip);
187  			if (_performanceSubDlg._largeFileRestrictionTip != nullptr)
188  				NppDarkMode::setDarkTooltips(_performanceSubDlg._largeFileRestrictionTip, NppDarkMode::ToolTipsType::tooltip);
189  			if (NppDarkMode::isEnabled())
190  			{
191  				const NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
192  				::EnableWindow(::GetDlgItem(_highlightingSubDlg.getHSelf(), IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
193  				const bool noBackup = _backupSubDlg.isCheckedOrNot(IDC_RADIO_BKNONE);
194  				::EnableWindow(::GetDlgItem(_backupSubDlg.getHSelf(), IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC), !noBackup);
195  				const bool isEnableAutoC = _autoCompletionSubDlg.isCheckedOrNot(IDD_AUTOC_ENABLECHECK);
196  				::EnableWindow(::GetDlgItem(_autoCompletionSubDlg.getHSelf(), IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
197  			}
198  			return TRUE;
199  		}
200  		case PREF_MSG_SETGUITOOLICONSSET:
201  		{
202  			const HWND generalSubDlg = _generalSubDlg.getHSelf();
203  			auto checkOrUncheckBtn = [&generalSubDlg](int id, WPARAM check = BST_UNCHECKED) -> void
204  			{
205  				::SendDlgItemMessage(generalSubDlg, id, BM_SETCHECK, check, 0);
206  			};
207  			const int iconState = NppDarkMode::getToolBarIconSet(static_cast<bool>(wParam));
208  			NppParameters& nppParams = NppParameters::getInstance();
209  			NppGUI& nppGUI = nppParams.getNppGUI();
210  			if (iconState != -1)
211  			{
212  				nppGUI._toolBarStatus = static_cast<toolBarStatusType>(iconState);
213  			}
214  			else
215  			{
216  				auto state = TB_STANDARD;
217  				if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_SMALLICON))
218  				{
219  					state = TB_SMALL;
220  				}
221  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_BIGICON))
222  				{
223  					state = TB_LARGE;
224  				}
225  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_SMALLICON2))
226  				{
227  					state = TB_SMALL2;
228  				}
229  				else if (_generalSubDlg.isCheckedOrNot(IDC_RADIO_BIGICON2))
230  				{
231  					state = TB_LARGE2;
232  				}
233  				nppGUI._toolBarStatus = state;
234  			}
235  			checkOrUncheckBtn(IDC_RADIO_STANDARD);
236  			checkOrUncheckBtn(IDC_RADIO_SMALLICON);
237  			checkOrUncheckBtn(IDC_RADIO_BIGICON);
238  			checkOrUncheckBtn(IDC_RADIO_SMALLICON2);
239  			checkOrUncheckBtn(IDC_RADIO_BIGICON2);
240  			switch (nppGUI._toolBarStatus)
241  			{
242  				case TB_LARGE:
243  				{
244  					checkOrUncheckBtn(IDC_RADIO_BIGICON, BST_CHECKED);
245  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE, 0);
246  					break;
247  				}
248  				case TB_SMALL2:
249  				{
250  					checkOrUncheckBtn(IDC_RADIO_SMALLICON2, BST_CHECKED);
251  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE_SET2, 0);
252  					break;
253  				}
254  				case TB_LARGE2:
255  				{
256  					checkOrUncheckBtn(IDC_RADIO_BIGICON2, BST_CHECKED);
257  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE_SET2, 0);
258  					break;
259  				}
260  				case TB_STANDARD:
261  				{
262  					checkOrUncheckBtn(IDC_RADIO_STANDARD, BST_CHECKED);
263  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_STANDARD, 0);
264  					break;
265  				}
266  				default:
267  				{
268  					checkOrUncheckBtn(IDC_RADIO_SMALLICON, BST_CHECKED);
269  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE, 0);
270  				}
271  			}
272  			return TRUE;
273  		}
274  		case PREF_MSG_SETGUITABBARICONS:
275  		{
276  			const int tabIconSet = NppDarkMode::getTabIconSet(static_cast<bool>(wParam));
277  			if (tabIconSet != -1)
278  			{
279  				_generalSubDlg.setTabbarAlternateIcons(tabIconSet == 1);
280  			}
281  			return TRUE;
282  		}
283  		case WM_COMMAND :
284  		{
285  			if (LOWORD(wParam) == IDC_LIST_DLGTITLE)
286  			{
287  				if (HIWORD(wParam) == CBN_SELCHANGE)
288  				{
289  					auto i = ::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETCURSEL, 0, 0);
290  					if (i != LB_ERR)
291  					{
292  						showDialogByIndex(i);
293  					}
294  				}
295  			}
296  			else 
297  			{
298  				switch (wParam)
299  				{
300  					case IDC_BUTTON_CLOSE :
301  					case IDCANCEL :
302  						display(false);
303  						return TRUE;
304  					default :
305  						::SendMessage(_hParent, WM_COMMAND, wParam, lParam);
306  						return TRUE;
307  				}
308  			}
309  		}
310  	}
311  	return FALSE;
312  }
313  void PreferenceDlg::makeCategoryList()
314  {
315  	for (size_t i = 0, len = _wVector.size(); i < len; ++i)
316  	{
317  		::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(_wVector[i]._name.c_str()));
318  	}
319  	setListSelection(0);
320  }
321  int32_t PreferenceDlg::getIndexFromName(const TCHAR *name) const
322  {
323  	if (!name)
324  		return -1;
325  	int32_t i = 0;
326  	for (auto it = _wVector.begin() ; it != _wVector.end(); ++it, ++i)
327  	{
328  		if (it->_internalName == name)
329  			return i;
330  	}
331  	return -1;
332  }
333  bool PreferenceDlg::setListSelection(size_t currentSel) const
334  {
335  	const size_t selStrLenMax = 255;
336  	TCHAR selStr[selStrLenMax + 1] = { '\0' };
337  	auto lbTextLen = ::SendMessage(_hSelf, LB_GETTEXTLEN, currentSel, 0);
338  	if (static_cast<size_t>(lbTextLen) > selStrLenMax)
339  		return false;
340  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXT, currentSel, reinterpret_cast<LPARAM>(selStr));
341  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_SELECTSTRING, currentSel, reinterpret_cast<LPARAM>(selStr));
342  	return true;
343  }
344  bool PreferenceDlg::renameDialogTitle(const TCHAR *internalName, const TCHAR *newName)
345  {
346  	bool foundIt = false;
347  	size_t i = 0;
348  	for (size_t len = _wVector.size(); i < len; ++i)
349  	{
350  		if (_wVector[i]._internalName == internalName)
351  		{
352  			foundIt = true;
353  			break;
354  		}
355  	}
356  	if (!foundIt)
357  		return false;
358  	const size_t lenMax = 256;
359  	TCHAR oldName[lenMax] = { '\0' };
360  	size_t txtLen = ::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXTLEN, i, 0);
361  	if (txtLen >= lenMax)
362  		return false;
363  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETTEXT, i, reinterpret_cast<LPARAM>(oldName));
364  	if (lstrcmp(newName, oldName) == 0)
365  		return true;
366  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_DELETESTRING, i, 0);
367  	::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_INSERTSTRING, i, reinterpret_cast<LPARAM>(newName));
368  	return true;
369  }
370  void PreferenceDlg::showDialogByName(const TCHAR *name) const
371  {
372  	int32_t i = getIndexFromName(name);
373  	if (i >= 0)
374  	{
375  		showDialogByIndex(i);
376  		setListSelection(i);
377  	}
378  }
379  void PreferenceDlg::showDialogByIndex(size_t index) const
380  {
381  	size_t len = _wVector.size();
382  	for (size_t i = 0; i < len; ++i)
383  	{
384  		_wVector[i]._dlg->display(false);
385  	}
386  	_wVector[index]._dlg->display(true);
387  }
388  void PreferenceDlg::destroy()
389  {
390  	_generalSubDlg.destroy();
391  	_editingSubDlg.destroy();
392  	_darkModeSubDlg.destroy();
393  	_marginsBorderEdgeSubDlg.destroy();
394  	_miscSubDlg.destroy();
395  	_fileAssocDlg.destroy();
396  	_languageSubDlg.destroy();
397  	_highlightingSubDlg.destroy();
398  	_printSubDlg.destroy();
399  	_searchingSubDlg.destroy();
400  	_newDocumentSubDlg.destroy();
401  	_defaultDirectorySubDlg.destroy();
402  	_recentFilesHistorySubDlg.destroy();
403  	_backupSubDlg.destroy();
404  	_autoCompletionSubDlg.destroy();
405  	_multiInstanceSubDlg.destroy();
406  	_delimiterSubDlg.destroy();
407  	_performanceSubDlg.destroy();
408  }
409  void GeneralSubDlg::setTabbarAlternateIcons(bool enable)
410  {
411  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
412  	if (!enable)
413  	{
414  		nppGUI._tabStatus &= ~TAB_ALTICONS;
415  		::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, BST_UNCHECKED, 0);
416  	}
417  	else
418  	{
419  		nppGUI._tabStatus |= TAB_ALTICONS;
420  		::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, BST_CHECKED, 0);
421  	}
422  }
423  intptr_t CALLBACK GeneralSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
424  {
425  	NppParameters& nppParam = NppParameters::getInstance();
426  	switch (message) 
427  	{
428  		case WM_INITDIALOG :
429  		{
430  			const NppGUI & nppGUI = nppParam.getNppGUI();
431  			toolBarStatusType tbStatus = nppGUI._toolBarStatus;
432  			int tabBarStatus = nppGUI._tabStatus;
433  			bool showTool = nppGUI._toolbarShow;
434  			bool showStatus = nppGUI._statusBarShow;
435  			bool showMenu = nppGUI._menuBarShow;
436  			bool hideRightShortcutsFromMenu = nppGUI._hideMenuRightShortcuts;
437  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDE, BM_SETCHECK, showTool?BST_UNCHECKED:BST_CHECKED, 0);
438  			int ID2Check = 0;
439  			switch (tbStatus)
440  			{
441  				case TB_SMALL :
442  					ID2Check = IDC_RADIO_SMALLICON;
443  					break;
444  				case TB_LARGE :
445  					ID2Check = IDC_RADIO_BIGICON;
446  					break;
447  				case TB_SMALL2 :
448  					ID2Check = IDC_RADIO_SMALLICON2;
449  					break;
450  				case TB_LARGE2 :
451  					ID2Check = IDC_RADIO_BIGICON2;
452  					break;
453  				case TB_STANDARD:
454  				default :
455  					ID2Check = IDC_RADIO_STANDARD;
456  			}
457  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
458  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REDUCE, BM_SETCHECK, tabBarStatus & TAB_REDUCE, 0);
459  			::SendDlgItemMessage(_hSelf, IDC_CHECK_LOCK, BM_SETCHECK, !(tabBarStatus & TAB_DRAGNDROP), 0);
460  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ORANGE, BM_SETCHECK, tabBarStatus & TAB_DRAWTOPBAR, 0);
461  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DRAWINACTIVE, BM_SETCHECK, tabBarStatus & TAB_DRAWINACTIVETAB, 0);
462  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLETABCLOSE, BM_SETCHECK, tabBarStatus & TAB_CLOSEBUTTON, 0);
463  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DBCLICK2CLOSE, BM_SETCHECK, tabBarStatus & TAB_DBCLK2CLOSE, 0);
464  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_VERTICAL, BM_SETCHECK, tabBarStatus & TAB_VERTICAL, 0);
465  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_MULTILINE, BM_SETCHECK, tabBarStatus & TAB_MULTILINE, 0);
466  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_LAST_EXIT, BM_SETCHECK, tabBarStatus & TAB_QUITONEMPTY, 0);
467  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_ALTICONS, BM_SETCHECK, tabBarStatus & TAB_ALTICONS, 0);
468  			::SendDlgItemMessage(_hSelf, IDC_CHECK_TAB_HIDE, BM_SETCHECK, tabBarStatus & TAB_HIDE, 0);
469  			::SendMessage(_hSelf, WM_COMMAND, IDC_CHECK_TAB_HIDE, 0);
470  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDESTATUSBAR, BM_SETCHECK, !showStatus, 0);
471  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDEMENUBAR, BM_SETCHECK, !showMenu, 0);
472  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR, BM_SETCHECK, hideRightShortcutsFromMenu, 0);
473  			LocalizationSwitcher & localizationSwitcher = nppParam.getLocalizationSwitcher();
474  			for (size_t i = 0, len = localizationSwitcher.size(); i < len ; ++i)
475  			{
476  				pair<wstring, wstring> localizationInfo = localizationSwitcher.getElementFromIndex(i);
477  				::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(localizationInfo.first.c_str()));
478  			}
479  			wstring lang = TEXT("English"); 
480  			if (nppParam.getNativeLangA()) 
481  			{
482  				string fn = localizationSwitcher.getFileName();
483  				wstring fnW = s2ws(fn);
484  				lang = localizationSwitcher.getLangFromXmlFileName(fnW.c_str());
485  			}
486  			auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(lang.c_str()));
487  			if (index != CB_ERR)
488                  ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_SETCURSEL, index, 0);
489  			return TRUE;
490  		}
491  		case WM_CTLCOLORLISTBOX:
492  		{
493  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
494  		}
495  		case WM_CTLCOLORDLG:
496  		case WM_CTLCOLORSTATIC:
497  		{
498  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
499  		}
500  		case WM_PRINTCLIENT:
501  		{
502  			if (NppDarkMode::isEnabled())
503  			{
504  				return TRUE;
505  			}
506  			break;
507  		}
508  		case WM_COMMAND:
509  		{
510  			switch (wParam)
511  			{
512  				case IDC_CHECK_HIDESTATUSBAR:
513  				{
514  					const bool isChecked = isCheckedOrNot(IDC_CHECK_HIDESTATUSBAR);
515  					::SendMessage(::GetParent(_hParent), NPPM_HIDESTATUSBAR, 0, isChecked ? TRUE : FALSE);
516  				}
517  				return TRUE;
518  				case IDC_CHECK_HIDEMENUBAR :
519  				{
520  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDEMENUBAR, BM_GETCHECK, 0, 0));
521  					::SendMessage(::GetParent(_hParent), NPPM_HIDEMENU, 0, isChecked?TRUE:FALSE);
522  				}
523  				return TRUE;
524  				case IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR:
525  				{
526  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDERIGHTSHORTCUTSOFMENUBAR, BM_GETCHECK, 0, 0));
527  					NppGUI& nppGUI = nppParam.getNppGUI();
528  					nppGUI._hideMenuRightShortcuts = isChecked;
529  				}
530  				return TRUE;
531  				case IDC_CHECK_TAB_HIDE :
532  				{
533  					bool toBeHidden = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_TAB_HIDE), BM_GETCHECK, 0, 0));
534  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_MULTILINE), !toBeHidden);
535  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_VERTICAL), !toBeHidden);
536  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REDUCE), !toBeHidden);
537  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_LOCK), !toBeHidden);
538  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ORANGE), !toBeHidden);
539  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_DRAWINACTIVE), !toBeHidden);
540  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLETABCLOSE), !toBeHidden);
541  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_DBCLICK2CLOSE), !toBeHidden);
542  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_LAST_EXIT), !toBeHidden);
543  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_TAB_ALTICONS), !toBeHidden);
544  					::SendMessage(::GetParent(_hParent), NPPM_HIDETABBAR, 0, toBeHidden);
545  					return TRUE;
546  				}
547  				case  IDC_CHECK_TAB_VERTICAL:
548  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_VERTICAL, 0);
549  					return TRUE;
550  				case IDC_CHECK_TAB_MULTILINE :
551  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_MULTILINE, 0);
552  					return TRUE;
553  				case IDC_CHECK_TAB_LAST_EXIT:
554  				{
555  					NppGUI & nppGUI = nppParam.getNppGUI();
556  					nppGUI._tabStatus ^= TAB_QUITONEMPTY;
557  				}
558  				return TRUE;
559  				case IDC_CHECK_TAB_ALTICONS:
560  				{
561  					NppGUI& nppGUI = nppParam.getNppGUI();
562  					nppGUI._tabStatus ^= TAB_ALTICONS;
563  					const bool isChecked = isCheckedOrNot(IDC_CHECK_TAB_ALTICONS);
564  					const bool isBtnCmd = true;
565  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CHANGETABBAEICONS, static_cast<WPARAM>(isBtnCmd), isChecked ? 1 : (nppGUI._darkmode._isEnabled ? 2 : 0));
566  					NppDarkMode::setTabIconSet(isChecked, NppDarkMode::isEnabled());
567  					return TRUE;
568  				}
569  				case IDC_CHECK_REDUCE :
570  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_REDUCETABBAR, 0);
571  					return TRUE;
572  				case IDC_CHECK_LOCK :
573  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LOCKTABBAR, 0);
574  					return TRUE;
575  				case IDC_CHECK_ORANGE :
576  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_TOPBAR, 0);
577  					return TRUE;
578  				case IDC_CHECK_DRAWINACTIVE :
579  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_INACIVETAB, 0);
580  					return TRUE;
581  				case IDC_CHECK_ENABLETABCLOSE :
582  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_CLOSEBOTTUN, 0);
583  					return TRUE;
584  				case IDC_CHECK_DBCLICK2CLOSE :
585  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_DRAWTABBAR_DBCLK2CLOSE, 0);
586  					return TRUE;
587  				case IDC_CHECK_HIDE :
588  				{
589  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_HIDE, BM_GETCHECK, 0, 0));
590  					::SendMessage(::GetParent(_hParent), NPPM_HIDETOOLBAR, 0, isChecked?TRUE:FALSE);
591  				}
592  				return TRUE;
593  				case IDC_RADIO_SMALLICON :
594  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE, 0);
595  					NppDarkMode::setToolBarIconSet(0, NppDarkMode::isEnabled());
596  					return TRUE;
597  				case IDC_RADIO_BIGICON :
598  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE, 0);
599  					NppDarkMode::setToolBarIconSet(1, NppDarkMode::isEnabled());
600  					return TRUE;
601  				case IDC_RADIO_SMALLICON2:
602  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_REDUCE_SET2, 0);
603  					NppDarkMode::setToolBarIconSet(2, NppDarkMode::isEnabled());
604  					return TRUE;
605  				case IDC_RADIO_BIGICON2:
606  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_ENLARGE_SET2, 0);
607  					NppDarkMode::setToolBarIconSet(3, NppDarkMode::isEnabled());
608  					return TRUE;
609  				case IDC_RADIO_STANDARD :
610  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_TOOLBAR_STANDARD, 0);
611  					NppDarkMode::setToolBarIconSet(4, NppDarkMode::isEnabled());
612  					return TRUE;
613  				default :
614  					switch (HIWORD(wParam))
615  					{
616  						case CBN_SELCHANGE : 
617  						{
618  							switch (LOWORD(wParam))
619  							{
620  								case IDC_COMBO_LOCALIZATION :
621  								{
622  									LocalizationSwitcher & localizationSwitcher = nppParam.getLocalizationSwitcher();
623  									auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETCURSEL, 0, 0);
624  									TCHAR langName[MAX_PATH] = { '\0' };
625  									auto cbTextLen = ::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETLBTEXTLEN, index, 0);
626  									if (cbTextLen > MAX_PATH - 1)
627  										return TRUE;
628  									::SendDlgItemMessage(_hSelf, IDC_COMBO_LOCALIZATION, CB_GETLBTEXT, index, reinterpret_cast<LPARAM>(langName));
629  									if (langName[0])
630  									{
631  										if (localizationSwitcher.switchToLang(TEXT("English")))
632  										{
633  											::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RELOADNATIVELANG, 0, 0);
634  										}
635  										if (localizationSwitcher.switchToLang(langName))
636  										{
637  											::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RELOADNATIVELANG, 0, 0);
638  											::InvalidateRect(_hParent, NULL, TRUE);
639  										}
640  									}
641  								}
642  								return TRUE;
643  								default:
644  									break;
645  							}
646  						}
647  					}
648  			}
649  		}
650  	}
651  	return FALSE;
652  }
653  void EditingSubDlg::initScintParam()
654  {
655  	NppParameters& nppParam = NppParameters::getInstance();
656  	ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
657  	int id = 0;
658  	switch (svp._lineWrapMethod)
659  	{
660  		case LINEWRAP_ALIGNED:
661  			id = IDC_RADIO_LWALIGN;
662  			break;
663  		case LINEWRAP_INDENT:
664  			id = IDC_RADIO_LWINDENT;
665  			break;
666  		default : 
667  			id = IDC_RADIO_LWDEF;
668  	}
669  	::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
670  	::SendDlgItemMessage(_hSelf, IDC_CHECK_SMOOTHFONT, BM_SETCHECK, svp._doSmoothFont, 0);
671  	int lineHilite = 0;
672  	switch (svp._currentLineHiliteMode)
673  	{
674  		case LINEHILITE_NONE:
675  			lineHilite = IDC_RADIO_CLM_NONE;
676  			break;
677  		case LINEHILITE_FRAME:
678  			lineHilite = IDC_RADIO_CLM_FRAME;
679  			break;
680  		default : 
681  			lineHilite = IDC_RADIO_CLM_HILITE;
682  	}
683  	::SendDlgItemMessage(_hSelf, lineHilite, BM_SETCHECK, TRUE, 0);
684  	::EnableWindow(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), (svp._currentLineHiliteMode == LINEHILITE_FRAME));
685  	::SendDlgItemMessage(_hSelf, IDC_CHECK_VIRTUALSPACE, BM_SETCHECK, svp._virtualSpace, 0);
686  	::SendDlgItemMessage(_hSelf, IDC_CHECK_SCROLLBEYONDLASTLINE, BM_SETCHECK, svp._scrollBeyondLastLine, 0);
687  	::SendDlgItemMessage(_hSelf, IDC_CHECK_RIGHTCLICKKEEPSSELECTION, BM_SETCHECK, svp._rightClickKeepsSelection, 0);
688  	::SendDlgItemMessage(_hSelf, IDC_CHECK_DISABLEADVANCEDSCROLL, BM_SETCHECK, svp._disableAdvancedScrolling, 0);
689  }
690  void EditingSubDlg::changeLineHiliteMode(bool enableSlider)
691  {
692  	::EnableWindow(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), enableSlider);
693  	redrawDlgItem(IDC_CARETLINEFRAME_WIDTH_STATIC);
694  	redrawDlgItem(IDC_CARETLINEFRAME_WIDTH_DISPLAY);
695  	::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_CURLINE_HILITING, 0);
696  }
697  static WNDPROC oldFunclstToolbarProc = NULL;
698  static LRESULT CALLBACK editNumSpaceProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
699  {
700  	switch (message)
701  	{
702  		case WM_CHAR:
703  		{
704  			if ((wParam != 8 && wParam != 32 && wParam < 48) || wParam > 57)
705  			{
706  				return TRUE;
707  			}
708  		}
709  	}
710  	return oldFunclstToolbarProc(hwnd, message, wParam, lParam);
711  }
712  intptr_t CALLBACK EditingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
713  {
714  	NppParameters& nppParam = NppParameters::getInstance();
715  	NppGUI & nppGUI = nppParam.getNppGUI();
716  	ScintillaViewParams& svp = (ScintillaViewParams&)nppParam.getSVP();
717  	switch (message)
718  	{
719  		case WM_INITDIALOG :
720  		{
721  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("0")));
722  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("1")));
723  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("2")));
724  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("3")));
725  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Block")));
726  			::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Block After")));
727  			::SendMessage(::GetDlgItem(_hSelf, IDC_WIDTH_COMBO), CB_SETCURSEL, nppGUI._caretWidth, 0);
728  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FOLDINGTOGGLE, BM_SETCHECK, nppGUI._enableFoldCmdToggable, 0);
729  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MULTISELECTION, BM_SETCHECK, nppGUI._enableMultiSelection, 0);
730  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETRANGEMIN, TRUE, BLINKRATE_FASTEST);
731  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETRANGEMAX, TRUE, BLINKRATE_SLOWEST);
732  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETPAGESIZE, 0, BLINKRATE_INTERVAL);
733  			int blinkRate = (nppGUI._caretBlinkRate == 0) ? BLINKRATE_SLOWEST : nppGUI._caretBlinkRate;
734  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER),TBM_SETPOS, TRUE, blinkRate);
735  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETRANGEMIN, TRUE, CARETLINEFRAME_SMALLEST);
736  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETRANGEMAX, TRUE, CARETLINEFRAME_LARGEST);
737  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETPAGESIZE, 0, CARETLINEFRAME_INTERVAL);
738  			::SendMessage(::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER), TBM_SETPOS, TRUE, svp._currentLineFrameWidth);
739  			::SetDlgItemInt(_hSelf, IDC_CARETLINEFRAME_WIDTH_DISPLAY, svp._currentLineFrameWidth, FALSE);
740  			bool checkDefaultCRLF = true;
741  			bool checkPlainTextCRLF = false;
742  			bool checkWithColorCRLF = false;
743  			if (svp._eolMode == svp.plainText)
744  			{
745  				checkDefaultCRLF = false;
746  				checkPlainTextCRLF = true;
747  				checkWithColorCRLF = false;
748  			}
749  			else if (svp._eolMode == svp.plainTextCustomColor)
750  			{
751  				checkDefaultCRLF = false;
752  				checkPlainTextCRLF = true;
753  				checkWithColorCRLF = true;
754  			}
755  			else if (svp._eolMode == svp.roundedRectangleTextCustomColor)
756  			{
757  				checkDefaultCRLF = true;
758  				checkPlainTextCRLF = false;
759  				checkWithColorCRLF = true;
760  			}
761  			::SendDlgItemMessage(_hSelf, IDC_RADIO_ROUNDCORNER_CRLF, BM_SETCHECK, checkDefaultCRLF, 0);
762  			::SendDlgItemMessage(_hSelf, IDC_RADIO_PLEINTEXT_CRLF, BM_SETCHECK, checkPlainTextCRLF, 0);
763  			::SendDlgItemMessage(_hSelf, IDC_CHECK_WITHCUSTOMCOLOR_CRLF, BM_SETCHECK, checkWithColorCRLF, 0);
764  			NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
765  			generic_string tip2show = pNativeSpeaker->getLocalizedStrFromID("eol-custom-color-tip", TEXT("Go to Style Configurator to change the default EOL custom color (\"EOL custom color\")."));
766  			_tip = CreateToolTip(IDC_BUTTON_LAUNCHSTYLECONF_CRLF, _hSelf, _hInst, const_cast<PTSTR>(tip2show.c_str()), pNativeSpeaker->isRTL());
767  			const bool isNpcModeAbbrv = svp._npcMode == svp.abbreviation;
768  			setChecked(IDC_RADIO_NPC_ABBREVIATION, isNpcModeAbbrv);
769  			setChecked(IDC_RADIO_NPC_CODEPOINT, !isNpcModeAbbrv);
770  			setChecked(IDC_CHECK_NPC_COLOR, svp._npcCustomColor);
771  			setChecked(IDC_CHECK_NPC_INCLUDECCUNIEOL, svp._npcIncludeCcUniEol);
772  			generic_string tipNote2Show = pNativeSpeaker->getLocalizedStrFromID("npcNote-tip",
773  				L"Representation of selected \"non-ASCII\" whitespace and non-printing (control) characters.\n\n"\
774  				L"NOTE:\n"\
775  				L"Using representation will disable character effects on text.\n\n"\
776  				L"For the full list of selected whitespace and non-printing characters check User Manual.\n\n"\
777  				L"Click on this button to open website with User Manual.");
778  			generic_string tipAb2Show = pNativeSpeaker->getLocalizedStrFromID("npcAbbreviation-tip",
779  				L"Abbreviation : name\n"\
780  				L"NBSP : no-break space\n"\
781  				L"ZWSP : zero-width space\n"\
782  				L"ZWNBSP : zero-width no-break space\n\n"\
783  				L"For the full list check User Manual.\n"\
784  				L"Click on \"?\" button on right to open website with User Manual.");
785  			generic_string tipCp2Show = pNativeSpeaker->getLocalizedStrFromID("npcCodepoint-tip",
786  				L"Codepoint : name\n"\
787  				L"U+00A0 : no-break space\n"\
788  				L"U+200B : zero-width space\n"\
789  				L"U+FEFF : zero-width no-break space\n\n"\
790  				L"For the full list check User Manual.\n"\
791  				L"Click on \"?\" button on right to open website with User Manual.");
792  			generic_string tipNpcCol2show = pNativeSpeaker->getLocalizedStrFromID("npcCustomColor-tip",
793  				L"Go to Style Configurator to change the default custom color for selected whitespace and non-printing characters (\"Non-printing characters custom color\").");
794  			generic_string tipNpcInc2show = pNativeSpeaker->getLocalizedStrFromID("npcIncludeCcUniEol-tip",
795  				L"Apply non-printing characters appearance settings to C0, C1 control and Unicode EOL (next line, line separator and paragraph separator) characters.");
796  			_tipNote = CreateToolTip(IDC_BUTTON_NPC_NOTE, _hSelf, _hInst, const_cast<PTSTR>(tipNote2Show.c_str()), pNativeSpeaker->isRTL());
797  			_tipAbb = CreateToolTip(IDC_RADIO_NPC_ABBREVIATION, _hSelf, _hInst, const_cast<PTSTR>(tipAb2Show.c_str()), pNativeSpeaker->isRTL());
798  			_tipCodepoint = CreateToolTip(IDC_RADIO_NPC_CODEPOINT, _hSelf, _hInst, const_cast<PTSTR>(tipCp2Show.c_str()), pNativeSpeaker->isRTL());
799  			_tipNpcColor = CreateToolTip(IDC_BUTTON_NPC_LAUNCHSTYLECONF, _hSelf, _hInst, const_cast<PTSTR>(tipNpcCol2show.c_str()), pNativeSpeaker->isRTL());
800  			_tipNpcInclude = CreateToolTip(IDC_CHECK_NPC_INCLUDECCUNIEOL, _hSelf, _hInst, const_cast<PTSTR>(tipNpcInc2show.c_str()), pNativeSpeaker->isRTL());
801  			_tips.push_back(_tipNote);
802  			_tips.push_back(_tipAbb);
803  			_tips.push_back(_tipCodepoint);
804  			_tips.push_back(_tipNpcColor);
805  			_tips.push_back(_tipNpcInclude);
806  			for (auto& tip : _tips)
807  			{
808  				if (tip != nullptr)
809  				{
810  					::SendMessage(tip, TTM_SETMAXTIPWIDTH, 0, 260);
811  				}
812  			}
813  			if (_tipNote != nullptr)
814  			{
815  				::SendMessage(_tipNote, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((30000), (0)));
816  			}
817  			initScintParam();
818  			return TRUE;
819  		}
820  		case WM_CTLCOLOREDIT:
821  		{
822  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
823  		}
824  		case WM_CTLCOLORLISTBOX:
825  		{
826  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
827  		}
828  		case WM_CTLCOLORDLG:
829  		{
830  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
831  		}
832  		case WM_CTLCOLORSTATIC:
833  		{
834  			int dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
835  			if (dlgCtrlID == IDC_CARETLINEFRAME_WIDTH_STATIC || dlgCtrlID == IDC_CARETLINEFRAME_WIDTH_DISPLAY)
836  			{
837  				return NppDarkMode::onCtlColorDarkerBGStaticText(reinterpret_cast<HDC>(wParam), (svp._currentLineHiliteMode == LINEHILITE_FRAME));
838  			}
839  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
840  		}
841  		case WM_PRINTCLIENT:
842  		{
843  			if (NppDarkMode::isEnabled())
844  			{
845  				return TRUE;
846  			}
847  			break;
848  		}
849  		case WM_HSCROLL:
850  		{
851  			HWND hCaretBlinkRateSlider = ::GetDlgItem(_hSelf, IDC_CARETBLINKRATE_SLIDER);
852  			HWND hCaretLineFrameSlider = ::GetDlgItem(_hSelf, IDC_CARETLINEFRAME_WIDTH_SLIDER);
853  			if (reinterpret_cast<HWND>(lParam) == hCaretBlinkRateSlider)
854  			{
855  				auto blinkRate = ::SendMessage(hCaretBlinkRateSlider, TBM_GETPOS, 0, 0);
856  				if (blinkRate == BLINKRATE_SLOWEST)
857  					blinkRate = 0;
858  				nppGUI._caretBlinkRate = static_cast<int>(blinkRate);
859  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETCARETBLINKRATE, 0, 0);
860  			}
861  			else if (reinterpret_cast<HWND>(lParam) == hCaretLineFrameSlider)
862  			{
863  				svp._currentLineFrameWidth = static_cast<unsigned char>(::SendMessage(hCaretLineFrameSlider, TBM_GETPOS, 0, 0));
864  				::SetDlgItemInt(_hSelf, IDC_CARETLINEFRAME_WIDTH_DISPLAY, svp._currentLineFrameWidth, FALSE);
865  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CARETLINEFRAME, 0, svp._currentLineFrameWidth);
866  			}
867  			return 0;	
868  		}
869  		case WM_COMMAND : 
870  		{
871  			ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
872  			switch (wParam)
873  			{
874  				case IDC_CHECK_SMOOTHFONT:
875  					svp._doSmoothFont = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_SMOOTHFONT, BM_GETCHECK, 0, 0));
876  					::SendMessage(::GetParent(_hParent), NPPM_SETSMOOTHFONT, 0, svp._doSmoothFont);
877  					return TRUE;
878  				case IDC_RADIO_CLM_NONE:
879  					svp._currentLineHiliteMode = LINEHILITE_NONE;
880  					changeLineHiliteMode(false);
881  					return TRUE;
882  				case IDC_RADIO_CLM_HILITE:
883  					svp._currentLineHiliteMode = LINEHILITE_HILITE;
884  					changeLineHiliteMode(false);
885  					return TRUE;
886  				case IDC_RADIO_CLM_FRAME:
887  					svp._currentLineHiliteMode = LINEHILITE_FRAME;
888  					changeLineHiliteMode(true);
889  					return TRUE;
890  				case IDC_RADIO_ROUNDCORNER_CRLF:
891  				case IDC_RADIO_PLEINTEXT_CRLF:
892  				case IDC_CHECK_WITHCUSTOMCOLOR_CRLF:
893  				{
894  					bool doCustomColor = isCheckedOrNot(IDC_CHECK_WITHCUSTOMCOLOR_CRLF);
895  					if (wParam == IDC_RADIO_ROUNDCORNER_CRLF)
896  					{
897  						svp._eolMode = doCustomColor ? svp.roundedRectangleTextCustomColor : svp.roundedRectangleText;
898  					}
899  					else if (wParam == IDC_RADIO_PLEINTEXT_CRLF)
900  					{
901  						svp._eolMode = doCustomColor ? svp.plainTextCustomColor : svp.plainText;
902  					}
903  					else 
904  					{
905  						if (isCheckedOrNot(IDC_RADIO_ROUNDCORNER_CRLF))
906  						{
907  							svp._eolMode = doCustomColor ? svp.roundedRectangleTextCustomColor : svp.roundedRectangleText;
908  						}
909  						else 
910  						{
911  							svp._eolMode = doCustomColor ? svp.plainTextCustomColor : svp.plainText;
912  						}
913  					}
914  					HWND grandParent = ::GetParent(_hParent);
915  					::SendMessage(grandParent, NPPM_INTERNAL_CRLFFORMCHANGED, 0, 0);
916  					return TRUE;
917  				}
918  				case IDC_BUTTON_LAUNCHSTYLECONF_CRLF:
919  				{
920  					HWND grandParent = ::GetParent(_hParent);
921  					::SendMessage(grandParent, NPPM_INTERNAL_CRLFLAUNCHSTYLECONF, 0, 0);
922  					return TRUE;
923  				}
924  				case IDC_RADIO_NPC_ABBREVIATION:
925  				case IDC_RADIO_NPC_CODEPOINT:
926  				{
927  					if (wParam == IDC_RADIO_NPC_CODEPOINT)
928  					{
929  						svp._npcMode = svp.codepoint;
930  					}
931  					else 
932  					{
933  						svp._npcMode = svp.abbreviation;
934  					}
935  					HWND grandParent = ::GetParent(_hParent);
936  					::SendMessage(grandParent, NPPM_INTERNAL_SETNPC, 0, 0);
937  					return TRUE;
938  				}
939  				case IDC_BUTTON_NPC_NOTE:
940  				{
941  					::ShellExecute(NULL, L"open", L"https:&bsol;&bsol;npp-user-manual.org/docs/views/#show-symbol", NULL, NULL, SW_SHOWNORMAL);
942  					return TRUE;
943  				}
944  				case IDC_CHECK_NPC_COLOR:
945  				{
946  					svp._npcCustomColor = isCheckedOrNot(IDC_CHECK_NPC_COLOR);
947  					HWND grandParent = ::GetParent(_hParent);
948  					::SendMessage(grandParent, NPPM_INTERNAL_NPCFORMCHANGED, 0, 0);
949  					return TRUE;
950  				}
951  				case IDC_BUTTON_NPC_LAUNCHSTYLECONF:
952  				{
953  					HWND grandParent = ::GetParent(_hParent);
954  					::SendMessage(grandParent, NPPM_INTERNAL_NPCLAUNCHSTYLECONF, 0, 0);
955  					return TRUE;
956  				}
957  				case IDC_CHECK_NPC_INCLUDECCUNIEOL:
958  				{
959  					svp._npcIncludeCcUniEol = isCheckedOrNot(IDC_CHECK_NPC_INCLUDECCUNIEOL);
960  					const HWND grandParent = ::GetParent(_hParent);
961  					::SendMessage(grandParent, NPPM_INTERNAL_SETNPC, IDC_CHECK_NPC_INCLUDECCUNIEOL, 0);
962  					return TRUE;
963  				}
964  				case IDC_CHECK_VIRTUALSPACE:
965  					svp._virtualSpace = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_VIRTUALSPACE, BM_GETCHECK, 0, 0));
966  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_VIRTUALSPACE, 0, 0);
967  					return TRUE;
968  				case IDC_CHECK_SCROLLBEYONDLASTLINE:
969  					svp._scrollBeyondLastLine = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_SCROLLBEYONDLASTLINE, BM_GETCHECK, 0, 0));
970  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SCROLLBEYONDLASTLINE, 0, 0);
971  					return TRUE;
972  				case IDC_CHECK_RIGHTCLICKKEEPSSELECTION:
973  					svp._rightClickKeepsSelection = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_RIGHTCLICKKEEPSSELECTION, BM_GETCHECK, 0, 0));
974  					return TRUE;
975  				case IDC_CHECK_DISABLEADVANCEDSCROLL:
976  					svp._disableAdvancedScrolling = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_DISABLEADVANCEDSCROLL, BM_GETCHECK, 0, 0));
977  					return TRUE;
978                  case IDC_CHECK_MULTISELECTION :
979                      nppGUI._enableMultiSelection = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_MULTISELECTION, BM_GETCHECK, 0, 0));
980                      ::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETMULTISELCTION, 0, 0);
981                      return TRUE;
982  				case IDC_CHECK_FOLDINGTOGGLE:
983  					nppGUI._enableFoldCmdToggable = isCheckedOrNot(IDC_CHECK_FOLDINGTOGGLE);
984  					return TRUE;
985  				case IDC_RADIO_LWDEF:
986  					svp._lineWrapMethod = LINEWRAP_DEFAULT;
987  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWDEF, 0);
988  					return TRUE;
989  				case IDC_RADIO_LWALIGN:
990  					svp._lineWrapMethod = LINEWRAP_ALIGNED;
991  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWALIGN, 0);
992  					return TRUE;
993  				case IDC_RADIO_LWINDENT:
994  					svp._lineWrapMethod = LINEWRAP_INDENT;
995  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LWINDENT, 0);
996  					return TRUE;
997  				default :
998  					switch (HIWORD(wParam))
999  					{
1000  						case CBN_SELCHANGE : 
1001  						{
1002  							if (LOWORD(wParam) == IDC_WIDTH_COMBO)
1003  							{
1004  								nppGUI._caretWidth = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_WIDTH_COMBO, CB_GETCURSEL, 0, 0));
1005  								::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETCARETWIDTH, 0, 0);
1006  								return TRUE;
1007  							}
1008  						}
1009  						break;
1010  					}
1011  			}
1012  		}
1013  	}
1014  	return FALSE;
1015  }
1016  void DarkModeSubDlg::enableCustomizedColorCtrls(bool doEnable)
1017  {
1018  	::EnableWindow(_pBackgroundColorPicker->getHSelf(), doEnable);
1019  	::EnableWindow(_pSofterBackgroundColorPicker->getHSelf(), doEnable);
1020  	::EnableWindow(_pHotBackgroundColorPicker->getHSelf(), doEnable);
1021  	::EnableWindow(_pPureBackgroundColorPicker->getHSelf(), doEnable);
1022  	::EnableWindow(_pErrorBackgroundColorPicker->getHSelf(), doEnable);
1023  	::EnableWindow(_pTextColorPicker->getHSelf(), doEnable);
1024  	::EnableWindow(_pDarkerTextColorPicker->getHSelf(), doEnable);
1025  	::EnableWindow(_pDisabledTextColorPicker->getHSelf(), doEnable);
1026  	::EnableWindow(_pEdgeColorPicker->getHSelf(), doEnable);
1027  	::EnableWindow(_pLinkColorPicker->getHSelf(), doEnable);
1028  	::EnableWindow(_pHotEdgeColorPicker->getHSelf(), doEnable);
1029  	::EnableWindow(_pDisabledEdgeColorPicker->getHSelf(), doEnable);
1030  	::EnableWindow(::GetDlgItem(_hSelf, IDD_CUSTOMIZED_RESET_BUTTON), doEnable);
1031  	if (doEnable)
1032  	{
1033  		_pBackgroundColorPicker->setColour(NppDarkMode::getBackgroundColor());
1034  		_pSofterBackgroundColorPicker->setColour(NppDarkMode::getSofterBackgroundColor());
1035  		_pHotBackgroundColorPicker->setColour(NppDarkMode::getHotBackgroundColor());
1036  		_pPureBackgroundColorPicker->setColour(NppDarkMode::getDarkerBackgroundColor());
1037  		_pErrorBackgroundColorPicker->setColour(NppDarkMode::getErrorBackgroundColor());
1038  		_pTextColorPicker->setColour(NppDarkMode::getTextColor());
1039  		_pDarkerTextColorPicker->setColour(NppDarkMode::getDarkerTextColor());
1040  		_pDisabledTextColorPicker->setColour(NppDarkMode::getDisabledTextColor());
1041  		_pEdgeColorPicker->setColour(NppDarkMode::getEdgeColor());
1042  		_pLinkColorPicker->setColour(NppDarkMode::getLinkTextColor());
1043  		_pHotEdgeColorPicker->setColour(NppDarkMode::getHotEdgeColor());
1044  		_pDisabledEdgeColorPicker->setColour(NppDarkMode::getDisabledEdgeColor());
1045  	}
1046  }
1047  void DarkModeSubDlg::move2CtrlLeft(int ctrlID, HWND handle2Move, int handle2MoveWidth, int handle2MoveHeight)
1048  {
1049  	POINT p{};
1050  	RECT rc{};
1051  	::GetWindowRect(::GetDlgItem(_hSelf, ctrlID), &rc);
1052  	NppParameters& nppParam = NppParameters::getInstance();
1053  	if(nppParam.getNativeLangSpeaker()->isRTL())
1054  		p.x = rc.right + nppParam._dpiManager.scaleX(5) + handle2MoveWidth;
1055  	else
1056  		p.x = rc.left - nppParam._dpiManager.scaleX(5) - handle2MoveWidth;
1057  	p.y = rc.top + ((rc.bottom - rc.top) / 2) - handle2MoveHeight / 2;
1058  	::ScreenToClient(_hSelf, &p);
1059  	::MoveWindow(handle2Move, p.x, p.y, handle2MoveWidth, handle2MoveHeight, TRUE);
1060  }
1061  intptr_t CALLBACK DarkModeSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
1062  {
1063  	UNREFERENCED_PARAMETER(lParam);
1064  	NppParameters& nppParam = NppParameters::getInstance();
1065  	NppGUI& nppGUI = nppParam.getNppGUI();
1066  	switch (message)
1067  	{
1068  		case WM_INITDIALOG:
1069  		{
1070  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_FOLLOWWINDOWS), NppDarkMode::isWindows10());
1071  			const int topControlID = NppDarkMode::isWindowsModeEnabled() && NppDarkMode::isWindows10() ? IDC_RADIO_DARKMODE_FOLLOWWINDOWS : NppDarkMode::isEnabled() ? IDC_RADIO_DARKMODE_DARKMODE : IDC_RADIO_DARKMODE_LIGHTMODE;
1072  			::SendDlgItemMessage(_hSelf, topControlID, BM_SETCHECK, BST_CHECKED, 0);
1073  			int id = IDC_RADIO_DARKMODE_BLACK;
1074  			switch (nppGUI._darkmode._colorTone)
1075  			{
1076  				case NppDarkMode::redTone:
1077  					id = IDC_RADIO_DARKMODE_RED;
1078  					break;
1079  				case NppDarkMode::greenTone:
1080  					id = IDC_RADIO_DARKMODE_GREEN;
1081  					break;
1082  				case NppDarkMode::blueTone:
1083  					id = IDC_RADIO_DARKMODE_BLUE;
1084  					break;
1085  				case NppDarkMode::purpleTone:
1086  					id = IDC_RADIO_DARKMODE_PURPLE;
1087  					break;
1088  				case NppDarkMode::cyanTone:
1089  					id = IDC_RADIO_DARKMODE_CYAN;
1090  					break;
1091  				case NppDarkMode::oliveTone:
1092  					id = IDC_RADIO_DARKMODE_OLIVE;
1093  					break;
1094  				case NppDarkMode::customizedTone:
1095  					id = IDC_RADIO_DARKMODE_CUSTOMIZED;
1096  					break;
1097  				case NppDarkMode::blackTone:
1098  				default:
1099  					break;
1100  			}
1101  			::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
1102  			_pBackgroundColorPicker = new ColourPicker;
1103  			_pSofterBackgroundColorPicker = new ColourPicker;
1104  			_pHotBackgroundColorPicker = new ColourPicker;
1105  			_pPureBackgroundColorPicker = new ColourPicker;
1106  			_pErrorBackgroundColorPicker = new ColourPicker;
1107  			_pTextColorPicker = new ColourPicker;
1108  			_pDarkerTextColorPicker = new ColourPicker;
1109  			_pDisabledTextColorPicker = new ColourPicker;
1110  			_pEdgeColorPicker = new ColourPicker;
1111  			_pLinkColorPicker = new ColourPicker;
1112  			_pHotEdgeColorPicker = new ColourPicker;
1113  			_pDisabledEdgeColorPicker = new ColourPicker;
1114  			_pBackgroundColorPicker->init(_hInst, _hSelf);
1115  			_pSofterBackgroundColorPicker->init(_hInst, _hSelf);
1116  			_pHotBackgroundColorPicker->init(_hInst, _hSelf);
1117  			_pPureBackgroundColorPicker->init(_hInst, _hSelf);
1118  			_pErrorBackgroundColorPicker->init(_hInst, _hSelf);
1119  			_pTextColorPicker->init(_hInst, _hSelf);
1120  			_pDarkerTextColorPicker->init(_hInst, _hSelf);
1121  			_pDisabledTextColorPicker->init(_hInst, _hSelf);
1122  			_pEdgeColorPicker->init(_hInst, _hSelf);
1123  			_pLinkColorPicker->init(_hInst, _hSelf);
1124  			_pHotEdgeColorPicker->init(_hInst, _hSelf);
1125  			_pDisabledEdgeColorPicker->init(_hInst, _hSelf);
1126  			int cpDynamicalWidth = NppParameters::getInstance()._dpiManager.scaleX(25);
1127  			int cpDynamicalHeight = NppParameters::getInstance()._dpiManager.scaleY(25);
1128  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR1_STATIC, _pPureBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1129  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR2_STATIC, _pHotBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1130  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR3_STATIC, _pSofterBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1131  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR4_STATIC, _pBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1132  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR5_STATIC, _pErrorBackgroundColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1133  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR6_STATIC, _pTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1134  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR7_STATIC, _pDarkerTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1135  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR8_STATIC, _pDisabledTextColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1136  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR9_STATIC, _pEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1137  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR10_STATIC, _pLinkColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1138  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR11_STATIC, _pHotEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1139  			move2CtrlLeft(IDD_CUSTOMIZED_COLOR12_STATIC, _pDisabledEdgeColorPicker->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
1140  			_pBackgroundColorPicker->display();
1141  			_pSofterBackgroundColorPicker->display();
1142  			_pHotBackgroundColorPicker->display();
1143  			_pPureBackgroundColorPicker->display();
1144  			_pErrorBackgroundColorPicker->display();
1145  			_pTextColorPicker->display();
1146  			_pDarkerTextColorPicker->display();
1147  			_pDisabledTextColorPicker->display();
1148  			_pEdgeColorPicker->display();
1149  			_pLinkColorPicker->display();
1150  			_pHotEdgeColorPicker->display();
1151  			_pDisabledEdgeColorPicker->display();
1152  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLACK), nppGUI._darkmode._isEnabled);
1153  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_RED), nppGUI._darkmode._isEnabled);
1154  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_GREEN), nppGUI._darkmode._isEnabled);
1155  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLUE), nppGUI._darkmode._isEnabled);
1156  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_PURPLE), nppGUI._darkmode._isEnabled);
1157  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CYAN), nppGUI._darkmode._isEnabled);
1158  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_OLIVE), nppGUI._darkmode._isEnabled);
1159  			::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CUSTOMIZED), nppGUI._darkmode._isEnabled);
1160  			enableCustomizedColorCtrls(nppGUI._darkmode._isEnabled && id == IDC_RADIO_DARKMODE_CUSTOMIZED);
1161  			return TRUE;
1162  		}
1163  		case WM_CTLCOLORDLG:
1164  		{
1165  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1166  		}
1167  		case WM_CTLCOLORSTATIC:
1168  		{
1169  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
1170  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
1171  			bool isStaticText = (dlgCtrlID == IDD_CUSTOMIZED_COLOR1_STATIC ||
1172  				dlgCtrlID == IDD_CUSTOMIZED_COLOR2_STATIC ||
1173  				dlgCtrlID == IDD_CUSTOMIZED_COLOR3_STATIC ||
1174  				dlgCtrlID == IDD_CUSTOMIZED_COLOR4_STATIC ||
1175  				dlgCtrlID == IDD_CUSTOMIZED_COLOR5_STATIC ||
1176  				dlgCtrlID == IDD_CUSTOMIZED_COLOR6_STATIC ||
1177  				dlgCtrlID == IDD_CUSTOMIZED_COLOR7_STATIC ||
1178  				dlgCtrlID == IDD_CUSTOMIZED_COLOR8_STATIC ||
1179  				dlgCtrlID == IDD_CUSTOMIZED_COLOR9_STATIC ||
1180  				dlgCtrlID == IDD_CUSTOMIZED_COLOR10_STATIC ||
1181  				dlgCtrlID == IDD_CUSTOMIZED_COLOR11_STATIC ||
1182  				dlgCtrlID == IDD_CUSTOMIZED_COLOR12_STATIC);
1183  			if (isStaticText)
1184  			{
1185  				bool isTextEnabled = nppGUI._darkmode._isEnabled && nppGUI._darkmode._colorTone == NppDarkMode::customizedTone;
1186  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
1187  			}
1188  			return NppDarkMode::onCtlColorDarker(hdcStatic);
1189  		}
1190  		case WM_PRINTCLIENT:
1191  		{
1192  			if (NppDarkMode::isEnabled())
1193  			{
1194  				return TRUE;
1195  			}
1196  			break;
1197  		}
1198  		case WM_DESTROY:
1199  		{
1200  			_pBackgroundColorPicker->destroy();
1201  			_pSofterBackgroundColorPicker->destroy();
1202  			_pHotBackgroundColorPicker->destroy();
1203  			_pPureBackgroundColorPicker->destroy();
1204  			_pErrorBackgroundColorPicker->destroy();
1205  			_pTextColorPicker->destroy();
1206  			_pDarkerTextColorPicker->destroy();
1207  			_pDisabledTextColorPicker->destroy();
1208  			_pEdgeColorPicker->destroy();
1209  			_pLinkColorPicker->destroy();
1210  			_pHotEdgeColorPicker->destroy();
1211  			_pDisabledEdgeColorPicker->destroy();
1212  			delete _pBackgroundColorPicker;
1213  			delete _pSofterBackgroundColorPicker;
1214  			delete _pHotBackgroundColorPicker;
1215  			delete _pPureBackgroundColorPicker;
1216  			delete _pErrorBackgroundColorPicker;
1217  			delete _pTextColorPicker;
1218  			delete _pDarkerTextColorPicker;
1219  			delete _pDisabledTextColorPicker;
1220  			delete _pEdgeColorPicker;
1221  			delete _pLinkColorPicker;
1222  			delete _pHotEdgeColorPicker;
1223  			delete _pDisabledEdgeColorPicker;
1224  			return TRUE;
1225  		}
1226  		case WM_COMMAND:
1227  		{
1228  			bool changed = false;
1229  			bool forceRefresh = false;
1230  			bool doEnableCustomizedColorCtrls = false;
1231  			switch (wParam)
1232  			{
1233  				case IDC_RADIO_DARKMODE_FOLLOWWINDOWS:
1234  				{
1235  					NppDarkMode::handleSettingChange(nullptr, 0, true);
1236  				}
1237  				[[fallthrough]];
1238  				case IDC_RADIO_DARKMODE_LIGHTMODE:
1239  				case IDC_RADIO_DARKMODE_DARKMODE:
1240  				{
1241  					const bool isFollowWindows = isCheckedOrNot(IDC_RADIO_DARKMODE_FOLLOWWINDOWS);
1242  					NppDarkMode::setWindowsMode(isFollowWindows);
1243  					const bool enableDarkMode = isCheckedOrNot(IDC_RADIO_DARKMODE_DARKMODE) || (isFollowWindows && NppDarkMode::isExperimentalActive());
1244  					nppGUI._darkmode._isEnabled = enableDarkMode;
1245  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLACK), enableDarkMode);
1246  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_RED), enableDarkMode);
1247  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_GREEN), enableDarkMode);
1248  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_BLUE), enableDarkMode);
1249  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_PURPLE), enableDarkMode);
1250  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CYAN), enableDarkMode);
1251  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_OLIVE), enableDarkMode);
1252  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DARKMODE_CUSTOMIZED), enableDarkMode);
1253  					doEnableCustomizedColorCtrls = enableDarkMode && nppGUI._darkmode._colorTone == NppDarkMode::customizedTone;
1254  					enableCustomizedColorCtrls(doEnableCustomizedColorCtrls);
1255  					::SendMessage(_hParent, PREF_MSG_SETGUITOOLICONSSET, static_cast<WPARAM>(enableDarkMode), 0);
1256  					::SendMessage(_hParent, PREF_MSG_SETGUITABBARICONS, static_cast<WPARAM>(enableDarkMode), 0);
1257  					changed = true;
1258  				}
1259  				break;
1260  				case IDC_RADIO_DARKMODE_BLACK:
1261  				case IDC_RADIO_DARKMODE_RED:
1262  				case IDC_RADIO_DARKMODE_GREEN:
1263  				case IDC_RADIO_DARKMODE_BLUE:
1264  				case IDC_RADIO_DARKMODE_PURPLE:
1265  				case IDC_RADIO_DARKMODE_CYAN:
1266  				case IDC_RADIO_DARKMODE_OLIVE:
1267  				case IDC_RADIO_DARKMODE_CUSTOMIZED:
1268  				case IDD_CUSTOMIZED_RESET_BUTTON:
1269  				{
1270  					if (wParam == IDC_RADIO_DARKMODE_BLACK)
1271  					{
1272  						if (nppGUI._darkmode._colorTone == NppDarkMode::blackTone)
1273  							return TRUE;
1274  						nppGUI._darkmode._colorTone = NppDarkMode::blackTone;
1275  					}
1276  					else if (wParam == IDC_RADIO_DARKMODE_RED)
1277  					{
1278  						if (nppGUI._darkmode._colorTone == NppDarkMode::redTone)
1279  							return TRUE;
1280  						nppGUI._darkmode._colorTone = NppDarkMode::redTone;
1281  					}
1282  					else if (wParam == IDC_RADIO_DARKMODE_GREEN)
1283  					{
1284  						if (nppGUI._darkmode._colorTone == NppDarkMode::greenTone)
1285  							return TRUE;
1286  						nppGUI._darkmode._colorTone = NppDarkMode::greenTone;
1287  					}
1288  					else if (wParam == IDC_RADIO_DARKMODE_BLUE)
1289  					{
1290  						if (nppGUI._darkmode._colorTone == NppDarkMode::blueTone)
1291  							return TRUE;
1292  						nppGUI._darkmode._colorTone = NppDarkMode::blueTone;
1293  					}
1294  					else if (wParam == IDC_RADIO_DARKMODE_PURPLE)
1295  					{
1296  						if (nppGUI._darkmode._colorTone == NppDarkMode::purpleTone)
1297  							return TRUE;
1298  						nppGUI._darkmode._colorTone = NppDarkMode::purpleTone;
1299  					}
1300  					else if (wParam == IDC_RADIO_DARKMODE_CYAN)
1301  					{
1302  						if (nppGUI._darkmode._colorTone == NppDarkMode::cyanTone)
1303  							return TRUE;
1304  						nppGUI._darkmode._colorTone = NppDarkMode::cyanTone;
1305  					}
1306  					else if (wParam == IDC_RADIO_DARKMODE_OLIVE)
1307  					{
1308  						if (nppGUI._darkmode._colorTone == NppDarkMode::oliveTone)
1309  							return TRUE;
1310  						nppGUI._darkmode._colorTone = NppDarkMode::oliveTone;
1311  					}
1312  					else if (wParam == IDC_RADIO_DARKMODE_CUSTOMIZED)
1313  					{
1314  						if (nppGUI._darkmode._colorTone == NppDarkMode::customizedTone)
1315  							return TRUE;
1316  						nppGUI._darkmode._colorTone = NppDarkMode::customizedTone;
1317  						doEnableCustomizedColorCtrls = true;
1318  					}
1319  					else if (wParam == IDD_CUSTOMIZED_RESET_BUTTON)
1320  					{
1321  						nppGUI._darkmode._customColors = NppDarkMode::getDarkModeDefaultColors();
1322  						NppDarkMode::changeCustomTheme(nppGUI._darkmode._customColors);
1323  						doEnableCustomizedColorCtrls = true;
1324  					}
1325  					nppGUI._darkmode._isEnabled = true;
1326  					NppDarkMode::setDarkTone(nppGUI._darkmode._colorTone);
1327  					changed = true;
1328  					forceRefresh = true;
1329  					enableCustomizedColorCtrls(doEnableCustomizedColorCtrls);
1330  				}
1331  				break;
1332  				default:
1333  					switch (HIWORD(wParam))
1334  					{
1335  						case CPN_COLOURPICKED:
1336  						{
1337  							COLORREF c = 0;
1338  							if (reinterpret_cast<HWND>(lParam) == _pBackgroundColorPicker->getHSelf())
1339  							{
1340  								c = _pBackgroundColorPicker->getColour();
1341  								NppDarkMode::setBackgroundColor(c);
1342  								nppGUI._darkmode._customColors.background = c;
1343  							}
1344  							else if (reinterpret_cast<HWND>(lParam) == _pSofterBackgroundColorPicker->getHSelf())
1345  							{
1346  								c = _pSofterBackgroundColorPicker->getColour();
1347  								NppDarkMode::setSofterBackgroundColor(c);
1348  								nppGUI._darkmode._customColors.softerBackground = c;
1349  							}
1350  							else if (reinterpret_cast<HWND>(lParam) == _pHotBackgroundColorPicker->getHSelf())
1351  							{
1352  								c = _pHotBackgroundColorPicker->getColour();
1353  								NppDarkMode::setHotBackgroundColor(c);
1354  								nppGUI._darkmode._customColors.hotBackground = c;
1355  							}
1356  							else if (reinterpret_cast<HWND>(lParam) == _pPureBackgroundColorPicker->getHSelf())
1357  							{
1358  								c = _pPureBackgroundColorPicker->getColour();
1359  								NppDarkMode::setDarkerBackgroundColor(c);
1360  								nppGUI._darkmode._customColors.pureBackground = c;
1361  							}
1362  							else if (reinterpret_cast<HWND>(lParam) == _pErrorBackgroundColorPicker->getHSelf())
1363  							{
1364  								c = _pErrorBackgroundColorPicker->getColour();
1365  								NppDarkMode::setErrorBackgroundColor(c);
1366  								nppGUI._darkmode._customColors.errorBackground = c;
1367  							}
1368  							else if (reinterpret_cast<HWND>(lParam) == _pTextColorPicker->getHSelf())
1369  							{
1370  								c = _pTextColorPicker->getColour();
1371  								NppDarkMode::setTextColor(c);
1372  								nppGUI._darkmode._customColors.text = c;
1373  							}
1374  							else if (reinterpret_cast<HWND>(lParam) == _pDarkerTextColorPicker->getHSelf())
1375  							{
1376  								c = _pDarkerTextColorPicker->getColour();
1377  								NppDarkMode::setDarkerTextColor(c);
1378  								nppGUI._darkmode._customColors.darkerText = c;
1379  							}
1380  							else if (reinterpret_cast<HWND>(lParam) == _pDisabledTextColorPicker->getHSelf())
1381  							{
1382  								c = _pDisabledTextColorPicker->getColour();
1383  								NppDarkMode::setDisabledTextColor(c);
1384  								nppGUI._darkmode._customColors.disabledText = c;
1385  							}
1386  							else if (reinterpret_cast<HWND>(lParam) == _pEdgeColorPicker->getHSelf())
1387  							{
1388  								c = _pEdgeColorPicker->getColour();
1389  								NppDarkMode::setEdgeColor(c);
1390  								nppGUI._darkmode._customColors.edge = c;
1391  							}
1392  							else if (reinterpret_cast<HWND>(lParam) == _pLinkColorPicker->getHSelf())
1393  							{
1394  								c = _pLinkColorPicker->getColour();
1395  								NppDarkMode::setLinkTextColor(c);
1396  								nppGUI._darkmode._customColors.linkText = c;
1397  							}
1398  							else if (reinterpret_cast<HWND>(lParam) == _pHotEdgeColorPicker->getHSelf())
1399  							{
1400  								c = _pHotEdgeColorPicker->getColour();
1401  								NppDarkMode::setHotEdgeColor(c);
1402  								nppGUI._darkmode._customColors.hotEdge = c;
1403  							}
1404  							else if (reinterpret_cast<HWND>(lParam) == _pDisabledEdgeColorPicker->getHSelf())
1405  							{
1406  								c = _pDisabledEdgeColorPicker->getColour();
1407  								NppDarkMode::setDisabledEdgeColor(c);
1408  								nppGUI._darkmode._customColors.disabledEdge = c;
1409  							}
1410  							else
1411  							{
1412  								return FALSE;
1413  							}
1414  							nppGUI._darkmode._isEnabled = true;
1415  							NppDarkMode::setDarkTone(nppGUI._darkmode._colorTone);
1416  							changed = true;
1417  							forceRefresh = true;
1418  							doEnableCustomizedColorCtrls = true;
1419  						}
1420  						break;
1421  						default:
1422  						{
1423  							return FALSE;
1424  						}
1425  					}
1426  			}
1427  			if (changed)
1428  			{
1429  				if (!doEnableCustomizedColorCtrls)
1430  				{
1431  					COLORREF disabledColor = nppGUI._darkmode._isEnabled ? NppDarkMode::getDarkerBackgroundColor() : ::GetSysColor(COLOR_3DFACE);
1432  					_pBackgroundColorPicker->setColour(disabledColor);
1433  					_pSofterBackgroundColorPicker->setColour(disabledColor);
1434  					_pHotBackgroundColorPicker->setColour(disabledColor);
1435  					_pPureBackgroundColorPicker->setColour(disabledColor);
1436  					_pErrorBackgroundColorPicker->setColour(disabledColor);
1437  					_pTextColorPicker->setColour(disabledColor);
1438  					_pDarkerTextColorPicker->setColour(disabledColor);
1439  					_pDisabledTextColorPicker->setColour(disabledColor);
1440  					_pEdgeColorPicker->setColour(disabledColor);
1441  					_pLinkColorPicker->setColour(disabledColor);
1442  					_pHotEdgeColorPicker->setColour(disabledColor);
1443  					_pDisabledEdgeColorPicker->setColour(disabledColor);
1444  				}
1445  				NppDarkMode::refreshDarkMode(_hSelf, forceRefresh);
1446  				getFocus(); 
1447  				return TRUE;
1448  			}
1449  			return FALSE;
1450  		}
1451  	}
1452  	return FALSE;
1453  }
1454  void MarginsBorderEdgeSubDlg::initScintParam()
1455  {
1456  	NppParameters& nppParam = NppParameters::getInstance();
1457  	ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
1458  	::SendDlgItemMessage(_hSelf, IDC_RADIO_BOX, BM_SETCHECK, FALSE, 0);
1459  	::SendDlgItemMessage(_hSelf, IDC_RADIO_CIRCLE, BM_SETCHECK, FALSE, 0);
1460  	::SendDlgItemMessage(_hSelf, IDC_RADIO_ARROW, BM_SETCHECK, FALSE, 0);
1461  	::SendDlgItemMessage(_hSelf, IDC_RADIO_SIMPLE, BM_SETCHECK, FALSE, 0);
1462  	::SendDlgItemMessage(_hSelf, IDC_RADIO_FOLDMARGENONE, BM_SETCHECK, FALSE, 0);
1463  	int id = 0;
1464  	switch (svp._folderStyle)
1465  	{
1466  		case FOLDER_STYLE_NONE:
1467  			id = IDC_RADIO_FOLDMARGENONE;
1468  			break;
1469  		case FOLDER_STYLE_BOX:
1470  			id = IDC_RADIO_BOX;
1471  			break;
1472  		case FOLDER_STYLE_CIRCLE:
1473  			id = IDC_RADIO_CIRCLE;
1474  			break;
1475  		case FOLDER_STYLE_ARROW:
1476  			id = IDC_RADIO_ARROW;
1477  			break;
1478  		default : 
1479  			id = IDC_RADIO_SIMPLE;
1480  	}
1481  	::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, TRUE, 0);
1482  	::SendDlgItemMessage(_hSelf, IDC_CHECK_LINENUMBERMARGE, BM_SETCHECK, svp._lineNumberMarginShow, 0);
1483  	::SendDlgItemMessage(_hSelf, IDC_RADIO_DYNAMIC, BM_SETCHECK, svp._lineNumberMarginDynamicWidth, 0);
1484  	::SendDlgItemMessage(_hSelf, IDC_RADIO_CONSTANT, BM_SETCHECK, !svp._lineNumberMarginDynamicWidth, 0);
1485  	::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DYNAMIC), svp._lineNumberMarginShow);
1486  	::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_CONSTANT), svp._lineNumberMarginShow);
1487  	::SendDlgItemMessage(_hSelf, IDC_CHECK_BOOKMARKMARGE, BM_SETCHECK, svp._bookMarkMarginShow, 0);
1488  	::SendDlgItemMessage(_hSelf, IDC_CHECK_CHANGHISTORYMARGE, BM_SETCHECK, svp._isChangeHistoryEnabled, 0);
1489  	::SendDlgItemMessage(_hSelf, IDC_CHECK_NOEDGE, BM_SETCHECK, !svp._showBorderEdge, 0);
1490  	bool canBeBg = svp._edgeMultiColumnPos.size() == 1;
1491  	if (!canBeBg)
1492  	{
1493  		svp._isEdgeBgMode = false;
1494  		::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, FALSE, 0);
1495  		::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_EDGEBGMODE), FALSE);
1496  	}
1497  	else
1498  	{
1499  		::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, svp._isEdgeBgMode, 0);
1500  	}
1501  	generic_string edgeColumnPosStr;
1502  	for (auto i : svp._edgeMultiColumnPos)
1503  	{
1504  		std::string s = std::to_string(i);
1505  		edgeColumnPosStr += generic_string(s.begin(), s.end());
1506  		edgeColumnPosStr += TEXT(" ");
1507  	}
1508  	::SendDlgItemMessage(_hSelf, IDC_COLUMNPOS_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(edgeColumnPosStr.c_str()));
1509  	oldFunclstToolbarProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(::GetDlgItem(_hSelf, IDC_COLUMNPOS_EDIT), GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(editNumSpaceProc)));
1510  }
1511  intptr_t CALLBACK MarginsBorderEdgeSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
1512  {
1513  	NppParameters& nppParam = NppParameters::getInstance();
1514  	switch (message) 
1515  	{
1516  		case WM_INITDIALOG :
1517  		{
1518  			const ScintillaViewParams & svp = nppParam.getSVP();
1519  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETRANGEMIN, TRUE, BORDERWIDTH_SMALLEST);
1520  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETRANGEMAX, TRUE, BORDERWIDTH_LARGEST);
1521  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETPAGESIZE, 0, BORDERWIDTH_INTERVAL);
1522  			::SendMessage(::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER),TBM_SETPOS, TRUE, svp._borderWidth);
1523  			::SetDlgItemInt(_hSelf, IDC_BORDERWIDTHVAL_STATIC, svp._borderWidth, FALSE);
1524  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETRANGEMIN, TRUE, PADDING_SMALLEST);
1525  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETRANGEMAX, TRUE, PADDING_LARGEST);
1526  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETPAGESIZE, 0, PADDING_INTERVAL);
1527  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER), TBM_SETPOS, TRUE, svp._paddingLeft);
1528  			::SetDlgItemInt(_hSelf, IDC_PADDINGLEFTVAL_STATIC, svp._paddingLeft, FALSE);
1529  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETRANGEMIN, TRUE, PADDING_SMALLEST);
1530  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETRANGEMAX, TRUE, PADDING_LARGEST);
1531  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETPAGESIZE, 0, PADDING_INTERVAL);
1532  			::SendMessage(::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER), TBM_SETPOS, TRUE, svp._paddingRight);
1533  			::SetDlgItemInt(_hSelf, IDC_PADDINGRIGHTVAL_STATIC, svp._paddingRight, FALSE);
1534  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETRANGEMIN, TRUE, DISTRACTIONFREE_SMALLEST);
1535  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETRANGEMAX, TRUE, DISTRACTIONFREE_LARGEST);
1536  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETPAGESIZE, 0, DISTRACTIONFREE_INTERVAL);
1537  			::SendMessage(::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER), TBM_SETPOS, TRUE, svp._distractionFreeDivPart);
1538  			::SetDlgItemInt(_hSelf, IDC_DISTRACTIONFREEVAL_STATIC, svp._distractionFreeDivPart, FALSE);
1539  			initScintParam();
1540  			return TRUE;
1541  		}
1542  		case WM_CTLCOLOREDIT:
1543  		{
1544  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1545  		}
1546  		case WM_CTLCOLORDLG:
1547  		case WM_CTLCOLORSTATIC:
1548  		{
1549  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1550  		}
1551  		case WM_PRINTCLIENT:
1552  		{
1553  			if (NppDarkMode::isEnabled())
1554  			{
1555  				return TRUE;
1556  			}
1557  			break;
1558  		}
1559  		case WM_HSCROLL:
1560  		{
1561  			ScintillaViewParams & svp = (ScintillaViewParams &)nppParam.getSVP();
1562  			HWND hBorderWidthSlider = ::GetDlgItem(_hSelf, IDC_BORDERWIDTH_SLIDER);
1563  			HWND hPaddingLeftSlider = ::GetDlgItem(_hSelf, IDC_PADDINGLEFT_SLIDER);
1564  			HWND hPaddingRightSlider = ::GetDlgItem(_hSelf, IDC_PADDINGRIGHT_SLIDER);
1565  			HWND hDistractionFreeSlider = ::GetDlgItem(_hSelf, IDC_DISTRACTIONFREE_SLIDER);
1566  			if (reinterpret_cast<HWND>(lParam) == hBorderWidthSlider)
1567  			{
1568  				auto borderWidth = ::SendMessage(hBorderWidthSlider, TBM_GETPOS, 0, 0);
1569  				svp._borderWidth = static_cast<int>(borderWidth);
1570  				::SetDlgItemInt(_hSelf, IDC_BORDERWIDTHVAL_STATIC, static_cast<UINT>(borderWidth), FALSE);
1571  				::SendMessage(::GetParent(_hParent), WM_SIZE, 0, 0);
1572  			}
1573  			else if (reinterpret_cast<HWND>(lParam) == hPaddingLeftSlider)
1574  			{
1575  				svp._paddingLeft = static_cast<unsigned char>(::SendMessage(hPaddingLeftSlider, TBM_GETPOS, 0, 0));
1576  				::SetDlgItemInt(_hSelf, IDC_PADDINGLEFTVAL_STATIC, static_cast<UINT>(svp._paddingLeft), FALSE);
1577  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1578  			}
1579  			else if (reinterpret_cast<HWND>(lParam) == hPaddingRightSlider)
1580  			{
1581  				svp._paddingRight = static_cast<unsigned char>(::SendMessage(hPaddingRightSlider, TBM_GETPOS, 0, 0));
1582  				::SetDlgItemInt(_hSelf, IDC_PADDINGRIGHTVAL_STATIC, static_cast<UINT>(svp._paddingRight), FALSE);
1583  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1584  			}
1585  			else if (reinterpret_cast<HWND>(lParam) == hDistractionFreeSlider)
1586  			{
1587  				svp._distractionFreeDivPart = static_cast<unsigned char>(::SendMessage(hDistractionFreeSlider, TBM_GETPOS, 0, 0));
1588  				::SetDlgItemInt(_hSelf, IDC_DISTRACTIONFREEVAL_STATIC, static_cast<UINT>(svp._distractionFreeDivPart), FALSE);
1589  				::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATETEXTZONEPADDING, 0, 0);
1590  			}
1591  			return 0;	
1592  		}
1593  		case WM_COMMAND : 
1594  		{
1595  			ScintillaViewParams & svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
1596  			switch (wParam)
1597  			{
1598  				case IDC_CHECK_LINENUMBERMARGE:
1599  					svp._lineNumberMarginShow = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_LINENUMBERMARGE, BM_GETCHECK, 0, 0));
1600  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_DYNAMIC), svp._lineNumberMarginShow);
1601  					::EnableWindow(::GetDlgItem(_hSelf, IDC_RADIO_CONSTANT), svp._lineNumberMarginShow);
1602  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1603  					return TRUE;
1604  				case IDC_RADIO_DYNAMIC:
1605  					svp._lineNumberMarginDynamicWidth = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_DYNAMIC, BM_GETCHECK, 0, 0));
1606  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1607  					return TRUE;
1608  				case IDC_RADIO_CONSTANT:
1609  					svp._lineNumberMarginDynamicWidth = !(BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_CONSTANT, BM_GETCHECK, 0, 0));
1610  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
1611  					return TRUE;
1612  				case IDC_CHECK_BOOKMARKMARGE:
1613  					svp._bookMarkMarginShow = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_BOOKMARKMARGE, BM_GETCHECK, 0, 0));
1614  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_SYMBOLMARGIN, 0);
1615  					return TRUE;
1616  				case IDC_CHECK_CHANGHISTORYMARGE:
1617  				{
1618  					bool isChangeHistoryEnabled = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_CHANGHISTORYMARGE, BM_GETCHECK, 0, 0));
1619  					if (isChangeHistoryEnabled)
1620  					{
1621  						NativeLangSpeaker* pNativeSpeaker = nppParam.getNativeLangSpeaker();
1622  						pNativeSpeaker->messageBox("ChangeHistoryEnabledWarning",
1623  							_hSelf,
1624  							TEXT("You have to restart Notepad++ to enable Change History."),
1625  							TEXT("Notepad++ need to be relaunched"),
1626  							MB_OK | MB_APPLMODAL);
1627  						svp._isChangeHistoryEnabled4NextSession = true;
1628  					}
1629  					else
1630  					{
1631  						svp._isChangeHistoryEnabled = false;
1632  						svp._isChangeHistoryEnabled4NextSession = false;
1633  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_ENABLECHANGEHISTORY, 0, 0);
1634  					}
1635  					return TRUE;
1636  				}
1637  				case IDC_CHECK_NOEDGE:
1638  					svp._showBorderEdge = !(BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_NOEDGE, BM_GETCHECK, 0, 0));
1639  					::SendMessage(::GetParent(_hParent), NPPM_SETEDITORBORDEREDGE, 0, svp._showBorderEdge ? TRUE : FALSE);
1640  					return TRUE;
1641  				case IDC_RADIO_SIMPLE:
1642  					svp._folderStyle = FOLDER_STYLE_SIMPLE;
1643  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_SIMPLE, 0);
1644  					return TRUE;
1645  				case IDC_RADIO_ARROW:
1646  					svp._folderStyle = FOLDER_STYLE_ARROW;
1647  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_ARROW, 0);
1648  					return TRUE;
1649  				case IDC_RADIO_CIRCLE:
1650  					svp._folderStyle = FOLDER_STYLE_CIRCLE;
1651  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_CIRCLE, 0);
1652  					return TRUE;
1653  				case IDC_RADIO_BOX:
1654  					svp._folderStyle = FOLDER_STYLE_BOX;
1655  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN_BOX, 0);
1656  					return TRUE;
1657  				case IDC_RADIO_FOLDMARGENONE:
1658  					svp._folderStyle = FOLDER_STYLE_NONE;
1659  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FOLDERMAGIN, 0);
1660  					return TRUE;
1661  				case IDC_CHECK_EDGEBGMODE:
1662  					svp._isEdgeBgMode = isCheckedOrNot(IDC_CHECK_EDGEBGMODE);
1663  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
1664  					return TRUE;
1665  				default :
1666  					switch (HIWORD(wParam))
1667  					{
1668  						case EN_CHANGE :
1669  						{
1670  							if (LOWORD(wParam) == IDC_COLUMNPOS_EDIT)
1671  							{
1672  								TCHAR text[MAX_PATH] = {'\0'};
1673  								::SendDlgItemMessage(_hSelf, IDC_COLUMNPOS_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text));
1674  								if (str2numberVector(text, svp._edgeMultiColumnPos))
1675  								{
1676  									bool canBeBg = svp._edgeMultiColumnPos.size() == 1;
1677  									if (!canBeBg)
1678  									{
1679  										svp._isEdgeBgMode = false;
1680  										::SendDlgItemMessage(_hSelf, IDC_CHECK_EDGEBGMODE, BM_SETCHECK, FALSE, 0);
1681  									}
1682  									::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_EDGEBGMODE), canBeBg);
1683  									::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
1684  									return TRUE;
1685  								}
1686  							}
1687  						}
1688  						break;
1689  					}
1690  			}
1691  		}
1692  	}
1693  	return FALSE;
1694  }
1695  const size_t fileUpdateChoiceEnable = 0;
1696  const size_t fileUpdateChoiceEnable4All = 1;
1697  const size_t fileUpdateChoiceDisable = 2;
1698  intptr_t CALLBACK MiscSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
1699  {
1700  	NppParameters& nppParam = NppParameters::getInstance();
1701  	NppGUI & nppGUI = nppParam.getNppGUI();
1702  	switch (message) 
1703  	{
1704  		case WM_INITDIALOG :
1705  		{
1706  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Enable")));
1707  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Enable for all opened files")));
1708  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Disable")));
1709  			int selIndex = -1;
<span onclick='openModal()' class='match'>1710  			if (nppGUI._fileAutoDetection & cdEnabledOld)
1711  			{
1712  				selIndex = fileUpdateChoiceEnable4All;
1713  			}
1714  			else if (nppGUI._fileAutoDetection & cdEnabledNew)
1715  			{				
1716  				selIndex = fileUpdateChoiceEnable;
1717  			}
1718  			else 
1719  			{
1720  				::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), FALSE);
1721  				::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), FALSE);
1722  				selIndex = fileUpdateChoiceDisable;
1723  			}
</span>1724  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_SETCURSEL, selIndex, 0);
1725  			bool bCheck = (nppGUI._fileAutoDetection & cdAutoUpdate) ? true : false;
1726  			::SendDlgItemMessage(_hSelf, IDC_CHECK_UPDATESILENTLY, BM_SETCHECK, bCheck? BST_CHECKED: BST_UNCHECKED, 0);
1727  			bCheck = (nppGUI._fileAutoDetection & cdGo2end) ? true : false;
1728  			::SendDlgItemMessage(_hSelf, IDC_CHECK_UPDATEGOTOEOF, BM_SETCHECK, bCheck ? BST_CHECKED : BST_UNCHECKED, 0);
1729  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MIN2SYSTRAY, BM_SETCHECK, nppGUI._isMinimizedToTray, 0);
1730  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DETECTENCODING, BM_SETCHECK, nppGUI._detectEncoding, 0);
1731  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SAVEALLCONFIRM, BM_SETCHECK, nppGUI._saveAllConfirm, 0);
1732  			::SendDlgItemMessage(_hSelf, IDC_CHECK_AUTOUPDATE, BM_SETCHECK, nppGUI._autoUpdateOpt._doAutoUpdate, 0);
1733  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DIRECTWRITE_ENABLE, BM_SETCHECK, nppGUI._writeTechnologyEngine == directWriteTechnology, 0);
1734  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCPEEKER, BM_SETCHECK, nppGUI._isDocPeekOnTab ? BST_CHECKED : BST_UNCHECKED, 0);
1735  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCPEEKONMAP, BM_SETCHECK, nppGUI._isDocPeekOnMap ? BST_CHECKED : BST_UNCHECKED, 0);
1736  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MUTE_SOUNDS, BM_SETCHECK, nppGUI._muteSounds ? BST_CHECKED : BST_UNCHECKED, 0);
1737  			::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_AUTOUPDATE), nppGUI._doesExistUpdater?SW_SHOW:SW_HIDE);
1738  			::SendDlgItemMessage(_hSelf, IDC_EDIT_SESSIONFILEEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._definedSessionExt.c_str()));
1739  			::SendDlgItemMessage(_hSelf, IDC_EDIT_WORKSPACEFILEEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._definedWorkspaceExt.c_str()));
1740  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLEDOCSWITCHER, BM_SETCHECK, nppGUI._doTaskList, 0);
1741  			::SendDlgItemMessage(_hSelf, IDC_CHECK_STYLEMRU, BM_SETCHECK, nppGUI._styleMRU, 0);
1742  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SHORTTITLE, BM_SETCHECK, nppGUI._shortTitlebar, 0);
1743  			return TRUE;
1744  		}
1745  		case WM_CTLCOLOREDIT:
1746  		{
1747  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1748  		}
1749  		case WM_CTLCOLORLISTBOX:
1750  		{
1751  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
1752  		}
1753  		case WM_CTLCOLORDLG:
1754  		case WM_CTLCOLORSTATIC:
1755  		{
1756  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1757  		}
1758  		case WM_PRINTCLIENT:
1759  		{
1760  			if (NppDarkMode::isEnabled())
1761  			{
1762  				return TRUE;
1763  			}
1764  			break;
1765  		}
1766  		case WM_COMMAND : 
1767  		{
1768  			if (HIWORD(wParam) == EN_CHANGE)
1769  			{
1770  				switch (LOWORD(wParam))
1771  				{
1772  					case  IDC_EDIT_SESSIONFILEEXT:
1773  					{
1774  						TCHAR sessionExt[MAX_PATH] = { '\0' };
1775  						::SendDlgItemMessage(_hSelf, IDC_EDIT_SESSIONFILEEXT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(sessionExt));
1776  						nppGUI._definedSessionExt = sessionExt;
1777  						return TRUE;
1778  					}
1779  					case  IDC_EDIT_WORKSPACEFILEEXT:
1780  					{
1781  						TCHAR workspaceExt[MAX_PATH] = { '\0' };
1782  						::SendDlgItemMessage(_hSelf, IDC_EDIT_WORKSPACEFILEEXT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(workspaceExt));
1783  						nppGUI._definedWorkspaceExt = workspaceExt;
1784  						return TRUE;
1785  					}
1786  				}
1787  			}
1788  			switch (wParam)
1789  			{
1790  				case IDC_CHECK_UPDATESILENTLY:
1791  				case IDC_CHECK_UPDATEGOTOEOF:
1792  				{
1793  					bool isSilent = isCheckedOrNot(IDC_CHECK_UPDATESILENTLY);
1794  					bool isGo2End = isCheckedOrNot(IDC_CHECK_UPDATEGOTOEOF);
1795  					auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_GETCURSEL, 0, 0);
1796  					int cd = cdDisabled;
1797  					if (index == fileUpdateChoiceEnable || index == fileUpdateChoiceEnable4All)
1798  					{
1799  						if (index == fileUpdateChoiceEnable4All)
1800  							cd |= cdEnabledOld;
1801  						else
1802  							cd |= cdEnabledNew;
1803  						if (isSilent)
1804  							cd |= cdAutoUpdate;
1805  						if (isGo2End)
1806  							cd |= cdGo2end;
1807  					}
1808  					nppGUI._fileAutoDetection = cd;
1809  				}
1810  				return TRUE;
1811  				case IDC_CHECK_AUTOUPDATE:
1812  					nppGUI._autoUpdateOpt._doAutoUpdate = isCheckedOrNot(static_cast<int32_t>(wParam));
1813  					return TRUE;
1814  				case IDC_CHECK_MIN2SYSTRAY:
1815  					nppGUI._isMinimizedToTray = isCheckedOrNot(static_cast<int32_t>(wParam));
1816  					return TRUE;
1817  				case IDC_CHECK_DETECTENCODING:
1818  					nppGUI._detectEncoding = isCheckedOrNot(static_cast<int32_t>(wParam));
1819  					return TRUE;
1820  				case IDC_CHECK_ENABLEDOCSWITCHER :
1821  				{
1822  					nppGUI._doTaskList = !nppGUI._doTaskList;
1823  					if (nppGUI._doTaskList)
1824  					{
1825  						::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_STYLEMRU), TRUE);
1826  					}
1827  					else
1828  					{
1829  						nppGUI._styleMRU = false;
1830  						::SendDlgItemMessage(_hSelf, IDC_CHECK_STYLEMRU, BM_SETCHECK, false, 0);
1831  						::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_STYLEMRU), FALSE);
1832  					}
1833  					return TRUE;
1834  				}
1835  				case IDC_CHECK_STYLEMRU :
1836  				{
1837  					nppGUI._styleMRU = isCheckedOrNot(IDC_CHECK_STYLEMRU);
1838  					return TRUE;
1839  				}
1840  				case IDC_CHECK_SHORTTITLE:
1841  				{
1842  					nppGUI._shortTitlebar = isCheckedOrNot(IDC_CHECK_SHORTTITLE);
1843  					HWND grandParent = ::GetParent(_hParent);
1844  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATETITLEBAR, 0, 0);
1845  					return TRUE;
1846  				}
1847  				case IDC_CHECK_DIRECTWRITE_ENABLE:
1848  				{
1849  					nppGUI._writeTechnologyEngine = isCheckedOrNot(IDC_CHECK_DIRECTWRITE_ENABLE) ? directWriteTechnology : defaultTechnology;
1850  					return TRUE;
1851  				}
1852  				case IDC_CHECK_ENABLEDOCPEEKER:
1853  				{
1854  					nppGUI._isDocPeekOnTab = isCheckedOrNot(IDC_CHECK_ENABLEDOCPEEKER);
1855  					return TRUE;
1856  				}
1857  				case IDC_CHECK_ENABLEDOCPEEKONMAP:
1858  				{
1859  					nppGUI._isDocPeekOnMap = isCheckedOrNot(IDC_CHECK_ENABLEDOCPEEKONMAP);
1860  					return TRUE;
1861  				}
1862  				case IDC_CHECK_MUTE_SOUNDS:
1863  				{
1864  					nppGUI._muteSounds = isCheckedOrNot(IDC_CHECK_MUTE_SOUNDS);
1865  					return TRUE;
1866  				}
1867  				case IDC_CHECK_SAVEALLCONFIRM:
1868  				{
1869  					nppGUI._saveAllConfirm = isCheckedOrNot(IDC_CHECK_SAVEALLCONFIRM);
1870  					return TRUE;
1871  				}
1872  				default:
1873  				{
1874  					if (HIWORD(wParam) == CBN_SELCHANGE)
1875  					{
1876  						if (LOWORD(wParam) == IDC_COMBO_FILEUPDATECHOICE)
1877  						{
1878  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FILEUPDATECHOICE, CB_GETCURSEL, 0, 0);
1879  							if (index == fileUpdateChoiceEnable || index == fileUpdateChoiceEnable4All)
1880  							{
1881  								bool isSilent = isCheckedOrNot(IDC_CHECK_UPDATESILENTLY);
1882  								bool isGo2End = isCheckedOrNot(IDC_CHECK_UPDATEGOTOEOF);
1883  								int cd = cdDisabled;
1884  								if (index == fileUpdateChoiceEnable4All)
1885  									cd |= cdEnabledOld;
1886  								else
1887  									cd |= cdEnabledNew;
1888  								if (isSilent)
1889  									cd |= cdAutoUpdate;
1890  								if (isGo2End)
1891  									cd |= cdGo2end;
1892  								nppGUI._fileAutoDetection = cd;
1893  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), TRUE);
1894  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), TRUE);
1895  							}
1896  							else if (index == fileUpdateChoiceDisable)
1897  							{
1898  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), FALSE);
1899  								::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), FALSE);
1900  								nppGUI._fileAutoDetection = cdDisabled;
1901  							}
1902  							return TRUE;
1903  						}
1904  					}
1905  				}
1906  			}
1907  		}
1908  	}
1909  	return FALSE;
1910  }
1911  intptr_t CALLBACK NewDocumentSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
1912  {
1913  	NppParameters& nppParam = NppParameters::getInstance();
1914  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
1915  	NewDocDefaultSettings & ndds = (NewDocDefaultSettings &)nppGUI.getNewDocDefaultSettings();
1916  	switch (message)
1917  	{
1918  		case WM_INITDIALOG:
1919  		{
1920  			int ID2Check = IDC_RADIO_F_WIN;
1921  			switch (ndds._format)
1922  			{
1923  				case EolType::windows:
1924  					ID2Check = IDC_RADIO_F_WIN;
1925  					break;
1926  				case EolType::macos:
1927  					ID2Check = IDC_RADIO_F_MAC;
1928  					break;
1929  				case EolType::unix:
1930  					ID2Check = IDC_RADIO_F_UNIX;
1931  					break;
1932  				case EolType::unknown:
1933  					assert(false);
1934  					break;
1935  			}
1936  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
1937  			switch (ndds._unicodeMode)
1938  			{
1939  				case uni16BE :
1940  					ID2Check = IDC_RADIO_UTF16BIG;
1941  					break;
1942  				case uni16LE :
1943  					ID2Check = IDC_RADIO_UTF16SMALL;
1944  					break;
1945  				case uniUTF8 :
1946  					ID2Check = IDC_RADIO_UTF8;
1947  					break;
1948  				case uniCookie :
1949  					ID2Check = IDC_RADIO_UTF8SANSBOM;
1950  					break;
1951  				default : 
1952  					ID2Check = IDC_RADIO_ANSI;
1953  			}
1954  			int selIndex = -1;
1955  			generic_string str;
1956  			EncodingMapper& em = EncodingMapper::getInstance();
1957  			for (size_t i = 0, encodingArraySize = sizeof(encodings)/sizeof(int) ; i < encodingArraySize ; ++i)
1958  			{
1959  				int cmdID = em.getIndexFromEncoding(encodings[i]);
1960  				if (cmdID != -1)
1961  				{
1962  					cmdID += IDM_FORMAT_ENCODE;
1963  					getNameStrFromCmd(cmdID, str);
1964  					int index = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str())));
1965  					if (ndds._codepage == encodings[i])
1966  						selIndex = index;
1967  					::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_SETITEMDATA, index, encodings[i]);
1968  				}
1969  			}
1970  			if (ndds._codepage == -1 || selIndex == -1)
1971  			{
1972  				::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
1973  			}
1974  			else
1975  			{
1976  				ID2Check = IDC_RADIO_OTHERCP;
1977  				::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_SETCURSEL, selIndex, 0);
1978  			}
1979  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
1980  			::SendDlgItemMessage(_hSelf, IDC_CHECK_OPENANSIASUTF8, BM_SETCHECK, (ID2Check == IDC_RADIO_UTF8SANSBOM && ndds._openAnsiAsUtf8)?BST_CHECKED:BST_UNCHECKED, 0);
1981  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_OPENANSIASUTF8), ID2Check == IDC_RADIO_UTF8SANSBOM);
1982  			for (int i = L_TEXT + 1 ; i < nppParam.L_END ; ++i) 
1983  			{
1984  				LangType lt = static_cast<LangType>(i);
1985  				str.clear();
1986  				if (lt != L_USER && lt != L_JS)
1987  				{
1988  					int cmdID = nppParam.langTypeToCommandID(lt);
1989  					if ((cmdID != -1))
1990  					{
1991  						getNameStrFromCmd(cmdID, str);
1992  						if (str.length() > 0)
1993  						{
1994  							size_t index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
1995  							::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_SETITEMDATA, index, lt);
1996  						}
1997  					}
1998  				}
1999  			}
2000  			int normalTextCmdID = nppParam.langTypeToCommandID(L_TEXT);
2001  			getNameStrFromCmd(normalTextCmdID, str);
2002  			::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
2003  			LangType l = L_TEXT;
2004  			size_t cbCount = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETCOUNT, 0, 0);
2005  			size_t j = 0;
2006  			for (; j < cbCount; ++j)
2007  			{
2008  				l = static_cast<LangType>(::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETITEMDATA, j, 0));
2009  				if (ndds._lang == l)
2010  					break;
2011  			}
2012  			::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_SETCURSEL, j, 0);
2013  			return TRUE;
2014  		}
2015  		case WM_CTLCOLORLISTBOX:
2016  		{
2017  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
2018  		}
2019  		case WM_CTLCOLORDLG:
2020  		case WM_CTLCOLORSTATIC:
2021  		{
2022  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2023  		}
2024  		case WM_PRINTCLIENT:
2025  		{
2026  			if (NppDarkMode::isEnabled())
2027  			{
2028  				return TRUE;
2029  			}
2030  			break;
2031  		}
2032  		case WM_COMMAND:
2033  			switch (wParam)
2034  			{
2035  				case IDC_RADIO_UTF16BIG:
2036  					ndds._unicodeMode = uni16BE;
2037  					ndds._openAnsiAsUtf8 = false;
2038  					makeOpenAnsiAsUtf8(false);
2039  					ndds._codepage = -1;
2040  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2041  					return TRUE;
2042  				case IDC_RADIO_UTF16SMALL:
2043  					ndds._unicodeMode = uni16LE;
2044  					ndds._openAnsiAsUtf8 = false;
2045  					makeOpenAnsiAsUtf8(false);
2046  					ndds._codepage = -1;
2047  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2048  					return TRUE;
2049  				case IDC_RADIO_UTF8:
2050  					ndds._unicodeMode = uniUTF8;
2051  					ndds._openAnsiAsUtf8 = false;
2052  					makeOpenAnsiAsUtf8(false);
2053  					ndds._codepage = -1;
2054  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2055  					return TRUE;
2056  				case IDC_RADIO_UTF8SANSBOM:
2057  					ndds._unicodeMode = uniCookie;
2058  					makeOpenAnsiAsUtf8(true);
2059  					ndds._codepage = -1;
2060  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2061  					return TRUE;
2062  				case IDC_RADIO_ANSI:
2063  					ndds._unicodeMode = uni8Bit;
2064  					ndds._openAnsiAsUtf8 = false;
2065  					makeOpenAnsiAsUtf8(false);
2066  					ndds._codepage = -1;
2067  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), false);
2068  					return TRUE;
2069  				case IDC_CHECK_OPENANSIASUTF8 :
2070  					ndds._openAnsiAsUtf8 = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_OPENANSIASUTF8), BM_GETCHECK, 0, 0));
2071  					return TRUE;
2072  				case IDC_RADIO_OTHERCP :
2073  				{
2074  					ndds._openAnsiAsUtf8 = false;
2075  					makeOpenAnsiAsUtf8(false);
2076  					::EnableWindow(::GetDlgItem(_hSelf, IDC_COMBO_OTHERCP), true);
2077  					auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETCURSEL, 0, 0);
2078  					ndds._codepage = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETITEMDATA, index, 0));
2079  					return TRUE;
2080  				}
2081  				case IDC_RADIO_F_MAC:
2082  				{
2083  					ndds._format = EolType::macos;
2084  					return TRUE;
2085  				}
2086  				case IDC_RADIO_F_UNIX:
2087  				{
2088  					ndds._format = EolType::unix;
2089  					return TRUE;
2090  				}
2091  				case IDC_RADIO_F_WIN:
2092  				{
2093  					ndds._format = EolType::windows;
2094  					return TRUE;
2095  				}
2096  				default:
2097  				{
2098  					if (HIWORD(wParam) == CBN_SELCHANGE)
2099  					{
2100  						if (LOWORD(wParam) == IDC_COMBO_DEFAULTLANG)
2101  						{
2102  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETCURSEL, 0, 0);
2103  							ndds._lang = static_cast<LangType>(::SendDlgItemMessage(_hSelf, IDC_COMBO_DEFAULTLANG, CB_GETITEMDATA, index, 0));
2104  							return TRUE;
2105  						}
2106  						else if (LOWORD(wParam) == IDC_COMBO_OTHERCP)
2107  						{
2108  							auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETCURSEL, 0, 0);
2109  							ndds._codepage = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_COMBO_OTHERCP, CB_GETITEMDATA, index, 0));
2110  							return TRUE;
2111  						}
2112  					}
2113  					return FALSE;
2114  				}
2115  			}
2116  	}
2117   	return FALSE;
2118  }
2119  intptr_t CALLBACK DefaultDirectorySubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
2120  {
2121  	NppParameters& nppParam = NppParameters::getInstance();
2122  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
2123  	switch (message) 
2124  	{
2125  		case WM_INITDIALOG :
2126  		{
2127  			int ID2Check = 0;
2128  			bool shouldActivated;
2129  			switch (nppGUI._openSaveDir)
2130  			{
2131  				case dir_last :
2132  					ID2Check = IDC_OPENSAVEDIR_REMEMBERLAST_RADIO;
2133  					shouldActivated = false;
2134  					break;
2135  				case dir_userDef :
2136  					ID2Check = IDC_OPENSAVEDIR_ALWAYSON_RADIO;
2137  					shouldActivated = true;
2138  					break;
2139  				default : 
2140  					ID2Check = IDC_OPENSAVEDIR_FOLLOWCURRENT_RADIO;
2141  					shouldActivated = false;
2142  			}
2143  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
2144  			::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._defaultDir));
2145  			::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), shouldActivated);
2146  			::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), shouldActivated);
2147  			::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES, BM_SETCHECK, nppGUI._isFolderDroppedOpenFiles ? BST_CHECKED : BST_UNCHECKED, 0);
2148  			return TRUE;
2149  		}
2150  		case WM_CTLCOLOREDIT:
2151  		{
2152  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2153  		}
2154  		case WM_CTLCOLORDLG:
2155  		case WM_CTLCOLORSTATIC:
2156  		{
2157  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2158  		}
2159  		case WM_PRINTCLIENT:
2160  		{
2161  			if (NppDarkMode::isEnabled())
2162  			{
2163  				return TRUE;
2164  			}
2165  			break;
2166  		}
2167  		case WM_COMMAND : 
2168  		{
2169  			if (HIWORD(wParam) == EN_CHANGE)
2170  			{
2171  				switch (LOWORD(wParam))
2172  				{
2173  					case  IDC_OPENSAVEDIR_ALWAYSON_EDIT:
2174  					{
2175  						TCHAR inputDir[MAX_PATH] = { '\0' };
2176  						::SendDlgItemMessage(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
2177  						wcscpy_s(nppGUI._defaultDir, inputDir);
2178  						::ExpandEnvironmentStrings(nppGUI._defaultDir, nppGUI._defaultDirExp, _countof(nppGUI._defaultDirExp));
2179  						nppParam.setWorkingDir(nppGUI._defaultDirExp);
2180  						return TRUE;
2181  					}
2182  				}
2183  			}
2184  			switch (wParam)
2185  			{
2186  				case IDC_OPENSAVEDIR_FOLLOWCURRENT_RADIO:
2187  					nppGUI._openSaveDir = dir_followCurrent;
2188  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_REFRESHWORKDIR, 0, 0);
2189  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), false);
2190  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), false);
2191  					return TRUE;
2192  				case IDC_OPENSAVEDIR_REMEMBERLAST_RADIO:
2193  					nppGUI._openSaveDir = dir_last;
2194  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), false);
2195  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), false);
2196  					return TRUE;
2197  				case IDC_OPENSAVEDIR_ALWAYSON_RADIO:
2198  					nppGUI._openSaveDir = dir_userDef;
2199  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_REFRESHWORKDIR, 0, 0);
2200  					::EnableWindow(::GetDlgItem(_hSelf, IDC_OPENSAVEDIR_ALWAYSON_EDIT), true);
2201  					::EnableWindow(::GetDlgItem(_hSelf, IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON), true);
2202  					return TRUE;
2203  				case IDD_OPENSAVEDIR_ALWAYSON_BROWSE_BUTTON :
2204  					{
2205  						generic_string title = nppParam.getNativeLangSpeaker()->getLocalizedStrFromID("default-open-save-select-folder",
2206  							TEXT("Select a folder as default directory"));
2207  						folderBrowser(_hSelf, title, IDC_OPENSAVEDIR_ALWAYSON_EDIT);
2208  					}
2209  					return TRUE;
2210  				case IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES:
2211  					nppGUI._isFolderDroppedOpenFiles = isCheckedOrNot(IDC_OPENSAVEDIR_CHECK_DRROPFOLDEROPENFILES);
2212  					return TRUE;
2213  				default:
2214  					return FALSE;
2215  			}
2216  		}
2217  	}
2218  	return FALSE;
2219  }
2220  void RecentFilesHistorySubDlg::setCustomLen(int val)
2221  {
2222  	::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, val, FALSE);
2223  	::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL), val > 0);
2224  }
2225  intptr_t CALLBACK RecentFilesHistorySubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
2226  {
2227  	NppParameters& nppParam = NppParameters::getInstance();
2228  	NppGUI& nppGUI = nppParam.getNppGUI();
2229  	switch (message) 
2230  	{
2231  		case WM_INITDIALOG:
2232  		{
2233  			::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nppParam.getNbMaxRecentFile(), FALSE);
2234  			::SendDlgItemMessage(_hSelf, IDC_CHECK_DONTCHECKHISTORY, BM_SETCHECK, !nppGUI._checkHistoryFiles, 0);
2235  			::SendDlgItemMessage(_hSelf, IDC_CHECK_INSUBMENU, BM_SETCHECK, nppParam.putRecentFileInSubMenu(), 0);
2236  			int customLength = nppParam.getRecentFileCustomLength();
2237  			int id = IDC_RADIO_CUSTOMIZELENTH;
2238  			int length = customLength;
2239  			if (customLength == RECENTFILES_SHOWONLYFILENAME)
2240  			{
2241  				id = IDC_RADIO_ONLYFILENAME;
2242  				length = 0;
2243  			}
2244  			else if (customLength == RECENTFILES_SHOWFULLPATH || customLength < 0)
2245  			{
2246  				id = IDC_RADIO_FULLFILENAMEPATH;
2247  				length = 0;
2248  			}
2249  			setChecked(id);
2250  			setCustomLen(length);
2251  			return TRUE;
2252  		}
2253  		case WM_CTLCOLOREDIT:
2254  		{
2255  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2256  		}
2257  		case WM_CTLCOLORDLG:
2258  		{
2259  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2260  		}
2261  		case WM_CTLCOLORSTATIC:
2262  		{
2263  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
2264  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
2265  			if (dlgCtrlID == IDC_CUSTOMIZELENGTH_RANGE_STATIC)
2266  			{
2267  				const bool isTextEnabled = isCheckedOrNot(IDC_RADIO_CUSTOMIZELENTH);
2268  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
2269  			}
2270  			if (dlgCtrlID == IDC_EDIT_CUSTOMIZELENGTHVAL)
2271  			{
2272  				return NppDarkMode::onCtlColor(hdcStatic);
2273  			}
2274  			return NppDarkMode::onCtlColorDarker(hdcStatic);
2275  		}
2276  		case WM_PRINTCLIENT:
2277  		{
2278  			if (NppDarkMode::isEnabled())
2279  			{
2280  				return TRUE;
2281  			}
2282  			break;
2283  		}
2284  		case WM_COMMAND:
2285  		{
2286  			switch (LOWORD(wParam))
2287  			{
2288  				case IDC_EDIT_MAXNBFILEVAL:
2289  				{
2290  					switch (HIWORD(wParam))
2291  					{
2292  						case EN_KILLFOCUS:
2293  						{
2294  							constexpr int stringSize = 3;
2295  							wchar_t str[stringSize]{};
2296  							::GetDlgItemText(_hSelf, IDC_EDIT_MAXNBFILEVAL, str, stringSize);
2297  							if (lstrcmp(str, L"") == 0)
2298  							{
2299  								::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nppParam.getNbMaxRecentFile(), FALSE);
2300  								return FALSE;
2301  							}
2302  							UINT nbMaxFile = ::GetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, nullptr, FALSE);
2303  							if (nbMaxFile == nppParam.getNbMaxRecentFile())
2304  							{
2305  								return FALSE;
2306  							}
2307  							if (nbMaxFile > NB_MAX_LRF_FILE)
2308  							{
2309  								::SetDlgItemInt(_hSelf, IDC_EDIT_MAXNBFILEVAL, NB_MAX_LRF_FILE, FALSE);
2310  								nbMaxFile = NB_MAX_LRF_FILE;
2311  							}
2312  							nppParam.setNbMaxRecentFile(nbMaxFile);
2313  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_HISTORY_SIZE, 0, 0);
2314  							return TRUE;
2315  						}
2316  						default:
2317  						{
2318  							break;
2319  						}
2320  					}
2321  					return FALSE;
2322  				}
2323  				case IDC_EDIT_CUSTOMIZELENGTHVAL:
2324  				{
2325  					if (!isCheckedOrNot(IDC_RADIO_CUSTOMIZELENTH))
2326  					{
2327  						return FALSE;
2328  					}
2329  					switch (HIWORD(wParam))
2330  					{
2331  						case EN_KILLFOCUS:
2332  						{
2333  							constexpr int stringSize = 4;
2334  							wchar_t str[stringSize]{};
2335  							::GetDlgItemText(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, str, stringSize);
2336  							if (lstrcmp(str, L"") == 0)
2337  							{
2338  								::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, nppParam.getRecentFileCustomLength(), FALSE);
2339  								return FALSE;
2340  							}
2341  							UINT size = ::GetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, nullptr, FALSE);
2342  							if (size == static_cast<UINT>(nppParam.getRecentFileCustomLength()))
2343  							{
2344  								return FALSE;
2345  							}
2346  							bool change = false;
2347  							if (size == 0)
2348  							{
2349  								size = NB_DEFAULT_LRF_CUSTOMLENGTH;
2350  								change = true;
2351  							}
2352  							else if (size > NB_MAX_LRF_CUSTOMLENGTH)
2353  							{
2354  								size = NB_MAX_LRF_CUSTOMLENGTH;
2355  								change = true;
2356  							}
2357  							if (change)
2358  							{
2359  								::SetDlgItemInt(_hSelf, IDC_EDIT_CUSTOMIZELENGTHVAL, size, FALSE);
2360  							}
2361  							nppParam.setRecentFileCustomLength(size);
2362  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2363  							return TRUE;
2364  						}
2365  						default:
2366  						{
2367  							break;
2368  						}
2369  					}
2370  					return FALSE;
2371  				}
2372  				default:
2373  				{
2374  					break;
2375  				}
2376  			}
2377  			switch (wParam)
2378  			{
2379  				case IDC_CHECK_DONTCHECKHISTORY:
2380  					nppGUI._checkHistoryFiles = !isCheckedOrNot(IDC_CHECK_DONTCHECKHISTORY);
2381  					return TRUE;
2382  				case IDC_CHECK_INSUBMENU:
2383  					nppParam.setPutRecentFileInSubMenu(isCheckedOrNot(IDC_CHECK_INSUBMENU));
2384  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_SWITCH, 0, 0);
2385  					return TRUE;
2386  				case IDC_RADIO_ONLYFILENAME:
2387  				{
2388  					setCustomLen(0);
2389  					nppParam.setRecentFileCustomLength(0);
2390  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2391  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2392  					return TRUE;
2393  				}
2394  				case IDC_RADIO_FULLFILENAMEPATH:
2395  				{
2396  					setCustomLen(0);
2397  					nppParam.setRecentFileCustomLength(-1);
2398  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2399  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2400  					return TRUE;
2401  				}
2402  				case IDC_RADIO_CUSTOMIZELENTH:
2403  				{
2404  					int len = nppParam.getRecentFileCustomLength();
2405  					if (len <= 0)
2406  					{
2407  						setCustomLen(NB_DEFAULT_LRF_CUSTOMLENGTH);
2408  						nppParam.setRecentFileCustomLength(NB_DEFAULT_LRF_CUSTOMLENGTH);
2409  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_RECENTFILELIST_UPDATE, 0, 0);
2410  					}
2411  					redrawDlgItem(IDC_CUSTOMIZELENGTH_RANGE_STATIC);
2412  					return TRUE;
2413  				}
2414  				default:
2415  					return FALSE;
2416  			}
2417  		}
2418  	}
2419  	return FALSE;
2420  }
2421  intptr_t CALLBACK LanguageSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
2422  {
2423  	NppParameters& nppParam = NppParameters::getInstance();
2424  	NppGUI & nppGUI = nppParam.getNppGUI();
2425  	NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
2426  	switch (message) 
2427  	{
2428  		case WM_INITDIALOG :
2429  		{
2430  			for (int i = L_TEXT ; i < nppParam.L_END ; ++i)
2431  			{
2432  				generic_string str;
2433  				if (static_cast<LangType>(i) != L_USER)
2434  				{
2435  					int cmdID = nppParam.langTypeToCommandID(static_cast<LangType>(i));
2436  					if ((cmdID != -1))
2437  					{
2438  						getNameStrFromCmd(cmdID, str);
2439  						if (str.length() > 0)
2440  						{
2441  							_langList.push_back(LangMenuItem(static_cast<LangType>(i), cmdID, str));
2442  							::SendDlgItemMessage(_hSelf, IDC_LIST_ENABLEDLANG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(str.c_str()));
2443  						}
2444  					}
2445  				}
2446  			}
2447  			for (size_t i = 0, len = nppGUI._excludedLangList.size(); i < len ; ++i)
2448  			{
2449  				::SendDlgItemMessage(_hSelf, IDC_LIST_DISABLEDLANG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(nppGUI._excludedLangList[i]._langName.c_str()));
2450  			}
2451  			::SendDlgItemMessage(_hSelf, IDC_CHECK_LANGMENUCOMPACT, BM_SETCHECK, nppGUI._isLangMenuCompact?BST_CHECKED:BST_UNCHECKED, 0);
2452  			::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_REMOVE), FALSE);
2453  			::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_RESTORE), FALSE);
2454  			::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nppGUI._tabSize, FALSE);
2455  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REPLACEBYSPACE, BM_SETCHECK, nppGUI._tabReplacedBySpace, 0);
2456  			::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("[Default]")));
2457  			const int nbLang = nppParam.getNbLang();
2458  			for (int i = 0; i < nbLang; ++i)
2459  			{
2460  				::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(nppParam.getLangFromIndex(i)->_langName.c_str()));
2461  			}
2462  			const int index2Begin = 0;
2463  			::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_SETCURSEL, index2Begin, 0);
2464  			::ShowWindow(::GetDlgItem(_hSelf, IDC_GR_TABVALUE_STATIC), SW_HIDE);
2465  			::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), SW_HIDE);
2466  			::SendDlgItemMessage(_hSelf, IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL, BM_SETCHECK, nppGUI._backSlashIsEscapeCharacterForSql, 0);
2467  			return TRUE;
2468  		}
2469  		case WM_CTLCOLOREDIT:
2470  		{
2471  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2472  		}
2473  		case WM_CTLCOLORLISTBOX:
2474  		{
2475  			return NppDarkMode::onCtlColorListbox(wParam, lParam);
2476  		}
2477  		case WM_CTLCOLORDLG:
2478  		{
2479  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2480  		}
2481  		case WM_CTLCOLORSTATIC:
2482  		{
2483  			const int dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
2484  			const auto& hdcStatic = reinterpret_cast<HDC>(wParam);
2485  			const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2486  			if ((index > 0) && (dlgCtrlID == IDC_TABSIZE_STATIC))
2487  			{
2488  				const Lang* lang = nppParam.getLangFromIndex(index - 1);
2489  				if (lang == nullptr)
2490  				{
2491  					return NppDarkMode::onCtlColorDarker(hdcStatic);
2492  				}
2493  				const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2494  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, !useDefaultTab);
2495  			}
2496  			return NppDarkMode::onCtlColorDarker(hdcStatic);
2497  		}
2498  		case WM_PRINTCLIENT:
2499  		{
2500  			if (NppDarkMode::isEnabled())
2501  			{
2502  				return TRUE;
2503  			}
2504  			break;
2505  		}
2506  		case WM_COMMAND : 
2507  		{
2508  			switch (HIWORD(wParam))
2509  			{
2510  				case LBN_SELCHANGE:
2511  				{
2512  					if (LOWORD(wParam) == IDC_LIST_DISABLEDLANG || LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2513  					{
2514  						int idButton2Enable;
2515  						int idButton2Disable;
2516  						if (LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2517  						{
2518  							idButton2Enable = IDC_BUTTON_REMOVE;
2519  							idButton2Disable = IDC_BUTTON_RESTORE;
2520  						}
2521  						else 
2522  						{
2523  							idButton2Enable = IDC_BUTTON_RESTORE;
2524  							idButton2Disable = IDC_BUTTON_REMOVE;
2525  						}
2526  						auto i = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), LB_GETCURSEL, 0, 0);
2527  						if (i != LB_ERR)
2528  						{
2529  							::EnableWindow(::GetDlgItem(_hSelf, idButton2Enable), TRUE);
2530  							int idListbox2Disable = (LOWORD(wParam) == IDC_LIST_ENABLEDLANG) ? IDC_LIST_DISABLEDLANG : IDC_LIST_ENABLEDLANG;
2531  							::SendDlgItemMessage(_hSelf, idListbox2Disable, LB_SETCURSEL, static_cast<WPARAM>(-1), 0);
2532  							::EnableWindow(::GetDlgItem(_hSelf, idButton2Disable), FALSE);
2533  						}
2534  						return TRUE;
2535  					}
2536  					else if (LOWORD(wParam) == IDC_LIST_TABSETTNG)
2537  					{
2538  						auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2539  						if (index == LB_ERR)
2540  							return FALSE;
2541  						::ShowWindow(::GetDlgItem(_hSelf, IDC_GR_TABVALUE_STATIC), index > 0 ? SW_SHOW : SW_HIDE);
2542  						::ShowWindow(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), index > 0 ? SW_SHOW : SW_HIDE);
2543  						if (index > 0)
2544  						{
2545  							Lang* lang = nppParam.getLangFromIndex(index - 1);
2546  							if (!lang) return FALSE;
2547  							bool useDefaultTab = (lang->_tabSize == -1 || lang->_tabSize == 0);
2548  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_DEFAULTTABVALUE), BM_SETCHECK, useDefaultTab, 0);
2549  							int size = useDefaultTab ? nppGUI._tabSize : lang->_tabSize;
2550  							::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, size, FALSE);
2551  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, useDefaultTab ? nppGUI._tabReplacedBySpace : lang->_isTabReplacedBySpace, 0);
2552  							::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), !useDefaultTab);
2553  							::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), !useDefaultTab);
2554  							if (!useDefaultTab)
2555  							{
2556  								::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, lang->_tabSize, FALSE);
2557  								::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, lang->_isTabReplacedBySpace, 0);
2558  							}
2559  						}
2560  						else
2561  						{
2562  							::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nppGUI._tabSize, FALSE);
2563  							::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), TRUE);
2564  							::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), TRUE);
2565  							::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_SETCHECK, nppGUI._tabReplacedBySpace, 0);
2566  						}
2567  						redrawDlgItem(IDC_TABSIZE_STATIC);
2568  						return TRUE;
2569  					}
2570  					break;
2571  				}
2572  				case LBN_DBLCLK:
2573  				{
2574  					if (LOWORD(wParam) == IDC_LIST_DISABLEDLANG || LOWORD(wParam) == IDC_LIST_ENABLEDLANG)
2575  					{
2576  						HWND(lParam) == ::GetDlgItem(_hSelf, IDC_LIST_ENABLEDLANG) ?
2577  							::SendMessage(_hSelf, WM_COMMAND, IDC_BUTTON_REMOVE, 0) :
2578  							::SendMessage(_hSelf, WM_COMMAND, IDC_BUTTON_RESTORE, 0);
2579  						return TRUE;
2580  					}
2581  					break;
2582  				}
2583  				case EN_CHANGE:
2584  				{
2585  					switch (LOWORD(wParam))
2586  					{
2587  						case IDC_EDIT_TABSIZEVAL:
2588  						{
2589  							const auto tabSize = ::GetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nullptr, FALSE);
2590  							if (tabSize < 1)
2591  							{
2592  								return FALSE;
2593  							}
2594  							const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2595  							const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2596  							if (!useDefaultTab && index > 0)
2597  							{
2598  								Lang* lang = nppParam.getLangFromIndex(index - 1);
2599  								if (lang == nullptr)
2600  								{
2601  									return FALSE;
2602  								}
2603  								if (lang->_langID == L_JS)
2604  								{
2605  									Lang* ljs = nppParam.getLangFromID(L_JAVASCRIPT);
2606  									ljs->_tabSize = tabSize;
2607  								}
2608  								else if (lang->_langID == L_JAVASCRIPT)
2609  								{
2610  									Lang* ljavascript = nppParam.getLangFromID(L_JS);
2611  									ljavascript->_tabSize = tabSize;
2612  								}
2613  								lang->_tabSize = tabSize;
2614  								nppParam.insertTabInfo(lang->getLangName(), lang->getTabInfo());
2615  							}
2616  							else
2617  							{
2618  								nppGUI._tabSize = tabSize;
2619  							}
2620  							::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_TAB_SIZE, 0, 0);
2621  							return TRUE;
2622  						}
2623  						default:
2624  						{
2625  							break;
2626  						}
2627  					}
2628  					break;
2629  				}
2630  				case EN_KILLFOCUS:
2631  				{
2632  					switch (LOWORD(wParam))
2633  					{
2634  						case IDC_EDIT_TABSIZEVAL:
2635  						{
2636  							const auto tabSize = ::GetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, nullptr, FALSE);
2637  							if (tabSize < 1)
2638  							{
2639  								const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2640  								const size_t index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2641  								auto prevSize = nppGUI._tabSize;
2642  								if (!useDefaultTab && index > 0)
2643  								{
2644  									Lang* lang = nppParam.getLangFromIndex(index - 1);
2645  									if (lang != nullptr && lang->_tabSize > 0)
2646  									{
2647  										prevSize = lang->_tabSize;
2648  									}
2649  								}
2650  								::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, prevSize, FALSE);
2651  								return TRUE;
2652  							}
2653  							return FALSE;
2654  						}
2655  						default:
2656  						{
2657  							break;
2658  						}
2659  					}
2660  					break;
2661  				}
2662  				default:
2663  				{
2664  					break;
2665  				}
2666  			}
2667  			switch (wParam)
2668  			{
2669  				case IDC_CHECK_LANGMENUCOMPACT:
2670  				{
2671  					nppGUI._isLangMenuCompact = (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_LANGMENUCOMPACT), BM_GETCHECK, 0, 0));
2672  					pNativeSpeaker->messageBox("LanguageMenuCompactWarning",
2673  						_hSelf,
2674  						TEXT("This option will be changed on the next launch."),
2675  						TEXT("Compact Language Menu"),
2676  						MB_OK);
2677  					return TRUE;
2678  				}
2679  				case IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL:
2680  				{
2681  					nppGUI._backSlashIsEscapeCharacterForSql = isCheckedOrNot(IDC_CHECK_BACKSLASHISESCAPECHARACTERFORSQL);
2682  					return TRUE;
2683  				}
2684  				case IDC_BUTTON_RESTORE :
2685  				case IDC_BUTTON_REMOVE :
2686  				{
2687  					int list2Remove, list2Add, idButton2Enable, idButton2Disable;
2688  					vector<LangMenuItem> *pSrcLst, *pDestLst;
2689  					if (LOWORD(wParam)==IDC_BUTTON_REMOVE)
2690  					{
2691  						list2Remove = IDC_LIST_ENABLEDLANG;
2692  						list2Add = IDC_LIST_DISABLEDLANG;
2693  						idButton2Enable = IDC_BUTTON_RESTORE;
2694  						idButton2Disable = IDC_BUTTON_REMOVE;
2695  						pSrcLst = &_langList;
2696  						pDestLst = &nppGUI._excludedLangList;
2697  					}
2698  					else
2699  					{
2700  						list2Remove = IDC_LIST_DISABLEDLANG;
2701  						list2Add = IDC_LIST_ENABLEDLANG;
2702  						idButton2Enable = IDC_BUTTON_REMOVE;
2703  						idButton2Disable = IDC_BUTTON_RESTORE;
2704  						pSrcLst = &nppGUI._excludedLangList;
2705  						pDestLst = &_langList;
2706  					}
2707  					size_t iRemove = ::SendDlgItemMessage(_hSelf, list2Remove, LB_GETCURSEL, 0, 0);
2708  					if (static_cast<intptr_t>(iRemove) == -1)
2709  						return TRUE;
2710  					const size_t sL = 31;
2711  					TCHAR s[sL + 1] = { '\0' };
2712  					auto lbTextLen = ::SendDlgItemMessage(_hSelf, list2Remove, LB_GETTEXTLEN, iRemove, 0);
2713  					if (static_cast<size_t>(lbTextLen) > sL)
2714  						return TRUE;
2715  					::SendDlgItemMessage(_hSelf, list2Remove, LB_GETTEXT, iRemove, reinterpret_cast<LPARAM>(s));
2716  					LangMenuItem lmi = pSrcLst->at(iRemove);
2717  					vector<LangMenuItem>::iterator lang2Remove = pSrcLst->begin() + iRemove;
2718  					pSrcLst->erase(lang2Remove);
2719  					auto iAdd = ::SendDlgItemMessage(_hSelf, list2Add, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(s));
2720  					::SendDlgItemMessage(_hSelf, list2Remove, LB_DELETESTRING, iRemove, 0);
2721  					pDestLst->push_back(lmi);
2722  					::SendDlgItemMessage(_hSelf, list2Add, LB_SETCURSEL, iAdd, 0);
2723  					::SendDlgItemMessage(_hSelf, list2Remove, LB_SETCURSEL, static_cast<WPARAM>(-1), 0);
2724  					::EnableWindow(::GetDlgItem(_hSelf, idButton2Enable), TRUE);
2725  					::EnableWindow(::GetDlgItem(_hSelf, idButton2Disable), FALSE);
2726  					if ((lmi._langType >= L_EXTERNAL) && (lmi._langType < nppParam.L_END))
2727  					{
2728  						bool found(false);
2729  						for (size_t x = 0; x < nppParam.getExternalLexerDoc()->size() && !found; ++x)
2730  						{
2731  							TiXmlNode *lexersRoot = nppParam.getExternalLexerDoc()->at(x)->FirstChild(TEXT("NotepadPlus"))->FirstChildElement(TEXT("LexerStyles"));
2732  							for (TiXmlNode *childNode = lexersRoot->FirstChildElement(TEXT("LexerType"));
2733  								childNode ;
2734  								childNode = childNode->NextSibling(TEXT("LexerType")))
2735  							{
2736  								TiXmlElement *element = childNode->ToElement();
2737  								if (generic_string(element->Attribute(TEXT("name"))) == lmi._langName)
2738  								{
2739  									element->SetAttribute(TEXT("excluded"), (LOWORD(wParam)==IDC_BUTTON_REMOVE)?TEXT("yes"):TEXT("no"));
2740  									nppParam.getExternalLexerDoc()->at(x)->SaveFile();
2741  									found = true;
2742  									break;
2743  								}
2744  							}
2745  						}
2746  					}
2747  					HWND grandParent = ::GetParent(_hParent);
2748  					if (LOWORD(wParam)==IDC_BUTTON_REMOVE)
2749  					{
2750  						HMENU menu2remove = reinterpret_cast<HMENU>(::SendMessage(grandParent, NPPM_INTERNAL_GETMENU, 0, 0));
2751  						::DeleteMenu(menu2remove, lmi._cmdID, MF_BYCOMMAND);
2752  					}
2753  					else
2754  					{
2755  						HMENU menu = HMENU(::SendMessage(grandParent, NPPM_INTERNAL_GETMENU, 0, 0));
2756  						HMENU subMenu = ::GetSubMenu(menu, MENUINDEX_LANGUAGE);
2757  						int nbItem = ::GetMenuItemCount(subMenu);
2758  						int x = 0;
2759  						MENUITEMINFO menuItemInfo
2760  						{
2761  							.cbSize = sizeof(MENUITEMINFO),
2762  							.fMask = MIIM_FTYPE
2763  						};
2764  						for (; x < nbItem; ++x)
2765  						{
2766  							::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
2767  							if (menuItemInfo.fType & MFT_SEPARATOR)
2768  							{
2769  								break;
2770  							}
2771  						}
2772  						TCHAR firstLetter = lmi._langName.empty() ? TEXT('\0') : towupper(lmi._langName[0]);
2773  						TCHAR buffer[MAX_EXTERNAL_LEXER_NAME_LEN]{TEXT('\0')};
2774  						menuItemInfo.fMask = MIIM_SUBMENU;
2775  						for (++x; x < nbItem; ++x)
2776  						{
2777  							::GetMenuItemInfo(subMenu, x, TRUE, &menuItemInfo);
2778  							::GetMenuString(subMenu, x, buffer, MAX_EXTERNAL_LEXER_NAME_LEN, MF_BYPOSITION);
2779  							if (menuItemInfo.hSubMenu && buffer[0] == firstLetter)
2780  							{
2781  								subMenu = menuItemInfo.hSubMenu;
2782  								nbItem = ::GetMenuItemCount(subMenu);
2783  								x = -1;
2784  							}
2785  							else if (lstrcmp(lmi._langName.c_str(), buffer) < 0)
2786  							{
2787  								break;
2788  							}
2789  						}
2790  						::InsertMenu(subMenu, x, MF_BYPOSITION, lmi._cmdID, lmi._langName.c_str());
2791  					}
2792  					::DrawMenuBar(grandParent);
2793  					return TRUE;
2794  				}
2795  				case IDC_CHECK_REPLACEBYSPACE:
2796  				{
2797  					bool isTabReplacedBySpace = BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), BM_GETCHECK, 0, 0);
2798  					auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2799  					if (index == LB_ERR) return FALSE;
2800  					if (index != 0)
2801  					{
2802  						Lang *lang = nppParam.getLangFromIndex(index - 1);
2803  						if (!lang) return FALSE;
2804  						if (!lang->_tabSize || lang->_tabSize == -1)
2805  							lang->_tabSize = nppGUI._tabSize;
2806  						if (lang->_langID == L_JS)
2807  						{
2808  							Lang *ljs = nppParam.getLangFromID(L_JAVASCRIPT);
2809  							ljs->_isTabReplacedBySpace = isTabReplacedBySpace;
2810  						}
2811  						else if (lang->_langID == L_JAVASCRIPT)
2812  						{
2813  							Lang *ljavascript = nppParam.getLangFromID(L_JS);
2814  							ljavascript->_isTabReplacedBySpace = isTabReplacedBySpace;
2815  						}
2816  						lang->_isTabReplacedBySpace = isTabReplacedBySpace;
2817  						nppParam.insertTabInfo(lang->getLangName(), lang->getTabInfo());
2818  					}
2819  					else
2820  					{
2821  						nppGUI._tabReplacedBySpace = isTabReplacedBySpace;
2822  					}
2823  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETTING_TAB_REPLCESPACE, 0, 0);
2824  					return TRUE;
2825  				}
2826  				case IDC_CHECK_DEFAULTTABVALUE:
2827  				{
2828  					const bool useDefaultTab = isCheckedOrNot(IDC_CHECK_DEFAULTTABVALUE);
2829  					const auto index = ::SendDlgItemMessage(_hSelf, IDC_LIST_TABSETTNG, LB_GETCURSEL, 0, 0);
2830  					if (index == LB_ERR || index == 0) 
2831  						return FALSE;
2832  					Lang *lang = nppParam.getLangFromIndex(index - 1);
2833  					if (!lang)
2834  						return FALSE;
2835  					lang->_tabSize = useDefaultTab ? 0 : nppGUI._tabSize;
2836  					lang->_isTabReplacedBySpace = useDefaultTab ? false : nppGUI._tabReplacedBySpace;
2837  					::SetDlgItemInt(_hSelf, IDC_EDIT_TABSIZEVAL, useDefaultTab ? nppGUI._tabSize : lang->_tabSize, FALSE);
2838  					setChecked(IDC_CHECK_REPLACEBYSPACE, useDefaultTab ? nppGUI._tabReplacedBySpace : lang->_isTabReplacedBySpace);
2839  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_REPLACEBYSPACE), !useDefaultTab);
2840  					::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_TABSIZEVAL), !useDefaultTab);
2841  					if (useDefaultTab)
2842  						nppParam.insertTabInfo(lang->getLangName(), -1);
2843  					redrawDlgItem(IDC_TABSIZE_STATIC);
2844  					return TRUE;
2845  				}
2846  				default:
2847  				{
2848  					break;
2849  				}
2850  			}
2851  		}
2852  		default:
2853  		{
2854  			break;
2855  		}
2856  	}
2857  	return FALSE;
2858  }
2859  intptr_t CALLBACK HighlightingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM&bsol;* lParam*/)
2860  {
2861  	NppParameters& nppParam = NppParameters::getInstance();
2862  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
2863  	switch (message) 
2864  	{
2865  		case WM_INITDIALOG :
2866  		{
2867  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MARKALLCASESENSITIVE, BM_SETCHECK, nppGUI._markAllCaseSensitive, 0);
2868  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MARKALLWHOLEWORDONLY, BM_SETCHECK, nppGUI._markAllWordOnly, 0);
2869  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLSMARTHILITE, BM_SETCHECK, nppGUI._enableSmartHilite, 0);
2870  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE, BM_SETCHECK, nppGUI._smartHiliteCaseSensitive, 0);
2871  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY, BM_SETCHECK, nppGUI._smartHiliteWordOnly, 0);
2872  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, nppGUI._smartHiliteUseFindSettings, 0);
2873  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW, BM_SETCHECK, nppGUI._smartHiliteOnAnotherView, 0);
2874  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLTAGSMATCHHILITE, BM_SETCHECK, nppGUI._enableTagsMatchHilite, 0);
2875  			::SendDlgItemMessage(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE, BM_SETCHECK, nppGUI._enableTagAttrsHilite, 0);
2876  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE, BM_SETCHECK, nppGUI._enableHiliteNonHTMLZone, 0);
2877  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE), nppGUI._enableTagsMatchHilite);
2878  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE), nppGUI._enableTagsMatchHilite);
2879  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE), nppGUI._enableSmartHilite);
2880  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY), nppGUI._enableSmartHilite);
2881  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS), nppGUI._enableSmartHilite);
2882  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW), nppGUI._enableSmartHilite);
2883  			if (NppDarkMode::isEnabled())
2884  			{
2885  				::EnableWindow(::GetDlgItem(_hSelf, IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
2886  			}
2887  			return TRUE;
2888  		}
2889  		case WM_CTLCOLORDLG:
2890  		case WM_CTLCOLORSTATIC:
2891  		{
2892  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2893  		}
2894  		case WM_PRINTCLIENT:
2895  		{
2896  			if (NppDarkMode::isEnabled())
2897  			{
2898  				return TRUE;
2899  			}
2900  			break;
2901  		}
2902  		case WM_COMMAND : 
2903  		{
2904  			switch (wParam)
2905  			{
2906  				case IDC_CHECK_MARKALLCASESENSITIVE:
2907  				{
2908  					nppGUI._markAllCaseSensitive = isCheckedOrNot(IDC_CHECK_MARKALLCASESENSITIVE);
2909  					HWND grandParent = ::GetParent(_hParent);
2910  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2911  					return TRUE;
2912  				}
2913  				case IDC_CHECK_MARKALLWHOLEWORDONLY:
2914  				{
2915  					nppGUI._markAllWordOnly = isCheckedOrNot(IDC_CHECK_MARKALLWHOLEWORDONLY);
2916  					HWND grandParent = ::GetParent(_hParent);
2917  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2918  					return TRUE;
2919  				}
2920  				case IDC_CHECK_ENABLSMARTHILITE:
2921  				{
2922  					nppGUI._enableSmartHilite = !nppGUI._enableSmartHilite;
2923  					if (!nppGUI._enableSmartHilite)
2924  					{
2925  					}
2926  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE), nppGUI._enableSmartHilite);
2927  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY), nppGUI._enableSmartHilite);
2928  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS), nppGUI._enableSmartHilite);
2929  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_SMARTHILITEANOTHERRVIEW), nppGUI._enableSmartHilite);
2930  					if (NppDarkMode::isEnabled())
2931  					{
2932  						::EnableWindow(::GetDlgItem(_hSelf, IDC_SMARTHILITEMATCHING_STATIC), nppGUI._enableSmartHilite);
2933  						redrawDlgItem(IDC_SMARTHILITEMATCHING_STATIC);
2934  					}
2935  					HWND grandParent = ::GetParent(_hParent);
2936  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2937  					return TRUE;
2938  				}
2939  				case IDC_CHECK_SMARTHILITECASESENSITIVE:
2940  				{
2941  					nppGUI._smartHiliteCaseSensitive = isCheckedOrNot(IDC_CHECK_SMARTHILITECASESENSITIVE);
2942  					if (nppGUI._smartHiliteCaseSensitive)
2943  					{
2944  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, false, 0);
2945  						nppGUI._smartHiliteUseFindSettings = false;
2946  					}
2947  					HWND grandParent = ::GetParent(_hParent);
2948  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2949  					return TRUE;
2950  				}
2951  				case IDC_CHECK_SMARTHILITEWHOLEWORDONLY:
2952  				{
2953  					nppGUI._smartHiliteWordOnly = isCheckedOrNot(IDC_CHECK_SMARTHILITEWHOLEWORDONLY);
2954  					if (nppGUI._smartHiliteWordOnly)
2955  					{
2956  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEUSEFINDSETTINGS, BM_SETCHECK, false, 0);
2957  						nppGUI._smartHiliteUseFindSettings = false;
2958  					}
2959  					HWND grandParent = ::GetParent(_hParent);
2960  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2961  					return TRUE;
2962  				}
2963  				case IDC_CHECK_SMARTHILITEUSEFINDSETTINGS:
2964  				{
2965  					nppGUI._smartHiliteUseFindSettings = isCheckedOrNot(IDC_CHECK_SMARTHILITEUSEFINDSETTINGS);
2966  					if (nppGUI._smartHiliteUseFindSettings)
2967  					{
2968  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITECASESENSITIVE, BM_SETCHECK, false, 0);
2969  						::SendDlgItemMessage(_hSelf, IDC_CHECK_SMARTHILITEWHOLEWORDONLY, BM_SETCHECK, false, 0);
2970  						nppGUI._smartHiliteCaseSensitive = false;
2971  						nppGUI._smartHiliteWordOnly = false;
2972  					}
2973  					HWND grandParent = ::GetParent(_hParent);
2974  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2975  					return TRUE;
2976  				}
2977  				case IDC_CHECK_SMARTHILITEANOTHERRVIEW:
2978  				{
2979  					nppGUI._smartHiliteOnAnotherView = isCheckedOrNot(IDC_CHECK_SMARTHILITEANOTHERRVIEW);
2980  					HWND grandParent = ::GetParent(_hParent);
2981  					::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATOR, 0, 0);
2982  					return TRUE;
2983  				}
2984  				case IDC_CHECK_ENABLTAGSMATCHHILITE:
2985  				{
2986  					nppGUI._enableTagsMatchHilite = !nppGUI._enableTagsMatchHilite;
2987  					if (!nppGUI._enableTagsMatchHilite)
2988  					{
2989  						HWND grandParent = ::GetParent(_hParent);
2990  						::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATORTAGMATCH, 0, 0);
2991  					}
2992  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_ENABLTAGATTRHILITE), nppGUI._enableTagsMatchHilite);
2993  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_HIGHLITENONEHTMLZONE), nppGUI._enableTagsMatchHilite);
2994  					return TRUE;
2995  				}
2996  				case IDC_CHECK_ENABLTAGATTRHILITE:
2997  				{
2998  					nppGUI._enableTagAttrsHilite = !nppGUI._enableTagAttrsHilite;
2999  					if (!nppGUI._enableTagAttrsHilite)
3000  					{
3001  						HWND grandParent = ::GetParent(_hParent);
3002  						::SendMessage(grandParent, NPPM_INTERNAL_CLEARINDICATORTAGATTR, 0, 0);
3003  					}
3004  					return TRUE;
3005  				}
3006  				case IDC_CHECK_HIGHLITENONEHTMLZONE:
3007  				{
3008  					nppGUI._enableHiliteNonHTMLZone = !nppGUI._enableHiliteNonHTMLZone;
3009  					return TRUE;
3010  				}
3011  			}
3012  		}
3013  	}
3014  	return FALSE;
3015  }
3016  intptr_t CALLBACK PrintSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3017  {
3018  	NppParameters& nppParam = NppParameters::getInstance();
3019  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
3020  	switch (message) 
3021  	{
3022  		case WM_INITDIALOG :
3023  		{
3024  			bool printLN = nppGUI._printSettings._printLineNumber;
3025  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PRINTLINENUM, BM_SETCHECK, printLN, 0);
3026  			int ID2Check = 0;
3027  			switch (nppGUI._printSettings._printOption)
3028  			{
3029  				case SC_PRINT_NORMAL :
3030  					ID2Check = IDC_RADIO_WYSIWYG;
3031  					break;
3032  				case SC_PRINT_INVERTLIGHT :
3033  					ID2Check = IDC_RADIO_INVERT;
3034  					break;
3035  				case SC_PRINT_BLACKONWHITE :
3036  					ID2Check = IDC_RADIO_BW;
3037  					break;
3038  				case SC_PRINT_COLOURONWHITE :
3039  					ID2Check = IDC_RADIO_NOBG;
3040  					break;
3041  			}
3042  			::SendDlgItemMessage(_hSelf, ID2Check, BM_SETCHECK, BST_CHECKED, 0);
3043  			::SetDlgItemInt(_hSelf, IDC_EDIT_ML, nppGUI._printSettings._marge.left, FALSE);
3044  			::SetDlgItemInt(_hSelf, IDC_EDIT_MR, nppGUI._printSettings._marge.right, FALSE);
3045  			::SetDlgItemInt(_hSelf, IDC_EDIT_MT, nppGUI._printSettings._marge.top, FALSE);
3046  			::SetDlgItemInt(_hSelf, IDC_EDIT_MB,  nppGUI._printSettings._marge.bottom, FALSE);
3047  			::SetDlgItemText(_hSelf, IDC_EDIT_HLEFT, nppGUI._printSettings._headerLeft.c_str());
3048  			::SetDlgItemText(_hSelf, IDC_EDIT_HMIDDLE, nppGUI._printSettings._headerMiddle.c_str());
3049  			::SetDlgItemText(_hSelf, IDC_EDIT_HRIGHT, nppGUI._printSettings._headerRight.c_str());
3050  			::SetDlgItemText(_hSelf, IDC_EDIT_FLEFT, nppGUI._printSettings._footerLeft.c_str());
3051  			::SetDlgItemText(_hSelf, IDC_EDIT_FMIDDLE, nppGUI._printSettings._footerMiddle.c_str());
3052  			::SetDlgItemText(_hSelf, IDC_EDIT_FRIGHT, nppGUI._printSettings._footerRight.c_str());
3053  			TCHAR intStr[5]{};
3054  			for (int i = 6 ; i < 15 ; ++i)
3055  			{
3056  				wsprintf(intStr, TEXT("%d"), i);
3057  				::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTSIZE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(intStr));
3058  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTSIZE, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(intStr));
3059  			}
3060  			const std::vector<generic_string> & fontlist = nppParam.getFontList();
3061  			for (size_t i = 0, len = fontlist.size() ; i < len ; ++i)
3062  			{
3063  				auto j = ::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3064  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3065  				::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_SETITEMDATA, j, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3066  				::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_SETITEMDATA, j, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
3067  			}
3068  			auto index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(nppGUI._printSettings._headerFontName.c_str()));
3069  			if (index == CB_ERR)
3070  				index = 0;
3071  			::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTNAME, CB_SETCURSEL, index, 0);
3072  			index = ::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(nppGUI._printSettings._footerFontName.c_str()));
3073  			if (index == CB_ERR)
3074  				index = 0;
3075  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTNAME, CB_SETCURSEL, index, 0);
3076  			wsprintf(intStr, TEXT("%d"), nppGUI._printSettings._headerFontSize);
3077  			::SendDlgItemMessage(_hSelf, IDC_COMBO_HFONTSIZE, CB_SELECTSTRING, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(intStr));
3078  			wsprintf(intStr, TEXT("%d"), nppGUI._printSettings._footerFontSize);
3079  			::SendDlgItemMessage(_hSelf, IDC_COMBO_FFONTSIZE, CB_SELECTSTRING, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(intStr));
3080  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HBOLD, BM_SETCHECK, nppGUI._printSettings._headerFontStyle & FONTSTYLE_BOLD, 0);
3081  			::SendDlgItemMessage(_hSelf, IDC_CHECK_HITALIC, BM_SETCHECK, nppGUI._printSettings._headerFontStyle & FONTSTYLE_ITALIC, 0);
3082  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FBOLD, BM_SETCHECK, nppGUI._printSettings._footerFontStyle & FONTSTYLE_BOLD, 0);
3083  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FITALIC, BM_SETCHECK, nppGUI._printSettings._footerFontStyle & FONTSTYLE_ITALIC, 0);
3084  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Full file name path")));
3085  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("File name")));
3086  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("File directory")));
3087  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Page")));
3088  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Short date format")));
3089  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Long date format")));
3090  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Time")));
3091  			varList.push_back(TEXT("$(FULL_CURRENT_PATH)"));
3092  			varList.push_back(TEXT("$(FILE_NAME)"));
3093  			varList.push_back(TEXT("$(CURRENT_DIRECTORY)"));
3094  			varList.push_back(TEXT("$(CURRENT_PRINTING_PAGE)"));
3095  			varList.push_back(TEXT("$(SHORT_DATE)"));
3096  			varList.push_back(TEXT("$(LONG_DATE)"));
3097  			varList.push_back(TEXT("$(TIME)"));
3098  			::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_SETCURSEL, 0, 0);
3099  			return TRUE;
3100  		}
3101  		case WM_CTLCOLOREDIT:
3102  		{
3103  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3104  		}
3105  		case WM_CTLCOLORLISTBOX:
3106  		{
3107  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
3108  		}
3109  		case WM_CTLCOLORDLG:
3110  		{
3111  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3112  		}
3113  		case WM_CTLCOLORSTATIC:
3114  		{
3115  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
3116  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3117  			if (dlgCtrlID == IDC_EDIT_VIEWPANEL)
3118  			{
3119  				return NppDarkMode::onCtlColor(hdcStatic);
3120  			}
3121  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3122  		}
3123  		case WM_PRINTCLIENT:
3124  		{
3125  			if (NppDarkMode::isEnabled())
3126  			{
3127  				return TRUE;
3128  			}
3129  			break;
3130  		}
3131  		case WM_COMMAND:
3132  		{
3133  			if (HIWORD(wParam) == EN_CHANGE && LOWORD(wParam) != IDC_EDIT_VIEWPANEL)
3134  			{
3135  				switch (LOWORD(wParam))
3136  				{
3137  					case  IDC_EDIT_ML:
3138  						nppGUI._printSettings._marge.left = ::GetDlgItemInt(_hSelf, IDC_EDIT_ML, NULL, FALSE);
3139  						return TRUE;
3140  					case  IDC_EDIT_MR:
3141  						nppGUI._printSettings._marge.right = ::GetDlgItemInt(_hSelf, IDC_EDIT_MR, NULL, FALSE);
3142  						return TRUE;
3143  					case IDC_EDIT_MT :
3144  						nppGUI._printSettings._marge.top = ::GetDlgItemInt(_hSelf, IDC_EDIT_MT, NULL, FALSE);
3145  						return TRUE;
3146  					case IDC_EDIT_MB :
3147  						nppGUI._printSettings._marge.bottom = ::GetDlgItemInt(_hSelf, IDC_EDIT_MB, NULL, FALSE);
3148  						return TRUE;
3149  					default:
3150  					{
3151  						constexpr int stringSize = 256;
3152  						TCHAR str[stringSize]{};
3153  						_focusedEditCtrl = LOWORD(wParam);
3154  						::GetDlgItemText(_hSelf, _focusedEditCtrl, str, stringSize);
3155  						::SendDlgItemMessage(_hSelf, IDC_EDIT_VIEWPANEL, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(str));
3156  						switch (LOWORD(wParam))
3157  						{
3158  							case  IDC_EDIT_HLEFT:
3159  								nppGUI._printSettings._headerLeft = str;
3160  								trim(nppGUI._printSettings._headerLeft);
3161  								return TRUE;
3162  							case  IDC_EDIT_HMIDDLE:
3163  								nppGUI._printSettings._headerMiddle = str;
3164  								trim(nppGUI._printSettings._headerMiddle);
3165  								return TRUE;
3166  							case IDC_EDIT_HRIGHT :
3167  								nppGUI._printSettings._headerRight = str;
3168  								trim(nppGUI._printSettings._headerRight);
3169  								return TRUE;
3170  							case  IDC_EDIT_FLEFT:
3171  								nppGUI._printSettings._footerLeft = str;
3172  								trim(nppGUI._printSettings._footerLeft);
3173  								return TRUE;
3174  							case  IDC_EDIT_FMIDDLE:
3175  								nppGUI._printSettings._footerMiddle = str;
3176  								trim(nppGUI._printSettings._footerMiddle);
3177  								return TRUE;
3178  							case IDC_EDIT_FRIGHT :
3179  								nppGUI._printSettings._footerRight = str;
3180  								trim(nppGUI._printSettings._footerRight);
3181  								return TRUE;
3182  							default :
3183  								return FALSE;
3184  						}
3185  					}
3186  				}
3187  			}
3188  			else if (HIWORD(wParam) == EN_SETFOCUS && LOWORD(wParam) != IDC_EDIT_VIEWPANEL)
3189  			{
3190  				constexpr int stringSize = 256;
3191  				TCHAR str[stringSize]{};
3192  				_focusedEditCtrl = LOWORD(wParam);
3193  				int focusedEditStatic = 0;
3194  				int groupStatic = 0;
3195  				switch (_focusedEditCtrl)
3196  				{
3197  					case IDC_EDIT_HLEFT : focusedEditStatic = IDC_HL_STATIC; groupStatic = IDC_HGB_STATIC; break;
3198  					case IDC_EDIT_HMIDDLE : focusedEditStatic = IDC_HM_STATIC; groupStatic = IDC_HGB_STATIC; break;
3199  					case IDC_EDIT_HRIGHT : focusedEditStatic = IDC_HR_STATIC; groupStatic = IDC_HGB_STATIC; break;
3200  					case IDC_EDIT_FLEFT : focusedEditStatic = IDC_FL_STATIC; groupStatic = IDC_FGB_STATIC; break;
3201  					case IDC_EDIT_FMIDDLE : focusedEditStatic = IDC_FM_STATIC; groupStatic = IDC_FGB_STATIC; break;
3202  					case IDC_EDIT_FRIGHT : focusedEditStatic = IDC_FR_STATIC; groupStatic = IDC_FGB_STATIC; break;
3203  					default : return TRUE;
3204  				}
3205  				::GetDlgItemText(_hSelf, _focusedEditCtrl, str, stringSize);
3206  				::SendDlgItemMessage(_hSelf, IDC_EDIT_VIEWPANEL, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(str));
3207  				::GetDlgItemText(_hSelf, groupStatic, str, stringSize);
3208  				generic_string title = str;
3209  				title += TEXT(" ");
3210  				::GetDlgItemText(_hSelf, focusedEditStatic, str, stringSize);
3211  				title += str;
3212  				title = purgeMenuItemString(title.c_str()); 
3213  				::SendDlgItemMessage(_hSelf, IDC_WHICHPART_STATIC, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(title.c_str()));
3214  				redrawDlgItem(IDC_WHICHPART_STATIC);
3215  				return TRUE;
3216  			}
3217  			else if (HIWORD(wParam) == CBN_SELCHANGE)
3218  			{
3219  				auto iSel = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETCURSEL, 0, 0);
3220  				switch (LOWORD(wParam))
3221  				{
3222  					case IDC_COMBO_HFONTNAME :
3223  					case IDC_COMBO_FFONTNAME :
3224  					{
3225  						TCHAR *fnStr = (TCHAR *)::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETITEMDATA, iSel, 0);
3226  						if (LOWORD(wParam) == IDC_COMBO_HFONTNAME)
3227  							nppGUI._printSettings._headerFontName = fnStr;
3228  						else
3229  							nppGUI._printSettings._footerFontName = fnStr;
3230  					}
3231  					break;
3232  					case IDC_COMBO_HFONTSIZE :
3233  					case IDC_COMBO_FFONTSIZE :
3234  					{
3235  						constexpr size_t intStrLen = 3;
3236  						TCHAR intStr[intStrLen]{};
3237  						auto lbTextLen = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETLBTEXTLEN, iSel, 0);
3238  						if (static_cast<size_t>(lbTextLen) >= intStrLen)
3239  							return TRUE;
3240  						::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETLBTEXT, iSel, reinterpret_cast<LPARAM>(intStr));
3241  						int *pVal = (LOWORD(wParam) == IDC_COMBO_HFONTSIZE)?&(nppGUI._printSettings._headerFontSize):&(nppGUI._printSettings._footerFontSize);
3242  						if (!intStr[0])
3243  							*pVal = 0;
3244  						else
3245  							*pVal = wcstol(intStr, NULL, 10);
3246  					}
3247  					break;
3248  					case IDC_COMBO_VARLIST:
3249  					{
3250  						break;
3251  					}
3252  					default:
3253  					{
3254  						break;
3255  					}
3256  				}
3257  				return TRUE;
3258  			}
3259  			switch (wParam)
3260  			{
3261  				case IDC_CHECK_PRINTLINENUM:
3262  					nppGUI._printSettings._printLineNumber = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_CHECK_PRINTLINENUM, BM_GETCHECK, 0, 0));
3263  					break;
3264  				case  IDC_RADIO_WYSIWYG:
3265  					nppGUI._printSettings._printOption = SC_PRINT_NORMAL;
3266  					break;
3267  				case  IDC_RADIO_INVERT:
3268  					nppGUI._printSettings._printOption = SC_PRINT_INVERTLIGHT;
3269  					break;
3270  				case IDC_RADIO_BW :
3271  					nppGUI._printSettings._printOption = SC_PRINT_BLACKONWHITE;
3272  					break;
3273  				case IDC_RADIO_NOBG :
3274  					nppGUI._printSettings._printOption = SC_PRINT_COLOURONWHITE;
3275  					break;
3276  				case IDC_CHECK_HBOLD:
3277  					nppGUI._printSettings._headerFontStyle ^= FONTSTYLE_BOLD;
3278  					break;
3279  				case  IDC_CHECK_HITALIC:
3280  					nppGUI._printSettings._headerFontStyle ^= FONTSTYLE_ITALIC;
3281  					break;
3282  				case  IDC_CHECK_FBOLD:
3283  					nppGUI._printSettings._footerFontStyle ^= FONTSTYLE_BOLD;
3284  					break;
3285  				case  IDC_CHECK_FITALIC:
3286  					nppGUI._printSettings._footerFontStyle ^= FONTSTYLE_ITALIC;
3287  					break;
3288  				case  IDC_BUTTON_ADDVAR:
3289  				{
3290  					try {
3291  						if (!_focusedEditCtrl)
3292  							return TRUE;
3293  						size_t iSel = ::SendDlgItemMessage(_hSelf, IDC_COMBO_VARLIST, CB_GETCURSEL, 0, 0);
3294  						if (iSel >= varList.size())
3295  							return TRUE;
3296  						TCHAR *varStr = (TCHAR*)varList[iSel].c_str();
3297  						size_t selStart = 0;
3298  						size_t selEnd = 0;
3299  						::SendDlgItemMessage(_hSelf, _focusedEditCtrl, EM_GETSEL, reinterpret_cast<WPARAM>(&selStart), reinterpret_cast<LPARAM>(&selEnd));
3300  						constexpr int stringSize = 256;
3301  						TCHAR str[stringSize]{};
3302  						::SendDlgItemMessage(_hSelf, _focusedEditCtrl, WM_GETTEXT, stringSize, reinterpret_cast<LPARAM>(str));
3303  						generic_string str2Set(str);
3304  						size_t strLen = str2Set.length();
3305  						if (selStart > strLen || selEnd > strLen)
3306  							selStart = selEnd = strLen;
3307  						str2Set.replace(selStart, selEnd - selStart, varStr);
3308  						::SetDlgItemText(_hSelf, _focusedEditCtrl, str2Set.c_str());
3309  					}
3310  					catch (...)
3311  					{
3312  					}
3313  				}
3314  				break;
3315  			}
3316  			return TRUE;
3317  		}
3318  	}
3319  	return FALSE;
3320  }
3321  intptr_t CALLBACK BackupSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3322  {
3323  	NppParameters& nppParam = NppParameters::getInstance();
3324  	NppGUI & nppGUI = nppParam.getNppGUI();
3325  	switch (message) 
3326  	{
3327  		case WM_INITDIALOG :
3328  		{
3329  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REMEMBERSESSION, BM_SETCHECK, nppGUI._rememberLastSession, 0);
3330  			bool snapshotCheck = nppGUI._rememberLastSession && nppGUI.isSnapshotMode();
3331  			::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_SETCHECK, snapshotCheck?BST_CHECKED:BST_UNCHECKED, 0);
3332  			auto periodicBackupInSec = static_cast<UINT>(nppGUI._snapshotBackupTiming / 1000);
3333  			::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT,periodicBackupInSec, FALSE);
3334  			generic_string backupFilePath = NppParameters::getInstance().getUserPath();
3335  			backupFilePath += TEXT("\\backup\\");
3336  			::SetDlgItemText(_hSelf, IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT, backupFilePath.c_str());
3337  			int ID2CheckBackupOnSave = 0;
3338  			switch (nppGUI._backup)
3339  			{
3340  				case bak_simple :
3341  					ID2CheckBackupOnSave = IDC_RADIO_BKSIMPLE;
3342  					break;
3343  				case bak_verbose :
3344  					ID2CheckBackupOnSave = IDC_RADIO_BKVERBOSE;
3345  					break;
3346  				default : 
3347  					ID2CheckBackupOnSave = IDC_RADIO_BKNONE;
3348  			}
3349  			::SendDlgItemMessage(_hSelf, ID2CheckBackupOnSave, BM_SETCHECK, BST_CHECKED, 0);
3350  			if (nppGUI._useDir)
3351  				::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_CHECK, BM_SETCHECK, BST_CHECKED, 0);
3352  			::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>((nppGUI._backupDir.c_str())));
3353  			updateBackupSessionGUI();
3354  			updateBackupOnSaveGUI();
3355  			return TRUE;
3356  		}
3357  		case WM_CTLCOLOREDIT:
3358  		{
3359  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3360  		}
3361  		case WM_CTLCOLORDLG:
3362  		{
3363  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3364  		}
3365  		case WM_CTLCOLORSTATIC:
3366  		{
3367  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
3368  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3369  			bool isStaticText = (dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_STATIC1 ||
3370  				dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_STATIC2 ||
3371  				dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_PATHLABEL_STATIC);
3372  			if (isStaticText)
3373  			{
3374  				bool isTextEnabled = isCheckedOrNot(IDC_BACKUPDIR_RESTORESESSION_CHECK);
3375  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3376  			}
3377  			if (dlgCtrlID == IDD_BACKUPDIR_STATIC)
3378  			{
3379  				bool isTextEnabled = !isCheckedOrNot(IDC_RADIO_BKNONE) && isCheckedOrNot(IDC_BACKUPDIR_CHECK);
3380  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3381  			}
3382  			if (dlgCtrlID == IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT)
3383  			{
3384  				return NppDarkMode::onCtlColor(hdcStatic);
3385  			}
3386  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3387  		}
3388  		case WM_PRINTCLIENT:
3389  		{
3390  			if (NppDarkMode::isEnabled())
3391  			{
3392  				return TRUE;
3393  			}
3394  			break;
3395  		}
3396  		case WM_COMMAND : 
3397  		{
3398  			if (HIWORD(wParam) == EN_CHANGE)
3399  			{
3400  				switch (LOWORD(wParam))
3401  				{
3402  					case  IDC_BACKUPDIR_EDIT:
3403  					{
3404  						TCHAR inputDir[MAX_PATH] = {'\0'};
3405  						::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
3406  						nppGUI._backupDir = inputDir;
3407  						return TRUE;
3408  					}
3409  					case IDC_BACKUPDIR_RESTORESESSION_EDIT:
3410  					{
3411  						constexpr int stringSize = 16;
3412  						TCHAR str[stringSize]{};
3413  						::GetDlgItemText(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, str, stringSize);
3414  						if (lstrcmp(str, TEXT("")) == 0)
3415  							return TRUE;
3416  						nppGUI._snapshotBackupTiming = ::GetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, NULL, FALSE) * 1000;
3417  						if (!nppGUI._snapshotBackupTiming)
3418  						{
3419  							nppGUI._snapshotBackupTiming = 1000;
3420  							::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, 1, FALSE);
3421  						}
3422  						return TRUE;
3423  					}
3424  				}
3425  			}
3426  			else if (HIWORD(wParam) == EN_KILLFOCUS)
3427  			{
3428  				switch (LOWORD(wParam))
3429  				{
3430  					case  IDC_BACKUPDIR_RESTORESESSION_EDIT:
3431  					{
3432  						constexpr int stringSize = 16;
3433  						TCHAR str[stringSize]{};
3434  						::GetDlgItemText(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, str, stringSize);
3435  						if (lstrcmp(str, TEXT("")) == 0)
3436  						{
3437  							::SetDlgItemInt(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT, static_cast<int32_t>(nppGUI._snapshotBackupTiming / 1000), FALSE);
3438  						}
3439  					}
3440  				}
3441  			}
3442  			switch (wParam)
3443  			{
3444  				case IDC_CHECK_REMEMBERSESSION:
3445  				{
3446  					nppGUI._rememberLastSession = isCheckedOrNot(IDC_CHECK_REMEMBERSESSION);
3447  					if (!nppGUI._rememberLastSession)
3448  					{
3449  						::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3450  						::SendMessage(_hSelf, WM_COMMAND, IDC_BACKUPDIR_RESTORESESSION_CHECK, 0);
3451  					}
3452  					updateBackupSessionGUI();
3453  					return TRUE;
3454  				}
3455  				case IDC_BACKUPDIR_RESTORESESSION_CHECK:
3456  				{
3457  					nppGUI._isSnapshotMode = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK, BM_GETCHECK, 0, 0);
3458  					updateBackupSessionGUI();
3459  					if (nppGUI._isSnapshotMode)
3460  					{
3461  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_ENABLESNAPSHOT, 0, 0);
3462  					}
3463  					return TRUE;
3464  				}
3465  				case IDC_RADIO_BKSIMPLE:
3466  				{
3467  					nppGUI._backup = bak_simple;
3468  					updateBackupOnSaveGUI();
3469  					return TRUE;
3470  				}
3471  				case IDC_RADIO_BKVERBOSE:
3472  				{
3473  					nppGUI._backup = bak_verbose;
3474  					updateBackupOnSaveGUI();
3475  					return TRUE;
3476  				}
3477  				case IDC_RADIO_BKNONE:
3478  				{
3479  					nppGUI._backup = bak_none;
3480  					updateBackupOnSaveGUI();
3481  					return TRUE;
3482  				}
3483  				case IDC_BACKUPDIR_CHECK:
3484  				{
3485  					nppGUI._useDir = !nppGUI._useDir;
3486  					updateBackupOnSaveGUI();
3487  					return TRUE;
3488  				}
3489  				case IDD_BACKUPDIR_BROWSE_BUTTON :
3490  				{
3491  					generic_string title = nppParam.getNativeLangSpeaker()->getLocalizedStrFromID("backup-select-folder",
3492  						TEXT("Select a folder as backup directory"));
3493  					folderBrowser(_hSelf, title, IDC_BACKUPDIR_EDIT);
3494  					return TRUE;
3495  				}
3496  				default :
3497  					return FALSE;
3498  			}
3499  		}
3500  	}
3501  	return FALSE;
3502  }
3503  void BackupSubDlg::updateBackupSessionGUI()
3504  {
3505  	bool rememberSession = isCheckedOrNot(IDC_CHECK_REMEMBERSESSION);
3506  	bool isSnapshot = isCheckedOrNot(IDC_BACKUPDIR_RESTORESESSION_CHECK);
3507  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_RESTORESESSION_CHECK), rememberSession);
3508  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_RESTORESESSION_EDIT), isSnapshot);
3509  	::EnableWindow(::GetDlgItem(_hSelf, IDD_BACKUPDIR_RESTORESESSION_PATH_EDIT), isSnapshot);
3510  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_STATIC1);
3511  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_STATIC2);
3512  	redrawDlgItem(IDD_BACKUPDIR_RESTORESESSION_PATHLABEL_STATIC);
3513  }
3514  void BackupSubDlg::updateBackupOnSaveGUI()
3515  {
3516  	bool noBackup = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_RADIO_BKNONE, BM_GETCHECK, 0, 0);
3517  	bool isEnableGlobableCheck = false;
3518  	bool isEnableLocalCheck = false;
3519  	if (!noBackup)
3520  	{
3521  		isEnableGlobableCheck = true;
3522  		isEnableLocalCheck = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_BACKUPDIR_CHECK, BM_GETCHECK, 0, 0);
3523  	}
3524  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_CHECK), isEnableGlobableCheck);
3525  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_EDIT), isEnableLocalCheck);
3526  	::EnableWindow(::GetDlgItem(_hSelf, IDD_BACKUPDIR_BROWSE_BUTTON), isEnableLocalCheck);
3527  	if (NppDarkMode::isEnabled())
3528  	{
3529  		::EnableWindow(::GetDlgItem(_hSelf, IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC), !noBackup);
3530  		redrawDlgItem(IDC_BACKUPDIR_USERCUSTOMDIR_GRPSTATIC);
3531  	}
3532  }
3533  intptr_t CALLBACK AutoCompletionSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
3534  {
3535  	NppParameters& nppParam = NppParameters::getInstance();
3536  	NppGUI & nppGUI = nppParam.getNppGUI();
3537  	switch (message) 
3538  	{
3539  		case WM_INITDIALOG :
3540  		{
3541  			::SetDlgItemInt(_hSelf, IDD_AUTOC_STATIC_N,  nppGUI._autocFromLen, FALSE);
3542  			const HWND hNbCharSlider = ::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER);
3543  			::SendMessage(hNbCharSlider, TBM_SETRANGEMIN, TRUE, AUTOCOMPLETEFROMCHAR_SMALLEST);
3544  			::SendMessage(hNbCharSlider, TBM_SETRANGEMAX, TRUE, AUTOCOMPLETEFROMCHAR_LARGEST);
3545  			::SendMessage(hNbCharSlider, TBM_SETPAGESIZE, 0, AUTOCOMPLETEFROMCHAR_INTERVAL);
3546  			::SendMessage(hNbCharSlider, TBM_SETPOS, TRUE, nppGUI._autocFromLen);
3547  			bool isEnableAutoC = nppGUI._autocStatus != nppGUI.autoc_none;
3548  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_ENABLECHECK, BM_SETCHECK, isEnableAutoC?BST_CHECKED:BST_UNCHECKED, 0);
3549  			int selectedID = IDD_AUTOC_BOTHRADIO;
3550  			if (nppGUI._autocStatus == nppGUI.autoc_func)
3551  				selectedID = IDD_AUTOC_FUNCRADIO;
3552  			else if (nppGUI._autocStatus == nppGUI.autoc_word)
3553  				selectedID = IDD_AUTOC_WORDRADIO;
3554  			else if (nppGUI._autocStatus == nppGUI.autoc_both)
3555  				selectedID = IDD_AUTOC_BOTHRADIO;
3556  			::SendDlgItemMessage(_hSelf, selectedID, BM_SETCHECK, BST_CHECKED, 0);
3557  			if (nppGUI._autocStatus == nppGUI.autoc_word || nppGUI._autocStatus == nppGUI.autoc_both)
3558  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, nppGUI._autocIgnoreNumbers ? BST_CHECKED : BST_UNCHECKED, 0);
3559  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_USEENTER, BM_SETCHECK, nppGUI._autocInsertSelectedUseENTER ? BST_CHECKED : BST_UNCHECKED, 0);
3560  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_USETAB, BM_SETCHECK, nppGUI._autocInsertSelectedUseTAB ? BST_CHECKED : BST_UNCHECKED, 0);
3561  			if (!isEnableAutoC)
3562  			{
3563  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_FUNCRADIO), FALSE);
3564  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_WORDRADIO), FALSE);
3565  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BRIEF_CHECK), FALSE);
3566  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BOTHRADIO), FALSE);
3567  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEENTER), FALSE);
3568  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USETAB), FALSE);
3569  				::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), FALSE);
3570  				::EnableWindow(::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER), FALSE);
3571  				if (NppDarkMode::isEnabled())
3572  				{
3573  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), FALSE);
3574  				}
3575  			}
3576  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MAINTAININDENT, BM_SETCHECK, nppGUI._maitainIndent, 0);
3577  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, nppGUI._autocBrief ? BST_CHECKED : BST_UNCHECKED, 0);
3578  			::SendDlgItemMessage(_hSelf, IDD_FUNC_CHECK, BM_SETCHECK, nppGUI._funcParams ? BST_CHECKED : BST_UNCHECKED, 0);
3579  			::SendDlgItemMessage(_hSelf, IDD_AUTOCPARENTHESES_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doParentheses?BST_CHECKED:BST_UNCHECKED, 0);
3580  			if (nppGUI._matchedPairConf._doParentheses)
3581  				::SendDlgItemMessage(_hSelf, IDD_AUTOCPARENTHESES_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" (  )")));
3582  			::SendDlgItemMessage(_hSelf, IDD_AUTOCBRACKET_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doBrackets?BST_CHECKED:BST_UNCHECKED, 0);
3583  			if (nppGUI._matchedPairConf._doBrackets)
3584  				::SendDlgItemMessage(_hSelf, IDD_AUTOCBRACKET_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" [  ]")));
3585  			::SendDlgItemMessage(_hSelf, IDD_AUTOCCURLYBRACKET_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doCurlyBrackets?BST_CHECKED:BST_UNCHECKED, 0);
3586  			if (nppGUI._matchedPairConf._doCurlyBrackets)
3587  				::SendDlgItemMessage(_hSelf, IDD_AUTOCCURLYBRACKET_CHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" {  }")));
3588  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_QUOTESCHECK, BM_SETCHECK, nppGUI._matchedPairConf._doQuotes?BST_CHECKED:BST_UNCHECKED, 0);
3589  			if (nppGUI._matchedPairConf._doQuotes)
3590  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_QUOTESCHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" '  '")));
3591  			::SendDlgItemMessage(_hSelf, IDD_AUTOC_DOUBLEQUOTESCHECK, BM_SETCHECK, nppGUI._matchedPairConf._doDoubleQuotes?BST_CHECKED:BST_UNCHECKED, 0);
3592  			if (nppGUI._matchedPairConf._doDoubleQuotes)
3593  				::SendDlgItemMessage(_hSelf, IDD_AUTOC_DOUBLEQUOTESCHECK, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT(" \"  \"")));
3594  			::SendDlgItemMessage(_hSelf, IDD_AUTOCTAG_CHECK, BM_SETCHECK, nppGUI._matchedPairConf._doHtmlXmlTag?BST_CHECKED:BST_UNCHECKED, 0);
3595  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, EM_LIMITTEXT, 1, 0);
3596  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, EM_LIMITTEXT, 1, 0);
3597  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, EM_LIMITTEXT, 1, 0);
3598  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, EM_LIMITTEXT, 1, 0);
3599  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, EM_LIMITTEXT, 1, 0);
3600  			::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, EM_LIMITTEXT, 1, 0);
3601  			size_t nbMatchedPair = nppGUI._matchedPairConf._matchedPairsInit.size();
3602  			if (nbMatchedPair > 3)
3603  				nbMatchedPair = 3;
3604  			for (size_t i = 0; i < nbMatchedPair; ++i)
3605  			{
3606  				TCHAR openChar[2]{};
3607  				openChar[0] = nppGUI._matchedPairConf._matchedPairsInit[i].first;
3608  				openChar[1] = '\0';
3609  				TCHAR closeChar[2]{};
3610  				closeChar[0] = nppGUI._matchedPairConf._matchedPairsInit[i].second;
3611  				closeChar[1] = '\0';
3612  				if (i == 0)
3613  				{
3614  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3615  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3616  				}
3617  				else if (i == 1)
3618  				{
3619  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3620  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3621  				}
3622  				if (i == 2)
3623  				{
3624  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(openChar));
3625  					::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closeChar));
3626  				}
3627  			}
3628  			return TRUE;
3629  		}
3630  		case WM_CTLCOLOREDIT:
3631  		{
3632  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3633  		}
3634  		case WM_CTLCOLORDLG:
3635  		{
3636  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3637  		}
3638  		case WM_CTLCOLORSTATIC:
3639  		{
3640  			const auto hdcStatic = reinterpret_cast<HDC>(wParam);
3641  			const auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
3642  			const bool isStaticText = (dlgCtrlID == IDD_AUTOC_STATIC_FROM ||
3643  				dlgCtrlID == IDD_AUTOC_STATIC_CHAR ||
3644  				dlgCtrlID == IDD_AUTOC_STATIC_N ||
3645  				dlgCtrlID == IDD_AUTOC_SLIDER_MIN_STATIC ||
3646  				dlgCtrlID == IDD_AUTOC_SLIDER_MAX_STATIC);
3647  			if (isStaticText)
3648  			{
3649  				const bool isTextEnabled = isCheckedOrNot(IDD_AUTOC_ENABLECHECK);
3650  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
3651  			}
3652  			return NppDarkMode::onCtlColorDarker(hdcStatic);
3653  		}
3654  		case WM_PRINTCLIENT:
3655  		{
3656  			if (NppDarkMode::isEnabled())
3657  			{
3658  				return TRUE;
3659  			}
3660  			break;
3661  		}
3662  		case WM_HSCROLL:
3663  		{
3664  			const HWND hNbCharSlider = ::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER);
3665  			if (hNbCharSlider == reinterpret_cast<HWND>(lParam))
3666  			{
3667  				nppGUI._autocFromLen = static_cast<UINT>(::SendMessage(hNbCharSlider, TBM_GETPOS, 0, 0));
3668  				::SetDlgItemInt(_hSelf, IDD_AUTOC_STATIC_N, nppGUI._autocFromLen, FALSE);
3669  			}
3670  			return 0; 
3671  		}
3672  		case WM_COMMAND : 
3673  		{
3674  			if (HIWORD(wParam) == EN_CHANGE)
3675  			{
3676  				switch (LOWORD(wParam))
3677  				{
3678  					case IDC_MACHEDPAIROPEN_EDIT1 :
3679  					case IDC_MACHEDPAIRCLOSE_EDIT1:
3680  					case IDC_MACHEDPAIROPEN_EDIT2 :
3681  					case IDC_MACHEDPAIRCLOSE_EDIT2:
3682  					case IDC_MACHEDPAIROPEN_EDIT3 :
3683  					case IDC_MACHEDPAIRCLOSE_EDIT3:
3684  					{
3685  						nppGUI._matchedPairConf._matchedPairs.clear();
3686  						TCHAR opener[2] = {'\0', '\0'};
3687  						TCHAR closer[2] = {'\0', '\0'};
3688  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT1, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3689  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT1, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3690  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3691  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3692  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT2, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3693  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT2, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3694  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3695  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3696  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIROPEN_EDIT3, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
3697  						::SendDlgItemMessage(_hSelf, IDC_MACHEDPAIRCLOSE_EDIT3, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
3698  						if (opener[0] < 0x80 && opener[0] != '\0' && closer[0] < 0x80 && closer[0] != '\0')
3699  							nppGUI._matchedPairConf._matchedPairs.push_back(pair<char, char>(static_cast<char>(opener[0]), static_cast<char>(closer[0])));
3700  						return TRUE;
3701  					}
3702  				}
3703  			}
3704  			switch (wParam)
3705  			{
3706  				case IDC_CHECK_MAINTAININDENT:
3707  				{
3708  					nppGUI._maitainIndent = isCheckedOrNot(IDC_CHECK_MAINTAININDENT);
3709  					return TRUE;
3710  				}
3711  				case IDD_AUTOC_ENABLECHECK :
3712  				{
3713  					bool isEnableAutoC = BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_AUTOC_ENABLECHECK, BM_GETCHECK, 0, 0);
3714  					if (isEnableAutoC)
3715  					{
3716  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BOTHRADIO, BM_SETCHECK, BST_CHECKED, 0);
3717  						nppGUI._autocStatus = nppGUI.autoc_both;
3718  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3719  						nppGUI._autocIgnoreNumbers = false;
3720  					}
3721  					else 
3722  					{
3723  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_FUNCRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3724  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_WORDRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3725  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BOTHRADIO, BM_SETCHECK, BST_UNCHECKED, 0);
3726  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3727  						nppGUI._autocBrief = false;
3728  						nppGUI._autocStatus = nppGUI.autoc_none;
3729  						::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3730  						nppGUI._autocIgnoreNumbers = false;
3731  					}
3732  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_FUNCRADIO), isEnableAutoC);
3733  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_WORDRADIO), isEnableAutoC);
3734  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BOTHRADIO), isEnableAutoC);
3735  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_BRIEF_CHECK), isEnableAutoC);
3736  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
3737  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEENTER), isEnableAutoC);
3738  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USETAB), isEnableAutoC);
3739  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), isEnableAutoC);
3740  					::EnableWindow(::GetDlgItem(_hSelf, IDC_AUTOC_CHAR_SLIDER), isEnableAutoC);
3741  					redrawDlgItem(IDD_AUTOC_STATIC_FROM);
3742  					redrawDlgItem(IDD_AUTOC_STATIC_N);
3743  					redrawDlgItem(IDD_AUTOC_STATIC_CHAR);
3744  					redrawDlgItem(IDD_AUTOC_SLIDER_MIN_STATIC);
3745  					redrawDlgItem(IDD_AUTOC_SLIDER_MAX_STATIC);
3746  					if (NppDarkMode::isEnabled())
3747  					{
3748  						::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_USEKEY_GRP_STATIC), isEnableAutoC);
3749  						redrawDlgItem(IDD_AUTOC_USEKEY_GRP_STATIC);
3750  					}
3751  					return TRUE;
3752  				}
3753  				case IDD_AUTOC_FUNCRADIO :
3754  				{
3755  					nppGUI._autocStatus = nppGUI.autoc_func;
3756  					::SendDlgItemMessage(_hSelf, IDD_AUTOC_IGNORENUMBERS, BM_SETCHECK, BST_UNCHECKED, 0);
3757  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), FALSE);
3758  					nppGUI._autocIgnoreNumbers = false;
3759  					::SendDlgItemMessage(_hSelf, IDD_AUTOC_BRIEF_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
3760  					nppGUI._autocBrief = false;
3761  					return TRUE;
3762  				}
3763  				case IDD_AUTOC_WORDRADIO :
3764  				{
3765  					nppGUI._autocStatus = nppGUI.autoc_word;
3766  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), TRUE);
3767  					return TRUE;
3768  				}
3769  				case IDD_AUTOC_BOTHRADIO :
3770  				{
3771  					nppGUI._autocStatus = nppGUI.autoc_both;
3772  					::EnableWindow(::GetDlgItem(_hSelf, IDD_AUTOC_IGNORENUMBERS), TRUE);
3773  					return TRUE;
3774  				}
3775  				case IDD_AUTOC_USEENTER:
3776  				{
3777  					nppGUI._autocInsertSelectedUseENTER = isCheckedOrNot(static_cast<int32_t>(wParam));
3778  					return TRUE;
3779  				}
3780  				case IDD_AUTOC_USETAB:
3781  				{
3782  					nppGUI._autocInsertSelectedUseTAB = isCheckedOrNot(static_cast<int32_t>(wParam));
3783  					return TRUE;
3784  				}
3785  				case IDD_AUTOC_IGNORENUMBERS:
3786  				{
3787  					nppGUI._autocIgnoreNumbers = isCheckedOrNot(static_cast<int32_t>(wParam));
3788  					return TRUE;
3789  				}
3790  				case IDD_AUTOC_BRIEF_CHECK :
3791  				{
3792  					nppGUI._autocBrief = isCheckedOrNot(static_cast<int32_t>(wParam));
3793  					return TRUE;
3794  				}
3795  				case IDD_FUNC_CHECK :
3796  				{
3797  					nppGUI._funcParams = isCheckedOrNot(static_cast<int32_t>(wParam));
3798  					return TRUE;
3799  				}
3800  				case IDD_AUTOCPARENTHESES_CHECK :
3801  				case IDD_AUTOCBRACKET_CHECK :
3802  				case IDD_AUTOCCURLYBRACKET_CHECK :
3803  				case IDD_AUTOC_DOUBLEQUOTESCHECK :
3804  				case IDD_AUTOC_QUOTESCHECK :
3805  				{
3806  					bool isChecked = isCheckedOrNot(static_cast<int32_t>(wParam));
3807  					const TCHAR *label = nullptr;
3808  					if (wParam == IDD_AUTOCPARENTHESES_CHECK)
3809  					{
3810  						nppGUI._matchedPairConf._doParentheses = isChecked;
3811  						label = isChecked?TEXT(" (  )"):TEXT(" (");
3812  					}
3813  					else if (wParam == IDD_AUTOCBRACKET_CHECK)
3814  					{
3815  						nppGUI._matchedPairConf._doBrackets = isChecked;
3816  						label = isChecked?TEXT(" [  ]"):TEXT(" [");
3817  					}
3818  					else if (wParam == IDD_AUTOCCURLYBRACKET_CHECK)
3819  					{
3820  						nppGUI._matchedPairConf._doCurlyBrackets = isChecked;
3821  						label = isChecked?TEXT(" {  }"):TEXT(" {");
3822  					}
3823  					else if (wParam == IDD_AUTOC_DOUBLEQUOTESCHECK)
3824  					{
3825  						nppGUI._matchedPairConf._doDoubleQuotes = isChecked;
3826  						label = isChecked?TEXT(" \"  \""):TEXT(" \"");
3827  					}
3828  					else 
3829  					{
3830  						nppGUI._matchedPairConf._doQuotes = isChecked;
3831  						label = isChecked?TEXT(" '  '"):TEXT(" '");
3832  					}
3833  					::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), WM_SETTEXT, 0, reinterpret_cast<LPARAM>(label));
3834  					return TRUE;
3835  				}
3836  				case IDD_AUTOCTAG_CHECK :
3837  				{
3838  					nppGUI._matchedPairConf._doHtmlXmlTag = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_AUTOCTAG_CHECK, BM_GETCHECK, 0, 0));
3839  					return TRUE;
3840  				}
3841  				default :
3842  					return FALSE;
3843  			}
3844  		}
3845  	}
3846  	return FALSE;
3847  }
3848  intptr_t CALLBACK MultiInstanceSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
3849  {
3850  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3851  	switch (message) 
3852  	{
3853  		case WM_INITDIALOG :
3854  		{
3855  			auto checkOrUncheckBtn = [this](int id, bool check) -> void
3856  			{
3857  				::SendDlgItemMessage(_hSelf, id, BM_SETCHECK, check ? BST_CHECKED : BST_UNCHECKED, 0);
3858  			};
3859  			checkOrUncheckBtn(IDC_CHECK_CLIPBOARDHISTORY, nppGUI._clipboardHistoryPanelKeepState);
3860  			checkOrUncheckBtn(IDC_CHECK_DOCLIST, nppGUI._docListKeepState);
3861  			checkOrUncheckBtn(IDC_CHECK_CHARPANEL, nppGUI._charPanelKeepState);
3862  			checkOrUncheckBtn(IDC_CHECK_FILEBROWSER, nppGUI._fileBrowserKeepState);
3863  			checkOrUncheckBtn(IDC_CHECK_PROJECTPANEL, nppGUI._projectPanelKeepState);
3864  			checkOrUncheckBtn(IDC_CHECK_DOCMAP, nppGUI._docMapKeepState);
3865  			checkOrUncheckBtn(IDC_CHECK_FUNCLIST, nppGUI._funcListKeepState);
3866  			checkOrUncheckBtn(IDC_CHECK_PLUGINPANEL, nppGUI._pluginPanelKeepState);
3867  			MultiInstSetting multiInstSetting = nppGUI._multiInstSetting;
3868  			::SendDlgItemMessage(_hSelf, IDC_SESSIONININST_RADIO, BM_SETCHECK, multiInstSetting == multiInstOnSession?BST_CHECKED:BST_UNCHECKED, 0);
3869  			::SendDlgItemMessage(_hSelf, IDC_MULTIINST_RADIO, BM_SETCHECK, multiInstSetting == multiInst?BST_CHECKED:BST_UNCHECKED, 0);
3870  			::SendDlgItemMessage(_hSelf, IDC_MONOINST_RADIO, BM_SETCHECK, multiInstSetting == monoInst?BST_CHECKED:BST_UNCHECKED, 0);
3871  			::SendDlgItemMessage(_hSelf, IDD_DATETIMEFORMAT_REVERSEORDER_CHECK, BM_SETCHECK, nppGUI._dateTimeReverseDefaultOrder ? BST_CHECKED : BST_UNCHECKED, 0);
3872  			::SetDlgItemText(_hSelf, IDC_DATETIMEFORMAT_EDIT, nppGUI._dateTimeFormat.c_str());
3873  			generic_string datetimeStr = getDateTimeStrFrom(nppGUI._dateTimeFormat, _BTTF_time);
3874  			::SetDlgItemText(_hSelf, IDD_DATETIMEFORMAT_RESULT_STATIC, datetimeStr.c_str());
3875  			return TRUE;
3876  		}
3877  		case WM_CTLCOLOREDIT:
3878  		{
3879  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
3880  		}
3881  		case WM_CTLCOLORDLG:
3882  		case WM_CTLCOLORSTATIC:
3883  		{
3884  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
3885  		}
3886  		case WM_PRINTCLIENT:
3887  		{
3888  			if (NppDarkMode::isEnabled())
3889  			{
3890  				return TRUE;
3891  			}
3892  			break;
3893  		}
3894  		case WM_COMMAND : 
3895  		{
3896  			if (HIWORD(wParam) == EN_CHANGE && LOWORD(wParam) == IDC_DATETIMEFORMAT_EDIT)
3897  			{
3898  				constexpr size_t inputLen = 256;
3899  				TCHAR input[inputLen]{};
3900  				::GetDlgItemText(_hSelf, IDC_DATETIMEFORMAT_EDIT, input, inputLen);
3901  				nppGUI._dateTimeFormat = input;
3902  				generic_string datetimeStr = getDateTimeStrFrom(nppGUI._dateTimeFormat, _BTTF_time);
3903  				::SetDlgItemText(_hSelf, IDD_DATETIMEFORMAT_RESULT_STATIC, datetimeStr.c_str());
3904  				return TRUE;
3905  			}
3906  			switch (wParam)
3907  			{
3908  				case IDC_SESSIONININST_RADIO :
3909  				{
3910  					nppGUI._multiInstSetting = multiInstOnSession;
3911  				}
3912  				break;
3913  				case IDC_MULTIINST_RADIO :
3914  				{
3915  					nppGUI._multiInstSetting = multiInst;
3916  				}
3917  				break;
3918  				case IDC_MONOINST_RADIO :
3919  				{
3920  					nppGUI._multiInstSetting = monoInst;
3921  				}
3922  				break;
3923  				case IDD_DATETIMEFORMAT_REVERSEORDER_CHECK:
3924  				{
3925  					nppGUI._dateTimeReverseDefaultOrder = isCheckedOrNot(IDD_DATETIMEFORMAT_REVERSEORDER_CHECK);
3926  				}
3927  				break;
3928  				case IDC_CHECK_CLIPBOARDHISTORY:
3929  				{
3930  					nppGUI._clipboardHistoryPanelKeepState = isCheckedOrNot(IDC_CHECK_CLIPBOARDHISTORY);
3931  				}
3932  				break;
3933  				case IDC_CHECK_DOCLIST:
3934  				{
3935  					nppGUI._docListKeepState = isCheckedOrNot(IDC_CHECK_DOCLIST);
3936  				}
3937  				break;
3938  				case IDC_CHECK_CHARPANEL:
3939  				{
3940  					nppGUI._charPanelKeepState = isCheckedOrNot(IDC_CHECK_CHARPANEL);
3941  				}
3942  				break;
3943  				case IDC_CHECK_FILEBROWSER:
3944  				{
3945  					nppGUI._fileBrowserKeepState = isCheckedOrNot(IDC_CHECK_FILEBROWSER);
3946  				}
3947  				break;
3948  				case IDC_CHECK_PROJECTPANEL:
3949  				{
3950  					nppGUI._projectPanelKeepState = isCheckedOrNot(IDC_CHECK_PROJECTPANEL);
3951  				}
3952  				break;
3953  				case IDC_CHECK_DOCMAP:
3954  				{
3955  					nppGUI._docMapKeepState = isCheckedOrNot(IDC_CHECK_DOCMAP);
3956  				}
3957  				break;
3958  				case IDC_CHECK_FUNCLIST:
3959  				{
3960  					nppGUI._funcListKeepState = isCheckedOrNot(IDC_CHECK_FUNCLIST);
3961  				}
3962  				break;
3963  				case IDC_CHECK_PLUGINPANEL:
3964  				{
3965  					nppGUI._pluginPanelKeepState = isCheckedOrNot(IDC_CHECK_PLUGINPANEL);
3966  				}
3967  				break;
3968  				default :
3969  					return FALSE;
3970  			}
3971  		}
3972  		break;
3973  	}
3974  	return FALSE;
3975  }
3976  void DelimiterSubDlg::detectSpace(const char *text2Check, int & nbSp, int & nbTab) const
3977  {
3978  	nbSp = nbTab = 0;
3979  	for (size_t i = 0; i < strlen(text2Check); ++i)
3980  	{
3981  		if (text2Check[i] == ' ')
3982  			++nbSp;
3983  		else if (text2Check[i] == '\t')
3984  			++nbTab;
3985  	}
3986  }
3987  generic_string DelimiterSubDlg::getWarningText(size_t nbSp, size_t nbTab) const
3988  {
3989  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
3990  	generic_string msg;
3991  	if (nbSp && nbTab)
3992  	{
3993  		generic_string nbSpStr = std::to_wstring(nbSp);
3994  		generic_string nbTabStr = std::to_wstring(nbTab);
3995  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
3996  		generic_string space = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-space-warning", TEXT(""));
3997  		generic_string tab = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tab-warning", TEXT(""));
3998  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
3999  		if (!warnBegin.empty() && !space.empty() && !tab.empty() && !warnEnd.empty())
4000  		{
4001  			space = stringReplace(space, TEXT("$INT_REPLACE$"), nbSpStr);
4002  			tab = stringReplace(tab, TEXT("$INT_REPLACE$"), nbTabStr);
4003  			msg = warnBegin;
4004  			msg += space;
4005  			msg += TEXT(" && ");
4006  			msg += tab;
4007  			msg += warnEnd;
4008  		}
4009  		else
4010  		{
4011  			msg = TEXT("Be aware: ");
4012  			msg += nbSpStr;
4013  			msg += TEXT(" space(s) && ");
4014  			msg += std::to_wstring(nbTab);
4015  			msg += TEXT(" TAB(s) in your character list.");
4016  		}
4017  	}
4018  	else if (nbSp && !nbTab)
4019  	{
4020  		generic_string nbSpStr = std::to_wstring(nbSp);
4021  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
4022  		generic_string space = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-space-warning", TEXT(""));
4023  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
4024  		if (!warnBegin.empty() && !space.empty() && !warnEnd.empty())
4025  		{
4026  			space = stringReplace(space, TEXT("$INT_REPLACE$"), nbSpStr);
4027  			msg = warnBegin;
4028  			msg += space;
4029  			msg += warnEnd;
4030  		}
4031  		else
4032  		{
4033  			msg = TEXT("Be aware: ");
4034  			msg += std::to_wstring(nbSp);
4035  			msg += TEXT(" space(s) in your character list.");
4036  		}
4037  	}
4038  	else if (!nbSp && nbTab)
4039  	{
4040  		generic_string nbTabStr = std::to_wstring(nbTab);
4041  		generic_string warnBegin = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-begin", TEXT(""));
4042  		generic_string tab = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tab-warning", TEXT(""));
4043  		generic_string warnEnd = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-warning-end", TEXT(""));
4044  		if (!warnBegin.empty() && !tab.empty() && !warnEnd.empty())
4045  		{
4046  			tab = stringReplace(tab, TEXT("$INT_REPLACE$"), nbTabStr);
4047  			msg = warnBegin;
4048  			msg += tab;
4049  			msg += warnEnd;
4050  		}
4051  		else
4052  		{
4053  			msg = TEXT("Be aware: ");
4054  			msg += std::to_wstring(nbTab);
4055  			msg += TEXT(" TAB(s) in your character list.");
4056  		}
4057  	}
4058  	else 
4059  	{
4060  	}
4061  	return msg;
4062  }
4063  void DelimiterSubDlg::setWarningIfNeed() const
4064  {
4065  	generic_string msg;
4066  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4067  	if (!nppGUI._isWordCharDefault)
4068  	{
4069  		int nbSp = 0;
4070  		int nbTab = 0;
4071  		detectSpace(nppGUI._customWordChars.c_str(), nbSp, nbTab);
4072  		msg = getWarningText(nbSp, nbTab);
4073  	}
4074  	::SetDlgItemText(_hSelf, IDD_STATIC_WORDCHAR_WARNING, msg.c_str());
4075  }
4076  intptr_t CALLBACK DelimiterSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
4077  {
4078  	NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
4079  	switch (message) 
4080  	{
4081  		case WM_INITDIALOG :
4082  		{
4083  			TCHAR opener[2]{};
4084  			opener[0] = nppGUI._leftmostDelimiter;
4085  			opener[1] = '\0';
4086  			TCHAR closer[2]{};
4087  			closer[0] = nppGUI._rightmostDelimiter;
4088  			closer[1] = '\0';
4089  			bool onSeveralLines = nppGUI._delimiterSelectionOnEntireDocument;
4090  			::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, EM_LIMITTEXT, 1, 0);
4091  			::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, EM_LIMITTEXT, 1, 0);
4092  			::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(opener));
4093  			::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(closer));
4094  			::SendDlgItemMessage(_hSelf, IDD_SEVERALLINEMODEON_CHECK, BM_SETCHECK, onSeveralLines?BST_CHECKED:BST_UNCHECKED, 0);
4095  			POINT point = getTopPoint(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA), false);
4096  			_singleLineModePoint.x = point.x + 4;
4097  			_singleLineModePoint.y = point.y - 4;
4098  			point = getTopPoint(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE), false);
4099  			_multiLineModePoint.x = point.x + 4;
4100  			_multiLineModePoint.y = point.y - 4;
4101  			::GetClientRect(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), &_closerRect);
4102  			_closerRect.right = _closerRect.right - _closerRect.left + 4;
4103  			_closerRect.bottom = _closerRect.bottom - _closerRect.top + 4;
4104  			::GetClientRect(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), &_closerLabelRect);
4105  			_closerLabelRect.right = _closerLabelRect.right - _closerLabelRect.left + 4;
4106  			_closerLabelRect.bottom = _closerLabelRect.bottom - _closerLabelRect.top + 4;
4107  			::ShowWindow(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE),onSeveralLines?SW_SHOW:SW_HIDE);
4108  			POINT *p = onSeveralLines?&_multiLineModePoint:&_singleLineModePoint;
4109  			::MoveWindow(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), p->x, p->y, _closerRect.right, _closerRect.bottom, TRUE);
4110  			::MoveWindow(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), p->x + _closerRect.right + 4, p->y + 4, _closerLabelRect.right, _closerLabelRect.bottom, TRUE);
4111  			::SetDlgItemTextA(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT, nppGUI._customWordChars.c_str());
4112  			::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_DEFAULT, BM_SETCHECK, nppGUI._isWordCharDefault ? BST_CHECKED : BST_UNCHECKED, 0);
4113  			::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_CUSTOM, BM_SETCHECK, !nppGUI._isWordCharDefault ? BST_CHECKED : BST_UNCHECKED, 0);
4114  			::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4115  			setWarningIfNeed();
4116  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4117  			generic_string tip2show = pNativeSpeaker->getLocalizedStrFromID("word-chars-list-tip", TEXT("This allows you to include additional character into current word characters while double clicking for selection or searching with \"Match whole word only\" option checked."));
4118  			_tip = CreateToolTip(IDD_WORDCHAR_QUESTION_BUTTON, _hSelf, _hInst, const_cast<PTSTR>(tip2show.c_str()), pNativeSpeaker->isRTL());
4119  			if (_tip)
4120  			{
4121  				SendMessage(_tip, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((30000), (0)));
4122  			}
4123  			return TRUE;
4124  		}
4125  		case WM_CTLCOLOREDIT:
4126  		{
4127  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4128  		}
4129  		case WM_CTLCOLORDLG:
4130  		{
4131  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4132  		}
4133  		case WM_CTLCOLORSTATIC:
4134  		{
4135  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4136  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4137  			bool isBlabla = (dlgCtrlID == IDD_STATIC_BLABLA) || (dlgCtrlID == IDD_STATIC_BLABLA2NDLINE);
4138  			if (NppDarkMode::isEnabled())
4139  			{
4140  				if (isBlabla)
4141  				{
4142  					return NppDarkMode::onCtlColor(hdcStatic);
4143  				}
4144  				return NppDarkMode::onCtlColorDarker(hdcStatic);
4145  			}
4146  			else if (isBlabla)
4147  			{
4148  				COLORREF bgColor = getCtrlBgColor(_hSelf);
4149  				SetTextColor(hdcStatic, RGB(0, 0, 0));
4150  				BYTE r = GetRValue(bgColor) - 30;
4151  				BYTE g = MyGetGValue(bgColor) - 30;
4152  				BYTE b = GetBValue(bgColor) - 30;
4153  				SetBkColor(hdcStatic, RGB(r, g, b));
4154  				return TRUE;
4155  			}
4156  			break;
4157  		}
4158  		case WM_PRINTCLIENT:
4159  		{
4160  			if (NppDarkMode::isEnabled())
4161  			{
4162  				return TRUE;
4163  			}
4164  			break;
4165  		}
4166  		case WM_COMMAND : 
4167  		{
4168  			if (HIWORD(wParam) == EN_CHANGE)
4169  			{
4170  				switch (LOWORD(wParam))
4171  				{
4172  					case  IDC_EDIT_OPENDELIMITER:
4173  					{
4174  						TCHAR opener[2] = { '\0' };
4175  						::SendDlgItemMessage(_hSelf, IDC_EDIT_OPENDELIMITER, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(opener));
4176  						nppGUI._leftmostDelimiter =  static_cast<char>(opener[0]);
4177  						return TRUE;
4178  					}
4179  					case  IDC_EDIT_CLOSEDELIMITER:
4180  					{
4181  						TCHAR closer[2] = { '\0' };
4182  						::SendDlgItemMessage(_hSelf, IDC_EDIT_CLOSEDELIMITER, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(closer));
4183  						nppGUI._rightmostDelimiter =  static_cast<char>(closer[0]);
4184  						return TRUE;
4185  					}
4186  					case  IDC_WORDCHAR_CUSTOM_EDIT:
4187  					{
4188  						char customText[MAX_PATH];
4189  						::GetDlgItemTextA(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT, customText, MAX_PATH-1);
4190  						nppGUI._customWordChars = customText;
4191  						setWarningIfNeed();
4192  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4193  						return TRUE;
4194  					}
4195  					default:
4196  						return FALSE;
4197  				}
4198  			}
4199  			switch (wParam)
4200  			{
4201  				case IDD_SEVERALLINEMODEON_CHECK :
4202  				{
4203  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDD_SEVERALLINEMODEON_CHECK, BM_GETCHECK, 0, 0));
4204  					nppGUI._delimiterSelectionOnEntireDocument = isChecked;
4205  					::ShowWindow(::GetDlgItem(_hSelf, IDD_STATIC_BLABLA2NDLINE),isChecked?SW_SHOW:SW_HIDE);
4206  					POINT *p = isChecked?&_multiLineModePoint:&_singleLineModePoint;
4207  					::MoveWindow(::GetDlgItem(_hSelf, IDC_EDIT_CLOSEDELIMITER), p->x, p->y, _closerRect.right, _closerRect.bottom, TRUE);
4208  					::MoveWindow(::GetDlgItem(_hSelf, IDD_STATIC_CLOSEDELIMITER), p->x + _closerRect.right + 4, p->y + 4, _closerLabelRect.right, _closerLabelRect.bottom, TRUE);
4209  					return TRUE;
4210  				}
4211  				case IDC_RADIO_WORDCHAR_DEFAULT:
4212  				{
4213  					::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_CUSTOM, BM_SETCHECK, BST_UNCHECKED, 0);
4214  					nppGUI._isWordCharDefault = true;
4215  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4216  					::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4217  					::SetDlgItemText(_hSelf, IDD_STATIC_WORDCHAR_WARNING, TEXT(""));
4218  					return TRUE;
4219  				}
4220  				case IDC_RADIO_WORDCHAR_CUSTOM:
4221  				{
4222  					::SendDlgItemMessage(_hSelf, IDC_RADIO_WORDCHAR_DEFAULT, BM_SETCHECK, BST_UNCHECKED, 0);
4223  					nppGUI._isWordCharDefault = false;
4224  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_SETWORDCHARS, 0, 0);
4225  					::EnableWindow(::GetDlgItem(_hSelf, IDC_WORDCHAR_CUSTOM_EDIT), !nppGUI._isWordCharDefault);
4226  					setWarningIfNeed();
4227  					return TRUE;
4228  				}
4229  				default :
4230  					return FALSE;
4231  			}
4232  		}
4233  		break;
4234  	}
4235  	return FALSE;
4236  }
4237  intptr_t CALLBACK CloudAndLinkSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
4238  {
4239  	NppParameters& nppParams = NppParameters::getInstance();
4240  	NppGUI & nppGUI = nppParams.getNppGUI();
4241  	const size_t uriSchemesMaxLength = 2048;
4242  	if (HIWORD(wParam) == EN_CHANGE)
4243  	{
4244  		switch (LOWORD(wParam))
4245  		{
4246  			case  IDC_CLOUDPATH_EDIT:
4247  			{
4248  				TCHAR inputDir[MAX_PATH] = {'\0'};
4249  				TCHAR inputDirExpanded[MAX_PATH] = {'\0'};
4250  				::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(inputDir));
4251  				::ExpandEnvironmentStrings(inputDir, inputDirExpanded, MAX_PATH);
4252  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4253  				if (::PathFileExists(inputDirExpanded))
4254  				{
4255  					nppGUI._cloudPath = inputDirExpanded;
4256  					nppParams.setCloudChoice(inputDirExpanded);
4257  					generic_string message;
4258  					if (nppParams.isCloudPathChanged())
4259  					{
4260  						message = pNativeSpeaker->getLocalizedStrFromID("cloud-restart-warning", TEXT("Please restart Notepad++ to take effect."));
4261  					}
4262  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4263  				}
4264  				else
4265  				{
4266  					bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_WITHCLOUD_RADIO, BM_GETCHECK, 0, 0));
4267  					if (isChecked)
4268  					{
4269  						generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-invalid-warning", TEXT("Invalid path."));
4270  						::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4271  						nppParams.removeCloudChoice();
4272  					}
4273  				}
4274  				return TRUE;
4275  			}
4276  			case IDC_URISCHEMES_EDIT:
4277  			{
4278  				TCHAR uriScheme[uriSchemesMaxLength] = { '\0' };
4279  				::SendDlgItemMessage(_hSelf, IDC_URISCHEMES_EDIT, WM_GETTEXT, uriSchemesMaxLength, reinterpret_cast<LPARAM>(uriScheme));
4280  				nppGUI._uriSchemes = uriScheme;
4281  				HWND grandParent = ::GetParent(_hParent);
4282  				::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4283  				return TRUE;
4284  			}
4285  		}
4286  	}
4287  	switch (message)
4288  	{
4289  		case WM_INITDIALOG:
4290  		{
4291  			generic_string message = TEXT("");
4292  			bool withCloud = nppGUI._cloudPath != TEXT("");
4293  			if (withCloud)
4294  			{
4295  				if (!::PathFileExists(nppGUI._cloudPath.c_str()))
4296  					message = TEXT("Invalid path");
4297  			}
4298  			::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4299  			::SendDlgItemMessage(_hSelf, IDC_NOCLOUD_RADIO, BM_SETCHECK, !withCloud ? BST_CHECKED : BST_UNCHECKED, 0);
4300  			::SendDlgItemMessage(_hSelf, IDC_WITHCLOUD_RADIO, BM_SETCHECK, withCloud ? BST_CHECKED : BST_UNCHECKED, 0);
4301  			::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._cloudPath.c_str()));
4302  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), withCloud);
4303  			::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), withCloud);
4304  			BOOL linkEnable = nppGUI._styleURL != urlDisable;
4305  			BOOL dontUnderline = (nppGUI._styleURL == urlNoUnderLineFg) || (nppGUI._styleURL == urlNoUnderLineBg);
4306  			BOOL roundBoxMode = (nppGUI._styleURL == urlNoUnderLineBg) || (nppGUI._styleURL == urlUnderLineBg);
4307  			::SendDlgItemMessage(_hSelf, IDC_URISCHEMES_EDIT, EM_SETLIMITTEXT, uriSchemesMaxLength, 0);
4308  			::SetWindowText(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), nppGUI._uriSchemes.c_str());
4309  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_ENABLE, BM_SETCHECK, linkEnable, 0);
4310  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE, BM_SETCHECK, dontUnderline, 0);
4311  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE, BM_SETCHECK, roundBoxMode, 0);
4312  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE), linkEnable);
4313  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE), linkEnable);
4314  			::EnableWindow(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), linkEnable);
4315  			return TRUE;
4316  		}
4317  		case WM_CTLCOLOREDIT:
4318  		{
4319  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4320  		}
4321  		case WM_CTLCOLORDLG:
4322  		{
4323  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4324  		}
4325  		case WM_CTLCOLORSTATIC:
4326  		{
4327  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4328  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4329  			bool isStaticText = dlgCtrlID == IDC_URISCHEMES_STATIC;
4330  			if (isStaticText)
4331  			{
4332  				bool isTextEnabled = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_ENABLE);
4333  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
4334  			}
4335  			return NppDarkMode::onCtlColorDarker(hdcStatic);
4336  		}
4337  		case WM_PRINTCLIENT:
4338  		{
4339  			if (NppDarkMode::isEnabled())
4340  			{
4341  				return TRUE;
4342  			}
4343  			break;
4344  		}
4345  		case WM_COMMAND:
4346  		{
4347  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4348  			switch (wParam)
4349  			{
4350  				case IDC_NOCLOUD_RADIO:
4351  				{
4352  					nppGUI._cloudPath = TEXT("");
4353  					nppParams.removeCloudChoice();
4354  					generic_string message;
4355  					if (nppParams.isCloudPathChanged())
4356  					{
4357  						message = pNativeSpeaker->getLocalizedStrFromID("cloud-restart-warning", TEXT("Please restart Notepad++ to take effect."));
4358  					}
4359  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4360  					::SendDlgItemMessage(_hSelf, IDC_CLOUDPATH_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._cloudPath.c_str()));
4361  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), false);
4362  					::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), false);
4363  				}
4364  				break;
4365  				case IDC_WITHCLOUD_RADIO:
4366  				{
4367  					generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-invalid-warning", TEXT("Invalid path."));
4368  					::SetDlgItemText(_hSelf, IDC_SETTINGSONCLOUD_WARNING_STATIC, message.c_str());
4369  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CLOUDPATH_EDIT), true);
4370  					::EnableWindow(::GetDlgItem(_hSelf, IDD_CLOUDPATH_BROWSE_BUTTON), true);
4371  				}
4372  				break;
4373  				case IDD_CLOUDPATH_BROWSE_BUTTON:
4374  				{
4375  					generic_string message = pNativeSpeaker->getLocalizedStrFromID("cloud-select-folder", TEXT("Select a folder from/to where Notepad++ reads/writes its settings"));
4376  					folderBrowser(_hSelf, message, IDC_CLOUDPATH_EDIT);
4377  				}
4378  				break;
4379  				case IDC_CHECK_CLICKABLELINK_ENABLE:
4380  				{
4381  					bool isChecked = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_ENABLE);
4382  					if (!isChecked)
4383  					{
4384  						::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE, BM_SETCHECK, BST_UNCHECKED, 0);
4385  						::SendDlgItemMessage(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE, BM_SETCHECK, BST_UNCHECKED, 0);
4386  					}
4387  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_NOUNDERLINE), isChecked);
4388  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_CLICKABLELINK_FULLBOXMODE), isChecked);
4389  					::EnableWindow(::GetDlgItem(_hSelf, IDC_URISCHEMES_EDIT), isChecked);
4390  					redrawDlgItem(IDC_CLICKABLELINK_STATIC);
4391  					nppGUI._styleURL = isChecked ? urlUnderLineFg : urlDisable;
4392  					HWND grandParent = ::GetParent(_hParent);
4393  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4394  				}
4395  				return TRUE;
4396  				case IDC_CHECK_CLICKABLELINK_NOUNDERLINE:
4397  				case IDC_CHECK_CLICKABLELINK_FULLBOXMODE:
4398  				{
4399  					bool isNoUnderline = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_NOUNDERLINE);
4400  					bool isRoundBoxMode = isCheckedOrNot(IDC_CHECK_CLICKABLELINK_FULLBOXMODE);
4401  					if (isRoundBoxMode)
4402  						nppGUI._styleURL = isNoUnderline ? urlNoUnderLineBg : urlUnderLineBg;
4403  					else
4404  						nppGUI._styleURL = isNoUnderline ? urlNoUnderLineFg : urlUnderLineFg;
4405  					HWND grandParent = ::GetParent(_hParent);
4406  					::SendMessage(grandParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4407  				}
4408  				return TRUE;
4409  				default:
4410  					return FALSE;
4411  			}
4412  		}																						
4413  	}
4414  	return FALSE;
4415  }
4416  intptr_t CALLBACK PerformanceSubDlg::run_dlgProc(UINT message , WPARAM wParam, LPARAM lParam)
4417  {
4418  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
4419  	if (HIWORD(wParam) == EN_CHANGE)
4420  	{
4421  		switch (LOWORD(wParam))
4422  		{
4423  			case  IDC_EDIT_PERFORMANCE_FILESIZE:
4424  			{
4425  				constexpr int stringSize = 16;
4426  				TCHAR str[stringSize]{};
4427  				::GetDlgItemText(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, str, stringSize);
4428  				if (lstrcmp(str, TEXT("")) == 0)
4429  					return TRUE;
4430  				int64_t fileLenInMB = ::GetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, NULL, FALSE);
4431  				if (fileLenInMB > 4096)
4432  				{
4433  					fileLenInMB = 4096;
4434  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4435  				}
4436  				nppGUI._largeFileRestriction._largeFileSizeDefInByte = fileLenInMB * 1024 * 1024;
4437  			}
4438  			return TRUE;
4439  		}
4440  	}
4441  	else if (HIWORD(wParam) == EN_KILLFOCUS)
4442  	{
4443  		switch (LOWORD(wParam))
4444  		{
4445  			case  IDC_EDIT_PERFORMANCE_FILESIZE:
4446  			{
4447  				constexpr int stringSize = 16;
4448  				TCHAR str[stringSize]{};
4449  				::GetDlgItemText(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, str, stringSize);
4450  				if (lstrcmp(str, TEXT("")) == 0)
4451  				{
4452  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, (NPP_STYLING_FILESIZE_LIMIT_DEFAULT / 1024) / 1024, FALSE);
4453  					return TRUE;
4454  				}
4455  				int64_t fileLenInMB = ::GetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, NULL, FALSE);
4456  				if (fileLenInMB == 0)
4457  				{
4458  					fileLenInMB = (NPP_STYLING_FILESIZE_LIMIT_DEFAULT / 1024) / 1024;
4459  					::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4460  					return TRUE;
4461  				}
4462  			}
4463  			return TRUE;
4464  		}
4465  	}
4466  	switch (message)
4467  	{
4468  		case WM_INITDIALOG:
4469  		{
4470  			int64_t fileLenInMB = (nppGUI._largeFileRestriction._largeFileSizeDefInByte / 1024) / 1024;
4471  			::SetDlgItemInt(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE, UINT(fileLenInMB), FALSE);
4472  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ENABLE, BM_SETCHECK, nppGUI._largeFileRestriction._isEnabled ? BST_CHECKED : BST_UNCHECKED, 0);
4473  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH, BM_SETCHECK, nppGUI._largeFileRestriction._allowBraceMatch ? BST_CHECKED : BST_UNCHECKED, 0);
4474  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION, BM_SETCHECK, nppGUI._largeFileRestriction._allowAutoCompletion ? BST_CHECKED : BST_UNCHECKED, 0);
4475  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE, BM_SETCHECK, nppGUI._largeFileRestriction._allowSmartHilite ? BST_CHECKED : BST_UNCHECKED, 0);
4476  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK, BM_SETCHECK, nppGUI._largeFileRestriction._allowClickableLink ? BST_CHECKED : BST_UNCHECKED, 0);
4477  			::SendDlgItemMessage(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP, BM_SETCHECK, nppGUI._largeFileRestriction._deactivateWordWrap ? BST_CHECKED : BST_UNCHECKED, 0);
4478  			bool largeFileRestrictionEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4479  			::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE), largeFileRestrictionEnabled);
4480  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH), largeFileRestrictionEnabled);
4481  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION), largeFileRestrictionEnabled);
4482  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE), largeFileRestrictionEnabled);
4483  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK), largeFileRestrictionEnabled);
4484  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP), largeFileRestrictionEnabled);
4485  			NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
4486  			generic_string enablePerfTip = pNativeSpeaker->getLocalizedStrFromID("largeFileRestriction-tip", TEXT("Some features may slow performance in large files. These features can be auto-disabled on opening a large file. You can customize them here.\n\nNOTE:\n1. Modifying options here requires re-open currently opened large files to get proper behavior.\n\n2. If \"Deactivate Word Wrap globally\" is checked and you open a large file, \"Word Wrap\" will be disabled for all files. You can re-enable it via menu \"View->Word Wrap\""));
4487  			_largeFileRestrictionTip = CreateToolTip(IDD_PERFORMANCE_TIP_QUESTION_BUTTON, _hSelf, _hInst, const_cast<PTSTR>(enablePerfTip.c_str()), false);
4488  			return TRUE;
4489  		}
4490  		case WM_CTLCOLOREDIT:
4491  		{
4492  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4493  		}
4494  		case WM_CTLCOLORDLG:
4495  		{
4496  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4497  		}
4498  		case WM_CTLCOLORSTATIC:
4499  		{
4500  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
4501  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
4502  			bool isStaticText = (dlgCtrlID == IDC_STATIC_PERFORMANCE_FILESIZE || dlgCtrlID == IDC_STATIC_PERFORMANCE_MB);
4503  			if (isStaticText)
4504  			{
4505  				bool isTextEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4506  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
4507  			}
4508  			if (dlgCtrlID == IDC_EDIT_PERFORMANCE_FILESIZE)
4509  			{
4510  				return NppDarkMode::onCtlColor(hdcStatic);
4511  			}
4512  			return NppDarkMode::onCtlColorDarker(hdcStatic);
4513  		}
4514  		case WM_PRINTCLIENT:
4515  		{
4516  			if (NppDarkMode::isEnabled())
4517  			{
4518  				return TRUE;
4519  			}
4520  			break;
4521  		}
4522  		case WM_COMMAND:
4523  		{
4524  			switch (wParam)
4525  			{
4526  				case IDC_CHECK_PERFORMANCE_ENABLE:
4527  				{
4528  					bool largeFileRestrictionEnabled = isCheckedOrNot(IDC_CHECK_PERFORMANCE_ENABLE);
4529  					nppGUI._largeFileRestriction._isEnabled = largeFileRestrictionEnabled;
4530  					::EnableWindow(::GetDlgItem(_hSelf, IDC_EDIT_PERFORMANCE_FILESIZE), largeFileRestrictionEnabled);
4531  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH), largeFileRestrictionEnabled);
4532  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION), largeFileRestrictionEnabled);
4533  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE), largeFileRestrictionEnabled);
4534  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK), largeFileRestrictionEnabled);
4535  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP), largeFileRestrictionEnabled);
4536  					redrawDlgItem(IDC_STATIC_PERFORMANCE_FILESIZE);
4537  					redrawDlgItem(IDC_STATIC_PERFORMANCE_MB);
4538  					if (largeFileRestrictionEnabled)
4539  					{
4540  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANSMARTHILITING, 0, 0);
4541  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANBRACEMATCH, 0, 0);
4542  					}
4543  					else
4544  					{
4545  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4546  					}
4547  				}
4548  				return TRUE;
4549  				case IDC_CHECK_PERFORMANCE_ALLOWBRACEMATCH:
4550  				{
4551  					bool isAllowed = isCheckedOrNot(int(wParam));
4552  					nppGUI._largeFileRestriction._allowBraceMatch = isAllowed;
4553  					if (!isAllowed)
4554  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANBRACEMATCH, 0, 0);
4555  				}
4556  				return TRUE;
4557  				case IDC_CHECK_PERFORMANCE_ALLOWAUTOCOMPLETION:
4558  				{
4559  					bool isAllowed = isCheckedOrNot(int(wParam));
4560  					nppGUI._largeFileRestriction._allowAutoCompletion = isAllowed;
4561  				}
4562  				return TRUE;
4563  				case IDC_CHECK_PERFORMANCE_ALLOWSMARTHILITE:
4564  				{
4565  					bool isAllowed = isCheckedOrNot(int(wParam));
4566  					nppGUI._largeFileRestriction._allowSmartHilite = isAllowed;
4567  					if (!isAllowed)
4568  						::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_CLEANSMARTHILITING, 0, 0);
4569  				}
4570  				return TRUE;
4571  				case IDC_CHECK_PERFORMANCE_ALLOWCLICKABLELINK:
4572  				{
4573  					bool isAllowed = isCheckedOrNot(int(wParam));
4574  					nppGUI._largeFileRestriction._allowClickableLink = isAllowed;
4575  					::SendMessage(::GetParent(_hParent), NPPM_INTERNAL_UPDATECLICKABLELINKS, 0, 0);
4576  				}
4577  				return TRUE;
4578  				case IDC_CHECK_PERFORMANCE_DEACTIVATEWORDWRAP:
4579  				{
4580  					bool isDeactivated = isCheckedOrNot(int(wParam));
4581  					nppGUI._largeFileRestriction._deactivateWordWrap = isDeactivated;
4582  				}
4583  				return TRUE;
4584  				default:
4585  					return FALSE;
4586  			}
4587  		}
4588  		break;
4589  	}
4590  	return FALSE;
4591  }
4592  intptr_t CALLBACK SearchEngineSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
4593  {
4594  	NppParameters& nppParams = NppParameters::getInstance();
4595  	NppGUI & nppGUI = nppParams.getNppGUI();
4596  	if (HIWORD(wParam) == EN_CHANGE)
4597  	{
4598  		switch (LOWORD(wParam))
4599  		{
4600  			case  IDC_SEARCHENGINE_EDIT:
4601  			{
4602  				TCHAR input[MAX_PATH] = { '\0' };
4603  				::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_EDIT, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(input));
4604  				nppGUI._searchEngineCustom = input;
4605  				return TRUE;
4606  			}
4607  		}
4608  	}
4609  	switch (message)
4610  	{
4611  		case WM_INITDIALOG:
4612  		{
4613  			if (nppGUI._searchEngineChoice == nppGUI.se_custom)
4614  			{
4615  				if (nppGUI._searchEngineCustom.empty())
4616  				{
4617  					nppGUI._searchEngineChoice = nppGUI.se_google;
4618  				}
4619  			}
4620  			if (nppGUI._searchEngineChoice == nppGUI.se_bing)
4621  				nppGUI._searchEngineChoice = nppGUI.se_duckDuckGo;
4622  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_CUSTOM_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_custom ? BST_CHECKED : BST_UNCHECKED, 0);
4623  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_DUCKDUCKGO_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_duckDuckGo ? BST_CHECKED : BST_UNCHECKED, 0);
4624  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_GOOGLE_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_google ? BST_CHECKED : BST_UNCHECKED, 0);
4625  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_YAHOO_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_yahoo ? BST_CHECKED : BST_UNCHECKED, 0);
4626  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_STACKOVERFLOW_RADIO, BM_SETCHECK, nppGUI._searchEngineChoice == nppGUI.se_stackoverflow ? BST_CHECKED : BST_UNCHECKED, 0);
4627  			::SendDlgItemMessage(_hSelf, IDC_SEARCHENGINE_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(nppGUI._searchEngineCustom.c_str()));
4628  			::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), nppGUI._searchEngineChoice == nppGUI.se_custom);
4629  			return TRUE;
4630  		}
4631  		case WM_CTLCOLOREDIT:
4632  		{
4633  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
4634  		}
4635  		case WM_CTLCOLORDLG:
4636  		case WM_CTLCOLORSTATIC:
4637  		{
4638  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4639  		}
4640  		case WM_PRINTCLIENT:
4641  		{
4642  			if (NppDarkMode::isEnabled())
4643  			{
4644  				return TRUE;
4645  			}
4646  			break;
4647  		}
4648  		case WM_COMMAND:
4649  		{
4650  			switch (wParam)
4651  			{
4652  				case IDC_SEARCHENGINE_DUCKDUCKGO_RADIO:
4653  				{
4654  					nppGUI._searchEngineChoice = nppGUI.se_duckDuckGo;
4655  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4656  				}
4657  				break;
4658  				case IDC_SEARCHENGINE_GOOGLE_RADIO:
4659  				{
4660  					nppGUI._searchEngineChoice = nppGUI.se_google;
4661  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4662  				}
4663  				break;
4664  				case IDC_SEARCHENGINE_YAHOO_RADIO:
4665  				{
4666  					nppGUI._searchEngineChoice = nppGUI.se_yahoo;
4667  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4668  				}
4669  				break;
4670  				case IDC_SEARCHENGINE_STACKOVERFLOW_RADIO:
4671  				{
4672  					nppGUI._searchEngineChoice = nppGUI.se_stackoverflow;
4673  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), false);
4674  				}
4675  				break;
4676  				case IDC_SEARCHENGINE_CUSTOM_RADIO:
4677  				{
4678  					nppGUI._searchEngineChoice = nppGUI.se_custom;
4679  					::EnableWindow(::GetDlgItem(_hSelf, IDC_SEARCHENGINE_EDIT), true);
4680  				}
4681  				break;
4682  				default:
4683  					return FALSE;
4684  			}
4685  		}
4686  		break;
4687  	}
4688  	return FALSE;
4689  }
4690  intptr_t CALLBACK SearchingSubDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM)
4691  {
4692  	NppParameters& nppParams = NppParameters::getInstance();
4693  	NppGUI& nppGUI = nppParams.getNppGUI();
4694  	switch (message)
4695  	{
4696  		case WM_INITDIALOG:
4697  		{
4698  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED, BM_SETCHECK, nppGUI._fillFindFieldWithSelected, 0);
4699  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET, BM_SETCHECK, nppGUI._fillFindFieldSelectCaret, 0);
4700  			::SendDlgItemMessage(_hSelf, IDC_CHECK_MONOSPACEDFONT_FINDDLG, BM_SETCHECK, nppGUI._monospacedFontFindDlg, 0);
4701  			::SendDlgItemMessage(_hSelf, IDC_CHECK_FINDDLG_ALWAYS_VISIBLE, BM_SETCHECK, nppGUI._findDlgAlwaysVisible, 0);
4702  			::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET), nppGUI._fillFindFieldWithSelected ? TRUE : FALSE);
4703  			::SendDlgItemMessage(_hSelf, IDC_CHECK_CONFIRMREPLOPENDOCS, BM_SETCHECK, nppGUI._confirmReplaceInAllOpenDocs, 0);
4704  			::SendDlgItemMessage(_hSelf, IDC_CHECK_REPLACEANDSTOP, BM_SETCHECK, nppGUI._replaceStopsWithoutFindingNext, 0);
4705  			::SendDlgItemMessage(_hSelf, IDC_CHECK_SHOWONCEPERFOUNDLINE, BM_SETCHECK, nppGUI._finderShowOnlyOneEntryPerFoundLine, 0);
4706  			return TRUE;
4707  		}
4708  		case WM_CTLCOLORDLG:
4709  		case WM_CTLCOLORSTATIC:
4710  		{
4711  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
4712  		}
4713  		case WM_PRINTCLIENT:
4714  		{
4715  			if (NppDarkMode::isEnabled())
4716  			{
4717  				return TRUE;
4718  			}
4719  			break;
4720  		}
4721  		case WM_COMMAND:
4722  		{
4723  			switch (wParam)
4724  			{
4725  				case IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED:
4726  				{
4727  					nppGUI._fillFindFieldWithSelected = isCheckedOrNot(IDC_CHECK_FILL_FIND_FIELD_WITH_SELECTED);
4728  					::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET), nppGUI._fillFindFieldWithSelected ? TRUE :FALSE);
4729  					if (!nppGUI._fillFindFieldWithSelected) 
4730  					{
4731  						::SendDlgItemMessage(_hSelf, IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET, BM_SETCHECK, BST_UNCHECKED, 0);
4732  						nppGUI._fillFindFieldSelectCaret = false;
4733  					}
4734  					return TRUE;
4735  				}
4736  				break;
4737  				case IDC_CHECK_MONOSPACEDFONT_FINDDLG:
4738  				{
4739  					nppGUI._monospacedFontFindDlg = isCheckedOrNot(IDC_CHECK_MONOSPACEDFONT_FINDDLG);
4740  					return TRUE;
4741  				}
4742  				break;
4743  				case IDC_CHECK_FINDDLG_ALWAYS_VISIBLE:
4744  				{
4745  					nppGUI._findDlgAlwaysVisible = isCheckedOrNot(IDC_CHECK_FINDDLG_ALWAYS_VISIBLE);
4746  					return TRUE;
4747  				}
4748  				break;
4749  				case IDC_CHECK_CONFIRMREPLOPENDOCS:
4750  				{
4751  					nppGUI._confirmReplaceInAllOpenDocs = isCheckedOrNot(IDC_CHECK_CONFIRMREPLOPENDOCS);
4752  					return TRUE;
4753  				}
4754  				break;
4755  				case IDC_CHECK_REPLACEANDSTOP:
4756  				{
4757  					nppGUI._replaceStopsWithoutFindingNext = isCheckedOrNot(IDC_CHECK_REPLACEANDSTOP);
4758  					return TRUE;
4759  				}
4760  				break;
4761  				case IDC_CHECK_SHOWONCEPERFOUNDLINE:
4762  				{
4763  					nppGUI._finderShowOnlyOneEntryPerFoundLine = isCheckedOrNot(IDC_CHECK_SHOWONCEPERFOUNDLINE);
4764  					return TRUE;
4765  				}
4766  				break;
4767  				case IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET:
4768  				{
4769  					nppGUI._fillFindFieldSelectCaret = isCheckedOrNot(IDC_CHECK_FILL_FIND_FIELD_SELECT_CARET);
4770  					return TRUE;
4771  				}
4772  				break;
4773  				default:
4774  					return FALSE;
4775  			}
4776  		}
4777  		break;
4778  	}
4779  	return FALSE;
4780  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-language_model.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-preferenceDlg.cpp</div>
                </div>
                <div class="column column_space"><pre><code>895            } else if (i == 1) {
896              temp_fid = parent_b->fontinfo_id2();
897            } else if (i == 2) {
898              temp_fid = b->fontinfo_id();
899            } else {
900              temp_fid = b->fontinfo_id2();
901            }
</pre></code></div>
                <div class="column column_space"><pre><code>1710  			if (nppGUI._fileAutoDetection & cdEnabledOld)
1711  			{
1712  				selIndex = fileUpdateChoiceEnable4All;
1713  			}
1714  			else if (nppGUI._fileAutoDetection & cdEnabledNew)
1715  			{				
1716  				selIndex = fileUpdateChoiceEnable;
1717  			}
1718  			else 
1719  			{
1720  				::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATESILENTLY), FALSE);
1721  				::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_UPDATEGOTOEOF), FALSE);
1722  				selIndex = fileUpdateChoiceDisable;
1723  			}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    