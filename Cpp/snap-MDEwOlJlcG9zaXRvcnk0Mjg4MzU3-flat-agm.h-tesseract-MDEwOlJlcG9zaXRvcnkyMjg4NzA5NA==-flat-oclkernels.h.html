
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.51985559566787%, Tokens: 15</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agm.h</h3>
            <pre><code>1  #ifndef snap_agm_h
2  #define snap_agm_h
3  #include "Snap.h"
4  class TAGM {
5  public:
6    static void RndConnectInsideCommunity(PUNGraph& Graph, const TIntV& CmtyV, const double& Prob, TRnd& Rnd);
7    static PUNGraph GenAGM(TVec<TIntV >& CmtyVV, const double& DensityCoef, const double& ScaleCoef, TRnd& Rnd=TInt::Rnd);
8    static PUNGraph GenAGM(TVec<TIntV>& CmtyVV, const double& DensityCoef, const int TargetEdges, TRnd& Rnd);
9    static PUNGraph GenAGM(TVec<TIntV>& CmtyVV, const TFltV& CProbV, TRnd& Rnd, const double PNoCom = -1.0);
10  };
11  class TAGMUtil {
12  public:
13    static void GenPLSeq(TIntV& SzSeq,const int& SeqLen, const double& Alpha, TRnd& Rnd, const int& Min, const int& Max);
14    static void ConnectCmtyVV(TVec<TIntV>& CmtyVV, const TIntPrV& CIDSzPrV, const TIntPrV& NIDMemPrV, TRnd& Rnd);
<span onclick='openModal()' class='match'>15    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const PUNGraph& Graph, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
15    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const PUNGraph& Graph, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
</span>16    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const TIntV& NIDV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
17    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
18    static void GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntV>& CmtyVV);
19    static void GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntV>& CmtyVV, const TIntV& NIDV);
20    static void GetNodeMembership(TIntH& NIDComVH, const THash<TInt,TIntV >& CmtyVH);
21    static void GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntSet>& CmtyVV);
22    static void GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const THash<TInt,TIntV >& CmtyVH);
23    static void GetNodeMembership(THash<TInt,TIntV >& NIDComVH, const THash<TInt,TIntV >& CmtyVH);
24    static void GetNodeMembership(THash<TInt,TIntV >& NIDComVH, const TVec<TIntV >& CmtyVV);
25    static void LoadCmtyVV(const TStr& InFNm, TVec<TIntV>& CmtyVV);
26    static void LoadCmtyVV(const TStr& InFNm, TVec<TIntV>& CmtyVV, TStrHash<TInt>& StrToNIdH, const int BeginCol, const int MinSz = 3, const TSsFmt Sep = ssfTabSep);
27    static void DumpCmtyVV(const TStr& OutFNm, const TVec<TIntV>& CmtyVV);
28    static void DumpCmtyVV(const TStr OutFNm, TVec<TIntV>& CmtyVV, TIntStrH& NIDNmH);
29    static int TotalMemberships(const TVec<TIntV>& CmtyVV);
30    static void RewireCmtyVV(const TVec<TIntV>& CmtyVVIn, TVec<TIntV>& CmtyVVOut, TRnd& Rnd);
31    static void RewireCmtyNID(THash<TInt,TIntV >& CmtyVH, TRnd& Rnd);
32    static int Intersection(const TIntV& C1, const TIntV& C2);
33    static void GetIntersection(const THashSet<TInt>& A, const THashSet<TInt>& B, THashSet<TInt>& C);
34    static int Intersection(const THashSet<TInt>& A, const THashSet<TInt>& B);
35    static double GetConductance(const PUNGraph& Graph, const TIntSet& CmtyS, const int Edges);
36    static void GetNbhCom(const PUNGraph& Graph, const int NID, TIntSet& NBCmtyS);
37    static void SaveGephi(const TStr& OutFNm, const PUNGraph& G, const TVec<TIntV >& CmtyVVAtr, const double MaxSz, const double MinSz) {
38      THash<TInt, TStr> TmpH;
39      SaveGephi(OutFNm, G, CmtyVVAtr, MaxSz, MinSz, TmpH);
40    }
41    static void SaveGephi(const TStr& OutFNm, const PUNGraph& G, const TVec<TIntV >& CmtyVVAtr, const double MaxSz, const double MinSz, const THash<TInt, TStr>& NIDNameH) { 
42      THash<TInt, TIntTr> TmpH; 
43      SaveGephi(OutFNm, G, CmtyVVAtr, MaxSz, MinSz, NIDNameH, TmpH);
44    }
45    static void SaveGephi(const TStr& OutFNm, const PUNGraph& G, const TVec<TIntV >& CmtyVVAtr, const double MaxSz, const double MinSz, const THash<TInt, TStr>& NIDNameH, const THash<TInt, TIntTr >& NIDColorH);
46    static void SaveBipartiteGephi(const TStr& OutFNm, const TIntV& NIDV, const TVec<TIntV>& CmtyVV, const double MaxSz, const double MinSz, const TIntStrH& NIDNameH, const THash<TInt, TIntTr >& NIDColorH, const THash<TInt, TIntTr >& CIDColorH);
47    static int FindComsByAGM(const PUNGraph& Graph, const int InitComs, const int MaxIter, const int RndSeed, const double RegGap, const double PNoCom = 0.0, const TStr PltFPrx = TStr());
48    template <class PGraph>
49    static PGraph LoadEdgeListStr(const TStr& InFNm, TIntStrH& NIDNameH, const int& SrcColId = 0, const int& DstColId = 1, const TSsFmt SsFmt = ssfTabSep) {
50      TSsParser Ss(InFNm, SsFmt);
51      PGraph Graph = PGraph::TObj::New();
52      TStrHash<TInt> StrSet(Mega(1), true);
53      while (Ss.Next()) {
54        const int SrcNId = StrSet.AddKey(Ss[SrcColId]);
55        const int DstNId = StrSet.AddKey(Ss[DstColId]);
56        if (! Graph->IsNode(SrcNId)) { Graph->AddNode(SrcNId); }
57        if (! Graph->IsNode(DstNId)) { Graph->AddNode(DstNId); }
58        Graph->AddEdge(SrcNId, DstNId);
59      }
60      NIDNameH.Gen(StrSet.Len());
61      for (int s = 0; s < StrSet.Len(); s++) { NIDNameH.AddDat(s, StrSet.GetKey(s)); }
62      IAssert(NIDNameH.Len() == Graph->GetNodes());
63      Graph->Defrag();
64      return Graph;
65    }
66    template <class PGraph>
67    static PGraph LoadEdgeListStr(const TStr& InFNm, TStrHash<TInt>& NodeNameH, const int& SrcColId = 0, const int& DstColId = 1, const TSsFmt SsFmt = ssfTabSep) {
68      TSsParser Ss(InFNm, SsFmt);
69      PGraph Graph = PGraph::TObj::New();
70      TStrHash<TInt> StrSet(Mega(1), true);
71      while (Ss.Next()) {
72        const int SrcNId = StrSet.AddKey(Ss[SrcColId]);
73        const int DstNId = StrSet.AddKey(Ss[DstColId]);
74        if (! Graph->IsNode(SrcNId)) { Graph->AddNode(SrcNId); }
75        if (! Graph->IsNode(DstNId)) { Graph->AddNode(DstNId); }
76        Graph->AddEdge(SrcNId, DstNId);
77      }
78      NodeNameH = StrSet;
79      NodeNameH.Pack();
80      Graph->Defrag();
81      return Graph;
82    }
83    template<class PGraph>
84    static void GVizComGraph(const PGraph& Graph,const TVec<TIntV >& CmtyVV, const TStr& OutFNm, const TStr& Desc = TStr()){
85      TStrV Colors = TStrV::GetV("red","blue","green","pink","cyan");
86      TStrV Shapes = TStrV::GetV("ellipse","triangle","square","pentagon","hexagon");
87      THash<TInt,TIntV> NIDComVH;
88      GetNodeMembership(NIDComVH,CmtyVV);
89      const TStr Ext = OutFNm.GetFExt();
90      const TStr GraphFNm = OutFNm.GetSubStr(0, OutFNm.Len() - Ext.Len()) + "dot";
91      const bool IsDir = HasGraphFlag(typename PGraph::TObj, gfDirected);
92      FILE *F = fopen(GraphFNm.CStr(), "wt");
93      if (! Desc.Empty()) fprintf(F, "&bsol;*****\n%s\n*****/\n\n", Desc.CStr());
94      if (IsDir) { fprintf(F, "digraph G {\n"); } else { fprintf(F, "graph G {\n"); }
95      fprintf(F, "  graph [splines=false overlap=false]\n"); 
96      fprintf(F, "  node  [width=0.3, height=0.3]\n");
97      for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
98        int NID = NI.GetId();
99        TIntV& CIDV = NIDComVH.GetDat(NID);
100        IAssert(CIDV.Len()>0);
101        TStr ShapeNm = Shapes[(CIDV.Len()-1) % Shapes.Len()];
102        TStr ColorNm = Colors[CIDV[0] % Colors.Len()];
103        TStr NodeComLabel = TStr::Fmt("%d(",NID);
104        for(int i=0;i<CIDV.Len();i++) {
105          TStr TmpStr = TStr::Fmt("%d",int(CIDV[i]));
106          NodeComLabel += TmpStr;
107          if(i<CIDV.Len()-1){NodeComLabel+=",";}
108        }
109        NodeComLabel += ")";
110        fprintf(F, "  %d [style=filled, shape=\"%s\" fillcolor=\"%s\" label=\"%s\"];\n", NI.GetId(), ShapeNm.CStr(),ColorNm.CStr(), NodeComLabel.CStr()); 
111      }
112      for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
113        if (NI.GetOutDeg()==0 && NI.GetInDeg()==0  ) { 
114          fprintf(F, "%d;\n", NI.GetId()); }
115        else {
116          for (int e = 0; e < NI.GetOutDeg(); e++) {
117            if (! IsDir && NI.GetId() > NI.GetOutNId(e)) { continue; }
118            fprintf(F, "  %d %s %d;\n", NI.GetId(), IsDir?"->":"--", NI.GetOutNId(e)); 
119          }
120        }
121      }
122      if (! Desc.Empty()) {
123        fprintf(F, "  label = \"\\n%s\\n\";", Desc.CStr());
124        fprintf(F, "  fontsize=24;\n");
125      }
126      fprintf(F, "}\n");
127      fclose(F);
128      TSnap::TSnapDetail::GVizDoLayout(GraphFNm, OutFNm, gvlNeato);
129    }
130  };
131  class TLogRegPredict;
132  typedef TPt<TLogRegPredict> PLogRegPredict;
133  class TLogRegFit {
134  private:
135    TVec<TFltV> X;
136    TFltV Y;
137    TFltV Theta;
138    int M; 
139  public:
140    TLogRegFit() {}
141    ~TLogRegFit() {}
142    PLogRegPredict CalcLogRegGradient(const TVec<TFltV>& XPt, const TFltV& yPt, const TStr& PlotNm = TStr(), const double& ChangeEps = 0.01, const int& MaxStep = 200, const bool InterceptPt = false);
143    PLogRegPredict CalcLogRegNewton(const TVec<TFltV>& XPt, const TFltV& yPt, const TStr& PlotNm = TStr(), const double& ChangeEps = 0.01, const int& MaxStep = 200, const bool InterceptPt = false);
144    int MLEGradient(const double& ChangeEps, const int& MaxStep, const TStr PlotNm);
145    int MLENewton(const double& ChangeEps, const int& MaxStep, const TStr PlotNm);
146    double GetStepSizeByLineSearch(const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta);
147    double Likelihood(const TFltV& NewTheta);
148    double Likelihood() { return Likelihood(Theta); }
149    void Gradient(TFltV& GradV);
150    void Hessian(TFltVV& HVV);
151    void GetNewtonStep(TFltVV& HVV, const TFltV& GradV, TFltV& DeltaLV);
152  };
153  class TLogRegPredict {
154  private: 
155      TCRef CRef;
156  private:
157      TFltV Theta;
158  public:
159      TLogRegPredict(const TFltV& _bb): Theta(_bb) { };
160      TLogRegPredict(TSIn& SIn) { Theta.Load(SIn); };
161      static PLogRegPredict Load(TSIn& SIn) { return new TLogRegPredict(SIn); };
162      void Save(TSOut& SOut) const { Theta.Save(SOut); };
163      UndefDefaultCopyAssign(TLogRegPredict);
164  public:    
165    static void GetCfy(const TVec<TFltV>& X, TFltV& OutV, const TFltV& NewTheta);
166    static double GetCfy(const TFltV& AttrV, const TFltV& NewTheta);
167    double GetCfy(const TFltV& AttrV) { return GetCfy(AttrV, Theta); }
168    void GetTheta(TFltV& _Theta) { _Theta = Theta; }
169    void GetCfy(const TVec<TFltV>& X, TFltV& OutV) { GetCfy(X, OutV, Theta); }
170    void PrintTheta() { for (int t = 0; t < Theta.Len(); t++) { printf("Theta[%d] = %f\n", t, Theta[t].Val); } }
171    friend class TPt<TLogRegPredict>;
172  };
173  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-oclkernels.h</h3>
            <pre><code>1  #ifndef TESSERACT_OPENCL_OCLKERNELS_H_
2  #  define TESSERACT_OPENCL_OCLKERNELS_H_
3  #  ifndef USE_EXTERNAL_KERNEL
4  #    define KERNEL(...) #    __VA_ARGS__ "\n"
5  static const char *kernel_src = KERNEL(
6  \n #ifdef KHR_DP_EXTENSION\n
7  \n #pragma OPENCL EXTENSION cl_khr_fp64
8      : enable\n
9  \n #elif AMD_DP_EXTENSION\n
10  \n #pragma OPENCL EXTENSION cl_amd_fp64
11      : enable\n
12  \n #else \n
13  \n #endif \n
14          __kernel void composeRGBPixel(__global uint *tiffdata, int w, int h, int wpl, __global uint *output) {
15              int i = get_global_id(1);
16              int j = get_global_id(0);
17              int tiffword, rval, gval, bval;
18              if ((i >= h) || (j >= w))
19                  return;
20              tiffword = tiffdata[i * w + j];
21              rval = ((tiffword)&0xff);
22              gval = (((tiffword) >> 8) & 0xff);
23              bval = (((tiffword) >> 16) & 0xff);
24              output[i * wpl + j] = (rval << (8 * (sizeof(uint) - 1 - 0))) | (gval << (8 * (sizeof(uint) - 1 - 1))) | (bval << (8 * (sizeof(uint) - 1 - 2)));
25          })
26      KERNEL(
27  \n__kernel void pixSubtract_inplace(__global int *dword, __global int *sword, const int wpl, const int h) {
28          const unsigned int row = get_global_id(1);
29          const unsigned int col = get_global_id(0);
30          const unsigned int pos = row * wpl + col;
31          if (row >= h || col >= wpl)
32              return;
33          *(dword + pos) &= ~(*(sword + pos));
34      }\n)
35          KERNEL(
36  \n__kernel void morphoDilateHor_5x5(__global int *sword, __global int *dword, const int wpl, const int h) {
37              const unsigned int pos = get_global_id(0);
38              unsigned int prevword, nextword, currword, tempword;
39              unsigned int destword;
40              const int col = pos % wpl;
41              if (pos >= (wpl * h))
42                  return;
43              currword = *(sword + pos);
44              destword = currword;
45              if (col == 0)
46                  prevword = 0;
47              else
48                  prevword = *(sword + pos - 1);
49              if (col == (wpl - 1))
50                  nextword = 0;
51              else
52                  nextword = *(sword + pos + 1);
53              tempword = (prevword << (31)) | ((currword >> 1));
54              destword |= tempword;
55              tempword = (currword << 1) | (nextword >> (31));
56              destword |= tempword;
57              tempword = (prevword << (30)) | ((currword >> 2));
58              destword |= tempword;
59              tempword = (currword << 2) | (nextword >> (30));
60              destword |= tempword;
61              *(dword + pos) = destword;
62          }\n)
63              KERNEL(
64  \n__kernel void morphoDilateVer_5x5(__global int *sword, __global int *dword, const int wpl, const int h) {
65                  const int col = get_global_id(0);
66                  const int row = get_global_id(1);
67                  const unsigned int pos = row * wpl + col;
68                  unsigned int tempword;
69                  unsigned int destword;
70                  int i;
71                  if (row >= h || col >= wpl)
72                      return;
73                  destword = *(sword + pos);
74                  i = (row - 2) < 0 ? row : (row - 2);
75                  tempword = *(sword + i * wpl + col);
76                  destword |= tempword;
77                  i = (row - 1) < 0 ? row : (row - 1);
78                  tempword = *(sword + i * wpl + col);
79                  destword |= tempword;
80                  i = (row >= (h - 1)) ? row : (row + 1);
81                  tempword = *(sword + i * wpl + col);
82                  destword |= tempword;
83                  i = (row >= (h - 2)) ? row : (row + 2);
84                  tempword = *(sword + i * wpl + col);
85                  destword |= tempword;
86                  *(dword + pos) = destword;
87              }\n)
88                  KERNEL(
89  \n__kernel void morphoDilateHor(__global int *sword, __global int *dword, const int xp, const int xn, const int wpl, const int h) {
90                      const int col = get_global_id(0);
91                      const int row = get_global_id(1);
92                      const unsigned int pos = row * wpl + col;
93                      unsigned int parbitsxp, parbitsxn, nwords;
94                      unsigned int destword, tempword, lastword, currword;
95                      unsigned int lnextword, lprevword, rnextword, rprevword, firstword, secondword;
96                      int i, j, siter, eiter;
97                      if (pos >= (wpl * h) || (xn < 1 && xp < 1))
98                          return;
99                      currword = *(sword + pos);
100                      destword = currword;
101                      parbitsxp = xp & 31;
102                      parbitsxn = xn & 31;
103                      nwords = xp >> 5;
104                      if (parbitsxp > 0)
105                          nwords += 1;
106                      else
107                          parbitsxp = 31;
108                      siter = (col - nwords);
109                      eiter = (col + nwords);
110                      if (col == 0)
111                          firstword = 0x0;
112                      else
113                          firstword = *(sword + pos - 1);
114                      if (col == (wpl - 1))
115                          secondword = 0x0;
116                      else
117                          secondword = *(sword + pos + 1);
118                      for (i = 1; i <= parbitsxp; i++) {
119                          tempword = ((i == parbitsxp) && (parbitsxp != parbitsxn)) ? 0x0 : (firstword << (32 - i)) | ((currword >> i));
120                          destword |= tempword;
121                          tempword = (currword << i) | (secondword >> (32 - i));
122                          destword |= tempword;
123                      }
124                      if (nwords == 1) {
125                          if (xn == 32) {
126                              destword |= firstword;
127                          }
128                          if (xp == 32) {
129                              destword |= secondword;
130                          }
131                          *(dword + pos) = destword;
132                          return;
133                      }
134                      if (siter < 0)
135                          firstword = 0x0;
136                      else
137                          firstword = *(sword + row * wpl + siter);
138                      if (eiter >= wpl)
139                          lastword = 0x0;
140                      else
141                          lastword = *(sword + row * wpl + eiter);
142                      for (i = 1; i < nwords; i++) {
143                          if ((siter + i) < 0)
144                              secondword = 0x0;
145                          else
146                              secondword = *(sword + row * wpl + siter + i);
147                          lprevword = firstword << (32 - parbitsxn) | secondword >> parbitsxn;
148                          firstword = secondword;
149                          if ((siter + i + 1) < 0)
150                              secondword = 0x0;
151                          else
152                              secondword = *(sword + row * wpl + siter + i + 1);
153                          lnextword = firstword << (32 - parbitsxn) | secondword >> parbitsxn;
154                          if ((eiter - i) >= wpl)
155                              firstword = 0x0;
156                          else
157                              firstword = *(sword + row * wpl + eiter - i);
158                          rnextword = firstword << parbitsxp | lastword >> (32 - parbitsxp);
159                          lastword = firstword;
160                          if ((eiter - i - 1) >= wpl)
161                              firstword = 0x0;
162                          else
163                              firstword = *(sword + row * wpl + eiter - i - 1);
164                          rprevword = firstword << parbitsxp | lastword >> (32 - parbitsxp);
165                          for (j = 1; j < 32; j++) {
166                              tempword = (lprevword << j) | (lnextword >> (32 - j));
167                              destword |= tempword;
168                              tempword = (rprevword << j) | (rnextword >> (32 - j));
169                              destword |= tempword;
170                          }
171                          destword |= lprevword;
172                          destword |= lnextword;
173                          destword |= rprevword;
174                          destword |= rnextword;
175                          lastword = firstword;
176                          firstword = secondword;
177                      }
178                      *(dword + pos) = destword;
179                  }\n)
180                      KERNEL(
181  \n__kernel void morphoDilateHor_32word(__global int *sword, __global int *dword, const int halfwidth, const int wpl, const int h, const char isEven) {
182                          const int col = get_global_id(0);
183                          const int row = get_global_id(1);
184                          const unsigned int pos = row * wpl + col;
185                          unsigned int prevword, nextword, currword, tempword;
186                          unsigned int destword;
187                          int i;
188                          if (pos >= (wpl * h))
189                              return;
190                          currword = *(sword + pos);
191                          destword = currword;
192                          if (col == 0)
193                              prevword = 0;
194                          else
195                              prevword = *(sword + pos - 1);
196                          if (col == (wpl - 1))
197                              nextword = 0;
198                          else
199                              nextword = *(sword + pos + 1);
200                          for (i = 1; i <= halfwidth; i++) {
201                              if (i == halfwidth && isEven) {
202                                  tempword = 0x0;
203                              } else {
204                                  tempword = (prevword << (32 - i)) | ((currword >> i));
205                              }
206                              destword |= tempword;
207                              tempword = (currword << i) | (nextword >> (32 - i));
208                              destword |= tempword;
209                          }
210                          *(dword + pos) = destword;
211                      }\n)
212                          KERNEL(
213  \n__kernel void morphoDilateVer(__global int *sword, __global int *dword, const int yp, const int wpl, const int h, const int yn) {
214                              const int col = get_global_id(0);
215                              const int row = get_global_id(1);
216                              const unsigned int pos = row * wpl + col;
217                              unsigned int tempword;
218                              unsigned int destword;
219                              int i, siter, eiter;
220                              if (row >= h || col >= wpl)
221                                  return;
222                              destword = *(sword + pos);
223                              siter = (row - yn) < 0 ? 0 : (row - yn);
224                              eiter = (row >= (h - yp)) ? (h - 1) : (row + yp);
225                              for (i = siter; i <= eiter; i++) {
226                                  tempword = *(sword + i * wpl + col);
227                                  destword |= tempword;
228                              }
229                              *(dword + pos) = destword;
230                          }\n)
231                              KERNEL(
232  \n__kernel void morphoErodeHor_5x5(__global int *sword, __global int *dword, const int wpl, const int h) {
233                                  const unsigned int pos = get_global_id(0);
234                                  unsigned int prevword, nextword, currword, tempword;
235                                  unsigned int destword;
236                                  const int col = pos % wpl;
237                                  if (pos >= (wpl * h))
238                                      return;
239                                  currword = *(sword + pos);
240                                  destword = currword;
241                                  if (col == 0)
242                                      prevword = 0xffffffff;
243                                  else
244                                      prevword = *(sword + pos - 1);
245                                  if (col == (wpl - 1))
246                                      nextword = 0xffffffff;
247                                  else
248                                      nextword = *(sword + pos + 1);
249                                  tempword = (prevword << (31)) | ((currword >> 1));
250                                  destword &= tempword;
251                                  tempword = (currword << 1) | (nextword >> (31));
252                                  destword &= tempword;
253                                  tempword = (prevword << (30)) | ((currword >> 2));
254                                  destword &= tempword;
255                                  tempword = (currword << 2) | (nextword >> (30));
256                                  destword &= tempword;
257                                  *(dword + pos) = destword;
258                              }\n)
259                                  KERNEL(
260  \n__kernel void morphoErodeVer_5x5(__global int *sword, __global int *dword, const int wpl, const int h, const int fwmask, const int lwmask) {
261                                      const int col = get_global_id(0);
262                                      const int row = get_global_id(1);
263                                      const unsigned int pos = row * wpl + col;
264                                      unsigned int tempword;
265                                      unsigned int destword;
266                                      int i;
267                                      if (row >= h || col >= wpl)
268                                          return;
269                                      destword = *(sword + pos);
270                                      if (row < 2 || row >= (h - 2)) {
271                                          destword = 0x0;
272                                      } else {
273                                          i = (row - 2);
274                                          tempword = *(sword + i * wpl + col);
275                                          destword &= tempword;
276                                          i = (row - 1);
277                                          tempword = *(sword + i * wpl + col);
278                                          destword &= tempword;
279                                          i = (row + 1);
280                                          tempword = *(sword + i * wpl + col);
281                                          destword &= tempword;
282                                          i = (row + 2);
283                                          tempword = *(sword + i * wpl + col);
284                                          destword &= tempword;
285                                          if (col == 0) {
286                                              destword &= fwmask;
287                                          }
288                                          if (col == (wpl - 1)) {
289                                              destword &= lwmask;
290                                          }
291                                      }
292                                      *(dword + pos) = destword;
293                                  }\n)
294                                      KERNEL(
<span onclick='openModal()' class='match'>295  \n__kernel void morphoErodeHor(__global int *sword, __global int *dword, const int xp, const int xn, const int wpl, const int h, const char isAsymmetric, const int rwmask, const int lwmask) {
295  \n__kernel void morphoErodeHor(__global int *sword, __global int *dword, const int xp, const int xn, const int wpl, const int h, const char isAsymmetric, const int rwmask, const int lwmask) {
</span>296                                          const int col = get_global_id(0);
297                                          const int row = get_global_id(1);
298                                          const unsigned int pos = row * wpl + col;
299                                          unsigned int parbitsxp, parbitsxn, nwords;
300                                          unsigned int destword, tempword, lastword, currword;
301                                          unsigned int lnextword, lprevword, rnextword, rprevword, firstword, secondword;
302                                          int i, j, siter, eiter;
303                                          if (pos >= (wpl * h) || (xn < 1 && xp < 1))
304                                              return;
305                                          currword = *(sword + pos);
306                                          destword = currword;
307                                          parbitsxp = xp & 31;
308                                          parbitsxn = xn & 31;
309                                          nwords = xp >> 5;
310                                          if (parbitsxp > 0)
311                                              nwords += 1;
312                                          else
313                                              parbitsxp = 31;
314                                          siter = (col - nwords);
315                                          eiter = (col + nwords);
316                                          if (col == 0)
317                                              firstword = 0xffffffff;
318                                          else
319                                              firstword = *(sword + pos - 1);
320                                          if (col == (wpl - 1))
321                                              secondword = 0xffffffff;
322                                          else
323                                              secondword = *(sword + pos + 1);
324                                          for (i = 1; i <= parbitsxp; i++) {
325                                              tempword = (firstword << (32 - i)) | ((currword >> i));
326                                              destword &= tempword;
327                                              tempword = ((i == parbitsxp) && (parbitsxp != parbitsxn)) ? 0xffffffff : (currword << i) | (secondword >> (32 - i));
328                                              destword &= tempword;
329                                          }
330                                          if (nwords == 1) {
331                                              if (xp == 32) {
332                                                  destword &= firstword;
333                                              }
334                                              if (xn == 32) {
335                                                  destword &= secondword;
336                                              }
337                                              if (isAsymmetric) {
338                                                  if (col == 0)
339                                                      destword &= rwmask;
340                                                  if (col == (wpl - 1))
341                                                      destword &= lwmask;
342                                              }
343                                              *(dword + pos) = destword;
344                                              return;
345                                          }
346                                          if (siter < 0)
347                                              firstword = 0xffffffff;
348                                          else
349                                              firstword = *(sword + row * wpl + siter);
350                                          if (eiter >= wpl)
351                                              lastword = 0xffffffff;
352                                          else
353                                              lastword = *(sword + row * wpl + eiter);
354                                          for (i = 1; i < nwords; i++) {
355                                              if ((siter + i) < 0)
356                                                  secondword = 0xffffffff;
357                                              else
358                                                  secondword = *(sword + row * wpl + siter + i);
359                                              lprevword = firstword << (32 - parbitsxp) | secondword >> (parbitsxp);
360                                              firstword = secondword;
361                                              if ((siter + i + 1) < 0)
362                                                  secondword = 0xffffffff;
363                                              else
364                                                  secondword = *(sword + row * wpl + siter + i + 1);
365                                              lnextword = firstword << (32 - parbitsxp) | secondword >> (parbitsxp);
366                                              if ((eiter - i) >= wpl)
367                                                  firstword = 0xffffffff;
368                                              else
369                                                  firstword = *(sword + row * wpl + eiter - i);
370                                              rnextword = firstword << parbitsxn | lastword >> (32 - parbitsxn);
371                                              lastword = firstword;
372                                              if ((eiter - i - 1) >= wpl)
373                                                  firstword = 0xffffffff;
374                                              else
375                                                  firstword = *(sword + row * wpl + eiter - i - 1);
376                                              rprevword = firstword << parbitsxn | lastword >> (32 - parbitsxn);
377                                              for (j = 0; j < 32; j++) {
378                                                  tempword = (lprevword << j) | (lnextword >> (32 - j));
379                                                  destword &= tempword;
380                                                  tempword = (rprevword << j) | (rnextword >> (32 - j));
381                                                  destword &= tempword;
382                                              }
383                                              destword &= lprevword;
384                                              destword &= lnextword;
385                                              destword &= rprevword;
386                                              destword &= rnextword;
387                                              lastword = firstword;
388                                              firstword = secondword;
389                                          }
390                                          if (isAsymmetric) {
391                                              if (col < (nwords - 1))
392                                                  destword = 0x0;
393                                              else if (col == (nwords - 1))
394                                                  destword &= rwmask;
395                                              else if (col > (wpl - nwords))
396                                                  destword = 0x0;
397                                              else if (col == (wpl - nwords))
398                                                  destword &= lwmask;
399                                          }
400                                          *(dword + pos) = destword;
401                                      }\n)
402                                          KERNEL(
403  \n__kernel void morphoErodeHor_32word(__global int *sword, __global int *dword, const int halfwidth, const int wpl, const int h, const char clearBoundPixH, const int rwmask, const int lwmask, const char isEven) {
404                                              const int col = get_global_id(0);
405                                              const int row = get_global_id(1);
406                                              const unsigned int pos = row * wpl + col;
407                                              unsigned int prevword, nextword, currword, tempword, destword;
408                                              int i;
409                                              if (pos >= (wpl * h))
410                                                  return;
411                                              currword = *(sword + pos);
412                                              destword = currword;
413                                              if (col == 0)
414                                                  prevword = 0xffffffff;
415                                              else
416                                                  prevword = *(sword + pos - 1);
417                                              if (col == (wpl - 1))
418                                                  nextword = 0xffffffff;
419                                              else
420                                                  nextword = *(sword + pos + 1);
421                                              for (i = 1; i <= halfwidth; i++) {
422                                                  tempword = (prevword << (32 - i)) | ((currword >> i));
423                                                  destword &= tempword;
424                                                  if (i == halfwidth && isEven) {
425                                                      tempword = 0xffffffff;
426                                                  } else {
427                                                      tempword = (currword << i) | (nextword >> (32 - i));
428                                                  }
429                                                  destword &= tempword;
430                                              }
431                                              if (clearBoundPixH) {
432                                                  if (col == 0) {
433                                                      destword &= rwmask;
434                                                  } else if (col == (wpl - 1)) {
435                                                      destword &= lwmask;
436                                                  }
437                                              }
438                                              *(dword + pos) = destword;
439                                          }\n)
440                                              KERNEL(
441  \n__kernel void morphoErodeVer(__global int *sword, __global int *dword, const int yp, const int wpl, const int h, const char clearBoundPixV, const int yn) {
442                                                  const int col = get_global_id(0);
443                                                  const int row = get_global_id(1);
444                                                  const unsigned int pos = row * wpl + col;
445                                                  unsigned int tempword, destword;
446                                                  int i, siter, eiter;
447                                                  if (row >= h || col >= wpl)
448                                                      return;
449                                                  destword = *(sword + pos);
450                                                  siter = (row - yp) < 0 ? 0 : (row - yp);
451                                                  eiter = (row >= (h - yn)) ? (h - 1) : (row + yn);
452                                                  for (i = siter; i <= eiter; i++) {
453                                                      tempword = *(sword + i * wpl + col);
454                                                      destword &= tempword;
455                                                  }
456                                                  if (clearBoundPixV && ((row < yp) || ((h - row) <= yn))) {
457                                                      destword = 0x0;
458                                                  }
459                                                  *(dword + pos) = destword;
460                                              }\n)
461      KERNEL(
462  \n #define HIST_REDUNDANCY 256\n
463  \n #define GROUP_SIZE 256\n
464  \n #define HIST_SIZE 256\n
465  \n #define NUM_CHANNELS 4\n
466  \n #define HR_UNROLL_SIZE 8 \n
467  \n #define HR_UNROLL_TYPE uchar8 \n
468          __attribute__((reqd_work_group_size(256, 1, 1))) __kernel void kernel_HistogramRectAllChannels(__global const uchar8 *data, uint numPixels, __global uint *histBuffer) {
469              uchar8 pixels;
470              int threadOffset = get_global_id(0) % HIST_REDUNDANCY;
471              for (uint pc = get_global_id(0); pc < numPixels * NUM_CHANNELS / HR_UNROLL_SIZE; pc += get_global_size(0)) {
472                  pixels = data[pc];
473                  atomic_inc(&histBuffer[0 * HIST_SIZE * HIST_REDUNDANCY + pixels.s0 * HIST_REDUNDANCY + threadOffset]);  
474                  atomic_inc(&histBuffer[0 * HIST_SIZE * HIST_REDUNDANCY + pixels.s4 * HIST_REDUNDANCY + threadOffset]);  
475                  atomic_inc(&histBuffer[1 * HIST_SIZE * HIST_REDUNDANCY + pixels.s1 * HIST_REDUNDANCY + threadOffset]);  
476                  atomic_inc(&histBuffer[1 * HIST_SIZE * HIST_REDUNDANCY + pixels.s5 * HIST_REDUNDANCY + threadOffset]);  
477                  atomic_inc(&histBuffer[2 * HIST_SIZE * HIST_REDUNDANCY + pixels.s2 * HIST_REDUNDANCY + threadOffset]);  
478                  atomic_inc(&histBuffer[2 * HIST_SIZE * HIST_REDUNDANCY + pixels.s6 * HIST_REDUNDANCY + threadOffset]);  
479                  atomic_inc(&histBuffer[3 * HIST_SIZE * HIST_REDUNDANCY + pixels.s3 * HIST_REDUNDANCY + threadOffset]);  
480                  atomic_inc(&histBuffer[3 * HIST_SIZE * HIST_REDUNDANCY + pixels.s7 * HIST_REDUNDANCY + threadOffset]);  
481              }
482          })
483          KERNEL(
484              __attribute__((reqd_work_group_size(256, 1, 1))) __kernel void kernel_HistogramRectOneChannel(__global const uchar8 *data, uint numPixels, __global uint *histBuffer) {
485                  uchar8 pixels;
486                  int threadOffset = get_global_id(0) % HIST_REDUNDANCY;
487                  for (uint pc = get_global_id(0); pc < numPixels / HR_UNROLL_SIZE; pc += get_global_size(0)) {
488                      pixels = data[pc];
489                      atomic_inc(&histBuffer[pixels.s0 * HIST_REDUNDANCY + threadOffset]);
490                      atomic_inc(&histBuffer[pixels.s1 * HIST_REDUNDANCY + threadOffset]);
491                      atomic_inc(&histBuffer[pixels.s2 * HIST_REDUNDANCY + threadOffset]);
492                      atomic_inc(&histBuffer[pixels.s3 * HIST_REDUNDANCY + threadOffset]);
493                      atomic_inc(&histBuffer[pixels.s4 * HIST_REDUNDANCY + threadOffset]);
494                      atomic_inc(&histBuffer[pixels.s5 * HIST_REDUNDANCY + threadOffset]);
495                      atomic_inc(&histBuffer[pixels.s6 * HIST_REDUNDANCY + threadOffset]);
496                      atomic_inc(&histBuffer[pixels.s7 * HIST_REDUNDANCY + threadOffset]);
497                  }
498              })
499      KERNEL(__attribute__((reqd_work_group_size(256, 1, 1))) __kernel void kernel_HistogramRectAllChannelsReduction(int n,  
500                                                                                                                     __global uint *histBuffer, __global int *histResult) {
501          int channel = get_group_id(0) / HIST_SIZE;
502          int bin = get_group_id(0) % HIST_SIZE;
503          int value = 0;
504          for (uint i = get_local_id(0); i < HIST_REDUNDANCY; i += GROUP_SIZE) {
505              value += histBuffer[channel * HIST_SIZE * HIST_REDUNDANCY + bin * HIST_REDUNDANCY + i];
506          }
507          __local int localHist[GROUP_SIZE];
508          localHist[get_local_id(0)] = value;
509          barrier(CLK_LOCAL_MEM_FENCE);
510          for (int stride = GROUP_SIZE / 2; stride >= 1; stride /= 2) {
511              if (get_local_id(0) < stride) {
512                  value = localHist[get_local_id(0) + stride];
513              }
514              barrier(CLK_LOCAL_MEM_FENCE);
515              if (get_local_id(0) < stride) {
516                  localHist[get_local_id(0)] += value;
517              }
518              barrier(CLK_LOCAL_MEM_FENCE);
519          }
520          if (get_local_id(0) == 0) {
521              histResult[get_group_id(0)] = localHist[0];
522          }
523      }  
524             )
525          KERNEL(
526              __attribute__((reqd_work_group_size(256, 1, 1))) __kernel void kernel_HistogramRectOneChannelReduction(int n,  
527                                                                                                                     __global uint *histBuffer, __global int *histResult) {
528                  int bin = get_group_id(0) % HIST_SIZE;
529                  int value = 0;
530                  for (int i = get_local_id(0); i < HIST_REDUNDANCY; i += GROUP_SIZE) {
531                      value += histBuffer[bin * HIST_REDUNDANCY + i];
532                  }
533                  __local int localHist[GROUP_SIZE];
534                  localHist[get_local_id(0)] = value;
535                  barrier(CLK_LOCAL_MEM_FENCE);
536                  for (int stride = GROUP_SIZE / 2; stride >= 1; stride /= 2) {
537                      if (get_local_id(0) < stride) {
538                          value = localHist[get_local_id(0) + stride];
539                      }
540                      barrier(CLK_LOCAL_MEM_FENCE);
541                      if (get_local_id(0) < stride) {
542                          localHist[get_local_id(0)] += value;
543                      }
544                      barrier(CLK_LOCAL_MEM_FENCE);
545                  }
546                  if (get_local_id(0) == 0) {
547                      histResult[get_group_id(0)] = localHist[0];
548                  }
549              }  
550              )
551      KERNEL(
552  \n #define CHAR_VEC_WIDTH 4 \n
553  \n #define PIXELS_PER_WORD 32 \n
554  \n #define PIXELS_PER_BURST 8 \n
555  \n #define BURSTS_PER_WORD (PIXELS_PER_WORD)/(PIXELS_PER_BURST) \n
556  \n typedef union {
557          uchar s[PIXELS_PER_BURST * NUM_CHANNELS];
558          uchar4 v[(PIXELS_PER_BURST * NUM_CHANNELS) / CHAR_VEC_WIDTH];
559      } charVec;
560          __attribute__((reqd_work_group_size(256, 1, 1))) __kernel void kernel_ThresholdRectToPix(__global const uchar4 *imageData, int height, int width,
561                                                                                                   int wpl,  
562                                                                                                   __global int *thresholds, __global int *hi_values, __global int *pix) {
563              int pThresholds[NUM_CHANNELS];
564              int pHi_Values[NUM_CHANNELS];
565              for (int i = 0; i < NUM_CHANNELS; i++) {
566                  pThresholds[i] = thresholds[i];
567                  pHi_Values[i] = hi_values[i];
568              }
569              for (uint w = get_global_id(0); w < wpl * height; w += get_global_size(0)) {
570                  unsigned int word = 0;  
571                  for (int b = 0; b < BURSTS_PER_WORD; b++) {
572                      charVec pixels;
573                      int offset = (w / wpl) * width;
574                      offset += (w % wpl) * PIXELS_PER_WORD;
575                      offset += b * PIXELS_PER_BURST;
576                      for (int i = 0; i < PIXELS_PER_BURST; ++i)
577                          pixels.v[i] = imageData[offset + i];
578                      for (int p = 0; p < PIXELS_PER_BURST; p++) {
579                          for (int c = 0; c < NUM_CHANNELS; c++) {
580                              unsigned char pixChan = pixels.s[p * NUM_CHANNELS + c];
581                              if (pHi_Values[c] >= 0 && (pixChan > pThresholds[c]) == (pHi_Values[c] == 0)) {
582                                  const uint kTopBit = 0x80000000;
583                                  word |= (kTopBit >> ((b * PIXELS_PER_BURST + p) & 31));
584                              }
585                          }
586                      }
587                  }
588                  pix[w] = word;
589              }
590          }
591  \n #define CHAR_VEC_WIDTH 8 \n
592  \n #define PIXELS_PER_WORD 32 \n
593  \n #define PIXELS_PER_BURST 8 \n
594  \n #define BURSTS_PER_WORD (PIXELS_PER_WORD) / (PIXELS_PER_BURST) \n
595  \n typedef union {
596              uchar s[PIXELS_PER_BURST * 1];
597              uchar8 v[(PIXELS_PER_BURST * 1) / CHAR_VEC_WIDTH];
598          } charVec1;
599          __attribute__((reqd_work_group_size(256, 1, 1))) __kernel void kernel_ThresholdRectToPix_OneChan(__global const uchar8 *imageData, int height, int width,
600                                                                                                           int wpl,  
601                                                                                                           __global int *thresholds, __global int *hi_values, __global int *pix) {
602              int pThresholds[1];
603              int pHi_Values[1];
604              for (int i = 0; i < 1; i++) {
605                  pThresholds[i] = thresholds[i];
606                  pHi_Values[i] = hi_values[i];
607              }
608              for (uint w = get_global_id(0); w < wpl * height; w += get_global_size(0)) {
609                  unsigned int word = 0;  
610                  for (int b = 0; b < BURSTS_PER_WORD; b++) {
611                      charVec1 pixels;
612                      pixels.v[0] = imageData[w * BURSTS_PER_WORD + b + 0];
613                      for (int p = 0; p < PIXELS_PER_BURST; p++) {
614                          int idx =
615  \n #ifdef __ENDIAN_LITTLE__\n
616                              p ^
617                              3;
618                          \n #else \n
619                              p;
620                          \n #endif \n unsigned char pixChan = pixels.s[idx];
621                          if (pHi_Values[0] >= 0 && (pixChan > pThresholds[0]) == (pHi_Values[0] == 0)) {
622                              const uint kTopBit = 0x80000000;
623                              word |= (kTopBit >> ((b * PIXELS_PER_BURST + p) & 31));
624                          }
625                      }
626                  }
627                  pix[w] = word;
628              }
629          })
630      ;  
631  #  endif 
632  #endif   
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agm.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-oclkernels.h</div>
                <div class="column column_space"><pre><code>15    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const PUNGraph& Graph, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
15    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const PUNGraph& Graph, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
</pre></code></div>
                <div class="column column_space"><pre><code>295  \n__kernel void morphoErodeHor(__global int *sword, __global int *dword, const int xp, const int xn, const int wpl, const int h, const char isAsymmetric, const int rwmask, const int lwmask) {
295  \n__kernel void morphoErodeHor(__global int *sword, __global int *dword, const int xp, const int xn, const int wpl, const int h, const char isAsymmetric, const int rwmask, const int lwmask) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    