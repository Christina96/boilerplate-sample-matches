
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 46, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-locks_24.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/lib/locks.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <boost/format.hpp>
5  #include <cstring>
6  #include <iostream>
7  #if USING_NANO_TIMED_LOCKS
8  namespace nano
9  {
10  template <typename Mutex>
11  void output (char const * str, std::chrono::milliseconds time, Mutex & mutex)
12  {
13  	static nano::mutex cout_mutex;
14  	auto stacktrace = nano::generate_stacktrace ();
15  	std::lock_guard guard (cout_mutex);
16  	std::cout << (boost::format ("%1% Mutex %2% %3% for %4%ms\n%5%") % std::addressof (mutex) % mutex.get_name () % str % time.count () % stacktrace).str ()
17  			  << std::endl;
18  }
19  template <typename Mutex>
20  void output_if_held_long_enough (nano::timer<std::chrono::milliseconds> & timer, Mutex & mutex)
21  {
22  	auto time_held = timer.since_start ();
23  	if (time_held >= std::chrono::milliseconds (NANO_TIMED_LOCKS))
24  	{
<span onclick='openModal()' class='match'>25  		std::unique_lock lk (nano::mutex_to_filter_mutex);
26  		if (!nano::any_filters_registered () || (nano::mutex_to_filter == &mutex))
27  		{
28  			lk.unlock ();
29  			output ("held", time_held, mutex);
30  		}
31  	}
32  	if (timer.current_state () != nano::timer_state::stopped)
</span>33  	{
34  		timer.stop ();
35  	}
36  }
37  #ifndef NANO_TIMED_LOCKS_IGNORE_BLOCKED
38  template <typename Mutex>
39  void output_if_blocked_long_enough (nano::timer<std::chrono::milliseconds> & timer, Mutex & mutex)
40  {
41  	auto time_blocked = timer.since_start ();
42  	if (time_blocked >= std::chrono::milliseconds (NANO_TIMED_LOCKS))
43  	{
44  		std::unique_lock lk (nano::mutex_to_filter_mutex);
45  		if (!nano::any_filters_registered () || (nano::mutex_to_filter == &mutex))
46  		{
47  			lk.unlock ();
48  			output ("blocked", time_blocked, mutex);
49  		}
50  	}
51  }
52  #endif
53  lock_guard<nano::mutex>::lock_guard (nano::mutex & mutex) :
54  	mut (mutex)
55  {
56  	timer.start ();
57  	mut.lock ();
58  #ifndef NANO_TIMED_LOCKS_IGNORE_BLOCKED
59  	output_if_blocked_long_enough (timer, mut);
60  #endif
61  }
62  lock_guard<nano::mutex>::~lock_guard () noexcept
63  {
64  	mut.unlock ();
65  	output_if_held_long_enough (timer, mut);
66  }
67  template <typename Mutex, typename U>
68  unique_lock<Mutex, U>::unique_lock (Mutex & mutex) :
69  	mut (std::addressof (mutex))
70  {
71  	lock_impl ();
72  }
73  template <typename Mutex, typename U>
74  unique_lock<Mutex, U>::unique_lock (Mutex & mutex, std::defer_lock_t) noexcept :
75  	mut (std::addressof (mutex))
76  {
77  }
78  template <typename Mutex, typename U>
79  void unique_lock<Mutex, U>::lock_impl ()
80  {
81  	timer.start ();
82  	mut->lock ();
83  	owns = true;
84  #ifndef NANO_TIMED_LOCKS_IGNORE_BLOCKED
85  	output_if_blocked_long_enough (timer, *mut);
86  #endif
87  }
88  template <typename Mutex, typename U>
89  unique_lock<Mutex, U> & unique_lock<Mutex, U>::operator= (unique_lock<Mutex, U> && other) noexcept
90  {
91  	if (this != std::addressof (other))
92  	{
93  		if (owns)
94  		{
95  			mut->unlock ();
96  			owns = false;
97  			output_if_held_long_enough (timer, *mut);
98  		}
99  		mut = other.mut;
100  		owns = other.owns;
101  		timer = other.timer;
102  		other.mut = nullptr;
103  		other.owns = false;
104  	}
105  	return *this;
106  }
107  template <typename Mutex, typename U>
108  unique_lock<Mutex, U>::~unique_lock () noexcept
109  {
110  	if (owns)
111  	{
112  		mut->unlock ();
113  		owns = false;
114  		output_if_held_long_enough (timer, *mut);
115  	}
116  }
117  template <typename Mutex, typename U>
118  void unique_lock<Mutex, U>::lock ()
119  {
120  	validate ();
121  	lock_impl ();
122  }
123  template <typename Mutex, typename U>
124  bool unique_lock<Mutex, U>::try_lock ()
125  {
126  	validate ();
127  	owns = mut->try_lock ();
128  	if (owns)
129  	{
130  		timer.start ();
131  	}
132  	return owns;
133  }
134  template <typename Mutex, typename U>
135  void unique_lock<Mutex, U>::unlock ()
136  {
137  	if (!mut || !owns)
138  	{
139  		throw (std::system_error (std::make_error_code (std::errc::operation_not_permitted)));
140  	}
141  	mut->unlock ();
142  	owns = false;
143  	output_if_held_long_enough (timer, *mut);
144  }
145  template <typename Mutex, typename U>
146  bool unique_lock<Mutex, U>::owns_lock () const noexcept
147  {
148  	return owns;
149  }
150  template <typename Mutex, typename U>
151  unique_lock<Mutex, U>::operator bool () const noexcept
152  {
153  	return owns;
154  }
155  template <typename Mutex, typename U>
156  Mutex * unique_lock<Mutex, U>::mutex () const noexcept
157  {
158  	return mut;
159  }
160  template <typename Mutex, typename U>
161  void unique_lock<Mutex, U>::validate () const
162  {
163  	if (!mut)
164  	{
165  		throw (std::system_error (std::make_error_code (std::errc::operation_not_permitted)));
166  	}
167  	if (owns)
168  	{
169  		throw (std::system_error (std::make_error_code (std::errc::resource_deadlock_would_occur)));
170  	}
171  }
172  template class unique_lock<nano::mutex>;
173  void condition_variable::notify_one () noexcept
174  {
175  	cnd.notify_one ();
176  }
177  void condition_variable::notify_all () noexcept
178  {
179  	cnd.notify_all ();
180  }
181  void condition_variable::wait (nano::unique_lock<nano::mutex> & lk)
182  {
183  	if (!lk.mut || !lk.owns)
184  	{
185  		throw (std::system_error (std::make_error_code (std::errc::operation_not_permitted)));
186  	}
187  	output_if_held_long_enough (lk.timer, *lk.mut);
188  	lk.timer.start ();
189  	cnd.wait (lk);
190  	lk.timer.restart ();
191  }
192  nano::mutex * mutex_to_filter{ nullptr };
193  nano::mutex mutex_to_filter_mutex;
194  bool should_be_filtered (char const * name)
195  {
196  	return std::strcmp (name, xstr (NANO_TIMED_LOCKS_FILTER)) == 0;
197  }
198  bool any_filters_registered ()
199  {
200  	return std::strcmp ("", xstr (NANO_TIMED_LOCKS_FILTER)) != 0;
201  }
202  }
203  #endif
204  char const * nano::mutex_identifier (mutexes mutex)
205  {
206  	switch (mutex)
207  	{
208  		case mutexes::active:
209  			return "active";
210  		case mutexes::block_arrival:
211  			return "block_arrival";
212  		case mutexes::block_processor:
213  			return "block_processor";
214  		case mutexes::block_uniquer:
215  			return "block_uniquer";
216  		case mutexes::blockstore_cache:
217  			return "blockstore_cache";
218  		case mutexes::confirmation_height_processor:
219  			return "confirmation_height_processor";
220  		case mutexes::election_winner_details:
221  			return "election_winner_details";
222  		case mutexes::gap_cache:
223  			return "gap_cache";
224  		case mutexes::network_filter:
225  			return "network_filter";
226  		case mutexes::observer_set:
227  			return "observer_set";
228  		case mutexes::request_aggregator:
229  			return "request_aggregator";
230  		case mutexes::state_block_signature_verification:
231  			return "state_block_signature_verification";
232  		case mutexes::telemetry:
233  			return "telemetry";
234  		case mutexes::vote_generator:
235  			return "vote_generator";
236  		case mutexes::vote_processor:
237  			return "vote_processor";
238  		case mutexes::vote_uniquer:
239  			return "vote_uniquer";
240  		case mutexes::votes_cache:
241  			return "votes_cache";
242  		case mutexes::work_pool:
243  			return "work_pool";
244  	}
245  	throw std::runtime_error ("Invalid mutexes enum specified");
246  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-locks_24.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/lib/locks.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <boost/format.hpp>
5  #include <cstring>
6  #include <iostream>
7  #if USING_NANO_TIMED_LOCKS
8  namespace nano
9  {
10  template <typename Mutex>
11  void output (char const * str, std::chrono::milliseconds time, Mutex & mutex)
12  {
13  	static nano::mutex cout_mutex;
14  	auto stacktrace = nano::generate_stacktrace ();
15  	std::lock_guard guard (cout_mutex);
16  	std::cout << (boost::format ("%1% Mutex %2% %3% for %4%ms\n%5%") % std::addressof (mutex) % mutex.get_name () % str % time.count () % stacktrace).str ()
17  			  << std::endl;
18  }
19  template <typename Mutex>
20  void output_if_held_long_enough (nano::timer<std::chrono::milliseconds> & timer, Mutex & mutex)
21  {
22  	auto time_held = timer.since_start ();
23  	if (time_held >= std::chrono::milliseconds (NANO_TIMED_LOCKS))
24  	{
25  		std::unique_lock lk (nano::mutex_to_filter_mutex);
26  		if (!nano::any_filters_registered () || (nano::mutex_to_filter == &mutex))
27  		{
28  			lk.unlock ();
29  			output ("held", time_held, mutex);
30  		}
31  	}
32  	if (timer.current_state () != nano::timer_state::stopped)
33  	{
34  		timer.stop ();
35  	}
36  }
37  #ifndef NANO_TIMED_LOCKS_IGNORE_BLOCKED
38  template <typename Mutex>
39  void output_if_blocked_long_enough (nano::timer<std::chrono::milliseconds> & timer, Mutex & mutex)
40  {
41  	auto time_blocked = timer.since_start ();
42  	if (time_blocked >= std::chrono::milliseconds (NANO_TIMED_LOCKS))
43  	{
<span onclick='openModal()' class='match'>44  		std::unique_lock lk (nano::mutex_to_filter_mutex);
45  		if (!nano::any_filters_registered () || (nano::mutex_to_filter == &mutex))
46  		{
47  			lk.unlock ();
48  			output ("blocked", time_blocked, mutex);
49  		}
50  	}
51  }
</span>52  #endif
53  lock_guard<nano::mutex>::lock_guard (nano::mutex & mutex) :
54  	mut (mutex)
55  {
56  	timer.start ();
57  	mut.lock ();
58  #ifndef NANO_TIMED_LOCKS_IGNORE_BLOCKED
59  	output_if_blocked_long_enough (timer, mut);
60  #endif
61  }
62  lock_guard<nano::mutex>::~lock_guard () noexcept
63  {
64  	mut.unlock ();
65  	output_if_held_long_enough (timer, mut);
66  }
67  template <typename Mutex, typename U>
68  unique_lock<Mutex, U>::unique_lock (Mutex & mutex) :
69  	mut (std::addressof (mutex))
70  {
71  	lock_impl ();
72  }
73  template <typename Mutex, typename U>
74  unique_lock<Mutex, U>::unique_lock (Mutex & mutex, std::defer_lock_t) noexcept :
75  	mut (std::addressof (mutex))
76  {
77  }
78  template <typename Mutex, typename U>
79  void unique_lock<Mutex, U>::lock_impl ()
80  {
81  	timer.start ();
82  	mut->lock ();
83  	owns = true;
84  #ifndef NANO_TIMED_LOCKS_IGNORE_BLOCKED
85  	output_if_blocked_long_enough (timer, *mut);
86  #endif
87  }
88  template <typename Mutex, typename U>
89  unique_lock<Mutex, U> & unique_lock<Mutex, U>::operator= (unique_lock<Mutex, U> && other) noexcept
90  {
91  	if (this != std::addressof (other))
92  	{
93  		if (owns)
94  		{
95  			mut->unlock ();
96  			owns = false;
97  			output_if_held_long_enough (timer, *mut);
98  		}
99  		mut = other.mut;
100  		owns = other.owns;
101  		timer = other.timer;
102  		other.mut = nullptr;
103  		other.owns = false;
104  	}
105  	return *this;
106  }
107  template <typename Mutex, typename U>
108  unique_lock<Mutex, U>::~unique_lock () noexcept
109  {
110  	if (owns)
111  	{
112  		mut->unlock ();
113  		owns = false;
114  		output_if_held_long_enough (timer, *mut);
115  	}
116  }
117  template <typename Mutex, typename U>
118  void unique_lock<Mutex, U>::lock ()
119  {
120  	validate ();
121  	lock_impl ();
122  }
123  template <typename Mutex, typename U>
124  bool unique_lock<Mutex, U>::try_lock ()
125  {
126  	validate ();
127  	owns = mut->try_lock ();
128  	if (owns)
129  	{
130  		timer.start ();
131  	}
132  	return owns;
133  }
134  template <typename Mutex, typename U>
135  void unique_lock<Mutex, U>::unlock ()
136  {
137  	if (!mut || !owns)
138  	{
139  		throw (std::system_error (std::make_error_code (std::errc::operation_not_permitted)));
140  	}
141  	mut->unlock ();
142  	owns = false;
143  	output_if_held_long_enough (timer, *mut);
144  }
145  template <typename Mutex, typename U>
146  bool unique_lock<Mutex, U>::owns_lock () const noexcept
147  {
148  	return owns;
149  }
150  template <typename Mutex, typename U>
151  unique_lock<Mutex, U>::operator bool () const noexcept
152  {
153  	return owns;
154  }
155  template <typename Mutex, typename U>
156  Mutex * unique_lock<Mutex, U>::mutex () const noexcept
157  {
158  	return mut;
159  }
160  template <typename Mutex, typename U>
161  void unique_lock<Mutex, U>::validate () const
162  {
163  	if (!mut)
164  	{
165  		throw (std::system_error (std::make_error_code (std::errc::operation_not_permitted)));
166  	}
167  	if (owns)
168  	{
169  		throw (std::system_error (std::make_error_code (std::errc::resource_deadlock_would_occur)));
170  	}
171  }
172  template class unique_lock<nano::mutex>;
173  void condition_variable::notify_one () noexcept
174  {
175  	cnd.notify_one ();
176  }
177  void condition_variable::notify_all () noexcept
178  {
179  	cnd.notify_all ();
180  }
181  void condition_variable::wait (nano::unique_lock<nano::mutex> & lk)
182  {
183  	if (!lk.mut || !lk.owns)
184  	{
185  		throw (std::system_error (std::make_error_code (std::errc::operation_not_permitted)));
186  	}
187  	output_if_held_long_enough (lk.timer, *lk.mut);
188  	lk.timer.start ();
189  	cnd.wait (lk);
190  	lk.timer.restart ();
191  }
192  nano::mutex * mutex_to_filter{ nullptr };
193  nano::mutex mutex_to_filter_mutex;
194  bool should_be_filtered (char const * name)
195  {
196  	return std::strcmp (name, xstr (NANO_TIMED_LOCKS_FILTER)) == 0;
197  }
198  bool any_filters_registered ()
199  {
200  	return std::strcmp ("", xstr (NANO_TIMED_LOCKS_FILTER)) != 0;
201  }
202  }
203  #endif
204  char const * nano::mutex_identifier (mutexes mutex)
205  {
206  	switch (mutex)
207  	{
208  		case mutexes::active:
209  			return "active";
210  		case mutexes::block_arrival:
211  			return "block_arrival";
212  		case mutexes::block_processor:
213  			return "block_processor";
214  		case mutexes::block_uniquer:
215  			return "block_uniquer";
216  		case mutexes::blockstore_cache:
217  			return "blockstore_cache";
218  		case mutexes::confirmation_height_processor:
219  			return "confirmation_height_processor";
220  		case mutexes::election_winner_details:
221  			return "election_winner_details";
222  		case mutexes::gap_cache:
223  			return "gap_cache";
224  		case mutexes::network_filter:
225  			return "network_filter";
226  		case mutexes::observer_set:
227  			return "observer_set";
228  		case mutexes::request_aggregator:
229  			return "request_aggregator";
230  		case mutexes::state_block_signature_verification:
231  			return "state_block_signature_verification";
232  		case mutexes::telemetry:
233  			return "telemetry";
234  		case mutexes::vote_generator:
235  			return "vote_generator";
236  		case mutexes::vote_processor:
237  			return "vote_processor";
238  		case mutexes::vote_uniquer:
239  			return "vote_uniquer";
240  		case mutexes::votes_cache:
241  			return "votes_cache";
242  		case mutexes::work_pool:
243  			return "work_pool";
244  	}
245  	throw std::runtime_error ("Invalid mutexes enum specified");
246  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-locks_24.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-locks_24.cpp</div>
                </div>
                <div class="column column_space"><pre><code>25  		std::unique_lock lk (nano::mutex_to_filter_mutex);
26  		if (!nano::any_filters_registered () || (nano::mutex_to_filter == &mutex))
27  		{
28  			lk.unlock ();
29  			output ("held", time_held, mutex);
30  		}
31  	}
32  	if (timer.current_state () != nano::timer_state::stopped)
</pre></code></div>
                <div class="column column_space"><pre><code>44  		std::unique_lock lk (nano::mutex_to_filter_mutex);
45  		if (!nano::any_filters_registered () || (nano::mutex_to_filter == &mutex))
46  		{
47  			lk.unlock ();
48  			output ("blocked", time_blocked, mutex);
49  		}
50  	}
51  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    