
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatWin.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstring>
4  #include <cstdio>
5  #include <cstdarg>
6  #include <ctime>
7  #include <cmath>
8  #include <climits>
9  #include <string_view>
10  #include <vector>
11  #include <map>
12  #include <optional>
13  #include <algorithm>
14  #include <iterator>
15  #include <memory>
16  #include <mutex>
17  #if !defined(NOMINMAX)
18  #define NOMINMAX
19  #endif
20  #undef _WIN32_WINNT
21  #define _WIN32_WINNT 0x0A00
22  #undef WINVER
23  #define WINVER 0x0A00
24  #define WIN32_LEAN_AND_MEAN 1
25  #include <windows.h>
26  #include <commctrl.h>
27  #include <richedit.h>
28  #include <windowsx.h>
29  #include <shellscalingapi.h>
30  #if !defined(DISABLE_D2D)
31  #define USE_D2D 1
32  #endif
33  #if defined(USE_D2D)
34  #include <d2d1.h>
35  #include <dwrite.h>
36  #endif
37  #include "ScintillaTypes.h"
38  #include "Debugging.h"
39  #include "Geometry.h"
40  #include "Platform.h"
41  #include "XPM.h"
42  #include "UniConversion.h"
43  #include "DBCS.h"
44  #include "WinTypes.h"
45  #include "PlatWin.h"
46  #if defined(__clang__)
47  #pragma clang diagnostic ignored "-Wlanguage-extension-token"
48  #endif
49  using namespace Scintilla;
50  namespace Scintilla::Internal {
51  UINT CodePageFromCharSet(CharacterSet characterSet, UINT documentCodePage) noexcept;
52  #if defined(USE_D2D)
53  IDWriteFactory *pIDWriteFactory = nullptr;
54  ID2D1Factory *pD2DFactory = nullptr;
55  D2D1_DRAW_TEXT_OPTIONS d2dDrawTextOptions = D2D1_DRAW_TEXT_OPTIONS_NONE;
56  static HMODULE hDLLD2D {};
57  static HMODULE hDLLDWrite {};
58  void LoadD2DOnce() noexcept {
59  	DWORD loadLibraryFlags = 0;
60  	HMODULE kernel32 = ::GetModuleHandleW(L"kernel32.dll");
61  	if (kernel32) {
62  		if (::GetProcAddress(kernel32, "SetDefaultDllDirectories")) {
63  			loadLibraryFlags = LOAD_LIBRARY_SEARCH_SYSTEM32;
64  		}
65  	}
66  	typedef HRESULT (WINAPI *D2D1CFSig)(D2D1_FACTORY_TYPE factoryType, REFIID riid,
67  		CONST D2D1_FACTORY_OPTIONS *pFactoryOptions, IUnknown **factory);
68  	typedef HRESULT (WINAPI *DWriteCFSig)(DWRITE_FACTORY_TYPE factoryType, REFIID iid,
69  		IUnknown **factory);
70  	hDLLD2D = ::LoadLibraryEx(TEXT("D2D1.DLL"), 0, loadLibraryFlags);
71  	D2D1CFSig fnD2DCF = DLLFunction<D2D1CFSig>(hDLLD2D, "D2D1CreateFactory");
72  	if (fnD2DCF) {
73  		fnD2DCF(D2D1_FACTORY_TYPE_SINGLE_THREADED,
74  			__uuidof(ID2D1Factory),
75  			nullptr,
76  			reinterpret_cast<IUnknown**>(&pD2DFactory));
77  	}
78  	hDLLDWrite = ::LoadLibraryEx(TEXT("DWRITE.DLL"), 0, loadLibraryFlags);
79  	DWriteCFSig fnDWCF = DLLFunction<DWriteCFSig>(hDLLDWrite, "DWriteCreateFactory");
80  	if (fnDWCF) {
81  		const GUID IID_IDWriteFactory2 = 
82  		{ 0x0439fc60, 0xca44, 0x4994, { 0x8d, 0xee, 0x3a, 0x9a, 0xf7, 0xb7, 0x32, 0xec } };
83  		const HRESULT hr = fnDWCF(DWRITE_FACTORY_TYPE_SHARED,
84  			IID_IDWriteFactory2,
85  			reinterpret_cast<IUnknown**>(&pIDWriteFactory));
86  		if (SUCCEEDED(hr)) {
87  			d2dDrawTextOptions = static_cast<D2D1_DRAW_TEXT_OPTIONS>(0x00000004);
88  		} else {
89  			fnDWCF(DWRITE_FACTORY_TYPE_SHARED,
90  				__uuidof(IDWriteFactory),
91  				reinterpret_cast<IUnknown**>(&pIDWriteFactory));
92  		}
93  	}
94  }
95  bool LoadD2D() {
96  	static std::once_flag once;
97  	std::call_once(once, LoadD2DOnce);
98  	return pIDWriteFactory && pD2DFactory;
99  }
100  #endif
101  void *PointerFromWindow(HWND hWnd) noexcept {
102  	return reinterpret_cast<void *>(::GetWindowLongPtr(hWnd, 0));
103  }
104  void SetWindowPointer(HWND hWnd, void *ptr) noexcept {
105  	::SetWindowLongPtr(hWnd, 0, reinterpret_cast<LONG_PTR>(ptr));
106  }
107  namespace {
108  UINT uSystemDPI = USER_DEFAULT_SCREEN_DPI;
109  using GetDpiForWindowSig = UINT(WINAPI *)(HWND hwnd);
110  GetDpiForWindowSig fnGetDpiForWindow = nullptr;
111  HMODULE hDLLShcore {};
112  using GetDpiForMonitorSig = HRESULT (WINAPI *)(HMONITOR hmonitor, &bsol;*MONITOR_DPI_TYPE*/int dpiType, UINT *dpiX, UINT *dpiY);
113  GetDpiForMonitorSig fnGetDpiForMonitor = nullptr;
114  using GetSystemMetricsForDpiSig = int(WINAPI *)(int nIndex, UINT dpi);
115  GetSystemMetricsForDpiSig fnGetSystemMetricsForDpi = nullptr;
116  using AdjustWindowRectExForDpiSig = BOOL(WINAPI *)(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi);
117  AdjustWindowRectExForDpiSig fnAdjustWindowRectExForDpi = nullptr;
118  using AreDpiAwarenessContextsEqualSig = BOOL(WINAPI *)(DPI_AWARENESS_CONTEXT, DPI_AWARENESS_CONTEXT);
119  AreDpiAwarenessContextsEqualSig fnAreDpiAwarenessContextsEqual = nullptr;
120  using GetWindowDpiAwarenessContextSig = DPI_AWARENESS_CONTEXT(WINAPI *)(HWND);
121  GetWindowDpiAwarenessContextSig fnGetWindowDpiAwarenessContext = nullptr;
122  using GetScaleFactorForMonitorSig = HRESULT(WINAPI *)(HMONITOR, DEVICE_SCALE_FACTOR *);
123  GetScaleFactorForMonitorSig fnGetScaleFactorForMonitor = nullptr;
124  using SetThreadDpiAwarenessContextSig = DPI_AWARENESS_CONTEXT(WINAPI *)(DPI_AWARENESS_CONTEXT);
125  SetThreadDpiAwarenessContextSig fnSetThreadDpiAwarenessContext = nullptr;
126  void LoadDpiForWindow() noexcept {
127  	HMODULE user32 = ::GetModuleHandleW(L"user32.dll");
128  	fnGetDpiForWindow = DLLFunction<GetDpiForWindowSig>(user32, "GetDpiForWindow");
129  	fnGetSystemMetricsForDpi = DLLFunction<GetSystemMetricsForDpiSig>(user32, "GetSystemMetricsForDpi");
130  	fnAdjustWindowRectExForDpi = DLLFunction<AdjustWindowRectExForDpiSig>(user32, "AdjustWindowRectExForDpi");
131  	fnSetThreadDpiAwarenessContext = DLLFunction<SetThreadDpiAwarenessContextSig>(user32, "SetThreadDpiAwarenessContext");
132  	using GetDpiForSystemSig = UINT(WINAPI *)(void);
133  	GetDpiForSystemSig fnGetDpiForSystem = DLLFunction<GetDpiForSystemSig>(user32, "GetDpiForSystem");
134  	if (fnGetDpiForSystem) {
135  		uSystemDPI = fnGetDpiForSystem();
136  	} else {
137  		HDC hdcMeasure = ::CreateCompatibleDC({});
138  		uSystemDPI = ::GetDeviceCaps(hdcMeasure, LOGPIXELSY);
139  		::DeleteDC(hdcMeasure);
140  	}
141  	fnGetWindowDpiAwarenessContext = DLLFunction<GetWindowDpiAwarenessContextSig>(user32, "GetWindowDpiAwarenessContext");
142  	fnAreDpiAwarenessContextsEqual = DLLFunction<AreDpiAwarenessContextsEqualSig>(user32, "AreDpiAwarenessContextsEqual");
143  	hDLLShcore = ::LoadLibraryExW(L"shcore.dll", {}, LOAD_LIBRARY_SEARCH_SYSTEM32);
144  	if (hDLLShcore) {
145  		fnGetScaleFactorForMonitor = DLLFunction<GetScaleFactorForMonitorSig>(hDLLShcore, "GetScaleFactorForMonitor");
146  		fnGetDpiForMonitor = DLLFunction<GetDpiForMonitorSig>(hDLLShcore, "GetDpiForMonitor");
147  	}
148  }
149  HINSTANCE hinstPlatformRes {};
150  constexpr Supports SupportsGDI[] = {
151  	Supports::PixelModification,
152  };
153  constexpr BYTE Win32MapFontQuality(FontQuality extraFontFlag) noexcept {
154  	switch (extraFontFlag & FontQuality::QualityMask) {
155  		case FontQuality::QualityNonAntialiased:
156  			return NONANTIALIASED_QUALITY;
157  		case FontQuality::QualityAntialiased:
158  			return ANTIALIASED_QUALITY;
159  		case FontQuality::QualityLcdOptimized:
160  			return CLEARTYPE_QUALITY;
161  		default:
162  			return DEFAULT_QUALITY;
163  	}
164  }
165  #if defined(USE_D2D)
166  constexpr D2D1_TEXT_ANTIALIAS_MODE DWriteMapFontQuality(FontQuality extraFontFlag) noexcept {
167  	switch (extraFontFlag & FontQuality::QualityMask) {
168  		case FontQuality::QualityNonAntialiased:
169  			return D2D1_TEXT_ANTIALIAS_MODE_ALIASED;
170  		case FontQuality::QualityAntialiased:
171  			return D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE;
172  		case FontQuality::QualityLcdOptimized:
173  			return D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE;
174  		default:
175  			return D2D1_TEXT_ANTIALIAS_MODE_DEFAULT;
176  	}
177  }
178  #endif
179  struct FontWin : public Font {
180  	virtual HFONT HFont() const noexcept = 0;
181  };
182  void SetLogFont(LOGFONTW &lf, const char *faceName, CharacterSet characterSet, XYPOSITION size, FontWeight weight, bool italic, FontQuality extraFontFlag) {
183  	lf = LOGFONTW();
184  	lf.lfHeight = -(std::abs(std::lround(size)));
185  	lf.lfWeight = static_cast<LONG>(weight);
186  	lf.lfItalic = italic ? 1 : 0;
187  	lf.lfCharSet = static_cast<BYTE>(characterSet);
188  	lf.lfQuality = Win32MapFontQuality(extraFontFlag);
189  	UTF16FromUTF8(faceName, lf.lfFaceName, LF_FACESIZE);
190  }
191  struct FontGDI : public FontWin {
192  	HFONT hfont = {};
193  	FontGDI(const FontParameters &fp) {
194  		LOGFONTW lf;
195  		SetLogFont(lf, fp.faceName, fp.characterSet, fp.size, fp.weight, fp.italic, fp.extraFontFlag);
196  		hfont = ::CreateFontIndirectW(&lf);
197  	}
198  	FontGDI(const FontGDI &) = delete;
199  	FontGDI(FontGDI &&) = delete;
200  	FontGDI &operator=(const FontGDI &) = delete;
201  	FontGDI &operator=(FontGDI &&) = delete;
202  	~FontGDI() noexcept override {
203  		if (hfont)
204  			::DeleteObject(hfont);
205  	}
206  	HFONT HFont() const noexcept override {
207  		LOGFONTW lf = {};
208  		if (0 == ::GetObjectW(hfont, sizeof(lf), &lf)) {
209  			return {};
210  		}
211  		return ::CreateFontIndirectW(&lf);
212  	}
213  };
214  #if defined(USE_D2D)
215  struct FontDirectWrite : public FontWin {
216  	IDWriteTextFormat *pTextFormat = nullptr;
217  	FontQuality extraFontFlag = FontQuality::QualityDefault;
218  	CharacterSet characterSet = CharacterSet::Ansi;
219  	FLOAT yAscent = 2.0f;
220  	FLOAT yDescent = 1.0f;
221  	FLOAT yInternalLeading = 0.0f;
222  	FontDirectWrite(const FontParameters &fp) :
223  		extraFontFlag(fp.extraFontFlag),
224  		characterSet(fp.characterSet) {
225  		const std::wstring wsFace = WStringFromUTF8(fp.faceName);
226  		const std::wstring wsLocale = WStringFromUTF8(fp.localeName);
227  		const FLOAT fHeight = static_cast<FLOAT>(fp.size);
228  		const DWRITE_FONT_STYLE style = fp.italic ? DWRITE_FONT_STYLE_ITALIC : DWRITE_FONT_STYLE_NORMAL;
229  		HRESULT hr = pIDWriteFactory->CreateTextFormat(wsFace.c_str(), nullptr,
230  			static_cast<DWRITE_FONT_WEIGHT>(fp.weight),
231  			style,
232  			DWRITE_FONT_STRETCH_NORMAL, fHeight, wsLocale.c_str(), &pTextFormat);
233  		if (hr == E_INVALIDARG) {
234  			hr = pIDWriteFactory->CreateTextFormat(wsFace.c_str(), nullptr,
235  				static_cast<DWRITE_FONT_WEIGHT>(fp.weight),
236  				style,
237  				DWRITE_FONT_STRETCH_NORMAL, fHeight, L"en-us", &pTextFormat);
238  		}
239  		if (SUCCEEDED(hr)) {
240  			pTextFormat->SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP);
241  			IDWriteTextLayout *pTextLayout = nullptr;
242  			hr = pIDWriteFactory->CreateTextLayout(L"X", 1, pTextFormat,
243  					100.0f, 100.0f, &pTextLayout);
244  			if (SUCCEEDED(hr) && pTextLayout) {
245  				constexpr int maxLines = 2;
246  				DWRITE_LINE_METRICS lineMetrics[maxLines]{};
247  				UINT32 lineCount = 0;
248  				hr = pTextLayout->GetLineMetrics(lineMetrics, maxLines, &lineCount);
249  				if (SUCCEEDED(hr)) {
250  					yAscent = lineMetrics[0].baseline;
251  					yDescent = lineMetrics[0].height - lineMetrics[0].baseline;
252  					FLOAT emHeight;
253  					hr = pTextLayout->GetFontSize(0, &emHeight);
254  					if (SUCCEEDED(hr)) {
255  						yInternalLeading = lineMetrics[0].height - emHeight;
256  					}
257  				}
258  				ReleaseUnknown(pTextLayout);
259  				pTextFormat->SetLineSpacing(DWRITE_LINE_SPACING_METHOD_UNIFORM, lineMetrics[0].height, lineMetrics[0].baseline);
260  			}
261  		}
262  	}
263  	FontDirectWrite(const FontDirectWrite &) = delete;
264  	FontDirectWrite(FontDirectWrite &&) = delete;
265  	FontDirectWrite &operator=(const FontDirectWrite &) = delete;
266  	FontDirectWrite &operator=(FontDirectWrite &&) = delete;
267  	~FontDirectWrite() noexcept override {
268  		ReleaseUnknown(pTextFormat);
269  	}
270  	HFONT HFont() const noexcept override {
271  		LOGFONTW lf = {};
272  		const HRESULT hr = pTextFormat->GetFontFamilyName(lf.lfFaceName, LF_FACESIZE);
273  		if (!SUCCEEDED(hr)) {
274  			return {};
275  		}
276  		lf.lfWeight = pTextFormat->GetFontWeight();
277  		lf.lfItalic = pTextFormat->GetFontStyle() == DWRITE_FONT_STYLE_ITALIC;
278  		lf.lfHeight = -static_cast<int>(pTextFormat->GetFontSize());
279  		return ::CreateFontIndirectW(&lf);
280  	}
281  	int CodePageText(int codePage) const noexcept {
282  		if (!(codePage == CpUtf8) && (characterSet != CharacterSet::Ansi)) {
283  			codePage = CodePageFromCharSet(characterSet, codePage);
284  		}
285  		return codePage;
286  	}
287  	static const FontDirectWrite *Cast(const Font *font_) {
288  		const FontDirectWrite *pfm = dynamic_cast<const FontDirectWrite *>(font_);
289  		PLATFORM_ASSERT(pfm);
290  		if (!pfm) {
291  			throw std::runtime_error("SurfaceD2D::SetFont: wrong Font type.");
292  		}
293  		return pfm;
294  	}
295  };
296  #endif
297  }
298  HMONITOR MonitorFromWindowHandleScaling(HWND hWnd) noexcept {
299  	constexpr DWORD monitorFlags = MONITOR_DEFAULTTONEAREST;
300  	if (!fnSetThreadDpiAwarenessContext) {
301  		return ::MonitorFromWindow(hWnd, monitorFlags);
302  	}
303  	const DPI_AWARENESS_CONTEXT oldContext = fnSetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
304  	PLATFORM_ASSERT(oldContext != nullptr);
305  	RECT rect;
306  	::GetWindowRect(hWnd, &rect);
307  	const HMONITOR monitor = ::MonitorFromRect(&rect, monitorFlags);
308  	fnSetThreadDpiAwarenessContext(oldContext);
309  	return monitor;
310  }
311  int GetDeviceScaleFactorWhenGdiScalingActive(HWND hWnd) noexcept {
312  	if (fnAreDpiAwarenessContextsEqual) {
313  		PLATFORM_ASSERT(fnGetWindowDpiAwarenessContext && fnGetScaleFactorForMonitor);
314  		if (fnAreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED, fnGetWindowDpiAwarenessContext(hWnd))) {
315  			const HWND hRootWnd = ::GetAncestor(hWnd, GA_ROOT); 
316  			const HMONITOR hMonitor = MonitorFromWindowHandleScaling(hRootWnd);
317  			DEVICE_SCALE_FACTOR deviceScaleFactor;
318  			if (S_OK == fnGetScaleFactorForMonitor(hMonitor, &deviceScaleFactor))
319  				return (static_cast<int>(deviceScaleFactor) + 99) / 100; 
320  		}
321  	}
322  	return 1;
323  }
324  std::shared_ptr<Font> Font::Allocate(const FontParameters &fp) {
325  #if defined(USE_D2D)
326  	if (fp.technology != Technology::Default) {
327  		return std::make_shared<FontDirectWrite>(fp);
328  	}
329  #endif
330  	return std::make_shared<FontGDI>(fp);
331  }
332  template<typename T, int lengthStandard>
333  class VarBuffer {
334  	T bufferStandard[lengthStandard];
335  public:
336  	T *buffer;
337  	explicit VarBuffer(size_t length) : buffer(nullptr) {
338  		if (length > lengthStandard) {
339  			buffer = new T[length];
340  		} else {
341  			buffer = bufferStandard;
342  		}
343  	}
344  	VarBuffer(const VarBuffer &) = delete;
345  	VarBuffer(VarBuffer &&) = delete;
346  	VarBuffer &operator=(const VarBuffer &) = delete;
347  	VarBuffer &operator=(VarBuffer &&) = delete;
348  	~VarBuffer() noexcept {
349  		if (buffer != bufferStandard) {
350  			delete []buffer;
351  			buffer = nullptr;
352  		}
353  	}
354  };
355  constexpr int stackBufferLength = 400;
356  class TextWide : public VarBuffer<wchar_t, stackBufferLength> {
357  public:
358  	int tlen;	
359  	TextWide(std::string_view text, int codePage) :
360  		VarBuffer<wchar_t, stackBufferLength>(text.length()) {
361  		if (codePage == CpUtf8) {
362  			tlen = static_cast<int>(UTF16FromUTF8(text, buffer, text.length()));
363  		} else {
364  			tlen = ::MultiByteToWideChar(codePage, 0, text.data(), static_cast<int>(text.length()),
365  				buffer, static_cast<int>(text.length()));
366  		}
367  	}
368  };
369  typedef VarBuffer<XYPOSITION, stackBufferLength> TextPositions;
370  UINT DpiForWindow(WindowID wid) noexcept {
371  	if (fnGetDpiForWindow) {
372  		return fnGetDpiForWindow(HwndFromWindowID(wid));
373  	}
374  	if (fnGetDpiForMonitor) {
375  		HMONITOR hMonitor = ::MonitorFromWindow(HwndFromWindowID(wid), MONITOR_DEFAULTTONEAREST);
376  		UINT dpiX = 0;
377  		UINT dpiY = 0;
378  		if (fnGetDpiForMonitor(hMonitor, 0 &bsol;*MDT_EFFECTIVE_DPI*/, &dpiX, &dpiY) == S_OK) {
379  			return dpiY;
380  		}
381  	}
382  	return uSystemDPI;
383  }
384  int SystemMetricsForDpi(int nIndex, UINT dpi) noexcept {
385  	if (fnGetSystemMetricsForDpi) {
386  		return fnGetSystemMetricsForDpi(nIndex, dpi);
387  	}
388  	int value = ::GetSystemMetrics(nIndex);
389  	value = (dpi == uSystemDPI) ? value : ::MulDiv(value, dpi, uSystemDPI);
390  	return value;
391  }
392  class SurfaceGDI : public Surface {
393  	SurfaceMode mode;
394  	HDC hdc{};
395  	bool hdcOwned=false;
396  	HPEN pen{};
397  	HPEN penOld{};
398  	HBRUSH brush{};
399  	HBRUSH brushOld{};
400  	HFONT fontOld{};
401  	HBITMAP bitmap{};
402  	HBITMAP bitmapOld{};
403  	int logPixelsY = USER_DEFAULT_SCREEN_DPI;
404  	static constexpr int maxWidthMeasure = INT_MAX;
405  	static constexpr int maxLenText = 65535;
406  	void PenColour(ColourRGBA fore, XYPOSITION widthStroke) noexcept;
407  	void BrushColour(ColourRGBA back) noexcept;
408  	void SetFont(const Font *font_);
409  	void Clear() noexcept;
410  public:
411  	SurfaceGDI() noexcept;
412  	SurfaceGDI(HDC hdcCompatible, int width, int height, SurfaceMode mode_, int logPixelsY_) noexcept;
413  	SurfaceGDI(const SurfaceGDI &) = delete;
414  	SurfaceGDI(SurfaceGDI &&) = delete;
415  	SurfaceGDI &operator=(const SurfaceGDI &) = delete;
416  	SurfaceGDI &operator=(SurfaceGDI &&) = delete;
417  	~SurfaceGDI() noexcept override;
418  	void Init(WindowID wid) override;
419  	void Init(SurfaceID sid, WindowID wid) override;
420  	std::unique_ptr<Surface> AllocatePixMap(int width, int height) override;
421  	void SetMode(SurfaceMode mode_) override;
422  	void Release() noexcept override;
423  	int SupportsFeature(Supports feature) noexcept override;
424  	bool Initialised() override;
425  	int LogPixelsY() override;
426  	int PixelDivisions() override;
427  	int DeviceHeightFont(int points) override;
428  	void LineDraw(Point start, Point end, Stroke stroke) override;
429  	void PolyLine(const Point *pts, size_t npts, Stroke stroke) override;
430  	void Polygon(const Point *pts, size_t npts, FillStroke fillStroke) override;
431  	void RectangleDraw(PRectangle rc, FillStroke fillStroke) override;
432  	void RectangleFrame(PRectangle rc, Stroke stroke) override;
433  	void FillRectangle(PRectangle rc, Fill fill) override;
434  	void FillRectangleAligned(PRectangle rc, Fill fill) override;
435  	void FillRectangle(PRectangle rc, Surface &surfacePattern) override;
436  	void RoundedRectangle(PRectangle rc, FillStroke fillStroke) override;
437  	void AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) override;
438  	void GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) override;
439  	void DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) override;
440  	void Ellipse(PRectangle rc, FillStroke fillStroke) override;
441  	void Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) override;
442  	void Copy(PRectangle rc, Point from, Surface &surfaceSource) override;
443  	std::unique_ptr<IScreenLineLayout> Layout(const IScreenLine *screenLine) override;
444  	void DrawTextCommon(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, UINT fuOptions);
445  	void DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
446  	void DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
447  	void DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) override;
448  	void MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) override;
449  	XYPOSITION WidthText(const Font *font_, std::string_view text) override;
450  	void DrawTextCommonUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, UINT fuOptions);
451  	void DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
452  	void DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
453  	void DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) override;
454  	void MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) override;
455  	XYPOSITION WidthTextUTF8(const Font *font_, std::string_view text) override;
456  	XYPOSITION Ascent(const Font *font_) override;
457  	XYPOSITION Descent(const Font *font_) override;
458  	XYPOSITION InternalLeading(const Font *font_) override;
459  	XYPOSITION Height(const Font *font_) override;
460  	XYPOSITION AverageCharWidth(const Font *font_) override;
461  	void SetClip(PRectangle rc) override;
462  	void PopClip() override;
463  	void FlushCachedState() override;
464  	void FlushDrawing() override;
465  };
466  SurfaceGDI::SurfaceGDI() noexcept {
467  }
468  SurfaceGDI::SurfaceGDI(HDC hdcCompatible, int width, int height, SurfaceMode mode_, int logPixelsY_) noexcept {
469  	hdc = ::CreateCompatibleDC(hdcCompatible);
470  	hdcOwned = true;
471  	bitmap = ::CreateCompatibleBitmap(hdcCompatible, width, height);
472  	bitmapOld = SelectBitmap(hdc, bitmap);
473  	::SetTextAlign(hdc, TA_BASELINE);
474  	mode = mode_;
475  	logPixelsY = logPixelsY_;
476  }
477  SurfaceGDI::~SurfaceGDI() noexcept {
478  	Clear();
479  }
480  void SurfaceGDI::Clear() noexcept {
481  	if (penOld) {
482  		::SelectObject(hdc, penOld);
483  		::DeleteObject(pen);
484  		penOld = {};
485  	}
486  	pen = {};
487  	if (brushOld) {
488  		::SelectObject(hdc, brushOld);
489  		::DeleteObject(brush);
490  		brushOld = {};
491  	}
492  	brush = {};
493  	if (fontOld) {
494  		::SelectObject(hdc, fontOld);
495  		fontOld = {};
496  	}
497  	if (bitmapOld) {
498  		::SelectObject(hdc, bitmapOld);
499  		::DeleteObject(bitmap);
500  		bitmapOld = {};
501  	}
502  	bitmap = {};
503  	if (hdcOwned) {
504  		::DeleteDC(hdc);
505  		hdc = {};
506  		hdcOwned = false;
507  	}
508  }
509  void SurfaceGDI::Release() noexcept {
510  	Clear();
511  }
512  int SurfaceGDI::SupportsFeature(Supports feature) noexcept {
513  	for (const Supports f : SupportsGDI) {
514  		if (f == feature)
515  			return 1;
516  	}
517  	return 0;
518  }
519  bool SurfaceGDI::Initialised() {
520  	return hdc != 0;
521  }
522  void SurfaceGDI::Init(WindowID wid) {
523  	Release();
524  	hdc = ::CreateCompatibleDC({});
525  	hdcOwned = true;
526  	::SetTextAlign(hdc, TA_BASELINE);
527  	logPixelsY = DpiForWindow(wid);
528  }
529  void SurfaceGDI::Init(SurfaceID sid, WindowID wid) {
530  	Release();
531  	hdc = static_cast<HDC>(sid);
532  	::SetTextAlign(hdc, TA_BASELINE);
533  	const bool printing = ::GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY;
534  	logPixelsY = printing ? ::GetDeviceCaps(hdc, LOGPIXELSY) : DpiForWindow(wid);
535  }
536  std::unique_ptr<Surface> SurfaceGDI::AllocatePixMap(int width, int height) {
537  	return std::make_unique<SurfaceGDI>(hdc, width, height, mode, logPixelsY);
538  }
539  void SurfaceGDI::SetMode(SurfaceMode mode_) {
540  	mode = mode_;
541  }
542  void SurfaceGDI::PenColour(ColourRGBA fore, XYPOSITION widthStroke) noexcept {
543  	if (pen) {
544  		::SelectObject(hdc, penOld);
545  		::DeleteObject(pen);
546  		pen = {};
547  		penOld = {};
548  	}
549  	const DWORD penWidth = std::lround(widthStroke);
550  	const COLORREF penColour = fore.OpaqueRGB();
551  	if (widthStroke > 1) {
552  		const LOGBRUSH brushParameters{ BS_SOLID, penColour, 0 };
553  		pen = ::ExtCreatePen(PS_GEOMETRIC | PS_ENDCAP_ROUND | PS_JOIN_MITER,
554  			penWidth,
555  			&brushParameters,
556  			0,
557  			nullptr);
558  	} else {
559  		pen = ::CreatePen(PS_INSIDEFRAME, penWidth, penColour);
560  	}
561  	penOld = SelectPen(hdc, pen);
562  }
563  void SurfaceGDI::BrushColour(ColourRGBA back) noexcept {
564  	if (brush) {
565  		::SelectObject(hdc, brushOld);
566  		::DeleteObject(brush);
567  		brush = {};
568  		brushOld = {};
569  	}
570  	brush = ::CreateSolidBrush(back.OpaqueRGB());
571  	brushOld = SelectBrush(hdc, brush);
572  }
573  void SurfaceGDI::SetFont(const Font *font_) {
574  	const FontGDI *pfm = dynamic_cast<const FontGDI *>(font_);
575  	PLATFORM_ASSERT(pfm);
576  	if (!pfm) {
577  		throw std::runtime_error("SurfaceGDI::SetFont: wrong Font type.");
578  	}
579  	if (fontOld) {
580  		SelectFont(hdc, pfm->hfont);
581  	} else {
582  		fontOld = SelectFont(hdc, pfm->hfont);
583  	}
584  }
585  int SurfaceGDI::LogPixelsY() {
586  	return logPixelsY;
587  }
588  int SurfaceGDI::PixelDivisions() {
589  	return 1;
590  }
591  int SurfaceGDI::DeviceHeightFont(int points) {
592  	return ::MulDiv(points, LogPixelsY(), 72);
593  }
594  void SurfaceGDI::LineDraw(Point start, Point end, Stroke stroke) {
595  	PenColour(stroke.colour, stroke.width);
596  	::MoveToEx(hdc, std::lround(std::floor(start.x)), std::lround(std::floor(start.y)), nullptr);
597  	::LineTo(hdc, std::lround(std::floor(end.x)), std::lround(std::floor(end.y)));
598  }
599  void SurfaceGDI::PolyLine(const Point *pts, size_t npts, Stroke stroke) {
600  	PLATFORM_ASSERT(npts > 1);
601  	if (npts <= 1) {
602  		return;
603  	}
604  	PenColour(stroke.colour, stroke.width);
605  	std::vector<POINT> outline;
606  	std::transform(pts, pts + npts, std::back_inserter(outline), POINTFromPoint);
607  	::Polyline(hdc, outline.data(), static_cast<int>(npts));
608  }
609  void SurfaceGDI::Polygon(const Point *pts, size_t npts, FillStroke fillStroke) {
610  	PenColour(fillStroke.stroke.colour.WithoutAlpha(), fillStroke.stroke.width);
611  	BrushColour(fillStroke.fill.colour.WithoutAlpha());
612  	std::vector<POINT> outline;
613  	std::transform(pts, pts + npts, std::back_inserter(outline), POINTFromPoint);
614  	::Polygon(hdc, outline.data(), static_cast<int>(npts));
615  }
616  void SurfaceGDI::RectangleDraw(PRectangle rc, FillStroke fillStroke) {
617  	RectangleFrame(rc, fillStroke.stroke);
618  	FillRectangle(rc.Inset(fillStroke.stroke.width), fillStroke.fill.colour);
619  }
620  void SurfaceGDI::RectangleFrame(PRectangle rc, Stroke stroke) {
621  	BrushColour(stroke.colour);
622  	const RECT rcw = RectFromPRectangle(rc);
623  	::FrameRect(hdc, &rcw, brush);
624  }
625  void SurfaceGDI::FillRectangle(PRectangle rc, Fill fill) {
626  	if (fill.colour.IsOpaque()) {
627  		const RECT rcw = RectFromPRectangle(rc);
628  		::SetBkColor(hdc, fill.colour.OpaqueRGB());
629  		::ExtTextOut(hdc, rcw.left, rcw.top, ETO_OPAQUE, &rcw, TEXT(""), 0, nullptr);
630  	} else {
631  		AlphaRectangle(rc, 0, FillStroke(fill.colour));
632  	}
633  }
634  void SurfaceGDI::FillRectangleAligned(PRectangle rc, Fill fill) {
635  	FillRectangle(PixelAlign(rc, 1), fill);
636  }
637  void SurfaceGDI::FillRectangle(PRectangle rc, Surface &surfacePattern) {
638  	HBRUSH br;
639  	if (SurfaceGDI *psgdi = dynamic_cast<SurfaceGDI *>(&surfacePattern); psgdi && psgdi->bitmap) {
640  		br = ::CreatePatternBrush(psgdi->bitmap);
641  	} else {	
642  		br = ::CreateSolidBrush(RGB(0xff, 0, 0));
643  	}
644  	const RECT rcw = RectFromPRectangle(rc);
645  	::FillRect(hdc, &rcw, br);
646  	::DeleteObject(br);
647  }
648  void SurfaceGDI::RoundedRectangle(PRectangle rc, FillStroke fillStroke) {
649  	PenColour(fillStroke.stroke.colour, fillStroke.stroke.width);
650  	BrushColour(fillStroke.fill.colour);
651  	const RECT rcw = RectFromPRectangle(rc);
652  	::RoundRect(hdc,
653  		rcw.left + 1, rcw.top,
654  		rcw.right - 1, rcw.bottom,
655  		8, 8);
656  }
657  namespace {
658  constexpr DWORD dwordFromBGRA(byte b, byte g, byte r, byte a) noexcept {
659  	return (a << 24) | (r << 16) | (g << 8) | b;
660  }
661  constexpr byte AlphaScaled(unsigned char component, unsigned int alpha) noexcept {
662  	return static_cast<byte>(component * alpha / 255);
663  }
664  constexpr DWORD dwordMultiplied(ColourRGBA colour) noexcept {
665  	return dwordFromBGRA(
666  		AlphaScaled(colour.GetBlue(), colour.GetAlpha()),
667  		AlphaScaled(colour.GetGreen(), colour.GetAlpha()),
668  		AlphaScaled(colour.GetRed(), colour.GetAlpha()),
669  		colour.GetAlpha());
670  }
671  class DIBSection {
672  	HDC hMemDC {};
673  	HBITMAP hbmMem {};
674  	HBITMAP hbmOld {};
675  	SIZE size {};
676  	DWORD *pixels = nullptr;
677  public:
678  	DIBSection(HDC hdc, SIZE size_) noexcept;
679  	DIBSection(const DIBSection&) = delete;
680  	DIBSection(DIBSection&&) = delete;
681  	DIBSection &operator=(const DIBSection&) = delete;
682  	DIBSection &operator=(DIBSection&&) = delete;
683  	~DIBSection() noexcept;
684  	operator bool() const noexcept {
685  		return hMemDC && hbmMem && pixels;
686  	}
687  	DWORD *Pixels() const noexcept {
688  		return pixels;
689  	}
690  	unsigned char *Bytes() const noexcept {
691  		return reinterpret_cast<unsigned char *>(pixels);
692  	}
693  	HDC DC() const noexcept {
694  		return hMemDC;
695  	}
696  	void SetPixel(LONG x, LONG y, DWORD value) noexcept {
697  		PLATFORM_ASSERT(x >= 0);
698  		PLATFORM_ASSERT(y >= 0);
699  		PLATFORM_ASSERT(x < size.cx);
700  		PLATFORM_ASSERT(y < size.cy);
701  		pixels[y * size.cx + x] = value;
702  	}
703  	void SetSymmetric(LONG x, LONG y, DWORD value) noexcept;
704  };
705  DIBSection::DIBSection(HDC hdc, SIZE size_) noexcept {
706  	hMemDC = ::CreateCompatibleDC(hdc);
707  	if (!hMemDC) {
708  		return;
709  	}
710  	size = size_;
711  	const BITMAPINFO bpih = { {sizeof(BITMAPINFOHEADER), size.cx, -size.cy, 1, 32, BI_RGB, 0, 0, 0, 0, 0},
712  		{{0, 0, 0, 0}} };
713  	void *image = nullptr;
714  	hbmMem = CreateDIBSection(hMemDC, &bpih, DIB_RGB_COLORS, &image, {}, 0);
715  	if (!hbmMem || !image) {
716  		return;
717  	}
718  	pixels = static_cast<DWORD *>(image);
719  	hbmOld = SelectBitmap(hMemDC, hbmMem);
720  }
721  DIBSection::~DIBSection() noexcept {
722  	if (hbmOld) {
723  		SelectBitmap(hMemDC, hbmOld);
724  		hbmOld = {};
725  	}
726  	if (hbmMem) {
727  		::DeleteObject(hbmMem);
728  		hbmMem = {};
729  	}
730  	if (hMemDC) {
731  		::DeleteDC(hMemDC);
732  		hMemDC = {};
733  	}
734  }
735  void DIBSection::SetSymmetric(LONG x, LONG y, DWORD value) noexcept {
736  	const LONG xSymmetric = size.cx - 1 - x;
737  	const LONG ySymmetric = size.cy - 1 - y;
738  	SetPixel(x, y, value);
739  	SetPixel(xSymmetric, y, value);
740  	SetPixel(x, ySymmetric, value);
741  	SetPixel(xSymmetric, ySymmetric, value);
742  }
743  ColourRGBA GradientValue(const std::vector<ColourStop> &stops, XYPOSITION proportion) noexcept {
744  	for (size_t stop = 0; stop < stops.size() - 1; stop++) {
745  		const XYPOSITION positionStart = stops[stop].position;
746  		const XYPOSITION positionEnd = stops[stop + 1].position;
747  		if ((proportion >= positionStart) && (proportion <= positionEnd)) {
748  			const XYPOSITION proportionInPair = (proportion - positionStart) /
749  				(positionEnd - positionStart);
750  			return stops[stop].colour.MixedWith(stops[stop + 1].colour, proportionInPair);
751  		}
752  	}
753  	return ColourRGBA();
754  }
755  constexpr SIZE SizeOfRect(RECT rc) noexcept {
756  	return { rc.right - rc.left, rc.bottom - rc.top };
757  }
758  constexpr BLENDFUNCTION mergeAlpha = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
759  }
760  void SurfaceGDI::AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) {
761  	const RECT rcw = RectFromPRectangle(rc);
762  	const SIZE size = SizeOfRect(rcw);
763  	if (size.cx > 0) {
764  		DIBSection section(hdc, size);
765  		if (section) {
766  			const LONG corner = std::min(static_cast<LONG>(cornerSize), (std::min(size.cx, size.cy) / 2) - 2);
767  			constexpr DWORD valEmpty = dwordFromBGRA(0,0,0,0);
768  			const DWORD valFill = dwordMultiplied(fillStroke.fill.colour);
769  			const DWORD valOutline = dwordMultiplied(fillStroke.stroke.colour);
770  			for (int y=0; y<size.cy; y++) {
771  				for (int x=0; x<size.cx; x++) {
772  					if ((x==0) || (x==size.cx-1) || (y == 0) || (y == size.cy -1)) {
773  						section.SetPixel(x, y, valOutline);
774  					} else {
775  						section.SetPixel(x, y, valFill);
776  					}
777  				}
778  			}
779  			for (LONG c=0; c<corner; c++) {
780  				for (LONG x=0; x<c+1; x++) {
781  					section.SetSymmetric(x, c - x, valEmpty);
782  				}
783  			}
784  			for (LONG x=1; x<corner; x++) {
785  				section.SetSymmetric(x, corner - x, valOutline);
786  			}
787  			GdiAlphaBlend(hdc, rcw.left, rcw.top, size.cx, size.cy, section.DC(), 0, 0, size.cx, size.cy, mergeAlpha);
788  		}
789  	} else {
790  		BrushColour(fillStroke.stroke.colour);
791  		FrameRect(hdc, &rcw, brush);
792  	}
793  }
794  void SurfaceGDI::GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) {
795  	const RECT rcw = RectFromPRectangle(rc);
796  	const SIZE size = SizeOfRect(rcw);
797  	DIBSection section(hdc, size);
798  	if (section) {
799  		if (options == GradientOptions::topToBottom) {
800  			for (LONG y = 0; y < size.cy; y++) {
801  				const XYPOSITION proportion = y / (rc.Height() - 1.0f);
802  				const ColourRGBA mixed = GradientValue(stops, proportion);
803  				const DWORD valFill = dwordMultiplied(mixed);
804  				for (LONG x = 0; x < size.cx; x++) {
805  					section.SetPixel(x, y, valFill);
806  				}
807  			}
808  		} else {
809  			for (LONG x = 0; x < size.cx; x++) {
810  				const XYPOSITION proportion = x / (rc.Width() - 1.0f);
811  				const ColourRGBA mixed = GradientValue(stops, proportion);
812  				const DWORD valFill = dwordMultiplied(mixed);
813  				for (LONG y = 0; y < size.cy; y++) {
814  					section.SetPixel(x, y, valFill);
815  				}
816  			}
817  		}
818  		GdiAlphaBlend(hdc, rcw.left, rcw.top, size.cx, size.cy, section.DC(), 0, 0, size.cx, size.cy, mergeAlpha);
819  	}
820  }
821  void SurfaceGDI::DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) {
822  	if (rc.Width() > 0) {
823  		if (rc.Width() > width)
824  			rc.left += std::floor((rc.Width() - width) / 2);
825  		rc.right = rc.left + width;
826  		if (rc.Height() > height)
827  			rc.top += std::floor((rc.Height() - height) / 2);
828  		rc.bottom = rc.top + height;
829  		const SIZE size { width, height };
830  		DIBSection section(hdc, size);
831  		if (section) {
832  			RGBAImage::BGRAFromRGBA(section.Bytes(), pixelsImage, static_cast<size_t>(width) * height);
833  			GdiAlphaBlend(hdc, static_cast<int>(rc.left), static_cast<int>(rc.top),
834  				static_cast<int>(rc.Width()), static_cast<int>(rc.Height()), section.DC(),
835  				0, 0, width, height, mergeAlpha);
836  		}
837  	}
838  }
839  void SurfaceGDI::Ellipse(PRectangle rc, FillStroke fillStroke) {
840  	PenColour(fillStroke.stroke.colour, fillStroke.stroke.width);
841  	BrushColour(fillStroke.fill.colour);
842  	const RECT rcw = RectFromPRectangle(rc);
843  	::Ellipse(hdc, rcw.left, rcw.top, rcw.right, rcw.bottom);
844  }
845  void SurfaceGDI::Stadium(PRectangle rc, FillStroke fillStroke, [[maybe_unused]] Ends ends) {
846  	RectangleDraw(rc, fillStroke);
847  }
848  void SurfaceGDI::Copy(PRectangle rc, Point from, Surface &surfaceSource) {
849  	::BitBlt(hdc,
850  		static_cast<int>(rc.left), static_cast<int>(rc.top),
851  		static_cast<int>(rc.Width()), static_cast<int>(rc.Height()),
852  		dynamic_cast<SurfaceGDI &>(surfaceSource).hdc,
853  		static_cast<int>(from.x), static_cast<int>(from.y), SRCCOPY);
854  }
855  std::unique_ptr<IScreenLineLayout> SurfaceGDI::Layout(const IScreenLine *) {
856  	return {};
857  }
858  typedef VarBuffer<int, stackBufferLength> TextPositionsI;
859  void SurfaceGDI::DrawTextCommon(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, UINT fuOptions) {
860  	SetFont(font_);
861  	const RECT rcw = RectFromPRectangle(rc);
862  	const int x = static_cast<int>(rc.left);
863  	const int yBaseInt = static_cast<int>(ybase);
864  	if (mode.codePage == CpUtf8) {
865  		const TextWide tbuf(text, mode.codePage);
866  		::ExtTextOutW(hdc, x, yBaseInt, fuOptions, &rcw, tbuf.buffer, tbuf.tlen, nullptr);
867  	} else {
868  		::ExtTextOutA(hdc, x, yBaseInt, fuOptions, &rcw, text.data(), static_cast<UINT>(text.length()), nullptr);
869  	}
870  }
871  void SurfaceGDI::DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
872  	ColourRGBA fore, ColourRGBA back) {
873  	::SetTextColor(hdc, fore.OpaqueRGB());
874  	::SetBkColor(hdc, back.OpaqueRGB());
875  	DrawTextCommon(rc, font_, ybase, text, ETO_OPAQUE);
876  }
877  void SurfaceGDI::DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
878  	ColourRGBA fore, ColourRGBA back) {
879  	::SetTextColor(hdc, fore.OpaqueRGB());
880  	::SetBkColor(hdc, back.OpaqueRGB());
881  	DrawTextCommon(rc, font_, ybase, text, ETO_OPAQUE | ETO_CLIPPED);
882  }
883  void SurfaceGDI::DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
884  	ColourRGBA fore) {
885  	for (const char ch : text) {
886  		if (ch != ' ') {
887  			::SetTextColor(hdc, fore.OpaqueRGB());
888  			::SetBkMode(hdc, TRANSPARENT);
889  			DrawTextCommon(rc, font_, ybase, text, 0);
890  			::SetBkMode(hdc, OPAQUE);
891  			return;
892  		}
893  	}
894  }
895  void SurfaceGDI::MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) {
896  	std::fill(positions, positions + text.length(), 0.0f);
897  	SetFont(font_);
898  	SIZE sz = { 0,0 };
899  	int fit = 0;
900  	int i = 0;
901  	const int len = static_cast<int>(text.length());
902  	if (mode.codePage == CpUtf8) {
903  		const TextWide tbuf(text, mode.codePage);
904  		TextPositionsI poses(tbuf.tlen);
905  		if (!::GetTextExtentExPointW(hdc, tbuf.buffer, tbuf.tlen, maxWidthMeasure, &fit, poses.buffer, &sz)) {
906  			return;
907  		}
908  		for (int ui = 0; ui < fit; ui++) {
909  			const unsigned char uch = text[i];
910  			const unsigned int byteCount = UTF8BytesOfLead[uch];
911  			if (byteCount == 4) {	
912  				ui++;
913  			}
914  			for (unsigned int bytePos = 0; (bytePos < byteCount) && (i < len); bytePos++) {
915  				positions[i++] = static_cast<XYPOSITION>(poses.buffer[ui]);
916  			}
917  		}
918  	} else {
919  		TextPositionsI poses(len);
920  		if (!::GetTextExtentExPointA(hdc, text.data(), len, maxWidthMeasure, &fit, poses.buffer, &sz)) {
921  			return;
922  		}
923  		while (i < fit) {
924  			positions[i] = static_cast<XYPOSITION>(poses.buffer[i]);
925  			i++;
926  		}
927  	}
928  	const XYPOSITION lastPos = (fit > 0) ? positions[fit - 1] : 0.0f;
929  	std::fill(positions + i, positions + text.length(), lastPos);
930  }
931  XYPOSITION SurfaceGDI::WidthText(const Font *font_, std::string_view text) {
932  	SetFont(font_);
933  	SIZE sz = { 0,0 };
934  	if (!(mode.codePage == CpUtf8)) {
935  		::GetTextExtentPoint32A(hdc, text.data(), std::min(static_cast<int>(text.length()), maxLenText), &sz);
936  	} else {
937  		const TextWide tbuf(text, mode.codePage);
938  		::GetTextExtentPoint32W(hdc, tbuf.buffer, tbuf.tlen, &sz);
939  	}
940  	return static_cast<XYPOSITION>(sz.cx);
941  }
942  void SurfaceGDI::DrawTextCommonUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, UINT fuOptions) {
943  	SetFont(font_);
944  	const RECT rcw = RectFromPRectangle(rc);
945  	const int x = static_cast<int>(rc.left);
946  	const int yBaseInt = static_cast<int>(ybase);
947  	const TextWide tbuf(text, CpUtf8);
948  	::ExtTextOutW(hdc, x, yBaseInt, fuOptions, &rcw, tbuf.buffer, tbuf.tlen, nullptr);
949  }
950  void SurfaceGDI::DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
951  	ColourRGBA fore, ColourRGBA back) {
952  	::SetTextColor(hdc, fore.OpaqueRGB());
953  	::SetBkColor(hdc, back.OpaqueRGB());
954  	DrawTextCommonUTF8(rc, font_, ybase, text, ETO_OPAQUE);
955  }
956  void SurfaceGDI::DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
957  	ColourRGBA fore, ColourRGBA back) {
958  	::SetTextColor(hdc, fore.OpaqueRGB());
959  	::SetBkColor(hdc, back.OpaqueRGB());
960  	DrawTextCommonUTF8(rc, font_, ybase, text, ETO_OPAQUE | ETO_CLIPPED);
961  }
962  void SurfaceGDI::DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
963  	ColourRGBA fore) {
964  	for (const char ch : text) {
965  		if (ch != ' ') {
966  			::SetTextColor(hdc, fore.OpaqueRGB());
967  			::SetBkMode(hdc, TRANSPARENT);
968  			DrawTextCommonUTF8(rc, font_, ybase, text, 0);
969  			::SetBkMode(hdc, OPAQUE);
970  			return;
971  		}
972  	}
973  }
974  void SurfaceGDI::MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) {
975  	std::fill(positions, positions + text.length(), 0.0f);
976  	SetFont(font_);
977  	SIZE sz = { 0,0 };
978  	int fit = 0;
979  	int i = 0;
980  	const int len = static_cast<int>(text.length());
981  	const TextWide tbuf(text, CpUtf8);
982  	TextPositionsI poses(tbuf.tlen);
983  	if (!::GetTextExtentExPointW(hdc, tbuf.buffer, tbuf.tlen, maxWidthMeasure, &fit, poses.buffer, &sz)) {
984  		return;
985  	}
986  	for (int ui = 0; ui < fit; ui++) {
987  		const unsigned char uch = text[i];
988  		const unsigned int byteCount = UTF8BytesOfLead[uch];
989  		if (byteCount == 4) {	
990  			ui++;
991  		}
992  		for (unsigned int bytePos = 0; (bytePos < byteCount) && (i < len); bytePos++) {
993  			positions[i++] = static_cast<XYPOSITION>(poses.buffer[ui]);
994  		}
995  	}
996  	const XYPOSITION lastPos = (fit > 0) ? positions[fit - 1] : 0.0f;
997  	std::fill(positions + i, positions + text.length(), lastPos);
998  }
999  XYPOSITION SurfaceGDI::WidthTextUTF8(const Font *font_, std::string_view text) {
1000  	SetFont(font_);
1001  	SIZE sz = { 0,0 };
1002  	const TextWide tbuf(text, CpUtf8);
1003  	::GetTextExtentPoint32W(hdc, tbuf.buffer, tbuf.tlen, &sz);
1004  	return static_cast<XYPOSITION>(sz.cx);
1005  }
1006  XYPOSITION SurfaceGDI::Ascent(const Font *font_) {
1007  	SetFont(font_);
1008  	TEXTMETRIC tm;
1009  	::GetTextMetrics(hdc, &tm);
1010  	return static_cast<XYPOSITION>(tm.tmAscent);
1011  }
1012  XYPOSITION SurfaceGDI::Descent(const Font *font_) {
1013  	SetFont(font_);
1014  	TEXTMETRIC tm;
1015  	::GetTextMetrics(hdc, &tm);
1016  	return static_cast<XYPOSITION>(tm.tmDescent);
1017  }
1018  XYPOSITION SurfaceGDI::InternalLeading(const Font *font_) {
1019  	SetFont(font_);
1020  	TEXTMETRIC tm;
1021  	::GetTextMetrics(hdc, &tm);
1022  	return static_cast<XYPOSITION>(tm.tmInternalLeading);
1023  }
1024  XYPOSITION SurfaceGDI::Height(const Font *font_) {
1025  	SetFont(font_);
1026  	TEXTMETRIC tm;
1027  	::GetTextMetrics(hdc, &tm);
1028  	return static_cast<XYPOSITION>(tm.tmHeight);
1029  }
1030  XYPOSITION SurfaceGDI::AverageCharWidth(const Font *font_) {
1031  	SetFont(font_);
1032  	TEXTMETRIC tm;
1033  	::GetTextMetrics(hdc, &tm);
1034  	return static_cast<XYPOSITION>(tm.tmAveCharWidth);
1035  }
1036  void SurfaceGDI::SetClip(PRectangle rc) {
1037  	::SaveDC(hdc);
1038  	::IntersectClipRect(hdc, static_cast<int>(rc.left), static_cast<int>(rc.top),
1039  		static_cast<int>(rc.right), static_cast<int>(rc.bottom));
1040  }
1041  void SurfaceGDI::PopClip() {
1042  	::RestoreDC(hdc, -1);
1043  }
1044  void SurfaceGDI::FlushCachedState() {
1045  	pen = {};
1046  	brush = {};
1047  }
1048  void SurfaceGDI::FlushDrawing() {
1049  }
1050  #if defined(USE_D2D)
1051  namespace {
1052  constexpr D2D1_RECT_F RectangleFromPRectangle(PRectangle rc) noexcept {
1053  	return {
1054  		static_cast<FLOAT>(rc.left),
1055  		static_cast<FLOAT>(rc.top),
1056  		static_cast<FLOAT>(rc.right),
1057  		static_cast<FLOAT>(rc.bottom)
1058  	};
1059  }
1060  constexpr D2D1_POINT_2F DPointFromPoint(Point point) noexcept {
1061  	return { static_cast<FLOAT>(point.x), static_cast<FLOAT>(point.y) };
1062  }
1063  constexpr Supports SupportsD2D[] = {
1064  	Supports::LineDrawsFinal,
1065  	Supports::FractionalStrokeWidth,
1066  	Supports::TranslucentStroke,
1067  	Supports::PixelModification,
1068  	Supports::ThreadSafeMeasureWidths,
1069  };
1070  constexpr D2D_COLOR_F ColorFromColourAlpha(ColourRGBA colour) noexcept {
1071  	return D2D_COLOR_F{
1072  		colour.GetRedComponent(),
1073  		colour.GetGreenComponent(),
1074  		colour.GetBlueComponent(),
1075  		colour.GetAlphaComponent()
1076  	};
1077  }
1078  constexpr D2D1_RECT_F RectangleInset(D2D1_RECT_F rect, FLOAT inset) noexcept {
1079  	return D2D1_RECT_F{
1080  		rect.left + inset,
1081  		rect.top + inset,
1082  		rect.right - inset,
1083  		rect.bottom - inset };
1084  }
1085  }
1086  class BlobInline;
1087  class SurfaceD2D : public Surface, public ISetRenderingParams {
1088  	SurfaceMode mode;
1089  	ID2D1RenderTarget *pRenderTarget = nullptr;
1090  	ID2D1BitmapRenderTarget *pBitmapRenderTarget = nullptr;
1091  	bool ownRenderTarget = false;
1092  	int clipsActive = 0;
1093  	ID2D1SolidColorBrush *pBrush = nullptr;
1094  	static constexpr FontQuality invalidFontQuality = FontQuality::QualityMask;
1095  	FontQuality fontQuality = invalidFontQuality;
1096  	int logPixelsY = USER_DEFAULT_SCREEN_DPI;
1097  	int deviceScaleFactor = 1;
1098  	std::shared_ptr<RenderingParams> renderingParams;
1099  	void Clear() noexcept;
1100  	void SetFontQuality(FontQuality extraFontFlag);
1101  	HRESULT GetBitmap(ID2D1Bitmap **ppBitmap);
1102  	void SetDeviceScaleFactor(const ID2D1RenderTarget *const pRenderTarget) noexcept;
1103  public:
1104  	SurfaceD2D() noexcept;
1105  	SurfaceD2D(ID2D1RenderTarget *pRenderTargetCompatible, int width, int height, SurfaceMode mode_, int logPixelsY_) noexcept;
1106  	SurfaceD2D(const SurfaceD2D &) = delete;
1107  	SurfaceD2D(SurfaceD2D &&) = delete;
1108  	SurfaceD2D &operator=(const SurfaceD2D &) = delete;
1109  	SurfaceD2D &operator=(SurfaceD2D &&) = delete;
1110  	~SurfaceD2D() noexcept override;
1111  	void SetScale(WindowID wid) noexcept;
1112  	void Init(WindowID wid) override;
1113  	void Init(SurfaceID sid, WindowID wid) override;
1114  	std::unique_ptr<Surface> AllocatePixMap(int width, int height) override;
1115  	void SetMode(SurfaceMode mode_) override;
1116  	void Release() noexcept override;
1117  	int SupportsFeature(Supports feature) noexcept override;
1118  	bool Initialised() override;
1119  	void D2DPenColourAlpha(ColourRGBA fore) noexcept;
1120  	int LogPixelsY() override;
1121  	int PixelDivisions() override;
1122  	int DeviceHeightFont(int points) override;
1123  	void LineDraw(Point start, Point end, Stroke stroke) override;
1124  	ID2D1PathGeometry *Geometry(const Point *pts, size_t npts, D2D1_FIGURE_BEGIN figureBegin) noexcept;
1125  	void PolyLine(const Point *pts, size_t npts, Stroke stroke) override;
1126  	void Polygon(const Point *pts, size_t npts, FillStroke fillStroke) override;
1127  	void RectangleDraw(PRectangle rc, FillStroke fillStroke) override;
1128  	void RectangleFrame(PRectangle rc, Stroke stroke) override;
1129  	void FillRectangle(PRectangle rc, Fill fill) override;
1130  	void FillRectangleAligned(PRectangle rc, Fill fill) override;
1131  	void FillRectangle(PRectangle rc, Surface &surfacePattern) override;
1132  	void RoundedRectangle(PRectangle rc, FillStroke fillStroke) override;
1133  	void AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) override;
1134  	void GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) override;
1135  	void DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) override;
1136  	void Ellipse(PRectangle rc, FillStroke fillStroke) override;
1137  	void Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) override;
1138  	void Copy(PRectangle rc, Point from, Surface &surfaceSource) override;
1139  	std::unique_ptr<IScreenLineLayout> Layout(const IScreenLine *screenLine) override;
1140  	void DrawTextCommon(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, int codePageOverride, UINT fuOptions);
1141  	void DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
1142  	void DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
1143  	void DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) override;
1144  	void MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) override;
1145  	XYPOSITION WidthText(const Font *font_, std::string_view text) override;
1146  	void DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
1147  	void DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
1148  	void DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) override;
1149  	void MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) override;
1150  	XYPOSITION WidthTextUTF8(const Font *font_, std::string_view text) override;
1151  	XYPOSITION Ascent(const Font *font_) override;
1152  	XYPOSITION Descent(const Font *font_) override;
1153  	XYPOSITION InternalLeading(const Font *font_) override;
1154  	XYPOSITION Height(const Font *font_) override;
1155  	XYPOSITION AverageCharWidth(const Font *font_) override;
1156  	void SetClip(PRectangle rc) override;
1157  	void PopClip() override;
1158  	void FlushCachedState() override;
1159  	void FlushDrawing() override;
1160  	void SetRenderingParams(std::shared_ptr<RenderingParams> renderingParams_) override;
1161  };
1162  SurfaceD2D::SurfaceD2D() noexcept {
1163  }
1164  SurfaceD2D::SurfaceD2D(ID2D1RenderTarget *pRenderTargetCompatible, int width, int height, SurfaceMode mode_, int logPixelsY_) noexcept {
1165  	const D2D1_SIZE_F desiredSize = D2D1::SizeF(static_cast<float>(width), static_cast<float>(height));
1166  	D2D1_PIXEL_FORMAT desiredFormat;
1167  #ifdef __MINGW32__
1168  	desiredFormat.format = DXGI_FORMAT_UNKNOWN;
1169  #else
1170  	desiredFormat = pRenderTargetCompatible->GetPixelFormat();
1171  #endif
1172  	desiredFormat.alphaMode = D2D1_ALPHA_MODE_IGNORE;
1173  	const HRESULT hr = pRenderTargetCompatible->CreateCompatibleRenderTarget(
1174  		&desiredSize, nullptr, &desiredFormat, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE, &pBitmapRenderTarget);
1175  	if (SUCCEEDED(hr)) {
1176  		pRenderTarget = pBitmapRenderTarget;
1177  		SetDeviceScaleFactor(pRenderTarget);
1178  		pRenderTarget->BeginDraw();
1179  		ownRenderTarget = true;
1180  	}
1181  	mode = mode_;
1182  	logPixelsY = logPixelsY_;
1183  }
1184  SurfaceD2D::~SurfaceD2D() noexcept {
1185  	Clear();
1186  }
1187  void SurfaceD2D::Clear() noexcept {
1188  	ReleaseUnknown(pBrush);
1189  	if (pRenderTarget) {
1190  		while (clipsActive) {
1191  			pRenderTarget->PopAxisAlignedClip();
1192  			clipsActive--;
1193  		}
1194  		if (ownRenderTarget) {
1195  			pRenderTarget->EndDraw();
1196  			ReleaseUnknown(pRenderTarget);
1197  			ownRenderTarget = false;
1198  		}
1199  		pRenderTarget = nullptr;
1200  	}
1201  	pBitmapRenderTarget = nullptr;
1202  }
1203  void SurfaceD2D::Release() noexcept {
1204  	Clear();
1205  }
1206  void SurfaceD2D::SetScale(WindowID wid) noexcept {
1207  	fontQuality = invalidFontQuality;
1208  	logPixelsY = DpiForWindow(wid);
1209  }
1210  int SurfaceD2D::SupportsFeature(Supports feature) noexcept {
1211  	for (const Supports f : SupportsD2D) {
1212  		if (f == feature)
1213  			return 1;
1214  	}
1215  	return 0;
1216  }
1217  bool SurfaceD2D::Initialised() {
1218  	return pRenderTarget != nullptr;
1219  }
1220  void SurfaceD2D::Init(WindowID wid) {
1221  	Release();
1222  	SetScale(wid);
1223  }
1224  void SurfaceD2D::Init(SurfaceID sid, WindowID wid) {
1225  	Release();
1226  	SetScale(wid);
1227  	pRenderTarget = static_cast<ID2D1RenderTarget *>(sid);
1228  	SetDeviceScaleFactor(pRenderTarget);
1229  }
1230  std::unique_ptr<Surface> SurfaceD2D::AllocatePixMap(int width, int height) {
1231  	std::unique_ptr<SurfaceD2D> surf = std::make_unique<SurfaceD2D>(pRenderTarget, width, height, mode, logPixelsY);
1232  	surf->SetRenderingParams(renderingParams);
1233  	return surf;
1234  }
1235  void SurfaceD2D::SetMode(SurfaceMode mode_) {
1236  	mode = mode_;
1237  }
1238  HRESULT SurfaceD2D::GetBitmap(ID2D1Bitmap **ppBitmap) {
1239  	PLATFORM_ASSERT(pBitmapRenderTarget);
1240  	return pBitmapRenderTarget->GetBitmap(ppBitmap);
1241  }
1242  void SurfaceD2D::D2DPenColourAlpha(ColourRGBA fore) noexcept {
1243  	if (pRenderTarget) {
1244  		const D2D_COLOR_F col = ColorFromColourAlpha(fore);
1245  		if (pBrush) {
1246  			pBrush->SetColor(col);
1247  		} else {
1248  			const HRESULT hr = pRenderTarget->CreateSolidColorBrush(col, &pBrush);
1249  			if (!SUCCEEDED(hr)) {
1250  				ReleaseUnknown(pBrush);
1251  			}
1252  		}
1253  	}
1254  }
1255  void SurfaceD2D::SetFontQuality(FontQuality extraFontFlag) {
1256  	if ((fontQuality != extraFontFlag) && renderingParams) {
1257  		fontQuality = extraFontFlag;
1258  		const D2D1_TEXT_ANTIALIAS_MODE aaMode = DWriteMapFontQuality(extraFontFlag);
1259  		if (aaMode == D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE && renderingParams->customRenderingParams) {
1260  			pRenderTarget->SetTextRenderingParams(renderingParams->customRenderingParams.get());
1261  		} else if (renderingParams->defaultRenderingParams) {
1262  			pRenderTarget->SetTextRenderingParams(renderingParams->defaultRenderingParams.get());
1263  		}
1264  		pRenderTarget->SetTextAntialiasMode(aaMode);
1265  	}
1266  }
1267  int SurfaceD2D::LogPixelsY() {
1268  	return logPixelsY;
1269  }
1270  void SurfaceD2D::SetDeviceScaleFactor(const ID2D1RenderTarget *const pD2D1RenderTarget) noexcept {
1271  	FLOAT dpiX = 0.f;
1272  	FLOAT dpiY = 0.f;
1273  	pD2D1RenderTarget->GetDpi(&dpiX, &dpiY);
1274  	deviceScaleFactor = static_cast<int>(dpiX / 96.f);
1275  }
1276  int SurfaceD2D::PixelDivisions() {
1277  	return deviceScaleFactor;
1278  }
1279  int SurfaceD2D::DeviceHeightFont(int points) {
1280  	return ::MulDiv(points, LogPixelsY(), 72);
1281  }
1282  void SurfaceD2D::LineDraw(Point start, Point end, Stroke stroke) {
1283  	D2DPenColourAlpha(stroke.colour);
1284  	D2D1_STROKE_STYLE_PROPERTIES strokeProps {};
1285  	strokeProps.startCap = D2D1_CAP_STYLE_SQUARE;
1286  	strokeProps.endCap = D2D1_CAP_STYLE_SQUARE;
1287  	strokeProps.dashCap = D2D1_CAP_STYLE_FLAT;
1288  	strokeProps.lineJoin = D2D1_LINE_JOIN_MITER;
1289  	strokeProps.miterLimit = 4.0f;
1290  	strokeProps.dashStyle = D2D1_DASH_STYLE_SOLID;
1291  	strokeProps.dashOffset = 0;
1292  	ID2D1StrokeStyle *pStrokeStyle = nullptr;
1293  	const HRESULT hr = pD2DFactory->CreateStrokeStyle(
1294  		strokeProps, nullptr, 0, &pStrokeStyle);
1295  	if (SUCCEEDED(hr)) {
1296  		pRenderTarget->DrawLine(
1297  			DPointFromPoint(start),
1298  			DPointFromPoint(end), pBrush, stroke.WidthF(), pStrokeStyle);
1299  	}
1300  	ReleaseUnknown(pStrokeStyle);
1301  }
1302  ID2D1PathGeometry *SurfaceD2D::Geometry(const Point *pts, size_t npts, D2D1_FIGURE_BEGIN figureBegin) noexcept {
1303  	ID2D1PathGeometry *geometry = nullptr;
1304  	HRESULT hr = pD2DFactory->CreatePathGeometry(&geometry);
1305  	if (SUCCEEDED(hr) && geometry) {
1306  		ID2D1GeometrySink *sink = nullptr;
1307  		hr = geometry->Open(&sink);
1308  		if (SUCCEEDED(hr) && sink) {
1309  			sink->BeginFigure(DPointFromPoint(pts[0]), figureBegin);
1310  			for (size_t i = 1; i < npts; i++) {
1311  				sink->AddLine(DPointFromPoint(pts[i]));
1312  			}
1313  			sink->EndFigure((figureBegin == D2D1_FIGURE_BEGIN_FILLED) ?
1314  				D2D1_FIGURE_END_CLOSED : D2D1_FIGURE_END_OPEN);
1315  			sink->Close();
1316  			ReleaseUnknown(sink);
1317  		}
1318  	}
1319  	return geometry;
1320  }
1321  void SurfaceD2D::PolyLine(const Point *pts, size_t npts, Stroke stroke) {
1322  	PLATFORM_ASSERT(pRenderTarget && (npts > 1));
1323  	if (!pRenderTarget || (npts <= 1)) {
1324  		return;
1325  	}
1326  	ID2D1PathGeometry *geometry = Geometry(pts, npts, D2D1_FIGURE_BEGIN_HOLLOW);
1327  	PLATFORM_ASSERT(geometry);
1328  	if (!geometry) {
1329  		return;
1330  	}
1331  	D2DPenColourAlpha(stroke.colour);
1332  	D2D1_STROKE_STYLE_PROPERTIES strokeProps {};
1333  	strokeProps.startCap = D2D1_CAP_STYLE_ROUND;
1334  	strokeProps.endCap = D2D1_CAP_STYLE_ROUND;
1335  	strokeProps.dashCap = D2D1_CAP_STYLE_FLAT;
1336  	strokeProps.lineJoin = D2D1_LINE_JOIN_MITER;
1337  	strokeProps.miterLimit = 4.0f;
1338  	strokeProps.dashStyle = D2D1_DASH_STYLE_SOLID;
1339  	strokeProps.dashOffset = 0;
1340  	ID2D1StrokeStyle *pStrokeStyle = nullptr;
1341  	const HRESULT hr = pD2DFactory->CreateStrokeStyle(
1342  		strokeProps, nullptr, 0, &pStrokeStyle);
1343  	if (SUCCEEDED(hr)) {
1344  		pRenderTarget->DrawGeometry(geometry, pBrush, stroke.WidthF(), pStrokeStyle);
1345  	}
1346  	ReleaseUnknown(pStrokeStyle);
1347  	ReleaseUnknown(geometry);
1348  }
1349  void SurfaceD2D::Polygon(const Point *pts, size_t npts, FillStroke fillStroke) {
1350  	PLATFORM_ASSERT(pRenderTarget && (npts > 2));
1351  	if (pRenderTarget) {
1352  		ID2D1PathGeometry *geometry = Geometry(pts, npts, D2D1_FIGURE_BEGIN_FILLED);
1353  		PLATFORM_ASSERT(geometry);
1354  		if (geometry) {
1355  			D2DPenColourAlpha(fillStroke.fill.colour);
1356  			pRenderTarget->FillGeometry(geometry, pBrush);
1357  			D2DPenColourAlpha(fillStroke.stroke.colour);
1358  			pRenderTarget->DrawGeometry(geometry, pBrush, fillStroke.stroke.WidthF());
1359  			ReleaseUnknown(geometry);
1360  		}
1361  	}
1362  }
1363  void SurfaceD2D::RectangleDraw(PRectangle rc, FillStroke fillStroke) {
1364  	if (!pRenderTarget)
1365  		return;
1366  	const D2D1_RECT_F rect = RectangleFromPRectangle(rc);
1367  	const D2D1_RECT_F rectFill = RectangleInset(rect, fillStroke.stroke.WidthF());
1368  	const float halfStroke = fillStroke.stroke.WidthF() / 2.0f;
1369  	const D2D1_RECT_F rectOutline = RectangleInset(rect, halfStroke);
1370  	D2DPenColourAlpha(fillStroke.fill.colour);
1371  	pRenderTarget->FillRectangle(&rectFill, pBrush);
1372  	D2DPenColourAlpha(fillStroke.stroke.colour);
1373  	pRenderTarget->DrawRectangle(&rectOutline, pBrush, fillStroke.stroke.WidthF());
1374  }
1375  void SurfaceD2D::RectangleFrame(PRectangle rc, Stroke stroke) {
1376  	if (pRenderTarget) {
1377  		const XYPOSITION halfStroke = stroke.width / 2.0f;
1378  		const D2D1_RECT_F rectangle1 = RectangleFromPRectangle(rc.Inset(halfStroke));
1379  		D2DPenColourAlpha(stroke.colour);
1380  		pRenderTarget->DrawRectangle(&rectangle1, pBrush, stroke.WidthF());
1381  	}
1382  }
1383  void SurfaceD2D::FillRectangle(PRectangle rc, Fill fill) {
1384  	if (pRenderTarget) {
<span onclick='openModal()' class='match'>1385  		D2DPenColourAlpha(fill.colour);
1386  		const D2D1_RECT_F rectangle = RectangleFromPRectangle(rc);
1387  		pRenderTarget->FillRectangle(&rectangle, pBrush);
</span>1388  	}
1389  }
1390  void SurfaceD2D::FillRectangleAligned(PRectangle rc, Fill fill) {
1391  	FillRectangle(PixelAlign(rc, PixelDivisions()), fill);
1392  }
1393  void SurfaceD2D::FillRectangle(PRectangle rc, Surface &surfacePattern) {
1394  	SurfaceD2D *psurfOther = dynamic_cast<SurfaceD2D *>(&surfacePattern);
1395  	PLATFORM_ASSERT(psurfOther);
1396  	if (!psurfOther) {
1397  		throw std::runtime_error("SurfaceD2D::FillRectangle: wrong Surface type.");
1398  	}
1399  	ID2D1Bitmap *pBitmap = nullptr;
1400  	HRESULT hr = psurfOther->GetBitmap(&pBitmap);
1401  	if (SUCCEEDED(hr) && pBitmap) {
1402  		ID2D1BitmapBrush *pBitmapBrush = nullptr;
1403  		const D2D1_BITMAP_BRUSH_PROPERTIES brushProperties =
1404  	        D2D1::BitmapBrushProperties(D2D1_EXTEND_MODE_WRAP, D2D1_EXTEND_MODE_WRAP,
1405  			D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR);
1406  		hr = pRenderTarget->CreateBitmapBrush(pBitmap, brushProperties, &pBitmapBrush);
1407  		ReleaseUnknown(pBitmap);
1408  		if (SUCCEEDED(hr) && pBitmapBrush) {
1409  			pRenderTarget->FillRectangle(
1410  				RectangleFromPRectangle(rc),
1411  				pBitmapBrush);
1412  			ReleaseUnknown(pBitmapBrush);
1413  		}
1414  	}
1415  }
1416  void SurfaceD2D::RoundedRectangle(PRectangle rc, FillStroke fillStroke) {
1417  	if (pRenderTarget) {
1418  		const FLOAT minDimension = static_cast<FLOAT>(std::min(rc.Width(), rc.Height())) / 2.0f;
1419  		const FLOAT radius = std::min(4.0f, minDimension);
1420  		if (fillStroke.fill.colour == fillStroke.stroke.colour) {
1421  			const D2D1_ROUNDED_RECT roundedRectFill = {
1422  				RectangleFromPRectangle(rc),
1423  				radius, radius };
1424  			D2DPenColourAlpha(fillStroke.fill.colour);
1425  			pRenderTarget->FillRoundedRectangle(roundedRectFill, pBrush);
1426  		} else {
1427  			const D2D1_ROUNDED_RECT roundedRectFill = {
1428  				RectangleFromPRectangle(rc.Inset(1.0)),
1429  				radius-1, radius-1 };
1430  			D2DPenColourAlpha(fillStroke.fill.colour);
1431  			pRenderTarget->FillRoundedRectangle(roundedRectFill, pBrush);
1432  			const D2D1_ROUNDED_RECT roundedRect = {
1433  				RectangleFromPRectangle(rc.Inset(0.5)),
1434  				radius, radius };
1435  			D2DPenColourAlpha(fillStroke.stroke.colour);
1436  			pRenderTarget->DrawRoundedRectangle(roundedRect, pBrush, fillStroke.stroke.WidthF());
1437  		}
1438  	}
1439  }
1440  void SurfaceD2D::AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) {
1441  	const D2D1_RECT_F rect = RectangleFromPRectangle(rc);
1442  	const D2D1_RECT_F rectFill = RectangleInset(rect, fillStroke.stroke.WidthF());
1443  	const float halfStroke = fillStroke.stroke.WidthF() / 2.0f;
1444  	const D2D1_RECT_F rectOutline = RectangleInset(rect, halfStroke);
1445  	if (pRenderTarget) {
1446  		if (cornerSize == 0) {
1447  			D2DPenColourAlpha(fillStroke.fill.colour);
1448  			pRenderTarget->FillRectangle(rectFill, pBrush);
1449  			D2DPenColourAlpha(fillStroke.stroke.colour);
1450  			pRenderTarget->DrawRectangle(rectOutline, pBrush, fillStroke.stroke.WidthF());
1451  		} else {
1452  			const float cornerSizeF = static_cast<float>(cornerSize);
1453  			const D2D1_ROUNDED_RECT roundedRectFill = {
1454  				rectFill, cornerSizeF - 1.0f, cornerSizeF - 1.0f };
1455  			D2DPenColourAlpha(fillStroke.fill.colour);
1456  			pRenderTarget->FillRoundedRectangle(roundedRectFill, pBrush);
1457  			const D2D1_ROUNDED_RECT roundedRect = {
1458  				rectOutline, cornerSizeF, cornerSizeF};
1459  			D2DPenColourAlpha(fillStroke.stroke.colour);
1460  			pRenderTarget->DrawRoundedRectangle(roundedRect, pBrush, fillStroke.stroke.WidthF());
1461  		}
1462  	}
1463  }
1464  void SurfaceD2D::GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) {
1465  	if (pRenderTarget) {
1466  		D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES lgbp {
1467  			DPointFromPoint(Point(rc.left, rc.top)), {}
1468  		};
1469  		switch (options) {
1470  		case GradientOptions::leftToRight:
1471  			lgbp.endPoint = DPointFromPoint(Point(rc.right, rc.top));
1472  			break;
1473  		case GradientOptions::topToBottom:
1474  		default:
1475  			lgbp.endPoint = DPointFromPoint(Point(rc.left, rc.bottom));
1476  			break;
1477  		}
1478  		std::vector<D2D1_GRADIENT_STOP> gradientStops;
1479  		for (const ColourStop &stop : stops) {
1480  			gradientStops.push_back({ static_cast<FLOAT>(stop.position), ColorFromColourAlpha(stop.colour) });
1481  		}
1482  		ID2D1GradientStopCollection *pGradientStops = nullptr;
1483  		HRESULT hr = pRenderTarget->CreateGradientStopCollection(
1484  			gradientStops.data(), static_cast<UINT32>(gradientStops.size()), &pGradientStops);
1485  		if (FAILED(hr) || !pGradientStops) {
1486  			return;
1487  		}
1488  		ID2D1LinearGradientBrush *pBrushLinear = nullptr;
1489  		hr = pRenderTarget->CreateLinearGradientBrush(
1490  			lgbp, pGradientStops, &pBrushLinear);
1491  		if (SUCCEEDED(hr) && pBrushLinear) {
1492  			const D2D1_RECT_F rectangle = RectangleFromPRectangle(PRectangle(
1493  				std::round(rc.left), rc.top, std::round(rc.right), rc.bottom));
1494  			pRenderTarget->FillRectangle(&rectangle, pBrushLinear);
1495  			ReleaseUnknown(pBrushLinear);
1496  		}
1497  		ReleaseUnknown(pGradientStops);
1498  	}
1499  }
1500  void SurfaceD2D::DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) {
1501  	if (pRenderTarget) {
1502  		if (rc.Width() > width)
1503  			rc.left += std::floor((rc.Width() - width) / 2);
1504  		rc.right = rc.left + width;
1505  		if (rc.Height() > height)
1506  			rc.top += std::floor((rc.Height() - height) / 2);
1507  		rc.bottom = rc.top + height;
1508  		std::vector<unsigned char> image(RGBAImage::bytesPerPixel * height * width);
1509  		RGBAImage::BGRAFromRGBA(image.data(), pixelsImage, static_cast<ptrdiff_t>(height) * width);
1510  		ID2D1Bitmap *bitmap = nullptr;
1511  		const D2D1_SIZE_U size = D2D1::SizeU(width, height);
1512  		const D2D1_BITMAP_PROPERTIES props = {{DXGI_FORMAT_B8G8R8A8_UNORM,
1513  		    D2D1_ALPHA_MODE_PREMULTIPLIED}, 72.0, 72.0};
1514  		const HRESULT hr = pRenderTarget->CreateBitmap(size, image.data(),
1515                    width * 4, &props, &bitmap);
1516  		if (SUCCEEDED(hr)) {
1517  			const D2D1_RECT_F rcDestination = RectangleFromPRectangle(rc);
1518  			pRenderTarget->DrawBitmap(bitmap, rcDestination);
1519  			ReleaseUnknown(bitmap);
1520  		}
1521  	}
1522  }
1523  void SurfaceD2D::Ellipse(PRectangle rc, FillStroke fillStroke) {
1524  	if (!pRenderTarget)
1525  		return;
1526  	const D2D1_POINT_2F centre = DPointFromPoint(rc.Centre());
1527  	const FLOAT radiusFill = static_cast<FLOAT>(rc.Width() / 2.0f - fillStroke.stroke.width);
1528  	const D2D1_ELLIPSE ellipseFill = { centre, radiusFill, radiusFill };
1529  	D2DPenColourAlpha(fillStroke.fill.colour);
1530  	pRenderTarget->FillEllipse(ellipseFill, pBrush);
1531  	const FLOAT radiusOutline = static_cast<FLOAT>(rc.Width() / 2.0f - fillStroke.stroke.width / 2.0f);
1532  	const D2D1_ELLIPSE ellipseOutline = { centre, radiusOutline, radiusOutline };
1533  	D2DPenColourAlpha(fillStroke.stroke.colour);
1534  	pRenderTarget->DrawEllipse(ellipseOutline, pBrush, fillStroke.stroke.WidthF());
1535  }
1536  void SurfaceD2D::Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) {
1537  	if (!pRenderTarget)
1538  		return;
1539  	if (rc.Width() < rc.Height()) {
1540  		RectangleDraw(rc, fillStroke);
1541  		return;
1542  	}
1543  	const FLOAT radius = static_cast<FLOAT>(rc.Height() / 2.0);
1544  	const FLOAT radiusFill = radius - fillStroke.stroke.WidthF();
1545  	const FLOAT halfStroke = fillStroke.stroke.WidthF() / 2.0f;
1546  	if (ends == Surface::Ends::semiCircles) {
1547  		const D2D1_RECT_F rect = RectangleFromPRectangle(rc);
1548  		const D2D1_ROUNDED_RECT roundedRectFill = { RectangleInset(rect, fillStroke.stroke.WidthF()),
1549  			radiusFill, radiusFill };
1550  		D2DPenColourAlpha(fillStroke.fill.colour);
1551  		pRenderTarget->FillRoundedRectangle(roundedRectFill, pBrush);
1552  		const D2D1_ROUNDED_RECT roundedRect = { RectangleInset(rect, halfStroke),
1553  			radius, radius };
1554  		D2DPenColourAlpha(fillStroke.stroke.colour);
1555  		pRenderTarget->DrawRoundedRectangle(roundedRect, pBrush, fillStroke.stroke.WidthF());
1556  	} else {
1557  		const Ends leftSide = static_cast<Ends>(static_cast<int>(ends) & 0xf);
1558  		const Ends rightSide = static_cast<Ends>(static_cast<int>(ends) & 0xf0);
1559  		PRectangle rcInner = rc;
1560  		rcInner.left += radius;
1561  		rcInner.right -= radius;
1562  		ID2D1PathGeometry *pathGeometry = nullptr;
1563  		const HRESULT hrGeometry = pD2DFactory->CreatePathGeometry(&pathGeometry);
1564  		if (FAILED(hrGeometry) || !pathGeometry)
1565  			return;
1566  		ID2D1GeometrySink *pSink = nullptr;
1567  		const HRESULT hrSink = pathGeometry->Open(&pSink);
1568  		if (SUCCEEDED(hrSink) && pSink) {
1569  			switch (leftSide) {
1570  				case Ends::leftFlat:
1571  					pSink->BeginFigure(DPointFromPoint(Point(rc.left + halfStroke, rc.top + halfStroke)), D2D1_FIGURE_BEGIN_FILLED);
1572  					pSink->AddLine(DPointFromPoint(Point(rc.left + halfStroke, rc.bottom - halfStroke)));
1573  					break;
1574  				case Ends::leftAngle:
1575  					pSink->BeginFigure(DPointFromPoint(Point(rcInner.left + halfStroke, rc.top + halfStroke)), D2D1_FIGURE_BEGIN_FILLED);
1576  					pSink->AddLine(DPointFromPoint(Point(rc.left + halfStroke, rc.Centre().y)));
1577  					pSink->AddLine(DPointFromPoint(Point(rcInner.left + halfStroke, rc.bottom - halfStroke)));
1578  					break;
1579  				case Ends::semiCircles:
1580  				default: {
1581  						pSink->BeginFigure(DPointFromPoint(Point(rcInner.left + halfStroke, rc.top + halfStroke)), D2D1_FIGURE_BEGIN_FILLED);
1582  						D2D1_ARC_SEGMENT segment{};
1583  						segment.point = DPointFromPoint(Point(rcInner.left + halfStroke, rc.bottom - halfStroke));
1584  						segment.size = D2D1::SizeF(radiusFill, radiusFill);
1585  						segment.rotationAngle = 0.0f;
1586  						segment.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
1587  						segment.arcSize = D2D1_ARC_SIZE_SMALL;
1588  						pSink->AddArc(segment);
1589  					}
1590  					break;
1591  			}
1592  			switch (rightSide) {
1593  			case Ends::rightFlat:
1594  				pSink->AddLine(DPointFromPoint(Point(rc.right - halfStroke, rc.bottom - halfStroke)));
1595  				pSink->AddLine(DPointFromPoint(Point(rc.right - halfStroke, rc.top + halfStroke)));
1596  				break;
1597  			case Ends::rightAngle:
1598  				pSink->AddLine(DPointFromPoint(Point(rcInner.right - halfStroke, rc.bottom - halfStroke)));
1599  				pSink->AddLine(DPointFromPoint(Point(rc.right - halfStroke, rc.Centre().y)));
1600  				pSink->AddLine(DPointFromPoint(Point(rcInner.right - halfStroke, rc.top + halfStroke)));
1601  				break;
1602  			case Ends::semiCircles:
1603  			default: {
1604  					pSink->AddLine(DPointFromPoint(Point(rcInner.right - halfStroke, rc.bottom - halfStroke)));
1605  					D2D1_ARC_SEGMENT segment{};
1606  					segment.point = DPointFromPoint(Point(rcInner.right - halfStroke, rc.top + halfStroke));
1607  					segment.size = D2D1::SizeF(radiusFill, radiusFill);
1608  					segment.rotationAngle = 0.0f;
1609  					segment.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
1610  					segment.arcSize = D2D1_ARC_SIZE_SMALL;
1611  					pSink->AddArc(segment);
1612  				}
1613  				break;
1614  			}
1615  			pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
1616  			pSink->Close();
1617  		}
1618  		ReleaseUnknown(pSink);
1619  		D2DPenColourAlpha(fillStroke.fill.colour);
1620  		pRenderTarget->FillGeometry(pathGeometry, pBrush);
1621  		D2DPenColourAlpha(fillStroke.stroke.colour);
1622  		pRenderTarget->DrawGeometry(pathGeometry, pBrush, fillStroke.stroke.WidthF());
1623  		ReleaseUnknown(pathGeometry);
1624  	}
1625  }
1626  void SurfaceD2D::Copy(PRectangle rc, Point from, Surface &surfaceSource) {
1627  	SurfaceD2D &surfOther = dynamic_cast<SurfaceD2D &>(surfaceSource);
1628  	ID2D1Bitmap *pBitmap = nullptr;
1629  	const HRESULT hr = surfOther.GetBitmap(&pBitmap);
1630  	if (SUCCEEDED(hr) && pBitmap) {
1631  		const D2D1_RECT_F rcDestination = RectangleFromPRectangle(rc);
1632  		const D2D1_RECT_F rcSource = RectangleFromPRectangle(PRectangle(
1633  			from.x, from.y, from.x + rc.Width(), from.y + rc.Height()));
1634  		pRenderTarget->DrawBitmap(pBitmap, rcDestination, 1.0f,
1635  			D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR, rcSource);
1636  		ReleaseUnknown(pBitmap);
1637  	}
1638  }
1639  class BlobInline final : public IDWriteInlineObject {
1640  	XYPOSITION width;
1641  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
1642  	STDMETHODIMP_(ULONG)AddRef() override;
1643  	STDMETHODIMP_(ULONG)Release() override;
1644  	COM_DECLSPEC_NOTHROW STDMETHODIMP Draw(
1645  		void *clientDrawingContext,
1646  		IDWriteTextRenderer *renderer,
1647  		FLOAT originX,
1648  		FLOAT originY,
1649  		BOOL isSideways,
1650  		BOOL isRightToLeft,
1651  		IUnknown *clientDrawingEffect
1652  		) override;
1653  	COM_DECLSPEC_NOTHROW STDMETHODIMP GetMetrics(DWRITE_INLINE_OBJECT_METRICS *metrics) override;
1654  	COM_DECLSPEC_NOTHROW STDMETHODIMP GetOverhangMetrics(DWRITE_OVERHANG_METRICS *overhangs) override;
1655  	COM_DECLSPEC_NOTHROW STDMETHODIMP GetBreakConditions(
1656  		DWRITE_BREAK_CONDITION *breakConditionBefore,
1657  		DWRITE_BREAK_CONDITION *breakConditionAfter) override;
1658  public:
1659  	BlobInline(XYPOSITION width_=0.0f) noexcept : width(width_) {
1660  	}
1661  };
1662  STDMETHODIMP BlobInline::QueryInterface(REFIID riid, PVOID *ppv) {
1663  	if (!ppv)
1664  		return E_POINTER;
1665  	*ppv = nullptr;
1666  	if (riid == IID_IUnknown)
1667  		*ppv = this;
1668  	if (riid == __uuidof(IDWriteInlineObject))
1669  		*ppv = this;
1670  	if (!*ppv)
1671  		return E_NOINTERFACE;
1672  	return S_OK;
1673  }
1674  STDMETHODIMP_(ULONG) BlobInline::AddRef() {
1675  	return 1;
1676  }
1677  STDMETHODIMP_(ULONG) BlobInline::Release() {
1678  	return 1;
1679  }
1680  COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BlobInline::Draw(
1681  	void*,
1682  	IDWriteTextRenderer*,
1683  	FLOAT,
1684  	FLOAT,
1685  	BOOL,
1686  	BOOL,
1687  	IUnknown*) {
1688  	return S_OK;
1689  }
1690  COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BlobInline::GetMetrics(
1691  	DWRITE_INLINE_OBJECT_METRICS *metrics
1692  ) {
1693  	if (!metrics)
1694  		return E_POINTER;
1695  	metrics->width = static_cast<FLOAT>(width);
1696  	metrics->height = 2;
1697  	metrics->baseline = 1;
1698  	metrics->supportsSideways = FALSE;
1699  	return S_OK;
1700  }
1701  COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BlobInline::GetOverhangMetrics(
1702  	DWRITE_OVERHANG_METRICS *overhangs
1703  ) {
1704  	if (!overhangs)
1705  		return E_POINTER;
1706  	overhangs->left = 0;
1707  	overhangs->top = 0;
1708  	overhangs->right = 0;
1709  	overhangs->bottom = 0;
1710  	return S_OK;
1711  }
1712  COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BlobInline::GetBreakConditions(
1713  	DWRITE_BREAK_CONDITION *breakConditionBefore,
1714  	DWRITE_BREAK_CONDITION *breakConditionAfter
1715  ) {
1716  	if (!breakConditionBefore || !breakConditionAfter)
1717  		return E_POINTER;
1718  	*breakConditionBefore = DWRITE_BREAK_CONDITION_NEUTRAL;
1719  	*breakConditionAfter = DWRITE_BREAK_CONDITION_NEUTRAL;
1720  	return S_OK;
1721  }
1722  class ScreenLineLayout : public IScreenLineLayout {
1723  	IDWriteTextLayout *textLayout = nullptr;
1724  	std::string text;
1725  	std::wstring buffer;
1726  	std::vector<BlobInline> blobs;
1727  	static void FillTextLayoutFormats(const IScreenLine *screenLine, IDWriteTextLayout *textLayout, std::vector<BlobInline> &blobs);
1728  	static std::wstring ReplaceRepresentation(std::string_view text);
1729  	static size_t GetPositionInLayout(std::string_view text, size_t position);
1730  public:
1731  	ScreenLineLayout(const IScreenLine *screenLine);
1732  	ScreenLineLayout(const ScreenLineLayout &) = delete;
1733  	ScreenLineLayout(ScreenLineLayout &&) = delete;
1734  	ScreenLineLayout &operator=(const ScreenLineLayout &) = delete;
1735  	ScreenLineLayout &operator=(ScreenLineLayout &&) = delete;
1736  	~ScreenLineLayout() noexcept override;
1737  	size_t PositionFromX(XYPOSITION xDistance, bool charPosition) override;
1738  	XYPOSITION XFromPosition(size_t caretPosition) override;
1739  	std::vector<Interval> FindRangeIntervals(size_t start, size_t end) override;
1740  };
1741  void ScreenLineLayout::FillTextLayoutFormats(const IScreenLine *screenLine, IDWriteTextLayout *textLayout, std::vector<BlobInline> &blobs) {
1742  	const ptrdiff_t numRepresentations = screenLine->RepresentationCount();
1743  	std::string_view text = screenLine->Text();
1744  	const ptrdiff_t numTabs = std::count(std::begin(text), std::end(text), '\t');
1745  	blobs.reserve(numRepresentations + numTabs);
1746  	UINT32 layoutPosition = 0;
1747  	for (size_t bytePosition = 0; bytePosition < screenLine->Length();) {
1748  		const unsigned char uch = screenLine->Text()[bytePosition];
1749  		const unsigned int byteCount = UTF8BytesOfLead[uch];
1750  		const UINT32 codeUnits = UTF16LengthFromUTF8ByteCount(byteCount);
1751  		const DWRITE_TEXT_RANGE textRange = { layoutPosition, codeUnits };
1752  		XYPOSITION representationWidth = screenLine->RepresentationWidth(bytePosition);
1753  		if ((representationWidth == 0.0f) && (screenLine->Text()[bytePosition] == '\t')) {
1754  			D2D1_POINT_2F realPt {};
1755  			DWRITE_HIT_TEST_METRICS realCaretMetrics {};
1756  			textLayout->HitTestTextPosition(
1757  				layoutPosition,
1758  				false, 
1759  				&realPt.x,
1760  				&realPt.y,
1761  				&realCaretMetrics
1762  			);
1763  			const XYPOSITION nextTab = screenLine->TabPositionAfter(realPt.x);
1764  			representationWidth = nextTab - realPt.x;
1765  		}
1766  		if (representationWidth > 0.0f) {
1767  			blobs.push_back(BlobInline(representationWidth));
1768  			textLayout->SetInlineObject(&blobs.back(), textRange);
1769  		};
1770  		const FontDirectWrite *pfm =
1771  			dynamic_cast<const FontDirectWrite *>(screenLine->FontOfPosition(bytePosition));
1772  		if (!pfm) {
1773  			throw std::runtime_error("FillTextLayoutFormats: wrong Font type.");
1774  		}
1775  		const unsigned int fontFamilyNameSize = pfm->pTextFormat->GetFontFamilyNameLength();
1776  		std::wstring fontFamilyName(fontFamilyNameSize, 0);
1777  		const HRESULT hrFamily = pfm->pTextFormat->GetFontFamilyName(fontFamilyName.data(), fontFamilyNameSize + 1);
1778  		if (SUCCEEDED(hrFamily)) {
1779  			textLayout->SetFontFamilyName(fontFamilyName.c_str(), textRange);
1780  		}
1781  		textLayout->SetFontSize(pfm->pTextFormat->GetFontSize(), textRange);
1782  		textLayout->SetFontWeight(pfm->pTextFormat->GetFontWeight(), textRange);
1783  		textLayout->SetFontStyle(pfm->pTextFormat->GetFontStyle(), textRange);
1784  		const unsigned int localeNameSize = pfm->pTextFormat->GetLocaleNameLength();
1785  		std::wstring localeName(localeNameSize, 0);
1786  		const HRESULT hrLocale = pfm->pTextFormat->GetLocaleName(localeName.data(), localeNameSize + 1);
1787  		if (SUCCEEDED(hrLocale)) {
1788  			textLayout->SetLocaleName(localeName.c_str(), textRange);
1789  		}
1790  		textLayout->SetFontStretch(pfm->pTextFormat->GetFontStretch(), textRange);
1791  		IDWriteFontCollection *fontCollection = nullptr;
1792  		if (SUCCEEDED(pfm->pTextFormat->GetFontCollection(&fontCollection))) {
1793  			textLayout->SetFontCollection(fontCollection, textRange);
1794  		}
1795  		bytePosition += byteCount;
1796  		layoutPosition += codeUnits;
1797  	}
1798  }
1799  std::wstring ScreenLineLayout::ReplaceRepresentation(std::string_view text) {
1800  	const TextWide wideText(text, CpUtf8);
1801  	std::wstring ws(wideText.buffer, wideText.tlen);
1802  	std::replace(ws.begin(), ws.end(), L'\t', L'X');
1803  	return ws;
1804  }
1805  size_t ScreenLineLayout::GetPositionInLayout(std::string_view text, size_t position) {
1806  	const std::string_view textUptoPosition = text.substr(0, position);
1807  	return UTF16Length(textUptoPosition);
1808  }
1809  ScreenLineLayout::ScreenLineLayout(const IScreenLine *screenLine) {
1810  	if (!screenLine || !screenLine->Length())
1811  		return;
1812  	text = screenLine->Text();
1813  	const FontDirectWrite *pfm = FontDirectWrite::Cast(screenLine->FontOfPosition(0));
1814  	if (!pfm->pTextFormat) {
1815  		return;
1816  	}
1817  	buffer = ReplaceRepresentation(screenLine->Text());
1818  	const HRESULT hrCreate = pIDWriteFactory->CreateTextLayout(
1819  		buffer.c_str(),
1820  		static_cast<UINT32>(buffer.length()),
1821  		pfm->pTextFormat,
1822  		static_cast<FLOAT>(screenLine->Width()),
1823  		static_cast<FLOAT>(screenLine->Height()),
1824  		&textLayout);
1825  	if (!SUCCEEDED(hrCreate)) {
1826  		return;
1827  	}
1828  	FillTextLayoutFormats(screenLine, textLayout, blobs);
1829  }
1830  ScreenLineLayout::~ScreenLineLayout() noexcept {
1831  	ReleaseUnknown(textLayout);
1832  }
1833  size_t ScreenLineLayout::PositionFromX(XYPOSITION xDistance, bool charPosition) {
1834  	if (!textLayout) {
1835  		return 0;
1836  	}
1837  	BOOL isTrailingHit = FALSE;
1838  	BOOL isInside = FALSE;
1839  	DWRITE_HIT_TEST_METRICS caretMetrics {};
1840  	textLayout->HitTestPoint(
1841  		static_cast<FLOAT>(xDistance),
1842  		0.0f,
1843  		&isTrailingHit,
1844  		&isInside,
1845  		&caretMetrics
1846  	);
1847  	DWRITE_HIT_TEST_METRICS hitTestMetrics {};
1848  	if (isTrailingHit) {
1849  		FLOAT caretX = 0.0f;
1850  		FLOAT caretY = 0.0f;
1851  		textLayout->HitTestTextPosition(
1852  			caretMetrics.textPosition,
1853  			false,
1854  			&caretX,
1855  			&caretY,
1856  			&hitTestMetrics
1857  		);
1858  	}
1859  	size_t pos;
1860  	if (charPosition) {
1861  		pos = isTrailingHit ? hitTestMetrics.textPosition : caretMetrics.textPosition;
1862  	} else {
1863  		pos = isTrailingHit ? static_cast<size_t>(hitTestMetrics.textPosition) + hitTestMetrics.length : caretMetrics.textPosition;
1864  	}
1865  	return UTF8PositionFromUTF16Position(text, pos);
1866  }
1867  XYPOSITION ScreenLineLayout::XFromPosition(size_t caretPosition) {
1868  	if (!textLayout) {
1869  		return 0.0;
1870  	}
1871  	const size_t position = GetPositionInLayout(text, caretPosition);
1872  	DWRITE_HIT_TEST_METRICS caretMetrics {};
1873  	D2D1_POINT_2F pt {};
1874  	textLayout->HitTestTextPosition(
1875  		static_cast<UINT32>(position),
1876  		false, 
1877  		&pt.x,
1878  		&pt.y,
1879  		&caretMetrics
1880  	);
1881  	return pt.x;
1882  }
1883  std::vector<Interval> ScreenLineLayout::FindRangeIntervals(size_t start, size_t end) {
1884  	std::vector<Interval> ret;
1885  	if (!textLayout || (start == end)) {
1886  		return ret;
1887  	}
1888  	const size_t startPos = GetPositionInLayout(text, start);
1889  	const size_t endPos = GetPositionInLayout(text, end);
1890  	const size_t rangeLength = (endPos > startPos) ? (endPos - startPos) : (startPos - endPos);
1891  	UINT32 actualHitTestCount = 0;
1892  	std::vector<DWRITE_HIT_TEST_METRICS> hitTestMetrics(2);
1893  	textLayout->HitTestTextRange(
1894  		static_cast<UINT32>(startPos),
1895  		static_cast<UINT32>(rangeLength),
1896  		0, 
1897  		0, 
1898  		hitTestMetrics.data(),
1899  		static_cast<UINT32>(hitTestMetrics.size()),
1900  		&actualHitTestCount
1901  	);
1902  	if (actualHitTestCount == 0) {
1903  		return ret;
1904  	}
1905  	if (hitTestMetrics.size() < actualHitTestCount) {
1906  		hitTestMetrics.resize(actualHitTestCount);
1907  		textLayout->HitTestTextRange(
1908  			static_cast<UINT32>(startPos),
1909  			static_cast<UINT32>(rangeLength),
1910  			0, 
1911  			0, 
1912  			hitTestMetrics.data(),
1913  			static_cast<UINT32>(hitTestMetrics.size()),
1914  			&actualHitTestCount
1915  		);
1916  	}
1917  	for (size_t i = 0; i < actualHitTestCount; ++i) {
1918  		const DWRITE_HIT_TEST_METRICS &htm = hitTestMetrics[i];
1919  		const Interval selectionInterval { htm.left, htm.left + htm.width };
1920  		ret.push_back(selectionInterval);
1921  	}
1922  	return ret;
1923  }
1924  std::unique_ptr<IScreenLineLayout> SurfaceD2D::Layout(const IScreenLine *screenLine) {
1925  	return std::make_unique<ScreenLineLayout>(screenLine);
1926  }
1927  void SurfaceD2D::DrawTextCommon(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, int codePageOverride, UINT fuOptions) {
1928  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
1929  	if (pfm->pTextFormat && pRenderTarget && pBrush) {
1930  		const int codePageDraw = codePageOverride ? codePageOverride : pfm->CodePageText(mode.codePage);
1931  		const TextWide tbuf(text, codePageDraw);
1932  		SetFontQuality(pfm->extraFontFlag);
1933  		if (fuOptions & ETO_CLIPPED) {
1934  			const D2D1_RECT_F rcClip = RectangleFromPRectangle(rc);
1935  			pRenderTarget->PushAxisAlignedClip(rcClip, D2D1_ANTIALIAS_MODE_ALIASED);
1936  		}
1937  		IDWriteTextLayout *pTextLayout = nullptr;
1938  		const HRESULT hr = pIDWriteFactory->CreateTextLayout(
1939  				tbuf.buffer,
1940  				tbuf.tlen,
1941  				pfm->pTextFormat,
1942  				static_cast<FLOAT>(rc.Width()),
1943  				static_cast<FLOAT>(rc.Height()),
1944  				&pTextLayout);
1945  		if (SUCCEEDED(hr)) {
1946  			const D2D1_POINT_2F origin = DPointFromPoint(Point(rc.left, ybase - pfm->yAscent));
1947  			pRenderTarget->DrawTextLayout(origin, pTextLayout, pBrush, d2dDrawTextOptions);
1948  			ReleaseUnknown(pTextLayout);
1949  		}
1950  		if (fuOptions & ETO_CLIPPED) {
1951  			pRenderTarget->PopAxisAlignedClip();
1952  		}
1953  	}
1954  }
1955  void SurfaceD2D::DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
1956  	ColourRGBA fore, ColourRGBA back) {
1957  	if (pRenderTarget) {
1958  		FillRectangleAligned(rc, back);
1959  		D2DPenColourAlpha(fore);
1960  		DrawTextCommon(rc, font_, ybase, text, 0, ETO_OPAQUE);
1961  	}
1962  }
1963  void SurfaceD2D::DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
1964  	ColourRGBA fore, ColourRGBA back) {
1965  	if (pRenderTarget) {
1966  		FillRectangleAligned(rc, back);
1967  		D2DPenColourAlpha(fore);
1968  		DrawTextCommon(rc, font_, ybase, text, 0, ETO_OPAQUE | ETO_CLIPPED);
1969  	}
1970  }
1971  void SurfaceD2D::DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
1972  	ColourRGBA fore) {
1973  	for (const char ch : text) {
1974  		if (ch != ' ') {
1975  			if (pRenderTarget) {
1976  				D2DPenColourAlpha(fore);
1977  				DrawTextCommon(rc, font_, ybase, text, 0, 0);
1978  			}
1979  			return;
1980  		}
1981  	}
1982  }
1983  namespace {
1984  HRESULT MeasurePositions(TextPositions &poses, const TextWide &tbuf, IDWriteTextFormat *pTextFormat) {
1985  	if (!pTextFormat) {
1986  		return E_FAIL;
1987  	}
1988  	std::fill(poses.buffer, poses.buffer + tbuf.tlen, 0.0f);
1989  	IDWriteTextLayout *pTextLayout = nullptr;
1990  	const HRESULT hrCreate = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pTextFormat, 10000.0, 1000.0, &pTextLayout);
1991  	if (!SUCCEEDED(hrCreate)) {
1992  		return hrCreate;
1993  	}
1994  	if (!pTextLayout) {
1995  		return E_FAIL;
1996  	}
1997  	VarBuffer<DWRITE_CLUSTER_METRICS, stackBufferLength> cm(tbuf.tlen);
1998  	UINT32 count = 0;
1999  	const HRESULT hrGetCluster = pTextLayout->GetClusterMetrics(cm.buffer, tbuf.tlen, &count);
2000  	ReleaseUnknown(pTextLayout);
2001  	if (!SUCCEEDED(hrGetCluster)) {
2002  		return hrGetCluster;
2003  	}
2004  	const DWRITE_CLUSTER_METRICS * const clusterMetrics = cm.buffer;
2005  	XYPOSITION position = 0.0;
2006  	int ti=0;
2007  	for (unsigned int ci=0; ci<count; ci++) {
2008  		for (unsigned int inCluster=0; inCluster<clusterMetrics[ci].length; inCluster++) {
2009  			poses.buffer[ti++] = position + clusterMetrics[ci].width * (inCluster + 1) / clusterMetrics[ci].length;
2010  		}
2011  		position += clusterMetrics[ci].width;
2012  	}
2013  	PLATFORM_ASSERT(ti == tbuf.tlen);
2014  	return S_OK;
2015  }
2016  }
2017  void SurfaceD2D::MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) {
2018  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2019  	const int codePageText = pfm->CodePageText(mode.codePage);
2020  	const TextWide tbuf(text, codePageText);
2021  	TextPositions poses(tbuf.tlen);
2022  	if (FAILED(MeasurePositions(poses, tbuf, pfm->pTextFormat))) {
2023  		return;
2024  	}
2025  	if (codePageText == CpUtf8) {
2026  		size_t i = 0;
2027  		for (int ui = 0; ui < tbuf.tlen; ui++) {
2028  			const unsigned char uch = text[i];
2029  			const unsigned int byteCount = UTF8BytesOfLead[uch];
2030  			if (byteCount == 4) {	
2031  				ui++;
2032  			}
2033  			for (unsigned int bytePos=0; (bytePos<byteCount) && (i<text.length()) && (ui<tbuf.tlen); bytePos++) {
2034  				positions[i++] = poses.buffer[ui];
2035  			}
2036  		}
2037  		const XYPOSITION lastPos = (i > 0) ? positions[i - 1] : 0.0;
2038  		while (i<text.length()) {
2039  			positions[i++] = lastPos;
2040  		}
2041  	} else if (!IsDBCSCodePage(codePageText)) {
2042  		PLATFORM_ASSERT(text.length() == static_cast<size_t>(tbuf.tlen));
2043  		for (int kk=0; kk<tbuf.tlen; kk++) {
2044  			positions[kk] = poses.buffer[kk];
2045  		}
2046  	} else {
2047  		int ui = 0;
2048  		for (size_t i=0; i<text.length() && ui<tbuf.tlen;) {
2049  			positions[i] = poses.buffer[ui];
2050  			if (DBCSIsLeadByte(codePageText, text[i])) {
2051  				positions[i+1] = poses.buffer[ui];
2052  				i += 2;
2053  			} else {
2054  				i++;
2055  			}
2056  			ui++;
2057  		}
2058  	}
2059  }
2060  XYPOSITION SurfaceD2D::WidthText(const Font *font_, std::string_view text) {
2061  	FLOAT width = 1.0;
2062  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2063  	if (pfm->pTextFormat) {
2064  		const TextWide tbuf(text, pfm->CodePageText(mode.codePage));
2065  		IDWriteTextLayout *pTextLayout = nullptr;
2066  		const HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pfm->pTextFormat, 1000.0, 1000.0, &pTextLayout);
2067  		if (SUCCEEDED(hr) && pTextLayout) {
2068  			DWRITE_TEXT_METRICS textMetrics;
2069  			if (SUCCEEDED(pTextLayout->GetMetrics(&textMetrics)))
2070  				width = textMetrics.widthIncludingTrailingWhitespace;
2071  			ReleaseUnknown(pTextLayout);
2072  		}
2073  	}
2074  	return width;
2075  }
2076  void SurfaceD2D::DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
2077  	ColourRGBA fore, ColourRGBA back) {
2078  	if (pRenderTarget) {
2079  		FillRectangleAligned(rc, back);
2080  		D2DPenColourAlpha(fore);
2081  		DrawTextCommon(rc, font_, ybase, text, CpUtf8, ETO_OPAQUE);
2082  	}
2083  }
2084  void SurfaceD2D::DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
2085  	ColourRGBA fore, ColourRGBA back) {
2086  	if (pRenderTarget) {
2087  		FillRectangleAligned(rc, back);
2088  		D2DPenColourAlpha(fore);
2089  		DrawTextCommon(rc, font_, ybase, text, CpUtf8, ETO_OPAQUE | ETO_CLIPPED);
2090  	}
2091  }
2092  void SurfaceD2D::DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
2093  	ColourRGBA fore) {
2094  	for (const char ch : text) {
2095  		if (ch != ' ') {
2096  			if (pRenderTarget) {
2097  				D2DPenColourAlpha(fore);
2098  				DrawTextCommon(rc, font_, ybase, text, CpUtf8, 0);
2099  			}
2100  			return;
2101  		}
2102  	}
2103  }
2104  void SurfaceD2D::MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) {
2105  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2106  	const TextWide tbuf(text, CpUtf8);
2107  	TextPositions poses(tbuf.tlen);
2108  	if (FAILED(MeasurePositions(poses, tbuf, pfm->pTextFormat))) {
2109  		return;
2110  	}
2111  	size_t i = 0;
2112  	for (int ui = 0; ui < tbuf.tlen; ui++) {
2113  		const unsigned char uch = text[i];
2114  		const unsigned int byteCount = UTF8BytesOfLead[uch];
2115  		if (byteCount == 4) {	
2116  			ui++;
2117  			PLATFORM_ASSERT(ui < tbuf.tlen);
2118  		}
2119  		for (unsigned int bytePos=0; (bytePos<byteCount) && (i<text.length()) && (ui < tbuf.tlen); bytePos++) {
2120  			positions[i++] = poses.buffer[ui];
2121  		}
2122  	}
2123  	const XYPOSITION lastPos = (i > 0) ? positions[i - 1] : 0.0;
2124  	while (i < text.length()) {
2125  		positions[i++] = lastPos;
2126  	}
2127  }
2128  XYPOSITION SurfaceD2D::WidthTextUTF8(const Font * font_, std::string_view text) {
2129  	FLOAT width = 1.0;
2130  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2131  	if (pfm->pTextFormat) {
2132  		const TextWide tbuf(text, CpUtf8);
2133  		IDWriteTextLayout *pTextLayout = nullptr;
2134  		const HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pfm->pTextFormat, 1000.0, 1000.0, &pTextLayout);
2135  		if (SUCCEEDED(hr)) {
2136  			DWRITE_TEXT_METRICS textMetrics;
2137  			if (SUCCEEDED(pTextLayout->GetMetrics(&textMetrics)))
2138  				width = textMetrics.widthIncludingTrailingWhitespace;
2139  			ReleaseUnknown(pTextLayout);
2140  		}
2141  	}
2142  	return width;
2143  }
2144  XYPOSITION SurfaceD2D::Ascent(const Font *font_) {
2145  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2146  	return std::ceil(pfm->yAscent);
2147  }
2148  XYPOSITION SurfaceD2D::Descent(const Font *font_) {
2149  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2150  	return std::ceil(pfm->yDescent);
2151  }
2152  XYPOSITION SurfaceD2D::InternalLeading(const Font *font_) {
2153  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2154  	return std::floor(pfm->yInternalLeading);
2155  }
2156  XYPOSITION SurfaceD2D::Height(const Font *font_) {
2157  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2158  	return std::ceil(pfm->yAscent) + std::ceil(pfm->yDescent);
2159  }
2160  XYPOSITION SurfaceD2D::AverageCharWidth(const Font *font_) {
2161  	FLOAT width = 1.0;
2162  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2163  	if (pfm->pTextFormat) {
2164  		IDWriteTextLayout *pTextLayout = nullptr;
2165  		static constexpr WCHAR wszAllAlpha[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
2166  		const size_t lenAllAlpha = wcslen(wszAllAlpha);
2167  		const HRESULT hr = pIDWriteFactory->CreateTextLayout(wszAllAlpha, static_cast<UINT32>(lenAllAlpha),
2168  			pfm->pTextFormat, 1000.0, 1000.0, &pTextLayout);
2169  		if (SUCCEEDED(hr) && pTextLayout) {
2170  			DWRITE_TEXT_METRICS textMetrics;
2171  			if (SUCCEEDED(pTextLayout->GetMetrics(&textMetrics)))
2172  				width = textMetrics.width / lenAllAlpha;
2173  			ReleaseUnknown(pTextLayout);
2174  		}
2175  	}
2176  	return width;
2177  }
2178  void SurfaceD2D::SetClip(PRectangle rc) {
2179  	if (pRenderTarget) {
2180  		const D2D1_RECT_F rcClip = RectangleFromPRectangle(rc);
2181  		pRenderTarget->PushAxisAlignedClip(rcClip, D2D1_ANTIALIAS_MODE_ALIASED);
2182  		clipsActive++;
2183  	}
2184  }
2185  void SurfaceD2D::PopClip() {
2186  	if (pRenderTarget) {
2187  		PLATFORM_ASSERT(clipsActive > 0);
2188  		pRenderTarget->PopAxisAlignedClip();
2189  		clipsActive--;
2190  	}
2191  }
2192  void SurfaceD2D::FlushCachedState() {
2193  }
2194  void SurfaceD2D::FlushDrawing() {
2195  	if (pRenderTarget) {
2196  		pRenderTarget->Flush();
2197  	}
2198  }
2199  void SurfaceD2D::SetRenderingParams(std::shared_ptr<RenderingParams> renderingParams_) {
2200  	renderingParams = renderingParams_;
2201  }
2202  #endif
2203  std::unique_ptr<Surface> Surface::Allocate(Technology technology) {
2204  #if defined(USE_D2D)
2205  	if (technology == Technology::Default)
2206  		return std::make_unique<SurfaceGDI>();
2207  	else
2208  		return std::make_unique<SurfaceD2D>();
2209  #else
2210  	return std::make_unique<SurfaceGDI>();
2211  #endif
2212  }
2213  Window::~Window() noexcept {
2214  }
2215  void Window::Destroy() noexcept {
2216  	if (wid)
2217  		::DestroyWindow(HwndFromWindowID(wid));
2218  	wid = nullptr;
2219  }
2220  PRectangle Window::GetPosition() const {
2221  	RECT rc;
2222  	::GetWindowRect(HwndFromWindowID(wid), &rc);
2223  	return PRectangle::FromInts(rc.left, rc.top, rc.right, rc.bottom);
2224  }
2225  void Window::SetPosition(PRectangle rc) {
2226  	::SetWindowPos(HwndFromWindowID(wid),
2227  		0, static_cast<int>(rc.left), static_cast<int>(rc.top),
2228  		static_cast<int>(rc.Width()), static_cast<int>(rc.Height()), SWP_NOZORDER | SWP_NOACTIVATE);
2229  }
2230  namespace {
2231  RECT RectFromMonitor(HMONITOR hMonitor) noexcept {
2232  	MONITORINFO mi = {};
2233  	mi.cbSize = sizeof(mi);
2234  	if (GetMonitorInfo(hMonitor, &mi)) {
2235  		return mi.rcWork;
2236  	}
2237  	RECT rc = {0, 0, 0, 0};
2238  	if (::SystemParametersInfoA(SPI_GETWORKAREA, 0, &rc, 0) == 0) {
2239  		rc.left = 0;
2240  		rc.top = 0;
2241  		rc.right = 0;
2242  		rc.bottom = 0;
2243  	}
2244  	return rc;
2245  }
2246  }
2247  void Window::SetPositionRelative(PRectangle rc, const Window *relativeTo) {
2248  	const DWORD style = GetWindowStyle(HwndFromWindowID(wid));
2249  	if (style & WS_POPUP) {
2250  		POINT ptOther = {0, 0};
2251  		::ClientToScreen(HwndFromWindow(*relativeTo), &ptOther);
2252  		rc.Move(static_cast<XYPOSITION>(ptOther.x), static_cast<XYPOSITION>(ptOther.y));
2253  		const RECT rcMonitor = RectFromPRectangle(rc);
2254  		HMONITOR hMonitor = MonitorFromRect(&rcMonitor, MONITOR_DEFAULTTONEAREST);
2255  		const RECT rcWork = RectFromMonitor(hMonitor);
2256  		if (rcWork.left < rcWork.right) {
2257  			if (rc.right > rcWork.right)
2258  				rc.Move(rcWork.right - rc.right, 0);
2259  			if (rc.bottom > rcWork.bottom)
2260  				rc.Move(0, rcWork.bottom - rc.bottom);
2261  			if (rc.left < rcWork.left)
2262  				rc.Move(rcWork.left - rc.left, 0);
2263  			if (rc.top < rcWork.top)
2264  				rc.Move(0, rcWork.top - rc.top);
2265  		}
2266  	}
2267  	SetPosition(rc);
2268  }
2269  PRectangle Window::GetClientPosition() const {
2270  	RECT rc={0,0,0,0};
2271  	if (wid)
2272  		::GetClientRect(HwndFromWindowID(wid), &rc);
2273  	return PRectangle::FromInts(rc.left, rc.top, rc.right, rc.bottom);
2274  }
2275  void Window::Show(bool show) {
2276  	if (show)
2277  		::ShowWindow(HwndFromWindowID(wid), SW_SHOWNOACTIVATE);
2278  	else
2279  		::ShowWindow(HwndFromWindowID(wid), SW_HIDE);
2280  }
2281  void Window::InvalidateAll() {
2282  	::InvalidateRect(HwndFromWindowID(wid), nullptr, FALSE);
2283  }
2284  void Window::InvalidateRectangle(PRectangle rc) {
2285  	const RECT rcw = RectFromPRectangle(rc);
2286  	::InvalidateRect(HwndFromWindowID(wid), &rcw, FALSE);
2287  }
2288  namespace {
2289  void FlipBitmap(HBITMAP bitmap, int width, int height) noexcept {
2290  	HDC hdc = ::CreateCompatibleDC({});
2291  	if (hdc) {
2292  		HBITMAP prevBmp = SelectBitmap(hdc, bitmap);
2293  		::StretchBlt(hdc, width - 1, 0, -width, height, hdc, 0, 0, width, height, SRCCOPY);
2294  		SelectBitmap(hdc, prevBmp);
2295  		::DeleteDC(hdc);
2296  	}
2297  }
2298  }
2299  HCURSOR LoadReverseArrowCursor(UINT dpi) noexcept {
2300  	HCURSOR reverseArrowCursor {};
2301  	bool created = false;
2302  	HCURSOR cursor = ::LoadCursor({}, IDC_ARROW);
2303  	if (dpi != uSystemDPI) {
2304  		const int width = SystemMetricsForDpi(SM_CXCURSOR, dpi);
2305  		const int height = SystemMetricsForDpi(SM_CYCURSOR, dpi);
2306  		HCURSOR copy = static_cast<HCURSOR>(::CopyImage(cursor, IMAGE_CURSOR, width, height, LR_COPYFROMRESOURCE | LR_COPYRETURNORG));
2307  		if (copy) {
2308  			created = copy != cursor;
2309  			cursor = copy;
2310  		}
2311  	}
2312  	ICONINFO info;
2313  	if (::GetIconInfo(cursor, &info)) {
2314  		BITMAP bmp {};
2315  		if (::GetObject(info.hbmMask, sizeof(bmp), &bmp)) {
2316  			FlipBitmap(info.hbmMask, bmp.bmWidth, bmp.bmHeight);
2317  			if (info.hbmColor)
2318  				FlipBitmap(info.hbmColor, bmp.bmWidth, bmp.bmHeight);
2319  			info.xHotspot = bmp.bmWidth - 1 - info.xHotspot;
2320  			reverseArrowCursor = ::CreateIconIndirect(&info);
2321  		}
2322  		::DeleteObject(info.hbmMask);
2323  		if (info.hbmColor)
2324  			::DeleteObject(info.hbmColor);
2325  	}
2326  	if (created) {
2327  		::DestroyCursor(cursor);
2328  	}
2329  	return reverseArrowCursor;
2330  }
2331  void Window::SetCursor(Cursor curs) {
2332  	switch (curs) {
2333  	case Cursor::text:
2334  		::SetCursor(::LoadCursor(NULL,IDC_IBEAM));
2335  		break;
2336  	case Cursor::up:
2337  		::SetCursor(::LoadCursor(NULL,IDC_UPARROW));
2338  		break;
2339  	case Cursor::wait:
2340  		::SetCursor(::LoadCursor(NULL,IDC_WAIT));
2341  		break;
2342  	case Cursor::horizontal:
2343  		::SetCursor(::LoadCursor(NULL,IDC_SIZEWE));
2344  		break;
2345  	case Cursor::vertical:
2346  		::SetCursor(::LoadCursor(NULL,IDC_SIZENS));
2347  		break;
2348  	case Cursor::hand:
2349  		::SetCursor(::LoadCursor(NULL,IDC_HAND));
2350  		break;
2351  	case Cursor::reverseArrow:
2352  	case Cursor::arrow:
2353  	case Cursor::invalid:	
2354  		::SetCursor(::LoadCursor(NULL,IDC_ARROW));
2355  		break;
2356  	}
2357  }
2358  PRectangle Window::GetMonitorRect(Point pt) {
2359  	const PRectangle rcPosition = GetPosition();
2360  	const POINT ptDesktop = {static_cast<LONG>(pt.x + rcPosition.left),
2361  		static_cast<LONG>(pt.y + rcPosition.top)};
2362  	HMONITOR hMonitor = MonitorFromPoint(ptDesktop, MONITOR_DEFAULTTONEAREST);
2363  	const RECT rcWork = RectFromMonitor(hMonitor);
2364  	if (rcWork.left < rcWork.right) {
2365  		PRectangle rcMonitor(
2366  			rcWork.left - rcPosition.left,
2367  			rcWork.top - rcPosition.top,
2368  			rcWork.right - rcPosition.left,
2369  			rcWork.bottom - rcPosition.top);
2370  		return rcMonitor;
2371  	} else {
2372  		return PRectangle();
2373  	}
2374  }
2375  struct ListItemData {
2376  	const char *text;
2377  	int pixId;
2378  };
2379  class LineToItem {
2380  	std::vector<char> words;
2381  	std::vector<ListItemData> data;
2382  public:
2383  	void Clear() noexcept {
2384  		words.clear();
2385  		data.clear();
2386  	}
2387  	ListItemData Get(size_t index) const noexcept {
2388  		if (index < data.size()) {
2389  			return data[index];
2390  		} else {
2391  			ListItemData missing = {"", -1};
2392  			return missing;
2393  		}
2394  	}
2395  	int Count() const noexcept {
2396  		return static_cast<int>(data.size());
2397  	}
2398  	void AllocItem(const char *text, int pixId) {
2399  		const ListItemData lid = { text, pixId };
2400  		data.push_back(lid);
2401  	}
2402  	char *SetWords(const char *s) {
2403  		words = std::vector<char>(s, s+strlen(s)+1);
2404  		return &words[0];
2405  	}
2406  };
2407  const TCHAR ListBoxX_ClassName[] = TEXT("ListBoxX");
2408  ListBox::ListBox() noexcept {
2409  }
2410  ListBox::~ListBox() noexcept {
2411  }
2412  class ListBoxX : public ListBox {
2413  	int lineHeight;
2414  	HFONT fontCopy;
2415  	Technology technology;
2416  	RGBAImageSet images;
2417  	LineToItem lti;
2418  	HWND lb;
2419  	bool unicodeMode;
2420  	int desiredVisibleRows;
2421  	unsigned int maxItemCharacters;
2422  	unsigned int aveCharWidth;
2423  	Window *parent;
2424  	int ctrlID;
2425  	UINT dpi;
2426  	IListBoxDelegate *delegate;
2427  	const char *widestItem;
2428  	unsigned int maxCharWidth;
2429  	WPARAM resizeHit;
2430  	PRectangle rcPreSize;
2431  	Point dragOffset;
2432  	Point location;	
2433  	MouseWheelDelta wheelDelta;
2434  	ListOptions options;
2435  	DWORD frameStyle = WS_THICKFRAME;
2436  	HWND GetHWND() const noexcept;
2437  	void AppendListItem(const char *text, const char *numword);
2438  	void AdjustWindowRect(PRectangle *rc, UINT dpiAdjust) const noexcept;
2439  	int ItemHeight() const;
2440  	int MinClientWidth() const noexcept;
2441  	int TextOffset() const;
2442  	POINT GetClientExtent() const noexcept;
2443  	POINT MinTrackSize() const;
2444  	POINT MaxTrackSize() const;
2445  	void SetRedraw(bool on) noexcept;
2446  	void OnDoubleClick();
2447  	void OnSelChange();
2448  	void ResizeToCursor();
2449  	void StartResize(WPARAM);
2450  	LRESULT NcHitTest(WPARAM, LPARAM) const;
2451  	void CentreItem(int n);
2452  	void Paint(HDC);
2453  	static LRESULT PASCAL ControlWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
2454  	static constexpr Point ItemInset {0, 0};	
2455  	static constexpr Point TextInset {2, 0};	
2456  	static constexpr Point ImageInset {1, 0};	
2457  public:
2458  	ListBoxX() : lineHeight(10), fontCopy{}, technology(Technology::Default), lb{}, unicodeMode(false),
2459  		desiredVisibleRows(9), maxItemCharacters(0), aveCharWidth(8),
2460  		parent(nullptr), ctrlID(0), dpi(USER_DEFAULT_SCREEN_DPI),
2461  		delegate(nullptr),
2462  		widestItem(nullptr), maxCharWidth(1), resizeHit(0) {
2463  	}
2464  	ListBoxX(const ListBoxX &) = delete;
2465  	ListBoxX(ListBoxX &&) = delete;
2466  	ListBoxX &operator=(const ListBoxX &) = delete;
2467  	ListBoxX &operator=(ListBoxX &&) = delete;
2468  	~ListBoxX() noexcept override {
2469  		if (fontCopy) {
2470  			::DeleteObject(fontCopy);
2471  			fontCopy = 0;
2472  		}
2473  	}
2474  	void SetFont(const Font *font) override;
2475  	void Create(Window &parent_, int ctrlID_, Point location_, int lineHeight_, bool unicodeMode_, Technology technology_) override;
2476  	void SetAverageCharWidth(int width) override;
2477  	void SetVisibleRows(int rows) override;
2478  	int GetVisibleRows() const override;
2479  	PRectangle GetDesiredRect() override;
2480  	int CaretFromEdge() override;
2481  	void Clear() noexcept override;
2482  	void Append(char *s, int type = -1) override;
2483  	int Length() override;
2484  	void Select(int n) override;
2485  	int GetSelection() override;
2486  	int Find(const char *prefix) override;
2487  	std::string GetValue(int n) override;
2488  	void RegisterImage(int type, const char *xpm_data) override;
2489  	void RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage) override;
2490  	void ClearRegisteredImages() override;
2491  	void SetDelegate(IListBoxDelegate *lbDelegate) override;
2492  	void SetList(const char *list, char separator, char typesep) override;
2493  	void SetOptions(ListOptions options_) override;
2494  	void Draw(DRAWITEMSTRUCT *pDrawItem);
2495  	LRESULT WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
2496  	static LRESULT PASCAL StaticWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
2497  };
2498  std::unique_ptr<ListBox> ListBox::Allocate() {
2499  	return std::make_unique<ListBoxX>();
2500  }
2501  void ListBoxX::Create(Window &parent_, int ctrlID_, Point location_, int lineHeight_, bool unicodeMode_, Technology technology_) {
2502  	parent = &parent_;
2503  	ctrlID = ctrlID_;
2504  	location = location_;
2505  	lineHeight = lineHeight_;
2506  	unicodeMode = unicodeMode_;
2507  	technology = technology_;
2508  	HWND hwndParent = HwndFromWindow(*parent);
2509  	HINSTANCE hinstanceParent = GetWindowInstance(hwndParent);
2510  	wid = ::CreateWindowEx(
2511  		WS_EX_WINDOWEDGE, ListBoxX_ClassName, TEXT(""),
2512  		WS_POPUP | frameStyle,
2513  		100,100, 150,80, hwndParent,
2514  		NULL,
2515  		hinstanceParent,
2516  		this);
2517  	dpi = DpiForWindow(hwndParent);
2518  	POINT locationw = POINTFromPoint(location);
2519  	::MapWindowPoints(hwndParent, NULL, &locationw, 1);
2520  	location = PointFromPOINT(locationw);
2521  }
2522  void ListBoxX::SetFont(const Font *font) {
2523  	const FontWin *pfm = dynamic_cast<const FontWin *>(font);
2524  	if (pfm) {
2525  		if (fontCopy) {
2526  			::DeleteObject(fontCopy);
2527  			fontCopy = 0;
2528  		}
2529  		fontCopy = pfm->HFont();
2530  		SetWindowFont(lb, fontCopy, 0);
2531  	}
2532  }
2533  void ListBoxX::SetAverageCharWidth(int width) {
2534  	aveCharWidth = width;
2535  }
2536  void ListBoxX::SetVisibleRows(int rows) {
2537  	desiredVisibleRows = rows;
2538  }
2539  int ListBoxX::GetVisibleRows() const {
2540  	return desiredVisibleRows;
2541  }
2542  HWND ListBoxX::GetHWND() const noexcept {
2543  	return HwndFromWindowID(GetID());
2544  }
2545  PRectangle ListBoxX::GetDesiredRect() {
2546  	PRectangle rcDesired = GetPosition();
2547  	int rows = Length();
2548  	if ((rows == 0) || (rows > desiredVisibleRows))
2549  		rows = desiredVisibleRows;
2550  	rcDesired.bottom = rcDesired.top + ItemHeight() * rows;
2551  	int width = MinClientWidth();
2552  	HDC hdc = ::GetDC(lb);
2553  	HFONT oldFont = SelectFont(hdc, fontCopy);
2554  	SIZE textSize = {0, 0};
2555  	int len = 0;
2556  	if (widestItem) {
2557  		len = static_cast<int>(strlen(widestItem));
2558  		if (unicodeMode) {
2559  			const TextWide tbuf(widestItem, CpUtf8);
2560  			::GetTextExtentPoint32W(hdc, tbuf.buffer, tbuf.tlen, &textSize);
2561  		} else {
2562  			::GetTextExtentPoint32A(hdc, widestItem, len, &textSize);
2563  		}
2564  	}
2565  	TEXTMETRIC tm;
2566  	::GetTextMetrics(hdc, &tm);
2567  	maxCharWidth = tm.tmMaxCharWidth;
2568  	SelectFont(hdc, oldFont);
2569  	::ReleaseDC(lb, hdc);
2570  	const int widthDesired = std::max(textSize.cx, (len + 1) * tm.tmAveCharWidth);
2571  	if (width < widthDesired)
2572  		width = widthDesired;
2573  	rcDesired.right = rcDesired.left + TextOffset() + width + (TextInset.x * 2);
2574  	if (Length() > rows)
2575  		rcDesired.right += SystemMetricsForDpi(SM_CXVSCROLL, dpi);
2576  	AdjustWindowRect(&rcDesired, dpi);
2577  	return rcDesired;
2578  }
2579  int ListBoxX::TextOffset() const {
2580  	const int pixWidth = images.GetWidth();
2581  	return static_cast<int>(pixWidth == 0 ? ItemInset.x : ItemInset.x + pixWidth + (ImageInset.x * 2));
2582  }
2583  int ListBoxX::CaretFromEdge() {
2584  	PRectangle rc;
2585  	AdjustWindowRect(&rc, dpi);
2586  	return TextOffset() + static_cast<int>(TextInset.x + (0 - rc.left) - 1);
2587  }
2588  void ListBoxX::Clear() noexcept {
2589  	ListBox_ResetContent(lb);
2590  	maxItemCharacters = 0;
2591  	widestItem = nullptr;
2592  	lti.Clear();
2593  }
2594  void ListBoxX::Append(char *, int) {
2595  	PLATFORM_ASSERT(false);
2596  }
2597  int ListBoxX::Length() {
2598  	return lti.Count();
2599  }
2600  void ListBoxX::Select(int n) {
2601  	SetRedraw(false);
2602  	CentreItem(n);
2603  	ListBox_SetCurSel(lb, n);
2604  	OnSelChange();
2605  	SetRedraw(true);
2606  }
2607  int ListBoxX::GetSelection() {
2608  	return ListBox_GetCurSel(lb);
2609  }
2610  int ListBoxX::Find(const char *) {
2611  	return LB_ERR;
2612  }
2613  std::string ListBoxX::GetValue(int n) {
2614  	const ListItemData item = lti.Get(n);
2615  	return item.text;
2616  }
2617  void ListBoxX::RegisterImage(int type, const char *xpm_data) {
2618  	XPM xpmImage(xpm_data);
2619  	images.AddImage(type, std::make_unique<RGBAImage>(xpmImage));
2620  }
2621  void ListBoxX::RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage) {
2622  	images.AddImage(type, std::make_unique<RGBAImage>(width, height, 1.0f, pixelsImage));
2623  }
2624  void ListBoxX::ClearRegisteredImages() {
2625  	images.Clear();
2626  }
2627  namespace {
2628  int ColourOfElement(std::optional<ColourRGBA> colour, int nIndex) {
2629  	if (colour.has_value()) {
2630  		return colour.value().OpaqueRGB();
2631  	} else {
2632  		return ::GetSysColor(nIndex);
2633  	}
2634  }
2635  void FillRectColour(HDC hdc, const RECT *lprc, int colour) noexcept {
2636  	const HBRUSH brush = ::CreateSolidBrush(colour);
2637  	::FillRect(hdc, lprc, brush);
2638  	::DeleteObject(brush);
2639  }
2640  }
2641  void ListBoxX::Draw(DRAWITEMSTRUCT *pDrawItem) {
2642  	if ((pDrawItem->itemAction == ODA_SELECT) || (pDrawItem->itemAction == ODA_DRAWENTIRE)) {
2643  		RECT rcBox = pDrawItem->rcItem;
2644  		rcBox.left += TextOffset();
2645  		if (pDrawItem->itemState & ODS_SELECTED) {
2646  			RECT rcImage = pDrawItem->rcItem;
2647  			rcImage.right = rcBox.left;
2648  			FillRectColour(pDrawItem->hDC, &rcImage, ColourOfElement(options.back, COLOR_WINDOW));
2649  			FillRectColour(pDrawItem->hDC, &rcBox, ColourOfElement(options.backSelected, COLOR_HIGHLIGHT));
2650  			::SetBkColor(pDrawItem->hDC, ColourOfElement(options.backSelected, COLOR_HIGHLIGHT));
2651  			::SetTextColor(pDrawItem->hDC, ColourOfElement(options.foreSelected, COLOR_HIGHLIGHTTEXT));
2652  		} else {
2653  			FillRectColour(pDrawItem->hDC, &pDrawItem->rcItem, ColourOfElement(options.back, COLOR_WINDOW));
2654  			::SetBkColor(pDrawItem->hDC, ColourOfElement(options.back, COLOR_WINDOW));
2655  			::SetTextColor(pDrawItem->hDC, ColourOfElement(options.fore, COLOR_WINDOWTEXT));
2656  		}
2657  		const ListItemData item = lti.Get(pDrawItem->itemID);
2658  		const int pixId = item.pixId;
2659  		const char *text = item.text;
2660  		const int len = static_cast<int>(strlen(text));
2661  		RECT rcText = rcBox;
2662  		::InsetRect(&rcText, static_cast<int>(TextInset.x), static_cast<int>(TextInset.y));
2663  		if (unicodeMode) {
2664  			const TextWide tbuf(text, CpUtf8);
2665  			::DrawTextW(pDrawItem->hDC, tbuf.buffer, tbuf.tlen, &rcText, DT_NOPREFIX|DT_END_ELLIPSIS|DT_SINGLELINE|DT_NOCLIP);
2666  		} else {
2667  			::DrawTextA(pDrawItem->hDC, text, len, &rcText, DT_NOPREFIX|DT_END_ELLIPSIS|DT_SINGLELINE|DT_NOCLIP);
2668  		}
2669  		const RGBAImage *pimage = images.Get(pixId);
2670  		if (pimage) {
2671  			std::unique_ptr<Surface> surfaceItem(Surface::Allocate(technology));
2672  			if (technology == Technology::Default) {
2673  				surfaceItem->Init(pDrawItem->hDC, pDrawItem->hwndItem);
2674  				const long left = pDrawItem->rcItem.left + static_cast<int>(ItemInset.x + ImageInset.x);
2675  				const PRectangle rcImage = PRectangle::FromInts(left, pDrawItem->rcItem.top,
2676  					left + images.GetWidth(), pDrawItem->rcItem.bottom);
2677  				surfaceItem->DrawRGBAImage(rcImage,
2678  					pimage->GetWidth(), pimage->GetHeight(), pimage->Pixels());
2679  				::SetTextAlign(pDrawItem->hDC, TA_TOP);
2680  			} else {
2681  #if defined(USE_D2D)
2682  				const D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(
2683  					D2D1_RENDER_TARGET_TYPE_DEFAULT,
2684  					D2D1::PixelFormat(
2685  						DXGI_FORMAT_B8G8R8A8_UNORM,
2686  						D2D1_ALPHA_MODE_IGNORE),
2687  					0,
2688  					0,
2689  					D2D1_RENDER_TARGET_USAGE_NONE,
2690  					D2D1_FEATURE_LEVEL_DEFAULT
2691  					);
2692  				ID2D1DCRenderTarget *pDCRT = nullptr;
2693  				HRESULT hr = pD2DFactory->CreateDCRenderTarget(&props, &pDCRT);
2694  				if (SUCCEEDED(hr) && pDCRT) {
2695  					const long left = pDrawItem->rcItem.left + static_cast<long>(ItemInset.x + ImageInset.x);
2696  					RECT rcItem = pDrawItem->rcItem;
2697  					rcItem.left = left;
2698  					rcItem.right = rcItem.left + images.GetWidth();
2699  					hr = pDCRT->BindDC(pDrawItem->hDC, &rcItem);
2700  					if (SUCCEEDED(hr)) {
2701  						surfaceItem->Init(pDCRT, pDrawItem->hwndItem);
2702  						pDCRT->BeginDraw();
2703  						const PRectangle rcImage = PRectangle::FromInts(0, 0, images.GetWidth(), rcItem.bottom - rcItem.top);
2704  						surfaceItem->DrawRGBAImage(rcImage,
2705  							pimage->GetWidth(), pimage->GetHeight(), pimage->Pixels());
2706  						pDCRT->EndDraw();
2707  						ReleaseUnknown(pDCRT);
2708  					}
2709  				}
2710  #endif
2711  			}
2712  		}
2713  	}
2714  }
2715  void ListBoxX::AppendListItem(const char *text, const char *numword) {
2716  	int pixId = -1;
2717  	if (numword) {
2718  		pixId = 0;
2719  		char ch;
2720  		while ((ch = *++numword) != '\0') {
2721  			pixId = 10 * pixId + (ch - '0');
2722  		}
2723  	}
2724  	lti.AllocItem(text, pixId);
2725  	const unsigned int len = static_cast<unsigned int>(strlen(text));
2726  	if (maxItemCharacters < len) {
2727  		maxItemCharacters = len;
2728  		widestItem = text;
2729  	}
2730  }
2731  void ListBoxX::SetDelegate(IListBoxDelegate *lbDelegate) {
2732  	delegate = lbDelegate;
2733  }
2734  void ListBoxX::SetList(const char *list, char separator, char typesep) {
2735  	SetRedraw(false);
2736  	Clear();
2737  	const size_t size = strlen(list);
2738  	char *words = lti.SetWords(list);
2739  	char *startword = words;
2740  	char *numword = nullptr;
2741  	for (size_t i=0; i < size; i++) {
2742  		if (words[i] == separator) {
2743  			words[i] = '\0';
2744  			if (numword)
2745  				*numword = '\0';
2746  			AppendListItem(startword, numword);
2747  			startword = words + i + 1;
2748  			numword = nullptr;
2749  		} else if (words[i] == typesep) {
2750  			numword = words + i;
2751  		}
2752  	}
2753  	if (startword) {
2754  		if (numword)
2755  			*numword = '\0';
2756  		AppendListItem(startword, numword);
2757  	}
2758  	const int count = lti.Count();
2759  	::SendMessage(lb, LB_INITSTORAGE, count, 0);
2760  	for (intptr_t j=0; j<count; j++) {
2761  		ListBox_AddItemData(lb, j+1);
2762  	}
2763  	SetRedraw(true);
2764  }
2765  void ListBoxX::SetOptions(ListOptions options_) {
2766  	options = options_;
2767  	frameStyle = FlagSet(options.options, AutoCompleteOption::FixedSize) ? WS_BORDER : WS_THICKFRAME;
2768  }
2769  void ListBoxX::AdjustWindowRect(PRectangle *rc, UINT dpiAdjust) const noexcept {
2770  	RECT rcw = RectFromPRectangle(*rc);
2771  	if (fnAdjustWindowRectExForDpi) {
2772  		fnAdjustWindowRectExForDpi(&rcw, frameStyle, false, WS_EX_WINDOWEDGE, dpiAdjust);
2773  	} else {
2774  		::AdjustWindowRectEx(&rcw, frameStyle, false, WS_EX_WINDOWEDGE);
2775  	}
2776  	*rc = PRectangle::FromInts(rcw.left, rcw.top, rcw.right, rcw.bottom);
2777  }
2778  int ListBoxX::ItemHeight() const {
2779  	int itemHeight = lineHeight + (static_cast<int>(TextInset.y) * 2);
2780  	const int pixHeight = images.GetHeight() + (static_cast<int>(ImageInset.y) * 2);
2781  	if (itemHeight < pixHeight) {
2782  		itemHeight = pixHeight;
2783  	}
2784  	return itemHeight;
2785  }
2786  int ListBoxX::MinClientWidth() const noexcept {
2787  	return 12 * (aveCharWidth+aveCharWidth/3);
2788  }
2789  POINT ListBoxX::MinTrackSize() const {
2790  	PRectangle rc = PRectangle::FromInts(0, 0, MinClientWidth(), ItemHeight());
2791  	AdjustWindowRect(&rc, dpi);
2792  	POINT ret = {static_cast<LONG>(rc.Width()), static_cast<LONG>(rc.Height())};
2793  	return ret;
2794  }
2795  POINT ListBoxX::MaxTrackSize() const {
2796  	PRectangle rc = PRectangle::FromInts(0, 0,
2797  		std::max(static_cast<unsigned int>(MinClientWidth()),
2798  		maxCharWidth * maxItemCharacters + static_cast<int>(TextInset.x) * 2 +
2799  		 TextOffset() + SystemMetricsForDpi(SM_CXVSCROLL, dpi)),
2800  		ItemHeight() * lti.Count());
2801  	AdjustWindowRect(&rc, dpi);
2802  	POINT ret = {static_cast<LONG>(rc.Width()), static_cast<LONG>(rc.Height())};
2803  	return ret;
2804  }
2805  void ListBoxX::SetRedraw(bool on) noexcept {
2806  	::SendMessage(lb, WM_SETREDRAW, on, 0);
2807  	if (on)
2808  		::InvalidateRect(lb, nullptr, TRUE);
2809  }
2810  void ListBoxX::ResizeToCursor() {
2811  	PRectangle rc = GetPosition();
2812  	POINT ptw;
2813  	::GetCursorPos(&ptw);
2814  	const Point pt = PointFromPOINT(ptw) + dragOffset;
2815  	switch (resizeHit) {
2816  		case HTLEFT:
2817  			rc.left = pt.x;
2818  			break;
2819  		case HTRIGHT:
2820  			rc.right = pt.x;
2821  			break;
2822  		case HTTOP:
2823  			rc.top = pt.y;
2824  			break;
2825  		case HTTOPLEFT:
2826  			rc.top = pt.y;
2827  			rc.left = pt.x;
2828  			break;
2829  		case HTTOPRIGHT:
2830  			rc.top = pt.y;
2831  			rc.right = pt.x;
2832  			break;
2833  		case HTBOTTOM:
2834  			rc.bottom = pt.y;
2835  			break;
2836  		case HTBOTTOMLEFT:
2837  			rc.bottom = pt.y;
2838  			rc.left = pt.x;
2839  			break;
2840  		case HTBOTTOMRIGHT:
2841  			rc.bottom = pt.y;
2842  			rc.right = pt.x;
2843  			break;
2844  		default:
2845  			break;
2846  	}
2847  	const POINT ptMin = MinTrackSize();
2848  	const POINT ptMax = MaxTrackSize();
2849  	rc.left = std::clamp(rc.left, rcPreSize.right - ptMax.x, rcPreSize.right - ptMin.x);
2850  	rc.top = std::clamp(rc.top, rcPreSize.bottom - ptMax.y, rcPreSize.bottom - ptMin.y);
2851  	rc.right = std::clamp(rc.right, rcPreSize.left + ptMin.x, rcPreSize.left + ptMax.x);
2852  	rc.bottom = std::clamp(rc.bottom, rcPreSize.top + ptMin.y, rcPreSize.top + ptMax.y);
2853  	SetPosition(rc);
2854  }
2855  void ListBoxX::StartResize(WPARAM hitCode) {
2856  	rcPreSize = GetPosition();
2857  	POINT cursorPos;
2858  	::GetCursorPos(&cursorPos);
2859  	switch (hitCode) {
2860  		case HTRIGHT:
2861  		case HTBOTTOM:
2862  		case HTBOTTOMRIGHT:
2863  			dragOffset.x = rcPreSize.right - cursorPos.x;
2864  			dragOffset.y = rcPreSize.bottom - cursorPos.y;
2865  			break;
2866  		case HTTOPRIGHT:
2867  			dragOffset.x = rcPreSize.right - cursorPos.x;
2868  			dragOffset.y = rcPreSize.top - cursorPos.y;
2869  			break;
2870  		case HTLEFT:
2871  		case HTTOP:
2872  		case HTTOPLEFT:
2873  			dragOffset.x = rcPreSize.left - cursorPos.x;
2874  			dragOffset.y = rcPreSize.top - cursorPos.y;
2875  			break;
2876  		case HTBOTTOMLEFT:
2877  			dragOffset.x = rcPreSize.left - cursorPos.x;
2878  			dragOffset.y = rcPreSize.bottom - cursorPos.y;
2879  			break;
2880  		default:
2881  			return;
2882  	}
2883  	::SetCapture(GetHWND());
2884  	resizeHit = hitCode;
2885  }
2886  LRESULT ListBoxX::NcHitTest(WPARAM wParam, LPARAM lParam) const {
2887  	const PRectangle rc = GetPosition();
2888  	LRESULT hit = ::DefWindowProc(GetHWND(), WM_NCHITTEST, wParam, lParam);
2889  	if (hit >= HTTOP && hit <= HTTOPRIGHT) {
2890  		const int minHeight = SystemMetricsForDpi(SM_CYMINTRACK, dpi);
2891  		const int yPos = GET_Y_LPARAM(lParam);
2892  		if ((rc.Height() < minHeight) && (yPos > ((rc.top + rc.bottom)/2))) {
2893  			hit += HTBOTTOM - HTTOP;
2894  		}
2895  	}
2896  	switch (hit) {
2897  		case HTLEFT:
2898  		case HTTOPLEFT:
2899  		case HTBOTTOMLEFT:
2900  			hit = HTERROR;
2901  			break;
2902  		case HTTOP:
2903  		case HTTOPRIGHT: {
2904  				if (location.y < rc.top)
2905  					hit = HTERROR;
2906  			}
2907  			break;
2908  		case HTBOTTOM:
2909  		case HTBOTTOMRIGHT: {
2910  				if (rc.bottom <= location.y)
2911  					hit = HTERROR;
2912  			}
2913  			break;
2914  		default:
2915  			break;
2916  	}
2917  	return hit;
2918  }
2919  void ListBoxX::OnDoubleClick() {
2920  	if (delegate) {
2921  		ListBoxEvent event(ListBoxEvent::EventType::doubleClick);
2922  		delegate->ListNotify(&event);
2923  	}
2924  }
2925  void ListBoxX::OnSelChange() {
2926  	if (delegate) {
2927  		ListBoxEvent event(ListBoxEvent::EventType::selectionChange);
2928  		delegate->ListNotify(&event);
2929  	}
2930  }
2931  POINT ListBoxX::GetClientExtent() const noexcept {
2932  	RECT rc;
2933  	::GetWindowRect(HwndFromWindowID(wid), &rc);
2934  	POINT ret { rc.right - rc.left, rc.bottom - rc.top };
2935  	return ret;
2936  }
2937  void ListBoxX::CentreItem(int n) {
2938  	if (n >= 0) {
2939  		const POINT extent = GetClientExtent();
2940  		const int visible = extent.y/ItemHeight();
2941  		if (visible < Length()) {
2942  			const int top = ListBox_GetTopIndex(lb);
2943  			const int half = (visible - 1) / 2;
2944  			if (n > (top + half))
2945  				ListBox_SetTopIndex(lb, n - half);
2946  		}
2947  	}
2948  }
2949  void ListBoxX::Paint(HDC hDC) {
2950  	const POINT extent = GetClientExtent();
2951  	HBITMAP hBitmap = ::CreateCompatibleBitmap(hDC, extent.x, extent.y);
2952  	HDC bitmapDC = ::CreateCompatibleDC(hDC);
2953  	HBITMAP hBitmapOld = SelectBitmap(bitmapDC, hBitmap);
2954  	const RECT rc = { 0, 0, extent.x, extent.y };
2955  	FillRectColour(bitmapDC, &rc, ColourOfElement(options.back, COLOR_WINDOWTEXT));
2956  	::SendMessage(lb, WM_PRINT, reinterpret_cast<WPARAM>(bitmapDC), PRF_CLIENT|PRF_NONCLIENT);
2957  	::BitBlt(hDC, 0, 0, extent.x, extent.y, bitmapDC, 0, 0, SRCCOPY);
2958  	SelectBrush(bitmapDC, GetStockBrush(WHITE_BRUSH));
2959  	SelectBitmap(bitmapDC, hBitmapOld);
2960  	::DeleteDC(bitmapDC);
2961  	::DeleteObject(hBitmap);
2962  }
2963  LRESULT PASCAL ListBoxX::ControlWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
2964  	try {
2965  		ListBoxX *lbx = static_cast<ListBoxX *>(PointerFromWindow(::GetParent(hWnd)));
2966  		switch (iMessage) {
2967  		case WM_ERASEBKGND:
2968  			return TRUE;
2969  		case WM_PAINT: {
2970  				PAINTSTRUCT ps;
2971  				HDC hDC = ::BeginPaint(hWnd, &ps);
2972  				if (lbx) {
2973  					lbx->Paint(hDC);
2974  				}
2975  				::EndPaint(hWnd, &ps);
2976  			}
2977  			return 0;
2978  		case WM_MOUSEACTIVATE:
2979  			return MA_NOACTIVATE;
2980  		case WM_LBUTTONDOWN: {
2981  				const LRESULT lResult = ::SendMessage(hWnd, LB_ITEMFROMPOINT, 0, lParam);
2982  				if (HIWORD(lResult) == 0) {
2983  					ListBox_SetCurSel(hWnd, LOWORD(lResult));
2984  					if (lbx) {
2985  						lbx->OnSelChange();
2986  					}
2987  				}
2988  			}
2989  			return 0;
2990  		case WM_LBUTTONUP:
2991  			return 0;
2992  		case WM_LBUTTONDBLCLK: {
2993  				if (lbx) {
2994  					lbx->OnDoubleClick();
2995  				}
2996  			}
2997  			return 0;
2998  		case WM_MBUTTONDOWN:
2999  			return 0;
3000  		default:
3001  			break;
3002  		}
3003  		WNDPROC prevWndProc = reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_USERDATA));
3004  		if (prevWndProc) {
3005  			return ::CallWindowProc(prevWndProc, hWnd, iMessage, wParam, lParam);
3006  		} else {
3007  			return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3008  		}
3009  	} catch (...) {
3010  	}
3011  	return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3012  }
3013  LRESULT ListBoxX::WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
3014  	switch (iMessage) {
3015  	case WM_CREATE: {
3016  			HINSTANCE hinstanceParent = GetWindowInstance(HwndFromWindow(*parent));
3017  			lb = ::CreateWindowEx(
3018  				0, TEXT("listbox"), TEXT(""),
3019  				WS_CHILD | WS_VSCROLL | WS_VISIBLE |
3020  				LBS_OWNERDRAWFIXED | LBS_NODATA | LBS_NOINTEGRALHEIGHT,
3021  				0, 0, 150,80, hWnd,
3022  				reinterpret_cast<HMENU>(static_cast<ptrdiff_t>(ctrlID)),
3023  				hinstanceParent,
3024  				0);
3025  			WNDPROC prevWndProc = SubclassWindow(lb, ControlWndProc);
3026  			::SetWindowLongPtr(lb, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(prevWndProc));
3027  		}
3028  		break;
3029  	case WM_SIZE:
3030  		if (lb) {
3031  			SetRedraw(false);
3032  			::SetWindowPos(lb, 0, 0,0, LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE);
3033  			CentreItem(GetSelection());
3034  			SetRedraw(true);
3035  		}
3036  		break;
3037  	case WM_PAINT: {
3038  			PAINTSTRUCT ps;
3039  			::BeginPaint(hWnd, &ps);
3040  			::EndPaint(hWnd, &ps);
3041  		}
3042  		break;
3043  	case WM_COMMAND:
3044  		::SendMessage(HwndFromWindow(*parent), iMessage, wParam, lParam);
3045  		break;
3046  	case WM_MEASUREITEM: {
3047  			MEASUREITEMSTRUCT *pMeasureItem = reinterpret_cast<MEASUREITEMSTRUCT *>(lParam);
3048  			pMeasureItem->itemHeight = ItemHeight();
3049  		}
3050  		break;
3051  	case WM_DRAWITEM:
3052  		Draw(reinterpret_cast<DRAWITEMSTRUCT *>(lParam));
3053  		break;
3054  	case WM_DESTROY:
3055  		lb = 0;
3056  		SetWindowPointer(hWnd, nullptr);
3057  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3058  	case WM_ERASEBKGND:
3059  		return TRUE;
3060  	case WM_GETMINMAXINFO: {
3061  			MINMAXINFO *minMax = reinterpret_cast<MINMAXINFO*>(lParam);
3062  			minMax->ptMaxTrackSize = MaxTrackSize();
3063  			minMax->ptMinTrackSize = MinTrackSize();
3064  		}
3065  		break;
3066  	case WM_MOUSEACTIVATE:
3067  		return MA_NOACTIVATE;
3068  	case WM_NCHITTEST:
3069  		return NcHitTest(wParam, lParam);
3070  	case WM_NCLBUTTONDOWN:
3071  		StartResize(wParam);
3072  		return 0;
3073  	case WM_MOUSEMOVE: {
3074  			if (resizeHit == 0) {
3075  				return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3076  			} else {
3077  				ResizeToCursor();
3078  			}
3079  		}
3080  		break;
3081  	case WM_LBUTTONUP:
3082  	case WM_CANCELMODE:
3083  		if (resizeHit != 0) {
3084  			resizeHit = 0;
3085  			::ReleaseCapture();
3086  		}
3087  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3088  	case WM_MOUSEWHEEL:
3089  		if (wheelDelta.Accumulate(wParam)) {
3090  			const int nRows = GetVisibleRows();
3091  			int linesToScroll = std::clamp(nRows - 1, 1, 3);
3092  			linesToScroll *= wheelDelta.Actions();
3093  			int top = ListBox_GetTopIndex(lb) + linesToScroll;
3094  			if (top < 0) {
3095  				top = 0;
3096  			}
3097  			ListBox_SetTopIndex(lb, top);
3098  		}
3099  		break;
3100  	default:
3101  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3102  	}
3103  	return 0;
3104  }
3105  LRESULT PASCAL ListBoxX::StaticWndProc(
3106      HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
3107  	if (iMessage == WM_CREATE) {
3108  		CREATESTRUCT *pCreate = reinterpret_cast<CREATESTRUCT *>(lParam);
3109  		SetWindowPointer(hWnd, pCreate->lpCreateParams);
3110  	}
3111  	ListBoxX *lbx = static_cast<ListBoxX *>(PointerFromWindow(hWnd));
3112  	if (lbx) {
3113  		return lbx->WndProc(hWnd, iMessage, wParam, lParam);
3114  	} else {
3115  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3116  	}
3117  }
3118  namespace {
3119  bool ListBoxX_Register() noexcept {
3120  	WNDCLASSEX wndclassc {};
3121  	wndclassc.cbSize = sizeof(wndclassc);
3122  	wndclassc.style = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
3123  	wndclassc.cbWndExtra = sizeof(ListBoxX *);
3124  	wndclassc.hInstance = hinstPlatformRes;
3125  	wndclassc.lpfnWndProc = ListBoxX::StaticWndProc;
3126  	wndclassc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
3127  	wndclassc.lpszClassName = ListBoxX_ClassName;
3128  	return ::RegisterClassEx(&wndclassc) != 0;
3129  }
3130  void ListBoxX_Unregister() noexcept {
3131  	if (hinstPlatformRes) {
3132  		::UnregisterClass(ListBoxX_ClassName, hinstPlatformRes);
3133  	}
3134  }
3135  }
3136  Menu::Menu() noexcept : mid{} {
3137  }
3138  void Menu::CreatePopUp() {
3139  	Destroy();
3140  	mid = ::CreatePopupMenu();
3141  }
3142  void Menu::Destroy() noexcept {
3143  	if (mid)
3144  		::DestroyMenu(static_cast<HMENU>(mid));
3145  	mid = 0;
3146  }
3147  void Menu::Show(Point pt, const Window &w) {
3148  	::TrackPopupMenu(static_cast<HMENU>(mid),
3149  		TPM_RIGHTBUTTON, static_cast<int>(pt.x - 4), static_cast<int>(pt.y), 0,
3150  		HwndFromWindow(w), nullptr);
3151  	Destroy();
3152  }
3153  ColourRGBA Platform::Chrome() {
3154  	return ColourRGBA::FromRGB(static_cast<int>(::GetSysColor(COLOR_3DFACE)));
3155  }
3156  ColourRGBA Platform::ChromeHighlight() {
3157  	return ColourRGBA::FromRGB(static_cast<int>(::GetSysColor(COLOR_3DHIGHLIGHT)));
3158  }
3159  const char *Platform::DefaultFont() {
3160  	return "Verdana";
3161  }
3162  int Platform::DefaultFontSize() {
3163  	return 8;
3164  }
3165  unsigned int Platform::DoubleClickTime() {
3166  	return ::GetDoubleClickTime();
3167  }
3168  void Platform::DebugDisplay(const char *s) noexcept {
3169  	::OutputDebugStringA(s);
3170  }
3171  #ifdef TRACE
3172  void Platform::DebugPrintf(const char *format, ...) noexcept {
3173  	char buffer[2000];
3174  	va_list pArguments;
3175  	va_start(pArguments, format);
3176  	vsnprintf(buffer, std::size(buffer), format, pArguments);
3177  	va_end(pArguments);
3178  	Platform::DebugDisplay(buffer);
3179  }
3180  #else
3181  void Platform::DebugPrintf(const char *, ...) noexcept {
3182  }
3183  #endif
3184  static bool assertionPopUps = true;
3185  bool Platform::ShowAssertionPopUps(bool assertionPopUps_) noexcept {
3186  	const bool ret = assertionPopUps;
3187  	assertionPopUps = assertionPopUps_;
3188  	return ret;
3189  }
3190  void Platform::Assert(const char *c, const char *file, int line) noexcept {
3191  	char buffer[2000] {};
3192  	snprintf(buffer, std::size(buffer), "Assertion [%s] failed at %s %d%s", c, file, line, assertionPopUps ? "" : "\r\n");
3193  	if (assertionPopUps) {
3194  		const int idButton = ::MessageBoxA(0, buffer, "Assertion failure",
3195  			MB_ABORTRETRYIGNORE|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);
3196  		if (idButton == IDRETRY) {
3197  			::DebugBreak();
3198  		} else if (idButton == IDIGNORE) {
3199  		} else {
3200  			abort();
3201  		}
3202  	} else {
3203  		Platform::DebugDisplay(buffer);
3204  		::DebugBreak();
3205  		abort();
3206  	}
3207  }
3208  void Platform_Initialise(void *hInstance) noexcept {
3209  	hinstPlatformRes = static_cast<HINSTANCE>(hInstance);
3210  	LoadDpiForWindow();
3211  	ListBoxX_Register();
3212  }
3213  void Platform_Finalise(bool fromDllMain) noexcept {
3214  #if defined(USE_D2D)
3215  	if (!fromDllMain) {
3216  		ReleaseUnknown(pIDWriteFactory);
3217  		ReleaseUnknown(pD2DFactory);
3218  		if (hDLLDWrite) {
3219  			FreeLibrary(hDLLDWrite);
3220  			hDLLDWrite = {};
3221  		}
3222  		if (hDLLD2D) {
3223  			FreeLibrary(hDLLD2D);
3224  			hDLLD2D = {};
3225  		}
3226  	}
3227  #endif
3228  	if (!fromDllMain && hDLLShcore) {
3229  		FreeLibrary(hDLLShcore);
3230  		hDLLShcore = {};
3231  	}
3232  	ListBoxX_Unregister();
3233  }
3234  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatWin.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstring>
4  #include <cstdio>
5  #include <cstdarg>
6  #include <ctime>
7  #include <cmath>
8  #include <climits>
9  #include <string_view>
10  #include <vector>
11  #include <map>
12  #include <optional>
13  #include <algorithm>
14  #include <iterator>
15  #include <memory>
16  #include <mutex>
17  #if !defined(NOMINMAX)
18  #define NOMINMAX
19  #endif
20  #undef _WIN32_WINNT
21  #define _WIN32_WINNT 0x0A00
22  #undef WINVER
23  #define WINVER 0x0A00
24  #define WIN32_LEAN_AND_MEAN 1
25  #include <windows.h>
26  #include <commctrl.h>
27  #include <richedit.h>
28  #include <windowsx.h>
29  #include <shellscalingapi.h>
30  #if !defined(DISABLE_D2D)
31  #define USE_D2D 1
32  #endif
33  #if defined(USE_D2D)
34  #include <d2d1.h>
35  #include <dwrite.h>
36  #endif
37  #include "ScintillaTypes.h"
38  #include "Debugging.h"
39  #include "Geometry.h"
40  #include "Platform.h"
41  #include "XPM.h"
42  #include "UniConversion.h"
43  #include "DBCS.h"
44  #include "WinTypes.h"
45  #include "PlatWin.h"
46  #if defined(__clang__)
47  #pragma clang diagnostic ignored "-Wlanguage-extension-token"
48  #endif
49  using namespace Scintilla;
50  namespace Scintilla::Internal {
51  UINT CodePageFromCharSet(CharacterSet characterSet, UINT documentCodePage) noexcept;
52  #if defined(USE_D2D)
53  IDWriteFactory *pIDWriteFactory = nullptr;
54  ID2D1Factory *pD2DFactory = nullptr;
55  D2D1_DRAW_TEXT_OPTIONS d2dDrawTextOptions = D2D1_DRAW_TEXT_OPTIONS_NONE;
56  static HMODULE hDLLD2D {};
57  static HMODULE hDLLDWrite {};
58  void LoadD2DOnce() noexcept {
59  	DWORD loadLibraryFlags = 0;
60  	HMODULE kernel32 = ::GetModuleHandleW(L"kernel32.dll");
61  	if (kernel32) {
62  		if (::GetProcAddress(kernel32, "SetDefaultDllDirectories")) {
63  			loadLibraryFlags = LOAD_LIBRARY_SEARCH_SYSTEM32;
64  		}
65  	}
66  	typedef HRESULT (WINAPI *D2D1CFSig)(D2D1_FACTORY_TYPE factoryType, REFIID riid,
67  		CONST D2D1_FACTORY_OPTIONS *pFactoryOptions, IUnknown **factory);
68  	typedef HRESULT (WINAPI *DWriteCFSig)(DWRITE_FACTORY_TYPE factoryType, REFIID iid,
69  		IUnknown **factory);
70  	hDLLD2D = ::LoadLibraryEx(TEXT("D2D1.DLL"), 0, loadLibraryFlags);
71  	D2D1CFSig fnD2DCF = DLLFunction<D2D1CFSig>(hDLLD2D, "D2D1CreateFactory");
72  	if (fnD2DCF) {
73  		fnD2DCF(D2D1_FACTORY_TYPE_SINGLE_THREADED,
74  			__uuidof(ID2D1Factory),
75  			nullptr,
76  			reinterpret_cast<IUnknown**>(&pD2DFactory));
77  	}
78  	hDLLDWrite = ::LoadLibraryEx(TEXT("DWRITE.DLL"), 0, loadLibraryFlags);
79  	DWriteCFSig fnDWCF = DLLFunction<DWriteCFSig>(hDLLDWrite, "DWriteCreateFactory");
80  	if (fnDWCF) {
81  		const GUID IID_IDWriteFactory2 = 
82  		{ 0x0439fc60, 0xca44, 0x4994, { 0x8d, 0xee, 0x3a, 0x9a, 0xf7, 0xb7, 0x32, 0xec } };
83  		const HRESULT hr = fnDWCF(DWRITE_FACTORY_TYPE_SHARED,
84  			IID_IDWriteFactory2,
85  			reinterpret_cast<IUnknown**>(&pIDWriteFactory));
86  		if (SUCCEEDED(hr)) {
87  			d2dDrawTextOptions = static_cast<D2D1_DRAW_TEXT_OPTIONS>(0x00000004);
88  		} else {
89  			fnDWCF(DWRITE_FACTORY_TYPE_SHARED,
90  				__uuidof(IDWriteFactory),
91  				reinterpret_cast<IUnknown**>(&pIDWriteFactory));
92  		}
93  	}
94  }
95  bool LoadD2D() {
96  	static std::once_flag once;
97  	std::call_once(once, LoadD2DOnce);
98  	return pIDWriteFactory && pD2DFactory;
99  }
100  #endif
101  void *PointerFromWindow(HWND hWnd) noexcept {
102  	return reinterpret_cast<void *>(::GetWindowLongPtr(hWnd, 0));
103  }
104  void SetWindowPointer(HWND hWnd, void *ptr) noexcept {
105  	::SetWindowLongPtr(hWnd, 0, reinterpret_cast<LONG_PTR>(ptr));
106  }
107  namespace {
108  UINT uSystemDPI = USER_DEFAULT_SCREEN_DPI;
109  using GetDpiForWindowSig = UINT(WINAPI *)(HWND hwnd);
110  GetDpiForWindowSig fnGetDpiForWindow = nullptr;
111  HMODULE hDLLShcore {};
112  using GetDpiForMonitorSig = HRESULT (WINAPI *)(HMONITOR hmonitor, &bsol;*MONITOR_DPI_TYPE*/int dpiType, UINT *dpiX, UINT *dpiY);
113  GetDpiForMonitorSig fnGetDpiForMonitor = nullptr;
114  using GetSystemMetricsForDpiSig = int(WINAPI *)(int nIndex, UINT dpi);
115  GetSystemMetricsForDpiSig fnGetSystemMetricsForDpi = nullptr;
116  using AdjustWindowRectExForDpiSig = BOOL(WINAPI *)(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi);
117  AdjustWindowRectExForDpiSig fnAdjustWindowRectExForDpi = nullptr;
118  using AreDpiAwarenessContextsEqualSig = BOOL(WINAPI *)(DPI_AWARENESS_CONTEXT, DPI_AWARENESS_CONTEXT);
119  AreDpiAwarenessContextsEqualSig fnAreDpiAwarenessContextsEqual = nullptr;
120  using GetWindowDpiAwarenessContextSig = DPI_AWARENESS_CONTEXT(WINAPI *)(HWND);
121  GetWindowDpiAwarenessContextSig fnGetWindowDpiAwarenessContext = nullptr;
122  using GetScaleFactorForMonitorSig = HRESULT(WINAPI *)(HMONITOR, DEVICE_SCALE_FACTOR *);
123  GetScaleFactorForMonitorSig fnGetScaleFactorForMonitor = nullptr;
124  using SetThreadDpiAwarenessContextSig = DPI_AWARENESS_CONTEXT(WINAPI *)(DPI_AWARENESS_CONTEXT);
125  SetThreadDpiAwarenessContextSig fnSetThreadDpiAwarenessContext = nullptr;
126  void LoadDpiForWindow() noexcept {
127  	HMODULE user32 = ::GetModuleHandleW(L"user32.dll");
128  	fnGetDpiForWindow = DLLFunction<GetDpiForWindowSig>(user32, "GetDpiForWindow");
129  	fnGetSystemMetricsForDpi = DLLFunction<GetSystemMetricsForDpiSig>(user32, "GetSystemMetricsForDpi");
130  	fnAdjustWindowRectExForDpi = DLLFunction<AdjustWindowRectExForDpiSig>(user32, "AdjustWindowRectExForDpi");
131  	fnSetThreadDpiAwarenessContext = DLLFunction<SetThreadDpiAwarenessContextSig>(user32, "SetThreadDpiAwarenessContext");
132  	using GetDpiForSystemSig = UINT(WINAPI *)(void);
133  	GetDpiForSystemSig fnGetDpiForSystem = DLLFunction<GetDpiForSystemSig>(user32, "GetDpiForSystem");
134  	if (fnGetDpiForSystem) {
135  		uSystemDPI = fnGetDpiForSystem();
136  	} else {
137  		HDC hdcMeasure = ::CreateCompatibleDC({});
138  		uSystemDPI = ::GetDeviceCaps(hdcMeasure, LOGPIXELSY);
139  		::DeleteDC(hdcMeasure);
140  	}
141  	fnGetWindowDpiAwarenessContext = DLLFunction<GetWindowDpiAwarenessContextSig>(user32, "GetWindowDpiAwarenessContext");
142  	fnAreDpiAwarenessContextsEqual = DLLFunction<AreDpiAwarenessContextsEqualSig>(user32, "AreDpiAwarenessContextsEqual");
143  	hDLLShcore = ::LoadLibraryExW(L"shcore.dll", {}, LOAD_LIBRARY_SEARCH_SYSTEM32);
144  	if (hDLLShcore) {
145  		fnGetScaleFactorForMonitor = DLLFunction<GetScaleFactorForMonitorSig>(hDLLShcore, "GetScaleFactorForMonitor");
146  		fnGetDpiForMonitor = DLLFunction<GetDpiForMonitorSig>(hDLLShcore, "GetDpiForMonitor");
147  	}
148  }
149  HINSTANCE hinstPlatformRes {};
150  constexpr Supports SupportsGDI[] = {
151  	Supports::PixelModification,
152  };
153  constexpr BYTE Win32MapFontQuality(FontQuality extraFontFlag) noexcept {
154  	switch (extraFontFlag & FontQuality::QualityMask) {
155  		case FontQuality::QualityNonAntialiased:
156  			return NONANTIALIASED_QUALITY;
157  		case FontQuality::QualityAntialiased:
158  			return ANTIALIASED_QUALITY;
159  		case FontQuality::QualityLcdOptimized:
160  			return CLEARTYPE_QUALITY;
161  		default:
162  			return DEFAULT_QUALITY;
163  	}
164  }
165  #if defined(USE_D2D)
166  constexpr D2D1_TEXT_ANTIALIAS_MODE DWriteMapFontQuality(FontQuality extraFontFlag) noexcept {
167  	switch (extraFontFlag & FontQuality::QualityMask) {
168  		case FontQuality::QualityNonAntialiased:
169  			return D2D1_TEXT_ANTIALIAS_MODE_ALIASED;
170  		case FontQuality::QualityAntialiased:
171  			return D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE;
172  		case FontQuality::QualityLcdOptimized:
173  			return D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE;
174  		default:
175  			return D2D1_TEXT_ANTIALIAS_MODE_DEFAULT;
176  	}
177  }
178  #endif
179  struct FontWin : public Font {
180  	virtual HFONT HFont() const noexcept = 0;
181  };
182  void SetLogFont(LOGFONTW &lf, const char *faceName, CharacterSet characterSet, XYPOSITION size, FontWeight weight, bool italic, FontQuality extraFontFlag) {
183  	lf = LOGFONTW();
184  	lf.lfHeight = -(std::abs(std::lround(size)));
185  	lf.lfWeight = static_cast<LONG>(weight);
186  	lf.lfItalic = italic ? 1 : 0;
187  	lf.lfCharSet = static_cast<BYTE>(characterSet);
188  	lf.lfQuality = Win32MapFontQuality(extraFontFlag);
189  	UTF16FromUTF8(faceName, lf.lfFaceName, LF_FACESIZE);
190  }
191  struct FontGDI : public FontWin {
192  	HFONT hfont = {};
193  	FontGDI(const FontParameters &fp) {
194  		LOGFONTW lf;
195  		SetLogFont(lf, fp.faceName, fp.characterSet, fp.size, fp.weight, fp.italic, fp.extraFontFlag);
196  		hfont = ::CreateFontIndirectW(&lf);
197  	}
198  	FontGDI(const FontGDI &) = delete;
199  	FontGDI(FontGDI &&) = delete;
200  	FontGDI &operator=(const FontGDI &) = delete;
201  	FontGDI &operator=(FontGDI &&) = delete;
202  	~FontGDI() noexcept override {
203  		if (hfont)
204  			::DeleteObject(hfont);
205  	}
206  	HFONT HFont() const noexcept override {
207  		LOGFONTW lf = {};
208  		if (0 == ::GetObjectW(hfont, sizeof(lf), &lf)) {
209  			return {};
210  		}
211  		return ::CreateFontIndirectW(&lf);
212  	}
213  };
214  #if defined(USE_D2D)
215  struct FontDirectWrite : public FontWin {
216  	IDWriteTextFormat *pTextFormat = nullptr;
217  	FontQuality extraFontFlag = FontQuality::QualityDefault;
218  	CharacterSet characterSet = CharacterSet::Ansi;
219  	FLOAT yAscent = 2.0f;
220  	FLOAT yDescent = 1.0f;
221  	FLOAT yInternalLeading = 0.0f;
222  	FontDirectWrite(const FontParameters &fp) :
223  		extraFontFlag(fp.extraFontFlag),
224  		characterSet(fp.characterSet) {
225  		const std::wstring wsFace = WStringFromUTF8(fp.faceName);
226  		const std::wstring wsLocale = WStringFromUTF8(fp.localeName);
227  		const FLOAT fHeight = static_cast<FLOAT>(fp.size);
228  		const DWRITE_FONT_STYLE style = fp.italic ? DWRITE_FONT_STYLE_ITALIC : DWRITE_FONT_STYLE_NORMAL;
229  		HRESULT hr = pIDWriteFactory->CreateTextFormat(wsFace.c_str(), nullptr,
230  			static_cast<DWRITE_FONT_WEIGHT>(fp.weight),
231  			style,
232  			DWRITE_FONT_STRETCH_NORMAL, fHeight, wsLocale.c_str(), &pTextFormat);
233  		if (hr == E_INVALIDARG) {
234  			hr = pIDWriteFactory->CreateTextFormat(wsFace.c_str(), nullptr,
235  				static_cast<DWRITE_FONT_WEIGHT>(fp.weight),
236  				style,
237  				DWRITE_FONT_STRETCH_NORMAL, fHeight, L"en-us", &pTextFormat);
238  		}
239  		if (SUCCEEDED(hr)) {
240  			pTextFormat->SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP);
241  			IDWriteTextLayout *pTextLayout = nullptr;
242  			hr = pIDWriteFactory->CreateTextLayout(L"X", 1, pTextFormat,
243  					100.0f, 100.0f, &pTextLayout);
244  			if (SUCCEEDED(hr) && pTextLayout) {
245  				constexpr int maxLines = 2;
246  				DWRITE_LINE_METRICS lineMetrics[maxLines]{};
247  				UINT32 lineCount = 0;
248  				hr = pTextLayout->GetLineMetrics(lineMetrics, maxLines, &lineCount);
249  				if (SUCCEEDED(hr)) {
250  					yAscent = lineMetrics[0].baseline;
251  					yDescent = lineMetrics[0].height - lineMetrics[0].baseline;
252  					FLOAT emHeight;
253  					hr = pTextLayout->GetFontSize(0, &emHeight);
254  					if (SUCCEEDED(hr)) {
255  						yInternalLeading = lineMetrics[0].height - emHeight;
256  					}
257  				}
258  				ReleaseUnknown(pTextLayout);
259  				pTextFormat->SetLineSpacing(DWRITE_LINE_SPACING_METHOD_UNIFORM, lineMetrics[0].height, lineMetrics[0].baseline);
260  			}
261  		}
262  	}
263  	FontDirectWrite(const FontDirectWrite &) = delete;
264  	FontDirectWrite(FontDirectWrite &&) = delete;
265  	FontDirectWrite &operator=(const FontDirectWrite &) = delete;
266  	FontDirectWrite &operator=(FontDirectWrite &&) = delete;
267  	~FontDirectWrite() noexcept override {
268  		ReleaseUnknown(pTextFormat);
269  	}
270  	HFONT HFont() const noexcept override {
271  		LOGFONTW lf = {};
272  		const HRESULT hr = pTextFormat->GetFontFamilyName(lf.lfFaceName, LF_FACESIZE);
273  		if (!SUCCEEDED(hr)) {
274  			return {};
275  		}
276  		lf.lfWeight = pTextFormat->GetFontWeight();
277  		lf.lfItalic = pTextFormat->GetFontStyle() == DWRITE_FONT_STYLE_ITALIC;
278  		lf.lfHeight = -static_cast<int>(pTextFormat->GetFontSize());
279  		return ::CreateFontIndirectW(&lf);
280  	}
281  	int CodePageText(int codePage) const noexcept {
282  		if (!(codePage == CpUtf8) && (characterSet != CharacterSet::Ansi)) {
283  			codePage = CodePageFromCharSet(characterSet, codePage);
284  		}
285  		return codePage;
286  	}
287  	static const FontDirectWrite *Cast(const Font *font_) {
288  		const FontDirectWrite *pfm = dynamic_cast<const FontDirectWrite *>(font_);
289  		PLATFORM_ASSERT(pfm);
290  		if (!pfm) {
291  			throw std::runtime_error("SurfaceD2D::SetFont: wrong Font type.");
292  		}
293  		return pfm;
294  	}
295  };
296  #endif
297  }
298  HMONITOR MonitorFromWindowHandleScaling(HWND hWnd) noexcept {
299  	constexpr DWORD monitorFlags = MONITOR_DEFAULTTONEAREST;
300  	if (!fnSetThreadDpiAwarenessContext) {
301  		return ::MonitorFromWindow(hWnd, monitorFlags);
302  	}
303  	const DPI_AWARENESS_CONTEXT oldContext = fnSetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
304  	PLATFORM_ASSERT(oldContext != nullptr);
305  	RECT rect;
306  	::GetWindowRect(hWnd, &rect);
307  	const HMONITOR monitor = ::MonitorFromRect(&rect, monitorFlags);
308  	fnSetThreadDpiAwarenessContext(oldContext);
309  	return monitor;
310  }
311  int GetDeviceScaleFactorWhenGdiScalingActive(HWND hWnd) noexcept {
312  	if (fnAreDpiAwarenessContextsEqual) {
313  		PLATFORM_ASSERT(fnGetWindowDpiAwarenessContext && fnGetScaleFactorForMonitor);
314  		if (fnAreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED, fnGetWindowDpiAwarenessContext(hWnd))) {
315  			const HWND hRootWnd = ::GetAncestor(hWnd, GA_ROOT); 
316  			const HMONITOR hMonitor = MonitorFromWindowHandleScaling(hRootWnd);
317  			DEVICE_SCALE_FACTOR deviceScaleFactor;
318  			if (S_OK == fnGetScaleFactorForMonitor(hMonitor, &deviceScaleFactor))
319  				return (static_cast<int>(deviceScaleFactor) + 99) / 100; 
320  		}
321  	}
322  	return 1;
323  }
324  std::shared_ptr<Font> Font::Allocate(const FontParameters &fp) {
325  #if defined(USE_D2D)
326  	if (fp.technology != Technology::Default) {
327  		return std::make_shared<FontDirectWrite>(fp);
328  	}
329  #endif
330  	return std::make_shared<FontGDI>(fp);
331  }
332  template<typename T, int lengthStandard>
333  class VarBuffer {
334  	T bufferStandard[lengthStandard];
335  public:
336  	T *buffer;
337  	explicit VarBuffer(size_t length) : buffer(nullptr) {
338  		if (length > lengthStandard) {
339  			buffer = new T[length];
340  		} else {
341  			buffer = bufferStandard;
342  		}
343  	}
344  	VarBuffer(const VarBuffer &) = delete;
345  	VarBuffer(VarBuffer &&) = delete;
346  	VarBuffer &operator=(const VarBuffer &) = delete;
347  	VarBuffer &operator=(VarBuffer &&) = delete;
348  	~VarBuffer() noexcept {
349  		if (buffer != bufferStandard) {
350  			delete []buffer;
351  			buffer = nullptr;
352  		}
353  	}
354  };
355  constexpr int stackBufferLength = 400;
356  class TextWide : public VarBuffer<wchar_t, stackBufferLength> {
357  public:
358  	int tlen;	
359  	TextWide(std::string_view text, int codePage) :
360  		VarBuffer<wchar_t, stackBufferLength>(text.length()) {
361  		if (codePage == CpUtf8) {
362  			tlen = static_cast<int>(UTF16FromUTF8(text, buffer, text.length()));
363  		} else {
364  			tlen = ::MultiByteToWideChar(codePage, 0, text.data(), static_cast<int>(text.length()),
365  				buffer, static_cast<int>(text.length()));
366  		}
367  	}
368  };
369  typedef VarBuffer<XYPOSITION, stackBufferLength> TextPositions;
370  UINT DpiForWindow(WindowID wid) noexcept {
371  	if (fnGetDpiForWindow) {
372  		return fnGetDpiForWindow(HwndFromWindowID(wid));
373  	}
374  	if (fnGetDpiForMonitor) {
375  		HMONITOR hMonitor = ::MonitorFromWindow(HwndFromWindowID(wid), MONITOR_DEFAULTTONEAREST);
376  		UINT dpiX = 0;
377  		UINT dpiY = 0;
378  		if (fnGetDpiForMonitor(hMonitor, 0 &bsol;*MDT_EFFECTIVE_DPI*/, &dpiX, &dpiY) == S_OK) {
379  			return dpiY;
380  		}
381  	}
382  	return uSystemDPI;
383  }
384  int SystemMetricsForDpi(int nIndex, UINT dpi) noexcept {
385  	if (fnGetSystemMetricsForDpi) {
386  		return fnGetSystemMetricsForDpi(nIndex, dpi);
387  	}
388  	int value = ::GetSystemMetrics(nIndex);
389  	value = (dpi == uSystemDPI) ? value : ::MulDiv(value, dpi, uSystemDPI);
390  	return value;
391  }
392  class SurfaceGDI : public Surface {
393  	SurfaceMode mode;
394  	HDC hdc{};
395  	bool hdcOwned=false;
396  	HPEN pen{};
397  	HPEN penOld{};
398  	HBRUSH brush{};
399  	HBRUSH brushOld{};
400  	HFONT fontOld{};
401  	HBITMAP bitmap{};
402  	HBITMAP bitmapOld{};
403  	int logPixelsY = USER_DEFAULT_SCREEN_DPI;
404  	static constexpr int maxWidthMeasure = INT_MAX;
405  	static constexpr int maxLenText = 65535;
406  	void PenColour(ColourRGBA fore, XYPOSITION widthStroke) noexcept;
407  	void BrushColour(ColourRGBA back) noexcept;
408  	void SetFont(const Font *font_);
409  	void Clear() noexcept;
410  public:
411  	SurfaceGDI() noexcept;
412  	SurfaceGDI(HDC hdcCompatible, int width, int height, SurfaceMode mode_, int logPixelsY_) noexcept;
413  	SurfaceGDI(const SurfaceGDI &) = delete;
414  	SurfaceGDI(SurfaceGDI &&) = delete;
415  	SurfaceGDI &operator=(const SurfaceGDI &) = delete;
416  	SurfaceGDI &operator=(SurfaceGDI &&) = delete;
417  	~SurfaceGDI() noexcept override;
418  	void Init(WindowID wid) override;
419  	void Init(SurfaceID sid, WindowID wid) override;
420  	std::unique_ptr<Surface> AllocatePixMap(int width, int height) override;
421  	void SetMode(SurfaceMode mode_) override;
422  	void Release() noexcept override;
423  	int SupportsFeature(Supports feature) noexcept override;
424  	bool Initialised() override;
425  	int LogPixelsY() override;
426  	int PixelDivisions() override;
427  	int DeviceHeightFont(int points) override;
428  	void LineDraw(Point start, Point end, Stroke stroke) override;
429  	void PolyLine(const Point *pts, size_t npts, Stroke stroke) override;
430  	void Polygon(const Point *pts, size_t npts, FillStroke fillStroke) override;
431  	void RectangleDraw(PRectangle rc, FillStroke fillStroke) override;
432  	void RectangleFrame(PRectangle rc, Stroke stroke) override;
433  	void FillRectangle(PRectangle rc, Fill fill) override;
434  	void FillRectangleAligned(PRectangle rc, Fill fill) override;
435  	void FillRectangle(PRectangle rc, Surface &surfacePattern) override;
436  	void RoundedRectangle(PRectangle rc, FillStroke fillStroke) override;
437  	void AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) override;
438  	void GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) override;
439  	void DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) override;
440  	void Ellipse(PRectangle rc, FillStroke fillStroke) override;
441  	void Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) override;
442  	void Copy(PRectangle rc, Point from, Surface &surfaceSource) override;
443  	std::unique_ptr<IScreenLineLayout> Layout(const IScreenLine *screenLine) override;
444  	void DrawTextCommon(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, UINT fuOptions);
445  	void DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
446  	void DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
447  	void DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) override;
448  	void MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) override;
449  	XYPOSITION WidthText(const Font *font_, std::string_view text) override;
450  	void DrawTextCommonUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, UINT fuOptions);
451  	void DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
452  	void DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
453  	void DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) override;
454  	void MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) override;
455  	XYPOSITION WidthTextUTF8(const Font *font_, std::string_view text) override;
456  	XYPOSITION Ascent(const Font *font_) override;
457  	XYPOSITION Descent(const Font *font_) override;
458  	XYPOSITION InternalLeading(const Font *font_) override;
459  	XYPOSITION Height(const Font *font_) override;
460  	XYPOSITION AverageCharWidth(const Font *font_) override;
461  	void SetClip(PRectangle rc) override;
462  	void PopClip() override;
463  	void FlushCachedState() override;
464  	void FlushDrawing() override;
465  };
466  SurfaceGDI::SurfaceGDI() noexcept {
467  }
468  SurfaceGDI::SurfaceGDI(HDC hdcCompatible, int width, int height, SurfaceMode mode_, int logPixelsY_) noexcept {
469  	hdc = ::CreateCompatibleDC(hdcCompatible);
470  	hdcOwned = true;
471  	bitmap = ::CreateCompatibleBitmap(hdcCompatible, width, height);
472  	bitmapOld = SelectBitmap(hdc, bitmap);
473  	::SetTextAlign(hdc, TA_BASELINE);
474  	mode = mode_;
475  	logPixelsY = logPixelsY_;
476  }
477  SurfaceGDI::~SurfaceGDI() noexcept {
478  	Clear();
479  }
480  void SurfaceGDI::Clear() noexcept {
481  	if (penOld) {
482  		::SelectObject(hdc, penOld);
483  		::DeleteObject(pen);
484  		penOld = {};
485  	}
486  	pen = {};
487  	if (brushOld) {
488  		::SelectObject(hdc, brushOld);
489  		::DeleteObject(brush);
490  		brushOld = {};
491  	}
492  	brush = {};
493  	if (fontOld) {
494  		::SelectObject(hdc, fontOld);
495  		fontOld = {};
496  	}
497  	if (bitmapOld) {
498  		::SelectObject(hdc, bitmapOld);
499  		::DeleteObject(bitmap);
500  		bitmapOld = {};
501  	}
502  	bitmap = {};
503  	if (hdcOwned) {
504  		::DeleteDC(hdc);
505  		hdc = {};
506  		hdcOwned = false;
507  	}
508  }
509  void SurfaceGDI::Release() noexcept {
510  	Clear();
511  }
512  int SurfaceGDI::SupportsFeature(Supports feature) noexcept {
513  	for (const Supports f : SupportsGDI) {
514  		if (f == feature)
515  			return 1;
516  	}
517  	return 0;
518  }
519  bool SurfaceGDI::Initialised() {
520  	return hdc != 0;
521  }
522  void SurfaceGDI::Init(WindowID wid) {
523  	Release();
524  	hdc = ::CreateCompatibleDC({});
525  	hdcOwned = true;
526  	::SetTextAlign(hdc, TA_BASELINE);
527  	logPixelsY = DpiForWindow(wid);
528  }
529  void SurfaceGDI::Init(SurfaceID sid, WindowID wid) {
530  	Release();
531  	hdc = static_cast<HDC>(sid);
532  	::SetTextAlign(hdc, TA_BASELINE);
533  	const bool printing = ::GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY;
534  	logPixelsY = printing ? ::GetDeviceCaps(hdc, LOGPIXELSY) : DpiForWindow(wid);
535  }
536  std::unique_ptr<Surface> SurfaceGDI::AllocatePixMap(int width, int height) {
537  	return std::make_unique<SurfaceGDI>(hdc, width, height, mode, logPixelsY);
538  }
539  void SurfaceGDI::SetMode(SurfaceMode mode_) {
540  	mode = mode_;
541  }
542  void SurfaceGDI::PenColour(ColourRGBA fore, XYPOSITION widthStroke) noexcept {
543  	if (pen) {
544  		::SelectObject(hdc, penOld);
545  		::DeleteObject(pen);
546  		pen = {};
547  		penOld = {};
548  	}
549  	const DWORD penWidth = std::lround(widthStroke);
550  	const COLORREF penColour = fore.OpaqueRGB();
551  	if (widthStroke > 1) {
552  		const LOGBRUSH brushParameters{ BS_SOLID, penColour, 0 };
553  		pen = ::ExtCreatePen(PS_GEOMETRIC | PS_ENDCAP_ROUND | PS_JOIN_MITER,
554  			penWidth,
555  			&brushParameters,
556  			0,
557  			nullptr);
558  	} else {
559  		pen = ::CreatePen(PS_INSIDEFRAME, penWidth, penColour);
560  	}
561  	penOld = SelectPen(hdc, pen);
562  }
563  void SurfaceGDI::BrushColour(ColourRGBA back) noexcept {
564  	if (brush) {
565  		::SelectObject(hdc, brushOld);
566  		::DeleteObject(brush);
567  		brush = {};
568  		brushOld = {};
569  	}
570  	brush = ::CreateSolidBrush(back.OpaqueRGB());
571  	brushOld = SelectBrush(hdc, brush);
572  }
573  void SurfaceGDI::SetFont(const Font *font_) {
574  	const FontGDI *pfm = dynamic_cast<const FontGDI *>(font_);
575  	PLATFORM_ASSERT(pfm);
576  	if (!pfm) {
577  		throw std::runtime_error("SurfaceGDI::SetFont: wrong Font type.");
578  	}
579  	if (fontOld) {
580  		SelectFont(hdc, pfm->hfont);
581  	} else {
582  		fontOld = SelectFont(hdc, pfm->hfont);
583  	}
584  }
585  int SurfaceGDI::LogPixelsY() {
586  	return logPixelsY;
587  }
588  int SurfaceGDI::PixelDivisions() {
589  	return 1;
590  }
591  int SurfaceGDI::DeviceHeightFont(int points) {
592  	return ::MulDiv(points, LogPixelsY(), 72);
593  }
594  void SurfaceGDI::LineDraw(Point start, Point end, Stroke stroke) {
595  	PenColour(stroke.colour, stroke.width);
596  	::MoveToEx(hdc, std::lround(std::floor(start.x)), std::lround(std::floor(start.y)), nullptr);
597  	::LineTo(hdc, std::lround(std::floor(end.x)), std::lround(std::floor(end.y)));
598  }
599  void SurfaceGDI::PolyLine(const Point *pts, size_t npts, Stroke stroke) {
600  	PLATFORM_ASSERT(npts > 1);
601  	if (npts <= 1) {
602  		return;
603  	}
604  	PenColour(stroke.colour, stroke.width);
605  	std::vector<POINT> outline;
606  	std::transform(pts, pts + npts, std::back_inserter(outline), POINTFromPoint);
607  	::Polyline(hdc, outline.data(), static_cast<int>(npts));
608  }
609  void SurfaceGDI::Polygon(const Point *pts, size_t npts, FillStroke fillStroke) {
610  	PenColour(fillStroke.stroke.colour.WithoutAlpha(), fillStroke.stroke.width);
611  	BrushColour(fillStroke.fill.colour.WithoutAlpha());
612  	std::vector<POINT> outline;
613  	std::transform(pts, pts + npts, std::back_inserter(outline), POINTFromPoint);
614  	::Polygon(hdc, outline.data(), static_cast<int>(npts));
615  }
616  void SurfaceGDI::RectangleDraw(PRectangle rc, FillStroke fillStroke) {
617  	RectangleFrame(rc, fillStroke.stroke);
618  	FillRectangle(rc.Inset(fillStroke.stroke.width), fillStroke.fill.colour);
619  }
620  void SurfaceGDI::RectangleFrame(PRectangle rc, Stroke stroke) {
<span onclick='openModal()' class='match'>621  	BrushColour(stroke.colour);
622  	const RECT rcw = RectFromPRectangle(rc);
623  	::FrameRect(hdc, &rcw, brush);
</span>624  }
625  void SurfaceGDI::FillRectangle(PRectangle rc, Fill fill) {
626  	if (fill.colour.IsOpaque()) {
627  		const RECT rcw = RectFromPRectangle(rc);
628  		::SetBkColor(hdc, fill.colour.OpaqueRGB());
629  		::ExtTextOut(hdc, rcw.left, rcw.top, ETO_OPAQUE, &rcw, TEXT(""), 0, nullptr);
630  	} else {
631  		AlphaRectangle(rc, 0, FillStroke(fill.colour));
632  	}
633  }
634  void SurfaceGDI::FillRectangleAligned(PRectangle rc, Fill fill) {
635  	FillRectangle(PixelAlign(rc, 1), fill);
636  }
637  void SurfaceGDI::FillRectangle(PRectangle rc, Surface &surfacePattern) {
638  	HBRUSH br;
639  	if (SurfaceGDI *psgdi = dynamic_cast<SurfaceGDI *>(&surfacePattern); psgdi && psgdi->bitmap) {
640  		br = ::CreatePatternBrush(psgdi->bitmap);
641  	} else {	
642  		br = ::CreateSolidBrush(RGB(0xff, 0, 0));
643  	}
644  	const RECT rcw = RectFromPRectangle(rc);
645  	::FillRect(hdc, &rcw, br);
646  	::DeleteObject(br);
647  }
648  void SurfaceGDI::RoundedRectangle(PRectangle rc, FillStroke fillStroke) {
649  	PenColour(fillStroke.stroke.colour, fillStroke.stroke.width);
650  	BrushColour(fillStroke.fill.colour);
651  	const RECT rcw = RectFromPRectangle(rc);
652  	::RoundRect(hdc,
653  		rcw.left + 1, rcw.top,
654  		rcw.right - 1, rcw.bottom,
655  		8, 8);
656  }
657  namespace {
658  constexpr DWORD dwordFromBGRA(byte b, byte g, byte r, byte a) noexcept {
659  	return (a << 24) | (r << 16) | (g << 8) | b;
660  }
661  constexpr byte AlphaScaled(unsigned char component, unsigned int alpha) noexcept {
662  	return static_cast<byte>(component * alpha / 255);
663  }
664  constexpr DWORD dwordMultiplied(ColourRGBA colour) noexcept {
665  	return dwordFromBGRA(
666  		AlphaScaled(colour.GetBlue(), colour.GetAlpha()),
667  		AlphaScaled(colour.GetGreen(), colour.GetAlpha()),
668  		AlphaScaled(colour.GetRed(), colour.GetAlpha()),
669  		colour.GetAlpha());
670  }
671  class DIBSection {
672  	HDC hMemDC {};
673  	HBITMAP hbmMem {};
674  	HBITMAP hbmOld {};
675  	SIZE size {};
676  	DWORD *pixels = nullptr;
677  public:
678  	DIBSection(HDC hdc, SIZE size_) noexcept;
679  	DIBSection(const DIBSection&) = delete;
680  	DIBSection(DIBSection&&) = delete;
681  	DIBSection &operator=(const DIBSection&) = delete;
682  	DIBSection &operator=(DIBSection&&) = delete;
683  	~DIBSection() noexcept;
684  	operator bool() const noexcept {
685  		return hMemDC && hbmMem && pixels;
686  	}
687  	DWORD *Pixels() const noexcept {
688  		return pixels;
689  	}
690  	unsigned char *Bytes() const noexcept {
691  		return reinterpret_cast<unsigned char *>(pixels);
692  	}
693  	HDC DC() const noexcept {
694  		return hMemDC;
695  	}
696  	void SetPixel(LONG x, LONG y, DWORD value) noexcept {
697  		PLATFORM_ASSERT(x >= 0);
698  		PLATFORM_ASSERT(y >= 0);
699  		PLATFORM_ASSERT(x < size.cx);
700  		PLATFORM_ASSERT(y < size.cy);
701  		pixels[y * size.cx + x] = value;
702  	}
703  	void SetSymmetric(LONG x, LONG y, DWORD value) noexcept;
704  };
705  DIBSection::DIBSection(HDC hdc, SIZE size_) noexcept {
706  	hMemDC = ::CreateCompatibleDC(hdc);
707  	if (!hMemDC) {
708  		return;
709  	}
710  	size = size_;
711  	const BITMAPINFO bpih = { {sizeof(BITMAPINFOHEADER), size.cx, -size.cy, 1, 32, BI_RGB, 0, 0, 0, 0, 0},
712  		{{0, 0, 0, 0}} };
713  	void *image = nullptr;
714  	hbmMem = CreateDIBSection(hMemDC, &bpih, DIB_RGB_COLORS, &image, {}, 0);
715  	if (!hbmMem || !image) {
716  		return;
717  	}
718  	pixels = static_cast<DWORD *>(image);
719  	hbmOld = SelectBitmap(hMemDC, hbmMem);
720  }
721  DIBSection::~DIBSection() noexcept {
722  	if (hbmOld) {
723  		SelectBitmap(hMemDC, hbmOld);
724  		hbmOld = {};
725  	}
726  	if (hbmMem) {
727  		::DeleteObject(hbmMem);
728  		hbmMem = {};
729  	}
730  	if (hMemDC) {
731  		::DeleteDC(hMemDC);
732  		hMemDC = {};
733  	}
734  }
735  void DIBSection::SetSymmetric(LONG x, LONG y, DWORD value) noexcept {
736  	const LONG xSymmetric = size.cx - 1 - x;
737  	const LONG ySymmetric = size.cy - 1 - y;
738  	SetPixel(x, y, value);
739  	SetPixel(xSymmetric, y, value);
740  	SetPixel(x, ySymmetric, value);
741  	SetPixel(xSymmetric, ySymmetric, value);
742  }
743  ColourRGBA GradientValue(const std::vector<ColourStop> &stops, XYPOSITION proportion) noexcept {
744  	for (size_t stop = 0; stop < stops.size() - 1; stop++) {
745  		const XYPOSITION positionStart = stops[stop].position;
746  		const XYPOSITION positionEnd = stops[stop + 1].position;
747  		if ((proportion >= positionStart) && (proportion <= positionEnd)) {
748  			const XYPOSITION proportionInPair = (proportion - positionStart) /
749  				(positionEnd - positionStart);
750  			return stops[stop].colour.MixedWith(stops[stop + 1].colour, proportionInPair);
751  		}
752  	}
753  	return ColourRGBA();
754  }
755  constexpr SIZE SizeOfRect(RECT rc) noexcept {
756  	return { rc.right - rc.left, rc.bottom - rc.top };
757  }
758  constexpr BLENDFUNCTION mergeAlpha = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
759  }
760  void SurfaceGDI::AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) {
761  	const RECT rcw = RectFromPRectangle(rc);
762  	const SIZE size = SizeOfRect(rcw);
763  	if (size.cx > 0) {
764  		DIBSection section(hdc, size);
765  		if (section) {
766  			const LONG corner = std::min(static_cast<LONG>(cornerSize), (std::min(size.cx, size.cy) / 2) - 2);
767  			constexpr DWORD valEmpty = dwordFromBGRA(0,0,0,0);
768  			const DWORD valFill = dwordMultiplied(fillStroke.fill.colour);
769  			const DWORD valOutline = dwordMultiplied(fillStroke.stroke.colour);
770  			for (int y=0; y<size.cy; y++) {
771  				for (int x=0; x<size.cx; x++) {
772  					if ((x==0) || (x==size.cx-1) || (y == 0) || (y == size.cy -1)) {
773  						section.SetPixel(x, y, valOutline);
774  					} else {
775  						section.SetPixel(x, y, valFill);
776  					}
777  				}
778  			}
779  			for (LONG c=0; c<corner; c++) {
780  				for (LONG x=0; x<c+1; x++) {
781  					section.SetSymmetric(x, c - x, valEmpty);
782  				}
783  			}
784  			for (LONG x=1; x<corner; x++) {
785  				section.SetSymmetric(x, corner - x, valOutline);
786  			}
787  			GdiAlphaBlend(hdc, rcw.left, rcw.top, size.cx, size.cy, section.DC(), 0, 0, size.cx, size.cy, mergeAlpha);
788  		}
789  	} else {
790  		BrushColour(fillStroke.stroke.colour);
791  		FrameRect(hdc, &rcw, brush);
792  	}
793  }
794  void SurfaceGDI::GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) {
795  	const RECT rcw = RectFromPRectangle(rc);
796  	const SIZE size = SizeOfRect(rcw);
797  	DIBSection section(hdc, size);
798  	if (section) {
799  		if (options == GradientOptions::topToBottom) {
800  			for (LONG y = 0; y < size.cy; y++) {
801  				const XYPOSITION proportion = y / (rc.Height() - 1.0f);
802  				const ColourRGBA mixed = GradientValue(stops, proportion);
803  				const DWORD valFill = dwordMultiplied(mixed);
804  				for (LONG x = 0; x < size.cx; x++) {
805  					section.SetPixel(x, y, valFill);
806  				}
807  			}
808  		} else {
809  			for (LONG x = 0; x < size.cx; x++) {
810  				const XYPOSITION proportion = x / (rc.Width() - 1.0f);
811  				const ColourRGBA mixed = GradientValue(stops, proportion);
812  				const DWORD valFill = dwordMultiplied(mixed);
813  				for (LONG y = 0; y < size.cy; y++) {
814  					section.SetPixel(x, y, valFill);
815  				}
816  			}
817  		}
818  		GdiAlphaBlend(hdc, rcw.left, rcw.top, size.cx, size.cy, section.DC(), 0, 0, size.cx, size.cy, mergeAlpha);
819  	}
820  }
821  void SurfaceGDI::DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) {
822  	if (rc.Width() > 0) {
823  		if (rc.Width() > width)
824  			rc.left += std::floor((rc.Width() - width) / 2);
825  		rc.right = rc.left + width;
826  		if (rc.Height() > height)
827  			rc.top += std::floor((rc.Height() - height) / 2);
828  		rc.bottom = rc.top + height;
829  		const SIZE size { width, height };
830  		DIBSection section(hdc, size);
831  		if (section) {
832  			RGBAImage::BGRAFromRGBA(section.Bytes(), pixelsImage, static_cast<size_t>(width) * height);
833  			GdiAlphaBlend(hdc, static_cast<int>(rc.left), static_cast<int>(rc.top),
834  				static_cast<int>(rc.Width()), static_cast<int>(rc.Height()), section.DC(),
835  				0, 0, width, height, mergeAlpha);
836  		}
837  	}
838  }
839  void SurfaceGDI::Ellipse(PRectangle rc, FillStroke fillStroke) {
840  	PenColour(fillStroke.stroke.colour, fillStroke.stroke.width);
841  	BrushColour(fillStroke.fill.colour);
842  	const RECT rcw = RectFromPRectangle(rc);
843  	::Ellipse(hdc, rcw.left, rcw.top, rcw.right, rcw.bottom);
844  }
845  void SurfaceGDI::Stadium(PRectangle rc, FillStroke fillStroke, [[maybe_unused]] Ends ends) {
846  	RectangleDraw(rc, fillStroke);
847  }
848  void SurfaceGDI::Copy(PRectangle rc, Point from, Surface &surfaceSource) {
849  	::BitBlt(hdc,
850  		static_cast<int>(rc.left), static_cast<int>(rc.top),
851  		static_cast<int>(rc.Width()), static_cast<int>(rc.Height()),
852  		dynamic_cast<SurfaceGDI &>(surfaceSource).hdc,
853  		static_cast<int>(from.x), static_cast<int>(from.y), SRCCOPY);
854  }
855  std::unique_ptr<IScreenLineLayout> SurfaceGDI::Layout(const IScreenLine *) {
856  	return {};
857  }
858  typedef VarBuffer<int, stackBufferLength> TextPositionsI;
859  void SurfaceGDI::DrawTextCommon(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, UINT fuOptions) {
860  	SetFont(font_);
861  	const RECT rcw = RectFromPRectangle(rc);
862  	const int x = static_cast<int>(rc.left);
863  	const int yBaseInt = static_cast<int>(ybase);
864  	if (mode.codePage == CpUtf8) {
865  		const TextWide tbuf(text, mode.codePage);
866  		::ExtTextOutW(hdc, x, yBaseInt, fuOptions, &rcw, tbuf.buffer, tbuf.tlen, nullptr);
867  	} else {
868  		::ExtTextOutA(hdc, x, yBaseInt, fuOptions, &rcw, text.data(), static_cast<UINT>(text.length()), nullptr);
869  	}
870  }
871  void SurfaceGDI::DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
872  	ColourRGBA fore, ColourRGBA back) {
873  	::SetTextColor(hdc, fore.OpaqueRGB());
874  	::SetBkColor(hdc, back.OpaqueRGB());
875  	DrawTextCommon(rc, font_, ybase, text, ETO_OPAQUE);
876  }
877  void SurfaceGDI::DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
878  	ColourRGBA fore, ColourRGBA back) {
879  	::SetTextColor(hdc, fore.OpaqueRGB());
880  	::SetBkColor(hdc, back.OpaqueRGB());
881  	DrawTextCommon(rc, font_, ybase, text, ETO_OPAQUE | ETO_CLIPPED);
882  }
883  void SurfaceGDI::DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
884  	ColourRGBA fore) {
885  	for (const char ch : text) {
886  		if (ch != ' ') {
887  			::SetTextColor(hdc, fore.OpaqueRGB());
888  			::SetBkMode(hdc, TRANSPARENT);
889  			DrawTextCommon(rc, font_, ybase, text, 0);
890  			::SetBkMode(hdc, OPAQUE);
891  			return;
892  		}
893  	}
894  }
895  void SurfaceGDI::MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) {
896  	std::fill(positions, positions + text.length(), 0.0f);
897  	SetFont(font_);
898  	SIZE sz = { 0,0 };
899  	int fit = 0;
900  	int i = 0;
901  	const int len = static_cast<int>(text.length());
902  	if (mode.codePage == CpUtf8) {
903  		const TextWide tbuf(text, mode.codePage);
904  		TextPositionsI poses(tbuf.tlen);
905  		if (!::GetTextExtentExPointW(hdc, tbuf.buffer, tbuf.tlen, maxWidthMeasure, &fit, poses.buffer, &sz)) {
906  			return;
907  		}
908  		for (int ui = 0; ui < fit; ui++) {
909  			const unsigned char uch = text[i];
910  			const unsigned int byteCount = UTF8BytesOfLead[uch];
911  			if (byteCount == 4) {	
912  				ui++;
913  			}
914  			for (unsigned int bytePos = 0; (bytePos < byteCount) && (i < len); bytePos++) {
915  				positions[i++] = static_cast<XYPOSITION>(poses.buffer[ui]);
916  			}
917  		}
918  	} else {
919  		TextPositionsI poses(len);
920  		if (!::GetTextExtentExPointA(hdc, text.data(), len, maxWidthMeasure, &fit, poses.buffer, &sz)) {
921  			return;
922  		}
923  		while (i < fit) {
924  			positions[i] = static_cast<XYPOSITION>(poses.buffer[i]);
925  			i++;
926  		}
927  	}
928  	const XYPOSITION lastPos = (fit > 0) ? positions[fit - 1] : 0.0f;
929  	std::fill(positions + i, positions + text.length(), lastPos);
930  }
931  XYPOSITION SurfaceGDI::WidthText(const Font *font_, std::string_view text) {
932  	SetFont(font_);
933  	SIZE sz = { 0,0 };
934  	if (!(mode.codePage == CpUtf8)) {
935  		::GetTextExtentPoint32A(hdc, text.data(), std::min(static_cast<int>(text.length()), maxLenText), &sz);
936  	} else {
937  		const TextWide tbuf(text, mode.codePage);
938  		::GetTextExtentPoint32W(hdc, tbuf.buffer, tbuf.tlen, &sz);
939  	}
940  	return static_cast<XYPOSITION>(sz.cx);
941  }
942  void SurfaceGDI::DrawTextCommonUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, UINT fuOptions) {
943  	SetFont(font_);
944  	const RECT rcw = RectFromPRectangle(rc);
945  	const int x = static_cast<int>(rc.left);
946  	const int yBaseInt = static_cast<int>(ybase);
947  	const TextWide tbuf(text, CpUtf8);
948  	::ExtTextOutW(hdc, x, yBaseInt, fuOptions, &rcw, tbuf.buffer, tbuf.tlen, nullptr);
949  }
950  void SurfaceGDI::DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
951  	ColourRGBA fore, ColourRGBA back) {
952  	::SetTextColor(hdc, fore.OpaqueRGB());
953  	::SetBkColor(hdc, back.OpaqueRGB());
954  	DrawTextCommonUTF8(rc, font_, ybase, text, ETO_OPAQUE);
955  }
956  void SurfaceGDI::DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
957  	ColourRGBA fore, ColourRGBA back) {
958  	::SetTextColor(hdc, fore.OpaqueRGB());
959  	::SetBkColor(hdc, back.OpaqueRGB());
960  	DrawTextCommonUTF8(rc, font_, ybase, text, ETO_OPAQUE | ETO_CLIPPED);
961  }
962  void SurfaceGDI::DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
963  	ColourRGBA fore) {
964  	for (const char ch : text) {
965  		if (ch != ' ') {
966  			::SetTextColor(hdc, fore.OpaqueRGB());
967  			::SetBkMode(hdc, TRANSPARENT);
968  			DrawTextCommonUTF8(rc, font_, ybase, text, 0);
969  			::SetBkMode(hdc, OPAQUE);
970  			return;
971  		}
972  	}
973  }
974  void SurfaceGDI::MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) {
975  	std::fill(positions, positions + text.length(), 0.0f);
976  	SetFont(font_);
977  	SIZE sz = { 0,0 };
978  	int fit = 0;
979  	int i = 0;
980  	const int len = static_cast<int>(text.length());
981  	const TextWide tbuf(text, CpUtf8);
982  	TextPositionsI poses(tbuf.tlen);
983  	if (!::GetTextExtentExPointW(hdc, tbuf.buffer, tbuf.tlen, maxWidthMeasure, &fit, poses.buffer, &sz)) {
984  		return;
985  	}
986  	for (int ui = 0; ui < fit; ui++) {
987  		const unsigned char uch = text[i];
988  		const unsigned int byteCount = UTF8BytesOfLead[uch];
989  		if (byteCount == 4) {	
990  			ui++;
991  		}
992  		for (unsigned int bytePos = 0; (bytePos < byteCount) && (i < len); bytePos++) {
993  			positions[i++] = static_cast<XYPOSITION>(poses.buffer[ui]);
994  		}
995  	}
996  	const XYPOSITION lastPos = (fit > 0) ? positions[fit - 1] : 0.0f;
997  	std::fill(positions + i, positions + text.length(), lastPos);
998  }
999  XYPOSITION SurfaceGDI::WidthTextUTF8(const Font *font_, std::string_view text) {
1000  	SetFont(font_);
1001  	SIZE sz = { 0,0 };
1002  	const TextWide tbuf(text, CpUtf8);
1003  	::GetTextExtentPoint32W(hdc, tbuf.buffer, tbuf.tlen, &sz);
1004  	return static_cast<XYPOSITION>(sz.cx);
1005  }
1006  XYPOSITION SurfaceGDI::Ascent(const Font *font_) {
1007  	SetFont(font_);
1008  	TEXTMETRIC tm;
1009  	::GetTextMetrics(hdc, &tm);
1010  	return static_cast<XYPOSITION>(tm.tmAscent);
1011  }
1012  XYPOSITION SurfaceGDI::Descent(const Font *font_) {
1013  	SetFont(font_);
1014  	TEXTMETRIC tm;
1015  	::GetTextMetrics(hdc, &tm);
1016  	return static_cast<XYPOSITION>(tm.tmDescent);
1017  }
1018  XYPOSITION SurfaceGDI::InternalLeading(const Font *font_) {
1019  	SetFont(font_);
1020  	TEXTMETRIC tm;
1021  	::GetTextMetrics(hdc, &tm);
1022  	return static_cast<XYPOSITION>(tm.tmInternalLeading);
1023  }
1024  XYPOSITION SurfaceGDI::Height(const Font *font_) {
1025  	SetFont(font_);
1026  	TEXTMETRIC tm;
1027  	::GetTextMetrics(hdc, &tm);
1028  	return static_cast<XYPOSITION>(tm.tmHeight);
1029  }
1030  XYPOSITION SurfaceGDI::AverageCharWidth(const Font *font_) {
1031  	SetFont(font_);
1032  	TEXTMETRIC tm;
1033  	::GetTextMetrics(hdc, &tm);
1034  	return static_cast<XYPOSITION>(tm.tmAveCharWidth);
1035  }
1036  void SurfaceGDI::SetClip(PRectangle rc) {
1037  	::SaveDC(hdc);
1038  	::IntersectClipRect(hdc, static_cast<int>(rc.left), static_cast<int>(rc.top),
1039  		static_cast<int>(rc.right), static_cast<int>(rc.bottom));
1040  }
1041  void SurfaceGDI::PopClip() {
1042  	::RestoreDC(hdc, -1);
1043  }
1044  void SurfaceGDI::FlushCachedState() {
1045  	pen = {};
1046  	brush = {};
1047  }
1048  void SurfaceGDI::FlushDrawing() {
1049  }
1050  #if defined(USE_D2D)
1051  namespace {
1052  constexpr D2D1_RECT_F RectangleFromPRectangle(PRectangle rc) noexcept {
1053  	return {
1054  		static_cast<FLOAT>(rc.left),
1055  		static_cast<FLOAT>(rc.top),
1056  		static_cast<FLOAT>(rc.right),
1057  		static_cast<FLOAT>(rc.bottom)
1058  	};
1059  }
1060  constexpr D2D1_POINT_2F DPointFromPoint(Point point) noexcept {
1061  	return { static_cast<FLOAT>(point.x), static_cast<FLOAT>(point.y) };
1062  }
1063  constexpr Supports SupportsD2D[] = {
1064  	Supports::LineDrawsFinal,
1065  	Supports::FractionalStrokeWidth,
1066  	Supports::TranslucentStroke,
1067  	Supports::PixelModification,
1068  	Supports::ThreadSafeMeasureWidths,
1069  };
1070  constexpr D2D_COLOR_F ColorFromColourAlpha(ColourRGBA colour) noexcept {
1071  	return D2D_COLOR_F{
1072  		colour.GetRedComponent(),
1073  		colour.GetGreenComponent(),
1074  		colour.GetBlueComponent(),
1075  		colour.GetAlphaComponent()
1076  	};
1077  }
1078  constexpr D2D1_RECT_F RectangleInset(D2D1_RECT_F rect, FLOAT inset) noexcept {
1079  	return D2D1_RECT_F{
1080  		rect.left + inset,
1081  		rect.top + inset,
1082  		rect.right - inset,
1083  		rect.bottom - inset };
1084  }
1085  }
1086  class BlobInline;
1087  class SurfaceD2D : public Surface, public ISetRenderingParams {
1088  	SurfaceMode mode;
1089  	ID2D1RenderTarget *pRenderTarget = nullptr;
1090  	ID2D1BitmapRenderTarget *pBitmapRenderTarget = nullptr;
1091  	bool ownRenderTarget = false;
1092  	int clipsActive = 0;
1093  	ID2D1SolidColorBrush *pBrush = nullptr;
1094  	static constexpr FontQuality invalidFontQuality = FontQuality::QualityMask;
1095  	FontQuality fontQuality = invalidFontQuality;
1096  	int logPixelsY = USER_DEFAULT_SCREEN_DPI;
1097  	int deviceScaleFactor = 1;
1098  	std::shared_ptr<RenderingParams> renderingParams;
1099  	void Clear() noexcept;
1100  	void SetFontQuality(FontQuality extraFontFlag);
1101  	HRESULT GetBitmap(ID2D1Bitmap **ppBitmap);
1102  	void SetDeviceScaleFactor(const ID2D1RenderTarget *const pRenderTarget) noexcept;
1103  public:
1104  	SurfaceD2D() noexcept;
1105  	SurfaceD2D(ID2D1RenderTarget *pRenderTargetCompatible, int width, int height, SurfaceMode mode_, int logPixelsY_) noexcept;
1106  	SurfaceD2D(const SurfaceD2D &) = delete;
1107  	SurfaceD2D(SurfaceD2D &&) = delete;
1108  	SurfaceD2D &operator=(const SurfaceD2D &) = delete;
1109  	SurfaceD2D &operator=(SurfaceD2D &&) = delete;
1110  	~SurfaceD2D() noexcept override;
1111  	void SetScale(WindowID wid) noexcept;
1112  	void Init(WindowID wid) override;
1113  	void Init(SurfaceID sid, WindowID wid) override;
1114  	std::unique_ptr<Surface> AllocatePixMap(int width, int height) override;
1115  	void SetMode(SurfaceMode mode_) override;
1116  	void Release() noexcept override;
1117  	int SupportsFeature(Supports feature) noexcept override;
1118  	bool Initialised() override;
1119  	void D2DPenColourAlpha(ColourRGBA fore) noexcept;
1120  	int LogPixelsY() override;
1121  	int PixelDivisions() override;
1122  	int DeviceHeightFont(int points) override;
1123  	void LineDraw(Point start, Point end, Stroke stroke) override;
1124  	ID2D1PathGeometry *Geometry(const Point *pts, size_t npts, D2D1_FIGURE_BEGIN figureBegin) noexcept;
1125  	void PolyLine(const Point *pts, size_t npts, Stroke stroke) override;
1126  	void Polygon(const Point *pts, size_t npts, FillStroke fillStroke) override;
1127  	void RectangleDraw(PRectangle rc, FillStroke fillStroke) override;
1128  	void RectangleFrame(PRectangle rc, Stroke stroke) override;
1129  	void FillRectangle(PRectangle rc, Fill fill) override;
1130  	void FillRectangleAligned(PRectangle rc, Fill fill) override;
1131  	void FillRectangle(PRectangle rc, Surface &surfacePattern) override;
1132  	void RoundedRectangle(PRectangle rc, FillStroke fillStroke) override;
1133  	void AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) override;
1134  	void GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) override;
1135  	void DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) override;
1136  	void Ellipse(PRectangle rc, FillStroke fillStroke) override;
1137  	void Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) override;
1138  	void Copy(PRectangle rc, Point from, Surface &surfaceSource) override;
1139  	std::unique_ptr<IScreenLineLayout> Layout(const IScreenLine *screenLine) override;
1140  	void DrawTextCommon(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, int codePageOverride, UINT fuOptions);
1141  	void DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
1142  	void DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
1143  	void DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) override;
1144  	void MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) override;
1145  	XYPOSITION WidthText(const Font *font_, std::string_view text) override;
1146  	void DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
1147  	void DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) override;
1148  	void DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) override;
1149  	void MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) override;
1150  	XYPOSITION WidthTextUTF8(const Font *font_, std::string_view text) override;
1151  	XYPOSITION Ascent(const Font *font_) override;
1152  	XYPOSITION Descent(const Font *font_) override;
1153  	XYPOSITION InternalLeading(const Font *font_) override;
1154  	XYPOSITION Height(const Font *font_) override;
1155  	XYPOSITION AverageCharWidth(const Font *font_) override;
1156  	void SetClip(PRectangle rc) override;
1157  	void PopClip() override;
1158  	void FlushCachedState() override;
1159  	void FlushDrawing() override;
1160  	void SetRenderingParams(std::shared_ptr<RenderingParams> renderingParams_) override;
1161  };
1162  SurfaceD2D::SurfaceD2D() noexcept {
1163  }
1164  SurfaceD2D::SurfaceD2D(ID2D1RenderTarget *pRenderTargetCompatible, int width, int height, SurfaceMode mode_, int logPixelsY_) noexcept {
1165  	const D2D1_SIZE_F desiredSize = D2D1::SizeF(static_cast<float>(width), static_cast<float>(height));
1166  	D2D1_PIXEL_FORMAT desiredFormat;
1167  #ifdef __MINGW32__
1168  	desiredFormat.format = DXGI_FORMAT_UNKNOWN;
1169  #else
1170  	desiredFormat = pRenderTargetCompatible->GetPixelFormat();
1171  #endif
1172  	desiredFormat.alphaMode = D2D1_ALPHA_MODE_IGNORE;
1173  	const HRESULT hr = pRenderTargetCompatible->CreateCompatibleRenderTarget(
1174  		&desiredSize, nullptr, &desiredFormat, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE, &pBitmapRenderTarget);
1175  	if (SUCCEEDED(hr)) {
1176  		pRenderTarget = pBitmapRenderTarget;
1177  		SetDeviceScaleFactor(pRenderTarget);
1178  		pRenderTarget->BeginDraw();
1179  		ownRenderTarget = true;
1180  	}
1181  	mode = mode_;
1182  	logPixelsY = logPixelsY_;
1183  }
1184  SurfaceD2D::~SurfaceD2D() noexcept {
1185  	Clear();
1186  }
1187  void SurfaceD2D::Clear() noexcept {
1188  	ReleaseUnknown(pBrush);
1189  	if (pRenderTarget) {
1190  		while (clipsActive) {
1191  			pRenderTarget->PopAxisAlignedClip();
1192  			clipsActive--;
1193  		}
1194  		if (ownRenderTarget) {
1195  			pRenderTarget->EndDraw();
1196  			ReleaseUnknown(pRenderTarget);
1197  			ownRenderTarget = false;
1198  		}
1199  		pRenderTarget = nullptr;
1200  	}
1201  	pBitmapRenderTarget = nullptr;
1202  }
1203  void SurfaceD2D::Release() noexcept {
1204  	Clear();
1205  }
1206  void SurfaceD2D::SetScale(WindowID wid) noexcept {
1207  	fontQuality = invalidFontQuality;
1208  	logPixelsY = DpiForWindow(wid);
1209  }
1210  int SurfaceD2D::SupportsFeature(Supports feature) noexcept {
1211  	for (const Supports f : SupportsD2D) {
1212  		if (f == feature)
1213  			return 1;
1214  	}
1215  	return 0;
1216  }
1217  bool SurfaceD2D::Initialised() {
1218  	return pRenderTarget != nullptr;
1219  }
1220  void SurfaceD2D::Init(WindowID wid) {
1221  	Release();
1222  	SetScale(wid);
1223  }
1224  void SurfaceD2D::Init(SurfaceID sid, WindowID wid) {
1225  	Release();
1226  	SetScale(wid);
1227  	pRenderTarget = static_cast<ID2D1RenderTarget *>(sid);
1228  	SetDeviceScaleFactor(pRenderTarget);
1229  }
1230  std::unique_ptr<Surface> SurfaceD2D::AllocatePixMap(int width, int height) {
1231  	std::unique_ptr<SurfaceD2D> surf = std::make_unique<SurfaceD2D>(pRenderTarget, width, height, mode, logPixelsY);
1232  	surf->SetRenderingParams(renderingParams);
1233  	return surf;
1234  }
1235  void SurfaceD2D::SetMode(SurfaceMode mode_) {
1236  	mode = mode_;
1237  }
1238  HRESULT SurfaceD2D::GetBitmap(ID2D1Bitmap **ppBitmap) {
1239  	PLATFORM_ASSERT(pBitmapRenderTarget);
1240  	return pBitmapRenderTarget->GetBitmap(ppBitmap);
1241  }
1242  void SurfaceD2D::D2DPenColourAlpha(ColourRGBA fore) noexcept {
1243  	if (pRenderTarget) {
1244  		const D2D_COLOR_F col = ColorFromColourAlpha(fore);
1245  		if (pBrush) {
1246  			pBrush->SetColor(col);
1247  		} else {
1248  			const HRESULT hr = pRenderTarget->CreateSolidColorBrush(col, &pBrush);
1249  			if (!SUCCEEDED(hr)) {
1250  				ReleaseUnknown(pBrush);
1251  			}
1252  		}
1253  	}
1254  }
1255  void SurfaceD2D::SetFontQuality(FontQuality extraFontFlag) {
1256  	if ((fontQuality != extraFontFlag) && renderingParams) {
1257  		fontQuality = extraFontFlag;
1258  		const D2D1_TEXT_ANTIALIAS_MODE aaMode = DWriteMapFontQuality(extraFontFlag);
1259  		if (aaMode == D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE && renderingParams->customRenderingParams) {
1260  			pRenderTarget->SetTextRenderingParams(renderingParams->customRenderingParams.get());
1261  		} else if (renderingParams->defaultRenderingParams) {
1262  			pRenderTarget->SetTextRenderingParams(renderingParams->defaultRenderingParams.get());
1263  		}
1264  		pRenderTarget->SetTextAntialiasMode(aaMode);
1265  	}
1266  }
1267  int SurfaceD2D::LogPixelsY() {
1268  	return logPixelsY;
1269  }
1270  void SurfaceD2D::SetDeviceScaleFactor(const ID2D1RenderTarget *const pD2D1RenderTarget) noexcept {
1271  	FLOAT dpiX = 0.f;
1272  	FLOAT dpiY = 0.f;
1273  	pD2D1RenderTarget->GetDpi(&dpiX, &dpiY);
1274  	deviceScaleFactor = static_cast<int>(dpiX / 96.f);
1275  }
1276  int SurfaceD2D::PixelDivisions() {
1277  	return deviceScaleFactor;
1278  }
1279  int SurfaceD2D::DeviceHeightFont(int points) {
1280  	return ::MulDiv(points, LogPixelsY(), 72);
1281  }
1282  void SurfaceD2D::LineDraw(Point start, Point end, Stroke stroke) {
1283  	D2DPenColourAlpha(stroke.colour);
1284  	D2D1_STROKE_STYLE_PROPERTIES strokeProps {};
1285  	strokeProps.startCap = D2D1_CAP_STYLE_SQUARE;
1286  	strokeProps.endCap = D2D1_CAP_STYLE_SQUARE;
1287  	strokeProps.dashCap = D2D1_CAP_STYLE_FLAT;
1288  	strokeProps.lineJoin = D2D1_LINE_JOIN_MITER;
1289  	strokeProps.miterLimit = 4.0f;
1290  	strokeProps.dashStyle = D2D1_DASH_STYLE_SOLID;
1291  	strokeProps.dashOffset = 0;
1292  	ID2D1StrokeStyle *pStrokeStyle = nullptr;
1293  	const HRESULT hr = pD2DFactory->CreateStrokeStyle(
1294  		strokeProps, nullptr, 0, &pStrokeStyle);
1295  	if (SUCCEEDED(hr)) {
1296  		pRenderTarget->DrawLine(
1297  			DPointFromPoint(start),
1298  			DPointFromPoint(end), pBrush, stroke.WidthF(), pStrokeStyle);
1299  	}
1300  	ReleaseUnknown(pStrokeStyle);
1301  }
1302  ID2D1PathGeometry *SurfaceD2D::Geometry(const Point *pts, size_t npts, D2D1_FIGURE_BEGIN figureBegin) noexcept {
1303  	ID2D1PathGeometry *geometry = nullptr;
1304  	HRESULT hr = pD2DFactory->CreatePathGeometry(&geometry);
1305  	if (SUCCEEDED(hr) && geometry) {
1306  		ID2D1GeometrySink *sink = nullptr;
1307  		hr = geometry->Open(&sink);
1308  		if (SUCCEEDED(hr) && sink) {
1309  			sink->BeginFigure(DPointFromPoint(pts[0]), figureBegin);
1310  			for (size_t i = 1; i < npts; i++) {
1311  				sink->AddLine(DPointFromPoint(pts[i]));
1312  			}
1313  			sink->EndFigure((figureBegin == D2D1_FIGURE_BEGIN_FILLED) ?
1314  				D2D1_FIGURE_END_CLOSED : D2D1_FIGURE_END_OPEN);
1315  			sink->Close();
1316  			ReleaseUnknown(sink);
1317  		}
1318  	}
1319  	return geometry;
1320  }
1321  void SurfaceD2D::PolyLine(const Point *pts, size_t npts, Stroke stroke) {
1322  	PLATFORM_ASSERT(pRenderTarget && (npts > 1));
1323  	if (!pRenderTarget || (npts <= 1)) {
1324  		return;
1325  	}
1326  	ID2D1PathGeometry *geometry = Geometry(pts, npts, D2D1_FIGURE_BEGIN_HOLLOW);
1327  	PLATFORM_ASSERT(geometry);
1328  	if (!geometry) {
1329  		return;
1330  	}
1331  	D2DPenColourAlpha(stroke.colour);
1332  	D2D1_STROKE_STYLE_PROPERTIES strokeProps {};
1333  	strokeProps.startCap = D2D1_CAP_STYLE_ROUND;
1334  	strokeProps.endCap = D2D1_CAP_STYLE_ROUND;
1335  	strokeProps.dashCap = D2D1_CAP_STYLE_FLAT;
1336  	strokeProps.lineJoin = D2D1_LINE_JOIN_MITER;
1337  	strokeProps.miterLimit = 4.0f;
1338  	strokeProps.dashStyle = D2D1_DASH_STYLE_SOLID;
1339  	strokeProps.dashOffset = 0;
1340  	ID2D1StrokeStyle *pStrokeStyle = nullptr;
1341  	const HRESULT hr = pD2DFactory->CreateStrokeStyle(
1342  		strokeProps, nullptr, 0, &pStrokeStyle);
1343  	if (SUCCEEDED(hr)) {
1344  		pRenderTarget->DrawGeometry(geometry, pBrush, stroke.WidthF(), pStrokeStyle);
1345  	}
1346  	ReleaseUnknown(pStrokeStyle);
1347  	ReleaseUnknown(geometry);
1348  }
1349  void SurfaceD2D::Polygon(const Point *pts, size_t npts, FillStroke fillStroke) {
1350  	PLATFORM_ASSERT(pRenderTarget && (npts > 2));
1351  	if (pRenderTarget) {
1352  		ID2D1PathGeometry *geometry = Geometry(pts, npts, D2D1_FIGURE_BEGIN_FILLED);
1353  		PLATFORM_ASSERT(geometry);
1354  		if (geometry) {
1355  			D2DPenColourAlpha(fillStroke.fill.colour);
1356  			pRenderTarget->FillGeometry(geometry, pBrush);
1357  			D2DPenColourAlpha(fillStroke.stroke.colour);
1358  			pRenderTarget->DrawGeometry(geometry, pBrush, fillStroke.stroke.WidthF());
1359  			ReleaseUnknown(geometry);
1360  		}
1361  	}
1362  }
1363  void SurfaceD2D::RectangleDraw(PRectangle rc, FillStroke fillStroke) {
1364  	if (!pRenderTarget)
1365  		return;
1366  	const D2D1_RECT_F rect = RectangleFromPRectangle(rc);
1367  	const D2D1_RECT_F rectFill = RectangleInset(rect, fillStroke.stroke.WidthF());
1368  	const float halfStroke = fillStroke.stroke.WidthF() / 2.0f;
1369  	const D2D1_RECT_F rectOutline = RectangleInset(rect, halfStroke);
1370  	D2DPenColourAlpha(fillStroke.fill.colour);
1371  	pRenderTarget->FillRectangle(&rectFill, pBrush);
1372  	D2DPenColourAlpha(fillStroke.stroke.colour);
1373  	pRenderTarget->DrawRectangle(&rectOutline, pBrush, fillStroke.stroke.WidthF());
1374  }
1375  void SurfaceD2D::RectangleFrame(PRectangle rc, Stroke stroke) {
1376  	if (pRenderTarget) {
1377  		const XYPOSITION halfStroke = stroke.width / 2.0f;
1378  		const D2D1_RECT_F rectangle1 = RectangleFromPRectangle(rc.Inset(halfStroke));
1379  		D2DPenColourAlpha(stroke.colour);
1380  		pRenderTarget->DrawRectangle(&rectangle1, pBrush, stroke.WidthF());
1381  	}
1382  }
1383  void SurfaceD2D::FillRectangle(PRectangle rc, Fill fill) {
1384  	if (pRenderTarget) {
1385  		D2DPenColourAlpha(fill.colour);
1386  		const D2D1_RECT_F rectangle = RectangleFromPRectangle(rc);
1387  		pRenderTarget->FillRectangle(&rectangle, pBrush);
1388  	}
1389  }
1390  void SurfaceD2D::FillRectangleAligned(PRectangle rc, Fill fill) {
1391  	FillRectangle(PixelAlign(rc, PixelDivisions()), fill);
1392  }
1393  void SurfaceD2D::FillRectangle(PRectangle rc, Surface &surfacePattern) {
1394  	SurfaceD2D *psurfOther = dynamic_cast<SurfaceD2D *>(&surfacePattern);
1395  	PLATFORM_ASSERT(psurfOther);
1396  	if (!psurfOther) {
1397  		throw std::runtime_error("SurfaceD2D::FillRectangle: wrong Surface type.");
1398  	}
1399  	ID2D1Bitmap *pBitmap = nullptr;
1400  	HRESULT hr = psurfOther->GetBitmap(&pBitmap);
1401  	if (SUCCEEDED(hr) && pBitmap) {
1402  		ID2D1BitmapBrush *pBitmapBrush = nullptr;
1403  		const D2D1_BITMAP_BRUSH_PROPERTIES brushProperties =
1404  	        D2D1::BitmapBrushProperties(D2D1_EXTEND_MODE_WRAP, D2D1_EXTEND_MODE_WRAP,
1405  			D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR);
1406  		hr = pRenderTarget->CreateBitmapBrush(pBitmap, brushProperties, &pBitmapBrush);
1407  		ReleaseUnknown(pBitmap);
1408  		if (SUCCEEDED(hr) && pBitmapBrush) {
1409  			pRenderTarget->FillRectangle(
1410  				RectangleFromPRectangle(rc),
1411  				pBitmapBrush);
1412  			ReleaseUnknown(pBitmapBrush);
1413  		}
1414  	}
1415  }
1416  void SurfaceD2D::RoundedRectangle(PRectangle rc, FillStroke fillStroke) {
1417  	if (pRenderTarget) {
1418  		const FLOAT minDimension = static_cast<FLOAT>(std::min(rc.Width(), rc.Height())) / 2.0f;
1419  		const FLOAT radius = std::min(4.0f, minDimension);
1420  		if (fillStroke.fill.colour == fillStroke.stroke.colour) {
1421  			const D2D1_ROUNDED_RECT roundedRectFill = {
1422  				RectangleFromPRectangle(rc),
1423  				radius, radius };
1424  			D2DPenColourAlpha(fillStroke.fill.colour);
1425  			pRenderTarget->FillRoundedRectangle(roundedRectFill, pBrush);
1426  		} else {
1427  			const D2D1_ROUNDED_RECT roundedRectFill = {
1428  				RectangleFromPRectangle(rc.Inset(1.0)),
1429  				radius-1, radius-1 };
1430  			D2DPenColourAlpha(fillStroke.fill.colour);
1431  			pRenderTarget->FillRoundedRectangle(roundedRectFill, pBrush);
1432  			const D2D1_ROUNDED_RECT roundedRect = {
1433  				RectangleFromPRectangle(rc.Inset(0.5)),
1434  				radius, radius };
1435  			D2DPenColourAlpha(fillStroke.stroke.colour);
1436  			pRenderTarget->DrawRoundedRectangle(roundedRect, pBrush, fillStroke.stroke.WidthF());
1437  		}
1438  	}
1439  }
1440  void SurfaceD2D::AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) {
1441  	const D2D1_RECT_F rect = RectangleFromPRectangle(rc);
1442  	const D2D1_RECT_F rectFill = RectangleInset(rect, fillStroke.stroke.WidthF());
1443  	const float halfStroke = fillStroke.stroke.WidthF() / 2.0f;
1444  	const D2D1_RECT_F rectOutline = RectangleInset(rect, halfStroke);
1445  	if (pRenderTarget) {
1446  		if (cornerSize == 0) {
1447  			D2DPenColourAlpha(fillStroke.fill.colour);
1448  			pRenderTarget->FillRectangle(rectFill, pBrush);
1449  			D2DPenColourAlpha(fillStroke.stroke.colour);
1450  			pRenderTarget->DrawRectangle(rectOutline, pBrush, fillStroke.stroke.WidthF());
1451  		} else {
1452  			const float cornerSizeF = static_cast<float>(cornerSize);
1453  			const D2D1_ROUNDED_RECT roundedRectFill = {
1454  				rectFill, cornerSizeF - 1.0f, cornerSizeF - 1.0f };
1455  			D2DPenColourAlpha(fillStroke.fill.colour);
1456  			pRenderTarget->FillRoundedRectangle(roundedRectFill, pBrush);
1457  			const D2D1_ROUNDED_RECT roundedRect = {
1458  				rectOutline, cornerSizeF, cornerSizeF};
1459  			D2DPenColourAlpha(fillStroke.stroke.colour);
1460  			pRenderTarget->DrawRoundedRectangle(roundedRect, pBrush, fillStroke.stroke.WidthF());
1461  		}
1462  	}
1463  }
1464  void SurfaceD2D::GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) {
1465  	if (pRenderTarget) {
1466  		D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES lgbp {
1467  			DPointFromPoint(Point(rc.left, rc.top)), {}
1468  		};
1469  		switch (options) {
1470  		case GradientOptions::leftToRight:
1471  			lgbp.endPoint = DPointFromPoint(Point(rc.right, rc.top));
1472  			break;
1473  		case GradientOptions::topToBottom:
1474  		default:
1475  			lgbp.endPoint = DPointFromPoint(Point(rc.left, rc.bottom));
1476  			break;
1477  		}
1478  		std::vector<D2D1_GRADIENT_STOP> gradientStops;
1479  		for (const ColourStop &stop : stops) {
1480  			gradientStops.push_back({ static_cast<FLOAT>(stop.position), ColorFromColourAlpha(stop.colour) });
1481  		}
1482  		ID2D1GradientStopCollection *pGradientStops = nullptr;
1483  		HRESULT hr = pRenderTarget->CreateGradientStopCollection(
1484  			gradientStops.data(), static_cast<UINT32>(gradientStops.size()), &pGradientStops);
1485  		if (FAILED(hr) || !pGradientStops) {
1486  			return;
1487  		}
1488  		ID2D1LinearGradientBrush *pBrushLinear = nullptr;
1489  		hr = pRenderTarget->CreateLinearGradientBrush(
1490  			lgbp, pGradientStops, &pBrushLinear);
1491  		if (SUCCEEDED(hr) && pBrushLinear) {
1492  			const D2D1_RECT_F rectangle = RectangleFromPRectangle(PRectangle(
1493  				std::round(rc.left), rc.top, std::round(rc.right), rc.bottom));
1494  			pRenderTarget->FillRectangle(&rectangle, pBrushLinear);
1495  			ReleaseUnknown(pBrushLinear);
1496  		}
1497  		ReleaseUnknown(pGradientStops);
1498  	}
1499  }
1500  void SurfaceD2D::DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) {
1501  	if (pRenderTarget) {
1502  		if (rc.Width() > width)
1503  			rc.left += std::floor((rc.Width() - width) / 2);
1504  		rc.right = rc.left + width;
1505  		if (rc.Height() > height)
1506  			rc.top += std::floor((rc.Height() - height) / 2);
1507  		rc.bottom = rc.top + height;
1508  		std::vector<unsigned char> image(RGBAImage::bytesPerPixel * height * width);
1509  		RGBAImage::BGRAFromRGBA(image.data(), pixelsImage, static_cast<ptrdiff_t>(height) * width);
1510  		ID2D1Bitmap *bitmap = nullptr;
1511  		const D2D1_SIZE_U size = D2D1::SizeU(width, height);
1512  		const D2D1_BITMAP_PROPERTIES props = {{DXGI_FORMAT_B8G8R8A8_UNORM,
1513  		    D2D1_ALPHA_MODE_PREMULTIPLIED}, 72.0, 72.0};
1514  		const HRESULT hr = pRenderTarget->CreateBitmap(size, image.data(),
1515                    width * 4, &props, &bitmap);
1516  		if (SUCCEEDED(hr)) {
1517  			const D2D1_RECT_F rcDestination = RectangleFromPRectangle(rc);
1518  			pRenderTarget->DrawBitmap(bitmap, rcDestination);
1519  			ReleaseUnknown(bitmap);
1520  		}
1521  	}
1522  }
1523  void SurfaceD2D::Ellipse(PRectangle rc, FillStroke fillStroke) {
1524  	if (!pRenderTarget)
1525  		return;
1526  	const D2D1_POINT_2F centre = DPointFromPoint(rc.Centre());
1527  	const FLOAT radiusFill = static_cast<FLOAT>(rc.Width() / 2.0f - fillStroke.stroke.width);
1528  	const D2D1_ELLIPSE ellipseFill = { centre, radiusFill, radiusFill };
1529  	D2DPenColourAlpha(fillStroke.fill.colour);
1530  	pRenderTarget->FillEllipse(ellipseFill, pBrush);
1531  	const FLOAT radiusOutline = static_cast<FLOAT>(rc.Width() / 2.0f - fillStroke.stroke.width / 2.0f);
1532  	const D2D1_ELLIPSE ellipseOutline = { centre, radiusOutline, radiusOutline };
1533  	D2DPenColourAlpha(fillStroke.stroke.colour);
1534  	pRenderTarget->DrawEllipse(ellipseOutline, pBrush, fillStroke.stroke.WidthF());
1535  }
1536  void SurfaceD2D::Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) {
1537  	if (!pRenderTarget)
1538  		return;
1539  	if (rc.Width() < rc.Height()) {
1540  		RectangleDraw(rc, fillStroke);
1541  		return;
1542  	}
1543  	const FLOAT radius = static_cast<FLOAT>(rc.Height() / 2.0);
1544  	const FLOAT radiusFill = radius - fillStroke.stroke.WidthF();
1545  	const FLOAT halfStroke = fillStroke.stroke.WidthF() / 2.0f;
1546  	if (ends == Surface::Ends::semiCircles) {
1547  		const D2D1_RECT_F rect = RectangleFromPRectangle(rc);
1548  		const D2D1_ROUNDED_RECT roundedRectFill = { RectangleInset(rect, fillStroke.stroke.WidthF()),
1549  			radiusFill, radiusFill };
1550  		D2DPenColourAlpha(fillStroke.fill.colour);
1551  		pRenderTarget->FillRoundedRectangle(roundedRectFill, pBrush);
1552  		const D2D1_ROUNDED_RECT roundedRect = { RectangleInset(rect, halfStroke),
1553  			radius, radius };
1554  		D2DPenColourAlpha(fillStroke.stroke.colour);
1555  		pRenderTarget->DrawRoundedRectangle(roundedRect, pBrush, fillStroke.stroke.WidthF());
1556  	} else {
1557  		const Ends leftSide = static_cast<Ends>(static_cast<int>(ends) & 0xf);
1558  		const Ends rightSide = static_cast<Ends>(static_cast<int>(ends) & 0xf0);
1559  		PRectangle rcInner = rc;
1560  		rcInner.left += radius;
1561  		rcInner.right -= radius;
1562  		ID2D1PathGeometry *pathGeometry = nullptr;
1563  		const HRESULT hrGeometry = pD2DFactory->CreatePathGeometry(&pathGeometry);
1564  		if (FAILED(hrGeometry) || !pathGeometry)
1565  			return;
1566  		ID2D1GeometrySink *pSink = nullptr;
1567  		const HRESULT hrSink = pathGeometry->Open(&pSink);
1568  		if (SUCCEEDED(hrSink) && pSink) {
1569  			switch (leftSide) {
1570  				case Ends::leftFlat:
1571  					pSink->BeginFigure(DPointFromPoint(Point(rc.left + halfStroke, rc.top + halfStroke)), D2D1_FIGURE_BEGIN_FILLED);
1572  					pSink->AddLine(DPointFromPoint(Point(rc.left + halfStroke, rc.bottom - halfStroke)));
1573  					break;
1574  				case Ends::leftAngle:
1575  					pSink->BeginFigure(DPointFromPoint(Point(rcInner.left + halfStroke, rc.top + halfStroke)), D2D1_FIGURE_BEGIN_FILLED);
1576  					pSink->AddLine(DPointFromPoint(Point(rc.left + halfStroke, rc.Centre().y)));
1577  					pSink->AddLine(DPointFromPoint(Point(rcInner.left + halfStroke, rc.bottom - halfStroke)));
1578  					break;
1579  				case Ends::semiCircles:
1580  				default: {
1581  						pSink->BeginFigure(DPointFromPoint(Point(rcInner.left + halfStroke, rc.top + halfStroke)), D2D1_FIGURE_BEGIN_FILLED);
1582  						D2D1_ARC_SEGMENT segment{};
1583  						segment.point = DPointFromPoint(Point(rcInner.left + halfStroke, rc.bottom - halfStroke));
1584  						segment.size = D2D1::SizeF(radiusFill, radiusFill);
1585  						segment.rotationAngle = 0.0f;
1586  						segment.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
1587  						segment.arcSize = D2D1_ARC_SIZE_SMALL;
1588  						pSink->AddArc(segment);
1589  					}
1590  					break;
1591  			}
1592  			switch (rightSide) {
1593  			case Ends::rightFlat:
1594  				pSink->AddLine(DPointFromPoint(Point(rc.right - halfStroke, rc.bottom - halfStroke)));
1595  				pSink->AddLine(DPointFromPoint(Point(rc.right - halfStroke, rc.top + halfStroke)));
1596  				break;
1597  			case Ends::rightAngle:
1598  				pSink->AddLine(DPointFromPoint(Point(rcInner.right - halfStroke, rc.bottom - halfStroke)));
1599  				pSink->AddLine(DPointFromPoint(Point(rc.right - halfStroke, rc.Centre().y)));
1600  				pSink->AddLine(DPointFromPoint(Point(rcInner.right - halfStroke, rc.top + halfStroke)));
1601  				break;
1602  			case Ends::semiCircles:
1603  			default: {
1604  					pSink->AddLine(DPointFromPoint(Point(rcInner.right - halfStroke, rc.bottom - halfStroke)));
1605  					D2D1_ARC_SEGMENT segment{};
1606  					segment.point = DPointFromPoint(Point(rcInner.right - halfStroke, rc.top + halfStroke));
1607  					segment.size = D2D1::SizeF(radiusFill, radiusFill);
1608  					segment.rotationAngle = 0.0f;
1609  					segment.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
1610  					segment.arcSize = D2D1_ARC_SIZE_SMALL;
1611  					pSink->AddArc(segment);
1612  				}
1613  				break;
1614  			}
1615  			pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
1616  			pSink->Close();
1617  		}
1618  		ReleaseUnknown(pSink);
1619  		D2DPenColourAlpha(fillStroke.fill.colour);
1620  		pRenderTarget->FillGeometry(pathGeometry, pBrush);
1621  		D2DPenColourAlpha(fillStroke.stroke.colour);
1622  		pRenderTarget->DrawGeometry(pathGeometry, pBrush, fillStroke.stroke.WidthF());
1623  		ReleaseUnknown(pathGeometry);
1624  	}
1625  }
1626  void SurfaceD2D::Copy(PRectangle rc, Point from, Surface &surfaceSource) {
1627  	SurfaceD2D &surfOther = dynamic_cast<SurfaceD2D &>(surfaceSource);
1628  	ID2D1Bitmap *pBitmap = nullptr;
1629  	const HRESULT hr = surfOther.GetBitmap(&pBitmap);
1630  	if (SUCCEEDED(hr) && pBitmap) {
1631  		const D2D1_RECT_F rcDestination = RectangleFromPRectangle(rc);
1632  		const D2D1_RECT_F rcSource = RectangleFromPRectangle(PRectangle(
1633  			from.x, from.y, from.x + rc.Width(), from.y + rc.Height()));
1634  		pRenderTarget->DrawBitmap(pBitmap, rcDestination, 1.0f,
1635  			D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR, rcSource);
1636  		ReleaseUnknown(pBitmap);
1637  	}
1638  }
1639  class BlobInline final : public IDWriteInlineObject {
1640  	XYPOSITION width;
1641  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
1642  	STDMETHODIMP_(ULONG)AddRef() override;
1643  	STDMETHODIMP_(ULONG)Release() override;
1644  	COM_DECLSPEC_NOTHROW STDMETHODIMP Draw(
1645  		void *clientDrawingContext,
1646  		IDWriteTextRenderer *renderer,
1647  		FLOAT originX,
1648  		FLOAT originY,
1649  		BOOL isSideways,
1650  		BOOL isRightToLeft,
1651  		IUnknown *clientDrawingEffect
1652  		) override;
1653  	COM_DECLSPEC_NOTHROW STDMETHODIMP GetMetrics(DWRITE_INLINE_OBJECT_METRICS *metrics) override;
1654  	COM_DECLSPEC_NOTHROW STDMETHODIMP GetOverhangMetrics(DWRITE_OVERHANG_METRICS *overhangs) override;
1655  	COM_DECLSPEC_NOTHROW STDMETHODIMP GetBreakConditions(
1656  		DWRITE_BREAK_CONDITION *breakConditionBefore,
1657  		DWRITE_BREAK_CONDITION *breakConditionAfter) override;
1658  public:
1659  	BlobInline(XYPOSITION width_=0.0f) noexcept : width(width_) {
1660  	}
1661  };
1662  STDMETHODIMP BlobInline::QueryInterface(REFIID riid, PVOID *ppv) {
1663  	if (!ppv)
1664  		return E_POINTER;
1665  	*ppv = nullptr;
1666  	if (riid == IID_IUnknown)
1667  		*ppv = this;
1668  	if (riid == __uuidof(IDWriteInlineObject))
1669  		*ppv = this;
1670  	if (!*ppv)
1671  		return E_NOINTERFACE;
1672  	return S_OK;
1673  }
1674  STDMETHODIMP_(ULONG) BlobInline::AddRef() {
1675  	return 1;
1676  }
1677  STDMETHODIMP_(ULONG) BlobInline::Release() {
1678  	return 1;
1679  }
1680  COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BlobInline::Draw(
1681  	void*,
1682  	IDWriteTextRenderer*,
1683  	FLOAT,
1684  	FLOAT,
1685  	BOOL,
1686  	BOOL,
1687  	IUnknown*) {
1688  	return S_OK;
1689  }
1690  COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BlobInline::GetMetrics(
1691  	DWRITE_INLINE_OBJECT_METRICS *metrics
1692  ) {
1693  	if (!metrics)
1694  		return E_POINTER;
1695  	metrics->width = static_cast<FLOAT>(width);
1696  	metrics->height = 2;
1697  	metrics->baseline = 1;
1698  	metrics->supportsSideways = FALSE;
1699  	return S_OK;
1700  }
1701  COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BlobInline::GetOverhangMetrics(
1702  	DWRITE_OVERHANG_METRICS *overhangs
1703  ) {
1704  	if (!overhangs)
1705  		return E_POINTER;
1706  	overhangs->left = 0;
1707  	overhangs->top = 0;
1708  	overhangs->right = 0;
1709  	overhangs->bottom = 0;
1710  	return S_OK;
1711  }
1712  COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BlobInline::GetBreakConditions(
1713  	DWRITE_BREAK_CONDITION *breakConditionBefore,
1714  	DWRITE_BREAK_CONDITION *breakConditionAfter
1715  ) {
1716  	if (!breakConditionBefore || !breakConditionAfter)
1717  		return E_POINTER;
1718  	*breakConditionBefore = DWRITE_BREAK_CONDITION_NEUTRAL;
1719  	*breakConditionAfter = DWRITE_BREAK_CONDITION_NEUTRAL;
1720  	return S_OK;
1721  }
1722  class ScreenLineLayout : public IScreenLineLayout {
1723  	IDWriteTextLayout *textLayout = nullptr;
1724  	std::string text;
1725  	std::wstring buffer;
1726  	std::vector<BlobInline> blobs;
1727  	static void FillTextLayoutFormats(const IScreenLine *screenLine, IDWriteTextLayout *textLayout, std::vector<BlobInline> &blobs);
1728  	static std::wstring ReplaceRepresentation(std::string_view text);
1729  	static size_t GetPositionInLayout(std::string_view text, size_t position);
1730  public:
1731  	ScreenLineLayout(const IScreenLine *screenLine);
1732  	ScreenLineLayout(const ScreenLineLayout &) = delete;
1733  	ScreenLineLayout(ScreenLineLayout &&) = delete;
1734  	ScreenLineLayout &operator=(const ScreenLineLayout &) = delete;
1735  	ScreenLineLayout &operator=(ScreenLineLayout &&) = delete;
1736  	~ScreenLineLayout() noexcept override;
1737  	size_t PositionFromX(XYPOSITION xDistance, bool charPosition) override;
1738  	XYPOSITION XFromPosition(size_t caretPosition) override;
1739  	std::vector<Interval> FindRangeIntervals(size_t start, size_t end) override;
1740  };
1741  void ScreenLineLayout::FillTextLayoutFormats(const IScreenLine *screenLine, IDWriteTextLayout *textLayout, std::vector<BlobInline> &blobs) {
1742  	const ptrdiff_t numRepresentations = screenLine->RepresentationCount();
1743  	std::string_view text = screenLine->Text();
1744  	const ptrdiff_t numTabs = std::count(std::begin(text), std::end(text), '\t');
1745  	blobs.reserve(numRepresentations + numTabs);
1746  	UINT32 layoutPosition = 0;
1747  	for (size_t bytePosition = 0; bytePosition < screenLine->Length();) {
1748  		const unsigned char uch = screenLine->Text()[bytePosition];
1749  		const unsigned int byteCount = UTF8BytesOfLead[uch];
1750  		const UINT32 codeUnits = UTF16LengthFromUTF8ByteCount(byteCount);
1751  		const DWRITE_TEXT_RANGE textRange = { layoutPosition, codeUnits };
1752  		XYPOSITION representationWidth = screenLine->RepresentationWidth(bytePosition);
1753  		if ((representationWidth == 0.0f) && (screenLine->Text()[bytePosition] == '\t')) {
1754  			D2D1_POINT_2F realPt {};
1755  			DWRITE_HIT_TEST_METRICS realCaretMetrics {};
1756  			textLayout->HitTestTextPosition(
1757  				layoutPosition,
1758  				false, 
1759  				&realPt.x,
1760  				&realPt.y,
1761  				&realCaretMetrics
1762  			);
1763  			const XYPOSITION nextTab = screenLine->TabPositionAfter(realPt.x);
1764  			representationWidth = nextTab - realPt.x;
1765  		}
1766  		if (representationWidth > 0.0f) {
1767  			blobs.push_back(BlobInline(representationWidth));
1768  			textLayout->SetInlineObject(&blobs.back(), textRange);
1769  		};
1770  		const FontDirectWrite *pfm =
1771  			dynamic_cast<const FontDirectWrite *>(screenLine->FontOfPosition(bytePosition));
1772  		if (!pfm) {
1773  			throw std::runtime_error("FillTextLayoutFormats: wrong Font type.");
1774  		}
1775  		const unsigned int fontFamilyNameSize = pfm->pTextFormat->GetFontFamilyNameLength();
1776  		std::wstring fontFamilyName(fontFamilyNameSize, 0);
1777  		const HRESULT hrFamily = pfm->pTextFormat->GetFontFamilyName(fontFamilyName.data(), fontFamilyNameSize + 1);
1778  		if (SUCCEEDED(hrFamily)) {
1779  			textLayout->SetFontFamilyName(fontFamilyName.c_str(), textRange);
1780  		}
1781  		textLayout->SetFontSize(pfm->pTextFormat->GetFontSize(), textRange);
1782  		textLayout->SetFontWeight(pfm->pTextFormat->GetFontWeight(), textRange);
1783  		textLayout->SetFontStyle(pfm->pTextFormat->GetFontStyle(), textRange);
1784  		const unsigned int localeNameSize = pfm->pTextFormat->GetLocaleNameLength();
1785  		std::wstring localeName(localeNameSize, 0);
1786  		const HRESULT hrLocale = pfm->pTextFormat->GetLocaleName(localeName.data(), localeNameSize + 1);
1787  		if (SUCCEEDED(hrLocale)) {
1788  			textLayout->SetLocaleName(localeName.c_str(), textRange);
1789  		}
1790  		textLayout->SetFontStretch(pfm->pTextFormat->GetFontStretch(), textRange);
1791  		IDWriteFontCollection *fontCollection = nullptr;
1792  		if (SUCCEEDED(pfm->pTextFormat->GetFontCollection(&fontCollection))) {
1793  			textLayout->SetFontCollection(fontCollection, textRange);
1794  		}
1795  		bytePosition += byteCount;
1796  		layoutPosition += codeUnits;
1797  	}
1798  }
1799  std::wstring ScreenLineLayout::ReplaceRepresentation(std::string_view text) {
1800  	const TextWide wideText(text, CpUtf8);
1801  	std::wstring ws(wideText.buffer, wideText.tlen);
1802  	std::replace(ws.begin(), ws.end(), L'\t', L'X');
1803  	return ws;
1804  }
1805  size_t ScreenLineLayout::GetPositionInLayout(std::string_view text, size_t position) {
1806  	const std::string_view textUptoPosition = text.substr(0, position);
1807  	return UTF16Length(textUptoPosition);
1808  }
1809  ScreenLineLayout::ScreenLineLayout(const IScreenLine *screenLine) {
1810  	if (!screenLine || !screenLine->Length())
1811  		return;
1812  	text = screenLine->Text();
1813  	const FontDirectWrite *pfm = FontDirectWrite::Cast(screenLine->FontOfPosition(0));
1814  	if (!pfm->pTextFormat) {
1815  		return;
1816  	}
1817  	buffer = ReplaceRepresentation(screenLine->Text());
1818  	const HRESULT hrCreate = pIDWriteFactory->CreateTextLayout(
1819  		buffer.c_str(),
1820  		static_cast<UINT32>(buffer.length()),
1821  		pfm->pTextFormat,
1822  		static_cast<FLOAT>(screenLine->Width()),
1823  		static_cast<FLOAT>(screenLine->Height()),
1824  		&textLayout);
1825  	if (!SUCCEEDED(hrCreate)) {
1826  		return;
1827  	}
1828  	FillTextLayoutFormats(screenLine, textLayout, blobs);
1829  }
1830  ScreenLineLayout::~ScreenLineLayout() noexcept {
1831  	ReleaseUnknown(textLayout);
1832  }
1833  size_t ScreenLineLayout::PositionFromX(XYPOSITION xDistance, bool charPosition) {
1834  	if (!textLayout) {
1835  		return 0;
1836  	}
1837  	BOOL isTrailingHit = FALSE;
1838  	BOOL isInside = FALSE;
1839  	DWRITE_HIT_TEST_METRICS caretMetrics {};
1840  	textLayout->HitTestPoint(
1841  		static_cast<FLOAT>(xDistance),
1842  		0.0f,
1843  		&isTrailingHit,
1844  		&isInside,
1845  		&caretMetrics
1846  	);
1847  	DWRITE_HIT_TEST_METRICS hitTestMetrics {};
1848  	if (isTrailingHit) {
1849  		FLOAT caretX = 0.0f;
1850  		FLOAT caretY = 0.0f;
1851  		textLayout->HitTestTextPosition(
1852  			caretMetrics.textPosition,
1853  			false,
1854  			&caretX,
1855  			&caretY,
1856  			&hitTestMetrics
1857  		);
1858  	}
1859  	size_t pos;
1860  	if (charPosition) {
1861  		pos = isTrailingHit ? hitTestMetrics.textPosition : caretMetrics.textPosition;
1862  	} else {
1863  		pos = isTrailingHit ? static_cast<size_t>(hitTestMetrics.textPosition) + hitTestMetrics.length : caretMetrics.textPosition;
1864  	}
1865  	return UTF8PositionFromUTF16Position(text, pos);
1866  }
1867  XYPOSITION ScreenLineLayout::XFromPosition(size_t caretPosition) {
1868  	if (!textLayout) {
1869  		return 0.0;
1870  	}
1871  	const size_t position = GetPositionInLayout(text, caretPosition);
1872  	DWRITE_HIT_TEST_METRICS caretMetrics {};
1873  	D2D1_POINT_2F pt {};
1874  	textLayout->HitTestTextPosition(
1875  		static_cast<UINT32>(position),
1876  		false, 
1877  		&pt.x,
1878  		&pt.y,
1879  		&caretMetrics
1880  	);
1881  	return pt.x;
1882  }
1883  std::vector<Interval> ScreenLineLayout::FindRangeIntervals(size_t start, size_t end) {
1884  	std::vector<Interval> ret;
1885  	if (!textLayout || (start == end)) {
1886  		return ret;
1887  	}
1888  	const size_t startPos = GetPositionInLayout(text, start);
1889  	const size_t endPos = GetPositionInLayout(text, end);
1890  	const size_t rangeLength = (endPos > startPos) ? (endPos - startPos) : (startPos - endPos);
1891  	UINT32 actualHitTestCount = 0;
1892  	std::vector<DWRITE_HIT_TEST_METRICS> hitTestMetrics(2);
1893  	textLayout->HitTestTextRange(
1894  		static_cast<UINT32>(startPos),
1895  		static_cast<UINT32>(rangeLength),
1896  		0, 
1897  		0, 
1898  		hitTestMetrics.data(),
1899  		static_cast<UINT32>(hitTestMetrics.size()),
1900  		&actualHitTestCount
1901  	);
1902  	if (actualHitTestCount == 0) {
1903  		return ret;
1904  	}
1905  	if (hitTestMetrics.size() < actualHitTestCount) {
1906  		hitTestMetrics.resize(actualHitTestCount);
1907  		textLayout->HitTestTextRange(
1908  			static_cast<UINT32>(startPos),
1909  			static_cast<UINT32>(rangeLength),
1910  			0, 
1911  			0, 
1912  			hitTestMetrics.data(),
1913  			static_cast<UINT32>(hitTestMetrics.size()),
1914  			&actualHitTestCount
1915  		);
1916  	}
1917  	for (size_t i = 0; i < actualHitTestCount; ++i) {
1918  		const DWRITE_HIT_TEST_METRICS &htm = hitTestMetrics[i];
1919  		const Interval selectionInterval { htm.left, htm.left + htm.width };
1920  		ret.push_back(selectionInterval);
1921  	}
1922  	return ret;
1923  }
1924  std::unique_ptr<IScreenLineLayout> SurfaceD2D::Layout(const IScreenLine *screenLine) {
1925  	return std::make_unique<ScreenLineLayout>(screenLine);
1926  }
1927  void SurfaceD2D::DrawTextCommon(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, int codePageOverride, UINT fuOptions) {
1928  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
1929  	if (pfm->pTextFormat && pRenderTarget && pBrush) {
1930  		const int codePageDraw = codePageOverride ? codePageOverride : pfm->CodePageText(mode.codePage);
1931  		const TextWide tbuf(text, codePageDraw);
1932  		SetFontQuality(pfm->extraFontFlag);
1933  		if (fuOptions & ETO_CLIPPED) {
1934  			const D2D1_RECT_F rcClip = RectangleFromPRectangle(rc);
1935  			pRenderTarget->PushAxisAlignedClip(rcClip, D2D1_ANTIALIAS_MODE_ALIASED);
1936  		}
1937  		IDWriteTextLayout *pTextLayout = nullptr;
1938  		const HRESULT hr = pIDWriteFactory->CreateTextLayout(
1939  				tbuf.buffer,
1940  				tbuf.tlen,
1941  				pfm->pTextFormat,
1942  				static_cast<FLOAT>(rc.Width()),
1943  				static_cast<FLOAT>(rc.Height()),
1944  				&pTextLayout);
1945  		if (SUCCEEDED(hr)) {
1946  			const D2D1_POINT_2F origin = DPointFromPoint(Point(rc.left, ybase - pfm->yAscent));
1947  			pRenderTarget->DrawTextLayout(origin, pTextLayout, pBrush, d2dDrawTextOptions);
1948  			ReleaseUnknown(pTextLayout);
1949  		}
1950  		if (fuOptions & ETO_CLIPPED) {
1951  			pRenderTarget->PopAxisAlignedClip();
1952  		}
1953  	}
1954  }
1955  void SurfaceD2D::DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
1956  	ColourRGBA fore, ColourRGBA back) {
1957  	if (pRenderTarget) {
1958  		FillRectangleAligned(rc, back);
1959  		D2DPenColourAlpha(fore);
1960  		DrawTextCommon(rc, font_, ybase, text, 0, ETO_OPAQUE);
1961  	}
1962  }
1963  void SurfaceD2D::DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
1964  	ColourRGBA fore, ColourRGBA back) {
1965  	if (pRenderTarget) {
1966  		FillRectangleAligned(rc, back);
1967  		D2DPenColourAlpha(fore);
1968  		DrawTextCommon(rc, font_, ybase, text, 0, ETO_OPAQUE | ETO_CLIPPED);
1969  	}
1970  }
1971  void SurfaceD2D::DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
1972  	ColourRGBA fore) {
1973  	for (const char ch : text) {
1974  		if (ch != ' ') {
1975  			if (pRenderTarget) {
1976  				D2DPenColourAlpha(fore);
1977  				DrawTextCommon(rc, font_, ybase, text, 0, 0);
1978  			}
1979  			return;
1980  		}
1981  	}
1982  }
1983  namespace {
1984  HRESULT MeasurePositions(TextPositions &poses, const TextWide &tbuf, IDWriteTextFormat *pTextFormat) {
1985  	if (!pTextFormat) {
1986  		return E_FAIL;
1987  	}
1988  	std::fill(poses.buffer, poses.buffer + tbuf.tlen, 0.0f);
1989  	IDWriteTextLayout *pTextLayout = nullptr;
1990  	const HRESULT hrCreate = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pTextFormat, 10000.0, 1000.0, &pTextLayout);
1991  	if (!SUCCEEDED(hrCreate)) {
1992  		return hrCreate;
1993  	}
1994  	if (!pTextLayout) {
1995  		return E_FAIL;
1996  	}
1997  	VarBuffer<DWRITE_CLUSTER_METRICS, stackBufferLength> cm(tbuf.tlen);
1998  	UINT32 count = 0;
1999  	const HRESULT hrGetCluster = pTextLayout->GetClusterMetrics(cm.buffer, tbuf.tlen, &count);
2000  	ReleaseUnknown(pTextLayout);
2001  	if (!SUCCEEDED(hrGetCluster)) {
2002  		return hrGetCluster;
2003  	}
2004  	const DWRITE_CLUSTER_METRICS * const clusterMetrics = cm.buffer;
2005  	XYPOSITION position = 0.0;
2006  	int ti=0;
2007  	for (unsigned int ci=0; ci<count; ci++) {
2008  		for (unsigned int inCluster=0; inCluster<clusterMetrics[ci].length; inCluster++) {
2009  			poses.buffer[ti++] = position + clusterMetrics[ci].width * (inCluster + 1) / clusterMetrics[ci].length;
2010  		}
2011  		position += clusterMetrics[ci].width;
2012  	}
2013  	PLATFORM_ASSERT(ti == tbuf.tlen);
2014  	return S_OK;
2015  }
2016  }
2017  void SurfaceD2D::MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) {
2018  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2019  	const int codePageText = pfm->CodePageText(mode.codePage);
2020  	const TextWide tbuf(text, codePageText);
2021  	TextPositions poses(tbuf.tlen);
2022  	if (FAILED(MeasurePositions(poses, tbuf, pfm->pTextFormat))) {
2023  		return;
2024  	}
2025  	if (codePageText == CpUtf8) {
2026  		size_t i = 0;
2027  		for (int ui = 0; ui < tbuf.tlen; ui++) {
2028  			const unsigned char uch = text[i];
2029  			const unsigned int byteCount = UTF8BytesOfLead[uch];
2030  			if (byteCount == 4) {	
2031  				ui++;
2032  			}
2033  			for (unsigned int bytePos=0; (bytePos<byteCount) && (i<text.length()) && (ui<tbuf.tlen); bytePos++) {
2034  				positions[i++] = poses.buffer[ui];
2035  			}
2036  		}
2037  		const XYPOSITION lastPos = (i > 0) ? positions[i - 1] : 0.0;
2038  		while (i<text.length()) {
2039  			positions[i++] = lastPos;
2040  		}
2041  	} else if (!IsDBCSCodePage(codePageText)) {
2042  		PLATFORM_ASSERT(text.length() == static_cast<size_t>(tbuf.tlen));
2043  		for (int kk=0; kk<tbuf.tlen; kk++) {
2044  			positions[kk] = poses.buffer[kk];
2045  		}
2046  	} else {
2047  		int ui = 0;
2048  		for (size_t i=0; i<text.length() && ui<tbuf.tlen;) {
2049  			positions[i] = poses.buffer[ui];
2050  			if (DBCSIsLeadByte(codePageText, text[i])) {
2051  				positions[i+1] = poses.buffer[ui];
2052  				i += 2;
2053  			} else {
2054  				i++;
2055  			}
2056  			ui++;
2057  		}
2058  	}
2059  }
2060  XYPOSITION SurfaceD2D::WidthText(const Font *font_, std::string_view text) {
2061  	FLOAT width = 1.0;
2062  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2063  	if (pfm->pTextFormat) {
2064  		const TextWide tbuf(text, pfm->CodePageText(mode.codePage));
2065  		IDWriteTextLayout *pTextLayout = nullptr;
2066  		const HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pfm->pTextFormat, 1000.0, 1000.0, &pTextLayout);
2067  		if (SUCCEEDED(hr) && pTextLayout) {
2068  			DWRITE_TEXT_METRICS textMetrics;
2069  			if (SUCCEEDED(pTextLayout->GetMetrics(&textMetrics)))
2070  				width = textMetrics.widthIncludingTrailingWhitespace;
2071  			ReleaseUnknown(pTextLayout);
2072  		}
2073  	}
2074  	return width;
2075  }
2076  void SurfaceD2D::DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
2077  	ColourRGBA fore, ColourRGBA back) {
2078  	if (pRenderTarget) {
2079  		FillRectangleAligned(rc, back);
2080  		D2DPenColourAlpha(fore);
2081  		DrawTextCommon(rc, font_, ybase, text, CpUtf8, ETO_OPAQUE);
2082  	}
2083  }
2084  void SurfaceD2D::DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
2085  	ColourRGBA fore, ColourRGBA back) {
2086  	if (pRenderTarget) {
2087  		FillRectangleAligned(rc, back);
2088  		D2DPenColourAlpha(fore);
2089  		DrawTextCommon(rc, font_, ybase, text, CpUtf8, ETO_OPAQUE | ETO_CLIPPED);
2090  	}
2091  }
2092  void SurfaceD2D::DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text,
2093  	ColourRGBA fore) {
2094  	for (const char ch : text) {
2095  		if (ch != ' ') {
2096  			if (pRenderTarget) {
2097  				D2DPenColourAlpha(fore);
2098  				DrawTextCommon(rc, font_, ybase, text, CpUtf8, 0);
2099  			}
2100  			return;
2101  		}
2102  	}
2103  }
2104  void SurfaceD2D::MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) {
2105  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2106  	const TextWide tbuf(text, CpUtf8);
2107  	TextPositions poses(tbuf.tlen);
2108  	if (FAILED(MeasurePositions(poses, tbuf, pfm->pTextFormat))) {
2109  		return;
2110  	}
2111  	size_t i = 0;
2112  	for (int ui = 0; ui < tbuf.tlen; ui++) {
2113  		const unsigned char uch = text[i];
2114  		const unsigned int byteCount = UTF8BytesOfLead[uch];
2115  		if (byteCount == 4) {	
2116  			ui++;
2117  			PLATFORM_ASSERT(ui < tbuf.tlen);
2118  		}
2119  		for (unsigned int bytePos=0; (bytePos<byteCount) && (i<text.length()) && (ui < tbuf.tlen); bytePos++) {
2120  			positions[i++] = poses.buffer[ui];
2121  		}
2122  	}
2123  	const XYPOSITION lastPos = (i > 0) ? positions[i - 1] : 0.0;
2124  	while (i < text.length()) {
2125  		positions[i++] = lastPos;
2126  	}
2127  }
2128  XYPOSITION SurfaceD2D::WidthTextUTF8(const Font * font_, std::string_view text) {
2129  	FLOAT width = 1.0;
2130  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2131  	if (pfm->pTextFormat) {
2132  		const TextWide tbuf(text, CpUtf8);
2133  		IDWriteTextLayout *pTextLayout = nullptr;
2134  		const HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pfm->pTextFormat, 1000.0, 1000.0, &pTextLayout);
2135  		if (SUCCEEDED(hr)) {
2136  			DWRITE_TEXT_METRICS textMetrics;
2137  			if (SUCCEEDED(pTextLayout->GetMetrics(&textMetrics)))
2138  				width = textMetrics.widthIncludingTrailingWhitespace;
2139  			ReleaseUnknown(pTextLayout);
2140  		}
2141  	}
2142  	return width;
2143  }
2144  XYPOSITION SurfaceD2D::Ascent(const Font *font_) {
2145  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2146  	return std::ceil(pfm->yAscent);
2147  }
2148  XYPOSITION SurfaceD2D::Descent(const Font *font_) {
2149  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2150  	return std::ceil(pfm->yDescent);
2151  }
2152  XYPOSITION SurfaceD2D::InternalLeading(const Font *font_) {
2153  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2154  	return std::floor(pfm->yInternalLeading);
2155  }
2156  XYPOSITION SurfaceD2D::Height(const Font *font_) {
2157  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2158  	return std::ceil(pfm->yAscent) + std::ceil(pfm->yDescent);
2159  }
2160  XYPOSITION SurfaceD2D::AverageCharWidth(const Font *font_) {
2161  	FLOAT width = 1.0;
2162  	const FontDirectWrite *pfm = FontDirectWrite::Cast(font_);
2163  	if (pfm->pTextFormat) {
2164  		IDWriteTextLayout *pTextLayout = nullptr;
2165  		static constexpr WCHAR wszAllAlpha[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
2166  		const size_t lenAllAlpha = wcslen(wszAllAlpha);
2167  		const HRESULT hr = pIDWriteFactory->CreateTextLayout(wszAllAlpha, static_cast<UINT32>(lenAllAlpha),
2168  			pfm->pTextFormat, 1000.0, 1000.0, &pTextLayout);
2169  		if (SUCCEEDED(hr) && pTextLayout) {
2170  			DWRITE_TEXT_METRICS textMetrics;
2171  			if (SUCCEEDED(pTextLayout->GetMetrics(&textMetrics)))
2172  				width = textMetrics.width / lenAllAlpha;
2173  			ReleaseUnknown(pTextLayout);
2174  		}
2175  	}
2176  	return width;
2177  }
2178  void SurfaceD2D::SetClip(PRectangle rc) {
2179  	if (pRenderTarget) {
2180  		const D2D1_RECT_F rcClip = RectangleFromPRectangle(rc);
2181  		pRenderTarget->PushAxisAlignedClip(rcClip, D2D1_ANTIALIAS_MODE_ALIASED);
2182  		clipsActive++;
2183  	}
2184  }
2185  void SurfaceD2D::PopClip() {
2186  	if (pRenderTarget) {
2187  		PLATFORM_ASSERT(clipsActive > 0);
2188  		pRenderTarget->PopAxisAlignedClip();
2189  		clipsActive--;
2190  	}
2191  }
2192  void SurfaceD2D::FlushCachedState() {
2193  }
2194  void SurfaceD2D::FlushDrawing() {
2195  	if (pRenderTarget) {
2196  		pRenderTarget->Flush();
2197  	}
2198  }
2199  void SurfaceD2D::SetRenderingParams(std::shared_ptr<RenderingParams> renderingParams_) {
2200  	renderingParams = renderingParams_;
2201  }
2202  #endif
2203  std::unique_ptr<Surface> Surface::Allocate(Technology technology) {
2204  #if defined(USE_D2D)
2205  	if (technology == Technology::Default)
2206  		return std::make_unique<SurfaceGDI>();
2207  	else
2208  		return std::make_unique<SurfaceD2D>();
2209  #else
2210  	return std::make_unique<SurfaceGDI>();
2211  #endif
2212  }
2213  Window::~Window() noexcept {
2214  }
2215  void Window::Destroy() noexcept {
2216  	if (wid)
2217  		::DestroyWindow(HwndFromWindowID(wid));
2218  	wid = nullptr;
2219  }
2220  PRectangle Window::GetPosition() const {
2221  	RECT rc;
2222  	::GetWindowRect(HwndFromWindowID(wid), &rc);
2223  	return PRectangle::FromInts(rc.left, rc.top, rc.right, rc.bottom);
2224  }
2225  void Window::SetPosition(PRectangle rc) {
2226  	::SetWindowPos(HwndFromWindowID(wid),
2227  		0, static_cast<int>(rc.left), static_cast<int>(rc.top),
2228  		static_cast<int>(rc.Width()), static_cast<int>(rc.Height()), SWP_NOZORDER | SWP_NOACTIVATE);
2229  }
2230  namespace {
2231  RECT RectFromMonitor(HMONITOR hMonitor) noexcept {
2232  	MONITORINFO mi = {};
2233  	mi.cbSize = sizeof(mi);
2234  	if (GetMonitorInfo(hMonitor, &mi)) {
2235  		return mi.rcWork;
2236  	}
2237  	RECT rc = {0, 0, 0, 0};
2238  	if (::SystemParametersInfoA(SPI_GETWORKAREA, 0, &rc, 0) == 0) {
2239  		rc.left = 0;
2240  		rc.top = 0;
2241  		rc.right = 0;
2242  		rc.bottom = 0;
2243  	}
2244  	return rc;
2245  }
2246  }
2247  void Window::SetPositionRelative(PRectangle rc, const Window *relativeTo) {
2248  	const DWORD style = GetWindowStyle(HwndFromWindowID(wid));
2249  	if (style & WS_POPUP) {
2250  		POINT ptOther = {0, 0};
2251  		::ClientToScreen(HwndFromWindow(*relativeTo), &ptOther);
2252  		rc.Move(static_cast<XYPOSITION>(ptOther.x), static_cast<XYPOSITION>(ptOther.y));
2253  		const RECT rcMonitor = RectFromPRectangle(rc);
2254  		HMONITOR hMonitor = MonitorFromRect(&rcMonitor, MONITOR_DEFAULTTONEAREST);
2255  		const RECT rcWork = RectFromMonitor(hMonitor);
2256  		if (rcWork.left < rcWork.right) {
2257  			if (rc.right > rcWork.right)
2258  				rc.Move(rcWork.right - rc.right, 0);
2259  			if (rc.bottom > rcWork.bottom)
2260  				rc.Move(0, rcWork.bottom - rc.bottom);
2261  			if (rc.left < rcWork.left)
2262  				rc.Move(rcWork.left - rc.left, 0);
2263  			if (rc.top < rcWork.top)
2264  				rc.Move(0, rcWork.top - rc.top);
2265  		}
2266  	}
2267  	SetPosition(rc);
2268  }
2269  PRectangle Window::GetClientPosition() const {
2270  	RECT rc={0,0,0,0};
2271  	if (wid)
2272  		::GetClientRect(HwndFromWindowID(wid), &rc);
2273  	return PRectangle::FromInts(rc.left, rc.top, rc.right, rc.bottom);
2274  }
2275  void Window::Show(bool show) {
2276  	if (show)
2277  		::ShowWindow(HwndFromWindowID(wid), SW_SHOWNOACTIVATE);
2278  	else
2279  		::ShowWindow(HwndFromWindowID(wid), SW_HIDE);
2280  }
2281  void Window::InvalidateAll() {
2282  	::InvalidateRect(HwndFromWindowID(wid), nullptr, FALSE);
2283  }
2284  void Window::InvalidateRectangle(PRectangle rc) {
2285  	const RECT rcw = RectFromPRectangle(rc);
2286  	::InvalidateRect(HwndFromWindowID(wid), &rcw, FALSE);
2287  }
2288  namespace {
2289  void FlipBitmap(HBITMAP bitmap, int width, int height) noexcept {
2290  	HDC hdc = ::CreateCompatibleDC({});
2291  	if (hdc) {
2292  		HBITMAP prevBmp = SelectBitmap(hdc, bitmap);
2293  		::StretchBlt(hdc, width - 1, 0, -width, height, hdc, 0, 0, width, height, SRCCOPY);
2294  		SelectBitmap(hdc, prevBmp);
2295  		::DeleteDC(hdc);
2296  	}
2297  }
2298  }
2299  HCURSOR LoadReverseArrowCursor(UINT dpi) noexcept {
2300  	HCURSOR reverseArrowCursor {};
2301  	bool created = false;
2302  	HCURSOR cursor = ::LoadCursor({}, IDC_ARROW);
2303  	if (dpi != uSystemDPI) {
2304  		const int width = SystemMetricsForDpi(SM_CXCURSOR, dpi);
2305  		const int height = SystemMetricsForDpi(SM_CYCURSOR, dpi);
2306  		HCURSOR copy = static_cast<HCURSOR>(::CopyImage(cursor, IMAGE_CURSOR, width, height, LR_COPYFROMRESOURCE | LR_COPYRETURNORG));
2307  		if (copy) {
2308  			created = copy != cursor;
2309  			cursor = copy;
2310  		}
2311  	}
2312  	ICONINFO info;
2313  	if (::GetIconInfo(cursor, &info)) {
2314  		BITMAP bmp {};
2315  		if (::GetObject(info.hbmMask, sizeof(bmp), &bmp)) {
2316  			FlipBitmap(info.hbmMask, bmp.bmWidth, bmp.bmHeight);
2317  			if (info.hbmColor)
2318  				FlipBitmap(info.hbmColor, bmp.bmWidth, bmp.bmHeight);
2319  			info.xHotspot = bmp.bmWidth - 1 - info.xHotspot;
2320  			reverseArrowCursor = ::CreateIconIndirect(&info);
2321  		}
2322  		::DeleteObject(info.hbmMask);
2323  		if (info.hbmColor)
2324  			::DeleteObject(info.hbmColor);
2325  	}
2326  	if (created) {
2327  		::DestroyCursor(cursor);
2328  	}
2329  	return reverseArrowCursor;
2330  }
2331  void Window::SetCursor(Cursor curs) {
2332  	switch (curs) {
2333  	case Cursor::text:
2334  		::SetCursor(::LoadCursor(NULL,IDC_IBEAM));
2335  		break;
2336  	case Cursor::up:
2337  		::SetCursor(::LoadCursor(NULL,IDC_UPARROW));
2338  		break;
2339  	case Cursor::wait:
2340  		::SetCursor(::LoadCursor(NULL,IDC_WAIT));
2341  		break;
2342  	case Cursor::horizontal:
2343  		::SetCursor(::LoadCursor(NULL,IDC_SIZEWE));
2344  		break;
2345  	case Cursor::vertical:
2346  		::SetCursor(::LoadCursor(NULL,IDC_SIZENS));
2347  		break;
2348  	case Cursor::hand:
2349  		::SetCursor(::LoadCursor(NULL,IDC_HAND));
2350  		break;
2351  	case Cursor::reverseArrow:
2352  	case Cursor::arrow:
2353  	case Cursor::invalid:	
2354  		::SetCursor(::LoadCursor(NULL,IDC_ARROW));
2355  		break;
2356  	}
2357  }
2358  PRectangle Window::GetMonitorRect(Point pt) {
2359  	const PRectangle rcPosition = GetPosition();
2360  	const POINT ptDesktop = {static_cast<LONG>(pt.x + rcPosition.left),
2361  		static_cast<LONG>(pt.y + rcPosition.top)};
2362  	HMONITOR hMonitor = MonitorFromPoint(ptDesktop, MONITOR_DEFAULTTONEAREST);
2363  	const RECT rcWork = RectFromMonitor(hMonitor);
2364  	if (rcWork.left < rcWork.right) {
2365  		PRectangle rcMonitor(
2366  			rcWork.left - rcPosition.left,
2367  			rcWork.top - rcPosition.top,
2368  			rcWork.right - rcPosition.left,
2369  			rcWork.bottom - rcPosition.top);
2370  		return rcMonitor;
2371  	} else {
2372  		return PRectangle();
2373  	}
2374  }
2375  struct ListItemData {
2376  	const char *text;
2377  	int pixId;
2378  };
2379  class LineToItem {
2380  	std::vector<char> words;
2381  	std::vector<ListItemData> data;
2382  public:
2383  	void Clear() noexcept {
2384  		words.clear();
2385  		data.clear();
2386  	}
2387  	ListItemData Get(size_t index) const noexcept {
2388  		if (index < data.size()) {
2389  			return data[index];
2390  		} else {
2391  			ListItemData missing = {"", -1};
2392  			return missing;
2393  		}
2394  	}
2395  	int Count() const noexcept {
2396  		return static_cast<int>(data.size());
2397  	}
2398  	void AllocItem(const char *text, int pixId) {
2399  		const ListItemData lid = { text, pixId };
2400  		data.push_back(lid);
2401  	}
2402  	char *SetWords(const char *s) {
2403  		words = std::vector<char>(s, s+strlen(s)+1);
2404  		return &words[0];
2405  	}
2406  };
2407  const TCHAR ListBoxX_ClassName[] = TEXT("ListBoxX");
2408  ListBox::ListBox() noexcept {
2409  }
2410  ListBox::~ListBox() noexcept {
2411  }
2412  class ListBoxX : public ListBox {
2413  	int lineHeight;
2414  	HFONT fontCopy;
2415  	Technology technology;
2416  	RGBAImageSet images;
2417  	LineToItem lti;
2418  	HWND lb;
2419  	bool unicodeMode;
2420  	int desiredVisibleRows;
2421  	unsigned int maxItemCharacters;
2422  	unsigned int aveCharWidth;
2423  	Window *parent;
2424  	int ctrlID;
2425  	UINT dpi;
2426  	IListBoxDelegate *delegate;
2427  	const char *widestItem;
2428  	unsigned int maxCharWidth;
2429  	WPARAM resizeHit;
2430  	PRectangle rcPreSize;
2431  	Point dragOffset;
2432  	Point location;	
2433  	MouseWheelDelta wheelDelta;
2434  	ListOptions options;
2435  	DWORD frameStyle = WS_THICKFRAME;
2436  	HWND GetHWND() const noexcept;
2437  	void AppendListItem(const char *text, const char *numword);
2438  	void AdjustWindowRect(PRectangle *rc, UINT dpiAdjust) const noexcept;
2439  	int ItemHeight() const;
2440  	int MinClientWidth() const noexcept;
2441  	int TextOffset() const;
2442  	POINT GetClientExtent() const noexcept;
2443  	POINT MinTrackSize() const;
2444  	POINT MaxTrackSize() const;
2445  	void SetRedraw(bool on) noexcept;
2446  	void OnDoubleClick();
2447  	void OnSelChange();
2448  	void ResizeToCursor();
2449  	void StartResize(WPARAM);
2450  	LRESULT NcHitTest(WPARAM, LPARAM) const;
2451  	void CentreItem(int n);
2452  	void Paint(HDC);
2453  	static LRESULT PASCAL ControlWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
2454  	static constexpr Point ItemInset {0, 0};	
2455  	static constexpr Point TextInset {2, 0};	
2456  	static constexpr Point ImageInset {1, 0};	
2457  public:
2458  	ListBoxX() : lineHeight(10), fontCopy{}, technology(Technology::Default), lb{}, unicodeMode(false),
2459  		desiredVisibleRows(9), maxItemCharacters(0), aveCharWidth(8),
2460  		parent(nullptr), ctrlID(0), dpi(USER_DEFAULT_SCREEN_DPI),
2461  		delegate(nullptr),
2462  		widestItem(nullptr), maxCharWidth(1), resizeHit(0) {
2463  	}
2464  	ListBoxX(const ListBoxX &) = delete;
2465  	ListBoxX(ListBoxX &&) = delete;
2466  	ListBoxX &operator=(const ListBoxX &) = delete;
2467  	ListBoxX &operator=(ListBoxX &&) = delete;
2468  	~ListBoxX() noexcept override {
2469  		if (fontCopy) {
2470  			::DeleteObject(fontCopy);
2471  			fontCopy = 0;
2472  		}
2473  	}
2474  	void SetFont(const Font *font) override;
2475  	void Create(Window &parent_, int ctrlID_, Point location_, int lineHeight_, bool unicodeMode_, Technology technology_) override;
2476  	void SetAverageCharWidth(int width) override;
2477  	void SetVisibleRows(int rows) override;
2478  	int GetVisibleRows() const override;
2479  	PRectangle GetDesiredRect() override;
2480  	int CaretFromEdge() override;
2481  	void Clear() noexcept override;
2482  	void Append(char *s, int type = -1) override;
2483  	int Length() override;
2484  	void Select(int n) override;
2485  	int GetSelection() override;
2486  	int Find(const char *prefix) override;
2487  	std::string GetValue(int n) override;
2488  	void RegisterImage(int type, const char *xpm_data) override;
2489  	void RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage) override;
2490  	void ClearRegisteredImages() override;
2491  	void SetDelegate(IListBoxDelegate *lbDelegate) override;
2492  	void SetList(const char *list, char separator, char typesep) override;
2493  	void SetOptions(ListOptions options_) override;
2494  	void Draw(DRAWITEMSTRUCT *pDrawItem);
2495  	LRESULT WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
2496  	static LRESULT PASCAL StaticWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
2497  };
2498  std::unique_ptr<ListBox> ListBox::Allocate() {
2499  	return std::make_unique<ListBoxX>();
2500  }
2501  void ListBoxX::Create(Window &parent_, int ctrlID_, Point location_, int lineHeight_, bool unicodeMode_, Technology technology_) {
2502  	parent = &parent_;
2503  	ctrlID = ctrlID_;
2504  	location = location_;
2505  	lineHeight = lineHeight_;
2506  	unicodeMode = unicodeMode_;
2507  	technology = technology_;
2508  	HWND hwndParent = HwndFromWindow(*parent);
2509  	HINSTANCE hinstanceParent = GetWindowInstance(hwndParent);
2510  	wid = ::CreateWindowEx(
2511  		WS_EX_WINDOWEDGE, ListBoxX_ClassName, TEXT(""),
2512  		WS_POPUP | frameStyle,
2513  		100,100, 150,80, hwndParent,
2514  		NULL,
2515  		hinstanceParent,
2516  		this);
2517  	dpi = DpiForWindow(hwndParent);
2518  	POINT locationw = POINTFromPoint(location);
2519  	::MapWindowPoints(hwndParent, NULL, &locationw, 1);
2520  	location = PointFromPOINT(locationw);
2521  }
2522  void ListBoxX::SetFont(const Font *font) {
2523  	const FontWin *pfm = dynamic_cast<const FontWin *>(font);
2524  	if (pfm) {
2525  		if (fontCopy) {
2526  			::DeleteObject(fontCopy);
2527  			fontCopy = 0;
2528  		}
2529  		fontCopy = pfm->HFont();
2530  		SetWindowFont(lb, fontCopy, 0);
2531  	}
2532  }
2533  void ListBoxX::SetAverageCharWidth(int width) {
2534  	aveCharWidth = width;
2535  }
2536  void ListBoxX::SetVisibleRows(int rows) {
2537  	desiredVisibleRows = rows;
2538  }
2539  int ListBoxX::GetVisibleRows() const {
2540  	return desiredVisibleRows;
2541  }
2542  HWND ListBoxX::GetHWND() const noexcept {
2543  	return HwndFromWindowID(GetID());
2544  }
2545  PRectangle ListBoxX::GetDesiredRect() {
2546  	PRectangle rcDesired = GetPosition();
2547  	int rows = Length();
2548  	if ((rows == 0) || (rows > desiredVisibleRows))
2549  		rows = desiredVisibleRows;
2550  	rcDesired.bottom = rcDesired.top + ItemHeight() * rows;
2551  	int width = MinClientWidth();
2552  	HDC hdc = ::GetDC(lb);
2553  	HFONT oldFont = SelectFont(hdc, fontCopy);
2554  	SIZE textSize = {0, 0};
2555  	int len = 0;
2556  	if (widestItem) {
2557  		len = static_cast<int>(strlen(widestItem));
2558  		if (unicodeMode) {
2559  			const TextWide tbuf(widestItem, CpUtf8);
2560  			::GetTextExtentPoint32W(hdc, tbuf.buffer, tbuf.tlen, &textSize);
2561  		} else {
2562  			::GetTextExtentPoint32A(hdc, widestItem, len, &textSize);
2563  		}
2564  	}
2565  	TEXTMETRIC tm;
2566  	::GetTextMetrics(hdc, &tm);
2567  	maxCharWidth = tm.tmMaxCharWidth;
2568  	SelectFont(hdc, oldFont);
2569  	::ReleaseDC(lb, hdc);
2570  	const int widthDesired = std::max(textSize.cx, (len + 1) * tm.tmAveCharWidth);
2571  	if (width < widthDesired)
2572  		width = widthDesired;
2573  	rcDesired.right = rcDesired.left + TextOffset() + width + (TextInset.x * 2);
2574  	if (Length() > rows)
2575  		rcDesired.right += SystemMetricsForDpi(SM_CXVSCROLL, dpi);
2576  	AdjustWindowRect(&rcDesired, dpi);
2577  	return rcDesired;
2578  }
2579  int ListBoxX::TextOffset() const {
2580  	const int pixWidth = images.GetWidth();
2581  	return static_cast<int>(pixWidth == 0 ? ItemInset.x : ItemInset.x + pixWidth + (ImageInset.x * 2));
2582  }
2583  int ListBoxX::CaretFromEdge() {
2584  	PRectangle rc;
2585  	AdjustWindowRect(&rc, dpi);
2586  	return TextOffset() + static_cast<int>(TextInset.x + (0 - rc.left) - 1);
2587  }
2588  void ListBoxX::Clear() noexcept {
2589  	ListBox_ResetContent(lb);
2590  	maxItemCharacters = 0;
2591  	widestItem = nullptr;
2592  	lti.Clear();
2593  }
2594  void ListBoxX::Append(char *, int) {
2595  	PLATFORM_ASSERT(false);
2596  }
2597  int ListBoxX::Length() {
2598  	return lti.Count();
2599  }
2600  void ListBoxX::Select(int n) {
2601  	SetRedraw(false);
2602  	CentreItem(n);
2603  	ListBox_SetCurSel(lb, n);
2604  	OnSelChange();
2605  	SetRedraw(true);
2606  }
2607  int ListBoxX::GetSelection() {
2608  	return ListBox_GetCurSel(lb);
2609  }
2610  int ListBoxX::Find(const char *) {
2611  	return LB_ERR;
2612  }
2613  std::string ListBoxX::GetValue(int n) {
2614  	const ListItemData item = lti.Get(n);
2615  	return item.text;
2616  }
2617  void ListBoxX::RegisterImage(int type, const char *xpm_data) {
2618  	XPM xpmImage(xpm_data);
2619  	images.AddImage(type, std::make_unique<RGBAImage>(xpmImage));
2620  }
2621  void ListBoxX::RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage) {
2622  	images.AddImage(type, std::make_unique<RGBAImage>(width, height, 1.0f, pixelsImage));
2623  }
2624  void ListBoxX::ClearRegisteredImages() {
2625  	images.Clear();
2626  }
2627  namespace {
2628  int ColourOfElement(std::optional<ColourRGBA> colour, int nIndex) {
2629  	if (colour.has_value()) {
2630  		return colour.value().OpaqueRGB();
2631  	} else {
2632  		return ::GetSysColor(nIndex);
2633  	}
2634  }
2635  void FillRectColour(HDC hdc, const RECT *lprc, int colour) noexcept {
2636  	const HBRUSH brush = ::CreateSolidBrush(colour);
2637  	::FillRect(hdc, lprc, brush);
2638  	::DeleteObject(brush);
2639  }
2640  }
2641  void ListBoxX::Draw(DRAWITEMSTRUCT *pDrawItem) {
2642  	if ((pDrawItem->itemAction == ODA_SELECT) || (pDrawItem->itemAction == ODA_DRAWENTIRE)) {
2643  		RECT rcBox = pDrawItem->rcItem;
2644  		rcBox.left += TextOffset();
2645  		if (pDrawItem->itemState & ODS_SELECTED) {
2646  			RECT rcImage = pDrawItem->rcItem;
2647  			rcImage.right = rcBox.left;
2648  			FillRectColour(pDrawItem->hDC, &rcImage, ColourOfElement(options.back, COLOR_WINDOW));
2649  			FillRectColour(pDrawItem->hDC, &rcBox, ColourOfElement(options.backSelected, COLOR_HIGHLIGHT));
2650  			::SetBkColor(pDrawItem->hDC, ColourOfElement(options.backSelected, COLOR_HIGHLIGHT));
2651  			::SetTextColor(pDrawItem->hDC, ColourOfElement(options.foreSelected, COLOR_HIGHLIGHTTEXT));
2652  		} else {
2653  			FillRectColour(pDrawItem->hDC, &pDrawItem->rcItem, ColourOfElement(options.back, COLOR_WINDOW));
2654  			::SetBkColor(pDrawItem->hDC, ColourOfElement(options.back, COLOR_WINDOW));
2655  			::SetTextColor(pDrawItem->hDC, ColourOfElement(options.fore, COLOR_WINDOWTEXT));
2656  		}
2657  		const ListItemData item = lti.Get(pDrawItem->itemID);
2658  		const int pixId = item.pixId;
2659  		const char *text = item.text;
2660  		const int len = static_cast<int>(strlen(text));
2661  		RECT rcText = rcBox;
2662  		::InsetRect(&rcText, static_cast<int>(TextInset.x), static_cast<int>(TextInset.y));
2663  		if (unicodeMode) {
2664  			const TextWide tbuf(text, CpUtf8);
2665  			::DrawTextW(pDrawItem->hDC, tbuf.buffer, tbuf.tlen, &rcText, DT_NOPREFIX|DT_END_ELLIPSIS|DT_SINGLELINE|DT_NOCLIP);
2666  		} else {
2667  			::DrawTextA(pDrawItem->hDC, text, len, &rcText, DT_NOPREFIX|DT_END_ELLIPSIS|DT_SINGLELINE|DT_NOCLIP);
2668  		}
2669  		const RGBAImage *pimage = images.Get(pixId);
2670  		if (pimage) {
2671  			std::unique_ptr<Surface> surfaceItem(Surface::Allocate(technology));
2672  			if (technology == Technology::Default) {
2673  				surfaceItem->Init(pDrawItem->hDC, pDrawItem->hwndItem);
2674  				const long left = pDrawItem->rcItem.left + static_cast<int>(ItemInset.x + ImageInset.x);
2675  				const PRectangle rcImage = PRectangle::FromInts(left, pDrawItem->rcItem.top,
2676  					left + images.GetWidth(), pDrawItem->rcItem.bottom);
2677  				surfaceItem->DrawRGBAImage(rcImage,
2678  					pimage->GetWidth(), pimage->GetHeight(), pimage->Pixels());
2679  				::SetTextAlign(pDrawItem->hDC, TA_TOP);
2680  			} else {
2681  #if defined(USE_D2D)
2682  				const D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(
2683  					D2D1_RENDER_TARGET_TYPE_DEFAULT,
2684  					D2D1::PixelFormat(
2685  						DXGI_FORMAT_B8G8R8A8_UNORM,
2686  						D2D1_ALPHA_MODE_IGNORE),
2687  					0,
2688  					0,
2689  					D2D1_RENDER_TARGET_USAGE_NONE,
2690  					D2D1_FEATURE_LEVEL_DEFAULT
2691  					);
2692  				ID2D1DCRenderTarget *pDCRT = nullptr;
2693  				HRESULT hr = pD2DFactory->CreateDCRenderTarget(&props, &pDCRT);
2694  				if (SUCCEEDED(hr) && pDCRT) {
2695  					const long left = pDrawItem->rcItem.left + static_cast<long>(ItemInset.x + ImageInset.x);
2696  					RECT rcItem = pDrawItem->rcItem;
2697  					rcItem.left = left;
2698  					rcItem.right = rcItem.left + images.GetWidth();
2699  					hr = pDCRT->BindDC(pDrawItem->hDC, &rcItem);
2700  					if (SUCCEEDED(hr)) {
2701  						surfaceItem->Init(pDCRT, pDrawItem->hwndItem);
2702  						pDCRT->BeginDraw();
2703  						const PRectangle rcImage = PRectangle::FromInts(0, 0, images.GetWidth(), rcItem.bottom - rcItem.top);
2704  						surfaceItem->DrawRGBAImage(rcImage,
2705  							pimage->GetWidth(), pimage->GetHeight(), pimage->Pixels());
2706  						pDCRT->EndDraw();
2707  						ReleaseUnknown(pDCRT);
2708  					}
2709  				}
2710  #endif
2711  			}
2712  		}
2713  	}
2714  }
2715  void ListBoxX::AppendListItem(const char *text, const char *numword) {
2716  	int pixId = -1;
2717  	if (numword) {
2718  		pixId = 0;
2719  		char ch;
2720  		while ((ch = *++numword) != '\0') {
2721  			pixId = 10 * pixId + (ch - '0');
2722  		}
2723  	}
2724  	lti.AllocItem(text, pixId);
2725  	const unsigned int len = static_cast<unsigned int>(strlen(text));
2726  	if (maxItemCharacters < len) {
2727  		maxItemCharacters = len;
2728  		widestItem = text;
2729  	}
2730  }
2731  void ListBoxX::SetDelegate(IListBoxDelegate *lbDelegate) {
2732  	delegate = lbDelegate;
2733  }
2734  void ListBoxX::SetList(const char *list, char separator, char typesep) {
2735  	SetRedraw(false);
2736  	Clear();
2737  	const size_t size = strlen(list);
2738  	char *words = lti.SetWords(list);
2739  	char *startword = words;
2740  	char *numword = nullptr;
2741  	for (size_t i=0; i < size; i++) {
2742  		if (words[i] == separator) {
2743  			words[i] = '\0';
2744  			if (numword)
2745  				*numword = '\0';
2746  			AppendListItem(startword, numword);
2747  			startword = words + i + 1;
2748  			numword = nullptr;
2749  		} else if (words[i] == typesep) {
2750  			numword = words + i;
2751  		}
2752  	}
2753  	if (startword) {
2754  		if (numword)
2755  			*numword = '\0';
2756  		AppendListItem(startword, numword);
2757  	}
2758  	const int count = lti.Count();
2759  	::SendMessage(lb, LB_INITSTORAGE, count, 0);
2760  	for (intptr_t j=0; j<count; j++) {
2761  		ListBox_AddItemData(lb, j+1);
2762  	}
2763  	SetRedraw(true);
2764  }
2765  void ListBoxX::SetOptions(ListOptions options_) {
2766  	options = options_;
2767  	frameStyle = FlagSet(options.options, AutoCompleteOption::FixedSize) ? WS_BORDER : WS_THICKFRAME;
2768  }
2769  void ListBoxX::AdjustWindowRect(PRectangle *rc, UINT dpiAdjust) const noexcept {
2770  	RECT rcw = RectFromPRectangle(*rc);
2771  	if (fnAdjustWindowRectExForDpi) {
2772  		fnAdjustWindowRectExForDpi(&rcw, frameStyle, false, WS_EX_WINDOWEDGE, dpiAdjust);
2773  	} else {
2774  		::AdjustWindowRectEx(&rcw, frameStyle, false, WS_EX_WINDOWEDGE);
2775  	}
2776  	*rc = PRectangle::FromInts(rcw.left, rcw.top, rcw.right, rcw.bottom);
2777  }
2778  int ListBoxX::ItemHeight() const {
2779  	int itemHeight = lineHeight + (static_cast<int>(TextInset.y) * 2);
2780  	const int pixHeight = images.GetHeight() + (static_cast<int>(ImageInset.y) * 2);
2781  	if (itemHeight < pixHeight) {
2782  		itemHeight = pixHeight;
2783  	}
2784  	return itemHeight;
2785  }
2786  int ListBoxX::MinClientWidth() const noexcept {
2787  	return 12 * (aveCharWidth+aveCharWidth/3);
2788  }
2789  POINT ListBoxX::MinTrackSize() const {
2790  	PRectangle rc = PRectangle::FromInts(0, 0, MinClientWidth(), ItemHeight());
2791  	AdjustWindowRect(&rc, dpi);
2792  	POINT ret = {static_cast<LONG>(rc.Width()), static_cast<LONG>(rc.Height())};
2793  	return ret;
2794  }
2795  POINT ListBoxX::MaxTrackSize() const {
2796  	PRectangle rc = PRectangle::FromInts(0, 0,
2797  		std::max(static_cast<unsigned int>(MinClientWidth()),
2798  		maxCharWidth * maxItemCharacters + static_cast<int>(TextInset.x) * 2 +
2799  		 TextOffset() + SystemMetricsForDpi(SM_CXVSCROLL, dpi)),
2800  		ItemHeight() * lti.Count());
2801  	AdjustWindowRect(&rc, dpi);
2802  	POINT ret = {static_cast<LONG>(rc.Width()), static_cast<LONG>(rc.Height())};
2803  	return ret;
2804  }
2805  void ListBoxX::SetRedraw(bool on) noexcept {
2806  	::SendMessage(lb, WM_SETREDRAW, on, 0);
2807  	if (on)
2808  		::InvalidateRect(lb, nullptr, TRUE);
2809  }
2810  void ListBoxX::ResizeToCursor() {
2811  	PRectangle rc = GetPosition();
2812  	POINT ptw;
2813  	::GetCursorPos(&ptw);
2814  	const Point pt = PointFromPOINT(ptw) + dragOffset;
2815  	switch (resizeHit) {
2816  		case HTLEFT:
2817  			rc.left = pt.x;
2818  			break;
2819  		case HTRIGHT:
2820  			rc.right = pt.x;
2821  			break;
2822  		case HTTOP:
2823  			rc.top = pt.y;
2824  			break;
2825  		case HTTOPLEFT:
2826  			rc.top = pt.y;
2827  			rc.left = pt.x;
2828  			break;
2829  		case HTTOPRIGHT:
2830  			rc.top = pt.y;
2831  			rc.right = pt.x;
2832  			break;
2833  		case HTBOTTOM:
2834  			rc.bottom = pt.y;
2835  			break;
2836  		case HTBOTTOMLEFT:
2837  			rc.bottom = pt.y;
2838  			rc.left = pt.x;
2839  			break;
2840  		case HTBOTTOMRIGHT:
2841  			rc.bottom = pt.y;
2842  			rc.right = pt.x;
2843  			break;
2844  		default:
2845  			break;
2846  	}
2847  	const POINT ptMin = MinTrackSize();
2848  	const POINT ptMax = MaxTrackSize();
2849  	rc.left = std::clamp(rc.left, rcPreSize.right - ptMax.x, rcPreSize.right - ptMin.x);
2850  	rc.top = std::clamp(rc.top, rcPreSize.bottom - ptMax.y, rcPreSize.bottom - ptMin.y);
2851  	rc.right = std::clamp(rc.right, rcPreSize.left + ptMin.x, rcPreSize.left + ptMax.x);
2852  	rc.bottom = std::clamp(rc.bottom, rcPreSize.top + ptMin.y, rcPreSize.top + ptMax.y);
2853  	SetPosition(rc);
2854  }
2855  void ListBoxX::StartResize(WPARAM hitCode) {
2856  	rcPreSize = GetPosition();
2857  	POINT cursorPos;
2858  	::GetCursorPos(&cursorPos);
2859  	switch (hitCode) {
2860  		case HTRIGHT:
2861  		case HTBOTTOM:
2862  		case HTBOTTOMRIGHT:
2863  			dragOffset.x = rcPreSize.right - cursorPos.x;
2864  			dragOffset.y = rcPreSize.bottom - cursorPos.y;
2865  			break;
2866  		case HTTOPRIGHT:
2867  			dragOffset.x = rcPreSize.right - cursorPos.x;
2868  			dragOffset.y = rcPreSize.top - cursorPos.y;
2869  			break;
2870  		case HTLEFT:
2871  		case HTTOP:
2872  		case HTTOPLEFT:
2873  			dragOffset.x = rcPreSize.left - cursorPos.x;
2874  			dragOffset.y = rcPreSize.top - cursorPos.y;
2875  			break;
2876  		case HTBOTTOMLEFT:
2877  			dragOffset.x = rcPreSize.left - cursorPos.x;
2878  			dragOffset.y = rcPreSize.bottom - cursorPos.y;
2879  			break;
2880  		default:
2881  			return;
2882  	}
2883  	::SetCapture(GetHWND());
2884  	resizeHit = hitCode;
2885  }
2886  LRESULT ListBoxX::NcHitTest(WPARAM wParam, LPARAM lParam) const {
2887  	const PRectangle rc = GetPosition();
2888  	LRESULT hit = ::DefWindowProc(GetHWND(), WM_NCHITTEST, wParam, lParam);
2889  	if (hit >= HTTOP && hit <= HTTOPRIGHT) {
2890  		const int minHeight = SystemMetricsForDpi(SM_CYMINTRACK, dpi);
2891  		const int yPos = GET_Y_LPARAM(lParam);
2892  		if ((rc.Height() < minHeight) && (yPos > ((rc.top + rc.bottom)/2))) {
2893  			hit += HTBOTTOM - HTTOP;
2894  		}
2895  	}
2896  	switch (hit) {
2897  		case HTLEFT:
2898  		case HTTOPLEFT:
2899  		case HTBOTTOMLEFT:
2900  			hit = HTERROR;
2901  			break;
2902  		case HTTOP:
2903  		case HTTOPRIGHT: {
2904  				if (location.y < rc.top)
2905  					hit = HTERROR;
2906  			}
2907  			break;
2908  		case HTBOTTOM:
2909  		case HTBOTTOMRIGHT: {
2910  				if (rc.bottom <= location.y)
2911  					hit = HTERROR;
2912  			}
2913  			break;
2914  		default:
2915  			break;
2916  	}
2917  	return hit;
2918  }
2919  void ListBoxX::OnDoubleClick() {
2920  	if (delegate) {
2921  		ListBoxEvent event(ListBoxEvent::EventType::doubleClick);
2922  		delegate->ListNotify(&event);
2923  	}
2924  }
2925  void ListBoxX::OnSelChange() {
2926  	if (delegate) {
2927  		ListBoxEvent event(ListBoxEvent::EventType::selectionChange);
2928  		delegate->ListNotify(&event);
2929  	}
2930  }
2931  POINT ListBoxX::GetClientExtent() const noexcept {
2932  	RECT rc;
2933  	::GetWindowRect(HwndFromWindowID(wid), &rc);
2934  	POINT ret { rc.right - rc.left, rc.bottom - rc.top };
2935  	return ret;
2936  }
2937  void ListBoxX::CentreItem(int n) {
2938  	if (n >= 0) {
2939  		const POINT extent = GetClientExtent();
2940  		const int visible = extent.y/ItemHeight();
2941  		if (visible < Length()) {
2942  			const int top = ListBox_GetTopIndex(lb);
2943  			const int half = (visible - 1) / 2;
2944  			if (n > (top + half))
2945  				ListBox_SetTopIndex(lb, n - half);
2946  		}
2947  	}
2948  }
2949  void ListBoxX::Paint(HDC hDC) {
2950  	const POINT extent = GetClientExtent();
2951  	HBITMAP hBitmap = ::CreateCompatibleBitmap(hDC, extent.x, extent.y);
2952  	HDC bitmapDC = ::CreateCompatibleDC(hDC);
2953  	HBITMAP hBitmapOld = SelectBitmap(bitmapDC, hBitmap);
2954  	const RECT rc = { 0, 0, extent.x, extent.y };
2955  	FillRectColour(bitmapDC, &rc, ColourOfElement(options.back, COLOR_WINDOWTEXT));
2956  	::SendMessage(lb, WM_PRINT, reinterpret_cast<WPARAM>(bitmapDC), PRF_CLIENT|PRF_NONCLIENT);
2957  	::BitBlt(hDC, 0, 0, extent.x, extent.y, bitmapDC, 0, 0, SRCCOPY);
2958  	SelectBrush(bitmapDC, GetStockBrush(WHITE_BRUSH));
2959  	SelectBitmap(bitmapDC, hBitmapOld);
2960  	::DeleteDC(bitmapDC);
2961  	::DeleteObject(hBitmap);
2962  }
2963  LRESULT PASCAL ListBoxX::ControlWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
2964  	try {
2965  		ListBoxX *lbx = static_cast<ListBoxX *>(PointerFromWindow(::GetParent(hWnd)));
2966  		switch (iMessage) {
2967  		case WM_ERASEBKGND:
2968  			return TRUE;
2969  		case WM_PAINT: {
2970  				PAINTSTRUCT ps;
2971  				HDC hDC = ::BeginPaint(hWnd, &ps);
2972  				if (lbx) {
2973  					lbx->Paint(hDC);
2974  				}
2975  				::EndPaint(hWnd, &ps);
2976  			}
2977  			return 0;
2978  		case WM_MOUSEACTIVATE:
2979  			return MA_NOACTIVATE;
2980  		case WM_LBUTTONDOWN: {
2981  				const LRESULT lResult = ::SendMessage(hWnd, LB_ITEMFROMPOINT, 0, lParam);
2982  				if (HIWORD(lResult) == 0) {
2983  					ListBox_SetCurSel(hWnd, LOWORD(lResult));
2984  					if (lbx) {
2985  						lbx->OnSelChange();
2986  					}
2987  				}
2988  			}
2989  			return 0;
2990  		case WM_LBUTTONUP:
2991  			return 0;
2992  		case WM_LBUTTONDBLCLK: {
2993  				if (lbx) {
2994  					lbx->OnDoubleClick();
2995  				}
2996  			}
2997  			return 0;
2998  		case WM_MBUTTONDOWN:
2999  			return 0;
3000  		default:
3001  			break;
3002  		}
3003  		WNDPROC prevWndProc = reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_USERDATA));
3004  		if (prevWndProc) {
3005  			return ::CallWindowProc(prevWndProc, hWnd, iMessage, wParam, lParam);
3006  		} else {
3007  			return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3008  		}
3009  	} catch (...) {
3010  	}
3011  	return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3012  }
3013  LRESULT ListBoxX::WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
3014  	switch (iMessage) {
3015  	case WM_CREATE: {
3016  			HINSTANCE hinstanceParent = GetWindowInstance(HwndFromWindow(*parent));
3017  			lb = ::CreateWindowEx(
3018  				0, TEXT("listbox"), TEXT(""),
3019  				WS_CHILD | WS_VSCROLL | WS_VISIBLE |
3020  				LBS_OWNERDRAWFIXED | LBS_NODATA | LBS_NOINTEGRALHEIGHT,
3021  				0, 0, 150,80, hWnd,
3022  				reinterpret_cast<HMENU>(static_cast<ptrdiff_t>(ctrlID)),
3023  				hinstanceParent,
3024  				0);
3025  			WNDPROC prevWndProc = SubclassWindow(lb, ControlWndProc);
3026  			::SetWindowLongPtr(lb, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(prevWndProc));
3027  		}
3028  		break;
3029  	case WM_SIZE:
3030  		if (lb) {
3031  			SetRedraw(false);
3032  			::SetWindowPos(lb, 0, 0,0, LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE);
3033  			CentreItem(GetSelection());
3034  			SetRedraw(true);
3035  		}
3036  		break;
3037  	case WM_PAINT: {
3038  			PAINTSTRUCT ps;
3039  			::BeginPaint(hWnd, &ps);
3040  			::EndPaint(hWnd, &ps);
3041  		}
3042  		break;
3043  	case WM_COMMAND:
3044  		::SendMessage(HwndFromWindow(*parent), iMessage, wParam, lParam);
3045  		break;
3046  	case WM_MEASUREITEM: {
3047  			MEASUREITEMSTRUCT *pMeasureItem = reinterpret_cast<MEASUREITEMSTRUCT *>(lParam);
3048  			pMeasureItem->itemHeight = ItemHeight();
3049  		}
3050  		break;
3051  	case WM_DRAWITEM:
3052  		Draw(reinterpret_cast<DRAWITEMSTRUCT *>(lParam));
3053  		break;
3054  	case WM_DESTROY:
3055  		lb = 0;
3056  		SetWindowPointer(hWnd, nullptr);
3057  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3058  	case WM_ERASEBKGND:
3059  		return TRUE;
3060  	case WM_GETMINMAXINFO: {
3061  			MINMAXINFO *minMax = reinterpret_cast<MINMAXINFO*>(lParam);
3062  			minMax->ptMaxTrackSize = MaxTrackSize();
3063  			minMax->ptMinTrackSize = MinTrackSize();
3064  		}
3065  		break;
3066  	case WM_MOUSEACTIVATE:
3067  		return MA_NOACTIVATE;
3068  	case WM_NCHITTEST:
3069  		return NcHitTest(wParam, lParam);
3070  	case WM_NCLBUTTONDOWN:
3071  		StartResize(wParam);
3072  		return 0;
3073  	case WM_MOUSEMOVE: {
3074  			if (resizeHit == 0) {
3075  				return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3076  			} else {
3077  				ResizeToCursor();
3078  			}
3079  		}
3080  		break;
3081  	case WM_LBUTTONUP:
3082  	case WM_CANCELMODE:
3083  		if (resizeHit != 0) {
3084  			resizeHit = 0;
3085  			::ReleaseCapture();
3086  		}
3087  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3088  	case WM_MOUSEWHEEL:
3089  		if (wheelDelta.Accumulate(wParam)) {
3090  			const int nRows = GetVisibleRows();
3091  			int linesToScroll = std::clamp(nRows - 1, 1, 3);
3092  			linesToScroll *= wheelDelta.Actions();
3093  			int top = ListBox_GetTopIndex(lb) + linesToScroll;
3094  			if (top < 0) {
3095  				top = 0;
3096  			}
3097  			ListBox_SetTopIndex(lb, top);
3098  		}
3099  		break;
3100  	default:
3101  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3102  	}
3103  	return 0;
3104  }
3105  LRESULT PASCAL ListBoxX::StaticWndProc(
3106      HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
3107  	if (iMessage == WM_CREATE) {
3108  		CREATESTRUCT *pCreate = reinterpret_cast<CREATESTRUCT *>(lParam);
3109  		SetWindowPointer(hWnd, pCreate->lpCreateParams);
3110  	}
3111  	ListBoxX *lbx = static_cast<ListBoxX *>(PointerFromWindow(hWnd));
3112  	if (lbx) {
3113  		return lbx->WndProc(hWnd, iMessage, wParam, lParam);
3114  	} else {
3115  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3116  	}
3117  }
3118  namespace {
3119  bool ListBoxX_Register() noexcept {
3120  	WNDCLASSEX wndclassc {};
3121  	wndclassc.cbSize = sizeof(wndclassc);
3122  	wndclassc.style = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
3123  	wndclassc.cbWndExtra = sizeof(ListBoxX *);
3124  	wndclassc.hInstance = hinstPlatformRes;
3125  	wndclassc.lpfnWndProc = ListBoxX::StaticWndProc;
3126  	wndclassc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
3127  	wndclassc.lpszClassName = ListBoxX_ClassName;
3128  	return ::RegisterClassEx(&wndclassc) != 0;
3129  }
3130  void ListBoxX_Unregister() noexcept {
3131  	if (hinstPlatformRes) {
3132  		::UnregisterClass(ListBoxX_ClassName, hinstPlatformRes);
3133  	}
3134  }
3135  }
3136  Menu::Menu() noexcept : mid{} {
3137  }
3138  void Menu::CreatePopUp() {
3139  	Destroy();
3140  	mid = ::CreatePopupMenu();
3141  }
3142  void Menu::Destroy() noexcept {
3143  	if (mid)
3144  		::DestroyMenu(static_cast<HMENU>(mid));
3145  	mid = 0;
3146  }
3147  void Menu::Show(Point pt, const Window &w) {
3148  	::TrackPopupMenu(static_cast<HMENU>(mid),
3149  		TPM_RIGHTBUTTON, static_cast<int>(pt.x - 4), static_cast<int>(pt.y), 0,
3150  		HwndFromWindow(w), nullptr);
3151  	Destroy();
3152  }
3153  ColourRGBA Platform::Chrome() {
3154  	return ColourRGBA::FromRGB(static_cast<int>(::GetSysColor(COLOR_3DFACE)));
3155  }
3156  ColourRGBA Platform::ChromeHighlight() {
3157  	return ColourRGBA::FromRGB(static_cast<int>(::GetSysColor(COLOR_3DHIGHLIGHT)));
3158  }
3159  const char *Platform::DefaultFont() {
3160  	return "Verdana";
3161  }
3162  int Platform::DefaultFontSize() {
3163  	return 8;
3164  }
3165  unsigned int Platform::DoubleClickTime() {
3166  	return ::GetDoubleClickTime();
3167  }
3168  void Platform::DebugDisplay(const char *s) noexcept {
3169  	::OutputDebugStringA(s);
3170  }
3171  #ifdef TRACE
3172  void Platform::DebugPrintf(const char *format, ...) noexcept {
3173  	char buffer[2000];
3174  	va_list pArguments;
3175  	va_start(pArguments, format);
3176  	vsnprintf(buffer, std::size(buffer), format, pArguments);
3177  	va_end(pArguments);
3178  	Platform::DebugDisplay(buffer);
3179  }
3180  #else
3181  void Platform::DebugPrintf(const char *, ...) noexcept {
3182  }
3183  #endif
3184  static bool assertionPopUps = true;
3185  bool Platform::ShowAssertionPopUps(bool assertionPopUps_) noexcept {
3186  	const bool ret = assertionPopUps;
3187  	assertionPopUps = assertionPopUps_;
3188  	return ret;
3189  }
3190  void Platform::Assert(const char *c, const char *file, int line) noexcept {
3191  	char buffer[2000] {};
3192  	snprintf(buffer, std::size(buffer), "Assertion [%s] failed at %s %d%s", c, file, line, assertionPopUps ? "" : "\r\n");
3193  	if (assertionPopUps) {
3194  		const int idButton = ::MessageBoxA(0, buffer, "Assertion failure",
3195  			MB_ABORTRETRYIGNORE|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);
3196  		if (idButton == IDRETRY) {
3197  			::DebugBreak();
3198  		} else if (idButton == IDIGNORE) {
3199  		} else {
3200  			abort();
3201  		}
3202  	} else {
3203  		Platform::DebugDisplay(buffer);
3204  		::DebugBreak();
3205  		abort();
3206  	}
3207  }
3208  void Platform_Initialise(void *hInstance) noexcept {
3209  	hinstPlatformRes = static_cast<HINSTANCE>(hInstance);
3210  	LoadDpiForWindow();
3211  	ListBoxX_Register();
3212  }
3213  void Platform_Finalise(bool fromDllMain) noexcept {
3214  #if defined(USE_D2D)
3215  	if (!fromDllMain) {
3216  		ReleaseUnknown(pIDWriteFactory);
3217  		ReleaseUnknown(pD2DFactory);
3218  		if (hDLLDWrite) {
3219  			FreeLibrary(hDLLDWrite);
3220  			hDLLDWrite = {};
3221  		}
3222  		if (hDLLD2D) {
3223  			FreeLibrary(hDLLD2D);
3224  			hDLLD2D = {};
3225  		}
3226  	}
3227  #endif
3228  	if (!fromDllMain && hDLLShcore) {
3229  		FreeLibrary(hDLLShcore);
3230  		hDLLShcore = {};
3231  	}
3232  	ListBoxX_Unregister();
3233  }
3234  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatWin.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatWin.cxx</div>
                </div>
                <div class="column column_space"><pre><code>1385  		D2DPenColourAlpha(fill.colour);
1386  		const D2D1_RECT_F rectangle = RectangleFromPRectangle(rc);
1387  		pRenderTarget->FillRectangle(&rectangle, pBrush);
</pre></code></div>
                <div class="column column_space"><pre><code>621  	BrushColour(stroke.colour);
622  	const RECT rcw = RectFromPRectangle(rc);
623  	::FrameRect(hdc, &rcw, brush);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    