
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 68, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexCmake.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static bool isCmakeNumber(char ch)
20  {
21      return(ch >= '0' && ch <= '9');
22  }
23  static bool isCmakeChar(char ch)
24  {
25      return(ch == '.' ) || (ch == '_' ) || isCmakeNumber(ch) || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
26  }
27  static bool isCmakeLetter(char ch)
28  {
29      return(ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
30  }
31  static bool CmakeNextLineHasElse(Sci_PositionU start, Sci_PositionU end, Accessor &styler)
32  {
33      Sci_Position nNextLine = -1;
34      for ( Sci_PositionU i = start; i < end; i++ ) {
35          char cNext = styler.SafeGetCharAt( i );
36          if ( cNext == '\n' ) {
37              nNextLine = i+1;
38              break;
39          }
40      }
41      if ( nNextLine == -1 ) 
42          return false;
43      for ( Sci_PositionU firstChar = nNextLine; firstChar < end; firstChar++ ) {
44          char cNext = styler.SafeGetCharAt( firstChar );
45          if ( cNext == ' ' )
46              continue;
47          if ( cNext == '\t' )
48              continue;
49          if ( styler.Match(firstChar, "ELSE")  || styler.Match(firstChar, "else"))
50              return true;
51          break;
52      }
53      return false;
54  }
55  static int calculateFoldCmake(Sci_PositionU start, Sci_PositionU end, int foldlevel, Accessor &styler, bool bElse)
56  {
57      if ( end - start > 20 )
58          return foldlevel;
59      int newFoldlevel = foldlevel;
60      char s[20]; 
61      for (unsigned int i = 0; i < end - start + 1 && i < 19; i++) {
62          s[i] = static_cast<char>( styler[ start + i ] );
63          s[i + 1] = '\0';
64      }
65      if ( CompareCaseInsensitive(s, "IF") == 0 || CompareCaseInsensitive(s, "WHILE") == 0
66           || CompareCaseInsensitive(s, "MACRO") == 0 || CompareCaseInsensitive(s, "FOREACH") == 0
67           || CompareCaseInsensitive(s, "FUNCTION") == 0)
68          newFoldlevel++;
69      else if ( CompareCaseInsensitive(s, "ENDIF") == 0 || CompareCaseInsensitive(s, "ENDWHILE") == 0
70                || CompareCaseInsensitive(s, "ENDMACRO") == 0 || CompareCaseInsensitive(s, "ENDFOREACH") == 0
71                || CompareCaseInsensitive(s, "ENDFUNCTION") == 0)
72          newFoldlevel--;
73      else if ( bElse && CompareCaseInsensitive(s, "ELSEIF") == 0 )
74          newFoldlevel++;
75      else if ( bElse && CompareCaseInsensitive(s, "ELSE") == 0 )
76          newFoldlevel++;
77      return newFoldlevel;
78  }
79  static int classifyWordCmake(Sci_PositionU start, Sci_PositionU end, WordList *keywordLists[], Accessor &styler )
80  {
81      char word[100] = {0};
82      char lowercaseWord[100] = {0};
83      WordList &Commands = *keywordLists[0];
84      WordList &Parameters = *keywordLists[1];
85      WordList &UserDefined = *keywordLists[2];
86      for (Sci_PositionU i = 0; i < end - start + 1 && i < 99; i++) {
87          word[i] = static_cast<char>( styler[ start + i ] );
88          lowercaseWord[i] = static_cast<char>(tolower(word[i]));
89      }
90      if ( CompareCaseInsensitive(word, "MACRO") == 0 || CompareCaseInsensitive(word, "ENDMACRO") == 0 )
91          return SCE_CMAKE_MACRODEF;
92      if ( CompareCaseInsensitive(word, "IF") == 0 ||  CompareCaseInsensitive(word, "ENDIF") == 0 )
93          return SCE_CMAKE_IFDEFINEDEF;
94      if ( CompareCaseInsensitive(word, "ELSEIF") == 0  || CompareCaseInsensitive(word, "ELSE") == 0 )
95          return SCE_CMAKE_IFDEFINEDEF;
96      if ( CompareCaseInsensitive(word, "WHILE") == 0 || CompareCaseInsensitive(word, "ENDWHILE") == 0)
97          return SCE_CMAKE_WHILEDEF;
98      if ( CompareCaseInsensitive(word, "FOREACH") == 0 || CompareCaseInsensitive(word, "ENDFOREACH") == 0)
99          return SCE_CMAKE_FOREACHDEF;
100      if ( Commands.InList(lowercaseWord) )
101          return SCE_CMAKE_COMMANDS;
102      if ( Parameters.InList(word) )
103          return SCE_CMAKE_PARAMETERS;
104      if ( UserDefined.InList(word) )
105          return SCE_CMAKE_USERDEFINED;
106      if ( strlen(word) > 3 ) {
107          if ( word[1] == '{' && word[strlen(word)-1] == '}' )
108              return SCE_CMAKE_VARIABLE;
109      }
110      if ( isCmakeNumber( word[0] ) ) {
111          bool bHasSimpleCmakeNumber = true;
112          for (unsigned int j = 1; j < end - start + 1 && j < 99; j++) {
113              if ( !isCmakeNumber( word[j] ) ) {
114                  bHasSimpleCmakeNumber = false;
115                  break;
116              }
117          }
118          if ( bHasSimpleCmakeNumber )
119              return SCE_CMAKE_NUMBER;
120      }
121      return SCE_CMAKE_DEFAULT;
122  }
123  static void ColouriseCmakeDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *keywordLists[], Accessor &styler)
124  {
125      int state = SCE_CMAKE_DEFAULT;
126      if ( startPos > 0 )
127          state = styler.StyleAt(startPos-1); 
128      styler.StartAt( startPos );
129      styler.GetLine( startPos );
130      Sci_PositionU nLengthDoc = startPos + length;
131      styler.StartSegment( startPos );
132      char cCurrChar;
133      bool bVarInString = false;
134      bool bClassicVarInString = false;
135      Sci_PositionU i;
136      for ( i = startPos; i < nLengthDoc; i++ ) {
137          cCurrChar = styler.SafeGetCharAt( i );
138          char cNextChar = styler.SafeGetCharAt(i+1);
139          switch (state) {
140          case SCE_CMAKE_DEFAULT:
141              if ( cCurrChar == '#' ) { 
142                  styler.ColourTo(i-1, state );
143                  state = SCE_CMAKE_COMMENT;
144                  break;
145              }
146              if ( cCurrChar == '"' ) {
147                  styler.ColourTo(i-1, state );
148                  state = SCE_CMAKE_STRINGDQ;
149                  bVarInString = false;
150                  bClassicVarInString = false;
151                  break;
152              }
153              if ( cCurrChar == '\'' ) {
154                  styler.ColourTo(i-1, state );
155                  state = SCE_CMAKE_STRINGRQ;
156                  bVarInString = false;
157                  bClassicVarInString = false;
158                  break;
159              }
160              if ( cCurrChar == '`' ) {
161                  styler.ColourTo(i-1, state );
162                  state = SCE_CMAKE_STRINGLQ;
163                  bVarInString = false;
164                  bClassicVarInString = false;
165                  break;
166              }
167              if ( cCurrChar == '$' || isCmakeChar(cCurrChar)) {
168                  styler.ColourTo(i-1,state);
169                  state = SCE_CMAKE_VARIABLE;
170                  if ( isCmakeNumber(cCurrChar) && (cNextChar == '\t' || cNextChar == ' ' || cNextChar == '\r' || cNextChar == '\n' ) )
171                      styler.ColourTo( i, SCE_CMAKE_NUMBER);
172                  break;
173              }
174              break;
175          case SCE_CMAKE_COMMENT:
176              if ( cCurrChar == '\n' || cCurrChar == '\r' ) {
177                  if ( styler.SafeGetCharAt(i-1) == '\\' ) {
178                      styler.ColourTo(i-2,state);
179                      styler.ColourTo(i-1,SCE_CMAKE_DEFAULT);
180                  }
181                  else {
182                      styler.ColourTo(i-1,state);
183                      state = SCE_CMAKE_DEFAULT;
184                  }
185              }
186              break;
187          case SCE_CMAKE_STRINGDQ:
188          case SCE_CMAKE_STRINGLQ:
189          case SCE_CMAKE_STRINGRQ:
190              if ( styler.SafeGetCharAt(i-1) == '\\' && styler.SafeGetCharAt(i-2) == '$' )
191                  break; 
192              if ( cCurrChar == '"' && state == SCE_CMAKE_STRINGDQ ) {
193                  styler.ColourTo(i,state);
194                  state = SCE_CMAKE_DEFAULT;
195                  break;
196              }
197              if ( cCurrChar == '`' && state == SCE_CMAKE_STRINGLQ ) {
198                  styler.ColourTo(i,state);
199                  state = SCE_CMAKE_DEFAULT;
200                  break;
201              }
202              if ( cCurrChar == '\'' && state == SCE_CMAKE_STRINGRQ ) {
203                  styler.ColourTo(i,state);
204                  state = SCE_CMAKE_DEFAULT;
205                  break;
206              }
207              if ( cNextChar == '\r' || cNextChar == '\n' ) {
208                  Sci_Position nCurLine = styler.GetLine(i+1);
209                  Sci_Position nBack = i;
210                  bool bNextLine = false;
211                  while ( nBack > 0 ) {
212                      if ( styler.GetLine(nBack) != nCurLine )
213                          break;
214                      char cTemp = styler.SafeGetCharAt(nBack, 'a'); 
215                      if ( cTemp == '\\' ) {
216                          bNextLine = true;
217                          break;
218                      }
219                      if ( cTemp != '\r' && cTemp != '\n' && cTemp != '\t' && cTemp != ' ' )
220                          break;
221                      nBack--;
222                  }
223                  if ( bNextLine ) {
224                      styler.ColourTo(i+1,state);
225                  }
226                  if ( bNextLine == false ) {
227                      styler.ColourTo(i,state);
228                      state = SCE_CMAKE_DEFAULT;
229                  }
230              }
231              break;
232          case SCE_CMAKE_VARIABLE:
233              if ( cCurrChar == '$' )
234                  state = SCE_CMAKE_DEFAULT;
235              else if ( cCurrChar == '\\' && (cNextChar == 'n' || cNextChar == 'r' || cNextChar == 't' ) )
236                  state = SCE_CMAKE_DEFAULT;
237              else if ( (isCmakeChar(cCurrChar) && !isCmakeChar( cNextChar) && cNextChar != '}') || cCurrChar == '}' ) {
238                  state = classifyWordCmake( styler.GetStartSegment(), i, keywordLists, styler );
239                  styler.ColourTo( i, state);
240                  state = SCE_CMAKE_DEFAULT;
241              }
242              else if ( !isCmakeChar( cCurrChar ) && cCurrChar != '{' && cCurrChar != '}' ) {
243                  if ( classifyWordCmake( styler.GetStartSegment(), i-1, keywordLists, styler) == SCE_CMAKE_NUMBER )
244                      styler.ColourTo( i-1, SCE_CMAKE_NUMBER );
245                  state = SCE_CMAKE_DEFAULT;
246                  if ( cCurrChar == '"' ) {
247                      state = SCE_CMAKE_STRINGDQ;
248                      bVarInString = false;
249                      bClassicVarInString = false;
250                  }
251                  else if ( cCurrChar == '`' ) {
252                      state = SCE_CMAKE_STRINGLQ;
253                      bVarInString = false;
254                      bClassicVarInString = false;
255                  }
256                  else if ( cCurrChar == '\'' ) {
257                      state = SCE_CMAKE_STRINGRQ;
258                      bVarInString = false;
259                      bClassicVarInString = false;
260                  }
261                  else if ( cCurrChar == '#' ) {
262                      state = SCE_CMAKE_COMMENT;
263                  }
264              }
265              break;
266          }
267          if ( state == SCE_CMAKE_STRINGDQ || state == SCE_CMAKE_STRINGLQ || state == SCE_CMAKE_STRINGRQ ) {
268              bool bIngoreNextDollarSign = false;
269              if ( bVarInString && cCurrChar == '$' ) {
270                  bVarInString = false;
271                  bIngoreNextDollarSign = true;
272              }
273              else if ( bVarInString && cCurrChar == '\\' && (cNextChar == 'n' || cNextChar == 'r' || cNextChar == 't' || cNextChar == '"' || cNextChar == '`' || cNextChar == '\'' ) ) {
274                  styler.ColourTo( i+1, SCE_CMAKE_STRINGVAR);
275                  bVarInString = false;
276                  bIngoreNextDollarSign = false;
277              }
278              else if ( bVarInString && !isCmakeChar(cNextChar) ) {
279                  int nWordState = classifyWordCmake( styler.GetStartSegment(), i, keywordLists, styler);
280                  if ( nWordState == SCE_CMAKE_VARIABLE )
281                      styler.ColourTo( i, SCE_CMAKE_STRINGVAR);
282                  bVarInString = false;
283              }
284              else if ( bClassicVarInString && cNextChar == '}' ) {
285                  styler.ColourTo( i+1, SCE_CMAKE_STRINGVAR);
286                  bClassicVarInString = false;
287              }
288              if ( !bIngoreNextDollarSign && cCurrChar == '$' && cNextChar == '{' ) {
289                  styler.ColourTo( i-1, state);
290                  bClassicVarInString = true;
291                  bVarInString = false;
292              }
293              else if ( !bIngoreNextDollarSign && cCurrChar == '$' ) {
294                  styler.ColourTo( i-1, state);
295                  bVarInString = true;
296                  bClassicVarInString = false;
297              }
298          }
299      }
300      styler.ColourTo(nLengthDoc-1,state);
301  }
302  static void FoldCmakeDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler)
303  {
304      if ( styler.GetPropertyInt("fold") == 0 )
305          return;
306      bool foldAtElse = styler.GetPropertyInt("fold.at.else", 0) == 1;
307      Sci_Position lineCurrent = styler.GetLine(startPos);
308      Sci_PositionU safeStartPos = styler.LineStart( lineCurrent );
309      bool bArg1 = true;
310      Sci_Position nWordStart = -1;
311      int levelCurrent = SC_FOLDLEVELBASE;
312      if (lineCurrent > 0)
313          levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
314      int levelNext = levelCurrent;
315      for (Sci_PositionU i = safeStartPos; i < startPos + length; i++) {
316          char chCurr = styler.SafeGetCharAt(i);
317          if ( bArg1 ) {
318              if ( nWordStart == -1 && (isCmakeLetter(chCurr)) ) {
319                  nWordStart = i;
320              }
321              else if ( isCmakeLetter(chCurr) == false && nWordStart > -1 ) {
322                  int newLevel = calculateFoldCmake( nWordStart, i-1, levelNext, styler, foldAtElse);
323                  if ( newLevel == levelNext ) {
324                      if ( foldAtElse ) {
325                          if ( CmakeNextLineHasElse(i, startPos + length, styler) )
326                              levelNext--;
327                      }
328                  }
329                  else
330                      levelNext = newLevel;
331                  bArg1 = false;
332              }
333          }
334          if ( chCurr == '\n' ) {
335              if ( bArg1 && foldAtElse) {
336                  if ( CmakeNextLineHasElse(i, startPos + length, styler) )
337                      levelNext--;
338              }
339              int levelUse = levelCurrent;
340              int lev = levelUse | levelNext << 16;
341              if (levelUse < levelNext )
342                  lev |= SC_FOLDLEVELHEADERFLAG;
343              if (lev != styler.LevelAt(lineCurrent))
344                  styler.SetLevel(lineCurrent, lev);
345              lineCurrent++;
346              levelCurrent = levelNext;
347              bArg1 = true; 
<span onclick='openModal()' class='match'>348              nWordStart = -1;
349          }
350      }
351      int levelUse = levelCurrent;
352      int lev = levelUse | levelNext << 16;
353      if (levelUse < levelNext)
354          lev |= SC_FOLDLEVELHEADERFLAG;
355      if (lev != styler.LevelAt(lineCurrent))
356          styler.SetLevel(lineCurrent, lev);
357  }
358  static const char * const cmakeWordLists[] = {
359      "Commands",
360      "Parameters",
361      "UserDefined",
362      0,
</span>363      0,};
364  LexerModule lmCmake(SCLEX_CMAKE, ColouriseCmakeDoc, "cmake", FoldCmakeDoc, cmakeWordLists);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static bool isNsisNumber(char ch)
20  {
21    return (ch >= '0' && ch <= '9');
22  }
23  static bool isNsisChar(char ch)
24  {
25    return (ch == '.' ) || (ch == '_' ) || isNsisNumber(ch) || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
26  }
27  static bool isNsisLetter(char ch)
28  {
29    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
30  }
31  static bool NsisNextLineHasElse(Sci_PositionU start, Sci_PositionU end, Accessor &styler)
32  {
33    Sci_Position nNextLine = -1;
34    for( Sci_PositionU i = start; i < end; i++ )
35    {
36      char cNext = styler.SafeGetCharAt( i );
37      if( cNext == '\n' )
38      {
39        nNextLine = i+1;
40        break;
41      }
42    }
43    if( nNextLine == -1 ) 
44      return false;
45    for( Sci_PositionU firstChar = nNextLine; firstChar < end; firstChar++ )
46    {
47      char cNext = styler.SafeGetCharAt( firstChar );
48      if( cNext == ' ' )
49        continue;
50      if( cNext == '\t' )
51        continue;
52      if( cNext == '!' )
53      {
54        if( styler.Match(firstChar, "!else") )
55          return true;
56      }
57      break;
58    }
59    return false;
60  }
61  static int NsisCmp( const char *s1, const char *s2, bool bIgnoreCase )
62  {
63    if( bIgnoreCase )
64       return CompareCaseInsensitive( s1, s2);
65    return strcmp( s1, s2 );
66  }
67  static int calculateFoldNsis(Sci_PositionU start, Sci_PositionU end, int foldlevel, Accessor &styler, bool bElse, bool foldUtilityCmd )
68  {
69    int style = styler.StyleAt(end);
70    if( end - start > 20 )
71      return foldlevel;
72    if( foldUtilityCmd )
73    {
74      if( style != SCE_NSIS_FUNCTIONDEF && style != SCE_NSIS_SECTIONDEF &&
75          style != SCE_NSIS_SUBSECTIONDEF && style != SCE_NSIS_IFDEFINEDEF &&
76          style != SCE_NSIS_MACRODEF && style != SCE_NSIS_SECTIONGROUP &&
77          style != SCE_NSIS_PAGEEX )
78            return foldlevel;
79    }
80    else
81    {
82      if( style != SCE_NSIS_FUNCTIONDEF && style != SCE_NSIS_SECTIONDEF &&
83          style != SCE_NSIS_SUBSECTIONDEF && style != SCE_NSIS_SECTIONGROUP &&
84          style != SCE_NSIS_PAGEEX )
85            return foldlevel;
86    }
87    int newFoldlevel = foldlevel;
88    bool bIgnoreCase = false;
89    if( styler.GetPropertyInt("nsis.ignorecase") == 1 )
90      bIgnoreCase = true;
91    char s[20]; 
92    s[0] = '\0';
93    for (Sci_PositionU i = 0; i < end - start + 1 && i < 19; i++)
94  	{
95  		s[i] = static_cast<char>( styler[ start + i ] );
96  		s[i + 1] = '\0';
97  	}
98    if( s[0] == '!' )
99    {
100      if( NsisCmp(s, "!ifndef", bIgnoreCase) == 0 || NsisCmp(s, "!ifdef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrodef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrondef", bIgnoreCase ) == 0 || NsisCmp(s, "!if", bIgnoreCase ) == 0 || NsisCmp(s, "!macro", bIgnoreCase ) == 0 )
101        newFoldlevel++;
102      else if( NsisCmp(s, "!endif", bIgnoreCase) == 0 || NsisCmp(s, "!macroend", bIgnoreCase ) == 0 )
103        newFoldlevel--;
104      else if( bElse && NsisCmp(s, "!else", bIgnoreCase) == 0 )
105        newFoldlevel++;
106    }
107    else
108    {
109      if( NsisCmp(s, "Section", bIgnoreCase ) == 0 || NsisCmp(s, "SectionGroup", bIgnoreCase ) == 0 || NsisCmp(s, "Function", bIgnoreCase) == 0 || NsisCmp(s, "SubSection", bIgnoreCase ) == 0 || NsisCmp(s, "PageEx", bIgnoreCase ) == 0 )
110        newFoldlevel++;
111      else if( NsisCmp(s, "SectionGroupEnd", bIgnoreCase ) == 0 || NsisCmp(s, "SubSectionEnd", bIgnoreCase ) == 0 || NsisCmp(s, "FunctionEnd", bIgnoreCase) == 0 || NsisCmp(s, "SectionEnd", bIgnoreCase ) == 0 || NsisCmp(s, "PageExEnd", bIgnoreCase ) == 0 )
112        newFoldlevel--;
113    }
114    return newFoldlevel;
115  }
116  static int classifyWordNsis(Sci_PositionU start, Sci_PositionU end, WordList *keywordLists[], Accessor &styler )
117  {
118    bool bIgnoreCase = false;
119    if( styler.GetPropertyInt("nsis.ignorecase") == 1 )
120      bIgnoreCase = true;
121    bool bUserVars = false;
122    if( styler.GetPropertyInt("nsis.uservars") == 1 )
123      bUserVars = true;
124  	char s[100];
125  	s[0] = '\0';
126  	s[1] = '\0';
127  	WordList &Functions = *keywordLists[0];
128  	WordList &Variables = *keywordLists[1];
129  	WordList &Lables = *keywordLists[2];
130  	WordList &UserDefined = *keywordLists[3];
131  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 99; i++)
132  	{
133      if( bIgnoreCase )
134        s[i] = static_cast<char>( tolower(styler[ start + i ] ) );
135      else
136  		  s[i] = static_cast<char>( styler[ start + i ] );
137  		s[i + 1] = '\0';
138  	}
139  	if( NsisCmp(s, "!macro", bIgnoreCase ) == 0 || NsisCmp(s, "!macroend", bIgnoreCase) == 0 ) 
140  		return SCE_NSIS_MACRODEF;
141  	if( NsisCmp(s, "!ifdef", bIgnoreCase ) == 0 ||  NsisCmp(s, "!ifndef", bIgnoreCase) == 0 ||  NsisCmp(s, "!endif", bIgnoreCase) == 0 ) 
142  		return SCE_NSIS_IFDEFINEDEF;
143  	if( NsisCmp(s, "!if", bIgnoreCase ) == 0 || NsisCmp(s, "!else", bIgnoreCase )  == 0 ) 
144  		return SCE_NSIS_IFDEFINEDEF;
145  	if (NsisCmp(s, "!ifmacrodef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrondef", bIgnoreCase )  == 0 ) 
146  		return SCE_NSIS_IFDEFINEDEF;
147    if( NsisCmp(s, "SectionGroup", bIgnoreCase) == 0 || NsisCmp(s, "SectionGroupEnd", bIgnoreCase) == 0 ) 
148      return SCE_NSIS_SECTIONGROUP;
149  	if( NsisCmp(s, "Section", bIgnoreCase ) == 0 || NsisCmp(s, "SectionEnd", bIgnoreCase) == 0 ) 
150  		return SCE_NSIS_SECTIONDEF;
151  	if( NsisCmp(s, "SubSection", bIgnoreCase) == 0 || NsisCmp(s, "SubSectionEnd", bIgnoreCase) == 0 ) 
152  		return SCE_NSIS_SUBSECTIONDEF;
153    if( NsisCmp(s, "PageEx", bIgnoreCase) == 0 || NsisCmp(s, "PageExEnd", bIgnoreCase) == 0 ) 
154      return SCE_NSIS_PAGEEX;
155  	if( NsisCmp(s, "Function", bIgnoreCase) == 0 || NsisCmp(s, "FunctionEnd", bIgnoreCase) == 0 ) 
156  		return SCE_NSIS_FUNCTIONDEF;
157  	if ( Functions.InList(s) )
158  		return SCE_NSIS_FUNCTION;
159  	if ( Variables.InList(s) )
160  		return SCE_NSIS_VARIABLE;
161  	if ( Lables.InList(s) )
162  		return SCE_NSIS_LABEL;
163  	if( UserDefined.InList(s) )
164  		return SCE_NSIS_USERDEFINED;
165  	if( strlen(s) > 3 )
166  	{
167  		if( s[1] == '{' && s[strlen(s)-1] == '}' )
168  			return SCE_NSIS_VARIABLE;
169  	}
170    if( s[0] == '$' && bUserVars )
171    {
172      bool bHasSimpleNsisChars = true;
173      for (Sci_PositionU j = 1; j < end - start + 1 && j < 99; j++)
174  	  {
175        if( !isNsisChar( s[j] ) )
176        {
177          bHasSimpleNsisChars = false;
178          break;
179        }
180  	  }
181      if( bHasSimpleNsisChars )
182        return SCE_NSIS_VARIABLE;
183    }
184    if( isNsisNumber( s[0] ) )
185    {
186      bool bHasSimpleNsisNumber = true;
187      for (Sci_PositionU j = 1; j < end - start + 1 && j < 99; j++)
188  	  {
189        if( !isNsisNumber( s[j] ) )
190        {
191          bHasSimpleNsisNumber = false;
192          break;
193        }
194  	  }
195      if( bHasSimpleNsisNumber )
196        return SCE_NSIS_NUMBER;
197    }
198  	return SCE_NSIS_DEFAULT;
199  }
200  static void ColouriseNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *keywordLists[], Accessor &styler)
201  {
202  	int state = SCE_NSIS_DEFAULT;
203    if( startPos > 0 )
204      state = styler.StyleAt(startPos-1); 
205  	styler.StartAt( startPos );
206  	styler.GetLine( startPos );
207  	Sci_PositionU nLengthDoc = startPos + length;
208  	styler.StartSegment( startPos );
209  	char cCurrChar;
210  	bool bVarInString = false;
211    bool bClassicVarInString = false;
212  	Sci_PositionU i;
213  	for( i = startPos; i < nLengthDoc; i++ )
214  	{
215  		cCurrChar = styler.SafeGetCharAt( i );
216  		char cNextChar = styler.SafeGetCharAt(i+1);
217  		switch(state)
218  		{
219  			case SCE_NSIS_DEFAULT:
220  				if( cCurrChar == ';' || cCurrChar == '#' ) 
221  				{
222  					styler.ColourTo(i-1, state );
223  					state = SCE_NSIS_COMMENT;
224  					break;
225  				}
226  				if( cCurrChar == '"' )
227  				{
228  					styler.ColourTo(i-1, state );
229  					state = SCE_NSIS_STRINGDQ;
230  					bVarInString = false;
231            bClassicVarInString = false;
232  					break;
233  				}
234  				if( cCurrChar == '\'' )
235  				{
236  					styler.ColourTo(i-1, state );
237  					state = SCE_NSIS_STRINGRQ;
238  					bVarInString = false;
239            bClassicVarInString = false;
240  					break;
241  				}
242  				if( cCurrChar == '`' )
243  				{
244  					styler.ColourTo(i-1, state );
245  					state = SCE_NSIS_STRINGLQ;
246  					bVarInString = false;
247            bClassicVarInString = false;
248  					break;
249  				}
250  				if( cCurrChar == '$' || isNsisChar(cCurrChar) || cCurrChar == '!' )
251  				{
252  					styler.ColourTo(i-1,state);
253  				  state = SCE_NSIS_FUNCTION;
254            if( isNsisNumber(cCurrChar) && (cNextChar == '\t' || cNextChar == ' ' || cNextChar == '\r' || cNextChar == '\n' ) )
255                styler.ColourTo( i, SCE_NSIS_NUMBER);
256  					break;
257  				}
258          if( cCurrChar == '/' && cNextChar == '*' )
259          {
260            styler.ColourTo(i-1,state);
261            state = SCE_NSIS_COMMENTBOX;
262            break;
263          }
264  				break;
265  			case SCE_NSIS_COMMENT:
266  				if( cNextChar == '\n' || cNextChar == '\r' )
267          {
268            if( cCurrChar == '\\' )
269            {
270              styler.ColourTo(i-2,state);
271              styler.ColourTo(i,SCE_NSIS_DEFAULT);
272            }
273            else
274            {
275  				    styler.ColourTo(i,state);
276              state = SCE_NSIS_DEFAULT;
277            }
278          }
279  				break;
280  			case SCE_NSIS_STRINGDQ:
281        case SCE_NSIS_STRINGLQ:
282        case SCE_NSIS_STRINGRQ:
283          if( styler.SafeGetCharAt(i-1) == '\\' && styler.SafeGetCharAt(i-2) == '$' )
284            break; 
285          if( cCurrChar == '"' && state == SCE_NSIS_STRINGDQ )
286  				{
287  					styler.ColourTo(i,state);
288  				  state = SCE_NSIS_DEFAULT;
289            break;
290  				}
291          if( cCurrChar == '`' && state == SCE_NSIS_STRINGLQ )
292          {
293  					styler.ColourTo(i,state);
294  				  state = SCE_NSIS_DEFAULT;
295            break;
296  				}
297          if( cCurrChar == '\'' && state == SCE_NSIS_STRINGRQ )
298  				{
299  					styler.ColourTo(i,state);
300  				  state = SCE_NSIS_DEFAULT;
301            break;
302  				}
303          if( cNextChar == '\r' || cNextChar == '\n' )
304          {
305            Sci_Position nCurLine = styler.GetLine(i+1);
306            Sci_Position nBack = i;
307            bool bNextLine = false;
308            while( nBack > 0 )
309            {
310              if( styler.GetLine(nBack) != nCurLine )
311                break;
312              char cTemp = styler.SafeGetCharAt(nBack, 'a'); 
313              if( cTemp == '\\' )
314              {
315                bNextLine = true;
316                break;
317              }
318              if( cTemp != '\r' && cTemp != '\n' && cTemp != '\t' && cTemp != ' ' )
319                break;
320              nBack--;
321            }
322            if( bNextLine )
323            {
324              styler.ColourTo(i+1,state);
325            }
326            if( bNextLine == false )
327            {
328              styler.ColourTo(i,state);
329  				    state = SCE_NSIS_DEFAULT;
330            }
331          }
332  				break;
333  			case SCE_NSIS_FUNCTION:
334          if( cCurrChar == '$' )
335            state = SCE_NSIS_DEFAULT;
336          else if( cCurrChar == '\\' && (cNextChar == 'n' || cNextChar == 'r' || cNextChar == 't' ) )
337            state = SCE_NSIS_DEFAULT;
338  				else if( (isNsisChar(cCurrChar) && !isNsisChar( cNextChar) && cNextChar != '}') || cCurrChar == '}' )
339  				{
340  					state = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler );
341  					styler.ColourTo( i, state);
342  					state = SCE_NSIS_DEFAULT;
343  				}
344  				else if( !isNsisChar( cCurrChar ) && cCurrChar != '{' && cCurrChar != '}' )
345  				{
346            if( classifyWordNsis( styler.GetStartSegment(), i-1, keywordLists, styler) == SCE_NSIS_NUMBER )
347               styler.ColourTo( i-1, SCE_NSIS_NUMBER );
348  					state = SCE_NSIS_DEFAULT;
349  					if( cCurrChar == '"' )
350  					{
351  						state = SCE_NSIS_STRINGDQ;
352  						bVarInString = false;
353              bClassicVarInString = false;
354  					}
355  					else if( cCurrChar == '`' )
356  					{
357  						state = SCE_NSIS_STRINGLQ;
358  						bVarInString = false;
359              bClassicVarInString = false;
360  					}
361  					else if( cCurrChar == '\'' )
362  					{
363  						state = SCE_NSIS_STRINGRQ;
364  						bVarInString = false;
365              bClassicVarInString = false;
366  					}
367  					else if( cCurrChar == '#' || cCurrChar == ';' )
368            {
369  						state = SCE_NSIS_COMMENT;
370            }
371  				}
372  				break;
373        case SCE_NSIS_COMMENTBOX:
374          if( styler.SafeGetCharAt(i-1) == '*' && cCurrChar == '/' )
375          {
376            styler.ColourTo(i,state);
377            state = SCE_NSIS_DEFAULT;
378          }
379          break;
380  		}
381  		if( state == SCE_NSIS_COMMENT || state == SCE_NSIS_COMMENTBOX )
382  		{
383  			styler.ColourTo(i,state);
384  		}
385  		else if( state == SCE_NSIS_STRINGDQ || state == SCE_NSIS_STRINGLQ || state == SCE_NSIS_STRINGRQ )
386  		{
387        bool bIngoreNextDollarSign = false;
388        bool bUserVars = false;
389        if( styler.GetPropertyInt("nsis.uservars") == 1 )
390          bUserVars = true;
391        if( bVarInString && cCurrChar == '$' )
392        {
393          bVarInString = false;
394          bIngoreNextDollarSign = true;
395        }
396        else if( bVarInString && cCurrChar == '\\' && (cNextChar == 'n' || cNextChar == 'r' || cNextChar == 't' || cNextChar == '"' || cNextChar == '`' || cNextChar == '\'' ) )
397        {
398          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
399          bVarInString = false;
400          bIngoreNextDollarSign = false;
401        }
402        else if( bVarInString && !isNsisChar(cNextChar) )
403        {
404          int nWordState = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler);
405  				if( nWordState == SCE_NSIS_VARIABLE )
406  					styler.ColourTo( i, SCE_NSIS_STRINGVAR);
407          else if( bUserVars )
408            styler.ColourTo( i, SCE_NSIS_STRINGVAR);
409          bVarInString = false;
410        }
411        else if( bClassicVarInString && cNextChar == '}' )
412        {
413          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
414  				bClassicVarInString = false;
415        }
416  			if( !bIngoreNextDollarSign && cCurrChar == '$' && cNextChar == '{' )
417  			{
418  				styler.ColourTo( i-1, state);
419  				bClassicVarInString = true;
420          bVarInString = false;
421  			}
422        else if( !bIngoreNextDollarSign && cCurrChar == '$' )
423        {
424          styler.ColourTo( i-1, state);
425          bVarInString = true;
426          bClassicVarInString = false;
427        }
428  		}
429  	}
430  	styler.ColourTo(nLengthDoc-1,state);
431  }
432  static void FoldNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler)
433  {
434  	if( styler.GetPropertyInt("fold") == 0 )
435  		return;
436    bool foldAtElse = styler.GetPropertyInt("fold.at.else", 0) == 1;
437    bool foldUtilityCmd = styler.GetPropertyInt("nsis.foldutilcmd", 1) == 1;
438    bool blockComment = false;
439    Sci_Position lineCurrent = styler.GetLine(startPos);
440    Sci_PositionU safeStartPos = styler.LineStart( lineCurrent );
441    bool bArg1 = true;
442    Sci_Position nWordStart = -1;
443    int levelCurrent = SC_FOLDLEVELBASE;
444  	if (lineCurrent > 0)
445  		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
446  	int levelNext = levelCurrent;
447    int style = styler.StyleAt(safeStartPos);
448    if( style == SCE_NSIS_COMMENTBOX )
449    {
450      if( styler.SafeGetCharAt(safeStartPos) == '/' && styler.SafeGetCharAt(safeStartPos+1) == '*' )
451        levelNext++;
452      blockComment = true;
453    }
454    for (Sci_PositionU i = safeStartPos; i < startPos + length; i++)
455  	{
456      char chCurr = styler.SafeGetCharAt(i);
457      style = styler.StyleAt(i);
458      if( blockComment && style != SCE_NSIS_COMMENTBOX )
459      {
460        levelNext--;
461        blockComment = false;
462      }
463      else if( !blockComment && style == SCE_NSIS_COMMENTBOX )
464      {
465        levelNext++;
466        blockComment = true;
467      }
468      if( bArg1 && !blockComment)
469      {
470        if( nWordStart == -1 && (isNsisLetter(chCurr) || chCurr == '!') )
471        {
472          nWordStart = i;
473        }
474        else if( isNsisLetter(chCurr) == false && nWordStart > -1 )
475        {
476          int newLevel = calculateFoldNsis( nWordStart, i-1, levelNext, styler, foldAtElse, foldUtilityCmd );
477          if( newLevel == levelNext )
478          {
479            if( foldAtElse && foldUtilityCmd )
480            {
481              if( NsisNextLineHasElse(i, startPos + length, styler) )
482                levelNext--;
483            }
484          }
485          else
486            levelNext = newLevel;
487          bArg1 = false;
488        }
489      }
490      if( chCurr == '\n' )
491      {
492        if( bArg1 && foldAtElse && foldUtilityCmd && !blockComment )
493        {
494          if( NsisNextLineHasElse(i, startPos + length, styler) )
495            levelNext--;
496        }
497        int levelUse = levelCurrent;
498  			int lev = levelUse | levelNext << 16;
499        if (levelUse < levelNext )
500  				lev |= SC_FOLDLEVELHEADERFLAG;
501  			if (lev != styler.LevelAt(lineCurrent))
502  				styler.SetLevel(lineCurrent, lev);
503  			lineCurrent++;
504  			levelCurrent = levelNext;
505        bArg1 = true; 
<span onclick='openModal()' class='match'>506        nWordStart = -1;
507      }
508    }
509  	int levelUse = levelCurrent;
510  	int lev = levelUse | levelNext << 16;
511  	if (levelUse < levelNext)
512  		lev |= SC_FOLDLEVELHEADERFLAG;
513  	if (lev != styler.LevelAt(lineCurrent))
514  		styler.SetLevel(lineCurrent, lev);
515  }
516  static const char * const nsisWordLists[] = {
517  	"Functions",
518  	"Variables",
519  	"Lables",
520  	"UserDefined",
</span>521  	0, };
522  LexerModule lmNsis(SCLEX_NSIS, ColouriseNsisDoc, "nsis", FoldNsisDoc, nsisWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexCmake.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</div>
                </div>
                <div class="column column_space"><pre><code>348              nWordStart = -1;
349          }
350      }
351      int levelUse = levelCurrent;
352      int lev = levelUse | levelNext << 16;
353      if (levelUse < levelNext)
354          lev |= SC_FOLDLEVELHEADERFLAG;
355      if (lev != styler.LevelAt(lineCurrent))
356          styler.SetLevel(lineCurrent, lev);
357  }
358  static const char * const cmakeWordLists[] = {
359      "Commands",
360      "Parameters",
361      "UserDefined",
362      0,
</pre></code></div>
                <div class="column column_space"><pre><code>506        nWordStart = -1;
507      }
508    }
509  	int levelUse = levelCurrent;
510  	int lev = levelUse | levelNext << 16;
511  	if (levelUse < levelNext)
512  		lev |= SC_FOLDLEVELHEADERFLAG;
513  	if (lev != styler.LevelAt(lineCurrent))
514  		styler.SetLevel(lineCurrent, lev);
515  }
516  static const char * const nsisWordLists[] = {
517  	"Functions",
518  	"Variables",
519  	"Lables",
520  	"UserDefined",
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    