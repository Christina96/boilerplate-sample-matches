
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 217, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-curve25519-donna-64bit.h</h3>
            <pre><code>1  typedef uint64_t bignum25519[5];
2  static const uint64_t reduce_mask_40 = ((uint64_t)1 &lt;&lt; 40) - 1;
3  static const uint64_t reduce_mask_51 = ((uint64_t)1 &lt;&lt; 51) - 1;
4  static const uint64_t reduce_mask_56 = ((uint64_t)1 &lt;&lt; 56) - 1;
5  DONNA_INLINE static void
6  curve25519_copy(bignum25519 out, const bignum25519 in) {
7  	out[0] = in[0];
8  	out[1] = in[1];
9  	out[2] = in[2];
10  	out[3] = in[3];
11  	out[4] = in[4];
12  }
13  DONNA_INLINE static void
14  curve25519_add(bignum25519 out, const bignum25519 a, const bignum25519 b) {
15  	out[0] = a[0] + b[0];
16  	out[1] = a[1] + b[1];
17  	out[2] = a[2] + b[2];
18  	out[3] = a[3] + b[3];
19  	out[4] = a[4] + b[4];
20  }
21  DONNA_INLINE static void
22  curve25519_add_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b) {
23  	out[0] = a[0] + b[0];
24  	out[1] = a[1] + b[1];
25  	out[2] = a[2] + b[2];
26  	out[3] = a[3] + b[3];
27  	out[4] = a[4] + b[4];
28  }
29  DONNA_INLINE static void
30  curve25519_add_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b) {
31  	uint64_t c;
32  	out[0] = a[0] + b[0]    ; c = (out[0] &gt;&gt; 51); out[0] &amp;= reduce_mask_51;
33  	out[1] = a[1] + b[1] + c; c = (out[1] &gt;&gt; 51); out[1] &amp;= reduce_mask_51;
34  	out[2] = a[2] + b[2] + c; c = (out[2] &gt;&gt; 51); out[2] &amp;= reduce_mask_51;
35  	out[3] = a[3] + b[3] + c; c = (out[3] &gt;&gt; 51); out[3] &amp;= reduce_mask_51;
36  	out[4] = a[4] + b[4] + c; c = (out[4] &gt;&gt; 51); out[4] &amp;= reduce_mask_51;
37  	out[0] += c * 19;
38  }
39  static const uint64_t twoP0      = 0x0fffffffffffda;
40  static const uint64_t twoP1234   = 0x0ffffffffffffe;
41  static const uint64_t fourP0     = 0x1fffffffffffb4;
42  static const uint64_t fourP1234  = 0x1ffffffffffffc;
43  DONNA_INLINE static void
44  curve25519_sub(bignum25519 out, const bignum25519 a, const bignum25519 b) {
45  	out[0] = a[0] + twoP0    - b[0];
46  	out[1] = a[1] + twoP1234 - b[1];
47  	out[2] = a[2] + twoP1234 - b[2];
48  	out[3] = a[3] + twoP1234 - b[3];
49  	out[4] = a[4] + twoP1234 - b[4];
50  }
51  DONNA_INLINE static void
52  curve25519_sub_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b) {
53  	out[0] = a[0] + fourP0    - b[0];
54  	out[1] = a[1] + fourP1234 - b[1];
55  	out[2] = a[2] + fourP1234 - b[2];
56  	out[3] = a[3] + fourP1234 - b[3];
57  	out[4] = a[4] + fourP1234 - b[4];
58  }
59  DONNA_INLINE static void
60  curve25519_sub_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b) {
61  	uint64_t c;
62  	out[0] = a[0] + fourP0    - b[0]    ; c = (out[0] &gt;&gt; 51); out[0] &amp;= reduce_mask_51;
63  	out[1] = a[1] + fourP1234 - b[1] + c; c = (out[1] &gt;&gt; 51); out[1] &amp;= reduce_mask_51;
64  	out[2] = a[2] + fourP1234 - b[2] + c; c = (out[2] &gt;&gt; 51); out[2] &amp;= reduce_mask_51;
65  	out[3] = a[3] + fourP1234 - b[3] + c; c = (out[3] &gt;&gt; 51); out[3] &amp;= reduce_mask_51;
66  	out[4] = a[4] + fourP1234 - b[4] + c; c = (out[4] &gt;&gt; 51); out[4] &amp;= reduce_mask_51;
67  	out[0] += c * 19;
68  }
69  DONNA_INLINE static void
70  curve25519_neg(bignum25519 out, const bignum25519 a) {
71  	uint64_t c;
72  	out[0] = twoP0    - a[0]    ; c = (out[0] &gt;&gt; 51); out[0] &amp;= reduce_mask_51;
73  	out[1] = twoP1234 - a[1] + c; c = (out[1] &gt;&gt; 51); out[1] &amp;= reduce_mask_51;
74  	out[2] = twoP1234 - a[2] + c; c = (out[2] &gt;&gt; 51); out[2] &amp;= reduce_mask_51;
75  	out[3] = twoP1234 - a[3] + c; c = (out[3] &gt;&gt; 51); out[3] &amp;= reduce_mask_51;
76  	out[4] = twoP1234 - a[4] + c; c = (out[4] &gt;&gt; 51); out[4] &amp;= reduce_mask_51;
77  	out[0] += c * 19;
78  }
79  DONNA_INLINE static void
80  curve25519_mul(bignum25519 out, const bignum25519 in2, const bignum25519 in) {
81  #if !defined(HAVE_NATIVE_UINT128)
82  	uint128_t mul;
83  #endif
84  	uint128_t t[5];
85  	uint64_t r0,r1,r2,r3,r4,s0,s1,s2,s3,s4,c;
86  	r0 = in[0];
87  	r1 = in[1];
88  	r2 = in[2];
89  	r3 = in[3];
90  	r4 = in[4];
91  	s0 = in2[0];
92  	s1 = in2[1];
93  	s2 = in2[2];
94  	s3 = in2[3];
95  	s4 = in2[4];
96  #if defined(HAVE_NATIVE_UINT128)
97  	t[0]  =  ((uint128_t) r0) * s0;
98  	t[1]  =  ((uint128_t) r0) * s1 + ((uint128_t) r1) * s0;
99  	t[2]  =  ((uint128_t) r0) * s2 + ((uint128_t) r2) * s0 + ((uint128_t) r1) * s1;
100  	t[3]  =  ((uint128_t) r0) * s3 + ((uint128_t) r3) * s0 + ((uint128_t) r1) * s2 + ((uint128_t) r2) * s1;
101  	t[4]  =  ((uint128_t) r0) * s4 + ((uint128_t) r4) * s0 + ((uint128_t) r3) * s1 + ((uint128_t) r1) * s3 + ((uint128_t) r2) * s2;
102  #else
103  	mul64x64_128(t[0], r0, s0)
104  	mul64x64_128(t[1], r0, s1) mul64x64_128(mul, r1, s0) add128(t[1], mul)
105  	mul64x64_128(t[2], r0, s2) mul64x64_128(mul, r2, s0) add128(t[2], mul) mul64x64_128(mul, r1, s1) add128(t[2], mul)
106  	mul64x64_128(t[3], r0, s3) mul64x64_128(mul, r3, s0) add128(t[3], mul) mul64x64_128(mul, r1, s2) add128(t[3], mul) mul64x64_128(mul, r2, s1) add128(t[3], mul)
107  	mul64x64_128(t[4], r0, s4) mul64x64_128(mul, r4, s0) add128(t[4], mul) mul64x64_128(mul, r3, s1) add128(t[4], mul) mul64x64_128(mul, r1, s3) add128(t[4], mul) mul64x64_128(mul, r2, s2) add128(t[4], mul)
108  #endif
109  	r1 *= 19;
110  	r2 *= 19;
111  	r3 *= 19;
112  	r4 *= 19;
113  #if defined(HAVE_NATIVE_UINT128)
114  	t[0] += ((uint128_t) r4) * s1 + ((uint128_t) r1) * s4 + ((uint128_t) r2) * s3 + ((uint128_t) r3) * s2;
115  	t[1] += ((uint128_t) r4) * s2 + ((uint128_t) r2) * s4 + ((uint128_t) r3) * s3;
116  	t[2] += ((uint128_t) r4) * s3 + ((uint128_t) r3) * s4;
117  	t[3] += ((uint128_t) r4) * s4;
118  #else
119  	mul64x64_128(mul, r4, s1) add128(t[0], mul) mul64x64_128(mul, r1, s4) add128(t[0], mul) mul64x64_128(mul, r2, s3) add128(t[0], mul) mul64x64_128(mul, r3, s2) add128(t[0], mul)
120  	mul64x64_128(mul, r4, s2) add128(t[1], mul) mul64x64_128(mul, r2, s4) add128(t[1], mul) mul64x64_128(mul, r3, s3) add128(t[1], mul)
121  	mul64x64_128(mul, r4, s3) add128(t[2], mul) mul64x64_128(mul, r3, s4) add128(t[2], mul)
122  	mul64x64_128(mul, r4, s4) add128(t[3], mul)
123  #endif
<span onclick='openModal()' class='match'>124  	                     r0 = lo128(t[0]) &amp; reduce_mask_51; shr128(c, t[0], 51);
125  	add128_64(t[1], c)   r1 = lo128(t[1]) &amp; reduce_mask_51; shr128(c, t[1], 51);
126  	add128_64(t[2], c)   r2 = lo128(t[2]) &amp; reduce_mask_51; shr128(c, t[2], 51);
127  	add128_64(t[3], c)   r3 = lo128(t[3]) &amp; reduce_mask_51; shr128(c, t[3], 51);
128  	add128_64(t[4], c)   r4 = lo128(t[4]) &amp; reduce_mask_51; shr128(c, t[4], 51);
129  	r0 +=   c * 19; c = r0 &gt;&gt; 51; r0 = r0 &amp; reduce_mask_51;
130  	r1 +=   c;
131  	out[0] = r0;
132  	out[1] = r1;
133  	out[2] = r2;
134  	out[3] = r3;
135  	out[4] = r4;
136  }
137  DONNA_NOINLINE static void
138  curve25519_mul_noinline(bignum25519 out, const bignum25519 in2, const bignum25519 in) {
</span>139  	curve25519_mul(out, in2, in);
140  }
141  DONNA_NOINLINE static void
142  curve25519_square_times(bignum25519 out, const bignum25519 in, uint64_t count) {
143  #if !defined(HAVE_NATIVE_UINT128)
144  	uint128_t mul;
145  #endif
146  	uint128_t t[5];
147  	uint64_t r0,r1,r2,r3,r4,c;
148  	uint64_t d0,d1,d2,d4,d419;
149  	r0 = in[0];
150  	r1 = in[1];
151  	r2 = in[2];
152  	r3 = in[3];
153  	r4 = in[4];
154  	do {
155  		d0 = r0 * 2;
156  		d1 = r1 * 2;
157  		d2 = r2 * 2 * 19;
158  		d419 = r4 * 19;
159  		d4 = d419 * 2;
160  #if defined(HAVE_NATIVE_UINT128)
161  		t[0] = ((uint128_t) r0) * r0 + ((uint128_t) d4) * r1 + (((uint128_t) d2) * (r3     ));
162  		t[1] = ((uint128_t) d0) * r1 + ((uint128_t) d4) * r2 + (((uint128_t) r3) * (r3 * 19));
163  		t[2] = ((uint128_t) d0) * r2 + ((uint128_t) r1) * r1 + (((uint128_t) d4) * (r3     ));
164  		t[3] = ((uint128_t) d0) * r3 + ((uint128_t) d1) * r2 + (((uint128_t) r4) * (d419   ));
165  		t[4] = ((uint128_t) d0) * r4 + ((uint128_t) d1) * r3 + (((uint128_t) r2) * (r2     ));
166  #else
167  		mul64x64_128(t[0], r0, r0) mul64x64_128(mul, d4, r1) add128(t[0], mul) mul64x64_128(mul, d2,      r3) add128(t[0], mul)
168  		mul64x64_128(t[1], d0, r1) mul64x64_128(mul, d4, r2) add128(t[1], mul) mul64x64_128(mul, r3, r3 * 19) add128(t[1], mul)
169  		mul64x64_128(t[2], d0, r2) mul64x64_128(mul, r1, r1) add128(t[2], mul) mul64x64_128(mul, d4,      r3) add128(t[2], mul)
170  		mul64x64_128(t[3], d0, r3) mul64x64_128(mul, d1, r2) add128(t[3], mul) mul64x64_128(mul, r4,    d419) add128(t[3], mul)
171  		mul64x64_128(t[4], d0, r4) mul64x64_128(mul, d1, r3) add128(t[4], mul) mul64x64_128(mul, r2,      r2) add128(t[4], mul)
172  #endif
173  		r0 = lo128(t[0]) &amp; reduce_mask_51;
174  		r1 = lo128(t[1]) &amp; reduce_mask_51; shl128(c, t[0], 13); r1 += c;
175  		r2 = lo128(t[2]) &amp; reduce_mask_51; shl128(c, t[1], 13); r2 += c;
176  		r3 = lo128(t[3]) &amp; reduce_mask_51; shl128(c, t[2], 13); r3 += c;
177  		r4 = lo128(t[4]) &amp; reduce_mask_51; shl128(c, t[3], 13); r4 += c; 
178  		                                   shl128(c, t[4], 13); r0 += c * 19;
179  		               c = r0 &gt;&gt; 51; r0 &amp;= reduce_mask_51;
180  		r1 += c     ;  c = r1 &gt;&gt; 51; r1 &amp;= reduce_mask_51;
181  		r2 += c     ;  c = r2 &gt;&gt; 51; r2 &amp;= reduce_mask_51;
182  		r3 += c     ;  c = r3 &gt;&gt; 51; r3 &amp;= reduce_mask_51;
183  		r4 += c     ;  c = r4 &gt;&gt; 51; r4 &amp;= reduce_mask_51;
184  		r0 += c * 19;
185  	} while(--count);
186  	out[0] = r0;
187  	out[1] = r1;
188  	out[2] = r2;
189  	out[3] = r3;
190  	out[4] = r4;
191  }
192  DONNA_INLINE static void
193  curve25519_square(bignum25519 out, const bignum25519 in) {
194  #if !defined(HAVE_NATIVE_UINT128)
195  	uint128_t mul;
196  #endif
197  	uint128_t t[5];
198  	uint64_t r0,r1,r2,r3,r4,c;
199  	uint64_t d0,d1,d2,d4,d419;
200  	r0 = in[0];
201  	r1 = in[1];
202  	r2 = in[2];
203  	r3 = in[3];
204  	r4 = in[4];
205  	d0 = r0 * 2;
206  	d1 = r1 * 2;
207  	d2 = r2 * 2 * 19;
208  	d419 = r4 * 19;
209  	d4 = d419 * 2;
210  #if defined(HAVE_NATIVE_UINT128)
211  	t[0] = ((uint128_t) r0) * r0 + ((uint128_t) d4) * r1 + (((uint128_t) d2) * (r3     ));
212  	t[1] = ((uint128_t) d0) * r1 + ((uint128_t) d4) * r2 + (((uint128_t) r3) * (r3 * 19));
213  	t[2] = ((uint128_t) d0) * r2 + ((uint128_t) r1) * r1 + (((uint128_t) d4) * (r3     ));
214  	t[3] = ((uint128_t) d0) * r3 + ((uint128_t) d1) * r2 + (((uint128_t) r4) * (d419   ));
215  	t[4] = ((uint128_t) d0) * r4 + ((uint128_t) d1) * r3 + (((uint128_t) r2) * (r2     ));
216  #else
217  	mul64x64_128(t[0], r0, r0) mul64x64_128(mul, d4, r1) add128(t[0], mul) mul64x64_128(mul, d2,      r3) add128(t[0], mul)
218  	mul64x64_128(t[1], d0, r1) mul64x64_128(mul, d4, r2) add128(t[1], mul) mul64x64_128(mul, r3, r3 * 19) add128(t[1], mul)
219  	mul64x64_128(t[2], d0, r2) mul64x64_128(mul, r1, r1) add128(t[2], mul) mul64x64_128(mul, d4,      r3) add128(t[2], mul)
220  	mul64x64_128(t[3], d0, r3) mul64x64_128(mul, d1, r2) add128(t[3], mul) mul64x64_128(mul, r4,    d419) add128(t[3], mul)
221  	mul64x64_128(t[4], d0, r4) mul64x64_128(mul, d1, r3) add128(t[4], mul) mul64x64_128(mul, r2,      r2) add128(t[4], mul)
222  #endif
223  	                     r0 = lo128(t[0]) &amp; reduce_mask_51; shr128(c, t[0], 51);
224  	add128_64(t[1], c)   r1 = lo128(t[1]) &amp; reduce_mask_51; shr128(c, t[1], 51);
225  	add128_64(t[2], c)   r2 = lo128(t[2]) &amp; reduce_mask_51; shr128(c, t[2], 51);
226  	add128_64(t[3], c)   r3 = lo128(t[3]) &amp; reduce_mask_51; shr128(c, t[3], 51);
227  	add128_64(t[4], c)   r4 = lo128(t[4]) &amp; reduce_mask_51; shr128(c, t[4], 51);
228  	r0 +=   c * 19; c = r0 &gt;&gt; 51; r0 = r0 &amp; reduce_mask_51;
229  	r1 +=   c;
230  	out[0] = r0;
231  	out[1] = r1;
232  	out[2] = r2;
233  	out[3] = r3;
234  	out[4] = r4;
235  }
236  DONNA_INLINE static void
237  curve25519_expand(bignum25519 out, const unsigned char *in) {
238  	static const union { uint8_t b[2]; uint16_t s; } endian_check = {{1,0}};
239  	uint64_t x0,x1,x2,x3;
240  	if (endian_check.s == 1) {
241  		x0 = *(uint64_t *)(in + 0);
242  		x1 = *(uint64_t *)(in + 8);
243  		x2 = *(uint64_t *)(in + 16);
244  		x3 = *(uint64_t *)(in + 24);
245  	} else {
246  		#define F_curve25519_expand(s)                         \
247  			((((uint64_t)in[s + 0])      ) | \
248  			 (((uint64_t)in[s + 1]) &lt;&lt;  8) | \
249  			 (((uint64_t)in[s + 2]) &lt;&lt; 16) | \
250  			 (((uint64_t)in[s + 3]) &lt;&lt; 24) | \
251  			 (((uint64_t)in[s + 4]) &lt;&lt; 32) | \
252  			 (((uint64_t)in[s + 5]) &lt;&lt; 40) | \
253  			 (((uint64_t)in[s + 6]) &lt;&lt; 48) | \
254  			 (((uint64_t)in[s + 7]) &lt;&lt; 56))
255  		x0 = F_curve25519_expand(0);
256  		x1 = F_curve25519_expand(8);
257  		x2 = F_curve25519_expand(16);
258  		x3 = F_curve25519_expand(24);
259  	}
260  	out[0] = x0 &amp; reduce_mask_51; x0 = (x0 &gt;&gt; 51) | (x1 &lt;&lt; 13);
261  	out[1] = x0 &amp; reduce_mask_51; x1 = (x1 &gt;&gt; 38) | (x2 &lt;&lt; 26);
262  	out[2] = x1 &amp; reduce_mask_51; x2 = (x2 &gt;&gt; 25) | (x3 &lt;&lt; 39);
263  	out[3] = x2 &amp; reduce_mask_51; x3 = (x3 &gt;&gt; 12);
264  	out[4] = x3 &amp; reduce_mask_51;
265  }
266  DONNA_INLINE static void
267  curve25519_contract(unsigned char *out, const bignum25519 input) {
268  	uint64_t t[5];
269  	uint64_t f, i;
270  	t[0] = input[0];
271  	t[1] = input[1];
272  	t[2] = input[2];
273  	t[3] = input[3];
274  	t[4] = input[4];
275  	#define curve25519_contract_carry() \
276  		t[1] += t[0] &gt;&gt; 51; t[0] &amp;= reduce_mask_51; \
277  		t[2] += t[1] &gt;&gt; 51; t[1] &amp;= reduce_mask_51; \
278  		t[3] += t[2] &gt;&gt; 51; t[2] &amp;= reduce_mask_51; \
279  		t[4] += t[3] &gt;&gt; 51; t[3] &amp;= reduce_mask_51;
280  	#define curve25519_contract_carry_full() curve25519_contract_carry() \
281  		t[0] += 19 * (t[4] &gt;&gt; 51); t[4] &amp;= reduce_mask_51;
282  	#define curve25519_contract_carry_final() curve25519_contract_carry() \
283  		t[4] &amp;= reduce_mask_51;
284  	curve25519_contract_carry_full()
285  	curve25519_contract_carry_full()
286  	t[0] += 19;
287  	curve25519_contract_carry_full()
288  	t[0] += (reduce_mask_51 + 1) - 19;
289  	t[1] += (reduce_mask_51 + 1) - 1;
290  	t[2] += (reduce_mask_51 + 1) - 1;
291  	t[3] += (reduce_mask_51 + 1) - 1;
292  	t[4] += (reduce_mask_51 + 1) - 1;
293  	curve25519_contract_carry_final()
294  	#define write51full(n,shift) \
295  		f = ((t[n] &gt;&gt; shift) | (t[n+1] &lt;&lt; (51 - shift))); \
296  		for (i = 0; i &lt; 8; i++, f &gt;&gt;= 8) *out++ = (unsigned char)f;
297  	#define write51(n) write51full(n,13*n)
298  	write51(0)
299  	write51(1)
300  	write51(2)
301  	write51(3)
302  }
303  #if !defined(ED25519_GCC_64BIT_CHOOSE)
304  DONNA_INLINE static void
305  curve25519_move_conditional_bytes(uint8_t out[96], const uint8_t in[96], uint64_t flag) {
306  	const uint64_t nb = flag - 1, b = ~nb;
307  	const uint64_t *inq = (const uint64_t *)in;
308  	uint64_t *outq = (uint64_t *)out;
309  	outq[0] = (outq[0] &amp; nb) | (inq[0] &amp; b);
310  	outq[1] = (outq[1] &amp; nb) | (inq[1] &amp; b);
311  	outq[2] = (outq[2] &amp; nb) | (inq[2] &amp; b);
312  	outq[3] = (outq[3] &amp; nb) | (inq[3] &amp; b);
313  	outq[4] = (outq[4] &amp; nb) | (inq[4] &amp; b);
314  	outq[5] = (outq[5] &amp; nb) | (inq[5] &amp; b);
315  	outq[6] = (outq[6] &amp; nb) | (inq[6] &amp; b);
316  	outq[7] = (outq[7] &amp; nb) | (inq[7] &amp; b);
317  	outq[8] = (outq[8] &amp; nb) | (inq[8] &amp; b);
318  	outq[9] = (outq[9] &amp; nb) | (inq[9] &amp; b);
319  	outq[10] = (outq[10] &amp; nb) | (inq[10] &amp; b);
320  	outq[11] = (outq[11] &amp; nb) | (inq[11] &amp; b);
321  }
322  DONNA_INLINE static void
323  curve25519_swap_conditional(bignum25519 a, bignum25519 b, uint64_t iswap) {
324  	const uint64_t swap = (uint64_t)(-(int64_t)iswap);
325  	uint64_t x0,x1,x2,x3,x4;
326  	x0 = swap &amp; (a[0] ^ b[0]); a[0] ^= x0; b[0] ^= x0;
327  	x1 = swap &amp; (a[1] ^ b[1]); a[1] ^= x1; b[1] ^= x1;
328  	x2 = swap &amp; (a[2] ^ b[2]); a[2] ^= x2; b[2] ^= x2;
329  	x3 = swap &amp; (a[3] ^ b[3]); a[3] ^= x3; b[3] ^= x3;
330  	x4 = swap &amp; (a[4] ^ b[4]); a[4] ^= x4; b[4] ^= x4;
331  }
332  #endif &amp;bsol;* ED25519_GCC_64BIT_CHOOSE */
333  #define ED25519_64BIT_TABLES
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-curve25519-donna-64bit.h</h3>
            <pre><code>1  typedef uint64_t bignum25519[5];
2  static const uint64_t reduce_mask_40 = ((uint64_t)1 &lt;&lt; 40) - 1;
3  static const uint64_t reduce_mask_51 = ((uint64_t)1 &lt;&lt; 51) - 1;
4  static const uint64_t reduce_mask_56 = ((uint64_t)1 &lt;&lt; 56) - 1;
5  DONNA_INLINE static void
6  curve25519_copy(bignum25519 out, const bignum25519 in) {
7  	out[0] = in[0];
8  	out[1] = in[1];
9  	out[2] = in[2];
10  	out[3] = in[3];
11  	out[4] = in[4];
12  }
13  DONNA_INLINE static void
14  curve25519_add(bignum25519 out, const bignum25519 a, const bignum25519 b) {
15  	out[0] = a[0] + b[0];
16  	out[1] = a[1] + b[1];
17  	out[2] = a[2] + b[2];
18  	out[3] = a[3] + b[3];
19  	out[4] = a[4] + b[4];
20  }
21  DONNA_INLINE static void
22  curve25519_add_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b) {
23  	out[0] = a[0] + b[0];
24  	out[1] = a[1] + b[1];
25  	out[2] = a[2] + b[2];
26  	out[3] = a[3] + b[3];
27  	out[4] = a[4] + b[4];
28  }
29  DONNA_INLINE static void
30  curve25519_add_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b) {
31  	uint64_t c;
32  	out[0] = a[0] + b[0]    ; c = (out[0] &gt;&gt; 51); out[0] &amp;= reduce_mask_51;
33  	out[1] = a[1] + b[1] + c; c = (out[1] &gt;&gt; 51); out[1] &amp;= reduce_mask_51;
34  	out[2] = a[2] + b[2] + c; c = (out[2] &gt;&gt; 51); out[2] &amp;= reduce_mask_51;
35  	out[3] = a[3] + b[3] + c; c = (out[3] &gt;&gt; 51); out[3] &amp;= reduce_mask_51;
36  	out[4] = a[4] + b[4] + c; c = (out[4] &gt;&gt; 51); out[4] &amp;= reduce_mask_51;
37  	out[0] += c * 19;
38  }
39  static const uint64_t twoP0      = 0x0fffffffffffda;
40  static const uint64_t twoP1234   = 0x0ffffffffffffe;
41  static const uint64_t fourP0     = 0x1fffffffffffb4;
42  static const uint64_t fourP1234  = 0x1ffffffffffffc;
43  DONNA_INLINE static void
44  curve25519_sub(bignum25519 out, const bignum25519 a, const bignum25519 b) {
45  	out[0] = a[0] + twoP0    - b[0];
46  	out[1] = a[1] + twoP1234 - b[1];
47  	out[2] = a[2] + twoP1234 - b[2];
48  	out[3] = a[3] + twoP1234 - b[3];
49  	out[4] = a[4] + twoP1234 - b[4];
50  }
51  DONNA_INLINE static void
52  curve25519_sub_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b) {
53  	out[0] = a[0] + fourP0    - b[0];
54  	out[1] = a[1] + fourP1234 - b[1];
55  	out[2] = a[2] + fourP1234 - b[2];
56  	out[3] = a[3] + fourP1234 - b[3];
57  	out[4] = a[4] + fourP1234 - b[4];
58  }
59  DONNA_INLINE static void
60  curve25519_sub_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b) {
61  	uint64_t c;
62  	out[0] = a[0] + fourP0    - b[0]    ; c = (out[0] &gt;&gt; 51); out[0] &amp;= reduce_mask_51;
63  	out[1] = a[1] + fourP1234 - b[1] + c; c = (out[1] &gt;&gt; 51); out[1] &amp;= reduce_mask_51;
64  	out[2] = a[2] + fourP1234 - b[2] + c; c = (out[2] &gt;&gt; 51); out[2] &amp;= reduce_mask_51;
65  	out[3] = a[3] + fourP1234 - b[3] + c; c = (out[3] &gt;&gt; 51); out[3] &amp;= reduce_mask_51;
66  	out[4] = a[4] + fourP1234 - b[4] + c; c = (out[4] &gt;&gt; 51); out[4] &amp;= reduce_mask_51;
67  	out[0] += c * 19;
68  }
69  DONNA_INLINE static void
70  curve25519_neg(bignum25519 out, const bignum25519 a) {
71  	uint64_t c;
72  	out[0] = twoP0    - a[0]    ; c = (out[0] &gt;&gt; 51); out[0] &amp;= reduce_mask_51;
73  	out[1] = twoP1234 - a[1] + c; c = (out[1] &gt;&gt; 51); out[1] &amp;= reduce_mask_51;
74  	out[2] = twoP1234 - a[2] + c; c = (out[2] &gt;&gt; 51); out[2] &amp;= reduce_mask_51;
75  	out[3] = twoP1234 - a[3] + c; c = (out[3] &gt;&gt; 51); out[3] &amp;= reduce_mask_51;
76  	out[4] = twoP1234 - a[4] + c; c = (out[4] &gt;&gt; 51); out[4] &amp;= reduce_mask_51;
77  	out[0] += c * 19;
78  }
79  DONNA_INLINE static void
80  curve25519_mul(bignum25519 out, const bignum25519 in2, const bignum25519 in) {
81  #if !defined(HAVE_NATIVE_UINT128)
82  	uint128_t mul;
83  #endif
84  	uint128_t t[5];
85  	uint64_t r0,r1,r2,r3,r4,s0,s1,s2,s3,s4,c;
86  	r0 = in[0];
87  	r1 = in[1];
88  	r2 = in[2];
89  	r3 = in[3];
90  	r4 = in[4];
91  	s0 = in2[0];
92  	s1 = in2[1];
93  	s2 = in2[2];
94  	s3 = in2[3];
95  	s4 = in2[4];
96  #if defined(HAVE_NATIVE_UINT128)
97  	t[0]  =  ((uint128_t) r0) * s0;
98  	t[1]  =  ((uint128_t) r0) * s1 + ((uint128_t) r1) * s0;
99  	t[2]  =  ((uint128_t) r0) * s2 + ((uint128_t) r2) * s0 + ((uint128_t) r1) * s1;
100  	t[3]  =  ((uint128_t) r0) * s3 + ((uint128_t) r3) * s0 + ((uint128_t) r1) * s2 + ((uint128_t) r2) * s1;
101  	t[4]  =  ((uint128_t) r0) * s4 + ((uint128_t) r4) * s0 + ((uint128_t) r3) * s1 + ((uint128_t) r1) * s3 + ((uint128_t) r2) * s2;
102  #else
103  	mul64x64_128(t[0], r0, s0)
104  	mul64x64_128(t[1], r0, s1) mul64x64_128(mul, r1, s0) add128(t[1], mul)
105  	mul64x64_128(t[2], r0, s2) mul64x64_128(mul, r2, s0) add128(t[2], mul) mul64x64_128(mul, r1, s1) add128(t[2], mul)
106  	mul64x64_128(t[3], r0, s3) mul64x64_128(mul, r3, s0) add128(t[3], mul) mul64x64_128(mul, r1, s2) add128(t[3], mul) mul64x64_128(mul, r2, s1) add128(t[3], mul)
107  	mul64x64_128(t[4], r0, s4) mul64x64_128(mul, r4, s0) add128(t[4], mul) mul64x64_128(mul, r3, s1) add128(t[4], mul) mul64x64_128(mul, r1, s3) add128(t[4], mul) mul64x64_128(mul, r2, s2) add128(t[4], mul)
108  #endif
109  	r1 *= 19;
110  	r2 *= 19;
111  	r3 *= 19;
112  	r4 *= 19;
113  #if defined(HAVE_NATIVE_UINT128)
114  	t[0] += ((uint128_t) r4) * s1 + ((uint128_t) r1) * s4 + ((uint128_t) r2) * s3 + ((uint128_t) r3) * s2;
115  	t[1] += ((uint128_t) r4) * s2 + ((uint128_t) r2) * s4 + ((uint128_t) r3) * s3;
116  	t[2] += ((uint128_t) r4) * s3 + ((uint128_t) r3) * s4;
117  	t[3] += ((uint128_t) r4) * s4;
118  #else
119  	mul64x64_128(mul, r4, s1) add128(t[0], mul) mul64x64_128(mul, r1, s4) add128(t[0], mul) mul64x64_128(mul, r2, s3) add128(t[0], mul) mul64x64_128(mul, r3, s2) add128(t[0], mul)
120  	mul64x64_128(mul, r4, s2) add128(t[1], mul) mul64x64_128(mul, r2, s4) add128(t[1], mul) mul64x64_128(mul, r3, s3) add128(t[1], mul)
121  	mul64x64_128(mul, r4, s3) add128(t[2], mul) mul64x64_128(mul, r3, s4) add128(t[2], mul)
122  	mul64x64_128(mul, r4, s4) add128(t[3], mul)
123  #endif
124  	                     r0 = lo128(t[0]) &amp; reduce_mask_51; shr128(c, t[0], 51);
125  	add128_64(t[1], c)   r1 = lo128(t[1]) &amp; reduce_mask_51; shr128(c, t[1], 51);
126  	add128_64(t[2], c)   r2 = lo128(t[2]) &amp; reduce_mask_51; shr128(c, t[2], 51);
127  	add128_64(t[3], c)   r3 = lo128(t[3]) &amp; reduce_mask_51; shr128(c, t[3], 51);
128  	add128_64(t[4], c)   r4 = lo128(t[4]) &amp; reduce_mask_51; shr128(c, t[4], 51);
129  	r0 +=   c * 19; c = r0 &gt;&gt; 51; r0 = r0 &amp; reduce_mask_51;
130  	r1 +=   c;
131  	out[0] = r0;
132  	out[1] = r1;
133  	out[2] = r2;
134  	out[3] = r3;
135  	out[4] = r4;
136  }
137  DONNA_NOINLINE static void
138  curve25519_mul_noinline(bignum25519 out, const bignum25519 in2, const bignum25519 in) {
139  	curve25519_mul(out, in2, in);
140  }
141  DONNA_NOINLINE static void
142  curve25519_square_times(bignum25519 out, const bignum25519 in, uint64_t count) {
143  #if !defined(HAVE_NATIVE_UINT128)
144  	uint128_t mul;
145  #endif
146  	uint128_t t[5];
147  	uint64_t r0,r1,r2,r3,r4,c;
148  	uint64_t d0,d1,d2,d4,d419;
149  	r0 = in[0];
150  	r1 = in[1];
151  	r2 = in[2];
152  	r3 = in[3];
153  	r4 = in[4];
154  	do {
155  		d0 = r0 * 2;
156  		d1 = r1 * 2;
157  		d2 = r2 * 2 * 19;
158  		d419 = r4 * 19;
159  		d4 = d419 * 2;
160  #if defined(HAVE_NATIVE_UINT128)
161  		t[0] = ((uint128_t) r0) * r0 + ((uint128_t) d4) * r1 + (((uint128_t) d2) * (r3     ));
162  		t[1] = ((uint128_t) d0) * r1 + ((uint128_t) d4) * r2 + (((uint128_t) r3) * (r3 * 19));
163  		t[2] = ((uint128_t) d0) * r2 + ((uint128_t) r1) * r1 + (((uint128_t) d4) * (r3     ));
164  		t[3] = ((uint128_t) d0) * r3 + ((uint128_t) d1) * r2 + (((uint128_t) r4) * (d419   ));
165  		t[4] = ((uint128_t) d0) * r4 + ((uint128_t) d1) * r3 + (((uint128_t) r2) * (r2     ));
166  #else
167  		mul64x64_128(t[0], r0, r0) mul64x64_128(mul, d4, r1) add128(t[0], mul) mul64x64_128(mul, d2,      r3) add128(t[0], mul)
168  		mul64x64_128(t[1], d0, r1) mul64x64_128(mul, d4, r2) add128(t[1], mul) mul64x64_128(mul, r3, r3 * 19) add128(t[1], mul)
169  		mul64x64_128(t[2], d0, r2) mul64x64_128(mul, r1, r1) add128(t[2], mul) mul64x64_128(mul, d4,      r3) add128(t[2], mul)
170  		mul64x64_128(t[3], d0, r3) mul64x64_128(mul, d1, r2) add128(t[3], mul) mul64x64_128(mul, r4,    d419) add128(t[3], mul)
171  		mul64x64_128(t[4], d0, r4) mul64x64_128(mul, d1, r3) add128(t[4], mul) mul64x64_128(mul, r2,      r2) add128(t[4], mul)
172  #endif
173  		r0 = lo128(t[0]) &amp; reduce_mask_51;
174  		r1 = lo128(t[1]) &amp; reduce_mask_51; shl128(c, t[0], 13); r1 += c;
175  		r2 = lo128(t[2]) &amp; reduce_mask_51; shl128(c, t[1], 13); r2 += c;
176  		r3 = lo128(t[3]) &amp; reduce_mask_51; shl128(c, t[2], 13); r3 += c;
177  		r4 = lo128(t[4]) &amp; reduce_mask_51; shl128(c, t[3], 13); r4 += c; 
178  		                                   shl128(c, t[4], 13); r0 += c * 19;
179  		               c = r0 &gt;&gt; 51; r0 &amp;= reduce_mask_51;
180  		r1 += c     ;  c = r1 &gt;&gt; 51; r1 &amp;= reduce_mask_51;
181  		r2 += c     ;  c = r2 &gt;&gt; 51; r2 &amp;= reduce_mask_51;
182  		r3 += c     ;  c = r3 &gt;&gt; 51; r3 &amp;= reduce_mask_51;
183  		r4 += c     ;  c = r4 &gt;&gt; 51; r4 &amp;= reduce_mask_51;
184  		r0 += c * 19;
185  	} while(--count);
186  	out[0] = r0;
187  	out[1] = r1;
188  	out[2] = r2;
189  	out[3] = r3;
190  	out[4] = r4;
191  }
192  DONNA_INLINE static void
193  curve25519_square(bignum25519 out, const bignum25519 in) {
194  #if !defined(HAVE_NATIVE_UINT128)
195  	uint128_t mul;
196  #endif
197  	uint128_t t[5];
198  	uint64_t r0,r1,r2,r3,r4,c;
199  	uint64_t d0,d1,d2,d4,d419;
200  	r0 = in[0];
201  	r1 = in[1];
202  	r2 = in[2];
203  	r3 = in[3];
204  	r4 = in[4];
205  	d0 = r0 * 2;
206  	d1 = r1 * 2;
207  	d2 = r2 * 2 * 19;
208  	d419 = r4 * 19;
209  	d4 = d419 * 2;
210  #if defined(HAVE_NATIVE_UINT128)
211  	t[0] = ((uint128_t) r0) * r0 + ((uint128_t) d4) * r1 + (((uint128_t) d2) * (r3     ));
212  	t[1] = ((uint128_t) d0) * r1 + ((uint128_t) d4) * r2 + (((uint128_t) r3) * (r3 * 19));
213  	t[2] = ((uint128_t) d0) * r2 + ((uint128_t) r1) * r1 + (((uint128_t) d4) * (r3     ));
214  	t[3] = ((uint128_t) d0) * r3 + ((uint128_t) d1) * r2 + (((uint128_t) r4) * (d419   ));
215  	t[4] = ((uint128_t) d0) * r4 + ((uint128_t) d1) * r3 + (((uint128_t) r2) * (r2     ));
216  #else
217  	mul64x64_128(t[0], r0, r0) mul64x64_128(mul, d4, r1) add128(t[0], mul) mul64x64_128(mul, d2,      r3) add128(t[0], mul)
218  	mul64x64_128(t[1], d0, r1) mul64x64_128(mul, d4, r2) add128(t[1], mul) mul64x64_128(mul, r3, r3 * 19) add128(t[1], mul)
219  	mul64x64_128(t[2], d0, r2) mul64x64_128(mul, r1, r1) add128(t[2], mul) mul64x64_128(mul, d4,      r3) add128(t[2], mul)
220  	mul64x64_128(t[3], d0, r3) mul64x64_128(mul, d1, r2) add128(t[3], mul) mul64x64_128(mul, r4,    d419) add128(t[3], mul)
221  	mul64x64_128(t[4], d0, r4) mul64x64_128(mul, d1, r3) add128(t[4], mul) mul64x64_128(mul, r2,      r2) add128(t[4], mul)
222  #endif
<span onclick='openModal()' class='match'>223  	                     r0 = lo128(t[0]) &amp; reduce_mask_51; shr128(c, t[0], 51);
224  	add128_64(t[1], c)   r1 = lo128(t[1]) &amp; reduce_mask_51; shr128(c, t[1], 51);
225  	add128_64(t[2], c)   r2 = lo128(t[2]) &amp; reduce_mask_51; shr128(c, t[2], 51);
226  	add128_64(t[3], c)   r3 = lo128(t[3]) &amp; reduce_mask_51; shr128(c, t[3], 51);
227  	add128_64(t[4], c)   r4 = lo128(t[4]) &amp; reduce_mask_51; shr128(c, t[4], 51);
228  	r0 +=   c * 19; c = r0 &gt;&gt; 51; r0 = r0 &amp; reduce_mask_51;
229  	r1 +=   c;
230  	out[0] = r0;
231  	out[1] = r1;
232  	out[2] = r2;
233  	out[3] = r3;
234  	out[4] = r4;
235  }
236  DONNA_INLINE static void
237  curve25519_expand(bignum25519 out, const unsigned char *in) {
</span>238  	static const union { uint8_t b[2]; uint16_t s; } endian_check = {{1,0}};
239  	uint64_t x0,x1,x2,x3;
240  	if (endian_check.s == 1) {
241  		x0 = *(uint64_t *)(in + 0);
242  		x1 = *(uint64_t *)(in + 8);
243  		x2 = *(uint64_t *)(in + 16);
244  		x3 = *(uint64_t *)(in + 24);
245  	} else {
246  		#define F_curve25519_expand(s)                         \
247  			((((uint64_t)in[s + 0])      ) | \
248  			 (((uint64_t)in[s + 1]) &lt;&lt;  8) | \
249  			 (((uint64_t)in[s + 2]) &lt;&lt; 16) | \
250  			 (((uint64_t)in[s + 3]) &lt;&lt; 24) | \
251  			 (((uint64_t)in[s + 4]) &lt;&lt; 32) | \
252  			 (((uint64_t)in[s + 5]) &lt;&lt; 40) | \
253  			 (((uint64_t)in[s + 6]) &lt;&lt; 48) | \
254  			 (((uint64_t)in[s + 7]) &lt;&lt; 56))
255  		x0 = F_curve25519_expand(0);
256  		x1 = F_curve25519_expand(8);
257  		x2 = F_curve25519_expand(16);
258  		x3 = F_curve25519_expand(24);
259  	}
260  	out[0] = x0 &amp; reduce_mask_51; x0 = (x0 &gt;&gt; 51) | (x1 &lt;&lt; 13);
261  	out[1] = x0 &amp; reduce_mask_51; x1 = (x1 &gt;&gt; 38) | (x2 &lt;&lt; 26);
262  	out[2] = x1 &amp; reduce_mask_51; x2 = (x2 &gt;&gt; 25) | (x3 &lt;&lt; 39);
263  	out[3] = x2 &amp; reduce_mask_51; x3 = (x3 &gt;&gt; 12);
264  	out[4] = x3 &amp; reduce_mask_51;
265  }
266  DONNA_INLINE static void
267  curve25519_contract(unsigned char *out, const bignum25519 input) {
268  	uint64_t t[5];
269  	uint64_t f, i;
270  	t[0] = input[0];
271  	t[1] = input[1];
272  	t[2] = input[2];
273  	t[3] = input[3];
274  	t[4] = input[4];
275  	#define curve25519_contract_carry() \
276  		t[1] += t[0] &gt;&gt; 51; t[0] &amp;= reduce_mask_51; \
277  		t[2] += t[1] &gt;&gt; 51; t[1] &amp;= reduce_mask_51; \
278  		t[3] += t[2] &gt;&gt; 51; t[2] &amp;= reduce_mask_51; \
279  		t[4] += t[3] &gt;&gt; 51; t[3] &amp;= reduce_mask_51;
280  	#define curve25519_contract_carry_full() curve25519_contract_carry() \
281  		t[0] += 19 * (t[4] &gt;&gt; 51); t[4] &amp;= reduce_mask_51;
282  	#define curve25519_contract_carry_final() curve25519_contract_carry() \
283  		t[4] &amp;= reduce_mask_51;
284  	curve25519_contract_carry_full()
285  	curve25519_contract_carry_full()
286  	t[0] += 19;
287  	curve25519_contract_carry_full()
288  	t[0] += (reduce_mask_51 + 1) - 19;
289  	t[1] += (reduce_mask_51 + 1) - 1;
290  	t[2] += (reduce_mask_51 + 1) - 1;
291  	t[3] += (reduce_mask_51 + 1) - 1;
292  	t[4] += (reduce_mask_51 + 1) - 1;
293  	curve25519_contract_carry_final()
294  	#define write51full(n,shift) \
295  		f = ((t[n] &gt;&gt; shift) | (t[n+1] &lt;&lt; (51 - shift))); \
296  		for (i = 0; i &lt; 8; i++, f &gt;&gt;= 8) *out++ = (unsigned char)f;
297  	#define write51(n) write51full(n,13*n)
298  	write51(0)
299  	write51(1)
300  	write51(2)
301  	write51(3)
302  }
303  #if !defined(ED25519_GCC_64BIT_CHOOSE)
304  DONNA_INLINE static void
305  curve25519_move_conditional_bytes(uint8_t out[96], const uint8_t in[96], uint64_t flag) {
306  	const uint64_t nb = flag - 1, b = ~nb;
307  	const uint64_t *inq = (const uint64_t *)in;
308  	uint64_t *outq = (uint64_t *)out;
309  	outq[0] = (outq[0] &amp; nb) | (inq[0] &amp; b);
310  	outq[1] = (outq[1] &amp; nb) | (inq[1] &amp; b);
311  	outq[2] = (outq[2] &amp; nb) | (inq[2] &amp; b);
312  	outq[3] = (outq[3] &amp; nb) | (inq[3] &amp; b);
313  	outq[4] = (outq[4] &amp; nb) | (inq[4] &amp; b);
314  	outq[5] = (outq[5] &amp; nb) | (inq[5] &amp; b);
315  	outq[6] = (outq[6] &amp; nb) | (inq[6] &amp; b);
316  	outq[7] = (outq[7] &amp; nb) | (inq[7] &amp; b);
317  	outq[8] = (outq[8] &amp; nb) | (inq[8] &amp; b);
318  	outq[9] = (outq[9] &amp; nb) | (inq[9] &amp; b);
319  	outq[10] = (outq[10] &amp; nb) | (inq[10] &amp; b);
320  	outq[11] = (outq[11] &amp; nb) | (inq[11] &amp; b);
321  }
322  DONNA_INLINE static void
323  curve25519_swap_conditional(bignum25519 a, bignum25519 b, uint64_t iswap) {
324  	const uint64_t swap = (uint64_t)(-(int64_t)iswap);
325  	uint64_t x0,x1,x2,x3,x4;
326  	x0 = swap &amp; (a[0] ^ b[0]); a[0] ^= x0; b[0] ^= x0;
327  	x1 = swap &amp; (a[1] ^ b[1]); a[1] ^= x1; b[1] ^= x1;
328  	x2 = swap &amp; (a[2] ^ b[2]); a[2] ^= x2; b[2] ^= x2;
329  	x3 = swap &amp; (a[3] ^ b[3]); a[3] ^= x3; b[3] ^= x3;
330  	x4 = swap &amp; (a[4] ^ b[4]); a[4] ^= x4; b[4] ^= x4;
331  }
332  #endif &amp;bsol;* ED25519_GCC_64BIT_CHOOSE */
333  #define ED25519_64BIT_TABLES
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-curve25519-donna-64bit.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-curve25519-donna-64bit.h</div>
                </div>
                <div class="column column_space"><pre><code>124  	                     r0 = lo128(t[0]) &amp; reduce_mask_51; shr128(c, t[0], 51);
125  	add128_64(t[1], c)   r1 = lo128(t[1]) &amp; reduce_mask_51; shr128(c, t[1], 51);
126  	add128_64(t[2], c)   r2 = lo128(t[2]) &amp; reduce_mask_51; shr128(c, t[2], 51);
127  	add128_64(t[3], c)   r3 = lo128(t[3]) &amp; reduce_mask_51; shr128(c, t[3], 51);
128  	add128_64(t[4], c)   r4 = lo128(t[4]) &amp; reduce_mask_51; shr128(c, t[4], 51);
129  	r0 +=   c * 19; c = r0 &gt;&gt; 51; r0 = r0 &amp; reduce_mask_51;
130  	r1 +=   c;
131  	out[0] = r0;
132  	out[1] = r1;
133  	out[2] = r2;
134  	out[3] = r3;
135  	out[4] = r4;
136  }
137  DONNA_NOINLINE static void
138  curve25519_mul_noinline(bignum25519 out, const bignum25519 in2, const bignum25519 in) {
</pre></code></div>
                <div class="column column_space"><pre><code>223  	                     r0 = lo128(t[0]) &amp; reduce_mask_51; shr128(c, t[0], 51);
224  	add128_64(t[1], c)   r1 = lo128(t[1]) &amp; reduce_mask_51; shr128(c, t[1], 51);
225  	add128_64(t[2], c)   r2 = lo128(t[2]) &amp; reduce_mask_51; shr128(c, t[2], 51);
226  	add128_64(t[3], c)   r3 = lo128(t[3]) &amp; reduce_mask_51; shr128(c, t[3], 51);
227  	add128_64(t[4], c)   r4 = lo128(t[4]) &amp; reduce_mask_51; shr128(c, t[4], 51);
228  	r0 +=   c * 19; c = r0 &gt;&gt; 51; r0 = r0 &amp; reduce_mask_51;
229  	r1 +=   c;
230  	out[0] = r0;
231  	out[1] = r1;
232  	out[2] = r2;
233  	out[3] = r3;
234  	out[4] = r4;
235  }
236  DONNA_INLINE static void
237  curve25519_expand(bignum25519 out, const unsigned char *in) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    