<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_stochastic_pooling.cpp & test_dummy_data_layer.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_stochastic_pooling.cpp & test_dummy_data_layer.cpp
      </h3>
      <h1 align="center">
        23.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_stochastic_pooling.cpp (25.388601%)<TH>test_dummy_data_layer.cpp (21.681416%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2292-0.html#0',2,'match2292-1.html#0',3)" NAME="0">(134-136)<TD><A HREF="javascript:ZweiFrames('match2292-0.html#0',2,'match2292-1.html#0',3)" NAME="0">(61-63)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2292-0.html#1',2,'match2292-1.html#1',3)" NAME="1">(137-138)<TD><A HREF="javascript:ZweiFrames('match2292-0.html#1',2,'match2292-1.html#1',3)" NAME="1">(106-107)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2292-0.html#2',2,'match2292-1.html#2',3)" NAME="2">(95-96)<TD><A HREF="javascript:ZweiFrames('match2292-0.html#2',2,'match2292-1.html#2',3)" NAME="2">(100-101)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2292-0.html#3',2,'match2292-1.html#3',3)" NAME="3">(93-94)<TD><A HREF="javascript:ZweiFrames('match2292-0.html#3',2,'match2292-1.html#3',3)" NAME="3">(68-69)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_stochastic_pooling.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;algorithm&gt;
#include &lt;vector&gt;

#include &quot;gtest/gtest.h&quot;

#include &quot;caffe/blob.hpp&quot;
#include &quot;caffe/common.hpp&quot;
#include &quot;caffe/filler.hpp&quot;
#include &quot;caffe/layers/pooling_layer.hpp&quot;

#include &quot;caffe/test/test_caffe_main.hpp&quot;
#include &quot;caffe/test/test_gradient_check_util.hpp&quot;

using std::min;

namespace caffe {

template &lt;typename TypeParam&gt;
class StochasticPoolingLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
  typedef typename TypeParam::Dtype Dtype;

 protected:
  StochasticPoolingLayerTest()
      : blob_bottom_(new Blob&lt;Dtype&gt;()),
        blob_top_(new Blob&lt;Dtype&gt;()) {}
  virtual void SetUp() {
    Caffe::set_random_seed(1701);
    blob_bottom_-&gt;Reshape(2, 3, 6, 5);
    // fill the values
    FillerParameter filler_param;
    filler_param.set_min(0.1);
    filler_param.set_max(1.);
    UniformFiller&lt;Dtype&gt; filler(filler_param);
    filler.Fill(this-&gt;blob_bottom_);
    blob_bottom_vec_.push_back(blob_bottom_);
    blob_top_vec_.push_back(blob_top_);
  }

  virtual ~StochasticPoolingLayerTest() {
    delete blob_bottom_; delete blob_top_;
  }

  Blob&lt;Dtype&gt;* const blob_bottom_;
  Blob&lt;Dtype&gt;* const blob_top_;
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
};

template &lt;typename Dtype&gt;
class CPUStochasticPoolingLayerTest
  : public StochasticPoolingLayerTest&lt;CPUDevice&lt;Dtype&gt; &gt; {
};

TYPED_TEST_CASE(CPUStochasticPoolingLayerTest, TestDtypes);

TYPED_TEST(CPUStochasticPoolingLayerTest, TestSetup) {
  LayerParameter layer_param;
  PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
  pooling_param-&gt;set_kernel_size(3);
  pooling_param-&gt;set_stride(2);
  PoolingLayer&lt;TypeParam&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_-&gt;num(), this-&gt;blob_bottom_-&gt;num());
  EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), this-&gt;blob_bottom_-&gt;channels());
  EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 3);
  EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 2);
}

#ifndef CPU_ONLY

template &lt;typename Dtype&gt;
class GPUStochasticPoolingLayerTest
  : public StochasticPoolingLayerTest&lt;GPUDevice&lt;Dtype&gt; &gt; {
};

TYPED_TEST_CASE(GPUStochasticPoolingLayerTest, TestDtypes);

TYPED_TEST(GPUStochasticPoolingLayerTest, TestStochastic) {
  LayerParameter layer_param;
  layer_param.set_phase(TRAIN);
  PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
  pooling_param-&gt;set_kernel_size(3);
  pooling_param-&gt;set_stride(2);
  pooling_param-&gt;set_pool(PoolingParameter_PoolMethod_STOCHASTIC);
  PoolingLayer&lt;TypeParam&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);

  // Check if the output is correct - it should do random sampling
<A NAME="3"></A>  const TypeParam* bottom_data = this-&gt;blob_bottom_-&gt;cpu_data();
  const TypeParam* top_data = this-&gt;blob_top_-&gt;cpu_data();
<A NAME="2"></A>  TypeParam total = 0;
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2292-1.html#3',3,'match2292-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  for (int n = 0; n &lt; this-&gt;blob_top_-&gt;num(); ++n) {
    for (int c = 0; c &lt; this-&gt;blob_top_-&gt;channels(); ++c) {</B></FONT>
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2292-1.html#2',3,'match2292-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>      for (int ph = 0; ph &lt; this-&gt;blob_top_-&gt;height(); ++ph) {
        for (int pw = 0; pw &lt; this-&gt;blob_top_-&gt;width(); ++pw) {</B></FONT>
          TypeParam pooled = top_data[this-&gt;blob_top_-&gt;offset(n, c, ph, pw)];
          total += pooled;
          int hstart = ph * 2;
          int hend = min(hstart + 3, this-&gt;blob_bottom_-&gt;height());
          int wstart = pw * 2;
          int wend = min(wstart + 3, this-&gt;blob_bottom_-&gt;width());
          bool has_equal = false;
          for (int h = hstart; h &lt; hend; ++h) {
            for (int w = wstart; w &lt; wend; ++w) {
              has_equal |= (pooled == bottom_data[this-&gt;blob_bottom_-&gt;
                  offset(n, c, h, w)]);
            }
          }
          EXPECT_TRUE(has_equal);
        }
      }
    }
  }
  // When we are doing stochastic pooling, the average we get should be higher
  // than the simple data average since we are weighting more on higher-valued
  // ones.
  EXPECT_GE(total / this-&gt;blob_top_-&gt;count(), 0.55);
}

TYPED_TEST(GPUStochasticPoolingLayerTest, TestStochasticTestPhase) {
  LayerParameter layer_param;
  layer_param.set_phase(TEST);
  PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
  pooling_param-&gt;set_kernel_size(3);
  pooling_param-&gt;set_stride(2);
  pooling_param-&gt;set_pool(PoolingParameter_PoolMethod_STOCHASTIC);
  PoolingLayer&lt;TypeParam&gt; layer(layer_param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
<A NAME="0"></A>
  // Check if the output is correct - it should do random sampling
  const TypeParam* bottom_data = this-&gt;blob_bottom_-&gt;cpu_data();
<A NAME="1"></A><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2292-1.html#0',3,'match2292-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  const TypeParam* top_data = this-&gt;blob_top_-&gt;cpu_data();
  for (int n = 0; n &lt; this-&gt;blob_top_-&gt;num(); ++n) {
    for (int c = 0; c &lt; this-&gt;blob_top_-&gt;channels(); ++c) {</B></FONT>
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2292-1.html#1',3,'match2292-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>      for (int ph = 0; ph &lt; this-&gt;blob_top_-&gt;height(); ++ph) {
        for (int pw = 0; pw &lt; this-&gt;blob_top_-&gt;width(); ++pw) {</B></FONT>
          TypeParam pooled = top_data[this-&gt;blob_top_-&gt;offset(n, c, ph, pw)];
          int hstart = ph * 2;
          int hend = min(hstart + 3, this-&gt;blob_bottom_-&gt;height());
          int wstart = pw * 2;
          int wend = min(wstart + 3, this-&gt;blob_bottom_-&gt;width());
          bool smaller_than_max = false;
          for (int h = hstart; h &lt; hend; ++h) {
            for (int w = wstart; w &lt; wend; ++w) {
              smaller_than_max |= (pooled &lt;= bottom_data[this-&gt;blob_bottom_-&gt;
                  offset(n, c, h, w)]);
            }
          }
          EXPECT_TRUE(smaller_than_max);
        }
      }
    }
  }
}

TYPED_TEST(GPUStochasticPoolingLayerTest, TestGradient) {
  LayerParameter layer_param;
  layer_param.set_phase(TRAIN);
  PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
  pooling_param-&gt;set_kernel_size(3);
  pooling_param-&gt;set_stride(2);
  pooling_param-&gt;set_pool(PoolingParameter_PoolMethod_STOCHASTIC);
  PoolingLayer&lt;TypeParam&gt; layer(layer_param);
  GradientChecker&lt;TypeParam&gt; checker(1e-4, 1e-2);
  // it is too expensive to call curand multiple times, so we don't do an
  // exhaustive gradient check.
  checker.CheckGradient(&amp;layer, this-&gt;blob_bottom_vec_,
      this-&gt;blob_top_vec_);
}

#endif

}  // namespace caffe
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_dummy_data_layer.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;string&gt;
#include &lt;vector&gt;

#include &quot;gtest/gtest.h&quot;

#include &quot;caffe/blob.hpp&quot;
#include &quot;caffe/common.hpp&quot;
#include &quot;caffe/layers/dummy_data_layer.hpp&quot;
#include &quot;caffe/proto/caffe.pb.h&quot;

#include &quot;caffe/test/test_caffe_main.hpp&quot;

namespace caffe {

template &lt;typename Dtype&gt;
class DummyDataLayerTest : public CPUDeviceTest&lt;Dtype&gt; {
 protected:
  DummyDataLayerTest()
      : blob_top_a_(new Blob&lt;Dtype&gt;()),
        blob_top_b_(new Blob&lt;Dtype&gt;()),
        blob_top_c_(new Blob&lt;Dtype&gt;()) {}

  virtual void SetUp() {
    blob_bottom_vec_.clear();
    blob_top_vec_.clear();
    blob_top_vec_.push_back(blob_top_a_);
    blob_top_vec_.push_back(blob_top_b_);
    blob_top_vec_.push_back(blob_top_c_);
  }

  virtual ~DummyDataLayerTest() {
    delete blob_top_a_;
    delete blob_top_b_;
    delete blob_top_c_;
  }

  Blob&lt;Dtype&gt;* const blob_top_a_;
  Blob&lt;Dtype&gt;* const blob_top_b_;
  Blob&lt;Dtype&gt;* const blob_top_c_;
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
  vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
};

TYPED_TEST_CASE(DummyDataLayerTest, TestDtypes);

TYPED_TEST(DummyDataLayerTest, TestOneTopConstant) {
  LayerParameter param;
  DummyDataParameter* dummy_data_param = param.mutable_dummy_data_param();
  dummy_data_param-&gt;add_num(5);
  dummy_data_param-&gt;add_channels(3);
  dummy_data_param-&gt;add_height(2);
  dummy_data_param-&gt;add_width(4);
  this-&gt;blob_top_vec_.resize(1);
  DummyDataLayer&lt;TypeParam&gt; layer(param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;num(), 5);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;channels(), 3);
<A NAME="0"></A>  EXPECT_EQ(this-&gt;blob_top_a_-&gt;height(), 2);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;width(), 4);
  EXPECT_EQ(this-&gt;blob_top_b_-&gt;count(), 0);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2292-0.html#0',2,'match2292-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  EXPECT_EQ(this-&gt;blob_top_c_-&gt;count(), 0);
  for (int i = 0; i &lt; this-&gt;blob_top_vec_.size(); ++i) {
    for (int j = 0; j &lt; this-&gt;blob_top_vec_[i]-&gt;count(); ++j) {</B></FONT>
      EXPECT_EQ(0, this-&gt;blob_top_vec_[i]-&gt;cpu_data()[j]);
<A NAME="3"></A>    }
  }
  layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2292-0.html#3',2,'match2292-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  for (int i = 0; i &lt; this-&gt;blob_top_vec_.size(); ++i) {
    for (int j = 0; j &lt; this-&gt;blob_top_vec_[i]-&gt;count(); ++j) {</B></FONT>
      EXPECT_EQ(0, this-&gt;blob_top_vec_[i]-&gt;cpu_data()[j]);
    }
  }
}

TYPED_TEST(DummyDataLayerTest, TestTwoTopConstant) {
  LayerParameter param;
  DummyDataParameter* dummy_data_param = param.mutable_dummy_data_param();
  dummy_data_param-&gt;add_num(5);
  dummy_data_param-&gt;add_channels(3);
  dummy_data_param-&gt;add_height(2);
  dummy_data_param-&gt;add_width(4);
  dummy_data_param-&gt;add_num(5);
  // Don't explicitly set number of channels or height for 2nd top blob; should
  // default to first channels and height (as we check later).
  dummy_data_param-&gt;add_height(1);
  FillerParameter* data_filler_param = dummy_data_param-&gt;add_data_filler();
  data_filler_param-&gt;set_value(7);
  this-&gt;blob_top_vec_.resize(2);
  DummyDataLayer&lt;TypeParam&gt; layer(param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;num(), 5);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;channels(), 3);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;height(), 2);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;width(), 4);
  EXPECT_EQ(this-&gt;blob_top_b_-&gt;num(), 5);
  EXPECT_EQ(this-&gt;blob_top_b_-&gt;channels(), 3);
<A NAME="2"></A>  EXPECT_EQ(this-&gt;blob_top_b_-&gt;height(), 1);
  EXPECT_EQ(this-&gt;blob_top_b_-&gt;width(), 4);
  EXPECT_EQ(this-&gt;blob_top_c_-&gt;count(), 0);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2292-0.html#2',2,'match2292-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  for (int i = 0; i &lt; this-&gt;blob_top_vec_.size(); ++i) {
    for (int j = 0; j &lt; this-&gt;blob_top_vec_[i]-&gt;count(); ++j) {</B></FONT>
      EXPECT_EQ(7, this-&gt;blob_top_vec_[i]-&gt;cpu_data()[j]);
<A NAME="1"></A>    }
  }
  layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2292-0.html#1',2,'match2292-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  for (int i = 0; i &lt; this-&gt;blob_top_vec_.size(); ++i) {
    for (int j = 0; j &lt; this-&gt;blob_top_vec_[i]-&gt;count(); ++j) {</B></FONT>
      EXPECT_EQ(7, this-&gt;blob_top_vec_[i]-&gt;cpu_data()[j]);
    }
  }
}

TYPED_TEST(DummyDataLayerTest, TestThreeTopConstantGaussianConstant) {
  LayerParameter param;
  DummyDataParameter* dummy_data_param = param.mutable_dummy_data_param();
  dummy_data_param-&gt;add_num(5);
  dummy_data_param-&gt;add_channels(3);
  dummy_data_param-&gt;add_height(2);
  dummy_data_param-&gt;add_width(4);
  FillerParameter* data_filler_param_a = dummy_data_param-&gt;add_data_filler();
  data_filler_param_a-&gt;set_value(7);
  FillerParameter* data_filler_param_b = dummy_data_param-&gt;add_data_filler();
  data_filler_param_b-&gt;set_type(&quot;gaussian&quot;);
  TypeParam gaussian_mean = 3.0;
  TypeParam gaussian_std = 0.01;
  data_filler_param_b-&gt;set_mean(gaussian_mean);
  data_filler_param_b-&gt;set_std(gaussian_std);
  FillerParameter* data_filler_param_c = dummy_data_param-&gt;add_data_filler();
  data_filler_param_c-&gt;set_value(9);
  DummyDataLayer&lt;TypeParam&gt; layer(param);
  layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;num(), 5);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;channels(), 3);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;height(), 2);
  EXPECT_EQ(this-&gt;blob_top_a_-&gt;width(), 4);
  EXPECT_EQ(this-&gt;blob_top_b_-&gt;num(), 5);
  EXPECT_EQ(this-&gt;blob_top_b_-&gt;channels(), 3);
  EXPECT_EQ(this-&gt;blob_top_b_-&gt;height(), 2);
  EXPECT_EQ(this-&gt;blob_top_b_-&gt;width(), 4);
  EXPECT_EQ(this-&gt;blob_top_c_-&gt;num(), 5);
  EXPECT_EQ(this-&gt;blob_top_c_-&gt;channels(), 3);
  EXPECT_EQ(this-&gt;blob_top_c_-&gt;height(), 2);
  EXPECT_EQ(this-&gt;blob_top_c_-&gt;width(), 4);
  for (int i = 0; i &lt; this-&gt;blob_top_a_-&gt;count(); ++i) {
    EXPECT_EQ(7, this-&gt;blob_top_a_-&gt;cpu_data()[i]);
  }
  // Blob b uses a Gaussian filler, so SetUp should not have initialized it.
  // Blob b's data should therefore be the default Blob data value: 0.
  for (int i = 0; i &lt; this-&gt;blob_top_b_-&gt;count(); ++i) {
    EXPECT_EQ(0, this-&gt;blob_top_b_-&gt;cpu_data()[i]);
  }
  for (int i = 0; i &lt; this-&gt;blob_top_c_-&gt;count(); ++i) {
    EXPECT_EQ(9, this-&gt;blob_top_c_-&gt;cpu_data()[i]);
  }

  // Do a Forward pass to fill in Blob b with Gaussian data.
  layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  for (int i = 0; i &lt; this-&gt;blob_top_a_-&gt;count(); ++i) {
    EXPECT_EQ(7, this-&gt;blob_top_a_-&gt;cpu_data()[i]);
  }
  // Check that the Gaussian's data has been filled in with values within
  // 10 standard deviations of the mean. Record the first and last sample.
  // to check that they're different after the next Forward pass.
  for (int i = 0; i &lt; this-&gt;blob_top_b_-&gt;count(); ++i) {
    EXPECT_NEAR(gaussian_mean, this-&gt;blob_top_b_-&gt;cpu_data()[i],
                gaussian_std * 10);
  }
  const TypeParam first_gaussian_sample = this-&gt;blob_top_b_-&gt;cpu_data()[0];
  const TypeParam last_gaussian_sample =
      this-&gt;blob_top_b_-&gt;cpu_data()[this-&gt;blob_top_b_-&gt;count() - 1];
  for (int i = 0; i &lt; this-&gt;blob_top_c_-&gt;count(); ++i) {
    EXPECT_EQ(9, this-&gt;blob_top_c_-&gt;cpu_data()[i]);
  }

  // Do another Forward pass to fill in Blob b with Gaussian data again,
  // checking that we get different values.
  layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
  for (int i = 0; i &lt; this-&gt;blob_top_a_-&gt;count(); ++i) {
    EXPECT_EQ(7, this-&gt;blob_top_a_-&gt;cpu_data()[i]);
  }
  for (int i = 0; i &lt; this-&gt;blob_top_b_-&gt;count(); ++i) {
    EXPECT_NEAR(gaussian_mean, this-&gt;blob_top_b_-&gt;cpu_data()[i],
                gaussian_std * 10);
  }
  EXPECT_NE(first_gaussian_sample, this-&gt;blob_top_b_-&gt;cpu_data()[0]);
  EXPECT_NE(last_gaussian_sample,
      this-&gt;blob_top_b_-&gt;cpu_data()[this-&gt;blob_top_b_-&gt;count() - 1]);
  for (int i = 0; i &lt; this-&gt;blob_top_c_-&gt;count(); ++i) {
    EXPECT_EQ(9, this-&gt;blob_top_c_-&gt;cpu_data()[i]);
  }
}

}  // namespace caffe
</PRE>
</div>
  </div>
</body>
</html>
