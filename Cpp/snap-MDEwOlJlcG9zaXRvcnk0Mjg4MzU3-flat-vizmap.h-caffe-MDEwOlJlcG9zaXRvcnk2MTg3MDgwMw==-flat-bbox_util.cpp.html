
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.062473617560153%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.h</h3>
            <pre><code>1  #ifndef vizmap_H
2  #define vizmap_H
3  class TVizMapFrame;
4  ClassHdTP(TVizMapXmlDocBs, PVizMapXmlDocBs);
5  ClassTPV(TVizMapLink, PVizMapLink, TVizMapLinkV) 
6  private:
7      TBool DirP;
8      TInt SrcPointN;
9      TInt DstPointN;
10      TFlt Wgt; 
11      TStr LinkNmStr; 
12      TInt DocId; 
13  public:
14      TVizMapLink(const int& _SrcPointN, const int& _DstPointN,
15          const bool& _DirP): DirP(_DirP), SrcPointN(_SrcPointN),
16          DstPointN(_DstPointN), Wgt(1.0), LinkNmStr(""), DocId(-1) { }
17      static PVizMapLink New(const int& SrcPointN, const int& DstPointN,
18          const bool& DirP) { return new TVizMapLink(SrcPointN, DstPointN, DirP); }
19      TVizMapLink(TSIn& SIn): DirP(SIn), SrcPointN(SIn), DstPointN(SIn),
20          Wgt(SIn), LinkNmStr(SIn), DocId(SIn) { }
21      static PVizMapLink Load(TSIn& SIn) { return new TVizMapLink(SIn); }
22      void Save(TSOut& SOut) const {
23          DirP.Save(SOut); SrcPointN.Save(SOut); DstPointN.Save(SOut);
24          Wgt.Save(SOut); LinkNmStr.Save(SOut); DocId.Save(SOut); }
25      bool IsDir() const { return DirP; }
26      bool IsSrcPointN(const int& PointN) const { return (PointN==SrcPointN); }
27      bool IsDstPointN(const int& PointN) const { return (PointN==DstPointN); }
28      int GetPointN(const int& PointN) const;
29      int GetSrcPointN() const { return SrcPointN; }
30      int GetDstPointN() const { return DstPointN; }
31      double GetWgt() const { return Wgt; }
32      void PutWgt(const double& _Wgt) { Wgt = _Wgt; }
33      bool IsLinkNm() const { return !LinkNmStr.Empty(); }
34      const TStr& GetLinkNm() const { return LinkNmStr; }
35      void PutLinkNm(const TStr& _LinkNmStr) { LinkNmStr = _LinkNmStr; }
36      bool IsDocId() const { return (DocId != -1); }
37      int GetDocId() const { return DocId; }
38      void PutDocId(const int& _DocId) { EAssert(_DocId != -1); DocId = _DocId; }
39  };
40  ClassTPV(TVizMapPoint, PVizMapPoint, TVizMapPointV) 
41  private:
42      TFltV CoordV; 
43      TFlt Wgt; 
44      TStr PointNmStr; 
45      TInt DocId; 
46      TIntV LinkNV; 
47      TIntV CatIdV; 
48  private:
49      void AddCat(const int& CatId) {
50          if (!CatIdV.IsInBin(CatId)) { CatIdV.AddSorted(CatId); } }
51  public:
52      TVizMapPoint(const TFltV& _CoordV): CoordV(_CoordV),
53          Wgt(1.0), PointNmStr(""), DocId(-1), LinkNV(), CatIdV() { };
54      static PVizMapPoint New(const TFltV& CoordV) {
55          return new TVizMapPoint(CoordV); }
56      TVizMapPoint(TSIn& SIn) {
57          CoordV.Load(SIn); Wgt.Load(SIn); PointNmStr.Load(SIn);
58          DocId.Load(SIn); LinkNV.Load(SIn); CatIdV.Load(SIn); }
59      static PVizMapPoint Load(TSIn& SIn) { return new TVizMapPoint(SIn); }
60      void Save(TSOut& SOut) const {
61          CoordV.Save(SOut); Wgt.Save(SOut); PointNmStr.Save(SOut);
62          DocId.Save(SOut); LinkNV.Save(SOut); CatIdV.Save(SOut); }
63      const TFltV& GetCoordV() const { return CoordV; }
64      int GetPointDim() const { return CoordV.Len(); }
65      double GetPointX() const { Assert(CoordV.Len() >= 1); return CoordV[0]; }
66      double GetPointY() const { Assert(CoordV.Len() >= 2); return CoordV[1]; }
67      double GetWgt() const { return Wgt; }
68      void PutWgt(const double& _Wgt) { Wgt = _Wgt; }
69      bool IsPointNm() const { return !PointNmStr.Empty(); }
70      const TStr& GetPointNm() const { return PointNmStr; }
71      void PutPointNm(const TStr& _PointNmStr) { PointNmStr = _PointNmStr; }
72      bool IsDocId() const { return (DocId != -1); }
73      int GetDocId() const { return DocId; }
74      void PutDocId(const int& _DocId) { EAssert(_DocId != -1); DocId = _DocId; }
75      bool IsLinks() const { return !LinkNV.Empty(); }
76      int GetLinks() const { return LinkNV.Len(); }
77      int GetLinkN(const int& LinkNN) const { return LinkNV[LinkNN]; };
78      void PutLinkN(const int& LinkN) { LinkNV.Add(LinkN); }
79      bool IsCats() const { return !CatIdV.Empty(); }
80      int GetCats() const { return CatIdV.Len(); }
81      int GetCatId(const int& CatIdN) const { return CatIdV[CatIdN]; }
82      bool IsCatId(const int& CatId) const { return CatIdV.IsIn(CatId); }
83      friend class TVizMapFrame;
84  };
85  ClassTPV(TVizMapLandscape, PVizMapLandscape, TVizMapLandscapeV) 
86  private:
87      TSFltVV HeightMatrixVV; 
88      TFltV LevelV;
89      TStr LandscapeNmStr; 
90      TIntVV CatMatrixVV; 
91      TIntFltPrH CatIdToCenterH; 
92      TFltVV CalcMatrixVV; 
93      TFltVV CalcStampVV; 
94  public:
95      TVizMapLandscape() { };
96      static PVizMapLandscape New() { return new TVizMapLandscape; }
97      TVizMapLandscape(const TVizMapLandscapeV& CatLandscapeV,
98          const PVizMapLandscape& FullLandscape, const TIntH& CatIdH,
99          const double& MxCover, const double& MnCover, const int& MnCats);
100      static PVizMapLandscape New(const TVizMapLandscapeV& CatLandscapeV,
101          const PVizMapLandscape& FullLandscape, const TIntH& CatIdH, const double& MxCover,
102          const double& MnCover, const int& MnCats) { return new TVizMapLandscape(
103              CatLandscapeV, FullLandscape, CatIdH, MxCover, MnCover, MnCats); }
104      TVizMapLandscape(TSIn& SIn) { HeightMatrixVV.Load(SIn);  LevelV.Load(SIn);
105          LandscapeNmStr.Load(SIn); CatMatrixVV.Load(SIn); CatIdToCenterH.Load(SIn); }
106      static PVizMapLandscape Load(TSIn& SIn) { return new TVizMapLandscape(SIn); }
107      void Save(TSOut& SOut) const { HeightMatrixVV.Save(SOut); LevelV.Save(SOut);
108          LandscapeNmStr.Save(SOut); CatMatrixVV.Save(SOut); CatIdToCenterH.Save(SOut); }
109      int GetXDim() const { return HeightMatrixVV.GetXDim(); }
110      int GetYDim() const { return HeightMatrixVV.GetYDim(); }
111      double GetHeight(const int& XPos, const int& YPos) const {
112          return HeightMatrixVV(XPos, YPos); }
113      const TSFltVV& HeightVV() const { return HeightMatrixVV; }
114      int GetLevels() const { return LevelV.Len(); }
115      double GetLevel(const int& LevelN) const { return LevelV[LevelN]; }
116      const TFltV& GetLevelV() const { return LevelV; }
117      bool IsLandscapeNm() const { return !LandscapeNmStr.Empty(); }
118      const TStr& GetLandscapeNm() const { return LandscapeNmStr; }
119      void PutLandscapeNm(const TStr& _LandscapeNmStr) { LandscapeNmStr = _LandscapeNmStr; }
120      bool IsCatVV() const { return !CatMatrixVV.Empty(); }
121      int GetCat(const int& XPos, const int& YPos) const { return CatMatrixVV(XPos, YPos); }
122      const TIntVV& CatVV() const { return CatMatrixVV; }
123      void PutCatVV(const TIntVV& _CatMatrixVV);
124      int GetCatFromCoord(const double& X, const double& Y);
125      bool IsCat(const int& CatId) const { return CatIdToCenterH.IsKey(CatId); }
126      int GetCats() const { return CatIdToCenterH.Len(); }
127      int GetCatFFirstKeyId() const { return CatIdToCenterH.FFirstKeyId(); }
128      bool GetCatFNextKeyId(int& KeyId) const { return CatIdToCenterH.FNextKeyId(KeyId); }
129      int GetCatId(const int& KeyId) const { return CatIdToCenterH.GetKey(KeyId); }
130      double GetCatX(const int& CatId) const { return CatIdToCenterH.GetDat(CatId).Val1; }
131      double GetCatY(const int& CatId) const { return CatIdToCenterH.GetDat(CatId).Val2; }
132      void CalcStart(const int& XDim, const int& YDim, const double& Sigma);
133      void CalcPutStamp(const double& PointX, const double& PointY, const double& PointWgt);
134      void CalcFinish(const double& MxVal, const int& Levels);
135      friend class TVizMapFrame;
136  };
137  ClassTPV(TVizMapKeyWd, PVizMapKeyWd, TVizMapKeyWdV) 
138  private:
139      TFltV CoordV; 
140      TStr KeyWdStr; 
141  public:
142      TVizMapKeyWd() { };
143      TVizMapKeyWd(const TFltV& _CoordV, const TStr& _KeyWdStr):
144          CoordV(_CoordV), KeyWdStr(_KeyWdStr) {}
145      TVizMapKeyWd(TSIn& SIn) { CoordV.Load(SIn); KeyWdStr.Load(SIn); }
146      static PVizMapKeyWd Load(TSIn& SIn) { return new TVizMapKeyWd(SIn); }
147      void Save(TSOut& SOut) const { CoordV.Save(SOut); KeyWdStr.Save(SOut); }
148      static PVizMapKeyWd New(const TFltV& CoordV, const TStr& KeyWdStr) {
149          return new TVizMapKeyWd(CoordV, KeyWdStr); }
150      const TFltV& GetCoordV() const { return CoordV; }
151      double GetKeyWdX() const { Assert(CoordV.Len() >= 1); return CoordV[0]; }
152      double GetKeyWdY() const { Assert(CoordV.Len() >= 2); return CoordV[1]; }
153      TStr GetKeyWdStr() const { return KeyWdStr; }
154  };
155  ClassTPV(TVizMapFrame, PVizMapFrame, TVizMapFrameV) 
156  private:
157      TVizMapPointV PointV; 
158      TVizMapLinkV LinkV; 
159      TStr FrameNmStr; 
160      TInt FrameSortN; 
161      TVizMapLandscapeV LandscapeV; 
162      PVizMapLandscape QueryLandscape; 
163      PBowDocBs PointBowDocBs;
164      PBowDocBs KeyWdBowDocBs;
165      TBowSpVV KeyWdSpVV;
166      PBowDocBs LinkBowDocBs;
167      TBowSpVV LinkSpVV;
168      TVizMapPointV KeyWdPointV;
169      TVizMapKeyWdV KeyWdV; 
170      TStrH CatNmH;
171      TIntH DId2PointNMap; 
172  private:
173      bool IsPointN(const int& PointN) const { return (0 <= PointN) && (PointN < PointV.Len());}
174  public:
175      TVizMapFrame();
176      static PVizMapFrame New() { return new TVizMapFrame(); }
177      TVizMapFrame(TSIn& SIn);
178      static PVizMapFrame Load(TSIn& SIn) { return new TVizMapFrame(SIn); }
179      TVizMapFrame(TSIn& SIn, PBowDocBs _PointBowDocBs,
180          PBowDocBs _KeyWdBowDocBs, PBowDocBs _LinkBowDocBs);
181      static PVizMapFrame Load(TSIn& SIn, PBowDocBs _PointBowDocBs,
182          PBowDocBs _KeyWdBowDocBs, PBowDocBs _LinkBowDocBs) {
183              return new TVizMapFrame(SIn, _PointBowDocBs,
184                  _KeyWdBowDocBs, _LinkBowDocBs); }
185      void Save(TSOut& SOut, const bool& SaveBows = true) const;
186      bool operator<(const TVizMapFrame& VizMapFrame) const {
187          return FrameSortN < VizMapFrame.FrameSortN; }
188      int GetPoints() const { return PointV.Len(); }
189      PVizMapPoint GetPoint(const int& PointN) const { return PointV[PointN]; }
190      int AddPoint(PVizMapPoint VizMapPoint) { return PointV.Add(VizMapPoint); }
191      int GetPointN(const TFltV& CoordV, const double& Radius) const;
192      int GetRectPointV(const TFltRect& Rect, TIntV& RectPointV) const;
193      int GetLinks() const { return LinkV.Len(); }
194      PVizMapLink GetLink(const int LinkN) const { return LinkV[LinkN]; }
195      int AddLink(PVizMapLink VizMapLink);
196      bool IsFrameNm() const { return !FrameNmStr.Empty(); }
197      const TStr& GetFrameNm() const { return FrameNmStr; }
198      void PutFrameNm(const TStr& _FrameNmStr) { FrameNmStr = _FrameNmStr; }
199      bool IsFrameSortN() const { return FrameSortN != -1; }
200      int GetFrameSortN() const { return FrameSortN; }
201      void PutFrameSortN(const int& _FrameSortN) {
202          IAssert(FrameSortN != -1); FrameSortN = _FrameSortN; }
203      int GetLandscapes() const { return LandscapeV.Len(); }
204      PVizMapLandscape GetLandscape(const int& LandscapeN) const {
205          return LandscapeV[LandscapeN]; }
206      void AddLandscape(const int& XDim, const int& YDim,
207          const double& Sigma, const bool& PointWgtP);
208      void AddLandscapeFromLndMrk(const int& XDim, const int& YDim,
209          const double& Sigma, const TVec<TFltV>& LndMrkPointV);
210      void AddLandscapeWithCats(const int& XDim, const int& YDim,
211          const double& Sigma, const bool& PointWgtP);
212      void PutPointBow(PBowDocBs _PointBowDocBs) {
213          PointBowDocBs = _PointBowDocBs;}
214      PBowDocBs GetPointBow() { return PointBowDocBs; }
215      void PutKeyWdBow(PBowDocBs _KeyWdBowDocBs, const TBowSpVV& _KeyWdSpVV) {
216          KeyWdBowDocBs = _KeyWdBowDocBs; KeyWdSpVV = _KeyWdSpVV; }
217      PBowDocBs GetKeyWdBow() { return KeyWdBowDocBs; }
218      const TBowSpVV& GetKeyWdSpVV() const { return KeyWdSpVV; }
219      void PutLinkBow(PBowDocBs _LinkBowDocBs, const TBowSpVV& _LinkSpVV) {
220          LinkBowDocBs = _LinkBowDocBs; LinkSpVV = _LinkSpVV; }
221      PBowDocBs GetLinkBow() { return LinkBowDocBs; }
222      const TBowSpVV& GetLinkSpVV() const { return LinkSpVV; }
223      int GetDocId(const int& PointN) const;
224      TStr GetDocNm(const int& PointN) const;
225      TStr GetDocBody(const int& PointN) const;
226      TStr GetDocUrl(const int& PointN) const;
227      int AddKeyWdPoint(PVizMapPoint VizMapPoint) { return KeyWdPointV.Add(VizMapPoint); }
228      int GenKeyWd(const TFltV& CoordV, const double& Radius,
229          const int& MxKeyWd, TStrV& KeyWdStrV, const bool& DistWgtP = false,
230          const bool& PointWgtP = false, const bool& BackKeyWdP = false) const;
231      void GenKeyWds(const int& KeyWds, const double& Radius,
232          const int& Candidantes, const int& RndSeed, const TFltRect& Rect);
233      int GetKeyWds() const { return KeyWdV.Len(); }
234      PVizMapKeyWd GetKeyWd(const int& KeyWdN) const { return KeyWdV[KeyWdN]; }
235      int AddCatNm(const TStr& CatNm) { return CatNmH.AddKey(CatNm); }
236      bool IsCatId(const TStr& CatNm) const { return CatNmH.IsKey(CatNm); }
237      int GetCatId(const TStr& CatNm) const { return CatNmH.GetKeyId(CatNm); }
238      int GetCats() const { return CatNmH.Len(); }
239      TStr GetCatNm(const int& CatId) const { return CatNmH.GetKey(CatId); }
240      void AddCat(const int& PointN, const int& CatId);
241      void CalcDId2PointNMap();
242      bool IsDId2PointNMap() const { return !DId2PointNMap.Empty(); }
243      bool IsInDId(const int& DId) const { return DId2PointNMap.IsKey(DId); }
244      int GetPointN(const int& DId) const { return DId2PointNMap.GetDat(DId); }
245      void SaveVrml(const TStr& VrmlFNm, PVizMapLandscape Landscape,
246        const bool& ShowDocNmP = true, const bool& ShowDocPtP = true,
247        const bool& ShowKeyWdP = true, const double& FontSize = 2.0,
248        const TStr& SkyColor = "0.4 0.4 1.0", const TStr& TerrainColor = "0.1 0.5 0.1",
249        const TStr& KeywordColor = "0.9 0.9 0.2", const TStr& DocNmColor = "1.0 0.4 0");
250      void SaveLegend(const TStr& TxtFNm, const int& LegendGridWidth,
251          const int& LegendGridHeight);
252  };
253  ClassTP(TVizMap, PVizMap)
254  private:
255      TVizMapFrameV VizMapFrameV;
256  public:
257      TVizMap() { };
258      static PVizMap New() { return new TVizMap; }
259      TVizMap(const PVizMapFrame& VizMapFrame) { VizMapFrameV.Add(VizMapFrame); };
260      static PVizMap New(const PVizMapFrame& VizMapFrame) {
261          return new TVizMap(VizMapFrame); }
262      TVizMap(TSIn& SIn);
263      static PVizMap Load(TSIn& SIn) { return new TVizMap(SIn); }
264      void Save(TSOut& SOut) const;
265      void AddVizMapFrame(const PVizMapFrame& VizMapFrame, const bool& SortedP);
266      int GetVizMapFrames() const { return VizMapFrameV.Len(); }
267      PVizMapFrame GetVizMapFrame(const int& VizMapFrameN) const {
268          return VizMapFrameV[VizMapFrameN]; }
269      PVizMapFrame GetFirst() const { return VizMapFrameV[0]; }
270      bool Empty() const { return VizMapFrameV.Empty(); }
271      static PVizMap LoadBin(const TStr& FNm) {
272          TFIn FIn(FNm); return TVizMap::Load(FIn); }
273      void SaveBin(const TStr& FNm) { TFOut FOut(FNm); Save(FOut); }
274      static void SaveXmlStart(TSOut& SOut) { SOut.PutStrLn("<docatlas>"); }
275      static void SaveXmlEnd(TSOut& SOut) { SOut.PutStrLn("</docatlas>"); }
276      static void SaveXmlDoc(TSOut& SOut, const TStr& Nm, const TStr& Body,
<span onclick='openModal()' class='match'>277          const TStr& DisplayBody = TStr(), const TStrV& CatNmV = TStrV(),
278          const TStrV& AuthorV = TStrV(), const TStr& FrameNm = TStr(),
279          const int& FrameSortN = -1);
</span>280  };
281  ClassTP(TVizMapLndMrk, PVizMapLndMrk)
282  private:
283      PBowDocBs BowDocBs;
284      PBowDocWgtBs BowDocWgtBs;
285      TBowSpVV LndMrkSpVV;
286      TVec<TFltV> LndMrkPointVV;
287  public:
288      TVizMapLndMrk(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs,
289          const TBowSpVV& _LndMrkSpVV, const TVec<TFltV>& _LndMrkPointVV):
290              BowDocBs(_BowDocBs), BowDocWgtBs(_BowDocWgtBs),
291              LndMrkSpVV(_LndMrkSpVV), LndMrkPointVV(_LndMrkPointVV) { }
292      static PVizMapLndMrk New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
293          const TBowSpVV& LndMrkSpVV, const TVec<TFltV>& LndMrkPointVV) {
294              return new TVizMapLndMrk(BowDocBs, BowDocWgtBs, LndMrkSpVV, LndMrkPointVV); }
295      TVizMapLndMrk(TSIn& SIn) {
296          BowDocBs = TBowDocBs::Load(SIn); BowDocWgtBs = TBowDocWgtBs::Load(SIn);
297          LndMrkSpVV.Load(SIn); LndMrkPointVV.Load(SIn); }
298      static PVizMapLndMrk Load(TSIn& SIn) { return new TVizMapLndMrk(SIn); }
299      void Save(TSOut& SOut) const {
300          BowDocBs->Save(SOut); BowDocWgtBs->Save(SOut);
301          LndMrkSpVV.Save(SOut); LndMrkPointVV.Save(SOut); }
302      PBowDocBs GetBowDocBs() const { return BowDocBs; }
303      PBowDocWgtBs GetBowDocWgtBs() const { return BowDocWgtBs; }
304      const TBowSpVV& GetLndMrkSpVV() const { return LndMrkSpVV; }
305      const TVec<TFltV>& GetLndMrkPointVV() const { return LndMrkPointVV; }
306      int GetLndMrks() const { return LndMrkSpVV.Len(); }
307      int GetLndMrkDId(const int& LndMrkN) const { return BowDocWgtBs->GetDId(LndMrkN); }
308      const TFltV& GetLndMrkPointV(const int& LndMrkN) const { return LndMrkPointVV[LndMrkN]; }
309      PBowSpV GetLndMrkSpV(const int& LndMrkN) const { return LndMrkSpVV[LndMrkN]; }
310      static PVizMapLndMrk LoadBin(const TStr& FNm) {
311          PSIn SIn = TFIn::New(FNm); return TVizMapLndMrk::Load(*SIn); }
312      void SaveBin(const TStr& FNm) { PSOut SOut = TFOut::New(FNm); Save(*SOut); }
313  };
314  ClassTV(TVizMapXmlDoc, TVizMapXmlDocV)
315  public:
316      TStr Nm;
317      TStr Body;
318      TStr DisplayBody;
319      TIntV CatIdV;
320      TIntV AuthorIdV;
321      TStr FrameNm;
322      TInt FrameSortN;
323  public:
324      TVizMapXmlDoc(): FrameNm(), FrameSortN(-1) { }
325      TVizMapXmlDoc(const TStr& _Nm, const TStr& _Body, const TStr& _DisplayBody,
326          const TIntV& _CatIdV, const TIntV& _AuthorIdV, const TStr& _FrameNm,
327          const int& _FrameSortN): Nm(_Nm), Body(_Body), DisplayBody(_DisplayBody),
328              CatIdV(_CatIdV), AuthorIdV(_AuthorIdV), FrameNm(_FrameNm),
329              FrameSortN(_FrameSortN) { }
330      int AddToBowDocBs(PVizMapXmlDocBs VizMapXmlDocBs, PBowDocBs BowDocBs) const;
331  };
332  typedef enum { vmxdgNone, vmxdgDay, vmxdgMonth, vmxdgYear } TVizMapXmlDocGrouping;
333  ClassTP(TVizMapXmlDocBs, PVizMapXmlDocBs)
334  public:
335      TVizMapXmlDocV XmlDocV;
336      TStrH CatNmH;
337      TStrH AuthorNmH;
338      TStrH FrameNmToSortN;
339      TIntIntVH FrameSortNToDocId;
340  public:
341      TVizMapXmlDocBs(const TStr& XmlFNm,
342          const PNotify& Notify = TStdNotify::New());
343      static PVizMapXmlDocBs New(const TStr& XmlFNm,
344          const PNotify& Notify = TStdNotify::New()) {
345              return new TVizMapXmlDocBs(XmlFNm, Notify); }
346      TVizMapXmlDocBs(const PWdGixRSet& RSet,
347          const TVizMapXmlDocGrouping& Grouping,
348          const PNotify& Notify = TStdNotify::New());
349      static PVizMapXmlDocBs New(const PWdGixRSet& RSet,
350          const TVizMapXmlDocGrouping& Grouping,
351          const PNotify& Notify = TStdNotify::New()) {
352              return new TVizMapXmlDocBs(RSet, Grouping, Notify); }
353      static PBowDocBs LoadBowDocBs(const TStr& XmlFNm, PSwSet SwSet,
354          PStemmer Stemmer, const int& MxNGramLen = 3, const int& MnNGramFq = 5);
355  };
356  typedef enum {vxmtStaticDoc, vxmtDynamicDoc,
357      vxmtStaticAuthor, vxmtDynamicAuthor } TVizXmlMapType;
358  typedef enum {vdtEucl, vdtCos, vdtSqrtCos} TVizDistType;
359  class TVizMapFactory {
360  private:
361      static void CG(const TMatrix& Matrix, const TFltV& b, TFltV& x,
362          PNotify Notify, const int& MaxStep = 200, const double& EpsTer = 1e-7);
363  private:
364      static void MakeFlat(PSVMTrainSet Set, const TVizDistType& DistType,
365          TVec<TFltV>& DocPointV, const int& MxStep, const int& MxSecs,
366          const double& MnDiff, const bool& RndStartPos, PNotify Notify);
367      static void NormalizePoints(TVec<TFltV>& PointV);
368      static void LsiMds(TVec<PBowSpV> DocSpV, PSemSpace SemSpace, TVec<TFltV>& DocPointV,
369          const double& SemSpaceThresh, const int& MxStep, const int& MxSecs,
370          const double& MnDiff, PNotify Notify);
371      static PVizMapFrame DocLsiMds(PBowDocWgtBs BowDocWgtBs, PSemSpace SemSpace,
372          const TVec<TFltV>& _DocPointV, const double& SemSpaceThresh,
373          const int& MxStep, const int& MxSecs, const double& MnDiff, PNotify Notify);
374      static void AddDocMetadata(PVizMapFrame VizMapFrame, PBowDocBs PointBowDocBs,
375          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs,
376          PVizMapLndMrk VizMapLndMrk = NULL);
377      static void LndMrk(PBowDocWgtBs BowDocWgtBs, PBowSim BowSim,
378          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
379          TVec<TFltV>& DocPointV, const int& LinCombNum, PNotify Notify);
380      static PVizMapFrame DocLndMrk(PBowDocWgtBs BowDocWgtBs,
381          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
382          const int& LinCombNum = 3, PNotify Notify = TNullNotify::New());
383      static PVizMapFrame ClustLsiMdsDocLndMrk(PBowDocWgtBs BowDocWgtBs,
384          PBowDocPart BowDocPart, PSemSpace SemSpace, const int& LinCombNum,
385          const double& SemSpaceThresh, const int& MxStep, const int& MxSecs,
386          const double& MnDiff, PNotify Notify);
387      static PVizMapFrame NewVizMapFrame(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
388          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs,
389          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
390          const bool& LndPointWgt, const bool& CalcLandscapeP);
391      static PVizMapFrame NewVizMapFrame(PBowDocBs BowDocBs, const int& ThDocs,
392          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
393          const bool& LndPointWgt, const bool& CalcLandscapeP);
394      static PVizMapFrame NewVizMapFrameFromLndMrk(PBowDocBs BowDocBs,
395          PBowDocWgtBs BowDocWgtBs, PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP,
396          const bool& LndMrkKeyWdP, const PNotify& Notify);
397  public:
398      static PVizMap NewVizMap(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
399          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs = 300,
400          const int& Clusts = 200, const double& SvdThreshold = 0.8,
401          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgtP = false,
402          const bool& CalcLandscapeP = true);
403      static PVizMap NewVizMap(PBowDocBs BowDocBs, const int& ThDocs = 300,
404          const int& Clusts = 200, const double& SvdThreshold = 0.8,
405          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgtP = false,
406          const bool& CalcLandscapeP = true);
407      static PVizMap NewVizMapStaticDoc(
408          const PVizMapXmlDocBs& XmlDocBs, PSwSet SwSet = TSwSet::New(swstEn523),
409          PStemmer Stemmer = TStemmer::New(stmtPorter, true),
410          const int& ThDocs = 300, const int& Clusts = 200, const double& SvdThreshold = 0.8,
411          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
412          const bool& CalcLandscapeP = true);
413      static PVizMap NewVizMapDynamicDoc(const PVizMapXmlDocBs& XmlDocBs, PSwSet SwSet = TSwSet::New(swstEn523),
414          PStemmer Stemmer = TStemmer::New(stmtPorter, true),
415          const int& ThDocs = 300, const int& Clusts = 200, const double& SvdThreshold = 0.8,
416          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
417          const bool& CalcLandscapeP = true);
418      static PVizMap NewVizMapStaticAuthor(const PVizMapXmlDocBs& XmlDocBs, PSwSet SwSet = TSwSet::New(swstEn523),
419          PStemmer Stemmer = TStemmer::New(stmtPorter, true), const int& MxAuthors = 100,
420          const int& ThDocs = 300, const int& Clusts = 200, const double& SvdThreshold = 0.8,
421          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
422          const bool& CalcLandscapeP = true);
423      static PVizMap NewVizMapDynamicAuthor(const PVizMapXmlDocBs& XmlDocBs, PSwSet SwSet = TSwSet::New(swstEn523),
424          PStemmer Stemmer = TStemmer::New(stmtPorter, true), const int& MxFrames = 5,
425          const int& MxAuthors = 10, const int& ThDocs = 300, const int& Clusts = 200,
426          const double& SvdThreshold = 0.8, const PNotify& Notify = TStdNotify::New(),
427          const bool& LndPointWgt = false, const bool& CalcLandscapeP = true);
428      static PVizMap NewVizMap(const PVizMapXmlDocBs& XmlDocBs,
429          const TVizXmlMapType& VizXmlMapType, PSwSet SwSet = TSwSet::New(swstEn523),
430          PStemmer Stemmer = TStemmer::New(stmtPorter, true), const int& ThDocs = 300,
431          const int& Clusts = 200, const double& SvdThreshold = 0.8,
432          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
433          const bool& CalcLandscapeP = true);
434      static PVizMap NewVizMap(const TStr& XmlFNm,
435          const TVizXmlMapType& VizXmlMapType, PSwSet SwSet = TSwSet::New(swstEn523),
436          PStemmer Stemmer = TStemmer::New(stmtPorter, true), const int& ThDocs = 300,
437          const int& Clusts = 200, const double& SvdThreshold = 0.8,
438          const PNotify& Notify = TStdNotify::New(), const bool& LndPointWgt = false,
439          const bool& CalcLandscapeP = true);
440      static PVizMapLndMrk NewVizMapLndMrk(PBowDocBs BowDocBs,
441          PBowDocWgtBs BowDocWgtBs, const int& ThDocs = 600, const int& Clusts = 400,
442          const double& SvdThreshold = 0.8, const PNotify& Notify = TStdNotify::New());
443      static PVizMapLndMrk NewVizMapLndMrk(PBowDocBs BowDocBs,
444          const TIntV& DIdV = TIntV(), const int& ThDocs = 600, const int& Clusts = 400,
445          const double& SvdThreshold = 0.8, const PNotify& Notify = TStdNotify::New());
446      static PVizMap NewVizMapFromLndMrk(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
447          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP = false,
448          const bool& LndMrkKeyWdP = false, const PNotify& Notify = TStdNotify::New());
449      static PVizMap NewVizMapFromLndMrk(PBowDocBs BowDocBs, const TIntV& DIdV,
450          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP = false,
451          const bool& LndMrkKeyWdP = false,
452          const TBowWordWgtType& WgtType = bwwtLogDFNrmTFIDF,
453          const PNotify& Notify = TStdNotify::New());
454  };
455  class TVrml {
456  public:
457      static void InsertHeader(PSOut SOut, const TStr& SkyColor);
458      static double InsertEvelationGrid(PSOut SOut, const TSFltVV& Rlf,
459          TFltVV& NewRlf, const TStr& TerrainColor, const int& N = 5,
460          const double& Height = 20.0, const double& Spacing = 0.7);
461      static void InsertBillboard(PSOut SOut, const TFltVV& Rlf,
462          const TStr& Text, const TStr& Color, const TStr& Size,
463          const double& x, const double& y, const double& Height,
464          const double& Scale, bool DoText = true, bool DoPoint = false);
465  };
466  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-bbox_util.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <csignal>
3  #include <ctime>
4  #include <functional>
5  #include <map>
6  #include <set>
7  #include <string>
8  #include <utility>
9  #include <vector>
10  #include "boost/iterator/counting_iterator.hpp"
11  #include "caffe/util/bbox_util.hpp"
12  #ifdef ENABLE_NMS_OPTIMIZATION
13  #include <immintrin.h>
14  #include "omp.h"
15  #endif
16  namespace caffe {
17  bool SortBBoxAscend(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
18    return bbox1.score() < bbox2.score();
19  }
20  bool SortBBoxDescend(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
21    return bbox1.score() > bbox2.score();
22  }
23  template <typename T>
24  bool SortScorePairAscend(const pair<float, T>& pair1,
25                           const pair<float, T>& pair2) {
26    return pair1.first < pair2.first;
27  }
28  template bool SortScorePairAscend(const pair<float, int>& pair1,
29                                    const pair<float, int>& pair2);
30  template bool SortScorePairAscend(const pair<float, pair<int, int> >& pair1,
31                                    const pair<float, pair<int, int> >& pair2);
32  template <typename T>
33  bool SortScorePairDescend(const pair<float, T>& pair1,
34                            const pair<float, T>& pair2) {
35    return pair1.first > pair2.first;
36  }
37  template bool SortScorePairDescend(const pair<float, int>& pair1,
38                                     const pair<float, int>& pair2);
39  template bool SortScorePairDescend(const pair<float, pair<int, int> >& pair1,
40                                     const pair<float, pair<int, int> >& pair2);
41  #ifdef ENABLE_NMS_OPTIMIZATION
42  #define DIVUP(m, n)((m) / (n) + ((m) % (n) > 0))
43  typedef unsigned long long int uint64_t;
44  static inline float max(float a, float b) { return (a) > (b) ? (a) : (b); }
45  static inline float min(float a, float b) { return (a) < (b) ? (a) : (b); }
46  #define MASK_ELEM(x, y) \
47    ((uint64_t*)((char*)mask_tbl + x * blocks * sizeof(uint64_t)) + y)
48  void cpu_nms_avx512_parallize_inner(int* __restrict keep_out, 
49                                      int* __restrict num_out, 
50                                      const float* __restrict x1,
51                                      const float* __restrict y1,
52                                      const float* __restrict x2, 
53                                      const float* __restrict y2,
54                                      int64_t boxes_num, 
55                                      float thresh_f)
56  {
57      const int blocks = DIVUP(boxes_num, 64);
58      uint64_t *mask_tbl = (uint64_t *)aligned_alloc(64, blocks * sizeof(uint64_t));
59      memset(mask_tbl, 0, sizeof(uint64_t) * blocks);
60      uint64_t i = 0, j = 0;
61      uint64_t num_to_keep = 0;
62      for (i = 0; i < boxes_num; i++) {
63          if (mask_tbl[i/64] & (1ull << (i % 64))) {
64              continue;
65          }
66          keep_out[num_to_keep++] = i;
67          __m512 x1_a = _mm512_set1_ps(x1[i]);
68          __m512 x2_a = _mm512_set1_ps(x2[i]);
69          __m512 y1_a = _mm512_set1_ps(y1[i]);
70          __m512 y2_a = _mm512_set1_ps(y2[i]);
71          __m512 zero = _mm512_setzero_ps();
72          __m512 Sa_w = _mm512_sub_ps(x2_a, x1_a);
73          __m512 Sa_h = _mm512_sub_ps(y2_a, y1_a);
74          __m512 Sa = _mm512_mul_ps(Sa_w, Sa_h);
75          __m512 thresh = _mm512_set1_ps(thresh_f);
76          for (j = i + 1; (j & 0xf) && (j < boxes_num); j ++) {
77              if (mask_tbl[j/64] & (1ull << (j % 64))) {
78                  continue;
79              }
80              float xx1 = max(x1[i], x1[j]);
81              float yy1 = max(y1[i], y1[j]);
82              float xx2 = min(x2[i], x2[j]);
83              float yy2 = min(y2[i], y2[j]);
84              float w = max(0.0f, xx2 - xx1 );
85              float h = max(0.0f, yy2 - yy1 );
86              float interS = w * h;
87              float Sa = (x2[i] - x1[i] ) * (y2[i] - y1[i] );
88              float Sb = (x2[j] - x1[j] ) * (y2[j] - y1[j] );
89              if (interS > thresh_f * (Sa + Sb - interS)) {
90                  mask_tbl[j/64] |= 1ull << (j % 64);
91              }
92          }
93          if (!(j & 0xf) && (j & 0x1f) && (j + 16 <= boxes_num)) {
94              __m512 x1_b = _mm512_load_ps(x1 + j);
95              __m512 y1_b = _mm512_load_ps(y1 + j);
96              __m512 x2_b = _mm512_load_ps(x2 + j);
97              __m512 y2_b = _mm512_load_ps(y2 + j);
98              __m512 xx1 = _mm512_max_ps(x1_a, x1_b);
99              __m512 yy1 = _mm512_max_ps(y1_a, y1_b);
100              __m512 xx2 = _mm512_min_ps(x2_a, x2_b);
101              __m512 yy2 = _mm512_min_ps(y2_a, y2_b);
102              __m512 w = _mm512_sub_ps(xx2, xx1);
103              __m512 h = _mm512_sub_ps(yy2, yy1);
104              w = _mm512_max_ps(w, zero);
105              h = _mm512_max_ps(h, zero);
106              __m512 interS = _mm512_mul_ps(w, h);
107              __m512 Sb_w = _mm512_sub_ps(x2_b, x1_b);
108              __m512 Sb_h = _mm512_sub_ps(y2_b, y1_b);
109              __m512 Sb = _mm512_mul_ps(Sb_w, Sb_h);
110              __m512 ovr = _mm512_add_ps(Sa, Sb);
111              ovr = _mm512_sub_ps(ovr, interS);
112              ovr = _mm512_mul_ps(ovr, thresh);
113              __mmask16 gt = _mm512_cmp_ps_mask(interS, ovr, _CMP_GT_OS);
114              uint64_t mask = gt;
115              mask_tbl[j/64] |= (mask) << (j % 64);
116              j += 16;
117          }
118          if (!(j & 0x1f) && (j & 0x3f) && (j + 32 <= boxes_num)) {
119              __m512 x1_b0 = _mm512_load_ps(x1 + j);
120              __m512 y1_b0 = _mm512_load_ps(y1 + j);
121              __m512 x2_b0 = _mm512_load_ps(x2 + j);
122              __m512 y2_b0 = _mm512_load_ps(y2 + j);
123              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
124              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
125              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
126              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
127              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
128              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
129              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
130              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
131              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
132              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
133              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
134              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
135              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
136              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
137              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
138              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
139              w0 = _mm512_max_ps(w0, zero);
140              h0 = _mm512_max_ps(h0, zero);
141              w1 = _mm512_max_ps(w1, zero);
142              h1 = _mm512_max_ps(h1, zero);
143              __m512 interS_0 = _mm512_mul_ps(w0, h0);
144              __m512 interS_1 = _mm512_mul_ps(w1, h1);
145              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
146              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
147              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
148              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
149              __m512 ovr0 = _mm512_fmadd_ps(Sb_w0, Sb_h0, Sa);
150              __m512 ovr1 = _mm512_fmadd_ps(Sb_w1, Sb_h1, Sa);
151              ovr0 = _mm512_sub_ps(ovr0, interS_0);
152              ovr1 = _mm512_sub_ps(ovr1, interS_1);
153              ovr0 = _mm512_mul_ps(ovr0, thresh);
154              ovr1 = _mm512_mul_ps(ovr1, thresh);
155              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
156              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
157              uint64_t mask = (gt0) | ((uint64_t)gt1 << 16);
158              mask_tbl[j/64] |= (mask) << (j % 64);
159              j += 32;
160          }
161          for (; (j + 64) <= boxes_num; j += 64) {
162              __m512 x1_b0 = _mm512_load_ps(x1 + j);
163              __m512 y1_b0 = _mm512_load_ps(y1 + j);
164              __m512 x2_b0 = _mm512_load_ps(x2 + j);
165              __m512 y2_b0 = _mm512_load_ps(y2 + j);
166              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
167              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
168              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
169              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
170              __m512 x1_b2 = _mm512_load_ps(x1 + j + 32);
171              __m512 y1_b2 = _mm512_load_ps(y1 + j + 32);
172              __m512 x2_b2 = _mm512_load_ps(x2 + j + 32);
173              __m512 y2_b2 = _mm512_load_ps(y2 + j + 32);
174              __m512 x1_b3 = _mm512_load_ps(x1 + j + 48);
175              __m512 y1_b3 = _mm512_load_ps(y1 + j + 48);
176              __m512 x2_b3 = _mm512_load_ps(x2 + j + 48);
177              __m512 y2_b3 = _mm512_load_ps(y2 + j + 48);
178              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
179              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
180              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
181              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
182              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
183              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
184              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
185              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
186              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
187              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
188              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
189              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
190              __m512 Sb_w2 = _mm512_sub_ps(x2_b2, x1_b2);
191              __m512 Sb_h2 = _mm512_sub_ps(y2_b2, y1_b2);
192              __m512 Sb_w3 = _mm512_sub_ps(x2_b3, x1_b3);
193              __m512 Sb_h3 = _mm512_sub_ps(y2_b3, y1_b3);
194              __m512 xx1_2 = _mm512_max_ps(x1_a, x1_b2);
195              __m512 yy1_2 = _mm512_max_ps(y1_a, y1_b2);
196              __m512 xx2_2 = _mm512_min_ps(x2_a, x2_b2);
197              __m512 yy2_2 = _mm512_min_ps(y2_a, y2_b2);
198              __m512 xx1_3 = _mm512_max_ps(x1_a, x1_b3);
199              __m512 yy1_3 = _mm512_max_ps(y1_a, y1_b3);
200              __m512 xx2_3 = _mm512_min_ps(x2_a, x2_b3);
201              __m512 yy2_3 = _mm512_min_ps(y2_a, y2_b3);
202              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
203              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
204              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
205              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
206              __m512 w2 = _mm512_sub_ps(xx2_2, xx1_2);
207              __m512 h2 = _mm512_sub_ps(yy2_2, yy1_2);
208              __m512 w3 = _mm512_sub_ps(xx2_3, xx1_3);
209              __m512 h3 = _mm512_sub_ps(yy2_3, yy1_3);
210              w0 = _mm512_max_ps(w0, zero);
211              h0 = _mm512_max_ps(h0, zero);
212              w1 = _mm512_max_ps(w1, zero);
213              h1 = _mm512_max_ps(h1, zero);
214              w2 = _mm512_max_ps(w2, zero);
215              h2 = _mm512_max_ps(h2, zero);
216              w3 = _mm512_max_ps(w3, zero);
217              h3 = _mm512_max_ps(h3, zero);
218              __m512 interS_0 = _mm512_mul_ps(w0, h0);
219              __m512 interS_1 = _mm512_mul_ps(w1, h1);
220              __m512 interS_2 = _mm512_mul_ps(w2, h2);
221              __m512 interS_3 = _mm512_mul_ps(w3, h3);
222              __m512 ovr0 = _mm512_fmadd_ps(Sb_w0, Sb_h0, Sa);
223              __m512 ovr1 = _mm512_fmadd_ps(Sb_w1, Sb_h1, Sa);
224              __m512 ovr2 = _mm512_fmadd_ps(Sb_w2, Sb_h2, Sa);
225              __m512 ovr3 = _mm512_fmadd_ps(Sb_w3, Sb_h3, Sa);
226              ovr0 = _mm512_sub_ps(ovr0, interS_0);
227              ovr1 = _mm512_sub_ps(ovr1, interS_1);
228              ovr2 = _mm512_sub_ps(ovr2, interS_2);
229              ovr3 = _mm512_sub_ps(ovr3, interS_3);
230              ovr0 = _mm512_mul_ps(ovr0, thresh);
231              ovr1 = _mm512_mul_ps(ovr1, thresh);
232              ovr2 = _mm512_mul_ps(ovr2, thresh);
233              ovr3 = _mm512_mul_ps(ovr3, thresh);
234              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
235              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
236              __mmask16 gt2 = _mm512_cmp_ps_mask(interS_2, ovr2, _CMP_GT_OS);
237              __mmask16 gt3 = _mm512_cmp_ps_mask(interS_3, ovr3, _CMP_GT_OS);
238              uint64_t mask = ((uint64_t)(gt0)) | (((uint64_t)gt1) << 16) | (((uint64_t)gt2) << 32) | (((uint64_t)gt3) << 48);
239              mask_tbl[j / 64] |= mask;
240          }
241          if ((j + 32) <= boxes_num) {
242              __m512 x1_b0 = _mm512_load_ps(x1 + j);
243              __m512 y1_b0 = _mm512_load_ps(y1 + j);
244              __m512 x2_b0 = _mm512_load_ps(x2 + j);
245              __m512 y2_b0 = _mm512_load_ps(y2 + j);
246              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
247              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
248              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
249              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
250              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
251              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
252              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
253              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
254              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
255              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
256              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
257              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
258              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
259              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
260              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
261              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
262              w0 = _mm512_max_ps(w0, zero);
263              h0 = _mm512_max_ps(h0, zero);
264              w1 = _mm512_max_ps(w1, zero);
265              h1 = _mm512_max_ps(h1, zero);
266              __m512 interS_0 = _mm512_mul_ps(w0, h0);
267              __m512 interS_1 = _mm512_mul_ps(w1, h1);
268              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
269              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
270              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
271              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
272              __m512 Sb0 = _mm512_mul_ps(Sb_w0, Sb_h0);
273              __m512 Sb1 = _mm512_mul_ps(Sb_w1, Sb_h1);
274              __m512 ovr0 = _mm512_add_ps(Sa, Sb0);
275              __m512 ovr1 = _mm512_add_ps(Sa, Sb1);
276              ovr0 = _mm512_sub_ps(ovr0, interS_0);
277              ovr1 = _mm512_sub_ps(ovr1, interS_1);
278              ovr0 = _mm512_mul_ps(ovr0, thresh);
279              ovr1 = _mm512_mul_ps(ovr1, thresh);
280              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
281              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
282              uint64_t mask = (gt0) | ((uint64_t)gt1 << 16);
283              mask_tbl[(j +  0) / 64] |= (mask) << (j % 64);
284              mask_tbl[(j + 32) / 64] |= (mask) >> (64-(j % 64));
285              j += 32;
286          }
287          if ((j + 16) <= boxes_num) {
288              __m512 x1_b = _mm512_load_ps(x1 + j);
289              __m512 y1_b = _mm512_load_ps(y1 + j);
290              __m512 x2_b = _mm512_load_ps(x2 + j);
291              __m512 y2_b = _mm512_load_ps(y2 + j);
292              __m512 xx1 = _mm512_max_ps(x1_a, x1_b);
293              __m512 yy1 = _mm512_max_ps(y1_a, y1_b);
294              __m512 xx2 = _mm512_min_ps(x2_a, x2_b);
295              __m512 yy2 = _mm512_min_ps(y2_a, y2_b);
296              __m512 w = _mm512_sub_ps(xx2, xx1);
297              __m512 h = _mm512_sub_ps(yy2, yy1);
298              w = _mm512_max_ps(w, zero);
299              h = _mm512_max_ps(h, zero);
300              __m512 interS = _mm512_mul_ps(w, h);
301              __m512 Sb_w = _mm512_sub_ps(x2_b, x1_b);
302              __m512 Sb_h = _mm512_sub_ps(y2_b, y1_b);
303              __m512 Sb = _mm512_mul_ps(Sb_w, Sb_h);
304              __m512 ovr = _mm512_add_ps(Sa, Sb);
305              ovr = _mm512_sub_ps(ovr, interS);
306              ovr = _mm512_mul_ps(ovr, thresh);
307              __mmask16 gt = _mm512_cmp_ps_mask(interS, ovr, _CMP_GT_OS);
308              uint64_t mask = gt;
309              mask_tbl[(j +  0) / 64] |= (mask) << (j % 64);
310              mask_tbl[(j + 16) / 64] |= (mask) >> (64-(j % 64));
311              j += 16;
312          }
313          for (; j < boxes_num; j ++) {
314              if (mask_tbl[j/64] & (1ull << (j % 64))) {
315                  continue;
316              }
317              float xx1 = max(x1[i], x1[j]);
318              float yy1 = max(y1[i], y1[j]);
319              float xx2 = min(x2[i], x2[j]);
320              float yy2 = min(y2[i], y2[j]);
321              float w = max(0.0f, xx2 - xx1 );
322              float h = max(0.0f, yy2 - yy1 );
323              float interS = w * h;
324              float Sa = (x2[i] - x1[i] ) * (y2[i] - y1[i] );
325              float Sb = (x2[j] - x1[j] ) * (y2[j] - y1[j] );
326              if (interS > thresh_f * (Sa + Sb - interS)) {
327                  mask_tbl[j/64] |= 1ull << (j % 64);
328              }
329          }
330      }
331      free(mask_tbl);
332      *num_out = num_to_keep;
333  }
334  void cpu_nms_avx512_caffe(int* __restrict keep_out, int* __restrict num_out,
335                            const vector<NormalizedBBox>& bboxes,
336                            vector<pair<float, int> >& score_index_vec,
337                            float thresh) {
338    uint64_t boxes_num = score_index_vec.size();
339    float* x1 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
340    float* y1 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
341    float* x2 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
342    float* y2 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
343    uint64_t i = 0;
344  #pragma omp parallel for
345    for (i = 0; i < boxes_num; ++i) {
346      x1[i] = bboxes[score_index_vec[i].second].xmin();
347      y1[i] = bboxes[score_index_vec[i].second].ymin();
348      x2[i] = bboxes[score_index_vec[i].second].xmax();
349      y2[i] = bboxes[score_index_vec[i].second].ymax();
350    }
351    cpu_nms_avx512_parallize_inner(keep_out, num_out, x1, y1, x2, y2, boxes_num,
352                                     thresh);
353  #pragma omp parallel for
354    for (int i = 0; i < *num_out; i++) {
355      keep_out[i] = score_index_vec[keep_out[i]].second;
356    }
357    free(x1);
358    free(x2);
359    free(y1);
360    free(y2);
361  }
362  #endif
363  NormalizedBBox UnitBBox() {
364    NormalizedBBox unit_bbox;
365    unit_bbox.set_xmin(0.);
366    unit_bbox.set_ymin(0.);
367    unit_bbox.set_xmax(1.);
368    unit_bbox.set_ymax(1.);
369    return unit_bbox;
370  }
371  bool IsCrossBoundaryBBox(const NormalizedBBox& bbox) {
372    return bbox.xmin() < 0 || bbox.xmin() > 1 ||
373        bbox.ymin() < 0 || bbox.ymin() > 1 ||
374        bbox.xmax() < 0 || bbox.xmax() > 1 ||
375        bbox.ymax() < 0 || bbox.ymax() > 1;
376  }
377  void IntersectBBox(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2,
378                     NormalizedBBox* intersect_bbox) {
379    if (bbox2.xmin() > bbox1.xmax() || bbox2.xmax() < bbox1.xmin() ||
380        bbox2.ymin() > bbox1.ymax() || bbox2.ymax() < bbox1.ymin()) {
381      intersect_bbox->set_xmin(0);
382      intersect_bbox->set_ymin(0);
383      intersect_bbox->set_xmax(0);
384      intersect_bbox->set_ymax(0);
385    } else {
386      intersect_bbox->set_xmin(std::max(bbox1.xmin(), bbox2.xmin()));
387      intersect_bbox->set_ymin(std::max(bbox1.ymin(), bbox2.ymin()));
388      intersect_bbox->set_xmax(std::min(bbox1.xmax(), bbox2.xmax()));
389      intersect_bbox->set_ymax(std::min(bbox1.ymax(), bbox2.ymax()));
390    }
391  }
392  float BBoxSize(const NormalizedBBox& bbox, const bool normalized) {
393    if (bbox.xmax() < bbox.xmin() || bbox.ymax() < bbox.ymin()) {
394      return 0;
395    } else {
396      if (bbox.has_size()) {
397        return bbox.size();
398      } else {
399        float width = bbox.xmax() - bbox.xmin();
400        float height = bbox.ymax() - bbox.ymin();
401        if (normalized) {
402          return width * height;
403        } else {
404          return (width + 1) * (height + 1);
405        }
406      }
407    }
408  }
409  template <typename Dtype>
410  Dtype BBoxSize(const Dtype* bbox, const bool normalized) {
411    if (bbox[2] < bbox[0] || bbox[3] < bbox[1]) {
412      return Dtype(0.);
413    } else {
414      const Dtype width = bbox[2] - bbox[0];
415      const Dtype height = bbox[3] - bbox[1];
416      if (normalized) {
417        return width * height;
418      } else {
419        return (width + 1) * (height + 1);
420      }
421    }
422  }
423  template float BBoxSize(const float* bbox, const bool normalized);
424  template double BBoxSize(const double* bbox, const bool normalized);
425  void ClipBBox(const NormalizedBBox& bbox, NormalizedBBox* clip_bbox) {
426    clip_bbox->set_xmin(std::max(std::min(bbox.xmin(), 1.f), 0.f));
427    clip_bbox->set_ymin(std::max(std::min(bbox.ymin(), 1.f), 0.f));
428    clip_bbox->set_xmax(std::max(std::min(bbox.xmax(), 1.f), 0.f));
429    clip_bbox->set_ymax(std::max(std::min(bbox.ymax(), 1.f), 0.f));
430    clip_bbox->clear_size();
431    clip_bbox->set_size(BBoxSize(*clip_bbox));
432    clip_bbox->set_difficult(bbox.difficult());
433  }
434  void ClipBBox(const NormalizedBBox& bbox, const float height, const float width,
435                NormalizedBBox* clip_bbox) {
436    clip_bbox->set_xmin(std::max(std::min(bbox.xmin(), width), 0.f));
437    clip_bbox->set_ymin(std::max(std::min(bbox.ymin(), height), 0.f));
438    clip_bbox->set_xmax(std::max(std::min(bbox.xmax(), width), 0.f));
439    clip_bbox->set_ymax(std::max(std::min(bbox.ymax(), height), 0.f));
440    clip_bbox->clear_size();
441    clip_bbox->set_size(BBoxSize(*clip_bbox));
442    clip_bbox->set_difficult(bbox.difficult());
443  }
444  void ScaleBBox(const NormalizedBBox& bbox, const int height, const int width,
445                 NormalizedBBox* scale_bbox) {
446    scale_bbox->set_xmin(bbox.xmin() * width);
447    scale_bbox->set_ymin(bbox.ymin() * height);
448    scale_bbox->set_xmax(bbox.xmax() * width);
449    scale_bbox->set_ymax(bbox.ymax() * height);
450    scale_bbox->clear_size();
451    bool normalized = !(width > 1 || height > 1);
452    scale_bbox->set_size(BBoxSize(*scale_bbox, normalized));
453    scale_bbox->set_difficult(bbox.difficult());
454  }
455  void OutputBBox(const NormalizedBBox& bbox, const pair<int, int>& img_size,
456                  const bool has_resize, const ResizeParameter& resize_param,
457                  NormalizedBBox* out_bbox) {
458    const int height = img_size.first;
459    const int width = img_size.second;
460    NormalizedBBox temp_bbox = bbox;
461    if (has_resize && resize_param.resize_mode()) {
462      float resize_height = resize_param.height();
463      CHECK_GT(resize_height, 0);
464      float resize_width = resize_param.width();
465      CHECK_GT(resize_width, 0);
466      float resize_aspect = resize_width / resize_height;
467      int height_scale = resize_param.height_scale();
468      int width_scale = resize_param.width_scale();
469      float aspect = static_cast<float>(width) / height;
470      float padding;
471      NormalizedBBox source_bbox;
472      switch (resize_param.resize_mode()) {
473        case ResizeParameter_Resize_mode_WARP:
474          ClipBBox(temp_bbox, &temp_bbox);
475          ScaleBBox(temp_bbox, height, width, out_bbox);
476          break;
477        case ResizeParameter_Resize_mode_FIT_LARGE_SIZE_AND_PAD:
478          if (aspect > resize_aspect) {
479            padding = (resize_height - resize_width / aspect) / 2;
480            source_bbox.set_xmin(0.);
481            source_bbox.set_ymin(padding / resize_height);
482            source_bbox.set_xmax(1.);
483            source_bbox.set_ymax(1. - padding / resize_height);
484          } else {
485            padding = (resize_width - resize_height * aspect) / 2;
486            source_bbox.set_xmin(padding / resize_width);
487            source_bbox.set_ymin(0.);
488            source_bbox.set_xmax(1. - padding / resize_width);
489            source_bbox.set_ymax(1.);
490          }
491          ProjectBBox(source_bbox, bbox, &temp_bbox);
492          ClipBBox(temp_bbox, &temp_bbox);
493          ScaleBBox(temp_bbox, height, width, out_bbox);
494          break;
495        case ResizeParameter_Resize_mode_FIT_SMALL_SIZE:
496          if (height_scale == 0 || width_scale == 0) {
497            ClipBBox(temp_bbox, &temp_bbox);
498            ScaleBBox(temp_bbox, height, width, out_bbox);
499          } else {
500            ScaleBBox(temp_bbox, height_scale, width_scale, out_bbox);
501            ClipBBox(*out_bbox, height, width, out_bbox);
502          }
503          break;
504        default:
505          LOG(FATAL) << "Unknown resize mode.";
506      }
507    } else {
508      ClipBBox(temp_bbox, &temp_bbox);
509      ScaleBBox(temp_bbox, height, width, out_bbox);
510    }
511  }
512  void LocateBBox(const NormalizedBBox& src_bbox, const NormalizedBBox& bbox,
513                  NormalizedBBox* loc_bbox) {
514    float src_width = src_bbox.xmax() - src_bbox.xmin();
515    float src_height = src_bbox.ymax() - src_bbox.ymin();
516    loc_bbox->set_xmin(src_bbox.xmin() + bbox.xmin() * src_width);
517    loc_bbox->set_ymin(src_bbox.ymin() + bbox.ymin() * src_height);
518    loc_bbox->set_xmax(src_bbox.xmin() + bbox.xmax() * src_width);
519    loc_bbox->set_ymax(src_bbox.ymin() + bbox.ymax() * src_height);
520    loc_bbox->set_difficult(bbox.difficult());
521  }
522  bool ProjectBBox(const NormalizedBBox& src_bbox, const NormalizedBBox& bbox,
523                   NormalizedBBox* proj_bbox) {
524    if (bbox.xmin() >= src_bbox.xmax() || bbox.xmax() <= src_bbox.xmin() ||
525        bbox.ymin() >= src_bbox.ymax() || bbox.ymax() <= src_bbox.ymin()) {
526      return false;
527    }
528    float src_width = src_bbox.xmax() - src_bbox.xmin();
529    float src_height = src_bbox.ymax() - src_bbox.ymin();
530    proj_bbox->set_xmin((bbox.xmin() - src_bbox.xmin()) / src_width);
531    proj_bbox->set_ymin((bbox.ymin() - src_bbox.ymin()) / src_height);
532    proj_bbox->set_xmax((bbox.xmax() - src_bbox.xmin()) / src_width);
533    proj_bbox->set_ymax((bbox.ymax() - src_bbox.ymin()) / src_height);
534    proj_bbox->set_difficult(bbox.difficult());
535    ClipBBox(*proj_bbox, proj_bbox);
536    if (BBoxSize(*proj_bbox) > 0) {
537      return true;
538    } else {
539      return false;
540    }
541  }
542  void ExtrapolateBBox(const ResizeParameter& param, const int height,
543      const int width, const NormalizedBBox& crop_bbox, NormalizedBBox* bbox) {
544    float height_scale = param.height_scale();
545    float width_scale = param.width_scale();
546    if (height_scale > 0 && width_scale > 0 &&
547        param.resize_mode() == ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
548      float orig_aspect = static_cast<float>(width) / height;
549      float resize_height = param.height();
550      float resize_width = param.width();
551      float resize_aspect = resize_width / resize_height;
552      if (orig_aspect < resize_aspect) {
553        resize_height = resize_width / orig_aspect;
554      } else {
555        resize_width = resize_height * orig_aspect;
556      }
557      float crop_height = resize_height * (crop_bbox.ymax() - crop_bbox.ymin());
558      float crop_width = resize_width * (crop_bbox.xmax() - crop_bbox.xmin());
559      CHECK_GE(crop_width, width_scale);
560      CHECK_GE(crop_height, height_scale);
561      bbox->set_xmin(bbox->xmin() * crop_width / width_scale);
562      bbox->set_xmax(bbox->xmax() * crop_width / width_scale);
563      bbox->set_ymin(bbox->ymin() * crop_height / height_scale);
564      bbox->set_ymax(bbox->ymax() * crop_height / height_scale);
565    }
566  }
567  float JaccardOverlap(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2,
568                       const bool normalized) {
569    NormalizedBBox intersect_bbox;
570    IntersectBBox(bbox1, bbox2, &intersect_bbox);
571    float intersect_width, intersect_height;
572    if (normalized) {
573      intersect_width = intersect_bbox.xmax() - intersect_bbox.xmin();
574      intersect_height = intersect_bbox.ymax() - intersect_bbox.ymin();
575    } else {
576      intersect_width = intersect_bbox.xmax() - intersect_bbox.xmin() + 1;
577      intersect_height = intersect_bbox.ymax() - intersect_bbox.ymin() + 1;
578    }
579    if (intersect_width > 0 && intersect_height > 0) {
580      float intersect_size = intersect_width * intersect_height;
581      float bbox1_size = BBoxSize(bbox1);
582      float bbox2_size = BBoxSize(bbox2);
583      return intersect_size / (bbox1_size + bbox2_size - intersect_size);
584    } else {
585      return 0.;
586    }
587  }
588  template <typename Dtype>
589  Dtype JaccardOverlap(const Dtype* bbox1, const Dtype* bbox2) {
590    if (bbox2[0] > bbox1[2] || bbox2[2] < bbox1[0] ||
591        bbox2[1] > bbox1[3] || bbox2[3] < bbox1[1]) {
592      return Dtype(0.);
593    } else {
<span onclick='openModal()' class='match'>594      const Dtype inter_xmin = std::max(bbox1[0], bbox2[0]);
595      const Dtype inter_ymin = std::max(bbox1[1], bbox2[1]);
596      const Dtype inter_xmax = std::min(bbox1[2], bbox2[2]);
597      const Dtype inter_ymax = std::min(bbox1[3], bbox2[3]);
598      const Dtype inter_width = inter_xmax - inter_xmin;
</span>599      const Dtype inter_height = inter_ymax - inter_ymin;
600      const Dtype inter_size = inter_width * inter_height;
601      const Dtype bbox1_size = BBoxSize(bbox1);
602      const Dtype bbox2_size = BBoxSize(bbox2);
603      return inter_size / (bbox1_size + bbox2_size - inter_size);
604    }
605  }
606  template float JaccardOverlap(const float* bbox1, const float* bbox2);
607  template double JaccardOverlap(const double* bbox1, const double* bbox2);
608  float BBoxCoverage(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
609    NormalizedBBox intersect_bbox;
610    IntersectBBox(bbox1, bbox2, &intersect_bbox);
611    float intersect_size = BBoxSize(intersect_bbox);
612    if (intersect_size > 0) {
613      float bbox1_size = BBoxSize(bbox1);
614      CHECK_NE(bbox1_size, 0);
615      return intersect_size / bbox1_size;
616    } else {
617      return 0.;
618    }
619  }
620  bool MeetEmitConstraint(const NormalizedBBox& src_bbox,
621                          const NormalizedBBox& bbox,
622                          const EmitConstraint& emit_constraint) {
623    EmitType emit_type = emit_constraint.emit_type();
624    if (emit_type == EmitConstraint_EmitType_CENTER) {
625      float x_center = (bbox.xmin() + bbox.xmax()) / 2;
626      float y_center = (bbox.ymin() + bbox.ymax()) / 2;
627      if (x_center >= src_bbox.xmin() && x_center <= src_bbox.xmax() &&
628          y_center >= src_bbox.ymin() && y_center <= src_bbox.ymax()) {
629        return true;
630      } else {
631        return false;
632      }
633    } else if (emit_type == EmitConstraint_EmitType_MIN_OVERLAP) {
634      float bbox_coverage = BBoxCoverage(bbox, src_bbox);
635      return bbox_coverage > emit_constraint.emit_overlap();
636    } else {
637      LOG(FATAL) << "Unknown emit type.";
638      return false;
639    }
640  }
641  void EncodeBBox(
642      const NormalizedBBox& prior_bbox, const vector<float>& prior_variance,
643      const CodeType code_type, const bool encode_variance_in_target,
644      const NormalizedBBox& bbox, NormalizedBBox* encode_bbox) {
645    if (code_type == PriorBoxParameter_CodeType_CORNER) {
646      if (encode_variance_in_target) {
647        encode_bbox->set_xmin(bbox.xmin() - prior_bbox.xmin());
648        encode_bbox->set_ymin(bbox.ymin() - prior_bbox.ymin());
649        encode_bbox->set_xmax(bbox.xmax() - prior_bbox.xmax());
650        encode_bbox->set_ymax(bbox.ymax() - prior_bbox.ymax());
651      } else {
652        CHECK_EQ(prior_variance.size(), 4);
653        for (int i = 0; i < prior_variance.size(); ++i) {
654          CHECK_GT(prior_variance[i], 0);
655        }
656        encode_bbox->set_xmin(
657            (bbox.xmin() - prior_bbox.xmin()) / prior_variance[0]);
658        encode_bbox->set_ymin(
659            (bbox.ymin() - prior_bbox.ymin()) / prior_variance[1]);
660        encode_bbox->set_xmax(
661            (bbox.xmax() - prior_bbox.xmax()) / prior_variance[2]);
662        encode_bbox->set_ymax(
663            (bbox.ymax() - prior_bbox.ymax()) / prior_variance[3]);
664      }
665    } else if (code_type == PriorBoxParameter_CodeType_CENTER_SIZE) {
666      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
667      CHECK_GT(prior_width, 0);
668      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
669      CHECK_GT(prior_height, 0);
670      float prior_center_x = (prior_bbox.xmin() + prior_bbox.xmax()) / 2.;
671      float prior_center_y = (prior_bbox.ymin() + prior_bbox.ymax()) / 2.;
672      float bbox_width = bbox.xmax() - bbox.xmin();
673      CHECK_GT(bbox_width, 0);
674      float bbox_height = bbox.ymax() - bbox.ymin();
675      CHECK_GT(bbox_height, 0);
676      float bbox_center_x = (bbox.xmin() + bbox.xmax()) / 2.;
677      float bbox_center_y = (bbox.ymin() + bbox.ymax()) / 2.;
678      if (encode_variance_in_target) {
679        encode_bbox->set_xmin((bbox_center_x - prior_center_x) / prior_width);
680        encode_bbox->set_ymin((bbox_center_y - prior_center_y) / prior_height);
681        encode_bbox->set_xmax(log(bbox_width / prior_width));
682        encode_bbox->set_ymax(log(bbox_height / prior_height));
683      } else {
684        encode_bbox->set_xmin(
685            (bbox_center_x - prior_center_x) / prior_width / prior_variance[0]);
686        encode_bbox->set_ymin(
687            (bbox_center_y - prior_center_y) / prior_height / prior_variance[1]);
688        encode_bbox->set_xmax(
689            log(bbox_width / prior_width) / prior_variance[2]);
690        encode_bbox->set_ymax(
691            log(bbox_height / prior_height) / prior_variance[3]);
692      }
693    } else if (code_type == PriorBoxParameter_CodeType_CORNER_SIZE) {
694      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
695      CHECK_GT(prior_width, 0);
696      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
697      CHECK_GT(prior_height, 0);
698      if (encode_variance_in_target) {
699        encode_bbox->set_xmin((bbox.xmin() - prior_bbox.xmin()) / prior_width);
700        encode_bbox->set_ymin((bbox.ymin() - prior_bbox.ymin()) / prior_height);
701        encode_bbox->set_xmax((bbox.xmax() - prior_bbox.xmax()) / prior_width);
702        encode_bbox->set_ymax((bbox.ymax() - prior_bbox.ymax()) / prior_height);
703      } else {
704        CHECK_EQ(prior_variance.size(), 4);
705        for (int i = 0; i < prior_variance.size(); ++i) {
706          CHECK_GT(prior_variance[i], 0);
707        }
708        encode_bbox->set_xmin(
709            (bbox.xmin() - prior_bbox.xmin()) / prior_width / prior_variance[0]);
710        encode_bbox->set_ymin(
711            (bbox.ymin() - prior_bbox.ymin()) / prior_height / prior_variance[1]);
712        encode_bbox->set_xmax(
713            (bbox.xmax() - prior_bbox.xmax()) / prior_width / prior_variance[2]);
714        encode_bbox->set_ymax(
715            (bbox.ymax() - prior_bbox.ymax()) / prior_height / prior_variance[3]);
716      }
717    } else {
718      LOG(FATAL) << "Unknown LocLossType.";
719    }
720  }
721  void DecodeBBox(
722      const NormalizedBBox& prior_bbox, const vector<float>& prior_variance,
723      const CodeType code_type, const bool variance_encoded_in_target,
724      const bool clip_bbox, const NormalizedBBox& bbox,
725      NormalizedBBox* decode_bbox) {
726    if (code_type == PriorBoxParameter_CodeType_CORNER) {
727      if (variance_encoded_in_target) {
728        decode_bbox->set_xmin(prior_bbox.xmin() + bbox.xmin());
729        decode_bbox->set_ymin(prior_bbox.ymin() + bbox.ymin());
730        decode_bbox->set_xmax(prior_bbox.xmax() + bbox.xmax());
731        decode_bbox->set_ymax(prior_bbox.ymax() + bbox.ymax());
732      } else {
733        decode_bbox->set_xmin(
734            prior_bbox.xmin() + prior_variance[0] * bbox.xmin());
735        decode_bbox->set_ymin(
736            prior_bbox.ymin() + prior_variance[1] * bbox.ymin());
737        decode_bbox->set_xmax(
738            prior_bbox.xmax() + prior_variance[2] * bbox.xmax());
739        decode_bbox->set_ymax(
740            prior_bbox.ymax() + prior_variance[3] * bbox.ymax());
741      }
742    } else if (code_type == PriorBoxParameter_CodeType_CENTER_SIZE) {
743      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
744      CHECK_GT(prior_width, 0);
745      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
746      CHECK_GT(prior_height, 0);
747      float prior_center_x = (prior_bbox.xmin() + prior_bbox.xmax()) / 2.;
748      float prior_center_y = (prior_bbox.ymin() + prior_bbox.ymax()) / 2.;
749      float decode_bbox_center_x, decode_bbox_center_y;
750      float decode_bbox_width, decode_bbox_height;
751      if (variance_encoded_in_target) {
752        decode_bbox_center_x = bbox.xmin() * prior_width + prior_center_x;
753        decode_bbox_center_y = bbox.ymin() * prior_height + prior_center_y;
754        decode_bbox_width = exp(bbox.xmax()) * prior_width;
755        decode_bbox_height = exp(bbox.ymax()) * prior_height;
756      } else {
757        decode_bbox_center_x =
758            prior_variance[0] * bbox.xmin() * prior_width + prior_center_x;
759        decode_bbox_center_y =
760            prior_variance[1] * bbox.ymin() * prior_height + prior_center_y;
761        decode_bbox_width =
762            exp(prior_variance[2] * bbox.xmax()) * prior_width;
763        decode_bbox_height =
764            exp(prior_variance[3] * bbox.ymax()) * prior_height;
765      }
766      decode_bbox->set_xmin(decode_bbox_center_x - decode_bbox_width / 2.);
767      decode_bbox->set_ymin(decode_bbox_center_y - decode_bbox_height / 2.);
768      decode_bbox->set_xmax(decode_bbox_center_x + decode_bbox_width / 2.);
769      decode_bbox->set_ymax(decode_bbox_center_y + decode_bbox_height / 2.);
770    } else if (code_type == PriorBoxParameter_CodeType_CORNER_SIZE) {
771      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
772      CHECK_GT(prior_width, 0);
773      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
774      CHECK_GT(prior_height, 0);
775      if (variance_encoded_in_target) {
776        decode_bbox->set_xmin(prior_bbox.xmin() + bbox.xmin() * prior_width);
777        decode_bbox->set_ymin(prior_bbox.ymin() + bbox.ymin() * prior_height);
778        decode_bbox->set_xmax(prior_bbox.xmax() + bbox.xmax() * prior_width);
779        decode_bbox->set_ymax(prior_bbox.ymax() + bbox.ymax() * prior_height);
780      } else {
781        decode_bbox->set_xmin(
782            prior_bbox.xmin() + prior_variance[0] * bbox.xmin() * prior_width);
783        decode_bbox->set_ymin(
784            prior_bbox.ymin() + prior_variance[1] * bbox.ymin() * prior_height);
785        decode_bbox->set_xmax(
786            prior_bbox.xmax() + prior_variance[2] * bbox.xmax() * prior_width);
787        decode_bbox->set_ymax(
788            prior_bbox.ymax() + prior_variance[3] * bbox.ymax() * prior_height);
789      }
790    } else {
791      LOG(FATAL) << "Unknown LocLossType.";
792    }
793    float bbox_size = BBoxSize(*decode_bbox);
794    decode_bbox->set_size(bbox_size);
795    if (clip_bbox) {
796      ClipBBox(*decode_bbox, decode_bbox);
797    }
798  }
799  void DecodeBBoxes(const vector<NormalizedBBox>& prior_bboxes,
800                    const vector<vector<float> >& prior_variances,
801                    const CodeType code_type,
802                    const bool variance_encoded_in_target, const bool clip_bbox,
803                    const vector<NormalizedBBox>& bboxes,
804                    vector<NormalizedBBox>* decode_bboxes) {
805    CHECK_EQ(prior_bboxes.size(), prior_variances.size());
806    CHECK_EQ(prior_bboxes.size(), bboxes.size());
807    int num_bboxes = prior_bboxes.size();
808    if (num_bboxes >= 1) {
809      CHECK_EQ(prior_variances[0].size(), 4);
810    }
811    decode_bboxes->reserve(num_bboxes);
812    NormalizedBBox* result = new NormalizedBBox[num_bboxes];
813  #ifdef _OPENMP
814    #pragma omp parallel for
815  #endif
816    for (int i = 0; i < num_bboxes; ++i) {
817      DecodeBBox(prior_bboxes[i], prior_variances[i], code_type,
818                 variance_encoded_in_target, clip_bbox, bboxes[i], &result[i]);
819    }
820    decode_bboxes->assign(&result[0], &result[num_bboxes]);
821    delete[] result;
822  }
823  void DecodeBBoxesAll(const vector<LabelBBox>& all_loc_preds,
824      const vector<NormalizedBBox>& prior_bboxes,
825      const vector<vector<float> >& prior_variances,
826      const int num, const bool share_location,
827      const int num_loc_classes, const int background_label_id,
828      const CodeType code_type, const bool variance_encoded_in_target,
829      const bool clip, vector<LabelBBox>* all_decode_bboxes) {
830    CHECK_EQ(all_loc_preds.size(), num);
831    all_decode_bboxes->clear();
832    all_decode_bboxes->resize(num);
833  #ifdef _OPENMP
834    #pragma omp parallel for
835  #endif
836    for (int i = 0; i < num; ++i) {
837      for (int c = 0; c < num_loc_classes; ++c) {
838        int label = share_location ? -1 : c;
839        if (label == background_label_id) {
840          continue;
841        }
842        if (all_loc_preds[i].find(label) == all_loc_preds[i].end()) {
843          LOG(FATAL) << "Could not find location predictions for label " << label;
844        }
845        const vector<NormalizedBBox>& label_loc_preds =
846            all_loc_preds[i].find(label)->second;
847        DecodeBBoxes(prior_bboxes, prior_variances,
848                     code_type, variance_encoded_in_target, clip,
849                     label_loc_preds, &((*all_decode_bboxes)[i][label]));
850      }
851    }
852  }
853  void MatchBBox(const vector<NormalizedBBox>& gt_bboxes,
854      const vector<NormalizedBBox>& pred_bboxes, const int label,
855      const MatchType match_type, const float overlap_threshold,
856      const bool ignore_cross_boundary_bbox,
857      vector<int>* match_indices, vector<float>* match_overlaps) {
858    int num_pred = pred_bboxes.size();
859    match_indices->clear();
860    match_indices->resize(num_pred, -1);
861    match_overlaps->clear();
862    match_overlaps->resize(num_pred, 0.);
863    int num_gt = 0;
864    vector<int> gt_indices;
865    if (label == -1) {
866      num_gt = gt_bboxes.size();
867      for (int i = 0; i < num_gt; ++i) {
868        gt_indices.push_back(i);
869      }
870    } else {
871      for (int i = 0; i < gt_bboxes.size(); ++i) {
872        if (gt_bboxes[i].label() == label) {
873          num_gt++;
874          gt_indices.push_back(i);
875        }
876      }
877    }
878    if (num_gt == 0) {
879      return;
880    }
881    map<int, map<int, float> > overlaps;
882    for (int i = 0; i < num_pred; ++i) {
883      if (ignore_cross_boundary_bbox && IsCrossBoundaryBBox(pred_bboxes[i])) {
884        (*match_indices)[i] = -2;
885        continue;
886      }
887      for (int j = 0; j < num_gt; ++j) {
888        float overlap = JaccardOverlap(pred_bboxes[i], gt_bboxes[gt_indices[j]]);
889        if (overlap > 1e-6) {
890          (*match_overlaps)[i] = std::max((*match_overlaps)[i], overlap);
891          overlaps[i][j] = overlap;
892        }
893      }
894    }
895    vector<int> gt_pool;
896    for (int i = 0; i < num_gt; ++i) {
897      gt_pool.push_back(i);
898    }
899    while (gt_pool.size() > 0) {
900      int max_idx = -1;
901      int max_gt_idx = -1;
902      float max_overlap = -1;
903      for (map<int, map<int, float> >::iterator it = overlaps.begin();
904           it != overlaps.end(); ++it) {
905        int i = it->first;
906        if ((*match_indices)[i] != -1) {
907          continue;
908        }
909        for (int p = 0; p < gt_pool.size(); ++p) {
910          int j = gt_pool[p];
911          if (it->second.find(j) == it->second.end()) {
912            continue;
913          }
914          if (it->second[j] > max_overlap) {
915            max_idx = i;
916            max_gt_idx = j;
917            max_overlap = it->second[j];
918          }
919        }
920      }
921      if (max_idx == -1) {
922        break;
923      } else {
924        CHECK_EQ((*match_indices)[max_idx], -1);
925        (*match_indices)[max_idx] = gt_indices[max_gt_idx];
926        (*match_overlaps)[max_idx] = max_overlap;
927        gt_pool.erase(std::find(gt_pool.begin(), gt_pool.end(), max_gt_idx));
928      }
929    }
930    switch (match_type) {
931      case MultiBoxLossParameter_MatchType_BIPARTITE:
932        break;
933      case MultiBoxLossParameter_MatchType_PER_PREDICTION:
934        for (map<int, map<int, float> >::iterator it = overlaps.begin();
935             it != overlaps.end(); ++it) {
936          int i = it->first;
937          if ((*match_indices)[i] != -1) {
938            continue;
939          }
940          int max_gt_idx = -1;
941          float max_overlap = -1;
942          for (int j = 0; j < num_gt; ++j) {
943            if (it->second.find(j) == it->second.end()) {
944              continue;
945            }
946            float overlap = it->second[j];
947            if (overlap >= overlap_threshold && overlap > max_overlap) {
948              max_gt_idx = j;
949              max_overlap = overlap;
950            }
951          }
952          if (max_gt_idx != -1) {
953            CHECK_EQ((*match_indices)[i], -1);
954            (*match_indices)[i] = gt_indices[max_gt_idx];
955            (*match_overlaps)[i] = max_overlap;
956          }
957        }
958        break;
959      default:
960        LOG(FATAL) << "Unknown matching type.";
961        break;
962    }
963    return;
964  }
965  void FindMatches(const vector<LabelBBox>& all_loc_preds,
966        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
967        const vector<NormalizedBBox>& prior_bboxes,
968        const vector<vector<float> >& prior_variances,
969        const MultiBoxLossParameter& multibox_loss_param,
970        vector<map<int, vector<float> > >* all_match_overlaps,
971        vector<map<int, vector<int> > >* all_match_indices) {
972    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
973    const int num_classes = multibox_loss_param.num_classes();
974    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
975    const bool share_location = multibox_loss_param.share_location();
976    const int loc_classes = share_location ? 1 : num_classes;
977    const MatchType match_type = multibox_loss_param.match_type();
978    const float overlap_threshold = multibox_loss_param.overlap_threshold();
979    const bool use_prior_for_matching =
980        multibox_loss_param.use_prior_for_matching();
981    const int background_label_id = multibox_loss_param.background_label_id();
982    const CodeType code_type = multibox_loss_param.code_type();
983    const bool encode_variance_in_target =
984        multibox_loss_param.encode_variance_in_target();
985    const bool ignore_cross_boundary_bbox =
986        multibox_loss_param.ignore_cross_boundary_bbox();
987    int num = all_loc_preds.size();
988    for (int i = 0; i < num; ++i) {
989      map<int, vector<int> > match_indices;
990      map<int, vector<float> > match_overlaps;
991      if (all_gt_bboxes.find(i) == all_gt_bboxes.end()) {
992        all_match_indices->push_back(match_indices);
993        all_match_overlaps->push_back(match_overlaps);
994        continue;
995      }
996      const vector<NormalizedBBox>& gt_bboxes = all_gt_bboxes.find(i)->second;
997      if (!use_prior_for_matching) {
998        for (int c = 0; c < loc_classes; ++c) {
999          int label = share_location ? -1 : c;
1000          if (!share_location && label == background_label_id) {
1001            continue;
1002          }
1003          vector<NormalizedBBox> loc_bboxes;
1004          bool clip_bbox = false;
1005          DecodeBBoxes(prior_bboxes, prior_variances,
1006                       code_type, encode_variance_in_target, clip_bbox,
1007                       all_loc_preds[i].find(label)->second, &loc_bboxes);
1008          MatchBBox(gt_bboxes, loc_bboxes, label, match_type,
1009                    overlap_threshold, ignore_cross_boundary_bbox,
1010                    &match_indices[label], &match_overlaps[label]);
1011        }
1012      } else {
1013        vector<int> temp_match_indices;
1014        vector<float> temp_match_overlaps;
1015        const int label = -1;
1016        MatchBBox(gt_bboxes, prior_bboxes, label, match_type, overlap_threshold,
1017                  ignore_cross_boundary_bbox, &temp_match_indices,
1018                  &temp_match_overlaps);
1019        if (share_location) {
1020          match_indices[label] = temp_match_indices;
1021          match_overlaps[label] = temp_match_overlaps;
1022        } else {
1023          vector<int> gt_labels;
1024          for (int g = 0; g < gt_bboxes.size(); ++g) {
1025            gt_labels.push_back(gt_bboxes[g].label());
1026          }
1027          for (int c = 0; c < loc_classes; ++c) {
1028            if (c == background_label_id) {
1029              continue;
1030            }
1031            match_indices[c].resize(temp_match_indices.size(), -1);
1032            match_overlaps[c] = temp_match_overlaps;
1033            for (int m = 0; m < temp_match_indices.size(); ++m) {
1034              if (temp_match_indices[m] > -1) {
1035                const int gt_idx = temp_match_indices[m];
1036                CHECK_LT(gt_idx, gt_labels.size());
1037                if (c == gt_labels[gt_idx]) {
1038                  match_indices[c][m] = gt_idx;
1039                }
1040              }
1041            }
1042          }
1043        }
1044      }
1045      all_match_indices->push_back(match_indices);
1046      all_match_overlaps->push_back(match_overlaps);
1047    }
1048  }
1049  int CountNumMatches(const vector<map<int, vector<int> > >& all_match_indices,
1050                      const int num) {
1051    int num_matches = 0;
1052    for (int i = 0; i < num; ++i) {
1053      const map<int, vector<int> >& match_indices = all_match_indices[i];
1054      for (map<int, vector<int> >::const_iterator it = match_indices.begin();
1055           it != match_indices.end(); ++it) {
1056        const vector<int>& match_index = it->second;
1057        for (int m = 0; m < match_index.size(); ++m) {
1058          if (match_index[m] > -1) {
1059            ++num_matches;
1060          }
1061        }
1062      }
1063    }
1064    return num_matches;
1065  }
1066  inline bool IsEligibleMining(const MiningType mining_type, const int match_idx,
1067      const float match_overlap, const float neg_overlap) {
1068    if (mining_type == MultiBoxLossParameter_MiningType_MAX_NEGATIVE) {
1069      return match_idx == -1 && match_overlap < neg_overlap;
1070    } else if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1071      return true;
1072    } else {
1073      return false;
1074    }
1075  }
1076  template <typename Dtype>
1077  void MineHardExamples(const Blob<Dtype>& conf_blob,
1078      const vector<LabelBBox>& all_loc_preds,
1079      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1080      const vector<NormalizedBBox>& prior_bboxes,
1081      const vector<vector<float> >& prior_variances,
1082      const vector<map<int, vector<float> > >& all_match_overlaps,
1083      const MultiBoxLossParameter& multibox_loss_param,
1084      int* num_matches, int* num_negs,
1085      vector<map<int, vector<int> > >* all_match_indices,
1086      vector<vector<int> >* all_neg_indices) {
1087    int num = all_loc_preds.size();
1088    *num_matches = CountNumMatches(*all_match_indices, num);
1089    *num_negs = 0;
1090    int num_priors = prior_bboxes.size();
1091    CHECK_EQ(num_priors, prior_variances.size());
1092    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
1093    const int num_classes = multibox_loss_param.num_classes();
1094    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
1095    const int background_label_id = multibox_loss_param.background_label_id();
1096    const bool use_prior_for_nms = multibox_loss_param.use_prior_for_nms();
1097    const ConfLossType conf_loss_type = multibox_loss_param.conf_loss_type();
1098    const MiningType mining_type = multibox_loss_param.mining_type();
1099    if (mining_type == MultiBoxLossParameter_MiningType_NONE) {
1100      return;
1101    }
1102    const LocLossType loc_loss_type = multibox_loss_param.loc_loss_type();
1103    const float neg_pos_ratio = multibox_loss_param.neg_pos_ratio();
1104    const float neg_overlap = multibox_loss_param.neg_overlap();
1105    const CodeType code_type = multibox_loss_param.code_type();
1106    const bool encode_variance_in_target =
1107        multibox_loss_param.encode_variance_in_target();
1108    const bool has_nms_param = multibox_loss_param.has_nms_param();
1109    float nms_threshold = 0;
1110    int top_k = -1;
1111    if (has_nms_param) {
1112      nms_threshold = multibox_loss_param.nms_param().nms_threshold();
1113      top_k = multibox_loss_param.nms_param().top_k();
1114    }
1115    const int sample_size = multibox_loss_param.sample_size();
1116    vector<vector<float> > all_conf_loss;
1117  #ifdef CPU_ONLY
1118    ComputeConfLoss(conf_blob.cpu_data(), num, num_priors, num_classes,
1119        background_label_id, conf_loss_type, *all_match_indices, all_gt_bboxes,
1120        &all_conf_loss);
1121  #else
1122    ComputeConfLossGPU(conf_blob, num, num_priors, num_classes,
1123        background_label_id, conf_loss_type, *all_match_indices, all_gt_bboxes,
1124        &all_conf_loss);
1125  #endif
1126    vector<vector<float> > all_loc_loss;
1127    if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1128      Blob<Dtype> loc_pred, loc_gt;
1129      if (*num_matches != 0) {
1130        vector<int> loc_shape(2, 1);
1131        loc_shape[1] = *num_matches * 4;
1132        loc_pred.Reshape(loc_shape);
1133        loc_gt.Reshape(loc_shape);
1134        Dtype* loc_pred_data = loc_pred.mutable_cpu_data();
1135        Dtype* loc_gt_data = loc_gt.mutable_cpu_data();
1136        EncodeLocPrediction(all_loc_preds, all_gt_bboxes, *all_match_indices,
1137                            prior_bboxes, prior_variances, multibox_loss_param,
1138                            loc_pred_data, loc_gt_data);
1139      }
1140      ComputeLocLoss(loc_pred, loc_gt, *all_match_indices, num,
1141                     num_priors, loc_loss_type, &all_loc_loss);
1142    } else {
1143      for (int i = 0; i < num; ++i) {
1144        vector<float> loc_loss(num_priors, 0.f);
1145        all_loc_loss.push_back(loc_loss);
1146      }
1147    }
1148    for (int i = 0; i < num; ++i) {
1149      map<int, vector<int> >& match_indices = (*all_match_indices)[i];
1150      const map<int, vector<float> >& match_overlaps = all_match_overlaps[i];
1151      const vector<float>& conf_loss = all_conf_loss[i];
1152      const vector<float>& loc_loss = all_loc_loss[i];
1153      vector<float> loss;
1154      std::transform(conf_loss.begin(), conf_loss.end(), loc_loss.begin(),
1155                     std::back_inserter(loss), std::plus<float>());
1156      set<int> sel_indices;
1157      vector<int> neg_indices;
1158      for (map<int, vector<int> >::iterator it = match_indices.begin();
1159           it != match_indices.end(); ++it) {
1160        const int label = it->first;
1161        int num_sel = 0;
1162        vector<pair<float, int> > loss_indices;
1163        for (int m = 0; m < match_indices[label].size(); ++m) {
1164          if (IsEligibleMining(mining_type, match_indices[label][m],
1165              match_overlaps.find(label)->second[m], neg_overlap)) {
1166            loss_indices.push_back(std::make_pair(loss[m], m));
1167            ++num_sel;
1168          }
1169        }
1170        if (mining_type == MultiBoxLossParameter_MiningType_MAX_NEGATIVE) {
1171          int num_pos = 0;
1172          for (int m = 0; m < match_indices[label].size(); ++m) {
1173            if (match_indices[label][m] > -1) {
1174              ++num_pos;
1175            }
1176          }
1177          num_sel = std::min(static_cast<int>(num_pos * neg_pos_ratio), num_sel);
1178        } else if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1179          CHECK_GT(sample_size, 0);
1180          num_sel = std::min(sample_size, num_sel);
1181        }
1182        if (has_nms_param && nms_threshold > 0) {
1183          vector<float> sel_loss;
1184          vector<NormalizedBBox> sel_bboxes;
1185          if (use_prior_for_nms) {
1186            for (int m = 0; m < match_indices[label].size(); ++m) {
1187              if (IsEligibleMining(mining_type, match_indices[label][m],
1188                  match_overlaps.find(label)->second[m], neg_overlap)) {
1189                sel_loss.push_back(loss[m]);
1190                sel_bboxes.push_back(prior_bboxes[m]);
1191              }
1192            }
1193          } else {
1194            vector<NormalizedBBox> loc_bboxes;
1195            bool clip_bbox = false;
1196            DecodeBBoxes(prior_bboxes, prior_variances,
1197                         code_type, encode_variance_in_target, clip_bbox,
1198                         all_loc_preds[i].find(label)->second, &loc_bboxes);
1199            for (int m = 0; m < match_indices[label].size(); ++m) {
1200              if (IsEligibleMining(mining_type, match_indices[label][m],
1201                  match_overlaps.find(label)->second[m], neg_overlap)) {
1202                sel_loss.push_back(loss[m]);
1203                sel_bboxes.push_back(loc_bboxes[m]);
1204              }
1205            }
1206          }
1207          vector<int> nms_indices;
1208          ApplyNMS(sel_bboxes, sel_loss, nms_threshold, top_k, &nms_indices);
1209          if (nms_indices.size() < num_sel) {
1210            LOG(INFO) << "not enough sample after nms: " << nms_indices.size();
1211          }
1212          num_sel = std::min(static_cast<int>(nms_indices.size()), num_sel);
1213          for (int n = 0; n < num_sel; ++n) {
1214            sel_indices.insert(loss_indices[nms_indices[n]].second);
1215          }
1216        } else {
1217          std::sort(loss_indices.begin(), loss_indices.end(),
1218                    SortScorePairDescend<int>);
1219          for (int n = 0; n < num_sel; ++n) {
1220            sel_indices.insert(loss_indices[n].second);
1221          }
1222        }
1223        for (int m = 0; m < match_indices[label].size(); ++m) {
1224          if (match_indices[label][m] > -1) {
1225            if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE &&
1226                sel_indices.find(m) == sel_indices.end()) {
1227              match_indices[label][m] = -1;
1228              *num_matches -= 1;
1229            }
1230          } else if (match_indices[label][m] == -1) {
1231            if (sel_indices.find(m) != sel_indices.end()) {
1232              neg_indices.push_back(m);
1233              *num_negs += 1;
1234            }
1235          }
1236        }
1237      }
1238      all_neg_indices->push_back(neg_indices);
1239    }
1240  }
1241  template void MineHardExamples(const Blob<float>& conf_blob,
1242      const vector<LabelBBox>& all_loc_preds,
1243      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1244      const vector<NormalizedBBox>& prior_bboxes,
1245      const vector<vector<float> >& prior_variances,
1246      const vector<map<int, vector<float> > >& all_match_overlaps,
1247      const MultiBoxLossParameter& multibox_loss_param,
1248      int* num_matches, int* num_negs,
1249      vector<map<int, vector<int> > >* all_match_indices,
1250      vector<vector<int> >* all_neg_indices);
1251  template void MineHardExamples(const Blob<double>& conf_blob,
1252      const vector<LabelBBox>& all_loc_preds,
1253      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1254      const vector<NormalizedBBox>& prior_bboxes,
1255      const vector<vector<float> >& prior_variances,
1256      const vector<map<int, vector<float> > >& all_match_overlaps,
1257      const MultiBoxLossParameter& multibox_loss_param,
1258      int* num_matches, int* num_negs,
1259      vector<map<int, vector<int> > >* all_match_indices,
1260      vector<vector<int> >* all_neg_indices);
1261  template <typename Dtype>
1262  void GetGroundTruth(const Dtype* gt_data, const int num_gt,
1263        const int background_label_id, const bool use_difficult_gt,
1264        map<int, vector<NormalizedBBox> >* all_gt_bboxes) {
1265    all_gt_bboxes->clear();
1266    for (int i = 0; i < num_gt; ++i) {
1267      int start_idx = i * 8;
1268      int item_id = gt_data[start_idx];
1269      if (item_id == -1) {
1270        continue;
1271      }
1272      int label = gt_data[start_idx + 1];
1273      CHECK_NE(background_label_id, label)
1274          << "Found background label in the dataset.";
1275      bool difficult = static_cast<bool>(gt_data[start_idx + 7]);
1276      if (!use_difficult_gt && difficult) {
1277        continue;
1278      }
1279      NormalizedBBox bbox;
1280      bbox.set_label(label);
1281      bbox.set_xmin(gt_data[start_idx + 3]);
1282      bbox.set_ymin(gt_data[start_idx + 4]);
1283      bbox.set_xmax(gt_data[start_idx + 5]);
1284      bbox.set_ymax(gt_data[start_idx + 6]);
1285      bbox.set_difficult(difficult);
1286      float bbox_size = BBoxSize(bbox);
1287      bbox.set_size(bbox_size);
1288      (*all_gt_bboxes)[item_id].push_back(bbox);
1289    }
1290  }
1291  template void GetGroundTruth(const float* gt_data, const int num_gt,
1292        const int background_label_id, const bool use_difficult_gt,
1293        map<int, vector<NormalizedBBox> >* all_gt_bboxes);
1294  template void GetGroundTruth(const double* gt_data, const int num_gt,
1295        const int background_label_id, const bool use_difficult_gt,
1296        map<int, vector<NormalizedBBox> >* all_gt_bboxes);
1297  template <typename Dtype>
1298  void GetGroundTruth(const Dtype* gt_data, const int num_gt,
1299        const int background_label_id, const bool use_difficult_gt,
1300        map<int, LabelBBox>* all_gt_bboxes) {
1301    all_gt_bboxes->clear();
1302    for (int i = 0; i < num_gt; ++i) {
1303      int start_idx = i * 8;
1304      int item_id = gt_data[start_idx];
1305      if (item_id == -1) {
1306        break;
1307      }
1308      NormalizedBBox bbox;
1309      int label = gt_data[start_idx + 1];
1310      CHECK_NE(background_label_id, label)
1311          << "Found background label in the dataset.";
1312      bool difficult = static_cast<bool>(gt_data[start_idx + 7]);
1313      if (!use_difficult_gt && difficult) {
1314        continue;
1315      }
1316      bbox.set_xmin(gt_data[start_idx + 3]);
1317      bbox.set_ymin(gt_data[start_idx + 4]);
1318      bbox.set_xmax(gt_data[start_idx + 5]);
1319      bbox.set_ymax(gt_data[start_idx + 6]);
1320      bbox.set_difficult(difficult);
1321      float bbox_size = BBoxSize(bbox);
1322      bbox.set_size(bbox_size);
1323      (*all_gt_bboxes)[item_id][label].push_back(bbox);
1324    }
1325  }
1326  template void GetGroundTruth(const float* gt_data, const int num_gt,
1327        const int background_label_id, const bool use_difficult_gt,
1328        map<int, LabelBBox>* all_gt_bboxes);
1329  template void GetGroundTruth(const double* gt_data, const int num_gt,
1330        const int background_label_id, const bool use_difficult_gt,
1331        map<int, LabelBBox>* all_gt_bboxes);
1332  template <typename Dtype>
1333  void GetLocPredictions(const Dtype* loc_data, const int num,
1334        const int num_preds_per_class, const int num_loc_classes,
1335        const bool share_location, vector<LabelBBox>* loc_preds) {
1336    loc_preds->clear();
1337    if (share_location) {
1338      CHECK_EQ(num_loc_classes, 1);
1339    }
1340    loc_preds->resize(num);
1341  #ifdef _OPENMP
1342    #pragma omp parallel for
1343  #endif
1344    for (int i = 0; i < num; ++i) {
1345      for (int c = 0; c < num_loc_classes; ++c) {
1346        int label = share_location ? -1 : c;
1347        if ((*loc_preds)[i].find(label) == (*loc_preds)[i].end()) {
1348          (*loc_preds)[i][label].resize(num_preds_per_class);
1349        } else {
1350          break;
1351        }
1352      }
1353    }
1354  #ifdef _OPENMP
1355    #if defined(_MSC_EXTENSIONS)
1356      #pragma omp parallel for
1357    #else
1358      #pragma omp parallel for collapse(3)
1359    #endif
1360  #endif
1361      for (int i = 0; i < num; ++i) {
1362        for (int p = 0; p < num_preds_per_class; ++p) {
1363          for (int c = 0; c < num_loc_classes; ++c) {
1364            int label = share_location ? -1 : c;
1365            (*loc_preds)[i][label][p].set_xmin(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4]);
1366            (*loc_preds)[i][label][p].set_ymin(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 1]);
1367            (*loc_preds)[i][label][p].set_xmax(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 2]);
1368            (*loc_preds)[i][label][p].set_ymax(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 3]);
1369        }
1370      }
1371    }
1372  }
1373  template void GetLocPredictions(const float* loc_data, const int num,
1374        const int num_preds_per_class, const int num_loc_classes,
1375        const bool share_location, vector<LabelBBox>* loc_preds);
1376  template void GetLocPredictions(const double* loc_data, const int num,
1377        const int num_preds_per_class, const int num_loc_classes,
1378        const bool share_location, vector<LabelBBox>* loc_preds);
1379  template <typename Dtype>
1380  void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1381        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1382        const vector<map<int, vector<int> > >& all_match_indices,
1383        const vector<NormalizedBBox>& prior_bboxes,
1384        const vector<vector<float> >& prior_variances,
1385        const MultiBoxLossParameter& multibox_loss_param,
1386        Dtype* loc_pred_data, Dtype* loc_gt_data) {
1387    int num = all_loc_preds.size();
1388    const CodeType code_type = multibox_loss_param.code_type();
1389    const bool encode_variance_in_target =
1390        multibox_loss_param.encode_variance_in_target();
1391    const bool bp_inside = multibox_loss_param.bp_inside();
1392    const bool use_prior_for_matching =
1393        multibox_loss_param.use_prior_for_matching();
1394    int count = 0;
1395    for (int i = 0; i < num; ++i) {
1396      for (map<int, vector<int> >::const_iterator
1397           it = all_match_indices[i].begin();
1398           it != all_match_indices[i].end(); ++it) {
1399        const int label = it->first;
1400        const vector<int>& match_index = it->second;
1401        CHECK(all_loc_preds[i].find(label) != all_loc_preds[i].end());
1402        const vector<NormalizedBBox>& loc_pred =
1403            all_loc_preds[i].find(label)->second;
1404        for (int j = 0; j < match_index.size(); ++j) {
1405          if (match_index[j] <= -1) {
1406            continue;
1407          }
1408          const int gt_idx = match_index[j];
1409          CHECK(all_gt_bboxes.find(i) != all_gt_bboxes.end());
1410          CHECK_LT(gt_idx, all_gt_bboxes.find(i)->second.size());
1411          const NormalizedBBox& gt_bbox = all_gt_bboxes.find(i)->second[gt_idx];
1412          NormalizedBBox gt_encode;
1413          CHECK_LT(j, prior_bboxes.size());
1414          EncodeBBox(prior_bboxes[j], prior_variances[j], code_type,
1415                     encode_variance_in_target, gt_bbox, &gt_encode);
1416          loc_gt_data[count * 4] = gt_encode.xmin();
1417          loc_gt_data[count * 4 + 1] = gt_encode.ymin();
1418          loc_gt_data[count * 4 + 2] = gt_encode.xmax();
1419          loc_gt_data[count * 4 + 3] = gt_encode.ymax();
1420          CHECK_LT(j, loc_pred.size());
1421          if (bp_inside) {
1422            NormalizedBBox match_bbox = prior_bboxes[j];
1423            if (!use_prior_for_matching) {
1424              const bool clip_bbox = false;
1425              DecodeBBox(prior_bboxes[j], prior_variances[j], code_type,
1426                         encode_variance_in_target, clip_bbox, loc_pred[j],
1427                         &match_bbox);
1428            }
1429            loc_pred_data[count * 4] =
1430                (match_bbox.xmin() < 0 || match_bbox.xmin() > 1) ?
1431                gt_encode.xmin() : loc_pred[j].xmin();
1432            loc_pred_data[count * 4 + 1] =
1433                (match_bbox.ymin() < 0 || match_bbox.ymin() > 1) ?
1434                gt_encode.ymin() : loc_pred[j].ymin();
1435            loc_pred_data[count * 4 + 2] =
1436                (match_bbox.xmax() < 0 || match_bbox.xmax() > 1) ?
1437                gt_encode.xmax() : loc_pred[j].xmax();
1438            loc_pred_data[count * 4 + 3] =
1439                (match_bbox.ymax() < 0 || match_bbox.ymax() > 1) ?
1440                gt_encode.ymax() : loc_pred[j].ymax();
1441          } else {
1442            loc_pred_data[count * 4] = loc_pred[j].xmin();
1443            loc_pred_data[count * 4 + 1] = loc_pred[j].ymin();
1444            loc_pred_data[count * 4 + 2] = loc_pred[j].xmax();
1445            loc_pred_data[count * 4 + 3] = loc_pred[j].ymax();
1446          }
1447          if (encode_variance_in_target) {
1448            for (int k = 0; k < 4; ++k) {
1449              CHECK_GT(prior_variances[j][k], 0);
1450              loc_pred_data[count * 4 + k] /= prior_variances[j][k];
1451              loc_gt_data[count * 4 + k] /= prior_variances[j][k];
1452            }
1453          }
1454          ++count;
1455        }
1456      }
1457    }
1458  }
1459  template void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1460        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1461        const vector<map<int, vector<int> > >& all_match_indices,
1462        const vector<NormalizedBBox>& prior_bboxes,
1463        const vector<vector<float> >& prior_variances,
1464        const MultiBoxLossParameter& multibox_loss_param,
1465        float* loc_pred_data, float* loc_gt_data);
1466  template void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1467        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1468        const vector<map<int, vector<int> > >& all_match_indices,
1469        const vector<NormalizedBBox>& prior_bboxes,
1470        const vector<vector<float> >& prior_variances,
1471        const MultiBoxLossParameter& multibox_loss_param,
1472        double* loc_pred_data, double* loc_gt_data);
1473  template <typename Dtype>
1474  void ComputeLocLoss(const Blob<Dtype>& loc_pred, const Blob<Dtype>& loc_gt,
1475        const vector<map<int, vector<int> > >& all_match_indices,
1476        const int num, const int num_priors, const LocLossType loc_loss_type,
1477        vector<vector<float> >* all_loc_loss) {
1478    int loc_count = loc_pred.count();
1479    CHECK_EQ(loc_count, loc_gt.count());
1480    Blob<Dtype> diff;
1481    const Dtype* diff_data = NULL;
1482    if (loc_count != 0) {
1483      diff.Reshape(loc_pred.shape());
1484      caffe_sub(loc_count, loc_pred.cpu_data(), loc_gt.cpu_data(),
1485                diff.mutable_cpu_data());
1486      diff_data = diff.cpu_data();
1487    }
1488    CHECK_NOTNULL(diff_data);
1489    int count = 0;
1490    for (int i = 0; i < num; ++i) {
1491      vector<float> loc_loss(num_priors, 0.f);
1492      for (map<int, vector<int> >::const_iterator
1493           it = all_match_indices[i].begin();
1494           it != all_match_indices[i].end(); ++it) {
1495        const vector<int>& match_index = it->second;
1496        CHECK_EQ(num_priors, match_index.size());
1497        for (int j = 0; j < match_index.size(); ++j) {
1498          if (match_index[j] <= -1) {
1499            continue;
1500          }
1501          Dtype loss = 0;
1502          for (int k = 0; k < 4; ++k) {
1503            Dtype val = diff_data[count * 4 + k];
1504            if (loc_loss_type == MultiBoxLossParameter_LocLossType_SMOOTH_L1) {
1505              Dtype abs_val = fabs(val);
1506              if (abs_val < 1.) {
1507                loss += 0.5 * val * val;
1508              } else {
1509                loss += abs_val - 0.5;
1510              }
1511            } else if (loc_loss_type == MultiBoxLossParameter_LocLossType_L2) {
1512              loss += 0.5 * val * val;
1513            } else {
1514              LOG(FATAL) << "Unknown loc loss type.";
1515            }
1516          }
1517          loc_loss[j] = loss;
1518          ++count;
1519        }
1520      }
1521      all_loc_loss->push_back(loc_loss);
1522    }
1523  }
1524  template void ComputeLocLoss(const Blob<float>& loc_pred,
1525        const Blob<float>& loc_gt,
1526        const vector<map<int, vector<int> > >& all_match_indices,
1527        const int num, const int num_priors, const LocLossType loc_loss_type,
1528        vector<vector<float> >* all_loc_loss);
1529  template void ComputeLocLoss(const Blob<double>& loc_pred,
1530        const Blob<double>& loc_gt,
1531        const vector<map<int, vector<int> > >& all_match_indices,
1532        const int num, const int num_priors, const LocLossType loc_loss_type,
1533        vector<vector<float> >* all_loc_loss);
1534  template <typename Dtype>
1535  void GetConfidenceScores(const Dtype* conf_data, const int num,
1536                           const int num_preds_per_class, const int num_classes,
1537                           vector<map<int, vector<float> > >* conf_preds) {
1538    conf_preds->clear();
1539    conf_preds->resize(num);
1540    Dtype* buffer = new Dtype[num * num_preds_per_class * num_classes];
1541  #ifdef _OPENMP
1542    #if defined(_MSC_EXTENSIONS)
1543      #pragma omp parallel for
1544    #else
1545      #pragma omp parallel for collapse(3)
1546    #endif
1547  #endif
1548    for (int i = 0; i < num; ++i) {
1549      for (int c = 0; c < num_classes; ++c) {
1550        for (int p = 0; p < num_preds_per_class; ++p) {
1551          buffer[i * num_classes * num_preds_per_class + c * num_preds_per_class +
1552                 p] = conf_data[i * num_classes * num_preds_per_class +
1553                                p * num_classes + c];
1554        }
1555      }
1556    }
1557  #ifdef _OPENMP
1558    #pragma omp parallel for 
1559  #endif
1560    for (int i = 0; i < num; i++) {
1561      for (int c = 0; c < num_classes; ++c) {
1562        (*conf_preds)[i][c].reserve(num_preds_per_class);
1563        (*conf_preds)[i][c].assign(
1564            &buffer[i * num_classes * num_preds_per_class +
1565                    c * num_preds_per_class],
1566            &buffer[i * num_classes * num_preds_per_class +
1567                    c * num_preds_per_class + num_preds_per_class]);
1568      }
1569    }
1570    delete[] buffer;
1571  }
1572  template void GetConfidenceScores(const float* conf_data, const int num,
1573        const int num_preds_per_class, const int num_classes,
1574        vector<map<int, vector<float> > >* conf_preds);
1575  template void GetConfidenceScores(const double* conf_data, const int num,
1576        const int num_preds_per_class, const int num_classes,
1577        vector<map<int, vector<float> > >* conf_preds);
1578  template <typename Dtype>
1579  void GetConfidenceScores(const Dtype* conf_data, const int num,
1580        const int num_preds_per_class, const int num_classes,
1581        const bool class_major, vector<map<int, vector<float> > >* conf_preds) {
1582    conf_preds->clear();
1583    conf_preds->resize(num);
1584    for (int i = 0; i < num; ++i) {
1585      map<int, vector<float> >& label_scores = (*conf_preds)[i];
1586      if (class_major) {
1587        for (int c = 0; c < num_classes; ++c) {
1588          label_scores[c].assign(conf_data, conf_data + num_preds_per_class);
1589          conf_data += num_preds_per_class;
1590        }
1591      } else {
1592        for (int p = 0; p < num_preds_per_class; ++p) {
1593          int start_idx = p * num_classes;
1594          for (int c = 0; c < num_classes; ++c) {
1595            label_scores[c].push_back(conf_data[start_idx + c]);
1596          }
1597        }
1598        conf_data += num_preds_per_class * num_classes;
1599      }
1600    }
1601  }
1602  template void GetConfidenceScores(const float* conf_data, const int num,
1603        const int num_preds_per_class, const int num_classes,
1604        const bool class_major, vector<map<int, vector<float> > >* conf_preds);
1605  template void GetConfidenceScores(const double* conf_data, const int num,
1606        const int num_preds_per_class, const int num_classes,
1607        const bool class_major, vector<map<int, vector<float> > >* conf_preds);
1608  template <typename Dtype>
1609  void ComputeConfLoss(const Dtype* conf_data, const int num,
1610        const int num_preds_per_class, const int num_classes,
1611        const int background_label_id, const ConfLossType loss_type,
1612        vector<vector<float> >* all_conf_loss) {
1613    all_conf_loss->clear();
1614    for (int i = 0; i < num; ++i) {
1615      vector<float> conf_loss;
1616      for (int p = 0; p < num_preds_per_class; ++p) {
1617        int start_idx = p * num_classes;
1618        int label = background_label_id;
1619        Dtype loss = 0;
1620        if (loss_type == MultiBoxLossParameter_ConfLossType_SOFTMAX) {
1621          CHECK_GE(label, 0);
1622          CHECK_LT(label, num_classes);
1623          Dtype maxval = -FLT_MAX;
1624          for (int c = 0; c < num_classes; ++c) {
1625            maxval = std::max<Dtype>(conf_data[start_idx + c], maxval);
1626          }
1627          Dtype sum = 0.;
1628          for (int c = 0; c < num_classes; ++c) {
1629            sum += std::exp(conf_data[start_idx + c] - maxval);
1630          }
1631          Dtype prob = std::exp(conf_data[start_idx + label] - maxval) / sum;
1632          loss = -log(std::max(prob, Dtype(FLT_MIN)));
1633        } else if (loss_type == MultiBoxLossParameter_ConfLossType_LOGISTIC) {
1634          int target = 0;
1635          for (int c = 0; c < num_classes; ++c) {
1636            if (c == label) {
1637              target = 1;
1638            } else {
1639              target = 0;
1640            }
1641            Dtype input = conf_data[start_idx + c];
1642            loss -= input * (target - (input >= 0)) -
1643                log(1 + exp(input - 2 * input * (input >= 0)));
1644          }
1645        } else {
1646          LOG(FATAL) << "Unknown conf loss type.";
1647        }
1648        conf_loss.push_back(loss);
1649      }
1650      conf_data += num_preds_per_class * num_classes;
1651      all_conf_loss->push_back(conf_loss);
1652    }
1653  }
1654  template void ComputeConfLoss(const float* conf_data, const int num,
1655        const int num_preds_per_class, const int num_classes,
1656        const int background_label_id, const ConfLossType loss_type,
1657        vector<vector<float> >* all_conf_loss);
1658  template void ComputeConfLoss(const double* conf_data, const int num,
1659        const int num_preds_per_class, const int num_classes,
1660        const int background_label_id, const ConfLossType loss_type,
1661        vector<vector<float> >* all_conf_loss);
1662  template <typename Dtype>
1663  void ComputeConfLoss(const Dtype* conf_data, const int num,
1664        const int num_preds_per_class, const int num_classes,
1665        const int background_label_id, const ConfLossType loss_type,
1666        const vector<map<int, vector<int> > >& all_match_indices,
1667        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1668        vector<vector<float> >* all_conf_loss) {
1669    CHECK_LT(background_label_id, num_classes);
1670    all_conf_loss->clear();
1671    for (int i = 0; i < num; ++i) {
1672      vector<float> conf_loss;
1673      const map<int, vector<int> >& match_indices = all_match_indices[i];
1674      for (int p = 0; p < num_preds_per_class; ++p) {
1675        int start_idx = p * num_classes;
1676        int label = background_label_id;
1677        for (map<int, vector<int> >::const_iterator it =
1678             match_indices.begin(); it != match_indices.end(); ++it) {
1679          const vector<int>& match_index = it->second;
1680          CHECK_EQ(match_index.size(), num_preds_per_class);
1681          if (match_index[p] > -1) {
1682            CHECK(all_gt_bboxes.find(i) != all_gt_bboxes.end());
1683            const vector<NormalizedBBox>& gt_bboxes =
1684                all_gt_bboxes.find(i)->second;
1685            CHECK_LT(match_index[p], gt_bboxes.size());
1686            label = gt_bboxes[match_index[p]].label();
1687            CHECK_GE(label, 0);
1688            CHECK_NE(label, background_label_id);
1689            CHECK_LT(label, num_classes);
1690            break;
1691          }
1692        }
1693        Dtype loss = 0;
1694        if (loss_type == MultiBoxLossParameter_ConfLossType_SOFTMAX) {
1695          CHECK_GE(label, 0);
1696          CHECK_LT(label, num_classes);
1697          Dtype maxval = conf_data[start_idx];
1698          for (int c = 1; c < num_classes; ++c) {
1699            maxval = std::max<Dtype>(conf_data[start_idx + c], maxval);
1700          }
1701          Dtype sum = 0.;
1702          for (int c = 0; c < num_classes; ++c) {
1703            sum += std::exp(conf_data[start_idx + c] - maxval);
1704          }
1705          Dtype prob = std::exp(conf_data[start_idx + label] - maxval) / sum;
1706          loss = -log(std::max(prob, Dtype(FLT_MIN)));
1707        } else if (loss_type == MultiBoxLossParameter_ConfLossType_LOGISTIC) {
1708          int target = 0;
1709          for (int c = 0; c < num_classes; ++c) {
1710            if (c == label) {
1711              target = 1;
1712            } else {
1713              target = 0;
1714            }
1715            Dtype input = conf_data[start_idx + c];
1716            loss -= input * (target - (input >= 0)) -
1717                log(1 + exp(input - 2 * input * (input >= 0)));
1718          }
1719        } else {
1720          LOG(FATAL) << "Unknown conf loss type.";
1721        }
1722        conf_loss.push_back(loss);
1723      }
1724      conf_data += num_preds_per_class * num_classes;
1725      all_conf_loss->push_back(conf_loss);
1726    }
1727  }
1728  template void ComputeConfLoss(const float* conf_data, const int num,
1729        const int num_preds_per_class, const int num_classes,
1730        const int background_label_id, const ConfLossType loss_type,
1731        const vector<map<int, vector<int> > >& all_match_indices,
1732        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1733        vector<vector<float> >* all_conf_loss);
1734  template void ComputeConfLoss(const double* conf_data, const int num,
1735        const int num_preds_per_class, const int num_classes,
1736        const int background_label_id, const ConfLossType loss_type,
1737        const vector<map<int, vector<int> > >& all_match_indices,
1738        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1739        vector<vector<float> >* all_conf_loss);
1740  template <typename Dtype>
1741  void EncodeConfPrediction(const Dtype* conf_data, const int num,
1742        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1743        const vector<map<int, vector<int> > >& all_match_indices,
1744        const vector<vector<int> >& all_neg_indices,
1745        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1746        Dtype* conf_pred_data, Dtype* conf_gt_data) {
1747    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
1748    const int num_classes = multibox_loss_param.num_classes();
1749    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
1750    const int background_label_id = multibox_loss_param.background_label_id();
1751    const bool map_object_to_agnostic =
1752        multibox_loss_param.map_object_to_agnostic();
1753    if (map_object_to_agnostic) {
1754      if (background_label_id >= 0) {
1755        CHECK_EQ(num_classes, 2);
1756      } else {
1757        CHECK_EQ(num_classes, 1);
1758      }
1759    }
1760    const MiningType mining_type = multibox_loss_param.mining_type();
1761    bool do_neg_mining;
1762    if (multibox_loss_param.has_do_neg_mining()) {
1763      LOG(WARNING) << "do_neg_mining is deprecated, use mining_type instead.";
1764      do_neg_mining = multibox_loss_param.do_neg_mining();
1765      CHECK_EQ(do_neg_mining,
1766               mining_type != MultiBoxLossParameter_MiningType_NONE);
1767    }
1768    do_neg_mining = mining_type != MultiBoxLossParameter_MiningType_NONE;
1769    const ConfLossType conf_loss_type = multibox_loss_param.conf_loss_type();
1770    int count = 0;
1771    for (int i = 0; i < num; ++i) {
1772      if (all_gt_bboxes.find(i) != all_gt_bboxes.end()) {
1773        const map<int, vector<int> >& match_indices = all_match_indices[i];
1774        for (map<int, vector<int> >::const_iterator it =
1775            match_indices.begin(); it != match_indices.end(); ++it) {
1776          const vector<int>& match_index = it->second;
1777          CHECK_EQ(match_index.size(), num_priors);
1778          for (int j = 0; j < num_priors; ++j) {
1779            if (match_index[j] <= -1) {
1780              continue;
1781            }
1782            const int gt_label = map_object_to_agnostic ?
1783              background_label_id + 1 :
1784              all_gt_bboxes.find(i)->second[match_index[j]].label();
1785            int idx = do_neg_mining ? count : j;
1786            switch (conf_loss_type) {
1787              case MultiBoxLossParameter_ConfLossType_SOFTMAX:
1788                conf_gt_data[idx] = gt_label;
1789                break;
1790              case MultiBoxLossParameter_ConfLossType_LOGISTIC:
1791                conf_gt_data[idx * num_classes + gt_label] = 1;
1792                break;
1793              default:
1794                LOG(FATAL) << "Unknown conf loss type.";
1795            }
1796            if (do_neg_mining) {
1797              caffe_copy<Dtype>(num_classes, conf_data + j * num_classes,
1798                  conf_pred_data + count * num_classes);
1799              ++count;
1800            }
1801          }
1802        }
1803        if (do_neg_mining) {
1804          for (int n = 0; n < all_neg_indices[i].size(); ++n) {
1805            int j = all_neg_indices[i][n];
1806            CHECK_LT(j, num_priors);
1807            caffe_copy<Dtype>(num_classes, conf_data + j * num_classes,
1808                conf_pred_data + count * num_classes);
1809            switch (conf_loss_type) {
1810              case MultiBoxLossParameter_ConfLossType_SOFTMAX:
1811                conf_gt_data[count] = background_label_id;
1812                break;
1813              case MultiBoxLossParameter_ConfLossType_LOGISTIC:
1814                if (background_label_id >= 0 &&
1815                    background_label_id < num_classes) {
1816                  conf_gt_data[count * num_classes + background_label_id] = 1;
1817                }
1818                break;
1819              default:
1820                LOG(FATAL) << "Unknown conf loss type.";
1821            }
1822            ++count;
1823          }
1824        }
1825      }
1826      if (do_neg_mining) {
1827        conf_data += num_priors * num_classes;
1828      } else {
1829        conf_gt_data += num_priors;
1830      }
1831    }
1832  }
1833  template void EncodeConfPrediction(const float* conf_data, const int num,
1834        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1835        const vector<map<int, vector<int> > >& all_match_indices,
1836        const vector<vector<int> >& all_neg_indices,
1837        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1838        float* conf_pred_data, float* conf_gt_data);
1839  template void EncodeConfPrediction(const double* conf_data, const int num,
1840        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1841        const vector<map<int, vector<int> > >& all_match_indices,
1842        const vector<vector<int> >& all_neg_indices,
1843        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1844        double* conf_pred_data, double* conf_gt_data);
1845  template <typename Dtype>
1846  void GetPriorBBoxes(const Dtype* prior_data, const int num_priors,
1847        vector<NormalizedBBox>* prior_bboxes,
1848        vector<vector<float> >* prior_variances) {
1849  #ifdef _OPENMP
1850    #pragma omp parallel for
1851  #endif
1852    for (int i = 0; i < num_priors; ++i) {
1853      NormalizedBBox bbox;
1854      bbox.set_xmin(prior_data[i*4]);
1855      bbox.set_ymin(prior_data[i*4 + 1]);
1856      bbox.set_xmax(prior_data[i*4 + 2]);
1857      bbox.set_ymax(prior_data[i*4 + 3]);
1858      bbox.set_size(BBoxSize(bbox));
1859      prior_bboxes->at(i) = bbox;
1860    }
1861    vector<float> var(4, 0);
1862    for (int i = 0; i < num_priors; ++i) {
1863      for (int j = 0; j < 4; ++j) {
1864        var.at(j) = (prior_data[(num_priors + i) * 4 + j]);
1865      }
1866      prior_variances->at(i) = var;
1867    }
1868  }
1869  template void GetPriorBBoxes(const float* prior_data, const int num_priors,
1870        vector<NormalizedBBox>* prior_bboxes,
1871        vector<vector<float> >* prior_variances);
1872  template void GetPriorBBoxes(const double* prior_data, const int num_priors,
1873        vector<NormalizedBBox>* prior_bboxes,
1874        vector<vector<float> >* prior_variances);
1875  template <typename Dtype>
1876  void GetDetectionResults(const Dtype* det_data, const int num_det,
1877        const int background_label_id,
1878        map<int, map<int, vector<NormalizedBBox> > >* all_detections) {
1879    all_detections->clear();
1880    for (int i = 0; i < num_det; ++i) {
1881      int start_idx = i * 7;
1882      int item_id = det_data[start_idx];
1883      if (item_id == -1) {
1884        continue;
1885      }
1886      int label = det_data[start_idx + 1];
1887      CHECK_NE(background_label_id, label)
1888          << "Found background label in the detection results.";
1889      NormalizedBBox bbox;
1890      bbox.set_score(det_data[start_idx + 2]);
1891      bbox.set_xmin(det_data[start_idx + 3]);
1892      bbox.set_ymin(det_data[start_idx + 4]);
1893      bbox.set_xmax(det_data[start_idx + 5]);
1894      bbox.set_ymax(det_data[start_idx + 6]);
1895      float bbox_size = BBoxSize(bbox);
1896      bbox.set_size(bbox_size);
1897      (*all_detections)[item_id][label].push_back(bbox);
1898    }
1899  }
1900  template void GetDetectionResults(const float* det_data, const int num_det,
1901        const int background_label_id,
1902        map<int, map<int, vector<NormalizedBBox> > >* all_detections);
1903  template void GetDetectionResults(const double* det_data, const int num_det,
1904        const int background_label_id,
1905        map<int, map<int, vector<NormalizedBBox> > >* all_detections);
1906  void GetTopKScoreIndex(const vector<float>& scores, const vector<int>& indices,
1907        const int top_k, vector<pair<float, int> >* score_index_vec) {
1908    CHECK_EQ(scores.size(), indices.size());
1909    for (int i = 0; i < scores.size(); ++i) {
1910      score_index_vec->push_back(std::make_pair(scores[i], indices[i]));
1911    }
1912    std::stable_sort(score_index_vec->begin(), score_index_vec->end(),
1913                     SortScorePairDescend<int>);
1914    if (top_k > -1 && top_k < score_index_vec->size()) {
1915      score_index_vec->resize(top_k);
1916    }
1917  }
1918  void GetMaxScoreIndex(const vector<float>& scores, const float threshold,
1919        const int top_k, vector<pair<float, int> >* score_index_vec) {
1920  #ifdef _OPENMP
1921    #pragma omp parallel for
1922  #endif
1923    for (int i = 0; i < scores.size(); ++i) {
1924      if (scores[i] > threshold) {
1925        score_index_vec->at(i) = std::make_pair(scores[i], i);
1926      }
1927    }
1928    std::stable_sort(score_index_vec->begin(), score_index_vec->end(),
1929                     SortScorePairDescend<int>);
1930    if (top_k > -1 && top_k < score_index_vec->size()) {
1931      score_index_vec->resize(top_k);
1932    }
1933  }
1934  template <typename Dtype>
1935  void GetMaxScoreIndex(const Dtype* scores, const int num, const float threshold,
1936        const int top_k, vector<pair<Dtype, int> >* score_index_vec) {
1937    for (int i = 0; i < num; ++i) {
1938      if (scores[i] > threshold) {
1939        score_index_vec->push_back(std::make_pair(scores[i], i));
1940      }
1941    }
1942    std::sort(score_index_vec->begin(), score_index_vec->end(),
1943              SortScorePairDescend<int>);
1944    if (top_k > -1 && top_k < score_index_vec->size()) {
1945      score_index_vec->resize(top_k);
1946    }
1947  }
1948  template
1949  void GetMaxScoreIndex(const float* scores, const int num, const float threshold,
1950        const int top_k, vector<pair<float, int> >* score_index_vec);
1951  template
1952  void GetMaxScoreIndex(const double* scores, const int num,
1953        const float threshold, const int top_k,
1954        vector<pair<double, int> >* score_index_vec);
1955  void ApplyNMS(const vector<NormalizedBBox>& bboxes, const vector<float>& scores,
1956        const float threshold, const int top_k, const bool reuse_overlaps,
1957        map<int, map<int, float> >* overlaps, vector<int>* indices) {
1958    CHECK_EQ(bboxes.size(), scores.size())
1959        << "bboxes and scores have different size.";
1960    vector<int> idx(boost::counting_iterator<int>(0),
1961                    boost::counting_iterator<int>(scores.size()));
1962    vector<pair<float, int> > score_index_vec;
1963    GetTopKScoreIndex(scores, idx, top_k, &score_index_vec);
1964    indices->clear();
1965    while (score_index_vec.size() != 0) {
1966      int best_idx = score_index_vec.front().second;
1967      const NormalizedBBox& best_bbox = bboxes[best_idx];
1968      if (BBoxSize(best_bbox) < 1e-5) {
1969        score_index_vec.erase(score_index_vec.begin());
1970        continue;
1971      }
1972      indices->push_back(best_idx);
1973      score_index_vec.erase(score_index_vec.begin());
1974      if (top_k > -1 && indices->size() >= top_k) {
1975        break;
1976      }
1977      for (vector<pair<float, int> >::iterator it = score_index_vec.begin();
1978           it != score_index_vec.end(); ) {
1979        int cur_idx = it->second;
1980        const NormalizedBBox& cur_bbox = bboxes[cur_idx];
1981        if (BBoxSize(cur_bbox) < 1e-5) {
1982          it = score_index_vec.erase(it);
1983          continue;
1984        }
1985        float cur_overlap = 0.;
1986        if (reuse_overlaps) {
1987          if (overlaps->find(best_idx) != overlaps->end() &&
1988              overlaps->find(best_idx)->second.find(cur_idx) !=
1989              (*overlaps)[best_idx].end()) {
1990            cur_overlap = (*overlaps)[best_idx][cur_idx];
1991          } else if (overlaps->find(cur_idx) != overlaps->end() &&
1992                     overlaps->find(cur_idx)->second.find(best_idx) !=
1993                     (*overlaps)[cur_idx].end()) {
1994            cur_overlap = (*overlaps)[cur_idx][best_idx];
1995          } else {
1996            cur_overlap = JaccardOverlap(best_bbox, cur_bbox);
1997            (*overlaps)[best_idx][cur_idx] = cur_overlap;
1998          }
1999        } else {
2000          cur_overlap = JaccardOverlap(best_bbox, cur_bbox);
2001        }
2002        if (cur_overlap > threshold) {
2003          it = score_index_vec.erase(it);
2004        } else {
2005          ++it;
2006        }
2007      }
2008    }
2009  }
2010  void ApplyNMS(const vector<NormalizedBBox>& bboxes, const vector<float>& scores,
2011        const float threshold, const int top_k, vector<int>* indices) {
2012    bool reuse_overlap = false;
2013    map<int, map<int, float> > overlaps;
2014    ApplyNMS(bboxes, scores, threshold, top_k, reuse_overlap, &overlaps, indices);
2015  }
2016  void ApplyNMS(const bool* overlapped, const int num, vector<int>* indices) {
2017    vector<int> index_vec(boost::counting_iterator<int>(0),
2018                          boost::counting_iterator<int>(num));
2019    indices->clear();
2020    while (index_vec.size() != 0) {
2021      int best_idx = index_vec.front();
2022      indices->push_back(best_idx);
2023      index_vec.erase(index_vec.begin());
2024      for (vector<int>::iterator it = index_vec.begin(); it != index_vec.end();) {
2025        int cur_idx = *it;
2026        if (overlapped[best_idx * num + cur_idx]) {
2027          it = index_vec.erase(it);
2028        } else {
2029          ++it;
2030        }
2031      }
2032    }
2033  }
2034  inline int clamp(const int v, const int a, const int b) {
2035    return v < a ? a : v > b ? b : v;
2036  }
2037  void ApplyNMSFast(const vector<NormalizedBBox>& bboxes,
2038                    const vector<float>& scores, const float score_threshold,
2039                    const float nms_threshold, const float eta, const int top_k,
2040                    vector<int>* indices) {
2041    CHECK_EQ(bboxes.size(), scores.size())
2042        << "bboxes and scores have different size.";
2043    vector<pair<float, int> > score_index_vec(scores.size());
2044    GetMaxScoreIndex(scores, score_threshold, top_k, &score_index_vec);
2045    float adaptive_threshold = nms_threshold;
2046    indices->clear();
2047  #ifdef ENABLE_NMS_OPTIMIZATION
2048    if (_may_i_use_cpu_feature(_FEATURE_AVX512CD | _FEATURE_AVX512F)) {
2049      if (score_index_vec.size() == 0) return;
2050      indices->resize(score_index_vec.size());
2051      int* p = (int*)malloc(sizeof(int) * score_index_vec.size());
2052      int num_out = 0;
2053      cpu_nms_avx512_caffe(p, &num_out, bboxes, score_index_vec, nms_threshold);
2054      indices->assign(p, p + num_out);
2055      free(p);
2056    } else {
2057  #endif
2058      while (score_index_vec.size() != 0) {
2059        const int idx = score_index_vec.front().second;
2060        bool keep = true;
2061        for (int k = 0; k < indices->size(); ++k) {
2062          if (keep) {
2063            const int kept_idx = (*indices)[k];
2064            float overlap = JaccardOverlap(bboxes[idx], bboxes[kept_idx]);
2065            keep = overlap <= adaptive_threshold;
2066          } else {
2067            break;
2068          }
2069        }
2070        if (keep) {
2071          indices->push_back(idx);
2072        }
2073        score_index_vec.erase(score_index_vec.begin());
2074        if (keep && eta < 1 && adaptive_threshold > 0.5) {
2075          adaptive_threshold *= eta;
2076        }
2077      }
2078  #ifdef ENABLE_NMS_OPTIMIZATION
2079    }
2080  #endif
2081  }
2082  template <typename Dtype>
2083  void ApplyNMSFast(const Dtype* bboxes, const Dtype* scores, const int num,
2084        const float score_threshold, const float nms_threshold,
2085        const float eta, const int top_k, vector<int>* indices) {
2086    vector<pair<Dtype, int> > score_index_vec;
2087    GetMaxScoreIndex(scores, num, score_threshold, top_k, &score_index_vec);
2088    float adaptive_threshold = nms_threshold;
2089    indices->clear();
2090    while (score_index_vec.size() != 0) {
2091      const int idx = score_index_vec.front().second;
2092      bool keep = true;
2093      for (int k = 0; k < indices->size(); ++k) {
2094        if (keep) {
2095          const int kept_idx = (*indices)[k];
2096          float overlap = JaccardOverlap(bboxes + idx * 4, bboxes + kept_idx * 4);
2097          keep = overlap <= adaptive_threshold;
2098        } else {
2099          break;
2100        }
2101      }
2102      if (keep) {
2103        indices->push_back(idx);
2104      }
2105      score_index_vec.erase(score_index_vec.begin());
2106      if (keep && eta < 1 && adaptive_threshold > 0.5) {
2107        adaptive_threshold *= eta;
2108      }
2109    }
2110  }
2111  template
2112  void ApplyNMSFast(const float* bboxes, const float* scores, const int num,
2113        const float score_threshold, const float nms_threshold,
2114        const float eta, const int top_k, vector<int>* indices);
2115  template
2116  void ApplyNMSFast(const double* bboxes, const double* scores, const int num,
2117        const float score_threshold, const float nms_threshold,
2118        const float eta, const int top_k, vector<int>* indices);
2119  void CumSum(const vector<pair<float, int> >& pairs, vector<int>* cumsum) {
2120    vector<pair<float, int> > sort_pairs = pairs;
2121    std::stable_sort(sort_pairs.begin(), sort_pairs.end(),
2122                     SortScorePairDescend<int>);
2123    cumsum->clear();
2124    for (int i = 0; i < sort_pairs.size(); ++i) {
2125      if (i == 0) {
2126        cumsum->push_back(sort_pairs[i].second);
2127      } else {
2128        cumsum->push_back(cumsum->back() + sort_pairs[i].second);
2129      }
2130    }
2131  }
2132  void ComputeAP(const vector<pair<float, int> >& tp, const int num_pos,
2133                 const vector<pair<float, int> >& fp, const string ap_version,
2134                 vector<float>* prec, vector<float>* rec, float* ap) {
2135    const float eps = 1e-6;
2136    CHECK_EQ(tp.size(), fp.size()) << "tp must have same size as fp.";
2137    const int num = tp.size();
2138    for (int i = 0; i < num; ++i) {
2139      CHECK_LE(fabs(tp[i].first - fp[i].first), eps);
2140      CHECK_EQ(tp[i].second, 1 - fp[i].second);
2141    }
2142    prec->clear();
2143    rec->clear();
2144    *ap = 0;
2145    if (tp.size() == 0 || num_pos == 0) {
2146      return;
2147    }
2148    vector<int> tp_cumsum;
2149    CumSum(tp, &tp_cumsum);
2150    CHECK_EQ(tp_cumsum.size(), num);
2151    vector<int> fp_cumsum;
2152    CumSum(fp, &fp_cumsum);
2153    CHECK_EQ(fp_cumsum.size(), num);
2154    for (int i = 0; i < num; ++i) {
2155      prec->push_back(static_cast<float>(tp_cumsum[i]) /
2156                      (tp_cumsum[i] + fp_cumsum[i]));
2157    }
2158    for (int i = 0; i < num; ++i) {
2159      CHECK_LE(tp_cumsum[i], num_pos);
2160      rec->push_back(static_cast<float>(tp_cumsum[i]) / num_pos);
2161    }
2162    if (ap_version == "11point") {
2163      vector<float> max_precs(11, 0.);
2164      int start_idx = num - 1;
2165      for (int j = 10; j >= 0; --j) {
2166        for (int i = start_idx; i >= 0 ; --i) {
2167          if ((*rec)[i] < j / 10.) {
2168            start_idx = i;
2169            if (j > 0) {
2170              max_precs[j-1] = max_precs[j];
2171            }
2172            break;
2173          } else {
2174            if (max_precs[j] < (*prec)[i]) {
2175              max_precs[j] = (*prec)[i];
2176            }
2177          }
2178        }
2179      }
2180      for (int j = 10; j >= 0; --j) {
2181        *ap += max_precs[j] / 11;
2182      }
2183    } else if (ap_version == "MaxIntegral") {
2184      float cur_rec = rec->back();
2185      float cur_prec = prec->back();
2186      for (int i = num - 2; i >= 0; --i) {
2187        cur_prec = std::max<float>((*prec)[i], cur_prec);
2188        if (fabs(cur_rec - (*rec)[i]) > eps) {
2189          *ap += cur_prec * fabs(cur_rec - (*rec)[i]);
2190        }
2191        cur_rec = (*rec)[i];
2192      }
2193      *ap += cur_rec * cur_prec;
2194    } else if (ap_version == "Integral") {
2195      float prev_rec = 0.;
2196      for (int i = 0; i < num; ++i) {
2197        if (fabs((*rec)[i] - prev_rec) > eps) {
2198          *ap += (*prec)[i] * fabs((*rec)[i] - prev_rec);
2199        }
2200        prev_rec = (*rec)[i];
2201      }
2202    } else {
2203      LOG(FATAL) << "Unknown ap_version: " << ap_version;
2204    }
2205  }
2206  #ifdef USE_OPENCV
2207  cv::Scalar HSV2RGB(const float h, const float s, const float v) {
2208    const int h_i = static_cast<int>(h * 6);
2209    const float f = h * 6 - h_i;
2210    const float p = v * (1 - s);
2211    const float q = v * (1 - f*s);
2212    const float t = v * (1 - (1 - f) * s);
2213    float r, g, b;
2214    switch (h_i) {
2215      case 0:
2216        r = v; g = t; b = p;
2217        break;
2218      case 1:
2219        r = q; g = v; b = p;
2220        break;
2221      case 2:
2222        r = p; g = v; b = t;
2223        break;
2224      case 3:
2225        r = p; g = q; b = v;
2226        break;
2227      case 4:
2228        r = t; g = p; b = v;
2229        break;
2230      case 5:
2231        r = v; g = p; b = q;
2232        break;
2233      default:
2234        r = 1; g = 1; b = 1;
2235        break;
2236    }
2237    return cv::Scalar(r * 255, g * 255, b * 255);
2238  }
2239  vector<cv::Scalar> GetColors(const int n) {
2240    vector<cv::Scalar> colors;
2241    cv::RNG rng(12345);
2242    const float golden_ratio_conjugate = 0.618033988749895;
2243    const float s = 0.3;
2244    const float v = 0.99;
2245    for (int i = 0; i < n; ++i) {
2246      const float h = std::fmod(rng.uniform(0.f, 1.f) + golden_ratio_conjugate,
2247                                1.f);
2248      colors.push_back(HSV2RGB(h, s, v));
2249    }
2250    return colors;
2251  }
2252  static clock_t start_clock = clock();
2253  static cv::VideoWriter cap_out;
2254  template <typename Dtype>
2255  void VisualizeBBox(const vector<cv::Mat>& images, const Blob<Dtype>* detections,
2256                     const float threshold, const vector<cv::Scalar>& colors,
2257                     const map<int, string>& label_to_display_name,
2258                     const string& save_file) {
2259    CHECK_EQ(detections->width(), 7);
2260    const int num_det = detections->height();
2261    const int num_img = images.size();
2262    if (num_det == 0 || num_img == 0) {
2263      return;
2264    }
2265    float fps = num_img / (static_cast<double>(clock() - start_clock) /
2266            CLOCKS_PER_SEC);
2267    const Dtype* detections_data = detections->cpu_data();
2268    const int width = images[0].cols;
2269    const int height = images[0].rows;
2270    vector<LabelBBox> all_detections(num_img);
2271    for (int i = 0; i < num_det; ++i) {
2272      const int img_idx = detections_data[i * 7];
2273      CHECK_LT(img_idx, num_img);
2274      const int label = detections_data[i * 7 + 1];
2275      const float score = detections_data[i * 7 + 2];
2276      if (score < threshold) {
2277        continue;
2278      }
2279      NormalizedBBox bbox;
2280      bbox.set_xmin(detections_data[i * 7 + 3] * width);
2281      bbox.set_ymin(detections_data[i * 7 + 4] * height);
2282      bbox.set_xmax(detections_data[i * 7 + 5] * width);
2283      bbox.set_ymax(detections_data[i * 7 + 6] * height);
2284      bbox.set_score(score);
2285      all_detections[img_idx][label].push_back(bbox);
2286    }
2287    int fontface = cv::FONT_HERSHEY_SIMPLEX;
2288    double scale = 1;
2289    int thickness = 2;
2290    int baseline = 0;
2291    char buffer[50];
2292    for (int i = 0; i < num_img; ++i) {
2293      cv::Mat image = images[i];
2294      snprintf(buffer, sizeof(buffer), "FPS: %.2f", fps);
2295      cv::Size text = cv::getTextSize(buffer, fontface, scale, thickness,
2296                                      &baseline);
2297      cv::rectangle(image, cv::Point(0, 0),
2298                    cv::Point(text.width, text.height + baseline),
2299                    CV_RGB(255, 255, 255), CV_FILLED);
2300      cv::putText(image, buffer, cv::Point(0, text.height + baseline / 2.),
2301                  fontface, scale, CV_RGB(0, 0, 0), thickness, 8);
2302      for (map<int, vector<NormalizedBBox> >::iterator it =
2303           all_detections[i].begin(); it != all_detections[i].end(); ++it) {
2304        int label = it->first;
2305        string label_name = "Unknown";
2306        if (label_to_display_name.find(label) != label_to_display_name.end()) {
2307          label_name = label_to_display_name.find(label)->second;
2308        }
2309        CHECK_LT(label, colors.size());
2310        const cv::Scalar& color = colors[label];
2311        const vector<NormalizedBBox>& bboxes = it->second;
2312        for (int j = 0; j < bboxes.size(); ++j) {
2313          cv::Point top_left_pt(bboxes[j].xmin(), bboxes[j].ymin());
2314          cv::Point bottom_right_pt(bboxes[j].xmax(), bboxes[j].ymax());
2315          cv::rectangle(image, top_left_pt, bottom_right_pt, color, 4);
2316          cv::Point bottom_left_pt(bboxes[j].xmin(), bboxes[j].ymax());
2317          snprintf(buffer, sizeof(buffer), "%s: %.2f", label_name.c_str(),
2318                   bboxes[j].score());
2319          cv::Size text = cv::getTextSize(buffer, fontface, scale, thickness,
2320                                          &baseline);
2321          cv::rectangle(
2322              image, bottom_left_pt + cv::Point(0, 0),
2323              bottom_left_pt + cv::Point(text.width, -text.height-baseline),
2324              color, CV_FILLED);
2325          cv::putText(image, buffer, bottom_left_pt - cv::Point(0, baseline),
2326                      fontface, scale, CV_RGB(0, 0, 0), thickness, 8);
2327        }
2328      }
2329      if (!save_file.empty()) {
2330        if (!cap_out.isOpened()) {
2331          cv::Size size(image.size().width, image.size().height);
2332          cv::VideoWriter outputVideo(save_file, CV_FOURCC('D', 'I', 'V', 'X'),
2333              30, size, true);
2334          cap_out = outputVideo;
2335        }
2336        cap_out.write(image);
2337      }
2338      cv::imshow("detections", image);
2339      if (cv::waitKey(1) == 27) {
2340        raise(SIGINT);
2341      }
2342    }
2343    start_clock = clock();
2344  }
2345  template
2346  void VisualizeBBox(const vector<cv::Mat>& images,
2347                     const Blob<float>* detections,
2348                     const float threshold, const vector<cv::Scalar>& colors,
2349                     const map<int, string>& label_to_display_name,
2350                     const string& save_file);
2351  template
2352  void VisualizeBBox(const vector<cv::Mat>& images,
2353                     const Blob<double>* detections,
2354                     const float threshold, const vector<cv::Scalar>& colors,
2355                     const map<int, string>& label_to_display_name,
2356                     const string& save_file);
2357  #endif  
2358  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-bbox_util.cpp</div>
                </div>
                <div class="column column_space"><pre><code>277          const TStr& DisplayBody = TStr(), const TStrV& CatNmV = TStrV(),
278          const TStrV& AuthorV = TStrV(), const TStr& FrameNm = TStr(),
279          const int& FrameSortN = -1);
</pre></code></div>
                <div class="column column_space"><pre><code>594      const Dtype inter_xmin = std::max(bbox1[0], bbox2[0]);
595      const Dtype inter_ymin = std::max(bbox1[1], bbox2[1]);
596      const Dtype inter_xmax = std::min(bbox1[2], bbox2[2]);
597      const Dtype inter_ymax = std::min(bbox1[3], bbox2[3]);
598      const Dtype inter_width = inter_xmax - inter_xmin;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    