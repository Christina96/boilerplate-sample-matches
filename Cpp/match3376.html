<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_tile_layer.cpp &amp; test_data_layer.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_tile_layer.cpp &amp; test_data_layer.cpp
      </h3>
<h1 align="center">
        4.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_tile_layer.cpp (6.6985645%)<th>test_data_layer.cpp (3.3096926%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-23)<td><a href="#" name="0">(22-32)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_tile_layer.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;vector&gt;
2 #include "gtest/gtest.h"
3 #include "caffe/blob.hpp"
4 #include "caffe/common.hpp"
5 #include "caffe/filler.hpp"
6 #include "caffe/layers/tile_layer.hpp"
7 #include "caffe/test/test_caffe_main.hpp"
8 #include "caffe/test/test_gradient_check_util.hpp"
9 <a name="0"></a>
10 namespace caffe {
11 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>template &lt;typename TypeParam&gt;
12 class TileLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
13   typedef typename TypeParam::Dtype Dtype;
14  protected:
15   TileLayerTest()
16       : blob_bottom_(new Blob&lt;Dtype&gt;(2, 3, 4, 5)),
17         blob_top_(new Blob&lt;Dtype&gt;()) {}
18   virtual void SetUp() {</b></font>
19     blob_bottom_vec_.push_back(blob_bottom_);
20     blob_top_vec_.push_back(blob_top_);
21     FillerParameter filler_param;
22     filler_param.set_mean(0.0);
23     filler_param.set_std(1.0);
24     GaussianFiller&lt;Dtype&gt; filler(filler_param);
25     filler.Fill(blob_bottom_);
26   }
27   virtual ~TileLayerTest() {
28     delete blob_bottom_;
29     delete blob_top_;
30   }
31   Blob&lt;Dtype&gt;* const blob_bottom_;
32   Blob&lt;Dtype&gt;* const blob_top_;
33   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
34   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
35 };
36 TYPED_TEST_CASE(TileLayerTest, TestDtypesAndDevices);
37 TYPED_TEST(TileLayerTest, TestTrivialSetup) {
38   typedef typename TypeParam::Dtype Dtype;
39   LayerParameter layer_param;
40   const int kNumTiles = 1;
41   layer_param.mutable_tile_param()-&gt;set_tiles(kNumTiles);
42   for (int i = 0; i &lt; this-&gt;blob_bottom_-&gt;num_axes(); ++i) {
43     layer_param.mutable_tile_param()-&gt;set_axis(i);
44     TileLayer&lt;Dtype&gt; layer(layer_param);
45     layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
46     ASSERT_EQ(this-&gt;blob_top_-&gt;num_axes(), this-&gt;blob_bottom_-&gt;num_axes());
47     for (int j = 0; j &lt; this-&gt;blob_bottom_-&gt;num_axes(); ++j) {
48       EXPECT_EQ(this-&gt;blob_top_-&gt;shape(j), this-&gt;blob_bottom_-&gt;shape(j));
49     }
50   }
51 }
52 TYPED_TEST(TileLayerTest, TestSetup) {
53   typedef typename TypeParam::Dtype Dtype;
54   LayerParameter layer_param;
55   const int kNumTiles = 3;
56   layer_param.mutable_tile_param()-&gt;set_tiles(kNumTiles);
57   for (int i = 0; i &lt; this-&gt;blob_bottom_-&gt;num_axes(); ++i) {
58     layer_param.mutable_tile_param()-&gt;set_axis(i);
59     TileLayer&lt;Dtype&gt; layer(layer_param);
60     layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
61     ASSERT_EQ(this-&gt;blob_top_-&gt;num_axes(), this-&gt;blob_bottom_-&gt;num_axes());
62     for (int j = 0; j &lt; this-&gt;blob_bottom_-&gt;num_axes(); ++j) {
63       const int top_dim =
64           ((i == j) ? kNumTiles : 1) * this-&gt;blob_bottom_-&gt;shape(j);
65       EXPECT_EQ(top_dim, this-&gt;blob_top_-&gt;shape(j));
66     }
67   }
68 }
69 TYPED_TEST(TileLayerTest, TestForwardNum) {
70   typedef typename TypeParam::Dtype Dtype;
71   LayerParameter layer_param;
72   const int kTileAxis = 0;
73   const int kNumTiles = 3;
74   layer_param.mutable_tile_param()-&gt;set_axis(kTileAxis);
75   layer_param.mutable_tile_param()-&gt;set_tiles(kNumTiles);
76   TileLayer&lt;Dtype&gt; layer(layer_param);
77   layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
78   layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
79   for (int n = 0; n &lt; this-&gt;blob_top_-&gt;num(); ++n) {
80     for (int c = 0; c &lt; this-&gt;blob_top_-&gt;channels(); ++c) {
81        for (int h = 0; h &lt; this-&gt;blob_top_-&gt;height(); ++h) {
82          for (int w = 0; w &lt; this-&gt;blob_top_-&gt;width(); ++w) {
83            const int bottom_n = n % this-&gt;blob_bottom_-&gt;num();
84            EXPECT_EQ(this-&gt;blob_bottom_-&gt;data_at(bottom_n, c, h, w),
85                      this-&gt;blob_top_-&gt;data_at(n, c, h, w));
86          }
87        }
88     }
89   }
90 }
91 TYPED_TEST(TileLayerTest, TestForwardChannels) {
92   typedef typename TypeParam::Dtype Dtype;
93   LayerParameter layer_param;
94   const int kNumTiles = 3;
95   layer_param.mutable_tile_param()-&gt;set_tiles(kNumTiles);
96   TileLayer&lt;Dtype&gt; layer(layer_param);
97   layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
98   layer.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
99   for (int n = 0; n &lt; this-&gt;blob_top_-&gt;num(); ++n) {
100     for (int c = 0; c &lt; this-&gt;blob_top_-&gt;channels(); ++c) {
101        for (int h = 0; h &lt; this-&gt;blob_top_-&gt;height(); ++h) {
102          for (int w = 0; w &lt; this-&gt;blob_top_-&gt;width(); ++w) {
103            const int bottom_c = c % this-&gt;blob_bottom_-&gt;channels();
104            EXPECT_EQ(this-&gt;blob_bottom_-&gt;data_at(n, bottom_c, h, w),
105                      this-&gt;blob_top_-&gt;data_at(n, c, h, w));
106          }
107        }
108     }
109   }
110 }
111 TYPED_TEST(TileLayerTest, TestTrivialGradient) {
112   typedef typename TypeParam::Dtype Dtype;
113   LayerParameter layer_param;
114   const int kNumTiles = 1;
115   layer_param.mutable_tile_param()-&gt;set_tiles(kNumTiles);
116   TileLayer&lt;Dtype&gt; layer(layer_param);
117   GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-2);
118   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
119       this-&gt;blob_top_vec_);
120 }
121 TYPED_TEST(TileLayerTest, TestGradientNum) {
122   typedef typename TypeParam::Dtype Dtype;
123   LayerParameter layer_param;
124   const int kTileAxis = 0;
125   const int kNumTiles = 3;
126   layer_param.mutable_tile_param()-&gt;set_axis(kTileAxis);
127   layer_param.mutable_tile_param()-&gt;set_tiles(kNumTiles);
128   TileLayer&lt;Dtype&gt; layer(layer_param);
129   GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-2);
130   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
131       this-&gt;blob_top_vec_);
132 }
133 TYPED_TEST(TileLayerTest, TestGradientChannels) {
134   typedef typename TypeParam::Dtype Dtype;
135   LayerParameter layer_param;
136   const int kTileAxis = 1;
137   const int kNumTiles = 3;
138   layer_param.mutable_tile_param()-&gt;set_axis(kTileAxis);
139   layer_param.mutable_tile_param()-&gt;set_tiles(kNumTiles);
140   TileLayer&lt;Dtype&gt; layer(layer_param);
141   GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-2);
142   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
143       this-&gt;blob_top_vec_);
144 }
}  </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_data_layer.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef USE_OPENCV
2 #include &lt;string&gt;
3 #include &lt;vector&gt;
4 #include "boost/scoped_ptr.hpp"
5 #include "gtest/gtest.h"
6 #include "caffe/blob.hpp"
7 #include "caffe/common.hpp"
8 #include "caffe/filler.hpp"
9 #include "caffe/layers/data_layer.hpp"
10 #include "caffe/proto/caffe.pb.h"
11 #include "caffe/util/db.hpp"
12 #include "caffe/util/io.hpp"
13 #include "caffe/test/test_caffe_main.hpp"
14 namespace caffe {
15 <a name="0"></a>
16 using boost::scoped_ptr;
17 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>template &lt;typename TypeParam&gt;
18 class DataLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
19   typedef typename TypeParam::Dtype Dtype;
20  protected:
21   DataLayerTest()
22       : backend_(DataParameter_DB_LEVELDB),
23         blob_top_data_(new Blob&lt;Dtype&gt;()),
24         blob_top_label_(new Blob&lt;Dtype&gt;()),
25         seed_(1701) {}
26   virtual void SetUp() {</b></font>
27     filename_.reset(new string());
28     MakeTempDir(filename_.get());
29     *filename_ += "/db";
30     blob_top_vec_.push_back(blob_top_data_);
31     blob_top_vec_.push_back(blob_top_label_);
32   }
33   void Fill(const bool unique_pixels, DataParameter_DB backend) {
34     backend_ = backend;
35     LOG(INFO) &lt;&lt; "Using temporary dataset " &lt;&lt; *filename_;
36     scoped_ptr&lt;db::DB&gt; db(db::GetDB(backend));
37     db-&gt;Open(*filename_, db::NEW);
38     scoped_ptr&lt;db::Transaction&gt; txn(db-&gt;NewTransaction());
39     for (int i = 0; i &lt; 5; ++i) {
40       Datum datum;
41       datum.set_label(i);
42       datum.set_channels(2);
43       datum.set_height(3);
44       datum.set_width(4);
45       std::string* data = datum.mutable_data();
46       for (int j = 0; j &lt; 24; ++j) {
47         int datum = unique_pixels ? j : i;
48         data-&gt;push_back(static_cast&lt;uint8_t&gt;(datum));
49       }
50       stringstream ss;
51       ss &lt;&lt; i;
52       string out;
53       CHECK(datum.SerializeToString(&amp;out));
54       txn-&gt;Put(ss.str(), out);
55     }
56     txn-&gt;Commit();
57     db-&gt;Close();
58   }
59   void TestRead() {
60     const Dtype scale = 3;
61     LayerParameter param;
62     param.set_phase(TRAIN);
63     DataParameter* data_param = param.mutable_data_param();
64     data_param-&gt;set_batch_size(5);
65     data_param-&gt;set_source(filename_-&gt;c_str());
66     data_param-&gt;set_backend(backend_);
67     TransformationParameter* transform_param =
68         param.mutable_transform_param();
69     transform_param-&gt;set_scale(scale);
70     DataLayer&lt;Dtype&gt; layer(param);
71     layer.SetUp(blob_bottom_vec_, blob_top_vec_);
72     EXPECT_EQ(blob_top_data_-&gt;num(), 5);
73     EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
74     EXPECT_EQ(blob_top_data_-&gt;height(), 3);
75     EXPECT_EQ(blob_top_data_-&gt;width(), 4);
76     EXPECT_EQ(blob_top_label_-&gt;num(), 5);
77     EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
78     EXPECT_EQ(blob_top_label_-&gt;height(), 1);
79     EXPECT_EQ(blob_top_label_-&gt;width(), 1);
80     for (int iter = 0; iter &lt; 100; ++iter) {
81       layer.Forward(blob_bottom_vec_, blob_top_vec_);
82       for (int i = 0; i &lt; 5; ++i) {
83         EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
84       }
85       for (int i = 0; i &lt; 5; ++i) {
86         for (int j = 0; j &lt; 24; ++j) {
87           EXPECT_EQ(scale * i, blob_top_data_-&gt;cpu_data()[i * 24 + j])
88               &lt;&lt; "debug: iter " &lt;&lt; iter &lt;&lt; " i " &lt;&lt; i &lt;&lt; " j " &lt;&lt; j;
89         }
90       }
91     }
92   }
93   void TestSkip() {
94     LayerParameter param;
95     param.set_phase(TRAIN);
96     DataParameter* data_param = param.mutable_data_param();
97     int batch_size = 5;
98     data_param-&gt;set_batch_size(batch_size);
99     data_param-&gt;set_source(filename_-&gt;c_str());
100     data_param-&gt;set_backend(backend_);
101     Caffe::set_solver_count(8);
102     for (int dev = 0; dev &lt; Caffe::solver_count(); ++dev) {
103       Caffe::set_solver_rank(dev);
104       DataLayer&lt;Dtype&gt; layer(param);
105       layer.SetUp(blob_bottom_vec_, blob_top_vec_);
106       int label = dev;
107       for (int iter = 0; iter &lt; 10; ++iter) {
108         layer.Forward(blob_bottom_vec_, blob_top_vec_);
109         for (int i = 0; i &lt; batch_size; ++i) {
110           EXPECT_EQ(label % batch_size, blob_top_label_-&gt;cpu_data()[i]);
111           label += Caffe::solver_count();
112         }
113       }
114     }
115     Caffe::set_solver_count(1);
116     Caffe::set_solver_rank(0);
117   }
118   void TestReshape(DataParameter_DB backend) {
119     const int num_inputs = 5;
120     LOG(INFO) &lt;&lt; "Using temporary dataset " &lt;&lt; *filename_;
121     scoped_ptr&lt;db::DB&gt; db(db::GetDB(backend));
122     db-&gt;Open(*filename_, db::NEW);
123     scoped_ptr&lt;db::Transaction&gt; txn(db-&gt;NewTransaction());
124     for (int i = 0; i &lt; num_inputs; ++i) {
125       Datum datum;
126       datum.set_label(i);
127       datum.set_channels(2);
128       datum.set_height(i % 2 + 1);
129       datum.set_width(i % 4 + 1);
130       std::string* data = datum.mutable_data();
131       const int data_size = datum.channels() * datum.height() * datum.width();
132       for (int j = 0; j &lt; data_size; ++j) {
133         data-&gt;push_back(static_cast&lt;uint8_t&gt;(j));
134       }
135       stringstream ss;
136       ss &lt;&lt; i;
137       string out;
138       CHECK(datum.SerializeToString(&amp;out));
139       txn-&gt;Put(ss.str(), out);
140     }
141     txn-&gt;Commit();
142     db-&gt;Close();
143     LayerParameter param;
144     param.set_phase(TEST);
145     DataParameter* data_param = param.mutable_data_param();
146     data_param-&gt;set_batch_size(1);
147     data_param-&gt;set_source(filename_-&gt;c_str());
148     data_param-&gt;set_backend(backend);
149     DataLayer&lt;Dtype&gt; layer(param);
150     layer.SetUp(blob_bottom_vec_, blob_top_vec_);
151     EXPECT_EQ(blob_top_data_-&gt;num(), 1);
152     EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
153     EXPECT_EQ(blob_top_label_-&gt;num(), 1);
154     EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
155     EXPECT_EQ(blob_top_label_-&gt;height(), 1);
156     EXPECT_EQ(blob_top_label_-&gt;width(), 1);
157     for (int iter = 0; iter &lt; num_inputs; ++iter) {
158       layer.Forward(blob_bottom_vec_, blob_top_vec_);
159       EXPECT_EQ(blob_top_data_-&gt;height(), iter % 2 + 1);
160       EXPECT_EQ(blob_top_data_-&gt;width(), iter % 4 + 1);
161       EXPECT_EQ(iter, blob_top_label_-&gt;cpu_data()[0]);
162       const int channels = blob_top_data_-&gt;channels();
163       const int height = blob_top_data_-&gt;height();
164       const int width = blob_top_data_-&gt;width();
165       for (int c = 0; c &lt; channels; ++c) {
166         for (int h = 0; h &lt; height; ++h) {
167           for (int w = 0; w &lt; width; ++w) {
168             const int idx = (c * height + h) * width + w;
169             EXPECT_EQ(idx, static_cast&lt;int&gt;(blob_top_data_-&gt;cpu_data()[idx]))
170                 &lt;&lt; "debug: iter " &lt;&lt; iter &lt;&lt; " c " &lt;&lt; c
171                 &lt;&lt; " h " &lt;&lt; h &lt;&lt; " w " &lt;&lt; w;
172           }
173         }
174       }
175     }
176   }
177   void TestReadCrop(Phase phase) {
178     const Dtype scale = 3;
179     LayerParameter param;
180     param.set_phase(phase);
181     Caffe::set_random_seed(1701);
182     DataParameter* data_param = param.mutable_data_param();
183     data_param-&gt;set_batch_size(5);
184     data_param-&gt;set_source(filename_-&gt;c_str());
185     data_param-&gt;set_backend(backend_);
186     TransformationParameter* transform_param =
187         param.mutable_transform_param();
188     transform_param-&gt;set_scale(scale);
189     transform_param-&gt;set_crop_size(1);
190     DataLayer&lt;Dtype&gt; layer(param);
191     layer.SetUp(blob_bottom_vec_, blob_top_vec_);
192     EXPECT_EQ(blob_top_data_-&gt;num(), 5);
193     EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
194     EXPECT_EQ(blob_top_data_-&gt;height(), 1);
195     EXPECT_EQ(blob_top_data_-&gt;width(), 1);
196     EXPECT_EQ(blob_top_label_-&gt;num(), 5);
197     EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
198     EXPECT_EQ(blob_top_label_-&gt;height(), 1);
199     EXPECT_EQ(blob_top_label_-&gt;width(), 1);
200     for (int iter = 0; iter &lt; 2; ++iter) {
201       layer.Forward(blob_bottom_vec_, blob_top_vec_);
202       for (int i = 0; i &lt; 5; ++i) {
203         EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
204       }
205       int num_with_center_value = 0;
206       for (int i = 0; i &lt; 5; ++i) {
207         for (int j = 0; j &lt; 2; ++j) {
208           const Dtype center_value = scale * (j ? 17 : 5);
209           num_with_center_value +=
210               (center_value == blob_top_data_-&gt;cpu_data()[i * 2 + j]);
211           if (phase == caffe::TEST) {
212             EXPECT_EQ(center_value, this-&gt;blob_top_data_-&gt;cpu_data()[i * 2 + j])
213                 &lt;&lt; "debug: iter " &lt;&lt; iter &lt;&lt; " i " &lt;&lt; i &lt;&lt; " j " &lt;&lt; j;
214           }
215         }
216       }
217       if (phase == caffe::TRAIN) {
218         EXPECT_LT(num_with_center_value, 10);
219       }
220     }
221   }
222   void TestReadCropTrainSequenceSeeded() {
223     LayerParameter param;
224     param.set_phase(TRAIN);
225     DataParameter* data_param = param.mutable_data_param();
226     data_param-&gt;set_batch_size(5);
227     data_param-&gt;set_source(filename_-&gt;c_str());
228     data_param-&gt;set_backend(backend_);
229     TransformationParameter* transform_param =
230         param.mutable_transform_param();
231     transform_param-&gt;set_crop_size(1);
232     transform_param-&gt;set_mirror(true);
233     Caffe::set_random_seed(seed_);
234     vector&lt;vector&lt;Dtype&gt; &gt; crop_sequence;
235     {
236       DataLayer&lt;Dtype&gt; layer1(param);
237       layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
238       for (int iter = 0; iter &lt; 2; ++iter) {
239         layer1.Forward(blob_bottom_vec_, blob_top_vec_);
240         for (int i = 0; i &lt; 5; ++i) {
241           EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
242         }
243         vector&lt;Dtype&gt; iter_crop_sequence;
244         for (int i = 0; i &lt; 5; ++i) {
245           for (int j = 0; j &lt; 2; ++j) {
246             iter_crop_sequence.push_back(
247                 blob_top_data_-&gt;cpu_data()[i * 2 + j]);
248           }
249         }
250         crop_sequence.push_back(iter_crop_sequence);
251       }
252     }  
253     Caffe::set_random_seed(seed_);
254     DataLayer&lt;Dtype&gt; layer2(param);
255     layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
256     for (int iter = 0; iter &lt; 2; ++iter) {
257       layer2.Forward(blob_bottom_vec_, blob_top_vec_);
258       for (int i = 0; i &lt; 5; ++i) {
259         EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
260       }
261       for (int i = 0; i &lt; 5; ++i) {
262         for (int j = 0; j &lt; 2; ++j) {
263           EXPECT_EQ(crop_sequence[iter][i * 2 + j],
264                     blob_top_data_-&gt;cpu_data()[i * 2 + j])
265               &lt;&lt; "debug: iter " &lt;&lt; iter &lt;&lt; " i " &lt;&lt; i &lt;&lt; " j " &lt;&lt; j;
266         }
267       }
268     }
269   }
270   void TestReadCropTrainSequenceUnseeded() {
271     LayerParameter param;
272     param.set_phase(TRAIN);
273     DataParameter* data_param = param.mutable_data_param();
274     data_param-&gt;set_batch_size(5);
275     data_param-&gt;set_source(filename_-&gt;c_str());
276     data_param-&gt;set_backend(backend_);
277     TransformationParameter* transform_param =
278         param.mutable_transform_param();
279     transform_param-&gt;set_crop_size(1);
280     transform_param-&gt;set_mirror(true);
281     Caffe::set_random_seed(seed_);
282     srand(seed_);
283     vector&lt;vector&lt;Dtype&gt; &gt; crop_sequence;
284     {
285       DataLayer&lt;Dtype&gt; layer1(param);
286       layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
287       for (int iter = 0; iter &lt; 2; ++iter) {
288         layer1.Forward(blob_bottom_vec_, blob_top_vec_);
289         for (int i = 0; i &lt; 5; ++i) {
290           EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
291         }
292         vector&lt;Dtype&gt; iter_crop_sequence;
293         for (int i = 0; i &lt; 5; ++i) {
294           for (int j = 0; j &lt; 2; ++j) {
295             iter_crop_sequence.push_back(
296                 blob_top_data_-&gt;cpu_data()[i * 2 + j]);
297           }
298         }
299         crop_sequence.push_back(iter_crop_sequence);
300       }
301     }  
302     srand(seed_);
303     DataLayer&lt;Dtype&gt; layer2(param);
304     layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
305     for (int iter = 0; iter &lt; 2; ++iter) {
306       layer2.Forward(blob_bottom_vec_, blob_top_vec_);
307       for (int i = 0; i &lt; 5; ++i) {
308         EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
309       }
310       int num_sequence_matches = 0;
311       for (int i = 0; i &lt; 5; ++i) {
312         for (int j = 0; j &lt; 2; ++j) {
313           num_sequence_matches += (crop_sequence[iter][i * 2 + j] ==
314                                    blob_top_data_-&gt;cpu_data()[i * 2 + j]);
315         }
316       }
317       EXPECT_LT(num_sequence_matches, 10);
318     }
319   }
320   virtual ~DataLayerTest() { delete blob_top_data_; delete blob_top_label_; }
321   DataParameter_DB backend_;
322   shared_ptr&lt;string&gt; filename_;
323   Blob&lt;Dtype&gt;* const blob_top_data_;
324   Blob&lt;Dtype&gt;* const blob_top_label_;
325   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
326   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
327   int seed_;
328 };
329 TYPED_TEST_CASE(DataLayerTest, TestDtypesAndDevices);
330 #ifdef USE_LEVELDB
331 TYPED_TEST(DataLayerTest, TestReadLevelDB) {
332   const bool unique_pixels = false;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
333   this-&gt;TestRead();
334 }
335 TYPED_TEST(DataLayerTest, TestSkipLevelDB) {
336   this-&gt;Fill(false, DataParameter_DB_LEVELDB);
337   this-&gt;TestSkip();
338 }
339 TYPED_TEST(DataLayerTest, TestReshapeLevelDB) {
340   this-&gt;TestReshape(DataParameter_DB_LEVELDB);
341 }
342 TYPED_TEST(DataLayerTest, TestReadCropTrainLevelDB) {
343   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
344   this-&gt;TestReadCrop(TRAIN);
345 }
346 TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceSeededLevelDB) {
347   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
348   this-&gt;TestReadCropTrainSequenceSeeded();
349 }
350 TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceUnseededLevelDB) {
351   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
352   this-&gt;TestReadCropTrainSequenceUnseeded();
353 }
354 TYPED_TEST(DataLayerTest, TestReadCropTestLevelDB) {
355   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
356   this-&gt;TestReadCrop(TEST);
357 }
358 #endif  
359 #ifdef USE_LMDB
360 TYPED_TEST(DataLayerTest, TestReadLMDB) {
361   const bool unique_pixels = false;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
362   this-&gt;TestRead();
363 }
364 TYPED_TEST(DataLayerTest, TestSkipLMDB) {
365   this-&gt;Fill(false, DataParameter_DB_LMDB);
366   this-&gt;TestSkip();
367 }
368 TYPED_TEST(DataLayerTest, TestReshapeLMDB) {
369   this-&gt;TestReshape(DataParameter_DB_LMDB);
370 }
371 TYPED_TEST(DataLayerTest, TestReadCropTrainLMDB) {
372   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
373   this-&gt;TestReadCrop(TRAIN);
374 }
375 TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceSeededLMDB) {
376   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
377   this-&gt;TestReadCropTrainSequenceSeeded();
378 }
379 TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceUnseededLMDB) {
380   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
381   this-&gt;TestReadCropTrainSequenceUnseeded();
382 }
383 TYPED_TEST(DataLayerTest, TestReadCropTestLMDB) {
384   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
385   this-&gt;TestReadCrop(TEST);
386 }
#endif  }  #endif  </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
