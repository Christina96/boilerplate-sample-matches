
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-mutex_test.cc</h3>
            <pre><code>1  #include "absl/synchronization/mutex.h"
2  #ifdef _WIN32
3  #include <windows.h>
4  #endif
5  #include <algorithm>
6  #include <atomic>
7  #include <cstdlib>
8  #include <functional>
9  #include <memory>
10  #include <random>
11  #include <string>
12  #include <thread>  
13  #include <type_traits>
14  #include <vector>
15  #include "gtest/gtest.h"
16  #include "absl/base/attributes.h"
17  #include "absl/base/config.h"
18  #include "absl/base/internal/sysinfo.h"
19  #include "absl/log/check.h"
20  #include "absl/log/log.h"
21  #include "absl/memory/memory.h"
22  #include "absl/synchronization/internal/thread_pool.h"
23  #include "absl/time/clock.h"
24  #include "absl/time/time.h"
25  namespace {
26  static constexpr bool kExtendedTest = false;
27  std::unique_ptr<absl::synchronization_internal::ThreadPool> CreatePool(
28      int threads) {
29    return absl::make_unique<absl::synchronization_internal::ThreadPool>(threads);
30  }
31  std::unique_ptr<absl::synchronization_internal::ThreadPool>
32  CreateDefaultPool() {
33    return CreatePool(kExtendedTest ? 32 : 10);
34  }
35  static void ScheduleAfter(absl::synchronization_internal::ThreadPool *tp,
36                            absl::Duration after,
37                            const std::function<void()> &func) {
38    tp->Schedule([func, after] {
39      absl::SleepFor(after);
40      func();
41    });
42  }
43  struct TestContext {
44    int iterations;
45    int threads;
46    int g0;  
47    int g1;  
48    absl::Mutex mu;
49    absl::CondVar cv;
50  };
51  static std::atomic<bool> invariant_checked;
52  static bool GetInvariantChecked() {
53    return invariant_checked.load(std::memory_order_relaxed);
54  }
55  static void SetInvariantChecked(bool new_value) {
56    invariant_checked.store(new_value, std::memory_order_relaxed);
57  }
58  static void CheckSumG0G1(void *v) {
59    TestContext *cxt = static_cast<TestContext *>(v);
60    CHECK_EQ(cxt->g0, -cxt->g1) << "Error in CheckSumG0G1";
61    SetInvariantChecked(true);
62  }
63  static void TestMu(TestContext *cxt, int c) {
64    for (int i = 0; i != cxt->iterations; i++) {
65      absl::MutexLock l(&cxt->mu);
66      int a = cxt->g0 + 1;
67      cxt->g0 = a;
68      cxt->g1--;
69    }
70  }
71  static void TestTry(TestContext *cxt, int c) {
72    for (int i = 0; i != cxt->iterations; i++) {
73      do {
74        std::this_thread::yield();
75      } while (!cxt->mu.TryLock());
76      int a = cxt->g0 + 1;
77      cxt->g0 = a;
78      cxt->g1--;
79      cxt->mu.Unlock();
80    }
81  }
82  static void TestR20ms(TestContext *cxt, int c) {
83    for (int i = 0; i != cxt->iterations; i++) {
84      absl::ReaderMutexLock l(&cxt->mu);
85      absl::SleepFor(absl::Milliseconds(20));
86      cxt->mu.AssertReaderHeld();
87    }
88  }
89  static void TestRW(TestContext *cxt, int c) {
90    if ((c & 1) == 0) {
91      for (int i = 0; i != cxt->iterations; i++) {
92        absl::WriterMutexLock l(&cxt->mu);
93        cxt->g0++;
94        cxt->g1--;
95        cxt->mu.AssertHeld();
96        cxt->mu.AssertReaderHeld();
97      }
98    } else {
99      for (int i = 0; i != cxt->iterations; i++) {
100        absl::ReaderMutexLock l(&cxt->mu);
101        CHECK_EQ(cxt->g0, -cxt->g1) << "Error in TestRW";
102        cxt->mu.AssertReaderHeld();
103      }
104    }
105  }
106  struct MyContext {
107    int target;
108    TestContext *cxt;
109    bool MyTurn();
110  };
111  bool MyContext::MyTurn() {
112    TestContext *cxt = this->cxt;
113    return cxt->g0 == this->target || cxt->g0 == cxt->iterations;
114  }
115  static void TestAwait(TestContext *cxt, int c) {
116    MyContext mc;
117    mc.target = c;
118    mc.cxt = cxt;
119    absl::MutexLock l(&cxt->mu);
120    cxt->mu.AssertHeld();
121    while (cxt->g0 < cxt->iterations) {
122      cxt->mu.Await(absl::Condition(&mc, &MyContext::MyTurn));
123      CHECK(mc.MyTurn()) << "Error in TestAwait";
124      cxt->mu.AssertHeld();
125      if (cxt->g0 < cxt->iterations) {
126        int a = cxt->g0 + 1;
127        cxt->g0 = a;
128        mc.target += cxt->threads;
129      }
130    }
131  }
132  static void TestSignalAll(TestContext *cxt, int c) {
133    int target = c;
134    absl::MutexLock l(&cxt->mu);
135    cxt->mu.AssertHeld();
136    while (cxt->g0 < cxt->iterations) {
137      while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
138        cxt->cv.Wait(&cxt->mu);
139      }
140      if (cxt->g0 < cxt->iterations) {
141        int a = cxt->g0 + 1;
142        cxt->g0 = a;
143        cxt->cv.SignalAll();
144        target += cxt->threads;
145      }
146    }
147  }
148  static void TestSignal(TestContext *cxt, int c) {
149    CHECK_EQ(cxt->threads, 2) << "TestSignal should use 2 threads";
150    int target = c;
151    absl::MutexLock l(&cxt->mu);
152    cxt->mu.AssertHeld();
153    while (cxt->g0 < cxt->iterations) {
154      while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
155        cxt->cv.Wait(&cxt->mu);
156      }
157      if (cxt->g0 < cxt->iterations) {
158        int a = cxt->g0 + 1;
159        cxt->g0 = a;
160        cxt->cv.Signal();
161        target += cxt->threads;
162      }
163    }
164  }
165  static void TestCVTimeout(TestContext *cxt, int c) {
166    int target = c;
167    absl::MutexLock l(&cxt->mu);
168    cxt->mu.AssertHeld();
169    while (cxt->g0 < cxt->iterations) {
170      while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
171        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(100));
172      }
173      if (cxt->g0 < cxt->iterations) {
174        int a = cxt->g0 + 1;
175        cxt->g0 = a;
176        cxt->cv.SignalAll();
177        target += cxt->threads;
178      }
179    }
180  }
181  static bool G0GE2(TestContext *cxt) { return cxt->g0 >= 2; }
182  static void TestTime(TestContext *cxt, int c, bool use_cv) {
183    CHECK_EQ(cxt->iterations, 1) << "TestTime should only use 1 iteration";
184    CHECK_GT(cxt->threads, 2) << "TestTime should use more than 2 threads";
185    const bool kFalse = false;
186    absl::Condition false_cond(&kFalse);
187    absl::Condition g0ge2(G0GE2, cxt);
188    if (c == 0) {
189      absl::MutexLock l(&cxt->mu);
190      absl::Time start = absl::Now();
191      if (use_cv) {
192        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
193      } else {
194        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
195            << "TestTime failed";
196      }
197      absl::Duration elapsed = absl::Now() - start;
198      CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
199          << "TestTime failed";
200      CHECK_EQ(cxt->g0, 1) << "TestTime failed";
201      start = absl::Now();
202      if (use_cv) {
203        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
204      } else {
205        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
206            << "TestTime failed";
207      }
208      elapsed = absl::Now() - start;
209      CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
210          << "TestTime failed";
211      cxt->g0++;
212      if (use_cv) {
213        cxt->cv.Signal();
214      }
215      start = absl::Now();
216      if (use_cv) {
217        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(4));
218      } else {
219        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(4)))
220            << "TestTime failed";
221      }
222      elapsed = absl::Now() - start;
223      CHECK(absl::Seconds(3.9) <= elapsed && elapsed <= absl::Seconds(6.0))
224          << "TestTime failed";
225      CHECK_GE(cxt->g0, 3) << "TestTime failed";
226      start = absl::Now();
227      if (use_cv) {
228        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
229      } else {
230        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
231            << "TestTime failed";
232      }
233      elapsed = absl::Now() - start;
234      CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
235          << "TestTime failed";
236      if (use_cv) {
237        cxt->cv.SignalAll();
238      }
239      start = absl::Now();
240      if (use_cv) {
241        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
242      } else {
243        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
244            << "TestTime failed";
245      }
246      elapsed = absl::Now() - start;
247      CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
248          << "TestTime failed";
249      CHECK_EQ(cxt->g0, cxt->threads) << "TestTime failed";
250    } else if (c == 1) {
251      absl::MutexLock l(&cxt->mu);
252      const absl::Time start = absl::Now();
253      if (use_cv) {
254        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Milliseconds(500));
255      } else {
256        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Milliseconds(500)))
257            << "TestTime failed";
258      }
259      const absl::Duration elapsed = absl::Now() - start;
260      CHECK(absl::Seconds(0.4) <= elapsed && elapsed <= absl::Seconds(0.9))
261          << "TestTime failed";
262      cxt->g0++;
263    } else if (c == 2) {
264      absl::MutexLock l(&cxt->mu);
265      if (use_cv) {
266        while (cxt->g0 < 2) {
267          cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(100));
268        }
269      } else {
270        CHECK(cxt->mu.AwaitWithTimeout(g0ge2, absl::Seconds(100)))
271            << "TestTime failed";
272      }
273      cxt->g0++;
274    } else {
275      absl::MutexLock l(&cxt->mu);
276      if (use_cv) {
277        while (cxt->g0 < 2) {
278          cxt->cv.Wait(&cxt->mu);
279        }
280      } else {
281        cxt->mu.Await(g0ge2);
282      }
283      cxt->g0++;
284    }
285  }
286  static void TestMuTime(TestContext *cxt, int c) { TestTime(cxt, c, false); }
287  static void TestCVTime(TestContext *cxt, int c) { TestTime(cxt, c, true); }
288  static void EndTest(int *c0, int *c1, absl::Mutex *mu, absl::CondVar *cv,
289                      const std::function<void(int)> &cb) {
290    mu->Lock();
291    int c = (*c0)++;
292    mu->Unlock();
293    cb(c);
294    absl::MutexLock l(mu);
295    (*c1)++;
296    cv->Signal();
297  }
298  static int RunTestCommon(TestContext *cxt, void (*test)(TestContext *cxt, int),
299                           int threads, int iterations, int operations) {
300    absl::Mutex mu2;
301    absl::CondVar cv2;
302    int c0 = 0;
303    int c1 = 0;
304    cxt->g0 = 0;
305    cxt->g1 = 0;
306    cxt->iterations = iterations;
307    cxt->threads = threads;
308    absl::synchronization_internal::ThreadPool tp(threads);
309    for (int i = 0; i != threads; i++) {
310      tp.Schedule(std::bind(
311          &EndTest, &c0, &c1, &mu2, &cv2,
312          std::function<void(int)>(std::bind(test, cxt, std::placeholders::_1))));
313    }
314    mu2.Lock();
315    while (c1 != threads) {
316      cv2.Wait(&mu2);
317    }
318    mu2.Unlock();
319    return cxt->g0;
320  }
321  static int RunTest(void (*test)(TestContext *cxt, int), int threads,
322                     int iterations, int operations) {
323    TestContext cxt;
324    return RunTestCommon(&cxt, test, threads, iterations, operations);
325  }
326  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
327  static int RunTestWithInvariantDebugging(void (*test)(TestContext *cxt, int),
328                                           int threads, int iterations,
329                                           int operations,
330                                           void (*invariant)(void *)) {
331    absl::EnableMutexInvariantDebugging(true);
332    SetInvariantChecked(false);
333    TestContext cxt;
334    cxt.mu.EnableInvariantDebugging(invariant, &cxt);
335    int ret = RunTestCommon(&cxt, test, threads, iterations, operations);
336    CHECK(GetInvariantChecked()) << "Invariant not checked";
337    absl::EnableMutexInvariantDebugging(false);  
338    return ret;
339  }
340  #endif
341  struct TimeoutBugStruct {
342    absl::Mutex mu;
343    bool a;
344    int a_waiter_count;
345  };
346  static void WaitForA(TimeoutBugStruct *x) {
347    x->mu.LockWhen(absl::Condition(&x->a));
348    x->a_waiter_count--;
349    x->mu.Unlock();
350  }
351  static bool NoAWaiters(TimeoutBugStruct *x) { return x->a_waiter_count == 0; }
352  TEST(Mutex, CondVarWaitSignalsAwait) {
353    struct {
354      absl::Mutex barrier_mu;
355      bool barrier ABSL_GUARDED_BY(barrier_mu) = false;
356      absl::Mutex release_mu;
357      bool release ABSL_GUARDED_BY(release_mu) = false;
358      absl::CondVar released_cv;
359    } state;
360    auto pool = CreateDefaultPool();
361    pool->Schedule([&state] {
362      state.release_mu.Lock();
363      state.barrier_mu.Lock();
364      state.barrier = true;
365      state.barrier_mu.Unlock();
366      state.release_mu.Await(absl::Condition(&state.release));
367      state.released_cv.Signal();
368      state.release_mu.Unlock();
369    });
370    state.barrier_mu.LockWhen(absl::Condition(&state.barrier));
371    state.barrier_mu.Unlock();
372    state.release_mu.Lock();
373    state.release = true;
374    state.released_cv.Wait(&state.release_mu);
375    state.release_mu.Unlock();
376  }
377  TEST(Mutex, CondVarWaitWithTimeoutSignalsAwait) {
378    struct {
379      absl::Mutex barrier_mu;
380      bool barrier ABSL_GUARDED_BY(barrier_mu) = false;
381      absl::Mutex release_mu;
382      bool release ABSL_GUARDED_BY(release_mu) = false;
383      absl::CondVar released_cv;
384    } state;
385    auto pool = CreateDefaultPool();
386    pool->Schedule([&state] {
387      state.release_mu.Lock();
388      state.barrier_mu.Lock();
389      state.barrier = true;
390      state.barrier_mu.Unlock();
391      state.release_mu.Await(absl::Condition(&state.release));
392      state.released_cv.Signal();
393      state.release_mu.Unlock();
394    });
395    state.barrier_mu.LockWhen(absl::Condition(&state.barrier));
396    state.barrier_mu.Unlock();
397    state.release_mu.Lock();
398    state.release = true;
399    EXPECT_TRUE(
400        !state.released_cv.WaitWithTimeout(&state.release_mu, absl::Seconds(10)))
401        << "; Unrecoverable test failure: CondVar::WaitWithTimeout did not "
402           "unblock the absl::Mutex::Await call in another thread.";
403    state.release_mu.Unlock();
404  }
405  TEST(Mutex, MutexTimeoutBug) {
406    auto tp = CreateDefaultPool();
407    TimeoutBugStruct x;
408    x.a = false;
409    x.a_waiter_count = 2;
410    tp->Schedule(std::bind(&WaitForA, &x));
411    tp->Schedule(std::bind(&WaitForA, &x));
412    absl::SleepFor(absl::Seconds(1));  
413    bool always_false = false;
414    x.mu.LockWhenWithTimeout(absl::Condition(&always_false),
415                             absl::Milliseconds(500));
416    x.a = true;                                    
417    x.mu.Await(absl::Condition(&NoAWaiters, &x));  
418    x.mu.Unlock();
419  }
420  struct CondVarWaitDeadlock : testing::TestWithParam<int> {
421    absl::Mutex mu;
422    absl::CondVar cv;
423    bool cond1 = false;
424    bool cond2 = false;
425    bool read_lock1;
426    bool read_lock2;
427    bool signal_unlocked;
428    CondVarWaitDeadlock() {
429      read_lock1 = GetParam() & (1 << 0);
430      read_lock2 = GetParam() & (1 << 1);
431      signal_unlocked = GetParam() & (1 << 2);
432    }
433    void Waiter1() {
434      if (read_lock1) {
435        mu.ReaderLock();
436        while (!cond1) {
437          cv.Wait(&mu);
438        }
439        mu.ReaderUnlock();
440      } else {
441        mu.Lock();
442        while (!cond1) {
443          cv.Wait(&mu);
444        }
445        mu.Unlock();
446      }
447    }
448    void Waiter2() {
449      if (read_lock2) {
450        mu.ReaderLockWhen(absl::Condition(&cond2));
451        mu.ReaderUnlock();
452      } else {
453        mu.LockWhen(absl::Condition(&cond2));
454        mu.Unlock();
455      }
456    }
457  };
458  TEST_P(CondVarWaitDeadlock, Test) {
459    auto waiter1 = CreatePool(1);
460    auto waiter2 = CreatePool(1);
461    waiter1->Schedule([this] { this->Waiter1(); });
462    waiter2->Schedule([this] { this->Waiter2(); });
463    absl::SleepFor(absl::Milliseconds(100));
464    mu.Lock();
465    cond1 = true;
466    if (signal_unlocked) {
467      mu.Unlock();
468      cv.Signal();
469    } else {
470      cv.Signal();
471      mu.Unlock();
472    }
473    waiter1.reset();  
474    mu.Lock();
475    cond2 = true;
476    mu.Unlock();
477    waiter2.reset();  
478  }
479  INSTANTIATE_TEST_SUITE_P(CondVarWaitDeadlockTest, CondVarWaitDeadlock,
480                           ::testing::Range(0, 8),
481                           ::testing::PrintToStringParamName());
482  struct DequeueAllWakeableBugStruct {
483    absl::Mutex mu;
484    absl::Mutex mu2;       
485    int unfinished_count;  
486    bool done1;            
487    int finished_count;    
488    bool done2;            
489  };
490  static void AcquireAsReader(DequeueAllWakeableBugStruct *x) {
491    x->mu.ReaderLock();
492    x->mu2.Lock();
493    x->unfinished_count--;
494    x->done1 = (x->unfinished_count == 0);
495    x->mu2.Unlock();
496    absl::SleepFor(absl::Seconds(2));
497    x->mu.ReaderUnlock();
498    x->mu2.Lock();
499    x->finished_count--;
500    x->done2 = (x->finished_count == 0);
501    x->mu2.Unlock();
502  }
503  TEST(Mutex, MutexReaderWakeupBug) {
504    auto tp = CreateDefaultPool();
505    DequeueAllWakeableBugStruct x;
506    x.unfinished_count = 2;
507    x.done1 = false;
508    x.finished_count = 2;
509    x.done2 = false;
510    x.mu.Lock();  
511    tp->Schedule(std::bind(&AcquireAsReader, &x));
512    tp->Schedule(std::bind(&AcquireAsReader, &x));
513    absl::SleepFor(absl::Seconds(1));  
514    x.mu.Unlock();                     
515    EXPECT_TRUE(
516        x.mu2.LockWhenWithTimeout(absl::Condition(&x.done1), absl::Seconds(10)));
517    x.mu2.Unlock();
518    EXPECT_TRUE(
519        x.mu2.LockWhenWithTimeout(absl::Condition(&x.done2), absl::Seconds(10)));
520    x.mu2.Unlock();
521  }
522  struct LockWhenTestStruct {
523    absl::Mutex mu1;
524    bool cond = false;
525    absl::Mutex mu2;
526    bool waiting = false;
527  };
528  static bool LockWhenTestIsCond(LockWhenTestStruct *s) {
529    s->mu2.Lock();
530    s->waiting = true;
531    s->mu2.Unlock();
532    return s->cond;
533  }
534  static void LockWhenTestWaitForIsCond(LockWhenTestStruct *s) {
535    s->mu1.LockWhen(absl::Condition(&LockWhenTestIsCond, s));
536    s->mu1.Unlock();
537  }
538  TEST(Mutex, LockWhen) {
539    LockWhenTestStruct s;
540    std::thread t(LockWhenTestWaitForIsCond, &s);
541    s.mu2.LockWhen(absl::Condition(&s.waiting));
542    s.mu2.Unlock();
543    s.mu1.Lock();
544    s.cond = true;
545    s.mu1.Unlock();
546    t.join();
547  }
548  TEST(Mutex, LockWhenGuard) {
549    absl::Mutex mu;
550    int n = 30;
551    bool done = false;
552    bool (*cond_eq_10)(int *) = [](int *p) { return *p == 10; };
553    bool (*cond_lt_10)(int *) = [](int *p) { return *p < 10; };
554    std::thread t1([&mu, &n, &done, cond_eq_10]() {
555      absl::ReaderMutexLock lock(&mu, absl::Condition(cond_eq_10, &n));
556      done = true;
557    });
558    std::thread t2[10];
559    for (std::thread &t : t2) {
560      t = std::thread([&mu, &n, cond_lt_10]() {
561        absl::WriterMutexLock lock(&mu, absl::Condition(cond_lt_10, &n));
562        ++n;
563      });
564    }
565    {
566      absl::MutexLock lock(&mu);
567      n = 0;
568    }
569    for (std::thread &t : t2) t.join();
570    t1.join();
571    EXPECT_TRUE(done);
572    EXPECT_EQ(n, 10);
573  }
574  #if !defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
575  struct ReaderDecrementBugStruct {
576    bool cond;  
577    int done;   
578    absl::Mutex mu;
579    bool waiting_on_cond;   
580    bool have_reader_lock;  
581    bool complete;          
582    absl::Mutex mu2;        
583  };
584  static bool IsCond(void *v) {
585    ReaderDecrementBugStruct *x = reinterpret_cast<ReaderDecrementBugStruct *>(v);
586    x->mu2.Lock();
587    x->waiting_on_cond = true;
588    x->mu2.Unlock();
589    return x->cond;
590  }
591  static bool AllDone(void *v) {
592    ReaderDecrementBugStruct *x = reinterpret_cast<ReaderDecrementBugStruct *>(v);
593    return x->done == 0;
594  }
595  static void WaitForCond(ReaderDecrementBugStruct *x) {
596    absl::Mutex dummy;
597    absl::MutexLock l(&dummy);
598    x->mu.LockWhen(absl::Condition(&IsCond, x));
599    x->done--;
600    x->mu.Unlock();
601  }
602  static void GetReadLock(ReaderDecrementBugStruct *x) {
603    x->mu.ReaderLock();
604    x->mu2.Lock();
605    x->have_reader_lock = true;
606    x->mu2.Await(absl::Condition(&x->complete));
607    x->mu2.Unlock();
608    x->mu.ReaderUnlock();
609    x->mu.Lock();
610    x->done--;
611    x->mu.Unlock();
612  }
613  TEST(Mutex, MutexReaderDecrementBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
614    ReaderDecrementBugStruct x;
615    x.cond = false;
616    x.waiting_on_cond = false;
617    x.have_reader_lock = false;
618    x.complete = false;
619    x.done = 2;  
620    std::thread thread1(WaitForCond, &x);
621    x.mu2.LockWhen(absl::Condition(&x.waiting_on_cond));
622    x.mu2.Unlock();
623    std::thread thread2(GetReadLock, &x);
624    x.mu2.LockWhen(absl::Condition(&x.have_reader_lock));
625    x.mu2.Unlock();
626    x.mu.ReaderLock();
627    x.mu.ReaderUnlock();
628    x.mu.AssertReaderHeld();
629    x.mu2.Lock();
630    x.complete = true;
631    x.mu2.Unlock();
632    x.mu.Lock();
633    x.cond = true;
634    x.mu.Await(absl::Condition(&AllDone, &x));
635    x.mu.Unlock();
636    thread1.join();
637    thread2.join();
638  }
639  #endif  
640  #ifdef ABSL_HAVE_THREAD_SANITIZER
641  TEST(Mutex, DISABLED_LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
642  #else
643  TEST(Mutex, LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
644  #endif
645    for (int i = 0; i != 10; i++) {
646      const int kNumLocks = 10;
647      auto mu = absl::make_unique<absl::Mutex[]>(kNumLocks);
648      for (int j = 0; j != kNumLocks; j++) {
649        if ((j % 2) == 0) {
650          mu[j].WriterLock();
651        } else {
652          mu[j].ReaderLock();
653        }
654      }
655    }
656  }
657  bool Equals42(int *p) { return *p == 42; }
658  bool Equals43(int *p) { return *p == 43; }
659  bool ConstEquals42(const int *p) { return *p == 42; }
660  bool ConstEquals43(const int *p) { return *p == 43; }
661  template <typename T>
662  bool TemplateEquals42(T *p) {
663    return *p == 42;
664  }
665  template <typename T>
666  bool TemplateEquals43(T *p) {
667    return *p == 43;
668  }
669  TEST(Mutex, FunctionPointerCondition) {
670    int x = 42;
671    const int const_x = 42;
672    EXPECT_TRUE(absl::Condition(Equals42, &x).Eval());
673    EXPECT_FALSE(absl::Condition(Equals43, &x).Eval());
674    EXPECT_TRUE(absl::Condition(ConstEquals42, &x).Eval());
675    EXPECT_FALSE(absl::Condition(ConstEquals43, &x).Eval());
676    EXPECT_TRUE(absl::Condition(ConstEquals42, &const_x).Eval());
677    EXPECT_FALSE(absl::Condition(ConstEquals43, &const_x).Eval());
678    EXPECT_TRUE(absl::Condition(TemplateEquals42, &x).Eval());
679    EXPECT_FALSE(absl::Condition(TemplateEquals43, &x).Eval());
680    EXPECT_TRUE(absl::Condition(TemplateEquals42, &const_x).Eval());
681    EXPECT_FALSE(absl::Condition(TemplateEquals43, &const_x).Eval());
682    EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(Equals42),
683                                        decltype(&const_x)>::value));
684    EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(ConstEquals42),
685                                       decltype(&const_x)>::value));
686  }
687  struct Base {
688    explicit Base(int v) : value(v) {}
689    int value;
690  };
691  struct Derived : Base {
692    explicit Derived(int v) : Base(v) {}
693  };
694  bool BaseEquals42(Base *p) { return p->value == 42; }
695  bool BaseEquals43(Base *p) { return p->value == 43; }
696  bool ConstBaseEquals42(const Base *p) { return p->value == 42; }
697  bool ConstBaseEquals43(const Base *p) { return p->value == 43; }
698  TEST(Mutex, FunctionPointerConditionWithDerivedToBaseConversion) {
699    Derived derived(42);
700    const Derived const_derived(42);
701    EXPECT_TRUE(absl::Condition(BaseEquals42, &derived).Eval());
702    EXPECT_FALSE(absl::Condition(BaseEquals43, &derived).Eval());
703    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &derived).Eval());
704    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &derived).Eval());
705    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &const_derived).Eval());
706    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &const_derived).Eval());
707    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &const_derived).Eval());
708    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &const_derived).Eval());
709    bool (*derived_pred)(const Derived *) = [](const Derived *) { return true; };
710    EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(derived_pred),
711                                        Base *>::value));
712    EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(derived_pred),
713                                        const Base *>::value));
714    EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(derived_pred),
715                                       Derived *>::value));
716    EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(derived_pred),
717                                       const Derived *>::value));
718  }
719  struct True {
720    template <class... Args>
721    bool operator()(Args...) const {
722      return true;
723    }
724  };
725  struct DerivedTrue : True {};
726  TEST(Mutex, FunctorCondition) {
727    {  
728      True f;
729      EXPECT_TRUE(absl::Condition(&f).Eval());
730    }
731    {  
732      DerivedTrue g;
733      EXPECT_TRUE(absl::Condition(&g).Eval());
734    }
735    {  
736      int value = 3;
737      auto is_zero = [&value] { return value == 0; };
738      absl::Condition c(&is_zero);
739      EXPECT_FALSE(c.Eval());
740      value = 0;
741      EXPECT_TRUE(c.Eval());
742    }
743    {  
744      int value = 0;
745      auto is_positive = std::bind(std::less<int>(), 0, std::cref(value));
746      absl::Condition c(&is_positive);
747      EXPECT_FALSE(c.Eval());
748      value = 1;
749      EXPECT_TRUE(c.Eval());
750    }
751    {  
752      int value = 3;
753      std::function<bool()> is_zero = [&value] { return value == 0; };
754      absl::Condition c(&is_zero);
755      EXPECT_FALSE(c.Eval());
756      value = 0;
757      EXPECT_TRUE(c.Eval());
758    }
759  }
760  static void ReaderForReaderOnCondVar(absl::Mutex *mu, absl::CondVar *cv,
761                                       int *running) {
762    std::random_device dev;
763    std::mt19937 gen(dev());
764    std::uniform_int_distribution<int> random_millis(0, 15);
765    mu->ReaderLock();
766    while (*running == 3) {
767      absl::SleepFor(absl::Milliseconds(random_millis(gen)));
768      cv->WaitWithTimeout(mu, absl::Milliseconds(random_millis(gen)));
769    }
770    mu->ReaderUnlock();
771    mu->Lock();
772    (*running)--;
773    mu->Unlock();
774  }
775  static bool IntIsZero(int *x) { return *x == 0; }
776  TEST(Mutex, TestReaderOnCondVar) {
777    auto tp = CreateDefaultPool();
778    absl::Mutex mu;
779    absl::CondVar cv;
780    int running = 3;
781    tp->Schedule(std::bind(&ReaderForReaderOnCondVar, &mu, &cv, &running));
782    tp->Schedule(std::bind(&ReaderForReaderOnCondVar, &mu, &cv, &running));
783    absl::SleepFor(absl::Seconds(2));
784    mu.Lock();
785    running--;
786    mu.Await(absl::Condition(&IntIsZero, &running));
787    mu.Unlock();
788  }
789  struct AcquireFromConditionStruct {
790    absl::Mutex mu0;   
791    int value;         
792    bool done;         
793    absl::Mutex mu1;   
794    absl::CondVar cv;  
795  };
796  static bool ConditionWithAcquire(AcquireFromConditionStruct *x) {
797    x->value++;  
798    if (x->value == 2 || x->value == 3) {
799      bool always_false = false;
800      x->mu1.LockWhenWithTimeout(absl::Condition(&always_false),
801                                 absl::Milliseconds(100));
802      x->mu1.Unlock();
803    }
804    CHECK_LT(x->value, 4) << "should not be invoked a fourth time";
805    return x->value == 2 || x->value == 3;
806  }
807  static void WaitForCond2(AcquireFromConditionStruct *x) {
808    x->mu0.LockWhen(absl::Condition(&ConditionWithAcquire, x));
809    x->done = true;
810    x->mu0.Unlock();
811  }
812  TEST(Mutex, AcquireFromCondition) {
813    auto tp = CreateDefaultPool();
814    AcquireFromConditionStruct x;
815    x.value = 0;
816    x.done = false;
817    tp->Schedule(
818        std::bind(&WaitForCond2, &x));  
819    absl::SleepFor(absl::Milliseconds(500));  
820    x.mu0.Lock();
821    x.cv.WaitWithTimeout(&x.mu0, absl::Milliseconds(500));  
822    x.mu0.Unlock();
823    x.mu0.LockWhen(absl::Condition(&x.done));
824    x.mu0.Unlock();
825  }
826  TEST(Mutex, DeadlockDetector) {
827    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
828    absl::Mutex m1;
829    absl::Mutex m2;
830    absl::Mutex m3;
831    absl::Mutex m4;
832    m1.Lock();  
833    m2.Lock();  
834    m3.Lock();  
835    m3.Unlock();
836    m2.Unlock();
837    m1.ForgetDeadlockInfo();  
838    m2.Lock();                
839    m3.Lock();                
840    m4.Lock();                
841    m3.Unlock();
842    m2.Unlock();
843    m4.Unlock();
844    m1.Unlock();
845  }
846  class ScopedDisableBazelTestWarnings {
847   public:
848    ScopedDisableBazelTestWarnings() {
849  #ifdef _WIN32
850      char file[MAX_PATH];
851      if (GetEnvironmentVariableA(kVarName, file, sizeof(file)) < sizeof(file)) {
852        warnings_output_file_ = file;
853        SetEnvironmentVariableA(kVarName, nullptr);
854      }
855  #else
856      const char *file = getenv(kVarName);
857      if (file != nullptr) {
858        warnings_output_file_ = file;
859        unsetenv(kVarName);
860      }
861  #endif
862    }
863    ~ScopedDisableBazelTestWarnings() {
864      if (!warnings_output_file_.empty()) {
865  #ifdef _WIN32
866        SetEnvironmentVariableA(kVarName, warnings_output_file_.c_str());
867  #else
868        setenv(kVarName, warnings_output_file_.c_str(), 0);
869  #endif
870      }
871    }
872   private:
873    static const char kVarName[];
874    std::string warnings_output_file_;
875  };
876  const char ScopedDisableBazelTestWarnings::kVarName[] =
877      "TEST_WARNINGS_OUTPUT_FILE";
878  #ifdef ABSL_HAVE_THREAD_SANITIZER
879  TEST(Mutex, DISABLED_DeadlockDetectorBazelWarning) {
880  #else
881  TEST(Mutex, DeadlockDetectorBazelWarning) {
882  #endif
883    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);
884    ScopedDisableBazelTestWarnings disable_bazel_test_warnings;
885    absl::Mutex mu0;
886    absl::Mutex mu1;
887    bool got_mu0 = mu0.TryLock();
888    mu1.Lock();  
889    if (got_mu0) {
890      mu0.Unlock();
891    }
892    if (mu0.TryLock()) {  
893      mu0.Unlock();
894    }
895    mu0.Lock();  
896    mu0.Unlock();
897    mu1.Unlock();
898    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
899  }
900  TEST(Mutex, DeadlockDetectorLongCycle) {
901    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);
902    ScopedDisableBazelTestWarnings disable_bazel_test_warnings;
903    std::vector<absl::Mutex> mutex(100);
904    for (size_t i = 0; i != mutex.size(); i++) {
905      mutex[i].Lock();
906      mutex[(i + 1) % mutex.size()].Lock();
907      mutex[i].Unlock();
908      mutex[(i + 1) % mutex.size()].Unlock();
909    }
910    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
911  }
912  TEST(Mutex, DeadlockDetectorStressTest) ABSL_NO_THREAD_SAFETY_ANALYSIS {
913    const int n_locks = 1 << 17;
914    auto array_of_locks = absl::make_unique<absl::Mutex[]>(n_locks);
915    for (int i = 0; i < n_locks; i++) {
916      int end = std::min(n_locks, i + 5);
917      for (int j = i; j < end; j++) {
918        array_of_locks[j].Lock();
919      }
920      for (int j = i; j < end; j++) {
921        array_of_locks[j].Unlock();
922      }
923    }
924  }
925  #ifdef ABSL_HAVE_THREAD_SANITIZER
926  TEST(Mutex, DISABLED_DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
927  #else
928  TEST(Mutex, DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
929  #endif
930    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
931    absl::Mutex *a = new absl::Mutex;
932    absl::Mutex b, c;
933    a->Lock();
934    b.Lock();
935    b.Unlock();
936    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kIgnore);
937    delete a;
938    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
939    c.Lock();
940    c.Unlock();
941  }
942  static absl::Duration TimeoutTestAllowedSchedulingDelay() {
943    return absl::Milliseconds(150);
944  }
945  ABSL_MUST_USE_RESULT
946  static bool DelayIsWithinBounds(absl::Duration expected_delay,
947                                  absl::Duration actual_delay) {
948    bool pass = true;
949    if (actual_delay < expected_delay) {
950      LOG(WARNING) << "Actual delay " << actual_delay
951                   << " was too short, expected " << expected_delay
952                   << " (difference " << actual_delay - expected_delay << ")";
953      pass = false;
954    }
955    absl::Duration tolerance = expected_delay <= absl::ZeroDuration()
956                                   ? absl::Milliseconds(10)
957                                   : TimeoutTestAllowedSchedulingDelay();
958    if (actual_delay > expected_delay + tolerance) {
959      LOG(WARNING) << "Actual delay " << actual_delay
960                   << " was too long, expected " << expected_delay
961                   << " (difference " << actual_delay - expected_delay << ")";
962      pass = false;
963    }
964    return pass;
965  }
966  struct TimeoutTestParam {
967    const char *from_file;
968    int from_line;
969    bool use_absolute_deadline;
970    absl::Duration wait_timeout;
971    absl::Duration satisfy_condition_delay;
972    bool expected_result;
973    absl::Duration expected_delay;
974  };
975  std::ostream &operator<<(std::ostream &os, const TimeoutTestParam &param) {
976    return os << "from: " << param.from_file << ":" << param.from_line
977              << " use_absolute_deadline: "
978              << (param.use_absolute_deadline ? "true" : "false")
979              << " wait_timeout: " << param.wait_timeout
980              << " satisfy_condition_delay: " << param.satisfy_condition_delay
981              << " expected_result: "
982              << (param.expected_result ? "true" : "false")
983              << " expected_delay: " << param.expected_delay;
984  }
985  static void RunAfterDelay(absl::Duration delay,
986                            absl::synchronization_internal::ThreadPool *pool,
987                            const std::function<void()> &callback) {
988    if (delay <= absl::ZeroDuration()) {
989      callback();  
990    } else if (delay != absl::InfiniteDuration()) {
991      ScheduleAfter(pool, delay, callback);
992    }
993  }
994  class TimeoutTest : public ::testing::Test,
995                      public ::testing::WithParamInterface<TimeoutTestParam> {};
996  std::vector<TimeoutTestParam> MakeTimeoutTestParamValues() {
997    const absl::Duration finite = 3 * TimeoutTestAllowedSchedulingDelay();
998    const absl::Duration never = absl::InfiniteDuration();
999    const absl::Duration negative = -absl::InfiniteDuration();
1000    const absl::Duration immediate = absl::ZeroDuration();
1001    std::vector<TimeoutTestParam> values;
1002    for (bool use_absolute_deadline : {false, true}) {
1003      values.push_back(TimeoutTestParam{
1004          __FILE__, __LINE__, use_absolute_deadline,
1005          negative,   
1006          immediate,  
1007          true,       
1008          immediate,  
1009      });
1010      values.push_back(TimeoutTestParam{
1011          __FILE__, __LINE__, use_absolute_deadline,
1012          negative,  
1013          finite,    
1014          false,     
1015          immediate  
1016      });
1017      values.push_back(TimeoutTestParam{
1018          __FILE__, __LINE__, use_absolute_deadline,
1019          negative,  
1020          never,     
1021          false,     
1022          immediate  
1023      });
1024      values.push_back(TimeoutTestParam{
1025          __FILE__, __LINE__, use_absolute_deadline,
1026          never,      
1027          immediate,  
1028          true,       
1029          immediate   
1030      });
1031      values.push_back(TimeoutTestParam{
1032          __FILE__, __LINE__, use_absolute_deadline,
1033          never,   
1034          finite,  
1035          true,    
1036          finite,  
1037      });
1038      values.push_back(TimeoutTestParam{
1039          __FILE__, __LINE__, use_absolute_deadline,
1040          never,      
1041          immediate,  
1042          true,       
1043          immediate   
1044      });
1045      values.push_back(TimeoutTestParam{
1046          __FILE__, __LINE__, use_absolute_deadline,
1047          finite * 2,  
1048          finite,      
1049          true,        
1050          finite       
1051      });
1052      values.push_back(TimeoutTestParam{
1053          __FILE__, __LINE__, use_absolute_deadline,
1054          finite,      
1055          finite * 2,  
1056          false,       
1057          finite       
1058      });
1059      values.push_back(TimeoutTestParam{
1060          __FILE__, __LINE__, use_absolute_deadline,
1061          finite,  
1062          never,   
1063          false,   
1064          finite   
1065      });
1066    }
1067    return values;
1068  }
1069  INSTANTIATE_TEST_SUITE_P(All, TimeoutTest,
1070                           testing::ValuesIn(MakeTimeoutTestParamValues()));
1071  TEST_P(TimeoutTest, Await) {
1072    const TimeoutTestParam params = GetParam();
1073    LOG(INFO) << "Params: " << params;
1074    for (int attempt = 1;; ++attempt) {
1075      LOG(INFO) << "Attempt " << attempt;
1076      absl::Mutex mu;
1077      bool value = false;  
1078      std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
1079          CreateDefaultPool();
1080      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
1081        absl::MutexLock l(&mu);
1082        value = true;
1083      });
1084      absl::MutexLock lock(&mu);
1085      absl::Time start_time = absl::Now();
1086      absl::Condition cond(&value);
1087      bool result =
1088          params.use_absolute_deadline
1089              ? mu.AwaitWithDeadline(cond, start_time + params.wait_timeout)
1090              : mu.AwaitWithTimeout(cond, params.wait_timeout);
1091      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1092        EXPECT_EQ(params.expected_result, result);
1093        break;
1094      }
1095    }
1096  }
1097  TEST_P(TimeoutTest, LockWhen) {
1098    const TimeoutTestParam params = GetParam();
1099    LOG(INFO) << "Params: " << params;
1100    for (int attempt = 1;; ++attempt) {
1101      LOG(INFO) << "Attempt " << attempt;
1102      absl::Mutex mu;
1103      bool value = false;  
1104      std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
1105          CreateDefaultPool();
1106      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
1107        absl::MutexLock l(&mu);
1108        value = true;
1109      });
1110      absl::Time start_time = absl::Now();
1111      absl::Condition cond(&value);
1112      bool result =
1113          params.use_absolute_deadline
1114              ? mu.LockWhenWithDeadline(cond, start_time + params.wait_timeout)
1115              : mu.LockWhenWithTimeout(cond, params.wait_timeout);
1116      mu.Unlock();
1117      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1118        EXPECT_EQ(params.expected_result, result);
1119        break;
1120      }
1121    }
1122  }
1123  TEST_P(TimeoutTest, ReaderLockWhen) {
1124    const TimeoutTestParam params = GetParam();
1125    LOG(INFO) << "Params: " << params;
1126    for (int attempt = 0;; ++attempt) {
1127      LOG(INFO) << "Attempt " << attempt;
1128      absl::Mutex mu;
1129      bool value = false;  
1130      std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
1131          CreateDefaultPool();
1132      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
1133        absl::MutexLock l(&mu);
1134        value = true;
1135      });
1136      absl::Time start_time = absl::Now();
1137      bool result =
1138          params.use_absolute_deadline
1139              ? mu.ReaderLockWhenWithDeadline(absl::Condition(&value),
1140                                              start_time + params.wait_timeout)
1141              : mu.ReaderLockWhenWithTimeout(absl::Condition(&value),
1142                                             params.wait_timeout);
1143      mu.ReaderUnlock();
1144      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1145        EXPECT_EQ(params.expected_result, result);
1146        break;
1147      }
1148    }
1149  }
1150  TEST_P(TimeoutTest, Wait) {
1151    const TimeoutTestParam params = GetParam();
1152    LOG(INFO) << "Params: " << params;
1153    for (int attempt = 0;; ++attempt) {
1154      LOG(INFO) << "Attempt " << attempt;
1155      absl::Mutex mu;
1156      bool value = false;  
1157      absl::CondVar cv;    
1158      std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
1159          CreateDefaultPool();
1160      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
1161        absl::MutexLock l(&mu);
1162        value = true;
1163        cv.Signal();
1164      });
1165      absl::MutexLock lock(&mu);
1166      absl::Time start_time = absl::Now();
1167      absl::Duration timeout = params.wait_timeout;
1168      absl::Time deadline = start_time + timeout;
1169      while (!value) {
1170        if (params.use_absolute_deadline ? cv.WaitWithDeadline(&mu, deadline)
1171                                         : cv.WaitWithTimeout(&mu, timeout)) {
1172          break;  
1173        }
1174        timeout = deadline - absl::Now();  
1175      }
1176      bool result = value;  
1177      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1178        EXPECT_EQ(params.expected_result, result);
1179        break;
1180      }
1181    }
1182  }
1183  TEST(Mutex, Logging) {
1184    absl::Mutex logged_mutex;
1185    logged_mutex.EnableDebugLog("fido_mutex");
1186    absl::CondVar logged_cv;
1187    logged_cv.EnableDebugLog("rover_cv");
1188    logged_mutex.Lock();
1189    logged_cv.WaitWithTimeout(&logged_mutex, absl::Milliseconds(20));
1190    logged_mutex.Unlock();
1191    logged_mutex.ReaderLock();
1192    logged_mutex.ReaderUnlock();
1193    logged_mutex.Lock();
1194    logged_mutex.Unlock();
1195    logged_cv.Signal();
1196    logged_cv.SignalAll();
1197  }
1198  static std::vector<int> AllThreadCountValues() {
1199    if (kExtendedTest) {
1200      return {2, 4, 8, 10, 16, 20, 24, 30, 32};
1201    }
1202    return {2, 4, 10};
1203  }
1204  class MutexVariableThreadCountTest : public ::testing::TestWithParam<int> {};
1205  INSTANTIATE_TEST_SUITE_P(ThreadCounts, MutexVariableThreadCountTest,
1206                           ::testing::ValuesIn(AllThreadCountValues()),
1207                           ::testing::PrintToStringParamName());
1208  static int ScaleIterations(int x) {
1209  #if defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
1210    return x / 10;
1211  #else
1212    return x;
1213  #endif
1214  }
1215  TEST_P(MutexVariableThreadCountTest, Mutex) {
1216    int threads = GetParam();
1217    int iterations = ScaleIterations(10000000) / threads;
1218    int operations = threads * iterations;
1219    EXPECT_EQ(RunTest(&TestMu, threads, iterations, operations), operations);
1220  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1221    iterations = std::min(iterations, 10);
1222    operations = threads * iterations;
1223    EXPECT_EQ(RunTestWithInvariantDebugging(&TestMu, threads, iterations,
1224                                            operations, CheckSumG0G1),
1225              operations);
1226  #endif
1227  }
1228  TEST_P(MutexVariableThreadCountTest, Try) {
1229    int threads = GetParam();
1230    int iterations = 1000000 / threads;
1231    int operations = iterations * threads;
<span onclick='openModal()' class='match'>1232    EXPECT_EQ(RunTest(&TestTry, threads, iterations, operations), operations);
1233  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
</span>1234    iterations = std::min(iterations, 10);
1235    operations = threads * iterations;
1236    EXPECT_EQ(RunTestWithInvariantDebugging(&TestTry, threads, iterations,
1237                                            operations, CheckSumG0G1),
1238              operations);
1239  #endif
1240  }
1241  TEST_P(MutexVariableThreadCountTest, R20ms) {
1242    int threads = GetParam();
1243    int iterations = 100;
1244    int operations = iterations * threads;
1245    EXPECT_EQ(RunTest(&TestR20ms, threads, iterations, operations), 0);
1246  }
1247  TEST_P(MutexVariableThreadCountTest, RW) {
1248    int threads = GetParam();
1249    int iterations = ScaleIterations(20000000) / threads;
1250    int operations = iterations * threads;
1251    EXPECT_EQ(RunTest(&TestRW, threads, iterations, operations), operations / 2);
1252  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1253    iterations = std::min(iterations, 10);
1254    operations = threads * iterations;
1255    EXPECT_EQ(RunTestWithInvariantDebugging(&TestRW, threads, iterations,
1256                                            operations, CheckSumG0G1),
1257              operations / 2);
1258  #endif
1259  }
1260  TEST_P(MutexVariableThreadCountTest, Await) {
1261    int threads = GetParam();
1262    int iterations = ScaleIterations(500000);
1263    int operations = iterations;
1264    EXPECT_EQ(RunTest(&TestAwait, threads, iterations, operations), operations);
1265  }
1266  TEST_P(MutexVariableThreadCountTest, SignalAll) {
1267    int threads = GetParam();
1268    int iterations = 200000 / threads;
1269    int operations = iterations;
1270    EXPECT_EQ(RunTest(&TestSignalAll, threads, iterations, operations),
1271              operations);
1272  }
1273  TEST(Mutex, Signal) {
1274    int threads = 2;  
1275    int iterations = 200000;
1276    int operations = iterations;
1277    EXPECT_EQ(RunTest(&TestSignal, threads, iterations, operations), operations);
1278  }
1279  TEST(Mutex, Timed) {
1280    int threads = 10;  
1281    int iterations = 1000;
1282    int operations = iterations;
1283    EXPECT_EQ(RunTest(&TestCVTimeout, threads, iterations, operations),
1284              operations);
1285  }
1286  TEST(Mutex, CVTime) {
1287    int threads = 10;  
1288    int iterations = 1;
1289    EXPECT_EQ(RunTest(&TestCVTime, threads, iterations, 1), threads * iterations);
1290  }
1291  TEST(Mutex, MuTime) {
1292    int threads = 10;  
1293    int iterations = 1;
1294    EXPECT_EQ(RunTest(&TestMuTime, threads, iterations, 1), threads * iterations);
1295  }
1296  TEST(Mutex, SignalExitedThread) {
1297  #if defined(__wasm__) || defined(__asmjs__)
1298    constexpr int kThreads = 1;  
1299  #else
1300    constexpr int kThreads = 100;
1301  #endif
1302    std::vector<std::thread> top;
1303    for (unsigned i = 0; i < 2 * std::thread::hardware_concurrency(); i++) {
1304      top.emplace_back([&]() {
1305        for (int i = 0; i < kThreads; i++) {
1306          absl::Mutex mu;
1307          std::thread t([&]() {
1308            mu.Lock();
1309            mu.Unlock();
1310          });
1311          mu.Lock();
1312          mu.Unlock();
1313          t.join();
1314        }
1315      });
1316    }
1317    for (auto &th : top) th.join();
1318  }
1319  TEST(Mutex, WriterPriority) {
1320    absl::Mutex mu;
1321    bool wrote = false;
1322    std::atomic<bool> saw_wrote{false};
1323    auto readfunc = [&]() {
1324      for (size_t i = 0; i < 10; ++i) {
1325        absl::ReaderMutexLock lock(&mu);
1326        if (wrote) {
1327          saw_wrote = true;
1328          break;
1329        }
1330        absl::SleepFor(absl::Seconds(1));
1331      }
1332    };
1333    std::thread t1(readfunc);
1334    absl::SleepFor(absl::Milliseconds(500));
1335    std::thread t2(readfunc);
1336    std::thread t3([&]() {
1337      absl::MutexLock lock(&mu);
1338      wrote = true;
1339    });
1340    t1.join();
1341    t2.join();
1342    t3.join();
1343    EXPECT_TRUE(saw_wrote.load());
1344  }
1345  TEST(Mutex, LockWhenWithTimeoutResult) {
1346    absl::Mutex mu;
1347    const bool kAlwaysTrue = true, kAlwaysFalse = false;
1348    const absl::Condition kTrueCond(&kAlwaysTrue), kFalseCond(&kAlwaysFalse);
1349    EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
1350    mu.Unlock();
1351    EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
1352    EXPECT_TRUE(mu.AwaitWithTimeout(kTrueCond, absl::Milliseconds(1)));
1353    EXPECT_FALSE(mu.AwaitWithTimeout(kFalseCond, absl::Milliseconds(1)));
1354    std::thread th1([&]() {
1355      EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
1356      mu.Unlock();
1357    });
1358    std::thread th2([&]() {
1359      EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
1360      mu.Unlock();
1361    });
1362    absl::SleepFor(absl::Milliseconds(100));
1363    mu.Unlock();
1364    th1.join();
1365    th2.join();
1366  }
1367  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-mutex_test.cc</h3>
            <pre><code>1  #include "absl/synchronization/mutex.h"
2  #ifdef _WIN32
3  #include <windows.h>
4  #endif
5  #include <algorithm>
6  #include <atomic>
7  #include <cstdlib>
8  #include <functional>
9  #include <memory>
10  #include <random>
11  #include <string>
12  #include <thread>  
13  #include <type_traits>
14  #include <vector>
15  #include "gtest/gtest.h"
16  #include "absl/base/attributes.h"
17  #include "absl/base/config.h"
18  #include "absl/base/internal/sysinfo.h"
19  #include "absl/log/check.h"
20  #include "absl/log/log.h"
21  #include "absl/memory/memory.h"
22  #include "absl/synchronization/internal/thread_pool.h"
23  #include "absl/time/clock.h"
24  #include "absl/time/time.h"
25  namespace {
26  static constexpr bool kExtendedTest = false;
27  std::unique_ptr<absl::synchronization_internal::ThreadPool> CreatePool(
28      int threads) {
29    return absl::make_unique<absl::synchronization_internal::ThreadPool>(threads);
30  }
31  std::unique_ptr<absl::synchronization_internal::ThreadPool>
32  CreateDefaultPool() {
33    return CreatePool(kExtendedTest ? 32 : 10);
34  }
35  static void ScheduleAfter(absl::synchronization_internal::ThreadPool *tp,
36                            absl::Duration after,
37                            const std::function<void()> &func) {
38    tp->Schedule([func, after] {
39      absl::SleepFor(after);
40      func();
41    });
42  }
43  struct TestContext {
44    int iterations;
45    int threads;
46    int g0;  
47    int g1;  
48    absl::Mutex mu;
49    absl::CondVar cv;
50  };
51  static std::atomic<bool> invariant_checked;
52  static bool GetInvariantChecked() {
53    return invariant_checked.load(std::memory_order_relaxed);
54  }
55  static void SetInvariantChecked(bool new_value) {
56    invariant_checked.store(new_value, std::memory_order_relaxed);
57  }
58  static void CheckSumG0G1(void *v) {
59    TestContext *cxt = static_cast<TestContext *>(v);
60    CHECK_EQ(cxt->g0, -cxt->g1) << "Error in CheckSumG0G1";
61    SetInvariantChecked(true);
62  }
63  static void TestMu(TestContext *cxt, int c) {
64    for (int i = 0; i != cxt->iterations; i++) {
65      absl::MutexLock l(&cxt->mu);
66      int a = cxt->g0 + 1;
67      cxt->g0 = a;
68      cxt->g1--;
69    }
70  }
71  static void TestTry(TestContext *cxt, int c) {
72    for (int i = 0; i != cxt->iterations; i++) {
73      do {
74        std::this_thread::yield();
75      } while (!cxt->mu.TryLock());
76      int a = cxt->g0 + 1;
77      cxt->g0 = a;
78      cxt->g1--;
79      cxt->mu.Unlock();
80    }
81  }
82  static void TestR20ms(TestContext *cxt, int c) {
83    for (int i = 0; i != cxt->iterations; i++) {
84      absl::ReaderMutexLock l(&cxt->mu);
85      absl::SleepFor(absl::Milliseconds(20));
86      cxt->mu.AssertReaderHeld();
87    }
88  }
89  static void TestRW(TestContext *cxt, int c) {
90    if ((c & 1) == 0) {
91      for (int i = 0; i != cxt->iterations; i++) {
92        absl::WriterMutexLock l(&cxt->mu);
93        cxt->g0++;
94        cxt->g1--;
95        cxt->mu.AssertHeld();
96        cxt->mu.AssertReaderHeld();
97      }
98    } else {
99      for (int i = 0; i != cxt->iterations; i++) {
100        absl::ReaderMutexLock l(&cxt->mu);
101        CHECK_EQ(cxt->g0, -cxt->g1) << "Error in TestRW";
102        cxt->mu.AssertReaderHeld();
103      }
104    }
105  }
106  struct MyContext {
107    int target;
108    TestContext *cxt;
109    bool MyTurn();
110  };
111  bool MyContext::MyTurn() {
112    TestContext *cxt = this->cxt;
113    return cxt->g0 == this->target || cxt->g0 == cxt->iterations;
114  }
115  static void TestAwait(TestContext *cxt, int c) {
116    MyContext mc;
117    mc.target = c;
118    mc.cxt = cxt;
119    absl::MutexLock l(&cxt->mu);
120    cxt->mu.AssertHeld();
121    while (cxt->g0 < cxt->iterations) {
122      cxt->mu.Await(absl::Condition(&mc, &MyContext::MyTurn));
123      CHECK(mc.MyTurn()) << "Error in TestAwait";
124      cxt->mu.AssertHeld();
125      if (cxt->g0 < cxt->iterations) {
126        int a = cxt->g0 + 1;
127        cxt->g0 = a;
128        mc.target += cxt->threads;
129      }
130    }
131  }
132  static void TestSignalAll(TestContext *cxt, int c) {
133    int target = c;
134    absl::MutexLock l(&cxt->mu);
135    cxt->mu.AssertHeld();
136    while (cxt->g0 < cxt->iterations) {
137      while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
138        cxt->cv.Wait(&cxt->mu);
139      }
140      if (cxt->g0 < cxt->iterations) {
141        int a = cxt->g0 + 1;
142        cxt->g0 = a;
143        cxt->cv.SignalAll();
144        target += cxt->threads;
145      }
146    }
147  }
148  static void TestSignal(TestContext *cxt, int c) {
149    CHECK_EQ(cxt->threads, 2) << "TestSignal should use 2 threads";
150    int target = c;
151    absl::MutexLock l(&cxt->mu);
152    cxt->mu.AssertHeld();
153    while (cxt->g0 < cxt->iterations) {
154      while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
155        cxt->cv.Wait(&cxt->mu);
156      }
157      if (cxt->g0 < cxt->iterations) {
158        int a = cxt->g0 + 1;
159        cxt->g0 = a;
160        cxt->cv.Signal();
161        target += cxt->threads;
162      }
163    }
164  }
165  static void TestCVTimeout(TestContext *cxt, int c) {
166    int target = c;
167    absl::MutexLock l(&cxt->mu);
168    cxt->mu.AssertHeld();
169    while (cxt->g0 < cxt->iterations) {
170      while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
171        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(100));
172      }
173      if (cxt->g0 < cxt->iterations) {
174        int a = cxt->g0 + 1;
175        cxt->g0 = a;
176        cxt->cv.SignalAll();
177        target += cxt->threads;
178      }
179    }
180  }
181  static bool G0GE2(TestContext *cxt) { return cxt->g0 >= 2; }
182  static void TestTime(TestContext *cxt, int c, bool use_cv) {
183    CHECK_EQ(cxt->iterations, 1) << "TestTime should only use 1 iteration";
184    CHECK_GT(cxt->threads, 2) << "TestTime should use more than 2 threads";
185    const bool kFalse = false;
186    absl::Condition false_cond(&kFalse);
187    absl::Condition g0ge2(G0GE2, cxt);
188    if (c == 0) {
189      absl::MutexLock l(&cxt->mu);
190      absl::Time start = absl::Now();
191      if (use_cv) {
192        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
193      } else {
194        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
195            << "TestTime failed";
196      }
197      absl::Duration elapsed = absl::Now() - start;
198      CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
199          << "TestTime failed";
200      CHECK_EQ(cxt->g0, 1) << "TestTime failed";
201      start = absl::Now();
202      if (use_cv) {
203        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
204      } else {
205        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
206            << "TestTime failed";
207      }
208      elapsed = absl::Now() - start;
209      CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
210          << "TestTime failed";
211      cxt->g0++;
212      if (use_cv) {
213        cxt->cv.Signal();
214      }
215      start = absl::Now();
216      if (use_cv) {
217        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(4));
218      } else {
219        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(4)))
220            << "TestTime failed";
221      }
222      elapsed = absl::Now() - start;
223      CHECK(absl::Seconds(3.9) <= elapsed && elapsed <= absl::Seconds(6.0))
224          << "TestTime failed";
225      CHECK_GE(cxt->g0, 3) << "TestTime failed";
226      start = absl::Now();
227      if (use_cv) {
228        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
229      } else {
230        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
231            << "TestTime failed";
232      }
233      elapsed = absl::Now() - start;
234      CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
235          << "TestTime failed";
236      if (use_cv) {
237        cxt->cv.SignalAll();
238      }
239      start = absl::Now();
240      if (use_cv) {
241        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
242      } else {
243        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
244            << "TestTime failed";
245      }
246      elapsed = absl::Now() - start;
247      CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
248          << "TestTime failed";
249      CHECK_EQ(cxt->g0, cxt->threads) << "TestTime failed";
250    } else if (c == 1) {
251      absl::MutexLock l(&cxt->mu);
252      const absl::Time start = absl::Now();
253      if (use_cv) {
254        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Milliseconds(500));
255      } else {
256        CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Milliseconds(500)))
257            << "TestTime failed";
258      }
259      const absl::Duration elapsed = absl::Now() - start;
260      CHECK(absl::Seconds(0.4) <= elapsed && elapsed <= absl::Seconds(0.9))
261          << "TestTime failed";
262      cxt->g0++;
263    } else if (c == 2) {
264      absl::MutexLock l(&cxt->mu);
265      if (use_cv) {
266        while (cxt->g0 < 2) {
267          cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(100));
268        }
269      } else {
270        CHECK(cxt->mu.AwaitWithTimeout(g0ge2, absl::Seconds(100)))
271            << "TestTime failed";
272      }
273      cxt->g0++;
274    } else {
275      absl::MutexLock l(&cxt->mu);
276      if (use_cv) {
277        while (cxt->g0 < 2) {
278          cxt->cv.Wait(&cxt->mu);
279        }
280      } else {
281        cxt->mu.Await(g0ge2);
282      }
283      cxt->g0++;
284    }
285  }
286  static void TestMuTime(TestContext *cxt, int c) { TestTime(cxt, c, false); }
287  static void TestCVTime(TestContext *cxt, int c) { TestTime(cxt, c, true); }
288  static void EndTest(int *c0, int *c1, absl::Mutex *mu, absl::CondVar *cv,
289                      const std::function<void(int)> &cb) {
290    mu->Lock();
291    int c = (*c0)++;
292    mu->Unlock();
293    cb(c);
294    absl::MutexLock l(mu);
295    (*c1)++;
296    cv->Signal();
297  }
298  static int RunTestCommon(TestContext *cxt, void (*test)(TestContext *cxt, int),
299                           int threads, int iterations, int operations) {
300    absl::Mutex mu2;
301    absl::CondVar cv2;
302    int c0 = 0;
303    int c1 = 0;
304    cxt->g0 = 0;
305    cxt->g1 = 0;
306    cxt->iterations = iterations;
307    cxt->threads = threads;
308    absl::synchronization_internal::ThreadPool tp(threads);
309    for (int i = 0; i != threads; i++) {
310      tp.Schedule(std::bind(
311          &EndTest, &c0, &c1, &mu2, &cv2,
312          std::function<void(int)>(std::bind(test, cxt, std::placeholders::_1))));
313    }
314    mu2.Lock();
315    while (c1 != threads) {
316      cv2.Wait(&mu2);
317    }
318    mu2.Unlock();
319    return cxt->g0;
320  }
321  static int RunTest(void (*test)(TestContext *cxt, int), int threads,
322                     int iterations, int operations) {
323    TestContext cxt;
324    return RunTestCommon(&cxt, test, threads, iterations, operations);
325  }
326  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
327  static int RunTestWithInvariantDebugging(void (*test)(TestContext *cxt, int),
328                                           int threads, int iterations,
329                                           int operations,
330                                           void (*invariant)(void *)) {
331    absl::EnableMutexInvariantDebugging(true);
332    SetInvariantChecked(false);
333    TestContext cxt;
334    cxt.mu.EnableInvariantDebugging(invariant, &cxt);
335    int ret = RunTestCommon(&cxt, test, threads, iterations, operations);
336    CHECK(GetInvariantChecked()) << "Invariant not checked";
337    absl::EnableMutexInvariantDebugging(false);  
338    return ret;
339  }
340  #endif
341  struct TimeoutBugStruct {
342    absl::Mutex mu;
343    bool a;
344    int a_waiter_count;
345  };
346  static void WaitForA(TimeoutBugStruct *x) {
347    x->mu.LockWhen(absl::Condition(&x->a));
348    x->a_waiter_count--;
349    x->mu.Unlock();
350  }
351  static bool NoAWaiters(TimeoutBugStruct *x) { return x->a_waiter_count == 0; }
352  TEST(Mutex, CondVarWaitSignalsAwait) {
353    struct {
354      absl::Mutex barrier_mu;
355      bool barrier ABSL_GUARDED_BY(barrier_mu) = false;
356      absl::Mutex release_mu;
357      bool release ABSL_GUARDED_BY(release_mu) = false;
358      absl::CondVar released_cv;
359    } state;
360    auto pool = CreateDefaultPool();
361    pool->Schedule([&state] {
362      state.release_mu.Lock();
363      state.barrier_mu.Lock();
364      state.barrier = true;
365      state.barrier_mu.Unlock();
366      state.release_mu.Await(absl::Condition(&state.release));
367      state.released_cv.Signal();
368      state.release_mu.Unlock();
369    });
370    state.barrier_mu.LockWhen(absl::Condition(&state.barrier));
371    state.barrier_mu.Unlock();
372    state.release_mu.Lock();
373    state.release = true;
374    state.released_cv.Wait(&state.release_mu);
375    state.release_mu.Unlock();
376  }
377  TEST(Mutex, CondVarWaitWithTimeoutSignalsAwait) {
378    struct {
379      absl::Mutex barrier_mu;
380      bool barrier ABSL_GUARDED_BY(barrier_mu) = false;
381      absl::Mutex release_mu;
382      bool release ABSL_GUARDED_BY(release_mu) = false;
383      absl::CondVar released_cv;
384    } state;
385    auto pool = CreateDefaultPool();
386    pool->Schedule([&state] {
387      state.release_mu.Lock();
388      state.barrier_mu.Lock();
389      state.barrier = true;
390      state.barrier_mu.Unlock();
391      state.release_mu.Await(absl::Condition(&state.release));
392      state.released_cv.Signal();
393      state.release_mu.Unlock();
394    });
395    state.barrier_mu.LockWhen(absl::Condition(&state.barrier));
396    state.barrier_mu.Unlock();
397    state.release_mu.Lock();
398    state.release = true;
399    EXPECT_TRUE(
400        !state.released_cv.WaitWithTimeout(&state.release_mu, absl::Seconds(10)))
401        << "; Unrecoverable test failure: CondVar::WaitWithTimeout did not "
402           "unblock the absl::Mutex::Await call in another thread.";
403    state.release_mu.Unlock();
404  }
405  TEST(Mutex, MutexTimeoutBug) {
406    auto tp = CreateDefaultPool();
407    TimeoutBugStruct x;
408    x.a = false;
409    x.a_waiter_count = 2;
410    tp->Schedule(std::bind(&WaitForA, &x));
411    tp->Schedule(std::bind(&WaitForA, &x));
412    absl::SleepFor(absl::Seconds(1));  
413    bool always_false = false;
414    x.mu.LockWhenWithTimeout(absl::Condition(&always_false),
415                             absl::Milliseconds(500));
416    x.a = true;                                    
417    x.mu.Await(absl::Condition(&NoAWaiters, &x));  
418    x.mu.Unlock();
419  }
420  struct CondVarWaitDeadlock : testing::TestWithParam<int> {
421    absl::Mutex mu;
422    absl::CondVar cv;
423    bool cond1 = false;
424    bool cond2 = false;
425    bool read_lock1;
426    bool read_lock2;
427    bool signal_unlocked;
428    CondVarWaitDeadlock() {
429      read_lock1 = GetParam() & (1 << 0);
430      read_lock2 = GetParam() & (1 << 1);
431      signal_unlocked = GetParam() & (1 << 2);
432    }
433    void Waiter1() {
434      if (read_lock1) {
435        mu.ReaderLock();
436        while (!cond1) {
437          cv.Wait(&mu);
438        }
439        mu.ReaderUnlock();
440      } else {
441        mu.Lock();
442        while (!cond1) {
443          cv.Wait(&mu);
444        }
445        mu.Unlock();
446      }
447    }
448    void Waiter2() {
449      if (read_lock2) {
450        mu.ReaderLockWhen(absl::Condition(&cond2));
451        mu.ReaderUnlock();
452      } else {
453        mu.LockWhen(absl::Condition(&cond2));
454        mu.Unlock();
455      }
456    }
457  };
458  TEST_P(CondVarWaitDeadlock, Test) {
459    auto waiter1 = CreatePool(1);
460    auto waiter2 = CreatePool(1);
461    waiter1->Schedule([this] { this->Waiter1(); });
462    waiter2->Schedule([this] { this->Waiter2(); });
463    absl::SleepFor(absl::Milliseconds(100));
464    mu.Lock();
465    cond1 = true;
466    if (signal_unlocked) {
467      mu.Unlock();
468      cv.Signal();
469    } else {
470      cv.Signal();
471      mu.Unlock();
472    }
473    waiter1.reset();  
474    mu.Lock();
475    cond2 = true;
476    mu.Unlock();
477    waiter2.reset();  
478  }
479  INSTANTIATE_TEST_SUITE_P(CondVarWaitDeadlockTest, CondVarWaitDeadlock,
480                           ::testing::Range(0, 8),
481                           ::testing::PrintToStringParamName());
482  struct DequeueAllWakeableBugStruct {
483    absl::Mutex mu;
484    absl::Mutex mu2;       
485    int unfinished_count;  
486    bool done1;            
487    int finished_count;    
488    bool done2;            
489  };
490  static void AcquireAsReader(DequeueAllWakeableBugStruct *x) {
491    x->mu.ReaderLock();
492    x->mu2.Lock();
493    x->unfinished_count--;
494    x->done1 = (x->unfinished_count == 0);
495    x->mu2.Unlock();
496    absl::SleepFor(absl::Seconds(2));
497    x->mu.ReaderUnlock();
498    x->mu2.Lock();
499    x->finished_count--;
500    x->done2 = (x->finished_count == 0);
501    x->mu2.Unlock();
502  }
503  TEST(Mutex, MutexReaderWakeupBug) {
504    auto tp = CreateDefaultPool();
505    DequeueAllWakeableBugStruct x;
506    x.unfinished_count = 2;
507    x.done1 = false;
508    x.finished_count = 2;
509    x.done2 = false;
510    x.mu.Lock();  
511    tp->Schedule(std::bind(&AcquireAsReader, &x));
512    tp->Schedule(std::bind(&AcquireAsReader, &x));
513    absl::SleepFor(absl::Seconds(1));  
514    x.mu.Unlock();                     
515    EXPECT_TRUE(
516        x.mu2.LockWhenWithTimeout(absl::Condition(&x.done1), absl::Seconds(10)));
517    x.mu2.Unlock();
518    EXPECT_TRUE(
519        x.mu2.LockWhenWithTimeout(absl::Condition(&x.done2), absl::Seconds(10)));
520    x.mu2.Unlock();
521  }
522  struct LockWhenTestStruct {
523    absl::Mutex mu1;
524    bool cond = false;
525    absl::Mutex mu2;
526    bool waiting = false;
527  };
528  static bool LockWhenTestIsCond(LockWhenTestStruct *s) {
529    s->mu2.Lock();
530    s->waiting = true;
531    s->mu2.Unlock();
532    return s->cond;
533  }
534  static void LockWhenTestWaitForIsCond(LockWhenTestStruct *s) {
535    s->mu1.LockWhen(absl::Condition(&LockWhenTestIsCond, s));
536    s->mu1.Unlock();
537  }
538  TEST(Mutex, LockWhen) {
539    LockWhenTestStruct s;
540    std::thread t(LockWhenTestWaitForIsCond, &s);
541    s.mu2.LockWhen(absl::Condition(&s.waiting));
542    s.mu2.Unlock();
543    s.mu1.Lock();
544    s.cond = true;
545    s.mu1.Unlock();
546    t.join();
547  }
548  TEST(Mutex, LockWhenGuard) {
549    absl::Mutex mu;
550    int n = 30;
551    bool done = false;
552    bool (*cond_eq_10)(int *) = [](int *p) { return *p == 10; };
553    bool (*cond_lt_10)(int *) = [](int *p) { return *p < 10; };
554    std::thread t1([&mu, &n, &done, cond_eq_10]() {
555      absl::ReaderMutexLock lock(&mu, absl::Condition(cond_eq_10, &n));
556      done = true;
557    });
558    std::thread t2[10];
559    for (std::thread &t : t2) {
560      t = std::thread([&mu, &n, cond_lt_10]() {
561        absl::WriterMutexLock lock(&mu, absl::Condition(cond_lt_10, &n));
562        ++n;
563      });
564    }
565    {
566      absl::MutexLock lock(&mu);
567      n = 0;
568    }
569    for (std::thread &t : t2) t.join();
570    t1.join();
571    EXPECT_TRUE(done);
572    EXPECT_EQ(n, 10);
573  }
574  #if !defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
575  struct ReaderDecrementBugStruct {
576    bool cond;  
577    int done;   
578    absl::Mutex mu;
579    bool waiting_on_cond;   
580    bool have_reader_lock;  
581    bool complete;          
582    absl::Mutex mu2;        
583  };
584  static bool IsCond(void *v) {
585    ReaderDecrementBugStruct *x = reinterpret_cast<ReaderDecrementBugStruct *>(v);
586    x->mu2.Lock();
587    x->waiting_on_cond = true;
588    x->mu2.Unlock();
589    return x->cond;
590  }
591  static bool AllDone(void *v) {
592    ReaderDecrementBugStruct *x = reinterpret_cast<ReaderDecrementBugStruct *>(v);
593    return x->done == 0;
594  }
595  static void WaitForCond(ReaderDecrementBugStruct *x) {
596    absl::Mutex dummy;
597    absl::MutexLock l(&dummy);
598    x->mu.LockWhen(absl::Condition(&IsCond, x));
599    x->done--;
600    x->mu.Unlock();
601  }
602  static void GetReadLock(ReaderDecrementBugStruct *x) {
603    x->mu.ReaderLock();
604    x->mu2.Lock();
605    x->have_reader_lock = true;
606    x->mu2.Await(absl::Condition(&x->complete));
607    x->mu2.Unlock();
608    x->mu.ReaderUnlock();
609    x->mu.Lock();
610    x->done--;
611    x->mu.Unlock();
612  }
613  TEST(Mutex, MutexReaderDecrementBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
614    ReaderDecrementBugStruct x;
615    x.cond = false;
616    x.waiting_on_cond = false;
617    x.have_reader_lock = false;
618    x.complete = false;
619    x.done = 2;  
620    std::thread thread1(WaitForCond, &x);
621    x.mu2.LockWhen(absl::Condition(&x.waiting_on_cond));
622    x.mu2.Unlock();
623    std::thread thread2(GetReadLock, &x);
624    x.mu2.LockWhen(absl::Condition(&x.have_reader_lock));
625    x.mu2.Unlock();
626    x.mu.ReaderLock();
627    x.mu.ReaderUnlock();
628    x.mu.AssertReaderHeld();
629    x.mu2.Lock();
630    x.complete = true;
631    x.mu2.Unlock();
632    x.mu.Lock();
633    x.cond = true;
634    x.mu.Await(absl::Condition(&AllDone, &x));
635    x.mu.Unlock();
636    thread1.join();
637    thread2.join();
638  }
639  #endif  
640  #ifdef ABSL_HAVE_THREAD_SANITIZER
641  TEST(Mutex, DISABLED_LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
642  #else
643  TEST(Mutex, LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
644  #endif
645    for (int i = 0; i != 10; i++) {
646      const int kNumLocks = 10;
647      auto mu = absl::make_unique<absl::Mutex[]>(kNumLocks);
648      for (int j = 0; j != kNumLocks; j++) {
649        if ((j % 2) == 0) {
650          mu[j].WriterLock();
651        } else {
652          mu[j].ReaderLock();
653        }
654      }
655    }
656  }
657  bool Equals42(int *p) { return *p == 42; }
658  bool Equals43(int *p) { return *p == 43; }
659  bool ConstEquals42(const int *p) { return *p == 42; }
660  bool ConstEquals43(const int *p) { return *p == 43; }
661  template <typename T>
662  bool TemplateEquals42(T *p) {
663    return *p == 42;
664  }
665  template <typename T>
666  bool TemplateEquals43(T *p) {
667    return *p == 43;
668  }
669  TEST(Mutex, FunctionPointerCondition) {
670    int x = 42;
671    const int const_x = 42;
672    EXPECT_TRUE(absl::Condition(Equals42, &x).Eval());
673    EXPECT_FALSE(absl::Condition(Equals43, &x).Eval());
674    EXPECT_TRUE(absl::Condition(ConstEquals42, &x).Eval());
675    EXPECT_FALSE(absl::Condition(ConstEquals43, &x).Eval());
676    EXPECT_TRUE(absl::Condition(ConstEquals42, &const_x).Eval());
677    EXPECT_FALSE(absl::Condition(ConstEquals43, &const_x).Eval());
678    EXPECT_TRUE(absl::Condition(TemplateEquals42, &x).Eval());
679    EXPECT_FALSE(absl::Condition(TemplateEquals43, &x).Eval());
680    EXPECT_TRUE(absl::Condition(TemplateEquals42, &const_x).Eval());
681    EXPECT_FALSE(absl::Condition(TemplateEquals43, &const_x).Eval());
682    EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(Equals42),
683                                        decltype(&const_x)>::value));
684    EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(ConstEquals42),
685                                       decltype(&const_x)>::value));
686  }
687  struct Base {
688    explicit Base(int v) : value(v) {}
689    int value;
690  };
691  struct Derived : Base {
692    explicit Derived(int v) : Base(v) {}
693  };
694  bool BaseEquals42(Base *p) { return p->value == 42; }
695  bool BaseEquals43(Base *p) { return p->value == 43; }
696  bool ConstBaseEquals42(const Base *p) { return p->value == 42; }
697  bool ConstBaseEquals43(const Base *p) { return p->value == 43; }
698  TEST(Mutex, FunctionPointerConditionWithDerivedToBaseConversion) {
699    Derived derived(42);
700    const Derived const_derived(42);
701    EXPECT_TRUE(absl::Condition(BaseEquals42, &derived).Eval());
702    EXPECT_FALSE(absl::Condition(BaseEquals43, &derived).Eval());
703    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &derived).Eval());
704    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &derived).Eval());
705    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &const_derived).Eval());
706    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &const_derived).Eval());
707    EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &const_derived).Eval());
708    EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &const_derived).Eval());
709    bool (*derived_pred)(const Derived *) = [](const Derived *) { return true; };
710    EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(derived_pred),
711                                        Base *>::value));
712    EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(derived_pred),
713                                        const Base *>::value));
714    EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(derived_pred),
715                                       Derived *>::value));
716    EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(derived_pred),
717                                       const Derived *>::value));
718  }
719  struct True {
720    template <class... Args>
721    bool operator()(Args...) const {
722      return true;
723    }
724  };
725  struct DerivedTrue : True {};
726  TEST(Mutex, FunctorCondition) {
727    {  
728      True f;
729      EXPECT_TRUE(absl::Condition(&f).Eval());
730    }
731    {  
732      DerivedTrue g;
733      EXPECT_TRUE(absl::Condition(&g).Eval());
734    }
735    {  
736      int value = 3;
737      auto is_zero = [&value] { return value == 0; };
738      absl::Condition c(&is_zero);
739      EXPECT_FALSE(c.Eval());
740      value = 0;
741      EXPECT_TRUE(c.Eval());
742    }
743    {  
744      int value = 0;
745      auto is_positive = std::bind(std::less<int>(), 0, std::cref(value));
746      absl::Condition c(&is_positive);
747      EXPECT_FALSE(c.Eval());
748      value = 1;
749      EXPECT_TRUE(c.Eval());
750    }
751    {  
752      int value = 3;
753      std::function<bool()> is_zero = [&value] { return value == 0; };
754      absl::Condition c(&is_zero);
755      EXPECT_FALSE(c.Eval());
756      value = 0;
757      EXPECT_TRUE(c.Eval());
758    }
759  }
760  static void ReaderForReaderOnCondVar(absl::Mutex *mu, absl::CondVar *cv,
761                                       int *running) {
762    std::random_device dev;
763    std::mt19937 gen(dev());
764    std::uniform_int_distribution<int> random_millis(0, 15);
765    mu->ReaderLock();
766    while (*running == 3) {
767      absl::SleepFor(absl::Milliseconds(random_millis(gen)));
768      cv->WaitWithTimeout(mu, absl::Milliseconds(random_millis(gen)));
769    }
770    mu->ReaderUnlock();
771    mu->Lock();
772    (*running)--;
773    mu->Unlock();
774  }
775  static bool IntIsZero(int *x) { return *x == 0; }
776  TEST(Mutex, TestReaderOnCondVar) {
777    auto tp = CreateDefaultPool();
778    absl::Mutex mu;
779    absl::CondVar cv;
780    int running = 3;
781    tp->Schedule(std::bind(&ReaderForReaderOnCondVar, &mu, &cv, &running));
782    tp->Schedule(std::bind(&ReaderForReaderOnCondVar, &mu, &cv, &running));
783    absl::SleepFor(absl::Seconds(2));
784    mu.Lock();
785    running--;
786    mu.Await(absl::Condition(&IntIsZero, &running));
787    mu.Unlock();
788  }
789  struct AcquireFromConditionStruct {
790    absl::Mutex mu0;   
791    int value;         
792    bool done;         
793    absl::Mutex mu1;   
794    absl::CondVar cv;  
795  };
796  static bool ConditionWithAcquire(AcquireFromConditionStruct *x) {
797    x->value++;  
798    if (x->value == 2 || x->value == 3) {
799      bool always_false = false;
800      x->mu1.LockWhenWithTimeout(absl::Condition(&always_false),
801                                 absl::Milliseconds(100));
802      x->mu1.Unlock();
803    }
804    CHECK_LT(x->value, 4) << "should not be invoked a fourth time";
805    return x->value == 2 || x->value == 3;
806  }
807  static void WaitForCond2(AcquireFromConditionStruct *x) {
808    x->mu0.LockWhen(absl::Condition(&ConditionWithAcquire, x));
809    x->done = true;
810    x->mu0.Unlock();
811  }
812  TEST(Mutex, AcquireFromCondition) {
813    auto tp = CreateDefaultPool();
814    AcquireFromConditionStruct x;
815    x.value = 0;
816    x.done = false;
817    tp->Schedule(
818        std::bind(&WaitForCond2, &x));  
819    absl::SleepFor(absl::Milliseconds(500));  
820    x.mu0.Lock();
821    x.cv.WaitWithTimeout(&x.mu0, absl::Milliseconds(500));  
822    x.mu0.Unlock();
823    x.mu0.LockWhen(absl::Condition(&x.done));
824    x.mu0.Unlock();
825  }
826  TEST(Mutex, DeadlockDetector) {
827    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
828    absl::Mutex m1;
829    absl::Mutex m2;
830    absl::Mutex m3;
831    absl::Mutex m4;
832    m1.Lock();  
833    m2.Lock();  
834    m3.Lock();  
835    m3.Unlock();
836    m2.Unlock();
837    m1.ForgetDeadlockInfo();  
838    m2.Lock();                
839    m3.Lock();                
840    m4.Lock();                
841    m3.Unlock();
842    m2.Unlock();
843    m4.Unlock();
844    m1.Unlock();
845  }
846  class ScopedDisableBazelTestWarnings {
847   public:
848    ScopedDisableBazelTestWarnings() {
849  #ifdef _WIN32
850      char file[MAX_PATH];
851      if (GetEnvironmentVariableA(kVarName, file, sizeof(file)) < sizeof(file)) {
852        warnings_output_file_ = file;
853        SetEnvironmentVariableA(kVarName, nullptr);
854      }
855  #else
856      const char *file = getenv(kVarName);
857      if (file != nullptr) {
858        warnings_output_file_ = file;
859        unsetenv(kVarName);
860      }
861  #endif
862    }
863    ~ScopedDisableBazelTestWarnings() {
864      if (!warnings_output_file_.empty()) {
865  #ifdef _WIN32
866        SetEnvironmentVariableA(kVarName, warnings_output_file_.c_str());
867  #else
868        setenv(kVarName, warnings_output_file_.c_str(), 0);
869  #endif
870      }
871    }
872   private:
873    static const char kVarName[];
874    std::string warnings_output_file_;
875  };
876  const char ScopedDisableBazelTestWarnings::kVarName[] =
877      "TEST_WARNINGS_OUTPUT_FILE";
878  #ifdef ABSL_HAVE_THREAD_SANITIZER
879  TEST(Mutex, DISABLED_DeadlockDetectorBazelWarning) {
880  #else
881  TEST(Mutex, DeadlockDetectorBazelWarning) {
882  #endif
883    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);
884    ScopedDisableBazelTestWarnings disable_bazel_test_warnings;
885    absl::Mutex mu0;
886    absl::Mutex mu1;
887    bool got_mu0 = mu0.TryLock();
888    mu1.Lock();  
889    if (got_mu0) {
890      mu0.Unlock();
891    }
892    if (mu0.TryLock()) {  
893      mu0.Unlock();
894    }
895    mu0.Lock();  
896    mu0.Unlock();
897    mu1.Unlock();
898    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
899  }
900  TEST(Mutex, DeadlockDetectorLongCycle) {
901    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);
902    ScopedDisableBazelTestWarnings disable_bazel_test_warnings;
903    std::vector<absl::Mutex> mutex(100);
904    for (size_t i = 0; i != mutex.size(); i++) {
905      mutex[i].Lock();
906      mutex[(i + 1) % mutex.size()].Lock();
907      mutex[i].Unlock();
908      mutex[(i + 1) % mutex.size()].Unlock();
909    }
910    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
911  }
912  TEST(Mutex, DeadlockDetectorStressTest) ABSL_NO_THREAD_SAFETY_ANALYSIS {
913    const int n_locks = 1 << 17;
914    auto array_of_locks = absl::make_unique<absl::Mutex[]>(n_locks);
915    for (int i = 0; i < n_locks; i++) {
916      int end = std::min(n_locks, i + 5);
917      for (int j = i; j < end; j++) {
918        array_of_locks[j].Lock();
919      }
920      for (int j = i; j < end; j++) {
921        array_of_locks[j].Unlock();
922      }
923    }
924  }
925  #ifdef ABSL_HAVE_THREAD_SANITIZER
926  TEST(Mutex, DISABLED_DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
927  #else
928  TEST(Mutex, DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
929  #endif
930    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
931    absl::Mutex *a = new absl::Mutex;
932    absl::Mutex b, c;
933    a->Lock();
934    b.Lock();
935    b.Unlock();
936    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kIgnore);
937    delete a;
938    absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
939    c.Lock();
940    c.Unlock();
941  }
942  static absl::Duration TimeoutTestAllowedSchedulingDelay() {
943    return absl::Milliseconds(150);
944  }
945  ABSL_MUST_USE_RESULT
946  static bool DelayIsWithinBounds(absl::Duration expected_delay,
947                                  absl::Duration actual_delay) {
948    bool pass = true;
949    if (actual_delay < expected_delay) {
950      LOG(WARNING) << "Actual delay " << actual_delay
951                   << " was too short, expected " << expected_delay
952                   << " (difference " << actual_delay - expected_delay << ")";
953      pass = false;
954    }
955    absl::Duration tolerance = expected_delay <= absl::ZeroDuration()
956                                   ? absl::Milliseconds(10)
957                                   : TimeoutTestAllowedSchedulingDelay();
958    if (actual_delay > expected_delay + tolerance) {
959      LOG(WARNING) << "Actual delay " << actual_delay
960                   << " was too long, expected " << expected_delay
961                   << " (difference " << actual_delay - expected_delay << ")";
962      pass = false;
963    }
964    return pass;
965  }
966  struct TimeoutTestParam {
967    const char *from_file;
968    int from_line;
969    bool use_absolute_deadline;
970    absl::Duration wait_timeout;
971    absl::Duration satisfy_condition_delay;
972    bool expected_result;
973    absl::Duration expected_delay;
974  };
975  std::ostream &operator<<(std::ostream &os, const TimeoutTestParam &param) {
976    return os << "from: " << param.from_file << ":" << param.from_line
977              << " use_absolute_deadline: "
978              << (param.use_absolute_deadline ? "true" : "false")
979              << " wait_timeout: " << param.wait_timeout
980              << " satisfy_condition_delay: " << param.satisfy_condition_delay
981              << " expected_result: "
982              << (param.expected_result ? "true" : "false")
983              << " expected_delay: " << param.expected_delay;
984  }
985  static void RunAfterDelay(absl::Duration delay,
986                            absl::synchronization_internal::ThreadPool *pool,
987                            const std::function<void()> &callback) {
988    if (delay <= absl::ZeroDuration()) {
989      callback();  
990    } else if (delay != absl::InfiniteDuration()) {
991      ScheduleAfter(pool, delay, callback);
992    }
993  }
994  class TimeoutTest : public ::testing::Test,
995                      public ::testing::WithParamInterface<TimeoutTestParam> {};
996  std::vector<TimeoutTestParam> MakeTimeoutTestParamValues() {
997    const absl::Duration finite = 3 * TimeoutTestAllowedSchedulingDelay();
998    const absl::Duration never = absl::InfiniteDuration();
999    const absl::Duration negative = -absl::InfiniteDuration();
1000    const absl::Duration immediate = absl::ZeroDuration();
1001    std::vector<TimeoutTestParam> values;
1002    for (bool use_absolute_deadline : {false, true}) {
1003      values.push_back(TimeoutTestParam{
1004          __FILE__, __LINE__, use_absolute_deadline,
1005          negative,   
1006          immediate,  
1007          true,       
1008          immediate,  
1009      });
1010      values.push_back(TimeoutTestParam{
1011          __FILE__, __LINE__, use_absolute_deadline,
1012          negative,  
1013          finite,    
1014          false,     
1015          immediate  
1016      });
1017      values.push_back(TimeoutTestParam{
1018          __FILE__, __LINE__, use_absolute_deadline,
1019          negative,  
1020          never,     
1021          false,     
1022          immediate  
1023      });
1024      values.push_back(TimeoutTestParam{
1025          __FILE__, __LINE__, use_absolute_deadline,
1026          never,      
1027          immediate,  
1028          true,       
1029          immediate   
1030      });
1031      values.push_back(TimeoutTestParam{
1032          __FILE__, __LINE__, use_absolute_deadline,
1033          never,   
1034          finite,  
1035          true,    
1036          finite,  
1037      });
1038      values.push_back(TimeoutTestParam{
1039          __FILE__, __LINE__, use_absolute_deadline,
1040          never,      
1041          immediate,  
1042          true,       
1043          immediate   
1044      });
1045      values.push_back(TimeoutTestParam{
1046          __FILE__, __LINE__, use_absolute_deadline,
1047          finite * 2,  
1048          finite,      
1049          true,        
1050          finite       
1051      });
1052      values.push_back(TimeoutTestParam{
1053          __FILE__, __LINE__, use_absolute_deadline,
1054          finite,      
1055          finite * 2,  
1056          false,       
1057          finite       
1058      });
1059      values.push_back(TimeoutTestParam{
1060          __FILE__, __LINE__, use_absolute_deadline,
1061          finite,  
1062          never,   
1063          false,   
1064          finite   
1065      });
1066    }
1067    return values;
1068  }
1069  INSTANTIATE_TEST_SUITE_P(All, TimeoutTest,
1070                           testing::ValuesIn(MakeTimeoutTestParamValues()));
1071  TEST_P(TimeoutTest, Await) {
1072    const TimeoutTestParam params = GetParam();
1073    LOG(INFO) << "Params: " << params;
1074    for (int attempt = 1;; ++attempt) {
1075      LOG(INFO) << "Attempt " << attempt;
1076      absl::Mutex mu;
1077      bool value = false;  
1078      std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
1079          CreateDefaultPool();
1080      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
1081        absl::MutexLock l(&mu);
1082        value = true;
1083      });
1084      absl::MutexLock lock(&mu);
1085      absl::Time start_time = absl::Now();
1086      absl::Condition cond(&value);
1087      bool result =
1088          params.use_absolute_deadline
1089              ? mu.AwaitWithDeadline(cond, start_time + params.wait_timeout)
1090              : mu.AwaitWithTimeout(cond, params.wait_timeout);
1091      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1092        EXPECT_EQ(params.expected_result, result);
1093        break;
1094      }
1095    }
1096  }
1097  TEST_P(TimeoutTest, LockWhen) {
1098    const TimeoutTestParam params = GetParam();
1099    LOG(INFO) << "Params: " << params;
1100    for (int attempt = 1;; ++attempt) {
1101      LOG(INFO) << "Attempt " << attempt;
1102      absl::Mutex mu;
1103      bool value = false;  
1104      std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
1105          CreateDefaultPool();
1106      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
1107        absl::MutexLock l(&mu);
1108        value = true;
1109      });
1110      absl::Time start_time = absl::Now();
1111      absl::Condition cond(&value);
1112      bool result =
1113          params.use_absolute_deadline
1114              ? mu.LockWhenWithDeadline(cond, start_time + params.wait_timeout)
1115              : mu.LockWhenWithTimeout(cond, params.wait_timeout);
1116      mu.Unlock();
1117      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1118        EXPECT_EQ(params.expected_result, result);
1119        break;
1120      }
1121    }
1122  }
1123  TEST_P(TimeoutTest, ReaderLockWhen) {
1124    const TimeoutTestParam params = GetParam();
1125    LOG(INFO) << "Params: " << params;
1126    for (int attempt = 0;; ++attempt) {
1127      LOG(INFO) << "Attempt " << attempt;
1128      absl::Mutex mu;
1129      bool value = false;  
1130      std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
1131          CreateDefaultPool();
1132      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
1133        absl::MutexLock l(&mu);
1134        value = true;
1135      });
1136      absl::Time start_time = absl::Now();
1137      bool result =
1138          params.use_absolute_deadline
1139              ? mu.ReaderLockWhenWithDeadline(absl::Condition(&value),
1140                                              start_time + params.wait_timeout)
1141              : mu.ReaderLockWhenWithTimeout(absl::Condition(&value),
1142                                             params.wait_timeout);
1143      mu.ReaderUnlock();
1144      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1145        EXPECT_EQ(params.expected_result, result);
1146        break;
1147      }
1148    }
1149  }
1150  TEST_P(TimeoutTest, Wait) {
1151    const TimeoutTestParam params = GetParam();
1152    LOG(INFO) << "Params: " << params;
1153    for (int attempt = 0;; ++attempt) {
1154      LOG(INFO) << "Attempt " << attempt;
1155      absl::Mutex mu;
1156      bool value = false;  
1157      absl::CondVar cv;    
1158      std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
1159          CreateDefaultPool();
1160      RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
1161        absl::MutexLock l(&mu);
1162        value = true;
1163        cv.Signal();
1164      });
1165      absl::MutexLock lock(&mu);
1166      absl::Time start_time = absl::Now();
1167      absl::Duration timeout = params.wait_timeout;
1168      absl::Time deadline = start_time + timeout;
1169      while (!value) {
1170        if (params.use_absolute_deadline ? cv.WaitWithDeadline(&mu, deadline)
1171                                         : cv.WaitWithTimeout(&mu, timeout)) {
1172          break;  
1173        }
1174        timeout = deadline - absl::Now();  
1175      }
1176      bool result = value;  
1177      if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
1178        EXPECT_EQ(params.expected_result, result);
1179        break;
1180      }
1181    }
1182  }
1183  TEST(Mutex, Logging) {
1184    absl::Mutex logged_mutex;
1185    logged_mutex.EnableDebugLog("fido_mutex");
1186    absl::CondVar logged_cv;
1187    logged_cv.EnableDebugLog("rover_cv");
1188    logged_mutex.Lock();
1189    logged_cv.WaitWithTimeout(&logged_mutex, absl::Milliseconds(20));
1190    logged_mutex.Unlock();
1191    logged_mutex.ReaderLock();
1192    logged_mutex.ReaderUnlock();
1193    logged_mutex.Lock();
1194    logged_mutex.Unlock();
1195    logged_cv.Signal();
1196    logged_cv.SignalAll();
1197  }
1198  static std::vector<int> AllThreadCountValues() {
1199    if (kExtendedTest) {
1200      return {2, 4, 8, 10, 16, 20, 24, 30, 32};
1201    }
1202    return {2, 4, 10};
1203  }
1204  class MutexVariableThreadCountTest : public ::testing::TestWithParam<int> {};
1205  INSTANTIATE_TEST_SUITE_P(ThreadCounts, MutexVariableThreadCountTest,
1206                           ::testing::ValuesIn(AllThreadCountValues()),
1207                           ::testing::PrintToStringParamName());
1208  static int ScaleIterations(int x) {
1209  #if defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
1210    return x / 10;
1211  #else
1212    return x;
1213  #endif
1214  }
1215  TEST_P(MutexVariableThreadCountTest, Mutex) {
1216    int threads = GetParam();
1217    int iterations = ScaleIterations(10000000) / threads;
1218    int operations = threads * iterations;
1219    EXPECT_EQ(RunTest(&TestMu, threads, iterations, operations), operations);
1220  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1221    iterations = std::min(iterations, 10);
1222    operations = threads * iterations;
1223    EXPECT_EQ(RunTestWithInvariantDebugging(&TestMu, threads, iterations,
1224                                            operations, CheckSumG0G1),
1225              operations);
1226  #endif
1227  }
1228  TEST_P(MutexVariableThreadCountTest, Try) {
1229    int threads = GetParam();
1230    int iterations = 1000000 / threads;
1231    int operations = iterations * threads;
1232    EXPECT_EQ(RunTest(&TestTry, threads, iterations, operations), operations);
1233  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1234    iterations = std::min(iterations, 10);
1235    operations = threads * iterations;
1236    EXPECT_EQ(RunTestWithInvariantDebugging(&TestTry, threads, iterations,
1237                                            operations, CheckSumG0G1),
1238              operations);
1239  #endif
1240  }
1241  TEST_P(MutexVariableThreadCountTest, R20ms) {
1242    int threads = GetParam();
1243    int iterations = 100;
1244    int operations = iterations * threads;
1245    EXPECT_EQ(RunTest(&TestR20ms, threads, iterations, operations), 0);
1246  }
1247  TEST_P(MutexVariableThreadCountTest, RW) {
1248    int threads = GetParam();
1249    int iterations = ScaleIterations(20000000) / threads;
1250    int operations = iterations * threads;
1251    EXPECT_EQ(RunTest(&TestRW, threads, iterations, operations), operations / 2);
1252  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
1253    iterations = std::min(iterations, 10);
1254    operations = threads * iterations;
1255    EXPECT_EQ(RunTestWithInvariantDebugging(&TestRW, threads, iterations,
1256                                            operations, CheckSumG0G1),
1257              operations / 2);
1258  #endif
1259  }
1260  TEST_P(MutexVariableThreadCountTest, Await) {
1261    int threads = GetParam();
1262    int iterations = ScaleIterations(500000);
1263    int operations = iterations;
<span onclick='openModal()' class='match'>1264    EXPECT_EQ(RunTest(&TestAwait, threads, iterations, operations), operations);
1265  }
</span>1266  TEST_P(MutexVariableThreadCountTest, SignalAll) {
1267    int threads = GetParam();
1268    int iterations = 200000 / threads;
1269    int operations = iterations;
1270    EXPECT_EQ(RunTest(&TestSignalAll, threads, iterations, operations),
1271              operations);
1272  }
1273  TEST(Mutex, Signal) {
1274    int threads = 2;  
1275    int iterations = 200000;
1276    int operations = iterations;
1277    EXPECT_EQ(RunTest(&TestSignal, threads, iterations, operations), operations);
1278  }
1279  TEST(Mutex, Timed) {
1280    int threads = 10;  
1281    int iterations = 1000;
1282    int operations = iterations;
1283    EXPECT_EQ(RunTest(&TestCVTimeout, threads, iterations, operations),
1284              operations);
1285  }
1286  TEST(Mutex, CVTime) {
1287    int threads = 10;  
1288    int iterations = 1;
1289    EXPECT_EQ(RunTest(&TestCVTime, threads, iterations, 1), threads * iterations);
1290  }
1291  TEST(Mutex, MuTime) {
1292    int threads = 10;  
1293    int iterations = 1;
1294    EXPECT_EQ(RunTest(&TestMuTime, threads, iterations, 1), threads * iterations);
1295  }
1296  TEST(Mutex, SignalExitedThread) {
1297  #if defined(__wasm__) || defined(__asmjs__)
1298    constexpr int kThreads = 1;  
1299  #else
1300    constexpr int kThreads = 100;
1301  #endif
1302    std::vector<std::thread> top;
1303    for (unsigned i = 0; i < 2 * std::thread::hardware_concurrency(); i++) {
1304      top.emplace_back([&]() {
1305        for (int i = 0; i < kThreads; i++) {
1306          absl::Mutex mu;
1307          std::thread t([&]() {
1308            mu.Lock();
1309            mu.Unlock();
1310          });
1311          mu.Lock();
1312          mu.Unlock();
1313          t.join();
1314        }
1315      });
1316    }
1317    for (auto &th : top) th.join();
1318  }
1319  TEST(Mutex, WriterPriority) {
1320    absl::Mutex mu;
1321    bool wrote = false;
1322    std::atomic<bool> saw_wrote{false};
1323    auto readfunc = [&]() {
1324      for (size_t i = 0; i < 10; ++i) {
1325        absl::ReaderMutexLock lock(&mu);
1326        if (wrote) {
1327          saw_wrote = true;
1328          break;
1329        }
1330        absl::SleepFor(absl::Seconds(1));
1331      }
1332    };
1333    std::thread t1(readfunc);
1334    absl::SleepFor(absl::Milliseconds(500));
1335    std::thread t2(readfunc);
1336    std::thread t3([&]() {
1337      absl::MutexLock lock(&mu);
1338      wrote = true;
1339    });
1340    t1.join();
1341    t2.join();
1342    t3.join();
1343    EXPECT_TRUE(saw_wrote.load());
1344  }
1345  TEST(Mutex, LockWhenWithTimeoutResult) {
1346    absl::Mutex mu;
1347    const bool kAlwaysTrue = true, kAlwaysFalse = false;
1348    const absl::Condition kTrueCond(&kAlwaysTrue), kFalseCond(&kAlwaysFalse);
1349    EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
1350    mu.Unlock();
1351    EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
1352    EXPECT_TRUE(mu.AwaitWithTimeout(kTrueCond, absl::Milliseconds(1)));
1353    EXPECT_FALSE(mu.AwaitWithTimeout(kFalseCond, absl::Milliseconds(1)));
1354    std::thread th1([&]() {
1355      EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
1356      mu.Unlock();
1357    });
1358    std::thread th2([&]() {
1359      EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
1360      mu.Unlock();
1361    });
1362    absl::SleepFor(absl::Milliseconds(100));
1363    mu.Unlock();
1364    th1.join();
1365    th2.join();
1366  }
1367  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-mutex_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-mutex_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>1232    EXPECT_EQ(RunTest(&TestTry, threads, iterations, operations), operations);
1233  #if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
</pre></code></div>
                <div class="column column_space"><pre><code>1264    EXPECT_EQ(RunTest(&TestAwait, threads, iterations, operations), operations);
1265  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    