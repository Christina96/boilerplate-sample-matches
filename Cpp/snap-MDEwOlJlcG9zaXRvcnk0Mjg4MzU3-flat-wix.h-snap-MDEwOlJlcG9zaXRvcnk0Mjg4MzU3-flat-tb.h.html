
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.58041958041958%, Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wix.h</h3>
            <pre><code>1  ClassHdTP(TWix, PWix);
2  ClassTP(TWixChDef, PWixChDef)
3  private:
4    TStr ChSetStr;
5    TStrV Bit4CdToStrV;
6    TIntV ChToBit4CdV;
7    TChV Bit6CdToChV;
8    TIntV ChToBit6CdV;
9    TChV UcChV;
10    TCh MnCh;
11    TCh MxCh;
12    int* ChToBit4CdT;
13    char* Bit6CdToChT;
14    int* ChToBit6CdT;
15    char* UcChT;
16    void AddBit4CdStr(const TStr& Str);
17    void AddBit6CdCh(const char& Ch);
18    void AddChSet(const TStr& Str);
19    void SetUcCh(const TStr& Str);
20    void SetMnMxCh();
21    void ConvVecToTb();
22  public:
23    TWixChDef();
24    ~TWixChDef();
25    TWixChDef(TSIn& SIn):
26      ChSetStr(SIn),
27      Bit4CdToStrV(SIn), ChToBit4CdV(SIn),
28      Bit6CdToChV(SIn), ChToBit6CdV(SIn),
29      UcChV(SIn), MnCh(SIn), MxCh(SIn){ConvVecToTb();}
30    static TPt<TWixChDef> Load(TSIn& SIn){return new TWixChDef(SIn);}
31    void Save(TSOut& SOut){
32      ChSetStr.Save(SOut);
33      Bit4CdToStrV.Save(SOut); ChToBit4CdV.Save(SOut);
34      Bit6CdToChV.Save(SOut); ChToBit6CdV.Save(SOut);
35      UcChV.Save(SOut); MnCh.Save(SOut); MxCh.Save(SOut);}
36    TWixChDef& operator=(const TWixChDef&){Fail; return *this;}
37    TStr GetChSet() const {return ChSetStr;}
38    TStr GetBit6Str(const int& Cd) const {return Bit4CdToStrV[Cd];}
39    int GetBit4VCd(const char& Ch) const {return ChToBit4CdV[Ch-TCh::Mn];}
40    char GetBit6VCh(const int& Cd) const {return Bit6CdToChV[Cd];}
41    int GetBit6VCd(const char& Ch) const {return ChToBit6CdV[Ch-TCh::Mn];}
42    char GetUcVCh(const char& Ch) const {return UcChV[Ch-TCh::Mn];}
43    char GetMnCh() const {return MnCh;}
44    char GetMxCh() const {return MxCh;}
45    int GetBit4TCd(const char& Ch) const {return ChToBit4CdT[Ch-TCh::Mn];}
46    char GetBit6TCh(const int& Cd) const {return Bit6CdToChT[Cd];}
47    int GetBit6TCd(const char& Ch) const {return ChToBit6CdT[Ch-TCh::Mn];}
48    char GetUcTCh(const char& Ch) const {return UcChT[Ch-TCh::Mn];}
49    void GetNrWordChA(const TChA& WordChA, bool& IsWordOk, TChA& NrWordChA) const;
50    bool IsNrWordChA(const TChA& NrWordChA) const;
<span onclick='openModal()' class='match'>51    void SaveTxt(TOLx& Lx) const;
52  };
53  class TWixCdA{
54  private:
55    TB32Set BSet1, BSet2, BSet3;
56  public:
57    TWixCdA(){}
58    TWixCdA(const TChA& NrWordChA, const TWixChDef& ChDef);
59    ~TWixCdA(){}
60    TWixCdA(TSIn& SIn):
61      BSet1(SIn), BSet2(SIn), BSet3(SIn){}
62    void Save(TSOut& SOut){
63      BSet1.Save(SOut); BSet2.Save(SOut); BSet3.Save(SOut);}
64    TWixCdA& operator=(const TWixCdA& Word){
</span>65      if (this!=&Word){BSet1=Word.BSet1; BSet2=Word.BSet2; BSet3=Word.BSet3;}
66      return *this;}
67    bool operator==(const TWixCdA& Word) const {
68      return (BSet1==Word.BSet1)&&(BSet2==Word.BSet2)&&(BSet3==Word.BSet3);}
69    bool operator<(const TWixCdA& Word) const {
70      return (BSet1<Word.BSet1)||((BSet1==Word.BSet1)&&(BSet2<Word.BSet2))||
71       ((BSet1==Word.BSet1)&&(BSet2==Word.BSet2)&&(BSet3<Word.BSet3));}
72    int GetBit6Cd(const int& ChN) const;
73    bool IsPrefix(const int& Chs, const TWixCdA& CdA) const;
74    void GetNrWordChA(const TWixChDef& ChDef, TChA& NrWordChA) const;
75    int GetPrimHashCd() const;
76    int GetSecHashCd() const;
77  };
78  typedef THash<TWixCdA, TVoid> TWixCdAH;
79  ClassTPV(TWixDocIdSet, PWixDocIdSet, TWixDocIdSetV)
80  private:
81    bool Modified;
82  private:
83    TWix* Wix;
84    TInt WordId;
85    TBlobPtV DocIdV;
86  public:
87    TWixDocIdSet(TWix* _Wix, const int & _WordId, const int& DocIds):
88      Modified(false), Wix(_Wix), WordId(_WordId), DocIdV(DocIds, 0){}
89    ~TWixDocIdSet(){}
90    TWixDocIdSet(TSIn& SIn, TWix* _Wix, const int & _WordId):
91      Modified(false), Wix(_Wix), WordId(_WordId), DocIdV(SIn){}
92    static TPt<TWixDocIdSet> Load(TSIn&){Fail; return NULL;}
93    void Save(TSOut& SOut){
94      DocIdV.Save(SOut);}
95    TWixDocIdSet& operator=(const TWixDocIdSet&){Fail; return *this;}
96    int GetMemUsed(){
97      return sizeof(TWix*)+sizeof(int)+DocIdV.GetMemUsed();}
98    void PutModified(const bool& _Modified){Modified=_Modified;}
99    int GetWordId(){return WordId;}
100    int GetDocIds();
101    void AddDocId(const TBlobPt& DocId, const bool& DoIncDocIds=true);
102    void GetDocIdV(TBlobPtV& _DocIdV){_DocIdV=DocIdV;}
103    void AndDocIdV(TBlobPtV& AndDocIdV){AndDocIdV.Intrs(DocIdV);}
104    void OrDocIdV(TBlobPtV& OrDocIdV){OrDocIdV.Union(DocIdV);}
105    void OnDelFromCache(const TBlobPt& BlobPt, void*);
106    void SaveTxt(TOLx& Lx, const TWixChDef& ChDef);
107  };
108  typedef THash<TBlobPt, PWixDocIdSet> TBPtDocIdSetH;
109  class TWixWord{
110  private:
111    TWixCdA CdA;
112    TInt DocIds;
113    TInt Next;
114    TBlobPt BPt1, BPt2, BPt3, BPt4;
115  public:
116    TWixWord(){}
117    TWixWord(const TWixCdA& _CdA):
118      CdA(_CdA), DocIds(0), Next(-1),
119      BPt1(), BPt2(), BPt3(), BPt4(){}
120    TWixWord(const TStr& WordStr, const TWixChDef& ChDef):
121      CdA(WordStr, ChDef), DocIds(0), Next(-1),
122      BPt1(), BPt2(), BPt3(), BPt4(){}
123    ~TWixWord(){}
124    TWixWord(TSIn& SIn):
125      CdA(SIn), DocIds(SIn), Next(SIn),
126      BPt1(SIn), BPt2(SIn), BPt3(SIn), BPt4(SIn){}
127    void Save(TSOut& SOut){
128      CdA.Save(SOut); DocIds.Save(SOut); Next.Save(SOut);
129      BPt1.Save(SOut); BPt2.Save(SOut); BPt3.Save(SOut); BPt4.Save(SOut);}
130    TWixWord& operator=(const TWixWord& Word){
131      if (this!=&Word){
132        CdA=Word.CdA; DocIds=Word.DocIds; Next=Word.Next;
133        BPt1=Word.BPt1; BPt2=Word.BPt2; BPt3=Word.BPt3; BPt4=Word.BPt4;}
134      return *this;}
135    bool operator==(const TWixWord& Word) const {return CdA==Word.CdA;}
136    bool operator<(const TWixWord& Word) const {return CdA<Word.CdA;}
137    TStr GetNrWordStr(const TWixChDef& ChDef){
138      TChA NrWordChA; CdA.GetNrWordChA(ChDef, NrWordChA); return NrWordChA;}
139    void GetNrWordChA(const TWixChDef& ChDef, TChA& NrWordChA){
140      CdA.GetNrWordChA(ChDef, NrWordChA);}
141    bool IsPrefixChA(const TChA& NrWordChA, const TWixCdA& NrWordCdA){
142      return CdA.IsPrefix(NrWordChA.Len(), NrWordCdA);}
143    int GetDocIds(){return DocIds;}
144    void IncDocIds(){DocIds++;}
145    void AddDocId(const TBlobPt& DocId);
146    int GetNext(){return Next;}
147    void PutNext(const int& _Next){Next=_Next;}
148    PWixDocIdSet GetDocIdSet(TWix* Wix, const int& WordId);
149    void PutDocIdSetBPt(const TBlobPt& DocIdSetBPt);
150    TBlobPt GetDocIdSetBPt();
151  };
152  typedef TVec<TWixWord> TWixWordV;
153  ClassTP(TWix, PWix)
154  public:
155    static const int& WordPortVIxChs;
156    static const int& WordPortVBitsPerCh;
157    static const int& WordPortVLen;
158    static const int& MxChsPerWord;
159    static const int& MxDocIdsInWord;
160    static const TStr WixFExt;
161    static const TStr WixDocIdFExt;
162    static const int InTitle_BPtFlagN;
163    static const int InA_BPtFlagN;
164    static const int WordFqMsb_BPtFlagN;
165    static const int WordFqLsb_BPtFlagN;
166  private:
167    TStr WixFNm;
168    TStr WixDocIdFNm;
169    TFAccess Access;
170    PWixChDef ChDef;
171    TWixCdAH SwCdAH;
172    TIntV WordPortV;
173    TWixWordV WordV;
174    PBlobBs DocIdBBs;
175    TCache<TBlobPt, PWixDocIdSet> DocIdSetCache;
176    int64 CacheResetThreshold; 
177    int64 NewCacheSizeInc;
178    void* GetVoidThis() const {return (void*)this;}  
179    int GetWordPortN(const TChA& WordChA, const bool& DoMaximize);
180    int GetWordPortN(const TWixCdA& WordCdA);
181    int GetWordId(const TWixCdA& WordCdA, const bool& CreateIfNo);
182    int AddDocId(const int& WordId, const TBlobPt& DocId);
183  private:
184    typedef TPair<TInt, TBlobPt> TFqDocIdPr;
185    THash<TWixCdA, TFqDocIdPr> WordCdA_FqDocIdPrH;
186  public:
187    TWix(const TStr& Nm, const TStr& FPath=TStr(),
188     const TFAccess& _Access=faRdOnly, const int64& CacheSize=100000000);
189    static PWix New(const TStr& Nm, const TStr& FPath=TStr(),
190      const TFAccess& Access=faRdOnly, const int64& CacheSize=100000000) {
191       return PWix(new TWix(Nm, FPath, Access, CacheSize)); }
192    ~TWix();
193    TWix(TSIn&){Fail;}
194    static PWix Load(TSIn&){Fail; return NULL;}
195    void Save(TSOut&){Fail;}
196    TWix& operator=(const TWix&){Fail; return *this;}
197    int64 GetMemUsed(){
198      return int64(WordPortV.GetMemUsed())+int64(WordV.GetMemUsed())+DocIdSetCache.GetMemUsed();}
199    TStr GetMemUsedStr();
200    void CacheFlushAndClr(){DocIdSetCache.FlushAndClr();}
201    TWixChDef& GetChDef(){return *ChDef;}
202    PBlobBs GetDocIdBBs(){return DocIdBBs;}
203    void AddHtmlDoc(const TBlobPt& DocId, const PSIn& SIn);
204    PWixDocIdSet GetDocIdSet(const int& WordId);
205    PWixDocIdSet GetDocIdSet(const TWixCdA& WordCdA);
206    void GetDocIdV(const TChA& WordChA, const bool& IsExactMatch,
207     const int& MxWcWords, TBlobPtV& DocIdV);
208    TWixWord& GetWord(const int& WordId){return WordV[WordId];}
209    int GetWords() const {return WordV.Len();}
210    TStr GetWordStr(const int& WordId){
211      return GetWord(WordId).GetNrWordStr(*ChDef);}
212    int GetWordFq(const int& WordId){
213      return GetWord(WordId).GetDocIds();}
214    void GetFqWordV(TIntStrPrV& FqWordV);
215    void SaveTxt(const TStr& FNm){SaveTxt(PSOut(new TFOut(FNm)));}
216    void SaveTxt(const PSOut& SOut);
217    void SaveTxtWordFq(const TStr& FNm){SaveTxtWordFq(PSOut(new TFOut(FNm)));}
218    void SaveTxtWordFq(const PSOut& SOut);
219    static void GetFNms(
220     const TStr& Nm, const TStr& FPath,
221     TStr& WixFNm, TStr& WixDocIdFNm);
222    static bool Exists(const TStr& Nm, const TStr& FPath=TStr());
223    static void Del(const TStr& Nm, const TStr& FPath=TStr());
224    friend class TWixWordSet;
225  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tb.h</h3>
            <pre><code>1  ClassHdTP(TTb, PTb);
2  typedef enum {
3    tsvcUndef, tsvcIgnore, tsvcLabel, tsvcClass, tsvcAttr} TTbSufixVarCat;
4  ClassTPV(TTbVarType, PTbVarType, TTbVarTypeV)
5  private:
6    TBool DefP;
7    TB32Set AlwVTSet;
8    TB32Set FixVTSet;
9    TBool DscIntP, DscOrdP;
10    TInt MnIntDsc, MxIntDsc;
11    TStrV DscToNmV;
12    TStrIntH NmToDscH;
13    TFlt MnFlt, MxFlt;
14  public:
15    TTbVarType():
16      AlwVTSet(TB32Set().Fill()), FixVTSet(),
17      DscIntP(false), DscOrdP(false),
18      MnIntDsc(0), MxIntDsc(0),
19      DscToNmV(), NmToDscH(10),
20      MnFlt(TFlt::Mx), MxFlt(TFlt::Mn){}
21    TTbVarType(TSIn& SIn):
22      DefP(SIn),
23      AlwVTSet(SIn), FixVTSet(SIn),
24      DscIntP(SIn), DscOrdP(SIn),
25      MnIntDsc(SIn), MxIntDsc(SIn),
26      DscToNmV(SIn), NmToDscH(SIn),
27      MnFlt(SIn), MxFlt(SIn){
28      Assert(DefP);}
29    static PTbVarType Load(TSIn& SIn){return new TTbVarType(SIn);}
30    void Save(TSOut& SOut){
31      Assert(DefP); DefP.Save(SOut),
32      FixVTSet.Save(SOut); AlwVTSet.Save(SOut);
33      DscIntP.Save(SOut); DscOrdP.Save(SOut);
34      MnIntDsc.Save(SOut); MxIntDsc.Save(SOut);
35      DscToNmV.Save(SOut); NmToDscH.Save(SOut);
36      MnFlt.Save(SOut); MxFlt.Save(SOut);}
37    void Def(){Assert(!DefP); DefP=true;}
38    bool IsDef() const {return DefP;}
39    TTbVarType& operator=(const TTbVarType& TbVarType){
40      Assert(!DefP); DefP=TbVarType.DefP;
41      FixVTSet=TbVarType.FixVTSet; AlwVTSet=TbVarType.AlwVTSet;
42      DscIntP=TbVarType.DscIntP; DscOrdP=TbVarType.DscOrdP;
43      MnIntDsc=TbVarType.MnIntDsc; MxIntDsc=TbVarType.MxIntDsc;
44      DscToNmV=TbVarType.DscToNmV; NmToDscH=TbVarType.NmToDscH;
45      MnFlt=TbVarType.MnFlt; MxFlt=TbVarType.MxFlt; return *this;}
46    bool operator==(const TTbVarType& TbVarType) const {
47      Assert(DefP);
48      if (this==&TbVarType){return true;}
49      return (DefP==TbVarType.DefP)&&
50       (AlwVTSet==TbVarType.AlwVTSet)&&(FixVTSet==TbVarType.FixVTSet)&&
51       (DscIntP==TbVarType.DscIntP)&&(DscOrdP==TbVarType.DscOrdP)&&
52       (MnIntDsc==TbVarType.MnIntDsc)&&(MxIntDsc==TbVarType.MxIntDsc)&&
53       (DscToNmV==TbVarType.DscToNmV)&&
54       (MnFlt==TbVarType.MnFlt)&&(MxFlt==TbVarType.MxFlt);}
55    TB32Set GetAlwVTSet() const {return AlwVTSet;}
56    void SetAlwVTSet(const TB32Set& _AlwVTSet){
57      Assert(!DefP); AlwVTSet=_AlwVTSet;}
58    TB32Set GetFixVTSet() const {return FixVTSet;}
59    void SetDscFix(const int& _MnIntDsc, const int& _MxIntDsc){
60      Assert(!DefP && !FixVTSet.In(tvtDsc) && (_MnIntDsc<=_MxIntDsc));
61      FixVTSet.Incl(tvtDsc);
62      DscIntP=true; DscOrdP=true; MnIntDsc=_MnIntDsc; MxIntDsc=_MxIntDsc;}
63    void SetDscFix(bool _DscOrd=false){
64      Assert(!DefP && !FixVTSet.In(tvtDsc) && (DscToNmV.Len()==0));
65      FixVTSet.Incl(tvtDsc);
66      DscIntP=false; DscOrdP=_DscOrd; MnIntDsc=0; MxIntDsc=0;}
67    int AddDscNm(const TStr& Str){
68      Assert(!DefP && FixVTSet.In(tvtDsc) && !DscIntP);
69      Assert(NmToDscH.GetKeyId(Str)==-1);
70      return NmToDscH.AddDat(Str, TInt(DscToNmV.Add(Str)));}
71    void SetFltFix(const double& _MnFlt, const double& _MxFlt){
72      Assert(!DefP && !FixVTSet.In(tvtFlt) && (_MnFlt<=_MxFlt));
73      FixVTSet.Incl(tvtFlt);
74      MnFlt=_MnFlt; MxFlt=_MxFlt;}
75    bool IsDsc() const {Assert(DefP);
76      return AlwVTSet.In(tvtDsc) && (FixVTSet.In(tvtDsc) || DscToNmV.Len()>0);}
77    bool IsDscInt() const {Assert(IsDsc()); return DscIntP;}
78    bool IsDscSym() const {Assert(IsDsc()); return !DscIntP;}
79    bool IsDscOrd() const {Assert(IsDsc()); return DscOrdP;}
80    int GetDscs() const {Assert(IsDsc());
81      if (DscIntP){return MxIntDsc-MnIntDsc+1;} else {return DscToNmV.Len();}}
82    int GetMnIntDsc() const {Assert(IsDscInt()); return MnIntDsc;}
83    int GetMxIntDsc() const {Assert(IsDscInt()); return MxIntDsc;}
84    TStr GetDscStr(const int& Dsc) const {return DscToNmV[Dsc];}
85    void GetDscStrV(TStrV& DscStrV) const {
86      Assert(IsDscSym()); int Dscs=GetDscs(); DscStrV.Gen(Dscs, 0);
87      for (int Dsc=0; Dsc<Dscs; Dsc++){DscStrV.Add(GetDscStr(Dsc));}}
88    bool IsFlt() const {Assert(DefP);
89      return AlwVTSet.In(tvtFlt) && (FixVTSet.In(tvtFlt) || (MnFlt<=MxFlt));}
90    double GetFltRange() const {Assert(IsFlt()); return MxFlt-MnFlt;}
91    double GetMnFlt() const {Assert(IsFlt()); return MnFlt;}
92    double GetMxFlt() const {Assert(IsFlt()); return MxFlt;}
93    TStr GetStr() const;
94    bool IsValOk(const TTbVal& Val);
95    TTbVal GetDscVal(const TStr& Str);
96    TTbVal GetDscVal(const int& Dsc);
97    TTbVal GetIntDscVal(const int& Int);
98    TTbVal GetFltVal(const double& Flt);
99    TTbVal GetVal(const TTbVal& Val);
100    double GetNrmFlt(const TTbVal& Val);
101    TStr GetValStr(const TTbVal& Val);
102    static PTbVarType GetDscBoolVarType();
103    static PTbVarType GetDscIntVarType(
104     const int& MnIntDsc, const int& MxIntDsc);
105    static PTbVarType GetDscNmVVarType(
106     const TStrV& NmV, const bool& DscOrdP=false);
107    static PTbVarType GetFltVarType(
108     const double& MnFlt=TFlt::Mn, const double& MxFlt=TFlt::Mx);
109    static TTbSufixVarCat GetSufixVarCat(const TStr& VarNm);
110    static bool IsSuffixVarNm(const PTb& Tb);
111  };
112  ClassTPV(TTbVar, PTbVar, TTbVarV)
113  private:
114    UndefCopy(TTbVar);
115  public:
116    TTbVar(){}
117    virtual ~TTbVar(){}
118    TTbVar(TSIn&){}
119    static PTbVar Load(TSIn&){Fail; return NULL;}
120    virtual void Save(TSOut&){}
121    TTbVar& operator=(const TTbVar&){return *this;}
122    bool operator==(const TTbVar& TbVar) const {
123      return (GetNm()==TbVar.GetNm())&&(GetVarType()==TbVar.GetVarType())&&
124       (GetActVTSet()==TbVar.GetActVTSet());}
125    virtual TStr GetNm() const=0;
126    virtual PTbVarType GetVarType() const=0;
127    virtual TB32Set GetActVTSet() const=0;
128    virtual void DefVarType()=0;
129    virtual TTbVal GetDscVal(const TStr& Str)=0;
130    virtual TTbVal GetDscVal(const int& Dsc)=0;
131    virtual TTbVal GetFltVal(const double& Flt)=0;
132    virtual TTbVal GetVal(const TTbVal& Val)=0;
133  };
134  ClassTPV(TTbTup, PTbTup, TTbTupV)
135  private:
136    UndefCopy(TTbTup);
137  public:
138    TTbTup(){}
139    TTbTup(TSIn&){}
140    virtual ~TTbTup(){}
141    static PTbTup Load(TSIn&){Fail; return NULL;}
142    virtual void Save(TSOut&){}
143    TTbTup& operator=(const TTbTup&){return *this;}
144    virtual void PutNm(const TStr& _Nm)=0;
145    virtual TStr GetNm()=0;
146    virtual void PutVal(int VarN, const TTbVal& Val)=0;
147    virtual TTbVal GetVal(int VarN)=0;
148  };
149  ClassTPV(TTb, PTb, TTbV)
150  private:
151    TStr Nm;
152    UndefCopyAssign(TTb);
153  public:
154    TTb(): Nm("Untitled-Table"){}
155    virtual ~TTb(){}
156    TTb(TSIn& SIn): Nm(SIn){}
157    static PTb Load(TSIn& SIn);
158    virtual void Save(TSOut& SOut){GetTypeNm(*this).Save(SOut); Nm.Save(SOut);}
159    void PutNm(const TStr& _Nm){Nm=_Nm;}
160    TStr GetNm(){return Nm;}
161    void AddTb(const PTb& Tb);
162    PTb GetSubTb(const TIntV& TupNV, const TIntV& VarNV, const PTb& Tb);
163    virtual int AddVar(const PTbVar& TbVar)=0;
164    virtual void DefVarTypes()=0;
165    virtual int GetVars()=0;
166    virtual PTbVar GetVar(const int& VarN)=0;
167    virtual int GetVarN(const TStr& Nm)=0;
168    virtual int AddTup(const TStr& Nm)=0;
169    int AddTup(){return AddTup(TStr());}
170    virtual int GetTups()=0;
171    virtual TStr GetTupNm(const int& TupN)=0;
172    virtual int GetTupN(const TStr& Nm)=0;
173    virtual void PutDsc(const int& TupN, const int& VarN, const TStr& Str)=0;
174    virtual void PutDsc(const int& TupN, const int& VarN, const int& Dsc)=0;
175    virtual void PutFlt(const int& TupN, const int& VarN, const double& Flt)=0;
176    virtual void PutVal(const int& TupN, const int& VarN, const TTbVal& Val)=0;
177    virtual TTbVal GetVal(const int& TupN, const int& VarN)=0;
178    virtual TStr GetValStr(const int& TupN, const int& VarN)=0;
179    static PTb LoadFile(const TStr& FNm, const TStr& FType, const TStr& MemRep);
180    static PTb LoadTxtSpc(const TStr& FNm, const PTb& Tb);
181    static PTb LoadTxtTab(const TStr& FNm, const PTb& Tb);
182    static PTb LoadTxtCsv(const TStr& FNm, const PTb& Tb);
183    void SaveTxt(const TStr& FNm, const bool& SaveTupNm=true);
<span onclick='openModal()' class='match'>184    void SaveAssis(const TStr& FNm);
185  };
186  class TGTbVar: public TTbVar{
187  private:
188    TStr Nm;
189    PTbVarType VarType;
190    TB32Set ActVTSet;
191  public:
192    TGTbVar(): TTbVar(), Nm(), VarType(), ActVTSet(){}
193    TGTbVar(const TStr& _Nm, const PTbVarType& _VarType):
194      TTbVar(), Nm(_Nm), VarType(_VarType), ActVTSet(){}
195    TGTbVar(TSIn& SIn):
196      TTbVar(SIn), Nm(SIn), VarType(SIn), ActVTSet(SIn){}
197    void Save(TSOut& SOut){
198      TTbVar::Save(SOut); Nm.Save(SOut); VarType.Save(SOut); ActVTSet.Save(SOut);}
199    TGTbVar& operator=(const TGTbVar& GTbVar){
</span>200      TTbVar::operator=(GTbVar);
201      Nm=GTbVar.Nm; ActVTSet=GTbVar.ActVTSet; VarType=GTbVar.VarType;
202      return *this;}
203    TStr GetNm() const {return Nm;}
204    PTbVarType GetVarType() const {return VarType;}
205    TB32Set GetActVTSet() const {return ActVTSet;}
206    void DefVarType(){VarType->Def();}
207    TTbVal GetDscVal(const TStr& Str){
208      ActVTSet.Incl(tvtDsc); return VarType->GetDscVal(Str);}
209    TTbVal GetDscVal(const int& Dsc){
210      ActVTSet.Incl(tvtDsc); return VarType->GetDscVal(Dsc);}
211    TTbVal GetFltVal(const double& Flt){
212      ActVTSet.Incl(tvtFlt); return VarType->GetFltVal(Flt);}
213    TTbVal GetVal(const TTbVal& Val){
214      ActVTSet.Incl(Val.GetValTag()); return VarType->GetVal(Val);}
215  };
216  class TGTbTup: public TTbTup{
217    TStr Nm;
218    TTbValV ValV;
219  public:
220    TGTbTup(): TTbTup(), Nm(), ValV(){}
221    TGTbTup(const TStr& _Nm, const int& Vars): TTbTup(), Nm(_Nm), ValV(Vars){}
222    TGTbTup(TSIn& SIn): TTbTup(SIn), Nm(SIn), ValV(SIn){}
223    virtual ~TGTbTup(){}
224    void Save(TSOut& SOut){TTbTup::Save(SOut); Nm.Save(SOut); ValV.Save(SOut);}
225    TGTbTup& operator=(const TGTbTup& GTbTup){
226      TTbTup::operator=(GTbTup); Nm=GTbTup.Nm; ValV=GTbTup.ValV; return *this;}
227    void PutNm(const TStr& _Nm){Nm=_Nm;}
228    TStr GetNm(){return Nm;}
229    void PutVal(int VarN, const TTbVal& Val){ValV[VarN]=Val;}
230    TTbVal GetVal(int VarN){return ValV[VarN];}
231  };
232  class TGTb: public TTb{
233  private:
234    TTbVarV VarV;
235    TStrIntH VarNmToNH;
236    TTbTupV TupV;
237    TStrIntH TupNmToNH;
238  public:
239    TGTb(const int& MxVars=0, const int& MxTups=0):
240      TTb(), VarV(MxVars, 0), VarNmToNH(MxVars>0?MxVars:100),
241      TupV(MxTups, 0), TupNmToNH(MxTups>0?MxTups:100){}
242    TGTb(TSIn& SIn):
243      TTb(SIn), VarV(SIn), VarNmToNH(SIn),
244      TupV(SIn), TupNmToNH(SIn){SIn.LoadCs();}
245    void Save(TSOut& SOut){
246      TTb::Save(SOut); VarV.Save(SOut); VarNmToNH.Save(SOut);
247      TupV.Save(SOut); SOut.SaveCs();}
248    int AddVar(const PTbVar& TbVar);
249    void DefVarTypes();
250    int GetVars(){return VarV.Len();}
251    PTbVar GetVar(const int& VarN){return VarV[VarN];}
252    int GetVarN(const TStr& Nm){return VarNmToNH.GetDat(Nm);}
253    int AddTup(const TStr& Nm);
254    int GetTups(){return TupV.Len();}
255    TStr GetTupNm(const int& TupN){return TupV[TupN]->GetNm();}
256    int GetTupN(const TStr& Nm){return TupNmToNH.GetDat(Nm);}
257    void PutDsc(const int& TupN, const int& VarN, const TStr& Str){
258      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Str));}
259    void PutDsc(const int& TupN, const int& VarN, const int& Dsc){
260      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Dsc));}
261    void PutFlt(const int& TupN, const int& VarN, const double& Flt){
262      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetFltVal(Flt));}
263    void PutVal(const int& TupN, const int& VarN, const TTbVal& Val){
264      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetVal(Val));}
265    TTbVal GetVal(const int& TupN, const int& VarN){
266      return TupV[TupN]->GetVal(VarN);}
267    TStr GetValStr(const int& TupN, const int& VarN);
268  };
269  class TBTb: public TTb{
270  private:
271    TTbVarV VarV;
272    TStrIntH VarNmToNH;
273    TTbTupV TupV;
274    TStrIntH TupNmToNH;
275  public:
276    TBTb(const int& MxVars=0, const int& MxTups=0):
277      TTb(), VarV(MxVars, 0), VarNmToNH(MxVars>0?MxVars:100),
278      TupV(MxTups, 0), TupNmToNH(MxTups>0?MxTups:100){}
279    TBTb(TSIn& SIn):
280      TTb(SIn), VarV(SIn), VarNmToNH(SIn),
281      TupV(SIn), TupNmToNH(SIn){SIn.LoadCs();}
282    void Save(TSOut& SOut){
283      TTb::Save(SOut); VarV.Save(SOut); VarNmToNH.Save(SOut);
284      TupV.Save(SOut); SOut.SaveCs();}
285    int AddVar(const PTbVar& TbVar);
286    void DefVarTypes(){}
287    int GetVars(){return VarNmToNH.Len();}
288    PTbVar GetVar(const int& &bsol;*VarN*/){Fail; return NULL;}
289    int GetVarN(const TStr& Nm){return VarNmToNH.GetKeyId(Nm);}
290    int AddTup(const TStr& Nm);
291    int GetTups(){return TupV.Len();}
292    TStr GetTupNm(const int& TupN){return TupV[TupN]->GetNm();}
293    int GetTupN(const TStr& Nm){return TupNmToNH.GetDat(Nm);}
294    void PutDsc(const int& TupN, const int& VarN, const TStr& Str){
295      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Str));}
296    void PutDsc(const int& TupN, const int& VarN, const int& Dsc){
297      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Dsc));}
298    void PutFlt(const int& TupN, const int& VarN, const double& Flt){
299      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetFltVal(Flt));}
300    void PutVal(const int& TupN, const int& VarN, const TTbVal& Val){
301      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetVal(Val));}
302    TTbVal GetVal(const int& TupN, const int& VarN){
303      return TupV[TupN]->GetVal(VarN);}
304    TStr GetValStr(const int& TupN, const int& VarN);
305  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wix.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tb.h</div>
                </div>
                <div class="column column_space"><pre><code>51    void SaveTxt(TOLx& Lx) const;
52  };
53  class TWixCdA{
54  private:
55    TB32Set BSet1, BSet2, BSet3;
56  public:
57    TWixCdA(){}
58    TWixCdA(const TChA& NrWordChA, const TWixChDef& ChDef);
59    ~TWixCdA(){}
60    TWixCdA(TSIn& SIn):
61      BSet1(SIn), BSet2(SIn), BSet3(SIn){}
62    void Save(TSOut& SOut){
63      BSet1.Save(SOut); BSet2.Save(SOut); BSet3.Save(SOut);}
64    TWixCdA& operator=(const TWixCdA& Word){
</pre></code></div>
                <div class="column column_space"><pre><code>184    void SaveAssis(const TStr& FNm);
185  };
186  class TGTbVar: public TTbVar{
187  private:
188    TStr Nm;
189    PTbVarType VarType;
190    TB32Set ActVTSet;
191  public:
192    TGTbVar(): TTbVar(), Nm(), VarType(), ActVTSet(){}
193    TGTbVar(const TStr& _Nm, const PTbVarType& _VarType):
194      TTbVar(), Nm(_Nm), VarType(_VarType), ActVTSet(){}
195    TGTbVar(TSIn& SIn):
196      TTbVar(SIn), Nm(SIn), VarType(SIn), ActVTSet(SIn){}
197    void Save(TSOut& SOut){
198      TTbVar::Save(SOut); Nm.Save(SOut); VarType.Save(SOut); ActVTSet.Save(SOut);}
199    TGTbVar& operator=(const TGTbVar& GTbVar){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    