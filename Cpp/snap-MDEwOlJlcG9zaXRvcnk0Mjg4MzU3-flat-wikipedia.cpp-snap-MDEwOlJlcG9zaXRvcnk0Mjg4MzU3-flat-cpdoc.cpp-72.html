
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wikipedia.cpp</h3>
            <pre><code>1  #include &quot;wikipedia.h&quot;
2  PWikiDoc LoadXml(const PXmlDoc&amp; XmlDoc){
3    return NULL;
4  }
<span onclick='openModal()' class='match'>5  PWikiBs TWikiBs::LoadBin(const TStr&amp; FNm){
6    return NULL;
7  }
8  void TWikiBs::SaveBin(const TStr&amp; FNm){
</span>9  }
10  PWikiBs TWikiBs::LoadXml(const TStr&amp; FNm){
11    PSIn SIn=TFIn::New(FNm);
12    TXmlDoc::SkipTopTag(SIn);
13    PXmlDoc XmlDoc; int XmlDocs=0;
14    forever{
15      XmlDocs++;
16      if (XmlDocs%1000==0){
17        printf(&quot;%d Docs\r&quot;, XmlDocs);
18      }
19      XmlDoc=TXmlDoc::LoadTxt(SIn);
20      if (!XmlDoc-&gt;IsOk()){break;}
21    }
22    return NULL;
23  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cpdoc.cpp</h3>
            <pre><code>1  TStr TCpDoc::GetTxtStr() const {
2    TChA ChA;
3    ChA+=GetTitleStr(); ChA+=&quot;. &quot;;
4    for (int ParN=0; ParN&lt;GetPars(); ParN++){
5      if (ParN&gt;0){ChA+=&#x27; &#x27;;}
6      ChA+=GetParStr(ParN);
7    }
8    return ChA;
9  }
10  TStr TCpDoc::GetHtmlStr() const {
11    TChA ChA;
12    ChA+=&quot;&lt;HTML&gt;\n&quot;;
13    ChA+=&quot;&lt;HEAD&gt;&lt;TITLE&gt;&quot;; ChA+=GetTitleStr(); ChA+=&quot;&lt;/TITLE&gt;&lt;/HEAD&gt;\n&quot;;
14    ChA+=&quot;&lt;BODY&gt;\n&quot;;
15    ChA+=&quot;&lt;H1&gt;&quot;; ChA+=GetTitleStr(); ChA+=&quot;&lt;/H1&gt;\n&quot;;
16    for (int ParN=0; ParN&lt;GetPars(); ParN++){
17      ChA+=&quot;&lt;P&gt;&quot;;
18      ChA+=GetParStr(ParN);
19      ChA+=&quot;&lt;/P&gt;\n&quot;;
20    }
21    ChA+=&quot;&lt;/BODY&gt;\n&quot;;
22    ChA+=&quot;&lt;/HTML&gt;\n&quot;;
23    return ChA;
24  }
25  TStr TCpDoc::GetAllParStr() const {
26    TChA ChA;
27    for (int ParN=0; ParN&lt;GetPars(); ParN++){
28      if (ParN&gt;0){ChA+=&#x27; &#x27;;}
29      ChA+=GetParStr(ParN);
30    }
31    return ChA;
32  }
33  PSIn TCpDoc::FFirstCpd(const TStr&amp; FNm){
34    PSIn SIn=TFIn::New(FNm);
35    return SIn;
36  }
<span onclick='openModal()' class='match'>37  PSIn TCpDoc::FFirstCpd(const PSIn&amp; SIn){
38    return SIn;
39  }
40  bool TCpDoc::FNextCpd(const PSIn&amp; SIn, PCpDoc&amp; CpDoc){
</span>41    if (SIn-&gt;Eof()){
42      CpDoc=NULL; return false;
43    } else {
44      CpDoc=TCpDoc::Load(*SIn); return true;
45    }
46  }
47  PCpDoc TCpDoc::LoadHtmlDoc(const TStr&amp; FNm){
48    PCpDoc CpDoc=TCpDoc::New();
49    PSIn HtmlSIn=TFIn::New(FNm);
50    TStr HtmlStr=TStr::LoadTxt(HtmlSIn);
51    CpDoc-&gt;DocNm=FNm;
52    CpDoc-&gt;ParStrV.Add(HtmlStr);
53    return CpDoc;
54  }
55  void TCpDoc::SaveHtmlToCpd(
56   const TStr&amp; InHtmlFPath, const TStr&amp; OutCpdFNm,
57   const bool&amp; &amp;bsol;*RecurseDirP*/, const int&amp; MxDocs){
58    PSOut SOut=TFOut::New(OutCpdFNm);
59    TStrV FPathV; FPathV.Add(InHtmlFPath);
60    TStrV FExtV; FExtV.Add(&quot;html&quot;); FExtV.Add(&quot;htm&quot;); FExtV.Add(&quot;xml&quot;);
61    TFFile FFile(FPathV, FExtV, &quot;&quot;, true); TStr FNm;
62    printf(&quot;Processing &#x27;%s&#x27; ...\n&quot;, InHtmlFPath.CStr());
63    int Docs=0;
64    while (FFile.Next(FNm)){
65      if ((MxDocs!=-1)&amp;&amp;(FFile.GetFNmN()&gt;MxDocs)){break;}
66      Docs++; if (FFile.GetFNmN()%10==0){printf(&quot;%d\r&quot;, Docs);}
67      PCpDoc CpDoc=TCpDoc::LoadHtmlDoc(FNm);
68      CpDoc-&gt;Save(*SOut);
69    }
70    printf(&quot;%d\nDone.\n&quot;, Docs);
71  }
72  void TCpDoc::SaveTBsToCpd(
73   const TStr&amp; InTBsFNm, const TStr&amp; OutCpdFNm, const int&amp; &amp;bsol;*MxDocs*/){
74    TStr TxtBsNm=InTBsFNm.GetFBase();
75    TStr TxtBsFPath=InTBsFNm.GetFPath();
76    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
77    PSOut SOut=TFOut::New(OutCpdFNm);
78    TBlobPt TrvBlobPt=TxtBs-&gt;FFirstDocId(); TBlobPt DocId;
79    int DocN=0; TStr DocNm; TStr DocStr;
80    while (TxtBs-&gt;FNextDocId(TrvBlobPt, DocId)){
81      DocN++; if (DocN%100==0){printf(&quot;%d docs\r&quot;, DocN);}
82      TxtBs-&gt;GetDocNmStr(DocId, DocNm, DocStr);
83      PCpDoc CpDoc=TCpDoc::New();
84      CpDoc-&gt;DocNm=DocNm;
85      CpDoc-&gt;ParStrV.Add(DocStr, 1);
86      CpDoc-&gt;Save(*SOut);
87    }
88  }
89  void TCpDoc::SaveLnDocToCpd(
90   const TStr&amp; LnDocFNm, const TStr&amp; OutCpdFNm, const bool&amp; NamedP, const int&amp; MxDocs){
91    printf(&quot;Saving Line-Document &#x27;%s&#x27; to &#x27;%s&#x27; ...\n&quot;, LnDocFNm.CStr(), OutCpdFNm.CStr());
92    PSOut SOut=TFOut::New(OutCpdFNm);
93    TFIn FIn(LnDocFNm); char Ch=&#x27; &#x27;; int Docs=0;
94    while (!FIn.Eof()){
95      Docs++; if ((MxDocs!=-1)&amp;&amp;(Docs&gt;=MxDocs)){break;}
96      printf(&quot;%d\r&quot;, Docs);
97      TChA DocNm;
98      if (NamedP){
99        Ch=FIn.GetCh();
100        while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)&amp;&amp;(Ch!=&#x27; &#x27;)){
101          DocNm+=Ch; Ch=FIn.GetCh();}
102        DocNm.Trunc();
103        if (DocNm.Empty()){Docs--; continue;}
104      }
105      TStrV CatNmV;
106      forever {
107        while ((!FIn.Eof())&amp;&amp;(Ch==&#x27; &#x27;)){Ch=FIn.GetCh();}
108        if (Ch==&#x27;!&#x27;){
109          if (!FIn.Eof()){Ch=FIn.GetCh();}
110          TChA CatNm;
111          while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)&amp;&amp;(Ch!=&#x27; &#x27;)){
112            CatNm+=Ch; Ch=FIn.GetCh();}
113          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
114        } else {
115          break;
116        }
117      }
118      TChA DocChA;
119      while ((!FIn.Eof())&amp;&amp;(Ch!=&#x27;\r&#x27;)&amp;&amp;(Ch!=&#x27;\n&#x27;)){
120        DocChA+=Ch; Ch=FIn.GetCh();}
121      if (DocNm.Empty()&amp;&amp;DocChA.Empty()){
122        continue;}
123      PCpDoc CpDoc=TCpDoc::New();
124      CpDoc-&gt;DocNm=DocNm;
125      CpDoc-&gt;ParStrV.Add(DocChA, 1);
126      for (int CatNmN=0; CatNmN&lt;CatNmV.Len(); CatNmN++){
127        CpDoc-&gt;TopCdNmV.Add(CatNmV[CatNmN]);}
128      CpDoc-&gt;Save(*SOut);
129    }
130    printf(&quot;\nDone.\n&quot;);
131  }
132  const TStr TCpDoc::Reuters21578CpdFBase=&quot;Reuters21578.Cpd&quot;;
133  void TCpDoc::SaveReuters21578ToCpd(
134   const TStr&amp; InFPath, const TStr&amp; OutCpdFNm, const int&amp; MxDocs){
135    PSOut SOut=TFOut::New(OutCpdFNm);
136    TFFile FFile(InFPath, &quot;.SGM&quot;, false); TStr FNm; int Docs=0;
137    while (FFile.Next(FNm)){
138      printf(&quot;Processing file &#x27;%s&#x27;\n&quot;, FNm.CStr());
139      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
140      for (int LDocN=0; LDocN&lt;LDocV.Len(); LDocN++){
141        Docs++; if (Docs%100==0){printf(&quot;%d\r&quot;, Docs);}
142        if ((MxDocs!=-1)&amp;&amp;(Docs&gt;MxDocs)){break;}
143        PCpDoc CpDoc=TCpDoc::New();
144        PXmlDoc Doc=LDocV[LDocN];
145        PXmlTok DocTok=Doc-&gt;GetTok();
146        CpDoc-&gt;DocNm=DocTok-&gt;GetArgVal(&quot;NEWID&quot;);
147        CpDoc-&gt;DateStr=Doc-&gt;GetTagTok(&quot;REUTERS|DATE&quot;)-&gt;GetTokStr(false);
148        PXmlTok TitleTok=Doc-&gt;GetTagTok(&quot;REUTERS|TEXT|TITLE&quot;);
149        if (!TitleTok.Empty()){
150          CpDoc-&gt;TitleStr=TitleTok-&gt;GetTokStr(false);}
151        PXmlTok DatelineTok=Doc-&gt;GetTagTok(&quot;REUTERS|TEXT|DATELINE&quot;);
152        if (!DatelineTok.Empty()){
153          CpDoc-&gt;DatelineStr=DatelineTok-&gt;GetTokStr(false);}
154        TStr TextStr;
155        PXmlTok BodyTok=Doc-&gt;GetTagTok(&quot;REUTERS|TEXT|BODY&quot;);
156        if (!BodyTok.Empty()){
157          TextStr=BodyTok-&gt;GetTokStr(false);
158        } else {
159          PXmlTok TextTok=Doc-&gt;GetTagTok(&quot;REUTERS|TEXT&quot;);
160          if (!TextTok.Empty()){
161            TextStr=TextTok-&gt;GetTokStr(false);
162          }
163        }
164        CpDoc-&gt;ParStrV.Add(TextStr, 1);
165        TXmlTokV TopCatTokV; Doc-&gt;GetTagTokV(&quot;REUTERS|TOPICS|D&quot;, TopCatTokV);
166        for (int TokN=0; TokN&lt;TopCatTokV.Len(); TokN++){
167          TStr CatNm=TopCatTokV[TokN]-&gt;GetTokStr(false);
168          CpDoc-&gt;TopCdNmV.Add(CatNm);
169        }
170        CpDoc-&gt;Save(*SOut);
171      }
172      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;MxDocs)){break;}
173    }
174  }
175  const TStr TCpDoc::Reuters2000CpdFBase=&quot;Reuters2000.Cpd&quot;;
176  void TCpDoc::LoadReuters2000DocFromXml(const TStr&amp; FNm,
177   TStr&amp; DocId, TStr&amp; DateStr, TStr&amp; TitleStr,
178   TStr&amp; HeadlineStr, TStr&amp; BylineStr, TStr&amp; DatelineStr,
179   TStrV&amp; ParStrV,
180   TStrV&amp; TopCdNmV, TStrV&amp; GeoCdNmV, TStrV&amp; IndCdNmV){
181    PXmlDoc Doc=TXmlDoc::LoadTxt(FNm);
182    DocId=Doc-&gt;GetTagTok(&quot;newsitem&quot;)-&gt;GetArgVal(&quot;itemid&quot;);
183    DateStr=Doc-&gt;GetTagTok(&quot;newsitem&quot;)-&gt;GetArgVal(&quot;date&quot;);
184    TitleStr=Doc-&gt;GetTagTok(&quot;newsitem|title&quot;)-&gt;GetTokStr(false);
185    HeadlineStr=Doc-&gt;GetTagTok(&quot;newsitem|headline&quot;)-&gt;GetTokStr(false);
186    BylineStr=&quot;&quot;; PXmlTok BylineTok;
187    if (Doc-&gt;IsTagTok(&quot;newsitem|byline&quot;, BylineTok)){
188      BylineStr=BylineTok-&gt;GetTokStr(false);}
189    DatelineStr=&quot;&quot;; PXmlTok DatelineTok;
190    if (Doc-&gt;IsTagTok(&quot;newsitem|dateline&quot;, DatelineTok)){
191      DatelineStr=DatelineTok-&gt;GetTokStr(false);}
192    ParStrV.Clr(); TXmlTokV ParTokV; Doc-&gt;GetTagTokV(&quot;newsitem|text|p&quot;, ParTokV);
193    for (int ParTokN=0; ParTokN&lt;ParTokV.Len(); ParTokN++){
194      TStr ParStr=ParTokV[ParTokN]-&gt;GetTokStr(false);
195      ParStrV.Add(ParStr);
196    }
197    TopCdNmV.Clr(); GeoCdNmV.Clr(); IndCdNmV.Clr();
198    TXmlTokV CdsTokV; Doc-&gt;GetTagTokV(&quot;newsitem|metadata|codes&quot;, CdsTokV);
199    for (int CdsTokN=0; CdsTokN&lt;CdsTokV.Len(); CdsTokN++){
200      PXmlTok CdsTok=CdsTokV[CdsTokN];
201      TXmlTokV CdTokV; CdsTok-&gt;GetTagTokV(&quot;code&quot;, CdTokV);
202      if (CdsTok-&gt;GetArgVal(&quot;class&quot;)==&quot;bip:topics:1.0&quot;){
203        for (int CdTokN=0; CdTokN&lt;CdTokV.Len(); CdTokN++){
204          TStr CdNm=CdTokV[CdTokN]-&gt;GetArgVal(&quot;code&quot;);
205          TopCdNmV.Add(CdNm);
206        }
207      } else
208      if (CdsTok-&gt;GetArgVal(&quot;class&quot;)==&quot;bip:countries:1.0&quot;){
209        for (int CdTokN=0; CdTokN&lt;CdTokV.Len(); CdTokN++){
210          TStr CdNm=CdTokV[CdTokN]-&gt;GetArgVal(&quot;code&quot;);
211          GeoCdNmV.Add(CdNm);
212        }
213      } else
214      if (CdsTok-&gt;GetArgVal(&quot;class&quot;)==&quot;bip:industries:1.0&quot;){
215        for (int CdTokN=0; CdTokN&lt;CdTokV.Len(); CdTokN++){
216          TStr CdNm=CdTokV[CdTokN]-&gt;GetArgVal(&quot;code&quot;);
217          IndCdNmV.Add(CdNm);
218        }
219      } else {
220        Fail;
221      }
222    }
223  }
224  PCpDoc TCpDoc::LoadReuters2000DocFromXml(const TStr&amp; FNm){
225    PCpDoc CpDoc=TCpDoc::New();
226    LoadReuters2000DocFromXml(FNm,
227     CpDoc-&gt;DocNm, CpDoc-&gt;DateStr, CpDoc-&gt;TitleStr,
228     CpDoc-&gt;HeadlineStr, CpDoc-&gt;BylineStr, CpDoc-&gt;DatelineStr,
229     CpDoc-&gt;ParStrV,
230     CpDoc-&gt;TopCdNmV, CpDoc-&gt;GeoCdNmV, CpDoc-&gt;IndCdNmV);
231    return CpDoc;
232  }
233  void TCpDoc::SaveReuters2000ToCpd(
234   const TStr&amp; InFPath, const TStr&amp; OutCpdFNm, const int&amp; MxDocs){
235    PSOut SOut=TFOut::New(OutCpdFNm);
236    TStrStrH DocIdToDateStrH;
237    TFFile FFile(InFPath, &quot;.XML&quot;, true); TStr FNm;
238    while (FFile.Next(FNm)){
239      if ((MxDocs!=-1)&amp;&amp;(FFile.GetFNmN()&gt;=MxDocs)){break;}
240      if ((1+FFile.GetFNmN())%100==0){
241        printf(&quot;Processing file &#x27;%s&#x27; (%d)\r&quot;, FNm.CStr(), 1+FFile.GetFNmN());}
242      PXmlDoc Doc=TXmlDoc::LoadTxt(FNm);
243      PCpDoc CpDoc=TCpDoc::New();
244      LoadReuters2000DocFromXml(FNm,
245       CpDoc-&gt;DocNm, CpDoc-&gt;DateStr, CpDoc-&gt;TitleStr,
246       CpDoc-&gt;HeadlineStr, CpDoc-&gt;BylineStr, CpDoc-&gt;DatelineStr,
247       CpDoc-&gt;ParStrV,
248       CpDoc-&gt;TopCdNmV, CpDoc-&gt;GeoCdNmV, CpDoc-&gt;IndCdNmV);
249      CpDoc-&gt;Save(*SOut);
250    }
251    printf(&quot;\n&quot;);
252  }
253  const TStr TCpDoc::AcmTechNewsCpdFBase=&quot;AcmTechNews.Cpd&quot;;
254  void TCpDoc::SaveAcmTechNewsToCpd(
255   const TStr&amp; InFPath, const TStr&amp; OutCpdFNm, const int&amp; MxDocs){
256    PSOut SOut=TFOut::New(OutCpdFNm);
257    TFFile FFile(TStrV()+InFPath, TStrV()+&quot;.Html&quot;+&quot;.Htm&quot;, &quot;&quot;, true);
258    TStr FNm; int Docs=0;
259    while (FFile.Next(FNm)){
260      printf(&quot;Processing file &#x27;%s&#x27;\r&quot;, FNm.CStr());
261      PSIn SIn=TFIn::New(FNm);
262      THtmlLx Lx(SIn);
263      while (Lx.GetSym()!=hsyEof){
264        if ((MxDocs!=-1)&amp;&amp;(Docs&gt;MxDocs)){break;}
265        Lx.MoveToBTagOrEof(&quot;&lt;SPAN&gt;&quot;);
266        if (Lx.GetArg(&quot;CLASS&quot;)!=&quot;title&quot;){continue;}
267        Lx.MoveToBTagOrEof(&quot;&lt;A&gt;&quot;);
268        TStr TitleStr=Lx.GetStrToETag(&quot;&lt;A&gt;&quot;, false); TitleStr=&quot;&quot;;
269        Lx.MoveToETagOrEof(&quot;&lt;SPAN&gt;&quot;);
270        Lx.MoveToBTagOrEof(&quot;&lt;P&gt;&quot;);
271        TStr ParStr=Lx.GetStrToETag(&quot;&lt;P&gt;&quot;, false);
272        if (!ParStr.Empty()){
273          Docs++;
274          PCpDoc CpDoc=TCpDoc::New(TInt::GetStr(Docs), TitleStr, ParStr);
275          CpDoc-&gt;Save(*SOut);
276        }
277      }
278    }
279    printf(&quot;\n&quot;);
280  }
281  const TStr TCpDoc::CiaWFBCpdFBase=&quot;CiaWFB.Cpd&quot;;
282  void TCpDoc::SaveCiaWFBToCpd(
283   const TStr&amp; InFPath, const TStr&amp; OutCpdFNm, const int&amp; MxDocs){
284    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(InFPath);
285    PSOut SOut=TFOut::New(OutCpdFNm);
286    for (int CountryN=0; CountryN&lt;CiaWFBBs-&gt;GetCountries(); CountryN++){
287      PCiaWFBCountry CiaWFBCountry=CiaWFBBs-&gt;GetCountry(CountryN);
288      TStr CountryNm=CiaWFBCountry-&gt;GetCountryNm();
289      TStr DescStr=CiaWFBCountry-&gt;GetDescStr();
290      PCpDoc CpDoc=TCpDoc::New(CountryNm, CountryNm, DescStr);
291      CpDoc-&gt;Save(*SOut);
292    }
293  }
294  const TStr TCpDoc::AsfaFBase=&quot;Asfa.Cpd&quot;;
295  void TCpDoc::SaveAsfaToCpd(const TStr&amp; InFPath, const TStr&amp; OutCpdFNm){
296    PSOut SOut=TFOut::New(OutCpdFNm);
297    TStrH AccessionIdH;
298    TFFile FFile(TStr::GetNrFPath(InFPath)+&quot;*.Asfa&quot;); TStr AsfaFNm;
299    while (FFile.Next(AsfaFNm)){
300      printf(&quot;Processing file &#x27;%s&#x27;\n&quot;, AsfaFNm.CStr());
301      PSIn SIn=TFIn::New(AsfaFNm);
302      TILx Lx(SIn, TFSet(iloRetEoln, iloExcept));
303      Lx.GetSym(syLn, syEof);
304      while (Lx.Sym!=syEof){
305        TStr QueryLnStr=Lx.Str;
306        TStrV QueryStrV; QueryLnStr.SplitOnAllCh(&#x27;\t&#x27;, QueryStrV, false);
307        IAssert(QueryStrV[0]==&quot;Query&quot;);
308        Lx.GetSym(syLn); TStr RecNoLnStr=Lx.Str;
309        TStrV RecNoStrV; RecNoLnStr.SplitOnAllCh(&#x27;\t&#x27;, RecNoStrV, false);
310        IAssert(RecNoStrV[0]==&quot;RecordNo&quot;);
311        TStr TitleStr, AbstractStr, PublicationYearStr, AccessionId;
312        TStrV AuthorNmV; TStrV TermNmV1, TermNmV2;
313        while (true){
314          Lx.GetSym(syLn); TStr FldLnStr=Lx.Str;
315          TStrV FldStrV; FldLnStr.SplitOnAllCh(&#x27;\t&#x27;, FldStrV, false);
316          if (FldStrV[0]==&quot;----&quot;){
317            if (!AccessionIdH.IsKey(AccessionId)){
318              AccessionIdH.AddKey(AccessionId);
319              PCpDoc CpDoc=TCpDoc::New();
320              CpDoc-&gt;DocNm=AccessionId;
321              CpDoc-&gt;DateStr=PublicationYearStr;
322              CpDoc-&gt;TitleStr=TitleStr;
323              CpDoc-&gt;ParStrV.Add(AbstractStr);
324              CpDoc-&gt;TopCdNmV=TermNmV1;
325              CpDoc-&gt;GeoCdNmV=TermNmV2;
326              CpDoc-&gt;IndCdNmV=AuthorNmV;
327              CpDoc-&gt;Save(*SOut);
328            } else {&amp;bsol;*printf(&quot;[%s]&quot;, AccessionId.CStr());*/}
329            break;
330          } else
331          if (FldStrV[0]==&quot;TI&quot;){
332            TitleStr=FldStrV[2];
333          } else if (FldStrV[0]==&quot;TI&quot;){
334            TitleStr=FldStrV[2];
335          } else if (FldStrV[0]==&quot;AU&quot;){
336            FldStrV[2].SplitOnAllCh(&#x27;;&#x27;, AuthorNmV);
337            for (int StrN=0; StrN&lt;AuthorNmV.Len(); StrN++){AuthorNmV[StrN].ToTrunc();}
338          } else if (FldStrV[0]==&quot;AB&quot;){
339            AbstractStr=FldStrV[2];
340          } else if (FldStrV[0]==&quot;PY&quot;){
341            PublicationYearStr=FldStrV[2];
342          } else if (FldStrV[0]==&quot;DE&quot;){
343            FldStrV[2].SplitOnAllCh(&#x27;;&#x27;, TermNmV1);
344            for (int StrN=0; StrN&lt;TermNmV1.Len(); StrN++){TermNmV1[StrN].ToTrunc();}
345          } else if (FldStrV[0]==&quot;CL&quot;){
346            FldStrV[2].SplitOnAllCh(&#x27;;&#x27;, TermNmV2);
347            for (int StrN=0; StrN&lt;TermNmV2.Len(); StrN++){TermNmV2[StrN].ToTrunc();}
348          } else if (FldStrV[0]==&quot;AN&quot;){
349            AccessionId=FldStrV[2];
350          }
351        }
352        printf(&quot;%d\r&quot;, AccessionIdH.Len());
353        Lx.GetSym(syLn, syEof);
354      }
355    }
356  }
357  void TCpDoc::SaveForNlpWin(const PSOut&amp; SOut){
358    SOut-&gt;PutStr(&quot;DocId:&quot;);
359    SOut-&gt;PutStr(DocNm); SOut-&gt;PutLn();
360    SOut-&gt;PutStr(HeadlineStr); SOut-&gt;PutLn();
361    for (int ParStrN=0; ParStrN&lt;ParStrV.Len(); ParStrN++){
362      SOut-&gt;PutStr(ParStrV[ParStrN]); SOut-&gt;PutLn();
363    }
364  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wikipedia.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cpdoc.cpp</div>
                </div>
                <div class="column column_space"><pre><code>5  PWikiBs TWikiBs::LoadBin(const TStr&amp; FNm){
6    return NULL;
7  }
8  void TWikiBs::SaveBin(const TStr&amp; FNm){
</pre></code></div>
                <div class="column column_space"><pre><code>37  PSIn TCpDoc::FFirstCpd(const PSIn&amp; SIn){
38    return SIn;
39  }
40  bool TCpDoc::FNextCpd(const PSIn&amp; SIn, PCpDoc&amp; CpDoc){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    