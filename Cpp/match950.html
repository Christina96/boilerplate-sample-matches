<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for doc-arithmetic.cpp &amp; TestNewton.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for doc-arithmetic.cpp &amp; TestNewton.cpp
      </h3>
<h1 align="center">
        12.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>doc-arithmetic.cpp (12.650602%)<th>TestNewton.cpp (11.731844%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(183-185)<td><a href="#" name="0">(21-30)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>doc-arithmetic.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "ibex.h"
#include &lt;fstream&gt;
using namespace ibex;
using namespace std;
ofstream output;
void print_compl(const IntervalVector&amp; x) {
	IntervalVector* result;
	int n=x.complementary(result);
	output &lt;&lt; "complementary of " &lt;&lt; x &lt;&lt; " = " &lt;&lt; endl;
	for (int i=0; i&lt;n; i++) {
	output &lt;&lt; "\t" &lt;&lt; result[i] &lt;&lt; endl;
	}
	delete[] result; }
int main() {
	output.open ("doc-arithmetic.txt");
	output &lt;&lt; "================= this file is generated ==============" &lt;&lt; endl;
	{
	Interval x1;                      	Interval x2(2);                   	Interval x3(x2);                  	Interval x4=x2;                   
	Interval x5(1,2);                 
	Interval x6(1,POS_INFINITY);      	Interval x7(NEG_INFINITY,-1);     	Interval x8=Interval::empty_set();  
	}
	{
	output &lt;&lt; "![itv-constants-O]" &lt;&lt; endl;
	output &lt;&lt; " EMPTY_SET =\t " &lt;&lt;  Interval::empty_set() &lt;&lt; endl;
	output &lt;&lt; " PI =\t\t "      &lt;&lt;  Interval::pi() &lt;&lt;  endl;
	output &lt;&lt; " 2 PI =\t\t "    &lt;&lt;  Interval::two_pi() &lt;&lt; endl;
	output &lt;&lt; " 1/2 PI =\t "    &lt;&lt;  Interval::half_pi() &lt;&lt; endl;
	output &lt;&lt; " ONE =\t\t "     &lt;&lt;  Interval::one() &lt;&lt; endl;
	output &lt;&lt; " ZERO =\t\t "    &lt;&lt;  Interval::zero() &lt;&lt; endl;
	output &lt;&lt; " ALL_REALS =\t " &lt;&lt;  Interval::all_reals() &lt;&lt; endl;
	output &lt;&lt; " POS_REALS =\t " &lt;&lt;  Interval::pos_reals() &lt;&lt; endl;
	output &lt;&lt; " NEG_REALS =\t " &lt;&lt;  Interval::neg_reals() &lt;&lt; endl;
	output &lt;&lt; "![itv-constants-O]" &lt;&lt; endl;
	}
	{
	output &lt;&lt; "![itv-div2-O]" &lt;&lt; endl;
	Interval intv(-10,10);
	Interval out2;
	bool result=intv.div2_inter(Interval(2,3), Interval(-1,2), out2);
	output &lt;&lt; "the intersection is " &lt;&lt; (result? "not":"") &lt;&lt; " empty" &lt;&lt; endl;
	output &lt;&lt; "left part=" &lt;&lt; intv &lt;&lt; " right part=" &lt;&lt; out2 &lt;&lt; endl;
	output &lt;&lt; "![itv-div2-O]" &lt;&lt; endl;
	}
	{
	IntervalVector x1(3); 	x1[0]=Interval(0,1);  	x1[1]=Interval(2,3);
	x1[2]=Interval(4,5);
	double _x2[3][2]={{0,1},{2,3},{4,5}};
	IntervalVector x2(3,_x2);
	}
	{
	Vector x1(3);  	x1[0]=0.1;     	x1[1]=0.2;
	x1[2]=0.3;
	double _x2[3]={0.1,0.2,0.3};
	Vector x2(3,_x2);
	}
	{
	IntervalVector x2(3,Interval(1,2));         	IntervalVector x3(3,0.1);                   	Vector         x4(3,0.1);                   
	IntervalVector x5(x2);                      	Vector x6(x4);                              	}
	{
	IntervalVector x1=IntervalVector::empty(3); 
	Vector x(3,0.1);
	IntervalVector x2(x);                       	}
	{
	output &lt;&lt; "! [itv-build-mat-O]" &lt;&lt; endl;
	Matrix m1(2,3);   	m1[0][0]=1;       	m1[0][1]=2;
	m1[0][2]=3;
	m1[1][0]=4;
	m1[1][1]=5;
	m1[1][2]=6;
	output &lt;&lt; "m1=" &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;
	double _m2[2*3]={1,2,3,
			 4,5,6};
	Matrix m2(2,3,_m2);
	output &lt;&lt; "m2=" &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;
	Matrix m3(2,3,1.0);
	output &lt;&lt; "m3=" &lt;&lt; m3 &lt;&lt; endl &lt;&lt; endl;
	Matrix m4=Matrix::ones(2,3);
	Matrix m5(m3);
	output &lt;&lt; "m5=" &lt;&lt; m5 &lt;&lt; endl;
	output &lt;&lt; "! [itv-build-mat-O]" &lt;&lt; endl;
	}
	{
	output &lt;&lt; "! [itv-build-itv-mat-O]" &lt;&lt; endl;
	double eps=1e-02;
	IntervalMatrix m1(3,3);                   	m1=Matrix::eye(3);                        	m1+=Interval(-eps,eps)*Matrix::ones(3);   	output &lt;&lt; "m1=" &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;
<a name="0"></a>	<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	double _m2[3*3][2]={{1-eps,1+eps},{-eps,eps},{-eps,eps},
	                   {-eps,eps},{1-eps,1+eps},{-eps,eps},
	                   {-eps,eps},{-eps,eps},{1-eps,1+eps}};</b></font>
	IntervalMatrix m2(3,3,_m2);
	output &lt;&lt; "m2=" &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;
	IntervalMatrix m3(3,3,Interval(-eps,eps));
	m3+=Matrix::eye(3);
	output &lt;&lt; "m3=" &lt;&lt; m3 &lt;&lt; endl &lt;&lt; endl;
	IntervalMatrix m4(m3);
	output &lt;&lt; "m4=" &lt;&lt; m4 &lt;&lt; endl;
	output &lt;&lt; "! [itv-build-itv-mat-O]" &lt;&lt; endl;
	}
	{
	output &lt;&lt; "! [itv-compl-O]" &lt;&lt; endl;
	Interval x(0,1);
	Interval c1,c2; 
	int n=x.complementary(c1,c2);
	output &lt;&lt; "complementary of " &lt;&lt; x &lt;&lt; " = " &lt;&lt; c1;
	if (n&gt;1) output &lt;&lt; " and " &lt;&lt; c2;
	output &lt;&lt; endl;
	output &lt;&lt; "! [itv-compl-O]" &lt;&lt; endl;
	}
	{
	output &lt;&lt; "! [itv-compl-vec-O]" &lt;&lt; endl;
	print_compl(IntervalVector::empty(3));
	print_compl(IntervalVector(3));
	print_compl(IntervalVector(3,Interval(0,1)));
	output &lt;&lt; "! [itv-compl-vec-O]" &lt;&lt; endl;
	}
	{
	output &lt;&lt; "! [itv-diff-O]" &lt;&lt; endl;
	Interval x(0,3);
	Interval y(1,2);
	Interval c1,c2; 
	int n=x.diff(y,c1,c2);
	output &lt;&lt; x &lt;&lt; " \\ " &lt;&lt; y &lt;&lt; " = " &lt;&lt; c1;
	if (n&gt;1) output &lt;&lt; " and " &lt;&lt; c2;
	output &lt;&lt; endl;
	output &lt;&lt; "! [itv-diff-O]" &lt;&lt; endl;
	}
	{
	output &lt;&lt; "! [itv-diff-vec-O]" &lt;&lt; endl;
	IntervalVector x(2,Interval(0,3));
	IntervalVector y(2,Interval(1,2));
	IntervalVector* result; 
	int n=x.diff(y,result);
	output &lt;&lt; x &lt;&lt; " \\ " &lt;&lt; y &lt;&lt; " = " &lt;&lt; endl;
	for (int i=0; i&lt;n; i++) {
		output &lt;&lt; "\t" &lt;&lt; result[i] &lt;&lt; endl;
	}
	delete[] result; 
	output &lt;&lt; "! [itv-diff-vec-O]" &lt;&lt; endl;
	}
	{
	output &lt;&lt; "! [itv-bisect-O]" &lt;&lt; endl;
	IntervalVector x(3,Interval(0,1)); 
	std::pair&lt;IntervalVector,IntervalVector&gt; p = x.bisect(1,0.4); 
	output &lt;&lt; "first box=" &lt;&lt; p.first &lt;&lt; endl;
	output &lt;&lt; "second box=" &lt;&lt; p.second &lt;&lt; endl;
	output &lt;&lt; "! [itv-bisect-O]" &lt;&lt; endl;
	}
	{
	Interval c=Interval(1.0);
	Interval x(1,2);
	Interval y(3,4);
	Interval z=x+y;
	output &lt;&lt; "x before =" &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; "y before =" &lt;&lt; y &lt;&lt; endl;
	output &lt;&lt; "z before =" &lt;&lt; z &lt;&lt; endl &lt;&lt; endl;
	bwd_sin(-1.0,z);
	output &lt;&lt; "z after =" &lt;&lt; z &lt;&lt; endl;
	bwd_add(z,x,y);
	output &lt;&lt; "x after =" &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; "y after =" &lt;&lt; y &lt;&lt; endl;
	}
	{
	Interval x(1,2);
	Interval y(3,4);
	Interval z=x+y;
	output &lt;&lt; "x before =" &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; "y before =" &lt;&lt; y &lt;&lt; endl;
	output &lt;&lt; "z before =" &lt;&lt; z &lt;&lt; endl &lt;&lt; endl;
	bwd_sin(1.0,z);
	output &lt;&lt; "z after =" &lt;&lt; z &lt;&lt; endl;
	bwd_add(z,x,y);
	output &lt;&lt; "x after =" &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; "y after =" &lt;&lt; y &lt;&lt; endl;
	}
	{
	double _x[][2]={{1,1},{1,1},{1,1}};
	IntervalVector x(3,_x);
	IntervalMatrix M=Matrix::eye(3) + Interval(-0.1,0.1)*Matrix::ones(3);
	output &lt;&lt; "x before=" &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; "M before=" &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
	output &lt;&lt; "M*x=" &lt;&lt; M*x &lt;&lt; endl &lt;&lt; endl;
	M[2][2]=Interval(0.5,1.1);
	IntervalVector y=Vector::ones(3);
	output &lt;&lt; "M modified=" &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
	bwd_mul(y,M,x,1e-04);
	output &lt;&lt; "x after=" &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; "M after=" &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
	}
	output.close();
	return 0;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestNewton.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "TestNewton.h"
#include "Ponts30.h"
#include "ibex_Newton.h"
#include "ibex_CtcNewton.h"
#include "ibex_LinearException.h"
using namespace std;
<a name="0"></a>
namespace ibex {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static double BOX1[30][2]={
		{3.4826061062102722232,3.4846061062102768879} ,
		{3.5744039600153962866,3.5764039600154005072} ,
		{3.2391050837195050072,3.2411050837195105601} ,
		{3.5177713541601911551,3.5197713541601940435} ,
		{3.4099008703180069269,3.4119008703180142561} ,
		{3.3352095857633039522,3.3372095857633072846} ,
		{3.3960878856415881444,3.3980878856415985823} ,
		{3.085591474532709988,3.0875914745327137645} ,
		{3.1663998478272401549,3.1683998478272479282} ,</b></font>
		{3.2785769799080979325,3.2805769799081017091} ,
		{2.9956040612287382352,2.9976040612287428999} ,
		{3.4611387483049846914,3.463138748304988912} ,
		{0.39899999999999968825,0.40100000000000096678} ,
		{1.9585917942265420599,1.9605917942265429499} ,
		{2.4023959387712587876,2.4043959387712607878} ,
		{-1.503546954078445852,-1.5015469540784438518} ,
		{3.4464903944979732309,3.4484903944979783397} ,
		{2.8407250066344245099,2.8427250066344273982} ,
		{3.6333497218046626465,3.635349721804671308} ,
		{3.0068080936676628845,3.0088080936676693256} ,
		{3.8706115579677371485,3.8726115579677440337} ,
		{2.9280247128026140047,2.930024712802626663} ,
		{3.6837522306610468448,3.6857522306610515095} ,
		{2.7619416257693760741,2.7639416257693838475} ,
		{3.4968929033543552087,3.4988929033543603175} ,
		{2.5958585387361381436,2.597858538736141476} ,
		{4.998999999999999666,5.001000000000000334} ,
		{-0.0010000000000000000208,0.0010000000000000000208} ,
		{-0.0010000000000000000208,0.0010000000000000000208} ,
		{-0.0010000000000000000208,0.0010000000000000000208}};
double BOX2[][2]= {
		{3.4836061062102725572,3.4836061062102761099},
		{3.5754039600153961764,3.5754039600154006173},
		{3.2401050837195057852,3.2401050837195093379},
		{3.5187713541601914891,3.5187713541601937095},
		{3.4109008703180077049,3.410900870318013034},
		{3.336209585763303842,3.3362095857633069507},
		{3.3970878856415889224,3.3970878856415973601},
		{3.0865914745327103219,3.0865914745327134305},
		{3.1673998478272404888,3.1673998478272467061},
		{3.2795769799080982665,3.2795769799081013751},
		{2.9966040612287390132,2.996604061228742566},
		{3.4621387483049854694,3.4621387483049890221},
		{0.39999999999999980016,0.40000000000000074385},
		{1.9595917942265419498,1.959591794226542838},
		{2.4033959387712586775,2.4033959387712604538},
		{-1.5025469540784459621,-1.5025469540784437417},
		{3.4474903944979735648,3.4474903944979780057},
		{2.8417250066344248438,2.8417250066344270643},
		{3.6343497218046629804,3.6343497218046700858},
		{3.0078080936676636625,3.0078080936676689916},
		{3.8716115579677374825,3.8716115579677432557},
		{2.9290247128026156709,2.929024712802626329},
		{3.6847522306610471787,3.6847522306610511755},
		{2.7629416257693772963,2.7629416257693835135},
		{3.4978929033543559868,3.4978929033543604277},
		{2.5968585387361389216,2.5968585387361411421},
		{5,5},
		{-0,0},
		{-0,0},
		{-0,0} };
void TestNewton::newton01() {
	Ponts30 p30;
	IntervalVector box(30,BOX1);
	try {
		newton(*p30.f,box);
		CPPUNIT_ASSERT(!box.is_empty());
	} catch (LinearException&amp; e) {
		CPPUNIT_ASSERT(false);
	}
	IntervalVector expected(30,BOX2);
	CPPUNIT_ASSERT(almost_eq(box,expected,1e-10));
}
void TestNewton::inflating_newton01() {
	Ponts30 p30;
	double eps=1e-2;
	IntervalVector error(30,-eps);
	IntervalVector box(30,BOX2);
	box += error;
	IntervalVector expected(30,BOX2);
	IntervalVector _ignore_(30);
	IntervalVector sol(30);
	bool ret=inflating_newton(*p30.f,box,sol,_ignore_);
	CPPUNIT_ASSERT(ret);
	CPPUNIT_ASSERT(almost_eq(sol,expected,1e-10));
}
void TestNewton::inflating_newton02() {
	Variable x,y,z;
	Function f(x,y,z,sqr(x)+sqr(y)+sqr(z)-1);
	double _x0[][2]={{-0.1,0.1},{-0.1,0.1},{1.,1.}};
	IntervalVector x0(3,_x0);
	VarSet vars(f,z);
	IntervalVector box_unicity(3);
	IntervalVector box_existence(3);
	inflating_newton(f,vars,x0,box_existence,box_unicity);
	CPPUNIT_ASSERT(box_unicity.is_superset(box_existence));
	CPPUNIT_ASSERT(box_unicity.is_superset(box_existence));
	CPPUNIT_ASSERT(box_existence[2].contains(1.0));
	CPPUNIT_ASSERT(box_existence[2].is_superset(7.0/(5*sqrt(Interval(2.0)))));
}
void TestNewton::ctc_parameter01() {
	Variable x,y,z;
	Function f(x,y,z,Return(sqr(x)+sqr(y)-1+z,x-y-z));
	VarSet vars(f,x,y);
	CtcNewton newton(f,vars,POS_INFINITY);
	double _box[][2] = { {0,1},{0,1},{-0.01,0.01}};
	IntervalVector box(3,_box);
	newton.contract(box);
	Vector sol(2,(::sqrt(2)/2));
	CPPUNIT_ASSERT(box.subvector(0,1).contains(sol));
	CPPUNIT_ASSERT(box.min_diam()&gt;0.001);
	CPPUNIT_ASSERT(box[0].diam()&lt;=0.1);
	CPPUNIT_ASSERT(box[1].diam()&lt;=0.1);
}
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
