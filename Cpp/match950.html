<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for doc-arithmetic.cpp &amp; TestNewton.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for doc-arithmetic.cpp &amp; TestNewton.cpp
      </h3>
<h1 align="center">
        12.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>doc-arithmetic.cpp (12.650602%)<th>TestNewton.cpp (11.731844%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(183-185)<td><a href="#" name="0">(21-30)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>doc-arithmetic.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex.h"
2 #include &lt;fstream&gt;
3 using namespace ibex;
4 using namespace std;
5 ofstream output;
6 void print_compl(const IntervalVector&amp; x) {
7 	IntervalVector* result;
8 	int n=x.complementary(result);
9 	output &lt;&lt; "complementary of " &lt;&lt; x &lt;&lt; " = " &lt;&lt; endl;
10 	for (int i=0; i&lt;n; i++) {
11 	output &lt;&lt; "\t" &lt;&lt; result[i] &lt;&lt; endl;
12 	}
13 	delete[] result; }
14 int main() {
15 	output.open ("doc-arithmetic.txt");
16 	output &lt;&lt; "================= this file is generated ==============" &lt;&lt; endl;
17 	{
18 	Interval x1;                      	Interval x2(2);                   	Interval x3(x2);                  	Interval x4=x2;                   
19 	Interval x5(1,2);                 
20 	Interval x6(1,POS_INFINITY);      	Interval x7(NEG_INFINITY,-1);     	Interval x8=Interval::empty_set();  
21 	}
22 	{
23 	output &lt;&lt; "![itv-constants-O]" &lt;&lt; endl;
24 	output &lt;&lt; " EMPTY_SET =\t " &lt;&lt;  Interval::empty_set() &lt;&lt; endl;
25 	output &lt;&lt; " PI =\t\t "      &lt;&lt;  Interval::pi() &lt;&lt;  endl;
26 	output &lt;&lt; " 2 PI =\t\t "    &lt;&lt;  Interval::two_pi() &lt;&lt; endl;
27 	output &lt;&lt; " 1/2 PI =\t "    &lt;&lt;  Interval::half_pi() &lt;&lt; endl;
28 	output &lt;&lt; " ONE =\t\t "     &lt;&lt;  Interval::one() &lt;&lt; endl;
29 	output &lt;&lt; " ZERO =\t\t "    &lt;&lt;  Interval::zero() &lt;&lt; endl;
30 	output &lt;&lt; " ALL_REALS =\t " &lt;&lt;  Interval::all_reals() &lt;&lt; endl;
31 	output &lt;&lt; " POS_REALS =\t " &lt;&lt;  Interval::pos_reals() &lt;&lt; endl;
32 	output &lt;&lt; " NEG_REALS =\t " &lt;&lt;  Interval::neg_reals() &lt;&lt; endl;
33 	output &lt;&lt; "![itv-constants-O]" &lt;&lt; endl;
34 	}
35 	{
36 	output &lt;&lt; "![itv-div2-O]" &lt;&lt; endl;
37 	Interval intv(-10,10);
38 	Interval out2;
39 	bool result=intv.div2_inter(Interval(2,3), Interval(-1,2), out2);
40 	output &lt;&lt; "the intersection is " &lt;&lt; (result? "not":"") &lt;&lt; " empty" &lt;&lt; endl;
41 	output &lt;&lt; "left part=" &lt;&lt; intv &lt;&lt; " right part=" &lt;&lt; out2 &lt;&lt; endl;
42 	output &lt;&lt; "![itv-div2-O]" &lt;&lt; endl;
43 	}
44 	{
45 	IntervalVector x1(3); 	x1[0]=Interval(0,1);  	x1[1]=Interval(2,3);
46 	x1[2]=Interval(4,5);
47 	double _x2[3][2]={{0,1},{2,3},{4,5}};
48 	IntervalVector x2(3,_x2);
49 	}
50 	{
51 	Vector x1(3);  	x1[0]=0.1;     	x1[1]=0.2;
52 	x1[2]=0.3;
53 	double _x2[3]={0.1,0.2,0.3};
54 	Vector x2(3,_x2);
55 	}
56 	{
57 	IntervalVector x2(3,Interval(1,2));         	IntervalVector x3(3,0.1);                   	Vector         x4(3,0.1);                   
58 	IntervalVector x5(x2);                      	Vector x6(x4);                              	}
59 	{
60 	IntervalVector x1=IntervalVector::empty(3); 
61 	Vector x(3,0.1);
62 	IntervalVector x2(x);                       	}
63 	{
64 	output &lt;&lt; "! [itv-build-mat-O]" &lt;&lt; endl;
65 	Matrix m1(2,3);   	m1[0][0]=1;       	m1[0][1]=2;
66 	m1[0][2]=3;
67 	m1[1][0]=4;
68 	m1[1][1]=5;
69 	m1[1][2]=6;
70 	output &lt;&lt; "m1=" &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;
71 	double _m2[2*3]={1,2,3,
72 			 4,5,6};
73 	Matrix m2(2,3,_m2);
74 	output &lt;&lt; "m2=" &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;
75 	Matrix m3(2,3,1.0);
76 	output &lt;&lt; "m3=" &lt;&lt; m3 &lt;&lt; endl &lt;&lt; endl;
77 	Matrix m4=Matrix::ones(2,3);
78 	Matrix m5(m3);
79 	output &lt;&lt; "m5=" &lt;&lt; m5 &lt;&lt; endl;
80 	output &lt;&lt; "! [itv-build-mat-O]" &lt;&lt; endl;
81 	}
82 	{
83 	output &lt;&lt; "! [itv-build-itv-mat-O]" &lt;&lt; endl;
84 	double eps=1e-02;
85 	IntervalMatrix m1(3,3);                   	m1=Matrix::eye(3);                        	m1+=Interval(-eps,eps)*Matrix::ones(3);   	output &lt;&lt; "m1=" &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;
86 <a name="0"></a>	<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	double _m2[3*3][2]={{1-eps,1+eps},{-eps,eps},{-eps,eps},
87 	                   {-eps,eps},{1-eps,1+eps},{-eps,eps},
88 	                   {-eps,eps},{-eps,eps},{1-eps,1+eps}};</b></font>
89 	IntervalMatrix m2(3,3,_m2);
90 	output &lt;&lt; "m2=" &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;
91 	IntervalMatrix m3(3,3,Interval(-eps,eps));
92 	m3+=Matrix::eye(3);
93 	output &lt;&lt; "m3=" &lt;&lt; m3 &lt;&lt; endl &lt;&lt; endl;
94 	IntervalMatrix m4(m3);
95 	output &lt;&lt; "m4=" &lt;&lt; m4 &lt;&lt; endl;
96 	output &lt;&lt; "! [itv-build-itv-mat-O]" &lt;&lt; endl;
97 	}
98 	{
99 	output &lt;&lt; "! [itv-compl-O]" &lt;&lt; endl;
100 	Interval x(0,1);
101 	Interval c1,c2; 
102 	int n=x.complementary(c1,c2);
103 	output &lt;&lt; "complementary of " &lt;&lt; x &lt;&lt; " = " &lt;&lt; c1;
104 	if (n&gt;1) output &lt;&lt; " and " &lt;&lt; c2;
105 	output &lt;&lt; endl;
106 	output &lt;&lt; "! [itv-compl-O]" &lt;&lt; endl;
107 	}
108 	{
109 	output &lt;&lt; "! [itv-compl-vec-O]" &lt;&lt; endl;
110 	print_compl(IntervalVector::empty(3));
111 	print_compl(IntervalVector(3));
112 	print_compl(IntervalVector(3,Interval(0,1)));
113 	output &lt;&lt; "! [itv-compl-vec-O]" &lt;&lt; endl;
114 	}
115 	{
116 	output &lt;&lt; "! [itv-diff-O]" &lt;&lt; endl;
117 	Interval x(0,3);
118 	Interval y(1,2);
119 	Interval c1,c2; 
120 	int n=x.diff(y,c1,c2);
121 	output &lt;&lt; x &lt;&lt; " \\ " &lt;&lt; y &lt;&lt; " = " &lt;&lt; c1;
122 	if (n&gt;1) output &lt;&lt; " and " &lt;&lt; c2;
123 	output &lt;&lt; endl;
124 	output &lt;&lt; "! [itv-diff-O]" &lt;&lt; endl;
125 	}
126 	{
127 	output &lt;&lt; "! [itv-diff-vec-O]" &lt;&lt; endl;
128 	IntervalVector x(2,Interval(0,3));
129 	IntervalVector y(2,Interval(1,2));
130 	IntervalVector* result; 
131 	int n=x.diff(y,result);
132 	output &lt;&lt; x &lt;&lt; " \\ " &lt;&lt; y &lt;&lt; " = " &lt;&lt; endl;
133 	for (int i=0; i&lt;n; i++) {
134 		output &lt;&lt; "\t" &lt;&lt; result[i] &lt;&lt; endl;
135 	}
136 	delete[] result; 
137 	output &lt;&lt; "! [itv-diff-vec-O]" &lt;&lt; endl;
138 	}
139 	{
140 	output &lt;&lt; "! [itv-bisect-O]" &lt;&lt; endl;
141 	IntervalVector x(3,Interval(0,1)); 
142 	std::pair&lt;IntervalVector,IntervalVector&gt; p = x.bisect(1,0.4); 
143 	output &lt;&lt; "first box=" &lt;&lt; p.first &lt;&lt; endl;
144 	output &lt;&lt; "second box=" &lt;&lt; p.second &lt;&lt; endl;
145 	output &lt;&lt; "! [itv-bisect-O]" &lt;&lt; endl;
146 	}
147 	{
148 	Interval c=Interval(1.0);
149 	Interval x(1,2);
150 	Interval y(3,4);
151 	Interval z=x+y;
152 	output &lt;&lt; "x before =" &lt;&lt; x &lt;&lt; endl;
153 	output &lt;&lt; "y before =" &lt;&lt; y &lt;&lt; endl;
154 	output &lt;&lt; "z before =" &lt;&lt; z &lt;&lt; endl &lt;&lt; endl;
155 	bwd_sin(-1.0,z);
156 	output &lt;&lt; "z after =" &lt;&lt; z &lt;&lt; endl;
157 	bwd_add(z,x,y);
158 	output &lt;&lt; "x after =" &lt;&lt; x &lt;&lt; endl;
159 	output &lt;&lt; "y after =" &lt;&lt; y &lt;&lt; endl;
160 	}
161 	{
162 	Interval x(1,2);
163 	Interval y(3,4);
164 	Interval z=x+y;
165 	output &lt;&lt; "x before =" &lt;&lt; x &lt;&lt; endl;
166 	output &lt;&lt; "y before =" &lt;&lt; y &lt;&lt; endl;
167 	output &lt;&lt; "z before =" &lt;&lt; z &lt;&lt; endl &lt;&lt; endl;
168 	bwd_sin(1.0,z);
169 	output &lt;&lt; "z after =" &lt;&lt; z &lt;&lt; endl;
170 	bwd_add(z,x,y);
171 	output &lt;&lt; "x after =" &lt;&lt; x &lt;&lt; endl;
172 	output &lt;&lt; "y after =" &lt;&lt; y &lt;&lt; endl;
173 	}
174 	{
175 	double _x[][2]={{1,1},{1,1},{1,1}};
176 	IntervalVector x(3,_x);
177 	IntervalMatrix M=Matrix::eye(3) + Interval(-0.1,0.1)*Matrix::ones(3);
178 	output &lt;&lt; "x before=" &lt;&lt; x &lt;&lt; endl;
179 	output &lt;&lt; "M before=" &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
180 	output &lt;&lt; "M*x=" &lt;&lt; M*x &lt;&lt; endl &lt;&lt; endl;
181 	M[2][2]=Interval(0.5,1.1);
182 	IntervalVector y=Vector::ones(3);
183 	output &lt;&lt; "M modified=" &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
184 	bwd_mul(y,M,x,1e-04);
185 	output &lt;&lt; "x after=" &lt;&lt; x &lt;&lt; endl;
186 	output &lt;&lt; "M after=" &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
187 	}
188 	output.close();
189 	return 0;
190 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestNewton.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "TestNewton.h"
2 #include "Ponts30.h"
3 #include "ibex_Newton.h"
4 #include "ibex_CtcNewton.h"
5 #include "ibex_LinearException.h"
6 using namespace std;
7 <a name="0"></a>
8 namespace ibex {
9 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static double BOX1[30][2]={
10 		{3.4826061062102722232,3.4846061062102768879} ,
11 		{3.5744039600153962866,3.5764039600154005072} ,
12 		{3.2391050837195050072,3.2411050837195105601} ,
13 		{3.5177713541601911551,3.5197713541601940435} ,
14 		{3.4099008703180069269,3.4119008703180142561} ,
15 		{3.3352095857633039522,3.3372095857633072846} ,
16 		{3.3960878856415881444,3.3980878856415985823} ,
17 		{3.085591474532709988,3.0875914745327137645} ,
18 		{3.1663998478272401549,3.1683998478272479282} ,</b></font>
19 		{3.2785769799080979325,3.2805769799081017091} ,
20 		{2.9956040612287382352,2.9976040612287428999} ,
21 		{3.4611387483049846914,3.463138748304988912} ,
22 		{0.39899999999999968825,0.40100000000000096678} ,
23 		{1.9585917942265420599,1.9605917942265429499} ,
24 		{2.4023959387712587876,2.4043959387712607878} ,
25 		{-1.503546954078445852,-1.5015469540784438518} ,
26 		{3.4464903944979732309,3.4484903944979783397} ,
27 		{2.8407250066344245099,2.8427250066344273982} ,
28 		{3.6333497218046626465,3.635349721804671308} ,
29 		{3.0068080936676628845,3.0088080936676693256} ,
30 		{3.8706115579677371485,3.8726115579677440337} ,
31 		{2.9280247128026140047,2.930024712802626663} ,
32 		{3.6837522306610468448,3.6857522306610515095} ,
33 		{2.7619416257693760741,2.7639416257693838475} ,
34 		{3.4968929033543552087,3.4988929033543603175} ,
35 		{2.5958585387361381436,2.597858538736141476} ,
36 		{4.998999999999999666,5.001000000000000334} ,
37 		{-0.0010000000000000000208,0.0010000000000000000208} ,
38 		{-0.0010000000000000000208,0.0010000000000000000208} ,
39 		{-0.0010000000000000000208,0.0010000000000000000208}};
40 double BOX2[][2]= {
41 		{3.4836061062102725572,3.4836061062102761099},
42 		{3.5754039600153961764,3.5754039600154006173},
43 		{3.2401050837195057852,3.2401050837195093379},
44 		{3.5187713541601914891,3.5187713541601937095},
45 		{3.4109008703180077049,3.410900870318013034},
46 		{3.336209585763303842,3.3362095857633069507},
47 		{3.3970878856415889224,3.3970878856415973601},
48 		{3.0865914745327103219,3.0865914745327134305},
49 		{3.1673998478272404888,3.1673998478272467061},
50 		{3.2795769799080982665,3.2795769799081013751},
51 		{2.9966040612287390132,2.996604061228742566},
52 		{3.4621387483049854694,3.4621387483049890221},
53 		{0.39999999999999980016,0.40000000000000074385},
54 		{1.9595917942265419498,1.959591794226542838},
55 		{2.4033959387712586775,2.4033959387712604538},
56 		{-1.5025469540784459621,-1.5025469540784437417},
57 		{3.4474903944979735648,3.4474903944979780057},
58 		{2.8417250066344248438,2.8417250066344270643},
59 		{3.6343497218046629804,3.6343497218046700858},
60 		{3.0078080936676636625,3.0078080936676689916},
61 		{3.8716115579677374825,3.8716115579677432557},
62 		{2.9290247128026156709,2.929024712802626329},
63 		{3.6847522306610471787,3.6847522306610511755},
64 		{2.7629416257693772963,2.7629416257693835135},
65 		{3.4978929033543559868,3.4978929033543604277},
66 		{2.5968585387361389216,2.5968585387361411421},
67 		{5,5},
68 		{-0,0},
69 		{-0,0},
70 		{-0,0} };
71 void TestNewton::newton01() {
72 	Ponts30 p30;
73 	IntervalVector box(30,BOX1);
74 	try {
75 		newton(*p30.f,box);
76 		CPPUNIT_ASSERT(!box.is_empty());
77 	} catch (LinearException&amp; e) {
78 		CPPUNIT_ASSERT(false);
79 	}
80 	IntervalVector expected(30,BOX2);
81 	CPPUNIT_ASSERT(almost_eq(box,expected,1e-10));
82 }
83 void TestNewton::inflating_newton01() {
84 	Ponts30 p30;
85 	double eps=1e-2;
86 	IntervalVector error(30,-eps);
87 	IntervalVector box(30,BOX2);
88 	box += error;
89 	IntervalVector expected(30,BOX2);
90 	IntervalVector _ignore_(30);
91 	IntervalVector sol(30);
92 	bool ret=inflating_newton(*p30.f,box,sol,_ignore_);
93 	CPPUNIT_ASSERT(ret);
94 	CPPUNIT_ASSERT(almost_eq(sol,expected,1e-10));
95 }
96 void TestNewton::inflating_newton02() {
97 	Variable x,y,z;
98 	Function f(x,y,z,sqr(x)+sqr(y)+sqr(z)-1);
99 	double _x0[][2]={{-0.1,0.1},{-0.1,0.1},{1.,1.}};
100 	IntervalVector x0(3,_x0);
101 	VarSet vars(f,z);
102 	IntervalVector box_unicity(3);
103 	IntervalVector box_existence(3);
104 	inflating_newton(f,vars,x0,box_existence,box_unicity);
105 	CPPUNIT_ASSERT(box_unicity.is_superset(box_existence));
106 	CPPUNIT_ASSERT(box_unicity.is_superset(box_existence));
107 	CPPUNIT_ASSERT(box_existence[2].contains(1.0));
108 	CPPUNIT_ASSERT(box_existence[2].is_superset(7.0/(5*sqrt(Interval(2.0)))));
109 }
110 void TestNewton::ctc_parameter01() {
111 	Variable x,y,z;
112 	Function f(x,y,z,Return(sqr(x)+sqr(y)-1+z,x-y-z));
113 	VarSet vars(f,x,y);
114 	CtcNewton newton(f,vars,POS_INFINITY);
115 	double _box[][2] = { {0,1},{0,1},{-0.01,0.01}};
116 	IntervalVector box(3,_box);
117 	newton.contract(box);
118 	Vector sol(2,(::sqrt(2)/2));
119 	CPPUNIT_ASSERT(box.subvector(0,1).contains(sol));
120 	CPPUNIT_ASSERT(box.min_diam()&gt;0.001);
121 	CPPUNIT_ASSERT(box[0].diam()&lt;=0.1);
122 	CPPUNIT_ASSERT(box[1].diam()&lt;=0.1);
123 }
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
