<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for doc-arithmetic.cpp & TestNewton.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for doc-arithmetic.cpp & TestNewton.cpp
      </h3>
      <h1 align="center">
        12.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>doc-arithmetic.cpp (12.650602%)<TH>TestNewton.cpp (11.731844%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match950-0.html#0',2,'match950-1.html#0',3)" NAME="0">(183-185)<TD><A HREF="javascript:ZweiFrames('match950-0.html#0',2,'match950-1.html#0',3)" NAME="0">(21-30)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>doc-arithmetic.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X                                   
// File        : arith01.cpp
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Jun 3, 2012
// Last Update : May 22, 2014
//============================================================================


#include &quot;ibex.h&quot;
#include &lt;fstream&gt;

using namespace ibex;
using namespace std;

ofstream output;

//! [itv-func-compl-vec-C]
void print_compl(const IntervalVector&amp; x) {
	IntervalVector* result;
	int n=x.complementary(result);
	output &lt;&lt; &quot;complementary of &quot; &lt;&lt; x &lt;&lt; &quot; = &quot; &lt;&lt; endl;
	for (int i=0; i&lt;n; i++) {
	output &lt;&lt; &quot;\t&quot; &lt;&lt; result[i] &lt;&lt; endl;
	}

	delete[] result; // don't forget to free memory!
}
//! [itv-func-compl-vec-C]

int main() {

	output.open (&quot;doc-arithmetic.txt&quot;);

	output &lt;&lt; &quot;================= this file is generated ==============&quot; &lt;&lt; endl;

	{
	//! [itv-build-C]
	Interval x1;                      // (-oo,+oo)
	Interval x2(2);                   // [2,2]
	Interval x3(x2);                  // [2,2]
	Interval x4=x2;                   // [2,2]

	Interval x5(1,2);                 // [1,2]

	Interval x6(1,POS_INFINITY);      // [1,+oo)
	Interval x7(NEG_INFINITY,-1);     // (-oo,-1]
	Interval x8=Interval::empty_set();  // empty set

	//! [itv-build-C]
	}

	{
	output &lt;&lt; &quot;![itv-constants-O]&quot; &lt;&lt; endl;
	//! [itv-constants-C]
	output &lt;&lt; &quot; EMPTY_SET =\t &quot; &lt;&lt;  Interval::empty_set() &lt;&lt; endl;
	output &lt;&lt; &quot; PI =\t\t &quot;      &lt;&lt;  Interval::pi() &lt;&lt;  endl;
	output &lt;&lt; &quot; 2 PI =\t\t &quot;    &lt;&lt;  Interval::two_pi() &lt;&lt; endl;
	output &lt;&lt; &quot; 1/2 PI =\t &quot;    &lt;&lt;  Interval::half_pi() &lt;&lt; endl;
	output &lt;&lt; &quot; ONE =\t\t &quot;     &lt;&lt;  Interval::one() &lt;&lt; endl;
	output &lt;&lt; &quot; ZERO =\t\t &quot;    &lt;&lt;  Interval::zero() &lt;&lt; endl;
	output &lt;&lt; &quot; ALL_REALS =\t &quot; &lt;&lt;  Interval::all_reals() &lt;&lt; endl;
	output &lt;&lt; &quot; POS_REALS =\t &quot; &lt;&lt;  Interval::pos_reals() &lt;&lt; endl;
	output &lt;&lt; &quot; NEG_REALS =\t &quot; &lt;&lt;  Interval::neg_reals() &lt;&lt; endl;
	//! [itv-constants-C]
	output &lt;&lt; &quot;![itv-constants-O]&quot; &lt;&lt; endl;

	}

	{
	output &lt;&lt; &quot;![itv-div2-O]&quot; &lt;&lt; endl;
	//! [itv-div2-C]
	Interval intv(-10,10);
	Interval out2;
	bool result=intv.div2_inter(Interval(2,3), Interval(-1,2), out2);
	output &lt;&lt; &quot;the intersection is &quot; &lt;&lt; (result? &quot;not&quot;:&quot;&quot;) &lt;&lt; &quot; empty&quot; &lt;&lt; endl;
	output &lt;&lt; &quot;left part=&quot; &lt;&lt; intv &lt;&lt; &quot; right part=&quot; &lt;&lt; out2 &lt;&lt; endl;
	//! [itv-div2-C]
	output &lt;&lt; &quot;![itv-div2-O]&quot; &lt;&lt; endl;
	}

	{
	//! [itv-build-vec-C]
	// creates ([0,1],[2,3],[4,5]) in several steps.
	IntervalVector x1(3); // so far x1 is ((-oo,oo),(-oo,oo),(-oo,oo))
	x1[0]=Interval(0,1);  // we initialize each component
	x1[1]=Interval(2,3);
	x1[2]=Interval(4,5);

	// creates the same vector in two steps only
	double _x2[3][2]={{0,1},{2,3},{4,5}};
	IntervalVector x2(3,_x2);
	//! [itv-build-vec-C]

	}

	{
	//! [itv-build-vec2-C]
	// creates (0.1,0.2,0.3) in several steps.
	Vector x1(3);  // so far x1 is (0,0,0)
	x1[0]=0.1;     // we initialize each component
	x1[1]=0.2;
	x1[2]=0.3;

	// creates the same vector in two steps only
	double _x2[3]={0.1,0.2,0.3};
	Vector x2(3,_x2);
	//! [itv-build-vec2-C]

	}

	{
	//! [itv-build-vec3-C]
	IntervalVector x2(3,Interval(1,2));         // create ([1,2],[1,2],[1,2])
	IntervalVector x3(3,0.1);                   // create ([0.1,0.1],[0.1,0.1],[0.1,0.1])
	Vector         x4(3,0.1);                   // create (0.1,0.1,0.1)

	IntervalVector x5(x2);                      // create a copy of x2
	Vector x6(x4);                              // create a copy of x4
	//! [itv-build-vec3-C]
	}

	{
	//! [itv-build-vec4-C]
	IntervalVector x1=IntervalVector::empty(3); // create a vector of 3 empty intervals

	Vector x(3,0.1);
	IntervalVector x2(x);                       // create ([0.1,0.1],[0.1,0.1],[0.1,0.1])
	//! [itv-build-vec4-C]
	}

	{
	output &lt;&lt; &quot;! [itv-build-mat-O]&quot; &lt;&lt; endl;
	//! [itv-build-mat-C]

	// create [(1,2,3);(4,5,6)] in several steps.
	Matrix m1(2,3);   // a 2x3 matrix filled with zeros
	m1[0][0]=1;       // we initialize each component
	m1[0][1]=2;
	m1[0][2]=3;
	m1[1][0]=4;
	m1[1][1]=5;
	m1[1][2]=6;
	output &lt;&lt; &quot;m1=&quot; &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;

	// create the same matrix in two steps only
	double _m2[2*3]={1,2,3,
			 4,5,6};
	Matrix m2(2,3,_m2);
	output &lt;&lt; &quot;m2=&quot; &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;

	// create a 2x3 matrix filled with ones
	Matrix m3(2,3,1.0);
	output &lt;&lt; &quot;m3=&quot; &lt;&lt; m3 &lt;&lt; endl &lt;&lt; endl;

	// the same matrix using a built-in static function
	Matrix m4=Matrix::ones(2,3);

	// create a copy of m3
	Matrix m5(m3);
	output &lt;&lt; &quot;m5=&quot; &lt;&lt; m5 &lt;&lt; endl;
	//! [itv-build-mat-C]
	output &lt;&lt; &quot;! [itv-build-mat-O]&quot; &lt;&lt; endl;
	}

	{
	output &lt;&lt; &quot;! [itv-build-itv-mat-O]&quot; &lt;&lt; endl;
	//! [itv-build-itv-mat-C]
	double eps=1e-02;

	// create in several steps.
	IntervalMatrix m1(3,3);                   // a 3x3 matrix filled with (-oo,oo)
	m1=Matrix::eye(3);                        // set m1 to the identity matrix
	m1+=Interval(-eps,eps)*Matrix::ones(3);   // add [-eps,eps] to each component
	output &lt;&lt; &quot;m1=&quot; &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;

	// create the same matrix with a matrix of double
<A NAME="0"></A>	// warning: the matrix of double has a number of rows
	// equal to the total number of components (9) and
	// 2 columns (left bound, right bound).
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match950-1.html#0',3,'match950-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	double _m2[3*3][2]={{1-eps,1+eps},{-eps,eps},{-eps,eps},
	                   {-eps,eps},{1-eps,1+eps},{-eps,eps},
	                   {-eps,eps},{-eps,eps},{1-eps,1+eps}};</B></FONT>

	IntervalMatrix m2(3,3,_m2);
	output &lt;&lt; &quot;m2=&quot; &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;

	// create a 3x3 matrix filled with [-eps,eps]
	IntervalMatrix m3(3,3,Interval(-eps,eps));
	m3+=Matrix::eye(3);
	output &lt;&lt; &quot;m3=&quot; &lt;&lt; m3 &lt;&lt; endl &lt;&lt; endl;

	// create a copy of m3
	IntervalMatrix m4(m3);
	output &lt;&lt; &quot;m4=&quot; &lt;&lt; m4 &lt;&lt; endl;
	//! [itv-build-itv-mat-C]
	output &lt;&lt; &quot;! [itv-build-itv-mat-O]&quot; &lt;&lt; endl;
	}

	{
	output &lt;&lt; &quot;! [itv-compl-O]&quot; &lt;&lt; endl;
	//! [itv-compl-C]
	Interval x(0,1);
	Interval c1,c2; // to store the result

	int n=x.complementary(c1,c2);
	output &lt;&lt; &quot;complementary of &quot; &lt;&lt; x &lt;&lt; &quot; = &quot; &lt;&lt; c1;
	if (n&gt;1) output &lt;&lt; &quot; and &quot; &lt;&lt; c2;
	output &lt;&lt; endl;
	//! [itv-compl-C]
	output &lt;&lt; &quot;! [itv-compl-O]&quot; &lt;&lt; endl;
	}


	{
	output &lt;&lt; &quot;! [itv-compl-vec-O]&quot; &lt;&lt; endl;
	//! [itv-compl-vec-C]
	print_compl(IntervalVector::empty(3));

	print_compl(IntervalVector(3));

	print_compl(IntervalVector(3,Interval(0,1)));
	//! [itv-compl-vec-C]
	output &lt;&lt; &quot;! [itv-compl-vec-O]&quot; &lt;&lt; endl;
	}

	{
	output &lt;&lt; &quot;! [itv-diff-O]&quot; &lt;&lt; endl;
	//! [itv-diff-C]

	// set difference between two intervals
	Interval x(0,3);
	Interval y(1,2);
	Interval c1,c2; // to store the result

	int n=x.diff(y,c1,c2);
	output &lt;&lt; x &lt;&lt; &quot; \\ &quot; &lt;&lt; y &lt;&lt; &quot; = &quot; &lt;&lt; c1;
	if (n&gt;1) output &lt;&lt; &quot; and &quot; &lt;&lt; c2;
	output &lt;&lt; endl;

	//! [itv-diff-C]
	output &lt;&lt; &quot;! [itv-diff-O]&quot; &lt;&lt; endl;
	}

	{
	output &lt;&lt; &quot;! [itv-diff-vec-O]&quot; &lt;&lt; endl;
	//! [itv-diff-vec-C]
	// set difference between two boxes
	IntervalVector x(2,Interval(0,3));
	IntervalVector y(2,Interval(1,2));
	IntervalVector* result; // to store the result

	int n=x.diff(y,result);
	output &lt;&lt; x &lt;&lt; &quot; \\ &quot; &lt;&lt; y &lt;&lt; &quot; = &quot; &lt;&lt; endl;
	for (int i=0; i&lt;n; i++) {
		output &lt;&lt; &quot;\t&quot; &lt;&lt; result[i] &lt;&lt; endl;
	}
	delete[] result; // don't forget to free memory!

	//! [itv-diff-vec-C]
	output &lt;&lt; &quot;! [itv-diff-vec-O]&quot; &lt;&lt; endl;
	}


	{
	output &lt;&lt; &quot;! [itv-bisect-O]&quot; &lt;&lt; endl;
	//! [itv-bisect-C]

	IntervalVector x(3,Interval(0,1)); // [0,1]x[0,1]x[0,1]

	std::pair&lt;IntervalVector,IntervalVector&gt; p = x.bisect(1,0.4); // bisect the second component with ratio 0.4

	output &lt;&lt; &quot;first box=&quot; &lt;&lt; p.first &lt;&lt; endl;
	output &lt;&lt; &quot;second box=&quot; &lt;&lt; p.second &lt;&lt; endl;

	//! [itv-bisect-C]
	output &lt;&lt; &quot;! [itv-bisect-O]&quot; &lt;&lt; endl;
	}

	{
	// Example #4
	// ------------------------------------------------
	// Basic &quot;projection&quot;/&quot;backward arithmetic&quot;
	//
	// (Contraction of x w.r.t. to f(x)=y)
	//
	// &gt; create three intervals x,y and z with z=x+y
	// &gt; project sin(z)=-1 onto z (contracts z)
	// &gt; project x+y onto x and y (contracts x and y)
	// ------------------------------------------------

	Interval c=Interval(1.0);
	Interval x(1,2);
	Interval y(3,4);
	Interval z=x+y;

	output &lt;&lt; &quot;x before =&quot; &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; &quot;y before =&quot; &lt;&lt; y &lt;&lt; endl;
	output &lt;&lt; &quot;z before =&quot; &lt;&lt; z &lt;&lt; endl &lt;&lt; endl;
	bwd_sin(-1.0,z);
	output &lt;&lt; &quot;z after =&quot; &lt;&lt; z &lt;&lt; endl;
	bwd_add(z,x,y);
	output &lt;&lt; &quot;x after =&quot; &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; &quot;y after =&quot; &lt;&lt; y &lt;&lt; endl;
	// ------------------------------------------------
	}

	{
	// Example #5
	// ------------------------------------------------
	// Example of projection leading to an empty set
	//
	// Same example as Example #3 except that the
	// projection of sin(z)=1 onto z leads to an empty set.
	// ------------------------------------------------
	Interval x(1,2);
	Interval y(3,4);
	Interval z=x+y;
	output &lt;&lt; &quot;x before =&quot; &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; &quot;y before =&quot; &lt;&lt; y &lt;&lt; endl;
	output &lt;&lt; &quot;z before =&quot; &lt;&lt; z &lt;&lt; endl &lt;&lt; endl;
	bwd_sin(1.0,z);
	output &lt;&lt; &quot;z after =&quot; &lt;&lt; z &lt;&lt; endl;
	bwd_add(z,x,y);
	output &lt;&lt; &quot;x after =&quot; &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; &quot;y after =&quot; &lt;&lt; y &lt;&lt; endl;
	// ------------------------------------------------
	}

	{
	// Example #6
	// ------------------------------------------------
	// Vector/Matrix projection
	// &gt; create a matrix M centered on the identity
	// &gt; create two 1-column vectors x and y
	// &gt; set artificially one entry of M to a large interval
	// &gt; contract M with respect to M*x=y and observe
	//   that the uncertainty on this entry has been reduced
	// ------------------------------------------------
	double _x[][2]={{1,1},{1,1},{1,1}};
	IntervalVector x(3,_x);
	IntervalMatrix M=Matrix::eye(3) + Interval(-0.1,0.1)*Matrix::ones(3);
	output &lt;&lt; &quot;x before=&quot; &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; &quot;M before=&quot; &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
	output &lt;&lt; &quot;M*x=&quot; &lt;&lt; M*x &lt;&lt; endl &lt;&lt; endl;

	M[2][2]=Interval(0.5,1.1);
	IntervalVector y=Vector::ones(3);
	output &lt;&lt; &quot;M modified=&quot; &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;

	bwd_mul(y,M,x,1e-04);
	output &lt;&lt; &quot;x after=&quot; &lt;&lt; x &lt;&lt; endl;
	output &lt;&lt; &quot;M after=&quot; &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;
	// ------------------------------------------------
	}

	output.close();

	return 0;
}

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestNewton.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X                                   
// File        : ibex_TestNewton.cpp
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Jun 10, 2012
// Last Update : Jun 10, 2012
//============================================================================

#include &quot;TestNewton.h&quot;
#include &quot;Ponts30.h&quot;
#include &quot;ibex_Newton.h&quot;
#include &quot;ibex_CtcNewton.h&quot;
#include &quot;ibex_LinearException.h&quot;

using namespace std;
<A NAME="0"></A>
namespace ibex {

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match950-0.html#0',2,'match950-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static double BOX1[30][2]={
		{3.4826061062102722232,3.4846061062102768879} ,
		{3.5744039600153962866,3.5764039600154005072} ,
		{3.2391050837195050072,3.2411050837195105601} ,
		{3.5177713541601911551,3.5197713541601940435} ,
		{3.4099008703180069269,3.4119008703180142561} ,
		{3.3352095857633039522,3.3372095857633072846} ,
		{3.3960878856415881444,3.3980878856415985823} ,
		{3.085591474532709988,3.0875914745327137645} ,
		{3.1663998478272401549,3.1683998478272479282} ,</B></FONT>
		{3.2785769799080979325,3.2805769799081017091} ,
		{2.9956040612287382352,2.9976040612287428999} ,
		{3.4611387483049846914,3.463138748304988912} ,
		{0.39899999999999968825,0.40100000000000096678} ,
		{1.9585917942265420599,1.9605917942265429499} ,
		{2.4023959387712587876,2.4043959387712607878} ,
		{-1.503546954078445852,-1.5015469540784438518} ,
		{3.4464903944979732309,3.4484903944979783397} ,
		{2.8407250066344245099,2.8427250066344273982} ,
		{3.6333497218046626465,3.635349721804671308} ,
		{3.0068080936676628845,3.0088080936676693256} ,
		{3.8706115579677371485,3.8726115579677440337} ,
		{2.9280247128026140047,2.930024712802626663} ,
		{3.6837522306610468448,3.6857522306610515095} ,
		{2.7619416257693760741,2.7639416257693838475} ,
		{3.4968929033543552087,3.4988929033543603175} ,
		{2.5958585387361381436,2.597858538736141476} ,
		{4.998999999999999666,5.001000000000000334} ,
		{-0.0010000000000000000208,0.0010000000000000000208} ,
		{-0.0010000000000000000208,0.0010000000000000000208} ,
		{-0.0010000000000000000208,0.0010000000000000000208}};


double BOX2[][2]= {
		{3.4836061062102725572,3.4836061062102761099},
		{3.5754039600153961764,3.5754039600154006173},
		{3.2401050837195057852,3.2401050837195093379},
		{3.5187713541601914891,3.5187713541601937095},
		{3.4109008703180077049,3.410900870318013034},
		{3.336209585763303842,3.3362095857633069507},
		{3.3970878856415889224,3.3970878856415973601},
		{3.0865914745327103219,3.0865914745327134305},
		{3.1673998478272404888,3.1673998478272467061},
		{3.2795769799080982665,3.2795769799081013751},
		{2.9966040612287390132,2.996604061228742566},
		{3.4621387483049854694,3.4621387483049890221},
		{0.39999999999999980016,0.40000000000000074385},
		{1.9595917942265419498,1.959591794226542838},
		{2.4033959387712586775,2.4033959387712604538},
		{-1.5025469540784459621,-1.5025469540784437417},
		{3.4474903944979735648,3.4474903944979780057},
		{2.8417250066344248438,2.8417250066344270643},
		{3.6343497218046629804,3.6343497218046700858},
		{3.0078080936676636625,3.0078080936676689916},
		{3.8716115579677374825,3.8716115579677432557},
		{2.9290247128026156709,2.929024712802626329},
		{3.6847522306610471787,3.6847522306610511755},
		{2.7629416257693772963,2.7629416257693835135},
		{3.4978929033543559868,3.4978929033543604277},
		{2.5968585387361389216,2.5968585387361411421},
		{5,5},
		{-0,0},
		{-0,0},
		{-0,0} };

void TestNewton::newton01() {
	Ponts30 p30;
	IntervalVector box(30,BOX1);
	try {
		newton(*p30.f,box);
		CPPUNIT_ASSERT(!box.is_empty());
	} catch (LinearException&amp; e) {
		//cout &lt;&lt; &quot;linear exception&quot; &lt;&lt; endl;
		CPPUNIT_ASSERT(false);
	}

	IntervalVector expected(30,BOX2);
	//cout &lt;&lt; expected &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;
	//cout &lt;&lt; box &lt;&lt; endl;
	CPPUNIT_ASSERT(almost_eq(box,expected,1e-10));
}

void TestNewton::inflating_newton01() {
	Ponts30 p30;
	double eps=1e-2;
	IntervalVector error(30,-eps);
	IntervalVector box(30,BOX2);
	box += error;
	IntervalVector expected(30,BOX2);
	IntervalVector _ignore_(30);
	IntervalVector sol(30);
	bool ret=inflating_newton(*p30.f,box,sol,_ignore_);
	CPPUNIT_ASSERT(ret);

	CPPUNIT_ASSERT(almost_eq(sol,expected,1e-10));
}

void TestNewton::inflating_newton02() {
	Variable x,y,z;
	Function f(x,y,z,sqr(x)+sqr(y)+sqr(z)-1);
	double _x0[][2]={{-0.1,0.1},{-0.1,0.1},{1.,1.}};
	IntervalVector x0(3,_x0);
	VarSet vars(f,z);
	IntervalVector box_unicity(3);
	IntervalVector box_existence(3);

	inflating_newton(f,vars,x0,box_existence,box_unicity);

	CPPUNIT_ASSERT(box_unicity.is_superset(box_existence));
	CPPUNIT_ASSERT(box_unicity.is_superset(box_existence));
	// the solution must contain the max (1.0) and the min
	// that is, the solution obtained at one corner of the parameter
	// box, like (-0.1,-0.1) which is ~ 7/5*sqrt(2)
	CPPUNIT_ASSERT(box_existence[2].contains(1.0));
	CPPUNIT_ASSERT(box_existence[2].is_superset(7.0/(5*sqrt(Interval(2.0)))));

}

void TestNewton::ctc_parameter01() {

	Variable x,y,z;
	Function f(x,y,z,Return(sqr(x)+sqr(y)-1+z,x-y-z));

	VarSet vars(f,x,y);

	CtcNewton newton(f,vars,POS_INFINITY);

	double _box[][2] = { {0,1},{0,1},{-0.01,0.01}};
	IntervalVector box(3,_box);

	newton.contract(box);

	Vector sol(2,(::sqrt(2)/2));

	CPPUNIT_ASSERT(box.subvector(0,1).contains(sol));
	CPPUNIT_ASSERT(box.min_diam()&gt;0.001);
	CPPUNIT_ASSERT(box[0].diam()&lt;=0.1);
	CPPUNIT_ASSERT(box[1].diam()&lt;=0.1);
}
} // end namespace ibex
</PRE>
</div>
  </div>
</body>
</html>
