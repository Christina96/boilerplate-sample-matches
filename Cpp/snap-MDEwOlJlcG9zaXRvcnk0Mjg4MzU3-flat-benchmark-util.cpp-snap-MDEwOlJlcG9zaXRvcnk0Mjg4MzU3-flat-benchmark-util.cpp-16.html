
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-benchmark-util.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &lt;Snap.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;omp.h&gt;
5  double Tick() {
6  #ifdef USE_OPENMP
7    return omp_get_wtime();
8  #else
9    struct rusage rusage;
10    getrusage(RUSAGE_SELF, &amp;rusage);
11    float cputime =
12    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
13    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
14    return cputime;
15  #endif
16  }
17  double GetCPUTimeUsage(double tick1, double tick2) {
18    return tick2 - tick1;
19  }
20  PTable Load(const Schema&amp; TblSchema, const int nCols, const TStr&amp; TsvFileName, TTableContext&amp; TableContext, const TFlt DefaultWeight = 0.0) {
21    TIntV RelColV;
22    for (int i = 0; i &lt; min(nCols, TblSchema.Len()); i++) {
23      RelColV.Add(i);
24    }
25    PTable PTbl = TTable::LoadSS(TblSchema, TsvFileName, TableContext, RelColV);
26    if (DefaultWeight != 0.0) {
27      TFltV WeightCol(PTbl-&gt;GetNumRows());
28      for (int i = 0; i &lt; PTbl-&gt;GetNumRows(); i++) {
29        WeightCol[i] = DefaultWeight;
30      }
31      PTbl-&gt;StoreFltCol(TStr(&quot;Weight&quot;), WeightCol);
32    }
33    return PTbl;
34  }
35  void LoadFlickrTables(const TStr&amp; PrefixPath, TTableContext&amp; Context,
36    TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, Schema&amp; NodeSchema, TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV, Schema&amp; EdgeSchema) {
37    Schema PhotoSchema;
38    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
39    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;UploadedDate&quot;, atInt));
40    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;LastUpdatedDate&quot;, atInt));
41    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Views&quot;, atInt));
42    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Media&quot;, atStr));
43    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;URL&quot;, atStr));
44    PTable PPhotoTbl = Load(PhotoSchema, 1, PrefixPath + TStr(&quot;photos.tsv&quot;), Context);
45    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PPhotoTbl, TStr(&quot;Photos&quot;)));
46    Schema UserSchema;
47    UserSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
48    UserSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;UserName&quot;, atStr));
49    UserSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;RealName&quot;, atStr));
50    UserSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Location&quot;, atStr));
51    PTable PUserTbl = Load(UserSchema, 1, PrefixPath + TStr(&quot;users.tsv&quot;), Context);
52    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PUserTbl, TStr(&quot;Users&quot;)));
53    Schema TagSchema;
54    TagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
55    TagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;MachineTag&quot;, atStr));
56    TagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Text&quot;, atStr));
57    TagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DisplayedText&quot;, atStr));
58    PTable PTagTbl = Load(TagSchema, 1, PrefixPath + TStr(&quot;tags.tsv&quot;), Context);
59    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PTagTbl, TStr(&quot;Tags&quot;)));
60    Schema CommentSchema;
61    CommentSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
62    CommentSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CreatedDate&quot;, atInt));
63    CommentSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;PermanentLink&quot;, atStr));
64    CommentSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Text&quot;, atStr));
65    PTable PCommentTbl = Load(CommentSchema, 1, PrefixPath + TStr(&quot;comments.tsv&quot;), Context);
66    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PCommentTbl, TStr(&quot;Comments&quot;)));
67    Schema LocationSchema;
68    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
69    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;WoeId&quot;, atInt));
70    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Accuracy&quot;, atInt));
71    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Context&quot;, atInt));
72    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Latitude&quot;, atFlt));
73    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Longitude&quot;, atFlt));
74    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NeighborhoodId&quot;, atStr));
75    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NeighborhoodWoeId&quot;, atStr));
76    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NeighborhoodName&quot;, atStr));
77    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;LocalityId&quot;, atStr));
78    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;LocalityWoeId&quot;, atStr));
79    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;LocalityName&quot;, atStr));
80    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountyId&quot;, atStr));
81    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountyWoeId&quot;, atStr));
82    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountyName&quot;, atStr));
83    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;RegionId&quot;, atStr));
84    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;RegionWoeId&quot;, atStr));
85    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;RegionName&quot;, atStr));
86    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountryId&quot;, atStr));
87    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountryWoeId&quot;, atStr));
88    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountryName&quot;, atStr));
89    PTable PLocationTbl = Load(LocationSchema, 1, PrefixPath + TStr(&quot;locations.tsv&quot;), Context);
90    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PLocationTbl, TStr(&quot;Locations&quot;)));
91    NodeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
92    Schema StdEdgeSchema = Schema();
93    StdEdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;SrcId&quot;, atStr));
94    StdEdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DstId&quot;, atStr));
95    PTable PPhotoOwnerTbl = Load(StdEdgeSchema, 2, PrefixPath + &quot;photo_owner_edges.tsv&quot;, Context, 1.0);
96    PTable PPhotoCommentTbl = Load(StdEdgeSchema, 2, PrefixPath + &quot;photo_comment_edges.tsv&quot;, Context, 0.2);
97    PTable PPhotoLocationTbl = Load(StdEdgeSchema, 2, PrefixPath + &quot;photo_location_edges.tsv&quot;, Context, 0.05);
98    PTable PCommentUserTbl = Load(StdEdgeSchema, 2, PrefixPath + &quot;comment_user_edges.tsv&quot;, Context, 0.2);
99    Schema PhotoTagSchema;
100    PhotoTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;SrcId&quot;, atStr));
101    PhotoTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DstId&quot;, atStr));
102    PhotoTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;UserId&quot;, atStr));
103    PTable PPhotoTagTbl = Load(PhotoTagSchema, 2, PrefixPath + &quot;photo_tag_edges.tsv&quot;, Context, 0.1);
104    Schema TaggerTagSchema;
105    TaggerTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;SrcId&quot;, atStr));
106    TaggerTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DstId&quot;, atStr));
107    TaggerTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;PhotoId&quot;, atStr));
108    PTable PTaggerTagTbl = Load(TaggerTagSchema, 2, PrefixPath + &quot;tagger_tag_edges.tsv&quot;, Context, 0.1);
109    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoOwnerTbl, &quot;Photos&quot;, &quot;Users&quot;, false));
110    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoOwnerTbl, &quot;Users&quot;, &quot;Photos&quot;, true));
111    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoCommentTbl, &quot;Photos&quot;, &quot;Comments&quot;, false));
112    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoLocationTbl, &quot;Photos&quot;, &quot;Locations&quot;, false));
113    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoLocationTbl, &quot;Locations&quot;, &quot;Photos&quot;, true));
114    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PCommentUserTbl, &quot;Comments&quot;, &quot;Users&quot;, false));
115    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoTagTbl, &quot;Photos&quot;, &quot;Tags&quot;, false));
116    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PTaggerTagTbl, &quot;Tags&quot;, &quot;Users&quot;, true));
117    EdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;SrcId&quot;, atStr));
118    EdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DstId&quot;, atStr));
119    EdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Weight&quot;, atFlt));
120  }
121  void LoadMixedTypeNodeList(const TStr&amp; PrefixPath, const TStr&amp; RandNodeFileName, THash&lt;TStr,TStrV&gt;&amp; NodeH) {
122    Schema RandNodeListSchema;
123    RandNodeListSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NTypeName&quot;, atStr));
124    RandNodeListSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
125    TTableContext Context;
126    PTable RandNTbl = Load(RandNodeListSchema, 2, PrefixPath+RandNodeFileName, Context);
127    for (int i = 0; i &lt; RandNTbl-&gt;GetNumRows(); i++) {
128      TStr NTypeStr = RandNTbl-&gt;GetStrVal(RandNodeListSchema.GetVal(0).GetVal1(), i);
129      TStr NStr = RandNTbl-&gt;GetStrVal(RandNodeListSchema.GetVal(1).GetVal1(), i);
130      if (!NodeH.IsKey(NTypeStr)) {
131        NodeH.AddDat(NTypeStr).Gen(RandNTbl-&gt;GetNumRows().Val, 0); 
132      }
133      NodeH.GetDat(NTypeStr).Add(NStr);
134    }
135  }
136  void LoadNodeList(const TStr&amp; PrefixPath, const TStr&amp; NodeFileName, TVec&lt;TPair&lt;TStr,TStr&gt; &gt;&amp; RandNV) {
137    Schema NodeListSchema;
138    NodeListSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NTypeName&quot;, atStr));
139    NodeListSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
140    TTableContext Context;
141    PTable RandNTbl = Load(NodeListSchema, 2, PrefixPath+NodeFileName, Context);
142    int n = RandNTbl-&gt;GetNumRows();
143    RandNV.Gen(n, n);
144    for (int i = 0; i &lt; n; i++) {
145      TStr NTypeStr = RandNTbl-&gt;GetStrVal(NodeListSchema.GetVal(0).GetVal1(), i);
146      TStr NStr = RandNTbl-&gt;GetStrVal(NodeListSchema.GetVal(1).GetVal1(), i);
147      TPair&lt;TStr,TStr&gt; Node(NTypeStr, NStr);
148      RandNV[i] = Node;
149    }
150  }
151  void CreateIdHashes(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, THash&lt;TStr,TStrH&gt;&amp; NStrH, TIntStrH&amp; NIdH) {
152    int ExpectedSz = 0;
153    for (TVec&lt;TPair&lt;PTable,TStr&gt; &gt;::TIter it = NodeTblV.BegI(); it &lt; NodeTblV.EndI(); it++) {
154      ExpectedSz += (*it).GetVal1()-&gt;GetNumRows();
155    }
156    NStrH.Gen(NodeTblV.Len());
157    NIdH.Gen(ExpectedSz);
158  }
159  template &lt;class PGraph&gt;
160  PGraph LoadGraph(const TVec&lt;PTable&gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV, TStrIntH&amp; NStrH, TIntStrH&amp; NIdH) {
161    PGraph Graph = PGraph::TObj::New();
162    TStr IdColName(&quot;Id&quot;);
163    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
164      PTable Table = NodeTblV[i];
165      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
166        TStr NStr = Table-&gt;GetStrVal(IdColName, CurrRowIdx);
167        int NId = Graph-&gt;AddNode();
168        NStrH.AddDat(NStr, NId);
169        NIdH.AddDat(NId, NStr);
170      }
171    }
172    TStr IdColName1(&quot;SrcId&quot;);
173    TStr IdColName2(&quot;DstId&quot;);
174    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
175      PTable Table;
176      TStr SrcETypeName;
177      TStr DstETypeName;
178      TBool IsDirectionReverse;
179      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
180      TStr SrcIdColName, DstIdColName;
181      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
182      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
183      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
184        TStr SrcNStr = Table-&gt;GetStrVal(SrcIdColName, CurrRowIdx);
185        IAssertR(NStrH.IsKey(SrcNStr), &quot;SrcId of edges must be a node Id&quot;);
186        TInt SrcNId = NStrH.GetDat(SrcNStr);
187        TStr DstNStr = Table-&gt;GetStrVal(DstIdColName, CurrRowIdx);
188        IAssertR(NStrH.IsKey(DstNStr), &quot;DstId of edges must be a node Id&quot;);
189        TInt DstNId = NStrH.GetDat(DstNStr);
190        Graph-&gt;AddEdge(SrcNId, DstNId);
191      }
192    }
193    return Graph;
194  }
195  template &lt;class PGraph&gt;
196  PGraph LoadGraphMNet(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV, THash&lt;TStr,TStrH&gt;&amp; NStrH, TIntStrH&amp; NIdH) {
197    PGraph Graph = PGraph::TObj::New();
198    TStr IdColName(&quot;Id&quot;);
199    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
200      Graph-&gt;AddNType(NodeTblV[i].GetVal2());
201      NStrH.AddDat(NodeTblV[i].GetVal2());
202    }
203    THash&lt;TPair&lt;TStr,TStr&gt;, TInt&gt; ETypeIdH;
204    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
205      TStr SrcETypeName = EdgeTblV[i].GetVal2();
206      TStr DstETypeName = EdgeTblV[i].GetVal3();
207      int Id = Graph-&gt;AddEType(TStr(&quot;Edge&quot;) + SrcETypeName.CStr() + DstETypeName.CStr(), SrcETypeName, DstETypeName);
208      TInt ETypeId(Id);
209      TPair&lt;TStr,TStr&gt; ETypeNamePair(SrcETypeName,DstETypeName);
210      ETypeIdH.AddDat(ETypeNamePair, ETypeId);
211    }
212    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
213      PTable Table = NodeTblV[i].GetVal1();
214      int NTypeId = Graph-&gt;GetNTypeId(NodeTblV[i].GetVal2());
215      TStrH* PNStrH = &amp;(NStrH.GetDat(NodeTblV[i].GetVal2()));
216      PNStrH-&gt;Gen(Table-&gt;GetNumRows());
217      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
218        TStr NStr = Table-&gt;GetStrVal(IdColName, CurrRowIdx);
219        int NId = Graph-&gt;AddNode(NTypeId);
220        PNStrH-&gt;AddDat(NStr, NId);
221        NIdH.AddDat(NId, NStr);
222      }
223    }
224    TStr IdColName1(&quot;SrcId&quot;);
225    TStr IdColName2(&quot;DstId&quot;);
226    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
227      PTable Table;
228      TStr SrcETypeName;
229      TStr DstETypeName;
230      TBool IsDirectionReverse;
231      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
232      TPair&lt;TStr,TStr&gt; ETypeNamePair(SrcETypeName,DstETypeName);
233      TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
234      TStr SrcIdColName, DstIdColName;
235      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
236      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
237      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
238        TStr SrcNStr = Table-&gt;GetStrVal(SrcIdColName, CurrRowIdx);
239        TInt SrcNId = NStrH.GetDat(SrcETypeName).GetDat(SrcNStr);
240        TStr DstNStr = Table-&gt;GetStrVal(DstIdColName, CurrRowIdx);
241        TInt DstNId = NStrH.GetDat(DstETypeName).GetDat(DstNStr);
242        Graph-&gt;AddEdge(SrcNId, DstNId, ETypeId);
243      }
244    }
245    return Graph;
246  }
247  void CreateNborList(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV,
248                        const TVec&lt;TPair&lt;TStr,TStr&gt; &gt;&amp; NodeV, TVec&lt;TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt; &gt;&amp; NbrVV) {
249    PSOut StdOut = TStdOut::New();
250    THash&lt;TPair&lt;TStr,TStr&gt;, TInt&gt; NOrderH;
251    int order = 0;
252    for (TVec&lt;TPair&lt;TStr,TStr&gt; &gt;::TIter iter = NodeV.BegI(); iter &lt; NodeV.EndI(); iter++) {
253      NOrderH.AddDat(*iter, order++);
254    }
255    NbrVV.Gen(order);
256    for (int i = 0; i &lt; order; i++) {
257      TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt; NbrV;
258      NbrVV[i] = NbrV;
259    }
260    TStr IdColName1(&quot;SrcId&quot;);
261    TStr IdColName2(&quot;DstId&quot;);
262    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
263      PTable Table;
264      TStr SrcETypeName;
265      TStr DstETypeName;
266      TBool IsDirectionReverse;
267      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
268      TStr SrcIdColName, DstIdColName;
269      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
270      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
271      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
272        TStr SrcNStr = Table-&gt;GetStrVal(SrcIdColName, CurrRowIdx);
273        TPair&lt;TStr,TStr&gt; Src(SrcETypeName, SrcNStr);
274        TInt SrcOrder = NOrderH.GetDat(Src);
275        TStr DstNStr = Table-&gt;GetStrVal(DstIdColName, CurrRowIdx);
276        TPair&lt;TStr,TStr&gt; Dst(DstETypeName, DstNStr);
277        TInt DstOrder = NOrderH.GetDat(Dst);
278        if (SrcOrder &lt; DstOrder) {
279          TTriple&lt;TStr,TStr,TBool&gt; Nbr(SrcETypeName, SrcNStr, false);
280          NbrVV[DstOrder.Val].Add(Nbr);
281        } else {
282          TTriple&lt;TStr,TStr,TBool&gt; Nbr(DstETypeName, DstNStr, true);
283          NbrVV[SrcOrder.Val].Add(Nbr);
284        }
285      }
286    }
287  }
288  template &lt;class PGraph&gt;
289  PGraph LoadGraphMNetRandom(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV,
290                              const TVec&lt;TPair&lt;TStr,TStr&gt; &gt;&amp; RandNV, const TVec&lt;TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt; &gt;&amp; RandNbrVV,
291                              THash&lt;TStr,TStrH&gt;&amp; NStrH, TIntStrH&amp; NIdH) {
292    PGraph Graph = PGraph::TObj::New();
293    TStr IdColName(&quot;Id&quot;);
294    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
295      Graph-&gt;AddNType(NodeTblV[i].GetVal2());
296      TStrH StrH;
297      NStrH.AddDat(NodeTblV[i].GetVal2(), StrH);
298    }
299    THash&lt;TPair&lt;TStr,TStr&gt;, TInt&gt; ETypeIdH;
300    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
301      TStr SrcETypeName = EdgeTblV[i].GetVal2();
302      TStr DstETypeName = EdgeTblV[i].GetVal3();
303      int Id = Graph-&gt;AddEType(TStr(&quot;Edge&quot;) + SrcETypeName.CStr() + DstETypeName.CStr(), SrcETypeName, DstETypeName);
304      TInt ETypeId(Id);
305      TPair&lt;TStr,TStr&gt; ETypeNamePair(SrcETypeName,DstETypeName);
306      ETypeIdH.AddDat(ETypeNamePair, ETypeId);
307    }
308    int order = 0;
309    for (TVec&lt;TPair&lt;TStr,TStr&gt; &gt;::TIter iter = RandNV.BegI(); iter &lt; RandNV.EndI(); iter++) {
310      int NId = Graph-&gt;AddNode((*iter).GetVal1());
311      NStrH.GetDat((*iter).GetVal1()).AddDat((*iter).GetVal2(), NId);
312      NIdH.AddDat(NId, (*iter).GetVal2());
313      const TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt;* Nbrs = &amp;(RandNbrVV[order++]);
314      for (TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt;::TIter iter2 = Nbrs-&gt;BegI(); iter2 &lt; Nbrs-&gt;EndI(); iter2++) {
315        TTriple&lt;TStr,TStr,TBool&gt;* Nbr = iter2;
316        if (Nbr-&gt;GetVal3()) {
317          TPair&lt;TStr,TStr&gt; ETypeNamePair((*iter).GetVal1(), Nbr-&gt;GetVal1());
318          TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
319          Graph-&gt;AddEdge(NId, NStrH.GetDat(Nbr-&gt;GetVal1()).GetDat(Nbr-&gt;GetVal2()), ETypeId);
320        } else {
321          TPair&lt;TStr,TStr&gt; ETypeNamePair(Nbr-&gt;GetVal1(), (*iter).GetVal1());
322          TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
323          Graph-&gt;AddEdge(NStrH.GetDat(Nbr-&gt;GetVal1()).GetDat(Nbr-&gt;GetVal2()), NId, ETypeId);
324        }
325      }
326    }
327    return Graph;
328  }
329  void BuildCombinedEdgeTable(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV, THash&lt;TStr,TStrH&gt;&amp; NStrH, TIntStrH&amp; NIdH, PTable CombinedEdgeTbl) {
330    TStr IdColName(&quot;Id&quot;);
331    TInt NId(0);
332    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
333      PTable Table = NodeTblV[i].GetVal1();
334      TStrH StrH(Table-&gt;GetNumRows());
335      NStrH.AddDat(NodeTblV[i].GetVal2(), StrH);
336      TStrH* PNStrH = &amp;(NStrH.GetDat(NodeTblV[i].GetVal2()));
337      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
338        TStr NStr = Table-&gt;GetStrVal(IdColName, CurrRowIdx);
339        PNStrH-&gt;AddDat(NStr, NId);
340        NIdH.AddDat(NId, NStr);
341        NId += 1;
342      }
343    }
344    TStr IdColName1(&quot;SrcId&quot;);
345    TStr IdColName2(&quot;DstId&quot;);
346    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
347      PTable Table;
348      TStr SrcETypeName;
<span onclick='openModal()' class='match'>349      TStr DstETypeName;
350      TBool IsDirectionReverse;
351      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
352      TStr SrcIdColName, DstIdColName;
</span>353      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
354      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
355      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
356        TStr SrcNStr = Table-&gt;GetStrVal(SrcIdColName, CurrRowIdx);
357        TInt SrcNId = NStrH.GetDat(SrcETypeName).GetDat(SrcNStr);
358        TStr DstNStr = Table-&gt;GetStrVal(DstIdColName, CurrRowIdx);
359        TInt DstNId = NStrH.GetDat(DstETypeName).GetDat(DstNStr);
360        TTableRow Row;
361        Row.AddInt(SrcNId);
362        Row.AddInt(DstNId);
363        CombinedEdgeTbl-&gt;AddRow(Row);
364      }
365    }
366  }
367  template &lt;class PGraph&gt;
368  void PageRankExp(const PGraph&amp; Graph, const int nExps, TIntFltH&amp; PageRankResults) {
369    for (int i = 0; i &lt; nExps; i++) {
370  #ifdef USE_OPENMP
371      TSnap::GetPageRankMNetMP(Graph, PageRankResults, 0.849999999999998, 0.0001, 10);
372  #else
373      TSnap::GetPageRank(Graph, PageRankResults, 0.849999999999998, 0.0001, 10);
374  #endif
375    }
376  }
377  template &lt;class PGraph&gt;
378  void BFSExp(const PGraph&amp; Graph, const TStrV&amp; RandNStrs, const TStrIntH&amp; NStrH,
379              const int nExps, TIntV&amp; BFSResults) {
380    for (int i = 0; i &lt; nExps; i++) {
381      TStr NStr = RandNStrs[i];
382      TInt NId = NStrH.GetDat(NStr);
383  #ifdef USE_OPENMP
384      TSnap::GetShortestDistancesMP2(Graph, NId.Val, true, false, BFSResults);
385  #else
386      TSnap::GetShortestDistances(Graph, NId.Val, true, false, BFSResults);
387  #endif
388    }
389  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-benchmark-util.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &lt;Snap.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;omp.h&gt;
5  double Tick() {
6  #ifdef USE_OPENMP
7    return omp_get_wtime();
8  #else
9    struct rusage rusage;
10    getrusage(RUSAGE_SELF, &amp;rusage);
11    float cputime =
12    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
13    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
14    return cputime;
15  #endif
16  }
17  double GetCPUTimeUsage(double tick1, double tick2) {
18    return tick2 - tick1;
19  }
20  PTable Load(const Schema&amp; TblSchema, const int nCols, const TStr&amp; TsvFileName, TTableContext&amp; TableContext, const TFlt DefaultWeight = 0.0) {
21    TIntV RelColV;
22    for (int i = 0; i &lt; min(nCols, TblSchema.Len()); i++) {
23      RelColV.Add(i);
24    }
25    PTable PTbl = TTable::LoadSS(TblSchema, TsvFileName, TableContext, RelColV);
26    if (DefaultWeight != 0.0) {
27      TFltV WeightCol(PTbl-&gt;GetNumRows());
28      for (int i = 0; i &lt; PTbl-&gt;GetNumRows(); i++) {
29        WeightCol[i] = DefaultWeight;
30      }
31      PTbl-&gt;StoreFltCol(TStr(&quot;Weight&quot;), WeightCol);
32    }
33    return PTbl;
34  }
35  void LoadFlickrTables(const TStr&amp; PrefixPath, TTableContext&amp; Context,
36    TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, Schema&amp; NodeSchema, TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV, Schema&amp; EdgeSchema) {
37    Schema PhotoSchema;
38    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
39    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;UploadedDate&quot;, atInt));
40    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;LastUpdatedDate&quot;, atInt));
41    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Views&quot;, atInt));
42    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Media&quot;, atStr));
43    PhotoSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;URL&quot;, atStr));
44    PTable PPhotoTbl = Load(PhotoSchema, 1, PrefixPath + TStr(&quot;photos.tsv&quot;), Context);
45    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PPhotoTbl, TStr(&quot;Photos&quot;)));
46    Schema UserSchema;
47    UserSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
48    UserSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;UserName&quot;, atStr));
49    UserSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;RealName&quot;, atStr));
50    UserSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Location&quot;, atStr));
51    PTable PUserTbl = Load(UserSchema, 1, PrefixPath + TStr(&quot;users.tsv&quot;), Context);
52    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PUserTbl, TStr(&quot;Users&quot;)));
53    Schema TagSchema;
54    TagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
55    TagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;MachineTag&quot;, atStr));
56    TagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Text&quot;, atStr));
57    TagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DisplayedText&quot;, atStr));
58    PTable PTagTbl = Load(TagSchema, 1, PrefixPath + TStr(&quot;tags.tsv&quot;), Context);
59    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PTagTbl, TStr(&quot;Tags&quot;)));
60    Schema CommentSchema;
61    CommentSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
62    CommentSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CreatedDate&quot;, atInt));
63    CommentSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;PermanentLink&quot;, atStr));
64    CommentSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Text&quot;, atStr));
65    PTable PCommentTbl = Load(CommentSchema, 1, PrefixPath + TStr(&quot;comments.tsv&quot;), Context);
66    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PCommentTbl, TStr(&quot;Comments&quot;)));
67    Schema LocationSchema;
68    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
69    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;WoeId&quot;, atInt));
70    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Accuracy&quot;, atInt));
71    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Context&quot;, atInt));
72    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Latitude&quot;, atFlt));
73    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Longitude&quot;, atFlt));
74    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NeighborhoodId&quot;, atStr));
75    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NeighborhoodWoeId&quot;, atStr));
76    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NeighborhoodName&quot;, atStr));
77    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;LocalityId&quot;, atStr));
78    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;LocalityWoeId&quot;, atStr));
79    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;LocalityName&quot;, atStr));
80    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountyId&quot;, atStr));
81    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountyWoeId&quot;, atStr));
82    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountyName&quot;, atStr));
83    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;RegionId&quot;, atStr));
84    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;RegionWoeId&quot;, atStr));
85    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;RegionName&quot;, atStr));
86    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountryId&quot;, atStr));
87    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountryWoeId&quot;, atStr));
88    LocationSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;CountryName&quot;, atStr));
89    PTable PLocationTbl = Load(LocationSchema, 1, PrefixPath + TStr(&quot;locations.tsv&quot;), Context);
90    NodeTblV.Add(TPair&lt;PTable,TStr&gt;(PLocationTbl, TStr(&quot;Locations&quot;)));
91    NodeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
92    Schema StdEdgeSchema = Schema();
93    StdEdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;SrcId&quot;, atStr));
94    StdEdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DstId&quot;, atStr));
95    PTable PPhotoOwnerTbl = Load(StdEdgeSchema, 2, PrefixPath + &quot;photo_owner_edges.tsv&quot;, Context, 1.0);
96    PTable PPhotoCommentTbl = Load(StdEdgeSchema, 2, PrefixPath + &quot;photo_comment_edges.tsv&quot;, Context, 0.2);
97    PTable PPhotoLocationTbl = Load(StdEdgeSchema, 2, PrefixPath + &quot;photo_location_edges.tsv&quot;, Context, 0.05);
98    PTable PCommentUserTbl = Load(StdEdgeSchema, 2, PrefixPath + &quot;comment_user_edges.tsv&quot;, Context, 0.2);
99    Schema PhotoTagSchema;
100    PhotoTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;SrcId&quot;, atStr));
101    PhotoTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DstId&quot;, atStr));
102    PhotoTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;UserId&quot;, atStr));
103    PTable PPhotoTagTbl = Load(PhotoTagSchema, 2, PrefixPath + &quot;photo_tag_edges.tsv&quot;, Context, 0.1);
104    Schema TaggerTagSchema;
105    TaggerTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;SrcId&quot;, atStr));
106    TaggerTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DstId&quot;, atStr));
107    TaggerTagSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;PhotoId&quot;, atStr));
108    PTable PTaggerTagTbl = Load(TaggerTagSchema, 2, PrefixPath + &quot;tagger_tag_edges.tsv&quot;, Context, 0.1);
109    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoOwnerTbl, &quot;Photos&quot;, &quot;Users&quot;, false));
110    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoOwnerTbl, &quot;Users&quot;, &quot;Photos&quot;, true));
111    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoCommentTbl, &quot;Photos&quot;, &quot;Comments&quot;, false));
112    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoLocationTbl, &quot;Photos&quot;, &quot;Locations&quot;, false));
113    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoLocationTbl, &quot;Locations&quot;, &quot;Photos&quot;, true));
114    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PCommentUserTbl, &quot;Comments&quot;, &quot;Users&quot;, false));
115    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PPhotoTagTbl, &quot;Photos&quot;, &quot;Tags&quot;, false));
116    EdgeTblV.Add(TQuad&lt;PTable,TStr,TStr,TBool&gt;(PTaggerTagTbl, &quot;Tags&quot;, &quot;Users&quot;, true));
117    EdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;SrcId&quot;, atStr));
118    EdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;DstId&quot;, atStr));
119    EdgeSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Weight&quot;, atFlt));
120  }
121  void LoadMixedTypeNodeList(const TStr&amp; PrefixPath, const TStr&amp; RandNodeFileName, THash&lt;TStr,TStrV&gt;&amp; NodeH) {
122    Schema RandNodeListSchema;
123    RandNodeListSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NTypeName&quot;, atStr));
124    RandNodeListSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
125    TTableContext Context;
126    PTable RandNTbl = Load(RandNodeListSchema, 2, PrefixPath+RandNodeFileName, Context);
127    for (int i = 0; i &lt; RandNTbl-&gt;GetNumRows(); i++) {
128      TStr NTypeStr = RandNTbl-&gt;GetStrVal(RandNodeListSchema.GetVal(0).GetVal1(), i);
129      TStr NStr = RandNTbl-&gt;GetStrVal(RandNodeListSchema.GetVal(1).GetVal1(), i);
130      if (!NodeH.IsKey(NTypeStr)) {
131        NodeH.AddDat(NTypeStr).Gen(RandNTbl-&gt;GetNumRows().Val, 0); 
132      }
133      NodeH.GetDat(NTypeStr).Add(NStr);
134    }
135  }
136  void LoadNodeList(const TStr&amp; PrefixPath, const TStr&amp; NodeFileName, TVec&lt;TPair&lt;TStr,TStr&gt; &gt;&amp; RandNV) {
137    Schema NodeListSchema;
138    NodeListSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;NTypeName&quot;, atStr));
139    NodeListSchema.Add(TPair&lt;TStr,TAttrType&gt;(&quot;Id&quot;, atStr));
140    TTableContext Context;
141    PTable RandNTbl = Load(NodeListSchema, 2, PrefixPath+NodeFileName, Context);
142    int n = RandNTbl-&gt;GetNumRows();
143    RandNV.Gen(n, n);
144    for (int i = 0; i &lt; n; i++) {
145      TStr NTypeStr = RandNTbl-&gt;GetStrVal(NodeListSchema.GetVal(0).GetVal1(), i);
146      TStr NStr = RandNTbl-&gt;GetStrVal(NodeListSchema.GetVal(1).GetVal1(), i);
147      TPair&lt;TStr,TStr&gt; Node(NTypeStr, NStr);
148      RandNV[i] = Node;
149    }
150  }
151  void CreateIdHashes(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, THash&lt;TStr,TStrH&gt;&amp; NStrH, TIntStrH&amp; NIdH) {
152    int ExpectedSz = 0;
153    for (TVec&lt;TPair&lt;PTable,TStr&gt; &gt;::TIter it = NodeTblV.BegI(); it &lt; NodeTblV.EndI(); it++) {
154      ExpectedSz += (*it).GetVal1()-&gt;GetNumRows();
155    }
156    NStrH.Gen(NodeTblV.Len());
157    NIdH.Gen(ExpectedSz);
158  }
159  template &lt;class PGraph&gt;
160  PGraph LoadGraph(const TVec&lt;PTable&gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV, TStrIntH&amp; NStrH, TIntStrH&amp; NIdH) {
161    PGraph Graph = PGraph::TObj::New();
162    TStr IdColName(&quot;Id&quot;);
163    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
164      PTable Table = NodeTblV[i];
165      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
166        TStr NStr = Table-&gt;GetStrVal(IdColName, CurrRowIdx);
167        int NId = Graph-&gt;AddNode();
168        NStrH.AddDat(NStr, NId);
169        NIdH.AddDat(NId, NStr);
170      }
171    }
172    TStr IdColName1(&quot;SrcId&quot;);
173    TStr IdColName2(&quot;DstId&quot;);
174    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
175      PTable Table;
176      TStr SrcETypeName;
<span onclick='openModal()' class='match'>177      TStr DstETypeName;
178      TBool IsDirectionReverse;
179      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
180      TStr SrcIdColName, DstIdColName;
</span>181      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
182      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
183      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
184        TStr SrcNStr = Table-&gt;GetStrVal(SrcIdColName, CurrRowIdx);
185        IAssertR(NStrH.IsKey(SrcNStr), &quot;SrcId of edges must be a node Id&quot;);
186        TInt SrcNId = NStrH.GetDat(SrcNStr);
187        TStr DstNStr = Table-&gt;GetStrVal(DstIdColName, CurrRowIdx);
188        IAssertR(NStrH.IsKey(DstNStr), &quot;DstId of edges must be a node Id&quot;);
189        TInt DstNId = NStrH.GetDat(DstNStr);
190        Graph-&gt;AddEdge(SrcNId, DstNId);
191      }
192    }
193    return Graph;
194  }
195  template &lt;class PGraph&gt;
196  PGraph LoadGraphMNet(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV, THash&lt;TStr,TStrH&gt;&amp; NStrH, TIntStrH&amp; NIdH) {
197    PGraph Graph = PGraph::TObj::New();
198    TStr IdColName(&quot;Id&quot;);
199    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
200      Graph-&gt;AddNType(NodeTblV[i].GetVal2());
201      NStrH.AddDat(NodeTblV[i].GetVal2());
202    }
203    THash&lt;TPair&lt;TStr,TStr&gt;, TInt&gt; ETypeIdH;
204    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
205      TStr SrcETypeName = EdgeTblV[i].GetVal2();
206      TStr DstETypeName = EdgeTblV[i].GetVal3();
207      int Id = Graph-&gt;AddEType(TStr(&quot;Edge&quot;) + SrcETypeName.CStr() + DstETypeName.CStr(), SrcETypeName, DstETypeName);
208      TInt ETypeId(Id);
209      TPair&lt;TStr,TStr&gt; ETypeNamePair(SrcETypeName,DstETypeName);
210      ETypeIdH.AddDat(ETypeNamePair, ETypeId);
211    }
212    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
213      PTable Table = NodeTblV[i].GetVal1();
214      int NTypeId = Graph-&gt;GetNTypeId(NodeTblV[i].GetVal2());
215      TStrH* PNStrH = &amp;(NStrH.GetDat(NodeTblV[i].GetVal2()));
216      PNStrH-&gt;Gen(Table-&gt;GetNumRows());
217      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
218        TStr NStr = Table-&gt;GetStrVal(IdColName, CurrRowIdx);
219        int NId = Graph-&gt;AddNode(NTypeId);
220        PNStrH-&gt;AddDat(NStr, NId);
221        NIdH.AddDat(NId, NStr);
222      }
223    }
224    TStr IdColName1(&quot;SrcId&quot;);
225    TStr IdColName2(&quot;DstId&quot;);
226    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
227      PTable Table;
228      TStr SrcETypeName;
229      TStr DstETypeName;
230      TBool IsDirectionReverse;
231      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
232      TPair&lt;TStr,TStr&gt; ETypeNamePair(SrcETypeName,DstETypeName);
233      TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
234      TStr SrcIdColName, DstIdColName;
235      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
236      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
237      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
238        TStr SrcNStr = Table-&gt;GetStrVal(SrcIdColName, CurrRowIdx);
239        TInt SrcNId = NStrH.GetDat(SrcETypeName).GetDat(SrcNStr);
240        TStr DstNStr = Table-&gt;GetStrVal(DstIdColName, CurrRowIdx);
241        TInt DstNId = NStrH.GetDat(DstETypeName).GetDat(DstNStr);
242        Graph-&gt;AddEdge(SrcNId, DstNId, ETypeId);
243      }
244    }
245    return Graph;
246  }
247  void CreateNborList(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV,
248                        const TVec&lt;TPair&lt;TStr,TStr&gt; &gt;&amp; NodeV, TVec&lt;TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt; &gt;&amp; NbrVV) {
249    PSOut StdOut = TStdOut::New();
250    THash&lt;TPair&lt;TStr,TStr&gt;, TInt&gt; NOrderH;
251    int order = 0;
252    for (TVec&lt;TPair&lt;TStr,TStr&gt; &gt;::TIter iter = NodeV.BegI(); iter &lt; NodeV.EndI(); iter++) {
253      NOrderH.AddDat(*iter, order++);
254    }
255    NbrVV.Gen(order);
256    for (int i = 0; i &lt; order; i++) {
257      TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt; NbrV;
258      NbrVV[i] = NbrV;
259    }
260    TStr IdColName1(&quot;SrcId&quot;);
261    TStr IdColName2(&quot;DstId&quot;);
262    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
263      PTable Table;
264      TStr SrcETypeName;
265      TStr DstETypeName;
266      TBool IsDirectionReverse;
267      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
268      TStr SrcIdColName, DstIdColName;
269      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
270      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
271      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
272        TStr SrcNStr = Table-&gt;GetStrVal(SrcIdColName, CurrRowIdx);
273        TPair&lt;TStr,TStr&gt; Src(SrcETypeName, SrcNStr);
274        TInt SrcOrder = NOrderH.GetDat(Src);
275        TStr DstNStr = Table-&gt;GetStrVal(DstIdColName, CurrRowIdx);
276        TPair&lt;TStr,TStr&gt; Dst(DstETypeName, DstNStr);
277        TInt DstOrder = NOrderH.GetDat(Dst);
278        if (SrcOrder &lt; DstOrder) {
279          TTriple&lt;TStr,TStr,TBool&gt; Nbr(SrcETypeName, SrcNStr, false);
280          NbrVV[DstOrder.Val].Add(Nbr);
281        } else {
282          TTriple&lt;TStr,TStr,TBool&gt; Nbr(DstETypeName, DstNStr, true);
283          NbrVV[SrcOrder.Val].Add(Nbr);
284        }
285      }
286    }
287  }
288  template &lt;class PGraph&gt;
289  PGraph LoadGraphMNetRandom(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV,
290                              const TVec&lt;TPair&lt;TStr,TStr&gt; &gt;&amp; RandNV, const TVec&lt;TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt; &gt;&amp; RandNbrVV,
291                              THash&lt;TStr,TStrH&gt;&amp; NStrH, TIntStrH&amp; NIdH) {
292    PGraph Graph = PGraph::TObj::New();
293    TStr IdColName(&quot;Id&quot;);
294    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
295      Graph-&gt;AddNType(NodeTblV[i].GetVal2());
296      TStrH StrH;
297      NStrH.AddDat(NodeTblV[i].GetVal2(), StrH);
298    }
299    THash&lt;TPair&lt;TStr,TStr&gt;, TInt&gt; ETypeIdH;
300    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
301      TStr SrcETypeName = EdgeTblV[i].GetVal2();
302      TStr DstETypeName = EdgeTblV[i].GetVal3();
303      int Id = Graph-&gt;AddEType(TStr(&quot;Edge&quot;) + SrcETypeName.CStr() + DstETypeName.CStr(), SrcETypeName, DstETypeName);
304      TInt ETypeId(Id);
305      TPair&lt;TStr,TStr&gt; ETypeNamePair(SrcETypeName,DstETypeName);
306      ETypeIdH.AddDat(ETypeNamePair, ETypeId);
307    }
308    int order = 0;
309    for (TVec&lt;TPair&lt;TStr,TStr&gt; &gt;::TIter iter = RandNV.BegI(); iter &lt; RandNV.EndI(); iter++) {
310      int NId = Graph-&gt;AddNode((*iter).GetVal1());
311      NStrH.GetDat((*iter).GetVal1()).AddDat((*iter).GetVal2(), NId);
312      NIdH.AddDat(NId, (*iter).GetVal2());
313      const TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt;* Nbrs = &amp;(RandNbrVV[order++]);
314      for (TVec&lt;TTriple&lt;TStr,TStr,TBool&gt; &gt;::TIter iter2 = Nbrs-&gt;BegI(); iter2 &lt; Nbrs-&gt;EndI(); iter2++) {
315        TTriple&lt;TStr,TStr,TBool&gt;* Nbr = iter2;
316        if (Nbr-&gt;GetVal3()) {
317          TPair&lt;TStr,TStr&gt; ETypeNamePair((*iter).GetVal1(), Nbr-&gt;GetVal1());
318          TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
319          Graph-&gt;AddEdge(NId, NStrH.GetDat(Nbr-&gt;GetVal1()).GetDat(Nbr-&gt;GetVal2()), ETypeId);
320        } else {
321          TPair&lt;TStr,TStr&gt; ETypeNamePair(Nbr-&gt;GetVal1(), (*iter).GetVal1());
322          TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
323          Graph-&gt;AddEdge(NStrH.GetDat(Nbr-&gt;GetVal1()).GetDat(Nbr-&gt;GetVal2()), NId, ETypeId);
324        }
325      }
326    }
327    return Graph;
328  }
329  void BuildCombinedEdgeTable(const TVec&lt;TPair&lt;PTable,TStr&gt; &gt;&amp; NodeTblV, const TVec&lt;TQuad&lt;PTable,TStr,TStr,TBool&gt; &gt;&amp; EdgeTblV, THash&lt;TStr,TStrH&gt;&amp; NStrH, TIntStrH&amp; NIdH, PTable CombinedEdgeTbl) {
330    TStr IdColName(&quot;Id&quot;);
331    TInt NId(0);
332    for (int i = 0; i &lt; NodeTblV.Len(); i++) {
333      PTable Table = NodeTblV[i].GetVal1();
334      TStrH StrH(Table-&gt;GetNumRows());
335      NStrH.AddDat(NodeTblV[i].GetVal2(), StrH);
336      TStrH* PNStrH = &amp;(NStrH.GetDat(NodeTblV[i].GetVal2()));
337      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
338        TStr NStr = Table-&gt;GetStrVal(IdColName, CurrRowIdx);
339        PNStrH-&gt;AddDat(NStr, NId);
340        NIdH.AddDat(NId, NStr);
341        NId += 1;
342      }
343    }
344    TStr IdColName1(&quot;SrcId&quot;);
345    TStr IdColName2(&quot;DstId&quot;);
346    for (int i = 0; i &lt; EdgeTblV.Len(); i++) {
347      PTable Table;
348      TStr SrcETypeName;
349      TStr DstETypeName;
350      TBool IsDirectionReverse;
351      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
352      TStr SrcIdColName, DstIdColName;
353      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
354      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
355      for (int CurrRowIdx = 0; CurrRowIdx &lt; Table-&gt;GetNumRows(); CurrRowIdx++) {
356        TStr SrcNStr = Table-&gt;GetStrVal(SrcIdColName, CurrRowIdx);
357        TInt SrcNId = NStrH.GetDat(SrcETypeName).GetDat(SrcNStr);
358        TStr DstNStr = Table-&gt;GetStrVal(DstIdColName, CurrRowIdx);
359        TInt DstNId = NStrH.GetDat(DstETypeName).GetDat(DstNStr);
360        TTableRow Row;
361        Row.AddInt(SrcNId);
362        Row.AddInt(DstNId);
363        CombinedEdgeTbl-&gt;AddRow(Row);
364      }
365    }
366  }
367  template &lt;class PGraph&gt;
368  void PageRankExp(const PGraph&amp; Graph, const int nExps, TIntFltH&amp; PageRankResults) {
369    for (int i = 0; i &lt; nExps; i++) {
370  #ifdef USE_OPENMP
371      TSnap::GetPageRankMNetMP(Graph, PageRankResults, 0.849999999999998, 0.0001, 10);
372  #else
373      TSnap::GetPageRank(Graph, PageRankResults, 0.849999999999998, 0.0001, 10);
374  #endif
375    }
376  }
377  template &lt;class PGraph&gt;
378  void BFSExp(const PGraph&amp; Graph, const TStrV&amp; RandNStrs, const TStrIntH&amp; NStrH,
379              const int nExps, TIntV&amp; BFSResults) {
380    for (int i = 0; i &lt; nExps; i++) {
381      TStr NStr = RandNStrs[i];
382      TInt NId = NStrH.GetDat(NStr);
383  #ifdef USE_OPENMP
384      TSnap::GetShortestDistancesMP2(Graph, NId.Val, true, false, BFSResults);
385  #else
386      TSnap::GetShortestDistances(Graph, NId.Val, true, false, BFSResults);
387  #endif
388    }
389  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-benchmark-util.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-benchmark-util.cpp</div>
                </div>
                <div class="column column_space"><pre><code>349      TStr DstETypeName;
350      TBool IsDirectionReverse;
351      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
352      TStr SrcIdColName, DstIdColName;
</pre></code></div>
                <div class="column column_space"><pre><code>177      TStr DstETypeName;
178      TBool IsDirectionReverse;
179      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
180      TStr SrcIdColName, DstIdColName;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    