<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for play.cpp & bag.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for play.cpp & bag.h
      </h3>
      <h1 align="center">
        2.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>play.cpp (6.030151%)<TH>bag.h (1.8720748%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match744-0.html#0',2,'match744-1.html#0',3)" NAME="0">(62-67)<TD><A HREF="javascript:ZweiFrames('match744-0.html#0',2,'match744-1.html#0',3)" NAME="0">(333-355)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>play.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2008, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of Willow Garage, Inc. nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
********************************************************************/

#include &quot;rosbag/player.h&quot;
#include &quot;boost/program_options.hpp&quot;

namespace po = boost::program_options;

rosbag::PlayerOptions parseOptions(int argc, char** argv) {
    rosbag::PlayerOptions opts;

    po::options_description desc(&quot;Allowed options&quot;);

    desc.add_options()
      (&quot;help,h&quot;, &quot;produce help message&quot;)
      (&quot;prefix,p&quot;, po::value&lt;std::string&gt;()-&gt;default_value(&quot;&quot;), &quot;prefixes all output topics in replay&quot;)
      (&quot;quiet,q&quot;, &quot;suppress console output&quot;)
      (&quot;immediate,i&quot;, &quot;play back all messages without waiting&quot;)
      (&quot;pause&quot;, &quot;start in paused mode&quot;)
      (&quot;queue&quot;, po::value&lt;int&gt;()-&gt;default_value(100), &quot;use an outgoing queue of size SIZE&quot;)
      (&quot;clock&quot;, &quot;publish the clock time&quot;)
      (&quot;hz&quot;, po::value&lt;float&gt;()-&gt;default_value(100.0f), &quot;use a frequency of HZ when publishing clock time&quot;)
      (&quot;delay,d&quot;, po::value&lt;float&gt;()-&gt;default_value(0.2f), &quot;sleep SEC seconds after every advertise call (to allow subscribers to connect)&quot;)
      (&quot;rate,r&quot;, po::value&lt;float&gt;()-&gt;default_value(1.0f), &quot;multiply the publish rate by FACTOR&quot;)
      (&quot;start,s&quot;, po::value&lt;float&gt;()-&gt;default_value(0.0f), &quot;start SEC seconds into the bag files&quot;)
      (&quot;duration,u&quot;, po::value&lt;float&gt;(), &quot;play only SEC seconds from the bag files&quot;)
      (&quot;skip-empty&quot;, po::value&lt;float&gt;(), &quot;skip regions in the bag with no messages for more than SEC seconds&quot;)
<A NAME="0"></A>      (&quot;loop,l&quot;, &quot;loop playback&quot;)
      (&quot;keep-alive,k&quot;, &quot;keep alive past end of bag (useful for publishing latched topics)&quot;)
      (&quot;try-future-version&quot;, &quot;still try to open a bag file, even if the version is not known to the player&quot;)
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match744-1.html#0',3,'match744-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>      (&quot;topics&quot;, po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), &quot;topics to play back&quot;)
      (&quot;pause-topics&quot;, po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), &quot;topics to pause playback on&quot;)
      (&quot;bags&quot;, po::value&lt; std::vector&lt;std::string&gt; &gt;(), &quot;bag files to play back from&quot;)
      (&quot;wait-for-subscribers&quot;, &quot;wait for at least one subscriber on each topic before publishing&quot;)
      (&quot;rate-control-topic&quot;, po::value&lt;std::string&gt;(), &quot;watch the given topic, and if the last publish was more than &lt;rate-control-max-delay&gt; ago, wait until the topic publishes again to continue playback&quot;)
      (&quot;rate-control-max-delay&quot;, po::value&lt;float&gt;()-&gt;default_value(1.0f), &quot;maximum time difference from &lt;rate-control-topic&gt; before pausing&quot;)</B></FONT>
      ;

    po::positional_options_description p;
    p.add(&quot;bags&quot;, -1);
    
    po::variables_map vm;
    
    try 
    {
      po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
    } catch (const boost::program_options::invalid_command_line_syntax&amp; e)
    {
      throw ros::Exception(e.what());
    } catch (const boost::program_options::unknown_option&amp; e)
    {
      throw ros::Exception(e.what());
    }

    if (vm.count(&quot;help&quot;)) {
      std::cout &lt;&lt; desc &lt;&lt; std::endl;
      exit(0);
    }

    if (vm.count(&quot;prefix&quot;))
      opts.prefix = vm[&quot;prefix&quot;].as&lt;std::string&gt;();
    if (vm.count(&quot;quiet&quot;))
      opts.quiet = true;
    if (vm.count(&quot;immediate&quot;))
      opts.at_once = true;
    if (vm.count(&quot;pause&quot;))
      opts.start_paused = true;
    if (vm.count(&quot;queue&quot;))
      opts.queue_size = vm[&quot;queue&quot;].as&lt;int&gt;();
    if (vm.count(&quot;hz&quot;))
      opts.bag_time_frequency = vm[&quot;hz&quot;].as&lt;float&gt;();
    if (vm.count(&quot;clock&quot;))
      opts.bag_time = true;
    if (vm.count(&quot;delay&quot;))
      opts.advertise_sleep = ros::WallDuration(vm[&quot;delay&quot;].as&lt;float&gt;());
    if (vm.count(&quot;rate&quot;))
      opts.time_scale = vm[&quot;rate&quot;].as&lt;float&gt;();
    if (vm.count(&quot;start&quot;))
    {
      opts.time = vm[&quot;start&quot;].as&lt;float&gt;();
      opts.has_time = true;
    }
    if (vm.count(&quot;duration&quot;))
    {
      opts.duration = vm[&quot;duration&quot;].as&lt;float&gt;();
      opts.has_duration = true;
    }
    if (vm.count(&quot;skip-empty&quot;))
      opts.skip_empty = ros::Duration(vm[&quot;skip-empty&quot;].as&lt;float&gt;());
    if (vm.count(&quot;loop&quot;))
      opts.loop = true;
    if (vm.count(&quot;keep-alive&quot;))
      opts.keep_alive = true;
    if (vm.count(&quot;wait-for-subscribers&quot;))
      opts.wait_for_subscribers = true;

    if (vm.count(&quot;topics&quot;))
    {
      std::vector&lt;std::string&gt; topics = vm[&quot;topics&quot;].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = topics.begin();
           i != topics.end();
           i++)
        opts.topics.push_back(*i);
    }

    if (vm.count(&quot;pause-topics&quot;))
    {
      std::vector&lt;std::string&gt; pause_topics = vm[&quot;pause-topics&quot;].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = pause_topics.begin();
           i != pause_topics.end();
           i++)
        opts.pause_topics.push_back(*i);
    }

    if (vm.count(&quot;rate-control-topic&quot;))
      opts.rate_control_topic = vm[&quot;rate-control-topic&quot;].as&lt;std::string&gt;();

    if (vm.count(&quot;rate-control-max-delay&quot;))
      opts.rate_control_max_delay = vm[&quot;rate-control-max-delay&quot;].as&lt;float&gt;();

    if (vm.count(&quot;bags&quot;))
    {
      std::vector&lt;std::string&gt; bags = vm[&quot;bags&quot;].as&lt; std::vector&lt;std::string&gt; &gt;();
      for (std::vector&lt;std::string&gt;::iterator i = bags.begin();
           i != bags.end();
           i++)
          opts.bags.push_back(*i);
    } else {
      if (vm.count(&quot;topics&quot;) || vm.count(&quot;pause-topics&quot;))
        throw ros::Exception(&quot;When using --topics or --pause-topics, --bags &quot;
          &quot;should be specified to list bags.&quot;);
      throw ros::Exception(&quot;You must specify at least one bag to play back.&quot;);
    }
            
    return opts;
}

int main(int argc, char** argv) {
    ros::init(argc, argv, &quot;play&quot;, ros::init_options::AnonymousName);

    // Parse the command-line options
    rosbag::PlayerOptions opts;
    try {
        opts = parseOptions(argc, argv);
    }
    catch (const ros::Exception&amp; ex) {
        ROS_ERROR(&quot;Error reading options: %s&quot;, ex.what());
        return 1;
    }

    rosbag::Player player(opts);

    try {
      player.publish();
    }
    catch (const std::runtime_error&amp; e) {
      ROS_FATAL(&quot;%s&quot;, e.what());
      return 1;
    }
    
    return 0;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bag.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2008, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of Willow Garage, Inc. nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

#ifndef ROSBAG_BAG_H
#define ROSBAG_BAG_H

#include &quot;rosbag/macros.h&quot;

#include &quot;rosbag/buffer.h&quot;
#include &quot;rosbag/chunked_file.h&quot;
#include &quot;rosbag/constants.h&quot;
#include &quot;rosbag/encryptor.h&quot;
#include &quot;rosbag/exceptions.h&quot;
#include &quot;rosbag/structures.h&quot;

#include &quot;ros/header.h&quot;
#include &quot;ros/time.h&quot;
#include &quot;ros/message_traits.h&quot;
#include &quot;ros/message_event.h&quot;
#include &quot;ros/serialization.h&quot;

//#include &quot;ros/subscription_callback_helper.h&quot;

#include &lt;ios&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;stdexcept&gt;

#include &lt;boost/config.hpp&gt;
#include &lt;boost/format.hpp&gt;
#include &lt;boost/iterator/iterator_facade.hpp&gt;

#include &lt;pluginlib/class_loader.hpp&gt;

#include &quot;console_bridge/console.h&quot;
#if defined logDebug
# undef logDebug
#endif
#if defined logInform
# undef logInform
#endif
#if defined logWarn
# undef logWarn
#endif
#if defined logError
# undef logError
#endif

namespace rosbag {

namespace bagmode
{
    //! The possible modes to open a bag in
    enum BagMode
    {
        Write   = 1,
        Read    = 2,
        Append  = 4
    };
}
typedef bagmode::BagMode BagMode;

class MessageInstance;
class View;
class Query;

class ROSBAG_STORAGE_DECL Bag
{
    friend class MessageInstance;
    friend class View;

public:
    Bag();

    //! Open a bag file
    /*!
     * \param filename The bag file to open
     * \param mode     The mode to use (either read, write or append)
     *
     * Can throw BagException
     */
    explicit Bag(std::string const&amp; filename, uint32_t mode = bagmode::Read);

    ~Bag();

#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES
    Bag(Bag&amp;&amp; other);

    Bag&amp; operator=(Bag&amp;&amp; other);
#endif // BOOST_NO_CXX11_RVALUE_REFERENCES

    //! Open a bag file.
    /*!
     * \param filename The bag file to open
     * \param mode     The mode to use (either read, write or append)
     *
     * Can throw BagException
     */
    void open(std::string const&amp; filename, uint32_t mode = bagmode::Read);

    //! Close the bag file
    void close();

    std::string     getFileName()     const;                      //!&lt; Get the filename of the bag
    BagMode         getMode()         const;                      //!&lt; Get the mode the bag is in
    uint32_t        getMajorVersion() const;                      //!&lt; Get the major-version of the open bag file
    uint32_t        getMinorVersion() const;                      //!&lt; Get the minor-version of the open bag file
    uint64_t        getSize()         const;                      //!&lt; Get the current size of the bag file (a lower bound)

    void            setCompression(CompressionType compression);  //!&lt; Set the compression method to use for writing chunks
    CompressionType getCompression() const;                       //!&lt; Get the compression method to use for writing chunks
    void            setChunkThreshold(uint32_t chunk_threshold);  //!&lt; Set the threshold for creating new chunks
    uint32_t        getChunkThreshold() const;                    //!&lt; Get the threshold for creating new chunks

    //! Set encryptor of the bag file
    /*!
     * \param plugin_name The name of the encryptor plugin
     * \param plugin_param The string parameter to be passed to the plugin initialization method
     *
     * Call this method to specify an encryptor for writing bag contents. This method need not be called when
     * reading or appending a bag file: The encryptor is read from the bag file header.
     */
    void setEncryptorPlugin(const std::string&amp; plugin_name, const std::string&amp; plugin_param = std::string());

    //! Write a message into the bag file
    /*!
     * \param topic The topic name
     * \param event The message event to be added
     *
     * Can throw BagIOException
     */
    template&lt;class T&gt;
    void write(std::string const&amp; topic, ros::MessageEvent&lt;T&gt; const&amp; event);

    //! Write a message into the bag file
    /*!
     * \param topic The topic name
     * \param time  Timestamp of the message
     * \param msg   The message to be added
     * \param connection_header  A connection header.
     *
     * Can throw BagIOException
     */
    template&lt;class T&gt;
    void write(std::string const&amp; topic, ros::Time const&amp; time, T const&amp; msg,
               boost::shared_ptr&lt;ros::M_string&gt; connection_header = boost::shared_ptr&lt;ros::M_string&gt;());

    //! Write a message into the bag file
    /*!
     * \param topic The topic name
     * \param time  Timestamp of the message
     * \param msg   The message to be added
     * \param connection_header  A connection header.
     *
     * Can throw BagIOException
     */
    template&lt;class T&gt;
    void write(std::string const&amp; topic, ros::Time const&amp; time, boost::shared_ptr&lt;T const&gt; const&amp; msg,
               boost::shared_ptr&lt;ros::M_string&gt; connection_header = boost::shared_ptr&lt;ros::M_string&gt;());

    //! Write a message into the bag file
    /*!
     * \param topic The topic name
     * \param time  Timestamp of the message
     * \param msg   The message to be added
     * \param connection_header  A connection header.
     *
     * Can throw BagIOException
     */
    template&lt;class T&gt;
    void write(std::string const&amp; topic, ros::Time const&amp; time, boost::shared_ptr&lt;T&gt; const&amp; msg,
               boost::shared_ptr&lt;ros::M_string&gt; connection_header = boost::shared_ptr&lt;ros::M_string&gt;());

    void swap(Bag&amp;);

    bool isOpen() const;

private:
    // disable copying
    Bag(const Bag&amp;);
    Bag&amp; operator=(const Bag&amp;);

    void init();

    // This helper function actually does the write with an arbitrary serializable message
    template&lt;class T&gt;
    void doWrite(std::string const&amp; topic, ros::Time const&amp; time, T const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; const&amp; connection_header);

    void openRead  (std::string const&amp; filename);
    void openWrite (std::string const&amp; filename);
    void openAppend(std::string const&amp; filename);

    void closeWrite();

    template&lt;class T&gt;
    boost::shared_ptr&lt;T&gt; instantiateBuffer(IndexEntry const&amp; index_entry) const;  //!&lt; deserializes the message held in record_buffer_

    void startWriting();
    void stopWriting();

    void startReadingVersion102();
    void startReadingVersion200();

    // Writing
    
    void writeVersion();
    void writeFileHeaderRecord();
    void writeConnectionRecord(ConnectionInfo const* connection_info, const bool encrypt);
    void appendConnectionRecordToBuffer(Buffer&amp; buf, ConnectionInfo const* connection_info);
    template&lt;class T&gt;
    void writeMessageDataRecord(uint32_t conn_id, ros::Time const&amp; time, T const&amp; msg);
    void writeIndexRecords();
    void writeConnectionRecords();
    void writeChunkInfoRecords();
    void startWritingChunk(ros::Time time);
    void writeChunkHeader(CompressionType compression, uint32_t compressed_size, uint32_t uncompressed_size);
    void stopWritingChunk();

    // Reading

    void readVersion();
    void readFileHeaderRecord();
    void readConnectionRecord();
    void readChunkHeader(ChunkHeader&amp; chunk_header) const;
    void readChunkInfoRecord();
    void readConnectionIndexRecord200();

    void readTopicIndexRecord102();
    void readMessageDefinitionRecord102();
    void readMessageDataRecord102(uint64_t offset, ros::Header&amp; header) const;

    ros::Header readMessageDataHeader(IndexEntry const&amp; index_entry);
    uint32_t    readMessageDataSize(IndexEntry const&amp; index_entry) const;

    template&lt;typename Stream&gt;
    void readMessageDataIntoStream(IndexEntry const&amp; index_entry, Stream&amp; stream) const;

    void     decompressChunk(uint64_t chunk_pos) const;
    void     decompressRawChunk(ChunkHeader const&amp; chunk_header) const;
    void     decompressBz2Chunk(ChunkHeader const&amp; chunk_header) const;
    void     decompressLz4Chunk(ChunkHeader const&amp; chunk_header) const;
    uint32_t getChunkOffset() const;

    // Record header I/O

    void writeHeader(ros::M_string const&amp; fields);
    void writeDataLength(uint32_t data_len);
    void appendHeaderToBuffer(Buffer&amp; buf, ros::M_string const&amp; fields);
    void appendDataLengthToBuffer(Buffer&amp; buf, uint32_t data_len);

    void readHeaderFromBuffer(Buffer&amp; buffer, uint32_t offset, ros::Header&amp; header, uint32_t&amp; data_size, uint32_t&amp; bytes_read) const;
    void readMessageDataHeaderFromBuffer(Buffer&amp; buffer, uint32_t offset, ros::Header&amp; header, uint32_t&amp; data_size, uint32_t&amp; bytes_read) const;
    bool readHeader(ros::Header&amp; header) const;
    bool readDataLength(uint32_t&amp; data_size) const;
    bool isOp(ros::M_string&amp; fields, uint8_t reqOp) const;

    // Header fields

    template&lt;typename T&gt;
    std::string toHeaderString(T const* field) const;

    std::string toHeaderString(ros::Time const* field) const;

    template&lt;typename T&gt;
    bool readField(ros::M_string const&amp; fields, std::string const&amp; field_name, bool required, T* data) const;

    bool readField(ros::M_string const&amp; fields, std::string const&amp; field_name, unsigned int min_len, unsigned int max_len, bool required, std::string&amp; data) const;
    bool readField(ros::M_string const&amp; fields, std::string const&amp; field_name, bool required, std::string&amp; data) const;

    bool readField(ros::M_string const&amp; fields, std::string const&amp; field_name, bool required, ros::Time&amp; data) const;

    ros::M_string::const_iterator checkField(ros::M_string const&amp; fields, std::string const&amp; field,
                                             unsigned int min_len, unsigned int max_len, bool required) const;

    // Low-level I/O

    void write(char const* s, std::streamsize n);
    void write(std::string const&amp; s);
    void read(char* b, std::streamsize n) const;
    void seek(uint64_t pos, int origin = std::ios_base::beg) const;

private:
    BagMode             mode_;
    mutable ChunkedFile file_;
    int                 version_;
    CompressionType     compression_;
    uint32_t            chunk_threshold_;
    uint32_t            bag_revision_;

    uint64_t file_size_;
    uint64_t file_header_pos_;
    uint64_t index_data_pos_;
    uint32_t connection_count_;
    uint32_t chunk_count_;
    
    // Current chunk
    bool      chunk_open_;
<A NAME="0"></A>    ChunkInfo curr_chunk_info_;
    uint64_t  curr_chunk_data_pos_;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match744-0.html#0',2,'match744-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    std::map&lt;std::string, uint32_t&gt;                topic_connection_ids_;
    std::map&lt;ros::M_string, uint32_t&gt;              header_connection_ids_;
    std::map&lt;uint32_t, ConnectionInfo*&gt;            connections_;

    std::vector&lt;ChunkInfo&gt;                         chunks_;

    std::map&lt;uint32_t, std::multiset&lt;IndexEntry&gt; &gt; connection_indexes_;
    std::map&lt;uint32_t, std::multiset&lt;IndexEntry&gt; &gt; curr_chunk_connection_indexes_;

    mutable Buffer   header_buffer_;           //!&lt; reusable buffer in which to assemble the record header before writing to file
    mutable Buffer   record_buffer_;           //!&lt; reusable buffer in which to assemble the record data before writing to file

    mutable Buffer   chunk_buffer_;            //!&lt; reusable buffer to read chunk into
    mutable Buffer   decompress_buffer_;       //!&lt; reusable buffer to decompress chunks into

    mutable Buffer   outgoing_chunk_buffer_;   //!&lt; reusable buffer to read chunk into

    mutable Buffer*  current_buffer_;

    mutable uint64_t decompressed_chunk_;      //!&lt; position of decompressed chunk

    // Encryptor plugin loader
    pluginlib::ClassLoader&lt;rosbag::EncryptorBase&gt; encryptor_loader_;</B></FONT>
    // Active encryptor
    boost::shared_ptr&lt;rosbag::EncryptorBase&gt; encryptor_;
};

} // namespace rosbag

#include &quot;rosbag/message_instance.h&quot;

namespace rosbag {

// Templated method definitions

template&lt;class T&gt;
void Bag::write(std::string const&amp; topic, ros::MessageEvent&lt;T&gt; const&amp; event) {
    doWrite(topic, event.getReceiptTime(), *event.getMessage(), event.getConnectionHeaderPtr());
}

template&lt;class T&gt;
void Bag::write(std::string const&amp; topic, ros::Time const&amp; time, T const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; connection_header) {
    doWrite(topic, time, msg, connection_header);
}

template&lt;class T&gt;
void Bag::write(std::string const&amp; topic, ros::Time const&amp; time, boost::shared_ptr&lt;T const&gt; const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; connection_header) {
    doWrite(topic, time, *msg, connection_header);
}

template&lt;class T&gt;
void Bag::write(std::string const&amp; topic, ros::Time const&amp; time, boost::shared_ptr&lt;T&gt; const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; connection_header) {
    doWrite(topic, time, *msg, connection_header);
}

template&lt;typename T&gt;
std::string Bag::toHeaderString(T const* field) const {
    return std::string((char*) field, sizeof(T));
}

template&lt;typename T&gt;
bool Bag::readField(ros::M_string const&amp; fields, std::string const&amp; field_name, bool required, T* data) const {
    ros::M_string::const_iterator i = checkField(fields, field_name, sizeof(T), sizeof(T), required);
    if (i == fields.end())
    	return false;
    memcpy(data, i-&gt;second.data(), sizeof(T));
    return true;
}

template&lt;typename Stream&gt;
void Bag::readMessageDataIntoStream(IndexEntry const&amp; index_entry, Stream&amp; stream) const {
    ros::Header header;
    uint32_t data_size;
    uint32_t bytes_read;
    switch (version_)
    {
    case 200:
    {
        decompressChunk(index_entry.chunk_pos);
        readMessageDataHeaderFromBuffer(*current_buffer_, index_entry.offset, header, data_size, bytes_read);
        if (data_size &gt; 0)
            memcpy(stream.advance(data_size), current_buffer_-&gt;getData() + index_entry.offset + bytes_read, data_size);
        break;
    }
    case 102:
    {
        readMessageDataRecord102(index_entry.chunk_pos, header);
        data_size = record_buffer_.getSize();
        if (data_size &gt; 0)
            memcpy(stream.advance(data_size), record_buffer_.getData(), data_size);
        break;
    }
    default:
        throw BagFormatException((boost::format(&quot;Unhandled version: %1%&quot;) % version_).str());
    }
}

template&lt;class T&gt;
boost::shared_ptr&lt;T&gt; Bag::instantiateBuffer(IndexEntry const&amp; index_entry) const {
    switch (version_)
    {
    case 200:
	{
        decompressChunk(index_entry.chunk_pos);

        // Read the message header
        ros::Header header;
        uint32_t data_size;
        uint32_t bytes_read;
        readMessageDataHeaderFromBuffer(*current_buffer_, index_entry.offset, header, data_size, bytes_read);

        // Read the connection id from the header
        uint32_t connection_id;
        readField(*header.getValues(), CONNECTION_FIELD_NAME, true, &amp;connection_id);

        std::map&lt;uint32_t, ConnectionInfo*&gt;::const_iterator connection_iter = connections_.find(connection_id);
        if (connection_iter == connections_.end())
            throw BagFormatException((boost::format(&quot;Unknown connection ID: %1%&quot;) % connection_id).str());
        ConnectionInfo* connection_info = connection_iter-&gt;second;

        boost::shared_ptr&lt;T&gt; p = boost::make_shared&lt;T&gt;();

        ros::serialization::PreDeserializeParams&lt;T&gt; predes_params;
        predes_params.message = p;
        predes_params.connection_header = connection_info-&gt;header;
        ros::serialization::PreDeserialize&lt;T&gt;::notify(predes_params);

        // Deserialize the message
        ros::serialization::IStream s(current_buffer_-&gt;getData() + index_entry.offset + bytes_read, data_size);
        ros::serialization::deserialize(s, *p);

        return p;
	}
    case 102:
	{
        // Read the message record
        ros::Header header;
        readMessageDataRecord102(index_entry.chunk_pos, header);

        ros::M_string&amp; fields = *header.getValues();

        // Read the connection id from the header
        std::string topic, latching(&quot;0&quot;), callerid;
        readField(fields, TOPIC_FIELD_NAME,    true,  topic);
        readField(fields, LATCHING_FIELD_NAME, false, latching);
        readField(fields, CALLERID_FIELD_NAME, false, callerid);

        std::map&lt;std::string, uint32_t&gt;::const_iterator topic_conn_id_iter = topic_connection_ids_.find(topic);
        if (topic_conn_id_iter == topic_connection_ids_.end())
            throw BagFormatException((boost::format(&quot;Unknown topic: %1%&quot;) % topic).str());
        uint32_t connection_id = topic_conn_id_iter-&gt;second;

        std::map&lt;uint32_t, ConnectionInfo*&gt;::const_iterator connection_iter = connections_.find(connection_id);
        if (connection_iter == connections_.end())
            throw BagFormatException((boost::format(&quot;Unknown connection ID: %1%&quot;) % connection_id).str());
        ConnectionInfo* connection_info = connection_iter-&gt;second;

        boost::shared_ptr&lt;T&gt; p = boost::make_shared&lt;T&gt;();

        // Create a new connection header, updated with the latching and callerid values
        boost::shared_ptr&lt;ros::M_string&gt; message_header(boost::make_shared&lt;ros::M_string&gt;());
        for (ros::M_string::const_iterator i = connection_info-&gt;header-&gt;begin(); i != connection_info-&gt;header-&gt;end(); i++)
            (*message_header)[i-&gt;first] = i-&gt;second;
        (*message_header)[&quot;latching&quot;] = latching;
        (*message_header)[&quot;callerid&quot;] = callerid;

        ros::serialization::PreDeserializeParams&lt;T&gt; predes_params;
        predes_params.message = p;
        predes_params.connection_header = message_header;
        ros::serialization::PreDeserialize&lt;T&gt;::notify(predes_params);

        // Deserialize the message
        ros::serialization::IStream s(record_buffer_.getData(), record_buffer_.getSize());
        ros::serialization::deserialize(s, *p);

        return p;
	}
    default:
        throw BagFormatException((boost::format(&quot;Unhandled version: %1%&quot;) % version_).str());
    }
}

template&lt;class T&gt;
void Bag::doWrite(std::string const&amp; topic, ros::Time const&amp; time, T const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; const&amp; connection_header) {

    if (time &lt; ros::TIME_MIN)
    {
        throw BagException(&quot;Tried to insert a message with time less than ros::TIME_MIN&quot;);
    }

    // Whenever we write we increment our revision
    bag_revision_++;

    // Get ID for connection header
    ConnectionInfo* connection_info = NULL;
    uint32_t conn_id = 0;
    if (!connection_header) {
        // No connection header: we'll manufacture one, and store by topic

        std::map&lt;std::string, uint32_t&gt;::iterator topic_connection_ids_iter = topic_connection_ids_.find(topic);
        if (topic_connection_ids_iter == topic_connection_ids_.end()) {
            conn_id = connections_.size();
            topic_connection_ids_[topic] = conn_id;
        }
        else {
            conn_id = topic_connection_ids_iter-&gt;second;
            connection_info = connections_[conn_id];
        }
    }
    else {
        // Store the connection info by the address of the connection header

        // Add the topic name to the connection header, so that when we later search by 
        // connection header, we can disambiguate connections that differ only by topic name (i.e.,
        // same callerid, same message type), #3755.  This modified connection header is only used
        // for our bookkeeping, and will not appear in the resulting .bag.
        ros::M_string connection_header_copy(*connection_header);
        connection_header_copy[&quot;topic&quot;] = topic;

        std::map&lt;ros::M_string, uint32_t&gt;::iterator header_connection_ids_iter = header_connection_ids_.find(connection_header_copy);
        if (header_connection_ids_iter == header_connection_ids_.end()) {
            conn_id = connections_.size();
            header_connection_ids_[connection_header_copy] = conn_id;
        }
        else {
            conn_id = header_connection_ids_iter-&gt;second;
            connection_info = connections_[conn_id];
        }
    }

    {
        // Seek to the end of the file (needed in case previous operation was a read)
        seek(0, std::ios::end);
        file_size_ = file_.getOffset();

        // Write the chunk header if we're starting a new chunk
        if (!chunk_open_)
            startWritingChunk(time);

        // Write connection info record, if necessary
        if (connection_info == NULL) {
            connection_info = new ConnectionInfo();
            connection_info-&gt;id       = conn_id;
            connection_info-&gt;topic    = topic;
            connection_info-&gt;datatype = std::string(ros::message_traits::datatype(msg));
            connection_info-&gt;md5sum   = std::string(ros::message_traits::md5sum(msg));
            connection_info-&gt;msg_def  = std::string(ros::message_traits::definition(msg));
            if (connection_header != NULL) {
                connection_info-&gt;header = connection_header;
            }
            else {
                connection_info-&gt;header = boost::make_shared&lt;ros::M_string&gt;();
                (*connection_info-&gt;header)[&quot;type&quot;]               = connection_info-&gt;datatype;
                (*connection_info-&gt;header)[&quot;md5sum&quot;]             = connection_info-&gt;md5sum;
                (*connection_info-&gt;header)[&quot;message_definition&quot;] = connection_info-&gt;msg_def;
            }
            connections_[conn_id] = connection_info;
            // No need to encrypt connection records in chunks
            writeConnectionRecord(connection_info, false);
            appendConnectionRecordToBuffer(outgoing_chunk_buffer_, connection_info);
        }

        // Add to topic indexes
        IndexEntry index_entry;
        index_entry.time      = time;
        index_entry.chunk_pos = curr_chunk_info_.pos;
        index_entry.offset    = getChunkOffset();

        std::multiset&lt;IndexEntry&gt;&amp; chunk_connection_index = curr_chunk_connection_indexes_[connection_info-&gt;id];
        chunk_connection_index.insert(chunk_connection_index.end(), index_entry);

        if (mode_ != BagMode::Write) {
          std::multiset&lt;IndexEntry&gt;&amp; connection_index = connection_indexes_[connection_info-&gt;id];
          connection_index.insert(connection_index.end(), index_entry);
        }

        // Increment the connection count
        curr_chunk_info_.connection_counts[connection_info-&gt;id]++;

        // Write the message data
        writeMessageDataRecord(conn_id, time, msg);

        // Check if we want to stop this chunk
        uint32_t chunk_size = getChunkOffset();
        CONSOLE_BRIDGE_logDebug(&quot;  curr_chunk_size=%d (threshold=%d)&quot;, chunk_size, chunk_threshold_);
        if (chunk_size &gt; chunk_threshold_) {
            // Empty the outgoing chunk
            stopWritingChunk();
            outgoing_chunk_buffer_.setSize(0);

            // We no longer have a valid curr_chunk_info
            curr_chunk_info_.pos = -1;
        }
    }
}

template&lt;class T&gt;
void Bag::writeMessageDataRecord(uint32_t conn_id, ros::Time const&amp; time, T const&amp; msg) {
    ros::M_string header;
    header[OP_FIELD_NAME]         = toHeaderString(&amp;OP_MSG_DATA);
    header[CONNECTION_FIELD_NAME] = toHeaderString(&amp;conn_id);
    header[TIME_FIELD_NAME]       = toHeaderString(&amp;time);

    // Assemble message in memory first, because we need to write its length
    uint32_t msg_ser_len = ros::serialization::serializationLength(msg);

    record_buffer_.setSize(msg_ser_len);
    
    ros::serialization::OStream s(record_buffer_.getData(), msg_ser_len);

    // todo: serialize into the outgoing_chunk_buffer &amp; remove record_buffer_
    ros::serialization::serialize(s, msg);

    // We do an extra seek here since writing our data record may
    // have indirectly moved our file-pointer if it was a
    // MessageInstance for our own bag
    seek(0, std::ios::end);
    file_size_ = file_.getOffset();

    CONSOLE_BRIDGE_logDebug(&quot;Writing MSG_DATA [%llu:%d]: conn=%d sec=%d nsec=%d data_len=%d&quot;,
              (unsigned long long) file_.getOffset(), getChunkOffset(), conn_id, time.sec, time.nsec, msg_ser_len);

    writeHeader(header);
    writeDataLength(msg_ser_len);
    write((char*) record_buffer_.getData(), msg_ser_len);
    
    // todo: use better abstraction than appendHeaderToBuffer
    appendHeaderToBuffer(outgoing_chunk_buffer_, header);
    appendDataLengthToBuffer(outgoing_chunk_buffer_, msg_ser_len);

    uint32_t offset = outgoing_chunk_buffer_.getSize();
    outgoing_chunk_buffer_.setSize(outgoing_chunk_buffer_.getSize() + msg_ser_len);
    memcpy(outgoing_chunk_buffer_.getData() + offset, record_buffer_.getData(), msg_ser_len);
    
    // Update the current chunk time range
    if (time &gt; curr_chunk_info_.end_time)
    	curr_chunk_info_.end_time = time;
    else if (time &lt; curr_chunk_info_.start_time)
        curr_chunk_info_.start_time = time;
}

inline void swap(Bag&amp; a, Bag&amp; b) {
    a.swap(b);
}

} // namespace rosbag

#endif
</PRE>
</div>
  </div>
</body>
</html>
