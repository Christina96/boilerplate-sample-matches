<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for play.cpp &amp; bag.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for play.cpp &amp; bag.h
      </h3>
<h1 align="center">
        2.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>play.cpp (6.030151%)<th>bag.h (1.8720748%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(62-67)<td><a href="#" name="0">(333-355)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>play.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "rosbag/player.h"
2 #include "boost/program_options.hpp"
3 namespace po = boost::program_options;
4 rosbag::PlayerOptions parseOptions(int argc, char** argv) {
5     rosbag::PlayerOptions opts;
6     po::options_description desc("Allowed options");
7     desc.add_options()
8       ("help,h", "produce help message")
9       ("prefix,p", po::value&lt;std::string&gt;()-&gt;default_value(""), "prefixes all output topics in replay")
10       ("quiet,q", "suppress console output")
11       ("immediate,i", "play back all messages without waiting")
12       ("pause", "start in paused mode")
13       ("queue", po::value&lt;int&gt;()-&gt;default_value(100), "use an outgoing queue of size SIZE")
14       ("clock", "publish the clock time")
15       ("hz", po::value&lt;float&gt;()-&gt;default_value(100.0f), "use a frequency of HZ when publishing clock time")
16       ("delay,d", po::value&lt;float&gt;()-&gt;default_value(0.2f), "sleep SEC seconds after every advertise call (to allow subscribers to connect)")
17       ("rate,r", po::value&lt;float&gt;()-&gt;default_value(1.0f), "multiply the publish rate by FACTOR")
18       ("start,s", po::value&lt;float&gt;()-&gt;default_value(0.0f), "start SEC seconds into the bag files")
19       ("duration,u", po::value&lt;float&gt;(), "play only SEC seconds from the bag files")
20       ("skip-empty", po::value&lt;float&gt;(), "skip regions in the bag with no messages for more than SEC seconds")
21 <a name="0"></a>      ("loop,l", "loop playback")
22       ("keep-alive,k", "keep alive past end of bag (useful for publishing latched topics)")
23       ("try-future-version", "still try to open a bag file, even if the version is not known to the player")
24 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      ("topics", po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), "topics to play back")
25       ("pause-topics", po::value&lt; std::vector&lt;std::string&gt; &gt;()-&gt;multitoken(), "topics to pause playback on")
26       ("bags", po::value&lt; std::vector&lt;std::string&gt; &gt;(), "bag files to play back from")
27       ("wait-for-subscribers", "wait for at least one subscriber on each topic before publishing")
28       ("rate-control-topic", po::value&lt;std::string&gt;(), "watch the given topic, and if the last publish was more than &lt;rate-control-max-delay&gt; ago, wait until the topic publishes again to continue playback")
29       ("rate-control-max-delay", po::value&lt;float&gt;()-&gt;default_value(1.0f), "maximum time difference from &lt;rate-control-topic&gt; before pausing")</b></font>
30       ;
31     po::positional_options_description p;
32     p.add("bags", -1);
33     po::variables_map vm;
34     try 
35     {
36       po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
37     } catch (const boost::program_options::invalid_command_line_syntax&amp; e)
38     {
39       throw ros::Exception(e.what());
40     } catch (const boost::program_options::unknown_option&amp; e)
41     {
42       throw ros::Exception(e.what());
43     }
44     if (vm.count("help")) {
45       std::cout &lt;&lt; desc &lt;&lt; std::endl;
46       exit(0);
47     }
48     if (vm.count("prefix"))
49       opts.prefix = vm["prefix"].as&lt;std::string&gt;();
50     if (vm.count("quiet"))
51       opts.quiet = true;
52     if (vm.count("immediate"))
53       opts.at_once = true;
54     if (vm.count("pause"))
55       opts.start_paused = true;
56     if (vm.count("queue"))
57       opts.queue_size = vm["queue"].as&lt;int&gt;();
58     if (vm.count("hz"))
59       opts.bag_time_frequency = vm["hz"].as&lt;float&gt;();
60     if (vm.count("clock"))
61       opts.bag_time = true;
62     if (vm.count("delay"))
63       opts.advertise_sleep = ros::WallDuration(vm["delay"].as&lt;float&gt;());
64     if (vm.count("rate"))
65       opts.time_scale = vm["rate"].as&lt;float&gt;();
66     if (vm.count("start"))
67     {
68       opts.time = vm["start"].as&lt;float&gt;();
69       opts.has_time = true;
70     }
71     if (vm.count("duration"))
72     {
73       opts.duration = vm["duration"].as&lt;float&gt;();
74       opts.has_duration = true;
75     }
76     if (vm.count("skip-empty"))
77       opts.skip_empty = ros::Duration(vm["skip-empty"].as&lt;float&gt;());
78     if (vm.count("loop"))
79       opts.loop = true;
80     if (vm.count("keep-alive"))
81       opts.keep_alive = true;
82     if (vm.count("wait-for-subscribers"))
83       opts.wait_for_subscribers = true;
84     if (vm.count("topics"))
85     {
86       std::vector&lt;std::string&gt; topics = vm["topics"].as&lt; std::vector&lt;std::string&gt; &gt;();
87       for (std::vector&lt;std::string&gt;::iterator i = topics.begin();
88            i != topics.end();
89            i++)
90         opts.topics.push_back(*i);
91     }
92     if (vm.count("pause-topics"))
93     {
94       std::vector&lt;std::string&gt; pause_topics = vm["pause-topics"].as&lt; std::vector&lt;std::string&gt; &gt;();
95       for (std::vector&lt;std::string&gt;::iterator i = pause_topics.begin();
96            i != pause_topics.end();
97            i++)
98         opts.pause_topics.push_back(*i);
99     }
100     if (vm.count("rate-control-topic"))
101       opts.rate_control_topic = vm["rate-control-topic"].as&lt;std::string&gt;();
102     if (vm.count("rate-control-max-delay"))
103       opts.rate_control_max_delay = vm["rate-control-max-delay"].as&lt;float&gt;();
104     if (vm.count("bags"))
105     {
106       std::vector&lt;std::string&gt; bags = vm["bags"].as&lt; std::vector&lt;std::string&gt; &gt;();
107       for (std::vector&lt;std::string&gt;::iterator i = bags.begin();
108            i != bags.end();
109            i++)
110           opts.bags.push_back(*i);
111     } else {
112       if (vm.count("topics") || vm.count("pause-topics"))
113         throw ros::Exception("When using --topics or --pause-topics, --bags "
114           "should be specified to list bags.");
115       throw ros::Exception("You must specify at least one bag to play back.");
116     }
117     return opts;
118 }
119 int main(int argc, char** argv) {
120     ros::init(argc, argv, "play", ros::init_options::AnonymousName);
121     rosbag::PlayerOptions opts;
122     try {
123         opts = parseOptions(argc, argv);
124     }
125     catch (const ros::Exception&amp; ex) {
126         ROS_ERROR("Error reading options: %s", ex.what());
127         return 1;
128     }
129     rosbag::Player player(opts);
130     try {
131       player.publish();
132     }
133     catch (const std::runtime_error&amp; e) {
134       ROS_FATAL("%s", e.what());
135       return 1;
136     }
137     return 0;
138 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bag.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef ROSBAG_BAG_H
2 #define ROSBAG_BAG_H
3 #include "rosbag/macros.h"
4 #include "rosbag/buffer.h"
5 #include "rosbag/chunked_file.h"
6 #include "rosbag/constants.h"
7 #include "rosbag/encryptor.h"
8 #include "rosbag/exceptions.h"
9 #include "rosbag/structures.h"
10 #include "ros/header.h"
11 #include "ros/time.h"
12 #include "ros/message_traits.h"
13 #include "ros/message_event.h"
14 #include "ros/serialization.h"
15 #include &lt;ios&gt;
16 #include &lt;map&gt;
17 #include &lt;queue&gt;
18 #include &lt;set&gt;
19 #include &lt;stdexcept&gt;
20 #include &lt;boost/config.hpp&gt;
21 #include &lt;boost/format.hpp&gt;
22 #include &lt;boost/iterator/iterator_facade.hpp&gt;
23 #include &lt;pluginlib/class_loader.hpp&gt;
24 #include "console_bridge/console.h"
25 #if defined logDebug
26 # undef logDebug
27 #endif
28 #if defined logInform
29 # undef logInform
30 #endif
31 #if defined logWarn
32 # undef logWarn
33 #endif
34 #if defined logError
35 # undef logError
36 #endif
37 namespace rosbag {
38 namespace bagmode
39 {
40     enum BagMode
41     {
42         Write   = 1,
43         Read    = 2,
44         Append  = 4
45     };
46 }
47 typedef bagmode::BagMode BagMode;
48 class MessageInstance;
49 class View;
50 class Query;
51 class ROSBAG_STORAGE_DECL Bag
52 {
53     friend class MessageInstance;
54     friend class View;
55 public:
56     Bag();
57     explicit Bag(std::string const&amp; filename, uint32_t mode = bagmode::Read);
58     ~Bag();
59 #ifndef BOOST_NO_CXX11_RVALUE_REFERENCES
60     Bag(Bag&amp;&amp; other);
61     Bag&amp; operator=(Bag&amp;&amp; other);
62 #endif 
63     void open(std::string const&amp; filename, uint32_t mode = bagmode::Read);
64     void close();
65     std::string     getFileName()     const;                      //!&lt; Get the filename of the bag
66     BagMode         getMode()         const;                      //!&lt; Get the mode the bag is in
67     uint32_t        getMajorVersion() const;                      //!&lt; Get the major-version of the open bag file
68     uint32_t        getMinorVersion() const;                      //!&lt; Get the minor-version of the open bag file
69     uint64_t        getSize()         const;                      //!&lt; Get the current size of the bag file (a lower bound)
70     void            setCompression(CompressionType compression);  //!&lt; Set the compression method to use for writing chunks
71     CompressionType getCompression() const;                       //!&lt; Get the compression method to use for writing chunks
72     void            setChunkThreshold(uint32_t chunk_threshold);  //!&lt; Set the threshold for creating new chunks
73     uint32_t        getChunkThreshold() const;                    //!&lt; Get the threshold for creating new chunks
74     void setEncryptorPlugin(const std::string&amp; plugin_name, const std::string&amp; plugin_param = std::string());
75     template&lt;class T&gt;
76     void write(std::string const&amp; topic, ros::MessageEvent&lt;T&gt; const&amp; event);
77     template&lt;class T&gt;
78     void write(std::string const&amp; topic, ros::Time const&amp; time, T const&amp; msg,
79                boost::shared_ptr&lt;ros::M_string&gt; connection_header = boost::shared_ptr&lt;ros::M_string&gt;());
80     template&lt;class T&gt;
81     void write(std::string const&amp; topic, ros::Time const&amp; time, boost::shared_ptr&lt;T const&gt; const&amp; msg,
82                boost::shared_ptr&lt;ros::M_string&gt; connection_header = boost::shared_ptr&lt;ros::M_string&gt;());
83     template&lt;class T&gt;
84     void write(std::string const&amp; topic, ros::Time const&amp; time, boost::shared_ptr&lt;T&gt; const&amp; msg,
85                boost::shared_ptr&lt;ros::M_string&gt; connection_header = boost::shared_ptr&lt;ros::M_string&gt;());
86     void swap(Bag&amp;);
87     bool isOpen() const;
88 private:
89     Bag(const Bag&amp;);
90     Bag&amp; operator=(const Bag&amp;);
91     void init();
92     template&lt;class T&gt;
93     void doWrite(std::string const&amp; topic, ros::Time const&amp; time, T const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; const&amp; connection_header);
94     void openRead  (std::string const&amp; filename);
95     void openWrite (std::string const&amp; filename);
96     void openAppend(std::string const&amp; filename);
97     void closeWrite();
98     template&lt;class T&gt;
99     boost::shared_ptr&lt;T&gt; instantiateBuffer(IndexEntry const&amp; index_entry) const;  //!&lt; deserializes the message held in record_buffer_
100     void startWriting();
101     void stopWriting();
102     void startReadingVersion102();
103     void startReadingVersion200();
104     void writeVersion();
105     void writeFileHeaderRecord();
106     void writeConnectionRecord(ConnectionInfo const* connection_info, const bool encrypt);
107     void appendConnectionRecordToBuffer(Buffer&amp; buf, ConnectionInfo const* connection_info);
108     template&lt;class T&gt;
109     void writeMessageDataRecord(uint32_t conn_id, ros::Time const&amp; time, T const&amp; msg);
110     void writeIndexRecords();
111     void writeConnectionRecords();
112     void writeChunkInfoRecords();
113     void startWritingChunk(ros::Time time);
114     void writeChunkHeader(CompressionType compression, uint32_t compressed_size, uint32_t uncompressed_size);
115     void stopWritingChunk();
116     void readVersion();
117     void readFileHeaderRecord();
118     void readConnectionRecord();
119     void readChunkHeader(ChunkHeader&amp; chunk_header) const;
120     void readChunkInfoRecord();
121     void readConnectionIndexRecord200();
122     void readTopicIndexRecord102();
123     void readMessageDefinitionRecord102();
124     void readMessageDataRecord102(uint64_t offset, ros::Header&amp; header) const;
125     ros::Header readMessageDataHeader(IndexEntry const&amp; index_entry);
126     uint32_t    readMessageDataSize(IndexEntry const&amp; index_entry) const;
127     template&lt;typename Stream&gt;
128     void readMessageDataIntoStream(IndexEntry const&amp; index_entry, Stream&amp; stream) const;
129     void     decompressChunk(uint64_t chunk_pos) const;
130     void     decompressRawChunk(ChunkHeader const&amp; chunk_header) const;
131     void     decompressBz2Chunk(ChunkHeader const&amp; chunk_header) const;
132     void     decompressLz4Chunk(ChunkHeader const&amp; chunk_header) const;
133     uint32_t getChunkOffset() const;
134     void writeHeader(ros::M_string const&amp; fields);
135     void writeDataLength(uint32_t data_len);
136     void appendHeaderToBuffer(Buffer&amp; buf, ros::M_string const&amp; fields);
137     void appendDataLengthToBuffer(Buffer&amp; buf, uint32_t data_len);
138     void readHeaderFromBuffer(Buffer&amp; buffer, uint32_t offset, ros::Header&amp; header, uint32_t&amp; data_size, uint32_t&amp; bytes_read) const;
139     void readMessageDataHeaderFromBuffer(Buffer&amp; buffer, uint32_t offset, ros::Header&amp; header, uint32_t&amp; data_size, uint32_t&amp; bytes_read) const;
140     bool readHeader(ros::Header&amp; header) const;
141     bool readDataLength(uint32_t&amp; data_size) const;
142     bool isOp(ros::M_string&amp; fields, uint8_t reqOp) const;
143     template&lt;typename T&gt;
144     std::string toHeaderString(T const* field) const;
145     std::string toHeaderString(ros::Time const* field) const;
146     template&lt;typename T&gt;
147     bool readField(ros::M_string const&amp; fields, std::string const&amp; field_name, bool required, T* data) const;
148     bool readField(ros::M_string const&amp; fields, std::string const&amp; field_name, unsigned int min_len, unsigned int max_len, bool required, std::string&amp; data) const;
149     bool readField(ros::M_string const&amp; fields, std::string const&amp; field_name, bool required, std::string&amp; data) const;
150     bool readField(ros::M_string const&amp; fields, std::string const&amp; field_name, bool required, ros::Time&amp; data) const;
151     ros::M_string::const_iterator checkField(ros::M_string const&amp; fields, std::string const&amp; field,
152                                              unsigned int min_len, unsigned int max_len, bool required) const;
153     void write(char const* s, std::streamsize n);
154     void write(std::string const&amp; s);
155     void read(char* b, std::streamsize n) const;
156     void seek(uint64_t pos, int origin = std::ios_base::beg) const;
157 private:
158     BagMode             mode_;
159     mutable ChunkedFile file_;
160     int                 version_;
161     CompressionType     compression_;
162     uint32_t            chunk_threshold_;
163     uint32_t            bag_revision_;
164     uint64_t file_size_;
165     uint64_t file_header_pos_;
166     uint64_t index_data_pos_;
167     uint32_t connection_count_;
168     uint32_t chunk_count_;
169     bool      chunk_open_;
170 <a name="0"></a>    ChunkInfo curr_chunk_info_;
171     uint64_t  curr_chunk_data_pos_;
172 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    std::map&lt;std::string, uint32_t&gt;                topic_connection_ids_;
173     std::map&lt;ros::M_string, uint32_t&gt;              header_connection_ids_;
174     std::map&lt;uint32_t, ConnectionInfo*&gt;            connections_;
175     std::vector&lt;ChunkInfo&gt;                         chunks_;
176     std::map&lt;uint32_t, std::multiset&lt;IndexEntry&gt; &gt; connection_indexes_;
177     std::map&lt;uint32_t, std::multiset&lt;IndexEntry&gt; &gt; curr_chunk_connection_indexes_;
178     mutable Buffer   header_buffer_;           //!&lt; reusable buffer in which to assemble the record header before writing to file
179     mutable Buffer   record_buffer_;           //!&lt; reusable buffer in which to assemble the record data before writing to file
180     mutable Buffer   chunk_buffer_;            //!&lt; reusable buffer to read chunk into
181     mutable Buffer   decompress_buffer_;       //!&lt; reusable buffer to decompress chunks into
182     mutable Buffer   outgoing_chunk_buffer_;   //!&lt; reusable buffer to read chunk into
183     mutable Buffer*  current_buffer_;
184     mutable uint64_t decompressed_chunk_;      //!&lt; position of decompressed chunk
185     pluginlib::ClassLoader&lt;rosbag::EncryptorBase&gt; encryptor_loader_;</b></font>
186     boost::shared_ptr&lt;rosbag::EncryptorBase&gt; encryptor_;
187 };
188 } 
189 #include "rosbag/message_instance.h"
190 namespace rosbag {
191 template&lt;class T&gt;
192 void Bag::write(std::string const&amp; topic, ros::MessageEvent&lt;T&gt; const&amp; event) {
193     doWrite(topic, event.getReceiptTime(), *event.getMessage(), event.getConnectionHeaderPtr());
194 }
195 template&lt;class T&gt;
196 void Bag::write(std::string const&amp; topic, ros::Time const&amp; time, T const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; connection_header) {
197     doWrite(topic, time, msg, connection_header);
198 }
199 template&lt;class T&gt;
200 void Bag::write(std::string const&amp; topic, ros::Time const&amp; time, boost::shared_ptr&lt;T const&gt; const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; connection_header) {
201     doWrite(topic, time, *msg, connection_header);
202 }
203 template&lt;class T&gt;
204 void Bag::write(std::string const&amp; topic, ros::Time const&amp; time, boost::shared_ptr&lt;T&gt; const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; connection_header) {
205     doWrite(topic, time, *msg, connection_header);
206 }
207 template&lt;typename T&gt;
208 std::string Bag::toHeaderString(T const* field) const {
209     return std::string((char*) field, sizeof(T));
210 }
211 template&lt;typename T&gt;
212 bool Bag::readField(ros::M_string const&amp; fields, std::string const&amp; field_name, bool required, T* data) const {
213     ros::M_string::const_iterator i = checkField(fields, field_name, sizeof(T), sizeof(T), required);
214     if (i == fields.end())
215     	return false;
216     memcpy(data, i-&gt;second.data(), sizeof(T));
217     return true;
218 }
219 template&lt;typename Stream&gt;
220 void Bag::readMessageDataIntoStream(IndexEntry const&amp; index_entry, Stream&amp; stream) const {
221     ros::Header header;
222     uint32_t data_size;
223     uint32_t bytes_read;
224     switch (version_)
225     {
226     case 200:
227     {
228         decompressChunk(index_entry.chunk_pos);
229         readMessageDataHeaderFromBuffer(*current_buffer_, index_entry.offset, header, data_size, bytes_read);
230         if (data_size &gt; 0)
231             memcpy(stream.advance(data_size), current_buffer_-&gt;getData() + index_entry.offset + bytes_read, data_size);
232         break;
233     }
234     case 102:
235     {
236         readMessageDataRecord102(index_entry.chunk_pos, header);
237         data_size = record_buffer_.getSize();
238         if (data_size &gt; 0)
239             memcpy(stream.advance(data_size), record_buffer_.getData(), data_size);
240         break;
241     }
242     default:
243         throw BagFormatException((boost::format("Unhandled version: %1%") % version_).str());
244     }
245 }
246 template&lt;class T&gt;
247 boost::shared_ptr&lt;T&gt; Bag::instantiateBuffer(IndexEntry const&amp; index_entry) const {
248     switch (version_)
249     {
250     case 200:
251 	{
252         decompressChunk(index_entry.chunk_pos);
253         ros::Header header;
254         uint32_t data_size;
255         uint32_t bytes_read;
256         readMessageDataHeaderFromBuffer(*current_buffer_, index_entry.offset, header, data_size, bytes_read);
257         uint32_t connection_id;
258         readField(*header.getValues(), CONNECTION_FIELD_NAME, true, &amp;connection_id);
259         std::map&lt;uint32_t, ConnectionInfo*&gt;::const_iterator connection_iter = connections_.find(connection_id);
260         if (connection_iter == connections_.end())
261             throw BagFormatException((boost::format("Unknown connection ID: %1%") % connection_id).str());
262         ConnectionInfo* connection_info = connection_iter-&gt;second;
263         boost::shared_ptr&lt;T&gt; p = boost::make_shared&lt;T&gt;();
264         ros::serialization::PreDeserializeParams&lt;T&gt; predes_params;
265         predes_params.message = p;
266         predes_params.connection_header = connection_info-&gt;header;
267         ros::serialization::PreDeserialize&lt;T&gt;::notify(predes_params);
268         ros::serialization::IStream s(current_buffer_-&gt;getData() + index_entry.offset + bytes_read, data_size);
269         ros::serialization::deserialize(s, *p);
270         return p;
271 	}
272     case 102:
273 	{
274         ros::Header header;
275         readMessageDataRecord102(index_entry.chunk_pos, header);
276         ros::M_string&amp; fields = *header.getValues();
277         std::string topic, latching("0"), callerid;
278         readField(fields, TOPIC_FIELD_NAME,    true,  topic);
279         readField(fields, LATCHING_FIELD_NAME, false, latching);
280         readField(fields, CALLERID_FIELD_NAME, false, callerid);
281         std::map&lt;std::string, uint32_t&gt;::const_iterator topic_conn_id_iter = topic_connection_ids_.find(topic);
282         if (topic_conn_id_iter == topic_connection_ids_.end())
283             throw BagFormatException((boost::format("Unknown topic: %1%") % topic).str());
284         uint32_t connection_id = topic_conn_id_iter-&gt;second;
285         std::map&lt;uint32_t, ConnectionInfo*&gt;::const_iterator connection_iter = connections_.find(connection_id);
286         if (connection_iter == connections_.end())
287             throw BagFormatException((boost::format("Unknown connection ID: %1%") % connection_id).str());
288         ConnectionInfo* connection_info = connection_iter-&gt;second;
289         boost::shared_ptr&lt;T&gt; p = boost::make_shared&lt;T&gt;();
290         boost::shared_ptr&lt;ros::M_string&gt; message_header(boost::make_shared&lt;ros::M_string&gt;());
291         for (ros::M_string::const_iterator i = connection_info-&gt;header-&gt;begin(); i != connection_info-&gt;header-&gt;end(); i++)
292             (*message_header)[i-&gt;first] = i-&gt;second;
293         (*message_header)["latching"] = latching;
294         (*message_header)["callerid"] = callerid;
295         ros::serialization::PreDeserializeParams&lt;T&gt; predes_params;
296         predes_params.message = p;
297         predes_params.connection_header = message_header;
298         ros::serialization::PreDeserialize&lt;T&gt;::notify(predes_params);
299         ros::serialization::IStream s(record_buffer_.getData(), record_buffer_.getSize());
300         ros::serialization::deserialize(s, *p);
301         return p;
302 	}
303     default:
304         throw BagFormatException((boost::format("Unhandled version: %1%") % version_).str());
305     }
306 }
307 template&lt;class T&gt;
308 void Bag::doWrite(std::string const&amp; topic, ros::Time const&amp; time, T const&amp; msg, boost::shared_ptr&lt;ros::M_string&gt; const&amp; connection_header) {
309     if (time &lt; ros::TIME_MIN)
310     {
311         throw BagException("Tried to insert a message with time less than ros::TIME_MIN");
312     }
313     bag_revision_++;
314     ConnectionInfo* connection_info = NULL;
315     uint32_t conn_id = 0;
316     if (!connection_header) {
317         std::map&lt;std::string, uint32_t&gt;::iterator topic_connection_ids_iter = topic_connection_ids_.find(topic);
318         if (topic_connection_ids_iter == topic_connection_ids_.end()) {
319             conn_id = connections_.size();
320             topic_connection_ids_[topic] = conn_id;
321         }
322         else {
323             conn_id = topic_connection_ids_iter-&gt;second;
324             connection_info = connections_[conn_id];
325         }
326     }
327     else {
328         ros::M_string connection_header_copy(*connection_header);
329         connection_header_copy["topic"] = topic;
330         std::map&lt;ros::M_string, uint32_t&gt;::iterator header_connection_ids_iter = header_connection_ids_.find(connection_header_copy);
331         if (header_connection_ids_iter == header_connection_ids_.end()) {
332             conn_id = connections_.size();
333             header_connection_ids_[connection_header_copy] = conn_id;
334         }
335         else {
336             conn_id = header_connection_ids_iter-&gt;second;
337             connection_info = connections_[conn_id];
338         }
339     }
340     {
341         seek(0, std::ios::end);
342         file_size_ = file_.getOffset();
343         if (!chunk_open_)
344             startWritingChunk(time);
345         if (connection_info == NULL) {
346             connection_info = new ConnectionInfo();
347             connection_info-&gt;id       = conn_id;
348             connection_info-&gt;topic    = topic;
349             connection_info-&gt;datatype = std::string(ros::message_traits::datatype(msg));
350             connection_info-&gt;md5sum   = std::string(ros::message_traits::md5sum(msg));
351             connection_info-&gt;msg_def  = std::string(ros::message_traits::definition(msg));
352             if (connection_header != NULL) {
353                 connection_info-&gt;header = connection_header;
354             }
355             else {
356                 connection_info-&gt;header = boost::make_shared&lt;ros::M_string&gt;();
357                 (*connection_info-&gt;header)["type"]               = connection_info-&gt;datatype;
358                 (*connection_info-&gt;header)["md5sum"]             = connection_info-&gt;md5sum;
359                 (*connection_info-&gt;header)["message_definition"] = connection_info-&gt;msg_def;
360             }
361             connections_[conn_id] = connection_info;
362             writeConnectionRecord(connection_info, false);
363             appendConnectionRecordToBuffer(outgoing_chunk_buffer_, connection_info);
364         }
365         IndexEntry index_entry;
366         index_entry.time      = time;
367         index_entry.chunk_pos = curr_chunk_info_.pos;
368         index_entry.offset    = getChunkOffset();
369         std::multiset&lt;IndexEntry&gt;&amp; chunk_connection_index = curr_chunk_connection_indexes_[connection_info-&gt;id];
370         chunk_connection_index.insert(chunk_connection_index.end(), index_entry);
371         if (mode_ != BagMode::Write) {
372           std::multiset&lt;IndexEntry&gt;&amp; connection_index = connection_indexes_[connection_info-&gt;id];
373           connection_index.insert(connection_index.end(), index_entry);
374         }
375         curr_chunk_info_.connection_counts[connection_info-&gt;id]++;
376         writeMessageDataRecord(conn_id, time, msg);
377         uint32_t chunk_size = getChunkOffset();
378         CONSOLE_BRIDGE_logDebug("  curr_chunk_size=%d (threshold=%d)", chunk_size, chunk_threshold_);
379         if (chunk_size &gt; chunk_threshold_) {
380             stopWritingChunk();
381             outgoing_chunk_buffer_.setSize(0);
382             curr_chunk_info_.pos = -1;
383         }
384     }
385 }
386 template&lt;class T&gt;
387 void Bag::writeMessageDataRecord(uint32_t conn_id, ros::Time const&amp; time, T const&amp; msg) {
388     ros::M_string header;
389     header[OP_FIELD_NAME]         = toHeaderString(&amp;OP_MSG_DATA);
390     header[CONNECTION_FIELD_NAME] = toHeaderString(&amp;conn_id);
391     header[TIME_FIELD_NAME]       = toHeaderString(&amp;time);
392     uint32_t msg_ser_len = ros::serialization::serializationLength(msg);
393     record_buffer_.setSize(msg_ser_len);
394     ros::serialization::OStream s(record_buffer_.getData(), msg_ser_len);
395     ros::serialization::serialize(s, msg);
396     seek(0, std::ios::end);
397     file_size_ = file_.getOffset();
398     CONSOLE_BRIDGE_logDebug("Writing MSG_DATA [%llu:%d]: conn=%d sec=%d nsec=%d data_len=%d",
399               (unsigned long long) file_.getOffset(), getChunkOffset(), conn_id, time.sec, time.nsec, msg_ser_len);
400     writeHeader(header);
401     writeDataLength(msg_ser_len);
402     write((char*) record_buffer_.getData(), msg_ser_len);
403     appendHeaderToBuffer(outgoing_chunk_buffer_, header);
404     appendDataLengthToBuffer(outgoing_chunk_buffer_, msg_ser_len);
405     uint32_t offset = outgoing_chunk_buffer_.getSize();
406     outgoing_chunk_buffer_.setSize(outgoing_chunk_buffer_.getSize() + msg_ser_len);
407     memcpy(outgoing_chunk_buffer_.getData() + offset, record_buffer_.getData(), msg_ser_len);
408     if (time &gt; curr_chunk_info_.end_time)
409     	curr_chunk_info_.end_time = time;
410     else if (time &lt; curr_chunk_info_.start_time)
411         curr_chunk_info_.start_time = time;
412 }
413 inline void swap(Bag&amp; a, Bag&amp; b) {
414     a.swap(b);
415 }
416 } 
417 #endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
