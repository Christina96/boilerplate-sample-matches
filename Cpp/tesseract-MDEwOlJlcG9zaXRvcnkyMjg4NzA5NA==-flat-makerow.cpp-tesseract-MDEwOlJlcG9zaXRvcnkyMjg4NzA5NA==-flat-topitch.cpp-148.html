
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-makerow.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #include &quot;makerow.h&quot;
5  #include &quot;blkocc.h&quot;
6  #include &quot;blobbox.h&quot;
7  #include &quot;ccstruct.h&quot;
8  #include &quot;detlinefit.h&quot;
9  #include &quot;drawtord.h&quot;
10  #include &quot;oldbasel.h&quot;
11  #include &quot;sortflts.h&quot;
12  #include &quot;statistc.h&quot;
13  #include &quot;textord.h&quot;
14  #include &quot;tordmain.h&quot;
15  #include &quot;tovars.h&quot;
16  #include &quot;tprintf.h&quot;
17  #include &quot;underlin.h&quot;
18  #include &lt;algorithm&gt;
19  #include &lt;cmath&gt;
20  #include &lt;vector&gt; 
21  namespace tesseract {
22  BOOL_VAR(textord_heavy_nr, false, &quot;Vigorously remove noise&quot;);
23  BOOL_VAR(textord_show_initial_rows, false, &quot;Display row accumulation&quot;);
24  BOOL_VAR(textord_show_parallel_rows, false, &quot;Display page correlated rows&quot;);
25  BOOL_VAR(textord_show_expanded_rows, false, &quot;Display rows after expanding&quot;);
26  BOOL_VAR(textord_show_final_rows, false, &quot;Display rows after final fitting&quot;);
27  BOOL_VAR(textord_show_final_blobs, false, &quot;Display blob bounds after pre-ass&quot;);
28  BOOL_VAR(textord_test_landscape, false, &quot;Tests refer to land/port&quot;);
29  BOOL_VAR(textord_parallel_baselines, true, &quot;Force parallel baselines&quot;);
30  BOOL_VAR(textord_straight_baselines, false, &quot;Force straight baselines&quot;);
31  BOOL_VAR(textord_old_baselines, true, &quot;Use old baseline algorithm&quot;);
32  BOOL_VAR(textord_old_xheight, false, &quot;Use old xheight algorithm&quot;);
33  BOOL_VAR(textord_fix_xheight_bug, true, &quot;Use spline baseline&quot;);
34  BOOL_VAR(textord_fix_makerow_bug, true, &quot;Prevent multiple baselines&quot;);
35  BOOL_VAR(textord_debug_xheights, false, &quot;Test xheight algorithms&quot;);
36  static BOOL_VAR(textord_biased_skewcalc, true, &quot;Bias skew estimates with line length&quot;);
37  static BOOL_VAR(textord_interpolating_skew, true, &quot;Interpolate across gaps&quot;);
38  static INT_VAR(textord_skewsmooth_offset, 4, &quot;For smooth factor&quot;);
39  static INT_VAR(textord_skewsmooth_offset2, 1, &quot;For smooth factor&quot;);
40  INT_VAR(textord_test_x, -INT32_MAX, &quot;coord of test pt&quot;);
41  INT_VAR(textord_test_y, -INT32_MAX, &quot;coord of test pt&quot;);
42  INT_VAR(textord_min_blobs_in_row, 4, &quot;Min blobs before gradient counted&quot;);
43  INT_VAR(textord_spline_minblobs, 8, &quot;Min blobs in each spline segment&quot;);
44  INT_VAR(textord_spline_medianwin, 6, &quot;Size of window for spline segmentation&quot;);
45  static INT_VAR(textord_max_blob_overlaps, 4, &quot;Max number of blobs a big blob can overlap&quot;);
46  INT_VAR(textord_min_xheight, 10, &quot;Min credible pixel xheight&quot;);
47  double_VAR(textord_spline_shift_fraction, 0.02, &quot;Fraction of line spacing for quad&quot;);
48  double_VAR(textord_skew_ile, 0.5, &quot;Ile of gradients for page skew&quot;);
49  double_VAR(textord_skew_lag, 0.02, &quot;Lag for skew on row accumulation&quot;);
50  double_VAR(textord_linespace_iqrlimit, 0.2, &quot;Max iqr/median for linespace&quot;);
51  double_VAR(textord_width_limit, 8, &quot;Max width of blobs to make rows&quot;);
52  double_VAR(textord_chop_width, 1.5, &quot;Max width before chopping&quot;);
53  static double_VAR(textord_expansion_factor, 1.0, &quot;Factor to expand rows by in expand_rows&quot;);
54  static double_VAR(textord_overlap_x, 0.375, &quot;Fraction of linespace for good overlap&quot;);
55  double_VAR(textord_minxh, 0.25, &quot;fraction of linesize for min xheight&quot;);
56  double_VAR(textord_min_linesize, 1.25, &quot;* blob height for initial linesize&quot;);
57  double_VAR(textord_excess_blobsize, 1.3, &quot;New row made if blob makes row this big&quot;);
58  double_VAR(textord_occupancy_threshold, 0.4, &quot;Fraction of neighbourhood&quot;);
59  double_VAR(textord_underline_width, 2.0, &quot;Multiple of line_size for underline&quot;);
60  double_VAR(textord_min_blob_height_fraction, 0.75,
61             &quot;Min blob height/top to include blob top into xheight stats&quot;);
62  double_VAR(textord_xheight_mode_fraction, 0.4, &quot;Min pile height to make xheight&quot;);
63  double_VAR(textord_ascheight_mode_fraction, 0.08, &quot;Min pile height to make ascheight&quot;);
64  static double_VAR(textord_descheight_mode_fraction, 0.08, &quot;Min pile height to make descheight&quot;);
65  double_VAR(textord_ascx_ratio_min, 1.25, &quot;Min cap/xheight&quot;);
66  double_VAR(textord_ascx_ratio_max, 1.8, &quot;Max cap/xheight&quot;);
67  double_VAR(textord_descx_ratio_min, 0.25, &quot;Min desc/xheight&quot;);
68  double_VAR(textord_descx_ratio_max, 0.6, &quot;Max desc/xheight&quot;);
69  double_VAR(textord_xheight_error_margin, 0.1, &quot;Accepted variation&quot;);
70  INT_VAR(textord_lms_line_trials, 12, &quot;Number of linew fits to do&quot;);
71  BOOL_VAR(textord_new_initial_xheight, true, &quot;Use test xheight mechanism&quot;);
72  BOOL_VAR(textord_debug_blob, false, &quot;Print test blob information&quot;);
73  #define MAX_HEIGHT_MODES 12
74  const int kMinLeaderCount = 5;
75  static int row_y_order(       
76      const void *item1, 
77      const void *item2) {
78    const TO_ROW *row1 = *reinterpret_cast&lt;const TO_ROW *const *&gt;(item1);
79    const TO_ROW *row2 = *reinterpret_cast&lt;const TO_ROW *const *&gt;(item2);
80    if (row1-&gt;parallel_c() &gt; row2-&gt;parallel_c()) {
81      return -1;
82    } else if (row1-&gt;parallel_c() &lt; row2-&gt;parallel_c()) {
83      return 1;
84    } else {
85      return 0;
86    }
87  }
88  static int row_spacing_order( 
89      const TO_ROW *row1, 
90      const TO_ROW *row2) {
91    return row1-&gt;spacing &lt; row2-&gt;spacing;
92  }
93  static float MakeRowFromBlobs(float line_size, BLOBNBOX_IT *blob_it, TO_ROW_IT *row_it) {
94    blob_it-&gt;sort(blob_x_order);
95    blob_it-&gt;move_to_first();
96    TO_ROW *row = nullptr;
97    float total_size = 0.0f;
98    int blob_count = 0;
99    for (; !blob_it-&gt;empty(); blob_it-&gt;forward()) {
100      BLOBNBOX *blob = blob_it-&gt;extract();
101      int top = blob-&gt;bounding_box().top();
102      int bottom = blob-&gt;bounding_box().bottom();
103      if (row == nullptr) {
104        row = new TO_ROW(blob, top, bottom, line_size);
105        row_it-&gt;add_before_then_move(row);
106      } else {
107        row-&gt;add_blob(blob, top, bottom, line_size);
108      }
109      total_size += top - bottom;
110      ++blob_count;
111    }
112    return blob_count &gt; 0 ? total_size / blob_count : total_size;
113  }
114  static float MakeRowFromSubBlobs(TO_BLOCK *block, C_BLOB *blob, TO_ROW_IT *row_it) {
115    BLOBNBOX_IT bb_it(&amp;block-&gt;small_blobs);
116    C_OUTLINE_IT ol_it(blob-&gt;out_list());
117    ol_it.set_to_list(ol_it.data()-&gt;child());
118    if (ol_it.empty()) {
119      return 0.0f;
120    }
121    for (ol_it.mark_cycle_pt(); !ol_it.cycled_list(); ol_it.forward()) {
122      blob = new C_BLOB(C_OUTLINE::deep_copy(ol_it.data()));
123      blob-&gt;CheckInverseFlagAndDirection();
124      auto *bbox = new BLOBNBOX(blob);
125      bb_it.add_after_then_move(bbox);
126    }
127    return MakeRowFromBlobs(block-&gt;line_size, &amp;bb_it, row_it);
128  }
129  float make_single_row(ICOORD page_tr, bool allow_sub_blobs, TO_BLOCK *block,
130                        TO_BLOCK_LIST *blocks) {
131    BLOBNBOX_IT blob_it = &amp;block-&gt;blobs;
132    TO_ROW_IT row_it = block-&gt;get_rows();
133    blob_it.add_list_after(&amp;block-&gt;small_blobs);
134    blob_it.add_list_after(&amp;block-&gt;noise_blobs);
135    blob_it.add_list_after(&amp;block-&gt;large_blobs);
136    if (block-&gt;blobs.singleton() &amp;&amp; allow_sub_blobs) {
137      blob_it.move_to_first();
138      float size = MakeRowFromSubBlobs(block, blob_it.data()-&gt;cblob(), &amp;row_it);
139      if (size &gt; block-&gt;line_size) {
140        block-&gt;line_size = size;
141      }
142    } else if (block-&gt;blobs.empty()) {
143      C_BLOB *blob = C_BLOB::FakeBlob(block-&gt;block-&gt;pdblk.bounding_box());
144      auto *bblob = new BLOBNBOX(blob);
145      blob_it.add_after_then_move(bblob);
146    }
147    MakeRowFromBlobs(block-&gt;line_size, &amp;blob_it, &amp;row_it);
148    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
149      fit_lms_line(row_it.data());
150    }
151    float gradient;
152    float fit_error;
153    compute_page_skew(blocks, gradient, fit_error);
154    return gradient;
155  }
156  float make_rows(ICOORD page_tr, TO_BLOCK_LIST *port_blocks) {
157    float port_m;         
158    float port_err;       
159    TO_BLOCK_IT block_it; 
160    block_it.set_to_list(port_blocks);
161    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
162      make_initial_textrows(page_tr, block_it.data(), FCOORD(1.0f, 0.0f), !textord_test_landscape);
163    }
164    compute_page_skew(port_blocks, port_m, port_err);
165    block_it.set_to_list(port_blocks);
166    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
167      cleanup_rows_making(page_tr, block_it.data(), port_m, FCOORD(1.0f, 0.0f),
168                          block_it.data()-&gt;block-&gt;pdblk.bounding_box().left(),
169                          !textord_test_landscape);
170    }
171    return port_m; 
172  }
173  void make_initial_textrows( 
174      ICOORD page_tr,
175      TO_BLOCK *block, 
176      FCOORD rotation, 
177      bool testing_on  
178  ) {
179    TO_ROW_IT row_it = block-&gt;get_rows();
180  #ifndef GRAPHICS_DISABLED
181    ScrollView::Color colour; 
182    if (textord_show_initial_rows &amp;&amp; testing_on) {
183      if (to_win == nullptr) {
184        create_to_win(page_tr);
185      }
186    }
187  #endif
188    assign_blobs_to_rows(block, nullptr, 0, true, true, textord_show_initial_rows &amp;&amp; testing_on);
189    row_it.move_to_first();
190    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
191      fit_lms_line(row_it.data());
192    }
193  #ifndef GRAPHICS_DISABLED
194    if (textord_show_initial_rows &amp;&amp; testing_on) {
195      colour = ScrollView::RED;
196      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
197        plot_to_row(row_it.data(), colour, rotation);
198        colour = static_cast&lt;ScrollView::Color&gt;(colour + 1);
199        if (colour &gt; ScrollView::MAGENTA) {
200          colour = ScrollView::RED;
201        }
202      }
203    }
204  #endif
205  }
206  void fit_lms_line(TO_ROW *row) {
207    float m, c; 
208    tesseract::DetLineFit lms;
209    BLOBNBOX_IT blob_it = row-&gt;blob_list();
210    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
211      const TBOX &amp;box = blob_it.data()-&gt;bounding_box();
212      lms.Add(ICOORD((box.left() + box.right()) / 2, box.bottom()));
213    }
214    double error = lms.Fit(&amp;m, &amp;c);
215    row-&gt;set_line(m, c, error);
216  }
217  void compute_page_skew(    
218      TO_BLOCK_LIST *blocks, 
219      float &amp;page_m,         
220      float &amp;page_err        
221  ) {
222    int32_t row_count;             
223    int32_t blob_count;            
224    int32_t row_err;               
225    int32_t row_index;             
226    TO_ROW *row;                   
227    TO_BLOCK_IT block_it = blocks; 
228    row_count = 0;
229    blob_count = 0;
230    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
231      POLY_BLOCK *pb = block_it.data()-&gt;block-&gt;pdblk.poly_block();
232      if (pb != nullptr &amp;&amp; !pb-&gt;IsText()) {
233        continue; 
234      }
235      row_count += block_it.data()-&gt;get_rows()-&gt;length();
236      TO_ROW_IT row_it(block_it.data()-&gt;get_rows());
237      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
238        blob_count += row_it.data()-&gt;blob_list()-&gt;length();
239      }
240    }
241    if (row_count == 0) {
242      page_m = 0.0f;
243      page_err = 0.0f;
244      return;
245    }
246    std::vector&lt;float&gt; gradients(blob_count);
247    std::vector&lt;float&gt; errors(blob_count);
248    row_index = 0;
249    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
250      POLY_BLOCK *pb = block_it.data()-&gt;block-&gt;pdblk.poly_block();
251      if (pb != nullptr &amp;&amp; !pb-&gt;IsText()) {
252        continue; 
253      }
254      TO_ROW_IT row_it(block_it.data()-&gt;get_rows());
255      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
256        row = row_it.data();
257        blob_count = row-&gt;blob_list()-&gt;length();
258        row_err = static_cast&lt;int32_t&gt;(std::ceil(row-&gt;line_error()));
259        if (row_err &lt;= 0) {
260          row_err = 1;
261        }
262        if (textord_biased_skewcalc) {
263          blob_count /= row_err;
264          for (blob_count /= row_err; blob_count &gt; 0; blob_count--) {
265            gradients[row_index] = row-&gt;line_m();
266            errors[row_index] = row-&gt;line_error();
267            row_index++;
268          }
269        } else if (blob_count &gt;= textord_min_blobs_in_row) {
270          gradients[row_index] = row-&gt;line_m();
271          errors[row_index] = row-&gt;line_error();
272          row_index++;
273        }
274      }
275    }
276    if (row_index == 0) {
277      for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
278        POLY_BLOCK *pb = block_it.data()-&gt;block-&gt;pdblk.poly_block();
279        if (pb != nullptr &amp;&amp; !pb-&gt;IsText()) {
280          continue; 
281        }
282        TO_ROW_IT row_it(block_it.data()-&gt;get_rows());
283        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
284          row = row_it.data();
285          gradients[row_index] = row-&gt;line_m();
286          errors[row_index] = row-&gt;line_error();
287          row_index++;
288        }
289      }
290    }
291    row_count = row_index;
292    row_index = static_cast&lt;int32_t&gt;(row_count * textord_skew_ile);
293    gradients.resize(row_count);
294    std::nth_element(gradients.begin(), gradients.begin() + row_index, gradients.end());
295    page_m = gradients[row_index];
296    row_index = static_cast&lt;int32_t&gt;(row_count * textord_skew_ile);
297    errors.resize(row_count);
298    std::nth_element(errors.begin(), errors.begin() + row_index, errors.end());
299    page_err = errors[row_index];
300  }
301  const double kNoiseSize = 0.5; 
302  const int kMinSize = 8;        
303  static bool dot_of_i(BLOBNBOX *dot, BLOBNBOX *i, TO_ROW *row) {
304    const TBOX &amp;ibox = i-&gt;bounding_box();
305    const TBOX &amp;dotbox = dot-&gt;bounding_box();
306    int overlap = std::min(dotbox.right(), ibox.right()) - std::max(dotbox.left(), ibox.left());
307    if (ibox.height() &lt;= 2 * dotbox.height() ||
308        (overlap * 2 &lt; ibox.width() &amp;&amp; overlap &lt; dotbox.width())) {
309      return false;
310    }
311    if (ibox.height() &gt; ibox.width() * 2) {
312      return true; 
313    }
314    const double kHeightFraction = 0.6;
315    double target_height = std::min(dotbox.bottom(), ibox.top());
316    target_height -= row-&gt;line_m() * dotbox.left() + row-&gt;line_c();
317    target_height *= kHeightFraction;
318    int left_min = dotbox.left() - dotbox.width();
319    int middle = (dotbox.left() + dotbox.right()) / 2;
320    int right_max = dotbox.right() + dotbox.width();
321    int left_miny = 0;
322    int left_maxy = 0;
323    int right_miny = 0;
324    int right_maxy = 0;
325    bool found_left = false;
326    bool found_right = false;
327    bool in_left = false;
328    bool in_right = false;
329    C_BLOB *blob = i-&gt;cblob();
330    C_OUTLINE_IT o_it = blob-&gt;out_list();
331    for (o_it.mark_cycle_pt(); !o_it.cycled_list(); o_it.forward()) {
332      C_OUTLINE *outline = o_it.data();
333      int length = outline-&gt;pathlength();
334      ICOORD pos = outline-&gt;start_pos();
335      for (int step = 0; step &lt; length; pos += outline-&gt;step(step++)) {
336        int x = pos.x();
337        int y = pos.y();
338        if (x &gt;= left_min &amp;&amp; x &lt; middle &amp;&amp; !found_left) {
339          if (in_left) {
340            if (y &gt; left_maxy) {
341              left_maxy = y;
342            }
343            if (y &lt; left_miny) {
344              left_miny = y;
345            }
346          } else {
347            left_maxy = left_miny = y;
348            in_left = true;
349          }
350        } else if (in_left) {
351          if (left_maxy - left_miny &gt; target_height) {
352            if (found_right) {
353              return true;
354            }
355            found_left = true;
356          }
357          in_left = false;
358        }
359        if (x &lt;= right_max &amp;&amp; x &gt; middle &amp;&amp; !found_right) {
360          if (in_right) {
361            if (y &gt; right_maxy) {
362              right_maxy = y;
363            }
364            if (y &lt; right_miny) {
365              right_miny = y;
366            }
367          } else {
368            right_maxy = right_miny = y;
369            in_right = true;
370          }
371        } else if (in_right) {
372          if (right_maxy - right_miny &gt; target_height) {
373            if (found_left) {
374              return true;
375            }
376            found_right = true;
377          }
378          in_right = false;
379        }
380      }
381    }
382    return false;
383  }
384  void vigorous_noise_removal(TO_BLOCK *block) {
385    TO_ROW_IT row_it = block-&gt;get_rows();
386    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
387      TO_ROW *row = row_it.data();
388      BLOBNBOX_IT b_it = row-&gt;blob_list();
389      int max_height = 0;
390      for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
391        BLOBNBOX *blob = b_it.data();
392        if (blob-&gt;bounding_box().height() &gt; max_height) {
393          max_height = blob-&gt;bounding_box().height();
394        }
395      }
396      STATS hstats(0, max_height);
397      for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
398        BLOBNBOX *blob = b_it.data();
399        int height = blob-&gt;bounding_box().height();
400        if (height &gt;= kMinSize) {
401          hstats.add(blob-&gt;bounding_box().height(), 1);
402        }
403      }
404      float xheight = hstats.median();
405      BLOBNBOX *prev = nullptr;
406      for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
407        BLOBNBOX *blob = b_it.data();
408        const TBOX &amp;box = blob-&gt;bounding_box();
409        if (box.height() &lt; kNoiseSize * xheight) {
410          if (prev != nullptr) {
411            if (dot_of_i(blob, prev, row)) {
412              continue; 
413            }
414          }
415          if (!b_it.at_last()) {
416            BLOBNBOX *next = b_it.data_relative(1);
417            if (dot_of_i(blob, next, row)) {
418              continue; 
419            }
420          }
421          delete blob-&gt;remove_cblob();
422          delete b_it.extract();
423        } else {
424          prev = blob;
425        }
426      }
427    }
428  }
429  void cleanup_rows_making( 
430      ICOORD page_tr,       
431      TO_BLOCK *block,      
432      float gradient,       
433      FCOORD rotation,      
434      int32_t block_edge,   
435      bool testing_on       
436  ) {
437    BLOBNBOX_IT blob_it = &amp;block-&gt;blobs;
438    TO_ROW_IT row_it = block-&gt;get_rows();
439  #ifndef GRAPHICS_DISABLED
440    if (textord_show_parallel_rows &amp;&amp; testing_on) {
441      if (to_win == nullptr) {
442        create_to_win(page_tr);
443      }
444    }
445  #endif
446    fit_parallel_rows(block, gradient, rotation, block_edge,
447                      textord_show_parallel_rows &amp;&amp; testing_on);
448    delete_non_dropout_rows(block, gradient, rotation, block_edge,
449                            textord_show_parallel_rows &amp;&amp; testing_on);
450    expand_rows(page_tr, block, gradient, rotation, block_edge, testing_on);
451    blob_it.set_to_list(&amp;block-&gt;blobs);
452    row_it.set_to_list(block-&gt;get_rows());
453    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
454      blob_it.add_list_after(row_it.data()-&gt;blob_list());
455    }
456    assign_blobs_to_rows(block, &amp;gradient, 1, false, false, false);
457    blob_it.set_to_list(&amp;block-&gt;blobs);
458    blob_it.add_list_after(&amp;block-&gt;large_blobs);
459    assign_blobs_to_rows(block, &amp;gradient, 2, true, true, false);
460    blob_it.set_to_list(&amp;block-&gt;blobs);
461    blob_it.add_list_after(&amp;block-&gt;noise_blobs);
462    blob_it.add_list_after(&amp;block-&gt;small_blobs);
463    assign_blobs_to_rows(block, &amp;gradient, 3, false, false, false);
464  }
465  void delete_non_dropout_rows( 
466      TO_BLOCK *block,          
467      float gradient,           
468      FCOORD rotation,          
469      int32_t block_edge,       
470      bool testing_on           
471  ) {
472    TBOX block_box; 
473    int32_t max_y;  
474    int32_t min_y;
475    int32_t line_index; 
476    int32_t line_count; 
477    int32_t distance;   
478    int32_t xleft;      
479    int32_t ybottom;    
480    TO_ROW *row;        
481    TO_ROW_IT row_it = block-&gt;get_rows();
482    BLOBNBOX_IT blob_it = &amp;block-&gt;blobs;
483    if (row_it.empty()) {
484      return; 
485    }
486    block_box = deskew_block_coords(block, gradient);
487    xleft = block-&gt;block-&gt;pdblk.bounding_box().left();
488    ybottom = block-&gt;block-&gt;pdblk.bounding_box().bottom();
489    min_y = block_box.bottom() - 1;
490    max_y = block_box.top() + 1;
491    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
492      line_index = static_cast&lt;int32_t&gt;(std::floor(row_it.data()-&gt;intercept()));
493      if (line_index &lt;= min_y) {
494        min_y = line_index - 1;
495      }
496      if (line_index &gt;= max_y) {
497        max_y = line_index + 1;
498      }
499    }
500    line_count = max_y - min_y + 1;
501    if (line_count &lt;= 0) {
502      return; 
503    }
504    std::vector&lt;int32_t&gt; deltas(line_count);
505    std::vector&lt;int32_t&gt; occupation(line_count);
506    compute_line_occupation(block, gradient, min_y, max_y, &amp;occupation[0], &amp;deltas[0]);
507    compute_occupation_threshold(
508        static_cast&lt;int32_t&gt;(ceil(block-&gt;line_spacing * (tesseract::CCStruct::kDescenderFraction +
509                                                         tesseract::CCStruct::kAscenderFraction))),
510        static_cast&lt;int32_t&gt;(ceil(block-&gt;line_spacing * (tesseract::CCStruct::kXHeightFraction +
511                                                         tesseract::CCStruct::kAscenderFraction))),
512        max_y - min_y + 1, &amp;occupation[0], &amp;deltas[0]);
513  #ifndef GRAPHICS_DISABLED
514    if (testing_on) {
515      draw_occupation(xleft, ybottom, min_y, max_y, &amp;occupation[0], &amp;deltas[0]);
516    }
517  #endif
518    compute_dropout_distances(&amp;occupation[0], &amp;deltas[0], line_count);
519    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
520      row = row_it.data();
521      line_index = static_cast&lt;int32_t&gt;(std::floor(row-&gt;intercept()));
522      distance = deltas[line_index - min_y];
523      if (find_best_dropout_row(row, distance, block-&gt;line_spacing / 2, line_index, &amp;row_it,
524                                testing_on)) {
525  #ifndef GRAPHICS_DISABLED
526        if (testing_on) {
527          plot_parallel_row(row, gradient, block_edge, ScrollView::WHITE, rotation);
528        }
529  #endif
530        blob_it.add_list_after(row_it.data()-&gt;blob_list());
531        delete row_it.extract(); 
532      }
533    }
534    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
535      blob_it.add_list_after(row_it.data()-&gt;blob_list());
536    }
537  }
538  bool find_best_dropout_row( 
539      TO_ROW *row,            
540      int32_t distance,       
541      float dist_limit,       
542      int32_t line_index,     
543      TO_ROW_IT *row_it,      
544      bool testing_on         
545  ) {
546    int32_t next_index; 
547    int32_t row_offset; 
548    int32_t abs_dist;   
549    int8_t row_inc;     
550    TO_ROW *next_row;   
551    if (testing_on) {
552      tprintf(&quot;Row at %g(%g), dropout dist=%d,&quot;, row-&gt;intercept(), row-&gt;parallel_c(), distance);
553    }
554    if (distance &lt; 0) {
555      row_inc = 1;
556      abs_dist = -distance;
557    } else {
558      row_inc = -1;
559      abs_dist = distance;
560    }
561    if (abs_dist &gt; dist_limit) {
562      if (testing_on) {
563        tprintf(&quot; too far - deleting\n&quot;);
564      }
565      return true;
566    }
567    if ((distance &lt; 0 &amp;&amp; !row_it-&gt;at_last()) || (distance &gt;= 0 &amp;&amp; !row_it-&gt;at_first())) {
568      row_offset = row_inc;
569      do {
570        next_row = row_it-&gt;data_relative(row_offset);
571        next_index = static_cast&lt;int32_t&gt;(std::floor(next_row-&gt;intercept()));
572        if ((distance &lt; 0 &amp;&amp; next_index &lt; line_index &amp;&amp;
573             next_index &gt; line_index + distance + distance) ||
574            (distance &gt;= 0 &amp;&amp; next_index &gt; line_index &amp;&amp;
575             next_index &lt; line_index + distance + distance)) {
576          if (testing_on) {
577            tprintf(&quot; nearer neighbour (%d) at %g\n&quot;, line_index + distance - next_index,
578                    next_row-&gt;intercept());
579          }
580          return true; 
581        } else if (next_index == line_index || next_index == line_index + distance + distance) {
582          if (row-&gt;believability() &lt;= next_row-&gt;believability()) {
583            if (testing_on) {
584              tprintf(&quot; equal but more believable at %g (%g/%g)\n&quot;, next_row-&gt;intercept(),
585                      row-&gt;believability(), next_row-&gt;believability());
586            }
587            return true; 
588          }
589        }
590        row_offset += row_inc;
591      } while ((next_index == line_index || next_index == line_index + distance + distance) &amp;&amp;
592               row_offset &lt; row_it-&gt;length());
593      if (testing_on) {
594        tprintf(&quot; keeping\n&quot;);
595      }
596    }
597    return false;
598  }
599  TBOX deskew_block_coords( 
600      TO_BLOCK *block,      
601      float gradient        
602  ) {
603    TBOX result;     
604    TBOX blob_box;   
605    FCOORD rotation; 
606    float length;    
607    TO_ROW_IT row_it = block-&gt;get_rows();
608    TO_ROW *row;         
609    BLOBNBOX *blob;      
610    BLOBNBOX_IT blob_it; 
611    length = std::sqrt(gradient * gradient + 1);
612    rotation = FCOORD(1 / length, -gradient / length);
613    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
614      row = row_it.data();
615      blob_it.set_to_list(row-&gt;blob_list());
616      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
617        blob = blob_it.data();
618        blob_box = blob-&gt;bounding_box();
619        blob_box.rotate(rotation); 
620        result += blob_box;
621      }
622    }
623    return result;
624  }
625  void compute_line_occupation( 
626      TO_BLOCK *block,          
627      float gradient,           
628      int32_t min_y,            
629      int32_t max_y,            
630      int32_t *occupation,      
631      int32_t *deltas           
632  ) {
633    int32_t line_count; 
634    int32_t line_index; 
635    int index;          
636    TO_ROW *row;        
637    TO_ROW_IT row_it = block-&gt;get_rows();
638    BLOBNBOX *blob;      
639    BLOBNBOX_IT blob_it; 
640    float length;        
641    TBOX blob_box;       
642    FCOORD rotation;     
643    line_count = max_y - min_y + 1;
644    length = std::sqrt(gradient * gradient + 1);
645    rotation = FCOORD(1 / length, -gradient / length);
646    for (line_index = 0; line_index &lt; line_count; line_index++) {
647      deltas[line_index] = 0;
648    }
649    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
650      row = row_it.data();
651      blob_it.set_to_list(row-&gt;blob_list());
652      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
653        blob = blob_it.data();
654        blob_box = blob-&gt;bounding_box();
655        blob_box.rotate(rotation); 
656        int32_t width = blob_box.right() - blob_box.left();
657        index = blob_box.bottom() - min_y;
658        ASSERT_HOST(index &gt;= 0 &amp;&amp; index &lt; line_count);
659        deltas[index] += width;
660        index = blob_box.top() - min_y;
661        ASSERT_HOST(index &gt;= 0 &amp;&amp; index &lt; line_count);
662        deltas[index] -= width;
663      }
664    }
665    occupation[0] = deltas[0];
666    for (line_index = 1; line_index &lt; line_count; line_index++) {
667      occupation[line_index] = occupation[line_index - 1] + deltas[line_index];
668    }
669  }
670  void compute_occupation_threshold( 
671      int32_t low_window,            
672      int32_t high_window,           
673      int32_t line_count,            
674      int32_t *occupation,           
675      int32_t *thresholds            
676  ) {
677    int32_t line_index; 
678    int32_t low_index;  
679    int32_t high_index; 
680    int32_t sum;        
681    int32_t divisor;    
682    int32_t min_index;  
683    int32_t min_occ;    
684    int32_t test_index; 
685    divisor = static_cast&lt;int32_t&gt;(ceil((low_window + high_window) / textord_occupancy_threshold));
686    if (low_window + high_window &lt; line_count) {
687      for (sum = 0, high_index = 0; high_index &lt; low_window; high_index++) {
688        sum += occupation[high_index];
689      }
690      for (low_index = 0; low_index &lt; high_window; low_index++, high_index++) {
691        sum += occupation[high_index];
692      }
693      min_occ = occupation[0];
694      min_index = 0;
695      for (test_index = 1; test_index &lt; high_index; test_index++) {
696        if (occupation[test_index] &lt;= min_occ) {
697          min_occ = occupation[test_index];
698          min_index = test_index; 
699        }
700      }
701      for (line_index = 0; line_index &lt; low_window; line_index++) {
702        thresholds[line_index] = (sum - min_occ) / divisor + min_occ;
703      }
704      for (low_index = 0; high_index &lt; line_count; low_index++, high_index++) {
705        sum -= occupation[low_index];
706        sum += occupation[high_index];
707        if (occupation[high_index] &lt;= min_occ) {
708          min_occ = occupation[high_index];
709          min_index = high_index;
710        }
711        if (min_index &lt;= low_index) {
712          min_occ = occupation[low_index + 1];
713          min_index = low_index + 1;
714          for (test_index = low_index + 2; test_index &lt;= high_index; test_index++) {
715            if (occupation[test_index] &lt;= min_occ) {
716              min_occ = occupation[test_index];
717              min_index = test_index;
718            }
719          }
720        }
721        thresholds[line_index++] = (sum - min_occ) / divisor + min_occ;
722      }
723    } else {
724      min_occ = occupation[0];
725      min_index = 0;
726      for (sum = 0, low_index = 0; low_index &lt; line_count; low_index++) {
727        if (occupation[low_index] &lt; min_occ) {
728          min_occ = occupation[low_index];
729          min_index = low_index;
730        }
731        sum += occupation[low_index];
732      }
733      line_index = 0;
734    }
735    for (; line_index &lt; line_count; line_index++) {
736      thresholds[line_index] = (sum - min_occ) / divisor + min_occ;
737    }
738  }
739  void compute_dropout_distances( 
740      int32_t *occupation,        
741      int32_t *thresholds,        
742      int32_t line_count          
743  ) {
744    int32_t line_index;     
745    int32_t distance;       
746    int32_t next_dist;      
747    int32_t back_index;     
748    int32_t prev_threshold; 
749    distance = -line_count;
750    line_index = 0;
751    do {
752      do {
753        distance--;
754        prev_threshold = thresholds[line_index];
755        thresholds[line_index] = distance;
756        line_index++;
757      } while (line_index &lt; line_count &amp;&amp; (occupation[line_index] &lt; thresholds[line_index] ||
758                                           occupation[line_index - 1] &gt;= prev_threshold));
759      if (line_index &lt; line_count) {
760        back_index = line_index - 1;
761        next_dist = 1;
762        while (next_dist &lt; -distance &amp;&amp; back_index &gt;= 0) {
763          thresholds[back_index] = next_dist;
764          back_index--;
765          next_dist++;
766          distance++;
767        }
768        distance = 1;
769      }
770    } while (line_index &lt; line_count);
771  }
772  void expand_rows(       
773      ICOORD page_tr,     
774      TO_BLOCK *block,    
775      float gradient,     
776      FCOORD rotation,    
777      int32_t block_edge, 
778      bool testing_on     
779  ) {
780    bool swallowed_row;    
781    float y_max, y_min;    
782    float y_bottom, y_top; 
783    TO_ROW *test_row;      
784    TO_ROW *row;           
785    BLOBNBOX_IT blob_it = &amp;block-&gt;blobs;
786    TO_ROW_IT row_it = block-&gt;get_rows();
787  #ifndef GRAPHICS_DISABLED
788    if (textord_show_expanded_rows &amp;&amp; testing_on) {
789      if (to_win == nullptr) {
790        create_to_win(page_tr);
791      }
792    }
793  #endif
794    adjust_row_limits(block); 
795    if (textord_new_initial_xheight) {
796      if (block-&gt;get_rows()-&gt;empty()) {
797        return;
798      }
799      compute_row_stats(block, textord_show_expanded_rows &amp;&amp; testing_on);
800    }
801    assign_blobs_to_rows(block, &amp;gradient, 4, true, false, false);
802    if (block-&gt;get_rows()-&gt;empty()) {
803      return;
804    }
805    fit_parallel_rows(block, gradient, rotation, block_edge,
806                      textord_show_expanded_rows &amp;&amp; testing_on);
807    if (!textord_new_initial_xheight) {
808      compute_row_stats(block, textord_show_expanded_rows &amp;&amp; testing_on);
809    }
810    row_it.move_to_last();
811    do {
812      row = row_it.data();
813      y_max = row-&gt;max_y(); 
814      y_min = row-&gt;min_y();
815      y_bottom = row-&gt;intercept() - block-&gt;line_size * textord_expansion_factor *
816                                        tesseract::CCStruct::kDescenderFraction;
817      y_top = row-&gt;intercept() +
818              block-&gt;line_size * textord_expansion_factor *
819                  (tesseract::CCStruct::kXHeightFraction + tesseract::CCStruct::kAscenderFraction);
820      if (y_min &gt; y_bottom) { 
821        if (textord_show_expanded_rows &amp;&amp; testing_on) {
822          tprintf(&quot;Expanding bottom of row at %f from %f to %f\n&quot;, row-&gt;intercept(), y_min, y_bottom);
823        }
824        swallowed_row = true;
825        while (swallowed_row &amp;&amp; !row_it.at_last()) {
826          swallowed_row = false;
827          test_row = row_it.data_relative(1);
828          if (test_row-&gt;max_y() &gt; y_bottom) {
829            if (test_row-&gt;min_y() &gt; y_bottom) {
830              if (textord_show_expanded_rows &amp;&amp; testing_on) {
831                tprintf(&quot;Eating row below at %f\n&quot;, test_row-&gt;intercept());
832              }
833              row_it.forward();
834  #ifndef GRAPHICS_DISABLED
835              if (textord_show_expanded_rows &amp;&amp; testing_on) {
836                plot_parallel_row(test_row, gradient, block_edge, ScrollView::WHITE, rotation);
837              }
838  #endif
839              blob_it.set_to_list(row-&gt;blob_list());
840              blob_it.add_list_after(test_row-&gt;blob_list());
841              delete row_it.extract();
842              row_it.backward();
843              swallowed_row = true;
844            } else if (test_row-&gt;max_y() &lt; y_min) {
845              y_bottom = test_row-&gt;max_y();
846              if (textord_show_expanded_rows &amp;&amp; testing_on) {
847                tprintf(&quot;Truncating limit to %f due to touching row at %f\n&quot;, y_bottom,
848                        test_row-&gt;intercept());
849              }
850            } else {
851              y_bottom = y_min; 
852              if (textord_show_expanded_rows &amp;&amp; testing_on) {
853                tprintf(&quot;Not expanding limit beyond %f due to touching row at %f\n&quot;, y_bottom,
854                        test_row-&gt;intercept());
855              }
856            }
857          }
858        }
859        y_min = y_bottom; 
860      }
861      if (y_max &lt; y_top) { 
862        if (textord_show_expanded_rows &amp;&amp; testing_on) {
863          tprintf(&quot;Expanding top of row at %f from %f to %f\n&quot;, row-&gt;intercept(), y_max, y_top);
864        }
865        swallowed_row = true;
866        while (swallowed_row &amp;&amp; !row_it.at_first()) {
867          swallowed_row = false;
868          test_row = row_it.data_relative(-1);
869          if (test_row-&gt;min_y() &lt; y_top) {
870            if (test_row-&gt;max_y() &lt; y_top) {
871              if (textord_show_expanded_rows &amp;&amp; testing_on) {
872                tprintf(&quot;Eating row above at %f\n&quot;, test_row-&gt;intercept());
873              }
874              row_it.backward();
875              blob_it.set_to_list(row-&gt;blob_list());
876  #ifndef GRAPHICS_DISABLED
877              if (textord_show_expanded_rows &amp;&amp; testing_on) {
878                plot_parallel_row(test_row, gradient, block_edge, ScrollView::WHITE, rotation);
879              }
880  #endif
881              blob_it.add_list_after(test_row-&gt;blob_list());
882              delete row_it.extract();
883              row_it.forward();
884              swallowed_row = true;
885            } else if (test_row-&gt;min_y() &lt; y_max) {
886              y_top = test_row-&gt;min_y();
887              if (textord_show_expanded_rows &amp;&amp; testing_on) {
888                tprintf(&quot;Truncating limit to %f due to touching row at %f\n&quot;, y_top,
889                        test_row-&gt;intercept());
890              }
891            } else {
892              y_top = y_max; 
893              if (textord_show_expanded_rows &amp;&amp; testing_on) {
894                tprintf(&quot;Not expanding limit beyond %f due to touching row at %f\n&quot;, y_top,
895                        test_row-&gt;intercept());
896              }
897            }
898          }
899        }
900        y_max = y_top;
901      }
902      row-&gt;set_limits(y_min, y_max);
903      row_it.backward();
904    } while (!row_it.at_last());
905  }
906  void adjust_row_limits( 
907      TO_BLOCK *block     
908  ) {
909    TO_ROW *row; 
910    float size;  
911    float ymax;  
912    float ymin;  
913    TO_ROW_IT row_it = block-&gt;get_rows();
914    if (textord_show_expanded_rows) {
915      tprintf(&quot;Adjusting row limits for block(%d,%d)\n&quot;, block-&gt;block-&gt;pdblk.bounding_box().left(),
916              block-&gt;block-&gt;pdblk.bounding_box().top());
917    }
918    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
919      row = row_it.data();
920      size = row-&gt;max_y() - row-&gt;min_y();
921      if (textord_show_expanded_rows) {
922        tprintf(&quot;Row at %f has min %f, max %f, size %f\n&quot;, row-&gt;intercept(), row-&gt;min_y(),
923                row-&gt;max_y(), size);
924      }
925      size /= tesseract::CCStruct::kXHeightFraction + tesseract::CCStruct::kAscenderFraction +
926              tesseract::CCStruct::kDescenderFraction;
927      ymax = size * (tesseract::CCStruct::kXHeightFraction + tesseract::CCStruct::kAscenderFraction);
928      ymin = -size * tesseract::CCStruct::kDescenderFraction;
929      row-&gt;set_limits(row-&gt;intercept() + ymin, row-&gt;intercept() + ymax);
930      row-&gt;merged = false;
931    }
932  }
933  void compute_row_stats( 
934      TO_BLOCK *block,    
935      bool testing_on     
936  ) {
937    int32_t row_index; 
938    TO_ROW *row;       
939    TO_ROW *prev_row;  
940    float iqr;         
941    TO_ROW_IT row_it = block-&gt;get_rows();
942    int16_t rowcount = row_it.length();
943    std::vector&lt;TO_ROW *&gt; rows(rowcount);
944    rowcount = 0;
945    prev_row = nullptr;
946    row_it.move_to_last(); 
947    do {
948      row = row_it.data();
949      if (prev_row != nullptr) {
950        rows[rowcount++] = prev_row;
951        prev_row-&gt;spacing = row-&gt;intercept() - prev_row-&gt;intercept();
952        if (prev_row-&gt;spacing &lt; 0.1 &amp;&amp; prev_row-&gt;spacing &gt; -0.1) {
953          prev_row-&gt;spacing = 0;
954        }
955        if (testing_on) {
956          tprintf(&quot;Row at %g yields spacing of %g\n&quot;, row-&gt;intercept(), prev_row-&gt;spacing);
957        }
958      }
959      prev_row = row;
960      row_it.backward();
961    } while (!row_it.at_last());
962    block-&gt;key_row = prev_row;
963    block-&gt;baseline_offset = std::fmod(prev_row-&gt;parallel_c(), block-&gt;line_spacing);
964    if (testing_on) {
965      tprintf(&quot;Blob based spacing=(%g,%g), offset=%g&quot;, block-&gt;line_size, block-&gt;line_spacing,
966              block-&gt;baseline_offset);
967    }
968    if (rowcount &gt; 0) {
969      rows.resize(rowcount);
970      row_index = rowcount * 3 / 4;
971      std::nth_element(rows.begin(), rows.begin() + row_index, rows.end(), row_spacing_order);
972      iqr = rows[row_index]-&gt;spacing;
973      row_index = rowcount / 4;
974      std::nth_element(rows.begin(), rows.begin() + row_index, rows.end(), row_spacing_order);
975      iqr -= rows[row_index]-&gt;spacing;
976      row_index = rowcount / 2;
977      std::nth_element(rows.begin(), rows.begin() + row_index, rows.end(), row_spacing_order);
978      block-&gt;key_row = rows[row_index];
979      if (testing_on) {
980        tprintf(&quot; row based=%g(%g)&quot;, rows[row_index]-&gt;spacing, iqr);
981      }
982      if (rowcount &gt; 2 &amp;&amp; iqr &lt; rows[row_index]-&gt;spacing * textord_linespace_iqrlimit) {
983        if (!textord_new_initial_xheight) {
984          if (rows[row_index]-&gt;spacing &lt; block-&gt;line_spacing &amp;&amp;
985              rows[row_index]-&gt;spacing &gt; block-&gt;line_size) {
986            block-&gt;line_size = rows[row_index]-&gt;spacing;
987          } else if (rows[row_index]-&gt;spacing &gt; block-&gt;line_spacing) {
988            block-&gt;line_size = block-&gt;line_spacing;
989          }
990        } else {
991          if (rows[row_index]-&gt;spacing &lt; block-&gt;line_spacing) {
992            block-&gt;line_size = rows[row_index]-&gt;spacing;
993          } else {
994            block-&gt;line_size = block-&gt;line_spacing;
995          }
996        }
997        if (block-&gt;line_size &lt; textord_min_xheight) {
998          block-&gt;line_size = (float)textord_min_xheight;
999        }
1000        block-&gt;line_spacing = rows[row_index]-&gt;spacing;
1001        block-&gt;max_blob_size = block-&gt;line_spacing * textord_excess_blobsize;
1002      }
1003      block-&gt;baseline_offset = std::fmod(rows[row_index]-&gt;intercept(), block-&gt;line_spacing);
1004    }
1005    if (testing_on) {
1006      tprintf(&quot;\nEstimate line size=%g, spacing=%g, offset=%g\n&quot;, block-&gt;line_size,
1007              block-&gt;line_spacing, block-&gt;baseline_offset);
1008    }
1009  }
1010  void Textord::compute_block_xheight(TO_BLOCK *block, float gradient) {
1011    TO_ROW *row; 
1012    float asc_frac_xheight = CCStruct::kAscenderFraction / CCStruct::kXHeightFraction;
1013    float desc_frac_xheight = CCStruct::kDescenderFraction / CCStruct::kXHeightFraction;
1014    int32_t min_height, max_height; 
1015    TO_ROW_IT row_it = block-&gt;get_rows();
1016    if (row_it.empty()) {
1017      return; 
1018    }
1019    get_min_max_xheight(block-&gt;line_size, &amp;min_height, &amp;max_height);
1020    STATS row_asc_xheights(min_height, max_height);
1021    STATS row_asc_ascrise(static_cast&lt;int&gt;(min_height * asc_frac_xheight),
1022                          static_cast&lt;int&gt;(max_height * asc_frac_xheight));
1023    int min_desc_height = static_cast&lt;int&gt;(min_height * desc_frac_xheight);
1024    int max_desc_height = static_cast&lt;int&gt;(max_height * desc_frac_xheight);
1025    STATS row_asc_descdrop(min_desc_height, max_desc_height);
1026    STATS row_desc_xheights(min_height, max_height);
1027    STATS row_desc_descdrop(min_desc_height, max_desc_height);
1028    STATS row_cap_xheights(min_height, max_height);
1029    STATS row_cap_floating_xheights(min_height, max_height);
1030    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1031      row = row_it.data();
1032      if (row-&gt;xheight &lt;= 0) {
1033        compute_row_xheight(row, block-&gt;block-&gt;classify_rotation(), gradient, block-&gt;line_size);
1034      }
1035      ROW_CATEGORY row_category = get_row_category(row);
1036      if (row_category == ROW_ASCENDERS_FOUND) {
1037        row_asc_xheights.add(static_cast&lt;int32_t&gt;(row-&gt;xheight), row-&gt;xheight_evidence);
1038        row_asc_ascrise.add(static_cast&lt;int32_t&gt;(row-&gt;ascrise), row-&gt;xheight_evidence);
1039        row_asc_descdrop.add(static_cast&lt;int32_t&gt;(-row-&gt;descdrop), row-&gt;xheight_evidence);
1040      } else if (row_category == ROW_DESCENDERS_FOUND) {
1041        row_desc_xheights.add(static_cast&lt;int32_t&gt;(row-&gt;xheight), row-&gt;xheight_evidence);
1042        row_desc_descdrop.add(static_cast&lt;int32_t&gt;(-row-&gt;descdrop), row-&gt;xheight_evidence);
1043      } else if (row_category == ROW_UNKNOWN) {
1044        fill_heights(row, gradient, min_height, max_height, &amp;row_cap_xheights,
1045                     &amp;row_cap_floating_xheights);
1046      }
1047    }
1048    float xheight = 0.0;
1049    float ascrise = 0.0;
1050    float descdrop = 0.0;
1051    if (row_asc_xheights.get_total() &gt; 0) {
1052      xheight = row_asc_xheights.median();
1053      ascrise = row_asc_ascrise.median();
1054      descdrop = -row_asc_descdrop.median();
1055    } else if (row_desc_xheights.get_total() &gt; 0) {
1056      xheight = row_desc_xheights.median();
1057      descdrop = -row_desc_descdrop.median();
1058    } else if (row_cap_xheights.get_total() &gt; 0) {
1059      compute_xheight_from_modes(
1060          &amp;row_cap_xheights, &amp;row_cap_floating_xheights,
1061          textord_single_height_mode &amp;&amp; block-&gt;block-&gt;classify_rotation().y() == 0.0, min_height,
1062          max_height, &amp;(xheight), &amp;(ascrise));
1063      if (ascrise == 0) { 
1064        xheight = row_cap_xheights.median() * CCStruct::kXHeightCapRatio;
1065      }
1066    } else { 
1067      xheight = block-&gt;line_size * CCStruct::kXHeightFraction;
1068    }
1069    bool corrected_xheight = false;
1070    if (xheight &lt; textord_min_xheight) {
1071      xheight = static_cast&lt;float&gt;(textord_min_xheight);
1072      corrected_xheight = true;
1073    }
1074    if (corrected_xheight || ascrise &lt;= 0) {
1075      ascrise = xheight * asc_frac_xheight;
1076    }
1077    if (corrected_xheight || descdrop &gt;= 0) {
1078      descdrop = -(xheight * desc_frac_xheight);
1079    }
1080    block-&gt;xheight = xheight;
1081    if (textord_debug_xheights) {
1082      tprintf(&quot;Block average xheight=%.4f, ascrise=%.4f, descdrop=%.4f\n&quot;, xheight, ascrise,
1083              descdrop);
1084    }
1085    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1086      correct_row_xheight(row_it.data(), xheight, ascrise, descdrop);
1087    }
1088  }
1089  void Textord::compute_row_xheight(TO_ROW *row, 
1090                                    const FCOORD &amp;rotation,
1091                                    float gradient, 
1092                                    int block_line_size) {
1093    if (!row-&gt;rep_chars_marked()) {
1094      mark_repeated_chars(row);
1095    }
1096    int min_height, max_height;
1097    get_min_max_xheight(block_line_size, &amp;min_height, &amp;max_height);
1098    STATS heights(min_height, max_height);
1099    STATS floating_heights(min_height, max_height);
1100    fill_heights(row, gradient, min_height, max_height, &amp;heights, &amp;floating_heights);
1101    row-&gt;ascrise = 0.0f;
1102    row-&gt;xheight = 0.0f;
1103    row-&gt;xheight_evidence = compute_xheight_from_modes(
1104        &amp;heights, &amp;floating_heights, textord_single_height_mode &amp;&amp; rotation.y() == 0.0, min_height,
1105        max_height, &amp;(row-&gt;xheight), &amp;(row-&gt;ascrise));
1106    row-&gt;descdrop = 0.0f;
1107    if (row-&gt;xheight &gt; 0) {
1108      row-&gt;descdrop =
1109          static_cast&lt;float&gt;(compute_row_descdrop(row, gradient, row-&gt;xheight_evidence, &amp;heights));
1110    }
1111  }
1112  void fill_heights(TO_ROW *row, float gradient, int min_height, int max_height, STATS *heights,
1113                    STATS *floating_heights) {
1114    float xcentre;  
1115    float top;      
1116    float height;   
1117    BLOBNBOX *blob; 
1118    int repeated_set;
1119    BLOBNBOX_IT blob_it = row-&gt;blob_list();
1120    if (blob_it.empty()) {
1121      return; 
1122    }
1123    bool has_rep_chars = row-&gt;rep_chars_marked() &amp;&amp; row-&gt;num_repeated_sets() &gt; 0;
1124    do {
1125      blob = blob_it.data();
1126      if (!blob-&gt;joined_to_prev()) {
1127        xcentre = (blob-&gt;bounding_box().left() + blob-&gt;bounding_box().right()) / 2.0f;
1128        top = blob-&gt;bounding_box().top();
1129        height = blob-&gt;bounding_box().height();
1130        if (textord_fix_xheight_bug) {
1131          top -= row-&gt;baseline.y(xcentre);
1132        } else {
1133          top -= gradient * xcentre + row-&gt;parallel_c();
1134        }
1135        if (top &gt;= min_height &amp;&amp; top &lt;= max_height) {
1136          heights-&gt;add(static_cast&lt;int32_t&gt;(floor(top + 0.5)), 1);
1137          if (height / top &lt; textord_min_blob_height_fraction) {
1138            floating_heights-&gt;add(static_cast&lt;int32_t&gt;(floor(top + 0.5)), 1);
1139          }
1140        }
1141      }
1142      if (has_rep_chars &amp;&amp; blob-&gt;repeated_set() != 0) {
1143        repeated_set = blob-&gt;repeated_set();
1144        blob_it.forward();
1145        while (!blob_it.at_first() &amp;&amp; blob_it.data()-&gt;repeated_set() == repeated_set) {
1146          blob_it.forward();
1147          if (textord_debug_xheights) {
1148            tprintf(&quot;Skipping repeated char when computing xheight\n&quot;);
1149          }
1150        }
1151      } else {
1152        blob_it.forward();
1153      }
1154    } while (!blob_it.at_first());
1155  }
1156  int compute_xheight_from_modes(STATS *heights, STATS *floating_heights, bool cap_only,
1157                                 int min_height, int max_height, float *xheight, float *ascrise) {
1158    int blob_index = heights-&gt;mode();                 
1159    int blob_count = heights-&gt;pile_count(blob_index); 
1160    if (textord_debug_xheights) {
1161      tprintf(&quot;min_height=%d, max_height=%d, mode=%d, count=%d, total=%d\n&quot;, min_height, max_height,
1162              blob_index, blob_count, heights-&gt;get_total());
1163      heights-&gt;print();
1164      floating_heights-&gt;print();
1165    }
1166    if (blob_count == 0) {
1167      return 0;
1168    }
1169    int modes[MAX_HEIGHT_MODES]; 
1170    bool in_best_pile = false;
1171    int prev_size = -INT32_MAX;
1172    int best_count = 0;
1173    int mode_count = compute_height_modes(heights, min_height, max_height, modes, MAX_HEIGHT_MODES);
1174    if (cap_only &amp;&amp; mode_count &gt; 1) {
1175      mode_count = 1;
1176    }
1177    int x;
1178    if (textord_debug_xheights) {
1179      tprintf(&quot;found %d modes: &quot;, mode_count);
1180      for (x = 0; x &lt; mode_count; x++) {
1181        tprintf(&quot;%d &quot;, modes[x]);
1182      }
1183      tprintf(&quot;\n&quot;);
1184    }
1185    for (x = 0; x &lt; mode_count - 1; x++) {
1186      if (modes[x] != prev_size + 1) {
1187        in_best_pile = false; 
1188      }
1189      int modes_x_count = heights-&gt;pile_count(modes[x]) - floating_heights-&gt;pile_count(modes[x]);
1190      if ((modes_x_count &gt;= blob_count * textord_xheight_mode_fraction) &amp;&amp;
1191          (in_best_pile || modes_x_count &gt; best_count)) {
1192        for (int asc = x + 1; asc &lt; mode_count; asc++) {
1193          float ratio = static_cast&lt;float&gt;(modes[asc]) / static_cast&lt;float&gt;(modes[x]);
1194          if (textord_ascx_ratio_min &lt; ratio &amp;&amp; ratio &lt; textord_ascx_ratio_max &amp;&amp;
1195              (heights-&gt;pile_count(modes[asc]) &gt;= blob_count * textord_ascheight_mode_fraction)) {
1196            if (modes_x_count &gt; best_count) {
1197              in_best_pile = true;
1198              best_count = modes_x_count;
1199            }
1200            if (textord_debug_xheights) {
1201              tprintf(&quot;X=%d, asc=%d, count=%d, ratio=%g\n&quot;, modes[x], modes[asc] - modes[x],
1202                      modes_x_count, ratio);
1203            }
1204            prev_size = modes[x];
1205            *xheight = static_cast&lt;float&gt;(modes[x]);
1206            *ascrise = static_cast&lt;float&gt;(modes[asc] - modes[x]);
1207          }
1208        }
1209      }
1210    }
1211    if (*xheight == 0) { 
1212      if (floating_heights-&gt;get_total() &gt; 0) {
1213        for (x = min_height; x &lt; max_height; ++x) {
1214          heights-&gt;add(x, -(floating_heights-&gt;pile_count(x)));
1215        }
1216        blob_index = heights-&gt;mode(); 
1217        for (x = min_height; x &lt; max_height; ++x) {
1218          heights-&gt;add(x, floating_heights-&gt;pile_count(x));
1219        }
1220      }
1221      *xheight = static_cast&lt;float&gt;(blob_index);
1222      *ascrise = 0.0f;
1223      best_count = heights-&gt;pile_count(blob_index);
1224      if (textord_debug_xheights) {
1225        tprintf(&quot;Single mode xheight set to %g\n&quot;, *xheight);
1226      }
1227    } else if (textord_debug_xheights) {
1228      tprintf(&quot;Multi-mode xheight set to %g, asc=%g\n&quot;, *xheight, *ascrise);
1229    }
1230    return best_count;
1231  }
1232  int32_t compute_row_descdrop(TO_ROW *row, float gradient, int xheight_blob_count,
1233                               STATS *asc_heights) {
1234    int i_min = asc_heights-&gt;min_bucket();
1235    if ((i_min / row-&gt;xheight) &lt; textord_ascx_ratio_min) {
1236      i_min = static_cast&lt;int&gt;(floor(row-&gt;xheight * textord_ascx_ratio_min + 0.5));
1237    }
1238    int i_max = asc_heights-&gt;max_bucket();
1239    if ((i_max / row-&gt;xheight) &gt; textord_ascx_ratio_max) {
1240      i_max = static_cast&lt;int&gt;(floor(row-&gt;xheight * textord_ascx_ratio_max));
1241    }
1242    int num_potential_asc = 0;
1243    for (int i = i_min; i &lt;= i_max; ++i) {
1244      num_potential_asc += asc_heights-&gt;pile_count(i);
1245    }
1246    auto min_height = static_cast&lt;int32_t&gt;(floor(row-&gt;xheight * textord_descx_ratio_min + 0.5));
1247    auto max_height = static_cast&lt;int32_t&gt;(floor(row-&gt;xheight * textord_descx_ratio_max));
1248    float xcentre; 
1249    float height;  
1250    BLOBNBOX_IT blob_it = row-&gt;blob_list();
1251    BLOBNBOX *blob; 
1252    STATS heights(min_height, max_height);
1253    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1254      blob = blob_it.data();
1255      if (!blob-&gt;joined_to_prev()) {
1256        xcentre = (blob-&gt;bounding_box().left() + blob-&gt;bounding_box().right()) / 2.0f;
1257        height = (gradient * xcentre + row-&gt;parallel_c() - blob-&gt;bounding_box().bottom());
1258        if (height &gt;= min_height &amp;&amp; height &lt;= max_height) {
1259          heights.add(static_cast&lt;int&gt;(floor(height + 0.5)), 1);
1260        }
1261      }
1262    }
1263    int blob_index = heights.mode();                 
1264    int blob_count = heights.pile_count(blob_index); 
1265    float total_fraction = (textord_descheight_mode_fraction + textord_ascheight_mode_fraction);
1266    if (static_cast&lt;float&gt;(blob_count + num_potential_asc) &lt; xheight_blob_count * total_fraction) {
1267      blob_count = 0;
1268    }
1269    int descdrop = blob_count &gt; 0 ? -blob_index : 0;
1270    if (textord_debug_xheights) {
1271      tprintf(&quot;Descdrop: %d (potential ascenders %d, descenders %d)\n&quot;, descdrop, num_potential_asc,
1272              blob_count);
1273      heights.print();
1274    }
1275    return descdrop;
1276  }
1277  int32_t compute_height_modes(STATS *heights,     
1278                               int32_t min_height, 
1279                               int32_t max_height, 
1280                               int32_t *modes,     
1281                               int32_t maxmodes) { 
1282    int32_t pile_count;                            
1283    int32_t src_count;                             
1284    int32_t src_index;                             
1285    int32_t least_count;                           
1286    int32_t least_index;                           
1287    int32_t dest_count;                            
1288    src_count = max_height + 1 - min_height;
1289    dest_count = 0;
1290    least_count = INT32_MAX;
1291    least_index = -1;
1292    for (src_index = 0; src_index &lt; src_count; src_index++) {
1293      pile_count = heights-&gt;pile_count(min_height + src_index);
1294      if (pile_count &gt; 0) {
1295        if (dest_count &lt; maxmodes) {
1296          if (pile_count &lt; least_count) {
1297            least_count = pile_count;
1298            least_index = dest_count;
1299          }
1300          modes[dest_count++] = min_height + src_index;
1301        } else if (pile_count &gt;= least_count) {
1302          while (least_index &lt; maxmodes - 1) {
1303            modes[least_index] = modes[least_index + 1];
1304            least_index++;
1305          }
1306          modes[maxmodes - 1] = min_height + src_index;
1307          if (pile_count == least_count) {
1308            least_index = maxmodes - 1;
1309          } else {
1310            least_count = heights-&gt;pile_count(modes[0]);
1311            least_index = 0;
1312            for (dest_count = 1; dest_count &lt; maxmodes; dest_count++) {
1313              pile_count = heights-&gt;pile_count(modes[dest_count]);
1314              if (pile_count &lt; least_count) {
1315                least_count = pile_count;
1316                least_index = dest_count;
1317              }
1318            }
1319          }
1320        }
1321      }
1322    }
1323    return dest_count;
1324  }
1325  void correct_row_xheight(TO_ROW *row, float xheight, float ascrise, float descdrop) {
1326    ROW_CATEGORY row_category = get_row_category(row);
1327    if (textord_debug_xheights) {
1328      tprintf(
1329          &quot;correcting row xheight: row-&gt;xheight %.4f&quot;
1330          &quot;, row-&gt;acrise %.4f row-&gt;descdrop %.4f\n&quot;,
1331          row-&gt;xheight, row-&gt;ascrise, row-&gt;descdrop);
1332    }
1333    bool normal_xheight = within_error_margin(row-&gt;xheight, xheight, textord_xheight_error_margin);
1334    bool cap_xheight =
1335        within_error_margin(row-&gt;xheight, xheight + ascrise, textord_xheight_error_margin);
1336    if (row_category == ROW_ASCENDERS_FOUND) {
1337      if (row-&gt;descdrop &gt;= 0) {
1338        row-&gt;descdrop = row-&gt;xheight * (descdrop / xheight);
1339      }
1340    } else if (row_category == ROW_INVALID ||
1341               (row_category == ROW_DESCENDERS_FOUND &amp;&amp; (normal_xheight || cap_xheight)) ||
1342               (row_category == ROW_UNKNOWN &amp;&amp; normal_xheight)) {
1343      if (textord_debug_xheights) {
1344        tprintf(&quot;using average xheight\n&quot;);
1345      }
1346      row-&gt;xheight = xheight;
1347      row-&gt;ascrise = ascrise;
1348      row-&gt;descdrop = descdrop;
1349    } else if (row_category == ROW_DESCENDERS_FOUND) {
1350      if (textord_debug_xheights) {
1351        tprintf(&quot;lowercase, corrected ascrise\n&quot;);
1352      }
1353      row-&gt;ascrise = row-&gt;xheight * (ascrise / xheight);
1354    } else if (row_category == ROW_UNKNOWN) {
1355      row-&gt;all_caps = true;
1356      if (cap_xheight) { 
1357        if (textord_debug_xheights) {
1358          tprintf(&quot;all caps\n&quot;);
1359        }
1360        row-&gt;xheight = xheight;
1361        row-&gt;ascrise = ascrise;
1362        row-&gt;descdrop = descdrop;
1363      } else { 
1364        if (textord_debug_xheights) {
1365          if (row-&gt;xheight &lt; xheight + ascrise &amp;&amp; row-&gt;xheight &gt; xheight) {
1366            tprintf(&quot;small caps\n&quot;);
1367          } else {
1368            tprintf(&quot;all caps with irregular xheight\n&quot;);
1369          }
1370        }
1371        row-&gt;ascrise = row-&gt;xheight * (ascrise / (xheight + ascrise));
1372        row-&gt;xheight -= row-&gt;ascrise;
1373        row-&gt;descdrop = row-&gt;xheight * (descdrop / xheight);
1374      }
1375    }
1376    if (textord_debug_xheights) {
1377      tprintf(
1378          &quot;corrected row-&gt;xheight = %.4f, row-&gt;acrise = %.4f, row-&gt;descdrop&quot;
1379          &quot; = %.4f\n&quot;,
1380          row-&gt;xheight, row-&gt;ascrise, row-&gt;descdrop);
1381    }
1382  }
1383  static int CountOverlaps(const TBOX &amp;box, int min_height, BLOBNBOX_LIST *blobs) {
1384    int overlaps = 0;
1385    BLOBNBOX_IT blob_it(blobs);
1386    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1387      BLOBNBOX *blob = blob_it.data();
1388      const TBOX &amp;blob_box = blob-&gt;bounding_box();
1389      if (blob_box.height() &gt;= min_height &amp;&amp; box.major_overlap(blob_box)) {
1390        ++overlaps;
1391      }
1392    }
1393    return overlaps;
1394  }
1395  void separate_underlines(TO_BLOCK *block,   
1396                           float gradient,    
1397                           FCOORD rotation,   
1398                           bool testing_on) { 
1399    BLOBNBOX *blob;                           
1400    C_BLOB *rotated_blob;                     
1401    TO_ROW *row;                              
1402    float length;                             
1403    TBOX blob_box;
1404    FCOORD blob_rotation; 
1405    FCOORD g_vec;         
1406    BLOBNBOX_IT blob_it;  
1407    BLOBNBOX_IT under_it = &amp;block-&gt;underlines;
1408    BLOBNBOX_IT large_it = &amp;block-&gt;large_blobs;
1409    TO_ROW_IT row_it = block-&gt;get_rows();
1410    int min_blob_height = static_cast&lt;int&gt;(textord_min_blob_height_fraction * block-&gt;line_size + 0.5);
1411    length = std::sqrt(1 + gradient * gradient);
1412    g_vec = FCOORD(1 / length, -gradient / length);
1413    blob_rotation = FCOORD(rotation.x(), -rotation.y());
1414    blob_rotation.rotate(g_vec); 
1415    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1416      row = row_it.data();
1417      blob_it.set_to_list(row-&gt;blob_list());
1418      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1419        blob = blob_it.data();
1420        blob_box = blob-&gt;bounding_box();
1421        if (blob_box.width() &gt; block-&gt;line_size * textord_underline_width) {
1422          ASSERT_HOST(blob-&gt;cblob() != nullptr);
1423          rotated_blob = crotate_cblob(blob-&gt;cblob(), blob_rotation);
1424          if (test_underline(testing_on &amp;&amp; textord_show_final_rows, rotated_blob,
1425                             static_cast&lt;int16_t&gt;(row-&gt;intercept()),
1426                             static_cast&lt;int16_t&gt;(block-&gt;line_size *
1427                                                  (tesseract::CCStruct::kXHeightFraction +
1428                                                   tesseract::CCStruct::kAscenderFraction / 2.0f)))) {
1429            under_it.add_after_then_move(blob_it.extract());
1430            if (testing_on &amp;&amp; textord_show_final_rows) {
1431              tprintf(&quot;Underlined blob at:&quot;);
1432              rotated_blob-&gt;bounding_box().print();
1433              tprintf(&quot;Was:&quot;);
1434              blob_box.print();
1435            }
1436          } else if (CountOverlaps(blob-&gt;bounding_box(), min_blob_height, row-&gt;blob_list()) &gt;
1437                     textord_max_blob_overlaps) {
1438            large_it.add_after_then_move(blob_it.extract());
1439            if (testing_on &amp;&amp; textord_show_final_rows) {
1440              tprintf(&quot;Large blob overlaps %d blobs at:&quot;,
1441                      CountOverlaps(blob_box, min_blob_height, row-&gt;blob_list()));
1442              blob_box.print();
1443            }
1444          }
1445          delete rotated_blob;
1446        }
1447      }
1448    }
1449  }
1450  void pre_associate_blobs( 
1451      ICOORD page_tr,       
1452      TO_BLOCK *block,      
1453      FCOORD rotation,      
1454      bool testing_on       
1455  ) {
1456  #ifndef GRAPHICS_DISABLED
1457    ScrollView::Color colour; 
1458  #endif
1459    BLOBNBOX *blob;     
1460    BLOBNBOX *nextblob; 
1461    TBOX blob_box;
1462    FCOORD blob_rotation; 
1463    BLOBNBOX_IT blob_it;  
1464    BLOBNBOX_IT start_it; 
1465    TO_ROW_IT row_it = block-&gt;get_rows();
1466  #ifndef GRAPHICS_DISABLED
1467    colour = ScrollView::RED;
1468  #endif
1469    blob_rotation = FCOORD(rotation.x(), -rotation.y());
1470    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1471      blob_it.set_to_list(row_it.data()-&gt;blob_list());
1472      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1473        blob = blob_it.data();
1474        blob_box = blob-&gt;bounding_box();
1475        start_it = blob_it; 
1476        bool overlap;
1477        do {
1478          overlap = false;
1479          if (!blob_it.at_last()) {
1480            nextblob = blob_it.data_relative(1);
1481            overlap = blob_box.major_x_overlap(nextblob-&gt;bounding_box());
1482            if (overlap) {
1483              blob-&gt;merge(nextblob);           
1484              blob_box = blob-&gt;bounding_box(); 
1485              blob_it.forward();
1486            }
1487          }
1488        } while (overlap);
1489        blob-&gt;chop(&amp;start_it, &amp;blob_it, blob_rotation,
1490                   block-&gt;line_size * tesseract::CCStruct::kXHeightFraction * textord_chop_width);
1491      }
1492  #ifndef GRAPHICS_DISABLED
1493      if (testing_on &amp;&amp; textord_show_final_blobs) {
1494        if (to_win == nullptr) {
1495          create_to_win(page_tr);
1496        }
1497        to_win-&gt;Pen(colour);
1498        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1499          blob = blob_it.data();
1500          blob_box = blob-&gt;bounding_box();
1501          blob_box.rotate(rotation);
1502          if (!blob-&gt;joined_to_prev()) {
1503            to_win-&gt;Rectangle(blob_box.left(), blob_box.bottom(), blob_box.right(), blob_box.top());
1504          }
1505        }
1506        colour = static_cast&lt;ScrollView::Color&gt;(colour + 1);
1507        if (colour &gt; ScrollView::MAGENTA) {
1508          colour = ScrollView::RED;
1509        }
1510      }
1511  #endif
1512    }
1513  }
1514  void fit_parallel_rows( 
1515      TO_BLOCK *block,    
1516      float gradient,     
1517      FCOORD rotation,    
1518      int32_t block_edge, 
1519      bool testing_on     
1520  ) {
1521  #ifndef GRAPHICS_DISABLED
1522    ScrollView::Color colour; 
1523  #endif
1524    TO_ROW_IT row_it = block-&gt;get_rows();
1525    row_it.move_to_first();
1526    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1527      if (row_it.data()-&gt;blob_list()-&gt;empty()) {
1528        delete row_it.extract(); 
1529      } else {
1530        fit_parallel_lms(gradient, row_it.data());
1531      }
1532    }
1533  #ifndef GRAPHICS_DISABLED
1534    if (testing_on) {
1535      colour = ScrollView::RED;
1536      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1537        plot_parallel_row(row_it.data(), gradient, block_edge, colour, rotation);
1538        colour = static_cast&lt;ScrollView::Color&gt;(colour + 1);
1539        if (colour &gt; ScrollView::MAGENTA) {
1540          colour = ScrollView::RED;
1541        }
1542      }
1543    }
1544  #endif
1545    row_it.sort(row_y_order); 
1546  }
1547  void fit_parallel_lms(float gradient, TO_ROW *row) {
1548    float c;       
1549    int blobcount; 
1550    tesseract::DetLineFit lms;
1551    BLOBNBOX_IT blob_it = row-&gt;blob_list();
1552    blobcount = 0;
1553    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1554      if (!blob_it.data()-&gt;joined_to_prev()) {
1555        const TBOX &amp;box = blob_it.data()-&gt;bounding_box();
1556        lms.Add(ICOORD((box.left() + box.right()) / 2, box.bottom()));
1557        blobcount++;
1558      }
1559    }
1560    double error = lms.ConstrainedFit(gradient, &amp;c);
1561    row-&gt;set_parallel_line(gradient, c, error);
1562    if (textord_straight_baselines &amp;&amp; blobcount &gt; textord_lms_line_trials) {
1563      error = lms.Fit(&amp;gradient, &amp;c);
1564    }
1565    row-&gt;set_line(gradient, c, error);
1566  }
1567  void Textord::make_spline_rows(TO_BLOCK *block, 
1568                                 float gradient,  
1569                                 bool testing_on) {
1570  #ifndef GRAPHICS_DISABLED
1571    ScrollView::Color colour; 
1572    if (testing_on &amp;&amp; to_win == nullptr) {
1573      create_to_win(page_tr_);
1574    }
1575  #endif
1576    TO_ROW_IT row_it = block-&gt;get_rows();
1577    row_it.move_to_first();
1578    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1579      if (row_it.data()-&gt;blob_list()-&gt;empty()) {
1580        delete row_it.extract(); 
1581      } else {
1582        make_baseline_spline(row_it.data(), block);
1583      }
1584    }
1585    if (textord_old_baselines) {
1586  #ifndef GRAPHICS_DISABLED
1587      if (testing_on) {
1588        colour = ScrollView::RED;
1589        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1590          row_it.data()-&gt;baseline.plot(to_win, colour);
1591          colour = static_cast&lt;ScrollView::Color&gt;(colour + 1);
1592          if (colour &gt; ScrollView::MAGENTA) {
1593            colour = ScrollView::RED;
1594          }
1595        }
1596      }
1597  #endif
1598      make_old_baselines(block, testing_on, gradient);
1599    }
1600  #ifndef GRAPHICS_DISABLED
1601    if (testing_on) {
1602      colour = ScrollView::RED;
1603      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1604        row_it.data()-&gt;baseline.plot(to_win, colour);
1605        colour = static_cast&lt;ScrollView::Color&gt;(colour + 1);
1606        if (colour &gt; ScrollView::MAGENTA) {
1607          colour = ScrollView::RED;
1608        }
1609      }
1610    }
1611  #endif
1612  }
1613  void make_baseline_spline(TO_ROW *row, 
1614                            TO_BLOCK *block) {
1615    double *coeffs;   
1616    int32_t segments; 
1617    auto *xstarts = new int32_t[row-&gt;blob_list()-&gt;length() + 1];
1618    if (segment_baseline(row, block, segments, xstarts) &amp;&amp; !textord_straight_baselines &amp;&amp;
1619        !textord_parallel_baselines) {
1620      coeffs = linear_spline_baseline(row, block, segments, xstarts);
1621    } else {
1622      xstarts[1] = xstarts[segments];
1623      segments = 1;
1624      coeffs = new double[3];
1625      coeffs[0] = 0;
1626      coeffs[1] = row-&gt;line_m();
1627      coeffs[2] = row-&gt;line_c();
1628    }
1629    row-&gt;baseline = QSPLINE(segments, xstarts, coeffs);
1630    delete[] coeffs;
1631    delete[] xstarts;
1632  }
1633  bool segment_baseline( 
1634      TO_ROW *row,       
1635      TO_BLOCK *block,   
1636      int32_t &amp;segments, 
1637      int32_t *xstarts   
1638  ) {
1639    bool needs_curve; 
1640    int blobcount;    
1641    int blobindex;    
1642    int last_state;   
1643    int state;        
1644    float yshift;     
1645    TBOX box;         
1646    TBOX new_box;     
1647    float middle;     
1648    BLOBNBOX_IT blob_it = row-&gt;blob_list();
1649    BLOBNBOX_IT new_it = blob_it; 
1650    SORTED_FLOATS yshifts;        
1651    needs_curve = false;
1652    box = box_next_pre_chopped(&amp;blob_it);
1653    xstarts[0] = box.left();
1654    segments = 1;
1655    blobcount = row-&gt;blob_list()-&gt;length();
1656    if (textord_oldbl_debug) {
1657      tprintf(&quot;Segmenting baseline of %d blobs at (%d,%d)\n&quot;, blobcount, box.left(), box.bottom());
1658    }
1659    if (blobcount &lt;= textord_spline_medianwin || blobcount &lt; textord_spline_minblobs) {
1660      blob_it.move_to_last();
1661      box = blob_it.data()-&gt;bounding_box();
1662      xstarts[1] = box.right();
1663      return false;
1664    }
1665    last_state = 0;
1666    new_it.mark_cycle_pt();
1667    for (blobindex = 0; blobindex &lt; textord_spline_medianwin; blobindex++) {
1668      new_box = box_next_pre_chopped(&amp;new_it);
1669      middle = (new_box.left() + new_box.right()) / 2.0;
1670      yshift = new_box.bottom() - row-&gt;line_m() * middle - row-&gt;line_c();
1671      yshifts.add(yshift, blobindex);
1672      if (new_it.cycled_list()) {
1673        xstarts[1] = new_box.right();
1674        return false;
1675      }
1676    }
1677    for (blobcount = 0; blobcount &lt; textord_spline_medianwin / 2; blobcount++) {
1678      box = box_next_pre_chopped(&amp;blob_it);
1679    }
1680    do {
1681      new_box = box_next_pre_chopped(&amp;new_it);
1682      yshift = yshifts[textord_spline_medianwin / 2];
1683      if (yshift &gt; textord_spline_shift_fraction * block-&gt;line_size) {
1684        state = 1;
1685      } else if (-yshift &gt; textord_spline_shift_fraction * block-&gt;line_size) {
1686        state = -1;
1687      } else {
1688        state = 0;
1689      }
1690      if (state != 0) {
1691        needs_curve = true;
1692      }
1693      if (state != last_state &amp;&amp; blobcount &gt; textord_spline_minblobs) {
1694        xstarts[segments++] = box.left();
1695        blobcount = 0;
1696      }
1697      last_state = state;
1698      yshifts.remove(blobindex - textord_spline_medianwin);
1699      box = box_next_pre_chopped(&amp;blob_it);
1700      middle = (new_box.left() + new_box.right()) / 2.0;
1701      yshift = new_box.bottom() - row-&gt;line_m() * middle - row-&gt;line_c();
1702      yshifts.add(yshift, blobindex);
1703      blobindex++;
<span onclick='openModal()' class='match'>1704      blobcount++;
1705    } while (!new_it.cycled_list());
1706    if (blobcount &gt; textord_spline_minblobs || segments == 1) {
</span>1707      xstarts[segments] = new_box.right();
1708    } else {
1709      xstarts[--segments] = new_box.right();
1710    }
1711    if (textord_oldbl_debug) {
1712      tprintf(&quot;Made %d segments on row at (%d,%d)\n&quot;, segments, box.right(), box.bottom());
1713    }
1714    return needs_curve;
1715  }
1716  double *linear_spline_baseline( 
1717      TO_ROW *row,                
1718      TO_BLOCK *block,            
1719      int32_t &amp;segments,          
1720      int32_t xstarts[]           
1721  ) {
1722    int blobcount;         
1723    int blobindex;         
1724    int index1, index2;    
1725    int blobs_per_segment; 
1726    TBOX box;              
1727    TBOX new_box;          
1728    BLOBNBOX_IT blob_it = row-&gt;blob_list();
1729    BLOBNBOX_IT new_it = blob_it; 
1730    float b, c;                   
1731    tesseract::DetLineFit lms;
1732    int32_t segment; 
1733    box = box_next_pre_chopped(&amp;blob_it);
1734    xstarts[0] = box.left();
1735    blobcount = 1;
1736    while (!blob_it.at_first()) {
1737      blobcount++;
1738      box = box_next_pre_chopped(&amp;blob_it);
1739    }
1740    segments = blobcount / textord_spline_medianwin;
1741    if (segments &lt; 1) {
1742      segments = 1;
1743    }
1744    blobs_per_segment = blobcount / segments;
1745    auto *coeffs = new double[segments * 3];
1746    if (textord_oldbl_debug) {
1747      tprintf(
1748          &quot;Linear splining baseline of %d blobs at (%d,%d), into %d segments of &quot;
1749          &quot;%d blobs\n&quot;,
1750          blobcount, box.left(), box.bottom(), segments, blobs_per_segment);
1751    }
1752    segment = 1;
1753    for (index2 = 0; index2 &lt; blobs_per_segment / 2; index2++) {
1754      box_next_pre_chopped(&amp;new_it);
1755    }
1756    index1 = 0;
1757    blobindex = index2;
1758    do {
1759      blobindex += blobs_per_segment;
1760      lms.Clear();
1761      while (index1 &lt; blobindex || (segment == segments &amp;&amp; index1 &lt; blobcount)) {
1762        box = box_next_pre_chopped(&amp;blob_it);
1763        int middle = (box.left() + box.right()) / 2;
1764        lms.Add(ICOORD(middle, box.bottom()));
1765        index1++;
1766        if (index1 == blobindex - blobs_per_segment / 2 || index1 == blobcount - 1) {
1767          xstarts[segment] = box.left();
1768        }
1769      }
1770      lms.Fit(&amp;b, &amp;c);
1771      coeffs[segment * 3 - 3] = 0;
1772      coeffs[segment * 3 - 2] = b;
1773      coeffs[segment * 3 - 1] = c;
1774      segment++;
1775      if (segment &gt; segments) {
1776        break;
1777      }
1778      blobindex += blobs_per_segment;
1779      lms.Clear();
1780      while (index2 &lt; blobindex || (segment == segments &amp;&amp; index2 &lt; blobcount)) {
1781        new_box = box_next_pre_chopped(&amp;new_it);
1782        int middle = (new_box.left() + new_box.right()) / 2;
1783        lms.Add(ICOORD(middle, new_box.bottom()));
1784        index2++;
1785        if (index2 == blobindex - blobs_per_segment / 2 || index2 == blobcount - 1) {
1786          xstarts[segment] = new_box.left();
1787        }
1788      }
1789      lms.Fit(&amp;b, &amp;c);
1790      coeffs[segment * 3 - 3] = 0;
1791      coeffs[segment * 3 - 2] = b;
1792      coeffs[segment * 3 - 1] = c;
1793      segment++;
1794    } while (segment &lt;= segments);
1795    return coeffs;
1796  }
1797  void assign_blobs_to_rows( 
1798      TO_BLOCK *block,       
1799      float *gradient,       
1800      int pass,              
1801      bool reject_misses,    
1802      bool make_new_rows,    
1803      bool drawing_skew      
1804  ) {
1805    OVERLAP_STATE overlap_result; 
1806    float ycoord;                 
1807    float top, bottom;            
1808    float g_length = 1.0f;        
1809    int16_t row_count;            
1810    int16_t left_x;               
1811    int16_t last_x;               
1812    float block_skew;             
1813    float smooth_factor;          
1814    float near_dist;              
1815    ICOORD testpt;                
1816    BLOBNBOX *blob;               
1817    TO_ROW *row;                  
1818    TO_ROW *dest_row = nullptr;   
1819    BLOBNBOX_IT blob_it = &amp;block-&gt;blobs;
1820    TO_ROW_IT row_it = block-&gt;get_rows();
1821    ycoord =
1822        (block-&gt;block-&gt;pdblk.bounding_box().bottom() + block-&gt;block-&gt;pdblk.bounding_box().top()) /
1823        2.0f;
1824    if (gradient != nullptr) {
1825      g_length = std::sqrt(1 + *gradient * *gradient);
1826    }
1827  #ifndef GRAPHICS_DISABLED
1828    if (drawing_skew) {
1829      to_win-&gt;SetCursor(block-&gt;block-&gt;pdblk.bounding_box().left(), ycoord);
1830    }
1831  #endif
1832    testpt = ICOORD(textord_test_x, textord_test_y);
1833    blob_it.sort(blob_x_order);
1834    smooth_factor = 1.0;
1835    block_skew = 0.0f;
1836    row_count = row_it.length(); 
1837    if (!blob_it.empty()) {
1838      left_x = blob_it.data()-&gt;bounding_box().left();
1839    } else {
1840      left_x = block-&gt;block-&gt;pdblk.bounding_box().left();
1841    }
1842    last_x = left_x;
1843    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1844      blob = blob_it.data();
1845      if (gradient != nullptr) {
1846        block_skew = (1 - 1 / g_length) * blob-&gt;bounding_box().bottom() +
1847                     *gradient / g_length * blob-&gt;bounding_box().left();
1848      } else if (blob-&gt;bounding_box().left() - last_x &gt; block-&gt;line_size / 2 &amp;&amp;
1849                 last_x - left_x &gt; block-&gt;line_size * 2 &amp;&amp; textord_interpolating_skew) {
1850        block_skew *= static_cast&lt;float&gt;(blob-&gt;bounding_box().left() - left_x) / (last_x - left_x);
1851      }
1852      last_x = blob-&gt;bounding_box().left();
1853      top = blob-&gt;bounding_box().top() - block_skew;
1854      bottom = blob-&gt;bounding_box().bottom() - block_skew;
1855  #ifndef GRAPHICS_DISABLED
1856      if (drawing_skew) {
1857        to_win-&gt;DrawTo(blob-&gt;bounding_box().left(), ycoord + block_skew);
1858      }
1859  #endif
1860      if (!row_it.empty()) {
1861        for (row_it.move_to_first(); !row_it.at_last() &amp;&amp; row_it.data()-&gt;min_y() &gt; top;
1862             row_it.forward()) {
1863        }
1864        row = row_it.data();
1865        if (row-&gt;min_y() &lt;= top &amp;&amp; row-&gt;max_y() &gt;= bottom) {
1866          dest_row = row;
1867          overlap_result = most_overlapping_row(&amp;row_it, dest_row, top, bottom, block-&gt;line_size,
1868                                                blob-&gt;bounding_box().contains(testpt));
1869          if (overlap_result == NEW_ROW &amp;&amp; !reject_misses) {
1870            overlap_result = ASSIGN;
1871          }
1872        } else {
1873          overlap_result = NEW_ROW;
1874          if (!make_new_rows) {
1875            near_dist = row_it.data_relative(-1)-&gt;min_y() - top;
1876            if (bottom &lt; row-&gt;min_y()) {
1877              if (row-&gt;min_y() - bottom &lt;= (block-&gt;line_spacing - block-&gt;line_size) *
1878                                               tesseract::CCStruct::kDescenderFraction) {
1879                overlap_result = ASSIGN;
1880                dest_row = row;
1881              }
1882            } else if (near_dist &gt; 0 &amp;&amp; near_dist &lt; bottom - row-&gt;max_y()) {
1883              row_it.backward();
1884              dest_row = row_it.data();
1885              if (dest_row-&gt;min_y() - bottom &lt;= (block-&gt;line_spacing - block-&gt;line_size) *
1886                                                    tesseract::CCStruct::kDescenderFraction) {
1887                overlap_result = ASSIGN;
1888              }
1889            } else {
1890              if (top - row-&gt;max_y() &lt;=
1891                  (block-&gt;line_spacing - block-&gt;line_size) *
1892                      (textord_overlap_x + tesseract::CCStruct::kAscenderFraction)) {
1893                overlap_result = ASSIGN;
1894                dest_row = row;
1895              }
1896            }
1897          }
1898        }
1899        if (overlap_result == ASSIGN) {
1900          dest_row-&gt;add_blob(blob_it.extract(), top, bottom, block-&gt;line_size);
1901        }
1902        if (overlap_result == NEW_ROW) {
1903          if (make_new_rows &amp;&amp; top - bottom &lt; block-&gt;max_blob_size) {
1904            dest_row = new TO_ROW(blob_it.extract(), top, bottom, block-&gt;line_size);
1905            row_count++;
1906            if (bottom &gt; row_it.data()-&gt;min_y()) {
1907              row_it.add_before_then_move(dest_row);
1908            } else {
1909              row_it.add_after_then_move(dest_row);
1910            }
1911            smooth_factor = 1.0 / (row_count * textord_skew_lag + textord_skewsmooth_offset);
1912          } else {
1913            overlap_result = REJECT;
1914          }
1915        }
1916      } else if (make_new_rows &amp;&amp; top - bottom &lt; block-&gt;max_blob_size) {
1917        overlap_result = NEW_ROW;
1918        dest_row = new TO_ROW(blob_it.extract(), top, bottom, block-&gt;line_size);
1919        row_count++;
1920        row_it.add_after_then_move(dest_row);
1921        smooth_factor = 1.0 / (row_count * textord_skew_lag + textord_skewsmooth_offset2);
1922      } else {
1923        overlap_result = REJECT;
1924      }
1925      if (blob-&gt;bounding_box().contains(testpt) &amp;&amp; textord_debug_blob) {
1926        if (overlap_result != REJECT) {
1927          tprintf(&quot;Test blob assigned to row at (%g,%g) on pass %d\n&quot;, dest_row-&gt;min_y(),
1928                  dest_row-&gt;max_y(), pass);
1929        } else {
1930          tprintf(&quot;Test blob assigned to no row on pass %d\n&quot;, pass);
1931        }
1932      }
1933      if (overlap_result != REJECT) {
1934        while (!row_it.at_first() &amp;&amp; row_it.data()-&gt;min_y() &gt; row_it.data_relative(-1)-&gt;min_y()) {
1935          row = row_it.extract();
1936          row_it.backward();
1937          row_it.add_before_then_move(row);
1938        }
1939        while (!row_it.at_last() &amp;&amp; row_it.data()-&gt;min_y() &lt; row_it.data_relative(1)-&gt;min_y()) {
1940          row = row_it.extract();
1941          row_it.forward();
1942          row_it.add_after_then_move(row);
1943        }
1944        BLOBNBOX_IT added_blob_it(dest_row-&gt;blob_list());
1945        added_blob_it.move_to_last();
1946        TBOX prev_box = added_blob_it.data_relative(-1)-&gt;bounding_box();
1947        if (dest_row-&gt;blob_list()-&gt;singleton() || !prev_box.major_x_overlap(blob-&gt;bounding_box())) {
1948          block_skew = (1 - smooth_factor) * block_skew +
1949                       smooth_factor * (blob-&gt;bounding_box().bottom() - dest_row-&gt;initial_min_y());
1950        }
1951      }
1952    }
1953    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1954      if (row_it.data()-&gt;blob_list()-&gt;empty()) {
1955        delete row_it.extract(); 
1956      }
1957    }
1958  }
1959  OVERLAP_STATE most_overlapping_row( 
1960      TO_ROW_IT *row_it,              
1961      TO_ROW *&amp;best_row,              
1962      float top,                      
1963      float bottom,                   
1964      float rowsize,                  
1965      bool testing_blob               
1966  ) {
1967    OVERLAP_STATE result;          
1968    float overlap;                 
1969    float bestover;                
1970    float merge_top, merge_bottom; 
1971    ICOORD testpt;                 
1972    TO_ROW *row;                   
1973    TO_ROW *test_row;              
1974    BLOBNBOX_IT blob_it;           
1975    result = ASSIGN;
1976    row = row_it-&gt;data();
1977    bestover = top - bottom;
1978    if (top &gt; row-&gt;max_y()) {
1979      bestover -= top - row-&gt;max_y();
1980    }
1981    if (bottom &lt; row-&gt;min_y()) {
1982      bestover -= row-&gt;min_y() - bottom;
1983    }
1984    if (testing_blob &amp;&amp; textord_debug_blob) {
1985      tprintf(&quot;Test blob y=(%g,%g), row=(%f,%f), size=%g, overlap=%f\n&quot;, bottom, top, row-&gt;min_y(),
1986              row-&gt;max_y(), rowsize, bestover);
1987    }
1988    test_row = row;
1989    do {
1990      if (!row_it-&gt;at_last()) {
1991        row_it-&gt;forward();
1992        test_row = row_it-&gt;data();
1993        if (test_row-&gt;min_y() &lt;= top &amp;&amp; test_row-&gt;max_y() &gt;= bottom) {
1994          merge_top = test_row-&gt;max_y() &gt; row-&gt;max_y() ? test_row-&gt;max_y() : row-&gt;max_y();
1995          merge_bottom = test_row-&gt;min_y() &lt; row-&gt;min_y() ? test_row-&gt;min_y() : row-&gt;min_y();
1996          if (merge_top - merge_bottom &lt;= rowsize) {
1997            if (testing_blob &amp;&amp; textord_debug_blob) {
1998              tprintf(&quot;Merging rows at (%g,%g), (%g,%g)\n&quot;, row-&gt;min_y(), row-&gt;max_y(),
1999                      test_row-&gt;min_y(), test_row-&gt;max_y());
2000            }
2001            test_row-&gt;set_limits(merge_bottom, merge_top);
2002            blob_it.set_to_list(test_row-&gt;blob_list());
2003            blob_it.add_list_after(row-&gt;blob_list());
2004            blob_it.sort(blob_x_order);
2005            row_it-&gt;backward();
2006            delete row_it-&gt;extract();
2007            row_it-&gt;forward();
2008            bestover = -1.0f; 
2009          }
2010          overlap = top - bottom;
2011          if (top &gt; test_row-&gt;max_y()) {
2012            overlap -= top - test_row-&gt;max_y();
2013          }
2014          if (bottom &lt; test_row-&gt;min_y()) {
2015            overlap -= test_row-&gt;min_y() - bottom;
2016          }
2017          if (bestover &gt;= rowsize - 1 &amp;&amp; overlap &gt;= rowsize - 1) {
2018            result = REJECT;
2019          }
2020          if (overlap &gt; bestover) {
2021            bestover = overlap; 
2022            row = test_row;
2023          }
2024          if (testing_blob &amp;&amp; textord_debug_blob) {
2025            tprintf(&quot;Test blob y=(%g,%g), row=(%f,%f), size=%g, overlap=%f-&gt;%f\n&quot;, bottom, top,
2026                    test_row-&gt;min_y(), test_row-&gt;max_y(), rowsize, overlap, bestover);
2027          }
2028        }
2029      }
2030    } while (!row_it-&gt;at_last() &amp;&amp; test_row-&gt;min_y() &lt;= top &amp;&amp; test_row-&gt;max_y() &gt;= bottom);
2031    while (row_it-&gt;data() != row) {
2032      row_it-&gt;backward(); 
2033    }
2034    if (top - bottom - bestover &gt; rowsize * textord_overlap_x &amp;&amp;
2035        (!textord_fix_makerow_bug || bestover &lt; rowsize * textord_overlap_x) &amp;&amp; result == ASSIGN) {
2036      result = NEW_ROW; 
2037    }
2038    best_row = row;
2039    return result;
2040  }
2041  int blob_x_order(      
2042      const void *item1, 
2043      const void *item2) {
2044    const BLOBNBOX *blob1 = *reinterpret_cast&lt;const BLOBNBOX *const *&gt;(item1);
2045    const BLOBNBOX *blob2 = *reinterpret_cast&lt;const BLOBNBOX *const *&gt;(item2);
2046    if (blob1-&gt;bounding_box().left() &lt; blob2-&gt;bounding_box().left()) {
2047      return -1;
2048    } else if (blob1-&gt;bounding_box().left() &gt; blob2-&gt;bounding_box().left()) {
2049      return 1;
2050    } else {
2051      return 0;
2052    }
2053  }
2054  void mark_repeated_chars(TO_ROW *row) {
2055    BLOBNBOX_IT box_it(row-&gt;blob_list()); 
2056    int num_repeated_sets = 0;
2057    if (!box_it.empty()) {
2058      do {
2059        BLOBNBOX *bblob = box_it.data();
2060        int repeat_length = 1;
2061        if (bblob-&gt;flow() == BTFT_LEADER &amp;&amp; !bblob-&gt;joined_to_prev() &amp;&amp; bblob-&gt;cblob() != nullptr) {
2062          BLOBNBOX_IT test_it(box_it);
2063          for (test_it.forward(); !test_it.at_first();) {
2064            bblob = test_it.data();
2065            if (bblob-&gt;flow() != BTFT_LEADER) {
2066              break;
2067            }
2068            test_it.forward();
2069            bblob = test_it.data();
2070            if (bblob-&gt;joined_to_prev() || bblob-&gt;cblob() == nullptr) {
2071              repeat_length = 0;
2072              break;
2073            }
2074            ++repeat_length;
2075          }
2076        }
2077        if (repeat_length &gt;= kMinLeaderCount) {
2078          num_repeated_sets++;
2079          for (; repeat_length &gt; 0; box_it.forward(), --repeat_length) {
2080            bblob = box_it.data();
2081            bblob-&gt;set_repeated_set(num_repeated_sets);
2082          }
2083        } else {
2084          bblob-&gt;set_repeated_set(0);
2085          box_it.forward();
2086        }
2087      } while (!box_it.at_first()); 
2088    }
2089    row-&gt;set_num_repeated_sets(num_repeated_sets);
2090  }
2091  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-topitch.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #include &quot;topitch.h&quot;
5  #include &quot;blobbox.h&quot;
6  #include &quot;drawtord.h&quot;
7  #include &quot;makerow.h&quot;
8  #include &quot;pithsync.h&quot;
9  #include &quot;pitsync1.h&quot;
10  #include &quot;statistc.h&quot;
11  #include &quot;tovars.h&quot;
12  #include &quot;wordseg.h&quot;
13  #include &quot;helpers.h&quot;
14  #include &lt;memory&gt;
15  namespace tesseract {
16  static BOOL_VAR(textord_all_prop, false, &quot;All doc is proportial text&quot;);
17  BOOL_VAR(textord_debug_pitch_test, false, &quot;Debug on fixed pitch test&quot;);
18  static BOOL_VAR(textord_disable_pitch_test, false, &quot;Turn off dp fixed pitch algorithm&quot;);
19  BOOL_VAR(textord_fast_pitch_test, false, &quot;Do even faster pitch algorithm&quot;);
20  BOOL_VAR(textord_debug_pitch_metric, false, &quot;Write full metric stuff&quot;);
21  BOOL_VAR(textord_show_row_cuts, false, &quot;Draw row-level cuts&quot;);
22  BOOL_VAR(textord_show_page_cuts, false, &quot;Draw page-level cuts&quot;);
23  BOOL_VAR(textord_blockndoc_fixed, false, &quot;Attempt whole doc/block fixed pitch&quot;);
24  double_VAR(textord_projection_scale, 0.200, &quot;Ding rate for mid-cuts&quot;);
25  double_VAR(textord_balance_factor, 1.0, &quot;Ding rate for unbalanced char cells&quot;);
26  #define BLOCK_STATS_CLUSTERS 10
27  #define MAX_ALLOWED_PITCH 100 
28  static int sort_floats(const void *arg1, const void *arg2) {
29    float diff = *reinterpret_cast&lt;const float *&gt;(arg1) - *reinterpret_cast&lt;const float *&gt;(arg2);
30    if (diff &gt; 0) {
31      return 1;
32    } else if (diff &lt; 0) {
33      return -1;
34    } else {
35      return 0;
36    }
37  }
38  void compute_fixed_pitch(ICOORD page_tr,             
39                           TO_BLOCK_LIST *port_blocks, 
40                           float gradient,             
41                           FCOORD rotation,            
42                           bool testing_on) {          
43    TO_BLOCK_IT block_it;                              
44    TO_BLOCK *block;                                   
45    TO_ROW *row;                                       
46    int block_index;                                   
47    int row_index;                                     
48  #ifndef GRAPHICS_DISABLED
49    if (textord_show_initial_words &amp;&amp; testing_on) {
50      if (to_win == nullptr) {
51        create_to_win(page_tr);
52      }
53    }
54  #endif
55    block_it.set_to_list(port_blocks);
56    block_index = 1;
57    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
58      block = block_it.data();
59      compute_block_pitch(block, rotation, block_index, testing_on);
60      block_index++;
61    }
62    if (!try_doc_fixed(page_tr, port_blocks, gradient)) {
63      block_index = 1;
64      for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
65        block = block_it.data();
66        if (!try_block_fixed(block, block_index)) {
67          try_rows_fixed(block, block_index, testing_on);
68        }
69        block_index++;
70      }
71    }
72    block_index = 1;
73    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
74      block = block_it.data();
75      POLY_BLOCK *pb = block-&gt;block-&gt;pdblk.poly_block();
76      if (pb != nullptr &amp;&amp; !pb-&gt;IsText()) {
77        continue; 
78      }
79      TO_ROW_IT row_it(block-&gt;get_rows());
80      row_index = 1;
81      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
82        row = row_it.data();
83        fix_row_pitch(row, block, port_blocks, row_index, block_index);
84        row_index++;
85      }
86      block_index++;
87    }
88  #ifndef GRAPHICS_DISABLED
89    if (textord_show_initial_words &amp;&amp; testing_on) {
90      ScrollView::Update();
91    }
92  #endif
93  }
94  void fix_row_pitch(TO_ROW *bad_row,        
95                     TO_BLOCK *bad_block,    
96                     TO_BLOCK_LIST *blocks,  
97                     int32_t row_target,     
98                     int32_t block_target) { 
99    int16_t mid_cuts;
100    int block_votes;               
101    int like_votes;                
102    int other_votes;               
103    int block_index;               
104    int row_index;                 
105    int maxwidth;                  
106    TO_BLOCK_IT block_it = blocks; 
107    TO_BLOCK *block;               
108    TO_ROW *row;                   
109    float sp_sd;                   
110    STATS block_stats;             
111    STATS like_stats;              
112    block_votes = like_votes = other_votes = 0;
113    maxwidth = static_cast&lt;int32_t&gt;(ceil(bad_row-&gt;xheight * textord_words_maxspace));
114    if (bad_row-&gt;pitch_decision != PITCH_DEF_FIXED &amp;&amp; bad_row-&gt;pitch_decision != PITCH_DEF_PROP) {
115      block_stats.set_range(0, maxwidth - 1);
116      like_stats.set_range(0, maxwidth - 1);
117      block_index = 1;
118      for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
119        block = block_it.data();
120        POLY_BLOCK *pb = block-&gt;block-&gt;pdblk.poly_block();
121        if (pb != nullptr &amp;&amp; !pb-&gt;IsText()) {
122          continue; 
123        }
124        row_index = 1;
125        TO_ROW_IT row_it(block-&gt;get_rows());
126        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
127          row = row_it.data();
128          if ((bad_row-&gt;all_caps &amp;&amp;
129               row-&gt;xheight + row-&gt;ascrise &lt;
130                   (bad_row-&gt;xheight + bad_row-&gt;ascrise) * (1 + textord_pitch_rowsimilarity) &amp;&amp;
131               row-&gt;xheight + row-&gt;ascrise &gt;
132                   (bad_row-&gt;xheight + bad_row-&gt;ascrise) * (1 - textord_pitch_rowsimilarity)) ||
133              (!bad_row-&gt;all_caps &amp;&amp;
134               row-&gt;xheight &lt; bad_row-&gt;xheight * (1 + textord_pitch_rowsimilarity) &amp;&amp;
135               row-&gt;xheight &gt; bad_row-&gt;xheight * (1 - textord_pitch_rowsimilarity))) {
136            if (block_index == block_target) {
137              if (row-&gt;pitch_decision == PITCH_DEF_FIXED) {
138                block_votes += textord_words_veto_power;
139                block_stats.add(static_cast&lt;int32_t&gt;(row-&gt;fixed_pitch), textord_words_veto_power);
140              } else if (row-&gt;pitch_decision == PITCH_MAYBE_FIXED ||
141                         row-&gt;pitch_decision == PITCH_CORR_FIXED) {
142                block_votes++;
143                block_stats.add(static_cast&lt;int32_t&gt;(row-&gt;fixed_pitch), 1);
144              } else if (row-&gt;pitch_decision == PITCH_DEF_PROP) {
145                block_votes -= textord_words_veto_power;
146              } else if (row-&gt;pitch_decision == PITCH_MAYBE_PROP ||
147                         row-&gt;pitch_decision == PITCH_CORR_PROP) {
148                block_votes--;
149              }
150            } else {
151              if (row-&gt;pitch_decision == PITCH_DEF_FIXED) {
152                like_votes += textord_words_veto_power;
153                like_stats.add(static_cast&lt;int32_t&gt;(row-&gt;fixed_pitch), textord_words_veto_power);
154              } else if (row-&gt;pitch_decision == PITCH_MAYBE_FIXED ||
155                         row-&gt;pitch_decision == PITCH_CORR_FIXED) {
156                like_votes++;
157                like_stats.add(static_cast&lt;int32_t&gt;(row-&gt;fixed_pitch), 1);
158              } else if (row-&gt;pitch_decision == PITCH_DEF_PROP) {
159                like_votes -= textord_words_veto_power;
160              } else if (row-&gt;pitch_decision == PITCH_MAYBE_PROP ||
161                         row-&gt;pitch_decision == PITCH_CORR_PROP) {
162                like_votes--;
163              }
164            }
165          } else {
166            if (row-&gt;pitch_decision == PITCH_DEF_FIXED) {
167              other_votes += textord_words_veto_power;
168            } else if (row-&gt;pitch_decision == PITCH_MAYBE_FIXED ||
169                       row-&gt;pitch_decision == PITCH_CORR_FIXED) {
170              other_votes++;
171            } else if (row-&gt;pitch_decision == PITCH_DEF_PROP) {
172              other_votes -= textord_words_veto_power;
173            } else if (row-&gt;pitch_decision == PITCH_MAYBE_PROP ||
174                       row-&gt;pitch_decision == PITCH_CORR_PROP) {
175              other_votes--;
176            }
177          }
178          row_index++;
179        }
180        block_index++;
181      }
182      if (block_votes &gt; textord_words_veto_power) {
183        bad_row-&gt;fixed_pitch = block_stats.ile(0.5);
184        bad_row-&gt;pitch_decision = PITCH_CORR_FIXED;
185      } else if (block_votes &lt;= textord_words_veto_power &amp;&amp; like_votes &gt; 0) {
186        bad_row-&gt;fixed_pitch = like_stats.ile(0.5);
187        bad_row-&gt;pitch_decision = PITCH_CORR_FIXED;
188      } else {
189        bad_row-&gt;pitch_decision = PITCH_CORR_PROP;
190        if (block_votes == 0 &amp;&amp; like_votes == 0 &amp;&amp; other_votes &gt; 0 &amp;&amp;
191            (textord_debug_pitch_test || textord_debug_pitch_metric)) {
192          tprintf(
193              &quot;Warning:row %d of block %d set prop with no like rows against &quot;
194              &quot;trend\n&quot;,
195              row_target, block_target);
196        }
197      }
198    }
199    if (textord_debug_pitch_metric) {
200      tprintf(&quot;:b_votes=%d:l_votes=%d:o_votes=%d&quot;, block_votes, like_votes, other_votes);
201      tprintf(&quot;x=%g:asc=%g\n&quot;, bad_row-&gt;xheight, bad_row-&gt;ascrise);
202    }
203    if (bad_row-&gt;pitch_decision == PITCH_CORR_FIXED) {
204      if (bad_row-&gt;fixed_pitch &lt; textord_min_xheight) {
205        if (block_votes &gt; 0) {
206          bad_row-&gt;fixed_pitch = block_stats.ile(0.5);
207        } else if (block_votes == 0 &amp;&amp; like_votes &gt; 0) {
208          bad_row-&gt;fixed_pitch = like_stats.ile(0.5);
209        } else {
210          tprintf(&quot;Warning:guessing pitch as xheight on row %d, block %d\n&quot;, row_target,
211                  block_target);
212          bad_row-&gt;fixed_pitch = bad_row-&gt;xheight;
213        }
214      }
215      if (bad_row-&gt;fixed_pitch &lt; textord_min_xheight) {
216        bad_row-&gt;fixed_pitch = (float)textord_min_xheight;
217      }
218      bad_row-&gt;kern_size = bad_row-&gt;fixed_pitch / 4;
219      bad_row-&gt;min_space = static_cast&lt;int32_t&gt;(bad_row-&gt;fixed_pitch * 0.6);
220      bad_row-&gt;max_nonspace = static_cast&lt;int32_t&gt;(bad_row-&gt;fixed_pitch * 0.4);
221      bad_row-&gt;space_threshold = (bad_row-&gt;min_space + bad_row-&gt;max_nonspace) / 2;
222      bad_row-&gt;space_size = bad_row-&gt;fixed_pitch;
223      if (bad_row-&gt;char_cells.empty() &amp;&amp; !bad_row-&gt;blob_list()-&gt;empty()) {
224        tune_row_pitch(bad_row, &amp;bad_row-&gt;projection, bad_row-&gt;projection_left,
225                       bad_row-&gt;projection_right,
226                       (bad_row-&gt;fixed_pitch + bad_row-&gt;max_nonspace * 3) / 4, bad_row-&gt;fixed_pitch,
227                       sp_sd, mid_cuts, &amp;bad_row-&gt;char_cells, false);
228      }
229    } else if (bad_row-&gt;pitch_decision == PITCH_CORR_PROP ||
230               bad_row-&gt;pitch_decision == PITCH_DEF_PROP) {
231      bad_row-&gt;fixed_pitch = 0.0f;
232      bad_row-&gt;char_cells.clear();
233    }
234  }
235  void compute_block_pitch(TO_BLOCK *block,     
236                           FCOORD rotation,     
237                           int32_t block_index, 
238                           bool testing_on) {   
239    TBOX block_box;                             
240    block_box = block-&gt;block-&gt;pdblk.bounding_box();
241    if (testing_on &amp;&amp; textord_debug_pitch_test) {
242      tprintf(&quot;Block %d at (%d,%d)-&gt;(%d,%d)\n&quot;, block_index, block_box.left(), block_box.bottom(),
243              block_box.right(), block_box.top());
244    }
245    block-&gt;min_space = static_cast&lt;int32_t&gt;(floor(block-&gt;xheight * textord_words_default_minspace));
246    block-&gt;max_nonspace = static_cast&lt;int32_t&gt;(ceil(block-&gt;xheight * textord_words_default_nonspace));
247    block-&gt;fixed_pitch = 0.0f;
248    block-&gt;space_size = static_cast&lt;float&gt;(block-&gt;min_space);
249    block-&gt;kern_size = static_cast&lt;float&gt;(block-&gt;max_nonspace);
250    block-&gt;pr_nonsp = block-&gt;xheight * words_default_prop_nonspace;
251    block-&gt;pr_space = block-&gt;pr_nonsp * textord_spacesize_ratioprop;
252    if (!block-&gt;get_rows()-&gt;empty()) {
253      ASSERT_HOST(block-&gt;xheight &gt; 0);
254      find_repeated_chars(block, textord_show_initial_words &amp;&amp; testing_on);
255  #ifndef GRAPHICS_DISABLED
256      if (textord_show_initial_words &amp;&amp; testing_on) {
257        ScrollView::Update();
258      }
259  #endif
260      compute_rows_pitch(block, block_index, textord_debug_pitch_test &amp;&amp; testing_on);
261    }
262  }
263  bool compute_rows_pitch( 
264      TO_BLOCK *block,     
265      int32_t block_index, 
266      bool testing_on      
267  ) {
268    int32_t maxwidth;   
269    TO_ROW *row;        
270    int32_t row_index;  
271    float lower, upper; 
272    TO_ROW_IT row_it = block-&gt;get_rows();
273    row_index = 1;
274    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
275      row = row_it.data();
276      ASSERT_HOST(row-&gt;xheight &gt; 0);
277      row-&gt;compute_vertical_projection();
278      maxwidth = static_cast&lt;int32_t&gt;(ceil(row-&gt;xheight * textord_words_maxspace));
279      if (row_pitch_stats(row, maxwidth, testing_on) &amp;&amp;
280          find_row_pitch(row, maxwidth, textord_dotmatrix_gap + 1, block, block_index, row_index,
281                         testing_on)) {
282        if (row-&gt;fixed_pitch == 0) {
283          lower = row-&gt;pr_nonsp;
284          upper = row-&gt;pr_space;
285          row-&gt;space_size = upper;
286          row-&gt;kern_size = lower;
287        }
288      } else {
289        row-&gt;fixed_pitch = 0.0f; 
290        row-&gt;pitch_decision = PITCH_DUNNO;
291      }
292      row_index++;
293    }
294    return false;
295  }
296  bool try_doc_fixed(             
297      ICOORD page_tr,             
298      TO_BLOCK_LIST *port_blocks, 
299      float gradient              
300  ) {
301    int16_t master_x; 
302    int16_t pitch;    
303    int x;            
304    int prop_blocks;  
305    int fixed_blocks;
306    int total_row_count; 
307    TO_BLOCK_IT block_it = port_blocks;
308    TO_BLOCK *block;         
309    TO_ROW *row;             
310    int16_t projection_left; 
311    int16_t projection_right;
312    int16_t row_left; 
313    int16_t row_right;
314    float master_y;     
315    float shift_factor; 
316    float final_pitch;  
317    float row_y;        
318    STATS projection;   
319    STATS pitches(0, MAX_ALLOWED_PITCH - 1);
320    float sp_sd;      
321    int16_t mid_cuts; 
322    float pitch_sd;   
323    if (!textord_blockndoc_fixed ||
324        block_it.empty() || block_it.data()-&gt;get_rows()-&gt;empty()) {
325      return false;
326    }
327    shift_factor = gradient / (gradient * gradient + 1);
328    TO_ROW_IT row_it(block_it.data()-&gt;get_rows());
329    master_x = row_it.data()-&gt;projection_left;
330    master_y = row_it.data()-&gt;baseline.y(master_x);
331    projection_left = INT16_MAX;
332    projection_right = -INT16_MAX;
333    prop_blocks = 0;
334    fixed_blocks = 0;
335    total_row_count = 0;
336    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
337      block = block_it.data();
338      row_it.set_to_list(block-&gt;get_rows());
339      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
340        row = row_it.data();
341        total_row_count++;
342        if (row-&gt;fixed_pitch &gt; 0) {
343          pitches.add(static_cast&lt;int32_t&gt;(row-&gt;fixed_pitch), 1);
344        }
345        row_y = row-&gt;baseline.y(master_x);
346        row_left = static_cast&lt;int16_t&gt;(row-&gt;projection_left - shift_factor * (master_y - row_y));
347        row_right = static_cast&lt;int16_t&gt;(row-&gt;projection_right - shift_factor * (master_y - row_y));
348        if (row_left &lt; projection_left) {
349          projection_left = row_left;
350        }
351        if (row_right &gt; projection_right) {
352          projection_right = row_right;
353        }
354      }
355    }
356    if (pitches.get_total() == 0) {
357      return false;
358    }
359    projection.set_range(projection_left, projection_right - 1);
360    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
361      block = block_it.data();
362      row_it.set_to_list(block-&gt;get_rows());
363      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
364        row = row_it.data();
365        row_y = row-&gt;baseline.y(master_x);
366        row_left = static_cast&lt;int16_t&gt;(row-&gt;projection_left - shift_factor * (master_y - row_y));
367        for (x = row-&gt;projection_left; x &lt; row-&gt;projection_right; x++, row_left++) {
368          projection.add(row_left, row-&gt;projection.pile_count(x));
369        }
370      }
371    }
372    row_it.set_to_list(block_it.data()-&gt;get_rows());
373    row = row_it.data();
374  #ifndef GRAPHICS_DISABLED
375    if (textord_show_page_cuts &amp;&amp; to_win != nullptr) {
376      projection.plot(to_win, projection_left, row-&gt;intercept(), 1.0f, -1.0f, ScrollView::CORAL);
377    }
378  #endif
379    final_pitch = pitches.ile(0.5);
380    pitch = static_cast&lt;int16_t&gt;(final_pitch);
381    pitch_sd = tune_row_pitch(row, &amp;projection, projection_left, projection_right, pitch * 0.75,
382                              final_pitch, sp_sd, mid_cuts, &amp;row-&gt;char_cells, false);
383    if (textord_debug_pitch_metric) {
384      tprintf(
385          &quot;try_doc:props=%d:fixed=%d:pitch=%d:final_pitch=%g:pitch_sd=%g:sp_sd=%&quot;
386          &quot;g:sd/trc=%g:sd/p=%g:sd/trc/p=%g\n&quot;,
387          prop_blocks, fixed_blocks, pitch, final_pitch, pitch_sd, sp_sd, pitch_sd / total_row_count,
388          pitch_sd / pitch, pitch_sd / total_row_count / pitch);
389    }
390  #ifndef GRAPHICS_DISABLED
391    if (textord_show_page_cuts &amp;&amp; to_win != nullptr) {
392      float row_shift;              
393      ICOORDELT_LIST *master_cells; 
394      master_cells = &amp;row-&gt;char_cells;
395      for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
396        block = block_it.data();
397        row_it.set_to_list(block-&gt;get_rows());
398        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
399          row = row_it.data();
400          row_y = row-&gt;baseline.y(master_x);
401          row_shift = shift_factor * (master_y - row_y);
402          plot_row_cells(to_win, ScrollView::GOLDENROD, row, row_shift, master_cells);
403        }
404      }
405    }
406  #endif
407    row-&gt;char_cells.clear();
408    return false;
409  }
410  bool try_block_fixed(   
411      TO_BLOCK *block,    
412      int32_t block_index 
413  ) {
414    return false;
415  }
416  bool try_rows_fixed(     
417      TO_BLOCK *block,     
418      int32_t block_index, 
419      bool testing_on      
420  ) {
421    TO_ROW *row;           
422    int32_t row_index;     
423    int32_t def_fixed = 0; 
424    int32_t def_prop = 0;
425    int32_t maybe_fixed = 0;
426    int32_t maybe_prop = 0;
427    int32_t dunno = 0;
428    int32_t corr_fixed = 0;
429    int32_t corr_prop = 0;
430    float lower, upper; 
431    TO_ROW_IT row_it = block-&gt;get_rows();
432    row_index = 1;
433    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
434      row = row_it.data();
435      ASSERT_HOST(row-&gt;xheight &gt; 0);
436      if (row-&gt;fixed_pitch &gt; 0 &amp;&amp; fixed_pitch_row(row, block-&gt;block, block_index)) {
437        if (row-&gt;fixed_pitch == 0) {
438          lower = row-&gt;pr_nonsp;
439          upper = row-&gt;pr_space;
440          row-&gt;space_size = upper;
441          row-&gt;kern_size = lower;
442        }
443      }
444      row_index++;
445    }
446    count_block_votes(block, def_fixed, def_prop, maybe_fixed, maybe_prop, corr_fixed, corr_prop,
447                      dunno);
448    if (testing_on &amp;&amp;
449        (textord_debug_pitch_test || textord_blocksall_prop || textord_blocksall_fixed)) {
450      tprintf(&quot;Initially:&quot;);
451      print_block_counts(block, block_index);
452    }
453    if (def_fixed &gt; def_prop * textord_words_veto_power) {
454      block-&gt;pitch_decision = PITCH_DEF_FIXED;
455    } else if (def_prop &gt; def_fixed * textord_words_veto_power) {
456      block-&gt;pitch_decision = PITCH_DEF_PROP;
457    } else if (def_fixed &gt; 0 || def_prop &gt; 0) {
458      block-&gt;pitch_decision = PITCH_DUNNO;
459    } else if (maybe_fixed &gt; maybe_prop * textord_words_veto_power) {
460      block-&gt;pitch_decision = PITCH_MAYBE_FIXED;
461    } else if (maybe_prop &gt; maybe_fixed * textord_words_veto_power) {
462      block-&gt;pitch_decision = PITCH_MAYBE_PROP;
463    } else {
464      block-&gt;pitch_decision = PITCH_DUNNO;
465    }
466    return false;
467  }
468  void print_block_counts( 
469      TO_BLOCK *block,     
470      int32_t block_index  
471  ) {
472    int32_t def_fixed = 0; 
473    int32_t def_prop = 0;
474    int32_t maybe_fixed = 0;
475    int32_t maybe_prop = 0;
476    int32_t dunno = 0;
477    int32_t corr_fixed = 0;
478    int32_t corr_prop = 0;
479    count_block_votes(block, def_fixed, def_prop, maybe_fixed, maybe_prop, corr_fixed, corr_prop,
480                      dunno);
481    tprintf(&quot;Block %d has (%d,%d,%d)&quot;, block_index, def_fixed, maybe_fixed, corr_fixed);
482    if (textord_blocksall_prop &amp;&amp; (def_fixed || maybe_fixed || corr_fixed)) {
483      tprintf(&quot; (Wrongly)&quot;);
484    }
485    tprintf(&quot; fixed, (%d,%d,%d)&quot;, def_prop, maybe_prop, corr_prop);
486    if (textord_blocksall_fixed &amp;&amp; (def_prop || maybe_prop || corr_prop)) {
487      tprintf(&quot; (Wrongly)&quot;);
488    }
489    tprintf(&quot; prop, %d dunno\n&quot;, dunno);
490  }
491  void count_block_votes( 
492      TO_BLOCK *block,    
493      int32_t &amp;def_fixed, 
494      int32_t &amp;def_prop, int32_t &amp;maybe_fixed, int32_t &amp;maybe_prop, int32_t &amp;corr_fixed,
495      int32_t &amp;corr_prop, int32_t &amp;dunno) {
496    TO_ROW *row; 
497    TO_ROW_IT row_it = block-&gt;get_rows();
498    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
499      row = row_it.data();
500      switch (row-&gt;pitch_decision) {
501        case PITCH_DUNNO:
502          dunno++;
503          break;
504        case PITCH_DEF_PROP:
505          def_prop++;
506          break;
507        case PITCH_MAYBE_PROP:
508          maybe_prop++;
509          break;
510        case PITCH_DEF_FIXED:
511          def_fixed++;
512          break;
513        case PITCH_MAYBE_FIXED:
514          maybe_fixed++;
515          break;
516        case PITCH_CORR_PROP:
517          corr_prop++;
518          break;
519        case PITCH_CORR_FIXED:
520          corr_fixed++;
521          break;
522      }
523    }
524  }
525  bool row_pitch_stats( 
526      TO_ROW *row,      
527      int32_t maxwidth, 
528      bool testing_on   
529  ) {
530    BLOBNBOX *blob;        
531    int gap_index;         
532    int32_t prev_x;        
533    int32_t cluster_count; 
534    int32_t prev_count;    
535    int32_t smooth_factor; 
536    TBOX blob_box;         
537    float lower, upper;    
538    float gaps[BLOCK_STATS_CLUSTERS];
539    BLOBNBOX_IT blob_it = row-&gt;blob_list();
540    STATS gap_stats(0, maxwidth - 1);
541    STATS cluster_stats[BLOCK_STATS_CLUSTERS + 1];
542    smooth_factor = static_cast&lt;int32_t&gt;(row-&gt;xheight * textord_wordstats_smooth_factor + 1.5);
543    if (!blob_it.empty()) {
544      prev_x = blob_it.data()-&gt;bounding_box().right();
545      blob_it.forward();
546      while (!blob_it.at_first()) {
547        blob = blob_it.data();
548        if (!blob-&gt;joined_to_prev()) {
549          blob_box = blob-&gt;bounding_box();
550          if (blob_box.left() - prev_x &lt; maxwidth) {
551            gap_stats.add(blob_box.left() - prev_x, 1);
552          }
553          prev_x = blob_box.right();
554        }
555        blob_it.forward();
556      }
557    }
558    if (gap_stats.get_total() == 0) {
559      return false;
560    }
561    cluster_count = 0;
562    lower = row-&gt;xheight * words_initial_lower;
563    upper = row-&gt;xheight * words_initial_upper;
564    gap_stats.smooth(smooth_factor);
565    do {
566      prev_count = cluster_count;
567      cluster_count = gap_stats.cluster(lower, upper, textord_spacesize_ratioprop,
568                                        BLOCK_STATS_CLUSTERS, cluster_stats);
569    } while (cluster_count &gt; prev_count &amp;&amp; cluster_count &lt; BLOCK_STATS_CLUSTERS);
570    if (cluster_count &lt; 1) {
571      return false;
572    }
573    for (gap_index = 0; gap_index &lt; cluster_count; gap_index++) {
574      gaps[gap_index] = cluster_stats[gap_index + 1].ile(0.5);
575    }
576    if (testing_on) {
577      tprintf(&quot;cluster_count=%d:&quot;, cluster_count);
578      for (gap_index = 0; gap_index &lt; cluster_count; gap_index++) {
579        tprintf(&quot; %g(%d)&quot;, gaps[gap_index], cluster_stats[gap_index + 1].get_total());
580      }
581      tprintf(&quot;\n&quot;);
582    }
583    qsort(gaps, cluster_count, sizeof(float), sort_floats);
584    lower = row-&gt;xheight * words_default_prop_nonspace;
585    upper = row-&gt;xheight * textord_words_min_minspace;
586    for (gap_index = 0; gap_index &lt; cluster_count &amp;&amp; gaps[gap_index] &lt; lower; gap_index++) {
587      ;
588    }
589    if (gap_index == 0) {
590      if (testing_on) {
591        tprintf(&quot;No clusters below nonspace threshold!!\n&quot;);
592      }
593      if (cluster_count &gt; 1) {
594        row-&gt;pr_nonsp = gaps[0];
595        row-&gt;pr_space = gaps[1];
596      } else {
597        row-&gt;pr_nonsp = lower;
598        row-&gt;pr_space = gaps[0];
599      }
600    } else {
601      row-&gt;pr_nonsp = gaps[gap_index - 1];
602      while (gap_index &lt; cluster_count &amp;&amp; gaps[gap_index] &lt; upper) {
603        gap_index++;
604      }
605      if (gap_index == cluster_count) {
606        if (testing_on) {
607          tprintf(&quot;No clusters above nonspace threshold!!\n&quot;);
608        }
609        row-&gt;pr_space = lower * textord_spacesize_ratioprop;
610      } else {
611        row-&gt;pr_space = gaps[gap_index];
612      }
613    }
614    upper = row-&gt;xheight * words_default_fixed_space;
615    for (gap_index = 0; gap_index &lt; cluster_count &amp;&amp; gaps[gap_index] &lt; upper; gap_index++) {
616      ;
617    }
618    if (gap_index == 0) {
619      if (testing_on) {
620        tprintf(&quot;No clusters below space threshold!!\n&quot;);
621      }
622      row-&gt;fp_nonsp = upper;
623      row-&gt;fp_space = gaps[0];
624    } else {
625      row-&gt;fp_nonsp = gaps[gap_index - 1];
626      if (gap_index == cluster_count) {
627        if (testing_on) {
628          tprintf(&quot;No clusters above space threshold!!\n&quot;);
629        }
630        row-&gt;fp_space = row-&gt;xheight;
631      } else {
632        row-&gt;fp_space = gaps[gap_index];
633      }
634    }
635    if (testing_on) {
636      tprintf(
637          &quot;Initial estimates:pr_nonsp=%g, pr_space=%g, fp_nonsp=%g, &quot;
638          &quot;fp_space=%g\n&quot;,
639          row-&gt;pr_nonsp, row-&gt;pr_space, row-&gt;fp_nonsp, row-&gt;fp_space);
640    }
641    return true; 
642  }
643  bool find_row_pitch(     
644      TO_ROW *row,         
645      int32_t maxwidth,    
646      int32_t dm_gap,      
647      TO_BLOCK *block,     
648      int32_t block_index, 
649      int32_t row_index,   
650      bool testing_on      
651  ) {
652    bool used_dm_model; 
653    float min_space;    
654    float non_space;    
655    float gap_iqr;      
656    float pitch_iqr;
657    float dm_gap_iqr; 
658    float dm_pitch_iqr;
659    float dm_pitch;      
660    float pitch;         
661    float initial_pitch; 
662    STATS gap_stats(0, maxwidth - 1);
663    STATS pitch_stats(0, maxwidth - 1);
664    row-&gt;fixed_pitch = 0.0f;
665    initial_pitch = row-&gt;fp_space;
666    if (initial_pitch &gt; row-&gt;xheight * (1 + words_default_fixed_limit)) {
667      initial_pitch = row-&gt;xheight; 
668    }
669    non_space = row-&gt;fp_nonsp;
670    if (non_space &gt; initial_pitch) {
671      non_space = initial_pitch;
672    }
673    min_space = (initial_pitch + non_space) / 2;
674    if (!count_pitch_stats(row, &amp;gap_stats, &amp;pitch_stats, initial_pitch, min_space, true, false,
675                           dm_gap)) {
676      dm_gap_iqr = 0.0001f;
677      dm_pitch_iqr = maxwidth * 2.0f;
678      dm_pitch = initial_pitch;
679    } else {
680      dm_gap_iqr = gap_stats.ile(0.75) - gap_stats.ile(0.25);
681      dm_pitch_iqr = pitch_stats.ile(0.75) - pitch_stats.ile(0.25);
682      dm_pitch = pitch_stats.ile(0.5);
683    }
684    gap_stats.clear();
685    pitch_stats.clear();
686    if (!count_pitch_stats(row, &amp;gap_stats, &amp;pitch_stats, initial_pitch, min_space, true, false, 0)) {
687      gap_iqr = 0.0001f;
688      pitch_iqr = maxwidth * 3.0f;
689    } else {
690      gap_iqr = gap_stats.ile(0.75) - gap_stats.ile(0.25);
691      pitch_iqr = pitch_stats.ile(0.75) - pitch_stats.ile(0.25);
692      if (testing_on) {
693        tprintf(
694            &quot;First fp iteration:initial_pitch=%g, gap_iqr=%g, pitch_iqr=%g, &quot;
695            &quot;pitch=%g\n&quot;,
696            initial_pitch, gap_iqr, pitch_iqr, pitch_stats.ile(0.5));
697      }
698      initial_pitch = pitch_stats.ile(0.5);
699      if (min_space &gt; initial_pitch &amp;&amp; count_pitch_stats(row, &amp;gap_stats, &amp;pitch_stats, initial_pitch,
700                                                         initial_pitch, true, false, 0)) {
701        min_space = initial_pitch;
702        gap_iqr = gap_stats.ile(0.75) - gap_stats.ile(0.25);
703        pitch_iqr = pitch_stats.ile(0.75) - pitch_stats.ile(0.25);
704        if (testing_on) {
705          tprintf(
706              &quot;Revised fp iteration:initial_pitch=%g, gap_iqr=%g, pitch_iqr=%g, &quot;
707              &quot;pitch=%g\n&quot;,
708              initial_pitch, gap_iqr, pitch_iqr, pitch_stats.ile(0.5));
709        }
710        initial_pitch = pitch_stats.ile(0.5);
711      }
712    }
713    if (textord_debug_pitch_metric) {
714      tprintf(&quot;Blk=%d:Row=%d:%c:p_iqr=%g:g_iqr=%g:dm_p_iqr=%g:dm_g_iqr=%g:%c:&quot;, block_index,
715              row_index, &#x27;X&#x27;, pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr,
716              pitch_iqr &gt; maxwidth &amp;&amp; dm_pitch_iqr &gt; maxwidth
717                  ? &#x27;D&#x27;
718                  : (pitch_iqr * dm_gap_iqr &lt;= dm_pitch_iqr * gap_iqr ? &#x27;S&#x27; : &#x27;M&#x27;));
719    }
720    if (pitch_iqr &gt; maxwidth &amp;&amp; dm_pitch_iqr &gt; maxwidth) {
721      row-&gt;pitch_decision = PITCH_DUNNO;
722      if (textord_debug_pitch_metric) {
723        tprintf(&quot;\n&quot;);
724      }
725      return false; 
726    }
727    if (pitch_iqr * dm_gap_iqr &lt;= dm_pitch_iqr * gap_iqr) {
728      if (testing_on) {
729        tprintf(
730            &quot;Choosing non dm version:pitch_iqr=%g, gap_iqr=%g, dm_pitch_iqr=%g, &quot;
731            &quot;dm_gap_iqr=%g\n&quot;,
732            pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr);
733      }
734      gap_iqr = gap_stats.ile(0.75) - gap_stats.ile(0.25);
735      pitch_iqr = pitch_stats.ile(0.75) - pitch_stats.ile(0.25);
736      pitch = pitch_stats.ile(0.5);
737      used_dm_model = false;
738    } else {
739      if (testing_on) {
740        tprintf(
741            &quot;Choosing dm version:pitch_iqr=%g, gap_iqr=%g, dm_pitch_iqr=%g, &quot;
742            &quot;dm_gap_iqr=%g\n&quot;,
743            pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr);
744      }
745      gap_iqr = dm_gap_iqr;
746      pitch_iqr = dm_pitch_iqr;
747      pitch = dm_pitch;
748      used_dm_model = true;
749    }
750    if (textord_debug_pitch_metric) {
751      tprintf(&quot;rev_p_iqr=%g:rev_g_iqr=%g:pitch=%g:&quot;, pitch_iqr, gap_iqr, pitch);
752      tprintf(&quot;p_iqr/g=%g:p_iqr/x=%g:iqr_res=%c:&quot;, pitch_iqr / gap_iqr, pitch_iqr / block-&gt;xheight,
753              pitch_iqr &lt; gap_iqr * textord_fpiqr_ratio &amp;&amp;
754                      pitch_iqr &lt; block-&gt;xheight * textord_max_pitch_iqr &amp;&amp;
755                      pitch &lt; block-&gt;xheight * textord_words_default_maxspace
756                  ? &#x27;F&#x27;
757                  : &#x27;P&#x27;);
758    }
759    if (pitch_iqr &lt; gap_iqr * textord_fpiqr_ratio &amp;&amp;
760        pitch_iqr &lt; block-&gt;xheight * textord_max_pitch_iqr &amp;&amp;
761        pitch &lt; block-&gt;xheight * textord_words_default_maxspace) {
762      row-&gt;pitch_decision = PITCH_MAYBE_FIXED;
763    } else {
764      row-&gt;pitch_decision = PITCH_MAYBE_PROP;
765    }
766    row-&gt;fixed_pitch = pitch;
767    row-&gt;kern_size = gap_stats.ile(0.5);
768    row-&gt;min_space = static_cast&lt;int32_t&gt;(row-&gt;fixed_pitch + non_space) / 2;
769    if (row-&gt;min_space &gt; row-&gt;fixed_pitch) {
770      row-&gt;min_space = static_cast&lt;int32_t&gt;(row-&gt;fixed_pitch);
771    }
772    row-&gt;max_nonspace = row-&gt;min_space;
773    row-&gt;space_size = row-&gt;fixed_pitch;
774    row-&gt;space_threshold = (row-&gt;max_nonspace + row-&gt;min_space) / 2;
775    row-&gt;used_dm_model = used_dm_model;
776    return true;
777  }
778  bool fixed_pitch_row(TO_ROW *row, 
779                       BLOCK *block,
780                       int32_t block_index 
781  ) {
782    const char *res_string; 
783    int16_t mid_cuts;       
784    float non_space;        
785    float pitch_sd;         
786    float sp_sd = 0.0f;     
787    non_space = row-&gt;fp_nonsp;
788    if (non_space &gt; row-&gt;fixed_pitch) {
789      non_space = row-&gt;fixed_pitch;
790    }
791    POLY_BLOCK *pb = block != nullptr ? block-&gt;pdblk.poly_block() : nullptr;
792    if (textord_all_prop || (pb != nullptr &amp;&amp; !pb-&gt;IsText())) {
793      pitch_sd = textord_words_def_prop * row-&gt;fixed_pitch;
794      row-&gt;pitch_decision = PITCH_DEF_PROP;
795    } else {
796      pitch_sd = tune_row_pitch(row, &amp;row-&gt;projection, row-&gt;projection_left, row-&gt;projection_right,
797                                (row-&gt;fixed_pitch + non_space * 3) / 4, row-&gt;fixed_pitch, sp_sd,
798                                mid_cuts, &amp;row-&gt;char_cells, block_index == textord_debug_block);
799      if (pitch_sd &lt; textord_words_pitchsd_threshold * row-&gt;fixed_pitch &amp;&amp;
800          ((pitsync_linear_version &amp; 3) &lt; 3 ||
801           ((pitsync_linear_version &amp; 3) &gt;= 3 &amp;&amp;
802            (row-&gt;used_dm_model || sp_sd &gt; 20 || (pitch_sd == 0 &amp;&amp; sp_sd &gt; 10))))) {
803        if (pitch_sd &lt; textord_words_def_fixed * row-&gt;fixed_pitch &amp;&amp; !row-&gt;all_caps &amp;&amp;
804            ((pitsync_linear_version &amp; 3) &lt; 3 || sp_sd &gt; 20)) {
805          row-&gt;pitch_decision = PITCH_DEF_FIXED;
806        } else {
807          row-&gt;pitch_decision = PITCH_MAYBE_FIXED;
808        }
809      } else if ((pitsync_linear_version &amp; 3) &lt; 3 || sp_sd &gt; 20 || mid_cuts &gt; 0 ||
810                 pitch_sd &gt;= textord_words_pitchsd_threshold * row-&gt;fixed_pitch) {
811        if (pitch_sd &lt; textord_words_def_prop * row-&gt;fixed_pitch) {
812          row-&gt;pitch_decision = PITCH_MAYBE_PROP;
813        } else {
814          row-&gt;pitch_decision = PITCH_DEF_PROP;
815        }
816      } else {
817        row-&gt;pitch_decision = PITCH_DUNNO;
818      }
819    }
820    if (textord_debug_pitch_metric) {
821      res_string = &quot;??&quot;;
822      switch (row-&gt;pitch_decision) {
823        case PITCH_DEF_PROP:
824          res_string = &quot;DP&quot;;
825          break;
826        case PITCH_MAYBE_PROP:
827          res_string = &quot;MP&quot;;
828          break;
829        case PITCH_DEF_FIXED:
830          res_string = &quot;DF&quot;;
831          break;
832        case PITCH_MAYBE_FIXED:
833          res_string = &quot;MF&quot;;
834          break;
835        default:
836          res_string = &quot;??&quot;;
837      }
838      tprintf(&quot;:sd/p=%g:occ=%g:init_res=%s\n&quot;, pitch_sd / row-&gt;fixed_pitch, sp_sd, res_string);
839    }
840    return true;
841  }
842  bool count_pitch_stats(  
843      TO_ROW *row,         
844      STATS *gap_stats,    
845      STATS *pitch_stats,  
846      float initial_pitch, 
847      float min_space,     
848      bool ignore_outsize, 
849      bool split_outsize,  
850      int32_t dm_gap       
851  ) {
852    bool prev_valid; 
853    BLOBNBOX *blob;  
854    BLOBNBOX_IT blob_it = row-&gt;blob_list();
855    int32_t prev_right;  
856    int32_t prev_centre; 
857    int32_t x_centre;    
858    int32_t blob_width;  
859    int32_t width_units; 
860    float width;         
861    TBOX blob_box;       
862    TBOX joined_box;     
863    gap_stats-&gt;clear();
864    pitch_stats-&gt;clear();
865    if (blob_it.empty()) {
866      return false;
867    }
868    prev_valid = false;
869    prev_centre = 0;
870    prev_right = 0; 
871    joined_box = blob_it.data()-&gt;bounding_box();
872    do {
873      blob_it.forward();
874      blob = blob_it.data();
875      if (!blob-&gt;joined_to_prev()) {
876        blob_box = blob-&gt;bounding_box();
877        if ((blob_box.left() - joined_box.right() &lt; dm_gap &amp;&amp; !blob_it.at_first()) ||
878            blob-&gt;cblob() == nullptr) {
879          joined_box += blob_box; 
880        } else {
881          blob_width = joined_box.width();
882          if (split_outsize) {
883            width_units =
884                static_cast&lt;int32_t&gt;(floor(static_cast&lt;float&gt;(blob_width) / initial_pitch + 0.5));
885            if (width_units &lt; 1) {
886              width_units = 1;
887            }
888            width_units--;
889          } else if (ignore_outsize) {
890            width = static_cast&lt;float&gt;(blob_width) / initial_pitch;
891            width_units =
892                width &lt; 1 + words_default_fixed_limit &amp;&amp; width &gt; 1 - words_default_fixed_limit ? 0
893                                                                                               : -1;
894          } else {
895            width_units = 0; 
896          }
897          x_centre = static_cast&lt;int32_t&gt;(joined_box.left() +
898                                          (blob_width - width_units * initial_pitch) / 2);
899          if (prev_valid &amp;&amp; width_units &gt;= 0) {
900            gap_stats-&gt;add(joined_box.left() - prev_right, 1);
901            pitch_stats-&gt;add(x_centre - prev_centre, 1);
902          }
903          prev_centre = static_cast&lt;int32_t&gt;(x_centre + width_units * initial_pitch);
904          prev_right = joined_box.right();
905          prev_valid = blob_box.left() - joined_box.right() &lt; min_space;
906          prev_valid = prev_valid &amp;&amp; width_units &gt;= 0;
907          joined_box = blob_box;
908        }
909      }
910    } while (!blob_it.at_first());
911    return gap_stats-&gt;get_total() &gt;= 3;
912  }
913  float tune_row_pitch(           
914      TO_ROW *row,                
915      STATS *projection,          
916      int16_t projection_left,    
917      int16_t projection_right,   
918      float space_size,           
919      float &amp;initial_pitch,       
920      float &amp;best_sp_sd,          
921      int16_t &amp;best_mid_cuts,     
922      ICOORDELT_LIST *best_cells, 
923      bool testing_on             
924  ) {
925    int pitch_delta;           
926    int16_t mid_cuts;          
927    float pitch_sd;            
928    float best_sd;             
929    float best_pitch;          
930    float initial_sd;          
931    float sp_sd;               
932    ICOORDELT_LIST test_cells; 
933    ICOORDELT_IT best_it;      
934    if (textord_fast_pitch_test) {
935      return tune_row_pitch2(row, projection, projection_left, projection_right, space_size,
936                             initial_pitch, best_sp_sd,
937                             best_mid_cuts, best_cells, testing_on);
938    }
939    if (textord_disable_pitch_test) {
940      best_sp_sd = initial_pitch;
941      return initial_pitch;
942    }
943    initial_sd = compute_pitch_sd(row, projection, projection_left, projection_right, space_size,
944                                  initial_pitch, best_sp_sd, best_mid_cuts, best_cells, testing_on);
945    best_sd = initial_sd;
946    best_pitch = initial_pitch;
947    if (testing_on) {
948      tprintf(&quot;tune_row_pitch:start pitch=%g, sd=%g\n&quot;, best_pitch, best_sd);
949    }
950    for (pitch_delta = 1; pitch_delta &lt;= textord_pitch_range; pitch_delta++) {
951      pitch_sd =
952          compute_pitch_sd(row, projection, projection_left, projection_right, space_size,
953                           initial_pitch + pitch_delta, sp_sd, mid_cuts, &amp;test_cells, testing_on);
954      if (testing_on) {
955        tprintf(&quot;testing pitch at %g, sd=%g\n&quot;, initial_pitch + pitch_delta, pitch_sd);
956      }
957      if (pitch_sd &lt; best_sd) {
958        best_sd = pitch_sd;
959        best_mid_cuts = mid_cuts;
960        best_sp_sd = sp_sd;
961        best_pitch = initial_pitch + pitch_delta;
962        best_cells-&gt;clear();
963        best_it.set_to_list(best_cells);
964        best_it.add_list_after(&amp;test_cells);
965      } else {
966        test_cells.clear();
967      }
968      if (pitch_sd &gt; initial_sd) {
969        break; 
970      }
971    }
972    for (pitch_delta = 1; pitch_delta &lt;= textord_pitch_range; pitch_delta++) {
973      pitch_sd =
974          compute_pitch_sd(row, projection, projection_left, projection_right, space_size,
975                           initial_pitch - pitch_delta, sp_sd, mid_cuts, &amp;test_cells, testing_on);
976      if (testing_on) {
977        tprintf(&quot;testing pitch at %g, sd=%g\n&quot;, initial_pitch - pitch_delta, pitch_sd);
978      }
979      if (pitch_sd &lt; best_sd) {
980        best_sd = pitch_sd;
981        best_mid_cuts = mid_cuts;
982        best_sp_sd = sp_sd;
983        best_pitch = initial_pitch - pitch_delta;
984        best_cells-&gt;clear();
985        best_it.set_to_list(best_cells);
986        best_it.add_list_after(&amp;test_cells);
987      } else {
988        test_cells.clear();
989      }
990      if (pitch_sd &gt; initial_sd) {
991        break;
992      }
993    }
994    initial_pitch = best_pitch;
995    if (textord_debug_pitch_metric) {
996      print_pitch_sd(row, projection, projection_left, projection_right, space_size, best_pitch);
997    }
998    return best_sd;
999  }
1000  float tune_row_pitch2(          
1001      TO_ROW *row,                
1002      STATS *projection,          
1003      int16_t projection_left,    
1004      int16_t projection_right,   
1005      float space_size,           
1006      float &amp;initial_pitch,       
1007      float &amp;best_sp_sd,          
1008      int16_t &amp;best_mid_cuts,     
1009      ICOORDELT_LIST *best_cells, 
1010      bool testing_on             
1011  ) {
1012    int pitch_delta;    
1013    int16_t pixel;      
1014    int16_t best_pixel; 
1015    int16_t best_delta; 
1016    int16_t best_pitch; 
1017    int16_t start;      
1018    int16_t end;        
1019    int32_t best_count; 
1020    float best_sd;      
1021    best_sp_sd = initial_pitch;
1022    best_pitch = static_cast&lt;int&gt;(initial_pitch);
1023    if (textord_disable_pitch_test || best_pitch &lt;= textord_pitch_range) {
1024      return initial_pitch;
1025    }
1026    std::unique_ptr&lt;STATS[]&gt; sum_proj(new STATS[textord_pitch_range * 2 + 1]); 
1027    for (pitch_delta = -textord_pitch_range; pitch_delta &lt;= textord_pitch_range; pitch_delta++) {
1028      sum_proj[textord_pitch_range + pitch_delta].set_range(0, best_pitch + pitch_delta);
1029    }
1030    for (pixel = projection_left; pixel &lt;= projection_right; pixel++) {
1031      for (pitch_delta = -textord_pitch_range; pitch_delta &lt;= textord_pitch_range; pitch_delta++) {
1032        sum_proj[textord_pitch_range + pitch_delta].add(
1033            (pixel - projection_left) % (best_pitch + pitch_delta), projection-&gt;pile_count(pixel));
1034      }
1035    }
1036    best_count = sum_proj[textord_pitch_range].pile_count(0);
1037    best_delta = 0;
1038    best_pixel = 0;
1039    for (pitch_delta = -textord_pitch_range; pitch_delta &lt;= textord_pitch_range; pitch_delta++) {
1040      for (pixel = 0; pixel &lt; best_pitch + pitch_delta; pixel++) {
1041        if (sum_proj[textord_pitch_range + pitch_delta].pile_count(pixel) &lt; best_count) {
1042          best_count = sum_proj[textord_pitch_range + pitch_delta].pile_count(pixel);
1043          best_delta = pitch_delta;
1044          best_pixel = pixel;
1045        }
1046      }
1047    }
1048    if (testing_on) {
1049      tprintf(&quot;tune_row_pitch:start pitch=%g, best_delta=%d, count=%d\n&quot;, initial_pitch, best_delta,
1050              best_count);
1051    }
1052    best_pitch += best_delta;
1053    initial_pitch = best_pitch;
1054    best_count++;
1055    best_count += best_count;
1056    for (start = best_pixel - 2;
1057         start &gt; best_pixel - best_pitch &amp;&amp;
1058         sum_proj[textord_pitch_range + best_delta].pile_count(start % best_pitch) &lt;= best_count;
1059         start--) {
1060      ;
1061    }
1062    for (end = best_pixel + 2;
1063         end &lt; best_pixel + best_pitch &amp;&amp;
1064         sum_proj[textord_pitch_range + best_delta].pile_count(end % best_pitch) &lt;= best_count;
1065         end++) {
1066      ;
1067    }
1068    best_sd = compute_pitch_sd(row, projection, projection_left, projection_right, space_size,
1069                               initial_pitch, best_sp_sd, best_mid_cuts, best_cells, testing_on,
1070                               start, end);
1071    if (testing_on) {
1072      tprintf(&quot;tune_row_pitch:output pitch=%g, sd=%g\n&quot;, initial_pitch, best_sd);
1073    }
1074    if (textord_debug_pitch_metric) {
1075      print_pitch_sd(row, projection, projection_left, projection_right, space_size, initial_pitch);
1076    }
1077    return best_sd;
1078  }
1079  float compute_pitch_sd(        
1080      TO_ROW *row,               
1081      STATS *projection,         
1082      int16_t projection_left,   
1083      int16_t projection_right,  
1084      float space_size,          
1085      float initial_pitch,       
1086      float &amp;sp_sd,              
1087      int16_t &amp;mid_cuts,         
1088      ICOORDELT_LIST *row_cells, 
1089      bool testing_on,           
1090      int16_t start,             
1091      int16_t end                
1092  ) {
1093    int16_t occupation; 
1094    BLOBNBOX_IT blob_it = row-&gt;blob_list();
1095    BLOBNBOX_IT start_it;  
1096    BLOBNBOX_IT plot_it;   
1097    int16_t blob_count;    
1098    TBOX blob_box;         
1099    TBOX prev_box;         
1100    int32_t prev_right;    
1101    int scale_factor;      
1102    int32_t sp_count;      
1103    FPSEGPT_LIST seg_list; 
1104    FPSEGPT_IT seg_it;     
1105    int16_t segpos;        
1106    int16_t cellpos;       
1107    ICOORDELT_IT cell_it = row_cells;
1108    ICOORDELT *cell;     
1109    double sqsum;        
1110    double spsum;        
1111    double sp_var;       
1112    double word_sync;    
1113    int32_t total_count; 
1114    if ((pitsync_linear_version &amp; 3) &gt; 1) {
1115      word_sync = compute_pitch_sd2(row, projection, projection_left, projection_right, initial_pitch,
1116                                    occupation, mid_cuts, row_cells, testing_on, start, end);
1117      sp_sd = occupation;
1118      return word_sync;
1119    }
1120    mid_cuts = 0;
1121    cellpos = 0;
1122    total_count = 0;
1123    sqsum = 0;
1124    sp_count = 0;
1125    spsum = 0;
1126    prev_right = -1;
1127    if (blob_it.empty()) {
1128      return space_size * 10;
1129    }
1130  #ifndef GRAPHICS_DISABLED
1131    if (testing_on &amp;&amp; to_win != nullptr) {
1132      blob_box = blob_it.data()-&gt;bounding_box();
1133      projection-&gt;plot(to_win, projection_left, row-&gt;intercept(), 1.0f, -1.0f, ScrollView::CORAL);
1134    }
1135  #endif
1136    start_it = blob_it;
1137    blob_count = 0;
1138    blob_box = box_next(&amp;blob_it); 
1139    blob_it.mark_cycle_pt();
1140    do {
1141      for (; blob_count &gt; 0; blob_count--) {
1142        box_next(&amp;start_it);
1143      }
1144      do {
1145        prev_box = blob_box;
1146        blob_count++;
1147        blob_box = box_next(&amp;blob_it);
1148      } while (!blob_it.cycled_list() &amp;&amp; blob_box.left() - prev_box.right() &lt; space_size);
1149      plot_it = start_it;
1150      if (pitsync_linear_version &amp; 3) {
1151        word_sync = check_pitch_sync2(&amp;start_it, blob_count, static_cast&lt;int16_t&gt;(initial_pitch), 2,
1152                                      projection, projection_left, projection_right,
1153                                      row-&gt;xheight * textord_projection_scale, occupation, &amp;seg_list,
1154                                      start, end);
1155      } else {
1156        word_sync = check_pitch_sync(&amp;start_it, blob_count, static_cast&lt;int16_t&gt;(initial_pitch), 2,
1157                                     projection, &amp;seg_list);
1158      }
1159      if (testing_on) {
1160        tprintf(&quot;Word ending at (%d,%d), len=%d, sync rating=%g, &quot;, prev_box.right(), prev_box.top(),
1161                seg_list.length() - 1, word_sync);
1162        seg_it.set_to_list(&amp;seg_list);
1163        for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
1164          if (seg_it.data()-&gt;faked) {
1165            tprintf(&quot;(F)&quot;);
1166          }
1167          tprintf(&quot;%d, &quot;, seg_it.data()-&gt;position());
1168        }
1169        tprintf(&quot;\n&quot;);
1170      }
1171  #ifndef GRAPHICS_DISABLED
1172      if (textord_show_fixed_cuts &amp;&amp; blob_count &gt; 0 &amp;&amp; to_win != nullptr) {
1173        plot_fp_cells2(to_win, ScrollView::GOLDENROD, row, &amp;seg_list);
1174      }
1175  #endif
1176      seg_it.set_to_list(&amp;seg_list);
1177      if (prev_right &gt;= 0) {
1178        sp_var = seg_it.data()-&gt;position() - prev_right;
1179        sp_var -= floor(sp_var / initial_pitch + 0.5) * initial_pitch;
1180        sp_var *= sp_var;
1181        spsum += sp_var;
1182        sp_count++;
1183      }
1184      for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
1185        segpos = seg_it.data()-&gt;position();
1186        if (cell_it.empty() || segpos &gt; cellpos + initial_pitch / 2) {
1187          while (!cell_it.empty() &amp;&amp; segpos &gt; cellpos + initial_pitch * 3 / 2) {
1188            cell = new ICOORDELT(cellpos + static_cast&lt;int16_t&gt;(initial_pitch), 0);
1189            cell_it.add_after_then_move(cell);
1190            cellpos += static_cast&lt;int16_t&gt;(initial_pitch);
1191          }
1192          cell = new ICOORDELT(segpos, 0);
1193          cell_it.add_after_then_move(cell);
1194          cellpos = segpos;
1195        } else if (segpos &gt; cellpos - initial_pitch / 2) {
1196          cell = cell_it.data();
1197          cell-&gt;set_x((cellpos + segpos) / 2);
1198          cellpos = cell-&gt;x();
1199        }
1200      }
1201      seg_it.move_to_last();
1202      prev_right = seg_it.data()-&gt;position();
1203      if (textord_pitch_scalebigwords) {
1204        scale_factor = (seg_list.length() - 2) / 2;
1205        if (scale_factor &lt; 1) {
1206          scale_factor = 1;
1207        }
1208      } else {
1209        scale_factor = 1;
1210      }
1211      sqsum += word_sync * scale_factor;
1212      total_count += (seg_list.length() - 1) * scale_factor;
1213      seg_list.clear();
1214    } while (!blob_it.cycled_list());
1215    sp_sd = sp_count &gt; 0 ? sqrt(spsum / sp_count) : 0;
1216    return total_count &gt; 0 ? sqrt(sqsum / total_count) : space_size * 10;
1217  }
1218  float compute_pitch_sd2(       
1219      TO_ROW *row,               
1220      STATS *projection,         
1221      int16_t projection_left,   
1222      int16_t projection_right,  
1223      float initial_pitch,       
1224      int16_t &amp;occupation,       
1225      int16_t &amp;mid_cuts,         
1226      ICOORDELT_LIST *row_cells, 
1227      bool testing_on,           
1228      int16_t start,             
1229      int16_t end                
1230  ) {
1231    BLOBNBOX_IT blob_it = row-&gt;blob_list();
1232    BLOBNBOX_IT plot_it;
1233    int16_t blob_count;    
1234    TBOX blob_box;         
1235    FPSEGPT_LIST seg_list; 
1236    FPSEGPT_IT seg_it;     
1237    int16_t segpos;        
1238    ICOORDELT_IT cell_it = row_cells;
1239    ICOORDELT *cell;  
1240    double word_sync; 
1241    mid_cuts = 0;
1242    if (blob_it.empty()) {
1243      occupation = 0;
1244      return initial_pitch * 10;
1245    }
1246  #ifndef GRAPHICS_DISABLED
1247    if (testing_on &amp;&amp; to_win != nullptr) {
1248      projection-&gt;plot(to_win, projection_left, row-&gt;intercept(), 1.0f, -1.0f, ScrollView::CORAL);
1249    }
1250  #endif
1251    blob_count = 0;
1252    blob_it.mark_cycle_pt();
1253    do {
1254      blob_box = box_next(&amp;blob_it);
<span onclick='openModal()' class='match'>1255      blob_count++;
1256    } while (!blob_it.cycled_list());
1257    plot_it = blob_it;
</span>1258    word_sync = check_pitch_sync2(
1259        &amp;blob_it, blob_count, static_cast&lt;int16_t&gt;(initial_pitch), 2, projection, projection_left,
1260        projection_right, row-&gt;xheight * textord_projection_scale, occupation, &amp;seg_list, start, end);
1261    if (testing_on) {
1262      tprintf(&quot;Row ending at (%d,%d), len=%d, sync rating=%g, &quot;, blob_box.right(), blob_box.top(),
1263              seg_list.length() - 1, word_sync);
1264      seg_it.set_to_list(&amp;seg_list);
1265      for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
1266        if (seg_it.data()-&gt;faked) {
1267          tprintf(&quot;(F)&quot;);
1268        }
1269        tprintf(&quot;%d, &quot;, seg_it.data()-&gt;position());
1270      }
1271      tprintf(&quot;\n&quot;);
1272    }
1273  #ifndef GRAPHICS_DISABLED
1274    if (textord_show_fixed_cuts &amp;&amp; blob_count &gt; 0 &amp;&amp; to_win != nullptr) {
1275      plot_fp_cells2(to_win, ScrollView::GOLDENROD, row, &amp;seg_list);
1276    }
1277  #endif
1278    seg_it.set_to_list(&amp;seg_list);
1279    for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
1280      segpos = seg_it.data()-&gt;position();
1281      cell = new ICOORDELT(segpos, 0);
1282      cell_it.add_after_then_move(cell);
1283      if (seg_it.at_last()) {
1284        mid_cuts = seg_it.data()-&gt;cheap_cuts();
1285      }
1286    }
1287    seg_list.clear();
1288    return occupation &gt; 0 ? sqrt(word_sync / occupation) : initial_pitch * 10;
1289  }
1290  void print_pitch_sd(         
1291      TO_ROW *row,             
1292      STATS *projection,       
1293      int16_t projection_left, 
1294      int16_t projection_right, float space_size,
1295      float initial_pitch 
1296  ) {
1297    const char *res2;   
1298    int16_t occupation; 
1299    float sp_sd;        
1300    BLOBNBOX_IT blob_it = row-&gt;blob_list();
1301    BLOBNBOX_IT start_it;     
1302    BLOBNBOX_IT row_start;    
1303    int16_t blob_count;       
1304    int16_t total_blob_count; 
1305    TBOX blob_box;            
1306    TBOX prev_box;            
1307    int32_t prev_right;       
1308    int scale_factor;         
1309    int32_t sp_count;         
1310    FPSEGPT_LIST seg_list;    
1311    FPSEGPT_IT seg_it;        
1312    double sqsum;             
1313    double spsum;             
1314    double sp_var;            
1315    double word_sync;         
1316    double total_count;       
1317    if (blob_it.empty()) {
1318      return;
1319    }
1320    row_start = blob_it;
1321    total_blob_count = 0;
1322    total_count = 0;
1323    sqsum = 0;
1324    sp_count = 0;
1325    spsum = 0;
1326    prev_right = -1;
1327    blob_it = row_start;
1328    start_it = blob_it;
1329    blob_count = 0;
1330    blob_box = box_next(&amp;blob_it); 
1331    blob_it.mark_cycle_pt();
1332    do {
1333      for (; blob_count &gt; 0; blob_count--) {
1334        box_next(&amp;start_it);
1335      }
1336      do {
1337        prev_box = blob_box;
1338        blob_count++;
1339        blob_box = box_next(&amp;blob_it);
1340      } while (!blob_it.cycled_list() &amp;&amp; blob_box.left() - prev_box.right() &lt; space_size);
1341      word_sync = check_pitch_sync2(
1342          &amp;start_it, blob_count, static_cast&lt;int16_t&gt;(initial_pitch), 2, projection, projection_left,
1343          projection_right, row-&gt;xheight * textord_projection_scale, occupation, &amp;seg_list, 0, 0);
1344      total_blob_count += blob_count;
1345      seg_it.set_to_list(&amp;seg_list);
1346      if (prev_right &gt;= 0) {
1347        sp_var = seg_it.data()-&gt;position() - prev_right;
1348        sp_var -= floor(sp_var / initial_pitch + 0.5) * initial_pitch;
1349        sp_var *= sp_var;
1350        spsum += sp_var;
1351        sp_count++;
1352      }
1353      seg_it.move_to_last();
1354      prev_right = seg_it.data()-&gt;position();
1355      if (textord_pitch_scalebigwords) {
1356        scale_factor = (seg_list.length() - 2) / 2;
1357        if (scale_factor &lt; 1) {
1358          scale_factor = 1;
1359        }
1360      } else {
1361        scale_factor = 1;
1362      }
1363      sqsum += word_sync * scale_factor;
1364      total_count += (seg_list.length() - 1) * scale_factor;
1365      seg_list.clear();
1366    } while (!blob_it.cycled_list());
1367    sp_sd = sp_count &gt; 0 ? sqrt(spsum / sp_count) : 0;
1368    word_sync = total_count &gt; 0 ? sqrt(sqsum / total_count) : space_size * 10;
1369    tprintf(&quot;new_sd=%g:sd/p=%g:new_sp_sd=%g:res=%c:&quot;, word_sync, word_sync / initial_pitch, sp_sd,
1370            word_sync &lt; textord_words_pitchsd_threshold * initial_pitch ? &#x27;F&#x27; : &#x27;P&#x27;);
1371    start_it = row_start;
1372    blob_it = row_start;
1373    word_sync =
1374        check_pitch_sync2(&amp;blob_it, total_blob_count, static_cast&lt;int16_t&gt;(initial_pitch), 2,
1375                          projection, projection_left, projection_right,
1376                          row-&gt;xheight * textord_projection_scale, occupation, &amp;seg_list, 0, 0);
1377    if (occupation &gt; 1) {
1378      word_sync /= occupation;
1379    }
1380    word_sync = sqrt(word_sync);
1381  #ifndef GRAPHICS_DISABLED
1382    if (textord_show_row_cuts &amp;&amp; to_win != nullptr) {
1383      plot_fp_cells2(to_win, ScrollView::CORAL, row, &amp;seg_list);
1384    }
1385  #endif
1386    seg_list.clear();
1387    if (word_sync &lt; textord_words_pitchsd_threshold * initial_pitch) {
1388      if (word_sync &lt; textord_words_def_fixed * initial_pitch &amp;&amp; !row-&gt;all_caps) {
1389        res2 = &quot;DF&quot;;
1390      } else {
1391        res2 = &quot;MF&quot;;
1392      }
1393    } else {
1394      res2 = word_sync &lt; textord_words_def_prop * initial_pitch ? &quot;MP&quot; : &quot;DP&quot;;
1395    }
1396    tprintf(
1397        &quot;row_sd=%g:sd/p=%g:res=%c:N=%d:res2=%s,init pitch=%g, row_pitch=%g, &quot;
1398        &quot;all_caps=%d\n&quot;,
1399        word_sync, word_sync / initial_pitch,
1400        word_sync &lt; textord_words_pitchsd_threshold * initial_pitch ? &#x27;F&#x27; : &#x27;P&#x27;, occupation, res2,
1401        initial_pitch, row-&gt;fixed_pitch, row-&gt;all_caps);
1402  }
1403  void find_repeated_chars(TO_BLOCK *block,   
1404                           bool testing_on) { 
1405    POLY_BLOCK *pb = block-&gt;block-&gt;pdblk.poly_block();
1406    if (pb != nullptr &amp;&amp; !pb-&gt;IsText()) {
1407      return; 
1408    }
1409    TO_ROW *row;
1410    BLOBNBOX_IT box_it;
1411    BLOBNBOX_IT search_it; 
1412    WERD *word;            
1413    TBOX word_box;         
1414    int blobcount, repeated_set;
1415    TO_ROW_IT row_it = block-&gt;get_rows();
1416    if (row_it.empty()) {
1417      return; 
1418    }
1419    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1420      row = row_it.data();
1421      box_it.set_to_list(row-&gt;blob_list());
1422      if (box_it.empty()) {
1423        continue; 
1424      }
1425      if (!row-&gt;rep_chars_marked()) {
1426        mark_repeated_chars(row);
1427      }
1428      if (row-&gt;num_repeated_sets() == 0) {
1429        continue; 
1430      }
1431      WERD_IT word_it(&amp;row-&gt;rep_words);
1432      do {
1433        if (box_it.data()-&gt;repeated_set() != 0 &amp;&amp; !box_it.data()-&gt;joined_to_prev()) {
1434          blobcount = 1;
1435          repeated_set = box_it.data()-&gt;repeated_set();
1436          search_it = box_it;
1437          search_it.forward();
1438          while (!search_it.at_first() &amp;&amp; search_it.data()-&gt;repeated_set() == repeated_set) {
1439            blobcount++;
1440            search_it.forward();
1441          }
1442          word = make_real_word(&amp;box_it, blobcount, box_it.at_first(), 1);
1443          if (!box_it.empty() &amp;&amp; box_it.data()-&gt;joined_to_prev()) {
1444            tprintf(&quot;Bad box joined to prev at&quot;);
1445            box_it.data()-&gt;bounding_box().print();
1446            tprintf(&quot;After repeated word:&quot;);
1447            word-&gt;bounding_box().print();
1448          }
1449          ASSERT_HOST(box_it.empty() || !box_it.data()-&gt;joined_to_prev());
1450          word-&gt;set_flag(W_REP_CHAR, true);
1451          word-&gt;set_flag(W_DONT_CHOP, true);
1452          word_it.add_after_then_move(word);
1453        } else {
1454          box_it.forward();
1455        }
1456      } while (!box_it.at_first());
1457    }
1458  }
1459  #ifndef GRAPHICS_DISABLED
1460  void plot_fp_word(   
1461      TO_BLOCK *block, 
1462      float pitch,     
1463      float nonspace   
1464  ) {
1465    TO_ROW *row; 
1466    TO_ROW_IT row_it = block-&gt;get_rows();
1467    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1468      row = row_it.data();
1469      row-&gt;min_space = static_cast&lt;int32_t&gt;((pitch + nonspace) / 2);
1470      row-&gt;max_nonspace = row-&gt;min_space;
1471      row-&gt;space_threshold = row-&gt;min_space;
1472      plot_word_decisions(to_win, static_cast&lt;int16_t&gt;(pitch), row);
1473    }
1474  }
1475  #endif
1476  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-makerow.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-topitch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1704      blobcount++;
1705    } while (!new_it.cycled_list());
1706    if (blobcount &gt; textord_spline_minblobs || segments == 1) {
</pre></code></div>
                <div class="column column_space"><pre><code>1255      blob_count++;
1256    } while (!blob_it.cycled_list());
1257    plot_it = blob_it;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    