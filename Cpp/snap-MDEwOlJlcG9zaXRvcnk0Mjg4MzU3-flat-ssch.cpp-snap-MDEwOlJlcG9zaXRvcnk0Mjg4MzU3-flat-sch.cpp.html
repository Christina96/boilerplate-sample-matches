
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssch.cpp</h3>
            <pre><code>1  #include "sch.h"
2  TSchTask::TSchTask(const int& _TaskId, const TStrV& _DimObjNmV,
3   const TSecTm& _StartTm, const TSecTm& _EndTm):
4    TaskId(_TaskId), DimObjNmV(_DimObjNmV), StartTm(_StartTm), EndTm(_EndTm){
5    IAssert(StartTm<EndTm);
6  }
7  TStr TSchTask::GetStr() const {
8    TChA ChA;
9    for (int DimN=0; DimN<DimObjNmV.Len(); DimN++){
10      if (DimN>0){ChA+=' ';}
11      ChA+=DimObjNmV[DimN];
12    }
13    return ChA;
14  }
15  bool TSchTask::IsCons(const PSchTask& Task1, const PSchTask& Task2){
16    return
17     (Task1->GetEndTm()<=Task2->GetStartTm())||
18     (Task2->GetEndTm()<=Task1->GetStartTm());
19  }
20  PSchTask TSchTask::LoadTxt(TILx& Lx){
21    PSchTask SchTask=PSchTask(new TSchTask());
22    Lx.GetVar("SchTask", true, true);
23    SchTask->TaskId=Lx.GetVarInt("TaskId");
24    Lx.GetVarStrV("DimObjNmV", SchTask->DimObjNmV);
25    SchTask->StartTm=Lx.GetVarSecTm("StartTm");
26    SchTask->EndTm=Lx.GetVarSecTm("EndTm");
27    Lx.GetVarEnd(true, true);
28    return SchTask;
29  }
30  void TSchTask::SaveTxt(TOLx& Lx) const {
31    Lx.PutVar("SchTask", true, true);
32    Lx.PutVarInt("TaskId", TaskId);
33    Lx.PutVarStrV("DimObjNmV", DimObjNmV);
34    Lx.PutVarSecTm("StartTm", StartTm);
35    Lx.PutVarSecTm("EndTm", EndTm);
36    Lx.PutVarEnd(true, true);
37  }
38  void TSchObj::AddTask(const PSchTask& Task){
39    IAssert(IsTaskOk(Task));
40    TTmTaskKd TmTaskKd(Task->GetStartTm(), Task);
41    int TaskN=TaskV.AddSorted(TmTaskKd);
42    if (0<TaskN){
43      PSchTask PrevTask=TaskV[TaskN-1].Dat;
44      IAssert(TSchTask::IsCons(PrevTask, Task));
45    }
46    if (TaskN+1<TaskV.Len()){
47      PSchTask NextTask=TaskV[TaskN+1].Dat;
48      IAssert(TSchTask::IsCons(Task, NextTask));
49    }
50  }
51  void TSchObj::DelTask(const PSchTask& Task){
52    TTmTaskKd TmTaskKd(Task->GetStartTm(), Task);
53    int TaskN=TaskV.SearchBin(TmTaskKd);
54    IAssert(TaskN!=-1);
55    IAssert(Task->GetTaskId()==TaskV[TaskN].Dat->GetTaskId());
56    TaskV.Del(TaskN);
57  }
58  bool TSchObj::IsTaskAtTm(const TSecTm& Tm, PSchTask& Task) const {
59    TTmTaskKd TmTaskKd(Tm);
60    int InsTaskN; int TaskN=TaskV.SearchBin(TmTaskKd, InsTaskN);
61    if (TaskN==-1){
62      if (InsTaskN==0){
63        Task=NULL; return false;
64      } else
65      if (TaskV[InsTaskN-1].Dat->IsTmIn(Tm)){
66        Task=TaskV[InsTaskN-1].Dat; return true;
67      } else {
68        Task=NULL; return false;
69      }
70    } else {
71      Task=TaskV[TaskN].Dat; return true;
72    }
73  }
74  bool TSchObj::IsTaskInTm(
75   const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
76    TTmTaskKd StartTmTaskKd(MnTm);
77    TTmTaskKd EndTmTaskKd(MxTm);
78    int StartInsTaskN; int EndInsTaskN;
79    int StartTaskN=TaskV.SearchBin(StartTmTaskKd, StartInsTaskN);
80    int EndTaskN=TaskV.SearchBin(EndTmTaskKd, EndInsTaskN);
81    if ((StartTaskN==-1)&&(EndTaskN==-1)){
82      if (StartInsTaskN==EndInsTaskN){
83        if (StartInsTaskN==0){
84          Task=NULL; return false;
85        } else
86        if (TaskV[StartInsTaskN-1].Dat->IsTmIn(MnTm)){
87          Task=TaskV[StartInsTaskN-1].Dat; return true;
88        } else {
<span onclick='openModal()' class='match'>89          Task=NULL; return false;
90        }
91      } else {
92        Task=TaskV[StartInsTaskN].Dat; return true;
93      }
94    } else {
</span>95      if (StartTaskN!=-1){IsTaskAtTm(MnTm, Task);}
96      else if (EndTaskN!=-1){IsTaskAtTm(MxTm, Task);}
97      else {Fail;}
98      IAssert(!Task.Empty());
99      return true;
100    }
101  }
102  PSchObj TSchObj::LoadTxt(TILx& Lx){
103    PSchObj SchObj=PSchObj(new TSchObj());
104    Lx.GetVar("SchObj", true, true);
105    SchObj->Nm=Lx.GetVarStr("Nm");
106    Lx.GetVar("TaskV", true, true);
107    while (!Lx.PeekVarEnd(true, true)){
108      PSchTask Task=TSchTask::LoadTxt(Lx);
109      SchObj->TaskV.Add(TTmTaskKd(Task->GetStartTm(), Task));
110    }
111    Lx.GetVarEnd(true, true);
112    Lx.GetVarEnd(true, true);
113    return SchObj;
114  }
115  void TSchObj::SaveTxt(TOLx& Lx) const {
116    Lx.PutVar("SchObj", true, true);
117    Lx.PutVarStr("Nm", Nm);
118    Lx.PutVar("TaskV", true, true);
119    for (int TaskN=0; TaskN<TaskV.Len(); TaskN++){
120      TaskV[TaskN].Dat->SaveTxt(Lx);}
121    Lx.PutVarEnd(true, true);
122    Lx.PutVarEnd(true, true);
123  }
124  int TSchDim::AddObj(const TStr& Nm){
125    IAssert(!NmToObjH.IsKey(Nm));
126    PSchObj Obj=PSchObj(new TSchObj(Nm));
127    NmToObjH.AddDat(Nm, Obj);
128    return NmToObjH.GetKeyId(Nm);
129  }
130  TStrV TSchDim::GetObjNmV() const {
131    TStrV NmV(NmToObjH.Len(), 0);
132    int NmToObjP=NmToObjH.FFirstKeyId();
133    while (NmToObjH.FNextKeyId(NmToObjP)){
134      NmV.Add(NmToObjH[NmToObjP]->GetNm());}
135    return NmV;
136  }
137  void TSchDim::AddTask(const PSchTask& Task){
138    PSchObj Obj=GetObj(Task->GetDimObjNm(DimN));
139    Obj->AddTask(Task);
140  }
141  void TSchDim::DelTask(const PSchTask& Task){
142    PSchObj Obj=GetObj(Task->GetDimObjNm(DimN));
143    Obj->DelTask(Task);
144  }
145  bool TSchDim::IsTaskOk(const PSchTask& Task, PSchTask& IcTask) const {
146    PSchObj Obj=GetObj(Task->GetDimObjNm(DimN));
147    return Obj->IsTaskOk(Task, IcTask);
148  }
149  bool TSchDim::IsTaskInTm(const TStr& ObjNm,
150   const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
151    PSchObj Obj=GetObj(ObjNm);
152    return Obj->IsTaskInTm(MnTm, MxTm, Task);
153  }
154  PSchDim TSchDim::LoadTxt(TILx& Lx){
155    PSchDim SchDim=PSchDim(new TSchDim());
156    Lx.GetVar("SchDim", true, true);
157    SchDim->DimN=Lx.GetVarInt("DimN");
158    SchDim->Nm=Lx.GetVarStr("Nm");
159    Lx.GetVar("NmToObjH", true, true);
160    int Ports=Lx.GetVarInt("Ports");
161    SchDim->NmToObjH=TNmToObjH(Ports);
162    while (!Lx.PeekVarEnd(true, true)){
163      PSchObj Obj=TSchObj::LoadTxt(Lx);
164      SchDim->NmToObjH.AddDat(Obj->GetNm(), Obj);
165    }
166    Lx.GetVarEnd(true, true);
167    Lx.GetVarEnd(true, true);
168    return SchDim;
169  }
170  void TSchDim::SaveTxt(TOLx& Lx) const {
171    Lx.PutVar("SchDim", true, true);
172    Lx.PutVarInt("DimN", DimN);
173    Lx.PutVarStr("Nm", Nm);
174    Lx.PutVar("NmToObjH", true, true);
175    int NmToObjP=NmToObjH.FFirstKeyId();
176    Lx.PutVarInt("Ports", NmToObjH.GetPorts());
177    while (NmToObjH.FNextKeyId(NmToObjP)){
178      NmToObjH[NmToObjP]->SaveTxt(Lx);}
179    Lx.PutVarEnd(true, true);
180    Lx.PutVarEnd(true, true);
181  }
182  TSch::TSch(const TStr& _Nm, const int& Dims,
183   const int& ExpObjs, const int& ExpTasks):
184    Nm(_Nm), DimV(Dims), LastTaskId(0), IdToTaskH(ExpTasks){
185    for (int DimN=0; DimN<Dims; DimN++){
186      DimV[DimN]=PSchDim(new TSchDim(DimN, ExpObjs));}
187  }
188  TStrV TSch::GetDimNmV() const {
189    TStrV DimNmV(GetDims(), 0);
190    for (int DimN=0; DimN<GetDims(); DimN++){
191      DimNmV.Add(GetDimNm(DimN));}
192    return DimNmV;
193  }
194  int TSch::GetDimN(const TStr& DimNm) const {
195    for (int DimN=0; DimN<GetDims(); DimN++){
196      if (GetDimNm(DimN)==DimNm){return DimN;}}
197    return -1;
198  }
199  int TSch::AddTask(
200   const TStrV& DimObjNmV, const TSecTm& StartTm, const TSecTm& EndTm){
201    IAssert(DimObjNmV.Len()==GetDims());
202    int TaskId=GetNewTaskId();
203    PSchTask Task=PSchTask(new TSchTask(TaskId, DimObjNmV, StartTm, EndTm));
204    IdToTaskH.AddDat(TaskId, Task);
205    for (int DimN=0; DimN<GetDims(); DimN++){
206      DimV[DimN]->AddTask(Task);}
207    return TaskId;
208  }
209  int TSch::AddTask(
210   const TStr& DimObjNm1, const TStr& DimObjNm2, const TStr& DimObjNm3,
211   const TSecTm& StartTm, const TSecTm& EndTm){
212    TStrV DimObjNmV(3, 0);
213    DimObjNmV.Add(DimObjNm1);
214    DimObjNmV.Add(DimObjNm2);
215    DimObjNmV.Add(DimObjNm3);
216    return AddTask(DimObjNmV, StartTm, EndTm);
217  }
218  void TSch::DelTask(const int& TaskId){
219    PSchTask Task=IdToTaskH.GetDat(TaskId);
220    for (int DimN=0; DimN<GetDims(); DimN++){
221      DimV[DimN]->DelTask(Task);}
222  }
223  bool TSch::IsTask(const int& TaskId, PSchTask& Task) const {
224    int IdToTaskP;
225    if (IdToTaskH.IsKey(TaskId, IdToTaskP)){
226      Task=IdToTaskH[IdToTaskP]; return true;}
227    else {return false;}
228  }
229  bool TSch::IsTaskOk(const PSchTask& Task, TSchTaskV& DimIcTaskV) const {
230    DimIcTaskV.Gen(GetDims(), GetDims());
231    bool Ok=true;
232    for (int DimN=0; DimN<GetDims(); DimN++){
233      PSchTask IcTask;
234      if (!DimV[DimN]->IsTaskOk(Task, IcTask)){
235        DimIcTaskV[DimN]=IcTask; Ok=false;
236      }
237    }
238    return Ok;
239  }
240  PSch TSch::LoadTxt(TILx& Lx){
241    PSch Sch=PSch(new TSch());
242    Lx.GetVar("Sch", true, true);
243    Sch->Nm=Lx.GetVarStr("Nm");
244    Lx.GetVar("DimV", true, true);
245    while (!Lx.PeekVarEnd(true, true)){
246      Sch->DimV.Add(TSchDim::LoadTxt(Lx));}
247    Lx.GetVarEnd(true, true);
248    Sch->LastTaskId=Lx.GetVarInt("LastTaskId");
249    Lx.GetVar("IdToTaskH", true, true);
250    int Ports=Lx.GetVarInt("Ports");
251    Sch->IdToTaskH=TIdToTaskH(Ports);
252    while (!Lx.PeekVarEnd(true, true)){
253      PSchTask Task=TSchTask::LoadTxt(Lx);
254      Sch->IdToTaskH.AddDat(Task->GetTaskId(), Task);
255    }
256    Lx.GetVarEnd(true, true);
257    Lx.GetVarEnd(true, true);
258    return Sch;
259  }
260  PSch TSch::LoadTxt(const TStr& FNm){
261    PSIn SIn=PSIn(new TFIn(FNm));
262    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloCsSens);
263    return LoadTxt(Lx);
264  }
265  void TSch::SaveTxt(TOLx& Lx) const {
266    Lx.PutVar("Sch", true, true);
267    Lx.PutVarStr("Nm", Nm);
268    Lx.PutVar("DimV", true, true);
269    for (int DimN=0; DimN<DimV.Len(); DimN++){
270      DimV[DimN]->SaveTxt(Lx);}
271    Lx.PutVarEnd(true, true);
272    Lx.PutVarInt("LastTaskId", LastTaskId);
273    Lx.PutVar("IdToTaskH", true, true);
274    Lx.PutVarInt("Ports", IdToTaskH.GetPorts());
275    int IdToTaskP=IdToTaskH.FFirstKeyId();
276    while (IdToTaskH.FNextKeyId(IdToTaskP)){
277      IdToTaskH[IdToTaskP]->SaveTxt(Lx);}
278    Lx.PutVarEnd(true, true);
279    Lx.PutVarEnd(true, true);
280  }
281  void TSch::SaveTxt(const TStr& FNm) const {
282    PSOut SOut=PSOut(new TFOut(FNm));
283    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens|oloVarIndent);
284    SaveTxt(Lx);
285  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sch.cpp</h3>
            <pre><code>1  #include "sch.h"
2  TSchTask::TSchTask(
3   const int& _TaskId, const TVec<TStrV>& _DimObjVV,
4   const TSecTm& _StartTm, const TSecTm& _EndTm, const bool& _Forced):
5    TaskId(_TaskId), DimObjVV(_DimObjVV),
6    StartTm(_StartTm), EndTm(_EndTm), Forced(_Forced){
7    IAssert(StartTm<EndTm);
8  }
9  TSchTask::TSchTask(
10   const int& _TaskId, const TStrV& DimObjV,
11   const TSecTm& _StartTm, const TSecTm& _EndTm, const bool& _Forced):
12    TaskId(_TaskId), DimObjVV(),
13    StartTm(_StartTm), EndTm(_EndTm), Forced(_Forced){
14    IAssert(StartTm<EndTm);
15    for (int DimObjN=0; DimObjN<DimObjV.Len(); DimObjN++){
16      DimObjVV.Add(); DimObjVV.Last().Add(DimObjV[DimObjN]);
17    }
18  }
19  TStr TSchTask::GetAllDimObjStr(const int& DimN) const {
20    TChA ChA;
21    for (int ObjN=0; ObjN<GetDimObjs(DimN); ObjN++){
22      if (ObjN>0){ChA+=", ";}
23      ChA+=GetDimObj(DimN, ObjN);
24    }
25    return ChA;
26  }
27  TStr TSchTask::GetStr() const {
28    TChA ChA;
29    if (Forced){ChA+="F:";}
30    for (int DimN=0; DimN<GetDims(); DimN++){
31      if (DimN>0){ChA+=' ';}
32      ChA+='[';
33      for (int ObjN=0; ObjN<GetDimObjs(DimN); ObjN++){
34        if (ObjN>0){ChA+=' ';}
35        ChA+=DimObjVV[DimN][ObjN];
36      }
37      ChA+=']';
38    }
39    return ChA;
40  }
41  bool TSchTask::IsCons(const PSchTask& Task1, const PSchTask& Task2){
42    IAssert((!Task1->IsForced())&&(!Task2->IsForced()));
43    return
44     (Task1->GetEndTm()<=Task2->GetStartTm())||
45     (Task2->GetEndTm()<=Task1->GetStartTm());
46  }
47  PSchTask TSchTask::LoadTxt(TILx& Lx){
48    PSchTask SchTask=PSchTask(new TSchTask());
49    Lx.GetVar("SchTask", true, true);
50    SchTask->TaskId=Lx.GetVarInt("TaskId");
51    Lx.GetVarStrVV("DimObjVV", SchTask->DimObjVV);
52    SchTask->StartTm=Lx.GetVarSecTm("StartTm");
53    SchTask->EndTm=Lx.GetVarSecTm("EndTm");
54    SchTask->Forced=Lx.GetVarBool("Forced");
55    Lx.GetVarEnd(true, true);
56    return SchTask;
57  }
58  void TSchTask::SaveTxt(TOLx& Lx) const {
59    Lx.PutVar("SchTask", true, true);
60    Lx.PutVarInt("TaskId", TaskId);
61    Lx.PutVarStrVV("DimObjVV", DimObjVV);
62    Lx.PutVarSecTm("StartTm", StartTm);
63    Lx.PutVarSecTm("EndTm", EndTm);
64    Lx.PutVarBool("Forced", Forced);
65    Lx.PutVarEnd(true, true);
66  }
67  void TSchObj::AddTask(const PSchTask& Task, const bool& OverlapCheckP){
68    IAssert(IsTaskOk(Task, OverlapCheckP));
69    if (Task->IsForced()){
70      FrcTaskV.Add(Task);
71    } else {
72      TTmTaskKd TmTaskKd(Task->GetStartTm(), Task);
73      int TaskN=TmTaskKdV.AddSorted(TmTaskKd);
74      if (0<TaskN){
75        PSchTask PrevTask=TmTaskKdV[TaskN-1].Dat;
76        if (OverlapCheckP){IAssert(TSchTask::IsCons(PrevTask, Task));}
77      }
78      if (TaskN+1<TmTaskKdV.Len()){
79        PSchTask NextTask=TmTaskKdV[TaskN+1].Dat;
80        if (OverlapCheckP){IAssert(TSchTask::IsCons(Task, NextTask));}
81      }
82    }
83  }
84  void TSchObj::DelTask(const PSchTask& Task){
85    if (Task->IsForced()){
86      int FrcTaskN=0;
87      while ((FrcTaskN<FrcTaskV.Len())&&
88       (FrcTaskV[FrcTaskN]->GetTaskId()!=Task->GetTaskId())){FrcTaskN++;}
89      IAssert(FrcTaskN<FrcTaskV.Len());
90      FrcTaskV.Del(FrcTaskN);
91    } else {
92      TTmTaskKd TmTaskKd(Task->GetStartTm(), Task);
93      int TaskN=TmTaskKdV.SearchBin(TmTaskKd);
94      IAssert(TaskN!=-1);
95      IAssert(Task->GetTaskId()==TmTaskKdV[TaskN].Dat->GetTaskId());
96      TmTaskKdV.Del(TaskN);
97    }
98  }
99  void TSchObj::GetTaskV(TSchTaskV& TaskV){
100    TaskV.Clr();
101    for (int TaskN=0; TaskN<GetTasks(); TaskN++){
102      TaskV.Add(GetTask(TaskN));}
103  }
104  int TSchObj::GetTasks() const {
105    return TmTaskKdV.Len()+FrcTaskV.Len();
106  }
107  PSchTask TSchObj::GetTask(const int& TaskN) const {
108    if (TaskN<TmTaskKdV.Len()){
109      return TmTaskKdV[TaskN].Dat;
110    } else {
111      return FrcTaskV[TaskN-TmTaskKdV.Len()];
112    }
113  }
114  bool TSchObj::IsRegTaskAtTm(const TSecTm& Tm, PSchTask& Task) const {
115    TTmTaskKd TmTaskKd(Tm);
116    int InsTaskN; int TaskN=TmTaskKdV.SearchBin(TmTaskKd, InsTaskN);
117    if (TaskN==-1){
118      if (InsTaskN==0){
119        Task=NULL; return false;
120      } else
121      if (TmTaskKdV[InsTaskN-1].Dat->IsTmIn(Tm)){
122        Task=TmTaskKdV[InsTaskN-1].Dat; return true;
123      } else {
<span onclick='openModal()' class='match'>124        Task=NULL; return false;
125      }
126    } else {
127      Task=TmTaskKdV[TaskN].Dat; return true;
128    }
129  }
130  bool TSchObj::IsRegTaskInTm(
</span>131   const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
132    TTmTaskKd StartTmTaskKd(MnTm);
133    TTmTaskKd EndTmTaskKd(MxTm);
134    int StartInsTaskN; int EndInsTaskN;
135    int StartTaskN=TmTaskKdV.SearchBin(StartTmTaskKd, StartInsTaskN);
136    int EndTaskN=TmTaskKdV.SearchBin(EndTmTaskKd, EndInsTaskN);
137    if ((StartTaskN==-1)&&(EndTaskN==-1)){
138      if (StartInsTaskN==EndInsTaskN){
139        if (StartInsTaskN==0){
140          Task=NULL; return false;
141        } else
142        if (TmTaskKdV[StartInsTaskN-1].Dat->IsTmIn(MnTm)){
143          Task=TmTaskKdV[StartInsTaskN-1].Dat; return true;
144        } else {
145          Task=NULL; return false;
146        }
147      } else {
148        Task=TmTaskKdV[StartInsTaskN].Dat; return true;
149      }
150    } else {
151      if (StartTaskN!=-1){IsRegTaskAtTm(MnTm, Task);}
152      else if (EndTaskN!=-1){IsRegTaskAtTm(MxTm, Task);}
153      else {Fail;}
154      IAssert(!Task.Empty());
155      return true;
156    }
157  }
158  bool TSchObj::IsFrcTaskInTm(
159   const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
160    for (int FrcTaskN=0; FrcTaskN<FrcTaskV.Len(); FrcTaskN++){
161      if (FrcTaskV[FrcTaskN]->IsTmInts(MnTm, MxTm)){
162        Task=FrcTaskV[FrcTaskN]; return true;
163      }
164    }
165    return false;
166  }
167  bool TSchObj::IsTaskInTm(
168   const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
169    return IsRegTaskInTm(MnTm, MxTm, Task) || IsFrcTaskInTm(MnTm, MxTm, Task);
170  }
171  PSchObj TSchObj::LoadTxt(TILx& Lx){
172    PSchObj SchObj=PSchObj(new TSchObj());
173    Lx.GetVar("SchObj", true, true);
174    SchObj->Nm=Lx.GetVarStr("Nm");
175    Lx.GetVar("TmTaskKdV", true, true);
176    while (!Lx.PeekVarEnd(true, true)){
177      PSchTask Task=TSchTask::LoadTxt(Lx);
178      SchObj->TmTaskKdV.Add(TTmTaskKd(Task->GetStartTm(), Task));
179    }
180    Lx.GetVarEnd(true, true);
181    Lx.GetVar("FrcTaskV", true, true);
182    while (!Lx.PeekVarEnd(true, true)){
183      PSchTask Task=TSchTask::LoadTxt(Lx);
184      SchObj->FrcTaskV.Add(Task);
185    }
186    Lx.GetVarEnd(true, true);
187    Lx.GetVarEnd(true, true);
188    return SchObj;
189  }
190  void TSchObj::SaveTxt(TOLx& Lx) const {
191    Lx.PutVar("SchObj", true, true);
192    Lx.PutVarStr("Nm", Nm);
193    Lx.PutVar("TmTaskKdV", true, true);
194    for (int TaskN=0; TaskN<TmTaskKdV.Len(); TaskN++){
195      TmTaskKdV[TaskN].Dat->SaveTxt(Lx);}
196    Lx.PutVarEnd(true, true);
197    Lx.PutVar("FrcTaskV", true, true);
198    for (int FrcTaskN=0; FrcTaskN<FrcTaskV.Len(); FrcTaskN++){
199      FrcTaskV[FrcTaskN]->SaveTxt(Lx);}
200    Lx.PutVarEnd(true, true);
201    Lx.PutVarEnd(true, true);
202  }
203  void TSchDim::AddObj(const TStr& ObjNm){
204    IAssert((!IsObj(ObjNm))&&(!IsCObj(ObjNm)));
205    PSchObj Obj=PSchObj(new TSchObj(ObjNm));
206    NmToObjH.AddDat(ObjNm, Obj);
207    NmToObjH.GetKeyId(ObjNm);
208  }
209  TStrV TSchDim::GetObjNmV() const {
210    TStrV ObjNmV(NmToObjH.Len(), 0);
211    int NmToObjP=NmToObjH.FFirstKeyId();
212    while (NmToObjH.FNextKeyId(NmToObjP)){
213      ObjNmV.Add(NmToObjH[NmToObjP]->GetNm());}
214    ObjNmV.Sort();
215    return ObjNmV;
216  }
217  int TSchDim::AddCObj(const TStr& CObjNm, const TStrV& ObjNmV){
218    IAssert((!IsObj(CObjNm))&&(!IsCObj(CObjNm)));
219    for (int ObjNmN=0; ObjNmN<ObjNmV.Len(); ObjNmN++){
220      IAssert(IsObj(ObjNmV[ObjNmN]));}
221    CObjNmToObjNmVH.AddDat(CObjNm, ObjNmV);
222    return NmToObjH.GetKeyId(CObjNm);
223  }
224  void TSchDim::GetCObjFromDesc(
225   const TStr& DescStr, TStr& CObjNm, TStrV& ObjNmV) const {
226    if (DescStr.IsChIn(':')){
227      TStr ObjNmVStr; DescStr.SplitOnCh(CObjNm, ':', ObjNmVStr);
228      CObjNm=CObjNm.GetTrunc(); ObjNmV.Clr();
229      TChA ObjNm;
230      for (int ChN=0; ChN<=ObjNmVStr.Len(); ChN++){
231        if ((ChN==ObjNmVStr.Len())||(ObjNmVStr[ChN]==',')){
232          ObjNm.Trunc();
233          if (!ObjNm.Empty()){ObjNmV.Add(ObjNm);}
234          ObjNm.Clr();
235        } else {
236          ObjNm+=ObjNmVStr[ChN];
237        }
238      }
239      ObjNmV.Sort();
240    } else {
241      CObjNm=DescStr.GetTrunc(); ObjNmV.Clr();
242    }
243  }
244  TStrV TSchDim::GetAllObjDescV() const {
245    TStrV DescStrV;
246    DescStrV.AddV(GetObjNmV());
247    TStrV CObjNmV=GetCObjNmV();
248    for (int CObjNmN=0; CObjNmN<CObjNmV.Len(); CObjNmN++){
249      TStrV ObjNmV=GetCObj_ObjNmV(CObjNmV[CObjNmN]);
250      TChA DescChA; DescChA+=CObjNmV[CObjNmN]; DescChA+=':';
251      for (int ObjNmN=0; ObjNmN<ObjNmV.Len(); ObjNmN++){
252        if (ObjNmN>0){DescChA+=", ";} DescChA+=ObjNmV[ObjNmN];}
253      DescStrV.Add(DescChA);
254    }
255    DescStrV.Sort();
256    return DescStrV;
257  }
258  void TSchDim::AddTask(const PSchTask& Task){
259    for (int DimObjN=0; DimObjN<Task->GetDimObjs(DimN); DimObjN++){
260      PSchObj Obj=GetObj(Task->GetDimObj(DimN, DimObjN));
261      Obj->AddTask(Task, OverlapCheckP);
262    }
263  }
264  void TSchDim::DelTask(const PSchTask& Task){
265    for (int DimObjN=0; DimObjN<Task->GetDimObjs(DimN); DimObjN++){
266      PSchObj Obj=GetObj(Task->GetDimObj(DimN, DimObjN));
267      Obj->DelTask(Task);
268    }
269  }
270  bool TSchDim::IsTaskOk(const PSchTask& Task, PSchTask& IcTask) const {
271    for (int DimObjN=0; DimObjN<Task->GetDimObjs(DimN); DimObjN++){
272      PSchObj Obj=GetObj(Task->GetDimObj(DimN, DimObjN));
273      if (!Obj->IsTaskOk(Task, IcTask, OverlapCheckP)){return false;}
274    }
275    return true;
276  }
277  bool TSchDim::IsTaskInTm(const TStr& ObjNm,
278   const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
279    PSchObj Obj=GetObj(ObjNm);
280    return Obj->IsTaskInTm(MnTm, MxTm, Task);
281  }
282  PSchDim TSchDim::LoadTxt(TILx& Lx){
283    PSchDim SchDim=PSchDim(new TSchDim());
284    Lx.GetVar("SchDim", true, true);
285    SchDim->DimN=Lx.GetVarInt("DimN");
286    SchDim->Nm=Lx.GetVarStr("Nm");
287    SchDim->OverlapCheckP=Lx.GetVarBool("OverlapCheckP");
288    Lx.GetVar("NmToObjH", true, true);
289    int NmToObjH_Ports=Lx.GetVarInt("Ports");
290    SchDim->NmToObjH=TNmToObjH(NmToObjH_Ports);
291    while (!Lx.PeekVarEnd(true, true)){
292      PSchObj Obj=TSchObj::LoadTxt(Lx);
293      SchDim->NmToObjH.AddDat(Obj->GetNm(), Obj);
294    }
295    Lx.GetVarEnd(true, true);
296    Lx.GetVar("CObjNmToObjNmVH", true, true);
297    int CObjNmToObjNmVH_Ports=Lx.GetVarInt("Ports");
298    SchDim->CObjNmToObjNmVH=TStrStrVH(CObjNmToObjNmVH_Ports);
299    while (!Lx.PeekVarEnd(true, true)){
300      Lx.GetVar("CObj", true, true);
301      TStr CObjNm=Lx.GetVarStr("CObjNm");
302      TStrV ObjNmV; Lx.GetVarStrV("ObjNmV", ObjNmV);
303      SchDim->CObjNmToObjNmVH.AddDat(CObjNm, ObjNmV);
304      Lx.GetVarEnd(true, true);
305    }
306    Lx.GetVarEnd(true, true);
307    Lx.GetVarEnd(true, true);
308    return SchDim;
309  }
310  void TSchDim::SaveTxt(TOLx& Lx) const {
311    Lx.PutVar("SchDim", true, true);
312    Lx.PutVarInt("DimN", DimN);
313    Lx.PutVarStr("Nm", Nm);
314    Lx.PutVarBool("OverlapCheckP", OverlapCheckP);
315    Lx.PutVar("NmToObjH", true, true);
316    int NmToObjP=NmToObjH.FFirstKeyId();
317    Lx.PutVarInt("Ports", NmToObjH.GetPorts());
318    while (NmToObjH.FNextKeyId(NmToObjP)){
319      NmToObjH[NmToObjP]->SaveTxt(Lx);}
320    Lx.PutVarEnd(true, true);
321    Lx.PutVar("CObjNmToObjNmVH", true, true);
322    int CObjNmToObjNmVP=CObjNmToObjNmVH.FFirstKeyId();
323    Lx.PutVarInt("Ports", CObjNmToObjNmVH.GetPorts());
324    while (CObjNmToObjNmVH.FNextKeyId(CObjNmToObjNmVP)){
325      Lx.PutVar("CObj", true, true);
326      Lx.PutVarStr("CObjNm", CObjNmToObjNmVH.GetKey(CObjNmToObjNmVP));
327      Lx.PutVarStrV("ObjNmV", CObjNmToObjNmVH[CObjNmToObjNmVP]);
328      Lx.PutVarEnd(true, true);
329    }
330    Lx.PutVarEnd(true, true);
331    Lx.PutVarEnd(true, true);
332  }
333  PSchRep TSchRep::New(
334   const PSch& Sch, const TStr& DimNm, const TStr& ObjNm, const int& ResMins,
335   const bool& AllTmP, const TSecTm& StartDtTm, const TSecTm& EndDtTm){
336    PSchRep SchRep=PSchRep(new TSchRep());
337    TSecTm EndDayTm=TSecTm::GetZeroTm().AddDays(1);
338    {TSecTm CurDayTm=TSecTm::GetZeroTm();
339    while (CurDayTm<EndDayTm){
340      SchRep->DayTmV.Add(CurDayTm); CurDayTm.AddMins(ResMins);}}
341    TSecTm NrStartDtTm; TSecTm NrEndDtTm;
342    if (AllTmP){
343      NrStartDtTm=Sch->GetCal()->GetStartTm();
344      NrEndDtTm=Sch->GetCal()->GetEndTm();
345    } else {
346      NrStartDtTm=StartDtTm; NrEndDtTm=EndDtTm;
347    }
348    if (NrStartDtTm>NrEndDtTm){NrEndDtTm=NrStartDtTm;}
349    if (NrStartDtTm<Sch->GetCal()->GetStartTm()){
350      NrStartDtTm=Sch->GetCal()->GetStartTm();}
351    if (NrEndDtTm>Sch->GetCal()->GetEndTm()){
352      NrEndDtTm=Sch->GetCal()->GetEndTm();}
353    TSecTm CurDtTm=NrStartDtTm;
354    PSchTask PrevTask; int TaskN=0-1; int TaskSegN=-1;
355    while (CurDtTm<NrEndDtTm){
356      SchRep->DtTmV.Add(CurDtTm);
357      SchRep->TaskNmVV.Add();
358      TSecTm StartTaskTm=CurDtTm;
359      TSecTm EndTaskTm=TSecTm(StartTaskTm).AddMins(ResMins);
360      for (int DayTmN=0; DayTmN<SchRep->DayTmV.Len(); DayTmN++){
361        PSchTask Task;
362        if (Sch->IsTaskInTm(DimNm, ObjNm, StartTaskTm, EndTaskTm-1, Task)){
363          if (PrevTask==Task){TaskSegN++;} else {TaskN++; TaskSegN=1;}
364          TStr TaskStr=Task->GetStr()+" ("+TInt::GetStr(TaskSegN)+")";
365          SchRep->TaskNmVV.Last().Add(TaskStr);
366        } else {
367          SchRep->TaskNmVV.Last().Add();
368        }
369        PrevTask=Task;
370        StartTaskTm.AddMins(ResMins); EndTaskTm.AddMins(ResMins);
371      }
372      CurDtTm.AddDays(1);
373    }
374    return SchRep;
375  }
376  void TSchRep::SaveHtml(const PSOut& SOut) const {
377    int CurDtTmN=0;
378    while (CurDtTmN<GetDtTms()){
379      int MnDtTmN=CurDtTmN;
380      while ((CurDtTmN<GetDtTms())&&
381       (GetDtTm(CurDtTmN).GetDayOfWeekN()!=TTmInfo::SunN)){CurDtTmN++;}
382      int MxDtTmN=CurDtTmN;
383      CurDtTmN++;
384      SOut->PutStr("<table border=1 cellpadding=3>\n");
385      SOut->PutStr("<tr>");
386      SOut->PutStr("<td>");
387      SOut->PutStr("Time");
388      SOut->PutStr("</td>");
389      for (int DtTmN=MnDtTmN; DtTmN<MxDtTmN; DtTmN++){
390        SOut->PutStr("<td>");
391        SOut->PutStr(GetDtTmStr(DtTmN));
392        SOut->PutStr("</td>");
393      }
394      SOut->PutStr("</tr>"); SOut->PutLn();
395      for (int DayTmN=0; DayTmN<GetDayTms(); DayTmN++){
396        SOut->PutStr("</tr>");
397        SOut->PutStr("<td>");
398        SOut->PutStr(GetDayTmStr(DayTmN));
399        SOut->PutStr("</td>");
400        for (int DtTmN=MnDtTmN; DtTmN<MxDtTmN; DtTmN++){
401          SOut->PutStr("<td>");
402          if (GetTaskStr(DtTmN, DayTmN).Empty()){
403            SOut->PutStr("&nbsp;");
404          } else {
405            SOut->PutStr(GetTaskStr(DtTmN, DayTmN));
406          }
407          SOut->PutStr("</td>");
408        }
409        SOut->PutStr("</tr>"); SOut->PutLn();
410      }
411      SOut->PutStr("</table>\n");
412    }
413  }
414  void TSchRep::SaveHtml(const TStr& FNm) const {
415    PSOut SOut=TFOut::New(FNm);
416    SOut->PutStr("<html>\n");
417    SOut->PutStr("<head><title>Urnik</title></head>\n");
418    SOut->PutStr("<body>\n");
419    SaveHtml(SOut);
420    SOut->PutStr("</body>\n");
421    SOut->PutStr("</html>\n");
422  }
423  void TSchRep::SaveTxt(const PSOut& SOut) const {
424    SOut->PutStr("Time");
425    for (int DtTmN=0; DtTmN<GetDtTms(); DtTmN++){
426      SOut->PutCh(TabCh); SOut->PutStr(GetDtTmStr(DtTmN));}
427    SOut->PutLn();
428    for (int DayTmN=0; DayTmN<GetDayTms(); DayTmN++){
429      SOut->PutStr(GetDayTmStr(DayTmN));
430      for (int DtTmN=0; DtTmN<GetDtTms(); DtTmN++){
431        SOut->PutCh(TabCh); SOut->PutStr(GetTaskStr(DtTmN, DayTmN));}
432      SOut->PutLn();
433    }
434  }
435  void TSchRep::SaveTxt(const TStr& FNm) const {
436    PSOut SOut=TFOut::New(FNm);
437    SaveTxt(SOut);
438  }
439  void TSchRep::SaveStat(const TStr& FNm, const PSch& Sch){
440    PSOut SOut=TFOut::New(FNm);
441    TStr StartTmStr=Sch->GetCal()->GetStartTm().GetDtStr(lSi);
442    TStr EndTmStr=Sch->GetCal()->GetEndTm().GetDtStr(lSi);
443    SOut->PutStr("Zacetek: "); SOut->PutStr(StartTmStr); SOut->PutLn();
444    SOut->PutStr("Konec: "); SOut->PutStr(EndTmStr); SOut->PutLn();
445    for (int DimN=0; DimN<Sch->GetDims(); DimN++){
446      SOut->PutStr("----------------------"); SOut->PutLn();
447      SOut->PutStr(TStr("Dimenzija: ")+Sch->GetDimNm(DimN)); SOut->PutLn();
448      TStrV ObjNmV=Sch->GetObjNmV(DimN);
449      for (int ObjNmN=0; ObjNmN<ObjNmV.Len(); ObjNmN++){
450        TStr ObjNm=ObjNmV[ObjNmN];
451        SOut->PutStr(ObjNm+": ");
452        TSchTaskV TaskV; Sch->GetObjTaskV(DimN, ObjNm, TaskV);
453        int ObjSecs=0;
454        for (int TaskN=0; TaskN<TaskV.Len(); TaskN++){
455          ObjSecs+=TaskV[TaskN]->GetTmSecs();}
456        SOut->PutStr(TInt::GetStr(ObjSecs/3600)+"h ");
457        SOut->PutStr(TInt::GetStr((ObjSecs%3600)/60)+"m ");
458        SOut->PutStr(TInt::GetStr((ObjSecs%3600*60)/60)+"s");
459        SOut->PutLn();
460      }
461    }
462  }
463  void TSchCal::PutScope(const TSchScope& _Scope,
464   const TSecTm& _StartTm, const TSecTm& _EndTm){
465    Scope=_Scope; StartTm=_StartTm; EndTm=_EndTm;
466    switch (Scope){
467      case ssUnlim: IAssert((!StartTm.IsDef())&&(!EndTm.IsDef())); break;
468      case ssLim: IAssert((StartTm.IsDef())&&(EndTm.IsDef())&&(StartTm<=EndTm)); break;
469      case ssWeek:
470        IAssert((!StartTm.IsDef())&&(!EndTm.IsDef()));
471        StartTm=EndTm=TSecTm::GetZeroWeekTm(); EndTm.AddDays(7); break;
472      default: Fail;
473    }
474  }
475  void TSchCal::AddBadDay(const TSecTm& DtTm, const TStr& DescStr){
476    TSecTm NrDtTm=TSecTm::GetDtTm(DtTm);
477    int BadDayN;
478    if (BadDay_DtTmDescStrKdV.IsIn(NrDtTm, BadDayN)){
479      BadDay_DtTmDescStrKdV.Del(BadDayN);}
480    BadDay_DtTmDescStrKdV.AddSorted(TSecTmStrKd(DtTm, DescStr));
481  }
482  void TSchCal::DelBadDay(const TSecTm& DtTm){
483    TSecTm NrDtTm=TSecTm::GetDtTm(DtTm);
484    int BadDayN;
485    if (BadDay_DtTmDescStrKdV.IsIn(NrDtTm, BadDayN)){
486      BadDay_DtTmDescStrKdV.Del(BadDayN);}
487  }
488  bool TSchCal::IsBadDay(const TSecTm& DtTm) const {
489    TSecTm NrDtTm=TSecTm::GetDtTm(DtTm);
490    return BadDay_DtTmDescStrKdV.IsIn(NrDtTm);
491  }
492  PSchCal TSchCal::LoadTxt(TILx& Lx){
493    PSchCal SchCal=TSchCal::New();
494    Lx.GetVar("SchCal", true, true);
495    SchCal->Scope=TSchScope(Lx.GetVarInt("Scope"));
496    SchCal->StartTm=Lx.GetVarSecTm("StartTm");
497    SchCal->EndTm=Lx.GetVarSecTm("EndTm");
498    Lx.GetVar("BadDay_DtTmDescStrKdV", true, true);
499    while (!Lx.PeekVarEnd(true, true)){
500      TSecTm DtTm=Lx.GetVarSecTm("DtTm");
501      TStr DescStr=Lx.GetVarStr("DescStr");
502      SchCal->BadDay_DtTmDescStrKdV.Add(TSecTmStrKd(DtTm, DescStr));
503    }
504    Lx.GetVarEnd(true, true);
505    Lx.GetVarEnd(true, true);
506    return SchCal;
507  }
508  void TSchCal::SaveTxt(TOLx& Lx) const {
509    Lx.PutVar("SchCal", true, true);
510    Lx.PutVarInt("Scope", int(Scope));
511    Lx.PutVarSecTm("StartTm", StartTm);
512    Lx.PutVarSecTm("EndTm", EndTm);
513    Lx.PutVar("BadDay_DtTmDescStrKdV", true, true);
514    for (int BadDayN=0; BadDayN<BadDay_DtTmDescStrKdV.Len(); BadDayN++){
515      Lx.PutVarSecTm("DtTm", BadDay_DtTmDescStrKdV[BadDayN].Key);
516      Lx.PutVarStr("DescStr", BadDay_DtTmDescStrKdV[BadDayN].Dat);
517    }
518    Lx.PutVarEnd(true, true);
519    Lx.PutVarEnd(true, true);
520  }
521  TSch::TSch(const TStr& _Nm, const int& Dims,
522   const int& ExpObjs, const int& ExpTasks):
523    Nm(_Nm), Cal(TSchCal::New()),
524    DimV(Dims), LastTaskId(0), CpbTask(),
525    IdToTaskH(ExpTasks), NmToPatH(10){
526    for (int DimN=0; DimN<Dims; DimN++){
527      DimV[DimN]=PSchDim(new TSchDim(DimN, ExpObjs));}
528  }
529  TStrV TSch::GetDimNmV() const {
530    TStrV DimNmV(GetDims(), 0);
531    for (int DimN=0; DimN<GetDims(); DimN++){
532      DimNmV.Add(GetDimNm(DimN));}
533    return DimNmV;
534  }
535  int TSch::GetDimN(const TStr& DimNm) const {
536    for (int DimN=0; DimN<GetDims(); DimN++){
537      if (GetDimNm(DimN)==DimNm){return DimN;}}
538    return -1;
539  }
540  void TSch::DelObj(const int& DimN, const TStr& ObjNm){
541    TSchTaskV TaskV; GetObjTaskV(DimN, ObjNm, TaskV);
542    for (int TaskN=0; TaskN<TaskV.Len(); TaskN++){
543      DelTask(TaskV[TaskN]->GetTaskId());}
544    DimV[DimN]->DelObj(ObjNm);
545    SyncPatVObj();
546  }
547  bool TSch::IsOkForAddTask(TStr& MsgStr) const {
548    if (GetDims()==0){MsgStr="Dimenzije niso definirane."; return false;}
549    for (int DimN=0; DimN<GetDims(); DimN++){
550      if (GetObjs(DimN)==0){
551        MsgStr="Dimenzija nima objektov."; return false;}
552    }
553    MsgStr="Ok."; return true;
554  }
555  int TSch::AddTask(const PSchTask& Task){
556    IAssert(Task->GetDims()==GetDims());
557    IdToTaskH.AddDat(Task->GetTaskId(), Task);
558    for (int DimN=0; DimN<GetDims(); DimN++){
559      DimV[DimN]->AddTask(Task);}
560    return Task->GetTaskId();
561  }
562  int TSch::AddTask(
563   const TVec<TStrV>& DimObjVV,
564   const TSecTm& StartTm, const TSecTm& EndTm, const bool& Forced){
565    int TaskId=GetNewTaskId();
566    PSchTask Task=PSchTask(new TSchTask(TaskId, DimObjVV, StartTm, EndTm, Forced));
567    return AddTask(Task);
568  }
569  int TSch::AddTask(
570   const TStr& DimObj1, const TStr& DimObj2, const TStr& DimObj3,
571   const TSecTm& StartTm, const TSecTm& EndTm, const bool& Forced){
572    TVec<TStrV> DimObjVV(3, 0);
573    DimObjVV.Add(); DimObjVV.Last().Add(DimObj1);
574    DimObjVV.Add(); DimObjVV.Last().Add(DimObj2);
575    DimObjVV.Add(); DimObjVV.Last().Add(DimObj3);
576    return AddTask(DimObjVV, StartTm, EndTm, Forced);
577  }
578  int TSch::AddTask(
579   const TStrV& DimObjV,
580   const TSecTm& StartTm, const TSecTm& EndTm, const bool& Forced){
581    TVec<TStrV> DimObjVV(3, 0);
582    DimObjVV.Add(); DimObjVV.Last().Add(DimObjV[0]);
583    DimObjVV.Add(); DimObjVV.Last().Add(DimObjV[1]);
584    DimObjVV.Add(); DimObjVV.Last().Add(DimObjV[2]);
585    return AddTask(DimObjVV, StartTm, EndTm, Forced);
586  }
587  int TSch::AddTask(
588   const TStrV& DimObjV1, const TStrV& DimObjV2, const TStrV& DimObjV3,
589   const TSecTm& StartTm, const TSecTm& EndTm, const bool& Forced){
590    TVec<TStrV> DimObjVV(3, 0);
591    DimObjVV.Add(DimObjV1);
592    DimObjVV.Add(DimObjV2);
593    DimObjVV.Add(DimObjV3);
594    return AddTask(DimObjVV, StartTm, EndTm, Forced);
595  }
596  void TSch::DelTask(const int& TaskId){
597    PSchTask Task=IdToTaskH.GetDat(TaskId);
598    for (int DimN=0; DimN<GetDims(); DimN++){
599      DimV[DimN]->DelTask(Task);}
600    IdToTaskH.DelKey(TaskId);
601  }
602  void TSch::GetDayTaskV(const TSecTm& DtTm, TIntV& TaskIdV) const {
603    TaskIdV.Clr();
604    int IdToTaskP=IdToTaskH.FFirstKeyId();
605    while (IdToTaskH.FNextKeyId(IdToTaskP)){
606      PSchTask Task=IdToTaskH[IdToTaskP];
607      TSecTm TaskDtTm=TSecTm::GetDtTm(Task->GetStartTm());
608      if (TaskDtTm==DtTm){
609        TaskIdV.Add(Task->GetTaskId());}
610    }
611  }
612  bool TSch::IsTask(const int& TaskId, PSchTask& Task) const {
613    int IdToTaskP;
614    if (IdToTaskH.IsKey(TaskId, IdToTaskP)){
615      Task=IdToTaskH[IdToTaskP]; return true;}
616    else {return false;}
617  }
618  bool TSch::IsTaskOk(const PSchTask& Task, TSchTaskV& DimIcTaskV) const {
619    DimIcTaskV.Gen(GetDims(), GetDims());
620    bool Ok=true;
621    for (int DimN=0; DimN<GetDims(); DimN++){
622      PSchTask IcTask;
623      if (!DimV[DimN]->IsTaskOk(Task, IcTask)){
624        DimIcTaskV[DimN]=IcTask; Ok=false;
625      }
626    }
627    return Ok;
628  }
629  bool TSch::IsTaskSim(const PSchTask& Task, PSchTask& SimTask) const {
630    TVec<TStrV> DimObjVV; Task->GetDimObjVV(DimObjVV);
631    int IdToTaskP=IdToTaskH.FFirstKeyId();
632    while (IdToTaskH.FNextKeyId(IdToTaskP)){
633      SimTask=IdToTaskH[IdToTaskP];
634      if (
635       (Task->GetStartTm()==SimTask->GetStartTm())&&
636       (Task->GetEndTm()==SimTask->GetEndTm())&&
637       (Task->IsForced()==SimTask->IsForced())){
638        TVec<TStrV> SimDimObjVV; SimTask->GetDimObjVV(SimDimObjVV);
639        if (DimObjVV==SimDimObjVV){return true;}
640      }
641    }
642    return false;
643  }
644  PSch TSch::AddPat(const TStr& PatNm){
645    IAssert(!IsPat(PatNm));
646    PSch Pat=New(PatNm, GetDims());
647    Pat->PutNm(PatNm);
648    Pat->GetCal()->PutScope(ssWeek);
649    for (int DimN=0; DimN<GetDims(); DimN++){
650      Pat->PutDimNm(DimN, GetDimNm(DimN));
651      Pat->AddObjV(DimN, GetObjNmV(DimN));
652      TStrV CObjNmV=GetCObjNmV(DimN);
653      for (int CObjNmN=0; CObjNmN<CObjNmV.Len(); CObjNmN++){
654        TStr CObjNm=CObjNmV[CObjNmN];
655        TStrV ObjNmV=GetCObj_ObjNmV(DimN, CObjNm);
656        Pat->AddCObj(DimN, CObjNm, ObjNmV);
657      }
658    }
659    NmToPatH.AddDat(PatNm, Pat);
660    return Pat;
661  }
662  void TSch::SyncPatObj(const TStr& PatNm) const {
663    PSch Pat=GetPat(PatNm);
664    for (int DimN=0; DimN<GetDims(); DimN++){
665      {TStrV ObjNmV=GetObjNmV(DimN);
666      for (int ObjNmN=0; ObjNmN<ObjNmV.Len(); ObjNmN++){
667        if (!Pat->IsObj(DimN, ObjNmV[ObjNmN])){
668          Pat->AddObj(DimN, ObjNmV[ObjNmN]);}
669      }}
670      {TStrV CObjNmV=GetCObjNmV(DimN);
671      for (int CObjNmN=0; CObjNmN<CObjNmV.Len(); CObjNmN++){
672        TStrV ObjNmV=GetCObj_ObjNmV(DimN, CObjNmV[CObjNmN]);
673        if (!Pat->IsCObj(DimN, CObjNmV[CObjNmN])){
674          Pat->AddCObj(DimN, CObjNmV[CObjNmN], ObjNmV);
675        } else {
676          TStrV PatObjNmV=Pat->GetCObj_ObjNmV(DimN, CObjNmV[CObjNmN]);
677          if (ObjNmV!=PatObjNmV){
678            Pat->DelCObj(DimN, CObjNmV[CObjNmN]);
679            Pat->AddCObj(DimN, CObjNmV[CObjNmN], ObjNmV);
680          }
681        }
682      }}
683      {TStrV PatObjNmV=Pat->GetObjNmV(DimN);
684      for (int PatObjNmN=0; PatObjNmN<PatObjNmV.Len(); PatObjNmN++){
685        if (!IsObj(DimN, PatObjNmV[PatObjNmN])){
686          Pat->DelObj(DimN, PatObjNmV[PatObjNmN]);}
687      }}
688      {TStrV PatCObjNmV=Pat->GetCObjNmV(DimN);
689      for (int PatCObjNmN=0; PatCObjNmN<PatCObjNmV.Len(); PatCObjNmN++){
690        TStrV PatObjNmV=Pat->GetCObj_ObjNmV(DimN, PatCObjNmV[PatCObjNmN]);
691        if (!IsCObj(DimN, PatCObjNmV[PatCObjNmN])){
692          Pat->DelCObj(DimN, PatCObjNmV[PatCObjNmN]);
693        }
694      }}
695    }
696  }
697  void TSch::SyncPatVObj() const {
698    TStrV PatNmV=GetPatNmV();
699    for (int PatNmN=0; PatNmN<PatNmV.Len(); PatNmN++){
700      SyncPatObj(PatNmV[PatNmN]);}
701  }
702  void TSch::ApplyPatAdd(
703   const PSch& Pat, const TSecTm& StartDtTm, const TSecTm& EndDtTm,
704   const bool& TestOnlyP, TStrV& LogStrV){
705    LogStrV.Clr();
706    LogStrV.Add(TStr("Adding pattern: ")+Pat->GetNm());
707    LogStrV.Add(TStr("Start date: ")+StartDtTm.GetDtStr());
708    LogStrV.Add(TStr("End date: ")+EndDtTm.GetDtStr());
709    LogStrV.Add(TStr("Test only: ")+TBool::GetYesNoStr(TestOnlyP));
710    LogStrV.Add("------------------------");
711    TSecTm CurSchDtTm=TSecTm::GetDtTm(StartDtTm);
712    if (CurSchDtTm<GetCal()->GetStartTm()){CurSchDtTm=GetCal()->GetStartTm();}
713    TSecTm CurPatDtTm=TSecTm::GetDtTm(Pat->GetCal()->GetStartTm());
714    while (CurPatDtTm.GetDayOfWeekN()!=CurSchDtTm.GetDayOfWeekN()){
715      CurPatDtTm.AddDays(1);}
716    while ((CurSchDtTm<GetCal()->GetStartTm())&&(CurSchDtTm<=EndDtTm)){
717      TIntV PatTaskIdV; Pat->GetDayTaskV(CurPatDtTm, PatTaskIdV);
718      for (int PatTaskIdN=0; PatTaskIdN<PatTaskIdV.Len(); PatTaskIdN++){
719        PSchTask PatTask=Pat->GetTask(PatTaskIdV[PatTaskIdN]);
720        TSecTm SchTaskStartTm=
721         CurSchDtTm+PatTask->GetStartTm()-TSecTm::GetDtTm(PatTask->GetStartTm());
722        TSecTm SchTaskEndTm=
723         CurSchDtTm+PatTask->GetEndTm()-TSecTm::GetDtTm(PatTask->GetEndTm());
724        int SchTaskId=GetNewTaskId();
725        TVec<TStrV> SchTaskDimObjVV; PatTask->GetDimObjVV(SchTaskDimObjVV);
726        bool SchTaskForced=PatTask->IsForced();
727        PSchTask SchTask=PSchTask(new TSchTask(SchTaskId,
728         SchTaskDimObjVV, SchTaskStartTm, SchTaskEndTm, SchTaskForced));
729        if (IsTaskOk(SchTask)){
730          if (!TestOnlyP){
731            AddTask(SchTask);} 
732          TChA LogChA;
733          LogChA+="Add ";
734          LogChA+='['; LogChA+=SchTaskStartTm.GetStr(); LogChA+=']';
735          LogChA+=" - ";
736          LogChA+='['; LogChA+=SchTaskEndTm.GetStr(); LogChA+=']'; LogChA+="  ";
737          LogChA+=SchTask->GetStr();
738          LogStrV.Add(LogChA);
739        }
740      }
741      CurSchDtTm.AddDays(1);
742      CurPatDtTm.AddDays(1);
743      if (CurPatDtTm>=Pat->GetCal()->GetEndTm()){
744        CurPatDtTm=Pat->GetCal()->GetStartTm();}
745    }
746  }
747  void TSch::ApplyPatDel(
748   const PSch& Pat, const TSecTm& StartDtTm, const TSecTm& EndDtTm,
749   const bool& TestOnlyP, TStrV& LogStrV){
750    LogStrV.Clr();
751    LogStrV.Add(TStr("Deleting pattern: ")+Pat->GetNm());
752    LogStrV.Add(TStr("Start date: ")+StartDtTm.GetDtStr());
753    LogStrV.Add(TStr("End date: ")+EndDtTm.GetDtStr());
754    LogStrV.Add(TStr("Test only: ")+TBool::GetYesNoStr(TestOnlyP));
755    LogStrV.Add("------------------------");
756    TSecTm CurSchDtTm=TSecTm::GetDtTm(StartDtTm);
757    if (CurSchDtTm<GetCal()->GetStartTm()){CurSchDtTm=GetCal()->GetStartTm();}
758    TSecTm CurPatDtTm=TSecTm::GetDtTm(Pat->GetCal()->GetStartTm());
759    while (CurPatDtTm.GetDayOfWeekN()!=CurSchDtTm.GetDayOfWeekN()){
760      CurPatDtTm.AddDays(1);}
761    while ((CurSchDtTm<GetCal()->GetEndTm())&&(CurSchDtTm<=EndDtTm)){
762      TIntV PatTaskIdV; Pat->GetDayTaskV(CurPatDtTm, PatTaskIdV);
763      for (int PatTaskIdN=0; PatTaskIdN<PatTaskIdV.Len(); PatTaskIdN++){
764        PSchTask PatTask=Pat->GetTask(PatTaskIdV[PatTaskIdN]);
765        TSecTm SchTaskStartTm=
766         CurSchDtTm+PatTask->GetStartTm()-TSecTm::GetDtTm(PatTask->GetStartTm());
767        TSecTm SchTaskEndTm=
768         CurSchDtTm+PatTask->GetEndTm()-TSecTm::GetDtTm(PatTask->GetEndTm());
769        int SchTaskId=GetNewTaskId();
770        TVec<TStrV> SchTaskDimObjVV; PatTask->GetDimObjVV(SchTaskDimObjVV);
771        bool SchTaskForced=PatTask->IsForced();
772        PSchTask SchTask=PSchTask(new TSchTask(SchTaskId,
773         SchTaskDimObjVV, SchTaskStartTm, SchTaskEndTm, SchTaskForced));
774        PSchTask SimSchTask;
775        if (IsTaskSim(SchTask, SimSchTask)){
776          if (!TestOnlyP){
777            DelTask(SimSchTask->GetTaskId()); 
778          }
779          TChA LogChA;
780          LogChA+="Del ";
781          LogChA+='['; LogChA+=SchTaskStartTm.GetStr(); LogChA+=']';
782          LogChA+=" - ";
783          LogChA+='['; LogChA+=SchTaskEndTm.GetStr(); LogChA+=']'; LogChA+="  ";
784          LogChA+=SchTask->GetStr();
785          LogStrV.Add(LogChA);
786        }
787      }
788      CurSchDtTm.AddDays(1);
789      CurPatDtTm.AddDays(1);
790      if (CurPatDtTm>=Pat->GetCal()->GetEndTm()){
791        CurPatDtTm=Pat->GetCal()->GetStartTm();}
792    }
793  }
794  PSch TSch::LoadTxt(TILx& Lx){
795    PSch Sch=PSch(new TSch());
796    Lx.GetVar("Sch", true, true);
797    Sch->Nm=Lx.GetVarStr("Nm");
798    Sch->Cal=TSchCal::LoadTxt(Lx);
799    Lx.GetVar("DimV", true, true);
800    while (!Lx.PeekVarEnd(true, true)){
801      Sch->DimV.Add(TSchDim::LoadTxt(Lx));}
802    Lx.GetVarEnd(true, true);
803    Sch->LastTaskId=Lx.GetVarInt("LastTaskId");
804    {Lx.GetVar("IdToTaskH", true, true);
805    int Ports=Lx.GetVarInt("Ports");
806    Sch->IdToTaskH=TIdToTaskH(Ports);
807    while (!Lx.PeekVarEnd(true, true)){
808      PSchTask Task=TSchTask::LoadTxt(Lx);
809      Sch->IdToTaskH.AddDat(Task->GetTaskId(), Task);
810    }
811    Lx.GetVarEnd(true, true);}
812    {Lx.GetVar("NmToPatH", true, true);
813    int Ports=Lx.GetVarInt("Ports");
814    Sch->NmToPatH=TNmToPatH(Ports);
815    while (!Lx.PeekVarEnd(true, true)){
816      PSch Pat=TSch::LoadTxt(Lx);
817      Sch->NmToPatH.AddDat(Pat->GetNm(), Pat);
818    }
819    Lx.GetVarEnd(true, true);}
820    Lx.GetVarEnd(true, true);
821    return Sch;
822  }
823  PSch TSch::LoadTxt(const TStr& FNm){
824    PSIn SIn=PSIn(new TFIn(FNm));
825    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloCsSens);
826    return LoadTxt(Lx);
827  }
828  void TSch::SaveTxt(TOLx& Lx) const {
829    Lx.PutVar("Sch", true, true);
830    Lx.PutVarStr("Nm", Nm);
831    Cal->SaveTxt(Lx);
832    Lx.PutVar("DimV", true, true);
833    for (int DimN=0; DimN<DimV.Len(); DimN++){
834      DimV[DimN]->SaveTxt(Lx);}
835    Lx.PutVarEnd(true, true);
836    Lx.PutVarInt("LastTaskId", LastTaskId);
837    Lx.PutVar("IdToTaskH", true, true);
838    Lx.PutVarInt("Ports", IdToTaskH.GetPorts());
839    int IdToTaskP=IdToTaskH.FFirstKeyId();
840    while (IdToTaskH.FNextKeyId(IdToTaskP)){
841      IdToTaskH[IdToTaskP]->SaveTxt(Lx);}
842    Lx.PutVarEnd(true, true);
843    Lx.PutVar("NmToPatH", true, true);
844    Lx.PutVarInt("Ports", NmToPatH.GetPorts());
845    int NmToPatP=NmToPatH.FFirstKeyId();
846    while (NmToPatH.FNextKeyId(NmToPatP)){
847      NmToPatH[NmToPatP]->SaveTxt(Lx);}
848    Lx.PutVarEnd(true, true);
849    Lx.PutVarEnd(true, true);
850  }
851  void TSch::SaveTxt(const TStr& FNm) const {
852    PSOut SOut=PSOut(new TFOut(FNm));
853    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens|oloVarIndent);
854    SaveTxt(Lx);
855  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssch.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>89          Task=NULL; return false;
90        }
91      } else {
92        Task=TaskV[StartInsTaskN].Dat; return true;
93      }
94    } else {
</pre></code></div>
                <div class="column column_space"><pre><code>124        Task=NULL; return false;
125      }
126    } else {
127      Task=TmTaskKdV[TaskN].Dat; return true;
128    }
129  }
130  bool TSchObj::IsRegTaskInTm(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    