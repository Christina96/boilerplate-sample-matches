
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cluster.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #include "cluster.h"
3  #include "genericheap.h"
4  #include "kdpair.h"
5  #include "matrix.h"
6  #include "tprintf.h"
7  #include "helpers.h"
8  #include <cfloat> 
9  #include <cmath>  
10  #include <vector> 
11  namespace tesseract {
12  #define HOTELLING 1  
13  #define FTABLE_X 10  
14  #define FTABLE_Y 100 
15  const double FTable[FTABLE_Y][FTABLE_X] = {
16      {
17          4052.19,
18          4999.52,
19          5403.34,
20          5624.62,
21          5763.65,
22          5858.97,
23          5928.33,
24          5981.10,
25          6022.50,
26          6055.85,
27      },
28      {
29          98.502,
30          99.000,
31          99.166,
32          99.249,
33          99.300,
34          99.333,
35          99.356,
36          99.374,
37          99.388,
38          99.399,
39      },
40      {
41          34.116,
42          30.816,
43          29.457,
44          28.710,
45          28.237,
46          27.911,
47          27.672,
48          27.489,
49          27.345,
50          27.229,
51      },
52      {
53          21.198,
54          18.000,
55          16.694,
56          15.977,
57          15.522,
58          15.207,
59          14.976,
60          14.799,
61          14.659,
62          14.546,
63      },
64      {
65          16.258,
66          13.274,
67          12.060,
68          11.392,
69          10.967,
70          10.672,
71          10.456,
72          10.289,
73          10.158,
74          10.051,
75      },
76      {
77          13.745,
78          10.925,
79          9.780,
80          9.148,
81          8.746,
82          8.466,
83          8.260,
84          8.102,
85          7.976,
86          7.874,
87      },
88      {
89          12.246,
90          9.547,
91          8.451,
92          7.847,
93          7.460,
94          7.191,
95          6.993,
96          6.840,
97          6.719,
98          6.620,
99      },
100      {
101          11.259,
102          8.649,
103          7.591,
104          7.006,
105          6.632,
106          6.371,
107          6.178,
108          6.029,
109          5.911,
110          5.814,
111      },
112      {
113          10.561,
114          8.022,
115          6.992,
116          6.422,
117          6.057,
118          5.802,
119          5.613,
120          5.467,
121          5.351,
122          5.257,
123      },
124      {
125          10.044,
126          7.559,
127          6.552,
128          5.994,
129          5.636,
130          5.386,
131          5.200,
132          5.057,
133          4.942,
134          4.849,
135      },
136      {
137          9.646,
138          7.206,
139          6.217,
140          5.668,
141          5.316,
142          5.069,
143          4.886,
144          4.744,
145          4.632,
146          4.539,
147      },
148      {
149          9.330,
150          6.927,
151          5.953,
152          5.412,
153          5.064,
154          4.821,
155          4.640,
156          4.499,
157          4.388,
158          4.296,
159      },
160      {
161          9.074,
162          6.701,
163          5.739,
164          5.205,
165          4.862,
166          4.620,
167          4.441,
168          4.302,
169          4.191,
170          4.100,
171      },
172      {
173          8.862,
174          6.515,
175          5.564,
176          5.035,
177          4.695,
178          4.456,
179          4.278,
180          4.140,
181          4.030,
182          3.939,
183      },
184      {
185          8.683,
186          6.359,
187          5.417,
188          4.893,
189          4.556,
190          4.318,
191          4.142,
192          4.004,
193          3.895,
194          3.805,
195      },
196      {
197          8.531,
198          6.226,
199          5.292,
200          4.773,
201          4.437,
202          4.202,
203          4.026,
204          3.890,
205          3.780,
206          3.691,
207      },
208      {
209          8.400,
210          6.112,
211          5.185,
212          4.669,
213          4.336,
214          4.102,
215          3.927,
216          3.791,
217          3.682,
218          3.593,
219      },
220      {
221          8.285,
222          6.013,
223          5.092,
224          4.579,
225          4.248,
226          4.015,
227          3.841,
228          3.705,
229          3.597,
230          3.508,
231      },
232      {
233          8.185,
234          5.926,
235          5.010,
236          4.500,
237          4.171,
238          3.939,
239          3.765,
240          3.631,
241          3.523,
242          3.434,
243      },
244      {
245          8.096,
246          5.849,
247          4.938,
248          4.431,
249          4.103,
250          3.871,
251          3.699,
252          3.564,
253          3.457,
254          3.368,
255      },
256      {
257          8.017,
258          5.780,
259          4.874,
260          4.369,
261          4.042,
262          3.812,
263          3.640,
264          3.506,
265          3.398,
266          3.310,
267      },
268      {
269          7.945,
270          5.719,
271          4.817,
272          4.313,
273          3.988,
274          3.758,
275          3.587,
276          3.453,
277          3.346,
278          3.258,
279      },
280      {
281          7.881,
282          5.664,
283          4.765,
284          4.264,
285          3.939,
286          3.710,
287          3.539,
288          3.406,
289          3.299,
290          3.211,
291      },
292      {
293          7.823,
294          5.614,
295          4.718,
296          4.218,
297          3.895,
298          3.667,
299          3.496,
300          3.363,
301          3.256,
302          3.168,
303      },
304      {
305          7.770,
306          5.568,
307          4.675,
308          4.177,
309          3.855,
310          3.627,
311          3.457,
312          3.324,
313          3.217,
314          3.129,
315      },
316      {
317          7.721,
318          5.526,
319          4.637,
320          4.140,
321          3.818,
322          3.591,
323          3.421,
324          3.288,
325          3.182,
326          3.094,
327      },
328      {
329          7.677,
330          5.488,
331          4.601,
332          4.106,
333          3.785,
334          3.558,
335          3.388,
336          3.256,
337          3.149,
338          3.062,
339      },
340      {
341          7.636,
342          5.453,
343          4.568,
344          4.074,
345          3.754,
346          3.528,
347          3.358,
348          3.226,
349          3.120,
350          3.032,
351      },
352      {
353          7.598,
354          5.420,
355          4.538,
356          4.045,
357          3.725,
358          3.499,
359          3.330,
360          3.198,
361          3.092,
362          3.005,
363      },
364      {
365          7.562,
366          5.390,
367          4.510,
368          4.018,
369          3.699,
370          3.473,
371          3.305,
372          3.173,
373          3.067,
374          2.979,
375      },
376      {
377          7.530,
378          5.362,
379          4.484,
380          3.993,
381          3.675,
382          3.449,
383          3.281,
384          3.149,
385          3.043,
386          2.955,
387      },
388      {
389          7.499,
390          5.336,
391          4.459,
392          3.969,
393          3.652,
394          3.427,
395          3.258,
396          3.127,
397          3.021,
398          2.934,
399      },
400      {
401          7.471,
402          5.312,
403          4.437,
404          3.948,
405          3.630,
406          3.406,
407          3.238,
408          3.106,
409          3.000,
410          2.913,
411      },
412      {
413          7.444,
414          5.289,
415          4.416,
416          3.927,
417          3.611,
418          3.386,
419          3.218,
420          3.087,
421          2.981,
422          2.894,
423      },
424      {
425          7.419,
426          5.268,
427          4.396,
428          3.908,
429          3.592,
430          3.368,
431          3.200,
432          3.069,
433          2.963,
434          2.876,
435      },
436      {
437          7.396,
438          5.248,
439          4.377,
440          3.890,
441          3.574,
442          3.351,
443          3.183,
444          3.052,
445          2.946,
446          2.859,
447      },
448      {
449          7.373,
450          5.229,
451          4.360,
452          3.873,
453          3.558,
454          3.334,
455          3.167,
456          3.036,
457          2.930,
458          2.843,
459      },
460      {
461          7.353,
462          5.211,
463          4.343,
464          3.858,
465          3.542,
466          3.319,
467          3.152,
468          3.021,
469          2.915,
470          2.828,
471      },
472      {
473          7.333,
474          5.194,
475          4.327,
476          3.843,
477          3.528,
478          3.305,
479          3.137,
480          3.006,
481          2.901,
482          2.814,
483      },
484      {
485          7.314,
486          5.179,
487          4.313,
488          3.828,
489          3.514,
490          3.291,
491          3.124,
492          2.993,
493          2.888,
494          2.801,
495      },
496      {
497          7.296,
498          5.163,
499          4.299,
500          3.815,
501          3.501,
502          3.278,
503          3.111,
504          2.980,
505          2.875,
506          2.788,
507      },
508      {
509          7.280,
510          5.149,
511          4.285,
512          3.802,
513          3.488,
514          3.266,
515          3.099,
516          2.968,
517          2.863,
518          2.776,
519      },
520      {
521          7.264,
522          5.136,
523          4.273,
524          3.790,
525          3.476,
526          3.254,
527          3.087,
528          2.957,
529          2.851,
530          2.764,
531      },
532      {
533          7.248,
534          5.123,
535          4.261,
536          3.778,
537          3.465,
538          3.243,
539          3.076,
540          2.946,
541          2.840,
542          2.754,
543      },
544      {
545          7.234,
546          5.110,
547          4.249,
548          3.767,
549          3.454,
550          3.232,
551          3.066,
552          2.935,
553          2.830,
554          2.743,
555      },
556      {
557          7.220,
558          5.099,
559          4.238,
560          3.757,
561          3.444,
562          3.222,
563          3.056,
564          2.925,
565          2.820,
566          2.733,
567      },
568      {
569          7.207,
570          5.087,
571          4.228,
572          3.747,
573          3.434,
574          3.213,
575          3.046,
576          2.916,
577          2.811,
578          2.724,
579      },
580      {
581          7.194,
582          5.077,
583          4.218,
584          3.737,
585          3.425,
586          3.204,
587          3.037,
588          2.907,
589          2.802,
590          2.715,
591      },
592      {
593          7.182,
594          5.066,
595          4.208,
596          3.728,
597          3.416,
598          3.195,
599          3.028,
600          2.898,
601          2.793,
602          2.706,
603      },
604      {
605          7.171,
606          5.057,
607          4.199,
608          3.720,
609          3.408,
610          3.186,
611          3.020,
612          2.890,
613          2.785,
614          2.698,
615      },
616      {
617          7.159,
618          5.047,
619          4.191,
620          3.711,
621          3.400,
622          3.178,
623          3.012,
624          2.882,
625          2.777,
626          2.690,
627      },
628      {
629          7.149,
630          5.038,
631          4.182,
632          3.703,
633          3.392,
634          3.171,
635          3.005,
636          2.874,
637          2.769,
638          2.683,
639      },
640      {
641          7.139,
642          5.030,
643          4.174,
644          3.695,
645          3.384,
646          3.163,
647          2.997,
648          2.867,
649          2.762,
650          2.675,
651      },
652      {
653          7.129,
654          5.021,
655          4.167,
656          3.688,
657          3.377,
658          3.156,
659          2.990,
660          2.860,
661          2.755,
662          2.668,
663      },
664      {
665          7.119,
666          5.013,
667          4.159,
668          3.681,
669          3.370,
670          3.149,
671          2.983,
672          2.853,
673          2.748,
674          2.662,
675      },
676      {
677          7.110,
678          5.006,
679          4.152,
680          3.674,
681          3.363,
682          3.143,
683          2.977,
684          2.847,
685          2.742,
686          2.655,
687      },
688      {
689          7.102,
690          4.998,
691          4.145,
692          3.667,
693          3.357,
694          3.136,
695          2.971,
696          2.841,
697          2.736,
698          2.649,
699      },
700      {
701          7.093,
702          4.991,
703          4.138,
704          3.661,
705          3.351,
706          3.130,
707          2.965,
708          2.835,
709          2.730,
710          2.643,
711      },
712      {
713          7.085,
714          4.984,
715          4.132,
716          3.655,
717          3.345,
718          3.124,
719          2.959,
720          2.829,
721          2.724,
722          2.637,
723      },
724      {
725          7.077,
726          4.977,
727          4.126,
728          3.649,
729          3.339,
730          3.119,
731          2.953,
732          2.823,
733          2.718,
734          2.632,
735      },
736      {
737          7.070,
738          4.971,
739          4.120,
740          3.643,
741          3.333,
742          3.113,
743          2.948,
744          2.818,
745          2.713,
746          2.626,
747      },
748      {
749          7.062,
750          4.965,
751          4.114,
752          3.638,
753          3.328,
754          3.108,
755          2.942,
756          2.813,
757          2.708,
758          2.621,
759      },
760      {
761          7.055,
762          4.959,
763          4.109,
764          3.632,
765          3.323,
766          3.103,
767          2.937,
768          2.808,
769          2.703,
770          2.616,
771      },
772      {
773          7.048,
774          4.953,
775          4.103,
776          3.627,
777          3.318,
778          3.098,
779          2.932,
780          2.803,
781          2.698,
782          2.611,
783      },
784      {
785          7.042,
786          4.947,
787          4.098,
788          3.622,
789          3.313,
790          3.093,
791          2.928,
792          2.798,
793          2.693,
794          2.607,
795      },
796      {
797          7.035,
798          4.942,
799          4.093,
800          3.618,
801          3.308,
802          3.088,
803          2.923,
804          2.793,
805          2.689,
806          2.602,
807      },
808      {
809          7.029,
810          4.937,
811          4.088,
812          3.613,
813          3.304,
814          3.084,
815          2.919,
816          2.789,
817          2.684,
818          2.598,
819      },
820      {
821          7.023,
822          4.932,
823          4.083,
824          3.608,
825          3.299,
826          3.080,
827          2.914,
828          2.785,
829          2.680,
830          2.593,
831      },
832      {
833          7.017,
834          4.927,
835          4.079,
836          3.604,
837          3.295,
838          3.075,
839          2.910,
840          2.781,
841          2.676,
842          2.589,
843      },
844      {
845          7.011,
846          4.922,
847          4.074,
848          3.600,
849          3.291,
850          3.071,
851          2.906,
852          2.777,
853          2.672,
854          2.585,
855      },
856      {
857          7.006,
858          4.917,
859          4.070,
860          3.596,
861          3.287,
862          3.067,
863          2.902,
864          2.773,
865          2.668,
866          2.581,
867      },
868      {
869          7.001,
870          4.913,
871          4.066,
872          3.591,
873          3.283,
874          3.063,
875          2.898,
876          2.769,
877          2.664,
878          2.578,
879      },
880      {
881          6.995,
882          4.908,
883          4.062,
884          3.588,
885          3.279,
886          3.060,
887          2.895,
888          2.765,
889          2.660,
890          2.574,
891      },
892      {
893          6.990,
894          4.904,
895          4.058,
896          3.584,
897          3.275,
898          3.056,
899          2.891,
900          2.762,
901          2.657,
902          2.570,
903      },
904      {
905          6.985,
906          4.900,
907          4.054,
908          3.580,
909          3.272,
910          3.052,
911          2.887,
912          2.758,
913          2.653,
914          2.567,
915      },
916      {
917          6.981,
918          4.896,
919          4.050,
920          3.577,
921          3.268,
922          3.049,
923          2.884,
924          2.755,
925          2.650,
926          2.563,
927      },
928      {
929          6.976,
930          4.892,
931          4.047,
932          3.573,
933          3.265,
934          3.046,
935          2.881,
936          2.751,
937          2.647,
938          2.560,
939      },
940      {
941          6.971,
942          4.888,
943          4.043,
944          3.570,
945          3.261,
946          3.042,
947          2.877,
948          2.748,
949          2.644,
950          2.557,
951      },
952      {
953          6.967,
954          4.884,
955          4.040,
956          3.566,
957          3.258,
958          3.039,
959          2.874,
960          2.745,
961          2.640,
962          2.554,
963      },
964      {
965          6.963,
966          4.881,
967          4.036,
968          3.563,
969          3.255,
970          3.036,
971          2.871,
972          2.742,
973          2.637,
974          2.551,
975      },
976      {
977          6.958,
978          4.877,
979          4.033,
980          3.560,
981          3.252,
982          3.033,
983          2.868,
984          2.739,
985          2.634,
986          2.548,
987      },
988      {
989          6.954,
990          4.874,
991          4.030,
992          3.557,
993          3.249,
994          3.030,
995          2.865,
996          2.736,
997          2.632,
998          2.545,
999      },
1000      {
1001          6.950,
1002          4.870,
1003          4.027,
1004          3.554,
1005          3.246,
1006          3.027,
1007          2.863,
1008          2.733,
1009          2.629,
1010          2.542,
1011      },
1012      {
1013          6.947,
1014          4.867,
1015          4.024,
1016          3.551,
1017          3.243,
1018          3.025,
1019          2.860,
1020          2.731,
1021          2.626,
1022          2.539,
1023      },
1024      {
1025          6.943,
1026          4.864,
1027          4.021,
1028          3.548,
1029          3.240,
1030          3.022,
1031          2.857,
1032          2.728,
1033          2.623,
1034          2.537,
1035      },
1036      {
1037          6.939,
1038          4.861,
1039          4.018,
1040          3.545,
1041          3.238,
1042          3.019,
1043          2.854,
1044          2.725,
1045          2.621,
1046          2.534,
1047      },
1048      {
1049          6.935,
1050          4.858,
1051          4.015,
1052          3.543,
1053          3.235,
1054          3.017,
1055          2.852,
1056          2.723,
1057          2.618,
1058          2.532,
1059      },
1060      {
1061          6.932,
1062          4.855,
1063          4.012,
1064          3.540,
1065          3.233,
1066          3.014,
1067          2.849,
1068          2.720,
1069          2.616,
1070          2.529,
1071      },
1072      {
1073          6.928,
1074          4.852,
1075          4.010,
1076          3.538,
1077          3.230,
1078          3.012,
1079          2.847,
1080          2.718,
1081          2.613,
1082          2.527,
1083      },
1084      {
1085          6.925,
1086          4.849,
1087          4.007,
1088          3.535,
1089          3.228,
1090          3.009,
1091          2.845,
1092          2.715,
1093          2.611,
1094          2.524,
1095      },
1096      {
1097          6.922,
1098          4.846,
1099          4.004,
1100          3.533,
1101          3.225,
1102          3.007,
1103          2.842,
1104          2.713,
1105          2.609,
1106          2.522,
1107      },
1108      {
1109          6.919,
1110          4.844,
1111          4.002,
1112          3.530,
1113          3.223,
1114          3.004,
1115          2.840,
1116          2.711,
1117          2.606,
1118          2.520,
1119      },
1120      {
1121          6.915,
1122          4.841,
1123          3.999,
1124          3.528,
1125          3.221,
1126          3.002,
1127          2.838,
1128          2.709,
1129          2.604,
1130          2.518,
1131      },
1132      {
1133          6.912,
1134          4.838,
1135          3.997,
1136          3.525,
1137          3.218,
1138          3.000,
1139          2.835,
1140          2.706,
1141          2.602,
1142          2.515,
1143      },
1144      {
1145          6.909,
1146          4.836,
1147          3.995,
1148          3.523,
1149          3.216,
1150          2.998,
1151          2.833,
1152          2.704,
1153          2.600,
1154          2.513,
1155      },
1156      {
1157          6.906,
1158          4.833,
1159          3.992,
1160          3.521,
1161          3.214,
1162          2.996,
1163          2.831,
1164          2.702,
1165          2.598,
1166          2.511,
1167      },
1168      {
1169          6.904,
1170          4.831,
1171          3.990,
1172          3.519,
1173          3.212,
1174          2.994,
1175          2.829,
1176          2.700,
1177          2.596,
1178          2.509,
1179      },
1180      {
1181          6.901,
1182          4.829,
1183          3.988,
1184          3.517,
1185          3.210,
1186          2.992,
1187          2.827,
1188          2.698,
1189          2.594,
1190          2.507,
1191      },
1192      {
1193          6.898,
1194          4.826,
1195          3.986,
1196          3.515,
1197          3.208,
1198          2.990,
1199          2.825,
1200          2.696,
1201          2.592,
1202          2.505,
1203      },
1204      {6.895, 4.824, 3.984, 3.513, 3.206, 2.988, 2.823, 2.694, 2.590, 2.503}};
1205  #define MINVARIANCE 0.0004
1206  #define MINSAMPLESPERBUCKET 5
1207  #define MINSAMPLES (MINBUCKETS * MINSAMPLESPERBUCKET)
1208  #define MINSAMPLESNEEDED 1
1209  #define BUCKETTABLESIZE 1024
1210  #define NORMALEXTENT 3.0
1211  struct TEMPCLUSTER {
1212    CLUSTER *Cluster;
1213    CLUSTER *Neighbor;
1214  };
1215  using ClusterPair = tesseract::KDPairInc<float, TEMPCLUSTER *>;
1216  using ClusterHeap = tesseract::GenericHeap<ClusterPair>;
1217  struct STATISTICS {
1218    STATISTICS(size_t n) : CoVariance(n * n), Min(n), Max(n) {
1219    }
1220    float AvgVariance = 1.0f;
1221    std::vector<float> CoVariance;
1222    std::vector<float> Min; 
1223    std::vector<float> Max; 
1224  };
1225  struct BUCKETS {
1226    BUCKETS(size_t n) : NumberOfBuckets(n), Count(n), ExpectedCount(n) {
1227    }
1228    ~BUCKETS() {
1229    }
1230    DISTRIBUTION Distribution = normal; 
1231    uint32_t SampleCount = 0;         
1232    double Confidence = 0.0;          
1233    double ChiSquared = 0.0;          
1234    uint16_t NumberOfBuckets;         
1235    uint16_t Bucket[BUCKETTABLESIZE]; 
1236    std::vector<uint32_t> Count;      
1237    std::vector<float> ExpectedCount; 
1238  };
1239  struct CHISTRUCT {
1240    CHISTRUCT(uint16_t degreesOfFreedom, double alpha) : DegreesOfFreedom(degreesOfFreedom), Alpha(alpha) {
1241    }
1242    uint16_t DegreesOfFreedom = 0;
1243    double Alpha = 0.0;
1244    double ChiSquared = 0.0;
1245  };
1246  struct ClusteringContext {
1247    ClusterHeap *heap;       
1248    TEMPCLUSTER *candidates; 
1249    KDTREE *tree;            
1250    int32_t next;            
1251  };
1252  using DENSITYFUNC = double (*)(int32_t);
1253  using SOLVEFUNC = double (*)(CHISTRUCT *, double);
1254  #define Odd(N) ((N) % 2)
1255  #define Mirror(N, R) ((R) - (N)-1)
1256  #define Abs(N) (((N) < 0) ? (-(N)) : (N))
1257  #define SqrtOf2Pi 2.506628275
1258  static const double kNormalStdDev = BUCKETTABLESIZE / (2.0 * NORMALEXTENT);
1259  static const double kNormalVariance =
1260      (BUCKETTABLESIZE * BUCKETTABLESIZE) / (4.0 * NORMALEXTENT * NORMALEXTENT);
1261  static const double kNormalMagnitude = (2.0 * NORMALEXTENT) / (SqrtOf2Pi * BUCKETTABLESIZE);
1262  static const double kNormalMean = BUCKETTABLESIZE / 2;
1263  #define LOOKUPTABLESIZE 8
1264  #define MAXDEGREESOFFREEDOM MAXBUCKETS
1265  static const uint32_t kCountTable[LOOKUPTABLESIZE] = {MINSAMPLES, 200,  400, 600, 800,
1266                                                        1000,       1500, 2000}; 
1267  static const uint16_t kBucketsTable[LOOKUPTABLESIZE] = {
1268      MINBUCKETS, 16, 20, 24, 27, 30, 35, MAXBUCKETS}; 
1269  static void CreateClusterTree(CLUSTERER *Clusterer);
1270  static void MakePotentialClusters(ClusteringContext *context, CLUSTER *Cluster, int32_t Level);
1271  static CLUSTER *FindNearestNeighbor(KDTREE *Tree, CLUSTER *Cluster, float *Distance);
1272  static CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster);
1273  static void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config);
1274  static PROTOTYPE *MakePrototype(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster);
1275  static PROTOTYPE *MakeDegenerateProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics,
1276                                        PROTOSTYLE Style, int32_t MinSamples);
1277  static PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster,
1278                                        STATISTICS *Statistics);
1279  static PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1280                                       BUCKETS *Buckets);
1281  static PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer, CLUSTER *Cluster,
1282                                        STATISTICS *Statistics, BUCKETS *Buckets);
1283  static PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1284                                   BUCKETS *NormalBuckets, double Confidence);
1285  static void MakeDimRandom(uint16_t i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc);
1286  static void MakeDimUniform(uint16_t i, PROTOTYPE *Proto, STATISTICS *Statistics);
1287  static STATISTICS *ComputeStatistics(int16_t N, PARAM_DESC ParamDesc[], CLUSTER *Cluster);
1288  static PROTOTYPE *NewSphericalProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1289  static PROTOTYPE *NewEllipticalProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1290  static PROTOTYPE *NewMixedProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1291  static PROTOTYPE *NewSimpleProto(int16_t N, CLUSTER *Cluster);
1292  static bool Independent(PARAM_DESC *ParamDesc, int16_t N, float *CoVariance, float Independence);
1293  static BUCKETS *GetBuckets(CLUSTERER *clusterer, DISTRIBUTION Distribution, uint32_t SampleCount,
1294                             double Confidence);
1295  static BUCKETS *MakeBuckets(DISTRIBUTION Distribution, uint32_t SampleCount, double Confidence);
1296  static uint16_t OptimumNumberOfBuckets(uint32_t SampleCount);
1297  static double ComputeChiSquared(uint16_t DegreesOfFreedom, double Alpha);
1298  static double NormalDensity(int32_t x);
1299  static double UniformDensity(int32_t x);
1300  static double Integral(double f1, double f2, double Dx);
1301  static void FillBuckets(BUCKETS *Buckets, CLUSTER *Cluster, uint16_t Dim, PARAM_DESC *ParamDesc,
1302                          float Mean, float StdDev);
1303  static uint16_t NormalBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev);
1304  static uint16_t UniformBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev);
1305  static bool DistributionOK(BUCKETS *Buckets);
1306  static uint16_t DegreesOfFreedom(DISTRIBUTION Distribution, uint16_t HistogramBuckets);
1307  static void AdjustBuckets(BUCKETS *Buckets, uint32_t NewSampleCount);
1308  static void InitBuckets(BUCKETS *Buckets);
1309  static int AlphaMatch(void *arg1,  
1310                        void *arg2); 
1311  static double Solve(SOLVEFUNC Function, void *FunctionParams, double InitialGuess, double Accuracy);
1312  static double ChiArea(CHISTRUCT *ChiParams, double x);
1313  static bool MultipleCharSamples(CLUSTERER *Clusterer, CLUSTER *Cluster, float MaxIllegal);
1314  static double InvertMatrix(const float *input, int size, float *inv);
1315  CLUSTERER *MakeClusterer(int16_t SampleSize, const PARAM_DESC ParamDesc[]) {
1316    int i;
1317    auto Clusterer = new CLUSTERER;
1318    Clusterer->SampleSize = SampleSize;
1319    Clusterer->NumberOfSamples = 0;
1320    Clusterer->NumChar = 0;
1321    Clusterer->Root = nullptr;
1322    Clusterer->ProtoList = NIL_LIST;
1323    Clusterer->ParamDesc = new PARAM_DESC[SampleSize];
1324    for (i = 0; i < SampleSize; i++) {
1325      Clusterer->ParamDesc[i].Circular = ParamDesc[i].Circular;
1326      Clusterer->ParamDesc[i].NonEssential = ParamDesc[i].NonEssential;
1327      Clusterer->ParamDesc[i].Min = ParamDesc[i].Min;
1328      Clusterer->ParamDesc[i].Max = ParamDesc[i].Max;
1329      Clusterer->ParamDesc[i].Range = ParamDesc[i].Max - ParamDesc[i].Min;
1330      Clusterer->ParamDesc[i].HalfRange = Clusterer->ParamDesc[i].Range / 2;
1331      Clusterer->ParamDesc[i].MidRange = (ParamDesc[i].Max + ParamDesc[i].Min) / 2;
1332    }
1333    Clusterer->KDTree = MakeKDTree(SampleSize, ParamDesc);
1334    for (auto &d : Clusterer->bucket_cache) {
1335      for (auto &c : d) {
1336        c = nullptr;
1337      }
1338    }
1339    return Clusterer;
1340  } 
1341  SAMPLE *MakeSample(CLUSTERER *Clusterer, const float *Feature, uint32_t CharID) {
1342    int i;
1343    ASSERT_HOST(Clusterer->Root == nullptr);
1344    auto Sample = new SAMPLE(Clusterer->SampleSize);
1345    Sample->Clustered = false;
1346    Sample->Prototype = false;
1347    Sample->SampleCount = 1;
1348    Sample->Left = nullptr;
1349    Sample->Right = nullptr;
1350    Sample->CharID = CharID;
1351    for (i = 0; i < Clusterer->SampleSize; i++) {
1352      Sample->Mean[i] = Feature[i];
1353    }
1354    Clusterer->NumberOfSamples++;
1355    KDStore(Clusterer->KDTree, &Sample->Mean[0], Sample);
1356    if (CharID >= Clusterer->NumChar) {
1357      Clusterer->NumChar = CharID + 1;
1358    }
1359    return (Sample);
1360  } 
1361  LIST ClusterSamples(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
1362    if (Clusterer->Root == nullptr) {
1363      CreateClusterTree(Clusterer);
1364    }
1365    FreeProtoList(&Clusterer->ProtoList);
1366    Clusterer->ProtoList = NIL_LIST;
1367    ComputePrototypes(Clusterer, Config);
1368    LIST proto_list = Clusterer->ProtoList;
1369    iterate(proto_list) {
1370      auto *proto = reinterpret_cast<PROTOTYPE *>(proto_list->first_node());
1371      proto->Cluster = nullptr;
1372    }
1373    return Clusterer->ProtoList;
1374  } 
1375  void FreeClusterer(CLUSTERER *Clusterer) {
1376    if (Clusterer != nullptr) {
1377      delete[] Clusterer->ParamDesc;
1378      delete Clusterer->KDTree;
1379      delete Clusterer->Root;
1380      for (auto &d : Clusterer->bucket_cache) {
1381        for (auto &c : d) {
1382          delete c;
1383        }
1384      }
1385      delete Clusterer;
1386    }
1387  } 
1388  void FreeProtoList(LIST *ProtoList) {
1389    destroy_nodes(*ProtoList, FreePrototype);
1390  } 
1391  void FreePrototype(void *arg) { 
1392    auto *Prototype = static_cast<PROTOTYPE *>(arg);
1393    if (Prototype->Cluster != nullptr) {
1394      Prototype->Cluster->Prototype = false;
1395    }
1396    if (Prototype->Style != spherical) {
1397      delete[] Prototype->Variance.Elliptical;
1398      delete[] Prototype->Magnitude.Elliptical;
1399      delete[] Prototype->Weight.Elliptical;
1400    }
1401    delete Prototype;
1402  } 
1403  CLUSTER *NextSample(LIST *SearchState) {
1404    CLUSTER *Cluster;
1405    if (*SearchState == NIL_LIST) {
1406      return (nullptr);
1407    }
1408    Cluster = reinterpret_cast<CLUSTER *>((*SearchState)->first_node());
1409    *SearchState = pop(*SearchState);
1410    for (;;) {
1411      if (Cluster->Left == nullptr) {
1412        return (Cluster);
1413      }
1414      *SearchState = push(*SearchState, Cluster->Right);
1415      Cluster = Cluster->Left;
1416    }
1417  } 
1418  float Mean(PROTOTYPE *Proto, uint16_t Dimension) {
1419    return (Proto->Mean[Dimension]);
1420  } 
1421  float StandardDeviation(PROTOTYPE *Proto, uint16_t Dimension) {
1422    switch (Proto->Style) {
1423      case spherical:
1424        return std::sqrt(Proto->Variance.Spherical);
1425      case elliptical:
1426        return std::sqrt(Proto->Variance.Elliptical[Dimension]);
1427      case mixed:
1428        switch (Proto->Distrib[Dimension]) {
1429          case normal:
1430            return std::sqrt(Proto->Variance.Elliptical[Dimension]);
1431          case uniform:
1432          case D_random:
1433            return Proto->Variance.Elliptical[Dimension];
1434          case DISTRIBUTION_COUNT:
1435            ASSERT_HOST(!"Distribution count not allowed!");
1436        }
1437    }
1438    return 0.0f;
1439  } 
1440  static void CreateClusterTree(CLUSTERER *Clusterer) {
1441    ClusteringContext context;
1442    ClusterPair HeapEntry;
1443    context.tree = Clusterer->KDTree;
1444    context.candidates = new TEMPCLUSTER[Clusterer->NumberOfSamples];
1445    context.next = 0;
1446    context.heap = new ClusterHeap(Clusterer->NumberOfSamples);
1447    KDWalk(context.tree, MakePotentialClusters, &context);
1448    while (context.heap->Pop(&HeapEntry)) {
1449      TEMPCLUSTER *PotentialCluster = HeapEntry.data();
1450      if (PotentialCluster->Cluster->Clustered) {
1451        continue;
1452      }
1453      else if (PotentialCluster->Neighbor->Clustered) {
1454        PotentialCluster->Neighbor =
1455            FindNearestNeighbor(context.tree, PotentialCluster->Cluster, &HeapEntry.key());
1456        if (PotentialCluster->Neighbor != nullptr) {
1457          context.heap->Push(&HeapEntry);
1458        }
1459      }
1460      else {
1461        PotentialCluster->Cluster = MakeNewCluster(Clusterer, PotentialCluster);
1462        PotentialCluster->Neighbor =
1463            FindNearestNeighbor(context.tree, PotentialCluster->Cluster, &HeapEntry.key());
1464        if (PotentialCluster->Neighbor != nullptr) {
1465          context.heap->Push(&HeapEntry);
1466        }
1467      }
1468    }
1469    Clusterer->Root = static_cast<CLUSTER *> RootOf(Clusterer->KDTree);
1470    delete context.tree;
1471    Clusterer->KDTree = nullptr;
1472    delete context.heap;
1473    delete[] context.candidates;
1474  } 
1475  static void MakePotentialClusters(ClusteringContext *context, CLUSTER *Cluster, int32_t &bsol;*Level*/) {
1476    ClusterPair HeapEntry;
1477    int next = context->next;
1478    context->candidates[next].Cluster = Cluster;
1479    HeapEntry.data() = &(context->candidates[next]);
1480    context->candidates[next].Neighbor =
1481        FindNearestNeighbor(context->tree, context->candidates[next].Cluster, &HeapEntry.key());
1482    if (context->candidates[next].Neighbor != nullptr) {
1483      context->heap->Push(&HeapEntry);
1484      context->next++;
1485    }
1486  } 
1487  static CLUSTER *FindNearestNeighbor(KDTREE *Tree, CLUSTER *Cluster, float *Distance)
1488  #define MAXNEIGHBORS 2
1489  #define MAXDISTANCE FLT_MAX
1490  {
1491    CLUSTER *Neighbor[MAXNEIGHBORS];
1492    float Dist[MAXNEIGHBORS];
1493    int NumberOfNeighbors;
1494    int32_t i;
1495    CLUSTER *BestNeighbor;
1496    KDNearestNeighborSearch(Tree, &Cluster->Mean[0], MAXNEIGHBORS, MAXDISTANCE, &NumberOfNeighbors,
1497                            reinterpret_cast<void **>(Neighbor), Dist);
1498    *Distance = MAXDISTANCE;
1499    BestNeighbor = nullptr;
1500    for (i = 0; i < NumberOfNeighbors; i++) {
1501      if ((Dist[i] < *Distance) && (Neighbor[i] != Cluster)) {
1502        *Distance = Dist[i];
1503        BestNeighbor = Neighbor[i];
1504      }
1505    }
1506    return BestNeighbor;
1507  } 
1508  static CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster) {
1509    auto Cluster = new CLUSTER(Clusterer->SampleSize);
1510    Cluster->Clustered = false;
1511    Cluster->Prototype = false;
1512    Cluster->Left = TempCluster->Cluster;
1513    Cluster->Right = TempCluster->Neighbor;
1514    Cluster->CharID = -1;
1515    Cluster->Left->Clustered = true;
1516    Cluster->Right->Clustered = true;
1517    KDDelete(Clusterer->KDTree, &Cluster->Left->Mean[0], Cluster->Left);
1518    KDDelete(Clusterer->KDTree, &Cluster->Right->Mean[0], Cluster->Right);
1519    Cluster->SampleCount = MergeClusters(Clusterer->SampleSize, Clusterer->ParamDesc,
1520                                         Cluster->Left->SampleCount, Cluster->Right->SampleCount,
1521                                         &Cluster->Mean[0], &Cluster->Left->Mean[0], &Cluster->Right->Mean[0]);
1522    KDStore(Clusterer->KDTree, &Cluster->Mean[0], Cluster);
1523    return Cluster;
1524  } 
1525  int32_t MergeClusters(int16_t N, PARAM_DESC ParamDesc[], int32_t n1, int32_t n2, float m[],
1526                        float m1[], float m2[]) {
1527    int32_t i, n;
1528    n = n1 + n2;
1529    for (i = N; i > 0; i--, ParamDesc++, m++, m1++, m2++) {
1530      if (ParamDesc->Circular) {
1531        if ((*m2 - *m1) > ParamDesc->HalfRange) {
1532          *m = (n1 * *m1 + n2 * (*m2 - ParamDesc->Range)) / n;
1533          if (*m < ParamDesc->Min) {
1534            *m += ParamDesc->Range;
1535          }
1536        } else if ((*m1 - *m2) > ParamDesc->HalfRange) {
1537          *m = (n1 * (*m1 - ParamDesc->Range) + n2 * *m2) / n;
1538          if (*m < ParamDesc->Min) {
1539            *m += ParamDesc->Range;
1540          }
1541        } else {
1542          *m = (n1 * *m1 + n2 * *m2) / n;
1543        }
1544      } else {
1545        *m = (n1 * *m1 + n2 * *m2) / n;
1546      }
1547    }
1548    return n;
1549  } 
1550  static void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
1551    LIST ClusterStack = NIL_LIST;
1552    CLUSTER *Cluster;
1553    PROTOTYPE *Prototype;
1554    if (Clusterer->Root != nullptr) {
1555      ClusterStack = push(NIL_LIST, Clusterer->Root);
1556    }
1557    while (ClusterStack != NIL_LIST) {
1558      Cluster = reinterpret_cast<CLUSTER *>(ClusterStack->first_node());
1559      ClusterStack = pop(ClusterStack);
1560      Prototype = MakePrototype(Clusterer, Config, Cluster);
1561      if (Prototype != nullptr) {
1562        Clusterer->ProtoList = push(Clusterer->ProtoList, Prototype);
1563      } else {
1564        ClusterStack = push(ClusterStack, Cluster->Right);
1565        ClusterStack = push(ClusterStack, Cluster->Left);
1566      }
1567    }
1568  } 
1569  static PROTOTYPE *MakePrototype(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster) {
1570    PROTOTYPE *Proto;
1571    BUCKETS *Buckets;
1572    if (MultipleCharSamples(Clusterer, Cluster, Config->MaxIllegal)) {
1573      return nullptr;
1574    }
1575    auto Statistics = ComputeStatistics(Clusterer->SampleSize, Clusterer->ParamDesc, Cluster);
1576    Proto = MakeDegenerateProto(Clusterer->SampleSize, Cluster, Statistics, Config->ProtoStyle,
1577                                static_cast<int32_t>(Config->MinSamples * Clusterer->NumChar));
1578    if (Proto != nullptr) {
1579      delete Statistics;
1580      return Proto;
1581    }
1582    if (!Independent(Clusterer->ParamDesc, Clusterer->SampleSize, &Statistics->CoVariance[0],
1583                     Config->Independence)) {
1584      delete Statistics;
1585      return nullptr;
1586    }
1587    if (HOTELLING && Config->ProtoStyle == elliptical) {
1588      Proto = TestEllipticalProto(Clusterer, Config, Cluster, Statistics);
<span onclick='openModal()' class='match'>1589      if (Proto != nullptr) {
1590        delete Statistics;
1591        return Proto;
1592      }
1593    }
</span>1594    Buckets = GetBuckets(Clusterer, normal, Cluster->SampleCount, Config->Confidence);
1595    switch (Config->ProtoStyle) {
1596      case spherical:
1597        Proto = MakeSphericalProto(Clusterer, Cluster, Statistics, Buckets);
1598        break;
1599      case elliptical:
1600        Proto = MakeEllipticalProto(Clusterer, Cluster, Statistics, Buckets);
1601        break;
1602      case mixed:
1603        Proto = MakeMixedProto(Clusterer, Cluster, Statistics, Buckets, Config->Confidence);
1604        break;
1605      case automatic:
1606        Proto = MakeSphericalProto(Clusterer, Cluster, Statistics, Buckets);
1607        if (Proto != nullptr) {
1608          break;
1609        }
1610        Proto = MakeEllipticalProto(Clusterer, Cluster, Statistics, Buckets);
1611        if (Proto != nullptr) {
1612          break;
1613        }
1614        Proto = MakeMixedProto(Clusterer, Cluster, Statistics, Buckets, Config->Confidence);
1615        break;
1616    }
1617    delete Statistics;
1618    return Proto;
1619  } 
1620  static PROTOTYPE *MakeDegenerateProto( 
1621      uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics, PROTOSTYLE Style, int32_t MinSamples) {
1622    PROTOTYPE *Proto = nullptr;
1623    if (MinSamples < MINSAMPLESNEEDED) {
1624      MinSamples = MINSAMPLESNEEDED;
1625    }
1626    if (Cluster->SampleCount < MinSamples) {
1627      switch (Style) {
1628        case spherical:
1629          Proto = NewSphericalProto(N, Cluster, Statistics);
1630          break;
1631        case elliptical:
1632        case automatic:
1633          Proto = NewEllipticalProto(N, Cluster, Statistics);
1634          break;
1635        case mixed:
1636          Proto = NewMixedProto(N, Cluster, Statistics);
1637          break;
1638      }
1639      Proto->Significant = false;
1640    }
1641    return (Proto);
1642  } 
1643  static PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster,
1644                                        STATISTICS *Statistics) {
1645    const double kMagicSampleMargin = 0.0625;
1646    const double kFTableBoostMargin = 2.0;
1647    int N = Clusterer->SampleSize;
1648    CLUSTER *Left = Cluster->Left;
1649    CLUSTER *Right = Cluster->Right;
1650    if (Left == nullptr || Right == nullptr) {
1651      return nullptr;
1652    }
1653    int TotalDims = Left->SampleCount + Right->SampleCount;
1654    if (TotalDims < N + 1 || TotalDims < 2) {
1655      return nullptr;
1656    }
1657    std::vector<float> Covariance(static_cast<size_t>(N) * N);
1658    std::vector<float> Inverse(static_cast<size_t>(N) * N);
1659    std::vector<float> Delta(N);
1660    for (int i = 0; i < N; ++i) {
1661      int row_offset = i * N;
1662      if (!Clusterer->ParamDesc[i].NonEssential) {
1663        for (int j = 0; j < N; ++j) {
1664          if (!Clusterer->ParamDesc[j].NonEssential) {
1665            Covariance[j + row_offset] = Statistics->CoVariance[j + row_offset];
1666          } else {
1667            Covariance[j + row_offset] = 0.0f;
1668          }
1669        }
1670      } else {
1671        for (int j = 0; j < N; ++j) {
1672          if (i == j) {
1673            Covariance[j + row_offset] = 1.0f;
1674          } else {
1675            Covariance[j + row_offset] = 0.0f;
1676          }
1677        }
1678      }
1679    }
1680    double err = InvertMatrix(&Covariance[0], N, &Inverse[0]);
1681    if (err > 1) {
1682      tprintf("Clustering error: Matrix inverse failed with error %g\n", err);
1683    }
1684    int EssentialN = 0;
1685    for (int dim = 0; dim < N; ++dim) {
1686      if (!Clusterer->ParamDesc[dim].NonEssential) {
1687        Delta[dim] = Left->Mean[dim] - Right->Mean[dim];
1688        ++EssentialN;
1689      } else {
1690        Delta[dim] = 0.0f;
1691      }
1692    }
1693    double Tsq = 0.0;
1694    for (int x = 0; x < N; ++x) {
1695      double temp = 0.0;
1696      for (int y = 0; y < N; ++y) {
1697        temp += static_cast<double>(Inverse[y + N * x]) * Delta[y];
1698      }
1699      Tsq += Delta[x] * temp;
1700    }
1701    double F = Tsq * (TotalDims - EssentialN - 1) / ((TotalDims - 2) * EssentialN);
1702    int Fx = EssentialN;
1703    if (Fx > FTABLE_X) {
1704      Fx = FTABLE_X;
1705    }
1706    --Fx;
1707    int Fy = TotalDims - EssentialN - 1;
1708    if (Fy > FTABLE_Y) {
1709      Fy = FTABLE_Y;
1710    }
1711    --Fy;
1712    double FTarget = FTable[Fy][Fx];
1713    if (Config->MagicSamples > 0 && TotalDims >= Config->MagicSamples * (1.0 - kMagicSampleMargin) &&
1714        TotalDims <= Config->MagicSamples * (1.0 + kMagicSampleMargin)) {
1715      FTarget += kFTableBoostMargin;
1716    }
1717    if (F < FTarget) {
1718      return NewEllipticalProto(Clusterer->SampleSize, Cluster, Statistics);
1719    }
1720    return nullptr;
1721  }
1722  static PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1723                                       BUCKETS *Buckets) {
1724    PROTOTYPE *Proto = nullptr;
1725    int i;
1726    for (i = 0; i < Clusterer->SampleSize; i++) {
1727      if (Clusterer->ParamDesc[i].NonEssential) {
1728        continue;
1729      }
1730      FillBuckets(Buckets, Cluster, i, &(Clusterer->ParamDesc[i]), Cluster->Mean[i],
1731                  sqrt(static_cast<double>(Statistics->AvgVariance)));
1732      if (!DistributionOK(Buckets)) {
1733        break;
1734      }
1735    }
1736    if (i >= Clusterer->SampleSize) {
1737      Proto = NewSphericalProto(Clusterer->SampleSize, Cluster, Statistics);
1738    }
1739    return (Proto);
1740  } 
1741  static PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer, CLUSTER *Cluster,
1742                                        STATISTICS *Statistics, BUCKETS *Buckets) {
1743    PROTOTYPE *Proto = nullptr;
1744    int i;
1745    for (i = 0; i < Clusterer->SampleSize; i++) {
1746      if (Clusterer->ParamDesc[i].NonEssential) {
1747        continue;
1748      }
1749      FillBuckets(Buckets, Cluster, i, &(Clusterer->ParamDesc[i]), Cluster->Mean[i],
1750                  sqrt(static_cast<double>(Statistics->CoVariance[i * (Clusterer->SampleSize + 1)])));
1751      if (!DistributionOK(Buckets)) {
1752        break;
1753      }
1754    }
1755    if (i >= Clusterer->SampleSize) {
1756      Proto = NewEllipticalProto(Clusterer->SampleSize, Cluster, Statistics);
1757    }
1758    return (Proto);
1759  } 
1760  static PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1761                                   BUCKETS *NormalBuckets, double Confidence) {
1762    PROTOTYPE *Proto;
1763    int i;
1764    BUCKETS *UniformBuckets = nullptr;
1765    BUCKETS *RandomBuckets = nullptr;
1766    Proto = NewMixedProto(Clusterer->SampleSize, Cluster, Statistics);
1767    for (i = 0; i < Clusterer->SampleSize; i++) {
1768      if (Clusterer->ParamDesc[i].NonEssential) {
1769        continue;
1770      }
1771      FillBuckets(NormalBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1772                  std::sqrt(Proto->Variance.Elliptical[i]));
1773      if (DistributionOK(NormalBuckets)) {
1774        continue;
1775      }
1776      if (RandomBuckets == nullptr) {
1777        RandomBuckets = GetBuckets(Clusterer, D_random, Cluster->SampleCount, Confidence);
1778      }
1779      MakeDimRandom(i, Proto, &(Clusterer->ParamDesc[i]));
1780      FillBuckets(RandomBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1781                  Proto->Variance.Elliptical[i]);
1782      if (DistributionOK(RandomBuckets)) {
1783        continue;
1784      }
1785      if (UniformBuckets == nullptr) {
1786        UniformBuckets = GetBuckets(Clusterer, uniform, Cluster->SampleCount, Confidence);
1787      }
1788      MakeDimUniform(i, Proto, Statistics);
1789      FillBuckets(UniformBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1790                  Proto->Variance.Elliptical[i]);
1791      if (DistributionOK(UniformBuckets)) {
1792        continue;
1793      }
1794      break;
1795    }
1796    if (i < Clusterer->SampleSize) {
1797      FreePrototype(Proto);
1798      Proto = nullptr;
1799    }
1800    return (Proto);
1801  } 
1802  static void MakeDimRandom(uint16_t i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc) {
1803    Proto->Distrib[i] = D_random;
1804    Proto->Mean[i] = ParamDesc->MidRange;
1805    Proto->Variance.Elliptical[i] = ParamDesc->HalfRange;
1806    Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
1807    Proto->Magnitude.Elliptical[i] = 1.0 / ParamDesc->Range;
1808    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1809    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1810  } 
1811  static void MakeDimUniform(uint16_t i, PROTOTYPE *Proto, STATISTICS *Statistics) {
1812    Proto->Distrib[i] = uniform;
1813    Proto->Mean[i] = Proto->Cluster->Mean[i] + (Statistics->Min[i] + Statistics->Max[i]) / 2;
1814    Proto->Variance.Elliptical[i] = (Statistics->Max[i] - Statistics->Min[i]) / 2;
1815    if (Proto->Variance.Elliptical[i] < MINVARIANCE) {
1816      Proto->Variance.Elliptical[i] = MINVARIANCE;
1817    }
1818    Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
1819    Proto->Magnitude.Elliptical[i] = 1.0 / (2.0 * Proto->Variance.Elliptical[i]);
1820    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1821    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1822  } 
1823  static STATISTICS *ComputeStatistics(int16_t N, PARAM_DESC ParamDesc[], CLUSTER *Cluster) {
1824    int i, j;
1825    LIST SearchState;
1826    SAMPLE *Sample;
1827    uint32_t SampleCountAdjustedForBias;
1828    auto Statistics = new STATISTICS(N);
1829    std::vector<float> Distance(N);
1830    InitSampleSearch(SearchState, Cluster);
1831    while ((Sample = NextSample(&SearchState)) != nullptr) {
1832      for (i = 0; i < N; i++) {
1833        Distance[i] = Sample->Mean[i] - Cluster->Mean[i];
1834        if (ParamDesc[i].Circular) {
1835          if (Distance[i] > ParamDesc[i].HalfRange) {
1836            Distance[i] -= ParamDesc[i].Range;
1837          }
1838          if (Distance[i] < -ParamDesc[i].HalfRange) {
1839            Distance[i] += ParamDesc[i].Range;
1840          }
1841        }
1842        if (Distance[i] < Statistics->Min[i]) {
1843          Statistics->Min[i] = Distance[i];
1844        }
1845        if (Distance[i] > Statistics->Max[i]) {
1846          Statistics->Max[i] = Distance[i];
1847        }
1848      }
1849      auto CoVariance = &Statistics->CoVariance[0];
1850      for (i = 0; i < N; i++) {
1851        for (j = 0; j < N; j++, CoVariance++) {
1852          *CoVariance += Distance[i] * Distance[j];
1853        }
1854      }
1855    }
1856    if (Cluster->SampleCount > 1) {
1857      SampleCountAdjustedForBias = Cluster->SampleCount - 1;
1858    } else {
1859      SampleCountAdjustedForBias = 1;
1860    }
1861    auto CoVariance = &Statistics->CoVariance[0];
1862    for (i = 0; i < N; i++) {
1863      for (j = 0; j < N; j++, CoVariance++) {
1864        *CoVariance /= SampleCountAdjustedForBias;
1865        if (j == i) {
1866          if (*CoVariance < MINVARIANCE) {
1867            *CoVariance = MINVARIANCE;
1868          }
1869          Statistics->AvgVariance *= *CoVariance;
1870        }
1871      }
1872    }
1873    Statistics->AvgVariance =
1874        static_cast<float>(pow(static_cast<double>(Statistics->AvgVariance), 1.0 / N));
1875    return Statistics;
1876  } 
1877  static PROTOTYPE *NewSphericalProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1878    PROTOTYPE *Proto;
1879    Proto = NewSimpleProto(N, Cluster);
1880    Proto->Variance.Spherical = Statistics->AvgVariance;
1881    if (Proto->Variance.Spherical < MINVARIANCE) {
1882      Proto->Variance.Spherical = MINVARIANCE;
1883    }
1884    Proto->Magnitude.Spherical = 1.0 / sqrt(2.0 * M_PI * Proto->Variance.Spherical);
1885    Proto->TotalMagnitude = static_cast<float>(
1886        pow(static_cast<double>(Proto->Magnitude.Spherical), static_cast<double>(N)));
1887    Proto->Weight.Spherical = 1.0 / Proto->Variance.Spherical;
1888    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1889    return (Proto);
1890  } 
1891  static PROTOTYPE *NewEllipticalProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1892    PROTOTYPE *Proto;
1893    int i;
1894    Proto = NewSimpleProto(N, Cluster);
1895    Proto->Variance.Elliptical = new float[N];
1896    Proto->Magnitude.Elliptical = new float[N];
1897    Proto->Weight.Elliptical = new float[N];
1898    auto CoVariance = &Statistics->CoVariance[0];
1899    Proto->TotalMagnitude = 1.0;
1900    for (i = 0; i < N; i++, CoVariance += N + 1) {
1901      Proto->Variance.Elliptical[i] = *CoVariance;
1902      if (Proto->Variance.Elliptical[i] < MINVARIANCE) {
1903        Proto->Variance.Elliptical[i] = MINVARIANCE;
1904      }
1905      Proto->Magnitude.Elliptical[i] = 1.0f / sqrt(2.0f * M_PI * Proto->Variance.Elliptical[i]);
1906      Proto->Weight.Elliptical[i] = 1.0f / Proto->Variance.Elliptical[i];
1907      Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1908    }
1909    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1910    Proto->Style = elliptical;
1911    return (Proto);
1912  } 
1913  static PROTOTYPE *NewMixedProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1914    auto Proto = NewEllipticalProto(N, Cluster, Statistics);
1915    Proto->Distrib.clear();
1916    Proto->Distrib.resize(N, normal);
1917    Proto->Style = mixed;
1918    return Proto;
1919  } 
1920  static PROTOTYPE *NewSimpleProto(int16_t N, CLUSTER *Cluster) {
1921    auto Proto = new PROTOTYPE;
1922    Proto->Mean = Cluster->Mean;
1923    Proto->Distrib.clear();
1924    Proto->Significant = true;
1925    Proto->Merged = false;
1926    Proto->Style = spherical;
1927    Proto->NumSamples = Cluster->SampleCount;
1928    Proto->Cluster = Cluster;
1929    Proto->Cluster->Prototype = true;
1930    return Proto;
1931  } 
1932  static bool Independent(PARAM_DESC *ParamDesc, int16_t N, float *CoVariance, float Independence) {
1933    int i, j;
1934    float *VARii; 
1935    float *VARjj; 
1936    float CorrelationCoeff;
1937    VARii = CoVariance;
1938    for (i = 0; i < N; i++, VARii += N + 1) {
1939      if (ParamDesc[i].NonEssential) {
1940        continue;
1941      }
1942      VARjj = VARii + N + 1;
1943      CoVariance = VARii + 1;
1944      for (j = i + 1; j < N; j++, CoVariance++, VARjj += N + 1) {
1945        if (ParamDesc[j].NonEssential) {
1946          continue;
1947        }
1948        if ((*VARii == 0.0) || (*VARjj == 0.0)) {
1949          CorrelationCoeff = 0.0;
1950        } else {
1951          CorrelationCoeff = sqrt(std::sqrt(*CoVariance * *CoVariance / (*VARii * *VARjj)));
1952        }
1953        if (CorrelationCoeff > Independence) {
1954          return false;
1955        }
1956      }
1957    }
1958    return true;
1959  } 
1960  static BUCKETS *GetBuckets(CLUSTERER *clusterer, DISTRIBUTION Distribution, uint32_t SampleCount,
1961                             double Confidence) {
1962    uint16_t NumberOfBuckets = OptimumNumberOfBuckets(SampleCount);
1963    BUCKETS *Buckets = clusterer->bucket_cache[Distribution][NumberOfBuckets - MINBUCKETS];
1964    if (Buckets == nullptr) {
1965      Buckets = MakeBuckets(Distribution, SampleCount, Confidence);
1966      clusterer->bucket_cache[Distribution][NumberOfBuckets - MINBUCKETS] = Buckets;
1967    } else {
1968      if (SampleCount != Buckets->SampleCount) {
1969        AdjustBuckets(Buckets, SampleCount);
1970      }
1971      if (Confidence != Buckets->Confidence) {
1972        Buckets->Confidence = Confidence;
1973        Buckets->ChiSquared =
1974            ComputeChiSquared(DegreesOfFreedom(Distribution, Buckets->NumberOfBuckets), Confidence);
1975      }
1976      InitBuckets(Buckets);
1977    }
1978    return Buckets;
1979  } 
1980  static BUCKETS *MakeBuckets(DISTRIBUTION Distribution, uint32_t SampleCount, double Confidence) {
1981    const DENSITYFUNC DensityFunction[] = {NormalDensity, UniformDensity, UniformDensity};
1982    int i, j;
1983    double BucketProbability;
1984    double NextBucketBoundary;
1985    double Probability;
1986    double ProbabilityDelta;
1987    double LastProbDensity;
1988    double ProbDensity;
1989    uint16_t CurrentBucket;
1990    bool Symmetrical;
1991    auto Buckets = new BUCKETS(OptimumNumberOfBuckets(SampleCount));
1992    Buckets->SampleCount = SampleCount;
1993    Buckets->Confidence = Confidence;
1994    Buckets->Distribution = Distribution;
1995    Symmetrical = true;
1996    Buckets->ChiSquared =
1997        ComputeChiSquared(DegreesOfFreedom(Distribution, Buckets->NumberOfBuckets), Confidence);
1998    if (Symmetrical) {
1999      BucketProbability = 1.0 / static_cast<double>(Buckets->NumberOfBuckets);
2000      CurrentBucket = Buckets->NumberOfBuckets / 2;
2001      if (Odd(Buckets->NumberOfBuckets)) {
2002        NextBucketBoundary = BucketProbability / 2;
2003      } else {
2004        NextBucketBoundary = BucketProbability;
2005      }
2006      Probability = 0.0;
2007      LastProbDensity = (*DensityFunction[static_cast<int>(Distribution)])(BUCKETTABLESIZE / 2);
2008      for (i = BUCKETTABLESIZE / 2; i < BUCKETTABLESIZE; i++) {
2009        ProbDensity = (*DensityFunction[static_cast<int>(Distribution)])(i + 1);
2010        ProbabilityDelta = Integral(LastProbDensity, ProbDensity, 1.0);
2011        Probability += ProbabilityDelta;
2012        if (Probability > NextBucketBoundary) {
2013          if (CurrentBucket < Buckets->NumberOfBuckets - 1) {
2014            CurrentBucket++;
2015          }
2016          NextBucketBoundary += BucketProbability;
2017        }
2018        Buckets->Bucket[i] = CurrentBucket;
2019        Buckets->ExpectedCount[CurrentBucket] += static_cast<float>(ProbabilityDelta * SampleCount);
2020        LastProbDensity = ProbDensity;
2021      }
2022      Buckets->ExpectedCount[CurrentBucket] += static_cast<float>((0.5 - Probability) * SampleCount);
2023      for (i = 0, j = BUCKETTABLESIZE - 1; i < j; i++, j--) {
2024        Buckets->Bucket[i] = Mirror(Buckets->Bucket[j], Buckets->NumberOfBuckets);
2025      }
2026      for (i = 0, j = Buckets->NumberOfBuckets - 1; i <= j; i++, j--) {
2027        Buckets->ExpectedCount[i] += Buckets->ExpectedCount[j];
2028      }
2029    }
2030    return Buckets;
2031  } 
2032  static uint16_t OptimumNumberOfBuckets(uint32_t SampleCount) {
2033    uint8_t Last, Next;
2034    float Slope;
2035    if (SampleCount < kCountTable[0]) {
2036      return kBucketsTable[0];
2037    }
2038    for (Last = 0, Next = 1; Next < LOOKUPTABLESIZE; Last++, Next++) {
2039      if (SampleCount <= kCountTable[Next]) {
2040        Slope = static_cast<float>(kBucketsTable[Next] - kBucketsTable[Last]) /
2041                static_cast<float>(kCountTable[Next] - kCountTable[Last]);
2042        return (
2043            static_cast<uint16_t>(kBucketsTable[Last] + Slope * (SampleCount - kCountTable[Last])));
2044      }
2045    }
2046    return kBucketsTable[Last];
2047  } 
2048  static double ComputeChiSquared(uint16_t DegreesOfFreedom, double Alpha)
2049  #define CHIACCURACY 0.01
2050  #define MINALPHA (1e-200)
2051  {
2052    static LIST ChiWith[MAXDEGREESOFFREEDOM + 1];
2053    Alpha = ClipToRange(Alpha, MINALPHA, 1.0);
2054    if (Odd(DegreesOfFreedom)) {
2055      DegreesOfFreedom++;
2056    }
2057    CHISTRUCT SearchKey(0.0, Alpha);
2058    auto *found = search(ChiWith[DegreesOfFreedom], &SearchKey, AlphaMatch);
2059    auto OldChiSquared = reinterpret_cast<CHISTRUCT *>(found ? found->first_node() : nullptr);
2060    if (OldChiSquared == nullptr) {
2061      OldChiSquared = new CHISTRUCT(DegreesOfFreedom, Alpha);
2062      OldChiSquared->ChiSquared =
2063          Solve(ChiArea, OldChiSquared, static_cast<double>(DegreesOfFreedom), CHIACCURACY);
2064      ChiWith[DegreesOfFreedom] = push(ChiWith[DegreesOfFreedom], OldChiSquared);
2065    } else {
2066    }
2067    return (OldChiSquared->ChiSquared);
2068  } 
2069  static double NormalDensity(int32_t x) {
2070    double Distance;
2071    Distance = x - kNormalMean;
2072    return kNormalMagnitude * exp(-0.5 * Distance * Distance / kNormalVariance);
2073  } 
2074  static double UniformDensity(int32_t x) {
2075    constexpr auto UniformDistributionDensity = 1.0 / BUCKETTABLESIZE;
2076    if ((x >= 0) && (x <= BUCKETTABLESIZE)) {
2077      return UniformDistributionDensity;
2078    } else {
2079      return 0.0;
2080    }
2081  } 
2082  static double Integral(double f1, double f2, double Dx) {
2083    return (f1 + f2) * Dx / 2.0;
2084  } 
2085  static void FillBuckets(BUCKETS *Buckets, CLUSTER *Cluster, uint16_t Dim, PARAM_DESC *ParamDesc,
2086                          float Mean, float StdDev) {
2087    uint16_t BucketID;
2088    int i;
2089    LIST SearchState;
2090    SAMPLE *Sample;
2091    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2092      Buckets->Count[i] = 0;
2093    }
2094    if (StdDev == 0.0) {
2095      InitSampleSearch(SearchState, Cluster);
2096      i = 0;
2097      while ((Sample = NextSample(&SearchState)) != nullptr) {
2098        if (Sample->Mean[Dim] > Mean) {
2099          BucketID = Buckets->NumberOfBuckets - 1;
2100        } else if (Sample->Mean[Dim] < Mean) {
2101          BucketID = 0;
2102        } else {
2103          BucketID = i;
2104        }
2105        Buckets->Count[BucketID] += 1;
2106        i++;
2107        if (i >= Buckets->NumberOfBuckets) {
2108          i = 0;
2109        }
2110      }
2111    } else {
2112      InitSampleSearch(SearchState, Cluster);
2113      while ((Sample = NextSample(&SearchState)) != nullptr) {
2114        switch (Buckets->Distribution) {
2115          case normal:
2116            BucketID = NormalBucket(ParamDesc, Sample->Mean[Dim], Mean, StdDev);
2117            break;
2118          case D_random:
2119          case uniform:
2120            BucketID = UniformBucket(ParamDesc, Sample->Mean[Dim], Mean, StdDev);
2121            break;
2122          default:
2123            BucketID = 0;
2124        }
2125        Buckets->Count[Buckets->Bucket[BucketID]] += 1;
2126      }
2127    }
2128  } 
2129  static uint16_t NormalBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev) {
2130    float X;
2131    if (ParamDesc->Circular) {
2132      if (x - Mean > ParamDesc->HalfRange) {
2133        x -= ParamDesc->Range;
2134      } else if (x - Mean < -ParamDesc->HalfRange) {
2135        x += ParamDesc->Range;
2136      }
2137    }
2138    X = ((x - Mean) / StdDev) * kNormalStdDev + kNormalMean;
2139    if (X < 0) {
2140      return 0;
2141    }
2142    if (X > BUCKETTABLESIZE - 1) {
2143      return (static_cast<uint16_t>(BUCKETTABLESIZE - 1));
2144    }
2145    return static_cast<uint16_t>(floor(static_cast<double>(X)));
2146  } 
2147  static uint16_t UniformBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev) {
2148    float X;
2149    if (ParamDesc->Circular) {
2150      if (x - Mean > ParamDesc->HalfRange) {
2151        x -= ParamDesc->Range;
2152      } else if (x - Mean < -ParamDesc->HalfRange) {
2153        x += ParamDesc->Range;
2154      }
2155    }
2156    X = ((x - Mean) / (2 * StdDev) * BUCKETTABLESIZE + BUCKETTABLESIZE / 2.0);
2157    if (X < 0) {
2158      return 0;
2159    }
2160    if (X > BUCKETTABLESIZE - 1) {
2161      return static_cast<uint16_t>(BUCKETTABLESIZE - 1);
2162    }
2163    return static_cast<uint16_t>(floor(static_cast<double>(X)));
2164  } 
2165  static bool DistributionOK(BUCKETS *Buckets) {
2166    float FrequencyDifference;
2167    float TotalDifference;
2168    int i;
2169    TotalDifference = 0.0;
2170    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2171      FrequencyDifference = Buckets->Count[i] - Buckets->ExpectedCount[i];
2172      TotalDifference += (FrequencyDifference * FrequencyDifference) / Buckets->ExpectedCount[i];
2173    }
2174    if (TotalDifference > Buckets->ChiSquared) {
2175      return false;
2176    } else {
2177      return true;
2178    }
2179  } 
2180  static uint16_t DegreesOfFreedom(DISTRIBUTION Distribution, uint16_t HistogramBuckets) {
2181    static uint8_t DegreeOffsets[] = {3, 3, 1};
2182    uint16_t AdjustedNumBuckets;
2183    AdjustedNumBuckets = HistogramBuckets - DegreeOffsets[static_cast<int>(Distribution)];
2184    if (Odd(AdjustedNumBuckets)) {
2185      AdjustedNumBuckets++;
2186    }
2187    return (AdjustedNumBuckets);
2188  } 
2189  static void AdjustBuckets(BUCKETS *Buckets, uint32_t NewSampleCount) {
2190    int i;
2191    double AdjustFactor;
2192    AdjustFactor =
2193        ((static_cast<double>(NewSampleCount)) / (static_cast<double>(Buckets->SampleCount)));
2194    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2195      Buckets->ExpectedCount[i] *= AdjustFactor;
2196    }
2197    Buckets->SampleCount = NewSampleCount;
2198  } 
2199  static void InitBuckets(BUCKETS *Buckets) {
2200    int i;
2201    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2202      Buckets->Count[i] = 0;
2203    }
2204  } 
2205  static int AlphaMatch(void *arg1,   
2206                        void *arg2) { 
2207    auto *ChiStruct = static_cast<CHISTRUCT *>(arg1);
2208    auto *SearchKey = static_cast<CHISTRUCT *>(arg2);
2209    return (ChiStruct->Alpha == SearchKey->Alpha);
2210  } 
2211  static double Solve(SOLVEFUNC Function, void *FunctionParams, double InitialGuess, double Accuracy)
2212  #define INITIALDELTA 0.1
2213  #define DELTARATIO 0.1
2214  {
2215    double x;
2216    double f;
2217    double Slope;
2218    double Delta;
2219    double NewDelta;
2220    double xDelta;
2221    double LastPosX, LastNegX;
2222    x = InitialGuess;
2223    Delta = INITIALDELTA;
2224    LastPosX = FLT_MAX;
2225    LastNegX = -FLT_MAX;
2226    f = (*Function)(static_cast<CHISTRUCT *>(FunctionParams), x);
2227    while (Abs(LastPosX - LastNegX) > Accuracy) {
2228      if (f < 0) {
2229        LastNegX = x;
2230      } else {
2231        LastPosX = x;
2232      }
2233      Slope = ((*Function)(static_cast<CHISTRUCT *>(FunctionParams), x + Delta) - f) / Delta;
2234      xDelta = f / Slope;
2235      x -= xDelta;
2236      NewDelta = Abs(xDelta) * DELTARATIO;
2237      if (NewDelta < Delta) {
2238        Delta = NewDelta;
2239      }
2240      f = (*Function)(static_cast<CHISTRUCT *>(FunctionParams), x);
2241    }
2242    return (x);
2243  } 
2244  static double ChiArea(CHISTRUCT *ChiParams, double x) {
2245    int i, N;
2246    double SeriesTotal;
2247    double Denominator;
2248    double PowerOfx;
2249    N = ChiParams->DegreesOfFreedom / 2 - 1;
2250    SeriesTotal = 1;
2251    Denominator = 1;
2252    PowerOfx = 1;
2253    for (i = 1; i <= N; i++) {
2254      Denominator *= 2 * i;
2255      PowerOfx *= x;
2256      SeriesTotal += PowerOfx / Denominator;
2257    }
2258    return ((SeriesTotal * exp(-0.5 * x)) - ChiParams->Alpha);
2259  } 
2260  static bool MultipleCharSamples(CLUSTERER *Clusterer, CLUSTER *Cluster, float MaxIllegal)
2261  #define ILLEGAL_CHAR 2
2262  {
2263    static std::vector<uint8_t> CharFlags;
2264    LIST SearchState;
2265    SAMPLE *Sample;
2266    int32_t CharID;
2267    int32_t NumCharInCluster;
2268    int32_t NumIllegalInCluster;
2269    float PercentIllegal;
2270    NumCharInCluster = Cluster->SampleCount;
2271    NumIllegalInCluster = 0;
2272    if (Clusterer->NumChar > CharFlags.size()) {
2273      CharFlags.resize(Clusterer->NumChar);
2274    }
2275    for (auto &CharFlag : CharFlags) {
2276      CharFlag = false;
2277    }
2278    InitSampleSearch(SearchState, Cluster);
2279    while ((Sample = NextSample(&SearchState)) != nullptr) {
2280      CharID = Sample->CharID;
2281      if (CharFlags[CharID] == false) {
2282        CharFlags[CharID] = true;
2283      } else {
2284        if (CharFlags[CharID] == true) {
2285          NumIllegalInCluster++;
2286          CharFlags[CharID] = ILLEGAL_CHAR;
2287        }
2288        NumCharInCluster--;
2289        PercentIllegal = static_cast<float>(NumIllegalInCluster) / NumCharInCluster;
2290        if (PercentIllegal > MaxIllegal) {
2291          destroy(SearchState);
2292          return true;
2293        }
2294      }
2295    }
2296    return false;
2297  } 
2298  static double InvertMatrix(const float *input, int size, float *inv) {
2299    GENERIC_2D_ARRAY<double> U(size, size, 0.0);
2300    GENERIC_2D_ARRAY<double> U_inv(size, size, 0.0);
2301    GENERIC_2D_ARRAY<double> L(size, size, 0.0);
2302    int row;
2303    int col;
2304    for (row = 0; row < size; row++) {
2305      for (col = 0; col < size; col++) {
2306        U[row][col] = input[row * size + col];
2307        L[row][col] = row == col ? 1.0 : 0.0;
2308        U_inv[row][col] = 0.0;
2309      }
2310    }
2311    for (col = 0; col < size; ++col) {
2312      int best_row = 0;
2313      double best_pivot = -1.0;
2314      for (row = col; row < size; ++row) {
2315        if (Abs(U[row][col]) > best_pivot) {
2316          best_pivot = Abs(U[row][col]);
2317          best_row = row;
2318        }
2319      }
2320      if (best_row != col) {
2321        for (int k = 0; k < size; ++k) {
2322          double tmp = U[best_row][k];
2323          U[best_row][k] = U[col][k];
2324          U[col][k] = tmp;
2325          tmp = L[best_row][k];
2326          L[best_row][k] = L[col][k];
2327          L[col][k] = tmp;
2328        }
2329      }
2330      for (row = col + 1; row < size; ++row) {
2331        double ratio = -U[row][col] / U[col][col];
2332        for (int j = col; j < size; ++j) {
2333          U[row][j] += U[col][j] * ratio;
2334        }
2335        for (int k = 0; k < size; ++k) {
2336          L[row][k] += L[col][k] * ratio;
2337        }
2338      }
2339    }
2340    for (col = 0; col < size; ++col) {
2341      U_inv[col][col] = 1.0 / U[col][col];
2342      for (row = col - 1; row >= 0; --row) {
2343        double total = 0.0;
2344        for (int k = col; k > row; --k) {
2345          total += U[row][k] * U_inv[k][col];
2346        }
2347        U_inv[row][col] = -total / U[row][row];
2348      }
2349    }
2350    for (row = 0; row < size; row++) {
2351      for (col = 0; col < size; col++) {
2352        double sum = 0.0;
2353        for (int k = row; k < size; ++k) {
2354          sum += U_inv[row][k] * L[k][col];
2355        }
2356        inv[row * size + col] = sum;
2357      }
2358    }
2359    double error_sum = 0.0;
2360    for (row = 0; row < size; row++) {
2361      for (col = 0; col < size; col++) {
2362        double sum = 0.0;
2363        for (int k = 0; k < size; ++k) {
2364          sum += static_cast<double>(input[row * size + k]) * inv[k * size + col];
2365        }
2366        if (row != col) {
2367          error_sum += Abs(sum);
2368        }
2369      }
2370    }
2371    return error_sum;
2372  }
2373  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cluster.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #include "cluster.h"
3  #include "genericheap.h"
4  #include "kdpair.h"
5  #include "matrix.h"
6  #include "tprintf.h"
7  #include "helpers.h"
8  #include <cfloat> 
9  #include <cmath>  
10  #include <vector> 
11  namespace tesseract {
12  #define HOTELLING 1  
13  #define FTABLE_X 10  
14  #define FTABLE_Y 100 
15  const double FTable[FTABLE_Y][FTABLE_X] = {
16      {
17          4052.19,
18          4999.52,
19          5403.34,
20          5624.62,
21          5763.65,
22          5858.97,
23          5928.33,
24          5981.10,
25          6022.50,
26          6055.85,
27      },
28      {
29          98.502,
30          99.000,
31          99.166,
32          99.249,
33          99.300,
34          99.333,
35          99.356,
36          99.374,
37          99.388,
38          99.399,
39      },
40      {
41          34.116,
42          30.816,
43          29.457,
44          28.710,
45          28.237,
46          27.911,
47          27.672,
48          27.489,
49          27.345,
50          27.229,
51      },
52      {
53          21.198,
54          18.000,
55          16.694,
56          15.977,
57          15.522,
58          15.207,
59          14.976,
60          14.799,
61          14.659,
62          14.546,
63      },
64      {
65          16.258,
66          13.274,
67          12.060,
68          11.392,
69          10.967,
70          10.672,
71          10.456,
72          10.289,
73          10.158,
74          10.051,
75      },
76      {
77          13.745,
78          10.925,
79          9.780,
80          9.148,
81          8.746,
82          8.466,
83          8.260,
84          8.102,
85          7.976,
86          7.874,
87      },
88      {
89          12.246,
90          9.547,
91          8.451,
92          7.847,
93          7.460,
94          7.191,
95          6.993,
96          6.840,
97          6.719,
98          6.620,
99      },
100      {
101          11.259,
102          8.649,
103          7.591,
104          7.006,
105          6.632,
106          6.371,
107          6.178,
108          6.029,
109          5.911,
110          5.814,
111      },
112      {
113          10.561,
114          8.022,
115          6.992,
116          6.422,
117          6.057,
118          5.802,
119          5.613,
120          5.467,
121          5.351,
122          5.257,
123      },
124      {
125          10.044,
126          7.559,
127          6.552,
128          5.994,
129          5.636,
130          5.386,
131          5.200,
132          5.057,
133          4.942,
134          4.849,
135      },
136      {
137          9.646,
138          7.206,
139          6.217,
140          5.668,
141          5.316,
142          5.069,
143          4.886,
144          4.744,
145          4.632,
146          4.539,
147      },
148      {
149          9.330,
150          6.927,
151          5.953,
152          5.412,
153          5.064,
154          4.821,
155          4.640,
156          4.499,
157          4.388,
158          4.296,
159      },
160      {
161          9.074,
162          6.701,
163          5.739,
164          5.205,
165          4.862,
166          4.620,
167          4.441,
168          4.302,
169          4.191,
170          4.100,
171      },
172      {
173          8.862,
174          6.515,
175          5.564,
176          5.035,
177          4.695,
178          4.456,
179          4.278,
180          4.140,
181          4.030,
182          3.939,
183      },
184      {
185          8.683,
186          6.359,
187          5.417,
188          4.893,
189          4.556,
190          4.318,
191          4.142,
192          4.004,
193          3.895,
194          3.805,
195      },
196      {
197          8.531,
198          6.226,
199          5.292,
200          4.773,
201          4.437,
202          4.202,
203          4.026,
204          3.890,
205          3.780,
206          3.691,
207      },
208      {
209          8.400,
210          6.112,
211          5.185,
212          4.669,
213          4.336,
214          4.102,
215          3.927,
216          3.791,
217          3.682,
218          3.593,
219      },
220      {
221          8.285,
222          6.013,
223          5.092,
224          4.579,
225          4.248,
226          4.015,
227          3.841,
228          3.705,
229          3.597,
230          3.508,
231      },
232      {
233          8.185,
234          5.926,
235          5.010,
236          4.500,
237          4.171,
238          3.939,
239          3.765,
240          3.631,
241          3.523,
242          3.434,
243      },
244      {
245          8.096,
246          5.849,
247          4.938,
248          4.431,
249          4.103,
250          3.871,
251          3.699,
252          3.564,
253          3.457,
254          3.368,
255      },
256      {
257          8.017,
258          5.780,
259          4.874,
260          4.369,
261          4.042,
262          3.812,
263          3.640,
264          3.506,
265          3.398,
266          3.310,
267      },
268      {
269          7.945,
270          5.719,
271          4.817,
272          4.313,
273          3.988,
274          3.758,
275          3.587,
276          3.453,
277          3.346,
278          3.258,
279      },
280      {
281          7.881,
282          5.664,
283          4.765,
284          4.264,
285          3.939,
286          3.710,
287          3.539,
288          3.406,
289          3.299,
290          3.211,
291      },
292      {
293          7.823,
294          5.614,
295          4.718,
296          4.218,
297          3.895,
298          3.667,
299          3.496,
300          3.363,
301          3.256,
302          3.168,
303      },
304      {
305          7.770,
306          5.568,
307          4.675,
308          4.177,
309          3.855,
310          3.627,
311          3.457,
312          3.324,
313          3.217,
314          3.129,
315      },
316      {
317          7.721,
318          5.526,
319          4.637,
320          4.140,
321          3.818,
322          3.591,
323          3.421,
324          3.288,
325          3.182,
326          3.094,
327      },
328      {
329          7.677,
330          5.488,
331          4.601,
332          4.106,
333          3.785,
334          3.558,
335          3.388,
336          3.256,
337          3.149,
338          3.062,
339      },
340      {
341          7.636,
342          5.453,
343          4.568,
344          4.074,
345          3.754,
346          3.528,
347          3.358,
348          3.226,
349          3.120,
350          3.032,
351      },
352      {
353          7.598,
354          5.420,
355          4.538,
356          4.045,
357          3.725,
358          3.499,
359          3.330,
360          3.198,
361          3.092,
362          3.005,
363      },
364      {
365          7.562,
366          5.390,
367          4.510,
368          4.018,
369          3.699,
370          3.473,
371          3.305,
372          3.173,
373          3.067,
374          2.979,
375      },
376      {
377          7.530,
378          5.362,
379          4.484,
380          3.993,
381          3.675,
382          3.449,
383          3.281,
384          3.149,
385          3.043,
386          2.955,
387      },
388      {
389          7.499,
390          5.336,
391          4.459,
392          3.969,
393          3.652,
394          3.427,
395          3.258,
396          3.127,
397          3.021,
398          2.934,
399      },
400      {
401          7.471,
402          5.312,
403          4.437,
404          3.948,
405          3.630,
406          3.406,
407          3.238,
408          3.106,
409          3.000,
410          2.913,
411      },
412      {
413          7.444,
414          5.289,
415          4.416,
416          3.927,
417          3.611,
418          3.386,
419          3.218,
420          3.087,
421          2.981,
422          2.894,
423      },
424      {
425          7.419,
426          5.268,
427          4.396,
428          3.908,
429          3.592,
430          3.368,
431          3.200,
432          3.069,
433          2.963,
434          2.876,
435      },
436      {
437          7.396,
438          5.248,
439          4.377,
440          3.890,
441          3.574,
442          3.351,
443          3.183,
444          3.052,
445          2.946,
446          2.859,
447      },
448      {
449          7.373,
450          5.229,
451          4.360,
452          3.873,
453          3.558,
454          3.334,
455          3.167,
456          3.036,
457          2.930,
458          2.843,
459      },
460      {
461          7.353,
462          5.211,
463          4.343,
464          3.858,
465          3.542,
466          3.319,
467          3.152,
468          3.021,
469          2.915,
470          2.828,
471      },
472      {
473          7.333,
474          5.194,
475          4.327,
476          3.843,
477          3.528,
478          3.305,
479          3.137,
480          3.006,
481          2.901,
482          2.814,
483      },
484      {
485          7.314,
486          5.179,
487          4.313,
488          3.828,
489          3.514,
490          3.291,
491          3.124,
492          2.993,
493          2.888,
494          2.801,
495      },
496      {
497          7.296,
498          5.163,
499          4.299,
500          3.815,
501          3.501,
502          3.278,
503          3.111,
504          2.980,
505          2.875,
506          2.788,
507      },
508      {
509          7.280,
510          5.149,
511          4.285,
512          3.802,
513          3.488,
514          3.266,
515          3.099,
516          2.968,
517          2.863,
518          2.776,
519      },
520      {
521          7.264,
522          5.136,
523          4.273,
524          3.790,
525          3.476,
526          3.254,
527          3.087,
528          2.957,
529          2.851,
530          2.764,
531      },
532      {
533          7.248,
534          5.123,
535          4.261,
536          3.778,
537          3.465,
538          3.243,
539          3.076,
540          2.946,
541          2.840,
542          2.754,
543      },
544      {
545          7.234,
546          5.110,
547          4.249,
548          3.767,
549          3.454,
550          3.232,
551          3.066,
552          2.935,
553          2.830,
554          2.743,
555      },
556      {
557          7.220,
558          5.099,
559          4.238,
560          3.757,
561          3.444,
562          3.222,
563          3.056,
564          2.925,
565          2.820,
566          2.733,
567      },
568      {
569          7.207,
570          5.087,
571          4.228,
572          3.747,
573          3.434,
574          3.213,
575          3.046,
576          2.916,
577          2.811,
578          2.724,
579      },
580      {
581          7.194,
582          5.077,
583          4.218,
584          3.737,
585          3.425,
586          3.204,
587          3.037,
588          2.907,
589          2.802,
590          2.715,
591      },
592      {
593          7.182,
594          5.066,
595          4.208,
596          3.728,
597          3.416,
598          3.195,
599          3.028,
600          2.898,
601          2.793,
602          2.706,
603      },
604      {
605          7.171,
606          5.057,
607          4.199,
608          3.720,
609          3.408,
610          3.186,
611          3.020,
612          2.890,
613          2.785,
614          2.698,
615      },
616      {
617          7.159,
618          5.047,
619          4.191,
620          3.711,
621          3.400,
622          3.178,
623          3.012,
624          2.882,
625          2.777,
626          2.690,
627      },
628      {
629          7.149,
630          5.038,
631          4.182,
632          3.703,
633          3.392,
634          3.171,
635          3.005,
636          2.874,
637          2.769,
638          2.683,
639      },
640      {
641          7.139,
642          5.030,
643          4.174,
644          3.695,
645          3.384,
646          3.163,
647          2.997,
648          2.867,
649          2.762,
650          2.675,
651      },
652      {
653          7.129,
654          5.021,
655          4.167,
656          3.688,
657          3.377,
658          3.156,
659          2.990,
660          2.860,
661          2.755,
662          2.668,
663      },
664      {
665          7.119,
666          5.013,
667          4.159,
668          3.681,
669          3.370,
670          3.149,
671          2.983,
672          2.853,
673          2.748,
674          2.662,
675      },
676      {
677          7.110,
678          5.006,
679          4.152,
680          3.674,
681          3.363,
682          3.143,
683          2.977,
684          2.847,
685          2.742,
686          2.655,
687      },
688      {
689          7.102,
690          4.998,
691          4.145,
692          3.667,
693          3.357,
694          3.136,
695          2.971,
696          2.841,
697          2.736,
698          2.649,
699      },
700      {
701          7.093,
702          4.991,
703          4.138,
704          3.661,
705          3.351,
706          3.130,
707          2.965,
708          2.835,
709          2.730,
710          2.643,
711      },
712      {
713          7.085,
714          4.984,
715          4.132,
716          3.655,
717          3.345,
718          3.124,
719          2.959,
720          2.829,
721          2.724,
722          2.637,
723      },
724      {
725          7.077,
726          4.977,
727          4.126,
728          3.649,
729          3.339,
730          3.119,
731          2.953,
732          2.823,
733          2.718,
734          2.632,
735      },
736      {
737          7.070,
738          4.971,
739          4.120,
740          3.643,
741          3.333,
742          3.113,
743          2.948,
744          2.818,
745          2.713,
746          2.626,
747      },
748      {
749          7.062,
750          4.965,
751          4.114,
752          3.638,
753          3.328,
754          3.108,
755          2.942,
756          2.813,
757          2.708,
758          2.621,
759      },
760      {
761          7.055,
762          4.959,
763          4.109,
764          3.632,
765          3.323,
766          3.103,
767          2.937,
768          2.808,
769          2.703,
770          2.616,
771      },
772      {
773          7.048,
774          4.953,
775          4.103,
776          3.627,
777          3.318,
778          3.098,
779          2.932,
780          2.803,
781          2.698,
782          2.611,
783      },
784      {
785          7.042,
786          4.947,
787          4.098,
788          3.622,
789          3.313,
790          3.093,
791          2.928,
792          2.798,
793          2.693,
794          2.607,
795      },
796      {
797          7.035,
798          4.942,
799          4.093,
800          3.618,
801          3.308,
802          3.088,
803          2.923,
804          2.793,
805          2.689,
806          2.602,
807      },
808      {
809          7.029,
810          4.937,
811          4.088,
812          3.613,
813          3.304,
814          3.084,
815          2.919,
816          2.789,
817          2.684,
818          2.598,
819      },
820      {
821          7.023,
822          4.932,
823          4.083,
824          3.608,
825          3.299,
826          3.080,
827          2.914,
828          2.785,
829          2.680,
830          2.593,
831      },
832      {
833          7.017,
834          4.927,
835          4.079,
836          3.604,
837          3.295,
838          3.075,
839          2.910,
840          2.781,
841          2.676,
842          2.589,
843      },
844      {
845          7.011,
846          4.922,
847          4.074,
848          3.600,
849          3.291,
850          3.071,
851          2.906,
852          2.777,
853          2.672,
854          2.585,
855      },
856      {
857          7.006,
858          4.917,
859          4.070,
860          3.596,
861          3.287,
862          3.067,
863          2.902,
864          2.773,
865          2.668,
866          2.581,
867      },
868      {
869          7.001,
870          4.913,
871          4.066,
872          3.591,
873          3.283,
874          3.063,
875          2.898,
876          2.769,
877          2.664,
878          2.578,
879      },
880      {
881          6.995,
882          4.908,
883          4.062,
884          3.588,
885          3.279,
886          3.060,
887          2.895,
888          2.765,
889          2.660,
890          2.574,
891      },
892      {
893          6.990,
894          4.904,
895          4.058,
896          3.584,
897          3.275,
898          3.056,
899          2.891,
900          2.762,
901          2.657,
902          2.570,
903      },
904      {
905          6.985,
906          4.900,
907          4.054,
908          3.580,
909          3.272,
910          3.052,
911          2.887,
912          2.758,
913          2.653,
914          2.567,
915      },
916      {
917          6.981,
918          4.896,
919          4.050,
920          3.577,
921          3.268,
922          3.049,
923          2.884,
924          2.755,
925          2.650,
926          2.563,
927      },
928      {
929          6.976,
930          4.892,
931          4.047,
932          3.573,
933          3.265,
934          3.046,
935          2.881,
936          2.751,
937          2.647,
938          2.560,
939      },
940      {
941          6.971,
942          4.888,
943          4.043,
944          3.570,
945          3.261,
946          3.042,
947          2.877,
948          2.748,
949          2.644,
950          2.557,
951      },
952      {
953          6.967,
954          4.884,
955          4.040,
956          3.566,
957          3.258,
958          3.039,
959          2.874,
960          2.745,
961          2.640,
962          2.554,
963      },
964      {
965          6.963,
966          4.881,
967          4.036,
968          3.563,
969          3.255,
970          3.036,
971          2.871,
972          2.742,
973          2.637,
974          2.551,
975      },
976      {
977          6.958,
978          4.877,
979          4.033,
980          3.560,
981          3.252,
982          3.033,
983          2.868,
984          2.739,
985          2.634,
986          2.548,
987      },
988      {
989          6.954,
990          4.874,
991          4.030,
992          3.557,
993          3.249,
994          3.030,
995          2.865,
996          2.736,
997          2.632,
998          2.545,
999      },
1000      {
1001          6.950,
1002          4.870,
1003          4.027,
1004          3.554,
1005          3.246,
1006          3.027,
1007          2.863,
1008          2.733,
1009          2.629,
1010          2.542,
1011      },
1012      {
1013          6.947,
1014          4.867,
1015          4.024,
1016          3.551,
1017          3.243,
1018          3.025,
1019          2.860,
1020          2.731,
1021          2.626,
1022          2.539,
1023      },
1024      {
1025          6.943,
1026          4.864,
1027          4.021,
1028          3.548,
1029          3.240,
1030          3.022,
1031          2.857,
1032          2.728,
1033          2.623,
1034          2.537,
1035      },
1036      {
1037          6.939,
1038          4.861,
1039          4.018,
1040          3.545,
1041          3.238,
1042          3.019,
1043          2.854,
1044          2.725,
1045          2.621,
1046          2.534,
1047      },
1048      {
1049          6.935,
1050          4.858,
1051          4.015,
1052          3.543,
1053          3.235,
1054          3.017,
1055          2.852,
1056          2.723,
1057          2.618,
1058          2.532,
1059      },
1060      {
1061          6.932,
1062          4.855,
1063          4.012,
1064          3.540,
1065          3.233,
1066          3.014,
1067          2.849,
1068          2.720,
1069          2.616,
1070          2.529,
1071      },
1072      {
1073          6.928,
1074          4.852,
1075          4.010,
1076          3.538,
1077          3.230,
1078          3.012,
1079          2.847,
1080          2.718,
1081          2.613,
1082          2.527,
1083      },
1084      {
1085          6.925,
1086          4.849,
1087          4.007,
1088          3.535,
1089          3.228,
1090          3.009,
1091          2.845,
1092          2.715,
1093          2.611,
1094          2.524,
1095      },
1096      {
1097          6.922,
1098          4.846,
1099          4.004,
1100          3.533,
1101          3.225,
1102          3.007,
1103          2.842,
1104          2.713,
1105          2.609,
1106          2.522,
1107      },
1108      {
1109          6.919,
1110          4.844,
1111          4.002,
1112          3.530,
1113          3.223,
1114          3.004,
1115          2.840,
1116          2.711,
1117          2.606,
1118          2.520,
1119      },
1120      {
1121          6.915,
1122          4.841,
1123          3.999,
1124          3.528,
1125          3.221,
1126          3.002,
1127          2.838,
1128          2.709,
1129          2.604,
1130          2.518,
1131      },
1132      {
1133          6.912,
1134          4.838,
1135          3.997,
1136          3.525,
1137          3.218,
1138          3.000,
1139          2.835,
1140          2.706,
1141          2.602,
1142          2.515,
1143      },
1144      {
1145          6.909,
1146          4.836,
1147          3.995,
1148          3.523,
1149          3.216,
1150          2.998,
1151          2.833,
1152          2.704,
1153          2.600,
1154          2.513,
1155      },
1156      {
1157          6.906,
1158          4.833,
1159          3.992,
1160          3.521,
1161          3.214,
1162          2.996,
1163          2.831,
1164          2.702,
1165          2.598,
1166          2.511,
1167      },
1168      {
1169          6.904,
1170          4.831,
1171          3.990,
1172          3.519,
1173          3.212,
1174          2.994,
1175          2.829,
1176          2.700,
1177          2.596,
1178          2.509,
1179      },
1180      {
1181          6.901,
1182          4.829,
1183          3.988,
1184          3.517,
1185          3.210,
1186          2.992,
1187          2.827,
1188          2.698,
1189          2.594,
1190          2.507,
1191      },
1192      {
1193          6.898,
1194          4.826,
1195          3.986,
1196          3.515,
1197          3.208,
1198          2.990,
1199          2.825,
1200          2.696,
1201          2.592,
1202          2.505,
1203      },
1204      {6.895, 4.824, 3.984, 3.513, 3.206, 2.988, 2.823, 2.694, 2.590, 2.503}};
1205  #define MINVARIANCE 0.0004
1206  #define MINSAMPLESPERBUCKET 5
1207  #define MINSAMPLES (MINBUCKETS * MINSAMPLESPERBUCKET)
1208  #define MINSAMPLESNEEDED 1
1209  #define BUCKETTABLESIZE 1024
1210  #define NORMALEXTENT 3.0
1211  struct TEMPCLUSTER {
1212    CLUSTER *Cluster;
1213    CLUSTER *Neighbor;
1214  };
1215  using ClusterPair = tesseract::KDPairInc<float, TEMPCLUSTER *>;
1216  using ClusterHeap = tesseract::GenericHeap<ClusterPair>;
1217  struct STATISTICS {
1218    STATISTICS(size_t n) : CoVariance(n * n), Min(n), Max(n) {
1219    }
1220    float AvgVariance = 1.0f;
1221    std::vector<float> CoVariance;
1222    std::vector<float> Min; 
1223    std::vector<float> Max; 
1224  };
1225  struct BUCKETS {
1226    BUCKETS(size_t n) : NumberOfBuckets(n), Count(n), ExpectedCount(n) {
1227    }
1228    ~BUCKETS() {
1229    }
1230    DISTRIBUTION Distribution = normal; 
1231    uint32_t SampleCount = 0;         
1232    double Confidence = 0.0;          
1233    double ChiSquared = 0.0;          
1234    uint16_t NumberOfBuckets;         
1235    uint16_t Bucket[BUCKETTABLESIZE]; 
1236    std::vector<uint32_t> Count;      
1237    std::vector<float> ExpectedCount; 
1238  };
1239  struct CHISTRUCT {
1240    CHISTRUCT(uint16_t degreesOfFreedom, double alpha) : DegreesOfFreedom(degreesOfFreedom), Alpha(alpha) {
1241    }
1242    uint16_t DegreesOfFreedom = 0;
1243    double Alpha = 0.0;
1244    double ChiSquared = 0.0;
1245  };
1246  struct ClusteringContext {
1247    ClusterHeap *heap;       
1248    TEMPCLUSTER *candidates; 
1249    KDTREE *tree;            
1250    int32_t next;            
1251  };
1252  using DENSITYFUNC = double (*)(int32_t);
1253  using SOLVEFUNC = double (*)(CHISTRUCT *, double);
1254  #define Odd(N) ((N) % 2)
1255  #define Mirror(N, R) ((R) - (N)-1)
1256  #define Abs(N) (((N) < 0) ? (-(N)) : (N))
1257  #define SqrtOf2Pi 2.506628275
1258  static const double kNormalStdDev = BUCKETTABLESIZE / (2.0 * NORMALEXTENT);
1259  static const double kNormalVariance =
1260      (BUCKETTABLESIZE * BUCKETTABLESIZE) / (4.0 * NORMALEXTENT * NORMALEXTENT);
1261  static const double kNormalMagnitude = (2.0 * NORMALEXTENT) / (SqrtOf2Pi * BUCKETTABLESIZE);
1262  static const double kNormalMean = BUCKETTABLESIZE / 2;
1263  #define LOOKUPTABLESIZE 8
1264  #define MAXDEGREESOFFREEDOM MAXBUCKETS
1265  static const uint32_t kCountTable[LOOKUPTABLESIZE] = {MINSAMPLES, 200,  400, 600, 800,
1266                                                        1000,       1500, 2000}; 
1267  static const uint16_t kBucketsTable[LOOKUPTABLESIZE] = {
1268      MINBUCKETS, 16, 20, 24, 27, 30, 35, MAXBUCKETS}; 
1269  static void CreateClusterTree(CLUSTERER *Clusterer);
1270  static void MakePotentialClusters(ClusteringContext *context, CLUSTER *Cluster, int32_t Level);
1271  static CLUSTER *FindNearestNeighbor(KDTREE *Tree, CLUSTER *Cluster, float *Distance);
1272  static CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster);
1273  static void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config);
1274  static PROTOTYPE *MakePrototype(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster);
1275  static PROTOTYPE *MakeDegenerateProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics,
1276                                        PROTOSTYLE Style, int32_t MinSamples);
1277  static PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster,
1278                                        STATISTICS *Statistics);
1279  static PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1280                                       BUCKETS *Buckets);
1281  static PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer, CLUSTER *Cluster,
1282                                        STATISTICS *Statistics, BUCKETS *Buckets);
1283  static PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1284                                   BUCKETS *NormalBuckets, double Confidence);
1285  static void MakeDimRandom(uint16_t i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc);
1286  static void MakeDimUniform(uint16_t i, PROTOTYPE *Proto, STATISTICS *Statistics);
1287  static STATISTICS *ComputeStatistics(int16_t N, PARAM_DESC ParamDesc[], CLUSTER *Cluster);
1288  static PROTOTYPE *NewSphericalProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1289  static PROTOTYPE *NewEllipticalProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1290  static PROTOTYPE *NewMixedProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1291  static PROTOTYPE *NewSimpleProto(int16_t N, CLUSTER *Cluster);
1292  static bool Independent(PARAM_DESC *ParamDesc, int16_t N, float *CoVariance, float Independence);
1293  static BUCKETS *GetBuckets(CLUSTERER *clusterer, DISTRIBUTION Distribution, uint32_t SampleCount,
1294                             double Confidence);
1295  static BUCKETS *MakeBuckets(DISTRIBUTION Distribution, uint32_t SampleCount, double Confidence);
1296  static uint16_t OptimumNumberOfBuckets(uint32_t SampleCount);
1297  static double ComputeChiSquared(uint16_t DegreesOfFreedom, double Alpha);
1298  static double NormalDensity(int32_t x);
1299  static double UniformDensity(int32_t x);
1300  static double Integral(double f1, double f2, double Dx);
1301  static void FillBuckets(BUCKETS *Buckets, CLUSTER *Cluster, uint16_t Dim, PARAM_DESC *ParamDesc,
1302                          float Mean, float StdDev);
1303  static uint16_t NormalBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev);
1304  static uint16_t UniformBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev);
1305  static bool DistributionOK(BUCKETS *Buckets);
1306  static uint16_t DegreesOfFreedom(DISTRIBUTION Distribution, uint16_t HistogramBuckets);
1307  static void AdjustBuckets(BUCKETS *Buckets, uint32_t NewSampleCount);
1308  static void InitBuckets(BUCKETS *Buckets);
1309  static int AlphaMatch(void *arg1,  
1310                        void *arg2); 
1311  static double Solve(SOLVEFUNC Function, void *FunctionParams, double InitialGuess, double Accuracy);
1312  static double ChiArea(CHISTRUCT *ChiParams, double x);
1313  static bool MultipleCharSamples(CLUSTERER *Clusterer, CLUSTER *Cluster, float MaxIllegal);
1314  static double InvertMatrix(const float *input, int size, float *inv);
1315  CLUSTERER *MakeClusterer(int16_t SampleSize, const PARAM_DESC ParamDesc[]) {
1316    int i;
1317    auto Clusterer = new CLUSTERER;
1318    Clusterer->SampleSize = SampleSize;
1319    Clusterer->NumberOfSamples = 0;
1320    Clusterer->NumChar = 0;
1321    Clusterer->Root = nullptr;
1322    Clusterer->ProtoList = NIL_LIST;
1323    Clusterer->ParamDesc = new PARAM_DESC[SampleSize];
1324    for (i = 0; i < SampleSize; i++) {
1325      Clusterer->ParamDesc[i].Circular = ParamDesc[i].Circular;
1326      Clusterer->ParamDesc[i].NonEssential = ParamDesc[i].NonEssential;
1327      Clusterer->ParamDesc[i].Min = ParamDesc[i].Min;
1328      Clusterer->ParamDesc[i].Max = ParamDesc[i].Max;
1329      Clusterer->ParamDesc[i].Range = ParamDesc[i].Max - ParamDesc[i].Min;
1330      Clusterer->ParamDesc[i].HalfRange = Clusterer->ParamDesc[i].Range / 2;
1331      Clusterer->ParamDesc[i].MidRange = (ParamDesc[i].Max + ParamDesc[i].Min) / 2;
1332    }
1333    Clusterer->KDTree = MakeKDTree(SampleSize, ParamDesc);
1334    for (auto &d : Clusterer->bucket_cache) {
1335      for (auto &c : d) {
1336        c = nullptr;
1337      }
1338    }
1339    return Clusterer;
1340  } 
1341  SAMPLE *MakeSample(CLUSTERER *Clusterer, const float *Feature, uint32_t CharID) {
1342    int i;
1343    ASSERT_HOST(Clusterer->Root == nullptr);
1344    auto Sample = new SAMPLE(Clusterer->SampleSize);
1345    Sample->Clustered = false;
1346    Sample->Prototype = false;
1347    Sample->SampleCount = 1;
1348    Sample->Left = nullptr;
1349    Sample->Right = nullptr;
1350    Sample->CharID = CharID;
1351    for (i = 0; i < Clusterer->SampleSize; i++) {
1352      Sample->Mean[i] = Feature[i];
1353    }
1354    Clusterer->NumberOfSamples++;
1355    KDStore(Clusterer->KDTree, &Sample->Mean[0], Sample);
1356    if (CharID >= Clusterer->NumChar) {
1357      Clusterer->NumChar = CharID + 1;
1358    }
1359    return (Sample);
1360  } 
1361  LIST ClusterSamples(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
1362    if (Clusterer->Root == nullptr) {
1363      CreateClusterTree(Clusterer);
1364    }
1365    FreeProtoList(&Clusterer->ProtoList);
1366    Clusterer->ProtoList = NIL_LIST;
1367    ComputePrototypes(Clusterer, Config);
1368    LIST proto_list = Clusterer->ProtoList;
1369    iterate(proto_list) {
1370      auto *proto = reinterpret_cast<PROTOTYPE *>(proto_list->first_node());
1371      proto->Cluster = nullptr;
1372    }
1373    return Clusterer->ProtoList;
1374  } 
1375  void FreeClusterer(CLUSTERER *Clusterer) {
1376    if (Clusterer != nullptr) {
1377      delete[] Clusterer->ParamDesc;
1378      delete Clusterer->KDTree;
1379      delete Clusterer->Root;
1380      for (auto &d : Clusterer->bucket_cache) {
1381        for (auto &c : d) {
1382          delete c;
1383        }
1384      }
1385      delete Clusterer;
1386    }
1387  } 
1388  void FreeProtoList(LIST *ProtoList) {
1389    destroy_nodes(*ProtoList, FreePrototype);
1390  } 
1391  void FreePrototype(void *arg) { 
1392    auto *Prototype = static_cast<PROTOTYPE *>(arg);
1393    if (Prototype->Cluster != nullptr) {
1394      Prototype->Cluster->Prototype = false;
1395    }
1396    if (Prototype->Style != spherical) {
1397      delete[] Prototype->Variance.Elliptical;
1398      delete[] Prototype->Magnitude.Elliptical;
1399      delete[] Prototype->Weight.Elliptical;
1400    }
1401    delete Prototype;
1402  } 
1403  CLUSTER *NextSample(LIST *SearchState) {
1404    CLUSTER *Cluster;
1405    if (*SearchState == NIL_LIST) {
1406      return (nullptr);
1407    }
1408    Cluster = reinterpret_cast<CLUSTER *>((*SearchState)->first_node());
1409    *SearchState = pop(*SearchState);
1410    for (;;) {
1411      if (Cluster->Left == nullptr) {
1412        return (Cluster);
1413      }
1414      *SearchState = push(*SearchState, Cluster->Right);
1415      Cluster = Cluster->Left;
1416    }
1417  } 
1418  float Mean(PROTOTYPE *Proto, uint16_t Dimension) {
1419    return (Proto->Mean[Dimension]);
1420  } 
1421  float StandardDeviation(PROTOTYPE *Proto, uint16_t Dimension) {
1422    switch (Proto->Style) {
1423      case spherical:
1424        return std::sqrt(Proto->Variance.Spherical);
1425      case elliptical:
1426        return std::sqrt(Proto->Variance.Elliptical[Dimension]);
1427      case mixed:
1428        switch (Proto->Distrib[Dimension]) {
1429          case normal:
1430            return std::sqrt(Proto->Variance.Elliptical[Dimension]);
1431          case uniform:
1432          case D_random:
1433            return Proto->Variance.Elliptical[Dimension];
1434          case DISTRIBUTION_COUNT:
1435            ASSERT_HOST(!"Distribution count not allowed!");
1436        }
1437    }
1438    return 0.0f;
1439  } 
1440  static void CreateClusterTree(CLUSTERER *Clusterer) {
1441    ClusteringContext context;
1442    ClusterPair HeapEntry;
1443    context.tree = Clusterer->KDTree;
1444    context.candidates = new TEMPCLUSTER[Clusterer->NumberOfSamples];
1445    context.next = 0;
1446    context.heap = new ClusterHeap(Clusterer->NumberOfSamples);
1447    KDWalk(context.tree, MakePotentialClusters, &context);
1448    while (context.heap->Pop(&HeapEntry)) {
1449      TEMPCLUSTER *PotentialCluster = HeapEntry.data();
1450      if (PotentialCluster->Cluster->Clustered) {
1451        continue;
1452      }
1453      else if (PotentialCluster->Neighbor->Clustered) {
1454        PotentialCluster->Neighbor =
1455            FindNearestNeighbor(context.tree, PotentialCluster->Cluster, &HeapEntry.key());
1456        if (PotentialCluster->Neighbor != nullptr) {
1457          context.heap->Push(&HeapEntry);
1458        }
1459      }
1460      else {
1461        PotentialCluster->Cluster = MakeNewCluster(Clusterer, PotentialCluster);
1462        PotentialCluster->Neighbor =
1463            FindNearestNeighbor(context.tree, PotentialCluster->Cluster, &HeapEntry.key());
1464        if (PotentialCluster->Neighbor != nullptr) {
1465          context.heap->Push(&HeapEntry);
1466        }
1467      }
1468    }
1469    Clusterer->Root = static_cast<CLUSTER *> RootOf(Clusterer->KDTree);
1470    delete context.tree;
1471    Clusterer->KDTree = nullptr;
1472    delete context.heap;
1473    delete[] context.candidates;
1474  } 
1475  static void MakePotentialClusters(ClusteringContext *context, CLUSTER *Cluster, int32_t &bsol;*Level*/) {
1476    ClusterPair HeapEntry;
1477    int next = context->next;
1478    context->candidates[next].Cluster = Cluster;
1479    HeapEntry.data() = &(context->candidates[next]);
1480    context->candidates[next].Neighbor =
1481        FindNearestNeighbor(context->tree, context->candidates[next].Cluster, &HeapEntry.key());
1482    if (context->candidates[next].Neighbor != nullptr) {
1483      context->heap->Push(&HeapEntry);
1484      context->next++;
1485    }
1486  } 
1487  static CLUSTER *FindNearestNeighbor(KDTREE *Tree, CLUSTER *Cluster, float *Distance)
1488  #define MAXNEIGHBORS 2
1489  #define MAXDISTANCE FLT_MAX
1490  {
1491    CLUSTER *Neighbor[MAXNEIGHBORS];
1492    float Dist[MAXNEIGHBORS];
1493    int NumberOfNeighbors;
1494    int32_t i;
1495    CLUSTER *BestNeighbor;
1496    KDNearestNeighborSearch(Tree, &Cluster->Mean[0], MAXNEIGHBORS, MAXDISTANCE, &NumberOfNeighbors,
1497                            reinterpret_cast<void **>(Neighbor), Dist);
1498    *Distance = MAXDISTANCE;
1499    BestNeighbor = nullptr;
1500    for (i = 0; i < NumberOfNeighbors; i++) {
1501      if ((Dist[i] < *Distance) && (Neighbor[i] != Cluster)) {
1502        *Distance = Dist[i];
1503        BestNeighbor = Neighbor[i];
1504      }
1505    }
1506    return BestNeighbor;
1507  } 
1508  static CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster) {
1509    auto Cluster = new CLUSTER(Clusterer->SampleSize);
1510    Cluster->Clustered = false;
1511    Cluster->Prototype = false;
1512    Cluster->Left = TempCluster->Cluster;
1513    Cluster->Right = TempCluster->Neighbor;
1514    Cluster->CharID = -1;
1515    Cluster->Left->Clustered = true;
1516    Cluster->Right->Clustered = true;
1517    KDDelete(Clusterer->KDTree, &Cluster->Left->Mean[0], Cluster->Left);
1518    KDDelete(Clusterer->KDTree, &Cluster->Right->Mean[0], Cluster->Right);
1519    Cluster->SampleCount = MergeClusters(Clusterer->SampleSize, Clusterer->ParamDesc,
1520                                         Cluster->Left->SampleCount, Cluster->Right->SampleCount,
1521                                         &Cluster->Mean[0], &Cluster->Left->Mean[0], &Cluster->Right->Mean[0]);
1522    KDStore(Clusterer->KDTree, &Cluster->Mean[0], Cluster);
1523    return Cluster;
1524  } 
1525  int32_t MergeClusters(int16_t N, PARAM_DESC ParamDesc[], int32_t n1, int32_t n2, float m[],
1526                        float m1[], float m2[]) {
1527    int32_t i, n;
1528    n = n1 + n2;
1529    for (i = N; i > 0; i--, ParamDesc++, m++, m1++, m2++) {
1530      if (ParamDesc->Circular) {
1531        if ((*m2 - *m1) > ParamDesc->HalfRange) {
1532          *m = (n1 * *m1 + n2 * (*m2 - ParamDesc->Range)) / n;
1533          if (*m < ParamDesc->Min) {
1534            *m += ParamDesc->Range;
1535          }
1536        } else if ((*m1 - *m2) > ParamDesc->HalfRange) {
1537          *m = (n1 * (*m1 - ParamDesc->Range) + n2 * *m2) / n;
1538          if (*m < ParamDesc->Min) {
1539            *m += ParamDesc->Range;
1540          }
1541        } else {
1542          *m = (n1 * *m1 + n2 * *m2) / n;
1543        }
1544      } else {
1545        *m = (n1 * *m1 + n2 * *m2) / n;
1546      }
1547    }
1548    return n;
1549  } 
1550  static void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
1551    LIST ClusterStack = NIL_LIST;
1552    CLUSTER *Cluster;
1553    PROTOTYPE *Prototype;
1554    if (Clusterer->Root != nullptr) {
1555      ClusterStack = push(NIL_LIST, Clusterer->Root);
1556    }
1557    while (ClusterStack != NIL_LIST) {
1558      Cluster = reinterpret_cast<CLUSTER *>(ClusterStack->first_node());
1559      ClusterStack = pop(ClusterStack);
1560      Prototype = MakePrototype(Clusterer, Config, Cluster);
1561      if (Prototype != nullptr) {
1562        Clusterer->ProtoList = push(Clusterer->ProtoList, Prototype);
1563      } else {
1564        ClusterStack = push(ClusterStack, Cluster->Right);
1565        ClusterStack = push(ClusterStack, Cluster->Left);
1566      }
1567    }
1568  } 
1569  static PROTOTYPE *MakePrototype(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster) {
1570    PROTOTYPE *Proto;
1571    BUCKETS *Buckets;
1572    if (MultipleCharSamples(Clusterer, Cluster, Config->MaxIllegal)) {
1573      return nullptr;
1574    }
1575    auto Statistics = ComputeStatistics(Clusterer->SampleSize, Clusterer->ParamDesc, Cluster);
1576    Proto = MakeDegenerateProto(Clusterer->SampleSize, Cluster, Statistics, Config->ProtoStyle,
1577                                static_cast<int32_t>(Config->MinSamples * Clusterer->NumChar));
1578    if (Proto != nullptr) {
1579      delete Statistics;
1580      return Proto;
1581    }
1582    if (!Independent(Clusterer->ParamDesc, Clusterer->SampleSize, &Statistics->CoVariance[0],
1583                     Config->Independence)) {
1584      delete Statistics;
1585      return nullptr;
1586    }
1587    if (HOTELLING && Config->ProtoStyle == elliptical) {
1588      Proto = TestEllipticalProto(Clusterer, Config, Cluster, Statistics);
<span onclick='openModal()' class='match'>1589      if (Proto != nullptr) {
1590        delete Statistics;
1591        return Proto;
1592      }
1593    }
</span>1594    Buckets = GetBuckets(Clusterer, normal, Cluster->SampleCount, Config->Confidence);
1595    switch (Config->ProtoStyle) {
1596      case spherical:
1597        Proto = MakeSphericalProto(Clusterer, Cluster, Statistics, Buckets);
1598        break;
1599      case elliptical:
1600        Proto = MakeEllipticalProto(Clusterer, Cluster, Statistics, Buckets);
1601        break;
1602      case mixed:
1603        Proto = MakeMixedProto(Clusterer, Cluster, Statistics, Buckets, Config->Confidence);
1604        break;
1605      case automatic:
1606        Proto = MakeSphericalProto(Clusterer, Cluster, Statistics, Buckets);
1607        if (Proto != nullptr) {
1608          break;
1609        }
1610        Proto = MakeEllipticalProto(Clusterer, Cluster, Statistics, Buckets);
1611        if (Proto != nullptr) {
1612          break;
1613        }
1614        Proto = MakeMixedProto(Clusterer, Cluster, Statistics, Buckets, Config->Confidence);
1615        break;
1616    }
1617    delete Statistics;
1618    return Proto;
1619  } 
1620  static PROTOTYPE *MakeDegenerateProto( 
1621      uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics, PROTOSTYLE Style, int32_t MinSamples) {
1622    PROTOTYPE *Proto = nullptr;
1623    if (MinSamples < MINSAMPLESNEEDED) {
1624      MinSamples = MINSAMPLESNEEDED;
1625    }
1626    if (Cluster->SampleCount < MinSamples) {
1627      switch (Style) {
1628        case spherical:
1629          Proto = NewSphericalProto(N, Cluster, Statistics);
1630          break;
1631        case elliptical:
1632        case automatic:
1633          Proto = NewEllipticalProto(N, Cluster, Statistics);
1634          break;
1635        case mixed:
1636          Proto = NewMixedProto(N, Cluster, Statistics);
1637          break;
1638      }
1639      Proto->Significant = false;
1640    }
1641    return (Proto);
1642  } 
1643  static PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster,
1644                                        STATISTICS *Statistics) {
1645    const double kMagicSampleMargin = 0.0625;
1646    const double kFTableBoostMargin = 2.0;
1647    int N = Clusterer->SampleSize;
1648    CLUSTER *Left = Cluster->Left;
1649    CLUSTER *Right = Cluster->Right;
1650    if (Left == nullptr || Right == nullptr) {
1651      return nullptr;
1652    }
1653    int TotalDims = Left->SampleCount + Right->SampleCount;
1654    if (TotalDims < N + 1 || TotalDims < 2) {
1655      return nullptr;
1656    }
1657    std::vector<float> Covariance(static_cast<size_t>(N) * N);
1658    std::vector<float> Inverse(static_cast<size_t>(N) * N);
1659    std::vector<float> Delta(N);
1660    for (int i = 0; i < N; ++i) {
1661      int row_offset = i * N;
1662      if (!Clusterer->ParamDesc[i].NonEssential) {
1663        for (int j = 0; j < N; ++j) {
1664          if (!Clusterer->ParamDesc[j].NonEssential) {
1665            Covariance[j + row_offset] = Statistics->CoVariance[j + row_offset];
1666          } else {
1667            Covariance[j + row_offset] = 0.0f;
1668          }
1669        }
1670      } else {
1671        for (int j = 0; j < N; ++j) {
1672          if (i == j) {
1673            Covariance[j + row_offset] = 1.0f;
1674          } else {
1675            Covariance[j + row_offset] = 0.0f;
1676          }
1677        }
1678      }
1679    }
1680    double err = InvertMatrix(&Covariance[0], N, &Inverse[0]);
1681    if (err > 1) {
1682      tprintf("Clustering error: Matrix inverse failed with error %g\n", err);
1683    }
1684    int EssentialN = 0;
1685    for (int dim = 0; dim < N; ++dim) {
1686      if (!Clusterer->ParamDesc[dim].NonEssential) {
1687        Delta[dim] = Left->Mean[dim] - Right->Mean[dim];
1688        ++EssentialN;
1689      } else {
1690        Delta[dim] = 0.0f;
1691      }
1692    }
1693    double Tsq = 0.0;
1694    for (int x = 0; x < N; ++x) {
1695      double temp = 0.0;
1696      for (int y = 0; y < N; ++y) {
1697        temp += static_cast<double>(Inverse[y + N * x]) * Delta[y];
1698      }
1699      Tsq += Delta[x] * temp;
1700    }
1701    double F = Tsq * (TotalDims - EssentialN - 1) / ((TotalDims - 2) * EssentialN);
1702    int Fx = EssentialN;
1703    if (Fx > FTABLE_X) {
1704      Fx = FTABLE_X;
1705    }
1706    --Fx;
1707    int Fy = TotalDims - EssentialN - 1;
1708    if (Fy > FTABLE_Y) {
1709      Fy = FTABLE_Y;
1710    }
1711    --Fy;
1712    double FTarget = FTable[Fy][Fx];
1713    if (Config->MagicSamples > 0 && TotalDims >= Config->MagicSamples * (1.0 - kMagicSampleMargin) &&
1714        TotalDims <= Config->MagicSamples * (1.0 + kMagicSampleMargin)) {
1715      FTarget += kFTableBoostMargin;
1716    }
1717    if (F < FTarget) {
1718      return NewEllipticalProto(Clusterer->SampleSize, Cluster, Statistics);
1719    }
1720    return nullptr;
1721  }
1722  static PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1723                                       BUCKETS *Buckets) {
1724    PROTOTYPE *Proto = nullptr;
1725    int i;
1726    for (i = 0; i < Clusterer->SampleSize; i++) {
1727      if (Clusterer->ParamDesc[i].NonEssential) {
1728        continue;
1729      }
1730      FillBuckets(Buckets, Cluster, i, &(Clusterer->ParamDesc[i]), Cluster->Mean[i],
1731                  sqrt(static_cast<double>(Statistics->AvgVariance)));
1732      if (!DistributionOK(Buckets)) {
1733        break;
1734      }
1735    }
1736    if (i >= Clusterer->SampleSize) {
1737      Proto = NewSphericalProto(Clusterer->SampleSize, Cluster, Statistics);
1738    }
1739    return (Proto);
1740  } 
1741  static PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer, CLUSTER *Cluster,
1742                                        STATISTICS *Statistics, BUCKETS *Buckets) {
1743    PROTOTYPE *Proto = nullptr;
1744    int i;
1745    for (i = 0; i < Clusterer->SampleSize; i++) {
1746      if (Clusterer->ParamDesc[i].NonEssential) {
1747        continue;
1748      }
1749      FillBuckets(Buckets, Cluster, i, &(Clusterer->ParamDesc[i]), Cluster->Mean[i],
1750                  sqrt(static_cast<double>(Statistics->CoVariance[i * (Clusterer->SampleSize + 1)])));
1751      if (!DistributionOK(Buckets)) {
1752        break;
1753      }
1754    }
1755    if (i >= Clusterer->SampleSize) {
1756      Proto = NewEllipticalProto(Clusterer->SampleSize, Cluster, Statistics);
1757    }
1758    return (Proto);
1759  } 
1760  static PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1761                                   BUCKETS *NormalBuckets, double Confidence) {
1762    PROTOTYPE *Proto;
1763    int i;
1764    BUCKETS *UniformBuckets = nullptr;
1765    BUCKETS *RandomBuckets = nullptr;
1766    Proto = NewMixedProto(Clusterer->SampleSize, Cluster, Statistics);
1767    for (i = 0; i < Clusterer->SampleSize; i++) {
1768      if (Clusterer->ParamDesc[i].NonEssential) {
1769        continue;
1770      }
1771      FillBuckets(NormalBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1772                  std::sqrt(Proto->Variance.Elliptical[i]));
1773      if (DistributionOK(NormalBuckets)) {
1774        continue;
1775      }
1776      if (RandomBuckets == nullptr) {
1777        RandomBuckets = GetBuckets(Clusterer, D_random, Cluster->SampleCount, Confidence);
1778      }
1779      MakeDimRandom(i, Proto, &(Clusterer->ParamDesc[i]));
1780      FillBuckets(RandomBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1781                  Proto->Variance.Elliptical[i]);
1782      if (DistributionOK(RandomBuckets)) {
1783        continue;
1784      }
1785      if (UniformBuckets == nullptr) {
1786        UniformBuckets = GetBuckets(Clusterer, uniform, Cluster->SampleCount, Confidence);
1787      }
1788      MakeDimUniform(i, Proto, Statistics);
1789      FillBuckets(UniformBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1790                  Proto->Variance.Elliptical[i]);
1791      if (DistributionOK(UniformBuckets)) {
1792        continue;
1793      }
1794      break;
1795    }
1796    if (i < Clusterer->SampleSize) {
1797      FreePrototype(Proto);
1798      Proto = nullptr;
1799    }
1800    return (Proto);
1801  } 
1802  static void MakeDimRandom(uint16_t i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc) {
1803    Proto->Distrib[i] = D_random;
1804    Proto->Mean[i] = ParamDesc->MidRange;
1805    Proto->Variance.Elliptical[i] = ParamDesc->HalfRange;
1806    Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
1807    Proto->Magnitude.Elliptical[i] = 1.0 / ParamDesc->Range;
1808    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1809    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1810  } 
1811  static void MakeDimUniform(uint16_t i, PROTOTYPE *Proto, STATISTICS *Statistics) {
1812    Proto->Distrib[i] = uniform;
1813    Proto->Mean[i] = Proto->Cluster->Mean[i] + (Statistics->Min[i] + Statistics->Max[i]) / 2;
1814    Proto->Variance.Elliptical[i] = (Statistics->Max[i] - Statistics->Min[i]) / 2;
1815    if (Proto->Variance.Elliptical[i] < MINVARIANCE) {
1816      Proto->Variance.Elliptical[i] = MINVARIANCE;
1817    }
1818    Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
1819    Proto->Magnitude.Elliptical[i] = 1.0 / (2.0 * Proto->Variance.Elliptical[i]);
1820    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1821    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1822  } 
1823  static STATISTICS *ComputeStatistics(int16_t N, PARAM_DESC ParamDesc[], CLUSTER *Cluster) {
1824    int i, j;
1825    LIST SearchState;
1826    SAMPLE *Sample;
1827    uint32_t SampleCountAdjustedForBias;
1828    auto Statistics = new STATISTICS(N);
1829    std::vector<float> Distance(N);
1830    InitSampleSearch(SearchState, Cluster);
1831    while ((Sample = NextSample(&SearchState)) != nullptr) {
1832      for (i = 0; i < N; i++) {
1833        Distance[i] = Sample->Mean[i] - Cluster->Mean[i];
1834        if (ParamDesc[i].Circular) {
1835          if (Distance[i] > ParamDesc[i].HalfRange) {
1836            Distance[i] -= ParamDesc[i].Range;
1837          }
1838          if (Distance[i] < -ParamDesc[i].HalfRange) {
1839            Distance[i] += ParamDesc[i].Range;
1840          }
1841        }
1842        if (Distance[i] < Statistics->Min[i]) {
1843          Statistics->Min[i] = Distance[i];
1844        }
1845        if (Distance[i] > Statistics->Max[i]) {
1846          Statistics->Max[i] = Distance[i];
1847        }
1848      }
1849      auto CoVariance = &Statistics->CoVariance[0];
1850      for (i = 0; i < N; i++) {
1851        for (j = 0; j < N; j++, CoVariance++) {
1852          *CoVariance += Distance[i] * Distance[j];
1853        }
1854      }
1855    }
1856    if (Cluster->SampleCount > 1) {
1857      SampleCountAdjustedForBias = Cluster->SampleCount - 1;
1858    } else {
1859      SampleCountAdjustedForBias = 1;
1860    }
1861    auto CoVariance = &Statistics->CoVariance[0];
1862    for (i = 0; i < N; i++) {
1863      for (j = 0; j < N; j++, CoVariance++) {
1864        *CoVariance /= SampleCountAdjustedForBias;
1865        if (j == i) {
1866          if (*CoVariance < MINVARIANCE) {
1867            *CoVariance = MINVARIANCE;
1868          }
1869          Statistics->AvgVariance *= *CoVariance;
1870        }
1871      }
1872    }
1873    Statistics->AvgVariance =
1874        static_cast<float>(pow(static_cast<double>(Statistics->AvgVariance), 1.0 / N));
1875    return Statistics;
1876  } 
1877  static PROTOTYPE *NewSphericalProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1878    PROTOTYPE *Proto;
1879    Proto = NewSimpleProto(N, Cluster);
1880    Proto->Variance.Spherical = Statistics->AvgVariance;
1881    if (Proto->Variance.Spherical < MINVARIANCE) {
1882      Proto->Variance.Spherical = MINVARIANCE;
1883    }
1884    Proto->Magnitude.Spherical = 1.0 / sqrt(2.0 * M_PI * Proto->Variance.Spherical);
1885    Proto->TotalMagnitude = static_cast<float>(
1886        pow(static_cast<double>(Proto->Magnitude.Spherical), static_cast<double>(N)));
1887    Proto->Weight.Spherical = 1.0 / Proto->Variance.Spherical;
1888    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1889    return (Proto);
1890  } 
1891  static PROTOTYPE *NewEllipticalProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1892    PROTOTYPE *Proto;
1893    int i;
1894    Proto = NewSimpleProto(N, Cluster);
1895    Proto->Variance.Elliptical = new float[N];
1896    Proto->Magnitude.Elliptical = new float[N];
1897    Proto->Weight.Elliptical = new float[N];
1898    auto CoVariance = &Statistics->CoVariance[0];
1899    Proto->TotalMagnitude = 1.0;
1900    for (i = 0; i < N; i++, CoVariance += N + 1) {
1901      Proto->Variance.Elliptical[i] = *CoVariance;
1902      if (Proto->Variance.Elliptical[i] < MINVARIANCE) {
1903        Proto->Variance.Elliptical[i] = MINVARIANCE;
1904      }
1905      Proto->Magnitude.Elliptical[i] = 1.0f / sqrt(2.0f * M_PI * Proto->Variance.Elliptical[i]);
1906      Proto->Weight.Elliptical[i] = 1.0f / Proto->Variance.Elliptical[i];
1907      Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1908    }
1909    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1910    Proto->Style = elliptical;
1911    return (Proto);
1912  } 
1913  static PROTOTYPE *NewMixedProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1914    auto Proto = NewEllipticalProto(N, Cluster, Statistics);
1915    Proto->Distrib.clear();
1916    Proto->Distrib.resize(N, normal);
1917    Proto->Style = mixed;
1918    return Proto;
1919  } 
1920  static PROTOTYPE *NewSimpleProto(int16_t N, CLUSTER *Cluster) {
1921    auto Proto = new PROTOTYPE;
1922    Proto->Mean = Cluster->Mean;
1923    Proto->Distrib.clear();
1924    Proto->Significant = true;
1925    Proto->Merged = false;
1926    Proto->Style = spherical;
1927    Proto->NumSamples = Cluster->SampleCount;
1928    Proto->Cluster = Cluster;
1929    Proto->Cluster->Prototype = true;
1930    return Proto;
1931  } 
1932  static bool Independent(PARAM_DESC *ParamDesc, int16_t N, float *CoVariance, float Independence) {
1933    int i, j;
1934    float *VARii; 
1935    float *VARjj; 
1936    float CorrelationCoeff;
1937    VARii = CoVariance;
1938    for (i = 0; i < N; i++, VARii += N + 1) {
1939      if (ParamDesc[i].NonEssential) {
1940        continue;
1941      }
1942      VARjj = VARii + N + 1;
1943      CoVariance = VARii + 1;
1944      for (j = i + 1; j < N; j++, CoVariance++, VARjj += N + 1) {
1945        if (ParamDesc[j].NonEssential) {
1946          continue;
1947        }
1948        if ((*VARii == 0.0) || (*VARjj == 0.0)) {
1949          CorrelationCoeff = 0.0;
1950        } else {
1951          CorrelationCoeff = sqrt(std::sqrt(*CoVariance * *CoVariance / (*VARii * *VARjj)));
1952        }
1953        if (CorrelationCoeff > Independence) {
1954          return false;
1955        }
1956      }
1957    }
1958    return true;
1959  } 
1960  static BUCKETS *GetBuckets(CLUSTERER *clusterer, DISTRIBUTION Distribution, uint32_t SampleCount,
1961                             double Confidence) {
1962    uint16_t NumberOfBuckets = OptimumNumberOfBuckets(SampleCount);
1963    BUCKETS *Buckets = clusterer->bucket_cache[Distribution][NumberOfBuckets - MINBUCKETS];
1964    if (Buckets == nullptr) {
1965      Buckets = MakeBuckets(Distribution, SampleCount, Confidence);
1966      clusterer->bucket_cache[Distribution][NumberOfBuckets - MINBUCKETS] = Buckets;
1967    } else {
1968      if (SampleCount != Buckets->SampleCount) {
1969        AdjustBuckets(Buckets, SampleCount);
1970      }
1971      if (Confidence != Buckets->Confidence) {
1972        Buckets->Confidence = Confidence;
1973        Buckets->ChiSquared =
1974            ComputeChiSquared(DegreesOfFreedom(Distribution, Buckets->NumberOfBuckets), Confidence);
1975      }
1976      InitBuckets(Buckets);
1977    }
1978    return Buckets;
1979  } 
1980  static BUCKETS *MakeBuckets(DISTRIBUTION Distribution, uint32_t SampleCount, double Confidence) {
1981    const DENSITYFUNC DensityFunction[] = {NormalDensity, UniformDensity, UniformDensity};
1982    int i, j;
1983    double BucketProbability;
1984    double NextBucketBoundary;
1985    double Probability;
1986    double ProbabilityDelta;
1987    double LastProbDensity;
1988    double ProbDensity;
1989    uint16_t CurrentBucket;
1990    bool Symmetrical;
1991    auto Buckets = new BUCKETS(OptimumNumberOfBuckets(SampleCount));
1992    Buckets->SampleCount = SampleCount;
1993    Buckets->Confidence = Confidence;
1994    Buckets->Distribution = Distribution;
1995    Symmetrical = true;
1996    Buckets->ChiSquared =
1997        ComputeChiSquared(DegreesOfFreedom(Distribution, Buckets->NumberOfBuckets), Confidence);
1998    if (Symmetrical) {
1999      BucketProbability = 1.0 / static_cast<double>(Buckets->NumberOfBuckets);
2000      CurrentBucket = Buckets->NumberOfBuckets / 2;
2001      if (Odd(Buckets->NumberOfBuckets)) {
2002        NextBucketBoundary = BucketProbability / 2;
2003      } else {
2004        NextBucketBoundary = BucketProbability;
2005      }
2006      Probability = 0.0;
2007      LastProbDensity = (*DensityFunction[static_cast<int>(Distribution)])(BUCKETTABLESIZE / 2);
2008      for (i = BUCKETTABLESIZE / 2; i < BUCKETTABLESIZE; i++) {
2009        ProbDensity = (*DensityFunction[static_cast<int>(Distribution)])(i + 1);
2010        ProbabilityDelta = Integral(LastProbDensity, ProbDensity, 1.0);
2011        Probability += ProbabilityDelta;
2012        if (Probability > NextBucketBoundary) {
2013          if (CurrentBucket < Buckets->NumberOfBuckets - 1) {
2014            CurrentBucket++;
2015          }
2016          NextBucketBoundary += BucketProbability;
2017        }
2018        Buckets->Bucket[i] = CurrentBucket;
2019        Buckets->ExpectedCount[CurrentBucket] += static_cast<float>(ProbabilityDelta * SampleCount);
2020        LastProbDensity = ProbDensity;
2021      }
2022      Buckets->ExpectedCount[CurrentBucket] += static_cast<float>((0.5 - Probability) * SampleCount);
2023      for (i = 0, j = BUCKETTABLESIZE - 1; i < j; i++, j--) {
2024        Buckets->Bucket[i] = Mirror(Buckets->Bucket[j], Buckets->NumberOfBuckets);
2025      }
2026      for (i = 0, j = Buckets->NumberOfBuckets - 1; i <= j; i++, j--) {
2027        Buckets->ExpectedCount[i] += Buckets->ExpectedCount[j];
2028      }
2029    }
2030    return Buckets;
2031  } 
2032  static uint16_t OptimumNumberOfBuckets(uint32_t SampleCount) {
2033    uint8_t Last, Next;
2034    float Slope;
2035    if (SampleCount < kCountTable[0]) {
2036      return kBucketsTable[0];
2037    }
2038    for (Last = 0, Next = 1; Next < LOOKUPTABLESIZE; Last++, Next++) {
2039      if (SampleCount <= kCountTable[Next]) {
2040        Slope = static_cast<float>(kBucketsTable[Next] - kBucketsTable[Last]) /
2041                static_cast<float>(kCountTable[Next] - kCountTable[Last]);
2042        return (
2043            static_cast<uint16_t>(kBucketsTable[Last] + Slope * (SampleCount - kCountTable[Last])));
2044      }
2045    }
2046    return kBucketsTable[Last];
2047  } 
2048  static double ComputeChiSquared(uint16_t DegreesOfFreedom, double Alpha)
2049  #define CHIACCURACY 0.01
2050  #define MINALPHA (1e-200)
2051  {
2052    static LIST ChiWith[MAXDEGREESOFFREEDOM + 1];
2053    Alpha = ClipToRange(Alpha, MINALPHA, 1.0);
2054    if (Odd(DegreesOfFreedom)) {
2055      DegreesOfFreedom++;
2056    }
2057    CHISTRUCT SearchKey(0.0, Alpha);
2058    auto *found = search(ChiWith[DegreesOfFreedom], &SearchKey, AlphaMatch);
2059    auto OldChiSquared = reinterpret_cast<CHISTRUCT *>(found ? found->first_node() : nullptr);
2060    if (OldChiSquared == nullptr) {
2061      OldChiSquared = new CHISTRUCT(DegreesOfFreedom, Alpha);
2062      OldChiSquared->ChiSquared =
2063          Solve(ChiArea, OldChiSquared, static_cast<double>(DegreesOfFreedom), CHIACCURACY);
2064      ChiWith[DegreesOfFreedom] = push(ChiWith[DegreesOfFreedom], OldChiSquared);
2065    } else {
2066    }
2067    return (OldChiSquared->ChiSquared);
2068  } 
2069  static double NormalDensity(int32_t x) {
2070    double Distance;
2071    Distance = x - kNormalMean;
2072    return kNormalMagnitude * exp(-0.5 * Distance * Distance / kNormalVariance);
2073  } 
2074  static double UniformDensity(int32_t x) {
2075    constexpr auto UniformDistributionDensity = 1.0 / BUCKETTABLESIZE;
2076    if ((x >= 0) && (x <= BUCKETTABLESIZE)) {
2077      return UniformDistributionDensity;
2078    } else {
2079      return 0.0;
2080    }
2081  } 
2082  static double Integral(double f1, double f2, double Dx) {
2083    return (f1 + f2) * Dx / 2.0;
2084  } 
2085  static void FillBuckets(BUCKETS *Buckets, CLUSTER *Cluster, uint16_t Dim, PARAM_DESC *ParamDesc,
2086                          float Mean, float StdDev) {
2087    uint16_t BucketID;
2088    int i;
2089    LIST SearchState;
2090    SAMPLE *Sample;
2091    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2092      Buckets->Count[i] = 0;
2093    }
2094    if (StdDev == 0.0) {
2095      InitSampleSearch(SearchState, Cluster);
2096      i = 0;
2097      while ((Sample = NextSample(&SearchState)) != nullptr) {
2098        if (Sample->Mean[Dim] > Mean) {
2099          BucketID = Buckets->NumberOfBuckets - 1;
2100        } else if (Sample->Mean[Dim] < Mean) {
2101          BucketID = 0;
2102        } else {
2103          BucketID = i;
2104        }
2105        Buckets->Count[BucketID] += 1;
2106        i++;
2107        if (i >= Buckets->NumberOfBuckets) {
2108          i = 0;
2109        }
2110      }
2111    } else {
2112      InitSampleSearch(SearchState, Cluster);
2113      while ((Sample = NextSample(&SearchState)) != nullptr) {
2114        switch (Buckets->Distribution) {
2115          case normal:
2116            BucketID = NormalBucket(ParamDesc, Sample->Mean[Dim], Mean, StdDev);
2117            break;
2118          case D_random:
2119          case uniform:
2120            BucketID = UniformBucket(ParamDesc, Sample->Mean[Dim], Mean, StdDev);
2121            break;
2122          default:
2123            BucketID = 0;
2124        }
2125        Buckets->Count[Buckets->Bucket[BucketID]] += 1;
2126      }
2127    }
2128  } 
2129  static uint16_t NormalBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev) {
2130    float X;
2131    if (ParamDesc->Circular) {
2132      if (x - Mean > ParamDesc->HalfRange) {
2133        x -= ParamDesc->Range;
2134      } else if (x - Mean < -ParamDesc->HalfRange) {
2135        x += ParamDesc->Range;
2136      }
2137    }
2138    X = ((x - Mean) / StdDev) * kNormalStdDev + kNormalMean;
2139    if (X < 0) {
2140      return 0;
2141    }
2142    if (X > BUCKETTABLESIZE - 1) {
2143      return (static_cast<uint16_t>(BUCKETTABLESIZE - 1));
2144    }
2145    return static_cast<uint16_t>(floor(static_cast<double>(X)));
2146  } 
2147  static uint16_t UniformBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev) {
2148    float X;
2149    if (ParamDesc->Circular) {
2150      if (x - Mean > ParamDesc->HalfRange) {
2151        x -= ParamDesc->Range;
2152      } else if (x - Mean < -ParamDesc->HalfRange) {
2153        x += ParamDesc->Range;
2154      }
2155    }
2156    X = ((x - Mean) / (2 * StdDev) * BUCKETTABLESIZE + BUCKETTABLESIZE / 2.0);
2157    if (X < 0) {
2158      return 0;
2159    }
2160    if (X > BUCKETTABLESIZE - 1) {
2161      return static_cast<uint16_t>(BUCKETTABLESIZE - 1);
2162    }
2163    return static_cast<uint16_t>(floor(static_cast<double>(X)));
2164  } 
2165  static bool DistributionOK(BUCKETS *Buckets) {
2166    float FrequencyDifference;
2167    float TotalDifference;
2168    int i;
2169    TotalDifference = 0.0;
2170    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2171      FrequencyDifference = Buckets->Count[i] - Buckets->ExpectedCount[i];
2172      TotalDifference += (FrequencyDifference * FrequencyDifference) / Buckets->ExpectedCount[i];
2173    }
2174    if (TotalDifference > Buckets->ChiSquared) {
2175      return false;
2176    } else {
2177      return true;
2178    }
2179  } 
2180  static uint16_t DegreesOfFreedom(DISTRIBUTION Distribution, uint16_t HistogramBuckets) {
2181    static uint8_t DegreeOffsets[] = {3, 3, 1};
2182    uint16_t AdjustedNumBuckets;
2183    AdjustedNumBuckets = HistogramBuckets - DegreeOffsets[static_cast<int>(Distribution)];
2184    if (Odd(AdjustedNumBuckets)) {
2185      AdjustedNumBuckets++;
2186    }
2187    return (AdjustedNumBuckets);
2188  } 
2189  static void AdjustBuckets(BUCKETS *Buckets, uint32_t NewSampleCount) {
2190    int i;
2191    double AdjustFactor;
2192    AdjustFactor =
2193        ((static_cast<double>(NewSampleCount)) / (static_cast<double>(Buckets->SampleCount)));
2194    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2195      Buckets->ExpectedCount[i] *= AdjustFactor;
2196    }
2197    Buckets->SampleCount = NewSampleCount;
2198  } 
2199  static void InitBuckets(BUCKETS *Buckets) {
2200    int i;
2201    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2202      Buckets->Count[i] = 0;
2203    }
2204  } 
2205  static int AlphaMatch(void *arg1,   
2206                        void *arg2) { 
2207    auto *ChiStruct = static_cast<CHISTRUCT *>(arg1);
2208    auto *SearchKey = static_cast<CHISTRUCT *>(arg2);
2209    return (ChiStruct->Alpha == SearchKey->Alpha);
2210  } 
2211  static double Solve(SOLVEFUNC Function, void *FunctionParams, double InitialGuess, double Accuracy)
2212  #define INITIALDELTA 0.1
2213  #define DELTARATIO 0.1
2214  {
2215    double x;
2216    double f;
2217    double Slope;
2218    double Delta;
2219    double NewDelta;
2220    double xDelta;
2221    double LastPosX, LastNegX;
2222    x = InitialGuess;
2223    Delta = INITIALDELTA;
2224    LastPosX = FLT_MAX;
2225    LastNegX = -FLT_MAX;
2226    f = (*Function)(static_cast<CHISTRUCT *>(FunctionParams), x);
2227    while (Abs(LastPosX - LastNegX) > Accuracy) {
2228      if (f < 0) {
2229        LastNegX = x;
2230      } else {
2231        LastPosX = x;
2232      }
2233      Slope = ((*Function)(static_cast<CHISTRUCT *>(FunctionParams), x + Delta) - f) / Delta;
2234      xDelta = f / Slope;
2235      x -= xDelta;
2236      NewDelta = Abs(xDelta) * DELTARATIO;
2237      if (NewDelta < Delta) {
2238        Delta = NewDelta;
2239      }
2240      f = (*Function)(static_cast<CHISTRUCT *>(FunctionParams), x);
2241    }
2242    return (x);
2243  } 
2244  static double ChiArea(CHISTRUCT *ChiParams, double x) {
2245    int i, N;
2246    double SeriesTotal;
2247    double Denominator;
2248    double PowerOfx;
2249    N = ChiParams->DegreesOfFreedom / 2 - 1;
2250    SeriesTotal = 1;
2251    Denominator = 1;
2252    PowerOfx = 1;
2253    for (i = 1; i <= N; i++) {
2254      Denominator *= 2 * i;
2255      PowerOfx *= x;
2256      SeriesTotal += PowerOfx / Denominator;
2257    }
2258    return ((SeriesTotal * exp(-0.5 * x)) - ChiParams->Alpha);
2259  } 
2260  static bool MultipleCharSamples(CLUSTERER *Clusterer, CLUSTER *Cluster, float MaxIllegal)
2261  #define ILLEGAL_CHAR 2
2262  {
2263    static std::vector<uint8_t> CharFlags;
2264    LIST SearchState;
2265    SAMPLE *Sample;
2266    int32_t CharID;
2267    int32_t NumCharInCluster;
2268    int32_t NumIllegalInCluster;
2269    float PercentIllegal;
2270    NumCharInCluster = Cluster->SampleCount;
2271    NumIllegalInCluster = 0;
2272    if (Clusterer->NumChar > CharFlags.size()) {
2273      CharFlags.resize(Clusterer->NumChar);
2274    }
2275    for (auto &CharFlag : CharFlags) {
2276      CharFlag = false;
2277    }
2278    InitSampleSearch(SearchState, Cluster);
2279    while ((Sample = NextSample(&SearchState)) != nullptr) {
2280      CharID = Sample->CharID;
2281      if (CharFlags[CharID] == false) {
2282        CharFlags[CharID] = true;
2283      } else {
2284        if (CharFlags[CharID] == true) {
2285          NumIllegalInCluster++;
2286          CharFlags[CharID] = ILLEGAL_CHAR;
2287        }
2288        NumCharInCluster--;
2289        PercentIllegal = static_cast<float>(NumIllegalInCluster) / NumCharInCluster;
2290        if (PercentIllegal > MaxIllegal) {
2291          destroy(SearchState);
2292          return true;
2293        }
2294      }
2295    }
2296    return false;
2297  } 
2298  static double InvertMatrix(const float *input, int size, float *inv) {
2299    GENERIC_2D_ARRAY<double> U(size, size, 0.0);
2300    GENERIC_2D_ARRAY<double> U_inv(size, size, 0.0);
2301    GENERIC_2D_ARRAY<double> L(size, size, 0.0);
2302    int row;
2303    int col;
2304    for (row = 0; row < size; row++) {
2305      for (col = 0; col < size; col++) {
2306        U[row][col] = input[row * size + col];
2307        L[row][col] = row == col ? 1.0 : 0.0;
2308        U_inv[row][col] = 0.0;
2309      }
2310    }
2311    for (col = 0; col < size; ++col) {
2312      int best_row = 0;
2313      double best_pivot = -1.0;
2314      for (row = col; row < size; ++row) {
2315        if (Abs(U[row][col]) > best_pivot) {
2316          best_pivot = Abs(U[row][col]);
2317          best_row = row;
2318        }
2319      }
2320      if (best_row != col) {
2321        for (int k = 0; k < size; ++k) {
2322          double tmp = U[best_row][k];
2323          U[best_row][k] = U[col][k];
2324          U[col][k] = tmp;
2325          tmp = L[best_row][k];
2326          L[best_row][k] = L[col][k];
2327          L[col][k] = tmp;
2328        }
2329      }
2330      for (row = col + 1; row < size; ++row) {
2331        double ratio = -U[row][col] / U[col][col];
2332        for (int j = col; j < size; ++j) {
2333          U[row][j] += U[col][j] * ratio;
2334        }
2335        for (int k = 0; k < size; ++k) {
2336          L[row][k] += L[col][k] * ratio;
2337        }
2338      }
2339    }
2340    for (col = 0; col < size; ++col) {
2341      U_inv[col][col] = 1.0 / U[col][col];
2342      for (row = col - 1; row >= 0; --row) {
2343        double total = 0.0;
2344        for (int k = col; k > row; --k) {
2345          total += U[row][k] * U_inv[k][col];
2346        }
2347        U_inv[row][col] = -total / U[row][row];
2348      }
2349    }
2350    for (row = 0; row < size; row++) {
2351      for (col = 0; col < size; col++) {
2352        double sum = 0.0;
2353        for (int k = row; k < size; ++k) {
2354          sum += U_inv[row][k] * L[k][col];
2355        }
2356        inv[row * size + col] = sum;
2357      }
2358    }
2359    double error_sum = 0.0;
2360    for (row = 0; row < size; row++) {
2361      for (col = 0; col < size; col++) {
2362        double sum = 0.0;
2363        for (int k = 0; k < size; ++k) {
2364          sum += static_cast<double>(input[row * size + k]) * inv[k * size + col];
2365        }
2366        if (row != col) {
2367          error_sum += Abs(sum);
2368        }
2369      }
2370    }
2371    return error_sum;
2372  }
2373  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cluster.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cluster.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1589      if (Proto != nullptr) {
1590        delete Statistics;
1591        return Proto;
1592      }
1593    }
</pre></code></div>
                <div class="column column_space"><pre><code>1589      if (Proto != nullptr) {
1590        delete Statistics;
1591        return Proto;
1592      }
1593    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    