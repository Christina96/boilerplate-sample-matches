<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for BaseTagHDF5.cpp & MultiTagHDF5.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for BaseTagHDF5.cpp & MultiTagHDF5.cpp
      </h3>
      <h1 align="center">
        13.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>BaseTagHDF5.cpp (10.646388%)<TH>MultiTagHDF5.cpp (16.969696%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1040-0.html#0',2,'match1040-1.html#0',3)" NAME="0">(32-38)<TD><A HREF="javascript:ZweiFrames('match1040-0.html#0',2,'match1040-1.html#0',3)" NAME="0">(31-37)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1040-0.html#1',2,'match1040-1.html#1',3)" NAME="1">(27-31)<TD><A HREF="javascript:ZweiFrames('match1040-0.html#1',2,'match1040-1.html#1',3)" NAME="1">(26-30)</A><TD ALIGN=center><FONT COLOR="#dd0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTagHDF5.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &quot;BaseTagHDF5.hpp&quot;
#include &lt;nix/NDArray.hpp&gt;
#include &lt;nix/util/util.hpp&gt;
#include &quot;DataArrayHDF5.hpp&quot;
#include &quot;BlockHDF5.hpp&quot;
#include &quot;FeatureHDF5.hpp&quot;

using namespace nix::base;

namespace nix {
namespace hdf5 {


BaseTagHDF5::BaseTagHDF5(const std::shared_ptr&lt;IFile&gt; &amp;file, const std::shared_ptr&lt;IBlock&gt; &amp;block, const H5Group &amp;group)
    : EntityWithSourcesHDF5(file, block, group)
<A NAME="1"></A>{
    feature_group = this-&gt;group().openOptGroup(&quot;features&quot;);
    refs_group = this-&gt;group().openOptGroup(&quot;references&quot;);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1040-1.html#1',3,'match1040-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

<A NAME="0"></A>
BaseTagHDF5::BaseTagHDF5(const std::shared_ptr&lt;IFile&gt; &amp;file, const std::shared_ptr&lt;IBlock&gt; &amp;block, const H5Group &amp;group,
                         const std::string &amp;id, const std::string &amp;type, const std::string &amp;name)</B></FONT>
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1040-1.html#0',3,'match1040-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    : BaseTagHDF5(file, block, group, id, type, name, util::getTime())
{
}


BaseTagHDF5::BaseTagHDF5(const std::shared_ptr&lt;IFile&gt; &amp;file, const std::shared_ptr&lt;IBlock&gt; &amp;block, const H5Group &amp;group,
                         const std::string &amp;id, const std::string &amp;type, const std::string &amp;name, time_t time)</B></FONT>
    : EntityWithSourcesHDF5(file, block, group, id, type, name, time)
{
    feature_group = this-&gt;group().openOptGroup(&quot;features&quot;);
    refs_group = this-&gt;group().openOptGroup(&quot;references&quot;);
}

//--------------------------------------------------
// Methods concerning references.
//--------------------------------------------------

bool BaseTagHDF5::hasReference(const std::string &amp;name_or_id) const {
    std::string id = block()-&gt;resolveEntityId({name_or_id, ObjectType::DataArray});
    return refs_group(false) ? refs_group(false)-&gt;hasGroup(id) : false;
}


ndsize_t BaseTagHDF5::referenceCount() const {
    boost::optional&lt;H5Group&gt; g = refs_group(false);
    return g ? g-&gt;objectCount() : size_t(0);
}


std::shared_ptr&lt;IDataArray&gt;  BaseTagHDF5::getReference(const std::string &amp;name_or_id) const {
    std::shared_ptr&lt;IDataArray&gt; da;
    boost::optional&lt;H5Group&gt; g = refs_group(false);

    std::string id = block()-&gt;resolveEntityId({name_or_id, ObjectType::DataArray});
    if (g &amp;&amp; hasReference(id)) {
        H5Group group = g-&gt;openGroup(id);
        da = std::make_shared&lt;DataArrayHDF5&gt;(file(), block(), group);
    }

    return da;
}

std::shared_ptr&lt;IDataArray&gt;  BaseTagHDF5::getReference(ndsize_t index) const {
    boost::optional&lt;H5Group&gt; g = refs_group(false);
    std::string id = g ? g-&gt;objectName(index) : &quot;&quot;;
    return getReference(id);
}

void BaseTagHDF5::addReference(const std::string &amp;name_or_id) {
    boost::optional&lt;H5Group&gt; g = refs_group(true);

    if (!block()-&gt;hasEntity({name_or_id, ObjectType::DataArray}))
        throw std::runtime_error(&quot;BaseTagHDF5::addReference: DataArray not found in block!&quot;);

    auto target = std::dynamic_pointer_cast&lt;DataArrayHDF5&gt;(block()-&gt;getEntity({name_or_id, ObjectType::DataArray}));

    g-&gt;createLink(target-&gt;group(), target-&gt;id());
}


bool BaseTagHDF5::removeReference(const std::string &amp;name_or_id) {
    boost::optional&lt;H5Group&gt; g = refs_group(false);
    bool removed = false;

    if (g &amp;&amp; hasReference(name_or_id)) {
        std::shared_ptr&lt;IDataArray&gt; reference = getReference(name_or_id);

        g-&gt;removeGroup(reference-&gt;id());
        removed = true;
    }

    return removed;
}


void BaseTagHDF5::references(const std::vector&lt;DataArray&gt; &amp;refs_new) {
    while (referenceCount() &gt; 0) {
        removeReference(getReference(0)-&gt;id());
    }

    for (const auto &amp;ref : refs_new) {
        addReference(ref.id());
    }
}

//--------------------------------------------------
// Methods concerning features.
//--------------------------------------------------

bool BaseTagHDF5::hasFeature(const std::string &amp;name_or_id) const {
    return getFeature(name_or_id) != nullptr;
}


ndsize_t BaseTagHDF5::featureCount() const {
    boost::optional&lt;H5Group&gt; g = feature_group(false);
    return g ? g-&gt;objectCount() : size_t(0);
}


std::shared_ptr&lt;IFeature&gt; BaseTagHDF5::getFeature(const std::string &amp;name_or_id) const {
    std::shared_ptr&lt;FeatureHDF5&gt; feature;
    boost::optional&lt;H5Group&gt; g = feature_group(false);

    if (g) {
        boost::optional&lt;H5Group&gt; group = g-&gt;findGroupByNameOrAttribute(&quot;name&quot;, name_or_id);
        if (group)
            feature = std::make_shared&lt;FeatureHDF5&gt;(file(), block(), group.get());
        else {
            for (ndsize_t i = 0; i &lt; g-&gt;objectCount(); i++) {
                H5Group gr = g-&gt;openGroup(g-&gt;objectName(i), false);
                std::shared_ptr&lt;FeatureHDF5&gt; feat = std::make_shared&lt;FeatureHDF5&gt;(file(), block(), gr);
                std::shared_ptr&lt;base::IDataArray&gt; da = feat-&gt;data();
                if (da-&gt;name() == name_or_id || da-&gt;id() == name_or_id) {
                    feature = std::make_shared&lt;FeatureHDF5&gt;(file(), block(), gr);
                    break;
                }
            }
        }
    }
    return feature;
}


std::shared_ptr&lt;IFeature&gt;  BaseTagHDF5::getFeature(ndsize_t index) const {
    boost::optional&lt;H5Group&gt; g = feature_group(false);
    std::string id = g-&gt;objectName(index);
    return getFeature(id);
}


std::shared_ptr&lt;IFeature&gt;  BaseTagHDF5::createFeature(const std::string &amp;name_or_id, LinkType link_type) {
    if(!block()-&gt;hasEntity({name_or_id, ObjectType::DataArray})) {
        throw std::runtime_error(&quot;DataArray not found in Block!&quot;);
    }
    std::string rep_id = util::createId();
    boost::optional&lt;H5Group&gt; g = feature_group(true);

    H5Group group = g-&gt;openGroup(rep_id, true);
    DataArray data = std::dynamic_pointer_cast&lt;IDataArray&gt;(block()-&gt;getEntity({name_or_id, ObjectType::DataArray}));
    return std::make_shared&lt;FeatureHDF5&gt;(file(), block(), group, rep_id, data, link_type);
}


bool BaseTagHDF5::deleteFeature(const std::string &amp;name_or_id) {
    boost::optional&lt;H5Group&gt; g = feature_group(false);
    bool deleted = false;

    if (g &amp;&amp; hasFeature(name_or_id)) {
        std::shared_ptr&lt;IFeature&gt; feature = getFeature(name_or_id);

        g-&gt;removeGroup(feature-&gt;id());
        deleted = true;
    }

    return deleted;
}


BaseTagHDF5::~BaseTagHDF5() {}

} // ns nix::hdf5
} // ns nix
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>MultiTagHDF5.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &quot;MultiTagHDF5.hpp&quot;

#include &lt;nix/NDArray.hpp&gt;
#include &lt;nix/util/util.hpp&gt;
#include &quot;DataArrayHDF5.hpp&quot;
#include &quot;BlockHDF5.hpp&quot;
#include &quot;FeatureHDF5.hpp&quot;

using namespace nix::base;

namespace nix {
namespace hdf5 {


<A NAME="1"></A>MultiTagHDF5::MultiTagHDF5(const std::shared_ptr&lt;IFile&gt; &amp;file, const std::shared_ptr&lt;IBlock&gt; &amp;block, const H5Group &amp;group)
    : BaseTagHDF5(file, block, group)
{
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1040-0.html#1',2,'match1040-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

<A NAME="0"></A>
MultiTagHDF5::MultiTagHDF5(const std::shared_ptr&lt;IFile&gt; &amp;file, const std::shared_ptr&lt;IBlock&gt; &amp;block, const H5Group &amp;group,
                           const std::string &amp;id, const std::string &amp;type, const std::string &amp;name, const DataArray &amp;positions)</B></FONT>
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1040-0.html#0',2,'match1040-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    : MultiTagHDF5(file, block, group, id, type, name, positions, util::getTime())
{
}


MultiTagHDF5::MultiTagHDF5(const std::shared_ptr&lt;IFile&gt; &amp;file, const std::shared_ptr&lt;IBlock&gt; &amp;block, const H5Group &amp;group,
                           const std::string &amp;id, const std::string &amp;type, const std::string &amp;name,</B></FONT>
                           const DataArray &amp;positions, time_t time)
    : BaseTagHDF5(file, block, group, id, type, name, time)
{
    // TODO: the line below currently throws an exception if positions is
    // not in block - to consider if we prefer copying it to the block
    this-&gt;positions(positions.id());
}


std::shared_ptr&lt;IDataArray&gt; MultiTagHDF5::positions() const {
    std::shared_ptr&lt;IDataArray&gt; da;
    bool error = false;

    if (group().hasGroup(&quot;positions&quot;)) {
        H5Group other_group = group().openGroup(&quot;positions&quot;, false);
        da = std::make_shared&lt;DataArrayHDF5&gt;(file(), block(), other_group);
        if (!block()-&gt;getEntity(da))
            error = true;
    }
    else error = true;

    // NOTE: we check that link exists in both places, here &amp; in entity
    // if error = true it was missing in one of the two
    if (error)
        throw std::runtime_error(&quot;MultiTagHDF5::positions: DataArray not found!&quot;);

    return da;
}


void MultiTagHDF5::positions(const std::string &amp;name_or_id) {
    std::shared_ptr&lt;IDataArray&gt; ida = block()-&gt;getEntity&lt;IDataArray&gt;(name_or_id);
    if (!ida)
        throw std::runtime_error(&quot;MultiTagHDF5::positions: DataArray not found in block!&quot;);
    if (group().hasGroup(&quot;positions&quot;))
        group().removeGroup(&quot;positions&quot;);

    auto target = std::dynamic_pointer_cast&lt;DataArrayHDF5&gt;(ida);

    group().createLink(target-&gt;group(), &quot;positions&quot;);
    forceUpdatedAt();
}


bool MultiTagHDF5::hasPositions() const {
    // NOTE: other than in positions getter here we do not check that the
    // positions DataArray also exists in block - we just say it does here
    return group().hasGroup(&quot;positions&quot;);
}


std::shared_ptr&lt;IDataArray&gt;  MultiTagHDF5::extents() const {
    std::shared_ptr&lt;IDataArray&gt; da;
    bool error = false;

    if (group().hasGroup(&quot;extents&quot;)) {
        H5Group other_group = group().openGroup(&quot;extents&quot;, false);
        da = std::make_shared&lt;DataArrayHDF5&gt;(file(), block(), other_group);
        if (!block()-&gt;hasEntity(da))
            error = true;
    }

    // NOTE: we check that link exists in parent entity: if error, it was missing there
    if (error)
        throw std::runtime_error(&quot;MultiTagHDF5::extents: DataArray not found!&quot;);

    return da;
}


void MultiTagHDF5::extents(const std::string &amp;name_or_id) {
    std::shared_ptr&lt;IDataArray&gt; ida = block()-&gt;getEntity&lt;IDataArray&gt;(name_or_id);

    if (!ida)
        throw std::runtime_error(&quot;MultiTagHDF5::extents: DataArray not found in block!&quot;);
    if (group().hasGroup(&quot;extents&quot;))
        group().removeGroup(&quot;extents&quot;);

    if (!checkDimensions(ida, positions()))
        throw std::runtime_error(&quot;MultiTagHDF5::extents: cannot set Extent because dimensionality of extent and position data do not match!&quot;);
    auto target = std::dynamic_pointer_cast&lt;DataArrayHDF5&gt;(ida);

    group().createLink(target-&gt;group(), &quot;extents&quot;);
    forceUpdatedAt();
}

void MultiTagHDF5::extents(const none_t t) {
    if (group().hasGroup(&quot;extents&quot;)) {
        group().removeGroup(&quot;extents&quot;);
    }
    forceUpdatedAt();
}


std::vector&lt;std::string&gt; MultiTagHDF5::units() const {
    std::vector&lt;std::string&gt; units;
    group().getData(&quot;units&quot;, units);
    return units;
}


void MultiTagHDF5::units(const std::vector&lt;std::string&gt; &amp;units) {
    group().setData(&quot;units&quot;, units);
    forceUpdatedAt();
}


void MultiTagHDF5::units(const none_t t) {
    if (group().hasData(&quot;units&quot;)) {
        group().removeData(&quot;units&quot;);
    }
    forceUpdatedAt();
}


bool MultiTagHDF5::checkDimensions(const DataArray &amp;a, const DataArray &amp;b)const {
    return a.dataExtent() == b.dataExtent();
}


MultiTagHDF5::~MultiTagHDF5() {}

} // ns nix::hdf5
} // ns nix
</PRE>
</div>
  </div>
</body>
</html>
