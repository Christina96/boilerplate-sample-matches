
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 38, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</h3>
            <pre><code>1  TStr TModeNet::GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const {
2    TStr Cpy(CrossName);
3    if (!isDir || !sameMode) { return Cpy; }
4    if (isOutEdge) {
5      Cpy += ":SRC";
6    } else {
7      Cpy += ":DST";
8    }
9    return Cpy;
10  }
11  void TModeNet::ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir) {
12    TStr Name = GetNeighborCrossName(CrossNetName, outEdge, sameMode, isDir);
13    TInt location = CheckDenseOrSparseN(Name);
14    int index = KeyToIndexTypeN.GetDat(Name).Val2;
15    if (location == 1) {
16      TVec<TIntV> Attrs(MxNId);
17      VecOfIntVecVecsN[index] = Attrs;
18    } else {
19      THash<TInt, TIntV> Attrs;
20      VecOfIntHashVecsN[index] = Attrs;
21    }
22  }
23  void TModeNet::Clr() {
24    TStrV CNets;
25    NeighborTypes.GetKeyV(CNets);
26    for (int i=0; i < CNets.Len(); i++) {
27      MMNet->GetCrossNetByName(CNets[i]).Clr();
28    }
29    TNEANet::Clr();
30  }
31  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const int linkId, const bool sameMode, bool isDir){
32    TStr CrossName = MMNet->GetCrossName(linkId);
33    return AddNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
34  }
35  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
36    if (!NeighborTypes.IsKey(CrossName)) {
37      AddNbrType(CrossName, sameMode, isDir);
38    }
39    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
40    return AppendIntVAttrDatN(NId, EId, Name); 
41  }
42  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
43    if (!NeighborTypes.IsKey(CrossName)) {
44      return -1;
45    }
46    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
47    return DelFromIntVAttrDatN(NId, EId, Name);
48  }
49  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir){
50    TStr CrossName = MMNet->GetCrossName(linkId);
51    return DelNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
52  }
53  void TModeNet::DelNode(const int& NId) {
54    TStrV Names;
55    GetCrossNetNames(Names);
56    for (int i=0; i < Names.Len(); i++) {
57      TCrossNet& Cross = MMNet->GetCrossNetByName(Names[i]);
58      TIntV OutEIds;
59      GetNeighborsByCrossNet(NId, Names[i], OutEIds, true);
60      for (int j=0; j < OutEIds.Len(); j++) {
61        Cross.DelEdge(OutEIds[j].Val);
62      }
63      if (Cross.IsDirect && Cross.Mode1 == Cross.Mode2) {
64        TIntV InEIds;
65        GetNeighborsByCrossNet(NId, Names[i], InEIds, false);
66        for (int j=0; j < InEIds.Len(); j++) {
67          Cross.DelEdge(InEIds[j].Val);
68        }
69      }
70    }
71    TNEANet::DelNode(NId);
72  }
73  void TModeNet::SetParentPointer(TMMNet* parent) {
74    MMNet = parent;
75  }
76  int TModeNet::AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir) {
77    if (NeighborTypes.IsKey(CrossName)) { return -1; } 
78    bool hasSingleVector = (!isDir || !sameMode);
79    NeighborTypes.AddDat(CrossName, hasSingleVector);
80    return 0;
81  }
82  int TModeNet::DelNbrType(const TStr& CrossName) {
83    bool hasSingleVector = NeighborTypes.GetDat(CrossName);
84    NeighborTypes.DelKey(CrossName);
85    if (hasSingleVector) {
86      return DelAttrN(CrossName);
87    } else {
88      TStr InName = GetNeighborCrossName(CrossName, true, true, true);
89      TStr OutName = GetNeighborCrossName(CrossName, false, true, true);
90      if (DelAttrN(InName) == -1 || DelAttrN(OutName) == -1) {
91        return -1;
92      }
93    }
94    return 0;
95  }
96  void TModeNet::GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId) const{
97    TBool hasSingleVector = NeighborTypes.GetDat(Name);
98    if (hasSingleVector) {
99      Neighbors = GetIntVAttrDatN(NId, Name);
100    } else {
101      TStr DirectionalName = GetNeighborCrossName(Name, isOutEId, true, true);
102      Neighbors = GetIntVAttrDatN(NId, DirectionalName);
103    }
104  }
105  int TModeNet::AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense){
106    TInt CurrLen;
107    if (UseDense) {
108      CurrLen = VecOfIntVecVecsN.Len();
109      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
110      KeyToDenseN.AddDat(attr, true);
111      VecOfIntVecVecsN.Add(Attrs);
112    } else {
113      THash<TInt, TIntV> NewHash;
114      CurrLen = VecOfIntHashVecsN.Len();
115      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
116      KeyToDenseN.AddDat(attr, false);
117      for (int i=0; i< Attrs.Len(); i++) {
118        NewHash.AddDat(i, Attrs[i]);
119      }
120      VecOfIntHashVecsN.Add(NewHash);
121    }
122    return 0;
123  }
124  int TModeNet::AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs){
125    TInt CurrLen;
126    THash<TInt, TIntV> NewHash;
127    CurrLen = VecOfIntHashVecsN.Len();
128    KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
129    KeyToDenseN.AddDat(attr, false);
130    for (int i=0; i< Attrs.Len(); i++) {
131      NewHash.AddDat(i, Attrs[i]);
132    }
133    VecOfIntHashVecsN.Add(NewHash);
134    return 0;
135  }
136  void TModeNet::RemoveCrossNets(TModeNet& Result, TStrV& CrossNets) {
137    const TModeNet& self = *this;
138    Result = TModeNet(self, false);
139    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
140      TStr AttrName = it.GetKey();
141      TInt AttrType = it.GetDat().GetVal1();
142      TInt AttrIndex = it.GetDat().GetVal2();
143      if (AttrType != IntVType) {
144        Result.KeyToIndexTypeN.AddDat(AttrName, it.GetDat());
145      } else {
146        TStr WithoutSuffix = AttrName;
147        bool removeSuffix = false;
148        if (AttrName.IsSuffix(":SRC") || AttrName.IsSuffix(":DST")) {
149          WithoutSuffix = AttrName.GetSubStr(0, AttrName.Len()-5);
150          removeSuffix = true;
151        }
152        bool isSingleVNbrAttr = (NeighborTypes.IsKey(AttrName) && NeighborTypes.GetDat(AttrName));
153        bool isMultiVNbrAttr = (removeSuffix && NeighborTypes.IsKey(WithoutSuffix) && !NeighborTypes.GetDat(WithoutSuffix));
154        if (isSingleVNbrAttr || isMultiVNbrAttr) {
155          TStr NbrName = isSingleVNbrAttr ? AttrName : WithoutSuffix;
156          if (CrossNets.IsIn(NbrName)) {
157            Result.AddNbrType(NbrName, removeSuffix, removeSuffix);
158            TInt location = CheckDenseOrSparseN(AttrName);
159            if (location == 1) {
160              TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
161              Result.AddIntVAttrByVecN(AttrName, Attrs);
162            } else {
163              THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
164              Result.AddIntVAttrByHashN(AttrName, Attrs);
165            }
166          }
167        } else {
168          TInt location = CheckDenseOrSparseN(AttrName);
169          if (location == 1) {
170            TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
171            Result.AddIntVAttrByVecN(AttrName, Attrs);
172          } else {
173            THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
174            Result.AddIntVAttrByHashN(AttrName, Attrs);
175          }
176        }
177      }
178    }
179  }
180  int TModeNet::GetAttrTypeN(const TStr& attr) const {
181    if (KeyToIndexTypeN.IsKey(attr)) {
182      return KeyToIndexTypeN.GetDat(attr).Val1;
183    }
184    return -1;
185  }
186  int TCrossNet::GetAttrTypeE(const TStr& attr) const {
187    if (KeyToIndexTypeE.IsKey(attr)) {
188      return KeyToIndexTypeE.GetDat(attr).Val1;
189    }
190    return -1;
191  }
192  void TCrossNet::Clr() {
193    CrossH.Clr();
194    MxEId=0;
195    KeyToIndexTypeE.Clr();
196    IntDefaultsE.Clr();
197    StrDefaultsE.Clr();
198    FltDefaultsE.Clr();
199    VecOfIntVecsE.Clr();
200    VecOfStrVecsE.Clr();
201    VecOfFltVecsE.Clr(); 
202    Net->ClrNbr(Mode1, CrossNetId, true, Mode1==Mode2, IsDirect.Val);
203    Net->ClrNbr(Mode2, CrossNetId, false, Mode1==Mode2, IsDirect.Val); 
204  }
205  int TCrossNet::AddEdge(const int& sourceNId, const int& destNId, int EId){
206    if (EId == -1) { EId = MxEId;  MxEId++; }
207    else { MxEId = TMath::Mx(EId+1, MxEId()); }
208    if (Net != NULL) {
209      TModeNet& M1 = Net->TModeNetH.GetDat(this->Mode1);
210      TModeNet& M2 = Net->TModeNetH.GetDat(this->Mode2);
211      if (!M1.IsNode(sourceNId) || !M2.IsNode(destNId)) { return -1; }
212      TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
213      M1.AddNeighbor(sourceNId, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
214      M2.AddNeighbor(destNId, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
215    }
216    TCrossNet::TCrossEdge newEdge(EId, sourceNId, destNId);
217    CrossH.AddDat(EId, newEdge);
218    int i;
219    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
220      TVec<TInt>& IntVec = VecOfIntVecsE[i];
221      int KeyId = CrossH.GetKeyId(EId);
222      if (IntVec.Len() > KeyId) {
223        IntVec[KeyId] = TInt::Mn;
224      } else {
225        IntVec.Ins(KeyId, TInt::Mn);
226      }
227    }
228    TVec<TStr> DefIntVec = TVec<TStr>();
229    IntDefaultsE.GetKeyV(DefIntVec);
230    for (i = 0; i < DefIntVec.Len(); i++) {
231      TStr attr = DefIntVec[i];
232      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
233      IntVec[CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
234    }
235    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
236      TVec<TStr>& StrVec = VecOfStrVecsE[i];
237      int KeyId = CrossH.GetKeyId(EId);
238      if (StrVec.Len() > KeyId) {
239        StrVec[KeyId] = TStr::GetNullStr();
240      } else {
241        StrVec.Ins(KeyId, TStr::GetNullStr());
242      }
243    }
244    TVec<TStr> DefStrVec = TVec<TStr>();
245    StrDefaultsE.GetKeyV(DefStrVec);
246    for (i = 0; i < DefStrVec.Len(); i++) {
247      TStr attr = DefStrVec[i];
248      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
249      StrVec[CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
250    }
251    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
252      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
253      int KeyId = CrossH.GetKeyId(EId);
254      if (FltVec.Len() > KeyId) {
255        FltVec[KeyId] = TFlt::Mn;
256      } else {
257        FltVec.Ins(KeyId, TFlt::Mn);
258      }
259    }
260    TVec<TStr> DefFltVec = TVec<TStr>();
261    FltDefaultsE.GetKeyV(DefFltVec);
262    for (i = 0; i < DefFltVec.Len(); i++) {
263      TStr attr = DefFltVec[i];
264      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
265      FltVec[CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
266    }
267    return EId;
268  }
269  int TCrossNet::DelEdge(const int& EId) {
270    TCrossEdge& Edge = CrossH.GetDat(EId);
271    int srcNode = Edge.SrcNId;
272    int dstNode = Edge.DstNId;
273    TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
274    Net->GetModeNetById(this->Mode1).DelNeighbor(srcNode, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
275    Net->GetModeNetById(this->Mode2).DelNeighbor(dstNode, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
276    int i;
277    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
278      TVec<TInt>& IntVec = VecOfIntVecsE[i];
279      IntVec[CrossH.GetKeyId(EId)] =  TInt::Mn;
280    }
281    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
282      TVec<TStr>& StrVec = VecOfStrVecsE[i];
283      StrVec[CrossH.GetKeyId(EId)] =  TStr::GetNullStr();
284    }
285    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
286      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
287      FltVec[CrossH.GetKeyId(EId)] = TFlt::Mn;
288    }
289    CrossH.DelKey(EId);
290    return 0;
291  }
292  void TCrossNet::SetParentPointer(TMMNet* parent) {
293    Net = parent;
294  }
295  void TCrossNet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
296    Names = TVec<TStr>();
297    while (!CrossHI.IsEnd()) {
298      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
299        Names.Add(CrossHI.GetKey());
300      }
301      CrossHI++;
302    }  
303  }
304  void TCrossNet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
305    Values = TVec<TStr>();
306    while (!CrossHI.IsEnd()) {
307      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
308        Values.Add(GetEdgeAttrValue(EId, CrossHI));
309      }
310      CrossHI++;
311    }  
312  }
313  void TCrossNet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
314    Names = TVec<TStr>();
315    while (!CrossHI.IsEnd()) {
316      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
317        Names.Add(CrossHI.GetKey());
318      }
319      CrossHI++;
320    }  
321  }
322  void TCrossNet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const {
323    Values = TVec<TInt>();
324    while (!CrossHI.IsEnd()) {
325      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
326        TInt val = (this->VecOfIntVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
327        Values.Add(val);
328      }
329      CrossHI++;
330    }  
331  }
332  void TCrossNet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
333    Names = TVec<TStr>();
334    while (!CrossHI.IsEnd()) {
335      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
336        Names.Add(CrossHI.GetKey());
337      }
338      CrossHI++;
339    }  
340  }
341  void TCrossNet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
342    Values = TVec<TStr>();
343    while (!CrossHI.IsEnd()) {
344      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
345        TStr val = this->VecOfStrVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId);
346        Values.Add(val);
347      }
348      CrossHI++;
349    }  
350  }
351  void TCrossNet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
352    Names = TVec<TStr>();
353    while (!CrossHI.IsEnd()) {
354      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
355        Names.Add(CrossHI.GetKey());
356      }
357      CrossHI++;
358    }  
359  }
360  void TCrossNet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const {
361    Values = TVec<TFlt>();
362    while (!CrossHI.IsEnd()) {
363      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
364        TFlt val = (this->VecOfFltVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
365        Values.Add(val);
366      }
367      CrossHI++;
368    }  
369  }
370  bool TCrossNet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
371    bool IntDel = IsIntAttrDeletedE(EId, attr);
372    bool StrDel = IsStrAttrDeletedE(EId, attr);
373    bool FltDel = IsFltAttrDeletedE(EId, attr);
374    return IntDel || StrDel || FltDel;
375  }
376  bool TCrossNet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
377    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
378  }
379  bool TCrossNet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
380    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
381  }
382  bool TCrossNet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
383    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
384  }
385  bool TCrossNet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
386    bool IntDel = EdgeAttrIsIntDeleted(EId, CrossHI);
387    bool StrDel = EdgeAttrIsStrDeleted(EId, CrossHI);
388    bool FltDel = EdgeAttrIsFltDeleted(EId, CrossHI);
389    return IntDel || StrDel || FltDel;
390  }
391  bool TCrossNet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
392    return (CrossHI.GetDat().Val1 == IntType &&
393      GetIntAttrDefaultE(CrossHI.GetKey()) == this->VecOfIntVecsE.GetVal(
394      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
395  }
396  bool TCrossNet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
397    return (CrossHI.GetDat().Val1 == StrType &&
398      GetStrAttrDefaultE(CrossHI.GetKey()) == this->VecOfStrVecsE.GetVal(
399      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
400  }
401  bool TCrossNet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
402    return (CrossHI.GetDat().Val1 == FltType &&
403      GetFltAttrDefaultE(CrossHI.GetKey()) == this->VecOfFltVecsE.GetVal(
404      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
405  }
406  TStr TCrossNet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
407    if (CrossHI.GetDat().Val1 == IntType) {
408      return (this->VecOfIntVecsE.GetVal(
409        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
410    } else if(CrossHI.GetDat().Val1 == StrType) {
411      return this->VecOfStrVecsE.GetVal(
412      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId));
413    } else if (CrossHI.GetDat().Val1 == FltType) {
414      return (this->VecOfFltVecsE.GetVal(
415        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
416    }
417    return TStr::GetNullStr();
418  }
419  int TCrossNet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
420    int i;
421    TInt CurrLen;
422    if (!IsEdge(EId)) {
423       return -1;
424    }
425    if (KeyToIndexTypeE.IsKey(attr)) {
426      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
427      NewVec[CrossH.GetKeyId(EId)] = value;
428    } else {
429      CurrLen = VecOfIntVecsE.Len();
430      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
431      TVec<TInt> NewVec = TVec<TInt>();
432      for (i = 0; i < MxEId; i++) {
433        NewVec.Ins(i, GetIntAttrDefaultE(attr));
434      }
435      NewVec[CrossH.GetKeyId(EId)] = value;
436      VecOfIntVecsE.Add(NewVec);
437    }
438    return 0;
439  }
440  int TCrossNet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
441    int i;
442    TInt CurrLen;
443    if (!IsEdge(EId)) {
444       return -1;
445    }
446    if (KeyToIndexTypeE.IsKey(attr)) {
447      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
448      NewVec[CrossH.GetKeyId(EId)] = value;
449    } else {
450      CurrLen = VecOfStrVecsE.Len();
451      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
452      TVec<TStr> NewVec = TVec<TStr>();
453      for (i = 0; i < MxEId; i++) {
454        NewVec.Ins(i, GetStrAttrDefaultE(attr));
455      }
456      NewVec[CrossH.GetKeyId(EId)] = value;
457      VecOfStrVecsE.Add(NewVec);
458    }
459    return 0;
460  } 
461  int TCrossNet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
462    int i;
463    TInt CurrLen;
464    if (!IsEdge(EId)) {
465       return -1;
466    }
467    if (KeyToIndexTypeE.IsKey(attr)) {
468      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
469      NewVec[CrossH.GetKeyId(EId)] = value;
470    } else {
471      CurrLen = VecOfFltVecsE.Len();
472      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
473      TVec<TFlt> NewVec = TVec<TFlt>();
474      for (i = 0; i < MxEId; i++) {
475        NewVec.Ins(i, GetFltAttrDefaultE(attr));
476      }
477      NewVec[CrossH.GetKeyId(EId)] = value;
478      VecOfFltVecsE.Add(NewVec);
479    }
480    return 0;
481  }
482  TInt TCrossNet::GetIntAttrDatE(const int& EId, const TStr& attr) {
483    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
484  }
485  TStr TCrossNet::GetStrAttrDatE(const int& EId, const TStr& attr) {
486    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
487  }
488  TFlt TCrossNet::GetFltAttrDatE(const int& EId, const TStr& attr) {
489    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
490  }
491  int TCrossNet::DelAttrDatE(const int& EId, const TStr& attr) {
492    TInt vecType = KeyToIndexTypeE(attr).Val1;
493    if (vecType == IntType) {
494      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
495    } else if (vecType == StrType) {
496      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
497    } else if (vecType == FltType) {
498      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
499    } else {
500      return -1;
501    }
502    return 0;
503  }
504  int TCrossNet::AddIntAttrE(const TStr& attr, TInt defaultValue){
505    int i;
506    TInt CurrLen;
507    TVec<TInt> NewVec;
508    CurrLen = VecOfIntVecsE.Len();
509    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
510    NewVec = TVec<TInt>();
511    for (i = 0; i < MxEId; i++) {
512      NewVec.Ins(i, defaultValue);
513    }
514    VecOfIntVecsE.Add(NewVec);
515    if (!IntDefaultsE.IsKey(attr)) {
516      IntDefaultsE.AddDat(attr, defaultValue);
517    } else {
518      return -1;
519    }
520    return 0;
521  }
522  int TCrossNet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
523    int i;
524    TInt CurrLen;
525    TVec<TStr> NewVec;
526    CurrLen = VecOfStrVecsE.Len();
527    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
528    NewVec = TVec<TStr>();
529    for (i = 0; i < MxEId; i++) {
530      NewVec.Ins(i, defaultValue);
531    }
532    VecOfStrVecsE.Add(NewVec);
533    if (!StrDefaultsE.IsKey(attr)) {
534      StrDefaultsE.AddDat(attr, defaultValue);
535    } else {
536      return -1;
537    }
538    return 0;
539  }
540  int TCrossNet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
541    int i;
542    TInt CurrLen;
543    TVec<TFlt> NewVec;
544    CurrLen = VecOfFltVecsE.Len();
545    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
546    NewVec = TVec<TFlt>();
547    for (i = 0; i < MxEId; i++) {
548      NewVec.Ins(i, defaultValue);
549    }
550    VecOfFltVecsE.Add(NewVec);
551    if (!FltDefaultsE.IsKey(attr)) {
552      FltDefaultsE.AddDat(attr, defaultValue);
553    } else {
554      return -1;
555    }
556    return 0;
557  }
558  int TCrossNet::DelAttrE(const TStr& attr) {
559    TInt vecType = KeyToIndexTypeE(attr).Val1;
560    if (vecType == IntType) {
561      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
562      if (IntDefaultsE.IsKey(attr)) {
563        IntDefaultsE.DelKey(attr);
564      }
565    } else if (vecType == StrType) {
566      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
567      if (StrDefaultsE.IsKey(attr)) {
568        StrDefaultsE.DelKey(attr);
569      }  
570    } else if (vecType == FltType) {
571      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
572      if (FltDefaultsE.IsKey(attr)) {
573        FltDefaultsE.DelKey(attr);
574      }
575    } else {
576      return -1;
577    }
578    KeyToIndexTypeE.DelKey(attr);
579    return 0;
580  }
581  void TMMNet::LoadNetworkShM(TShMIn& ShMIn) {
582    MxModeId = TInt(ShMIn);
583    MxCrossNetId = TInt(ShMIn);
584    TModeNetInit Fm;
585    TModeNetH.LoadShM(ShMIn, Fm);
586    TCrossNetInit Fc;
587    TCrossNetH.LoadShM(ShMIn, Fc);
588    ModeIdToNameH.LoadShM(ShMIn);
589    ModeNameToIdH.LoadShM(ShMIn);
590    CrossIdToNameH.LoadShM(ShMIn);
591    CrossNameToIdH.LoadShM(ShMIn);
592    for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
593      it.GetDat().SetParentPointer(this);
594    }
595    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
596      it.GetDat().SetParentPointer(this);
597    }
598  }
599  int TMMNet::AddModeNet(const TStr& ModeName) {
600    if (ModeNameToIdH.IsKey(ModeName)) {
601      return -1;
602    }
603    TInt ModeId = TInt(MxModeId);
604    MxModeId++;
605    ModeIdToNameH.AddDat(ModeId, ModeName);
606    ModeNameToIdH.AddDat(ModeName, ModeId);
607    TModeNet NewGraph(ModeId);
608    NewGraph.SetParentPointer(this);
609    TModeNetH.AddDat(ModeId, NewGraph);
610    return ModeId;
611  }
612  int TMMNet::AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir) {
613    TInt ModeId1 = GetModeId(ModeName1);
614    TInt ModeId2 = GetModeId(ModeName2);
615    return AddCrossNet(ModeId1, ModeId2, CrossNetName, isDir);
616  }
617  int TMMNet::AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir) {
618    if (CrossNameToIdH.IsKey(CrossNetName)) {
619      return -1;
620    }
621    TInt CrossNetId = TInt(MxCrossNetId);
622    MxCrossNetId++;
623    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
624    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
625    TCrossNet Cross = TCrossNet(ModeId1, ModeId2, isDir, CrossNetId);
626    Cross.SetParentPointer(this);
627    TCrossNetH.AddDat(CrossNetId, Cross);
628    TModeNetH.GetDat(ModeId1).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
629    TModeNetH.GetDat(ModeId2).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
630    return CrossNetId;
631  }
632  int TMMNet::DelCrossNet(const TInt& CrossNetId) {
633    return DelCrossNet(CrossIdToNameH.GetDat(CrossNetId));
634  }
635  int TMMNet::DelCrossNet(const TStr& CrossNet) {
636    IAssertR(CrossNameToIdH.IsKey(CrossNet),TStr::Fmt("No such link type: %s", CrossNet.CStr()));
637    TInt CrossNetId = CrossNameToIdH.GetDat(CrossNet);
638    TInt Mode1 = GetCrossNetById(CrossNetId).Mode1;
639    TInt Mode2 = GetCrossNetById(CrossNetId).Mode2;
640    if (GetModeNetById(Mode1).DelNbrType(CrossNet) == -1 || (Mode1 != Mode2 && GetModeNetById(Mode2).DelNbrType(CrossNet) == -1)) {
641      return -1;
642    }
643    CrossNameToIdH.DelKey(CrossNet);
644    CrossIdToNameH.DelKey(CrossNetId);
645    GetCrossNetById(CrossNetId).SetParentPointer(NULL);
646    TCrossNetH.DelKey(CrossNetId);
647    return 0;
648  }
649  int TMMNet::DelModeNet(const TInt& ModeId) {
650    TStrV CrossNets;
651    GetModeNetById(ModeId).GetCrossNetNames(CrossNets);
652    for (int i = 0; i < CrossNets.Len(); i++) {
653      if (DelCrossNet(CrossNets[i]) == -1) {
654        return -1;
655      }
656    }
657    TStr ModeName = ModeIdToNameH.GetDat(ModeId);
658    ModeNameToIdH.DelKey(ModeName);
659    ModeIdToNameH.DelKey(ModeId);
660    GetModeNetById(ModeId).SetParentPointer(NULL);
661    TModeNetH.DelKey(ModeId);
662    return 0;
663  }
664  int TMMNet::DelModeNet(const TStr& ModeName) {
665    IAssertR(ModeNameToIdH.IsKey(ModeName), TStr::Fmt("No such mode with name: %s", ModeName.CStr()));
666    return DelModeNet(ModeNameToIdH.GetDat(ModeName));
667  }
668  TModeNet& TMMNet::GetModeNetByName(const TStr& ModeName) const {
669    return GetModeNetById(ModeNameToIdH.GetDat(ModeName));
670  }
671  TModeNet& TMMNet::GetModeNetById(const TInt& ModeId) const {
672    TModeNet &Net = (const_cast<TMMNet *>(this))->TModeNetH.GetDat(ModeId);
673    return Net;
674  }
675  TCrossNet& TMMNet::GetCrossNetByName(const TStr& CrossName) const{
676    return GetCrossNetById(CrossNameToIdH.GetDat(CrossName));
677  }
678  TCrossNet& TMMNet::GetCrossNetById(const TInt& CrossId) const{
679    TCrossNet& CrossNet = (const_cast<TMMNet *>(this))->TCrossNetH.GetDat(CrossId);
680    return CrossNet;
681  }
682  int TMMNet::AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet) {
683    ModeIdToNameH.AddDat(ModeId, ModeName);
684    ModeNameToIdH.AddDat(ModeName, ModeId);
685    TModeNetH.AddDat(ModeId, ModeNet);
686    TModeNetH[ModeId].SetParentPointer(this);
687    return ModeId;
688  }
689  int TMMNet::AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet) {
690    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
691    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
692    TCrossNetH.AddDat(CrossNetId, CrossNet);
693    TCrossNetH[CrossNetId].SetParentPointer(this);
694    return CrossNetId;
695  }
696  void TMMNet::ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir) {
697    TStr CrossNetName = CrossIdToNameH[CrossNetId];
698    TModeNetH[ModeId].ClrNbr(CrossNetName, outEdge, sameMode, isDir);
699  }
700  PMMNet TMMNet::GetSubgraphByCrossNet(TStrV& CrossNetTypes) {
701    PMMNet Result = New();
702    TInt MxMode = 0;
703    TInt MxCross = 0;
704    TIntH ModeH;
705    for(int i = 0; i < CrossNetTypes.Len(); i++) {
706      TStr CrossName = CrossNetTypes[i];
707      TInt OldId = CrossNameToIdH.GetDat(CrossName);
708      TInt NewId = MxCross++;
709      TCrossNet NewCrossNet(TCrossNetH.GetDat(OldId));
710      TInt OldModeId1 = NewCrossNet.Mode1;
711      TInt OldModeId2 = NewCrossNet.Mode2;
712      TInt NewModeId1, NewModeId2;
713      if (ModeH.IsKey(OldModeId1)) {
714        NewModeId1 = ModeH.GetDat(OldModeId1);
715      } else {
716        NewModeId1 = MxMode++;
717        ModeH.AddDat(OldModeId1, NewModeId1);
718      }
719      if (ModeH.IsKey(OldModeId2)) {
720        NewModeId2 = ModeH.GetDat(OldModeId2);
721      } else {
722        NewModeId2 = MxMode++;
723        ModeH.AddDat(OldModeId2, NewModeId2);
724      }
725      NewCrossNet.Mode1 = NewModeId1;
726      NewCrossNet.Mode2 = NewModeId2;
727      NewCrossNet.CrossNetId = NewId;
728      Result->AddCrossNet(CrossName, NewId, NewCrossNet);
729    }
730    for(TIntH::TIter it = ModeH.BegI(); it < ModeH.EndI(); it++) {
731      TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
732      TInt NewModeId = it.GetDat();
733      TModeNet NewModeNet;
734      TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, CrossNetTypes);
735      NewModeNet.ModeId = NewModeId;
736      Result->AddMode(ModeName, NewModeId, NewModeNet);
737    }
738    Result->MxModeId = MxMode;
739    Result->MxCrossNetId = MxCross;
740    return Result;
741  }
742  PMMNet TMMNet::GetSubgraphByModeNet(TStrV& ModeNetTypes) {
743    THash<TInt, TBool> ModeTypeIds;
744    for (int i = 0; i < ModeNetTypes.Len(); i++) {
745      ModeTypeIds.AddDat(ModeNameToIdH.GetDat(ModeNetTypes[i]), true);
746    }
747    TStrV CrossNetTypes;
748    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
749      TCrossNet& CrossNet = it.GetDat();
750      if (ModeTypeIds.IsKey(CrossNet.Mode1) && ModeTypeIds.IsKey(CrossNet.Mode2)) {
751        CrossNetTypes.Add(CrossIdToNameH.GetDat(it.GetKey()));
752        ModeTypeIds[CrossNet.Mode1] = false;
753        ModeTypeIds[CrossNet.Mode2] = false;
754      }
755    }
756    PMMNet Result = GetSubgraphByCrossNet(CrossNetTypes);
757    TInt MxMode = Result->MxModeId;
758    TStrV EmptyCrossNetTypes;
759    for (THash<TInt, TBool>::TIter it = ModeTypeIds.BegI(); it < ModeTypeIds.EndI(); it++) {
760      if (it.GetDat().Val) {
761        TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
762        TInt NewModeId = MxMode++;
763        TModeNet NewModeNet;
764        TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, EmptyCrossNetTypes);
765        NewModeNet.ModeId = NewModeId;
766        Result->AddMode(ModeName, NewModeId, NewModeNet);
767      }
768    }
769    Result->MxModeId = MxMode;
770    return Result;
771  }
772  PNEANet TMMNet::ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap) {
773    TIntPrIntH NodeMap;
774    THash<TIntPr, TIntPr> EdgeMap;
775    THashSet<TInt> Modes;
776    PNEANet NewNet = TNEANet::New();
777    for (int i = 0; i < CrossNetTypes.Len(); i++) {
778      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
779      TInt Mode1 = CrossNet.GetMode1();
780      TInt Mode2 = CrossNet.GetMode2();
781      Modes.AddKey(Mode1);
782      Modes.AddKey(Mode2);
783      bool isDirected = CrossNet.IsDirected();
784      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
785        int srcNode = EdgeI.GetSrcNId();
786        int dstNode = EdgeI.GetDstNId();
787        TIntPr SrcNodeMapping(Mode1, srcNode);
788        int srcId = 0;
789        if (NodeMap.IsKey(SrcNodeMapping)) {
790          srcId = NodeMap.GetDat(SrcNodeMapping);
791        } else {
792          srcId = NewNet->AddNode();
793          NodeMap.AddDat(SrcNodeMapping, srcId);
794        }
795        TIntPr DstNodeMapping(Mode2, dstNode);
796        int dstId = 0;
797        if (NodeMap.IsKey(DstNodeMapping)) {
798          dstId = NodeMap.GetDat(DstNodeMapping);
799        } else {
800          dstId = NewNet->AddNode();
801          NodeMap.AddDat(DstNodeMapping, dstId);
802        }
803        int edgeId = EdgeI.GetId();
804        TIntPr EdgeMapping(CrossNetTypes[i], edgeId);
805        int newEId = NewNet->AddEdge(srcId, dstId);
806        int otherEId = -1;
807        if (!isDirected) {
808          otherEId = NewNet->AddEdge(dstId, srcId);
809        }
810        EdgeMap.AddDat(EdgeMapping, TIntPr(newEId, otherEId));
811      }
812    }
813    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
814      TModeNet &ModeNet = GetModeNetById(it.GetKey());
815      TInt ModeId = it.GetKey();
816      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
817        TIntPr NodeKey(ModeId, NodeIt.GetId());
818        if (!NodeMap.IsKey(NodeKey)) {
819          int newId = NewNet->AddNode();
820          NodeMap.AddDat(NodeKey, newId);
821        }
822      }
823    }
824    NewNet->AddIntAttrN(TStr("Mode"));
825    NewNet->AddIntAttrN(TStr("Id"));
826    NewNet->AddIntAttrE(TStr("CrossNet"));
827    NewNet->AddIntAttrE(TStr("Id"));
828    for(TIntPrIntH::TIter it = NodeMap.BegI(); it != NodeMap.EndI(); it++) {
829      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal1(), TStr("Mode"));
830      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal2(), TStr("Id"));
831    }
832    for(THash<TIntPr, TIntPr>::TIter it = EdgeMap.BegI(); it != EdgeMap.EndI(); it++) {
833      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal1(), TStr("CrossNet"));
834      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal2(), TStr("Id"));
835      if (it.GetDat().GetVal2() != -1) {
836        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal1(), TStr("CrossNet"));
837        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal2(), TStr("Id"));
838      }
839    }
840    for (int i = 0; i < NodeAttrMap.Len(); i++) {
841      TInt ModeId = NodeAttrMap[i].Val1;
842      TStr OrigAttr = NodeAttrMap[i].Val2;
843      TStr NewAttr = NodeAttrMap[i].Val3;
844      TModeNet& Net = GetModeNetById(ModeId);
845      int type = Net.GetAttrTypeN(OrigAttr);
846      if (type == TModeNet::IntType) {
847        NewNet->AddIntAttrN(NewAttr, Net.GetIntAttrDefaultN(OrigAttr));
848        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
849          TIntPr OldNId(ModeId, it.GetId());
850          int NewId = NodeMap.GetDat(OldNId);
851          int Val = Net.GetIntAttrDatN(it.GetId(), OrigAttr);
852          NewNet->AddIntAttrDatN(NewId, Val, NewAttr);
853        }
854      } else if (type == TModeNet::FltType) {
855        NewNet->AddFltAttrN(NewAttr, Net.GetFltAttrDefaultN(OrigAttr));
856        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
857          TIntPr OldNId(ModeId, it.GetId());
858          int NewId = NodeMap.GetDat(OldNId);
859          TFlt Val = Net.GetFltAttrDatN(it.GetId(), OrigAttr);
860          NewNet->AddFltAttrDatN(NewId, Val, NewAttr);
861        }
862      } else if (type == TModeNet::StrType) {
863        NewNet->AddStrAttrN(NewAttr, Net.GetStrAttrDefaultN(OrigAttr));
864        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
865          TIntPr OldNId(ModeId, it.GetId());
866          int NewId = NodeMap.GetDat(OldNId);
867          TStr Val = Net.GetStrAttrDatN(it.GetId(), OrigAttr);
868          NewNet->AddStrAttrDatN(NewId, Val, NewAttr);
869        }
870      } else if (type == TModeNet::IntVType) {
871        NewNet->AddIntVAttrN(NewAttr);
872        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
873          TIntPr OldNId(ModeId, it.GetId());
874          int NewId = NodeMap.GetDat(OldNId);
875          TIntV Val = Net.GetIntVAttrDatN(it.GetId(), OrigAttr);
876          NewNet->AddIntVAttrDatN(NewId, Val, NewAttr);
877        }
878      }
879    }
880    for (int i = 0; i < EdgeAttrMap.Len(); i++) {
881      TInt CrossId = EdgeAttrMap[i].Val1;
882      TStr OrigAttr = EdgeAttrMap[i].Val2;
883      TStr NewAttr = EdgeAttrMap[i].Val3;
884      TCrossNet& Net = GetCrossNetById(CrossId);
885      int type = Net.GetAttrTypeE(OrigAttr);
886      if (type == TCrossNet::IntType) {
887        NewNet->AddIntAttrE(NewAttr, Net.GetIntAttrDefaultE(OrigAttr));
888        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
889          TIntPr OldNId(CrossId, it.GetId());
890          TIntPr NewId = EdgeMap.GetDat(OldNId);
891          int Val = Net.GetIntAttrDatE(it.GetId(), OrigAttr);
892          NewNet->AddIntAttrDatE(NewId.Val1, Val, NewAttr);
893          if (NewId.Val2 != -1) {
894            NewNet->AddIntAttrDatE(NewId.Val2, Val, NewAttr);
895          }
896        }
897      } else if (type == TCrossNet::FltType) {
898        NewNet->AddFltAttrE(NewAttr, Net.GetFltAttrDefaultE(OrigAttr));
899        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
900          TIntPr OldNId(CrossId, it.GetId());
901          TIntPr NewId = EdgeMap.GetDat(OldNId);
902          TFlt Val = Net.GetFltAttrDatE(it.GetId(), OrigAttr);
903          NewNet->AddFltAttrDatE(NewId.Val1, Val, NewAttr);
904          if (NewId.Val2 != -1) {
905            NewNet->AddFltAttrDatE(NewId.Val2, Val, NewAttr);
906          }
907        }
908      } else if (type == TCrossNet::StrType) {
909        NewNet->AddStrAttrE(NewAttr, Net.GetStrAttrDefaultE(OrigAttr));
910        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++){
911          TIntPr OldNId(CrossId, it.GetId());
912          TIntPr NewId = EdgeMap.GetDat(OldNId);
913          TStr Val = Net.GetStrAttrDatE(it.GetId(), OrigAttr);
914          NewNet->AddStrAttrDatE(NewId.Val1, Val, NewAttr);
915          if (NewId.Val2 != -1) {
916            NewNet->AddStrAttrDatE(NewId.Val2, Val, NewAttr);
917          }
918        }
919      }
920    }
921    return NewNet;
922  }
923  PNEANet TMMNet::ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap) {
924    TIntPrIntH NodeMap;
925    THashSet<TInt> Modes;
926    PNEANet NewNet = TNEANet::New();
927    NewNet->AddIntAttrN(TStr("Mode"));
928    NewNet->AddIntAttrN(TStr("Id"));
929    NewNet->AddIntAttrE(TStr("CrossNet"));
930    NewNet->AddIntAttrE(TStr("Id"));
931    for (int i = 0; i < CrossNetTypes.Len(); i++) {
932      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
933      TStrPrV CNetAttrs;
934      if (EdgeAttrMap.IsKey(CrossNetTypes[i])) {
935        CNetAttrs = EdgeAttrMap.GetDat(CrossNetTypes[i]);
936      }
937      TInt Mode1 = CrossNet.GetMode1();
938      TInt Mode2 = CrossNet.GetMode2();
939      TModeNet& Mode1Net = GetModeNetById(Mode1);
940      TModeNet& Mode2Net = GetModeNetById(Mode2);
941      TStrPrV Mode1Attrs;
942      if (NodeAttrMap.IsKey(Mode1)) {
943        Mode1Attrs = NodeAttrMap.GetDat(Mode1);
944      }
945      TStrPrV Mode2Attrs;
946      if (NodeAttrMap.IsKey(Mode2)) {
947        Mode2Attrs = NodeAttrMap.GetDat(Mode2);
948      } 
949      Modes.AddKey(Mode1);
950      Modes.AddKey(Mode2);
951      bool isDirected = CrossNet.IsDirected();
952      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
953        int srcNode = EdgeI.GetSrcNId();
954        int dstNode = EdgeI.GetDstNId();
955        TIntPr SrcNodeMapping(Mode1, srcNode);
956        int srcId = 0;
957        if (NodeMap.IsKey(SrcNodeMapping)) {
958          srcId = NodeMap.GetDat(SrcNodeMapping);
959        } else {
960          srcId = NewNet->AddNode();
961          NodeMap.AddDat(SrcNodeMapping, srcId);
962          NewNet->AddIntAttrDatN(srcId, srcNode, TStr("Id"));
963          NewNet->AddIntAttrDatN(srcId, Mode1, TStr("Mode"));
964          AddNodeAttributes(NewNet, Mode1Net, Mode1Attrs, Mode1, srcNode, srcId);
965        }
966        TIntPr DstNodeMapping(Mode2, dstNode);
967        int dstId = 0;
968        if (NodeMap.IsKey(DstNodeMapping)) {
969          dstId = NodeMap.GetDat(DstNodeMapping);
970        } else {
971          dstId = NewNet->AddNode();
972          NodeMap.AddDat(DstNodeMapping, dstId);
973          NewNet->AddIntAttrDatN(dstId, dstNode, TStr("Id"));
974          NewNet->AddIntAttrDatN(dstId, Mode2, TStr("Mode"));
975          AddNodeAttributes(NewNet, Mode2Net, Mode2Attrs, Mode2, dstNode, dstId);
976        }
977        int edgeId = EdgeI.GetId();
978        int newEId = NewNet->AddEdge(srcId, dstId);
979        NewNet->AddIntAttrDatE(newEId, edgeId, TStr("Id"));
980        NewNet->AddIntAttrDatE(newEId, CrossNetTypes[i], TStr("CrossNet"));
981        AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, newEId);
982        if (!isDirected) {
983          int otherEId = NewNet->AddEdge(dstId, srcId);
984          NewNet->AddIntAttrDatE(otherEId, edgeId, TStr("Id"));
985          NewNet->AddIntAttrDatE(otherEId, CrossNetTypes[i], TStr("CrossNet"));
986          AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, otherEId);
987        }
988      }
989    }
990    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
991      TInt ModeId = it.GetKey();
992      TModeNet &ModeNet = GetModeNetById(ModeId);
993      TStrPrV ModeAttrs = NodeAttrMap.GetDat(ModeId);
994      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
995        TIntPr NodeKey(ModeId, NodeIt.GetId());
996        if (!NodeMap.IsKey(NodeKey)) {
997          int newId = NewNet->AddNode();
998          NodeMap.AddDat(NodeKey, newId);
999          AddNodeAttributes(NewNet, ModeNet, ModeAttrs, ModeId, NodeIt.GetId(), newId);
1000        }
1001      }
1002    }
1003    return NewNet;
1004  }
1005  void TMMNet::GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxLen) const {
1006    if (MxLen <= NumPartitions) {
1007        Partitions.Add(TIntPr(0,MxLen));
1008    } else {
1009      TInt PartitionSize = MxLen/NumPartitions;
1010      TInt CurrStart = 0;
1011      bool done = false;
1012      while (!done) {
1013        TInt CurrEnd = CurrStart + PartitionSize;
1014        if (MxLen - CurrEnd < PartitionSize) {
1015          CurrEnd = MxLen;
1016          done = true;
1017        }
1018        Partitions.Add(TIntPr(CurrStart, CurrEnd));
1019        CurrStart = CurrEnd;
1020      }
1021    }
1022  }
1023  #ifdef GCC_ATOMIC
1024  PNEANetMP TMMNet::ToNetworkMP(TStrV& CrossNetNames) {
1025    TStrIntH CrossNetStart;
1026    THashSet<TInt> ModeSet;
1027    int offset = 0;
1028    int NumEdges = 0;
1029    TVec<TCrossNet> CrossNets;
1030    for (int i=0; i < CrossNetNames.Len(); i++) {
1031      CrossNets.Add(GetCrossNetByName(CrossNetNames[i]));
1032      CrossNetStart.AddDat(CrossNetNames[i], offset);
1033      TCrossNet& CrossNet = GetCrossNetByName(CrossNetNames[i]);
1034      int factor = CrossNet.IsDirected() ? 1 : 2;
1035      offset += (CrossNet.GetMxEId() * factor);
1036      NumEdges += (CrossNet.GetEdges() * factor);
1037      ModeSet.AddKey(CrossNet.GetMode1());
1038      ModeSet.AddKey(CrossNet.GetMode2());
1039    }
1040    int MxEId = offset;
1041    int NumNodes = 0;
1042    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1043      TModeNet& ModeNet = GetModeNetById(MI.GetKey());
1044      NumNodes += ModeNet.GetNodes();
1045    }
1046    THashMP<TIntPr, TInt> NodeMap(NumNodes);
1047    THashMP<TIntPr, TIntPr> EdgeMap(NumEdges);
1048    PNEANetMP NewNet = TNEANetMP::New(NumNodes, NumEdges);
1049    int num_threads = omp_get_max_threads();
1050    offset = 0;
1051    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1052      TInt ModeId = MI.GetKey();
1053      TModeNet& ModeNet = GetModeNetById(ModeId);
1054      TIntV KeyIds;
1055      ModeNet.NodeH.GetKeyV(KeyIds);
1056      TIntPrV NodePartitions;
1057      GetPartitionRanges(NodePartitions, num_threads, KeyIds.Len());
1058      int curr_nid;
1059      #pragma omp parallel for schedule(static) private(curr_nid)
1060      for (int i = 0; i < NodePartitions.Len(); i++) {
1061        TInt CurrStart = NodePartitions[i].GetVal1();
1062        TInt CurrEnd = NodePartitions[i].GetVal2();
1063        curr_nid = offset + CurrStart;
1064        for (int idx = CurrStart; idx < CurrEnd ; idx++) {
1065          int n_i = KeyIds[idx];
1066          if (ModeNet.IsNode(n_i)) {
1067            TIntV InNbrs;
1068            TIntV OutNbrs;
1069            for (int j=0; j < CrossNetNames.Len(); j++) {
1070              TStr CrossNetName = TStr(CrossNetNames[j].CStr());
1071              if (ModeNet.NeighborTypes.IsKey(CrossNetName)) {
1072                if (ModeNet.NeighborTypes.GetDat(CrossNetName)) {
1073                  TIntV Neighbors;
1074                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, Neighbors);
1075                  int edge_offset = CrossNetStart.GetDat(CrossNetName);
1076                  TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1077                  bool isDir = CrossNet.IsDirected();
1078                  bool isOutNbr = CrossNet.GetMode1() == ModeId;
1079                  int factor = isDir ? 1 : 2;
1080                  int id_offset = isDir || isOutNbr ? 0 : 1;
1081                  if (!isDir && CrossNet.GetMode1() == CrossNet.GetMode2()) {
1082                    id_offset = n_i == CrossNet.GetEdge(n_i).GetSrcNId() ? 0 : 1;
1083                  }
1084                  for (int k = 0; k < Neighbors.Len(); k++) {
1085                    if (isOutNbr && id_offset == 0) {
1086                      OutNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1087                    } else {
1088                      InNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1089                    }
1090                    if (!isDir) {
1091                      int opp_offset = id_offset == 1 ? 0 : 1;
1092                      if (isOutNbr && id_offset == 0) {
1093                        InNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1094                      } else {
1095                        OutNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1096                      }
1097                    }
1098                  }
1099                } else {
1100                  TIntV TempOut;
1101                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempOut, true);
1102                  OutNbrs.AddV(TempOut);
1103                  TIntV TempIn;
1104                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempIn, false);
1105                  InNbrs.AddV(TempIn);
1106                }
1107              }
1108            }
1109            NewNet->AddNodeWithEdges(curr_nid, InNbrs, OutNbrs);
1110            TIntPr NodeKey(MI.GetKey(), n_i);
1111            NodeMap.AddDat(NodeKey, curr_nid);
1112            curr_nid++;
1113          }
1114        }
1115      }
1116      offset += KeyIds.Len();
1117    }
1118    NewNet->SetNodes(offset);
1119    for (int j=0; j < CrossNetNames.Len(); j++) {
1120      TStr CrossNetName = CrossNetNames[j];
1121      TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1122      TInt CrossNetId = GetCrossId(CrossNetName);
1123      TInt Mode1 = CrossNet.GetMode1();
1124      TInt Mode2 = CrossNet.GetMode2();
1125      TIntPrV EdgePartitions;
1126      GetPartitionRanges(EdgePartitions, num_threads, CrossNet.MxEId);
1127      int curr_eid;
1128      offset = CrossNetStart.GetDat(CrossNetNames[j]);
1129      int factor = CrossNet.IsDirected() ? 1 : 2;
1130      #pragma omp parallel for schedule(static) private(curr_eid)
1131      for (int i = 0; i < EdgePartitions.Len(); i++) {
1132        TInt CurrStart = EdgePartitions[i].GetVal1();
1133        TInt CurrEnd = EdgePartitions[i].GetVal2();
1134        for (int e_i = CurrStart; e_i < CurrEnd ; e_i++) {
1135          curr_eid = offset + factor*e_i;
1136          if (CrossNet.IsEdge(e_i)) {
1137            int new_eid = curr_eid;
1138            TIntPr EdgeKey(CrossNetId, e_i);
1139            TCrossNet::TCrossEdgeI edge = CrossNet.GetEdgeI(e_i);
1140            int srcNode = edge.GetSrcNId();
1141            int dstNode = edge.GetDstNId();
1142            TIntPr NodeKeySrc(Mode1, srcNode);
1143            TIntPr NodeKeyDst(Mode2, dstNode);
1144            int newSrc = NodeMap.GetDat(NodeKeySrc);
1145            int newDst = NodeMap.GetDat(NodeKeyDst);
1146            NewNet->AddEdgeUnchecked(curr_eid, newSrc, newDst);
1147            curr_eid++;
1148            int otherEId = -1;
1149            if (!CrossNet.IsDirected()) {
1150              otherEId = curr_eid;
1151              NewNet->AddEdgeUnchecked(otherEId, newDst, newSrc);
1152            }
1153            EdgeMap.AddDat(EdgeKey, TIntPr(new_eid, otherEId));
1154          }
1155        }
1156      }
1157    }
1158    NewNet->SetEdges(MxEId);
1159    NewNet->ReserveAttr(2, 0, 0, 2, 0, 0);
1160    NewNet->AddIntAttrN(TStr("Mode"));
1161    NewNet->AddIntAttrN(TStr("Id"));
1162    NewNet->AddIntAttrE(TStr("CrossNet"));
1163    NewNet->AddIntAttrE(TStr("Id"));
<span onclick='openModal()' class='match'>1164    TIntPrV NewNodeIds;
1165    NodeMap.GetKeyV(NewNodeIds);
1166    #pragma omp parallel for schedule(static)
1167    for(int i = 0; i < NewNodeIds.Len(); i++) {
1168      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal1(), TStr("Mode"));
</span>1169      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal2(), TStr("Id"));
1170    }
1171    TIntPrV NewEdgeIds;
1172    EdgeMap.GetKeyV(NewEdgeIds);
1173    #pragma omp parallel for schedule(static)
1174    for(int i = 0; i < NewEdgeIds.Len(); i++) {
1175      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1176      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1177      if (EdgeMap.GetDat(NewEdgeIds[i]).GetVal2() != -1) {
1178        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1179        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1180      }
1181    }
1182    return NewNet;
1183  }
1184  #endif 
1185  int TMMNet::AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId) {
1186    for (int i = 0; i < Attrs.Len(); i++) {
1187      TStr OrigAttr = Attrs[i].Val1;
1188      TStr NewAttr = Attrs[i].Val2;
1189      int type = Net.GetAttrTypeN(OrigAttr);
1190      if (type == TModeNet::IntType) {
1191        TIntPr OldNId(ModeId, oldId);
1192        TInt Val = Net.GetIntAttrDatN(oldId, OrigAttr);
1193        NewNet->AddIntAttrDatN(NId, Val, NewAttr);
1194      } else if (type == TModeNet::FltType) {
1195        TIntPr OldNId(ModeId, oldId);
1196        TFlt Val = Net.GetFltAttrDatN(oldId, OrigAttr);
1197        NewNet->AddFltAttrDatN(NId, Val, NewAttr);
1198      } else if (type == TModeNet::StrType) {
1199        TIntPr OldNId(ModeId, oldId);
1200        TStr Val = Net.GetStrAttrDatN(oldId, OrigAttr);
1201        NewNet->AddStrAttrDatN(NId, Val, NewAttr);
1202      } else if (type == TModeNet::IntVType) {
1203        TIntPr OldNId(ModeId, oldId);
1204        TIntV Val = Net.GetIntVAttrDatN(oldId, OrigAttr);
1205        NewNet->AddIntVAttrDatN(NId, Val, NewAttr);
1206      }
1207    }
1208    return 0;
1209  }
1210  int TMMNet::AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId) {
1211    for (int i = 0; i < Attrs.Len(); i++) {
1212      TStr OrigAttr = Attrs[i].Val1;
1213      TStr NewAttr = Attrs[i].Val2;
1214      int type = Net.GetAttrTypeE(OrigAttr);
1215      if (type == TCrossNet::IntType) {
1216        TIntPr OldNId(CrossId, oldId);
1217        TInt Val = Net.GetIntAttrDatE(oldId, OrigAttr);
1218        NewNet->AddIntAttrDatE(EId, Val, NewAttr);
1219      } else if (type == TCrossNet::FltType) {
1220        TIntPr OldNId(CrossId, oldId);
1221        TFlt Val = Net.GetFltAttrDatE(oldId, OrigAttr);
1222        NewNet->AddFltAttrDatE(EId, Val, NewAttr);
1223      } else if (type == TCrossNet::StrType) {
1224        TIntPr OldNId(CrossId, oldId);
1225        TStr Val = Net.GetStrAttrDatE(oldId, OrigAttr);
1226        NewNet->AddStrAttrDatE(EId, Val, NewAttr);
1227      }
1228    }
1229    return 0;
1230  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</h3>
            <pre><code>1  TStr TModeNet::GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const {
2    TStr Cpy(CrossName);
3    if (!isDir || !sameMode) { return Cpy; }
4    if (isOutEdge) {
5      Cpy += ":SRC";
6    } else {
7      Cpy += ":DST";
8    }
9    return Cpy;
10  }
11  void TModeNet::ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir) {
12    TStr Name = GetNeighborCrossName(CrossNetName, outEdge, sameMode, isDir);
13    TInt location = CheckDenseOrSparseN(Name);
14    int index = KeyToIndexTypeN.GetDat(Name).Val2;
15    if (location == 1) {
16      TVec<TIntV> Attrs(MxNId);
17      VecOfIntVecVecsN[index] = Attrs;
18    } else {
19      THash<TInt, TIntV> Attrs;
20      VecOfIntHashVecsN[index] = Attrs;
21    }
22  }
23  void TModeNet::Clr() {
24    TStrV CNets;
25    NeighborTypes.GetKeyV(CNets);
26    for (int i=0; i < CNets.Len(); i++) {
27      MMNet->GetCrossNetByName(CNets[i]).Clr();
28    }
29    TNEANet::Clr();
30  }
31  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const int linkId, const bool sameMode, bool isDir){
32    TStr CrossName = MMNet->GetCrossName(linkId);
33    return AddNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
34  }
35  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
36    if (!NeighborTypes.IsKey(CrossName)) {
37      AddNbrType(CrossName, sameMode, isDir);
38    }
39    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
40    return AppendIntVAttrDatN(NId, EId, Name); 
41  }
42  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
43    if (!NeighborTypes.IsKey(CrossName)) {
44      return -1;
45    }
46    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
47    return DelFromIntVAttrDatN(NId, EId, Name);
48  }
49  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir){
50    TStr CrossName = MMNet->GetCrossName(linkId);
51    return DelNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
52  }
53  void TModeNet::DelNode(const int& NId) {
54    TStrV Names;
55    GetCrossNetNames(Names);
56    for (int i=0; i < Names.Len(); i++) {
57      TCrossNet& Cross = MMNet->GetCrossNetByName(Names[i]);
58      TIntV OutEIds;
59      GetNeighborsByCrossNet(NId, Names[i], OutEIds, true);
60      for (int j=0; j < OutEIds.Len(); j++) {
61        Cross.DelEdge(OutEIds[j].Val);
62      }
63      if (Cross.IsDirect && Cross.Mode1 == Cross.Mode2) {
64        TIntV InEIds;
65        GetNeighborsByCrossNet(NId, Names[i], InEIds, false);
66        for (int j=0; j < InEIds.Len(); j++) {
67          Cross.DelEdge(InEIds[j].Val);
68        }
69      }
70    }
71    TNEANet::DelNode(NId);
72  }
73  void TModeNet::SetParentPointer(TMMNet* parent) {
74    MMNet = parent;
75  }
76  int TModeNet::AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir) {
77    if (NeighborTypes.IsKey(CrossName)) { return -1; } 
78    bool hasSingleVector = (!isDir || !sameMode);
79    NeighborTypes.AddDat(CrossName, hasSingleVector);
80    return 0;
81  }
82  int TModeNet::DelNbrType(const TStr& CrossName) {
83    bool hasSingleVector = NeighborTypes.GetDat(CrossName);
84    NeighborTypes.DelKey(CrossName);
85    if (hasSingleVector) {
86      return DelAttrN(CrossName);
87    } else {
88      TStr InName = GetNeighborCrossName(CrossName, true, true, true);
89      TStr OutName = GetNeighborCrossName(CrossName, false, true, true);
90      if (DelAttrN(InName) == -1 || DelAttrN(OutName) == -1) {
91        return -1;
92      }
93    }
94    return 0;
95  }
96  void TModeNet::GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId) const{
97    TBool hasSingleVector = NeighborTypes.GetDat(Name);
98    if (hasSingleVector) {
99      Neighbors = GetIntVAttrDatN(NId, Name);
100    } else {
101      TStr DirectionalName = GetNeighborCrossName(Name, isOutEId, true, true);
102      Neighbors = GetIntVAttrDatN(NId, DirectionalName);
103    }
104  }
105  int TModeNet::AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense){
106    TInt CurrLen;
107    if (UseDense) {
108      CurrLen = VecOfIntVecVecsN.Len();
109      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
110      KeyToDenseN.AddDat(attr, true);
111      VecOfIntVecVecsN.Add(Attrs);
112    } else {
113      THash<TInt, TIntV> NewHash;
114      CurrLen = VecOfIntHashVecsN.Len();
115      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
116      KeyToDenseN.AddDat(attr, false);
117      for (int i=0; i< Attrs.Len(); i++) {
118        NewHash.AddDat(i, Attrs[i]);
119      }
120      VecOfIntHashVecsN.Add(NewHash);
121    }
122    return 0;
123  }
124  int TModeNet::AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs){
125    TInt CurrLen;
126    THash<TInt, TIntV> NewHash;
127    CurrLen = VecOfIntHashVecsN.Len();
128    KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
129    KeyToDenseN.AddDat(attr, false);
130    for (int i=0; i< Attrs.Len(); i++) {
131      NewHash.AddDat(i, Attrs[i]);
132    }
133    VecOfIntHashVecsN.Add(NewHash);
134    return 0;
135  }
136  void TModeNet::RemoveCrossNets(TModeNet& Result, TStrV& CrossNets) {
137    const TModeNet& self = *this;
138    Result = TModeNet(self, false);
139    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
140      TStr AttrName = it.GetKey();
141      TInt AttrType = it.GetDat().GetVal1();
142      TInt AttrIndex = it.GetDat().GetVal2();
143      if (AttrType != IntVType) {
144        Result.KeyToIndexTypeN.AddDat(AttrName, it.GetDat());
145      } else {
146        TStr WithoutSuffix = AttrName;
147        bool removeSuffix = false;
148        if (AttrName.IsSuffix(":SRC") || AttrName.IsSuffix(":DST")) {
149          WithoutSuffix = AttrName.GetSubStr(0, AttrName.Len()-5);
150          removeSuffix = true;
151        }
152        bool isSingleVNbrAttr = (NeighborTypes.IsKey(AttrName) && NeighborTypes.GetDat(AttrName));
153        bool isMultiVNbrAttr = (removeSuffix && NeighborTypes.IsKey(WithoutSuffix) && !NeighborTypes.GetDat(WithoutSuffix));
154        if (isSingleVNbrAttr || isMultiVNbrAttr) {
155          TStr NbrName = isSingleVNbrAttr ? AttrName : WithoutSuffix;
156          if (CrossNets.IsIn(NbrName)) {
157            Result.AddNbrType(NbrName, removeSuffix, removeSuffix);
158            TInt location = CheckDenseOrSparseN(AttrName);
159            if (location == 1) {
160              TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
161              Result.AddIntVAttrByVecN(AttrName, Attrs);
162            } else {
163              THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
164              Result.AddIntVAttrByHashN(AttrName, Attrs);
165            }
166          }
167        } else {
168          TInt location = CheckDenseOrSparseN(AttrName);
169          if (location == 1) {
170            TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
171            Result.AddIntVAttrByVecN(AttrName, Attrs);
172          } else {
173            THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
174            Result.AddIntVAttrByHashN(AttrName, Attrs);
175          }
176        }
177      }
178    }
179  }
180  int TModeNet::GetAttrTypeN(const TStr& attr) const {
181    if (KeyToIndexTypeN.IsKey(attr)) {
182      return KeyToIndexTypeN.GetDat(attr).Val1;
183    }
184    return -1;
185  }
186  int TCrossNet::GetAttrTypeE(const TStr& attr) const {
187    if (KeyToIndexTypeE.IsKey(attr)) {
188      return KeyToIndexTypeE.GetDat(attr).Val1;
189    }
190    return -1;
191  }
192  void TCrossNet::Clr() {
193    CrossH.Clr();
194    MxEId=0;
195    KeyToIndexTypeE.Clr();
196    IntDefaultsE.Clr();
197    StrDefaultsE.Clr();
198    FltDefaultsE.Clr();
199    VecOfIntVecsE.Clr();
200    VecOfStrVecsE.Clr();
201    VecOfFltVecsE.Clr(); 
202    Net->ClrNbr(Mode1, CrossNetId, true, Mode1==Mode2, IsDirect.Val);
203    Net->ClrNbr(Mode2, CrossNetId, false, Mode1==Mode2, IsDirect.Val); 
204  }
205  int TCrossNet::AddEdge(const int& sourceNId, const int& destNId, int EId){
206    if (EId == -1) { EId = MxEId;  MxEId++; }
207    else { MxEId = TMath::Mx(EId+1, MxEId()); }
208    if (Net != NULL) {
209      TModeNet& M1 = Net->TModeNetH.GetDat(this->Mode1);
210      TModeNet& M2 = Net->TModeNetH.GetDat(this->Mode2);
211      if (!M1.IsNode(sourceNId) || !M2.IsNode(destNId)) { return -1; }
212      TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
213      M1.AddNeighbor(sourceNId, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
214      M2.AddNeighbor(destNId, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
215    }
216    TCrossNet::TCrossEdge newEdge(EId, sourceNId, destNId);
217    CrossH.AddDat(EId, newEdge);
218    int i;
219    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
220      TVec<TInt>& IntVec = VecOfIntVecsE[i];
221      int KeyId = CrossH.GetKeyId(EId);
222      if (IntVec.Len() > KeyId) {
223        IntVec[KeyId] = TInt::Mn;
224      } else {
225        IntVec.Ins(KeyId, TInt::Mn);
226      }
227    }
228    TVec<TStr> DefIntVec = TVec<TStr>();
229    IntDefaultsE.GetKeyV(DefIntVec);
230    for (i = 0; i < DefIntVec.Len(); i++) {
231      TStr attr = DefIntVec[i];
232      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
233      IntVec[CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
234    }
235    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
236      TVec<TStr>& StrVec = VecOfStrVecsE[i];
237      int KeyId = CrossH.GetKeyId(EId);
238      if (StrVec.Len() > KeyId) {
239        StrVec[KeyId] = TStr::GetNullStr();
240      } else {
241        StrVec.Ins(KeyId, TStr::GetNullStr());
242      }
243    }
244    TVec<TStr> DefStrVec = TVec<TStr>();
245    StrDefaultsE.GetKeyV(DefStrVec);
246    for (i = 0; i < DefStrVec.Len(); i++) {
247      TStr attr = DefStrVec[i];
248      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
249      StrVec[CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
250    }
251    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
252      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
253      int KeyId = CrossH.GetKeyId(EId);
254      if (FltVec.Len() > KeyId) {
255        FltVec[KeyId] = TFlt::Mn;
256      } else {
257        FltVec.Ins(KeyId, TFlt::Mn);
258      }
259    }
260    TVec<TStr> DefFltVec = TVec<TStr>();
261    FltDefaultsE.GetKeyV(DefFltVec);
262    for (i = 0; i < DefFltVec.Len(); i++) {
263      TStr attr = DefFltVec[i];
264      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
265      FltVec[CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
266    }
267    return EId;
268  }
269  int TCrossNet::DelEdge(const int& EId) {
270    TCrossEdge& Edge = CrossH.GetDat(EId);
271    int srcNode = Edge.SrcNId;
272    int dstNode = Edge.DstNId;
273    TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
274    Net->GetModeNetById(this->Mode1).DelNeighbor(srcNode, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
275    Net->GetModeNetById(this->Mode2).DelNeighbor(dstNode, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
276    int i;
277    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
278      TVec<TInt>& IntVec = VecOfIntVecsE[i];
279      IntVec[CrossH.GetKeyId(EId)] =  TInt::Mn;
280    }
281    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
282      TVec<TStr>& StrVec = VecOfStrVecsE[i];
283      StrVec[CrossH.GetKeyId(EId)] =  TStr::GetNullStr();
284    }
285    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
286      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
287      FltVec[CrossH.GetKeyId(EId)] = TFlt::Mn;
288    }
289    CrossH.DelKey(EId);
290    return 0;
291  }
292  void TCrossNet::SetParentPointer(TMMNet* parent) {
293    Net = parent;
294  }
295  void TCrossNet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
296    Names = TVec<TStr>();
297    while (!CrossHI.IsEnd()) {
298      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
299        Names.Add(CrossHI.GetKey());
300      }
301      CrossHI++;
302    }  
303  }
304  void TCrossNet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
305    Values = TVec<TStr>();
306    while (!CrossHI.IsEnd()) {
307      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
308        Values.Add(GetEdgeAttrValue(EId, CrossHI));
309      }
310      CrossHI++;
311    }  
312  }
313  void TCrossNet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
314    Names = TVec<TStr>();
315    while (!CrossHI.IsEnd()) {
316      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
317        Names.Add(CrossHI.GetKey());
318      }
319      CrossHI++;
320    }  
321  }
322  void TCrossNet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const {
323    Values = TVec<TInt>();
324    while (!CrossHI.IsEnd()) {
325      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
326        TInt val = (this->VecOfIntVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
327        Values.Add(val);
328      }
329      CrossHI++;
330    }  
331  }
332  void TCrossNet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
333    Names = TVec<TStr>();
334    while (!CrossHI.IsEnd()) {
335      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
336        Names.Add(CrossHI.GetKey());
337      }
338      CrossHI++;
339    }  
340  }
341  void TCrossNet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
342    Values = TVec<TStr>();
343    while (!CrossHI.IsEnd()) {
344      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
345        TStr val = this->VecOfStrVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId);
346        Values.Add(val);
347      }
348      CrossHI++;
349    }  
350  }
351  void TCrossNet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
352    Names = TVec<TStr>();
353    while (!CrossHI.IsEnd()) {
354      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
355        Names.Add(CrossHI.GetKey());
356      }
357      CrossHI++;
358    }  
359  }
360  void TCrossNet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const {
361    Values = TVec<TFlt>();
362    while (!CrossHI.IsEnd()) {
363      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
364        TFlt val = (this->VecOfFltVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
365        Values.Add(val);
366      }
367      CrossHI++;
368    }  
369  }
370  bool TCrossNet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
371    bool IntDel = IsIntAttrDeletedE(EId, attr);
372    bool StrDel = IsStrAttrDeletedE(EId, attr);
373    bool FltDel = IsFltAttrDeletedE(EId, attr);
374    return IntDel || StrDel || FltDel;
375  }
376  bool TCrossNet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
377    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
378  }
379  bool TCrossNet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
380    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
381  }
382  bool TCrossNet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
383    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
384  }
385  bool TCrossNet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
386    bool IntDel = EdgeAttrIsIntDeleted(EId, CrossHI);
387    bool StrDel = EdgeAttrIsStrDeleted(EId, CrossHI);
388    bool FltDel = EdgeAttrIsFltDeleted(EId, CrossHI);
389    return IntDel || StrDel || FltDel;
390  }
391  bool TCrossNet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
392    return (CrossHI.GetDat().Val1 == IntType &&
393      GetIntAttrDefaultE(CrossHI.GetKey()) == this->VecOfIntVecsE.GetVal(
394      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
395  }
396  bool TCrossNet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
397    return (CrossHI.GetDat().Val1 == StrType &&
398      GetStrAttrDefaultE(CrossHI.GetKey()) == this->VecOfStrVecsE.GetVal(
399      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
400  }
401  bool TCrossNet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
402    return (CrossHI.GetDat().Val1 == FltType &&
403      GetFltAttrDefaultE(CrossHI.GetKey()) == this->VecOfFltVecsE.GetVal(
404      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
405  }
406  TStr TCrossNet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
407    if (CrossHI.GetDat().Val1 == IntType) {
408      return (this->VecOfIntVecsE.GetVal(
409        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
410    } else if(CrossHI.GetDat().Val1 == StrType) {
411      return this->VecOfStrVecsE.GetVal(
412      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId));
413    } else if (CrossHI.GetDat().Val1 == FltType) {
414      return (this->VecOfFltVecsE.GetVal(
415        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
416    }
417    return TStr::GetNullStr();
418  }
419  int TCrossNet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
420    int i;
421    TInt CurrLen;
422    if (!IsEdge(EId)) {
423       return -1;
424    }
425    if (KeyToIndexTypeE.IsKey(attr)) {
426      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
427      NewVec[CrossH.GetKeyId(EId)] = value;
428    } else {
429      CurrLen = VecOfIntVecsE.Len();
430      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
431      TVec<TInt> NewVec = TVec<TInt>();
432      for (i = 0; i < MxEId; i++) {
433        NewVec.Ins(i, GetIntAttrDefaultE(attr));
434      }
435      NewVec[CrossH.GetKeyId(EId)] = value;
436      VecOfIntVecsE.Add(NewVec);
437    }
438    return 0;
439  }
440  int TCrossNet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
441    int i;
442    TInt CurrLen;
443    if (!IsEdge(EId)) {
444       return -1;
445    }
446    if (KeyToIndexTypeE.IsKey(attr)) {
447      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
448      NewVec[CrossH.GetKeyId(EId)] = value;
449    } else {
450      CurrLen = VecOfStrVecsE.Len();
451      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
452      TVec<TStr> NewVec = TVec<TStr>();
453      for (i = 0; i < MxEId; i++) {
454        NewVec.Ins(i, GetStrAttrDefaultE(attr));
455      }
456      NewVec[CrossH.GetKeyId(EId)] = value;
457      VecOfStrVecsE.Add(NewVec);
458    }
459    return 0;
460  } 
461  int TCrossNet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
462    int i;
463    TInt CurrLen;
464    if (!IsEdge(EId)) {
465       return -1;
466    }
467    if (KeyToIndexTypeE.IsKey(attr)) {
468      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
469      NewVec[CrossH.GetKeyId(EId)] = value;
470    } else {
471      CurrLen = VecOfFltVecsE.Len();
472      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
473      TVec<TFlt> NewVec = TVec<TFlt>();
474      for (i = 0; i < MxEId; i++) {
475        NewVec.Ins(i, GetFltAttrDefaultE(attr));
476      }
477      NewVec[CrossH.GetKeyId(EId)] = value;
478      VecOfFltVecsE.Add(NewVec);
479    }
480    return 0;
481  }
482  TInt TCrossNet::GetIntAttrDatE(const int& EId, const TStr& attr) {
483    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
484  }
485  TStr TCrossNet::GetStrAttrDatE(const int& EId, const TStr& attr) {
486    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
487  }
488  TFlt TCrossNet::GetFltAttrDatE(const int& EId, const TStr& attr) {
489    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
490  }
491  int TCrossNet::DelAttrDatE(const int& EId, const TStr& attr) {
492    TInt vecType = KeyToIndexTypeE(attr).Val1;
493    if (vecType == IntType) {
494      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
495    } else if (vecType == StrType) {
496      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
497    } else if (vecType == FltType) {
498      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
499    } else {
500      return -1;
501    }
502    return 0;
503  }
504  int TCrossNet::AddIntAttrE(const TStr& attr, TInt defaultValue){
505    int i;
506    TInt CurrLen;
507    TVec<TInt> NewVec;
508    CurrLen = VecOfIntVecsE.Len();
509    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
510    NewVec = TVec<TInt>();
511    for (i = 0; i < MxEId; i++) {
512      NewVec.Ins(i, defaultValue);
513    }
514    VecOfIntVecsE.Add(NewVec);
515    if (!IntDefaultsE.IsKey(attr)) {
516      IntDefaultsE.AddDat(attr, defaultValue);
517    } else {
518      return -1;
519    }
520    return 0;
521  }
522  int TCrossNet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
523    int i;
524    TInt CurrLen;
525    TVec<TStr> NewVec;
526    CurrLen = VecOfStrVecsE.Len();
527    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
528    NewVec = TVec<TStr>();
529    for (i = 0; i < MxEId; i++) {
530      NewVec.Ins(i, defaultValue);
531    }
532    VecOfStrVecsE.Add(NewVec);
533    if (!StrDefaultsE.IsKey(attr)) {
534      StrDefaultsE.AddDat(attr, defaultValue);
535    } else {
536      return -1;
537    }
538    return 0;
539  }
540  int TCrossNet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
541    int i;
542    TInt CurrLen;
543    TVec<TFlt> NewVec;
544    CurrLen = VecOfFltVecsE.Len();
545    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
546    NewVec = TVec<TFlt>();
547    for (i = 0; i < MxEId; i++) {
548      NewVec.Ins(i, defaultValue);
549    }
550    VecOfFltVecsE.Add(NewVec);
551    if (!FltDefaultsE.IsKey(attr)) {
552      FltDefaultsE.AddDat(attr, defaultValue);
553    } else {
554      return -1;
555    }
556    return 0;
557  }
558  int TCrossNet::DelAttrE(const TStr& attr) {
559    TInt vecType = KeyToIndexTypeE(attr).Val1;
560    if (vecType == IntType) {
561      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
562      if (IntDefaultsE.IsKey(attr)) {
563        IntDefaultsE.DelKey(attr);
564      }
565    } else if (vecType == StrType) {
566      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
567      if (StrDefaultsE.IsKey(attr)) {
568        StrDefaultsE.DelKey(attr);
569      }  
570    } else if (vecType == FltType) {
571      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
572      if (FltDefaultsE.IsKey(attr)) {
573        FltDefaultsE.DelKey(attr);
574      }
575    } else {
576      return -1;
577    }
578    KeyToIndexTypeE.DelKey(attr);
579    return 0;
580  }
581  void TMMNet::LoadNetworkShM(TShMIn& ShMIn) {
582    MxModeId = TInt(ShMIn);
583    MxCrossNetId = TInt(ShMIn);
584    TModeNetInit Fm;
585    TModeNetH.LoadShM(ShMIn, Fm);
586    TCrossNetInit Fc;
587    TCrossNetH.LoadShM(ShMIn, Fc);
588    ModeIdToNameH.LoadShM(ShMIn);
589    ModeNameToIdH.LoadShM(ShMIn);
590    CrossIdToNameH.LoadShM(ShMIn);
591    CrossNameToIdH.LoadShM(ShMIn);
592    for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
593      it.GetDat().SetParentPointer(this);
594    }
595    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
596      it.GetDat().SetParentPointer(this);
597    }
598  }
599  int TMMNet::AddModeNet(const TStr& ModeName) {
600    if (ModeNameToIdH.IsKey(ModeName)) {
601      return -1;
602    }
603    TInt ModeId = TInt(MxModeId);
604    MxModeId++;
605    ModeIdToNameH.AddDat(ModeId, ModeName);
606    ModeNameToIdH.AddDat(ModeName, ModeId);
607    TModeNet NewGraph(ModeId);
608    NewGraph.SetParentPointer(this);
609    TModeNetH.AddDat(ModeId, NewGraph);
610    return ModeId;
611  }
612  int TMMNet::AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir) {
613    TInt ModeId1 = GetModeId(ModeName1);
614    TInt ModeId2 = GetModeId(ModeName2);
615    return AddCrossNet(ModeId1, ModeId2, CrossNetName, isDir);
616  }
617  int TMMNet::AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir) {
618    if (CrossNameToIdH.IsKey(CrossNetName)) {
619      return -1;
620    }
621    TInt CrossNetId = TInt(MxCrossNetId);
622    MxCrossNetId++;
623    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
624    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
625    TCrossNet Cross = TCrossNet(ModeId1, ModeId2, isDir, CrossNetId);
626    Cross.SetParentPointer(this);
627    TCrossNetH.AddDat(CrossNetId, Cross);
628    TModeNetH.GetDat(ModeId1).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
629    TModeNetH.GetDat(ModeId2).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
630    return CrossNetId;
631  }
632  int TMMNet::DelCrossNet(const TInt& CrossNetId) {
633    return DelCrossNet(CrossIdToNameH.GetDat(CrossNetId));
634  }
635  int TMMNet::DelCrossNet(const TStr& CrossNet) {
636    IAssertR(CrossNameToIdH.IsKey(CrossNet),TStr::Fmt("No such link type: %s", CrossNet.CStr()));
637    TInt CrossNetId = CrossNameToIdH.GetDat(CrossNet);
638    TInt Mode1 = GetCrossNetById(CrossNetId).Mode1;
639    TInt Mode2 = GetCrossNetById(CrossNetId).Mode2;
640    if (GetModeNetById(Mode1).DelNbrType(CrossNet) == -1 || (Mode1 != Mode2 && GetModeNetById(Mode2).DelNbrType(CrossNet) == -1)) {
641      return -1;
642    }
643    CrossNameToIdH.DelKey(CrossNet);
644    CrossIdToNameH.DelKey(CrossNetId);
645    GetCrossNetById(CrossNetId).SetParentPointer(NULL);
646    TCrossNetH.DelKey(CrossNetId);
647    return 0;
648  }
649  int TMMNet::DelModeNet(const TInt& ModeId) {
650    TStrV CrossNets;
651    GetModeNetById(ModeId).GetCrossNetNames(CrossNets);
652    for (int i = 0; i < CrossNets.Len(); i++) {
653      if (DelCrossNet(CrossNets[i]) == -1) {
654        return -1;
655      }
656    }
657    TStr ModeName = ModeIdToNameH.GetDat(ModeId);
658    ModeNameToIdH.DelKey(ModeName);
659    ModeIdToNameH.DelKey(ModeId);
660    GetModeNetById(ModeId).SetParentPointer(NULL);
661    TModeNetH.DelKey(ModeId);
662    return 0;
663  }
664  int TMMNet::DelModeNet(const TStr& ModeName) {
665    IAssertR(ModeNameToIdH.IsKey(ModeName), TStr::Fmt("No such mode with name: %s", ModeName.CStr()));
666    return DelModeNet(ModeNameToIdH.GetDat(ModeName));
667  }
668  TModeNet& TMMNet::GetModeNetByName(const TStr& ModeName) const {
669    return GetModeNetById(ModeNameToIdH.GetDat(ModeName));
670  }
671  TModeNet& TMMNet::GetModeNetById(const TInt& ModeId) const {
672    TModeNet &Net = (const_cast<TMMNet *>(this))->TModeNetH.GetDat(ModeId);
673    return Net;
674  }
675  TCrossNet& TMMNet::GetCrossNetByName(const TStr& CrossName) const{
676    return GetCrossNetById(CrossNameToIdH.GetDat(CrossName));
677  }
678  TCrossNet& TMMNet::GetCrossNetById(const TInt& CrossId) const{
679    TCrossNet& CrossNet = (const_cast<TMMNet *>(this))->TCrossNetH.GetDat(CrossId);
680    return CrossNet;
681  }
682  int TMMNet::AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet) {
683    ModeIdToNameH.AddDat(ModeId, ModeName);
684    ModeNameToIdH.AddDat(ModeName, ModeId);
685    TModeNetH.AddDat(ModeId, ModeNet);
686    TModeNetH[ModeId].SetParentPointer(this);
687    return ModeId;
688  }
689  int TMMNet::AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet) {
690    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
691    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
692    TCrossNetH.AddDat(CrossNetId, CrossNet);
693    TCrossNetH[CrossNetId].SetParentPointer(this);
694    return CrossNetId;
695  }
696  void TMMNet::ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir) {
697    TStr CrossNetName = CrossIdToNameH[CrossNetId];
698    TModeNetH[ModeId].ClrNbr(CrossNetName, outEdge, sameMode, isDir);
699  }
700  PMMNet TMMNet::GetSubgraphByCrossNet(TStrV& CrossNetTypes) {
701    PMMNet Result = New();
702    TInt MxMode = 0;
703    TInt MxCross = 0;
704    TIntH ModeH;
705    for(int i = 0; i < CrossNetTypes.Len(); i++) {
706      TStr CrossName = CrossNetTypes[i];
707      TInt OldId = CrossNameToIdH.GetDat(CrossName);
708      TInt NewId = MxCross++;
709      TCrossNet NewCrossNet(TCrossNetH.GetDat(OldId));
710      TInt OldModeId1 = NewCrossNet.Mode1;
711      TInt OldModeId2 = NewCrossNet.Mode2;
712      TInt NewModeId1, NewModeId2;
713      if (ModeH.IsKey(OldModeId1)) {
714        NewModeId1 = ModeH.GetDat(OldModeId1);
715      } else {
716        NewModeId1 = MxMode++;
717        ModeH.AddDat(OldModeId1, NewModeId1);
718      }
719      if (ModeH.IsKey(OldModeId2)) {
720        NewModeId2 = ModeH.GetDat(OldModeId2);
721      } else {
722        NewModeId2 = MxMode++;
723        ModeH.AddDat(OldModeId2, NewModeId2);
724      }
725      NewCrossNet.Mode1 = NewModeId1;
726      NewCrossNet.Mode2 = NewModeId2;
727      NewCrossNet.CrossNetId = NewId;
728      Result->AddCrossNet(CrossName, NewId, NewCrossNet);
729    }
730    for(TIntH::TIter it = ModeH.BegI(); it < ModeH.EndI(); it++) {
731      TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
732      TInt NewModeId = it.GetDat();
733      TModeNet NewModeNet;
734      TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, CrossNetTypes);
735      NewModeNet.ModeId = NewModeId;
736      Result->AddMode(ModeName, NewModeId, NewModeNet);
737    }
738    Result->MxModeId = MxMode;
739    Result->MxCrossNetId = MxCross;
740    return Result;
741  }
742  PMMNet TMMNet::GetSubgraphByModeNet(TStrV& ModeNetTypes) {
743    THash<TInt, TBool> ModeTypeIds;
744    for (int i = 0; i < ModeNetTypes.Len(); i++) {
745      ModeTypeIds.AddDat(ModeNameToIdH.GetDat(ModeNetTypes[i]), true);
746    }
747    TStrV CrossNetTypes;
748    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
749      TCrossNet& CrossNet = it.GetDat();
750      if (ModeTypeIds.IsKey(CrossNet.Mode1) && ModeTypeIds.IsKey(CrossNet.Mode2)) {
751        CrossNetTypes.Add(CrossIdToNameH.GetDat(it.GetKey()));
752        ModeTypeIds[CrossNet.Mode1] = false;
753        ModeTypeIds[CrossNet.Mode2] = false;
754      }
755    }
756    PMMNet Result = GetSubgraphByCrossNet(CrossNetTypes);
757    TInt MxMode = Result->MxModeId;
758    TStrV EmptyCrossNetTypes;
759    for (THash<TInt, TBool>::TIter it = ModeTypeIds.BegI(); it < ModeTypeIds.EndI(); it++) {
760      if (it.GetDat().Val) {
761        TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
762        TInt NewModeId = MxMode++;
763        TModeNet NewModeNet;
764        TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, EmptyCrossNetTypes);
765        NewModeNet.ModeId = NewModeId;
766        Result->AddMode(ModeName, NewModeId, NewModeNet);
767      }
768    }
769    Result->MxModeId = MxMode;
770    return Result;
771  }
772  PNEANet TMMNet::ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap) {
773    TIntPrIntH NodeMap;
774    THash<TIntPr, TIntPr> EdgeMap;
775    THashSet<TInt> Modes;
776    PNEANet NewNet = TNEANet::New();
777    for (int i = 0; i < CrossNetTypes.Len(); i++) {
778      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
779      TInt Mode1 = CrossNet.GetMode1();
780      TInt Mode2 = CrossNet.GetMode2();
781      Modes.AddKey(Mode1);
782      Modes.AddKey(Mode2);
783      bool isDirected = CrossNet.IsDirected();
784      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
785        int srcNode = EdgeI.GetSrcNId();
786        int dstNode = EdgeI.GetDstNId();
787        TIntPr SrcNodeMapping(Mode1, srcNode);
788        int srcId = 0;
789        if (NodeMap.IsKey(SrcNodeMapping)) {
790          srcId = NodeMap.GetDat(SrcNodeMapping);
791        } else {
792          srcId = NewNet->AddNode();
793          NodeMap.AddDat(SrcNodeMapping, srcId);
794        }
795        TIntPr DstNodeMapping(Mode2, dstNode);
796        int dstId = 0;
797        if (NodeMap.IsKey(DstNodeMapping)) {
798          dstId = NodeMap.GetDat(DstNodeMapping);
799        } else {
800          dstId = NewNet->AddNode();
801          NodeMap.AddDat(DstNodeMapping, dstId);
802        }
803        int edgeId = EdgeI.GetId();
804        TIntPr EdgeMapping(CrossNetTypes[i], edgeId);
805        int newEId = NewNet->AddEdge(srcId, dstId);
806        int otherEId = -1;
807        if (!isDirected) {
808          otherEId = NewNet->AddEdge(dstId, srcId);
809        }
810        EdgeMap.AddDat(EdgeMapping, TIntPr(newEId, otherEId));
811      }
812    }
813    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
814      TModeNet &ModeNet = GetModeNetById(it.GetKey());
815      TInt ModeId = it.GetKey();
816      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
817        TIntPr NodeKey(ModeId, NodeIt.GetId());
818        if (!NodeMap.IsKey(NodeKey)) {
819          int newId = NewNet->AddNode();
820          NodeMap.AddDat(NodeKey, newId);
821        }
822      }
823    }
824    NewNet->AddIntAttrN(TStr("Mode"));
825    NewNet->AddIntAttrN(TStr("Id"));
826    NewNet->AddIntAttrE(TStr("CrossNet"));
827    NewNet->AddIntAttrE(TStr("Id"));
828    for(TIntPrIntH::TIter it = NodeMap.BegI(); it != NodeMap.EndI(); it++) {
829      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal1(), TStr("Mode"));
830      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal2(), TStr("Id"));
831    }
832    for(THash<TIntPr, TIntPr>::TIter it = EdgeMap.BegI(); it != EdgeMap.EndI(); it++) {
833      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal1(), TStr("CrossNet"));
834      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal2(), TStr("Id"));
835      if (it.GetDat().GetVal2() != -1) {
836        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal1(), TStr("CrossNet"));
837        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal2(), TStr("Id"));
838      }
839    }
840    for (int i = 0; i < NodeAttrMap.Len(); i++) {
841      TInt ModeId = NodeAttrMap[i].Val1;
842      TStr OrigAttr = NodeAttrMap[i].Val2;
843      TStr NewAttr = NodeAttrMap[i].Val3;
844      TModeNet& Net = GetModeNetById(ModeId);
845      int type = Net.GetAttrTypeN(OrigAttr);
846      if (type == TModeNet::IntType) {
847        NewNet->AddIntAttrN(NewAttr, Net.GetIntAttrDefaultN(OrigAttr));
848        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
849          TIntPr OldNId(ModeId, it.GetId());
850          int NewId = NodeMap.GetDat(OldNId);
851          int Val = Net.GetIntAttrDatN(it.GetId(), OrigAttr);
852          NewNet->AddIntAttrDatN(NewId, Val, NewAttr);
853        }
854      } else if (type == TModeNet::FltType) {
855        NewNet->AddFltAttrN(NewAttr, Net.GetFltAttrDefaultN(OrigAttr));
856        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
857          TIntPr OldNId(ModeId, it.GetId());
858          int NewId = NodeMap.GetDat(OldNId);
859          TFlt Val = Net.GetFltAttrDatN(it.GetId(), OrigAttr);
860          NewNet->AddFltAttrDatN(NewId, Val, NewAttr);
861        }
862      } else if (type == TModeNet::StrType) {
863        NewNet->AddStrAttrN(NewAttr, Net.GetStrAttrDefaultN(OrigAttr));
864        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
865          TIntPr OldNId(ModeId, it.GetId());
866          int NewId = NodeMap.GetDat(OldNId);
867          TStr Val = Net.GetStrAttrDatN(it.GetId(), OrigAttr);
868          NewNet->AddStrAttrDatN(NewId, Val, NewAttr);
869        }
870      } else if (type == TModeNet::IntVType) {
871        NewNet->AddIntVAttrN(NewAttr);
872        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
873          TIntPr OldNId(ModeId, it.GetId());
874          int NewId = NodeMap.GetDat(OldNId);
875          TIntV Val = Net.GetIntVAttrDatN(it.GetId(), OrigAttr);
876          NewNet->AddIntVAttrDatN(NewId, Val, NewAttr);
877        }
878      }
879    }
880    for (int i = 0; i < EdgeAttrMap.Len(); i++) {
881      TInt CrossId = EdgeAttrMap[i].Val1;
882      TStr OrigAttr = EdgeAttrMap[i].Val2;
883      TStr NewAttr = EdgeAttrMap[i].Val3;
884      TCrossNet& Net = GetCrossNetById(CrossId);
885      int type = Net.GetAttrTypeE(OrigAttr);
886      if (type == TCrossNet::IntType) {
887        NewNet->AddIntAttrE(NewAttr, Net.GetIntAttrDefaultE(OrigAttr));
888        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
889          TIntPr OldNId(CrossId, it.GetId());
890          TIntPr NewId = EdgeMap.GetDat(OldNId);
891          int Val = Net.GetIntAttrDatE(it.GetId(), OrigAttr);
892          NewNet->AddIntAttrDatE(NewId.Val1, Val, NewAttr);
893          if (NewId.Val2 != -1) {
894            NewNet->AddIntAttrDatE(NewId.Val2, Val, NewAttr);
895          }
896        }
897      } else if (type == TCrossNet::FltType) {
898        NewNet->AddFltAttrE(NewAttr, Net.GetFltAttrDefaultE(OrigAttr));
899        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
900          TIntPr OldNId(CrossId, it.GetId());
901          TIntPr NewId = EdgeMap.GetDat(OldNId);
902          TFlt Val = Net.GetFltAttrDatE(it.GetId(), OrigAttr);
903          NewNet->AddFltAttrDatE(NewId.Val1, Val, NewAttr);
904          if (NewId.Val2 != -1) {
905            NewNet->AddFltAttrDatE(NewId.Val2, Val, NewAttr);
906          }
907        }
908      } else if (type == TCrossNet::StrType) {
909        NewNet->AddStrAttrE(NewAttr, Net.GetStrAttrDefaultE(OrigAttr));
910        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++){
911          TIntPr OldNId(CrossId, it.GetId());
912          TIntPr NewId = EdgeMap.GetDat(OldNId);
913          TStr Val = Net.GetStrAttrDatE(it.GetId(), OrigAttr);
914          NewNet->AddStrAttrDatE(NewId.Val1, Val, NewAttr);
915          if (NewId.Val2 != -1) {
916            NewNet->AddStrAttrDatE(NewId.Val2, Val, NewAttr);
917          }
918        }
919      }
920    }
921    return NewNet;
922  }
923  PNEANet TMMNet::ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap) {
924    TIntPrIntH NodeMap;
925    THashSet<TInt> Modes;
926    PNEANet NewNet = TNEANet::New();
927    NewNet->AddIntAttrN(TStr("Mode"));
928    NewNet->AddIntAttrN(TStr("Id"));
929    NewNet->AddIntAttrE(TStr("CrossNet"));
930    NewNet->AddIntAttrE(TStr("Id"));
931    for (int i = 0; i < CrossNetTypes.Len(); i++) {
932      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
933      TStrPrV CNetAttrs;
934      if (EdgeAttrMap.IsKey(CrossNetTypes[i])) {
935        CNetAttrs = EdgeAttrMap.GetDat(CrossNetTypes[i]);
936      }
937      TInt Mode1 = CrossNet.GetMode1();
938      TInt Mode2 = CrossNet.GetMode2();
939      TModeNet& Mode1Net = GetModeNetById(Mode1);
940      TModeNet& Mode2Net = GetModeNetById(Mode2);
941      TStrPrV Mode1Attrs;
942      if (NodeAttrMap.IsKey(Mode1)) {
943        Mode1Attrs = NodeAttrMap.GetDat(Mode1);
944      }
945      TStrPrV Mode2Attrs;
946      if (NodeAttrMap.IsKey(Mode2)) {
947        Mode2Attrs = NodeAttrMap.GetDat(Mode2);
948      } 
949      Modes.AddKey(Mode1);
950      Modes.AddKey(Mode2);
951      bool isDirected = CrossNet.IsDirected();
952      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
953        int srcNode = EdgeI.GetSrcNId();
954        int dstNode = EdgeI.GetDstNId();
955        TIntPr SrcNodeMapping(Mode1, srcNode);
956        int srcId = 0;
957        if (NodeMap.IsKey(SrcNodeMapping)) {
958          srcId = NodeMap.GetDat(SrcNodeMapping);
959        } else {
960          srcId = NewNet->AddNode();
961          NodeMap.AddDat(SrcNodeMapping, srcId);
962          NewNet->AddIntAttrDatN(srcId, srcNode, TStr("Id"));
963          NewNet->AddIntAttrDatN(srcId, Mode1, TStr("Mode"));
964          AddNodeAttributes(NewNet, Mode1Net, Mode1Attrs, Mode1, srcNode, srcId);
965        }
966        TIntPr DstNodeMapping(Mode2, dstNode);
967        int dstId = 0;
968        if (NodeMap.IsKey(DstNodeMapping)) {
969          dstId = NodeMap.GetDat(DstNodeMapping);
970        } else {
971          dstId = NewNet->AddNode();
972          NodeMap.AddDat(DstNodeMapping, dstId);
973          NewNet->AddIntAttrDatN(dstId, dstNode, TStr("Id"));
974          NewNet->AddIntAttrDatN(dstId, Mode2, TStr("Mode"));
975          AddNodeAttributes(NewNet, Mode2Net, Mode2Attrs, Mode2, dstNode, dstId);
976        }
977        int edgeId = EdgeI.GetId();
978        int newEId = NewNet->AddEdge(srcId, dstId);
979        NewNet->AddIntAttrDatE(newEId, edgeId, TStr("Id"));
980        NewNet->AddIntAttrDatE(newEId, CrossNetTypes[i], TStr("CrossNet"));
981        AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, newEId);
982        if (!isDirected) {
983          int otherEId = NewNet->AddEdge(dstId, srcId);
984          NewNet->AddIntAttrDatE(otherEId, edgeId, TStr("Id"));
985          NewNet->AddIntAttrDatE(otherEId, CrossNetTypes[i], TStr("CrossNet"));
986          AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, otherEId);
987        }
988      }
989    }
990    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
991      TInt ModeId = it.GetKey();
992      TModeNet &ModeNet = GetModeNetById(ModeId);
993      TStrPrV ModeAttrs = NodeAttrMap.GetDat(ModeId);
994      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
995        TIntPr NodeKey(ModeId, NodeIt.GetId());
996        if (!NodeMap.IsKey(NodeKey)) {
997          int newId = NewNet->AddNode();
998          NodeMap.AddDat(NodeKey, newId);
999          AddNodeAttributes(NewNet, ModeNet, ModeAttrs, ModeId, NodeIt.GetId(), newId);
1000        }
1001      }
1002    }
1003    return NewNet;
1004  }
1005  void TMMNet::GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxLen) const {
1006    if (MxLen <= NumPartitions) {
1007        Partitions.Add(TIntPr(0,MxLen));
1008    } else {
1009      TInt PartitionSize = MxLen/NumPartitions;
1010      TInt CurrStart = 0;
1011      bool done = false;
1012      while (!done) {
1013        TInt CurrEnd = CurrStart + PartitionSize;
1014        if (MxLen - CurrEnd < PartitionSize) {
1015          CurrEnd = MxLen;
1016          done = true;
1017        }
1018        Partitions.Add(TIntPr(CurrStart, CurrEnd));
1019        CurrStart = CurrEnd;
1020      }
1021    }
1022  }
1023  #ifdef GCC_ATOMIC
1024  PNEANetMP TMMNet::ToNetworkMP(TStrV& CrossNetNames) {
1025    TStrIntH CrossNetStart;
1026    THashSet<TInt> ModeSet;
1027    int offset = 0;
1028    int NumEdges = 0;
1029    TVec<TCrossNet> CrossNets;
1030    for (int i=0; i < CrossNetNames.Len(); i++) {
1031      CrossNets.Add(GetCrossNetByName(CrossNetNames[i]));
1032      CrossNetStart.AddDat(CrossNetNames[i], offset);
1033      TCrossNet& CrossNet = GetCrossNetByName(CrossNetNames[i]);
1034      int factor = CrossNet.IsDirected() ? 1 : 2;
1035      offset += (CrossNet.GetMxEId() * factor);
1036      NumEdges += (CrossNet.GetEdges() * factor);
1037      ModeSet.AddKey(CrossNet.GetMode1());
1038      ModeSet.AddKey(CrossNet.GetMode2());
1039    }
1040    int MxEId = offset;
1041    int NumNodes = 0;
1042    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1043      TModeNet& ModeNet = GetModeNetById(MI.GetKey());
1044      NumNodes += ModeNet.GetNodes();
1045    }
1046    THashMP<TIntPr, TInt> NodeMap(NumNodes);
1047    THashMP<TIntPr, TIntPr> EdgeMap(NumEdges);
1048    PNEANetMP NewNet = TNEANetMP::New(NumNodes, NumEdges);
1049    int num_threads = omp_get_max_threads();
1050    offset = 0;
1051    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1052      TInt ModeId = MI.GetKey();
1053      TModeNet& ModeNet = GetModeNetById(ModeId);
1054      TIntV KeyIds;
1055      ModeNet.NodeH.GetKeyV(KeyIds);
1056      TIntPrV NodePartitions;
1057      GetPartitionRanges(NodePartitions, num_threads, KeyIds.Len());
1058      int curr_nid;
1059      #pragma omp parallel for schedule(static) private(curr_nid)
1060      for (int i = 0; i < NodePartitions.Len(); i++) {
1061        TInt CurrStart = NodePartitions[i].GetVal1();
1062        TInt CurrEnd = NodePartitions[i].GetVal2();
1063        curr_nid = offset + CurrStart;
1064        for (int idx = CurrStart; idx < CurrEnd ; idx++) {
1065          int n_i = KeyIds[idx];
1066          if (ModeNet.IsNode(n_i)) {
1067            TIntV InNbrs;
1068            TIntV OutNbrs;
1069            for (int j=0; j < CrossNetNames.Len(); j++) {
1070              TStr CrossNetName = TStr(CrossNetNames[j].CStr());
1071              if (ModeNet.NeighborTypes.IsKey(CrossNetName)) {
1072                if (ModeNet.NeighborTypes.GetDat(CrossNetName)) {
1073                  TIntV Neighbors;
1074                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, Neighbors);
1075                  int edge_offset = CrossNetStart.GetDat(CrossNetName);
1076                  TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1077                  bool isDir = CrossNet.IsDirected();
1078                  bool isOutNbr = CrossNet.GetMode1() == ModeId;
1079                  int factor = isDir ? 1 : 2;
1080                  int id_offset = isDir || isOutNbr ? 0 : 1;
1081                  if (!isDir && CrossNet.GetMode1() == CrossNet.GetMode2()) {
1082                    id_offset = n_i == CrossNet.GetEdge(n_i).GetSrcNId() ? 0 : 1;
1083                  }
1084                  for (int k = 0; k < Neighbors.Len(); k++) {
1085                    if (isOutNbr && id_offset == 0) {
1086                      OutNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1087                    } else {
1088                      InNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1089                    }
1090                    if (!isDir) {
1091                      int opp_offset = id_offset == 1 ? 0 : 1;
1092                      if (isOutNbr && id_offset == 0) {
1093                        InNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1094                      } else {
1095                        OutNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1096                      }
1097                    }
1098                  }
1099                } else {
1100                  TIntV TempOut;
1101                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempOut, true);
1102                  OutNbrs.AddV(TempOut);
1103                  TIntV TempIn;
1104                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempIn, false);
1105                  InNbrs.AddV(TempIn);
1106                }
1107              }
1108            }
1109            NewNet->AddNodeWithEdges(curr_nid, InNbrs, OutNbrs);
1110            TIntPr NodeKey(MI.GetKey(), n_i);
1111            NodeMap.AddDat(NodeKey, curr_nid);
1112            curr_nid++;
1113          }
1114        }
1115      }
1116      offset += KeyIds.Len();
1117    }
1118    NewNet->SetNodes(offset);
1119    for (int j=0; j < CrossNetNames.Len(); j++) {
1120      TStr CrossNetName = CrossNetNames[j];
1121      TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1122      TInt CrossNetId = GetCrossId(CrossNetName);
1123      TInt Mode1 = CrossNet.GetMode1();
1124      TInt Mode2 = CrossNet.GetMode2();
1125      TIntPrV EdgePartitions;
1126      GetPartitionRanges(EdgePartitions, num_threads, CrossNet.MxEId);
1127      int curr_eid;
1128      offset = CrossNetStart.GetDat(CrossNetNames[j]);
1129      int factor = CrossNet.IsDirected() ? 1 : 2;
1130      #pragma omp parallel for schedule(static) private(curr_eid)
1131      for (int i = 0; i < EdgePartitions.Len(); i++) {
1132        TInt CurrStart = EdgePartitions[i].GetVal1();
1133        TInt CurrEnd = EdgePartitions[i].GetVal2();
1134        for (int e_i = CurrStart; e_i < CurrEnd ; e_i++) {
1135          curr_eid = offset + factor*e_i;
1136          if (CrossNet.IsEdge(e_i)) {
1137            int new_eid = curr_eid;
1138            TIntPr EdgeKey(CrossNetId, e_i);
1139            TCrossNet::TCrossEdgeI edge = CrossNet.GetEdgeI(e_i);
1140            int srcNode = edge.GetSrcNId();
1141            int dstNode = edge.GetDstNId();
1142            TIntPr NodeKeySrc(Mode1, srcNode);
1143            TIntPr NodeKeyDst(Mode2, dstNode);
1144            int newSrc = NodeMap.GetDat(NodeKeySrc);
1145            int newDst = NodeMap.GetDat(NodeKeyDst);
1146            NewNet->AddEdgeUnchecked(curr_eid, newSrc, newDst);
1147            curr_eid++;
1148            int otherEId = -1;
1149            if (!CrossNet.IsDirected()) {
1150              otherEId = curr_eid;
1151              NewNet->AddEdgeUnchecked(otherEId, newDst, newSrc);
1152            }
1153            EdgeMap.AddDat(EdgeKey, TIntPr(new_eid, otherEId));
1154          }
1155        }
1156      }
1157    }
1158    NewNet->SetEdges(MxEId);
1159    NewNet->ReserveAttr(2, 0, 0, 2, 0, 0);
1160    NewNet->AddIntAttrN(TStr("Mode"));
1161    NewNet->AddIntAttrN(TStr("Id"));
1162    NewNet->AddIntAttrE(TStr("CrossNet"));
1163    NewNet->AddIntAttrE(TStr("Id"));
1164    TIntPrV NewNodeIds;
1165    NodeMap.GetKeyV(NewNodeIds);
1166    #pragma omp parallel for schedule(static)
1167    for(int i = 0; i < NewNodeIds.Len(); i++) {
1168      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal1(), TStr("Mode"));
1169      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal2(), TStr("Id"));
1170    }
<span onclick='openModal()' class='match'>1171    TIntPrV NewEdgeIds;
1172    EdgeMap.GetKeyV(NewEdgeIds);
1173    #pragma omp parallel for schedule(static)
1174    for(int i = 0; i < NewEdgeIds.Len(); i++) {
1175      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal2(), TStr("Id"));
</span>1176      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1177      if (EdgeMap.GetDat(NewEdgeIds[i]).GetVal2() != -1) {
1178        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1179        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1180      }
1181    }
1182    return NewNet;
1183  }
1184  #endif 
1185  int TMMNet::AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId) {
1186    for (int i = 0; i < Attrs.Len(); i++) {
1187      TStr OrigAttr = Attrs[i].Val1;
1188      TStr NewAttr = Attrs[i].Val2;
1189      int type = Net.GetAttrTypeN(OrigAttr);
1190      if (type == TModeNet::IntType) {
1191        TIntPr OldNId(ModeId, oldId);
1192        TInt Val = Net.GetIntAttrDatN(oldId, OrigAttr);
1193        NewNet->AddIntAttrDatN(NId, Val, NewAttr);
1194      } else if (type == TModeNet::FltType) {
1195        TIntPr OldNId(ModeId, oldId);
1196        TFlt Val = Net.GetFltAttrDatN(oldId, OrigAttr);
1197        NewNet->AddFltAttrDatN(NId, Val, NewAttr);
1198      } else if (type == TModeNet::StrType) {
1199        TIntPr OldNId(ModeId, oldId);
1200        TStr Val = Net.GetStrAttrDatN(oldId, OrigAttr);
1201        NewNet->AddStrAttrDatN(NId, Val, NewAttr);
1202      } else if (type == TModeNet::IntVType) {
1203        TIntPr OldNId(ModeId, oldId);
1204        TIntV Val = Net.GetIntVAttrDatN(oldId, OrigAttr);
1205        NewNet->AddIntVAttrDatN(NId, Val, NewAttr);
1206      }
1207    }
1208    return 0;
1209  }
1210  int TMMNet::AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId) {
1211    for (int i = 0; i < Attrs.Len(); i++) {
1212      TStr OrigAttr = Attrs[i].Val1;
1213      TStr NewAttr = Attrs[i].Val2;
1214      int type = Net.GetAttrTypeE(OrigAttr);
1215      if (type == TCrossNet::IntType) {
1216        TIntPr OldNId(CrossId, oldId);
1217        TInt Val = Net.GetIntAttrDatE(oldId, OrigAttr);
1218        NewNet->AddIntAttrDatE(EId, Val, NewAttr);
1219      } else if (type == TCrossNet::FltType) {
1220        TIntPr OldNId(CrossId, oldId);
1221        TFlt Val = Net.GetFltAttrDatE(oldId, OrigAttr);
1222        NewNet->AddFltAttrDatE(EId, Val, NewAttr);
1223      } else if (type == TCrossNet::StrType) {
1224        TIntPr OldNId(CrossId, oldId);
1225        TStr Val = Net.GetStrAttrDatE(oldId, OrigAttr);
1226        NewNet->AddStrAttrDatE(EId, Val, NewAttr);
1227      }
1228    }
1229    return 0;
1230  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1164    TIntPrV NewNodeIds;
1165    NodeMap.GetKeyV(NewNodeIds);
1166    #pragma omp parallel for schedule(static)
1167    for(int i = 0; i < NewNodeIds.Len(); i++) {
1168      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal1(), TStr("Mode"));
</pre></code></div>
                <div class="column column_space"><pre><code>1171    TIntPrV NewEdgeIds;
1172    EdgeMap.GetKeyV(NewEdgeIds);
1173    #pragma omp parallel for schedule(static)
1174    for(int i = 0; i < NewEdgeIds.Len(); i++) {
1175      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal2(), TStr("Id"));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    