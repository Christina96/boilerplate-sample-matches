
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.750279955207166%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wixexp.cpp</h3>
            <pre><code>1  class EWixExp{
2  private:
3    TStr ErrMsg;
4  public:
5    EWixExp(const TWixExp);
6    EWixExp(const TStr& _ErrMsg):
7      ErrMsg(_ErrMsg){}
8    EWixExp& operator=(const EWixExp& E){
9      ErrMsg=E.ErrMsg; return *this;}
10    TStr GetErrMsg() const {return ErrMsg;}
11  };
12  void TWixExpLxChDef::SetChTy(const TWixExpLxChTy& ChTy, const TStr& Str){
13    for (int ChN=0; ChN<Str.Len(); ChN++){ChTyV[Str[ChN]-TCh::Mn]=TInt(ChTy);}}
14  TWixExpLxChDef::TWixExpLxChDef():
15    ChTyV(TCh::Vals){
16    ChTyV.PutAll(TInt(welctAlpha));
17    for (char Ch=TCh::NullCh; Ch<=' '; Ch++){SetChTy(welctSpace, TStr(Ch));}
18    SetChTy(welctNum, "0123456789");
19    SetChTy(welctSym, "&|!()\"+-*:");
20    SetChTy(welctEof, TStr(TCh::EofCh));
21  }
22  TWixExpKwMap::TWixExpKwMap():
23    StrToKwH(20){
24    StrToKwH.AddDat("domain", wekDomain);
25    StrToKwH.AddDat("depth", wekDepth);
26    StrToKwH.AddDat("feature", wekFeature);
27    StrToKwH.AddDat("outgoingurl", wekOutgoingUrl);
28    StrToKwH.AddDat("title", wekTitle);
29    StrToKwH.AddDat("after", wekAfter);
30    StrToKwH.AddDat("before", wekBefore);
31    StrToKwH.AddDat("within", wekWithin);
32  }
33  bool TWixExpKwMap::IsExpKw(const TStr& ExpKwStr, TWixExpKw& ExpKw){
34    int KeyId=StrToKwH.GetKeyId(ExpKwStr);
35    if (KeyId==-1){return false;}
36    else {ExpKw=TWixExpKw(int(StrToKwH[KeyId])); return true;}
37  }
38  TWixExpLxChDef TWixExpLx::ChDef;
39  TWixExpLx::TWixExpLx(const TStr& ExpStr):
40    SIn(TStrIn::New(ExpStr)), Ch(' '),  Sym(wesyUndef), Str(){
41  }
42  TWixExpLxSym TWixExpLx::GetSym(const TFSet& Expect){
43    Str.Clr();
44    while (ChDef.IsSpace(Ch)){GetCh();}
45    if (Expect.In(wesyNum)){
46      if (!ChDef.IsNum(Ch)){throw EWixExp("Number expected.");}
47      Sym=wesyNum;
48      do {Str.AddCh(Ch); GetCh();} while (ChDef.IsNum(Ch));
49    } else {
50      switch (ChDef.GetChTy(Ch)){
51        case welctAlpha:
52        case welctNum:
53          do {Str.AddCh(Ch); GetCh();} while (ChDef.IsAlNum(Ch));
54          if (Str=="OR"){Sym=wesyOr;}
55          else if (Str=="AND"){Sym=wesyAnd;}
56          else if (Str=="NOT"){Sym=wesyNot;}
57          else {Sym=wesyWord;}
58          break;
59        case welctSym:
60          Str.AddCh(Ch);
61          switch (Ch){
62            case ':': Sym=wesyColon; break;
63            case '(': Sym=wesyLParen; break;
64            case ')': Sym=wesyRParen; break;
65            case '|': Sym=wesyOr; break;
66            case '&': Sym=wesyAnd; break;
67            case '!': Sym=wesyNot; break;
68            case '+': Sym=wesyIncl; break;
69            case '-': Sym=wesyExcl; break;
70            case '*': Sym=wesyWCard; break;
71            default: Sym=wesySSym;
72          }
73          GetCh();
74          break;
75        case welctEof: Sym=wesyEof; break;
76        default: Sym=wesyUndef; GetCh();
77      }
78    }
79    if ((!Expect.In(Sym))&&(!Expect.Empty())){
80      if (Sym==wesyEof){
81        throw EWixExp("Unexpected end of expression.");
82      } else {
83        throw EWixExp("Unexpected symbol.");
84      }
85    }
86    return Sym;
87  }
88  PWixExpDocIdSet TWixExpDocIdSet::AndDocSet(const PWixExpDocIdSet& DocSet){
89    PWixExpDocIdSet DstDocIdSet=PWixExpDocIdSet(new TWixExpDocIdSet());
90    TBlobPtV& V1=DocIdV;
91    TBlobPtV& V2=DocSet->DocIdV;
92    TBlobPtV& DstV=DstDocIdSet->DocIdV;
93    int N1=0; int N2=0;
94    while ((N1<V1.Len())&&(N2<V2.Len())){
95      TBlobPt& Val1=V1[N1];
96      while ((N2<V2.Len())&&(Val1>V2[N2])){
97        N2++;}
98      if ((N2<V2.Len())&&(Val1==V2[N2])){
99        TBlobPt Val(Val1); Val.MergeFlags(V2[N2]);
100        DstV.Add(Val); N2++;
101      }
102      N1++;
103    }
104    return DstDocIdSet;
105  }
106  PWixExpDocIdSet TWixExpDocIdSet::OrDocSet(const PWixExpDocIdSet& DocSet){
107    PWixExpDocIdSet DstDocIdSet=PWixExpDocIdSet(new TWixExpDocIdSet());
108    TBlobPtV& V1=DocIdV;
109    TBlobPtV& V2=DocSet->DocIdV;
110    TBlobPtV& DstV=DstDocIdSet->DocIdV;
111    int N1=0; int N2=0;
112    while ((N1<V1.Len())&&(N2<V2.Len())){
113      TBlobPt& Val1=V1[N1];
114      TBlobPt& Val2=V2[N2];
115      if (Val1<Val2){DstV.Add(Val1); N1++;}
116      else if (Val1>Val2){DstV.Add(Val2); N2++;}
117      else {TBlobPt Val(Val1); Val.MergeFlags(Val2); DstV.Add(Val); N1++; N2++;}
118    }
119    for (int RestN1=N1; RestN1<V1.Len(); RestN1++){DstV.Add(V1[RestN1]);}
<span onclick='openModal()' class='match'>120    for (int RestN2=N2; RestN2<V2.Len(); RestN2++){DstV.Add(V2[RestN2]);}
121    return DstDocIdSet;
122  }
123  TWixExpItem::TWixExpItem(const TWixExpItemType& _Type,
124   const PWixExpItem& ExpItem1, const PWixExpItem& ExpItem2):
125    Type(_Type), ExpItemV(), WordStrV(){
126    IAssert(
127     (Type==weitOr)||(Type==weitAnd)||(Type==weitNot)||
128     (Type==weitIncl)||(Type==weitExcl)||(Type==weitWCard));
129    if (Type==weitWCard){
</span>130      IAssert(ExpItem1->GetType()==weitWord);
131      IAssert(ExpItem2.Empty());
132    }
133    ExpItemV.Add(ExpItem1);
134    if (!ExpItem2.Empty()){ExpItemV.Add(ExpItem2);}
135  }
136  TWixExpItem::TWixExpItem(const TStr& WordStr):
137    Type(weitWord), ExpItemV(), WordStrV(){
138    WordStrV.Add(WordStr);
139  }
140  TWixExpItem::TWixExpItem(const TStrV& _WordStrV):
141    Type(weitPhrase), ExpItemV(), WordStrV(_WordStrV){}
142  TWixExpItem::TWixExpItem(const TStr& MetaTag, const TStrV& ArgStrV):
143    Type(weitMeta), ExpItemV(), WordStrV(){
144    WordStrV.Add(MetaTag);
145    WordStrV.AddV(ArgStrV);
146  }
147  PWixExpItem TWixExpItem::GetExpItem(const int& ExpItemN){
148    IAssert(
149     (Type==weitOr)||(Type==weitAnd)||(Type==weitNot)||
150     (Type==weitIncl)||(Type==weitExcl)||(Type==weitWCard));
151    return ExpItemV[ExpItemN];
152  }
153  TStr TWixExpItem::GetWordStr(){
154    IAssert(Type==weitWord);
155    return WordStrV[0];
156  }
157  int TWixExpItem::GetPhraseLen(){
158    IAssert(Type==weitPhrase);
159    return WordStrV.Len();
160  }
161  TStr TWixExpItem::GetPhraseWordStr(const int& WordStrN){
162    IAssert(Type==weitPhrase);
163    return WordStrV[WordStrN];
164  }
165  PWixExpDocIdSet TWixExpItem::Eval(const PWix& Wix){
166    PWixExpDocIdSet DocIdSet;
167    switch (Type){
168      case weitOr:{
169        DocIdSet=GetExpItem(0)->Eval(Wix);
170        PWixExpDocIdSet RDocIdSet=GetExpItem(1)->Eval(Wix);
171        DocIdSet=DocIdSet->OrDocSet(RDocIdSet);
172        break;}
173      case weitAnd:{
174        DocIdSet=GetExpItem(0)->Eval(Wix);
175        PWixExpDocIdSet RDocIdSet=GetExpItem(1)->Eval(Wix);
176        DocIdSet=DocIdSet->AndDocSet(RDocIdSet);
177        break;}
178      case weitNot:{
179        DocIdSet=GetExpItem()->Eval(Wix);
180        DocIdSet->PutNegated(!DocIdSet->IsNegated());
181        break;}
182      case weitIncl: break; /&bsol;**
183      case weitExcl: break; /&bsol;**
184      case weitWCard:{
185        PWixExpItem SubExpItem=GetExpItem();
186        TBlobPtV DocIdV;
187        Wix->GetDocIdV(SubExpItem->GetWordStr(), false, 100, DocIdV);
188        DocIdSet=PWixExpDocIdSet(new TWixExpDocIdSet(DocIdV));
189        break;}
190      case weitWord:{
191        TBlobPtV DocIdV;
192        Wix->GetDocIdV(GetWordStr(), true, -1, DocIdV);
193        DocIdSet=PWixExpDocIdSet(new TWixExpDocIdSet(DocIdV));
194        break;}
195      case weitPhrase: break; /&bsol;**
196      case weitMeta: break; /&bsol;**
197      default: Fail;
198    }
199    return DocIdSet;
200  }
201  PWixExpItem TWixExp::ParseFact(TWixExpLx& Lx, const TFSet& Expect){
202    if (Lx.Sym==wesyNot){
203      Lx.GetSym(FactExpect);
204      PWixExpItem ExpItem=ParseFact(Lx, Expect);
205      return PWixExpItem(new TWixExpItem(weitNot, ExpItem));
206    } else
207    if (Lx.Sym==wesyIncl){
208      Lx.GetSym(FactExpect);
209      PWixExpItem ExpItem=ParseFact(Lx, Expect);
210      return PWixExpItem(new TWixExpItem(weitIncl, ExpItem));
211    } else
212    if (Lx.Sym==wesyExcl){
213      Lx.GetSym(FactExpect);
214      PWixExpItem ExpItem=ParseFact(Lx, Expect);
215      return PWixExpItem(new TWixExpItem(weitExcl, ExpItem));
216    } else
217    if (Lx.Sym==wesyLParen){
218      Lx.GetSym(ExpExpect);
219      PWixExpItem ExpItem=ParseExp(Lx, TFSet()|wesyRParen);
220      Lx.GetSym(Expect);
221      return ExpItem;
222    } else
223    if (Lx.Sym==wesyDQuote){
224      TStrV WordStrV;
225      Lx.GetSym(TFSet()|wesyWord|wesyDQuote);
226      while (Lx.Sym==wesyWord){
227        WordStrV.Add(Lx.Str);
228        Lx.GetSym(TFSet()|wesyWord|wesyDQuote);
229      }
230      Lx.GetSym(Expect);
231      return PWixExpItem(new TWixExpItem(WordStrV));
232    } else
233    if (Lx.Sym==wesyWord){
234      PWixExpItem ExpItem=PWixExpItem(new TWixExpItem(Lx.Str));
235      Lx.GetSym(TFSet(Expect)|wesyWCard);
236      if (Lx.Sym==wesyWCard){
237        PWixExpItem WCardExpItem=
238         PWixExpItem(new TWixExpItem(weitWCard, ExpItem));
239        ExpItem=WCardExpItem;
240        Lx.GetSym(Expect);
241      }
242      return ExpItem;
243    } else {
244      Fail; return NULL;
245    }
246  }
247  PWixExpItem TWixExp::ParseTerm(TWixExpLx& Lx, const TFSet& Expect){
248    TFSet LoopExpect=TFSet(Expect)|FactExpect|wesyAnd;
249    PWixExpItem ExpItem=ParseFact(Lx, LoopExpect);
250    while ((Lx.Sym==wesyAnd)||(FactExpect.In(Lx.Sym))){
251      if (Lx.Sym==wesyAnd){
252        Lx.GetSym(FactExpect);}
253      PWixExpItem RExpItem=ParseFact(Lx, LoopExpect);
254      ExpItem=PWixExpItem(new TWixExpItem(weitAnd, ExpItem, RExpItem));
255    }
256    return ExpItem;
257  }
258  PWixExpItem TWixExp::ParseExp(TWixExpLx& Lx, const TFSet& Expect){
259    PWixExpItem ExpItem=ParseTerm(Lx, TFSet(Expect)|wesyOr);
260    while (Lx.Sym==wesyOr){
261      Lx.GetSym(TermExpect);
262      PWixExpItem RExpItem=ParseTerm(Lx, TFSet(Expect)|wesyOr);
263      ExpItem=PWixExpItem(new TWixExpItem(weitOr, ExpItem, RExpItem));
264    }
265    return ExpItem;
266  }
267  TWixExp::TWixExp(const TStr& _ExpStr):
268    ExpStr(_ExpStr), Ok(true), ErrMsg(), ExpItem(),
269    FactExpect(), TermExpect(), ExpExpect(){
270    FactExpect=TFSet()|wesyNot|wesyIncl|wesyExcl|wesyLParen|wesyDQuote|wesyWord;
271    TermExpect=FactExpect;
272    ExpExpect=TermExpect;
273    TWixExpLx Lx(ExpStr);
274    try {
275      Lx.GetSym(ExpExpect);
276      ExpItem=ParseExp(Lx, TFSet()|wesyEof);
277    }
278    catch (EWixExp E){
279      Ok=false; ErrMsg=E.GetErrMsg();
280    }
281  }
282  PWixExpDocIdSet TWixExp::Eval(const PWix& Wix){
283    PWixExpDocIdSet DocIdSet=ExpItem->Eval(Wix);
284    return DocIdSet;
285  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.cc</h3>
            <pre><code>1  #include "gmock/gmock-spec-builders.h"
2  #include <stdlib.h>
3  #include <iostream>  
4  #include <map>
5  #include <set>
6  #include <string>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #if GTEST_OS_CYGWIN || GTEST_OS_LINUX || GTEST_OS_MAC
10  # include <unistd.h>  
11  #endif
12  namespace testing {
13  namespace internal {
14  GTEST_API_ GTEST_DEFINE_STATIC_MUTEX_(g_gmock_mutex);
15  GTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,
16                                  const char* file, int line,
17                                  const string& message) {
18    ::std::ostringstream s;
19    s << file << ":" << line << ": " << message << ::std::endl;
20    Log(severity, s.str(), 0);
21  }
22  ExpectationBase::ExpectationBase(const char* a_file,
23                                   int a_line,
24                                   const string& a_source_text)
25      : file_(a_file),
26        line_(a_line),
27        source_text_(a_source_text),
28        cardinality_specified_(false),
29        cardinality_(Exactly(1)),
30        call_count_(0),
31        retired_(false),
32        extra_matcher_specified_(false),
33        repeated_action_specified_(false),
34        retires_on_saturation_(false),
35        last_clause_(kNone),
36        action_count_checked_(false) {}
37  ExpectationBase::~ExpectationBase() {}
38  void ExpectationBase::SpecifyCardinality(const Cardinality& a_cardinality) {
39    cardinality_specified_ = true;
40    cardinality_ = a_cardinality;
41  }
42  void ExpectationBase::RetireAllPreRequisites()
43      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
44    if (is_retired()) {
45      return;
46    }
47    for (ExpectationSet::const_iterator it = immediate_prerequisites_.begin();
48         it != immediate_prerequisites_.end(); ++it) {
49      ExpectationBase* const prerequisite = it->expectation_base().get();
50      if (!prerequisite->is_retired()) {
51        prerequisite->RetireAllPreRequisites();
52        prerequisite->Retire();
53      }
54    }
55  }
56  bool ExpectationBase::AllPrerequisitesAreSatisfied() const
57      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
58    g_gmock_mutex.AssertHeld();
59    for (ExpectationSet::const_iterator it = immediate_prerequisites_.begin();
60         it != immediate_prerequisites_.end(); ++it) {
61      if (!(it->expectation_base()->IsSatisfied()) ||
62          !(it->expectation_base()->AllPrerequisitesAreSatisfied()))
63        return false;
64    }
65    return true;
66  }
67  void ExpectationBase::FindUnsatisfiedPrerequisites(ExpectationSet* result) const
68      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
69    g_gmock_mutex.AssertHeld();
70    for (ExpectationSet::const_iterator it = immediate_prerequisites_.begin();
71         it != immediate_prerequisites_.end(); ++it) {
72      if (it->expectation_base()->IsSatisfied()) {
73        if (it->expectation_base()->call_count_ == 0) {
74          it->expectation_base()->FindUnsatisfiedPrerequisites(result);
75        }
76      } else {
77        *result += *it;
78      }
79    }
80  }
81  void ExpectationBase::DescribeCallCountTo(::std::ostream* os) const
82      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
83    g_gmock_mutex.AssertHeld();
84    *os << "         Expected: to be ";
85    cardinality().DescribeTo(os);
86    *os << "\n           Actual: ";
87    Cardinality::DescribeActualCallCountTo(call_count(), os);
88    *os << " - " << (IsOverSaturated() ? "over-saturated" :
89                     IsSaturated() ? "saturated" :
90                     IsSatisfied() ? "satisfied" : "unsatisfied")
91        << " and "
92        << (is_retired() ? "retired" : "active");
93  }
94  void ExpectationBase::CheckActionCountIfNotDone() const
95      GTEST_LOCK_EXCLUDED_(mutex_) {
96    bool should_check = false;
97    {
98      MutexLock l(&mutex_);
99      if (!action_count_checked_) {
100        action_count_checked_ = true;
101        should_check = true;
102      }
103    }
104    if (should_check) {
105      if (!cardinality_specified_) {
106        return;
107      }
108      const int action_count = static_cast<int>(untyped_actions_.size());
109      const int upper_bound = cardinality().ConservativeUpperBound();
110      const int lower_bound = cardinality().ConservativeLowerBound();
111      bool too_many;  
112      if (action_count > upper_bound ||
113          (action_count == upper_bound && repeated_action_specified_)) {
114        too_many = true;
115      } else if (0 < action_count && action_count < lower_bound &&
116                 !repeated_action_specified_) {
117        too_many = false;
118      } else {
119        return;
120      }
121      ::std::stringstream ss;
122      DescribeLocationTo(&ss);
123      ss << "Too " << (too_many ? "many" : "few")
124         << " actions specified in " << source_text() << "...\n"
125         << "Expected to be ";
126      cardinality().DescribeTo(&ss);
127      ss << ", but has " << (too_many ? "" : "only ")
128         << action_count << " WillOnce()"
129         << (action_count == 1 ? "" : "s");
130      if (repeated_action_specified_) {
131        ss << " and a WillRepeatedly()";
132      }
133      ss << ".";
134      Log(kWarning, ss.str(), -1);  
135    }
136  }
137  void ExpectationBase::UntypedTimes(const Cardinality& a_cardinality) {
138    if (last_clause_ == kTimes) {
139      ExpectSpecProperty(false,
140                         ".Times() cannot appear "
141                         "more than once in an EXPECT_CALL().");
142    } else {
143      ExpectSpecProperty(last_clause_ < kTimes,
144                         ".Times() cannot appear after "
145                         ".InSequence(), .WillOnce(), .WillRepeatedly(), "
146                         "or .RetiresOnSaturation().");
147    }
148    last_clause_ = kTimes;
149    SpecifyCardinality(a_cardinality);
150  }
151  GTEST_API_ ThreadLocal<Sequence*> g_gmock_implicit_sequence;
152  void ReportUninterestingCall(CallReaction reaction, const string& msg) {
153    switch (reaction) {
154      case kAllow:
155        Log(kInfo, msg, 3);
156        break;
157      case kWarn:
158        Log(kWarning, msg, 3);
159        break;
160      default:  
161        Expect(false, NULL, -1, msg);
162    }
163  }
164  UntypedFunctionMockerBase::UntypedFunctionMockerBase()
165      : mock_obj_(NULL), name_("") {}
166  UntypedFunctionMockerBase::~UntypedFunctionMockerBase() {}
167  void UntypedFunctionMockerBase::RegisterOwner(const void* mock_obj)
168      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
169    {
170      MutexLock l(&g_gmock_mutex);
171      mock_obj_ = mock_obj;
172    }
173    Mock::Register(mock_obj, this);
174  }
175  void UntypedFunctionMockerBase::SetOwnerAndName(const void* mock_obj,
176                                                  const char* name)
177      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
178    MutexLock l(&g_gmock_mutex);
179    mock_obj_ = mock_obj;
180    name_ = name;
181  }
182  const void* UntypedFunctionMockerBase::MockObject() const
183      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
184    const void* mock_obj;
185    {
186      MutexLock l(&g_gmock_mutex);
187      Assert(mock_obj_ != NULL, __FILE__, __LINE__,
188             "MockObject() must not be called before RegisterOwner() or "
189             "SetOwnerAndName() has been called.");
190      mock_obj = mock_obj_;
191    }
192    return mock_obj;
193  }
194  const char* UntypedFunctionMockerBase::Name() const
195      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
196    const char* name;
197    {
198      MutexLock l(&g_gmock_mutex);
199      Assert(name_ != NULL, __FILE__, __LINE__,
200             "Name() must not be called before SetOwnerAndName() has "
201             "been called.");
202      name = name_;
<span onclick='openModal()' class='match'>203    }
204    return name;
205  }
206  const UntypedActionResultHolderBase*
207  UntypedFunctionMockerBase::UntypedInvokeWith(const void* const untyped_args)
208      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
209    if (untyped_expectations_.size() == 0) {
</span>210      const CallReaction reaction =
211          Mock::GetReactionOnUninterestingCalls(MockObject());
212      const bool need_to_report_uninteresting_call =
213          reaction == kAllow ? LogIsVisible(kInfo) :
214          reaction == kWarn ? LogIsVisible(kWarning) :
215          true;
216      if (!need_to_report_uninteresting_call) {
217        return this->UntypedPerformDefaultAction(untyped_args, "");
218      }
219      ::std::stringstream ss;
220      this->UntypedDescribeUninterestingCall(untyped_args, &ss);
221      const UntypedActionResultHolderBase* const result =
222          this->UntypedPerformDefaultAction(untyped_args, ss.str());
223      if (result != NULL)
224        result->PrintAsActionResult(&ss);
225      ReportUninterestingCall(reaction, ss.str());
226      return result;
227    }
228    bool is_excessive = false;
229    ::std::stringstream ss;
230    ::std::stringstream why;
231    ::std::stringstream loc;
232    const void* untyped_action = NULL;
233    const ExpectationBase* const untyped_expectation =
234        this->UntypedFindMatchingExpectation(
235            untyped_args, &untyped_action, &is_excessive,
236            &ss, &why);
237    const bool found = untyped_expectation != NULL;
238    const bool need_to_report_call =
239        !found || is_excessive || LogIsVisible(kInfo);
240    if (!need_to_report_call) {
241      return
242          untyped_action == NULL ?
243          this->UntypedPerformDefaultAction(untyped_args, "") :
244          this->UntypedPerformAction(untyped_action, untyped_args);
245    }
246    ss << "    Function call: " << Name();
247    this->UntypedPrintArgs(untyped_args, &ss);
248    if (found && !is_excessive) {
249      untyped_expectation->DescribeLocationTo(&loc);
250    }
251    const UntypedActionResultHolderBase* const result =
252        untyped_action == NULL ?
253        this->UntypedPerformDefaultAction(untyped_args, ss.str()) :
254        this->UntypedPerformAction(untyped_action, untyped_args);
255    if (result != NULL)
256      result->PrintAsActionResult(&ss);
257    ss << "\n" << why.str();
258    if (!found) {
259      Expect(false, NULL, -1, ss.str());
260    } else if (is_excessive) {
261      Expect(false, untyped_expectation->file(),
262             untyped_expectation->line(), ss.str());
263    } else {
264      Log(kInfo, loc.str() + ss.str(), 2);
265    }
266    return result;
267  }
268  Expectation UntypedFunctionMockerBase::GetHandleOf(ExpectationBase* exp) {
269    for (UntypedExpectations::const_iterator it =
270             untyped_expectations_.begin();
271         it != untyped_expectations_.end(); ++it) {
272      if (it->get() == exp) {
273        return Expectation(*it);
274      }
275    }
276    Assert(false, __FILE__, __LINE__, "Cannot find expectation.");
277    return Expectation();
278  }
279  bool UntypedFunctionMockerBase::VerifyAndClearExpectationsLocked()
280      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
281    g_gmock_mutex.AssertHeld();
282    bool expectations_met = true;
283    for (UntypedExpectations::const_iterator it =
284             untyped_expectations_.begin();
285         it != untyped_expectations_.end(); ++it) {
286      ExpectationBase* const untyped_expectation = it->get();
287      if (untyped_expectation->IsOverSaturated()) {
288        expectations_met = false;
289      } else if (!untyped_expectation->IsSatisfied()) {
290        expectations_met = false;
291        ::std::stringstream ss;
292        ss  << "Actual function call count doesn't match "
293            << untyped_expectation->source_text() << "...\n";
294        untyped_expectation->MaybeDescribeExtraMatcherTo(&ss);
295        untyped_expectation->DescribeCallCountTo(&ss);
296        Expect(false, untyped_expectation->file(),
297               untyped_expectation->line(), ss.str());
298      }
299    }
300    UntypedExpectations expectations_to_delete;
301    untyped_expectations_.swap(expectations_to_delete);
302    g_gmock_mutex.Unlock();
303    expectations_to_delete.clear();
304    g_gmock_mutex.Lock();
305    return expectations_met;
306  }
307  }  
308  namespace {
309  typedef std::set<internal::UntypedFunctionMockerBase*> FunctionMockers;
310  struct MockObjectState {
311    MockObjectState()
312        : first_used_file(NULL), first_used_line(-1), leakable(false) {}
313    const char* first_used_file;
314    int first_used_line;
315    ::std::string first_used_test_case;
316    ::std::string first_used_test;
317    bool leakable;  
318    FunctionMockers function_mockers;  
319  };
320  class MockObjectRegistry {
321   public:
322    typedef std::map<const void*, MockObjectState> StateMap;
323    ~MockObjectRegistry() {
324      if (!GMOCK_FLAG(catch_leaked_mocks))
325        return;
326      int leaked_count = 0;
327      for (StateMap::const_iterator it = states_.begin(); it != states_.end();
328           ++it) {
329        if (it->second.leakable)  
330          continue;
331        std::cout << "\n";
332        const MockObjectState& state = it->second;
333        std::cout << internal::FormatFileLocation(state.first_used_file,
334                                                  state.first_used_line);
335        std::cout << " ERROR: this mock object";
336        if (state.first_used_test != "") {
337          std::cout << " (used in test " << state.first_used_test_case << "."
338               << state.first_used_test << ")";
339        }
340        std::cout << " should be deleted but never is. Its address is @"
341             << it->first << ".";
342        leaked_count++;
343      }
344      if (leaked_count > 0) {
345        std::cout << "\nERROR: " << leaked_count
346             << " leaked mock " << (leaked_count == 1 ? "object" : "objects")
347             << " found at program exit.\n";
348        std::cout.flush();
349        ::std::cerr.flush();
350        _exit(1);  
351      }
352    }
353    StateMap& states() { return states_; }
354   private:
355    StateMap states_;
356  };
357  MockObjectRegistry g_mock_object_registry;
358  std::map<const void*, internal::CallReaction> g_uninteresting_call_reaction;
359  void SetReactionOnUninterestingCalls(const void* mock_obj,
360                                       internal::CallReaction reaction)
361      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
362    internal::MutexLock l(&internal::g_gmock_mutex);
363    g_uninteresting_call_reaction[mock_obj] = reaction;
364  }
365  }  
366  void Mock::AllowUninterestingCalls(const void* mock_obj)
367      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
368    SetReactionOnUninterestingCalls(mock_obj, internal::kAllow);
369  }
370  void Mock::WarnUninterestingCalls(const void* mock_obj)
371      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
372    SetReactionOnUninterestingCalls(mock_obj, internal::kWarn);
373  }
374  void Mock::FailUninterestingCalls(const void* mock_obj)
375      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
376    SetReactionOnUninterestingCalls(mock_obj, internal::kFail);
377  }
378  void Mock::UnregisterCallReaction(const void* mock_obj)
379      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
380    internal::MutexLock l(&internal::g_gmock_mutex);
381    g_uninteresting_call_reaction.erase(mock_obj);
382  }
383  internal::CallReaction Mock::GetReactionOnUninterestingCalls(
384      const void* mock_obj)
385          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
386    internal::MutexLock l(&internal::g_gmock_mutex);
387    return (g_uninteresting_call_reaction.count(mock_obj) == 0) ?
388        internal::kDefault : g_uninteresting_call_reaction[mock_obj];
389  }
390  void Mock::AllowLeak(const void* mock_obj)
391      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
392    internal::MutexLock l(&internal::g_gmock_mutex);
393    g_mock_object_registry.states()[mock_obj].leakable = true;
394  }
395  bool Mock::VerifyAndClearExpectations(void* mock_obj)
396      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
397    internal::MutexLock l(&internal::g_gmock_mutex);
398    return VerifyAndClearExpectationsLocked(mock_obj);
399  }
400  bool Mock::VerifyAndClear(void* mock_obj)
401      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
402    internal::MutexLock l(&internal::g_gmock_mutex);
403    ClearDefaultActionsLocked(mock_obj);
404    return VerifyAndClearExpectationsLocked(mock_obj);
405  }
406  bool Mock::VerifyAndClearExpectationsLocked(void* mock_obj)
407      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex) {
408    internal::g_gmock_mutex.AssertHeld();
409    if (g_mock_object_registry.states().count(mock_obj) == 0) {
410      return true;
411    }
412    bool expectations_met = true;
413    FunctionMockers& mockers =
414        g_mock_object_registry.states()[mock_obj].function_mockers;
415    for (FunctionMockers::const_iterator it = mockers.begin();
416         it != mockers.end(); ++it) {
417      if (!(*it)->VerifyAndClearExpectationsLocked()) {
418        expectations_met = false;
419      }
420    }
421    return expectations_met;
422  }
423  void Mock::Register(const void* mock_obj,
424                      internal::UntypedFunctionMockerBase* mocker)
425      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
426    internal::MutexLock l(&internal::g_gmock_mutex);
427    g_mock_object_registry.states()[mock_obj].function_mockers.insert(mocker);
428  }
429  void Mock::RegisterUseByOnCallOrExpectCall(const void* mock_obj,
430                                             const char* file, int line)
431      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
432    internal::MutexLock l(&internal::g_gmock_mutex);
433    MockObjectState& state = g_mock_object_registry.states()[mock_obj];
434    if (state.first_used_file == NULL) {
435      state.first_used_file = file;
436      state.first_used_line = line;
437      const TestInfo* const test_info =
438          UnitTest::GetInstance()->current_test_info();
439      if (test_info != NULL) {
440        state.first_used_test_case = test_info->test_case_name();
441        state.first_used_test = test_info->name();
442      }
443    }
444  }
445  void Mock::UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)
446      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex) {
447    internal::g_gmock_mutex.AssertHeld();
448    for (MockObjectRegistry::StateMap::iterator it =
449             g_mock_object_registry.states().begin();
450         it != g_mock_object_registry.states().end(); ++it) {
451      FunctionMockers& mockers = it->second.function_mockers;
452      if (mockers.erase(mocker) > 0) {
453        if (mockers.empty()) {
454          g_mock_object_registry.states().erase(it);
455        }
456        return;
457      }
458    }
459  }
460  void Mock::ClearDefaultActionsLocked(void* mock_obj)
461      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex) {
462    internal::g_gmock_mutex.AssertHeld();
463    if (g_mock_object_registry.states().count(mock_obj) == 0) {
464      return;
465    }
466    FunctionMockers& mockers =
467        g_mock_object_registry.states()[mock_obj].function_mockers;
468    for (FunctionMockers::const_iterator it = mockers.begin();
469         it != mockers.end(); ++it) {
470      (*it)->ClearDefaultActionsLocked();
471    }
472  }
473  Expectation::Expectation() {}
474  Expectation::Expectation(
475      const internal::linked_ptr<internal::ExpectationBase>& an_expectation_base)
476      : expectation_base_(an_expectation_base) {}
477  Expectation::~Expectation() {}
478  void Sequence::AddExpectation(const Expectation& expectation) const {
479    if (*last_expectation_ != expectation) {
480      if (last_expectation_->expectation_base() != NULL) {
481        expectation.expectation_base()->immediate_prerequisites_
482            += *last_expectation_;
483      }
484      *last_expectation_ = expectation;
485    }
486  }
487  InSequence::InSequence() {
488    if (internal::g_gmock_implicit_sequence.get() == NULL) {
489      internal::g_gmock_implicit_sequence.set(new Sequence);
490      sequence_created_ = true;
491    } else {
492      sequence_created_ = false;
493    }
494  }
495  InSequence::~InSequence() {
496    if (sequence_created_) {
497      delete internal::g_gmock_implicit_sequence.get();
498      internal::g_gmock_implicit_sequence.set(NULL);
499    }
500  }
501  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wixexp.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.cc</div>
                </div>
                <div class="column column_space"><pre><code>120    for (int RestN2=N2; RestN2<V2.Len(); RestN2++){DstV.Add(V2[RestN2]);}
121    return DstDocIdSet;
122  }
123  TWixExpItem::TWixExpItem(const TWixExpItemType& _Type,
124   const PWixExpItem& ExpItem1, const PWixExpItem& ExpItem2):
125    Type(_Type), ExpItemV(), WordStrV(){
126    IAssert(
127     (Type==weitOr)||(Type==weitAnd)||(Type==weitNot)||
128     (Type==weitIncl)||(Type==weitExcl)||(Type==weitWCard));
129    if (Type==weitWCard){
</pre></code></div>
                <div class="column column_space"><pre><code>203    }
204    return name;
205  }
206  const UntypedActionResultHolderBase*
207  UntypedFunctionMockerBase::UntypedInvokeWith(const void* const untyped_args)
208      GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
209    if (untyped_expectations_.size() == 0) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    