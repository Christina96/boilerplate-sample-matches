<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infotag.cpp &amp; id3v2tag.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infotag.cpp &amp; id3v2tag.cpp
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infotag.cpp (4.33213%)<th>id3v2tag.cpp (1.4760147%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(224-236)<td><a href="#" name="0">(711-723)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infotag.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;tdebug.h&gt;
2 #include &lt;tfile.h&gt;
3 #include "infotag.h"
4 #include "riffutils.h"
5 using namespace TagLib;
6 using namespace RIFF::Info;
7 namespace
8 {
9   const RIFF::Info::StringHandler defaultStringHandler;
10   const RIFF::Info::StringHandler *stringHandler = &amp;defaultStringHandler;
11 }
12 class RIFF::Info::Tag::TagPrivate
13 {
14 public:
15   FieldListMap fieldListMap;
16 };
17 StringHandler::StringHandler()
18 {
19 }
20 StringHandler::~StringHandler()
21 {
22 }
23 String RIFF::Info::StringHandler::parse(const ByteVector &amp;data) const
24 {
25   return String(data, String::UTF8);
26 }
27 ByteVector RIFF::Info::StringHandler::render(const String &amp;s) const
28 {
29   return s.data(String::UTF8);
30 }
31 RIFF::Info::Tag::Tag(const ByteVector &amp;data) :
32   d(new TagPrivate())
33 {
34   parse(data);
35 }
36 RIFF::Info::Tag::Tag() :
37   d(new TagPrivate())
38 {
39 }
40 RIFF::Info::Tag::~Tag()
41 {
42   delete d;
43 }
44 String RIFF::Info::Tag::title() const
45 {
46   return fieldText("INAM");
47 }
48 String RIFF::Info::Tag::artist() const
49 {
50   return fieldText("IART");
51 }
52 String RIFF::Info::Tag::album() const
53 {
54   return fieldText("IPRD");
55 }
56 String RIFF::Info::Tag::comment() const
57 {
58   return fieldText("ICMT");
59 }
60 String RIFF::Info::Tag::genre() const
61 {
62   return fieldText("IGNR");
63 }
64 unsigned int RIFF::Info::Tag::year() const
65 {
66   return fieldText("ICRD").substr(0, 4).toInt();
67 }
68 unsigned int RIFF::Info::Tag::track() const
69 {
70   return fieldText("IPRT").toInt();
71 }
72 void RIFF::Info::Tag::setTitle(const String &amp;s)
73 {
74   setFieldText("INAM", s);
75 }
76 void RIFF::Info::Tag::setArtist(const String &amp;s)
77 {
78   setFieldText("IART", s);
79 }
80 void RIFF::Info::Tag::setAlbum(const String &amp;s)
81 {
82   setFieldText("IPRD", s);
83 }
84 void RIFF::Info::Tag::setComment(const String &amp;s)
85 {
86   setFieldText("ICMT", s);
87 }
88 void RIFF::Info::Tag::setGenre(const String &amp;s)
89 {
90   setFieldText("IGNR", s);
91 }
92 void RIFF::Info::Tag::setYear(unsigned int i)
93 {
94   if(i != 0)
95     setFieldText("ICRD", String::number(i));
96   else
97     d-&gt;fieldListMap.erase("ICRD");
98 }
99 void RIFF::Info::Tag::setTrack(unsigned int i)
100 {
101   if(i != 0)
102     setFieldText("IPRT", String::number(i));
103   else
104     d-&gt;fieldListMap.erase("IPRT");
105 }
106 bool RIFF::Info::Tag::isEmpty() const
107 {
108   return d-&gt;fieldListMap.isEmpty();
109 }
110 FieldListMap RIFF::Info::Tag::fieldListMap() const
111 {
112   return d-&gt;fieldListMap;
113 }
114 String RIFF::Info::Tag::fieldText(const ByteVector &amp;id) const
115 {
116   if(d-&gt;fieldListMap.contains(id))
117     return String(d-&gt;fieldListMap[id]);
118   return String();
119 }
120 void RIFF::Info::Tag::setFieldText(const ByteVector &amp;id, const String &amp;s)
121 {
122   if(!isValidChunkName(id))
123     return;
124   if(!s.isEmpty())
125     d-&gt;fieldListMap[id] = s;
126   else
127     removeField(id);
128 }
129 void RIFF::Info::Tag::removeField(const ByteVector &amp;id)
130 {
131   if(d-&gt;fieldListMap.contains(id))
132     d-&gt;fieldListMap.erase(id);
133 }
134 ByteVector RIFF::Info::Tag::render() const
135 {
136   ByteVector data("INFO");
137   FieldListMap::ConstIterator it = d-&gt;fieldListMap.begin();
138   for(; it != d-&gt;fieldListMap.end(); ++it) {
139     ByteVector text = stringHandler-&gt;render(it-&gt;second);
140     if(text.isEmpty())
141       continue;
142     data.append(it-&gt;first);
143     data.append(ByteVector::fromUInt(text.size() + 1, false));
144     data.append(text);
145     do {
146       data.append('\0');
147     } while(data.size() &amp; 1);
148   }
149   if(data.size() == 4)
150     return ByteVector();
151 <a name="0"></a>  return data;
152 }
153 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>void RIFF::Info::Tag::setStringHandler(const StringHandler *handler)
154 {
155   if(handler)
156     stringHandler = handler;
157   else
158     stringHandler = &amp;defaultStringHandler;
159 }
160 void RIFF::Info::Tag::parse(const ByteVector &amp;data)</b></font>
161 {
162   unsigned int p = 4;
163   while(p &lt; data.size()) {
164     const unsigned int size = data.toUInt(p + 4, false);
165     if(size &gt; data.size() - p - 8)
166       break;
167     const ByteVector id = data.mid(p, 4);
168     if(isValidChunkName(id)) {
169       const String text = stringHandler-&gt;parse(data.mid(p + 8, size));
170       d-&gt;fieldListMap[id] = text;
171     }
172     p += ((size + 1) &amp; ~1) + 8;
173   }
174 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>id3v2tag.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;algorithm&gt;
2 #include &lt;tfile.h&gt;
3 #include &lt;tbytevector.h&gt;
4 #include &lt;tpropertymap.h&gt;
5 #include &lt;tdebug.h&gt;
6 #include "id3v2tag.h"
7 #include "id3v2header.h"
8 #include "id3v2extendedheader.h"
9 #include "id3v2footer.h"
10 #include "id3v2synchdata.h"
11 #include "id3v1genres.h"
12 #include "frames/textidentificationframe.h"
13 #include "frames/commentsframe.h"
14 #include "frames/urllinkframe.h"
15 #include "frames/uniquefileidentifierframe.h"
16 #include "frames/unsynchronizedlyricsframe.h"
17 #include "frames/unknownframe.h"
18 using namespace TagLib;
19 using namespace ID3v2;
20 namespace
21 {
22   const ID3v2::Latin1StringHandler defaultStringHandler;
23   const ID3v2::Latin1StringHandler *stringHandler = &amp;defaultStringHandler;
24   const long MinPaddingSize = 1024;
25   const long MaxPaddingSize = 1024 * 1024;
26   bool contains(const char **a, const ByteVector &amp;v)
27   {
28     for(int i = 0; a[i]; i++)
29     {
30       if(v == a[i])
31         return true;
32     }
33     return false;
34   }
35 }  
36 class ID3v2::Tag::TagPrivate
37 {
38 public:
39   TagPrivate() :
40     factory(0),
41     file(0),
42     tagOffset(0),
43     extendedHeader(0),
44     footer(0)
45   {
46     frameList.setAutoDelete(true);
47   }
48   ~TagPrivate()
49   {
50     delete extendedHeader;
51     delete footer;
52   }
53   const FrameFactory *factory;
54   File *file;
55   long tagOffset;
56   Header header;
57   ExtendedHeader *extendedHeader;
58   Footer *footer;
59   FrameListMap frameListMap;
60   FrameList frameList;
61 };
62 Latin1StringHandler::Latin1StringHandler()
63 {
64 }
65 Latin1StringHandler::~Latin1StringHandler()
66 {
67 }
68 String Latin1StringHandler::parse(const ByteVector &amp;data) const
69 {
70   return String(data, String::Latin1);
71 }
72 ID3v2::Tag::Tag() :
73   d(new TagPrivate())
74 {
75   d-&gt;factory = FrameFactory::instance();
76 }
77 ID3v2::Tag::Tag(File *file, long tagOffset, const FrameFactory *factory) :
78   d(new TagPrivate())
79 {
80   d-&gt;factory = factory;
81   d-&gt;file = file;
82   d-&gt;tagOffset = tagOffset;
83   read();
84 }
85 ID3v2::Tag::~Tag()
86 {
87   delete d;
88 }
89 String ID3v2::Tag::title() const
90 {
91   if(!d-&gt;frameListMap["TIT2"].isEmpty())
92     return d-&gt;frameListMap["TIT2"].front()-&gt;toString();
93   return String();
94 }
95 String ID3v2::Tag::artist() const
96 {
97   if(!d-&gt;frameListMap["TPE1"].isEmpty())
98     return d-&gt;frameListMap["TPE1"].front()-&gt;toString();
99   return String();
100 }
101 String ID3v2::Tag::album() const
102 {
103   if(!d-&gt;frameListMap["TALB"].isEmpty())
104     return d-&gt;frameListMap["TALB"].front()-&gt;toString();
105   return String();
106 }
107 String ID3v2::Tag::comment() const
108 {
109   const FrameList &amp;comments = d-&gt;frameListMap["COMM"];
110   if(comments.isEmpty())
111     return String();
112   for(FrameList::ConstIterator it = comments.begin(); it != comments.end(); ++it)
113   {
114     CommentsFrame *frame = dynamic_cast&lt;CommentsFrame *&gt;(*it);
115     if(frame &amp;&amp; frame-&gt;description().isEmpty())
116       return (*it)-&gt;toString();
117   }
118   return comments.front()-&gt;toString();
119 }
120 String ID3v2::Tag::genre() const
121 {
122   const FrameList &amp;tconFrames = d-&gt;frameListMap["TCON"];
123   TextIdentificationFrame *f;
124   if(tconFrames.isEmpty() ||
125      !(f = dynamic_cast&lt;TextIdentificationFrame *&gt;(tconFrames.front())))
126   {
127     return String();
128   }
129   StringList fields = f-&gt;fieldList();
130   StringList genres;
131   for(StringList::Iterator it = fields.begin(); it != fields.end(); ++it) {
132     if((*it).isEmpty())
133       continue;
134     bool ok;
135     int number = (*it).toInt(&amp;ok);
136     if(ok &amp;&amp; number &gt;= 0 &amp;&amp; number &lt;= 255) {
137       *it = ID3v1::genre(number);
138     }
139     if(std::find(genres.begin(), genres.end(), *it) == genres.end())
140       genres.append(*it);
141   }
142   return genres.toString();
143 }
144 unsigned int ID3v2::Tag::year() const
145 {
146   if(!d-&gt;frameListMap["TDRC"].isEmpty())
147     return d-&gt;frameListMap["TDRC"].front()-&gt;toString().substr(0, 4).toInt();
148   return 0;
149 }
150 unsigned int ID3v2::Tag::track() const
151 {
152   if(!d-&gt;frameListMap["TRCK"].isEmpty())
153     return d-&gt;frameListMap["TRCK"].front()-&gt;toString().toInt();
154   return 0;
155 }
156 void ID3v2::Tag::setTitle(const String &amp;s)
157 {
158   setTextFrame("TIT2", s);
159 }
160 void ID3v2::Tag::setArtist(const String &amp;s)
161 {
162   setTextFrame("TPE1", s);
163 }
164 void ID3v2::Tag::setAlbum(const String &amp;s)
165 {
166   setTextFrame("TALB", s);
167 }
168 void ID3v2::Tag::setComment(const String &amp;s)
169 {
170   if(s.isEmpty()) {
171     removeFrames("COMM");
172     return;
173   }
174   const FrameList &amp;comments = d-&gt;frameListMap["COMM"];
175   if(!comments.isEmpty()) {
176     for(FrameList::ConstIterator it = comments.begin(); it != comments.end(); ++it) {
177       CommentsFrame *frame = dynamic_cast&lt;CommentsFrame *&gt;(*it);
178       if(frame &amp;&amp; frame-&gt;description().isEmpty()) {
179         (*it)-&gt;setText(s);
180         return;
181       }
182     }
183     comments.front()-&gt;setText(s);
184     return;
185   }
186   CommentsFrame *f = new CommentsFrame(d-&gt;factory-&gt;defaultTextEncoding());
187   addFrame(f);
188   f-&gt;setText(s);
189 }
190 void ID3v2::Tag::setGenre(const String &amp;s)
191 {
192   if(s.isEmpty()) {
193     removeFrames("TCON");
194     return;
195   }
196 #ifdef NO_ITUNES_HACKS
197   int index = ID3v1::genreIndex(s);
198   if(index != 255)
199     setTextFrame("TCON", String::number(index));
200   else
201     setTextFrame("TCON", s);
202 #else
203   setTextFrame("TCON", s);
204 #endif
205 }
206 void ID3v2::Tag::setYear(unsigned int i)
207 {
208   if(i == 0) {
209     removeFrames("TDRC");
210     return;
211   }
212   setTextFrame("TDRC", String::number(i));
213 }
214 void ID3v2::Tag::setTrack(unsigned int i)
215 {
216   if(i == 0) {
217     removeFrames("TRCK");
218     return;
219   }
220   setTextFrame("TRCK", String::number(i));
221 }
222 bool ID3v2::Tag::isEmpty() const
223 {
224   return d-&gt;frameList.isEmpty();
225 }
226 Header *ID3v2::Tag::header() const
227 {
228   return &amp;(d-&gt;header);
229 }
230 ExtendedHeader *ID3v2::Tag::extendedHeader() const
231 {
232   return d-&gt;extendedHeader;
233 }
234 Footer *ID3v2::Tag::footer() const
235 {
236   return d-&gt;footer;
237 }
238 const FrameListMap &amp;ID3v2::Tag::frameListMap() const
239 {
240   return d-&gt;frameListMap;
241 }
242 const FrameList &amp;ID3v2::Tag::frameList() const
243 {
244   return d-&gt;frameList;
245 }
246 const FrameList &amp;ID3v2::Tag::frameList(const ByteVector &amp;frameID) const
247 {
248   return d-&gt;frameListMap[frameID];
249 }
250 void ID3v2::Tag::addFrame(Frame *frame)
251 {
252   d-&gt;frameList.append(frame);
253   d-&gt;frameListMap[frame-&gt;frameID()].append(frame);
254 }
255 void ID3v2::Tag::removeFrame(Frame *frame, bool del)
256 {
257   FrameList::Iterator it = d-&gt;frameList.find(frame);
258   d-&gt;frameList.erase(it);
259   it = d-&gt;frameListMap[frame-&gt;frameID()].find(frame);
260   d-&gt;frameListMap[frame-&gt;frameID()].erase(it);
261   if(del)
262     delete frame;
263 }
264 void ID3v2::Tag::removeFrames(const ByteVector &amp;id)
265 {
266   FrameList l = d-&gt;frameListMap[id];
267   for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it)
268     removeFrame(*it, true);
269 }
270 PropertyMap ID3v2::Tag::properties() const
271 {
272   PropertyMap properties;
273   for(FrameList::ConstIterator it = frameList().begin(); it != frameList().end(); ++it) {
274     PropertyMap props = (*it)-&gt;asProperties();
275     properties.merge(props);
276   }
277   return properties;
278 }
279 void ID3v2::Tag::removeUnsupportedProperties(const StringList &amp;properties)
280 {
281   for(StringList::ConstIterator it = properties.begin(); it != properties.end(); ++it){
282     if(it-&gt;startsWith("UNKNOWN/")) {
283       String frameID = it-&gt;substr(String("UNKNOWN/").size());
284       if(frameID.size() != 4)
285         continue;       ByteVector id = frameID.data(String::Latin1);
286       FrameList l = frameList(id);
287       for(FrameList::ConstIterator fit = l.begin(); fit != l.end(); fit++)
288         if (dynamic_cast&lt;const UnknownFrame *&gt;(*fit) != 0)
289           removeFrame(*fit);
290     }
291     else if(it-&gt;size() == 4){
292       ByteVector id = it-&gt;data(String::Latin1);
293       removeFrames(id);
294     }
295     else {
296       ByteVector id = it-&gt;substr(0,4).data(String::Latin1);
297       if(it-&gt;size() &lt;= 5)
298         continue;       String description = it-&gt;substr(5);
299       Frame *frame = 0;
300       if(id == "TXXX")
301         frame = UserTextIdentificationFrame::find(this, description);
302       else if(id == "WXXX")
303         frame = UserUrlLinkFrame::find(this, description);
304       else if(id == "COMM")
305         frame = CommentsFrame::findByDescription(this, description);
306       else if(id == "USLT")
307         frame = UnsynchronizedLyricsFrame::findByDescription(this, description);
308       else if(id == "UFID")
309         frame = UniqueFileIdentifierFrame::findByOwner(this, description);
310       if(frame)
311         removeFrame(frame);
312     }
313   }
314 }
315 PropertyMap ID3v2::Tag::setProperties(const PropertyMap &amp;origProps)
316 {
317   FrameList framesToDelete;
318   PropertyMap properties;
319   PropertyMap tiplProperties;
320   PropertyMap tmclProperties;
321   Frame::splitProperties(origProps, properties, tiplProperties, tmclProperties);
322   for(FrameListMap::ConstIterator it = frameListMap().begin(); it != frameListMap().end(); ++it){
323     for(FrameList::ConstIterator lit = it-&gt;second.begin(); lit != it-&gt;second.end(); ++lit){
324       PropertyMap frameProperties = (*lit)-&gt;asProperties();
325       if(it-&gt;first == "TIPL") {
326         if (tiplProperties != frameProperties)
327           framesToDelete.append(*lit);
328         else
329           tiplProperties.erase(frameProperties);
330       } else if(it-&gt;first == "TMCL") {
331         if (tmclProperties != frameProperties)
332           framesToDelete.append(*lit);
333         else
334           tmclProperties.erase(frameProperties);
335       } else if(!properties.contains(frameProperties))
336         framesToDelete.append(*lit);
337       else
338         properties.erase(frameProperties);
339     }
340   }
341   for(FrameList::ConstIterator it = framesToDelete.begin(); it != framesToDelete.end(); ++it)
342     removeFrame(*it);
343   if(!tiplProperties.isEmpty())
344       addFrame(TextIdentificationFrame::createTIPLFrame(tiplProperties));
345   if(!tmclProperties.isEmpty())
346       addFrame(TextIdentificationFrame::createTMCLFrame(tmclProperties));
347   for(PropertyMap::ConstIterator it = properties.begin(); it != properties.end(); ++it)
348     addFrame(Frame::createTextualFrame(it-&gt;first, it-&gt;second));
349   return PropertyMap(); }
350 ByteVector ID3v2::Tag::render() const
351 {
352   return render(ID3v2::v4);
353 }
354 void ID3v2::Tag::downgradeFrames(FrameList *frames, FrameList *newFrames) const
355 {
356 #ifdef NO_ITUNES_HACKS
357   static const char *unsupportedFrames[] = {
358     "ASPI", "EQU2", "RVA2", "SEEK", "SIGN", "TDRL", "TDTG",
359     "TMOO", "TPRO", "TSOA", "TSOT", "TSST", "TSOP", 0
360   };
361 #else
362   static const char *unsupportedFrames[] = {
363     "ASPI", "EQU2", "RVA2", "SEEK", "SIGN", "TDRL", "TDTG",
364     "TMOO", "TPRO", "TSST", 0
365   };
366 #endif
367   ID3v2::TextIdentificationFrame *frameTDOR = 0;
368   ID3v2::TextIdentificationFrame *frameTDRC = 0;
369   ID3v2::TextIdentificationFrame *frameTIPL = 0;
370   ID3v2::TextIdentificationFrame *frameTMCL = 0;
371   ID3v2::TextIdentificationFrame *frameTCON = 0;
372   for(FrameList::ConstIterator it = d-&gt;frameList.begin(); it != d-&gt;frameList.end(); it++) {
373     ID3v2::Frame *frame = *it;
374     ByteVector frameID = frame-&gt;header()-&gt;frameID();
375     if(contains(unsupportedFrames, frameID))
376     {
377       debug("A frame that is not supported in ID3v2.3 \'" + String(frameID) +
378             "\' has been discarded");
379       continue;
380     }
381     if(frameID == "TDOR")
382       frameTDOR = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
383     else if(frameID == "TDRC")
384       frameTDRC = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
385     else if(frameID == "TIPL")
386       frameTIPL = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
387     else if(frameID == "TMCL")
388       frameTMCL = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
389     else if(frame &amp;&amp; frameID == "TCON")
390       frameTCON = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
391     else
392       frames-&gt;append(frame);
393   }
394   if(frameTDOR) {
395     String content = frameTDOR-&gt;toString();
396     if(content.size() &gt;= 4) {
397       ID3v2::TextIdentificationFrame *frameTORY =
398           new ID3v2::TextIdentificationFrame("TORY", String::Latin1);
399       frameTORY-&gt;setText(content.substr(0, 4));
400       frames-&gt;append(frameTORY);
401       newFrames-&gt;append(frameTORY);
402     }
403   }
404   if(frameTDRC) {
405     String content = frameTDRC-&gt;toString();
406     if(content.size() &gt;= 4) {
407       ID3v2::TextIdentificationFrame *frameTYER =
408           new ID3v2::TextIdentificationFrame("TYER", String::Latin1);
409       frameTYER-&gt;setText(content.substr(0, 4));
410       frames-&gt;append(frameTYER);
411       newFrames-&gt;append(frameTYER);
412       if(content.size() &gt;= 10 &amp;&amp; content[4] == '-' &amp;&amp; content[7] == '-') {
413         ID3v2::TextIdentificationFrame *frameTDAT =
414             new ID3v2::TextIdentificationFrame("TDAT", String::Latin1);
415         frameTDAT-&gt;setText(content.substr(8, 2) + content.substr(5, 2));
416         frames-&gt;append(frameTDAT);
417         newFrames-&gt;append(frameTDAT);
418         if(content.size() &gt;= 16 &amp;&amp; content[10] == 'T' &amp;&amp; content[13] == ':') {
419           ID3v2::TextIdentificationFrame *frameTIME =
420               new ID3v2::TextIdentificationFrame("TIME", String::Latin1);
421           frameTIME-&gt;setText(content.substr(11, 2) + content.substr(14, 2));
422           frames-&gt;append(frameTIME);
423           newFrames-&gt;append(frameTIME);
424         }
425       }
426     }
427   }
428   if(frameTIPL || frameTMCL) {
429     ID3v2::TextIdentificationFrame *frameIPLS =
430       new ID3v2::TextIdentificationFrame("IPLS", String::Latin1);
431     StringList people;
432     if(frameTMCL) {
433       StringList v24People = frameTMCL-&gt;fieldList();
434       for(unsigned int i = 0; i + 1 &lt; v24People.size(); i += 2) {
435         people.append(v24People[i]);
436         people.append(v24People[i+1]);
437       }
438     }
439     if(frameTIPL) {
440       StringList v24People = frameTIPL-&gt;fieldList();
441       for(unsigned int i = 0; i + 1 &lt; v24People.size(); i += 2) {
442         people.append(v24People[i]);
443         people.append(v24People[i+1]);
444       }
445     }
446     frameIPLS-&gt;setText(people);
447     frames-&gt;append(frameIPLS);
448     newFrames-&gt;append(frameIPLS);
449   }
450   if(frameTCON) {
451     StringList genres = frameTCON-&gt;fieldList();
452     String combined;
453     String genreText;
454     const bool hasMultipleGenres = genres.size() &gt; 1;
455     for(StringList::ConstIterator it = genres.begin(); it != genres.end(); ++it) {
456       bool ok = false;
457       int number = it-&gt;toInt(&amp;ok);
458       if((ok &amp;&amp; number &gt;= 0 &amp;&amp; number &lt;= 255) || *it == "RX" || *it == "CR")
459         combined += '(' + *it + ')';
460       else if(hasMultipleGenres &amp;&amp; (number = ID3v1::genreIndex(*it)) != 255)
461         combined += '(' + String::number(number) + ')';
462       else if(genreText.isEmpty())
463         genreText = *it;
464     }
465     if(!genreText.isEmpty())
466       combined += genreText;
467     frameTCON = new ID3v2::TextIdentificationFrame("TCON", String::Latin1);
468     frameTCON-&gt;setText(combined);
469     frames-&gt;append(frameTCON);
470     newFrames-&gt;append(frameTCON);
471   }
472 }
473 ByteVector ID3v2::Tag::render(int version) const
474 {
475   return render(version == 3 ? v3 : v4);
476 }
477 ByteVector ID3v2::Tag::render(Version version) const
478 {
479   FrameList newFrames;
480   newFrames.setAutoDelete(true);
481   FrameList frameList;
482   if(version == v4) {
483     frameList = d-&gt;frameList;
484   }
485   else {
486     downgradeFrames(&amp;frameList, &amp;newFrames);
487   }
488   ByteVector tagData(Header::size(), '\0');
489   for(FrameList::ConstIterator it = frameList.begin(); it != frameList.end(); it++) {
490     (*it)-&gt;header()-&gt;setVersion(version == v3 ? 3 : 4);
491     if((*it)-&gt;header()-&gt;frameID().size() != 4) {
492       debug("An ID3v2 frame of unsupported or unknown type \'"
493           + String((*it)-&gt;header()-&gt;frameID()) + "\' has been discarded");
494       continue;
495     }
496     if(!(*it)-&gt;header()-&gt;tagAlterPreservation()) {
497       const ByteVector frameData = (*it)-&gt;render();
498       if(frameData.size() == Frame::headerSize((*it)-&gt;header()-&gt;version())) {
499         debug("An empty ID3v2 frame \'"
500           + String((*it)-&gt;header()-&gt;frameID()) + "\' has been discarded");
501         continue;
502       }
503       tagData.append(frameData);
504     }
505   }
506   long originalSize = d-&gt;header.tagSize();
507   long paddingSize = originalSize - (tagData.size() - Header::size());
508   if(paddingSize &lt;= 0) {
509     paddingSize = MinPaddingSize;
510   }
511   else {
512     long threshold = d-&gt;file ? d-&gt;file-&gt;length() / 100 : 0;
513     threshold = std::max(threshold, MinPaddingSize);
514     threshold = std::min(threshold, MaxPaddingSize);
515     if(paddingSize &gt; threshold)
516       paddingSize = MinPaddingSize;
517   }
518   tagData.resize(static_cast&lt;unsigned int&gt;(tagData.size() + paddingSize), '\0');
519   d-&gt;header.setMajorVersion(version);
520   d-&gt;header.setTagSize(tagData.size() - Header::size());
521   const ByteVector headerData = d-&gt;header.render();
522   std::copy(headerData.begin(), headerData.end(), tagData.begin());
523   return tagData;
524 }
525 Latin1StringHandler const *ID3v2::Tag::latin1StringHandler()
526 {
527 <a name="0"></a>  return stringHandler;
528 }
529 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>void ID3v2::Tag::setLatin1StringHandler(const Latin1StringHandler *handler)
530 {
531   if(handler)
532     stringHandler = handler;
533   else
534     stringHandler = &amp;defaultStringHandler;
535 }
536 void ID3v2::Tag::read()</b></font>
537 {
538   if(!d-&gt;file)
539     return;
540   if(!d-&gt;file-&gt;isOpen())
541     return;
542   d-&gt;file-&gt;seek(d-&gt;tagOffset);
543   d-&gt;header.setData(d-&gt;file-&gt;readBlock(Header::size()));
544   if(d-&gt;header.tagSize() != 0)
545     parse(d-&gt;file-&gt;readBlock(d-&gt;header.tagSize()));
546   unsigned int extraSize = 0;
547   while(true) {
548     d-&gt;file-&gt;seek(d-&gt;tagOffset + d-&gt;header.completeTagSize() + extraSize);
549     const ByteVector data = d-&gt;file-&gt;readBlock(Header::size());
550     if(data.size() &lt; Header::size() || !data.startsWith(Header::fileIdentifier()))
551       break;
552     extraSize += Header(data).completeTagSize();
553   }
554   if(extraSize != 0) {
555     debug("ID3v2::Tag::read() - Duplicate ID3v2 tags found.");
556     d-&gt;header.setTagSize(d-&gt;header.tagSize() + extraSize);
557   }
558 }
559 void ID3v2::Tag::parse(const ByteVector &amp;origData)
560 {
561   ByteVector data = origData;
562   if(d-&gt;header.unsynchronisation() &amp;&amp; d-&gt;header.majorVersion() &lt;= 3)
563     data = SynchData::decode(data);
564   unsigned int frameDataPosition = 0;
565   unsigned int frameDataLength = data.size();
566   if(d-&gt;header.extendedHeader()) {
567     if(!d-&gt;extendedHeader)
568       d-&gt;extendedHeader = new ExtendedHeader();
569     d-&gt;extendedHeader-&gt;setData(data);
570     if(d-&gt;extendedHeader-&gt;size() &lt;= data.size()) {
571       frameDataPosition += d-&gt;extendedHeader-&gt;size();
572       frameDataLength -= d-&gt;extendedHeader-&gt;size();
573     }
574   }
575   if(d-&gt;header.footerPresent() &amp;&amp; Footer::size() &lt;= frameDataLength)
576     frameDataLength -= Footer::size();
577   while(frameDataPosition &lt; frameDataLength - Frame::headerSize(d-&gt;header.majorVersion())) {
578     if(data.at(frameDataPosition) == 0) {
579       if(d-&gt;header.footerPresent()) {
580         debug("Padding *and* a footer found.  This is not allowed by the spec.");
581       }
582       break;
583     }
584     Frame *frame = d-&gt;factory-&gt;createFrame(data.mid(frameDataPosition),
585                                            &amp;d-&gt;header);
586     if(!frame)
587       return;
588     if(frame-&gt;size() &lt;= 0) {
589       delete frame;
590       return;
591     }
592     frameDataPosition += frame-&gt;size() + Frame::headerSize(d-&gt;header.majorVersion());
593     addFrame(frame);
594   }
595   d-&gt;factory-&gt;rebuildAggregateFrames(this);
596 }
597 void ID3v2::Tag::setTextFrame(const ByteVector &amp;id, const String &amp;value)
598 {
599   if(value.isEmpty()) {
600     removeFrames(id);
601     return;
602   }
603   if(!d-&gt;frameListMap[id].isEmpty())
604     d-&gt;frameListMap[id].front()-&gt;setText(value);
605   else {
606     const String::Type encoding = d-&gt;factory-&gt;defaultTextEncoding();
607     TextIdentificationFrame *f = new TextIdentificationFrame(id, encoding);
608     addFrame(f);
609     f-&gt;setText(value);
610   }
611 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
