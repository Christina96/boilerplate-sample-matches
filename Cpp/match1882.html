<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for infotag.cpp & id3v2tag.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for infotag.cpp & id3v2tag.cpp
      </h3>
      <h1 align="center">
        2.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>infotag.cpp (4.33213%)<TH>id3v2tag.cpp (1.4760147%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1882-0.html#0',2,'match1882-1.html#0',3)" NAME="0">(224-236)<TD><A HREF="javascript:ZweiFrames('match1882-0.html#0',2,'match1882-1.html#0',3)" NAME="0">(711-723)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infotag.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/***************************************************************************
    copyright            : (C) 2012 by Tsuda Kageyu
    email                : tsuda.kageyu@gmail.com
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;tdebug.h&gt;
#include &lt;tfile.h&gt;

#include &quot;infotag.h&quot;
#include &quot;riffutils.h&quot;

using namespace TagLib;
using namespace RIFF::Info;

namespace
{
  const RIFF::Info::StringHandler defaultStringHandler;
  const RIFF::Info::StringHandler *stringHandler = &amp;defaultStringHandler;
}

class RIFF::Info::Tag::TagPrivate
{
public:
  FieldListMap fieldListMap;
};

////////////////////////////////////////////////////////////////////////////////
// StringHandler implementation
////////////////////////////////////////////////////////////////////////////////

StringHandler::StringHandler()
{
}

StringHandler::~StringHandler()
{
}

String RIFF::Info::StringHandler::parse(const ByteVector &amp;data) const
{
  return String(data, String::UTF8);
}

ByteVector RIFF::Info::StringHandler::render(const String &amp;s) const
{
  return s.data(String::UTF8);
}

////////////////////////////////////////////////////////////////////////////////
// public members
////////////////////////////////////////////////////////////////////////////////

RIFF::Info::Tag::Tag(const ByteVector &amp;data) :
  d(new TagPrivate())
{
  parse(data);
}

RIFF::Info::Tag::Tag() :
  d(new TagPrivate())
{
}

RIFF::Info::Tag::~Tag()
{
  delete d;
}

String RIFF::Info::Tag::title() const
{
  return fieldText(&quot;INAM&quot;);
}

String RIFF::Info::Tag::artist() const
{
  return fieldText(&quot;IART&quot;);
}

String RIFF::Info::Tag::album() const
{
  return fieldText(&quot;IPRD&quot;);
}

String RIFF::Info::Tag::comment() const
{
  return fieldText(&quot;ICMT&quot;);
}

String RIFF::Info::Tag::genre() const
{
  return fieldText(&quot;IGNR&quot;);
}

unsigned int RIFF::Info::Tag::year() const
{
  return fieldText(&quot;ICRD&quot;).substr(0, 4).toInt();
}

unsigned int RIFF::Info::Tag::track() const
{
  return fieldText(&quot;IPRT&quot;).toInt();
}

void RIFF::Info::Tag::setTitle(const String &amp;s)
{
  setFieldText(&quot;INAM&quot;, s);
}

void RIFF::Info::Tag::setArtist(const String &amp;s)
{
  setFieldText(&quot;IART&quot;, s);
}

void RIFF::Info::Tag::setAlbum(const String &amp;s)
{
  setFieldText(&quot;IPRD&quot;, s);
}

void RIFF::Info::Tag::setComment(const String &amp;s)
{
  setFieldText(&quot;ICMT&quot;, s);
}

void RIFF::Info::Tag::setGenre(const String &amp;s)
{
  setFieldText(&quot;IGNR&quot;, s);
}

void RIFF::Info::Tag::setYear(unsigned int i)
{
  if(i != 0)
    setFieldText(&quot;ICRD&quot;, String::number(i));
  else
    d-&gt;fieldListMap.erase(&quot;ICRD&quot;);
}

void RIFF::Info::Tag::setTrack(unsigned int i)
{
  if(i != 0)
    setFieldText(&quot;IPRT&quot;, String::number(i));
  else
    d-&gt;fieldListMap.erase(&quot;IPRT&quot;);
}

bool RIFF::Info::Tag::isEmpty() const
{
  return d-&gt;fieldListMap.isEmpty();
}

FieldListMap RIFF::Info::Tag::fieldListMap() const
{
  return d-&gt;fieldListMap;
}

String RIFF::Info::Tag::fieldText(const ByteVector &amp;id) const
{
  if(d-&gt;fieldListMap.contains(id))
    return String(d-&gt;fieldListMap[id]);
  return String();
}

void RIFF::Info::Tag::setFieldText(const ByteVector &amp;id, const String &amp;s)
{
  // id must be four-byte long pure ascii string.
  if(!isValidChunkName(id))
    return;

  if(!s.isEmpty())
    d-&gt;fieldListMap[id] = s;
  else
    removeField(id);
}

void RIFF::Info::Tag::removeField(const ByteVector &amp;id)
{
  if(d-&gt;fieldListMap.contains(id))
    d-&gt;fieldListMap.erase(id);
}

ByteVector RIFF::Info::Tag::render() const
{
  ByteVector data(&quot;INFO&quot;);

  FieldListMap::ConstIterator it = d-&gt;fieldListMap.begin();
  for(; it != d-&gt;fieldListMap.end(); ++it) {
    ByteVector text = stringHandler-&gt;render(it-&gt;second);
    if(text.isEmpty())
      continue;

    data.append(it-&gt;first);
    data.append(ByteVector::fromUInt(text.size() + 1, false));
    data.append(text);

    do {
      data.append('\0');
    } while(data.size() &amp; 1);
  }

  if(data.size() == 4)
    return ByteVector();
<A NAME="0"></A>  return data;
}

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1882-1.html#0',3,'match1882-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>void RIFF::Info::Tag::setStringHandler(const StringHandler *handler)
{
  if(handler)
    stringHandler = handler;
  else
    stringHandler = &amp;defaultStringHandler;
}

////////////////////////////////////////////////////////////////////////////////
// protected members
////////////////////////////////////////////////////////////////////////////////

void RIFF::Info::Tag::parse(const ByteVector &amp;data)</B></FONT>
{
  unsigned int p = 4;
  while(p &lt; data.size()) {
    const unsigned int size = data.toUInt(p + 4, false);
    if(size &gt; data.size() - p - 8)
      break;

    const ByteVector id = data.mid(p, 4);
    if(isValidChunkName(id)) {
      const String text = stringHandler-&gt;parse(data.mid(p + 8, size));
      d-&gt;fieldListMap[id] = text;
    }

    p += ((size + 1) &amp; ~1) + 8;
  }
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>id3v2tag.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/***************************************************************************
    copyright            : (C) 2002 - 2008 by Scott Wheeler
    email                : wheeler@kde.org
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;algorithm&gt;

#include &lt;tfile.h&gt;
#include &lt;tbytevector.h&gt;
#include &lt;tpropertymap.h&gt;
#include &lt;tdebug.h&gt;

#include &quot;id3v2tag.h&quot;
#include &quot;id3v2header.h&quot;
#include &quot;id3v2extendedheader.h&quot;
#include &quot;id3v2footer.h&quot;
#include &quot;id3v2synchdata.h&quot;
#include &quot;id3v1genres.h&quot;

#include &quot;frames/textidentificationframe.h&quot;
#include &quot;frames/commentsframe.h&quot;
#include &quot;frames/urllinkframe.h&quot;
#include &quot;frames/uniquefileidentifierframe.h&quot;
#include &quot;frames/unsynchronizedlyricsframe.h&quot;
#include &quot;frames/unknownframe.h&quot;

using namespace TagLib;
using namespace ID3v2;

namespace
{
  const ID3v2::Latin1StringHandler defaultStringHandler;
  const ID3v2::Latin1StringHandler *stringHandler = &amp;defaultStringHandler;

  const long MinPaddingSize = 1024;
  const long MaxPaddingSize = 1024 * 1024;

  bool contains(const char **a, const ByteVector &amp;v)
  {
    for(int i = 0; a[i]; i++)
    {
      if(v == a[i])
        return true;
    }
    return false;
  }
}  // namespace

class ID3v2::Tag::TagPrivate
{
public:
  TagPrivate() :
    factory(0),
    file(0),
    tagOffset(0),
    extendedHeader(0),
    footer(0)
  {
    frameList.setAutoDelete(true);
  }

  ~TagPrivate()
  {
    delete extendedHeader;
    delete footer;
  }

  const FrameFactory *factory;

  File *file;
  long tagOffset;

  Header header;
  ExtendedHeader *extendedHeader;
  Footer *footer;

  FrameListMap frameListMap;
  FrameList frameList;
};

////////////////////////////////////////////////////////////////////////////////
// StringHandler implementation
////////////////////////////////////////////////////////////////////////////////

Latin1StringHandler::Latin1StringHandler()
{
}

Latin1StringHandler::~Latin1StringHandler()
{
}

String Latin1StringHandler::parse(const ByteVector &amp;data) const
{
  return String(data, String::Latin1);
}

////////////////////////////////////////////////////////////////////////////////
// public members
////////////////////////////////////////////////////////////////////////////////

ID3v2::Tag::Tag() :
  d(new TagPrivate())
{
  d-&gt;factory = FrameFactory::instance();
}

ID3v2::Tag::Tag(File *file, long tagOffset, const FrameFactory *factory) :
  d(new TagPrivate())
{
  d-&gt;factory = factory;
  d-&gt;file = file;
  d-&gt;tagOffset = tagOffset;

  read();
}

ID3v2::Tag::~Tag()
{
  delete d;
}

String ID3v2::Tag::title() const
{
  if(!d-&gt;frameListMap[&quot;TIT2&quot;].isEmpty())
    return d-&gt;frameListMap[&quot;TIT2&quot;].front()-&gt;toString();
  return String();
}

String ID3v2::Tag::artist() const
{
  if(!d-&gt;frameListMap[&quot;TPE1&quot;].isEmpty())
    return d-&gt;frameListMap[&quot;TPE1&quot;].front()-&gt;toString();
  return String();
}

String ID3v2::Tag::album() const
{
  if(!d-&gt;frameListMap[&quot;TALB&quot;].isEmpty())
    return d-&gt;frameListMap[&quot;TALB&quot;].front()-&gt;toString();
  return String();
}

String ID3v2::Tag::comment() const
{
  const FrameList &amp;comments = d-&gt;frameListMap[&quot;COMM&quot;];

  if(comments.isEmpty())
    return String();

  for(FrameList::ConstIterator it = comments.begin(); it != comments.end(); ++it)
  {
    CommentsFrame *frame = dynamic_cast&lt;CommentsFrame *&gt;(*it);

    if(frame &amp;&amp; frame-&gt;description().isEmpty())
      return (*it)-&gt;toString();
  }

  return comments.front()-&gt;toString();
}

String ID3v2::Tag::genre() const
{
  // TODO: In the next major version (TagLib 2.0) a list of multiple genres
  // should be separated by &quot; / &quot; instead of &quot; &quot;.  For the moment to keep
  // the behavior the same as released versions it is being left with &quot; &quot;.

  const FrameList &amp;tconFrames = d-&gt;frameListMap[&quot;TCON&quot;];
  TextIdentificationFrame *f;
  if(tconFrames.isEmpty() ||
     !(f = dynamic_cast&lt;TextIdentificationFrame *&gt;(tconFrames.front())))
  {
    return String();
  }

  // ID3v2.4 lists genres as the fields in its frames field list.  If the field
  // is simply a number it can be assumed that it is an ID3v1 genre number.
  // Here was assume that if an ID3v1 string is present that it should be
  // appended to the genre string.  Multiple fields will be appended as the
  // string is built.

  StringList fields = f-&gt;fieldList();

  StringList genres;

  for(StringList::Iterator it = fields.begin(); it != fields.end(); ++it) {

    if((*it).isEmpty())
      continue;

    bool ok;
    int number = (*it).toInt(&amp;ok);
    if(ok &amp;&amp; number &gt;= 0 &amp;&amp; number &lt;= 255) {
      *it = ID3v1::genre(number);
    }

    if(std::find(genres.begin(), genres.end(), *it) == genres.end())
      genres.append(*it);
  }

  return genres.toString();
}

unsigned int ID3v2::Tag::year() const
{
  if(!d-&gt;frameListMap[&quot;TDRC&quot;].isEmpty())
    return d-&gt;frameListMap[&quot;TDRC&quot;].front()-&gt;toString().substr(0, 4).toInt();
  return 0;
}

unsigned int ID3v2::Tag::track() const
{
  if(!d-&gt;frameListMap[&quot;TRCK&quot;].isEmpty())
    return d-&gt;frameListMap[&quot;TRCK&quot;].front()-&gt;toString().toInt();
  return 0;
}

void ID3v2::Tag::setTitle(const String &amp;s)
{
  setTextFrame(&quot;TIT2&quot;, s);
}

void ID3v2::Tag::setArtist(const String &amp;s)
{
  setTextFrame(&quot;TPE1&quot;, s);
}

void ID3v2::Tag::setAlbum(const String &amp;s)
{
  setTextFrame(&quot;TALB&quot;, s);
}

void ID3v2::Tag::setComment(const String &amp;s)
{
  if(s.isEmpty()) {
    removeFrames(&quot;COMM&quot;);
    return;
  }

  const FrameList &amp;comments = d-&gt;frameListMap[&quot;COMM&quot;];

  if(!comments.isEmpty()) {
    for(FrameList::ConstIterator it = comments.begin(); it != comments.end(); ++it) {
      CommentsFrame *frame = dynamic_cast&lt;CommentsFrame *&gt;(*it);
      if(frame &amp;&amp; frame-&gt;description().isEmpty()) {
        (*it)-&gt;setText(s);
        return;
      }
    }

    comments.front()-&gt;setText(s);
    return;
  }

  CommentsFrame *f = new CommentsFrame(d-&gt;factory-&gt;defaultTextEncoding());
  addFrame(f);
  f-&gt;setText(s);
}

void ID3v2::Tag::setGenre(const String &amp;s)
{
  if(s.isEmpty()) {
    removeFrames(&quot;TCON&quot;);
    return;
  }

  // iTunes can't handle correctly encoded ID3v2.4 numerical genres.  Just use
  // strings until iTunes sucks less.

#ifdef NO_ITUNES_HACKS

  int index = ID3v1::genreIndex(s);

  if(index != 255)
    setTextFrame(&quot;TCON&quot;, String::number(index));
  else
    setTextFrame(&quot;TCON&quot;, s);

#else

  setTextFrame(&quot;TCON&quot;, s);

#endif
}

void ID3v2::Tag::setYear(unsigned int i)
{
  if(i == 0) {
    removeFrames(&quot;TDRC&quot;);
    return;
  }
  setTextFrame(&quot;TDRC&quot;, String::number(i));
}

void ID3v2::Tag::setTrack(unsigned int i)
{
  if(i == 0) {
    removeFrames(&quot;TRCK&quot;);
    return;
  }
  setTextFrame(&quot;TRCK&quot;, String::number(i));
}

bool ID3v2::Tag::isEmpty() const
{
  return d-&gt;frameList.isEmpty();
}

Header *ID3v2::Tag::header() const
{
  return &amp;(d-&gt;header);
}

ExtendedHeader *ID3v2::Tag::extendedHeader() const
{
  return d-&gt;extendedHeader;
}

Footer *ID3v2::Tag::footer() const
{
  return d-&gt;footer;
}

const FrameListMap &amp;ID3v2::Tag::frameListMap() const
{
  return d-&gt;frameListMap;
}

const FrameList &amp;ID3v2::Tag::frameList() const
{
  return d-&gt;frameList;
}

const FrameList &amp;ID3v2::Tag::frameList(const ByteVector &amp;frameID) const
{
  return d-&gt;frameListMap[frameID];
}

void ID3v2::Tag::addFrame(Frame *frame)
{
  d-&gt;frameList.append(frame);
  d-&gt;frameListMap[frame-&gt;frameID()].append(frame);
}

void ID3v2::Tag::removeFrame(Frame *frame, bool del)
{
  // remove the frame from the frame list
  FrameList::Iterator it = d-&gt;frameList.find(frame);
  d-&gt;frameList.erase(it);

  // ...and from the frame list map
  it = d-&gt;frameListMap[frame-&gt;frameID()].find(frame);
  d-&gt;frameListMap[frame-&gt;frameID()].erase(it);

  // ...and delete as desired
  if(del)
    delete frame;
}

void ID3v2::Tag::removeFrames(const ByteVector &amp;id)
{
  FrameList l = d-&gt;frameListMap[id];
  for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it)
    removeFrame(*it, true);
}

PropertyMap ID3v2::Tag::properties() const
{
  PropertyMap properties;
  for(FrameList::ConstIterator it = frameList().begin(); it != frameList().end(); ++it) {
    PropertyMap props = (*it)-&gt;asProperties();
    properties.merge(props);
  }
  return properties;
}

void ID3v2::Tag::removeUnsupportedProperties(const StringList &amp;properties)
{
  for(StringList::ConstIterator it = properties.begin(); it != properties.end(); ++it){
    if(it-&gt;startsWith(&quot;UNKNOWN/&quot;)) {
      String frameID = it-&gt;substr(String(&quot;UNKNOWN/&quot;).size());
      if(frameID.size() != 4)
        continue; // invalid specification
      ByteVector id = frameID.data(String::Latin1);
      // delete all unknown frames of given type
      FrameList l = frameList(id);
      for(FrameList::ConstIterator fit = l.begin(); fit != l.end(); fit++)
        if (dynamic_cast&lt;const UnknownFrame *&gt;(*fit) != 0)
          removeFrame(*fit);
    }
    else if(it-&gt;size() == 4){
      ByteVector id = it-&gt;data(String::Latin1);
      removeFrames(id);
    }
    else {
      ByteVector id = it-&gt;substr(0,4).data(String::Latin1);
      if(it-&gt;size() &lt;= 5)
        continue; // invalid specification
      String description = it-&gt;substr(5);
      Frame *frame = 0;
      if(id == &quot;TXXX&quot;)
        frame = UserTextIdentificationFrame::find(this, description);
      else if(id == &quot;WXXX&quot;)
        frame = UserUrlLinkFrame::find(this, description);
      else if(id == &quot;COMM&quot;)
        frame = CommentsFrame::findByDescription(this, description);
      else if(id == &quot;USLT&quot;)
        frame = UnsynchronizedLyricsFrame::findByDescription(this, description);
      else if(id == &quot;UFID&quot;)
        frame = UniqueFileIdentifierFrame::findByOwner(this, description);
      if(frame)
        removeFrame(frame);
    }
  }
}

PropertyMap ID3v2::Tag::setProperties(const PropertyMap &amp;origProps)
{
  FrameList framesToDelete;
  // we split up the PropertyMap into the &quot;normal&quot; keys and the &quot;complicated&quot; ones,
  // which are those according to TIPL or TMCL frames.
  PropertyMap properties;
  PropertyMap tiplProperties;
  PropertyMap tmclProperties;
  Frame::splitProperties(origProps, properties, tiplProperties, tmclProperties);
  for(FrameListMap::ConstIterator it = frameListMap().begin(); it != frameListMap().end(); ++it){
    for(FrameList::ConstIterator lit = it-&gt;second.begin(); lit != it-&gt;second.end(); ++lit){
      PropertyMap frameProperties = (*lit)-&gt;asProperties();
      if(it-&gt;first == &quot;TIPL&quot;) {
        if (tiplProperties != frameProperties)
          framesToDelete.append(*lit);
        else
          tiplProperties.erase(frameProperties);
      } else if(it-&gt;first == &quot;TMCL&quot;) {
        if (tmclProperties != frameProperties)
          framesToDelete.append(*lit);
        else
          tmclProperties.erase(frameProperties);
      } else if(!properties.contains(frameProperties))
        framesToDelete.append(*lit);
      else
        properties.erase(frameProperties);
    }
  }
  for(FrameList::ConstIterator it = framesToDelete.begin(); it != framesToDelete.end(); ++it)
    removeFrame(*it);

  // now create remaining frames:
  // start with the involved people list (TIPL)
  if(!tiplProperties.isEmpty())
      addFrame(TextIdentificationFrame::createTIPLFrame(tiplProperties));
  // proceed with the musician credit list (TMCL)
  if(!tmclProperties.isEmpty())
      addFrame(TextIdentificationFrame::createTMCLFrame(tmclProperties));
  // now create the &quot;one key per frame&quot; frames
  for(PropertyMap::ConstIterator it = properties.begin(); it != properties.end(); ++it)
    addFrame(Frame::createTextualFrame(it-&gt;first, it-&gt;second));
  return PropertyMap(); // ID3 implements the complete PropertyMap interface, so an empty map is returned
}

ByteVector ID3v2::Tag::render() const
{
  return render(ID3v2::v4);
}

void ID3v2::Tag::downgradeFrames(FrameList *frames, FrameList *newFrames) const
{
#ifdef NO_ITUNES_HACKS
  static const char *unsupportedFrames[] = {
    &quot;ASPI&quot;, &quot;EQU2&quot;, &quot;RVA2&quot;, &quot;SEEK&quot;, &quot;SIGN&quot;, &quot;TDRL&quot;, &quot;TDTG&quot;,
    &quot;TMOO&quot;, &quot;TPRO&quot;, &quot;TSOA&quot;, &quot;TSOT&quot;, &quot;TSST&quot;, &quot;TSOP&quot;, 0
  };
#else
  // iTunes writes and reads TSOA, TSOT, TSOP to ID3v2.3.
  static const char *unsupportedFrames[] = {
    &quot;ASPI&quot;, &quot;EQU2&quot;, &quot;RVA2&quot;, &quot;SEEK&quot;, &quot;SIGN&quot;, &quot;TDRL&quot;, &quot;TDTG&quot;,
    &quot;TMOO&quot;, &quot;TPRO&quot;, &quot;TSST&quot;, 0
  };
#endif
  ID3v2::TextIdentificationFrame *frameTDOR = 0;
  ID3v2::TextIdentificationFrame *frameTDRC = 0;
  ID3v2::TextIdentificationFrame *frameTIPL = 0;
  ID3v2::TextIdentificationFrame *frameTMCL = 0;
  ID3v2::TextIdentificationFrame *frameTCON = 0;

  for(FrameList::ConstIterator it = d-&gt;frameList.begin(); it != d-&gt;frameList.end(); it++) {
    ID3v2::Frame *frame = *it;
    ByteVector frameID = frame-&gt;header()-&gt;frameID();

    if(contains(unsupportedFrames, frameID))
    {
      debug(&quot;A frame that is not supported in ID3v2.3 \'&quot; + String(frameID) +
            &quot;\' has been discarded&quot;);
      continue;
    }

    if(frameID == &quot;TDOR&quot;)
      frameTDOR = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
    else if(frameID == &quot;TDRC&quot;)
      frameTDRC = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
    else if(frameID == &quot;TIPL&quot;)
      frameTIPL = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
    else if(frameID == &quot;TMCL&quot;)
      frameTMCL = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
    else if(frame &amp;&amp; frameID == &quot;TCON&quot;)
      frameTCON = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(frame);
    else
      frames-&gt;append(frame);
  }

  if(frameTDOR) {
    String content = frameTDOR-&gt;toString();

    if(content.size() &gt;= 4) {
      ID3v2::TextIdentificationFrame *frameTORY =
          new ID3v2::TextIdentificationFrame(&quot;TORY&quot;, String::Latin1);
      frameTORY-&gt;setText(content.substr(0, 4));
      frames-&gt;append(frameTORY);
      newFrames-&gt;append(frameTORY);
    }
  }

  if(frameTDRC) {
    String content = frameTDRC-&gt;toString();
    if(content.size() &gt;= 4) {
      ID3v2::TextIdentificationFrame *frameTYER =
          new ID3v2::TextIdentificationFrame(&quot;TYER&quot;, String::Latin1);
      frameTYER-&gt;setText(content.substr(0, 4));
      frames-&gt;append(frameTYER);
      newFrames-&gt;append(frameTYER);
      if(content.size() &gt;= 10 &amp;&amp; content[4] == '-' &amp;&amp; content[7] == '-') {
        ID3v2::TextIdentificationFrame *frameTDAT =
            new ID3v2::TextIdentificationFrame(&quot;TDAT&quot;, String::Latin1);
        frameTDAT-&gt;setText(content.substr(8, 2) + content.substr(5, 2));
        frames-&gt;append(frameTDAT);
        newFrames-&gt;append(frameTDAT);
        if(content.size() &gt;= 16 &amp;&amp; content[10] == 'T' &amp;&amp; content[13] == ':') {
          ID3v2::TextIdentificationFrame *frameTIME =
              new ID3v2::TextIdentificationFrame(&quot;TIME&quot;, String::Latin1);
          frameTIME-&gt;setText(content.substr(11, 2) + content.substr(14, 2));
          frames-&gt;append(frameTIME);
          newFrames-&gt;append(frameTIME);
        }
      }
    }
  }

  if(frameTIPL || frameTMCL) {
    ID3v2::TextIdentificationFrame *frameIPLS =
      new ID3v2::TextIdentificationFrame(&quot;IPLS&quot;, String::Latin1);

    StringList people;

    if(frameTMCL) {
      StringList v24People = frameTMCL-&gt;fieldList();
      for(unsigned int i = 0; i + 1 &lt; v24People.size(); i += 2) {
        people.append(v24People[i]);
        people.append(v24People[i+1]);
      }
    }
    if(frameTIPL) {
      StringList v24People = frameTIPL-&gt;fieldList();
      for(unsigned int i = 0; i + 1 &lt; v24People.size(); i += 2) {
        people.append(v24People[i]);
        people.append(v24People[i+1]);
      }
    }

    frameIPLS-&gt;setText(people);
    frames-&gt;append(frameIPLS);
    newFrames-&gt;append(frameIPLS);
  }

  if(frameTCON) {
    StringList genres = frameTCON-&gt;fieldList();
    String combined;
    String genreText;
    const bool hasMultipleGenres = genres.size() &gt; 1;

    // If there are multiple genres, add them as multiple references to ID3v1
    // genres if such a reference exists. The first genre for which no ID3v1
    // genre number exists can be finally added as a refinement.
    for(StringList::ConstIterator it = genres.begin(); it != genres.end(); ++it) {
      bool ok = false;
      int number = it-&gt;toInt(&amp;ok);
      if((ok &amp;&amp; number &gt;= 0 &amp;&amp; number &lt;= 255) || *it == &quot;RX&quot; || *it == &quot;CR&quot;)
        combined += '(' + *it + ')';
      else if(hasMultipleGenres &amp;&amp; (number = ID3v1::genreIndex(*it)) != 255)
        combined += '(' + String::number(number) + ')';
      else if(genreText.isEmpty())
        genreText = *it;
    }
    if(!genreText.isEmpty())
      combined += genreText;

    frameTCON = new ID3v2::TextIdentificationFrame(&quot;TCON&quot;, String::Latin1);
    frameTCON-&gt;setText(combined);
    frames-&gt;append(frameTCON);
    newFrames-&gt;append(frameTCON);
  }
}

ByteVector ID3v2::Tag::render(int version) const
{
  return render(version == 3 ? v3 : v4);
}

ByteVector ID3v2::Tag::render(Version version) const
{
  // We need to render the &quot;tag data&quot; first so that we have to correct size to
  // render in the tag's header.  The &quot;tag data&quot; -- everything that is included
  // in ID3v2::Header::tagSize() -- includes the extended header, frames and
  // padding, but does not include the tag's header or footer.

  // TODO: Render the extended header.

  // Downgrade the frames that ID3v2.3 doesn't support.

  FrameList newFrames;
  newFrames.setAutoDelete(true);

  FrameList frameList;
  if(version == v4) {
    frameList = d-&gt;frameList;
  }
  else {
    downgradeFrames(&amp;frameList, &amp;newFrames);
  }

  // Reserve a 10-byte blank space for an ID3v2 tag header.

  ByteVector tagData(Header::size(), '\0');

  // Loop through the frames rendering them and adding them to the tagData.

  for(FrameList::ConstIterator it = frameList.begin(); it != frameList.end(); it++) {
    (*it)-&gt;header()-&gt;setVersion(version == v3 ? 3 : 4);
    if((*it)-&gt;header()-&gt;frameID().size() != 4) {
      debug(&quot;An ID3v2 frame of unsupported or unknown type \'&quot;
          + String((*it)-&gt;header()-&gt;frameID()) + &quot;\' has been discarded&quot;);
      continue;
    }
    if(!(*it)-&gt;header()-&gt;tagAlterPreservation()) {
      const ByteVector frameData = (*it)-&gt;render();
      if(frameData.size() == Frame::headerSize((*it)-&gt;header()-&gt;version())) {
        debug(&quot;An empty ID3v2 frame \'&quot;
          + String((*it)-&gt;header()-&gt;frameID()) + &quot;\' has been discarded&quot;);
        continue;
      }
      tagData.append(frameData);
    }
  }

  // Compute the amount of padding, and append that to tagData.

  long originalSize = d-&gt;header.tagSize();
  long paddingSize = originalSize - (tagData.size() - Header::size());

  if(paddingSize &lt;= 0) {
    paddingSize = MinPaddingSize;
  }
  else {
    // Padding won't increase beyond 1% of the file size or 1MB.

    long threshold = d-&gt;file ? d-&gt;file-&gt;length() / 100 : 0;
    threshold = std::max(threshold, MinPaddingSize);
    threshold = std::min(threshold, MaxPaddingSize);

    if(paddingSize &gt; threshold)
      paddingSize = MinPaddingSize;
  }

  tagData.resize(static_cast&lt;unsigned int&gt;(tagData.size() + paddingSize), '\0');

  // Set the version and data size.
  d-&gt;header.setMajorVersion(version);
  d-&gt;header.setTagSize(tagData.size() - Header::size());

  // TODO: This should eventually include d-&gt;footer-&gt;render().
  const ByteVector headerData = d-&gt;header.render();
  std::copy(headerData.begin(), headerData.end(), tagData.begin());

  return tagData;
}

Latin1StringHandler const *ID3v2::Tag::latin1StringHandler()
{
<A NAME="0"></A>  return stringHandler;
}

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1882-0.html#0',2,'match1882-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>void ID3v2::Tag::setLatin1StringHandler(const Latin1StringHandler *handler)
{
  if(handler)
    stringHandler = handler;
  else
    stringHandler = &amp;defaultStringHandler;
}

////////////////////////////////////////////////////////////////////////////////
// protected members
////////////////////////////////////////////////////////////////////////////////

void ID3v2::Tag::read()</B></FONT>
{
  if(!d-&gt;file)
    return;

  if(!d-&gt;file-&gt;isOpen())
    return;

  d-&gt;file-&gt;seek(d-&gt;tagOffset);
  d-&gt;header.setData(d-&gt;file-&gt;readBlock(Header::size()));

  // If the tag size is 0, then this is an invalid tag (tags must contain at
  // least one frame)

  if(d-&gt;header.tagSize() != 0)
    parse(d-&gt;file-&gt;readBlock(d-&gt;header.tagSize()));

  // Look for duplicate ID3v2 tags and treat them as an extra blank of this one.
  // It leads to overwriting them with zero when saving the tag.

  // This is a workaround for some faulty files that have duplicate ID3v2 tags.
  // Unfortunately, TagLib itself may write such duplicate tags until v1.10.

  unsigned int extraSize = 0;

  while(true) {

    d-&gt;file-&gt;seek(d-&gt;tagOffset + d-&gt;header.completeTagSize() + extraSize);

    const ByteVector data = d-&gt;file-&gt;readBlock(Header::size());
    if(data.size() &lt; Header::size() || !data.startsWith(Header::fileIdentifier()))
      break;

    extraSize += Header(data).completeTagSize();
  }

  if(extraSize != 0) {
    debug(&quot;ID3v2::Tag::read() - Duplicate ID3v2 tags found.&quot;);
    d-&gt;header.setTagSize(d-&gt;header.tagSize() + extraSize);
  }
}

void ID3v2::Tag::parse(const ByteVector &amp;origData)
{
  ByteVector data = origData;

  if(d-&gt;header.unsynchronisation() &amp;&amp; d-&gt;header.majorVersion() &lt;= 3)
    data = SynchData::decode(data);

  unsigned int frameDataPosition = 0;
  unsigned int frameDataLength = data.size();

  // check for extended header

  if(d-&gt;header.extendedHeader()) {
    if(!d-&gt;extendedHeader)
      d-&gt;extendedHeader = new ExtendedHeader();
    d-&gt;extendedHeader-&gt;setData(data);
    if(d-&gt;extendedHeader-&gt;size() &lt;= data.size()) {
      frameDataPosition += d-&gt;extendedHeader-&gt;size();
      frameDataLength -= d-&gt;extendedHeader-&gt;size();
    }
  }

  // check for footer -- we don't actually need to parse it, as it *must*
  // contain the same data as the header, but we do need to account for its
  // size.

  if(d-&gt;header.footerPresent() &amp;&amp; Footer::size() &lt;= frameDataLength)
    frameDataLength -= Footer::size();

  // parse frames

  // Make sure that there is at least enough room in the remaining frame data for
  // a frame header.

  while(frameDataPosition &lt; frameDataLength - Frame::headerSize(d-&gt;header.majorVersion())) {

    // If the next data is position is 0, assume that we've hit the padding
    // portion of the frame data.

    if(data.at(frameDataPosition) == 0) {
      if(d-&gt;header.footerPresent()) {
        debug(&quot;Padding *and* a footer found.  This is not allowed by the spec.&quot;);
      }

      break;
    }

    Frame *frame = d-&gt;factory-&gt;createFrame(data.mid(frameDataPosition),
                                           &amp;d-&gt;header);

    if(!frame)
      return;

    // Checks to make sure that frame parsed correctly.

    if(frame-&gt;size() &lt;= 0) {
      delete frame;
      return;
    }

    frameDataPosition += frame-&gt;size() + Frame::headerSize(d-&gt;header.majorVersion());
    addFrame(frame);
  }

  d-&gt;factory-&gt;rebuildAggregateFrames(this);
}

void ID3v2::Tag::setTextFrame(const ByteVector &amp;id, const String &amp;value)
{
  if(value.isEmpty()) {
    removeFrames(id);
    return;
  }

  if(!d-&gt;frameListMap[id].isEmpty())
    d-&gt;frameListMap[id].front()-&gt;setText(value);
  else {
    const String::Type encoding = d-&gt;factory-&gt;defaultTextEncoding();
    TextIdentificationFrame *f = new TextIdentificationFrame(id, encoding);
    addFrame(f);
    f-&gt;setText(value);
  }
}
</PRE>
</div>
  </div>
</body>
</html>
