
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-normalis.cpp</h3>
            <pre><code>1  #include "normalis.h"
2  #include <allheaders.h>
3  #include "blobs.h"
4  #include "helpers.h"
5  #include "matrix.h"
6  #include "ocrblock.h"
7  #include "unicharset.h"
8  #include "werd.h"
9  #include <cfloat> 
10  #include <cstdlib>
11  namespace tesseract {
12  const int kSloppyTolerance = 4;
13  const float kFinalPixelTolerance = 0.125f;
14  DENORM::DENORM() {
15    Init();
16  }
17  DENORM::DENORM(const DENORM &src) {
18    rotation_ = nullptr;
19    *this = src;
20  }
21  DENORM &DENORM::operator=(const DENORM &src) {
22    Clear();
23    inverse_ = src.inverse_;
24    predecessor_ = src.predecessor_;
25    pix_ = src.pix_;
26    block_ = src.block_;
27    if (src.rotation_ == nullptr) {
28      rotation_ = nullptr;
29    } else {
30      rotation_ = new FCOORD(*src.rotation_);
31    }
32    x_origin_ = src.x_origin_;
33    y_origin_ = src.y_origin_;
34    x_scale_ = src.x_scale_;
35    y_scale_ = src.y_scale_;
36    final_xshift_ = src.final_xshift_;
37    final_yshift_ = src.final_yshift_;
38    return *this;
39  }
40  DENORM::~DENORM() {
41    Clear();
42  }
43  void DENORM::SetupNormalization(const BLOCK *block, const FCOORD *rotation,
44                                  const DENORM *predecessor, float x_origin, float y_origin,
45                                  float x_scale, float y_scale, float final_xshift,
46                                  float final_yshift) {
47    Clear();
48    block_ = block;
49    if (rotation == nullptr) {
50      rotation_ = nullptr;
51    } else {
52      rotation_ = new FCOORD(*rotation);
53    }
54    predecessor_ = predecessor;
55    x_origin_ = x_origin;
56    y_origin_ = y_origin;
57    x_scale_ = x_scale;
58    y_scale_ = y_scale;
59    final_xshift_ = final_xshift;
60    final_yshift_ = final_yshift;
61  }
62  static void ComputeRunlengthImage(const TBOX &box,
63                                    const std::vector<std::vector<int>> &x_coords,
64                                    const std::vector<std::vector<int>> &y_coords,
65                                    GENERIC_2D_ARRAY<int> *minruns) {
66    int width = box.width();
67    int height = box.height();
68    ASSERT_HOST(minruns->dim1() == width);
69    ASSERT_HOST(minruns->dim2() == height);
70    for (int ix = 0; ix < width; ++ix) {
71      int y = 0;
72      for (auto y_coord : y_coords[ix]) {
73        int y_edge = ClipToRange(y_coord, 0, height);
74        int gap = y_edge - y;
75        while (y < y_edge) {
76          (*minruns)(ix, y) = gap;
77          ++y;
78        }
79      }
80      int gap = height - y;
81      while (y < height) {
82        (*minruns)(ix, y) = gap;
83        ++y;
84      }
85    }
86    for (int iy = 0; iy < height; ++iy) {
87      int x = 0;
88      for (auto x_coord : x_coords[iy]) {
89        int x_edge = ClipToRange(x_coord, 0, width);
90        int gap = x_edge - x;
91        while (x < x_edge) {
92          if (gap < (*minruns)(x, iy)) {
93            (*minruns)(x, iy) = gap;
94          }
95          ++x;
96        }
97      }
98      int gap = width - x;
99      while (x < width) {
100        if (gap < (*minruns)(x, iy)) {
101          (*minruns)(x, iy) = gap;
102        }
103        ++x;
104      }
105    }
106  }
107  static void ComputeEdgeDensityProfiles(const TBOX &box, const GENERIC_2D_ARRAY<int> &minruns,
108                                         std::vector<float> &hx, std::vector<float> &hy) {
109    int width = box.width();
110    int height = box.height();
111    hx.clear();
112    hx.resize(width + 1);
113    hy.clear();
114    hy.resize(height + 1);
115    double total = 0.0;
116    for (int iy = 0; iy < height; ++iy) {
117      for (int ix = 0; ix < width; ++ix) {
118        int run = minruns(ix, iy);
119        if (run == 0) {
120          run = 1;
121        }
122        float density = 1.0f / run;
123        hx[ix] += density;
124        hy[iy] += density;
125      }
126      total += hy[iy];
127    }
128    if (total > 0.0) {
129      for (int ix = 0; ix < width; ++ix) {
130        hx[ix] /= total;
131      }
132      for (int iy = 0; iy < height; ++iy) {
133        hy[iy] /= total;
134      }
135    }
136    hx[width] = 1.0f;
137    hy[height] = 1.0f;
138  }
139  void DENORM::SetupNonLinear(const DENORM *predecessor, const TBOX &box, float target_width,
140                              float target_height, float final_xshift, float final_yshift,
141                              const std::vector<std::vector<int>> &x_coords,
142                              const std::vector<std::vector<int>> &y_coords) {
143    Clear();
144    predecessor_ = predecessor;
145    x_map_ = new std::vector<float>;
146    y_map_ = new std::vector<float>;
147    int width = box.width();
148    int height = box.height();
149    GENERIC_2D_ARRAY<int> minruns(width, height, 0);
150    ComputeRunlengthImage(box, x_coords, y_coords, &minruns);
151    ComputeEdgeDensityProfiles(box, minruns, *x_map_, *y_map_);
152    (*x_map_)[width] = target_width;
153    for (int x = width - 1; x >= 0; --x) {
154      (*x_map_)[x] = (*x_map_)[x + 1] - (*x_map_)[x] * target_width;
155    }
156    (*y_map_)[height] = target_height;
157    for (int y = height - 1; y >= 0; --y) {
158      (*y_map_)[y] = (*y_map_)[y + 1] - (*y_map_)[y] * target_height;
159    }
160    x_origin_ = box.left();
161    y_origin_ = box.bottom();
162    final_xshift_ = final_xshift;
163    final_yshift_ = final_yshift;
164  }
165  void DENORM::LocalNormTransform(const TPOINT &pt, TPOINT *transformed) const {
166    FCOORD src_pt(pt.x, pt.y);
167    FCOORD float_result;
168    LocalNormTransform(src_pt, &float_result);
169    transformed->x = IntCastRounded(float_result.x());
170    transformed->y = IntCastRounded(float_result.y());
171  }
172  void DENORM::LocalNormTransform(const FCOORD &pt, FCOORD *transformed) const {
173    FCOORD translated(pt.x() - x_origin_, pt.y() - y_origin_);
174    if (x_map_ != nullptr && y_map_ != nullptr) {
175      int x = ClipToRange(IntCastRounded(translated.x()), 0, static_cast<int>(x_map_->size() - 1));
176      translated.set_x((*x_map_)[x]);
177      int y = ClipToRange(IntCastRounded(translated.y()), 0, static_cast<int>(y_map_->size() - 1));
178      translated.set_y((*y_map_)[y]);
179    } else {
180      translated.set_x(translated.x() * x_scale_);
181      translated.set_y(translated.y() * y_scale_);
182      if (rotation_ != nullptr) {
183        translated.rotate(*rotation_);
184      }
185    }
186    transformed->set_x(translated.x() + final_xshift_);
187    transformed->set_y(translated.y() + final_yshift_);
188  }
189  void DENORM::NormTransform(const DENORM *first_norm, const TPOINT &pt, TPOINT *transformed) const {
190    FCOORD src_pt(pt.x, pt.y);
191    FCOORD float_result;
192    NormTransform(first_norm, src_pt, &float_result);
193    transformed->x = IntCastRounded(float_result.x());
194    transformed->y = IntCastRounded(float_result.y());
195  }
196  void DENORM::NormTransform(const DENORM *first_norm, const FCOORD &pt, FCOORD *transformed) const {
197    FCOORD src_pt(pt);
198    if (first_norm != this) {
199      if (predecessor_ != nullptr) {
200        predecessor_->NormTransform(first_norm, pt, &src_pt);
201      } else if (block_ != nullptr) {
202        FCOORD fwd_rotation(block_->re_rotation().x(), -block_->re_rotation().y());
203        src_pt.rotate(fwd_rotation);
204      }
205    }
206    LocalNormTransform(src_pt, transformed);
207  }
208  void DENORM::LocalDenormTransform(const TPOINT &pt, TPOINT *original) const {
209    FCOORD src_pt(pt.x, pt.y);
210    FCOORD float_result;
211    LocalDenormTransform(src_pt, &float_result);
212    original->x = IntCastRounded(float_result.x());
213    original->y = IntCastRounded(float_result.y());
214  }
215  void DENORM::LocalDenormTransform(const FCOORD &pt, FCOORD *original) const {
216    FCOORD rotated(pt.x() - final_xshift_, pt.y() - final_yshift_);
217    if (x_map_ != nullptr && y_map_ != nullptr) {
218      auto pos = std::upper_bound(x_map_->begin(), x_map_->end(), rotated.x());
219      if (pos > x_map_->begin()) {
220        --pos;
221      }
222      auto x = pos - x_map_->begin();
223      original->set_x(x + x_origin_);
224      pos = std::upper_bound(y_map_->begin(), y_map_->end(), rotated.y());
225      if (pos > y_map_->begin()) {
226        --pos;
227      }
228      auto y = pos - y_map_->begin();
229      original->set_y(y + y_origin_);
230    } else {
231      if (rotation_ != nullptr) {
232        FCOORD inverse_rotation(rotation_->x(), -rotation_->y());
233        rotated.rotate(inverse_rotation);
234      }
235      original->set_x(rotated.x() / x_scale_ + x_origin_);
236      float y_scale = y_scale_;
237      original->set_y(rotated.y() / y_scale + y_origin_);
238    }
239  }
240  void DENORM::DenormTransform(const DENORM *last_denorm, const TPOINT &pt, TPOINT *original) const {
241    FCOORD src_pt(pt.x, pt.y);
242    FCOORD float_result;
243    DenormTransform(last_denorm, src_pt, &float_result);
244    original->x = IntCastRounded(float_result.x());
<span onclick='openModal()' class='match'>245    original->y = IntCastRounded(float_result.y());
246  }
247  void DENORM::DenormTransform(const DENORM *last_denorm, const FCOORD &pt, FCOORD *original) const {
</span>248    LocalDenormTransform(pt, original);
249    if (last_denorm != this) {
250      if (predecessor_ != nullptr) {
251        predecessor_->DenormTransform(last_denorm, *original, original);
252      } else if (block_ != nullptr) {
253        original->rotate(block_->re_rotation());
254      }
255    }
256  }
257  void DENORM::LocalNormBlob(TBLOB *blob) const {
258    ICOORD translation(-IntCastRounded(x_origin_), -IntCastRounded(y_origin_));
259    blob->Move(translation);
260    if (y_scale_ != 1.0f) {
261      blob->Scale(y_scale_);
262    }
263    if (rotation_ != nullptr) {
264      blob->Rotate(*rotation_);
265    }
266    translation.set_x(IntCastRounded(final_xshift_));
267    translation.set_y(IntCastRounded(final_yshift_));
268    blob->Move(translation);
269  }
270  void DENORM::XHeightRange(int unichar_id, const UNICHARSET &unicharset, const TBOX &bbox,
271                            float *min_xht, float *max_xht, float *yshift) const {
272    *yshift = 0.0f;
273    *min_xht = 0.0f;
274    *max_xht = FLT_MAX;
275    if (!unicharset.top_bottom_useful()) {
276      return;
277    }
278    int top = ClipToRange<int>(bbox.top(), 0, kBlnCellHeight - 1);
279    int bottom = ClipToRange<int>(bbox.bottom(), 0, kBlnCellHeight - 1);
280    double tolerance = y_scale();
281    if (!unicharset.script_has_upper_lower()) {
282      tolerance = y_scale() * kSloppyTolerance;
283    }
284    int min_bottom, max_bottom, min_top, max_top;
285    unicharset.get_top_bottom(unichar_id, &min_bottom, &max_bottom, &min_top, &max_top);
286    double midx = (bbox.left() + bbox.right()) / 2.0;
287    double ydiff = (bbox.top() - bbox.bottom()) + 2.0;
288    FCOORD mid_bot(midx, bbox.bottom()), tmid_bot;
289    FCOORD mid_high(midx, bbox.bottom() + ydiff), tmid_high;
290    DenormTransform(nullptr, mid_bot, &tmid_bot);
291    DenormTransform(nullptr, mid_high, &tmid_high);
292    double yscale = tmid_high.pt_to_pt_dist(tmid_bot) / ydiff;
293    int bln_yshift = 0, bottom_shift = 0, top_shift = 0;
294    if (bottom < min_bottom - tolerance) {
295      bottom_shift = bottom - min_bottom;
296    } else if (bottom > max_bottom + tolerance) {
297      bottom_shift = bottom - max_bottom;
298    }
299    if (top < min_top - tolerance) {
300      top_shift = top - min_top;
301    } else if (top > max_top + tolerance) {
302      top_shift = top - max_top;
303    }
304    if ((top_shift >= 0 && bottom_shift > 0) || (top_shift < 0 && bottom_shift < 0)) {
305      bln_yshift = (top_shift + bottom_shift) / 2;
306    }
307    *yshift = bln_yshift * yscale;
308    if (max_top == kBlnCellHeight - 1 && top > kBlnCellHeight - kBlnBaselineOffset / 2) {
309      max_top += kBlnBaselineOffset;
310    }
311    top -= bln_yshift;
312    int height = top - kBlnBaselineOffset;
313    double min_height = min_top - kBlnBaselineOffset - tolerance;
314    double max_height = max_top - kBlnBaselineOffset + tolerance;
315    if (min_height > kBlnXHeight / 8 && height > 0) {
316      float result = height * kBlnXHeight * yscale / min_height;
317      *max_xht = result + kFinalPixelTolerance;
318      result = height * kBlnXHeight * yscale / max_height;
319      *min_xht = result - kFinalPixelTolerance;
320    }
321  }
322  void DENORM::Print() const {
323    if (pix_ != nullptr) {
324      tprintf("Pix dimensions %d x %d x %d\n", pixGetWidth(pix_), pixGetHeight(pix_),
325              pixGetDepth(pix_));
326    }
327    if (inverse_) {
328      tprintf("Inverse\n");
329    }
330    if (block_ && block_->re_rotation().x() != 1.0f) {
331      tprintf("Block rotation %g, %g\n", block_->re_rotation().x(), block_->re_rotation().y());
332    }
333    tprintf("Input Origin = (%g, %g)\n", x_origin_, y_origin_);
334    if (x_map_ != nullptr && y_map_ != nullptr) {
335      tprintf("x map:\n");
336      for (auto x : *x_map_) {
337        tprintf("%g ", x);
338      }
339      tprintf("\ny map:\n");
340      for (auto y : *y_map_) {
341        tprintf("%g ", y);
342      }
343      tprintf("\n");
344    } else {
345      tprintf("Scale = (%g, %g)\n", x_scale_, y_scale_);
346      if (rotation_ != nullptr) {
347        tprintf("Rotation = (%g, %g)\n", rotation_->x(), rotation_->y());
348      }
349    }
350    tprintf("Final Origin = (%g, %g)\n", final_xshift_, final_xshift_);
351    if (predecessor_ != nullptr) {
352      tprintf("Predecessor:\n");
353      predecessor_->Print();
354    }
355  }
356  void DENORM::Clear() {
357    delete x_map_;
358    x_map_ = nullptr;
359    delete y_map_;
360    y_map_ = nullptr;
361    delete rotation_;
362    rotation_ = nullptr;
363  }
364  void DENORM::Init() {
365    inverse_ = false;
366    pix_ = nullptr;
367    block_ = nullptr;
368    rotation_ = nullptr;
369    predecessor_ = nullptr;
370    x_map_ = nullptr;
371    y_map_ = nullptr;
372    x_origin_ = 0.0f;
373    y_origin_ = 0.0f;
374    x_scale_ = 1.0f;
375    y_scale_ = 1.0f;
376    final_xshift_ = 0.0f;
377    final_yshift_ = static_cast<float>(kBlnBaselineOffset);
378  }
379  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-normalis.cpp</h3>
            <pre><code>1  #include "normalis.h"
2  #include <allheaders.h>
3  #include "blobs.h"
4  #include "helpers.h"
5  #include "matrix.h"
6  #include "ocrblock.h"
7  #include "unicharset.h"
8  #include "werd.h"
9  #include <cfloat> 
10  #include <cstdlib>
11  namespace tesseract {
12  const int kSloppyTolerance = 4;
13  const float kFinalPixelTolerance = 0.125f;
14  DENORM::DENORM() {
15    Init();
16  }
17  DENORM::DENORM(const DENORM &src) {
18    rotation_ = nullptr;
19    *this = src;
20  }
21  DENORM &DENORM::operator=(const DENORM &src) {
22    Clear();
23    inverse_ = src.inverse_;
24    predecessor_ = src.predecessor_;
25    pix_ = src.pix_;
26    block_ = src.block_;
27    if (src.rotation_ == nullptr) {
28      rotation_ = nullptr;
29    } else {
30      rotation_ = new FCOORD(*src.rotation_);
31    }
32    x_origin_ = src.x_origin_;
33    y_origin_ = src.y_origin_;
34    x_scale_ = src.x_scale_;
35    y_scale_ = src.y_scale_;
36    final_xshift_ = src.final_xshift_;
37    final_yshift_ = src.final_yshift_;
38    return *this;
39  }
40  DENORM::~DENORM() {
41    Clear();
42  }
43  void DENORM::SetupNormalization(const BLOCK *block, const FCOORD *rotation,
44                                  const DENORM *predecessor, float x_origin, float y_origin,
45                                  float x_scale, float y_scale, float final_xshift,
46                                  float final_yshift) {
47    Clear();
48    block_ = block;
49    if (rotation == nullptr) {
50      rotation_ = nullptr;
51    } else {
52      rotation_ = new FCOORD(*rotation);
53    }
54    predecessor_ = predecessor;
55    x_origin_ = x_origin;
56    y_origin_ = y_origin;
57    x_scale_ = x_scale;
58    y_scale_ = y_scale;
59    final_xshift_ = final_xshift;
60    final_yshift_ = final_yshift;
61  }
62  static void ComputeRunlengthImage(const TBOX &box,
63                                    const std::vector<std::vector<int>> &x_coords,
64                                    const std::vector<std::vector<int>> &y_coords,
65                                    GENERIC_2D_ARRAY<int> *minruns) {
66    int width = box.width();
67    int height = box.height();
68    ASSERT_HOST(minruns->dim1() == width);
69    ASSERT_HOST(minruns->dim2() == height);
70    for (int ix = 0; ix < width; ++ix) {
71      int y = 0;
72      for (auto y_coord : y_coords[ix]) {
73        int y_edge = ClipToRange(y_coord, 0, height);
74        int gap = y_edge - y;
75        while (y < y_edge) {
76          (*minruns)(ix, y) = gap;
77          ++y;
78        }
79      }
80      int gap = height - y;
81      while (y < height) {
82        (*minruns)(ix, y) = gap;
83        ++y;
84      }
85    }
86    for (int iy = 0; iy < height; ++iy) {
87      int x = 0;
88      for (auto x_coord : x_coords[iy]) {
89        int x_edge = ClipToRange(x_coord, 0, width);
90        int gap = x_edge - x;
91        while (x < x_edge) {
92          if (gap < (*minruns)(x, iy)) {
93            (*minruns)(x, iy) = gap;
94          }
95          ++x;
96        }
97      }
98      int gap = width - x;
99      while (x < width) {
100        if (gap < (*minruns)(x, iy)) {
101          (*minruns)(x, iy) = gap;
102        }
103        ++x;
104      }
105    }
106  }
107  static void ComputeEdgeDensityProfiles(const TBOX &box, const GENERIC_2D_ARRAY<int> &minruns,
108                                         std::vector<float> &hx, std::vector<float> &hy) {
109    int width = box.width();
110    int height = box.height();
111    hx.clear();
112    hx.resize(width + 1);
113    hy.clear();
114    hy.resize(height + 1);
115    double total = 0.0;
116    for (int iy = 0; iy < height; ++iy) {
117      for (int ix = 0; ix < width; ++ix) {
118        int run = minruns(ix, iy);
119        if (run == 0) {
120          run = 1;
121        }
122        float density = 1.0f / run;
123        hx[ix] += density;
124        hy[iy] += density;
125      }
126      total += hy[iy];
127    }
128    if (total > 0.0) {
129      for (int ix = 0; ix < width; ++ix) {
130        hx[ix] /= total;
131      }
132      for (int iy = 0; iy < height; ++iy) {
133        hy[iy] /= total;
134      }
135    }
136    hx[width] = 1.0f;
137    hy[height] = 1.0f;
138  }
139  void DENORM::SetupNonLinear(const DENORM *predecessor, const TBOX &box, float target_width,
140                              float target_height, float final_xshift, float final_yshift,
141                              const std::vector<std::vector<int>> &x_coords,
142                              const std::vector<std::vector<int>> &y_coords) {
143    Clear();
144    predecessor_ = predecessor;
145    x_map_ = new std::vector<float>;
146    y_map_ = new std::vector<float>;
147    int width = box.width();
148    int height = box.height();
149    GENERIC_2D_ARRAY<int> minruns(width, height, 0);
150    ComputeRunlengthImage(box, x_coords, y_coords, &minruns);
151    ComputeEdgeDensityProfiles(box, minruns, *x_map_, *y_map_);
152    (*x_map_)[width] = target_width;
153    for (int x = width - 1; x >= 0; --x) {
154      (*x_map_)[x] = (*x_map_)[x + 1] - (*x_map_)[x] * target_width;
155    }
156    (*y_map_)[height] = target_height;
157    for (int y = height - 1; y >= 0; --y) {
158      (*y_map_)[y] = (*y_map_)[y + 1] - (*y_map_)[y] * target_height;
159    }
160    x_origin_ = box.left();
161    y_origin_ = box.bottom();
162    final_xshift_ = final_xshift;
163    final_yshift_ = final_yshift;
164  }
165  void DENORM::LocalNormTransform(const TPOINT &pt, TPOINT *transformed) const {
166    FCOORD src_pt(pt.x, pt.y);
167    FCOORD float_result;
168    LocalNormTransform(src_pt, &float_result);
169    transformed->x = IntCastRounded(float_result.x());
<span onclick='openModal()' class='match'>170    transformed->y = IntCastRounded(float_result.y());
171  }
172  void DENORM::LocalNormTransform(const FCOORD &pt, FCOORD *transformed) const {
</span>173    FCOORD translated(pt.x() - x_origin_, pt.y() - y_origin_);
174    if (x_map_ != nullptr && y_map_ != nullptr) {
175      int x = ClipToRange(IntCastRounded(translated.x()), 0, static_cast<int>(x_map_->size() - 1));
176      translated.set_x((*x_map_)[x]);
177      int y = ClipToRange(IntCastRounded(translated.y()), 0, static_cast<int>(y_map_->size() - 1));
178      translated.set_y((*y_map_)[y]);
179    } else {
180      translated.set_x(translated.x() * x_scale_);
181      translated.set_y(translated.y() * y_scale_);
182      if (rotation_ != nullptr) {
183        translated.rotate(*rotation_);
184      }
185    }
186    transformed->set_x(translated.x() + final_xshift_);
187    transformed->set_y(translated.y() + final_yshift_);
188  }
189  void DENORM::NormTransform(const DENORM *first_norm, const TPOINT &pt, TPOINT *transformed) const {
190    FCOORD src_pt(pt.x, pt.y);
191    FCOORD float_result;
192    NormTransform(first_norm, src_pt, &float_result);
193    transformed->x = IntCastRounded(float_result.x());
194    transformed->y = IntCastRounded(float_result.y());
195  }
196  void DENORM::NormTransform(const DENORM *first_norm, const FCOORD &pt, FCOORD *transformed) const {
197    FCOORD src_pt(pt);
198    if (first_norm != this) {
199      if (predecessor_ != nullptr) {
200        predecessor_->NormTransform(first_norm, pt, &src_pt);
201      } else if (block_ != nullptr) {
202        FCOORD fwd_rotation(block_->re_rotation().x(), -block_->re_rotation().y());
203        src_pt.rotate(fwd_rotation);
204      }
205    }
206    LocalNormTransform(src_pt, transformed);
207  }
208  void DENORM::LocalDenormTransform(const TPOINT &pt, TPOINT *original) const {
209    FCOORD src_pt(pt.x, pt.y);
210    FCOORD float_result;
211    LocalDenormTransform(src_pt, &float_result);
212    original->x = IntCastRounded(float_result.x());
213    original->y = IntCastRounded(float_result.y());
214  }
215  void DENORM::LocalDenormTransform(const FCOORD &pt, FCOORD *original) const {
216    FCOORD rotated(pt.x() - final_xshift_, pt.y() - final_yshift_);
217    if (x_map_ != nullptr && y_map_ != nullptr) {
218      auto pos = std::upper_bound(x_map_->begin(), x_map_->end(), rotated.x());
219      if (pos > x_map_->begin()) {
220        --pos;
221      }
222      auto x = pos - x_map_->begin();
223      original->set_x(x + x_origin_);
224      pos = std::upper_bound(y_map_->begin(), y_map_->end(), rotated.y());
225      if (pos > y_map_->begin()) {
226        --pos;
227      }
228      auto y = pos - y_map_->begin();
229      original->set_y(y + y_origin_);
230    } else {
231      if (rotation_ != nullptr) {
232        FCOORD inverse_rotation(rotation_->x(), -rotation_->y());
233        rotated.rotate(inverse_rotation);
234      }
235      original->set_x(rotated.x() / x_scale_ + x_origin_);
236      float y_scale = y_scale_;
237      original->set_y(rotated.y() / y_scale + y_origin_);
238    }
239  }
240  void DENORM::DenormTransform(const DENORM *last_denorm, const TPOINT &pt, TPOINT *original) const {
241    FCOORD src_pt(pt.x, pt.y);
242    FCOORD float_result;
243    DenormTransform(last_denorm, src_pt, &float_result);
244    original->x = IntCastRounded(float_result.x());
245    original->y = IntCastRounded(float_result.y());
246  }
247  void DENORM::DenormTransform(const DENORM *last_denorm, const FCOORD &pt, FCOORD *original) const {
248    LocalDenormTransform(pt, original);
249    if (last_denorm != this) {
250      if (predecessor_ != nullptr) {
251        predecessor_->DenormTransform(last_denorm, *original, original);
252      } else if (block_ != nullptr) {
253        original->rotate(block_->re_rotation());
254      }
255    }
256  }
257  void DENORM::LocalNormBlob(TBLOB *blob) const {
258    ICOORD translation(-IntCastRounded(x_origin_), -IntCastRounded(y_origin_));
259    blob->Move(translation);
260    if (y_scale_ != 1.0f) {
261      blob->Scale(y_scale_);
262    }
263    if (rotation_ != nullptr) {
264      blob->Rotate(*rotation_);
265    }
266    translation.set_x(IntCastRounded(final_xshift_));
267    translation.set_y(IntCastRounded(final_yshift_));
268    blob->Move(translation);
269  }
270  void DENORM::XHeightRange(int unichar_id, const UNICHARSET &unicharset, const TBOX &bbox,
271                            float *min_xht, float *max_xht, float *yshift) const {
272    *yshift = 0.0f;
273    *min_xht = 0.0f;
274    *max_xht = FLT_MAX;
275    if (!unicharset.top_bottom_useful()) {
276      return;
277    }
278    int top = ClipToRange<int>(bbox.top(), 0, kBlnCellHeight - 1);
279    int bottom = ClipToRange<int>(bbox.bottom(), 0, kBlnCellHeight - 1);
280    double tolerance = y_scale();
281    if (!unicharset.script_has_upper_lower()) {
282      tolerance = y_scale() * kSloppyTolerance;
283    }
284    int min_bottom, max_bottom, min_top, max_top;
285    unicharset.get_top_bottom(unichar_id, &min_bottom, &max_bottom, &min_top, &max_top);
286    double midx = (bbox.left() + bbox.right()) / 2.0;
287    double ydiff = (bbox.top() - bbox.bottom()) + 2.0;
288    FCOORD mid_bot(midx, bbox.bottom()), tmid_bot;
289    FCOORD mid_high(midx, bbox.bottom() + ydiff), tmid_high;
290    DenormTransform(nullptr, mid_bot, &tmid_bot);
291    DenormTransform(nullptr, mid_high, &tmid_high);
292    double yscale = tmid_high.pt_to_pt_dist(tmid_bot) / ydiff;
293    int bln_yshift = 0, bottom_shift = 0, top_shift = 0;
294    if (bottom < min_bottom - tolerance) {
295      bottom_shift = bottom - min_bottom;
296    } else if (bottom > max_bottom + tolerance) {
297      bottom_shift = bottom - max_bottom;
298    }
299    if (top < min_top - tolerance) {
300      top_shift = top - min_top;
301    } else if (top > max_top + tolerance) {
302      top_shift = top - max_top;
303    }
304    if ((top_shift >= 0 && bottom_shift > 0) || (top_shift < 0 && bottom_shift < 0)) {
305      bln_yshift = (top_shift + bottom_shift) / 2;
306    }
307    *yshift = bln_yshift * yscale;
308    if (max_top == kBlnCellHeight - 1 && top > kBlnCellHeight - kBlnBaselineOffset / 2) {
309      max_top += kBlnBaselineOffset;
310    }
311    top -= bln_yshift;
312    int height = top - kBlnBaselineOffset;
313    double min_height = min_top - kBlnBaselineOffset - tolerance;
314    double max_height = max_top - kBlnBaselineOffset + tolerance;
315    if (min_height > kBlnXHeight / 8 && height > 0) {
316      float result = height * kBlnXHeight * yscale / min_height;
317      *max_xht = result + kFinalPixelTolerance;
318      result = height * kBlnXHeight * yscale / max_height;
319      *min_xht = result - kFinalPixelTolerance;
320    }
321  }
322  void DENORM::Print() const {
323    if (pix_ != nullptr) {
324      tprintf("Pix dimensions %d x %d x %d\n", pixGetWidth(pix_), pixGetHeight(pix_),
325              pixGetDepth(pix_));
326    }
327    if (inverse_) {
328      tprintf("Inverse\n");
329    }
330    if (block_ && block_->re_rotation().x() != 1.0f) {
331      tprintf("Block rotation %g, %g\n", block_->re_rotation().x(), block_->re_rotation().y());
332    }
333    tprintf("Input Origin = (%g, %g)\n", x_origin_, y_origin_);
334    if (x_map_ != nullptr && y_map_ != nullptr) {
335      tprintf("x map:\n");
336      for (auto x : *x_map_) {
337        tprintf("%g ", x);
338      }
339      tprintf("\ny map:\n");
340      for (auto y : *y_map_) {
341        tprintf("%g ", y);
342      }
343      tprintf("\n");
344    } else {
345      tprintf("Scale = (%g, %g)\n", x_scale_, y_scale_);
346      if (rotation_ != nullptr) {
347        tprintf("Rotation = (%g, %g)\n", rotation_->x(), rotation_->y());
348      }
349    }
350    tprintf("Final Origin = (%g, %g)\n", final_xshift_, final_xshift_);
351    if (predecessor_ != nullptr) {
352      tprintf("Predecessor:\n");
353      predecessor_->Print();
354    }
355  }
356  void DENORM::Clear() {
357    delete x_map_;
358    x_map_ = nullptr;
359    delete y_map_;
360    y_map_ = nullptr;
361    delete rotation_;
362    rotation_ = nullptr;
363  }
364  void DENORM::Init() {
365    inverse_ = false;
366    pix_ = nullptr;
367    block_ = nullptr;
368    rotation_ = nullptr;
369    predecessor_ = nullptr;
370    x_map_ = nullptr;
371    y_map_ = nullptr;
372    x_origin_ = 0.0f;
373    y_origin_ = 0.0f;
374    x_scale_ = 1.0f;
375    y_scale_ = 1.0f;
376    final_xshift_ = 0.0f;
377    final_yshift_ = static_cast<float>(kBlnBaselineOffset);
378  }
379  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-normalis.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-normalis.cpp</div>
                </div>
                <div class="column column_space"><pre><code>245    original->y = IntCastRounded(float_result.y());
246  }
247  void DENORM::DenormTransform(const DENORM *last_denorm, const FCOORD &pt, FCOORD *original) const {
</pre></code></div>
                <div class="column column_space"><pre><code>170    transformed->y = IntCastRounded(float_result.y());
171  }
172  void DENORM::LocalNormTransform(const FCOORD &pt, FCOORD *transformed) const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    