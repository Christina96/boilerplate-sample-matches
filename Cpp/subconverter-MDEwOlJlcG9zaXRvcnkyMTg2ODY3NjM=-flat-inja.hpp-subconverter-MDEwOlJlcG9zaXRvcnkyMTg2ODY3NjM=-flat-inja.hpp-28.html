
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-inja.hpp</h3>
            <pre><code>1  #ifndef INCLUDE_INJA_INJA_HPP_
2  #define INCLUDE_INJA_INJA_HPP_
3  #include &lt;nlohmann/json.hpp&gt;
4  namespace inja {
5  #ifndef INJA_DATA_TYPE
6    using json = nlohmann::json;
7  #else
8    using json = INJA_DATA_TYPE;
9  #endif
10  }
11  #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) &amp;&amp; !defined(INJA_NOEXCEPTION)
12    #ifndef INJA_THROW
13      #define INJA_THROW(exception) throw exception
14    #endif
15  #else
16    #include &lt;cstdlib&gt;
17    #ifndef INJA_THROW
18      #define INJA_THROW(exception) std::abort(); std::ignore = exception
19    #endif
20    #ifndef INJA_NOEXCEPTION
21      #define INJA_NOEXCEPTION
22    #endif
23  #endif
24  #ifndef INCLUDE_INJA_ENVIRONMENT_HPP_
25  #define INCLUDE_INJA_ENVIRONMENT_HPP_
26  #include &lt;fstream&gt;
27  #include &lt;iostream&gt;
28  #include &lt;memory&gt;
29  #include &lt;sstream&gt;
30  #include &lt;string&gt;
31  #ifndef INCLUDE_INJA_CONFIG_HPP_
32  #define INCLUDE_INJA_CONFIG_HPP_
33  #include &lt;functional&gt;
34  #include &lt;string&gt;
35  #ifndef NONSTD_SV_LITE_H_INCLUDED
36  #define NONSTD_SV_LITE_H_INCLUDED
37  #define string_view_lite_MAJOR 1
38  #define string_view_lite_MINOR 4
39  #define string_view_lite_PATCH 0
40  #define string_view_lite_VERSION                                                                                       \
41    nssv_STRINGIFY(string_view_lite_MAJOR) &quot;.&quot; nssv_STRINGIFY(string_view_lite_MINOR) &quot;.&quot; nssv_STRINGIFY(                \
42        string_view_lite_PATCH)
43  #define nssv_STRINGIFY(x) nssv_STRINGIFY_(x)
44  #define nssv_STRINGIFY_(x) #x
45  #define nssv_STRING_VIEW_DEFAULT 0
46  #define nssv_STRING_VIEW_NONSTD 1
47  #define nssv_STRING_VIEW_STD 2
48  #if !defined(nssv_CONFIG_SELECT_STRING_VIEW)
49  #define nssv_CONFIG_SELECT_STRING_VIEW (nssv_HAVE_STD_STRING_VIEW ? nssv_STRING_VIEW_STD : nssv_STRING_VIEW_NONSTD)
50  #endif
51  #if defined(nssv_CONFIG_SELECT_STD_STRING_VIEW) || defined(nssv_CONFIG_SELECT_NONSTD_STRING_VIEW)
52  #error nssv_CONFIG_SELECT_STD_STRING_VIEW and nssv_CONFIG_SELECT_NONSTD_STRING_VIEW are deprecated and removed, please use nssv_CONFIG_SELECT_STRING_VIEW=nssv_STRING_VIEW_...
53  #endif
54  #ifndef nssv_CONFIG_STD_SV_OPERATOR
55  #define nssv_CONFIG_STD_SV_OPERATOR 0
56  #endif
57  #ifndef nssv_CONFIG_USR_SV_OPERATOR
58  #define nssv_CONFIG_USR_SV_OPERATOR 1
59  #endif
60  #ifdef nssv_CONFIG_CONVERSION_STD_STRING
61  #define nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS nssv_CONFIG_CONVERSION_STD_STRING
62  #define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS nssv_CONFIG_CONVERSION_STD_STRING
63  #endif
64  #ifndef nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS
65  #define nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS 1
66  #endif
67  #ifndef nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
68  #define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS 1
69  #endif
70  #ifndef nssv_CONFIG_NO_EXCEPTIONS
71  #if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)
72  #define nssv_CONFIG_NO_EXCEPTIONS 0
73  #else
74  #define nssv_CONFIG_NO_EXCEPTIONS 1
75  #endif
76  #endif
77  #ifndef nssv_CPLUSPLUS
78  #if defined(_MSVC_LANG) &amp;&amp; !defined(__clang__)
79  #define nssv_CPLUSPLUS (_MSC_VER == 1900 ? 201103L : _MSVC_LANG)
80  #else
81  #define nssv_CPLUSPLUS __cplusplus
82  #endif
83  #endif
84  #define nssv_CPP98_OR_GREATER (nssv_CPLUSPLUS &gt;= 199711L)
85  #define nssv_CPP11_OR_GREATER (nssv_CPLUSPLUS &gt;= 201103L)
86  #define nssv_CPP11_OR_GREATER_ (nssv_CPLUSPLUS &gt;= 201103L)
87  #define nssv_CPP14_OR_GREATER (nssv_CPLUSPLUS &gt;= 201402L)
88  #define nssv_CPP17_OR_GREATER (nssv_CPLUSPLUS &gt;= 201703L)
89  #define nssv_CPP20_OR_GREATER (nssv_CPLUSPLUS &gt;= 202000L)
90  #if nssv_CPP17_OR_GREATER &amp;&amp; defined(__has_include)
91  #if __has_include(&lt;string_view&gt; )
92  #define nssv_HAVE_STD_STRING_VIEW 1
93  #else
94  #define nssv_HAVE_STD_STRING_VIEW 0
95  #endif
96  #else
97  #define nssv_HAVE_STD_STRING_VIEW 0
98  #endif
99  #define nssv_USES_STD_STRING_VIEW                                                                                      \
100    ((nssv_CONFIG_SELECT_STRING_VIEW == nssv_STRING_VIEW_STD) ||                                                         \
101     ((nssv_CONFIG_SELECT_STRING_VIEW == nssv_STRING_VIEW_DEFAULT) &amp;&amp; nssv_HAVE_STD_STRING_VIEW))
102  #define nssv_HAVE_STARTS_WITH (nssv_CPP20_OR_GREATER || !nssv_USES_STD_STRING_VIEW)
103  #define nssv_HAVE_ENDS_WITH nssv_HAVE_STARTS_WITH
104  #if nssv_USES_STD_STRING_VIEW
105  #include &lt;string_view&gt;
106  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
107  namespace nonstd {
108  template &lt;class CharT, class Traits, class Allocator = std::allocator&lt;CharT&gt;&gt;
109  std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(std::basic_string_view&lt;CharT, Traits&gt; v,
110                                                        Allocator const &amp;a = Allocator()) {
111    return std::basic_string&lt;CharT, Traits, Allocator&gt;(v.begin(), v.end(), a);
112  }
113  template &lt;class CharT, class Traits, class Allocator&gt;
114  std::basic_string_view&lt;CharT, Traits&gt; to_string_view(std::basic_string&lt;CharT, Traits, Allocator&gt; const &amp;s) {
115    return std::basic_string_view&lt;CharT, Traits&gt;(s.data(), s.size());
116  }
117  #if nssv_CONFIG_STD_SV_OPERATOR
118  using namespace std::literals::string_view_literals;
119  #endif
120  #if nssv_CONFIG_USR_SV_OPERATOR
121  inline namespace literals {
122  inline namespace string_view_literals {
123  constexpr std::string_view operator&quot;&quot; _sv(const char *str, size_t len) noexcept 
124  {
125    return std::string_view {str, len};
126  }
127  constexpr std::u16string_view operator&quot;&quot; _sv(const char16_t *str, size_t len) noexcept 
128  {
129    return std::u16string_view {str, len};
130  }
131  constexpr std::u32string_view operator&quot;&quot; _sv(const char32_t *str, size_t len) noexcept 
132  {
133    return std::u32string_view {str, len};
134  }
135  constexpr std::wstring_view operator&quot;&quot; _sv(const wchar_t *str, size_t len) noexcept 
136  {
137    return std::wstring_view {str, len};
138  }
139  } 
140  } 
141  #endif 
142  } 
143  #endif 
144  namespace nonstd {
145  using std::basic_string_view;
146  using std::string_view;
147  using std::u16string_view;
148  using std::u32string_view;
149  using std::wstring_view;
150  using std::operator==;
151  using std::operator!=;
152  using std::operator&lt;;
153  using std::operator&lt;=;
154  using std::operator&gt;;
155  using std::operator&gt;=;
156  using std::operator&lt;&lt;;
157  } 
158  #else 
159  #if defined(_MSC_VER) &amp;&amp; !defined(__clang__)
160  #define nssv_COMPILER_MSVC_VER (_MSC_VER)
161  #define nssv_COMPILER_MSVC_VERSION (_MSC_VER / 10 - 10 * (5 + (_MSC_VER &lt; 1900)))
162  #else
163  #define nssv_COMPILER_MSVC_VER 0
164  #define nssv_COMPILER_MSVC_VERSION 0
165  #endif
166  #define nssv_COMPILER_VERSION(major, minor, patch) (10 * (10 * (major) + (minor)) + (patch))
167  #if defined(__clang__)
168  #define nssv_COMPILER_CLANG_VERSION nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)
169  #else
170  #define nssv_COMPILER_CLANG_VERSION 0
171  #endif
172  #if defined(__GNUC__) &amp;&amp; !defined(__clang__)
173  #define nssv_COMPILER_GNUC_VERSION nssv_COMPILER_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
174  #else
175  #define nssv_COMPILER_GNUC_VERSION 0
176  #endif
177  #define nssv_BETWEEN(v, lo, hi) ((lo) &lt;= (v) &amp;&amp; (v) &lt; (hi))
178  #ifdef _HAS_CPP0X
179  #define nssv_HAS_CPP0X _HAS_CPP0X
180  #else
181  #define nssv_HAS_CPP0X 0
182  #endif
183  #if nssv_COMPILER_MSVC_VER &gt;= 1900
184  #undef nssv_CPP11_OR_GREATER
185  #define nssv_CPP11_OR_GREATER 1
186  #endif
187  #define nssv_CPP11_90 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1500)
188  #define nssv_CPP11_100 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1600)
189  #define nssv_CPP11_110 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1700)
190  #define nssv_CPP11_120 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1800)
191  #define nssv_CPP11_140 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1900)
192  #define nssv_CPP11_141 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1910)
193  #define nssv_CPP14_000 (nssv_CPP14_OR_GREATER)
194  #define nssv_CPP17_000 (nssv_CPP17_OR_GREATER)
195  #define nssv_HAVE_CONSTEXPR_11 nssv_CPP11_140
196  #define nssv_HAVE_EXPLICIT_CONVERSION nssv_CPP11_140
197  #define nssv_HAVE_INLINE_NAMESPACE nssv_CPP11_140
198  #define nssv_HAVE_NOEXCEPT nssv_CPP11_140
199  #define nssv_HAVE_NULLPTR nssv_CPP11_100
200  #define nssv_HAVE_REF_QUALIFIER nssv_CPP11_140
201  #define nssv_HAVE_UNICODE_LITERALS nssv_CPP11_140
202  #define nssv_HAVE_USER_DEFINED_LITERALS nssv_CPP11_140
203  #define nssv_HAVE_WCHAR16_T nssv_CPP11_100
204  #define nssv_HAVE_WCHAR32_T nssv_CPP11_100
205  #if !((nssv_CPP11_OR_GREATER &amp;&amp; nssv_COMPILER_CLANG_VERSION) || nssv_BETWEEN(nssv_COMPILER_CLANG_VERSION, 300, 400))
206  #define nssv_HAVE_STD_DEFINED_LITERALS nssv_CPP11_140
207  #else
208  #define nssv_HAVE_STD_DEFINED_LITERALS 0
209  #endif
210  #define nssv_HAVE_CONSTEXPR_14 nssv_CPP14_000
211  #define nssv_HAVE_NODISCARD nssv_CPP17_000
212  #define nssv_HAVE_STD_HASH nssv_CPP11_120
213  #if nssv_HAVE_CONSTEXPR_11
214  #define nssv_constexpr constexpr
215  #else
216  #define nssv_constexpr &amp;bsol;*constexpr*/
217  #endif
218  #if nssv_HAVE_CONSTEXPR_14
219  #define nssv_constexpr14 constexpr
220  #else
221  #define nssv_constexpr14 &amp;bsol;*constexpr*/
222  #endif
223  #if nssv_HAVE_EXPLICIT_CONVERSION
224  #define nssv_explicit explicit
225  #else
226  #define nssv_explicit &amp;bsol;*explicit*/
227  #endif
228  #if nssv_HAVE_INLINE_NAMESPACE
229  #define nssv_inline_ns inline
230  #else
231  #define nssv_inline_ns &amp;bsol;*inline*/
232  #endif
233  #if nssv_HAVE_NOEXCEPT
234  #define nssv_noexcept noexcept
235  #else
236  #define nssv_noexcept &amp;bsol;*noexcept*/
237  #endif
238  #if nssv_HAVE_NULLPTR
239  #define nssv_nullptr nullptr
240  #else
241  #define nssv_nullptr NULL
242  #endif
243  #if nssv_HAVE_NODISCARD
244  #define nssv_nodiscard [[nodiscard]]
245  #else
246  #define nssv_nodiscard &amp;bsol;*[[nodiscard]]*/
247  #endif
248  #include &lt;algorithm&gt;
249  #include &lt;cassert&gt;
250  #include &lt;iterator&gt;
251  #include &lt;limits&gt;
252  #include &lt;ostream&gt;
253  #include &lt;string&gt; 
254  #if !nssv_CONFIG_NO_EXCEPTIONS
255  #include &lt;stdexcept&gt;
256  #endif
257  #if nssv_CPP11_OR_GREATER
258  #include &lt;type_traits&gt;
259  #endif
260  #if defined(__clang__)
261  #pragma clang diagnostic ignored &quot;-Wreserved-user-defined-literal&quot;
262  #pragma clang diagnostic push
263  #pragma clang diagnostic ignored &quot;-Wuser-defined-literals&quot;
264  #elif defined(__GNUC__)
265  #pragma GCC diagnostic push
266  #pragma GCC diagnostic ignored &quot;-Wliteral-suffix&quot;
267  #endif 
268  #if nssv_COMPILER_MSVC_VERSION &gt;= 140
269  #define nssv_SUPPRESS_MSGSL_WARNING(expr) [[gsl::suppress(expr)]]
270  #define nssv_SUPPRESS_MSVC_WARNING(code, descr) __pragma(warning(suppress : code))
271  #define nssv_DISABLE_MSVC_WARNINGS(codes) __pragma(warning(push)) __pragma(warning(disable : codes))
272  #else
273  #define nssv_SUPPRESS_MSGSL_WARNING(expr)
274  #define nssv_SUPPRESS_MSVC_WARNING(code, descr)
275  #define nssv_DISABLE_MSVC_WARNINGS(codes)
276  #endif
277  #if defined(__clang__)
278  #define nssv_RESTORE_WARNINGS() _Pragma(&quot;clang diagnostic pop&quot;)
279  #elif defined(__GNUC__)
280  #define nssv_RESTORE_WARNINGS() _Pragma(&quot;GCC diagnostic pop&quot;)
281  #elif nssv_COMPILER_MSVC_VERSION &gt;= 140
282  #define nssv_RESTORE_WARNINGS() __pragma(warning(pop))
283  #else
284  #define nssv_RESTORE_WARNINGS()
285  #endif
286  nssv_DISABLE_MSVC_WARNINGS(4455 26481 26472)
287      namespace nonstd {
288    namespace sv_lite {
289  #if nssv_CPP11_OR_GREATER
290    namespace detail {
291    template &lt;typename CharT&gt; inline constexpr std::size_t length(CharT *s, std::size_t result = 0) {
292      return *s == &#x27;\0&#x27; ? result : length(s + 1, result + 1);
293    }
294    } 
295  #endif 
296    template &lt;class CharT, class Traits = std::char_traits&lt;CharT&gt;&gt; class basic_string_view;
297    template &lt;class CharT, class Traits &amp;bsol;* = std::char_traits&lt;CharT&gt; */
298              &gt;
299    class basic_string_view {
300    public:
301      typedef Traits traits_type;
302      typedef CharT value_type;
303      typedef CharT *pointer;
304      typedef CharT const *const_pointer;
305      typedef CharT &amp;reference;
306      typedef CharT const &amp;const_reference;
307      typedef const_pointer iterator;
308      typedef const_pointer const_iterator;
309      typedef std::reverse_iterator&lt;const_iterator&gt; reverse_iterator;
310      typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
311      typedef std::size_t size_type;
312      typedef std::ptrdiff_t difference_type;
313      nssv_constexpr basic_string_view() nssv_noexcept : data_(nssv_nullptr), size_(0) {}
314  #if nssv_CPP11_OR_GREATER
315      nssv_constexpr basic_string_view(basic_string_view const &amp;other) nssv_noexcept = default;
316  #else
317      nssv_constexpr basic_string_view(basic_string_view const &amp;other) nssv_noexcept : data_(other.data_),
318                                                                                       size_(other.size_) {}
319  #endif
320      nssv_constexpr basic_string_view(CharT const *s, size_type count) nssv_noexcept 
321          : data_(s),
322            size_(count) {}
323      nssv_constexpr basic_string_view(CharT const *s) nssv_noexcept 
324          : data_(s)
325  #if nssv_CPP17_OR_GREATER
326          ,
327            size_(Traits::length(s))
328  #elif nssv_CPP11_OR_GREATER
329          ,
330            size_(detail::length(s))
331  #else
332          ,
333            size_(Traits::length(s))
334  #endif
335      {
336      }
337  #if nssv_CPP11_OR_GREATER
338      nssv_constexpr14 basic_string_view &amp;operator=(basic_string_view const &amp;other) nssv_noexcept = default;
339  #else
340      nssv_constexpr14 basic_string_view &amp;operator=(basic_string_view const &amp;other) nssv_noexcept {
341        data_ = other.data_;
342        size_ = other.size_;
343        return *this;
344      }
345  #endif
346      nssv_constexpr const_iterator begin() const nssv_noexcept { return data_; }
347      nssv_constexpr const_iterator end() const nssv_noexcept { return data_ + size_; }
348      nssv_constexpr const_iterator cbegin() const nssv_noexcept { return begin(); }
349      nssv_constexpr const_iterator cend() const nssv_noexcept { return end(); }
350      nssv_constexpr const_reverse_iterator rbegin() const nssv_noexcept { return const_reverse_iterator(end()); }
351      nssv_constexpr const_reverse_iterator rend() const nssv_noexcept { return const_reverse_iterator(begin()); }
352      nssv_constexpr const_reverse_iterator crbegin() const nssv_noexcept { return rbegin(); }
353      nssv_constexpr const_reverse_iterator crend() const nssv_noexcept { return rend(); }
354      nssv_constexpr size_type size() const nssv_noexcept { return size_; }
355      nssv_constexpr size_type length() const nssv_noexcept { return size_; }
356      nssv_constexpr size_type max_size() const nssv_noexcept { return (std::numeric_limits&lt;size_type&gt;::max)(); }
357      nssv_nodiscard nssv_constexpr bool empty() const nssv_noexcept { return 0 == size_; }
358      nssv_constexpr const_reference operator[](size_type pos) const { return data_at(pos); }
359      nssv_constexpr14 const_reference at(size_type pos) const {
360  #if nssv_CONFIG_NO_EXCEPTIONS
361        assert(pos &lt; size());
362  #else
363        if (pos &gt;= size()) {
364          throw std::out_of_range(&quot;nonstd::string_view::at()&quot;);
365        }
366  #endif
367        return data_at(pos);
368      }
369      nssv_constexpr const_reference front() const { return data_at(0); }
370      nssv_constexpr const_reference back() const { return data_at(size() - 1); }
371      nssv_constexpr const_pointer data() const nssv_noexcept { return data_; }
372      nssv_constexpr14 void remove_prefix(size_type n) {
373        assert(n &lt;= size());
374        data_ += n;
375        size_ -= n;
376      }
377      nssv_constexpr14 void remove_suffix(size_type n) {
378        assert(n &lt;= size());
379        size_ -= n;
380      }
381      nssv_constexpr14 void swap(basic_string_view &amp;other) nssv_noexcept {
382        using std::swap;
383        swap(data_, other.data_);
384        swap(size_, other.size_);
385      }
386      size_type copy(CharT *dest, size_type n, size_type pos = 0) const {
387  #if nssv_CONFIG_NO_EXCEPTIONS
388        assert(pos &lt;= size());
389  #else
390        if (pos &gt; size()) {
391          throw std::out_of_range(&quot;nonstd::string_view::copy()&quot;);
392        }
393  #endif
394        const size_type rlen = (std::min)(n, size() - pos);
395        (void)Traits::copy(dest, data() + pos, rlen);
396        return rlen;
397      }
398      nssv_constexpr14 basic_string_view substr(size_type pos = 0, size_type n = npos) const {
399  #if nssv_CONFIG_NO_EXCEPTIONS
400        assert(pos &lt;= size());
401  #else
402        if (pos &gt; size()) {
403          throw std::out_of_range(&quot;nonstd::string_view::substr()&quot;);
404        }
405  #endif
406        return basic_string_view(data() + pos, (std::min)(n, size() - pos));
407      }
408      nssv_constexpr14 int compare(basic_string_view other) const nssv_noexcept 
409      {
410        if (const int result = Traits::compare(data(), other.data(), (std::min)(size(), other.size()))) {
411          return result;
412        }
413        return size() == other.size() ? 0 : size() &lt; other.size() ? -1 : 1;
414      }
415      nssv_constexpr int compare(size_type pos1, size_type n1, basic_string_view other) const 
416      {
417        return substr(pos1, n1).compare(other);
418      }
419      nssv_constexpr int compare(size_type pos1, size_type n1, basic_string_view other, size_type pos2,
420                                 size_type n2) const 
421      {
422        return substr(pos1, n1).compare(other.substr(pos2, n2));
423      }
424      nssv_constexpr int compare(CharT const *s) const 
425      {
426        return compare(basic_string_view(s));
427      }
428      nssv_constexpr int compare(size_type pos1, size_type n1, CharT const *s) const 
429      {
430        return substr(pos1, n1).compare(basic_string_view(s));
431      }
432      nssv_constexpr int compare(size_type pos1, size_type n1, CharT const *s, size_type n2) const 
433      {
434        return substr(pos1, n1).compare(basic_string_view(s, n2));
435      }
436      nssv_constexpr bool starts_with(basic_string_view v) const nssv_noexcept 
437      {
438        return size() &gt;= v.size() &amp;&amp; compare(0, v.size(), v) == 0;
439      }
440      nssv_constexpr bool starts_with(CharT c) const nssv_noexcept 
441      {
442        return starts_with(basic_string_view(&amp;c, 1));
443      }
444      nssv_constexpr bool starts_with(CharT const *s) const 
445      {
446        return starts_with(basic_string_view(s));
447      }
448      nssv_constexpr bool ends_with(basic_string_view v) const nssv_noexcept 
449      {
450        return size() &gt;= v.size() &amp;&amp; compare(size() - v.size(), npos, v) == 0;
451      }
452      nssv_constexpr bool ends_with(CharT c) const nssv_noexcept 
453      {
454        return ends_with(basic_string_view(&amp;c, 1));
455      }
456      nssv_constexpr bool ends_with(CharT const *s) const 
457      {
458        return ends_with(basic_string_view(s));
459      }
460      nssv_constexpr14 size_type find(basic_string_view v, size_type pos = 0) const nssv_noexcept 
461      {
462        return assert(v.size() == 0 || v.data() != nssv_nullptr),
463               pos &gt;= size() ? npos : to_pos(std::search(cbegin() + pos, cend(), v.cbegin(), v.cend(), Traits::eq));
464      }
465      nssv_constexpr14 size_type find(CharT c, size_type pos = 0) const nssv_noexcept 
466      {
467        return find(basic_string_view(&amp;c, 1), pos);
468      }
469      nssv_constexpr14 size_type find(CharT const *s, size_type pos, size_type n) const 
470      {
471        return find(basic_string_view(s, n), pos);
472      }
473      nssv_constexpr14 size_type find(CharT const *s, size_type pos = 0) const 
474      {
475        return find(basic_string_view(s), pos);
476      }
477      nssv_constexpr14 size_type rfind(basic_string_view v, size_type pos = npos) const nssv_noexcept 
478      {
479        if (size() &lt; v.size()) {
480          return npos;
481        }
482        if (v.empty()) {
483          return (std::min)(size(), pos);
484        }
485        const_iterator last = cbegin() + (std::min)(size() - v.size(), pos) + v.size();
486        const_iterator result = std::find_end(cbegin(), last, v.cbegin(), v.cend(), Traits::eq);
487        return result != last ? size_type(result - cbegin()) : npos;
488      }
489      nssv_constexpr14 size_type rfind(CharT c, size_type pos = npos) const nssv_noexcept 
490      {
491        return rfind(basic_string_view(&amp;c, 1), pos);
492      }
493      nssv_constexpr14 size_type rfind(CharT const *s, size_type pos, size_type n) const 
494      {
495        return rfind(basic_string_view(s, n), pos);
496      }
497      nssv_constexpr14 size_type rfind(CharT const *s, size_type pos = npos) const 
498      {
499        return rfind(basic_string_view(s), pos);
500      }
501      nssv_constexpr size_type find_first_of(basic_string_view v, size_type pos = 0) const nssv_noexcept 
502      {
503        return pos &gt;= size() ? npos
504                             : to_pos(std::find_first_of(cbegin() + pos, cend(), v.cbegin(), v.cend(), Traits::eq));
505      }
506      nssv_constexpr size_type find_first_of(CharT c, size_type pos = 0) const nssv_noexcept 
507      {
508        return find_first_of(basic_string_view(&amp;c, 1), pos);
509      }
510      nssv_constexpr size_type find_first_of(CharT const *s, size_type pos, size_type n) const 
511      {
512        return find_first_of(basic_string_view(s, n), pos);
513      }
514      nssv_constexpr size_type find_first_of(CharT const *s, size_type pos = 0) const 
515      {
516        return find_first_of(basic_string_view(s), pos);
517      }
518      nssv_constexpr size_type find_last_of(basic_string_view v, size_type pos = npos) const nssv_noexcept 
519      {
520        return empty() ? npos
521                       : pos &gt;= size() ? find_last_of(v, size() - 1)
522                                       : to_pos(std::find_first_of(const_reverse_iterator(cbegin() + pos + 1), crend(),
523                                                                   v.cbegin(), v.cend(), Traits::eq));
524      }
525      nssv_constexpr size_type find_last_of(CharT c, size_type pos = npos) const nssv_noexcept 
526      {
527        return find_last_of(basic_string_view(&amp;c, 1), pos);
528      }
529      nssv_constexpr size_type find_last_of(CharT const *s, size_type pos, size_type count) const 
530      {
531        return find_last_of(basic_string_view(s, count), pos);
532      }
533      nssv_constexpr size_type find_last_of(CharT const *s, size_type pos = npos) const 
534      {
535        return find_last_of(basic_string_view(s), pos);
536      }
537      nssv_constexpr size_type find_first_not_of(basic_string_view v, size_type pos = 0) const nssv_noexcept 
538      {
539        return pos &gt;= size() ? npos : to_pos(std::find_if(cbegin() + pos, cend(), not_in_view(v)));
540      }
541      nssv_constexpr size_type find_first_not_of(CharT c, size_type pos = 0) const nssv_noexcept 
542      {
543        return find_first_not_of(basic_string_view(&amp;c, 1), pos);
544      }
545      nssv_constexpr size_type find_first_not_of(CharT const *s, size_type pos, size_type count) const 
546      {
547        return find_first_not_of(basic_string_view(s, count), pos);
548      }
549      nssv_constexpr size_type find_first_not_of(CharT const *s, size_type pos = 0) const 
550      {
551        return find_first_not_of(basic_string_view(s), pos);
552      }
553      nssv_constexpr size_type find_last_not_of(basic_string_view v, size_type pos = npos) const nssv_noexcept 
554      {
555        return empty() ? npos
556                       : pos &gt;= size()
557                             ? find_last_not_of(v, size() - 1)
558                             : to_pos(std::find_if(const_reverse_iterator(cbegin() + pos + 1), crend(), not_in_view(v)));
559      }
560      nssv_constexpr size_type find_last_not_of(CharT c, size_type pos = npos) const nssv_noexcept 
561      {
562        return find_last_not_of(basic_string_view(&amp;c, 1), pos);
563      }
564      nssv_constexpr size_type find_last_not_of(CharT const *s, size_type pos, size_type count) const 
565      {
566        return find_last_not_of(basic_string_view(s, count), pos);
567      }
568      nssv_constexpr size_type find_last_not_of(CharT const *s, size_type pos = npos) const 
569      {
570        return find_last_not_of(basic_string_view(s), pos);
571      }
572  #if nssv_CPP17_OR_GREATER
573      static nssv_constexpr size_type npos = size_type(-1);
574  #elif nssv_CPP11_OR_GREATER
575      enum : size_type { npos = size_type(-1) };
576  #else
577      enum { npos = size_type(-1) };
578  #endif
579    private:
580      struct not_in_view {
581        const basic_string_view v;
582        nssv_constexpr explicit not_in_view(basic_string_view v) : v(v) {}
583        nssv_constexpr bool operator()(CharT c) const { return npos == v.find_first_of(c); }
584      };
585      nssv_constexpr size_type to_pos(const_iterator it) const { return it == cend() ? npos : size_type(it - cbegin()); }
586      nssv_constexpr size_type to_pos(const_reverse_iterator it) const {
587        return it == crend() ? npos : size_type(crend() - it - 1);
588      }
589      nssv_constexpr const_reference data_at(size_type pos) const {
590  #if nssv_BETWEEN(nssv_COMPILER_GNUC_VERSION, 1, 500)
591        return data_[pos];
592  #else
593        return assert(pos &lt; size()), data_[pos];
594  #endif
595      }
596    private:
597      const_pointer data_;
598      size_type size_;
599    public:
600  #if nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS
601      template &lt;class Allocator&gt;
602      basic_string_view(std::basic_string&lt;CharT, Traits, Allocator&gt; const &amp;s) nssv_noexcept : data_(s.data()),
603                                                                                              size_(s.size()) {}
604  #if nssv_HAVE_EXPLICIT_CONVERSION
605      template &lt;class Allocator&gt; explicit operator std::basic_string&lt;CharT, Traits, Allocator&gt;() const {
606        return to_string(Allocator());
607      }
608  #endif 
609  #if nssv_CPP11_OR_GREATER
610      template &lt;class Allocator = std::allocator&lt;CharT&gt;&gt;
611      std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(Allocator const &amp;a = Allocator()) const {
612        return std::basic_string&lt;CharT, Traits, Allocator&gt;(begin(), end(), a);
613      }
614  #else
615      std::basic_string&lt;CharT, Traits&gt; to_string() const { return std::basic_string&lt;CharT, Traits&gt;(begin(), end()); }
616      template &lt;class Allocator&gt; std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(Allocator const &amp;a) const {
617        return std::basic_string&lt;CharT, Traits, Allocator&gt;(begin(), end(), a);
618      }
619  #endif 
620  #endif 
621    };
622    template &lt;class CharT, class Traits&gt;
623    nssv_constexpr bool operator==(basic_string_view&lt;CharT, Traits&gt; lhs,
624                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
625      return lhs.compare(rhs) == 0;
626    }
627    template &lt;class CharT, class Traits&gt;
628    nssv_constexpr bool operator!=(basic_string_view&lt;CharT, Traits&gt; lhs,
629                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
630      return lhs.compare(rhs) != 0;
631    }
632    template &lt;class CharT, class Traits&gt;
633    nssv_constexpr bool operator&lt;(basic_string_view&lt;CharT, Traits&gt; lhs,
634                                  basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
635      return lhs.compare(rhs) &lt; 0;
636    }
637    template &lt;class CharT, class Traits&gt;
638    nssv_constexpr bool operator&lt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
639                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
640      return lhs.compare(rhs) &lt;= 0;
641    }
642    template &lt;class CharT, class Traits&gt;
643    nssv_constexpr bool operator&gt;(basic_string_view&lt;CharT, Traits&gt; lhs,
644                                  basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
645      return lhs.compare(rhs) &gt; 0;
646    }
647    template &lt;class CharT, class Traits&gt;
648    nssv_constexpr bool operator&gt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
649                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
650      return lhs.compare(rhs) &gt;= 0;
651    }
652  #if !nssv_CPP11_OR_GREATER || nssv_BETWEEN(nssv_COMPILER_MSVC_VERSION, 100, 141)
653    template &lt;class CharT, class Traits&gt;
654    nssv_constexpr bool operator==(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
655      return lhs.compare(rhs) == 0;
656    }
657    template &lt;class CharT, class Traits&gt;
658    nssv_constexpr bool operator==(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
659      return rhs.compare(lhs) == 0;
660    }
661    template &lt;class CharT, class Traits&gt;
662    nssv_constexpr bool operator==(basic_string_view&lt;CharT, Traits&gt; lhs,
663                                   std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
664      return lhs.size() == rhs.size() &amp;&amp; lhs.compare(rhs) == 0;
665    }
666    template &lt;class CharT, class Traits&gt;
667    nssv_constexpr bool operator==(std::basic_string&lt;CharT, Traits&gt; rhs,
668                                   basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
669      return lhs.size() == rhs.size() &amp;&amp; lhs.compare(rhs) == 0;
670    }
671    template &lt;class CharT, class Traits&gt;
672    nssv_constexpr bool operator!=(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
673      return lhs.compare(rhs) != 0;
674    }
675    template &lt;class CharT, class Traits&gt;
676    nssv_constexpr bool operator!=(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
677      return rhs.compare(lhs) != 0;
678    }
679    template &lt;class CharT, class Traits&gt;
680    nssv_constexpr bool operator!=(basic_string_view&lt;CharT, Traits&gt; lhs,
681                                   std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
682      return lhs.size() != rhs.size() &amp;&amp; lhs.compare(rhs) != 0;
683    }
684    template &lt;class CharT, class Traits&gt;
685    nssv_constexpr bool operator!=(std::basic_string&lt;CharT, Traits&gt; rhs,
686                                   basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
687      return lhs.size() != rhs.size() || rhs.compare(lhs) != 0;
688    }
689    template &lt;class CharT, class Traits&gt;
690    nssv_constexpr bool operator&lt;(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
691      return lhs.compare(rhs) &lt; 0;
692    }
693    template &lt;class CharT, class Traits&gt;
694    nssv_constexpr bool operator&lt;(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
695      return rhs.compare(lhs) &gt; 0;
696    }
697    template &lt;class CharT, class Traits&gt;
698    nssv_constexpr bool operator&lt;(basic_string_view&lt;CharT, Traits&gt; lhs,
699                                  std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
700      return lhs.compare(rhs) &lt; 0;
701    }
702    template &lt;class CharT, class Traits&gt;
703    nssv_constexpr bool operator&lt;(std::basic_string&lt;CharT, Traits&gt; rhs,
704                                  basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
705      return rhs.compare(lhs) &gt; 0;
706    }
707    template &lt;class CharT, class Traits&gt;
708    nssv_constexpr bool operator&lt;=(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
709      return lhs.compare(rhs) &lt;= 0;
710    }
711    template &lt;class CharT, class Traits&gt;
712    nssv_constexpr bool operator&lt;=(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
713      return rhs.compare(lhs) &gt;= 0;
714    }
715    template &lt;class CharT, class Traits&gt;
716    nssv_constexpr bool operator&lt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
717                                   std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
718      return lhs.compare(rhs) &lt;= 0;
719    }
720    template &lt;class CharT, class Traits&gt;
721    nssv_constexpr bool operator&lt;=(std::basic_string&lt;CharT, Traits&gt; rhs,
722                                   basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
723      return rhs.compare(lhs) &gt;= 0;
724    }
725    template &lt;class CharT, class Traits&gt;
726    nssv_constexpr bool operator&gt;(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
727      return lhs.compare(rhs) &gt; 0;
728    }
729    template &lt;class CharT, class Traits&gt;
730    nssv_constexpr bool operator&gt;(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
731      return rhs.compare(lhs) &lt; 0;
732    }
733    template &lt;class CharT, class Traits&gt;
734    nssv_constexpr bool operator&gt;(basic_string_view&lt;CharT, Traits&gt; lhs,
735                                  std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
736      return lhs.compare(rhs) &gt; 0;
737    }
738    template &lt;class CharT, class Traits&gt;
739    nssv_constexpr bool operator&gt;(std::basic_string&lt;CharT, Traits&gt; rhs,
740                                  basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
741      return rhs.compare(lhs) &lt; 0;
742    }
743    template &lt;class CharT, class Traits&gt;
744    nssv_constexpr bool operator&gt;=(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
745      return lhs.compare(rhs) &gt;= 0;
746    }
747    template &lt;class CharT, class Traits&gt;
748    nssv_constexpr bool operator&gt;=(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
749      return rhs.compare(lhs) &lt;= 0;
750    }
751    template &lt;class CharT, class Traits&gt;
752    nssv_constexpr bool operator&gt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
753                                   std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
754      return lhs.compare(rhs) &gt;= 0;
755    }
756    template &lt;class CharT, class Traits&gt;
757    nssv_constexpr bool operator&gt;=(std::basic_string&lt;CharT, Traits&gt; rhs,
758                                   basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
759      return rhs.compare(lhs) &lt;= 0;
760    }
761  #else 
762  #define nssv_BASIC_STRING_VIEW_I(T, U) typename std::decay&lt;basic_string_view&lt;T, U&gt;&gt;::type
763  #if nssv_BETWEEN(nssv_COMPILER_MSVC_VERSION, 140, 150)
764  #define nssv_MSVC_ORDER(x) , int = x
765  #else
766  #define nssv_MSVC_ORDER(x) &amp;bsol;*, int=x*/
767  #endif
768    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
769    nssv_constexpr bool operator==(basic_string_view&lt;CharT, Traits&gt; lhs,
770                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
771      return lhs.compare(rhs) == 0;
772    }
773    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
774    nssv_constexpr bool operator==(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
775                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
776      return lhs.size() == rhs.size() &amp;&amp; lhs.compare(rhs) == 0;
777    }
778    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
779    nssv_constexpr bool operator!=(basic_string_view&lt;CharT, Traits&gt; lhs,
780                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
781      return lhs.size() != rhs.size() || lhs.compare(rhs) != 0;
782    }
783    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
784    nssv_constexpr bool operator!=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
785                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
786      return lhs.compare(rhs) != 0;
787    }
788    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
789    nssv_constexpr bool operator&lt;(basic_string_view&lt;CharT, Traits&gt; lhs,
790                                  nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
791      return lhs.compare(rhs) &lt; 0;
792    }
793    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
794    nssv_constexpr bool operator&lt;(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
795                                  basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
796      return lhs.compare(rhs) &lt; 0;
797    }
798    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
799    nssv_constexpr bool operator&lt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
800                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
801      return lhs.compare(rhs) &lt;= 0;
802    }
803    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
804    nssv_constexpr bool operator&lt;=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
805                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
806      return lhs.compare(rhs) &lt;= 0;
807    }
808    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
809    nssv_constexpr bool operator&gt;(basic_string_view&lt;CharT, Traits&gt; lhs,
810                                  nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
811      return lhs.compare(rhs) &gt; 0;
812    }
813    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
814    nssv_constexpr bool operator&gt;(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
815                                  basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
816      return lhs.compare(rhs) &gt; 0;
817    }
818    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
819    nssv_constexpr bool operator&gt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
820                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
821      return lhs.compare(rhs) &gt;= 0;
822    }
823    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
824    nssv_constexpr bool operator&gt;=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
825                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
826      return lhs.compare(rhs) &gt;= 0;
827    }
828  #undef nssv_MSVC_ORDER
829  #undef nssv_BASIC_STRING_VIEW_I
830  #endif 
831    namespace detail {
832    template &lt;class Stream&gt; void write_padding(Stream &amp;os, std::streamsize n) {
833      for (std::streamsize i = 0; i &lt; n; ++i)
834        os.rdbuf()-&gt;sputc(os.fill());
835    }
836    template &lt;class Stream, class View&gt; Stream &amp;write_to_stream(Stream &amp;os, View const &amp;sv) {
837      typename Stream::sentry sentry(os);
838      if (!os)
839        return os;
840      const std::streamsize length = static_cast&lt;std::streamsize&gt;(sv.length());
841      const bool pad = (length &lt; os.width());
842      const bool left_pad = pad &amp;&amp; (os.flags() &amp; std::ios_base::adjustfield) == std::ios_base::right;
843      if (left_pad)
844        write_padding(os, os.width() - length);
845      os.rdbuf()-&gt;sputn(sv.begin(), length);
846      if (pad &amp;&amp; !left_pad)
847        write_padding(os, os.width() - length);
848      os.width(0);
849      return os;
850    }
851    } 
852    template &lt;class CharT, class Traits&gt;
853    std::basic_ostream&lt;CharT, Traits&gt; &amp;operator&lt;&lt;(std::basic_ostream&lt;CharT, Traits&gt; &amp;os,
854                                                  basic_string_view&lt;CharT, Traits&gt; sv) {
855      return detail::write_to_stream(os, sv);
856    }
857    typedef basic_string_view&lt;char&gt; string_view;
858    typedef basic_string_view&lt;wchar_t&gt; wstring_view;
859  #if nssv_HAVE_WCHAR16_T
860    typedef basic_string_view&lt;char16_t&gt; u16string_view;
861    typedef basic_string_view&lt;char32_t&gt; u32string_view;
862  #endif
863    } 
864  } 
865  #if nssv_HAVE_USER_DEFINED_LITERALS
866  namespace nonstd {
867  nssv_inline_ns namespace literals {
868    nssv_inline_ns namespace string_view_literals {
869  #if nssv_CONFIG_STD_SV_OPERATOR &amp;&amp; nssv_HAVE_STD_DEFINED_LITERALS
870      nssv_constexpr nonstd::sv_lite::string_view operator&quot;&quot; sv(const char *str, size_t len) nssv_noexcept 
871      {
872        return nonstd::sv_lite::string_view {str, len};
873      }
874      nssv_constexpr nonstd::sv_lite::u16string_view operator&quot;&quot; sv(const char16_t *str, size_t len) nssv_noexcept 
875      {
876        return nonstd::sv_lite::u16string_view {str, len};
877      }
878      nssv_constexpr nonstd::sv_lite::u32string_view operator&quot;&quot; sv(const char32_t *str, size_t len) nssv_noexcept 
879      {
880        return nonstd::sv_lite::u32string_view {str, len};
881      }
882      nssv_constexpr nonstd::sv_lite::wstring_view operator&quot;&quot; sv(const wchar_t *str, size_t len) nssv_noexcept 
883      {
884        return nonstd::sv_lite::wstring_view {str, len};
885      }
886  #endif 
887  #if nssv_CONFIG_USR_SV_OPERATOR
888      nssv_constexpr nonstd::sv_lite::string_view operator&quot;&quot; _sv(const char *str, size_t len) nssv_noexcept 
889      {
890        return nonstd::sv_lite::string_view {str, len};
891      }
892      nssv_constexpr nonstd::sv_lite::u16string_view operator&quot;&quot; _sv(const char16_t *str, size_t len) nssv_noexcept 
893      {
894        return nonstd::sv_lite::u16string_view {str, len};
895      }
896      nssv_constexpr nonstd::sv_lite::u32string_view operator&quot;&quot; _sv(const char32_t *str, size_t len) nssv_noexcept 
897      {
898        return nonstd::sv_lite::u32string_view {str, len};
899      }
900      nssv_constexpr nonstd::sv_lite::wstring_view operator&quot;&quot; _sv(const wchar_t *str, size_t len) nssv_noexcept 
901      {
902        return nonstd::sv_lite::wstring_view {str, len};
903      }
904  #endif 
905    }
906  }
907  } 
908  #endif
909  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
910  namespace nonstd {
911  namespace sv_lite {
912  #if nssv_CPP11_OR_GREATER &amp;&amp; nssv_COMPILER_MSVC_VERSION != 140
913  template &lt;class CharT, class Traits, class Allocator = std::allocator&lt;CharT&gt;&gt;
914  std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(basic_string_view&lt;CharT, Traits&gt; v,
915                                                        Allocator const &amp;a = Allocator()) {
916    return std::basic_string&lt;CharT, Traits, Allocator&gt;(v.begin(), v.end(), a);
917  }
918  #else
919  template &lt;class CharT, class Traits&gt; std::basic_string&lt;CharT, Traits&gt; to_string(basic_string_view&lt;CharT, Traits&gt; v) {
920    return std::basic_string&lt;CharT, Traits&gt;(v.begin(), v.end());
921  }
922  template &lt;class CharT, class Traits, class Allocator&gt;
923  std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(basic_string_view&lt;CharT, Traits&gt; v, Allocator const &amp;a) {
924    return std::basic_string&lt;CharT, Traits, Allocator&gt;(v.begin(), v.end(), a);
925  }
926  #endif 
927  template &lt;class CharT, class Traits, class Allocator&gt;
928  basic_string_view&lt;CharT, Traits&gt; to_string_view(std::basic_string&lt;CharT, Traits, Allocator&gt; const &amp;s) {
929    return basic_string_view&lt;CharT, Traits&gt;(s.data(), s.size());
930  }
931  } 
932  } 
933  #endif 
934  namespace nonstd {
935  using sv_lite::basic_string_view;
936  using sv_lite::string_view;
937  using sv_lite::wstring_view;
938  #if nssv_HAVE_WCHAR16_T
939  using sv_lite::u16string_view;
940  #endif
941  #if nssv_HAVE_WCHAR32_T
942  using sv_lite::u32string_view;
943  #endif
944  using sv_lite::operator==;
945  using sv_lite::operator!=;
946  using sv_lite::operator&lt;;
947  using sv_lite::operator&lt;=;
948  using sv_lite::operator&gt;;
949  using sv_lite::operator&gt;=;
950  using sv_lite::operator&lt;&lt;;
951  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
952  using sv_lite::to_string;
953  using sv_lite::to_string_view;
954  #endif
955  } 
956  #if nssv_HAVE_STD_HASH
957  #include &lt;functional&gt;
958  namespace std {
959  template &lt;&gt; struct hash&lt;nonstd::string_view&gt; {
960  public:
961    std::size_t operator()(nonstd::string_view v) const nssv_noexcept {
962      return std::hash&lt;std::string&gt;()(std::string(v.data(), v.size()));
963    }
964  };
965  template &lt;&gt; struct hash&lt;nonstd::wstring_view&gt; {
966  public:
967    std::size_t operator()(nonstd::wstring_view v) const nssv_noexcept {
968      return std::hash&lt;std::wstring&gt;()(std::wstring(v.data(), v.size()));
969    }
970  };
971  template &lt;&gt; struct hash&lt;nonstd::u16string_view&gt; {
972  public:
973    std::size_t operator()(nonstd::u16string_view v) const nssv_noexcept {
974      return std::hash&lt;std::u16string&gt;()(std::u16string(v.data(), v.size()));
975    }
976  };
977  template &lt;&gt; struct hash&lt;nonstd::u32string_view&gt; {
978  public:
979    std::size_t operator()(nonstd::u32string_view v) const nssv_noexcept {
980      return std::hash&lt;std::u32string&gt;()(std::u32string(v.data(), v.size()));
981    }
982  };
983  } 
984  #endif 
985  nssv_RESTORE_WARNINGS()
986  #endif 
987  #endif 
988  #ifndef INCLUDE_INJA_TEMPLATE_HPP_
989  #define INCLUDE_INJA_TEMPLATE_HPP_
990  #include &lt;map&gt;
991  #include &lt;memory&gt;
992  #include &lt;string&gt;
993  #include &lt;vector&gt;
994  #ifndef INCLUDE_INJA_NODE_HPP_
995  #define INCLUDE_INJA_NODE_HPP_
996  #include &lt;string&gt;
997  #include &lt;utility&gt;
998  #ifndef INCLUDE_INJA_FUNCTION_STORAGE_HPP_
999  #define INCLUDE_INJA_FUNCTION_STORAGE_HPP_
1000  #include &lt;vector&gt;
1001  namespace inja {
1002  using Arguments = std::vector&lt;const json *&gt;;
1003  using CallbackFunction = std::function&lt;json(Arguments &amp;args)&gt;;
1004  using VoidCallbackFunction = std::function&lt;void(Arguments &amp;args)&gt;;
1005  class FunctionStorage {
1006  public:
1007    enum class Operation {
1008      Not,
1009      And,
1010      Or,
1011      In,
1012      Equal,
1013      NotEqual,
1014      Greater,
1015      GreaterEqual,
1016      Less,
1017      LessEqual,
1018      Add,
1019      Subtract,
1020      Multiplication,
1021      Division,
1022      Power,
1023      Modulo,
1024      AtId,
1025      At,
1026      Default,
1027      DivisibleBy,
1028      Even,
1029      Exists,
1030      ExistsInObject,
1031      First,
1032      Float,
1033      Int,
1034      IsArray,
1035      IsBoolean,
1036      IsFloat,
1037      IsInteger,
1038      IsNumber,
1039      IsObject,
1040      IsString,
1041      Last,
1042      Length,
1043      Lower,
1044      Max,
1045      Min,
1046      Odd,
1047      Range,
1048      Round,
1049      Sort,
1050      Upper,
1051      Super,
1052      Join,
1053      Callback,
1054      ParenLeft,
1055      ParenRight,
1056      None,
1057    };
1058    struct FunctionData {
1059      explicit FunctionData(const Operation &amp;op, const CallbackFunction &amp;cb = CallbackFunction{}) : operation(op), callback(cb) {}
1060      const Operation operation;
1061      const CallbackFunction callback;
1062    };
1063  private:
1064    const int VARIADIC {-1};
1065    std::map&lt;std::pair&lt;std::string, int&gt;, FunctionData&gt; function_storage = {
1066      {std::make_pair(&quot;at&quot;, 2), FunctionData { Operation::At }},
1067      {std::make_pair(&quot;default&quot;, 2), FunctionData { Operation::Default }},
1068      {std::make_pair(&quot;divisibleBy&quot;, 2), FunctionData { Operation::DivisibleBy }},
1069      {std::make_pair(&quot;even&quot;, 1), FunctionData { Operation::Even }},
1070      {std::make_pair(&quot;exists&quot;, 1), FunctionData { Operation::Exists }},
1071      {std::make_pair(&quot;existsIn&quot;, 2), FunctionData { Operation::ExistsInObject }},
1072      {std::make_pair(&quot;first&quot;, 1), FunctionData { Operation::First }},
1073      {std::make_pair(&quot;float&quot;, 1), FunctionData { Operation::Float }},
1074      {std::make_pair(&quot;int&quot;, 1), FunctionData { Operation::Int }},
1075      {std::make_pair(&quot;isArray&quot;, 1), FunctionData { Operation::IsArray }},
1076      {std::make_pair(&quot;isBoolean&quot;, 1), FunctionData { Operation::IsBoolean }},
1077      {std::make_pair(&quot;isFloat&quot;, 1), FunctionData { Operation::IsFloat }},
1078      {std::make_pair(&quot;isInteger&quot;, 1), FunctionData { Operation::IsInteger }},
1079      {std::make_pair(&quot;isNumber&quot;, 1), FunctionData { Operation::IsNumber }},
1080      {std::make_pair(&quot;isObject&quot;, 1), FunctionData { Operation::IsObject }},
1081      {std::make_pair(&quot;isString&quot;, 1), FunctionData { Operation::IsString }},
1082      {std::make_pair(&quot;last&quot;, 1), FunctionData { Operation::Last }},
1083      {std::make_pair(&quot;length&quot;, 1), FunctionData { Operation::Length }},
1084      {std::make_pair(&quot;lower&quot;, 1), FunctionData { Operation::Lower }},
1085      {std::make_pair(&quot;max&quot;, 1), FunctionData { Operation::Max }},
1086      {std::make_pair(&quot;min&quot;, 1), FunctionData { Operation::Min }},
1087      {std::make_pair(&quot;odd&quot;, 1), FunctionData { Operation::Odd }},
1088      {std::make_pair(&quot;range&quot;, 1), FunctionData { Operation::Range }},
1089      {std::make_pair(&quot;round&quot;, 2), FunctionData { Operation::Round }},
1090      {std::make_pair(&quot;sort&quot;, 1), FunctionData { Operation::Sort }},
1091      {std::make_pair(&quot;upper&quot;, 1), FunctionData { Operation::Upper }},
1092      {std::make_pair(&quot;super&quot;, 0), FunctionData { Operation::Super }},
1093      {std::make_pair(&quot;super&quot;, 1), FunctionData { Operation::Super }},
1094      {std::make_pair(&quot;join&quot;, 2), FunctionData { Operation::Join }},
1095    };
1096  public:
1097    void add_builtin(nonstd::string_view name, int num_args, Operation op) {
1098      function_storage.emplace(std::make_pair(static_cast&lt;std::string&gt;(name), num_args), FunctionData { op });
1099    }
1100    void add_callback(nonstd::string_view name, int num_args, const CallbackFunction &amp;callback) {
1101      function_storage.emplace(std::make_pair(static_cast&lt;std::string&gt;(name), num_args), FunctionData { Operation::Callback, callback });
1102    }
1103    FunctionData find_function(nonstd::string_view name, int num_args) const {
1104      auto it = function_storage.find(std::make_pair(static_cast&lt;std::string&gt;(name), num_args));
1105      if (it != function_storage.end()) {
1106        return it-&gt;second;
1107      } else if (num_args &gt; 0) {
1108        it = function_storage.find(std::make_pair(static_cast&lt;std::string&gt;(name), VARIADIC));
1109        if (it != function_storage.end()) {
1110          return it-&gt;second;
1111        }
1112      }
1113      return FunctionData { Operation::None };
1114    }
1115  };
1116  } 
1117  #endif 
1118  #ifndef INCLUDE_INJA_UTILS_HPP_
1119  #define INCLUDE_INJA_UTILS_HPP_
1120  #include &lt;algorithm&gt;
1121  #include &lt;fstream&gt;
1122  #include &lt;string&gt;
1123  #include &lt;utility&gt;
1124  #ifndef INCLUDE_INJA_EXCEPTIONS_HPP_
1125  #define INCLUDE_INJA_EXCEPTIONS_HPP_
1126  #include &lt;stdexcept&gt;
1127  #include &lt;string&gt;
1128  namespace inja {
1129  struct SourceLocation {
1130    size_t line;
1131    size_t column;
1132  };
1133  struct InjaError : public std::runtime_error {
1134    const std::string type;
1135    const std::string message;
1136    const SourceLocation location;
1137    explicit InjaError(const std::string &amp;type, const std::string &amp;message)
1138        : std::runtime_error(&quot;[inja.exception.&quot; + type + &quot;] &quot; + message), type(type), message(message), location({0, 0}) {}
1139    explicit InjaError(const std::string &amp;type, const std::string &amp;message, SourceLocation location)
1140        : std::runtime_error(&quot;[inja.exception.&quot; + type + &quot;] (at &quot; + std::to_string(location.line) + &quot;:&quot; +
1141                             std::to_string(location.column) + &quot;) &quot; + message),
1142          type(type), message(message), location(location) {}
1143  };
1144  struct ParserError : public InjaError {
1145    explicit ParserError(const std::string &amp;message, SourceLocation location) : InjaError(&quot;parser_error&quot;, message, location) {}
1146  };
1147  struct RenderError : public InjaError {
1148    explicit RenderError(const std::string &amp;message, SourceLocation location) : InjaError(&quot;render_error&quot;, message, location) {}
1149  };
1150  struct FileError : public InjaError {
1151    explicit FileError(const std::string &amp;message) : InjaError(&quot;file_error&quot;, message) {}
1152    explicit FileError(const std::string &amp;message, SourceLocation location) : InjaError(&quot;file_error&quot;, message, location) {}
1153  };
1154  struct JsonError : public InjaError {
1155    explicit JsonError(const std::string &amp;message, SourceLocation location) : InjaError(&quot;json_error&quot;, message, location) {}
1156  };
1157  } 
1158  #endif 
1159  namespace inja {
1160  namespace string_view {
1161  inline nonstd::string_view slice(nonstd::string_view view, size_t start, size_t end) {
1162    start = std::min(start, view.size());
1163    end = std::min(std::max(start, end), view.size());
1164    return view.substr(start, end - start);
1165  }
1166  inline std::pair&lt;nonstd::string_view, nonstd::string_view&gt; split(nonstd::string_view view, char Separator) {
1167    size_t idx = view.find(Separator);
1168    if (idx == nonstd::string_view::npos) {
1169      return std::make_pair(view, nonstd::string_view());
1170    }
1171    return std::make_pair(slice(view, 0, idx), slice(view, idx + 1, nonstd::string_view::npos));
1172  }
1173  inline bool starts_with(nonstd::string_view view, nonstd::string_view prefix) {
1174    return (view.size() &gt;= prefix.size() &amp;&amp; view.compare(0, prefix.size(), prefix) == 0);
1175  }
1176  } 
1177  inline SourceLocation get_source_location(nonstd::string_view content, size_t pos) {
1178    auto sliced = string_view::slice(content, 0, pos);
1179    std::size_t last_newline = sliced.rfind(&quot;\n&quot;);
1180    if (last_newline == nonstd::string_view::npos) {
1181      return {1, sliced.length() + 1};
1182    }
1183    size_t count_lines = 0;
1184    size_t search_start = 0;
1185    while (search_start &lt;= sliced.size()) {
1186      search_start = sliced.find(&quot;\n&quot;, search_start) + 1;
1187      if (search_start == 0) {
1188        break;
1189      }
1190      count_lines += 1;
1191    }
1192    return {count_lines + 1, sliced.length() - last_newline};
1193  }
1194  inline void replace_substring(std::string&amp; s, const std::string&amp; f,
1195                                const std::string&amp; t)
1196  {
1197    if (f.empty()) return;
1198    for (auto pos = s.find(f);                  
1199              pos != std::string::npos;         
1200              s.replace(pos, f.size(), t),      
1201              pos = s.find(f, pos + t.size()))  
1202    {}
1203  }
1204  } 
1205  #endif 
1206  namespace inja {
1207  class NodeVisitor;
1208  class BlockNode;
1209  class TextNode;
1210  class ExpressionNode;
1211  class LiteralNode;
1212  class JsonNode;
1213  class FunctionNode;
1214  class ExpressionListNode;
1215  class StatementNode;
1216  class ForStatementNode;
1217  class ForArrayStatementNode;
1218  class ForObjectStatementNode;
1219  class IfStatementNode;
1220  class IncludeStatementNode;
1221  class ExtendsStatementNode;
1222  class BlockStatementNode;
1223  class SetStatementNode;
1224  class NodeVisitor {
1225  public:
1226    virtual ~NodeVisitor() = default;
1227    virtual void visit(const BlockNode&amp; node) = 0;
1228    virtual void visit(const TextNode&amp; node) = 0;
1229    virtual void visit(const ExpressionNode&amp; node) = 0;
1230    virtual void visit(const LiteralNode&amp; node) = 0;
1231    virtual void visit(const JsonNode&amp; node) = 0;
1232    virtual void visit(const FunctionNode&amp; node) = 0;
1233    virtual void visit(const ExpressionListNode&amp; node) = 0;
1234    virtual void visit(const StatementNode&amp; node) = 0;
1235    virtual void visit(const ForStatementNode&amp; node) = 0;
1236    virtual void visit(const ForArrayStatementNode&amp; node) = 0;
1237    virtual void visit(const ForObjectStatementNode&amp; node) = 0;
1238    virtual void visit(const IfStatementNode&amp; node) = 0;
1239    virtual void visit(const IncludeStatementNode&amp; node) = 0;
1240    virtual void visit(const ExtendsStatementNode&amp; node) = 0;
1241    virtual void visit(const BlockStatementNode&amp; node) = 0;
1242    virtual void visit(const SetStatementNode&amp; node) = 0;
1243  };
1244  class AstNode {
1245  public:
1246    virtual void accept(NodeVisitor&amp; v) const = 0;
1247    size_t pos;
1248    AstNode(size_t pos) : pos(pos) { }
1249    virtual ~AstNode() { }
1250  };
1251  class BlockNode : public AstNode {
1252  public:
1253    std::vector&lt;std::shared_ptr&lt;AstNode&gt;&gt; nodes;
1254    explicit BlockNode() : AstNode(0) {}
1255    void accept(NodeVisitor&amp; v) const {
1256      v.visit(*this);
1257    }
1258  };
1259  class TextNode : public AstNode {
1260  public:
1261    const size_t length;
1262    explicit TextNode(size_t pos, size_t length): AstNode(pos), length(length) { }
1263    void accept(NodeVisitor&amp; v) const {
1264      v.visit(*this);
1265    }
1266  };
1267  class ExpressionNode : public AstNode {
1268  public:
1269    explicit ExpressionNode(size_t pos) : AstNode(pos) {}
1270    void accept(NodeVisitor&amp; v) const {
1271      v.visit(*this);
1272    }
1273  };
1274  class LiteralNode : public ExpressionNode {
1275  public:
1276    const json value;
1277    explicit LiteralNode(const json&amp; value, size_t pos) : ExpressionNode(pos), value(value) { }
1278    void accept(NodeVisitor&amp; v) const {
1279      v.visit(*this);
1280    }
1281  };
1282  class JsonNode : public ExpressionNode {
1283  public:
1284    const std::string name;
1285    const json::json_pointer ptr;
1286    static std::string convert_dot_to_json_ptr(nonstd::string_view ptr_name) {
1287      std::string result;
1288      do {
1289        nonstd::string_view part;
1290        std::tie(part, ptr_name) = string_view::split(ptr_name, &#x27;.&#x27;);
1291        result.push_back(&#x27;/&#x27;);
1292        result.append(part.begin(), part.end());
1293      } while (!ptr_name.empty());
1294      return result;
1295    }
1296    explicit JsonNode(nonstd::string_view ptr_name, size_t pos) : ExpressionNode(pos), name(ptr_name), ptr(json::json_pointer(convert_dot_to_json_ptr(ptr_name))) { }
1297    void accept(NodeVisitor&amp; v) const {
1298      v.visit(*this);
1299    }
1300  };
1301  class FunctionNode : public ExpressionNode {
1302    using Op = FunctionStorage::Operation;
1303  public:
1304    enum class Associativity {
1305      Left,
1306      Right,
1307    };
1308    unsigned int precedence;
1309    Associativity associativity;
1310    Op operation;
1311    std::string name;
1312    int number_args; 
1313    std::vector&lt;std::shared_ptr&lt;ExpressionNode&gt;&gt; arguments;
1314    CallbackFunction callback;
1315    explicit FunctionNode(nonstd::string_view name, size_t pos) : ExpressionNode(pos), precedence(8), associativity(Associativity::Left), operation(Op::Callback), name(name), number_args(1) { }
1316    explicit FunctionNode(Op operation, size_t pos) : ExpressionNode(pos), operation(operation), number_args(1) {
1317      switch (operation) {
1318        case Op::Not: {
1319          number_args = 1;
1320          precedence = 4;
1321          associativity = Associativity::Left;
1322        } break;
1323        case Op::And: {
1324          number_args = 2;
1325          precedence = 1;
1326          associativity = Associativity::Left;
1327        } break;
1328        case Op::Or: {
1329          number_args = 2;
1330          precedence = 1;
1331          associativity = Associativity::Left;
1332        } break;
1333        case Op::In: {
1334          number_args = 2;
1335          precedence = 2;
1336          associativity = Associativity::Left;
1337        } break;
1338        case Op::Equal: {
1339          number_args = 2;
1340          precedence = 2;
1341          associativity = Associativity::Left;
1342        } break;
1343        case Op::NotEqual: {
1344          number_args = 2;
1345          precedence = 2;
1346          associativity = Associativity::Left;
1347        } break;
1348        case Op::Greater: {
1349          number_args = 2;
1350          precedence = 2;
1351          associativity = Associativity::Left;
1352        } break;
1353        case Op::GreaterEqual: {
1354          number_args = 2;
1355          precedence = 2;
1356          associativity = Associativity::Left;
1357        } break;
1358        case Op::Less: {
1359          number_args = 2;
1360          precedence = 2;
1361          associativity = Associativity::Left;
1362        } break;
1363        case Op::LessEqual: {
1364          number_args = 2;
1365          precedence = 2;
1366          associativity = Associativity::Left;
1367        } break;
1368        case Op::Add: {
1369          number_args = 2;
1370          precedence = 3;
1371          associativity = Associativity::Left;
1372        } break;
1373        case Op::Subtract: {
1374          number_args = 2;
1375          precedence = 3;
1376          associativity = Associativity::Left;
1377        } break;
1378        case Op::Multiplication: {
1379          number_args = 2;
1380          precedence = 4;
1381          associativity = Associativity::Left;
1382        } break;
1383        case Op::Division: {
1384          number_args = 2;
1385          precedence = 4;
1386          associativity = Associativity::Left;
1387        } break;
1388        case Op::Power: {
1389          number_args = 2;
1390          precedence = 5;
1391          associativity = Associativity::Right;
1392        } break;
1393        case Op::Modulo: {
1394          number_args = 2;
1395          precedence = 4;
1396          associativity = Associativity::Left;
1397        } break;
1398        case Op::AtId: {
1399          number_args = 2;
1400          precedence = 8;
1401          associativity = Associativity::Left;
1402        } break;
1403        default: {
1404          precedence = 1;
1405          associativity = Associativity::Left;
1406        }
1407      }
1408    }
1409    void accept(NodeVisitor&amp; v) const {
1410      v.visit(*this);
1411    }
1412  };
1413  class ExpressionListNode : public AstNode {
1414  public:
1415    std::shared_ptr&lt;ExpressionNode&gt; root;
1416    explicit ExpressionListNode() : AstNode(0) { }
1417    explicit ExpressionListNode(size_t pos) : AstNode(pos) { }
1418    void accept(NodeVisitor&amp; v) const {
1419      v.visit(*this);
1420    }
1421  };
1422  class StatementNode : public AstNode {
1423  public:
1424    StatementNode(size_t pos) : AstNode(pos) { }
1425    virtual void accept(NodeVisitor&amp; v) const = 0;
1426  };
1427  class ForStatementNode : public StatementNode {
1428  public:
1429    ExpressionListNode condition;
1430    BlockNode body;
1431    BlockNode *const parent;
1432    ForStatementNode(BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent) { }
1433    virtual void accept(NodeVisitor&amp; v) const = 0;
1434  };
1435  class ForArrayStatementNode : public ForStatementNode {
1436  public:
1437    const std::string value;
1438    explicit ForArrayStatementNode(const std::string&amp; value, BlockNode *const parent, size_t pos) : ForStatementNode(parent, pos), value(value) { }
1439    void accept(NodeVisitor&amp; v) const {
1440      v.visit(*this);
1441    }
1442  };
1443  class ForObjectStatementNode : public ForStatementNode {
1444  public:
1445    const std::string key;
1446    const std::string value;
1447    explicit ForObjectStatementNode(const std::string&amp; key, const std::string&amp; value, BlockNode *const parent, size_t pos) : ForStatementNode(parent, pos), key(key), value(value) { }
1448    void accept(NodeVisitor&amp; v) const {
1449      v.visit(*this);
1450    }
1451  };
1452  class IfStatementNode : public StatementNode {
1453  public:
1454    ExpressionListNode condition;
1455    BlockNode true_statement;
1456    BlockNode false_statement;
1457    BlockNode *const parent;
1458    const bool is_nested;
1459    bool has_false_statement {false};
1460    explicit IfStatementNode(BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent), is_nested(false) { }
1461    explicit IfStatementNode(bool is_nested, BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent), is_nested(is_nested) { }
1462    void accept(NodeVisitor&amp; v) const {
1463      v.visit(*this);
1464    }
1465  };
1466  class IncludeStatementNode : public StatementNode {
1467  public:
1468    const std::string file;
1469    explicit IncludeStatementNode(const std::string&amp; file, size_t pos) : StatementNode(pos), file(file) { }
1470    void accept(NodeVisitor&amp; v) const {
1471      v.visit(*this);
1472    }
1473  };
1474  class ExtendsStatementNode : public StatementNode {
1475  public:
1476    const std::string file;
1477    explicit ExtendsStatementNode(const std::string&amp; file, size_t pos) : StatementNode(pos), file(file) { }
1478    void accept(NodeVisitor&amp; v) const {
1479      v.visit(*this);
1480    };
1481  };
1482  class BlockStatementNode : public StatementNode {
1483  public:
1484    const std::string name;
1485    BlockNode block;
1486    BlockNode *const parent;
1487    explicit BlockStatementNode(BlockNode *const parent, const std::string&amp; name, size_t pos) : StatementNode(pos), name(name), parent(parent) { }
1488    void accept(NodeVisitor&amp; v) const {
1489      v.visit(*this);
1490    };
1491  };
1492  class SetStatementNode : public StatementNode {
1493  public:
1494    const std::string key;
1495    ExpressionListNode expression;
1496    explicit SetStatementNode(const std::string&amp; key, size_t pos) : StatementNode(pos), key(key) { }
1497    void accept(NodeVisitor&amp; v) const {
1498      v.visit(*this);
1499    }
1500  };
1501  } 
1502  #endif 
1503  #ifndef INCLUDE_INJA_STATISTICS_HPP_
1504  #define INCLUDE_INJA_STATISTICS_HPP_
1505  namespace inja {
1506  class StatisticsVisitor : public NodeVisitor {
1507    void visit(const BlockNode&amp; node) {
1508      for (auto&amp; n : node.nodes) {
1509        n-&gt;accept(*this);
1510      }
1511    }
1512    void visit(const TextNode&amp;) { }
1513    void visit(const ExpressionNode&amp;) { }
1514    void visit(const LiteralNode&amp;) { }
1515    void visit(const JsonNode&amp;) {
1516      variable_counter += 1;
1517    }
1518    void visit(const FunctionNode&amp; node) {
1519      for (auto&amp; n : node.arguments) {
1520        n-&gt;accept(*this);
1521      }
1522    }
1523    void visit(const ExpressionListNode&amp; node) {
1524      node.root-&gt;accept(*this);
1525    }
1526    void visit(const StatementNode&amp;) { }
1527    void visit(const ForStatementNode&amp;) { }
1528    void visit(const ForArrayStatementNode&amp; node) {
1529      node.condition.accept(*this);
1530      node.body.accept(*this);
1531    }
1532    void visit(const ForObjectStatementNode&amp; node) {
1533      node.condition.accept(*this);
1534      node.body.accept(*this);
1535    }
1536    void visit(const IfStatementNode&amp; node) {
1537      node.condition.accept(*this);
1538      node.true_statement.accept(*this);
1539      node.false_statement.accept(*this);
1540    }
1541    void visit(const IncludeStatementNode&amp;) { }
1542    void visit(const ExtendsStatementNode&amp;) { }
1543    void visit(const BlockStatementNode&amp; node) {
1544      node.block.accept(*this);
1545    }
1546    void visit(const SetStatementNode&amp;) { }
1547  public:
1548    unsigned int variable_counter;
1549    explicit StatisticsVisitor() : variable_counter(0) { }
1550  };
1551  } 
1552  #endif 
1553  namespace inja {
1554  struct Template {
1555    BlockNode root;
1556    std::string content;
1557    std::map&lt;std::string, std::shared_ptr&lt;BlockStatementNode&gt;&gt; block_storage;
1558    explicit Template() { }
1559    explicit Template(const std::string&amp; content): content(content) { }
1560    int count_variables() {
1561      auto statistic_visitor = StatisticsVisitor();
1562      root.accept(statistic_visitor);
1563      return statistic_visitor.variable_counter;
1564    }
1565  };
1566  using TemplateStorage = std::map&lt;std::string, Template&gt;;
1567  } 
1568  #endif 
1569  namespace inja {
1570  struct LexerConfig {
1571    std::string statement_open {&quot;{%&quot;};
1572    std::string statement_open_no_lstrip {&quot;{%+&quot;};
1573    std::string statement_open_force_lstrip {&quot;{%-&quot;};
1574    std::string statement_close {&quot;%}&quot;};
1575    std::string statement_close_force_rstrip {&quot;-%}&quot;};
1576    std::string line_statement {&quot;##&quot;};
1577    std::string expression_open {&quot;{{&quot;};
1578    std::string expression_open_force_lstrip {&quot;{{-&quot;};
1579    std::string expression_close {&quot;}}&quot;};
1580    std::string expression_close_force_rstrip {&quot;-}}&quot;};
1581    std::string comment_open {&quot;{#&quot;};
1582    std::string comment_open_force_lstrip {&quot;{#-&quot;};
1583    std::string comment_close {&quot;#}&quot;};
1584    std::string comment_close_force_rstrip {&quot;-#}&quot;};
1585    std::string open_chars {&quot;#{&quot;};
1586    bool trim_blocks {false};
1587    bool lstrip_blocks {false};
1588    void update_open_chars() {
1589      open_chars = &quot;&quot;;
1590      if (open_chars.find(line_statement[0]) == std::string::npos) {
1591        open_chars += line_statement[0];
1592      }
1593      if (open_chars.find(statement_open[0]) == std::string::npos) {
1594        open_chars += statement_open[0];
1595      }
1596      if (open_chars.find(statement_open_no_lstrip[0]) == std::string::npos) {
1597        open_chars += statement_open_no_lstrip[0];
1598      }
1599      if (open_chars.find(statement_open_force_lstrip[0]) == std::string::npos) {
1600        open_chars += statement_open_force_lstrip[0];
1601      }
1602      if (open_chars.find(expression_open[0]) == std::string::npos) {
1603        open_chars += expression_open[0];
1604      }
1605      if (open_chars.find(expression_open_force_lstrip[0]) == std::string::npos) {
1606        open_chars += expression_open_force_lstrip[0];
1607      }
1608      if (open_chars.find(comment_open[0]) == std::string::npos) {
1609        open_chars += comment_open[0];
1610      }
1611      if (open_chars.find(comment_open_force_lstrip[0]) == std::string::npos) {
1612        open_chars += comment_open_force_lstrip[0];
1613      }
1614    }
1615  };
1616  struct ParserConfig {
1617    bool search_included_templates_in_files {true};
1618    std::function&lt;Template(const std::string&amp;, const std::string&amp;)&gt; include_callback;
1619  };
1620  struct RenderConfig {
1621    bool throw_at_missing_includes {true};
1622  };
1623  } 
1624  #endif 
1625  #ifndef INCLUDE_INJA_PARSER_HPP_
1626  #define INCLUDE_INJA_PARSER_HPP_
1627  #include &lt;limits&gt;
1628  #include &lt;stack&gt;
1629  #include &lt;string&gt;
1630  #include &lt;utility&gt;
1631  #include &lt;queue&gt;
1632  #include &lt;vector&gt;
1633  #ifndef INCLUDE_INJA_LEXER_HPP_
1634  #define INCLUDE_INJA_LEXER_HPP_
1635  #include &lt;cctype&gt;
1636  #include &lt;locale&gt;
1637  #ifndef INCLUDE_INJA_TOKEN_HPP_
1638  #define INCLUDE_INJA_TOKEN_HPP_
1639  #include &lt;string&gt;
1640  namespace inja {
1641  struct Token {
1642    enum class Kind {
1643      Text,
1644      ExpressionOpen,     
1645      ExpressionClose,    
1646      LineStatementOpen,  
1647      LineStatementClose, 
1648      StatementOpen,      
1649      StatementClose,     
1650      CommentOpen,        
1651      CommentClose,       
1652      Id,                 
1653      Number,             
1654      String,             
1655      Plus,               
1656      Minus,              
1657      Times,              
1658      Slash,              
1659      Percent,            
1660      Power,              
1661      Comma,              
1662      Dot,                
1663      Colon,              
1664      LeftParen,          
1665      RightParen,         
1666      LeftBracket,        
1667      RightBracket,       
1668      LeftBrace,          
1669      RightBrace,         
1670      Equal,              
1671      NotEqual,           
1672      GreaterThan,        
1673      GreaterEqual,       
1674      LessThan,           
1675      LessEqual,          
1676      Unknown,
1677      Eof,
1678    };
1679    Kind kind {Kind::Unknown};
1680    nonstd::string_view text;
1681    explicit constexpr Token() = default;
1682    explicit constexpr Token(Kind kind, nonstd::string_view text) : kind(kind), text(text) {}
1683    std::string describe() const {
1684      switch (kind) {
1685      case Kind::Text:
1686        return &quot;&lt;text&gt;&quot;;
1687      case Kind::LineStatementClose:
1688        return &quot;&lt;eol&gt;&quot;;
1689      case Kind::Eof:
1690        return &quot;&lt;eof&gt;&quot;;
1691      default:
1692        return static_cast&lt;std::string&gt;(text);
1693      }
1694    }
1695  };
1696  } 
1697  #endif 
1698  namespace inja {
1699  class Lexer {
1700    enum class State {
1701      Text,
1702      ExpressionStart,
1703      ExpressionStartForceLstrip,
1704      ExpressionBody,
1705      LineStart,
1706      LineBody,
1707      StatementStart,
1708      StatementStartNoLstrip,
1709      StatementStartForceLstrip,
1710      StatementBody,
1711      CommentStart,
1712      CommentStartForceLstrip,
1713      CommentBody,
1714    };
1715    enum class MinusState {
1716      Operator,
1717      Number,
1718    };
1719    const LexerConfig &amp;config;
1720    State state;
1721    MinusState minus_state;
1722    nonstd::string_view m_in;
1723    size_t tok_start;
1724    size_t pos;
1725    Token scan_body(nonstd::string_view close, Token::Kind closeKind, nonstd::string_view close_trim = nonstd::string_view(), bool trim = false) {
1726    again:
1727      if (tok_start &gt;= m_in.size()) {
1728        return make_token(Token::Kind::Eof);
1729      }
1730      const char ch = m_in[tok_start];
1731      if (ch == &#x27; &#x27; || ch == &#x27;\t&#x27; || ch == &#x27;\r&#x27;) {
1732        tok_start += 1;
1733        goto again;
1734      }
1735      if (!close_trim.empty() &amp;&amp; inja::string_view::starts_with(m_in.substr(tok_start), close_trim)) {
1736        state = State::Text;
1737        pos = tok_start + close_trim.size();
1738        const Token tok = make_token(closeKind);
1739        skip_whitespaces_and_newlines();
1740        return tok;
1741      }
1742      if (inja::string_view::starts_with(m_in.substr(tok_start), close)) {
1743        state = State::Text;
1744        pos = tok_start + close.size();
1745        const Token tok = make_token(closeKind);
1746        if (trim) {
1747          skip_whitespaces_and_first_newline();
1748        }
1749        return tok;
1750      }
1751      if (ch == &#x27;\n&#x27;) {
1752        tok_start += 1;
1753        goto again;
1754      }
1755      pos = tok_start + 1;
1756      if (std::isalpha(ch)) {
1757        minus_state = MinusState::Operator;
1758        return scan_id();
1759      }
1760      const MinusState current_minus_state = minus_state;
1761      if (minus_state == MinusState::Operator) {
1762        minus_state = MinusState::Number;
1763      }
1764      switch (ch) {
1765      case &#x27;+&#x27;:
1766        return make_token(Token::Kind::Plus);
1767      case &#x27;-&#x27;:
1768        if (current_minus_state == MinusState::Operator) {
1769          return make_token(Token::Kind::Minus);
1770        }
1771        return scan_number();
1772      case &#x27;*&#x27;:
1773        return make_token(Token::Kind::Times);
1774      case &#x27;/&#x27;:
1775        return make_token(Token::Kind::Slash);
1776      case &#x27;^&#x27;:
1777        return make_token(Token::Kind::Power);
1778      case &#x27;%&#x27;:
1779        return make_token(Token::Kind::Percent);
1780      case &#x27;.&#x27;:
1781        return make_token(Token::Kind::Dot);
1782      case &#x27;,&#x27;:
1783        return make_token(Token::Kind::Comma);
1784      case &#x27;:&#x27;:
1785        return make_token(Token::Kind::Colon);
1786      case &#x27;(&#x27;:
1787        return make_token(Token::Kind::LeftParen);
1788      case &#x27;)&#x27;:
1789        minus_state = MinusState::Operator;
1790        return make_token(Token::Kind::RightParen);
1791      case &#x27;[&#x27;:
1792        return make_token(Token::Kind::LeftBracket);
1793      case &#x27;]&#x27;:
1794        minus_state = MinusState::Operator;
1795        return make_token(Token::Kind::RightBracket);
1796      case &#x27;{&#x27;:
1797        return make_token(Token::Kind::LeftBrace);
1798      case &#x27;}&#x27;:
1799        minus_state = MinusState::Operator;
1800        return make_token(Token::Kind::RightBrace);
1801      case &#x27;&gt;&#x27;:
1802        if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;=&#x27;) {
1803          pos += 1;
1804          return make_token(Token::Kind::GreaterEqual);
1805        }
1806        return make_token(Token::Kind::GreaterThan);
1807      case &#x27;&lt;&#x27;:
1808        if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;=&#x27;) {
1809          pos += 1;
1810          return make_token(Token::Kind::LessEqual);
1811        }
1812        return make_token(Token::Kind::LessThan);
1813      case &#x27;=&#x27;:
1814        if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;=&#x27;) {
1815          pos += 1;
1816          return make_token(Token::Kind::Equal);
1817        }
1818        return make_token(Token::Kind::Unknown);
1819      case &#x27;!&#x27;:
1820        if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;=&#x27;) {
1821          pos += 1;
1822          return make_token(Token::Kind::NotEqual);
1823        }
1824        return make_token(Token::Kind::Unknown);
1825      case &#x27;\&quot;&#x27;:
1826        return scan_string();
1827      case &#x27;0&#x27;:
1828      case &#x27;1&#x27;:
1829      case &#x27;2&#x27;:
1830      case &#x27;3&#x27;:
1831      case &#x27;4&#x27;:
1832      case &#x27;5&#x27;:
1833      case &#x27;6&#x27;:
1834      case &#x27;7&#x27;:
1835      case &#x27;8&#x27;:
1836      case &#x27;9&#x27;:
1837        minus_state = MinusState::Operator;
1838        return scan_number();
1839      case &#x27;_&#x27;:
1840      case &#x27;@&#x27;:
1841      case &#x27;$&#x27;:
1842        minus_state = MinusState::Operator;
1843        return scan_id();
1844      default:
1845        return make_token(Token::Kind::Unknown);
1846      }
1847    }
1848    Token scan_id() {
1849      for (;;) {
1850        if (pos &gt;= m_in.size()) {
1851          break;
1852        }
1853        const char ch = m_in[pos];
1854        if (!std::isalnum(ch) &amp;&amp; ch != &#x27;.&#x27; &amp;&amp; ch != &#x27;/&#x27; &amp;&amp; ch != &#x27;_&#x27; &amp;&amp; ch != &#x27;-&#x27;) {
1855          break;
1856        }
1857        pos += 1;
1858      }
1859      return make_token(Token::Kind::Id);
1860    }
1861    Token scan_number() {
1862      for (;;) {
1863        if (pos &gt;= m_in.size()) {
1864          break;
1865        }
1866        const char ch = m_in[pos];
1867        if (!std::isdigit(ch) &amp;&amp; ch != &#x27;.&#x27; &amp;&amp; ch != &#x27;e&#x27; &amp;&amp; ch != &#x27;E&#x27; &amp;&amp; ch != &#x27;+&#x27; &amp;&amp; ch != &#x27;-&#x27;) {
1868          break;
1869        }
1870        pos += 1;
1871      }
1872      return make_token(Token::Kind::Number);
1873    }
1874    Token scan_string() {
1875      bool escape {false};
1876      for (;;) {
1877        if (pos &gt;= m_in.size()) {
1878          break;
1879        }
1880        const char ch = m_in[pos++];
1881        if (ch == &#x27;\\&#x27;) {
1882          escape = true;
1883        } else if (!escape &amp;&amp; ch == m_in[tok_start]) {
1884          break;
1885        } else {
1886          escape = false;
1887        }
1888      }
1889      return make_token(Token::Kind::String);
1890    }
1891    Token make_token(Token::Kind kind) const { return Token(kind, string_view::slice(m_in, tok_start, pos)); }
1892    void skip_whitespaces_and_newlines() {
1893      if (pos &lt; m_in.size()) {
1894        while (pos &lt; m_in.size() &amp;&amp; (m_in[pos] == &#x27; &#x27; || m_in[pos] == &#x27;\t&#x27; || m_in[pos] == &#x27;\n&#x27; || m_in[pos] == &#x27;\r&#x27;)) {
1895          pos += 1;
1896        }
1897      }
1898    }
1899    void skip_whitespaces_and_first_newline() {
1900      if (pos &lt; m_in.size()) {
1901        while (pos &lt; m_in.size() &amp;&amp; (m_in[pos] == &#x27; &#x27; || m_in[pos] == &#x27;\t&#x27;)) {
1902          pos += 1;
1903        }
1904      }
1905      if (pos &lt; m_in.size()) {
1906        const char ch = m_in[pos];
1907        if (ch == &#x27;\n&#x27;) {
1908          pos += 1;
1909        } else if (ch == &#x27;\r&#x27;) {
1910          pos += 1;
1911          if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;\n&#x27;) {
1912            pos += 1;
1913          }
1914        }
1915      }
1916    }
1917    static nonstd::string_view clear_final_line_if_whitespace(nonstd::string_view text) {
1918      nonstd::string_view result = text;
1919      while (!result.empty()) {
1920        const char ch = result.back();
1921        if (ch == &#x27; &#x27; || ch == &#x27;\t&#x27;) {
1922          result.remove_suffix(1);
1923        } else if (ch == &#x27;\n&#x27; || ch == &#x27;\r&#x27;) {
1924          break;
1925        } else {
1926          return text;
1927        }
1928      }
1929      return result;
1930    }
1931  public:
1932    explicit Lexer(const LexerConfig &amp;config) : config(config), state(State::Text), minus_state(MinusState::Number) {}
1933    SourceLocation current_position() const {
1934      return get_source_location(m_in, tok_start);
1935    }
1936    void start(nonstd::string_view input) {
1937      m_in = input;
1938      tok_start = 0;
1939      pos = 0;
1940      state = State::Text;
1941      minus_state = MinusState::Number;
1942      if (inja::string_view::starts_with(m_in, &quot;\xEF\xBB\xBF&quot;)) {
1943        m_in = m_in.substr(3);
1944      }
1945    }
1946    Token scan() {
1947      tok_start = pos;
1948    again:
1949      if (tok_start &gt;= m_in.size()) {
1950        return make_token(Token::Kind::Eof);
1951      }
1952      switch (state) {
1953      default:
1954      case State::Text: {
1955        const size_t open_start = m_in.substr(pos).find_first_of(config.open_chars);
1956        if (open_start == nonstd::string_view::npos) {
1957          pos = m_in.size();
1958          return make_token(Token::Kind::Text);
1959        }
1960        pos += open_start;
1961        nonstd::string_view open_str = m_in.substr(pos);
1962        bool must_lstrip = false;
1963        if (inja::string_view::starts_with(open_str, config.expression_open)) {
1964          if (inja::string_view::starts_with(open_str, config.expression_open_force_lstrip)) {
1965            state = State::ExpressionStartForceLstrip;
1966            must_lstrip = true;
1967          } else {
1968            state = State::ExpressionStart;
1969          }
1970        } else if (inja::string_view::starts_with(open_str, config.statement_open)) {
1971          if (inja::string_view::starts_with(open_str, config.statement_open_no_lstrip)) {
1972            state = State::StatementStartNoLstrip;
1973          } else if (inja::string_view::starts_with(open_str, config.statement_open_force_lstrip )) {
1974            state = State::StatementStartForceLstrip;
1975            must_lstrip = true;
1976          } else {
1977            state = State::StatementStart;
1978            must_lstrip = config.lstrip_blocks;
1979          }
1980        } else if (inja::string_view::starts_with(open_str, config.comment_open)) {
1981          if (inja::string_view::starts_with(open_str, config.comment_open_force_lstrip)) {
1982            state = State::CommentStartForceLstrip;
1983            must_lstrip = true;
1984          } else {
1985            state = State::CommentStart;
1986            must_lstrip = config.lstrip_blocks;
1987          }
1988        } else if ((pos == 0 || m_in[pos - 1] == &#x27;\n&#x27;) &amp;&amp; inja::string_view::starts_with(open_str, config.line_statement)) {
1989          state = State::LineStart;
1990        } else {
1991          pos += 1; 
1992          goto again;
1993        }
1994        nonstd::string_view text = string_view::slice(m_in, tok_start, pos);
1995        if (must_lstrip) {
1996          text = clear_final_line_if_whitespace(text);
1997        }
1998        if (text.empty()) {
1999          goto again; 
2000        }
2001        return Token(Token::Kind::Text, text);
2002      }
2003      case State::ExpressionStart: {
2004        state = State::ExpressionBody;
2005        pos += config.expression_open.size();
2006        return make_token(Token::Kind::ExpressionOpen);
2007      }
2008      case State::ExpressionStartForceLstrip: {
2009        state = State::ExpressionBody;
2010        pos += config.expression_open_force_lstrip.size();
2011        return make_token(Token::Kind::ExpressionOpen);
2012      }
2013      case State::LineStart: {
2014        state = State::LineBody;
2015        pos += config.line_statement.size();
2016        return make_token(Token::Kind::LineStatementOpen);
2017      }
2018      case State::StatementStart: {
2019        state = State::StatementBody;
2020        pos += config.statement_open.size();
2021        return make_token(Token::Kind::StatementOpen);
2022      }
2023      case State::StatementStartNoLstrip: {
2024        state = State::StatementBody;
2025        pos += config.statement_open_no_lstrip.size();
2026        return make_token(Token::Kind::StatementOpen);
2027      }
2028      case State::StatementStartForceLstrip: {
2029        state = State::StatementBody;
2030        pos += config.statement_open_force_lstrip.size();
2031        return make_token(Token::Kind::StatementOpen);
2032      }
2033      case State::CommentStart: {
2034        state = State::CommentBody;
2035        pos += config.comment_open.size();
2036        return make_token(Token::Kind::CommentOpen);
2037      }
2038      case State::CommentStartForceLstrip: {
2039        state = State::CommentBody;
2040        pos += config.comment_open_force_lstrip.size();
2041        return make_token(Token::Kind::CommentOpen);
2042      }
2043      case State::ExpressionBody:
2044        return scan_body(config.expression_close, Token::Kind::ExpressionClose, config.expression_close_force_rstrip);
2045      case State::LineBody:
2046        return scan_body(&quot;\n&quot;, Token::Kind::LineStatementClose);
2047      case State::StatementBody:
2048        return scan_body(config.statement_close, Token::Kind::StatementClose, config.statement_close_force_rstrip, config.trim_blocks);
2049      case State::CommentBody: {
2050        const size_t end = m_in.substr(pos).find(config.comment_close);
2051        if (end == nonstd::string_view::npos) {
2052          pos = m_in.size();
2053          return make_token(Token::Kind::Eof);
2054        }
2055        const bool must_rstrip = inja::string_view::starts_with(m_in.substr(pos + end - 1), config.comment_close_force_rstrip);
2056        state = State::Text;
2057        pos += end + config.comment_close.size();
2058        Token tok = make_token(Token::Kind::CommentClose);
2059        if (must_rstrip || config.trim_blocks) {
2060          skip_whitespaces_and_first_newline();
2061        }
2062        return tok;
2063      }
2064      }
2065    }
2066    const LexerConfig &amp;get_config() const {
2067      return config;
2068    }
2069  };
2070  } 
2071  #endif 
2072  namespace inja {
2073  class Parser {
2074    const ParserConfig &amp;config;
2075    Lexer lexer;
2076    TemplateStorage &amp;template_storage;
2077    const FunctionStorage &amp;function_storage;
2078    Token tok, peek_tok;
2079    bool have_peek_tok {false};
2080    size_t current_paren_level {0};
2081    size_t current_bracket_level {0};
2082    size_t current_brace_level {0};
2083    nonstd::string_view json_literal_start;
2084    BlockNode *current_block {nullptr};
2085    ExpressionListNode *current_expression_list {nullptr};
2086    std::stack&lt;std::pair&lt;FunctionNode*, size_t&gt;&gt; function_stack;
2087    std::vector&lt;std::shared_ptr&lt;ExpressionNode&gt;&gt; arguments;
2088    std::stack&lt;std::shared_ptr&lt;FunctionNode&gt;&gt; operator_stack;
2089    std::stack&lt;IfStatementNode*&gt; if_statement_stack;
2090    std::stack&lt;ForStatementNode*&gt; for_statement_stack;
2091    std::stack&lt;BlockStatementNode*&gt; block_statement_stack;
2092    inline void throw_parser_error(const std::string &amp;message) {
2093      INJA_THROW(ParserError(message, lexer.current_position()));
2094    }
2095    inline void get_next_token() {
2096      if (have_peek_tok) {
2097        tok = peek_tok;
2098        have_peek_tok = false;
2099      } else {
2100        tok = lexer.scan();
2101      }
2102    }
2103    inline void get_peek_token() {
2104      if (!have_peek_tok) {
2105        peek_tok = lexer.scan();
2106        have_peek_tok = true;
2107      }
2108    }
2109    inline void add_json_literal(const char* content_ptr) {
2110      nonstd::string_view json_text(json_literal_start.data(), tok.text.data() - json_literal_start.data() + tok.text.size());
2111      arguments.emplace_back(std::make_shared&lt;LiteralNode&gt;(json::parse(json_text), json_text.data() - content_ptr));
2112    }
2113    inline void add_operator() {
2114      auto function = operator_stack.top();
2115      operator_stack.pop();
2116      for (int i = 0; i &lt; function-&gt;number_args; ++i) {
2117        function-&gt;arguments.insert(function-&gt;arguments.begin(), arguments.back());
2118        arguments.pop_back();
2119      }
2120      arguments.emplace_back(function);
2121    }
2122    void add_to_template_storage(nonstd::string_view path, std::string&amp; template_name) {
2123      if (template_storage.find(template_name) != template_storage.end()) {
2124        return;
2125      }
2126      std::string original_path = static_cast&lt;std::string&gt;(path);
2127      std::string original_name = template_name;
2128      if (config.search_included_templates_in_files) {
2129        template_name = original_path + original_name;
2130        if (template_name.compare(0, 2, &quot;./&quot;) == 0) {
2131          template_name.erase(0, 2);
2132        }
2133        if (template_storage.find(template_name) == template_storage.end()) {
2134          std::ifstream file;
2135          file.open(template_name);
2136          if (!file.fail()) {
2137            std::string text((std::istreambuf_iterator&lt;char&gt;(file)), std::istreambuf_iterator&lt;char&gt;());
2138            auto include_template = Template(text);
2139            template_storage.emplace(template_name, include_template);
2140            parse_into_template(template_storage[template_name], template_name);
2141            return;
2142          } else if (!config.include_callback) {
2143            INJA_THROW(FileError(&quot;failed accessing file at &#x27;&quot; + template_name + &quot;&#x27;&quot;));
2144          }
2145        }
2146      }
2147      if (config.include_callback) {
2148        auto include_template = config.include_callback(original_path, original_name);
2149        template_storage.emplace(template_name, include_template);
2150      }
2151    }
2152    bool parse_expression(Template &amp;tmpl, Token::Kind closing) {
2153      while (tok.kind != closing &amp;&amp; tok.kind != Token::Kind::Eof) {
2154        switch (tok.kind) {
2155        case Token::Kind::String: {
2156          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2157            json_literal_start = tok.text;
2158            add_json_literal(tmpl.content.c_str());
2159          }
2160        } break;
2161        case Token::Kind::Number: {
2162          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2163            json_literal_start = tok.text;
2164            add_json_literal(tmpl.content.c_str());
2165          }
2166        } break;
2167        case Token::Kind::LeftBracket: {
2168          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2169            json_literal_start = tok.text;
2170          }
2171          current_bracket_level += 1;
2172        } break;
2173        case Token::Kind::LeftBrace: {
2174          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2175            json_literal_start = tok.text;
2176          }
2177          current_brace_level += 1;
2178        } break;
2179        case Token::Kind::RightBracket: {
2180          if (current_bracket_level == 0) {
2181            throw_parser_error(&quot;unexpected &#x27;]&#x27;&quot;);
2182          }
2183          current_bracket_level -= 1;
2184          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2185            add_json_literal(tmpl.content.c_str());
2186          }
2187        } break;
2188        case Token::Kind::RightBrace: {
2189          if (current_brace_level == 0) {
2190            throw_parser_error(&quot;unexpected &#x27;}&#x27;&quot;);
2191          }
2192          current_brace_level -= 1;
2193          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2194            add_json_literal(tmpl.content.c_str());
2195          }
2196        } break;
2197        case Token::Kind::Id: {
2198          get_peek_token();
2199          if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;true&quot;) || tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;false&quot;) || tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;null&quot;)) {
2200            if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2201              json_literal_start = tok.text;
2202              add_json_literal(tmpl.content.c_str());
2203            }
2204          } else if (tok.text == &quot;and&quot; || tok.text == &quot;or&quot; || tok.text == &quot;in&quot; || tok.text == &quot;not&quot;) {
2205            goto parse_operator;
2206          } else if (peek_tok.kind == Token::Kind::LeftParen) {
2207            operator_stack.emplace(std::make_shared&lt;FunctionNode&gt;(static_cast&lt;std::string&gt;(tok.text), tok.text.data() - tmpl.content.c_str()));
2208            function_stack.emplace(operator_stack.top().get(), current_paren_level);       
2209          } else {
2210            arguments.emplace_back(std::make_shared&lt;JsonNode&gt;(static_cast&lt;std::string&gt;(tok.text), tok.text.data() - tmpl.content.c_str()));
2211          }
2212        } break;
2213        case Token::Kind::Equal:
2214        case Token::Kind::NotEqual:
2215        case Token::Kind::GreaterThan:
2216        case Token::Kind::GreaterEqual:
2217        case Token::Kind::LessThan:
2218        case Token::Kind::LessEqual:
2219        case Token::Kind::Plus:
2220        case Token::Kind::Minus:
2221        case Token::Kind::Times:
2222        case Token::Kind::Slash:
2223        case Token::Kind::Power:
2224        case Token::Kind::Percent:
2225        case Token::Kind::Dot: {
2226    parse_operator:
2227          FunctionStorage::Operation operation;
2228          switch (tok.kind) {
2229          case Token::Kind::Id: {
2230            if (tok.text == &quot;and&quot;) {
2231              operation = FunctionStorage::Operation::And;
2232            } else if (tok.text == &quot;or&quot;) {
2233              operation = FunctionStorage::Operation::Or;
2234            } else if (tok.text == &quot;in&quot;) {
2235              operation = FunctionStorage::Operation::In;
2236            } else if (tok.text == &quot;not&quot;) {
2237              operation = FunctionStorage::Operation::Not;
2238            } else {
2239              throw_parser_error(&quot;unknown operator in parser.&quot;);
2240            }
2241          } break;
2242          case Token::Kind::Equal: {
2243            operation = FunctionStorage::Operation::Equal;
2244          } break;
2245          case Token::Kind::NotEqual: {
2246            operation = FunctionStorage::Operation::NotEqual;
2247          } break;
2248          case Token::Kind::GreaterThan: {
2249            operation = FunctionStorage::Operation::Greater;
2250          } break;
2251          case Token::Kind::GreaterEqual: {
2252            operation = FunctionStorage::Operation::GreaterEqual;
2253          } break;
2254          case Token::Kind::LessThan: {
2255            operation = FunctionStorage::Operation::Less;
2256          } break;
2257          case Token::Kind::LessEqual: {
2258            operation = FunctionStorage::Operation::LessEqual;
2259          } break;
2260          case Token::Kind::Plus: {
2261            operation = FunctionStorage::Operation::Add;
2262          } break;
2263          case Token::Kind::Minus: {
2264            operation = FunctionStorage::Operation::Subtract;
2265          } break;
2266          case Token::Kind::Times: {
2267            operation = FunctionStorage::Operation::Multiplication;
2268          } break;
2269          case Token::Kind::Slash: {
2270            operation = FunctionStorage::Operation::Division;
2271          } break;
2272          case Token::Kind::Power: {
2273            operation = FunctionStorage::Operation::Power;
2274          } break;
2275          case Token::Kind::Percent: {
2276            operation = FunctionStorage::Operation::Modulo;
2277          } break;
2278          case Token::Kind::Dot: {
2279            operation = FunctionStorage::Operation::AtId;
2280          } break;
2281          default: {
2282            throw_parser_error(&quot;unknown operator in parser.&quot;);
2283          }
2284          }
2285          auto function_node = std::make_shared&lt;FunctionNode&gt;(operation, tok.text.data() - tmpl.content.c_str());
2286          while (!operator_stack.empty() &amp;&amp; ((operator_stack.top()-&gt;precedence &gt; function_node-&gt;precedence) || (operator_stack.top()-&gt;precedence == function_node-&gt;precedence &amp;&amp; function_node-&gt;associativity == FunctionNode::Associativity::Left)) &amp;&amp; (operator_stack.top()-&gt;operation != FunctionStorage::Operation::ParenLeft)) {
2287            add_operator();
2288          }
2289          operator_stack.emplace(function_node);
2290        } break;
2291        case Token::Kind::Comma: {
2292          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2293            if (function_stack.empty()) {
2294              throw_parser_error(&quot;unexpected &#x27;,&#x27;&quot;);
2295            }
2296            function_stack.top().first-&gt;number_args += 1;
2297          }
2298        } break;
2299        case Token::Kind::Colon: {
2300          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2301            throw_parser_error(&quot;unexpected &#x27;:&#x27;&quot;);
2302          }
2303        } break;
2304        case Token::Kind::LeftParen: {
2305          current_paren_level += 1;
2306          operator_stack.emplace(std::make_shared&lt;FunctionNode&gt;(FunctionStorage::Operation::ParenLeft, tok.text.data() - tmpl.content.c_str()));
2307          get_peek_token();
2308          if (peek_tok.kind == Token::Kind::RightParen) {
2309            if (!function_stack.empty() &amp;&amp; function_stack.top().second == current_paren_level - 1) {
2310              function_stack.top().first-&gt;number_args = 0;
2311            }
2312          }
2313        } break;
2314        case Token::Kind::RightParen: {
2315          current_paren_level -= 1;
2316          while (!operator_stack.empty() &amp;&amp; operator_stack.top()-&gt;operation != FunctionStorage::Operation::ParenLeft) {
2317            add_operator();
2318          }
2319          if (!operator_stack.empty() &amp;&amp; operator_stack.top()-&gt;operation == FunctionStorage::Operation::ParenLeft) {
2320            operator_stack.pop();
2321          }
2322          if (!function_stack.empty() &amp;&amp; function_stack.top().second == current_paren_level) {
2323            auto func = function_stack.top().first;
2324            auto function_data = function_storage.find_function(func-&gt;name, func-&gt;number_args);
2325            if (function_data.operation == FunctionStorage::Operation::None) {
2326              throw_parser_error(&quot;unknown function &quot; + func-&gt;name);
2327            }
2328            func-&gt;operation = function_data.operation;
2329            if (function_data.operation == FunctionStorage::Operation::Callback) {
2330              func-&gt;callback = function_data.callback;
2331            }
2332            if (operator_stack.empty()) {
2333              throw_parser_error(&quot;internal error at function &quot; + func-&gt;name);
2334            }
2335            add_operator();
2336            function_stack.pop();
2337          }
2338        }
2339        default:
2340          break;
2341        }
2342        get_next_token();
2343      }
2344      while (!operator_stack.empty()) {
2345        add_operator();
2346      }
2347      if (arguments.size() == 1) {
2348        current_expression_list-&gt;root = arguments[0];
2349        arguments = {};
2350      } else if (arguments.size() &gt; 1) {
2351        throw_parser_error(&quot;malformed expression&quot;);
2352      }
2353      return true;
2354    }
2355    bool parse_statement(Template &amp;tmpl, Token::Kind closing, nonstd::string_view path) {
2356      if (tok.kind != Token::Kind::Id) {
2357        return false;
2358      }
2359      if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;if&quot;)) {
2360        get_next_token();
2361        auto if_statement_node = std::make_shared&lt;IfStatementNode&gt;(current_block, tok.text.data() - tmpl.content.c_str());
2362        current_block-&gt;nodes.emplace_back(if_statement_node);
2363        if_statement_stack.emplace(if_statement_node.get());
2364        current_block = &amp;if_statement_node-&gt;true_statement;
2365        current_expression_list = &amp;if_statement_node-&gt;condition;
2366        if (!parse_expression(tmpl, closing)) {
2367          return false;
2368        }
2369      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;else&quot;)) {
2370        if (if_statement_stack.empty()) {
2371          throw_parser_error(&quot;else without matching if&quot;);
2372        }
2373        auto &amp;if_statement_data = if_statement_stack.top();
2374        get_next_token();
2375        if_statement_data-&gt;has_false_statement = true;
2376        current_block = &amp;if_statement_data-&gt;false_statement;
2377        if (tok.kind == Token::Kind::Id &amp;&amp; tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;if&quot;)) {
2378          get_next_token();
2379          auto if_statement_node = std::make_shared&lt;IfStatementNode&gt;(true, current_block, tok.text.data() - tmpl.content.c_str());
2380          current_block-&gt;nodes.emplace_back(if_statement_node);
2381          if_statement_stack.emplace(if_statement_node.get());
2382          current_block = &amp;if_statement_node-&gt;true_statement;
2383          current_expression_list = &amp;if_statement_node-&gt;condition;
2384          if (!parse_expression(tmpl, closing)) {
2385            return false;
2386          }
2387        }
2388      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;endif&quot;)) {
2389        if (if_statement_stack.empty()) {
2390          throw_parser_error(&quot;endif without matching if&quot;);
2391        }
2392        while (if_statement_stack.top()-&gt;is_nested) {
2393          if_statement_stack.pop();
2394        }
2395        auto &amp;if_statement_data = if_statement_stack.top();
2396        get_next_token();
2397        current_block = if_statement_data-&gt;parent;
2398        if_statement_stack.pop();
2399      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;block&quot;)) {
2400        get_next_token();
2401        if (tok.kind != Token::Kind::Id) {
2402          throw_parser_error(&quot;expected block name, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2403        }
2404        const std::string block_name = static_cast&lt;std::string&gt;(tok.text);
2405        auto block_statement_node = std::make_shared&lt;BlockStatementNode&gt;(current_block, block_name, tok.text.data() - tmpl.content.c_str());
2406        current_block-&gt;nodes.emplace_back(block_statement_node);
2407        block_statement_stack.emplace(block_statement_node.get());
2408        current_block = &amp;block_statement_node-&gt;block;
2409        auto success = tmpl.block_storage.emplace(block_name, block_statement_node);
2410        if (!success.second) {
2411          throw_parser_error(&quot;block with the name &#x27;&quot; + block_name + &quot;&#x27; does already exist&quot;);
2412        }
2413        get_next_token();
2414      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;endblock&quot;)) {
2415        if (block_statement_stack.empty()) {
2416          throw_parser_error(&quot;endblock without matching block&quot;);
2417        }
2418        auto &amp;block_statement_data = block_statement_stack.top();
2419        get_next_token();
2420        current_block = block_statement_data-&gt;parent;
2421        block_statement_stack.pop();
2422      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;for&quot;)) {
2423        get_next_token();
2424        if (tok.kind != Token::Kind::Id) {
2425          throw_parser_error(&quot;expected id, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2426        }
2427        Token value_token = tok;
2428        get_next_token();
2429        std::shared_ptr&lt;ForStatementNode&gt; for_statement_node;
2430        if (tok.kind == Token::Kind::Comma) {
2431          get_next_token();
2432          if (tok.kind != Token::Kind::Id) {
2433            throw_parser_error(&quot;expected id, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2434          }
2435          Token key_token = std::move(value_token);
2436          value_token = tok;
2437          get_next_token();
2438          for_statement_node = std::make_shared&lt;ForObjectStatementNode&gt;(static_cast&lt;std::string&gt;(key_token.text), static_cast&lt;std::string&gt;(value_token.text), current_block, tok.text.data() - tmpl.content.c_str());
2439        } else {
2440          for_statement_node = std::make_shared&lt;ForArrayStatementNode&gt;(static_cast&lt;std::string&gt;(value_token.text), current_block, tok.text.data() - tmpl.content.c_str());
2441        }
2442        current_block-&gt;nodes.emplace_back(for_statement_node);
2443        for_statement_stack.emplace(for_statement_node.get());
2444        current_block = &amp;for_statement_node-&gt;body;
2445        current_expression_list = &amp;for_statement_node-&gt;condition;
2446        if (tok.kind != Token::Kind::Id || tok.text != static_cast&lt;decltype(tok.text)&gt;(&quot;in&quot;)) {
2447          throw_parser_error(&quot;expected &#x27;in&#x27;, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2448        }
2449        get_next_token();
2450        if (!parse_expression(tmpl, closing)) {
2451          return false;
2452        }
2453      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;endfor&quot;)) {
2454        if (for_statement_stack.empty()) {
2455          throw_parser_error(&quot;endfor without matching for&quot;);
2456        }
2457        auto &amp;for_statement_data = for_statement_stack.top();
2458        get_next_token();
2459        current_block = for_statement_data-&gt;parent;
2460        for_statement_stack.pop();
2461      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;include&quot;)) {
2462        get_next_token();
2463        if (tok.kind != Token::Kind::String) {
2464          throw_parser_error(&quot;expected string, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2465        }
2466        std::string template_name = json::parse(tok.text).get_ref&lt;const std::string &amp;&gt;();
2467        add_to_template_storage(path, template_name);
2468        current_block-&gt;nodes.emplace_back(std::make_shared&lt;IncludeStatementNode&gt;(template_name, tok.text.data() - tmpl.content.c_str()));
2469        get_next_token();
2470      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;extends&quot;)) {
2471        get_next_token();
2472        if (tok.kind != Token::Kind::String) {
2473          throw_parser_error(&quot;expected string, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2474        }
2475        std::string template_name = json::parse(tok.text).get_ref&lt;const std::string &amp;&gt;();
2476        add_to_template_storage(path, template_name);
2477        current_block-&gt;nodes.emplace_back(std::make_shared&lt;ExtendsStatementNode&gt;(template_name, tok.text.data() - tmpl.content.c_str()));
2478        get_next_token();
2479      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;set&quot;)) {
2480        get_next_token();
2481        if (tok.kind != Token::Kind::Id) {
2482          throw_parser_error(&quot;expected variable name, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2483        }
2484        std::string key = static_cast&lt;std::string&gt;(tok.text);
2485        get_next_token();
2486        auto set_statement_node = std::make_shared&lt;SetStatementNode&gt;(key, tok.text.data() - tmpl.content.c_str());
2487        current_block-&gt;nodes.emplace_back(set_statement_node);
2488        current_expression_list = &amp;set_statement_node-&gt;expression;
2489        if (tok.text != static_cast&lt;decltype(tok.text)&gt;(&quot;=&quot;)) {
2490          throw_parser_error(&quot;expected &#x27;=&#x27;, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2491        }
2492        get_next_token();
2493        if (!parse_expression(tmpl, closing)) {
2494          return false;
2495        }
2496      } else {
2497        return false;
2498      }
2499      return true;
2500    }
2501    void parse_into(Template &amp;tmpl, nonstd::string_view path) {
2502      lexer.start(tmpl.content);
2503      current_block = &amp;tmpl.root;
2504      for (;;) {
2505        get_next_token();
2506        switch (tok.kind) {
2507        case Token::Kind::Eof: {
2508          if (!if_statement_stack.empty()) {
2509            throw_parser_error(&quot;unmatched if&quot;);
2510          }
2511          if (!for_statement_stack.empty()) {
2512            throw_parser_error(&quot;unmatched for&quot;);
2513          }
2514        } return;
2515        case Token::Kind::Text: {
2516          current_block-&gt;nodes.emplace_back(std::make_shared&lt;TextNode&gt;(tok.text.data() - tmpl.content.c_str(), tok.text.size()));
2517        } break;
2518        case Token::Kind::StatementOpen: {
2519          get_next_token();
2520          if (!parse_statement(tmpl, Token::Kind::StatementClose, path)) {
2521            throw_parser_error(&quot;expected statement, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2522          }
2523          if (tok.kind != Token::Kind::StatementClose) {
2524            throw_parser_error(&quot;expected statement close, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2525          }
2526        } break;
2527        case Token::Kind::LineStatementOpen: {
2528          get_next_token();
2529          if (!parse_statement(tmpl, Token::Kind::LineStatementClose, path)) {
2530            throw_parser_error(&quot;expected statement, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2531          }
2532          if (tok.kind != Token::Kind::LineStatementClose &amp;&amp; tok.kind != Token::Kind::Eof) {
2533            throw_parser_error(&quot;expected line statement close, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2534          }
2535        } break;
2536        case Token::Kind::ExpressionOpen: {
2537          get_next_token();
2538          auto expression_list_node = std::make_shared&lt;ExpressionListNode&gt;(tok.text.data() - tmpl.content.c_str());
2539          current_block-&gt;nodes.emplace_back(expression_list_node);
2540          current_expression_list = expression_list_node.get();
2541          if (!parse_expression(tmpl, Token::Kind::ExpressionClose)) {
2542            throw_parser_error(&quot;expected expression, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2543          }
2544          if (tok.kind != Token::Kind::ExpressionClose) {
2545            throw_parser_error(&quot;expected expression close, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2546          }
2547        } break;
2548        case Token::Kind::CommentOpen: {
2549          get_next_token();
2550          if (tok.kind != Token::Kind::CommentClose) {
2551            throw_parser_error(&quot;expected comment close, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2552          }
2553        } break;
2554        default: {
2555          throw_parser_error(&quot;unexpected token &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2556        } break;
2557        }
2558      }
2559    }
2560  public:
2561    explicit Parser(const ParserConfig &amp;parser_config, const LexerConfig &amp;lexer_config,
2562                    TemplateStorage &amp;template_storage, const FunctionStorage &amp;function_storage)
2563        : config(parser_config), lexer(lexer_config), template_storage(template_storage), function_storage(function_storage) { }
2564    Template parse(nonstd::string_view input, nonstd::string_view path) {
2565      auto result = Template(static_cast&lt;std::string&gt;(input));
2566      parse_into(result, path);
2567      return result;
2568    }
2569    Template parse(nonstd::string_view input) {
2570      return parse(input, &quot;./&quot;);
2571    }
2572    void parse_into_template(Template&amp; tmpl, nonstd::string_view filename) {
2573      nonstd::string_view path = filename.substr(0, filename.find_last_of(&quot;/\\&quot;) + 1);
2574      auto sub_parser = Parser(config, lexer.get_config(), template_storage, function_storage);
2575      sub_parser.parse_into(tmpl, path);
2576    }
2577    std::string load_file(const std::string&amp; filename) {
2578      std::ifstream file;
2579      file.open(filename);
2580      if (file.fail()) {
2581        INJA_THROW(FileError(&quot;failed accessing file at &#x27;&quot; + filename + &quot;&#x27;&quot;));
2582      }
2583      std::string text((std::istreambuf_iterator&lt;char&gt;(file)), std::istreambuf_iterator&lt;char&gt;());
2584      return text;
2585    }
2586  };
2587  } 
2588  #endif 
2589  #ifndef INCLUDE_INJA_RENDERER_HPP_
2590  #define INCLUDE_INJA_RENDERER_HPP_
2591  #include &lt;algorithm&gt;
2592  #include &lt;numeric&gt;
2593  #include &lt;string&gt;
2594  #include &lt;utility&gt;
2595  #include &lt;vector&gt;
2596  namespace inja {
2597  class Renderer : public NodeVisitor  {
2598    using Op = FunctionStorage::Operation;
2599    const RenderConfig config;
2600    const TemplateStorage &amp;template_storage;
2601    const FunctionStorage &amp;function_storage;
2602    const Template *current_template;
2603    size_t current_level {0};
2604    std::vector&lt;const Template*&gt; template_stack;
2605    std::vector&lt;const BlockStatementNode*&gt; block_statement_stack;
2606    const json *json_input;
2607    std::ostream *output_stream;
2608    json json_additional_data;
2609    json* current_loop_data = &amp;json_additional_data[&quot;loop&quot;];
2610    std::vector&lt;std::shared_ptr&lt;json&gt;&gt; json_tmp_stack;
2611    std::stack&lt;const json*&gt; json_eval_stack;
2612    std::stack&lt;const JsonNode*&gt; not_found_stack;
2613    bool break_rendering {false};
2614    bool truthy(const json* data) const {
2615      if (data-&gt;is_boolean()) {
2616        return data-&gt;get&lt;bool&gt;();
2617      } else if (data-&gt;is_number()) {
2618        return (*data != 0);
2619      } else if (data-&gt;is_null()) {
2620        return false;
2621      }
2622      return !data-&gt;empty();
2623    }
2624    void print_json(const std::shared_ptr&lt;json&gt; value) {
2625      if (value-&gt;is_string()) {
2626        *output_stream &lt;&lt; value-&gt;get_ref&lt;const json::string_t&amp;&gt;();
2627      } else if (value-&gt;is_number_integer()) {
2628        *output_stream &lt;&lt; value-&gt;get&lt;const json::number_integer_t&gt;();
2629      } else if (value-&gt;is_null()) {
2630      } else {
2631        *output_stream &lt;&lt; value-&gt;dump();
2632      }
2633    }
2634    const std::shared_ptr&lt;json&gt; eval_expression_list(const ExpressionListNode&amp; expression_list) {
2635      if (!expression_list.root) {
2636        throw_renderer_error(&quot;empty expression&quot;, expression_list);
2637      }
2638      expression_list.root-&gt;accept(*this);
2639      if (json_eval_stack.empty()) {
2640        throw_renderer_error(&quot;empty expression&quot;, expression_list);
2641      } else if (json_eval_stack.size() != 1) {
2642        throw_renderer_error(&quot;malformed expression&quot;, expression_list);
2643      }
2644      const auto result = json_eval_stack.top();
2645      json_eval_stack.pop();
2646      if (!result) {
2647        if (not_found_stack.empty()) {
2648          throw_renderer_error(&quot;expression could not be evaluated&quot;, expression_list);
2649        }
2650        auto node = not_found_stack.top();
2651        not_found_stack.pop();
2652        throw_renderer_error(&quot;variable &#x27;&quot; + static_cast&lt;std::string&gt;(node-&gt;name) + &quot;&#x27; not found&quot;, *node);
2653      }
2654      return std::make_shared&lt;json&gt;(*result);
2655    }
2656    void throw_renderer_error(const std::string &amp;message, const AstNode&amp; node) {
2657      SourceLocation loc = get_source_location(current_template-&gt;content, node.pos);
2658      INJA_THROW(RenderError(message, loc));
2659    }
2660    template&lt;size_t N, size_t N_start = 0, bool throw_not_found=true&gt;
2661    std::array&lt;const json*, N&gt; get_arguments(const FunctionNode&amp; node) {
2662      if (node.arguments.size() &lt; N_start + N) {
2663        throw_renderer_error(&quot;function needs &quot; + std::to_string(N_start + N) + &quot; variables, but has only found &quot; + std::to_string(node.arguments.size()), node);
2664      }
2665      for (size_t i = N_start; i &lt; N_start + N; i += 1) {
2666        node.arguments[i]-&gt;accept(*this);
2667      }
2668      if (json_eval_stack.size() &lt; N) {
2669        throw_renderer_error(&quot;function needs &quot; + std::to_string(N) + &quot; variables, but has only found &quot; + std::to_string(json_eval_stack.size()), node);
2670      }
2671      std::array&lt;const json*, N&gt; result;
2672      for (size_t i = 0; i &lt; N; i += 1) {
2673        result[N - i - 1] = json_eval_stack.top();
2674        json_eval_stack.pop();
2675        if (!result[N - i - 1]) {
2676          const auto json_node = not_found_stack.top();
2677          not_found_stack.pop();
2678          if (throw_not_found) {
2679            throw_renderer_error(&quot;variable &#x27;&quot; + static_cast&lt;std::string&gt;(json_node-&gt;name) + &quot;&#x27; not found&quot;, *json_node);
2680          }
2681        }
2682      }
2683      return result;
2684    }
2685    template&lt;bool throw_not_found=true&gt;
2686    Arguments get_argument_vector(const FunctionNode&amp; node) {
2687      const size_t N = node.arguments.size();
2688      for (auto a: node.arguments) {
2689        a-&gt;accept(*this);
2690      }
2691      if (json_eval_stack.size() &lt; N) {
2692        throw_renderer_error(&quot;function needs &quot; + std::to_string(N) + &quot; variables, but has only found &quot; + std::to_string(json_eval_stack.size()), node);
2693      }
2694      Arguments result {N};
2695      for (size_t i = 0; i &lt; N; i += 1) {
2696        result[N - i - 1] = json_eval_stack.top();
2697        json_eval_stack.pop();
2698        if (!result[N - i - 1]) {
2699          const auto json_node = not_found_stack.top();
2700          not_found_stack.pop();
2701          if (throw_not_found) {
2702            throw_renderer_error(&quot;variable &#x27;&quot; + static_cast&lt;std::string&gt;(json_node-&gt;name) + &quot;&#x27; not found&quot;, *json_node);
2703          }
2704        }
2705      }
2706      return result;
2707    }
2708    void visit(const BlockNode&amp; node) {
2709      for (auto&amp; n : node.nodes) {
2710        n-&gt;accept(*this);
2711        if (break_rendering) {
2712          break;
2713        }
2714      }
2715    }
2716    void visit(const TextNode&amp; node) {
2717      output_stream-&gt;write(current_template-&gt;content.c_str() + node.pos, node.length);
2718    }
2719    void visit(const ExpressionNode&amp;) { }
2720    void visit(const LiteralNode&amp; node) {
2721      json_eval_stack.push(&amp;node.value);
2722    }
2723    void visit(const JsonNode&amp; node) {
2724      if (json_additional_data.contains(node.ptr)) {
2725        json_eval_stack.push(&amp;(json_additional_data[node.ptr]));
2726      } else if (json_input-&gt;contains(node.ptr)) {
2727        json_eval_stack.push(&amp;(*json_input)[node.ptr]);
2728      } else {
2729        const auto function_data = function_storage.find_function(node.name, 0);
2730        if (function_data.operation == FunctionStorage::Operation::Callback) {
2731          Arguments empty_args {};
2732          const auto value = std::make_shared&lt;json&gt;(function_data.callback(empty_args));
2733          json_tmp_stack.push_back(value);
2734          json_eval_stack.push(value.get());
2735        } else {
2736          json_eval_stack.push(nullptr);
2737          not_found_stack.emplace(&amp;node);
2738        }
2739      }
2740    }
2741    void visit(const FunctionNode&amp; node) {
2742      std::shared_ptr&lt;json&gt; result_ptr;
2743      switch (node.operation) {
2744      case Op::Not: {
2745        const auto args = get_arguments&lt;1&gt;(node);
2746        result_ptr = std::make_shared&lt;json&gt;(!truthy(args[0]));
2747        json_tmp_stack.push_back(result_ptr);
2748        json_eval_stack.push(result_ptr.get());
2749      } break;
2750      case Op::And: {
2751        result_ptr = std::make_shared&lt;json&gt;(truthy(get_arguments&lt;1, 0&gt;(node)[0]) &amp;&amp; truthy(get_arguments&lt;1, 1&gt;(node)[0]));
2752        json_tmp_stack.push_back(result_ptr);
2753        json_eval_stack.push(result_ptr.get());
2754      } break;
2755      case Op::Or: {
2756        result_ptr = std::make_shared&lt;json&gt;(truthy(get_arguments&lt;1, 0&gt;(node)[0]) || truthy(get_arguments&lt;1, 1&gt;(node)[0]));
2757        json_tmp_stack.push_back(result_ptr);
2758        json_eval_stack.push(result_ptr.get());
2759      } break;
2760      case Op::In: {
2761        const auto args = get_arguments&lt;2&gt;(node);
2762        result_ptr = std::make_shared&lt;json&gt;(std::find(args[1]-&gt;begin(), args[1]-&gt;end(), *args[0]) != args[1]-&gt;end());
2763        json_tmp_stack.push_back(result_ptr);
2764        json_eval_stack.push(result_ptr.get());
2765      } break;
2766      case Op::Equal: {
2767        const auto args = get_arguments&lt;2&gt;(node);
2768        result_ptr = std::make_shared&lt;json&gt;(*args[0] == *args[1]);
2769        json_tmp_stack.push_back(result_ptr);
2770        json_eval_stack.push(result_ptr.get());
2771      } break;
2772      case Op::NotEqual: {
2773        const auto args = get_arguments&lt;2&gt;(node);
2774        result_ptr = std::make_shared&lt;json&gt;(*args[0] != *args[1]);
2775        json_tmp_stack.push_back(result_ptr);
2776        json_eval_stack.push(result_ptr.get());
2777      } break;
2778      case Op::Greater: {
2779        const auto args = get_arguments&lt;2&gt;(node);
2780        result_ptr = std::make_shared&lt;json&gt;(*args[0] &gt; *args[1]);
2781        json_tmp_stack.push_back(result_ptr);
2782        json_eval_stack.push(result_ptr.get());
2783      } break;
2784      case Op::GreaterEqual: {
2785        const auto args = get_arguments&lt;2&gt;(node);
2786        result_ptr = std::make_shared&lt;json&gt;(*args[0] &gt;= *args[1]);
2787        json_tmp_stack.push_back(result_ptr);
2788        json_eval_stack.push(result_ptr.get());
2789      } break;
2790      case Op::Less: {
2791        const auto args = get_arguments&lt;2&gt;(node);
2792        result_ptr = std::make_shared&lt;json&gt;(*args[0] &lt; *args[1]);
2793        json_tmp_stack.push_back(result_ptr);
2794        json_eval_stack.push(result_ptr.get());
2795      } break;
2796      case Op::LessEqual: {
2797        const auto args = get_arguments&lt;2&gt;(node);
2798        result_ptr = std::make_shared&lt;json&gt;(*args[0] &lt;= *args[1]);
2799        json_tmp_stack.push_back(result_ptr);
2800        json_eval_stack.push(result_ptr.get());
2801      } break;
2802      case Op::Add: {
2803        const auto args = get_arguments&lt;2&gt;(node);
2804        if (args[0]-&gt;is_string() &amp;&amp; args[1]-&gt;is_string()) {
2805          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get_ref&lt;const std::string&amp;&gt;() + args[1]-&gt;get_ref&lt;const std::string&amp;&gt;());
2806          json_tmp_stack.push_back(result_ptr);
2807        } else if (args[0]-&gt;is_number_integer() &amp;&amp; args[1]-&gt;is_number_integer()) {
2808          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;int&gt;() + args[1]-&gt;get&lt;int&gt;());
2809          json_tmp_stack.push_back(result_ptr);
2810        } else {
2811          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;double&gt;() + args[1]-&gt;get&lt;double&gt;());
2812          json_tmp_stack.push_back(result_ptr);
2813        }
2814        json_eval_stack.push(result_ptr.get());
2815      } break;
2816      case Op::Subtract: {
2817        const auto args = get_arguments&lt;2&gt;(node);
2818        if (args[0]-&gt;is_number_integer() &amp;&amp; args[1]-&gt;is_number_integer()) {
2819          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;int&gt;() - args[1]-&gt;get&lt;int&gt;());
2820          json_tmp_stack.push_back(result_ptr);
2821        } else {
2822          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;double&gt;() - args[1]-&gt;get&lt;double&gt;());
2823          json_tmp_stack.push_back(result_ptr);
2824        }
2825        json_eval_stack.push(result_ptr.get());
2826      } break;
2827      case Op::Multiplication: {
2828        const auto args = get_arguments&lt;2&gt;(node);
2829        if (args[0]-&gt;is_number_integer() &amp;&amp; args[1]-&gt;is_number_integer()) {
2830          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;int&gt;() * args[1]-&gt;get&lt;int&gt;());
2831          json_tmp_stack.push_back(result_ptr);
2832        } else {
2833          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;double&gt;() * args[1]-&gt;get&lt;double&gt;());
2834          json_tmp_stack.push_back(result_ptr);
2835        }
2836        json_eval_stack.push(result_ptr.get());
2837      } break;
2838      case Op::Division: {
2839        const auto args = get_arguments&lt;2&gt;(node);
2840        if (args[1]-&gt;get&lt;double&gt;() == 0) {
2841          throw_renderer_error(&quot;division by zero&quot;, node);
2842        }
2843        result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;double&gt;() / args[1]-&gt;get&lt;double&gt;());
2844        json_tmp_stack.push_back(result_ptr);
2845        json_eval_stack.push(result_ptr.get());
2846      } break;
2847      case Op::Power: {
2848        const auto args = get_arguments&lt;2&gt;(node);
2849        if (args[0]-&gt;is_number_integer() &amp;&amp; args[1]-&gt;get&lt;int&gt;() &gt;= 0) {
2850          int result = static_cast&lt;int&gt;(std::pow(args[0]-&gt;get&lt;int&gt;(), args[1]-&gt;get&lt;int&gt;()));
2851          result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2852          json_tmp_stack.push_back(result_ptr);
2853        } else {
2854          double result = std::pow(args[0]-&gt;get&lt;double&gt;(), args[1]-&gt;get&lt;int&gt;());
2855          result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2856          json_tmp_stack.push_back(result_ptr);
2857        }
2858        json_eval_stack.push(result_ptr.get());
2859      } break;
2860      case Op::Modulo: {
2861        const auto args = get_arguments&lt;2&gt;(node);
2862        result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;int&gt;() % args[1]-&gt;get&lt;int&gt;());
2863        json_tmp_stack.push_back(result_ptr);
2864        json_eval_stack.push(result_ptr.get());
2865      } break;
2866      case Op::AtId: {
2867        const auto container = get_arguments&lt;1, 0, false&gt;(node)[0];
2868        node.arguments[1]-&gt;accept(*this);
2869        if (not_found_stack.empty()) {
2870          throw_renderer_error(&quot;could not find element with given name&quot;, node);
2871        }
2872        const auto id_node = not_found_stack.top();
2873        not_found_stack.pop();
2874        json_eval_stack.pop();
2875        json_eval_stack.push(&amp;container-&gt;at(id_node-&gt;name));
2876      } break;
2877      case Op::At: {
2878        const auto args = get_arguments&lt;2&gt;(node);
2879        if (args[0]-&gt;is_object()) {
2880          json_eval_stack.push(&amp;args[0]-&gt;at(args[1]-&gt;get&lt;std::string&gt;()));
2881        } else {
2882          json_eval_stack.push(&amp;args[0]-&gt;at(args[1]-&gt;get&lt;int&gt;()));
2883        }
2884      } break;
2885      case Op::Default: {
2886        const auto test_arg = get_arguments&lt;1, 0, false&gt;(node)[0];
2887        json_eval_stack.push(test_arg ? test_arg : get_arguments&lt;1, 1&gt;(node)[0]);
2888      } break;
2889      case Op::DivisibleBy: {
2890        const auto args = get_arguments&lt;2&gt;(node);
2891        const int divisor = args[1]-&gt;get&lt;int&gt;();
2892        result_ptr = std::make_shared&lt;json&gt;((divisor != 0) &amp;&amp; (args[0]-&gt;get&lt;int&gt;() % divisor == 0));
2893        json_tmp_stack.push_back(result_ptr);
2894        json_eval_stack.push(result_ptr.get());
2895      } break;
2896      case Op::Even: {
2897        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;int&gt;() % 2 == 0);
2898        json_tmp_stack.push_back(result_ptr);
2899        json_eval_stack.push(result_ptr.get());
2900      } break;
2901      case Op::Exists: {
2902        auto &amp;&amp;name = get_arguments&lt;1&gt;(node)[0]-&gt;get_ref&lt;const std::string &amp;&gt;();
2903        result_ptr = std::make_shared&lt;json&gt;(json_input-&gt;contains(json::json_pointer(JsonNode::convert_dot_to_json_ptr(name))));
2904        json_tmp_stack.push_back(result_ptr);
2905        json_eval_stack.push(result_ptr.get());
2906      } break;
2907      case Op::ExistsInObject: {
2908        const auto args = get_arguments&lt;2&gt;(node);
2909        auto &amp;&amp;name = args[1]-&gt;get_ref&lt;const std::string &amp;&gt;();
2910        result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;find(name) != args[0]-&gt;end());
2911        json_tmp_stack.push_back(result_ptr);
2912        json_eval_stack.push(result_ptr.get());
2913      } break;
2914      case Op::First: {
2915        const auto result = &amp;get_arguments&lt;1&gt;(node)[0]-&gt;front();
2916        json_eval_stack.push(result);
2917      } break;
2918      case Op::Float: {
2919        result_ptr = std::make_shared&lt;json&gt;(std::stod(get_arguments&lt;1&gt;(node)[0]-&gt;get_ref&lt;const std::string &amp;&gt;()));
2920        json_tmp_stack.push_back(result_ptr);
2921        json_eval_stack.push(result_ptr.get());
2922      } break;
2923      case Op::Int: {
2924        result_ptr = std::make_shared&lt;json&gt;(std::stoi(get_arguments&lt;1&gt;(node)[0]-&gt;get_ref&lt;const std::string &amp;&gt;()));
2925        json_tmp_stack.push_back(result_ptr);
2926        json_eval_stack.push(result_ptr.get());
2927      } break;
2928      case Op::Last: {
2929        const auto result = &amp;get_arguments&lt;1&gt;(node)[0]-&gt;back();
2930        json_eval_stack.push(result);
2931      } break;
2932      case Op::Length: {
2933        const auto val = get_arguments&lt;1&gt;(node)[0];
2934        if (val-&gt;is_string()) {
2935          result_ptr = std::make_shared&lt;json&gt;(val-&gt;get_ref&lt;const std::string &amp;&gt;().length());
2936        } else {
2937          result_ptr = std::make_shared&lt;json&gt;(val-&gt;size());
2938        }
2939        json_tmp_stack.push_back(result_ptr);
2940        json_eval_stack.push(result_ptr.get());
2941      } break;
2942      case Op::Lower: {
2943        std::string result = get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;std::string&gt;();
2944        std::transform(result.begin(), result.end(), result.begin(), ::tolower);
2945        result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2946        json_tmp_stack.push_back(result_ptr);
2947        json_eval_stack.push(result_ptr.get());
2948      } break;
2949      case Op::Max: {
2950        const auto args = get_arguments&lt;1&gt;(node);
2951        const auto result = std::max_element(args[0]-&gt;begin(), args[0]-&gt;end());
2952        json_eval_stack.push(&amp;(*result));
2953      } break;
2954      case Op::Min: {
2955        const auto args = get_arguments&lt;1&gt;(node);
2956        const auto result = std::min_element(args[0]-&gt;begin(), args[0]-&gt;end());
2957        json_eval_stack.push(&amp;(*result));
2958      } break;
2959      case Op::Odd: {
2960        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;int&gt;() % 2 != 0);
2961        json_tmp_stack.push_back(result_ptr);
2962        json_eval_stack.push(result_ptr.get());
2963      } break;
2964      case Op::Range: {
2965        std::vector&lt;int&gt; result(get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;int&gt;());
2966        std::iota(result.begin(), result.end(), 0);
2967        result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2968        json_tmp_stack.push_back(result_ptr);
2969        json_eval_stack.push(result_ptr.get());
2970      } break;
2971      case Op::Round: {
2972        const auto args = get_arguments&lt;2&gt;(node);
2973        const int precision = args[1]-&gt;get&lt;int&gt;();
2974        const double result = std::round(args[0]-&gt;get&lt;double&gt;() * std::pow(10.0, precision)) / std::pow(10.0, precision);
2975        if(0==precision){
2976          result_ptr = std::make_shared&lt;json&gt;(int(result));
2977        }else{
2978          result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2979        }
2980        json_tmp_stack.push_back(result_ptr);
2981        json_eval_stack.push(result_ptr.get());
2982      } break;
2983      case Op::Sort: {
2984        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;std::vector&lt;json&gt;&gt;());
2985        std::sort(result_ptr-&gt;begin(), result_ptr-&gt;end());
2986        json_tmp_stack.push_back(result_ptr);
2987        json_eval_stack.push(result_ptr.get());
2988      } break;
2989      case Op::Upper: {
2990        std::string result = get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;std::string&gt;();
2991        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
2992        result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2993        json_tmp_stack.push_back(result_ptr);
2994        json_eval_stack.push(result_ptr.get());
2995      } break;
2996      case Op::IsBoolean: {
2997        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_boolean());
2998        json_tmp_stack.push_back(result_ptr);
2999        json_eval_stack.push(result_ptr.get());
3000      } break;
3001      case Op::IsNumber: {
3002        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_number());
3003        json_tmp_stack.push_back(result_ptr);
3004        json_eval_stack.push(result_ptr.get());
3005      } break;
3006      case Op::IsInteger: {
3007        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_number_integer());
3008        json_tmp_stack.push_back(result_ptr);
3009        json_eval_stack.push(result_ptr.get());
3010      } break;
3011      case Op::IsFloat: {
3012        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_number_float());
3013        json_tmp_stack.push_back(result_ptr);
3014        json_eval_stack.push(result_ptr.get());
3015      } break;
3016      case Op::IsObject: {
3017        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_object());
3018        json_tmp_stack.push_back(result_ptr);
3019        json_eval_stack.push(result_ptr.get());
3020      } break;
3021      case Op::IsArray: {
3022        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_array());
3023        json_tmp_stack.push_back(result_ptr);
3024        json_eval_stack.push(result_ptr.get());
3025      } break;
3026      case Op::IsString: {
3027        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_string());
3028        json_tmp_stack.push_back(result_ptr);
3029        json_eval_stack.push(result_ptr.get());
3030      } break;
3031      case Op::Callback: {
3032        auto args = get_argument_vector(node);
3033        result_ptr = std::make_shared&lt;json&gt;(node.callback(args));
3034        json_tmp_stack.push_back(result_ptr);
3035        json_eval_stack.push(result_ptr.get());
3036      } break;
3037      case Op::Super: {
3038        const auto args = get_argument_vector(node);
3039        const size_t old_level = current_level;
3040        const size_t level_diff = (args.size() == 1) ? args[0]-&gt;get&lt;int&gt;() : 1;
3041        const size_t level = current_level + level_diff;
3042        if (block_statement_stack.empty()) {
3043          throw_renderer_error(&quot;super() call is not within a block&quot;, node);
3044        }
3045        if (level &lt; 1 || level &gt; template_stack.size() - 1) {
3046          throw_renderer_error(&quot;level of super() call does not match parent templates (between 1 and &quot; + std::to_string(template_stack.size() - 1) + &quot;)&quot;, node);
3047        }
3048        const auto current_block_statement = block_statement_stack.back();
3049        const Template *new_template = template_stack.at(level);
3050        const Template *old_template = current_template;
3051        const auto block_it = new_template-&gt;block_storage.find(current_block_statement-&gt;name);
3052        if (block_it != new_template-&gt;block_storage.end()) {
3053          current_template = new_template;
3054          current_level = level;
3055          block_it-&gt;second-&gt;block.accept(*this);
3056          current_level = old_level;
3057          current_template = old_template;
3058        } else {
3059          throw_renderer_error(&quot;could not find block with name &#x27;&quot; + current_block_statement-&gt;name + &quot;&#x27;&quot;, node);
3060        }
3061        result_ptr = std::make_shared&lt;json&gt;(nullptr);
3062        json_tmp_stack.push_back(result_ptr);
3063        json_eval_stack.push(result_ptr.get());
3064      } break;
3065      case Op::Join: {
3066        const auto args = get_arguments&lt;2&gt;(node);
3067        const auto separator = args[1]-&gt;get&lt;std::string&gt;();
3068        std::ostringstream os;
3069        std::string sep;
3070        for (const auto&amp; value : *args[0]) {
3071          os &lt;&lt; sep;
3072          if (value.is_string()) {
3073            os &lt;&lt; value.get&lt;std::string&gt;(); 
3074          } else {
3075            os &lt;&lt; value;
3076          }
3077          sep = separator;
3078        }
3079        result_ptr = std::make_shared&lt;json&gt;(os.str());
3080        json_tmp_stack.push_back(result_ptr);
3081        json_eval_stack.push(result_ptr.get());
3082      } break;
3083      case Op::ParenLeft:
3084      case Op::ParenRight:
3085      case Op::None:
3086        break;
3087      }
3088    }
3089    void visit(const ExpressionListNode&amp; node) {
3090      print_json(eval_expression_list(node));
3091    }
3092    void visit(const StatementNode&amp;) { }
3093    void visit(const ForStatementNode&amp;) { }
3094    void visit(const ForArrayStatementNode&amp; node) {
3095      const auto result = eval_expression_list(node.condition);
3096      if (!result-&gt;is_array()) {
3097        throw_renderer_error(&quot;object must be an array&quot;, node);
3098      }
3099      if (!current_loop_data-&gt;empty()) {
3100        auto tmp = *current_loop_data; 
3101        (*current_loop_data)[&quot;parent&quot;] = std::move(tmp);
3102      }
3103      size_t index = 0;
3104      (*current_loop_data)[&quot;is_first&quot;] = true;
3105      (*current_loop_data)[&quot;is_last&quot;] = (result-&gt;size() &lt;= 1);
3106      for (auto it = result-&gt;begin(); it != result-&gt;end(); ++it) {
3107        json_additional_data[static_cast&lt;std::string&gt;(node.value)] = *it;
3108        (*current_loop_data)[&quot;index&quot;] = index;
3109        (*current_loop_data)[&quot;index1&quot;] = index + 1;
3110        if (index == 1) {
3111          (*current_loop_data)[&quot;is_first&quot;] = false;
3112        }
3113        if (index == result-&gt;size() - 1) {
3114          (*current_loop_data)[&quot;is_last&quot;] = true;
3115        }
3116        node.body.accept(*this);
3117        ++index;
3118      }
3119      json_additional_data[static_cast&lt;std::string&gt;(node.value)].clear();
3120      if (!(*current_loop_data)[&quot;parent&quot;].empty()) {
3121        const auto tmp = (*current_loop_data)[&quot;parent&quot;];
3122        *current_loop_data = std::move(tmp);
3123      } else {
3124        current_loop_data = &amp;json_additional_data[&quot;loop&quot;];
3125      }
3126    }
3127    void visit(const ForObjectStatementNode&amp; node) {
3128      const auto result = eval_expression_list(node.condition);
3129      if (!result-&gt;is_object()) {
3130        throw_renderer_error(&quot;object must be an object&quot;, node);
3131      }
3132      if (!current_loop_data-&gt;empty()) {
3133        (*current_loop_data)[&quot;parent&quot;] = std::move(*current_loop_data);
3134      }
3135      size_t index = 0;
3136      (*current_loop_data)[&quot;is_first&quot;] = true;
3137      (*current_loop_data)[&quot;is_last&quot;] = (result-&gt;size() &lt;= 1);
3138      for (auto it = result-&gt;begin(); it != result-&gt;end(); ++it) {
3139        json_additional_data[static_cast&lt;std::string&gt;(node.key)] = it.key();
3140        json_additional_data[static_cast&lt;std::string&gt;(node.value)] = it.value();
3141        (*current_loop_data)[&quot;index&quot;] = index;
3142        (*current_loop_data)[&quot;index1&quot;] = index + 1;
3143        if (index == 1) {
3144          (*current_loop_data)[&quot;is_first&quot;] = false;
3145        }
3146        if (index == result-&gt;size() - 1) {
3147          (*current_loop_data)[&quot;is_last&quot;] = true;
3148        }
3149        node.body.accept(*this);
3150        ++index;
3151      }
3152      json_additional_data[static_cast&lt;std::string&gt;(node.key)].clear();
3153      json_additional_data[static_cast&lt;std::string&gt;(node.value)].clear();
3154      if (!(*current_loop_data)[&quot;parent&quot;].empty()) {
3155        *current_loop_data = std::move((*current_loop_data)[&quot;parent&quot;]);
3156      } else {
3157        current_loop_data = &amp;json_additional_data[&quot;loop&quot;];
3158      }
3159    }
3160    void visit(const IfStatementNode&amp; node) {
3161      const auto result = eval_expression_list(node.condition);
3162      if (truthy(result.get())) {
3163        node.true_statement.accept(*this);
3164      } else if (node.has_false_statement) {
3165        node.false_statement.accept(*this);
3166      }
3167    }
3168    void visit(const IncludeStatementNode&amp; node) {
3169      auto sub_renderer = Renderer(config, template_storage, function_storage);
3170      const auto included_template_it = template_storage.find(node.file);
3171      if (included_template_it != template_storage.end()) {
3172        sub_renderer.render_to(*output_stream, included_template_it-&gt;second, *json_input, &amp;json_additional_data);
3173      } else if (config.throw_at_missing_includes) {
3174        throw_renderer_error(&quot;include &#x27;&quot; + node.file + &quot;&#x27; not found&quot;, node);
3175      }
3176    }
3177    void visit(const ExtendsStatementNode&amp; node) {
3178      const auto included_template_it = template_storage.find(node.file);
3179      if (included_template_it != template_storage.end()) {
3180        const Template *parent_template = &amp;included_template_it-&gt;second;
3181        render_to(*output_stream, *parent_template, *json_input, &amp;json_additional_data);
3182        break_rendering = true;
3183      } else if (config.throw_at_missing_includes) {
3184        throw_renderer_error(&quot;extends &#x27;&quot; + node.file + &quot;&#x27; not found&quot;, node);
3185      }
3186    }
3187    void visit(const BlockStatementNode&amp; node) {
3188      const size_t old_level = current_level;
3189      current_level = 0;
3190      current_template = template_stack.front();
3191      const auto block_it = current_template-&gt;block_storage.find(node.name);
3192      if (block_it != current_template-&gt;block_storage.end()) {
3193        block_statement_stack.emplace_back(&amp;node);
3194        block_it-&gt;second-&gt;block.accept(*this);
3195        block_statement_stack.pop_back(); 
3196      }
3197      current_level = old_level;
3198      current_template = template_stack.back();
3199    }
3200    void visit(const SetStatementNode&amp; node) {
3201      std::string ptr = node.key;
3202      replace_substring(ptr, &quot;.&quot;, &quot;/&quot;);
3203      ptr = &quot;/&quot; + ptr;
3204      json_additional_data[json::json_pointer(ptr)] = *eval_expression_list(node.expression);
3205    }
3206  public:
3207    Renderer(const RenderConfig&amp; config, const TemplateStorage &amp;template_storage, const FunctionStorage &amp;function_storage)
3208        : config(config), template_storage(template_storage), function_storage(function_storage) { }
3209    void render_to(std::ostream &amp;os, const Template &amp;tmpl, const json &amp;data, json *loop_data = nullptr) {
3210      output_stream = &amp;os;
3211      current_template = &amp;tmpl;
3212      json_input = &amp;data;
3213      if (loop_data) {
3214        json_additional_data = *loop_data;
3215        current_loop_data = &amp;json_additional_data[&quot;loop&quot;];
3216      }
3217      template_stack.emplace_back(current_template);
3218      current_template-&gt;root.accept(*this);
3219      json_tmp_stack.clear();
3220    }
3221  };
3222  } 
3223  #endif 
3224  namespace inja {
3225  class Environment {
3226    std::string input_path;
3227    std::string output_path;
3228    LexerConfig lexer_config;
3229    ParserConfig parser_config;
3230    RenderConfig render_config;
3231    FunctionStorage function_storage;
3232    TemplateStorage template_storage;
3233  public:
3234    Environment() : Environment(&quot;&quot;) {}
3235    explicit Environment(const std::string &amp;global_path) : input_path(global_path), output_path(global_path) {}
3236    Environment(const std::string &amp;input_path, const std::string &amp;output_path)
3237        : input_path(input_path), output_path(output_path) {}
3238    void set_statement(const std::string &amp;open, const std::string &amp;close) {
3239      lexer_config.statement_open = open;
3240      lexer_config.statement_open_no_lstrip = open + &quot;+&quot;;
3241      lexer_config.statement_open_force_lstrip = open + &quot;-&quot;;
3242      lexer_config.statement_close = close;
3243      lexer_config.statement_close_force_rstrip = &quot;-&quot; + close;
3244      lexer_config.update_open_chars();
3245    }
3246    void set_line_statement(const std::string &amp;open) {
3247      lexer_config.line_statement = open;
3248      lexer_config.update_open_chars();
3249    }
3250    void set_expression(const std::string &amp;open, const std::string &amp;close) {
3251      lexer_config.expression_open = open;
3252      lexer_config.expression_open_force_lstrip = open + &quot;-&quot;;
3253      lexer_config.expression_close = close;
3254      lexer_config.expression_close_force_rstrip = &quot;-&quot; + close;
3255      lexer_config.update_open_chars();
3256    }
3257    void set_comment(const std::string &amp;open, const std::string &amp;close) {
3258      lexer_config.comment_open = open;
3259      lexer_config.comment_open_force_lstrip = open + &quot;-&quot;;
3260      lexer_config.comment_close = close;
3261      lexer_config.comment_close_force_rstrip = &quot;-&quot; + close;
3262      lexer_config.update_open_chars();
3263    }
3264    void set_trim_blocks(bool trim_blocks) {
3265      lexer_config.trim_blocks = trim_blocks;
3266    }
3267    void set_lstrip_blocks(bool lstrip_blocks) {
3268      lexer_config.lstrip_blocks = lstrip_blocks;
3269    }
3270    void set_search_included_templates_in_files(bool search_in_files) {
3271      parser_config.search_included_templates_in_files = search_in_files;
3272    }
3273    void set_throw_at_missing_includes(bool will_throw) {
3274      render_config.throw_at_missing_includes = will_throw;
3275    }
3276    Template parse(nonstd::string_view input) {
3277      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3278      return parser.parse(input);
3279    }
3280    Template parse_template(const std::string &amp;filename) {
3281      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3282      auto result = Template(parser.load_file(input_path + static_cast&lt;std::string&gt;(filename)));
3283      parser.parse_into_template(result, input_path + static_cast&lt;std::string&gt;(filename));
3284      return result;
3285    }
3286    Template parse_file(const std::string &amp;filename) {
3287      return parse_template(filename);
3288    }
3289    std::string render(nonstd::string_view input, const json &amp;data) { return render(parse(input), data); }
3290    std::string render(const Template &amp;tmpl, const json &amp;data) {
3291      std::stringstream os;
3292      render_to(os, tmpl, data);
3293      return os.str();
3294    }
3295    std::string render_file(const std::string &amp;filename, const json &amp;data) {
3296      return render(parse_template(filename), data);
3297    }
3298    std::string render_file_with_json_file(const std::string &amp;filename, const std::string &amp;filename_data) {
3299      const json data = load_json(filename_data);
3300      return render_file(filename, data);
3301    }
3302    void write(const std::string &amp;filename, const json &amp;data, const std::string &amp;filename_out) {
3303      std::ofstream file(output_path + filename_out);
<span onclick='openModal()' class='match'>3304      file &lt;&lt; render_file(filename, data);
3305      file.close();
3306    }
3307    void write(const Template &amp;temp, const json &amp;data, const std::string &amp;filename_out) {
</span>3308      std::ofstream file(output_path + filename_out);
3309      file &lt;&lt; render(temp, data);
3310      file.close();
3311    }
3312    void write_with_json_file(const std::string &amp;filename, const std::string &amp;filename_data,
3313                              const std::string &amp;filename_out) {
3314      const json data = load_json(filename_data);
3315      write(filename, data, filename_out);
3316    }
3317    void write_with_json_file(const Template &amp;temp, const std::string &amp;filename_data, const std::string &amp;filename_out) {
3318      const json data = load_json(filename_data);
3319      write(temp, data, filename_out);
3320    }
3321    std::ostream &amp;render_to(std::ostream &amp;os, const Template &amp;tmpl, const json &amp;data) {
3322      Renderer(render_config, template_storage, function_storage).render_to(os, tmpl, data);
3323      return os;
3324    }
3325    std::string load_file(const std::string &amp;filename) {
3326      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3327      return parser.load_file(input_path + filename);
3328    }
3329    json load_json(const std::string &amp;filename) {
3330      std::ifstream file;
3331      file.open(input_path + filename);
3332      if (file.fail()) {
3333        INJA_THROW(FileError(&quot;failed accessing file at &#x27;&quot; + input_path + filename + &quot;&#x27;&quot;));
3334      }
3335      json j;
3336      file &gt;&gt; j;
3337      return j;
3338    }
3339    void add_callback(const std::string &amp;name, const CallbackFunction &amp;callback) {
3340      add_callback(name, -1, callback);
3341    }
3342    void add_void_callback(const std::string &amp;name, const VoidCallbackFunction &amp;callback) {
3343      add_void_callback(name, -1, callback);
3344    }
3345    void add_callback(const std::string &amp;name, int num_args, const CallbackFunction &amp;callback) {
3346      function_storage.add_callback(name, num_args, callback);
3347    }
3348    void add_void_callback(const std::string &amp;name, int num_args, const VoidCallbackFunction &amp;callback) {
3349      function_storage.add_callback(name, num_args, [callback](Arguments&amp; args) { callback(args); return json(); });
3350    }
3351    void include_template(const std::string &amp;name, const Template &amp;tmpl) {
3352      template_storage[name] = tmpl;
3353    }
3354    void set_include_callback(const std::function&lt;Template(const std::string&amp;, const std::string&amp;)&gt;&amp; callback) {
3355      parser_config.include_callback = callback;
3356    }
3357  };
3358  inline std::string render(nonstd::string_view input, const json &amp;data) {
3359    return Environment().render(input, data);
3360  }
3361  inline void render_to(std::ostream &amp;os, nonstd::string_view input, const json &amp;data) {
3362    Environment env;
3363    env.render_to(os, env.parse(input), data);
3364  }
3365  } 
3366  #endif 
3367  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-inja.hpp</h3>
            <pre><code>1  #ifndef INCLUDE_INJA_INJA_HPP_
2  #define INCLUDE_INJA_INJA_HPP_
3  #include &lt;nlohmann/json.hpp&gt;
4  namespace inja {
5  #ifndef INJA_DATA_TYPE
6    using json = nlohmann::json;
7  #else
8    using json = INJA_DATA_TYPE;
9  #endif
10  }
11  #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) &amp;&amp; !defined(INJA_NOEXCEPTION)
12    #ifndef INJA_THROW
13      #define INJA_THROW(exception) throw exception
14    #endif
15  #else
16    #include &lt;cstdlib&gt;
17    #ifndef INJA_THROW
18      #define INJA_THROW(exception) std::abort(); std::ignore = exception
19    #endif
20    #ifndef INJA_NOEXCEPTION
21      #define INJA_NOEXCEPTION
22    #endif
23  #endif
24  #ifndef INCLUDE_INJA_ENVIRONMENT_HPP_
25  #define INCLUDE_INJA_ENVIRONMENT_HPP_
26  #include &lt;fstream&gt;
27  #include &lt;iostream&gt;
28  #include &lt;memory&gt;
29  #include &lt;sstream&gt;
30  #include &lt;string&gt;
31  #ifndef INCLUDE_INJA_CONFIG_HPP_
32  #define INCLUDE_INJA_CONFIG_HPP_
33  #include &lt;functional&gt;
34  #include &lt;string&gt;
35  #ifndef NONSTD_SV_LITE_H_INCLUDED
36  #define NONSTD_SV_LITE_H_INCLUDED
37  #define string_view_lite_MAJOR 1
38  #define string_view_lite_MINOR 4
39  #define string_view_lite_PATCH 0
40  #define string_view_lite_VERSION                                                                                       \
41    nssv_STRINGIFY(string_view_lite_MAJOR) &quot;.&quot; nssv_STRINGIFY(string_view_lite_MINOR) &quot;.&quot; nssv_STRINGIFY(                \
42        string_view_lite_PATCH)
43  #define nssv_STRINGIFY(x) nssv_STRINGIFY_(x)
44  #define nssv_STRINGIFY_(x) #x
45  #define nssv_STRING_VIEW_DEFAULT 0
46  #define nssv_STRING_VIEW_NONSTD 1
47  #define nssv_STRING_VIEW_STD 2
48  #if !defined(nssv_CONFIG_SELECT_STRING_VIEW)
49  #define nssv_CONFIG_SELECT_STRING_VIEW (nssv_HAVE_STD_STRING_VIEW ? nssv_STRING_VIEW_STD : nssv_STRING_VIEW_NONSTD)
50  #endif
51  #if defined(nssv_CONFIG_SELECT_STD_STRING_VIEW) || defined(nssv_CONFIG_SELECT_NONSTD_STRING_VIEW)
52  #error nssv_CONFIG_SELECT_STD_STRING_VIEW and nssv_CONFIG_SELECT_NONSTD_STRING_VIEW are deprecated and removed, please use nssv_CONFIG_SELECT_STRING_VIEW=nssv_STRING_VIEW_...
53  #endif
54  #ifndef nssv_CONFIG_STD_SV_OPERATOR
55  #define nssv_CONFIG_STD_SV_OPERATOR 0
56  #endif
57  #ifndef nssv_CONFIG_USR_SV_OPERATOR
58  #define nssv_CONFIG_USR_SV_OPERATOR 1
59  #endif
60  #ifdef nssv_CONFIG_CONVERSION_STD_STRING
61  #define nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS nssv_CONFIG_CONVERSION_STD_STRING
62  #define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS nssv_CONFIG_CONVERSION_STD_STRING
63  #endif
64  #ifndef nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS
65  #define nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS 1
66  #endif
67  #ifndef nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
68  #define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS 1
69  #endif
70  #ifndef nssv_CONFIG_NO_EXCEPTIONS
71  #if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)
72  #define nssv_CONFIG_NO_EXCEPTIONS 0
73  #else
74  #define nssv_CONFIG_NO_EXCEPTIONS 1
75  #endif
76  #endif
77  #ifndef nssv_CPLUSPLUS
78  #if defined(_MSVC_LANG) &amp;&amp; !defined(__clang__)
79  #define nssv_CPLUSPLUS (_MSC_VER == 1900 ? 201103L : _MSVC_LANG)
80  #else
81  #define nssv_CPLUSPLUS __cplusplus
82  #endif
83  #endif
84  #define nssv_CPP98_OR_GREATER (nssv_CPLUSPLUS &gt;= 199711L)
85  #define nssv_CPP11_OR_GREATER (nssv_CPLUSPLUS &gt;= 201103L)
86  #define nssv_CPP11_OR_GREATER_ (nssv_CPLUSPLUS &gt;= 201103L)
87  #define nssv_CPP14_OR_GREATER (nssv_CPLUSPLUS &gt;= 201402L)
88  #define nssv_CPP17_OR_GREATER (nssv_CPLUSPLUS &gt;= 201703L)
89  #define nssv_CPP20_OR_GREATER (nssv_CPLUSPLUS &gt;= 202000L)
90  #if nssv_CPP17_OR_GREATER &amp;&amp; defined(__has_include)
91  #if __has_include(&lt;string_view&gt; )
92  #define nssv_HAVE_STD_STRING_VIEW 1
93  #else
94  #define nssv_HAVE_STD_STRING_VIEW 0
95  #endif
96  #else
97  #define nssv_HAVE_STD_STRING_VIEW 0
98  #endif
99  #define nssv_USES_STD_STRING_VIEW                                                                                      \
100    ((nssv_CONFIG_SELECT_STRING_VIEW == nssv_STRING_VIEW_STD) ||                                                         \
101     ((nssv_CONFIG_SELECT_STRING_VIEW == nssv_STRING_VIEW_DEFAULT) &amp;&amp; nssv_HAVE_STD_STRING_VIEW))
102  #define nssv_HAVE_STARTS_WITH (nssv_CPP20_OR_GREATER || !nssv_USES_STD_STRING_VIEW)
103  #define nssv_HAVE_ENDS_WITH nssv_HAVE_STARTS_WITH
104  #if nssv_USES_STD_STRING_VIEW
105  #include &lt;string_view&gt;
106  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
107  namespace nonstd {
108  template &lt;class CharT, class Traits, class Allocator = std::allocator&lt;CharT&gt;&gt;
109  std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(std::basic_string_view&lt;CharT, Traits&gt; v,
110                                                        Allocator const &amp;a = Allocator()) {
111    return std::basic_string&lt;CharT, Traits, Allocator&gt;(v.begin(), v.end(), a);
112  }
113  template &lt;class CharT, class Traits, class Allocator&gt;
114  std::basic_string_view&lt;CharT, Traits&gt; to_string_view(std::basic_string&lt;CharT, Traits, Allocator&gt; const &amp;s) {
115    return std::basic_string_view&lt;CharT, Traits&gt;(s.data(), s.size());
116  }
117  #if nssv_CONFIG_STD_SV_OPERATOR
118  using namespace std::literals::string_view_literals;
119  #endif
120  #if nssv_CONFIG_USR_SV_OPERATOR
121  inline namespace literals {
122  inline namespace string_view_literals {
123  constexpr std::string_view operator&quot;&quot; _sv(const char *str, size_t len) noexcept 
124  {
125    return std::string_view {str, len};
126  }
127  constexpr std::u16string_view operator&quot;&quot; _sv(const char16_t *str, size_t len) noexcept 
128  {
129    return std::u16string_view {str, len};
130  }
131  constexpr std::u32string_view operator&quot;&quot; _sv(const char32_t *str, size_t len) noexcept 
132  {
133    return std::u32string_view {str, len};
134  }
135  constexpr std::wstring_view operator&quot;&quot; _sv(const wchar_t *str, size_t len) noexcept 
136  {
137    return std::wstring_view {str, len};
138  }
139  } 
140  } 
141  #endif 
142  } 
143  #endif 
144  namespace nonstd {
145  using std::basic_string_view;
146  using std::string_view;
147  using std::u16string_view;
148  using std::u32string_view;
149  using std::wstring_view;
150  using std::operator==;
151  using std::operator!=;
152  using std::operator&lt;;
153  using std::operator&lt;=;
154  using std::operator&gt;;
155  using std::operator&gt;=;
156  using std::operator&lt;&lt;;
157  } 
158  #else 
159  #if defined(_MSC_VER) &amp;&amp; !defined(__clang__)
160  #define nssv_COMPILER_MSVC_VER (_MSC_VER)
161  #define nssv_COMPILER_MSVC_VERSION (_MSC_VER / 10 - 10 * (5 + (_MSC_VER &lt; 1900)))
162  #else
163  #define nssv_COMPILER_MSVC_VER 0
164  #define nssv_COMPILER_MSVC_VERSION 0
165  #endif
166  #define nssv_COMPILER_VERSION(major, minor, patch) (10 * (10 * (major) + (minor)) + (patch))
167  #if defined(__clang__)
168  #define nssv_COMPILER_CLANG_VERSION nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)
169  #else
170  #define nssv_COMPILER_CLANG_VERSION 0
171  #endif
172  #if defined(__GNUC__) &amp;&amp; !defined(__clang__)
173  #define nssv_COMPILER_GNUC_VERSION nssv_COMPILER_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
174  #else
175  #define nssv_COMPILER_GNUC_VERSION 0
176  #endif
177  #define nssv_BETWEEN(v, lo, hi) ((lo) &lt;= (v) &amp;&amp; (v) &lt; (hi))
178  #ifdef _HAS_CPP0X
179  #define nssv_HAS_CPP0X _HAS_CPP0X
180  #else
181  #define nssv_HAS_CPP0X 0
182  #endif
183  #if nssv_COMPILER_MSVC_VER &gt;= 1900
184  #undef nssv_CPP11_OR_GREATER
185  #define nssv_CPP11_OR_GREATER 1
186  #endif
187  #define nssv_CPP11_90 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1500)
188  #define nssv_CPP11_100 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1600)
189  #define nssv_CPP11_110 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1700)
190  #define nssv_CPP11_120 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1800)
191  #define nssv_CPP11_140 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1900)
192  #define nssv_CPP11_141 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER &gt;= 1910)
193  #define nssv_CPP14_000 (nssv_CPP14_OR_GREATER)
194  #define nssv_CPP17_000 (nssv_CPP17_OR_GREATER)
195  #define nssv_HAVE_CONSTEXPR_11 nssv_CPP11_140
196  #define nssv_HAVE_EXPLICIT_CONVERSION nssv_CPP11_140
197  #define nssv_HAVE_INLINE_NAMESPACE nssv_CPP11_140
198  #define nssv_HAVE_NOEXCEPT nssv_CPP11_140
199  #define nssv_HAVE_NULLPTR nssv_CPP11_100
200  #define nssv_HAVE_REF_QUALIFIER nssv_CPP11_140
201  #define nssv_HAVE_UNICODE_LITERALS nssv_CPP11_140
202  #define nssv_HAVE_USER_DEFINED_LITERALS nssv_CPP11_140
203  #define nssv_HAVE_WCHAR16_T nssv_CPP11_100
204  #define nssv_HAVE_WCHAR32_T nssv_CPP11_100
205  #if !((nssv_CPP11_OR_GREATER &amp;&amp; nssv_COMPILER_CLANG_VERSION) || nssv_BETWEEN(nssv_COMPILER_CLANG_VERSION, 300, 400))
206  #define nssv_HAVE_STD_DEFINED_LITERALS nssv_CPP11_140
207  #else
208  #define nssv_HAVE_STD_DEFINED_LITERALS 0
209  #endif
210  #define nssv_HAVE_CONSTEXPR_14 nssv_CPP14_000
211  #define nssv_HAVE_NODISCARD nssv_CPP17_000
212  #define nssv_HAVE_STD_HASH nssv_CPP11_120
213  #if nssv_HAVE_CONSTEXPR_11
214  #define nssv_constexpr constexpr
215  #else
216  #define nssv_constexpr &amp;bsol;*constexpr*/
217  #endif
218  #if nssv_HAVE_CONSTEXPR_14
219  #define nssv_constexpr14 constexpr
220  #else
221  #define nssv_constexpr14 &amp;bsol;*constexpr*/
222  #endif
223  #if nssv_HAVE_EXPLICIT_CONVERSION
224  #define nssv_explicit explicit
225  #else
226  #define nssv_explicit &amp;bsol;*explicit*/
227  #endif
228  #if nssv_HAVE_INLINE_NAMESPACE
229  #define nssv_inline_ns inline
230  #else
231  #define nssv_inline_ns &amp;bsol;*inline*/
232  #endif
233  #if nssv_HAVE_NOEXCEPT
234  #define nssv_noexcept noexcept
235  #else
236  #define nssv_noexcept &amp;bsol;*noexcept*/
237  #endif
238  #if nssv_HAVE_NULLPTR
239  #define nssv_nullptr nullptr
240  #else
241  #define nssv_nullptr NULL
242  #endif
243  #if nssv_HAVE_NODISCARD
244  #define nssv_nodiscard [[nodiscard]]
245  #else
246  #define nssv_nodiscard &amp;bsol;*[[nodiscard]]*/
247  #endif
248  #include &lt;algorithm&gt;
249  #include &lt;cassert&gt;
250  #include &lt;iterator&gt;
251  #include &lt;limits&gt;
252  #include &lt;ostream&gt;
253  #include &lt;string&gt; 
254  #if !nssv_CONFIG_NO_EXCEPTIONS
255  #include &lt;stdexcept&gt;
256  #endif
257  #if nssv_CPP11_OR_GREATER
258  #include &lt;type_traits&gt;
259  #endif
260  #if defined(__clang__)
261  #pragma clang diagnostic ignored &quot;-Wreserved-user-defined-literal&quot;
262  #pragma clang diagnostic push
263  #pragma clang diagnostic ignored &quot;-Wuser-defined-literals&quot;
264  #elif defined(__GNUC__)
265  #pragma GCC diagnostic push
266  #pragma GCC diagnostic ignored &quot;-Wliteral-suffix&quot;
267  #endif 
268  #if nssv_COMPILER_MSVC_VERSION &gt;= 140
269  #define nssv_SUPPRESS_MSGSL_WARNING(expr) [[gsl::suppress(expr)]]
270  #define nssv_SUPPRESS_MSVC_WARNING(code, descr) __pragma(warning(suppress : code))
271  #define nssv_DISABLE_MSVC_WARNINGS(codes) __pragma(warning(push)) __pragma(warning(disable : codes))
272  #else
273  #define nssv_SUPPRESS_MSGSL_WARNING(expr)
274  #define nssv_SUPPRESS_MSVC_WARNING(code, descr)
275  #define nssv_DISABLE_MSVC_WARNINGS(codes)
276  #endif
277  #if defined(__clang__)
278  #define nssv_RESTORE_WARNINGS() _Pragma(&quot;clang diagnostic pop&quot;)
279  #elif defined(__GNUC__)
280  #define nssv_RESTORE_WARNINGS() _Pragma(&quot;GCC diagnostic pop&quot;)
281  #elif nssv_COMPILER_MSVC_VERSION &gt;= 140
282  #define nssv_RESTORE_WARNINGS() __pragma(warning(pop))
283  #else
284  #define nssv_RESTORE_WARNINGS()
285  #endif
286  nssv_DISABLE_MSVC_WARNINGS(4455 26481 26472)
287      namespace nonstd {
288    namespace sv_lite {
289  #if nssv_CPP11_OR_GREATER
290    namespace detail {
291    template &lt;typename CharT&gt; inline constexpr std::size_t length(CharT *s, std::size_t result = 0) {
292      return *s == &#x27;\0&#x27; ? result : length(s + 1, result + 1);
293    }
294    } 
295  #endif 
296    template &lt;class CharT, class Traits = std::char_traits&lt;CharT&gt;&gt; class basic_string_view;
297    template &lt;class CharT, class Traits &amp;bsol;* = std::char_traits&lt;CharT&gt; */
298              &gt;
299    class basic_string_view {
300    public:
301      typedef Traits traits_type;
302      typedef CharT value_type;
303      typedef CharT *pointer;
304      typedef CharT const *const_pointer;
305      typedef CharT &amp;reference;
306      typedef CharT const &amp;const_reference;
307      typedef const_pointer iterator;
308      typedef const_pointer const_iterator;
309      typedef std::reverse_iterator&lt;const_iterator&gt; reverse_iterator;
310      typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
311      typedef std::size_t size_type;
312      typedef std::ptrdiff_t difference_type;
313      nssv_constexpr basic_string_view() nssv_noexcept : data_(nssv_nullptr), size_(0) {}
314  #if nssv_CPP11_OR_GREATER
315      nssv_constexpr basic_string_view(basic_string_view const &amp;other) nssv_noexcept = default;
316  #else
317      nssv_constexpr basic_string_view(basic_string_view const &amp;other) nssv_noexcept : data_(other.data_),
318                                                                                       size_(other.size_) {}
319  #endif
320      nssv_constexpr basic_string_view(CharT const *s, size_type count) nssv_noexcept 
321          : data_(s),
322            size_(count) {}
323      nssv_constexpr basic_string_view(CharT const *s) nssv_noexcept 
324          : data_(s)
325  #if nssv_CPP17_OR_GREATER
326          ,
327            size_(Traits::length(s))
328  #elif nssv_CPP11_OR_GREATER
329          ,
330            size_(detail::length(s))
331  #else
332          ,
333            size_(Traits::length(s))
334  #endif
335      {
336      }
337  #if nssv_CPP11_OR_GREATER
338      nssv_constexpr14 basic_string_view &amp;operator=(basic_string_view const &amp;other) nssv_noexcept = default;
339  #else
340      nssv_constexpr14 basic_string_view &amp;operator=(basic_string_view const &amp;other) nssv_noexcept {
341        data_ = other.data_;
342        size_ = other.size_;
343        return *this;
344      }
345  #endif
346      nssv_constexpr const_iterator begin() const nssv_noexcept { return data_; }
347      nssv_constexpr const_iterator end() const nssv_noexcept { return data_ + size_; }
348      nssv_constexpr const_iterator cbegin() const nssv_noexcept { return begin(); }
349      nssv_constexpr const_iterator cend() const nssv_noexcept { return end(); }
350      nssv_constexpr const_reverse_iterator rbegin() const nssv_noexcept { return const_reverse_iterator(end()); }
351      nssv_constexpr const_reverse_iterator rend() const nssv_noexcept { return const_reverse_iterator(begin()); }
352      nssv_constexpr const_reverse_iterator crbegin() const nssv_noexcept { return rbegin(); }
353      nssv_constexpr const_reverse_iterator crend() const nssv_noexcept { return rend(); }
354      nssv_constexpr size_type size() const nssv_noexcept { return size_; }
355      nssv_constexpr size_type length() const nssv_noexcept { return size_; }
356      nssv_constexpr size_type max_size() const nssv_noexcept { return (std::numeric_limits&lt;size_type&gt;::max)(); }
357      nssv_nodiscard nssv_constexpr bool empty() const nssv_noexcept { return 0 == size_; }
358      nssv_constexpr const_reference operator[](size_type pos) const { return data_at(pos); }
359      nssv_constexpr14 const_reference at(size_type pos) const {
360  #if nssv_CONFIG_NO_EXCEPTIONS
361        assert(pos &lt; size());
362  #else
363        if (pos &gt;= size()) {
364          throw std::out_of_range(&quot;nonstd::string_view::at()&quot;);
365        }
366  #endif
367        return data_at(pos);
368      }
369      nssv_constexpr const_reference front() const { return data_at(0); }
370      nssv_constexpr const_reference back() const { return data_at(size() - 1); }
371      nssv_constexpr const_pointer data() const nssv_noexcept { return data_; }
372      nssv_constexpr14 void remove_prefix(size_type n) {
373        assert(n &lt;= size());
374        data_ += n;
375        size_ -= n;
376      }
377      nssv_constexpr14 void remove_suffix(size_type n) {
378        assert(n &lt;= size());
379        size_ -= n;
380      }
381      nssv_constexpr14 void swap(basic_string_view &amp;other) nssv_noexcept {
382        using std::swap;
383        swap(data_, other.data_);
384        swap(size_, other.size_);
385      }
386      size_type copy(CharT *dest, size_type n, size_type pos = 0) const {
387  #if nssv_CONFIG_NO_EXCEPTIONS
388        assert(pos &lt;= size());
389  #else
390        if (pos &gt; size()) {
391          throw std::out_of_range(&quot;nonstd::string_view::copy()&quot;);
392        }
393  #endif
394        const size_type rlen = (std::min)(n, size() - pos);
395        (void)Traits::copy(dest, data() + pos, rlen);
396        return rlen;
397      }
398      nssv_constexpr14 basic_string_view substr(size_type pos = 0, size_type n = npos) const {
399  #if nssv_CONFIG_NO_EXCEPTIONS
400        assert(pos &lt;= size());
401  #else
402        if (pos &gt; size()) {
403          throw std::out_of_range(&quot;nonstd::string_view::substr()&quot;);
404        }
405  #endif
406        return basic_string_view(data() + pos, (std::min)(n, size() - pos));
407      }
408      nssv_constexpr14 int compare(basic_string_view other) const nssv_noexcept 
409      {
410        if (const int result = Traits::compare(data(), other.data(), (std::min)(size(), other.size()))) {
411          return result;
412        }
413        return size() == other.size() ? 0 : size() &lt; other.size() ? -1 : 1;
414      }
415      nssv_constexpr int compare(size_type pos1, size_type n1, basic_string_view other) const 
416      {
417        return substr(pos1, n1).compare(other);
418      }
419      nssv_constexpr int compare(size_type pos1, size_type n1, basic_string_view other, size_type pos2,
420                                 size_type n2) const 
421      {
422        return substr(pos1, n1).compare(other.substr(pos2, n2));
423      }
424      nssv_constexpr int compare(CharT const *s) const 
425      {
426        return compare(basic_string_view(s));
427      }
428      nssv_constexpr int compare(size_type pos1, size_type n1, CharT const *s) const 
429      {
430        return substr(pos1, n1).compare(basic_string_view(s));
431      }
432      nssv_constexpr int compare(size_type pos1, size_type n1, CharT const *s, size_type n2) const 
433      {
434        return substr(pos1, n1).compare(basic_string_view(s, n2));
435      }
436      nssv_constexpr bool starts_with(basic_string_view v) const nssv_noexcept 
437      {
438        return size() &gt;= v.size() &amp;&amp; compare(0, v.size(), v) == 0;
439      }
440      nssv_constexpr bool starts_with(CharT c) const nssv_noexcept 
441      {
442        return starts_with(basic_string_view(&amp;c, 1));
443      }
444      nssv_constexpr bool starts_with(CharT const *s) const 
445      {
446        return starts_with(basic_string_view(s));
447      }
448      nssv_constexpr bool ends_with(basic_string_view v) const nssv_noexcept 
449      {
450        return size() &gt;= v.size() &amp;&amp; compare(size() - v.size(), npos, v) == 0;
451      }
452      nssv_constexpr bool ends_with(CharT c) const nssv_noexcept 
453      {
454        return ends_with(basic_string_view(&amp;c, 1));
455      }
456      nssv_constexpr bool ends_with(CharT const *s) const 
457      {
458        return ends_with(basic_string_view(s));
459      }
460      nssv_constexpr14 size_type find(basic_string_view v, size_type pos = 0) const nssv_noexcept 
461      {
462        return assert(v.size() == 0 || v.data() != nssv_nullptr),
463               pos &gt;= size() ? npos : to_pos(std::search(cbegin() + pos, cend(), v.cbegin(), v.cend(), Traits::eq));
464      }
465      nssv_constexpr14 size_type find(CharT c, size_type pos = 0) const nssv_noexcept 
466      {
467        return find(basic_string_view(&amp;c, 1), pos);
468      }
469      nssv_constexpr14 size_type find(CharT const *s, size_type pos, size_type n) const 
470      {
471        return find(basic_string_view(s, n), pos);
472      }
473      nssv_constexpr14 size_type find(CharT const *s, size_type pos = 0) const 
474      {
475        return find(basic_string_view(s), pos);
476      }
477      nssv_constexpr14 size_type rfind(basic_string_view v, size_type pos = npos) const nssv_noexcept 
478      {
479        if (size() &lt; v.size()) {
480          return npos;
481        }
482        if (v.empty()) {
483          return (std::min)(size(), pos);
484        }
485        const_iterator last = cbegin() + (std::min)(size() - v.size(), pos) + v.size();
486        const_iterator result = std::find_end(cbegin(), last, v.cbegin(), v.cend(), Traits::eq);
487        return result != last ? size_type(result - cbegin()) : npos;
488      }
489      nssv_constexpr14 size_type rfind(CharT c, size_type pos = npos) const nssv_noexcept 
490      {
491        return rfind(basic_string_view(&amp;c, 1), pos);
492      }
493      nssv_constexpr14 size_type rfind(CharT const *s, size_type pos, size_type n) const 
494      {
495        return rfind(basic_string_view(s, n), pos);
496      }
497      nssv_constexpr14 size_type rfind(CharT const *s, size_type pos = npos) const 
498      {
499        return rfind(basic_string_view(s), pos);
500      }
501      nssv_constexpr size_type find_first_of(basic_string_view v, size_type pos = 0) const nssv_noexcept 
502      {
503        return pos &gt;= size() ? npos
504                             : to_pos(std::find_first_of(cbegin() + pos, cend(), v.cbegin(), v.cend(), Traits::eq));
505      }
506      nssv_constexpr size_type find_first_of(CharT c, size_type pos = 0) const nssv_noexcept 
507      {
508        return find_first_of(basic_string_view(&amp;c, 1), pos);
509      }
510      nssv_constexpr size_type find_first_of(CharT const *s, size_type pos, size_type n) const 
511      {
512        return find_first_of(basic_string_view(s, n), pos);
513      }
514      nssv_constexpr size_type find_first_of(CharT const *s, size_type pos = 0) const 
515      {
516        return find_first_of(basic_string_view(s), pos);
517      }
518      nssv_constexpr size_type find_last_of(basic_string_view v, size_type pos = npos) const nssv_noexcept 
519      {
520        return empty() ? npos
521                       : pos &gt;= size() ? find_last_of(v, size() - 1)
522                                       : to_pos(std::find_first_of(const_reverse_iterator(cbegin() + pos + 1), crend(),
523                                                                   v.cbegin(), v.cend(), Traits::eq));
524      }
525      nssv_constexpr size_type find_last_of(CharT c, size_type pos = npos) const nssv_noexcept 
526      {
527        return find_last_of(basic_string_view(&amp;c, 1), pos);
528      }
529      nssv_constexpr size_type find_last_of(CharT const *s, size_type pos, size_type count) const 
530      {
531        return find_last_of(basic_string_view(s, count), pos);
532      }
533      nssv_constexpr size_type find_last_of(CharT const *s, size_type pos = npos) const 
534      {
535        return find_last_of(basic_string_view(s), pos);
536      }
537      nssv_constexpr size_type find_first_not_of(basic_string_view v, size_type pos = 0) const nssv_noexcept 
538      {
539        return pos &gt;= size() ? npos : to_pos(std::find_if(cbegin() + pos, cend(), not_in_view(v)));
540      }
541      nssv_constexpr size_type find_first_not_of(CharT c, size_type pos = 0) const nssv_noexcept 
542      {
543        return find_first_not_of(basic_string_view(&amp;c, 1), pos);
544      }
545      nssv_constexpr size_type find_first_not_of(CharT const *s, size_type pos, size_type count) const 
546      {
547        return find_first_not_of(basic_string_view(s, count), pos);
548      }
549      nssv_constexpr size_type find_first_not_of(CharT const *s, size_type pos = 0) const 
550      {
551        return find_first_not_of(basic_string_view(s), pos);
552      }
553      nssv_constexpr size_type find_last_not_of(basic_string_view v, size_type pos = npos) const nssv_noexcept 
554      {
555        return empty() ? npos
556                       : pos &gt;= size()
557                             ? find_last_not_of(v, size() - 1)
558                             : to_pos(std::find_if(const_reverse_iterator(cbegin() + pos + 1), crend(), not_in_view(v)));
559      }
560      nssv_constexpr size_type find_last_not_of(CharT c, size_type pos = npos) const nssv_noexcept 
561      {
562        return find_last_not_of(basic_string_view(&amp;c, 1), pos);
563      }
564      nssv_constexpr size_type find_last_not_of(CharT const *s, size_type pos, size_type count) const 
565      {
566        return find_last_not_of(basic_string_view(s, count), pos);
567      }
568      nssv_constexpr size_type find_last_not_of(CharT const *s, size_type pos = npos) const 
569      {
570        return find_last_not_of(basic_string_view(s), pos);
571      }
572  #if nssv_CPP17_OR_GREATER
573      static nssv_constexpr size_type npos = size_type(-1);
574  #elif nssv_CPP11_OR_GREATER
575      enum : size_type { npos = size_type(-1) };
576  #else
577      enum { npos = size_type(-1) };
578  #endif
579    private:
580      struct not_in_view {
581        const basic_string_view v;
582        nssv_constexpr explicit not_in_view(basic_string_view v) : v(v) {}
583        nssv_constexpr bool operator()(CharT c) const { return npos == v.find_first_of(c); }
584      };
585      nssv_constexpr size_type to_pos(const_iterator it) const { return it == cend() ? npos : size_type(it - cbegin()); }
586      nssv_constexpr size_type to_pos(const_reverse_iterator it) const {
587        return it == crend() ? npos : size_type(crend() - it - 1);
588      }
589      nssv_constexpr const_reference data_at(size_type pos) const {
590  #if nssv_BETWEEN(nssv_COMPILER_GNUC_VERSION, 1, 500)
591        return data_[pos];
592  #else
593        return assert(pos &lt; size()), data_[pos];
594  #endif
595      }
596    private:
597      const_pointer data_;
598      size_type size_;
599    public:
600  #if nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS
601      template &lt;class Allocator&gt;
602      basic_string_view(std::basic_string&lt;CharT, Traits, Allocator&gt; const &amp;s) nssv_noexcept : data_(s.data()),
603                                                                                              size_(s.size()) {}
604  #if nssv_HAVE_EXPLICIT_CONVERSION
605      template &lt;class Allocator&gt; explicit operator std::basic_string&lt;CharT, Traits, Allocator&gt;() const {
606        return to_string(Allocator());
607      }
608  #endif 
609  #if nssv_CPP11_OR_GREATER
610      template &lt;class Allocator = std::allocator&lt;CharT&gt;&gt;
611      std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(Allocator const &amp;a = Allocator()) const {
612        return std::basic_string&lt;CharT, Traits, Allocator&gt;(begin(), end(), a);
613      }
614  #else
615      std::basic_string&lt;CharT, Traits&gt; to_string() const { return std::basic_string&lt;CharT, Traits&gt;(begin(), end()); }
616      template &lt;class Allocator&gt; std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(Allocator const &amp;a) const {
617        return std::basic_string&lt;CharT, Traits, Allocator&gt;(begin(), end(), a);
618      }
619  #endif 
620  #endif 
621    };
622    template &lt;class CharT, class Traits&gt;
623    nssv_constexpr bool operator==(basic_string_view&lt;CharT, Traits&gt; lhs,
624                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
625      return lhs.compare(rhs) == 0;
626    }
627    template &lt;class CharT, class Traits&gt;
628    nssv_constexpr bool operator!=(basic_string_view&lt;CharT, Traits&gt; lhs,
629                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
630      return lhs.compare(rhs) != 0;
631    }
632    template &lt;class CharT, class Traits&gt;
633    nssv_constexpr bool operator&lt;(basic_string_view&lt;CharT, Traits&gt; lhs,
634                                  basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
635      return lhs.compare(rhs) &lt; 0;
636    }
637    template &lt;class CharT, class Traits&gt;
638    nssv_constexpr bool operator&lt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
639                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
640      return lhs.compare(rhs) &lt;= 0;
641    }
642    template &lt;class CharT, class Traits&gt;
643    nssv_constexpr bool operator&gt;(basic_string_view&lt;CharT, Traits&gt; lhs,
644                                  basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
645      return lhs.compare(rhs) &gt; 0;
646    }
647    template &lt;class CharT, class Traits&gt;
648    nssv_constexpr bool operator&gt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
649                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
650      return lhs.compare(rhs) &gt;= 0;
651    }
652  #if !nssv_CPP11_OR_GREATER || nssv_BETWEEN(nssv_COMPILER_MSVC_VERSION, 100, 141)
653    template &lt;class CharT, class Traits&gt;
654    nssv_constexpr bool operator==(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
655      return lhs.compare(rhs) == 0;
656    }
657    template &lt;class CharT, class Traits&gt;
658    nssv_constexpr bool operator==(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
659      return rhs.compare(lhs) == 0;
660    }
661    template &lt;class CharT, class Traits&gt;
662    nssv_constexpr bool operator==(basic_string_view&lt;CharT, Traits&gt; lhs,
663                                   std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
664      return lhs.size() == rhs.size() &amp;&amp; lhs.compare(rhs) == 0;
665    }
666    template &lt;class CharT, class Traits&gt;
667    nssv_constexpr bool operator==(std::basic_string&lt;CharT, Traits&gt; rhs,
668                                   basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
669      return lhs.size() == rhs.size() &amp;&amp; lhs.compare(rhs) == 0;
670    }
671    template &lt;class CharT, class Traits&gt;
672    nssv_constexpr bool operator!=(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
673      return lhs.compare(rhs) != 0;
674    }
675    template &lt;class CharT, class Traits&gt;
676    nssv_constexpr bool operator!=(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
677      return rhs.compare(lhs) != 0;
678    }
679    template &lt;class CharT, class Traits&gt;
680    nssv_constexpr bool operator!=(basic_string_view&lt;CharT, Traits&gt; lhs,
681                                   std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
682      return lhs.size() != rhs.size() &amp;&amp; lhs.compare(rhs) != 0;
683    }
684    template &lt;class CharT, class Traits&gt;
685    nssv_constexpr bool operator!=(std::basic_string&lt;CharT, Traits&gt; rhs,
686                                   basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
687      return lhs.size() != rhs.size() || rhs.compare(lhs) != 0;
688    }
689    template &lt;class CharT, class Traits&gt;
690    nssv_constexpr bool operator&lt;(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
691      return lhs.compare(rhs) &lt; 0;
692    }
693    template &lt;class CharT, class Traits&gt;
694    nssv_constexpr bool operator&lt;(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
695      return rhs.compare(lhs) &gt; 0;
696    }
697    template &lt;class CharT, class Traits&gt;
698    nssv_constexpr bool operator&lt;(basic_string_view&lt;CharT, Traits&gt; lhs,
699                                  std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
700      return lhs.compare(rhs) &lt; 0;
701    }
702    template &lt;class CharT, class Traits&gt;
703    nssv_constexpr bool operator&lt;(std::basic_string&lt;CharT, Traits&gt; rhs,
704                                  basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
705      return rhs.compare(lhs) &gt; 0;
706    }
707    template &lt;class CharT, class Traits&gt;
708    nssv_constexpr bool operator&lt;=(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
709      return lhs.compare(rhs) &lt;= 0;
710    }
711    template &lt;class CharT, class Traits&gt;
712    nssv_constexpr bool operator&lt;=(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
713      return rhs.compare(lhs) &gt;= 0;
714    }
715    template &lt;class CharT, class Traits&gt;
716    nssv_constexpr bool operator&lt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
717                                   std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
718      return lhs.compare(rhs) &lt;= 0;
719    }
720    template &lt;class CharT, class Traits&gt;
721    nssv_constexpr bool operator&lt;=(std::basic_string&lt;CharT, Traits&gt; rhs,
722                                   basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
723      return rhs.compare(lhs) &gt;= 0;
724    }
725    template &lt;class CharT, class Traits&gt;
726    nssv_constexpr bool operator&gt;(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
727      return lhs.compare(rhs) &gt; 0;
728    }
729    template &lt;class CharT, class Traits&gt;
730    nssv_constexpr bool operator&gt;(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
731      return rhs.compare(lhs) &lt; 0;
732    }
733    template &lt;class CharT, class Traits&gt;
734    nssv_constexpr bool operator&gt;(basic_string_view&lt;CharT, Traits&gt; lhs,
735                                  std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
736      return lhs.compare(rhs) &gt; 0;
737    }
738    template &lt;class CharT, class Traits&gt;
739    nssv_constexpr bool operator&gt;(std::basic_string&lt;CharT, Traits&gt; rhs,
740                                  basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
741      return rhs.compare(lhs) &lt; 0;
742    }
743    template &lt;class CharT, class Traits&gt;
744    nssv_constexpr bool operator&gt;=(basic_string_view&lt;CharT, Traits&gt; lhs, char const *rhs) nssv_noexcept {
745      return lhs.compare(rhs) &gt;= 0;
746    }
747    template &lt;class CharT, class Traits&gt;
748    nssv_constexpr bool operator&gt;=(char const *lhs, basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
749      return rhs.compare(lhs) &lt;= 0;
750    }
751    template &lt;class CharT, class Traits&gt;
752    nssv_constexpr bool operator&gt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
753                                   std::basic_string&lt;CharT, Traits&gt; rhs) nssv_noexcept {
754      return lhs.compare(rhs) &gt;= 0;
755    }
756    template &lt;class CharT, class Traits&gt;
757    nssv_constexpr bool operator&gt;=(std::basic_string&lt;CharT, Traits&gt; rhs,
758                                   basic_string_view&lt;CharT, Traits&gt; lhs) nssv_noexcept {
759      return rhs.compare(lhs) &lt;= 0;
760    }
761  #else 
762  #define nssv_BASIC_STRING_VIEW_I(T, U) typename std::decay&lt;basic_string_view&lt;T, U&gt;&gt;::type
763  #if nssv_BETWEEN(nssv_COMPILER_MSVC_VERSION, 140, 150)
764  #define nssv_MSVC_ORDER(x) , int = x
765  #else
766  #define nssv_MSVC_ORDER(x) &amp;bsol;*, int=x*/
767  #endif
768    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
769    nssv_constexpr bool operator==(basic_string_view&lt;CharT, Traits&gt; lhs,
770                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
771      return lhs.compare(rhs) == 0;
772    }
773    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
774    nssv_constexpr bool operator==(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
775                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
776      return lhs.size() == rhs.size() &amp;&amp; lhs.compare(rhs) == 0;
777    }
778    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
779    nssv_constexpr bool operator!=(basic_string_view&lt;CharT, Traits&gt; lhs,
780                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
781      return lhs.size() != rhs.size() || lhs.compare(rhs) != 0;
782    }
783    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
784    nssv_constexpr bool operator!=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
785                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
786      return lhs.compare(rhs) != 0;
787    }
788    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
789    nssv_constexpr bool operator&lt;(basic_string_view&lt;CharT, Traits&gt; lhs,
790                                  nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
791      return lhs.compare(rhs) &lt; 0;
792    }
793    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
794    nssv_constexpr bool operator&lt;(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
795                                  basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
796      return lhs.compare(rhs) &lt; 0;
797    }
798    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
799    nssv_constexpr bool operator&lt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
800                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
801      return lhs.compare(rhs) &lt;= 0;
802    }
803    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
804    nssv_constexpr bool operator&lt;=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
805                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
806      return lhs.compare(rhs) &lt;= 0;
807    }
808    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
809    nssv_constexpr bool operator&gt;(basic_string_view&lt;CharT, Traits&gt; lhs,
810                                  nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
811      return lhs.compare(rhs) &gt; 0;
812    }
813    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
814    nssv_constexpr bool operator&gt;(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
815                                  basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
816      return lhs.compare(rhs) &gt; 0;
817    }
818    template &lt;class CharT, class Traits nssv_MSVC_ORDER(1)&gt;
819    nssv_constexpr bool operator&gt;=(basic_string_view&lt;CharT, Traits&gt; lhs,
820                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
821      return lhs.compare(rhs) &gt;= 0;
822    }
823    template &lt;class CharT, class Traits nssv_MSVC_ORDER(2)&gt;
824    nssv_constexpr bool operator&gt;=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
825                                   basic_string_view&lt;CharT, Traits&gt; rhs) nssv_noexcept {
826      return lhs.compare(rhs) &gt;= 0;
827    }
828  #undef nssv_MSVC_ORDER
829  #undef nssv_BASIC_STRING_VIEW_I
830  #endif 
831    namespace detail {
832    template &lt;class Stream&gt; void write_padding(Stream &amp;os, std::streamsize n) {
833      for (std::streamsize i = 0; i &lt; n; ++i)
834        os.rdbuf()-&gt;sputc(os.fill());
835    }
836    template &lt;class Stream, class View&gt; Stream &amp;write_to_stream(Stream &amp;os, View const &amp;sv) {
837      typename Stream::sentry sentry(os);
838      if (!os)
839        return os;
840      const std::streamsize length = static_cast&lt;std::streamsize&gt;(sv.length());
841      const bool pad = (length &lt; os.width());
842      const bool left_pad = pad &amp;&amp; (os.flags() &amp; std::ios_base::adjustfield) == std::ios_base::right;
843      if (left_pad)
844        write_padding(os, os.width() - length);
845      os.rdbuf()-&gt;sputn(sv.begin(), length);
846      if (pad &amp;&amp; !left_pad)
847        write_padding(os, os.width() - length);
848      os.width(0);
849      return os;
850    }
851    } 
852    template &lt;class CharT, class Traits&gt;
853    std::basic_ostream&lt;CharT, Traits&gt; &amp;operator&lt;&lt;(std::basic_ostream&lt;CharT, Traits&gt; &amp;os,
854                                                  basic_string_view&lt;CharT, Traits&gt; sv) {
855      return detail::write_to_stream(os, sv);
856    }
857    typedef basic_string_view&lt;char&gt; string_view;
858    typedef basic_string_view&lt;wchar_t&gt; wstring_view;
859  #if nssv_HAVE_WCHAR16_T
860    typedef basic_string_view&lt;char16_t&gt; u16string_view;
861    typedef basic_string_view&lt;char32_t&gt; u32string_view;
862  #endif
863    } 
864  } 
865  #if nssv_HAVE_USER_DEFINED_LITERALS
866  namespace nonstd {
867  nssv_inline_ns namespace literals {
868    nssv_inline_ns namespace string_view_literals {
869  #if nssv_CONFIG_STD_SV_OPERATOR &amp;&amp; nssv_HAVE_STD_DEFINED_LITERALS
870      nssv_constexpr nonstd::sv_lite::string_view operator&quot;&quot; sv(const char *str, size_t len) nssv_noexcept 
871      {
872        return nonstd::sv_lite::string_view {str, len};
873      }
874      nssv_constexpr nonstd::sv_lite::u16string_view operator&quot;&quot; sv(const char16_t *str, size_t len) nssv_noexcept 
875      {
876        return nonstd::sv_lite::u16string_view {str, len};
877      }
878      nssv_constexpr nonstd::sv_lite::u32string_view operator&quot;&quot; sv(const char32_t *str, size_t len) nssv_noexcept 
879      {
880        return nonstd::sv_lite::u32string_view {str, len};
881      }
882      nssv_constexpr nonstd::sv_lite::wstring_view operator&quot;&quot; sv(const wchar_t *str, size_t len) nssv_noexcept 
883      {
884        return nonstd::sv_lite::wstring_view {str, len};
885      }
886  #endif 
887  #if nssv_CONFIG_USR_SV_OPERATOR
888      nssv_constexpr nonstd::sv_lite::string_view operator&quot;&quot; _sv(const char *str, size_t len) nssv_noexcept 
889      {
890        return nonstd::sv_lite::string_view {str, len};
891      }
892      nssv_constexpr nonstd::sv_lite::u16string_view operator&quot;&quot; _sv(const char16_t *str, size_t len) nssv_noexcept 
893      {
894        return nonstd::sv_lite::u16string_view {str, len};
895      }
896      nssv_constexpr nonstd::sv_lite::u32string_view operator&quot;&quot; _sv(const char32_t *str, size_t len) nssv_noexcept 
897      {
898        return nonstd::sv_lite::u32string_view {str, len};
899      }
900      nssv_constexpr nonstd::sv_lite::wstring_view operator&quot;&quot; _sv(const wchar_t *str, size_t len) nssv_noexcept 
901      {
902        return nonstd::sv_lite::wstring_view {str, len};
903      }
904  #endif 
905    }
906  }
907  } 
908  #endif
909  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
910  namespace nonstd {
911  namespace sv_lite {
912  #if nssv_CPP11_OR_GREATER &amp;&amp; nssv_COMPILER_MSVC_VERSION != 140
913  template &lt;class CharT, class Traits, class Allocator = std::allocator&lt;CharT&gt;&gt;
914  std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(basic_string_view&lt;CharT, Traits&gt; v,
915                                                        Allocator const &amp;a = Allocator()) {
916    return std::basic_string&lt;CharT, Traits, Allocator&gt;(v.begin(), v.end(), a);
917  }
918  #else
919  template &lt;class CharT, class Traits&gt; std::basic_string&lt;CharT, Traits&gt; to_string(basic_string_view&lt;CharT, Traits&gt; v) {
920    return std::basic_string&lt;CharT, Traits&gt;(v.begin(), v.end());
921  }
922  template &lt;class CharT, class Traits, class Allocator&gt;
923  std::basic_string&lt;CharT, Traits, Allocator&gt; to_string(basic_string_view&lt;CharT, Traits&gt; v, Allocator const &amp;a) {
924    return std::basic_string&lt;CharT, Traits, Allocator&gt;(v.begin(), v.end(), a);
925  }
926  #endif 
927  template &lt;class CharT, class Traits, class Allocator&gt;
928  basic_string_view&lt;CharT, Traits&gt; to_string_view(std::basic_string&lt;CharT, Traits, Allocator&gt; const &amp;s) {
929    return basic_string_view&lt;CharT, Traits&gt;(s.data(), s.size());
930  }
931  } 
932  } 
933  #endif 
934  namespace nonstd {
935  using sv_lite::basic_string_view;
936  using sv_lite::string_view;
937  using sv_lite::wstring_view;
938  #if nssv_HAVE_WCHAR16_T
939  using sv_lite::u16string_view;
940  #endif
941  #if nssv_HAVE_WCHAR32_T
942  using sv_lite::u32string_view;
943  #endif
944  using sv_lite::operator==;
945  using sv_lite::operator!=;
946  using sv_lite::operator&lt;;
947  using sv_lite::operator&lt;=;
948  using sv_lite::operator&gt;;
949  using sv_lite::operator&gt;=;
950  using sv_lite::operator&lt;&lt;;
951  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
952  using sv_lite::to_string;
953  using sv_lite::to_string_view;
954  #endif
955  } 
956  #if nssv_HAVE_STD_HASH
957  #include &lt;functional&gt;
958  namespace std {
959  template &lt;&gt; struct hash&lt;nonstd::string_view&gt; {
960  public:
961    std::size_t operator()(nonstd::string_view v) const nssv_noexcept {
962      return std::hash&lt;std::string&gt;()(std::string(v.data(), v.size()));
963    }
964  };
965  template &lt;&gt; struct hash&lt;nonstd::wstring_view&gt; {
966  public:
967    std::size_t operator()(nonstd::wstring_view v) const nssv_noexcept {
968      return std::hash&lt;std::wstring&gt;()(std::wstring(v.data(), v.size()));
969    }
970  };
971  template &lt;&gt; struct hash&lt;nonstd::u16string_view&gt; {
972  public:
973    std::size_t operator()(nonstd::u16string_view v) const nssv_noexcept {
974      return std::hash&lt;std::u16string&gt;()(std::u16string(v.data(), v.size()));
975    }
976  };
977  template &lt;&gt; struct hash&lt;nonstd::u32string_view&gt; {
978  public:
979    std::size_t operator()(nonstd::u32string_view v) const nssv_noexcept {
980      return std::hash&lt;std::u32string&gt;()(std::u32string(v.data(), v.size()));
981    }
982  };
983  } 
984  #endif 
985  nssv_RESTORE_WARNINGS()
986  #endif 
987  #endif 
988  #ifndef INCLUDE_INJA_TEMPLATE_HPP_
989  #define INCLUDE_INJA_TEMPLATE_HPP_
990  #include &lt;map&gt;
991  #include &lt;memory&gt;
992  #include &lt;string&gt;
993  #include &lt;vector&gt;
994  #ifndef INCLUDE_INJA_NODE_HPP_
995  #define INCLUDE_INJA_NODE_HPP_
996  #include &lt;string&gt;
997  #include &lt;utility&gt;
998  #ifndef INCLUDE_INJA_FUNCTION_STORAGE_HPP_
999  #define INCLUDE_INJA_FUNCTION_STORAGE_HPP_
1000  #include &lt;vector&gt;
1001  namespace inja {
1002  using Arguments = std::vector&lt;const json *&gt;;
1003  using CallbackFunction = std::function&lt;json(Arguments &amp;args)&gt;;
1004  using VoidCallbackFunction = std::function&lt;void(Arguments &amp;args)&gt;;
1005  class FunctionStorage {
1006  public:
1007    enum class Operation {
1008      Not,
1009      And,
1010      Or,
1011      In,
1012      Equal,
1013      NotEqual,
1014      Greater,
1015      GreaterEqual,
1016      Less,
1017      LessEqual,
1018      Add,
1019      Subtract,
1020      Multiplication,
1021      Division,
1022      Power,
1023      Modulo,
1024      AtId,
1025      At,
1026      Default,
1027      DivisibleBy,
1028      Even,
1029      Exists,
1030      ExistsInObject,
1031      First,
1032      Float,
1033      Int,
1034      IsArray,
1035      IsBoolean,
1036      IsFloat,
1037      IsInteger,
1038      IsNumber,
1039      IsObject,
1040      IsString,
1041      Last,
1042      Length,
1043      Lower,
1044      Max,
1045      Min,
1046      Odd,
1047      Range,
1048      Round,
1049      Sort,
1050      Upper,
1051      Super,
1052      Join,
1053      Callback,
1054      ParenLeft,
1055      ParenRight,
1056      None,
1057    };
1058    struct FunctionData {
1059      explicit FunctionData(const Operation &amp;op, const CallbackFunction &amp;cb = CallbackFunction{}) : operation(op), callback(cb) {}
1060      const Operation operation;
1061      const CallbackFunction callback;
1062    };
1063  private:
1064    const int VARIADIC {-1};
1065    std::map&lt;std::pair&lt;std::string, int&gt;, FunctionData&gt; function_storage = {
1066      {std::make_pair(&quot;at&quot;, 2), FunctionData { Operation::At }},
1067      {std::make_pair(&quot;default&quot;, 2), FunctionData { Operation::Default }},
1068      {std::make_pair(&quot;divisibleBy&quot;, 2), FunctionData { Operation::DivisibleBy }},
1069      {std::make_pair(&quot;even&quot;, 1), FunctionData { Operation::Even }},
1070      {std::make_pair(&quot;exists&quot;, 1), FunctionData { Operation::Exists }},
1071      {std::make_pair(&quot;existsIn&quot;, 2), FunctionData { Operation::ExistsInObject }},
1072      {std::make_pair(&quot;first&quot;, 1), FunctionData { Operation::First }},
1073      {std::make_pair(&quot;float&quot;, 1), FunctionData { Operation::Float }},
1074      {std::make_pair(&quot;int&quot;, 1), FunctionData { Operation::Int }},
1075      {std::make_pair(&quot;isArray&quot;, 1), FunctionData { Operation::IsArray }},
1076      {std::make_pair(&quot;isBoolean&quot;, 1), FunctionData { Operation::IsBoolean }},
1077      {std::make_pair(&quot;isFloat&quot;, 1), FunctionData { Operation::IsFloat }},
1078      {std::make_pair(&quot;isInteger&quot;, 1), FunctionData { Operation::IsInteger }},
1079      {std::make_pair(&quot;isNumber&quot;, 1), FunctionData { Operation::IsNumber }},
1080      {std::make_pair(&quot;isObject&quot;, 1), FunctionData { Operation::IsObject }},
1081      {std::make_pair(&quot;isString&quot;, 1), FunctionData { Operation::IsString }},
1082      {std::make_pair(&quot;last&quot;, 1), FunctionData { Operation::Last }},
1083      {std::make_pair(&quot;length&quot;, 1), FunctionData { Operation::Length }},
1084      {std::make_pair(&quot;lower&quot;, 1), FunctionData { Operation::Lower }},
1085      {std::make_pair(&quot;max&quot;, 1), FunctionData { Operation::Max }},
1086      {std::make_pair(&quot;min&quot;, 1), FunctionData { Operation::Min }},
1087      {std::make_pair(&quot;odd&quot;, 1), FunctionData { Operation::Odd }},
1088      {std::make_pair(&quot;range&quot;, 1), FunctionData { Operation::Range }},
1089      {std::make_pair(&quot;round&quot;, 2), FunctionData { Operation::Round }},
1090      {std::make_pair(&quot;sort&quot;, 1), FunctionData { Operation::Sort }},
1091      {std::make_pair(&quot;upper&quot;, 1), FunctionData { Operation::Upper }},
1092      {std::make_pair(&quot;super&quot;, 0), FunctionData { Operation::Super }},
1093      {std::make_pair(&quot;super&quot;, 1), FunctionData { Operation::Super }},
1094      {std::make_pair(&quot;join&quot;, 2), FunctionData { Operation::Join }},
1095    };
1096  public:
1097    void add_builtin(nonstd::string_view name, int num_args, Operation op) {
1098      function_storage.emplace(std::make_pair(static_cast&lt;std::string&gt;(name), num_args), FunctionData { op });
1099    }
1100    void add_callback(nonstd::string_view name, int num_args, const CallbackFunction &amp;callback) {
1101      function_storage.emplace(std::make_pair(static_cast&lt;std::string&gt;(name), num_args), FunctionData { Operation::Callback, callback });
1102    }
1103    FunctionData find_function(nonstd::string_view name, int num_args) const {
1104      auto it = function_storage.find(std::make_pair(static_cast&lt;std::string&gt;(name), num_args));
1105      if (it != function_storage.end()) {
1106        return it-&gt;second;
1107      } else if (num_args &gt; 0) {
1108        it = function_storage.find(std::make_pair(static_cast&lt;std::string&gt;(name), VARIADIC));
1109        if (it != function_storage.end()) {
1110          return it-&gt;second;
1111        }
1112      }
1113      return FunctionData { Operation::None };
1114    }
1115  };
1116  } 
1117  #endif 
1118  #ifndef INCLUDE_INJA_UTILS_HPP_
1119  #define INCLUDE_INJA_UTILS_HPP_
1120  #include &lt;algorithm&gt;
1121  #include &lt;fstream&gt;
1122  #include &lt;string&gt;
1123  #include &lt;utility&gt;
1124  #ifndef INCLUDE_INJA_EXCEPTIONS_HPP_
1125  #define INCLUDE_INJA_EXCEPTIONS_HPP_
1126  #include &lt;stdexcept&gt;
1127  #include &lt;string&gt;
1128  namespace inja {
1129  struct SourceLocation {
1130    size_t line;
1131    size_t column;
1132  };
1133  struct InjaError : public std::runtime_error {
1134    const std::string type;
1135    const std::string message;
1136    const SourceLocation location;
1137    explicit InjaError(const std::string &amp;type, const std::string &amp;message)
1138        : std::runtime_error(&quot;[inja.exception.&quot; + type + &quot;] &quot; + message), type(type), message(message), location({0, 0}) {}
1139    explicit InjaError(const std::string &amp;type, const std::string &amp;message, SourceLocation location)
1140        : std::runtime_error(&quot;[inja.exception.&quot; + type + &quot;] (at &quot; + std::to_string(location.line) + &quot;:&quot; +
1141                             std::to_string(location.column) + &quot;) &quot; + message),
1142          type(type), message(message), location(location) {}
1143  };
1144  struct ParserError : public InjaError {
1145    explicit ParserError(const std::string &amp;message, SourceLocation location) : InjaError(&quot;parser_error&quot;, message, location) {}
1146  };
1147  struct RenderError : public InjaError {
1148    explicit RenderError(const std::string &amp;message, SourceLocation location) : InjaError(&quot;render_error&quot;, message, location) {}
1149  };
1150  struct FileError : public InjaError {
1151    explicit FileError(const std::string &amp;message) : InjaError(&quot;file_error&quot;, message) {}
1152    explicit FileError(const std::string &amp;message, SourceLocation location) : InjaError(&quot;file_error&quot;, message, location) {}
1153  };
1154  struct JsonError : public InjaError {
1155    explicit JsonError(const std::string &amp;message, SourceLocation location) : InjaError(&quot;json_error&quot;, message, location) {}
1156  };
1157  } 
1158  #endif 
1159  namespace inja {
1160  namespace string_view {
1161  inline nonstd::string_view slice(nonstd::string_view view, size_t start, size_t end) {
1162    start = std::min(start, view.size());
1163    end = std::min(std::max(start, end), view.size());
1164    return view.substr(start, end - start);
1165  }
1166  inline std::pair&lt;nonstd::string_view, nonstd::string_view&gt; split(nonstd::string_view view, char Separator) {
1167    size_t idx = view.find(Separator);
1168    if (idx == nonstd::string_view::npos) {
1169      return std::make_pair(view, nonstd::string_view());
1170    }
1171    return std::make_pair(slice(view, 0, idx), slice(view, idx + 1, nonstd::string_view::npos));
1172  }
1173  inline bool starts_with(nonstd::string_view view, nonstd::string_view prefix) {
1174    return (view.size() &gt;= prefix.size() &amp;&amp; view.compare(0, prefix.size(), prefix) == 0);
1175  }
1176  } 
1177  inline SourceLocation get_source_location(nonstd::string_view content, size_t pos) {
1178    auto sliced = string_view::slice(content, 0, pos);
1179    std::size_t last_newline = sliced.rfind(&quot;\n&quot;);
1180    if (last_newline == nonstd::string_view::npos) {
1181      return {1, sliced.length() + 1};
1182    }
1183    size_t count_lines = 0;
1184    size_t search_start = 0;
1185    while (search_start &lt;= sliced.size()) {
1186      search_start = sliced.find(&quot;\n&quot;, search_start) + 1;
1187      if (search_start == 0) {
1188        break;
1189      }
1190      count_lines += 1;
1191    }
1192    return {count_lines + 1, sliced.length() - last_newline};
1193  }
1194  inline void replace_substring(std::string&amp; s, const std::string&amp; f,
1195                                const std::string&amp; t)
1196  {
1197    if (f.empty()) return;
1198    for (auto pos = s.find(f);                  
1199              pos != std::string::npos;         
1200              s.replace(pos, f.size(), t),      
1201              pos = s.find(f, pos + t.size()))  
1202    {}
1203  }
1204  } 
1205  #endif 
1206  namespace inja {
1207  class NodeVisitor;
1208  class BlockNode;
1209  class TextNode;
1210  class ExpressionNode;
1211  class LiteralNode;
1212  class JsonNode;
1213  class FunctionNode;
1214  class ExpressionListNode;
1215  class StatementNode;
1216  class ForStatementNode;
1217  class ForArrayStatementNode;
1218  class ForObjectStatementNode;
1219  class IfStatementNode;
1220  class IncludeStatementNode;
1221  class ExtendsStatementNode;
1222  class BlockStatementNode;
1223  class SetStatementNode;
1224  class NodeVisitor {
1225  public:
1226    virtual ~NodeVisitor() = default;
1227    virtual void visit(const BlockNode&amp; node) = 0;
1228    virtual void visit(const TextNode&amp; node) = 0;
1229    virtual void visit(const ExpressionNode&amp; node) = 0;
1230    virtual void visit(const LiteralNode&amp; node) = 0;
1231    virtual void visit(const JsonNode&amp; node) = 0;
1232    virtual void visit(const FunctionNode&amp; node) = 0;
1233    virtual void visit(const ExpressionListNode&amp; node) = 0;
1234    virtual void visit(const StatementNode&amp; node) = 0;
1235    virtual void visit(const ForStatementNode&amp; node) = 0;
1236    virtual void visit(const ForArrayStatementNode&amp; node) = 0;
1237    virtual void visit(const ForObjectStatementNode&amp; node) = 0;
1238    virtual void visit(const IfStatementNode&amp; node) = 0;
1239    virtual void visit(const IncludeStatementNode&amp; node) = 0;
1240    virtual void visit(const ExtendsStatementNode&amp; node) = 0;
1241    virtual void visit(const BlockStatementNode&amp; node) = 0;
1242    virtual void visit(const SetStatementNode&amp; node) = 0;
1243  };
1244  class AstNode {
1245  public:
1246    virtual void accept(NodeVisitor&amp; v) const = 0;
1247    size_t pos;
1248    AstNode(size_t pos) : pos(pos) { }
1249    virtual ~AstNode() { }
1250  };
1251  class BlockNode : public AstNode {
1252  public:
1253    std::vector&lt;std::shared_ptr&lt;AstNode&gt;&gt; nodes;
1254    explicit BlockNode() : AstNode(0) {}
1255    void accept(NodeVisitor&amp; v) const {
1256      v.visit(*this);
1257    }
1258  };
1259  class TextNode : public AstNode {
1260  public:
1261    const size_t length;
1262    explicit TextNode(size_t pos, size_t length): AstNode(pos), length(length) { }
1263    void accept(NodeVisitor&amp; v) const {
1264      v.visit(*this);
1265    }
1266  };
1267  class ExpressionNode : public AstNode {
1268  public:
1269    explicit ExpressionNode(size_t pos) : AstNode(pos) {}
1270    void accept(NodeVisitor&amp; v) const {
1271      v.visit(*this);
1272    }
1273  };
1274  class LiteralNode : public ExpressionNode {
1275  public:
1276    const json value;
1277    explicit LiteralNode(const json&amp; value, size_t pos) : ExpressionNode(pos), value(value) { }
1278    void accept(NodeVisitor&amp; v) const {
1279      v.visit(*this);
1280    }
1281  };
1282  class JsonNode : public ExpressionNode {
1283  public:
1284    const std::string name;
1285    const json::json_pointer ptr;
1286    static std::string convert_dot_to_json_ptr(nonstd::string_view ptr_name) {
1287      std::string result;
1288      do {
1289        nonstd::string_view part;
1290        std::tie(part, ptr_name) = string_view::split(ptr_name, &#x27;.&#x27;);
1291        result.push_back(&#x27;/&#x27;);
1292        result.append(part.begin(), part.end());
1293      } while (!ptr_name.empty());
1294      return result;
1295    }
1296    explicit JsonNode(nonstd::string_view ptr_name, size_t pos) : ExpressionNode(pos), name(ptr_name), ptr(json::json_pointer(convert_dot_to_json_ptr(ptr_name))) { }
1297    void accept(NodeVisitor&amp; v) const {
1298      v.visit(*this);
1299    }
1300  };
1301  class FunctionNode : public ExpressionNode {
1302    using Op = FunctionStorage::Operation;
1303  public:
1304    enum class Associativity {
1305      Left,
1306      Right,
1307    };
1308    unsigned int precedence;
1309    Associativity associativity;
1310    Op operation;
1311    std::string name;
1312    int number_args; 
1313    std::vector&lt;std::shared_ptr&lt;ExpressionNode&gt;&gt; arguments;
1314    CallbackFunction callback;
1315    explicit FunctionNode(nonstd::string_view name, size_t pos) : ExpressionNode(pos), precedence(8), associativity(Associativity::Left), operation(Op::Callback), name(name), number_args(1) { }
1316    explicit FunctionNode(Op operation, size_t pos) : ExpressionNode(pos), operation(operation), number_args(1) {
1317      switch (operation) {
1318        case Op::Not: {
1319          number_args = 1;
1320          precedence = 4;
1321          associativity = Associativity::Left;
1322        } break;
1323        case Op::And: {
1324          number_args = 2;
1325          precedence = 1;
1326          associativity = Associativity::Left;
1327        } break;
1328        case Op::Or: {
1329          number_args = 2;
1330          precedence = 1;
1331          associativity = Associativity::Left;
1332        } break;
1333        case Op::In: {
1334          number_args = 2;
1335          precedence = 2;
1336          associativity = Associativity::Left;
1337        } break;
1338        case Op::Equal: {
1339          number_args = 2;
1340          precedence = 2;
1341          associativity = Associativity::Left;
1342        } break;
1343        case Op::NotEqual: {
1344          number_args = 2;
1345          precedence = 2;
1346          associativity = Associativity::Left;
1347        } break;
1348        case Op::Greater: {
1349          number_args = 2;
1350          precedence = 2;
1351          associativity = Associativity::Left;
1352        } break;
1353        case Op::GreaterEqual: {
1354          number_args = 2;
1355          precedence = 2;
1356          associativity = Associativity::Left;
1357        } break;
1358        case Op::Less: {
1359          number_args = 2;
1360          precedence = 2;
1361          associativity = Associativity::Left;
1362        } break;
1363        case Op::LessEqual: {
1364          number_args = 2;
1365          precedence = 2;
1366          associativity = Associativity::Left;
1367        } break;
1368        case Op::Add: {
1369          number_args = 2;
1370          precedence = 3;
1371          associativity = Associativity::Left;
1372        } break;
1373        case Op::Subtract: {
1374          number_args = 2;
1375          precedence = 3;
1376          associativity = Associativity::Left;
1377        } break;
1378        case Op::Multiplication: {
1379          number_args = 2;
1380          precedence = 4;
1381          associativity = Associativity::Left;
1382        } break;
1383        case Op::Division: {
1384          number_args = 2;
1385          precedence = 4;
1386          associativity = Associativity::Left;
1387        } break;
1388        case Op::Power: {
1389          number_args = 2;
1390          precedence = 5;
1391          associativity = Associativity::Right;
1392        } break;
1393        case Op::Modulo: {
1394          number_args = 2;
1395          precedence = 4;
1396          associativity = Associativity::Left;
1397        } break;
1398        case Op::AtId: {
1399          number_args = 2;
1400          precedence = 8;
1401          associativity = Associativity::Left;
1402        } break;
1403        default: {
1404          precedence = 1;
1405          associativity = Associativity::Left;
1406        }
1407      }
1408    }
1409    void accept(NodeVisitor&amp; v) const {
1410      v.visit(*this);
1411    }
1412  };
1413  class ExpressionListNode : public AstNode {
1414  public:
1415    std::shared_ptr&lt;ExpressionNode&gt; root;
1416    explicit ExpressionListNode() : AstNode(0) { }
1417    explicit ExpressionListNode(size_t pos) : AstNode(pos) { }
1418    void accept(NodeVisitor&amp; v) const {
1419      v.visit(*this);
1420    }
1421  };
1422  class StatementNode : public AstNode {
1423  public:
1424    StatementNode(size_t pos) : AstNode(pos) { }
1425    virtual void accept(NodeVisitor&amp; v) const = 0;
1426  };
1427  class ForStatementNode : public StatementNode {
1428  public:
1429    ExpressionListNode condition;
1430    BlockNode body;
1431    BlockNode *const parent;
1432    ForStatementNode(BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent) { }
1433    virtual void accept(NodeVisitor&amp; v) const = 0;
1434  };
1435  class ForArrayStatementNode : public ForStatementNode {
1436  public:
1437    const std::string value;
1438    explicit ForArrayStatementNode(const std::string&amp; value, BlockNode *const parent, size_t pos) : ForStatementNode(parent, pos), value(value) { }
1439    void accept(NodeVisitor&amp; v) const {
1440      v.visit(*this);
1441    }
1442  };
1443  class ForObjectStatementNode : public ForStatementNode {
1444  public:
1445    const std::string key;
1446    const std::string value;
1447    explicit ForObjectStatementNode(const std::string&amp; key, const std::string&amp; value, BlockNode *const parent, size_t pos) : ForStatementNode(parent, pos), key(key), value(value) { }
1448    void accept(NodeVisitor&amp; v) const {
1449      v.visit(*this);
1450    }
1451  };
1452  class IfStatementNode : public StatementNode {
1453  public:
1454    ExpressionListNode condition;
1455    BlockNode true_statement;
1456    BlockNode false_statement;
1457    BlockNode *const parent;
1458    const bool is_nested;
1459    bool has_false_statement {false};
1460    explicit IfStatementNode(BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent), is_nested(false) { }
1461    explicit IfStatementNode(bool is_nested, BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent), is_nested(is_nested) { }
1462    void accept(NodeVisitor&amp; v) const {
1463      v.visit(*this);
1464    }
1465  };
1466  class IncludeStatementNode : public StatementNode {
1467  public:
1468    const std::string file;
1469    explicit IncludeStatementNode(const std::string&amp; file, size_t pos) : StatementNode(pos), file(file) { }
1470    void accept(NodeVisitor&amp; v) const {
1471      v.visit(*this);
1472    }
1473  };
1474  class ExtendsStatementNode : public StatementNode {
1475  public:
1476    const std::string file;
1477    explicit ExtendsStatementNode(const std::string&amp; file, size_t pos) : StatementNode(pos), file(file) { }
1478    void accept(NodeVisitor&amp; v) const {
1479      v.visit(*this);
1480    };
1481  };
1482  class BlockStatementNode : public StatementNode {
1483  public:
1484    const std::string name;
1485    BlockNode block;
1486    BlockNode *const parent;
1487    explicit BlockStatementNode(BlockNode *const parent, const std::string&amp; name, size_t pos) : StatementNode(pos), name(name), parent(parent) { }
1488    void accept(NodeVisitor&amp; v) const {
1489      v.visit(*this);
1490    };
1491  };
1492  class SetStatementNode : public StatementNode {
1493  public:
1494    const std::string key;
1495    ExpressionListNode expression;
1496    explicit SetStatementNode(const std::string&amp; key, size_t pos) : StatementNode(pos), key(key) { }
1497    void accept(NodeVisitor&amp; v) const {
1498      v.visit(*this);
1499    }
1500  };
1501  } 
1502  #endif 
1503  #ifndef INCLUDE_INJA_STATISTICS_HPP_
1504  #define INCLUDE_INJA_STATISTICS_HPP_
1505  namespace inja {
1506  class StatisticsVisitor : public NodeVisitor {
1507    void visit(const BlockNode&amp; node) {
1508      for (auto&amp; n : node.nodes) {
1509        n-&gt;accept(*this);
1510      }
1511    }
1512    void visit(const TextNode&amp;) { }
1513    void visit(const ExpressionNode&amp;) { }
1514    void visit(const LiteralNode&amp;) { }
1515    void visit(const JsonNode&amp;) {
1516      variable_counter += 1;
1517    }
1518    void visit(const FunctionNode&amp; node) {
1519      for (auto&amp; n : node.arguments) {
1520        n-&gt;accept(*this);
1521      }
1522    }
1523    void visit(const ExpressionListNode&amp; node) {
1524      node.root-&gt;accept(*this);
1525    }
1526    void visit(const StatementNode&amp;) { }
1527    void visit(const ForStatementNode&amp;) { }
1528    void visit(const ForArrayStatementNode&amp; node) {
1529      node.condition.accept(*this);
1530      node.body.accept(*this);
1531    }
1532    void visit(const ForObjectStatementNode&amp; node) {
1533      node.condition.accept(*this);
1534      node.body.accept(*this);
1535    }
1536    void visit(const IfStatementNode&amp; node) {
1537      node.condition.accept(*this);
1538      node.true_statement.accept(*this);
1539      node.false_statement.accept(*this);
1540    }
1541    void visit(const IncludeStatementNode&amp;) { }
1542    void visit(const ExtendsStatementNode&amp;) { }
1543    void visit(const BlockStatementNode&amp; node) {
1544      node.block.accept(*this);
1545    }
1546    void visit(const SetStatementNode&amp;) { }
1547  public:
1548    unsigned int variable_counter;
1549    explicit StatisticsVisitor() : variable_counter(0) { }
1550  };
1551  } 
1552  #endif 
1553  namespace inja {
1554  struct Template {
1555    BlockNode root;
1556    std::string content;
1557    std::map&lt;std::string, std::shared_ptr&lt;BlockStatementNode&gt;&gt; block_storage;
1558    explicit Template() { }
1559    explicit Template(const std::string&amp; content): content(content) { }
1560    int count_variables() {
1561      auto statistic_visitor = StatisticsVisitor();
1562      root.accept(statistic_visitor);
1563      return statistic_visitor.variable_counter;
1564    }
1565  };
1566  using TemplateStorage = std::map&lt;std::string, Template&gt;;
1567  } 
1568  #endif 
1569  namespace inja {
1570  struct LexerConfig {
1571    std::string statement_open {&quot;{%&quot;};
1572    std::string statement_open_no_lstrip {&quot;{%+&quot;};
1573    std::string statement_open_force_lstrip {&quot;{%-&quot;};
1574    std::string statement_close {&quot;%}&quot;};
1575    std::string statement_close_force_rstrip {&quot;-%}&quot;};
1576    std::string line_statement {&quot;##&quot;};
1577    std::string expression_open {&quot;{{&quot;};
1578    std::string expression_open_force_lstrip {&quot;{{-&quot;};
1579    std::string expression_close {&quot;}}&quot;};
1580    std::string expression_close_force_rstrip {&quot;-}}&quot;};
1581    std::string comment_open {&quot;{#&quot;};
1582    std::string comment_open_force_lstrip {&quot;{#-&quot;};
1583    std::string comment_close {&quot;#}&quot;};
1584    std::string comment_close_force_rstrip {&quot;-#}&quot;};
1585    std::string open_chars {&quot;#{&quot;};
1586    bool trim_blocks {false};
1587    bool lstrip_blocks {false};
1588    void update_open_chars() {
1589      open_chars = &quot;&quot;;
1590      if (open_chars.find(line_statement[0]) == std::string::npos) {
1591        open_chars += line_statement[0];
1592      }
1593      if (open_chars.find(statement_open[0]) == std::string::npos) {
1594        open_chars += statement_open[0];
1595      }
1596      if (open_chars.find(statement_open_no_lstrip[0]) == std::string::npos) {
1597        open_chars += statement_open_no_lstrip[0];
1598      }
1599      if (open_chars.find(statement_open_force_lstrip[0]) == std::string::npos) {
1600        open_chars += statement_open_force_lstrip[0];
1601      }
1602      if (open_chars.find(expression_open[0]) == std::string::npos) {
1603        open_chars += expression_open[0];
1604      }
1605      if (open_chars.find(expression_open_force_lstrip[0]) == std::string::npos) {
1606        open_chars += expression_open_force_lstrip[0];
1607      }
1608      if (open_chars.find(comment_open[0]) == std::string::npos) {
1609        open_chars += comment_open[0];
1610      }
1611      if (open_chars.find(comment_open_force_lstrip[0]) == std::string::npos) {
1612        open_chars += comment_open_force_lstrip[0];
1613      }
1614    }
1615  };
1616  struct ParserConfig {
1617    bool search_included_templates_in_files {true};
1618    std::function&lt;Template(const std::string&amp;, const std::string&amp;)&gt; include_callback;
1619  };
1620  struct RenderConfig {
1621    bool throw_at_missing_includes {true};
1622  };
1623  } 
1624  #endif 
1625  #ifndef INCLUDE_INJA_PARSER_HPP_
1626  #define INCLUDE_INJA_PARSER_HPP_
1627  #include &lt;limits&gt;
1628  #include &lt;stack&gt;
1629  #include &lt;string&gt;
1630  #include &lt;utility&gt;
1631  #include &lt;queue&gt;
1632  #include &lt;vector&gt;
1633  #ifndef INCLUDE_INJA_LEXER_HPP_
1634  #define INCLUDE_INJA_LEXER_HPP_
1635  #include &lt;cctype&gt;
1636  #include &lt;locale&gt;
1637  #ifndef INCLUDE_INJA_TOKEN_HPP_
1638  #define INCLUDE_INJA_TOKEN_HPP_
1639  #include &lt;string&gt;
1640  namespace inja {
1641  struct Token {
1642    enum class Kind {
1643      Text,
1644      ExpressionOpen,     
1645      ExpressionClose,    
1646      LineStatementOpen,  
1647      LineStatementClose, 
1648      StatementOpen,      
1649      StatementClose,     
1650      CommentOpen,        
1651      CommentClose,       
1652      Id,                 
1653      Number,             
1654      String,             
1655      Plus,               
1656      Minus,              
1657      Times,              
1658      Slash,              
1659      Percent,            
1660      Power,              
1661      Comma,              
1662      Dot,                
1663      Colon,              
1664      LeftParen,          
1665      RightParen,         
1666      LeftBracket,        
1667      RightBracket,       
1668      LeftBrace,          
1669      RightBrace,         
1670      Equal,              
1671      NotEqual,           
1672      GreaterThan,        
1673      GreaterEqual,       
1674      LessThan,           
1675      LessEqual,          
1676      Unknown,
1677      Eof,
1678    };
1679    Kind kind {Kind::Unknown};
1680    nonstd::string_view text;
1681    explicit constexpr Token() = default;
1682    explicit constexpr Token(Kind kind, nonstd::string_view text) : kind(kind), text(text) {}
1683    std::string describe() const {
1684      switch (kind) {
1685      case Kind::Text:
1686        return &quot;&lt;text&gt;&quot;;
1687      case Kind::LineStatementClose:
1688        return &quot;&lt;eol&gt;&quot;;
1689      case Kind::Eof:
1690        return &quot;&lt;eof&gt;&quot;;
1691      default:
1692        return static_cast&lt;std::string&gt;(text);
1693      }
1694    }
1695  };
1696  } 
1697  #endif 
1698  namespace inja {
1699  class Lexer {
1700    enum class State {
1701      Text,
1702      ExpressionStart,
1703      ExpressionStartForceLstrip,
1704      ExpressionBody,
1705      LineStart,
1706      LineBody,
1707      StatementStart,
1708      StatementStartNoLstrip,
1709      StatementStartForceLstrip,
1710      StatementBody,
1711      CommentStart,
1712      CommentStartForceLstrip,
1713      CommentBody,
1714    };
1715    enum class MinusState {
1716      Operator,
1717      Number,
1718    };
1719    const LexerConfig &amp;config;
1720    State state;
1721    MinusState minus_state;
1722    nonstd::string_view m_in;
1723    size_t tok_start;
1724    size_t pos;
1725    Token scan_body(nonstd::string_view close, Token::Kind closeKind, nonstd::string_view close_trim = nonstd::string_view(), bool trim = false) {
1726    again:
1727      if (tok_start &gt;= m_in.size()) {
1728        return make_token(Token::Kind::Eof);
1729      }
1730      const char ch = m_in[tok_start];
1731      if (ch == &#x27; &#x27; || ch == &#x27;\t&#x27; || ch == &#x27;\r&#x27;) {
1732        tok_start += 1;
1733        goto again;
1734      }
1735      if (!close_trim.empty() &amp;&amp; inja::string_view::starts_with(m_in.substr(tok_start), close_trim)) {
1736        state = State::Text;
1737        pos = tok_start + close_trim.size();
1738        const Token tok = make_token(closeKind);
1739        skip_whitespaces_and_newlines();
1740        return tok;
1741      }
1742      if (inja::string_view::starts_with(m_in.substr(tok_start), close)) {
1743        state = State::Text;
1744        pos = tok_start + close.size();
1745        const Token tok = make_token(closeKind);
1746        if (trim) {
1747          skip_whitespaces_and_first_newline();
1748        }
1749        return tok;
1750      }
1751      if (ch == &#x27;\n&#x27;) {
1752        tok_start += 1;
1753        goto again;
1754      }
1755      pos = tok_start + 1;
1756      if (std::isalpha(ch)) {
1757        minus_state = MinusState::Operator;
1758        return scan_id();
1759      }
1760      const MinusState current_minus_state = minus_state;
1761      if (minus_state == MinusState::Operator) {
1762        minus_state = MinusState::Number;
1763      }
1764      switch (ch) {
1765      case &#x27;+&#x27;:
1766        return make_token(Token::Kind::Plus);
1767      case &#x27;-&#x27;:
1768        if (current_minus_state == MinusState::Operator) {
1769          return make_token(Token::Kind::Minus);
1770        }
1771        return scan_number();
1772      case &#x27;*&#x27;:
1773        return make_token(Token::Kind::Times);
1774      case &#x27;/&#x27;:
1775        return make_token(Token::Kind::Slash);
1776      case &#x27;^&#x27;:
1777        return make_token(Token::Kind::Power);
1778      case &#x27;%&#x27;:
1779        return make_token(Token::Kind::Percent);
1780      case &#x27;.&#x27;:
1781        return make_token(Token::Kind::Dot);
1782      case &#x27;,&#x27;:
1783        return make_token(Token::Kind::Comma);
1784      case &#x27;:&#x27;:
1785        return make_token(Token::Kind::Colon);
1786      case &#x27;(&#x27;:
1787        return make_token(Token::Kind::LeftParen);
1788      case &#x27;)&#x27;:
1789        minus_state = MinusState::Operator;
1790        return make_token(Token::Kind::RightParen);
1791      case &#x27;[&#x27;:
1792        return make_token(Token::Kind::LeftBracket);
1793      case &#x27;]&#x27;:
1794        minus_state = MinusState::Operator;
1795        return make_token(Token::Kind::RightBracket);
1796      case &#x27;{&#x27;:
1797        return make_token(Token::Kind::LeftBrace);
1798      case &#x27;}&#x27;:
1799        minus_state = MinusState::Operator;
1800        return make_token(Token::Kind::RightBrace);
1801      case &#x27;&gt;&#x27;:
1802        if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;=&#x27;) {
1803          pos += 1;
1804          return make_token(Token::Kind::GreaterEqual);
1805        }
1806        return make_token(Token::Kind::GreaterThan);
1807      case &#x27;&lt;&#x27;:
1808        if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;=&#x27;) {
1809          pos += 1;
1810          return make_token(Token::Kind::LessEqual);
1811        }
1812        return make_token(Token::Kind::LessThan);
1813      case &#x27;=&#x27;:
1814        if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;=&#x27;) {
1815          pos += 1;
1816          return make_token(Token::Kind::Equal);
1817        }
1818        return make_token(Token::Kind::Unknown);
1819      case &#x27;!&#x27;:
1820        if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;=&#x27;) {
1821          pos += 1;
1822          return make_token(Token::Kind::NotEqual);
1823        }
1824        return make_token(Token::Kind::Unknown);
1825      case &#x27;\&quot;&#x27;:
1826        return scan_string();
1827      case &#x27;0&#x27;:
1828      case &#x27;1&#x27;:
1829      case &#x27;2&#x27;:
1830      case &#x27;3&#x27;:
1831      case &#x27;4&#x27;:
1832      case &#x27;5&#x27;:
1833      case &#x27;6&#x27;:
1834      case &#x27;7&#x27;:
1835      case &#x27;8&#x27;:
1836      case &#x27;9&#x27;:
1837        minus_state = MinusState::Operator;
1838        return scan_number();
1839      case &#x27;_&#x27;:
1840      case &#x27;@&#x27;:
1841      case &#x27;$&#x27;:
1842        minus_state = MinusState::Operator;
1843        return scan_id();
1844      default:
1845        return make_token(Token::Kind::Unknown);
1846      }
1847    }
1848    Token scan_id() {
1849      for (;;) {
1850        if (pos &gt;= m_in.size()) {
1851          break;
1852        }
1853        const char ch = m_in[pos];
1854        if (!std::isalnum(ch) &amp;&amp; ch != &#x27;.&#x27; &amp;&amp; ch != &#x27;/&#x27; &amp;&amp; ch != &#x27;_&#x27; &amp;&amp; ch != &#x27;-&#x27;) {
1855          break;
1856        }
1857        pos += 1;
1858      }
1859      return make_token(Token::Kind::Id);
1860    }
1861    Token scan_number() {
1862      for (;;) {
1863        if (pos &gt;= m_in.size()) {
1864          break;
1865        }
1866        const char ch = m_in[pos];
1867        if (!std::isdigit(ch) &amp;&amp; ch != &#x27;.&#x27; &amp;&amp; ch != &#x27;e&#x27; &amp;&amp; ch != &#x27;E&#x27; &amp;&amp; ch != &#x27;+&#x27; &amp;&amp; ch != &#x27;-&#x27;) {
1868          break;
1869        }
1870        pos += 1;
1871      }
1872      return make_token(Token::Kind::Number);
1873    }
1874    Token scan_string() {
1875      bool escape {false};
1876      for (;;) {
1877        if (pos &gt;= m_in.size()) {
1878          break;
1879        }
1880        const char ch = m_in[pos++];
1881        if (ch == &#x27;\\&#x27;) {
1882          escape = true;
1883        } else if (!escape &amp;&amp; ch == m_in[tok_start]) {
1884          break;
1885        } else {
1886          escape = false;
1887        }
1888      }
1889      return make_token(Token::Kind::String);
1890    }
1891    Token make_token(Token::Kind kind) const { return Token(kind, string_view::slice(m_in, tok_start, pos)); }
1892    void skip_whitespaces_and_newlines() {
1893      if (pos &lt; m_in.size()) {
1894        while (pos &lt; m_in.size() &amp;&amp; (m_in[pos] == &#x27; &#x27; || m_in[pos] == &#x27;\t&#x27; || m_in[pos] == &#x27;\n&#x27; || m_in[pos] == &#x27;\r&#x27;)) {
1895          pos += 1;
1896        }
1897      }
1898    }
1899    void skip_whitespaces_and_first_newline() {
1900      if (pos &lt; m_in.size()) {
1901        while (pos &lt; m_in.size() &amp;&amp; (m_in[pos] == &#x27; &#x27; || m_in[pos] == &#x27;\t&#x27;)) {
1902          pos += 1;
1903        }
1904      }
1905      if (pos &lt; m_in.size()) {
1906        const char ch = m_in[pos];
1907        if (ch == &#x27;\n&#x27;) {
1908          pos += 1;
1909        } else if (ch == &#x27;\r&#x27;) {
1910          pos += 1;
1911          if (pos &lt; m_in.size() &amp;&amp; m_in[pos] == &#x27;\n&#x27;) {
1912            pos += 1;
1913          }
1914        }
1915      }
1916    }
1917    static nonstd::string_view clear_final_line_if_whitespace(nonstd::string_view text) {
1918      nonstd::string_view result = text;
1919      while (!result.empty()) {
1920        const char ch = result.back();
1921        if (ch == &#x27; &#x27; || ch == &#x27;\t&#x27;) {
1922          result.remove_suffix(1);
1923        } else if (ch == &#x27;\n&#x27; || ch == &#x27;\r&#x27;) {
1924          break;
1925        } else {
1926          return text;
1927        }
1928      }
1929      return result;
1930    }
1931  public:
1932    explicit Lexer(const LexerConfig &amp;config) : config(config), state(State::Text), minus_state(MinusState::Number) {}
1933    SourceLocation current_position() const {
1934      return get_source_location(m_in, tok_start);
1935    }
1936    void start(nonstd::string_view input) {
1937      m_in = input;
1938      tok_start = 0;
1939      pos = 0;
1940      state = State::Text;
1941      minus_state = MinusState::Number;
1942      if (inja::string_view::starts_with(m_in, &quot;\xEF\xBB\xBF&quot;)) {
1943        m_in = m_in.substr(3);
1944      }
1945    }
1946    Token scan() {
1947      tok_start = pos;
1948    again:
1949      if (tok_start &gt;= m_in.size()) {
1950        return make_token(Token::Kind::Eof);
1951      }
1952      switch (state) {
1953      default:
1954      case State::Text: {
1955        const size_t open_start = m_in.substr(pos).find_first_of(config.open_chars);
1956        if (open_start == nonstd::string_view::npos) {
1957          pos = m_in.size();
1958          return make_token(Token::Kind::Text);
1959        }
1960        pos += open_start;
1961        nonstd::string_view open_str = m_in.substr(pos);
1962        bool must_lstrip = false;
1963        if (inja::string_view::starts_with(open_str, config.expression_open)) {
1964          if (inja::string_view::starts_with(open_str, config.expression_open_force_lstrip)) {
1965            state = State::ExpressionStartForceLstrip;
1966            must_lstrip = true;
1967          } else {
1968            state = State::ExpressionStart;
1969          }
1970        } else if (inja::string_view::starts_with(open_str, config.statement_open)) {
1971          if (inja::string_view::starts_with(open_str, config.statement_open_no_lstrip)) {
1972            state = State::StatementStartNoLstrip;
1973          } else if (inja::string_view::starts_with(open_str, config.statement_open_force_lstrip )) {
1974            state = State::StatementStartForceLstrip;
1975            must_lstrip = true;
1976          } else {
1977            state = State::StatementStart;
1978            must_lstrip = config.lstrip_blocks;
1979          }
1980        } else if (inja::string_view::starts_with(open_str, config.comment_open)) {
1981          if (inja::string_view::starts_with(open_str, config.comment_open_force_lstrip)) {
1982            state = State::CommentStartForceLstrip;
1983            must_lstrip = true;
1984          } else {
1985            state = State::CommentStart;
1986            must_lstrip = config.lstrip_blocks;
1987          }
1988        } else if ((pos == 0 || m_in[pos - 1] == &#x27;\n&#x27;) &amp;&amp; inja::string_view::starts_with(open_str, config.line_statement)) {
1989          state = State::LineStart;
1990        } else {
1991          pos += 1; 
1992          goto again;
1993        }
1994        nonstd::string_view text = string_view::slice(m_in, tok_start, pos);
1995        if (must_lstrip) {
1996          text = clear_final_line_if_whitespace(text);
1997        }
1998        if (text.empty()) {
1999          goto again; 
2000        }
2001        return Token(Token::Kind::Text, text);
2002      }
2003      case State::ExpressionStart: {
2004        state = State::ExpressionBody;
2005        pos += config.expression_open.size();
2006        return make_token(Token::Kind::ExpressionOpen);
2007      }
2008      case State::ExpressionStartForceLstrip: {
2009        state = State::ExpressionBody;
2010        pos += config.expression_open_force_lstrip.size();
2011        return make_token(Token::Kind::ExpressionOpen);
2012      }
2013      case State::LineStart: {
2014        state = State::LineBody;
2015        pos += config.line_statement.size();
2016        return make_token(Token::Kind::LineStatementOpen);
2017      }
2018      case State::StatementStart: {
2019        state = State::StatementBody;
2020        pos += config.statement_open.size();
2021        return make_token(Token::Kind::StatementOpen);
2022      }
2023      case State::StatementStartNoLstrip: {
2024        state = State::StatementBody;
2025        pos += config.statement_open_no_lstrip.size();
2026        return make_token(Token::Kind::StatementOpen);
2027      }
2028      case State::StatementStartForceLstrip: {
2029        state = State::StatementBody;
2030        pos += config.statement_open_force_lstrip.size();
2031        return make_token(Token::Kind::StatementOpen);
2032      }
2033      case State::CommentStart: {
2034        state = State::CommentBody;
2035        pos += config.comment_open.size();
2036        return make_token(Token::Kind::CommentOpen);
2037      }
2038      case State::CommentStartForceLstrip: {
2039        state = State::CommentBody;
2040        pos += config.comment_open_force_lstrip.size();
2041        return make_token(Token::Kind::CommentOpen);
2042      }
2043      case State::ExpressionBody:
2044        return scan_body(config.expression_close, Token::Kind::ExpressionClose, config.expression_close_force_rstrip);
2045      case State::LineBody:
2046        return scan_body(&quot;\n&quot;, Token::Kind::LineStatementClose);
2047      case State::StatementBody:
2048        return scan_body(config.statement_close, Token::Kind::StatementClose, config.statement_close_force_rstrip, config.trim_blocks);
2049      case State::CommentBody: {
2050        const size_t end = m_in.substr(pos).find(config.comment_close);
2051        if (end == nonstd::string_view::npos) {
2052          pos = m_in.size();
2053          return make_token(Token::Kind::Eof);
2054        }
2055        const bool must_rstrip = inja::string_view::starts_with(m_in.substr(pos + end - 1), config.comment_close_force_rstrip);
2056        state = State::Text;
2057        pos += end + config.comment_close.size();
2058        Token tok = make_token(Token::Kind::CommentClose);
2059        if (must_rstrip || config.trim_blocks) {
2060          skip_whitespaces_and_first_newline();
2061        }
2062        return tok;
2063      }
2064      }
2065    }
2066    const LexerConfig &amp;get_config() const {
2067      return config;
2068    }
2069  };
2070  } 
2071  #endif 
2072  namespace inja {
2073  class Parser {
2074    const ParserConfig &amp;config;
2075    Lexer lexer;
2076    TemplateStorage &amp;template_storage;
2077    const FunctionStorage &amp;function_storage;
2078    Token tok, peek_tok;
2079    bool have_peek_tok {false};
2080    size_t current_paren_level {0};
2081    size_t current_bracket_level {0};
2082    size_t current_brace_level {0};
2083    nonstd::string_view json_literal_start;
2084    BlockNode *current_block {nullptr};
2085    ExpressionListNode *current_expression_list {nullptr};
2086    std::stack&lt;std::pair&lt;FunctionNode*, size_t&gt;&gt; function_stack;
2087    std::vector&lt;std::shared_ptr&lt;ExpressionNode&gt;&gt; arguments;
2088    std::stack&lt;std::shared_ptr&lt;FunctionNode&gt;&gt; operator_stack;
2089    std::stack&lt;IfStatementNode*&gt; if_statement_stack;
2090    std::stack&lt;ForStatementNode*&gt; for_statement_stack;
2091    std::stack&lt;BlockStatementNode*&gt; block_statement_stack;
2092    inline void throw_parser_error(const std::string &amp;message) {
2093      INJA_THROW(ParserError(message, lexer.current_position()));
2094    }
2095    inline void get_next_token() {
2096      if (have_peek_tok) {
2097        tok = peek_tok;
2098        have_peek_tok = false;
2099      } else {
2100        tok = lexer.scan();
2101      }
2102    }
2103    inline void get_peek_token() {
2104      if (!have_peek_tok) {
2105        peek_tok = lexer.scan();
2106        have_peek_tok = true;
2107      }
2108    }
2109    inline void add_json_literal(const char* content_ptr) {
2110      nonstd::string_view json_text(json_literal_start.data(), tok.text.data() - json_literal_start.data() + tok.text.size());
2111      arguments.emplace_back(std::make_shared&lt;LiteralNode&gt;(json::parse(json_text), json_text.data() - content_ptr));
2112    }
2113    inline void add_operator() {
2114      auto function = operator_stack.top();
2115      operator_stack.pop();
2116      for (int i = 0; i &lt; function-&gt;number_args; ++i) {
2117        function-&gt;arguments.insert(function-&gt;arguments.begin(), arguments.back());
2118        arguments.pop_back();
2119      }
2120      arguments.emplace_back(function);
2121    }
2122    void add_to_template_storage(nonstd::string_view path, std::string&amp; template_name) {
2123      if (template_storage.find(template_name) != template_storage.end()) {
2124        return;
2125      }
2126      std::string original_path = static_cast&lt;std::string&gt;(path);
2127      std::string original_name = template_name;
2128      if (config.search_included_templates_in_files) {
2129        template_name = original_path + original_name;
2130        if (template_name.compare(0, 2, &quot;./&quot;) == 0) {
2131          template_name.erase(0, 2);
2132        }
2133        if (template_storage.find(template_name) == template_storage.end()) {
2134          std::ifstream file;
2135          file.open(template_name);
2136          if (!file.fail()) {
2137            std::string text((std::istreambuf_iterator&lt;char&gt;(file)), std::istreambuf_iterator&lt;char&gt;());
2138            auto include_template = Template(text);
2139            template_storage.emplace(template_name, include_template);
2140            parse_into_template(template_storage[template_name], template_name);
2141            return;
2142          } else if (!config.include_callback) {
2143            INJA_THROW(FileError(&quot;failed accessing file at &#x27;&quot; + template_name + &quot;&#x27;&quot;));
2144          }
2145        }
2146      }
2147      if (config.include_callback) {
2148        auto include_template = config.include_callback(original_path, original_name);
2149        template_storage.emplace(template_name, include_template);
2150      }
2151    }
2152    bool parse_expression(Template &amp;tmpl, Token::Kind closing) {
2153      while (tok.kind != closing &amp;&amp; tok.kind != Token::Kind::Eof) {
2154        switch (tok.kind) {
2155        case Token::Kind::String: {
2156          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2157            json_literal_start = tok.text;
2158            add_json_literal(tmpl.content.c_str());
2159          }
2160        } break;
2161        case Token::Kind::Number: {
2162          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2163            json_literal_start = tok.text;
2164            add_json_literal(tmpl.content.c_str());
2165          }
2166        } break;
2167        case Token::Kind::LeftBracket: {
2168          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2169            json_literal_start = tok.text;
2170          }
2171          current_bracket_level += 1;
2172        } break;
2173        case Token::Kind::LeftBrace: {
2174          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2175            json_literal_start = tok.text;
2176          }
2177          current_brace_level += 1;
2178        } break;
2179        case Token::Kind::RightBracket: {
2180          if (current_bracket_level == 0) {
2181            throw_parser_error(&quot;unexpected &#x27;]&#x27;&quot;);
2182          }
2183          current_bracket_level -= 1;
2184          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2185            add_json_literal(tmpl.content.c_str());
2186          }
2187        } break;
2188        case Token::Kind::RightBrace: {
2189          if (current_brace_level == 0) {
2190            throw_parser_error(&quot;unexpected &#x27;}&#x27;&quot;);
2191          }
2192          current_brace_level -= 1;
2193          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2194            add_json_literal(tmpl.content.c_str());
2195          }
2196        } break;
2197        case Token::Kind::Id: {
2198          get_peek_token();
2199          if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;true&quot;) || tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;false&quot;) || tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;null&quot;)) {
2200            if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2201              json_literal_start = tok.text;
2202              add_json_literal(tmpl.content.c_str());
2203            }
2204          } else if (tok.text == &quot;and&quot; || tok.text == &quot;or&quot; || tok.text == &quot;in&quot; || tok.text == &quot;not&quot;) {
2205            goto parse_operator;
2206          } else if (peek_tok.kind == Token::Kind::LeftParen) {
2207            operator_stack.emplace(std::make_shared&lt;FunctionNode&gt;(static_cast&lt;std::string&gt;(tok.text), tok.text.data() - tmpl.content.c_str()));
2208            function_stack.emplace(operator_stack.top().get(), current_paren_level);       
2209          } else {
2210            arguments.emplace_back(std::make_shared&lt;JsonNode&gt;(static_cast&lt;std::string&gt;(tok.text), tok.text.data() - tmpl.content.c_str()));
2211          }
2212        } break;
2213        case Token::Kind::Equal:
2214        case Token::Kind::NotEqual:
2215        case Token::Kind::GreaterThan:
2216        case Token::Kind::GreaterEqual:
2217        case Token::Kind::LessThan:
2218        case Token::Kind::LessEqual:
2219        case Token::Kind::Plus:
2220        case Token::Kind::Minus:
2221        case Token::Kind::Times:
2222        case Token::Kind::Slash:
2223        case Token::Kind::Power:
2224        case Token::Kind::Percent:
2225        case Token::Kind::Dot: {
2226    parse_operator:
2227          FunctionStorage::Operation operation;
2228          switch (tok.kind) {
2229          case Token::Kind::Id: {
2230            if (tok.text == &quot;and&quot;) {
2231              operation = FunctionStorage::Operation::And;
2232            } else if (tok.text == &quot;or&quot;) {
2233              operation = FunctionStorage::Operation::Or;
2234            } else if (tok.text == &quot;in&quot;) {
2235              operation = FunctionStorage::Operation::In;
2236            } else if (tok.text == &quot;not&quot;) {
2237              operation = FunctionStorage::Operation::Not;
2238            } else {
2239              throw_parser_error(&quot;unknown operator in parser.&quot;);
2240            }
2241          } break;
2242          case Token::Kind::Equal: {
2243            operation = FunctionStorage::Operation::Equal;
2244          } break;
2245          case Token::Kind::NotEqual: {
2246            operation = FunctionStorage::Operation::NotEqual;
2247          } break;
2248          case Token::Kind::GreaterThan: {
2249            operation = FunctionStorage::Operation::Greater;
2250          } break;
2251          case Token::Kind::GreaterEqual: {
2252            operation = FunctionStorage::Operation::GreaterEqual;
2253          } break;
2254          case Token::Kind::LessThan: {
2255            operation = FunctionStorage::Operation::Less;
2256          } break;
2257          case Token::Kind::LessEqual: {
2258            operation = FunctionStorage::Operation::LessEqual;
2259          } break;
2260          case Token::Kind::Plus: {
2261            operation = FunctionStorage::Operation::Add;
2262          } break;
2263          case Token::Kind::Minus: {
2264            operation = FunctionStorage::Operation::Subtract;
2265          } break;
2266          case Token::Kind::Times: {
2267            operation = FunctionStorage::Operation::Multiplication;
2268          } break;
2269          case Token::Kind::Slash: {
2270            operation = FunctionStorage::Operation::Division;
2271          } break;
2272          case Token::Kind::Power: {
2273            operation = FunctionStorage::Operation::Power;
2274          } break;
2275          case Token::Kind::Percent: {
2276            operation = FunctionStorage::Operation::Modulo;
2277          } break;
2278          case Token::Kind::Dot: {
2279            operation = FunctionStorage::Operation::AtId;
2280          } break;
2281          default: {
2282            throw_parser_error(&quot;unknown operator in parser.&quot;);
2283          }
2284          }
2285          auto function_node = std::make_shared&lt;FunctionNode&gt;(operation, tok.text.data() - tmpl.content.c_str());
2286          while (!operator_stack.empty() &amp;&amp; ((operator_stack.top()-&gt;precedence &gt; function_node-&gt;precedence) || (operator_stack.top()-&gt;precedence == function_node-&gt;precedence &amp;&amp; function_node-&gt;associativity == FunctionNode::Associativity::Left)) &amp;&amp; (operator_stack.top()-&gt;operation != FunctionStorage::Operation::ParenLeft)) {
2287            add_operator();
2288          }
2289          operator_stack.emplace(function_node);
2290        } break;
2291        case Token::Kind::Comma: {
2292          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2293            if (function_stack.empty()) {
2294              throw_parser_error(&quot;unexpected &#x27;,&#x27;&quot;);
2295            }
2296            function_stack.top().first-&gt;number_args += 1;
2297          }
2298        } break;
2299        case Token::Kind::Colon: {
2300          if (current_brace_level == 0 &amp;&amp; current_bracket_level == 0) {
2301            throw_parser_error(&quot;unexpected &#x27;:&#x27;&quot;);
2302          }
2303        } break;
2304        case Token::Kind::LeftParen: {
2305          current_paren_level += 1;
2306          operator_stack.emplace(std::make_shared&lt;FunctionNode&gt;(FunctionStorage::Operation::ParenLeft, tok.text.data() - tmpl.content.c_str()));
2307          get_peek_token();
2308          if (peek_tok.kind == Token::Kind::RightParen) {
2309            if (!function_stack.empty() &amp;&amp; function_stack.top().second == current_paren_level - 1) {
2310              function_stack.top().first-&gt;number_args = 0;
2311            }
2312          }
2313        } break;
2314        case Token::Kind::RightParen: {
2315          current_paren_level -= 1;
2316          while (!operator_stack.empty() &amp;&amp; operator_stack.top()-&gt;operation != FunctionStorage::Operation::ParenLeft) {
2317            add_operator();
2318          }
2319          if (!operator_stack.empty() &amp;&amp; operator_stack.top()-&gt;operation == FunctionStorage::Operation::ParenLeft) {
2320            operator_stack.pop();
2321          }
2322          if (!function_stack.empty() &amp;&amp; function_stack.top().second == current_paren_level) {
2323            auto func = function_stack.top().first;
2324            auto function_data = function_storage.find_function(func-&gt;name, func-&gt;number_args);
2325            if (function_data.operation == FunctionStorage::Operation::None) {
2326              throw_parser_error(&quot;unknown function &quot; + func-&gt;name);
2327            }
2328            func-&gt;operation = function_data.operation;
2329            if (function_data.operation == FunctionStorage::Operation::Callback) {
2330              func-&gt;callback = function_data.callback;
2331            }
2332            if (operator_stack.empty()) {
2333              throw_parser_error(&quot;internal error at function &quot; + func-&gt;name);
2334            }
2335            add_operator();
2336            function_stack.pop();
2337          }
2338        }
2339        default:
2340          break;
2341        }
2342        get_next_token();
2343      }
2344      while (!operator_stack.empty()) {
2345        add_operator();
2346      }
2347      if (arguments.size() == 1) {
2348        current_expression_list-&gt;root = arguments[0];
2349        arguments = {};
2350      } else if (arguments.size() &gt; 1) {
2351        throw_parser_error(&quot;malformed expression&quot;);
2352      }
2353      return true;
2354    }
2355    bool parse_statement(Template &amp;tmpl, Token::Kind closing, nonstd::string_view path) {
2356      if (tok.kind != Token::Kind::Id) {
2357        return false;
2358      }
2359      if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;if&quot;)) {
2360        get_next_token();
2361        auto if_statement_node = std::make_shared&lt;IfStatementNode&gt;(current_block, tok.text.data() - tmpl.content.c_str());
2362        current_block-&gt;nodes.emplace_back(if_statement_node);
2363        if_statement_stack.emplace(if_statement_node.get());
2364        current_block = &amp;if_statement_node-&gt;true_statement;
2365        current_expression_list = &amp;if_statement_node-&gt;condition;
2366        if (!parse_expression(tmpl, closing)) {
2367          return false;
2368        }
2369      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;else&quot;)) {
2370        if (if_statement_stack.empty()) {
2371          throw_parser_error(&quot;else without matching if&quot;);
2372        }
2373        auto &amp;if_statement_data = if_statement_stack.top();
2374        get_next_token();
2375        if_statement_data-&gt;has_false_statement = true;
2376        current_block = &amp;if_statement_data-&gt;false_statement;
2377        if (tok.kind == Token::Kind::Id &amp;&amp; tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;if&quot;)) {
2378          get_next_token();
2379          auto if_statement_node = std::make_shared&lt;IfStatementNode&gt;(true, current_block, tok.text.data() - tmpl.content.c_str());
2380          current_block-&gt;nodes.emplace_back(if_statement_node);
2381          if_statement_stack.emplace(if_statement_node.get());
2382          current_block = &amp;if_statement_node-&gt;true_statement;
2383          current_expression_list = &amp;if_statement_node-&gt;condition;
2384          if (!parse_expression(tmpl, closing)) {
2385            return false;
2386          }
2387        }
2388      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;endif&quot;)) {
2389        if (if_statement_stack.empty()) {
2390          throw_parser_error(&quot;endif without matching if&quot;);
2391        }
2392        while (if_statement_stack.top()-&gt;is_nested) {
2393          if_statement_stack.pop();
2394        }
2395        auto &amp;if_statement_data = if_statement_stack.top();
2396        get_next_token();
2397        current_block = if_statement_data-&gt;parent;
2398        if_statement_stack.pop();
2399      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;block&quot;)) {
2400        get_next_token();
2401        if (tok.kind != Token::Kind::Id) {
2402          throw_parser_error(&quot;expected block name, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2403        }
2404        const std::string block_name = static_cast&lt;std::string&gt;(tok.text);
2405        auto block_statement_node = std::make_shared&lt;BlockStatementNode&gt;(current_block, block_name, tok.text.data() - tmpl.content.c_str());
2406        current_block-&gt;nodes.emplace_back(block_statement_node);
2407        block_statement_stack.emplace(block_statement_node.get());
2408        current_block = &amp;block_statement_node-&gt;block;
2409        auto success = tmpl.block_storage.emplace(block_name, block_statement_node);
2410        if (!success.second) {
2411          throw_parser_error(&quot;block with the name &#x27;&quot; + block_name + &quot;&#x27; does already exist&quot;);
2412        }
2413        get_next_token();
2414      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;endblock&quot;)) {
2415        if (block_statement_stack.empty()) {
2416          throw_parser_error(&quot;endblock without matching block&quot;);
2417        }
2418        auto &amp;block_statement_data = block_statement_stack.top();
2419        get_next_token();
2420        current_block = block_statement_data-&gt;parent;
2421        block_statement_stack.pop();
2422      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;for&quot;)) {
2423        get_next_token();
2424        if (tok.kind != Token::Kind::Id) {
2425          throw_parser_error(&quot;expected id, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2426        }
2427        Token value_token = tok;
2428        get_next_token();
2429        std::shared_ptr&lt;ForStatementNode&gt; for_statement_node;
2430        if (tok.kind == Token::Kind::Comma) {
2431          get_next_token();
2432          if (tok.kind != Token::Kind::Id) {
2433            throw_parser_error(&quot;expected id, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2434          }
2435          Token key_token = std::move(value_token);
2436          value_token = tok;
2437          get_next_token();
2438          for_statement_node = std::make_shared&lt;ForObjectStatementNode&gt;(static_cast&lt;std::string&gt;(key_token.text), static_cast&lt;std::string&gt;(value_token.text), current_block, tok.text.data() - tmpl.content.c_str());
2439        } else {
2440          for_statement_node = std::make_shared&lt;ForArrayStatementNode&gt;(static_cast&lt;std::string&gt;(value_token.text), current_block, tok.text.data() - tmpl.content.c_str());
2441        }
2442        current_block-&gt;nodes.emplace_back(for_statement_node);
2443        for_statement_stack.emplace(for_statement_node.get());
2444        current_block = &amp;for_statement_node-&gt;body;
2445        current_expression_list = &amp;for_statement_node-&gt;condition;
2446        if (tok.kind != Token::Kind::Id || tok.text != static_cast&lt;decltype(tok.text)&gt;(&quot;in&quot;)) {
2447          throw_parser_error(&quot;expected &#x27;in&#x27;, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2448        }
2449        get_next_token();
2450        if (!parse_expression(tmpl, closing)) {
2451          return false;
2452        }
2453      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;endfor&quot;)) {
2454        if (for_statement_stack.empty()) {
2455          throw_parser_error(&quot;endfor without matching for&quot;);
2456        }
2457        auto &amp;for_statement_data = for_statement_stack.top();
2458        get_next_token();
2459        current_block = for_statement_data-&gt;parent;
2460        for_statement_stack.pop();
2461      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;include&quot;)) {
2462        get_next_token();
2463        if (tok.kind != Token::Kind::String) {
2464          throw_parser_error(&quot;expected string, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2465        }
2466        std::string template_name = json::parse(tok.text).get_ref&lt;const std::string &amp;&gt;();
2467        add_to_template_storage(path, template_name);
2468        current_block-&gt;nodes.emplace_back(std::make_shared&lt;IncludeStatementNode&gt;(template_name, tok.text.data() - tmpl.content.c_str()));
2469        get_next_token();
2470      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;extends&quot;)) {
2471        get_next_token();
2472        if (tok.kind != Token::Kind::String) {
2473          throw_parser_error(&quot;expected string, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2474        }
2475        std::string template_name = json::parse(tok.text).get_ref&lt;const std::string &amp;&gt;();
2476        add_to_template_storage(path, template_name);
2477        current_block-&gt;nodes.emplace_back(std::make_shared&lt;ExtendsStatementNode&gt;(template_name, tok.text.data() - tmpl.content.c_str()));
2478        get_next_token();
2479      } else if (tok.text == static_cast&lt;decltype(tok.text)&gt;(&quot;set&quot;)) {
2480        get_next_token();
2481        if (tok.kind != Token::Kind::Id) {
2482          throw_parser_error(&quot;expected variable name, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2483        }
2484        std::string key = static_cast&lt;std::string&gt;(tok.text);
2485        get_next_token();
2486        auto set_statement_node = std::make_shared&lt;SetStatementNode&gt;(key, tok.text.data() - tmpl.content.c_str());
2487        current_block-&gt;nodes.emplace_back(set_statement_node);
2488        current_expression_list = &amp;set_statement_node-&gt;expression;
2489        if (tok.text != static_cast&lt;decltype(tok.text)&gt;(&quot;=&quot;)) {
2490          throw_parser_error(&quot;expected &#x27;=&#x27;, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2491        }
2492        get_next_token();
2493        if (!parse_expression(tmpl, closing)) {
2494          return false;
2495        }
2496      } else {
2497        return false;
2498      }
2499      return true;
2500    }
2501    void parse_into(Template &amp;tmpl, nonstd::string_view path) {
2502      lexer.start(tmpl.content);
2503      current_block = &amp;tmpl.root;
2504      for (;;) {
2505        get_next_token();
2506        switch (tok.kind) {
2507        case Token::Kind::Eof: {
2508          if (!if_statement_stack.empty()) {
2509            throw_parser_error(&quot;unmatched if&quot;);
2510          }
2511          if (!for_statement_stack.empty()) {
2512            throw_parser_error(&quot;unmatched for&quot;);
2513          }
2514        } return;
2515        case Token::Kind::Text: {
2516          current_block-&gt;nodes.emplace_back(std::make_shared&lt;TextNode&gt;(tok.text.data() - tmpl.content.c_str(), tok.text.size()));
2517        } break;
2518        case Token::Kind::StatementOpen: {
2519          get_next_token();
2520          if (!parse_statement(tmpl, Token::Kind::StatementClose, path)) {
2521            throw_parser_error(&quot;expected statement, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2522          }
2523          if (tok.kind != Token::Kind::StatementClose) {
2524            throw_parser_error(&quot;expected statement close, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2525          }
2526        } break;
2527        case Token::Kind::LineStatementOpen: {
2528          get_next_token();
2529          if (!parse_statement(tmpl, Token::Kind::LineStatementClose, path)) {
2530            throw_parser_error(&quot;expected statement, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2531          }
2532          if (tok.kind != Token::Kind::LineStatementClose &amp;&amp; tok.kind != Token::Kind::Eof) {
2533            throw_parser_error(&quot;expected line statement close, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2534          }
2535        } break;
2536        case Token::Kind::ExpressionOpen: {
2537          get_next_token();
2538          auto expression_list_node = std::make_shared&lt;ExpressionListNode&gt;(tok.text.data() - tmpl.content.c_str());
2539          current_block-&gt;nodes.emplace_back(expression_list_node);
2540          current_expression_list = expression_list_node.get();
2541          if (!parse_expression(tmpl, Token::Kind::ExpressionClose)) {
2542            throw_parser_error(&quot;expected expression, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2543          }
2544          if (tok.kind != Token::Kind::ExpressionClose) {
2545            throw_parser_error(&quot;expected expression close, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2546          }
2547        } break;
2548        case Token::Kind::CommentOpen: {
2549          get_next_token();
2550          if (tok.kind != Token::Kind::CommentClose) {
2551            throw_parser_error(&quot;expected comment close, got &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2552          }
2553        } break;
2554        default: {
2555          throw_parser_error(&quot;unexpected token &#x27;&quot; + tok.describe() + &quot;&#x27;&quot;);
2556        } break;
2557        }
2558      }
2559    }
2560  public:
2561    explicit Parser(const ParserConfig &amp;parser_config, const LexerConfig &amp;lexer_config,
2562                    TemplateStorage &amp;template_storage, const FunctionStorage &amp;function_storage)
2563        : config(parser_config), lexer(lexer_config), template_storage(template_storage), function_storage(function_storage) { }
2564    Template parse(nonstd::string_view input, nonstd::string_view path) {
2565      auto result = Template(static_cast&lt;std::string&gt;(input));
2566      parse_into(result, path);
2567      return result;
2568    }
2569    Template parse(nonstd::string_view input) {
2570      return parse(input, &quot;./&quot;);
2571    }
2572    void parse_into_template(Template&amp; tmpl, nonstd::string_view filename) {
2573      nonstd::string_view path = filename.substr(0, filename.find_last_of(&quot;/\\&quot;) + 1);
2574      auto sub_parser = Parser(config, lexer.get_config(), template_storage, function_storage);
2575      sub_parser.parse_into(tmpl, path);
2576    }
2577    std::string load_file(const std::string&amp; filename) {
2578      std::ifstream file;
2579      file.open(filename);
2580      if (file.fail()) {
2581        INJA_THROW(FileError(&quot;failed accessing file at &#x27;&quot; + filename + &quot;&#x27;&quot;));
2582      }
2583      std::string text((std::istreambuf_iterator&lt;char&gt;(file)), std::istreambuf_iterator&lt;char&gt;());
2584      return text;
2585    }
2586  };
2587  } 
2588  #endif 
2589  #ifndef INCLUDE_INJA_RENDERER_HPP_
2590  #define INCLUDE_INJA_RENDERER_HPP_
2591  #include &lt;algorithm&gt;
2592  #include &lt;numeric&gt;
2593  #include &lt;string&gt;
2594  #include &lt;utility&gt;
2595  #include &lt;vector&gt;
2596  namespace inja {
2597  class Renderer : public NodeVisitor  {
2598    using Op = FunctionStorage::Operation;
2599    const RenderConfig config;
2600    const TemplateStorage &amp;template_storage;
2601    const FunctionStorage &amp;function_storage;
2602    const Template *current_template;
2603    size_t current_level {0};
2604    std::vector&lt;const Template*&gt; template_stack;
2605    std::vector&lt;const BlockStatementNode*&gt; block_statement_stack;
2606    const json *json_input;
2607    std::ostream *output_stream;
2608    json json_additional_data;
2609    json* current_loop_data = &amp;json_additional_data[&quot;loop&quot;];
2610    std::vector&lt;std::shared_ptr&lt;json&gt;&gt; json_tmp_stack;
2611    std::stack&lt;const json*&gt; json_eval_stack;
2612    std::stack&lt;const JsonNode*&gt; not_found_stack;
2613    bool break_rendering {false};
2614    bool truthy(const json* data) const {
2615      if (data-&gt;is_boolean()) {
2616        return data-&gt;get&lt;bool&gt;();
2617      } else if (data-&gt;is_number()) {
2618        return (*data != 0);
2619      } else if (data-&gt;is_null()) {
2620        return false;
2621      }
2622      return !data-&gt;empty();
2623    }
2624    void print_json(const std::shared_ptr&lt;json&gt; value) {
2625      if (value-&gt;is_string()) {
2626        *output_stream &lt;&lt; value-&gt;get_ref&lt;const json::string_t&amp;&gt;();
2627      } else if (value-&gt;is_number_integer()) {
2628        *output_stream &lt;&lt; value-&gt;get&lt;const json::number_integer_t&gt;();
2629      } else if (value-&gt;is_null()) {
2630      } else {
2631        *output_stream &lt;&lt; value-&gt;dump();
2632      }
2633    }
2634    const std::shared_ptr&lt;json&gt; eval_expression_list(const ExpressionListNode&amp; expression_list) {
2635      if (!expression_list.root) {
2636        throw_renderer_error(&quot;empty expression&quot;, expression_list);
2637      }
2638      expression_list.root-&gt;accept(*this);
2639      if (json_eval_stack.empty()) {
2640        throw_renderer_error(&quot;empty expression&quot;, expression_list);
2641      } else if (json_eval_stack.size() != 1) {
2642        throw_renderer_error(&quot;malformed expression&quot;, expression_list);
2643      }
2644      const auto result = json_eval_stack.top();
2645      json_eval_stack.pop();
2646      if (!result) {
2647        if (not_found_stack.empty()) {
2648          throw_renderer_error(&quot;expression could not be evaluated&quot;, expression_list);
2649        }
2650        auto node = not_found_stack.top();
2651        not_found_stack.pop();
2652        throw_renderer_error(&quot;variable &#x27;&quot; + static_cast&lt;std::string&gt;(node-&gt;name) + &quot;&#x27; not found&quot;, *node);
2653      }
2654      return std::make_shared&lt;json&gt;(*result);
2655    }
2656    void throw_renderer_error(const std::string &amp;message, const AstNode&amp; node) {
2657      SourceLocation loc = get_source_location(current_template-&gt;content, node.pos);
2658      INJA_THROW(RenderError(message, loc));
2659    }
2660    template&lt;size_t N, size_t N_start = 0, bool throw_not_found=true&gt;
2661    std::array&lt;const json*, N&gt; get_arguments(const FunctionNode&amp; node) {
2662      if (node.arguments.size() &lt; N_start + N) {
2663        throw_renderer_error(&quot;function needs &quot; + std::to_string(N_start + N) + &quot; variables, but has only found &quot; + std::to_string(node.arguments.size()), node);
2664      }
2665      for (size_t i = N_start; i &lt; N_start + N; i += 1) {
2666        node.arguments[i]-&gt;accept(*this);
2667      }
2668      if (json_eval_stack.size() &lt; N) {
2669        throw_renderer_error(&quot;function needs &quot; + std::to_string(N) + &quot; variables, but has only found &quot; + std::to_string(json_eval_stack.size()), node);
2670      }
2671      std::array&lt;const json*, N&gt; result;
2672      for (size_t i = 0; i &lt; N; i += 1) {
2673        result[N - i - 1] = json_eval_stack.top();
2674        json_eval_stack.pop();
2675        if (!result[N - i - 1]) {
2676          const auto json_node = not_found_stack.top();
2677          not_found_stack.pop();
2678          if (throw_not_found) {
2679            throw_renderer_error(&quot;variable &#x27;&quot; + static_cast&lt;std::string&gt;(json_node-&gt;name) + &quot;&#x27; not found&quot;, *json_node);
2680          }
2681        }
2682      }
2683      return result;
2684    }
2685    template&lt;bool throw_not_found=true&gt;
2686    Arguments get_argument_vector(const FunctionNode&amp; node) {
2687      const size_t N = node.arguments.size();
2688      for (auto a: node.arguments) {
2689        a-&gt;accept(*this);
2690      }
2691      if (json_eval_stack.size() &lt; N) {
2692        throw_renderer_error(&quot;function needs &quot; + std::to_string(N) + &quot; variables, but has only found &quot; + std::to_string(json_eval_stack.size()), node);
2693      }
2694      Arguments result {N};
2695      for (size_t i = 0; i &lt; N; i += 1) {
2696        result[N - i - 1] = json_eval_stack.top();
2697        json_eval_stack.pop();
2698        if (!result[N - i - 1]) {
2699          const auto json_node = not_found_stack.top();
2700          not_found_stack.pop();
2701          if (throw_not_found) {
2702            throw_renderer_error(&quot;variable &#x27;&quot; + static_cast&lt;std::string&gt;(json_node-&gt;name) + &quot;&#x27; not found&quot;, *json_node);
2703          }
2704        }
2705      }
2706      return result;
2707    }
2708    void visit(const BlockNode&amp; node) {
2709      for (auto&amp; n : node.nodes) {
2710        n-&gt;accept(*this);
2711        if (break_rendering) {
2712          break;
2713        }
2714      }
2715    }
2716    void visit(const TextNode&amp; node) {
2717      output_stream-&gt;write(current_template-&gt;content.c_str() + node.pos, node.length);
2718    }
2719    void visit(const ExpressionNode&amp;) { }
2720    void visit(const LiteralNode&amp; node) {
2721      json_eval_stack.push(&amp;node.value);
2722    }
2723    void visit(const JsonNode&amp; node) {
2724      if (json_additional_data.contains(node.ptr)) {
2725        json_eval_stack.push(&amp;(json_additional_data[node.ptr]));
2726      } else if (json_input-&gt;contains(node.ptr)) {
2727        json_eval_stack.push(&amp;(*json_input)[node.ptr]);
2728      } else {
2729        const auto function_data = function_storage.find_function(node.name, 0);
2730        if (function_data.operation == FunctionStorage::Operation::Callback) {
2731          Arguments empty_args {};
2732          const auto value = std::make_shared&lt;json&gt;(function_data.callback(empty_args));
2733          json_tmp_stack.push_back(value);
2734          json_eval_stack.push(value.get());
2735        } else {
2736          json_eval_stack.push(nullptr);
2737          not_found_stack.emplace(&amp;node);
2738        }
2739      }
2740    }
2741    void visit(const FunctionNode&amp; node) {
2742      std::shared_ptr&lt;json&gt; result_ptr;
2743      switch (node.operation) {
2744      case Op::Not: {
2745        const auto args = get_arguments&lt;1&gt;(node);
2746        result_ptr = std::make_shared&lt;json&gt;(!truthy(args[0]));
2747        json_tmp_stack.push_back(result_ptr);
2748        json_eval_stack.push(result_ptr.get());
2749      } break;
2750      case Op::And: {
2751        result_ptr = std::make_shared&lt;json&gt;(truthy(get_arguments&lt;1, 0&gt;(node)[0]) &amp;&amp; truthy(get_arguments&lt;1, 1&gt;(node)[0]));
2752        json_tmp_stack.push_back(result_ptr);
2753        json_eval_stack.push(result_ptr.get());
2754      } break;
2755      case Op::Or: {
2756        result_ptr = std::make_shared&lt;json&gt;(truthy(get_arguments&lt;1, 0&gt;(node)[0]) || truthy(get_arguments&lt;1, 1&gt;(node)[0]));
2757        json_tmp_stack.push_back(result_ptr);
2758        json_eval_stack.push(result_ptr.get());
2759      } break;
2760      case Op::In: {
2761        const auto args = get_arguments&lt;2&gt;(node);
2762        result_ptr = std::make_shared&lt;json&gt;(std::find(args[1]-&gt;begin(), args[1]-&gt;end(), *args[0]) != args[1]-&gt;end());
2763        json_tmp_stack.push_back(result_ptr);
2764        json_eval_stack.push(result_ptr.get());
2765      } break;
2766      case Op::Equal: {
2767        const auto args = get_arguments&lt;2&gt;(node);
2768        result_ptr = std::make_shared&lt;json&gt;(*args[0] == *args[1]);
2769        json_tmp_stack.push_back(result_ptr);
2770        json_eval_stack.push(result_ptr.get());
2771      } break;
2772      case Op::NotEqual: {
2773        const auto args = get_arguments&lt;2&gt;(node);
2774        result_ptr = std::make_shared&lt;json&gt;(*args[0] != *args[1]);
2775        json_tmp_stack.push_back(result_ptr);
2776        json_eval_stack.push(result_ptr.get());
2777      } break;
2778      case Op::Greater: {
2779        const auto args = get_arguments&lt;2&gt;(node);
2780        result_ptr = std::make_shared&lt;json&gt;(*args[0] &gt; *args[1]);
2781        json_tmp_stack.push_back(result_ptr);
2782        json_eval_stack.push(result_ptr.get());
2783      } break;
2784      case Op::GreaterEqual: {
2785        const auto args = get_arguments&lt;2&gt;(node);
2786        result_ptr = std::make_shared&lt;json&gt;(*args[0] &gt;= *args[1]);
2787        json_tmp_stack.push_back(result_ptr);
2788        json_eval_stack.push(result_ptr.get());
2789      } break;
2790      case Op::Less: {
2791        const auto args = get_arguments&lt;2&gt;(node);
2792        result_ptr = std::make_shared&lt;json&gt;(*args[0] &lt; *args[1]);
2793        json_tmp_stack.push_back(result_ptr);
2794        json_eval_stack.push(result_ptr.get());
2795      } break;
2796      case Op::LessEqual: {
2797        const auto args = get_arguments&lt;2&gt;(node);
2798        result_ptr = std::make_shared&lt;json&gt;(*args[0] &lt;= *args[1]);
2799        json_tmp_stack.push_back(result_ptr);
2800        json_eval_stack.push(result_ptr.get());
2801      } break;
2802      case Op::Add: {
2803        const auto args = get_arguments&lt;2&gt;(node);
2804        if (args[0]-&gt;is_string() &amp;&amp; args[1]-&gt;is_string()) {
2805          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get_ref&lt;const std::string&amp;&gt;() + args[1]-&gt;get_ref&lt;const std::string&amp;&gt;());
2806          json_tmp_stack.push_back(result_ptr);
2807        } else if (args[0]-&gt;is_number_integer() &amp;&amp; args[1]-&gt;is_number_integer()) {
2808          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;int&gt;() + args[1]-&gt;get&lt;int&gt;());
2809          json_tmp_stack.push_back(result_ptr);
2810        } else {
2811          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;double&gt;() + args[1]-&gt;get&lt;double&gt;());
2812          json_tmp_stack.push_back(result_ptr);
2813        }
2814        json_eval_stack.push(result_ptr.get());
2815      } break;
2816      case Op::Subtract: {
2817        const auto args = get_arguments&lt;2&gt;(node);
2818        if (args[0]-&gt;is_number_integer() &amp;&amp; args[1]-&gt;is_number_integer()) {
2819          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;int&gt;() - args[1]-&gt;get&lt;int&gt;());
2820          json_tmp_stack.push_back(result_ptr);
2821        } else {
2822          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;double&gt;() - args[1]-&gt;get&lt;double&gt;());
2823          json_tmp_stack.push_back(result_ptr);
2824        }
2825        json_eval_stack.push(result_ptr.get());
2826      } break;
2827      case Op::Multiplication: {
2828        const auto args = get_arguments&lt;2&gt;(node);
2829        if (args[0]-&gt;is_number_integer() &amp;&amp; args[1]-&gt;is_number_integer()) {
2830          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;int&gt;() * args[1]-&gt;get&lt;int&gt;());
2831          json_tmp_stack.push_back(result_ptr);
2832        } else {
2833          result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;double&gt;() * args[1]-&gt;get&lt;double&gt;());
2834          json_tmp_stack.push_back(result_ptr);
2835        }
2836        json_eval_stack.push(result_ptr.get());
2837      } break;
2838      case Op::Division: {
2839        const auto args = get_arguments&lt;2&gt;(node);
2840        if (args[1]-&gt;get&lt;double&gt;() == 0) {
2841          throw_renderer_error(&quot;division by zero&quot;, node);
2842        }
2843        result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;double&gt;() / args[1]-&gt;get&lt;double&gt;());
2844        json_tmp_stack.push_back(result_ptr);
2845        json_eval_stack.push(result_ptr.get());
2846      } break;
2847      case Op::Power: {
2848        const auto args = get_arguments&lt;2&gt;(node);
2849        if (args[0]-&gt;is_number_integer() &amp;&amp; args[1]-&gt;get&lt;int&gt;() &gt;= 0) {
2850          int result = static_cast&lt;int&gt;(std::pow(args[0]-&gt;get&lt;int&gt;(), args[1]-&gt;get&lt;int&gt;()));
2851          result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2852          json_tmp_stack.push_back(result_ptr);
2853        } else {
2854          double result = std::pow(args[0]-&gt;get&lt;double&gt;(), args[1]-&gt;get&lt;int&gt;());
2855          result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2856          json_tmp_stack.push_back(result_ptr);
2857        }
2858        json_eval_stack.push(result_ptr.get());
2859      } break;
2860      case Op::Modulo: {
2861        const auto args = get_arguments&lt;2&gt;(node);
2862        result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;get&lt;int&gt;() % args[1]-&gt;get&lt;int&gt;());
2863        json_tmp_stack.push_back(result_ptr);
2864        json_eval_stack.push(result_ptr.get());
2865      } break;
2866      case Op::AtId: {
2867        const auto container = get_arguments&lt;1, 0, false&gt;(node)[0];
2868        node.arguments[1]-&gt;accept(*this);
2869        if (not_found_stack.empty()) {
2870          throw_renderer_error(&quot;could not find element with given name&quot;, node);
2871        }
2872        const auto id_node = not_found_stack.top();
2873        not_found_stack.pop();
2874        json_eval_stack.pop();
2875        json_eval_stack.push(&amp;container-&gt;at(id_node-&gt;name));
2876      } break;
2877      case Op::At: {
2878        const auto args = get_arguments&lt;2&gt;(node);
2879        if (args[0]-&gt;is_object()) {
2880          json_eval_stack.push(&amp;args[0]-&gt;at(args[1]-&gt;get&lt;std::string&gt;()));
2881        } else {
2882          json_eval_stack.push(&amp;args[0]-&gt;at(args[1]-&gt;get&lt;int&gt;()));
2883        }
2884      } break;
2885      case Op::Default: {
2886        const auto test_arg = get_arguments&lt;1, 0, false&gt;(node)[0];
2887        json_eval_stack.push(test_arg ? test_arg : get_arguments&lt;1, 1&gt;(node)[0]);
2888      } break;
2889      case Op::DivisibleBy: {
2890        const auto args = get_arguments&lt;2&gt;(node);
2891        const int divisor = args[1]-&gt;get&lt;int&gt;();
2892        result_ptr = std::make_shared&lt;json&gt;((divisor != 0) &amp;&amp; (args[0]-&gt;get&lt;int&gt;() % divisor == 0));
2893        json_tmp_stack.push_back(result_ptr);
2894        json_eval_stack.push(result_ptr.get());
2895      } break;
2896      case Op::Even: {
2897        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;int&gt;() % 2 == 0);
2898        json_tmp_stack.push_back(result_ptr);
2899        json_eval_stack.push(result_ptr.get());
2900      } break;
2901      case Op::Exists: {
2902        auto &amp;&amp;name = get_arguments&lt;1&gt;(node)[0]-&gt;get_ref&lt;const std::string &amp;&gt;();
2903        result_ptr = std::make_shared&lt;json&gt;(json_input-&gt;contains(json::json_pointer(JsonNode::convert_dot_to_json_ptr(name))));
2904        json_tmp_stack.push_back(result_ptr);
2905        json_eval_stack.push(result_ptr.get());
2906      } break;
2907      case Op::ExistsInObject: {
2908        const auto args = get_arguments&lt;2&gt;(node);
2909        auto &amp;&amp;name = args[1]-&gt;get_ref&lt;const std::string &amp;&gt;();
2910        result_ptr = std::make_shared&lt;json&gt;(args[0]-&gt;find(name) != args[0]-&gt;end());
2911        json_tmp_stack.push_back(result_ptr);
2912        json_eval_stack.push(result_ptr.get());
2913      } break;
2914      case Op::First: {
2915        const auto result = &amp;get_arguments&lt;1&gt;(node)[0]-&gt;front();
2916        json_eval_stack.push(result);
2917      } break;
2918      case Op::Float: {
2919        result_ptr = std::make_shared&lt;json&gt;(std::stod(get_arguments&lt;1&gt;(node)[0]-&gt;get_ref&lt;const std::string &amp;&gt;()));
2920        json_tmp_stack.push_back(result_ptr);
2921        json_eval_stack.push(result_ptr.get());
2922      } break;
2923      case Op::Int: {
2924        result_ptr = std::make_shared&lt;json&gt;(std::stoi(get_arguments&lt;1&gt;(node)[0]-&gt;get_ref&lt;const std::string &amp;&gt;()));
2925        json_tmp_stack.push_back(result_ptr);
2926        json_eval_stack.push(result_ptr.get());
2927      } break;
2928      case Op::Last: {
2929        const auto result = &amp;get_arguments&lt;1&gt;(node)[0]-&gt;back();
2930        json_eval_stack.push(result);
2931      } break;
2932      case Op::Length: {
2933        const auto val = get_arguments&lt;1&gt;(node)[0];
2934        if (val-&gt;is_string()) {
2935          result_ptr = std::make_shared&lt;json&gt;(val-&gt;get_ref&lt;const std::string &amp;&gt;().length());
2936        } else {
2937          result_ptr = std::make_shared&lt;json&gt;(val-&gt;size());
2938        }
2939        json_tmp_stack.push_back(result_ptr);
2940        json_eval_stack.push(result_ptr.get());
2941      } break;
2942      case Op::Lower: {
2943        std::string result = get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;std::string&gt;();
2944        std::transform(result.begin(), result.end(), result.begin(), ::tolower);
2945        result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2946        json_tmp_stack.push_back(result_ptr);
2947        json_eval_stack.push(result_ptr.get());
2948      } break;
2949      case Op::Max: {
2950        const auto args = get_arguments&lt;1&gt;(node);
2951        const auto result = std::max_element(args[0]-&gt;begin(), args[0]-&gt;end());
2952        json_eval_stack.push(&amp;(*result));
2953      } break;
2954      case Op::Min: {
2955        const auto args = get_arguments&lt;1&gt;(node);
2956        const auto result = std::min_element(args[0]-&gt;begin(), args[0]-&gt;end());
2957        json_eval_stack.push(&amp;(*result));
2958      } break;
2959      case Op::Odd: {
2960        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;int&gt;() % 2 != 0);
2961        json_tmp_stack.push_back(result_ptr);
2962        json_eval_stack.push(result_ptr.get());
2963      } break;
2964      case Op::Range: {
2965        std::vector&lt;int&gt; result(get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;int&gt;());
2966        std::iota(result.begin(), result.end(), 0);
2967        result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2968        json_tmp_stack.push_back(result_ptr);
2969        json_eval_stack.push(result_ptr.get());
2970      } break;
2971      case Op::Round: {
2972        const auto args = get_arguments&lt;2&gt;(node);
2973        const int precision = args[1]-&gt;get&lt;int&gt;();
2974        const double result = std::round(args[0]-&gt;get&lt;double&gt;() * std::pow(10.0, precision)) / std::pow(10.0, precision);
2975        if(0==precision){
2976          result_ptr = std::make_shared&lt;json&gt;(int(result));
2977        }else{
2978          result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2979        }
2980        json_tmp_stack.push_back(result_ptr);
2981        json_eval_stack.push(result_ptr.get());
2982      } break;
2983      case Op::Sort: {
2984        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;std::vector&lt;json&gt;&gt;());
2985        std::sort(result_ptr-&gt;begin(), result_ptr-&gt;end());
2986        json_tmp_stack.push_back(result_ptr);
2987        json_eval_stack.push(result_ptr.get());
2988      } break;
2989      case Op::Upper: {
2990        std::string result = get_arguments&lt;1&gt;(node)[0]-&gt;get&lt;std::string&gt;();
2991        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
2992        result_ptr = std::make_shared&lt;json&gt;(std::move(result));
2993        json_tmp_stack.push_back(result_ptr);
2994        json_eval_stack.push(result_ptr.get());
2995      } break;
2996      case Op::IsBoolean: {
2997        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_boolean());
2998        json_tmp_stack.push_back(result_ptr);
2999        json_eval_stack.push(result_ptr.get());
3000      } break;
3001      case Op::IsNumber: {
3002        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_number());
3003        json_tmp_stack.push_back(result_ptr);
3004        json_eval_stack.push(result_ptr.get());
3005      } break;
3006      case Op::IsInteger: {
3007        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_number_integer());
3008        json_tmp_stack.push_back(result_ptr);
3009        json_eval_stack.push(result_ptr.get());
3010      } break;
3011      case Op::IsFloat: {
3012        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_number_float());
3013        json_tmp_stack.push_back(result_ptr);
3014        json_eval_stack.push(result_ptr.get());
3015      } break;
3016      case Op::IsObject: {
3017        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_object());
3018        json_tmp_stack.push_back(result_ptr);
3019        json_eval_stack.push(result_ptr.get());
3020      } break;
3021      case Op::IsArray: {
3022        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_array());
3023        json_tmp_stack.push_back(result_ptr);
3024        json_eval_stack.push(result_ptr.get());
3025      } break;
3026      case Op::IsString: {
3027        result_ptr = std::make_shared&lt;json&gt;(get_arguments&lt;1&gt;(node)[0]-&gt;is_string());
3028        json_tmp_stack.push_back(result_ptr);
3029        json_eval_stack.push(result_ptr.get());
3030      } break;
3031      case Op::Callback: {
3032        auto args = get_argument_vector(node);
3033        result_ptr = std::make_shared&lt;json&gt;(node.callback(args));
3034        json_tmp_stack.push_back(result_ptr);
3035        json_eval_stack.push(result_ptr.get());
3036      } break;
3037      case Op::Super: {
3038        const auto args = get_argument_vector(node);
3039        const size_t old_level = current_level;
3040        const size_t level_diff = (args.size() == 1) ? args[0]-&gt;get&lt;int&gt;() : 1;
3041        const size_t level = current_level + level_diff;
3042        if (block_statement_stack.empty()) {
3043          throw_renderer_error(&quot;super() call is not within a block&quot;, node);
3044        }
3045        if (level &lt; 1 || level &gt; template_stack.size() - 1) {
3046          throw_renderer_error(&quot;level of super() call does not match parent templates (between 1 and &quot; + std::to_string(template_stack.size() - 1) + &quot;)&quot;, node);
3047        }
3048        const auto current_block_statement = block_statement_stack.back();
3049        const Template *new_template = template_stack.at(level);
3050        const Template *old_template = current_template;
3051        const auto block_it = new_template-&gt;block_storage.find(current_block_statement-&gt;name);
3052        if (block_it != new_template-&gt;block_storage.end()) {
3053          current_template = new_template;
3054          current_level = level;
3055          block_it-&gt;second-&gt;block.accept(*this);
3056          current_level = old_level;
3057          current_template = old_template;
3058        } else {
3059          throw_renderer_error(&quot;could not find block with name &#x27;&quot; + current_block_statement-&gt;name + &quot;&#x27;&quot;, node);
3060        }
3061        result_ptr = std::make_shared&lt;json&gt;(nullptr);
3062        json_tmp_stack.push_back(result_ptr);
3063        json_eval_stack.push(result_ptr.get());
3064      } break;
3065      case Op::Join: {
3066        const auto args = get_arguments&lt;2&gt;(node);
3067        const auto separator = args[1]-&gt;get&lt;std::string&gt;();
3068        std::ostringstream os;
3069        std::string sep;
3070        for (const auto&amp; value : *args[0]) {
3071          os &lt;&lt; sep;
3072          if (value.is_string()) {
3073            os &lt;&lt; value.get&lt;std::string&gt;(); 
3074          } else {
3075            os &lt;&lt; value;
3076          }
3077          sep = separator;
3078        }
3079        result_ptr = std::make_shared&lt;json&gt;(os.str());
3080        json_tmp_stack.push_back(result_ptr);
3081        json_eval_stack.push(result_ptr.get());
3082      } break;
3083      case Op::ParenLeft:
3084      case Op::ParenRight:
3085      case Op::None:
3086        break;
3087      }
3088    }
3089    void visit(const ExpressionListNode&amp; node) {
3090      print_json(eval_expression_list(node));
3091    }
3092    void visit(const StatementNode&amp;) { }
3093    void visit(const ForStatementNode&amp;) { }
3094    void visit(const ForArrayStatementNode&amp; node) {
3095      const auto result = eval_expression_list(node.condition);
3096      if (!result-&gt;is_array()) {
3097        throw_renderer_error(&quot;object must be an array&quot;, node);
3098      }
3099      if (!current_loop_data-&gt;empty()) {
3100        auto tmp = *current_loop_data; 
3101        (*current_loop_data)[&quot;parent&quot;] = std::move(tmp);
3102      }
3103      size_t index = 0;
3104      (*current_loop_data)[&quot;is_first&quot;] = true;
3105      (*current_loop_data)[&quot;is_last&quot;] = (result-&gt;size() &lt;= 1);
3106      for (auto it = result-&gt;begin(); it != result-&gt;end(); ++it) {
3107        json_additional_data[static_cast&lt;std::string&gt;(node.value)] = *it;
3108        (*current_loop_data)[&quot;index&quot;] = index;
3109        (*current_loop_data)[&quot;index1&quot;] = index + 1;
3110        if (index == 1) {
3111          (*current_loop_data)[&quot;is_first&quot;] = false;
3112        }
3113        if (index == result-&gt;size() - 1) {
3114          (*current_loop_data)[&quot;is_last&quot;] = true;
3115        }
3116        node.body.accept(*this);
3117        ++index;
3118      }
3119      json_additional_data[static_cast&lt;std::string&gt;(node.value)].clear();
3120      if (!(*current_loop_data)[&quot;parent&quot;].empty()) {
3121        const auto tmp = (*current_loop_data)[&quot;parent&quot;];
3122        *current_loop_data = std::move(tmp);
3123      } else {
3124        current_loop_data = &amp;json_additional_data[&quot;loop&quot;];
3125      }
3126    }
3127    void visit(const ForObjectStatementNode&amp; node) {
3128      const auto result = eval_expression_list(node.condition);
3129      if (!result-&gt;is_object()) {
3130        throw_renderer_error(&quot;object must be an object&quot;, node);
3131      }
3132      if (!current_loop_data-&gt;empty()) {
3133        (*current_loop_data)[&quot;parent&quot;] = std::move(*current_loop_data);
3134      }
3135      size_t index = 0;
3136      (*current_loop_data)[&quot;is_first&quot;] = true;
3137      (*current_loop_data)[&quot;is_last&quot;] = (result-&gt;size() &lt;= 1);
3138      for (auto it = result-&gt;begin(); it != result-&gt;end(); ++it) {
3139        json_additional_data[static_cast&lt;std::string&gt;(node.key)] = it.key();
3140        json_additional_data[static_cast&lt;std::string&gt;(node.value)] = it.value();
3141        (*current_loop_data)[&quot;index&quot;] = index;
3142        (*current_loop_data)[&quot;index1&quot;] = index + 1;
3143        if (index == 1) {
3144          (*current_loop_data)[&quot;is_first&quot;] = false;
3145        }
3146        if (index == result-&gt;size() - 1) {
3147          (*current_loop_data)[&quot;is_last&quot;] = true;
3148        }
3149        node.body.accept(*this);
3150        ++index;
3151      }
3152      json_additional_data[static_cast&lt;std::string&gt;(node.key)].clear();
3153      json_additional_data[static_cast&lt;std::string&gt;(node.value)].clear();
3154      if (!(*current_loop_data)[&quot;parent&quot;].empty()) {
3155        *current_loop_data = std::move((*current_loop_data)[&quot;parent&quot;]);
3156      } else {
3157        current_loop_data = &amp;json_additional_data[&quot;loop&quot;];
3158      }
3159    }
3160    void visit(const IfStatementNode&amp; node) {
3161      const auto result = eval_expression_list(node.condition);
3162      if (truthy(result.get())) {
3163        node.true_statement.accept(*this);
3164      } else if (node.has_false_statement) {
3165        node.false_statement.accept(*this);
3166      }
3167    }
3168    void visit(const IncludeStatementNode&amp; node) {
3169      auto sub_renderer = Renderer(config, template_storage, function_storage);
3170      const auto included_template_it = template_storage.find(node.file);
3171      if (included_template_it != template_storage.end()) {
3172        sub_renderer.render_to(*output_stream, included_template_it-&gt;second, *json_input, &amp;json_additional_data);
3173      } else if (config.throw_at_missing_includes) {
3174        throw_renderer_error(&quot;include &#x27;&quot; + node.file + &quot;&#x27; not found&quot;, node);
3175      }
3176    }
3177    void visit(const ExtendsStatementNode&amp; node) {
3178      const auto included_template_it = template_storage.find(node.file);
3179      if (included_template_it != template_storage.end()) {
3180        const Template *parent_template = &amp;included_template_it-&gt;second;
3181        render_to(*output_stream, *parent_template, *json_input, &amp;json_additional_data);
3182        break_rendering = true;
3183      } else if (config.throw_at_missing_includes) {
3184        throw_renderer_error(&quot;extends &#x27;&quot; + node.file + &quot;&#x27; not found&quot;, node);
3185      }
3186    }
3187    void visit(const BlockStatementNode&amp; node) {
3188      const size_t old_level = current_level;
3189      current_level = 0;
3190      current_template = template_stack.front();
3191      const auto block_it = current_template-&gt;block_storage.find(node.name);
3192      if (block_it != current_template-&gt;block_storage.end()) {
3193        block_statement_stack.emplace_back(&amp;node);
3194        block_it-&gt;second-&gt;block.accept(*this);
3195        block_statement_stack.pop_back(); 
3196      }
3197      current_level = old_level;
3198      current_template = template_stack.back();
3199    }
3200    void visit(const SetStatementNode&amp; node) {
3201      std::string ptr = node.key;
3202      replace_substring(ptr, &quot;.&quot;, &quot;/&quot;);
3203      ptr = &quot;/&quot; + ptr;
3204      json_additional_data[json::json_pointer(ptr)] = *eval_expression_list(node.expression);
3205    }
3206  public:
3207    Renderer(const RenderConfig&amp; config, const TemplateStorage &amp;template_storage, const FunctionStorage &amp;function_storage)
3208        : config(config), template_storage(template_storage), function_storage(function_storage) { }
3209    void render_to(std::ostream &amp;os, const Template &amp;tmpl, const json &amp;data, json *loop_data = nullptr) {
3210      output_stream = &amp;os;
3211      current_template = &amp;tmpl;
3212      json_input = &amp;data;
3213      if (loop_data) {
3214        json_additional_data = *loop_data;
3215        current_loop_data = &amp;json_additional_data[&quot;loop&quot;];
3216      }
3217      template_stack.emplace_back(current_template);
3218      current_template-&gt;root.accept(*this);
3219      json_tmp_stack.clear();
3220    }
3221  };
3222  } 
3223  #endif 
3224  namespace inja {
3225  class Environment {
3226    std::string input_path;
3227    std::string output_path;
3228    LexerConfig lexer_config;
3229    ParserConfig parser_config;
3230    RenderConfig render_config;
3231    FunctionStorage function_storage;
3232    TemplateStorage template_storage;
3233  public:
3234    Environment() : Environment(&quot;&quot;) {}
3235    explicit Environment(const std::string &amp;global_path) : input_path(global_path), output_path(global_path) {}
3236    Environment(const std::string &amp;input_path, const std::string &amp;output_path)
3237        : input_path(input_path), output_path(output_path) {}
3238    void set_statement(const std::string &amp;open, const std::string &amp;close) {
3239      lexer_config.statement_open = open;
3240      lexer_config.statement_open_no_lstrip = open + &quot;+&quot;;
3241      lexer_config.statement_open_force_lstrip = open + &quot;-&quot;;
3242      lexer_config.statement_close = close;
3243      lexer_config.statement_close_force_rstrip = &quot;-&quot; + close;
3244      lexer_config.update_open_chars();
3245    }
3246    void set_line_statement(const std::string &amp;open) {
3247      lexer_config.line_statement = open;
3248      lexer_config.update_open_chars();
3249    }
3250    void set_expression(const std::string &amp;open, const std::string &amp;close) {
3251      lexer_config.expression_open = open;
3252      lexer_config.expression_open_force_lstrip = open + &quot;-&quot;;
3253      lexer_config.expression_close = close;
3254      lexer_config.expression_close_force_rstrip = &quot;-&quot; + close;
3255      lexer_config.update_open_chars();
3256    }
3257    void set_comment(const std::string &amp;open, const std::string &amp;close) {
3258      lexer_config.comment_open = open;
3259      lexer_config.comment_open_force_lstrip = open + &quot;-&quot;;
3260      lexer_config.comment_close = close;
3261      lexer_config.comment_close_force_rstrip = &quot;-&quot; + close;
3262      lexer_config.update_open_chars();
3263    }
3264    void set_trim_blocks(bool trim_blocks) {
3265      lexer_config.trim_blocks = trim_blocks;
3266    }
3267    void set_lstrip_blocks(bool lstrip_blocks) {
3268      lexer_config.lstrip_blocks = lstrip_blocks;
3269    }
3270    void set_search_included_templates_in_files(bool search_in_files) {
3271      parser_config.search_included_templates_in_files = search_in_files;
3272    }
3273    void set_throw_at_missing_includes(bool will_throw) {
3274      render_config.throw_at_missing_includes = will_throw;
3275    }
3276    Template parse(nonstd::string_view input) {
3277      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3278      return parser.parse(input);
3279    }
3280    Template parse_template(const std::string &amp;filename) {
3281      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3282      auto result = Template(parser.load_file(input_path + static_cast&lt;std::string&gt;(filename)));
3283      parser.parse_into_template(result, input_path + static_cast&lt;std::string&gt;(filename));
3284      return result;
3285    }
3286    Template parse_file(const std::string &amp;filename) {
3287      return parse_template(filename);
3288    }
3289    std::string render(nonstd::string_view input, const json &amp;data) { return render(parse(input), data); }
3290    std::string render(const Template &amp;tmpl, const json &amp;data) {
3291      std::stringstream os;
3292      render_to(os, tmpl, data);
3293      return os.str();
3294    }
3295    std::string render_file(const std::string &amp;filename, const json &amp;data) {
3296      return render(parse_template(filename), data);
3297    }
3298    std::string render_file_with_json_file(const std::string &amp;filename, const std::string &amp;filename_data) {
3299      const json data = load_json(filename_data);
3300      return render_file(filename, data);
3301    }
3302    void write(const std::string &amp;filename, const json &amp;data, const std::string &amp;filename_out) {
3303      std::ofstream file(output_path + filename_out);
3304      file &lt;&lt; render_file(filename, data);
3305      file.close();
3306    }
3307    void write(const Template &amp;temp, const json &amp;data, const std::string &amp;filename_out) {
3308      std::ofstream file(output_path + filename_out);
<span onclick='openModal()' class='match'>3309      file &lt;&lt; render(temp, data);
3310      file.close();
3311    }
3312    void write_with_json_file(const std::string &amp;filename, const std::string &amp;filename_data,
</span>3313                              const std::string &amp;filename_out) {
3314      const json data = load_json(filename_data);
3315      write(filename, data, filename_out);
3316    }
3317    void write_with_json_file(const Template &amp;temp, const std::string &amp;filename_data, const std::string &amp;filename_out) {
3318      const json data = load_json(filename_data);
3319      write(temp, data, filename_out);
3320    }
3321    std::ostream &amp;render_to(std::ostream &amp;os, const Template &amp;tmpl, const json &amp;data) {
3322      Renderer(render_config, template_storage, function_storage).render_to(os, tmpl, data);
3323      return os;
3324    }
3325    std::string load_file(const std::string &amp;filename) {
3326      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3327      return parser.load_file(input_path + filename);
3328    }
3329    json load_json(const std::string &amp;filename) {
3330      std::ifstream file;
3331      file.open(input_path + filename);
3332      if (file.fail()) {
3333        INJA_THROW(FileError(&quot;failed accessing file at &#x27;&quot; + input_path + filename + &quot;&#x27;&quot;));
3334      }
3335      json j;
3336      file &gt;&gt; j;
3337      return j;
3338    }
3339    void add_callback(const std::string &amp;name, const CallbackFunction &amp;callback) {
3340      add_callback(name, -1, callback);
3341    }
3342    void add_void_callback(const std::string &amp;name, const VoidCallbackFunction &amp;callback) {
3343      add_void_callback(name, -1, callback);
3344    }
3345    void add_callback(const std::string &amp;name, int num_args, const CallbackFunction &amp;callback) {
3346      function_storage.add_callback(name, num_args, callback);
3347    }
3348    void add_void_callback(const std::string &amp;name, int num_args, const VoidCallbackFunction &amp;callback) {
3349      function_storage.add_callback(name, num_args, [callback](Arguments&amp; args) { callback(args); return json(); });
3350    }
3351    void include_template(const std::string &amp;name, const Template &amp;tmpl) {
3352      template_storage[name] = tmpl;
3353    }
3354    void set_include_callback(const std::function&lt;Template(const std::string&amp;, const std::string&amp;)&gt;&amp; callback) {
3355      parser_config.include_callback = callback;
3356    }
3357  };
3358  inline std::string render(nonstd::string_view input, const json &amp;data) {
3359    return Environment().render(input, data);
3360  }
3361  inline void render_to(std::ostream &amp;os, nonstd::string_view input, const json &amp;data) {
3362    Environment env;
3363    env.render_to(os, env.parse(input), data);
3364  }
3365  } 
3366  #endif 
3367  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-inja.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-inja.hpp</div>
                </div>
                <div class="column column_space"><pre><code>3304      file &lt;&lt; render_file(filename, data);
3305      file.close();
3306    }
3307    void write(const Template &amp;temp, const json &amp;data, const std::string &amp;filename_out) {
</pre></code></div>
                <div class="column column_space"><pre><code>3309      file &lt;&lt; render(temp, data);
3310      file.close();
3311    }
3312    void write_with_json_file(const std::string &amp;filename, const std::string &amp;filename_data,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    