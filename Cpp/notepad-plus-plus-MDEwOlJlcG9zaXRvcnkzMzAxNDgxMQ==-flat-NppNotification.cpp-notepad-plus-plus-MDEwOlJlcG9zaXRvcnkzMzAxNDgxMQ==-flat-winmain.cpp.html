
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 45, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppNotification.cpp</h3>
            <pre><code>1  #include "Notepad_plus_Window.h"
2  #include "functionListPanel.h"
3  #include "xmlMatchedTagsHighlighter.h"
4  #include "VerticalFileSwitcher.h"
5  #include "ProjectPanel.h"
6  #include "documentMap.h"
7  #include "Common.h"
8  #include <stack>
9  using namespace std;
10  BOOL Notepad_plus::notify(SCNotification *notification)
11  {
12  	bool isFromPrimary = (_mainEditView.getHSelf() == notification->nmhdr.hwndFrom || _mainDocTab.getHSelf() == notification->nmhdr.hwndFrom);
13  	bool isFromSecondary = !isFromPrimary && (_subEditView.getHSelf() == notification->nmhdr.hwndFrom || _subDocTab.getHSelf() == notification->nmhdr.hwndFrom);
14  	ScintillaEditView * notifyView = nullptr;
15  	if (isFromPrimary)
16  		notifyView = &_mainEditView;
17  	else if (isFromSecondary)
18  		notifyView = &_subEditView;
19  	DocTabView *notifyDocTab = isFromPrimary?&_mainDocTab:&_subDocTab;
20  	TBHDR * tabNotification = (TBHDR*) notification;
21  	switch (notification->nmhdr.code)
22  	{
23  		case SCN_MODIFIED:
24  		{
25  			if (!notifyView)
26  				return FALSE;
27  			if (notification->modificationType & (SC_MOD_DELETETEXT | SC_MOD_INSERTTEXT))
28  			{
29  				_pEditView->updateBeginEndSelectPosition(notification->modificationType & SC_MOD_INSERTTEXT, notification->position, notification->length);
30  				_linkTriggered = true;
31  				::InvalidateRect(notifyView->getHSelf(), NULL, TRUE);
32  			}
33  			if (notification->modificationType & (SC_MOD_DELETETEXT | SC_MOD_INSERTTEXT | SC_PERFORMED_UNDO | SC_PERFORMED_REDO))
34  			{
35  				_pEditView->getCurrentBuffer()->setModifiedStatus(true);
36  			}
37  			if (notification->modificationType & SC_MOD_CHANGEINDICATOR)
38  			{
39  				::InvalidateRect(notifyView->getHSelf(), NULL, FALSE);
40  			}
41  			break;
42  		}
43  		case SCN_SAVEPOINTREACHED:
44  		case SCN_SAVEPOINTLEFT:
45  		{
46  			Buffer * buf = 0;
47  			if (isFromPrimary)
48  			{
49  				buf = _mainEditView.getCurrentBuffer();
50  			}
51  			else if (isFromSecondary)
52  			{
53  				buf = _subEditView.getCurrentBuffer();
54  			}
55  			else
56  			{
57  				BufferID id = BUFFER_INVALID;
58  				if (notification->nmhdr.hwndFrom == _invisibleEditView.getHSelf())
59  				{
60  					id = MainFileManager.getBufferFromDocument(_invisibleEditView.execute(SCI_GETDOCPOINTER));
61  				}
62  				else if (notification->nmhdr.hwndFrom == _fileEditView.getHSelf())
63  				{
64  					id = MainFileManager.getBufferFromDocument(_fileEditView.execute(SCI_GETDOCPOINTER));
65  				}
66  				else
67  					break;	
68  				if (id != BUFFER_INVALID)
69  				{
70  					buf = MainFileManager.getBufferByID(id);
71  				}
72  				else
73  					break;
74  			}
75  			bool isDirty = notification->nmhdr.code == SCN_SAVEPOINTLEFT;
76  			bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
77  			if (isSnapshotMode && !isDirty)
78  			{
79  				bool canUndo = _pEditView->execute(SCI_CANUNDO) == TRUE;
80  				if (!canUndo && buf->isLoadedDirty() && buf->isDirty())
81  					isDirty = true;
82  			}
83  			if (buf->isUnsync()) 
84  				isDirty = true;
85  			if (buf->isSavePointDirty())
86  				isDirty = true;
87  			buf->setDirty(isDirty);
88  			break;
89  		}
90  		case SCN_MODIFYATTEMPTRO:
91  		{
92  			break;
93  		}
94  		case SCN_KEY:
95  		{
96  			break;
97  		}
98  		case TCN_MOUSEHOVERING:
99  		case TCN_MOUSEHOVERSWITCHING:
100  		{
101  			NppParameters& nppParam = NppParameters::getInstance();
102  			bool doPeekOnTab = nppParam.getNppGUI()._isDocPeekOnTab;
103  			bool doPeekOnMap = nppParam.getNppGUI()._isDocPeekOnMap;
104  			if (doPeekOnTab)
105  			{
106  				TBHDR *tbHdr = reinterpret_cast<TBHDR *>(notification);
107  				DocTabView *pTabDocView = isFromPrimary ? &_mainDocTab : (isFromSecondary ? &_subDocTab : nullptr);
108  				if (pTabDocView)
109  				{
110  					BufferID id = pTabDocView->getBufferByIndex(tbHdr->_tabOrigin);
111  					Buffer *pBuf = MainFileManager.getBufferByID(id);
112  					Buffer *currentBufMain = _mainEditView.getCurrentBuffer();
113  					Buffer *currentBufSub = _subEditView.getCurrentBuffer();
114  					RECT rect{};
115  					TabCtrl_GetItemRect(pTabDocView->getHSelf(), tbHdr->_tabOrigin, &rect);
116  					POINT p{};
117  					p.x = rect.left;
118  					p.y = rect.bottom;
119  					::ClientToScreen(pTabDocView->getHSelf(), &p);
120  					if (pBuf != currentBufMain && pBuf != currentBufSub) 
121  					{
122  						_documentPeeker.doDialog(p, pBuf, *(const_cast<ScintillaEditView*>(pTabDocView->getScintillaEditView())));
123  					}
124  					else  
125  					{
126  						_documentPeeker.display(false);
127  					}
128  				}
129  			}
130  			if (doPeekOnMap && _pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible())
131  			{
132  				TBHDR *tbHdr = reinterpret_cast<TBHDR *>(notification);
133  				DocTabView *pTabDocView = isFromPrimary ? &_mainDocTab : (isFromSecondary ? &_subDocTab : nullptr);
134  				if (pTabDocView)
135  				{
136  					BufferID id = pTabDocView->getBufferByIndex(tbHdr->_tabOrigin);
137  					Buffer *pBuf = MainFileManager.getBufferByID(id);
138  					Buffer *currentBufMain = _mainEditView.getCurrentBuffer();
139  					Buffer *currentBufSub = _subEditView.getCurrentBuffer();
140  					if (pBuf != currentBufMain && pBuf != currentBufSub) 
141  					{
142  						_pDocMap->showInMapTemporarily(pBuf, notifyView);
143  						_pDocMap->setSyntaxHiliting();
144  					}
145  					else  
146  					{
147  						_pDocMap->reloadMap();
148  						_pDocMap->setSyntaxHiliting();
149  					}
150  					_pDocMap->setTemporarilyShowing(true);
151  				}
152  			}
153  			break;
154  		}
155  		case TCN_MOUSELEAVING:
156  		{
157  			NppParameters& nppParam = NppParameters::getInstance();
158  			bool doPeekOnTab = nppParam.getNppGUI()._isDocPeekOnTab;
159  			bool doPeekOnMap = nppParam.getNppGUI()._isDocPeekOnMap;
160  			if (doPeekOnTab)
161  			{
162  				_documentPeeker.display(false);
163  			}
164  			if (doPeekOnMap && _pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible())
165  			{
166  				_pDocMap->reloadMap();
167  				_pDocMap->setSyntaxHiliting();
168  				_pDocMap->setTemporarilyShowing(false);
169  			}
170  			break;
171  		}
172  		case TCN_TABDROPPEDOUTSIDE:
173  		case TCN_TABDROPPED:
174  		{
175  			TabBarPlus *sender = reinterpret_cast<TabBarPlus *>(notification->nmhdr.idFrom);
176  			bool isInCtrlStat = (::GetKeyState(VK_LCONTROL) & 0x80000000) != 0;
177  			if (notification->nmhdr.code == TCN_TABDROPPEDOUTSIDE)
178  			{
179  				POINT p = sender->getDraggingPoint();
180  				HWND hWin = ::WindowFromPoint(p);
181  				if (hWin == _pEditView->getHSelf()) 
182  				{
183  					if (!_tabPopupDropMenu.isCreated())
184  					{
185  						TCHAR goToView[32] = TEXT("Move to Other View");
186  						TCHAR cloneToView[32] = TEXT("Clone to Other View");
187  						vector<MenuItemUnit> itemUnitArray;
188  						itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_ANOTHER_VIEW, goToView));
189  						itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_CLONE_TO_ANOTHER_VIEW, cloneToView));
190  						_tabPopupDropMenu.create(_pPublicInterface->getHSelf(), itemUnitArray, _mainMenuHandle);
191  						_nativeLangSpeaker.changeLangTabDropContextMenu(_tabPopupDropMenu.getMenuHandle());
192  					}
193  					_tabPopupDropMenu.display(p);
194  				}
195  				else if ((hWin == _pNonDocTab->getHSelf()) ||
196  						 (hWin == _pNonEditView->getHSelf())) 
197  				{
198  					docGotoAnotherEditView(isInCtrlStat?TransferClone:TransferMove);
199  				}
200  				else
201  				{
202  					RECT nppZone{};
203  					::GetWindowRect(_pPublicInterface->getHSelf(), &nppZone);
204  					bool isInNppZone = (((p.x >= nppZone.left) && (p.x <= nppZone.right)) && (p.y >= nppZone.top) && (p.y <= nppZone.bottom));
205  					if (isInNppZone)
206  					{
207  						return TRUE;
208  					}
209  					generic_string quotFileName = TEXT("\"");
210  					quotFileName += _pEditView->getCurrentBuffer()->getFullPathName();
211  					quotFileName += TEXT("\"");
212  					COPYDATASTRUCT fileNamesData{};
<span onclick='openModal()' class='match'>213  					fileNamesData.dwData = COPYDATA_FILENAMESW;
214  					fileNamesData.lpData = (void *)quotFileName.c_str();
215  					fileNamesData.cbData = static_cast<DWORD>((quotFileName.length() + 1) * sizeof(TCHAR));
216  					HWND hWinParent = ::GetParent(hWin);
</span>217  					const rsize_t classNameBufferSize = MAX_PATH;
218  					TCHAR className[classNameBufferSize];
219  					::GetClassName(hWinParent,className, classNameBufferSize);
220  					if (lstrcmp(className, _pPublicInterface->getClassName()) == 0 && hWinParent != _pPublicInterface->getHSelf()) 
221  					{
222  						int index = _pDocTab->getCurrentTabIndex();
223  						BufferID bufferToClose = notifyDocTab->getBufferByIndex(index);
224  						Buffer * buf = MainFileManager.getBufferByID(bufferToClose);
225  						int iView = isFromPrimary?MAIN_VIEW:SUB_VIEW;
226  						if (buf->isDirty())
227  						{
228  							generic_string msg, title;
229  							_nativeLangSpeaker.messageBox("CannotMoveDoc",
230  								_pPublicInterface->getHSelf(),
231  								TEXT("Document is modified, save it then try again."),
232  								TEXT("Move to new Notepad++ Instance"),
233  								MB_OK);
234  						}
235  						else
236  						{
237  							::SendMessage(hWinParent, NPPM_INTERNAL_SWITCHVIEWFROMHWND, 0, reinterpret_cast<LPARAM>(hWin));
238  							::SendMessage(hWinParent, WM_COPYDATA, reinterpret_cast<WPARAM>(_pPublicInterface->getHinst()), reinterpret_cast<LPARAM>(&fileNamesData));
239  							if (!isInCtrlStat)
240  							{
241  								fileClose(bufferToClose, iView);
242  								if (noOpenedDoc())
243  									::SendMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0, 0);
244  							}
245  						}
246  					}
247  					else 
248  					{
249  						docOpenInNewInstance(isInCtrlStat?TransferClone:TransferMove, p.x, p.y);
250  					}
251  				}
252  			}
253  			sender->resetDraggingPoint();
254  			return TRUE;
255  		}
256  		case TCN_TABDELETE:
257  		{
258  			int index = tabNotification->_tabOrigin;
259  			BufferID bufferToClose = notifyDocTab->getBufferByIndex(index);
260  			Buffer * buf = MainFileManager.getBufferByID(bufferToClose);
261  			int iView = isFromPrimary?MAIN_VIEW:SUB_VIEW;
262  			if (buf->isDirty())
263  			{
264  				activateBuffer(bufferToClose, iView);
265  			}
266  			if (fileClose(bufferToClose, iView))
267  				checkDocState();
268  			break;
269  		}
270  		case TCN_SELCHANGE:
271  		{
272  			int iView = -1;
273  			if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf())
274  			{
275  				iView = MAIN_VIEW;
276  			}
277  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf())
278  			{
279  				iView = SUB_VIEW;
280  			}
281  			else
282  				break;
283  			_documentPeeker.saveCurrentSnapshot(*_pEditView);
284  			switchEditViewTo(iView);
285  			BufferID bufid = _pDocTab->getBufferByIndex(_pDocTab->getCurrentTabIndex());
286  			if (bufid != BUFFER_INVALID)
287  			{
288  				_isFolding = true; 
289  				activateBuffer(bufid, iView);
290  				_isFolding = false;
291  			}
292  			_documentPeeker.display(false);
293  			break;
294  		}
295  		case NM_CLICK :
296  		{
297  			if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())
298  			{
299  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
300  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_TYPING_MODE))
301  				{
302  					bool isOverTypeMode = (_pEditView->execute(SCI_GETOVERTYPE) != 0);
303  					_pEditView->execute(SCI_SETOVERTYPE, !isOverTypeMode);
304  					_statusBar.setText((_pEditView->execute(SCI_GETOVERTYPE))?TEXT("OVR"):TEXT("INS"), STATUSBAR_TYPING_MODE);
305  				}
306  			}
307  			else if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf() && _activeView == SUB_VIEW)
308  			{
309  				bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
310  				if (isSnapshotMode)
311  				{
312  					MainFileManager.backupCurrentBuffer();
313  				}
314  				switchEditViewTo(MAIN_VIEW);
315  			}
316  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf() && _activeView == MAIN_VIEW)
317  			{
318  				bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
319  				if (isSnapshotMode)
320  				{
321  					MainFileManager.backupCurrentBuffer();
322  				}
323  				switchEditViewTo(SUB_VIEW);
324  			}
325  			break;
326  		}
327  		case NM_DBLCLK :
328  		{
329  			if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())
330  			{
331  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
332  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_CUR_POS))
333  				{
334  					bool isFirstTime = !_goToLineDlg.isCreated();
335  					_goToLineDlg.doDialog(_nativeLangSpeaker.isRTL());
336  					if (isFirstTime)
337  						_nativeLangSpeaker.changeDlgLang(_goToLineDlg.getHSelf(), "GoToLine");
338  				}
339  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_SIZE))
340  				{
341  					command(IDM_VIEW_SUMMARY);
342  				}
343  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_TYPE))
344  				{
345  					POINT p;
346  					::GetCursorPos(&p);
347  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
348  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
349  				}
350  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_EOF_FORMAT))
351  				{
352  					POINT p;
353  					::GetCursorPos(&p);
354  					MenuPosition & menuPos = getMenuPosition("edit-eolConversion");
355  					HMENU hEditMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
356  					if (!hEditMenu)
357  						return TRUE;
358  					HMENU hEolFormatMenu = ::GetSubMenu(hEditMenu, menuPos._y);
359  					if (!hEolFormatMenu)
360  						return TRUE;
361  					TrackPopupMenu(hEolFormatMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
362  				}
363  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_UNICODE_TYPE))
364  				{
365  					POINT p;
366  					::GetCursorPos(&p);
367  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
368  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
369  				}
370  			}
371  			break;
372  		}
373  		case NM_RCLICK :
374  		{
375  			POINT p;
376  			::GetCursorPos(&p);
377  			if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf())
378  			{
379  				switchEditViewTo(MAIN_VIEW);
380  			}
381  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf())
382  			{
383  				switchEditViewTo(SUB_VIEW);
384  			}
385  			else if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())  
386  			{
387  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
388  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_TYPE))
389  				{
390  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
391  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
392  				}
393  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_EOF_FORMAT))
394  				{
395  					MenuPosition & menuPos = getMenuPosition("edit-eolConversion");
396  					HMENU hEditMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
397  					if (!hEditMenu)
398  						return TRUE;
399  					HMENU hEolFormatMenu = ::GetSubMenu(hEditMenu, menuPos._y);
400  					if (!hEolFormatMenu)
401  						return TRUE;
402  					TrackPopupMenu(hEolFormatMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
403  				}
404  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_UNICODE_TYPE))
405  				{
406  					POINT p;
407  					::GetCursorPos(&p);
408  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
409  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
410  				}
411  				return TRUE;
412  			}
413  			else if (_pDocumentListPanel && notification->nmhdr.hwndFrom == _pDocumentListPanel->getHSelf())
414  			{
415  				if (_pDocumentListPanel->nbSelectedFiles() > 1)
416  				{
417  					if (!_fileSwitcherMultiFilePopupMenu.isCreated())
418  					{
419  						vector<MenuItemUnit> itemUnitArray;
420  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_FILESCLOSE, TEXT("Close Selected files")));
421  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_FILESCLOSEOTHERS, TEXT("Close Other files")));
422  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_COPYNAMES, TEXT("Copy Selected Names")));
423  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_COPYPATHS, TEXT("Copy Selected Pathnames")));
424  						for (auto&& x : itemUnitArray)
425  						{
426  							const generic_string menuItem = _nativeLangSpeaker.getNativeLangMenuString(x._cmdID);
427  							if (!menuItem.empty())
428  								x._itemName = menuItem;
429  						}
430  						_fileSwitcherMultiFilePopupMenu.create(_pPublicInterface->getHSelf(), itemUnitArray);
431  					}
432  					_fileSwitcherMultiFilePopupMenu.display(p);
433  					return TRUE;
434  				}
435  			}
436  			else 
437  				return TRUE;
438  			if (!_tabPopupMenu.isCreated())
439  			{
440  				std::vector<MenuItemUnit> itemUnitArray;
441  				NppParameters& nppParam = NppParameters::getInstance();
442  				if (nppParam.hasCustomTabContextMenu())
443  				{
444  					itemUnitArray = nppParam.getTabContextMenuItems();
445  				}
446  				else 
447  				{
448  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSE, TEXT("Close")));
449  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_BUT_CURRENT, TEXT("Close All BUT This"), TEXT("Close Multiple Tabs")));
450  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_TOLEFT, TEXT("Close All to the Left"), TEXT("Close Multiple Tabs")));
451  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_TORIGHT, TEXT("Close All to the Right"), TEXT("Close Multiple Tabs")));
452  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_UNCHANGED, TEXT("Close All Unchanged"), TEXT("Close Multiple Tabs")));
453  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_SAVE, TEXT("Save")));
454  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_SAVEAS, TEXT("Save As...")));
455  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_FOLDER, TEXT("Open Containing Folder in Explorer"), TEXT("Open into")));
456  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_CMD, TEXT("Open Containing Folder in cmd"), TEXT("Open into")));
457  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CONTAININGFOLDERASWORKSPACE, TEXT("Open Containing Folder as Workspace"), TEXT("Open into")));
458  					itemUnitArray.push_back(MenuItemUnit(0, NULL, TEXT("Open into")));
459  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_DEFAULT_VIEWER, TEXT("Open in Default Viewer"), TEXT("Open into")));
460  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_RENAME, TEXT("Rename")));
461  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_DELETE, TEXT("Move to Recycle Bin")));
462  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_RELOAD, TEXT("Reload")));
463  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_PRINT, TEXT("Print")));
464  					itemUnitArray.push_back(MenuItemUnit(0, NULL));
465  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_SETREADONLY, TEXT("Read-Only")));
466  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_CLEARREADONLY, TEXT("Clear Read-Only Flag")));
467  					itemUnitArray.push_back(MenuItemUnit(0, NULL));
468  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_FULLPATHTOCLIP, TEXT("Copy Full File Path"), TEXT("Copy to Clipboard")));
469  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_FILENAMETOCLIP, TEXT("Copy Filename"), TEXT("Copy to Clipboard")));
470  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_CURRENTDIRTOCLIP, TEXT("Copy Current Dir. Path"), TEXT("Copy to Clipboard")));
471  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_ANOTHER_VIEW, TEXT("Move to Other View"), TEXT("Move Document")));
472  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_CLONE_TO_ANOTHER_VIEW, TEXT("Clone to Other View"), TEXT("Move Document")));
473  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_NEW_INSTANCE, TEXT("Move to New Instance"), TEXT("Move Document")));
474  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_LOAD_IN_NEW_INSTANCE, TEXT("Open in New Instance"), TEXT("Move Document")));
475  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_1, TEXT("Apply Color 1"), TEXT("Apply Color to Tab")));
476  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_2, TEXT("Apply Color 2"), TEXT("Apply Color to Tab")));
477  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_3, TEXT("Apply Color 3"), TEXT("Apply Color to Tab")));
478  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_4, TEXT("Apply Color 4"), TEXT("Apply Color to Tab")));
479  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_5, TEXT("Apply Color 5"), TEXT("Apply Color to Tab")));
480  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_NONE, TEXT("Remove Color"), TEXT("Apply Color to Tab")));
481  				}
482  				_tabPopupMenu.create(_pPublicInterface->getHSelf(), itemUnitArray, _mainMenuHandle);
483  				_nativeLangSpeaker.changeLangTabContextMenu(_tabPopupMenu.getMenuHandle());
484  			}
485  			for (int i = 0; i < 5; ++i)
486  			{
487  				COLORREF colour = NppDarkMode::getIndividualTabColour(i, NppDarkMode::isDarkMenuEnabled(), true);
488  				HBITMAP hBitmap = generateSolidColourMenuItemIcon(colour);
489  				SetMenuItemBitmaps(_tabPopupMenu.getMenuHandle(), IDM_VIEW_TAB_COLOUR_1 + i, MF_BYCOMMAND, hBitmap, hBitmap);
490  			}
491  			bool isEnable = ((::GetMenuState(_mainMenuHandle, IDM_FILE_SAVE, MF_BYCOMMAND)&MF_DISABLED) == 0);
492  			_tabPopupMenu.enableItem(IDM_FILE_SAVE, isEnable);
493  			Buffer * buf = _pEditView->getCurrentBuffer();
494  			bool isUserReadOnly = buf->getUserReadOnly();
495  			_tabPopupMenu.checkItem(IDM_EDIT_SETREADONLY, isUserReadOnly);
496  			bool isSysReadOnly = buf->getFileReadOnly();
497  			_tabPopupMenu.enableItem(IDM_EDIT_SETREADONLY, !isSysReadOnly && !buf->isMonitoringOn());
498  			_tabPopupMenu.enableItem(IDM_EDIT_CLEARREADONLY, isSysReadOnly);
499  			bool isFileExisting = PathFileExists(buf->getFullPathName()) != FALSE;
500  			_tabPopupMenu.enableItem(IDM_FILE_DELETE, isFileExisting);
501  			_tabPopupMenu.enableItem(IDM_FILE_RELOAD, isFileExisting);
502  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_FOLDER, isFileExisting);
503  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_CMD, isFileExisting);
504  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_DEFAULT_VIEWER, isAssoCommandExisting(buf->getFullPathName()));
505  			bool isDirty = buf->isDirty();
506  			bool isUntitled = buf->isUntitled();
507  			_tabPopupMenu.enableItem(IDM_VIEW_GOTO_NEW_INSTANCE, !(isDirty||isUntitled));
508  			_tabPopupMenu.enableItem(IDM_VIEW_LOAD_IN_NEW_INSTANCE, !(isDirty||isUntitled));
509  			_tabPopupMenu.display(p);
510  			return TRUE;
511  		}
512  		case SCN_MARGINCLICK:
513  		{
514  			if (notification->nmhdr.hwndFrom == _mainEditView.getHSelf())
515  				switchEditViewTo(MAIN_VIEW);
516  			else if (notification->nmhdr.hwndFrom == _subEditView.getHSelf())
517  				switchEditViewTo(SUB_VIEW);
518  			intptr_t lineClick = _pEditView->execute(SCI_LINEFROMPOSITION, notification->position);
519  			if (notification->margin == ScintillaEditView::_SC_MARGE_FOLDER)
520  			{
521  				_pEditView->marginClick(notification->position, notification->modifiers);
522  				if (_pDocMap)
523  					_pDocMap->fold(lineClick, _pEditView->isFolded(lineClick));
524  				ScintillaEditView * unfocusView = isFromPrimary ? &_subEditView : &_mainEditView;
525  				_smartHighlighter.highlightView(_pEditView, unfocusView);
526  			}
527  			else if ((notification->margin == ScintillaEditView::_SC_MARGE_SYMBOL) && !notification->modifiers)
528  			{
529  				if (!_pEditView->markerMarginClick(lineClick))
530  					bookmarkToggle(lineClick);
531  			}
532  			break;
533  		}
534  		case SCN_MARGINRIGHTCLICK:
535  		{
536  			if (notification->nmhdr.hwndFrom == _mainEditView.getHSelf())
537  				switchEditViewTo(MAIN_VIEW);
538  			else if (notification->nmhdr.hwndFrom == _subEditView.getHSelf())
539  				switchEditViewTo(SUB_VIEW);
540  			if ((notification->margin == ScintillaEditView::_SC_MARGE_SYMBOL) && !notification->modifiers)
541  			{
542  				POINT p;
543  				::GetCursorPos(&p);
544  				MenuPosition& menuPos = getMenuPosition("search-bookmark");
545  				HMENU hSearchMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
546  				if (hSearchMenu)
547  				{
548  					HMENU hBookmarkMenu = ::GetSubMenu(hSearchMenu, menuPos._y);
549  					if (hBookmarkMenu)
550  					{
551  						TrackPopupMenu(hBookmarkMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
552  					}
553  				}
554  			}
555  			break;
556  		}
557  		case SCN_FOLDINGSTATECHANGED :
558  		{
559  			if ((notification->nmhdr.hwndFrom == _mainEditView.getHSelf()) || (notification->nmhdr.hwndFrom == _subEditView.getHSelf()))
560  			{
561  				size_t lineClicked = notification->line;
562  				if (!_isFolding)
563  				{
564  					addHotSpot();
565  				}
566  				if (_pDocMap)
567  					_pDocMap->fold(lineClicked, _pEditView->isFolded(lineClicked));
568  			}
569  			return TRUE;
570  		}
571  		case SCN_CHARADDED:
572  		{
573  			if (!_recordingMacro && !_playingBackMacro) 
574  			{
575  				const NppGUI & nppGui = NppParameters::getInstance().getNppGUI();
576  				bool indentMaintain = nppGui._maitainIndent;
577  				if (indentMaintain)
578  					maintainIndentation(static_cast<TCHAR>(notification->ch));
579  				Buffer* currentBuf = _pEditView->getCurrentBuffer();
580  				if (currentBuf->allowAutoCompletion())
581  				{
582  					AutoCompletion* autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
583  					bool isColumnMode = _pEditView->execute(SCI_GETSELECTIONS) > 1; 
584  					if (nppGui._matchedPairConf.hasAnyPairsPair() && !isColumnMode)
585  						autoC->insertMatchedChars(notification->ch, nppGui._matchedPairConf);
586  					autoC->update(notification->ch);
587  				}
588  			}
589  			break;
590  		}
591  		case SCN_DOUBLECLICK:
592  		{
593  			if (!notifyView)
594  				return FALSE;
595  			if (notification->modifiers == SCMOD_CTRL)
596  			{
597  				const NppGUI & nppGUI = NppParameters::getInstance().getNppGUI();
598  				std::string bufstring;
599  				size_t position_of_click;
600  				if (notification->position != -1)
601  					position_of_click = notification->position;
602  				else
603  					position_of_click = _pEditView->execute(SCI_GETCURRENTPOS);
604  				{
605  					char *buf;
606  					if (nppGUI._delimiterSelectionOnEntireDocument)
607  					{
608  						auto length = notifyView->execute(SCI_GETLENGTH);
609  						buf = new char[length + 1];
610  						notifyView->execute(SCI_GETTEXT, length + 1, reinterpret_cast<LPARAM>(buf));
611  					}
612  					else
613  					{
614  						auto length = notifyView->execute(SCI_GETCURLINE);
615  						buf = new char[length + 1];
616  						notifyView->execute(SCI_GETCURLINE, length, reinterpret_cast<LPARAM>(buf));
617  						const auto line_position = notifyView->execute(SCI_POSITIONFROMLINE, notifyView->getCurrentLineNumber());
618  						position_of_click = position_of_click - line_position;
619  					}
620  					bufstring = buf;
621  					delete [] buf;
622  				}
623  				int leftmost_position = -1;
624  				int rightmost_position = -1;
625  				if (nppGUI._rightmostDelimiter == nppGUI._leftmostDelimiter)
626  				{
627  					for (int32_t i = static_cast<int32_t>(position_of_click); i >= 0; --i)
628  					{
629  						if (i >= static_cast<int32_t>(bufstring.size()))
630  							return FALSE;
631  						if (bufstring.at(i) == nppGUI._leftmostDelimiter)
632  						{
633  							if (nppGUI._leftmostDelimiter == '"')
634  							{
635  								if (! (i > 0 && bufstring.at(i - 1) == '\\'))
636  								{
637  									leftmost_position = i;
638  									break;
639  								}
640  							}
641  							else
642  							{
643  								leftmost_position = i;
644  								break;
645  							}
646  						}
647  					}
648  					if (leftmost_position == -1)
649  						break;
650  					for (size_t i = position_of_click; i < bufstring.length(); ++i)
651  					{
652  						if (bufstring.at(i) == nppGUI._rightmostDelimiter)
653  						{
654  							if (nppGUI._rightmostDelimiter == '"')
655  							{
656  								if (! (i > 0 && bufstring.at(i - 1) == '\\'))
657  								{
658  									rightmost_position = static_cast<int32_t>(i);
659  									break;
660  								}
661  							}
662  							else
663  							{
664  								rightmost_position = static_cast<int32_t>(i);
665  								break;
666  							}
667  						}
668  					}
669  				}
670  				else
671  				{
672  					std::stack<unsigned int> leftmost_delimiter_positions;
673  					for (unsigned int i = 0; i < bufstring.length(); ++i)
674  					{
675  						if (bufstring.at(i) == nppGUI._leftmostDelimiter)
676  							leftmost_delimiter_positions.push(i);
677  						else if (bufstring.at(i) == nppGUI._rightmostDelimiter && ! leftmost_delimiter_positions.empty())
678  						{
679  							unsigned int matching_leftmost = leftmost_delimiter_positions.top();
680  							leftmost_delimiter_positions.pop();
681  							assert( (leftmost_position == -1 && rightmost_position == -1) || (leftmost_position >= 0 && rightmost_position >= 0) );
682  							if (matching_leftmost <= position_of_click && i >= position_of_click && (leftmost_position == -1 || matching_leftmost > static_cast<unsigned int>(leftmost_position)))
683  							{
684  								leftmost_position = matching_leftmost;
685  								rightmost_position = i;
686  							}
687  						}
688  					}
689  				}
690  				if (rightmost_position != -1 && leftmost_position != -1)
691  				{
692  					if (nppGUI._delimiterSelectionOnEntireDocument)
693  					{
694  						notifyView->execute(SCI_SETCURRENTPOS, rightmost_position);
695  						notifyView->execute(SCI_SETANCHOR, leftmost_position + 1);
696  					}
697  					else
698  					{
699  						const auto line_position = notifyView->execute(SCI_POSITIONFROMLINE, notifyView->getCurrentLineNumber());
700  						notifyView->execute(SCI_SETCURRENTPOS, line_position + rightmost_position);
701  						notifyView->execute(SCI_SETANCHOR, line_position + leftmost_position + 1);
702  					}
703  				}
704  			}
705  			else
706  			{ 
707  				auto indicMsk = notifyView->execute(SCI_INDICATORALLONFOR, notification->position);
708  				if (!(indicMsk & (1 << URL_INDIC)))
709  					break;
710  				auto startPos = notifyView->execute(SCI_INDICATORSTART, URL_INDIC, notification->position);
711  				auto endPos = notifyView->execute(SCI_INDICATOREND, URL_INDIC, notification->position);
712  				if ((notification->position < startPos) || (notification->position > endPos))
713  					break;
714  				::PostMessage(notifyView->getHSelf(), WM_LBUTTONUP, 0, 0);
715  				notifyView->execute(SCI_SETSEL, notification->position, notification->position); 
716  				generic_string url = notifyView->getGenericTextAsString(static_cast<size_t>(startPos), static_cast<size_t>(endPos));
717  				::ShellExecute(_pPublicInterface->getHSelf(), TEXT("open"), url.c_str(), NULL, NULL, SW_SHOW);
718  			}
719  			break;
720  		}
721  		case SCN_UPDATEUI:
722  		{
723  			if (!notifyView)
724  				return FALSE;
725  			NppParameters& nppParam = NppParameters::getInstance();
726  			NppGUI & nppGui = nppParam.getNppGUI();
727  			if (notification->updated & SC_UPDATE_V_SCROLL)
728  			{
729  				addHotSpot(notifyView);
730  			}
731  			if (nppParam._isFindReplacing)
732  				break;
733  			Buffer* currentBuf = _pEditView->getCurrentBuffer();
734  			if (notification->nmhdr.hwndFrom != _pEditView->getHSelf() && currentBuf->allowSmartHilite()) 
735  			{
736  				if (nppGui._smartHiliteOnAnotherView)
737  				{
738  					TCHAR selectedText[1024];
739  					_pEditView->getGenericSelectedText(selectedText, sizeof(selectedText)/sizeof(TCHAR), false);
740  					_smartHighlighter.highlightViewWithWord(notifyView, selectedText);
741  				}
742  				break;
743  			}
744  			braceMatch();
745  			if (nppGui._enableTagsMatchHilite)
746  			{
747  				XmlMatchedTagsHighlighter xmlTagMatchHiliter(_pEditView);
748  				xmlTagMatchHiliter.tagMatch(nppGui._enableTagAttrsHilite);
749  			}
750  			if (nppGui._enableSmartHilite && currentBuf->allowSmartHilite())
751  			{
752  				if (nppGui._disableSmartHiliteTmp)
753  					nppGui._disableSmartHiliteTmp = false;
754  				else
755  				{
756  					ScintillaEditView * anbotherView = isFromPrimary ? &_subEditView : &_mainEditView;
757  					_smartHighlighter.highlightView(notifyView, anbotherView);
758  				}
759  			}
760  			bool selectionIsChanged = (notification->updated & SC_UPDATE_SELECTION) != 0;
761  			bool contentIsChanged = (notification->updated & SC_UPDATE_CONTENT) != 0;
762  			if (selectionIsChanged || contentIsChanged)
763  			{
764  				updateStatusBar();
765  			}
766  			if (_pFuncList && (!_pFuncList->isClosed()) && _pFuncList->isVisible())
767  				_pFuncList->markEntry();
768  			AutoCompletion * autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
769  			autoC->update(0);
770  			break;
771  		}
772  		case TTN_GETDISPINFO:
773  		{
774  			try
775  			{
776  				LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)notification;
777  				lpttt->hinst = NULL;
778  				POINT p;
779  				::GetCursorPos(&p);
780  				::MapWindowPoints(NULL, _pPublicInterface->getHSelf(), &p, 1);
781  				HWND hWin = ::ChildWindowFromPointEx(_pPublicInterface->getHSelf(), p, CWP_SKIPINVISIBLE);
782  				const int tipMaxLen = 1024;
783  				static TCHAR docTip[tipMaxLen];
784  				docTip[0] = '\0';
785  				generic_string tipTmp(TEXT(""));
786  				int id = int(lpttt->hdr.idFrom);
787  				if (hWin == _rebarTop.getHSelf())
788  				{
789  					getNameStrFromCmd(id, tipTmp);
790  					if (tipTmp.length() >= 80)
791  						return FALSE;
792  					wcscpy_s(lpttt->szText, tipTmp.c_str());
793  					return TRUE;
794  				}
795  				else if (hWin == _mainDocTab.getHSelf())
796  				{
797  					BufferID idd = _mainDocTab.getBufferByIndex(id);
798  					Buffer * buf = MainFileManager.getBufferByID(idd);
799  					if (buf == nullptr)
800  						return FALSE;
801  					tipTmp = buf->getFullPathName();
802  					if (tipTmp.length() >= tipMaxLen)
803  						return FALSE;
804  					wcscpy_s(docTip, tipTmp.c_str());
805  					lpttt->lpszText = docTip;
806  					return TRUE;
807  				}
808  				else if (hWin == _subDocTab.getHSelf())
809  				{
810  					BufferID idd = _subDocTab.getBufferByIndex(id);
811  					Buffer * buf = MainFileManager.getBufferByID(idd);
812  					if (buf == nullptr)
813  						return FALSE;
814  					tipTmp = buf->getFullPathName();
815  					if (tipTmp.length() >= tipMaxLen)
816  						return FALSE;
817  					wcscpy_s(docTip, tipTmp.c_str());
818  					lpttt->lpszText = docTip;
819  					return TRUE;
820  				}
821  				else
822  					return FALSE;
823  			}
824  			catch (...)
825  			{
826  			}
827  			break;
828  		}
829  		case SCN_ZOOM:
830  		{
831  			if (!notifyView)
832  				return FALSE;
833  			ScintillaEditView * unfocusView = isFromPrimary ? &_subEditView : &_mainEditView;
834  			_smartHighlighter.highlightView(notifyView, unfocusView);
835  			break;
836  		}
837  		case SCN_MACRORECORD:
838  		{
839  			_macro.push_back(
840  				recordedMacroStep(
841  					notification->message,
842  					notification->wParam,
843  					notification->lParam
844  				)
845  			);
846  			break;
847  		}
848  		case SCN_PAINTED:
849  		{
850  			if (!notifyView)
851  				return FALSE;
852  			_mainEditView.restoreCurrentPosPostStep();
853  			_subEditView.restoreCurrentPosPostStep();
854  			if (_mainEditView.isWrapRestoreNeeded())
855  			{
856  				_mainEditView.restoreCurrentPosPreStep();
857  				_mainEditView.setWrapRestoreNeeded(false);
858  			}
859  			if (_subEditView.isWrapRestoreNeeded())
860  			{
861  				_subEditView.restoreCurrentPosPreStep();
862  				_subEditView.setWrapRestoreNeeded(false);
863  			}
864  			notifyView->updateLineNumberWidth();
865  			if (_syncInfo.doSync())
866  				doSynScorll(HWND(notification->nmhdr.hwndFrom));
867  			NppParameters& nppParam = NppParameters::getInstance();
868  			if ((_linkTriggered && !nppParam._isFindReplacing) || notification->wParam == LINKTRIGGERED)
869  			{
870  				addHotSpot();
871  				_linkTriggered = false;
872  			}
873  			if (_pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible() && !_pDocMap->isTemporarilyShowing())
874  			{
875  				_pDocMap->wrapMap();
876  				_pDocMap->scrollMap();
877  			}
878  			break;
879  		}
880  		case SCN_NEEDSHOWN:
881  		{
882  			break;
883  		}
884  		case SCN_CALLTIPCLICK:
885  		{
886  			AutoCompletion * autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
887  			autoC->callTipClick(notification->position);
888  			break;
889  		}
890  		case SCN_AUTOCSELECTION:
891  		{
892  			const NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
893  			if (nppGui._autocStatus == NppGUI::AutocStatus::autoc_none)
894  			{
895  				break;
896  			}
897  			if (notification->listCompletionMethod == SC_AC_NEWLINE && !nppGui._autocInsertSelectedUseENTER)
898  			{
899  				notifyView->execute(SCI_AUTOCCANCEL);
900  				notifyView->execute(SCI_NEWLINE);
901  			}
902  			if (notification->listCompletionMethod == SC_AC_TAB && !nppGui._autocInsertSelectedUseTAB)
903  			{
904  				notifyView->execute(SCI_AUTOCCANCEL);
905  				notifyView->execute(SCI_TAB);
906  			}
907  			break;
908  		}
909  		case RBN_HEIGHTCHANGE:
910  		{
911  			SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
912  			break;
913  		}
914  		case RBN_CHEVRONPUSHED:
915  		{
916  			NMREBARCHEVRON * lpnm = reinterpret_cast<NMREBARCHEVRON *>(notification);
917  			ReBar * notifRebar = &_rebarTop;
918  			if (_rebarBottom.getHSelf() == lpnm->hdr.hwndFrom)
919  				notifRebar = &_rebarBottom;
920  			if (lpnm->wID == REBAR_BAR_TOOLBAR)
921  			{
922  				POINT pt{};
923  				pt.x = lpnm->rc.left;
924  				pt.y = lpnm->rc.bottom;
925  				ClientToScreen(notifRebar->getHSelf(), &pt);
926  				_toolBar.doPopop(pt);
927  				return TRUE;
928  			}
929  			REBARBANDINFO rbBand;
930  			ZeroMemory(&rbBand, REBARBAND_SIZE);
931  			rbBand.cbSize = REBARBAND_SIZE;
932  			rbBand.fMask = RBBIM_CHILD;
933  			::SendMessage(notifRebar->getHSelf(), RB_GETBANDINFO, lpnm->uBand, reinterpret_cast<LPARAM>(&rbBand));
934  			::SendMessage(rbBand.hwndChild, WM_NOTIFY, 0, reinterpret_cast<LPARAM>(lpnm));
935  			break;
936  		}
937  		default:
938  			break;
939  	}
940  	return FALSE;
941  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-winmain.cpp</h3>
            <pre><code>1  #include "Notepad_plus_Window.h"
2  #include "Processus.h"
3  #include "Win32Exception.h"	
4  #include "MiniDumper.h"			
5  #include "verifySignedfile.h"
6  #include "NppDarkMode.h"
7  #include <memory>
8  typedef std::vector<generic_string> ParamVector;
9  namespace
10  {
11  void allowPrivilegeMessages(const Notepad_plus_Window& notepad_plus_plus, winVer winVer)
12  {
13  	#ifndef MSGFLT_ADD
14  	const DWORD MSGFLT_ADD = 1;
15  	#endif
16  	#ifndef MSGFLT_ALLOW
17  	const DWORD MSGFLT_ALLOW = 1;
18  	#endif
19  	if (winVer >= WV_VISTA || winVer == WV_UNKNOWN)
20  	{
21  		HMODULE hDll = GetModuleHandle(TEXT("user32.dll"));
22  		if (hDll)
23  		{
24  			if (winVer == WV_VISTA)
25  			{
26  				typedef BOOL (WINAPI *MESSAGEFILTERFUNC)(UINT message,DWORD dwFlag);
27  				MESSAGEFILTERFUNC func = (MESSAGEFILTERFUNC)::GetProcAddress( hDll, "ChangeWindowMessageFilter" );
28  				if (func)
29  				{
30  					func(WM_COPYDATA, MSGFLT_ADD);
31  					func(NPPM_INTERNAL_RESTOREFROMTRAY, MSGFLT_ADD);
32  				}
33  			}
34  			else
35  			{
36  				typedef BOOL (WINAPI *MESSAGEFILTERFUNCEX)(HWND hWnd,UINT message,DWORD action,VOID* pChangeFilterStruct);
37  				MESSAGEFILTERFUNCEX funcEx = (MESSAGEFILTERFUNCEX)::GetProcAddress( hDll, "ChangeWindowMessageFilterEx" );
38  				if (funcEx)
39  				{
40  					funcEx(notepad_plus_plus.getHSelf(), WM_COPYDATA, MSGFLT_ALLOW, NULL);
41  					funcEx(notepad_plus_plus.getHSelf(), NPPM_INTERNAL_RESTOREFROMTRAY, MSGFLT_ALLOW, NULL);
42  				}
43  			}
44  		}
45  	}
46  }
47  void parseCommandLine(const TCHAR* commandLine, ParamVector& paramVector)
48  {
49  	if (!commandLine)
50  		return;
51  	TCHAR* cmdLine = new TCHAR[lstrlen(commandLine) + 1];
52  	lstrcpy(cmdLine, commandLine);
53  	TCHAR* cmdLinePtr = cmdLine;
54  	bool isInFile = false;
55  	bool isStringInArg = false;
56  	bool isInWhiteSpace = true;
57  	int zArg = 0; 
58  	bool shouldBeTerminated = false; 
59  	size_t commandLength = lstrlen(cmdLinePtr);
60  	std::vector<TCHAR *> args;
61  	for (size_t i = 0; i < commandLength && !shouldBeTerminated; ++i)
62  	{
63  		switch (cmdLinePtr[i])
64  		{
65  			case '\"': 
66  			{
67  				if (!isStringInArg && i > 0 && cmdLinePtr[i-1] == '=')
68  				{
69  					isStringInArg = true;
70  				}
71  				else if (isStringInArg)
72  				{
73  					isStringInArg = false;
74  				}
75  				else if (!isInFile)	
76  				{
77  					args.push_back(cmdLinePtr + i + 1);	
78  					isInFile = true;
79  					cmdLinePtr[i] = 0;
80  					if (zArg == 1)
81  					{
82  						++zArg; 
83  					}
84  				}
85  				else if (isInFile)
86  				{
87  					isInFile = false;
88  					cmdLinePtr[i] = 0;
89  				}
90  				isInWhiteSpace = false;
91  			}
92  			break;
93  			case '\t': 
94  			case ' ':
95  			{
96  				isInWhiteSpace = true;
97  				if (!isInFile && !isStringInArg)
98  				{
99  					cmdLinePtr[i] = 0;		
100  					size_t argsLen = args.size();
101  					if (argsLen > 0 && lstrcmp(args[argsLen-1], L"-z") == 0)
102  						++zArg; 
103  				}
104  			}
105  			break;
106  			default: 
107  			{
108  				if (!isInFile && !isStringInArg && isInWhiteSpace)
109  				{
110  					args.push_back(cmdLinePtr + i);	
111  					if (zArg == 2)
112  					{
113  						shouldBeTerminated = true; 
114  					}
115  					isInWhiteSpace = false;
116  				}
117  			}
118  		}
119  	}
120  	paramVector.assign(args.begin(), args.end());
121  	delete[] cmdLine;
122  }
123  void convertParamsToNotepadStyle(ParamVector& params)
124  {
125  	for (auto it = params.begin(); it != params.end(); ++it)
126  	{
127  		if (lstrcmp(it->c_str(), TEXT("/p")) == 0 || lstrcmp(it->c_str(), TEXT("/P")) == 0)
128  		{
129  			it->assign(TEXT("-quickPrint"));
130  		}
131  	}
132  }
133  bool isInList(const TCHAR *token2Find, ParamVector& params, bool eraseArg = true)
134  {
135  	for (auto it = params.begin(); it != params.end(); ++it)
136  	{
137  		if (lstrcmp(token2Find, it->c_str()) == 0)
138  		{
139  			if (eraseArg) params.erase(it);
140  			return true;
141  		}
142  	}
143  	return false;
144  }
145  bool getParamVal(TCHAR c, ParamVector & params, generic_string & value)
146  {
147  	value = TEXT("");
148  	size_t nbItems = params.size();
149  	for (size_t i = 0; i < nbItems; ++i)
150  	{
151  		const TCHAR * token = params.at(i).c_str();
152  		if (token[0] == '-' && lstrlen(token) >= 2 && token[1] == c) 
153  		{
154  			value = (token+2);
155  			params.erase(params.begin() + i);
156  			return true;
157  		}
158  	}
159  	return false;
160  }
161  bool getParamValFromString(const TCHAR *str, ParamVector & params, generic_string & value)
162  {
163  	value = TEXT("");
164  	size_t nbItems = params.size();
165  	for (size_t i = 0; i < nbItems; ++i)
166  	{
167  		const TCHAR * token = params.at(i).c_str();
168  		generic_string tokenStr = token;
169  		size_t pos = tokenStr.find(str);
170  		if (pos != generic_string::npos && pos == 0)
171  		{
172  			value = (token + lstrlen(str));
173  			params.erase(params.begin() + i);
174  			return true;
175  		}
176  	}
177  	return false;
178  }
179  LangType getLangTypeFromParam(ParamVector & params)
180  {
181  	generic_string langStr;
182  	if (!getParamVal('l', params, langStr))
183  		return L_EXTERNAL;
184  	return NppParameters::getLangIDFromStr(langStr.c_str());
185  }
186  generic_string getLocalizationPathFromParam(ParamVector & params)
187  {
188  	generic_string locStr;
189  	if (!getParamVal('L', params, locStr))
190  		return TEXT("");
191  	locStr = stringToLower(stringReplace(locStr, TEXT("_"), TEXT("-"))); 
192  	return NppParameters::getLocPathFromStr(locStr.c_str());
193  }
194  intptr_t getNumberFromParam(char paramName, ParamVector & params, bool & isParamePresent)
195  {
196  	generic_string numStr;
197  	if (!getParamVal(paramName, params, numStr))
198  	{
199  		isParamePresent = false;
200  		return -1;
201  	}
202  	isParamePresent = true;
203  	return static_cast<intptr_t>(_ttoi64(numStr.c_str()));
204  }
205  generic_string getEasterEggNameFromParam(ParamVector & params, unsigned char & type)
206  {
207  	generic_string EasterEggName;
208  	if (!getParamValFromString(TEXT("-qn="), params, EasterEggName))  
209  	{
210  		if (!getParamValFromString(TEXT("-qt="), params, EasterEggName)) 
211  		{
212  			if (!getParamValFromString(TEXT("-qf="), params, EasterEggName)) 
213  				return TEXT("");
214  			else
215  			{
216  				type = 2; 
217  			}
218  		}
219  		else
220  			type = 1; 
221  	}
222  	else
223  		type = 0; 
224  	if (EasterEggName.c_str()[0] == '"' && EasterEggName.c_str()[EasterEggName.length() - 1] == '"')
225  	{
226  		EasterEggName = EasterEggName.substr(1, EasterEggName.length() - 2);
227  	}
228  	if (type == 2)
229  		EasterEggName = relativeFilePathToFullFilePath(EasterEggName.c_str());
230  	return EasterEggName;
231  }
232  int getGhostTypingSpeedFromParam(ParamVector & params)
233  {
234  	generic_string speedStr;
235  	if (!getParamValFromString(TEXT("-qSpeed"), params, speedStr))
236  		return -1;
237  	int speed = std::stoi(speedStr, 0);
238  	if (speed <= 0 || speed > 3)
239  		return -1;
240  	return speed;
241  }
242  const TCHAR FLAG_MULTI_INSTANCE[] = TEXT("-multiInst");
243  const TCHAR FLAG_NO_PLUGIN[] = TEXT("-noPlugin");
244  const TCHAR FLAG_READONLY[] = TEXT("-ro");
245  const TCHAR FLAG_NOSESSION[] = TEXT("-nosession");
246  const TCHAR FLAG_NOTABBAR[] = TEXT("-notabbar");
247  const TCHAR FLAG_SYSTRAY[] = TEXT("-systemtray");
248  const TCHAR FLAG_LOADINGTIME[] = TEXT("-loadingTime");
249  const TCHAR FLAG_HELP[] = TEXT("--help");
250  const TCHAR FLAG_ALWAYS_ON_TOP[] = TEXT("-alwaysOnTop");
251  const TCHAR FLAG_OPENSESSIONFILE[] = TEXT("-openSession");
252  const TCHAR FLAG_RECURSIVE[] = TEXT("-r");
253  const TCHAR FLAG_FUNCLSTEXPORT[] = TEXT("-export=functionList");
254  const TCHAR FLAG_PRINTANDQUIT[] = TEXT("-quickPrint");
255  const TCHAR FLAG_NOTEPAD_COMPATIBILITY[] = TEXT("-notepadStyleCmdline");
256  const TCHAR FLAG_OPEN_FOLDERS_AS_WORKSPACE[] = TEXT("-openFoldersAsWorkspace");
257  const TCHAR FLAG_SETTINGS_DIR[] = TEXT("-settingsDir=");
258  const TCHAR FLAG_TITLEBAR_ADD[] = TEXT("-titleAdd=");
259  const TCHAR FLAG_APPLY_UDL[] = TEXT("-udl=");
260  const TCHAR FLAG_PLUGIN_MESSAGE[] = TEXT("-pluginMessage=");
261  const TCHAR FLAG_MONITOR_FILES[] = TEXT("-monitor");
262  void doException(Notepad_plus_Window & notepad_plus_plus)
263  {
264  	Win32Exception::removeHandler();	
265  	::MessageBox(Notepad_plus_Window::gNppHWND, TEXT("Notepad++ will attempt to save any unsaved data. However, dataloss is very likely."), TEXT("Recovery initiating"), MB_OK | MB_ICONINFORMATION);
266  	TCHAR tmpDir[1024];
267  	GetTempPath(1024, tmpDir);
268  	generic_string emergencySavedDir = tmpDir;
269  	emergencySavedDir += TEXT("\\Notepad++ RECOV");
270  	bool res = notepad_plus_plus.emergency(emergencySavedDir);
271  	if (res)
272  	{
273  		generic_string displayText = TEXT("Notepad++ was able to successfully recover some unsaved documents, or nothing to be saved could be found.\r\nYou can find the results at :\r\n");
274  		displayText += emergencySavedDir;
275  		::MessageBox(Notepad_plus_Window::gNppHWND, displayText.c_str(), TEXT("Recovery success"), MB_OK | MB_ICONINFORMATION);
276  	}
277  	else
278  		::MessageBox(Notepad_plus_Window::gNppHWND, TEXT("Unfortunatly, Notepad++ was not able to save your work. We are sorry for any lost data."), TEXT("Recovery failure"), MB_OK | MB_ICONERROR);
279  }
280  void stripIgnoredParams(ParamVector & params)
281  {
282  	for (auto it = params.begin(); it != params.end(); )
283  	{
284  		if (lstrcmp(it->c_str(), TEXT("-z")) == 0)
285  		{
286  			auto nextIt = std::next(it);
287  			if ( nextIt != params.end() )
288  			{
289  				params.erase(nextIt);
290  			}
291  			it = params.erase(it);
292  		}
293  		else
294  		{
295  			++it;
296  		}
297  	}
298  }
299  } 
300  int WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE &bsol;*hPrevInstance*/, _In_ PWSTR pCmdLine, _In_ int &bsol;*nShowCmd*/)
301  {
302  	bool TheFirstOne = true;
303  	::SetLastError(NO_ERROR);
304  	::CreateMutex(NULL, false, TEXT("nppInstance"));
305  	if (::GetLastError() == ERROR_ALREADY_EXISTS)
306  		TheFirstOne = false;
307  	generic_string cmdLineString = pCmdLine ? pCmdLine : _T("");
308  	ParamVector params;
309  	parseCommandLine(pCmdLine, params);
310  	stripIgnoredParams(params);
311  	if ( isInList(FLAG_NOTEPAD_COMPATIBILITY, params) )
312  	{
313  		convertParamsToNotepadStyle(params);
314  	}
315  	bool isParamePresent;
316  	bool showHelp = isInList(FLAG_HELP, params);
317  	bool isMultiInst = isInList(FLAG_MULTI_INSTANCE, params);
318  	bool doFunctionListExport = isInList(FLAG_FUNCLSTEXPORT, params);
319  	bool doPrintAndQuit = isInList(FLAG_PRINTANDQUIT, params);
320  	CmdLineParams cmdLineParams;
321  	cmdLineParams._isNoTab = isInList(FLAG_NOTABBAR, params);
322  	cmdLineParams._isNoPlugin = isInList(FLAG_NO_PLUGIN, params);
323  	cmdLineParams._isReadOnly = isInList(FLAG_READONLY, params);
324  	cmdLineParams._isNoSession = isInList(FLAG_NOSESSION, params);
325  	cmdLineParams._isPreLaunch = isInList(FLAG_SYSTRAY, params);
326  	cmdLineParams._alwaysOnTop = isInList(FLAG_ALWAYS_ON_TOP, params);
327  	cmdLineParams._showLoadingTime = isInList(FLAG_LOADINGTIME, params);
328  	cmdLineParams._isSessionFile = isInList(FLAG_OPENSESSIONFILE, params);
329  	cmdLineParams._isRecursive = isInList(FLAG_RECURSIVE, params);
330  	cmdLineParams._openFoldersAsWorkspace = isInList(FLAG_OPEN_FOLDERS_AS_WORKSPACE, params);
331  	cmdLineParams._monitorFiles = isInList(FLAG_MONITOR_FILES, params);
332  	cmdLineParams._langType = getLangTypeFromParam(params);
333  	cmdLineParams._localizationPath = getLocalizationPathFromParam(params);
334  	cmdLineParams._easterEggName = getEasterEggNameFromParam(params, cmdLineParams._quoteType);
335  	cmdLineParams._ghostTypingSpeed = getGhostTypingSpeedFromParam(params);
336  	generic_string pluginMessage;
337  	if (getParamValFromString(FLAG_PLUGIN_MESSAGE, params, pluginMessage))
338  	{
339  		if (pluginMessage.length() >= 2)
340  		{
341  			if (pluginMessage.front() == '"' && pluginMessage.back() == '"')
342  			{
343  				pluginMessage = pluginMessage.substr(1, pluginMessage.length() - 2);
344  			}
345  		}
346  		cmdLineParams._pluginMessage = pluginMessage;
347  	}
348  	cmdLineParams._line2go = getNumberFromParam('n', params, isParamePresent);
349      cmdLineParams._column2go = getNumberFromParam('c', params, isParamePresent);
350      cmdLineParams._pos2go = getNumberFromParam('p', params, isParamePresent);
351  	cmdLineParams._point.x = static_cast<LONG>(getNumberFromParam('x', params, cmdLineParams._isPointXValid));
352  	cmdLineParams._point.y = static_cast<LONG>(getNumberFromParam('y', params, cmdLineParams._isPointYValid));
353  	NppParameters& nppParameters = NppParameters::getInstance();
354  	nppParameters.setCmdLineString(cmdLineString);
355  	generic_string path;
356  	if (getParamValFromString(FLAG_SETTINGS_DIR, params, path))
357  	{
358  		if (path.c_str()[0] == '"' && path.c_str()[path.length() - 1] == '"')
359  		{
360  			path = path.substr(1, path.length() - 2);
361  		}
362  		nppParameters.setCmdSettingsDir(path);
363  	}
364  	generic_string titleBarAdditional;
365  	if (getParamValFromString(FLAG_TITLEBAR_ADD, params, titleBarAdditional))
366  	{
367  		if (titleBarAdditional.length() >= 2)
368  		{
369  			if (titleBarAdditional.front() == '"' && titleBarAdditional.back() == '"')
370  			{
371  				titleBarAdditional = titleBarAdditional.substr(1, titleBarAdditional.length() - 2);
372  			}
373  		}
374  		nppParameters.setTitleBarAdd(titleBarAdditional);
375  	}
376  	generic_string udlName;
377  	if (getParamValFromString(FLAG_APPLY_UDL, params, udlName))
378  	{
379  		if (udlName.length() >= 2)
380  		{
381  			if (udlName.front() == '"' && udlName.back() == '"')
382  			{
383  				udlName = udlName.substr(1, udlName.length() - 2);
384  			}
385  		}
386  		cmdLineParams._udlName = udlName;
387  	}
388  	if (showHelp)
389  		::MessageBox(NULL, COMMAND_ARG_HELP, TEXT("Notepad++ Command Argument Help"), MB_OK);
390  	if (cmdLineParams._localizationPath != TEXT(""))
391  	{
392  		nppParameters.setStartWithLocFileName(cmdLineParams._localizationPath);
393  	}
394  	nppParameters.load();
395  	NppGUI & nppGui = nppParameters.getNppGUI();
396  	NppDarkMode::initDarkMode();
397  	bool doUpdateNpp = nppGui._autoUpdateOpt._doAutoUpdate;
398  	bool doUpdatePluginList = nppGui._autoUpdateOpt._doAutoUpdate;
399  	if (doFunctionListExport || doPrintAndQuit) 
400  	{
401  		isMultiInst = true;
402  		doUpdateNpp = doUpdatePluginList = false;
403  		cmdLineParams._isNoSession = true;
404  	}
405  	nppParameters.setFunctionListExportBoolean(doFunctionListExport);
406  	nppParameters.setPrintAndExitBoolean(doPrintAndQuit);
407  	if (nppParameters.asNotepadStyle())
408  	{
409  		isMultiInst = true;
410  		cmdLineParams._isNoTab = true;
411  		cmdLineParams._isNoSession = true;
412  	}
413  	const NppGUI & nppGUI = nppParameters.getNppGUI();
414  	if (nppGUI._multiInstSetting == multiInst)
415  	{
416  		isMultiInst = true;
417  		if (!TheFirstOne)
418  			cmdLineParams._isNoSession = true;
419  	}
420  	generic_string quotFileName = TEXT("");
421  	size_t nbFilesToOpen = params.size();
422  	for (size_t i = 0; i < nbFilesToOpen; ++i)
423  	{
424  		const TCHAR * currentFile = params.at(i).c_str();
425  		if (currentFile[0])
426  		{
427  			quotFileName += TEXT("\"");
428  			quotFileName += relativeFilePathToFullFilePath(currentFile);
429  			quotFileName += TEXT("\" ");
430  		}
431  	}
432  	::SetCurrentDirectory(NppParameters::getInstance().getNppPath().c_str());	
433  	if ((!isMultiInst) && (!TheFirstOne))
434  	{
435  		HWND hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), NULL);
436  		for (int i = 0 ;!hNotepad_plus && i < 5 ; ++i)
437  		{
438  			Sleep(100);
439  			hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), NULL);
440  		}
441          if (hNotepad_plus)
442          {
443  			nppParameters.destroyInstance();
444  			bool isInSystemTray = ::SendMessage(hNotepad_plus, NPPM_INTERNAL_RESTOREFROMTRAY, 0, 0);
445  			if (!isInSystemTray)
446  			{
447  				int sw = 0;
448  				if (::IsZoomed(hNotepad_plus))
449  					sw = SW_MAXIMIZE;
450  				else if (::IsIconic(hNotepad_plus))
451  					sw = SW_RESTORE;
452  				if (sw != 0)
453  					::ShowWindow(hNotepad_plus, sw);
454  			}
455  			::SetForegroundWindow(hNotepad_plus);
456  			if (params.size() > 0)	
457  			{
458  				CmdLineParamsDTO dto = CmdLineParamsDTO::FromCmdLineParams(cmdLineParams);
459  				COPYDATASTRUCT paramData{};
460  				paramData.dwData = COPYDATA_PARAMS;
461  				paramData.lpData = &dto;
462  				paramData.cbData = sizeof(dto);
463  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&paramData));
464  				COPYDATASTRUCT cmdLineData{};
<span onclick='openModal()' class='match'>465  				cmdLineData.dwData = COPYDATA_FULL_CMDLINE;
466  				cmdLineData.lpData = (void*)cmdLineString.c_str();
467  				cmdLineData.cbData = static_cast<DWORD>((cmdLineString.length() + 1) * sizeof(TCHAR));
468  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&cmdLineData));
</span>469  				COPYDATASTRUCT fileNamesData{};
470  				fileNamesData.dwData = COPYDATA_FILENAMESW;
471  				fileNamesData.lpData = (void *)quotFileName.c_str();
472  				fileNamesData.cbData = static_cast<DWORD>((quotFileName.length() + 1) * sizeof(TCHAR));
473  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&fileNamesData));
474  			}
475  			return 0;
476          }
477  	}
478  	auto upNotepadWindow = std::make_unique<Notepad_plus_Window>();
479  	Notepad_plus_Window & notepad_plus_plus = *upNotepadWindow.get();
480  	generic_string updaterDir = nppParameters.getNppPath();
481  	updaterDir += TEXT("\\updater\\");
482  	generic_string updaterFullPath = updaterDir + TEXT("gup.exe");
483  	generic_string updaterParams = TEXT("-v");
484  	updaterParams += VERSION_VALUE;
485  	bool isUpExist = nppGui._doesExistUpdater = (::PathFileExists(updaterFullPath.c_str()) == TRUE);
486      if (doUpdateNpp) 
487      {
488          Date today(0);
489          if (today < nppGui._autoUpdateOpt._nextUpdateDate)
490              doUpdateNpp = false;
491      }
492  	if (doUpdatePluginList)
493  	{
494  	}
495  	winVer ver = nppParameters.getWinVersion();
496  	bool isGtXP = ver > WV_XP;
497  	SecurityGuard securityGuard;
498  	bool isSignatureOK = securityGuard.checkModule(updaterFullPath, nm_gup);
499  	if (TheFirstOne && isUpExist && isGtXP && isSignatureOK)
500  	{
501  		if (nppParameters.archType() == IMAGE_FILE_MACHINE_AMD64)
502  		{
503  			updaterParams += TEXT(" -px64");
504  		}
505  		else if (nppParameters.archType() == IMAGE_FILE_MACHINE_ARM64)
506  		{
507  			updaterParams += TEXT(" -parm64");
508  		}
509  		if (doUpdateNpp)
510  		{
511  			Process updater(updaterFullPath.c_str(), updaterParams.c_str(), updaterDir.c_str());
512  			updater.run();
513  			if (nppGui._autoUpdateOpt._intervalDays < 0) 
514  				nppGui._autoUpdateOpt._intervalDays = 0 - nppGui._autoUpdateOpt._intervalDays;
515  			nppGui._autoUpdateOpt._nextUpdateDate = Date(nppGui._autoUpdateOpt._intervalDays);
516  		}
517  		doUpdatePluginList = false;
518  		if (doUpdatePluginList)
519  		{
520  			generic_string upPlParams = TEXT("-v"); 
521  			upPlParams += notepad_plus_plus.getPluginListVerStr();
522  			if (nppParameters.archType() == IMAGE_FILE_MACHINE_AMD64)
523  			{
524  				upPlParams += TEXT(" -px64");
525  			}
526  			else if (nppParameters.archType() == IMAGE_FILE_MACHINE_ARM64)
527  			{
528  				upPlParams += TEXT(" -parm64");
529  			}
530  			upPlParams += TEXT(" -upZip");
531  			upPlParams += TEXT(" https:&bsol;&bsol;notepad-plus-plus.org/update/pluginListDownloadUrl.php");
532  			upPlParams += nppParameters.getPluginConfDir();
533  			Process updater(updaterFullPath.c_str(), upPlParams.c_str(), updaterDir.c_str());
534  			updater.run();
535  		}
536  	}
537  	MSG msg{};
538  	msg.wParam = 0;
539  	Win32Exception::installHandler();
540  	MiniDumper mdump;	
541  	try
542  	{
543  		notepad_plus_plus.init(hInstance, NULL, quotFileName.c_str(), &cmdLineParams);
544  		allowPrivilegeMessages(notepad_plus_plus, ver);
545  		bool going = true;
546  		while (going)
547  		{
548  			going = ::GetMessageW(&msg, NULL, 0, 0) != 0;
549  			if (going)
550  			{
551  				if (!notepad_plus_plus.isDlgsMsg(&msg))
552  				{
553  					if (::TranslateAccelerator(notepad_plus_plus.getHSelf(), notepad_plus_plus.getAccTable(), &msg) == 0)
554  					{
555  						::TranslateMessage(&msg);
556  						::DispatchMessageW(&msg);
557  					}
558  				}
559  			}
560  		}
561  	}
562  	catch (int i)
563  	{
564  		TCHAR str[50] = TEXT("God Damned Exception : ");
565  		TCHAR code[10];
566  		wsprintf(code, TEXT("%d"), i);
567  		wcscat_s(str, code);
568  		::MessageBox(Notepad_plus_Window::gNppHWND, str, TEXT("Int Exception"), MB_OK);
569  		doException(notepad_plus_plus);
570  	}
571  	catch (std::runtime_error & ex)
572  	{
573  		::MessageBoxA(Notepad_plus_Window::gNppHWND, ex.what(), "Runtime Exception", MB_OK);
574  		doException(notepad_plus_plus);
575  	}
576  	catch (const Win32Exception & ex)
577  	{
578  		TCHAR message[1024];	
579  		wsprintf(message, TEXT("An exception occured. Notepad++ cannot recover and must be shut down.\r\nThe exception details are as follows:\r\n")
580  			TEXT("Code:\t0x%08X\r\nType:\t%S\r\nException address: 0x%p"), ex.code(), ex.what(), ex.where());
581  		::MessageBox(Notepad_plus_Window::gNppHWND, message, TEXT("Win32Exception"), MB_OK | MB_ICONERROR);
582  		mdump.writeDump(ex.info());
583  		doException(notepad_plus_plus);
584  	}
585  	catch (std::exception & ex)
586  	{
587  		::MessageBoxA(Notepad_plus_Window::gNppHWND, ex.what(), "General Exception", MB_OK);
588  		doException(notepad_plus_plus);
589  	}
590  	catch (...) 
591  	{
592  		::MessageBoxA(Notepad_plus_Window::gNppHWND, "An exception that we did not yet found its name is just caught", "Unknown Exception", MB_OK);
593  		doException(notepad_plus_plus);
594  	}
595  	return static_cast<int>(msg.wParam);
596  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppNotification.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-winmain.cpp</div>
                </div>
                <div class="column column_space"><pre><code>213  					fileNamesData.dwData = COPYDATA_FILENAMESW;
214  					fileNamesData.lpData = (void *)quotFileName.c_str();
215  					fileNamesData.cbData = static_cast<DWORD>((quotFileName.length() + 1) * sizeof(TCHAR));
216  					HWND hWinParent = ::GetParent(hWin);
</pre></code></div>
                <div class="column column_space"><pre><code>465  				cmdLineData.dwData = COPYDATA_FULL_CMDLINE;
466  				cmdLineData.lpData = (void*)cmdLineString.c_str();
467  				cmdLineData.cbData = static_cast<DWORD>((cmdLineString.length() + 1) * sizeof(TCHAR));
468  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&cmdLineData));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    