
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.581267217630854%, Tokens: 16</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-city.cc</h3>
            <pre><code>1  #include "absl/hash/internal/city.h"
2  #include <string.h>  
3  #include <algorithm>
4  #include "absl/base/config.h"
5  #include "absl/base/internal/endian.h"
6  #include "absl/base/internal/unaligned_access.h"
7  #include "absl/base/optimization.h"
8  namespace absl {
9  ABSL_NAMESPACE_BEGIN
10  namespace hash_internal {
11  #ifdef ABSL_IS_BIG_ENDIAN
12  #define uint32_in_expected_order(x) (absl::gbswap_32(x))
13  #define uint64_in_expected_order(x) (absl::gbswap_64(x))
14  #else
15  #define uint32_in_expected_order(x) (x)
16  #define uint64_in_expected_order(x) (x)
17  #endif
18  static uint64_t Fetch64(const char *p) {
19    return uint64_in_expected_order(ABSL_INTERNAL_UNALIGNED_LOAD64(p));
20  }
21  static uint32_t Fetch32(const char *p) {
22    return uint32_in_expected_order(ABSL_INTERNAL_UNALIGNED_LOAD32(p));
23  }
24  static const uint64_t k0 = 0xc3a5c85c97cb3127ULL;
25  static const uint64_t k1 = 0xb492b66fbe98f273ULL;
26  static const uint64_t k2 = 0x9ae16a3b2f90404fULL;
27  static const uint32_t c1 = 0xcc9e2d51;
28  static const uint32_t c2 = 0x1b873593;
29  static uint32_t fmix(uint32_t h) {
30    h ^= h >> 16;
31    h *= 0x85ebca6b;
32    h ^= h >> 13;
33    h *= 0xc2b2ae35;
34    h ^= h >> 16;
35    return h;
36  }
37  static uint32_t Rotate32(uint32_t val, int shift) {
38    return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
39  }
40  #undef PERMUTE3
41  #define PERMUTE3(a, b, c) \
42    do {                    \
43      std::swap(a, b);      \
44      std::swap(a, c);      \
45    } while (0)
46  static uint32_t Mur(uint32_t a, uint32_t h) {
47    a *= c1;
48    a = Rotate32(a, 17);
49    a *= c2;
50    h ^= a;
51    h = Rotate32(h, 19);
52    return h * 5 + 0xe6546b64;
53  }
54  static uint32_t Hash32Len13to24(const char *s, size_t len) {
55    uint32_t a = Fetch32(s - 4 + (len >> 1));
56    uint32_t b = Fetch32(s + 4);
57    uint32_t c = Fetch32(s + len - 8);
58    uint32_t d = Fetch32(s + (len >> 1));
59    uint32_t e = Fetch32(s);
60    uint32_t f = Fetch32(s + len - 4);
61    uint32_t h = static_cast<uint32_t>(len);
62    return fmix(Mur(f, Mur(e, Mur(d, Mur(c, Mur(b, Mur(a, h)))))));
63  }
64  static uint32_t Hash32Len0to4(const char *s, size_t len) {
65    uint32_t b = 0;
66    uint32_t c = 9;
67    for (size_t i = 0; i < len; i++) {
68      signed char v = static_cast<signed char>(s[i]);
69      b = b * c1 + static_cast<uint32_t>(v);
70      c ^= b;
71    }
72    return fmix(Mur(b, Mur(static_cast<uint32_t>(len), c)));
73  }
74  static uint32_t Hash32Len5to12(const char *s, size_t len) {
75    uint32_t a = static_cast<uint32_t>(len), b = a * 5, c = 9, d = b;
76    a += Fetch32(s);
77    b += Fetch32(s + len - 4);
78    c += Fetch32(s + ((len >> 1) & 4));
79    return fmix(Mur(c, Mur(b, Mur(a, d))));
80  }
81  uint32_t CityHash32(const char *s, size_t len) {
82    if (len <= 24) {
83      return len <= 12
84                 ? (len <= 4 ? Hash32Len0to4(s, len) : Hash32Len5to12(s, len))
85                 : Hash32Len13to24(s, len);
86    }
<span onclick='openModal()' class='match'>87    uint32_t h = static_cast<uint32_t>(len), g = c1 * h, f = g;
88    uint32_t a0 = Rotate32(Fetch32(s + len - 4) * c1, 17) * c2;
89    uint32_t a1 = Rotate32(Fetch32(s + len - 8) * c1, 17) * c2;
90    uint32_t a2 = Rotate32(Fetch32(s + len - 16) * c1, 17) * c2;
91    uint32_t a3 = Rotate32(Fetch32(s + len - 12) * c1, 17) * c2;
92    uint32_t a4 = Rotate32(Fetch32(s + len - 20) * c1, 17) * c2;
93    h ^= a0;
94    h = Rotate32(h, 19);
95    h = h * 5 + 0xe6546b64;
96    h ^= a2;
97    h = Rotate32(h, 19);
98    h = h * 5 + 0xe6546b64;
99    g ^= a1;
100    g = Rotate32(g, 19);
</span>101    g = g * 5 + 0xe6546b64;
102    g ^= a3;
103    g = Rotate32(g, 19);
104    g = g * 5 + 0xe6546b64;
105    f += a4;
106    f = Rotate32(f, 19);
107    f = f * 5 + 0xe6546b64;
108    size_t iters = (len - 1) / 20;
109    do {
110      uint32_t b0 = Rotate32(Fetch32(s) * c1, 17) * c2;
111      uint32_t b1 = Fetch32(s + 4);
112      uint32_t b2 = Rotate32(Fetch32(s + 8) * c1, 17) * c2;
113      uint32_t b3 = Rotate32(Fetch32(s + 12) * c1, 17) * c2;
114      uint32_t b4 = Fetch32(s + 16);
115      h ^= b0;
116      h = Rotate32(h, 18);
117      h = h * 5 + 0xe6546b64;
118      f += b1;
119      f = Rotate32(f, 19);
120      f = f * c1;
121      g += b2;
122      g = Rotate32(g, 18);
123      g = g * 5 + 0xe6546b64;
124      h ^= b3 + b1;
125      h = Rotate32(h, 19);
126      h = h * 5 + 0xe6546b64;
127      g ^= b4;
128      g = absl::gbswap_32(g) * 5;
129      h += b4 * 5;
130      h = absl::gbswap_32(h);
131      f += b0;
132      PERMUTE3(f, h, g);
133      s += 20;
134    } while (--iters != 0);
135    g = Rotate32(g, 11) * c1;
136    g = Rotate32(g, 17) * c1;
137    f = Rotate32(f, 11) * c1;
138    f = Rotate32(f, 17) * c1;
139    h = Rotate32(h + g, 19);
140    h = h * 5 + 0xe6546b64;
141    h = Rotate32(h, 17) * c1;
142    h = Rotate32(h + f, 19);
143    h = h * 5 + 0xe6546b64;
144    h = Rotate32(h, 17) * c1;
145    return h;
146  }
147  static uint64_t Rotate(uint64_t val, int shift) {
148    return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
149  }
150  static uint64_t ShiftMix(uint64_t val) { return val ^ (val >> 47); }
151  static uint64_t HashLen16(uint64_t u, uint64_t v, uint64_t mul) {
152    uint64_t a = (u ^ v) * mul;
153    a ^= (a >> 47);
154    uint64_t b = (v ^ a) * mul;
155    b ^= (b >> 47);
156    b *= mul;
157    return b;
158  }
159  static uint64_t HashLen16(uint64_t u, uint64_t v) {
160    const uint64_t kMul = 0x9ddfea08eb382d69ULL;
161    return HashLen16(u, v, kMul);
162  }
163  static uint64_t HashLen0to16(const char *s, size_t len) {
164    if (len >= 8) {
165      uint64_t mul = k2 + len * 2;
166      uint64_t a = Fetch64(s) + k2;
167      uint64_t b = Fetch64(s + len - 8);
168      uint64_t c = Rotate(b, 37) * mul + a;
169      uint64_t d = (Rotate(a, 25) + b) * mul;
170      return HashLen16(c, d, mul);
171    }
172    if (len >= 4) {
173      uint64_t mul = k2 + len * 2;
174      uint64_t a = Fetch32(s);
175      return HashLen16(len + (a << 3), Fetch32(s + len - 4), mul);
176    }
177    if (len > 0) {
178      uint8_t a = static_cast<uint8_t>(s[0]);
179      uint8_t b = static_cast<uint8_t>(s[len >> 1]);
180      uint8_t c = static_cast<uint8_t>(s[len - 1]);
181      uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);
182      uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);
183      return ShiftMix(y * k2 ^ z * k0) * k2;
184    }
185    return k2;
186  }
187  static uint64_t HashLen17to32(const char *s, size_t len) {
188    uint64_t mul = k2 + len * 2;
189    uint64_t a = Fetch64(s) * k1;
190    uint64_t b = Fetch64(s + 8);
191    uint64_t c = Fetch64(s + len - 8) * mul;
192    uint64_t d = Fetch64(s + len - 16) * k2;
193    return HashLen16(Rotate(a + b, 43) + Rotate(c, 30) + d,
194                     a + Rotate(b + k2, 18) + c, mul);
195  }
196  static std::pair<uint64_t, uint64_t> WeakHashLen32WithSeeds(
197      uint64_t w, uint64_t x, uint64_t y, uint64_t z, uint64_t a, uint64_t b) {
198    a += w;
199    b = Rotate(b + a + z, 21);
200    uint64_t c = a;
201    a += x;
202    a += y;
203    b += Rotate(a, 44);
204    return std::make_pair(a + z, b + c);
205  }
206  static std::pair<uint64_t, uint64_t> WeakHashLen32WithSeeds(const char *s,
207                                                              uint64_t a,
208                                                              uint64_t b) {
209    return WeakHashLen32WithSeeds(Fetch64(s), Fetch64(s + 8), Fetch64(s + 16),
210                                  Fetch64(s + 24), a, b);
211  }
212  static uint64_t HashLen33to64(const char *s, size_t len) {
213    uint64_t mul = k2 + len * 2;
214    uint64_t a = Fetch64(s) * k2;
215    uint64_t b = Fetch64(s + 8);
216    uint64_t c = Fetch64(s + len - 24);
217    uint64_t d = Fetch64(s + len - 32);
218    uint64_t e = Fetch64(s + 16) * k2;
219    uint64_t f = Fetch64(s + 24) * 9;
220    uint64_t g = Fetch64(s + len - 8);
221    uint64_t h = Fetch64(s + len - 16) * mul;
222    uint64_t u = Rotate(a + g, 43) + (Rotate(b, 30) + c) * 9;
223    uint64_t v = ((a + g) ^ d) + f + 1;
224    uint64_t w = absl::gbswap_64((u + v) * mul) + h;
225    uint64_t x = Rotate(e + f, 42) + c;
226    uint64_t y = (absl::gbswap_64((v + w) * mul) + g) * mul;
227    uint64_t z = e + f + c;
228    a = absl::gbswap_64((x + z) * mul + y) + b;
229    b = ShiftMix((z + a) * mul + d + h) * mul;
230    return b + x;
231  }
232  uint64_t CityHash64(const char *s, size_t len) {
233    if (len <= 32) {
234      if (len <= 16) {
235        return HashLen0to16(s, len);
236      } else {
237        return HashLen17to32(s, len);
238      }
239    } else if (len <= 64) {
240      return HashLen33to64(s, len);
241    }
242    uint64_t x = Fetch64(s + len - 40);
243    uint64_t y = Fetch64(s + len - 16) + Fetch64(s + len - 56);
244    uint64_t z = HashLen16(Fetch64(s + len - 48) + len, Fetch64(s + len - 24));
245    std::pair<uint64_t, uint64_t> v =
246        WeakHashLen32WithSeeds(s + len - 64, len, z);
247    std::pair<uint64_t, uint64_t> w =
248        WeakHashLen32WithSeeds(s + len - 32, y + k1, x);
249    x = x * k1 + Fetch64(s);
250    len = (len - 1) & ~static_cast<size_t>(63);
251    do {
252      x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
253      y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
254      x ^= w.second;
255      y += v.first + Fetch64(s + 40);
256      z = Rotate(z + w.first, 33) * k1;
257      v = WeakHashLen32WithSeeds(s, v.second * k1, x + w.first);
258      w = WeakHashLen32WithSeeds(s + 32, z + w.second, y + Fetch64(s + 16));
259      std::swap(z, x);
260      s += 64;
261      len -= 64;
262    } while (len != 0);
263    return HashLen16(HashLen16(v.first, w.first) + ShiftMix(y) * k1 + z,
264                     HashLen16(v.second, w.second) + x);
265  }
266  uint64_t CityHash64WithSeed(const char *s, size_t len, uint64_t seed) {
267    return CityHash64WithSeeds(s, len, k2, seed);
268  }
269  uint64_t CityHash64WithSeeds(const char *s, size_t len, uint64_t seed0,
270                               uint64_t seed1) {
271    return HashLen16(CityHash64(s, len) - seed0, seed1);
272  }
273  }  
274  ABSL_NAMESPACE_END
275  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</h3>
            <pre><code>1  #include "vizmapgks.h"
2  #include <gkswf.h>
<span onclick='openModal()' class='match'>3  TGksColor TVizMapContext::ColorLandscapeAbove = TGksColor(54, 92, 120);
4  TGksColor TVizMapContext::ColorAddFirstLevel = TGksColor(9, 7, 6);
5  TGksColor TVizMapContext::ColorAddSecondLevel = TGksColor(18, 14, 12);
6  TGksColor TVizMapContext::ColorLegendGridColor = TGksColor(192, 255, 255, 255);
7  TGksColor TVizMapContext::ColorPointCross = TGksColor(255, 220, 0);
8  TGksColor TVizMapContext::ColorSelPointCross = TGksColor(255, 145, 145);
9  TGksColor TVizMapContext::ColorPointFont = TGksColor(255, 220, 0);
10  TGksColor TVizMapContext::ColorSelPointFont = TGksColor(255, 255, 30);
11  TGksColor TVizMapContext::ColorLink = TGksColor(100, 100, 255, 100);
12  TGksColor TVizMapContext::ColorKeyWdFont = TGksColor(240,240,255);
13  TGksColor TVizMapContext::ColorCatNmFont = TGksColor(255,240,255);
14  TGksColor TVizMapContext::ColorZoomRect = TGksColor(100, 0, 0, 0); 
15  TGksColor TVizMapContext::ColorMgGlass = TGksColor(50, 0, 0, 0);
16  TGksColor TVizMapContext::ColorMgGlassWnd = TGksColor(192, 255, 255, 255);
17  TGksColor TVizMapContext::ColorMgGlassWndFrm = TGksColor(100, 0, 0, 0); 
18  TGksColor TVizMapContext::ColorMgGlassWndShadow = TGksColor(50, 0, 0, 0);
</span>19  int TVizMapContext::SizePointCross = 2;
20  int TVizMapContext::PointNmWidth = 100;
21  int TVizMapContext::PointNmMxLines = 3;
22  double TVizMapContext::PointNmFontScale = 20.0;
23  int TVizMapContext::MgGlassWindowWidth = 150;
24  int TVizMapContext::RndKeyWdN = 3000;
25  double TVizMapContext::RelRadius = 0.2;
26  int TVizMapContext::KeyWdCandidates = 10;
27  double TVizMapContext::RelMnRptDist = 0.1;
28  double TVizMapContext::RelSparsity = 0.05;
29  void TVizMapContext::LoadColor() {
30      LandscapeCatColorV.Clr();
31      LandscapeCatColorV.Add(TGksColor(43, 76, 115));
32      LandscapeCatColorV.Add(TGksColor(53, 46, 115));
33      LandscapeCatColorV.Add(TGksColor(33, 106, 115));
34      LandscapeCatColorV.Add(TGksColor(63, 80, 170));
35      LandscapeCatColorV.Add(TGksColor(61, 106, 200));
36      LandscapeCatColorV.Add(TGksColor(71, 106, 190));
37      LandscapeCatColorV.Add(TGksColor(51, 106, 210));
38      LandscapeCatColorV.Add(TGksColor(81, 106, 180));
39      LandscapeCatColorV.Add(TGksColor(43, 91, 125));
40      LandscapeCatColorV.Add(TGksColor(43, 91, 135));
41      LandscapeCatColorV.Add(TGksColor(43, 91, 145));
42      LandscapeCatColorV.Add(TGksColor(43, 91, 155));
43      LandscapeCatColorV.Add(TGksColor(43, 106, 125));
44      LandscapeCatColorV.Add(TGksColor(43, 106, 135));
45      LandscapeCatColorV.Add(TGksColor(43, 106, 145));
46      LandscapeCatColorV.Add(TGksColor(43, 106, 155));
47  }
48  void TVizMapContext::LoadCatFullNms() {
49      CatFullNmH.AddDat("1POL", "CURRENT NEWS - POLITICS");
50      CatFullNmH.AddDat("2ECO", "CURRENT NEWS - ECONOMICS");
51      CatFullNmH.AddDat("3SPO", "CURRENT NEWS - SPORT");
52      CatFullNmH.AddDat("4GEN", "CURRENT NEWS - GENERAL");
53      CatFullNmH.AddDat("6INS", "CURRENT NEWS - INSURANCE");
54      CatFullNmH.AddDat("7RSK", "CURRENT NEWS - RISK NEWS");
55      CatFullNmH.AddDat("8YDB", "TEMPORARY");
56      CatFullNmH.AddDat("9BNX", "TEMPORARY");
57      CatFullNmH.AddDat("ADS10", "CURRENT NEWS - ADVERTISING");
58      CatFullNmH.AddDat("BNW14", "CURRENT NEWS - BUSINESS NEWS");
59      CatFullNmH.AddDat("BRP11", "CURRENT NEWS - BRANDS");
60      CatFullNmH.AddDat("C11", "STRATEGY/PLANS");
61      CatFullNmH.AddDat("C12", "LEGAL/JUDICIAL");
62      CatFullNmH.AddDat("C13", "REGULATION/POLICY");
63      CatFullNmH.AddDat("C14", "SHARE LISTINGS");
64      CatFullNmH.AddDat("C15", "PERFORMANCE");
65      CatFullNmH.AddDat("C151", "ACCOUNTS/EARNINGS");
66      CatFullNmH.AddDat("C1511", "ANNUAL RESULTS");
67      CatFullNmH.AddDat("C152", "COMMENT/FORECASTS");
68      CatFullNmH.AddDat("C16", "INSOLVENCY/LIQUIDITY");
69      CatFullNmH.AddDat("C17", "FUNDING/CAPITAL");
70      CatFullNmH.AddDat("C171", "SHARE CAPITAL");
71      CatFullNmH.AddDat("C172", "BONDS/DEBT ISSUES");
72      CatFullNmH.AddDat("C173", "LOANS/CREDITS");
73      CatFullNmH.AddDat("C174", "CREDIT RATINGS");
74      CatFullNmH.AddDat("C18", "OWNERSHIP CHANGES");
75      CatFullNmH.AddDat("C181", "MERGERS/ACQUISITIONS");
76      CatFullNmH.AddDat("C182", "ASSET TRANSFERS");
77      CatFullNmH.AddDat("C183", "PRIVATISATIONS");
78      CatFullNmH.AddDat("C21", "PRODUCTION/SERVICES");
79      CatFullNmH.AddDat("C22", "NEW PRODUCTS/SERVICES");
80      CatFullNmH.AddDat("C23", "RESEARCH/DEVELOPMENT");
81      CatFullNmH.AddDat("C24", "CAPACITY/FACILITIES");
82      CatFullNmH.AddDat("C31", "MARKETS/MARKETING");
83      CatFullNmH.AddDat("C311", "DOMESTIC MARKETS");
84      CatFullNmH.AddDat("C312", "EXTERNAL MARKETS");
85      CatFullNmH.AddDat("C313", "MARKET SHARE");
86      CatFullNmH.AddDat("C32", "ADVERTISING/PROMOTION");
87      CatFullNmH.AddDat("C33", "CONTRACTS/ORDERS");
88      CatFullNmH.AddDat("C331", "DEFENCE CONTRACTS");
89      CatFullNmH.AddDat("C34", "MONOPOLIES/COMPETITION");
90      CatFullNmH.AddDat("C41", "MANAGEMENT");
91      CatFullNmH.AddDat("C411", "MANAGEMENT MOVES");
92      CatFullNmH.AddDat("C42", "LABOUR");
93      CatFullNmH.AddDat("CCAT", "CORPORATE/INDUSTRIAL");
94      CatFullNmH.AddDat("E11", "ECONOMIC PERFORMANCE");
95      CatFullNmH.AddDat("E12", "MONETARY/ECONOMIC");
96      CatFullNmH.AddDat("E121", "MONEY SUPPLY");
97      CatFullNmH.AddDat("E13", "INFLATION/PRICES");
98      CatFullNmH.AddDat("E131", "CONSUMER PRICES");
99      CatFullNmH.AddDat("E132", "WHOLESALE PRICES");
100      CatFullNmH.AddDat("E14", "CONSUMER FINANCE");
101      CatFullNmH.AddDat("E141", "PERSONAL INCOME");
102      CatFullNmH.AddDat("E142", "CONSUMER CREDIT");
103      CatFullNmH.AddDat("E143", "RETAIL SALES");
104      CatFullNmH.AddDat("E21", "GOVERNMENT FINANCE");
105      CatFullNmH.AddDat("E211", "EXPENDITURE/REVENUE");
106      CatFullNmH.AddDat("E212", "GOVERNMENT BORROWING");
107      CatFullNmH.AddDat("E31", "OUTPUT/CAPACITY");
108      CatFullNmH.AddDat("E311", "INDUSTRIAL PRODUCTION");
109      CatFullNmH.AddDat("E312", "CAPACITY UTILIZATION");
110      CatFullNmH.AddDat("E313", "INVENTORIES");
111      CatFullNmH.AddDat("E41", "EMPLOYMENT/LABOUR");
112      CatFullNmH.AddDat("E411", "UNEMPLOYMENT");
113      CatFullNmH.AddDat("E51", "TRADE/RESERVES");
114      CatFullNmH.AddDat("E511", "BALANCE OF PAYMENTS");
115      CatFullNmH.AddDat("E512", "MERCHANDISE TRADE");
116      CatFullNmH.AddDat("E513", "RESERVES");
117      CatFullNmH.AddDat("E61", "HOUSING STARTS");
118      CatFullNmH.AddDat("E71", "LEADING INDICATORS");
119      CatFullNmH.AddDat("ECAT", "ECONOMICS");
120      CatFullNmH.AddDat("ENT12", "CURRENT NEWS - ENTERTAINMENT");
121      CatFullNmH.AddDat("G11", "SOCIAL AFFAIRS");
122      CatFullNmH.AddDat("G111", "HEALTH/SAFETY");
123      CatFullNmH.AddDat("G112", "SOCIAL SECURITY");
124      CatFullNmH.AddDat("G113", "EDUCATION/RESEARCH");
125      CatFullNmH.AddDat("G12", "INTERNAL POLITICS");
126      CatFullNmH.AddDat("G13", "INTERNATIONAL RELATIONS");
127      CatFullNmH.AddDat("G131", "DEFENCE");
128      CatFullNmH.AddDat("G14", "ENVIRONMENT");
129      CatFullNmH.AddDat("G15", "EUROPEAN COMMUNITY");
130      CatFullNmH.AddDat("G151", "EC INTERNAL MARKET");
131      CatFullNmH.AddDat("G152", "EC CORPORATE POLICY");
132      CatFullNmH.AddDat("G153", "EC AGRICULTURE POLICY");
133      CatFullNmH.AddDat("G154", "EC MONETARY/ECONOMIC");
134      CatFullNmH.AddDat("G155", "EC INSTITUTIONS");
135      CatFullNmH.AddDat("G156", "EC ENVIRONMENT ISSUES");
136      CatFullNmH.AddDat("G157", "EC COMPETITION/SUBSIDY");
137      CatFullNmH.AddDat("G158", "EC EXTERNAL RELATIONS");
138      CatFullNmH.AddDat("G159", "EC GENERAL");
139      CatFullNmH.AddDat("GCAT", "GOVERNMENT/SOCIAL");
140      CatFullNmH.AddDat("GCRIM", "CRIME, LAW ENFORCEMENT");
141      CatFullNmH.AddDat("GDEF", "DEFENCE");
142      CatFullNmH.AddDat("GDIP", "INTERNATIONAL RELATIONS");
143      CatFullNmH.AddDat("GDIS", "DISASTERS AND ACCIDENTS");
144      CatFullNmH.AddDat("GEDU", "EDUCATION");
145      CatFullNmH.AddDat("GENT", "ARTS, CULTURE, ENTERTAINMENT");
146      CatFullNmH.AddDat("GENV", "ENVIRONMENT AND NATURAL WORLD");
147      CatFullNmH.AddDat("GFAS", "FASHION");
148      CatFullNmH.AddDat("GHEA", "HEALTH");
149      CatFullNmH.AddDat("GJOB", "LABOUR ISSUES");
150      CatFullNmH.AddDat("GMIL", "MILLENNIUM ISSUES");
151      CatFullNmH.AddDat("GOBIT", "OBITUARIES");
152      CatFullNmH.AddDat("GODD", "HUMAN INTEREST");
153      CatFullNmH.AddDat("GPOL", "DOMESTIC POLITICS");
154      CatFullNmH.AddDat("GPRO", "BIOGRAPHIES, PERSONALITIES, PEOPLE");
155      CatFullNmH.AddDat("GREL", "RELIGION");
156      CatFullNmH.AddDat("GSCI", "SCIENCE AND TECHNOLOGY");
157      CatFullNmH.AddDat("GSPO", "SPORTS");
158      CatFullNmH.AddDat("GTOUR", "TRAVEL AND TOURISM");
159      CatFullNmH.AddDat("GVIO", "WAR, CIVIL WAR");
160      CatFullNmH.AddDat("GVOTE", "ELECTIONS");
161      CatFullNmH.AddDat("GWEA", "WEATHER");
162      CatFullNmH.AddDat("GWELF", "WELFARE, SOCIAL SERVICES");
163      CatFullNmH.AddDat("M11", "EQUITY MARKETS");
164      CatFullNmH.AddDat("M12", "BOND MARKETS");
165      CatFullNmH.AddDat("M13", "MONEY MARKETS");
166      CatFullNmH.AddDat("M131", "INTERBANK MARKETS");
167      CatFullNmH.AddDat("M132", "FOREX MARKETS");
168      CatFullNmH.AddDat("M14", "COMMODITY MARKETS");
169      CatFullNmH.AddDat("M141", "SOFT COMMODITIES");
170      CatFullNmH.AddDat("M142", "METALS TRADING");
171      CatFullNmH.AddDat("M143", "ENERGY MARKETS");
172      CatFullNmH.AddDat("MCAT", "MARKETS");
173      CatFullNmH.AddDat("MEUR", "EURO CURRENCY");
174      CatFullNmH.AddDat("PRB13", "CURRENT NEWS - PRESS RELEASE WIRES");
175  }
176  TFltRect TVizMapContext::GetZoomRect() {
177      if (!ZoomS.Empty()) {
178          return ZoomS.Top();
179      } else {
180          return TFltRect(0.0, 0.0, 1.0, 1.0);
181      }
182  }
183  void TVizMapContext::RenderLandscapeBmp() {
184      if (SelLandscape.Empty()) return;
185      TFltRect ZoomRect = GetZoomRect();
186      const int MaxWidth = SelLandscape->GetXDim();
187      const int MaxHeight = SelLandscape->GetYDim();
188      const int Width = TFlt::Round(ZoomRect.GetXLen()*MaxWidth);
189      const int Height = TFlt::Round(ZoomRect.GetYLen()*MaxHeight);
190      const int LeftX = TFlt::Round(ZoomRect.GetMnX()*MaxWidth);
191      const int TopY = TFlt::Round(ZoomRect.GetMnY()*MaxHeight);
192      if (Width > 0 && Height > 0) {        
193          const TSFltVV& HeightVV = SelLandscape->HeightVV();
194              Assert(SelLandscape->GetLevels() == 2);
195              const double First = SelLandscape->GetLevel(0);
196              const double Second = SelLandscape->GetLevel(1);
197              LandscapeBmp = TGksBitmap::New(Width, Height, ColorLandscapeAbove);
198              for (int X = 0; X < Width; X++) {
199                  for (int Y = 0; Y < Height; Y++) {
200                      double Val = HeightVV(LeftX+X, TopY+Y);
201                      if (Val > Second) { Val = Second + 3*(Val - Second); }
202                      TGksColor PixelColor = ColorLandscapeAbove.Add(
203                          TFlt::Round(Val*34), TFlt::Round(Val*28), TFlt::Round(Val*24));
204                      if (Val > Second) { PixelColor = PixelColor.Add(ColorAddSecondLevel); } 
205                      if (Val > First) { PixelColor = PixelColor.Add(ColorAddFirstLevel); }
206                      LandscapeBmp->SetPixel(X, Y, PixelColor);
207                  }
208              }
209      } else {
210          LandscapeBmp = TGksBitmap::New(1, 1, ColorLandscapeAbove);
211      }
212  }
213  void TVizMapContext::ResetMgGlassSize() { 
214      TFltRect ZoomRect = GetZoomRect();
215      MgGlassSize = 0.2 * TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen()); 
216  }
217  void TVizMapContext::ResetMgGlassKeyWd(const int& MgGlassKeyWds) {
218      MgGlassPoints = VizMapFrame->GenKeyWd(TFltV::GetV(MouseX, MouseY), 
219          MgGlassSize, MgGlassKeyWds, MgGlassKeyWdV, false, false);
220  }
221  void TVizMapContext::ResetKeyWd() {
222      TFltRect ZoomRect = GetZoomRect();
223      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
224      const double Radius = RelRadius * MnZoomRectSize; 
225      VizMapFrame->GenKeyWds(RndKeyWdN, Radius, KeyWdCandidates, 0, ZoomRect); 
226  }
227  void TVizMapContext::ResetNearPointN() {
228      double MnDist = TFlt::Mx;
229      NearPointN = -1;
230      int Points = VizMapFrame->GetPoints();
231      for (int PointN = 0; PointN < Points; PointN++) {
232          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
233          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
234          const double Dist = TMath::Sqr(PointX - MouseX) + 
235              TMath::Sqr(PointY - MouseY);
236          if (Dist < MnDist) { MnDist = Dist; NearPointN = PointN; }
237      }
238      if (TMath::Sqrt(MnDist) > 0.1) { NearPointN = -1; }
239  }
240  inline double TVizMapContext::GetMapCoord(const int& ScreenCoord, 
241          const int& ScreenLen, const double& MapMn, const double& MapLen) {
242      return MapMn + MapLen*(double(ScreenCoord)/double(ScreenLen));
243  }
244  inline int TVizMapContext::GetScreenCoord(const double& MapCoord, const double& MapMn, 
245          const double& MapLen, const int& ScreenLen) {
246      return TFlt::Round(ScreenLen * ((MapCoord - MapMn)/MapLen));
247  }
248  int TVizMapContext::GetEncoderClsid(const TStr& EncoderType, CLSID* pClsid) {
249      const int StrLen = EncoderType.Len() + 1;
250      WCHAR* format = new WCHAR[StrLen];
251      const int Res = MultiByteToWideChar(CP_ACP, 0, 
252          EncoderType.CStr(), StrLen, format, StrLen);
253      UINT  num = 0;          
254      UINT  size = 0;         
255      Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;
256      Gdiplus::GetImageEncodersSize(&num, &size);
257      if (size == 0) { return -1; } 
258      pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
259      if(pImageCodecInfo == NULL) { return -1; } 
260      Gdiplus::GetImageEncoders(num, size, pImageCodecInfo);
261      for(UINT j = 0; j < num; ++j) {
262          if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
263              *pClsid = pImageCodecInfo[j].Clsid;
264              free(pImageCodecInfo);
265              return j;  
266          }    
267      }
268      free(pImageCodecInfo);
269      return -1;  
270  }
271  void TVizMapContext::ResetFrame() {
272      if (VizMapFrame->GetLandscapes() > 0) {
273          SelLandscape = VizMapFrame->GetLandscape(0); 
274          RenderLandscapeBmp();
275      }
276      ResetKeyWd(); SelPointV.Clr();
277  }
278  TVizMapContext::TVizMapContext(PVizMap _VizMap): 
279          VizMap(_VizMap), VizMapFrameN(0),
280          VizMapFrame(_VizMap->GetFirst()), SelMode(vmsmZoom), 
281          MgGlassPoints(0), MouseInP(false), LeftButtonDownP(false), 
282          MgGlassSize(0.2), NearPointN(-1) { 
283      LoadColor();
284      LoadCatFullNms();
285      ResetFrame();
286  }
287  void TVizMapContext::SetVizMapFrame(const int& NewVizMapFrameN) {
288      VizMapFrameN = NewVizMapFrameN;
289      VizMapFrame = VizMap->GetVizMapFrame(VizMapFrameN);
290      ResetFrame();
291  }
292  void TVizMapContext::SaveVrml(const TStr& VrmlFNm, bool ShowPointNmP, bool ShowKeyWdP) {    
293      VizMapFrame->SaveVrml(VrmlFNm, SelLandscape, ShowPointNmP, !ShowPointNmP,  ShowKeyWdP);
294  }
295  void TVizMapContext::PaintEmpty(PGks Gks) {
296      Gks->SetBrush(TGksBrush::New(ColorLandscapeAbove));
297      Gks->FillRect(-1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
298  }
299  void TVizMapContext::Paint(PGks Gks, const bool& ShowPointNmP, const int& PointFontSize,
300          const int& PointNmFontScale, const double& PointWgtThreshold, const int& CatId,
301          const bool& ShowCatNmP, const bool& ShowKeyWdP, const int& KeyWdFontSize, 
302          const bool& ShowMgGlassP, const int& LegendGridWidth, const int& LegendGridHeight) {
303      if (!SelLandscape.Empty()) { PaintLandscape(Gks); } 
304      else { PaintEmpty(Gks); }
305      PaintLegendGrid(Gks, LegendGridWidth, LegendGridHeight);
306      PaintLinks(Gks);
307      TVec<TFltRect> PointNmRectV;
308      if (ShowPointNmP) { 
309          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
310              PointWgtThreshold, CatId, ShowMgGlassP, PointNmRectV); 
311      } else { 
312          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
313              TFlt::Mx, CatId, ShowMgGlassP, PointNmRectV); 
314      }
315      if (ShowCatNmP && !SelLandscape.Empty()) { 
316          PaintCatNms(Gks, KeyWdFontSize, PointNmRectV); };
317      if (ShowKeyWdP) { PaintKeyWds(Gks, KeyWdFontSize, PointNmRectV); }
318      if (LeftButtonDownP) { PaintZoomRect(Gks); }
319      else if (MouseInP && ShowMgGlassP) { PaintMgGlass(Gks, KeyWdFontSize); }
320  }
321  void TVizMapContext::PaintLandscape(PGks Gks){
322      Gks->Bitmap(LandscapeBmp, -1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
323  }
324  void TVizMapContext::PaintLegendGrid(PGks Gks, 
325          const int& LegendGridWidth, const int& LegendGridHeight) {
326      Gks->SetPen(TGksPen::New(ColorLegendGridColor));
327      for (int LineN = 1; LineN < LegendGridWidth; LineN++) {
328          const double RelativeWidth = double(LineN) / double(LegendGridWidth);
329          const int X = TFlt::Round(RelativeWidth * Gks->GetWidth());
330          Gks->Line(X, -1, X, Gks->GetHeight());
331      }
332      for (int LineN = 1; LineN < LegendGridHeight; LineN++) {
333          const double RelativeHeight = double(LineN) / double(LegendGridHeight);
334          const int Y = TFlt::Round(RelativeHeight * Gks->GetHeight());
335          Gks->Line(-1, Y, Gks->GetWidth(), Y);
336      }
337  }
338  void TVizMapContext::PaintLinks(PGks Gks) {
339      int Links = VizMapFrame->GetLinks();
340      TFltRect ZoomRect = GetZoomRect();
341      for (int LinkN = 0; LinkN < Links; LinkN++) {
342          PVizMapLink Link = VizMapFrame->GetLink(LinkN);
343          PVizMapPoint SrcPoint = VizMapFrame->GetPoint(Link->GetSrcPointN());
344          PVizMapPoint DstPoint = VizMapFrame->GetPoint(Link->GetDstPointN());
345          const double SrcPointX = SrcPoint->GetPointX(), SrcPointY = SrcPoint->GetPointY();
346          const double DstPointX = DstPoint->GetPointX(), DstPointY = DstPoint->GetPointY();
347          const int SrcX = GetScreenCoord(SrcPointX, ZoomRect.GetMnX(), 
348              ZoomRect.GetXLen(), Gks->GetWidth());
349          const int SrcY = GetScreenCoord(SrcPointY, ZoomRect.GetMnY(), 
350              ZoomRect.GetYLen(), Gks->GetHeight());
351          const int DstX = GetScreenCoord(DstPointX, ZoomRect.GetMnX(), 
352              ZoomRect.GetXLen(), Gks->GetWidth());
353          const int DstY = GetScreenCoord(DstPointY, ZoomRect.GetMnY(), 
354              ZoomRect.GetYLen(), Gks->GetHeight());
355          PaintArrow(Gks, SrcX, SrcY, DstX, DstY, 3);
356      }
357  }
358  void TVizMapContext::PaintArrow(PGks Gks, const int& SrcX, const int& SrcY, 
359          const int& DstX, const int& DstY, const int& Width) {
360      Gks->SetPen(TGksPen::New(ColorLink, gpmCopy, gpsSolid, Width));
361      Gks->Line(SrcX, SrcY, DstX, DstY);
362      TFltV DirectionV = TFltV::GetV(DstX - SrcX, DstY - SrcY); 
363      TLinAlg::Normalize(DirectionV);
364      const int HeadSize = TFlt::Round(2.5*Width); 
365      const double AngleRad = 0.75*TMath::Pi;
366      const int dX1 = TFlt::Round(HeadSize*DirectionV[0]);
367      const int dY1 = TFlt::Round(HeadSize*DirectionV[1]);
368      double dxx, dyy;
369      TLinAlg::Rotate(DirectionV[0], DirectionV[1], AngleRad, dxx, dyy);
370      const int dX2 = TFlt::Round(HeadSize*dxx);
371      const int dY2 = TFlt::Round(HeadSize*dyy);
372      TLinAlg::Rotate(DirectionV[0], DirectionV[1], -AngleRad, dxx, dyy);
373      const int dX3 = TFlt::Round(HeadSize*dxx);
374      const int dY3 = TFlt::Round(HeadSize*dyy);
375      TGksSPointV HeadPointV(3, 0);
376      HeadPointV.Add(TGksSPoint(DstX, DstY));
377      HeadPointV.Add(TGksSPoint(DstX-dX1+dX2, DstY-dY1+dY2));
378      HeadPointV.Add(TGksSPoint(DstX-dX1+dX3, DstY-dY1+dY3)); 
379      Gks->SetBrush(TGksBrush::New(ColorLink));
380      Gks->Polygon(HeadPointV);
381  }
382  void TVizMapContext::PaintPoints(PGks Gks, const int& PointFontSize, 
383          const int& PointNmFontScale, const double& PointWgtThreshold, 
384          const int& CatId, const bool& ShowMgGlassP,
385          TVec<TFltRect>& PointNmRectV) {
386      int Points = VizMapFrame->GetPoints();
387      TFltRect ZoomRect = GetZoomRect();
388      for (int PointN = 0; PointN < Points; PointN++) {
389          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
390          bool IsSelPointP = SelPointV.IsInBin(PointN);
391          if (IsSelPointP || ((NearPointN == PointN) && !ShowMgGlassP)) { continue; }
392          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
393          if (ZoomRect.IsXYIn(PointX, PointY)) {
394              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
395                  ZoomRect.GetXLen(), Gks->GetWidth());
396              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
397                  ZoomRect.GetYLen(), Gks->GetHeight());
398              bool IsCatP = Point->IsCatId(CatId);
399              if (Point->IsPointNm() && 
400                  ((Point->GetWgt() > PointWgtThreshold) || IsSelPointP)) {
401                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
402                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
403              } else {
404                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
405              }
406          }
407      }
408      for (int SelPointN = 0; SelPointN < SelPointV.Len(); SelPointN++) {
409          const int PointN = SelPointV[SelPointN];
410          if ((NearPointN == PointN) && !ShowMgGlassP) { continue; }
411          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
412          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
413          if (ZoomRect.IsXYIn(PointX, PointY)) {
414              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
415                  ZoomRect.GetXLen(), Gks->GetWidth());
416              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
417                  ZoomRect.GetYLen(), Gks->GetHeight());
418              bool IsCatP = Point->IsCatId(CatId);
419              if (Point->IsPointNm()) {
420                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
421                      PointFontSize, PointNmFontScale, true, IsCatP));
422              } else {
423                  PaintPointCross(Gks, X, Y, true, IsCatP);
424              }
425          }
426      }
427      if (!ShowMgGlassP && (NearPointN != -1)) {
428          PVizMapPoint Point = VizMapFrame->GetPoint(NearPointN);
429          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
430          if (ZoomRect.IsXYIn(PointX, PointY)) {
431              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
432                  ZoomRect.GetXLen(), Gks->GetWidth());
433              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
434                  ZoomRect.GetYLen(), Gks->GetHeight());
435              bool IsCatP = Point->IsCatId(CatId);
436              bool IsSelPointP = SelPointV.IsInBin(NearPointN);
437              if (Point->IsPointNm()) {
438                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
439                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
440              } else {
441                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
442              }
443          }
444      }
445  }
446  void TVizMapContext::PaintPointCross(PGks Gks, const int& X, 
447          const int& Y, const bool& SelPointP, const bool& IsCatP) {
448      Gks->SetPen(TGksPen::New(SelPointP ? ColorSelPointCross : ColorPointCross));
449      Gks->Line(X - SizePointCross, Y - SizePointCross, 
450                X + SizePointCross, Y + SizePointCross);
451      Gks->Line(X - SizePointCross, Y + SizePointCross, 
452                X + SizePointCross, Y - SizePointCross);
453      if (IsCatP) {
454          Gks->Line(X - SizePointCross + 1, Y - SizePointCross, 
455                    X + SizePointCross + 1, Y + SizePointCross);
456          Gks->Line(X - SizePointCross + 1, Y + SizePointCross, 
457                    X + SizePointCross + 1, Y - SizePointCross);
458      }
459  }
460  TFltRect TVizMapContext::PaintPointNm(PGks Gks, PVizMapPoint Point, const int& X, 
461          const int& Y, const int& PointFontSize, const int& PointNmFontScale, 
462          const bool& SelPointP, const bool& IsCatP) {
463      TStr PointNm = Point->GetPointNm(); 
464      PointNm.ChangeChAll('_', ' ');
465      if (PointNm.IsStrIn("[[")) {
466          const int StartPos = PointNm.SearchStr("[[");
467          PointNm = PointNm.Left(StartPos - 1);
468      }
469      TGksColor FontColor = SelPointP ? ColorSelPointFont : ColorPointFont;
470      const int FontSize = PointFontSize + TFlt::Round(Point->GetWgt()*PointNmFontScale);
471      Gks->SetFont(TGksFont::New("ARIAL", FontSize, FontColor));
472      TStr ScreenPointNm = Gks->BreakTxt(PointNm, " ", "", PointNmWidth, PointNmMxLines);
473      const int HalfTxtWidth = Gks->GetTxtWidth(ScreenPointNm) / 2;
474      const int HalfTxtHeight = Gks->GetTxtHeight(ScreenPointNm) / 2;
475      const int MnX = X - HalfTxtWidth;
476      int CurrY = Y - HalfTxtHeight;
477      TStrV LineV; ScreenPointNm.SplitOnAllCh('\n', LineV);
478      for (int LineN = 0; LineN < LineV.Len(); LineN++) {
479          const int HalfLineWidth = Gks->GetTxtWidth(LineV[LineN]) / 2;
480          const int LineHeight = Gks->GetTxtHeight(LineV[LineN]);
481          Gks->PutTxt(LineV[LineN], MnX + (HalfTxtWidth - HalfLineWidth), CurrY);
482          CurrY += LineHeight-3;
483      }
484      return TFltRect(X - HalfTxtWidth, Y - HalfTxtHeight,
485          X + HalfTxtWidth, Y + HalfTxtHeight - LineV.Len()*3);
486  }
487  void TVizMapContext::PaintCatNms(PGks Gks, const int& KeyWdFontSize, 
488          TVec<TFltRect>& PointNmRectV) {
489      TIntH CatH; TIntFltPrH CatPosH;
490      PBowDocBs BowDocBs = VizMapFrame->GetKeyWdBow();
491      const int Points = VizMapFrame->GetPoints();
492      for (int PointN = 0; PointN < Points; PointN++) {
493          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
494          const int DId = Point->GetDocId();
495          const int CIds = BowDocBs->GetDocCIds(DId);
496          for (int CIdN = 0; CIdN < CIds; CIdN++) {
497              const int CId = BowDocBs->GetDocCId(DId, CIdN);
498              CatH.AddDat(CId)++;
499              CatPosH.AddDat(CId).Val1 += Point->GetPointX();
500              CatPosH.AddDat(CId).Val2 += Point->GetPointY();
501          }
502      }
503      CatH.SortByDat(false); 
504      const int TopCats = Points > 100 ? 6 : 4; 
505      TFltRect ZoomRect = GetZoomRect();    
506      Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize + 3, ColorCatNmFont));
507      TVec<TFltRect> CatNmRectV; TVec<TFltV> CatNmPosV;
508      const int MnSize = TInt::GetMn(Gks->GetWidth(), Gks->GetHeight());
509      const int MnDist = TFlt::Round(0.3 * double(MnSize));
510      int Cats = 0, CatKeyId = CatH.FFirstKeyId();
511      while (CatH.FNextKeyId(CatKeyId)) {
512          if (Cats == TopCats) { break; } 
513          if (double(CatH[CatKeyId]) / double(Points) < 0.05) { break; } 
514          const int CId = CatH.GetKey(CatKeyId);
515          TStr CatNm = BowDocBs->GetCatNm(CId);
516          if (CatFullNmH.IsKey(CatNm)) {
517              CatNm = CatFullNmH.GetDat(CatNm);
518          } else { continue; }
519          TFltPr CatPos = CatPosH.GetDat(CId);
520          const int CatCount = CatH.GetDat(CId); IAssert(CatCount > 0);
521          const double CatX = CatPos.Val1 / double(CatCount);
522          const double CatY = CatPos.Val2 / double(CatCount);
523          if (!ZoomRect.IsXYIn(CatX, CatY)) { continue; }
524          const int HalfTxtWidth = Gks->GetTxtWidth(CatNm) / 2;
525          const int HalfTxtHeight = Gks->GetTxtHeight(CatNm) / 2;
526          const int X = GetScreenCoord(CatX , ZoomRect.GetMnX(), 
527              ZoomRect.GetXLen(), Gks->GetWidth());
528          const int Y = GetScreenCoord(CatY, ZoomRect.GetMnY(), 
529              ZoomRect.GetYLen(), Gks->GetHeight());
530          int CatNmDist = MnSize; TFltV CatNmPos = TFltV::GetV(double(X), double(Y));
531          for (int CatNmPosN = 0; CatNmPosN < CatNmPosV.Len(); CatNmPosN++) {
532              const double Dist = TLinAlg::EuclDist(CatNmPosV[CatNmPosN], CatNmPos);
533              CatNmDist = TInt::GetMn(TFlt::Round(Dist), CatNmDist);
534          }
535          if (CatNmDist < MnDist) { continue; }
536          TFltRect CatNmRect(X - HalfTxtWidth, Y - HalfTxtHeight,
537              X + HalfTxtWidth, Y + HalfTxtHeight);
538          bool DoDraw = true; const int Rects = CatNmRectV.Len();
539          for (int RectN = 0; (RectN < Rects) && DoDraw; RectN++) {
540              DoDraw = !TFltRect::Intersection(CatNmRect, CatNmRectV[RectN]); }
541          if (!DoDraw) { continue; }
542          Gks->PutTxt(CatNm, X - HalfTxtWidth, Y - HalfTxtHeight); 
543          CatNmRectV.Add(CatNmRect); Cats++;
544          CatNmPosV.Add(CatNmPos);
545      }
546      PointNmRectV.AddV(CatNmRectV);
547  }
548  void TVizMapContext::PaintKeyWds(PGks Gks, const int& KeyWdFontSize, 
549          TVec<TFltRect>& PointNmRectV) {
550      Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize, ColorKeyWdFont));
551      TFltRect ZoomRect = GetZoomRect();    
552      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
553      const double MnRptDist = RelMnRptDist * MnZoomRectSize;
554      const double Sparsity = RelSparsity * MnZoomRectSize;
555      TVizMapKeyWdV OkKeyWdV;
556      int KeyWds = VizMapFrame->GetKeyWds();
557      for (int KeyWdN = 0; KeyWdN < KeyWds; KeyWdN++) {
558          PVizMapKeyWd KeyWd = VizMapFrame->GetKeyWd(KeyWdN);
559          TStr KeyWdStr = KeyWd->GetKeyWdStr().GetLc();
560          const double KeyWdX = KeyWd->GetKeyWdX();
561          const double KeyWdY = KeyWd->GetKeyWdY();
562          if (ZoomRect.IsXYIn(KeyWdX, KeyWdY)) {
563              const int X = GetScreenCoord(KeyWdX, ZoomRect.GetMnX(), 
564                  ZoomRect.GetXLen(), Gks->GetWidth());
565              const int Y = GetScreenCoord(KeyWdY, ZoomRect.GetMnY(), 
566                  ZoomRect.GetYLen(), Gks->GetHeight());
567              const int HalfTxtWidth = Gks->GetTxtWidth(KeyWdStr) / 2;
568              const int HalfTxtHeight = Gks->GetTxtHeight(KeyWdStr) / 2;
569              TFltRect KeyWdRect(X - HalfTxtWidth, Y - HalfTxtHeight,
570                  X + HalfTxtWidth, Y + HalfTxtHeight);
571              bool DoDrawP = true; const int Rects = PointNmRectV.Len();
572              for (int RectN = 0; RectN < Rects; RectN++) {
573                  if (TFltRect::Intersection(KeyWdRect, PointNmRectV[RectN])) { 
574                      DoDrawP = false; break; }
575              }
576              if (!DoDrawP) { continue; } 
577              TFltV KeyWdCoodV = TFltV::GetV(KeyWdX, KeyWdY);
578              const int OkKeyWds = OkKeyWdV.Len(); bool KeyWdOkP = true;
579              for (int OkKeyWdN = 0; OkKeyWdN < OkKeyWds; OkKeyWdN++) {
580                  PVizMapKeyWd OkKeyWd = OkKeyWdV[OkKeyWdN];
581                  TStr OkKeyWdStr = OkKeyWd->GetKeyWdStr().GetLc();
582                  const double Dist = TLinAlg::EuclDist(KeyWdCoodV, OkKeyWd->GetCoordV());
583                  if (Dist < Sparsity) { KeyWdOkP = false; break; }
584                  if (OkKeyWdStr == KeyWdStr) {
585                      if (Dist < MnRptDist) { KeyWdOkP = false; break; }
586                  }
587              }
588              if (!KeyWdOkP) { continue; } 
589              Gks->PutTxt(KeyWdStr, X - HalfTxtWidth, Y - HalfTxtHeight); 
590              PointNmRectV.Add(KeyWdRect); OkKeyWdV.Add(KeyWd);
591          }
592      }
593  }
594  void TVizMapContext::PaintZoomRect(PGks Gks) {
595      Gks->SetPen(TGksPen::New(ColorZoomRect, gpmCopy, gpsSolid, 2));
596      Gks->FrameRect(DownX, DownY, ScreenX, ScreenY);
597  }
598  void TVizMapContext::PaintMgGlass(PGks Gks, const int& KeyWdFontSize) {
599      TFltRect ZoomRect = GetZoomRect();
600      int SizeX = TFlt::Round((MgGlassSize/ZoomRect.GetXLen()) * Gks->GetWidth());
601      int SizeY = TFlt::Round((MgGlassSize/ZoomRect.GetYLen()) * Gks->GetHeight());
602      Gks->SetBrush(TGksBrush::New(ColorMgGlass));
603      Gks->FillEllipse(ScreenX-SizeX, ScreenY-SizeY, ScreenX+SizeX, ScreenY+SizeY);
604      if (MgGlassKeyWdV.Len() > 0) {
605          Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize, TGksColor::GetBlack(), TFSet()|gfsBold));
606          TStr KeyWdStr = Gks->BreakTxt(MgGlassKeyWdV, ", ", ",", MgGlassWindowWidth);       
607          TStr NearPointStr;
608          if (NearPointN != -1) {
609              PVizMapPoint NearPoint = VizMapFrame->GetPoint(NearPointN);
610              if (NearPoint->IsPointNm()) {
611                  TStr NearPointNm = NearPoint->GetPointNm();
612                  if (NearPointNm.IsStrIn("[[")) {
613                      const int StartPos = NearPointNm.SearchStr("[[");
614                      NearPointNm = NearPointNm.Left(StartPos - 1);
615                  }
616                  NearPointStr = Gks->BreakTxt(NearPointNm, 
617                      " ", "", MgGlassWindowWidth, 1);
618                  NearPointStr.DelChAll('\n');
619                  NearPointStr += "\n";
620              }
621          }
622          TStr DocCountStr = "#documents = " + MgGlassPoints.GetStr() + "\n";
623          KeyWdStr = NearPointStr + DocCountStr + KeyWdStr;
624          int WndWidth = Gks->GetTxtWidth(KeyWdStr) + 6;
625          int WndHeight = Gks->GetTxtHeight(KeyWdStr) + 6;
626          int PosX = ScreenX + 20, PosY = ScreenY + 20;
627          if (PosX + WndWidth > Gks->GetWidth()) {
628              PosX = ScreenX - 20 - WndWidth; }
629          if (PosY + WndHeight > Gks->GetHeight()) {
630              PosY = ScreenY - 20 - WndHeight; }
631          Gks->SetBrush(TGksBrush::New(ColorMgGlassWndShadow));
632          Gks->FillRect(PosX + 5, PosY + 5, 
633              PosX + WndWidth + 5, PosY + WndHeight + 5);
634          Gks->SetBrush(TGksBrush::New(ColorMgGlassWnd));
635          Gks->SetPen(TGksPen::New(ColorMgGlassWndFrm));
636          Gks->Rectangle(PosX, PosY, 
637              PosX + WndWidth, PosY + WndHeight);
638          Gks->PutTxt(KeyWdStr, PosX+3, PosY+3);
639      }
640  }
641  void TVizMapContext::Export(const TStr& FNm, const TStr& EncoderType, const int& Width, 
642          const int& Height, const bool& ShowPointNmP, const int& PointFontSize, 
643          const int& PointNmFontScale, const double& PointWgtThreshold, const bool& ShowCatNmP,
644          const bool& ShowKeyWdP, const int& KeyWdFontSize, const bool& ShowMgGlassP, 
645          const int& LegendGridWidth, const int& LegendGridHeight) {
646      Gdiplus::Bitmap* Bmp = new Gdiplus::Bitmap(Width, Height);
647      Gdiplus::Graphics* g = Gdiplus::Graphics::FromImage(Bmp);
648      PGks BmpGks = TWfGks::New();
649      HDC HdcHandle = g->GetHDC(); BmpGks->BeginPaint(HdcHandle);
650      Paint(BmpGks, ShowPointNmP, PointFontSize, PointNmFontScale,
651          PointWgtThreshold, -1, ShowCatNmP, ShowKeyWdP, KeyWdFontSize, ShowMgGlassP, 
652          LegendGridWidth, LegendGridHeight);
653      BmpGks->EndPaint(); g->ReleaseHDC(HdcHandle);
654      WCHAR* FNmWChar = new WCHAR[FNm.Len() + 1];
655      const int Res = MultiByteToWideChar(CP_ACP, 0, 
656          FNm.CStr(), FNm.Len() + 1, FNmWChar, FNm.Len() + 1);
657      CLSID pngClsid; GetEncoderClsid(EncoderType, &pngClsid);
658      Bmp->Save(FNmWChar, &pngClsid, NULL);
659      delete FNmWChar; delete Bmp; delete g;
660  }
661  bool TVizMapContext::MouseMove(const int& X, const int& Y, 
662          const int& Width, const int& Height, const int& MgGlassKeyWds) {
663      const int MoveDiff = TInt::Abs(X - ScreenX) + TInt::Abs(Y - ScreenY);
664      ScreenX = X; ScreenY = Y;
665      TFltRect ZoomRect = GetZoomRect();
666      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
667      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
668      if (!LeftButtonDownP && (MoveDiff > 0)) { 
669          ResetMgGlassKeyWd(MgGlassKeyWds);
670          ResetNearPointN();
671      }
672      return (MoveDiff > 0);
673  }
674  void TVizMapContext::MouseLeftDown(const int& X, 
675          const int& Y, const int& Width, const int& Height) {
676      LeftButtonDownP = true;
677      DownX = X; DownY = Y;
678  }
679  void TVizMapContext::MouseLeftUp(const int& X, 
680          const int& Y, const int& Width, const int& Height) {
681      LeftButtonDownP = false;
682      TFltRect ZoomRect = GetZoomRect();
683      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
684      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
685      if (TInt::Abs(DownX - X) > 10 && TInt::Abs(DownY - Y) > 10) {
686          const double StartX = GetMapCoord(DownX, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
687          const double StartY = GetMapCoord(DownY, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
688          if (IsZoomMode()) { 
689              ZoomIn(StartX, StartY, MouseX, MouseY); 
690          } else if (IsSelectMode()) {
691              Select(StartX, StartY, MouseX, MouseY);
692          }
693      } else {
694          SelectDoc(MouseX, MouseY);
695      }
696  }
697  void TVizMapContext::MouseWheel(const int& Degree, const int& MgGlassKeyWds) { 
698      MgGlassSize *= pow(TMath::E / 2, Degree); 
699      if (!LeftButtonDownP) { ResetMgGlassKeyWd(MgGlassKeyWds); }
700  }
701  void TVizMapContext::ZoomIn(const double& X1, const double& Y1, const double& X2, const double& Y2) { 
702      ZoomIn(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
703                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2))); 
704  }
705  void TVizMapContext::ZoomIn(const TFltRect& ZoomInRect) { 
706      ZoomS.Push(ZoomInRect); 
707      RenderLandscapeBmp();
708      ResetMgGlassSize();
709      ResetKeyWd();
710  }
711  bool TVizMapContext::ZoomOut() { 
712      if (!ZoomS.Empty()) { 
713          ZoomS.Pop(); 
714          RenderLandscapeBmp(); 
715          ResetMgGlassSize();
716          ResetKeyWd();
717          return true;
718      } 
719      return false;
720  }
721  bool TVizMapContext::ZoomAll() { 
722      if (!ZoomS.Empty()) { 
723          ZoomS.Clr(); 
724          RenderLandscapeBmp(); 
725          ResetMgGlassSize();
726          ResetKeyWd();
727          return true;
728      }
729      return false;
730  }
731  void TVizMapContext::Select(const double& X1, const double& Y1, const double& X2, const double& Y2) {
732      Select(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
733                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2)));
734  }
735  void TVizMapContext::Select(const TFltRect& SelRect) {
736      TIntV NewSelPointV; 
737      if (VizMapFrame->GetRectPointV(SelRect, NewSelPointV) > 0) {
738          SelPointV.Union(NewSelPointV);
739      }
740  }
741  void TVizMapContext::Select(const int& DocId) {
742      SelPointV.Clr();
743      int Points = VizMapFrame->GetPoints();
744      for (int PointN = 0; PointN < Points; PointN++) {
745          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
746          if (Point->IsDocId() && Point->GetDocId() == DocId) {
747              SelPointV.Add(PointN); break;
748          }
749      }
750      if (SelPointV.Empty()) {
751          const int Frames = VizMap->GetVizMapFrames();
752          for (int FrameN = 0; FrameN < Frames; FrameN++) {
753              if (FrameN == VizMapFrameN) { continue; }
754              PVizMapFrame OtherFrame = VizMap->GetVizMapFrame(FrameN);
755              int Points = OtherFrame->GetPoints();
756              for (int PointN = 0; PointN < Points; PointN++) {
757                  PVizMapPoint Point = OtherFrame->GetPoint(PointN);
758                  if (Point->IsDocId() && Point->GetDocId() == DocId) {
759                      SelPointV.Add(PointN); SetVizMapFrame(FrameN); break;
760                  }
761              }
762          }
763      }
764  }
765  void TVizMapContext::GetSelectDIdV(TIntV& DIdV) {
766      DIdV.Gen(SelPointV.Len(), 0);
767      const int SelPoints = SelPointV.Len();
768      for (int SelPointN = 0; SelPointN < SelPoints; SelPointN++) {
769          DIdV.Add(VizMapFrame->GetPoint(SelPointV[SelPointN])->GetDocId());
770      }
771  }
772  void TVizMapContext::UnselectAll() {
773      SelPointV.Clr();
774  }
775  void TVizMapContext::SelectDoc(const double& DocX, const double& DocY) {
776      const int PointN = VizMapFrame->GetPointN(TFltV::GetV(DocX, DocY), 1.5);
777      if (IsZoomMode()) { 
778          if (PointN != -1) { 
779              SelPointV = TIntV::GetV(PointN); 
780          } else { 
781              SelPointV.Clr(); 
782          }
783      } else if (IsSelectMode()) {
784          if (PointN != -1) { 
785              if (SelPointV.IsInBin(PointN)) {
786                  SelPointV.DelIfIn(PointN);
787              } else {
788                  SelPointV.AddSorted(PointN); 
789              }
790          }
791      }
792  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-city.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</div>
                <div class="column column_space"><pre><code>87    uint32_t h = static_cast<uint32_t>(len), g = c1 * h, f = g;
88    uint32_t a0 = Rotate32(Fetch32(s + len - 4) * c1, 17) * c2;
89    uint32_t a1 = Rotate32(Fetch32(s + len - 8) * c1, 17) * c2;
90    uint32_t a2 = Rotate32(Fetch32(s + len - 16) * c1, 17) * c2;
91    uint32_t a3 = Rotate32(Fetch32(s + len - 12) * c1, 17) * c2;
92    uint32_t a4 = Rotate32(Fetch32(s + len - 20) * c1, 17) * c2;
93    h ^= a0;
94    h = Rotate32(h, 19);
95    h = h * 5 + 0xe6546b64;
96    h ^= a2;
97    h = Rotate32(h, 19);
98    h = h * 5 + 0xe6546b64;
99    g ^= a1;
100    g = Rotate32(g, 19);
</pre></code></div>
                <div class="column column_space"><pre><code>3  TGksColor TVizMapContext::ColorLandscapeAbove = TGksColor(54, 92, 120);
4  TGksColor TVizMapContext::ColorAddFirstLevel = TGksColor(9, 7, 6);
5  TGksColor TVizMapContext::ColorAddSecondLevel = TGksColor(18, 14, 12);
6  TGksColor TVizMapContext::ColorLegendGridColor = TGksColor(192, 255, 255, 255);
7  TGksColor TVizMapContext::ColorPointCross = TGksColor(255, 220, 0);
8  TGksColor TVizMapContext::ColorSelPointCross = TGksColor(255, 145, 145);
9  TGksColor TVizMapContext::ColorPointFont = TGksColor(255, 220, 0);
10  TGksColor TVizMapContext::ColorSelPointFont = TGksColor(255, 255, 30);
11  TGksColor TVizMapContext::ColorLink = TGksColor(100, 100, 255, 100);
12  TGksColor TVizMapContext::ColorKeyWdFont = TGksColor(240,240,255);
13  TGksColor TVizMapContext::ColorCatNmFont = TGksColor(255,240,255);
14  TGksColor TVizMapContext::ColorZoomRect = TGksColor(100, 0, 0, 0); 
15  TGksColor TVizMapContext::ColorMgGlass = TGksColor(50, 0, 0, 0);
16  TGksColor TVizMapContext::ColorMgGlassWnd = TGksColor(192, 255, 255, 255);
17  TGksColor TVizMapContext::ColorMgGlassWndFrm = TGksColor(100, 0, 0, 0); 
18  TGksColor TVizMapContext::ColorMgGlassWndShadow = TGksColor(50, 0, 0, 0);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    