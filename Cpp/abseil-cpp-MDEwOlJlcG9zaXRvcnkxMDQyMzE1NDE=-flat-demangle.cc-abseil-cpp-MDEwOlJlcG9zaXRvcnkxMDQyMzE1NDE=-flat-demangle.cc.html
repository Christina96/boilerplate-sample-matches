
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-demangle.cc</h3>
            <pre><code>1  #include "absl/debugging/internal/demangle.h"
2  #include <cstdint>
3  #include <cstdio>
4  #include <limits>
5  namespace absl {
6  ABSL_NAMESPACE_BEGIN
7  namespace debugging_internal {
8  typedef struct {
9    const char *abbrev;
10    const char *real_name;
11    int arity;
12  } AbbrevPair;
13  static const AbbrevPair kOperatorList[] = {
14      {"nw", "new", 0},
15      {"na", "new[]", 0},
16      {"dl", "delete", 1},
17      {"da", "delete[]", 1},
18      {"ps", "+", 1},  
19      {"ng", "-", 1},  
20      {"ad", "&", 1},  
21      {"de", "*", 1},  
22      {"co", "~", 1},
23      {"pl", "+", 2},
24      {"mi", "-", 2},
25      {"ml", "*", 2},
26      {"dv", "/", 2},
27      {"rm", "%", 2},
28      {"an", "&", 2},
29      {"or", "|", 2},
30      {"eo", "^", 2},
31      {"aS", "=", 2},
32      {"pL", "+=", 2},
33      {"mI", "-=", 2},
34      {"mL", "*=", 2},
35      {"dV", "/=", 2},
36      {"rM", "%=", 2},
37      {"aN", "&=", 2},
38      {"oR", "|=", 2},
39      {"eO", "^=", 2},
40      {"ls", "<<", 2},
41      {"rs", ">>", 2},
42      {"lS", "<<=", 2},
43      {"rS", ">>=", 2},
44      {"eq", "==", 2},
45      {"ne", "!=", 2},
46      {"lt", "<", 2},
47      {"gt", ">", 2},
48      {"le", "<=", 2},
49      {"ge", ">=", 2},
50      {"nt", "!", 1},
51      {"aa", "&&", 2},
52      {"oo", "||", 2},
53      {"pp", "++", 1},
54      {"mm", "--", 1},
55      {"cm", ",", 2},
56      {"pm", "->*", 2},
57      {"pt", "->", 0},  
58      {"cl", "()", 0},  
59      {"ix", "[]", 2},
60      {"qu", "?", 3},
61      {"st", "sizeof", 0},  
62      {"sz", "sizeof", 1},  
63      {nullptr, nullptr, 0},
64  };
65  static const AbbrevPair kBuiltinTypeList[] = {
66      {"v", "void", 0},
67      {"w", "wchar_t", 0},
68      {"b", "bool", 0},
69      {"c", "char", 0},
70      {"a", "signed char", 0},
71      {"h", "unsigned char", 0},
72      {"s", "short", 0},
73      {"t", "unsigned short", 0},
74      {"i", "int", 0},
75      {"j", "unsigned int", 0},
76      {"l", "long", 0},
77      {"m", "unsigned long", 0},
78      {"x", "long long", 0},
79      {"y", "unsigned long long", 0},
80      {"n", "__int128", 0},
81      {"o", "unsigned __int128", 0},
82      {"f", "float", 0},
83      {"d", "double", 0},
84      {"e", "long double", 0},
85      {"g", "__float128", 0},
86      {"z", "ellipsis", 0},
87      {"De", "decimal128", 0},      
88      {"Dd", "decimal64", 0},       
89      {"Dc", "decltype(auto)", 0},
90      {"Da", "auto", 0},
91      {"Dn", "std::nullptr_t", 0},  
92      {"Df", "decimal32", 0},       
93      {"Di", "char32_t", 0},
94      {"Du", "char8_t", 0},
95      {"Ds", "char16_t", 0},
96      {"Dh", "float16", 0},         
97      {nullptr, nullptr, 0},
98  };
99  static const AbbrevPair kSubstitutionList[] = {
100      {"St", "", 0},
101      {"Sa", "allocator", 0},
102      {"Sb", "basic_string", 0},
103      {"Ss", "string", 0},
104      {"Si", "istream", 0},
105      {"So", "ostream", 0},
106      {"Sd", "iostream", 0},
107      {nullptr, nullptr, 0},
108  };
109  typedef struct {
110    int mangled_idx;                     
111    int out_cur_idx;                     
112    int prev_name_idx;                   
113    unsigned int prev_name_length : 16;  
114    signed int nest_level : 15;          
115    unsigned int append : 1;             
116  } ParseState;
117  static_assert(sizeof(ParseState) == 4 * sizeof(int),
118                "unexpected size of ParseState");
119  typedef struct {
120    const char *mangled_begin;  
121    char *out;                  
122    int out_end_idx;            
123    int recursion_depth;        
124    int steps;               
125    ParseState parse_state;  
126  } State;
127  namespace {
128  class ComplexityGuard {
129   public:
130    explicit ComplexityGuard(State *state) : state_(state) {
131      ++state->recursion_depth;
132      ++state->steps;
133    }
134    ~ComplexityGuard() { --state_->recursion_depth; }
135    static constexpr int kRecursionDepthLimit = 256;
136    static constexpr int kParseStepsLimit = 1 << 17;
137    bool IsTooComplex() const {
138      return state_->recursion_depth > kRecursionDepthLimit ||
139             state_->steps > kParseStepsLimit;
140    }
141   private:
142    State *state_;
143  };
144  }  
145  static size_t StrLen(const char *str) {
146    size_t len = 0;
147    while (*str != '\0') {
148      ++str;
149      ++len;
150    }
151    return len;
152  }
153  static bool AtLeastNumCharsRemaining(const char *str, size_t n) {
154    for (size_t i = 0; i < n; ++i) {
155      if (str[i] == '\0') {
156        return false;
157      }
158    }
159    return true;
160  }
161  static bool StrPrefix(const char *str, const char *prefix) {
162    size_t i = 0;
163    while (str[i] != '\0' && prefix[i] != '\0' && str[i] == prefix[i]) {
164      ++i;
165    }
166    return prefix[i] == '\0';  
167  }
168  static void InitState(State* state,
169                        const char* mangled,
170                        char* out,
171                        size_t out_size) {
172    state->mangled_begin = mangled;
173    state->out = out;
174    state->out_end_idx = static_cast<int>(out_size);
175    state->recursion_depth = 0;
176    state->steps = 0;
177    state->parse_state.mangled_idx = 0;
178    state->parse_state.out_cur_idx = 0;
179    state->parse_state.prev_name_idx = 0;
180    state->parse_state.prev_name_length = 0;
181    state->parse_state.nest_level = -1;
182    state->parse_state.append = true;
183  }
184  static inline const char *RemainingInput(State *state) {
185    return &state->mangled_begin[state->parse_state.mangled_idx];
186  }
187  static bool ParseOneCharToken(State *state, const char one_char_token) {
188    ComplexityGuard guard(state);
189    if (guard.IsTooComplex()) return false;
190    if (RemainingInput(state)[0] == one_char_token) {
191      ++state->parse_state.mangled_idx;
192      return true;
193    }
194    return false;
195  }
196  static bool ParseTwoCharToken(State *state, const char *two_char_token) {
197    ComplexityGuard guard(state);
198    if (guard.IsTooComplex()) return false;
199    if (RemainingInput(state)[0] == two_char_token[0] &&
200        RemainingInput(state)[1] == two_char_token[1]) {
201      state->parse_state.mangled_idx += 2;
202      return true;
203    }
204    return false;
205  }
206  static bool ParseCharClass(State *state, const char *char_class) {
207    ComplexityGuard guard(state);
208    if (guard.IsTooComplex()) return false;
209    if (RemainingInput(state)[0] == '\0') {
210      return false;
211    }
212    const char *p = char_class;
213    for (; *p != '\0'; ++p) {
214      if (RemainingInput(state)[0] == *p) {
215        ++state->parse_state.mangled_idx;
216        return true;
217      }
218    }
219    return false;
220  }
221  static bool ParseDigit(State *state, int *digit) {
222    char c = RemainingInput(state)[0];
223    if (ParseCharClass(state, "0123456789")) {
224      if (digit != nullptr) {
225        *digit = c - '0';
226      }
227      return true;
228    }
229    return false;
230  }
231  static bool Optional(bool &bsol;*status*/) { return true; }
232  typedef bool (*ParseFunc)(State *);
233  static bool OneOrMore(ParseFunc parse_func, State *state) {
234    if (parse_func(state)) {
235      while (parse_func(state)) {
236      }
237      return true;
238    }
239    return false;
240  }
241  static bool ZeroOrMore(ParseFunc parse_func, State *state) {
242    while (parse_func(state)) {
243    }
244    return true;
245  }
246  static void Append(State *state, const char *const str, const size_t length) {
247    for (size_t i = 0; i < length; ++i) {
248      if (state->parse_state.out_cur_idx + 1 <
249          state->out_end_idx) {  
250        state->out[state->parse_state.out_cur_idx++] = str[i];
251      } else {
252        state->parse_state.out_cur_idx = state->out_end_idx + 1;
253        break;
254      }
255    }
256    if (state->parse_state.out_cur_idx < state->out_end_idx) {
257      state->out[state->parse_state.out_cur_idx] =
258          '\0';  
259    }
260  }
261  static bool IsLower(char c) { return c >= 'a' && c <= 'z'; }
262  static bool IsAlpha(char c) {
263    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
264  }
265  static bool IsDigit(char c) { return c >= '0' && c <= '9'; }
266  static bool IsFunctionCloneSuffix(const char *str) {
267    size_t i = 0;
268    while (str[i] != '\0') {
269      bool parsed = false;
270      if (str[i] == '.' && (IsAlpha(str[i + 1]) || str[i + 1] == '_')) {
271        parsed = true;
272        i += 2;
273        while (IsAlpha(str[i]) || str[i] == '_') {
274          ++i;
275        }
276      }
277      if (str[i] == '.' && IsDigit(str[i + 1])) {
278        parsed = true;
279        i += 2;
280        while (IsDigit(str[i])) {
281          ++i;
282        }
283      }
284      if (!parsed)
285        return false;
286    }
287    return true;  
288  }
289  static bool EndsWith(State *state, const char chr) {
290    return state->parse_state.out_cur_idx > 0 &&
291           state->parse_state.out_cur_idx < state->out_end_idx &&
292           chr == state->out[state->parse_state.out_cur_idx - 1];
293  }
294  static void MaybeAppendWithLength(State *state, const char *const str,
295                                    const size_t length) {
296    if (state->parse_state.append && length > 0) {
297      if (str[0] == '<' && EndsWith(state, '<')) {
298        Append(state, " ", 1);
299      }
300      if (state->parse_state.out_cur_idx < state->out_end_idx &&
301          (IsAlpha(str[0]) || str[0] == '_')) {
302        state->parse_state.prev_name_idx = state->parse_state.out_cur_idx;
303        state->parse_state.prev_name_length = static_cast<unsigned int>(length);
304      }
305      Append(state, str, length);
306    }
307  }
308  static bool MaybeAppendDecimal(State *state, int val) {
309    constexpr size_t kMaxLength = 20;
310    char buf[kMaxLength];
311    if (state->parse_state.append) {
312      char *p = &buf[kMaxLength];
313      do {  
314        *--p = static_cast<char>((val % 10) + '0');
315        val /= 10;
316      } while (p > buf && val != 0);
317      Append(state, p, kMaxLength - static_cast<size_t>(p - buf));
318    }
319    return true;
320  }
321  static bool MaybeAppend(State *state, const char *const str) {
322    if (state->parse_state.append) {
323      size_t length = StrLen(str);
324      MaybeAppendWithLength(state, str, length);
325    }
326    return true;
327  }
328  static bool EnterNestedName(State *state) {
329    state->parse_state.nest_level = 0;
330    return true;
331  }
332  static bool LeaveNestedName(State *state, int16_t prev_value) {
333    state->parse_state.nest_level = prev_value;
334    return true;
335  }
336  static bool DisableAppend(State *state) {
337    state->parse_state.append = false;
338    return true;
339  }
340  static bool RestoreAppend(State *state, bool prev_value) {
341    state->parse_state.append = prev_value;
342    return true;
343  }
344  static void MaybeIncreaseNestLevel(State *state) {
345    if (state->parse_state.nest_level > -1) {
346      ++state->parse_state.nest_level;
347    }
348  }
349  static void MaybeAppendSeparator(State *state) {
350    if (state->parse_state.nest_level >= 1) {
351      MaybeAppend(state, "::");
352    }
353  }
354  static void MaybeCancelLastSeparator(State *state) {
355    if (state->parse_state.nest_level >= 1 && state->parse_state.append &&
356        state->parse_state.out_cur_idx >= 2) {
357      state->parse_state.out_cur_idx -= 2;
358      state->out[state->parse_state.out_cur_idx] = '\0';
359    }
360  }
361  static bool IdentifierIsAnonymousNamespace(State *state, size_t length) {
362    static const char anon_prefix[] = "_GLOBAL__N_";
363    return (length > (sizeof(anon_prefix) - 1) &&
364            StrPrefix(RemainingInput(state), anon_prefix));
365  }
366  static bool ParseMangledName(State *state);
367  static bool ParseEncoding(State *state);
368  static bool ParseName(State *state);
369  static bool ParseUnscopedName(State *state);
370  static bool ParseNestedName(State *state);
371  static bool ParsePrefix(State *state);
372  static bool ParseUnqualifiedName(State *state);
373  static bool ParseSourceName(State *state);
374  static bool ParseLocalSourceName(State *state);
375  static bool ParseUnnamedTypeName(State *state);
376  static bool ParseNumber(State *state, int *number_out);
377  static bool ParseFloatNumber(State *state);
378  static bool ParseSeqId(State *state);
379  static bool ParseIdentifier(State *state, size_t length);
380  static bool ParseOperatorName(State *state, int *arity);
381  static bool ParseSpecialName(State *state);
382  static bool ParseCallOffset(State *state);
383  static bool ParseNVOffset(State *state);
384  static bool ParseVOffset(State *state);
385  static bool ParseAbiTags(State *state);
386  static bool ParseCtorDtorName(State *state);
387  static bool ParseDecltype(State *state);
388  static bool ParseType(State *state);
389  static bool ParseCVQualifiers(State *state);
390  static bool ParseBuiltinType(State *state);
391  static bool ParseFunctionType(State *state);
392  static bool ParseBareFunctionType(State *state);
393  static bool ParseClassEnumType(State *state);
394  static bool ParseArrayType(State *state);
395  static bool ParsePointerToMemberType(State *state);
396  static bool ParseTemplateParam(State *state);
397  static bool ParseTemplateTemplateParam(State *state);
398  static bool ParseTemplateArgs(State *state);
399  static bool ParseTemplateArg(State *state);
400  static bool ParseBaseUnresolvedName(State *state);
401  static bool ParseUnresolvedName(State *state);
402  static bool ParseExpression(State *state);
403  static bool ParseExprPrimary(State *state);
404  static bool ParseExprCastValue(State *state);
405  static bool ParseLocalName(State *state);
406  static bool ParseLocalNameSuffix(State *state);
407  static bool ParseDiscriminator(State *state);
408  static bool ParseSubstitution(State *state, bool accept_std);
409  static bool ParseMangledName(State *state) {
410    ComplexityGuard guard(state);
411    if (guard.IsTooComplex()) return false;
412    return ParseTwoCharToken(state, "_Z") && ParseEncoding(state);
413  }
414  static bool ParseEncoding(State *state) {
415    ComplexityGuard guard(state);
416    if (guard.IsTooComplex()) return false;
417    if (ParseName(state) && Optional(ParseBareFunctionType(state))) {
418      return true;
419    }
420    if (ParseSpecialName(state)) {
421      return true;
422    }
423    return false;
424  }
425  static bool ParseName(State *state) {
426    ComplexityGuard guard(state);
427    if (guard.IsTooComplex()) return false;
428    if (ParseNestedName(state) || ParseLocalName(state)) {
429      return true;
430    }
431    ParseState copy = state->parse_state;
432    if (ParseSubstitution(state, &bsol;*accept_std=*/false) &&
433        ParseTemplateArgs(state)) {
434      return true;
435    }
436    state->parse_state = copy;
437    return ParseUnscopedName(state) && Optional(ParseTemplateArgs(state));
438  }
439  static bool ParseUnscopedName(State *state) {
440    ComplexityGuard guard(state);
441    if (guard.IsTooComplex()) return false;
442    if (ParseUnqualifiedName(state)) {
443      return true;
444    }
445    ParseState copy = state->parse_state;
446    if (ParseTwoCharToken(state, "St") && MaybeAppend(state, "std::") &&
447        ParseUnqualifiedName(state)) {
448      return true;
449    }
450    state->parse_state = copy;
451    return false;
452  }
453  static inline bool ParseRefQualifier(State *state) {
454    return ParseCharClass(state, "OR");
455  }
456  static bool ParseNestedName(State *state) {
457    ComplexityGuard guard(state);
458    if (guard.IsTooComplex()) return false;
459    ParseState copy = state->parse_state;
460    if (ParseOneCharToken(state, 'N') && EnterNestedName(state) &&
461        Optional(ParseCVQualifiers(state)) &&
462        Optional(ParseRefQualifier(state)) && ParsePrefix(state) &&
463        LeaveNestedName(state, copy.nest_level) &&
464        ParseOneCharToken(state, 'E')) {
465      return true;
466    }
467    state->parse_state = copy;
468    return false;
469  }
470  static bool ParsePrefix(State *state) {
471    ComplexityGuard guard(state);
472    if (guard.IsTooComplex()) return false;
473    bool has_something = false;
474    while (true) {
475      MaybeAppendSeparator(state);
476      if (ParseTemplateParam(state) ||
477          ParseSubstitution(state, &bsol;*accept_std=*/true) ||
478          ParseUnscopedName(state) ||
479          (ParseOneCharToken(state, 'M') && ParseUnnamedTypeName(state))) {
480        has_something = true;
481        MaybeIncreaseNestLevel(state);
482        continue;
483      }
484      MaybeCancelLastSeparator(state);
485      if (has_something && ParseTemplateArgs(state)) {
486        return ParsePrefix(state);
487      } else {
488        break;
489      }
490    }
491    return true;
492  }
493  static bool ParseUnqualifiedName(State *state) {
494    ComplexityGuard guard(state);
495    if (guard.IsTooComplex()) return false;
496    if (ParseOperatorName(state, nullptr) || ParseCtorDtorName(state) ||
497        ParseSourceName(state) || ParseLocalSourceName(state) ||
498        ParseUnnamedTypeName(state)) {
499      return ParseAbiTags(state);
500    }
501    return false;
502  }
503  static bool ParseAbiTags(State *state) {
504    ComplexityGuard guard(state);
505    if (guard.IsTooComplex()) return false;
506    while (ParseOneCharToken(state, 'B')) {
507      ParseState copy = state->parse_state;
508      MaybeAppend(state, "[abi:");
509      if (!ParseSourceName(state)) {
510        state->parse_state = copy;
511        return false;
512      }
513      MaybeAppend(state, "]");
514    }
515    return true;
516  }
517  static bool ParseSourceName(State *state) {
518    ComplexityGuard guard(state);
519    if (guard.IsTooComplex()) return false;
520    ParseState copy = state->parse_state;
521    int length = -1;
522    if (ParseNumber(state, &length) &&
523        ParseIdentifier(state, static_cast<size_t>(length))) {
524      return true;
525    }
526    state->parse_state = copy;
527    return false;
528  }
529  static bool ParseLocalSourceName(State *state) {
530    ComplexityGuard guard(state);
531    if (guard.IsTooComplex()) return false;
532    ParseState copy = state->parse_state;
533    if (ParseOneCharToken(state, 'L') && ParseSourceName(state) &&
534        Optional(ParseDiscriminator(state))) {
535      return true;
536    }
537    state->parse_state = copy;
538    return false;
539  }
540  static bool ParseUnnamedTypeName(State *state) {
541    ComplexityGuard guard(state);
542    if (guard.IsTooComplex()) return false;
543    ParseState copy = state->parse_state;
544    int which = -1;
545    if (ParseTwoCharToken(state, "Ut") && Optional(ParseNumber(state, &which)) &&
546        which <= std::numeric_limits<int>::max() - 2 &&  
547        ParseOneCharToken(state, '_')) {
548      MaybeAppend(state, "{unnamed type#");
549      MaybeAppendDecimal(state, 2 + which);
550      MaybeAppend(state, "}");
551      return true;
552    }
553    state->parse_state = copy;
554    which = -1;
555    if (ParseTwoCharToken(state, "Ul") && DisableAppend(state) &&
556        OneOrMore(ParseType, state) && RestoreAppend(state, copy.append) &&
557        ParseOneCharToken(state, 'E') && Optional(ParseNumber(state, &which)) &&
558        which <= std::numeric_limits<int>::max() - 2 &&  
559        ParseOneCharToken(state, '_')) {
560      MaybeAppend(state, "{lambda()#");
561      MaybeAppendDecimal(state, 2 + which);
562      MaybeAppend(state, "}");
563      return true;
564    }
565    state->parse_state = copy;
566    return false;
567  }
568  static bool ParseNumber(State *state, int *number_out) {
569    ComplexityGuard guard(state);
570    if (guard.IsTooComplex()) return false;
571    bool negative = false;
572    if (ParseOneCharToken(state, 'n')) {
573      negative = true;
574    }
575    const char *p = RemainingInput(state);
576    uint64_t number = 0;
577    for (; *p != '\0'; ++p) {
578      if (IsDigit(*p)) {
579        number = number * 10 + static_cast<uint64_t>(*p - '0');
580      } else {
581        break;
582      }
583    }
584    if (negative) {
585      number = ~number + 1;
586    }
587    if (p != RemainingInput(state)) {  
588      state->parse_state.mangled_idx += p - RemainingInput(state);
589      if (number_out != nullptr) {
590        *number_out = static_cast<int>(number);
591      }
592      return true;
593    }
594    return false;
595  }
596  static bool ParseFloatNumber(State *state) {
597    ComplexityGuard guard(state);
598    if (guard.IsTooComplex()) return false;
599    const char *p = RemainingInput(state);
600    for (; *p != '\0'; ++p) {
601      if (!IsDigit(*p) && !(*p >= 'a' && *p <= 'f')) {
602        break;
603      }
604    }
605    if (p != RemainingInput(state)) {  
606      state->parse_state.mangled_idx += p - RemainingInput(state);
607      return true;
608    }
609    return false;
610  }
611  static bool ParseSeqId(State *state) {
612    ComplexityGuard guard(state);
613    if (guard.IsTooComplex()) return false;
614    const char *p = RemainingInput(state);
615    for (; *p != '\0'; ++p) {
616      if (!IsDigit(*p) && !(*p >= 'A' && *p <= 'Z')) {
617        break;
618      }
619    }
620    if (p != RemainingInput(state)) {  
621      state->parse_state.mangled_idx += p - RemainingInput(state);
622      return true;
623    }
624    return false;
625  }
626  static bool ParseIdentifier(State *state, size_t length) {
627    ComplexityGuard guard(state);
628    if (guard.IsTooComplex()) return false;
629    if (!AtLeastNumCharsRemaining(RemainingInput(state), length)) {
630      return false;
631    }
632    if (IdentifierIsAnonymousNamespace(state, length)) {
633      MaybeAppend(state, "(anonymous namespace)");
634    } else {
635      MaybeAppendWithLength(state, RemainingInput(state), length);
636    }
637    state->parse_state.mangled_idx += length;
638    return true;
639  }
640  static bool ParseOperatorName(State *state, int *arity) {
641    ComplexityGuard guard(state);
642    if (guard.IsTooComplex()) return false;
643    if (!AtLeastNumCharsRemaining(RemainingInput(state), 2)) {
644      return false;
645    }
646    ParseState copy = state->parse_state;
647    if (ParseTwoCharToken(state, "cv") && MaybeAppend(state, "operator ") &&
648        EnterNestedName(state) && ParseType(state) &&
649        LeaveNestedName(state, copy.nest_level)) {
650      if (arity != nullptr) {
651        *arity = 1;
652      }
653      return true;
654    }
655    state->parse_state = copy;
656    if (ParseOneCharToken(state, 'v') && ParseDigit(state, arity) &&
657        ParseSourceName(state)) {
658      return true;
659    }
660    state->parse_state = copy;
661    if (!(IsLower(RemainingInput(state)[0]) &&
662          IsAlpha(RemainingInput(state)[1]))) {
663      return false;
664    }
665    const AbbrevPair *p;
666    for (p = kOperatorList; p->abbrev != nullptr; ++p) {
667      if (RemainingInput(state)[0] == p->abbrev[0] &&
668          RemainingInput(state)[1] == p->abbrev[1]) {
669        if (arity != nullptr) {
670          *arity = p->arity;
671        }
672        MaybeAppend(state, "operator");
673        if (IsLower(*p->real_name)) {  
674          MaybeAppend(state, " ");
675        }
676        MaybeAppend(state, p->real_name);
677        state->parse_state.mangled_idx += 2;
678        return true;
679      }
680    }
681    return false;
682  }
683  static bool ParseSpecialName(State *state) {
684    ComplexityGuard guard(state);
685    if (guard.IsTooComplex()) return false;
686    ParseState copy = state->parse_state;
687    if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "VTISH") &&
688        ParseType(state)) {
689      return true;
690    }
691    state->parse_state = copy;
692    if (ParseTwoCharToken(state, "Tc") && ParseCallOffset(state) &&
693        ParseCallOffset(state) && ParseEncoding(state)) {
694      return true;
695    }
696    state->parse_state = copy;
697    if (ParseTwoCharToken(state, "GV") && ParseName(state)) {
698      return true;
699    }
700    state->parse_state = copy;
701    if (ParseOneCharToken(state, 'T') && ParseCallOffset(state) &&
702        ParseEncoding(state)) {
703      return true;
704    }
705    state->parse_state = copy;
706    if (ParseTwoCharToken(state, "TC") && ParseType(state) &&
707        ParseNumber(state, nullptr) && ParseOneCharToken(state, '_') &&
708        DisableAppend(state) && ParseType(state)) {
709      RestoreAppend(state, copy.append);
710      return true;
711    }
712    state->parse_state = copy;
713    if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "FJ") &&
714        ParseType(state)) {
715      return true;
716    }
717    state->parse_state = copy;
718    if (ParseTwoCharToken(state, "GR") && ParseName(state)) {
719      return true;
720    }
721    state->parse_state = copy;
722    if (ParseTwoCharToken(state, "GA") && ParseEncoding(state)) {
723      return true;
724    }
725    state->parse_state = copy;
726    if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "hv") &&
727        ParseCallOffset(state) && ParseEncoding(state)) {
728      return true;
729    }
730    state->parse_state = copy;
731    return false;
732  }
733  static bool ParseCallOffset(State *state) {
734    ComplexityGuard guard(state);
735    if (guard.IsTooComplex()) return false;
736    ParseState copy = state->parse_state;
737    if (ParseOneCharToken(state, 'h') && ParseNVOffset(state) &&
738        ParseOneCharToken(state, '_')) {
739      return true;
740    }
741    state->parse_state = copy;
742    if (ParseOneCharToken(state, 'v') && ParseVOffset(state) &&
743        ParseOneCharToken(state, '_')) {
744      return true;
745    }
746    state->parse_state = copy;
747    return false;
748  }
749  static bool ParseNVOffset(State *state) {
750    ComplexityGuard guard(state);
751    if (guard.IsTooComplex()) return false;
752    return ParseNumber(state, nullptr);
753  }
754  static bool ParseVOffset(State *state) {
755    ComplexityGuard guard(state);
756    if (guard.IsTooComplex()) return false;
757    ParseState copy = state->parse_state;
758    if (ParseNumber(state, nullptr) && ParseOneCharToken(state, '_') &&
759        ParseNumber(state, nullptr)) {
760      return true;
761    }
762    state->parse_state = copy;
763    return false;
764  }
765  static bool ParseCtorDtorName(State *state) {
766    ComplexityGuard guard(state);
767    if (guard.IsTooComplex()) return false;
768    ParseState copy = state->parse_state;
769    if (ParseOneCharToken(state, 'C')) {
770      if (ParseCharClass(state, "1234")) {
771        const char *const prev_name =
772            state->out + state->parse_state.prev_name_idx;
<span onclick='openModal()' class='match'>773        MaybeAppendWithLength(state, prev_name,
774                              state->parse_state.prev_name_length);
775        return true;
776      } else if (ParseOneCharToken(state, 'I') && ParseCharClass(state, "12") &&
</span>777                 ParseClassEnumType(state)) {
778        return true;
779      }
780    }
781    state->parse_state = copy;
782    if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "0124")) {
783      const char *const prev_name = state->out + state->parse_state.prev_name_idx;
784      MaybeAppend(state, "~");
785      MaybeAppendWithLength(state, prev_name,
786                            state->parse_state.prev_name_length);
787      return true;
788    }
789    state->parse_state = copy;
790    return false;
791  }
792  static bool ParseDecltype(State *state) {
793    ComplexityGuard guard(state);
794    if (guard.IsTooComplex()) return false;
795    ParseState copy = state->parse_state;
796    if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "tT") &&
797        ParseExpression(state) && ParseOneCharToken(state, 'E')) {
798      return true;
799    }
800    state->parse_state = copy;
801    return false;
802  }
803  static bool ParseType(State *state) {
804    ComplexityGuard guard(state);
805    if (guard.IsTooComplex()) return false;
806    ParseState copy = state->parse_state;
807    if (ParseCVQualifiers(state)) {
808      const bool result = ParseType(state);
809      if (!result) state->parse_state = copy;
810      return result;
811    }
812    state->parse_state = copy;
813    if (ParseCharClass(state, "OPRCG")) {
814      const bool result = ParseType(state);
815      if (!result) state->parse_state = copy;
816      return result;
817    }
818    state->parse_state = copy;
819    if (ParseTwoCharToken(state, "Dp") && ParseType(state)) {
820      return true;
821    }
822    state->parse_state = copy;
823    if (ParseOneCharToken(state, 'U') && ParseSourceName(state) &&
824        ParseType(state)) {
825      return true;
826    }
827    state->parse_state = copy;
828    if (ParseBuiltinType(state) || ParseFunctionType(state) ||
829        ParseClassEnumType(state) || ParseArrayType(state) ||
830        ParsePointerToMemberType(state) || ParseDecltype(state) ||
831        ParseSubstitution(state, &bsol;*accept_std=*/false)) {
832      return true;
833    }
834    if (ParseTemplateTemplateParam(state) && ParseTemplateArgs(state)) {
835      return true;
836    }
837    state->parse_state = copy;
838    if (ParseTemplateParam(state)) {
839      return true;
840    }
841    if (ParseTwoCharToken(state, "Dv") && ParseNumber(state, nullptr) &&
842        ParseOneCharToken(state, '_')) {
843      return true;
844    }
845    state->parse_state = copy;
846    return false;
847  }
848  static bool ParseCVQualifiers(State *state) {
849    ComplexityGuard guard(state);
850    if (guard.IsTooComplex()) return false;
851    int num_cv_qualifiers = 0;
852    num_cv_qualifiers += ParseOneCharToken(state, 'r');
853    num_cv_qualifiers += ParseOneCharToken(state, 'V');
854    num_cv_qualifiers += ParseOneCharToken(state, 'K');
855    return num_cv_qualifiers > 0;
856  }
857  static bool ParseBuiltinType(State *state) {
858    ComplexityGuard guard(state);
859    if (guard.IsTooComplex()) return false;
860    const AbbrevPair *p;
861    for (p = kBuiltinTypeList; p->abbrev != nullptr; ++p) {
862      if (p->abbrev[1] == '\0') {
863        if (ParseOneCharToken(state, p->abbrev[0])) {
864          MaybeAppend(state, p->real_name);
865          return true;
866        }
867      } else if (p->abbrev[2] == '\0' && ParseTwoCharToken(state, p->abbrev)) {
868        MaybeAppend(state, p->real_name);
869        return true;
870      }
871    }
872    ParseState copy = state->parse_state;
873    if (ParseOneCharToken(state, 'u') && ParseSourceName(state)) {
874      return true;
875    }
876    state->parse_state = copy;
877    return false;
878  }
879  static bool ParseExceptionSpec(State *state) {
880    ComplexityGuard guard(state);
881    if (guard.IsTooComplex()) return false;
882    if (ParseTwoCharToken(state, "Do")) return true;
883    ParseState copy = state->parse_state;
884    if (ParseTwoCharToken(state, "DO") && ParseExpression(state) &&
885        ParseOneCharToken(state, 'E')) {
886      return true;
887    }
888    state->parse_state = copy;
889    if (ParseTwoCharToken(state, "Dw") && OneOrMore(ParseType, state) &&
890        ParseOneCharToken(state, 'E')) {
891      return true;
892    }
893    state->parse_state = copy;
894    return false;
895  }
896  static bool ParseFunctionType(State *state) {
897    ComplexityGuard guard(state);
898    if (guard.IsTooComplex()) return false;
899    ParseState copy = state->parse_state;
900    if (Optional(ParseExceptionSpec(state)) && ParseOneCharToken(state, 'F') &&
901        Optional(ParseOneCharToken(state, 'Y')) && ParseBareFunctionType(state) &&
902        Optional(ParseOneCharToken(state, 'O')) &&
903        ParseOneCharToken(state, 'E')) {
904      return true;
905    }
906    state->parse_state = copy;
907    return false;
908  }
909  static bool ParseBareFunctionType(State *state) {
910    ComplexityGuard guard(state);
911    if (guard.IsTooComplex()) return false;
912    ParseState copy = state->parse_state;
913    DisableAppend(state);
914    if (OneOrMore(ParseType, state)) {
915      RestoreAppend(state, copy.append);
916      MaybeAppend(state, "()");
917      return true;
918    }
919    state->parse_state = copy;
920    return false;
921  }
922  static bool ParseClassEnumType(State *state) {
923    ComplexityGuard guard(state);
924    if (guard.IsTooComplex()) return false;
925    return ParseName(state);
926  }
927  static bool ParseArrayType(State *state) {
928    ComplexityGuard guard(state);
929    if (guard.IsTooComplex()) return false;
930    ParseState copy = state->parse_state;
931    if (ParseOneCharToken(state, 'A') && ParseNumber(state, nullptr) &&
932        ParseOneCharToken(state, '_') && ParseType(state)) {
933      return true;
934    }
935    state->parse_state = copy;
936    if (ParseOneCharToken(state, 'A') && Optional(ParseExpression(state)) &&
937        ParseOneCharToken(state, '_') && ParseType(state)) {
938      return true;
939    }
940    state->parse_state = copy;
941    return false;
942  }
943  static bool ParsePointerToMemberType(State *state) {
944    ComplexityGuard guard(state);
945    if (guard.IsTooComplex()) return false;
946    ParseState copy = state->parse_state;
947    if (ParseOneCharToken(state, 'M') && ParseType(state) && ParseType(state)) {
948      return true;
949    }
950    state->parse_state = copy;
951    return false;
952  }
953  static bool ParseTemplateParam(State *state) {
954    ComplexityGuard guard(state);
955    if (guard.IsTooComplex()) return false;
956    if (ParseTwoCharToken(state, "T_")) {
957      MaybeAppend(state, "?");  
958      return true;
959    }
960    ParseState copy = state->parse_state;
961    if (ParseOneCharToken(state, 'T') && ParseNumber(state, nullptr) &&
962        ParseOneCharToken(state, '_')) {
963      MaybeAppend(state, "?");  
964      return true;
965    }
966    state->parse_state = copy;
967    return false;
968  }
969  static bool ParseTemplateTemplateParam(State *state) {
970    ComplexityGuard guard(state);
971    if (guard.IsTooComplex()) return false;
972    return (ParseTemplateParam(state) ||
973            ParseSubstitution(state, &bsol;*accept_std=*/false));
974  }
975  static bool ParseTemplateArgs(State *state) {
976    ComplexityGuard guard(state);
977    if (guard.IsTooComplex()) return false;
978    ParseState copy = state->parse_state;
979    DisableAppend(state);
980    if (ParseOneCharToken(state, 'I') && OneOrMore(ParseTemplateArg, state) &&
981        ParseOneCharToken(state, 'E')) {
982      RestoreAppend(state, copy.append);
983      MaybeAppend(state, "<>");
984      return true;
985    }
986    state->parse_state = copy;
987    return false;
988  }
989  static bool ParseTemplateArg(State *state) {
990    ComplexityGuard guard(state);
991    if (guard.IsTooComplex()) return false;
992    ParseState copy = state->parse_state;
993    if (ParseOneCharToken(state, 'J') && ZeroOrMore(ParseTemplateArg, state) &&
994        ParseOneCharToken(state, 'E')) {
995      return true;
996    }
997    state->parse_state = copy;
998    if (ParseLocalSourceName(state) && Optional(ParseTemplateArgs(state))) {
999      copy = state->parse_state;
1000      if (ParseExprCastValue(state) && ParseOneCharToken(state, 'E')) {
1001        return true;
1002      }
1003      state->parse_state = copy;
1004      return true;
1005    }
1006    if (ParseType(state) || ParseExprPrimary(state)) {
1007      return true;
1008    }
1009    state->parse_state = copy;
1010    if (ParseOneCharToken(state, 'X') && ParseExpression(state) &&
1011        ParseOneCharToken(state, 'E')) {
1012      return true;
1013    }
1014    state->parse_state = copy;
1015    return false;
1016  }
1017  static inline bool ParseUnresolvedType(State *state) {
1018    return (ParseTemplateParam(state) && Optional(ParseTemplateArgs(state))) ||
1019           ParseDecltype(state) || ParseSubstitution(state, &bsol;*accept_std=*/false);
1020  }
1021  static inline bool ParseSimpleId(State *state) {
1022    return ParseSourceName(state) && Optional(ParseTemplateArgs(state));
1023  }
1024  static bool ParseBaseUnresolvedName(State *state) {
1025    ComplexityGuard guard(state);
1026    if (guard.IsTooComplex()) return false;
1027    if (ParseSimpleId(state)) {
1028      return true;
1029    }
1030    ParseState copy = state->parse_state;
1031    if (ParseTwoCharToken(state, "on") && ParseOperatorName(state, nullptr) &&
1032        Optional(ParseTemplateArgs(state))) {
1033      return true;
1034    }
1035    state->parse_state = copy;
1036    if (ParseTwoCharToken(state, "dn") &&
1037        (ParseUnresolvedType(state) || ParseSimpleId(state))) {
1038      return true;
1039    }
1040    state->parse_state = copy;
1041    return false;
1042  }
1043  static bool ParseUnresolvedName(State *state) {
1044    ComplexityGuard guard(state);
1045    if (guard.IsTooComplex()) return false;
1046    ParseState copy = state->parse_state;
1047    if (Optional(ParseTwoCharToken(state, "gs")) &&
1048        ParseBaseUnresolvedName(state)) {
1049      return true;
1050    }
1051    state->parse_state = copy;
1052    if (ParseTwoCharToken(state, "sr") && ParseUnresolvedType(state) &&
1053        ParseBaseUnresolvedName(state)) {
1054      return true;
1055    }
1056    state->parse_state = copy;
1057    if (ParseTwoCharToken(state, "sr") && ParseOneCharToken(state, 'N') &&
1058        ParseUnresolvedType(state) &&
1059        OneOrMore(&bsol;* <unresolved-qualifier-level> ::= */ ParseSimpleId, state) &&
1060        ParseOneCharToken(state, 'E') && ParseBaseUnresolvedName(state)) {
1061      return true;
1062    }
1063    state->parse_state = copy;
1064    if (Optional(ParseTwoCharToken(state, "gs")) &&
1065        ParseTwoCharToken(state, "sr") &&
1066        OneOrMore(&bsol;* <unresolved-qualifier-level> ::= */ ParseSimpleId, state) &&
1067        ParseOneCharToken(state, 'E') && ParseBaseUnresolvedName(state)) {
1068      return true;
1069    }
1070    state->parse_state = copy;
1071    return false;
1072  }
1073  static bool ParseExpression(State *state) {
1074    ComplexityGuard guard(state);
1075    if (guard.IsTooComplex()) return false;
1076    if (ParseTemplateParam(state) || ParseExprPrimary(state)) {
1077      return true;
1078    }
1079    ParseState copy = state->parse_state;
1080    if (ParseTwoCharToken(state, "cl") && OneOrMore(ParseExpression, state) &&
1081        ParseOneCharToken(state, 'E')) {
1082      return true;
1083    }
1084    state->parse_state = copy;
1085    if (ParseTwoCharToken(state, "cp") && ParseSimpleId(state) &&
1086        ZeroOrMore(ParseExpression, state) && ParseOneCharToken(state, 'E')) {
1087      return true;
1088    }
1089    state->parse_state = copy;
1090    if (ParseTwoCharToken(state, "fp") && Optional(ParseCVQualifiers(state)) &&
1091        Optional(ParseNumber(state, nullptr)) && ParseOneCharToken(state, '_')) {
1092      return true;
1093    }
1094    state->parse_state = copy;
1095    if (ParseTwoCharToken(state, "fL") && Optional(ParseNumber(state, nullptr)) &&
1096        ParseOneCharToken(state, 'p') && Optional(ParseCVQualifiers(state)) &&
1097        Optional(ParseNumber(state, nullptr)) && ParseOneCharToken(state, '_')) {
1098      return true;
1099    }
1100    state->parse_state = copy;
1101    if (ParseTwoCharToken(state, "cv")) {
1102      if (ParseType(state)) {
1103        ParseState copy2 = state->parse_state;
1104        if (ParseOneCharToken(state, '_') && ZeroOrMore(ParseExpression, state) &&
1105            ParseOneCharToken(state, 'E')) {
1106          return true;
1107        }
1108        state->parse_state = copy2;
1109        if (ParseExpression(state)) {
1110          return true;
1111        }
1112      }
1113    } else {
1114      int arity = -1;
1115      if (ParseOperatorName(state, &arity) &&
1116          arity > 0 &&  
1117          (arity < 3 || ParseExpression(state)) &&
1118          (arity < 2 || ParseExpression(state)) &&
1119          (arity < 1 || ParseExpression(state))) {
1120        return true;
1121      }
1122    }
1123    state->parse_state = copy;
1124    if (ParseTwoCharToken(state, "st") && ParseType(state)) {
1125      return true;
1126    }
1127    state->parse_state = copy;
1128    if ((ParseTwoCharToken(state, "dt") || ParseTwoCharToken(state, "pt")) &&
1129        ParseExpression(state) && ParseType(state)) {
1130      return true;
1131    }
1132    state->parse_state = copy;
1133    if (ParseTwoCharToken(state, "ds") && ParseExpression(state) &&
1134        ParseExpression(state)) {
1135      return true;
1136    }
1137    state->parse_state = copy;
1138    if (ParseTwoCharToken(state, "sp") && ParseExpression(state)) {
1139      return true;
1140    }
1141    state->parse_state = copy;
1142    return ParseUnresolvedName(state);
1143  }
1144  static bool ParseExprPrimary(State *state) {
1145    ComplexityGuard guard(state);
1146    if (guard.IsTooComplex()) return false;
1147    ParseState copy = state->parse_state;
1148    if (ParseTwoCharToken(state, "LZ")) {
1149      if (ParseEncoding(state) && ParseOneCharToken(state, 'E')) {
1150        return true;
1151      }
1152      state->parse_state = copy;
1153      return false;
1154    }
1155    if (ParseOneCharToken(state, 'L') && ParseType(state) &&
1156        ParseExprCastValue(state)) {
1157      return true;
1158    }
1159    state->parse_state = copy;
1160    if (ParseOneCharToken(state, 'L') && ParseMangledName(state) &&
1161        ParseOneCharToken(state, 'E')) {
1162      return true;
1163    }
1164    state->parse_state = copy;
1165    return false;
1166  }
1167  static bool ParseExprCastValue(State *state) {
1168    ComplexityGuard guard(state);
1169    if (guard.IsTooComplex()) return false;
1170    ParseState copy = state->parse_state;
1171    if (ParseNumber(state, nullptr) && ParseOneCharToken(state, 'E')) {
1172      return true;
1173    }
1174    state->parse_state = copy;
1175    if (ParseFloatNumber(state) && ParseOneCharToken(state, 'E')) {
1176      return true;
1177    }
1178    state->parse_state = copy;
1179    return false;
1180  }
1181  static bool ParseLocalNameSuffix(State *state) {
1182    ComplexityGuard guard(state);
1183    if (guard.IsTooComplex()) return false;
1184    if (MaybeAppend(state, "::") && ParseName(state) &&
1185        Optional(ParseDiscriminator(state))) {
1186      return true;
1187    }
1188    if (state->parse_state.append) {
1189      state->out[state->parse_state.out_cur_idx - 2] = '\0';
1190    }
1191    return ParseOneCharToken(state, 's') && Optional(ParseDiscriminator(state));
1192  }
1193  static bool ParseLocalName(State *state) {
1194    ComplexityGuard guard(state);
1195    if (guard.IsTooComplex()) return false;
1196    ParseState copy = state->parse_state;
1197    if (ParseOneCharToken(state, 'Z') && ParseEncoding(state) &&
1198        ParseOneCharToken(state, 'E') && ParseLocalNameSuffix(state)) {
1199      return true;
1200    }
1201    state->parse_state = copy;
1202    return false;
1203  }
1204  static bool ParseDiscriminator(State *state) {
1205    ComplexityGuard guard(state);
1206    if (guard.IsTooComplex()) return false;
1207    ParseState copy = state->parse_state;
1208    if (ParseOneCharToken(state, '_') && ParseNumber(state, nullptr)) {
1209      return true;
1210    }
1211    state->parse_state = copy;
1212    return false;
1213  }
1214  static bool ParseSubstitution(State *state, bool accept_std) {
1215    ComplexityGuard guard(state);
1216    if (guard.IsTooComplex()) return false;
1217    if (ParseTwoCharToken(state, "S_")) {
1218      MaybeAppend(state, "?");  
1219      return true;
1220    }
1221    ParseState copy = state->parse_state;
1222    if (ParseOneCharToken(state, 'S') && ParseSeqId(state) &&
1223        ParseOneCharToken(state, '_')) {
1224      MaybeAppend(state, "?");  
1225      return true;
1226    }
1227    state->parse_state = copy;
1228    if (ParseOneCharToken(state, 'S')) {
1229      const AbbrevPair *p;
1230      for (p = kSubstitutionList; p->abbrev != nullptr; ++p) {
1231        if (RemainingInput(state)[0] == p->abbrev[1] &&
1232            (accept_std || p->abbrev[1] != 't')) {
1233          MaybeAppend(state, "std");
1234          if (p->real_name[0] != '\0') {
1235            MaybeAppend(state, "::");
1236            MaybeAppend(state, p->real_name);
1237          }
1238          ++state->parse_state.mangled_idx;
1239          return true;
1240        }
1241      }
1242    }
1243    state->parse_state = copy;
1244    return false;
1245  }
1246  static bool ParseTopLevelMangledName(State *state) {
1247    ComplexityGuard guard(state);
1248    if (guard.IsTooComplex()) return false;
1249    if (ParseMangledName(state)) {
1250      if (RemainingInput(state)[0] != '\0') {
1251        if (IsFunctionCloneSuffix(RemainingInput(state))) {
1252          return true;
1253        }
1254        if (RemainingInput(state)[0] == '@') {
1255          MaybeAppend(state, RemainingInput(state));
1256          return true;
1257        }
1258        return false;  
1259      }
1260      return true;
1261    }
1262    return false;
1263  }
1264  static bool Overflowed(const State *state) {
1265    return state->parse_state.out_cur_idx >= state->out_end_idx;
1266  }
1267  bool Demangle(const char* mangled, char* out, size_t out_size) {
1268    State state;
1269    InitState(&state, mangled, out, out_size);
1270    return ParseTopLevelMangledName(&state) && !Overflowed(&state) &&
1271           state.parse_state.out_cur_idx > 0;
1272  }
1273  }  
1274  ABSL_NAMESPACE_END
1275  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-demangle.cc</h3>
            <pre><code>1  #include "absl/debugging/internal/demangle.h"
2  #include <cstdint>
3  #include <cstdio>
4  #include <limits>
5  namespace absl {
6  ABSL_NAMESPACE_BEGIN
7  namespace debugging_internal {
8  typedef struct {
9    const char *abbrev;
10    const char *real_name;
11    int arity;
12  } AbbrevPair;
13  static const AbbrevPair kOperatorList[] = {
14      {"nw", "new", 0},
15      {"na", "new[]", 0},
16      {"dl", "delete", 1},
17      {"da", "delete[]", 1},
18      {"ps", "+", 1},  
19      {"ng", "-", 1},  
20      {"ad", "&", 1},  
21      {"de", "*", 1},  
22      {"co", "~", 1},
23      {"pl", "+", 2},
24      {"mi", "-", 2},
25      {"ml", "*", 2},
26      {"dv", "/", 2},
27      {"rm", "%", 2},
28      {"an", "&", 2},
29      {"or", "|", 2},
30      {"eo", "^", 2},
31      {"aS", "=", 2},
32      {"pL", "+=", 2},
33      {"mI", "-=", 2},
34      {"mL", "*=", 2},
35      {"dV", "/=", 2},
36      {"rM", "%=", 2},
37      {"aN", "&=", 2},
38      {"oR", "|=", 2},
39      {"eO", "^=", 2},
40      {"ls", "<<", 2},
41      {"rs", ">>", 2},
42      {"lS", "<<=", 2},
43      {"rS", ">>=", 2},
44      {"eq", "==", 2},
45      {"ne", "!=", 2},
46      {"lt", "<", 2},
47      {"gt", ">", 2},
48      {"le", "<=", 2},
49      {"ge", ">=", 2},
50      {"nt", "!", 1},
51      {"aa", "&&", 2},
52      {"oo", "||", 2},
53      {"pp", "++", 1},
54      {"mm", "--", 1},
55      {"cm", ",", 2},
56      {"pm", "->*", 2},
57      {"pt", "->", 0},  
58      {"cl", "()", 0},  
59      {"ix", "[]", 2},
60      {"qu", "?", 3},
61      {"st", "sizeof", 0},  
62      {"sz", "sizeof", 1},  
63      {nullptr, nullptr, 0},
64  };
65  static const AbbrevPair kBuiltinTypeList[] = {
66      {"v", "void", 0},
67      {"w", "wchar_t", 0},
68      {"b", "bool", 0},
69      {"c", "char", 0},
70      {"a", "signed char", 0},
71      {"h", "unsigned char", 0},
72      {"s", "short", 0},
73      {"t", "unsigned short", 0},
74      {"i", "int", 0},
75      {"j", "unsigned int", 0},
76      {"l", "long", 0},
77      {"m", "unsigned long", 0},
78      {"x", "long long", 0},
79      {"y", "unsigned long long", 0},
80      {"n", "__int128", 0},
81      {"o", "unsigned __int128", 0},
82      {"f", "float", 0},
83      {"d", "double", 0},
84      {"e", "long double", 0},
85      {"g", "__float128", 0},
86      {"z", "ellipsis", 0},
87      {"De", "decimal128", 0},      
88      {"Dd", "decimal64", 0},       
89      {"Dc", "decltype(auto)", 0},
90      {"Da", "auto", 0},
91      {"Dn", "std::nullptr_t", 0},  
92      {"Df", "decimal32", 0},       
93      {"Di", "char32_t", 0},
94      {"Du", "char8_t", 0},
95      {"Ds", "char16_t", 0},
96      {"Dh", "float16", 0},         
97      {nullptr, nullptr, 0},
98  };
99  static const AbbrevPair kSubstitutionList[] = {
100      {"St", "", 0},
101      {"Sa", "allocator", 0},
102      {"Sb", "basic_string", 0},
103      {"Ss", "string", 0},
104      {"Si", "istream", 0},
105      {"So", "ostream", 0},
106      {"Sd", "iostream", 0},
107      {nullptr, nullptr, 0},
108  };
109  typedef struct {
110    int mangled_idx;                     
111    int out_cur_idx;                     
112    int prev_name_idx;                   
113    unsigned int prev_name_length : 16;  
114    signed int nest_level : 15;          
115    unsigned int append : 1;             
116  } ParseState;
117  static_assert(sizeof(ParseState) == 4 * sizeof(int),
118                "unexpected size of ParseState");
119  typedef struct {
120    const char *mangled_begin;  
121    char *out;                  
122    int out_end_idx;            
123    int recursion_depth;        
124    int steps;               
125    ParseState parse_state;  
126  } State;
127  namespace {
128  class ComplexityGuard {
129   public:
130    explicit ComplexityGuard(State *state) : state_(state) {
131      ++state->recursion_depth;
132      ++state->steps;
133    }
134    ~ComplexityGuard() { --state_->recursion_depth; }
135    static constexpr int kRecursionDepthLimit = 256;
136    static constexpr int kParseStepsLimit = 1 << 17;
137    bool IsTooComplex() const {
138      return state_->recursion_depth > kRecursionDepthLimit ||
139             state_->steps > kParseStepsLimit;
140    }
141   private:
142    State *state_;
143  };
144  }  
145  static size_t StrLen(const char *str) {
146    size_t len = 0;
147    while (*str != '\0') {
148      ++str;
149      ++len;
150    }
151    return len;
152  }
153  static bool AtLeastNumCharsRemaining(const char *str, size_t n) {
154    for (size_t i = 0; i < n; ++i) {
155      if (str[i] == '\0') {
156        return false;
157      }
158    }
159    return true;
160  }
161  static bool StrPrefix(const char *str, const char *prefix) {
162    size_t i = 0;
163    while (str[i] != '\0' && prefix[i] != '\0' && str[i] == prefix[i]) {
164      ++i;
165    }
166    return prefix[i] == '\0';  
167  }
168  static void InitState(State* state,
169                        const char* mangled,
170                        char* out,
171                        size_t out_size) {
172    state->mangled_begin = mangled;
173    state->out = out;
174    state->out_end_idx = static_cast<int>(out_size);
175    state->recursion_depth = 0;
176    state->steps = 0;
177    state->parse_state.mangled_idx = 0;
178    state->parse_state.out_cur_idx = 0;
179    state->parse_state.prev_name_idx = 0;
180    state->parse_state.prev_name_length = 0;
181    state->parse_state.nest_level = -1;
182    state->parse_state.append = true;
183  }
184  static inline const char *RemainingInput(State *state) {
185    return &state->mangled_begin[state->parse_state.mangled_idx];
186  }
187  static bool ParseOneCharToken(State *state, const char one_char_token) {
188    ComplexityGuard guard(state);
189    if (guard.IsTooComplex()) return false;
190    if (RemainingInput(state)[0] == one_char_token) {
191      ++state->parse_state.mangled_idx;
192      return true;
193    }
194    return false;
195  }
196  static bool ParseTwoCharToken(State *state, const char *two_char_token) {
197    ComplexityGuard guard(state);
198    if (guard.IsTooComplex()) return false;
199    if (RemainingInput(state)[0] == two_char_token[0] &&
200        RemainingInput(state)[1] == two_char_token[1]) {
201      state->parse_state.mangled_idx += 2;
202      return true;
203    }
204    return false;
205  }
206  static bool ParseCharClass(State *state, const char *char_class) {
207    ComplexityGuard guard(state);
208    if (guard.IsTooComplex()) return false;
209    if (RemainingInput(state)[0] == '\0') {
210      return false;
211    }
212    const char *p = char_class;
213    for (; *p != '\0'; ++p) {
214      if (RemainingInput(state)[0] == *p) {
215        ++state->parse_state.mangled_idx;
216        return true;
217      }
218    }
219    return false;
220  }
221  static bool ParseDigit(State *state, int *digit) {
222    char c = RemainingInput(state)[0];
223    if (ParseCharClass(state, "0123456789")) {
224      if (digit != nullptr) {
225        *digit = c - '0';
226      }
227      return true;
228    }
229    return false;
230  }
231  static bool Optional(bool &bsol;*status*/) { return true; }
232  typedef bool (*ParseFunc)(State *);
233  static bool OneOrMore(ParseFunc parse_func, State *state) {
234    if (parse_func(state)) {
235      while (parse_func(state)) {
236      }
237      return true;
238    }
239    return false;
240  }
241  static bool ZeroOrMore(ParseFunc parse_func, State *state) {
242    while (parse_func(state)) {
243    }
244    return true;
245  }
246  static void Append(State *state, const char *const str, const size_t length) {
247    for (size_t i = 0; i < length; ++i) {
248      if (state->parse_state.out_cur_idx + 1 <
249          state->out_end_idx) {  
250        state->out[state->parse_state.out_cur_idx++] = str[i];
251      } else {
252        state->parse_state.out_cur_idx = state->out_end_idx + 1;
253        break;
254      }
255    }
256    if (state->parse_state.out_cur_idx < state->out_end_idx) {
257      state->out[state->parse_state.out_cur_idx] =
258          '\0';  
259    }
260  }
261  static bool IsLower(char c) { return c >= 'a' && c <= 'z'; }
262  static bool IsAlpha(char c) {
263    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
264  }
265  static bool IsDigit(char c) { return c >= '0' && c <= '9'; }
266  static bool IsFunctionCloneSuffix(const char *str) {
267    size_t i = 0;
268    while (str[i] != '\0') {
269      bool parsed = false;
270      if (str[i] == '.' && (IsAlpha(str[i + 1]) || str[i + 1] == '_')) {
271        parsed = true;
272        i += 2;
273        while (IsAlpha(str[i]) || str[i] == '_') {
274          ++i;
275        }
276      }
277      if (str[i] == '.' && IsDigit(str[i + 1])) {
278        parsed = true;
279        i += 2;
280        while (IsDigit(str[i])) {
281          ++i;
282        }
283      }
284      if (!parsed)
285        return false;
286    }
287    return true;  
288  }
289  static bool EndsWith(State *state, const char chr) {
290    return state->parse_state.out_cur_idx > 0 &&
291           state->parse_state.out_cur_idx < state->out_end_idx &&
292           chr == state->out[state->parse_state.out_cur_idx - 1];
293  }
294  static void MaybeAppendWithLength(State *state, const char *const str,
295                                    const size_t length) {
296    if (state->parse_state.append && length > 0) {
297      if (str[0] == '<' && EndsWith(state, '<')) {
298        Append(state, " ", 1);
299      }
300      if (state->parse_state.out_cur_idx < state->out_end_idx &&
301          (IsAlpha(str[0]) || str[0] == '_')) {
302        state->parse_state.prev_name_idx = state->parse_state.out_cur_idx;
303        state->parse_state.prev_name_length = static_cast<unsigned int>(length);
304      }
305      Append(state, str, length);
306    }
307  }
308  static bool MaybeAppendDecimal(State *state, int val) {
309    constexpr size_t kMaxLength = 20;
310    char buf[kMaxLength];
311    if (state->parse_state.append) {
312      char *p = &buf[kMaxLength];
313      do {  
314        *--p = static_cast<char>((val % 10) + '0');
315        val /= 10;
316      } while (p > buf && val != 0);
317      Append(state, p, kMaxLength - static_cast<size_t>(p - buf));
318    }
319    return true;
320  }
321  static bool MaybeAppend(State *state, const char *const str) {
322    if (state->parse_state.append) {
323      size_t length = StrLen(str);
324      MaybeAppendWithLength(state, str, length);
325    }
326    return true;
327  }
328  static bool EnterNestedName(State *state) {
329    state->parse_state.nest_level = 0;
330    return true;
331  }
332  static bool LeaveNestedName(State *state, int16_t prev_value) {
333    state->parse_state.nest_level = prev_value;
334    return true;
335  }
336  static bool DisableAppend(State *state) {
337    state->parse_state.append = false;
338    return true;
339  }
340  static bool RestoreAppend(State *state, bool prev_value) {
341    state->parse_state.append = prev_value;
342    return true;
343  }
344  static void MaybeIncreaseNestLevel(State *state) {
345    if (state->parse_state.nest_level > -1) {
346      ++state->parse_state.nest_level;
347    }
348  }
349  static void MaybeAppendSeparator(State *state) {
350    if (state->parse_state.nest_level >= 1) {
351      MaybeAppend(state, "::");
352    }
353  }
354  static void MaybeCancelLastSeparator(State *state) {
355    if (state->parse_state.nest_level >= 1 && state->parse_state.append &&
356        state->parse_state.out_cur_idx >= 2) {
357      state->parse_state.out_cur_idx -= 2;
358      state->out[state->parse_state.out_cur_idx] = '\0';
359    }
360  }
361  static bool IdentifierIsAnonymousNamespace(State *state, size_t length) {
362    static const char anon_prefix[] = "_GLOBAL__N_";
363    return (length > (sizeof(anon_prefix) - 1) &&
364            StrPrefix(RemainingInput(state), anon_prefix));
365  }
366  static bool ParseMangledName(State *state);
367  static bool ParseEncoding(State *state);
368  static bool ParseName(State *state);
369  static bool ParseUnscopedName(State *state);
370  static bool ParseNestedName(State *state);
371  static bool ParsePrefix(State *state);
372  static bool ParseUnqualifiedName(State *state);
373  static bool ParseSourceName(State *state);
374  static bool ParseLocalSourceName(State *state);
375  static bool ParseUnnamedTypeName(State *state);
376  static bool ParseNumber(State *state, int *number_out);
377  static bool ParseFloatNumber(State *state);
378  static bool ParseSeqId(State *state);
379  static bool ParseIdentifier(State *state, size_t length);
380  static bool ParseOperatorName(State *state, int *arity);
381  static bool ParseSpecialName(State *state);
382  static bool ParseCallOffset(State *state);
383  static bool ParseNVOffset(State *state);
384  static bool ParseVOffset(State *state);
385  static bool ParseAbiTags(State *state);
386  static bool ParseCtorDtorName(State *state);
387  static bool ParseDecltype(State *state);
388  static bool ParseType(State *state);
389  static bool ParseCVQualifiers(State *state);
390  static bool ParseBuiltinType(State *state);
391  static bool ParseFunctionType(State *state);
392  static bool ParseBareFunctionType(State *state);
393  static bool ParseClassEnumType(State *state);
394  static bool ParseArrayType(State *state);
395  static bool ParsePointerToMemberType(State *state);
396  static bool ParseTemplateParam(State *state);
397  static bool ParseTemplateTemplateParam(State *state);
398  static bool ParseTemplateArgs(State *state);
399  static bool ParseTemplateArg(State *state);
400  static bool ParseBaseUnresolvedName(State *state);
401  static bool ParseUnresolvedName(State *state);
402  static bool ParseExpression(State *state);
403  static bool ParseExprPrimary(State *state);
404  static bool ParseExprCastValue(State *state);
405  static bool ParseLocalName(State *state);
406  static bool ParseLocalNameSuffix(State *state);
407  static bool ParseDiscriminator(State *state);
408  static bool ParseSubstitution(State *state, bool accept_std);
409  static bool ParseMangledName(State *state) {
410    ComplexityGuard guard(state);
411    if (guard.IsTooComplex()) return false;
412    return ParseTwoCharToken(state, "_Z") && ParseEncoding(state);
413  }
414  static bool ParseEncoding(State *state) {
415    ComplexityGuard guard(state);
416    if (guard.IsTooComplex()) return false;
417    if (ParseName(state) && Optional(ParseBareFunctionType(state))) {
418      return true;
419    }
420    if (ParseSpecialName(state)) {
421      return true;
422    }
423    return false;
424  }
425  static bool ParseName(State *state) {
426    ComplexityGuard guard(state);
427    if (guard.IsTooComplex()) return false;
428    if (ParseNestedName(state) || ParseLocalName(state)) {
429      return true;
430    }
431    ParseState copy = state->parse_state;
432    if (ParseSubstitution(state, &bsol;*accept_std=*/false) &&
433        ParseTemplateArgs(state)) {
434      return true;
435    }
436    state->parse_state = copy;
437    return ParseUnscopedName(state) && Optional(ParseTemplateArgs(state));
438  }
439  static bool ParseUnscopedName(State *state) {
440    ComplexityGuard guard(state);
441    if (guard.IsTooComplex()) return false;
442    if (ParseUnqualifiedName(state)) {
443      return true;
444    }
445    ParseState copy = state->parse_state;
446    if (ParseTwoCharToken(state, "St") && MaybeAppend(state, "std::") &&
447        ParseUnqualifiedName(state)) {
448      return true;
449    }
450    state->parse_state = copy;
451    return false;
452  }
453  static inline bool ParseRefQualifier(State *state) {
454    return ParseCharClass(state, "OR");
455  }
456  static bool ParseNestedName(State *state) {
457    ComplexityGuard guard(state);
458    if (guard.IsTooComplex()) return false;
459    ParseState copy = state->parse_state;
460    if (ParseOneCharToken(state, 'N') && EnterNestedName(state) &&
461        Optional(ParseCVQualifiers(state)) &&
462        Optional(ParseRefQualifier(state)) && ParsePrefix(state) &&
463        LeaveNestedName(state, copy.nest_level) &&
464        ParseOneCharToken(state, 'E')) {
465      return true;
466    }
467    state->parse_state = copy;
468    return false;
469  }
470  static bool ParsePrefix(State *state) {
471    ComplexityGuard guard(state);
472    if (guard.IsTooComplex()) return false;
473    bool has_something = false;
474    while (true) {
475      MaybeAppendSeparator(state);
476      if (ParseTemplateParam(state) ||
477          ParseSubstitution(state, &bsol;*accept_std=*/true) ||
478          ParseUnscopedName(state) ||
479          (ParseOneCharToken(state, 'M') && ParseUnnamedTypeName(state))) {
480        has_something = true;
481        MaybeIncreaseNestLevel(state);
482        continue;
483      }
484      MaybeCancelLastSeparator(state);
485      if (has_something && ParseTemplateArgs(state)) {
486        return ParsePrefix(state);
487      } else {
488        break;
489      }
490    }
491    return true;
492  }
493  static bool ParseUnqualifiedName(State *state) {
494    ComplexityGuard guard(state);
495    if (guard.IsTooComplex()) return false;
496    if (ParseOperatorName(state, nullptr) || ParseCtorDtorName(state) ||
497        ParseSourceName(state) || ParseLocalSourceName(state) ||
498        ParseUnnamedTypeName(state)) {
499      return ParseAbiTags(state);
500    }
501    return false;
502  }
503  static bool ParseAbiTags(State *state) {
504    ComplexityGuard guard(state);
505    if (guard.IsTooComplex()) return false;
506    while (ParseOneCharToken(state, 'B')) {
507      ParseState copy = state->parse_state;
508      MaybeAppend(state, "[abi:");
509      if (!ParseSourceName(state)) {
510        state->parse_state = copy;
511        return false;
512      }
513      MaybeAppend(state, "]");
514    }
515    return true;
516  }
517  static bool ParseSourceName(State *state) {
518    ComplexityGuard guard(state);
519    if (guard.IsTooComplex()) return false;
520    ParseState copy = state->parse_state;
521    int length = -1;
522    if (ParseNumber(state, &length) &&
523        ParseIdentifier(state, static_cast<size_t>(length))) {
524      return true;
525    }
526    state->parse_state = copy;
527    return false;
528  }
529  static bool ParseLocalSourceName(State *state) {
530    ComplexityGuard guard(state);
531    if (guard.IsTooComplex()) return false;
532    ParseState copy = state->parse_state;
533    if (ParseOneCharToken(state, 'L') && ParseSourceName(state) &&
534        Optional(ParseDiscriminator(state))) {
535      return true;
536    }
537    state->parse_state = copy;
538    return false;
539  }
540  static bool ParseUnnamedTypeName(State *state) {
541    ComplexityGuard guard(state);
542    if (guard.IsTooComplex()) return false;
543    ParseState copy = state->parse_state;
544    int which = -1;
545    if (ParseTwoCharToken(state, "Ut") && Optional(ParseNumber(state, &which)) &&
546        which <= std::numeric_limits<int>::max() - 2 &&  
547        ParseOneCharToken(state, '_')) {
548      MaybeAppend(state, "{unnamed type#");
549      MaybeAppendDecimal(state, 2 + which);
550      MaybeAppend(state, "}");
551      return true;
552    }
553    state->parse_state = copy;
554    which = -1;
555    if (ParseTwoCharToken(state, "Ul") && DisableAppend(state) &&
556        OneOrMore(ParseType, state) && RestoreAppend(state, copy.append) &&
557        ParseOneCharToken(state, 'E') && Optional(ParseNumber(state, &which)) &&
558        which <= std::numeric_limits<int>::max() - 2 &&  
559        ParseOneCharToken(state, '_')) {
560      MaybeAppend(state, "{lambda()#");
561      MaybeAppendDecimal(state, 2 + which);
562      MaybeAppend(state, "}");
563      return true;
564    }
565    state->parse_state = copy;
566    return false;
567  }
568  static bool ParseNumber(State *state, int *number_out) {
569    ComplexityGuard guard(state);
570    if (guard.IsTooComplex()) return false;
571    bool negative = false;
572    if (ParseOneCharToken(state, 'n')) {
573      negative = true;
574    }
575    const char *p = RemainingInput(state);
576    uint64_t number = 0;
577    for (; *p != '\0'; ++p) {
578      if (IsDigit(*p)) {
579        number = number * 10 + static_cast<uint64_t>(*p - '0');
580      } else {
581        break;
582      }
583    }
584    if (negative) {
585      number = ~number + 1;
586    }
587    if (p != RemainingInput(state)) {  
588      state->parse_state.mangled_idx += p - RemainingInput(state);
589      if (number_out != nullptr) {
590        *number_out = static_cast<int>(number);
591      }
592      return true;
593    }
594    return false;
595  }
596  static bool ParseFloatNumber(State *state) {
597    ComplexityGuard guard(state);
598    if (guard.IsTooComplex()) return false;
599    const char *p = RemainingInput(state);
600    for (; *p != '\0'; ++p) {
601      if (!IsDigit(*p) && !(*p >= 'a' && *p <= 'f')) {
602        break;
603      }
604    }
605    if (p != RemainingInput(state)) {  
606      state->parse_state.mangled_idx += p - RemainingInput(state);
607      return true;
608    }
609    return false;
610  }
611  static bool ParseSeqId(State *state) {
612    ComplexityGuard guard(state);
613    if (guard.IsTooComplex()) return false;
614    const char *p = RemainingInput(state);
615    for (; *p != '\0'; ++p) {
616      if (!IsDigit(*p) && !(*p >= 'A' && *p <= 'Z')) {
617        break;
618      }
619    }
620    if (p != RemainingInput(state)) {  
621      state->parse_state.mangled_idx += p - RemainingInput(state);
622      return true;
623    }
624    return false;
625  }
626  static bool ParseIdentifier(State *state, size_t length) {
627    ComplexityGuard guard(state);
628    if (guard.IsTooComplex()) return false;
629    if (!AtLeastNumCharsRemaining(RemainingInput(state), length)) {
630      return false;
631    }
632    if (IdentifierIsAnonymousNamespace(state, length)) {
633      MaybeAppend(state, "(anonymous namespace)");
634    } else {
635      MaybeAppendWithLength(state, RemainingInput(state), length);
636    }
637    state->parse_state.mangled_idx += length;
638    return true;
639  }
640  static bool ParseOperatorName(State *state, int *arity) {
641    ComplexityGuard guard(state);
642    if (guard.IsTooComplex()) return false;
643    if (!AtLeastNumCharsRemaining(RemainingInput(state), 2)) {
644      return false;
645    }
646    ParseState copy = state->parse_state;
647    if (ParseTwoCharToken(state, "cv") && MaybeAppend(state, "operator ") &&
648        EnterNestedName(state) && ParseType(state) &&
649        LeaveNestedName(state, copy.nest_level)) {
650      if (arity != nullptr) {
651        *arity = 1;
652      }
653      return true;
654    }
655    state->parse_state = copy;
656    if (ParseOneCharToken(state, 'v') && ParseDigit(state, arity) &&
657        ParseSourceName(state)) {
658      return true;
659    }
660    state->parse_state = copy;
661    if (!(IsLower(RemainingInput(state)[0]) &&
662          IsAlpha(RemainingInput(state)[1]))) {
663      return false;
664    }
665    const AbbrevPair *p;
666    for (p = kOperatorList; p->abbrev != nullptr; ++p) {
667      if (RemainingInput(state)[0] == p->abbrev[0] &&
668          RemainingInput(state)[1] == p->abbrev[1]) {
669        if (arity != nullptr) {
670          *arity = p->arity;
671        }
672        MaybeAppend(state, "operator");
673        if (IsLower(*p->real_name)) {  
674          MaybeAppend(state, " ");
675        }
676        MaybeAppend(state, p->real_name);
677        state->parse_state.mangled_idx += 2;
678        return true;
679      }
680    }
681    return false;
682  }
683  static bool ParseSpecialName(State *state) {
684    ComplexityGuard guard(state);
685    if (guard.IsTooComplex()) return false;
686    ParseState copy = state->parse_state;
687    if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "VTISH") &&
688        ParseType(state)) {
689      return true;
690    }
691    state->parse_state = copy;
692    if (ParseTwoCharToken(state, "Tc") && ParseCallOffset(state) &&
693        ParseCallOffset(state) && ParseEncoding(state)) {
694      return true;
695    }
696    state->parse_state = copy;
697    if (ParseTwoCharToken(state, "GV") && ParseName(state)) {
698      return true;
699    }
700    state->parse_state = copy;
701    if (ParseOneCharToken(state, 'T') && ParseCallOffset(state) &&
702        ParseEncoding(state)) {
703      return true;
704    }
705    state->parse_state = copy;
706    if (ParseTwoCharToken(state, "TC") && ParseType(state) &&
707        ParseNumber(state, nullptr) && ParseOneCharToken(state, '_') &&
708        DisableAppend(state) && ParseType(state)) {
709      RestoreAppend(state, copy.append);
710      return true;
711    }
712    state->parse_state = copy;
713    if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "FJ") &&
714        ParseType(state)) {
715      return true;
716    }
717    state->parse_state = copy;
718    if (ParseTwoCharToken(state, "GR") && ParseName(state)) {
719      return true;
720    }
721    state->parse_state = copy;
722    if (ParseTwoCharToken(state, "GA") && ParseEncoding(state)) {
723      return true;
724    }
725    state->parse_state = copy;
726    if (ParseOneCharToken(state, 'T') && ParseCharClass(state, "hv") &&
727        ParseCallOffset(state) && ParseEncoding(state)) {
728      return true;
729    }
730    state->parse_state = copy;
731    return false;
732  }
733  static bool ParseCallOffset(State *state) {
734    ComplexityGuard guard(state);
735    if (guard.IsTooComplex()) return false;
736    ParseState copy = state->parse_state;
737    if (ParseOneCharToken(state, 'h') && ParseNVOffset(state) &&
738        ParseOneCharToken(state, '_')) {
739      return true;
740    }
741    state->parse_state = copy;
742    if (ParseOneCharToken(state, 'v') && ParseVOffset(state) &&
743        ParseOneCharToken(state, '_')) {
744      return true;
745    }
746    state->parse_state = copy;
747    return false;
748  }
749  static bool ParseNVOffset(State *state) {
750    ComplexityGuard guard(state);
751    if (guard.IsTooComplex()) return false;
752    return ParseNumber(state, nullptr);
753  }
754  static bool ParseVOffset(State *state) {
755    ComplexityGuard guard(state);
756    if (guard.IsTooComplex()) return false;
757    ParseState copy = state->parse_state;
758    if (ParseNumber(state, nullptr) && ParseOneCharToken(state, '_') &&
759        ParseNumber(state, nullptr)) {
760      return true;
761    }
762    state->parse_state = copy;
763    return false;
764  }
765  static bool ParseCtorDtorName(State *state) {
766    ComplexityGuard guard(state);
767    if (guard.IsTooComplex()) return false;
768    ParseState copy = state->parse_state;
769    if (ParseOneCharToken(state, 'C')) {
770      if (ParseCharClass(state, "1234")) {
771        const char *const prev_name =
772            state->out + state->parse_state.prev_name_idx;
773        MaybeAppendWithLength(state, prev_name,
774                              state->parse_state.prev_name_length);
775        return true;
776      } else if (ParseOneCharToken(state, 'I') && ParseCharClass(state, "12") &&
777                 ParseClassEnumType(state)) {
778        return true;
779      }
780    }
781    state->parse_state = copy;
782    if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "0124")) {
783      const char *const prev_name = state->out + state->parse_state.prev_name_idx;
784      MaybeAppend(state, "~");
<span onclick='openModal()' class='match'>785      MaybeAppendWithLength(state, prev_name,
786                            state->parse_state.prev_name_length);
787      return true;
788    }
789    state->parse_state = copy;
</span>790    return false;
791  }
792  static bool ParseDecltype(State *state) {
793    ComplexityGuard guard(state);
794    if (guard.IsTooComplex()) return false;
795    ParseState copy = state->parse_state;
796    if (ParseOneCharToken(state, 'D') && ParseCharClass(state, "tT") &&
797        ParseExpression(state) && ParseOneCharToken(state, 'E')) {
798      return true;
799    }
800    state->parse_state = copy;
801    return false;
802  }
803  static bool ParseType(State *state) {
804    ComplexityGuard guard(state);
805    if (guard.IsTooComplex()) return false;
806    ParseState copy = state->parse_state;
807    if (ParseCVQualifiers(state)) {
808      const bool result = ParseType(state);
809      if (!result) state->parse_state = copy;
810      return result;
811    }
812    state->parse_state = copy;
813    if (ParseCharClass(state, "OPRCG")) {
814      const bool result = ParseType(state);
815      if (!result) state->parse_state = copy;
816      return result;
817    }
818    state->parse_state = copy;
819    if (ParseTwoCharToken(state, "Dp") && ParseType(state)) {
820      return true;
821    }
822    state->parse_state = copy;
823    if (ParseOneCharToken(state, 'U') && ParseSourceName(state) &&
824        ParseType(state)) {
825      return true;
826    }
827    state->parse_state = copy;
828    if (ParseBuiltinType(state) || ParseFunctionType(state) ||
829        ParseClassEnumType(state) || ParseArrayType(state) ||
830        ParsePointerToMemberType(state) || ParseDecltype(state) ||
831        ParseSubstitution(state, &bsol;*accept_std=*/false)) {
832      return true;
833    }
834    if (ParseTemplateTemplateParam(state) && ParseTemplateArgs(state)) {
835      return true;
836    }
837    state->parse_state = copy;
838    if (ParseTemplateParam(state)) {
839      return true;
840    }
841    if (ParseTwoCharToken(state, "Dv") && ParseNumber(state, nullptr) &&
842        ParseOneCharToken(state, '_')) {
843      return true;
844    }
845    state->parse_state = copy;
846    return false;
847  }
848  static bool ParseCVQualifiers(State *state) {
849    ComplexityGuard guard(state);
850    if (guard.IsTooComplex()) return false;
851    int num_cv_qualifiers = 0;
852    num_cv_qualifiers += ParseOneCharToken(state, 'r');
853    num_cv_qualifiers += ParseOneCharToken(state, 'V');
854    num_cv_qualifiers += ParseOneCharToken(state, 'K');
855    return num_cv_qualifiers > 0;
856  }
857  static bool ParseBuiltinType(State *state) {
858    ComplexityGuard guard(state);
859    if (guard.IsTooComplex()) return false;
860    const AbbrevPair *p;
861    for (p = kBuiltinTypeList; p->abbrev != nullptr; ++p) {
862      if (p->abbrev[1] == '\0') {
863        if (ParseOneCharToken(state, p->abbrev[0])) {
864          MaybeAppend(state, p->real_name);
865          return true;
866        }
867      } else if (p->abbrev[2] == '\0' && ParseTwoCharToken(state, p->abbrev)) {
868        MaybeAppend(state, p->real_name);
869        return true;
870      }
871    }
872    ParseState copy = state->parse_state;
873    if (ParseOneCharToken(state, 'u') && ParseSourceName(state)) {
874      return true;
875    }
876    state->parse_state = copy;
877    return false;
878  }
879  static bool ParseExceptionSpec(State *state) {
880    ComplexityGuard guard(state);
881    if (guard.IsTooComplex()) return false;
882    if (ParseTwoCharToken(state, "Do")) return true;
883    ParseState copy = state->parse_state;
884    if (ParseTwoCharToken(state, "DO") && ParseExpression(state) &&
885        ParseOneCharToken(state, 'E')) {
886      return true;
887    }
888    state->parse_state = copy;
889    if (ParseTwoCharToken(state, "Dw") && OneOrMore(ParseType, state) &&
890        ParseOneCharToken(state, 'E')) {
891      return true;
892    }
893    state->parse_state = copy;
894    return false;
895  }
896  static bool ParseFunctionType(State *state) {
897    ComplexityGuard guard(state);
898    if (guard.IsTooComplex()) return false;
899    ParseState copy = state->parse_state;
900    if (Optional(ParseExceptionSpec(state)) && ParseOneCharToken(state, 'F') &&
901        Optional(ParseOneCharToken(state, 'Y')) && ParseBareFunctionType(state) &&
902        Optional(ParseOneCharToken(state, 'O')) &&
903        ParseOneCharToken(state, 'E')) {
904      return true;
905    }
906    state->parse_state = copy;
907    return false;
908  }
909  static bool ParseBareFunctionType(State *state) {
910    ComplexityGuard guard(state);
911    if (guard.IsTooComplex()) return false;
912    ParseState copy = state->parse_state;
913    DisableAppend(state);
914    if (OneOrMore(ParseType, state)) {
915      RestoreAppend(state, copy.append);
916      MaybeAppend(state, "()");
917      return true;
918    }
919    state->parse_state = copy;
920    return false;
921  }
922  static bool ParseClassEnumType(State *state) {
923    ComplexityGuard guard(state);
924    if (guard.IsTooComplex()) return false;
925    return ParseName(state);
926  }
927  static bool ParseArrayType(State *state) {
928    ComplexityGuard guard(state);
929    if (guard.IsTooComplex()) return false;
930    ParseState copy = state->parse_state;
931    if (ParseOneCharToken(state, 'A') && ParseNumber(state, nullptr) &&
932        ParseOneCharToken(state, '_') && ParseType(state)) {
933      return true;
934    }
935    state->parse_state = copy;
936    if (ParseOneCharToken(state, 'A') && Optional(ParseExpression(state)) &&
937        ParseOneCharToken(state, '_') && ParseType(state)) {
938      return true;
939    }
940    state->parse_state = copy;
941    return false;
942  }
943  static bool ParsePointerToMemberType(State *state) {
944    ComplexityGuard guard(state);
945    if (guard.IsTooComplex()) return false;
946    ParseState copy = state->parse_state;
947    if (ParseOneCharToken(state, 'M') && ParseType(state) && ParseType(state)) {
948      return true;
949    }
950    state->parse_state = copy;
951    return false;
952  }
953  static bool ParseTemplateParam(State *state) {
954    ComplexityGuard guard(state);
955    if (guard.IsTooComplex()) return false;
956    if (ParseTwoCharToken(state, "T_")) {
957      MaybeAppend(state, "?");  
958      return true;
959    }
960    ParseState copy = state->parse_state;
961    if (ParseOneCharToken(state, 'T') && ParseNumber(state, nullptr) &&
962        ParseOneCharToken(state, '_')) {
963      MaybeAppend(state, "?");  
964      return true;
965    }
966    state->parse_state = copy;
967    return false;
968  }
969  static bool ParseTemplateTemplateParam(State *state) {
970    ComplexityGuard guard(state);
971    if (guard.IsTooComplex()) return false;
972    return (ParseTemplateParam(state) ||
973            ParseSubstitution(state, &bsol;*accept_std=*/false));
974  }
975  static bool ParseTemplateArgs(State *state) {
976    ComplexityGuard guard(state);
977    if (guard.IsTooComplex()) return false;
978    ParseState copy = state->parse_state;
979    DisableAppend(state);
980    if (ParseOneCharToken(state, 'I') && OneOrMore(ParseTemplateArg, state) &&
981        ParseOneCharToken(state, 'E')) {
982      RestoreAppend(state, copy.append);
983      MaybeAppend(state, "<>");
984      return true;
985    }
986    state->parse_state = copy;
987    return false;
988  }
989  static bool ParseTemplateArg(State *state) {
990    ComplexityGuard guard(state);
991    if (guard.IsTooComplex()) return false;
992    ParseState copy = state->parse_state;
993    if (ParseOneCharToken(state, 'J') && ZeroOrMore(ParseTemplateArg, state) &&
994        ParseOneCharToken(state, 'E')) {
995      return true;
996    }
997    state->parse_state = copy;
998    if (ParseLocalSourceName(state) && Optional(ParseTemplateArgs(state))) {
999      copy = state->parse_state;
1000      if (ParseExprCastValue(state) && ParseOneCharToken(state, 'E')) {
1001        return true;
1002      }
1003      state->parse_state = copy;
1004      return true;
1005    }
1006    if (ParseType(state) || ParseExprPrimary(state)) {
1007      return true;
1008    }
1009    state->parse_state = copy;
1010    if (ParseOneCharToken(state, 'X') && ParseExpression(state) &&
1011        ParseOneCharToken(state, 'E')) {
1012      return true;
1013    }
1014    state->parse_state = copy;
1015    return false;
1016  }
1017  static inline bool ParseUnresolvedType(State *state) {
1018    return (ParseTemplateParam(state) && Optional(ParseTemplateArgs(state))) ||
1019           ParseDecltype(state) || ParseSubstitution(state, &bsol;*accept_std=*/false);
1020  }
1021  static inline bool ParseSimpleId(State *state) {
1022    return ParseSourceName(state) && Optional(ParseTemplateArgs(state));
1023  }
1024  static bool ParseBaseUnresolvedName(State *state) {
1025    ComplexityGuard guard(state);
1026    if (guard.IsTooComplex()) return false;
1027    if (ParseSimpleId(state)) {
1028      return true;
1029    }
1030    ParseState copy = state->parse_state;
1031    if (ParseTwoCharToken(state, "on") && ParseOperatorName(state, nullptr) &&
1032        Optional(ParseTemplateArgs(state))) {
1033      return true;
1034    }
1035    state->parse_state = copy;
1036    if (ParseTwoCharToken(state, "dn") &&
1037        (ParseUnresolvedType(state) || ParseSimpleId(state))) {
1038      return true;
1039    }
1040    state->parse_state = copy;
1041    return false;
1042  }
1043  static bool ParseUnresolvedName(State *state) {
1044    ComplexityGuard guard(state);
1045    if (guard.IsTooComplex()) return false;
1046    ParseState copy = state->parse_state;
1047    if (Optional(ParseTwoCharToken(state, "gs")) &&
1048        ParseBaseUnresolvedName(state)) {
1049      return true;
1050    }
1051    state->parse_state = copy;
1052    if (ParseTwoCharToken(state, "sr") && ParseUnresolvedType(state) &&
1053        ParseBaseUnresolvedName(state)) {
1054      return true;
1055    }
1056    state->parse_state = copy;
1057    if (ParseTwoCharToken(state, "sr") && ParseOneCharToken(state, 'N') &&
1058        ParseUnresolvedType(state) &&
1059        OneOrMore(&bsol;* <unresolved-qualifier-level> ::= */ ParseSimpleId, state) &&
1060        ParseOneCharToken(state, 'E') && ParseBaseUnresolvedName(state)) {
1061      return true;
1062    }
1063    state->parse_state = copy;
1064    if (Optional(ParseTwoCharToken(state, "gs")) &&
1065        ParseTwoCharToken(state, "sr") &&
1066        OneOrMore(&bsol;* <unresolved-qualifier-level> ::= */ ParseSimpleId, state) &&
1067        ParseOneCharToken(state, 'E') && ParseBaseUnresolvedName(state)) {
1068      return true;
1069    }
1070    state->parse_state = copy;
1071    return false;
1072  }
1073  static bool ParseExpression(State *state) {
1074    ComplexityGuard guard(state);
1075    if (guard.IsTooComplex()) return false;
1076    if (ParseTemplateParam(state) || ParseExprPrimary(state)) {
1077      return true;
1078    }
1079    ParseState copy = state->parse_state;
1080    if (ParseTwoCharToken(state, "cl") && OneOrMore(ParseExpression, state) &&
1081        ParseOneCharToken(state, 'E')) {
1082      return true;
1083    }
1084    state->parse_state = copy;
1085    if (ParseTwoCharToken(state, "cp") && ParseSimpleId(state) &&
1086        ZeroOrMore(ParseExpression, state) && ParseOneCharToken(state, 'E')) {
1087      return true;
1088    }
1089    state->parse_state = copy;
1090    if (ParseTwoCharToken(state, "fp") && Optional(ParseCVQualifiers(state)) &&
1091        Optional(ParseNumber(state, nullptr)) && ParseOneCharToken(state, '_')) {
1092      return true;
1093    }
1094    state->parse_state = copy;
1095    if (ParseTwoCharToken(state, "fL") && Optional(ParseNumber(state, nullptr)) &&
1096        ParseOneCharToken(state, 'p') && Optional(ParseCVQualifiers(state)) &&
1097        Optional(ParseNumber(state, nullptr)) && ParseOneCharToken(state, '_')) {
1098      return true;
1099    }
1100    state->parse_state = copy;
1101    if (ParseTwoCharToken(state, "cv")) {
1102      if (ParseType(state)) {
1103        ParseState copy2 = state->parse_state;
1104        if (ParseOneCharToken(state, '_') && ZeroOrMore(ParseExpression, state) &&
1105            ParseOneCharToken(state, 'E')) {
1106          return true;
1107        }
1108        state->parse_state = copy2;
1109        if (ParseExpression(state)) {
1110          return true;
1111        }
1112      }
1113    } else {
1114      int arity = -1;
1115      if (ParseOperatorName(state, &arity) &&
1116          arity > 0 &&  
1117          (arity < 3 || ParseExpression(state)) &&
1118          (arity < 2 || ParseExpression(state)) &&
1119          (arity < 1 || ParseExpression(state))) {
1120        return true;
1121      }
1122    }
1123    state->parse_state = copy;
1124    if (ParseTwoCharToken(state, "st") && ParseType(state)) {
1125      return true;
1126    }
1127    state->parse_state = copy;
1128    if ((ParseTwoCharToken(state, "dt") || ParseTwoCharToken(state, "pt")) &&
1129        ParseExpression(state) && ParseType(state)) {
1130      return true;
1131    }
1132    state->parse_state = copy;
1133    if (ParseTwoCharToken(state, "ds") && ParseExpression(state) &&
1134        ParseExpression(state)) {
1135      return true;
1136    }
1137    state->parse_state = copy;
1138    if (ParseTwoCharToken(state, "sp") && ParseExpression(state)) {
1139      return true;
1140    }
1141    state->parse_state = copy;
1142    return ParseUnresolvedName(state);
1143  }
1144  static bool ParseExprPrimary(State *state) {
1145    ComplexityGuard guard(state);
1146    if (guard.IsTooComplex()) return false;
1147    ParseState copy = state->parse_state;
1148    if (ParseTwoCharToken(state, "LZ")) {
1149      if (ParseEncoding(state) && ParseOneCharToken(state, 'E')) {
1150        return true;
1151      }
1152      state->parse_state = copy;
1153      return false;
1154    }
1155    if (ParseOneCharToken(state, 'L') && ParseType(state) &&
1156        ParseExprCastValue(state)) {
1157      return true;
1158    }
1159    state->parse_state = copy;
1160    if (ParseOneCharToken(state, 'L') && ParseMangledName(state) &&
1161        ParseOneCharToken(state, 'E')) {
1162      return true;
1163    }
1164    state->parse_state = copy;
1165    return false;
1166  }
1167  static bool ParseExprCastValue(State *state) {
1168    ComplexityGuard guard(state);
1169    if (guard.IsTooComplex()) return false;
1170    ParseState copy = state->parse_state;
1171    if (ParseNumber(state, nullptr) && ParseOneCharToken(state, 'E')) {
1172      return true;
1173    }
1174    state->parse_state = copy;
1175    if (ParseFloatNumber(state) && ParseOneCharToken(state, 'E')) {
1176      return true;
1177    }
1178    state->parse_state = copy;
1179    return false;
1180  }
1181  static bool ParseLocalNameSuffix(State *state) {
1182    ComplexityGuard guard(state);
1183    if (guard.IsTooComplex()) return false;
1184    if (MaybeAppend(state, "::") && ParseName(state) &&
1185        Optional(ParseDiscriminator(state))) {
1186      return true;
1187    }
1188    if (state->parse_state.append) {
1189      state->out[state->parse_state.out_cur_idx - 2] = '\0';
1190    }
1191    return ParseOneCharToken(state, 's') && Optional(ParseDiscriminator(state));
1192  }
1193  static bool ParseLocalName(State *state) {
1194    ComplexityGuard guard(state);
1195    if (guard.IsTooComplex()) return false;
1196    ParseState copy = state->parse_state;
1197    if (ParseOneCharToken(state, 'Z') && ParseEncoding(state) &&
1198        ParseOneCharToken(state, 'E') && ParseLocalNameSuffix(state)) {
1199      return true;
1200    }
1201    state->parse_state = copy;
1202    return false;
1203  }
1204  static bool ParseDiscriminator(State *state) {
1205    ComplexityGuard guard(state);
1206    if (guard.IsTooComplex()) return false;
1207    ParseState copy = state->parse_state;
1208    if (ParseOneCharToken(state, '_') && ParseNumber(state, nullptr)) {
1209      return true;
1210    }
1211    state->parse_state = copy;
1212    return false;
1213  }
1214  static bool ParseSubstitution(State *state, bool accept_std) {
1215    ComplexityGuard guard(state);
1216    if (guard.IsTooComplex()) return false;
1217    if (ParseTwoCharToken(state, "S_")) {
1218      MaybeAppend(state, "?");  
1219      return true;
1220    }
1221    ParseState copy = state->parse_state;
1222    if (ParseOneCharToken(state, 'S') && ParseSeqId(state) &&
1223        ParseOneCharToken(state, '_')) {
1224      MaybeAppend(state, "?");  
1225      return true;
1226    }
1227    state->parse_state = copy;
1228    if (ParseOneCharToken(state, 'S')) {
1229      const AbbrevPair *p;
1230      for (p = kSubstitutionList; p->abbrev != nullptr; ++p) {
1231        if (RemainingInput(state)[0] == p->abbrev[1] &&
1232            (accept_std || p->abbrev[1] != 't')) {
1233          MaybeAppend(state, "std");
1234          if (p->real_name[0] != '\0') {
1235            MaybeAppend(state, "::");
1236            MaybeAppend(state, p->real_name);
1237          }
1238          ++state->parse_state.mangled_idx;
1239          return true;
1240        }
1241      }
1242    }
1243    state->parse_state = copy;
1244    return false;
1245  }
1246  static bool ParseTopLevelMangledName(State *state) {
1247    ComplexityGuard guard(state);
1248    if (guard.IsTooComplex()) return false;
1249    if (ParseMangledName(state)) {
1250      if (RemainingInput(state)[0] != '\0') {
1251        if (IsFunctionCloneSuffix(RemainingInput(state))) {
1252          return true;
1253        }
1254        if (RemainingInput(state)[0] == '@') {
1255          MaybeAppend(state, RemainingInput(state));
1256          return true;
1257        }
1258        return false;  
1259      }
1260      return true;
1261    }
1262    return false;
1263  }
1264  static bool Overflowed(const State *state) {
1265    return state->parse_state.out_cur_idx >= state->out_end_idx;
1266  }
1267  bool Demangle(const char* mangled, char* out, size_t out_size) {
1268    State state;
1269    InitState(&state, mangled, out, out_size);
1270    return ParseTopLevelMangledName(&state) && !Overflowed(&state) &&
1271           state.parse_state.out_cur_idx > 0;
1272  }
1273  }  
1274  ABSL_NAMESPACE_END
1275  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-demangle.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-demangle.cc</div>
                </div>
                <div class="column column_space"><pre><code>773        MaybeAppendWithLength(state, prev_name,
774                              state->parse_state.prev_name_length);
775        return true;
776      } else if (ParseOneCharToken(state, 'I') && ParseCharClass(state, "12") &&
</pre></code></div>
                <div class="column column_space"><pre><code>785      MaybeAppendWithLength(state, prev_name,
786                            state->parse_state.prev_name_length);
787      return true;
788    }
789    state->parse_state = copy;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    