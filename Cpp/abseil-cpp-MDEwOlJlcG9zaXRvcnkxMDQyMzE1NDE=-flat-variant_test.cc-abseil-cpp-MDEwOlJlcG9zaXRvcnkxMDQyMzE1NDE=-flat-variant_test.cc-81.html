
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 82, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_test.cc</h3>
            <pre><code>1  #include &quot;absl/types/variant.h&quot;
2  #if !defined(ABSL_USES_STD_VARIANT)
3  #include &lt;algorithm&gt;
4  #include &lt;cstddef&gt;
5  #include &lt;functional&gt;
6  #include &lt;initializer_list&gt;
7  #include &lt;memory&gt;
8  #include &lt;ostream&gt;
9  #include &lt;queue&gt;
10  #include &lt;type_traits&gt;
11  #include &lt;unordered_set&gt;
12  #include &lt;utility&gt;
13  #include &lt;vector&gt;
14  #include &quot;gmock/gmock.h&quot;
15  #include &quot;gtest/gtest.h&quot;
16  #include &quot;absl/base/config.h&quot;
17  #include &quot;absl/base/port.h&quot;
18  #include &quot;absl/memory/memory.h&quot;
19  #include &quot;absl/meta/type_traits.h&quot;
20  #include &quot;absl/strings/string_view.h&quot;
21  #ifdef ABSL_HAVE_EXCEPTIONS
22  #define ABSL_VARIANT_TEST_EXPECT_FAIL(expr, exception_t, text) \
23    EXPECT_THROW(expr, exception_t)
24  #else
25  #define ABSL_VARIANT_TEST_EXPECT_FAIL(expr, exception_t, text) \
26    EXPECT_DEATH_IF_SUPPORTED(expr, text)
27  #endif  
28  #define ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(...)                 \
29    ABSL_VARIANT_TEST_EXPECT_FAIL((void)(__VA_ARGS__), absl::bad_variant_access, \
30                                  &quot;Bad variant access&quot;)
31  struct Hashable {};
32  namespace std {
33  template &lt;&gt;
34  struct hash&lt;Hashable&gt; {
35    size_t operator()(const Hashable&amp;);
36  };
37  }  
38  struct NonHashable {};
39  namespace absl {
40  ABSL_NAMESPACE_BEGIN
41  namespace {
42  using ::testing::DoubleEq;
43  using ::testing::Pointee;
44  using ::testing::VariantWith;
45  struct MoveCanThrow {
46    MoveCanThrow() : v(0) {}
47    MoveCanThrow(int v) : v(v) {}  
48    MoveCanThrow(const MoveCanThrow&amp; other) : v(other.v) {}
49    MoveCanThrow&amp; operator=(const MoveCanThrow&amp; &amp;bsol;*other*/) { return *this; }
50    int v;
51  };
52  bool operator==(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v == rhs.v; }
53  bool operator!=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v != rhs.v; }
54  bool operator&lt;(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v &lt; rhs.v; }
55  bool operator&lt;=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v &lt;= rhs.v; }
56  bool operator&gt;=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v &gt;= rhs.v; }
57  bool operator&gt;(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v &gt; rhs.v; }
58  struct SpecialSwap {
59    explicit SpecialSwap(int i) : i(i) {}
60    friend void swap(SpecialSwap&amp; a, SpecialSwap&amp; b) {
61      a.special_swap = b.special_swap = true;
62      std::swap(a.i, b.i);
63    }
64    bool operator==(SpecialSwap other) const { return i == other.i; }
65    int i;
66    bool special_swap = false;
67  };
68  struct MoveOnlyWithListConstructor {
69    MoveOnlyWithListConstructor() = default;
70    explicit MoveOnlyWithListConstructor(std::initializer_list&lt;int&gt; &amp;bsol;*ilist*/,
71                                         int value)
72        : value(value) {}
73    MoveOnlyWithListConstructor(MoveOnlyWithListConstructor&amp;&amp;) = default;
74    MoveOnlyWithListConstructor&amp; operator=(MoveOnlyWithListConstructor&amp;&amp;) =
75        default;
76    int value = 0;
77  };
78  #ifdef ABSL_HAVE_EXCEPTIONS
79  struct ConversionException {};
80  template &lt;class T&gt;
81  struct ExceptionOnConversion {
82    operator T() const {  
83      throw ConversionException();
84    }
85  };
86  template &lt;class H, class... T&gt;
87  void ToValuelessByException(absl::variant&lt;H, T...&gt;&amp; v) {  
88    try {
89      v.template emplace&lt;0&gt;(ExceptionOnConversion&lt;H&gt;());
90    } catch (ConversionException&amp; &amp;bsol;*e*/) {
91    }
92  }
93  #endif  
94  template&lt;typename T, size_t N&gt;
95  struct ValueHolder {
96    explicit ValueHolder(const T&amp; x) : value(x) {}
97    typedef T value_type;
98    value_type value;
99    static const size_t kIndex = N;
100  };
101  template&lt;typename T, size_t N&gt;
102  const size_t ValueHolder&lt;T, N&gt;::kIndex;
103  template&lt;typename T, size_t N&gt;
104  inline bool operator==(const ValueHolder&lt;T, N&gt;&amp; left,
105                         const ValueHolder&lt;T, N&gt;&amp; right) {
106    return left.value == right.value;
107  }
108  template&lt;typename T, size_t N&gt;
109  inline bool operator!=(const ValueHolder&lt;T, N&gt;&amp; left,
110                         const ValueHolder&lt;T, N&gt;&amp; right) {
111    return left.value != right.value;
112  }
113  template&lt;typename T, size_t N&gt;
114  inline std::ostream&amp; operator&lt;&lt;(
115      std::ostream&amp; stream, const ValueHolder&lt;T, N&gt;&amp; object) {
116    return stream &lt;&lt; object.value;
117  }
118  template&lt;typename T&gt;
119  struct VariantFactory {
120    typedef variant&lt;ValueHolder&lt;T, 1&gt;, ValueHolder&lt;T, 2&gt;, ValueHolder&lt;T, 3&gt;,
121                    ValueHolder&lt;T, 4&gt;&gt;
122        Type;
123  };
124  typedef ::testing::Types&lt;ValueHolder&lt;size_t, 1&gt;, ValueHolder&lt;size_t, 2&gt;,
125                           ValueHolder&lt;size_t, 3&gt;,
126                           ValueHolder&lt;size_t, 4&gt;&gt; VariantTypes;
127  struct IncrementInDtor {
128    explicit IncrementInDtor(int* counter) : counter(counter) {}
129    ~IncrementInDtor() { *counter += 1; }
130    int* counter;
131  };
132  struct IncrementInDtorCopyCanThrow {
133    explicit IncrementInDtorCopyCanThrow(int* counter) : counter(counter) {}
134    IncrementInDtorCopyCanThrow(IncrementInDtorCopyCanThrow&amp;&amp; other) noexcept =
135        default;
136    IncrementInDtorCopyCanThrow(const IncrementInDtorCopyCanThrow&amp; other)
137        : counter(other.counter) {}
138    IncrementInDtorCopyCanThrow&amp; operator=(
139        IncrementInDtorCopyCanThrow&amp;&amp;) noexcept = default;
140    IncrementInDtorCopyCanThrow&amp; operator=(
141        IncrementInDtorCopyCanThrow const&amp; other) {
142      counter = other.counter;
143      return *this;
144    }
145    ~IncrementInDtorCopyCanThrow() { *counter += 1; }
146    int* counter;
147  };
148  inline bool operator==(const IncrementInDtor&amp; left,
149                         const IncrementInDtor&amp; right) {
150    return left.counter == right.counter;
151  }
152  inline std::ostream&amp; operator&lt;&lt;(
153      std::ostream&amp; stream, const IncrementInDtor&amp; object) {
154    return stream &lt;&lt; object.counter;
155  }
156  class CopyNoAssign {
157   public:
158    explicit CopyNoAssign(int value) : foo(value) {}
159    CopyNoAssign(const CopyNoAssign&amp; other) : foo(other.foo) {}
160    int foo;
161   private:
162    const CopyNoAssign&amp; operator=(const CopyNoAssign&amp;);
163  };
164  class NonCopyable {
165   public:
166    NonCopyable()
167        : value(0) {}
168    explicit NonCopyable(int value1)
169        : value(value1) {}
170    NonCopyable(int value1, int value2)
171        : value(value1 + value2) {}
172    NonCopyable(int value1, int value2, int value3)
173        : value(value1 + value2 + value3) {}
174    NonCopyable(int value1, int value2, int value3, int value4)
175        : value(value1 + value2 + value3 + value4) {}
176    NonCopyable(const NonCopyable&amp;) = delete;
177    NonCopyable&amp; operator=(const NonCopyable&amp;) = delete;
178    int value;
179  };
180  template &lt;typename T&gt;
181  class VariantTypesTest : public ::testing::Test {};
182  TYPED_TEST_SUITE(VariantTypesTest, VariantTypes);
183  struct NonNoexceptDefaultConstructible {
184    NonNoexceptDefaultConstructible() {}
185    int value = 5;
186  };
187  struct NonDefaultConstructible {
188    NonDefaultConstructible() = delete;
189  };
190  TEST(VariantTest, TestDefaultConstructor) {
191    {
192      using X = variant&lt;int&gt;;
193      constexpr variant&lt;int&gt; x{};
194      ASSERT_FALSE(x.valueless_by_exception());
195      ASSERT_EQ(0u, x.index());
196      EXPECT_EQ(0, absl::get&lt;0&gt;(x));
197      EXPECT_TRUE(std::is_nothrow_default_constructible&lt;X&gt;::value);
198    }
199    {
200      using X = variant&lt;NonNoexceptDefaultConstructible&gt;;
201      X x{};
202      ASSERT_FALSE(x.valueless_by_exception());
203      ASSERT_EQ(0u, x.index());
204      EXPECT_EQ(5, absl::get&lt;0&gt;(x).value);
205      EXPECT_FALSE(std::is_nothrow_default_constructible&lt;X&gt;::value);
206    }
207    {
208      using X = variant&lt;int, NonNoexceptDefaultConstructible&gt;;
209      X x{};
210      ASSERT_FALSE(x.valueless_by_exception());
211      ASSERT_EQ(0u, x.index());
212      EXPECT_EQ(0, absl::get&lt;0&gt;(x));
213      EXPECT_TRUE(std::is_nothrow_default_constructible&lt;X&gt;::value);
214    }
215    {
216      using X = variant&lt;NonNoexceptDefaultConstructible, int&gt;;
217      X x{};
218      ASSERT_FALSE(x.valueless_by_exception());
219      ASSERT_EQ(0u, x.index());
220      EXPECT_EQ(5, absl::get&lt;0&gt;(x).value);
221      EXPECT_FALSE(std::is_nothrow_default_constructible&lt;X&gt;::value);
222    }
223    EXPECT_FALSE(
224        std::is_default_constructible&lt;variant&lt;NonDefaultConstructible&gt;&gt;::value);
225    EXPECT_FALSE((std::is_default_constructible&lt;
226                  variant&lt;NonDefaultConstructible, int&gt;&gt;::value));
227    EXPECT_TRUE((std::is_default_constructible&lt;
228                 variant&lt;int, NonDefaultConstructible&gt;&gt;::value));
229  }
230  TYPED_TEST(VariantTypesTest, TestCopyCtor) {
231    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
232    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
233    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
234    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
235    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
236    const TypeParam value(TypeParam::kIndex);
237    Variant original(value);
<span onclick='openModal()' class='match'>238    Variant copied(original);
239    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(copied) ||
240                TypeParam::kIndex != 1);
241    EXPECT_TRUE(absl::holds_alternative&lt;value_type2&gt;(copied) ||
242                TypeParam::kIndex != 2);
243    EXPECT_TRUE(absl::holds_alternative&lt;value_type3&gt;(copied) ||
244                TypeParam::kIndex != 3);
245    EXPECT_TRUE(absl::holds_alternative&lt;value_type4&gt;(copied) ||
246                TypeParam::kIndex != 4);
247    EXPECT_TRUE((absl::get_if&lt;value_type1&gt;(&amp;original) ==
</span>248                 absl::get_if&lt;value_type1&gt;(&amp;copied)) ||
249                TypeParam::kIndex == 1);
250    EXPECT_TRUE((absl::get_if&lt;value_type2&gt;(&amp;original) ==
251                 absl::get_if&lt;value_type2&gt;(&amp;copied)) ||
252                TypeParam::kIndex == 2);
253    EXPECT_TRUE((absl::get_if&lt;value_type3&gt;(&amp;original) ==
254                 absl::get_if&lt;value_type3&gt;(&amp;copied)) ||
255                TypeParam::kIndex == 3);
256    EXPECT_TRUE((absl::get_if&lt;value_type4&gt;(&amp;original) ==
257                 absl::get_if&lt;value_type4&gt;(&amp;copied)) ||
258                TypeParam::kIndex == 4);
259    EXPECT_TRUE((absl::get_if&lt;value_type1&gt;(&amp;original) ==
260                 absl::get_if&lt;value_type1&gt;(&amp;copied)) ||
261                TypeParam::kIndex == 1);
262    EXPECT_TRUE((absl::get_if&lt;value_type2&gt;(&amp;original) ==
263                 absl::get_if&lt;value_type2&gt;(&amp;copied)) ||
264                TypeParam::kIndex == 2);
265    EXPECT_TRUE((absl::get_if&lt;value_type3&gt;(&amp;original) ==
266                 absl::get_if&lt;value_type3&gt;(&amp;copied)) ||
267                TypeParam::kIndex == 3);
268    EXPECT_TRUE((absl::get_if&lt;value_type4&gt;(&amp;original) ==
269                 absl::get_if&lt;value_type4&gt;(&amp;copied)) ||
270                TypeParam::kIndex == 4);
271    const TypeParam* ovalptr = absl::get_if&lt;TypeParam&gt;(&amp;original);
272    const TypeParam* cvalptr = absl::get_if&lt;TypeParam&gt;(&amp;copied);
273    ASSERT_TRUE(ovalptr != nullptr);
274    ASSERT_TRUE(cvalptr != nullptr);
275    EXPECT_EQ(*ovalptr, *cvalptr);
276    TypeParam* mutable_ovalptr = absl::get_if&lt;TypeParam&gt;(&amp;original);
277    TypeParam* mutable_cvalptr = absl::get_if&lt;TypeParam&gt;(&amp;copied);
278    ASSERT_TRUE(mutable_ovalptr != nullptr);
279    ASSERT_TRUE(mutable_cvalptr != nullptr);
280    EXPECT_EQ(*mutable_ovalptr, *mutable_cvalptr);
281  }
282  template &lt;class&gt;
283  struct MoveOnly {
284    MoveOnly() = default;
285    explicit MoveOnly(int value) : value(value) {}
286    MoveOnly(MoveOnly&amp;&amp;) = default;
287    MoveOnly&amp; operator=(MoveOnly&amp;&amp;) = default;
288    int value = 5;
289  };
290  TEST(VariantTest, TestMoveConstruct) {
291    using V = variant&lt;MoveOnly&lt;class A&gt;, MoveOnly&lt;class B&gt;, MoveOnly&lt;class C&gt;&gt;;
292    V v(in_place_index&lt;1&gt;, 10);
293    V v2 = absl::move(v);
294    EXPECT_EQ(10, absl::get&lt;1&gt;(v2).value);
295  }
296  template &lt;class T&gt;
297  union SingleUnion {
298    T member;
299  };
300  template &lt;class T&gt;
301  struct is_trivially_move_constructible
302      : std::is_move_constructible&lt;SingleUnion&lt;T&gt;&gt;::type {};
303  template &lt;class T&gt;
304  struct is_trivially_move_assignable
305      : absl::is_move_assignable&lt;SingleUnion&lt;T&gt;&gt;::type {};
306  TEST(VariantTest, NothrowMoveConstructible) {
307    using U = std::unique_ptr&lt;int&gt;;
308    struct E {
309      E(E&amp;&amp;) {}
310    };
311    static_assert(std::is_nothrow_move_constructible&lt;variant&lt;U&gt;&gt;::value, &quot;&quot;);
312    static_assert(std::is_nothrow_move_constructible&lt;variant&lt;U, int&gt;&gt;::value, &quot;&quot;);
313    static_assert(!std::is_nothrow_move_constructible&lt;variant&lt;U, E&gt;&gt;::value, &quot;&quot;);
314  }
315  TYPED_TEST(VariantTypesTest, TestValueCtor) {
316    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
317    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
318    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
319    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
320    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
321    const TypeParam value(TypeParam::kIndex);
322    Variant v(value);
323    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(v) ||
324                TypeParam::kIndex != 1);
325    EXPECT_TRUE(absl::holds_alternative&lt;value_type2&gt;(v) ||
326                TypeParam::kIndex != 2);
327    EXPECT_TRUE(absl::holds_alternative&lt;value_type3&gt;(v) ||
328                TypeParam::kIndex != 3);
329    EXPECT_TRUE(absl::holds_alternative&lt;value_type4&gt;(v) ||
330                TypeParam::kIndex != 4);
331    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type1&gt;(&amp;v) ||
332                TypeParam::kIndex != 1);
333    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type2&gt;(&amp;v) ||
334                TypeParam::kIndex != 2);
335    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type3&gt;(&amp;v) ||
336                TypeParam::kIndex != 3);
337    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type4&gt;(&amp;v) ||
338                TypeParam::kIndex != 4);
339    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type1&gt;(&amp;v) ||
340                TypeParam::kIndex != 1);
341    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type2&gt;(&amp;v) ||
342                TypeParam::kIndex != 2);
343    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type3&gt;(&amp;v) ||
344                TypeParam::kIndex != 3);
345    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type4&gt;(&amp;v) ||
346                TypeParam::kIndex != 4);
347    const TypeParam* valptr = absl::get_if&lt;TypeParam&gt;(&amp;v);
348    ASSERT_TRUE(nullptr != valptr);
349    EXPECT_EQ(value.value, valptr-&gt;value);
350    const TypeParam* mutable_valptr = absl::get_if&lt;TypeParam&gt;(&amp;v);
351    ASSERT_TRUE(nullptr != mutable_valptr);
352    EXPECT_EQ(value.value, mutable_valptr-&gt;value);
353  }
354  TEST(VariantTest, AmbiguousValueConstructor) {
355    EXPECT_FALSE((std::is_convertible&lt;int, absl::variant&lt;int, int&gt;&gt;::value));
356    EXPECT_FALSE((std::is_constructible&lt;absl::variant&lt;int, int&gt;, int&gt;::value));
357  }
358  TEST(VariantTest, InPlaceType) {
359    using Var = variant&lt;int, std::string, NonCopyable, std::vector&lt;int&gt;&gt;;
360    Var v1(in_place_type_t&lt;int&gt;(), 7);
361    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v1));
362    EXPECT_EQ(7, absl::get&lt;int&gt;(v1));
363    Var v2(in_place_type_t&lt;std::string&gt;(), &quot;ABC&quot;);
364    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v2));
365    EXPECT_EQ(&quot;ABC&quot;, absl::get&lt;std::string&gt;(v2));
366    Var v3(in_place_type_t&lt;std::string&gt;(), &quot;ABC&quot;, 2u);
367    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v3));
368    EXPECT_EQ(&quot;AB&quot;, absl::get&lt;std::string&gt;(v3));
369    Var v4(in_place_type_t&lt;NonCopyable&gt;{});
370    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v4));
371    Var v5(in_place_type_t&lt;std::vector&lt;int&gt;&gt;(), {1, 2, 3});
372    ASSERT_TRUE(absl::holds_alternative&lt;std::vector&lt;int&gt;&gt;(v5));
373    EXPECT_THAT(absl::get&lt;std::vector&lt;int&gt;&gt;(v5), ::testing::ElementsAre(1, 2, 3));
374  }
375  TEST(VariantTest, InPlaceTypeVariableTemplate) {
376    using Var = variant&lt;int, std::string, NonCopyable, std::vector&lt;int&gt;&gt;;
377    Var v1(in_place_type&lt;int&gt;, 7);
378    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v1));
379    EXPECT_EQ(7, absl::get&lt;int&gt;(v1));
380    Var v2(in_place_type&lt;std::string&gt;, &quot;ABC&quot;);
381    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v2));
382    EXPECT_EQ(&quot;ABC&quot;, absl::get&lt;std::string&gt;(v2));
383    Var v3(in_place_type&lt;std::string&gt;, &quot;ABC&quot;, 2u);
384    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v3));
385    EXPECT_EQ(&quot;AB&quot;, absl::get&lt;std::string&gt;(v3));
386    Var v4(in_place_type&lt;NonCopyable&gt;);
387    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v4));
388    Var v5(in_place_type&lt;std::vector&lt;int&gt;&gt;, {1, 2, 3});
389    ASSERT_TRUE(absl::holds_alternative&lt;std::vector&lt;int&gt;&gt;(v5));
390    EXPECT_THAT(absl::get&lt;std::vector&lt;int&gt;&gt;(v5), ::testing::ElementsAre(1, 2, 3));
391  }
392  TEST(VariantTest, InPlaceTypeInitializerList) {
393    using Var =
394        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
395    Var v1(in_place_type_t&lt;MoveOnlyWithListConstructor&gt;(), {1, 2, 3, 4, 5}, 6);
396    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
397    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
398  }
399  TEST(VariantTest, InPlaceTypeInitializerListVariabletemplate) {
400    using Var =
401        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
402    Var v1(in_place_type&lt;MoveOnlyWithListConstructor&gt;, {1, 2, 3, 4, 5}, 6);
403    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
404    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
405  }
406  TEST(VariantTest, InPlaceIndex) {
407    using Var = variant&lt;int, std::string, NonCopyable, std::vector&lt;int&gt;&gt;;
408    Var v1(in_place_index_t&lt;0&gt;(), 7);
409    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v1));
410    EXPECT_EQ(7, absl::get&lt;int&gt;(v1));
411    Var v2(in_place_index_t&lt;1&gt;(), &quot;ABC&quot;);
412    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v2));
413    EXPECT_EQ(&quot;ABC&quot;, absl::get&lt;std::string&gt;(v2));
414    Var v3(in_place_index_t&lt;1&gt;(), &quot;ABC&quot;, 2u);
415    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v3));
416    EXPECT_EQ(&quot;AB&quot;, absl::get&lt;std::string&gt;(v3));
417    Var v4(in_place_index_t&lt;2&gt;{});
418    EXPECT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v4));
419    EXPECT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(
420        variant&lt;NonCopyable&gt;(in_place_index_t&lt;0&gt;{})));
421    Var v5(in_place_index_t&lt;3&gt;(), {1, 2, 3});
422    ASSERT_TRUE(absl::holds_alternative&lt;std::vector&lt;int&gt;&gt;(v5));
423    EXPECT_THAT(absl::get&lt;std::vector&lt;int&gt;&gt;(v5), ::testing::ElementsAre(1, 2, 3));
424  }
425  TEST(VariantTest, InPlaceIndexVariableTemplate) {
426    using Var = variant&lt;int, std::string, NonCopyable, std::vector&lt;int&gt;&gt;;
427    Var v1(in_place_index&lt;0&gt;, 7);
428    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v1));
429    EXPECT_EQ(7, absl::get&lt;int&gt;(v1));
430    Var v2(in_place_index&lt;1&gt;, &quot;ABC&quot;);
431    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v2));
432    EXPECT_EQ(&quot;ABC&quot;, absl::get&lt;std::string&gt;(v2));
433    Var v3(in_place_index&lt;1&gt;, &quot;ABC&quot;, 2u);
434    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v3));
435    EXPECT_EQ(&quot;AB&quot;, absl::get&lt;std::string&gt;(v3));
436    Var v4(in_place_index&lt;2&gt;);
437    EXPECT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v4));
438    EXPECT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(
439        variant&lt;NonCopyable&gt;(in_place_index&lt;0&gt;)));
440    Var v5(in_place_index&lt;3&gt;, {1, 2, 3});
441    ASSERT_TRUE(absl::holds_alternative&lt;std::vector&lt;int&gt;&gt;(v5));
442    EXPECT_THAT(absl::get&lt;std::vector&lt;int&gt;&gt;(v5), ::testing::ElementsAre(1, 2, 3));
443  }
444  TEST(VariantTest, InPlaceIndexInitializerList) {
445    using Var =
446        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
447    Var v1(in_place_index_t&lt;3&gt;(), {1, 2, 3, 4, 5}, 6);
448    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
449    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
450  }
451  TEST(VariantTest, InPlaceIndexInitializerListVariableTemplate) {
452    using Var =
453        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
454    Var v1(in_place_index&lt;3&gt;, {1, 2, 3, 4, 5}, 6);
455    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
456    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
457  }
458  TEST(VariantTest, TestDtor) {
459    typedef VariantFactory&lt;IncrementInDtor&gt;::Type Variant;
460    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
461    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
462    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
463    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
464    int counter = 0;
465    IncrementInDtor counter_adjuster(&amp;counter);
466    EXPECT_EQ(0, counter);
467    value_type1 value1(counter_adjuster);
468    { Variant object(value1); }
469    EXPECT_EQ(1, counter);
470    value_type2 value2(counter_adjuster);
471    { Variant object(value2); }
472    EXPECT_EQ(2, counter);
473    value_type3 value3(counter_adjuster);
474    { Variant object(value3); }
475    EXPECT_EQ(3, counter);
476    value_type4 value4(counter_adjuster);
477    { Variant object(value4); }
478    EXPECT_EQ(4, counter);
479  }
480  #ifdef ABSL_HAVE_EXCEPTIONS
481  #if defined(ABSL_INTERNAL_MSVC_2017_DBG_MODE)
482  TEST(VariantTest, DISABLED_TestDtorValuelessByException)
483  #else
484  TEST(VariantTest, TestDtorValuelessByException)
485  #endif
486  {
487    int counter = 0;
488    IncrementInDtor counter_adjuster(&amp;counter);
489    {
490      using Variant = VariantFactory&lt;IncrementInDtor&gt;::Type;
491      Variant v(in_place_index&lt;0&gt;, counter_adjuster);
492      EXPECT_EQ(0, counter);
493      ToValuelessByException(v);
494      ASSERT_TRUE(v.valueless_by_exception());
495      EXPECT_EQ(1, counter);
496    }
497    EXPECT_EQ(1, counter);
498  }
499  #endif  
500  TEST(VariantTest, TestSelfAssignment) {
501    typedef VariantFactory&lt;IncrementInDtor&gt;::Type Variant;
502    int counter = 0;
503    IncrementInDtor counter_adjuster(&amp;counter);
504    absl::variant_alternative_t&lt;0, Variant&gt; value(counter_adjuster);
505    Variant object(value);
506    object.operator=(object);
507    EXPECT_EQ(0, counter);
508    const std::string long_str(128, &#x27;a&#x27;);
509    std::string foo = long_str;
510    foo = *&amp;foo;
511    EXPECT_EQ(long_str, foo);
512    variant&lt;int, std::string&gt; so = long_str;
513    ASSERT_EQ(1u, so.index());
514    EXPECT_EQ(long_str, absl::get&lt;1&gt;(so));
515    so = *&amp;so;
516    ASSERT_EQ(1u, so.index());
517    EXPECT_EQ(long_str, absl::get&lt;1&gt;(so));
518  }
519  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValueSameTypes) {
520    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
521    const TypeParam value(TypeParam::kIndex);
522    const Variant source(value);
523    Variant target(TypeParam(value.value + 1));
524    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(source));
525    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(target));
526    ASSERT_NE(absl::get&lt;TypeParam&gt;(source), absl::get&lt;TypeParam&gt;(target));
527    target = source;
528    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(source));
529    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(target));
530    EXPECT_EQ(absl::get&lt;TypeParam&gt;(source), absl::get&lt;TypeParam&gt;(target));
531  }
532  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValuesVaryingSourceType) {
533    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
534    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
535    const TypeParam value(TypeParam::kIndex);
536    const Variant source(value);
537    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(source));
538    Variant target(value_type1(1));
539    ASSERT_TRUE(absl::holds_alternative&lt;value_type1&gt;(target));
540    target = source;
541    EXPECT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(source));
542    EXPECT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(target));
543    EXPECT_EQ(absl::get&lt;TypeParam&gt;(source), absl::get&lt;TypeParam&gt;(target));
544  }
545  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValuesVaryingTargetType) {
546    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
547    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
548    const Variant source(value_type1(1));
549    ASSERT_TRUE(absl::holds_alternative&lt;value_type1&gt;(source));
550    const TypeParam value(TypeParam::kIndex);
551    Variant target(value);
552    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(target));
553    target = source;
554    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(target));
555    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(source));
556    EXPECT_EQ(absl::get&lt;value_type1&gt;(source), absl::get&lt;value_type1&gt;(target));
557  }
558  TEST(VariantTest, TestAssign) {
559    typedef VariantFactory&lt;IncrementInDtor&gt;::Type Variant;
560    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
561    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
562    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
563    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
564    const int kSize = 4;
565    int counter[kSize];
566    std::unique_ptr&lt;IncrementInDtor&gt; counter_adjustor[kSize];
567    for (int i = 0; i != kSize; i++) {
568      counter[i] = 0;
569      counter_adjustor[i] = absl::make_unique&lt;IncrementInDtor&gt;(&amp;counter[i]);
570    }
571    value_type1 v1(*counter_adjustor[0]);
572    value_type2 v2(*counter_adjustor[1]);
573    value_type3 v3(*counter_adjustor[2]);
574    value_type4 v4(*counter_adjustor[3]);
575    {
576      Variant object(v1);
577      object = v2;
578      object = v3;
579      object = v4;
580      object = v1;
581    }
582    EXPECT_EQ(2, counter[0]);
583    EXPECT_EQ(1, counter[1]);
584    EXPECT_EQ(1, counter[2]);
585    EXPECT_EQ(1, counter[3]);
586    std::fill(std::begin(counter), std::end(counter), 0);
587    {
588      Variant object(v1);
589      object.operator=(object);
590      EXPECT_EQ(0, counter[0]);
591    }
592    {
593      Variant object(v2);
594      object.operator=(object);
595      EXPECT_EQ(0, counter[1]);
596    }
597    {
598      Variant object(v3);
599      object.operator=(object);
600      EXPECT_EQ(0, counter[2]);
601    }
602    {
603      Variant object(v4);
604      object.operator=(object);
605      EXPECT_EQ(0, counter[3]);
606    }
607    EXPECT_EQ(1, counter[0]);
608    EXPECT_EQ(1, counter[1]);
609    EXPECT_EQ(1, counter[2]);
610    EXPECT_EQ(1, counter[3]);
611  }
612  TEST(VariantTest, TestBackupAssign) {
613    typedef VariantFactory&lt;IncrementInDtorCopyCanThrow&gt;::Type Variant;
614    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
615    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
616    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
617    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
618    const int kSize = 4;
619    int counter[kSize];
620    std::unique_ptr&lt;IncrementInDtorCopyCanThrow&gt; counter_adjustor[kSize];
621    for (int i = 0; i != kSize; i++) {
622      counter[i] = 0;
623      counter_adjustor[i].reset(new IncrementInDtorCopyCanThrow(&amp;counter[i]));
624    }
625    value_type1 v1(*counter_adjustor[0]);
626    value_type2 v2(*counter_adjustor[1]);
627    value_type3 v3(*counter_adjustor[2]);
628    value_type4 v4(*counter_adjustor[3]);
629    {
630      Variant object(v1);
631      object = v2;
632      object = v3;
633      object = v4;
634      object = v1;
635    }
636  #if !(defined(ABSL_USES_STD_VARIANT) &amp;&amp; defined(__GLIBCXX__))
637    EXPECT_EQ(3, counter[0]);
638    EXPECT_EQ(2, counter[1]);
639    EXPECT_EQ(2, counter[2]);
640    EXPECT_EQ(2, counter[3]);
641  #endif
642    std::fill(std::begin(counter), std::end(counter), 0);
643    {
644      Variant object(v1);
645      object.operator=(object);
646      EXPECT_EQ(0, counter[0]);
647    }
648    {
649      Variant object(v2);
650      object.operator=(object);
651      EXPECT_EQ(0, counter[1]);
652    }
653    {
654      Variant object(v3);
655      object.operator=(object);
656      EXPECT_EQ(0, counter[2]);
657    }
658    {
659      Variant object(v4);
660      object.operator=(object);
661      EXPECT_EQ(0, counter[3]);
662    }
663    EXPECT_EQ(1, counter[0]);
664    EXPECT_EQ(1, counter[1]);
665    EXPECT_EQ(1, counter[2]);
666    EXPECT_EQ(1, counter[3]);
667  }
668  TEST(VariantTest, TestEmplaceBasic) {
669    using Variant = variant&lt;int, char&gt;;
670    Variant v(absl::in_place_index&lt;0&gt;, 0);
671    {
672      char&amp; emplace_result = v.emplace&lt;char&gt;();
673      ASSERT_TRUE(absl::holds_alternative&lt;char&gt;(v));
674      EXPECT_EQ(absl::get&lt;char&gt;(v), 0);
675      EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;char&gt;(v));
676    }
677    absl::get&lt;char&gt;(v) = &#x27;a&#x27;;
678    v.emplace&lt;char&gt;(&#x27;b&#x27;);
679    ASSERT_TRUE(absl::holds_alternative&lt;char&gt;(v));
680    EXPECT_EQ(absl::get&lt;char&gt;(v), &#x27;b&#x27;);
681    {
682      int&amp; emplace_result = v.emplace&lt;int&gt;();
683      EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(v));
684      EXPECT_EQ(absl::get&lt;int&gt;(v), 0);
685      EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;int&gt;(v));
686    }
687  }
688  TEST(VariantTest, TestEmplaceInitializerList) {
689    using Var =
690        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
691    Var v1(absl::in_place_index&lt;0&gt;, 555);
692    MoveOnlyWithListConstructor&amp; emplace_result =
693        v1.emplace&lt;MoveOnlyWithListConstructor&gt;({1, 2, 3, 4, 5}, 6);
694    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
695    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
696    EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;MoveOnlyWithListConstructor&gt;(v1));
697  }
698  TEST(VariantTest, TestEmplaceIndex) {
699    using Variant = variant&lt;int, char&gt;;
700    Variant v(absl::in_place_index&lt;0&gt;, 555);
701    {
702      char&amp; emplace_result = v.emplace&lt;1&gt;();
703      ASSERT_TRUE(absl::holds_alternative&lt;char&gt;(v));
704      EXPECT_EQ(absl::get&lt;char&gt;(v), 0);
705      EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;char&gt;(v));
706    }
707    absl::get&lt;char&gt;(v) = &#x27;a&#x27;;
708    v.emplace&lt;1&gt;(&#x27;b&#x27;);
709    ASSERT_TRUE(absl::holds_alternative&lt;char&gt;(v));
710    EXPECT_EQ(absl::get&lt;char&gt;(v), &#x27;b&#x27;);
711    {
712      int&amp; emplace_result = v.emplace&lt;0&gt;();
713      EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(v));
714      EXPECT_EQ(absl::get&lt;int&gt;(v), 0);
715      EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;int&gt;(v));
716    }
717  }
718  TEST(VariantTest, TestEmplaceIndexInitializerList) {
719    using Var =
720        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
721    Var v1(absl::in_place_index&lt;0&gt;, 555);
722    MoveOnlyWithListConstructor&amp; emplace_result =
723        v1.emplace&lt;3&gt;({1, 2, 3, 4, 5}, 6);
724    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
725    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
726    EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;MoveOnlyWithListConstructor&gt;(v1));
727  }
728  TEST(VariantTest, Index) {
729    using Var = variant&lt;int, std::string, double&gt;;
730    Var v = 1;
731    EXPECT_EQ(0u, v.index());
732    v = &quot;str&quot;;
733    EXPECT_EQ(1u, v.index());
734    v = 0.;
735    EXPECT_EQ(2u, v.index());
736    Var v2 = v;
737    EXPECT_EQ(2u, v2.index());
738    v2.emplace&lt;int&gt;(3);
739    EXPECT_EQ(0u, v2.index());
740  }
741  TEST(VariantTest, NotValuelessByException) {
742    using Var = variant&lt;int, std::string, double&gt;;
743    Var v = 1;
744    EXPECT_FALSE(v.valueless_by_exception());
745    v = &quot;str&quot;;
746    EXPECT_FALSE(v.valueless_by_exception());
747    v = 0.;
748    EXPECT_FALSE(v.valueless_by_exception());
749    Var v2 = v;
750    EXPECT_FALSE(v.valueless_by_exception());
751    v2.emplace&lt;int&gt;(3);
752    EXPECT_FALSE(v.valueless_by_exception());
753  }
754  #ifdef ABSL_HAVE_EXCEPTIONS
755  TEST(VariantTest, IndexValuelessByException) {
756    using Var = variant&lt;MoveCanThrow, std::string, double&gt;;
757    Var v(absl::in_place_index&lt;0&gt;);
758    EXPECT_EQ(0u, v.index());
759    ToValuelessByException(v);
760    EXPECT_EQ(absl::variant_npos, v.index());
761    v = &quot;str&quot;;
762    EXPECT_EQ(1u, v.index());
763  }
764  TEST(VariantTest, ValuelessByException) {
765    using Var = variant&lt;MoveCanThrow, std::string, double&gt;;
766    Var v(absl::in_place_index&lt;0&gt;);
767    EXPECT_FALSE(v.valueless_by_exception());
768    ToValuelessByException(v);
769    EXPECT_TRUE(v.valueless_by_exception());
770    v = &quot;str&quot;;
771    EXPECT_FALSE(v.valueless_by_exception());
772  }
773  #endif  
774  TEST(VariantTest, MemberSwap) {
775    SpecialSwap v1(3);
776    SpecialSwap v2(7);
777    variant&lt;SpecialSwap&gt; a = v1, b = v2;
778    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v1));
779    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v2));
780    a.swap(b);
781    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v2));
782    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v1));
783    EXPECT_TRUE(absl::get&lt;SpecialSwap&gt;(a).special_swap);
784    using V = variant&lt;MoveCanThrow, std::string, int&gt;;
785    int i = 33;
786    std::string s = &quot;abc&quot;;
787    {
788      V lhs(i), rhs(s);
789      lhs.swap(rhs);
790      EXPECT_THAT(lhs, VariantWith&lt;std::string&gt;(s));
791      EXPECT_THAT(rhs, VariantWith&lt;int&gt;(i));
792    }
793  #ifdef ABSL_HAVE_EXCEPTIONS
794    V valueless(in_place_index&lt;0&gt;);
795    ToValuelessByException(valueless);
796    {
797      V lhs(valueless), rhs(i);
798      lhs.swap(rhs);
799      EXPECT_THAT(lhs, VariantWith&lt;int&gt;(i));
800      EXPECT_TRUE(rhs.valueless_by_exception());
801    }
802    {
803      V lhs(s), rhs(valueless);
804      lhs.swap(rhs);
805      EXPECT_THAT(rhs, VariantWith&lt;std::string&gt;(s));
806      EXPECT_TRUE(lhs.valueless_by_exception());
807    }
808    {
809      V lhs(valueless), rhs(valueless);
810      lhs.swap(rhs);
811      EXPECT_TRUE(lhs.valueless_by_exception());
812      EXPECT_TRUE(rhs.valueless_by_exception());
813    }
814  #endif  
815  }
816  TEST(VariantTest, VariantSize) {
817    {
818      using Size1Variant = absl::variant&lt;int&gt;;
819      EXPECT_EQ(1u, absl::variant_size&lt;Size1Variant&gt;::value);
820      EXPECT_EQ(1u, absl::variant_size&lt;const Size1Variant&gt;::value);
821      EXPECT_EQ(1u, absl::variant_size&lt;volatile Size1Variant&gt;::value);
822      EXPECT_EQ(1u, absl::variant_size&lt;const volatile Size1Variant&gt;::value);
823    }
824    {
825      using Size3Variant = absl::variant&lt;int, float, int&gt;;
826      EXPECT_EQ(3u, absl::variant_size&lt;Size3Variant&gt;::value);
827      EXPECT_EQ(3u, absl::variant_size&lt;const Size3Variant&gt;::value);
828      EXPECT_EQ(3u, absl::variant_size&lt;volatile Size3Variant&gt;::value);
829      EXPECT_EQ(3u, absl::variant_size&lt;const volatile Size3Variant&gt;::value);
830    }
831  }
832  TEST(VariantTest, VariantAlternative) {
833    {
834      using V = absl::variant&lt;float, int, const char*&gt;;
835      EXPECT_TRUE(
836          (std::is_same&lt;float, absl::variant_alternative_t&lt;0, V&gt;&gt;::value));
837      EXPECT_TRUE((std::is_same&lt;const float,
838                                absl::variant_alternative_t&lt;0, const V&gt;&gt;::value));
839      EXPECT_TRUE(
840          (std::is_same&lt;volatile float,
841                        absl::variant_alternative_t&lt;0, volatile V&gt;&gt;::value));
842      EXPECT_TRUE((
843          std::is_same&lt;const volatile float,
844                       absl::variant_alternative_t&lt;0, const volatile V&gt;&gt;::value));
845      EXPECT_TRUE((std::is_same&lt;int, absl::variant_alternative_t&lt;1, V&gt;&gt;::value));
846      EXPECT_TRUE((std::is_same&lt;const int,
847                                absl::variant_alternative_t&lt;1, const V&gt;&gt;::value));
848      EXPECT_TRUE(
849          (std::is_same&lt;volatile int,
850                        absl::variant_alternative_t&lt;1, volatile V&gt;&gt;::value));
851      EXPECT_TRUE((
852          std::is_same&lt;const volatile int,
853                       absl::variant_alternative_t&lt;1, const volatile V&gt;&gt;::value));
854      EXPECT_TRUE(
855          (std::is_same&lt;const char*, absl::variant_alternative_t&lt;2, V&gt;&gt;::value));
856      EXPECT_TRUE((std::is_same&lt;const char* const,
857                                absl::variant_alternative_t&lt;2, const V&gt;&gt;::value));
858      EXPECT_TRUE(
859          (std::is_same&lt;const char* volatile,
860                        absl::variant_alternative_t&lt;2, volatile V&gt;&gt;::value));
861      EXPECT_TRUE((
862          std::is_same&lt;const char* const volatile,
863                       absl::variant_alternative_t&lt;2, const volatile V&gt;&gt;::value));
864    }
865    {
866      using V = absl::variant&lt;float, volatile int, const char*&gt;;
867      EXPECT_TRUE(
868          (std::is_same&lt;float, absl::variant_alternative_t&lt;0, V&gt;&gt;::value));
869      EXPECT_TRUE((std::is_same&lt;const float,
870                                absl::variant_alternative_t&lt;0, const V&gt;&gt;::value));
871      EXPECT_TRUE(
872          (std::is_same&lt;volatile float,
873                        absl::variant_alternative_t&lt;0, volatile V&gt;&gt;::value));
874      EXPECT_TRUE((
875          std::is_same&lt;const volatile float,
876                       absl::variant_alternative_t&lt;0, const volatile V&gt;&gt;::value));
877      EXPECT_TRUE(
878          (std::is_same&lt;volatile int, absl::variant_alternative_t&lt;1, V&gt;&gt;::value));
879      EXPECT_TRUE((std::is_same&lt;const volatile int,
880                                absl::variant_alternative_t&lt;1, const V&gt;&gt;::value));
881      EXPECT_TRUE(
882          (std::is_same&lt;volatile int,
883                        absl::variant_alternative_t&lt;1, volatile V&gt;&gt;::value));
884      EXPECT_TRUE((
885          std::is_same&lt;const volatile int,
886                       absl::variant_alternative_t&lt;1, const volatile V&gt;&gt;::value));
887      EXPECT_TRUE(
888          (std::is_same&lt;const char*, absl::variant_alternative_t&lt;2, V&gt;&gt;::value));
889      EXPECT_TRUE((std::is_same&lt;const char* const,
890                                absl::variant_alternative_t&lt;2, const V&gt;&gt;::value));
891      EXPECT_TRUE(
892          (std::is_same&lt;const char* volatile,
893                        absl::variant_alternative_t&lt;2, volatile V&gt;&gt;::value));
894      EXPECT_TRUE((
895          std::is_same&lt;const char* const volatile,
896                       absl::variant_alternative_t&lt;2, const volatile V&gt;&gt;::value));
897    }
898  }
899  TEST(VariantTest, HoldsAlternative) {
900    using Var = variant&lt;int, std::string, double&gt;;
901    Var v = 1;
902    EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(v));
903    EXPECT_FALSE(absl::holds_alternative&lt;std::string&gt;(v));
904    EXPECT_FALSE(absl::holds_alternative&lt;double&gt;(v));
905    v = &quot;str&quot;;
906    EXPECT_FALSE(absl::holds_alternative&lt;int&gt;(v));
907    EXPECT_TRUE(absl::holds_alternative&lt;std::string&gt;(v));
908    EXPECT_FALSE(absl::holds_alternative&lt;double&gt;(v));
909    v = 0.;
910    EXPECT_FALSE(absl::holds_alternative&lt;int&gt;(v));
911    EXPECT_FALSE(absl::holds_alternative&lt;std::string&gt;(v));
912    EXPECT_TRUE(absl::holds_alternative&lt;double&gt;(v));
913    Var v2 = v;
914    EXPECT_FALSE(absl::holds_alternative&lt;int&gt;(v2));
915    EXPECT_FALSE(absl::holds_alternative&lt;std::string&gt;(v2));
916    EXPECT_TRUE(absl::holds_alternative&lt;double&gt;(v2));
917    v2.emplace&lt;int&gt;(3);
918    EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(v2));
919    EXPECT_FALSE(absl::holds_alternative&lt;std::string&gt;(v2));
920    EXPECT_FALSE(absl::holds_alternative&lt;double&gt;(v2));
921  }
922  TEST(VariantTest, GetIndex) {
923    using Var = variant&lt;int, std::string, double, int&gt;;
924    {
925      Var v(absl::in_place_index&lt;0&gt;, 0);
926      using LValueGetType = decltype(absl::get&lt;0&gt;(v));
927      using RValueGetType = decltype(absl::get&lt;0&gt;(absl::move(v)));
928      EXPECT_TRUE((std::is_same&lt;LValueGetType, int&amp;&gt;::value));
929      EXPECT_TRUE((std::is_same&lt;RValueGetType, int&amp;&amp;&gt;::value));
930      EXPECT_EQ(absl::get&lt;0&gt;(v), 0);
931      EXPECT_EQ(absl::get&lt;0&gt;(absl::move(v)), 0);
932      const Var&amp; const_v = v;
933      using ConstLValueGetType = decltype(absl::get&lt;0&gt;(const_v));
934      using ConstRValueGetType = decltype(absl::get&lt;0&gt;(absl::move(const_v)));
935      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const int&amp;&gt;::value));
936      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const int&amp;&amp;&gt;::value));
937      EXPECT_EQ(absl::get&lt;0&gt;(const_v), 0);
938      EXPECT_EQ(absl::get&lt;0&gt;(absl::move(const_v)), 0);
939    }
940    {
941      Var v = std::string(&quot;Hello&quot;);
942      using LValueGetType = decltype(absl::get&lt;1&gt;(v));
943      using RValueGetType = decltype(absl::get&lt;1&gt;(absl::move(v)));
944      EXPECT_TRUE((std::is_same&lt;LValueGetType, std::string&amp;&gt;::value));
945      EXPECT_TRUE((std::is_same&lt;RValueGetType, std::string&amp;&amp;&gt;::value));
946      EXPECT_EQ(absl::get&lt;1&gt;(v), &quot;Hello&quot;);
947      EXPECT_EQ(absl::get&lt;1&gt;(absl::move(v)), &quot;Hello&quot;);
948      const Var&amp; const_v = v;
949      using ConstLValueGetType = decltype(absl::get&lt;1&gt;(const_v));
950      using ConstRValueGetType = decltype(absl::get&lt;1&gt;(absl::move(const_v)));
951      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const std::string&amp;&gt;::value));
952      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const std::string&amp;&amp;&gt;::value));
953      EXPECT_EQ(absl::get&lt;1&gt;(const_v), &quot;Hello&quot;);
954      EXPECT_EQ(absl::get&lt;1&gt;(absl::move(const_v)), &quot;Hello&quot;);
955    }
956    {
957      Var v = 2.0;
958      using LValueGetType = decltype(absl::get&lt;2&gt;(v));
959      using RValueGetType = decltype(absl::get&lt;2&gt;(absl::move(v)));
960      EXPECT_TRUE((std::is_same&lt;LValueGetType, double&amp;&gt;::value));
961      EXPECT_TRUE((std::is_same&lt;RValueGetType, double&amp;&amp;&gt;::value));
962      EXPECT_EQ(absl::get&lt;2&gt;(v), 2.);
963      EXPECT_EQ(absl::get&lt;2&gt;(absl::move(v)), 2.);
964      const Var&amp; const_v = v;
965      using ConstLValueGetType = decltype(absl::get&lt;2&gt;(const_v));
966      using ConstRValueGetType = decltype(absl::get&lt;2&gt;(absl::move(const_v)));
967      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const double&amp;&gt;::value));
968      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const double&amp;&amp;&gt;::value));
969      EXPECT_EQ(absl::get&lt;2&gt;(const_v), 2.);
970      EXPECT_EQ(absl::get&lt;2&gt;(absl::move(const_v)), 2.);
971    }
972    {
973      Var v(absl::in_place_index&lt;0&gt;, 0);
974      v.emplace&lt;3&gt;(1);
975      using LValueGetType = decltype(absl::get&lt;3&gt;(v));
976      using RValueGetType = decltype(absl::get&lt;3&gt;(absl::move(v)));
977      EXPECT_TRUE((std::is_same&lt;LValueGetType, int&amp;&gt;::value));
978      EXPECT_TRUE((std::is_same&lt;RValueGetType, int&amp;&amp;&gt;::value));
979      EXPECT_EQ(absl::get&lt;3&gt;(v), 1);
980      EXPECT_EQ(absl::get&lt;3&gt;(absl::move(v)), 1);
981      const Var&amp; const_v = v;
982      using ConstLValueGetType = decltype(absl::get&lt;3&gt;(const_v));
983      using ConstRValueGetType = decltype(absl::get&lt;3&gt;(absl::move(const_v)));
984      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const int&amp;&gt;::value));
985      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const int&amp;&amp;&gt;::value));
986      EXPECT_EQ(absl::get&lt;3&gt;(const_v), 1);
987      EXPECT_EQ(absl::get&lt;3&gt;(absl::move(const_v)), 1);  
988    }
989  }
990  TEST(VariantTest, BadGetIndex) {
991    using Var = variant&lt;int, std::string, double&gt;;
992    {
993      Var v = 1;
994      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;1&gt;(v));
995      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;1&gt;(std::move(v)));
996      const Var&amp; const_v = v;
997      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;1&gt;(const_v));
998      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
999          absl::get&lt;1&gt;(std::move(const_v)));  
1000    }
1001    {
1002      Var v = std::string(&quot;Hello&quot;);
1003      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;0&gt;(v));
1004      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;0&gt;(std::move(v)));
1005      const Var&amp; const_v = v;
1006      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;0&gt;(const_v));
1007      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1008          absl::get&lt;0&gt;(std::move(const_v)));  
1009    }
1010  }
1011  TEST(VariantTest, GetType) {
1012    using Var = variant&lt;int, std::string, double&gt;;
1013    {
1014      Var v = 1;
1015      using LValueGetType = decltype(absl::get&lt;int&gt;(v));
1016      using RValueGetType = decltype(absl::get&lt;int&gt;(absl::move(v)));
1017      EXPECT_TRUE((std::is_same&lt;LValueGetType, int&amp;&gt;::value));
1018      EXPECT_TRUE((std::is_same&lt;RValueGetType, int&amp;&amp;&gt;::value));
1019      EXPECT_EQ(absl::get&lt;int&gt;(v), 1);
1020      EXPECT_EQ(absl::get&lt;int&gt;(absl::move(v)), 1);
1021      const Var&amp; const_v = v;
1022      using ConstLValueGetType = decltype(absl::get&lt;int&gt;(const_v));
1023      using ConstRValueGetType = decltype(absl::get&lt;int&gt;(absl::move(const_v)));
1024      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const int&amp;&gt;::value));
1025      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const int&amp;&amp;&gt;::value));
1026      EXPECT_EQ(absl::get&lt;int&gt;(const_v), 1);
1027      EXPECT_EQ(absl::get&lt;int&gt;(absl::move(const_v)), 1);
1028    }
1029    {
1030      Var v = std::string(&quot;Hello&quot;);
1031      using LValueGetType = decltype(absl::get&lt;1&gt;(v));
1032      using RValueGetType = decltype(absl::get&lt;1&gt;(absl::move(v)));
1033      EXPECT_TRUE((std::is_same&lt;LValueGetType, std::string&amp;&gt;::value));
1034      EXPECT_TRUE((std::is_same&lt;RValueGetType, std::string&amp;&amp;&gt;::value));
1035      EXPECT_EQ(absl::get&lt;std::string&gt;(v), &quot;Hello&quot;);
1036      EXPECT_EQ(absl::get&lt;std::string&gt;(absl::move(v)), &quot;Hello&quot;);
1037      const Var&amp; const_v = v;
1038      using ConstLValueGetType = decltype(absl::get&lt;1&gt;(const_v));
1039      using ConstRValueGetType = decltype(absl::get&lt;1&gt;(absl::move(const_v)));
1040      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const std::string&amp;&gt;::value));
1041      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const std::string&amp;&amp;&gt;::value));
1042      EXPECT_EQ(absl::get&lt;std::string&gt;(const_v), &quot;Hello&quot;);
1043      EXPECT_EQ(absl::get&lt;std::string&gt;(absl::move(const_v)), &quot;Hello&quot;);
1044    }
1045    {
1046      Var v = 2.0;
1047      using LValueGetType = decltype(absl::get&lt;2&gt;(v));
1048      using RValueGetType = decltype(absl::get&lt;2&gt;(absl::move(v)));
1049      EXPECT_TRUE((std::is_same&lt;LValueGetType, double&amp;&gt;::value));
1050      EXPECT_TRUE((std::is_same&lt;RValueGetType, double&amp;&amp;&gt;::value));
1051      EXPECT_EQ(absl::get&lt;double&gt;(v), 2.);
1052      EXPECT_EQ(absl::get&lt;double&gt;(absl::move(v)), 2.);
1053      const Var&amp; const_v = v;
1054      using ConstLValueGetType = decltype(absl::get&lt;2&gt;(const_v));
1055      using ConstRValueGetType = decltype(absl::get&lt;2&gt;(absl::move(const_v)));
1056      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const double&amp;&gt;::value));
1057      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const double&amp;&amp;&gt;::value));
1058      EXPECT_EQ(absl::get&lt;double&gt;(const_v), 2.);
1059      EXPECT_EQ(absl::get&lt;double&gt;(absl::move(const_v)), 2.);
1060    }
1061  }
1062  TEST(VariantTest, BadGetType) {
1063    using Var = variant&lt;int, std::string, double&gt;;
1064    {
1065      Var v = 1;
1066      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;std::string&gt;(v));
1067      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1068          absl::get&lt;std::string&gt;(std::move(v)));
1069      const Var&amp; const_v = v;
1070      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1071          absl::get&lt;std::string&gt;(const_v));
1072      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1073          absl::get&lt;std::string&gt;(std::move(const_v)));  
1074    }
1075    {
1076      Var v = std::string(&quot;Hello&quot;);
1077      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;int&gt;(v));
1078      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;int&gt;(std::move(v)));
1079      const Var&amp; const_v = v;
1080      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;int&gt;(const_v));
1081      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1082          absl::get&lt;int&gt;(std::move(const_v)));  
1083    }
1084  }
1085  TEST(VariantTest, GetIfIndex) {
1086    using Var = variant&lt;int, std::string, double, int&gt;;
1087    {
1088      Var v(absl::in_place_index&lt;0&gt;, 0);
1089      EXPECT_TRUE(noexcept(absl::get_if&lt;0&gt;(&amp;v)));
1090      {
1091        auto* elem = absl::get_if&lt;0&gt;(&amp;v);
1092        EXPECT_TRUE((std::is_same&lt;decltype(elem), int*&gt;::value));
1093        ASSERT_NE(elem, nullptr);
1094        EXPECT_EQ(*elem, 0);
1095        {
1096          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;v);
1097          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), std::string*&gt;::value));
1098          EXPECT_EQ(bad_elem, nullptr);
1099        }
1100        {
1101          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;v);
1102          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), double*&gt;::value));
1103          EXPECT_EQ(bad_elem, nullptr);
1104        }
1105        {
1106          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;v);
1107          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1108          EXPECT_EQ(bad_elem, nullptr);
1109        }
1110      }
1111      const Var&amp; const_v = v;
1112      EXPECT_TRUE(noexcept(absl::get_if&lt;0&gt;(&amp;const_v)));
1113      {
1114        auto* elem = absl::get_if&lt;0&gt;(&amp;const_v);
1115        EXPECT_TRUE((std::is_same&lt;decltype(elem), const int*&gt;::value));
1116        ASSERT_NE(elem, nullptr);
1117        EXPECT_EQ(*elem, 0);
1118        {
1119          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;const_v);
1120          EXPECT_TRUE(
1121              (std::is_same&lt;decltype(bad_elem), const std::string*&gt;::value));
1122          EXPECT_EQ(bad_elem, nullptr);
1123        }
1124        {
1125          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;const_v);
1126          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const double*&gt;::value));
1127          EXPECT_EQ(bad_elem, nullptr);
1128        }
1129        {
1130          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;const_v);
1131          EXPECT_EQ(bad_elem, nullptr);
1132          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1133        }
1134      }
1135    }
1136    {
1137      Var v = std::string(&quot;Hello&quot;);
1138      EXPECT_TRUE(noexcept(absl::get_if&lt;1&gt;(&amp;v)));
1139      {
1140        auto* elem = absl::get_if&lt;1&gt;(&amp;v);
1141        EXPECT_TRUE((std::is_same&lt;decltype(elem), std::string*&gt;::value));
1142        ASSERT_NE(elem, nullptr);
1143        EXPECT_EQ(*elem, &quot;Hello&quot;);
1144        {
1145          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;v);
1146          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1147          EXPECT_EQ(bad_elem, nullptr);
1148        }
1149        {
1150          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;v);
1151          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), double*&gt;::value));
1152          EXPECT_EQ(bad_elem, nullptr);
1153        }
1154        {
1155          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;v);
1156          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1157          EXPECT_EQ(bad_elem, nullptr);
1158        }
1159      }
1160      const Var&amp; const_v = v;
1161      EXPECT_TRUE(noexcept(absl::get_if&lt;1&gt;(&amp;const_v)));
1162      {
1163        auto* elem = absl::get_if&lt;1&gt;(&amp;const_v);
1164        EXPECT_TRUE((std::is_same&lt;decltype(elem), const std::string*&gt;::value));
1165        ASSERT_NE(elem, nullptr);
1166        EXPECT_EQ(*elem, &quot;Hello&quot;);
1167        {
1168          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;const_v);
1169          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1170          EXPECT_EQ(bad_elem, nullptr);
1171        }
1172        {
1173          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;const_v);
1174          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const double*&gt;::value));
1175          EXPECT_EQ(bad_elem, nullptr);
1176        }
1177        {
1178          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;const_v);
1179          EXPECT_EQ(bad_elem, nullptr);
1180          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1181        }
1182      }
1183    }
1184    {
1185      Var v = 2.0;
1186      EXPECT_TRUE(noexcept(absl::get_if&lt;2&gt;(&amp;v)));
1187      {
1188        auto* elem = absl::get_if&lt;2&gt;(&amp;v);
1189        EXPECT_TRUE((std::is_same&lt;decltype(elem), double*&gt;::value));
1190        ASSERT_NE(elem, nullptr);
1191        EXPECT_EQ(*elem, 2.0);
1192        {
1193          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;v);
1194          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1195          EXPECT_EQ(bad_elem, nullptr);
1196        }
1197        {
1198          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;v);
1199          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), std::string*&gt;::value));
1200          EXPECT_EQ(bad_elem, nullptr);
1201        }
1202        {
1203          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;v);
1204          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1205          EXPECT_EQ(bad_elem, nullptr);
1206        }
1207      }
1208      const Var&amp; const_v = v;
1209      EXPECT_TRUE(noexcept(absl::get_if&lt;2&gt;(&amp;const_v)));
1210      {
1211        auto* elem = absl::get_if&lt;2&gt;(&amp;const_v);
1212        EXPECT_TRUE((std::is_same&lt;decltype(elem), const double*&gt;::value));
1213        ASSERT_NE(elem, nullptr);
1214        EXPECT_EQ(*elem, 2.0);
1215        {
1216          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;const_v);
1217          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1218          EXPECT_EQ(bad_elem, nullptr);
1219        }
1220        {
1221          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;const_v);
1222          EXPECT_TRUE(
1223              (std::is_same&lt;decltype(bad_elem), const std::string*&gt;::value));
1224          EXPECT_EQ(bad_elem, nullptr);
1225        }
1226        {
1227          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;const_v);
1228          EXPECT_EQ(bad_elem, nullptr);
1229          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1230        }
1231      }
1232    }
1233    {
1234      Var v(absl::in_place_index&lt;0&gt;, 0);
1235      v.emplace&lt;3&gt;(1);
1236      EXPECT_TRUE(noexcept(absl::get_if&lt;3&gt;(&amp;v)));
1237      {
1238        auto* elem = absl::get_if&lt;3&gt;(&amp;v);
1239        EXPECT_TRUE((std::is_same&lt;decltype(elem), int*&gt;::value));
1240        ASSERT_NE(elem, nullptr);
1241        EXPECT_EQ(*elem, 1);
1242        {
1243          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;v);
1244          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1245          EXPECT_EQ(bad_elem, nullptr);
1246        }
1247        {
1248          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;v);
1249          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), std::string*&gt;::value));
1250          EXPECT_EQ(bad_elem, nullptr);
1251        }
1252        {
1253          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;v);
1254          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), double*&gt;::value));
1255          EXPECT_EQ(bad_elem, nullptr);
1256        }
1257      }
1258      const Var&amp; const_v = v;
1259      EXPECT_TRUE(noexcept(absl::get_if&lt;3&gt;(&amp;const_v)));
1260      {
1261        auto* elem = absl::get_if&lt;3&gt;(&amp;const_v);
1262        EXPECT_TRUE((std::is_same&lt;decltype(elem), const int*&gt;::value));
1263        ASSERT_NE(elem, nullptr);
1264        EXPECT_EQ(*elem, 1);
1265        {
1266          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;const_v);
1267          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1268          EXPECT_EQ(bad_elem, nullptr);
1269        }
1270        {
1271          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;const_v);
1272          EXPECT_TRUE(
1273              (std::is_same&lt;decltype(bad_elem), const std::string*&gt;::value));
1274          EXPECT_EQ(bad_elem, nullptr);
1275        }
1276        {
1277          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;const_v);
1278          EXPECT_EQ(bad_elem, nullptr);
1279          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const double*&gt;::value));
1280        }
1281      }
1282    }
1283  }
1284  TEST(VariantTest, OperatorEquals) {
1285    variant&lt;int, std::string&gt; a(1), b(1);
1286    EXPECT_TRUE(a == b);
1287    EXPECT_TRUE(b == a);
1288    EXPECT_FALSE(a != b);
1289    EXPECT_FALSE(b != a);
1290    b = &quot;str&quot;;
1291    EXPECT_FALSE(a == b);
1292    EXPECT_FALSE(b == a);
1293    EXPECT_TRUE(a != b);
1294    EXPECT_TRUE(b != a);
1295    b = 0;
1296    EXPECT_FALSE(a == b);
1297    EXPECT_FALSE(b == a);
1298    EXPECT_TRUE(a != b);
1299    EXPECT_TRUE(b != a);
1300    a = b = &quot;foo&quot;;
1301    EXPECT_TRUE(a == b);
1302    EXPECT_TRUE(b == a);
1303    EXPECT_FALSE(a != b);
1304    EXPECT_FALSE(b != a);
1305    a = &quot;bar&quot;;
1306    EXPECT_FALSE(a == b);
1307    EXPECT_FALSE(b == a);
1308    EXPECT_TRUE(a != b);
1309    EXPECT_TRUE(b != a);
1310  }
1311  TEST(VariantTest, OperatorRelational) {
1312    variant&lt;int, std::string&gt; a(1), b(1);
1313    EXPECT_FALSE(a &lt; b);
1314    EXPECT_FALSE(b &lt; a);
1315    EXPECT_FALSE(a &gt; b);
1316    EXPECT_FALSE(b &gt; a);
1317    EXPECT_TRUE(a &lt;= b);
1318    EXPECT_TRUE(b &lt;= a);
1319    EXPECT_TRUE(a &gt;= b);
1320    EXPECT_TRUE(b &gt;= a);
1321    b = &quot;str&quot;;
1322    EXPECT_TRUE(a &lt; b);
1323    EXPECT_FALSE(b &lt; a);
1324    EXPECT_FALSE(a &gt; b);
1325    EXPECT_TRUE(b &gt; a);
1326    EXPECT_TRUE(a &lt;= b);
1327    EXPECT_FALSE(b &lt;= a);
1328    EXPECT_FALSE(a &gt;= b);
1329    EXPECT_TRUE(b &gt;= a);
1330    b = 0;
1331    EXPECT_FALSE(a &lt; b);
1332    EXPECT_TRUE(b &lt; a);
1333    EXPECT_TRUE(a &gt; b);
1334    EXPECT_FALSE(b &gt; a);
1335    EXPECT_FALSE(a &lt;= b);
1336    EXPECT_TRUE(b &lt;= a);
1337    EXPECT_TRUE(a &gt;= b);
1338    EXPECT_FALSE(b &gt;= a);
1339    a = b = &quot;foo&quot;;
1340    EXPECT_FALSE(a &lt; b);
1341    EXPECT_FALSE(b &lt; a);
1342    EXPECT_FALSE(a &gt; b);
1343    EXPECT_FALSE(b &gt; a);
1344    EXPECT_TRUE(a &lt;= b);
1345    EXPECT_TRUE(b &lt;= a);
1346    EXPECT_TRUE(a &gt;= b);
1347    EXPECT_TRUE(b &gt;= a);
1348    a = &quot;bar&quot;;
1349    EXPECT_TRUE(a &lt; b);
1350    EXPECT_FALSE(b &lt; a);
1351    EXPECT_FALSE(a &gt; b);
1352    EXPECT_TRUE(b &gt; a);
1353    EXPECT_TRUE(a &lt;= b);
1354    EXPECT_FALSE(b &lt;= a);
1355    EXPECT_FALSE(a &gt;= b);
1356    EXPECT_TRUE(b &gt;= a);
1357  }
1358  #ifdef ABSL_HAVE_EXCEPTIONS
1359  TEST(VariantTest, ValuelessOperatorEquals) {
1360    variant&lt;MoveCanThrow, std::string&gt; int_v(1), string_v(&quot;Hello&quot;),
1361        valueless(absl::in_place_index&lt;0&gt;),
1362        other_valueless(absl::in_place_index&lt;0&gt;);
1363    ToValuelessByException(valueless);
1364    ToValuelessByException(other_valueless);
1365    EXPECT_TRUE(valueless == other_valueless);
1366    EXPECT_TRUE(other_valueless == valueless);
1367    EXPECT_FALSE(valueless == int_v);
1368    EXPECT_FALSE(valueless == string_v);
1369    EXPECT_FALSE(int_v == valueless);
1370    EXPECT_FALSE(string_v == valueless);
1371    EXPECT_FALSE(valueless != other_valueless);
1372    EXPECT_FALSE(other_valueless != valueless);
1373    EXPECT_TRUE(valueless != int_v);
1374    EXPECT_TRUE(valueless != string_v);
1375    EXPECT_TRUE(int_v != valueless);
1376    EXPECT_TRUE(string_v != valueless);
1377  }
1378  TEST(VariantTest, ValuelessOperatorRelational) {
1379    variant&lt;MoveCanThrow, std::string&gt; int_v(1), string_v(&quot;Hello&quot;),
1380        valueless(absl::in_place_index&lt;0&gt;),
1381        other_valueless(absl::in_place_index&lt;0&gt;);
1382    ToValuelessByException(valueless);
1383    ToValuelessByException(other_valueless);
1384    EXPECT_FALSE(valueless &lt; other_valueless);
1385    EXPECT_FALSE(other_valueless &lt; valueless);
1386    EXPECT_TRUE(valueless &lt; int_v);
1387    EXPECT_TRUE(valueless &lt; string_v);
1388    EXPECT_FALSE(int_v &lt; valueless);
1389    EXPECT_FALSE(string_v &lt; valueless);
1390    EXPECT_TRUE(valueless &lt;= other_valueless);
1391    EXPECT_TRUE(other_valueless &lt;= valueless);
1392    EXPECT_TRUE(valueless &lt;= int_v);
1393    EXPECT_TRUE(valueless &lt;= string_v);
1394    EXPECT_FALSE(int_v &lt;= valueless);
1395    EXPECT_FALSE(string_v &lt;= valueless);
1396    EXPECT_TRUE(valueless &gt;= other_valueless);
1397    EXPECT_TRUE(other_valueless &gt;= valueless);
1398    EXPECT_FALSE(valueless &gt;= int_v);
1399    EXPECT_FALSE(valueless &gt;= string_v);
1400    EXPECT_TRUE(int_v &gt;= valueless);
1401    EXPECT_TRUE(string_v &gt;= valueless);
1402    EXPECT_FALSE(valueless &gt; other_valueless);
1403    EXPECT_FALSE(other_valueless &gt; valueless);
1404    EXPECT_FALSE(valueless &gt; int_v);
1405    EXPECT_FALSE(valueless &gt; string_v);
1406    EXPECT_TRUE(int_v &gt; valueless);
1407    EXPECT_TRUE(string_v &gt; valueless);
1408  }
1409  #endif
1410  template &lt;typename T&gt;
1411  struct ConvertTo {
1412    template &lt;typename U&gt;
1413    T operator()(const U&amp; u) const {
1414      return u;
1415    }
1416  };
1417  TEST(VariantTest, VisitSimple) {
1418    variant&lt;std::string, const char*&gt; v = &quot;A&quot;;
1419    std::string str = absl::visit(ConvertTo&lt;std::string&gt;{}, v);
1420    EXPECT_EQ(&quot;A&quot;, str);
1421    v = std::string(&quot;B&quot;);
1422    absl::string_view piece = absl::visit(ConvertTo&lt;absl::string_view&gt;{}, v);
1423    EXPECT_EQ(&quot;B&quot;, piece);
1424    struct StrLen {
1425      size_t operator()(const char* s) const { return strlen(s); }
1426      size_t operator()(const std::string&amp; s) const { return s.size(); }
1427    };
1428    v = &quot;SomeStr&quot;;
1429    EXPECT_EQ(7u, absl::visit(StrLen{}, v));
1430    v = std::string(&quot;VeryLargeThisTime&quot;);
1431    EXPECT_EQ(17u, absl::visit(StrLen{}, v));
1432  }
1433  TEST(VariantTest, VisitRValue) {
1434    variant&lt;std::string&gt; v = std::string(&quot;X&quot;);
1435    struct Visitor {
1436      bool operator()(const std::string&amp;) const { return false; }
1437      bool operator()(std::string&amp;&amp;) const { return true; }  
1438      int operator()(const std::string&amp;, const std::string&amp;) const { return 0; }
1439      int operator()(const std::string&amp;, std::string&amp;&amp;) const {
1440        return 1;
1441      }  
1442      int operator()(std::string&amp;&amp;, const std::string&amp;) const {
1443        return 2;
1444      }                                                                 
1445      int operator()(std::string&amp;&amp;, std::string&amp;&amp;) const { return 3; }  
1446    };
1447    EXPECT_FALSE(absl::visit(Visitor{}, v));
1448    EXPECT_TRUE(absl::visit(Visitor{}, absl::move(v)));
1449    EXPECT_EQ(0, absl::visit(Visitor{}, v, v));
1450    EXPECT_EQ(1, absl::visit(Visitor{}, v, absl::move(v)));
1451    EXPECT_EQ(2, absl::visit(Visitor{}, absl::move(v), v));
1452    EXPECT_EQ(3, absl::visit(Visitor{}, absl::move(v), absl::move(v)));
1453  }
1454  TEST(VariantTest, VisitRValueVisitor) {
1455    variant&lt;std::string&gt; v = std::string(&quot;X&quot;);
1456    struct Visitor {
1457      bool operator()(const std::string&amp;) const&amp; { return false; }
1458      bool operator()(const std::string&amp;) &amp;&amp; { return true; }
1459    };
1460    Visitor visitor;
1461    EXPECT_FALSE(absl::visit(visitor, v));
1462    EXPECT_TRUE(absl::visit(Visitor{}, v));
1463  }
1464  TEST(VariantTest, VisitResultTypeDifferent) {
1465    variant&lt;std::string&gt; v = std::string(&quot;X&quot;);
1466    struct LValue_LValue {};
1467    struct RValue_LValue {};
1468    struct LValue_RValue {};
1469    struct RValue_RValue {};
1470    struct Visitor {
1471      LValue_LValue operator()(const std::string&amp;) const&amp; { return {}; }
1472      RValue_LValue operator()(std::string&amp;&amp;) const&amp; { return {}; }  
1473      LValue_RValue operator()(const std::string&amp;) &amp;&amp; { return {}; }
1474      RValue_RValue operator()(std::string&amp;&amp;) &amp;&amp; { return {}; }  
1475    } visitor;
1476    EXPECT_TRUE(
1477        (std::is_same&lt;LValue_LValue, decltype(absl::visit(visitor, v))&gt;::value));
1478    EXPECT_TRUE(
1479        (std::is_same&lt;RValue_LValue,
1480                      decltype(absl::visit(visitor, absl::move(v)))&gt;::value));
1481    EXPECT_TRUE((
1482        std::is_same&lt;LValue_RValue, decltype(absl::visit(Visitor{}, v))&gt;::value));
1483    EXPECT_TRUE(
1484        (std::is_same&lt;RValue_RValue,
1485                      decltype(absl::visit(Visitor{}, absl::move(v)))&gt;::value));
1486  }
1487  TEST(VariantTest, VisitVariadic) {
1488    using A = variant&lt;int, std::string&gt;;
1489    using B = variant&lt;std::unique_ptr&lt;int&gt;, absl::string_view&gt;;
1490    struct Visitor {
1491      std::pair&lt;int, int&gt; operator()(int a, std::unique_ptr&lt;int&gt; b) const {
1492        return {a, *b};
1493      }
1494      std::pair&lt;int, int&gt; operator()(absl::string_view a,
1495                                     std::unique_ptr&lt;int&gt; b) const {
1496        return {static_cast&lt;int&gt;(a.size()), static_cast&lt;int&gt;(*b)};
1497      }
1498      std::pair&lt;int, int&gt; operator()(int a, absl::string_view b) const {
1499        return {a, static_cast&lt;int&gt;(b.size())};
1500      }
1501      std::pair&lt;int, int&gt; operator()(absl::string_view a,
1502                                     absl::string_view b) const {
1503        return {static_cast&lt;int&gt;(a.size()), static_cast&lt;int&gt;(b.size())};
1504      }
1505    };
1506    EXPECT_THAT(absl::visit(Visitor(), A(1), B(std::unique_ptr&lt;int&gt;(new int(7)))),
1507                ::testing::Pair(1, 7));
1508    EXPECT_THAT(absl::visit(Visitor(), A(1), B(absl::string_view(&quot;ABC&quot;))),
1509                ::testing::Pair(1, 3));
1510    EXPECT_THAT(absl::visit(Visitor(), A(std::string(&quot;BBBBB&quot;)),
1511                            B(std::unique_ptr&lt;int&gt;(new int(7)))),
1512                ::testing::Pair(5, 7));
1513    EXPECT_THAT(absl::visit(Visitor(), A(std::string(&quot;BBBBB&quot;)),
1514                            B(absl::string_view(&quot;ABC&quot;))),
1515                ::testing::Pair(5, 3));
1516  }
1517  TEST(VariantTest, VisitNoArgs) {
1518    EXPECT_EQ(5, absl::visit([] { return 5; }));
1519  }
1520  struct ConstFunctor {
1521    int operator()(int a, int b) const { return a - b; }
1522  };
1523  struct MutableFunctor {
1524    int operator()(int a, int b) { return a - b; }
1525  };
1526  struct Class {
1527    int Method(int a, int b) { return a - b; }
1528    int ConstMethod(int a, int b) const { return a - b; }
1529    int member;
1530  };
1531  TEST(VariantTest, VisitReferenceWrapper) {
1532    ConstFunctor cf;
1533    MutableFunctor mf;
1534    absl::variant&lt;int&gt; three = 3;
1535    absl::variant&lt;int&gt; two = 2;
1536    EXPECT_EQ(1, absl::visit(std::cref(cf), three, two));
1537    EXPECT_EQ(1, absl::visit(std::ref(cf), three, two));
1538    EXPECT_EQ(1, absl::visit(std::ref(mf), three, two));
1539  }
1540  #if !(defined(ABSL_USES_STD_VARIANT) &amp;&amp; defined(__GLIBCXX__))
1541  TEST(VariantTest, VisitMemberFunction) {
1542    absl::variant&lt;std::unique_ptr&lt;Class&gt;&gt; p(absl::make_unique&lt;Class&gt;());
1543    absl::variant&lt;std::unique_ptr&lt;const Class&gt;&gt; cp(
1544        absl::make_unique&lt;const Class&gt;());
1545    absl::variant&lt;int&gt; three = 3;
1546    absl::variant&lt;int&gt; two = 2;
1547    EXPECT_EQ(1, absl::visit(&amp;Class::Method, p, three, two));
1548    EXPECT_EQ(1, absl::visit(&amp;Class::ConstMethod, p, three, two));
1549    EXPECT_EQ(1, absl::visit(&amp;Class::ConstMethod, cp, three, two));
1550  }
1551  TEST(VariantTest, VisitDataMember) {
1552    absl::variant&lt;std::unique_ptr&lt;Class&gt;&gt; p(absl::make_unique&lt;Class&gt;(Class{42}));
1553    absl::variant&lt;std::unique_ptr&lt;const Class&gt;&gt; cp(
1554        absl::make_unique&lt;const Class&gt;(Class{42}));
1555    EXPECT_EQ(42, absl::visit(&amp;Class::member, p));
1556    absl::visit(&amp;Class::member, p) = 5;
1557    EXPECT_EQ(5, absl::visit(&amp;Class::member, p));
1558    EXPECT_EQ(42, absl::visit(&amp;Class::member, cp));
1559  }
1560  #endif  
1561  TEST(VariantTest, MonostateBasic) {
1562    absl::monostate mono;
1563    (void)mono;
1564    EXPECT_TRUE(absl::is_trivially_default_constructible&lt;absl::monostate&gt;::value);
1565    EXPECT_TRUE(is_trivially_move_constructible&lt;absl::monostate&gt;::value);
1566    EXPECT_TRUE(absl::is_trivially_copy_constructible&lt;absl::monostate&gt;::value);
1567    EXPECT_TRUE(is_trivially_move_assignable&lt;absl::monostate&gt;::value);
1568    EXPECT_TRUE(absl::is_trivially_copy_assignable&lt;absl::monostate&gt;::value);
1569    EXPECT_TRUE(absl::is_trivially_destructible&lt;absl::monostate&gt;::value);
1570  }
1571  TEST(VariantTest, VariantMonostateDefaultConstruction) {
1572    absl::variant&lt;absl::monostate, NonDefaultConstructible&gt; var;
1573    EXPECT_EQ(var.index(), 0u);
1574  }
1575  TEST(VariantTest, MonostateComparisons) {
1576    absl::monostate lhs, rhs;
1577    EXPECT_EQ(lhs, lhs);
1578    EXPECT_EQ(lhs, rhs);
1579    EXPECT_FALSE(lhs != lhs);
1580    EXPECT_FALSE(lhs != rhs);
1581    EXPECT_FALSE(lhs &lt; lhs);
1582    EXPECT_FALSE(lhs &lt; rhs);
1583    EXPECT_FALSE(lhs &gt; lhs);
1584    EXPECT_FALSE(lhs &gt; rhs);
1585    EXPECT_LE(lhs, lhs);
1586    EXPECT_LE(lhs, rhs);
1587    EXPECT_GE(lhs, lhs);
1588    EXPECT_GE(lhs, rhs);
1589    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() ==
1590                         std::declval&lt;absl::monostate&gt;()));
1591    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() !=
1592                         std::declval&lt;absl::monostate&gt;()));
1593    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() &lt;
1594                         std::declval&lt;absl::monostate&gt;()));
1595    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() &gt;
1596                         std::declval&lt;absl::monostate&gt;()));
1597    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() &lt;=
1598                         std::declval&lt;absl::monostate&gt;()));
1599    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() &gt;=
1600                         std::declval&lt;absl::monostate&gt;()));
1601  }
1602  TEST(VariantTest, NonmemberSwap) {
1603    using std::swap;
1604    SpecialSwap v1(3);
1605    SpecialSwap v2(7);
1606    variant&lt;SpecialSwap&gt; a = v1, b = v2;
1607    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v1));
1608    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v2));
1609    std::swap(a, b);
1610    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v2));
1611    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v1));
1612  #ifndef ABSL_USES_STD_VARIANT
1613    EXPECT_FALSE(absl::get&lt;SpecialSwap&gt;(a).special_swap);
1614  #endif
1615    swap(a, b);
1616    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v1));
1617    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v2));
1618    EXPECT_TRUE(absl::get&lt;SpecialSwap&gt;(b).special_swap);
1619  }
1620  TEST(VariantTest, BadAccess) {
1621    EXPECT_TRUE(noexcept(absl::bad_variant_access()));
1622    absl::bad_variant_access exception_obj;
1623    std::exception* base = &amp;exception_obj;
1624    (void)base;
1625  }
1626  TEST(VariantTest, MonostateHash) {
1627    absl::monostate mono, other_mono;
1628    std::hash&lt;absl::monostate&gt; const hasher{};
1629    static_assert(std::is_same&lt;decltype(hasher(mono)), std::size_t&gt;::value, &quot;&quot;);
1630    EXPECT_EQ(hasher(mono), hasher(other_mono));
1631  }
1632  TEST(VariantTest, Hash) {
1633    static_assert(type_traits_internal::IsHashable&lt;variant&lt;int&gt;&gt;::value, &quot;&quot;);
1634    static_assert(type_traits_internal::IsHashable&lt;variant&lt;Hashable&gt;&gt;::value, &quot;&quot;);
1635    static_assert(type_traits_internal::IsHashable&lt;variant&lt;int, Hashable&gt;&gt;::value,
1636                  &quot;&quot;);
1637  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
1638    static_assert(!type_traits_internal::IsHashable&lt;variant&lt;NonHashable&gt;&gt;::value,
1639                  &quot;&quot;);
1640    static_assert(
1641        !type_traits_internal::IsHashable&lt;variant&lt;Hashable, NonHashable&gt;&gt;::value,
1642        &quot;&quot;);
1643  #endif
1644  #if !(defined(_MSC_VER) &amp;&amp; defined(ABSL_USES_STD_VARIANT))
1645    {
1646      variant&lt;int, int&gt; v0(in_place_index&lt;0&gt;, 42);
1647      variant&lt;int, int&gt; v1(in_place_index&lt;1&gt;, 42);
1648      std::hash&lt;variant&lt;int, int&gt;&gt; hash;
1649      EXPECT_NE(hash(v0), hash(v1));
1650    }
1651  #endif  
1652    {
1653      std::hash&lt;variant&lt;int&gt;&gt; hash;
1654      std::set&lt;size_t&gt; hashcodes;
1655      for (int i = 0; i &lt; 100; ++i) {
1656        hashcodes.insert(hash(i));
1657      }
1658      EXPECT_GT(hashcodes.size(), 90u);
1659      static_assert(type_traits_internal::IsHashable&lt;variant&lt;const int&gt;&gt;::value,
1660                    &quot;&quot;);
1661      static_assert(
1662          type_traits_internal::IsHashable&lt;variant&lt;const Hashable&gt;&gt;::value, &quot;&quot;);
1663      std::hash&lt;absl::variant&lt;const int&gt;&gt; c_hash;
1664      for (int i = 0; i &lt; 100; ++i) {
1665        EXPECT_EQ(hash(i), c_hash(i));
1666      }
1667    }
1668  }
1669  #if !defined(ABSL_USES_STD_VARIANT)
1670  TEST(VariantTest, TestConvertingSet) {
1671    typedef variant&lt;double&gt; Variant;
1672    Variant v(1.0);
1673    const int two = 2;
1674    v = two;
1675    EXPECT_TRUE(absl::holds_alternative&lt;double&gt;(v));
1676    ASSERT_TRUE(nullptr != absl::get_if&lt;double&gt;(&amp;v));
1677    EXPECT_DOUBLE_EQ(2, absl::get&lt;double&gt;(v));
1678  }
1679  #endif  
1680  TEST(VariantTest, Container) {
1681    typedef variant&lt;int, float&gt; Variant;
1682    std::vector&lt;Variant&gt; vec;
1683    vec.push_back(Variant(10));
1684    vec.push_back(Variant(20.0f));
1685    vec.resize(10, Variant(0));
1686  }
1687  TEST(VariantTest, TestVariantWithNonCopyableType) {
1688    typedef variant&lt;int, NonCopyable&gt; Variant;
1689    const int kValue = 1;
1690    Variant v(kValue);
1691    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1692    EXPECT_EQ(kValue, absl::get&lt;int&gt;(v));
1693  }
1694  TEST(VariantTest, TestEmplace) {
1695    typedef variant&lt;int, NonCopyable&gt; Variant;
1696    const int kValue = 1;
1697    Variant v(kValue);
1698    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1699    EXPECT_EQ(kValue, absl::get&lt;int&gt;(v));
1700    v.emplace&lt;NonCopyable&gt;();
1701    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1702    EXPECT_EQ(0, absl::get&lt;NonCopyable&gt;(v).value);
1703    v = kValue;
1704    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1705    v.emplace&lt;NonCopyable&gt;(1);
1706    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1707    EXPECT_EQ(1, absl::get&lt;NonCopyable&gt;(v).value);
1708    v = kValue;
1709    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1710    v.emplace&lt;NonCopyable&gt;(1, 2);
1711    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1712    EXPECT_EQ(3, absl::get&lt;NonCopyable&gt;(v).value);
1713    v = kValue;
1714    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1715    v.emplace&lt;NonCopyable&gt;(1, 2, 3);
1716    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1717    EXPECT_EQ(6, absl::get&lt;NonCopyable&gt;(v).value);
1718    v = kValue;
1719    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1720    v.emplace&lt;NonCopyable&gt;(1, 2, 3, 4);
1721    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1722    EXPECT_EQ(10, absl::get&lt;NonCopyable&gt;(v).value);
1723    v = kValue;
1724    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1725  }
1726  TEST(VariantTest, TestEmplaceDestroysCurrentValue) {
1727    typedef variant&lt;int, IncrementInDtor, NonCopyable&gt; Variant;
1728    int counter = 0;
1729    Variant v(0);
1730    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1731    v.emplace&lt;IncrementInDtor&gt;(&amp;counter);
1732    ASSERT_TRUE(absl::holds_alternative&lt;IncrementInDtor&gt;(v));
1733    ASSERT_EQ(0, counter);
1734    v.emplace&lt;NonCopyable&gt;();
1735    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1736    EXPECT_EQ(1, counter);
1737  }
1738  TEST(VariantTest, TestMoveSemantics) {
1739    typedef variant&lt;std::unique_ptr&lt;int&gt;, std::unique_ptr&lt;std::string&gt;&gt; Variant;
1740    Variant v(absl::WrapUnique(new int(10)));
1741    EXPECT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;int&gt;&gt;(v));
1742    Variant v2(absl::move(v));
1743    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;int&gt;&gt;(v2));
1744    ASSERT_NE(nullptr, absl::get&lt;std::unique_ptr&lt;int&gt;&gt;(v2));
1745    EXPECT_EQ(10, *absl::get&lt;std::unique_ptr&lt;int&gt;&gt;(v2));
1746    EXPECT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;int&gt;&gt;(v));
1747    ASSERT_NE(nullptr, absl::get_if&lt;std::unique_ptr&lt;int&gt;&gt;(&amp;v));
1748    EXPECT_EQ(nullptr, absl::get&lt;std::unique_ptr&lt;int&gt;&gt;(v));
1749    v = absl::make_unique&lt;std::string&gt;(&quot;foo&quot;);
1750    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;std::string&gt;&gt;(v));
1751    EXPECT_EQ(&quot;foo&quot;, *absl::get&lt;std::unique_ptr&lt;std::string&gt;&gt;(v));
1752    v2 = absl::move(v);
1753    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;std::string&gt;&gt;(v2));
1754    EXPECT_EQ(&quot;foo&quot;, *absl::get&lt;std::unique_ptr&lt;std::string&gt;&gt;(v2));
1755    EXPECT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;std::string&gt;&gt;(v));
1756  }
1757  variant&lt;int, std::string&gt; PassThrough(const variant&lt;int, std::string&gt;&amp; arg) {
1758    return arg;
1759  }
1760  TEST(VariantTest, TestImplicitConversion) {
1761    EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(PassThrough(0)));
1762    EXPECT_TRUE(
1763        absl::holds_alternative&lt;std::string&gt;(PassThrough(std::string(&quot;foo&quot;))));
1764  }
1765  struct Convertible2;
1766  struct Convertible1 {
1767    Convertible1() {}
1768    Convertible1(const Convertible1&amp;) {}
1769    Convertible1&amp; operator=(const Convertible1&amp;) { return *this; }
1770    Convertible1(const Convertible2&amp;) {}  
1771  };
1772  struct Convertible2 {
1773    Convertible2() {}
1774    Convertible2(const Convertible2&amp;) {}
1775    Convertible2&amp; operator=(const Convertible2&amp;) { return *this; }
1776    Convertible2(const Convertible1&amp;) {}  
1777  };
1778  TEST(VariantTest, TestRvalueConversion) {
1779  #if !defined(ABSL_USES_STD_VARIANT)
1780    variant&lt;double, std::string&gt; var(
1781        ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(
1782            variant&lt;std::string, int&gt;(0)));
1783    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(var));
1784    EXPECT_EQ(0.0, absl::get&lt;double&gt;(var));
1785    var = ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(
1786        variant&lt;const char*, float&gt;(&quot;foo&quot;));
1787    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(var));
1788    EXPECT_EQ(&quot;foo&quot;, absl::get&lt;std::string&gt;(var));
1789    variant&lt;double&gt; singleton(
1790        ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int, float&gt;(42)));
1791    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1792    EXPECT_EQ(42.0, absl::get&lt;double&gt;(singleton));
1793    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int, float&gt;(3.14f));
1794    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1795    EXPECT_FLOAT_EQ(3.14f, static_cast&lt;float&gt;(absl::get&lt;double&gt;(singleton)));
1796    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int&gt;(0));
1797    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1798    EXPECT_EQ(0.0, absl::get&lt;double&gt;(singleton));
1799    variant&lt;int32_t, uint32_t&gt; variant2(
1800        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(variant&lt;int32_t&gt;(42)));
1801    ASSERT_TRUE(absl::holds_alternative&lt;int32_t&gt;(variant2));
1802    EXPECT_EQ(42, absl::get&lt;int32_t&gt;(variant2));
1803    variant2 =
1804        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(variant&lt;uint32_t&gt;(42u));
1805    ASSERT_TRUE(absl::holds_alternative&lt;uint32_t&gt;(variant2));
1806    EXPECT_EQ(42u, absl::get&lt;uint32_t&gt;(variant2));
1807  #endif  
1808    variant&lt;Convertible1, Convertible2&gt; variant3(
1809        ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(
1810            (variant&lt;Convertible2, Convertible1&gt;(Convertible1()))));
1811    ASSERT_TRUE(absl::holds_alternative&lt;Convertible1&gt;(variant3));
1812    variant3 = ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(
1813        variant&lt;Convertible2, Convertible1&gt;(Convertible2()));
1814    ASSERT_TRUE(absl::holds_alternative&lt;Convertible2&gt;(variant3));
1815  }
1816  TEST(VariantTest, TestLvalueConversion) {
1817  #if !defined(ABSL_USES_STD_VARIANT)
1818    variant&lt;std::string, int&gt; source1 = 0;
1819    variant&lt;double, std::string&gt; destination(
1820        ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(source1));
1821    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(destination));
1822    EXPECT_EQ(0.0, absl::get&lt;double&gt;(destination));
1823    variant&lt;const char*, float&gt; source2 = &quot;foo&quot;;
1824    destination = ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(source2);
1825    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(destination));
1826    EXPECT_EQ(&quot;foo&quot;, absl::get&lt;std::string&gt;(destination));
1827    variant&lt;int, float&gt; source3(42);
1828    variant&lt;double&gt; singleton(ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source3));
1829    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1830    EXPECT_EQ(42.0, absl::get&lt;double&gt;(singleton));
1831    source3 = 3.14f;
1832    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source3);
1833    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1834    EXPECT_FLOAT_EQ(3.14f, static_cast&lt;float&gt;(absl::get&lt;double&gt;(singleton)));
1835    variant&lt;int&gt; source4(0);
1836    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source4);
1837    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1838    EXPECT_EQ(0.0, absl::get&lt;double&gt;(singleton));
1839    variant&lt;int32_t&gt; source5(42);
1840    variant&lt;int32_t, uint32_t&gt; variant2(
1841        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(source5));
1842    ASSERT_TRUE(absl::holds_alternative&lt;int32_t&gt;(variant2));
1843    EXPECT_EQ(42, absl::get&lt;int32_t&gt;(variant2));
1844    variant&lt;uint32_t&gt; source6(42u);
1845    variant2 = ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(source6);
1846    ASSERT_TRUE(absl::holds_alternative&lt;uint32_t&gt;(variant2));
1847    EXPECT_EQ(42u, absl::get&lt;uint32_t&gt;(variant2));
1848  #endif
1849    variant&lt;Convertible2, Convertible1&gt; source7((Convertible1()));
1850    variant&lt;Convertible1, Convertible2&gt; variant3(
1851        ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(source7));
1852    ASSERT_TRUE(absl::holds_alternative&lt;Convertible1&gt;(variant3));
1853    source7 = Convertible2();
1854    variant3 = ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(source7);
1855    ASSERT_TRUE(absl::holds_alternative&lt;Convertible2&gt;(variant3));
1856  }
1857  TEST(VariantTest, TestMoveConversion) {
1858    using Variant =
1859        variant&lt;std::unique_ptr&lt;const int&gt;, std::unique_ptr&lt;const std::string&gt;&gt;;
1860    using OtherVariant =
1861        variant&lt;std::unique_ptr&lt;int&gt;, std::unique_ptr&lt;std::string&gt;&gt;;
1862    Variant var(
1863        ConvertVariantTo&lt;Variant&gt;(OtherVariant{absl::make_unique&lt;int&gt;(0)}));
1864    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;const int&gt;&gt;(var));
1865    ASSERT_NE(absl::get&lt;std::unique_ptr&lt;const int&gt;&gt;(var), nullptr);
1866    EXPECT_EQ(0, *absl::get&lt;std::unique_ptr&lt;const int&gt;&gt;(var));
1867    var = ConvertVariantTo&lt;Variant&gt;(
1868        OtherVariant(absl::make_unique&lt;std::string&gt;(&quot;foo&quot;)));
1869    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;const std::string&gt;&gt;(var));
1870    EXPECT_EQ(&quot;foo&quot;, *absl::get&lt;std::unique_ptr&lt;const std::string&gt;&gt;(var));
1871  }
1872  TEST(VariantTest, DoesNotMoveFromLvalues) {
1873    using Variant =
1874        variant&lt;std::shared_ptr&lt;const int&gt;, std::shared_ptr&lt;const std::string&gt;&gt;;
1875    using OtherVariant =
1876        variant&lt;std::shared_ptr&lt;int&gt;, std::shared_ptr&lt;std::string&gt;&gt;;
1877    Variant v1(std::make_shared&lt;const int&gt;(0));
1878    Variant v2(v1);
1879    EXPECT_EQ(absl::get&lt;std::shared_ptr&lt;const int&gt;&gt;(v1),
1880              absl::get&lt;std::shared_ptr&lt;const int&gt;&gt;(v2));
1881    v1 = std::make_shared&lt;const std::string&gt;(&quot;foo&quot;);
1882    v2 = v1;
1883    EXPECT_EQ(absl::get&lt;std::shared_ptr&lt;const std::string&gt;&gt;(v1),
1884              absl::get&lt;std::shared_ptr&lt;const std::string&gt;&gt;(v2));
1885    OtherVariant other(std::make_shared&lt;int&gt;(0));
1886    Variant v3(ConvertVariantTo&lt;Variant&gt;(other));
1887    EXPECT_EQ(absl::get&lt;std::shared_ptr&lt;int&gt;&gt;(other),
1888              absl::get&lt;std::shared_ptr&lt;const int&gt;&gt;(v3));
1889    other = std::make_shared&lt;std::string&gt;(&quot;foo&quot;);
1890    v3 = ConvertVariantTo&lt;Variant&gt;(other);
1891    EXPECT_EQ(absl::get&lt;std::shared_ptr&lt;std::string&gt;&gt;(other),
1892              absl::get&lt;std::shared_ptr&lt;const std::string&gt;&gt;(v3));
1893  }
1894  TEST(VariantTest, TestRvalueConversionViaConvertVariantTo) {
1895  #if !defined(ABSL_USES_STD_VARIANT)
1896    variant&lt;double, std::string&gt; var(
1897        ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(
1898            variant&lt;std::string, int&gt;(3)));
1899    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;var), Pointee(3.0));
1900    var = ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(
1901        variant&lt;const char*, float&gt;(&quot;foo&quot;));
1902    EXPECT_THAT(absl::get_if&lt;std::string&gt;(&amp;var), Pointee(std::string(&quot;foo&quot;)));
1903    variant&lt;double&gt; singleton(
1904        ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int, float&gt;(42)));
1905    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(42.0));
1906    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int, float&gt;(3.14f));
1907    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(DoubleEq(3.14f)));
1908    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int&gt;(3));
1909    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(3.0));
1910    variant&lt;int32_t, uint32_t&gt; variant2(
1911        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(variant&lt;int32_t&gt;(42)));
1912    EXPECT_THAT(absl::get_if&lt;int32_t&gt;(&amp;variant2), Pointee(42));
1913    variant2 =
1914        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(variant&lt;uint32_t&gt;(42u));
1915    EXPECT_THAT(absl::get_if&lt;uint32_t&gt;(&amp;variant2), Pointee(42u));
1916  #endif
1917    variant&lt;Convertible1, Convertible2&gt; variant3(
1918        ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(
1919            (variant&lt;Convertible2, Convertible1&gt;(Convertible1()))));
1920    ASSERT_TRUE(absl::holds_alternative&lt;Convertible1&gt;(variant3));
1921    variant3 = ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(
1922        variant&lt;Convertible2, Convertible1&gt;(Convertible2()));
1923    ASSERT_TRUE(absl::holds_alternative&lt;Convertible2&gt;(variant3));
1924  }
1925  TEST(VariantTest, TestLvalueConversionViaConvertVariantTo) {
1926  #if !defined(ABSL_USES_STD_VARIANT)
1927    variant&lt;std::string, int&gt; source1 = 3;
1928    variant&lt;double, std::string&gt; destination(
1929        ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(source1));
1930    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;destination), Pointee(3.0));
1931    variant&lt;const char*, float&gt; source2 = &quot;foo&quot;;
1932    destination = ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(source2);
1933    EXPECT_THAT(absl::get_if&lt;std::string&gt;(&amp;destination),
1934                Pointee(std::string(&quot;foo&quot;)));
1935    variant&lt;int, float&gt; source3(42);
1936    variant&lt;double&gt; singleton(ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source3));
1937    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(42.0));
1938    source3 = 3.14f;
1939    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source3);
1940    EXPECT_FLOAT_EQ(3.14f, static_cast&lt;float&gt;(absl::get&lt;double&gt;(singleton)));
1941    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(DoubleEq(3.14f)));
1942    variant&lt;int&gt; source4(3);
1943    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source4);
1944    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(3.0));
1945    variant&lt;int32_t&gt; source5(42);
1946    variant&lt;int32_t, uint32_t&gt; variant2(
1947        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(source5));
1948    EXPECT_THAT(absl::get_if&lt;int32_t&gt;(&amp;variant2), Pointee(42));
1949    variant&lt;uint32_t&gt; source6(42u);
1950    variant2 = ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(source6);
1951    EXPECT_THAT(absl::get_if&lt;uint32_t&gt;(&amp;variant2), Pointee(42u));
1952  #endif  
1953    variant&lt;Convertible2, Convertible1&gt; source7((Convertible1()));
1954    variant&lt;Convertible1, Convertible2&gt; variant3(
1955        ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(source7));
1956    ASSERT_TRUE(absl::holds_alternative&lt;Convertible1&gt;(variant3));
1957    source7 = Convertible2();
1958    variant3 = ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(source7);
1959    ASSERT_TRUE(absl::holds_alternative&lt;Convertible2&gt;(variant3));
1960  }
1961  TEST(VariantTest, TestMoveConversionViaConvertVariantTo) {
1962    using Variant =
1963        variant&lt;std::unique_ptr&lt;const int&gt;, std::unique_ptr&lt;const std::string&gt;&gt;;
1964    using OtherVariant =
1965        variant&lt;std::unique_ptr&lt;int&gt;, std::unique_ptr&lt;std::string&gt;&gt;;
1966    Variant var(
1967        ConvertVariantTo&lt;Variant&gt;(OtherVariant{absl::make_unique&lt;int&gt;(3)}));
1968    EXPECT_THAT(absl::get_if&lt;std::unique_ptr&lt;const int&gt;&gt;(&amp;var),
1969                Pointee(Pointee(3)));
1970    var = ConvertVariantTo&lt;Variant&gt;(
1971        OtherVariant(absl::make_unique&lt;std::string&gt;(&quot;foo&quot;)));
1972    EXPECT_THAT(absl::get_if&lt;std::unique_ptr&lt;const std::string&gt;&gt;(&amp;var),
1973                Pointee(Pointee(std::string(&quot;foo&quot;))));
1974  }
1975  #if !(defined(ABSL_USES_STD_VARIANT) &amp;&amp; defined(__GLIBCXX__))
1976  #define ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY 1
1977  #endif
1978  TEST(VariantTest, TestCopyAndMoveTypeTraits) {
1979    EXPECT_TRUE(std::is_copy_constructible&lt;variant&lt;std::string&gt;&gt;::value);
1980    EXPECT_TRUE(absl::is_copy_assignable&lt;variant&lt;std::string&gt;&gt;::value);
1981    EXPECT_TRUE(std::is_move_constructible&lt;variant&lt;std::string&gt;&gt;::value);
1982    EXPECT_TRUE(absl::is_move_assignable&lt;variant&lt;std::string&gt;&gt;::value);
1983    EXPECT_TRUE(std::is_move_constructible&lt;variant&lt;std::unique_ptr&lt;int&gt;&gt;&gt;::value);
1984    EXPECT_TRUE(absl::is_move_assignable&lt;variant&lt;std::unique_ptr&lt;int&gt;&gt;&gt;::value);
1985    EXPECT_FALSE(
1986        std::is_copy_constructible&lt;variant&lt;std::unique_ptr&lt;int&gt;&gt;&gt;::value);
1987    EXPECT_FALSE(absl::is_copy_assignable&lt;variant&lt;std::unique_ptr&lt;int&gt;&gt;&gt;::value);
1988    EXPECT_FALSE(
1989        absl::is_trivially_copy_constructible&lt;variant&lt;std::string&gt;&gt;::value);
1990    EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;variant&lt;std::string&gt;&gt;::value);
1991  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
1992    EXPECT_TRUE(absl::is_trivially_copy_constructible&lt;variant&lt;int&gt;&gt;::value);
1993    EXPECT_TRUE(absl::is_trivially_copy_assignable&lt;variant&lt;int&gt;&gt;::value);
1994    EXPECT_TRUE(is_trivially_move_constructible&lt;variant&lt;int&gt;&gt;::value);
1995    EXPECT_TRUE(is_trivially_move_assignable&lt;variant&lt;int&gt;&gt;::value);
1996  #endif  
1997  }
1998  TEST(VariantTest, TestVectorOfMoveonlyVariant) {
1999    std::vector&lt;variant&lt;std::unique_ptr&lt;int&gt;, std::string&gt;&gt; vec;
2000    vec.push_back(absl::make_unique&lt;int&gt;(42));
2001    vec.emplace_back(&quot;Hello&quot;);
2002    vec.reserve(3);
2003    auto another_vec = absl::move(vec);
2004    ASSERT_EQ(2u, another_vec.size());
2005    EXPECT_EQ(42, *absl::get&lt;std::unique_ptr&lt;int&gt;&gt;(another_vec[0]));
2006    EXPECT_EQ(&quot;Hello&quot;, absl::get&lt;std::string&gt;(another_vec[1]));
2007  }
2008  TEST(VariantTest, NestedVariant) {
2009  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
2010    static_assert(absl::is_trivially_copy_constructible&lt;variant&lt;int&gt;&gt;(), &quot;&quot;);
2011    static_assert(absl::is_trivially_copy_assignable&lt;variant&lt;int&gt;&gt;(), &quot;&quot;);
2012    static_assert(is_trivially_move_constructible&lt;variant&lt;int&gt;&gt;(), &quot;&quot;);
2013    static_assert(is_trivially_move_assignable&lt;variant&lt;int&gt;&gt;(), &quot;&quot;);
2014    static_assert(absl::is_trivially_copy_constructible&lt;variant&lt;variant&lt;int&gt;&gt;&gt;(),
2015                  &quot;&quot;);
2016    static_assert(absl::is_trivially_copy_assignable&lt;variant&lt;variant&lt;int&gt;&gt;&gt;(),
2017                  &quot;&quot;);
2018    static_assert(is_trivially_move_constructible&lt;variant&lt;variant&lt;int&gt;&gt;&gt;(), &quot;&quot;);
2019    static_assert(is_trivially_move_assignable&lt;variant&lt;variant&lt;int&gt;&gt;&gt;(), &quot;&quot;);
2020  #endif  
2021    variant&lt;int&gt; x(42);
2022    variant&lt;variant&lt;int&gt;&gt; y(x);
2023    variant&lt;variant&lt;int&gt;&gt; z(y);
2024    EXPECT_TRUE(absl::holds_alternative&lt;variant&lt;int&gt;&gt;(z));
2025    EXPECT_EQ(x, absl::get&lt;variant&lt;int&gt;&gt;(z));
2026  }
2027  struct TriviallyDestructible {
2028    TriviallyDestructible(TriviallyDestructible&amp;&amp;) {}
2029    TriviallyDestructible(const TriviallyDestructible&amp;) {}
2030    TriviallyDestructible&amp; operator=(TriviallyDestructible&amp;&amp;) { return *this; }
2031    TriviallyDestructible&amp; operator=(const TriviallyDestructible&amp;) {
2032      return *this;
2033    }
2034  };
2035  struct TriviallyMovable {
2036    TriviallyMovable(TriviallyMovable&amp;&amp;) = default;
2037    TriviallyMovable(TriviallyMovable const&amp;) {}
2038    TriviallyMovable&amp; operator=(const TriviallyMovable&amp;) { return *this; }
2039  };
2040  struct TriviallyCopyable {
2041    TriviallyCopyable(const TriviallyCopyable&amp;) = default;
2042    TriviallyCopyable&amp; operator=(const TriviallyCopyable&amp;) { return *this; }
2043  };
2044  struct TriviallyMoveAssignable {
2045    TriviallyMoveAssignable(TriviallyMoveAssignable&amp;&amp;) = default;
2046    TriviallyMoveAssignable(const TriviallyMoveAssignable&amp;) {}
2047    TriviallyMoveAssignable&amp; operator=(TriviallyMoveAssignable&amp;&amp;) = default;
2048    TriviallyMoveAssignable&amp; operator=(const TriviallyMoveAssignable&amp;) {
2049      return *this;
2050    }
2051  };
2052  struct TriviallyCopyAssignable {};
2053  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
2054  TEST(VariantTest, TestTriviality) {
2055    {
2056      using TrivDestVar = absl::variant&lt;TriviallyDestructible&gt;;
2057      EXPECT_FALSE(is_trivially_move_constructible&lt;TrivDestVar&gt;::value);
2058      EXPECT_FALSE(absl::is_trivially_copy_constructible&lt;TrivDestVar&gt;::value);
2059      EXPECT_FALSE(is_trivially_move_assignable&lt;TrivDestVar&gt;::value);
2060      EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;TrivDestVar&gt;::value);
2061      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivDestVar&gt;::value);
2062    }
2063    {
2064      using TrivMoveVar = absl::variant&lt;TriviallyMovable&gt;;
2065      EXPECT_TRUE(is_trivially_move_constructible&lt;TrivMoveVar&gt;::value);
2066      EXPECT_FALSE(absl::is_trivially_copy_constructible&lt;TrivMoveVar&gt;::value);
2067      EXPECT_FALSE(is_trivially_move_assignable&lt;TrivMoveVar&gt;::value);
2068      EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;TrivMoveVar&gt;::value);
2069      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivMoveVar&gt;::value);
2070    }
2071    {
2072      using TrivCopyVar = absl::variant&lt;TriviallyCopyable&gt;;
2073      EXPECT_TRUE(is_trivially_move_constructible&lt;TrivCopyVar&gt;::value);
2074      EXPECT_TRUE(absl::is_trivially_copy_constructible&lt;TrivCopyVar&gt;::value);
2075      EXPECT_FALSE(is_trivially_move_assignable&lt;TrivCopyVar&gt;::value);
2076      EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;TrivCopyVar&gt;::value);
2077      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivCopyVar&gt;::value);
2078    }
2079    {
2080      using TrivMoveAssignVar = absl::variant&lt;TriviallyMoveAssignable&gt;;
2081      EXPECT_TRUE(is_trivially_move_constructible&lt;TrivMoveAssignVar&gt;::value);
2082      EXPECT_FALSE(
2083          absl::is_trivially_copy_constructible&lt;TrivMoveAssignVar&gt;::value);
2084      EXPECT_TRUE(is_trivially_move_assignable&lt;TrivMoveAssignVar&gt;::value);
2085      EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;TrivMoveAssignVar&gt;::value);
2086      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivMoveAssignVar&gt;::value);
2087    }
2088    {
2089      using TrivCopyAssignVar = absl::variant&lt;TriviallyCopyAssignable&gt;;
2090      EXPECT_TRUE(is_trivially_move_constructible&lt;TrivCopyAssignVar&gt;::value);
2091      EXPECT_TRUE(
2092          absl::is_trivially_copy_constructible&lt;TrivCopyAssignVar&gt;::value);
2093      EXPECT_TRUE(is_trivially_move_assignable&lt;TrivCopyAssignVar&gt;::value);
2094      EXPECT_TRUE(absl::is_trivially_copy_assignable&lt;TrivCopyAssignVar&gt;::value);
2095      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivCopyAssignVar&gt;::value);
2096    }
2097  }
2098  #endif  
2099  TEST(VariantTest, MoveCtorBug) {
2100    struct TrivialCopyNontrivialMove {
2101      TrivialCopyNontrivialMove() = default;
2102      TrivialCopyNontrivialMove(const TrivialCopyNontrivialMove&amp;) = default;
2103      TrivialCopyNontrivialMove(TrivialCopyNontrivialMove&amp;&amp;) { called = true; }
2104      bool called = false;
2105    };
2106    {
2107      using V = absl::variant&lt;TrivialCopyNontrivialMove, int&gt;;
2108      V v1(absl::in_place_index&lt;0&gt;);
2109      V v2(std::move(v1));
2110      EXPECT_TRUE(absl::get&lt;0&gt;(v2).called);
2111    }
2112    {
2113      using V = absl::variant&lt;int, TrivialCopyNontrivialMove&gt;;
2114      V v1(absl::in_place_index&lt;1&gt;);
2115      V v2(std::move(v1));
2116      EXPECT_TRUE(absl::get&lt;1&gt;(v2).called);
2117    }
2118  }
2119  }  
2120  ABSL_NAMESPACE_END
2121  }  
2122  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_test.cc</h3>
            <pre><code>1  #include &quot;absl/types/variant.h&quot;
2  #if !defined(ABSL_USES_STD_VARIANT)
3  #include &lt;algorithm&gt;
4  #include &lt;cstddef&gt;
5  #include &lt;functional&gt;
6  #include &lt;initializer_list&gt;
7  #include &lt;memory&gt;
8  #include &lt;ostream&gt;
9  #include &lt;queue&gt;
10  #include &lt;type_traits&gt;
11  #include &lt;unordered_set&gt;
12  #include &lt;utility&gt;
13  #include &lt;vector&gt;
14  #include &quot;gmock/gmock.h&quot;
15  #include &quot;gtest/gtest.h&quot;
16  #include &quot;absl/base/config.h&quot;
17  #include &quot;absl/base/port.h&quot;
18  #include &quot;absl/memory/memory.h&quot;
19  #include &quot;absl/meta/type_traits.h&quot;
20  #include &quot;absl/strings/string_view.h&quot;
21  #ifdef ABSL_HAVE_EXCEPTIONS
22  #define ABSL_VARIANT_TEST_EXPECT_FAIL(expr, exception_t, text) \
23    EXPECT_THROW(expr, exception_t)
24  #else
25  #define ABSL_VARIANT_TEST_EXPECT_FAIL(expr, exception_t, text) \
26    EXPECT_DEATH_IF_SUPPORTED(expr, text)
27  #endif  
28  #define ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(...)                 \
29    ABSL_VARIANT_TEST_EXPECT_FAIL((void)(__VA_ARGS__), absl::bad_variant_access, \
30                                  &quot;Bad variant access&quot;)
31  struct Hashable {};
32  namespace std {
33  template &lt;&gt;
34  struct hash&lt;Hashable&gt; {
35    size_t operator()(const Hashable&amp;);
36  };
37  }  
38  struct NonHashable {};
39  namespace absl {
40  ABSL_NAMESPACE_BEGIN
41  namespace {
42  using ::testing::DoubleEq;
43  using ::testing::Pointee;
44  using ::testing::VariantWith;
45  struct MoveCanThrow {
46    MoveCanThrow() : v(0) {}
47    MoveCanThrow(int v) : v(v) {}  
48    MoveCanThrow(const MoveCanThrow&amp; other) : v(other.v) {}
49    MoveCanThrow&amp; operator=(const MoveCanThrow&amp; &amp;bsol;*other*/) { return *this; }
50    int v;
51  };
52  bool operator==(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v == rhs.v; }
53  bool operator!=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v != rhs.v; }
54  bool operator&lt;(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v &lt; rhs.v; }
55  bool operator&lt;=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v &lt;= rhs.v; }
56  bool operator&gt;=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v &gt;= rhs.v; }
57  bool operator&gt;(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v &gt; rhs.v; }
58  struct SpecialSwap {
59    explicit SpecialSwap(int i) : i(i) {}
60    friend void swap(SpecialSwap&amp; a, SpecialSwap&amp; b) {
61      a.special_swap = b.special_swap = true;
62      std::swap(a.i, b.i);
63    }
64    bool operator==(SpecialSwap other) const { return i == other.i; }
65    int i;
66    bool special_swap = false;
67  };
68  struct MoveOnlyWithListConstructor {
69    MoveOnlyWithListConstructor() = default;
70    explicit MoveOnlyWithListConstructor(std::initializer_list&lt;int&gt; &amp;bsol;*ilist*/,
71                                         int value)
72        : value(value) {}
73    MoveOnlyWithListConstructor(MoveOnlyWithListConstructor&amp;&amp;) = default;
74    MoveOnlyWithListConstructor&amp; operator=(MoveOnlyWithListConstructor&amp;&amp;) =
75        default;
76    int value = 0;
77  };
78  #ifdef ABSL_HAVE_EXCEPTIONS
79  struct ConversionException {};
80  template &lt;class T&gt;
81  struct ExceptionOnConversion {
82    operator T() const {  
83      throw ConversionException();
84    }
85  };
86  template &lt;class H, class... T&gt;
87  void ToValuelessByException(absl::variant&lt;H, T...&gt;&amp; v) {  
88    try {
89      v.template emplace&lt;0&gt;(ExceptionOnConversion&lt;H&gt;());
90    } catch (ConversionException&amp; &amp;bsol;*e*/) {
91    }
92  }
93  #endif  
94  template&lt;typename T, size_t N&gt;
95  struct ValueHolder {
96    explicit ValueHolder(const T&amp; x) : value(x) {}
97    typedef T value_type;
98    value_type value;
99    static const size_t kIndex = N;
100  };
101  template&lt;typename T, size_t N&gt;
102  const size_t ValueHolder&lt;T, N&gt;::kIndex;
103  template&lt;typename T, size_t N&gt;
104  inline bool operator==(const ValueHolder&lt;T, N&gt;&amp; left,
105                         const ValueHolder&lt;T, N&gt;&amp; right) {
106    return left.value == right.value;
107  }
108  template&lt;typename T, size_t N&gt;
109  inline bool operator!=(const ValueHolder&lt;T, N&gt;&amp; left,
110                         const ValueHolder&lt;T, N&gt;&amp; right) {
111    return left.value != right.value;
112  }
113  template&lt;typename T, size_t N&gt;
114  inline std::ostream&amp; operator&lt;&lt;(
115      std::ostream&amp; stream, const ValueHolder&lt;T, N&gt;&amp; object) {
116    return stream &lt;&lt; object.value;
117  }
118  template&lt;typename T&gt;
119  struct VariantFactory {
120    typedef variant&lt;ValueHolder&lt;T, 1&gt;, ValueHolder&lt;T, 2&gt;, ValueHolder&lt;T, 3&gt;,
121                    ValueHolder&lt;T, 4&gt;&gt;
122        Type;
123  };
124  typedef ::testing::Types&lt;ValueHolder&lt;size_t, 1&gt;, ValueHolder&lt;size_t, 2&gt;,
125                           ValueHolder&lt;size_t, 3&gt;,
126                           ValueHolder&lt;size_t, 4&gt;&gt; VariantTypes;
127  struct IncrementInDtor {
128    explicit IncrementInDtor(int* counter) : counter(counter) {}
129    ~IncrementInDtor() { *counter += 1; }
130    int* counter;
131  };
132  struct IncrementInDtorCopyCanThrow {
133    explicit IncrementInDtorCopyCanThrow(int* counter) : counter(counter) {}
134    IncrementInDtorCopyCanThrow(IncrementInDtorCopyCanThrow&amp;&amp; other) noexcept =
135        default;
136    IncrementInDtorCopyCanThrow(const IncrementInDtorCopyCanThrow&amp; other)
137        : counter(other.counter) {}
138    IncrementInDtorCopyCanThrow&amp; operator=(
139        IncrementInDtorCopyCanThrow&amp;&amp;) noexcept = default;
140    IncrementInDtorCopyCanThrow&amp; operator=(
141        IncrementInDtorCopyCanThrow const&amp; other) {
142      counter = other.counter;
143      return *this;
144    }
145    ~IncrementInDtorCopyCanThrow() { *counter += 1; }
146    int* counter;
147  };
148  inline bool operator==(const IncrementInDtor&amp; left,
149                         const IncrementInDtor&amp; right) {
150    return left.counter == right.counter;
151  }
152  inline std::ostream&amp; operator&lt;&lt;(
153      std::ostream&amp; stream, const IncrementInDtor&amp; object) {
154    return stream &lt;&lt; object.counter;
155  }
156  class CopyNoAssign {
157   public:
158    explicit CopyNoAssign(int value) : foo(value) {}
159    CopyNoAssign(const CopyNoAssign&amp; other) : foo(other.foo) {}
160    int foo;
161   private:
162    const CopyNoAssign&amp; operator=(const CopyNoAssign&amp;);
163  };
164  class NonCopyable {
165   public:
166    NonCopyable()
167        : value(0) {}
168    explicit NonCopyable(int value1)
169        : value(value1) {}
170    NonCopyable(int value1, int value2)
171        : value(value1 + value2) {}
172    NonCopyable(int value1, int value2, int value3)
173        : value(value1 + value2 + value3) {}
174    NonCopyable(int value1, int value2, int value3, int value4)
175        : value(value1 + value2 + value3 + value4) {}
176    NonCopyable(const NonCopyable&amp;) = delete;
177    NonCopyable&amp; operator=(const NonCopyable&amp;) = delete;
178    int value;
179  };
180  template &lt;typename T&gt;
181  class VariantTypesTest : public ::testing::Test {};
182  TYPED_TEST_SUITE(VariantTypesTest, VariantTypes);
183  struct NonNoexceptDefaultConstructible {
184    NonNoexceptDefaultConstructible() {}
185    int value = 5;
186  };
187  struct NonDefaultConstructible {
188    NonDefaultConstructible() = delete;
189  };
190  TEST(VariantTest, TestDefaultConstructor) {
191    {
192      using X = variant&lt;int&gt;;
193      constexpr variant&lt;int&gt; x{};
194      ASSERT_FALSE(x.valueless_by_exception());
195      ASSERT_EQ(0u, x.index());
196      EXPECT_EQ(0, absl::get&lt;0&gt;(x));
197      EXPECT_TRUE(std::is_nothrow_default_constructible&lt;X&gt;::value);
198    }
199    {
200      using X = variant&lt;NonNoexceptDefaultConstructible&gt;;
201      X x{};
202      ASSERT_FALSE(x.valueless_by_exception());
203      ASSERT_EQ(0u, x.index());
204      EXPECT_EQ(5, absl::get&lt;0&gt;(x).value);
205      EXPECT_FALSE(std::is_nothrow_default_constructible&lt;X&gt;::value);
206    }
207    {
208      using X = variant&lt;int, NonNoexceptDefaultConstructible&gt;;
209      X x{};
210      ASSERT_FALSE(x.valueless_by_exception());
211      ASSERT_EQ(0u, x.index());
212      EXPECT_EQ(0, absl::get&lt;0&gt;(x));
213      EXPECT_TRUE(std::is_nothrow_default_constructible&lt;X&gt;::value);
214    }
215    {
216      using X = variant&lt;NonNoexceptDefaultConstructible, int&gt;;
217      X x{};
218      ASSERT_FALSE(x.valueless_by_exception());
219      ASSERT_EQ(0u, x.index());
220      EXPECT_EQ(5, absl::get&lt;0&gt;(x).value);
221      EXPECT_FALSE(std::is_nothrow_default_constructible&lt;X&gt;::value);
222    }
223    EXPECT_FALSE(
224        std::is_default_constructible&lt;variant&lt;NonDefaultConstructible&gt;&gt;::value);
225    EXPECT_FALSE((std::is_default_constructible&lt;
226                  variant&lt;NonDefaultConstructible, int&gt;&gt;::value));
227    EXPECT_TRUE((std::is_default_constructible&lt;
228                 variant&lt;int, NonDefaultConstructible&gt;&gt;::value));
229  }
230  TYPED_TEST(VariantTypesTest, TestCopyCtor) {
231    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
232    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
233    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
234    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
235    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
236    const TypeParam value(TypeParam::kIndex);
237    Variant original(value);
238    Variant copied(original);
239    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(copied) ||
240                TypeParam::kIndex != 1);
241    EXPECT_TRUE(absl::holds_alternative&lt;value_type2&gt;(copied) ||
242                TypeParam::kIndex != 2);
243    EXPECT_TRUE(absl::holds_alternative&lt;value_type3&gt;(copied) ||
244                TypeParam::kIndex != 3);
245    EXPECT_TRUE(absl::holds_alternative&lt;value_type4&gt;(copied) ||
246                TypeParam::kIndex != 4);
247    EXPECT_TRUE((absl::get_if&lt;value_type1&gt;(&amp;original) ==
248                 absl::get_if&lt;value_type1&gt;(&amp;copied)) ||
249                TypeParam::kIndex == 1);
250    EXPECT_TRUE((absl::get_if&lt;value_type2&gt;(&amp;original) ==
251                 absl::get_if&lt;value_type2&gt;(&amp;copied)) ||
252                TypeParam::kIndex == 2);
253    EXPECT_TRUE((absl::get_if&lt;value_type3&gt;(&amp;original) ==
254                 absl::get_if&lt;value_type3&gt;(&amp;copied)) ||
255                TypeParam::kIndex == 3);
256    EXPECT_TRUE((absl::get_if&lt;value_type4&gt;(&amp;original) ==
257                 absl::get_if&lt;value_type4&gt;(&amp;copied)) ||
258                TypeParam::kIndex == 4);
259    EXPECT_TRUE((absl::get_if&lt;value_type1&gt;(&amp;original) ==
260                 absl::get_if&lt;value_type1&gt;(&amp;copied)) ||
261                TypeParam::kIndex == 1);
262    EXPECT_TRUE((absl::get_if&lt;value_type2&gt;(&amp;original) ==
263                 absl::get_if&lt;value_type2&gt;(&amp;copied)) ||
264                TypeParam::kIndex == 2);
265    EXPECT_TRUE((absl::get_if&lt;value_type3&gt;(&amp;original) ==
266                 absl::get_if&lt;value_type3&gt;(&amp;copied)) ||
267                TypeParam::kIndex == 3);
268    EXPECT_TRUE((absl::get_if&lt;value_type4&gt;(&amp;original) ==
269                 absl::get_if&lt;value_type4&gt;(&amp;copied)) ||
270                TypeParam::kIndex == 4);
271    const TypeParam* ovalptr = absl::get_if&lt;TypeParam&gt;(&amp;original);
272    const TypeParam* cvalptr = absl::get_if&lt;TypeParam&gt;(&amp;copied);
273    ASSERT_TRUE(ovalptr != nullptr);
274    ASSERT_TRUE(cvalptr != nullptr);
275    EXPECT_EQ(*ovalptr, *cvalptr);
276    TypeParam* mutable_ovalptr = absl::get_if&lt;TypeParam&gt;(&amp;original);
277    TypeParam* mutable_cvalptr = absl::get_if&lt;TypeParam&gt;(&amp;copied);
278    ASSERT_TRUE(mutable_ovalptr != nullptr);
279    ASSERT_TRUE(mutable_cvalptr != nullptr);
280    EXPECT_EQ(*mutable_ovalptr, *mutable_cvalptr);
281  }
282  template &lt;class&gt;
283  struct MoveOnly {
284    MoveOnly() = default;
285    explicit MoveOnly(int value) : value(value) {}
286    MoveOnly(MoveOnly&amp;&amp;) = default;
287    MoveOnly&amp; operator=(MoveOnly&amp;&amp;) = default;
288    int value = 5;
289  };
290  TEST(VariantTest, TestMoveConstruct) {
291    using V = variant&lt;MoveOnly&lt;class A&gt;, MoveOnly&lt;class B&gt;, MoveOnly&lt;class C&gt;&gt;;
292    V v(in_place_index&lt;1&gt;, 10);
293    V v2 = absl::move(v);
294    EXPECT_EQ(10, absl::get&lt;1&gt;(v2).value);
295  }
296  template &lt;class T&gt;
297  union SingleUnion {
298    T member;
299  };
300  template &lt;class T&gt;
301  struct is_trivially_move_constructible
302      : std::is_move_constructible&lt;SingleUnion&lt;T&gt;&gt;::type {};
303  template &lt;class T&gt;
304  struct is_trivially_move_assignable
305      : absl::is_move_assignable&lt;SingleUnion&lt;T&gt;&gt;::type {};
306  TEST(VariantTest, NothrowMoveConstructible) {
307    using U = std::unique_ptr&lt;int&gt;;
308    struct E {
309      E(E&amp;&amp;) {}
310    };
311    static_assert(std::is_nothrow_move_constructible&lt;variant&lt;U&gt;&gt;::value, &quot;&quot;);
312    static_assert(std::is_nothrow_move_constructible&lt;variant&lt;U, int&gt;&gt;::value, &quot;&quot;);
313    static_assert(!std::is_nothrow_move_constructible&lt;variant&lt;U, E&gt;&gt;::value, &quot;&quot;);
314  }
315  TYPED_TEST(VariantTypesTest, TestValueCtor) {
316    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
317    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
318    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
319    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
320    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
321    const TypeParam value(TypeParam::kIndex);
<span onclick='openModal()' class='match'>322    Variant v(value);
323    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(v) ||
324                TypeParam::kIndex != 1);
325    EXPECT_TRUE(absl::holds_alternative&lt;value_type2&gt;(v) ||
326                TypeParam::kIndex != 2);
327    EXPECT_TRUE(absl::holds_alternative&lt;value_type3&gt;(v) ||
328                TypeParam::kIndex != 3);
329    EXPECT_TRUE(absl::holds_alternative&lt;value_type4&gt;(v) ||
330                TypeParam::kIndex != 4);
331    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type1&gt;(&amp;v) ||
</span>332                TypeParam::kIndex != 1);
333    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type2&gt;(&amp;v) ||
334                TypeParam::kIndex != 2);
335    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type3&gt;(&amp;v) ||
336                TypeParam::kIndex != 3);
337    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type4&gt;(&amp;v) ||
338                TypeParam::kIndex != 4);
339    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type1&gt;(&amp;v) ||
340                TypeParam::kIndex != 1);
341    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type2&gt;(&amp;v) ||
342                TypeParam::kIndex != 2);
343    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type3&gt;(&amp;v) ||
344                TypeParam::kIndex != 3);
345    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type4&gt;(&amp;v) ||
346                TypeParam::kIndex != 4);
347    const TypeParam* valptr = absl::get_if&lt;TypeParam&gt;(&amp;v);
348    ASSERT_TRUE(nullptr != valptr);
349    EXPECT_EQ(value.value, valptr-&gt;value);
350    const TypeParam* mutable_valptr = absl::get_if&lt;TypeParam&gt;(&amp;v);
351    ASSERT_TRUE(nullptr != mutable_valptr);
352    EXPECT_EQ(value.value, mutable_valptr-&gt;value);
353  }
354  TEST(VariantTest, AmbiguousValueConstructor) {
355    EXPECT_FALSE((std::is_convertible&lt;int, absl::variant&lt;int, int&gt;&gt;::value));
356    EXPECT_FALSE((std::is_constructible&lt;absl::variant&lt;int, int&gt;, int&gt;::value));
357  }
358  TEST(VariantTest, InPlaceType) {
359    using Var = variant&lt;int, std::string, NonCopyable, std::vector&lt;int&gt;&gt;;
360    Var v1(in_place_type_t&lt;int&gt;(), 7);
361    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v1));
362    EXPECT_EQ(7, absl::get&lt;int&gt;(v1));
363    Var v2(in_place_type_t&lt;std::string&gt;(), &quot;ABC&quot;);
364    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v2));
365    EXPECT_EQ(&quot;ABC&quot;, absl::get&lt;std::string&gt;(v2));
366    Var v3(in_place_type_t&lt;std::string&gt;(), &quot;ABC&quot;, 2u);
367    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v3));
368    EXPECT_EQ(&quot;AB&quot;, absl::get&lt;std::string&gt;(v3));
369    Var v4(in_place_type_t&lt;NonCopyable&gt;{});
370    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v4));
371    Var v5(in_place_type_t&lt;std::vector&lt;int&gt;&gt;(), {1, 2, 3});
372    ASSERT_TRUE(absl::holds_alternative&lt;std::vector&lt;int&gt;&gt;(v5));
373    EXPECT_THAT(absl::get&lt;std::vector&lt;int&gt;&gt;(v5), ::testing::ElementsAre(1, 2, 3));
374  }
375  TEST(VariantTest, InPlaceTypeVariableTemplate) {
376    using Var = variant&lt;int, std::string, NonCopyable, std::vector&lt;int&gt;&gt;;
377    Var v1(in_place_type&lt;int&gt;, 7);
378    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v1));
379    EXPECT_EQ(7, absl::get&lt;int&gt;(v1));
380    Var v2(in_place_type&lt;std::string&gt;, &quot;ABC&quot;);
381    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v2));
382    EXPECT_EQ(&quot;ABC&quot;, absl::get&lt;std::string&gt;(v2));
383    Var v3(in_place_type&lt;std::string&gt;, &quot;ABC&quot;, 2u);
384    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v3));
385    EXPECT_EQ(&quot;AB&quot;, absl::get&lt;std::string&gt;(v3));
386    Var v4(in_place_type&lt;NonCopyable&gt;);
387    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v4));
388    Var v5(in_place_type&lt;std::vector&lt;int&gt;&gt;, {1, 2, 3});
389    ASSERT_TRUE(absl::holds_alternative&lt;std::vector&lt;int&gt;&gt;(v5));
390    EXPECT_THAT(absl::get&lt;std::vector&lt;int&gt;&gt;(v5), ::testing::ElementsAre(1, 2, 3));
391  }
392  TEST(VariantTest, InPlaceTypeInitializerList) {
393    using Var =
394        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
395    Var v1(in_place_type_t&lt;MoveOnlyWithListConstructor&gt;(), {1, 2, 3, 4, 5}, 6);
396    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
397    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
398  }
399  TEST(VariantTest, InPlaceTypeInitializerListVariabletemplate) {
400    using Var =
401        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
402    Var v1(in_place_type&lt;MoveOnlyWithListConstructor&gt;, {1, 2, 3, 4, 5}, 6);
403    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
404    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
405  }
406  TEST(VariantTest, InPlaceIndex) {
407    using Var = variant&lt;int, std::string, NonCopyable, std::vector&lt;int&gt;&gt;;
408    Var v1(in_place_index_t&lt;0&gt;(), 7);
409    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v1));
410    EXPECT_EQ(7, absl::get&lt;int&gt;(v1));
411    Var v2(in_place_index_t&lt;1&gt;(), &quot;ABC&quot;);
412    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v2));
413    EXPECT_EQ(&quot;ABC&quot;, absl::get&lt;std::string&gt;(v2));
414    Var v3(in_place_index_t&lt;1&gt;(), &quot;ABC&quot;, 2u);
415    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v3));
416    EXPECT_EQ(&quot;AB&quot;, absl::get&lt;std::string&gt;(v3));
417    Var v4(in_place_index_t&lt;2&gt;{});
418    EXPECT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v4));
419    EXPECT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(
420        variant&lt;NonCopyable&gt;(in_place_index_t&lt;0&gt;{})));
421    Var v5(in_place_index_t&lt;3&gt;(), {1, 2, 3});
422    ASSERT_TRUE(absl::holds_alternative&lt;std::vector&lt;int&gt;&gt;(v5));
423    EXPECT_THAT(absl::get&lt;std::vector&lt;int&gt;&gt;(v5), ::testing::ElementsAre(1, 2, 3));
424  }
425  TEST(VariantTest, InPlaceIndexVariableTemplate) {
426    using Var = variant&lt;int, std::string, NonCopyable, std::vector&lt;int&gt;&gt;;
427    Var v1(in_place_index&lt;0&gt;, 7);
428    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v1));
429    EXPECT_EQ(7, absl::get&lt;int&gt;(v1));
430    Var v2(in_place_index&lt;1&gt;, &quot;ABC&quot;);
431    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v2));
432    EXPECT_EQ(&quot;ABC&quot;, absl::get&lt;std::string&gt;(v2));
433    Var v3(in_place_index&lt;1&gt;, &quot;ABC&quot;, 2u);
434    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(v3));
435    EXPECT_EQ(&quot;AB&quot;, absl::get&lt;std::string&gt;(v3));
436    Var v4(in_place_index&lt;2&gt;);
437    EXPECT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v4));
438    EXPECT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(
439        variant&lt;NonCopyable&gt;(in_place_index&lt;0&gt;)));
440    Var v5(in_place_index&lt;3&gt;, {1, 2, 3});
441    ASSERT_TRUE(absl::holds_alternative&lt;std::vector&lt;int&gt;&gt;(v5));
442    EXPECT_THAT(absl::get&lt;std::vector&lt;int&gt;&gt;(v5), ::testing::ElementsAre(1, 2, 3));
443  }
444  TEST(VariantTest, InPlaceIndexInitializerList) {
445    using Var =
446        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
447    Var v1(in_place_index_t&lt;3&gt;(), {1, 2, 3, 4, 5}, 6);
448    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
449    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
450  }
451  TEST(VariantTest, InPlaceIndexInitializerListVariableTemplate) {
452    using Var =
453        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
454    Var v1(in_place_index&lt;3&gt;, {1, 2, 3, 4, 5}, 6);
455    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
456    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
457  }
458  TEST(VariantTest, TestDtor) {
459    typedef VariantFactory&lt;IncrementInDtor&gt;::Type Variant;
460    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
461    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
462    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
463    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
464    int counter = 0;
465    IncrementInDtor counter_adjuster(&amp;counter);
466    EXPECT_EQ(0, counter);
467    value_type1 value1(counter_adjuster);
468    { Variant object(value1); }
469    EXPECT_EQ(1, counter);
470    value_type2 value2(counter_adjuster);
471    { Variant object(value2); }
472    EXPECT_EQ(2, counter);
473    value_type3 value3(counter_adjuster);
474    { Variant object(value3); }
475    EXPECT_EQ(3, counter);
476    value_type4 value4(counter_adjuster);
477    { Variant object(value4); }
478    EXPECT_EQ(4, counter);
479  }
480  #ifdef ABSL_HAVE_EXCEPTIONS
481  #if defined(ABSL_INTERNAL_MSVC_2017_DBG_MODE)
482  TEST(VariantTest, DISABLED_TestDtorValuelessByException)
483  #else
484  TEST(VariantTest, TestDtorValuelessByException)
485  #endif
486  {
487    int counter = 0;
488    IncrementInDtor counter_adjuster(&amp;counter);
489    {
490      using Variant = VariantFactory&lt;IncrementInDtor&gt;::Type;
491      Variant v(in_place_index&lt;0&gt;, counter_adjuster);
492      EXPECT_EQ(0, counter);
493      ToValuelessByException(v);
494      ASSERT_TRUE(v.valueless_by_exception());
495      EXPECT_EQ(1, counter);
496    }
497    EXPECT_EQ(1, counter);
498  }
499  #endif  
500  TEST(VariantTest, TestSelfAssignment) {
501    typedef VariantFactory&lt;IncrementInDtor&gt;::Type Variant;
502    int counter = 0;
503    IncrementInDtor counter_adjuster(&amp;counter);
504    absl::variant_alternative_t&lt;0, Variant&gt; value(counter_adjuster);
505    Variant object(value);
506    object.operator=(object);
507    EXPECT_EQ(0, counter);
508    const std::string long_str(128, &#x27;a&#x27;);
509    std::string foo = long_str;
510    foo = *&amp;foo;
511    EXPECT_EQ(long_str, foo);
512    variant&lt;int, std::string&gt; so = long_str;
513    ASSERT_EQ(1u, so.index());
514    EXPECT_EQ(long_str, absl::get&lt;1&gt;(so));
515    so = *&amp;so;
516    ASSERT_EQ(1u, so.index());
517    EXPECT_EQ(long_str, absl::get&lt;1&gt;(so));
518  }
519  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValueSameTypes) {
520    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
521    const TypeParam value(TypeParam::kIndex);
522    const Variant source(value);
523    Variant target(TypeParam(value.value + 1));
524    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(source));
525    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(target));
526    ASSERT_NE(absl::get&lt;TypeParam&gt;(source), absl::get&lt;TypeParam&gt;(target));
527    target = source;
528    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(source));
529    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(target));
530    EXPECT_EQ(absl::get&lt;TypeParam&gt;(source), absl::get&lt;TypeParam&gt;(target));
531  }
532  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValuesVaryingSourceType) {
533    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
534    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
535    const TypeParam value(TypeParam::kIndex);
536    const Variant source(value);
537    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(source));
538    Variant target(value_type1(1));
539    ASSERT_TRUE(absl::holds_alternative&lt;value_type1&gt;(target));
540    target = source;
541    EXPECT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(source));
542    EXPECT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(target));
543    EXPECT_EQ(absl::get&lt;TypeParam&gt;(source), absl::get&lt;TypeParam&gt;(target));
544  }
545  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValuesVaryingTargetType) {
546    typedef typename VariantFactory&lt;typename TypeParam::value_type&gt;::Type Variant;
547    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
548    const Variant source(value_type1(1));
549    ASSERT_TRUE(absl::holds_alternative&lt;value_type1&gt;(source));
550    const TypeParam value(TypeParam::kIndex);
551    Variant target(value);
552    ASSERT_TRUE(absl::holds_alternative&lt;TypeParam&gt;(target));
553    target = source;
554    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(target));
555    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(source));
556    EXPECT_EQ(absl::get&lt;value_type1&gt;(source), absl::get&lt;value_type1&gt;(target));
557  }
558  TEST(VariantTest, TestAssign) {
559    typedef VariantFactory&lt;IncrementInDtor&gt;::Type Variant;
560    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
561    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
562    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
563    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
564    const int kSize = 4;
565    int counter[kSize];
566    std::unique_ptr&lt;IncrementInDtor&gt; counter_adjustor[kSize];
567    for (int i = 0; i != kSize; i++) {
568      counter[i] = 0;
569      counter_adjustor[i] = absl::make_unique&lt;IncrementInDtor&gt;(&amp;counter[i]);
570    }
571    value_type1 v1(*counter_adjustor[0]);
572    value_type2 v2(*counter_adjustor[1]);
573    value_type3 v3(*counter_adjustor[2]);
574    value_type4 v4(*counter_adjustor[3]);
575    {
576      Variant object(v1);
577      object = v2;
578      object = v3;
579      object = v4;
580      object = v1;
581    }
582    EXPECT_EQ(2, counter[0]);
583    EXPECT_EQ(1, counter[1]);
584    EXPECT_EQ(1, counter[2]);
585    EXPECT_EQ(1, counter[3]);
586    std::fill(std::begin(counter), std::end(counter), 0);
587    {
588      Variant object(v1);
589      object.operator=(object);
590      EXPECT_EQ(0, counter[0]);
591    }
592    {
593      Variant object(v2);
594      object.operator=(object);
595      EXPECT_EQ(0, counter[1]);
596    }
597    {
598      Variant object(v3);
599      object.operator=(object);
600      EXPECT_EQ(0, counter[2]);
601    }
602    {
603      Variant object(v4);
604      object.operator=(object);
605      EXPECT_EQ(0, counter[3]);
606    }
607    EXPECT_EQ(1, counter[0]);
608    EXPECT_EQ(1, counter[1]);
609    EXPECT_EQ(1, counter[2]);
610    EXPECT_EQ(1, counter[3]);
611  }
612  TEST(VariantTest, TestBackupAssign) {
613    typedef VariantFactory&lt;IncrementInDtorCopyCanThrow&gt;::Type Variant;
614    using value_type1 = absl::variant_alternative_t&lt;0, Variant&gt;;
615    using value_type2 = absl::variant_alternative_t&lt;1, Variant&gt;;
616    using value_type3 = absl::variant_alternative_t&lt;2, Variant&gt;;
617    using value_type4 = absl::variant_alternative_t&lt;3, Variant&gt;;
618    const int kSize = 4;
619    int counter[kSize];
620    std::unique_ptr&lt;IncrementInDtorCopyCanThrow&gt; counter_adjustor[kSize];
621    for (int i = 0; i != kSize; i++) {
622      counter[i] = 0;
623      counter_adjustor[i].reset(new IncrementInDtorCopyCanThrow(&amp;counter[i]));
624    }
625    value_type1 v1(*counter_adjustor[0]);
626    value_type2 v2(*counter_adjustor[1]);
627    value_type3 v3(*counter_adjustor[2]);
628    value_type4 v4(*counter_adjustor[3]);
629    {
630      Variant object(v1);
631      object = v2;
632      object = v3;
633      object = v4;
634      object = v1;
635    }
636  #if !(defined(ABSL_USES_STD_VARIANT) &amp;&amp; defined(__GLIBCXX__))
637    EXPECT_EQ(3, counter[0]);
638    EXPECT_EQ(2, counter[1]);
639    EXPECT_EQ(2, counter[2]);
640    EXPECT_EQ(2, counter[3]);
641  #endif
642    std::fill(std::begin(counter), std::end(counter), 0);
643    {
644      Variant object(v1);
645      object.operator=(object);
646      EXPECT_EQ(0, counter[0]);
647    }
648    {
649      Variant object(v2);
650      object.operator=(object);
651      EXPECT_EQ(0, counter[1]);
652    }
653    {
654      Variant object(v3);
655      object.operator=(object);
656      EXPECT_EQ(0, counter[2]);
657    }
658    {
659      Variant object(v4);
660      object.operator=(object);
661      EXPECT_EQ(0, counter[3]);
662    }
663    EXPECT_EQ(1, counter[0]);
664    EXPECT_EQ(1, counter[1]);
665    EXPECT_EQ(1, counter[2]);
666    EXPECT_EQ(1, counter[3]);
667  }
668  TEST(VariantTest, TestEmplaceBasic) {
669    using Variant = variant&lt;int, char&gt;;
670    Variant v(absl::in_place_index&lt;0&gt;, 0);
671    {
672      char&amp; emplace_result = v.emplace&lt;char&gt;();
673      ASSERT_TRUE(absl::holds_alternative&lt;char&gt;(v));
674      EXPECT_EQ(absl::get&lt;char&gt;(v), 0);
675      EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;char&gt;(v));
676    }
677    absl::get&lt;char&gt;(v) = &#x27;a&#x27;;
678    v.emplace&lt;char&gt;(&#x27;b&#x27;);
679    ASSERT_TRUE(absl::holds_alternative&lt;char&gt;(v));
680    EXPECT_EQ(absl::get&lt;char&gt;(v), &#x27;b&#x27;);
681    {
682      int&amp; emplace_result = v.emplace&lt;int&gt;();
683      EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(v));
684      EXPECT_EQ(absl::get&lt;int&gt;(v), 0);
685      EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;int&gt;(v));
686    }
687  }
688  TEST(VariantTest, TestEmplaceInitializerList) {
689    using Var =
690        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
691    Var v1(absl::in_place_index&lt;0&gt;, 555);
692    MoveOnlyWithListConstructor&amp; emplace_result =
693        v1.emplace&lt;MoveOnlyWithListConstructor&gt;({1, 2, 3, 4, 5}, 6);
694    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
695    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
696    EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;MoveOnlyWithListConstructor&gt;(v1));
697  }
698  TEST(VariantTest, TestEmplaceIndex) {
699    using Variant = variant&lt;int, char&gt;;
700    Variant v(absl::in_place_index&lt;0&gt;, 555);
701    {
702      char&amp; emplace_result = v.emplace&lt;1&gt;();
703      ASSERT_TRUE(absl::holds_alternative&lt;char&gt;(v));
704      EXPECT_EQ(absl::get&lt;char&gt;(v), 0);
705      EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;char&gt;(v));
706    }
707    absl::get&lt;char&gt;(v) = &#x27;a&#x27;;
708    v.emplace&lt;1&gt;(&#x27;b&#x27;);
709    ASSERT_TRUE(absl::holds_alternative&lt;char&gt;(v));
710    EXPECT_EQ(absl::get&lt;char&gt;(v), &#x27;b&#x27;);
711    {
712      int&amp; emplace_result = v.emplace&lt;0&gt;();
713      EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(v));
714      EXPECT_EQ(absl::get&lt;int&gt;(v), 0);
715      EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;int&gt;(v));
716    }
717  }
718  TEST(VariantTest, TestEmplaceIndexInitializerList) {
719    using Var =
720        variant&lt;int, std::string, NonCopyable, MoveOnlyWithListConstructor&gt;;
721    Var v1(absl::in_place_index&lt;0&gt;, 555);
722    MoveOnlyWithListConstructor&amp; emplace_result =
723        v1.emplace&lt;3&gt;({1, 2, 3, 4, 5}, 6);
724    ASSERT_TRUE(absl::holds_alternative&lt;MoveOnlyWithListConstructor&gt;(v1));
725    EXPECT_EQ(6, absl::get&lt;MoveOnlyWithListConstructor&gt;(v1).value);
726    EXPECT_EQ(&amp;emplace_result, &amp;absl::get&lt;MoveOnlyWithListConstructor&gt;(v1));
727  }
728  TEST(VariantTest, Index) {
729    using Var = variant&lt;int, std::string, double&gt;;
730    Var v = 1;
731    EXPECT_EQ(0u, v.index());
732    v = &quot;str&quot;;
733    EXPECT_EQ(1u, v.index());
734    v = 0.;
735    EXPECT_EQ(2u, v.index());
736    Var v2 = v;
737    EXPECT_EQ(2u, v2.index());
738    v2.emplace&lt;int&gt;(3);
739    EXPECT_EQ(0u, v2.index());
740  }
741  TEST(VariantTest, NotValuelessByException) {
742    using Var = variant&lt;int, std::string, double&gt;;
743    Var v = 1;
744    EXPECT_FALSE(v.valueless_by_exception());
745    v = &quot;str&quot;;
746    EXPECT_FALSE(v.valueless_by_exception());
747    v = 0.;
748    EXPECT_FALSE(v.valueless_by_exception());
749    Var v2 = v;
750    EXPECT_FALSE(v.valueless_by_exception());
751    v2.emplace&lt;int&gt;(3);
752    EXPECT_FALSE(v.valueless_by_exception());
753  }
754  #ifdef ABSL_HAVE_EXCEPTIONS
755  TEST(VariantTest, IndexValuelessByException) {
756    using Var = variant&lt;MoveCanThrow, std::string, double&gt;;
757    Var v(absl::in_place_index&lt;0&gt;);
758    EXPECT_EQ(0u, v.index());
759    ToValuelessByException(v);
760    EXPECT_EQ(absl::variant_npos, v.index());
761    v = &quot;str&quot;;
762    EXPECT_EQ(1u, v.index());
763  }
764  TEST(VariantTest, ValuelessByException) {
765    using Var = variant&lt;MoveCanThrow, std::string, double&gt;;
766    Var v(absl::in_place_index&lt;0&gt;);
767    EXPECT_FALSE(v.valueless_by_exception());
768    ToValuelessByException(v);
769    EXPECT_TRUE(v.valueless_by_exception());
770    v = &quot;str&quot;;
771    EXPECT_FALSE(v.valueless_by_exception());
772  }
773  #endif  
774  TEST(VariantTest, MemberSwap) {
775    SpecialSwap v1(3);
776    SpecialSwap v2(7);
777    variant&lt;SpecialSwap&gt; a = v1, b = v2;
778    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v1));
779    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v2));
780    a.swap(b);
781    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v2));
782    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v1));
783    EXPECT_TRUE(absl::get&lt;SpecialSwap&gt;(a).special_swap);
784    using V = variant&lt;MoveCanThrow, std::string, int&gt;;
785    int i = 33;
786    std::string s = &quot;abc&quot;;
787    {
788      V lhs(i), rhs(s);
789      lhs.swap(rhs);
790      EXPECT_THAT(lhs, VariantWith&lt;std::string&gt;(s));
791      EXPECT_THAT(rhs, VariantWith&lt;int&gt;(i));
792    }
793  #ifdef ABSL_HAVE_EXCEPTIONS
794    V valueless(in_place_index&lt;0&gt;);
795    ToValuelessByException(valueless);
796    {
797      V lhs(valueless), rhs(i);
798      lhs.swap(rhs);
799      EXPECT_THAT(lhs, VariantWith&lt;int&gt;(i));
800      EXPECT_TRUE(rhs.valueless_by_exception());
801    }
802    {
803      V lhs(s), rhs(valueless);
804      lhs.swap(rhs);
805      EXPECT_THAT(rhs, VariantWith&lt;std::string&gt;(s));
806      EXPECT_TRUE(lhs.valueless_by_exception());
807    }
808    {
809      V lhs(valueless), rhs(valueless);
810      lhs.swap(rhs);
811      EXPECT_TRUE(lhs.valueless_by_exception());
812      EXPECT_TRUE(rhs.valueless_by_exception());
813    }
814  #endif  
815  }
816  TEST(VariantTest, VariantSize) {
817    {
818      using Size1Variant = absl::variant&lt;int&gt;;
819      EXPECT_EQ(1u, absl::variant_size&lt;Size1Variant&gt;::value);
820      EXPECT_EQ(1u, absl::variant_size&lt;const Size1Variant&gt;::value);
821      EXPECT_EQ(1u, absl::variant_size&lt;volatile Size1Variant&gt;::value);
822      EXPECT_EQ(1u, absl::variant_size&lt;const volatile Size1Variant&gt;::value);
823    }
824    {
825      using Size3Variant = absl::variant&lt;int, float, int&gt;;
826      EXPECT_EQ(3u, absl::variant_size&lt;Size3Variant&gt;::value);
827      EXPECT_EQ(3u, absl::variant_size&lt;const Size3Variant&gt;::value);
828      EXPECT_EQ(3u, absl::variant_size&lt;volatile Size3Variant&gt;::value);
829      EXPECT_EQ(3u, absl::variant_size&lt;const volatile Size3Variant&gt;::value);
830    }
831  }
832  TEST(VariantTest, VariantAlternative) {
833    {
834      using V = absl::variant&lt;float, int, const char*&gt;;
835      EXPECT_TRUE(
836          (std::is_same&lt;float, absl::variant_alternative_t&lt;0, V&gt;&gt;::value));
837      EXPECT_TRUE((std::is_same&lt;const float,
838                                absl::variant_alternative_t&lt;0, const V&gt;&gt;::value));
839      EXPECT_TRUE(
840          (std::is_same&lt;volatile float,
841                        absl::variant_alternative_t&lt;0, volatile V&gt;&gt;::value));
842      EXPECT_TRUE((
843          std::is_same&lt;const volatile float,
844                       absl::variant_alternative_t&lt;0, const volatile V&gt;&gt;::value));
845      EXPECT_TRUE((std::is_same&lt;int, absl::variant_alternative_t&lt;1, V&gt;&gt;::value));
846      EXPECT_TRUE((std::is_same&lt;const int,
847                                absl::variant_alternative_t&lt;1, const V&gt;&gt;::value));
848      EXPECT_TRUE(
849          (std::is_same&lt;volatile int,
850                        absl::variant_alternative_t&lt;1, volatile V&gt;&gt;::value));
851      EXPECT_TRUE((
852          std::is_same&lt;const volatile int,
853                       absl::variant_alternative_t&lt;1, const volatile V&gt;&gt;::value));
854      EXPECT_TRUE(
855          (std::is_same&lt;const char*, absl::variant_alternative_t&lt;2, V&gt;&gt;::value));
856      EXPECT_TRUE((std::is_same&lt;const char* const,
857                                absl::variant_alternative_t&lt;2, const V&gt;&gt;::value));
858      EXPECT_TRUE(
859          (std::is_same&lt;const char* volatile,
860                        absl::variant_alternative_t&lt;2, volatile V&gt;&gt;::value));
861      EXPECT_TRUE((
862          std::is_same&lt;const char* const volatile,
863                       absl::variant_alternative_t&lt;2, const volatile V&gt;&gt;::value));
864    }
865    {
866      using V = absl::variant&lt;float, volatile int, const char*&gt;;
867      EXPECT_TRUE(
868          (std::is_same&lt;float, absl::variant_alternative_t&lt;0, V&gt;&gt;::value));
869      EXPECT_TRUE((std::is_same&lt;const float,
870                                absl::variant_alternative_t&lt;0, const V&gt;&gt;::value));
871      EXPECT_TRUE(
872          (std::is_same&lt;volatile float,
873                        absl::variant_alternative_t&lt;0, volatile V&gt;&gt;::value));
874      EXPECT_TRUE((
875          std::is_same&lt;const volatile float,
876                       absl::variant_alternative_t&lt;0, const volatile V&gt;&gt;::value));
877      EXPECT_TRUE(
878          (std::is_same&lt;volatile int, absl::variant_alternative_t&lt;1, V&gt;&gt;::value));
879      EXPECT_TRUE((std::is_same&lt;const volatile int,
880                                absl::variant_alternative_t&lt;1, const V&gt;&gt;::value));
881      EXPECT_TRUE(
882          (std::is_same&lt;volatile int,
883                        absl::variant_alternative_t&lt;1, volatile V&gt;&gt;::value));
884      EXPECT_TRUE((
885          std::is_same&lt;const volatile int,
886                       absl::variant_alternative_t&lt;1, const volatile V&gt;&gt;::value));
887      EXPECT_TRUE(
888          (std::is_same&lt;const char*, absl::variant_alternative_t&lt;2, V&gt;&gt;::value));
889      EXPECT_TRUE((std::is_same&lt;const char* const,
890                                absl::variant_alternative_t&lt;2, const V&gt;&gt;::value));
891      EXPECT_TRUE(
892          (std::is_same&lt;const char* volatile,
893                        absl::variant_alternative_t&lt;2, volatile V&gt;&gt;::value));
894      EXPECT_TRUE((
895          std::is_same&lt;const char* const volatile,
896                       absl::variant_alternative_t&lt;2, const volatile V&gt;&gt;::value));
897    }
898  }
899  TEST(VariantTest, HoldsAlternative) {
900    using Var = variant&lt;int, std::string, double&gt;;
901    Var v = 1;
902    EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(v));
903    EXPECT_FALSE(absl::holds_alternative&lt;std::string&gt;(v));
904    EXPECT_FALSE(absl::holds_alternative&lt;double&gt;(v));
905    v = &quot;str&quot;;
906    EXPECT_FALSE(absl::holds_alternative&lt;int&gt;(v));
907    EXPECT_TRUE(absl::holds_alternative&lt;std::string&gt;(v));
908    EXPECT_FALSE(absl::holds_alternative&lt;double&gt;(v));
909    v = 0.;
910    EXPECT_FALSE(absl::holds_alternative&lt;int&gt;(v));
911    EXPECT_FALSE(absl::holds_alternative&lt;std::string&gt;(v));
912    EXPECT_TRUE(absl::holds_alternative&lt;double&gt;(v));
913    Var v2 = v;
914    EXPECT_FALSE(absl::holds_alternative&lt;int&gt;(v2));
915    EXPECT_FALSE(absl::holds_alternative&lt;std::string&gt;(v2));
916    EXPECT_TRUE(absl::holds_alternative&lt;double&gt;(v2));
917    v2.emplace&lt;int&gt;(3);
918    EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(v2));
919    EXPECT_FALSE(absl::holds_alternative&lt;std::string&gt;(v2));
920    EXPECT_FALSE(absl::holds_alternative&lt;double&gt;(v2));
921  }
922  TEST(VariantTest, GetIndex) {
923    using Var = variant&lt;int, std::string, double, int&gt;;
924    {
925      Var v(absl::in_place_index&lt;0&gt;, 0);
926      using LValueGetType = decltype(absl::get&lt;0&gt;(v));
927      using RValueGetType = decltype(absl::get&lt;0&gt;(absl::move(v)));
928      EXPECT_TRUE((std::is_same&lt;LValueGetType, int&amp;&gt;::value));
929      EXPECT_TRUE((std::is_same&lt;RValueGetType, int&amp;&amp;&gt;::value));
930      EXPECT_EQ(absl::get&lt;0&gt;(v), 0);
931      EXPECT_EQ(absl::get&lt;0&gt;(absl::move(v)), 0);
932      const Var&amp; const_v = v;
933      using ConstLValueGetType = decltype(absl::get&lt;0&gt;(const_v));
934      using ConstRValueGetType = decltype(absl::get&lt;0&gt;(absl::move(const_v)));
935      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const int&amp;&gt;::value));
936      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const int&amp;&amp;&gt;::value));
937      EXPECT_EQ(absl::get&lt;0&gt;(const_v), 0);
938      EXPECT_EQ(absl::get&lt;0&gt;(absl::move(const_v)), 0);
939    }
940    {
941      Var v = std::string(&quot;Hello&quot;);
942      using LValueGetType = decltype(absl::get&lt;1&gt;(v));
943      using RValueGetType = decltype(absl::get&lt;1&gt;(absl::move(v)));
944      EXPECT_TRUE((std::is_same&lt;LValueGetType, std::string&amp;&gt;::value));
945      EXPECT_TRUE((std::is_same&lt;RValueGetType, std::string&amp;&amp;&gt;::value));
946      EXPECT_EQ(absl::get&lt;1&gt;(v), &quot;Hello&quot;);
947      EXPECT_EQ(absl::get&lt;1&gt;(absl::move(v)), &quot;Hello&quot;);
948      const Var&amp; const_v = v;
949      using ConstLValueGetType = decltype(absl::get&lt;1&gt;(const_v));
950      using ConstRValueGetType = decltype(absl::get&lt;1&gt;(absl::move(const_v)));
951      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const std::string&amp;&gt;::value));
952      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const std::string&amp;&amp;&gt;::value));
953      EXPECT_EQ(absl::get&lt;1&gt;(const_v), &quot;Hello&quot;);
954      EXPECT_EQ(absl::get&lt;1&gt;(absl::move(const_v)), &quot;Hello&quot;);
955    }
956    {
957      Var v = 2.0;
958      using LValueGetType = decltype(absl::get&lt;2&gt;(v));
959      using RValueGetType = decltype(absl::get&lt;2&gt;(absl::move(v)));
960      EXPECT_TRUE((std::is_same&lt;LValueGetType, double&amp;&gt;::value));
961      EXPECT_TRUE((std::is_same&lt;RValueGetType, double&amp;&amp;&gt;::value));
962      EXPECT_EQ(absl::get&lt;2&gt;(v), 2.);
963      EXPECT_EQ(absl::get&lt;2&gt;(absl::move(v)), 2.);
964      const Var&amp; const_v = v;
965      using ConstLValueGetType = decltype(absl::get&lt;2&gt;(const_v));
966      using ConstRValueGetType = decltype(absl::get&lt;2&gt;(absl::move(const_v)));
967      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const double&amp;&gt;::value));
968      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const double&amp;&amp;&gt;::value));
969      EXPECT_EQ(absl::get&lt;2&gt;(const_v), 2.);
970      EXPECT_EQ(absl::get&lt;2&gt;(absl::move(const_v)), 2.);
971    }
972    {
973      Var v(absl::in_place_index&lt;0&gt;, 0);
974      v.emplace&lt;3&gt;(1);
975      using LValueGetType = decltype(absl::get&lt;3&gt;(v));
976      using RValueGetType = decltype(absl::get&lt;3&gt;(absl::move(v)));
977      EXPECT_TRUE((std::is_same&lt;LValueGetType, int&amp;&gt;::value));
978      EXPECT_TRUE((std::is_same&lt;RValueGetType, int&amp;&amp;&gt;::value));
979      EXPECT_EQ(absl::get&lt;3&gt;(v), 1);
980      EXPECT_EQ(absl::get&lt;3&gt;(absl::move(v)), 1);
981      const Var&amp; const_v = v;
982      using ConstLValueGetType = decltype(absl::get&lt;3&gt;(const_v));
983      using ConstRValueGetType = decltype(absl::get&lt;3&gt;(absl::move(const_v)));
984      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const int&amp;&gt;::value));
985      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const int&amp;&amp;&gt;::value));
986      EXPECT_EQ(absl::get&lt;3&gt;(const_v), 1);
987      EXPECT_EQ(absl::get&lt;3&gt;(absl::move(const_v)), 1);  
988    }
989  }
990  TEST(VariantTest, BadGetIndex) {
991    using Var = variant&lt;int, std::string, double&gt;;
992    {
993      Var v = 1;
994      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;1&gt;(v));
995      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;1&gt;(std::move(v)));
996      const Var&amp; const_v = v;
997      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;1&gt;(const_v));
998      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
999          absl::get&lt;1&gt;(std::move(const_v)));  
1000    }
1001    {
1002      Var v = std::string(&quot;Hello&quot;);
1003      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;0&gt;(v));
1004      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;0&gt;(std::move(v)));
1005      const Var&amp; const_v = v;
1006      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;0&gt;(const_v));
1007      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1008          absl::get&lt;0&gt;(std::move(const_v)));  
1009    }
1010  }
1011  TEST(VariantTest, GetType) {
1012    using Var = variant&lt;int, std::string, double&gt;;
1013    {
1014      Var v = 1;
1015      using LValueGetType = decltype(absl::get&lt;int&gt;(v));
1016      using RValueGetType = decltype(absl::get&lt;int&gt;(absl::move(v)));
1017      EXPECT_TRUE((std::is_same&lt;LValueGetType, int&amp;&gt;::value));
1018      EXPECT_TRUE((std::is_same&lt;RValueGetType, int&amp;&amp;&gt;::value));
1019      EXPECT_EQ(absl::get&lt;int&gt;(v), 1);
1020      EXPECT_EQ(absl::get&lt;int&gt;(absl::move(v)), 1);
1021      const Var&amp; const_v = v;
1022      using ConstLValueGetType = decltype(absl::get&lt;int&gt;(const_v));
1023      using ConstRValueGetType = decltype(absl::get&lt;int&gt;(absl::move(const_v)));
1024      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const int&amp;&gt;::value));
1025      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const int&amp;&amp;&gt;::value));
1026      EXPECT_EQ(absl::get&lt;int&gt;(const_v), 1);
1027      EXPECT_EQ(absl::get&lt;int&gt;(absl::move(const_v)), 1);
1028    }
1029    {
1030      Var v = std::string(&quot;Hello&quot;);
1031      using LValueGetType = decltype(absl::get&lt;1&gt;(v));
1032      using RValueGetType = decltype(absl::get&lt;1&gt;(absl::move(v)));
1033      EXPECT_TRUE((std::is_same&lt;LValueGetType, std::string&amp;&gt;::value));
1034      EXPECT_TRUE((std::is_same&lt;RValueGetType, std::string&amp;&amp;&gt;::value));
1035      EXPECT_EQ(absl::get&lt;std::string&gt;(v), &quot;Hello&quot;);
1036      EXPECT_EQ(absl::get&lt;std::string&gt;(absl::move(v)), &quot;Hello&quot;);
1037      const Var&amp; const_v = v;
1038      using ConstLValueGetType = decltype(absl::get&lt;1&gt;(const_v));
1039      using ConstRValueGetType = decltype(absl::get&lt;1&gt;(absl::move(const_v)));
1040      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const std::string&amp;&gt;::value));
1041      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const std::string&amp;&amp;&gt;::value));
1042      EXPECT_EQ(absl::get&lt;std::string&gt;(const_v), &quot;Hello&quot;);
1043      EXPECT_EQ(absl::get&lt;std::string&gt;(absl::move(const_v)), &quot;Hello&quot;);
1044    }
1045    {
1046      Var v = 2.0;
1047      using LValueGetType = decltype(absl::get&lt;2&gt;(v));
1048      using RValueGetType = decltype(absl::get&lt;2&gt;(absl::move(v)));
1049      EXPECT_TRUE((std::is_same&lt;LValueGetType, double&amp;&gt;::value));
1050      EXPECT_TRUE((std::is_same&lt;RValueGetType, double&amp;&amp;&gt;::value));
1051      EXPECT_EQ(absl::get&lt;double&gt;(v), 2.);
1052      EXPECT_EQ(absl::get&lt;double&gt;(absl::move(v)), 2.);
1053      const Var&amp; const_v = v;
1054      using ConstLValueGetType = decltype(absl::get&lt;2&gt;(const_v));
1055      using ConstRValueGetType = decltype(absl::get&lt;2&gt;(absl::move(const_v)));
1056      EXPECT_TRUE((std::is_same&lt;ConstLValueGetType, const double&amp;&gt;::value));
1057      EXPECT_TRUE((std::is_same&lt;ConstRValueGetType, const double&amp;&amp;&gt;::value));
1058      EXPECT_EQ(absl::get&lt;double&gt;(const_v), 2.);
1059      EXPECT_EQ(absl::get&lt;double&gt;(absl::move(const_v)), 2.);
1060    }
1061  }
1062  TEST(VariantTest, BadGetType) {
1063    using Var = variant&lt;int, std::string, double&gt;;
1064    {
1065      Var v = 1;
1066      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;std::string&gt;(v));
1067      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1068          absl::get&lt;std::string&gt;(std::move(v)));
1069      const Var&amp; const_v = v;
1070      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1071          absl::get&lt;std::string&gt;(const_v));
1072      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1073          absl::get&lt;std::string&gt;(std::move(const_v)));  
1074    }
1075    {
1076      Var v = std::string(&quot;Hello&quot;);
1077      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;int&gt;(v));
1078      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;int&gt;(std::move(v)));
1079      const Var&amp; const_v = v;
1080      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get&lt;int&gt;(const_v));
1081      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1082          absl::get&lt;int&gt;(std::move(const_v)));  
1083    }
1084  }
1085  TEST(VariantTest, GetIfIndex) {
1086    using Var = variant&lt;int, std::string, double, int&gt;;
1087    {
1088      Var v(absl::in_place_index&lt;0&gt;, 0);
1089      EXPECT_TRUE(noexcept(absl::get_if&lt;0&gt;(&amp;v)));
1090      {
1091        auto* elem = absl::get_if&lt;0&gt;(&amp;v);
1092        EXPECT_TRUE((std::is_same&lt;decltype(elem), int*&gt;::value));
1093        ASSERT_NE(elem, nullptr);
1094        EXPECT_EQ(*elem, 0);
1095        {
1096          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;v);
1097          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), std::string*&gt;::value));
1098          EXPECT_EQ(bad_elem, nullptr);
1099        }
1100        {
1101          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;v);
1102          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), double*&gt;::value));
1103          EXPECT_EQ(bad_elem, nullptr);
1104        }
1105        {
1106          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;v);
1107          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1108          EXPECT_EQ(bad_elem, nullptr);
1109        }
1110      }
1111      const Var&amp; const_v = v;
1112      EXPECT_TRUE(noexcept(absl::get_if&lt;0&gt;(&amp;const_v)));
1113      {
1114        auto* elem = absl::get_if&lt;0&gt;(&amp;const_v);
1115        EXPECT_TRUE((std::is_same&lt;decltype(elem), const int*&gt;::value));
1116        ASSERT_NE(elem, nullptr);
1117        EXPECT_EQ(*elem, 0);
1118        {
1119          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;const_v);
1120          EXPECT_TRUE(
1121              (std::is_same&lt;decltype(bad_elem), const std::string*&gt;::value));
1122          EXPECT_EQ(bad_elem, nullptr);
1123        }
1124        {
1125          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;const_v);
1126          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const double*&gt;::value));
1127          EXPECT_EQ(bad_elem, nullptr);
1128        }
1129        {
1130          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;const_v);
1131          EXPECT_EQ(bad_elem, nullptr);
1132          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1133        }
1134      }
1135    }
1136    {
1137      Var v = std::string(&quot;Hello&quot;);
1138      EXPECT_TRUE(noexcept(absl::get_if&lt;1&gt;(&amp;v)));
1139      {
1140        auto* elem = absl::get_if&lt;1&gt;(&amp;v);
1141        EXPECT_TRUE((std::is_same&lt;decltype(elem), std::string*&gt;::value));
1142        ASSERT_NE(elem, nullptr);
1143        EXPECT_EQ(*elem, &quot;Hello&quot;);
1144        {
1145          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;v);
1146          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1147          EXPECT_EQ(bad_elem, nullptr);
1148        }
1149        {
1150          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;v);
1151          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), double*&gt;::value));
1152          EXPECT_EQ(bad_elem, nullptr);
1153        }
1154        {
1155          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;v);
1156          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1157          EXPECT_EQ(bad_elem, nullptr);
1158        }
1159      }
1160      const Var&amp; const_v = v;
1161      EXPECT_TRUE(noexcept(absl::get_if&lt;1&gt;(&amp;const_v)));
1162      {
1163        auto* elem = absl::get_if&lt;1&gt;(&amp;const_v);
1164        EXPECT_TRUE((std::is_same&lt;decltype(elem), const std::string*&gt;::value));
1165        ASSERT_NE(elem, nullptr);
1166        EXPECT_EQ(*elem, &quot;Hello&quot;);
1167        {
1168          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;const_v);
1169          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1170          EXPECT_EQ(bad_elem, nullptr);
1171        }
1172        {
1173          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;const_v);
1174          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const double*&gt;::value));
1175          EXPECT_EQ(bad_elem, nullptr);
1176        }
1177        {
1178          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;const_v);
1179          EXPECT_EQ(bad_elem, nullptr);
1180          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1181        }
1182      }
1183    }
1184    {
1185      Var v = 2.0;
1186      EXPECT_TRUE(noexcept(absl::get_if&lt;2&gt;(&amp;v)));
1187      {
1188        auto* elem = absl::get_if&lt;2&gt;(&amp;v);
1189        EXPECT_TRUE((std::is_same&lt;decltype(elem), double*&gt;::value));
1190        ASSERT_NE(elem, nullptr);
1191        EXPECT_EQ(*elem, 2.0);
1192        {
1193          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;v);
1194          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1195          EXPECT_EQ(bad_elem, nullptr);
1196        }
1197        {
1198          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;v);
1199          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), std::string*&gt;::value));
1200          EXPECT_EQ(bad_elem, nullptr);
1201        }
1202        {
1203          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;v);
1204          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1205          EXPECT_EQ(bad_elem, nullptr);
1206        }
1207      }
1208      const Var&amp; const_v = v;
1209      EXPECT_TRUE(noexcept(absl::get_if&lt;2&gt;(&amp;const_v)));
1210      {
1211        auto* elem = absl::get_if&lt;2&gt;(&amp;const_v);
1212        EXPECT_TRUE((std::is_same&lt;decltype(elem), const double*&gt;::value));
1213        ASSERT_NE(elem, nullptr);
1214        EXPECT_EQ(*elem, 2.0);
1215        {
1216          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;const_v);
1217          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1218          EXPECT_EQ(bad_elem, nullptr);
1219        }
1220        {
1221          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;const_v);
1222          EXPECT_TRUE(
1223              (std::is_same&lt;decltype(bad_elem), const std::string*&gt;::value));
1224          EXPECT_EQ(bad_elem, nullptr);
1225        }
1226        {
1227          auto* bad_elem = absl::get_if&lt;3&gt;(&amp;const_v);
1228          EXPECT_EQ(bad_elem, nullptr);
1229          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1230        }
1231      }
1232    }
1233    {
1234      Var v(absl::in_place_index&lt;0&gt;, 0);
1235      v.emplace&lt;3&gt;(1);
1236      EXPECT_TRUE(noexcept(absl::get_if&lt;3&gt;(&amp;v)));
1237      {
1238        auto* elem = absl::get_if&lt;3&gt;(&amp;v);
1239        EXPECT_TRUE((std::is_same&lt;decltype(elem), int*&gt;::value));
1240        ASSERT_NE(elem, nullptr);
1241        EXPECT_EQ(*elem, 1);
1242        {
1243          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;v);
1244          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), int*&gt;::value));
1245          EXPECT_EQ(bad_elem, nullptr);
1246        }
1247        {
1248          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;v);
1249          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), std::string*&gt;::value));
1250          EXPECT_EQ(bad_elem, nullptr);
1251        }
1252        {
1253          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;v);
1254          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), double*&gt;::value));
1255          EXPECT_EQ(bad_elem, nullptr);
1256        }
1257      }
1258      const Var&amp; const_v = v;
1259      EXPECT_TRUE(noexcept(absl::get_if&lt;3&gt;(&amp;const_v)));
1260      {
1261        auto* elem = absl::get_if&lt;3&gt;(&amp;const_v);
1262        EXPECT_TRUE((std::is_same&lt;decltype(elem), const int*&gt;::value));
1263        ASSERT_NE(elem, nullptr);
1264        EXPECT_EQ(*elem, 1);
1265        {
1266          auto* bad_elem = absl::get_if&lt;0&gt;(&amp;const_v);
1267          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const int*&gt;::value));
1268          EXPECT_EQ(bad_elem, nullptr);
1269        }
1270        {
1271          auto* bad_elem = absl::get_if&lt;1&gt;(&amp;const_v);
1272          EXPECT_TRUE(
1273              (std::is_same&lt;decltype(bad_elem), const std::string*&gt;::value));
1274          EXPECT_EQ(bad_elem, nullptr);
1275        }
1276        {
1277          auto* bad_elem = absl::get_if&lt;2&gt;(&amp;const_v);
1278          EXPECT_EQ(bad_elem, nullptr);
1279          EXPECT_TRUE((std::is_same&lt;decltype(bad_elem), const double*&gt;::value));
1280        }
1281      }
1282    }
1283  }
1284  TEST(VariantTest, OperatorEquals) {
1285    variant&lt;int, std::string&gt; a(1), b(1);
1286    EXPECT_TRUE(a == b);
1287    EXPECT_TRUE(b == a);
1288    EXPECT_FALSE(a != b);
1289    EXPECT_FALSE(b != a);
1290    b = &quot;str&quot;;
1291    EXPECT_FALSE(a == b);
1292    EXPECT_FALSE(b == a);
1293    EXPECT_TRUE(a != b);
1294    EXPECT_TRUE(b != a);
1295    b = 0;
1296    EXPECT_FALSE(a == b);
1297    EXPECT_FALSE(b == a);
1298    EXPECT_TRUE(a != b);
1299    EXPECT_TRUE(b != a);
1300    a = b = &quot;foo&quot;;
1301    EXPECT_TRUE(a == b);
1302    EXPECT_TRUE(b == a);
1303    EXPECT_FALSE(a != b);
1304    EXPECT_FALSE(b != a);
1305    a = &quot;bar&quot;;
1306    EXPECT_FALSE(a == b);
1307    EXPECT_FALSE(b == a);
1308    EXPECT_TRUE(a != b);
1309    EXPECT_TRUE(b != a);
1310  }
1311  TEST(VariantTest, OperatorRelational) {
1312    variant&lt;int, std::string&gt; a(1), b(1);
1313    EXPECT_FALSE(a &lt; b);
1314    EXPECT_FALSE(b &lt; a);
1315    EXPECT_FALSE(a &gt; b);
1316    EXPECT_FALSE(b &gt; a);
1317    EXPECT_TRUE(a &lt;= b);
1318    EXPECT_TRUE(b &lt;= a);
1319    EXPECT_TRUE(a &gt;= b);
1320    EXPECT_TRUE(b &gt;= a);
1321    b = &quot;str&quot;;
1322    EXPECT_TRUE(a &lt; b);
1323    EXPECT_FALSE(b &lt; a);
1324    EXPECT_FALSE(a &gt; b);
1325    EXPECT_TRUE(b &gt; a);
1326    EXPECT_TRUE(a &lt;= b);
1327    EXPECT_FALSE(b &lt;= a);
1328    EXPECT_FALSE(a &gt;= b);
1329    EXPECT_TRUE(b &gt;= a);
1330    b = 0;
1331    EXPECT_FALSE(a &lt; b);
1332    EXPECT_TRUE(b &lt; a);
1333    EXPECT_TRUE(a &gt; b);
1334    EXPECT_FALSE(b &gt; a);
1335    EXPECT_FALSE(a &lt;= b);
1336    EXPECT_TRUE(b &lt;= a);
1337    EXPECT_TRUE(a &gt;= b);
1338    EXPECT_FALSE(b &gt;= a);
1339    a = b = &quot;foo&quot;;
1340    EXPECT_FALSE(a &lt; b);
1341    EXPECT_FALSE(b &lt; a);
1342    EXPECT_FALSE(a &gt; b);
1343    EXPECT_FALSE(b &gt; a);
1344    EXPECT_TRUE(a &lt;= b);
1345    EXPECT_TRUE(b &lt;= a);
1346    EXPECT_TRUE(a &gt;= b);
1347    EXPECT_TRUE(b &gt;= a);
1348    a = &quot;bar&quot;;
1349    EXPECT_TRUE(a &lt; b);
1350    EXPECT_FALSE(b &lt; a);
1351    EXPECT_FALSE(a &gt; b);
1352    EXPECT_TRUE(b &gt; a);
1353    EXPECT_TRUE(a &lt;= b);
1354    EXPECT_FALSE(b &lt;= a);
1355    EXPECT_FALSE(a &gt;= b);
1356    EXPECT_TRUE(b &gt;= a);
1357  }
1358  #ifdef ABSL_HAVE_EXCEPTIONS
1359  TEST(VariantTest, ValuelessOperatorEquals) {
1360    variant&lt;MoveCanThrow, std::string&gt; int_v(1), string_v(&quot;Hello&quot;),
1361        valueless(absl::in_place_index&lt;0&gt;),
1362        other_valueless(absl::in_place_index&lt;0&gt;);
1363    ToValuelessByException(valueless);
1364    ToValuelessByException(other_valueless);
1365    EXPECT_TRUE(valueless == other_valueless);
1366    EXPECT_TRUE(other_valueless == valueless);
1367    EXPECT_FALSE(valueless == int_v);
1368    EXPECT_FALSE(valueless == string_v);
1369    EXPECT_FALSE(int_v == valueless);
1370    EXPECT_FALSE(string_v == valueless);
1371    EXPECT_FALSE(valueless != other_valueless);
1372    EXPECT_FALSE(other_valueless != valueless);
1373    EXPECT_TRUE(valueless != int_v);
1374    EXPECT_TRUE(valueless != string_v);
1375    EXPECT_TRUE(int_v != valueless);
1376    EXPECT_TRUE(string_v != valueless);
1377  }
1378  TEST(VariantTest, ValuelessOperatorRelational) {
1379    variant&lt;MoveCanThrow, std::string&gt; int_v(1), string_v(&quot;Hello&quot;),
1380        valueless(absl::in_place_index&lt;0&gt;),
1381        other_valueless(absl::in_place_index&lt;0&gt;);
1382    ToValuelessByException(valueless);
1383    ToValuelessByException(other_valueless);
1384    EXPECT_FALSE(valueless &lt; other_valueless);
1385    EXPECT_FALSE(other_valueless &lt; valueless);
1386    EXPECT_TRUE(valueless &lt; int_v);
1387    EXPECT_TRUE(valueless &lt; string_v);
1388    EXPECT_FALSE(int_v &lt; valueless);
1389    EXPECT_FALSE(string_v &lt; valueless);
1390    EXPECT_TRUE(valueless &lt;= other_valueless);
1391    EXPECT_TRUE(other_valueless &lt;= valueless);
1392    EXPECT_TRUE(valueless &lt;= int_v);
1393    EXPECT_TRUE(valueless &lt;= string_v);
1394    EXPECT_FALSE(int_v &lt;= valueless);
1395    EXPECT_FALSE(string_v &lt;= valueless);
1396    EXPECT_TRUE(valueless &gt;= other_valueless);
1397    EXPECT_TRUE(other_valueless &gt;= valueless);
1398    EXPECT_FALSE(valueless &gt;= int_v);
1399    EXPECT_FALSE(valueless &gt;= string_v);
1400    EXPECT_TRUE(int_v &gt;= valueless);
1401    EXPECT_TRUE(string_v &gt;= valueless);
1402    EXPECT_FALSE(valueless &gt; other_valueless);
1403    EXPECT_FALSE(other_valueless &gt; valueless);
1404    EXPECT_FALSE(valueless &gt; int_v);
1405    EXPECT_FALSE(valueless &gt; string_v);
1406    EXPECT_TRUE(int_v &gt; valueless);
1407    EXPECT_TRUE(string_v &gt; valueless);
1408  }
1409  #endif
1410  template &lt;typename T&gt;
1411  struct ConvertTo {
1412    template &lt;typename U&gt;
1413    T operator()(const U&amp; u) const {
1414      return u;
1415    }
1416  };
1417  TEST(VariantTest, VisitSimple) {
1418    variant&lt;std::string, const char*&gt; v = &quot;A&quot;;
1419    std::string str = absl::visit(ConvertTo&lt;std::string&gt;{}, v);
1420    EXPECT_EQ(&quot;A&quot;, str);
1421    v = std::string(&quot;B&quot;);
1422    absl::string_view piece = absl::visit(ConvertTo&lt;absl::string_view&gt;{}, v);
1423    EXPECT_EQ(&quot;B&quot;, piece);
1424    struct StrLen {
1425      size_t operator()(const char* s) const { return strlen(s); }
1426      size_t operator()(const std::string&amp; s) const { return s.size(); }
1427    };
1428    v = &quot;SomeStr&quot;;
1429    EXPECT_EQ(7u, absl::visit(StrLen{}, v));
1430    v = std::string(&quot;VeryLargeThisTime&quot;);
1431    EXPECT_EQ(17u, absl::visit(StrLen{}, v));
1432  }
1433  TEST(VariantTest, VisitRValue) {
1434    variant&lt;std::string&gt; v = std::string(&quot;X&quot;);
1435    struct Visitor {
1436      bool operator()(const std::string&amp;) const { return false; }
1437      bool operator()(std::string&amp;&amp;) const { return true; }  
1438      int operator()(const std::string&amp;, const std::string&amp;) const { return 0; }
1439      int operator()(const std::string&amp;, std::string&amp;&amp;) const {
1440        return 1;
1441      }  
1442      int operator()(std::string&amp;&amp;, const std::string&amp;) const {
1443        return 2;
1444      }                                                                 
1445      int operator()(std::string&amp;&amp;, std::string&amp;&amp;) const { return 3; }  
1446    };
1447    EXPECT_FALSE(absl::visit(Visitor{}, v));
1448    EXPECT_TRUE(absl::visit(Visitor{}, absl::move(v)));
1449    EXPECT_EQ(0, absl::visit(Visitor{}, v, v));
1450    EXPECT_EQ(1, absl::visit(Visitor{}, v, absl::move(v)));
1451    EXPECT_EQ(2, absl::visit(Visitor{}, absl::move(v), v));
1452    EXPECT_EQ(3, absl::visit(Visitor{}, absl::move(v), absl::move(v)));
1453  }
1454  TEST(VariantTest, VisitRValueVisitor) {
1455    variant&lt;std::string&gt; v = std::string(&quot;X&quot;);
1456    struct Visitor {
1457      bool operator()(const std::string&amp;) const&amp; { return false; }
1458      bool operator()(const std::string&amp;) &amp;&amp; { return true; }
1459    };
1460    Visitor visitor;
1461    EXPECT_FALSE(absl::visit(visitor, v));
1462    EXPECT_TRUE(absl::visit(Visitor{}, v));
1463  }
1464  TEST(VariantTest, VisitResultTypeDifferent) {
1465    variant&lt;std::string&gt; v = std::string(&quot;X&quot;);
1466    struct LValue_LValue {};
1467    struct RValue_LValue {};
1468    struct LValue_RValue {};
1469    struct RValue_RValue {};
1470    struct Visitor {
1471      LValue_LValue operator()(const std::string&amp;) const&amp; { return {}; }
1472      RValue_LValue operator()(std::string&amp;&amp;) const&amp; { return {}; }  
1473      LValue_RValue operator()(const std::string&amp;) &amp;&amp; { return {}; }
1474      RValue_RValue operator()(std::string&amp;&amp;) &amp;&amp; { return {}; }  
1475    } visitor;
1476    EXPECT_TRUE(
1477        (std::is_same&lt;LValue_LValue, decltype(absl::visit(visitor, v))&gt;::value));
1478    EXPECT_TRUE(
1479        (std::is_same&lt;RValue_LValue,
1480                      decltype(absl::visit(visitor, absl::move(v)))&gt;::value));
1481    EXPECT_TRUE((
1482        std::is_same&lt;LValue_RValue, decltype(absl::visit(Visitor{}, v))&gt;::value));
1483    EXPECT_TRUE(
1484        (std::is_same&lt;RValue_RValue,
1485                      decltype(absl::visit(Visitor{}, absl::move(v)))&gt;::value));
1486  }
1487  TEST(VariantTest, VisitVariadic) {
1488    using A = variant&lt;int, std::string&gt;;
1489    using B = variant&lt;std::unique_ptr&lt;int&gt;, absl::string_view&gt;;
1490    struct Visitor {
1491      std::pair&lt;int, int&gt; operator()(int a, std::unique_ptr&lt;int&gt; b) const {
1492        return {a, *b};
1493      }
1494      std::pair&lt;int, int&gt; operator()(absl::string_view a,
1495                                     std::unique_ptr&lt;int&gt; b) const {
1496        return {static_cast&lt;int&gt;(a.size()), static_cast&lt;int&gt;(*b)};
1497      }
1498      std::pair&lt;int, int&gt; operator()(int a, absl::string_view b) const {
1499        return {a, static_cast&lt;int&gt;(b.size())};
1500      }
1501      std::pair&lt;int, int&gt; operator()(absl::string_view a,
1502                                     absl::string_view b) const {
1503        return {static_cast&lt;int&gt;(a.size()), static_cast&lt;int&gt;(b.size())};
1504      }
1505    };
1506    EXPECT_THAT(absl::visit(Visitor(), A(1), B(std::unique_ptr&lt;int&gt;(new int(7)))),
1507                ::testing::Pair(1, 7));
1508    EXPECT_THAT(absl::visit(Visitor(), A(1), B(absl::string_view(&quot;ABC&quot;))),
1509                ::testing::Pair(1, 3));
1510    EXPECT_THAT(absl::visit(Visitor(), A(std::string(&quot;BBBBB&quot;)),
1511                            B(std::unique_ptr&lt;int&gt;(new int(7)))),
1512                ::testing::Pair(5, 7));
1513    EXPECT_THAT(absl::visit(Visitor(), A(std::string(&quot;BBBBB&quot;)),
1514                            B(absl::string_view(&quot;ABC&quot;))),
1515                ::testing::Pair(5, 3));
1516  }
1517  TEST(VariantTest, VisitNoArgs) {
1518    EXPECT_EQ(5, absl::visit([] { return 5; }));
1519  }
1520  struct ConstFunctor {
1521    int operator()(int a, int b) const { return a - b; }
1522  };
1523  struct MutableFunctor {
1524    int operator()(int a, int b) { return a - b; }
1525  };
1526  struct Class {
1527    int Method(int a, int b) { return a - b; }
1528    int ConstMethod(int a, int b) const { return a - b; }
1529    int member;
1530  };
1531  TEST(VariantTest, VisitReferenceWrapper) {
1532    ConstFunctor cf;
1533    MutableFunctor mf;
1534    absl::variant&lt;int&gt; three = 3;
1535    absl::variant&lt;int&gt; two = 2;
1536    EXPECT_EQ(1, absl::visit(std::cref(cf), three, two));
1537    EXPECT_EQ(1, absl::visit(std::ref(cf), three, two));
1538    EXPECT_EQ(1, absl::visit(std::ref(mf), three, two));
1539  }
1540  #if !(defined(ABSL_USES_STD_VARIANT) &amp;&amp; defined(__GLIBCXX__))
1541  TEST(VariantTest, VisitMemberFunction) {
1542    absl::variant&lt;std::unique_ptr&lt;Class&gt;&gt; p(absl::make_unique&lt;Class&gt;());
1543    absl::variant&lt;std::unique_ptr&lt;const Class&gt;&gt; cp(
1544        absl::make_unique&lt;const Class&gt;());
1545    absl::variant&lt;int&gt; three = 3;
1546    absl::variant&lt;int&gt; two = 2;
1547    EXPECT_EQ(1, absl::visit(&amp;Class::Method, p, three, two));
1548    EXPECT_EQ(1, absl::visit(&amp;Class::ConstMethod, p, three, two));
1549    EXPECT_EQ(1, absl::visit(&amp;Class::ConstMethod, cp, three, two));
1550  }
1551  TEST(VariantTest, VisitDataMember) {
1552    absl::variant&lt;std::unique_ptr&lt;Class&gt;&gt; p(absl::make_unique&lt;Class&gt;(Class{42}));
1553    absl::variant&lt;std::unique_ptr&lt;const Class&gt;&gt; cp(
1554        absl::make_unique&lt;const Class&gt;(Class{42}));
1555    EXPECT_EQ(42, absl::visit(&amp;Class::member, p));
1556    absl::visit(&amp;Class::member, p) = 5;
1557    EXPECT_EQ(5, absl::visit(&amp;Class::member, p));
1558    EXPECT_EQ(42, absl::visit(&amp;Class::member, cp));
1559  }
1560  #endif  
1561  TEST(VariantTest, MonostateBasic) {
1562    absl::monostate mono;
1563    (void)mono;
1564    EXPECT_TRUE(absl::is_trivially_default_constructible&lt;absl::monostate&gt;::value);
1565    EXPECT_TRUE(is_trivially_move_constructible&lt;absl::monostate&gt;::value);
1566    EXPECT_TRUE(absl::is_trivially_copy_constructible&lt;absl::monostate&gt;::value);
1567    EXPECT_TRUE(is_trivially_move_assignable&lt;absl::monostate&gt;::value);
1568    EXPECT_TRUE(absl::is_trivially_copy_assignable&lt;absl::monostate&gt;::value);
1569    EXPECT_TRUE(absl::is_trivially_destructible&lt;absl::monostate&gt;::value);
1570  }
1571  TEST(VariantTest, VariantMonostateDefaultConstruction) {
1572    absl::variant&lt;absl::monostate, NonDefaultConstructible&gt; var;
1573    EXPECT_EQ(var.index(), 0u);
1574  }
1575  TEST(VariantTest, MonostateComparisons) {
1576    absl::monostate lhs, rhs;
1577    EXPECT_EQ(lhs, lhs);
1578    EXPECT_EQ(lhs, rhs);
1579    EXPECT_FALSE(lhs != lhs);
1580    EXPECT_FALSE(lhs != rhs);
1581    EXPECT_FALSE(lhs &lt; lhs);
1582    EXPECT_FALSE(lhs &lt; rhs);
1583    EXPECT_FALSE(lhs &gt; lhs);
1584    EXPECT_FALSE(lhs &gt; rhs);
1585    EXPECT_LE(lhs, lhs);
1586    EXPECT_LE(lhs, rhs);
1587    EXPECT_GE(lhs, lhs);
1588    EXPECT_GE(lhs, rhs);
1589    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() ==
1590                         std::declval&lt;absl::monostate&gt;()));
1591    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() !=
1592                         std::declval&lt;absl::monostate&gt;()));
1593    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() &lt;
1594                         std::declval&lt;absl::monostate&gt;()));
1595    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() &gt;
1596                         std::declval&lt;absl::monostate&gt;()));
1597    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() &lt;=
1598                         std::declval&lt;absl::monostate&gt;()));
1599    EXPECT_TRUE(noexcept(std::declval&lt;absl::monostate&gt;() &gt;=
1600                         std::declval&lt;absl::monostate&gt;()));
1601  }
1602  TEST(VariantTest, NonmemberSwap) {
1603    using std::swap;
1604    SpecialSwap v1(3);
1605    SpecialSwap v2(7);
1606    variant&lt;SpecialSwap&gt; a = v1, b = v2;
1607    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v1));
1608    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v2));
1609    std::swap(a, b);
1610    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v2));
1611    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v1));
1612  #ifndef ABSL_USES_STD_VARIANT
1613    EXPECT_FALSE(absl::get&lt;SpecialSwap&gt;(a).special_swap);
1614  #endif
1615    swap(a, b);
1616    EXPECT_THAT(a, VariantWith&lt;SpecialSwap&gt;(v1));
1617    EXPECT_THAT(b, VariantWith&lt;SpecialSwap&gt;(v2));
1618    EXPECT_TRUE(absl::get&lt;SpecialSwap&gt;(b).special_swap);
1619  }
1620  TEST(VariantTest, BadAccess) {
1621    EXPECT_TRUE(noexcept(absl::bad_variant_access()));
1622    absl::bad_variant_access exception_obj;
1623    std::exception* base = &amp;exception_obj;
1624    (void)base;
1625  }
1626  TEST(VariantTest, MonostateHash) {
1627    absl::monostate mono, other_mono;
1628    std::hash&lt;absl::monostate&gt; const hasher{};
1629    static_assert(std::is_same&lt;decltype(hasher(mono)), std::size_t&gt;::value, &quot;&quot;);
1630    EXPECT_EQ(hasher(mono), hasher(other_mono));
1631  }
1632  TEST(VariantTest, Hash) {
1633    static_assert(type_traits_internal::IsHashable&lt;variant&lt;int&gt;&gt;::value, &quot;&quot;);
1634    static_assert(type_traits_internal::IsHashable&lt;variant&lt;Hashable&gt;&gt;::value, &quot;&quot;);
1635    static_assert(type_traits_internal::IsHashable&lt;variant&lt;int, Hashable&gt;&gt;::value,
1636                  &quot;&quot;);
1637  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
1638    static_assert(!type_traits_internal::IsHashable&lt;variant&lt;NonHashable&gt;&gt;::value,
1639                  &quot;&quot;);
1640    static_assert(
1641        !type_traits_internal::IsHashable&lt;variant&lt;Hashable, NonHashable&gt;&gt;::value,
1642        &quot;&quot;);
1643  #endif
1644  #if !(defined(_MSC_VER) &amp;&amp; defined(ABSL_USES_STD_VARIANT))
1645    {
1646      variant&lt;int, int&gt; v0(in_place_index&lt;0&gt;, 42);
1647      variant&lt;int, int&gt; v1(in_place_index&lt;1&gt;, 42);
1648      std::hash&lt;variant&lt;int, int&gt;&gt; hash;
1649      EXPECT_NE(hash(v0), hash(v1));
1650    }
1651  #endif  
1652    {
1653      std::hash&lt;variant&lt;int&gt;&gt; hash;
1654      std::set&lt;size_t&gt; hashcodes;
1655      for (int i = 0; i &lt; 100; ++i) {
1656        hashcodes.insert(hash(i));
1657      }
1658      EXPECT_GT(hashcodes.size(), 90u);
1659      static_assert(type_traits_internal::IsHashable&lt;variant&lt;const int&gt;&gt;::value,
1660                    &quot;&quot;);
1661      static_assert(
1662          type_traits_internal::IsHashable&lt;variant&lt;const Hashable&gt;&gt;::value, &quot;&quot;);
1663      std::hash&lt;absl::variant&lt;const int&gt;&gt; c_hash;
1664      for (int i = 0; i &lt; 100; ++i) {
1665        EXPECT_EQ(hash(i), c_hash(i));
1666      }
1667    }
1668  }
1669  #if !defined(ABSL_USES_STD_VARIANT)
1670  TEST(VariantTest, TestConvertingSet) {
1671    typedef variant&lt;double&gt; Variant;
1672    Variant v(1.0);
1673    const int two = 2;
1674    v = two;
1675    EXPECT_TRUE(absl::holds_alternative&lt;double&gt;(v));
1676    ASSERT_TRUE(nullptr != absl::get_if&lt;double&gt;(&amp;v));
1677    EXPECT_DOUBLE_EQ(2, absl::get&lt;double&gt;(v));
1678  }
1679  #endif  
1680  TEST(VariantTest, Container) {
1681    typedef variant&lt;int, float&gt; Variant;
1682    std::vector&lt;Variant&gt; vec;
1683    vec.push_back(Variant(10));
1684    vec.push_back(Variant(20.0f));
1685    vec.resize(10, Variant(0));
1686  }
1687  TEST(VariantTest, TestVariantWithNonCopyableType) {
1688    typedef variant&lt;int, NonCopyable&gt; Variant;
1689    const int kValue = 1;
1690    Variant v(kValue);
1691    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1692    EXPECT_EQ(kValue, absl::get&lt;int&gt;(v));
1693  }
1694  TEST(VariantTest, TestEmplace) {
1695    typedef variant&lt;int, NonCopyable&gt; Variant;
1696    const int kValue = 1;
1697    Variant v(kValue);
1698    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1699    EXPECT_EQ(kValue, absl::get&lt;int&gt;(v));
1700    v.emplace&lt;NonCopyable&gt;();
1701    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1702    EXPECT_EQ(0, absl::get&lt;NonCopyable&gt;(v).value);
1703    v = kValue;
1704    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1705    v.emplace&lt;NonCopyable&gt;(1);
1706    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1707    EXPECT_EQ(1, absl::get&lt;NonCopyable&gt;(v).value);
1708    v = kValue;
1709    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1710    v.emplace&lt;NonCopyable&gt;(1, 2);
1711    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1712    EXPECT_EQ(3, absl::get&lt;NonCopyable&gt;(v).value);
1713    v = kValue;
1714    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1715    v.emplace&lt;NonCopyable&gt;(1, 2, 3);
1716    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1717    EXPECT_EQ(6, absl::get&lt;NonCopyable&gt;(v).value);
1718    v = kValue;
1719    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1720    v.emplace&lt;NonCopyable&gt;(1, 2, 3, 4);
1721    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1722    EXPECT_EQ(10, absl::get&lt;NonCopyable&gt;(v).value);
1723    v = kValue;
1724    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1725  }
1726  TEST(VariantTest, TestEmplaceDestroysCurrentValue) {
1727    typedef variant&lt;int, IncrementInDtor, NonCopyable&gt; Variant;
1728    int counter = 0;
1729    Variant v(0);
1730    ASSERT_TRUE(absl::holds_alternative&lt;int&gt;(v));
1731    v.emplace&lt;IncrementInDtor&gt;(&amp;counter);
1732    ASSERT_TRUE(absl::holds_alternative&lt;IncrementInDtor&gt;(v));
1733    ASSERT_EQ(0, counter);
1734    v.emplace&lt;NonCopyable&gt;();
1735    ASSERT_TRUE(absl::holds_alternative&lt;NonCopyable&gt;(v));
1736    EXPECT_EQ(1, counter);
1737  }
1738  TEST(VariantTest, TestMoveSemantics) {
1739    typedef variant&lt;std::unique_ptr&lt;int&gt;, std::unique_ptr&lt;std::string&gt;&gt; Variant;
1740    Variant v(absl::WrapUnique(new int(10)));
1741    EXPECT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;int&gt;&gt;(v));
1742    Variant v2(absl::move(v));
1743    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;int&gt;&gt;(v2));
1744    ASSERT_NE(nullptr, absl::get&lt;std::unique_ptr&lt;int&gt;&gt;(v2));
1745    EXPECT_EQ(10, *absl::get&lt;std::unique_ptr&lt;int&gt;&gt;(v2));
1746    EXPECT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;int&gt;&gt;(v));
1747    ASSERT_NE(nullptr, absl::get_if&lt;std::unique_ptr&lt;int&gt;&gt;(&amp;v));
1748    EXPECT_EQ(nullptr, absl::get&lt;std::unique_ptr&lt;int&gt;&gt;(v));
1749    v = absl::make_unique&lt;std::string&gt;(&quot;foo&quot;);
1750    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;std::string&gt;&gt;(v));
1751    EXPECT_EQ(&quot;foo&quot;, *absl::get&lt;std::unique_ptr&lt;std::string&gt;&gt;(v));
1752    v2 = absl::move(v);
1753    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;std::string&gt;&gt;(v2));
1754    EXPECT_EQ(&quot;foo&quot;, *absl::get&lt;std::unique_ptr&lt;std::string&gt;&gt;(v2));
1755    EXPECT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;std::string&gt;&gt;(v));
1756  }
1757  variant&lt;int, std::string&gt; PassThrough(const variant&lt;int, std::string&gt;&amp; arg) {
1758    return arg;
1759  }
1760  TEST(VariantTest, TestImplicitConversion) {
1761    EXPECT_TRUE(absl::holds_alternative&lt;int&gt;(PassThrough(0)));
1762    EXPECT_TRUE(
1763        absl::holds_alternative&lt;std::string&gt;(PassThrough(std::string(&quot;foo&quot;))));
1764  }
1765  struct Convertible2;
1766  struct Convertible1 {
1767    Convertible1() {}
1768    Convertible1(const Convertible1&amp;) {}
1769    Convertible1&amp; operator=(const Convertible1&amp;) { return *this; }
1770    Convertible1(const Convertible2&amp;) {}  
1771  };
1772  struct Convertible2 {
1773    Convertible2() {}
1774    Convertible2(const Convertible2&amp;) {}
1775    Convertible2&amp; operator=(const Convertible2&amp;) { return *this; }
1776    Convertible2(const Convertible1&amp;) {}  
1777  };
1778  TEST(VariantTest, TestRvalueConversion) {
1779  #if !defined(ABSL_USES_STD_VARIANT)
1780    variant&lt;double, std::string&gt; var(
1781        ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(
1782            variant&lt;std::string, int&gt;(0)));
1783    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(var));
1784    EXPECT_EQ(0.0, absl::get&lt;double&gt;(var));
1785    var = ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(
1786        variant&lt;const char*, float&gt;(&quot;foo&quot;));
1787    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(var));
1788    EXPECT_EQ(&quot;foo&quot;, absl::get&lt;std::string&gt;(var));
1789    variant&lt;double&gt; singleton(
1790        ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int, float&gt;(42)));
1791    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1792    EXPECT_EQ(42.0, absl::get&lt;double&gt;(singleton));
1793    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int, float&gt;(3.14f));
1794    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1795    EXPECT_FLOAT_EQ(3.14f, static_cast&lt;float&gt;(absl::get&lt;double&gt;(singleton)));
1796    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int&gt;(0));
1797    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1798    EXPECT_EQ(0.0, absl::get&lt;double&gt;(singleton));
1799    variant&lt;int32_t, uint32_t&gt; variant2(
1800        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(variant&lt;int32_t&gt;(42)));
1801    ASSERT_TRUE(absl::holds_alternative&lt;int32_t&gt;(variant2));
1802    EXPECT_EQ(42, absl::get&lt;int32_t&gt;(variant2));
1803    variant2 =
1804        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(variant&lt;uint32_t&gt;(42u));
1805    ASSERT_TRUE(absl::holds_alternative&lt;uint32_t&gt;(variant2));
1806    EXPECT_EQ(42u, absl::get&lt;uint32_t&gt;(variant2));
1807  #endif  
1808    variant&lt;Convertible1, Convertible2&gt; variant3(
1809        ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(
1810            (variant&lt;Convertible2, Convertible1&gt;(Convertible1()))));
1811    ASSERT_TRUE(absl::holds_alternative&lt;Convertible1&gt;(variant3));
1812    variant3 = ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(
1813        variant&lt;Convertible2, Convertible1&gt;(Convertible2()));
1814    ASSERT_TRUE(absl::holds_alternative&lt;Convertible2&gt;(variant3));
1815  }
1816  TEST(VariantTest, TestLvalueConversion) {
1817  #if !defined(ABSL_USES_STD_VARIANT)
1818    variant&lt;std::string, int&gt; source1 = 0;
1819    variant&lt;double, std::string&gt; destination(
1820        ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(source1));
1821    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(destination));
1822    EXPECT_EQ(0.0, absl::get&lt;double&gt;(destination));
1823    variant&lt;const char*, float&gt; source2 = &quot;foo&quot;;
1824    destination = ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(source2);
1825    ASSERT_TRUE(absl::holds_alternative&lt;std::string&gt;(destination));
1826    EXPECT_EQ(&quot;foo&quot;, absl::get&lt;std::string&gt;(destination));
1827    variant&lt;int, float&gt; source3(42);
1828    variant&lt;double&gt; singleton(ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source3));
1829    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1830    EXPECT_EQ(42.0, absl::get&lt;double&gt;(singleton));
1831    source3 = 3.14f;
1832    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source3);
1833    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1834    EXPECT_FLOAT_EQ(3.14f, static_cast&lt;float&gt;(absl::get&lt;double&gt;(singleton)));
1835    variant&lt;int&gt; source4(0);
1836    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source4);
1837    ASSERT_TRUE(absl::holds_alternative&lt;double&gt;(singleton));
1838    EXPECT_EQ(0.0, absl::get&lt;double&gt;(singleton));
1839    variant&lt;int32_t&gt; source5(42);
1840    variant&lt;int32_t, uint32_t&gt; variant2(
1841        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(source5));
1842    ASSERT_TRUE(absl::holds_alternative&lt;int32_t&gt;(variant2));
1843    EXPECT_EQ(42, absl::get&lt;int32_t&gt;(variant2));
1844    variant&lt;uint32_t&gt; source6(42u);
1845    variant2 = ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(source6);
1846    ASSERT_TRUE(absl::holds_alternative&lt;uint32_t&gt;(variant2));
1847    EXPECT_EQ(42u, absl::get&lt;uint32_t&gt;(variant2));
1848  #endif
1849    variant&lt;Convertible2, Convertible1&gt; source7((Convertible1()));
1850    variant&lt;Convertible1, Convertible2&gt; variant3(
1851        ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(source7));
1852    ASSERT_TRUE(absl::holds_alternative&lt;Convertible1&gt;(variant3));
1853    source7 = Convertible2();
1854    variant3 = ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(source7);
1855    ASSERT_TRUE(absl::holds_alternative&lt;Convertible2&gt;(variant3));
1856  }
1857  TEST(VariantTest, TestMoveConversion) {
1858    using Variant =
1859        variant&lt;std::unique_ptr&lt;const int&gt;, std::unique_ptr&lt;const std::string&gt;&gt;;
1860    using OtherVariant =
1861        variant&lt;std::unique_ptr&lt;int&gt;, std::unique_ptr&lt;std::string&gt;&gt;;
1862    Variant var(
1863        ConvertVariantTo&lt;Variant&gt;(OtherVariant{absl::make_unique&lt;int&gt;(0)}));
1864    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;const int&gt;&gt;(var));
1865    ASSERT_NE(absl::get&lt;std::unique_ptr&lt;const int&gt;&gt;(var), nullptr);
1866    EXPECT_EQ(0, *absl::get&lt;std::unique_ptr&lt;const int&gt;&gt;(var));
1867    var = ConvertVariantTo&lt;Variant&gt;(
1868        OtherVariant(absl::make_unique&lt;std::string&gt;(&quot;foo&quot;)));
1869    ASSERT_TRUE(absl::holds_alternative&lt;std::unique_ptr&lt;const std::string&gt;&gt;(var));
1870    EXPECT_EQ(&quot;foo&quot;, *absl::get&lt;std::unique_ptr&lt;const std::string&gt;&gt;(var));
1871  }
1872  TEST(VariantTest, DoesNotMoveFromLvalues) {
1873    using Variant =
1874        variant&lt;std::shared_ptr&lt;const int&gt;, std::shared_ptr&lt;const std::string&gt;&gt;;
1875    using OtherVariant =
1876        variant&lt;std::shared_ptr&lt;int&gt;, std::shared_ptr&lt;std::string&gt;&gt;;
1877    Variant v1(std::make_shared&lt;const int&gt;(0));
1878    Variant v2(v1);
1879    EXPECT_EQ(absl::get&lt;std::shared_ptr&lt;const int&gt;&gt;(v1),
1880              absl::get&lt;std::shared_ptr&lt;const int&gt;&gt;(v2));
1881    v1 = std::make_shared&lt;const std::string&gt;(&quot;foo&quot;);
1882    v2 = v1;
1883    EXPECT_EQ(absl::get&lt;std::shared_ptr&lt;const std::string&gt;&gt;(v1),
1884              absl::get&lt;std::shared_ptr&lt;const std::string&gt;&gt;(v2));
1885    OtherVariant other(std::make_shared&lt;int&gt;(0));
1886    Variant v3(ConvertVariantTo&lt;Variant&gt;(other));
1887    EXPECT_EQ(absl::get&lt;std::shared_ptr&lt;int&gt;&gt;(other),
1888              absl::get&lt;std::shared_ptr&lt;const int&gt;&gt;(v3));
1889    other = std::make_shared&lt;std::string&gt;(&quot;foo&quot;);
1890    v3 = ConvertVariantTo&lt;Variant&gt;(other);
1891    EXPECT_EQ(absl::get&lt;std::shared_ptr&lt;std::string&gt;&gt;(other),
1892              absl::get&lt;std::shared_ptr&lt;const std::string&gt;&gt;(v3));
1893  }
1894  TEST(VariantTest, TestRvalueConversionViaConvertVariantTo) {
1895  #if !defined(ABSL_USES_STD_VARIANT)
1896    variant&lt;double, std::string&gt; var(
1897        ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(
1898            variant&lt;std::string, int&gt;(3)));
1899    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;var), Pointee(3.0));
1900    var = ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(
1901        variant&lt;const char*, float&gt;(&quot;foo&quot;));
1902    EXPECT_THAT(absl::get_if&lt;std::string&gt;(&amp;var), Pointee(std::string(&quot;foo&quot;)));
1903    variant&lt;double&gt; singleton(
1904        ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int, float&gt;(42)));
1905    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(42.0));
1906    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int, float&gt;(3.14f));
1907    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(DoubleEq(3.14f)));
1908    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(variant&lt;int&gt;(3));
1909    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(3.0));
1910    variant&lt;int32_t, uint32_t&gt; variant2(
1911        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(variant&lt;int32_t&gt;(42)));
1912    EXPECT_THAT(absl::get_if&lt;int32_t&gt;(&amp;variant2), Pointee(42));
1913    variant2 =
1914        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(variant&lt;uint32_t&gt;(42u));
1915    EXPECT_THAT(absl::get_if&lt;uint32_t&gt;(&amp;variant2), Pointee(42u));
1916  #endif
1917    variant&lt;Convertible1, Convertible2&gt; variant3(
1918        ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(
1919            (variant&lt;Convertible2, Convertible1&gt;(Convertible1()))));
1920    ASSERT_TRUE(absl::holds_alternative&lt;Convertible1&gt;(variant3));
1921    variant3 = ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(
1922        variant&lt;Convertible2, Convertible1&gt;(Convertible2()));
1923    ASSERT_TRUE(absl::holds_alternative&lt;Convertible2&gt;(variant3));
1924  }
1925  TEST(VariantTest, TestLvalueConversionViaConvertVariantTo) {
1926  #if !defined(ABSL_USES_STD_VARIANT)
1927    variant&lt;std::string, int&gt; source1 = 3;
1928    variant&lt;double, std::string&gt; destination(
1929        ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(source1));
1930    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;destination), Pointee(3.0));
1931    variant&lt;const char*, float&gt; source2 = &quot;foo&quot;;
1932    destination = ConvertVariantTo&lt;variant&lt;double, std::string&gt;&gt;(source2);
1933    EXPECT_THAT(absl::get_if&lt;std::string&gt;(&amp;destination),
1934                Pointee(std::string(&quot;foo&quot;)));
1935    variant&lt;int, float&gt; source3(42);
1936    variant&lt;double&gt; singleton(ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source3));
1937    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(42.0));
1938    source3 = 3.14f;
1939    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source3);
1940    EXPECT_FLOAT_EQ(3.14f, static_cast&lt;float&gt;(absl::get&lt;double&gt;(singleton)));
1941    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(DoubleEq(3.14f)));
1942    variant&lt;int&gt; source4(3);
1943    singleton = ConvertVariantTo&lt;variant&lt;double&gt;&gt;(source4);
1944    EXPECT_THAT(absl::get_if&lt;double&gt;(&amp;singleton), Pointee(3.0));
1945    variant&lt;int32_t&gt; source5(42);
1946    variant&lt;int32_t, uint32_t&gt; variant2(
1947        ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(source5));
1948    EXPECT_THAT(absl::get_if&lt;int32_t&gt;(&amp;variant2), Pointee(42));
1949    variant&lt;uint32_t&gt; source6(42u);
1950    variant2 = ConvertVariantTo&lt;variant&lt;int32_t, uint32_t&gt;&gt;(source6);
1951    EXPECT_THAT(absl::get_if&lt;uint32_t&gt;(&amp;variant2), Pointee(42u));
1952  #endif  
1953    variant&lt;Convertible2, Convertible1&gt; source7((Convertible1()));
1954    variant&lt;Convertible1, Convertible2&gt; variant3(
1955        ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(source7));
1956    ASSERT_TRUE(absl::holds_alternative&lt;Convertible1&gt;(variant3));
1957    source7 = Convertible2();
1958    variant3 = ConvertVariantTo&lt;variant&lt;Convertible1, Convertible2&gt;&gt;(source7);
1959    ASSERT_TRUE(absl::holds_alternative&lt;Convertible2&gt;(variant3));
1960  }
1961  TEST(VariantTest, TestMoveConversionViaConvertVariantTo) {
1962    using Variant =
1963        variant&lt;std::unique_ptr&lt;const int&gt;, std::unique_ptr&lt;const std::string&gt;&gt;;
1964    using OtherVariant =
1965        variant&lt;std::unique_ptr&lt;int&gt;, std::unique_ptr&lt;std::string&gt;&gt;;
1966    Variant var(
1967        ConvertVariantTo&lt;Variant&gt;(OtherVariant{absl::make_unique&lt;int&gt;(3)}));
1968    EXPECT_THAT(absl::get_if&lt;std::unique_ptr&lt;const int&gt;&gt;(&amp;var),
1969                Pointee(Pointee(3)));
1970    var = ConvertVariantTo&lt;Variant&gt;(
1971        OtherVariant(absl::make_unique&lt;std::string&gt;(&quot;foo&quot;)));
1972    EXPECT_THAT(absl::get_if&lt;std::unique_ptr&lt;const std::string&gt;&gt;(&amp;var),
1973                Pointee(Pointee(std::string(&quot;foo&quot;))));
1974  }
1975  #if !(defined(ABSL_USES_STD_VARIANT) &amp;&amp; defined(__GLIBCXX__))
1976  #define ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY 1
1977  #endif
1978  TEST(VariantTest, TestCopyAndMoveTypeTraits) {
1979    EXPECT_TRUE(std::is_copy_constructible&lt;variant&lt;std::string&gt;&gt;::value);
1980    EXPECT_TRUE(absl::is_copy_assignable&lt;variant&lt;std::string&gt;&gt;::value);
1981    EXPECT_TRUE(std::is_move_constructible&lt;variant&lt;std::string&gt;&gt;::value);
1982    EXPECT_TRUE(absl::is_move_assignable&lt;variant&lt;std::string&gt;&gt;::value);
1983    EXPECT_TRUE(std::is_move_constructible&lt;variant&lt;std::unique_ptr&lt;int&gt;&gt;&gt;::value);
1984    EXPECT_TRUE(absl::is_move_assignable&lt;variant&lt;std::unique_ptr&lt;int&gt;&gt;&gt;::value);
1985    EXPECT_FALSE(
1986        std::is_copy_constructible&lt;variant&lt;std::unique_ptr&lt;int&gt;&gt;&gt;::value);
1987    EXPECT_FALSE(absl::is_copy_assignable&lt;variant&lt;std::unique_ptr&lt;int&gt;&gt;&gt;::value);
1988    EXPECT_FALSE(
1989        absl::is_trivially_copy_constructible&lt;variant&lt;std::string&gt;&gt;::value);
1990    EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;variant&lt;std::string&gt;&gt;::value);
1991  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
1992    EXPECT_TRUE(absl::is_trivially_copy_constructible&lt;variant&lt;int&gt;&gt;::value);
1993    EXPECT_TRUE(absl::is_trivially_copy_assignable&lt;variant&lt;int&gt;&gt;::value);
1994    EXPECT_TRUE(is_trivially_move_constructible&lt;variant&lt;int&gt;&gt;::value);
1995    EXPECT_TRUE(is_trivially_move_assignable&lt;variant&lt;int&gt;&gt;::value);
1996  #endif  
1997  }
1998  TEST(VariantTest, TestVectorOfMoveonlyVariant) {
1999    std::vector&lt;variant&lt;std::unique_ptr&lt;int&gt;, std::string&gt;&gt; vec;
2000    vec.push_back(absl::make_unique&lt;int&gt;(42));
2001    vec.emplace_back(&quot;Hello&quot;);
2002    vec.reserve(3);
2003    auto another_vec = absl::move(vec);
2004    ASSERT_EQ(2u, another_vec.size());
2005    EXPECT_EQ(42, *absl::get&lt;std::unique_ptr&lt;int&gt;&gt;(another_vec[0]));
2006    EXPECT_EQ(&quot;Hello&quot;, absl::get&lt;std::string&gt;(another_vec[1]));
2007  }
2008  TEST(VariantTest, NestedVariant) {
2009  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
2010    static_assert(absl::is_trivially_copy_constructible&lt;variant&lt;int&gt;&gt;(), &quot;&quot;);
2011    static_assert(absl::is_trivially_copy_assignable&lt;variant&lt;int&gt;&gt;(), &quot;&quot;);
2012    static_assert(is_trivially_move_constructible&lt;variant&lt;int&gt;&gt;(), &quot;&quot;);
2013    static_assert(is_trivially_move_assignable&lt;variant&lt;int&gt;&gt;(), &quot;&quot;);
2014    static_assert(absl::is_trivially_copy_constructible&lt;variant&lt;variant&lt;int&gt;&gt;&gt;(),
2015                  &quot;&quot;);
2016    static_assert(absl::is_trivially_copy_assignable&lt;variant&lt;variant&lt;int&gt;&gt;&gt;(),
2017                  &quot;&quot;);
2018    static_assert(is_trivially_move_constructible&lt;variant&lt;variant&lt;int&gt;&gt;&gt;(), &quot;&quot;);
2019    static_assert(is_trivially_move_assignable&lt;variant&lt;variant&lt;int&gt;&gt;&gt;(), &quot;&quot;);
2020  #endif  
2021    variant&lt;int&gt; x(42);
2022    variant&lt;variant&lt;int&gt;&gt; y(x);
2023    variant&lt;variant&lt;int&gt;&gt; z(y);
2024    EXPECT_TRUE(absl::holds_alternative&lt;variant&lt;int&gt;&gt;(z));
2025    EXPECT_EQ(x, absl::get&lt;variant&lt;int&gt;&gt;(z));
2026  }
2027  struct TriviallyDestructible {
2028    TriviallyDestructible(TriviallyDestructible&amp;&amp;) {}
2029    TriviallyDestructible(const TriviallyDestructible&amp;) {}
2030    TriviallyDestructible&amp; operator=(TriviallyDestructible&amp;&amp;) { return *this; }
2031    TriviallyDestructible&amp; operator=(const TriviallyDestructible&amp;) {
2032      return *this;
2033    }
2034  };
2035  struct TriviallyMovable {
2036    TriviallyMovable(TriviallyMovable&amp;&amp;) = default;
2037    TriviallyMovable(TriviallyMovable const&amp;) {}
2038    TriviallyMovable&amp; operator=(const TriviallyMovable&amp;) { return *this; }
2039  };
2040  struct TriviallyCopyable {
2041    TriviallyCopyable(const TriviallyCopyable&amp;) = default;
2042    TriviallyCopyable&amp; operator=(const TriviallyCopyable&amp;) { return *this; }
2043  };
2044  struct TriviallyMoveAssignable {
2045    TriviallyMoveAssignable(TriviallyMoveAssignable&amp;&amp;) = default;
2046    TriviallyMoveAssignable(const TriviallyMoveAssignable&amp;) {}
2047    TriviallyMoveAssignable&amp; operator=(TriviallyMoveAssignable&amp;&amp;) = default;
2048    TriviallyMoveAssignable&amp; operator=(const TriviallyMoveAssignable&amp;) {
2049      return *this;
2050    }
2051  };
2052  struct TriviallyCopyAssignable {};
2053  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
2054  TEST(VariantTest, TestTriviality) {
2055    {
2056      using TrivDestVar = absl::variant&lt;TriviallyDestructible&gt;;
2057      EXPECT_FALSE(is_trivially_move_constructible&lt;TrivDestVar&gt;::value);
2058      EXPECT_FALSE(absl::is_trivially_copy_constructible&lt;TrivDestVar&gt;::value);
2059      EXPECT_FALSE(is_trivially_move_assignable&lt;TrivDestVar&gt;::value);
2060      EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;TrivDestVar&gt;::value);
2061      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivDestVar&gt;::value);
2062    }
2063    {
2064      using TrivMoveVar = absl::variant&lt;TriviallyMovable&gt;;
2065      EXPECT_TRUE(is_trivially_move_constructible&lt;TrivMoveVar&gt;::value);
2066      EXPECT_FALSE(absl::is_trivially_copy_constructible&lt;TrivMoveVar&gt;::value);
2067      EXPECT_FALSE(is_trivially_move_assignable&lt;TrivMoveVar&gt;::value);
2068      EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;TrivMoveVar&gt;::value);
2069      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivMoveVar&gt;::value);
2070    }
2071    {
2072      using TrivCopyVar = absl::variant&lt;TriviallyCopyable&gt;;
2073      EXPECT_TRUE(is_trivially_move_constructible&lt;TrivCopyVar&gt;::value);
2074      EXPECT_TRUE(absl::is_trivially_copy_constructible&lt;TrivCopyVar&gt;::value);
2075      EXPECT_FALSE(is_trivially_move_assignable&lt;TrivCopyVar&gt;::value);
2076      EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;TrivCopyVar&gt;::value);
2077      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivCopyVar&gt;::value);
2078    }
2079    {
2080      using TrivMoveAssignVar = absl::variant&lt;TriviallyMoveAssignable&gt;;
2081      EXPECT_TRUE(is_trivially_move_constructible&lt;TrivMoveAssignVar&gt;::value);
2082      EXPECT_FALSE(
2083          absl::is_trivially_copy_constructible&lt;TrivMoveAssignVar&gt;::value);
2084      EXPECT_TRUE(is_trivially_move_assignable&lt;TrivMoveAssignVar&gt;::value);
2085      EXPECT_FALSE(absl::is_trivially_copy_assignable&lt;TrivMoveAssignVar&gt;::value);
2086      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivMoveAssignVar&gt;::value);
2087    }
2088    {
2089      using TrivCopyAssignVar = absl::variant&lt;TriviallyCopyAssignable&gt;;
2090      EXPECT_TRUE(is_trivially_move_constructible&lt;TrivCopyAssignVar&gt;::value);
2091      EXPECT_TRUE(
2092          absl::is_trivially_copy_constructible&lt;TrivCopyAssignVar&gt;::value);
2093      EXPECT_TRUE(is_trivially_move_assignable&lt;TrivCopyAssignVar&gt;::value);
2094      EXPECT_TRUE(absl::is_trivially_copy_assignable&lt;TrivCopyAssignVar&gt;::value);
2095      EXPECT_TRUE(absl::is_trivially_destructible&lt;TrivCopyAssignVar&gt;::value);
2096    }
2097  }
2098  #endif  
2099  TEST(VariantTest, MoveCtorBug) {
2100    struct TrivialCopyNontrivialMove {
2101      TrivialCopyNontrivialMove() = default;
2102      TrivialCopyNontrivialMove(const TrivialCopyNontrivialMove&amp;) = default;
2103      TrivialCopyNontrivialMove(TrivialCopyNontrivialMove&amp;&amp;) { called = true; }
2104      bool called = false;
2105    };
2106    {
2107      using V = absl::variant&lt;TrivialCopyNontrivialMove, int&gt;;
2108      V v1(absl::in_place_index&lt;0&gt;);
2109      V v2(std::move(v1));
2110      EXPECT_TRUE(absl::get&lt;0&gt;(v2).called);
2111    }
2112    {
2113      using V = absl::variant&lt;int, TrivialCopyNontrivialMove&gt;;
2114      V v1(absl::in_place_index&lt;1&gt;);
2115      V v2(std::move(v1));
2116      EXPECT_TRUE(absl::get&lt;1&gt;(v2).called);
2117    }
2118  }
2119  }  
2120  ABSL_NAMESPACE_END
2121  }  
2122  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>238    Variant copied(original);
239    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(copied) ||
240                TypeParam::kIndex != 1);
241    EXPECT_TRUE(absl::holds_alternative&lt;value_type2&gt;(copied) ||
242                TypeParam::kIndex != 2);
243    EXPECT_TRUE(absl::holds_alternative&lt;value_type3&gt;(copied) ||
244                TypeParam::kIndex != 3);
245    EXPECT_TRUE(absl::holds_alternative&lt;value_type4&gt;(copied) ||
246                TypeParam::kIndex != 4);
247    EXPECT_TRUE((absl::get_if&lt;value_type1&gt;(&amp;original) ==
</pre></code></div>
                <div class="column column_space"><pre><code>322    Variant v(value);
323    EXPECT_TRUE(absl::holds_alternative&lt;value_type1&gt;(v) ||
324                TypeParam::kIndex != 1);
325    EXPECT_TRUE(absl::holds_alternative&lt;value_type2&gt;(v) ||
326                TypeParam::kIndex != 2);
327    EXPECT_TRUE(absl::holds_alternative&lt;value_type3&gt;(v) ||
328                TypeParam::kIndex != 3);
329    EXPECT_TRUE(absl::holds_alternative&lt;value_type4&gt;(v) ||
330                TypeParam::kIndex != 4);
331    EXPECT_TRUE(nullptr != absl::get_if&lt;value_type1&gt;(&amp;v) ||
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    