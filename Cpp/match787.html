<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for approximate_time.h &amp; test_socket.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for approximate_time.h &amp; test_socket.cpp
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>approximate_time.h (1.9274377%)<th>test_socket.cpp (1.7763846%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(135-151)<td><a href="#" name="0">(1035-1055)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>approximate_time.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef MESSAGE_FILTERS_SYNC_APPROXIMATE_TIME_H
#define MESSAGE_FILTERS_SYNC_APPROXIMATE_TIME_H
#include "message_filters/synchronizer.h"
#include "message_filters/connection.h"
#include "message_filters/null_types.h"
#include "message_filters/signal9.h"
#include &lt;boost/tuple/tuple.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;boost/function.hpp&gt;
#include &lt;boost/thread/mutex.hpp&gt;
#include &lt;boost/bind.hpp&gt;
#include &lt;boost/type_traits/is_same.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/mpl/or.hpp&gt;
#include &lt;boost/mpl/at.hpp&gt;
#include &lt;boost/mpl/vector.hpp&gt;
#include &lt;ros/assert.h&gt;
#include &lt;ros/message_traits.h&gt;
#include &lt;ros/message_event.h&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
namespace message_filters
{
namespace sync_policies
{
namespace mpl = boost::mpl;
template&lt;typename M0, typename M1, typename M2 = NullType, typename M3 = NullType, typename M4 = NullType,
         typename M5 = NullType, typename M6 = NullType, typename M7 = NullType, typename M8 = NullType&gt;
struct ApproximateTime : public PolicyBase&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt;
{
  typedef Synchronizer&lt;ApproximateTime&gt; Sync;
  typedef PolicyBase&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt; Super;
  typedef typename Super::Messages Messages;
  typedef typename Super::Signal Signal;
  typedef typename Super::Events Events;
  typedef typename Super::RealTypeCount RealTypeCount;
  typedef typename Super::M0Event M0Event;
  typedef typename Super::M1Event M1Event;
  typedef typename Super::M2Event M2Event;
  typedef typename Super::M3Event M3Event;
  typedef typename Super::M4Event M4Event;
  typedef typename Super::M5Event M5Event;
  typedef typename Super::M6Event M6Event;
  typedef typename Super::M7Event M7Event;
  typedef typename Super::M8Event M8Event;
  typedef std::deque&lt;M0Event&gt; M0Deque;
  typedef std::deque&lt;M1Event&gt; M1Deque;
  typedef std::deque&lt;M2Event&gt; M2Deque;
  typedef std::deque&lt;M3Event&gt; M3Deque;
  typedef std::deque&lt;M4Event&gt; M4Deque;
  typedef std::deque&lt;M5Event&gt; M5Deque;
  typedef std::deque&lt;M6Event&gt; M6Deque;
  typedef std::deque&lt;M7Event&gt; M7Deque;
  typedef std::deque&lt;M8Event&gt; M8Deque;
  typedef std::vector&lt;M0Event&gt; M0Vector;
  typedef std::vector&lt;M1Event&gt; M1Vector;
  typedef std::vector&lt;M2Event&gt; M2Vector;
  typedef std::vector&lt;M3Event&gt; M3Vector;
  typedef std::vector&lt;M4Event&gt; M4Vector;
  typedef std::vector&lt;M5Event&gt; M5Vector;
  typedef std::vector&lt;M6Event&gt; M6Vector;
  typedef std::vector&lt;M7Event&gt; M7Vector;
  typedef std::vector&lt;M8Event&gt; M8Vector;
  typedef boost::tuple&lt;M0Event, M1Event, M2Event, M3Event, M4Event, M5Event, M6Event, M7Event, M8Event&gt; Tuple;
  typedef boost::tuple&lt;M0Deque, M1Deque, M2Deque, M3Deque, M4Deque, M5Deque, M6Deque, M7Deque, M8Deque&gt; DequeTuple;
  typedef boost::tuple&lt;M0Vector, M1Vector, M2Vector, M3Vector, M4Vector, M5Vector, M6Vector, M7Vector, M8Vector&gt; VectorTuple;
  ApproximateTime(uint32_t queue_size)
  : parent_(0)
  , queue_size_(queue_size)
  , enable_reset_(false)
  , num_reset_deques_(0)
  , num_non_empty_deques_(0)
  , pivot_(NO_PIVOT)
  , max_interval_duration_(ros::DURATION_MAX)
  , age_penalty_(0.1)
  , has_dropped_messages_(9, false)
  , inter_message_lower_bounds_(9, ros::Duration(0))
  , warned_about_incorrect_bound_(9, false)
  , last_stamps_(9, ros::Time(0, 0))
  {
    ROS_ASSERT(queue_size_ &gt; 0);    }
  ApproximateTime(const ApproximateTime&amp; e)
  {
    *this = e;
  }
<a name="0"></a>
  ApproximateTime&amp; operator=(const ApproximateTime&amp; rhs)
  {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    parent_ = rhs.parent_;
    queue_size_ = rhs.queue_size_;
    num_non_empty_deques_ = rhs.num_non_empty_deques_;
    pivot_time_ = rhs.pivot_time_;
    pivot_ = rhs.pivot_;
    max_interval_duration_ = rhs.max_interval_duration_;
    age_penalty_ = rhs.age_penalty_;
    candidate_start_ = rhs.candidate_start_;
    candidate_end_ = rhs.candidate_end_;
    deques_ = rhs.deques_;
    past_ = rhs.past_;
    has_dropped_messages_ = rhs.has_dropped_messages_;
    inter_message_lower_bounds_ = rhs.inter_message_lower_bounds_;
    warned_about_incorrect_bound_ = rhs.warned_about_incorrect_bound_;
    last_stamps_ = rhs.last_stamps_;
    enable_reset_ = rhs.enable_reset_;
    num_reset_deques_ = rhs.num_reset_deques_;</b></font>
    return *this;
  }
  void initParent(Sync* parent)
  {
    parent_ = parent;
  }
  template&lt;int i&gt;
  bool checkInterMessageBound()
  {
    namespace mt = ros::message_traits;
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    ROS_ASSERT(!deque.empty());
    const typename mpl::at_c&lt;Messages, i&gt;::type &amp;msg = *(deque.back()).getMessage();
    ros::Time msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(msg);
    ros::Time previous_msg_time;
    bool check_ok = true;
    if (deque.size() == (size_t) 1)
    {
      if (v.empty())
      {
        return check_ok;
      }
      const typename mpl::at_c&lt;Messages, i&gt;::type &amp;previous_msg = *(v.back()).getMessage();
      previous_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(previous_msg);
    }
    else
    {
      const typename mpl::at_c&lt;Messages, i&gt;::type &amp;previous_msg = *(deque[deque.size()-2]).getMessage();
      previous_msg_time =  mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(previous_msg);
    }
    if (msg_time &lt; previous_msg_time)
    {
      if (!warned_about_incorrect_bound_[i])
        ROS_WARN_STREAM("Messages of type " &lt;&lt; i &lt;&lt; " arrived out of order (will print only once)");
      warned_about_incorrect_bound_[i] = true;
      check_ok = false;
    }
    else if ((msg_time - previous_msg_time) &lt; inter_message_lower_bounds_[i])
    {
      if (!warned_about_incorrect_bound_[i])
        ROS_WARN_STREAM("Messages of type " &lt;&lt; i &lt;&lt; " arrived closer (" &lt;&lt; (msg_time - previous_msg_time)
                        &lt;&lt; ") than the lower bound you provided (" &lt;&lt; inter_message_lower_bounds_[i]
                        &lt;&lt; ") (will print only once)");
      warned_about_incorrect_bound_[i] = true;
      check_ok = false;
    }
    return check_ok;
  }
  template&lt;int i&gt;
  void add(const typename mpl::at_c&lt;Events, i&gt;::type&amp; evt)
  {
    boost::mutex::scoped_lock lock(data_mutex_);
    ros::Time now = evt.getReceiptTime();
    if (ros::Time::isSimTime() &amp;&amp; enable_reset_)
    {
      if (now &lt; last_stamps_[i])
      {
        ++num_reset_deques_;
        if (num_reset_deques_ == 1)
        {
          ROS_WARN("Detected jump back in time. Clearing message filter queues");
        }
        clearDeque&lt;i&gt;();
        if (num_reset_deques_ &gt;= RealTypeCount::value)
        {
          num_reset_deques_ = 0;
        }
      }
    }
    last_stamps_[i] = now;
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
    deque.push_back(evt);
    if (deque.size() == (size_t)1) {
      ++num_non_empty_deques_;
      if (num_non_empty_deques_ == (uint32_t)RealTypeCount::value)
      {
        process();
      }
    }
    else
    {
      if (!checkInterMessageBound&lt;i&gt;())
        if (ros::Time::isSimTime() &amp;&amp; enable_reset_)
        {
          dequeDeleteFront&lt;i&gt;();
        }
    }
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; past = boost::get&lt;i&gt;(past_);
    if (deque.size() + past.size() &gt; queue_size_)
    {
      num_non_empty_deques_ = 0;       recover&lt;0&gt;();
      recover&lt;1&gt;();
      recover&lt;2&gt;();
      recover&lt;3&gt;();
      recover&lt;4&gt;();
      recover&lt;5&gt;();
      recover&lt;6&gt;();
      recover&lt;7&gt;();
      recover&lt;8&gt;();
      ROS_ASSERT(!deque.empty());
      deque.pop_front();
      has_dropped_messages_[i] = true;
      if (pivot_ != NO_PIVOT)
      {
	candidate_ = Tuple();
	pivot_ = NO_PIVOT;
	process();
      }
    }
  }
  void setAgePenalty(double age_penalty)
  {
    ROS_ASSERT(age_penalty &gt;= 0);
    age_penalty_ = age_penalty;
  }
  void setInterMessageLowerBound(int i, ros::Duration lower_bound) {
    ROS_ASSERT(lower_bound &gt;= ros::Duration(0,0));
    inter_message_lower_bounds_[i] = lower_bound;
  }
  void setInterMessageLowerBound(ros::Duration lower_bound) {
    ROS_ASSERT(lower_bound &gt;= ros::Duration(0,0));
    for (size_t i = 0; i &lt; inter_message_lower_bounds_.size(); i++)
    {
      inter_message_lower_bounds_[i] = lower_bound;
    }
  }
  void setMaxIntervalDuration(ros::Duration max_interval_duration) {
    ROS_ASSERT(max_interval_duration &gt;= ros::Duration(0,0));
    max_interval_duration_ = max_interval_duration;
  }
  void setReset(const bool reset)
  {
    enable_reset_ = reset;
  }
private:
  template&lt;int i&gt;
  void clearDeque()
  {
    num_non_empty_deques_ = 0;
    recover&lt;0&gt;();
    recover&lt;1&gt;();
    recover&lt;2&gt;();
    recover&lt;3&gt;();
    recover&lt;4&gt;();
    recover&lt;5&gt;();
    recover&lt;6&gt;();
    recover&lt;7&gt;();
    recover&lt;8&gt;();
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    if (!q.empty())
    {
      --num_non_empty_deques_;
    }
    q.clear();
    warned_about_incorrect_bound_[i] = false;
    candidate_ = Tuple();
    pivot_ = NO_PIVOT;
  }
  template&lt;int i&gt;
  void dequeDeleteFront()
  {
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
    ROS_ASSERT(!deque.empty());
    deque.pop_front();
    if (deque.empty())
    {
      --num_non_empty_deques_;
    }
  }
  void dequeDeleteFront(uint32_t index)
  {
    switch (index)
    {
    case 0:
      dequeDeleteFront&lt;0&gt;();
      break;
    case 1:
      dequeDeleteFront&lt;1&gt;();
      break;
    case 2:
      dequeDeleteFront&lt;2&gt;();
      break;
    case 3:
      dequeDeleteFront&lt;3&gt;();
      break;
    case 4:
      dequeDeleteFront&lt;4&gt;();
      break;
    case 5:
      dequeDeleteFront&lt;5&gt;();
      break;
    case 6:
      dequeDeleteFront&lt;6&gt;();
      break;
    case 7:
      dequeDeleteFront&lt;7&gt;();
      break;
    case 8:
      dequeDeleteFront&lt;8&gt;();
      break;
    default:
      ROS_BREAK();
    }
  }
  template&lt;int i&gt;
  void dequeMoveFrontToPast()
  {
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; vector = boost::get&lt;i&gt;(past_);
    ROS_ASSERT(!deque.empty());
    vector.push_back(deque.front());
    deque.pop_front();
    if (deque.empty())
    {
      --num_non_empty_deques_;
    }
  }
  void dequeMoveFrontToPast(uint32_t index)
  {
    switch (index)
    {
    case 0:
      dequeMoveFrontToPast&lt;0&gt;();
      break;
    case 1:
      dequeMoveFrontToPast&lt;1&gt;();
      break;
    case 2:
      dequeMoveFrontToPast&lt;2&gt;();
      break;
    case 3:
      dequeMoveFrontToPast&lt;3&gt;();
      break;
    case 4:
      dequeMoveFrontToPast&lt;4&gt;();
      break;
    case 5:
      dequeMoveFrontToPast&lt;5&gt;();
      break;
    case 6:
      dequeMoveFrontToPast&lt;6&gt;();
      break;
    case 7:
      dequeMoveFrontToPast&lt;7&gt;();
      break;
    case 8:
      dequeMoveFrontToPast&lt;8&gt;();
      break;
    default:
      ROS_BREAK();
    }
  }
  void makeCandidate()
  {
    candidate_ = Tuple();     boost::get&lt;0&gt;(candidate_) = boost::get&lt;0&gt;(deques_).front();
    boost::get&lt;1&gt;(candidate_) = boost::get&lt;1&gt;(deques_).front();
    if (RealTypeCount::value &gt; 2)
    {
      boost::get&lt;2&gt;(candidate_) = boost::get&lt;2&gt;(deques_).front();
      if (RealTypeCount::value &gt; 3)
      {
	boost::get&lt;3&gt;(candidate_) = boost::get&lt;3&gt;(deques_).front();
	if (RealTypeCount::value &gt; 4)
	{
	  boost::get&lt;4&gt;(candidate_) = boost::get&lt;4&gt;(deques_).front();
	  if (RealTypeCount::value &gt; 5)
	  {
	    boost::get&lt;5&gt;(candidate_) = boost::get&lt;5&gt;(deques_).front();
	    if (RealTypeCount::value &gt; 6)
	    {
	      boost::get&lt;6&gt;(candidate_) = boost::get&lt;6&gt;(deques_).front();
	      if (RealTypeCount::value &gt; 7)
	      {
		boost::get&lt;7&gt;(candidate_) = boost::get&lt;7&gt;(deques_).front();
		if (RealTypeCount::value &gt; 8)
		{
		  boost::get&lt;8&gt;(candidate_) = boost::get&lt;8&gt;(deques_).front();
		}
	      }
	    }
	  }
	}
      }
    }
    boost::get&lt;0&gt;(past_).clear();
    boost::get&lt;1&gt;(past_).clear();
    boost::get&lt;2&gt;(past_).clear();
    boost::get&lt;3&gt;(past_).clear();
    boost::get&lt;4&gt;(past_).clear();
    boost::get&lt;5&gt;(past_).clear();
    boost::get&lt;6&gt;(past_).clear();
    boost::get&lt;7&gt;(past_).clear();
    boost::get&lt;8&gt;(past_).clear();
  }
  template&lt;int i&gt;
  void recover(size_t num_messages)
  {
    if (i &gt;= RealTypeCount::value)
    {
      return;
    }
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    ROS_ASSERT(num_messages &lt;= v.size());
    while (num_messages &gt; 0)
    {
      q.push_front(v.back());
      v.pop_back();
      num_messages--;
    }
    if (!q.empty())
    {
      ++num_non_empty_deques_;
    }
  }
  template&lt;int i&gt;
  void recover()
  {
    if (i &gt;= RealTypeCount::value)
    {
      return;
    }
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    while (!v.empty())
    {
      q.push_front(v.back());
      v.pop_back();
    }
    if (!q.empty())
    {
      ++num_non_empty_deques_;
    }
  }
  template&lt;int i&gt;
  void recoverAndDelete()
  {
    if (i &gt;= RealTypeCount::value)
    {
      return;
    }
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    while (!v.empty())
    {
      q.push_front(v.back());
      v.pop_back();
    }
    ROS_ASSERT(!q.empty());
    q.pop_front();
    if (!q.empty())
    {
      ++num_non_empty_deques_;
    }
  }
  void publishCandidate()
  {
    parent_-&gt;signal(boost::get&lt;0&gt;(candidate_), boost::get&lt;1&gt;(candidate_), boost::get&lt;2&gt;(candidate_), boost::get&lt;3&gt;(candidate_),
                    boost::get&lt;4&gt;(candidate_), boost::get&lt;5&gt;(candidate_), boost::get&lt;6&gt;(candidate_), boost::get&lt;7&gt;(candidate_),
                    boost::get&lt;8&gt;(candidate_));
    candidate_ = Tuple();
    pivot_ = NO_PIVOT;
    num_non_empty_deques_ = 0;     recoverAndDelete&lt;0&gt;();
    recoverAndDelete&lt;1&gt;();
    recoverAndDelete&lt;2&gt;();
    recoverAndDelete&lt;3&gt;();
    recoverAndDelete&lt;4&gt;();
    recoverAndDelete&lt;5&gt;();
    recoverAndDelete&lt;6&gt;();
    recoverAndDelete&lt;7&gt;();
    recoverAndDelete&lt;8&gt;();
  }
  void getCandidateStart(uint32_t &amp;start_index, ros::Time &amp;start_time)
  {
    return getCandidateBoundary(start_index, start_time, false);
  }
  void getCandidateEnd(uint32_t &amp;end_index, ros::Time &amp;end_time)
  {
    return getCandidateBoundary(end_index, end_time, true);
  }
  void getCandidateBoundary(uint32_t &amp;index, ros::Time &amp;time, bool end)
  {
    namespace mt = ros::message_traits;
    M0Event&amp; m0 = boost::get&lt;0&gt;(deques_).front();
    time = mt::TimeStamp&lt;M0&gt;::value(*m0.getMessage());
    index = 0;
    if (RealTypeCount::value &gt; 1)
    {
      M1Event&amp; m1 = boost::get&lt;1&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M1&gt;::value(*m1.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M1&gt;::value(*m1.getMessage());
        index = 1;
      }
    }
    if (RealTypeCount::value &gt; 2)
    {
      M2Event&amp; m2 = boost::get&lt;2&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M2&gt;::value(*m2.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M2&gt;::value(*m2.getMessage());
        index = 2;
      }
    }
    if (RealTypeCount::value &gt; 3)
    {
      M3Event&amp; m3 = boost::get&lt;3&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M3&gt;::value(*m3.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M3&gt;::value(*m3.getMessage());
        index = 3;
      }
    }
    if (RealTypeCount::value &gt; 4)
    {
      M4Event&amp; m4 = boost::get&lt;4&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M4&gt;::value(*m4.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M4&gt;::value(*m4.getMessage());
        index = 4;
      }
    }
    if (RealTypeCount::value &gt; 5)
    {
      M5Event&amp; m5 = boost::get&lt;5&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M5&gt;::value(*m5.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M5&gt;::value(*m5.getMessage());
        index = 5;
      }
    }
    if (RealTypeCount::value &gt; 6)
    {
      M6Event&amp; m6 = boost::get&lt;6&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M6&gt;::value(*m6.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M6&gt;::value(*m6.getMessage());
        index = 6;
      }
    }
    if (RealTypeCount::value &gt; 7)
    {
      M7Event&amp; m7 = boost::get&lt;7&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M7&gt;::value(*m7.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M7&gt;::value(*m7.getMessage());
        index = 7;
      }
    }
    if (RealTypeCount::value &gt; 8)
    {
      M8Event&amp; m8 = boost::get&lt;8&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M8&gt;::value(*m8.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M8&gt;::value(*m8.getMessage());
        index = 8;
      }
    }
  }
  template&lt;int i&gt;
  ros::Time getVirtualTime()
  {
    namespace mt = ros::message_traits;
    if (i &gt;= RealTypeCount::value)
    {
      return ros::Time(0,0);      }
    ROS_ASSERT(pivot_ != NO_PIVOT);
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    if (q.empty())
    {
      ROS_ASSERT(!v.empty());        ros::Time last_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(*(v.back()).getMessage());
      ros::Time msg_time_lower_bound = last_msg_time + inter_message_lower_bounds_[i];
      if (msg_time_lower_bound &gt; pivot_time_)        {
        return msg_time_lower_bound;
      }
      return pivot_time_;
    }
    ros::Time current_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(*(q.front()).getMessage());
    return current_msg_time;
  }
  void getVirtualCandidateStart(uint32_t &amp;start_index, ros::Time &amp;start_time)
  {
    return getVirtualCandidateBoundary(start_index, start_time, false);
  }
  void getVirtualCandidateEnd(uint32_t &amp;end_index, ros::Time &amp;end_time)
  {
    return getVirtualCandidateBoundary(end_index, end_time, true);
  }
  void getVirtualCandidateBoundary(uint32_t &amp;index, ros::Time &amp;time, bool end)
  {
    namespace mt = ros::message_traits;
    std::vector&lt;ros::Time&gt; virtual_times(9);
    virtual_times[0] = getVirtualTime&lt;0&gt;();
    virtual_times[1] = getVirtualTime&lt;1&gt;();
    virtual_times[2] = getVirtualTime&lt;2&gt;();
    virtual_times[3] = getVirtualTime&lt;3&gt;();
    virtual_times[4] = getVirtualTime&lt;4&gt;();
    virtual_times[5] = getVirtualTime&lt;5&gt;();
    virtual_times[6] = getVirtualTime&lt;6&gt;();
    virtual_times[7] = getVirtualTime&lt;7&gt;();
    virtual_times[8] = getVirtualTime&lt;8&gt;();
    time = virtual_times[0];
    index = 0;
    for (int i = 0; i &lt; RealTypeCount::value; i++)
    {
      if ((virtual_times[i] &lt; time) ^ end)
      {
	time = virtual_times[i];
	index = i;
      }
    }
  }
  void process()
  {
    while (num_non_empty_deques_ == (uint32_t)RealTypeCount::value)
    {
      ros::Time end_time, start_time;
      uint32_t end_index, start_index;
      getCandidateEnd(end_index, end_time);
      getCandidateStart(start_index, start_time);
      for (uint32_t i = 0; i &lt; (uint32_t)RealTypeCount::value; i++)
      {
	if (i != end_index)
	{
	  has_dropped_messages_[i] = false;
	}
      }
      if (pivot_ == NO_PIVOT)
      {
        if (end_time - start_time &gt; max_interval_duration_)
        {
          dequeDeleteFront(start_index);
          continue;
        }
	if (has_dropped_messages_[end_index])
	{
	  dequeDeleteFront(start_index);
	  continue;
	}
	makeCandidate();
	candidate_start_ = start_time;
	candidate_end_ = end_time;
	pivot_ = end_index;
	pivot_time_ = end_time;
	dequeMoveFrontToPast(start_index);
      }
      else
      {
        if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (start_time - candidate_start_))
        {
          dequeMoveFrontToPast(start_index);
        }
        else
        {
          makeCandidate();
          candidate_start_ = start_time;
          candidate_end_ = end_time;
          dequeMoveFrontToPast(start_index);
        }
      }
      ROS_ASSERT(pivot_ != NO_PIVOT);
      if (start_index == pivot_)        {
        publishCandidate();
      }
      else if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (pivot_time_ - candidate_start_))
      {
        publishCandidate();
      }
      else if (num_non_empty_deques_ &lt; (uint32_t)RealTypeCount::value)
      {
        uint32_t num_non_empty_deques_before_virtual_search = num_non_empty_deques_;
        std::vector&lt;int&gt; num_virtual_moves(9,0);
        while (1)
        {
          ros::Time end_time, start_time;
          uint32_t end_index, start_index;
          getVirtualCandidateEnd(end_index, end_time);
          getVirtualCandidateStart(start_index, start_time);
          if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (pivot_time_ - candidate_start_))
          {
            publishCandidate();              break;            }
          if ((end_time - candidate_end_) * (1 + age_penalty_) &lt; (start_time - candidate_start_))
          {
            num_non_empty_deques_ = 0; 	    recover&lt;0&gt;(num_virtual_moves[0]);
	    recover&lt;1&gt;(num_virtual_moves[1]);
	    recover&lt;2&gt;(num_virtual_moves[2]);
	    recover&lt;3&gt;(num_virtual_moves[3]);
	    recover&lt;4&gt;(num_virtual_moves[4]);
	    recover&lt;5&gt;(num_virtual_moves[5]);
	    recover&lt;6&gt;(num_virtual_moves[6]);
	    recover&lt;7&gt;(num_virtual_moves[7]);
	    recover&lt;8&gt;(num_virtual_moves[8]);
            (void)num_non_empty_deques_before_virtual_search;             ROS_ASSERT(num_non_empty_deques_before_virtual_search == num_non_empty_deques_);
            break;
          }
	  ROS_ASSERT(start_index != pivot_);
	  ROS_ASSERT(start_time &lt; pivot_time_);
          dequeMoveFrontToPast(start_index);
          num_virtual_moves[start_index]++;
        }       }
    }   }
  Sync* parent_;
  uint32_t queue_size_;
  bool enable_reset_;
  uint32_t num_reset_deques_;
  static const uint32_t NO_PIVOT = 9;  
  DequeTuple deques_;
  uint32_t num_non_empty_deques_;
  VectorTuple past_;
  Tuple candidate_;    ros::Time candidate_start_;
  ros::Time candidate_end_;
  ros::Time pivot_time_;
  uint32_t pivot_;    boost::mutex data_mutex_;  
  ros::Duration max_interval_duration_;   double age_penalty_;
  std::vector&lt;bool&gt; has_dropped_messages_;
  std::vector&lt;ros::Duration&gt; inter_message_lower_bounds_;
  std::vector&lt;bool&gt; warned_about_incorrect_bound_;
  std::vector&lt;ros::Time&gt; last_stamps_;
};
} } 
#endif 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_socket.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "xmlrpcpp/XmlRpcUtil.h"
#include "xmlrpcpp/XmlRpcSocket.h"
#include "test_system_mocks.h"
#include &lt;arpa/inet.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;deque&gt;
#include &lt;gtest/gtest.h&gt;
#define FOR_ERRNO(itr, var, ...)                                               \
  int var[] = {__VA_ARGS__};                                                   \
  for (size_t itr = 0; itr &lt; sizeof(var) / sizeof(int); itr++)
using XmlRpc::XmlRpcSocket;
class XmlRpcSocketTest : public ::testing::Test {
protected:
  void SetUp() {
    accept_calls = 0;
    bind_calls = 0;
    close_calls = 0;
    connect_calls = 0;
    fcntl_calls = 0;
    listen_calls = 0;
    read_calls = 0;
    select_calls = 0;
    socket_calls = 0;
    write_calls = 0;
    XmlRpc::setVerbosity(5);
    XmlRpcSocket::s_use_ipv6_ = false;
  }
  void TearDown() {
    fake_accept = 0;
    fake_bind = 0;
    fake_close = 0;
    fake_connect = 0;
    fake_fcntl = 0;
    fake_listen = 0;
    fake_read = 0;
    fake_select = 0;
    fake_socket = 0;
    fake_write = 0;
  }
};
TEST_F(XmlRpcSocketTest, TestMocks) {
  EXPECT_EQ(0, fake_accept);
  EXPECT_EQ(0, accept_calls);
  fake_accept = count_accept;
  EXPECT_EQ(0, accept(0, 0, 0));
  EXPECT_EQ(1, accept_calls);
  EXPECT_EQ(0, fake_bind);
  EXPECT_EQ(0, bind_calls);
  fake_bind = count_bind;
  EXPECT_EQ(0, bind(0, 0, 0));
  EXPECT_EQ(1, bind_calls);
  EXPECT_EQ(0, fake_close);
  EXPECT_EQ(0, close_calls);
  fake_close = count_close;
  EXPECT_EQ(0, close(-1));
  EXPECT_EQ(1, close_calls);
  EXPECT_EQ(0, fake_connect);
  EXPECT_EQ(0, connect_calls);
  fake_connect = count_connect;
  EXPECT_EQ(0, connect(0, 0, 0));
  EXPECT_EQ(1, connect_calls);
  EXPECT_EQ(0, fake_fcntl);
  EXPECT_EQ(0, fcntl_calls);
  fake_fcntl = count_fcntl;
  EXPECT_EQ(0, fcntl(0, 0, 0));
  EXPECT_EQ(1, fcntl_calls);
  EXPECT_EQ(0, fake_freeaddrinfo);
  EXPECT_EQ(0, freeaddrinfo_calls);
  fake_freeaddrinfo = count_freeaddrinfo;
  freeaddrinfo(0);
  EXPECT_EQ(1, freeaddrinfo_calls);
  EXPECT_EQ(0, fake_getaddrinfo);
  EXPECT_EQ(0, getaddrinfo_calls);
  fake_getaddrinfo = count_getaddrinfo;
  EXPECT_EQ(0, getaddrinfo(0, 0, 0, 0));
  EXPECT_EQ(1, getaddrinfo_calls);
  EXPECT_EQ(0, fake_getsockname);
  EXPECT_EQ(0, getsockname_calls);
  fake_getsockname = count_getsockname;
  EXPECT_EQ(0, getsockname(0, 0, 0));
  EXPECT_EQ(1, getsockname_calls);
  EXPECT_EQ(0, fake_listen);
  EXPECT_EQ(0, listen_calls);
  fake_listen = count_listen;
  EXPECT_EQ(0, listen(0, 0));
  EXPECT_EQ(1, listen_calls);
  EXPECT_EQ(0, fake_read);
  EXPECT_EQ(0, read_calls);
  fake_read = count_read;
  EXPECT_EQ(0, read(0, 0, 0));
  EXPECT_EQ(1, read_calls);
  EXPECT_EQ(0, fake_setsockopt);
  EXPECT_EQ(0, setsockopt_calls);
  fake_setsockopt = count_setsockopt;
  EXPECT_EQ(0, setsockopt(0, 0, 0, 0, 0));
  EXPECT_EQ(1, setsockopt_calls);
  EXPECT_EQ(0, fake_select);
  EXPECT_EQ(0, select_calls);
  fake_select = count_select;
  EXPECT_EQ(0, select(0, 0, 0, 0, 0));
  EXPECT_EQ(1, select_calls);
  EXPECT_EQ(0, fake_socket);
  EXPECT_EQ(0, socket_calls);
  fake_socket = count_socket;
  EXPECT_EQ(0, socket(0, 0, 0));
  EXPECT_EQ(1, socket_calls);
  EXPECT_EQ(0, fake_write);
  EXPECT_EQ(0, write_calls);
  fake_write = count_write;
  EXPECT_EQ(0, write(0, 0, 0));
  EXPECT_EQ(1, write_calls);
}
int socket_ret = 0;
int socket_errno = 0;
int socket_domain = 0;
int socket_type = 0;
int socket_protocol = 0;
int test_socket(int domain, int type, int protocol) {
  socket_domain = domain;
  socket_type = type;
  socket_protocol = protocol;
  socket_calls++;
  errno = socket_errno;
  return socket_ret;
}
TEST_F(XmlRpcSocketTest, socket) {
  fake_socket = test_socket;
  errno = 0;
  EXPECT_EQ(0, errno);
  socket_ret = 7;
  socket_errno = 0;
  socket_calls = 0;
  EXPECT_EQ(7, XmlRpcSocket::socket());
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, socket_calls);
  EXPECT_EQ(AF_INET, socket_domain);
  EXPECT_EQ(SOCK_STREAM, socket_type);
  EXPECT_EQ(0, socket_protocol);
  FOR_ERRNO(i,
            errnos,
            EACCES,
            EAFNOSUPPORT,
            EINVAL,
            EMFILE,
            ENFILE,
            ENOBUFS,
            ENOMEM,
            EPROTONOSUPPORT) {
    socket_ret = -1;
    socket_errno = errnos[i];
    socket_calls = 0;
    EXPECT_EQ(-1, XmlRpcSocket::socket());
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, socket_calls);
    EXPECT_EQ(AF_INET, socket_domain);
    EXPECT_EQ(SOCK_STREAM, socket_type);
    EXPECT_EQ(0, socket_protocol);
  }
}
int close_fd = 0;
int close_errno = 0;
int close_ret = 0;
int test_close(int fd) {
  EXPECT_EQ(close_fd, fd);
  close_calls++;
  errno = close_errno;
  return close_ret;
}
TEST_F(XmlRpcSocketTest, close) {
  close_fd = 8;
  close_errno = 0;
  close_ret = 0;
  close_calls = 0;
  fake_close = test_close;
  XmlRpcSocket::close(8);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, close_calls);
  FOR_ERRNO(i, errnos, EBADF, EINTR, EIO) {
    close_errno = errnos[i];
    close_ret = -1;
    close_calls = 0;
    XmlRpcSocket::close(8);
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, close_calls);
  }
}
int fcntl_fd = 0;
int fcntl_cmd = 0;
unsigned long fcntl_arg = 0;
int fcntl_errno = 0;
int fcntl_ret = 0;
int test_fcntl(int fd, int cmd, unsigned long arg) {
  EXPECT_EQ(fcntl_fd, fd);
  EXPECT_EQ(fcntl_cmd, cmd);
  EXPECT_EQ(fcntl_arg, arg);
  errno = fcntl_errno;
  fcntl_calls++;
  return fcntl_ret;
}
TEST_F(XmlRpcSocketTest, setNonBlocking) {
  fake_fcntl = test_fcntl;
  fcntl_fd = 9;
  fcntl_cmd = F_SETFL;
  fcntl_arg = O_NONBLOCK;
  fcntl_calls = 0;
  fcntl_errno = 0;
  fcntl_ret = 0;
  EXPECT_TRUE(XmlRpcSocket::setNonBlocking(9));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, fcntl_calls);
  FOR_ERRNO(i, errnos, EACCES, EAGAIN, EBADF) {
    fcntl_calls = 0;
    fcntl_errno = errnos[i];
    fcntl_ret = -1;
    EXPECT_FALSE(XmlRpcSocket::setNonBlocking(9));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, fcntl_calls);
  }
}
struct expected_read {
  expected_read(int fd, const void* buf, size_t sz)
    : fd(fd), count(4095), buf(buf), sz(sz), ret(sz), _errno(0) {}
  expected_read(int fd, int _errno)
    : fd(fd), count(4095), buf(0), sz(0), ret(-1), _errno(_errno) {}
  int fd;
  size_t count;
  const void* buf;
  size_t sz;
  ssize_t ret;
  int _errno;
};
std::deque&lt;expected_read&gt; expected_reads;
ssize_t mock_read(int fd, void* buf, size_t count) {
  read_calls++;
  EXPECT_LE(1u, expected_reads.size());
  if (expected_reads.size() &lt; 1) {
    errno = 0;
    return 0;
  }
  expected_read r = expected_reads.front();
  expected_reads.pop_front();
  EXPECT_EQ(r.fd, fd);
  EXPECT_EQ(r.count, count);
  EXPECT_GT(static_cast&lt;size_t&gt;(SSIZE_MAX), count);
  EXPECT_LE(r.sz, count);
  size_t cnt = std::min(count, r.sz);
  if (cnt &gt; 0) {
    memcpy(buf, r.buf, cnt);
  }
  if (r.ret &gt;= 0) {
    EXPECT_EQ(cnt, static_cast&lt;size_t&gt;(r.ret));
  }
  errno = r._errno;
  return r.ret;
}
TEST_F(XmlRpcSocketTest, nbRead) {
  fake_read = mock_read;
  const char data[] = "read1 read2 read3 read4 read5 read6 read7 read8";
  bool eof = false;
  std::string data_out;
  expected_reads.push_back(expected_read(7, data, 9));
  expected_reads.push_back(expected_read(7, 0, 0));
  EXPECT_TRUE(XmlRpcSocket::nbRead(7, data_out, &amp;eof));
  EXPECT_EQ("read1 rea", data_out);
  EXPECT_TRUE(eof);
  EXPECT_EQ(2, read_calls);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(0u, expected_reads.size());
  expected_reads.clear();
}
#define TEST_READ(RES, ERR)                                                    \
  TEST_F(XmlRpcSocketTest, nbRead_##ERR) {                                     \
    fake_read = mock_read;                                                     \
    bool eof = false;                                                          \
    std::string data_out;                                                      \
                                                                               \
    expected_reads.push_back(expected_read(7, ERR));                           \
                                                                               \
    EXPECT_##RES(XmlRpcSocket::nbRead(7, data_out, &amp;eof));                     \
    EXPECT_EQ("", data_out);                                                   \
    EXPECT_FALSE(eof);                                                         \
    EXPECT_EQ(1, read_calls);                                                  \
    EXPECT_EQ(ERR, XmlRpcSocket::getError());                                  \
    EXPECT_EQ(0u, expected_reads.size());                                       \
    expected_reads.clear();                                                    \
  }
TEST_READ(TRUE, EAGAIN);
TEST_READ(TRUE, EWOULDBLOCK);
TEST_F(XmlRpcSocketTest, nbRead_EINTR) {
  fake_read = mock_read;
  bool eof = false;
  std::string data_out;
  expected_reads.push_back(expected_read(7, EINTR));
  EXPECT_TRUE(XmlRpcSocket::nbRead(7, data_out, &amp;eof));
  EXPECT_EQ("", data_out);
  EXPECT_FALSE(eof);
  EXPECT_EQ(1, read_calls);
  EXPECT_EQ(EINTR, XmlRpcSocket::getError());
}
TEST_READ(FALSE, EBADF);
TEST_READ(FALSE, EFAULT);
TEST_READ(FALSE, EINVAL);
TEST_READ(FALSE, EIO);
TEST_READ(FALSE, EISDIR);
TEST_READ(FALSE, EACCES);
TEST_READ(FALSE, ECONNREFUSED);
TEST_READ(FALSE, ENOMEM);
TEST_READ(FALSE, ENOTCONN);
struct expected_write {
  expected_write(int fd, std::string data, size_t count, size_t max_write)
    : fd(fd),
      data(data),
      count(count),
      max_write(max_write),
      ret(std::min(count, max_write)),
      _errno(0) {}
  expected_write(int fd, size_t count, ssize_t ret, int _errno)
    : fd(fd), data(""), count(count), max_write(0), ret(ret), _errno(_errno) {}
  int fd;
  std::string data;
  size_t count;
  size_t max_write;
  ssize_t ret;
  int _errno;
};
std::deque&lt;expected_write&gt; expected_writes;
ssize_t mock_write(int fd, const void* buf, size_t count) {
  write_calls++;
  EXPECT_LE(1u, expected_writes.size());
  if (expected_writes.size() &lt; 1) {
    errno = EWOULDBLOCK;
    return -1;
  }
  expected_write w = expected_writes.front();
  expected_writes.pop_front();
  EXPECT_EQ(w.fd, fd);
  EXPECT_EQ(w.count, count);
  size_t sz = std::min(w.max_write, count);
  if (sz &gt; 0) {
    std::string data((const char*)buf, sz);
    EXPECT_EQ(w.data, data);
    EXPECT_GE(w.ret, 0u);
    EXPECT_EQ(static_cast&lt;size_t&gt;(w.ret), sz);
  }
  errno = w._errno;
  return w.ret;
}
TEST_F(XmlRpcSocketTest, nbWrite) {
  fake_write = mock_write;
  int count = 0;
  std::string hello = "hello world";
  expected_writes.push_back(expected_write(10, "hello world", 11, 11));
  count = 0;
  write_calls = 0;
  errno = 0;
  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
  EXPECT_EQ(count, 11);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(0u, expected_writes.size());
  EXPECT_EQ(1, write_calls);
  expected_writes.push_back(expected_write(10, "hello", 11, 5));
  expected_writes.push_back(expected_write(10, " world", 6, 10));
  count = 0;
  write_calls = 0;
  errno = 0;
  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
  EXPECT_EQ(count, 11);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(0u, expected_writes.size());
  EXPECT_EQ(2, write_calls);
  count = 0;
  write_calls = 0;
  errno = 0;
  expected_writes.push_back(expected_write(10, "hello", 11, 5));
  expected_writes.push_back(expected_write(10, 6, -1, EWOULDBLOCK));
  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
  EXPECT_EQ(count, 5);
  EXPECT_EQ(EWOULDBLOCK, XmlRpcSocket::getError());
  EXPECT_EQ(0u, expected_writes.size());
  EXPECT_EQ(2, write_calls);
}
#define TEST_WRITE(RES, ERR)                                                   \
  TEST_F(XmlRpcSocketTest, nbWrite_##ERR) {                                    \
    fake_write = mock_write;                                                   \
    int count = 0;                                                             \
    std::string hello = "hello world";                                         \
    errno = 0;                                                                 \
    expected_writes.push_back(expected_write(10, 11, -1, ERR));                \
    EXPECT_##RES(XmlRpcSocket::nbWrite(10, hello, &amp;count));                    \
    EXPECT_EQ(count, 0);                                                       \
    EXPECT_EQ(ERR, XmlRpcSocket::getError());                                  \
    EXPECT_EQ(0u, expected_writes.size());                                     \
    EXPECT_EQ(1, write_calls);                                                 \
    expected_writes.clear();                                                   \
  }
TEST_WRITE(TRUE, EAGAIN);
TEST_WRITE(TRUE, EWOULDBLOCK);
TEST_WRITE(TRUE, EINTR); TEST_WRITE(FALSE, EBADF);
TEST_WRITE(FALSE, EDESTADDRREQ);
TEST_WRITE(FALSE, EDQUOT);
TEST_WRITE(FALSE, EFAULT);
TEST_WRITE(FALSE, EFBIG);
TEST_WRITE(FALSE, EINVAL);
TEST_WRITE(FALSE, EIO);
TEST_WRITE(FALSE, ENOSPC);
TEST_WRITE(FALSE, EPIPE);
TEST_WRITE(FALSE, EACCES);
TEST_WRITE(FALSE, ECONNRESET);
TEST_WRITE(FALSE, EISCONN);
TEST_WRITE(FALSE, ENOBUFS);
TEST_WRITE(FALSE, ENOMEM);
TEST_WRITE(FALSE, ENOTCONN);
int setsockopt_ret = 0;
int setsockopt_errno = 0;
int setsockopt_sockfd = 0;
int test_setsockopt(
    int sockfd, int level, int optname, const void* optval, socklen_t optlen) {
  setsockopt_calls++;
  setsockopt_sockfd = sockfd;
  EXPECT_EQ(SOL_SOCKET, level);
  EXPECT_EQ(SO_REUSEADDR, optname);
  EXPECT_EQ(sizeof(int), optlen);
  if (sizeof(int) == optlen) {
    EXPECT_EQ(1, *(int*)optval);
  }
  errno = setsockopt_errno;
  return setsockopt_ret;
}
TEST_F(XmlRpcSocketTest, setReuseAddr) {
  fake_setsockopt = test_setsockopt;
  errno = 0;
  setsockopt_sockfd = 0;
  setsockopt_calls = 0;
  setsockopt_errno = 0;
  setsockopt_ret = 0;
  EXPECT_TRUE(XmlRpcSocket::setReuseAddr(11));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(11, setsockopt_sockfd);
  EXPECT_EQ(1, setsockopt_calls);
  FOR_ERRNO(i, errnos, EBADF, EFAULT, EINVAL, ENOPROTOOPT, ENOTSOCK) {
    errno = 0;
    setsockopt_sockfd = 0;
    setsockopt_calls = 0;
    setsockopt_errno = errnos[i];
    setsockopt_ret = -1;
    EXPECT_FALSE(XmlRpcSocket::setReuseAddr(11));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(11, setsockopt_sockfd);
    EXPECT_EQ(1, setsockopt_calls);
  }
}
bool operator==(const in6_addr a, const in6_addr b) {
  return IN6_ARE_ADDR_EQUAL(&amp;a, &amp;b);
}
int bind_ret = 0;
int bind_errno = 0;
int bind_sockfd = 0;
int bind_family = 0;
int bind_port = 0;
int test_bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen) {
  bind_calls++;
  EXPECT_EQ(bind_sockfd, sockfd);
  EXPECT_TRUE(NULL != addr);
  if (NULL != addr) {
    EXPECT_EQ(bind_family, addr-&gt;sa_family);
    if (AF_INET == addr-&gt;sa_family) {
      EXPECT_EQ(sizeof(struct sockaddr_in), addrlen);
      struct sockaddr_in* in_addr = (struct sockaddr_in*)addr;
      EXPECT_EQ(INADDR_ANY, ntohl(in_addr-&gt;sin_addr.s_addr));
      EXPECT_EQ(bind_port, ntohs(in_addr-&gt;sin_port));
    } else if (AF_INET6 == addr-&gt;sa_family) {
      EXPECT_EQ(sizeof(struct sockaddr_in6), addrlen);
      struct sockaddr_in6* in6_addr = (struct sockaddr_in6*)addr;
      EXPECT_EQ(in6addr_any, in6_addr-&gt;sin6_addr);
      EXPECT_EQ(bind_port, ntohs(in6_addr-&gt;sin6_port));
    } else {
      ADD_FAILURE() &lt;&lt; "Unrecognized sockaddr family";
    }
  }
  errno = bind_errno;
  return bind_ret;
}
TEST_F(XmlRpcSocketTest, bind) {
  fake_bind = test_bind;
  bind_sockfd = 12;
  bind_family = AF_INET;
  bind_port = 22;
  bind_calls = 0;
  bind_errno = 0;
  bind_ret = 0;
  EXPECT_TRUE(XmlRpcSocket::bind(12, 22));
  EXPECT_EQ(1, bind_calls);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  FOR_ERRNO(i, errnos, EACCES, EADDRINUSE, EBADF, EINVAL, ENOTSOCK) {
    bind_calls = 0;
    bind_family = AF_INET;
    bind_port = 22;
    bind_errno = errnos[i];
    bind_ret = -1;
    EXPECT_FALSE(XmlRpcSocket::bind(12, 22));
    EXPECT_EQ(1, bind_calls);
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
  }
  XmlRpcSocket::s_use_ipv6_ = true;
  bind_calls = 0;
  bind_family = AF_INET6;
  bind_port = 22;
  bind_errno = 0;
  bind_ret = 0;
  EXPECT_TRUE(XmlRpcSocket::bind(12, 22));
  EXPECT_EQ(1, bind_calls);
  EXPECT_EQ(0, XmlRpcSocket::getError());
}
int getsockname_ret = 0;
int getsockname_errno = 0;
int getsockname_sockfd = 0;
void* getsockname_addr = 0;
socklen_t getsockname_len = 0;
int test_getsockname(int sockfd, struct sockaddr* addr, socklen_t* addrlen) {
  getsockname_calls++;
  EXPECT_EQ(getsockname_sockfd, sockfd);
  EXPECT_TRUE(NULL != addr);
  EXPECT_LE(getsockname_len, *addrlen);
  if (NULL != addr) {
    socklen_t len = std::min(*addrlen, getsockname_len);
    if (len &gt; 0)
      memcpy(addr, getsockname_addr, len);
  }
  EXPECT_TRUE(NULL != addrlen);
  if (NULL != addrlen) {
    *addrlen = getsockname_len;
  }
  errno = getsockname_errno;
  return getsockname_ret;
}
TEST_F(XmlRpcSocketTest, get_port) {
  fake_getsockname = test_getsockname;
  struct sockaddr_in inet_addr;
  inet_addr.sin_family = AF_INET;
  inet_addr.sin_port = htons(123);
  struct sockaddr_in6 inet6_addr;
  inet6_addr.sin6_family = AF_INET6;
  inet6_addr.sin6_port = htons(4224);
  getsockname_sockfd = 14;
  getsockname_errno = 0;
  getsockname_ret = 0;
  getsockname_calls = 0;
  getsockname_addr = &amp;inet_addr;
  getsockname_len = sizeof(struct sockaddr_in);
  EXPECT_EQ(123, XmlRpcSocket::get_port(14));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, getsockname_calls);
  getsockname_calls = 0;
  getsockname_addr = &amp;inet6_addr;
  getsockname_len = sizeof(struct sockaddr_in6);
  EXPECT_EQ(4224, XmlRpcSocket::get_port(14));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, getsockname_calls);
  getsockname_ret = -1;
  FOR_ERRNO(i, errnos, EBADF, EFAULT, EINVAL, ENOBUFS, ENOTSOCK) {
    getsockname_errno = errnos[i];
    getsockname_calls = 0;
    getsockname_addr = NULL;
    getsockname_len = 0;
    EXPECT_EQ(0, XmlRpcSocket::get_port(14));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, getsockname_calls);
    getsockname_calls = 0;
    getsockname_addr = &amp;inet_addr;
    getsockname_len = sizeof(struct sockaddr_in);
    EXPECT_EQ(0, XmlRpcSocket::get_port(14));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, getsockname_calls);
  }
}
int listen_ret = 0;
int listen_errno = 0;
int listen_sockfd = 0;
int listen_backlog = 0;
int test_listen(int sockfd, int backlog) {
  EXPECT_EQ(listen_sockfd, sockfd);
  EXPECT_EQ(listen_backlog, backlog);
  errno = listen_errno;
  return listen_ret;
}
TEST_F(XmlRpcSocketTest, listen) {
  fake_listen = test_listen;
  listen_sockfd = 13;
  listen_backlog = 10;
  listen_ret = 0;
  listen_errno = 0;
  EXPECT_TRUE(XmlRpcSocket::listen(13, 10));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  FOR_ERRNO(i, errnos, EADDRINUSE, EBADF, ENOTSOCK, EOPNOTSUPP) {
    listen_ret = -1;
    listen_errno = errnos[i];
    EXPECT_FALSE(XmlRpcSocket::listen(13, 10));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
  }
}
int accept_ret = 0;
int accept_errno = 0;
int accept_sockfd = 0;
void* accept_addr = 0;
socklen_t accept_addrlen = 0;
int test_accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen) {
  accept_calls++;
  EXPECT_EQ(accept_sockfd, sockfd);
  if (accept_addr) {
    EXPECT_TRUE(NULL != addr);
    EXPECT_TRUE(NULL != addrlen);
    if (NULL != addr &amp;&amp; NULL != addrlen) {
      socklen_t len = std::min(accept_addrlen, *addrlen);
      memcpy(addr, accept_addr, len);
      *addrlen = accept_addrlen;
    }
  } else {
    EXPECT_EQ(NULL, addr);
    EXPECT_EQ(NULL, addrlen);
  }
  errno = accept_errno;
  return accept_ret;
}
TEST_F(XmlRpcSocketTest, accept) {
  fake_accept = test_accept;
  struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_port = htons(45);
  addr.sin_addr.s_addr = 0xDEADBEEF;
  accept_addr = &amp;addr;
  accept_addrlen = sizeof(struct sockaddr);
  accept_sockfd = 15;
  accept_calls = 0;
  accept_ret = 16;
  accept_errno = 0;
  EXPECT_EQ(16, XmlRpcSocket::accept(15));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, accept_calls);
  FOR_ERRNO(i,
            errnos,
            EAGAIN,
            EWOULDBLOCK,
            EBADF,
            ECONNABORTED,
            EFAULT,
            EINTR,             EINVAL,
            EMFILE,
            ENFILE,
            ENOBUFS,
            ENOMEM,
            ENOTSOCK,
            EOPNOTSUPP,
            EPROTO,
            EPERM) {
    accept_calls = 0;
    accept_ret = -1;
    accept_errno = errnos[i];
    EXPECT_EQ(-1, XmlRpcSocket::accept(15));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, accept_calls);
  }
}
int getaddrinfo_ret = 0;
int getaddrinfo_errno = 0;
const char* getaddrinfo_node = 0;
const char* getaddrinfo_service = 0;
struct addrinfo getaddrinfo_hints = {.ai_flags = 0,
                                     .ai_family = 0,
                                     .ai_socktype = 0,
                                     .ai_protocol = 0,
                                     .ai_addrlen = 0,
                                     .ai_addr = 0,
                                     .ai_canonname = 0,
                                     .ai_next = 0};
struct addrinfo* getaddrinfo_res = 0;
int test_getaddrinfo(const char* node,
                     const char* service,
                     const struct addrinfo* hints,
                     struct addrinfo** res) {
  getaddrinfo_calls++;
  EXPECT_STREQ(getaddrinfo_node, node);
  EXPECT_STREQ(getaddrinfo_service, service);
  EXPECT_TRUE(NULL != hints);
  if (NULL != hints) {
    EXPECT_TRUE(memcmp(hints, &amp;getaddrinfo_hints, sizeof(struct addrinfo)) ==
                0);
  }
  EXPECT_TRUE(NULL != res);
  if (NULL != res) {
    *res = getaddrinfo_res;
  }
  errno = getaddrinfo_errno;
  return getaddrinfo_ret;
}
struct addrinfo* freeaddrinfo_res = 0;
void test_freeaddrinfo(struct addrinfo* res) {
  freeaddrinfo_calls++;
  EXPECT_EQ(freeaddrinfo_res, res);
  return;
}
void EXPECT_SOCKADDR_EQ(const sockaddr* addr1, const sockaddr* addr2) {
  EXPECT_EQ((NULL == addr1), (NULL == addr2));
  if (NULL != addr1 &amp;&amp; NULL != addr2) {
    EXPECT_EQ(addr1-&gt;sa_family, addr2-&gt;sa_family);
    if (addr1-&gt;sa_family == addr2-&gt;sa_family) {
      switch (addr1-&gt;sa_family) {
      case AF_INET: {
        const sockaddr_in* addr1_in = (const sockaddr_in*)addr1;
        const sockaddr_in* addr2_in = (const sockaddr_in*)addr2;
        EXPECT_EQ(addr1_in-&gt;sin_port, addr2_in-&gt;sin_port);
        EXPECT_EQ(addr1_in-&gt;sin_addr.s_addr, addr2_in-&gt;sin_addr.s_addr);
      } break;
      case AF_INET6: {
        const sockaddr_in6* addr1_in6 = (const sockaddr_in6*)addr1;
        const sockaddr_in6* addr2_in6 = (const sockaddr_in6*)addr2;
        EXPECT_EQ(addr1_in6-&gt;sin6_port, addr2_in6-&gt;sin6_port);
        EXPECT_EQ(addr1_in6-&gt;sin6_flowinfo, addr2_in6-&gt;sin6_flowinfo);
        EXPECT_EQ(addr1_in6-&gt;sin6_scope_id, addr2_in6-&gt;sin6_scope_id);
        EXPECT_TRUE(
            IN6_ARE_ADDR_EQUAL(&amp;addr1_in6-&gt;sin6_addr, &amp;addr2_in6-&gt;sin6_addr));
        for (int i = 0; i &lt; 16; i++) {
          EXPECT_EQ(addr1_in6-&gt;sin6_addr.s6_addr[i],
                    addr2_in6-&gt;sin6_addr.s6_addr[i])
              &lt;&lt; "IPv6 address mismstach at byte " &lt;&lt; i;
        }
      } break;
      default:
        ADD_FAILURE() &lt;&lt; "Unrecognized address type; cannot compare";
      }
    }
  }
}
int connect_ret = 0;
int connect_errno = 0;
int connect_sockfd = 0;
const struct sockaddr* connect_addr = 0;
socklen_t connect_addrlen = 0;
int test_connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen) {
  connect_calls++;
  EXPECT_EQ(connect_sockfd, sockfd);
  EXPECT_TRUE(NULL != addr);
  EXPECT_EQ(connect_addrlen, addrlen);
  EXPECT_SOCKADDR_EQ(connect_addr, addr);
  errno = connect_errno;
  return connect_ret;
}
class XmlRpcConnectTest : public XmlRpcSocketTest,
                          XmlRpc::XmlRpcLogHandler,
                          XmlRpc::XmlRpcErrorHandler {
public:
  virtual void log(int level, const char* msg) {
    last_level = level;
    last_msg = msg;
    std::cout &lt;&lt; "LOG(" &lt;&lt; level &lt;&lt; "):" &lt;&lt; msg;
  }
  virtual void error(const char* msg) {
    last_error = msg;
    std::cout &lt;&lt; "ERROR: " &lt;&lt; msg;
  }
  int last_level;
  std::string last_msg;
  std::string last_error;
  void EXPECT_LOG(int level, const std::string&amp; msg) {
    EXPECT_EQ(level, last_level);
    EXPECT_EQ(msg, last_msg);
  }
  void EXPECT_ERROR(const std::string&amp; msg) {
    EXPECT_EQ(msg, last_error);
  }
protected:
  void SetUp() {
    XmlRpcSocketTest::SetUp();
    fake_getaddrinfo = test_getaddrinfo;
    fake_freeaddrinfo = test_freeaddrinfo;
    fake_connect = test_connect;
    XmlRpc::XmlRpcLogHandler::setLogHandler(this);
<a name="0"></a>    XmlRpc::XmlRpcErrorHandler::setErrorHandler(this);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    addr_ip4_22.sin_family = AF_INET;
    addr_ip4_22.sin_port = htons(22);
    addr_ip4_22.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr_ip4_404.sin_family = AF_INET;
    addr_ip4_404.sin_port = htons(404);
    addr_ip4_404.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr_ip6_44.sin6_family = AF_INET6;
    addr_ip6_44.sin6_port = htons(44);
    addr_ip6_44.sin6_flowinfo = 0;
    addr_ip6_44.sin6_addr = in6addr_loopback;
    addr_ip6_44.sin6_scope_id = 0;
    addr_ip6_404.sin6_family = AF_INET6;
    addr_ip6_404.sin6_port = htons(404);
    addr_ip6_404.sin6_flowinfo = 0;
    addr_ip6_404.sin6_addr = in6addr_loopback;
    addr_ip6_404.sin6_scope_id = 0;
    info_ip4.ai_flags = 0;</b></font>
    info_ip4.ai_family = AF_INET;
    info_ip4.ai_socktype = SOCK_STREAM;
    info_ip4.ai_protocol = 0;
    info_ip4.ai_addrlen = sizeof(struct sockaddr_in);
    info_ip4.ai_addr = (struct sockaddr*)&amp;addr_ip4_22;
    info_ip4.ai_canonname = 0;
    info_ip4.ai_next = 0;
    info_ip6.ai_flags = 0;
    info_ip6.ai_family = AF_INET6;
    info_ip6.ai_socktype = SOCK_STREAM;
    info_ip6.ai_protocol = 0;
    info_ip6.ai_addrlen = sizeof(struct sockaddr_in6);
    info_ip6.ai_addr = (struct sockaddr*)&amp;addr_ip6_44;
    info_ip6.ai_canonname = 0;
    info_ip6.ai_next = 0;
    info_canon.ai_flags = 0;
    info_canon.ai_family = 0;
    info_canon.ai_socktype = 0;
    info_canon.ai_protocol = 0;
    info_canon.ai_addrlen = 0;
    info_canon.ai_addr = 0;
    info_canon.ai_canonname = 0;
    info_canon.ai_next = 0;
    getaddrinfo_hints.ai_family = AF_UNSPEC;
    getaddrinfo_node = "nowhere.com";
    getaddrinfo_service = 0;
    connect_sockfd = 19;
  }
  void TestConnect() {
    freeaddrinfo_res = getaddrinfo_res;
    last_level = 0;
    last_msg = "";
    last_error = "";
    getaddrinfo_calls = 0;
    freeaddrinfo_calls = 0;
    connect_calls = 0;
    EXPECT_TRUE(XmlRpcSocket::connect(19, "nowhere.com", 404));
    EXPECT_EQ(1, getaddrinfo_calls);
    EXPECT_EQ(1, freeaddrinfo_calls);
    EXPECT_EQ(1, connect_calls);
  }
  void TestLookupFail() {
    freeaddrinfo_res = getaddrinfo_res;
    last_level = 0;
    last_msg = "";
    last_error = "";
    getaddrinfo_calls = 0;
    freeaddrinfo_calls = 0;
    connect_calls = 0;
    EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
    EXPECT_EQ(1, getaddrinfo_calls);
    EXPECT_EQ(0, freeaddrinfo_calls);
    EXPECT_EQ(0, connect_calls);
  }
  void TestConnectFail() {
    freeaddrinfo_res = getaddrinfo_res;
    last_level = 0;
    last_msg = "";
    last_error = "";
    getaddrinfo_calls = 0;
    freeaddrinfo_calls = 0;
    connect_calls = 0;
    EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
    EXPECT_EQ(1, getaddrinfo_calls);
    EXPECT_EQ(1, freeaddrinfo_calls);
    EXPECT_EQ(1, connect_calls);
  }
  void TearDown() {
    XmlRpcLogHandler::setLogHandler(NULL);
    XmlRpcErrorHandler::setErrorHandler(NULL);
    XmlRpcSocketTest::TearDown();
  }
  struct sockaddr_in addr_ip4_22;
  struct sockaddr_in addr_ip4_404;
  struct sockaddr_in6 addr_ip6_44;
  struct sockaddr_in6 addr_ip6_404;
  struct addrinfo info_ip4;
  struct addrinfo info_ip6;
  struct addrinfo info_canon;
};
TEST_F(XmlRpcConnectTest, connect_ipv4) {
  getaddrinfo_ret = 0;
  getaddrinfo_errno = 0;
  connect_ret = 0;
  connect_errno = 0;
  connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
  connect_addrlen = sizeof(struct sockaddr_in);
  getaddrinfo_res = &amp;info_canon;
  info_canon.ai_next = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;
  TestConnect();
  getaddrinfo_res = &amp;info_canon;
  info_canon.ai_next = &amp;info_ip6;
  info_ip6.ai_next = &amp;info_ip4;
  info_ip4.ai_next = 0;
  TestConnect();
  getaddrinfo_res = &amp;info_ip6;
  info_ip6.ai_next = &amp;info_ip4;
  info_ip4.ai_next = 0;
  TestConnect();
  getaddrinfo_res = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;
  TestConnect();
}
TEST_F(XmlRpcConnectTest, connect_ipv6) {
  XmlRpcSocket::s_use_ipv6_ = true;
  getaddrinfo_ret = 0;
  getaddrinfo_errno = 0;
  connect_ret = 0;
  connect_errno = 0;
  connect_addr = (struct sockaddr*)&amp;addr_ip6_404;
  connect_addrlen = sizeof(struct sockaddr_in6);
  getaddrinfo_res = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;
  TestConnect();
  getaddrinfo_res = &amp;info_ip6;
  info_ip6.ai_next = &amp;info_ip4;
  info_ip4.ai_next = 0;
  TestConnect();
}
TEST_F(XmlRpcConnectTest, connect_lookup_fail) {
  connect_ret = 0;
  connect_errno = 0;
  connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
  connect_addrlen = sizeof(struct sockaddr_in);
  getaddrinfo_res = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;
  FOR_ERRNO(i,
            addr_errs,
            EAI_ADDRFAMILY,
            EAI_AGAIN,
            EAI_BADFLAGS,
            EAI_FAIL,
            EAI_FAMILY,
            EAI_MEMORY,
            EAI_NODATA,
            EAI_NONAME,
            EAI_SERVICE,
            EAI_SOCKTYPE) {
    getaddrinfo_ret = addr_errs[i];
    getaddrinfo_errno = 0;
    TestLookupFail();
    EXPECT_ERROR(
        std::string("Couldn't find an AF_INET address for [nowhere.com]: ") +
        std::string(gai_strerror(addr_errs[i])) + std::string("\n"));
  }
  getaddrinfo_ret = EAI_SYSTEM;
  FOR_ERRNO(i, errnos, ENFILE, EMFILE, EAGAIN, EINTR) {
    getaddrinfo_errno = errnos[i];
    TestLookupFail();
    EXPECT_ERROR(
        std::string("Couldn't find an AF_INET address for [nowhere.com]: ") +
        std::string(strerror(errnos[i])) + std::string("\n"));
  }
  getaddrinfo_res = &amp;info_ip6;
  info_ip6.ai_next = 0;
  getaddrinfo_ret = 0;
  getaddrinfo_errno = 0;
  freeaddrinfo_res = getaddrinfo_res;
  last_level = 0;
  last_msg = "";
  last_error = "";
  getaddrinfo_calls = 0;
  freeaddrinfo_calls = 0;
  connect_calls = 0;
  EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
  EXPECT_EQ(1, getaddrinfo_calls);
  EXPECT_EQ(1, freeaddrinfo_calls);
  EXPECT_EQ(0, connect_calls);
  EXPECT_ERROR(
      std::string("Couldn't find an AF_INET address for [nowhere.com]") +
      std::string("\n"));
}
TEST_F(XmlRpcConnectTest, connect_multiple_result) {}
TEST_F(XmlRpcConnectTest, connect_failure) {
  getaddrinfo_ret = 0;
  getaddrinfo_errno = 0;
  connect_ret = 0;
  connect_errno = 0;
  connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
  connect_addrlen = sizeof(struct sockaddr_in);
  getaddrinfo_res = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;
  connect_ret = -1;
  connect_errno = EINPROGRESS;
  TestConnect();
  EXPECT_ERROR("");
  EXPECT_EQ(EWOULDBLOCK, EAGAIN);
  connect_ret = -1;
  connect_errno = EWOULDBLOCK;
#if defined(_WINDOWS)
  TestConnect();
  EXPECT_ERROR("");
#else
  TestConnectFail();
  EXPECT_ERROR(std::string("::connect error = ") +
               std::string(strerror(EWOULDBLOCK)) + std::string("\n"));
#endif
  FOR_ERRNO(i,
            errnos,
            EACCES,
            EPERM,
            EADDRINUSE,
            EAFNOSUPPORT,
            EALREADY,
            EBADF,
            ECONNREFUSED,
            EFAULT,
            EINTR,
            EISCONN,
            ENETUNREACH,
            ENOTSOCK,
            ETIMEDOUT) {
    connect_ret = -1;
    connect_errno = errnos[i];
    TestConnectFail();
    EXPECT_ERROR(std::string("::connect error = ") +
                 std::string(strerror(errnos[i])) + std::string("\n"));
  }
}
int main(int argc, char **argv)
{
  ::testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
