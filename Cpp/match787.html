<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for approximate_time.h &amp; test_socket.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for approximate_time.h &amp; test_socket.cpp
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>approximate_time.h (1.9274377%)<th>test_socket.cpp (1.7763846%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(135-151)<td><a href="#" name="0">(1035-1055)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>approximate_time.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef MESSAGE_FILTERS_SYNC_APPROXIMATE_TIME_H
2 #define MESSAGE_FILTERS_SYNC_APPROXIMATE_TIME_H
3 #include "message_filters/synchronizer.h"
4 #include "message_filters/connection.h"
5 #include "message_filters/null_types.h"
6 #include "message_filters/signal9.h"
7 #include &lt;boost/tuple/tuple.hpp&gt;
8 #include &lt;boost/shared_ptr.hpp&gt;
9 #include &lt;boost/function.hpp&gt;
10 #include &lt;boost/thread/mutex.hpp&gt;
11 #include &lt;boost/bind.hpp&gt;
12 #include &lt;boost/type_traits/is_same.hpp&gt;
13 #include &lt;boost/noncopyable.hpp&gt;
14 #include &lt;boost/mpl/or.hpp&gt;
15 #include &lt;boost/mpl/at.hpp&gt;
16 #include &lt;boost/mpl/vector.hpp&gt;
17 #include &lt;ros/assert.h&gt;
18 #include &lt;ros/message_traits.h&gt;
19 #include &lt;ros/message_event.h&gt;
20 #include &lt;deque&gt;
21 #include &lt;vector&gt;
22 #include &lt;string&gt;
23 namespace message_filters
24 {
25 namespace sync_policies
26 {
27 namespace mpl = boost::mpl;
28 template&lt;typename M0, typename M1, typename M2 = NullType, typename M3 = NullType, typename M4 = NullType,
29          typename M5 = NullType, typename M6 = NullType, typename M7 = NullType, typename M8 = NullType&gt;
30 struct ApproximateTime : public PolicyBase&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt;
31 {
32   typedef Synchronizer&lt;ApproximateTime&gt; Sync;
33   typedef PolicyBase&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt; Super;
34   typedef typename Super::Messages Messages;
35   typedef typename Super::Signal Signal;
36   typedef typename Super::Events Events;
37   typedef typename Super::RealTypeCount RealTypeCount;
38   typedef typename Super::M0Event M0Event;
39   typedef typename Super::M1Event M1Event;
40   typedef typename Super::M2Event M2Event;
41   typedef typename Super::M3Event M3Event;
42   typedef typename Super::M4Event M4Event;
43   typedef typename Super::M5Event M5Event;
44   typedef typename Super::M6Event M6Event;
45   typedef typename Super::M7Event M7Event;
46   typedef typename Super::M8Event M8Event;
47   typedef std::deque&lt;M0Event&gt; M0Deque;
48   typedef std::deque&lt;M1Event&gt; M1Deque;
49   typedef std::deque&lt;M2Event&gt; M2Deque;
50   typedef std::deque&lt;M3Event&gt; M3Deque;
51   typedef std::deque&lt;M4Event&gt; M4Deque;
52   typedef std::deque&lt;M5Event&gt; M5Deque;
53   typedef std::deque&lt;M6Event&gt; M6Deque;
54   typedef std::deque&lt;M7Event&gt; M7Deque;
55   typedef std::deque&lt;M8Event&gt; M8Deque;
56   typedef std::vector&lt;M0Event&gt; M0Vector;
57   typedef std::vector&lt;M1Event&gt; M1Vector;
58   typedef std::vector&lt;M2Event&gt; M2Vector;
59   typedef std::vector&lt;M3Event&gt; M3Vector;
60   typedef std::vector&lt;M4Event&gt; M4Vector;
61   typedef std::vector&lt;M5Event&gt; M5Vector;
62   typedef std::vector&lt;M6Event&gt; M6Vector;
63   typedef std::vector&lt;M7Event&gt; M7Vector;
64   typedef std::vector&lt;M8Event&gt; M8Vector;
65   typedef boost::tuple&lt;M0Event, M1Event, M2Event, M3Event, M4Event, M5Event, M6Event, M7Event, M8Event&gt; Tuple;
66   typedef boost::tuple&lt;M0Deque, M1Deque, M2Deque, M3Deque, M4Deque, M5Deque, M6Deque, M7Deque, M8Deque&gt; DequeTuple;
67   typedef boost::tuple&lt;M0Vector, M1Vector, M2Vector, M3Vector, M4Vector, M5Vector, M6Vector, M7Vector, M8Vector&gt; VectorTuple;
68   ApproximateTime(uint32_t queue_size)
69   : parent_(0)
70   , queue_size_(queue_size)
71   , enable_reset_(false)
72   , num_reset_deques_(0)
73   , num_non_empty_deques_(0)
74   , pivot_(NO_PIVOT)
75   , max_interval_duration_(ros::DURATION_MAX)
76   , age_penalty_(0.1)
77   , has_dropped_messages_(9, false)
78   , inter_message_lower_bounds_(9, ros::Duration(0))
79   , warned_about_incorrect_bound_(9, false)
80   , last_stamps_(9, ros::Time(0, 0))
81   {
82     ROS_ASSERT(queue_size_ &gt; 0);    }
83   ApproximateTime(const ApproximateTime&amp; e)
84   {
85     *this = e;
86   }
87 <a name="0"></a>
88   ApproximateTime&amp; operator=(const ApproximateTime&amp; rhs)
89   {
90 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    parent_ = rhs.parent_;
91     queue_size_ = rhs.queue_size_;
92     num_non_empty_deques_ = rhs.num_non_empty_deques_;
93     pivot_time_ = rhs.pivot_time_;
94     pivot_ = rhs.pivot_;
95     max_interval_duration_ = rhs.max_interval_duration_;
96     age_penalty_ = rhs.age_penalty_;
97     candidate_start_ = rhs.candidate_start_;
98     candidate_end_ = rhs.candidate_end_;
99     deques_ = rhs.deques_;
100     past_ = rhs.past_;
101     has_dropped_messages_ = rhs.has_dropped_messages_;
102     inter_message_lower_bounds_ = rhs.inter_message_lower_bounds_;
103     warned_about_incorrect_bound_ = rhs.warned_about_incorrect_bound_;
104     last_stamps_ = rhs.last_stamps_;
105     enable_reset_ = rhs.enable_reset_;
106     num_reset_deques_ = rhs.num_reset_deques_;</b></font>
107     return *this;
108   }
109   void initParent(Sync* parent)
110   {
111     parent_ = parent;
112   }
113   template&lt;int i&gt;
114   bool checkInterMessageBound()
115   {
116     namespace mt = ros::message_traits;
117     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
118     std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
119     ROS_ASSERT(!deque.empty());
120     const typename mpl::at_c&lt;Messages, i&gt;::type &amp;msg = *(deque.back()).getMessage();
121     ros::Time msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(msg);
122     ros::Time previous_msg_time;
123     bool check_ok = true;
124     if (deque.size() == (size_t) 1)
125     {
126       if (v.empty())
127       {
128         return check_ok;
129       }
130       const typename mpl::at_c&lt;Messages, i&gt;::type &amp;previous_msg = *(v.back()).getMessage();
131       previous_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(previous_msg);
132     }
133     else
134     {
135       const typename mpl::at_c&lt;Messages, i&gt;::type &amp;previous_msg = *(deque[deque.size()-2]).getMessage();
136       previous_msg_time =  mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(previous_msg);
137     }
138     if (msg_time &lt; previous_msg_time)
139     {
140       if (!warned_about_incorrect_bound_[i])
141         ROS_WARN_STREAM("Messages of type " &lt;&lt; i &lt;&lt; " arrived out of order (will print only once)");
142       warned_about_incorrect_bound_[i] = true;
143       check_ok = false;
144     }
145     else if ((msg_time - previous_msg_time) &lt; inter_message_lower_bounds_[i])
146     {
147       if (!warned_about_incorrect_bound_[i])
148         ROS_WARN_STREAM("Messages of type " &lt;&lt; i &lt;&lt; " arrived closer (" &lt;&lt; (msg_time - previous_msg_time)
149                         &lt;&lt; ") than the lower bound you provided (" &lt;&lt; inter_message_lower_bounds_[i]
150                         &lt;&lt; ") (will print only once)");
151       warned_about_incorrect_bound_[i] = true;
152       check_ok = false;
153     }
154     return check_ok;
155   }
156   template&lt;int i&gt;
157   void add(const typename mpl::at_c&lt;Events, i&gt;::type&amp; evt)
158   {
159     boost::mutex::scoped_lock lock(data_mutex_);
160     ros::Time now = evt.getReceiptTime();
161     if (ros::Time::isSimTime() &amp;&amp; enable_reset_)
162     {
163       if (now &lt; last_stamps_[i])
164       {
165         ++num_reset_deques_;
166         if (num_reset_deques_ == 1)
167         {
168           ROS_WARN("Detected jump back in time. Clearing message filter queues");
169         }
170         clearDeque&lt;i&gt;();
171         if (num_reset_deques_ &gt;= RealTypeCount::value)
172         {
173           num_reset_deques_ = 0;
174         }
175       }
176     }
177     last_stamps_[i] = now;
178     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
179     deque.push_back(evt);
180     if (deque.size() == (size_t)1) {
181       ++num_non_empty_deques_;
182       if (num_non_empty_deques_ == (uint32_t)RealTypeCount::value)
183       {
184         process();
185       }
186     }
187     else
188     {
189       if (!checkInterMessageBound&lt;i&gt;())
190         if (ros::Time::isSimTime() &amp;&amp; enable_reset_)
191         {
192           dequeDeleteFront&lt;i&gt;();
193         }
194     }
195     std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; past = boost::get&lt;i&gt;(past_);
196     if (deque.size() + past.size() &gt; queue_size_)
197     {
198       num_non_empty_deques_ = 0;       recover&lt;0&gt;();
199       recover&lt;1&gt;();
200       recover&lt;2&gt;();
201       recover&lt;3&gt;();
202       recover&lt;4&gt;();
203       recover&lt;5&gt;();
204       recover&lt;6&gt;();
205       recover&lt;7&gt;();
206       recover&lt;8&gt;();
207       ROS_ASSERT(!deque.empty());
208       deque.pop_front();
209       has_dropped_messages_[i] = true;
210       if (pivot_ != NO_PIVOT)
211       {
212 	candidate_ = Tuple();
213 	pivot_ = NO_PIVOT;
214 	process();
215       }
216     }
217   }
218   void setAgePenalty(double age_penalty)
219   {
220     ROS_ASSERT(age_penalty &gt;= 0);
221     age_penalty_ = age_penalty;
222   }
223   void setInterMessageLowerBound(int i, ros::Duration lower_bound) {
224     ROS_ASSERT(lower_bound &gt;= ros::Duration(0,0));
225     inter_message_lower_bounds_[i] = lower_bound;
226   }
227   void setInterMessageLowerBound(ros::Duration lower_bound) {
228     ROS_ASSERT(lower_bound &gt;= ros::Duration(0,0));
229     for (size_t i = 0; i &lt; inter_message_lower_bounds_.size(); i++)
230     {
231       inter_message_lower_bounds_[i] = lower_bound;
232     }
233   }
234   void setMaxIntervalDuration(ros::Duration max_interval_duration) {
235     ROS_ASSERT(max_interval_duration &gt;= ros::Duration(0,0));
236     max_interval_duration_ = max_interval_duration;
237   }
238   void setReset(const bool reset)
239   {
240     enable_reset_ = reset;
241   }
242 private:
243   template&lt;int i&gt;
244   void clearDeque()
245   {
246     num_non_empty_deques_ = 0;
247     recover&lt;0&gt;();
248     recover&lt;1&gt;();
249     recover&lt;2&gt;();
250     recover&lt;3&gt;();
251     recover&lt;4&gt;();
252     recover&lt;5&gt;();
253     recover&lt;6&gt;();
254     recover&lt;7&gt;();
255     recover&lt;8&gt;();
256     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
257     if (!q.empty())
258     {
259       --num_non_empty_deques_;
260     }
261     q.clear();
262     warned_about_incorrect_bound_[i] = false;
263     candidate_ = Tuple();
264     pivot_ = NO_PIVOT;
265   }
266   template&lt;int i&gt;
267   void dequeDeleteFront()
268   {
269     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
270     ROS_ASSERT(!deque.empty());
271     deque.pop_front();
272     if (deque.empty())
273     {
274       --num_non_empty_deques_;
275     }
276   }
277   void dequeDeleteFront(uint32_t index)
278   {
279     switch (index)
280     {
281     case 0:
282       dequeDeleteFront&lt;0&gt;();
283       break;
284     case 1:
285       dequeDeleteFront&lt;1&gt;();
286       break;
287     case 2:
288       dequeDeleteFront&lt;2&gt;();
289       break;
290     case 3:
291       dequeDeleteFront&lt;3&gt;();
292       break;
293     case 4:
294       dequeDeleteFront&lt;4&gt;();
295       break;
296     case 5:
297       dequeDeleteFront&lt;5&gt;();
298       break;
299     case 6:
300       dequeDeleteFront&lt;6&gt;();
301       break;
302     case 7:
303       dequeDeleteFront&lt;7&gt;();
304       break;
305     case 8:
306       dequeDeleteFront&lt;8&gt;();
307       break;
308     default:
309       ROS_BREAK();
310     }
311   }
312   template&lt;int i&gt;
313   void dequeMoveFrontToPast()
314   {
315     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
316     std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; vector = boost::get&lt;i&gt;(past_);
317     ROS_ASSERT(!deque.empty());
318     vector.push_back(deque.front());
319     deque.pop_front();
320     if (deque.empty())
321     {
322       --num_non_empty_deques_;
323     }
324   }
325   void dequeMoveFrontToPast(uint32_t index)
326   {
327     switch (index)
328     {
329     case 0:
330       dequeMoveFrontToPast&lt;0&gt;();
331       break;
332     case 1:
333       dequeMoveFrontToPast&lt;1&gt;();
334       break;
335     case 2:
336       dequeMoveFrontToPast&lt;2&gt;();
337       break;
338     case 3:
339       dequeMoveFrontToPast&lt;3&gt;();
340       break;
341     case 4:
342       dequeMoveFrontToPast&lt;4&gt;();
343       break;
344     case 5:
345       dequeMoveFrontToPast&lt;5&gt;();
346       break;
347     case 6:
348       dequeMoveFrontToPast&lt;6&gt;();
349       break;
350     case 7:
351       dequeMoveFrontToPast&lt;7&gt;();
352       break;
353     case 8:
354       dequeMoveFrontToPast&lt;8&gt;();
355       break;
356     default:
357       ROS_BREAK();
358     }
359   }
360   void makeCandidate()
361   {
362     candidate_ = Tuple();     boost::get&lt;0&gt;(candidate_) = boost::get&lt;0&gt;(deques_).front();
363     boost::get&lt;1&gt;(candidate_) = boost::get&lt;1&gt;(deques_).front();
364     if (RealTypeCount::value &gt; 2)
365     {
366       boost::get&lt;2&gt;(candidate_) = boost::get&lt;2&gt;(deques_).front();
367       if (RealTypeCount::value &gt; 3)
368       {
369 	boost::get&lt;3&gt;(candidate_) = boost::get&lt;3&gt;(deques_).front();
370 	if (RealTypeCount::value &gt; 4)
371 	{
372 	  boost::get&lt;4&gt;(candidate_) = boost::get&lt;4&gt;(deques_).front();
373 	  if (RealTypeCount::value &gt; 5)
374 	  {
375 	    boost::get&lt;5&gt;(candidate_) = boost::get&lt;5&gt;(deques_).front();
376 	    if (RealTypeCount::value &gt; 6)
377 	    {
378 	      boost::get&lt;6&gt;(candidate_) = boost::get&lt;6&gt;(deques_).front();
379 	      if (RealTypeCount::value &gt; 7)
380 	      {
381 		boost::get&lt;7&gt;(candidate_) = boost::get&lt;7&gt;(deques_).front();
382 		if (RealTypeCount::value &gt; 8)
383 		{
384 		  boost::get&lt;8&gt;(candidate_) = boost::get&lt;8&gt;(deques_).front();
385 		}
386 	      }
387 	    }
388 	  }
389 	}
390       }
391     }
392     boost::get&lt;0&gt;(past_).clear();
393     boost::get&lt;1&gt;(past_).clear();
394     boost::get&lt;2&gt;(past_).clear();
395     boost::get&lt;3&gt;(past_).clear();
396     boost::get&lt;4&gt;(past_).clear();
397     boost::get&lt;5&gt;(past_).clear();
398     boost::get&lt;6&gt;(past_).clear();
399     boost::get&lt;7&gt;(past_).clear();
400     boost::get&lt;8&gt;(past_).clear();
401   }
402   template&lt;int i&gt;
403   void recover(size_t num_messages)
404   {
405     if (i &gt;= RealTypeCount::value)
406     {
407       return;
408     }
409     std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
410     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
411     ROS_ASSERT(num_messages &lt;= v.size());
412     while (num_messages &gt; 0)
413     {
414       q.push_front(v.back());
415       v.pop_back();
416       num_messages--;
417     }
418     if (!q.empty())
419     {
420       ++num_non_empty_deques_;
421     }
422   }
423   template&lt;int i&gt;
424   void recover()
425   {
426     if (i &gt;= RealTypeCount::value)
427     {
428       return;
429     }
430     std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
431     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
432     while (!v.empty())
433     {
434       q.push_front(v.back());
435       v.pop_back();
436     }
437     if (!q.empty())
438     {
439       ++num_non_empty_deques_;
440     }
441   }
442   template&lt;int i&gt;
443   void recoverAndDelete()
444   {
445     if (i &gt;= RealTypeCount::value)
446     {
447       return;
448     }
449     std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
450     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
451     while (!v.empty())
452     {
453       q.push_front(v.back());
454       v.pop_back();
455     }
456     ROS_ASSERT(!q.empty());
457     q.pop_front();
458     if (!q.empty())
459     {
460       ++num_non_empty_deques_;
461     }
462   }
463   void publishCandidate()
464   {
465     parent_-&gt;signal(boost::get&lt;0&gt;(candidate_), boost::get&lt;1&gt;(candidate_), boost::get&lt;2&gt;(candidate_), boost::get&lt;3&gt;(candidate_),
466                     boost::get&lt;4&gt;(candidate_), boost::get&lt;5&gt;(candidate_), boost::get&lt;6&gt;(candidate_), boost::get&lt;7&gt;(candidate_),
467                     boost::get&lt;8&gt;(candidate_));
468     candidate_ = Tuple();
469     pivot_ = NO_PIVOT;
470     num_non_empty_deques_ = 0;     recoverAndDelete&lt;0&gt;();
471     recoverAndDelete&lt;1&gt;();
472     recoverAndDelete&lt;2&gt;();
473     recoverAndDelete&lt;3&gt;();
474     recoverAndDelete&lt;4&gt;();
475     recoverAndDelete&lt;5&gt;();
476     recoverAndDelete&lt;6&gt;();
477     recoverAndDelete&lt;7&gt;();
478     recoverAndDelete&lt;8&gt;();
479   }
480   void getCandidateStart(uint32_t &amp;start_index, ros::Time &amp;start_time)
481   {
482     return getCandidateBoundary(start_index, start_time, false);
483   }
484   void getCandidateEnd(uint32_t &amp;end_index, ros::Time &amp;end_time)
485   {
486     return getCandidateBoundary(end_index, end_time, true);
487   }
488   void getCandidateBoundary(uint32_t &amp;index, ros::Time &amp;time, bool end)
489   {
490     namespace mt = ros::message_traits;
491     M0Event&amp; m0 = boost::get&lt;0&gt;(deques_).front();
492     time = mt::TimeStamp&lt;M0&gt;::value(*m0.getMessage());
493     index = 0;
494     if (RealTypeCount::value &gt; 1)
495     {
496       M1Event&amp; m1 = boost::get&lt;1&gt;(deques_).front();
497       if ((mt::TimeStamp&lt;M1&gt;::value(*m1.getMessage()) &lt; time) ^ end)
498       {
499         time = mt::TimeStamp&lt;M1&gt;::value(*m1.getMessage());
500         index = 1;
501       }
502     }
503     if (RealTypeCount::value &gt; 2)
504     {
505       M2Event&amp; m2 = boost::get&lt;2&gt;(deques_).front();
506       if ((mt::TimeStamp&lt;M2&gt;::value(*m2.getMessage()) &lt; time) ^ end)
507       {
508         time = mt::TimeStamp&lt;M2&gt;::value(*m2.getMessage());
509         index = 2;
510       }
511     }
512     if (RealTypeCount::value &gt; 3)
513     {
514       M3Event&amp; m3 = boost::get&lt;3&gt;(deques_).front();
515       if ((mt::TimeStamp&lt;M3&gt;::value(*m3.getMessage()) &lt; time) ^ end)
516       {
517         time = mt::TimeStamp&lt;M3&gt;::value(*m3.getMessage());
518         index = 3;
519       }
520     }
521     if (RealTypeCount::value &gt; 4)
522     {
523       M4Event&amp; m4 = boost::get&lt;4&gt;(deques_).front();
524       if ((mt::TimeStamp&lt;M4&gt;::value(*m4.getMessage()) &lt; time) ^ end)
525       {
526         time = mt::TimeStamp&lt;M4&gt;::value(*m4.getMessage());
527         index = 4;
528       }
529     }
530     if (RealTypeCount::value &gt; 5)
531     {
532       M5Event&amp; m5 = boost::get&lt;5&gt;(deques_).front();
533       if ((mt::TimeStamp&lt;M5&gt;::value(*m5.getMessage()) &lt; time) ^ end)
534       {
535         time = mt::TimeStamp&lt;M5&gt;::value(*m5.getMessage());
536         index = 5;
537       }
538     }
539     if (RealTypeCount::value &gt; 6)
540     {
541       M6Event&amp; m6 = boost::get&lt;6&gt;(deques_).front();
542       if ((mt::TimeStamp&lt;M6&gt;::value(*m6.getMessage()) &lt; time) ^ end)
543       {
544         time = mt::TimeStamp&lt;M6&gt;::value(*m6.getMessage());
545         index = 6;
546       }
547     }
548     if (RealTypeCount::value &gt; 7)
549     {
550       M7Event&amp; m7 = boost::get&lt;7&gt;(deques_).front();
551       if ((mt::TimeStamp&lt;M7&gt;::value(*m7.getMessage()) &lt; time) ^ end)
552       {
553         time = mt::TimeStamp&lt;M7&gt;::value(*m7.getMessage());
554         index = 7;
555       }
556     }
557     if (RealTypeCount::value &gt; 8)
558     {
559       M8Event&amp; m8 = boost::get&lt;8&gt;(deques_).front();
560       if ((mt::TimeStamp&lt;M8&gt;::value(*m8.getMessage()) &lt; time) ^ end)
561       {
562         time = mt::TimeStamp&lt;M8&gt;::value(*m8.getMessage());
563         index = 8;
564       }
565     }
566   }
567   template&lt;int i&gt;
568   ros::Time getVirtualTime()
569   {
570     namespace mt = ros::message_traits;
571     if (i &gt;= RealTypeCount::value)
572     {
573       return ros::Time(0,0);      }
574     ROS_ASSERT(pivot_ != NO_PIVOT);
575     std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
576     std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
577     if (q.empty())
578     {
579       ROS_ASSERT(!v.empty());        ros::Time last_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(*(v.back()).getMessage());
580       ros::Time msg_time_lower_bound = last_msg_time + inter_message_lower_bounds_[i];
581       if (msg_time_lower_bound &gt; pivot_time_)        {
582         return msg_time_lower_bound;
583       }
584       return pivot_time_;
585     }
586     ros::Time current_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(*(q.front()).getMessage());
587     return current_msg_time;
588   }
589   void getVirtualCandidateStart(uint32_t &amp;start_index, ros::Time &amp;start_time)
590   {
591     return getVirtualCandidateBoundary(start_index, start_time, false);
592   }
593   void getVirtualCandidateEnd(uint32_t &amp;end_index, ros::Time &amp;end_time)
594   {
595     return getVirtualCandidateBoundary(end_index, end_time, true);
596   }
597   void getVirtualCandidateBoundary(uint32_t &amp;index, ros::Time &amp;time, bool end)
598   {
599     namespace mt = ros::message_traits;
600     std::vector&lt;ros::Time&gt; virtual_times(9);
601     virtual_times[0] = getVirtualTime&lt;0&gt;();
602     virtual_times[1] = getVirtualTime&lt;1&gt;();
603     virtual_times[2] = getVirtualTime&lt;2&gt;();
604     virtual_times[3] = getVirtualTime&lt;3&gt;();
605     virtual_times[4] = getVirtualTime&lt;4&gt;();
606     virtual_times[5] = getVirtualTime&lt;5&gt;();
607     virtual_times[6] = getVirtualTime&lt;6&gt;();
608     virtual_times[7] = getVirtualTime&lt;7&gt;();
609     virtual_times[8] = getVirtualTime&lt;8&gt;();
610     time = virtual_times[0];
611     index = 0;
612     for (int i = 0; i &lt; RealTypeCount::value; i++)
613     {
614       if ((virtual_times[i] &lt; time) ^ end)
615       {
616 	time = virtual_times[i];
617 	index = i;
618       }
619     }
620   }
621   void process()
622   {
623     while (num_non_empty_deques_ == (uint32_t)RealTypeCount::value)
624     {
625       ros::Time end_time, start_time;
626       uint32_t end_index, start_index;
627       getCandidateEnd(end_index, end_time);
628       getCandidateStart(start_index, start_time);
629       for (uint32_t i = 0; i &lt; (uint32_t)RealTypeCount::value; i++)
630       {
631 	if (i != end_index)
632 	{
633 	  has_dropped_messages_[i] = false;
634 	}
635       }
636       if (pivot_ == NO_PIVOT)
637       {
638         if (end_time - start_time &gt; max_interval_duration_)
639         {
640           dequeDeleteFront(start_index);
641           continue;
642         }
643 	if (has_dropped_messages_[end_index])
644 	{
645 	  dequeDeleteFront(start_index);
646 	  continue;
647 	}
648 	makeCandidate();
649 	candidate_start_ = start_time;
650 	candidate_end_ = end_time;
651 	pivot_ = end_index;
652 	pivot_time_ = end_time;
653 	dequeMoveFrontToPast(start_index);
654       }
655       else
656       {
657         if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (start_time - candidate_start_))
658         {
659           dequeMoveFrontToPast(start_index);
660         }
661         else
662         {
663           makeCandidate();
664           candidate_start_ = start_time;
665           candidate_end_ = end_time;
666           dequeMoveFrontToPast(start_index);
667         }
668       }
669       ROS_ASSERT(pivot_ != NO_PIVOT);
670       if (start_index == pivot_)        {
671         publishCandidate();
672       }
673       else if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (pivot_time_ - candidate_start_))
674       {
675         publishCandidate();
676       }
677       else if (num_non_empty_deques_ &lt; (uint32_t)RealTypeCount::value)
678       {
679         uint32_t num_non_empty_deques_before_virtual_search = num_non_empty_deques_;
680         std::vector&lt;int&gt; num_virtual_moves(9,0);
681         while (1)
682         {
683           ros::Time end_time, start_time;
684           uint32_t end_index, start_index;
685           getVirtualCandidateEnd(end_index, end_time);
686           getVirtualCandidateStart(start_index, start_time);
687           if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (pivot_time_ - candidate_start_))
688           {
689             publishCandidate();              break;            }
690           if ((end_time - candidate_end_) * (1 + age_penalty_) &lt; (start_time - candidate_start_))
691           {
692             num_non_empty_deques_ = 0; 	    recover&lt;0&gt;(num_virtual_moves[0]);
693 	    recover&lt;1&gt;(num_virtual_moves[1]);
694 	    recover&lt;2&gt;(num_virtual_moves[2]);
695 	    recover&lt;3&gt;(num_virtual_moves[3]);
696 	    recover&lt;4&gt;(num_virtual_moves[4]);
697 	    recover&lt;5&gt;(num_virtual_moves[5]);
698 	    recover&lt;6&gt;(num_virtual_moves[6]);
699 	    recover&lt;7&gt;(num_virtual_moves[7]);
700 	    recover&lt;8&gt;(num_virtual_moves[8]);
701             (void)num_non_empty_deques_before_virtual_search;             ROS_ASSERT(num_non_empty_deques_before_virtual_search == num_non_empty_deques_);
702             break;
703           }
704 	  ROS_ASSERT(start_index != pivot_);
705 	  ROS_ASSERT(start_time &lt; pivot_time_);
706           dequeMoveFrontToPast(start_index);
707           num_virtual_moves[start_index]++;
708         }       }
709     }   }
710   Sync* parent_;
711   uint32_t queue_size_;
712   bool enable_reset_;
713   uint32_t num_reset_deques_;
714   static const uint32_t NO_PIVOT = 9;  
715   DequeTuple deques_;
716   uint32_t num_non_empty_deques_;
717   VectorTuple past_;
718   Tuple candidate_;    ros::Time candidate_start_;
719   ros::Time candidate_end_;
720   ros::Time pivot_time_;
721   uint32_t pivot_;    boost::mutex data_mutex_;  
722   ros::Duration max_interval_duration_;   double age_penalty_;
723   std::vector&lt;bool&gt; has_dropped_messages_;
724   std::vector&lt;ros::Duration&gt; inter_message_lower_bounds_;
725   std::vector&lt;bool&gt; warned_about_incorrect_bound_;
726   std::vector&lt;ros::Time&gt; last_stamps_;
727 };
728 } } 
729 #endif 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_socket.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "xmlrpcpp/XmlRpcUtil.h"
2 #include "xmlrpcpp/XmlRpcSocket.h"
3 #include "test_system_mocks.h"
4 #include &lt;arpa/inet.h&gt;
5 #include &lt;fcntl.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;limits.h&gt;
8 #include &lt;netdb.h&gt;
9 #include &lt;stdarg.h&gt;
10 #include &lt;sys/socket.h&gt;
11 #include &lt;sys/types.h&gt;
12 #include &lt;unistd.h&gt;
13 #include &lt;deque&gt;
14 #include &lt;gtest/gtest.h&gt;
15 #define FOR_ERRNO(itr, var, ...)                                               \
16   int var[] = {__VA_ARGS__};                                                   \
17   for (size_t itr = 0; itr &lt; sizeof(var) / sizeof(int); itr++)
18 using XmlRpc::XmlRpcSocket;
19 class XmlRpcSocketTest : public ::testing::Test {
20 protected:
21   void SetUp() {
22     accept_calls = 0;
23     bind_calls = 0;
24     close_calls = 0;
25     connect_calls = 0;
26     fcntl_calls = 0;
27     listen_calls = 0;
28     read_calls = 0;
29     select_calls = 0;
30     socket_calls = 0;
31     write_calls = 0;
32     XmlRpc::setVerbosity(5);
33     XmlRpcSocket::s_use_ipv6_ = false;
34   }
35   void TearDown() {
36     fake_accept = 0;
37     fake_bind = 0;
38     fake_close = 0;
39     fake_connect = 0;
40     fake_fcntl = 0;
41     fake_listen = 0;
42     fake_read = 0;
43     fake_select = 0;
44     fake_socket = 0;
45     fake_write = 0;
46   }
47 };
48 TEST_F(XmlRpcSocketTest, TestMocks) {
49   EXPECT_EQ(0, fake_accept);
50   EXPECT_EQ(0, accept_calls);
51   fake_accept = count_accept;
52   EXPECT_EQ(0, accept(0, 0, 0));
53   EXPECT_EQ(1, accept_calls);
54   EXPECT_EQ(0, fake_bind);
55   EXPECT_EQ(0, bind_calls);
56   fake_bind = count_bind;
57   EXPECT_EQ(0, bind(0, 0, 0));
58   EXPECT_EQ(1, bind_calls);
59   EXPECT_EQ(0, fake_close);
60   EXPECT_EQ(0, close_calls);
61   fake_close = count_close;
62   EXPECT_EQ(0, close(-1));
63   EXPECT_EQ(1, close_calls);
64   EXPECT_EQ(0, fake_connect);
65   EXPECT_EQ(0, connect_calls);
66   fake_connect = count_connect;
67   EXPECT_EQ(0, connect(0, 0, 0));
68   EXPECT_EQ(1, connect_calls);
69   EXPECT_EQ(0, fake_fcntl);
70   EXPECT_EQ(0, fcntl_calls);
71   fake_fcntl = count_fcntl;
72   EXPECT_EQ(0, fcntl(0, 0, 0));
73   EXPECT_EQ(1, fcntl_calls);
74   EXPECT_EQ(0, fake_freeaddrinfo);
75   EXPECT_EQ(0, freeaddrinfo_calls);
76   fake_freeaddrinfo = count_freeaddrinfo;
77   freeaddrinfo(0);
78   EXPECT_EQ(1, freeaddrinfo_calls);
79   EXPECT_EQ(0, fake_getaddrinfo);
80   EXPECT_EQ(0, getaddrinfo_calls);
81   fake_getaddrinfo = count_getaddrinfo;
82   EXPECT_EQ(0, getaddrinfo(0, 0, 0, 0));
83   EXPECT_EQ(1, getaddrinfo_calls);
84   EXPECT_EQ(0, fake_getsockname);
85   EXPECT_EQ(0, getsockname_calls);
86   fake_getsockname = count_getsockname;
87   EXPECT_EQ(0, getsockname(0, 0, 0));
88   EXPECT_EQ(1, getsockname_calls);
89   EXPECT_EQ(0, fake_listen);
90   EXPECT_EQ(0, listen_calls);
91   fake_listen = count_listen;
92   EXPECT_EQ(0, listen(0, 0));
93   EXPECT_EQ(1, listen_calls);
94   EXPECT_EQ(0, fake_read);
95   EXPECT_EQ(0, read_calls);
96   fake_read = count_read;
97   EXPECT_EQ(0, read(0, 0, 0));
98   EXPECT_EQ(1, read_calls);
99   EXPECT_EQ(0, fake_setsockopt);
100   EXPECT_EQ(0, setsockopt_calls);
101   fake_setsockopt = count_setsockopt;
102   EXPECT_EQ(0, setsockopt(0, 0, 0, 0, 0));
103   EXPECT_EQ(1, setsockopt_calls);
104   EXPECT_EQ(0, fake_select);
105   EXPECT_EQ(0, select_calls);
106   fake_select = count_select;
107   EXPECT_EQ(0, select(0, 0, 0, 0, 0));
108   EXPECT_EQ(1, select_calls);
109   EXPECT_EQ(0, fake_socket);
110   EXPECT_EQ(0, socket_calls);
111   fake_socket = count_socket;
112   EXPECT_EQ(0, socket(0, 0, 0));
113   EXPECT_EQ(1, socket_calls);
114   EXPECT_EQ(0, fake_write);
115   EXPECT_EQ(0, write_calls);
116   fake_write = count_write;
117   EXPECT_EQ(0, write(0, 0, 0));
118   EXPECT_EQ(1, write_calls);
119 }
120 int socket_ret = 0;
121 int socket_errno = 0;
122 int socket_domain = 0;
123 int socket_type = 0;
124 int socket_protocol = 0;
125 int test_socket(int domain, int type, int protocol) {
126   socket_domain = domain;
127   socket_type = type;
128   socket_protocol = protocol;
129   socket_calls++;
130   errno = socket_errno;
131   return socket_ret;
132 }
133 TEST_F(XmlRpcSocketTest, socket) {
134   fake_socket = test_socket;
135   errno = 0;
136   EXPECT_EQ(0, errno);
137   socket_ret = 7;
138   socket_errno = 0;
139   socket_calls = 0;
140   EXPECT_EQ(7, XmlRpcSocket::socket());
141   EXPECT_EQ(0, XmlRpcSocket::getError());
142   EXPECT_EQ(1, socket_calls);
143   EXPECT_EQ(AF_INET, socket_domain);
144   EXPECT_EQ(SOCK_STREAM, socket_type);
145   EXPECT_EQ(0, socket_protocol);
146   FOR_ERRNO(i,
147             errnos,
148             EACCES,
149             EAFNOSUPPORT,
150             EINVAL,
151             EMFILE,
152             ENFILE,
153             ENOBUFS,
154             ENOMEM,
155             EPROTONOSUPPORT) {
156     socket_ret = -1;
157     socket_errno = errnos[i];
158     socket_calls = 0;
159     EXPECT_EQ(-1, XmlRpcSocket::socket());
160     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
161     EXPECT_EQ(1, socket_calls);
162     EXPECT_EQ(AF_INET, socket_domain);
163     EXPECT_EQ(SOCK_STREAM, socket_type);
164     EXPECT_EQ(0, socket_protocol);
165   }
166 }
167 int close_fd = 0;
168 int close_errno = 0;
169 int close_ret = 0;
170 int test_close(int fd) {
171   EXPECT_EQ(close_fd, fd);
172   close_calls++;
173   errno = close_errno;
174   return close_ret;
175 }
176 TEST_F(XmlRpcSocketTest, close) {
177   close_fd = 8;
178   close_errno = 0;
179   close_ret = 0;
180   close_calls = 0;
181   fake_close = test_close;
182   XmlRpcSocket::close(8);
183   EXPECT_EQ(0, XmlRpcSocket::getError());
184   EXPECT_EQ(1, close_calls);
185   FOR_ERRNO(i, errnos, EBADF, EINTR, EIO) {
186     close_errno = errnos[i];
187     close_ret = -1;
188     close_calls = 0;
189     XmlRpcSocket::close(8);
190     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
191     EXPECT_EQ(1, close_calls);
192   }
193 }
194 int fcntl_fd = 0;
195 int fcntl_cmd = 0;
196 unsigned long fcntl_arg = 0;
197 int fcntl_errno = 0;
198 int fcntl_ret = 0;
199 int test_fcntl(int fd, int cmd, unsigned long arg) {
200   EXPECT_EQ(fcntl_fd, fd);
201   EXPECT_EQ(fcntl_cmd, cmd);
202   EXPECT_EQ(fcntl_arg, arg);
203   errno = fcntl_errno;
204   fcntl_calls++;
205   return fcntl_ret;
206 }
207 TEST_F(XmlRpcSocketTest, setNonBlocking) {
208   fake_fcntl = test_fcntl;
209   fcntl_fd = 9;
210   fcntl_cmd = F_SETFL;
211   fcntl_arg = O_NONBLOCK;
212   fcntl_calls = 0;
213   fcntl_errno = 0;
214   fcntl_ret = 0;
215   EXPECT_TRUE(XmlRpcSocket::setNonBlocking(9));
216   EXPECT_EQ(0, XmlRpcSocket::getError());
217   EXPECT_EQ(1, fcntl_calls);
218   FOR_ERRNO(i, errnos, EACCES, EAGAIN, EBADF) {
219     fcntl_calls = 0;
220     fcntl_errno = errnos[i];
221     fcntl_ret = -1;
222     EXPECT_FALSE(XmlRpcSocket::setNonBlocking(9));
223     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
224     EXPECT_EQ(1, fcntl_calls);
225   }
226 }
227 struct expected_read {
228   expected_read(int fd, const void* buf, size_t sz)
229     : fd(fd), count(4095), buf(buf), sz(sz), ret(sz), _errno(0) {}
230   expected_read(int fd, int _errno)
231     : fd(fd), count(4095), buf(0), sz(0), ret(-1), _errno(_errno) {}
232   int fd;
233   size_t count;
234   const void* buf;
235   size_t sz;
236   ssize_t ret;
237   int _errno;
238 };
239 std::deque&lt;expected_read&gt; expected_reads;
240 ssize_t mock_read(int fd, void* buf, size_t count) {
241   read_calls++;
242   EXPECT_LE(1u, expected_reads.size());
243   if (expected_reads.size() &lt; 1) {
244     errno = 0;
245     return 0;
246   }
247   expected_read r = expected_reads.front();
248   expected_reads.pop_front();
249   EXPECT_EQ(r.fd, fd);
250   EXPECT_EQ(r.count, count);
251   EXPECT_GT(static_cast&lt;size_t&gt;(SSIZE_MAX), count);
252   EXPECT_LE(r.sz, count);
253   size_t cnt = std::min(count, r.sz);
254   if (cnt &gt; 0) {
255     memcpy(buf, r.buf, cnt);
256   }
257   if (r.ret &gt;= 0) {
258     EXPECT_EQ(cnt, static_cast&lt;size_t&gt;(r.ret));
259   }
260   errno = r._errno;
261   return r.ret;
262 }
263 TEST_F(XmlRpcSocketTest, nbRead) {
264   fake_read = mock_read;
265   const char data[] = "read1 read2 read3 read4 read5 read6 read7 read8";
266   bool eof = false;
267   std::string data_out;
268   expected_reads.push_back(expected_read(7, data, 9));
269   expected_reads.push_back(expected_read(7, 0, 0));
270   EXPECT_TRUE(XmlRpcSocket::nbRead(7, data_out, &amp;eof));
271   EXPECT_EQ("read1 rea", data_out);
272   EXPECT_TRUE(eof);
273   EXPECT_EQ(2, read_calls);
274   EXPECT_EQ(0, XmlRpcSocket::getError());
275   EXPECT_EQ(0u, expected_reads.size());
276   expected_reads.clear();
277 }
278 #define TEST_READ(RES, ERR)                                                    \
279   TEST_F(XmlRpcSocketTest, nbRead_##ERR) {                                     \
280     fake_read = mock_read;                                                     \
281     bool eof = false;                                                          \
282     std::string data_out;                                                      \
283                                                                                \
284     expected_reads.push_back(expected_read(7, ERR));                           \
285                                                                                \
286     EXPECT_##RES(XmlRpcSocket::nbRead(7, data_out, &amp;eof));                     \
287     EXPECT_EQ("", data_out);                                                   \
288     EXPECT_FALSE(eof);                                                         \
289     EXPECT_EQ(1, read_calls);                                                  \
290     EXPECT_EQ(ERR, XmlRpcSocket::getError());                                  \
291     EXPECT_EQ(0u, expected_reads.size());                                       \
292     expected_reads.clear();                                                    \
293   }
294 TEST_READ(TRUE, EAGAIN);
295 TEST_READ(TRUE, EWOULDBLOCK);
296 TEST_F(XmlRpcSocketTest, nbRead_EINTR) {
297   fake_read = mock_read;
298   bool eof = false;
299   std::string data_out;
300   expected_reads.push_back(expected_read(7, EINTR));
301   EXPECT_TRUE(XmlRpcSocket::nbRead(7, data_out, &amp;eof));
302   EXPECT_EQ("", data_out);
303   EXPECT_FALSE(eof);
304   EXPECT_EQ(1, read_calls);
305   EXPECT_EQ(EINTR, XmlRpcSocket::getError());
306 }
307 TEST_READ(FALSE, EBADF);
308 TEST_READ(FALSE, EFAULT);
309 TEST_READ(FALSE, EINVAL);
310 TEST_READ(FALSE, EIO);
311 TEST_READ(FALSE, EISDIR);
312 TEST_READ(FALSE, EACCES);
313 TEST_READ(FALSE, ECONNREFUSED);
314 TEST_READ(FALSE, ENOMEM);
315 TEST_READ(FALSE, ENOTCONN);
316 struct expected_write {
317   expected_write(int fd, std::string data, size_t count, size_t max_write)
318     : fd(fd),
319       data(data),
320       count(count),
321       max_write(max_write),
322       ret(std::min(count, max_write)),
323       _errno(0) {}
324   expected_write(int fd, size_t count, ssize_t ret, int _errno)
325     : fd(fd), data(""), count(count), max_write(0), ret(ret), _errno(_errno) {}
326   int fd;
327   std::string data;
328   size_t count;
329   size_t max_write;
330   ssize_t ret;
331   int _errno;
332 };
333 std::deque&lt;expected_write&gt; expected_writes;
334 ssize_t mock_write(int fd, const void* buf, size_t count) {
335   write_calls++;
336   EXPECT_LE(1u, expected_writes.size());
337   if (expected_writes.size() &lt; 1) {
338     errno = EWOULDBLOCK;
339     return -1;
340   }
341   expected_write w = expected_writes.front();
342   expected_writes.pop_front();
343   EXPECT_EQ(w.fd, fd);
344   EXPECT_EQ(w.count, count);
345   size_t sz = std::min(w.max_write, count);
346   if (sz &gt; 0) {
347     std::string data((const char*)buf, sz);
348     EXPECT_EQ(w.data, data);
349     EXPECT_GE(w.ret, 0u);
350     EXPECT_EQ(static_cast&lt;size_t&gt;(w.ret), sz);
351   }
352   errno = w._errno;
353   return w.ret;
354 }
355 TEST_F(XmlRpcSocketTest, nbWrite) {
356   fake_write = mock_write;
357   int count = 0;
358   std::string hello = "hello world";
359   expected_writes.push_back(expected_write(10, "hello world", 11, 11));
360   count = 0;
361   write_calls = 0;
362   errno = 0;
363   EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
364   EXPECT_EQ(count, 11);
365   EXPECT_EQ(0, XmlRpcSocket::getError());
366   EXPECT_EQ(0u, expected_writes.size());
367   EXPECT_EQ(1, write_calls);
368   expected_writes.push_back(expected_write(10, "hello", 11, 5));
369   expected_writes.push_back(expected_write(10, " world", 6, 10));
370   count = 0;
371   write_calls = 0;
372   errno = 0;
373   EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
374   EXPECT_EQ(count, 11);
375   EXPECT_EQ(0, XmlRpcSocket::getError());
376   EXPECT_EQ(0u, expected_writes.size());
377   EXPECT_EQ(2, write_calls);
378   count = 0;
379   write_calls = 0;
380   errno = 0;
381   expected_writes.push_back(expected_write(10, "hello", 11, 5));
382   expected_writes.push_back(expected_write(10, 6, -1, EWOULDBLOCK));
383   EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
384   EXPECT_EQ(count, 5);
385   EXPECT_EQ(EWOULDBLOCK, XmlRpcSocket::getError());
386   EXPECT_EQ(0u, expected_writes.size());
387   EXPECT_EQ(2, write_calls);
388 }
389 #define TEST_WRITE(RES, ERR)                                                   \
390   TEST_F(XmlRpcSocketTest, nbWrite_##ERR) {                                    \
391     fake_write = mock_write;                                                   \
392     int count = 0;                                                             \
393     std::string hello = "hello world";                                         \
394     errno = 0;                                                                 \
395     expected_writes.push_back(expected_write(10, 11, -1, ERR));                \
396     EXPECT_##RES(XmlRpcSocket::nbWrite(10, hello, &amp;count));                    \
397     EXPECT_EQ(count, 0);                                                       \
398     EXPECT_EQ(ERR, XmlRpcSocket::getError());                                  \
399     EXPECT_EQ(0u, expected_writes.size());                                     \
400     EXPECT_EQ(1, write_calls);                                                 \
401     expected_writes.clear();                                                   \
402   }
403 TEST_WRITE(TRUE, EAGAIN);
404 TEST_WRITE(TRUE, EWOULDBLOCK);
405 TEST_WRITE(TRUE, EINTR); TEST_WRITE(FALSE, EBADF);
406 TEST_WRITE(FALSE, EDESTADDRREQ);
407 TEST_WRITE(FALSE, EDQUOT);
408 TEST_WRITE(FALSE, EFAULT);
409 TEST_WRITE(FALSE, EFBIG);
410 TEST_WRITE(FALSE, EINVAL);
411 TEST_WRITE(FALSE, EIO);
412 TEST_WRITE(FALSE, ENOSPC);
413 TEST_WRITE(FALSE, EPIPE);
414 TEST_WRITE(FALSE, EACCES);
415 TEST_WRITE(FALSE, ECONNRESET);
416 TEST_WRITE(FALSE, EISCONN);
417 TEST_WRITE(FALSE, ENOBUFS);
418 TEST_WRITE(FALSE, ENOMEM);
419 TEST_WRITE(FALSE, ENOTCONN);
420 int setsockopt_ret = 0;
421 int setsockopt_errno = 0;
422 int setsockopt_sockfd = 0;
423 int test_setsockopt(
424     int sockfd, int level, int optname, const void* optval, socklen_t optlen) {
425   setsockopt_calls++;
426   setsockopt_sockfd = sockfd;
427   EXPECT_EQ(SOL_SOCKET, level);
428   EXPECT_EQ(SO_REUSEADDR, optname);
429   EXPECT_EQ(sizeof(int), optlen);
430   if (sizeof(int) == optlen) {
431     EXPECT_EQ(1, *(int*)optval);
432   }
433   errno = setsockopt_errno;
434   return setsockopt_ret;
435 }
436 TEST_F(XmlRpcSocketTest, setReuseAddr) {
437   fake_setsockopt = test_setsockopt;
438   errno = 0;
439   setsockopt_sockfd = 0;
440   setsockopt_calls = 0;
441   setsockopt_errno = 0;
442   setsockopt_ret = 0;
443   EXPECT_TRUE(XmlRpcSocket::setReuseAddr(11));
444   EXPECT_EQ(0, XmlRpcSocket::getError());
445   EXPECT_EQ(11, setsockopt_sockfd);
446   EXPECT_EQ(1, setsockopt_calls);
447   FOR_ERRNO(i, errnos, EBADF, EFAULT, EINVAL, ENOPROTOOPT, ENOTSOCK) {
448     errno = 0;
449     setsockopt_sockfd = 0;
450     setsockopt_calls = 0;
451     setsockopt_errno = errnos[i];
452     setsockopt_ret = -1;
453     EXPECT_FALSE(XmlRpcSocket::setReuseAddr(11));
454     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
455     EXPECT_EQ(11, setsockopt_sockfd);
456     EXPECT_EQ(1, setsockopt_calls);
457   }
458 }
459 bool operator==(const in6_addr a, const in6_addr b) {
460   return IN6_ARE_ADDR_EQUAL(&amp;a, &amp;b);
461 }
462 int bind_ret = 0;
463 int bind_errno = 0;
464 int bind_sockfd = 0;
465 int bind_family = 0;
466 int bind_port = 0;
467 int test_bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen) {
468   bind_calls++;
469   EXPECT_EQ(bind_sockfd, sockfd);
470   EXPECT_TRUE(NULL != addr);
471   if (NULL != addr) {
472     EXPECT_EQ(bind_family, addr-&gt;sa_family);
473     if (AF_INET == addr-&gt;sa_family) {
474       EXPECT_EQ(sizeof(struct sockaddr_in), addrlen);
475       struct sockaddr_in* in_addr = (struct sockaddr_in*)addr;
476       EXPECT_EQ(INADDR_ANY, ntohl(in_addr-&gt;sin_addr.s_addr));
477       EXPECT_EQ(bind_port, ntohs(in_addr-&gt;sin_port));
478     } else if (AF_INET6 == addr-&gt;sa_family) {
479       EXPECT_EQ(sizeof(struct sockaddr_in6), addrlen);
480       struct sockaddr_in6* in6_addr = (struct sockaddr_in6*)addr;
481       EXPECT_EQ(in6addr_any, in6_addr-&gt;sin6_addr);
482       EXPECT_EQ(bind_port, ntohs(in6_addr-&gt;sin6_port));
483     } else {
484       ADD_FAILURE() &lt;&lt; "Unrecognized sockaddr family";
485     }
486   }
487   errno = bind_errno;
488   return bind_ret;
489 }
490 TEST_F(XmlRpcSocketTest, bind) {
491   fake_bind = test_bind;
492   bind_sockfd = 12;
493   bind_family = AF_INET;
494   bind_port = 22;
495   bind_calls = 0;
496   bind_errno = 0;
497   bind_ret = 0;
498   EXPECT_TRUE(XmlRpcSocket::bind(12, 22));
499   EXPECT_EQ(1, bind_calls);
500   EXPECT_EQ(0, XmlRpcSocket::getError());
501   FOR_ERRNO(i, errnos, EACCES, EADDRINUSE, EBADF, EINVAL, ENOTSOCK) {
502     bind_calls = 0;
503     bind_family = AF_INET;
504     bind_port = 22;
505     bind_errno = errnos[i];
506     bind_ret = -1;
507     EXPECT_FALSE(XmlRpcSocket::bind(12, 22));
508     EXPECT_EQ(1, bind_calls);
509     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
510   }
511   XmlRpcSocket::s_use_ipv6_ = true;
512   bind_calls = 0;
513   bind_family = AF_INET6;
514   bind_port = 22;
515   bind_errno = 0;
516   bind_ret = 0;
517   EXPECT_TRUE(XmlRpcSocket::bind(12, 22));
518   EXPECT_EQ(1, bind_calls);
519   EXPECT_EQ(0, XmlRpcSocket::getError());
520 }
521 int getsockname_ret = 0;
522 int getsockname_errno = 0;
523 int getsockname_sockfd = 0;
524 void* getsockname_addr = 0;
525 socklen_t getsockname_len = 0;
526 int test_getsockname(int sockfd, struct sockaddr* addr, socklen_t* addrlen) {
527   getsockname_calls++;
528   EXPECT_EQ(getsockname_sockfd, sockfd);
529   EXPECT_TRUE(NULL != addr);
530   EXPECT_LE(getsockname_len, *addrlen);
531   if (NULL != addr) {
532     socklen_t len = std::min(*addrlen, getsockname_len);
533     if (len &gt; 0)
534       memcpy(addr, getsockname_addr, len);
535   }
536   EXPECT_TRUE(NULL != addrlen);
537   if (NULL != addrlen) {
538     *addrlen = getsockname_len;
539   }
540   errno = getsockname_errno;
541   return getsockname_ret;
542 }
543 TEST_F(XmlRpcSocketTest, get_port) {
544   fake_getsockname = test_getsockname;
545   struct sockaddr_in inet_addr;
546   inet_addr.sin_family = AF_INET;
547   inet_addr.sin_port = htons(123);
548   struct sockaddr_in6 inet6_addr;
549   inet6_addr.sin6_family = AF_INET6;
550   inet6_addr.sin6_port = htons(4224);
551   getsockname_sockfd = 14;
552   getsockname_errno = 0;
553   getsockname_ret = 0;
554   getsockname_calls = 0;
555   getsockname_addr = &amp;inet_addr;
556   getsockname_len = sizeof(struct sockaddr_in);
557   EXPECT_EQ(123, XmlRpcSocket::get_port(14));
558   EXPECT_EQ(0, XmlRpcSocket::getError());
559   EXPECT_EQ(1, getsockname_calls);
560   getsockname_calls = 0;
561   getsockname_addr = &amp;inet6_addr;
562   getsockname_len = sizeof(struct sockaddr_in6);
563   EXPECT_EQ(4224, XmlRpcSocket::get_port(14));
564   EXPECT_EQ(0, XmlRpcSocket::getError());
565   EXPECT_EQ(1, getsockname_calls);
566   getsockname_ret = -1;
567   FOR_ERRNO(i, errnos, EBADF, EFAULT, EINVAL, ENOBUFS, ENOTSOCK) {
568     getsockname_errno = errnos[i];
569     getsockname_calls = 0;
570     getsockname_addr = NULL;
571     getsockname_len = 0;
572     EXPECT_EQ(0, XmlRpcSocket::get_port(14));
573     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
574     EXPECT_EQ(1, getsockname_calls);
575     getsockname_calls = 0;
576     getsockname_addr = &amp;inet_addr;
577     getsockname_len = sizeof(struct sockaddr_in);
578     EXPECT_EQ(0, XmlRpcSocket::get_port(14));
579     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
580     EXPECT_EQ(1, getsockname_calls);
581   }
582 }
583 int listen_ret = 0;
584 int listen_errno = 0;
585 int listen_sockfd = 0;
586 int listen_backlog = 0;
587 int test_listen(int sockfd, int backlog) {
588   EXPECT_EQ(listen_sockfd, sockfd);
589   EXPECT_EQ(listen_backlog, backlog);
590   errno = listen_errno;
591   return listen_ret;
592 }
593 TEST_F(XmlRpcSocketTest, listen) {
594   fake_listen = test_listen;
595   listen_sockfd = 13;
596   listen_backlog = 10;
597   listen_ret = 0;
598   listen_errno = 0;
599   EXPECT_TRUE(XmlRpcSocket::listen(13, 10));
600   EXPECT_EQ(0, XmlRpcSocket::getError());
601   FOR_ERRNO(i, errnos, EADDRINUSE, EBADF, ENOTSOCK, EOPNOTSUPP) {
602     listen_ret = -1;
603     listen_errno = errnos[i];
604     EXPECT_FALSE(XmlRpcSocket::listen(13, 10));
605     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
606   }
607 }
608 int accept_ret = 0;
609 int accept_errno = 0;
610 int accept_sockfd = 0;
611 void* accept_addr = 0;
612 socklen_t accept_addrlen = 0;
613 int test_accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen) {
614   accept_calls++;
615   EXPECT_EQ(accept_sockfd, sockfd);
616   if (accept_addr) {
617     EXPECT_TRUE(NULL != addr);
618     EXPECT_TRUE(NULL != addrlen);
619     if (NULL != addr &amp;&amp; NULL != addrlen) {
620       socklen_t len = std::min(accept_addrlen, *addrlen);
621       memcpy(addr, accept_addr, len);
622       *addrlen = accept_addrlen;
623     }
624   } else {
625     EXPECT_EQ(NULL, addr);
626     EXPECT_EQ(NULL, addrlen);
627   }
628   errno = accept_errno;
629   return accept_ret;
630 }
631 TEST_F(XmlRpcSocketTest, accept) {
632   fake_accept = test_accept;
633   struct sockaddr_in addr;
634   addr.sin_family = AF_INET;
635   addr.sin_port = htons(45);
636   addr.sin_addr.s_addr = 0xDEADBEEF;
637   accept_addr = &amp;addr;
638   accept_addrlen = sizeof(struct sockaddr);
639   accept_sockfd = 15;
640   accept_calls = 0;
641   accept_ret = 16;
642   accept_errno = 0;
643   EXPECT_EQ(16, XmlRpcSocket::accept(15));
644   EXPECT_EQ(0, XmlRpcSocket::getError());
645   EXPECT_EQ(1, accept_calls);
646   FOR_ERRNO(i,
647             errnos,
648             EAGAIN,
649             EWOULDBLOCK,
650             EBADF,
651             ECONNABORTED,
652             EFAULT,
653             EINTR,             EINVAL,
654             EMFILE,
655             ENFILE,
656             ENOBUFS,
657             ENOMEM,
658             ENOTSOCK,
659             EOPNOTSUPP,
660             EPROTO,
661             EPERM) {
662     accept_calls = 0;
663     accept_ret = -1;
664     accept_errno = errnos[i];
665     EXPECT_EQ(-1, XmlRpcSocket::accept(15));
666     EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
667     EXPECT_EQ(1, accept_calls);
668   }
669 }
670 int getaddrinfo_ret = 0;
671 int getaddrinfo_errno = 0;
672 const char* getaddrinfo_node = 0;
673 const char* getaddrinfo_service = 0;
674 struct addrinfo getaddrinfo_hints = {.ai_flags = 0,
675                                      .ai_family = 0,
676                                      .ai_socktype = 0,
677                                      .ai_protocol = 0,
678                                      .ai_addrlen = 0,
679                                      .ai_addr = 0,
680                                      .ai_canonname = 0,
681                                      .ai_next = 0};
682 struct addrinfo* getaddrinfo_res = 0;
683 int test_getaddrinfo(const char* node,
684                      const char* service,
685                      const struct addrinfo* hints,
686                      struct addrinfo** res) {
687   getaddrinfo_calls++;
688   EXPECT_STREQ(getaddrinfo_node, node);
689   EXPECT_STREQ(getaddrinfo_service, service);
690   EXPECT_TRUE(NULL != hints);
691   if (NULL != hints) {
692     EXPECT_TRUE(memcmp(hints, &amp;getaddrinfo_hints, sizeof(struct addrinfo)) ==
693                 0);
694   }
695   EXPECT_TRUE(NULL != res);
696   if (NULL != res) {
697     *res = getaddrinfo_res;
698   }
699   errno = getaddrinfo_errno;
700   return getaddrinfo_ret;
701 }
702 struct addrinfo* freeaddrinfo_res = 0;
703 void test_freeaddrinfo(struct addrinfo* res) {
704   freeaddrinfo_calls++;
705   EXPECT_EQ(freeaddrinfo_res, res);
706   return;
707 }
708 void EXPECT_SOCKADDR_EQ(const sockaddr* addr1, const sockaddr* addr2) {
709   EXPECT_EQ((NULL == addr1), (NULL == addr2));
710   if (NULL != addr1 &amp;&amp; NULL != addr2) {
711     EXPECT_EQ(addr1-&gt;sa_family, addr2-&gt;sa_family);
712     if (addr1-&gt;sa_family == addr2-&gt;sa_family) {
713       switch (addr1-&gt;sa_family) {
714       case AF_INET: {
715         const sockaddr_in* addr1_in = (const sockaddr_in*)addr1;
716         const sockaddr_in* addr2_in = (const sockaddr_in*)addr2;
717         EXPECT_EQ(addr1_in-&gt;sin_port, addr2_in-&gt;sin_port);
718         EXPECT_EQ(addr1_in-&gt;sin_addr.s_addr, addr2_in-&gt;sin_addr.s_addr);
719       } break;
720       case AF_INET6: {
721         const sockaddr_in6* addr1_in6 = (const sockaddr_in6*)addr1;
722         const sockaddr_in6* addr2_in6 = (const sockaddr_in6*)addr2;
723         EXPECT_EQ(addr1_in6-&gt;sin6_port, addr2_in6-&gt;sin6_port);
724         EXPECT_EQ(addr1_in6-&gt;sin6_flowinfo, addr2_in6-&gt;sin6_flowinfo);
725         EXPECT_EQ(addr1_in6-&gt;sin6_scope_id, addr2_in6-&gt;sin6_scope_id);
726         EXPECT_TRUE(
727             IN6_ARE_ADDR_EQUAL(&amp;addr1_in6-&gt;sin6_addr, &amp;addr2_in6-&gt;sin6_addr));
728         for (int i = 0; i &lt; 16; i++) {
729           EXPECT_EQ(addr1_in6-&gt;sin6_addr.s6_addr[i],
730                     addr2_in6-&gt;sin6_addr.s6_addr[i])
731               &lt;&lt; "IPv6 address mismstach at byte " &lt;&lt; i;
732         }
733       } break;
734       default:
735         ADD_FAILURE() &lt;&lt; "Unrecognized address type; cannot compare";
736       }
737     }
738   }
739 }
740 int connect_ret = 0;
741 int connect_errno = 0;
742 int connect_sockfd = 0;
743 const struct sockaddr* connect_addr = 0;
744 socklen_t connect_addrlen = 0;
745 int test_connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen) {
746   connect_calls++;
747   EXPECT_EQ(connect_sockfd, sockfd);
748   EXPECT_TRUE(NULL != addr);
749   EXPECT_EQ(connect_addrlen, addrlen);
750   EXPECT_SOCKADDR_EQ(connect_addr, addr);
751   errno = connect_errno;
752   return connect_ret;
753 }
754 class XmlRpcConnectTest : public XmlRpcSocketTest,
755                           XmlRpc::XmlRpcLogHandler,
756                           XmlRpc::XmlRpcErrorHandler {
757 public:
758   virtual void log(int level, const char* msg) {
759     last_level = level;
760     last_msg = msg;
761     std::cout &lt;&lt; "LOG(" &lt;&lt; level &lt;&lt; "):" &lt;&lt; msg;
762   }
763   virtual void error(const char* msg) {
764     last_error = msg;
765     std::cout &lt;&lt; "ERROR: " &lt;&lt; msg;
766   }
767   int last_level;
768   std::string last_msg;
769   std::string last_error;
770   void EXPECT_LOG(int level, const std::string&amp; msg) {
771     EXPECT_EQ(level, last_level);
772     EXPECT_EQ(msg, last_msg);
773   }
774   void EXPECT_ERROR(const std::string&amp; msg) {
775     EXPECT_EQ(msg, last_error);
776   }
777 protected:
778   void SetUp() {
779     XmlRpcSocketTest::SetUp();
780     fake_getaddrinfo = test_getaddrinfo;
781     fake_freeaddrinfo = test_freeaddrinfo;
782     fake_connect = test_connect;
783     XmlRpc::XmlRpcLogHandler::setLogHandler(this);
784 <a name="0"></a>    XmlRpc::XmlRpcErrorHandler::setErrorHandler(this);
785 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    addr_ip4_22.sin_family = AF_INET;
786     addr_ip4_22.sin_port = htons(22);
787     addr_ip4_22.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
788     addr_ip4_404.sin_family = AF_INET;
789     addr_ip4_404.sin_port = htons(404);
790     addr_ip4_404.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
791     addr_ip6_44.sin6_family = AF_INET6;
792     addr_ip6_44.sin6_port = htons(44);
793     addr_ip6_44.sin6_flowinfo = 0;
794     addr_ip6_44.sin6_addr = in6addr_loopback;
795     addr_ip6_44.sin6_scope_id = 0;
796     addr_ip6_404.sin6_family = AF_INET6;
797     addr_ip6_404.sin6_port = htons(404);
798     addr_ip6_404.sin6_flowinfo = 0;
799     addr_ip6_404.sin6_addr = in6addr_loopback;
800     addr_ip6_404.sin6_scope_id = 0;
801     info_ip4.ai_flags = 0;</b></font>
802     info_ip4.ai_family = AF_INET;
803     info_ip4.ai_socktype = SOCK_STREAM;
804     info_ip4.ai_protocol = 0;
805     info_ip4.ai_addrlen = sizeof(struct sockaddr_in);
806     info_ip4.ai_addr = (struct sockaddr*)&amp;addr_ip4_22;
807     info_ip4.ai_canonname = 0;
808     info_ip4.ai_next = 0;
809     info_ip6.ai_flags = 0;
810     info_ip6.ai_family = AF_INET6;
811     info_ip6.ai_socktype = SOCK_STREAM;
812     info_ip6.ai_protocol = 0;
813     info_ip6.ai_addrlen = sizeof(struct sockaddr_in6);
814     info_ip6.ai_addr = (struct sockaddr*)&amp;addr_ip6_44;
815     info_ip6.ai_canonname = 0;
816     info_ip6.ai_next = 0;
817     info_canon.ai_flags = 0;
818     info_canon.ai_family = 0;
819     info_canon.ai_socktype = 0;
820     info_canon.ai_protocol = 0;
821     info_canon.ai_addrlen = 0;
822     info_canon.ai_addr = 0;
823     info_canon.ai_canonname = 0;
824     info_canon.ai_next = 0;
825     getaddrinfo_hints.ai_family = AF_UNSPEC;
826     getaddrinfo_node = "nowhere.com";
827     getaddrinfo_service = 0;
828     connect_sockfd = 19;
829   }
830   void TestConnect() {
831     freeaddrinfo_res = getaddrinfo_res;
832     last_level = 0;
833     last_msg = "";
834     last_error = "";
835     getaddrinfo_calls = 0;
836     freeaddrinfo_calls = 0;
837     connect_calls = 0;
838     EXPECT_TRUE(XmlRpcSocket::connect(19, "nowhere.com", 404));
839     EXPECT_EQ(1, getaddrinfo_calls);
840     EXPECT_EQ(1, freeaddrinfo_calls);
841     EXPECT_EQ(1, connect_calls);
842   }
843   void TestLookupFail() {
844     freeaddrinfo_res = getaddrinfo_res;
845     last_level = 0;
846     last_msg = "";
847     last_error = "";
848     getaddrinfo_calls = 0;
849     freeaddrinfo_calls = 0;
850     connect_calls = 0;
851     EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
852     EXPECT_EQ(1, getaddrinfo_calls);
853     EXPECT_EQ(0, freeaddrinfo_calls);
854     EXPECT_EQ(0, connect_calls);
855   }
856   void TestConnectFail() {
857     freeaddrinfo_res = getaddrinfo_res;
858     last_level = 0;
859     last_msg = "";
860     last_error = "";
861     getaddrinfo_calls = 0;
862     freeaddrinfo_calls = 0;
863     connect_calls = 0;
864     EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
865     EXPECT_EQ(1, getaddrinfo_calls);
866     EXPECT_EQ(1, freeaddrinfo_calls);
867     EXPECT_EQ(1, connect_calls);
868   }
869   void TearDown() {
870     XmlRpcLogHandler::setLogHandler(NULL);
871     XmlRpcErrorHandler::setErrorHandler(NULL);
872     XmlRpcSocketTest::TearDown();
873   }
874   struct sockaddr_in addr_ip4_22;
875   struct sockaddr_in addr_ip4_404;
876   struct sockaddr_in6 addr_ip6_44;
877   struct sockaddr_in6 addr_ip6_404;
878   struct addrinfo info_ip4;
879   struct addrinfo info_ip6;
880   struct addrinfo info_canon;
881 };
882 TEST_F(XmlRpcConnectTest, connect_ipv4) {
883   getaddrinfo_ret = 0;
884   getaddrinfo_errno = 0;
885   connect_ret = 0;
886   connect_errno = 0;
887   connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
888   connect_addrlen = sizeof(struct sockaddr_in);
889   getaddrinfo_res = &amp;info_canon;
890   info_canon.ai_next = &amp;info_ip4;
891   info_ip4.ai_next = &amp;info_ip6;
892   info_ip6.ai_next = 0;
893   TestConnect();
894   getaddrinfo_res = &amp;info_canon;
895   info_canon.ai_next = &amp;info_ip6;
896   info_ip6.ai_next = &amp;info_ip4;
897   info_ip4.ai_next = 0;
898   TestConnect();
899   getaddrinfo_res = &amp;info_ip6;
900   info_ip6.ai_next = &amp;info_ip4;
901   info_ip4.ai_next = 0;
902   TestConnect();
903   getaddrinfo_res = &amp;info_ip4;
904   info_ip4.ai_next = &amp;info_ip6;
905   info_ip6.ai_next = 0;
906   TestConnect();
907 }
908 TEST_F(XmlRpcConnectTest, connect_ipv6) {
909   XmlRpcSocket::s_use_ipv6_ = true;
910   getaddrinfo_ret = 0;
911   getaddrinfo_errno = 0;
912   connect_ret = 0;
913   connect_errno = 0;
914   connect_addr = (struct sockaddr*)&amp;addr_ip6_404;
915   connect_addrlen = sizeof(struct sockaddr_in6);
916   getaddrinfo_res = &amp;info_ip4;
917   info_ip4.ai_next = &amp;info_ip6;
918   info_ip6.ai_next = 0;
919   TestConnect();
920   getaddrinfo_res = &amp;info_ip6;
921   info_ip6.ai_next = &amp;info_ip4;
922   info_ip4.ai_next = 0;
923   TestConnect();
924 }
925 TEST_F(XmlRpcConnectTest, connect_lookup_fail) {
926   connect_ret = 0;
927   connect_errno = 0;
928   connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
929   connect_addrlen = sizeof(struct sockaddr_in);
930   getaddrinfo_res = &amp;info_ip4;
931   info_ip4.ai_next = &amp;info_ip6;
932   info_ip6.ai_next = 0;
933   FOR_ERRNO(i,
934             addr_errs,
935             EAI_ADDRFAMILY,
936             EAI_AGAIN,
937             EAI_BADFLAGS,
938             EAI_FAIL,
939             EAI_FAMILY,
940             EAI_MEMORY,
941             EAI_NODATA,
942             EAI_NONAME,
943             EAI_SERVICE,
944             EAI_SOCKTYPE) {
945     getaddrinfo_ret = addr_errs[i];
946     getaddrinfo_errno = 0;
947     TestLookupFail();
948     EXPECT_ERROR(
949         std::string("Couldn't find an AF_INET address for [nowhere.com]: ") +
950         std::string(gai_strerror(addr_errs[i])) + std::string("\n"));
951   }
952   getaddrinfo_ret = EAI_SYSTEM;
953   FOR_ERRNO(i, errnos, ENFILE, EMFILE, EAGAIN, EINTR) {
954     getaddrinfo_errno = errnos[i];
955     TestLookupFail();
956     EXPECT_ERROR(
957         std::string("Couldn't find an AF_INET address for [nowhere.com]: ") +
958         std::string(strerror(errnos[i])) + std::string("\n"));
959   }
960   getaddrinfo_res = &amp;info_ip6;
961   info_ip6.ai_next = 0;
962   getaddrinfo_ret = 0;
963   getaddrinfo_errno = 0;
964   freeaddrinfo_res = getaddrinfo_res;
965   last_level = 0;
966   last_msg = "";
967   last_error = "";
968   getaddrinfo_calls = 0;
969   freeaddrinfo_calls = 0;
970   connect_calls = 0;
971   EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
972   EXPECT_EQ(1, getaddrinfo_calls);
973   EXPECT_EQ(1, freeaddrinfo_calls);
974   EXPECT_EQ(0, connect_calls);
975   EXPECT_ERROR(
976       std::string("Couldn't find an AF_INET address for [nowhere.com]") +
977       std::string("\n"));
978 }
979 TEST_F(XmlRpcConnectTest, connect_multiple_result) {}
980 TEST_F(XmlRpcConnectTest, connect_failure) {
981   getaddrinfo_ret = 0;
982   getaddrinfo_errno = 0;
983   connect_ret = 0;
984   connect_errno = 0;
985   connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
986   connect_addrlen = sizeof(struct sockaddr_in);
987   getaddrinfo_res = &amp;info_ip4;
988   info_ip4.ai_next = &amp;info_ip6;
989   info_ip6.ai_next = 0;
990   connect_ret = -1;
991   connect_errno = EINPROGRESS;
992   TestConnect();
993   EXPECT_ERROR("");
994   EXPECT_EQ(EWOULDBLOCK, EAGAIN);
995   connect_ret = -1;
996   connect_errno = EWOULDBLOCK;
997 #if defined(_WINDOWS)
998   TestConnect();
999   EXPECT_ERROR("");
1000 #else
1001   TestConnectFail();
1002   EXPECT_ERROR(std::string("::connect error = ") +
1003                std::string(strerror(EWOULDBLOCK)) + std::string("\n"));
1004 #endif
1005   FOR_ERRNO(i,
1006             errnos,
1007             EACCES,
1008             EPERM,
1009             EADDRINUSE,
1010             EAFNOSUPPORT,
1011             EALREADY,
1012             EBADF,
1013             ECONNREFUSED,
1014             EFAULT,
1015             EINTR,
1016             EISCONN,
1017             ENETUNREACH,
1018             ENOTSOCK,
1019             ETIMEDOUT) {
1020     connect_ret = -1;
1021     connect_errno = errnos[i];
1022     TestConnectFail();
1023     EXPECT_ERROR(std::string("::connect error = ") +
1024                  std::string(strerror(errnos[i])) + std::string("\n"));
1025   }
1026 }
1027 int main(int argc, char **argv)
1028 {
1029   ::testing::InitGoogleTest(&amp;argc, argv);
1030   return RUN_ALL_TESTS();
1031 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
