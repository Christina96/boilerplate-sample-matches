<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for approximate_time.h &amp; test_socket.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for approximate_time.h &amp; test_socket.cpp
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>approximate_time.h (1.9274377%)<th>test_socket.cpp (1.7763846%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(135-151)<td><a href="#" name="0">(1035-1055)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>approximate_time.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2009, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of the Willow Garage nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

#ifndef MESSAGE_FILTERS_SYNC_APPROXIMATE_TIME_H
#define MESSAGE_FILTERS_SYNC_APPROXIMATE_TIME_H

#include "message_filters/synchronizer.h"
#include "message_filters/connection.h"
#include "message_filters/null_types.h"
#include "message_filters/signal9.h"

#include &lt;boost/tuple/tuple.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;boost/function.hpp&gt;
#include &lt;boost/thread/mutex.hpp&gt;

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/type_traits/is_same.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/mpl/or.hpp&gt;
#include &lt;boost/mpl/at.hpp&gt;
#include &lt;boost/mpl/vector.hpp&gt;

#include &lt;ros/assert.h&gt;
#include &lt;ros/message_traits.h&gt;
#include &lt;ros/message_event.h&gt;

#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

namespace message_filters
{
namespace sync_policies
{

namespace mpl = boost::mpl;

template&lt;typename M0, typename M1, typename M2 = NullType, typename M3 = NullType, typename M4 = NullType,
         typename M5 = NullType, typename M6 = NullType, typename M7 = NullType, typename M8 = NullType&gt;
struct ApproximateTime : public PolicyBase&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt;
{
  typedef Synchronizer&lt;ApproximateTime&gt; Sync;
  typedef PolicyBase&lt;M0, M1, M2, M3, M4, M5, M6, M7, M8&gt; Super;
  typedef typename Super::Messages Messages;
  typedef typename Super::Signal Signal;
  typedef typename Super::Events Events;
  typedef typename Super::RealTypeCount RealTypeCount;
  typedef typename Super::M0Event M0Event;
  typedef typename Super::M1Event M1Event;
  typedef typename Super::M2Event M2Event;
  typedef typename Super::M3Event M3Event;
  typedef typename Super::M4Event M4Event;
  typedef typename Super::M5Event M5Event;
  typedef typename Super::M6Event M6Event;
  typedef typename Super::M7Event M7Event;
  typedef typename Super::M8Event M8Event;
  typedef std::deque&lt;M0Event&gt; M0Deque;
  typedef std::deque&lt;M1Event&gt; M1Deque;
  typedef std::deque&lt;M2Event&gt; M2Deque;
  typedef std::deque&lt;M3Event&gt; M3Deque;
  typedef std::deque&lt;M4Event&gt; M4Deque;
  typedef std::deque&lt;M5Event&gt; M5Deque;
  typedef std::deque&lt;M6Event&gt; M6Deque;
  typedef std::deque&lt;M7Event&gt; M7Deque;
  typedef std::deque&lt;M8Event&gt; M8Deque;
  typedef std::vector&lt;M0Event&gt; M0Vector;
  typedef std::vector&lt;M1Event&gt; M1Vector;
  typedef std::vector&lt;M2Event&gt; M2Vector;
  typedef std::vector&lt;M3Event&gt; M3Vector;
  typedef std::vector&lt;M4Event&gt; M4Vector;
  typedef std::vector&lt;M5Event&gt; M5Vector;
  typedef std::vector&lt;M6Event&gt; M6Vector;
  typedef std::vector&lt;M7Event&gt; M7Vector;
  typedef std::vector&lt;M8Event&gt; M8Vector;
  typedef boost::tuple&lt;M0Event, M1Event, M2Event, M3Event, M4Event, M5Event, M6Event, M7Event, M8Event&gt; Tuple;
  typedef boost::tuple&lt;M0Deque, M1Deque, M2Deque, M3Deque, M4Deque, M5Deque, M6Deque, M7Deque, M8Deque&gt; DequeTuple;
  typedef boost::tuple&lt;M0Vector, M1Vector, M2Vector, M3Vector, M4Vector, M5Vector, M6Vector, M7Vector, M8Vector&gt; VectorTuple;

  ApproximateTime(uint32_t queue_size)
  : parent_(0)
  , queue_size_(queue_size)
  , enable_reset_(false)
  , num_reset_deques_(0)
  , num_non_empty_deques_(0)
  , pivot_(NO_PIVOT)
  , max_interval_duration_(ros::DURATION_MAX)
  , age_penalty_(0.1)
  , has_dropped_messages_(9, false)
  , inter_message_lower_bounds_(9, ros::Duration(0))
  , warned_about_incorrect_bound_(9, false)
  , last_stamps_(9, ros::Time(0, 0))
  {
    ROS_ASSERT(queue_size_ &gt; 0);  // The synchronizer will tend to drop many messages with a queue size of 1. At least 2 is recommended.
  }

  ApproximateTime(const ApproximateTime&amp; e)
  {
    *this = e;
  }
<a name="0"></a>
  ApproximateTime&amp; operator=(const ApproximateTime&amp; rhs)
  {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    parent_ = rhs.parent_;
    queue_size_ = rhs.queue_size_;
    num_non_empty_deques_ = rhs.num_non_empty_deques_;
    pivot_time_ = rhs.pivot_time_;
    pivot_ = rhs.pivot_;
    max_interval_duration_ = rhs.max_interval_duration_;
    age_penalty_ = rhs.age_penalty_;
    candidate_start_ = rhs.candidate_start_;
    candidate_end_ = rhs.candidate_end_;
    deques_ = rhs.deques_;
    past_ = rhs.past_;
    has_dropped_messages_ = rhs.has_dropped_messages_;
    inter_message_lower_bounds_ = rhs.inter_message_lower_bounds_;
    warned_about_incorrect_bound_ = rhs.warned_about_incorrect_bound_;
    last_stamps_ = rhs.last_stamps_;
    enable_reset_ = rhs.enable_reset_;
    num_reset_deques_ = rhs.num_reset_deques_;</b></font>

    return *this;
  }

  void initParent(Sync* parent)
  {
    parent_ = parent;
  }

  template&lt;int i&gt;
  bool checkInterMessageBound()
  {
    namespace mt = ros::message_traits;

    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    ROS_ASSERT(!deque.empty());
    const typename mpl::at_c&lt;Messages, i&gt;::type &amp;msg = *(deque.back()).getMessage();
    ros::Time msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(msg);
    ros::Time previous_msg_time;
    bool check_ok = true;
    if (deque.size() == (size_t) 1)
    {
      if (v.empty())
      {
        // We have already published (or have never received) the previous message, we cannot check the bound
        return check_ok;
      }
      const typename mpl::at_c&lt;Messages, i&gt;::type &amp;previous_msg = *(v.back()).getMessage();
      previous_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(previous_msg);
    }
    else
    {
      // There are at least 2 elements in the deque. Check that the gap respects the bound if it was provided.
      const typename mpl::at_c&lt;Messages, i&gt;::type &amp;previous_msg = *(deque[deque.size()-2]).getMessage();
      previous_msg_time =  mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(previous_msg);
    }
    if (msg_time &lt; previous_msg_time)
    {
      if (!warned_about_incorrect_bound_[i])
        ROS_WARN_STREAM("Messages of type " &lt;&lt; i &lt;&lt; " arrived out of order (will print only once)");
      warned_about_incorrect_bound_[i] = true;
      check_ok = false;
    }
    else if ((msg_time - previous_msg_time) &lt; inter_message_lower_bounds_[i])
    {
      if (!warned_about_incorrect_bound_[i])
        ROS_WARN_STREAM("Messages of type " &lt;&lt; i &lt;&lt; " arrived closer (" &lt;&lt; (msg_time - previous_msg_time)
                        &lt;&lt; ") than the lower bound you provided (" &lt;&lt; inter_message_lower_bounds_[i]
                        &lt;&lt; ") (will print only once)");
      warned_about_incorrect_bound_[i] = true;
      check_ok = false;
    }
    return check_ok;
  }


  template&lt;int i&gt;
  void add(const typename mpl::at_c&lt;Events, i&gt;::type&amp; evt)
  {
    boost::mutex::scoped_lock lock(data_mutex_);

    // check if time jumped back in simulation time
    ros::Time now = evt.getReceiptTime();
    if (ros::Time::isSimTime() &amp;&amp; enable_reset_)
    {
      if (now &lt; last_stamps_[i])
      {
        ++num_reset_deques_;
        if (num_reset_deques_ == 1)
        {
          ROS_WARN("Detected jump back in time. Clearing message filter queues");
        }
        clearDeque&lt;i&gt;();
        if (num_reset_deques_ &gt;= RealTypeCount::value)
        {
          num_reset_deques_ = 0;
        }
      }
    }
    last_stamps_[i] = now;

    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
    deque.push_back(evt);
    if (deque.size() == (size_t)1) {
      // We have just added the first message, so it was empty before
      ++num_non_empty_deques_;
      if (num_non_empty_deques_ == (uint32_t)RealTypeCount::value)
      {
        // All deques have messages
        process();
      }
    }
    else
    {
      if (!checkInterMessageBound&lt;i&gt;())
        if (ros::Time::isSimTime() &amp;&amp; enable_reset_)
        {
          dequeDeleteFront&lt;i&gt;();
        }
    }
    // Check whether we have more messages than allowed in the queue.
    // Note that during the above call to process(), queue i may contain queue_size_+1 messages.
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; past = boost::get&lt;i&gt;(past_);
    if (deque.size() + past.size() &gt; queue_size_)
    {
      // Cancel ongoing candidate search, if any:
      num_non_empty_deques_ = 0; // We will recompute it from scratch
      recover&lt;0&gt;();
      recover&lt;1&gt;();
      recover&lt;2&gt;();
      recover&lt;3&gt;();
      recover&lt;4&gt;();
      recover&lt;5&gt;();
      recover&lt;6&gt;();
      recover&lt;7&gt;();
      recover&lt;8&gt;();
      // Drop the oldest message in the offending topic
      ROS_ASSERT(!deque.empty());
      deque.pop_front();
      has_dropped_messages_[i] = true;
      if (pivot_ != NO_PIVOT)
      {
	// The candidate is no longer valid. Destroy it.
	candidate_ = Tuple();
	pivot_ = NO_PIVOT;
	// There might still be enough messages to create a new candidate:
	process();
      }
    }
  }

  void setAgePenalty(double age_penalty)
  {
    // For correctness we only need age_penalty &gt; -1.0, but most likely a negative age_penalty is a mistake.
    ROS_ASSERT(age_penalty &gt;= 0);
    age_penalty_ = age_penalty;
  }

  void setInterMessageLowerBound(int i, ros::Duration lower_bound) {
    ROS_ASSERT(lower_bound &gt;= ros::Duration(0,0));
    inter_message_lower_bounds_[i] = lower_bound;
  }

  void setInterMessageLowerBound(ros::Duration lower_bound) {
    ROS_ASSERT(lower_bound &gt;= ros::Duration(0,0));
    for (size_t i = 0; i &lt; inter_message_lower_bounds_.size(); i++)
    {
      inter_message_lower_bounds_[i] = lower_bound;
    }
  }

  void setMaxIntervalDuration(ros::Duration max_interval_duration) {
    ROS_ASSERT(max_interval_duration &gt;= ros::Duration(0,0));
    max_interval_duration_ = max_interval_duration;
  }

  void setReset(const bool reset)
  {
    // Set this true to reset queue on ROS time jumped back
    enable_reset_ = reset;
  }

private:
  template&lt;int i&gt;
  void clearDeque()
  {
    num_non_empty_deques_ = 0;
    recover&lt;0&gt;();
    recover&lt;1&gt;();
    recover&lt;2&gt;();
    recover&lt;3&gt;();
    recover&lt;4&gt;();
    recover&lt;5&gt;();
    recover&lt;6&gt;();
    recover&lt;7&gt;();
    recover&lt;8&gt;();
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    if (!q.empty())
    {
      --num_non_empty_deques_;
    }
    q.clear();
    warned_about_incorrect_bound_[i] = false;
    candidate_ = Tuple();
    pivot_ = NO_PIVOT;
  }

  // Assumes that deque number &lt;index&gt; is non empty
  template&lt;int i&gt;
  void dequeDeleteFront()
  {
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
    ROS_ASSERT(!deque.empty());
    deque.pop_front();
    if (deque.empty())
    {
      --num_non_empty_deques_;
    }
  }

  // Assumes that deque number &lt;index&gt; is non empty
  void dequeDeleteFront(uint32_t index)
  {
    switch (index)
    {
    case 0:
      dequeDeleteFront&lt;0&gt;();
      break;
    case 1:
      dequeDeleteFront&lt;1&gt;();
      break;
    case 2:
      dequeDeleteFront&lt;2&gt;();
      break;
    case 3:
      dequeDeleteFront&lt;3&gt;();
      break;
    case 4:
      dequeDeleteFront&lt;4&gt;();
      break;
    case 5:
      dequeDeleteFront&lt;5&gt;();
      break;
    case 6:
      dequeDeleteFront&lt;6&gt;();
      break;
    case 7:
      dequeDeleteFront&lt;7&gt;();
      break;
    case 8:
      dequeDeleteFront&lt;8&gt;();
      break;
    default:
      ROS_BREAK();
    }
  }

  // Assumes that deque number &lt;index&gt; is non empty
  template&lt;int i&gt;
  void dequeMoveFrontToPast()
  {
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; deque = boost::get&lt;i&gt;(deques_);
    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; vector = boost::get&lt;i&gt;(past_);
    ROS_ASSERT(!deque.empty());
    vector.push_back(deque.front());
    deque.pop_front();
    if (deque.empty())
    {
      --num_non_empty_deques_;
    }
  }
  // Assumes that deque number &lt;index&gt; is non empty
  void dequeMoveFrontToPast(uint32_t index)
  {
    switch (index)
    {
    case 0:
      dequeMoveFrontToPast&lt;0&gt;();
      break;
    case 1:
      dequeMoveFrontToPast&lt;1&gt;();
      break;
    case 2:
      dequeMoveFrontToPast&lt;2&gt;();
      break;
    case 3:
      dequeMoveFrontToPast&lt;3&gt;();
      break;
    case 4:
      dequeMoveFrontToPast&lt;4&gt;();
      break;
    case 5:
      dequeMoveFrontToPast&lt;5&gt;();
      break;
    case 6:
      dequeMoveFrontToPast&lt;6&gt;();
      break;
    case 7:
      dequeMoveFrontToPast&lt;7&gt;();
      break;
    case 8:
      dequeMoveFrontToPast&lt;8&gt;();
      break;
    default:
      ROS_BREAK();
    }
  }

  void makeCandidate()
  {
    //printf("Creating candidate\n");
    // Create candidate tuple
    candidate_ = Tuple(); // Discards old one if any
    boost::get&lt;0&gt;(candidate_) = boost::get&lt;0&gt;(deques_).front();
    boost::get&lt;1&gt;(candidate_) = boost::get&lt;1&gt;(deques_).front();
    if (RealTypeCount::value &gt; 2)
    {
      boost::get&lt;2&gt;(candidate_) = boost::get&lt;2&gt;(deques_).front();
      if (RealTypeCount::value &gt; 3)
      {
	boost::get&lt;3&gt;(candidate_) = boost::get&lt;3&gt;(deques_).front();
	if (RealTypeCount::value &gt; 4)
	{
	  boost::get&lt;4&gt;(candidate_) = boost::get&lt;4&gt;(deques_).front();
	  if (RealTypeCount::value &gt; 5)
	  {
	    boost::get&lt;5&gt;(candidate_) = boost::get&lt;5&gt;(deques_).front();
	    if (RealTypeCount::value &gt; 6)
	    {
	      boost::get&lt;6&gt;(candidate_) = boost::get&lt;6&gt;(deques_).front();
	      if (RealTypeCount::value &gt; 7)
	      {
		boost::get&lt;7&gt;(candidate_) = boost::get&lt;7&gt;(deques_).front();
		if (RealTypeCount::value &gt; 8)
		{
		  boost::get&lt;8&gt;(candidate_) = boost::get&lt;8&gt;(deques_).front();
		}
	      }
	    }
	  }
	}
      }
    }
    // Delete all past messages, since we have found a better candidate
    boost::get&lt;0&gt;(past_).clear();
    boost::get&lt;1&gt;(past_).clear();
    boost::get&lt;2&gt;(past_).clear();
    boost::get&lt;3&gt;(past_).clear();
    boost::get&lt;4&gt;(past_).clear();
    boost::get&lt;5&gt;(past_).clear();
    boost::get&lt;6&gt;(past_).clear();
    boost::get&lt;7&gt;(past_).clear();
    boost::get&lt;8&gt;(past_).clear();
    //printf("Candidate created\n");
  }


  // ASSUMES: num_messages &lt;= past_[i].size()
  template&lt;int i&gt;
  void recover(size_t num_messages)
  {
    if (i &gt;= RealTypeCount::value)
    {
      return;
    }

    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    ROS_ASSERT(num_messages &lt;= v.size());
    while (num_messages &gt; 0)
    {
      q.push_front(v.back());
      v.pop_back();
      num_messages--;
    }

    if (!q.empty())
    {
      ++num_non_empty_deques_;
    }
  }


  template&lt;int i&gt;
  void recover()
  {
    if (i &gt;= RealTypeCount::value)
    {
      return;
    }

    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    while (!v.empty())
    {
      q.push_front(v.back());
      v.pop_back();
    }

    if (!q.empty())
    {
      ++num_non_empty_deques_;
    }
  }


  template&lt;int i&gt;
  void recoverAndDelete()
  {
    if (i &gt;= RealTypeCount::value)
    {
      return;
    }

    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    while (!v.empty())
    {
      q.push_front(v.back());
      v.pop_back();
    }

    ROS_ASSERT(!q.empty());

    q.pop_front();
    if (!q.empty())
    {
      ++num_non_empty_deques_;
    }
  }

  // Assumes: all deques are non empty, i.e. num_non_empty_deques_ == RealTypeCount::value
  void publishCandidate()
  {
    //printf("Publishing candidate\n");
    // Publish
    parent_-&gt;signal(boost::get&lt;0&gt;(candidate_), boost::get&lt;1&gt;(candidate_), boost::get&lt;2&gt;(candidate_), boost::get&lt;3&gt;(candidate_),
                    boost::get&lt;4&gt;(candidate_), boost::get&lt;5&gt;(candidate_), boost::get&lt;6&gt;(candidate_), boost::get&lt;7&gt;(candidate_),
                    boost::get&lt;8&gt;(candidate_));
    // Delete this candidate
    candidate_ = Tuple();
    pivot_ = NO_PIVOT;

    // Recover hidden messages, and delete the ones corresponding to the candidate
    num_non_empty_deques_ = 0; // We will recompute it from scratch
    recoverAndDelete&lt;0&gt;();
    recoverAndDelete&lt;1&gt;();
    recoverAndDelete&lt;2&gt;();
    recoverAndDelete&lt;3&gt;();
    recoverAndDelete&lt;4&gt;();
    recoverAndDelete&lt;5&gt;();
    recoverAndDelete&lt;6&gt;();
    recoverAndDelete&lt;7&gt;();
    recoverAndDelete&lt;8&gt;();
  }

  // Assumes: all deques are non empty, i.e. num_non_empty_deques_ == RealTypeCount::value
  // Returns: the oldest message on the deques
  void getCandidateStart(uint32_t &amp;start_index, ros::Time &amp;start_time)
  {
    return getCandidateBoundary(start_index, start_time, false);
  }

  // Assumes: all deques are non empty, i.e. num_non_empty_deques_ == RealTypeCount::value
  // Returns: the latest message among the heads of the deques, i.e. the minimum
  //          time to end an interval started at getCandidateStart_index()
  void getCandidateEnd(uint32_t &amp;end_index, ros::Time &amp;end_time)
  {
    return getCandidateBoundary(end_index, end_time, true);
  }

  // ASSUMES: all deques are non-empty
  // end = true: look for the latest head of deque
  //       false: look for the earliest head of deque
  void getCandidateBoundary(uint32_t &amp;index, ros::Time &amp;time, bool end)
  {
    namespace mt = ros::message_traits;

    M0Event&amp; m0 = boost::get&lt;0&gt;(deques_).front();
    time = mt::TimeStamp&lt;M0&gt;::value(*m0.getMessage());
    index = 0;
    if (RealTypeCount::value &gt; 1)
    {
      M1Event&amp; m1 = boost::get&lt;1&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M1&gt;::value(*m1.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M1&gt;::value(*m1.getMessage());
        index = 1;
      }
    }
    if (RealTypeCount::value &gt; 2)
    {
      M2Event&amp; m2 = boost::get&lt;2&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M2&gt;::value(*m2.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M2&gt;::value(*m2.getMessage());
        index = 2;
      }
    }
    if (RealTypeCount::value &gt; 3)
    {
      M3Event&amp; m3 = boost::get&lt;3&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M3&gt;::value(*m3.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M3&gt;::value(*m3.getMessage());
        index = 3;
      }
    }
    if (RealTypeCount::value &gt; 4)
    {
      M4Event&amp; m4 = boost::get&lt;4&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M4&gt;::value(*m4.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M4&gt;::value(*m4.getMessage());
        index = 4;
      }
    }
    if (RealTypeCount::value &gt; 5)
    {
      M5Event&amp; m5 = boost::get&lt;5&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M5&gt;::value(*m5.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M5&gt;::value(*m5.getMessage());
        index = 5;
      }
    }
    if (RealTypeCount::value &gt; 6)
    {
      M6Event&amp; m6 = boost::get&lt;6&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M6&gt;::value(*m6.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M6&gt;::value(*m6.getMessage());
        index = 6;
      }
    }
    if (RealTypeCount::value &gt; 7)
    {
      M7Event&amp; m7 = boost::get&lt;7&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M7&gt;::value(*m7.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M7&gt;::value(*m7.getMessage());
        index = 7;
      }
    }
    if (RealTypeCount::value &gt; 8)
    {
      M8Event&amp; m8 = boost::get&lt;8&gt;(deques_).front();
      if ((mt::TimeStamp&lt;M8&gt;::value(*m8.getMessage()) &lt; time) ^ end)
      {
        time = mt::TimeStamp&lt;M8&gt;::value(*m8.getMessage());
        index = 8;
      }
    }
  }


  // ASSUMES: we have a pivot and candidate
  template&lt;int i&gt;
  ros::Time getVirtualTime()
  {
    namespace mt = ros::message_traits;

    if (i &gt;= RealTypeCount::value)
    {
      return ros::Time(0,0);  // Dummy return value
    }
    ROS_ASSERT(pivot_ != NO_PIVOT);

    std::vector&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; v = boost::get&lt;i&gt;(past_);
    std::deque&lt;typename mpl::at_c&lt;Events, i&gt;::type&gt;&amp; q = boost::get&lt;i&gt;(deques_);
    if (q.empty())
    {
      ROS_ASSERT(!v.empty());  // Because we have a candidate
      ros::Time last_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(*(v.back()).getMessage());
      ros::Time msg_time_lower_bound = last_msg_time + inter_message_lower_bounds_[i];
      if (msg_time_lower_bound &gt; pivot_time_)  // Take the max
      {
        return msg_time_lower_bound;
      }
      return pivot_time_;
    }
    ros::Time current_msg_time = mt::TimeStamp&lt;typename mpl::at_c&lt;Messages, i&gt;::type&gt;::value(*(q.front()).getMessage());
    return current_msg_time;
  }


  // ASSUMES: we have a pivot and candidate
  void getVirtualCandidateStart(uint32_t &amp;start_index, ros::Time &amp;start_time)
  {
    return getVirtualCandidateBoundary(start_index, start_time, false);
  }

  // ASSUMES: we have a pivot and candidate
  void getVirtualCandidateEnd(uint32_t &amp;end_index, ros::Time &amp;end_time)
  {
    return getVirtualCandidateBoundary(end_index, end_time, true);
  }

  // ASSUMES: we have a pivot and candidate
  // end = true: look for the latest head of deque
  //       false: look for the earliest head of deque
  void getVirtualCandidateBoundary(uint32_t &amp;index, ros::Time &amp;time, bool end)
  {
    namespace mt = ros::message_traits;

    std::vector&lt;ros::Time&gt; virtual_times(9);
    virtual_times[0] = getVirtualTime&lt;0&gt;();
    virtual_times[1] = getVirtualTime&lt;1&gt;();
    virtual_times[2] = getVirtualTime&lt;2&gt;();
    virtual_times[3] = getVirtualTime&lt;3&gt;();
    virtual_times[4] = getVirtualTime&lt;4&gt;();
    virtual_times[5] = getVirtualTime&lt;5&gt;();
    virtual_times[6] = getVirtualTime&lt;6&gt;();
    virtual_times[7] = getVirtualTime&lt;7&gt;();
    virtual_times[8] = getVirtualTime&lt;8&gt;();
 
    time = virtual_times[0];
    index = 0;
    for (int i = 0; i &lt; RealTypeCount::value; i++)
    {
      if ((virtual_times[i] &lt; time) ^ end)
      {
	time = virtual_times[i];
	index = i;
      }
    }
  }


  // assumes data_mutex_ is already locked
  void process()
  {
    // While no deque is empty
    while (num_non_empty_deques_ == (uint32_t)RealTypeCount::value)
    {
      // Find the start and end of the current interval
      //printf("Entering while loop in this state [\n");
      //show_internal_state();
      //printf("]\n");
      ros::Time end_time, start_time;
      uint32_t end_index, start_index;
      getCandidateEnd(end_index, end_time);
      getCandidateStart(start_index, start_time);
      for (uint32_t i = 0; i &lt; (uint32_t)RealTypeCount::value; i++)
      {
	if (i != end_index)
	{
	  // No dropped message could have been better to use than the ones we have,
	  // so it becomes ok to use this topic as pivot in the future
	  has_dropped_messages_[i] = false;
	}
      }
      if (pivot_ == NO_PIVOT)
      {
        // We do not have a candidate
        // INVARIANT: the past_ vectors are empty
        // INVARIANT: (candidate_ has no filled members)
        if (end_time - start_time &gt; max_interval_duration_)
        {
          // This interval is too big to be a valid candidate, move to the next
          dequeDeleteFront(start_index);
          continue;
        }
	if (has_dropped_messages_[end_index])
	{
	  // The topic that would become pivot has dropped messages, so it is not a good pivot
	  dequeDeleteFront(start_index);
	  continue;
	}
	// This is a valid candidate, and we don't have any, so take it
	makeCandidate();
	candidate_start_ = start_time;
	candidate_end_ = end_time;
	pivot_ = end_index;
	pivot_time_ = end_time;
	dequeMoveFrontToPast(start_index);
      }
      else
      {
        // We already have a candidate
        // Is this one better than the current candidate?
        // INVARIANT: has_dropped_messages_ is all false
        if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (start_time - candidate_start_))
        {
          // This is not a better candidate, move to the next
          dequeMoveFrontToPast(start_index);
        }
        else
        {
          // This is a better candidate
          makeCandidate();
          candidate_start_ = start_time;
          candidate_end_ = end_time;
          dequeMoveFrontToPast(start_index);
          // Keep the same pivot (and pivot time)
        }
      }
      // INVARIANT: we have a candidate and pivot
      ROS_ASSERT(pivot_ != NO_PIVOT);
      //printf("start_index == %d, pivot_ == %d\n", start_index, pivot_);
      if (start_index == pivot_)  // TODO: replace with start_time == pivot_time_
      {
        // We have exhausted all possible candidates for this pivot, we now can output the best one
        publishCandidate();
      }
      else if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (pivot_time_ - candidate_start_))
      {
        // We have not exhausted all candidates, but this candidate is already provably optimal
        // Indeed, any future candidate must contain the interval [pivot_time_ end_time], which
        // is already too big.
        // Note: this case is subsumed by the next, but it may save some unnecessary work and
        //       it makes things (a little) easier to understand
        publishCandidate();
      }
      else if (num_non_empty_deques_ &lt; (uint32_t)RealTypeCount::value)
      {
        uint32_t num_non_empty_deques_before_virtual_search = num_non_empty_deques_;

        // Before giving up, use the rate bounds, if provided, to further try to prove optimality
        std::vector&lt;int&gt; num_virtual_moves(9,0);
        while (1)
        {
          ros::Time end_time, start_time;
          uint32_t end_index, start_index;
          getVirtualCandidateEnd(end_index, end_time);
          getVirtualCandidateStart(start_index, start_time);
          if ((end_time - candidate_end_) * (1 + age_penalty_) &gt;= (pivot_time_ - candidate_start_))
          {
            // We have proved optimality
            // As above, any future candidate must contain the interval [pivot_time_ end_time], which
            // is already too big.
            publishCandidate();  // This cleans up the virtual moves as a byproduct
            break;  // From the while(1) loop only
          }
          if ((end_time - candidate_end_) * (1 + age_penalty_) &lt; (start_time - candidate_start_))
          {
            // We cannot prove optimality
            // Indeed, we have a virtual (i.e. optimistic) candidate that is better than the current
            // candidate
            // Cleanup the virtual search:
            num_non_empty_deques_ = 0; // We will recompute it from scratch
	    recover&lt;0&gt;(num_virtual_moves[0]);
	    recover&lt;1&gt;(num_virtual_moves[1]);
	    recover&lt;2&gt;(num_virtual_moves[2]);
	    recover&lt;3&gt;(num_virtual_moves[3]);
	    recover&lt;4&gt;(num_virtual_moves[4]);
	    recover&lt;5&gt;(num_virtual_moves[5]);
	    recover&lt;6&gt;(num_virtual_moves[6]);
	    recover&lt;7&gt;(num_virtual_moves[7]);
	    recover&lt;8&gt;(num_virtual_moves[8]);
            (void)num_non_empty_deques_before_virtual_search; // unused variable warning stopper
            ROS_ASSERT(num_non_empty_deques_before_virtual_search == num_non_empty_deques_);
            break;
          }
          // Note: we cannot reach this point with start_index == pivot_ since in that case we would
          //       have start_time == pivot_time, in which case the two tests above are the negation
          //       of each other, so that one must be true. Therefore the while loop always terminates.
	  ROS_ASSERT(start_index != pivot_);
	  ROS_ASSERT(start_time &lt; pivot_time_);
          dequeMoveFrontToPast(start_index);
          num_virtual_moves[start_index]++;
        } // while(1)
      }
    } // while(num_non_empty_deques_ == (uint32_t)RealTypeCount::value)
  }

  Sync* parent_;
  uint32_t queue_size_;
  bool enable_reset_;
  uint32_t num_reset_deques_;

  static const uint32_t NO_PIVOT = 9;  // Special value for the pivot indicating that no pivot has been selected

  DequeTuple deques_;
  uint32_t num_non_empty_deques_;
  VectorTuple past_;
  Tuple candidate_;  // NULL if there is no candidate, in which case there is no pivot.
  ros::Time candidate_start_;
  ros::Time candidate_end_;
  ros::Time pivot_time_;
  uint32_t pivot_;  // Equal to NO_PIVOT if there is no candidate
  boost::mutex data_mutex_;  // Protects all of the above

  ros::Duration max_interval_duration_; // TODO: initialize with a parameter
  double age_penalty_;

  std::vector&lt;bool&gt; has_dropped_messages_;
  std::vector&lt;ros::Duration&gt; inter_message_lower_bounds_;
  std::vector&lt;bool&gt; warned_about_incorrect_bound_;
  std::vector&lt;ros::Time&gt; last_stamps_;
};

} // namespace sync
} // namespace message_filters

#endif // MESSAGE_FILTERS_SYNC_APPROXIMATE_TIME_H

</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_socket.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Unit tests for XmlRpc++
 *
 * Copyright (C) 2017, Zoox Inc
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Austin Hendrix &lt;austin@zoox.com&gt;
 *
 */

#include "xmlrpcpp/XmlRpcUtil.h"
#include "xmlrpcpp/XmlRpcSocket.h"
#include "test_system_mocks.h"

#include &lt;arpa/inet.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#include &lt;deque&gt;

#include &lt;gtest/gtest.h&gt;

#define FOR_ERRNO(itr, var, ...)                                               \
  int var[] = {__VA_ARGS__};                                                   \
  for (size_t itr = 0; itr &lt; sizeof(var) / sizeof(int); itr++)

using XmlRpc::XmlRpcSocket;

class XmlRpcSocketTest : public ::testing::Test {
protected:
  void SetUp() {
    accept_calls = 0;
    bind_calls = 0;
    close_calls = 0;
    connect_calls = 0;
    fcntl_calls = 0;
    listen_calls = 0;
    read_calls = 0;
    select_calls = 0;
    socket_calls = 0;
    write_calls = 0;

    XmlRpc::setVerbosity(5);
    XmlRpcSocket::s_use_ipv6_ = false;
  }

  void TearDown() {
    fake_accept = 0;
    fake_bind = 0;
    fake_close = 0;
    fake_connect = 0;
    fake_fcntl = 0;
    fake_listen = 0;
    fake_read = 0;
    fake_select = 0;
    fake_socket = 0;
    fake_write = 0;
  }
};

TEST_F(XmlRpcSocketTest, TestMocks) {
  EXPECT_EQ(0, fake_accept);
  EXPECT_EQ(0, accept_calls);
  fake_accept = count_accept;
  EXPECT_EQ(0, accept(0, 0, 0));
  EXPECT_EQ(1, accept_calls);

  EXPECT_EQ(0, fake_bind);
  EXPECT_EQ(0, bind_calls);
  fake_bind = count_bind;
  EXPECT_EQ(0, bind(0, 0, 0));
  EXPECT_EQ(1, bind_calls);

  EXPECT_EQ(0, fake_close);
  EXPECT_EQ(0, close_calls);
  fake_close = count_close;
  EXPECT_EQ(0, close(-1));
  EXPECT_EQ(1, close_calls);

  EXPECT_EQ(0, fake_connect);
  EXPECT_EQ(0, connect_calls);
  fake_connect = count_connect;
  EXPECT_EQ(0, connect(0, 0, 0));
  EXPECT_EQ(1, connect_calls);

  EXPECT_EQ(0, fake_fcntl);
  EXPECT_EQ(0, fcntl_calls);
  fake_fcntl = count_fcntl;
  EXPECT_EQ(0, fcntl(0, 0, 0));
  EXPECT_EQ(1, fcntl_calls);

  EXPECT_EQ(0, fake_freeaddrinfo);
  EXPECT_EQ(0, freeaddrinfo_calls);
  fake_freeaddrinfo = count_freeaddrinfo;
  freeaddrinfo(0);
  EXPECT_EQ(1, freeaddrinfo_calls);

  EXPECT_EQ(0, fake_getaddrinfo);
  EXPECT_EQ(0, getaddrinfo_calls);
  fake_getaddrinfo = count_getaddrinfo;
  EXPECT_EQ(0, getaddrinfo(0, 0, 0, 0));
  EXPECT_EQ(1, getaddrinfo_calls);

  EXPECT_EQ(0, fake_getsockname);
  EXPECT_EQ(0, getsockname_calls);
  fake_getsockname = count_getsockname;
  EXPECT_EQ(0, getsockname(0, 0, 0));
  EXPECT_EQ(1, getsockname_calls);

  EXPECT_EQ(0, fake_listen);
  EXPECT_EQ(0, listen_calls);
  fake_listen = count_listen;
  EXPECT_EQ(0, listen(0, 0));
  EXPECT_EQ(1, listen_calls);

  EXPECT_EQ(0, fake_read);
  EXPECT_EQ(0, read_calls);
  fake_read = count_read;
  EXPECT_EQ(0, read(0, 0, 0));
  EXPECT_EQ(1, read_calls);

  EXPECT_EQ(0, fake_setsockopt);
  EXPECT_EQ(0, setsockopt_calls);
  fake_setsockopt = count_setsockopt;
  EXPECT_EQ(0, setsockopt(0, 0, 0, 0, 0));
  EXPECT_EQ(1, setsockopt_calls);

  EXPECT_EQ(0, fake_select);
  EXPECT_EQ(0, select_calls);
  fake_select = count_select;
  EXPECT_EQ(0, select(0, 0, 0, 0, 0));
  EXPECT_EQ(1, select_calls);

  EXPECT_EQ(0, fake_socket);
  EXPECT_EQ(0, socket_calls);
  fake_socket = count_socket;
  EXPECT_EQ(0, socket(0, 0, 0));
  EXPECT_EQ(1, socket_calls);

  EXPECT_EQ(0, fake_write);
  EXPECT_EQ(0, write_calls);
  fake_write = count_write;
  EXPECT_EQ(0, write(0, 0, 0));
  EXPECT_EQ(1, write_calls);
}

int socket_ret = 0;
int socket_errno = 0;
int socket_domain = 0;
int socket_type = 0;
int socket_protocol = 0;
int test_socket(int domain, int type, int protocol) {
  socket_domain = domain;
  socket_type = type;
  socket_protocol = protocol;

  socket_calls++;
  errno = socket_errno;
  return socket_ret;
}

TEST_F(XmlRpcSocketTest, socket) {
  fake_socket = test_socket;

  errno = 0;
  EXPECT_EQ(0, errno);

  socket_ret = 7;
  socket_errno = 0;
  socket_calls = 0;
  EXPECT_EQ(7, XmlRpcSocket::socket());
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, socket_calls);
  EXPECT_EQ(AF_INET, socket_domain);
  EXPECT_EQ(SOCK_STREAM, socket_type);
  EXPECT_EQ(0, socket_protocol);

  // Check all of the errno values that the man page says socket can set if
  // it fails
  FOR_ERRNO(i,
            errnos,
            EACCES,
            EAFNOSUPPORT,
            EINVAL,
            EMFILE,
            ENFILE,
            ENOBUFS,
            ENOMEM,
            EPROTONOSUPPORT) {
    socket_ret = -1;
    socket_errno = errnos[i];
    socket_calls = 0;
    EXPECT_EQ(-1, XmlRpcSocket::socket());
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, socket_calls);
    EXPECT_EQ(AF_INET, socket_domain);
    EXPECT_EQ(SOCK_STREAM, socket_type);
    EXPECT_EQ(0, socket_protocol);
  }
}

int close_fd = 0;
int close_errno = 0;
int close_ret = 0;
int test_close(int fd) {
  EXPECT_EQ(close_fd, fd);

  close_calls++;
  errno = close_errno;
  return close_ret;
}

TEST_F(XmlRpcSocketTest, close) {
  // TODO(austin): XmlRpcSocket does not check or return the return value from
  //               close
  close_fd = 8;
  close_errno = 0;
  close_ret = 0;
  close_calls = 0;
  fake_close = test_close;
  XmlRpcSocket::close(8);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, close_calls);

  // TODO(austin): Close should automatically retry on EINTR but does not.
  FOR_ERRNO(i, errnos, EBADF, EINTR, EIO) {
    close_errno = errnos[i];
    close_ret = -1;
    close_calls = 0;
    XmlRpcSocket::close(8);
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, close_calls);
  }
}

int fcntl_fd = 0;
int fcntl_cmd = 0;
unsigned long fcntl_arg = 0;
int fcntl_errno = 0;
int fcntl_ret = 0;
int test_fcntl(int fd, int cmd, unsigned long arg) {
  EXPECT_EQ(fcntl_fd, fd);
  EXPECT_EQ(fcntl_cmd, cmd);
  EXPECT_EQ(fcntl_arg, arg);

  errno = fcntl_errno;
  fcntl_calls++;
  return fcntl_ret;
}

TEST_F(XmlRpcSocketTest, setNonBlocking) {
  fake_fcntl = test_fcntl;

  fcntl_fd = 9;
  fcntl_cmd = F_SETFL;
  fcntl_arg = O_NONBLOCK;

  fcntl_calls = 0;
  fcntl_errno = 0;
  fcntl_ret = 0;
  EXPECT_TRUE(XmlRpcSocket::setNonBlocking(9));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, fcntl_calls);

  // Tests for the errno values that the man page indicates might reasonably be
  // returned by F_SETFL
  FOR_ERRNO(i, errnos, EACCES, EAGAIN, EBADF) {
    fcntl_calls = 0;
    fcntl_errno = errnos[i];
    fcntl_ret = -1;
    EXPECT_FALSE(XmlRpcSocket::setNonBlocking(9));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, fcntl_calls);
  }
}

struct expected_read {
  expected_read(int fd, const void* buf, size_t sz)
    : fd(fd), count(4095), buf(buf), sz(sz), ret(sz), _errno(0) {}

  expected_read(int fd, int _errno)
    : fd(fd), count(4095), buf(0), sz(0), ret(-1), _errno(_errno) {}

  int fd;
  size_t count;
  const void* buf;
  size_t sz;
  ssize_t ret;
  int _errno;
};

std::deque&lt;expected_read&gt; expected_reads;

ssize_t mock_read(int fd, void* buf, size_t count) {
  read_calls++;

  // Check that we have another call in the queue. If not, fail the test and
  // return 0 (EOF).
  EXPECT_LE(1u, expected_reads.size());
  if (expected_reads.size() &lt; 1) {
    errno = 0;
    return 0;
  }

  // Get the next call off the queue.
  expected_read r = expected_reads.front();
  expected_reads.pop_front();

  // Check file descriptor and count.
  EXPECT_EQ(r.fd, fd);
  EXPECT_EQ(r.count, count);

  // Sanity check on count. Man pages say a count above SSIZE_MAX is undefined,
  // so check that the count that is passed doesn't trigger undefined behavior.
  EXPECT_GT(static_cast&lt;size_t&gt;(SSIZE_MAX), count);

  // Check that the buffer size is less or equal to the requested buffer size.
  EXPECT_LE(r.sz, count);
  size_t cnt = std::min(count, r.sz);
  // If we have a nonzero number of bytes to copy, copy them into the output
  // buffer.
  if (cnt &gt; 0) {
    memcpy(buf, r.buf, cnt);
  }

  // Check that the return value is what we expect it to be.
  if (r.ret &gt;= 0) {
    EXPECT_EQ(cnt, static_cast&lt;size_t&gt;(r.ret));
  }

  // Update errno and return.
  errno = r._errno;
  return r.ret;
}

TEST_F(XmlRpcSocketTest, nbRead) {
  fake_read = mock_read;

  const char data[] = "read1 read2 read3 read4 read5 read6 read7 read8";
  bool eof = false;
  std::string data_out;

  // Test: read some incoming data and then return EOF.
  // This is a nominal case when reading from a blocking descriptor.
  expected_reads.push_back(expected_read(7, data, 9));
  expected_reads.push_back(expected_read(7, 0, 0));

  EXPECT_TRUE(XmlRpcSocket::nbRead(7, data_out, &amp;eof));
  EXPECT_EQ("read1 rea", data_out);
  EXPECT_TRUE(eof);
  EXPECT_EQ(2, read_calls);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(0u, expected_reads.size());
  expected_reads.clear();
}

#define TEST_READ(RES, ERR)                                                    \
  TEST_F(XmlRpcSocketTest, nbRead_##ERR) {                                     \
    fake_read = mock_read;                                                     \
    bool eof = false;                                                          \
    std::string data_out;                                                      \
                                                                               \
    expected_reads.push_back(expected_read(7, ERR));                           \
                                                                               \
    EXPECT_##RES(XmlRpcSocket::nbRead(7, data_out, &amp;eof));                     \
    EXPECT_EQ("", data_out);                                                   \
    EXPECT_FALSE(eof);                                                         \
    EXPECT_EQ(1, read_calls);                                                  \
    EXPECT_EQ(ERR, XmlRpcSocket::getError());                                  \
    EXPECT_EQ(0u, expected_reads.size());                                       \
    expected_reads.clear();                                                    \
  }

// EAGAIN: fd is ok, read should be expected to return 0 bytes.
TEST_READ(TRUE, EAGAIN);

// EWOULDBLOCK: same as EAGAIN.
TEST_READ(TRUE, EWOULDBLOCK);

// EINTR: interrupted by system call. Expected behavior is that the caller
// should retry the read again immediately.
TEST_F(XmlRpcSocketTest, nbRead_EINTR) {
  fake_read = mock_read;

  bool eof = false;
  std::string data_out;

  expected_reads.push_back(expected_read(7, EINTR));
  // TODO(austin): expecting a second read causes the test to fail.
  // expected_reads.push_back(expected_read(7, 0, 0));

  EXPECT_TRUE(XmlRpcSocket::nbRead(7, data_out, &amp;eof));
  EXPECT_EQ("", data_out);
  EXPECT_FALSE(eof);
  // TODO(austin): expecting a second read causes the test to fail.
  // EXPECT_EQ(2, read_calls);
  EXPECT_EQ(1, read_calls);
  EXPECT_EQ(EINTR, XmlRpcSocket::getError());
}

// EBADF: file descriptor is bad; read should fail.
TEST_READ(FALSE, EBADF);

// EFAULT: buf is bad; read should fail.
// TODO(austin): this failure indicates that file descriptor is good, so if
// we see this error elsewhere it indicates that we shouldn't close the socket.
// Since XmlRpcSocket is handling the buffers, maybe this should be converted
// into an assertion failure inside XmlRpcSocket, and this test should
// EXPECT_DEATH?
TEST_READ(FALSE, EFAULT);

// EINVAL: File descriptor is not for reading. read should fail.
TEST_READ(FALSE, EINVAL);

// EIO: I/O error. read should probably fail.
TEST_READ(FALSE, EIO);

// EISDIR: File descriptor is a directory. read should fail.
TEST_READ(FALSE, EISDIR);

// More errors from recv (these should also apply to read on a socket).
// EACCES: Permission denied. read should fail.
TEST_READ(FALSE, EACCES);

// ECONNREFUSED: Connection refused. read should fail.
TEST_READ(FALSE, ECONNREFUSED);

// ENOMEM: Could not allocate memory. read should fail.
TEST_READ(FALSE, ENOMEM);

// ENOTCONN: Socket is not connected. read should fail.
TEST_READ(FALSE, ENOTCONN);

struct expected_write {
  expected_write(int fd, std::string data, size_t count, size_t max_write)
    : fd(fd),
      data(data),
      count(count),
      max_write(max_write),
      ret(std::min(count, max_write)),
      _errno(0) {}

  expected_write(int fd, size_t count, ssize_t ret, int _errno)
    : fd(fd), data(""), count(count), max_write(0), ret(ret), _errno(_errno) {}

  int fd;
  std::string data;
  size_t count;
  size_t max_write;
  ssize_t ret;
  int _errno;
};

std::deque&lt;expected_write&gt; expected_writes;

ssize_t mock_write(int fd, const void* buf, size_t count) {
  write_calls++;

  // Check that we have another call in the queue. If not, fail the test and
  // return 0 (EOF).
  EXPECT_LE(1u, expected_writes.size());
  if (expected_writes.size() &lt; 1) {
    // Since the socket is supposed to be non-blocking, return EWOULDBLOCK
    // if we can't write.
    errno = EWOULDBLOCK;
    return -1;
  }

  expected_write w = expected_writes.front();
  expected_writes.pop_front();

  EXPECT_EQ(w.fd, fd);
  EXPECT_EQ(w.count, count);
  size_t sz = std::min(w.max_write, count);
  if (sz &gt; 0) {
    std::string data((const char*)buf, sz);
    EXPECT_EQ(w.data, data);
    EXPECT_GE(w.ret, 0u);
    EXPECT_EQ(static_cast&lt;size_t&gt;(w.ret), sz);
  }

  errno = w._errno;
  return w.ret;
}

TEST_F(XmlRpcSocketTest, nbWrite) {
  fake_write = mock_write;
  int count = 0;
  std::string hello = "hello world";

  // Single write for all the data.
  expected_writes.push_back(expected_write(10, "hello world", 11, 11));
  count = 0;
  write_calls = 0;
  errno = 0;
  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
  EXPECT_EQ(count, 11);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(0u, expected_writes.size());
  EXPECT_EQ(1, write_calls);

  // Write in two parts, both succeed.
  expected_writes.push_back(expected_write(10, "hello", 11, 5));
  expected_writes.push_back(expected_write(10, " world", 6, 10));
  count = 0;
  write_calls = 0;
  errno = 0;
  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
  EXPECT_EQ(count, 11);
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(0u, expected_writes.size());
  EXPECT_EQ(2, write_calls);

  // Partial write.
  count = 0;
  write_calls = 0;
  errno = 0;
  expected_writes.push_back(expected_write(10, "hello", 11, 5));
  expected_writes.push_back(expected_write(10, 6, -1, EWOULDBLOCK));
  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &amp;count));
  EXPECT_EQ(count, 5);
  EXPECT_EQ(EWOULDBLOCK, XmlRpcSocket::getError());
  EXPECT_EQ(0u, expected_writes.size());
  EXPECT_EQ(2, write_calls);
}

#define TEST_WRITE(RES, ERR)                                                   \
  TEST_F(XmlRpcSocketTest, nbWrite_##ERR) {                                    \
    fake_write = mock_write;                                                   \
    int count = 0;                                                             \
    std::string hello = "hello world";                                         \
    errno = 0;                                                                 \
    expected_writes.push_back(expected_write(10, 11, -1, ERR));                \
    EXPECT_##RES(XmlRpcSocket::nbWrite(10, hello, &amp;count));                    \
    EXPECT_EQ(count, 0);                                                       \
    EXPECT_EQ(ERR, XmlRpcSocket::getError());                                  \
    EXPECT_EQ(0u, expected_writes.size());                                     \
    EXPECT_EQ(1, write_calls);                                                 \
    expected_writes.clear();                                                   \
  }

TEST_WRITE(TRUE, EAGAIN);
TEST_WRITE(TRUE, EWOULDBLOCK);
TEST_WRITE(TRUE, EINTR); // TODO(austin): this should retry immediately.
TEST_WRITE(FALSE, EBADF);
TEST_WRITE(FALSE, EDESTADDRREQ);
TEST_WRITE(FALSE, EDQUOT);
TEST_WRITE(FALSE, EFAULT);
TEST_WRITE(FALSE, EFBIG);
TEST_WRITE(FALSE, EINVAL);
TEST_WRITE(FALSE, EIO);
TEST_WRITE(FALSE, ENOSPC);
TEST_WRITE(FALSE, EPIPE);
TEST_WRITE(FALSE, EACCES);
TEST_WRITE(FALSE, ECONNRESET);
TEST_WRITE(FALSE, EISCONN);
TEST_WRITE(FALSE, ENOBUFS);
TEST_WRITE(FALSE, ENOMEM);
TEST_WRITE(FALSE, ENOTCONN);

int setsockopt_ret = 0;
int setsockopt_errno = 0;
int setsockopt_sockfd = 0;
int test_setsockopt(
    int sockfd, int level, int optname, const void* optval, socklen_t optlen) {
  setsockopt_calls++;
  setsockopt_sockfd = sockfd;

  // These arguments are all fixed, so just test for them here.
  EXPECT_EQ(SOL_SOCKET, level);
  EXPECT_EQ(SO_REUSEADDR, optname);
  EXPECT_EQ(sizeof(int), optlen);
  if (sizeof(int) == optlen) {
    EXPECT_EQ(1, *(int*)optval);
  }

  errno = setsockopt_errno;
  return setsockopt_ret;
}

TEST_F(XmlRpcSocketTest, setReuseAddr) {
  fake_setsockopt = test_setsockopt;

  errno = 0;
  setsockopt_sockfd = 0;
  setsockopt_calls = 0;

  setsockopt_errno = 0;
  setsockopt_ret = 0;
  EXPECT_TRUE(XmlRpcSocket::setReuseAddr(11));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(11, setsockopt_sockfd);
  EXPECT_EQ(1, setsockopt_calls);

  FOR_ERRNO(i, errnos, EBADF, EFAULT, EINVAL, ENOPROTOOPT, ENOTSOCK) {
    errno = 0;
    setsockopt_sockfd = 0;
    setsockopt_calls = 0;

    setsockopt_errno = errnos[i];
    setsockopt_ret = -1;
    EXPECT_FALSE(XmlRpcSocket::setReuseAddr(11));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(11, setsockopt_sockfd);
    EXPECT_EQ(1, setsockopt_calls);
  }
}

bool operator==(const in6_addr a, const in6_addr b) {
  // Delegate to IPv6 address comparison macro.
  return IN6_ARE_ADDR_EQUAL(&amp;a, &amp;b);
}

int bind_ret = 0;
int bind_errno = 0;
int bind_sockfd = 0;
int bind_family = 0;
int bind_port = 0;
int test_bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen) {
  bind_calls++;
  EXPECT_EQ(bind_sockfd, sockfd);

  EXPECT_TRUE(NULL != addr);
  if (NULL != addr) {
    EXPECT_EQ(bind_family, addr-&gt;sa_family);
    if (AF_INET == addr-&gt;sa_family) {
      EXPECT_EQ(sizeof(struct sockaddr_in), addrlen);
      struct sockaddr_in* in_addr = (struct sockaddr_in*)addr;
      EXPECT_EQ(INADDR_ANY, ntohl(in_addr-&gt;sin_addr.s_addr));
      EXPECT_EQ(bind_port, ntohs(in_addr-&gt;sin_port));

    } else if (AF_INET6 == addr-&gt;sa_family) {
      EXPECT_EQ(sizeof(struct sockaddr_in6), addrlen);
      struct sockaddr_in6* in6_addr = (struct sockaddr_in6*)addr;
      EXPECT_EQ(in6addr_any, in6_addr-&gt;sin6_addr);
      EXPECT_EQ(bind_port, ntohs(in6_addr-&gt;sin6_port));
    } else {
      ADD_FAILURE() &lt;&lt; "Unrecognized sockaddr family";
    }
  }

  errno = bind_errno;
  return bind_ret;
}

TEST_F(XmlRpcSocketTest, bind) {
  fake_bind = test_bind;

  // Nominal case: bind returns success.
  bind_sockfd = 12;
  bind_family = AF_INET;
  bind_port = 22;

  bind_calls = 0;
  bind_errno = 0;
  bind_ret = 0;
  EXPECT_TRUE(XmlRpcSocket::bind(12, 22));
  EXPECT_EQ(1, bind_calls);
  EXPECT_EQ(0, XmlRpcSocket::getError());

  // Errors that the man page indicates can happen for all sockets; this does
  // not include the errors that are specific to UNIX domain sockets.
  FOR_ERRNO(i, errnos, EACCES, EADDRINUSE, EBADF, EINVAL, ENOTSOCK) {
    bind_calls = 0;

    bind_family = AF_INET;
    bind_port = 22;

    bind_errno = errnos[i];
    bind_ret = -1;
    EXPECT_FALSE(XmlRpcSocket::bind(12, 22));
    EXPECT_EQ(1, bind_calls);
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
  }

  // Basic test for IPv6 functionality.
  XmlRpcSocket::s_use_ipv6_ = true;

  bind_calls = 0;

  bind_family = AF_INET6;
  bind_port = 22;

  bind_errno = 0;
  bind_ret = 0;
  EXPECT_TRUE(XmlRpcSocket::bind(12, 22));
  EXPECT_EQ(1, bind_calls);
  EXPECT_EQ(0, XmlRpcSocket::getError());
}

int getsockname_ret = 0;
int getsockname_errno = 0;
int getsockname_sockfd = 0;
void* getsockname_addr = 0;
socklen_t getsockname_len = 0;
int test_getsockname(int sockfd, struct sockaddr* addr, socklen_t* addrlen) {
  getsockname_calls++;

  EXPECT_EQ(getsockname_sockfd, sockfd);

  EXPECT_TRUE(NULL != addr);
  EXPECT_LE(getsockname_len, *addrlen);
  if (NULL != addr) {
    socklen_t len = std::min(*addrlen, getsockname_len);
    if (len &gt; 0)
      memcpy(addr, getsockname_addr, len);
  }
  EXPECT_TRUE(NULL != addrlen);
  if (NULL != addrlen) {
    *addrlen = getsockname_len;
  }

  errno = getsockname_errno;
  return getsockname_ret;
}

TEST_F(XmlRpcSocketTest, get_port) {
  fake_getsockname = test_getsockname;

  struct sockaddr_in inet_addr;
  inet_addr.sin_family = AF_INET;
  inet_addr.sin_port = htons(123);

  struct sockaddr_in6 inet6_addr;
  inet6_addr.sin6_family = AF_INET6;
  inet6_addr.sin6_port = htons(4224);

  getsockname_sockfd = 14;

  getsockname_errno = 0;
  getsockname_ret = 0;

  getsockname_calls = 0;
  getsockname_addr = &amp;inet_addr;
  getsockname_len = sizeof(struct sockaddr_in);
  EXPECT_EQ(123, XmlRpcSocket::get_port(14));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, getsockname_calls);

  getsockname_calls = 0;
  getsockname_addr = &amp;inet6_addr;
  getsockname_len = sizeof(struct sockaddr_in6);
  EXPECT_EQ(4224, XmlRpcSocket::get_port(14));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, getsockname_calls);

  getsockname_ret = -1;
  FOR_ERRNO(i, errnos, EBADF, EFAULT, EINVAL, ENOBUFS, ENOTSOCK) {
    getsockname_errno = errnos[i];

    // Errors, no data written to buffer.
    getsockname_calls = 0;
    getsockname_addr = NULL;
    getsockname_len = 0;
    EXPECT_EQ(0, XmlRpcSocket::get_port(14));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, getsockname_calls);

    // Same errors, but this time put valid data and expect that it is ignored.
    getsockname_calls = 0;
    getsockname_addr = &amp;inet_addr;
    getsockname_len = sizeof(struct sockaddr_in);
    EXPECT_EQ(0, XmlRpcSocket::get_port(14));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, getsockname_calls);
  }
}

int listen_ret = 0;
int listen_errno = 0;
int listen_sockfd = 0;
int listen_backlog = 0;
int test_listen(int sockfd, int backlog) {
  EXPECT_EQ(listen_sockfd, sockfd);
  EXPECT_EQ(listen_backlog, backlog);

  errno = listen_errno;
  return listen_ret;
}

TEST_F(XmlRpcSocketTest, listen) {
  fake_listen = test_listen;

  listen_sockfd = 13;
  listen_backlog = 10;

  listen_ret = 0;
  listen_errno = 0;
  EXPECT_TRUE(XmlRpcSocket::listen(13, 10));
  EXPECT_EQ(0, XmlRpcSocket::getError());

  FOR_ERRNO(i, errnos, EADDRINUSE, EBADF, ENOTSOCK, EOPNOTSUPP) {
    listen_ret = -1;
    listen_errno = errnos[i];
    EXPECT_FALSE(XmlRpcSocket::listen(13, 10));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
  }
}

int accept_ret = 0;
int accept_errno = 0;
int accept_sockfd = 0;
void* accept_addr = 0;
socklen_t accept_addrlen = 0;
int test_accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen) {
  accept_calls++;
  EXPECT_EQ(accept_sockfd, sockfd);

  if (accept_addr) {
    EXPECT_TRUE(NULL != addr);
    EXPECT_TRUE(NULL != addrlen);
    if (NULL != addr &amp;&amp; NULL != addrlen) {
      socklen_t len = std::min(accept_addrlen, *addrlen);
      memcpy(addr, accept_addr, len);
      *addrlen = accept_addrlen;
    }
  } else {
    EXPECT_EQ(NULL, addr);
    EXPECT_EQ(NULL, addrlen);
  }

  errno = accept_errno;
  return accept_ret;
}

TEST_F(XmlRpcSocketTest, accept) {
  fake_accept = test_accept;

  // Set up address. XmlRpcSocket::accept expects this, even if it isn't used.
  struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_port = htons(45);
  addr.sin_addr.s_addr = 0xDEADBEEF;

  accept_addr = &amp;addr;
  accept_addrlen = sizeof(struct sockaddr);

  accept_sockfd = 15;

  accept_calls = 0;
  accept_ret = 16;
  accept_errno = 0;
  EXPECT_EQ(16, XmlRpcSocket::accept(15));
  EXPECT_EQ(0, XmlRpcSocket::getError());
  EXPECT_EQ(1, accept_calls);

  FOR_ERRNO(i,
            errnos,
            EAGAIN,
            EWOULDBLOCK,
            EBADF,
            ECONNABORTED,
            EFAULT,
            EINTR, // TODO(austin): Should this retry immediately?
            EINVAL,
            EMFILE,
            ENFILE,
            ENOBUFS,
            ENOMEM,
            ENOTSOCK,
            EOPNOTSUPP,
            EPROTO,
            EPERM) {
    accept_calls = 0;
    accept_ret = -1;
    accept_errno = errnos[i];
    EXPECT_EQ(-1, XmlRpcSocket::accept(15));
    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
    EXPECT_EQ(1, accept_calls);
  }
}

// To test connect() we need mocks for getaddrinfo(), freeaddrinfo(), connect()
// and XmlRpc logging hooks to validate that the correct error messages are
// logged.

int getaddrinfo_ret = 0;
int getaddrinfo_errno = 0;
const char* getaddrinfo_node = 0;
const char* getaddrinfo_service = 0;
struct addrinfo getaddrinfo_hints = {.ai_flags = 0,
                                     .ai_family = 0,
                                     .ai_socktype = 0,
                                     .ai_protocol = 0,
                                     .ai_addrlen = 0,
                                     .ai_addr = 0,
                                     .ai_canonname = 0,
                                     .ai_next = 0};
struct addrinfo* getaddrinfo_res = 0;
int test_getaddrinfo(const char* node,
                     const char* service,
                     const struct addrinfo* hints,
                     struct addrinfo** res) {
  getaddrinfo_calls++;

  EXPECT_STREQ(getaddrinfo_node, node);
  EXPECT_STREQ(getaddrinfo_service, service);

  EXPECT_TRUE(NULL != hints);
  if (NULL != hints) {
    EXPECT_TRUE(memcmp(hints, &amp;getaddrinfo_hints, sizeof(struct addrinfo)) ==
                0);
  }

  EXPECT_TRUE(NULL != res);
  if (NULL != res) {
    *res = getaddrinfo_res;
  }

  errno = getaddrinfo_errno;
  return getaddrinfo_ret;
}

struct addrinfo* freeaddrinfo_res = 0;
void test_freeaddrinfo(struct addrinfo* res) {
  // The man page does not indicate any errors that freeaddrinfo may encounter.
  freeaddrinfo_calls++;

  EXPECT_EQ(freeaddrinfo_res, res);

  return;
}

void EXPECT_SOCKADDR_EQ(const sockaddr* addr1, const sockaddr* addr2) {
  EXPECT_EQ((NULL == addr1), (NULL == addr2));
  if (NULL != addr1 &amp;&amp; NULL != addr2) {
    EXPECT_EQ(addr1-&gt;sa_family, addr2-&gt;sa_family);
    if (addr1-&gt;sa_family == addr2-&gt;sa_family) {
      switch (addr1-&gt;sa_family) {
      case AF_INET: {
        const sockaddr_in* addr1_in = (const sockaddr_in*)addr1;
        const sockaddr_in* addr2_in = (const sockaddr_in*)addr2;
        EXPECT_EQ(addr1_in-&gt;sin_port, addr2_in-&gt;sin_port);
        EXPECT_EQ(addr1_in-&gt;sin_addr.s_addr, addr2_in-&gt;sin_addr.s_addr);
      } break;
      case AF_INET6: {
        const sockaddr_in6* addr1_in6 = (const sockaddr_in6*)addr1;
        const sockaddr_in6* addr2_in6 = (const sockaddr_in6*)addr2;
        EXPECT_EQ(addr1_in6-&gt;sin6_port, addr2_in6-&gt;sin6_port);
        EXPECT_EQ(addr1_in6-&gt;sin6_flowinfo, addr2_in6-&gt;sin6_flowinfo);
        EXPECT_EQ(addr1_in6-&gt;sin6_scope_id, addr2_in6-&gt;sin6_scope_id);
        EXPECT_TRUE(
            IN6_ARE_ADDR_EQUAL(&amp;addr1_in6-&gt;sin6_addr, &amp;addr2_in6-&gt;sin6_addr));
        for (int i = 0; i &lt; 16; i++) {
          EXPECT_EQ(addr1_in6-&gt;sin6_addr.s6_addr[i],
                    addr2_in6-&gt;sin6_addr.s6_addr[i])
              &lt;&lt; "IPv6 address mismstach at byte " &lt;&lt; i;
        }
      } break;
      default:
        ADD_FAILURE() &lt;&lt; "Unrecognized address type; cannot compare";
      }
    }
  }
}

int connect_ret = 0;
int connect_errno = 0;
int connect_sockfd = 0;
const struct sockaddr* connect_addr = 0;
socklen_t connect_addrlen = 0;
int test_connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen) {
  connect_calls++;

  EXPECT_EQ(connect_sockfd, sockfd);

  EXPECT_TRUE(NULL != addr);
  EXPECT_EQ(connect_addrlen, addrlen);
  EXPECT_SOCKADDR_EQ(connect_addr, addr);

  errno = connect_errno;
  return connect_ret;
}

class XmlRpcConnectTest : public XmlRpcSocketTest,
                          XmlRpc::XmlRpcLogHandler,
                          XmlRpc::XmlRpcErrorHandler {
public:
  virtual void log(int level, const char* msg) {
    last_level = level;
    last_msg = msg;
    std::cout &lt;&lt; "LOG(" &lt;&lt; level &lt;&lt; "):" &lt;&lt; msg;
  }

  virtual void error(const char* msg) {
    last_error = msg;
    std::cout &lt;&lt; "ERROR: " &lt;&lt; msg;
  }

  int last_level;
  std::string last_msg;
  std::string last_error;

  void EXPECT_LOG(int level, const std::string&amp; msg) {
    EXPECT_EQ(level, last_level);
    EXPECT_EQ(msg, last_msg);
  }

  void EXPECT_ERROR(const std::string&amp; msg) {
    EXPECT_EQ(msg, last_error);
  }

protected:
  void SetUp() {
    XmlRpcSocketTest::SetUp();

    // Install mock functions.
    fake_getaddrinfo = test_getaddrinfo;
    fake_freeaddrinfo = test_freeaddrinfo;
    fake_connect = test_connect;

    XmlRpc::XmlRpcLogHandler::setLogHandler(this);
<a name="0"></a>    XmlRpc::XmlRpcErrorHandler::setErrorHandler(this);

    // Set up address data structures for testing use.
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    addr_ip4_22.sin_family = AF_INET;
    addr_ip4_22.sin_port = htons(22);
    addr_ip4_22.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

    addr_ip4_404.sin_family = AF_INET;
    addr_ip4_404.sin_port = htons(404);
    addr_ip4_404.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

    addr_ip6_44.sin6_family = AF_INET6;
    addr_ip6_44.sin6_port = htons(44);
    addr_ip6_44.sin6_flowinfo = 0;
    addr_ip6_44.sin6_addr = in6addr_loopback;
    addr_ip6_44.sin6_scope_id = 0;

    addr_ip6_404.sin6_family = AF_INET6;
    addr_ip6_404.sin6_port = htons(404);
    addr_ip6_404.sin6_flowinfo = 0;
    addr_ip6_404.sin6_addr = in6addr_loopback;
    addr_ip6_404.sin6_scope_id = 0;

    info_ip4.ai_flags = 0;</b></font>
    info_ip4.ai_family = AF_INET;
    info_ip4.ai_socktype = SOCK_STREAM;
    info_ip4.ai_protocol = 0;
    info_ip4.ai_addrlen = sizeof(struct sockaddr_in);
    info_ip4.ai_addr = (struct sockaddr*)&amp;addr_ip4_22;
    info_ip4.ai_canonname = 0;
    info_ip4.ai_next = 0;

    info_ip6.ai_flags = 0;
    info_ip6.ai_family = AF_INET6;
    info_ip6.ai_socktype = SOCK_STREAM;
    info_ip6.ai_protocol = 0;
    info_ip6.ai_addrlen = sizeof(struct sockaddr_in6);
    info_ip6.ai_addr = (struct sockaddr*)&amp;addr_ip6_44;
    info_ip6.ai_canonname = 0;
    info_ip6.ai_next = 0;

    info_canon.ai_flags = 0;
    info_canon.ai_family = 0;
    info_canon.ai_socktype = 0;
    info_canon.ai_protocol = 0;
    info_canon.ai_addrlen = 0;
    info_canon.ai_addr = 0;
    info_canon.ai_canonname = 0;
    info_canon.ai_next = 0;

    // Set up expected hints.
    getaddrinfo_hints.ai_family = AF_UNSPEC;
    // TODO(austin): hints should probably specify SOCK_STREAM
    // getaddrinfo_hints.ai_socktype = SOCK_STREAM;

    getaddrinfo_node = "nowhere.com";
    getaddrinfo_service = 0;

    connect_sockfd = 19;
  }

  void TestConnect() {
    // Always free the same getaddrinfo that we started with.
    freeaddrinfo_res = getaddrinfo_res;

    // Clear last log message.
    last_level = 0;
    last_msg = "";
    last_error = "";

    // Actually start running tests.
    getaddrinfo_calls = 0;
    freeaddrinfo_calls = 0;
    connect_calls = 0;
    EXPECT_TRUE(XmlRpcSocket::connect(19, "nowhere.com", 404));
    EXPECT_EQ(1, getaddrinfo_calls);
    EXPECT_EQ(1, freeaddrinfo_calls);
    EXPECT_EQ(1, connect_calls);
  }

  void TestLookupFail() {
    // Always free the same getaddrinfo that we started with.
    freeaddrinfo_res = getaddrinfo_res;

    // Clear last log message.
    last_level = 0;
    last_msg = "";
    last_error = "";

    // Actually start running tests.
    getaddrinfo_calls = 0;
    freeaddrinfo_calls = 0;
    connect_calls = 0;
    EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
    EXPECT_EQ(1, getaddrinfo_calls);
    EXPECT_EQ(0, freeaddrinfo_calls);
    EXPECT_EQ(0, connect_calls);
  }

  void TestConnectFail() {
    // Always free the same getaddrinfo that we started with.
    freeaddrinfo_res = getaddrinfo_res;

    // Clear last log message.
    last_level = 0;
    last_msg = "";
    last_error = "";

    // Actually start running tests.
    getaddrinfo_calls = 0;
    freeaddrinfo_calls = 0;
    connect_calls = 0;
    EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
    EXPECT_EQ(1, getaddrinfo_calls);
    EXPECT_EQ(1, freeaddrinfo_calls);
    EXPECT_EQ(1, connect_calls);
  }

  void TearDown() {
    XmlRpcLogHandler::setLogHandler(NULL);
    XmlRpcErrorHandler::setErrorHandler(NULL);

    XmlRpcSocketTest::TearDown();
  }

  struct sockaddr_in addr_ip4_22;
  struct sockaddr_in addr_ip4_404;
  struct sockaddr_in6 addr_ip6_44;
  struct sockaddr_in6 addr_ip6_404;
  struct addrinfo info_ip4;
  struct addrinfo info_ip6;
  struct addrinfo info_canon;
};

TEST_F(XmlRpcConnectTest, connect_ipv4) {
  // Expected results from getaddrinfo.
  getaddrinfo_ret = 0;
  getaddrinfo_errno = 0;

  // Expected results from connect.
  connect_ret = 0;
  connect_errno = 0;
  connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
  connect_addrlen = sizeof(struct sockaddr_in);

  // Canonical address first, then IPv4, IPv6.
  getaddrinfo_res = &amp;info_canon;
  info_canon.ai_next = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;
  TestConnect();

  // List with IPv6 first.
  getaddrinfo_res = &amp;info_canon;
  info_canon.ai_next = &amp;info_ip6;
  info_ip6.ai_next = &amp;info_ip4;
  info_ip4.ai_next = 0;
  TestConnect();

  // List without canon address, IPv6 first.
  getaddrinfo_res = &amp;info_ip6;
  info_ip6.ai_next = &amp;info_ip4;
  info_ip4.ai_next = 0;
  TestConnect();

  // List without canon address, IPv4 first.
  getaddrinfo_res = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;
  TestConnect();
}

TEST_F(XmlRpcConnectTest, connect_ipv6) {
  // Basic IPv6 tests.
  XmlRpcSocket::s_use_ipv6_ = true;

  // Expected results from getaddrinfo.
  getaddrinfo_ret = 0;
  getaddrinfo_errno = 0;

  // Expected results from connect.
  connect_ret = 0;
  connect_errno = 0;
  connect_addr = (struct sockaddr*)&amp;addr_ip6_404;
  connect_addrlen = sizeof(struct sockaddr_in6);

  // List without canon address, IPv4 first.
  getaddrinfo_res = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;
  TestConnect();

  // List without canon address, IPv6 first.
  getaddrinfo_res = &amp;info_ip6;
  info_ip6.ai_next = &amp;info_ip4;
  info_ip4.ai_next = 0;
  TestConnect();
}

// Simulate error returns from getaddrinfo. Check that the error is logged
// correctly, that connect is not called, that the result is freed(or not)
// and that connect correctly returns an error.
TEST_F(XmlRpcConnectTest, connect_lookup_fail) {
  // Expected results from connect.
  connect_ret = 0;
  connect_errno = 0;
  connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
  connect_addrlen = sizeof(struct sockaddr_in);

  // List without canon address, IPv4 first.
  getaddrinfo_res = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;

  // Enumerate possible return codes from getaddrinfo and make sure that
  // connect() fails and that the correct error message is reported.
  FOR_ERRNO(i,
            addr_errs,
            EAI_ADDRFAMILY,
            EAI_AGAIN,
            EAI_BADFLAGS,
            EAI_FAIL,
            EAI_FAMILY,
            EAI_MEMORY,
            EAI_NODATA,
            EAI_NONAME,
            EAI_SERVICE,
            EAI_SOCKTYPE) {
    // Results from getaddrinfo.
    getaddrinfo_ret = addr_errs[i];
    getaddrinfo_errno = 0;

    TestLookupFail();
    EXPECT_ERROR(
        std::string("Couldn't find an AF_INET address for [nowhere.com]: ") +
        std::string(gai_strerror(addr_errs[i])) + std::string("\n"));
  }

  // Enumerate system failures from getaddrinfo and make sure that connect()
  // fails and that the correct error from perror is reported.
  // TODO(austin): getaddrinfo should retry on EINTR but it doesn't.
  getaddrinfo_ret = EAI_SYSTEM;
  FOR_ERRNO(i, errnos, ENFILE, EMFILE, EAGAIN, EINTR) {
    getaddrinfo_errno = errnos[i];
    TestLookupFail();
    EXPECT_ERROR(
        std::string("Couldn't find an AF_INET address for [nowhere.com]: ") +
        std::string(strerror(errnos[i])) + std::string("\n"));
  }

  // IPv4 lookup only returns IPv6 results.
  getaddrinfo_res = &amp;info_ip6;
  info_ip6.ai_next = 0;

  // Results from getaddrinfo.
  getaddrinfo_ret = 0;
  getaddrinfo_errno = 0;

  // Always free the same getaddrinfo that we started with.
  freeaddrinfo_res = getaddrinfo_res;

  // Clear last log message.
  last_level = 0;
  last_msg = "";
  last_error = "";

  // Call connect and analyze results. We do this inline here instead of
  // using one of the convenience functions because none of the convenience
  // functions fit this pattern.
  getaddrinfo_calls = 0;
  freeaddrinfo_calls = 0;
  connect_calls = 0;
  EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
  EXPECT_EQ(1, getaddrinfo_calls);
  EXPECT_EQ(1, freeaddrinfo_calls);
  EXPECT_EQ(0, connect_calls);
  EXPECT_ERROR(
      std::string("Couldn't find an AF_INET address for [nowhere.com]") +
      std::string("\n"));
}

// TODO(austin): this probably won't work, isn't supported upstream and isn't
// required by our current use case. Future work.
// Simulate multiple results for a hostname lookup. Simulate failure to
// connect to the first hostname and verify that another attempt is made
// for the second address.
TEST_F(XmlRpcConnectTest, connect_multiple_result) {}

// Simulate various error results from connect().
TEST_F(XmlRpcConnectTest, connect_failure) {
  // Expected results from getaddrinfo.
  getaddrinfo_ret = 0;
  getaddrinfo_errno = 0;

  // Expected results from connect.
  connect_ret = 0;
  connect_errno = 0;
  connect_addr = (struct sockaddr*)&amp;addr_ip4_404;
  connect_addrlen = sizeof(struct sockaddr_in);

  // List without canon address, IPv4 first.
  getaddrinfo_res = &amp;info_ip4;
  info_ip4.ai_next = &amp;info_ip6;
  info_ip6.ai_next = 0;

  // EINPROGRESS indicates that the socket is non-blocking and the connection
  // request has started but not finished, so we expect success.
  connect_ret = -1;
  connect_errno = EINPROGRESS;
  TestConnect();
  EXPECT_ERROR("");

  // On Windows, EWOULDBLOCK (really WSAEWOULDBLOCK) indicates that the
  // socket is non-blocking and could not be completed immediately (success)
  // but on Linux it it synonymous with EAGAIN which indicates that there are
  // no more available local ports.
  //
  // NOTE(austin): if this comparison fails, create separate tests for EAGAIN
  //               and EWOULDBLOCK.
  EXPECT_EQ(EWOULDBLOCK, EAGAIN);
  connect_ret = -1;
  connect_errno = EWOULDBLOCK;
#if defined(_WINDOWS)
  TestConnect();
  EXPECT_ERROR("");
#else
  TestConnectFail();
  EXPECT_ERROR(std::string("::connect error = ") +
               std::string(strerror(EWOULDBLOCK)) + std::string("\n"));
#endif

  // All other errors that connect may return should be reported as an error.
  // TODO(austin): Connect should immediately retry on EINTR but it doesn't.
  FOR_ERRNO(i,
            errnos,
            EACCES,
            EPERM,
            EADDRINUSE,
            EAFNOSUPPORT,
            EALREADY,
            EBADF,
            ECONNREFUSED,
            EFAULT,
            EINTR,
            EISCONN,
            ENETUNREACH,
            ENOTSOCK,
            ETIMEDOUT) {
    connect_ret = -1;
    connect_errno = errnos[i];
    TestConnectFail();
    EXPECT_ERROR(std::string("::connect error = ") +
                 std::string(strerror(errnos[i])) + std::string("\n"));
  }
}

int main(int argc, char **argv)
{
  ::testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
