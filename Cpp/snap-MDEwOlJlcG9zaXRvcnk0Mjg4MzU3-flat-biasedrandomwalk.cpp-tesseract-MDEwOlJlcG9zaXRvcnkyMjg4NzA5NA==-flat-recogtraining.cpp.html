
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.549071618037134%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-biasedrandomwalk.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "Snap.h"
3  #include "biasedrandomwalk.h"
4  void GetNodeAlias(TFltV& PTblV, TIntVFltVPr& NTTable) {
5    int64 N = PTblV.Len();
6    TIntV& KTbl = NTTable.Val1;
7    TFltV& UTbl = NTTable.Val2;
8    for (int64 i = 0; i < N; i++) {
9      KTbl[i]=0;
10      UTbl[i]=0;
11    }
12    TIntV UnderV;
13    TIntV OverV;
14    for (int64 i = 0; i < N; i++) {
15      UTbl[i] = PTblV[i]*N;
16      if (UTbl[i] < 1) {
17        UnderV.Add(i);
18      } else {
19        OverV.Add(i);
20      }
21    }
22    while (UnderV.Len() > 0 && OverV.Len() > 0) {
23      int64 Small = UnderV.Last();
24      int64 Large = OverV.Last();
25      UnderV.DelLast();
26      OverV.DelLast();
27      KTbl[Small] = Large;
28      UTbl[Large] = UTbl[Large] + UTbl[Small] - 1;
29      if (UTbl[Large] < 1) {
30        UnderV.Add(Large);
31      } else {
32        OverV.Add(Large);
33      }
34    }
35    while(UnderV.Len() > 0){
36      int64 curr = UnderV.Last();
37      UnderV.DelLast();
38      UTbl[curr]=1;
39    }
40    while(OverV.Len() > 0){
41      int64 curr = OverV.Last();
42      OverV.DelLast();
43      UTbl[curr]=1;
44    }
45  }
46  int64 AliasDrawInt(TIntVFltVPr& NTTable, TRnd& Rnd) {
47    int64 N = NTTable.GetVal1().Len();
48    TInt X = static_cast<int64>(Rnd.GetUniDev()*N);
49    double Y = Rnd.GetUniDev();
50    return Y < NTTable.GetVal2()[X] ? X : NTTable.GetVal1()[X];
51  }
52  void PreprocessNode (PWNet& InNet, const double& ParamP, const double& ParamQ,
53   TWNet::TNodeI NI, int64& NCnt, const bool& Verbose) {
54    if (Verbose && NCnt%100 == 0) {
55      printf("\rPreprocessing progress: %.2lf%% ",(double)NCnt*100/(double)(InNet->GetNodes()));fflush(stdout);
56    }
57    THash <TInt, TBool> NbrH;                                    
58    for (int64 i = 0; i < NI.GetOutDeg(); i++) {
59      NbrH.AddKey(NI.GetNbrNId(i));
60    } 
61    for (int64 i = 0; i < NI.GetOutDeg(); i++) {
62      TWNet::TNodeI CurrI = InNet->GetNI(NI.GetNbrNId(i));      
63      double Psum = 0;
64      TFltV PTable;                              
65      for (int64 j = 0; j < CurrI.GetOutDeg(); j++) {           
66        int64 FId = CurrI.GetNbrNId(j);
67        TFlt Weight;
68        if (!(InNet->GetEDat(CurrI.GetId(), FId, Weight))){ continue; }
69        if (FId==NI.GetId()) {
70          PTable.Add(Weight / ParamP);
71          Psum += Weight / ParamP;
<span onclick='openModal()' class='match'>72        } else if (NbrH.IsKey(FId)) {
73          PTable.Add(Weight);
74          Psum += Weight;
75        } else {
76          PTable.Add(Weight / ParamQ);
77          Psum += Weight / ParamQ;
78        }
79      }
</span>80      for (int64 j = 0; j < CurrI.GetOutDeg(); j++) {
81        PTable[j] /= Psum;
82      }
83      GetNodeAlias(PTable,CurrI.GetDat().GetDat(NI.GetId()));
84    }
85    NCnt++;
86  }
87  void PreprocessTransitionProbs(PWNet& InNet, const double& ParamP, const double& ParamQ, const bool& Verbose) {
88    for (TWNet::TNodeI NI = InNet->BegNI(); NI < InNet->EndNI(); NI++) {
89      InNet->SetNDat(NI.GetId(),TIntIntVFltVPrH());
90    }
91    for (TWNet::TNodeI NI = InNet->BegNI(); NI < InNet->EndNI(); NI++) {
92      for (int64 i = 0; i < NI.GetOutDeg(); i++) {                    
93        TWNet::TNodeI CurrI = InNet->GetNI(NI.GetNbrNId(i));
94        CurrI.GetDat().AddDat(NI.GetId(),TPair<TIntV,TFltV>(TIntV(CurrI.GetOutDeg()),TFltV(CurrI.GetOutDeg())));
95      }
96    }
97    int64 NCnt = 0;
98    TIntV NIds;
99    for (TWNet::TNodeI NI = InNet->BegNI(); NI < InNet->EndNI(); NI++) {
100      NIds.Add(NI.GetId());
101    }
102  #pragma omp parallel for schedule(dynamic)
103    for (int64 i = 0; i < NIds.Len(); i++) {
104      PreprocessNode(InNet, ParamP, ParamQ, InNet->GetNI(NIds[i]), NCnt, Verbose);
105    }
106    if(Verbose){ printf("\n"); }
107  }
108  int64 PredictMemoryRequirements(PWNet& InNet) {
109    int64 MemNeeded = 0;
110    for (TWNet::TNodeI NI = InNet->BegNI(); NI < InNet->EndNI(); NI++) {
111      for (int64 i = 0; i < NI.GetOutDeg(); i++) {
112        TWNet::TNodeI CurrI = InNet->GetNI(NI.GetNbrNId(i));
113        MemNeeded += CurrI.GetOutDeg()*(sizeof(TInt) + sizeof(TFlt));
114      }
115    }
116    return MemNeeded;
117  }
118  void SimulateWalk(PWNet& InNet, int64 StartNId, const int& WalkLen, TRnd& Rnd, TIntV& WalkV) {
119    WalkV.Add(StartNId);
120    if (WalkLen == 1) { return; }
121    if (InNet->GetNI(StartNId).GetOutDeg() == 0) { return; }
122    WalkV.Add(InNet->GetNI(StartNId).GetNbrNId(Rnd.GetUniDevInt(InNet->GetNI(StartNId).GetOutDeg())));
123    while (WalkV.Len() < WalkLen) {
124      int64 Dst = WalkV.Last();
125      int64 Src = WalkV.LastLast();
126      if (InNet->GetNI(Dst).GetOutDeg() == 0) { return; }
127      int64 Next = AliasDrawInt(InNet->GetNDat(Dst).GetDat(Src),Rnd);
128      WalkV.Add(InNet->GetNI(Dst).GetNbrNId(Next));
129    }
130  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recogtraining.cpp</h3>
            <pre><code>1  #include "tesseractclass.h"
2  #include "boxread.h"
3  #include "control.h"
4  #include "host.h" 
5  #include "ratngs.h"
6  #ifndef DISABLED_LEGACY_ENGINE
7  #  include "reject.h"
8  #endif
9  #include "stopper.h"
10  namespace tesseract {
11  const int16_t kMaxBoxEdgeDiff = 2;
12  FILE *Tesseract::init_recog_training(const char *filename) {
13    if (tessedit_ambigs_training) {
14      tessedit_tess_adaption_mode.set_value(0); 
15      tessedit_enable_doc_dict.set_value(false); 
16      getDict().stopper_no_acceptable_choices.set_value(true);
17    }
18    std::string output_fname = filename;
19    const char *lastdot = strrchr(output_fname.c_str(), '.');
20    if (lastdot != nullptr) {
21      output_fname[lastdot - output_fname.c_str()] = '\0';
22    }
23    output_fname += ".txt";
24    FILE *output_file = fopen(output_fname.c_str(), "a+");
25    if (output_file == nullptr) {
26      tprintf("Error: Could not open file %s\n", output_fname.c_str());
27      ASSERT_HOST(output_file);
28    }
29    return output_file;
30  }
31  static bool read_t(PAGE_RES_IT *page_res_it, TBOX *tbox) {
32    while (page_res_it->block() != nullptr && page_res_it->word() == nullptr) {
33      page_res_it->forward();
34    }
35    if (page_res_it->word() != nullptr) {
36      *tbox = page_res_it->word()->word->bounding_box();
37      if (tbox->left() < 0) {
38        tbox->rotate(FCOORD(0.0, -1.0));
39      }
40      return true;
41    } else {
42      return false;
43    }
44  }
45  void Tesseract::recog_training_segmented(const char *filename, PAGE_RES *page_res,
46                                           volatile ETEXT_DESC *monitor, FILE *output_file) {
47    std::string box_fname = filename;
48    const char *lastdot = strrchr(box_fname.c_str(), '.');
49    if (lastdot != nullptr) {
50      box_fname[lastdot - box_fname.c_str()] = '\0';
51    }
52    box_fname += ".box";
53    FILE *box_file = fopen(box_fname.c_str(), "r");
54    if (box_file == nullptr) {
55      tprintf("Error: Could not open file %s\n", box_fname.c_str());
56      ASSERT_HOST(box_file);
57    }
58    PAGE_RES_IT page_res_it;
59    page_res_it.page_res = page_res;
60    page_res_it.restart_page();
61    std::string label;
62    TBOX tbox; 
63    TBOX bbox; 
64    bool keep_going;
65    int line_number = 0;
66    int examined_words = 0;
67    do {
68      keep_going = read_t(&page_res_it, &tbox);
69      keep_going &= ReadNextBox(applybox_page, &line_number, box_file, label, &bbox);
70      while (keep_going && !NearlyEqual<int>(tbox.bottom(), bbox.bottom(), kMaxBoxEdgeDiff)) {
<span onclick='openModal()' class='match'>71        if (bbox.bottom() < tbox.bottom()) {
72          page_res_it.forward();
73          keep_going = read_t(&page_res_it, &tbox);
74        } else {
75          keep_going = ReadNextBox(applybox_page, &line_number, box_file, label, &bbox);
76        }
77      }
</span>78      while (keep_going && !NearlyEqual<int>(tbox.left(), bbox.left(), kMaxBoxEdgeDiff)) {
79        if (bbox.left() > tbox.left()) {
80          page_res_it.forward();
81          keep_going = read_t(&page_res_it, &tbox);
82        } else {
83          keep_going = ReadNextBox(applybox_page, &line_number, box_file, label, &bbox);
84        }
85      }
86      if (keep_going && NearlyEqual<int>(tbox.right(), bbox.right(), kMaxBoxEdgeDiff) &&
87          NearlyEqual<int>(tbox.top(), bbox.top(), kMaxBoxEdgeDiff)) {
88        ambigs_classify_and_output(label.c_str(), &page_res_it, output_file);
89        examined_words++;
90      }
91      page_res_it.forward();
92    } while (keep_going);
93    int total_words = 0;
94    for (page_res_it.restart_page(); page_res_it.block() != nullptr; page_res_it.forward()) {
95      if (page_res_it.word()) {
96        if (page_res_it.word()->uch_set == nullptr) {
97          page_res_it.word()->SetupFake(unicharset);
98        }
99        total_words++;
100      }
101    }
102    if (examined_words < 0.85 * total_words) {
103      tprintf(
104          "TODO(antonova): clean up recog_training_segmented; "
105          " It examined only a small fraction of the ambigs image.\n");
106    }
107    tprintf("recog_training_segmented: examined %d / %d words.\n", examined_words, total_words);
108  }
109  static void PrintPath(int length, const BLOB_CHOICE **blob_choices, const UNICHARSET &unicharset,
110                        const char *label, FILE *output_file) {
111    float rating = 0.0f;
112    float certainty = 0.0f;
113    for (int i = 0; i < length; ++i) {
114      const BLOB_CHOICE *blob_choice = blob_choices[i];
115      fprintf(output_file, "%s", unicharset.id_to_unichar(blob_choice->unichar_id()));
116      rating += blob_choice->rating();
117      if (certainty > blob_choice->certainty()) {
118        certainty = blob_choice->certainty();
119      }
120    }
121    fprintf(output_file, "\t%s\t%.4f\t%.4f\n", label, rating, certainty);
122  }
123  static void PrintMatrixPaths(int col, int dim, const MATRIX &ratings, int length,
124                               const BLOB_CHOICE **blob_choices, const UNICHARSET &unicharset,
125                               const char *label, FILE *output_file) {
126    for (int row = col; row < dim && row - col < ratings.bandwidth(); ++row) {
127      if (ratings.get(col, row) != NOT_CLASSIFIED) {
128        BLOB_CHOICE_IT bc_it(ratings.get(col, row));
129        for (bc_it.mark_cycle_pt(); !bc_it.cycled_list(); bc_it.forward()) {
130          blob_choices[length] = bc_it.data();
131          if (row + 1 < dim) {
132            PrintMatrixPaths(row + 1, dim, ratings, length + 1, blob_choices, unicharset, label,
133                             output_file);
134          } else {
135            PrintPath(length + 1, blob_choices, unicharset, label, output_file);
136          }
137        }
138      }
139    }
140  }
141  void Tesseract::ambigs_classify_and_output(const char *label, PAGE_RES_IT *pr_it,
142                                             FILE *output_file) {
143    fflush(stdout);
144    WordData word_data(*pr_it);
145    SetupWordPassN(1, &word_data);
146    classify_word_and_language(1, pr_it, &word_data);
147    WERD_RES *werd_res = word_data.word;
148    WERD_CHOICE *best_choice = werd_res->best_choice;
149    ASSERT_HOST(best_choice != nullptr);
150    std::vector<UNICHAR_ID> encoding;
151    if (!unicharset.encode_string(label, true, &encoding, nullptr, nullptr)) {
152      tprintf("Not outputting illegal unichar %s\n", label);
153      return;
154    }
155    int dim = werd_res->ratings->dimension();
156    const auto **blob_choices = new const BLOB_CHOICE *[dim];
157    PrintMatrixPaths(0, dim, *werd_res->ratings, 0, blob_choices, unicharset, label, output_file);
158    delete[] blob_choices;
159  }
160  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-biasedrandomwalk.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recogtraining.cpp</div>
                <div class="column column_space"><pre><code>72        } else if (NbrH.IsKey(FId)) {
73          PTable.Add(Weight);
74          Psum += Weight;
75        } else {
76          PTable.Add(Weight / ParamQ);
77          Psum += Weight / ParamQ;
78        }
79      }
</pre></code></div>
                <div class="column column_space"><pre><code>71        if (bbox.bottom() < tbox.bottom()) {
72          page_res_it.forward();
73          keep_going = read_t(&page_res_it, &tbox);
74        } else {
75          keep_going = ReadNextBox(applybox_page, &line_number, box_file, label, &bbox);
76        }
77      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    