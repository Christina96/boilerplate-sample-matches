
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</h3>
            <pre><code>1  #include <time.h>
2  #include <shlwapi.h>
3  #include <shlobj.h>
4  #include "Parameters.h"
5  #include "ScintillaEditView.h"
6  #include "keys.h"
7  #include "localization.h"
8  #include "localizationString.h"
9  #include "UserDefineDialog.h"
10  #include "WindowsDlgRc.h"
11  #ifdef _MSC_VER
12  #pragma warning(disable : 4996) 
13  #endif
14  using namespace std;
15  namespace 
16  {
17  struct WinMenuKeyDefinition 
18  {
19  	int vKey;
20  	int functionId;
21  	bool isCtrl;
22  	bool isAlt;
23  	bool isShift;
24  	const TCHAR * specialName;		
25  };
26  struct ScintillaKeyDefinition
27  {
28  	const TCHAR * name;
29  	int functionId;
30  	bool isCtrl;
31  	bool isAlt;
32  	bool isShift;
33  	int vKey;
34  	int redirFunctionId;	
35  };
36  static const WinMenuKeyDefinition winKeyDefs[] =
37  {
38  	{ VK_N,       IDM_FILE_NEW,                                 true,  false, false, nullptr },
39  	{ VK_O,       IDM_FILE_OPEN,                                true,  false, false, nullptr },
40  	{ VK_NULL,    IDM_FILE_OPEN_FOLDER,                         false, false, false, TEXT("Open containing folder in Explorer") },
41  	{ VK_NULL,    IDM_FILE_OPEN_CMD,                            false, false, false, TEXT("Open containing folder in Command Prompt") },
42  	{ VK_NULL,    IDM_FILE_OPEN_DEFAULT_VIEWER,                 false, false, false, nullptr },
43  	{ VK_NULL,    IDM_FILE_OPENFOLDERASWORSPACE,                false, false, false, nullptr },
44  	{ VK_R,       IDM_FILE_RELOAD,                              true,  false, false, nullptr },
45  	{ VK_S,       IDM_FILE_SAVE,                                true,  false, false, nullptr },
46  	{ VK_S,       IDM_FILE_SAVEAS,                              true,  true,  false, nullptr },
47  	{ VK_NULL,    IDM_FILE_SAVECOPYAS,                          false, false, false, nullptr },
48  	{ VK_S,       IDM_FILE_SAVEALL,                             true,  false, true,  nullptr },
49  	{ VK_NULL,    IDM_FILE_RENAME,                              false, false, false, nullptr },
50  	{ VK_W,       IDM_FILE_CLOSE,                               true,  false, false, nullptr },
51  	{ VK_W,       IDM_FILE_CLOSEALL,                            true,  false, true,  nullptr },
52  	{ VK_NULL,    IDM_FILE_CLOSEALL_BUT_CURRENT,                false, false, false, nullptr },
53  	{ VK_NULL,    IDM_FILE_CLOSEALL_TOLEFT,                     false, false, false, nullptr },
54  	{ VK_NULL,    IDM_FILE_CLOSEALL_TORIGHT,                    false, false, false, nullptr },
55  	{ VK_NULL,    IDM_FILE_CLOSEALL_UNCHANGED,                  false, false, false, nullptr },
56  	{ VK_NULL,    IDM_FILE_DELETE,                              false, false, false, nullptr },
57  	{ VK_NULL,    IDM_FILE_LOADSESSION,                         false, false, false, nullptr },
58  	{ VK_NULL,    IDM_FILE_SAVESESSION,                         false, false, false, nullptr },
59  	{ VK_P,       IDM_FILE_PRINT,                               true,  false, false, nullptr },
60  	{ VK_NULL,    IDM_FILE_PRINTNOW,                            false, false, false, nullptr },
61  	{ VK_F4,      IDM_FILE_EXIT,                                false, true,  false, nullptr },
62  	{ VK_T,       IDM_FILE_RESTORELASTCLOSEDFILE,               true,  false, true,  TEXT("Restore Recent Closed File")},
63  	{ VK_B,       IDM_EDIT_BEGINENDSELECT,                      true,  false, true,  nullptr },
64  	{ VK_B,       IDM_EDIT_BEGINENDSELECT_COLUMNMODE,           false, true,  true,  nullptr },
65  	{ VK_NULL,    IDM_EDIT_FULLPATHTOCLIP,                      false, false, false, nullptr },
66  	{ VK_NULL,    IDM_EDIT_FILENAMETOCLIP,                      false, false, false, nullptr },
67  	{ VK_NULL,    IDM_EDIT_CURRENTDIRTOCLIP,                    false, false, false, nullptr },
68  	{ VK_NULL,    IDM_EDIT_COPY_ALL_NAMES,                      false, false, false, nullptr },
69  	{ VK_NULL,    IDM_EDIT_COPY_ALL_PATHS,                      false, false, false, nullptr },
70  	{ VK_NULL,    IDM_EDIT_INS_TAB,                             false, false, false, nullptr },
71  	{ VK_NULL,    IDM_EDIT_RMV_TAB,                             false, false, false, nullptr },
72  	{ VK_U,       IDM_EDIT_UPPERCASE,                           true,  false, true,  nullptr },
73  	{ VK_U,       IDM_EDIT_LOWERCASE,                           true,  false, false, nullptr },
74  	{ VK_U,       IDM_EDIT_PROPERCASE_FORCE,                    false, true,  false, nullptr },
75  	{ VK_U,       IDM_EDIT_PROPERCASE_BLEND,                    false, true,  true,  nullptr },
76  	{ VK_U,       IDM_EDIT_SENTENCECASE_FORCE,                  true,  true,  false, nullptr },
77  	{ VK_U,       IDM_EDIT_SENTENCECASE_BLEND,                  true,  true,  true,  nullptr },
78  	{ VK_NULL,    IDM_EDIT_INVERTCASE,                          false, false, false, nullptr },
79  	{ VK_NULL,    IDM_EDIT_RANDOMCASE,                          false, false, false, nullptr },
80  	{ VK_NULL,    IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES,        false, false, false, nullptr },
81  	{ VK_NULL,    IDM_EDIT_REMOVE_ANY_DUP_LINES,                false, false, false, nullptr },
82  	{ VK_I,       IDM_EDIT_SPLIT_LINES,                         true,  false, false, nullptr },
83  	{ VK_J,       IDM_EDIT_JOIN_LINES,                          true,  false, false, nullptr },
84  	{ VK_UP,      IDM_EDIT_LINE_UP,                             true,  false, true,  nullptr },
85  	{ VK_DOWN,    IDM_EDIT_LINE_DOWN,                           true,  false, true,  nullptr },
86  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINES,                    false, false, false, nullptr },
87  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINESWITHBLANK,           false, false, false, nullptr },
88  	{ VK_RETURN,  IDM_EDIT_BLANKLINEABOVECURRENT,               true,  true,  false, nullptr },
89  	{ VK_RETURN,  IDM_EDIT_BLANKLINEBELOWCURRENT,               true,  true,  true,  nullptr },
90  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING,   false, false, false, nullptr },
91  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING,  false, false, false, nullptr },
92  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING,   false, false, false, nullptr },
93  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING,  false, false, false, nullptr },
94  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_ASCENDING,         false, false, false, nullptr },
95  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_DESCENDING,        false, false, false, nullptr },
96  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING,    false, false, false, nullptr },
97  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING,   false, false, false, nullptr },
98  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING,      false, false, false, nullptr },
99  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING,     false, false, false, nullptr },
100  	{ VK_NULL,    IDM_EDIT_SORTLINES_REVERSE_ORDER,             false, false, false, nullptr },
101  	{ VK_NULL,    IDM_EDIT_SORTLINES_RANDOMLY,                  false, false, false, nullptr },
102  	{ VK_Q,       IDM_EDIT_BLOCK_COMMENT,                       true,  false, false, nullptr },
103  	{ VK_K,       IDM_EDIT_BLOCK_COMMENT_SET,                   true,  false, false, nullptr },
104  	{ VK_K,       IDM_EDIT_BLOCK_UNCOMMENT,                     true,  false, true,  nullptr },
105  	{ VK_Q,       IDM_EDIT_STREAM_COMMENT,                      true,  false, true,  nullptr },
106  	{ VK_NULL,    IDM_EDIT_STREAM_UNCOMMENT,                    false, false, false, nullptr },
107  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE,                        true,  false, false, nullptr },
108  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE_PATH,                   true,  true,  false, nullptr },
109  	{ VK_RETURN,  IDM_EDIT_AUTOCOMPLETE_CURRENTFILE,            true,  false, false, nullptr },
110  	{ VK_SPACE,   IDM_EDIT_FUNCCALLTIP,                         true,  false, true,  nullptr },
111  	{ VK_UP,      IDM_EDIT_FUNCCALLTIP_PREVIOUS,                false, true,  false, nullptr },
112  	{ VK_DOWN,    IDM_EDIT_FUNCCALLTIP_NEXT,                    false, true,  false, nullptr },
113  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_SHORT,               false, false, false, nullptr },
114  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_LONG,                false, false, false, nullptr },
115  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_CUSTOMIZED,          false, false, false, nullptr },
116  	{ VK_NULL,    IDM_FORMAT_TODOS,                             false, false, false, TEXT("EOL Conversion to Windows (CR LF)") },
117  	{ VK_NULL,    IDM_FORMAT_TOUNIX,                            false, false, false, TEXT("EOL Conversion to Unix (LF)") },
118  	{ VK_NULL,    IDM_FORMAT_TOMAC,                             false, false, false, TEXT("EOL Conversion to Macintosh (CR)") },
119  	{ VK_NULL,    IDM_EDIT_TRIMTRAILING,                        false, false, false, nullptr },
120  	{ VK_NULL,    IDM_EDIT_TRIMLINEHEAD,                        false, false, false, nullptr },
121  	{ VK_NULL,    IDM_EDIT_TRIM_BOTH,                           false, false, false, nullptr },
122  	{ VK_NULL,    IDM_EDIT_EOL2WS,                              false, false, false, nullptr },
123  	{ VK_NULL,    IDM_EDIT_TRIMALL,                             false, false, false, nullptr },
124  	{ VK_NULL,    IDM_EDIT_TAB2SW,                              false, false, false, nullptr },
125  	{ VK_NULL,    IDM_EDIT_SW2TAB_ALL,                          false, false, false, nullptr },
126  	{ VK_NULL,    IDM_EDIT_SW2TAB_LEADING,                      false, false, false, nullptr },
127  	{ VK_NULL,    IDM_EDIT_PASTE_AS_HTML,                       false, false, false, nullptr },
128  	{ VK_NULL,    IDM_EDIT_PASTE_AS_RTF,                        false, false, false, nullptr },
129  	{ VK_NULL,    IDM_EDIT_COPY_BINARY,                         false, false, false, nullptr },
130  	{ VK_NULL,    IDM_EDIT_CUT_BINARY,                          false, false, false, nullptr },
131  	{ VK_NULL,    IDM_EDIT_PASTE_BINARY,                        false, false, false, nullptr },
132  	{ VK_NULL,    IDM_EDIT_OPENASFILE,                          false, false, false, nullptr },
133  	{ VK_NULL,    IDM_EDIT_OPENINFOLDER,                        false, false, false, nullptr },
134  	{ VK_NULL,    IDM_EDIT_SEARCHONINTERNET,                    false, false, false, nullptr },
135  	{ VK_NULL,    IDM_EDIT_CHANGESEARCHENGINE,                  false, false, false, nullptr },
136  	{ VK_C,       IDM_EDIT_COLUMNMODE,                          false, true,  false, nullptr },
137  	{ VK_NULL,    IDM_EDIT_CHAR_PANEL,                          false, false, false, TEXT("Toggle Character Panel") },
138  	{ VK_NULL,    IDM_EDIT_CLIPBOARDHISTORY_PANEL,              false, false, false, TEXT("Toggle Clipboard History") },
139  	{ VK_NULL,    IDM_EDIT_SETREADONLY,                         false, false, false, nullptr },
140  	{ VK_NULL,    IDM_EDIT_CLEARREADONLY,                       false, false, false, nullptr },
141  	{ VK_F,       IDM_SEARCH_FIND,                              true,  false, false, nullptr },
142  	{ VK_F,       IDM_SEARCH_FINDINFILES,                       true,  false, true,  nullptr },
143  	{ VK_F3,      IDM_SEARCH_FINDNEXT,                          false, false, false, nullptr },
144  	{ VK_F3,      IDM_SEARCH_FINDPREV,                          false, false, true,  nullptr },
145  	{ VK_F3,      IDM_SEARCH_SETANDFINDNEXT,                    true,  false, false, nullptr },
146  	{ VK_F3,      IDM_SEARCH_SETANDFINDPREV,                    true,  false, true,  nullptr },
147  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDNEXT,                 true,  true,  false, nullptr },
148  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDPREV,                 true,  true,  true,  nullptr },
149  	{ VK_H,       IDM_SEARCH_REPLACE,                           true,  false, false, nullptr },
150  	{ VK_I,       IDM_SEARCH_FINDINCREMENT,                     true,  true,  false, nullptr },
151  	{ VK_F7,      IDM_FOCUS_ON_FOUND_RESULTS,                   false, false, false, nullptr },
152  	{ VK_F4,      IDM_SEARCH_GOTOPREVFOUND,                     false, false, true,  nullptr },
153  	{ VK_F4,      IDM_SEARCH_GOTONEXTFOUND,                     false, false, false, nullptr },
154  	{ VK_G,       IDM_SEARCH_GOTOLINE,                          true,  false, false, nullptr },
155  	{ VK_B,       IDM_SEARCH_GOTOMATCHINGBRACE,                 true,  false, false, nullptr },
156  	{ VK_B,       IDM_SEARCH_SELECTMATCHINGBRACES,              true,  true,  false, nullptr },
157  	{ VK_M,       IDM_SEARCH_MARK,                              true,  false, false, nullptr },
158  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT1,                       false, false, false, TEXT("Style all using 1st style") },
159  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT2,                       false, false, false, TEXT("Style all using 2nd style") },
160  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT3,                       false, false, false, TEXT("Style all using 3rd style") },
161  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT4,                       false, false, false, TEXT("Style all using 4th style") },
162  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT5,                       false, false, false, TEXT("Style all using 5th style") },
163  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT1,                       false, false, false, TEXT("Style one using 1st style") },
164  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT2,                       false, false, false, TEXT("Style one using 2nd style") },
165  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT3,                       false, false, false, TEXT("Style one using 3rd style") },
166  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT4,                       false, false, false, TEXT("Style one using 4th style") },
167  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT5,                       false, false, false, TEXT("Style one using 5th style") },
168  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT1,                     false, false, false, TEXT("Clear 1st style") },
169  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT2,                     false, false, false, TEXT("Clear 2nd style") },
170  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT3,                     false, false, false, TEXT("Clear 3rd style") },
171  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT4,                     false, false, false, TEXT("Clear 4th style") },
172  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT5,                     false, false, false, TEXT("Clear 5th style") },
173  	{ VK_NULL,    IDM_SEARCH_CLEARALLMARKS,                     false, false, false, TEXT("Clear all styles") },
174  	{ VK_1,       IDM_SEARCH_GOPREVMARKER1,                     true,  false, true,  TEXT("Previous style of 1st style") },
175  	{ VK_2,       IDM_SEARCH_GOPREVMARKER2,                     true,  false, true,  TEXT("Previous style of 2nd style") },
176  	{ VK_3,       IDM_SEARCH_GOPREVMARKER3,                     true,  false, true,  TEXT("Previous style of 3rd style") },
177  	{ VK_4,       IDM_SEARCH_GOPREVMARKER4,                     true,  false, true,  TEXT("Previous style of 4th style") },
178  	{ VK_5,       IDM_SEARCH_GOPREVMARKER5,                     true,  false, true,  TEXT("Previous style of 5th style") },
179  	{ VK_0,       IDM_SEARCH_GOPREVMARKER_DEF,                  true,  false, true,  TEXT("Previous style of Find Mark style") },
180  	{ VK_1,       IDM_SEARCH_GONEXTMARKER1,                     true,  false, false, TEXT("Next style of 1st style") },
181  	{ VK_2,       IDM_SEARCH_GONEXTMARKER2,                     true,  false, false, TEXT("Next style of 2nd style") },
182  	{ VK_3,       IDM_SEARCH_GONEXTMARKER3,                     true,  false, false, TEXT("Next style of 3rd style") },
183  	{ VK_4,       IDM_SEARCH_GONEXTMARKER4,                     true,  false, false, TEXT("Next style of 4th style") },
184  	{ VK_5,       IDM_SEARCH_GONEXTMARKER5,                     true,  false, false, TEXT("Next style of 5th style") },
185  	{ VK_0,       IDM_SEARCH_GONEXTMARKER_DEF,                  true,  false, false, TEXT("Next style of Find Mark style") },
186  	{ VK_NULL,    IDM_SEARCH_STYLE1TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 1st Style") },
187  	{ VK_NULL,    IDM_SEARCH_STYLE2TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 2nd Style") },
188  	{ VK_NULL,    IDM_SEARCH_STYLE3TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 3rd Style") },
189  	{ VK_NULL,    IDM_SEARCH_STYLE4TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 4th Style") },
190  	{ VK_NULL,    IDM_SEARCH_STYLE5TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 5th Style") },
191  	{ VK_NULL,    IDM_SEARCH_ALLSTYLESTOCLIP,                   false, false, false, TEXT("Copy Styled Text of All Styles") },
192  	{ VK_NULL,    IDM_SEARCH_MARKEDTOCLIP,                      false, false, false, TEXT("Copy Styled Text of Find Mark style") },
193  	{ VK_F2,      IDM_SEARCH_TOGGLE_BOOKMARK,                   true,  false, false, nullptr },
194  	{ VK_F2,      IDM_SEARCH_NEXT_BOOKMARK,                     false, false, false, nullptr },
195  	{ VK_F2,      IDM_SEARCH_PREV_BOOKMARK,                     false, false, true, nullptr  },
196  	{ VK_NULL,    IDM_SEARCH_CLEAR_BOOKMARKS,                   false, false, false, nullptr },
197  	{ VK_NULL,    IDM_SEARCH_CUTMARKEDLINES,                    false, false, false, nullptr },
198  	{ VK_NULL,    IDM_SEARCH_COPYMARKEDLINES,                   false, false, false, nullptr },
199  	{ VK_NULL,    IDM_SEARCH_PASTEMARKEDLINES,                  false, false, false, nullptr },
200  	{ VK_NULL,    IDM_SEARCH_DELETEMARKEDLINES,                 false, false, false, nullptr },
201  	{ VK_NULL,    IDM_SEARCH_DELETEUNMARKEDLINES,               false, false, false, nullptr },
202  	{ VK_NULL,    IDM_SEARCH_INVERSEMARKS,                      false, false, false, nullptr },
203  	{ VK_NULL,    IDM_SEARCH_FINDCHARINRANGE,                   false, false, false, nullptr },
204  	{ VK_NULL,    IDM_VIEW_ALWAYSONTOP,                         false, false, false, nullptr },
205  	{ VK_F11,     IDM_VIEW_FULLSCREENTOGGLE,                    false, false, false, nullptr },
206  	{ VK_F12,     IDM_VIEW_POSTIT,                              false, false, false, nullptr },
207  	{ VK_NULL,    IDM_VIEW_DISTRACTIONFREE,                     false, false, false, nullptr },
208  	{ VK_NULL,    IDM_VIEW_IN_FIREFOX,                          false, false, false, TEXT("View current file in Firefox") },
209  	{ VK_NULL,    IDM_VIEW_IN_CHROME,                           false, false, false, TEXT("View current file in Chrome") },
210  	{ VK_NULL,    IDM_VIEW_IN_IE,                               false, false, false, TEXT("View current file in IE") },
211  	{ VK_NULL,    IDM_VIEW_IN_EDGE,                             false, false, false, TEXT("View current file in Edge")  },
212  	{ VK_NULL,    IDM_VIEW_TAB_SPACE,                           false, false, false, nullptr },
213  	{ VK_NULL,    IDM_VIEW_EOL,                                 false, false, false, nullptr },
214  	{ VK_NULL,    IDM_VIEW_ALL_CHARACTERS,                      false, false, false, nullptr },
215  	{ VK_NULL,    IDM_VIEW_NPC,                                 false, false, false, nullptr },
216  	{ VK_NULL,    IDM_VIEW_NPC_CCUNIEOL,                        false, false, false, nullptr },
217  	{ VK_NULL,    IDM_VIEW_INDENT_GUIDE,                        false, false, false, nullptr },
218  	{ VK_NULL,    IDM_VIEW_WRAP_SYMBOL,                         false, false, false, nullptr },
219  	{ VK_NULL,    IDM_VIEW_GOTO_ANOTHER_VIEW,                   false, false, false, nullptr },
220  	{ VK_NULL,    IDM_VIEW_CLONE_TO_ANOTHER_VIEW,               false, false, false, nullptr },
221  	{ VK_NULL,    IDM_VIEW_GOTO_NEW_INSTANCE,                   false, false, false, nullptr },
222  	{ VK_NULL,    IDM_VIEW_LOAD_IN_NEW_INSTANCE,                false, false, false, nullptr },
223  	{ VK_NUMPAD1, IDM_VIEW_TAB1,                                true,  false, false, nullptr },
224  	{ VK_NUMPAD2, IDM_VIEW_TAB2,                                true,  false, false, nullptr },
225  	{ VK_NUMPAD3, IDM_VIEW_TAB3,                                true,  false, false, nullptr },
226  	{ VK_NUMPAD4, IDM_VIEW_TAB4,                                true,  false, false, nullptr },
227  	{ VK_NUMPAD5, IDM_VIEW_TAB5,                                true,  false, false, nullptr },
228  	{ VK_NUMPAD6, IDM_VIEW_TAB6,                                true,  false, false, nullptr },
229  	{ VK_NUMPAD7, IDM_VIEW_TAB7,                                true,  false, false, nullptr },
230  	{ VK_NUMPAD8, IDM_VIEW_TAB8,                                true,  false, false, nullptr },
231  	{ VK_NUMPAD9, IDM_VIEW_TAB9,                                true,  false, false, nullptr },
232  	{ VK_NEXT,    IDM_VIEW_TAB_NEXT,                            true,  false, false, nullptr },
233  	{ VK_PRIOR,   IDM_VIEW_TAB_PREV,                            true,  false, false, nullptr },
234  	{ VK_NEXT,    IDM_VIEW_TAB_MOVEFORWARD,                     true,  false, true,  nullptr },
235  	{ VK_PRIOR,   IDM_VIEW_TAB_MOVEBACKWARD,                    true,  false, true,  nullptr },
236  	{ VK_TAB,     IDC_PREV_DOC,                                 true,  false, true,  TEXT("Switch to previous document") },
237  	{ VK_TAB,     IDC_NEXT_DOC,                                 true,  false, false, TEXT("Switch to next document") },
238  	{ VK_NULL,    IDM_VIEW_WRAP,                                false, false, false, nullptr },
239  	{ VK_H,       IDM_VIEW_HIDELINES,                           false, true,  false, nullptr },
240  	{ VK_F8,      IDM_VIEW_SWITCHTO_OTHER_VIEW,                 false, false, false, nullptr },
241  	{ VK_0,       IDM_VIEW_FOLDALL,                             false, true,  false, nullptr },
242  	{ VK_0,       IDM_VIEW_UNFOLDALL,                           false, true,  true,  nullptr },
243  	{ VK_F,       IDM_VIEW_FOLD_CURRENT,                        true,  true,  false, nullptr },
244  	{ VK_F,       IDM_VIEW_UNFOLD_CURRENT,                      true,  true,  true,  nullptr },
245  	{ VK_1,       IDM_VIEW_FOLD_1,                              false, true,  false, TEXT("Fold Level 1") },
246  	{ VK_2,       IDM_VIEW_FOLD_2,                              false, true,  false, TEXT("Fold Level 2") },
247  	{ VK_3,       IDM_VIEW_FOLD_3,                              false, true,  false, TEXT("Fold Level 3") },
248  	{ VK_4,       IDM_VIEW_FOLD_4,                              false, true,  false, TEXT("Fold Level 4") },
249  	{ VK_5,       IDM_VIEW_FOLD_5,                              false, true,  false, TEXT("Fold Level 5") },
250  	{ VK_6,       IDM_VIEW_FOLD_6,                              false, true,  false, TEXT("Fold Level 6") },
251  	{ VK_7,       IDM_VIEW_FOLD_7,                              false, true,  false, TEXT("Fold Level 7") },
252  	{ VK_8,       IDM_VIEW_FOLD_8,                              false, true,  false, TEXT("Fold Level 8") },
253  	{ VK_1,       IDM_VIEW_UNFOLD_1,                            false, true,  true,  TEXT("Unfold Level 1") },
254  	{ VK_2,       IDM_VIEW_UNFOLD_2,                            false, true,  true,  TEXT("Unfold Level 2") },
255  	{ VK_3,       IDM_VIEW_UNFOLD_3,                            false, true,  true,  TEXT("Unfold Level 3") },
256  	{ VK_4,       IDM_VIEW_UNFOLD_4,                            false, true,  true,  TEXT("Unfold Level 4") },
257  	{ VK_5,       IDM_VIEW_UNFOLD_5,                            false, true,  true,  TEXT("Unfold Level 5") },
258  	{ VK_6,       IDM_VIEW_UNFOLD_6,                            false, true,  true,  TEXT("Unfold Level 6") },
259  	{ VK_7,       IDM_VIEW_UNFOLD_7,                            false, true,  true,  TEXT("Unfold Level 7") },
260  	{ VK_8,       IDM_VIEW_UNFOLD_8,                            false, true,  true,  TEXT("Unfold Level 8") },
261  	{ VK_NULL,    IDM_VIEW_SUMMARY,                             false, false, false, nullptr },
262  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_1,                     false, false, false, TEXT("Toggle Project Panel 1") },
263  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_2,                     false, false, false, TEXT("Toggle Project Panel 2") },
264  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_3,                     false, false, false, TEXT("Toggle Project Panel 3") },
265  	{ VK_NULL,    IDM_VIEW_FILEBROWSER,                         false, false, false, TEXT("Toggle Folder as Workspace") },
266  	{ VK_NULL,    IDM_VIEW_DOC_MAP,                             false, false, false, TEXT("Toggle Document Map") },
267  	{ VK_NULL,    IDM_VIEW_DOCLIST,                             false, false, false, TEXT("Toggle Document List") },
268  	{ VK_NULL,    IDM_VIEW_FUNC_LIST,                           false, false, false, TEXT("Toggle Function List") },
269  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_1,            false, false, false, TEXT("Switch to Project Panel 1") },
270  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_2,            false, false, false, TEXT("Switch to Project Panel 2") },
271  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_3,            false, false, false, TEXT("Switch to Project Panel 3") },
272  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FILEBROWSER,                false, false, false, TEXT("Switch to Folder as Workspace") },
273  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FUNC_LIST,                  false, false, false, TEXT("Switch to Function List") },
274  	{ VK_NULL,    IDM_VIEW_SWITCHTO_DOCLIST,                    false, false, false, TEXT("Switch to Document List") },
275  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_NONE,                     false, false, false, TEXT("Remove Tab Colour") },
276  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_1,                        false, false, false, TEXT("Apply Tab Colour 1") },
277  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_2,                        false, false, false, TEXT("Apply Tab Colour 2") },
278  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_3,                        false, false, false, TEXT("Apply Tab Colour 3") },
279  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_4,                        false, false, false, TEXT("Apply Tab Colour 4") },
280  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_5,                        false, false, false, TEXT("Apply Tab Colour 5") },
281  	{ VK_NULL,    IDM_VIEW_SYNSCROLLV,                          false, false, false, nullptr },
282  	{ VK_NULL,    IDM_VIEW_SYNSCROLLH,                          false, false, false, nullptr },
283  	{ VK_R,       IDM_EDIT_RTL,                                 true,  true,  false, nullptr },
284  	{ VK_L,       IDM_EDIT_LTR,                                 true,  true,  false, nullptr },
285  	{ VK_NULL,    IDM_VIEW_MONITORING,                          false, false, false, nullptr },
286  	{ VK_NULL,    IDM_FORMAT_ANSI,                              false, false, false, nullptr },
287  	{ VK_NULL,    IDM_FORMAT_AS_UTF_8,                          false, false, false, nullptr },
288  	{ VK_NULL,    IDM_FORMAT_UTF_8,                             false, false, false, nullptr },
289  	{ VK_NULL,    IDM_FORMAT_UTF_16BE,                          false, false, false, nullptr },
290  	{ VK_NULL,    IDM_FORMAT_UTF_16LE,                          false, false, false, nullptr },
291  	{ VK_NULL,    IDM_FORMAT_ISO_8859_6,                        false, false, false, nullptr },
292  	{ VK_NULL,    IDM_FORMAT_WIN_1256,                          false, false, false, nullptr },
293  	{ VK_NULL,    IDM_FORMAT_ISO_8859_13,                       false, false, false, nullptr },
294  	{ VK_NULL,    IDM_FORMAT_WIN_1257,                          false, false, false, nullptr },
295  	{ VK_NULL,    IDM_FORMAT_ISO_8859_14,                       false, false, false, nullptr },
296  	{ VK_NULL,    IDM_FORMAT_ISO_8859_5,                        false, false, false, nullptr },
297  	{ VK_NULL,    IDM_FORMAT_MAC_CYRILLIC,                      false, false, false, nullptr },
298  	{ VK_NULL,    IDM_FORMAT_KOI8R_CYRILLIC,                    false, false, false, nullptr },
299  	{ VK_NULL,    IDM_FORMAT_KOI8U_CYRILLIC,                    false, false, false, nullptr },
300  	{ VK_NULL,    IDM_FORMAT_WIN_1251,                          false, false, false, nullptr },
301  	{ VK_NULL,    IDM_FORMAT_WIN_1250,                          false, false, false, nullptr },
302  	{ VK_NULL,    IDM_FORMAT_DOS_437,                           false, false, false, nullptr },
303  	{ VK_NULL,    IDM_FORMAT_DOS_720,                           false, false, false, nullptr },
304  	{ VK_NULL,    IDM_FORMAT_DOS_737,                           false, false, false, nullptr },
305  	{ VK_NULL,    IDM_FORMAT_DOS_775,                           false, false, false, nullptr },
306  	{ VK_NULL,    IDM_FORMAT_DOS_850,                           false, false, false, nullptr },
307  	{ VK_NULL,    IDM_FORMAT_DOS_852,                           false, false, false, nullptr },
308  	{ VK_NULL,    IDM_FORMAT_DOS_855,                           false, false, false, nullptr },
309  	{ VK_NULL,    IDM_FORMAT_DOS_857,                           false, false, false, nullptr },
310  	{ VK_NULL,    IDM_FORMAT_DOS_858,                           false, false, false, nullptr },
311  	{ VK_NULL,    IDM_FORMAT_DOS_860,                           false, false, false, nullptr },
312  	{ VK_NULL,    IDM_FORMAT_DOS_861,                           false, false, false, nullptr },
313  	{ VK_NULL,    IDM_FORMAT_DOS_862,                           false, false, false, nullptr },
314  	{ VK_NULL,    IDM_FORMAT_DOS_863,                           false, false, false, nullptr },
315  	{ VK_NULL,    IDM_FORMAT_DOS_865,                           false, false, false, nullptr },
316  	{ VK_NULL,    IDM_FORMAT_DOS_866,                           false, false, false, nullptr },
317  	{ VK_NULL,    IDM_FORMAT_DOS_869,                           false, false, false, nullptr },
318  	{ VK_NULL,    IDM_FORMAT_BIG5,                              false, false, false, nullptr },
319  	{ VK_NULL,    IDM_FORMAT_GB2312,                            false, false, false, nullptr },
320  	{ VK_NULL,    IDM_FORMAT_ISO_8859_2,                        false, false, false, nullptr },
321  	{ VK_NULL,    IDM_FORMAT_ISO_8859_7,                        false, false, false, nullptr },
322  	{ VK_NULL,    IDM_FORMAT_WIN_1253,                          false, false, false, nullptr },
323  	{ VK_NULL,    IDM_FORMAT_ISO_8859_8,                        false, false, false, nullptr },
324  	{ VK_NULL,    IDM_FORMAT_WIN_1255,                          false, false, false, nullptr },
325  	{ VK_NULL,    IDM_FORMAT_SHIFT_JIS,                         false, false, false, nullptr },
326  	{ VK_NULL,    IDM_FORMAT_EUC_KR,                            false, false, false, nullptr },
327  	{ VK_NULL,    IDM_FORMAT_ISO_8859_15,                       false, false, false, nullptr },
328  	{ VK_NULL,    IDM_FORMAT_ISO_8859_4,                        false, false, false, nullptr },
329  	{ VK_NULL,    IDM_FORMAT_ISO_8859_3,                        false, false, false, nullptr },
330  	{ VK_NULL,    IDM_FORMAT_TIS_620,                           false, false, false, nullptr },
331  	{ VK_NULL,    IDM_FORMAT_ISO_8859_9,                        false, false, false, nullptr },
332  	{ VK_NULL,    IDM_FORMAT_WIN_1254,                          false, false, false, nullptr },
333  	{ VK_NULL,    IDM_FORMAT_WIN_1252,                          false, false, false, nullptr },
334  	{ VK_NULL,    IDM_FORMAT_ISO_8859_1,                        false, false, false, nullptr },
335  	{ VK_NULL,    IDM_FORMAT_WIN_1258,                          false, false, false, nullptr },
336  	{ VK_NULL,    IDM_FORMAT_CONV2_ANSI,                        false, false, false, nullptr },
337  	{ VK_NULL,    IDM_FORMAT_CONV2_AS_UTF_8,                    false, false, false, nullptr },
338  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_8,                       false, false, false, nullptr },
339  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16BE,                    false, false, false, nullptr },
340  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16LE,                    false, false, false, nullptr },
341  	{ VK_NULL,    IDM_LANG_USER_DLG,                            false, false, false, nullptr },
342  	{ VK_NULL,    IDM_LANG_USER,                                false, false, false, nullptr },
343  	{ VK_NULL,    IDM_LANG_OPENUDLDIR,                          false, false, false, nullptr },
344  	{ VK_NULL,    IDM_SETTING_PREFERENCE,                       false, false, false, nullptr },
345  	{ VK_NULL,    IDM_LANGSTYLE_CONFIG_DLG,                     false, false, false, nullptr },
346  	{ VK_NULL,    IDM_SETTING_SHORTCUT_MAPPER,                  false, false, false, nullptr },
347  	{ VK_NULL,    IDM_SETTING_IMPORTPLUGIN,                     false, false, false, nullptr },
348  	{ VK_NULL,    IDM_SETTING_IMPORTSTYLETHEMS,                 false, false, false, nullptr },
349  	{ VK_NULL,    IDM_SETTING_EDITCONTEXTMENU,                  false, false, false, nullptr },
350  	{ VK_R,       IDC_EDIT_TOGGLEMACRORECORDING,                true,  false, true,  TEXT("Toggle macro recording")},
351  	{ VK_NULL,    IDM_MACRO_STARTRECORDINGMACRO,                false, false, false, nullptr },
352  	{ VK_NULL,    IDM_MACRO_STOPRECORDINGMACRO,                 false, false, false, nullptr },
353  	{ VK_P,       IDM_MACRO_PLAYBACKRECORDEDMACRO,              true,  false, true,  nullptr },
354  	{ VK_NULL,    IDM_MACRO_SAVECURRENTMACRO,                   false, false, false, nullptr },
355  	{ VK_NULL,    IDM_MACRO_RUNMULTIMACRODLG,                   false, false, false, nullptr },
356  	{ VK_F5,      IDM_EXECUTE,                                  false, false, false, nullptr },
357  	{ VK_NULL,    IDM_WINDOW_SORT_FN_ASC,                       false, false, false, TEXT("Sort By Name A to Z") },
358  	{ VK_NULL,    IDM_WINDOW_SORT_FN_DSC,                       false, false, false, TEXT("Sort By Name Z to A") },
359  	{ VK_NULL,    IDM_WINDOW_SORT_FP_ASC,                       false, false, false, TEXT("Sort By Path A to Z") },
360  	{ VK_NULL,    IDM_WINDOW_SORT_FP_DSC,                       false, false, false, TEXT("Sort By Path Z to A") },
361  	{ VK_NULL,    IDM_WINDOW_SORT_FT_ASC,                       false, false, false, TEXT("Sort By Type A to Z") },
362  	{ VK_NULL,    IDM_WINDOW_SORT_FT_DSC,                       false, false, false, TEXT("Sort By Type Z to A") },
363  	{ VK_NULL,    IDM_WINDOW_SORT_FS_ASC,                       false, false, false, TEXT("Sort By Size Smaller to Larger") },
364  	{ VK_NULL,    IDM_WINDOW_SORT_FS_DSC,                       false, false, false, TEXT("Sort By Size Larger to Smaller") },
365  	{ VK_NULL,    IDM_CMDLINEARGUMENTS,                         false, false, false, nullptr },
366  	{ VK_NULL,    IDM_HOMESWEETHOME,                            false, false, false, nullptr },
367  	{ VK_NULL,    IDM_PROJECTPAGE,                              false, false, false, nullptr },
368  	{ VK_NULL,    IDM_ONLINEDOCUMENT,                           false, false, false, nullptr },
369  	{ VK_NULL,    IDM_FORUM,                                    false, false, false, nullptr },
370  	{ VK_NULL,    IDM_UPDATE_NPP,                               false, false, false, TEXT("Update Notepad++") },
371  	{ VK_NULL,    IDM_CONFUPDATERPROXY,                         false, false, false, TEXT("Set Updater Proxy...") },
372  	{ VK_NULL,    IDM_DEBUGINFO,                                false, false, false, nullptr },
373  	{ VK_F1,      IDM_ABOUT,                                    false, false, false, nullptr }
374  };
375  static const ScintillaKeyDefinition scintKeyDefs[] =
376  {
377  	{TEXT("SCI_CUT"),                     SCI_CUT,                     true,  false, false, VK_X,        IDM_EDIT_CUT},
378  	{TEXT(""),                            SCI_CUT,                     false, false, true,  VK_DELETE,   0},
379  	{TEXT("SCI_COPY"),                    SCI_COPY,                    true,  false, false, VK_C,        IDM_EDIT_COPY},
380  	{TEXT(""),                            SCI_COPY,                    true,  false, false, VK_INSERT,   0},
381  	{TEXT("SCI_PASTE"),                   SCI_PASTE,                   true,  false, false, VK_V,        IDM_EDIT_PASTE},
382  	{TEXT(""),                            SCI_PASTE,                   false, false, true,  VK_INSERT,   0},
383  	{TEXT("SCI_SELECTALL"),               SCI_SELECTALL,               true,  false, false, VK_A,        IDM_EDIT_SELECTALL},
384  	{TEXT("SCI_CLEAR"),                   SCI_CLEAR,                   false, false, false, VK_DELETE,   IDM_EDIT_DELETE},
385  	{TEXT("SCI_CLEARALL"),                SCI_CLEARALL,                false, false, false, 0,           0},
386  	{TEXT("SCI_UNDO"),                    SCI_UNDO,                    true,  false, false, VK_Z,        IDM_EDIT_UNDO},
387  	{TEXT(""),                            SCI_UNDO,                    false, true,  false, VK_BACK,     0},
388  	{TEXT("SCI_REDO"),                    SCI_REDO,                    true,  false, false, VK_Y,        IDM_EDIT_REDO},
389  	{TEXT(""),                            SCI_REDO,                    true,  false, true,  VK_Z,        0},
390  	{TEXT("SCI_NEWLINE"),                 SCI_NEWLINE,                 false, false, false, VK_RETURN,   0},
391  	{TEXT(""),                            SCI_NEWLINE,                 false, false, true,  VK_RETURN,   0},
392  	{TEXT("SCI_TAB"),                     SCI_TAB,                     false, false, false, VK_TAB,      0},
393  	{TEXT("SCI_BACKTAB"),                 SCI_BACKTAB,                 false, false, true,  VK_TAB,      0},
394  	{TEXT("SCI_FORMFEED"),                SCI_FORMFEED,                false, false, false, 0,           0},
395  	{TEXT("SCI_ZOOMIN"),                  SCI_ZOOMIN,                  true,  false, false, VK_ADD,      IDM_VIEW_ZOOMIN},
396  	{TEXT("SCI_ZOOMOUT"),                 SCI_ZOOMOUT,                 true,  false, false, VK_SUBTRACT, IDM_VIEW_ZOOMOUT},
397  	{TEXT("SCI_SETZOOM"),                 SCI_SETZOOM,                 true,  false, false, VK_DIVIDE,   IDM_VIEW_ZOOMRESTORE},
398  	{TEXT("SCI_SELECTIONDUPLICATE"),      SCI_SELECTIONDUPLICATE,      true,  false, false, VK_D,        IDM_EDIT_DUP_LINE},
399  	{TEXT("SCI_LINESJOIN"),               SCI_LINESJOIN,               false, false, false, 0,           0},
400  	{TEXT("SCI_SCROLLCARET"),             SCI_SCROLLCARET,             false, false, false, 0,           0},
401  	{TEXT("SCI_EDITTOGGLEOVERTYPE"),      SCI_EDITTOGGLEOVERTYPE,      false, false, false, VK_INSERT,   0},
402  	{TEXT("SCI_MOVECARETINSIDEVIEW"),     SCI_MOVECARETINSIDEVIEW,     false, false, false, 0,           0},
403  	{TEXT("SCI_LINEDOWN"),                SCI_LINEDOWN,                false, false, false, VK_DOWN,     0},
404  	{TEXT("SCI_LINEDOWNEXTEND"),          SCI_LINEDOWNEXTEND,          false, false, true,  VK_DOWN,     0},
405  	{TEXT("SCI_LINEDOWNRECTEXTEND"),      SCI_LINEDOWNRECTEXTEND,      false, true,  true,  VK_DOWN,     0},
406  	{TEXT("SCI_LINESCROLLDOWN"),          SCI_LINESCROLLDOWN,          true,  false, false, VK_DOWN,     0},
407  	{TEXT("SCI_LINEUP"),                  SCI_LINEUP,                  false, false, false, VK_UP,       0},
408  	{TEXT("SCI_LINEUPEXTEND"),            SCI_LINEUPEXTEND,            false, false, true,  VK_UP,       0},
409  	{TEXT("SCI_LINEUPRECTEXTEND"),        SCI_LINEUPRECTEXTEND,        false, true,  true,  VK_UP,       0},
410  	{TEXT("SCI_LINESCROLLUP"),            SCI_LINESCROLLUP,            true,  false, false, VK_UP,       0},
411  	{TEXT("SCI_PARADOWN"),                SCI_PARADOWN,                true,  false, false, VK_OEM_6,    0},
412  	{TEXT("SCI_PARADOWNEXTEND"),          SCI_PARADOWNEXTEND,          true,  false, true,  VK_OEM_6,    0},
413  	{TEXT("SCI_PARAUP"),                  SCI_PARAUP,                  true,  false, false, VK_OEM_4,    0},
414  	{TEXT("SCI_PARAUPEXTEND"),            SCI_PARAUPEXTEND,            true,  false, true,  VK_OEM_4,    0},
415  	{TEXT("SCI_CHARLEFT"),                SCI_CHARLEFT,                false, false, false, VK_LEFT,     0},
416  	{TEXT("SCI_CHARLEFTEXTEND"),          SCI_CHARLEFTEXTEND,          false, false, true,  VK_LEFT,     0},
417  	{TEXT("SCI_CHARLEFTRECTEXTEND"),      SCI_CHARLEFTRECTEXTEND,      false, true,  true,  VK_LEFT,     0},
418  	{TEXT("SCI_CHARRIGHT"),               SCI_CHARRIGHT,               false, false, false, VK_RIGHT,    0},
419  	{TEXT("SCI_CHARRIGHTEXTEND"),         SCI_CHARRIGHTEXTEND,         false, false, true,  VK_RIGHT,    0},
420  	{TEXT("SCI_CHARRIGHTRECTEXTEND"),     SCI_CHARRIGHTRECTEXTEND,     false, true,  true,  VK_RIGHT,    0},
421  	{TEXT("SCI_WORDLEFT"),                SCI_WORDLEFT,                true,  false, false, VK_LEFT,     0},
422  	{TEXT("SCI_WORDLEFTEXTEND"),          SCI_WORDLEFTEXTEND,          true,  false, true,  VK_LEFT,     0},
423  	{TEXT("SCI_WORDRIGHT"),               SCI_WORDRIGHT,               true,  false, false, VK_RIGHT,    0},
424  	{TEXT("SCI_WORDRIGHTEXTEND"),         SCI_WORDRIGHTEXTEND,         false, false, false, 0,           0},
425  	{TEXT("SCI_WORDLEFTEND"),             SCI_WORDLEFTEND,             false, false, false, 0,           0},
426  	{TEXT("SCI_WORDLEFTENDEXTEND"),       SCI_WORDLEFTENDEXTEND,       false, false, false, 0,           0},
427  	{TEXT("SCI_WORDRIGHTEND"),            SCI_WORDRIGHTEND,            false, false, false, 0,           0},
428  	{TEXT("SCI_WORDRIGHTENDEXTEND"),      SCI_WORDRIGHTENDEXTEND,      true,  false, true,  VK_RIGHT,    0},
429  	{TEXT("SCI_WORDPARTLEFT"),            SCI_WORDPARTLEFT,            true,  false, false, VK_OEM_2,    0},
430  	{TEXT("SCI_WORDPARTLEFTEXTEND"),      SCI_WORDPARTLEFTEXTEND,      true,  false, true,  VK_OEM_2,    0},
431  	{TEXT("SCI_WORDPARTRIGHT"),           SCI_WORDPARTRIGHT,           true,  false, false, VK_OEM_5,    0},
432  	{TEXT("SCI_WORDPARTRIGHTEXTEND"),     SCI_WORDPARTRIGHTEXTEND,     true,  false, true,  VK_OEM_5,    0},
433  	{TEXT("SCI_HOME"),                    SCI_HOME,                    false, false, false, 0,           0},
434  	{TEXT("SCI_HOMEEXTEND"),              SCI_HOMEEXTEND,              false, false, false, 0,           0},
435  	{TEXT("SCI_HOMERECTEXTEND"),          SCI_HOMERECTEXTEND,          false, false, false, 0,           0},
436  	{TEXT("SCI_HOMEDISPLAY"),             SCI_HOMEDISPLAY,             false, true,  false, VK_HOME,     0},
437  	{TEXT("SCI_HOMEDISPLAYEXTEND"),       SCI_HOMEDISPLAYEXTEND,       false, false, false, 0,           0},
438  	{TEXT("SCI_HOMEWRAP"),                SCI_HOMEWRAP,                false, false, false, 0,           0},
439  	{TEXT("SCI_HOMEWRAPEXTEND"),          SCI_HOMEWRAPEXTEND,          false, false, false, 0,           0},
440  	{TEXT("SCI_VCHOME"),                  SCI_VCHOME,                  false, false, false, 0,           0},
441  	{TEXT("SCI_VCHOMEEXTEND"),            SCI_VCHOMEEXTEND,            false, false, false, 0,           0},
442  	{TEXT("SCI_VCHOMERECTEXTEND"),        SCI_VCHOMERECTEXTEND,        false, true,  true,  VK_HOME,     0},
443  	{TEXT("SCI_VCHOMEDISPLAY"),           SCI_VCHOMEDISPLAY,           false, false, false, 0,           0},
444  	{TEXT("SCI_VCHOMEDISPLAYEXTEND"),     SCI_VCHOMEDISPLAYEXTEND,     false, false, false, 0,           0},
445  	{TEXT("SCI_VCHOMEWRAP"),              SCI_VCHOMEWRAP,              false, false, false, VK_HOME,     0},
446  	{TEXT("SCI_VCHOMEWRAPEXTEND"),        SCI_VCHOMEWRAPEXTEND,        false, false, true,  VK_HOME,     0},
447  	{TEXT("SCI_LINEEND"),                 SCI_LINEEND,                 false, false, false, 0,           0},
448  	{TEXT("SCI_LINEENDWRAPEXTEND"),       SCI_LINEENDWRAPEXTEND,       false, false, true,  VK_END,      0},
449  	{TEXT("SCI_LINEENDRECTEXTEND"),       SCI_LINEENDRECTEXTEND,       false, true,  true,  VK_END,      0},
450  	{TEXT("SCI_LINEENDDISPLAY"),          SCI_LINEENDDISPLAY,          false, true,  false, VK_END,      0},
451  	{TEXT("SCI_LINEENDDISPLAYEXTEND"),    SCI_LINEENDDISPLAYEXTEND,    false, false, false, 0,           0},
452  	{TEXT("SCI_LINEENDWRAP"),             SCI_LINEENDWRAP,             false, false, false, VK_END,      0},
453  	{TEXT("SCI_LINEENDEXTEND"),           SCI_LINEENDEXTEND,           false, false, false, 0,           0},
454  	{TEXT("SCI_DOCUMENTSTART"),           SCI_DOCUMENTSTART,           true,  false, false, VK_HOME,     0},
455  	{TEXT("SCI_DOCUMENTSTARTEXTEND"),     SCI_DOCUMENTSTARTEXTEND,     true,  false, true,  VK_HOME,     0},
456  	{TEXT("SCI_DOCUMENTEND"),             SCI_DOCUMENTEND,             true,  false, false, VK_END,      0},
457  	{TEXT("SCI_DOCUMENTENDEXTEND"),       SCI_DOCUMENTENDEXTEND,       true,  false, true,  VK_END,      0},
458  	{TEXT("SCI_PAGEUP"),                  SCI_PAGEUP,                  false, false, false, VK_PRIOR,    0},
459  	{TEXT("SCI_PAGEUPEXTEND"),            SCI_PAGEUPEXTEND,            false, false, true,  VK_PRIOR,    0},
460  	{TEXT("SCI_PAGEUPRECTEXTEND"),        SCI_PAGEUPRECTEXTEND,        false, true,  true,  VK_PRIOR,    0},
461  	{TEXT("SCI_PAGEDOWN"),                SCI_PAGEDOWN,                false, false, false, VK_NEXT,     0},
462  	{TEXT("SCI_PAGEDOWNEXTEND"),          SCI_PAGEDOWNEXTEND,          false, false, true,  VK_NEXT,     0},
463  	{TEXT("SCI_PAGEDOWNRECTEXTEND"),      SCI_PAGEDOWNRECTEXTEND,      false, true,  true,  VK_NEXT,     0},
464  	{TEXT("SCI_STUTTEREDPAGEUP"),         SCI_STUTTEREDPAGEUP,         false, false, false, 0,           0},
465  	{TEXT("SCI_STUTTEREDPAGEUPEXTEND"),   SCI_STUTTEREDPAGEUPEXTEND,   false, false, false, 0,           0},
466  	{TEXT("SCI_STUTTEREDPAGEDOWN"),       SCI_STUTTEREDPAGEDOWN,       false, false, false, 0,           0},
467  	{TEXT("SCI_STUTTEREDPAGEDOWNEXTEND"), SCI_STUTTEREDPAGEDOWNEXTEND, false, false, false, 0,           0},
468  	{TEXT("SCI_DELETEBACK"),              SCI_DELETEBACK,              false, false, false, VK_BACK,     0},
469  	{TEXT(""),                            SCI_DELETEBACK,              false, false, true,  VK_BACK,     0},
470  	{TEXT("SCI_DELETEBACKNOTLINE"),       SCI_DELETEBACKNOTLINE,       false, false, false, 0,           0},
471  	{TEXT("SCI_DELWORDLEFT"),             SCI_DELWORDLEFT,             true,  false, false, VK_BACK,     0},
472  	{TEXT("SCI_DELWORDRIGHT"),            SCI_DELWORDRIGHT,            true,  false, false, VK_DELETE,   0},
473  	{TEXT("SCI_DELLINELEFT"),             SCI_DELLINELEFT,             true,  false, true,  VK_BACK,     0},
474  	{TEXT("SCI_DELLINERIGHT"),            SCI_DELLINERIGHT,            true,  false, true,  VK_DELETE,   0},
475  	{TEXT("SCI_LINEDELETE"),              SCI_LINEDELETE,              true,  false, true,  VK_L,        0},
476  	{TEXT("SCI_LINECUT"),                 SCI_LINECUT,                 true,  false, false, VK_L,        0},
477  	{TEXT("SCI_LINECOPY"),                SCI_LINECOPY,                true,  false, true,  VK_X,        0},
478  	{TEXT("SCI_LINETRANSPOSE"),           SCI_LINETRANSPOSE,           true,  false, false, VK_T,        0},
479  	{TEXT("SCI_LINEDUPLICATE"),           SCI_LINEDUPLICATE,           false, false, false, 0,           0},
480  	{TEXT("SCI_CANCEL"),                  SCI_CANCEL,                  false, false, false, VK_ESCAPE,   0},
481  	{TEXT("SCI_SWAPMAINANCHORCARET"),     SCI_SWAPMAINANCHORCARET,     false, false, false, 0,           0},
482  	{TEXT("SCI_ROTATESELECTION"),         SCI_ROTATESELECTION,         false, false, false, 0,           0}
483  };
484  #define NONEEDSHORTCUTSXMLBACKUP_FILENAME L"v852NoNeedShortcutsBackup.xml"
485  #define SHORTCUTSXML_FILENAME L"shortcuts.xml"
486  typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
487  int strVal(const TCHAR *str, int base)
488  {
489  	if (!str) return -1;
490  	if (!str[0]) return 0;
491  	TCHAR *finStr;
492  	int result = wcstol(str, &finStr, base);
493  	if (*finStr != '\0')
494  		return -1;
495  	return result;
496  }
497  int decStrVal(const TCHAR *str)
498  {
499  	return strVal(str, 10);
500  }
501  int hexStrVal(const TCHAR *str)
502  {
503  	return strVal(str, 16);
504  }
505  int getKwClassFromName(const TCHAR *str)
506  {
507  	if (!lstrcmp(TEXT("instre1"), str)) return LANG_INDEX_INSTR;
508  	if (!lstrcmp(TEXT("instre2"), str)) return LANG_INDEX_INSTR2;
509  	if (!lstrcmp(TEXT("type1"), str)) return LANG_INDEX_TYPE;
510  	if (!lstrcmp(TEXT("type2"), str)) return LANG_INDEX_TYPE2;
511  	if (!lstrcmp(TEXT("type3"), str)) return LANG_INDEX_TYPE3;
512  	if (!lstrcmp(TEXT("type4"), str)) return LANG_INDEX_TYPE4;
513  	if (!lstrcmp(TEXT("type5"), str)) return LANG_INDEX_TYPE5;
514  	if (!lstrcmp(TEXT("type6"), str)) return LANG_INDEX_TYPE6;
515  	if (!lstrcmp(TEXT("type7"), str)) return LANG_INDEX_TYPE7;
516  	if ((str[1] == '\0') && (str[0] >= '0') && (str[0] <= '8')) 
517  		return str[0] - '0';
518  	return -1;
519  }
520  } 
521  void cutString(const TCHAR* str2cut, vector<generic_string>& patternVect)
522  {
523  	if (str2cut == nullptr) return;
524  	const TCHAR *pBegin = str2cut;
525  	const TCHAR *pEnd = pBegin;
526  	while (*pEnd != '\0')
527  	{
528  		if (_istspace(*pEnd))
529  		{
530  			if (pBegin != pEnd)
531  				patternVect.emplace_back(pBegin, pEnd);
532  			pBegin = pEnd + 1;
533  		}
534  		++pEnd;
535  	}
536  	if (pBegin != pEnd)
537  		patternVect.emplace_back(pBegin, pEnd);
538  }
539  void cutStringBy(const TCHAR* str2cut, vector<generic_string>& patternVect, char byChar, bool allowEmptyStr)
540  {
541  	if (str2cut == nullptr) return;
542  	const TCHAR* pBegin = str2cut;
543  	const TCHAR* pEnd = pBegin;
544  	while (*pEnd != '\0')
545  	{
546  		if (*pEnd == byChar)
547  		{
548  			if (allowEmptyStr)
549  				patternVect.emplace_back(pBegin, pEnd);
550  			else if (pBegin != pEnd)
551  				patternVect.emplace_back(pBegin, pEnd);
552  			pBegin = pEnd + 1;
553  		}
554  		++pEnd;
555  	}
556  	if (allowEmptyStr)
557  		patternVect.emplace_back(pBegin, pEnd);
558  	else if (pBegin != pEnd)
559  		patternVect.emplace_back(pBegin, pEnd);
560  }
561  std::wstring LocalizationSwitcher::getLangFromXmlFileName(const wchar_t *fn) const
562  {
563  	size_t nbItem = sizeof(localizationDefs)/sizeof(LocalizationSwitcher::LocalizationDefinition);
564  	for (size_t i = 0 ; i < nbItem ; ++i)
565  	{
566  		if (0 == wcsicmp(fn, localizationDefs[i]._xmlFileName))
567  			return localizationDefs[i]._langName;
568  	}
569  	return std::wstring();
570  }
571  std::wstring LocalizationSwitcher::getXmlFilePathFromLangName(const wchar_t *langName) const
572  {
573  	for (size_t i = 0, len = _localizationList.size(); i < len ; ++i)
574  	{
575  		if (0 == wcsicmp(langName, _localizationList[i].first.c_str()))
576  			return _localizationList[i].second;
577  	}
578  	return std::wstring();
579  }
580  bool LocalizationSwitcher::addLanguageFromXml(const std::wstring& xmlFullPath)
581  {
582  	wchar_t * fn = ::PathFindFileNameW(xmlFullPath.c_str());
583  	wstring foundLang = getLangFromXmlFileName(fn);
584  	if (!foundLang.empty())
585  	{
586  		_localizationList.push_back(pair<wstring, wstring>(foundLang, xmlFullPath));
587  		return true;
588  	}
589  	return false;
590  }
591  bool LocalizationSwitcher::switchToLang(const wchar_t *lang2switch) const
592  {
593  	wstring langPath = getXmlFilePathFromLangName(lang2switch);
594  	if (langPath.empty())
595  		return false;
596  	return ::CopyFileW(langPath.c_str(), _nativeLangPath.c_str(), FALSE) != FALSE;
597  }
598  generic_string ThemeSwitcher::getThemeFromXmlFileName(const TCHAR *xmlFullPath) const
599  {
600  	if (!xmlFullPath || !xmlFullPath[0])
601  		return generic_string();
602  	generic_string fn(::PathFindFileName(xmlFullPath));
603  	PathRemoveExtension(const_cast<TCHAR *>(fn.c_str()));
604  	return fn;
605  }
606  int DynamicMenu::getTopLevelItemNumber() const
607  {
608  	int nb = 0;
609  	generic_string previousFolderName;
610  	for (const MenuItemUnit& i : _menuItems)
611  	{
612  		if (i._parentFolderName.empty())
613  		{
614  			++nb;
615  		}
616  		else
617  		{
618  			if (previousFolderName.empty())
619  			{
620  				++nb;
621  				previousFolderName = i._parentFolderName;
622  			}
623  			else 
624  			{
625  				if (i._parentFolderName.empty())
626  				{
627  					++nb;
628  					previousFolderName = i._parentFolderName;
629  				}
630  				else if (previousFolderName == i._parentFolderName)
631  				{
632  				}
633  				else
634  				{
635  					++nb;
636  					previousFolderName = i._parentFolderName;
637  				}
638  			}
639  		}
640  	}
641  	return nb;
642  }
643  bool DynamicMenu::attach(HMENU hMenu, unsigned int posBase, int lastCmd, const generic_string& lastCmdLabel)
644  {
645  	if (!hMenu) return false;
646  	_hMenu = hMenu;
647  	_posBase = posBase;
648  	_lastCmd = lastCmd;
649  	_lastCmdLabel = lastCmdLabel;
650  	return createMenu();
651  }
652  bool DynamicMenu::clearMenu() const
653  {
654  	if (!_hMenu) return false;
655  	int nbTopItem = getTopLevelItemNumber();
656  	for (int i = nbTopItem + 1; i >= 0 ; --i)
657  	{
658  		::DeleteMenu(_hMenu, static_cast<int32_t>(_posBase) + i, MF_BYPOSITION);
659  	}
660  	return true;
661  }
662  bool DynamicMenu::createMenu() const
663  {
664  	if (!_hMenu) return false;
665  	bool lastIsSep = false;
666  	HMENU hParentFolder = NULL;
667  	generic_string currentParentFolderStr;
668  	int j = 0;
669  	size_t nb = _menuItems.size();
670  	size_t i = 0;
671  	for (; i < nb; ++i)
672  	{
673  		const MenuItemUnit& item = _menuItems[i];
674  		if (item._parentFolderName.empty())
675  		{
676  			currentParentFolderStr.clear();
677  			hParentFolder = NULL;
678  			j = 0;
679  		}
680  		else
681  		{
682  			if (item._parentFolderName != currentParentFolderStr)
683  			{
684  				currentParentFolderStr = item._parentFolderName;
685  				hParentFolder = ::CreateMenu();
686  				j = 0;
687  				::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i), MF_BYPOSITION | MF_POPUP, (UINT_PTR)hParentFolder, currentParentFolderStr.c_str());
688  			}
689  		}
690  		unsigned int flag = MF_BYPOSITION | ((item._cmdID == 0) ? MF_SEPARATOR : 0);
691  		if (hParentFolder)
692  		{
693  			::InsertMenu(hParentFolder, j++, flag, item._cmdID, item._itemName.c_str());
694  			lastIsSep = false;
695  		}
696  		else if ((i == 0 || i == _menuItems.size() - 1) && item._cmdID == 0)
697  		{
698  			lastIsSep = true;
699  		}
700  		else if (item._cmdID != 0)
701  		{
702  			::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i), flag, item._cmdID, item._itemName.c_str());
703  			lastIsSep = false;
704  		}
705  		else if (item._cmdID == 0 && !lastIsSep)
706  		{
707  			::InsertMenu(_hMenu, static_cast<int32_t>(_posBase + i), flag, item._cmdID, item._itemName.c_str());
708  			lastIsSep = true;
709  		}
710  		else 
711  		{
712  			lastIsSep = true;
713  		}
714  	}
715  	if (nb > 0)
716  	{
717  		::InsertMenu(_hMenu, static_cast<int32_t>(_posBase + i), MF_BYPOSITION | MF_SEPARATOR, 0, nullptr);
718  		::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i + 2), MF_BYCOMMAND, _lastCmd, _lastCmdLabel.c_str());
719  	}
720  	return true;
721  }
722  winVer NppParameters::getWindowsVersion()
723  {
724  	OSVERSIONINFOEX osvi;
725  	SYSTEM_INFO si;
726  	PGNSI pGNSI;
727  	ZeroMemory(&si, sizeof(SYSTEM_INFO));
728  	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
729  	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
730  	BOOL bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *)&osvi);
731  	if (!bOsVersionInfoEx)
732  	{
733  		osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
734  		if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) )
735  			return WV_UNKNOWN;
736  	}
737  	pGNSI = (PGNSI) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
738  	if (pGNSI != NULL)
739  		pGNSI(&si);
740  	else
741  		GetSystemInfo(&si);
742  	switch (si.wProcessorArchitecture)
743  	{
744  	case PROCESSOR_ARCHITECTURE_IA64:
745  		_platForm = PF_IA64;
746  		break;
747  	case PROCESSOR_ARCHITECTURE_AMD64:
748  		_platForm = PF_X64;
749  		break;
750  	case PROCESSOR_ARCHITECTURE_INTEL:
751  		_platForm = PF_X86;
752  		break;
753  	case PROCESSOR_ARCHITECTURE_ARM64:
754  		_platForm = PF_ARM64;
755  		break;
756  	default:
757  		_platForm = PF_UNKNOWN;
758  	}
759     switch (osvi.dwPlatformId)
760     {
761  		case VER_PLATFORM_WIN32_NT:
762  		{
763  			if (osvi.dwMajorVersion == 10 && osvi.dwMinorVersion == 0 && osvi.dwBuildNumber >= 22000)
764  				return WV_WIN11;
765  			if (osvi.dwMajorVersion == 10 && osvi.dwMinorVersion == 0)
766  				return WV_WIN10;
767  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 3)
768  				return WV_WIN81;
769  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 2)
770  				return WV_WIN8;
771  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 1)
772  				return WV_WIN7;
773  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 0)
774  				return WV_VISTA;
775  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)
776  			{
777  				if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
778  					return WV_XPX64;
779  				return WV_S2003;
780  			}
781  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
782  				return WV_XP;
783  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
784  				return WV_W2K;
785  			if (osvi.dwMajorVersion <= 4)
786  				return WV_NT;
787  			break;
788  		}
789  		case VER_PLATFORM_WIN32_WINDOWS:
790  		{
791  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)
792  				return WV_95;
793  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 10)
794  				return WV_98;
795  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)
796  				return WV_ME;
797  			break;
798  		}
799  		case VER_PLATFORM_WIN32s:
800  			return WV_WIN32S;
801  		default:
802  			return WV_UNKNOWN;
803     }
804     return WV_UNKNOWN;
805  }
806  NppParameters::NppParameters()
807  {
808  	_winVersion = getWindowsVersion();
809  	TCHAR nppPath[MAX_PATH];
810  	::GetModuleFileName(NULL, nppPath, MAX_PATH);
811  	PathRemoveFileSpec(nppPath);
812  	_nppPath = nppPath;
813  	TCHAR curDir[MAX_PATH];
814  	::GetCurrentDirectory(MAX_PATH, curDir);
815  	_currentDirectory = curDir;
816  	_appdataNppDir.clear();
817  	generic_string notepadStylePath(_nppPath);
818  	pathAppend(notepadStylePath, notepadStyleFile);
819  	_asNotepadStyle = (PathFileExists(notepadStylePath.c_str()) == TRUE);
820  	initMenuKeys();
821  	initScintillaKeys();
822  }
823  NppParameters::~NppParameters()
824  {
825  	for (int i = 0 ; i < _nbLang ; ++i)
826  		delete _langList[i];
827  	for (int i = 0 ; i < _nbRecentFile ; ++i)
828  		delete _LRFileList[i];
829  	for (int i = 0 ; i < _nbUserLang ; ++i)
830  		delete _userLangArray[i];
831  	for (std::vector<TiXmlDocument *>::iterator it = _pXmlExternalLexerDoc.begin(), end = _pXmlExternalLexerDoc.end(); it != end; ++it )
832  		delete (*it);
833  	_pXmlExternalLexerDoc.clear();
834  }
835  bool NppParameters::reloadStylers(const TCHAR* stylePath)
836  {
837  	delete _pXmlUserStylerDoc;
838  	const TCHAR* stylePathToLoad = stylePath != nullptr ? stylePath : _stylerPath.c_str();
839  	_pXmlUserStylerDoc = new TiXmlDocument(stylePathToLoad);
840  	bool loadOkay = _pXmlUserStylerDoc->LoadFile();
841  	if (!loadOkay)
842  	{
843  		if (!_pNativeLangSpeaker)
844  		{
845  			::MessageBox(NULL, stylePathToLoad, TEXT("Load stylers.xml failed"), MB_OK);
846  		}
847  		else
848  		{
849  			_pNativeLangSpeaker->messageBox("LoadStylersFailed",
850  				NULL,
851  				TEXT("Load \"$STR_REPLACE$\" failed!"),
852  				TEXT("Load stylers.xml failed"),
853  				MB_OK,
854  				0,
855  				stylePathToLoad);
856  		}
857  		delete _pXmlUserStylerDoc;
858  		_pXmlUserStylerDoc = NULL;
859  		return false;
860  	}
861  	_lexerStylerVect.clear();
862  	_widgetStyleArray.clear();
863  	getUserStylersFromXmlTree();
864  	for ( size_t i = 0; i < getExternalLexerDoc()->size(); ++i)
865  	{
866  		getExternalLexerFromXmlTree( getExternalLexerDoc()->at(i) );
867  	}
868  	return true;
869  }
870  bool NppParameters::reloadLang()
871  {
872  	generic_string nativeLangPath(_localizationSwitcher._nativeLangPath);
873  	if (!PathFileExists(nativeLangPath.c_str()))
874  	{
875  		nativeLangPath = _nppPath;
876  		pathAppend(nativeLangPath, generic_string(TEXT("nativeLang.xml")));
877  		if (!PathFileExists(nativeLangPath.c_str()))
878  			return false;
879  	}
880  	delete _pXmlNativeLangDocA;
881  	_pXmlNativeLangDocA = new TiXmlDocumentA();
882  	bool loadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());
883  	if (!loadOkay)
884  	{
885  		delete _pXmlNativeLangDocA;
886  		_pXmlNativeLangDocA = nullptr;
887  		return false;
888  	}
889  	return loadOkay;
890  }
891  generic_string NppParameters::getSpecialFolderLocation(int folderKind)
892  {
893  	TCHAR path[MAX_PATH];
894  	const HRESULT specialLocationResult = SHGetFolderPath(nullptr, folderKind, nullptr, SHGFP_TYPE_CURRENT, path);
895  	generic_string result;
896  	if (SUCCEEDED(specialLocationResult))
897  	{
898  		result = path;
899  	}
900  	return result;
901  }
902  generic_string NppParameters::getSettingsFolder()
903  {
904  	if (_isLocal)
905  		return _nppPath;
906  	generic_string settingsFolderPath = getSpecialFolderLocation(CSIDL_APPDATA);
907  	if (settingsFolderPath.empty())
908  		return _nppPath;
909  	pathAppend(settingsFolderPath, TEXT("Notepad++"));
910  	return settingsFolderPath;
911  }
912  bool NppParameters::load()
913  {
914  	L_END = L_EXTERNAL;
915  	bool isAllLaoded = true;
916  	_isx64 = sizeof(void *) == 8;
917  	generic_string localConfPath(_nppPath);
918  	pathAppend(localConfPath, localConfFile);
919  	_isLocal = (PathFileExists(localConfPath.c_str()) == TRUE);
920  	if (_isLocal)
921  	{
922  		if (_winVersion >= WV_VISTA)
923  		{
924  			generic_string progPath = getSpecialFolderLocation(CSIDL_PROGRAM_FILES);
925  			TCHAR nppDirLocation[MAX_PATH];
926  			wcscpy_s(nppDirLocation, _nppPath.c_str());
927  			::PathRemoveFileSpec(nppDirLocation);
928  			if  (progPath == nppDirLocation)
929  				_isLocal = false;
930  		}
931  	}
932  	_pluginRootDir = _nppPath;
933  	pathAppend(_pluginRootDir, TEXT("plugins"));
934  	generic_string nppPluginRootParent;
935  	if (_isLocal)
936  	{
937  		_userPath = nppPluginRootParent = _nppPath;
938  		_userPluginConfDir = _pluginRootDir;
939  		pathAppend(_userPluginConfDir, TEXT("Config"));
940  	}
941  	else
942  	{
943  		_userPath = getSpecialFolderLocation(CSIDL_APPDATA);
944  		pathAppend(_userPath, TEXT("Notepad++"));
945  		if (!PathFileExists(_userPath.c_str()))
946  			::CreateDirectory(_userPath.c_str(), NULL);
947  		_appdataNppDir = _userPluginConfDir = _userPath;
948  		pathAppend(_userPluginConfDir, TEXT("plugins"));
949  		if (!PathFileExists(_userPluginConfDir.c_str()))
950  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
951  		pathAppend(_userPluginConfDir, TEXT("Config"));
952  		if (!PathFileExists(_userPluginConfDir.c_str()))
953  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
954  		setElevationRequired(true);
955  	}
956  	_pluginConfDir = _pluginRootDir; 
957  	pathAppend(_pluginConfDir, TEXT("Config"));
958  	if (!PathFileExists(nppPluginRootParent.c_str()))
959  		::CreateDirectory(nppPluginRootParent.c_str(), NULL);
960  	if (!PathFileExists(_pluginRootDir.c_str()))
961  		::CreateDirectory(_pluginRootDir.c_str(), NULL);
962  	_sessionPath = _userPath; 
963  	generic_string cloudChoicePath{_userPath};
964  	cloudChoicePath += TEXT("\\cloud\\choice");
965  	_isCloud = (::PathFileExists(cloudChoicePath.c_str()) == TRUE);
966  	if (_isCloud)
967  	{
968  		std::string cloudChoiceStr = getFileContent(cloudChoicePath.c_str());
969  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
970  		std::wstring cloudChoiceStrW = wmc.char2wchar(cloudChoiceStr.c_str(), SC_CP_UTF8);
971  		if (!cloudChoiceStrW.empty() && ::PathFileExists(cloudChoiceStrW.c_str()))
972  		{
973  			_userPath = cloudChoiceStrW;
974  			_nppGUI._cloudPath = cloudChoiceStrW;
975  			_initialCloudChoice = _nppGUI._cloudPath;
976  		}
977  		else
978  		{
979  			_isCloud = false;
980  		}
981  	}
982  	if (!_cmdSettingsDir.empty())
983  	{
984  		if (!::PathIsDirectory(_cmdSettingsDir.c_str()))
985  		{
986  			generic_string errMsg = TEXT("The given path\r");
987  			errMsg += _cmdSettingsDir;
988  			errMsg += TEXT("\nvia command line \"-settingsDir=\" is not a valid directory.\rThis argument will be ignored.");
989  			::MessageBox(NULL, errMsg.c_str(), TEXT("Invalid directory"), MB_OK);
990  		}
991  		else
992  		{
993  			_userPath = _cmdSettingsDir;
994  			_sessionPath = _userPath; 
995  		}
996  	}
997  	generic_string langs_xml_path(_userPath);
998  	pathAppend(langs_xml_path, TEXT("langs.xml"));
999  	BOOL doRecover = FALSE;
1000  	if (::PathFileExists(langs_xml_path.c_str()))
1001  	{
1002  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
1003  		if (GetFileAttributesEx(langs_xml_path.c_str(), GetFileExInfoStandard, &attributes) != 0)
1004  		{
1005  			if (attributes.nFileSizeLow == 0 && attributes.nFileSizeHigh == 0)
1006  			{
1007  				if (_pNativeLangSpeaker)
1008  				{
1009  					doRecover = _pNativeLangSpeaker->messageBox("LoadLangsFailed",
1010  						NULL,
1011  						TEXT("Load langs.xml failed!\rDo you want to recover your langs.xml?"),
1012  						TEXT("Configurator"),
1013  						MB_YESNO);
1014  				}
1015  				else
1016  				{
1017  					doRecover = ::MessageBox(NULL, TEXT("Load langs.xml failed!\rDo you want to recover your langs.xml?"), TEXT("Configurator"), MB_YESNO);
1018  				}
1019  			}
1020  		}
1021  	}
1022  	else
1023  		doRecover = true;
1024  	if (doRecover)
1025  	{
1026  		generic_string srcLangsPath(_nppPath);
1027  		pathAppend(srcLangsPath, TEXT("langs.model.xml"));
1028  		::CopyFile(srcLangsPath.c_str(), langs_xml_path.c_str(), FALSE);
1029  	}
1030  	_pXmlDoc = new TiXmlDocument(langs_xml_path);
1031  	bool loadOkay = _pXmlDoc->LoadFile();
1032  	if (!loadOkay)
1033  	{
1034  		if (_pNativeLangSpeaker)
1035  		{
1036  			_pNativeLangSpeaker->messageBox("LoadLangsFailedFinal",
1037  				NULL,
1038  				TEXT("Load langs.xml failed!"),
1039  				TEXT("Configurator"),
1040  				MB_OK);
1041  		}
1042  		else
1043  		{
1044  			::MessageBox(NULL, TEXT("Load langs.xml failed!"), TEXT("Configurator"), MB_OK);
1045  		}
1046  		delete _pXmlDoc;
1047  		_pXmlDoc = nullptr;
1048  		isAllLaoded = false;
1049  	}
1050  	else
1051  		getLangKeywordsFromXmlTree();
1052  	generic_string configPath(_userPath);
1053  	pathAppend(configPath, TEXT("config.xml"));
1054  	generic_string srcConfigPath(_nppPath);
1055  	pathAppend(srcConfigPath, TEXT("config.model.xml"));
1056  	if (!::PathFileExists(configPath.c_str()))
1057  		::CopyFile(srcConfigPath.c_str(), configPath.c_str(), FALSE);
1058  	_pXmlUserDoc = new TiXmlDocument(configPath);
1059  	loadOkay = _pXmlUserDoc->LoadFile();
1060  	if (!loadOkay)
1061  	{
1062  		TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
1063  		_pXmlUserDoc->LinkEndChild(decl);
1064  	}
1065  	else
1066  	{
1067  		getUserParametersFromXmlTree();
1068  	}
1069  	_stylerPath = _userPath;
1070  	pathAppend(_stylerPath, TEXT("stylers.xml"));
1071  	if (!PathFileExists(_stylerPath.c_str()))
1072  	{
1073  		generic_string srcStylersPath(_nppPath);
1074  		pathAppend(srcStylersPath, TEXT("stylers.model.xml"));
1075  		::CopyFile(srcStylersPath.c_str(), _stylerPath.c_str(), TRUE);
1076  	}
1077  	if (_nppGUI._themeName.empty() || (!PathFileExists(_nppGUI._themeName.c_str())))
1078  		_nppGUI._themeName.assign(_stylerPath);
1079  	_pXmlUserStylerDoc = new TiXmlDocument(_nppGUI._themeName.c_str());
1080  	loadOkay = _pXmlUserStylerDoc->LoadFile();
1081  	if (!loadOkay)
1082  	{
1083  		if (_pNativeLangSpeaker)
1084  		{
1085  			_pNativeLangSpeaker->messageBox("LoadStylersFailed",
1086  				NULL,
1087  				TEXT("Load \"$STR_REPLACE$\" failed!"),
1088  				TEXT("Load stylers.xml failed"),
1089  				MB_OK,
1090  				0,
1091  				_stylerPath.c_str());
1092  		}
1093  		else
1094  		{
1095  			::MessageBox(NULL, _stylerPath.c_str(), TEXT("Load stylers.xml failed"), MB_OK);
1096  		}
1097  		delete _pXmlUserStylerDoc;
1098  		_pXmlUserStylerDoc = NULL;
1099  		isAllLaoded = false;
1100  	}
1101  	else
1102  		getUserStylersFromXmlTree();
1103  	_themeSwitcher._stylesXmlPath = _stylerPath;
1104  	_themeSwitcher.addDefaultThemeFromXml(_stylerPath);
1105  	_userDefineLangsFolderPath = _userDefineLangPath = _userPath;
1106  	pathAppend(_userDefineLangPath, TEXT("userDefineLang.xml"));
1107  	pathAppend(_userDefineLangsFolderPath, TEXT("userDefineLangs"));
1108  	std::vector<generic_string> udlFiles;
1109  	getFilesInFolder(udlFiles, TEXT("*.xml"), _userDefineLangsFolderPath);
1110  	_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
1111  	loadOkay = _pXmlUserLangDoc->LoadFile();
1112  	if (!loadOkay)
1113  	{
1114  		delete _pXmlUserLangDoc;
1115  		_pXmlUserLangDoc = nullptr;
1116  		isAllLaoded = false;
1117  	}
1118  	else
1119  	{
1120  		auto r = addUserDefineLangsFromXmlTree(_pXmlUserLangDoc);
1121  		if (r.second - r.first > 0)
1122  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(_pXmlUserLangDoc, false, true, r));
1123  	}
1124  	for (const auto& i : udlFiles)
1125  	{
1126  		auto udlDoc = new TiXmlDocument(i);
1127  		loadOkay = udlDoc->LoadFile();
1128  		if (!loadOkay)
1129  		{
1130  			delete udlDoc;
1131  		}
1132  		else
1133  		{
1134  			auto r = addUserDefineLangsFromXmlTree(udlDoc);
1135  			if (r.second - r.first > 0)
1136  				_pXmlUserLangsDoc.push_back(UdlXmlFileState(udlDoc, false, false, r));
1137  		}
1138  	}
1139  	generic_string nativeLangPath;
1140  	nativeLangPath = _userPath;
1141  	pathAppend(nativeLangPath, TEXT("nativeLang.xml"));
1142  	_localizationSwitcher._nativeLangPath = nativeLangPath;
1143  	if (!_startWithLocFileName.empty()) 
1144  	{
1145  		nativeLangPath = _nppPath;
1146  		pathAppend(nativeLangPath, TEXT("localization\\"));
1147  		pathAppend(nativeLangPath, _startWithLocFileName);
1148  	}
1149  	else 
1150  	{
1151  		if (!PathFileExists(nativeLangPath.c_str()))
1152  		{
1153  			nativeLangPath = _nppPath;
1154  			pathAppend(nativeLangPath, TEXT("nativeLang.xml"));
1155  		}
1156  	}
1157  	_pXmlNativeLangDocA = new TiXmlDocumentA();
1158  	loadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());
1159  	if (!loadOkay)
1160  	{
1161  		delete _pXmlNativeLangDocA;
1162  		_pXmlNativeLangDocA = nullptr;
1163  		isAllLaoded = false;
1164  	}
1165  	generic_string toolbarIconsPath(_userPath);
1166  	pathAppend(toolbarIconsPath, TEXT("toolbarIcons.xml"));
1167  	_pXmlToolIconsDoc = new TiXmlDocument(toolbarIconsPath);
1168  	loadOkay = _pXmlToolIconsDoc->LoadFile();
1169  	if (!loadOkay)
1170  	{
1171  		delete _pXmlToolIconsDoc;
1172  		_pXmlToolIconsDoc = nullptr;
1173  		isAllLaoded = false;
1174  	}
1175  	wstring v852NoNeedShortcutsBackup;
1176  	_shortcutsPath = v852NoNeedShortcutsBackup = _userPath;
1177  	pathAppend(_shortcutsPath, SHORTCUTSXML_FILENAME);
1178  	pathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
1179  	if (!PathFileExists(_shortcutsPath.c_str()))
1180  	{
1181  		generic_string srcShortcutsPath(_nppPath);
1182  		pathAppend(srcShortcutsPath, SHORTCUTSXML_FILENAME);
1183  		::CopyFile(srcShortcutsPath.c_str(), _shortcutsPath.c_str(), TRUE);
1184  		HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
1185  		::FlushFileBuffers(hFile);
1186  		::CloseHandle(hFile);
1187  	}
1188  	_pXmlShortcutDocA = new TiXmlDocumentA();
1189  	loadOkay = _pXmlShortcutDocA->LoadUnicodeFilePath(_shortcutsPath.c_str());
1190  	if (!loadOkay)
1191  	{
1192  		delete _pXmlShortcutDocA;
1193  		_pXmlShortcutDocA = nullptr;
1194  		isAllLaoded = false;
1195  	}
1196  	else
1197  	{
1198  		getShortcutsFromXmlTree();
1199  		getMacrosFromXmlTree();
1200  		getUserCmdsFromXmlTree();
1201  		getScintKeysFromXmlTree();
1202  	}
1203  	_contextMenuPath = _userPath;
1204  	pathAppend(_contextMenuPath, TEXT("contextMenu.xml"));
1205  	if (!PathFileExists(_contextMenuPath.c_str()))
1206  	{
1207  		generic_string srcContextMenuPath(_nppPath);
1208  		pathAppend(srcContextMenuPath, TEXT("contextMenu.xml"));
1209  		::CopyFile(srcContextMenuPath.c_str(), _contextMenuPath.c_str(), TRUE);
1210  	}
1211  	_pXmlContextMenuDocA = new TiXmlDocumentA();
1212  	loadOkay = _pXmlContextMenuDocA->LoadUnicodeFilePath(_contextMenuPath.c_str());
1213  	if (!loadOkay)
1214  	{
1215  		delete _pXmlContextMenuDocA;
1216  		_pXmlContextMenuDocA = nullptr;
1217  		isAllLaoded = false;
1218  	}
1219  	_tabContextMenuPath = _userPath;
1220  	pathAppend(_tabContextMenuPath, TEXT("tabContextMenu.xml"));
1221  	_pXmlTabContextMenuDocA = new TiXmlDocumentA();
1222  	loadOkay = _pXmlTabContextMenuDocA->LoadUnicodeFilePath(_tabContextMenuPath.c_str());
1223  	if (!loadOkay)
1224  	{
1225  		delete _pXmlTabContextMenuDocA;
1226  		_pXmlTabContextMenuDocA = nullptr;
1227  	}
1228  	pathAppend(_sessionPath, TEXT("session.xml"));
1229  	const NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
1230  	if (nppGUI._rememberLastSession)
1231  	{
1232  		TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(_sessionPath);
1233  		loadOkay = pXmlSessionDoc->LoadFile();
1234  		if (!loadOkay)
1235  			isAllLaoded = false;
1236  		else
1237  			getSessionFromXmlTree(pXmlSessionDoc, _session);
1238  		delete pXmlSessionDoc;
1239  		for (size_t i = 0, len = _pXmlExternalLexerDoc.size() ; i < len ; ++i)
1240  			if (_pXmlExternalLexerDoc[i])
1241  				delete _pXmlExternalLexerDoc[i];
1242  	}
1243  	generic_string enableSelectFgColorPath = _userPath;
1244  	pathAppend(enableSelectFgColorPath, TEXT("enableSelectFgColor.xml"));
1245  	if (PathFileExists(enableSelectFgColorPath.c_str()))
1246  	{
1247  		_isSelectFgColorEnabled = true;
1248  	}
1249  	generic_string filePath, filePath2, issueFileName;
1250  	filePath = _nppPath;
1251  	issueFileName = nppLogNetworkDriveIssue;
1252  	issueFileName += TEXT(".xml");
1253  	pathAppend(filePath, issueFileName);
1254  	_doNppLogNetworkDriveIssue = (PathFileExists(filePath.c_str()) == TRUE);
1255  	if (!_doNppLogNetworkDriveIssue)
1256  	{
1257  		filePath2 = _userPath;
1258  		pathAppend(filePath2, issueFileName);
1259  		_doNppLogNetworkDriveIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1260  	}
1261  	filePath = _nppPath;
1262  	issueFileName = nppLogNulContentCorruptionIssue;
1263  	issueFileName += TEXT(".xml");
1264  	pathAppend(filePath, issueFileName);
1265  	_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath.c_str()) == TRUE);
1266  	if (!_doNppLogNulContentCorruptionIssue)
1267  	{
1268  		filePath2 = _userPath;
1269  		pathAppend(filePath2, issueFileName);
1270  		_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1271  	}
1272  	return isAllLaoded;
1273  }
1274  void NppParameters::destroyInstance()
1275  {
1276  	delete _pXmlDoc;
1277  	delete _pXmlUserDoc;
1278  	delete _pXmlUserStylerDoc;
1279  	for (auto& l : _pXmlUserLangsDoc)
1280  	{
1281  		delete l._udlXmlDoc;
1282  	}
1283  	delete _pXmlNativeLangDocA;
1284  	delete _pXmlToolIconsDoc;
1285  	delete _pXmlShortcutDocA;
1286  	delete _pXmlContextMenuDocA;
1287  	delete _pXmlTabContextMenuDocA;
1288  	delete 	getInstancePointer();
1289  }
1290  void NppParameters::saveConfig_xml()
1291  {
1292  	if (_pXmlUserDoc)
1293  		_pXmlUserDoc->SaveFile();
1294  }
1295  void NppParameters::setWorkSpaceFilePath(int i, const TCHAR* wsFile)
1296  {
1297  	if (i < 0 || i > 2 || !wsFile)
1298  		return;
1299  	_workSpaceFilePathes[i] = wsFile;
1300  }
1301  void NppParameters::removeTransparent(HWND hwnd)
1302  {
1303  	if (hwnd != nullptr)
1304  		::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) & ~WS_EX_LAYERED);
1305  }
1306  void NppParameters::SetTransparent(HWND hwnd, int percent)
1307  {
1308  	::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);
1309  	if (percent > 255)
1310  		percent = 255;
1311  	else if (percent < 0)
1312  		percent = 0;
1313  	::SetLayeredWindowAttributes(hwnd, 0, static_cast<BYTE>(percent), LWA_ALPHA);
1314  }
1315  bool NppParameters::isExistingExternalLangName(const char* newName) const
1316  {
1317  	if ((!newName) || (!newName[0]))
1318  		return true;
1319  	for (int i = 0 ; i < _nbExternalLang ; ++i)
1320  	{
1321  		if (_externalLangArray[i]->_name == newName)
1322  			return true;
1323  	}
1324  	return false;
1325  }
1326  const TCHAR* NppParameters::getUserDefinedLangNameFromExt(TCHAR *ext, TCHAR *fullName) const
1327  {
1328  	if ((!ext) || (!ext[0]))
1329  		return nullptr;
1330  	std::vector<generic_string> extVect;
1331  	int iMatched = -1;
1332  	for (int i = 0 ; i < _nbUserLang ; ++i)
1333  	{
1334  		extVect.clear();
1335  		cutString(_userLangArray[i]->_ext.c_str(), extVect);
1336  		for (size_t j = 0, len = extVect.size(); j < len; ++j)
1337  		{
1338  			if (!wcsicmp(extVect[j].c_str(), ext) || (wcschr(fullName, '.') && !wcsicmp(extVect[j].c_str(), fullName)))
1339  			{
1340  				iMatched = i;
1341  				if (((NppDarkMode::isEnabled() && _userLangArray[i]->_isDarkModeTheme)) ||
1342  					((!NppDarkMode::isEnabled() && !_userLangArray[i]->_isDarkModeTheme)))
1343  					return _userLangArray[i]->_name.c_str();
1344  			}
1345  		}
1346  	}
1347  	if (iMatched >= 0)
1348  	{
1349  		return _userLangArray[iMatched]->_name.c_str();
1350  	}
1351  	return nullptr;
1352  }
1353  int NppParameters::getExternalLangIndexFromName(const TCHAR* externalLangName) const
1354  {
1355  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1356  	for (int i = 0 ; i < _nbExternalLang ; ++i)
1357  	{
1358  		if (!lstrcmp(externalLangName, wmc.char2wchar(_externalLangArray[i]->_name.c_str(), CP_ACP)))
1359  			return i;
1360  	}
1361  	return -1;
1362  }
1363  UserLangContainer* NppParameters::getULCFromName(const TCHAR *userLangName)
1364  {
1365  	for (int i = 0 ; i < _nbUserLang ; ++i)
1366  	{
1367  		if (0 == lstrcmp(userLangName, _userLangArray[i]->_name.c_str()))
1368  			return _userLangArray[i];
1369  	}
1370  	return nullptr;
1371  }
1372  COLORREF NppParameters::getCurLineHilitingColour()
1373  {
1374  	const Style * pStyle = _widgetStyleArray.findByName(TEXT("Current line background colour"));
1375  	if (!pStyle)
1376  		return COLORREF(-1);
1377  	return pStyle->_bgColor;
1378  }
1379  void NppParameters::setCurLineHilitingColour(COLORREF colour2Set)
1380  {
1381  	Style * pStyle = _widgetStyleArray.findByName(TEXT("Current line background colour"));
1382  	if (!pStyle)
1383  		return;
1384  	pStyle->_bgColor = colour2Set;
1385  }
1386  static int CALLBACK EnumFontFamExProc(const LOGFONT* lpelfe, const TEXTMETRIC*, DWORD, LPARAM lParam)
1387  {
1388  	std::vector<generic_string>& strVect = *(std::vector<generic_string> *)lParam;
1389  	const int32_t vectSize = static_cast<int32_t>(strVect.size());
1390  	const TCHAR* lfFaceName = ((ENUMLOGFONTEX*)lpelfe)->elfLogFont.lfFaceName;
1391  	for (int i = vectSize - 1 ; i >= 0 ; i--)
1392  	{
1393  		if (0 == lstrcmp(strVect[i].c_str(), lfFaceName))
1394  			return 1;	
1395  	}
1396  	strVect.push_back(lfFaceName);
1397  	return 1; 
1398  }
1399  void NppParameters::setFontList(HWND hWnd)
1400  {
1401  	LOGFONT lf{};
1402  	_fontlist.clear();
1403  	_fontlist.reserve(64); 
1404  	_fontlist.push_back(generic_string());
1405  	lf.lfCharSet = DEFAULT_CHARSET;
1406  	lf.lfFaceName[0]='\0';
1407  	lf.lfPitchAndFamily = 0;
1408  	HDC hDC = ::GetDC(hWnd);
1409  	::EnumFontFamiliesEx(hDC, &lf, EnumFontFamExProc, reinterpret_cast<LPARAM>(&_fontlist), 0);
1410  }
1411  bool NppParameters::isInFontList(const generic_string& fontName2Search) const
1412  {
1413  	if (fontName2Search.empty())
1414  		return false;
1415  	for (size_t i = 0, len = _fontlist.size(); i < len; i++)
1416  	{
1417  		if (_fontlist[i] == fontName2Search)
1418  			return true;
1419  	}
1420  	return false;
1421  }
1422  LOGFONT NppParameters::getDefaultGUIFont(DefaultFontType type)
1423  {
1424  	LOGFONT lf{};
1425  	NONCLIENTMETRICS ncm{};
1426  	ncm.cbSize = sizeof(NONCLIENTMETRICS);
1427  	if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
1428  	{
1429  		switch (type)
1430  		{
1431  			case DefaultFontType::menu:
1432  			{
1433  				lf = ncm.lfMenuFont;
1434  				break;
1435  			}
1436  			case DefaultFontType::status:
1437  			{
1438  				lf = ncm.lfStatusFont;
1439  				break;
1440  			}
1441  			case DefaultFontType::caption:
1442  			{
1443  				lf = ncm.lfCaptionFont;
1444  				break;
1445  			}
1446  			case DefaultFontType::smcaption:
1447  			{
1448  				lf = ncm.lfSmCaptionFont;
1449  				break;
1450  			}
1451  			default:
1452  			{
1453  				lf = ncm.lfMessageFont;
1454  				break;
1455  			}
1456  		}
1457  	}
1458  	else 
1459  	{
1460  		auto hf = static_cast<HFONT>(::GetStockObject(DEFAULT_GUI_FONT));
1461  		::GetObject(hf, sizeof(LOGFONT), &lf);
1462  	}
1463  	return lf;
1464  }
1465  void NppParameters::getLangKeywordsFromXmlTree()
1466  {
1467  	TiXmlNode *root =
1468  		_pXmlDoc->FirstChild(TEXT("NotepadPlus"));
1469  		if (!root) return;
1470  	feedKeyWordsParameters(root);
1471  }
1472  void NppParameters::getExternalLexerFromXmlTree(TiXmlDocument* externalLexerDoc)
1473  {
1474  	TiXmlNode *root = externalLexerDoc->FirstChild(TEXT("NotepadPlus"));
1475  		if (!root) return;
1476  	feedKeyWordsParameters(root);
1477  	feedStylerArray(root);
1478  }
1479  int NppParameters::addExternalLangToEnd(ExternalLangContainer * externalLang)
1480  {
1481  	_externalLangArray[_nbExternalLang] = externalLang;
1482  	++_nbExternalLang;
1483  	++L_END;
1484  	return _nbExternalLang-1;
1485  }
1486  bool NppParameters::getUserStylersFromXmlTree()
1487  {
1488  	TiXmlNode *root = _pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus"));
1489  		if (!root) return false;
1490  	return feedStylerArray(root);
1491  }
1492  bool NppParameters::getUserParametersFromXmlTree()
1493  {
1494  	if (!_pXmlUserDoc)
1495  		return false;
1496  	TiXmlNode *root = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
1497  	if (!root)
1498  		return false;
1499  	feedGUIParameters(root);
1500  	feedFileListParameters(root);
1501  	TiXmlNode *node = root->FirstChildElement(TEXT("History"));
1502  	root->RemoveChild(node);
1503  	TiXmlElement HistoryNode(TEXT("History"));
1504  	root->InsertEndChild(HistoryNode);
1505  	feedFindHistoryParameters(root);
1506  	feedProjectPanelsParameters(root);
1507  	feedFileBrowserParameters(root);
1508  	feedColumnEditorParameters(root);
1509  	return true;
1510  }
1511  std::pair<unsigned char, unsigned char> NppParameters::addUserDefineLangsFromXmlTree(TiXmlDocument *tixmldoc)
1512  {
1513  	if (!tixmldoc)
1514  		return std::make_pair(static_cast<unsigned char>(0), static_cast<unsigned char>(0));
1515  	TiXmlNode *root = tixmldoc->FirstChild(TEXT("NotepadPlus"));
1516  	if (!root)
1517  		return std::make_pair(static_cast<unsigned char>(0), static_cast<unsigned char>(0));
1518  	return feedUserLang(root);
1519  }
1520  bool NppParameters::getShortcutsFromXmlTree()
1521  {
1522  	if (!_pXmlShortcutDocA)
1523  		return false;
1524  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1525  	if (!root)
1526  		return false;
1527  	feedShortcut(root);
1528  	return true;
1529  }
1530  bool NppParameters::getMacrosFromXmlTree()
1531  {
1532  	if (!_pXmlShortcutDocA)
1533  		return false;
1534  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1535  	if (!root)
1536  		return false;
1537  	feedMacros(root);
1538  	return true;
1539  }
1540  bool NppParameters::getUserCmdsFromXmlTree()
1541  {
1542  	if (!_pXmlShortcutDocA)
1543  		return false;
1544  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1545  	if (!root)
1546  		return false;
1547  	feedUserCmds(root);
1548  	return true;
1549  }
1550  bool NppParameters::getPluginCmdsFromXmlTree()
1551  {
1552  	if (!_pXmlShortcutDocA)
1553  		return false;
1554  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1555  	if (!root)
1556  		return false;
1557  	feedPluginCustomizedCmds(root);
1558  	return true;
1559  }
1560  bool NppParameters::getScintKeysFromXmlTree()
1561  {
1562  	if (!_pXmlShortcutDocA)
1563  		return false;
1564  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1565  	if (!root)
1566  		return false;
1567  	feedScintKeys(root);
1568  	return true;
1569  }
1570  void NppParameters::initMenuKeys()
1571  {
1572  	int nbCommands = sizeof(winKeyDefs)/sizeof(WinMenuKeyDefinition);
1573  	WinMenuKeyDefinition wkd;
1574  	for (int i = 0; i < nbCommands; ++i)
1575  	{
1576  		wkd = winKeyDefs[i];
1577  		Shortcut sc((wkd.specialName ? wstring2string(wkd.specialName, CP_UTF8).c_str() : ""), wkd.isCtrl, wkd.isAlt, wkd.isShift, static_cast<unsigned char>(wkd.vKey));
1578  		_shortcuts.push_back( CommandShortcut(sc, wkd.functionId) );
1579  	}
1580  }
1581  void NppParameters::initScintillaKeys()
1582  {
1583  	int nbCommands = sizeof(scintKeyDefs)/sizeof(ScintillaKeyDefinition);
1584  	ScintillaKeyDefinition skd;
1585  	int prevIndex = -1;
1586  	int prevID = -1;
1587  	for (int i = 0; i < nbCommands; ++i)
1588  	{
1589  		skd = scintKeyDefs[i];
1590  		if (skd.functionId == prevID)
1591  		{
1592  			KeyCombo kc;
1593  			kc._isCtrl = skd.isCtrl;
1594  			kc._isAlt = skd.isAlt;
1595  			kc._isShift = skd.isShift;
1596  			kc._key = static_cast<unsigned char>(skd.vKey);
1597  			_scintillaKeyCommands[prevIndex].addKeyCombo(kc);
1598  		}
1599  		else
1600  		{
1601  			Shortcut s = Shortcut(wstring2string(skd.name, CP_UTF8).c_str(), skd.isCtrl, skd.isAlt, skd.isShift, static_cast<unsigned char>(skd.vKey));
1602  			ScintillaKeyMap sm = ScintillaKeyMap(s, skd.functionId, skd.redirFunctionId);
1603  			_scintillaKeyCommands.push_back(sm);
1604  			++prevIndex;
1605  		}
1606  		prevID = skd.functionId;
1607  	}
1608  }
1609  bool NppParameters::reloadContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu)
1610  {
1611  	_contextMenuItems.clear();
1612  	return getContextMenuFromXmlTree(mainMenuHadle, pluginsMenu);
1613  }
1614  int NppParameters::getCmdIdFromMenuEntryItemName(HMENU mainMenuHadle, const generic_string& menuEntryName, const generic_string& menuItemName)
1615  {
1616  	int nbMenuEntry = ::GetMenuItemCount(mainMenuHadle);
1617  	for (int i = 0; i < nbMenuEntry; ++i)
1618  	{
1619  		TCHAR menuEntryString[menuItemStrLenMax];
1620  		::GetMenuString(mainMenuHadle, i, menuEntryString, menuItemStrLenMax, MF_BYPOSITION);
1621  		if (wcsicmp(menuEntryName.c_str(), purgeMenuItemString(menuEntryString).c_str()) == 0)
1622  		{
1623  			vector< pair<HMENU, int> > parentMenuPos;
1624  			HMENU topMenu = ::GetSubMenu(mainMenuHadle, i);
1625  			int maxTopMenuPos = ::GetMenuItemCount(topMenu);
1626  			HMENU currMenu = topMenu;
1627  			int currMaxMenuPos = maxTopMenuPos;
1628  			int currMenuPos = 0;
1629  			bool notFound = false;
1630  			do {
1631  				if (::GetSubMenu(currMenu, currMenuPos))
1632  				{
1633  					parentMenuPos.push_back(::make_pair(currMenu, currMenuPos));
1634  					currMenu = ::GetSubMenu(currMenu, currMenuPos);
1635  					currMenuPos = 0;
1636  					currMaxMenuPos = ::GetMenuItemCount(currMenu);
1637  				}
1638  				else
1639  				{
1640  					TCHAR cmdStr[menuItemStrLenMax];
1641  					::GetMenuString(currMenu, currMenuPos, cmdStr, menuItemStrLenMax, MF_BYPOSITION);
1642  					if (wcsicmp(menuItemName.c_str(), purgeMenuItemString(cmdStr).c_str()) == 0)
1643  					{
1644  						return ::GetMenuItemID(currMenu, currMenuPos);
1645  					}
1646  					if ((currMenuPos >= currMaxMenuPos) && (parentMenuPos.size() > 0))
1647  					{
1648  						currMenu = parentMenuPos.back().first;
1649  						currMenuPos = parentMenuPos.back().second;
1650  						parentMenuPos.pop_back();
1651  						currMaxMenuPos = ::GetMenuItemCount(currMenu);
1652  					}
1653  					if ((currMenu == topMenu) && (currMenuPos >= maxTopMenuPos))
1654  					{
1655  						notFound = true;
1656  					}
1657  					else
1658  					{
1659  						++currMenuPos;
1660  					}
1661  				}
1662  			} while (!notFound);
1663  		}
1664  	}
1665  	return -1;
1666  }
1667  int NppParameters::getPluginCmdIdFromMenuEntryItemName(HMENU pluginsMenu, const generic_string& pluginName, const generic_string& pluginCmdName)
1668  {
1669  	int nbPlugins = ::GetMenuItemCount(pluginsMenu);
1670  	for (int i = 0; i < nbPlugins; ++i)
1671  	{
1672  		TCHAR menuItemString[menuItemStrLenMax];
1673  		::GetMenuString(pluginsMenu, i, menuItemString, menuItemStrLenMax, MF_BYPOSITION);
1674  		if (wcsicmp(pluginName.c_str(), purgeMenuItemString(menuItemString).c_str()) == 0)
1675  		{
1676  			HMENU pluginMenu = ::GetSubMenu(pluginsMenu, i);
1677  			int nbPluginCmd = ::GetMenuItemCount(pluginMenu);
1678  			for (int j = 0; j < nbPluginCmd; ++j)
1679  			{
1680  				TCHAR pluginCmdStr[menuItemStrLenMax];
1681  				::GetMenuString(pluginMenu, j, pluginCmdStr, menuItemStrLenMax, MF_BYPOSITION);
1682  				if (wcsicmp(pluginCmdName.c_str(), purgeMenuItemString(pluginCmdStr).c_str()) == 0)
1683  				{
1684  					return ::GetMenuItemID(pluginMenu, j);
1685  				}
1686  			}
1687  		}
1688  	}
1689  	return -1;
1690  }
1691  bool NppParameters::getContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu, bool isEditCM)
1692  {
1693  	std::vector<MenuItemUnit>& contextMenuItems = isEditCM ? _contextMenuItems : _tabContextMenuItems;
1694  	TiXmlDocumentA* pXmlContextMenuDocA = isEditCM ? _pXmlContextMenuDocA : _pXmlTabContextMenuDocA;
1695  	std::string cmName = isEditCM ? "ScintillaContextMenu" : "TabContextMenu";
1696  	if (!pXmlContextMenuDocA)
1697  		return false;
1698  	TiXmlNodeA *root = pXmlContextMenuDocA->FirstChild("NotepadPlus");
1699  	if (!root)
1700  		return false;
1701  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1702  	NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
1703  	TiXmlNodeA *contextMenuRoot = root->FirstChildElement(cmName.c_str());
1704  	if (contextMenuRoot)
1705  	{
1706  		for (TiXmlNodeA *childNode = contextMenuRoot->FirstChildElement("Item");
1707  			childNode ;
1708  			childNode = childNode->NextSibling("Item") )
1709  		{
1710  			const char *folderNameDefaultA = (childNode->ToElement())->Attribute("FolderName");
1711  			const char *folderNameTranslateID_A = (childNode->ToElement())->Attribute("TranslateID");
1712  			const char *displayAsA = (childNode->ToElement())->Attribute("ItemNameAs");
1713  			generic_string folderName;
1714  			generic_string displayAs;
1715  			folderName = folderNameDefaultA ? wmc.char2wchar(folderNameDefaultA, SC_CP_UTF8) : TEXT("");
1716  			displayAs = displayAsA ? wmc.char2wchar(displayAsA, SC_CP_UTF8) : TEXT("");
1717  			if (folderNameTranslateID_A)
1718  			{
1719  				folderName = pNativeSpeaker->getLocalizedStrFromID(folderNameTranslateID_A, folderName);
1720  			}
1721  			int id;
1722  			const char *idStr = (childNode->ToElement())->Attribute("id", &id);
1723  			if (idStr)
1724  			{
1725  				contextMenuItems.push_back(MenuItemUnit(id, displayAs.c_str(), folderName.c_str()));
1726  			}
1727  			else
1728  			{
1729  				const char *menuEntryNameA = (childNode->ToElement())->Attribute("MenuEntryName");
1730  				const char *menuItemNameA = (childNode->ToElement())->Attribute("MenuItemName");
1731  				generic_string menuEntryName;
1732  				generic_string menuItemName;
1733  				menuEntryName = menuEntryNameA?wmc.char2wchar(menuEntryNameA, SC_CP_UTF8):TEXT("");
1734  				menuItemName = menuItemNameA?wmc.char2wchar(menuItemNameA, SC_CP_UTF8):TEXT("");
1735  				if (!menuEntryName.empty() && !menuItemName.empty())
1736  				{
1737  					int cmd = getCmdIdFromMenuEntryItemName(mainMenuHadle, menuEntryName, menuItemName);
1738  					if (cmd != -1)
1739  						contextMenuItems.push_back(MenuItemUnit(cmd, displayAs.c_str(), folderName.c_str()));
1740  				}
1741  				else
1742  				{
1743  					const char *pluginNameA = (childNode->ToElement())->Attribute("PluginEntryName");
1744  					const char *pluginCmdNameA = (childNode->ToElement())->Attribute("PluginCommandItemName");
1745  					generic_string pluginName;
1746  					generic_string pluginCmdName;
1747  					pluginName = pluginNameA?wmc.char2wchar(pluginNameA, SC_CP_UTF8):TEXT("");
1748  					pluginCmdName = pluginCmdNameA?wmc.char2wchar(pluginCmdNameA, SC_CP_UTF8):TEXT("");
1749  					if (pluginsMenu && !pluginName.empty() && !pluginCmdName.empty())
1750  					{
1751  						int pluginCmdId = getPluginCmdIdFromMenuEntryItemName(pluginsMenu, pluginName, pluginCmdName);
1752  						if (pluginCmdId != -1)
1753  							contextMenuItems.push_back(MenuItemUnit(pluginCmdId, displayAs.c_str(), folderName.c_str()));
1754  					}
1755  				}
1756  			}
1757  		}
1758  	}
1759  	return true;
1760  }
1761  void NppParameters::setWorkingDir(const TCHAR * newPath)
1762  {
1763  	if (newPath && newPath[0])
1764  	{
1765  		_currentDirectory = newPath;
1766  	}
1767  	else
1768  	{
1769  		if (PathFileExists(_nppGUI._defaultDirExp))
1770  			_currentDirectory = _nppGUI._defaultDirExp;
1771  		else
1772  			_currentDirectory = _nppPath.c_str();
1773  	}
1774  }
1775  bool NppParameters::loadSession(Session & session, const TCHAR *sessionFileName)
1776  {
1777  	TiXmlDocument *pXmlSessionDocument = new TiXmlDocument(sessionFileName);
1778  	bool loadOkay = pXmlSessionDocument->LoadFile();
1779  	if (loadOkay)
1780  		loadOkay = getSessionFromXmlTree(pXmlSessionDocument, session);
1781  	delete pXmlSessionDocument;
1782  	return loadOkay;
1783  }
1784  bool NppParameters::getSessionFromXmlTree(TiXmlDocument *pSessionDoc, Session& session)
1785  {
1786  	if (!pSessionDoc)
1787  		return false;
1788  	TiXmlNode *root = pSessionDoc->FirstChild(TEXT("NotepadPlus"));
1789  	if (!root)
1790  		return false;
1791  	TiXmlNode *sessionRoot = root->FirstChildElement(TEXT("Session"));
1792  	if (!sessionRoot)
1793  		return false;
1794  	TiXmlElement *actView = sessionRoot->ToElement();
1795  	int index = 0;
1796  	const TCHAR *str = actView->Attribute(TEXT("activeView"), &index);
1797  	if (str)
1798  	{
1799  		session._activeView = index;
1800  	}
1801  	const size_t nbView = 2;
1802  	TiXmlNode *viewRoots[nbView];
1803  	viewRoots[0] = sessionRoot->FirstChildElement(TEXT("mainView"));
1804  	viewRoots[1] = sessionRoot->FirstChildElement(TEXT("subView"));
1805  	for (size_t k = 0; k < nbView; ++k)
1806  	{
1807  		if (viewRoots[k])
1808  		{
1809  			int index2 = 0;
1810  			TiXmlElement *actIndex = viewRoots[k]->ToElement();
1811  			str = actIndex->Attribute(TEXT("activeIndex"), &index2);
1812  			if (str)
1813  			{
1814  				if (k == 0)
1815  					session._activeMainIndex = index2;
1816  				else 
1817  					session._activeSubIndex = index2;
1818  			}
1819  			for (TiXmlNode *childNode = viewRoots[k]->FirstChildElement(TEXT("File"));
1820  				childNode ;
1821  				childNode = childNode->NextSibling(TEXT("File")) )
1822  			{
1823  				const TCHAR *fileName = (childNode->ToElement())->Attribute(TEXT("filename"));
1824  				if (fileName)
1825  				{
1826  					Position position;
1827  					const TCHAR* posStr = (childNode->ToElement())->Attribute(TEXT("firstVisibleLine"));
1828  					if (posStr)
1829  						position._firstVisibleLine = static_cast<intptr_t>(_ttoi64(posStr));
1830  					posStr = (childNode->ToElement())->Attribute(TEXT("xOffset"));
1831  					if (posStr)
1832  						position._xOffset = static_cast<intptr_t>(_ttoi64(posStr));
1833  					posStr = (childNode->ToElement())->Attribute(TEXT("startPos"));
1834  					if (posStr)
1835  						position._startPos = static_cast<intptr_t>(_ttoi64(posStr));
1836  					posStr = (childNode->ToElement())->Attribute(TEXT("endPos"));
1837  					if (posStr)
1838  						position._endPos = static_cast<intptr_t>(_ttoi64(posStr));
1839  					posStr = (childNode->ToElement())->Attribute(TEXT("selMode"));
1840  					if (posStr)
1841  						position._selMode = static_cast<intptr_t>(_ttoi64(posStr));
1842  					posStr = (childNode->ToElement())->Attribute(TEXT("scrollWidth"));
1843  					if (posStr)
1844  						position._scrollWidth = static_cast<intptr_t>(_ttoi64(posStr));
1845  					posStr = (childNode->ToElement())->Attribute(TEXT("offset"));
1846  					if (posStr)
1847  						position._offset = static_cast<intptr_t>(_ttoi64(posStr));
1848  					posStr = (childNode->ToElement())->Attribute(TEXT("wrapCount"));
1849  					if (posStr)
1850  						position._wrapCount = static_cast<intptr_t>(_ttoi64(posStr));
1851  					MapPosition mapPosition;
1852  					const TCHAR* mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapFirstVisibleDisplayLine"));
1853  					if (mapPosStr)
1854  						mapPosition._firstVisibleDisplayLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1855  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapFirstVisibleDocLine"));
1856  					if (mapPosStr)
1857  						mapPosition._firstVisibleDocLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1858  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapLastVisibleDocLine"));
1859  					if (mapPosStr)
1860  						mapPosition._lastVisibleDocLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1861  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapNbLine"));
1862  					if (mapPosStr)
1863  						mapPosition._nbLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1864  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapHigherPos"));
1865  					if (mapPosStr)
1866  						mapPosition._higherPos = static_cast<intptr_t>(_ttoi64(mapPosStr));
1867  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapWidth"));
1868  					if (mapPosStr)
1869  						mapPosition._width = static_cast<intptr_t>(_ttoi64(mapPosStr));
1870  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapHeight"));
1871  					if (mapPosStr)
1872  						mapPosition._height = static_cast<intptr_t>(_ttoi64(mapPosStr));
1873  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapKByteInDoc"));
1874  					if (mapPosStr)
1875  						mapPosition._KByteInDoc = static_cast<intptr_t>(_ttoi64(mapPosStr));
1876  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapWrapIndentMode"));
1877  					if (mapPosStr)
1878  						mapPosition._wrapIndentMode = static_cast<intptr_t>(_ttoi64(mapPosStr));
1879  					const TCHAR *boolStr = (childNode->ToElement())->Attribute(TEXT("mapIsWrap"));
1880  					if (boolStr)
1881  						mapPosition._isWrap = (lstrcmp(TEXT("yes"), boolStr) == 0);
1882  					const TCHAR *langName;
1883  					langName = (childNode->ToElement())->Attribute(TEXT("lang"));
1884  					int encoding = -1;
1885  					const TCHAR *encStr = (childNode->ToElement())->Attribute(TEXT("encoding"), &encoding);
1886  					const TCHAR *backupFilePath = (childNode->ToElement())->Attribute(TEXT("backupFilePath"));
1887  					FILETIME fileModifiedTimestamp{};
1888  					(childNode->ToElement())->Attribute(TEXT("originalFileLastModifTimestamp"), reinterpret_cast<int32_t*>(&fileModifiedTimestamp.dwLowDateTime));
1889  					(childNode->ToElement())->Attribute(TEXT("originalFileLastModifTimestampHigh"), reinterpret_cast<int32_t*>(&fileModifiedTimestamp.dwHighDateTime));
1890  					bool isUserReadOnly = false;
1891  					const TCHAR *boolStrReadOnly = (childNode->ToElement())->Attribute(TEXT("userReadOnly"));
1892  					if (boolStrReadOnly)
1893  						isUserReadOnly = _wcsicmp(TEXT("yes"), boolStrReadOnly) == 0;
1894  					sessionFileInfo sfi(fileName, langName, encStr ? encoding : -1, isUserReadOnly, position, backupFilePath, fileModifiedTimestamp, mapPosition);
1895  					const TCHAR* intStrTabColour = (childNode->ToElement())->Attribute(TEXT("tabColourId"));
1896  					if (intStrTabColour)
1897  					{
1898  						sfi._individualTabColour = _wtoi(intStrTabColour);
1899  					}
1900  					for (TiXmlNode *markNode = childNode->FirstChildElement(TEXT("Mark"));
1901  						markNode;
1902  						markNode = markNode->NextSibling(TEXT("Mark")))
1903  					{
1904  						const TCHAR* lineNumberStr = (markNode->ToElement())->Attribute(TEXT("line"));
1905  						if (lineNumberStr)
1906  						{
1907  							sfi._marks.push_back(static_cast<size_t>(_ttoi64(lineNumberStr)));
1908  						}
1909  					}
1910  					for (TiXmlNode *foldNode = childNode->FirstChildElement(TEXT("Fold"));
1911  						foldNode;
1912  						foldNode = foldNode->NextSibling(TEXT("Fold")))
1913  					{
1914  						const TCHAR *lineNumberStr = (foldNode->ToElement())->Attribute(TEXT("line"));
1915  						if (lineNumberStr)
1916  						{
1917  							sfi._foldStates.push_back(static_cast<size_t>(_ttoi64(lineNumberStr)));
1918  						}
1919  					}
1920  					if (k == 0)
1921  						session._mainViewFiles.push_back(sfi);
1922  					else 
1923  						session._subViewFiles.push_back(sfi);
1924  				}
1925  			}
1926  		}
1927  	}
1928  	TiXmlNode *fileBrowserRoot = sessionRoot->FirstChildElement(TEXT("FileBrowser"));
1929  	if (fileBrowserRoot)
1930  	{
1931  		const TCHAR *selectedItemPath = (fileBrowserRoot->ToElement())->Attribute(TEXT("latestSelectedItem"));
1932  		if (selectedItemPath)
1933  		{
1934  			session._fileBrowserSelectedItem = selectedItemPath;
1935  		}
1936  		for (TiXmlNode *childNode = fileBrowserRoot->FirstChildElement(TEXT("root"));
1937  			childNode;
1938  			childNode = childNode->NextSibling(TEXT("root")))
1939  		{
1940  			const TCHAR *fileName = (childNode->ToElement())->Attribute(TEXT("foldername"));
1941  			if (fileName)
1942  			{
1943  				session._fileBrowserRoots.push_back({ fileName });
1944  			}
1945  		}
1946  	}
1947  	return true;
1948  }
1949  void NppParameters::feedFileListParameters(TiXmlNode *node)
1950  {
1951  	TiXmlNode *historyRoot = node->FirstChildElement(TEXT("History"));
1952  	if (!historyRoot) return;
1953  	int nbMaxFile = _nbMaxRecentFile;
1954  	const TCHAR *strVal = (historyRoot->ToElement())->Attribute(TEXT("nbMaxFile"), &nbMaxFile);
1955  	if (strVal && (nbMaxFile >= 0) && (nbMaxFile <= NB_MAX_LRF_FILE))
1956  		_nbMaxRecentFile = nbMaxFile;
1957  	int customLen = RECENTFILES_SHOWFULLPATH;
1958  	strVal = (historyRoot->ToElement())->Attribute(TEXT("customLength"), &customLen);
1959  	if (strVal)
1960  		_recentFileCustomLength = std::min<int>(customLen, NB_MAX_LRF_CUSTOMLENGTH);
1961  	strVal = (historyRoot->ToElement())->Attribute(TEXT("inSubMenu"));
1962  	if (strVal)
1963  		_putRecentFileInSubMenu = (lstrcmp(strVal, TEXT("yes")) == 0);
1964  	for (TiXmlNode *childNode = historyRoot->FirstChildElement(TEXT("File"));
1965  		childNode && (_nbRecentFile < NB_MAX_LRF_FILE);
1966  		childNode = childNode->NextSibling(TEXT("File")) )
1967  	{
1968  		const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("filename"));
1969  		if (filePath)
1970  		{
1971  			_LRFileList[_nbRecentFile] = new generic_string(filePath);
1972  			++_nbRecentFile;
1973  		}
1974  	}
1975  }
1976  void NppParameters::feedFileBrowserParameters(TiXmlNode *node)
1977  {
1978  	TiXmlNode *fileBrowserRoot = node->FirstChildElement(TEXT("FileBrowser"));
1979  	if (!fileBrowserRoot) return;
1980  	const TCHAR *selectedItemPath = (fileBrowserRoot->ToElement())->Attribute(TEXT("latestSelectedItem"));
1981  	if (selectedItemPath)
1982  	{
1983  		_fileBrowserSelectedItemPath = selectedItemPath;
1984  	}
1985  	for (TiXmlNode *childNode = fileBrowserRoot->FirstChildElement(TEXT("root"));
1986  		childNode;
1987  		childNode = childNode->NextSibling(TEXT("root")) )
1988  	{
1989  		const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("foldername"));
1990  		if (filePath)
1991  		{
1992  			_fileBrowserRoot.push_back(filePath);
1993  		}
1994  	}
1995  }
1996  void NppParameters::feedProjectPanelsParameters(TiXmlNode *node)
1997  {
1998  	TiXmlNode *projPanelRoot = node->FirstChildElement(TEXT("ProjectPanels"));
1999  	if (!projPanelRoot) return;
2000  	for (TiXmlNode *childNode = projPanelRoot->FirstChildElement(TEXT("ProjectPanel"));
2001  		childNode;
2002  		childNode = childNode->NextSibling(TEXT("ProjectPanel")) )
2003  	{
2004  		int index = 0;
2005  		const TCHAR *idStr = (childNode->ToElement())->Attribute(TEXT("id"), &index);
2006  		if (idStr && (index >= 0 && index <= 2))
2007  		{
2008  			const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("workSpaceFile"));
2009  			if (filePath)
2010  			{
2011  				_workSpaceFilePathes[index] = filePath;
2012  			}
2013  		}
2014  	}
2015  }
2016  void NppParameters::feedColumnEditorParameters(TiXmlNode *node)
2017  {
2018  	TiXmlNode * columnEditorRoot = node->FirstChildElement(TEXT("ColumnEditor"));
2019  	if (!columnEditorRoot) return;
2020  	const TCHAR* strVal = (columnEditorRoot->ToElement())->Attribute(TEXT("choice"));
2021  	if (strVal)
2022  	{
2023  		if (lstrcmp(strVal, TEXT("text")) == 0)
2024  			_columnEditParam._mainChoice = activeText;
2025  		else
2026  			_columnEditParam._mainChoice = activeNumeric;
2027  	}
2028  	TiXmlNode *childNode = columnEditorRoot->FirstChildElement(TEXT("text"));
2029  	if (!childNode) return;
2030  	const TCHAR* content = (childNode->ToElement())->Attribute(TEXT("content"));
2031  	if (content)
2032  	{
2033  		_columnEditParam._insertedTextContent = content;
2034  	}
2035  	childNode = columnEditorRoot->FirstChildElement(TEXT("number"));
2036  	if (!childNode) return;
2037  	int val;
2038  	strVal = (childNode->ToElement())->Attribute(TEXT("initial"), &val);
2039  	if (strVal)
2040  		_columnEditParam._initialNum = val;
2041  	strVal = (childNode->ToElement())->Attribute(TEXT("increase"), &val);
2042  	if (strVal)
2043  		_columnEditParam._increaseNum = val;
2044  	strVal = (childNode->ToElement())->Attribute(TEXT("repeat"), &val);
2045  	if (strVal)
2046  		_columnEditParam._repeatNum = val;
2047  	strVal = (childNode->ToElement())->Attribute(TEXT("formatChoice"));
2048  	if (strVal)
2049  	{
2050  		if (lstrcmp(strVal, TEXT("hex")) == 0)
2051  			_columnEditParam._formatChoice = 1;
2052  		else if (lstrcmp(strVal, TEXT("oct")) == 0)
2053  			_columnEditParam._formatChoice = 2;
2054  		else if (lstrcmp(strVal, TEXT("bin")) == 0)
2055  			_columnEditParam._formatChoice = 3;
2056  		else 
2057  			_columnEditParam._formatChoice = 0;
2058  	}
2059  	strVal = (childNode->ToElement())->Attribute(TEXT("leadingChoice"));
2060  	if (strVal)
2061  	{
2062  		_columnEditParam._leadingChoice = ColumnEditorParam::noneLeading;
2063  		if (lstrcmp(strVal, TEXT("zeros")) == 0)
2064  		{
2065  			_columnEditParam._leadingChoice = ColumnEditorParam::zeroLeading;
2066  		}
2067  		else if (lstrcmp(strVal, TEXT("spaces")) == 0)
2068  		{
2069  			_columnEditParam._leadingChoice = ColumnEditorParam::spaceLeading;
2070  		}
2071  	}
2072  }
2073  void NppParameters::feedFindHistoryParameters(TiXmlNode *node)
2074  {
2075  	TiXmlNode *findHistoryRoot = node->FirstChildElement(TEXT("FindHistory"));
2076  	if (!findHistoryRoot) return;
2077  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryPath"), &_findHistory._nbMaxFindHistoryPath);
2078  	if (_findHistory._nbMaxFindHistoryPath > NB_MAX_FINDHISTORY_PATH)
2079  	{
2080  		_findHistory._nbMaxFindHistoryPath = NB_MAX_FINDHISTORY_PATH;
2081  	}
2082  	if ((_findHistory._nbMaxFindHistoryPath > 0) && (_findHistory._nbMaxFindHistoryPath <= NB_MAX_FINDHISTORY_PATH))
2083  	{
2084  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Path"));
2085  			childNode && (_findHistory._findHistoryPaths.size() < NB_MAX_FINDHISTORY_PATH);
2086  			childNode = childNode->NextSibling(TEXT("Path")) )
2087  		{
2088  			const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("name"));
2089  			if (filePath)
2090  			{
2091  				_findHistory._findHistoryPaths.push_back(generic_string(filePath));
2092  			}
2093  		}
2094  	}
2095  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryFilter"), &_findHistory._nbMaxFindHistoryFilter);
2096  	if (_findHistory._nbMaxFindHistoryFilter > NB_MAX_FINDHISTORY_FILTER)
2097  	{
2098  		_findHistory._nbMaxFindHistoryFilter = NB_MAX_FINDHISTORY_FILTER;
2099  	}
2100  	if ((_findHistory._nbMaxFindHistoryFilter > 0) && (_findHistory._nbMaxFindHistoryFilter <= NB_MAX_FINDHISTORY_FILTER))
2101  	{
2102  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Filter"));
2103  			childNode && (_findHistory._findHistoryFilters.size() < NB_MAX_FINDHISTORY_FILTER);
2104  			childNode = childNode->NextSibling(TEXT("Filter")))
2105  		{
2106  			const TCHAR *fileFilter = (childNode->ToElement())->Attribute(TEXT("name"));
2107  			if (fileFilter)
2108  			{
2109  				_findHistory._findHistoryFilters.push_back(generic_string(fileFilter));
2110  			}
2111  		}
2112  	}
2113  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryFind"), &_findHistory._nbMaxFindHistoryFind);
2114  	if (_findHistory._nbMaxFindHistoryFind > NB_MAX_FINDHISTORY_FIND)
2115  	{
2116  		_findHistory._nbMaxFindHistoryFind = NB_MAX_FINDHISTORY_FIND;
2117  	}
2118  	if ((_findHistory._nbMaxFindHistoryFind > 0) && (_findHistory._nbMaxFindHistoryFind <= NB_MAX_FINDHISTORY_FIND))
2119  	{
2120  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Find"));
2121  			childNode && (_findHistory._findHistoryFinds.size() < NB_MAX_FINDHISTORY_FIND);
2122  			childNode = childNode->NextSibling(TEXT("Find")))
2123  		{
2124  			const TCHAR *fileFind = (childNode->ToElement())->Attribute(TEXT("name"));
2125  			if (fileFind)
2126  			{
2127  				_findHistory._findHistoryFinds.push_back(generic_string(fileFind));
2128  			}
2129  		}
2130  	}
2131  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryReplace"), &_findHistory._nbMaxFindHistoryReplace);
2132  	if (_findHistory._nbMaxFindHistoryReplace > NB_MAX_FINDHISTORY_REPLACE)
2133  	{
2134  		_findHistory._nbMaxFindHistoryReplace = NB_MAX_FINDHISTORY_REPLACE;
2135  	}
2136  	if ((_findHistory._nbMaxFindHistoryReplace > 0) && (_findHistory._nbMaxFindHistoryReplace <= NB_MAX_FINDHISTORY_REPLACE))
2137  	{
2138  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Replace"));
2139  			childNode && (_findHistory._findHistoryReplaces.size() < NB_MAX_FINDHISTORY_REPLACE);
2140  			childNode = childNode->NextSibling(TEXT("Replace")))
2141  		{
2142  			const TCHAR *fileReplace = (childNode->ToElement())->Attribute(TEXT("name"));
2143  			if (fileReplace)
2144  			{
2145  				_findHistory._findHistoryReplaces.push_back(generic_string(fileReplace));
2146  			}
2147  		}
2148  	}
2149  	const TCHAR *boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("matchWord"));
2150  	if (boolStr)
2151  		_findHistory._isMatchWord = (lstrcmp(TEXT("yes"), boolStr) == 0);
2152  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("matchCase"));
2153  	if (boolStr)
2154  		_findHistory._isMatchCase = (lstrcmp(TEXT("yes"), boolStr) == 0);
2155  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("wrap"));
2156  	if (boolStr)
2157  		_findHistory._isWrap = (lstrcmp(TEXT("yes"), boolStr) == 0);
2158  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("directionDown"));
2159  	if (boolStr)
2160  		_findHistory._isDirectionDown = (lstrcmp(TEXT("yes"), boolStr) == 0);
2161  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifRecuisive"));
2162  	if (boolStr)
2163  		_findHistory._isFifRecuisive = (lstrcmp(TEXT("yes"), boolStr) == 0);
2164  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifInHiddenFolder"));
2165  	if (boolStr)
2166  		_findHistory._isFifInHiddenFolder = (lstrcmp(TEXT("yes"), boolStr) == 0);
2167  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel1"));
2168  	if (boolStr)
2169  		_findHistory._isFifProjectPanel_1 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2170  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel2"));
2171  	if (boolStr)
2172  		_findHistory._isFifProjectPanel_2 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2173  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel3"));
2174  	if (boolStr)
2175  		_findHistory._isFifProjectPanel_3 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2176  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifFilterFollowsDoc"));
2177  	if (boolStr)
2178  		_findHistory._isFilterFollowDoc = (lstrcmp(TEXT("yes"), boolStr) == 0);
2179  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifFolderFollowsDoc"));
2180  	if (boolStr)
2181  		_findHistory._isFolderFollowDoc = (lstrcmp(TEXT("yes"), boolStr) == 0);
2182  	int mode = 0;
2183  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("searchMode"), &mode);
2184  	if (boolStr)
2185  		_findHistory._searchMode = (FindHistory::searchMode)mode;
2186  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("transparencyMode"), &mode);
2187  	if (boolStr)
2188  		_findHistory._transparencyMode = (FindHistory::transparencyMode)mode;
2189  	(findHistoryRoot->ToElement())->Attribute(TEXT("transparency"), &_findHistory._transparency);
2190  	if (_findHistory._transparency <= 0 || _findHistory._transparency > 200)
2191  		_findHistory._transparency = 150;
2192  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("dotMatchesNewline"));
2193  	if (boolStr)
2194  		_findHistory._dotMatchesNewline = (lstrcmp(TEXT("yes"), boolStr) == 0);
2195  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("isSearch2ButtonsMode"));
2196  	if (boolStr)
2197  		_findHistory._isSearch2ButtonsMode = (lstrcmp(TEXT("yes"), boolStr) == 0);
2198  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("regexBackward4PowerUser"));
2199  	if (boolStr)
2200  		_findHistory._regexBackward4PowerUser = (lstrcmp(TEXT("yes"), boolStr) == 0);
2201  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("bookmarkLine"));
2202  	if (boolStr)
2203  		_findHistory._isBookmarkLine = (lstrcmp(TEXT("yes"), boolStr) == 0);
2204  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("purge"));
2205  	if (boolStr)
2206  		_findHistory._isPurge = (lstrcmp(TEXT("yes"), boolStr) == 0);
2207  }
2208  void NppParameters::feedShortcut(TiXmlNodeA *node)
2209  {
2210  	TiXmlNodeA *shortcutsRoot = node->FirstChildElement("InternalCommands");
2211  	if (!shortcutsRoot) return;
2212  	for (TiXmlNodeA *childNode = shortcutsRoot->FirstChildElement("Shortcut");
2213  		childNode ;
2214  		childNode = childNode->NextSibling("Shortcut"))
2215  	{
2216  		int id;
2217  		const char* idStr = (childNode->ToElement())->Attribute("id", &id);
2218  		if (idStr)
2219  		{
2220  			size_t len = _shortcuts.size();
2221  			for (size_t i = 0; i < len; ++i)
2222  			{
2223  				if (_shortcuts[i].getID() == (unsigned long)id)
2224  				{	
2225  					getShortcuts(childNode, _shortcuts[i]);
2226  					addUserModifiedIndex(i);
2227  				}
2228  			}
2229  		}
2230  	}
2231  }
2232  void NppParameters::feedMacros(TiXmlNodeA *node)
2233  {
2234  	TiXmlNodeA *macrosRoot = node->FirstChildElement("Macros");
2235  	if (!macrosRoot) return;
2236  	for (TiXmlNodeA *childNode = macrosRoot->FirstChildElement("Macro");
2237  		childNode ;
2238  		childNode = childNode->NextSibling("Macro"))
2239  	{
2240  		Shortcut sc;
2241  		string fdnm;
2242  		if (getShortcuts(childNode, sc, &fdnm))
2243  		{
2244  			Macro macro;
2245  			getActions(childNode, macro);
2246  			int cmdID = ID_MACRO + static_cast<int32_t>(_macros.size());
2247  			_macros.push_back(MacroShortcut(sc, macro, cmdID));
2248  			_macroMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2249  		}
2250  	}
2251  }
2252  void NppParameters::getActions(TiXmlNodeA *node, Macro & macro)
2253  {
2254  	for (TiXmlNodeA *childNode = node->FirstChildElement("Action");
2255  		childNode ;
2256  		childNode = childNode->NextSibling("Action") )
2257  	{
2258  		int type;
2259  		const char *typeStr = (childNode->ToElement())->Attribute("type", &type);
2260  		if ((!typeStr) || (type > 3))
2261  			continue;
2262  		int msg = 0;
2263  		(childNode->ToElement())->Attribute("message", &msg);
2264  		int wParam = 0;
2265  		(childNode->ToElement())->Attribute("wParam", &wParam);
2266  		int lParam = 0;
2267  		(childNode->ToElement())->Attribute("lParam", &lParam);
2268  		const char *sParam = (childNode->ToElement())->Attribute("sParam");
2269  		if (!sParam)
2270  			sParam = "";
2271  		recordedMacroStep step(msg, wParam, lParam, sParam, type);
2272  		if (step.isValid())
2273  			macro.push_back(step);
2274  	}
2275  }
2276  void NppParameters::feedUserCmds(TiXmlNodeA *node)
2277  {
2278  	TiXmlNodeA *userCmdsRoot = node->FirstChildElement("UserDefinedCommands");
2279  	if (!userCmdsRoot) return;
2280  	for (TiXmlNodeA *childNode = userCmdsRoot->FirstChildElement("Command");
2281  		childNode ;
2282  		childNode = childNode->NextSibling("Command") )
2283  	{
2284  		Shortcut sc;
2285  		string fdnm;
2286  		if (getShortcuts(childNode, sc, &fdnm))
2287  		{
2288  			TiXmlNodeA *aNode = childNode->FirstChild();
2289  			if (aNode)
2290  			{
2291  				const char* cmdStr = aNode->Value();
2292  				if (cmdStr)
2293  				{
2294  					int cmdID = ID_USER_CMD + static_cast<int32_t>(_userCommands.size());
2295  					_userCommands.push_back(UserCommand(sc, cmdStr, cmdID));
2296  					_runMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2297  				}
2298  			}
2299  		}
2300  	}
2301  }
2302  void NppParameters::feedPluginCustomizedCmds(TiXmlNodeA *node)
2303  {
2304  	TiXmlNodeA *pluginCustomizedCmdsRoot = node->FirstChildElement("PluginCommands");
2305  	if (!pluginCustomizedCmdsRoot) return;
2306  	for (TiXmlNodeA *childNode = pluginCustomizedCmdsRoot->FirstChildElement("PluginCommand");
2307  		childNode ;
2308  		childNode = childNode->NextSibling("PluginCommand") )
2309  	{
2310  		const char *moduleName = (childNode->ToElement())->Attribute("moduleName");
2311  		if (!moduleName)
2312  			continue;
2313  		int internalID = -1;
2314  		const char *internalIDStr = (childNode->ToElement())->Attribute("internalID", &internalID);
2315  		if (!internalIDStr)
2316  			continue;
2317  		size_t len = _pluginCommands.size();
2318  		for (size_t i = 0; i < len; ++i)
2319  		{
2320  			PluginCmdShortcut & pscOrig = _pluginCommands[i];
2321  			if (!strnicmp(pscOrig.getModuleName(), moduleName, strlen(moduleName)) && pscOrig.getInternalID() == internalID)
2322  			{
2323  				getShortcuts(childNode, _pluginCommands[i]);
2324  				addPluginModifiedIndex(i);
2325  				break;
2326  			}
2327  		}
2328  	}
2329  }
2330  void NppParameters::feedScintKeys(TiXmlNodeA *node)
2331  {
2332  	TiXmlNodeA *scintKeysRoot = node->FirstChildElement("ScintillaKeys");
2333  	if (!scintKeysRoot) return;
2334  	for (TiXmlNodeA *childNode = scintKeysRoot->FirstChildElement("ScintKey");
2335  		childNode ;
2336  		childNode = childNode->NextSibling("ScintKey") )
2337  	{
2338  		int scintKey;
2339  		const char *keyStr = (childNode->ToElement())->Attribute("ScintID", &scintKey);
2340  		if (!keyStr)
2341  			continue;
2342  		int menuID;
2343  		keyStr = (childNode->ToElement())->Attribute("menuCmdID", &menuID);
2344  		if (!keyStr)
2345  			continue;
2346  		size_t len = _scintillaKeyCommands.size();
2347  		for (int32_t i = 0; i < static_cast<int32_t>(len); ++i)
2348  		{
2349  			ScintillaKeyMap & skmOrig = _scintillaKeyCommands[i];
2350  			if (skmOrig.getScintillaKeyID() == (unsigned long)scintKey && skmOrig.getMenuCmdID() == menuID)
2351  			{
2352  				_scintillaKeyCommands[i].clearDups();
2353  				getShortcuts(childNode, _scintillaKeyCommands[i]);
2354  				_scintillaKeyCommands[i].setKeyComboByIndex(0, _scintillaKeyCommands[i].getKeyCombo());
2355  				addScintillaModifiedIndex(i);
2356  				KeyCombo kc;
2357  				for (TiXmlNodeA *nextNode = childNode->FirstChildElement("NextKey");
2358  					nextNode ;
2359  					nextNode = nextNode->NextSibling("NextKey"))
2360  				{
2361  					const char *str = (nextNode->ToElement())->Attribute("Ctrl");
2362  					if (!str)
2363  						continue;
2364  					kc._isCtrl = (strcmp("yes", str) == 0);
2365  					str = (nextNode->ToElement())->Attribute("Alt");
2366  					if (!str)
2367  						continue;
2368  					kc._isAlt = (strcmp("yes", str) == 0);
2369  					str = (nextNode->ToElement())->Attribute("Shift");
2370  					if (!str)
2371  						continue;
2372  					kc._isShift = (strcmp("yes", str) == 0);
2373  					int key;
2374  					str = (nextNode->ToElement())->Attribute("Key", &key);
2375  					if (!str)
2376  						continue;
2377  					kc._key = static_cast<unsigned char>(key);
2378  					_scintillaKeyCommands[i].addKeyCombo(kc);
2379  				}
2380  				break;
2381  			}
2382  		}
2383  	}
2384  }
2385  bool NppParameters::getShortcuts(TiXmlNodeA *node, Shortcut & sc, string* folderName)
2386  {
2387  	if (!node) return false;
2388  	const char* name = (node->ToElement())->Attribute("name");
2389  	if (!name)
2390  		name = "";
2391  	bool isCtrl = false;
2392  	const char* isCtrlStr = (node->ToElement())->Attribute("Ctrl");
2393  	if (isCtrlStr)
2394  		isCtrl = (strcmp("yes", isCtrlStr) == 0);
2395  	bool isAlt = false;
2396  	const char* isAltStr = (node->ToElement())->Attribute("Alt");
2397  	if (isAltStr)
2398  		isAlt = (strcmp("yes", isAltStr) == 0);
2399  	bool isShift = false;
2400  	const char* isShiftStr = (node->ToElement())->Attribute("Shift");
2401  	if (isShiftStr)
2402  		isShift = (strcmp("yes", isShiftStr) == 0);
2403  	int key;
2404  	const char* keyStr = (node->ToElement())->Attribute("Key", &key);
2405  	if (!keyStr)
2406  		return false;
2407  	if (folderName)
2408  	{
2409  		const char* fn = (node->ToElement())->Attribute("FolderName");
2410  		*folderName = fn ? fn : "";
2411  	}
2412  	sc = Shortcut(name, isCtrl, isAlt, isShift, static_cast<unsigned char>(key));
2413  	return true;
2414  }
2415  std::pair<unsigned char, unsigned char> NppParameters::feedUserLang(TiXmlNode *node)
2416  {
2417  	int iBegin = _nbUserLang;
2418  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("UserLang"));
2419  		childNode && (_nbUserLang < NB_MAX_USER_LANG);
2420  		childNode = childNode->NextSibling(TEXT("UserLang")) )
2421  	{
2422  		const TCHAR* name = (childNode->ToElement())->Attribute(TEXT("name"));
2423  		const TCHAR* ext = (childNode->ToElement())->Attribute(TEXT("ext"));
2424  		const TCHAR* darkModeTheme = (childNode->ToElement())->Attribute(TEXT("darkModeTheme"));
2425  		const TCHAR* udlVersion = (childNode->ToElement())->Attribute(TEXT("udlVersion"));
2426  		if (!name || !name[0] || !ext)
2427  		{
2428  			continue;
2429  		}
2430  		bool isDarkModeTheme = false;
2431  		if (darkModeTheme && darkModeTheme[0])
2432  		{
2433  			isDarkModeTheme = (lstrcmp(TEXT("yes"), darkModeTheme) == 0);
2434  		}
2435  		try {
2436  			_userLangArray[_nbUserLang] = new UserLangContainer(name, ext, isDarkModeTheme, udlVersion ? udlVersion : TEXT(""));
2437  			++_nbUserLang;
2438  			TiXmlNode *settingsRoot = childNode->FirstChildElement(TEXT("Settings"));
2439  			if (!settingsRoot)
2440  				throw std::runtime_error("NppParameters::feedUserLang : Settings node is missing");
2441  			feedUserSettings(settingsRoot);
2442  			TiXmlNode *keywordListsRoot = childNode->FirstChildElement(TEXT("KeywordLists"));
2443  			if (!keywordListsRoot)
2444  				throw std::runtime_error("NppParameters::feedUserLang : KeywordLists node is missing");
2445  			feedUserKeywordList(keywordListsRoot);
2446  			TiXmlNode *stylesRoot = childNode->FirstChildElement(TEXT("Styles"));
2447  			if (!stylesRoot)
2448  				throw std::runtime_error("NppParameters::feedUserLang : Styles node is missing");
2449  			feedUserStyles(stylesRoot);
2450  			for (int i = 0 ; i < SCE_USER_STYLE_TOTAL_STYLES ; ++i)
2451  			{
2452  				const Style * pStyle = _userLangArray[_nbUserLang - 1]->_styles.findByID(i);
2453  				if (!pStyle)
2454  					_userLangArray[_nbUserLang - 1]->_styles.addStyler(i, globalMappper().styleNameMapper[i]);
2455  			}
2456  		}
2457  		catch (const std::exception&)
2458  		{
2459  			delete _userLangArray[--_nbUserLang];
2460  		}
2461  	}
2462  	int iEnd = _nbUserLang;
2463  	return pair<unsigned char, unsigned char>(static_cast<unsigned char>(iBegin), static_cast<unsigned char>(iEnd));
2464  }
2465  bool NppParameters::importUDLFromFile(const generic_string& sourceFile)
2466  {
2467  	TiXmlDocument *pXmlUserLangDoc = new TiXmlDocument(sourceFile);
2468  	bool loadOkay = pXmlUserLangDoc->LoadFile();
2469  	if (loadOkay)
2470  	{
2471  		auto r = addUserDefineLangsFromXmlTree(pXmlUserLangDoc);
2472  		loadOkay = (r.second - r.first) != 0;
2473  		if (loadOkay)
2474  		{
2475  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, r));
2476  			setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
2477  		}
2478  	}
2479  	delete pXmlUserLangDoc;
2480  	return loadOkay;
2481  }
2482  bool NppParameters::exportUDLToFile(size_t langIndex2export, const generic_string& fileName2save)
2483  {
2484  	if (langIndex2export >= NB_MAX_USER_LANG)
2485  		return false;
2486  	if (static_cast<int32_t>(langIndex2export) >= _nbUserLang)
2487  		return false;
2488  	TiXmlDocument *pNewXmlUserLangDoc = new TiXmlDocument(fileName2save);
2489  	TiXmlNode *newRoot2export = pNewXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2490  	insertUserLang2Tree(newRoot2export, _userLangArray[langIndex2export]);
2491  	bool result = pNewXmlUserLangDoc->SaveFile();
2492  	delete pNewXmlUserLangDoc;
2493  	return result;
2494  }
2495  LangType NppParameters::getLangFromExt(const TCHAR *ext)
2496  {
2497  	int i = getNbLang();
2498  	i--;
2499  	while (i >= 0)
2500  	{
2501  		Lang *l = getLangFromIndex(i--);
2502  		const TCHAR *defList = l->getDefaultExtList();
2503  		const TCHAR *userList = NULL;
2504  		LexerStylerArray &lsa = getLStylerArray();
2505  		const TCHAR *lName = l->getLangName();
2506  		LexerStyler *pLS = lsa.getLexerStylerByName(lName);
2507  		if (pLS)
2508  			userList = pLS->getLexerUserExt();
2509  		generic_string list;
2510  		if (defList)
2511  			list += defList;
2512  		if (userList)
2513  		{
2514  			list += TEXT(" ");
2515  			list += userList;
2516  		}
2517  		if (isInList(ext, list.c_str()))
2518  			return l->getLangID();
2519  	}
2520  	return L_TEXT;
2521  }
2522  void NppParameters::setCloudChoice(const TCHAR *pathChoice)
2523  {
2524  	generic_string cloudChoicePath = getSettingsFolder();
2525  	cloudChoicePath += TEXT("\\cloud\\");
2526  	if (!PathFileExists(cloudChoicePath.c_str()))
2527  	{
2528  		::CreateDirectory(cloudChoicePath.c_str(), NULL);
2529  	}
2530  	cloudChoicePath += TEXT("choice");
2531  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2532  	std::string cloudPathA = wmc.wchar2char(pathChoice, SC_CP_UTF8);
2533  	writeFileContent(cloudChoicePath.c_str(), cloudPathA.c_str());
2534  }
2535  void NppParameters::removeCloudChoice()
2536  {
2537  	generic_string cloudChoicePath = getSettingsFolder();
2538  	cloudChoicePath += TEXT("\\cloud\\choice");
2539  	if (PathFileExists(cloudChoicePath.c_str()))
2540  	{
2541  		::DeleteFile(cloudChoicePath.c_str());
2542  	}
2543  }
2544  bool NppParameters::isCloudPathChanged() const
2545  {
2546  	if (_initialCloudChoice == _nppGUI._cloudPath)
2547  		return false;
2548  	else if (_initialCloudChoice.size() - _nppGUI._cloudPath.size() == 1)
2549  	{
2550  		TCHAR c = _initialCloudChoice.at(_initialCloudChoice.size()-1);
2551  		if (c == '\\' || c == '/')
2552  		{
2553  			if (_initialCloudChoice.find(_nppGUI._cloudPath) == 0)
2554  				return false;
2555  		}
2556  	}
2557  	else if (_nppGUI._cloudPath.size() - _initialCloudChoice.size() == 1)
2558  	{
2559  		TCHAR c = _nppGUI._cloudPath.at(_nppGUI._cloudPath.size() - 1);
2560  		if (c == '\\' || c == '/')
2561  		{
2562  			if (_nppGUI._cloudPath.find(_initialCloudChoice) == 0)
2563  				return false;
2564  		}
2565  	}
2566  	return true;
2567  }
2568  bool NppParameters::writeSettingsFilesOnCloudForThe1stTime(const generic_string & cloudSettingsPath)
2569  {
2570  	bool isOK = false;
2571  	if (cloudSettingsPath.empty())
2572  		return false;
2573  	generic_string cloudConfigPath = cloudSettingsPath;
2574  	pathAppend(cloudConfigPath, TEXT("config.xml"));
2575  	if (!::PathFileExists(cloudConfigPath.c_str()) && _pXmlUserDoc)
2576  	{
2577  		isOK = _pXmlUserDoc->SaveFile(cloudConfigPath.c_str());
2578  		if (!isOK)
2579  			return false;
2580  	}
2581  	generic_string cloudStylersPath = cloudSettingsPath;
2582  	pathAppend(cloudStylersPath, TEXT("stylers.xml"));
2583  	if (!::PathFileExists(cloudStylersPath.c_str()) && _pXmlUserStylerDoc)
2584  	{
2585  		isOK = _pXmlUserStylerDoc->SaveFile(cloudStylersPath.c_str());
2586  		if (!isOK)
2587  			return false;
2588  	}
2589  	generic_string cloudLangsPath = cloudSettingsPath;
2590  	pathAppend(cloudLangsPath, TEXT("langs.xml"));
2591  	if (!::PathFileExists(cloudLangsPath.c_str()) && _pXmlUserDoc)
2592  	{
2593  		isOK = _pXmlDoc->SaveFile(cloudLangsPath.c_str());
2594  		if (!isOK)
2595  			return false;
2596  	}
2597  	generic_string cloudUserLangsPath = cloudSettingsPath;
2598  	pathAppend(cloudUserLangsPath, TEXT("userDefineLang.xml"));
2599  	if (!::PathFileExists(cloudUserLangsPath.c_str()) && _pXmlUserLangDoc)
2600  	{
2601  		isOK = _pXmlUserLangDoc->SaveFile(cloudUserLangsPath.c_str());
2602  		if (!isOK)
2603  			return false;
2604  	}
2605  	generic_string cloudShortcutsPath = cloudSettingsPath;
2606  	pathAppend(cloudShortcutsPath, SHORTCUTSXML_FILENAME);
2607  	if (!::PathFileExists(cloudShortcutsPath.c_str()) && _pXmlShortcutDocA)
2608  	{
2609  		isOK = _pXmlShortcutDocA->SaveUnicodeFilePath(cloudShortcutsPath.c_str());
2610  		if (!isOK)
2611  			return false;
2612  	}
2613  	generic_string cloudContextMenuPath = cloudSettingsPath;
2614  	pathAppend(cloudContextMenuPath, TEXT("contextMenu.xml"));
2615  	if (!::PathFileExists(cloudContextMenuPath.c_str()) && _pXmlContextMenuDocA)
2616  	{
2617  		isOK = _pXmlContextMenuDocA->SaveUnicodeFilePath(cloudContextMenuPath.c_str());
2618  		if (!isOK)
2619  			return false;
2620  	}
2621  	generic_string cloudNativeLangPath = cloudSettingsPath;
2622  	pathAppend(cloudNativeLangPath, TEXT("nativeLang.xml"));
2623  	if (!::PathFileExists(cloudNativeLangPath.c_str()) && _pXmlNativeLangDocA)
2624  	{
2625  		isOK = _pXmlNativeLangDocA->SaveUnicodeFilePath(cloudNativeLangPath.c_str());
2626  		if (!isOK)
2627  			return false;
2628  	}
2629  	return true;
2630  }
2631  void NppParameters::writeDefaultUDL()
2632  {
2633  	bool firstCleanDone = false;
2634  	std::vector<std::pair<bool, bool>> deleteState; 
2635  	for (const auto& udl : _pXmlUserLangsDoc)
2636  	{
2637  		if (!_pXmlUserLangDoc)
2638  		{
2639  			_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
2640  			TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
2641  			_pXmlUserLangDoc->LinkEndChild(decl);
2642  			_pXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2643  		}
2644  		bool toDelete = (udl._indexRange.second - udl._indexRange.first) == 0;
2645  		deleteState.push_back(std::pair(toDelete, udl._isInDefaultSharedContainer));
2646  		if ((!udl._udlXmlDoc || udl._udlXmlDoc == _pXmlUserLangDoc) && udl._isDirty && !toDelete) 
2647  		{
2648  			TiXmlNode *root = _pXmlUserLangDoc->FirstChild(TEXT("NotepadPlus"));
2649  			if (root && !firstCleanDone)
2650  			{
2651  				_pXmlUserLangDoc->RemoveChild(root);
2652  				_pXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2653  				firstCleanDone = true;
2654  			}
2655  			root = _pXmlUserLangDoc->FirstChild(TEXT("NotepadPlus"));
2656  			for (int i = udl._indexRange.first; i < udl._indexRange.second; ++i)
2657  			{
2658  				insertUserLang2Tree(root, _userLangArray[i]);
2659  			}
2660  		}
2661  	}
2662  	bool deleteAll = true;
2663  	for (std::pair<bool, bool> udlState : deleteState)
2664  	{
2665  		if (!udlState.first && udlState.second) 
2666  		{
2667  			deleteAll = false; 
2668  			break;
2669  		}
2670  	}
2671  	if (firstCleanDone) 
2672  	{
2673  		_pXmlUserLangDoc->SaveFile();
2674  	}
2675  	else if (deleteAll)
2676  	{
2677  		if (::PathFileExists(_userDefineLangPath.c_str()))
2678  		{
2679  			::DeleteFile(_userDefineLangPath.c_str());
2680  		}
2681  	}
2682  }
2683  void NppParameters::writeNonDefaultUDL()
2684  {
2685  	for (auto& udl : _pXmlUserLangsDoc)
2686  	{
2687  		if (udl._isDirty && udl._udlXmlDoc != nullptr && udl._udlXmlDoc != _pXmlUserLangDoc)
2688  		{
2689  			if (udl._indexRange.second == udl._indexRange.first) 
2690  			{
2691  				const TCHAR* docFilePath = udl._udlXmlDoc->Value();
2692  				if (docFilePath && ::PathFileExists(docFilePath))
2693  				{
2694  					::DeleteFile(docFilePath);
2695  				}
2696  			}
2697  			else
2698  			{
2699  				TiXmlNode *root = udl._udlXmlDoc->FirstChild(TEXT("NotepadPlus"));
2700  				if (root)
2701  				{
2702  					udl._udlXmlDoc->RemoveChild(root);
2703  				}
2704  				udl._udlXmlDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2705  				root = udl._udlXmlDoc->FirstChild(TEXT("NotepadPlus"));
2706  				for (int i = udl._indexRange.first; i < udl._indexRange.second; ++i)
2707  				{
2708  					insertUserLang2Tree(root, _userLangArray[i]);
2709  				}
2710  				udl._udlXmlDoc->SaveFile();
2711  			}
2712  		}
2713  	}
2714  }
2715  void NppParameters::writeNeed2SaveUDL()
2716  {
2717  	writeDefaultUDL();
2718  	writeNonDefaultUDL();
2719  }
2720  void NppParameters::insertCmd(TiXmlNodeA *shortcutsRoot, const CommandShortcut & cmd)
2721  {
2722  	const KeyCombo & key = cmd.getKeyCombo();
2723  	TiXmlNodeA *sc = shortcutsRoot->InsertEndChild(TiXmlElementA("Shortcut"));
2724  	sc->ToElement()->SetAttribute("id", cmd.getID());
2725  	sc->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2726  	sc->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2727  	sc->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2728  	sc->ToElement()->SetAttribute("Key", key._key);
2729  }
2730  void NppParameters::insertMacro(TiXmlNodeA *macrosRoot, const MacroShortcut & macro, const string& folderName)
2731  {
2732  	const KeyCombo & key = macro.getKeyCombo();
2733  	TiXmlNodeA *macroRoot = macrosRoot->InsertEndChild(TiXmlElementA("Macro"));
2734  	macroRoot->ToElement()->SetAttribute("name", macro.getMenuName());
2735  	macroRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2736  	macroRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2737  	macroRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2738  	macroRoot->ToElement()->SetAttribute("Key", key._key);
2739  	if (!folderName.empty())
2740  	{
2741  		macroRoot->ToElement()->SetAttribute("FolderName", folderName);
2742  	}
2743  	for (size_t i = 0, len = macro._macro.size(); i < len ; ++i)
2744  	{
2745  		TiXmlNodeA *actionNode = macroRoot->InsertEndChild(TiXmlElementA("Action"));
2746  		const recordedMacroStep & action = macro._macro[i];
2747  		actionNode->ToElement()->SetAttribute("type", action._macroType);
2748  		actionNode->ToElement()->SetAttribute("message", action._message);
2749  		actionNode->ToElement()->SetAttribute("wParam", static_cast<int>(action._wParameter));
2750  		actionNode->ToElement()->SetAttribute("lParam", static_cast<int>(action._lParameter));
2751  		actionNode->ToElement()->SetAttribute("sParam", action._sParameter.c_str());
2752  	}
2753  }
2754  void NppParameters::insertUserCmd(TiXmlNodeA *userCmdRoot, const UserCommand & userCmd, const string& folderName)
2755  {
2756  	const KeyCombo & key = userCmd.getKeyCombo();
2757  	TiXmlNodeA *cmdRoot = userCmdRoot->InsertEndChild(TiXmlElementA("Command"));
2758  	cmdRoot->ToElement()->SetAttribute("name", userCmd.getMenuName());
2759  	cmdRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2760  	cmdRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2761  	cmdRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2762  	cmdRoot->ToElement()->SetAttribute("Key", key._key);
2763  	cmdRoot->InsertEndChild(TiXmlTextA(userCmd._cmd.c_str()));
2764  	if (!folderName.empty())
2765  	{
2766  		cmdRoot->ToElement()->SetAttribute("FolderName", folderName);
2767  	}
2768  }
2769  void NppParameters::insertPluginCmd(TiXmlNodeA *pluginCmdRoot, const PluginCmdShortcut & pluginCmd)
2770  {
2771  	const KeyCombo & key = pluginCmd.getKeyCombo();
2772  	TiXmlNodeA *pluginCmdNode = pluginCmdRoot->InsertEndChild(TiXmlElementA("PluginCommand"));
2773  	pluginCmdNode->ToElement()->SetAttribute("moduleName", pluginCmd.getModuleName());
<span onclick='openModal()' class='match'>2774  	pluginCmdNode->ToElement()->SetAttribute("internalID", pluginCmd.getInternalID());
2775  	pluginCmdNode->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
</span>2776  	pluginCmdNode->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2777  	pluginCmdNode->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2778  	pluginCmdNode->ToElement()->SetAttribute("Key", key._key);
2779  }
2780  void NppParameters::insertScintKey(TiXmlNodeA *scintKeyRoot, const ScintillaKeyMap & scintKeyMap)
2781  {
2782  	TiXmlNodeA *keyRoot = scintKeyRoot->InsertEndChild(TiXmlElementA("ScintKey"));
2783  	keyRoot->ToElement()->SetAttribute("ScintID", scintKeyMap.getScintillaKeyID());
2784  	keyRoot->ToElement()->SetAttribute("menuCmdID", scintKeyMap.getMenuCmdID());
2785  	KeyCombo key = scintKeyMap.getKeyComboByIndex(0);
2786  	keyRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2787  	keyRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2788  	keyRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2789  	keyRoot->ToElement()->SetAttribute("Key", key._key);
2790  	size_t size = scintKeyMap.getSize();
2791  	if (size > 1)
2792  	{
2793  		for (size_t i = 1; i < size; ++i)
2794  		{
2795  			TiXmlNodeA *keyNext = keyRoot->InsertEndChild(TiXmlElementA("NextKey"));
2796  			key = scintKeyMap.getKeyComboByIndex(i);
2797  			keyNext->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2798  			keyNext->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2799  			keyNext->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2800  			keyNext->ToElement()->SetAttribute("Key", key._key);
2801  		}
2802  	}
2803  }
2804  void NppParameters::writeSession(const Session & session, const TCHAR *fileName)
2805  {
2806  	const TCHAR *sessionPathName = fileName ? fileName : _sessionPath.c_str();
2807  	TCHAR backupPathName[MAX_PATH]{};
2808  	if (PathFileExists(sessionPathName))
2809  	{
2810  		_tcscpy(backupPathName, sessionPathName);
2811  		_tcscat(backupPathName, TEXT(".inCaseOfCorruption.bak"));
2812  		CopyFile(sessionPathName, backupPathName, FALSE);
2813  	}
2814  	TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(sessionPathName);
2815  	TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
2816  	pXmlSessionDoc->LinkEndChild(decl);
2817  	TiXmlNode *root = pXmlSessionDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2818  	if (root)
2819  	{
2820  		TiXmlNode *sessionNode = root->InsertEndChild(TiXmlElement(TEXT("Session")));
2821  		(sessionNode->ToElement())->SetAttribute(TEXT("activeView"), static_cast<int32_t>(session._activeView));
2822  		struct ViewElem {
2823  			TiXmlNode *viewNode;
2824  			vector<sessionFileInfo> *viewFiles;
2825  			size_t activeIndex;
2826  		};
2827  		const int nbElem = 2;
2828  		ViewElem viewElems[nbElem];
2829  		viewElems[0].viewNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("mainView")));
2830  		viewElems[1].viewNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("subView")));
2831  		viewElems[0].viewFiles = (vector<sessionFileInfo> *)(&(session._mainViewFiles));
2832  		viewElems[1].viewFiles = (vector<sessionFileInfo> *)(&(session._subViewFiles));
2833  		viewElems[0].activeIndex = session._activeMainIndex;
2834  		viewElems[1].activeIndex = session._activeSubIndex;
2835  		for (size_t k = 0; k < nbElem ; ++k)
2836  		{
2837  			(viewElems[k].viewNode->ToElement())->SetAttribute(TEXT("activeIndex"), static_cast<int32_t>(viewElems[k].activeIndex));
2838  			vector<sessionFileInfo> & viewSessionFiles = *(viewElems[k].viewFiles);
2839  			for (size_t i = 0, len = viewElems[k].viewFiles->size(); i < len ; ++i)
2840  			{
2841  				TiXmlNode *fileNameNode = viewElems[k].viewNode->InsertEndChild(TiXmlElement(TEXT("File")));
2842  				TCHAR szInt64[64];
2843  				(fileNameNode->ToElement())->SetAttribute(TEXT("firstVisibleLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._firstVisibleLine), szInt64, 10));
2844  				(fileNameNode->ToElement())->SetAttribute(TEXT("xOffset"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._xOffset), szInt64, 10));
2845  				(fileNameNode->ToElement())->SetAttribute(TEXT("scrollWidth"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._scrollWidth), szInt64, 10));
2846  				(fileNameNode->ToElement())->SetAttribute(TEXT("startPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._startPos), szInt64, 10));
2847  				(fileNameNode->ToElement())->SetAttribute(TEXT("endPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._endPos), szInt64, 10));
2848  				(fileNameNode->ToElement())->SetAttribute(TEXT("selMode"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._selMode), szInt64, 10));
2849  				(fileNameNode->ToElement())->SetAttribute(TEXT("offset"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._offset), szInt64, 10));
2850  				(fileNameNode->ToElement())->SetAttribute(TEXT("wrapCount"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._wrapCount), szInt64, 10));
2851  				(fileNameNode->ToElement())->SetAttribute(TEXT("lang"), viewSessionFiles[i]._langName.c_str());
2852  				(fileNameNode->ToElement())->SetAttribute(TEXT("encoding"), viewSessionFiles[i]._encoding);
2853  				(fileNameNode->ToElement())->SetAttribute(TEXT("userReadOnly"), (viewSessionFiles[i]._isUserReadOnly && !viewSessionFiles[i]._isMonitoring) ? TEXT("yes") : TEXT("no"));
2854  				(fileNameNode->ToElement())->SetAttribute(TEXT("filename"), viewSessionFiles[i]._fileName.c_str());
2855  				(fileNameNode->ToElement())->SetAttribute(TEXT("backupFilePath"), viewSessionFiles[i]._backupFilePath.c_str());
2856  				(fileNameNode->ToElement())->SetAttribute(TEXT("originalFileLastModifTimestamp"), static_cast<int32_t>(viewSessionFiles[i]._originalFileLastModifTimestamp.dwLowDateTime));
2857  				(fileNameNode->ToElement())->SetAttribute(TEXT("originalFileLastModifTimestampHigh"), static_cast<int32_t>(viewSessionFiles[i]._originalFileLastModifTimestamp.dwHighDateTime));
2858  				(fileNameNode->ToElement())->SetAttribute(TEXT("tabColourId"), static_cast<int32_t>(viewSessionFiles[i]._individualTabColour));
2859  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapFirstVisibleDisplayLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._firstVisibleDisplayLine), szInt64, 10));
2860  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapFirstVisibleDocLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._firstVisibleDocLine), szInt64, 10));
2861  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapLastVisibleDocLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._lastVisibleDocLine), szInt64, 10));
2862  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapNbLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._nbLine), szInt64, 10));
2863  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapHigherPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._higherPos), szInt64, 10));
2864  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapWidth"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._width), szInt64, 10));
2865  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapHeight"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._height), szInt64, 10));
2866  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapKByteInDoc"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._KByteInDoc), szInt64, 10));
2867  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapWrapIndentMode"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._wrapIndentMode), szInt64, 10));
2868  				fileNameNode->ToElement()->SetAttribute(TEXT("mapIsWrap"), viewSessionFiles[i]._mapPos._isWrap ? TEXT("yes") : TEXT("no"));
2869  				for (size_t j = 0, len = viewSessionFiles[i]._marks.size() ; j < len ; ++j)
2870  				{
2871  					size_t markLine = viewSessionFiles[i]._marks[j];
2872  					TiXmlNode *markNode = fileNameNode->InsertEndChild(TiXmlElement(TEXT("Mark")));
2873  					markNode->ToElement()->SetAttribute(TEXT("line"), _ui64tot(static_cast<ULONGLONG>(markLine), szInt64, 10));
2874  				}
2875  				for (size_t j = 0, len = viewSessionFiles[i]._foldStates.size() ; j < len ; ++j)
2876  				{
2877  					size_t foldLine = viewSessionFiles[i]._foldStates[j];
2878  					TiXmlNode *foldNode = fileNameNode->InsertEndChild(TiXmlElement(TEXT("Fold")));
2879  					foldNode->ToElement()->SetAttribute(TEXT("line"), _ui64tot(static_cast<ULONGLONG>(foldLine), szInt64, 10));
2880  				}
2881  			}
2882  		}
2883  		if (session._includeFileBrowser)
2884  		{
2885  			TiXmlNode* fileBrowserRootNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("FileBrowser")));
2886  			fileBrowserRootNode->ToElement()->SetAttribute(TEXT("latestSelectedItem"), session._fileBrowserSelectedItem.c_str());
2887  			for (const auto& root : session._fileBrowserRoots)
2888  			{
2889  				TiXmlNode *fileNameNode = fileBrowserRootNode->InsertEndChild(TiXmlElement(TEXT("root")));
2890  				(fileNameNode->ToElement())->SetAttribute(TEXT("foldername"), root.c_str());
2891  			}
2892  		}
2893  	}
2894  	bool sessionSaveOK = pXmlSessionDoc->SaveFile();
2895  	if (sessionSaveOK)
2896  	{
2897  		TiXmlDocument* pXmlSessionCheck = new TiXmlDocument(sessionPathName);
2898  		sessionSaveOK = pXmlSessionCheck->LoadFile();
2899  		delete pXmlSessionCheck;
2900  	}
2901  	if (!sessionSaveOK)
2902  	{
2903  		if (backupPathName[0]) 
2904  		{
2905  			_pNativeLangSpeaker->messageBox("ErrorOfSavingSessionFile",
2906  				nullptr,
2907  				TEXT("The old session file will be restored."),
2908  				TEXT("Error of saving session file"),
2909  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2910  			wstring sessionPathNameFail2Load = sessionPathName;
2911  			sessionPathNameFail2Load += L".fail2Load";
2912  			MoveFileEx(sessionPathName, sessionPathNameFail2Load.c_str(), MOVEFILE_REPLACE_EXISTING);
2913  			CopyFile(backupPathName, sessionPathName, FALSE);
2914  		}
2915  	}
2916  	else
2917  	{
2918  		if (backupPathName[0]) 
2919  		{
2920  			::DeleteFile(backupPathName);
2921  		}
2922  	}
2923  	delete pXmlSessionDoc;
2924  }
2925  void NppParameters::writeShortcuts()
2926  {
2927  	if (!_isAnyShortcutModified) return;
2928  	if (!_pXmlShortcutDocA)
2929  	{
2930  		_pXmlShortcutDocA = new TiXmlDocumentA();
2931  		TiXmlDeclarationA* decl = new TiXmlDeclarationA("1.0", "UTF-8", "");
2932  		_pXmlShortcutDocA->LinkEndChild(decl);
2933  	}
2934  	else
2935  	{
2936  		wchar_t v852NoNeedShortcutsBackup[MAX_PATH]{};
2937  		::wcscpy_s(v852NoNeedShortcutsBackup, _shortcutsPath.c_str());
2938  		::PathRemoveFileSpec(v852NoNeedShortcutsBackup);
2939  		::PathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
2940  		if (!::PathFileExists(v852NoNeedShortcutsBackup))
2941  		{
2942  			HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
2943  			::FlushFileBuffers(hFile);
2944  			::CloseHandle(hFile);
2945  			wstring v852ShortcutsBackupPath = _shortcutsPath;
2946  			v852ShortcutsBackupPath += L".v8.5.2.backup";
2947  			::CopyFile(_shortcutsPath.c_str(), v852ShortcutsBackupPath.c_str(), TRUE);
2948  			_pNativeLangSpeaker->messageBox("MacroAndRunCmdlWarning",
2949  				nullptr,
2950  				TEXT("Your Macro and Run commands saved in Notepad++ v.8.5.2 (or older) may not be compatible with the current version of Notepad++.\nPlease test those commands and, if needed, re-edit them.\n\nAlternatively, you can downgrade to Notepad++ v8.5.2 and restore your previous data.\nNotepad++ will backup your old \"shortcuts.xml\" and save it as \"shortcuts.xml.v8.5.2.backup\".\nRenaming \"shortcuts.xml.v8.5.2.backup\" -> \"shortcuts.xml\", your commands should be restored and work properly."),
2951  				TEXT("Macro and Run Commands Compatibility"),
2952  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2953  		}
2954  	}
2955  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
2956  	if (!root)
2957  	{
2958  		root = _pXmlShortcutDocA->InsertEndChild(TiXmlElementA("NotepadPlus"));
2959  	}
2960  	TiXmlNodeA *cmdRoot = root->FirstChild("InternalCommands");
2961  	if (cmdRoot)
2962  		root->RemoveChild(cmdRoot);
2963  	cmdRoot = root->InsertEndChild(TiXmlElementA("InternalCommands"));
2964  	for (size_t i = 0, len = _customizedShortcuts.size(); i < len ; ++i)
2965  	{
2966  		size_t index = _customizedShortcuts[i];
2967  		CommandShortcut csc = _shortcuts[index];
2968  		insertCmd(cmdRoot, csc);
2969  	}
2970  	TiXmlNodeA *macrosRoot = root->FirstChild("Macros");
2971  	if (macrosRoot)
2972  		root->RemoveChild(macrosRoot);
2973  	macrosRoot = root->InsertEndChild(TiXmlElementA("Macros"));
2974  	for (size_t i = 0, len = _macros.size(); i < len ; ++i)
2975  	{
2976  		insertMacro(macrosRoot, _macros[i], wstring2string(_macroMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2977  	}
2978  	TiXmlNodeA *userCmdRoot = root->FirstChild("UserDefinedCommands");
2979  	if (userCmdRoot)
2980  		root->RemoveChild(userCmdRoot);
2981  	userCmdRoot = root->InsertEndChild(TiXmlElementA("UserDefinedCommands"));
2982  	for (size_t i = 0, len = _userCommands.size(); i < len ; ++i)
2983  	{
2984  		insertUserCmd(userCmdRoot, _userCommands[i], wstring2string(_runMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2985  	}
2986  	TiXmlNodeA *pluginCmdRoot = root->FirstChild("PluginCommands");
2987  	if (pluginCmdRoot)
2988  		root->RemoveChild(pluginCmdRoot);
2989  	pluginCmdRoot = root->InsertEndChild(TiXmlElementA("PluginCommands"));
2990  	for (size_t i = 0, len = _pluginCustomizedCmds.size(); i < len ; ++i)
2991  	{
2992  		insertPluginCmd(pluginCmdRoot, _pluginCommands[_pluginCustomizedCmds[i]]);
2993  	}
2994  	TiXmlNodeA *scitillaKeyRoot = root->FirstChild("ScintillaKeys");
2995  	if (scitillaKeyRoot)
2996  		root->RemoveChild(scitillaKeyRoot);
2997  	scitillaKeyRoot = root->InsertEndChild(TiXmlElementA("ScintillaKeys"));
2998  	for (size_t i = 0, len = _scintillaModifiedKeyIndices.size(); i < len ; ++i)
2999  	{
3000  		insertScintKey(scitillaKeyRoot, _scintillaKeyCommands[_scintillaModifiedKeyIndices[i]]);
3001  	}
3002  	_pXmlShortcutDocA->SaveUnicodeFilePath(_shortcutsPath.c_str());
3003  }
3004  int NppParameters::addUserLangToEnd(const UserLangContainer & userLang, const TCHAR *newName)
3005  {
3006  	if (isExistingUserLangName(newName))
3007  		return -1;
3008  	unsigned char iBegin = _nbUserLang;
3009  	_userLangArray[_nbUserLang] = new UserLangContainer();
3010  	*(_userLangArray[_nbUserLang]) = userLang;
3011  	_userLangArray[_nbUserLang]->_name = newName;
3012  	++_nbUserLang;
3013  	unsigned char iEnd = _nbUserLang;
3014  	_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, make_pair(iBegin, iEnd)));
3015  	setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
3016  	return _nbUserLang-1;
3017  }
3018  void NppParameters::removeUserLang(size_t index)
3019  {
3020  	if (static_cast<int32_t>(index) >= _nbUserLang)
3021  		return;
3022  	delete _userLangArray[index];
3023  	for (int32_t i = static_cast<int32_t>(index); i < (_nbUserLang - 1); ++i)
3024  		_userLangArray[i] = _userLangArray[i+1];
3025  	_nbUserLang--;
3026  	removeIndexFromXmlUdls(index);
3027  }
3028  void NppParameters::feedUserSettings(TiXmlNode *settingsRoot)
3029  {
3030  	const TCHAR *boolStr;
3031  	TiXmlNode *globalSettingNode = settingsRoot->FirstChildElement(TEXT("Global"));
3032  	if (globalSettingNode)
3033  	{
3034  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("caseIgnored"));
3035  		if (boolStr)
3036  			_userLangArray[_nbUserLang - 1]->_isCaseIgnored = (lstrcmp(TEXT("yes"), boolStr) == 0);
3037  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("allowFoldOfComments"));
3038  		if (boolStr)
3039  			_userLangArray[_nbUserLang - 1]->_allowFoldOfComments = (lstrcmp(TEXT("yes"), boolStr) == 0);
3040  		(globalSettingNode->ToElement())->Attribute(TEXT("forcePureLC"), &_userLangArray[_nbUserLang - 1]->_forcePureLC);
3041  		(globalSettingNode->ToElement())->Attribute(TEXT("decimalSeparator"), &_userLangArray[_nbUserLang - 1]->_decimalSeparator);
3042  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("foldCompact"));
3043  		if (boolStr)
3044  			_userLangArray[_nbUserLang - 1]->_foldCompact = (lstrcmp(TEXT("yes"), boolStr) == 0);
3045  	}
3046  	TiXmlNode *prefixNode = settingsRoot->FirstChildElement(TEXT("Prefix"));
3047  	if (prefixNode)
3048  	{
3049  		const TCHAR *udlVersion = _userLangArray[_nbUserLang - 1]->_udlVersion.c_str();
3050  		if (!lstrcmp(udlVersion, TEXT("2.1")) || !lstrcmp(udlVersion, TEXT("2.0")))
3051  		{
3052  			for (int i = 0 ; i < SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
3053  			{
3054  				boolStr = (prefixNode->ToElement())->Attribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1]);
3055  				if (boolStr)
3056  					_userLangArray[_nbUserLang - 1]->_isPrefix[i] = (lstrcmp(TEXT("yes"), boolStr) == 0);
3057  			}
3058  		}
3059  		else	
3060  		{
3061  			TCHAR names[SCE_USER_TOTAL_KEYWORD_GROUPS][7] = {TEXT("words1"), TEXT("words2"), TEXT("words3"), TEXT("words4")};
3062  			for (int i = 0 ; i < 4 ; ++i)
3063  			{
3064  				boolStr = (prefixNode->ToElement())->Attribute(names[i]);
3065  				if (boolStr)
3066  					_userLangArray[_nbUserLang - 1]->_isPrefix[i] = (lstrcmp(TEXT("yes"), boolStr) == 0);
3067  			}
3068  		}
3069  	}
3070  }
3071  void NppParameters::feedUserKeywordList(TiXmlNode *node)
3072  {
3073  	const TCHAR * udlVersion = _userLangArray[_nbUserLang - 1]->_udlVersion.c_str();
3074  	int id = -1;
3075  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("Keywords"));
3076  		childNode ;
3077  		childNode = childNode->NextSibling(TEXT("Keywords")))
3078  	{
3079  		const TCHAR * keywordsName = (childNode->ToElement())->Attribute(TEXT("name"));
3080  		TiXmlNode *valueNode = childNode->FirstChild();
3081  		if (valueNode)
3082  		{
3083  			const TCHAR *kwl = nullptr;
3084  			if (!lstrcmp(udlVersion, TEXT("")) && !lstrcmp(keywordsName, TEXT("Delimiters")))	
3085  			{
3086  				basic_string<TCHAR> temp;
3087  				kwl = (valueNode)?valueNode->Value():TEXT("000000");
3088  				temp += TEXT("00");	 if (kwl[0] != '0') temp += kwl[0];	 temp += TEXT(" 01");
3089  				temp += TEXT(" 02");	if (kwl[3] != '0') temp += kwl[3];
3090  				temp += TEXT(" 03");	if (kwl[1] != '0') temp += kwl[1];	 temp += TEXT(" 04");
3091  				temp += TEXT(" 05");	if (kwl[4] != '0') temp += kwl[4];
3092  				temp += TEXT(" 06");	if (kwl[2] != '0') temp += kwl[2];	 temp += TEXT(" 07");
3093  				temp += TEXT(" 08");	if (kwl[5] != '0') temp += kwl[5];
3094  				temp += TEXT(" 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23");
3095  				wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[SCE_USER_KWLIST_DELIMITERS], temp.c_str());
3096  			}
3097  			else if (!lstrcmp(keywordsName, TEXT("Comment")))
3098  			{
3099  				kwl = (valueNode)?valueNode->Value():TEXT("");
3100  				basic_string<TCHAR> temp{TEXT(" ")};
3101  				temp += kwl;
3102  				size_t pos = 0;
3103  				pos = temp.find(TEXT(" 0"));
3104  				while (pos != string::npos)
3105  				{
3106  					temp.replace(pos, 2, TEXT(" 00"));
3107  					pos = temp.find(TEXT(" 0"), pos+1);
3108  				}
3109  				pos = temp.find(TEXT(" 1"));
3110  				while (pos != string::npos)
3111  				{
3112  					temp.replace(pos, 2, TEXT(" 03"));
3113  					pos = temp.find(TEXT(" 1"));
3114  				}
3115  				pos = temp.find(TEXT(" 2"));
3116  				while (pos != string::npos)
3117  				{
3118  					temp.replace(pos, 2, TEXT(" 04"));
3119  					pos = temp.find(TEXT(" 2"));
3120  				}
3121  				temp += TEXT(" 01 02");
3122  				if (temp[0] == ' ')
3123  					temp.erase(0, 1);
3124  				wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[SCE_USER_KWLIST_COMMENTS], temp.c_str());
3125  			}
3126  			else
3127  			{
3128  				kwl = (valueNode)?valueNode->Value():TEXT("");
3129  				if (globalMappper().keywordIdMapper.find(keywordsName) != globalMappper().keywordIdMapper.end())
3130  				{
3131  					id = globalMappper().keywordIdMapper[keywordsName];
3132  					if (wcslen(kwl) < max_char)
3133  					{
3134  						wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[id], kwl);
3135  					}
3136  					else
3137  					{
3138  						wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[id], TEXT("imported string too long, needs to be < max_char(30720)"));
3139  					}
3140  				}
3141  			}
3142  		}
3143  	}
3144  }
3145  void NppParameters::feedUserStyles(TiXmlNode *node)
3146  {
3147  	int id = -1;
3148  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("WordsStyle"));
3149  		childNode ;
3150  		childNode = childNode->NextSibling(TEXT("WordsStyle")))
3151  	{
3152  		const TCHAR *styleName = (childNode->ToElement())->Attribute(TEXT("name"));
3153  		if (styleName)
3154  		{
3155  			if (globalMappper().styleIdMapper.find(styleName) != globalMappper().styleIdMapper.end())
3156  			{
3157  				id = globalMappper().styleIdMapper[styleName];
3158  				_userLangArray[_nbUserLang - 1]->_styles.addStyler((id | L_USER << 16), childNode);
3159  			}
3160  		}
3161  	}
3162  }
3163  bool NppParameters::feedStylerArray(TiXmlNode *node)
3164  {
3165  	TiXmlNode *styleRoot = node->FirstChildElement(TEXT("LexerStyles"));
3166  	if (!styleRoot) return false;
3167  	for (TiXmlNode *childNode = styleRoot->FirstChildElement(TEXT("LexerType"));
3168  		 childNode ;
3169  		 childNode = childNode->NextSibling(TEXT("LexerType")) )
3170  	{
3171  		TiXmlElement *element = childNode->ToElement();
3172  		const TCHAR *lexerName = element->Attribute(TEXT("name"));
3173  		const TCHAR *lexerDesc = element->Attribute(TEXT("desc"));
3174  		const TCHAR *lexerUserExt = element->Attribute(TEXT("ext"));
3175  		const TCHAR *lexerExcluded = element->Attribute(TEXT("excluded"));
3176  		if (lexerName)
3177  		{
3178  			_lexerStylerVect.addLexerStyler(lexerName, lexerDesc, lexerUserExt, childNode);
3179  			if (lexerExcluded != NULL && (lstrcmp(lexerExcluded, TEXT("yes")) == 0))
3180  			{
3181  				int index = getExternalLangIndexFromName(lexerName);
3182  				if (index != -1)
3183  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)(index + L_EXTERNAL)));
3184  			}
3185  		}
3186  	}
3187  	_lexerStylerVect.sort();
3188  	TiXmlNode *globalStyleRoot = node->FirstChildElement(TEXT("GlobalStyles"));
3189  	if (!globalStyleRoot) return false;
3190  	for (TiXmlNode *childNode = globalStyleRoot->FirstChildElement(TEXT("WidgetStyle"));
3191  		 childNode ;
3192  		 childNode = childNode->NextSibling(TEXT("WidgetStyle")) )
3193  	{
3194  		TiXmlElement *element = childNode->ToElement();
3195  		const TCHAR *styleIDStr = element->Attribute(TEXT("styleID"));
3196  		int styleID = -1;
3197  		if ((styleID = decStrVal(styleIDStr)) != -1)
3198  		{
3199  			_widgetStyleArray.addStyler(styleID, childNode);
3200  		}
3201  	}
3202  	constexpr auto rgbhex = [](COLORREF bbggrr) -> int {
3203  		return
3204  			((bbggrr & 0xFF0000) >> 16) |
3205  			((bbggrr & 0x00FF00)) |
3206  			((bbggrr & 0x0000FF) << 16);
3207  	};
3208  	const Style* pStyle = _widgetStyleArray.findByName(TEXT("EOL custom color"));
3209  	if (!pStyle)
3210  	{
3211  		TiXmlNode* eolColorkNode = globalStyleRoot->InsertEndChild(TiXmlElement(TEXT("WidgetStyle")));
3212  		eolColorkNode->ToElement()->SetAttribute(TEXT("name"), TEXT("EOL custom color"));
3213  		eolColorkNode->ToElement()->SetAttribute(TEXT("styleID"), TEXT("0"));
3214  		eolColorkNode->ToElement()->SetAttribute(TEXT("fgColor"), TEXT("DADADA"));
3215  		_widgetStyleArray.addStyler(0, eolColorkNode);
3216  	}
3217  	const Style* pStyleNpc = _widgetStyleArray.findByName(g_npcStyleName);
3218  	if (!pStyleNpc)
3219  	{
3220  		TiXmlNode* npcColorkNode = globalStyleRoot->InsertEndChild(TiXmlElement(TEXT("WidgetStyle")));
3221  		npcColorkNode->ToElement()->SetAttribute(TEXT("name"), g_npcStyleName);
3222  		npcColorkNode->ToElement()->SetAttribute(TEXT("styleID"), TEXT("0"));
3223  		const Style* pStyleWS = _widgetStyleArray.findByName(TEXT("White space symbol"));
3224  		if (pStyleWS)
3225  		{
3226  			constexpr size_t bufSize = 7;
3227  			wchar_t strColor[bufSize] = { '\0' };
3228  			swprintf(strColor, bufSize, L"%6X", rgbhex(pStyleWS->_fgColor));
3229  			npcColorkNode->ToElement()->SetAttribute(L"fgColor", strColor);
3230  		}
3231  		else
3232  		{
3233  			npcColorkNode->ToElement()->SetAttribute(L"fgColor", L"DADADA");
3234  		}
3235  		_widgetStyleArray.addStyler(0, npcColorkNode);
3236  	}
3237  	return true;
3238  }
3239  void LexerStylerArray::addLexerStyler(const TCHAR *lexerName, const TCHAR *lexerDesc, const TCHAR *lexerUserExt , TiXmlNode *lexerNode)
3240  {
3241  	_lexerStylerVect.emplace_back();
3242  	LexerStyler & ls = _lexerStylerVect.back();
3243  	ls.setLexerName(lexerName);
3244  	if (lexerDesc)
3245  		ls.setLexerDesc(lexerDesc);
3246  	if (lexerUserExt)
3247  		ls.setLexerUserExt(lexerUserExt);
3248  	for (TiXmlNode *childNode = lexerNode->FirstChildElement(TEXT("WordsStyle"));
3249  		 childNode ;
3250  		 childNode = childNode->NextSibling(TEXT("WordsStyle")) )
3251  	{
3252  		TiXmlElement *element = childNode->ToElement();
3253  		const TCHAR *styleIDStr = element->Attribute(TEXT("styleID"));
3254  		if (styleIDStr)
3255  		{
3256  			int styleID = -1;
3257  			if ((styleID = decStrVal(styleIDStr)) != -1)
3258  			{
3259  				ls.addStyler(styleID, childNode);
3260  			}
3261  		}
3262  	}
3263  }
3264  void StyleArray::addStyler(int styleID, TiXmlNode *styleNode)
3265  {
3266  	bool isUser = styleID >> 16 == L_USER;
3267  	if (isUser)
3268  	{
3269  		styleID = (styleID & 0xFFFF);
3270  		if (styleID >= SCE_USER_STYLE_TOTAL_STYLES || findByID(styleID))
3271  			return;
3272  	}
3273  	_styleVect.emplace_back();
3274  	Style & s = _styleVect.back();
3275  	s._styleID = styleID;
3276  	if (styleNode)
3277  	{
3278  		TiXmlElement *element = styleNode->ToElement();
3279  		const TCHAR *str = element->Attribute(TEXT("name"));
3280  		if (str)
3281  		{
3282  			if (isUser)
3283  				s._styleDesc = globalMappper().styleNameMapper[styleID];
3284  			else
3285  				s._styleDesc = str;
3286  		}
3287  		str = element->Attribute(TEXT("fgColor"));
3288  		if (str)
3289  		{
3290  			unsigned long result = hexStrVal(str);
3291  			s._fgColor = (RGB((result >> 16) & 0xFF, (result >> 8) & 0xFF, result & 0xFF)) | (result & 0xFF000000);
3292  		}
3293  		str = element->Attribute(TEXT("bgColor"));
3294  		if (str)
3295  		{
3296  			unsigned long result = hexStrVal(str);
3297  			s._bgColor = (RGB((result >> 16) & 0xFF, (result >> 8) & 0xFF, result & 0xFF)) | (result & 0xFF000000);
3298  		}
3299  		str = element->Attribute(TEXT("colorStyle"));
3300  		if (str)
3301  		{
3302  			s._colorStyle = decStrVal(str);
3303  		}
3304  		str = element->Attribute(TEXT("fontName"));
3305  		if (str)
3306  		{
3307  			s._fontName = str;
3308  			s._isFontEnabled = true;
3309  		}
3310  		str = element->Attribute(TEXT("fontStyle"));
3311  		if (str)
3312  		{
3313  			s._fontStyle = decStrVal(str);
3314  		}
3315  		str = element->Attribute(TEXT("fontSize"));
3316  		if (str)
3317  		{
3318  			s._fontSize = decStrVal(str);
3319  		}
3320  		str = element->Attribute(TEXT("nesting"));
3321  		if (str)
3322  		{
3323  			s._nesting = decStrVal(str);
3324  		}
3325  		str = element->Attribute(TEXT("keywordClass"));
3326  		if (str)
3327  		{
3328  			s._keywordClass = getKwClassFromName(str);
3329  		}
3330  		TiXmlNode *v = styleNode->FirstChild();
3331  		if (v)
3332  		{
3333  			s._keywords = v->Value();
3334  		}
3335  	}
3336  }
3337  bool NppParameters::writeRecentFileHistorySettings(int nbMaxFile) const
3338  {
3339  	if (!_pXmlUserDoc) return false;
3340  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3341  	if (!nppRoot)
3342  	{
3343  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3344  	}
3345  	TiXmlNode *historyNode = nppRoot->FirstChildElement(TEXT("History"));
3346  	if (!historyNode)
3347  	{
3348  		historyNode = nppRoot->InsertEndChild(TiXmlElement(TEXT("History")));
3349  	}
3350  	(historyNode->ToElement())->SetAttribute(TEXT("nbMaxFile"), nbMaxFile!=-1?nbMaxFile:_nbMaxRecentFile);
3351  	(historyNode->ToElement())->SetAttribute(TEXT("inSubMenu"), _putRecentFileInSubMenu?TEXT("yes"):TEXT("no"));
3352  	(historyNode->ToElement())->SetAttribute(TEXT("customLength"), _recentFileCustomLength);
3353  	return true;
3354  }
3355  bool NppParameters::writeColumnEditorSettings() const
3356  {
3357  	if (!_pXmlUserDoc) return false;
3358  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3359  	if (!nppRoot)
3360  	{
3361  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3362  	}
3363  	TiXmlNode *oldColumnEditorNode = nppRoot->FirstChildElement(TEXT("ColumnEditor"));
3364  	if (oldColumnEditorNode)
3365  	{
3366  		nppRoot->RemoveChild(oldColumnEditorNode);
3367  	}
3368  	TiXmlElement columnEditorRootNode{TEXT("ColumnEditor")};
3369  	(columnEditorRootNode.ToElement())->SetAttribute(TEXT("choice"), _columnEditParam._mainChoice == activeNumeric ? L"number" : L"text");
3370  	TiXmlElement textNode{ TEXT("text") };
3371  	(textNode.ToElement())->SetAttribute(TEXT("content"), _columnEditParam._insertedTextContent.c_str());
3372  	(columnEditorRootNode.ToElement())->InsertEndChild(textNode);
3373  	TiXmlElement numberNode{ TEXT("number") };
3374  	(numberNode.ToElement())->SetAttribute(TEXT("initial"), _columnEditParam._initialNum);
3375  	(numberNode.ToElement())->SetAttribute(TEXT("increase"), _columnEditParam._increaseNum);
3376  	(numberNode.ToElement())->SetAttribute(TEXT("repeat"), _columnEditParam._repeatNum);
3377  	wstring format = TEXT("dec");
3378  	if (_columnEditParam._formatChoice == 1)
3379  		format = TEXT("hex");
3380  	else if (_columnEditParam._formatChoice == 2)
3381  		format = TEXT("oct");
3382  	else if (_columnEditParam._formatChoice == 3)
3383  		format = TEXT("bin");
3384  	(numberNode.ToElement())->SetAttribute(TEXT("formatChoice"), format);
3385  	wstring leading = TEXT("none");
3386  	if (_columnEditParam._leadingChoice == ColumnEditorParam::zeroLeading)
3387  		leading = TEXT("zeros");
3388  	else if (_columnEditParam._leadingChoice == ColumnEditorParam::spaceLeading)
3389  		leading = TEXT("spaces");
3390  	(numberNode.ToElement())->SetAttribute(TEXT("leadingChoice"), leading);
3391  	(columnEditorRootNode.ToElement())->InsertEndChild(numberNode);
3392  	(nppRoot->ToElement())->InsertEndChild(columnEditorRootNode);
3393  	return true;
3394  }
3395  bool NppParameters::writeProjectPanelsSettings() const
3396  {
3397  	if (!_pXmlUserDoc) return false;
3398  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3399  	if (!nppRoot)
3400  	{
3401  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3402  	}
3403  	TiXmlNode *oldProjPanelRootNode = nppRoot->FirstChildElement(TEXT("ProjectPanels"));
3404  	if (oldProjPanelRootNode)
3405  	{
3406  		nppRoot->RemoveChild(oldProjPanelRootNode);
3407  	}
3408  	TiXmlElement projPanelRootNode{TEXT("ProjectPanels")};
3409  	for (int32_t i = 0 ; i < 3 ; ++i)
3410  	{
3411  		TiXmlElement projPanelNode{TEXT("ProjectPanel")};
3412  		(projPanelNode.ToElement())->SetAttribute(TEXT("id"), i);
3413  		(projPanelNode.ToElement())->SetAttribute(TEXT("workSpaceFile"), _workSpaceFilePathes[i]);
3414  		(projPanelRootNode.ToElement())->InsertEndChild(projPanelNode);
3415  	}
3416  	(nppRoot->ToElement())->InsertEndChild(projPanelRootNode);
3417  	return true;
3418  }
3419  bool NppParameters::writeFileBrowserSettings(const vector<generic_string> & rootPaths, const generic_string & latestSelectedItemPath) const
3420  {
3421  	if (!_pXmlUserDoc) return false;
3422  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3423  	if (!nppRoot)
3424  	{
3425  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3426  	}
3427  	TiXmlNode *oldFileBrowserRootNode = nppRoot->FirstChildElement(TEXT("FileBrowser"));
3428  	if (oldFileBrowserRootNode)
3429  	{
3430  		nppRoot->RemoveChild(oldFileBrowserRootNode);
3431  	}
3432  	TiXmlElement fileBrowserRootNode{ TEXT("FileBrowser") };
3433  	if (rootPaths.size() != 0)
3434  	{
3435  		fileBrowserRootNode.SetAttribute(TEXT("latestSelectedItem"), latestSelectedItemPath.c_str());
3436  		size_t len = rootPaths.size();
3437  		for (size_t i = 0; i < len; ++i)
3438  		{
3439  			TiXmlElement fbRootNode{ TEXT("root") };
3440  			(fbRootNode.ToElement())->SetAttribute(TEXT("foldername"), rootPaths[i].c_str());
3441  			(fileBrowserRootNode.ToElement())->InsertEndChild(fbRootNode);
3442  		}
3443  	}
3444  	(nppRoot->ToElement())->InsertEndChild(fileBrowserRootNode);
3445  	return true;
3446  }
3447  bool NppParameters::writeHistory(const TCHAR *fullpath)
3448  {
3449  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3450  	if (!nppRoot)
3451  	{
3452  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3453  	}
3454  	TiXmlNode *historyNode = nppRoot->FirstChildElement(TEXT("History"));
3455  	if (!historyNode)
3456  	{
3457  		historyNode = nppRoot->InsertEndChild(TiXmlElement(TEXT("History")));
3458  	}
3459  	TiXmlElement recentFileNode(TEXT("File"));
3460  	(recentFileNode.ToElement())->SetAttribute(TEXT("filename"), fullpath);
3461  	(historyNode->ToElement())->InsertEndChild(recentFileNode);
3462  	return true;
3463  }
3464  TiXmlNode * NppParameters::getChildElementByAttribut(TiXmlNode *pere, const TCHAR *childName,\
3465  			const TCHAR *attributName, const TCHAR *attributVal) const
3466  {
3467  	for (TiXmlNode *childNode = pere->FirstChildElement(childName);
3468  		childNode ;
3469  		childNode = childNode->NextSibling(childName))
3470  	{
3471  		TiXmlElement *element = childNode->ToElement();
3472  		const TCHAR *val = element->Attribute(attributName);
3473  		if (val)
3474  		{
3475  			if (!lstrcmp(val, attributVal))
3476  				return childNode;
3477  		}
3478  	}
3479  	return NULL;
3480  }
3481  LangType NppParameters::getLangIDFromStr(const TCHAR *langName)
3482  {
3483  	int lang = static_cast<int32_t>(L_TEXT);
3484  	for (; lang < L_EXTERNAL; ++lang)
3485  	{
3486  		const TCHAR * name = ScintillaEditView::_langNameInfoArray[lang]._langName;
3487  		if (!lstrcmp(name, langName)) 
3488  		{
3489  			return (LangType)lang;
3490  		}
3491  	}
3492  	LangType l = (LangType)lang;
3493  	if (l == L_EXTERNAL) 
3494  	{
3495  		int id = NppParameters::getInstance().getExternalLangIndexFromName(langName);
3496  		if (id != -1) return (LangType)(id + L_EXTERNAL);
3497  	}
3498  	return L_TEXT;
3499  }
3500  generic_string NppParameters::getLocPathFromStr(const generic_string & localizationCode)
3501  {
3502  	if (localizationCode == TEXT("en") || localizationCode == TEXT("en-au") || localizationCode == TEXT("en-bz") || localizationCode == TEXT("en-ca") || localizationCode == TEXT("en-cb") || localizationCode == TEXT("en-gb") || localizationCode == TEXT("en-ie") || localizationCode == TEXT("en-jm") || localizationCode == TEXT("en-nz") || localizationCode == TEXT("en-ph") || localizationCode == TEXT("en-tt") || localizationCode == TEXT("en-us") || localizationCode == TEXT("en-za") || localizationCode == TEXT("en-zw"))
3503  		return TEXT("english.xml");
3504  	if (localizationCode == TEXT("af"))
3505  		return TEXT("afrikaans.xml");
3506  	if (localizationCode == TEXT("sq"))
3507  		return TEXT("albanian.xml");
3508  	if (localizationCode == TEXT("ar") || localizationCode == TEXT("ar-dz") || localizationCode == TEXT("ar-bh") || localizationCode == TEXT("ar-eg") ||localizationCode == TEXT("ar-iq") || localizationCode == TEXT("ar-jo") || localizationCode == TEXT("ar-kw") || localizationCode == TEXT("ar-lb") || localizationCode == TEXT("ar-ly") || localizationCode == TEXT("ar-ma") || localizationCode == TEXT("ar-om") || localizationCode == TEXT("ar-qa") || localizationCode == TEXT("ar-sa") || localizationCode == TEXT("ar-sy") || localizationCode == TEXT("ar-tn") || localizationCode == TEXT("ar-ae") || localizationCode == TEXT("ar-ye"))
3509  		return TEXT("arabic.xml");
3510  	if (localizationCode == TEXT("an"))
3511  		return TEXT("aragonese.xml");
3512  	if (localizationCode == TEXT("az"))
3513  		return TEXT("azerbaijani.xml");
3514  	if (localizationCode == TEXT("eu"))
3515  		return TEXT("basque.xml");
3516  	if (localizationCode == TEXT("be"))
3517  		return TEXT("belarusian.xml");
3518  	if (localizationCode == TEXT("bn"))
3519  		return TEXT("bengali.xml");
3520  	if (localizationCode == TEXT("bs"))
3521  		return TEXT("bosnian.xml");
3522  	if (localizationCode == TEXT("pt-br"))
3523  		return TEXT("brazilian_portuguese.xml");
3524  	if (localizationCode == TEXT("br-fr"))
3525  		return TEXT("breton.xml");
3526  	if (localizationCode == TEXT("bg"))
3527  		return TEXT("bulgarian.xml");
3528  	if (localizationCode == TEXT("ca"))
3529  		return TEXT("catalan.xml");
3530  	if (localizationCode == TEXT("zh-tw") || localizationCode == TEXT("zh-hk") || localizationCode == TEXT("zh-sg"))
3531  		return TEXT("taiwaneseMandarin.xml");
3532  	if (localizationCode == TEXT("zh") || localizationCode == TEXT("zh-cn"))
3533  		return TEXT("chineseSimplified.xml");
3534  	if (localizationCode == TEXT("co") || localizationCode == TEXT("co-fr"))
3535  		return TEXT("corsican.xml");
3536  	if (localizationCode == TEXT("hr"))
3537  		return TEXT("croatian.xml");
3538  	if (localizationCode == TEXT("cs"))
3539  		return TEXT("czech.xml");
3540  	if (localizationCode == TEXT("da"))
3541  		return TEXT("danish.xml");
3542  	if (localizationCode == TEXT("nl") || localizationCode == TEXT("nl-be"))
3543  		return TEXT("dutch.xml");
3544  	if (localizationCode == TEXT("eo"))
3545  		return TEXT("esperanto.xml");
3546  	if (localizationCode == TEXT("et"))
3547  		return TEXT("estonian.xml");
3548  	if (localizationCode == TEXT("fa"))
3549  		return TEXT("farsi.xml");
3550  	if (localizationCode == TEXT("fi"))
3551  		return TEXT("finnish.xml");
3552  	if (localizationCode == TEXT("fr") || localizationCode == TEXT("fr-be") || localizationCode == TEXT("fr-ca") || localizationCode == TEXT("fr-fr") || localizationCode == TEXT("fr-lu") || localizationCode == TEXT("fr-mc") || localizationCode == TEXT("fr-ch"))
3553  		return TEXT("french.xml");
3554  	if (localizationCode == TEXT("fur"))
3555  		return TEXT("friulian.xml");
3556  	if (localizationCode == TEXT("gl"))
3557  		return TEXT("galician.xml");
3558  	if (localizationCode == TEXT("ka"))
3559  		return TEXT("georgian.xml");
3560  	if (localizationCode == TEXT("de") || localizationCode == TEXT("de-at") || localizationCode == TEXT("de-de") || localizationCode == TEXT("de-li") || localizationCode == TEXT("de-lu") || localizationCode == TEXT("de-ch"))
3561  		return TEXT("german.xml");
3562  	if (localizationCode == TEXT("el"))
3563  		return TEXT("greek.xml");
3564  	if (localizationCode == TEXT("gu"))
3565  		return TEXT("gujarati.xml");
3566  	if (localizationCode == TEXT("he"))
3567  		return TEXT("hebrew.xml");
3568  	if (localizationCode == TEXT("hi"))
3569  		return TEXT("hindi.xml");
3570  	if (localizationCode == TEXT("hu"))
3571  		return TEXT("hungarian.xml");
3572  	if (localizationCode == TEXT("id"))
3573  		return TEXT("indonesian.xml");
3574  	if (localizationCode == TEXT("it") || localizationCode == TEXT("it-ch"))
3575  		return TEXT("italian.xml");
3576  	if (localizationCode == TEXT("ja"))
3577  		return TEXT("japanese.xml");
3578  	if (localizationCode == TEXT("kn"))
3579  		return TEXT("kannada.xml");
3580  	if (localizationCode == TEXT("kk"))
3581  		return TEXT("kazakh.xml");
3582  	if (localizationCode == TEXT("ko") || localizationCode == TEXT("ko-kp") || localizationCode == TEXT("ko-kr"))
3583  		return TEXT("korean.xml");
3584  	if (localizationCode == TEXT("ku"))
3585  		return TEXT("kurdish.xml");
3586  	if (localizationCode == TEXT("ky"))
3587  		return TEXT("kyrgyz.xml");
3588  	if (localizationCode == TEXT("lv"))
3589  		return TEXT("latvian.xml");
3590  	if (localizationCode == TEXT("lt"))
3591  		return TEXT("lithuanian.xml");
3592  	if (localizationCode == TEXT("lb"))
3593  		return TEXT("luxembourgish.xml");
3594  	if (localizationCode == TEXT("mk"))
3595  		return TEXT("macedonian.xml");
3596  	if (localizationCode == TEXT("ms"))
3597  		return TEXT("malay.xml");
3598  	if (localizationCode == TEXT("mr"))
3599  		return TEXT("marathi.xml");
3600  	if (localizationCode == TEXT("mn"))
3601  		return TEXT("mongolian.xml");
3602  	if (localizationCode == TEXT("no") || localizationCode == TEXT("nb"))
3603  		return TEXT("norwegian.xml");
3604  	if (localizationCode == TEXT("nn"))
3605  		return TEXT("nynorsk.xml");
3606  	if (localizationCode == TEXT("oc"))
3607  		return TEXT("occitan.xml");
3608  	if (localizationCode == TEXT("pl"))
3609  		return TEXT("polish.xml");
3610  	if (localizationCode == TEXT("pt") || localizationCode == TEXT("pt-pt"))
3611  		return TEXT("portuguese.xml");
3612  	if (localizationCode == TEXT("pa") || localizationCode == TEXT("pa-in"))
3613  		return TEXT("punjabi.xml");
3614  	if (localizationCode == TEXT("ro") || localizationCode == TEXT("ro-mo"))
3615  		return TEXT("romanian.xml");
3616  	if (localizationCode == TEXT("ru") || localizationCode == TEXT("ru-mo"))
3617  		return TEXT("russian.xml");
3618  	if (localizationCode == TEXT("sc"))
3619  		return TEXT("sardinian.xml");
3620  	if (localizationCode == TEXT("sr"))
3621  		return TEXT("serbian.xml");
3622  	if (localizationCode == TEXT("sr-cyrl-ba") || localizationCode == TEXT("sr-cyrl-sp"))
3623  		return TEXT("serbianCyrillic.xml");
3624  	if (localizationCode == TEXT("si"))
3625  		return TEXT("sinhala.xml");
3626  	if (localizationCode == TEXT("sk"))
3627  		return TEXT("slovak.xml");
3628  	if (localizationCode == TEXT("sl"))
3629  		return TEXT("slovenian.xml");
3630  	if (localizationCode == TEXT("es") || localizationCode == TEXT("es-bo") || localizationCode == TEXT("es-cl") || localizationCode == TEXT("es-co") || localizationCode == TEXT("es-cr") || localizationCode == TEXT("es-do") || localizationCode == TEXT("es-ec") || localizationCode == TEXT("es-sv") || localizationCode == TEXT("es-gt") || localizationCode == TEXT("es-hn") || localizationCode == TEXT("es-mx") || localizationCode == TEXT("es-ni") || localizationCode == TEXT("es-pa") || localizationCode == TEXT("es-py") || localizationCode == TEXT("es-pe") || localizationCode == TEXT("es-pr") || localizationCode == TEXT("es-es") || localizationCode == TEXT("es-uy") || localizationCode == TEXT("es-ve"))
3631  		return TEXT("spanish.xml");
3632  	if (localizationCode == TEXT("es-ar"))
3633  		return TEXT("spanish_ar.xml");
3634  	if (localizationCode == TEXT("sv"))
3635  		return TEXT("swedish.xml");
3636  	if (localizationCode == TEXT("tl"))
3637  		return TEXT("tagalog.xml");
3638  	if (localizationCode == TEXT("tg-cyrl-tj"))
3639  		return TEXT("tajikCyrillic.xml");
3640  	if (localizationCode == TEXT("ta"))
3641  		return TEXT("tamil.xml");
3642  	if (localizationCode == TEXT("tt"))
3643  		return TEXT("tatar.xml");
3644  	if (localizationCode == TEXT("te"))
3645  		return TEXT("telugu.xml");
3646  	if (localizationCode == TEXT("th"))
3647  		return TEXT("thai.xml");
3648  	if (localizationCode == TEXT("tr"))
3649  		return TEXT("turkish.xml");
3650  	if (localizationCode == TEXT("uk"))
3651  		return TEXT("ukrainian.xml");
3652  	if (localizationCode == TEXT("ur") || localizationCode == TEXT("ur-pk"))
3653  		return TEXT("urdu.xml");
3654  	if (localizationCode == TEXT("ug-cn"))
3655  		return TEXT("uyghur.xml");
3656  	if (localizationCode == TEXT("uz"))
3657  		return TEXT("uzbek.xml");
3658  	if (localizationCode == TEXT("uz-cyrl-uz"))
3659  		return TEXT("uzbekCyrillic.xml");
3660  	if (localizationCode == TEXT("vec"))
3661  		return TEXT("venetian.xml");
3662  	if (localizationCode == TEXT("vi") || localizationCode == TEXT("vi-vn"))
3663  		return TEXT("vietnamese.xml");
3664  	if (localizationCode == TEXT("cy-gb"))
3665  		return TEXT("welsh.xml");
3666  	if (localizationCode == TEXT("zu") || localizationCode == TEXT("zu-za"))
3667  		return TEXT("zulu.xml");
3668  	if (localizationCode == TEXT("ne") || localizationCode == TEXT("nep"))
3669  		return TEXT("nepali.xml");
3670  	if (localizationCode == TEXT("oc-aranes"))
3671  		return TEXT("aranese.xml");
3672  	if (localizationCode == TEXT("exy"))
3673  		return TEXT("extremaduran.xml");
3674  	if (localizationCode == TEXT("keb"))
3675  		return TEXT("kabyle.xml");
3676  	if (localizationCode == TEXT("lij"))
3677  		return TEXT("ligurian.xml");
3678  	if (localizationCode == TEXT("ga"))
3679  		return TEXT("irish.xml");
3680  	if (localizationCode == TEXT("sgs"))
3681  		return TEXT("samogitian.xml");
3682  	if (localizationCode == TEXT("yue"))
3683  		return TEXT("hongKongCantonese.xml");
3684  	if (localizationCode == TEXT("ab") || localizationCode == TEXT("abk"))
3685  		return TEXT("abkhazian.xml");
3686  	return generic_string();
3687  }
3688  void NppParameters::feedKeyWordsParameters(TiXmlNode *node)
3689  {
3690  	TiXmlNode *langRoot = node->FirstChildElement(TEXT("Languages"));
3691  	if (!langRoot)
3692  		return;
3693  	for (TiXmlNode *langNode = langRoot->FirstChildElement(TEXT("Language"));
3694  		langNode ;
3695  		langNode = langNode->NextSibling(TEXT("Language")) )
3696  	{
3697  		if (_nbLang < NB_LANG)
3698  		{
3699  			TiXmlElement* element = langNode->ToElement();
3700  			const TCHAR* name = element->Attribute(TEXT("name"));
3701  			if (name)
3702  			{
3703  				_langList[_nbLang] = new Lang(getLangIDFromStr(name), name);
3704  				_langList[_nbLang]->setDefaultExtList(element->Attribute(TEXT("ext")));
3705  				_langList[_nbLang]->setCommentLineSymbol(element->Attribute(TEXT("commentLine")));
3706  				_langList[_nbLang]->setCommentStart(element->Attribute(TEXT("commentStart")));
3707  				_langList[_nbLang]->setCommentEnd(element->Attribute(TEXT("commentEnd")));
3708  				int tabSettings;
3709  				if (element->Attribute(TEXT("tabSettings"), &tabSettings))
3710  					_langList[_nbLang]->setTabInfo(tabSettings);
3711  				for (TiXmlNode *kwNode = langNode->FirstChildElement(TEXT("Keywords"));
3712  					kwNode ;
3713  					kwNode = kwNode->NextSibling(TEXT("Keywords")) )
3714  				{
3715  					const TCHAR *indexName = (kwNode->ToElement())->Attribute(TEXT("name"));
3716  					TiXmlNode *kwVal = kwNode->FirstChild();
3717  					const TCHAR *keyWords = TEXT("");
3718  					if ((indexName) && (kwVal))
3719  						keyWords = kwVal->Value();
3720  					int i = getKwClassFromName(indexName);
3721  					if (i >= 0 && i <= KEYWORDSET_MAX)
3722  						_langList[_nbLang]->setWords(keyWords, i);
3723  				}
3724  				++_nbLang;
3725  			}
3726  		}
3727  	}
3728  }
3729  extern "C" {
3730  typedef DWORD (WINAPI * EESFUNC) (LPCTSTR, LPTSTR, DWORD);
3731  }
3732  void NppParameters::feedGUIParameters(TiXmlNode *node)
3733  {
3734  	TiXmlNode *GUIRoot = node->FirstChildElement(TEXT("GUIConfigs"));
3735  	if (nullptr == GUIRoot)
3736  		return;
3737  	for (TiXmlNode *childNode = GUIRoot->FirstChildElement(TEXT("GUIConfig"));
3738  		childNode ;
3739  		childNode = childNode->NextSibling(TEXT("GUIConfig")) )
3740  	{
3741  		TiXmlElement* element = childNode->ToElement();
3742  		const TCHAR* nm = element->Attribute(TEXT("name"));
3743  		if (nullptr == nm)
3744  			continue;
3745  		auto parseYesNoBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
3746  			const TCHAR* val = element->Attribute(name);
3747  			if (val != nullptr)
3748  			{
3749  				if (!lstrcmp(val, TEXT("yes")))
3750  					return true;
3751  				else if (!lstrcmp(val, TEXT("no")))
3752  					return false;
3753  			}
3754  			return defaultValue;
3755  		};
3756  		if (!lstrcmp(nm, TEXT("ToolBar")))
3757  		{
3758  			const TCHAR* val = element->Attribute(TEXT("visible"));
3759  			if (val)
3760  			{
3761  				if (!lstrcmp(val, TEXT("no")))
3762  					_nppGUI._toolbarShow = false;
3763  				else
3764  					_nppGUI._toolbarShow = true;
3765  			}
3766  			TiXmlNode *n = childNode->FirstChild();
3767  			if (n)
3768  			{
3769  				val = n->Value();
3770  				if (val)
3771  				{
3772  					if (!lstrcmp(val, TEXT("small")))
3773  						_nppGUI._toolBarStatus = TB_SMALL;
3774  					else if (!lstrcmp(val, TEXT("large")))
3775  						_nppGUI._toolBarStatus = TB_LARGE;
3776  					else if (!lstrcmp(val, TEXT("small2")))
3777  						_nppGUI._toolBarStatus = TB_SMALL2;
3778  					else if (!lstrcmp(val, TEXT("large2")))
3779  						_nppGUI._toolBarStatus = TB_LARGE2;
3780  					else 
3781  						_nppGUI._toolBarStatus = TB_STANDARD;
3782  				}
3783  			}
3784  		}
3785  		else if (!lstrcmp(nm, TEXT("StatusBar")))
3786  		{
3787  			TiXmlNode *n = childNode->FirstChild();
3788  			if (n)
3789  			{
3790  				const TCHAR* val = n->Value();
3791  				if (val)
3792  				{
3793  					if (!lstrcmp(val, TEXT("hide")))
3794  						_nppGUI._statusBarShow = false;
3795  					else if (!lstrcmp(val, TEXT("show")))
3796  						_nppGUI._statusBarShow = true;
3797  				}
3798  			}
3799  		}
3800  		else if (!lstrcmp(nm, TEXT("MenuBar")))
3801  		{
3802  			TiXmlNode *n = childNode->FirstChild();
3803  			if (n)
3804  			{
3805  				const TCHAR* val = n->Value();
3806  				if (val)
3807  				{
3808  					if (!lstrcmp(val, TEXT("hide")))
3809  						_nppGUI._menuBarShow = false;
3810  					else if (!lstrcmp(val, TEXT("show")))
3811  						_nppGUI._menuBarShow = true;
3812  				}
3813  			}
3814  		}
3815  		else if (!lstrcmp(nm, TEXT("TabBar")))
3816  		{
3817  			bool isFailed = false;
3818  			int oldValue = _nppGUI._tabStatus;
3819  			const TCHAR* val = element->Attribute(TEXT("dragAndDrop"));
3820  			if (val)
3821  			{
3822  				if (!lstrcmp(val, TEXT("yes")))
3823  					_nppGUI._tabStatus = TAB_DRAGNDROP;
3824  				else if (!lstrcmp(val, TEXT("no")))
3825  					_nppGUI._tabStatus = 0;
3826  				else
3827  					isFailed = true;
3828  			}
3829  			val = element->Attribute(TEXT("drawTopBar"));
3830  			if (val)
3831  			{
3832  				if (!lstrcmp(val, TEXT("yes")))
3833  					_nppGUI._tabStatus |= TAB_DRAWTOPBAR;
3834  				else if (!lstrcmp(val, TEXT("no")))
3835  					_nppGUI._tabStatus |= 0;
3836  				else
3837  					isFailed = true;
3838  			}
3839  			val = element->Attribute(TEXT("drawInactiveTab"));
3840  			if (val)
3841  			{
3842  				if (!lstrcmp(val, TEXT("yes")))
3843  					_nppGUI._tabStatus |= TAB_DRAWINACTIVETAB;
3844  				else if (!lstrcmp(val, TEXT("no")))
3845  					_nppGUI._tabStatus |= 0;
3846  				else
3847  					isFailed = true;
3848  			}
3849  			val = element->Attribute(TEXT("reduce"));
3850  			if (val)
3851  			{
3852  				if (!lstrcmp(val, TEXT("yes")))
3853  					_nppGUI._tabStatus |= TAB_REDUCE;
3854  				else if (!lstrcmp(val, TEXT("no")))
3855  					_nppGUI._tabStatus |= 0;
3856  				else
3857  					isFailed = true;
3858  			}
3859  			val = element->Attribute(TEXT("closeButton"));
3860  			if (val)
3861  			{
3862  				if (!lstrcmp(val, TEXT("yes")))
3863  					_nppGUI._tabStatus |= TAB_CLOSEBUTTON;
3864  				else if (!lstrcmp(val, TEXT("no")))
3865  					_nppGUI._tabStatus |= 0;
3866  				else
3867  					isFailed = true;
3868  			}
3869  			val = element->Attribute(TEXT("doubleClick2Close"));
3870  			if (val)
3871  			{
3872  				if (!lstrcmp(val, TEXT("yes")))
3873  					_nppGUI._tabStatus |= TAB_DBCLK2CLOSE;
3874  				else if (!lstrcmp(val, TEXT("no")))
3875  					_nppGUI._tabStatus |= 0;
3876  				else
3877  					isFailed = true;
3878  			}
3879  			val = element->Attribute(TEXT("vertical"));
3880  			if (val)
3881  			{
3882  				if (!lstrcmp(val, TEXT("yes")))
3883  					_nppGUI._tabStatus |= TAB_VERTICAL;
3884  				else if (!lstrcmp(val, TEXT("no")))
3885  					_nppGUI._tabStatus |= 0;
3886  				else
3887  					isFailed = true;
3888  			}
3889  			val = element->Attribute(TEXT("multiLine"));
3890  			if (val)
3891  			{
3892  				if (!lstrcmp(val, TEXT("yes")))
3893  					_nppGUI._tabStatus |= TAB_MULTILINE;
3894  				else if (!lstrcmp(val, TEXT("no")))
3895  					_nppGUI._tabStatus |= 0;
3896  				else
3897  					isFailed = true;
3898  			}
3899  			val = element->Attribute(TEXT("hide"));
3900  			if (val)
3901  			{
3902  				if (!lstrcmp(val, TEXT("yes")))
3903  					_nppGUI._tabStatus |= TAB_HIDE;
3904  				else if (!lstrcmp(val, TEXT("no")))
3905  					_nppGUI._tabStatus |= 0;
3906  				else
3907  					isFailed = true;
3908  			}
3909  			val = element->Attribute(TEXT("quitOnEmpty"));
3910  			if (val)
3911  			{
3912  				if (!lstrcmp(val, TEXT("yes")))
3913  					_nppGUI._tabStatus |= TAB_QUITONEMPTY;
3914  				else if (!lstrcmp(val, TEXT("no")))
3915  					_nppGUI._tabStatus |= 0;
3916  				else
3917  					isFailed = true;
3918  			}
3919  			val = element->Attribute(TEXT("iconSetNumber"));
3920  			if (val)
3921  			{
3922  				if (!lstrcmp(val, TEXT("1")))
3923  					_nppGUI._tabStatus |= TAB_ALTICONS;
3924  				else if (!lstrcmp(val, TEXT("0")))
3925  					_nppGUI._tabStatus |= 0;
3926  				else
3927  					isFailed = true;
3928  			}
3929  			if (isFailed)
3930  				_nppGUI._tabStatus = oldValue;
3931  		}
3932  		else if (!lstrcmp(nm, TEXT("Auto-detection")))
3933  		{
3934  			TiXmlNode *n = childNode->FirstChild();
3935  			if (n)
3936  			{
3937  				const TCHAR* val = n->Value();
3938  				if (val)
3939  				{
3940  					if (!lstrcmp(val, TEXT("yesOld")))
3941  						_nppGUI._fileAutoDetection = cdEnabledOld;
3942  					else if (!lstrcmp(val, TEXT("autoOld")))
3943  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate);
3944  					else if (!lstrcmp(val, TEXT("Update2EndOld")))
3945  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdGo2end);
3946  					else if (!lstrcmp(val, TEXT("autoUpdate2EndOld")))
3947  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate | cdGo2end);
3948  					else if (!lstrcmp(val, TEXT("yes")))
3949  						_nppGUI._fileAutoDetection = cdEnabledNew;
3950  					else if (!lstrcmp(val, TEXT("auto")))
3951  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate);
3952  					else if (!lstrcmp(val, TEXT("Update2End")))
3953  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdGo2end);
3954  					else if (!lstrcmp(val, TEXT("autoUpdate2End")))
3955  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate | cdGo2end);
3956  					else 
3957  						_nppGUI._fileAutoDetection = cdDisabled;
3958  				}
3959  			}
3960  		}
3961  		else if (!lstrcmp(nm, TEXT("TrayIcon")))
3962  		{
3963  			TiXmlNode *n = childNode->FirstChild();
3964  			if (n)
3965  			{
3966  				const TCHAR* val = n->Value();
3967  				if (val)
3968  				{
3969  					_nppGUI._isMinimizedToTray = (lstrcmp(val, TEXT("yes")) == 0);
3970  				}
3971  			}
3972  		}
3973  		else if (!lstrcmp(nm, TEXT("RememberLastSession")))
3974  		{
3975  			TiXmlNode *n = childNode->FirstChild();
3976  			if (n)
3977  			{
3978  				const TCHAR* val = n->Value();
3979  				if (val)
3980  				{
3981  					if (lstrcmp(val, TEXT("yes")) == 0)
3982  						_nppGUI._rememberLastSession = true;
3983  					else
3984  						_nppGUI._rememberLastSession = false;
3985  				}
3986  			}
3987  		}
3988  		else if (!lstrcmp(nm, TEXT("DetectEncoding")))
3989  		{
3990  			TiXmlNode *n = childNode->FirstChild();
3991  			if (n)
3992  			{
3993  				const TCHAR* val = n->Value();
3994  				if (val)
3995  				{
3996  					if (lstrcmp(val, TEXT("yes")) == 0)
3997  						_nppGUI._detectEncoding = true;
3998  					else
3999  						_nppGUI._detectEncoding = false;
4000  				}
4001  			}
4002  		}
4003  		else if (!lstrcmp(nm, TEXT("SaveAllConfirm")))
4004  		{
4005  			TiXmlNode *n = childNode->FirstChild();
4006  			if (n)
4007  			{
4008  				const TCHAR* val = n->Value();
4009  				if (val)
4010  				{
4011  					if (lstrcmp(val, TEXT("yes")) == 0)
4012  						_nppGUI._saveAllConfirm = true;
4013  					else
4014  						_nppGUI._saveAllConfirm = false;
4015  				}
4016  			}
4017  		}
4018  		else if (lstrcmp(nm, TEXT("MaitainIndent")) == 0)
4019  		{
4020  			TiXmlNode *n = childNode->FirstChild();
4021  			if (n)
4022  			{
4023  				const TCHAR* val = n->Value();
4024  				if (val)
4025  				{
4026  					if (lstrcmp(val, TEXT("yes")) == 0)
4027  						_nppGUI._maitainIndent = true;
4028  					else
4029  						_nppGUI._maitainIndent = false;
4030  				}
4031  			}
4032  		}
4033  		else if (!lstrcmp(nm, TEXT("MarkAll")))
4034  		{
4035  			const TCHAR* val = element->Attribute(TEXT("matchCase"));
4036  			if (val)
4037  			{
4038  				if (lstrcmp(val, TEXT("yes")) == 0)
4039  					_nppGUI._markAllCaseSensitive = true;
4040  				else if (!lstrcmp(val, TEXT("no")))
4041  					_nppGUI._markAllCaseSensitive = false;
4042  			}
4043  			val = element->Attribute(TEXT("wholeWordOnly"));
4044  			if (val)
4045  			{
4046  				if (lstrcmp(val, TEXT("yes")) == 0)
4047  					_nppGUI._markAllWordOnly = true;
4048  				else if (!lstrcmp(val, TEXT("no")))
4049  					_nppGUI._markAllWordOnly = false;
4050  			}
4051  		}
4052  		else if (!lstrcmp(nm, TEXT("SmartHighLight")))
4053  		{
4054  			TiXmlNode *n = childNode->FirstChild();
4055  			if (n)
4056  			{
4057  				const TCHAR* val = n->Value();
4058  				if (val)
4059  				{
4060  					if (lstrcmp(val, TEXT("yes")) == 0)
4061  						_nppGUI._enableSmartHilite = true;
4062  					else
4063  						_nppGUI._enableSmartHilite = false;
4064  				}
4065  				val = element->Attribute(TEXT("matchCase"));
4066  				if (val)
4067  				{
4068  					if (lstrcmp(val, TEXT("yes")) == 0)
4069  						_nppGUI._smartHiliteCaseSensitive = true;
4070  					else if (!lstrcmp(val, TEXT("no")))
4071  						_nppGUI._smartHiliteCaseSensitive = false;
4072  				}
4073  				val = element->Attribute(TEXT("wholeWordOnly"));
4074  				if (val)
4075  				{
4076  					if (lstrcmp(val, TEXT("yes")) == 0)
4077  						_nppGUI._smartHiliteWordOnly = true;
4078  					else if (!lstrcmp(val, TEXT("no")))
4079  						_nppGUI._smartHiliteWordOnly = false;
4080  				}
4081  				val = element->Attribute(TEXT("useFindSettings"));
4082  				if (val)
4083  				{
4084  					if (lstrcmp(val, TEXT("yes")) == 0)
4085  						_nppGUI._smartHiliteUseFindSettings = true;
4086  					else if (!lstrcmp(val, TEXT("no")))
4087  						_nppGUI._smartHiliteUseFindSettings = false;
4088  				}
4089  				val = element->Attribute(TEXT("onAnotherView"));
4090  				if (val)
4091  				{
4092  					if (lstrcmp(val, TEXT("yes")) == 0)
4093  						_nppGUI._smartHiliteOnAnotherView = true;
4094  					else if (!lstrcmp(val, TEXT("no")))
4095  						_nppGUI._smartHiliteOnAnotherView = false;
4096  				}
4097  			}
4098  		}
4099  		else if (!lstrcmp(nm, TEXT("TagsMatchHighLight")))
4100  		{
4101  			TiXmlNode *n = childNode->FirstChild();
4102  			if (n)
4103  			{
4104  				const TCHAR* val = n->Value();
4105  				if (val)
4106  				{
4107  					_nppGUI._enableTagsMatchHilite = !lstrcmp(val, TEXT("yes"));
4108  					const TCHAR *tahl = element->Attribute(TEXT("TagAttrHighLight"));
4109  					if (tahl)
4110  						_nppGUI._enableTagAttrsHilite = !lstrcmp(tahl, TEXT("yes"));
4111  					tahl = element->Attribute(TEXT("HighLightNonHtmlZone"));
4112  					if (tahl)
4113  						_nppGUI._enableHiliteNonHTMLZone = !lstrcmp(tahl, TEXT("yes"));
4114  				}
4115  			}
4116  		}
4117  		else if (!lstrcmp(nm, TEXT("TaskList")))
4118  		{
4119  			TiXmlNode *n = childNode->FirstChild();
4120  			if (n)
4121  			{
4122  				const TCHAR* val = n->Value();
4123  				if (val)
4124  				{
4125  					_nppGUI._doTaskList = (!lstrcmp(val, TEXT("yes")))?true:false;
4126  				}
4127  			}
4128  		}
4129  		else if (!lstrcmp(nm, TEXT("MRU")))
4130  		{
4131  			TiXmlNode *n = childNode->FirstChild();
4132  			if (n)
4133  			{
4134  				const TCHAR* val = n->Value();
4135  				if (val)
4136  					_nppGUI._styleMRU = (!lstrcmp(val, TEXT("yes")));
4137  			}
4138  		}
4139  		else if (!lstrcmp(nm, TEXT("URL")))
4140  		{
4141  			TiXmlNode *n = childNode->FirstChild();
4142  			if (n)
4143  			{
4144  				const TCHAR* val = n->Value();
4145  				if (val)
4146  				{
4147  					int const i = _wtoi (val);
4148  					if ((i >= urlMin) && (i <= urlMax))
4149  						_nppGUI._styleURL = urlMode(i);
4150  				}
4151  			}
4152  		}
4153  		else if (!lstrcmp(nm, TEXT("uriCustomizedSchemes")))
4154  		{
4155  			TiXmlNode *n = childNode->FirstChild();
4156  			if (n)
4157  			{
4158  				const TCHAR* val = n->Value();
4159  				if (val)
4160  				_nppGUI._uriSchemes = val;
4161  			}
4162  		}
4163  		else if (!lstrcmp(nm, TEXT("CheckHistoryFiles")))
4164  		{
4165  			TiXmlNode *n = childNode->FirstChild();
4166  			if (n)
4167  			{
4168  				const TCHAR* val = n->Value();
4169  				if (val)
4170  				{
4171  					if (!lstrcmp(val, TEXT("no")))
4172  						_nppGUI._checkHistoryFiles = false;
4173  					else if (!lstrcmp(val, TEXT("yes")))
4174  						_nppGUI._checkHistoryFiles = true;
4175  				}
4176  			}
4177  		}
4178  		else if (!lstrcmp(nm, TEXT("ScintillaViewsSplitter")))
4179  		{
4180  			TiXmlNode *n = childNode->FirstChild();
4181  			if (n)
4182  			{
4183  				const TCHAR* val = n->Value();
4184  				if (val)
4185  				{
4186  					if (!lstrcmp(val, TEXT("vertical")))
4187  						_nppGUI._splitterPos = POS_VERTICAL;
4188  					else if (!lstrcmp(val, TEXT("horizontal")))
4189  						_nppGUI._splitterPos = POS_HORIZOTAL;
4190  				}
4191  			}
4192  		}
4193  		else if (!lstrcmp(nm, TEXT("UserDefineDlg")))
4194  		{
4195  			bool isFailed = false;
4196  			int oldValue = _nppGUI._userDefineDlgStatus;
4197  			TiXmlNode *n = childNode->FirstChild();
4198  			if (n)
4199  			{
4200  				const TCHAR* val = n->Value();
4201  				if (val)
4202  				{
4203  					if (!lstrcmp(val, TEXT("hide")))
4204  						_nppGUI._userDefineDlgStatus = 0;
4205  					else if (!lstrcmp(val, TEXT("show")))
4206  						_nppGUI._userDefineDlgStatus = UDD_SHOW;
4207  					else
4208  						isFailed = true;
4209  				}
4210  			}
4211  			const TCHAR* val = element->Attribute(TEXT("position"));
4212  			if (val)
4213  			{
4214  				if (!lstrcmp(val, TEXT("docked")))
4215  					_nppGUI._userDefineDlgStatus |= UDD_DOCKED;
4216  				else if (!lstrcmp(val, TEXT("undocked")))
4217  					_nppGUI._userDefineDlgStatus |= 0;
4218  				else
4219  					isFailed = true;
4220  			}
4221  			if (isFailed)
4222  				_nppGUI._userDefineDlgStatus = oldValue;
4223  		}
4224  		else if (!lstrcmp(nm, TEXT("TabSetting")))
4225  		{
4226  			int i;
4227  			const TCHAR* val = element->Attribute(TEXT("size"), &i);
4228  			if (val)
4229  				_nppGUI._tabSize = i;
4230  			if ((_nppGUI._tabSize == -1) || (_nppGUI._tabSize == 0))
4231  				_nppGUI._tabSize = 4;
4232  			val = element->Attribute(TEXT("replaceBySpace"));
4233  			if (val)
4234  				_nppGUI._tabReplacedBySpace = (!lstrcmp(val, TEXT("yes")));
4235  		}
4236  		else if (!lstrcmp(nm, TEXT("Caret")))
4237  		{
4238  			int i;
4239  			const TCHAR* val = element->Attribute(TEXT("width"), &i);
4240  			if (val)
4241  				_nppGUI._caretWidth = i;
4242  			val = element->Attribute(TEXT("blinkRate"), &i);
4243  			if (val)
4244  				_nppGUI._caretBlinkRate = i;
4245  		}
4246  		else if (!lstrcmp(nm, TEXT("ScintillaGlobalSettings")))
4247  		{
4248  			const TCHAR* val = element->Attribute(TEXT("enableMultiSelection"));
4249  			if (val)
4250  			{
4251  				if (lstrcmp(val, TEXT("yes")) == 0)
4252  					_nppGUI._enableMultiSelection = true;
4253  				else if (lstrcmp(val, TEXT("no")) == 0)
4254  					_nppGUI._enableMultiSelection = false;
4255  			}
4256  		}
4257  		else if (!lstrcmp(nm, TEXT("AppPosition")))
4258  		{
4259  			RECT oldRect = _nppGUI._appPos;
4260  			bool fuckUp = true;
4261  			int i;
4262  			if (element->Attribute(TEXT("x"), &i))
4263  			{
4264  				_nppGUI._appPos.left = i;
4265  				if (element->Attribute(TEXT("y"), &i))
4266  				{
4267  					_nppGUI._appPos.top = i;
4268  					if (element->Attribute(TEXT("width"), &i))
4269  					{
4270  						_nppGUI._appPos.right = i;
4271  						if (element->Attribute(TEXT("height"), &i))
4272  						{
4273  							_nppGUI._appPos.bottom = i;
4274  							fuckUp = false;
4275  						}
4276  					}
4277  				}
4278  			}
4279  			if (fuckUp)
4280  				_nppGUI._appPos = oldRect;
4281  			const TCHAR* val = element->Attribute(TEXT("isMaximized"));
4282  			if (val)
4283  				_nppGUI._isMaximized = (lstrcmp(val, TEXT("yes")) == 0);
4284  		}
4285  		else if (!lstrcmp(nm, TEXT("FindWindowPosition")))
4286  		{
4287  			RECT oldRect = _nppGUI._findWindowPos;
4288  			bool incomplete = true;
4289  			int i;
4290  			if (element->Attribute(TEXT("left"), &i))
4291  			{
4292  				_nppGUI._findWindowPos.left = i;
4293  				if (element->Attribute(TEXT("top"), &i))
4294  				{
4295  					_nppGUI._findWindowPos.top = i;
4296  					if (element->Attribute(TEXT("right"), &i))
4297  					{
4298  						_nppGUI._findWindowPos.right = i;
4299  						if (element->Attribute(TEXT("bottom"), &i))
4300  						{
4301  							_nppGUI._findWindowPos.bottom = i;
4302  							incomplete = false;
4303  						}
4304  					}
4305  				}
4306  			}
4307  			if (incomplete)
4308  			{
4309  				_nppGUI._findWindowPos = oldRect;
4310  			}
4311  			const TCHAR* val = element->Attribute(TEXT("isLessModeOn"));
4312  			if (val)
4313  				_nppGUI._findWindowLessMode = (lstrcmp(val, TEXT("yes")) == 0);
4314  		}
4315  		else if (!lstrcmp(nm, TEXT("FinderConfig")))
4316  		{
4317  			const TCHAR* val = element->Attribute(TEXT("wrappedLines"));
4318  			if (val)
4319  			{
4320  				_nppGUI._finderLinesAreCurrentlyWrapped = (!lstrcmp(val, TEXT("yes")));
4321  			}
4322  			val = element->Attribute(TEXT("purgeBeforeEverySearch"));
4323  			if (val)
4324  			{
4325  				_nppGUI._finderPurgeBeforeEverySearch = (!lstrcmp(val, TEXT("yes")));
4326  			}
4327  			val = element->Attribute(TEXT("showOnlyOneEntryPerFoundLine"));
4328  			if (val)
4329  			{
4330  				_nppGUI._finderShowOnlyOneEntryPerFoundLine = (!lstrcmp(val, TEXT("yes")));
4331  			}
4332  		}
4333  		else if (!lstrcmp(nm, TEXT("NewDocDefaultSettings")))
4334  		{
4335  			int i;
4336  			if (element->Attribute(TEXT("format"), &i))
4337  			{
4338  				EolType newFormat = EolType::osdefault;
4339  				switch (i)
4340  				{
4341  					case static_cast<LPARAM>(EolType::windows) :
4342  						newFormat = EolType::windows;
4343  						break;
4344  					case static_cast<LPARAM>(EolType::macos) :
4345  						newFormat = EolType::macos;
4346  						break;
4347  					case static_cast<LPARAM>(EolType::unix) :
4348  						newFormat = EolType::unix;
4349  						break;
4350  					default:
4351  						assert(false and "invalid buffer format - fallback to default");
4352  				}
4353  				_nppGUI._newDocDefaultSettings._format = newFormat;
4354  			}
4355  			if (element->Attribute(TEXT("encoding"), &i))
4356  				_nppGUI._newDocDefaultSettings._unicodeMode = (UniMode)i;
4357  			if (element->Attribute(TEXT("lang"), &i))
4358  				_nppGUI._newDocDefaultSettings._lang = (LangType)i;
4359  			if (element->Attribute(TEXT("codepage"), &i))
4360  				_nppGUI._newDocDefaultSettings._codepage = (LangType)i;
4361  			const TCHAR* val = element->Attribute(TEXT("openAnsiAsUTF8"));
4362  			if (val)
4363  				_nppGUI._newDocDefaultSettings._openAnsiAsUtf8 = (lstrcmp(val, TEXT("yes")) == 0);
4364  			val = element->Attribute(TEXT("addNewDocumentOnStartup"));
4365  			if (val)
4366  				_nppGUI._newDocDefaultSettings._addNewDocumentOnStartup = (lstrcmp(val, TEXT("yes")) == 0);
4367  		}
4368  		else if (!lstrcmp(nm, TEXT("langsExcluded")))
4369  		{
4370  			int g0 = 0; 
4371  			int g1 = 0; 
4372  			int g2 = 0; 
4373  			int g3 = 0; 
4374  			int g4 = 0; 
4375  			int g5 = 0; 
4376  			int g6 = 0; 
4377  			int g7 = 0; 
4378  			int g8 = 0; 
4379  			int g9 = 0; 
4380  			int g10= 0; 
4381  			int g11= 0; 
4382  			int g12= 0; 
4383  			{
4384  				int i;
4385  				if (element->Attribute(TEXT("gr0"), &i))
4386  				{
4387  					if (i <= 255)
4388  						g0 = i;
4389  				}
4390  				if (element->Attribute(TEXT("gr1"), &i))
4391  				{
4392  					if (i <= 255)
4393  						g1 = i;
4394  				}
4395  				if (element->Attribute(TEXT("gr2"), &i))
4396  				{
4397  					if (i <= 255)
4398  						g2 = i;
4399  				}
4400  				if (element->Attribute(TEXT("gr3"), &i))
4401  				{
4402  					if (i <= 255)
4403  						g3 = i;
4404  				}
4405  				if (element->Attribute(TEXT("gr4"), &i))
4406  				{
4407  					if (i <= 255)
4408  						g4 = i;
4409  				}
4410  				if (element->Attribute(TEXT("gr5"), &i))
4411  				{
4412  					if (i <= 255)
4413  						g5 = i;
4414  				}
4415  				if (element->Attribute(TEXT("gr6"), &i))
4416  				{
4417  					if (i <= 255)
4418  						g6 = i;
4419  				}
4420  				if (element->Attribute(TEXT("gr7"), &i))
4421  				{
4422  					if (i <= 255)
4423  						g7 = i;
4424  				}
4425  				if (element->Attribute(TEXT("gr8"), &i))
4426  				{
4427  					if (i <= 255)
4428  						g8 = i;
4429  				}
4430  				if (element->Attribute(TEXT("gr9"), &i))
4431  				{
4432  					if (i <= 255)
4433  						g9 = i;
4434  				}
4435  				if (element->Attribute(TEXT("gr10"), &i))
4436  				{
4437  					if (i <= 255)
4438  						g10 = i;
4439  				}
4440  				if (element->Attribute(TEXT("gr11"), &i))
4441  				{
4442  					if (i <= 255)
4443  						g11 = i;
4444  				}
4445  				if (element->Attribute(TEXT("gr12"), &i))
4446  				{
4447  					if (i <= 255)
4448  						g12 = i;
4449  				}
4450  			}
4451  			UCHAR mask = 1;
4452  			for (int i = 0 ; i < 8 ; ++i)
4453  			{
4454  				if (mask & g0)
4455  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4456  				mask <<= 1;
4457  			}
4458  			mask = 1;
4459  			for (int i = 8 ; i < 16 ; ++i)
4460  			{
4461  				if (mask & g1)
4462  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4463  				mask <<= 1;
4464  			}
4465  			mask = 1;
4466  			for (int i = 16 ; i < 24 ; ++i)
4467  			{
4468  				if (mask & g2)
4469  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4470  				mask <<= 1;
4471  			}
4472  			mask = 1;
4473  			for (int i = 24 ; i < 32 ; ++i)
4474  			{
4475  				if (mask & g3)
4476  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4477  				mask <<= 1;
4478  			}
4479  			mask = 1;
4480  			for (int i = 32 ; i < 40 ; ++i)
4481  			{
4482  				if (mask & g4)
4483  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4484  				mask <<= 1;
4485  			}
4486  			mask = 1;
4487  			for (int i = 40 ; i < 48 ; ++i)
4488  			{
4489  				if (mask & g5)
4490  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4491  				mask <<= 1;
4492  			}
4493  			mask = 1;
4494  			for (int i = 48 ; i < 56 ; ++i)
4495  			{
4496  				if (mask & g6)
4497  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4498  				mask <<= 1;
4499  			}
4500  			mask = 1;
4501  			for (int i = 56 ; i < 64 ; ++i)
4502  			{
4503  				if (mask & g7)
4504  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4505  				mask <<= 1;
4506  			}
4507  			mask = 1;
4508  			for (int i = 64; i < 72; ++i)
4509  			{
4510  				if (mask & g8)
4511  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4512  				mask <<= 1;
4513  			}
4514  			mask = 1;
4515  			for (int i = 72; i < 80; ++i)
4516  			{
4517  				if (mask & g9)
4518  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4519  				mask <<= 1;
4520  			}
4521  			mask = 1;
4522  			for (int i = 80; i < 88; ++i)
4523  			{
4524  				if (mask & g10)
4525  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4526  				mask <<= 1;
4527  			}
4528  			mask = 1;
4529  			for (int i = 88; i < 96; ++i)
4530  			{
4531  				if (mask & g11)
4532  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4533  				mask <<= 1;
4534  			}
4535  			mask = 1;
4536  			for (int i = 96; i < 104; ++i)
4537  			{
4538  				if (mask & g12)
4539  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4540  				mask <<= 1;
4541  			}
4542  			const TCHAR* val = element->Attribute(TEXT("langMenuCompact"));
4543  			if (val)
4544  				_nppGUI._isLangMenuCompact = (!lstrcmp(val, TEXT("yes")));
4545  		}
4546  		else if (!lstrcmp(nm, TEXT("Print")))
4547  		{
4548  			const TCHAR* val = element->Attribute(TEXT("lineNumber"));
4549  			if (val)
4550  				_nppGUI._printSettings._printLineNumber = (!lstrcmp(val, TEXT("yes")));
4551  			int i;
4552  			if (element->Attribute(TEXT("printOption"), &i))
4553  				_nppGUI._printSettings._printOption = i;
4554  			val = element->Attribute(TEXT("headerLeft"));
4555  			if (val)
4556  				_nppGUI._printSettings._headerLeft = val;
4557  			val = element->Attribute(TEXT("headerMiddle"));
4558  			if (val)
4559  				_nppGUI._printSettings._headerMiddle = val;
4560  			val = element->Attribute(TEXT("headerRight"));
4561  			if (val)
4562  				_nppGUI._printSettings._headerRight = val;
4563  			val = element->Attribute(TEXT("footerLeft"));
4564  			if (val)
4565  				_nppGUI._printSettings._footerLeft = val;
4566  			val = element->Attribute(TEXT("footerMiddle"));
4567  			if (val)
4568  				_nppGUI._printSettings._footerMiddle = val;
4569  			val = element->Attribute(TEXT("footerRight"));
4570  			if (val)
4571  				_nppGUI._printSettings._footerRight = val;
4572  			val = element->Attribute(TEXT("headerFontName"));
4573  			if (val)
4574  				_nppGUI._printSettings._headerFontName = val;
4575  			val = element->Attribute(TEXT("footerFontName"));
4576  			if (val)
4577  				_nppGUI._printSettings._footerFontName = val;
4578  			if (element->Attribute(TEXT("headerFontStyle"), &i))
4579  				_nppGUI._printSettings._headerFontStyle = i;
4580  			if (element->Attribute(TEXT("footerFontStyle"), &i))
4581  				_nppGUI._printSettings._footerFontStyle = i;
4582  			if (element->Attribute(TEXT("headerFontSize"), &i))
4583  				_nppGUI._printSettings._headerFontSize = i;
4584  			if (element->Attribute(TEXT("footerFontSize"), &i))
4585  				_nppGUI._printSettings._footerFontSize = i;
4586  			if (element->Attribute(TEXT("margeLeft"), &i))
4587  				_nppGUI._printSettings._marge.left = i;
4588  			if (element->Attribute(TEXT("margeTop"), &i))
4589  				_nppGUI._printSettings._marge.top = i;
4590  			if (element->Attribute(TEXT("margeRight"), &i))
4591  				_nppGUI._printSettings._marge.right = i;
4592  			if (element->Attribute(TEXT("margeBottom"), &i))
4593  				_nppGUI._printSettings._marge.bottom = i;
4594  		}
4595  		else if (!lstrcmp(nm, TEXT("ScintillaPrimaryView")))
4596  		{
4597  			feedScintillaParam(element);
4598  		}
4599  		else if (!lstrcmp(nm, TEXT("Backup")))
4600  		{
4601  			int i;
4602  			if (element->Attribute(TEXT("action"), &i))
4603  				_nppGUI._backup = (BackupFeature)i;
4604  			const TCHAR *bDir = element->Attribute(TEXT("useCustumDir"));
4605  			if (bDir)
4606  			{
4607  				_nppGUI._useDir = (lstrcmp(bDir, TEXT("yes")) == 0);
4608  			}
4609  			const TCHAR *pDir = element->Attribute(TEXT("dir"));
4610  			if (pDir)
4611  				_nppGUI._backupDir = pDir;
4612  			const TCHAR *isSnapshotModeStr = element->Attribute(TEXT("isSnapshotMode"));
4613  			if (isSnapshotModeStr && !lstrcmp(isSnapshotModeStr, TEXT("no")))
4614  				_nppGUI._isSnapshotMode = false;
4615  			int timing;
4616  			if (element->Attribute(TEXT("snapshotBackupTiming"), &timing))
4617  				_nppGUI._snapshotBackupTiming = timing;
4618  		}
4619  		else if (!lstrcmp(nm, TEXT("DockingManager")))
4620  		{
4621  			feedDockingManager(element);
4622  		}
4623  		else if (!lstrcmp(nm, TEXT("globalOverride")))
4624  		{
4625  			const TCHAR *bDir = element->Attribute(TEXT("fg"));
4626  			if (bDir)
4627  				_nppGUI._globalOverride.enableFg = (lstrcmp(bDir, TEXT("yes")) == 0);
4628  			bDir = element->Attribute(TEXT("bg"));
4629  			if (bDir)
4630  				_nppGUI._globalOverride.enableBg = (lstrcmp(bDir, TEXT("yes")) == 0);
4631  			bDir = element->Attribute(TEXT("font"));
4632  			if (bDir)
4633  				_nppGUI._globalOverride.enableFont = (lstrcmp(bDir, TEXT("yes")) == 0);
4634  			bDir = element->Attribute(TEXT("fontSize"));
4635  			if (bDir)
4636  				_nppGUI._globalOverride.enableFontSize = (lstrcmp(bDir, TEXT("yes")) == 0);
4637  			bDir = element->Attribute(TEXT("bold"));
4638  			if (bDir)
4639  				_nppGUI._globalOverride.enableBold = (lstrcmp(bDir, TEXT("yes")) == 0);
4640  			bDir = element->Attribute(TEXT("italic"));
4641  			if (bDir)
4642  				_nppGUI._globalOverride.enableItalic = (lstrcmp(bDir, TEXT("yes")) == 0);
4643  			bDir = element->Attribute(TEXT("underline"));
4644  			if (bDir)
4645  				_nppGUI._globalOverride.enableUnderLine = (lstrcmp(bDir, TEXT("yes")) == 0);
4646  		}
4647  		else if (!lstrcmp(nm, TEXT("auto-completion")))
4648  		{
4649  			int i;
4650  			if (element->Attribute(TEXT("autoCAction"), &i))
4651  				_nppGUI._autocStatus = static_cast<NppGUI::AutocStatus>(i);
4652  			if (element->Attribute(TEXT("triggerFromNbChar"), &i))
4653  				_nppGUI._autocFromLen = i;
4654  			const TCHAR * optName = element->Attribute(TEXT("autoCIgnoreNumbers"));
4655  			if (optName)
4656  				_nppGUI._autocIgnoreNumbers = (lstrcmp(optName, TEXT("yes")) == 0);
4657  			optName = element->Attribute(TEXT("insertSelectedItemUseENTER"));
4658  			if (optName)
4659  				_nppGUI._autocInsertSelectedUseENTER = (lstrcmp(optName, TEXT("yes")) == 0);
4660  			optName = element->Attribute(TEXT("insertSelectedItemUseTAB"));
4661  			if (optName)
4662  				_nppGUI._autocInsertSelectedUseTAB = (lstrcmp(optName, TEXT("yes")) == 0);
4663  			optName = element->Attribute(TEXT("autoCBrief"));
4664  			if (optName)
4665  				_nppGUI._autocBrief = (lstrcmp(optName, TEXT("yes")) == 0);
4666  			optName = element->Attribute(TEXT("funcParams"));
4667  			if (optName)
4668  				_nppGUI._funcParams = (lstrcmp(optName, TEXT("yes")) == 0);
4669  		}
4670  		else if (!lstrcmp(nm, TEXT("auto-insert")))
4671  		{
4672  			const TCHAR * optName = element->Attribute(TEXT("htmlXmlTag"));
4673  			if (optName)
4674  				_nppGUI._matchedPairConf._doHtmlXmlTag = (lstrcmp(optName, TEXT("yes")) == 0);
4675  			optName = element->Attribute(TEXT("parentheses"));
4676  			if (optName)
4677  				_nppGUI._matchedPairConf._doParentheses = (lstrcmp(optName, TEXT("yes")) == 0);
4678  			optName = element->Attribute(TEXT("brackets"));
4679  			if (optName)
4680  				_nppGUI._matchedPairConf._doBrackets = (lstrcmp(optName, TEXT("yes")) == 0);
4681  			optName = element->Attribute(TEXT("curlyBrackets"));
4682  			if (optName)
4683  				_nppGUI._matchedPairConf._doCurlyBrackets = (lstrcmp(optName, TEXT("yes")) == 0);
4684  			optName = element->Attribute(TEXT("quotes"));
4685  			if (optName)
4686  				_nppGUI._matchedPairConf._doQuotes = (lstrcmp(optName, TEXT("yes")) == 0);
4687  			optName = element->Attribute(TEXT("doubleQuotes"));
4688  			if (optName)
4689  				_nppGUI._matchedPairConf._doDoubleQuotes = (lstrcmp(optName, TEXT("yes")) == 0);
4690  			for (TiXmlNode *subChildNode = childNode->FirstChildElement(TEXT("UserDefinePair"));
4691  				 subChildNode;
4692  				 subChildNode = subChildNode->NextSibling(TEXT("UserDefinePair")) )
4693  			{
4694  				int open = -1;
4695  				int openVal = 0;
4696  				const TCHAR *openValStr = (subChildNode->ToElement())->Attribute(TEXT("open"), &openVal);
4697  				if (openValStr && (openVal >= 0 && openVal < 128))
4698  					open = openVal;
4699  				int close = -1;
4700  				int closeVal = 0;
4701  				const TCHAR *closeValStr = (subChildNode->ToElement())->Attribute(TEXT("close"), &closeVal);
4702  				if (closeValStr && (closeVal >= 0 && closeVal <= 128))
4703  					close = closeVal;
4704  				if (open != -1 && close != -1)
4705  					_nppGUI._matchedPairConf._matchedPairsInit.push_back(pair<char, char>(char(open), char(close)));
4706  			}
4707  		}
4708  		else if (!lstrcmp(nm, TEXT("sessionExt")))
4709  		{
4710  			TiXmlNode *n = childNode->FirstChild();
4711  			if (n)
4712  			{
4713  				const TCHAR* val = n->Value();
4714  				if (val)
4715  					_nppGUI._definedSessionExt = val;
4716  			}
4717  		}
4718  		else if (!lstrcmp(nm, TEXT("workspaceExt")))
4719  		{
4720  			TiXmlNode *n = childNode->FirstChild();
4721  			if (n)
4722  			{
4723  				const TCHAR* val = n->Value();
4724  				if (val)
4725  					_nppGUI._definedWorkspaceExt = val;
4726  			}
4727  		}
4728  		else if (!lstrcmp(nm, TEXT("noUpdate")))
4729  		{
4730  			TiXmlNode *n = childNode->FirstChild();
4731  			if (n)
4732  			{
4733  				const TCHAR* val = n->Value();
4734  				if (val)
4735  					_nppGUI._autoUpdateOpt._doAutoUpdate = (!lstrcmp(val, TEXT("yes")))?false:true;
4736  				int i;
4737  				val = element->Attribute(TEXT("intervalDays"), &i);
4738  				if (val)
4739  					_nppGUI._autoUpdateOpt._intervalDays = i;
4740  				val = element->Attribute(TEXT("nextUpdateDate"));
4741  				if (val)
4742  					_nppGUI._autoUpdateOpt._nextUpdateDate = Date(val);
4743  			}
4744  		}
4745  		else if (!lstrcmp(nm, TEXT("openSaveDir")))
4746  		{
4747  			const TCHAR * value = element->Attribute(TEXT("value"));
4748  			if (value && value[0])
4749  			{
4750  				if (lstrcmp(value, TEXT("1")) == 0)
4751  					_nppGUI._openSaveDir = dir_last;
4752  				else if (lstrcmp(value, TEXT("2")) == 0)
4753  					_nppGUI._openSaveDir = dir_userDef;
4754  				else
4755  					_nppGUI._openSaveDir = dir_followCurrent;
4756  			}
4757  			const TCHAR * path = element->Attribute(TEXT("defaultDirPath"));
4758  			if (path && path[0])
4759  			{
4760  				lstrcpyn(_nppGUI._defaultDir, path, MAX_PATH);
4761  				::ExpandEnvironmentStrings(_nppGUI._defaultDir, _nppGUI._defaultDirExp, MAX_PATH);
4762  			}
4763   		}
4764  		else if (!lstrcmp(nm, TEXT("titleBar")))
4765  		{
4766  			const TCHAR * value = element->Attribute(TEXT("short"));
4767  			_nppGUI._shortTitlebar = false;	
4768  			if (value && value[0])
4769  			{
4770  				if (lstrcmp(value, TEXT("yes")) == 0)
4771  					_nppGUI._shortTitlebar = true;
4772  				else if (lstrcmp(value, TEXT("no")) == 0)
4773  					_nppGUI._shortTitlebar = false;
4774  			}
4775  		}
4776  		else if (!lstrcmp(nm, TEXT("insertDateTime")))
4777  		{
4778  			const TCHAR* customFormat = element->Attribute(TEXT("customizedFormat"));
4779  			if (customFormat != NULL && customFormat[0])
4780  				_nppGUI._dateTimeFormat = customFormat;
4781  			const TCHAR* value = element->Attribute(TEXT("reverseDefaultOrder"));
4782  			if (value && value[0])
4783  			{
4784  				if (lstrcmp(value, TEXT("yes")) == 0)
4785  					_nppGUI._dateTimeReverseDefaultOrder = true;
4786  				else if (lstrcmp(value, TEXT("no")) == 0)
4787  					_nppGUI._dateTimeReverseDefaultOrder = false;
4788  			}
4789  		}
4790  		else if (!lstrcmp(nm, TEXT("wordCharList")))
4791  		{
4792  			const TCHAR * value = element->Attribute(TEXT("useDefault"));
4793  			if (value && value[0])
4794  			{
4795  				if (lstrcmp(value, TEXT("yes")) == 0)
4796  					_nppGUI._isWordCharDefault = true;
4797  				else if (lstrcmp(value, TEXT("no")) == 0)
4798  					_nppGUI._isWordCharDefault = false;
4799  			}
4800  			const TCHAR *charsAddedW = element->Attribute(TEXT("charsAdded"));
4801  			if (charsAddedW)
4802  			{
4803  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
4804  				_nppGUI._customWordChars = wmc.wchar2char(charsAddedW, SC_CP_UTF8);
4805  			}
4806  		}
4807  		else if (!lstrcmp(nm, TEXT("delimiterSelection")))
4808  		{
4809  			int leftmost = 0;
4810  			element->Attribute(TEXT("leftmostDelimiter"), &leftmost);
4811  			if (leftmost > 0 && leftmost < 256)
4812  				_nppGUI._leftmostDelimiter = static_cast<char>(leftmost);
4813  			int rightmost = 0;
4814  			element->Attribute(TEXT("rightmostDelimiter"), &rightmost);
4815  			if (rightmost > 0 && rightmost < 256)
4816  				_nppGUI._rightmostDelimiter = static_cast<char>(rightmost);
4817  			const TCHAR *delimiterSelectionOnEntireDocument = element->Attribute(TEXT("delimiterSelectionOnEntireDocument"));
4818  			if (delimiterSelectionOnEntireDocument != NULL && !lstrcmp(delimiterSelectionOnEntireDocument, TEXT("yes")))
4819  				_nppGUI._delimiterSelectionOnEntireDocument = true;
4820  			else
4821  				_nppGUI._delimiterSelectionOnEntireDocument = false;
4822  		}
4823  		else if (!lstrcmp(nm, TEXT("largeFileRestriction")))
4824  		{
4825  			int fileSizeLimit4StylingMB = 0;
4826  			element->Attribute(TEXT("fileSizeMB"), &fileSizeLimit4StylingMB);
4827  			if (fileSizeLimit4StylingMB > 0 && fileSizeLimit4StylingMB <= 4096)
4828  				_nppGUI._largeFileRestriction._largeFileSizeDefInByte = (static_cast<int64_t>(fileSizeLimit4StylingMB) * 1024 * 1024);
4829  			const TCHAR* boolVal = element->Attribute(TEXT("isEnabled"));
4830  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("no")))
4831  				_nppGUI._largeFileRestriction._isEnabled = false;
4832  			else
4833  				_nppGUI._largeFileRestriction._isEnabled = true;
4834  			boolVal = element->Attribute(TEXT("allowAutoCompletion"));
4835  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4836  				_nppGUI._largeFileRestriction._allowAutoCompletion = true;
4837  			else
4838  				_nppGUI._largeFileRestriction._allowAutoCompletion = false;
4839  			boolVal = element->Attribute(TEXT("allowBraceMatch"));
4840  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4841  				_nppGUI._largeFileRestriction._allowBraceMatch = true;
4842  			else
4843  				_nppGUI._largeFileRestriction._allowBraceMatch = false;
4844  			boolVal = element->Attribute(TEXT("allowSmartHilite"));
4845  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4846  				_nppGUI._largeFileRestriction._allowSmartHilite = true;
4847  			else
4848  				_nppGUI._largeFileRestriction._allowSmartHilite = false;
4849  			boolVal = element->Attribute(TEXT("allowClickableLink"));
4850  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4851  				_nppGUI._largeFileRestriction._allowClickableLink = true;
4852  			else
4853  				_nppGUI._largeFileRestriction._allowClickableLink = false;
4854  			boolVal = element->Attribute(TEXT("deactivateWordWrap"));
4855  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("no")))
4856  				_nppGUI._largeFileRestriction._deactivateWordWrap = false;
4857  			else
4858  				_nppGUI._largeFileRestriction._deactivateWordWrap = true;
4859  		}
4860  		else if (!lstrcmp(nm, TEXT("multiInst")))
4861  		{
4862  			int val = 0;
4863  			element->Attribute(TEXT("setting"), &val);
4864  			if (val < 0 || val > 2)
4865  				val = 0;
4866  			_nppGUI._multiInstSetting = (MultiInstSetting)val;
4867  			_nppGUI._clipboardHistoryPanelKeepState = parseYesNoBoolAttribute(TEXT("clipboardHistory"));
4868  			_nppGUI._docListKeepState = parseYesNoBoolAttribute(TEXT("documentList"));
4869  			_nppGUI._charPanelKeepState = parseYesNoBoolAttribute(TEXT("characterPanel"));
4870  			_nppGUI._fileBrowserKeepState = parseYesNoBoolAttribute(TEXT("folderAsWorkspace"));
4871  			_nppGUI._projectPanelKeepState = parseYesNoBoolAttribute(TEXT("projectPanels"));
4872  			_nppGUI._docMapKeepState = parseYesNoBoolAttribute(TEXT("documentMap"));
4873  			_nppGUI._funcListKeepState = parseYesNoBoolAttribute(TEXT("fuctionList"));
4874  			_nppGUI._pluginPanelKeepState = parseYesNoBoolAttribute(TEXT("pluginPanels"));
4875  		}
4876  		else if (!lstrcmp(nm, TEXT("searchEngine")))
4877  		{
4878  			int i;
4879  			if (element->Attribute(TEXT("searchEngineChoice"), &i))
4880  				_nppGUI._searchEngineChoice = static_cast<NppGUI::SearchEngineChoice>(i);
4881  			const TCHAR * searchEngineCustom = element->Attribute(TEXT("searchEngineCustom"));
4882  			if (searchEngineCustom && searchEngineCustom[0])
4883  				_nppGUI._searchEngineCustom = searchEngineCustom;
4884  		}
4885  		else if (!lstrcmp(nm, TEXT("Searching")))
4886  		{
4887  			const TCHAR* optNameMonoFont = element->Attribute(TEXT("monospacedFontFindDlg"));
4888  			if (optNameMonoFont)
4889  				_nppGUI._monospacedFontFindDlg = (lstrcmp(optNameMonoFont, TEXT("yes")) == 0);
4890  			const TCHAR* optStopFillingFindField = element->Attribute(TEXT("stopFillingFindField"));
4891  			if (optStopFillingFindField) 
4892  			{
4893  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optStopFillingFindField, TEXT("no")) == 0);
4894  				_nppGUI._fillFindFieldSelectCaret = _nppGUI._fillFindFieldWithSelected;
4895  			}
4896  			const TCHAR* optFillFindFieldWithSelected = element->Attribute(TEXT("fillFindFieldWithSelected"));
4897  			if (optFillFindFieldWithSelected)
4898  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optFillFindFieldWithSelected, TEXT("yes")) == 0);
4899  			const TCHAR* optFillFindFieldSelectCaret = element->Attribute(TEXT("fillFindFieldSelectCaret"));
4900  			if (optFillFindFieldSelectCaret)
4901  				_nppGUI._fillFindFieldSelectCaret = (lstrcmp(optFillFindFieldSelectCaret, TEXT("yes")) == 0);
4902  			const TCHAR* optFindDlgAlwaysVisible = element->Attribute(TEXT("findDlgAlwaysVisible"));
4903  			if (optFindDlgAlwaysVisible)
4904  				_nppGUI._findDlgAlwaysVisible = (lstrcmp(optFindDlgAlwaysVisible, TEXT("yes")) == 0);
4905  			const TCHAR* optConfirmReplaceOpenDocs = element->Attribute(TEXT("confirmReplaceInAllOpenDocs"));
4906  			if (optConfirmReplaceOpenDocs)
4907  				_nppGUI._confirmReplaceInAllOpenDocs = (lstrcmp(optConfirmReplaceOpenDocs, TEXT("yes")) == 0);
4908  			const TCHAR* optReplaceStopsWithoutFindingNext = element->Attribute(TEXT("replaceStopsWithoutFindingNext"));
4909  			if (optReplaceStopsWithoutFindingNext)
4910  				_nppGUI._replaceStopsWithoutFindingNext = (lstrcmp(optReplaceStopsWithoutFindingNext, TEXT("yes")) == 0);
4911  		}
4912  		else if (!lstrcmp(nm, TEXT("MISC")))
4913  		{
4914  			const TCHAR * optName = element->Attribute(TEXT("fileSwitcherWithoutExtColumn"));
4915  			if (optName)
4916  				_nppGUI._fileSwitcherWithoutExtColumn = (lstrcmp(optName, TEXT("yes")) == 0);
4917  			int i = 0;
4918  			if (element->Attribute(TEXT("fileSwitcherExtWidth"), &i))
4919  				_nppGUI._fileSwitcherExtWidth = i;
4920  			const TCHAR * optNamePath = element->Attribute(TEXT("fileSwitcherWithoutPathColumn"));
4921  			if (optNamePath)
4922  				_nppGUI._fileSwitcherWithoutPathColumn = (lstrcmp(optNamePath, TEXT("yes")) == 0);
4923  			if (element->Attribute(TEXT("fileSwitcherPathWidth"), &i))
4924  				_nppGUI._fileSwitcherPathWidth = i;
4925  			_nppGUI._fileSwitcherDisableListViewGroups = parseYesNoBoolAttribute(TEXT("fileSwitcherNoGroups"));
4926  			const TCHAR * optNameBackSlashEscape = element->Attribute(TEXT("backSlashIsEscapeCharacterForSql"));
4927  			if (optNameBackSlashEscape && !lstrcmp(optNameBackSlashEscape, TEXT("no")))
4928  				_nppGUI._backSlashIsEscapeCharacterForSql = false;
4929  			const TCHAR * optNameWriteTechnologyEngine = element->Attribute(TEXT("writeTechnologyEngine"));
4930  			if (optNameWriteTechnologyEngine)
4931  				_nppGUI._writeTechnologyEngine = (lstrcmp(optNameWriteTechnologyEngine, TEXT("1")) == 0) ? directWriteTechnology : defaultTechnology;
4932  			const TCHAR * optNameFolderDroppedOpenFiles = element->Attribute(TEXT("isFolderDroppedOpenFiles"));
4933  			if (optNameFolderDroppedOpenFiles)
4934  				_nppGUI._isFolderDroppedOpenFiles = (lstrcmp(optNameFolderDroppedOpenFiles, TEXT("yes")) == 0);
4935  			const TCHAR * optDocPeekOnTab = element->Attribute(TEXT("docPeekOnTab"));
4936  			if (optDocPeekOnTab)
4937  				_nppGUI._isDocPeekOnTab = (lstrcmp(optDocPeekOnTab, TEXT("yes")) == 0);
4938  			const TCHAR * optDocPeekOnMap = element->Attribute(TEXT("docPeekOnMap"));
4939  			if (optDocPeekOnMap)
4940  				_nppGUI._isDocPeekOnMap = (lstrcmp(optDocPeekOnMap, TEXT("yes")) == 0);
4941  			const TCHAR* optSortFunctionList = element->Attribute(TEXT("sortFunctionList"));
4942  			if (optSortFunctionList)
4943  				_nppGUI._shouldSortFunctionList = (lstrcmp(optSortFunctionList, TEXT("yes")) == 0);
4944  			const TCHAR* saveDlgExtFilterToAllTypes = element->Attribute(TEXT("saveDlgExtFilterToAllTypes"));
4945  			if (saveDlgExtFilterToAllTypes)
4946  				_nppGUI._setSaveDlgExtFiltToAllTypes = (lstrcmp(saveDlgExtFilterToAllTypes, TEXT("yes")) == 0);
4947  			const TCHAR * optMuteSounds = element->Attribute(TEXT("muteSounds"));
4948  			if (optMuteSounds)
4949  				_nppGUI._muteSounds = lstrcmp(optMuteSounds, TEXT("yes")) == 0;
4950  			const TCHAR * optEnableFoldCmdToggable = element->Attribute(TEXT("enableFoldCmdToggable"));
4951  			if (optEnableFoldCmdToggable)
4952  				_nppGUI._enableFoldCmdToggable = lstrcmp(optEnableFoldCmdToggable, TEXT("yes")) == 0;
4953  			const TCHAR * hideMenuRightShortcuts = element->Attribute(TEXT("hideMenuRightShortcuts"));
4954  			if (hideMenuRightShortcuts)
4955  				_nppGUI._hideMenuRightShortcuts = lstrcmp(hideMenuRightShortcuts, TEXT("yes")) == 0;
4956  		}
4957  		else if (!lstrcmp(nm, TEXT("commandLineInterpreter")))
4958  		{
4959  			TiXmlNode *node = childNode->FirstChild();
4960  			if (node)
4961  			{
4962  				const TCHAR *cli = node->Value();
4963  				if (cli && cli[0])
4964  					_nppGUI._commandLineInterpreter.assign(cli);
4965  			}
4966  		}
4967  		else if (!lstrcmp(nm, TEXT("DarkMode")))
4968  		{
4969  			_nppGUI._darkmode._isEnabled = parseYesNoBoolAttribute(TEXT("enable"));
4970  			int i;
4971  			const TCHAR* val;
4972  			val = element->Attribute(TEXT("colorTone"), &i);
4973  			if (val)
4974  				_nppGUI._darkmode._colorTone = static_cast<NppDarkMode::ColorTone>(i);
4975  			val = element->Attribute(TEXT("customColorTop"), &i);
4976  			if (val)
4977  				_nppGUI._darkmode._customColors.pureBackground = i;
4978  			val = element->Attribute(TEXT("customColorMenuHotTrack"), &i);
4979  			if (val)
4980  				_nppGUI._darkmode._customColors.hotBackground = i;
4981  			val = element->Attribute(TEXT("customColorActive"), &i);
4982  			if (val)
4983  				_nppGUI._darkmode._customColors.softerBackground = i;
4984  			val = element->Attribute(TEXT("customColorMain"), &i);
4985  			if (val)
4986  				_nppGUI._darkmode._customColors.background = i;
4987  			val = element->Attribute(TEXT("customColorError"), &i);
4988  			if (val)
4989  				_nppGUI._darkmode._customColors.errorBackground = i;
4990  			val = element->Attribute(TEXT("customColorText"), &i);
4991  			if (val)
4992  				_nppGUI._darkmode._customColors.text = i;
4993  			val = element->Attribute(TEXT("customColorDarkText"), &i);
4994  			if (val)
4995  				_nppGUI._darkmode._customColors.darkerText = i;
4996  			val = element->Attribute(TEXT("customColorDisabledText"), &i);
4997  			if (val)
4998  				_nppGUI._darkmode._customColors.disabledText = i;
4999  			val = element->Attribute(TEXT("customColorLinkText"), &i);
5000  			if (val)
5001  				_nppGUI._darkmode._customColors.linkText = i;
5002  			val = element->Attribute(TEXT("customColorEdge"), &i);
5003  			if (val)
5004  				_nppGUI._darkmode._customColors.edge = i;
5005  			val = element->Attribute(TEXT("customColorHotEdge"), &i);
5006  			if (val)
5007  				_nppGUI._darkmode._customColors.hotEdge = i;
5008  			val = element->Attribute(TEXT("customColorDisabledEdge"), &i);
5009  			if (val)
5010  				_nppGUI._darkmode._customColors.disabledEdge = i;
5011  			auto parseStringAttribute = [&element](const TCHAR* name, const TCHAR* defaultName = TEXT("")) -> const TCHAR* {
5012  				const TCHAR* val = element->Attribute(name);
5013  				if (val != nullptr && val[0])
5014  				{
5015  					return element->Attribute(name);
5016  				}
5017  				return defaultName;
5018  			};
5019  			auto parseToolBarIconsAttribute = [&element](const TCHAR* name, int defaultValue = -1) -> int {
5020  				int val;
5021  				const TCHAR* valStr = element->Attribute(name, &val);
5022  				if (valStr != nullptr && (val >= 0 && val <= 4))
5023  				{
5024  					return val;
5025  				}
5026  				return defaultValue;
5027  			};
5028  			auto parseTabIconsAttribute = [&element](const TCHAR* name, int defaultValue = -1) -> int {
5029  				int val;
5030  				const TCHAR* valStr = element->Attribute(name, &val);
5031  				if (valStr != nullptr && (val >= 0 && val <= 2))
5032  				{
5033  					return val;
5034  				}
5035  				return defaultValue;
5036  			};
5037  			auto& windowsMode = _nppGUI._darkmode._advOptions._enableWindowsMode;
5038  			windowsMode = parseYesNoBoolAttribute(TEXT("enableWindowsMode"));
5039  			auto& darkDefaults = _nppGUI._darkmode._advOptions._darkDefaults;
5040  			auto& darkThemeName = darkDefaults._xmlFileName;
5041  			darkThemeName = parseStringAttribute(TEXT("darkThemeName"), TEXT("DarkModeDefault.xml"));
5042  			darkDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT("darkToolBarIconSet"), 0);
5043  			darkDefaults._tabIconSet = parseTabIconsAttribute(TEXT("darkTabIconSet"), 2);
5044  			darkDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT("darkTabUseTheme"));
5045  			auto& lightDefaults = _nppGUI._darkmode._advOptions._lightDefaults;
5046  			auto& lightThemeName = lightDefaults._xmlFileName;
5047  			lightThemeName = parseStringAttribute(TEXT("lightThemeName"));
5048  			lightDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT("lightToolBarIconSet"), 4);
5049  			lightDefaults._tabIconSet = parseTabIconsAttribute(TEXT("lightTabIconSet"), 0);
5050  			lightDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT("lightTabUseTheme"), true);
5051  			if (!windowsMode)
5052  			{
5053  				generic_string themePath;
5054  				generic_string xmlFileName = _nppGUI._darkmode._isEnabled ? darkThemeName : lightThemeName;
5055  				const bool isLocalOnly = _isLocal && !_isCloud;
5056  				if (!xmlFileName.empty() && lstrcmp(xmlFileName.c_str(), TEXT("stylers.xml")) != 0)
5057  				{
5058  					themePath = isLocalOnly ? _nppPath : _userPath;
5059  					pathAppend(themePath, TEXT("themes\\"));
5060  					pathAppend(themePath, xmlFileName);
5061  					if (!isLocalOnly && ::PathFileExists(themePath.c_str()) == FALSE)
5062  					{
5063  						themePath = _nppPath;
5064  						pathAppend(themePath, TEXT("themes\\"));
5065  						pathAppend(themePath, xmlFileName);
5066  					}
5067  				}
5068  				else
5069  				{
5070  					themePath = isLocalOnly ? _nppPath : _userPath;
5071  					pathAppend(themePath, TEXT("stylers.xml"));
5072  					if (!isLocalOnly && ::PathFileExists(themePath.c_str()) == FALSE)
5073  					{
5074  						themePath = _nppPath;
5075  						pathAppend(themePath, TEXT("stylers.xml"));
5076  					}
5077  				}
5078  				if (::PathFileExists(themePath.c_str()) == TRUE)
5079  				{
5080  					_nppGUI._themeName.assign(themePath);
5081  				}
5082  			}
5083  		}
5084  	}
5085  }
5086  void NppParameters::feedScintillaParam(TiXmlNode *node)
5087  {
5088  	TiXmlElement* element = node->ToElement();
5089  	auto parseYesNoBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
5090  		const TCHAR* nm = element->Attribute(name);
5091  		if (nm)
5092  		{
5093  			if (!lstrcmp(nm, TEXT("yes")))
5094  				return true;
5095  			else if (!lstrcmp(nm, TEXT("no")))
5096  				return false;
5097  		}
5098  		return defaultValue;
5099  	};
5100  	auto parseShowHideBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
5101  		const TCHAR* nm = element->Attribute(name);
5102  		if (nm)
5103  		{
5104  			if (!lstrcmp(nm, TEXT("show")))
5105  				return true;
5106  			else if (!lstrcmp(nm, TEXT("hide")))
5107  				return false;
5108  		}
5109  		return defaultValue;
5110  	};
5111  	const TCHAR *nm = element->Attribute(TEXT("lineNumberMargin"));
5112  	if (nm)
5113  	{
5114  		if (!lstrcmp(nm, TEXT("show")))
5115  			_svp._lineNumberMarginShow = true;
5116  		else if (!lstrcmp(nm, TEXT("hide")))
5117  			_svp._lineNumberMarginShow = false;
5118  	}
5119  	nm = element->Attribute(TEXT("lineNumberDynamicWidth"));
5120  	if (nm)
5121  	{
5122  		if (!lstrcmp(nm, TEXT("yes")))
5123  			_svp._lineNumberMarginDynamicWidth = true;
5124  		else if (!lstrcmp(nm, TEXT("no")))
5125  			_svp._lineNumberMarginDynamicWidth = false;
5126  	}
5127  	nm = element->Attribute(TEXT("bookMarkMargin"));
5128  	if (nm)
5129  	{
5130  		if (!lstrcmp(nm, TEXT("show")))
5131  			_svp._bookMarkMarginShow = true;
5132  		else if (!lstrcmp(nm, TEXT("hide")))
5133  			_svp._bookMarkMarginShow = false;
5134  	}
5135  	nm = element->Attribute(TEXT("isChangeHistoryEnabled"));
5136  	if (nm)
5137  	{
5138  		if (!lstrcmp(nm, TEXT("yes")))
5139  		{
5140  			_svp._isChangeHistoryEnabled = true;
5141  			_svp._isChangeHistoryEnabled4NextSession = true;
5142  		}
5143  		else if (!lstrcmp(nm, TEXT("no")))
5144  		{
5145  			_svp._isChangeHistoryEnabled = false;
5146  			_svp._isChangeHistoryEnabled4NextSession = false;
5147  		}
5148  	}
5149  	nm = element->Attribute(TEXT("indentGuideLine"));
5150  	if (nm)
5151  	{
5152  		if (!lstrcmp(nm, TEXT("show")))
5153  			_svp._indentGuideLineShow = true;
5154  		else if (!lstrcmp(nm, TEXT("hide")))
5155  			_svp._indentGuideLineShow= false;
5156  	}
5157  	nm = element->Attribute(TEXT("folderMarkStyle"));
5158  	if (nm)
5159  	{
5160  		if (!lstrcmp(nm, TEXT("box")))
5161  			_svp._folderStyle = FOLDER_STYLE_BOX;
5162  		else if (!lstrcmp(nm, TEXT("circle")))
5163  			_svp._folderStyle = FOLDER_STYLE_CIRCLE;
5164  		else if (!lstrcmp(nm, TEXT("arrow")))
5165  			_svp._folderStyle = FOLDER_STYLE_ARROW;
5166  		else if (!lstrcmp(nm, TEXT("simple")))
5167  			_svp._folderStyle = FOLDER_STYLE_SIMPLE;
5168  		else if (!lstrcmp(nm, TEXT("none")))
5169  			_svp._folderStyle = FOLDER_STYLE_NONE;
5170  	}
5171  	nm = element->Attribute(TEXT("lineWrapMethod"));
5172  	if (nm)
5173  	{
5174  		if (!lstrcmp(nm, TEXT("default")))
5175  			_svp._lineWrapMethod = LINEWRAP_DEFAULT;
5176  		else if (!lstrcmp(nm, TEXT("aligned")))
5177  			_svp._lineWrapMethod = LINEWRAP_ALIGNED;
5178  		else if (!lstrcmp(nm, TEXT("indent")))
5179  			_svp._lineWrapMethod = LINEWRAP_INDENT;
5180  	}
5181  	nm = element->Attribute(TEXT("currentLineHilitingShow"));
5182  	if (nm)
5183  	{
5184  		if (!lstrcmp(nm, TEXT("show")))
5185  			_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5186  		else
5187  			_svp._currentLineHiliteMode = LINEHILITE_NONE;
5188  	}
5189  	else
5190  	{
5191  		const TCHAR* currentLineModeStr = element->Attribute(TEXT("currentLineIndicator"));
5192  		if (currentLineModeStr && currentLineModeStr[0])
5193  		{
5194  			if (lstrcmp(currentLineModeStr, TEXT("1")) == 0)
5195  				_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5196  			else if (lstrcmp(currentLineModeStr, TEXT("2")) == 0)
5197  				_svp._currentLineHiliteMode = LINEHILITE_FRAME;
5198  			else
5199  				_svp._currentLineHiliteMode = LINEHILITE_NONE;
5200  		}
5201  	}
5202  	nm = element->Attribute(TEXT("currentLineFrameWidth"));
5203  	if (nm)
5204  	{
5205  		unsigned char frameWidth{ 1 };
5206  		try
5207  		{
5208  			frameWidth = static_cast<unsigned char>(std::stoi(nm));
5209  		}
5210  		catch (...)
5211  		{
5212  		}
5213  		_svp._currentLineFrameWidth = (frameWidth < 1) ? 1 : (frameWidth > 6) ? 6 : frameWidth;
5214  	}
5215  	nm = element->Attribute(TEXT("virtualSpace"));
5216  	if (nm)
5217  	{
5218  		if (!lstrcmp(nm, TEXT("yes")))
5219  			_svp._virtualSpace = true;
5220  		else if (!lstrcmp(nm, TEXT("no")))
5221  			_svp._virtualSpace = false;
5222  	}
5223  	nm = element->Attribute(TEXT("scrollBeyondLastLine"));
5224  	if (nm)
5225  	{
5226  		if (!lstrcmp(nm, TEXT("yes")))
5227  			_svp._scrollBeyondLastLine = true;
5228  		else if (!lstrcmp(nm, TEXT("no")))
5229  			_svp._scrollBeyondLastLine = false;
5230  	}
5231  	nm = element->Attribute(TEXT("rightClickKeepsSelection"));
5232  	if (nm)
5233  	{
5234  		if (!lstrcmp(nm, TEXT("yes")))
5235  			_svp._rightClickKeepsSelection = true;
5236  		else if (!lstrcmp(nm, TEXT("no")))
5237  			_svp._rightClickKeepsSelection = false;
5238  	}
5239  	nm = element->Attribute(TEXT("disableAdvancedScrolling"));
5240  	if (nm)
5241  	{
5242  		if (!lstrcmp(nm, TEXT("yes")))
5243  			_svp._disableAdvancedScrolling = true;
5244  		else if (!lstrcmp(nm, TEXT("no")))
5245  			_svp._disableAdvancedScrolling = false;
5246  	}
5247  	nm = element->Attribute(TEXT("wrapSymbolShow"));
5248  	if (nm)
5249  	{
5250  		if (!lstrcmp(nm, TEXT("show")))
5251  			_svp._wrapSymbolShow = true;
5252  		else if (!lstrcmp(nm, TEXT("hide")))
5253  			_svp._wrapSymbolShow = false;
5254  	}
5255  	nm = element->Attribute(TEXT("Wrap"));
5256  	if (nm)
5257  	{
5258  		if (!lstrcmp(nm, TEXT("yes")))
5259  			_svp._doWrap = true;
5260  		else if (!lstrcmp(nm, TEXT("no")))
5261  			_svp._doWrap = false;
5262  	}
5263  	nm = element->Attribute(TEXT("isEdgeBgMode"));
5264  	if (nm)
5265  	{
5266  		if (!lstrcmp(nm, TEXT("yes")))
5267  			_svp._isEdgeBgMode = true;
5268  		else if (!lstrcmp(nm, TEXT("no")))
5269  			_svp._isEdgeBgMode = false;
5270  	}
5271  	nm = element->Attribute(TEXT("borderEdge"));
5272  	if (nm)
5273  	{
5274  		if (!lstrcmp(nm, TEXT("yes")))
5275  			_svp._showBorderEdge = true;
5276  		else if (!lstrcmp(nm, TEXT("no")))
5277  			_svp._showBorderEdge = false;
5278  	}
5279  	nm = element->Attribute(TEXT("edgeMultiColumnPos"));
5280  	if (nm)
5281  	{
5282  		str2numberVector(nm, _svp._edgeMultiColumnPos);
5283  	}
5284  	int val;
5285  	nm = element->Attribute(TEXT("zoom"), &val);
5286  	if (nm)
5287  	{
5288  		_svp._zoom = val;
5289  	}
5290  	nm = element->Attribute(TEXT("zoom2"), &val);
5291  	if (nm)
5292  	{
5293  		_svp._zoom2 = val;
5294  	}
5295  	nm = element->Attribute(TEXT("whiteSpaceShow"));
5296  	if (nm)
5297  	{
5298  		if (!lstrcmp(nm, TEXT("show")))
5299  			_svp._whiteSpaceShow = true;
5300  		else if (!lstrcmp(nm, TEXT("hide")))
5301  			_svp._whiteSpaceShow = false;
5302  	}
5303  	nm = element->Attribute(TEXT("eolShow"));
5304  	if (nm)
5305  	{
5306  		if (!lstrcmp(nm, TEXT("show")))
5307  			_svp._eolShow = true;
5308  		else if (!lstrcmp(nm, TEXT("hide")))
5309  			_svp._eolShow = false;
5310  	}
5311  	nm = element->Attribute(TEXT("eolMode"), &val);
5312  	if (nm)
5313  	{
5314  		if (val >= 0 && val <= 3)
5315  			_svp._eolMode = static_cast<ScintillaViewParams::crlfMode>(val);
5316  	}
5317  	_svp._npcShow = parseShowHideBoolAttribute(TEXT("npcShow"), true);
5318  	nm = element->Attribute(TEXT("npcMode"), &val);
5319  	if (nm)
5320  	{
5321  		if (val >= 1 && val <= 2)
5322  			_svp._npcMode = static_cast<ScintillaViewParams::npcMode>(val);
5323  	}
5324  	_svp._npcCustomColor = parseYesNoBoolAttribute(TEXT("npcCustomColor"));
5325  	_svp._npcIncludeCcUniEol = parseYesNoBoolAttribute(TEXT("npcIncludeCcUniEOL"));
5326  	_svp._ccUniEolShow = parseYesNoBoolAttribute(TEXT("ccShow"), true);
5327  	nm = element->Attribute(TEXT("borderWidth"), &val);
5328  	if (nm)
5329  	{
5330  		if (val >= 0 && val <= 30)
5331  			_svp._borderWidth = val;
5332  	}
5333  	nm = element->Attribute(TEXT("smoothFont"));
5334  	if (nm)
5335  	{
5336  		if (!lstrcmp(nm, TEXT("yes")))
5337  			_svp._doSmoothFont = true;
5338  		else if (!lstrcmp(nm, TEXT("no")))
5339  			_svp._doSmoothFont = false;
5340  	}
5341  	nm = element->Attribute(TEXT("paddingLeft"), &val);
5342  	if (nm)
5343  	{
5344  		if (val >= 0 && val <= 30)
5345  			_svp._paddingLeft = static_cast<unsigned char>(val);
5346  	}
5347  	nm = element->Attribute(TEXT("paddingRight"), &val);
5348  	if (nm)
5349  	{
5350  		if (val >= 0 && val <= 30)
5351  			_svp._paddingRight = static_cast<unsigned char>(val);
5352  	}
5353  	nm = element->Attribute(TEXT("distractionFreeDivPart"), &val);
5354  	if (nm)
5355  	{
5356  		if (val >= 3 && val <= 9)
5357  			_svp._distractionFreeDivPart = static_cast<unsigned char>(val);
5358  	}
5359  }
5360  void NppParameters::feedDockingManager(TiXmlNode *node)
5361  {
5362  	TiXmlElement *element = node->ToElement();
5363  	int i;
5364  	if (element->Attribute(TEXT("leftWidth"), &i))
5365  		_nppGUI._dockingData._leftWidth = i;
5366  	if (element->Attribute(TEXT("rightWidth"), &i))
5367  		_nppGUI._dockingData._rightWidth = i;
5368  	if (element->Attribute(TEXT("topHeight"), &i))
5369  		_nppGUI._dockingData._topHeight = i;
5370  	if (element->Attribute(TEXT("bottomHeight"), &i))
5371  		_nppGUI._dockingData._bottomHight = i;
5372  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("FloatingWindow"));
5373  		childNode ;
5374  		childNode = childNode->NextSibling(TEXT("FloatingWindow")) )
5375  	{
5376  		TiXmlElement *floatElement = childNode->ToElement();
5377  		int cont;
5378  		if (floatElement->Attribute(TEXT("cont"), &cont))
5379  		{
5380  			int x = 0;
5381  			int y = 0;
5382  			int w = 100;
5383  			int h = 100;
5384  			floatElement->Attribute(TEXT("x"), &x);
5385  			floatElement->Attribute(TEXT("y"), &y);
5386  			floatElement->Attribute(TEXT("width"), &w);
5387  			floatElement->Attribute(TEXT("height"), &h);
5388  			_nppGUI._dockingData._flaotingWindowInfo.push_back(FloatingWindowInfo(cont, x, y, w, h));
5389  		}
5390  	}
5391  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("PluginDlg"));
5392  		childNode ;
5393  		childNode = childNode->NextSibling(TEXT("PluginDlg")) )
5394  	{
5395  		TiXmlElement *dlgElement = childNode->ToElement();
5396  		const TCHAR *name = dlgElement->Attribute(TEXT("pluginName"));
5397  		int id;
5398  		const TCHAR *idStr = dlgElement->Attribute(TEXT("id"), &id);
5399  		if (name && idStr)
5400  		{
5401  			int curr = 0; 
5402  			int prev = 0; 
5403  			dlgElement->Attribute(TEXT("curr"), &curr);
5404  			dlgElement->Attribute(TEXT("prev"), &prev);
5405  			bool isVisible = false;
5406  			const TCHAR *val = dlgElement->Attribute(TEXT("isVisible"));
5407  			if (val)
5408  			{
5409  				isVisible = (lstrcmp(val, TEXT("yes")) == 0);
5410  			}
5411  			_nppGUI._dockingData._pluginDockInfo.push_back(PluginDlgDockingInfo(name, id, curr, prev, isVisible));
5412  		}
5413  	}
5414  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("ActiveTabs"));
5415  		childNode ;
5416  		childNode = childNode->NextSibling(TEXT("ActiveTabs")) )
5417  	{
5418  		TiXmlElement *dlgElement = childNode->ToElement();
5419  		int cont;
5420  		if (dlgElement->Attribute(TEXT("cont"), &cont))
5421  		{
5422  			int activeTab = 0;
5423  			dlgElement->Attribute(TEXT("activeTab"), &activeTab);
5424  			_nppGUI._dockingData._containerTabInfo.push_back(ContainerTabInfo(cont, activeTab));
5425  		}
5426  	}
5427  }
5428  void NppParameters::duplicateDockingManager(TiXmlNode* dockMngNode, TiXmlElement* dockMngElmt2Clone)
5429  {
5430  	if (!dockMngNode || !dockMngElmt2Clone) return;
5431  	TiXmlElement *dockMngElmt = dockMngNode->ToElement();
5432  	int i;
5433  	if (dockMngElmt->Attribute(TEXT("leftWidth"), &i))
5434  		dockMngElmt2Clone->SetAttribute(TEXT("leftWidth"), i);
5435  	if (dockMngElmt->Attribute(TEXT("rightWidth"), &i))
5436  		dockMngElmt2Clone->SetAttribute(TEXT("rightWidth"), i);
5437  	if (dockMngElmt->Attribute(TEXT("topHeight"), &i))
5438  		dockMngElmt2Clone->SetAttribute(TEXT("topHeight"), i);
5439  	if (dockMngElmt->Attribute(TEXT("bottomHeight"), &i))
5440  		dockMngElmt2Clone->SetAttribute(TEXT("bottomHeight"), i);
5441  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("FloatingWindow"));
5442  		childNode;
5443  		childNode = childNode->NextSibling(TEXT("FloatingWindow")))
5444  	{
5445  		TiXmlElement *floatElement = childNode->ToElement();
5446  		int cont;
5447  		if (floatElement->Attribute(TEXT("cont"), &cont))
5448  		{
5449  			TiXmlElement FWNode(TEXT("FloatingWindow"));
5450  			FWNode.SetAttribute(TEXT("cont"), cont);
5451  			int x = 0;
5452  			int y = 0;
5453  			int w = 100;
5454  			int h = 100;
5455  			floatElement->Attribute(TEXT("x"), &x);
5456  			FWNode.SetAttribute(TEXT("x"), x);
5457  			floatElement->Attribute(TEXT("y"), &y);
5458  			FWNode.SetAttribute(TEXT("y"), y);
5459  			floatElement->Attribute(TEXT("width"), &w);
5460  			FWNode.SetAttribute(TEXT("width"), w);
5461  			floatElement->Attribute(TEXT("height"), &h);
5462  			FWNode.SetAttribute(TEXT("height"), h);
5463  			dockMngElmt2Clone->InsertEndChild(FWNode);
5464  		}
5465  	}
5466  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("PluginDlg"));
5467  		childNode;
5468  		childNode = childNode->NextSibling(TEXT("PluginDlg")))
5469  	{
5470  		TiXmlElement *dlgElement = childNode->ToElement();
5471  		const TCHAR *name = dlgElement->Attribute(TEXT("pluginName"));
5472  		TiXmlElement PDNode(TEXT("PluginDlg"));
5473  		int id;
5474  		const TCHAR *idStr = dlgElement->Attribute(TEXT("id"), &id);
5475  		if (name && idStr)
5476  		{
5477  			int curr = 0; 
5478  			int prev = 0; 
5479  			dlgElement->Attribute(TEXT("curr"), &curr);
5480  			dlgElement->Attribute(TEXT("prev"), &prev);
5481  			bool isVisible = false;
5482  			const TCHAR *val = dlgElement->Attribute(TEXT("isVisible"));
5483  			if (val)
5484  			{
5485  				isVisible = (lstrcmp(val, TEXT("yes")) == 0);
5486  			}
5487  			PDNode.SetAttribute(TEXT("pluginName"), name);
5488  			PDNode.SetAttribute(TEXT("id"), idStr);
5489  			PDNode.SetAttribute(TEXT("curr"), curr);
5490  			PDNode.SetAttribute(TEXT("prev"), prev);
5491  			PDNode.SetAttribute(TEXT("isVisible"), isVisible ? TEXT("yes") : TEXT("no"));
5492  			dockMngElmt2Clone->InsertEndChild(PDNode);
5493  		}
5494  	}
5495  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("ActiveTabs"));
5496  		childNode;
5497  		childNode = childNode->NextSibling(TEXT("ActiveTabs")))
5498  	{
5499  		TiXmlElement *dlgElement = childNode->ToElement();
5500  		TiXmlElement CTNode(TEXT("ActiveTabs"));
5501  		int cont;
5502  		if (dlgElement->Attribute(TEXT("cont"), &cont))
5503  		{
5504  			int activeTab = 0;
5505  			dlgElement->Attribute(TEXT("activeTab"), &activeTab);
5506  			CTNode.SetAttribute(TEXT("cont"), cont);
5507  			CTNode.SetAttribute(TEXT("activeTab"), activeTab);
5508  			dockMngElmt2Clone->InsertEndChild(CTNode);
5509  		}
5510  	}
5511  }
5512  bool NppParameters::writeScintillaParams()
5513  {
5514  	if (!_pXmlUserDoc) return false;
5515  	const TCHAR *pViewName = TEXT("ScintillaPrimaryView");
5516  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
5517  	if (!nppRoot)
5518  	{
5519  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
5520  	}
5521  	TiXmlNode *configsRoot = nppRoot->FirstChildElement(TEXT("GUIConfigs"));
5522  	if (!configsRoot)
5523  	{
5524  		configsRoot = nppRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfigs")));
5525  	}
5526  	TiXmlNode *scintNode = getChildElementByAttribut(configsRoot, TEXT("GUIConfig"), TEXT("name"), pViewName);
5527  	if (!scintNode)
5528  	{
5529  		scintNode = configsRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig")));
5530  		(scintNode->ToElement())->SetAttribute(TEXT("name"), pViewName);
5531  	}
5532  	auto setYesNoBoolAttribute = [&scintNode](const TCHAR* name, bool value) -> void {
5533  		const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5534  		(scintNode->ToElement())->SetAttribute(name, pStr);
5535  	};
5536  	auto setShowHideBoolAttribute = [&scintNode](const TCHAR* name, bool value) -> void {
5537  		const TCHAR* pStr = value ? TEXT("show") : TEXT("hide");
5538  		(scintNode->ToElement())->SetAttribute(name, pStr);
5539  	};
5540  	(scintNode->ToElement())->SetAttribute(TEXT("lineNumberMargin"), _svp._lineNumberMarginShow?TEXT("show"):TEXT("hide"));
5541  	(scintNode->ToElement())->SetAttribute(TEXT("lineNumberDynamicWidth"), _svp._lineNumberMarginDynamicWidth ?TEXT("yes"):TEXT("no"));
5542  	(scintNode->ToElement())->SetAttribute(TEXT("bookMarkMargin"), _svp._bookMarkMarginShow?TEXT("show"):TEXT("hide"));
5543  	(scintNode->ToElement())->SetAttribute(TEXT("indentGuideLine"), _svp._indentGuideLineShow?TEXT("show"):TEXT("hide"));
5544  	const TCHAR *pFolderStyleStr = (_svp._folderStyle == FOLDER_STYLE_SIMPLE)?TEXT("simple"):
5545  									(_svp._folderStyle == FOLDER_STYLE_ARROW)?TEXT("arrow"):
5546  										(_svp._folderStyle == FOLDER_STYLE_CIRCLE)?TEXT("circle"):
5547  										(_svp._folderStyle == FOLDER_STYLE_NONE)?TEXT("none"):TEXT("box");
5548  	(scintNode->ToElement())->SetAttribute(TEXT("folderMarkStyle"), pFolderStyleStr);
5549  	(scintNode->ToElement())->SetAttribute(TEXT("isChangeHistoryEnabled"), _svp._isChangeHistoryEnabled4NextSession ? TEXT("yes") : TEXT("no"));
5550  	const TCHAR *pWrapMethodStr = (_svp._lineWrapMethod == LINEWRAP_ALIGNED)?TEXT("aligned"):
5551  								(_svp._lineWrapMethod == LINEWRAP_INDENT)?TEXT("indent"):TEXT("default");
5552  	(scintNode->ToElement())->SetAttribute(TEXT("lineWrapMethod"), pWrapMethodStr);
5553  	(scintNode->ToElement())->SetAttribute(TEXT("currentLineIndicator"), _svp._currentLineHiliteMode);
5554  	(scintNode->ToElement())->SetAttribute(TEXT("currentLineFrameWidth"), _svp._currentLineFrameWidth);
5555  	(scintNode->ToElement())->SetAttribute(TEXT("virtualSpace"), _svp._virtualSpace?TEXT("yes"):TEXT("no"));
5556  	(scintNode->ToElement())->SetAttribute(TEXT("scrollBeyondLastLine"), _svp._scrollBeyondLastLine?TEXT("yes"):TEXT("no"));
5557  	(scintNode->ToElement())->SetAttribute(TEXT("rightClickKeepsSelection"), _svp._rightClickKeepsSelection ? TEXT("yes") : TEXT("no"));
5558  	(scintNode->ToElement())->SetAttribute(TEXT("disableAdvancedScrolling"), _svp._disableAdvancedScrolling?TEXT("yes"):TEXT("no"));
5559  	(scintNode->ToElement())->SetAttribute(TEXT("wrapSymbolShow"), _svp._wrapSymbolShow?TEXT("show"):TEXT("hide"));
5560  	(scintNode->ToElement())->SetAttribute(TEXT("Wrap"), _svp._doWrap?TEXT("yes"):TEXT("no"));
5561  	(scintNode->ToElement())->SetAttribute(TEXT("borderEdge"), _svp._showBorderEdge ? TEXT("yes") : TEXT("no"));
5562  	generic_string edgeColumnPosStr;
5563  	for (auto i : _svp._edgeMultiColumnPos)
5564  	{
5565  		std::string s = std::to_string(i);
5566  		edgeColumnPosStr += generic_string(s.begin(), s.end());
5567  		edgeColumnPosStr += TEXT(" ");
5568  	}
5569  	(scintNode->ToElement())->SetAttribute(TEXT("isEdgeBgMode"), _svp._isEdgeBgMode ? TEXT("yes") : TEXT("no"));
5570  	(scintNode->ToElement())->SetAttribute(TEXT("edgeMultiColumnPos"), edgeColumnPosStr);
5571  	(scintNode->ToElement())->SetAttribute(TEXT("zoom"), static_cast<int>(_svp._zoom));
5572  	(scintNode->ToElement())->SetAttribute(TEXT("zoom2"), static_cast<int>(_svp._zoom2));
5573  	(scintNode->ToElement())->SetAttribute(TEXT("whiteSpaceShow"), _svp._whiteSpaceShow?TEXT("show"):TEXT("hide"));
5574  	(scintNode->ToElement())->SetAttribute(TEXT("eolShow"), _svp._eolShow?TEXT("show"):TEXT("hide"));
5575  	(scintNode->ToElement())->SetAttribute(TEXT("eolMode"), _svp._eolMode);
5576  	setShowHideBoolAttribute(TEXT("npcShow"), _svp._npcShow);
5577  	(scintNode->ToElement())->SetAttribute(TEXT("npcMode"), static_cast<int>(_svp._npcMode));
5578  	setYesNoBoolAttribute(TEXT("npcCustomColor"), _svp._npcCustomColor);
5579  	setYesNoBoolAttribute(TEXT("npcIncludeCcUniEOL"), _svp._npcIncludeCcUniEol);
5580  	setYesNoBoolAttribute(TEXT("ccShow"), _svp._ccUniEolShow);
5581  	(scintNode->ToElement())->SetAttribute(TEXT("borderWidth"), _svp._borderWidth);
5582  	(scintNode->ToElement())->SetAttribute(TEXT("smoothFont"), _svp._doSmoothFont ? TEXT("yes") : TEXT("no"));
5583  	(scintNode->ToElement())->SetAttribute(TEXT("paddingLeft"), _svp._paddingLeft);
5584  	(scintNode->ToElement())->SetAttribute(TEXT("paddingRight"), _svp._paddingRight);
5585  	(scintNode->ToElement())->SetAttribute(TEXT("distractionFreeDivPart"), _svp._distractionFreeDivPart);
5586  	return true;
5587  }
5588  void NppParameters::createXmlTreeFromGUIParams()
5589  {
5590  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
5591  	if (!nppRoot)
5592  	{
5593  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
5594  	}
5595  	TiXmlNode *oldGUIRoot = nppRoot->FirstChildElement(TEXT("GUIConfigs"));
5596  	TiXmlElement* dockMngNodeDup = nullptr;
5597  	TiXmlNode* dockMngNodeOriginal = nullptr;
5598  	if (oldGUIRoot && _nppGUI._isCmdlineNosessionActivated)
5599  	{
5600  		for (TiXmlNode *childNode = oldGUIRoot->FirstChildElement(TEXT("GUIConfig"));
5601  			childNode;
5602  			childNode = childNode->NextSibling(TEXT("GUIConfig")))
5603  		{
5604  			TiXmlElement* element = childNode->ToElement();
5605  			const TCHAR* nm = element->Attribute(TEXT("name"));
5606  			if (nullptr == nm)
5607  				continue;
5608  			if (!lstrcmp(nm, TEXT("DockingManager")))
5609  			{
5610  				dockMngNodeOriginal = childNode;
5611  				break;
5612  			}
5613  		}
5614  		if (dockMngNodeOriginal)
5615  		{
5616  			dockMngNodeDup = new TiXmlElement(TEXT("GUIConfig"));
5617  			dockMngNodeDup->SetAttribute(TEXT("name"), TEXT("DockingManager"));
5618  			duplicateDockingManager(dockMngNodeOriginal, dockMngNodeDup);
5619  		}
5620  	}
5621  	if (oldGUIRoot)
5622  	{
5623  		nppRoot->RemoveChild(oldGUIRoot);
5624  	}
5625  	TiXmlNode *newGUIRoot = nppRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfigs")));
5626  	{
5627  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5628  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ToolBar"));
5629  		const TCHAR *pStr = (_nppGUI._toolbarShow) ? TEXT("yes") : TEXT("no");
5630  		GUIConfigElement->SetAttribute(TEXT("visible"), pStr);
5631  		if (_nppGUI._toolBarStatus == TB_SMALL)
5632  			pStr = TEXT("small");
5633  		else if (_nppGUI._toolBarStatus == TB_LARGE)
5634  			pStr = TEXT("large");
5635  		else if (_nppGUI._toolBarStatus == TB_SMALL2)
5636  			pStr = TEXT("small2");
5637  		else if (_nppGUI._toolBarStatus == TB_LARGE2)
5638  			pStr = TEXT("large2");
5639  		else 
5640  			pStr = TEXT("standard");
5641  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5642  	}
5643  	{
5644  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5645  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("StatusBar"));
5646  		const TCHAR *pStr = _nppGUI._statusBarShow ? TEXT("show") : TEXT("hide");
5647  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5648  	}
5649  	{
5650  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5651  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("TabBar"));
5652  		const TCHAR *pStr = (_nppGUI._tabStatus & TAB_DRAWTOPBAR) ? TEXT("yes") : TEXT("no");
5653  		GUIConfigElement->SetAttribute(TEXT("dragAndDrop"), pStr);
5654  		pStr = (_nppGUI._tabStatus & TAB_DRAGNDROP) ? TEXT("yes") : TEXT("no");
5655  		GUIConfigElement->SetAttribute(TEXT("drawTopBar"), pStr);
5656  		pStr = (_nppGUI._tabStatus & TAB_DRAWINACTIVETAB) ? TEXT("yes") : TEXT("no");
5657  		GUIConfigElement->SetAttribute(TEXT("drawInactiveTab"), pStr);
5658  		pStr = (_nppGUI._tabStatus & TAB_REDUCE) ? TEXT("yes") : TEXT("no");
5659  		GUIConfigElement->SetAttribute(TEXT("reduce"), pStr);
5660  		pStr = (_nppGUI._tabStatus & TAB_CLOSEBUTTON) ? TEXT("yes") : TEXT("no");
5661  		GUIConfigElement->SetAttribute(TEXT("closeButton"), pStr);
5662  		pStr = (_nppGUI._tabStatus & TAB_DBCLK2CLOSE) ? TEXT("yes") : TEXT("no");
5663  		GUIConfigElement->SetAttribute(TEXT("doubleClick2Close"), pStr);
5664  		pStr = (_nppGUI._tabStatus & TAB_VERTICAL) ? TEXT("yes") : TEXT("no");
5665  		GUIConfigElement->SetAttribute(TEXT("vertical"), pStr);
5666  		pStr = (_nppGUI._tabStatus & TAB_MULTILINE) ? TEXT("yes") : TEXT("no");
5667  		GUIConfigElement->SetAttribute(TEXT("multiLine"), pStr);
5668  		pStr = (_nppGUI._tabStatus & TAB_HIDE) ? TEXT("yes") : TEXT("no");
5669  		GUIConfigElement->SetAttribute(TEXT("hide"), pStr);
5670  		pStr = (_nppGUI._tabStatus & TAB_QUITONEMPTY) ? TEXT("yes") : TEXT("no");
5671  		GUIConfigElement->SetAttribute(TEXT("quitOnEmpty"), pStr);
5672  		pStr = (_nppGUI._tabStatus & TAB_ALTICONS) ? TEXT("1") : TEXT("0");
5673  		GUIConfigElement->SetAttribute(TEXT("iconSetNumber"), pStr);
5674  	}
5675  	{
5676  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5677  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ScintillaViewsSplitter"));
5678  		const TCHAR *pStr = _nppGUI._splitterPos == POS_VERTICAL ? TEXT("vertical") : TEXT("horizontal");
5679  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5680  	}
5681  	{
5682  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5683  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("UserDefineDlg"));
5684  		const TCHAR *pStr = (_nppGUI._userDefineDlgStatus & UDD_DOCKED) ? TEXT("docked") : TEXT("undocked");
5685  		GUIConfigElement->SetAttribute(TEXT("position"), pStr);
5686  		pStr = (_nppGUI._userDefineDlgStatus & UDD_SHOW) ? TEXT("show") : TEXT("hide");
5687  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5688  	}
5689  	{
5690  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5691  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("TabSetting"));
5692  		const TCHAR *pStr = _nppGUI._tabReplacedBySpace ? TEXT("yes") : TEXT("no");
5693  		GUIConfigElement->SetAttribute(TEXT("replaceBySpace"), pStr);
5694  		GUIConfigElement->SetAttribute(TEXT("size"), _nppGUI._tabSize);
5695  	}
5696  	{
5697  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5698  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("AppPosition"));
5699  		GUIConfigElement->SetAttribute(TEXT("x"), _nppGUI._appPos.left);
5700  		GUIConfigElement->SetAttribute(TEXT("y"), _nppGUI._appPos.top);
5701  		GUIConfigElement->SetAttribute(TEXT("width"), _nppGUI._appPos.right);
5702  		GUIConfigElement->SetAttribute(TEXT("height"), _nppGUI._appPos.bottom);
5703  		GUIConfigElement->SetAttribute(TEXT("isMaximized"), _nppGUI._isMaximized ? TEXT("yes") : TEXT("no"));
5704  	}
5705  	{
5706  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5707  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("FindWindowPosition"));
5708  		GUIConfigElement->SetAttribute(TEXT("left"), _nppGUI._findWindowPos.left);
5709  		GUIConfigElement->SetAttribute(TEXT("top"), _nppGUI._findWindowPos.top);
5710  		GUIConfigElement->SetAttribute(TEXT("right"), _nppGUI._findWindowPos.right);
5711  		GUIConfigElement->SetAttribute(TEXT("bottom"), _nppGUI._findWindowPos.bottom);
5712  		GUIConfigElement->SetAttribute(TEXT("isLessModeOn"), _nppGUI._findWindowLessMode ? TEXT("yes") : TEXT("no"));
5713  	}
5714  	{
5715  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5716  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("FinderConfig"));
5717  		const TCHAR* pStr = _nppGUI._finderLinesAreCurrentlyWrapped ? TEXT("yes") : TEXT("no");
5718  		GUIConfigElement->SetAttribute(TEXT("wrappedLines"), pStr);
5719  		pStr = _nppGUI._finderPurgeBeforeEverySearch ? TEXT("yes") : TEXT("no");
5720  		GUIConfigElement->SetAttribute(TEXT("purgeBeforeEverySearch"), pStr);
5721  		pStr = _nppGUI._finderShowOnlyOneEntryPerFoundLine ? TEXT("yes") : TEXT("no");
5722  		GUIConfigElement->SetAttribute(TEXT("showOnlyOneEntryPerFoundLine"), pStr);
5723  	}
5724  	{
5725  		TiXmlElement *element = insertGUIConfigBoolNode(newGUIRoot, TEXT("noUpdate"), !_nppGUI._autoUpdateOpt._doAutoUpdate);
5726  		element->SetAttribute(TEXT("intervalDays"), _nppGUI._autoUpdateOpt._intervalDays);
5727  		element->SetAttribute(TEXT("nextUpdateDate"), _nppGUI._autoUpdateOpt._nextUpdateDate.toString().c_str());
5728  	}
5729  	{
5730  		const TCHAR *pStr = TEXT("no");
5731  		if (_nppGUI._fileAutoDetection & cdEnabledOld)
5732  		{
5733  			pStr = TEXT("yesOld");
5734  			if ((_nppGUI._fileAutoDetection & cdAutoUpdate) && (_nppGUI._fileAutoDetection & cdGo2end))
5735  			{
5736  				pStr = TEXT("autoUpdate2EndOld");
5737  			}
5738  			else if (_nppGUI._fileAutoDetection & cdAutoUpdate)
5739  			{
5740  				pStr = TEXT("autoOld");
5741  			}
5742  			else if (_nppGUI._fileAutoDetection & cdGo2end)
5743  			{
5744  				pStr = TEXT("Update2EndOld");
5745  			}
5746  		}
5747  		else if (_nppGUI._fileAutoDetection & cdEnabledNew)
5748  		{
5749  			pStr = TEXT("yes");
5750  			if ((_nppGUI._fileAutoDetection & cdAutoUpdate) && (_nppGUI._fileAutoDetection & cdGo2end))
5751  			{
5752  				pStr = TEXT("autoUpdate2End");
5753  			}
5754  			else if (_nppGUI._fileAutoDetection & cdAutoUpdate)
5755  			{
5756  				pStr = TEXT("auto");
5757  			}
5758  			else if (_nppGUI._fileAutoDetection & cdGo2end)
5759  			{
5760  				pStr = TEXT("Update2End");
5761  			}
5762  		}
5763  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5764  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Auto-detection"));
5765  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5766  	}
5767  	{
5768  		insertGUIConfigBoolNode(newGUIRoot, TEXT("CheckHistoryFiles"), _nppGUI._checkHistoryFiles);
5769  	}
5770  	{
5771  		insertGUIConfigBoolNode(newGUIRoot, TEXT("TrayIcon"), _nppGUI._isMinimizedToTray);
5772  	}
5773  	{
5774  		insertGUIConfigBoolNode(newGUIRoot, TEXT("MaitainIndent"), _nppGUI._maitainIndent);
5775  	}
5776  	{
5777  		TiXmlElement * ele = insertGUIConfigBoolNode(newGUIRoot, TEXT("TagsMatchHighLight"), _nppGUI._enableTagsMatchHilite);
5778  		ele->SetAttribute(TEXT("TagAttrHighLight"), _nppGUI._enableTagAttrsHilite ? TEXT("yes") : TEXT("no"));
5779  		ele->SetAttribute(TEXT("HighLightNonHtmlZone"), _nppGUI._enableHiliteNonHTMLZone ? TEXT("yes") : TEXT("no"));
5780  	}
5781  	{
5782  		insertGUIConfigBoolNode(newGUIRoot, TEXT("RememberLastSession"), _nppGUI._rememberLastSession);
5783  	}
5784  	{
5785  		insertGUIConfigBoolNode(newGUIRoot, TEXT("DetectEncoding"), _nppGUI._detectEncoding);
5786  	}
5787  	{
5788  		insertGUIConfigBoolNode(newGUIRoot, TEXT("SaveAllConfirm"), _nppGUI._saveAllConfirm);
5789  	}
5790  	{
5791  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5792  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("NewDocDefaultSettings"));
5793  		GUIConfigElement->SetAttribute(TEXT("format"), static_cast<int32_t>(_nppGUI._newDocDefaultSettings._format));
5794  		GUIConfigElement->SetAttribute(TEXT("encoding"), _nppGUI._newDocDefaultSettings._unicodeMode);
5795  		GUIConfigElement->SetAttribute(TEXT("lang"), _nppGUI._newDocDefaultSettings._lang);
5796  		GUIConfigElement->SetAttribute(TEXT("codepage"), _nppGUI._newDocDefaultSettings._codepage);
5797  		GUIConfigElement->SetAttribute(TEXT("openAnsiAsUTF8"), _nppGUI._newDocDefaultSettings._openAnsiAsUtf8 ? TEXT("yes") : TEXT("no"));
5798  		GUIConfigElement->SetAttribute(TEXT("addNewDocumentOnStartup"), _nppGUI._newDocDefaultSettings._addNewDocumentOnStartup ? TEXT("yes") : TEXT("no"));
5799  	}
5800  	{
5801  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5802  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("langsExcluded"));
5803  		writeExcludedLangList(GUIConfigElement);
5804  		GUIConfigElement->SetAttribute(TEXT("langMenuCompact"), _nppGUI._isLangMenuCompact ? TEXT("yes") : TEXT("no"));
5805  	}
5806  	{
5807  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5808  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Print"));
5809  		writePrintSetting(GUIConfigElement);
5810  	}
5811  	{
5812  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5813  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Backup"));
5814  		GUIConfigElement->SetAttribute(TEXT("action"), _nppGUI._backup);
5815  		GUIConfigElement->SetAttribute(TEXT("useCustumDir"), _nppGUI._useDir ? TEXT("yes") : TEXT("no"));
5816  		GUIConfigElement->SetAttribute(TEXT("dir"), _nppGUI._backupDir.c_str());
5817  		GUIConfigElement->SetAttribute(TEXT("isSnapshotMode"), _nppGUI._isSnapshotMode ? TEXT("yes") : TEXT("no"));
5818  		GUIConfigElement->SetAttribute(TEXT("snapshotBackupTiming"), static_cast<int32_t>(_nppGUI._snapshotBackupTiming));
5819  	}
5820  	{
5821  		insertGUIConfigBoolNode(newGUIRoot, TEXT("TaskList"), _nppGUI._doTaskList);
5822  	}
5823  	{
5824  		insertGUIConfigBoolNode(newGUIRoot, TEXT("MRU"), _nppGUI._styleMRU);
5825  	}
5826  	{
5827  		TCHAR szStr [12] = TEXT("0");
5828  		_itow(_nppGUI._styleURL, szStr, 10);
5829  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5830  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("URL"));
5831  		GUIConfigElement->InsertEndChild(TiXmlText(szStr));
5832  	}
5833  	{
5834  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5835  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("uriCustomizedSchemes"));
5836  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._uriSchemes.c_str()));
5837  	}
5838  	{
5839  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5840  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("globalOverride"));
5841  		GUIConfigElement->SetAttribute(TEXT("fg"), _nppGUI._globalOverride.enableFg ? TEXT("yes") : TEXT("no"));
5842  		GUIConfigElement->SetAttribute(TEXT("bg"), _nppGUI._globalOverride.enableBg ? TEXT("yes") : TEXT("no"));
5843  		GUIConfigElement->SetAttribute(TEXT("font"), _nppGUI._globalOverride.enableFont ? TEXT("yes") : TEXT("no"));
5844  		GUIConfigElement->SetAttribute(TEXT("fontSize"), _nppGUI._globalOverride.enableFontSize ? TEXT("yes") : TEXT("no"));
5845  		GUIConfigElement->SetAttribute(TEXT("bold"), _nppGUI._globalOverride.enableBold ? TEXT("yes") : TEXT("no"));
5846  		GUIConfigElement->SetAttribute(TEXT("italic"), _nppGUI._globalOverride.enableItalic ? TEXT("yes") : TEXT("no"));
5847  		GUIConfigElement->SetAttribute(TEXT("underline"), _nppGUI._globalOverride.enableUnderLine ? TEXT("yes") : TEXT("no"));
5848  	}
5849  	{
5850  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5851  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("auto-completion"));
5852  		GUIConfigElement->SetAttribute(TEXT("autoCAction"), _nppGUI._autocStatus);
5853  		GUIConfigElement->SetAttribute(TEXT("triggerFromNbChar"), static_cast<int32_t>(_nppGUI._autocFromLen));
5854  		const TCHAR * pStr = _nppGUI._autocIgnoreNumbers ? TEXT("yes") : TEXT("no");
5855  		GUIConfigElement->SetAttribute(TEXT("autoCIgnoreNumbers"), pStr);
5856  		pStr = _nppGUI._autocInsertSelectedUseENTER ? TEXT("yes") : TEXT("no");
5857  		GUIConfigElement->SetAttribute(TEXT("insertSelectedItemUseENTER"), pStr);
5858  		pStr = _nppGUI._autocInsertSelectedUseTAB ? TEXT("yes") : TEXT("no");
5859  		GUIConfigElement->SetAttribute(TEXT("insertSelectedItemUseTAB"), pStr);
5860  		pStr = _nppGUI._autocBrief ? TEXT("yes") : TEXT("no");
5861  		GUIConfigElement->SetAttribute(TEXT("autoCBrief"), pStr);
5862  		pStr = _nppGUI._funcParams ? TEXT("yes") : TEXT("no");
5863  		GUIConfigElement->SetAttribute(TEXT("funcParams"), pStr);
5864  	}
5865  	{
5866  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5867  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("auto-insert"));
5868  		GUIConfigElement->SetAttribute(TEXT("parentheses"), _nppGUI._matchedPairConf._doParentheses ? TEXT("yes") : TEXT("no"));
5869  		GUIConfigElement->SetAttribute(TEXT("brackets"), _nppGUI._matchedPairConf._doBrackets ? TEXT("yes") : TEXT("no"));
5870  		GUIConfigElement->SetAttribute(TEXT("curlyBrackets"), _nppGUI._matchedPairConf._doCurlyBrackets ? TEXT("yes") : TEXT("no"));
5871  		GUIConfigElement->SetAttribute(TEXT("quotes"), _nppGUI._matchedPairConf._doQuotes ? TEXT("yes") : TEXT("no"));
5872  		GUIConfigElement->SetAttribute(TEXT("doubleQuotes"), _nppGUI._matchedPairConf._doDoubleQuotes ? TEXT("yes") : TEXT("no"));
5873  		GUIConfigElement->SetAttribute(TEXT("htmlXmlTag"), _nppGUI._matchedPairConf._doHtmlXmlTag ? TEXT("yes") : TEXT("no"));
5874  		TiXmlElement hist_element{ TEXT("") };
5875  		hist_element.SetValue(TEXT("UserDefinePair"));
5876  		for (size_t i = 0, nb = _nppGUI._matchedPairConf._matchedPairs.size(); i < nb; ++i)
5877  		{
5878  			int open = _nppGUI._matchedPairConf._matchedPairs[i].first;
5879  			int close = _nppGUI._matchedPairConf._matchedPairs[i].second;
5880  			(hist_element.ToElement())->SetAttribute(TEXT("open"), open);
5881  			(hist_element.ToElement())->SetAttribute(TEXT("close"), close);
5882  			GUIConfigElement->InsertEndChild(hist_element);
5883  		}
5884  	}
5885  	{
5886  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5887  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("sessionExt"));
5888  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._definedSessionExt.c_str()));
5889  	}
5890  	{
5891  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5892  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("workspaceExt"));
5893  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._definedWorkspaceExt.c_str()));
5894  	}
5895  	{
5896  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5897  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MenuBar"));
5898  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._menuBarShow ? TEXT("show") : TEXT("hide")));
5899  	}
5900  	{
5901  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5902  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Caret"));
5903  		GUIConfigElement->SetAttribute(TEXT("width"), _nppGUI._caretWidth);
5904  		GUIConfigElement->SetAttribute(TEXT("blinkRate"), _nppGUI._caretBlinkRate);
5905  	}
5906  	{
5907  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5908  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ScintillaGlobalSettings"));
5909  		GUIConfigElement->SetAttribute(TEXT("enableMultiSelection"), _nppGUI._enableMultiSelection ? TEXT("yes") : TEXT("no"));
5910  	}
5911  	{
5912  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5913  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("openSaveDir"));
5914  		GUIConfigElement->SetAttribute(TEXT("value"), _nppGUI._openSaveDir);
5915  		GUIConfigElement->SetAttribute(TEXT("defaultDirPath"), _nppGUI._defaultDir);
5916  	}
5917  	{
5918  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5919  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("titleBar"));
5920  		const TCHAR *pStr = (_nppGUI._shortTitlebar) ? TEXT("yes") : TEXT("no");
5921  		GUIConfigElement->SetAttribute(TEXT("short"), pStr);
5922  	}
5923  	{
5924  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5925  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("insertDateTime"));
5926  		GUIConfigElement->SetAttribute(TEXT("customizedFormat"), _nppGUI._dateTimeFormat.c_str());
5927  		const TCHAR* pStr = (_nppGUI._dateTimeReverseDefaultOrder) ? TEXT("yes") : TEXT("no");
5928  		GUIConfigElement->SetAttribute(TEXT("reverseDefaultOrder"), pStr);
5929  	}
5930  	{
5931  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5932  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("wordCharList"));
5933  		GUIConfigElement->SetAttribute(TEXT("useDefault"), _nppGUI._isWordCharDefault ? TEXT("yes") : TEXT("no"));
5934  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
5935  		const wchar_t* charsAddStr = wmc.char2wchar(_nppGUI._customWordChars.c_str(), SC_CP_UTF8);
5936  		GUIConfigElement->SetAttribute(TEXT("charsAdded"), charsAddStr);
5937  	}
5938  	{
5939  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5940  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("delimiterSelection"));
5941  		GUIConfigElement->SetAttribute(TEXT("leftmostDelimiter"), _nppGUI._leftmostDelimiter);
5942  		GUIConfigElement->SetAttribute(TEXT("rightmostDelimiter"), _nppGUI._rightmostDelimiter);
5943  		GUIConfigElement->SetAttribute(TEXT("delimiterSelectionOnEntireDocument"), _nppGUI._delimiterSelectionOnEntireDocument ? TEXT("yes") : TEXT("no"));
5944  	}
5945  	{
5946  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5947  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("largeFileRestriction"));
5948  		GUIConfigElement->SetAttribute(TEXT("fileSizeMB"), static_cast<int>((_nppGUI._largeFileRestriction._largeFileSizeDefInByte / 1024) / 1024));
5949  		GUIConfigElement->SetAttribute(TEXT("isEnabled"), _nppGUI._largeFileRestriction._isEnabled ? TEXT("yes") : TEXT("no"));
5950  		GUIConfigElement->SetAttribute(TEXT("allowAutoCompletion"), _nppGUI._largeFileRestriction._allowAutoCompletion ? TEXT("yes") : TEXT("no"));
5951  		GUIConfigElement->SetAttribute(TEXT("allowBraceMatch"), _nppGUI._largeFileRestriction._allowBraceMatch ? TEXT("yes") : TEXT("no"));
5952  		GUIConfigElement->SetAttribute(TEXT("allowSmartHilite"), _nppGUI._largeFileRestriction._allowSmartHilite ? TEXT("yes") : TEXT("no"));
5953  		GUIConfigElement->SetAttribute(TEXT("allowClickableLink"), _nppGUI._largeFileRestriction._allowClickableLink ? TEXT("yes") : TEXT("no"));
5954  		GUIConfigElement->SetAttribute(TEXT("deactivateWordWrap"), _nppGUI._largeFileRestriction._deactivateWordWrap ? TEXT("yes") : TEXT("no"));
5955  	}
5956  	{
5957  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5958  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("multiInst"));
5959  		GUIConfigElement->SetAttribute(TEXT("setting"), _nppGUI._multiInstSetting);
5960  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) -> void {
5961  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5962  			GUIConfigElement->SetAttribute(name, pStr);
5963  		};
5964  		setYesNoBoolAttribute(TEXT("clipboardHistory"), _nppGUI._clipboardHistoryPanelKeepState);
5965  		setYesNoBoolAttribute(TEXT("documentList"), _nppGUI._docListKeepState);
5966  		setYesNoBoolAttribute(TEXT("characterPanel"), _nppGUI._charPanelKeepState);
5967  		setYesNoBoolAttribute(TEXT("folderAsWorkspace"), _nppGUI._fileBrowserKeepState);
5968  		setYesNoBoolAttribute(TEXT("projectPanels"), _nppGUI._projectPanelKeepState);
5969  		setYesNoBoolAttribute(TEXT("documentMap"), _nppGUI._docMapKeepState);
5970  		setYesNoBoolAttribute(TEXT("fuctionList"), _nppGUI._funcListKeepState);
5971  		setYesNoBoolAttribute(TEXT("pluginPanels"), _nppGUI._pluginPanelKeepState);
5972  	}
5973  	{
5974  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5975  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MISC"));
5976  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) -> void {
5977  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5978  			GUIConfigElement->SetAttribute(name, pStr);
5979  		};
5980  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherWithoutExtColumn"), _nppGUI._fileSwitcherWithoutExtColumn ? TEXT("yes") : TEXT("no"));
5981  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherExtWidth"), _nppGUI._fileSwitcherExtWidth);
5982  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherWithoutPathColumn"), _nppGUI._fileSwitcherWithoutPathColumn ? TEXT("yes") : TEXT("no"));
5983  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherPathWidth"), _nppGUI._fileSwitcherPathWidth);
5984  		setYesNoBoolAttribute(TEXT("fileSwitcherNoGroups"), _nppGUI._fileSwitcherDisableListViewGroups);
5985  		GUIConfigElement->SetAttribute(TEXT("backSlashIsEscapeCharacterForSql"), _nppGUI._backSlashIsEscapeCharacterForSql ? TEXT("yes") : TEXT("no"));
5986  		GUIConfigElement->SetAttribute(TEXT("writeTechnologyEngine"), _nppGUI._writeTechnologyEngine);
5987  		GUIConfigElement->SetAttribute(TEXT("isFolderDroppedOpenFiles"), _nppGUI._isFolderDroppedOpenFiles ? TEXT("yes") : TEXT("no"));
5988  		GUIConfigElement->SetAttribute(TEXT("docPeekOnTab"), _nppGUI._isDocPeekOnTab ? TEXT("yes") : TEXT("no"));
5989  		GUIConfigElement->SetAttribute(TEXT("docPeekOnMap"), _nppGUI._isDocPeekOnMap ? TEXT("yes") : TEXT("no"));
5990  		GUIConfigElement->SetAttribute(TEXT("sortFunctionList"), _nppGUI._shouldSortFunctionList ? TEXT("yes") : TEXT("no"));
5991  		GUIConfigElement->SetAttribute(TEXT("saveDlgExtFilterToAllTypes"), _nppGUI._setSaveDlgExtFiltToAllTypes ? TEXT("yes") : TEXT("no"));
5992  		GUIConfigElement->SetAttribute(TEXT("muteSounds"), _nppGUI._muteSounds ? TEXT("yes") : TEXT("no"));
5993  		GUIConfigElement->SetAttribute(TEXT("enableFoldCmdToggable"), _nppGUI._enableFoldCmdToggable ? TEXT("yes") : TEXT("no"));
5994  		GUIConfigElement->SetAttribute(TEXT("hideMenuRightShortcuts"), _nppGUI._hideMenuRightShortcuts ? TEXT("yes") : TEXT("no"));
5995  	}
5996  	{
5997  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5998  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Searching"));
5999  		GUIConfigElement->SetAttribute(TEXT("monospacedFontFindDlg"), _nppGUI._monospacedFontFindDlg ? TEXT("yes") : TEXT("no"));
6000  		GUIConfigElement->SetAttribute(TEXT("fillFindFieldWithSelected"), _nppGUI._fillFindFieldWithSelected ? TEXT("yes") : TEXT("no"));
6001  		GUIConfigElement->SetAttribute(TEXT("fillFindFieldSelectCaret"), _nppGUI._fillFindFieldSelectCaret ? TEXT("yes") : TEXT("no"));
6002  		GUIConfigElement->SetAttribute(TEXT("findDlgAlwaysVisible"), _nppGUI._findDlgAlwaysVisible ? TEXT("yes") : TEXT("no"));
6003  		GUIConfigElement->SetAttribute(TEXT("confirmReplaceInAllOpenDocs"), _nppGUI._confirmReplaceInAllOpenDocs ? TEXT("yes") : TEXT("no"));
6004  		GUIConfigElement->SetAttribute(TEXT("replaceStopsWithoutFindingNext"), _nppGUI._replaceStopsWithoutFindingNext ? TEXT("yes") : TEXT("no"));
6005  	}
6006  	{
6007  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6008  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("searchEngine"));
6009  		GUIConfigElement->SetAttribute(TEXT("searchEngineChoice"), _nppGUI._searchEngineChoice);
6010  		GUIConfigElement->SetAttribute(TEXT("searchEngineCustom"), _nppGUI._searchEngineCustom);
6011  	}
6012  	{
6013  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6014  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MarkAll"));
6015  		GUIConfigElement->SetAttribute(TEXT("matchCase"), _nppGUI._markAllCaseSensitive ? TEXT("yes") : TEXT("no"));
6016  		GUIConfigElement->SetAttribute(TEXT("wholeWordOnly"), _nppGUI._markAllWordOnly ? TEXT("yes") : TEXT("no"));
6017  	}
6018  	{
6019  		TiXmlElement *GUIConfigElement = insertGUIConfigBoolNode(newGUIRoot, TEXT("SmartHighLight"), _nppGUI._enableSmartHilite);
6020  		GUIConfigElement->SetAttribute(TEXT("matchCase"), _nppGUI._smartHiliteCaseSensitive ? TEXT("yes") : TEXT("no"));
6021  		GUIConfigElement->SetAttribute(TEXT("wholeWordOnly"), _nppGUI._smartHiliteWordOnly ? TEXT("yes") : TEXT("no"));
6022  		GUIConfigElement->SetAttribute(TEXT("useFindSettings"), _nppGUI._smartHiliteUseFindSettings ? TEXT("yes") : TEXT("no"));
6023  		GUIConfigElement->SetAttribute(TEXT("onAnotherView"), _nppGUI._smartHiliteOnAnotherView ? TEXT("yes") : TEXT("no"));
6024  	}
6025  	if (_nppGUI._commandLineInterpreter.compare(CMD_INTERPRETER))
6026  	{
6027  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6028  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("commandLineInterpreter"));
6029  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._commandLineInterpreter.c_str()));
6030  	}
6031  	{
6032  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6033  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("DarkMode"));
6034  		NppDarkMode::setAdvancedOptions();
6035  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) {
6036  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
6037  			GUIConfigElement->SetAttribute(name, pStr);
6038  		};
6039  		setYesNoBoolAttribute(TEXT("enable"), _nppGUI._darkmode._isEnabled);
6040  		GUIConfigElement->SetAttribute(TEXT("colorTone"), _nppGUI._darkmode._colorTone);
6041  		GUIConfigElement->SetAttribute(TEXT("customColorTop"), _nppGUI._darkmode._customColors.pureBackground);
6042  		GUIConfigElement->SetAttribute(TEXT("customColorMenuHotTrack"), _nppGUI._darkmode._customColors.hotBackground);
6043  		GUIConfigElement->SetAttribute(TEXT("customColorActive"), _nppGUI._darkmode._customColors.softerBackground);
6044  		GUIConfigElement->SetAttribute(TEXT("customColorMain"), _nppGUI._darkmode._customColors.background);
6045  		GUIConfigElement->SetAttribute(TEXT("customColorError"), _nppGUI._darkmode._customColors.errorBackground);
6046  		GUIConfigElement->SetAttribute(TEXT("customColorText"), _nppGUI._darkmode._customColors.text);
6047  		GUIConfigElement->SetAttribute(TEXT("customColorDarkText"), _nppGUI._darkmode._customColors.darkerText);
6048  		GUIConfigElement->SetAttribute(TEXT("customColorDisabledText"), _nppGUI._darkmode._customColors.disabledText);
6049  		GUIConfigElement->SetAttribute(TEXT("customColorLinkText"), _nppGUI._darkmode._customColors.linkText);
6050  		GUIConfigElement->SetAttribute(TEXT("customColorEdge"), _nppGUI._darkmode._customColors.edge);
6051  		GUIConfigElement->SetAttribute(TEXT("customColorHotEdge"), _nppGUI._darkmode._customColors.hotEdge);
6052  		GUIConfigElement->SetAttribute(TEXT("customColorDisabledEdge"), _nppGUI._darkmode._customColors.disabledEdge);
6053  		setYesNoBoolAttribute(TEXT("enableWindowsMode"), _nppGUI._darkmode._advOptions._enableWindowsMode);
6054  		GUIConfigElement->SetAttribute(TEXT("darkThemeName"), _nppGUI._darkmode._advOptions._darkDefaults._xmlFileName.c_str());
6055  		GUIConfigElement->SetAttribute(TEXT("darkToolBarIconSet"), _nppGUI._darkmode._advOptions._darkDefaults._toolBarIconSet);
6056  		GUIConfigElement->SetAttribute(TEXT("darkTabIconSet"), _nppGUI._darkmode._advOptions._darkDefaults._tabIconSet);
6057  		setYesNoBoolAttribute(TEXT("darkTabUseTheme"), _nppGUI._darkmode._advOptions._darkDefaults._tabUseTheme);
6058  		GUIConfigElement->SetAttribute(TEXT("lightThemeName"), _nppGUI._darkmode._advOptions._lightDefaults._xmlFileName.c_str());
6059  		GUIConfigElement->SetAttribute(TEXT("lightToolBarIconSet"), _nppGUI._darkmode._advOptions._lightDefaults._toolBarIconSet);
6060  		GUIConfigElement->SetAttribute(TEXT("lightTabIconSet"), _nppGUI._darkmode._advOptions._lightDefaults._tabIconSet);
6061  		setYesNoBoolAttribute(TEXT("lightTabUseTheme"), _nppGUI._darkmode._advOptions._lightDefaults._tabUseTheme);
6062  	}
6063  	writeScintillaParams();
6064  	if (_nppGUI._isCmdlineNosessionActivated && dockMngNodeDup)
6065  	{
6066  		newGUIRoot->InsertEndChild(*dockMngNodeDup);
6067  		delete dockMngNodeDup;
6068  	}
6069  	else
6070  	{
6071  		insertDockingParamNode(newGUIRoot);
6072  	}
6073  }
6074  bool NppParameters::writeFindHistory()
6075  {
6076  	if (!_pXmlUserDoc) return false;
6077  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
6078  	if (!nppRoot)
6079  	{
6080  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
6081  	}
6082  	TiXmlNode *findHistoryRoot = nppRoot->FirstChildElement(TEXT("FindHistory"));
6083  	if (!findHistoryRoot)
6084  	{
6085  		TiXmlElement element(TEXT("FindHistory"));
6086  		findHistoryRoot = nppRoot->InsertEndChild(element);
6087  	}
6088  	findHistoryRoot->Clear();
6089  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryPath"),	_findHistory._nbMaxFindHistoryPath);
6090  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryFilter"),  _findHistory._nbMaxFindHistoryFilter);
6091  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryFind"),	_findHistory._nbMaxFindHistoryFind);
6092  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryReplace"), _findHistory._nbMaxFindHistoryReplace);
6093  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("matchWord"),				_findHistory._isMatchWord?TEXT("yes"):TEXT("no"));
6094  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("matchCase"),				_findHistory._isMatchCase?TEXT("yes"):TEXT("no"));
6095  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("wrap"),					_findHistory._isWrap?TEXT("yes"):TEXT("no"));
6096  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("directionDown"),			_findHistory._isDirectionDown?TEXT("yes"):TEXT("no"));
6097  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifRecuisive"),			_findHistory._isFifRecuisive?TEXT("yes"):TEXT("no"));
6098  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifInHiddenFolder"),		_findHistory._isFifInHiddenFolder?TEXT("yes"):TEXT("no"));
6099  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel1"),	    	_findHistory._isFifProjectPanel_1?TEXT("yes"):TEXT("no"));
6100  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel2"),	      	_findHistory._isFifProjectPanel_2?TEXT("yes"):TEXT("no"));
6101  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel3"),	       	_findHistory._isFifProjectPanel_3?TEXT("yes"):TEXT("no"));
6102  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifFilterFollowsDoc"),	_findHistory._isFilterFollowDoc?TEXT("yes"):TEXT("no"));
6103  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifFolderFollowsDoc"),	_findHistory._isFolderFollowDoc?TEXT("yes"):TEXT("no"));
6104  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("searchMode"), _findHistory._searchMode);
6105  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("transparencyMode"), _findHistory._transparencyMode);
6106  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("transparency"), _findHistory._transparency);
6107  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("dotMatchesNewline"),		_findHistory._dotMatchesNewline?TEXT("yes"):TEXT("no"));
6108  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("isSearch2ButtonsMode"),		_findHistory._isSearch2ButtonsMode?TEXT("yes"):TEXT("no"));
6109  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("regexBackward4PowerUser"),		_findHistory._regexBackward4PowerUser ? TEXT("yes") : TEXT("no"));
6110  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("bookmarkLine"), _findHistory._isBookmarkLine ? TEXT("yes") : TEXT("no"));
6111  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("purge"), _findHistory._isPurge ? TEXT("yes") : TEXT("no"));
6112  	TiXmlElement hist_element{TEXT("")};
6113  	hist_element.SetValue(TEXT("Path"));
6114  	for (size_t i = 0, len = _findHistory._findHistoryPaths.size(); i < len; ++i)
6115  	{
6116  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryPaths[i].c_str());
6117  		findHistoryRoot->InsertEndChild(hist_element);
6118  	}
6119  	hist_element.SetValue(TEXT("Filter"));
6120  	for (size_t i = 0, len = _findHistory._findHistoryFilters.size(); i < len; ++i)
6121  	{
6122  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryFilters[i].c_str());
6123  		findHistoryRoot->InsertEndChild(hist_element);
6124  	}
6125  	hist_element.SetValue(TEXT("Find"));
6126  	for (size_t i = 0, len = _findHistory._findHistoryFinds.size(); i < len; ++i)
6127  	{
6128  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryFinds[i].c_str());
6129  		findHistoryRoot->InsertEndChild(hist_element);
6130  	}
6131  	hist_element.SetValue(TEXT("Replace"));
6132  	for (size_t i = 0, len = _findHistory._findHistoryReplaces.size(); i < len; ++i)
6133  	{
6134  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryReplaces[i].c_str());
6135  		findHistoryRoot->InsertEndChild(hist_element);
6136  	}
6137  	return true;
6138  }
6139  void NppParameters::insertDockingParamNode(TiXmlNode *GUIRoot)
6140  {
6141  	TiXmlElement DMNode(TEXT("GUIConfig"));
6142  	DMNode.SetAttribute(TEXT("name"), TEXT("DockingManager"));
6143  	DMNode.SetAttribute(TEXT("leftWidth"), _nppGUI._dockingData._leftWidth);
6144  	DMNode.SetAttribute(TEXT("rightWidth"), _nppGUI._dockingData._rightWidth);
6145  	DMNode.SetAttribute(TEXT("topHeight"), _nppGUI._dockingData._topHeight);
6146  	DMNode.SetAttribute(TEXT("bottomHeight"), _nppGUI._dockingData._bottomHight);
6147  	for (size_t i = 0, len = _nppGUI._dockingData._flaotingWindowInfo.size(); i < len ; ++i)
6148  	{
6149  		FloatingWindowInfo & fwi = _nppGUI._dockingData._flaotingWindowInfo[i];
6150  		TiXmlElement FWNode(TEXT("FloatingWindow"));
6151  		FWNode.SetAttribute(TEXT("cont"), fwi._cont);
6152  		FWNode.SetAttribute(TEXT("x"), fwi._pos.left);
6153  		FWNode.SetAttribute(TEXT("y"), fwi._pos.top);
6154  		FWNode.SetAttribute(TEXT("width"), fwi._pos.right);
6155  		FWNode.SetAttribute(TEXT("height"), fwi._pos.bottom);
6156  		DMNode.InsertEndChild(FWNode);
6157  	}
6158  	for (size_t i = 0, len = _nppGUI._dockingData._pluginDockInfo.size() ; i < len ; ++i)
6159  	{
6160  		PluginDlgDockingInfo & pdi = _nppGUI._dockingData._pluginDockInfo[i];
6161  		TiXmlElement PDNode(TEXT("PluginDlg"));
6162  		PDNode.SetAttribute(TEXT("pluginName"), pdi._name);
6163  		PDNode.SetAttribute(TEXT("id"), pdi._internalID);
6164  		PDNode.SetAttribute(TEXT("curr"), pdi._currContainer);
6165  		PDNode.SetAttribute(TEXT("prev"), pdi._prevContainer);
6166  		PDNode.SetAttribute(TEXT("isVisible"), pdi._isVisible?TEXT("yes"):TEXT("no"));
6167  		DMNode.InsertEndChild(PDNode);
6168  	}
6169  	for (size_t i = 0, len = _nppGUI._dockingData._containerTabInfo.size(); i < len ; ++i)
6170  	{
6171  		ContainerTabInfo & cti = _nppGUI._dockingData._containerTabInfo[i];
6172  		TiXmlElement CTNode(TEXT("ActiveTabs"));
6173  		CTNode.SetAttribute(TEXT("cont"), cti._cont);
6174  		CTNode.SetAttribute(TEXT("activeTab"), cti._activeTab);
6175  		DMNode.InsertEndChild(CTNode);
6176  	}
6177  	GUIRoot->InsertEndChild(DMNode);
6178  }
6179  void NppParameters::writePrintSetting(TiXmlElement *element)
6180  {
6181  	const TCHAR *pStr = _nppGUI._printSettings._printLineNumber?TEXT("yes"):TEXT("no");
6182  	element->SetAttribute(TEXT("lineNumber"), pStr);
6183  	element->SetAttribute(TEXT("printOption"), _nppGUI._printSettings._printOption);
6184  	element->SetAttribute(TEXT("headerLeft"), _nppGUI._printSettings._headerLeft.c_str());
6185  	element->SetAttribute(TEXT("headerMiddle"), _nppGUI._printSettings._headerMiddle.c_str());
6186  	element->SetAttribute(TEXT("headerRight"), _nppGUI._printSettings._headerRight.c_str());
6187  	element->SetAttribute(TEXT("footerLeft"), _nppGUI._printSettings._footerLeft.c_str());
6188  	element->SetAttribute(TEXT("footerMiddle"), _nppGUI._printSettings._footerMiddle.c_str());
6189  	element->SetAttribute(TEXT("footerRight"), _nppGUI._printSettings._footerRight.c_str());
6190  	element->SetAttribute(TEXT("headerFontName"), _nppGUI._printSettings._headerFontName.c_str());
6191  	element->SetAttribute(TEXT("headerFontStyle"), _nppGUI._printSettings._headerFontStyle);
6192  	element->SetAttribute(TEXT("headerFontSize"), _nppGUI._printSettings._headerFontSize);
6193  	element->SetAttribute(TEXT("footerFontName"), _nppGUI._printSettings._footerFontName.c_str());
6194  	element->SetAttribute(TEXT("footerFontStyle"), _nppGUI._printSettings._footerFontStyle);
6195  	element->SetAttribute(TEXT("footerFontSize"), _nppGUI._printSettings._footerFontSize);
6196  	element->SetAttribute(TEXT("margeLeft"), _nppGUI._printSettings._marge.left);
6197  	element->SetAttribute(TEXT("margeRight"), _nppGUI._printSettings._marge.right);
6198  	element->SetAttribute(TEXT("margeTop"), _nppGUI._printSettings._marge.top);
6199  	element->SetAttribute(TEXT("margeBottom"), _nppGUI._printSettings._marge.bottom);
6200  }
6201  void NppParameters::writeExcludedLangList(TiXmlElement *element)
6202  {
6203  	int g0 = 0; 
6204  	int g1 = 0; 
6205  	int g2 = 0; 
6206  	int g3 = 0; 
6207  	int g4 = 0; 
6208  	int g5 = 0; 
6209  	int g6 = 0; 
6210  	int g7 = 0; 
6211  	int g8 = 0; 
6212  	int g9 = 0; 
6213  	int g10= 0; 
6214  	int g11= 0; 
6215  	int g12= 0; 
6216  	const int groupNbMember = 8;
6217  	for (size_t i = 0, len = _nppGUI._excludedLangList.size(); i < len ; ++i)
6218  	{
6219  		LangType langType = _nppGUI._excludedLangList[i]._langType;
6220  		if (langType >= L_EXTERNAL && langType < L_END)
6221  			continue;
6222  		int nGrp = langType / groupNbMember;
6223  		int nMask = 1 << langType % groupNbMember;
6224  		switch (nGrp)
6225  		{
6226  			case 0 :
6227  				g0 |= nMask;
6228  				break;
6229  			case 1 :
6230  				g1 |= nMask;
6231  				break;
6232  			case 2 :
6233  				g2 |= nMask;
6234  				break;
6235  			case 3 :
6236  				g3 |= nMask;
6237  				break;
6238  			case 4 :
6239  				g4 |= nMask;
6240  				break;
6241  			case 5 :
6242  				g5 |= nMask;
6243  				break;
6244  			case 6 :
6245  				g6 |= nMask;
6246  				break;
6247  			case 7 :
6248  				g7 |= nMask;
6249  				break;
6250  			case 8:
6251  				g8 |= nMask;
6252  				break;
6253  			case 9:
6254  				g9 |= nMask;
6255  				break;
6256  			case 10:
6257  				g10 |= nMask;
6258  				break;
6259  			case 11:
6260  				g11 |= nMask;
6261  				break;
6262  			case 12:
6263  				g12 |= nMask;
6264  				break;
6265  		}
6266  	}
6267  	element->SetAttribute(TEXT("gr0"), g0);
6268  	element->SetAttribute(TEXT("gr1"), g1);
6269  	element->SetAttribute(TEXT("gr2"), g2);
6270  	element->SetAttribute(TEXT("gr3"), g3);
6271  	element->SetAttribute(TEXT("gr4"), g4);
6272  	element->SetAttribute(TEXT("gr5"), g5);
6273  	element->SetAttribute(TEXT("gr6"), g6);
6274  	element->SetAttribute(TEXT("gr7"), g7);
6275  	element->SetAttribute(TEXT("gr8"), g8);
6276  	element->SetAttribute(TEXT("gr9"), g9);
6277  	element->SetAttribute(TEXT("gr10"), g10);
6278  	element->SetAttribute(TEXT("gr11"), g11);
6279  	element->SetAttribute(TEXT("gr12"), g12);
6280  }
6281  TiXmlElement * NppParameters::insertGUIConfigBoolNode(TiXmlNode *r2w, const TCHAR *name, bool bVal)
6282  {
6283  	const TCHAR *pStr = bVal?TEXT("yes"):TEXT("no");
6284  	TiXmlElement *GUIConfigElement = (r2w->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6285  	GUIConfigElement->SetAttribute(TEXT("name"), name);
6286  	GUIConfigElement->InsertEndChild(TiXmlText(pStr));
6287  	return GUIConfigElement;
6288  }
6289  int RGB2int(COLORREF color)
6290  {
6291  	return (((((DWORD)color) & 0x0000FF) << 16) | ((((DWORD)color) & 0x00FF00)) | ((((DWORD)color) & 0xFF0000) >> 16));
6292  }
6293  int NppParameters::langTypeToCommandID(LangType lt) const
6294  {
6295  	int id;
6296  	switch (lt)
6297  	{
6298  		case L_C :
6299  			id = IDM_LANG_C; break;
6300  		case L_CPP :
6301  			id = IDM_LANG_CPP; break;
6302  		case L_JAVA :
6303  			id = IDM_LANG_JAVA;	break;
6304  		case L_CS :
6305  			id = IDM_LANG_CS; break;
6306  		case L_OBJC :
6307  			id = IDM_LANG_OBJC;	break;
6308  		case L_HTML :
6309  			id = IDM_LANG_HTML;	break;
6310  		case L_XML :
6311  			id = IDM_LANG_XML; break;
6312  		case L_JS :
6313  		case L_JAVASCRIPT:
6314  			id = IDM_LANG_JS; break;
6315  		case L_JSON:
6316  			id = IDM_LANG_JSON; break;
6317  		case L_JSON5:
6318  			id = IDM_LANG_JSON5; break;
6319  		case L_PHP :
6320  			id = IDM_LANG_PHP; break;
6321  		case L_ASP :
6322  			id = IDM_LANG_ASP; break;
6323  		case L_JSP :
6324  			id = IDM_LANG_JSP; break;
6325  		case L_CSS :
6326  			id = IDM_LANG_CSS; break;
6327  		case L_LUA :
6328  			id = IDM_LANG_LUA; break;
6329  		case L_PERL :
6330  			id = IDM_LANG_PERL; break;
6331  		case L_PYTHON :
6332  			id = IDM_LANG_PYTHON; break;
6333  		case L_BATCH :
6334  			id = IDM_LANG_BATCH; break;
6335  		case L_PASCAL :
6336  			id = IDM_LANG_PASCAL; break;
6337  		case L_MAKEFILE :
6338  			id = IDM_LANG_MAKEFILE;	break;
6339  		case L_INI :
6340  			id = IDM_LANG_INI; break;
6341  		case L_ASCII :
6342  			id = IDM_LANG_ASCII; break;
6343  		case L_RC :
6344  			id = IDM_LANG_RC; break;
6345  		case L_TEX :
6346  			id = IDM_LANG_TEX; break;
6347  		case L_FORTRAN :
6348  			id = IDM_LANG_FORTRAN; break;
6349  		case L_FORTRAN_77 :
6350  			id = IDM_LANG_FORTRAN_77; break;
6351  		case L_BASH :
6352  			id = IDM_LANG_BASH; break;
6353  		case L_FLASH :
6354  			id = IDM_LANG_FLASH; break;
6355  		case L_NSIS :
6356  			id = IDM_LANG_NSIS; break;
6357  		case L_USER :
6358  			id = IDM_LANG_USER; break;
6359  		case L_SQL :
6360  			id = IDM_LANG_SQL; break;
6361  		case L_MSSQL :
6362  			id = IDM_LANG_MSSQL; break;
6363  		case L_VB :
6364  			id = IDM_LANG_VB; break;
6365  		case L_TCL :
6366  			id = IDM_LANG_TCL; break;
6367  		case L_LISP :
6368  			id = IDM_LANG_LISP; break;
6369  		case L_SCHEME :
6370  			id = IDM_LANG_SCHEME; break;
6371  		case L_ASM :
6372  			id = IDM_LANG_ASM; break;
6373  		case L_DIFF :
6374  			id = IDM_LANG_DIFF; break;
6375  		case L_PROPS :
6376  			id = IDM_LANG_PROPS; break;
6377  		case L_PS :
6378  			id = IDM_LANG_PS; break;
6379  		case L_RUBY :
6380  			id = IDM_LANG_RUBY; break;
6381  		case L_SMALLTALK :
6382  			id = IDM_LANG_SMALLTALK; break;
6383  		case L_VHDL :
6384  			id = IDM_LANG_VHDL; break;
6385  		case L_ADA :
6386  			id = IDM_LANG_ADA; break;
6387  		case L_MATLAB :
6388  			id = IDM_LANG_MATLAB; break;
6389  		case L_HASKELL :
6390  			id = IDM_LANG_HASKELL; break;
6391  		case L_KIX :
6392  			id = IDM_LANG_KIX; break;
6393  		case L_AU3 :
6394  			id = IDM_LANG_AU3; break;
6395  		case L_VERILOG :
6396  			id = IDM_LANG_VERILOG; break;
6397  		case L_CAML :
6398  			id = IDM_LANG_CAML; break;
6399  		case L_INNO :
6400  			id = IDM_LANG_INNO; break;
6401  		case L_CMAKE :
6402  			id = IDM_LANG_CMAKE; break;
6403  		case L_YAML :
6404  			id = IDM_LANG_YAML; break;
6405  		case L_COBOL :
6406  			id = IDM_LANG_COBOL; break;
6407  		case L_D :
6408  			id = IDM_LANG_D; break;
6409  		case L_GUI4CLI :
6410  			id = IDM_LANG_GUI4CLI; break;
6411  		case L_POWERSHELL :
6412  			id = IDM_LANG_POWERSHELL; break;
6413  		case L_R :
6414  			id = IDM_LANG_R; break;
6415  		case L_COFFEESCRIPT :
6416  			id = IDM_LANG_COFFEESCRIPT; break;
6417  		case L_BAANC:
6418  			id = IDM_LANG_BAANC; break;
6419  		case L_SREC :
6420  			id = IDM_LANG_SREC; break;
6421  		case L_IHEX :
6422  			id = IDM_LANG_IHEX; break;
6423  		case L_TEHEX :
6424  			id = IDM_LANG_TEHEX; break;
6425  		case L_SWIFT:
6426  			id = IDM_LANG_SWIFT; break;
6427  		case L_ASN1 :
6428  			id = IDM_LANG_ASN1; break;
6429          case L_AVS :
6430  			id = IDM_LANG_AVS; break;
6431  		case L_BLITZBASIC :
6432  			id = IDM_LANG_BLITZBASIC; break;
6433  		case L_PUREBASIC :
6434  			id = IDM_LANG_PUREBASIC; break;
6435  		case L_FREEBASIC :
6436  			id = IDM_LANG_FREEBASIC; break;
6437  		case L_CSOUND :
6438  			id = IDM_LANG_CSOUND; break;
6439  		case L_ERLANG :
6440  			id = IDM_LANG_ERLANG; break;
6441  		case L_ESCRIPT :
6442  			id = IDM_LANG_ESCRIPT; break;
6443  		case L_FORTH :
6444  			id = IDM_LANG_FORTH; break;
6445  		case L_LATEX :
6446  			id = IDM_LANG_LATEX; break;
6447  		case L_MMIXAL :
6448  			id = IDM_LANG_MMIXAL; break;
6449  		case L_NIM :
6450  			id = IDM_LANG_NIM; break;
6451  		case L_NNCRONTAB :
6452  			id = IDM_LANG_NNCRONTAB; break;
6453  		case L_OSCRIPT :
6454  			id = IDM_LANG_OSCRIPT; break;
6455  		case L_REBOL :
6456  			id = IDM_LANG_REBOL; break;
6457  		case L_REGISTRY :
6458  			id = IDM_LANG_REGISTRY; break;
6459  		case L_RUST :
6460  			id = IDM_LANG_RUST; break;
6461  		case L_SPICE :
6462  			id = IDM_LANG_SPICE; break;
6463  		case L_TXT2TAGS :
6464  			id = IDM_LANG_TXT2TAGS; break;
6465  		case L_VISUALPROLOG:
6466  			id = IDM_LANG_VISUALPROLOG; break;
6467  		case L_TYPESCRIPT:
6468  			id = IDM_LANG_TYPESCRIPT; break;
6469  		case L_GDSCRIPT:
6470  			id = IDM_LANG_GDSCRIPT; break;
6471  		case L_HOLLYWOOD:
6472  			id = IDM_LANG_HOLLYWOOD; break;
6473  		case L_SEARCHRESULT :
6474  			id = -1;	break;
6475  		case L_TEXT :
6476  			id = IDM_LANG_TEXT;	break;
6477  		default :
6478  			if (lt >= L_EXTERNAL && lt < L_END)
6479  				id = lt - L_EXTERNAL + IDM_LANG_EXTERNAL;
6480  			else
6481  				id = IDM_LANG_TEXT;
6482  	}
6483  	return id;
6484  }
6485  generic_string NppParameters:: getWinVersionStr() const
6486  {
6487  	switch (_winVersion)
6488  	{
6489  		case WV_WIN32S: return TEXT("Windows 3.1");
6490  		case WV_95: return TEXT("Windows 95");
6491  		case WV_98: return TEXT("Windows 98");
6492  		case WV_ME: return TEXT("Windows Millennium Edition");
6493  		case WV_NT: return TEXT("Windows NT");
6494  		case WV_W2K: return TEXT("Windows 2000");
6495  		case WV_XP: return TEXT("Windows XP");
6496  		case WV_S2003: return TEXT("Windows Server 2003");
6497  		case WV_XPX64: return TEXT("Windows XP 64 bits");
6498  		case WV_VISTA: return TEXT("Windows Vista");
6499  		case WV_WIN7: return TEXT("Windows 7");
6500  		case WV_WIN8: return TEXT("Windows 8");
6501  		case WV_WIN81: return TEXT("Windows 8.1");
6502  		case WV_WIN10: return TEXT("Windows 10");
6503  		case WV_WIN11: return TEXT("Windows 11");
6504  		default: &bsol;*case WV_UNKNOWN:*/ return TEXT("Windows unknown version");
6505  	}
6506  }
6507  generic_string NppParameters::getWinVerBitStr() const
6508  {
6509  	switch (_platForm)
6510  	{
6511  	case PF_X86:
6512  		return TEXT("32-bit");
6513  	case PF_X64:
6514  	case PF_IA64:
6515  	case PF_ARM64:
6516  		return TEXT("64-bit");
6517  	default:
6518  		return TEXT("Unknown-bit");
6519  	}
6520  }
6521  generic_string NppParameters::writeStyles(LexerStylerArray & lexersStylers, StyleArray & globalStylers)
6522  {
6523  	TiXmlNode *lexersRoot = (_pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("LexerStyles"));
6524  	for (TiXmlNode *childNode = lexersRoot->FirstChildElement(TEXT("LexerType"));
6525  		childNode ;
6526  		childNode = childNode->NextSibling(TEXT("LexerType")))
6527  	{
6528  		TiXmlElement *element = childNode->ToElement();
6529  		const TCHAR *nm = element->Attribute(TEXT("name"));
6530  		LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6531  		LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6532  		if (pLs)
6533  		{
6534  			const TCHAR *extStr = pLs->getLexerUserExt();
6535  			element->SetAttribute(TEXT("ext"), extStr);
6536  			for (TiXmlNode *grChildNode = childNode->FirstChildElement(TEXT("WordsStyle"));
6537  					grChildNode ;
6538  					grChildNode = grChildNode->NextSibling(TEXT("WordsStyle")))
6539  			{
6540  				TiXmlElement *grElement = grChildNode->ToElement();
6541  				const TCHAR *styleName = grElement->Attribute(TEXT("name"));
6542  				const Style * pStyle = pLs->findByName(styleName);
6543  				Style * pStyle2Sync = pLs2 ? pLs2->findByName(styleName) : nullptr;
6544  				if (pStyle && pStyle2Sync)
6545  				{
6546  					writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6547  				}
6548  			}
6549  		}
6550  	}
6551  	for (size_t x = 0; x < _pXmlExternalLexerDoc.size(); ++x)
6552  	{
6553  		TiXmlNode* lexersRoot2 = ( _pXmlExternalLexerDoc[x]->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("LexerStyles"));
6554  		for (TiXmlNode* childNode = lexersRoot2->FirstChildElement(TEXT("LexerType"));
6555  			childNode ;
6556  			childNode = childNode->NextSibling(TEXT("LexerType")))
6557  		{
6558  			TiXmlElement *element = childNode->ToElement();
6559  			const TCHAR *nm = element->Attribute(TEXT("name"));
6560  			LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6561  			LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6562  			if (pLs)
6563  			{
6564  				const TCHAR *extStr = pLs->getLexerUserExt();
6565  				element->SetAttribute(TEXT("ext"), extStr);
6566  				for (TiXmlNode *grChildNode = childNode->FirstChildElement(TEXT("WordsStyle"));
6567  						grChildNode ;
6568  						grChildNode = grChildNode->NextSibling(TEXT("WordsStyle")))
6569  				{
6570  					TiXmlElement *grElement = grChildNode->ToElement();
6571  					const TCHAR *styleName = grElement->Attribute(TEXT("name"));
6572  					const Style * pStyle = pLs->findByName(styleName);
6573  					Style * pStyle2Sync = pLs2 ? pLs2->findByName(styleName) : nullptr;
6574  					if (pStyle && pStyle2Sync)
6575  					{
6576  						writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6577  					}
6578  				}
6579  			}
6580  		}
6581  		_pXmlExternalLexerDoc[x]->SaveFile();
6582  	}
6583  	TiXmlNode *globalStylesRoot = (_pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("GlobalStyles"));
6584  	for (TiXmlNode *childNode = globalStylesRoot->FirstChildElement(TEXT("WidgetStyle"));
6585  		childNode ;
6586  		childNode = childNode->NextSibling(TEXT("WidgetStyle")))
6587  	{
6588  		TiXmlElement *pElement = childNode->ToElement();
6589  		const TCHAR *styleName = pElement->Attribute(TEXT("name"));
6590  		const Style * pStyle = _widgetStyleArray.findByName(styleName);
6591  		Style * pStyle2Sync = globalStylers.findByName(styleName);
6592  		if (pStyle && pStyle2Sync)
6593  		{
6594  			writeStyle2Element(*pStyle, *pStyle2Sync, pElement);
6595  		}
6596  	}
6597  	bool isSaved = _pXmlUserStylerDoc->SaveFile();
6598  	if (!isSaved)
6599  	{
6600  		auto savePath = _themeSwitcher.getSavePathFrom(_pXmlUserStylerDoc->Value());
6601  		if (!savePath.empty())
6602  		{
6603  			_pXmlUserStylerDoc->SaveFile(savePath.c_str());
6604  			return savePath;
6605  		}
6606  	}
6607  	return TEXT("");
6608  }
6609  bool NppParameters::insertTabInfo(const TCHAR *langName, int tabInfo)
6610  {
6611  	if (!_pXmlDoc) return false;
6612  	TiXmlNode *langRoot = (_pXmlDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("Languages"));
6613  	for (TiXmlNode *childNode = langRoot->FirstChildElement(TEXT("Language"));
6614  		childNode ;
6615  		childNode = childNode->NextSibling(TEXT("Language")))
6616  	{
6617  		TiXmlElement *element = childNode->ToElement();
6618  		const TCHAR *nm = element->Attribute(TEXT("name"));
6619  		if (nm && lstrcmp(langName, nm) == 0)
6620  		{
6621  			childNode->ToElement()->SetAttribute(TEXT("tabSettings"), tabInfo);
6622  			_pXmlDoc->SaveFile();
6623  			return true;
6624  		}
6625  	}
6626  	return false;
6627  }
6628  void NppParameters::writeStyle2Element(const Style & style2Write, Style & style2Sync, TiXmlElement *element)
6629  {
6630  	if (HIBYTE(HIWORD(style2Write._fgColor)) != 0xFF)
6631  	{
6632  		int rgbVal = RGB2int(style2Write._fgColor);
6633  		TCHAR fgStr[7];
6634  		wsprintf(fgStr, TEXT("%.6X"), rgbVal);
6635  		element->SetAttribute(TEXT("fgColor"), fgStr);
6636  	}
6637  	if (HIBYTE(HIWORD(style2Write._bgColor)) != 0xFF)
6638  	{
6639  		int rgbVal = RGB2int(style2Write._bgColor);
6640  		TCHAR bgStr[7];
6641  		wsprintf(bgStr, TEXT("%.6X"), rgbVal);
6642  		element->SetAttribute(TEXT("bgColor"), bgStr);
6643  	}
6644  	if (style2Write._colorStyle != COLORSTYLE_ALL)
6645  	{
6646  		element->SetAttribute(TEXT("colorStyle"), style2Write._colorStyle);
6647  	}
6648  	if (!style2Write._fontName.empty())
6649  	{
6650  		const TCHAR * oldFontName = element->Attribute(TEXT("fontName"));
6651  		if (oldFontName && oldFontName != style2Write._fontName)
6652  		{
6653  			element->SetAttribute(TEXT("fontName"), style2Write._fontName);
6654  			style2Sync._fontName = style2Write._fontName;
6655  		}
6656  	}
6657  	if (style2Write._fontSize != STYLE_NOT_USED)
6658  	{
6659  		if (!style2Write._fontSize)
6660  			element->SetAttribute(TEXT("fontSize"), TEXT(""));
6661  		else
6662  			element->SetAttribute(TEXT("fontSize"), style2Write._fontSize);
6663  	}
6664  	if (style2Write._fontStyle != STYLE_NOT_USED)
6665  	{
6666  		element->SetAttribute(TEXT("fontStyle"), style2Write._fontStyle);
6667  	}
6668  	if (!style2Write._keywords.empty())
6669  	{
6670  		TiXmlNode *teteDeNoeud = element->LastChild();
6671  		if (teteDeNoeud)
6672  			teteDeNoeud->SetValue(style2Write._keywords.c_str());
6673  		else
6674  			element->InsertEndChild(TiXmlText(style2Write._keywords.c_str()));
6675  	}
6676  }
6677  void NppParameters::insertUserLang2Tree(TiXmlNode *node, UserLangContainer *userLang)
6678  {
6679  	TiXmlElement *rootElement = (node->InsertEndChild(TiXmlElement(TEXT("UserLang"))))->ToElement();
6680  	TCHAR temp[32];
6681  	generic_string udlVersion;
6682  	udlVersion += _itow(SCE_UDL_VERSION_MAJOR, temp, 10);
6683  	udlVersion += TEXT(".");
6684  	udlVersion += _itow(SCE_UDL_VERSION_MINOR, temp, 10);
6685  	rootElement->SetAttribute(TEXT("name"), userLang->_name);
6686  	rootElement->SetAttribute(TEXT("ext"), userLang->_ext);
6687  	if (userLang->_isDarkModeTheme)
6688  		rootElement->SetAttribute(TEXT("darkModeTheme"), TEXT("yes"));
6689  	rootElement->SetAttribute(TEXT("udlVersion"), udlVersion.c_str());
6690  	TiXmlElement *settingsElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("Settings"))))->ToElement();
6691  	{
6692  		TiXmlElement *globalElement = (settingsElement->InsertEndChild(TiXmlElement(TEXT("Global"))))->ToElement();
6693  		globalElement->SetAttribute(TEXT("caseIgnored"),			userLang->_isCaseIgnored ? TEXT("yes"):TEXT("no"));
6694  		globalElement->SetAttribute(TEXT("allowFoldOfComments"),	userLang->_allowFoldOfComments ? TEXT("yes"):TEXT("no"));
6695  		globalElement->SetAttribute(TEXT("foldCompact"),			userLang->_foldCompact ? TEXT("yes"):TEXT("no"));
6696  		globalElement->SetAttribute(TEXT("forcePureLC"),			userLang->_forcePureLC);
6697  		globalElement->SetAttribute(TEXT("decimalSeparator"),	   userLang->_decimalSeparator);
6698  		TiXmlElement *prefixElement = (settingsElement->InsertEndChild(TiXmlElement(TEXT("Prefix"))))->ToElement();
6699  		for (int i = 0 ; i < SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
6700  			prefixElement->SetAttribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1], userLang->_isPrefix[i]?TEXT("yes"):TEXT("no"));
6701  	}
6702  	TiXmlElement *kwlElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("KeywordLists"))))->ToElement();
6703  	for (int i = 0 ; i < SCE_USER_KWLIST_TOTAL ; ++i)
6704  	{
6705  		TiXmlElement *kwElement = (kwlElement->InsertEndChild(TiXmlElement(TEXT("Keywords"))))->ToElement();
6706  		kwElement->SetAttribute(TEXT("name"), globalMappper().keywordNameMapper[i]);
6707  		kwElement->InsertEndChild(TiXmlText(userLang->_keywordLists[i]));
6708  	}
6709  	TiXmlElement *styleRootElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("Styles"))))->ToElement();
6710  	for (const Style & style2Write : userLang->_styles)
6711  	{
6712  		TiXmlElement *styleElement = (styleRootElement->InsertEndChild(TiXmlElement(TEXT("WordsStyle"))))->ToElement();
6713  		if (style2Write._styleID == -1)
6714  			continue;
6715  		styleElement->SetAttribute(TEXT("name"), style2Write._styleDesc);
6716  		{
6717  			int rgbVal = RGB2int(style2Write._fgColor);
6718  			TCHAR fgStr[7];
6719  			wsprintf(fgStr, TEXT("%.6X"), rgbVal);
6720  			styleElement->SetAttribute(TEXT("fgColor"), fgStr);
6721  		}
6722  		{
6723  			int rgbVal = RGB2int(style2Write._bgColor);
6724  			TCHAR bgStr[7];
6725  			wsprintf(bgStr, TEXT("%.6X"), rgbVal);
6726  			styleElement->SetAttribute(TEXT("bgColor"), bgStr);
6727  		}
6728  		if (style2Write._colorStyle != COLORSTYLE_ALL)
6729  		{
6730  			styleElement->SetAttribute(TEXT("colorStyle"), style2Write._colorStyle);
6731  		}
6732  		if (!style2Write._fontName.empty())
6733  		{
6734  			styleElement->SetAttribute(TEXT("fontName"), style2Write._fontName);
6735  		}
6736  		if (style2Write._fontStyle == STYLE_NOT_USED)
6737  		{
6738  			styleElement->SetAttribute(TEXT("fontStyle"), TEXT("0"));
6739  		}
6740  		else
6741  		{
6742  			styleElement->SetAttribute(TEXT("fontStyle"), style2Write._fontStyle);
6743  		}
6744  		if (style2Write._fontSize != STYLE_NOT_USED)
6745  		{
6746  			if (!style2Write._fontSize)
6747  				styleElement->SetAttribute(TEXT("fontSize"), TEXT(""));
6748  			else
6749  				styleElement->SetAttribute(TEXT("fontSize"), style2Write._fontSize);
6750  		}
6751  		styleElement->SetAttribute(TEXT("nesting"), style2Write._nesting);
6752  	}
6753  }
6754  void NppParameters::addUserModifiedIndex(size_t index)
6755  {
6756  	size_t len = _customizedShortcuts.size();
6757  	bool found = false;
6758  	for (size_t i = 0; i < len; ++i)
6759  	{
6760  		if (_customizedShortcuts[i] == index)
6761  		{
6762  			found = true;
6763  			break;
6764  		}
6765  	}
6766  	if (!found)
6767  	{
6768  		_customizedShortcuts.push_back(index);
6769  	}
6770  }
6771  void NppParameters::addPluginModifiedIndex(size_t index)
6772  {
6773  	size_t len = _pluginCustomizedCmds.size();
6774  	bool found = false;
6775  	for (size_t i = 0; i < len; ++i)
6776  	{
6777  		if (_pluginCustomizedCmds[i] == index)
6778  		{
6779  			found = true;
6780  			break;
6781  		}
6782  	}
6783  	if (!found)
6784  	{
6785  		_pluginCustomizedCmds.push_back(index);
6786  	}
6787  }
6788  void NppParameters::addScintillaModifiedIndex(int index)
6789  {
6790  	size_t len = _scintillaModifiedKeyIndices.size();
6791  	bool found = false;
6792  	for (size_t i = 0; i < len; ++i)
6793  	{
6794  		if (_scintillaModifiedKeyIndices[i] == index)
6795  		{
6796  			found = true;
6797  			break;
6798  		}
6799  	}
6800  	if (!found)
6801  	{
6802  		_scintillaModifiedKeyIndices.push_back(index);
6803  	}
6804  }
6805  void NppParameters::safeWow64EnableWow64FsRedirection(BOOL Wow64FsEnableRedirection)
6806  {
6807  	HMODULE kernel = GetModuleHandle(TEXT("kernel32"));
6808  	if (kernel)
6809  	{
6810  		BOOL isWow64 = FALSE;
6811  		typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
6812  		LPFN_ISWOW64PROCESS IsWow64ProcessFunc = (LPFN_ISWOW64PROCESS) GetProcAddress(kernel,"IsWow64Process");
6813  		if (IsWow64ProcessFunc)
6814  		{
6815  			IsWow64ProcessFunc(GetCurrentProcess(),&isWow64);
6816  			if (isWow64)
6817  			{
6818  				typedef BOOL (WINAPI *LPFN_WOW64ENABLEWOW64FSREDIRECTION)(BOOL);
6819  				LPFN_WOW64ENABLEWOW64FSREDIRECTION Wow64EnableWow64FsRedirectionFunc = (LPFN_WOW64ENABLEWOW64FSREDIRECTION)GetProcAddress(kernel, "Wow64EnableWow64FsRedirection");
6820  				if (Wow64EnableWow64FsRedirectionFunc)
6821  				{
6822  					Wow64EnableWow64FsRedirectionFunc(Wow64FsEnableRedirection);
6823  				}
6824  			}
6825  		}
6826  	}
6827  }
6828  void NppParameters::setUdlXmlDirtyFromIndex(size_t i)
6829  {
6830  	for (auto& uxfs : _pXmlUserLangsDoc)
6831  	{
6832  		if (i >= uxfs._indexRange.first && i < uxfs._indexRange.second)
6833  		{
6834  			uxfs._isDirty = true;
6835  			return;
6836  		}
6837  	}
6838  }
6839  void NppParameters::removeIndexFromXmlUdls(size_t i)
6840  {
6841  	bool isUpdateBegin = false;
6842  	for (auto& uxfs : _pXmlUserLangsDoc)
6843  	{
6844  		if (!isUpdateBegin && (i >= uxfs._indexRange.first && i < uxfs._indexRange.second)) 
6845  		{
6846  			if (uxfs._indexRange.second > 0)
6847  				uxfs._indexRange.second -= 1;
6848  			uxfs._isDirty = true;
6849  			isUpdateBegin = true;
6850  		}
6851  		else if (isUpdateBegin)
6852  		{
6853  			if (uxfs._indexRange.first > 0)
6854  				uxfs._indexRange.first -= 1;
6855  			if (uxfs._indexRange.second > 0)
6856  				uxfs._indexRange.second -= 1;
6857  		}
6858  	}
6859  }
6860  void NppParameters::setUdlXmlDirtyFromXmlDoc(const TiXmlDocument* xmlDoc)
6861  {
6862  	for (auto& uxfs : _pXmlUserLangsDoc)
6863  	{
6864  		if (xmlDoc == uxfs._udlXmlDoc)
6865  		{
6866  			uxfs._isDirty = true;
6867  			return;
6868  		}
6869  	}
6870  }
6871  Date::Date(const TCHAR *dateStr)
6872  {
6873  	assert(dateStr);
6874  	int D = lstrlen(dateStr);
6875  	if ( 8==D )
6876  	{
6877  		generic_string ds(dateStr);
6878  		generic_string yyyy(ds, 0, 4);
6879  		generic_string mm(ds, 4, 2);
6880  		generic_string dd(ds, 6, 2);
6881  		int y = _wtoi(yyyy.c_str());
6882  		int m = _wtoi(mm.c_str());
6883  		int d = _wtoi(dd.c_str());
6884  		if ((y > 0 && y <= 9999) && (m > 0 && m <= 12) && (d > 0 && d <= 31))
6885  		{
6886  			_year = y;
6887  			_month = m;
6888  			_day = d;
6889  			return;
6890  		}
6891  	}
6892  	now();
6893  }
6894  Date::Date(int nbDaysFromNow)
6895  {
6896  	const time_t oneDay = (60 * 60 * 24);
6897  	time_t rawtime;
6898  	tm* timeinfo;
6899  	time(&rawtime);
6900  	rawtime += (nbDaysFromNow * oneDay);
6901  	timeinfo = localtime(&rawtime);
6902  	if (timeinfo)
6903  	{
6904  		_year = timeinfo->tm_year + 1900;
6905  		_month = timeinfo->tm_mon + 1;
6906  		_day = timeinfo->tm_mday;
6907  	}
6908  }
6909  void Date::now()
6910  {
6911  	time_t rawtime;
6912  	tm* timeinfo;
6913  	time(&rawtime);
6914  	timeinfo = localtime(&rawtime);
6915  	if (timeinfo)
6916  	{
6917  		_year = timeinfo->tm_year + 1900;
6918  		_month = timeinfo->tm_mon + 1;
6919  		_day = timeinfo->tm_mday;
6920  	}
6921  }
6922  EolType convertIntToFormatType(int value, EolType defvalue)
6923  {
6924  	switch (value)
6925  	{
6926  		case static_cast<LPARAM>(EolType::windows) :
6927  			return EolType::windows;
6928  		case static_cast<LPARAM>(EolType::macos) :
6929  				return EolType::macos;
6930  		case static_cast<LPARAM>(EolType::unix) :
6931  			return EolType::unix;
6932  		default:
6933  			return defvalue;
6934  	}
6935  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</h3>
            <pre><code>1  #include <time.h>
2  #include <shlwapi.h>
3  #include <shlobj.h>
4  #include "Parameters.h"
5  #include "ScintillaEditView.h"
6  #include "keys.h"
7  #include "localization.h"
8  #include "localizationString.h"
9  #include "UserDefineDialog.h"
10  #include "WindowsDlgRc.h"
11  #ifdef _MSC_VER
12  #pragma warning(disable : 4996) 
13  #endif
14  using namespace std;
15  namespace 
16  {
17  struct WinMenuKeyDefinition 
18  {
19  	int vKey;
20  	int functionId;
21  	bool isCtrl;
22  	bool isAlt;
23  	bool isShift;
24  	const TCHAR * specialName;		
25  };
26  struct ScintillaKeyDefinition
27  {
28  	const TCHAR * name;
29  	int functionId;
30  	bool isCtrl;
31  	bool isAlt;
32  	bool isShift;
33  	int vKey;
34  	int redirFunctionId;	
35  };
36  static const WinMenuKeyDefinition winKeyDefs[] =
37  {
38  	{ VK_N,       IDM_FILE_NEW,                                 true,  false, false, nullptr },
39  	{ VK_O,       IDM_FILE_OPEN,                                true,  false, false, nullptr },
40  	{ VK_NULL,    IDM_FILE_OPEN_FOLDER,                         false, false, false, TEXT("Open containing folder in Explorer") },
41  	{ VK_NULL,    IDM_FILE_OPEN_CMD,                            false, false, false, TEXT("Open containing folder in Command Prompt") },
42  	{ VK_NULL,    IDM_FILE_OPEN_DEFAULT_VIEWER,                 false, false, false, nullptr },
43  	{ VK_NULL,    IDM_FILE_OPENFOLDERASWORSPACE,                false, false, false, nullptr },
44  	{ VK_R,       IDM_FILE_RELOAD,                              true,  false, false, nullptr },
45  	{ VK_S,       IDM_FILE_SAVE,                                true,  false, false, nullptr },
46  	{ VK_S,       IDM_FILE_SAVEAS,                              true,  true,  false, nullptr },
47  	{ VK_NULL,    IDM_FILE_SAVECOPYAS,                          false, false, false, nullptr },
48  	{ VK_S,       IDM_FILE_SAVEALL,                             true,  false, true,  nullptr },
49  	{ VK_NULL,    IDM_FILE_RENAME,                              false, false, false, nullptr },
50  	{ VK_W,       IDM_FILE_CLOSE,                               true,  false, false, nullptr },
51  	{ VK_W,       IDM_FILE_CLOSEALL,                            true,  false, true,  nullptr },
52  	{ VK_NULL,    IDM_FILE_CLOSEALL_BUT_CURRENT,                false, false, false, nullptr },
53  	{ VK_NULL,    IDM_FILE_CLOSEALL_TOLEFT,                     false, false, false, nullptr },
54  	{ VK_NULL,    IDM_FILE_CLOSEALL_TORIGHT,                    false, false, false, nullptr },
55  	{ VK_NULL,    IDM_FILE_CLOSEALL_UNCHANGED,                  false, false, false, nullptr },
56  	{ VK_NULL,    IDM_FILE_DELETE,                              false, false, false, nullptr },
57  	{ VK_NULL,    IDM_FILE_LOADSESSION,                         false, false, false, nullptr },
58  	{ VK_NULL,    IDM_FILE_SAVESESSION,                         false, false, false, nullptr },
59  	{ VK_P,       IDM_FILE_PRINT,                               true,  false, false, nullptr },
60  	{ VK_NULL,    IDM_FILE_PRINTNOW,                            false, false, false, nullptr },
61  	{ VK_F4,      IDM_FILE_EXIT,                                false, true,  false, nullptr },
62  	{ VK_T,       IDM_FILE_RESTORELASTCLOSEDFILE,               true,  false, true,  TEXT("Restore Recent Closed File")},
63  	{ VK_B,       IDM_EDIT_BEGINENDSELECT,                      true,  false, true,  nullptr },
64  	{ VK_B,       IDM_EDIT_BEGINENDSELECT_COLUMNMODE,           false, true,  true,  nullptr },
65  	{ VK_NULL,    IDM_EDIT_FULLPATHTOCLIP,                      false, false, false, nullptr },
66  	{ VK_NULL,    IDM_EDIT_FILENAMETOCLIP,                      false, false, false, nullptr },
67  	{ VK_NULL,    IDM_EDIT_CURRENTDIRTOCLIP,                    false, false, false, nullptr },
68  	{ VK_NULL,    IDM_EDIT_COPY_ALL_NAMES,                      false, false, false, nullptr },
69  	{ VK_NULL,    IDM_EDIT_COPY_ALL_PATHS,                      false, false, false, nullptr },
70  	{ VK_NULL,    IDM_EDIT_INS_TAB,                             false, false, false, nullptr },
71  	{ VK_NULL,    IDM_EDIT_RMV_TAB,                             false, false, false, nullptr },
72  	{ VK_U,       IDM_EDIT_UPPERCASE,                           true,  false, true,  nullptr },
73  	{ VK_U,       IDM_EDIT_LOWERCASE,                           true,  false, false, nullptr },
74  	{ VK_U,       IDM_EDIT_PROPERCASE_FORCE,                    false, true,  false, nullptr },
75  	{ VK_U,       IDM_EDIT_PROPERCASE_BLEND,                    false, true,  true,  nullptr },
76  	{ VK_U,       IDM_EDIT_SENTENCECASE_FORCE,                  true,  true,  false, nullptr },
77  	{ VK_U,       IDM_EDIT_SENTENCECASE_BLEND,                  true,  true,  true,  nullptr },
78  	{ VK_NULL,    IDM_EDIT_INVERTCASE,                          false, false, false, nullptr },
79  	{ VK_NULL,    IDM_EDIT_RANDOMCASE,                          false, false, false, nullptr },
80  	{ VK_NULL,    IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES,        false, false, false, nullptr },
81  	{ VK_NULL,    IDM_EDIT_REMOVE_ANY_DUP_LINES,                false, false, false, nullptr },
82  	{ VK_I,       IDM_EDIT_SPLIT_LINES,                         true,  false, false, nullptr },
83  	{ VK_J,       IDM_EDIT_JOIN_LINES,                          true,  false, false, nullptr },
84  	{ VK_UP,      IDM_EDIT_LINE_UP,                             true,  false, true,  nullptr },
85  	{ VK_DOWN,    IDM_EDIT_LINE_DOWN,                           true,  false, true,  nullptr },
86  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINES,                    false, false, false, nullptr },
87  	{ VK_NULL,    IDM_EDIT_REMOVEEMPTYLINESWITHBLANK,           false, false, false, nullptr },
88  	{ VK_RETURN,  IDM_EDIT_BLANKLINEABOVECURRENT,               true,  true,  false, nullptr },
89  	{ VK_RETURN,  IDM_EDIT_BLANKLINEBELOWCURRENT,               true,  true,  true,  nullptr },
90  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING,   false, false, false, nullptr },
91  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING,  false, false, false, nullptr },
92  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING,   false, false, false, nullptr },
93  	{ VK_NULL,    IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING,  false, false, false, nullptr },
94  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_ASCENDING,         false, false, false, nullptr },
95  	{ VK_NULL,    IDM_EDIT_SORTLINES_INTEGER_DESCENDING,        false, false, false, nullptr },
96  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING,    false, false, false, nullptr },
97  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING,   false, false, false, nullptr },
98  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING,      false, false, false, nullptr },
99  	{ VK_NULL,    IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING,     false, false, false, nullptr },
100  	{ VK_NULL,    IDM_EDIT_SORTLINES_REVERSE_ORDER,             false, false, false, nullptr },
101  	{ VK_NULL,    IDM_EDIT_SORTLINES_RANDOMLY,                  false, false, false, nullptr },
102  	{ VK_Q,       IDM_EDIT_BLOCK_COMMENT,                       true,  false, false, nullptr },
103  	{ VK_K,       IDM_EDIT_BLOCK_COMMENT_SET,                   true,  false, false, nullptr },
104  	{ VK_K,       IDM_EDIT_BLOCK_UNCOMMENT,                     true,  false, true,  nullptr },
105  	{ VK_Q,       IDM_EDIT_STREAM_COMMENT,                      true,  false, true,  nullptr },
106  	{ VK_NULL,    IDM_EDIT_STREAM_UNCOMMENT,                    false, false, false, nullptr },
107  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE,                        true,  false, false, nullptr },
108  	{ VK_SPACE,   IDM_EDIT_AUTOCOMPLETE_PATH,                   true,  true,  false, nullptr },
109  	{ VK_RETURN,  IDM_EDIT_AUTOCOMPLETE_CURRENTFILE,            true,  false, false, nullptr },
110  	{ VK_SPACE,   IDM_EDIT_FUNCCALLTIP,                         true,  false, true,  nullptr },
111  	{ VK_UP,      IDM_EDIT_FUNCCALLTIP_PREVIOUS,                false, true,  false, nullptr },
112  	{ VK_DOWN,    IDM_EDIT_FUNCCALLTIP_NEXT,                    false, true,  false, nullptr },
113  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_SHORT,               false, false, false, nullptr },
114  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_LONG,                false, false, false, nullptr },
115  	{ VK_NULL,    IDM_EDIT_INSERT_DATETIME_CUSTOMIZED,          false, false, false, nullptr },
116  	{ VK_NULL,    IDM_FORMAT_TODOS,                             false, false, false, TEXT("EOL Conversion to Windows (CR LF)") },
117  	{ VK_NULL,    IDM_FORMAT_TOUNIX,                            false, false, false, TEXT("EOL Conversion to Unix (LF)") },
118  	{ VK_NULL,    IDM_FORMAT_TOMAC,                             false, false, false, TEXT("EOL Conversion to Macintosh (CR)") },
119  	{ VK_NULL,    IDM_EDIT_TRIMTRAILING,                        false, false, false, nullptr },
120  	{ VK_NULL,    IDM_EDIT_TRIMLINEHEAD,                        false, false, false, nullptr },
121  	{ VK_NULL,    IDM_EDIT_TRIM_BOTH,                           false, false, false, nullptr },
122  	{ VK_NULL,    IDM_EDIT_EOL2WS,                              false, false, false, nullptr },
123  	{ VK_NULL,    IDM_EDIT_TRIMALL,                             false, false, false, nullptr },
124  	{ VK_NULL,    IDM_EDIT_TAB2SW,                              false, false, false, nullptr },
125  	{ VK_NULL,    IDM_EDIT_SW2TAB_ALL,                          false, false, false, nullptr },
126  	{ VK_NULL,    IDM_EDIT_SW2TAB_LEADING,                      false, false, false, nullptr },
127  	{ VK_NULL,    IDM_EDIT_PASTE_AS_HTML,                       false, false, false, nullptr },
128  	{ VK_NULL,    IDM_EDIT_PASTE_AS_RTF,                        false, false, false, nullptr },
129  	{ VK_NULL,    IDM_EDIT_COPY_BINARY,                         false, false, false, nullptr },
130  	{ VK_NULL,    IDM_EDIT_CUT_BINARY,                          false, false, false, nullptr },
131  	{ VK_NULL,    IDM_EDIT_PASTE_BINARY,                        false, false, false, nullptr },
132  	{ VK_NULL,    IDM_EDIT_OPENASFILE,                          false, false, false, nullptr },
133  	{ VK_NULL,    IDM_EDIT_OPENINFOLDER,                        false, false, false, nullptr },
134  	{ VK_NULL,    IDM_EDIT_SEARCHONINTERNET,                    false, false, false, nullptr },
135  	{ VK_NULL,    IDM_EDIT_CHANGESEARCHENGINE,                  false, false, false, nullptr },
136  	{ VK_C,       IDM_EDIT_COLUMNMODE,                          false, true,  false, nullptr },
137  	{ VK_NULL,    IDM_EDIT_CHAR_PANEL,                          false, false, false, TEXT("Toggle Character Panel") },
138  	{ VK_NULL,    IDM_EDIT_CLIPBOARDHISTORY_PANEL,              false, false, false, TEXT("Toggle Clipboard History") },
139  	{ VK_NULL,    IDM_EDIT_SETREADONLY,                         false, false, false, nullptr },
140  	{ VK_NULL,    IDM_EDIT_CLEARREADONLY,                       false, false, false, nullptr },
141  	{ VK_F,       IDM_SEARCH_FIND,                              true,  false, false, nullptr },
142  	{ VK_F,       IDM_SEARCH_FINDINFILES,                       true,  false, true,  nullptr },
143  	{ VK_F3,      IDM_SEARCH_FINDNEXT,                          false, false, false, nullptr },
144  	{ VK_F3,      IDM_SEARCH_FINDPREV,                          false, false, true,  nullptr },
145  	{ VK_F3,      IDM_SEARCH_SETANDFINDNEXT,                    true,  false, false, nullptr },
146  	{ VK_F3,      IDM_SEARCH_SETANDFINDPREV,                    true,  false, true,  nullptr },
147  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDNEXT,                 true,  true,  false, nullptr },
148  	{ VK_F3,      IDM_SEARCH_VOLATILE_FINDPREV,                 true,  true,  true,  nullptr },
149  	{ VK_H,       IDM_SEARCH_REPLACE,                           true,  false, false, nullptr },
150  	{ VK_I,       IDM_SEARCH_FINDINCREMENT,                     true,  true,  false, nullptr },
151  	{ VK_F7,      IDM_FOCUS_ON_FOUND_RESULTS,                   false, false, false, nullptr },
152  	{ VK_F4,      IDM_SEARCH_GOTOPREVFOUND,                     false, false, true,  nullptr },
153  	{ VK_F4,      IDM_SEARCH_GOTONEXTFOUND,                     false, false, false, nullptr },
154  	{ VK_G,       IDM_SEARCH_GOTOLINE,                          true,  false, false, nullptr },
155  	{ VK_B,       IDM_SEARCH_GOTOMATCHINGBRACE,                 true,  false, false, nullptr },
156  	{ VK_B,       IDM_SEARCH_SELECTMATCHINGBRACES,              true,  true,  false, nullptr },
157  	{ VK_M,       IDM_SEARCH_MARK,                              true,  false, false, nullptr },
158  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT1,                       false, false, false, TEXT("Style all using 1st style") },
159  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT2,                       false, false, false, TEXT("Style all using 2nd style") },
160  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT3,                       false, false, false, TEXT("Style all using 3rd style") },
161  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT4,                       false, false, false, TEXT("Style all using 4th style") },
162  	{ VK_NULL,    IDM_SEARCH_MARKALLEXT5,                       false, false, false, TEXT("Style all using 5th style") },
163  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT1,                       false, false, false, TEXT("Style one using 1st style") },
164  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT2,                       false, false, false, TEXT("Style one using 2nd style") },
165  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT3,                       false, false, false, TEXT("Style one using 3rd style") },
166  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT4,                       false, false, false, TEXT("Style one using 4th style") },
167  	{ VK_NULL,    IDM_SEARCH_MARKONEEXT5,                       false, false, false, TEXT("Style one using 5th style") },
168  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT1,                     false, false, false, TEXT("Clear 1st style") },
169  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT2,                     false, false, false, TEXT("Clear 2nd style") },
170  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT3,                     false, false, false, TEXT("Clear 3rd style") },
171  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT4,                     false, false, false, TEXT("Clear 4th style") },
172  	{ VK_NULL,    IDM_SEARCH_UNMARKALLEXT5,                     false, false, false, TEXT("Clear 5th style") },
173  	{ VK_NULL,    IDM_SEARCH_CLEARALLMARKS,                     false, false, false, TEXT("Clear all styles") },
174  	{ VK_1,       IDM_SEARCH_GOPREVMARKER1,                     true,  false, true,  TEXT("Previous style of 1st style") },
175  	{ VK_2,       IDM_SEARCH_GOPREVMARKER2,                     true,  false, true,  TEXT("Previous style of 2nd style") },
176  	{ VK_3,       IDM_SEARCH_GOPREVMARKER3,                     true,  false, true,  TEXT("Previous style of 3rd style") },
177  	{ VK_4,       IDM_SEARCH_GOPREVMARKER4,                     true,  false, true,  TEXT("Previous style of 4th style") },
178  	{ VK_5,       IDM_SEARCH_GOPREVMARKER5,                     true,  false, true,  TEXT("Previous style of 5th style") },
179  	{ VK_0,       IDM_SEARCH_GOPREVMARKER_DEF,                  true,  false, true,  TEXT("Previous style of Find Mark style") },
180  	{ VK_1,       IDM_SEARCH_GONEXTMARKER1,                     true,  false, false, TEXT("Next style of 1st style") },
181  	{ VK_2,       IDM_SEARCH_GONEXTMARKER2,                     true,  false, false, TEXT("Next style of 2nd style") },
182  	{ VK_3,       IDM_SEARCH_GONEXTMARKER3,                     true,  false, false, TEXT("Next style of 3rd style") },
183  	{ VK_4,       IDM_SEARCH_GONEXTMARKER4,                     true,  false, false, TEXT("Next style of 4th style") },
184  	{ VK_5,       IDM_SEARCH_GONEXTMARKER5,                     true,  false, false, TEXT("Next style of 5th style") },
185  	{ VK_0,       IDM_SEARCH_GONEXTMARKER_DEF,                  true,  false, false, TEXT("Next style of Find Mark style") },
186  	{ VK_NULL,    IDM_SEARCH_STYLE1TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 1st Style") },
187  	{ VK_NULL,    IDM_SEARCH_STYLE2TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 2nd Style") },
188  	{ VK_NULL,    IDM_SEARCH_STYLE3TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 3rd Style") },
189  	{ VK_NULL,    IDM_SEARCH_STYLE4TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 4th Style") },
190  	{ VK_NULL,    IDM_SEARCH_STYLE5TOCLIP,                      false, false, false, TEXT("Copy Styled Text of 5th Style") },
191  	{ VK_NULL,    IDM_SEARCH_ALLSTYLESTOCLIP,                   false, false, false, TEXT("Copy Styled Text of All Styles") },
192  	{ VK_NULL,    IDM_SEARCH_MARKEDTOCLIP,                      false, false, false, TEXT("Copy Styled Text of Find Mark style") },
193  	{ VK_F2,      IDM_SEARCH_TOGGLE_BOOKMARK,                   true,  false, false, nullptr },
194  	{ VK_F2,      IDM_SEARCH_NEXT_BOOKMARK,                     false, false, false, nullptr },
195  	{ VK_F2,      IDM_SEARCH_PREV_BOOKMARK,                     false, false, true, nullptr  },
196  	{ VK_NULL,    IDM_SEARCH_CLEAR_BOOKMARKS,                   false, false, false, nullptr },
197  	{ VK_NULL,    IDM_SEARCH_CUTMARKEDLINES,                    false, false, false, nullptr },
198  	{ VK_NULL,    IDM_SEARCH_COPYMARKEDLINES,                   false, false, false, nullptr },
199  	{ VK_NULL,    IDM_SEARCH_PASTEMARKEDLINES,                  false, false, false, nullptr },
200  	{ VK_NULL,    IDM_SEARCH_DELETEMARKEDLINES,                 false, false, false, nullptr },
201  	{ VK_NULL,    IDM_SEARCH_DELETEUNMARKEDLINES,               false, false, false, nullptr },
202  	{ VK_NULL,    IDM_SEARCH_INVERSEMARKS,                      false, false, false, nullptr },
203  	{ VK_NULL,    IDM_SEARCH_FINDCHARINRANGE,                   false, false, false, nullptr },
204  	{ VK_NULL,    IDM_VIEW_ALWAYSONTOP,                         false, false, false, nullptr },
205  	{ VK_F11,     IDM_VIEW_FULLSCREENTOGGLE,                    false, false, false, nullptr },
206  	{ VK_F12,     IDM_VIEW_POSTIT,                              false, false, false, nullptr },
207  	{ VK_NULL,    IDM_VIEW_DISTRACTIONFREE,                     false, false, false, nullptr },
208  	{ VK_NULL,    IDM_VIEW_IN_FIREFOX,                          false, false, false, TEXT("View current file in Firefox") },
209  	{ VK_NULL,    IDM_VIEW_IN_CHROME,                           false, false, false, TEXT("View current file in Chrome") },
210  	{ VK_NULL,    IDM_VIEW_IN_IE,                               false, false, false, TEXT("View current file in IE") },
211  	{ VK_NULL,    IDM_VIEW_IN_EDGE,                             false, false, false, TEXT("View current file in Edge")  },
212  	{ VK_NULL,    IDM_VIEW_TAB_SPACE,                           false, false, false, nullptr },
213  	{ VK_NULL,    IDM_VIEW_EOL,                                 false, false, false, nullptr },
214  	{ VK_NULL,    IDM_VIEW_ALL_CHARACTERS,                      false, false, false, nullptr },
215  	{ VK_NULL,    IDM_VIEW_NPC,                                 false, false, false, nullptr },
216  	{ VK_NULL,    IDM_VIEW_NPC_CCUNIEOL,                        false, false, false, nullptr },
217  	{ VK_NULL,    IDM_VIEW_INDENT_GUIDE,                        false, false, false, nullptr },
218  	{ VK_NULL,    IDM_VIEW_WRAP_SYMBOL,                         false, false, false, nullptr },
219  	{ VK_NULL,    IDM_VIEW_GOTO_ANOTHER_VIEW,                   false, false, false, nullptr },
220  	{ VK_NULL,    IDM_VIEW_CLONE_TO_ANOTHER_VIEW,               false, false, false, nullptr },
221  	{ VK_NULL,    IDM_VIEW_GOTO_NEW_INSTANCE,                   false, false, false, nullptr },
222  	{ VK_NULL,    IDM_VIEW_LOAD_IN_NEW_INSTANCE,                false, false, false, nullptr },
223  	{ VK_NUMPAD1, IDM_VIEW_TAB1,                                true,  false, false, nullptr },
224  	{ VK_NUMPAD2, IDM_VIEW_TAB2,                                true,  false, false, nullptr },
225  	{ VK_NUMPAD3, IDM_VIEW_TAB3,                                true,  false, false, nullptr },
226  	{ VK_NUMPAD4, IDM_VIEW_TAB4,                                true,  false, false, nullptr },
227  	{ VK_NUMPAD5, IDM_VIEW_TAB5,                                true,  false, false, nullptr },
228  	{ VK_NUMPAD6, IDM_VIEW_TAB6,                                true,  false, false, nullptr },
229  	{ VK_NUMPAD7, IDM_VIEW_TAB7,                                true,  false, false, nullptr },
230  	{ VK_NUMPAD8, IDM_VIEW_TAB8,                                true,  false, false, nullptr },
231  	{ VK_NUMPAD9, IDM_VIEW_TAB9,                                true,  false, false, nullptr },
232  	{ VK_NEXT,    IDM_VIEW_TAB_NEXT,                            true,  false, false, nullptr },
233  	{ VK_PRIOR,   IDM_VIEW_TAB_PREV,                            true,  false, false, nullptr },
234  	{ VK_NEXT,    IDM_VIEW_TAB_MOVEFORWARD,                     true,  false, true,  nullptr },
235  	{ VK_PRIOR,   IDM_VIEW_TAB_MOVEBACKWARD,                    true,  false, true,  nullptr },
236  	{ VK_TAB,     IDC_PREV_DOC,                                 true,  false, true,  TEXT("Switch to previous document") },
237  	{ VK_TAB,     IDC_NEXT_DOC,                                 true,  false, false, TEXT("Switch to next document") },
238  	{ VK_NULL,    IDM_VIEW_WRAP,                                false, false, false, nullptr },
239  	{ VK_H,       IDM_VIEW_HIDELINES,                           false, true,  false, nullptr },
240  	{ VK_F8,      IDM_VIEW_SWITCHTO_OTHER_VIEW,                 false, false, false, nullptr },
241  	{ VK_0,       IDM_VIEW_FOLDALL,                             false, true,  false, nullptr },
242  	{ VK_0,       IDM_VIEW_UNFOLDALL,                           false, true,  true,  nullptr },
243  	{ VK_F,       IDM_VIEW_FOLD_CURRENT,                        true,  true,  false, nullptr },
244  	{ VK_F,       IDM_VIEW_UNFOLD_CURRENT,                      true,  true,  true,  nullptr },
245  	{ VK_1,       IDM_VIEW_FOLD_1,                              false, true,  false, TEXT("Fold Level 1") },
246  	{ VK_2,       IDM_VIEW_FOLD_2,                              false, true,  false, TEXT("Fold Level 2") },
247  	{ VK_3,       IDM_VIEW_FOLD_3,                              false, true,  false, TEXT("Fold Level 3") },
248  	{ VK_4,       IDM_VIEW_FOLD_4,                              false, true,  false, TEXT("Fold Level 4") },
249  	{ VK_5,       IDM_VIEW_FOLD_5,                              false, true,  false, TEXT("Fold Level 5") },
250  	{ VK_6,       IDM_VIEW_FOLD_6,                              false, true,  false, TEXT("Fold Level 6") },
251  	{ VK_7,       IDM_VIEW_FOLD_7,                              false, true,  false, TEXT("Fold Level 7") },
252  	{ VK_8,       IDM_VIEW_FOLD_8,                              false, true,  false, TEXT("Fold Level 8") },
253  	{ VK_1,       IDM_VIEW_UNFOLD_1,                            false, true,  true,  TEXT("Unfold Level 1") },
254  	{ VK_2,       IDM_VIEW_UNFOLD_2,                            false, true,  true,  TEXT("Unfold Level 2") },
255  	{ VK_3,       IDM_VIEW_UNFOLD_3,                            false, true,  true,  TEXT("Unfold Level 3") },
256  	{ VK_4,       IDM_VIEW_UNFOLD_4,                            false, true,  true,  TEXT("Unfold Level 4") },
257  	{ VK_5,       IDM_VIEW_UNFOLD_5,                            false, true,  true,  TEXT("Unfold Level 5") },
258  	{ VK_6,       IDM_VIEW_UNFOLD_6,                            false, true,  true,  TEXT("Unfold Level 6") },
259  	{ VK_7,       IDM_VIEW_UNFOLD_7,                            false, true,  true,  TEXT("Unfold Level 7") },
260  	{ VK_8,       IDM_VIEW_UNFOLD_8,                            false, true,  true,  TEXT("Unfold Level 8") },
261  	{ VK_NULL,    IDM_VIEW_SUMMARY,                             false, false, false, nullptr },
262  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_1,                     false, false, false, TEXT("Toggle Project Panel 1") },
263  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_2,                     false, false, false, TEXT("Toggle Project Panel 2") },
264  	{ VK_NULL,    IDM_VIEW_PROJECT_PANEL_3,                     false, false, false, TEXT("Toggle Project Panel 3") },
265  	{ VK_NULL,    IDM_VIEW_FILEBROWSER,                         false, false, false, TEXT("Toggle Folder as Workspace") },
266  	{ VK_NULL,    IDM_VIEW_DOC_MAP,                             false, false, false, TEXT("Toggle Document Map") },
267  	{ VK_NULL,    IDM_VIEW_DOCLIST,                             false, false, false, TEXT("Toggle Document List") },
268  	{ VK_NULL,    IDM_VIEW_FUNC_LIST,                           false, false, false, TEXT("Toggle Function List") },
269  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_1,            false, false, false, TEXT("Switch to Project Panel 1") },
270  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_2,            false, false, false, TEXT("Switch to Project Panel 2") },
271  	{ VK_NULL,    IDM_VIEW_SWITCHTO_PROJECT_PANEL_3,            false, false, false, TEXT("Switch to Project Panel 3") },
272  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FILEBROWSER,                false, false, false, TEXT("Switch to Folder as Workspace") },
273  	{ VK_NULL,    IDM_VIEW_SWITCHTO_FUNC_LIST,                  false, false, false, TEXT("Switch to Function List") },
274  	{ VK_NULL,    IDM_VIEW_SWITCHTO_DOCLIST,                    false, false, false, TEXT("Switch to Document List") },
275  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_NONE,                     false, false, false, TEXT("Remove Tab Colour") },
276  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_1,                        false, false, false, TEXT("Apply Tab Colour 1") },
277  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_2,                        false, false, false, TEXT("Apply Tab Colour 2") },
278  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_3,                        false, false, false, TEXT("Apply Tab Colour 3") },
279  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_4,                        false, false, false, TEXT("Apply Tab Colour 4") },
280  	{ VK_NULL,    IDM_VIEW_TAB_COLOUR_5,                        false, false, false, TEXT("Apply Tab Colour 5") },
281  	{ VK_NULL,    IDM_VIEW_SYNSCROLLV,                          false, false, false, nullptr },
282  	{ VK_NULL,    IDM_VIEW_SYNSCROLLH,                          false, false, false, nullptr },
283  	{ VK_R,       IDM_EDIT_RTL,                                 true,  true,  false, nullptr },
284  	{ VK_L,       IDM_EDIT_LTR,                                 true,  true,  false, nullptr },
285  	{ VK_NULL,    IDM_VIEW_MONITORING,                          false, false, false, nullptr },
286  	{ VK_NULL,    IDM_FORMAT_ANSI,                              false, false, false, nullptr },
287  	{ VK_NULL,    IDM_FORMAT_AS_UTF_8,                          false, false, false, nullptr },
288  	{ VK_NULL,    IDM_FORMAT_UTF_8,                             false, false, false, nullptr },
289  	{ VK_NULL,    IDM_FORMAT_UTF_16BE,                          false, false, false, nullptr },
290  	{ VK_NULL,    IDM_FORMAT_UTF_16LE,                          false, false, false, nullptr },
291  	{ VK_NULL,    IDM_FORMAT_ISO_8859_6,                        false, false, false, nullptr },
292  	{ VK_NULL,    IDM_FORMAT_WIN_1256,                          false, false, false, nullptr },
293  	{ VK_NULL,    IDM_FORMAT_ISO_8859_13,                       false, false, false, nullptr },
294  	{ VK_NULL,    IDM_FORMAT_WIN_1257,                          false, false, false, nullptr },
295  	{ VK_NULL,    IDM_FORMAT_ISO_8859_14,                       false, false, false, nullptr },
296  	{ VK_NULL,    IDM_FORMAT_ISO_8859_5,                        false, false, false, nullptr },
297  	{ VK_NULL,    IDM_FORMAT_MAC_CYRILLIC,                      false, false, false, nullptr },
298  	{ VK_NULL,    IDM_FORMAT_KOI8R_CYRILLIC,                    false, false, false, nullptr },
299  	{ VK_NULL,    IDM_FORMAT_KOI8U_CYRILLIC,                    false, false, false, nullptr },
300  	{ VK_NULL,    IDM_FORMAT_WIN_1251,                          false, false, false, nullptr },
301  	{ VK_NULL,    IDM_FORMAT_WIN_1250,                          false, false, false, nullptr },
302  	{ VK_NULL,    IDM_FORMAT_DOS_437,                           false, false, false, nullptr },
303  	{ VK_NULL,    IDM_FORMAT_DOS_720,                           false, false, false, nullptr },
304  	{ VK_NULL,    IDM_FORMAT_DOS_737,                           false, false, false, nullptr },
305  	{ VK_NULL,    IDM_FORMAT_DOS_775,                           false, false, false, nullptr },
306  	{ VK_NULL,    IDM_FORMAT_DOS_850,                           false, false, false, nullptr },
307  	{ VK_NULL,    IDM_FORMAT_DOS_852,                           false, false, false, nullptr },
308  	{ VK_NULL,    IDM_FORMAT_DOS_855,                           false, false, false, nullptr },
309  	{ VK_NULL,    IDM_FORMAT_DOS_857,                           false, false, false, nullptr },
310  	{ VK_NULL,    IDM_FORMAT_DOS_858,                           false, false, false, nullptr },
311  	{ VK_NULL,    IDM_FORMAT_DOS_860,                           false, false, false, nullptr },
312  	{ VK_NULL,    IDM_FORMAT_DOS_861,                           false, false, false, nullptr },
313  	{ VK_NULL,    IDM_FORMAT_DOS_862,                           false, false, false, nullptr },
314  	{ VK_NULL,    IDM_FORMAT_DOS_863,                           false, false, false, nullptr },
315  	{ VK_NULL,    IDM_FORMAT_DOS_865,                           false, false, false, nullptr },
316  	{ VK_NULL,    IDM_FORMAT_DOS_866,                           false, false, false, nullptr },
317  	{ VK_NULL,    IDM_FORMAT_DOS_869,                           false, false, false, nullptr },
318  	{ VK_NULL,    IDM_FORMAT_BIG5,                              false, false, false, nullptr },
319  	{ VK_NULL,    IDM_FORMAT_GB2312,                            false, false, false, nullptr },
320  	{ VK_NULL,    IDM_FORMAT_ISO_8859_2,                        false, false, false, nullptr },
321  	{ VK_NULL,    IDM_FORMAT_ISO_8859_7,                        false, false, false, nullptr },
322  	{ VK_NULL,    IDM_FORMAT_WIN_1253,                          false, false, false, nullptr },
323  	{ VK_NULL,    IDM_FORMAT_ISO_8859_8,                        false, false, false, nullptr },
324  	{ VK_NULL,    IDM_FORMAT_WIN_1255,                          false, false, false, nullptr },
325  	{ VK_NULL,    IDM_FORMAT_SHIFT_JIS,                         false, false, false, nullptr },
326  	{ VK_NULL,    IDM_FORMAT_EUC_KR,                            false, false, false, nullptr },
327  	{ VK_NULL,    IDM_FORMAT_ISO_8859_15,                       false, false, false, nullptr },
328  	{ VK_NULL,    IDM_FORMAT_ISO_8859_4,                        false, false, false, nullptr },
329  	{ VK_NULL,    IDM_FORMAT_ISO_8859_3,                        false, false, false, nullptr },
330  	{ VK_NULL,    IDM_FORMAT_TIS_620,                           false, false, false, nullptr },
331  	{ VK_NULL,    IDM_FORMAT_ISO_8859_9,                        false, false, false, nullptr },
332  	{ VK_NULL,    IDM_FORMAT_WIN_1254,                          false, false, false, nullptr },
333  	{ VK_NULL,    IDM_FORMAT_WIN_1252,                          false, false, false, nullptr },
334  	{ VK_NULL,    IDM_FORMAT_ISO_8859_1,                        false, false, false, nullptr },
335  	{ VK_NULL,    IDM_FORMAT_WIN_1258,                          false, false, false, nullptr },
336  	{ VK_NULL,    IDM_FORMAT_CONV2_ANSI,                        false, false, false, nullptr },
337  	{ VK_NULL,    IDM_FORMAT_CONV2_AS_UTF_8,                    false, false, false, nullptr },
338  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_8,                       false, false, false, nullptr },
339  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16BE,                    false, false, false, nullptr },
340  	{ VK_NULL,    IDM_FORMAT_CONV2_UTF_16LE,                    false, false, false, nullptr },
341  	{ VK_NULL,    IDM_LANG_USER_DLG,                            false, false, false, nullptr },
342  	{ VK_NULL,    IDM_LANG_USER,                                false, false, false, nullptr },
343  	{ VK_NULL,    IDM_LANG_OPENUDLDIR,                          false, false, false, nullptr },
344  	{ VK_NULL,    IDM_SETTING_PREFERENCE,                       false, false, false, nullptr },
345  	{ VK_NULL,    IDM_LANGSTYLE_CONFIG_DLG,                     false, false, false, nullptr },
346  	{ VK_NULL,    IDM_SETTING_SHORTCUT_MAPPER,                  false, false, false, nullptr },
347  	{ VK_NULL,    IDM_SETTING_IMPORTPLUGIN,                     false, false, false, nullptr },
348  	{ VK_NULL,    IDM_SETTING_IMPORTSTYLETHEMS,                 false, false, false, nullptr },
349  	{ VK_NULL,    IDM_SETTING_EDITCONTEXTMENU,                  false, false, false, nullptr },
350  	{ VK_R,       IDC_EDIT_TOGGLEMACRORECORDING,                true,  false, true,  TEXT("Toggle macro recording")},
351  	{ VK_NULL,    IDM_MACRO_STARTRECORDINGMACRO,                false, false, false, nullptr },
352  	{ VK_NULL,    IDM_MACRO_STOPRECORDINGMACRO,                 false, false, false, nullptr },
353  	{ VK_P,       IDM_MACRO_PLAYBACKRECORDEDMACRO,              true,  false, true,  nullptr },
354  	{ VK_NULL,    IDM_MACRO_SAVECURRENTMACRO,                   false, false, false, nullptr },
355  	{ VK_NULL,    IDM_MACRO_RUNMULTIMACRODLG,                   false, false, false, nullptr },
356  	{ VK_F5,      IDM_EXECUTE,                                  false, false, false, nullptr },
357  	{ VK_NULL,    IDM_WINDOW_SORT_FN_ASC,                       false, false, false, TEXT("Sort By Name A to Z") },
358  	{ VK_NULL,    IDM_WINDOW_SORT_FN_DSC,                       false, false, false, TEXT("Sort By Name Z to A") },
359  	{ VK_NULL,    IDM_WINDOW_SORT_FP_ASC,                       false, false, false, TEXT("Sort By Path A to Z") },
360  	{ VK_NULL,    IDM_WINDOW_SORT_FP_DSC,                       false, false, false, TEXT("Sort By Path Z to A") },
361  	{ VK_NULL,    IDM_WINDOW_SORT_FT_ASC,                       false, false, false, TEXT("Sort By Type A to Z") },
362  	{ VK_NULL,    IDM_WINDOW_SORT_FT_DSC,                       false, false, false, TEXT("Sort By Type Z to A") },
363  	{ VK_NULL,    IDM_WINDOW_SORT_FS_ASC,                       false, false, false, TEXT("Sort By Size Smaller to Larger") },
364  	{ VK_NULL,    IDM_WINDOW_SORT_FS_DSC,                       false, false, false, TEXT("Sort By Size Larger to Smaller") },
365  	{ VK_NULL,    IDM_CMDLINEARGUMENTS,                         false, false, false, nullptr },
366  	{ VK_NULL,    IDM_HOMESWEETHOME,                            false, false, false, nullptr },
367  	{ VK_NULL,    IDM_PROJECTPAGE,                              false, false, false, nullptr },
368  	{ VK_NULL,    IDM_ONLINEDOCUMENT,                           false, false, false, nullptr },
369  	{ VK_NULL,    IDM_FORUM,                                    false, false, false, nullptr },
370  	{ VK_NULL,    IDM_UPDATE_NPP,                               false, false, false, TEXT("Update Notepad++") },
371  	{ VK_NULL,    IDM_CONFUPDATERPROXY,                         false, false, false, TEXT("Set Updater Proxy...") },
372  	{ VK_NULL,    IDM_DEBUGINFO,                                false, false, false, nullptr },
373  	{ VK_F1,      IDM_ABOUT,                                    false, false, false, nullptr }
374  };
375  static const ScintillaKeyDefinition scintKeyDefs[] =
376  {
377  	{TEXT("SCI_CUT"),                     SCI_CUT,                     true,  false, false, VK_X,        IDM_EDIT_CUT},
378  	{TEXT(""),                            SCI_CUT,                     false, false, true,  VK_DELETE,   0},
379  	{TEXT("SCI_COPY"),                    SCI_COPY,                    true,  false, false, VK_C,        IDM_EDIT_COPY},
380  	{TEXT(""),                            SCI_COPY,                    true,  false, false, VK_INSERT,   0},
381  	{TEXT("SCI_PASTE"),                   SCI_PASTE,                   true,  false, false, VK_V,        IDM_EDIT_PASTE},
382  	{TEXT(""),                            SCI_PASTE,                   false, false, true,  VK_INSERT,   0},
383  	{TEXT("SCI_SELECTALL"),               SCI_SELECTALL,               true,  false, false, VK_A,        IDM_EDIT_SELECTALL},
384  	{TEXT("SCI_CLEAR"),                   SCI_CLEAR,                   false, false, false, VK_DELETE,   IDM_EDIT_DELETE},
385  	{TEXT("SCI_CLEARALL"),                SCI_CLEARALL,                false, false, false, 0,           0},
386  	{TEXT("SCI_UNDO"),                    SCI_UNDO,                    true,  false, false, VK_Z,        IDM_EDIT_UNDO},
387  	{TEXT(""),                            SCI_UNDO,                    false, true,  false, VK_BACK,     0},
388  	{TEXT("SCI_REDO"),                    SCI_REDO,                    true,  false, false, VK_Y,        IDM_EDIT_REDO},
389  	{TEXT(""),                            SCI_REDO,                    true,  false, true,  VK_Z,        0},
390  	{TEXT("SCI_NEWLINE"),                 SCI_NEWLINE,                 false, false, false, VK_RETURN,   0},
391  	{TEXT(""),                            SCI_NEWLINE,                 false, false, true,  VK_RETURN,   0},
392  	{TEXT("SCI_TAB"),                     SCI_TAB,                     false, false, false, VK_TAB,      0},
393  	{TEXT("SCI_BACKTAB"),                 SCI_BACKTAB,                 false, false, true,  VK_TAB,      0},
394  	{TEXT("SCI_FORMFEED"),                SCI_FORMFEED,                false, false, false, 0,           0},
395  	{TEXT("SCI_ZOOMIN"),                  SCI_ZOOMIN,                  true,  false, false, VK_ADD,      IDM_VIEW_ZOOMIN},
396  	{TEXT("SCI_ZOOMOUT"),                 SCI_ZOOMOUT,                 true,  false, false, VK_SUBTRACT, IDM_VIEW_ZOOMOUT},
397  	{TEXT("SCI_SETZOOM"),                 SCI_SETZOOM,                 true,  false, false, VK_DIVIDE,   IDM_VIEW_ZOOMRESTORE},
398  	{TEXT("SCI_SELECTIONDUPLICATE"),      SCI_SELECTIONDUPLICATE,      true,  false, false, VK_D,        IDM_EDIT_DUP_LINE},
399  	{TEXT("SCI_LINESJOIN"),               SCI_LINESJOIN,               false, false, false, 0,           0},
400  	{TEXT("SCI_SCROLLCARET"),             SCI_SCROLLCARET,             false, false, false, 0,           0},
401  	{TEXT("SCI_EDITTOGGLEOVERTYPE"),      SCI_EDITTOGGLEOVERTYPE,      false, false, false, VK_INSERT,   0},
402  	{TEXT("SCI_MOVECARETINSIDEVIEW"),     SCI_MOVECARETINSIDEVIEW,     false, false, false, 0,           0},
403  	{TEXT("SCI_LINEDOWN"),                SCI_LINEDOWN,                false, false, false, VK_DOWN,     0},
404  	{TEXT("SCI_LINEDOWNEXTEND"),          SCI_LINEDOWNEXTEND,          false, false, true,  VK_DOWN,     0},
405  	{TEXT("SCI_LINEDOWNRECTEXTEND"),      SCI_LINEDOWNRECTEXTEND,      false, true,  true,  VK_DOWN,     0},
406  	{TEXT("SCI_LINESCROLLDOWN"),          SCI_LINESCROLLDOWN,          true,  false, false, VK_DOWN,     0},
407  	{TEXT("SCI_LINEUP"),                  SCI_LINEUP,                  false, false, false, VK_UP,       0},
408  	{TEXT("SCI_LINEUPEXTEND"),            SCI_LINEUPEXTEND,            false, false, true,  VK_UP,       0},
409  	{TEXT("SCI_LINEUPRECTEXTEND"),        SCI_LINEUPRECTEXTEND,        false, true,  true,  VK_UP,       0},
410  	{TEXT("SCI_LINESCROLLUP"),            SCI_LINESCROLLUP,            true,  false, false, VK_UP,       0},
411  	{TEXT("SCI_PARADOWN"),                SCI_PARADOWN,                true,  false, false, VK_OEM_6,    0},
412  	{TEXT("SCI_PARADOWNEXTEND"),          SCI_PARADOWNEXTEND,          true,  false, true,  VK_OEM_6,    0},
413  	{TEXT("SCI_PARAUP"),                  SCI_PARAUP,                  true,  false, false, VK_OEM_4,    0},
414  	{TEXT("SCI_PARAUPEXTEND"),            SCI_PARAUPEXTEND,            true,  false, true,  VK_OEM_4,    0},
415  	{TEXT("SCI_CHARLEFT"),                SCI_CHARLEFT,                false, false, false, VK_LEFT,     0},
416  	{TEXT("SCI_CHARLEFTEXTEND"),          SCI_CHARLEFTEXTEND,          false, false, true,  VK_LEFT,     0},
417  	{TEXT("SCI_CHARLEFTRECTEXTEND"),      SCI_CHARLEFTRECTEXTEND,      false, true,  true,  VK_LEFT,     0},
418  	{TEXT("SCI_CHARRIGHT"),               SCI_CHARRIGHT,               false, false, false, VK_RIGHT,    0},
419  	{TEXT("SCI_CHARRIGHTEXTEND"),         SCI_CHARRIGHTEXTEND,         false, false, true,  VK_RIGHT,    0},
420  	{TEXT("SCI_CHARRIGHTRECTEXTEND"),     SCI_CHARRIGHTRECTEXTEND,     false, true,  true,  VK_RIGHT,    0},
421  	{TEXT("SCI_WORDLEFT"),                SCI_WORDLEFT,                true,  false, false, VK_LEFT,     0},
422  	{TEXT("SCI_WORDLEFTEXTEND"),          SCI_WORDLEFTEXTEND,          true,  false, true,  VK_LEFT,     0},
423  	{TEXT("SCI_WORDRIGHT"),               SCI_WORDRIGHT,               true,  false, false, VK_RIGHT,    0},
424  	{TEXT("SCI_WORDRIGHTEXTEND"),         SCI_WORDRIGHTEXTEND,         false, false, false, 0,           0},
425  	{TEXT("SCI_WORDLEFTEND"),             SCI_WORDLEFTEND,             false, false, false, 0,           0},
426  	{TEXT("SCI_WORDLEFTENDEXTEND"),       SCI_WORDLEFTENDEXTEND,       false, false, false, 0,           0},
427  	{TEXT("SCI_WORDRIGHTEND"),            SCI_WORDRIGHTEND,            false, false, false, 0,           0},
428  	{TEXT("SCI_WORDRIGHTENDEXTEND"),      SCI_WORDRIGHTENDEXTEND,      true,  false, true,  VK_RIGHT,    0},
429  	{TEXT("SCI_WORDPARTLEFT"),            SCI_WORDPARTLEFT,            true,  false, false, VK_OEM_2,    0},
430  	{TEXT("SCI_WORDPARTLEFTEXTEND"),      SCI_WORDPARTLEFTEXTEND,      true,  false, true,  VK_OEM_2,    0},
431  	{TEXT("SCI_WORDPARTRIGHT"),           SCI_WORDPARTRIGHT,           true,  false, false, VK_OEM_5,    0},
432  	{TEXT("SCI_WORDPARTRIGHTEXTEND"),     SCI_WORDPARTRIGHTEXTEND,     true,  false, true,  VK_OEM_5,    0},
433  	{TEXT("SCI_HOME"),                    SCI_HOME,                    false, false, false, 0,           0},
434  	{TEXT("SCI_HOMEEXTEND"),              SCI_HOMEEXTEND,              false, false, false, 0,           0},
435  	{TEXT("SCI_HOMERECTEXTEND"),          SCI_HOMERECTEXTEND,          false, false, false, 0,           0},
436  	{TEXT("SCI_HOMEDISPLAY"),             SCI_HOMEDISPLAY,             false, true,  false, VK_HOME,     0},
437  	{TEXT("SCI_HOMEDISPLAYEXTEND"),       SCI_HOMEDISPLAYEXTEND,       false, false, false, 0,           0},
438  	{TEXT("SCI_HOMEWRAP"),                SCI_HOMEWRAP,                false, false, false, 0,           0},
439  	{TEXT("SCI_HOMEWRAPEXTEND"),          SCI_HOMEWRAPEXTEND,          false, false, false, 0,           0},
440  	{TEXT("SCI_VCHOME"),                  SCI_VCHOME,                  false, false, false, 0,           0},
441  	{TEXT("SCI_VCHOMEEXTEND"),            SCI_VCHOMEEXTEND,            false, false, false, 0,           0},
442  	{TEXT("SCI_VCHOMERECTEXTEND"),        SCI_VCHOMERECTEXTEND,        false, true,  true,  VK_HOME,     0},
443  	{TEXT("SCI_VCHOMEDISPLAY"),           SCI_VCHOMEDISPLAY,           false, false, false, 0,           0},
444  	{TEXT("SCI_VCHOMEDISPLAYEXTEND"),     SCI_VCHOMEDISPLAYEXTEND,     false, false, false, 0,           0},
445  	{TEXT("SCI_VCHOMEWRAP"),              SCI_VCHOMEWRAP,              false, false, false, VK_HOME,     0},
446  	{TEXT("SCI_VCHOMEWRAPEXTEND"),        SCI_VCHOMEWRAPEXTEND,        false, false, true,  VK_HOME,     0},
447  	{TEXT("SCI_LINEEND"),                 SCI_LINEEND,                 false, false, false, 0,           0},
448  	{TEXT("SCI_LINEENDWRAPEXTEND"),       SCI_LINEENDWRAPEXTEND,       false, false, true,  VK_END,      0},
449  	{TEXT("SCI_LINEENDRECTEXTEND"),       SCI_LINEENDRECTEXTEND,       false, true,  true,  VK_END,      0},
450  	{TEXT("SCI_LINEENDDISPLAY"),          SCI_LINEENDDISPLAY,          false, true,  false, VK_END,      0},
451  	{TEXT("SCI_LINEENDDISPLAYEXTEND"),    SCI_LINEENDDISPLAYEXTEND,    false, false, false, 0,           0},
452  	{TEXT("SCI_LINEENDWRAP"),             SCI_LINEENDWRAP,             false, false, false, VK_END,      0},
453  	{TEXT("SCI_LINEENDEXTEND"),           SCI_LINEENDEXTEND,           false, false, false, 0,           0},
454  	{TEXT("SCI_DOCUMENTSTART"),           SCI_DOCUMENTSTART,           true,  false, false, VK_HOME,     0},
455  	{TEXT("SCI_DOCUMENTSTARTEXTEND"),     SCI_DOCUMENTSTARTEXTEND,     true,  false, true,  VK_HOME,     0},
456  	{TEXT("SCI_DOCUMENTEND"),             SCI_DOCUMENTEND,             true,  false, false, VK_END,      0},
457  	{TEXT("SCI_DOCUMENTENDEXTEND"),       SCI_DOCUMENTENDEXTEND,       true,  false, true,  VK_END,      0},
458  	{TEXT("SCI_PAGEUP"),                  SCI_PAGEUP,                  false, false, false, VK_PRIOR,    0},
459  	{TEXT("SCI_PAGEUPEXTEND"),            SCI_PAGEUPEXTEND,            false, false, true,  VK_PRIOR,    0},
460  	{TEXT("SCI_PAGEUPRECTEXTEND"),        SCI_PAGEUPRECTEXTEND,        false, true,  true,  VK_PRIOR,    0},
461  	{TEXT("SCI_PAGEDOWN"),                SCI_PAGEDOWN,                false, false, false, VK_NEXT,     0},
462  	{TEXT("SCI_PAGEDOWNEXTEND"),          SCI_PAGEDOWNEXTEND,          false, false, true,  VK_NEXT,     0},
463  	{TEXT("SCI_PAGEDOWNRECTEXTEND"),      SCI_PAGEDOWNRECTEXTEND,      false, true,  true,  VK_NEXT,     0},
464  	{TEXT("SCI_STUTTEREDPAGEUP"),         SCI_STUTTEREDPAGEUP,         false, false, false, 0,           0},
465  	{TEXT("SCI_STUTTEREDPAGEUPEXTEND"),   SCI_STUTTEREDPAGEUPEXTEND,   false, false, false, 0,           0},
466  	{TEXT("SCI_STUTTEREDPAGEDOWN"),       SCI_STUTTEREDPAGEDOWN,       false, false, false, 0,           0},
467  	{TEXT("SCI_STUTTEREDPAGEDOWNEXTEND"), SCI_STUTTEREDPAGEDOWNEXTEND, false, false, false, 0,           0},
468  	{TEXT("SCI_DELETEBACK"),              SCI_DELETEBACK,              false, false, false, VK_BACK,     0},
469  	{TEXT(""),                            SCI_DELETEBACK,              false, false, true,  VK_BACK,     0},
470  	{TEXT("SCI_DELETEBACKNOTLINE"),       SCI_DELETEBACKNOTLINE,       false, false, false, 0,           0},
471  	{TEXT("SCI_DELWORDLEFT"),             SCI_DELWORDLEFT,             true,  false, false, VK_BACK,     0},
472  	{TEXT("SCI_DELWORDRIGHT"),            SCI_DELWORDRIGHT,            true,  false, false, VK_DELETE,   0},
473  	{TEXT("SCI_DELLINELEFT"),             SCI_DELLINELEFT,             true,  false, true,  VK_BACK,     0},
474  	{TEXT("SCI_DELLINERIGHT"),            SCI_DELLINERIGHT,            true,  false, true,  VK_DELETE,   0},
475  	{TEXT("SCI_LINEDELETE"),              SCI_LINEDELETE,              true,  false, true,  VK_L,        0},
476  	{TEXT("SCI_LINECUT"),                 SCI_LINECUT,                 true,  false, false, VK_L,        0},
477  	{TEXT("SCI_LINECOPY"),                SCI_LINECOPY,                true,  false, true,  VK_X,        0},
478  	{TEXT("SCI_LINETRANSPOSE"),           SCI_LINETRANSPOSE,           true,  false, false, VK_T,        0},
479  	{TEXT("SCI_LINEDUPLICATE"),           SCI_LINEDUPLICATE,           false, false, false, 0,           0},
480  	{TEXT("SCI_CANCEL"),                  SCI_CANCEL,                  false, false, false, VK_ESCAPE,   0},
481  	{TEXT("SCI_SWAPMAINANCHORCARET"),     SCI_SWAPMAINANCHORCARET,     false, false, false, 0,           0},
482  	{TEXT("SCI_ROTATESELECTION"),         SCI_ROTATESELECTION,         false, false, false, 0,           0}
483  };
484  #define NONEEDSHORTCUTSXMLBACKUP_FILENAME L"v852NoNeedShortcutsBackup.xml"
485  #define SHORTCUTSXML_FILENAME L"shortcuts.xml"
486  typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
487  int strVal(const TCHAR *str, int base)
488  {
489  	if (!str) return -1;
490  	if (!str[0]) return 0;
491  	TCHAR *finStr;
492  	int result = wcstol(str, &finStr, base);
493  	if (*finStr != '\0')
494  		return -1;
495  	return result;
496  }
497  int decStrVal(const TCHAR *str)
498  {
499  	return strVal(str, 10);
500  }
501  int hexStrVal(const TCHAR *str)
502  {
503  	return strVal(str, 16);
504  }
505  int getKwClassFromName(const TCHAR *str)
506  {
507  	if (!lstrcmp(TEXT("instre1"), str)) return LANG_INDEX_INSTR;
508  	if (!lstrcmp(TEXT("instre2"), str)) return LANG_INDEX_INSTR2;
509  	if (!lstrcmp(TEXT("type1"), str)) return LANG_INDEX_TYPE;
510  	if (!lstrcmp(TEXT("type2"), str)) return LANG_INDEX_TYPE2;
511  	if (!lstrcmp(TEXT("type3"), str)) return LANG_INDEX_TYPE3;
512  	if (!lstrcmp(TEXT("type4"), str)) return LANG_INDEX_TYPE4;
513  	if (!lstrcmp(TEXT("type5"), str)) return LANG_INDEX_TYPE5;
514  	if (!lstrcmp(TEXT("type6"), str)) return LANG_INDEX_TYPE6;
515  	if (!lstrcmp(TEXT("type7"), str)) return LANG_INDEX_TYPE7;
516  	if ((str[1] == '\0') && (str[0] >= '0') && (str[0] <= '8')) 
517  		return str[0] - '0';
518  	return -1;
519  }
520  } 
521  void cutString(const TCHAR* str2cut, vector<generic_string>& patternVect)
522  {
523  	if (str2cut == nullptr) return;
524  	const TCHAR *pBegin = str2cut;
525  	const TCHAR *pEnd = pBegin;
526  	while (*pEnd != '\0')
527  	{
528  		if (_istspace(*pEnd))
529  		{
530  			if (pBegin != pEnd)
531  				patternVect.emplace_back(pBegin, pEnd);
532  			pBegin = pEnd + 1;
533  		}
534  		++pEnd;
535  	}
536  	if (pBegin != pEnd)
537  		patternVect.emplace_back(pBegin, pEnd);
538  }
539  void cutStringBy(const TCHAR* str2cut, vector<generic_string>& patternVect, char byChar, bool allowEmptyStr)
540  {
541  	if (str2cut == nullptr) return;
542  	const TCHAR* pBegin = str2cut;
543  	const TCHAR* pEnd = pBegin;
544  	while (*pEnd != '\0')
545  	{
546  		if (*pEnd == byChar)
547  		{
548  			if (allowEmptyStr)
549  				patternVect.emplace_back(pBegin, pEnd);
550  			else if (pBegin != pEnd)
551  				patternVect.emplace_back(pBegin, pEnd);
552  			pBegin = pEnd + 1;
553  		}
554  		++pEnd;
555  	}
556  	if (allowEmptyStr)
557  		patternVect.emplace_back(pBegin, pEnd);
558  	else if (pBegin != pEnd)
559  		patternVect.emplace_back(pBegin, pEnd);
560  }
561  std::wstring LocalizationSwitcher::getLangFromXmlFileName(const wchar_t *fn) const
562  {
563  	size_t nbItem = sizeof(localizationDefs)/sizeof(LocalizationSwitcher::LocalizationDefinition);
564  	for (size_t i = 0 ; i < nbItem ; ++i)
565  	{
566  		if (0 == wcsicmp(fn, localizationDefs[i]._xmlFileName))
567  			return localizationDefs[i]._langName;
568  	}
569  	return std::wstring();
570  }
571  std::wstring LocalizationSwitcher::getXmlFilePathFromLangName(const wchar_t *langName) const
572  {
573  	for (size_t i = 0, len = _localizationList.size(); i < len ; ++i)
574  	{
575  		if (0 == wcsicmp(langName, _localizationList[i].first.c_str()))
576  			return _localizationList[i].second;
577  	}
578  	return std::wstring();
579  }
580  bool LocalizationSwitcher::addLanguageFromXml(const std::wstring& xmlFullPath)
581  {
582  	wchar_t * fn = ::PathFindFileNameW(xmlFullPath.c_str());
583  	wstring foundLang = getLangFromXmlFileName(fn);
584  	if (!foundLang.empty())
585  	{
586  		_localizationList.push_back(pair<wstring, wstring>(foundLang, xmlFullPath));
587  		return true;
588  	}
589  	return false;
590  }
591  bool LocalizationSwitcher::switchToLang(const wchar_t *lang2switch) const
592  {
593  	wstring langPath = getXmlFilePathFromLangName(lang2switch);
594  	if (langPath.empty())
595  		return false;
596  	return ::CopyFileW(langPath.c_str(), _nativeLangPath.c_str(), FALSE) != FALSE;
597  }
598  generic_string ThemeSwitcher::getThemeFromXmlFileName(const TCHAR *xmlFullPath) const
599  {
600  	if (!xmlFullPath || !xmlFullPath[0])
601  		return generic_string();
602  	generic_string fn(::PathFindFileName(xmlFullPath));
603  	PathRemoveExtension(const_cast<TCHAR *>(fn.c_str()));
604  	return fn;
605  }
606  int DynamicMenu::getTopLevelItemNumber() const
607  {
608  	int nb = 0;
609  	generic_string previousFolderName;
610  	for (const MenuItemUnit& i : _menuItems)
611  	{
612  		if (i._parentFolderName.empty())
613  		{
614  			++nb;
615  		}
616  		else
617  		{
618  			if (previousFolderName.empty())
619  			{
620  				++nb;
621  				previousFolderName = i._parentFolderName;
622  			}
623  			else 
624  			{
625  				if (i._parentFolderName.empty())
626  				{
627  					++nb;
628  					previousFolderName = i._parentFolderName;
629  				}
630  				else if (previousFolderName == i._parentFolderName)
631  				{
632  				}
633  				else
634  				{
635  					++nb;
636  					previousFolderName = i._parentFolderName;
637  				}
638  			}
639  		}
640  	}
641  	return nb;
642  }
643  bool DynamicMenu::attach(HMENU hMenu, unsigned int posBase, int lastCmd, const generic_string& lastCmdLabel)
644  {
645  	if (!hMenu) return false;
646  	_hMenu = hMenu;
647  	_posBase = posBase;
648  	_lastCmd = lastCmd;
649  	_lastCmdLabel = lastCmdLabel;
650  	return createMenu();
651  }
652  bool DynamicMenu::clearMenu() const
653  {
654  	if (!_hMenu) return false;
655  	int nbTopItem = getTopLevelItemNumber();
656  	for (int i = nbTopItem + 1; i >= 0 ; --i)
657  	{
658  		::DeleteMenu(_hMenu, static_cast<int32_t>(_posBase) + i, MF_BYPOSITION);
659  	}
660  	return true;
661  }
662  bool DynamicMenu::createMenu() const
663  {
664  	if (!_hMenu) return false;
665  	bool lastIsSep = false;
666  	HMENU hParentFolder = NULL;
667  	generic_string currentParentFolderStr;
668  	int j = 0;
669  	size_t nb = _menuItems.size();
670  	size_t i = 0;
671  	for (; i < nb; ++i)
672  	{
673  		const MenuItemUnit& item = _menuItems[i];
674  		if (item._parentFolderName.empty())
675  		{
676  			currentParentFolderStr.clear();
677  			hParentFolder = NULL;
678  			j = 0;
679  		}
680  		else
681  		{
682  			if (item._parentFolderName != currentParentFolderStr)
683  			{
684  				currentParentFolderStr = item._parentFolderName;
685  				hParentFolder = ::CreateMenu();
686  				j = 0;
687  				::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i), MF_BYPOSITION | MF_POPUP, (UINT_PTR)hParentFolder, currentParentFolderStr.c_str());
688  			}
689  		}
690  		unsigned int flag = MF_BYPOSITION | ((item._cmdID == 0) ? MF_SEPARATOR : 0);
691  		if (hParentFolder)
692  		{
693  			::InsertMenu(hParentFolder, j++, flag, item._cmdID, item._itemName.c_str());
694  			lastIsSep = false;
695  		}
696  		else if ((i == 0 || i == _menuItems.size() - 1) && item._cmdID == 0)
697  		{
698  			lastIsSep = true;
699  		}
700  		else if (item._cmdID != 0)
701  		{
702  			::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i), flag, item._cmdID, item._itemName.c_str());
703  			lastIsSep = false;
704  		}
705  		else if (item._cmdID == 0 && !lastIsSep)
706  		{
707  			::InsertMenu(_hMenu, static_cast<int32_t>(_posBase + i), flag, item._cmdID, item._itemName.c_str());
708  			lastIsSep = true;
709  		}
710  		else 
711  		{
712  			lastIsSep = true;
713  		}
714  	}
715  	if (nb > 0)
716  	{
717  		::InsertMenu(_hMenu, static_cast<int32_t>(_posBase + i), MF_BYPOSITION | MF_SEPARATOR, 0, nullptr);
718  		::InsertMenu(_hMenu, static_cast<UINT>(_posBase + i + 2), MF_BYCOMMAND, _lastCmd, _lastCmdLabel.c_str());
719  	}
720  	return true;
721  }
722  winVer NppParameters::getWindowsVersion()
723  {
724  	OSVERSIONINFOEX osvi;
725  	SYSTEM_INFO si;
726  	PGNSI pGNSI;
727  	ZeroMemory(&si, sizeof(SYSTEM_INFO));
728  	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
729  	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
730  	BOOL bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *)&osvi);
731  	if (!bOsVersionInfoEx)
732  	{
733  		osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
734  		if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) )
735  			return WV_UNKNOWN;
736  	}
737  	pGNSI = (PGNSI) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
738  	if (pGNSI != NULL)
739  		pGNSI(&si);
740  	else
741  		GetSystemInfo(&si);
742  	switch (si.wProcessorArchitecture)
743  	{
744  	case PROCESSOR_ARCHITECTURE_IA64:
745  		_platForm = PF_IA64;
746  		break;
747  	case PROCESSOR_ARCHITECTURE_AMD64:
748  		_platForm = PF_X64;
749  		break;
750  	case PROCESSOR_ARCHITECTURE_INTEL:
751  		_platForm = PF_X86;
752  		break;
753  	case PROCESSOR_ARCHITECTURE_ARM64:
754  		_platForm = PF_ARM64;
755  		break;
756  	default:
757  		_platForm = PF_UNKNOWN;
758  	}
759     switch (osvi.dwPlatformId)
760     {
761  		case VER_PLATFORM_WIN32_NT:
762  		{
763  			if (osvi.dwMajorVersion == 10 && osvi.dwMinorVersion == 0 && osvi.dwBuildNumber >= 22000)
764  				return WV_WIN11;
765  			if (osvi.dwMajorVersion == 10 && osvi.dwMinorVersion == 0)
766  				return WV_WIN10;
767  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 3)
768  				return WV_WIN81;
769  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 2)
770  				return WV_WIN8;
771  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 1)
772  				return WV_WIN7;
773  			if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 0)
774  				return WV_VISTA;
775  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)
776  			{
777  				if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
778  					return WV_XPX64;
779  				return WV_S2003;
780  			}
781  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
782  				return WV_XP;
783  			if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
784  				return WV_W2K;
785  			if (osvi.dwMajorVersion <= 4)
786  				return WV_NT;
787  			break;
788  		}
789  		case VER_PLATFORM_WIN32_WINDOWS:
790  		{
791  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)
792  				return WV_95;
793  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 10)
794  				return WV_98;
795  			if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)
796  				return WV_ME;
797  			break;
798  		}
799  		case VER_PLATFORM_WIN32s:
800  			return WV_WIN32S;
801  		default:
802  			return WV_UNKNOWN;
803     }
804     return WV_UNKNOWN;
805  }
806  NppParameters::NppParameters()
807  {
808  	_winVersion = getWindowsVersion();
809  	TCHAR nppPath[MAX_PATH];
810  	::GetModuleFileName(NULL, nppPath, MAX_PATH);
811  	PathRemoveFileSpec(nppPath);
812  	_nppPath = nppPath;
813  	TCHAR curDir[MAX_PATH];
814  	::GetCurrentDirectory(MAX_PATH, curDir);
815  	_currentDirectory = curDir;
816  	_appdataNppDir.clear();
817  	generic_string notepadStylePath(_nppPath);
818  	pathAppend(notepadStylePath, notepadStyleFile);
819  	_asNotepadStyle = (PathFileExists(notepadStylePath.c_str()) == TRUE);
820  	initMenuKeys();
821  	initScintillaKeys();
822  }
823  NppParameters::~NppParameters()
824  {
825  	for (int i = 0 ; i < _nbLang ; ++i)
826  		delete _langList[i];
827  	for (int i = 0 ; i < _nbRecentFile ; ++i)
828  		delete _LRFileList[i];
829  	for (int i = 0 ; i < _nbUserLang ; ++i)
830  		delete _userLangArray[i];
831  	for (std::vector<TiXmlDocument *>::iterator it = _pXmlExternalLexerDoc.begin(), end = _pXmlExternalLexerDoc.end(); it != end; ++it )
832  		delete (*it);
833  	_pXmlExternalLexerDoc.clear();
834  }
835  bool NppParameters::reloadStylers(const TCHAR* stylePath)
836  {
837  	delete _pXmlUserStylerDoc;
838  	const TCHAR* stylePathToLoad = stylePath != nullptr ? stylePath : _stylerPath.c_str();
839  	_pXmlUserStylerDoc = new TiXmlDocument(stylePathToLoad);
840  	bool loadOkay = _pXmlUserStylerDoc->LoadFile();
841  	if (!loadOkay)
842  	{
843  		if (!_pNativeLangSpeaker)
844  		{
845  			::MessageBox(NULL, stylePathToLoad, TEXT("Load stylers.xml failed"), MB_OK);
846  		}
847  		else
848  		{
849  			_pNativeLangSpeaker->messageBox("LoadStylersFailed",
850  				NULL,
851  				TEXT("Load \"$STR_REPLACE$\" failed!"),
852  				TEXT("Load stylers.xml failed"),
853  				MB_OK,
854  				0,
855  				stylePathToLoad);
856  		}
857  		delete _pXmlUserStylerDoc;
858  		_pXmlUserStylerDoc = NULL;
859  		return false;
860  	}
861  	_lexerStylerVect.clear();
862  	_widgetStyleArray.clear();
863  	getUserStylersFromXmlTree();
864  	for ( size_t i = 0; i < getExternalLexerDoc()->size(); ++i)
865  	{
866  		getExternalLexerFromXmlTree( getExternalLexerDoc()->at(i) );
867  	}
868  	return true;
869  }
870  bool NppParameters::reloadLang()
871  {
872  	generic_string nativeLangPath(_localizationSwitcher._nativeLangPath);
873  	if (!PathFileExists(nativeLangPath.c_str()))
874  	{
875  		nativeLangPath = _nppPath;
876  		pathAppend(nativeLangPath, generic_string(TEXT("nativeLang.xml")));
877  		if (!PathFileExists(nativeLangPath.c_str()))
878  			return false;
879  	}
880  	delete _pXmlNativeLangDocA;
881  	_pXmlNativeLangDocA = new TiXmlDocumentA();
882  	bool loadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());
883  	if (!loadOkay)
884  	{
885  		delete _pXmlNativeLangDocA;
886  		_pXmlNativeLangDocA = nullptr;
887  		return false;
888  	}
889  	return loadOkay;
890  }
891  generic_string NppParameters::getSpecialFolderLocation(int folderKind)
892  {
893  	TCHAR path[MAX_PATH];
894  	const HRESULT specialLocationResult = SHGetFolderPath(nullptr, folderKind, nullptr, SHGFP_TYPE_CURRENT, path);
895  	generic_string result;
896  	if (SUCCEEDED(specialLocationResult))
897  	{
898  		result = path;
899  	}
900  	return result;
901  }
902  generic_string NppParameters::getSettingsFolder()
903  {
904  	if (_isLocal)
905  		return _nppPath;
906  	generic_string settingsFolderPath = getSpecialFolderLocation(CSIDL_APPDATA);
907  	if (settingsFolderPath.empty())
908  		return _nppPath;
909  	pathAppend(settingsFolderPath, TEXT("Notepad++"));
910  	return settingsFolderPath;
911  }
912  bool NppParameters::load()
913  {
914  	L_END = L_EXTERNAL;
915  	bool isAllLaoded = true;
916  	_isx64 = sizeof(void *) == 8;
917  	generic_string localConfPath(_nppPath);
918  	pathAppend(localConfPath, localConfFile);
919  	_isLocal = (PathFileExists(localConfPath.c_str()) == TRUE);
920  	if (_isLocal)
921  	{
922  		if (_winVersion >= WV_VISTA)
923  		{
924  			generic_string progPath = getSpecialFolderLocation(CSIDL_PROGRAM_FILES);
925  			TCHAR nppDirLocation[MAX_PATH];
926  			wcscpy_s(nppDirLocation, _nppPath.c_str());
927  			::PathRemoveFileSpec(nppDirLocation);
928  			if  (progPath == nppDirLocation)
929  				_isLocal = false;
930  		}
931  	}
932  	_pluginRootDir = _nppPath;
933  	pathAppend(_pluginRootDir, TEXT("plugins"));
934  	generic_string nppPluginRootParent;
935  	if (_isLocal)
936  	{
937  		_userPath = nppPluginRootParent = _nppPath;
938  		_userPluginConfDir = _pluginRootDir;
939  		pathAppend(_userPluginConfDir, TEXT("Config"));
940  	}
941  	else
942  	{
943  		_userPath = getSpecialFolderLocation(CSIDL_APPDATA);
944  		pathAppend(_userPath, TEXT("Notepad++"));
945  		if (!PathFileExists(_userPath.c_str()))
946  			::CreateDirectory(_userPath.c_str(), NULL);
947  		_appdataNppDir = _userPluginConfDir = _userPath;
948  		pathAppend(_userPluginConfDir, TEXT("plugins"));
949  		if (!PathFileExists(_userPluginConfDir.c_str()))
950  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
951  		pathAppend(_userPluginConfDir, TEXT("Config"));
952  		if (!PathFileExists(_userPluginConfDir.c_str()))
953  			::CreateDirectory(_userPluginConfDir.c_str(), NULL);
954  		setElevationRequired(true);
955  	}
956  	_pluginConfDir = _pluginRootDir; 
957  	pathAppend(_pluginConfDir, TEXT("Config"));
958  	if (!PathFileExists(nppPluginRootParent.c_str()))
959  		::CreateDirectory(nppPluginRootParent.c_str(), NULL);
960  	if (!PathFileExists(_pluginRootDir.c_str()))
961  		::CreateDirectory(_pluginRootDir.c_str(), NULL);
962  	_sessionPath = _userPath; 
963  	generic_string cloudChoicePath{_userPath};
964  	cloudChoicePath += TEXT("\\cloud\\choice");
965  	_isCloud = (::PathFileExists(cloudChoicePath.c_str()) == TRUE);
966  	if (_isCloud)
967  	{
968  		std::string cloudChoiceStr = getFileContent(cloudChoicePath.c_str());
969  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
970  		std::wstring cloudChoiceStrW = wmc.char2wchar(cloudChoiceStr.c_str(), SC_CP_UTF8);
971  		if (!cloudChoiceStrW.empty() && ::PathFileExists(cloudChoiceStrW.c_str()))
972  		{
973  			_userPath = cloudChoiceStrW;
974  			_nppGUI._cloudPath = cloudChoiceStrW;
975  			_initialCloudChoice = _nppGUI._cloudPath;
976  		}
977  		else
978  		{
979  			_isCloud = false;
980  		}
981  	}
982  	if (!_cmdSettingsDir.empty())
983  	{
984  		if (!::PathIsDirectory(_cmdSettingsDir.c_str()))
985  		{
986  			generic_string errMsg = TEXT("The given path\r");
987  			errMsg += _cmdSettingsDir;
988  			errMsg += TEXT("\nvia command line \"-settingsDir=\" is not a valid directory.\rThis argument will be ignored.");
989  			::MessageBox(NULL, errMsg.c_str(), TEXT("Invalid directory"), MB_OK);
990  		}
991  		else
992  		{
993  			_userPath = _cmdSettingsDir;
994  			_sessionPath = _userPath; 
995  		}
996  	}
997  	generic_string langs_xml_path(_userPath);
998  	pathAppend(langs_xml_path, TEXT("langs.xml"));
999  	BOOL doRecover = FALSE;
1000  	if (::PathFileExists(langs_xml_path.c_str()))
1001  	{
1002  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
1003  		if (GetFileAttributesEx(langs_xml_path.c_str(), GetFileExInfoStandard, &attributes) != 0)
1004  		{
1005  			if (attributes.nFileSizeLow == 0 && attributes.nFileSizeHigh == 0)
1006  			{
1007  				if (_pNativeLangSpeaker)
1008  				{
1009  					doRecover = _pNativeLangSpeaker->messageBox("LoadLangsFailed",
1010  						NULL,
1011  						TEXT("Load langs.xml failed!\rDo you want to recover your langs.xml?"),
1012  						TEXT("Configurator"),
1013  						MB_YESNO);
1014  				}
1015  				else
1016  				{
1017  					doRecover = ::MessageBox(NULL, TEXT("Load langs.xml failed!\rDo you want to recover your langs.xml?"), TEXT("Configurator"), MB_YESNO);
1018  				}
1019  			}
1020  		}
1021  	}
1022  	else
1023  		doRecover = true;
1024  	if (doRecover)
1025  	{
1026  		generic_string srcLangsPath(_nppPath);
1027  		pathAppend(srcLangsPath, TEXT("langs.model.xml"));
1028  		::CopyFile(srcLangsPath.c_str(), langs_xml_path.c_str(), FALSE);
1029  	}
1030  	_pXmlDoc = new TiXmlDocument(langs_xml_path);
1031  	bool loadOkay = _pXmlDoc->LoadFile();
1032  	if (!loadOkay)
1033  	{
1034  		if (_pNativeLangSpeaker)
1035  		{
1036  			_pNativeLangSpeaker->messageBox("LoadLangsFailedFinal",
1037  				NULL,
1038  				TEXT("Load langs.xml failed!"),
1039  				TEXT("Configurator"),
1040  				MB_OK);
1041  		}
1042  		else
1043  		{
1044  			::MessageBox(NULL, TEXT("Load langs.xml failed!"), TEXT("Configurator"), MB_OK);
1045  		}
1046  		delete _pXmlDoc;
1047  		_pXmlDoc = nullptr;
1048  		isAllLaoded = false;
1049  	}
1050  	else
1051  		getLangKeywordsFromXmlTree();
1052  	generic_string configPath(_userPath);
1053  	pathAppend(configPath, TEXT("config.xml"));
1054  	generic_string srcConfigPath(_nppPath);
1055  	pathAppend(srcConfigPath, TEXT("config.model.xml"));
1056  	if (!::PathFileExists(configPath.c_str()))
1057  		::CopyFile(srcConfigPath.c_str(), configPath.c_str(), FALSE);
1058  	_pXmlUserDoc = new TiXmlDocument(configPath);
1059  	loadOkay = _pXmlUserDoc->LoadFile();
1060  	if (!loadOkay)
1061  	{
1062  		TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
1063  		_pXmlUserDoc->LinkEndChild(decl);
1064  	}
1065  	else
1066  	{
1067  		getUserParametersFromXmlTree();
1068  	}
1069  	_stylerPath = _userPath;
1070  	pathAppend(_stylerPath, TEXT("stylers.xml"));
1071  	if (!PathFileExists(_stylerPath.c_str()))
1072  	{
1073  		generic_string srcStylersPath(_nppPath);
1074  		pathAppend(srcStylersPath, TEXT("stylers.model.xml"));
1075  		::CopyFile(srcStylersPath.c_str(), _stylerPath.c_str(), TRUE);
1076  	}
1077  	if (_nppGUI._themeName.empty() || (!PathFileExists(_nppGUI._themeName.c_str())))
1078  		_nppGUI._themeName.assign(_stylerPath);
1079  	_pXmlUserStylerDoc = new TiXmlDocument(_nppGUI._themeName.c_str());
1080  	loadOkay = _pXmlUserStylerDoc->LoadFile();
1081  	if (!loadOkay)
1082  	{
1083  		if (_pNativeLangSpeaker)
1084  		{
1085  			_pNativeLangSpeaker->messageBox("LoadStylersFailed",
1086  				NULL,
1087  				TEXT("Load \"$STR_REPLACE$\" failed!"),
1088  				TEXT("Load stylers.xml failed"),
1089  				MB_OK,
1090  				0,
1091  				_stylerPath.c_str());
1092  		}
1093  		else
1094  		{
1095  			::MessageBox(NULL, _stylerPath.c_str(), TEXT("Load stylers.xml failed"), MB_OK);
1096  		}
1097  		delete _pXmlUserStylerDoc;
1098  		_pXmlUserStylerDoc = NULL;
1099  		isAllLaoded = false;
1100  	}
1101  	else
1102  		getUserStylersFromXmlTree();
1103  	_themeSwitcher._stylesXmlPath = _stylerPath;
1104  	_themeSwitcher.addDefaultThemeFromXml(_stylerPath);
1105  	_userDefineLangsFolderPath = _userDefineLangPath = _userPath;
1106  	pathAppend(_userDefineLangPath, TEXT("userDefineLang.xml"));
1107  	pathAppend(_userDefineLangsFolderPath, TEXT("userDefineLangs"));
1108  	std::vector<generic_string> udlFiles;
1109  	getFilesInFolder(udlFiles, TEXT("*.xml"), _userDefineLangsFolderPath);
1110  	_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
1111  	loadOkay = _pXmlUserLangDoc->LoadFile();
1112  	if (!loadOkay)
1113  	{
1114  		delete _pXmlUserLangDoc;
1115  		_pXmlUserLangDoc = nullptr;
1116  		isAllLaoded = false;
1117  	}
1118  	else
1119  	{
1120  		auto r = addUserDefineLangsFromXmlTree(_pXmlUserLangDoc);
1121  		if (r.second - r.first > 0)
1122  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(_pXmlUserLangDoc, false, true, r));
1123  	}
1124  	for (const auto& i : udlFiles)
1125  	{
1126  		auto udlDoc = new TiXmlDocument(i);
1127  		loadOkay = udlDoc->LoadFile();
1128  		if (!loadOkay)
1129  		{
1130  			delete udlDoc;
1131  		}
1132  		else
1133  		{
1134  			auto r = addUserDefineLangsFromXmlTree(udlDoc);
1135  			if (r.second - r.first > 0)
1136  				_pXmlUserLangsDoc.push_back(UdlXmlFileState(udlDoc, false, false, r));
1137  		}
1138  	}
1139  	generic_string nativeLangPath;
1140  	nativeLangPath = _userPath;
1141  	pathAppend(nativeLangPath, TEXT("nativeLang.xml"));
1142  	_localizationSwitcher._nativeLangPath = nativeLangPath;
1143  	if (!_startWithLocFileName.empty()) 
1144  	{
1145  		nativeLangPath = _nppPath;
1146  		pathAppend(nativeLangPath, TEXT("localization\\"));
1147  		pathAppend(nativeLangPath, _startWithLocFileName);
1148  	}
1149  	else 
1150  	{
1151  		if (!PathFileExists(nativeLangPath.c_str()))
1152  		{
1153  			nativeLangPath = _nppPath;
1154  			pathAppend(nativeLangPath, TEXT("nativeLang.xml"));
1155  		}
1156  	}
1157  	_pXmlNativeLangDocA = new TiXmlDocumentA();
1158  	loadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());
1159  	if (!loadOkay)
1160  	{
1161  		delete _pXmlNativeLangDocA;
1162  		_pXmlNativeLangDocA = nullptr;
1163  		isAllLaoded = false;
1164  	}
1165  	generic_string toolbarIconsPath(_userPath);
1166  	pathAppend(toolbarIconsPath, TEXT("toolbarIcons.xml"));
1167  	_pXmlToolIconsDoc = new TiXmlDocument(toolbarIconsPath);
1168  	loadOkay = _pXmlToolIconsDoc->LoadFile();
1169  	if (!loadOkay)
1170  	{
1171  		delete _pXmlToolIconsDoc;
1172  		_pXmlToolIconsDoc = nullptr;
1173  		isAllLaoded = false;
1174  	}
1175  	wstring v852NoNeedShortcutsBackup;
1176  	_shortcutsPath = v852NoNeedShortcutsBackup = _userPath;
1177  	pathAppend(_shortcutsPath, SHORTCUTSXML_FILENAME);
1178  	pathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
1179  	if (!PathFileExists(_shortcutsPath.c_str()))
1180  	{
1181  		generic_string srcShortcutsPath(_nppPath);
1182  		pathAppend(srcShortcutsPath, SHORTCUTSXML_FILENAME);
1183  		::CopyFile(srcShortcutsPath.c_str(), _shortcutsPath.c_str(), TRUE);
1184  		HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup.c_str(), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
1185  		::FlushFileBuffers(hFile);
1186  		::CloseHandle(hFile);
1187  	}
1188  	_pXmlShortcutDocA = new TiXmlDocumentA();
1189  	loadOkay = _pXmlShortcutDocA->LoadUnicodeFilePath(_shortcutsPath.c_str());
1190  	if (!loadOkay)
1191  	{
1192  		delete _pXmlShortcutDocA;
1193  		_pXmlShortcutDocA = nullptr;
1194  		isAllLaoded = false;
1195  	}
1196  	else
1197  	{
1198  		getShortcutsFromXmlTree();
1199  		getMacrosFromXmlTree();
1200  		getUserCmdsFromXmlTree();
1201  		getScintKeysFromXmlTree();
1202  	}
1203  	_contextMenuPath = _userPath;
1204  	pathAppend(_contextMenuPath, TEXT("contextMenu.xml"));
1205  	if (!PathFileExists(_contextMenuPath.c_str()))
1206  	{
1207  		generic_string srcContextMenuPath(_nppPath);
1208  		pathAppend(srcContextMenuPath, TEXT("contextMenu.xml"));
1209  		::CopyFile(srcContextMenuPath.c_str(), _contextMenuPath.c_str(), TRUE);
1210  	}
1211  	_pXmlContextMenuDocA = new TiXmlDocumentA();
1212  	loadOkay = _pXmlContextMenuDocA->LoadUnicodeFilePath(_contextMenuPath.c_str());
1213  	if (!loadOkay)
1214  	{
1215  		delete _pXmlContextMenuDocA;
1216  		_pXmlContextMenuDocA = nullptr;
1217  		isAllLaoded = false;
1218  	}
1219  	_tabContextMenuPath = _userPath;
1220  	pathAppend(_tabContextMenuPath, TEXT("tabContextMenu.xml"));
1221  	_pXmlTabContextMenuDocA = new TiXmlDocumentA();
1222  	loadOkay = _pXmlTabContextMenuDocA->LoadUnicodeFilePath(_tabContextMenuPath.c_str());
1223  	if (!loadOkay)
1224  	{
1225  		delete _pXmlTabContextMenuDocA;
1226  		_pXmlTabContextMenuDocA = nullptr;
1227  	}
1228  	pathAppend(_sessionPath, TEXT("session.xml"));
1229  	const NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
1230  	if (nppGUI._rememberLastSession)
1231  	{
1232  		TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(_sessionPath);
1233  		loadOkay = pXmlSessionDoc->LoadFile();
1234  		if (!loadOkay)
1235  			isAllLaoded = false;
1236  		else
1237  			getSessionFromXmlTree(pXmlSessionDoc, _session);
1238  		delete pXmlSessionDoc;
1239  		for (size_t i = 0, len = _pXmlExternalLexerDoc.size() ; i < len ; ++i)
1240  			if (_pXmlExternalLexerDoc[i])
1241  				delete _pXmlExternalLexerDoc[i];
1242  	}
1243  	generic_string enableSelectFgColorPath = _userPath;
1244  	pathAppend(enableSelectFgColorPath, TEXT("enableSelectFgColor.xml"));
1245  	if (PathFileExists(enableSelectFgColorPath.c_str()))
1246  	{
1247  		_isSelectFgColorEnabled = true;
1248  	}
1249  	generic_string filePath, filePath2, issueFileName;
1250  	filePath = _nppPath;
1251  	issueFileName = nppLogNetworkDriveIssue;
1252  	issueFileName += TEXT(".xml");
1253  	pathAppend(filePath, issueFileName);
1254  	_doNppLogNetworkDriveIssue = (PathFileExists(filePath.c_str()) == TRUE);
1255  	if (!_doNppLogNetworkDriveIssue)
1256  	{
1257  		filePath2 = _userPath;
1258  		pathAppend(filePath2, issueFileName);
1259  		_doNppLogNetworkDriveIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1260  	}
1261  	filePath = _nppPath;
1262  	issueFileName = nppLogNulContentCorruptionIssue;
1263  	issueFileName += TEXT(".xml");
1264  	pathAppend(filePath, issueFileName);
1265  	_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath.c_str()) == TRUE);
1266  	if (!_doNppLogNulContentCorruptionIssue)
1267  	{
1268  		filePath2 = _userPath;
1269  		pathAppend(filePath2, issueFileName);
1270  		_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath2.c_str()) == TRUE);
1271  	}
1272  	return isAllLaoded;
1273  }
1274  void NppParameters::destroyInstance()
1275  {
1276  	delete _pXmlDoc;
1277  	delete _pXmlUserDoc;
1278  	delete _pXmlUserStylerDoc;
1279  	for (auto& l : _pXmlUserLangsDoc)
1280  	{
1281  		delete l._udlXmlDoc;
1282  	}
1283  	delete _pXmlNativeLangDocA;
1284  	delete _pXmlToolIconsDoc;
1285  	delete _pXmlShortcutDocA;
1286  	delete _pXmlContextMenuDocA;
1287  	delete _pXmlTabContextMenuDocA;
1288  	delete 	getInstancePointer();
1289  }
1290  void NppParameters::saveConfig_xml()
1291  {
1292  	if (_pXmlUserDoc)
1293  		_pXmlUserDoc->SaveFile();
1294  }
1295  void NppParameters::setWorkSpaceFilePath(int i, const TCHAR* wsFile)
1296  {
1297  	if (i < 0 || i > 2 || !wsFile)
1298  		return;
1299  	_workSpaceFilePathes[i] = wsFile;
1300  }
1301  void NppParameters::removeTransparent(HWND hwnd)
1302  {
1303  	if (hwnd != nullptr)
1304  		::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) & ~WS_EX_LAYERED);
1305  }
1306  void NppParameters::SetTransparent(HWND hwnd, int percent)
1307  {
1308  	::SetWindowLongPtr(hwnd, GWL_EXSTYLE, ::GetWindowLongPtr(hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);
1309  	if (percent > 255)
1310  		percent = 255;
1311  	else if (percent < 0)
1312  		percent = 0;
1313  	::SetLayeredWindowAttributes(hwnd, 0, static_cast<BYTE>(percent), LWA_ALPHA);
1314  }
1315  bool NppParameters::isExistingExternalLangName(const char* newName) const
1316  {
1317  	if ((!newName) || (!newName[0]))
1318  		return true;
1319  	for (int i = 0 ; i < _nbExternalLang ; ++i)
1320  	{
1321  		if (_externalLangArray[i]->_name == newName)
1322  			return true;
1323  	}
1324  	return false;
1325  }
1326  const TCHAR* NppParameters::getUserDefinedLangNameFromExt(TCHAR *ext, TCHAR *fullName) const
1327  {
1328  	if ((!ext) || (!ext[0]))
1329  		return nullptr;
1330  	std::vector<generic_string> extVect;
1331  	int iMatched = -1;
1332  	for (int i = 0 ; i < _nbUserLang ; ++i)
1333  	{
1334  		extVect.clear();
1335  		cutString(_userLangArray[i]->_ext.c_str(), extVect);
1336  		for (size_t j = 0, len = extVect.size(); j < len; ++j)
1337  		{
1338  			if (!wcsicmp(extVect[j].c_str(), ext) || (wcschr(fullName, '.') && !wcsicmp(extVect[j].c_str(), fullName)))
1339  			{
1340  				iMatched = i;
1341  				if (((NppDarkMode::isEnabled() && _userLangArray[i]->_isDarkModeTheme)) ||
1342  					((!NppDarkMode::isEnabled() && !_userLangArray[i]->_isDarkModeTheme)))
1343  					return _userLangArray[i]->_name.c_str();
1344  			}
1345  		}
1346  	}
1347  	if (iMatched >= 0)
1348  	{
1349  		return _userLangArray[iMatched]->_name.c_str();
1350  	}
1351  	return nullptr;
1352  }
1353  int NppParameters::getExternalLangIndexFromName(const TCHAR* externalLangName) const
1354  {
1355  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1356  	for (int i = 0 ; i < _nbExternalLang ; ++i)
1357  	{
1358  		if (!lstrcmp(externalLangName, wmc.char2wchar(_externalLangArray[i]->_name.c_str(), CP_ACP)))
1359  			return i;
1360  	}
1361  	return -1;
1362  }
1363  UserLangContainer* NppParameters::getULCFromName(const TCHAR *userLangName)
1364  {
1365  	for (int i = 0 ; i < _nbUserLang ; ++i)
1366  	{
1367  		if (0 == lstrcmp(userLangName, _userLangArray[i]->_name.c_str()))
1368  			return _userLangArray[i];
1369  	}
1370  	return nullptr;
1371  }
1372  COLORREF NppParameters::getCurLineHilitingColour()
1373  {
1374  	const Style * pStyle = _widgetStyleArray.findByName(TEXT("Current line background colour"));
1375  	if (!pStyle)
1376  		return COLORREF(-1);
1377  	return pStyle->_bgColor;
1378  }
1379  void NppParameters::setCurLineHilitingColour(COLORREF colour2Set)
1380  {
1381  	Style * pStyle = _widgetStyleArray.findByName(TEXT("Current line background colour"));
1382  	if (!pStyle)
1383  		return;
1384  	pStyle->_bgColor = colour2Set;
1385  }
1386  static int CALLBACK EnumFontFamExProc(const LOGFONT* lpelfe, const TEXTMETRIC*, DWORD, LPARAM lParam)
1387  {
1388  	std::vector<generic_string>& strVect = *(std::vector<generic_string> *)lParam;
1389  	const int32_t vectSize = static_cast<int32_t>(strVect.size());
1390  	const TCHAR* lfFaceName = ((ENUMLOGFONTEX*)lpelfe)->elfLogFont.lfFaceName;
1391  	for (int i = vectSize - 1 ; i >= 0 ; i--)
1392  	{
1393  		if (0 == lstrcmp(strVect[i].c_str(), lfFaceName))
1394  			return 1;	
1395  	}
1396  	strVect.push_back(lfFaceName);
1397  	return 1; 
1398  }
1399  void NppParameters::setFontList(HWND hWnd)
1400  {
1401  	LOGFONT lf{};
1402  	_fontlist.clear();
1403  	_fontlist.reserve(64); 
1404  	_fontlist.push_back(generic_string());
1405  	lf.lfCharSet = DEFAULT_CHARSET;
1406  	lf.lfFaceName[0]='\0';
1407  	lf.lfPitchAndFamily = 0;
1408  	HDC hDC = ::GetDC(hWnd);
1409  	::EnumFontFamiliesEx(hDC, &lf, EnumFontFamExProc, reinterpret_cast<LPARAM>(&_fontlist), 0);
1410  }
1411  bool NppParameters::isInFontList(const generic_string& fontName2Search) const
1412  {
1413  	if (fontName2Search.empty())
1414  		return false;
1415  	for (size_t i = 0, len = _fontlist.size(); i < len; i++)
1416  	{
1417  		if (_fontlist[i] == fontName2Search)
1418  			return true;
1419  	}
1420  	return false;
1421  }
1422  LOGFONT NppParameters::getDefaultGUIFont(DefaultFontType type)
1423  {
1424  	LOGFONT lf{};
1425  	NONCLIENTMETRICS ncm{};
1426  	ncm.cbSize = sizeof(NONCLIENTMETRICS);
1427  	if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0) != FALSE)
1428  	{
1429  		switch (type)
1430  		{
1431  			case DefaultFontType::menu:
1432  			{
1433  				lf = ncm.lfMenuFont;
1434  				break;
1435  			}
1436  			case DefaultFontType::status:
1437  			{
1438  				lf = ncm.lfStatusFont;
1439  				break;
1440  			}
1441  			case DefaultFontType::caption:
1442  			{
1443  				lf = ncm.lfCaptionFont;
1444  				break;
1445  			}
1446  			case DefaultFontType::smcaption:
1447  			{
1448  				lf = ncm.lfSmCaptionFont;
1449  				break;
1450  			}
1451  			default:
1452  			{
1453  				lf = ncm.lfMessageFont;
1454  				break;
1455  			}
1456  		}
1457  	}
1458  	else 
1459  	{
1460  		auto hf = static_cast<HFONT>(::GetStockObject(DEFAULT_GUI_FONT));
1461  		::GetObject(hf, sizeof(LOGFONT), &lf);
1462  	}
1463  	return lf;
1464  }
1465  void NppParameters::getLangKeywordsFromXmlTree()
1466  {
1467  	TiXmlNode *root =
1468  		_pXmlDoc->FirstChild(TEXT("NotepadPlus"));
1469  		if (!root) return;
1470  	feedKeyWordsParameters(root);
1471  }
1472  void NppParameters::getExternalLexerFromXmlTree(TiXmlDocument* externalLexerDoc)
1473  {
1474  	TiXmlNode *root = externalLexerDoc->FirstChild(TEXT("NotepadPlus"));
1475  		if (!root) return;
1476  	feedKeyWordsParameters(root);
1477  	feedStylerArray(root);
1478  }
1479  int NppParameters::addExternalLangToEnd(ExternalLangContainer * externalLang)
1480  {
1481  	_externalLangArray[_nbExternalLang] = externalLang;
1482  	++_nbExternalLang;
1483  	++L_END;
1484  	return _nbExternalLang-1;
1485  }
1486  bool NppParameters::getUserStylersFromXmlTree()
1487  {
1488  	TiXmlNode *root = _pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus"));
1489  		if (!root) return false;
1490  	return feedStylerArray(root);
1491  }
1492  bool NppParameters::getUserParametersFromXmlTree()
1493  {
1494  	if (!_pXmlUserDoc)
1495  		return false;
1496  	TiXmlNode *root = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
1497  	if (!root)
1498  		return false;
1499  	feedGUIParameters(root);
1500  	feedFileListParameters(root);
1501  	TiXmlNode *node = root->FirstChildElement(TEXT("History"));
1502  	root->RemoveChild(node);
1503  	TiXmlElement HistoryNode(TEXT("History"));
1504  	root->InsertEndChild(HistoryNode);
1505  	feedFindHistoryParameters(root);
1506  	feedProjectPanelsParameters(root);
1507  	feedFileBrowserParameters(root);
1508  	feedColumnEditorParameters(root);
1509  	return true;
1510  }
1511  std::pair<unsigned char, unsigned char> NppParameters::addUserDefineLangsFromXmlTree(TiXmlDocument *tixmldoc)
1512  {
1513  	if (!tixmldoc)
1514  		return std::make_pair(static_cast<unsigned char>(0), static_cast<unsigned char>(0));
1515  	TiXmlNode *root = tixmldoc->FirstChild(TEXT("NotepadPlus"));
1516  	if (!root)
1517  		return std::make_pair(static_cast<unsigned char>(0), static_cast<unsigned char>(0));
1518  	return feedUserLang(root);
1519  }
1520  bool NppParameters::getShortcutsFromXmlTree()
1521  {
1522  	if (!_pXmlShortcutDocA)
1523  		return false;
1524  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1525  	if (!root)
1526  		return false;
1527  	feedShortcut(root);
1528  	return true;
1529  }
1530  bool NppParameters::getMacrosFromXmlTree()
1531  {
1532  	if (!_pXmlShortcutDocA)
1533  		return false;
1534  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1535  	if (!root)
1536  		return false;
1537  	feedMacros(root);
1538  	return true;
1539  }
1540  bool NppParameters::getUserCmdsFromXmlTree()
1541  {
1542  	if (!_pXmlShortcutDocA)
1543  		return false;
1544  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1545  	if (!root)
1546  		return false;
1547  	feedUserCmds(root);
1548  	return true;
1549  }
1550  bool NppParameters::getPluginCmdsFromXmlTree()
1551  {
1552  	if (!_pXmlShortcutDocA)
1553  		return false;
1554  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1555  	if (!root)
1556  		return false;
1557  	feedPluginCustomizedCmds(root);
1558  	return true;
1559  }
1560  bool NppParameters::getScintKeysFromXmlTree()
1561  {
1562  	if (!_pXmlShortcutDocA)
1563  		return false;
1564  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
1565  	if (!root)
1566  		return false;
1567  	feedScintKeys(root);
1568  	return true;
1569  }
1570  void NppParameters::initMenuKeys()
1571  {
1572  	int nbCommands = sizeof(winKeyDefs)/sizeof(WinMenuKeyDefinition);
1573  	WinMenuKeyDefinition wkd;
1574  	for (int i = 0; i < nbCommands; ++i)
1575  	{
1576  		wkd = winKeyDefs[i];
1577  		Shortcut sc((wkd.specialName ? wstring2string(wkd.specialName, CP_UTF8).c_str() : ""), wkd.isCtrl, wkd.isAlt, wkd.isShift, static_cast<unsigned char>(wkd.vKey));
1578  		_shortcuts.push_back( CommandShortcut(sc, wkd.functionId) );
1579  	}
1580  }
1581  void NppParameters::initScintillaKeys()
1582  {
1583  	int nbCommands = sizeof(scintKeyDefs)/sizeof(ScintillaKeyDefinition);
1584  	ScintillaKeyDefinition skd;
1585  	int prevIndex = -1;
1586  	int prevID = -1;
1587  	for (int i = 0; i < nbCommands; ++i)
1588  	{
1589  		skd = scintKeyDefs[i];
1590  		if (skd.functionId == prevID)
1591  		{
1592  			KeyCombo kc;
1593  			kc._isCtrl = skd.isCtrl;
1594  			kc._isAlt = skd.isAlt;
1595  			kc._isShift = skd.isShift;
1596  			kc._key = static_cast<unsigned char>(skd.vKey);
1597  			_scintillaKeyCommands[prevIndex].addKeyCombo(kc);
1598  		}
1599  		else
1600  		{
1601  			Shortcut s = Shortcut(wstring2string(skd.name, CP_UTF8).c_str(), skd.isCtrl, skd.isAlt, skd.isShift, static_cast<unsigned char>(skd.vKey));
1602  			ScintillaKeyMap sm = ScintillaKeyMap(s, skd.functionId, skd.redirFunctionId);
1603  			_scintillaKeyCommands.push_back(sm);
1604  			++prevIndex;
1605  		}
1606  		prevID = skd.functionId;
1607  	}
1608  }
1609  bool NppParameters::reloadContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu)
1610  {
1611  	_contextMenuItems.clear();
1612  	return getContextMenuFromXmlTree(mainMenuHadle, pluginsMenu);
1613  }
1614  int NppParameters::getCmdIdFromMenuEntryItemName(HMENU mainMenuHadle, const generic_string& menuEntryName, const generic_string& menuItemName)
1615  {
1616  	int nbMenuEntry = ::GetMenuItemCount(mainMenuHadle);
1617  	for (int i = 0; i < nbMenuEntry; ++i)
1618  	{
1619  		TCHAR menuEntryString[menuItemStrLenMax];
1620  		::GetMenuString(mainMenuHadle, i, menuEntryString, menuItemStrLenMax, MF_BYPOSITION);
1621  		if (wcsicmp(menuEntryName.c_str(), purgeMenuItemString(menuEntryString).c_str()) == 0)
1622  		{
1623  			vector< pair<HMENU, int> > parentMenuPos;
1624  			HMENU topMenu = ::GetSubMenu(mainMenuHadle, i);
1625  			int maxTopMenuPos = ::GetMenuItemCount(topMenu);
1626  			HMENU currMenu = topMenu;
1627  			int currMaxMenuPos = maxTopMenuPos;
1628  			int currMenuPos = 0;
1629  			bool notFound = false;
1630  			do {
1631  				if (::GetSubMenu(currMenu, currMenuPos))
1632  				{
1633  					parentMenuPos.push_back(::make_pair(currMenu, currMenuPos));
1634  					currMenu = ::GetSubMenu(currMenu, currMenuPos);
1635  					currMenuPos = 0;
1636  					currMaxMenuPos = ::GetMenuItemCount(currMenu);
1637  				}
1638  				else
1639  				{
1640  					TCHAR cmdStr[menuItemStrLenMax];
1641  					::GetMenuString(currMenu, currMenuPos, cmdStr, menuItemStrLenMax, MF_BYPOSITION);
1642  					if (wcsicmp(menuItemName.c_str(), purgeMenuItemString(cmdStr).c_str()) == 0)
1643  					{
1644  						return ::GetMenuItemID(currMenu, currMenuPos);
1645  					}
1646  					if ((currMenuPos >= currMaxMenuPos) && (parentMenuPos.size() > 0))
1647  					{
1648  						currMenu = parentMenuPos.back().first;
1649  						currMenuPos = parentMenuPos.back().second;
1650  						parentMenuPos.pop_back();
1651  						currMaxMenuPos = ::GetMenuItemCount(currMenu);
1652  					}
1653  					if ((currMenu == topMenu) && (currMenuPos >= maxTopMenuPos))
1654  					{
1655  						notFound = true;
1656  					}
1657  					else
1658  					{
1659  						++currMenuPos;
1660  					}
1661  				}
1662  			} while (!notFound);
1663  		}
1664  	}
1665  	return -1;
1666  }
1667  int NppParameters::getPluginCmdIdFromMenuEntryItemName(HMENU pluginsMenu, const generic_string& pluginName, const generic_string& pluginCmdName)
1668  {
1669  	int nbPlugins = ::GetMenuItemCount(pluginsMenu);
1670  	for (int i = 0; i < nbPlugins; ++i)
1671  	{
1672  		TCHAR menuItemString[menuItemStrLenMax];
1673  		::GetMenuString(pluginsMenu, i, menuItemString, menuItemStrLenMax, MF_BYPOSITION);
1674  		if (wcsicmp(pluginName.c_str(), purgeMenuItemString(menuItemString).c_str()) == 0)
1675  		{
1676  			HMENU pluginMenu = ::GetSubMenu(pluginsMenu, i);
1677  			int nbPluginCmd = ::GetMenuItemCount(pluginMenu);
1678  			for (int j = 0; j < nbPluginCmd; ++j)
1679  			{
1680  				TCHAR pluginCmdStr[menuItemStrLenMax];
1681  				::GetMenuString(pluginMenu, j, pluginCmdStr, menuItemStrLenMax, MF_BYPOSITION);
1682  				if (wcsicmp(pluginCmdName.c_str(), purgeMenuItemString(pluginCmdStr).c_str()) == 0)
1683  				{
1684  					return ::GetMenuItemID(pluginMenu, j);
1685  				}
1686  			}
1687  		}
1688  	}
1689  	return -1;
1690  }
1691  bool NppParameters::getContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu, bool isEditCM)
1692  {
1693  	std::vector<MenuItemUnit>& contextMenuItems = isEditCM ? _contextMenuItems : _tabContextMenuItems;
1694  	TiXmlDocumentA* pXmlContextMenuDocA = isEditCM ? _pXmlContextMenuDocA : _pXmlTabContextMenuDocA;
1695  	std::string cmName = isEditCM ? "ScintillaContextMenu" : "TabContextMenu";
1696  	if (!pXmlContextMenuDocA)
1697  		return false;
1698  	TiXmlNodeA *root = pXmlContextMenuDocA->FirstChild("NotepadPlus");
1699  	if (!root)
1700  		return false;
1701  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1702  	NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
1703  	TiXmlNodeA *contextMenuRoot = root->FirstChildElement(cmName.c_str());
1704  	if (contextMenuRoot)
1705  	{
1706  		for (TiXmlNodeA *childNode = contextMenuRoot->FirstChildElement("Item");
1707  			childNode ;
1708  			childNode = childNode->NextSibling("Item") )
1709  		{
1710  			const char *folderNameDefaultA = (childNode->ToElement())->Attribute("FolderName");
1711  			const char *folderNameTranslateID_A = (childNode->ToElement())->Attribute("TranslateID");
1712  			const char *displayAsA = (childNode->ToElement())->Attribute("ItemNameAs");
1713  			generic_string folderName;
1714  			generic_string displayAs;
1715  			folderName = folderNameDefaultA ? wmc.char2wchar(folderNameDefaultA, SC_CP_UTF8) : TEXT("");
1716  			displayAs = displayAsA ? wmc.char2wchar(displayAsA, SC_CP_UTF8) : TEXT("");
1717  			if (folderNameTranslateID_A)
1718  			{
1719  				folderName = pNativeSpeaker->getLocalizedStrFromID(folderNameTranslateID_A, folderName);
1720  			}
1721  			int id;
1722  			const char *idStr = (childNode->ToElement())->Attribute("id", &id);
1723  			if (idStr)
1724  			{
1725  				contextMenuItems.push_back(MenuItemUnit(id, displayAs.c_str(), folderName.c_str()));
1726  			}
1727  			else
1728  			{
1729  				const char *menuEntryNameA = (childNode->ToElement())->Attribute("MenuEntryName");
1730  				const char *menuItemNameA = (childNode->ToElement())->Attribute("MenuItemName");
1731  				generic_string menuEntryName;
1732  				generic_string menuItemName;
1733  				menuEntryName = menuEntryNameA?wmc.char2wchar(menuEntryNameA, SC_CP_UTF8):TEXT("");
1734  				menuItemName = menuItemNameA?wmc.char2wchar(menuItemNameA, SC_CP_UTF8):TEXT("");
1735  				if (!menuEntryName.empty() && !menuItemName.empty())
1736  				{
1737  					int cmd = getCmdIdFromMenuEntryItemName(mainMenuHadle, menuEntryName, menuItemName);
1738  					if (cmd != -1)
1739  						contextMenuItems.push_back(MenuItemUnit(cmd, displayAs.c_str(), folderName.c_str()));
1740  				}
1741  				else
1742  				{
1743  					const char *pluginNameA = (childNode->ToElement())->Attribute("PluginEntryName");
1744  					const char *pluginCmdNameA = (childNode->ToElement())->Attribute("PluginCommandItemName");
1745  					generic_string pluginName;
1746  					generic_string pluginCmdName;
1747  					pluginName = pluginNameA?wmc.char2wchar(pluginNameA, SC_CP_UTF8):TEXT("");
1748  					pluginCmdName = pluginCmdNameA?wmc.char2wchar(pluginCmdNameA, SC_CP_UTF8):TEXT("");
1749  					if (pluginsMenu && !pluginName.empty() && !pluginCmdName.empty())
1750  					{
1751  						int pluginCmdId = getPluginCmdIdFromMenuEntryItemName(pluginsMenu, pluginName, pluginCmdName);
1752  						if (pluginCmdId != -1)
1753  							contextMenuItems.push_back(MenuItemUnit(pluginCmdId, displayAs.c_str(), folderName.c_str()));
1754  					}
1755  				}
1756  			}
1757  		}
1758  	}
1759  	return true;
1760  }
1761  void NppParameters::setWorkingDir(const TCHAR * newPath)
1762  {
1763  	if (newPath && newPath[0])
1764  	{
1765  		_currentDirectory = newPath;
1766  	}
1767  	else
1768  	{
1769  		if (PathFileExists(_nppGUI._defaultDirExp))
1770  			_currentDirectory = _nppGUI._defaultDirExp;
1771  		else
1772  			_currentDirectory = _nppPath.c_str();
1773  	}
1774  }
1775  bool NppParameters::loadSession(Session & session, const TCHAR *sessionFileName)
1776  {
1777  	TiXmlDocument *pXmlSessionDocument = new TiXmlDocument(sessionFileName);
1778  	bool loadOkay = pXmlSessionDocument->LoadFile();
1779  	if (loadOkay)
1780  		loadOkay = getSessionFromXmlTree(pXmlSessionDocument, session);
1781  	delete pXmlSessionDocument;
1782  	return loadOkay;
1783  }
1784  bool NppParameters::getSessionFromXmlTree(TiXmlDocument *pSessionDoc, Session& session)
1785  {
1786  	if (!pSessionDoc)
1787  		return false;
1788  	TiXmlNode *root = pSessionDoc->FirstChild(TEXT("NotepadPlus"));
1789  	if (!root)
1790  		return false;
1791  	TiXmlNode *sessionRoot = root->FirstChildElement(TEXT("Session"));
1792  	if (!sessionRoot)
1793  		return false;
1794  	TiXmlElement *actView = sessionRoot->ToElement();
1795  	int index = 0;
1796  	const TCHAR *str = actView->Attribute(TEXT("activeView"), &index);
1797  	if (str)
1798  	{
1799  		session._activeView = index;
1800  	}
1801  	const size_t nbView = 2;
1802  	TiXmlNode *viewRoots[nbView];
1803  	viewRoots[0] = sessionRoot->FirstChildElement(TEXT("mainView"));
1804  	viewRoots[1] = sessionRoot->FirstChildElement(TEXT("subView"));
1805  	for (size_t k = 0; k < nbView; ++k)
1806  	{
1807  		if (viewRoots[k])
1808  		{
1809  			int index2 = 0;
1810  			TiXmlElement *actIndex = viewRoots[k]->ToElement();
1811  			str = actIndex->Attribute(TEXT("activeIndex"), &index2);
1812  			if (str)
1813  			{
1814  				if (k == 0)
1815  					session._activeMainIndex = index2;
1816  				else 
1817  					session._activeSubIndex = index2;
1818  			}
1819  			for (TiXmlNode *childNode = viewRoots[k]->FirstChildElement(TEXT("File"));
1820  				childNode ;
1821  				childNode = childNode->NextSibling(TEXT("File")) )
1822  			{
1823  				const TCHAR *fileName = (childNode->ToElement())->Attribute(TEXT("filename"));
1824  				if (fileName)
1825  				{
1826  					Position position;
1827  					const TCHAR* posStr = (childNode->ToElement())->Attribute(TEXT("firstVisibleLine"));
1828  					if (posStr)
1829  						position._firstVisibleLine = static_cast<intptr_t>(_ttoi64(posStr));
1830  					posStr = (childNode->ToElement())->Attribute(TEXT("xOffset"));
1831  					if (posStr)
1832  						position._xOffset = static_cast<intptr_t>(_ttoi64(posStr));
1833  					posStr = (childNode->ToElement())->Attribute(TEXT("startPos"));
1834  					if (posStr)
1835  						position._startPos = static_cast<intptr_t>(_ttoi64(posStr));
1836  					posStr = (childNode->ToElement())->Attribute(TEXT("endPos"));
1837  					if (posStr)
1838  						position._endPos = static_cast<intptr_t>(_ttoi64(posStr));
1839  					posStr = (childNode->ToElement())->Attribute(TEXT("selMode"));
1840  					if (posStr)
1841  						position._selMode = static_cast<intptr_t>(_ttoi64(posStr));
1842  					posStr = (childNode->ToElement())->Attribute(TEXT("scrollWidth"));
1843  					if (posStr)
1844  						position._scrollWidth = static_cast<intptr_t>(_ttoi64(posStr));
1845  					posStr = (childNode->ToElement())->Attribute(TEXT("offset"));
1846  					if (posStr)
1847  						position._offset = static_cast<intptr_t>(_ttoi64(posStr));
1848  					posStr = (childNode->ToElement())->Attribute(TEXT("wrapCount"));
1849  					if (posStr)
1850  						position._wrapCount = static_cast<intptr_t>(_ttoi64(posStr));
1851  					MapPosition mapPosition;
1852  					const TCHAR* mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapFirstVisibleDisplayLine"));
1853  					if (mapPosStr)
1854  						mapPosition._firstVisibleDisplayLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1855  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapFirstVisibleDocLine"));
1856  					if (mapPosStr)
1857  						mapPosition._firstVisibleDocLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1858  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapLastVisibleDocLine"));
1859  					if (mapPosStr)
1860  						mapPosition._lastVisibleDocLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1861  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapNbLine"));
1862  					if (mapPosStr)
1863  						mapPosition._nbLine = static_cast<intptr_t>(_ttoi64(mapPosStr));
1864  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapHigherPos"));
1865  					if (mapPosStr)
1866  						mapPosition._higherPos = static_cast<intptr_t>(_ttoi64(mapPosStr));
1867  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapWidth"));
1868  					if (mapPosStr)
1869  						mapPosition._width = static_cast<intptr_t>(_ttoi64(mapPosStr));
1870  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapHeight"));
1871  					if (mapPosStr)
1872  						mapPosition._height = static_cast<intptr_t>(_ttoi64(mapPosStr));
1873  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapKByteInDoc"));
1874  					if (mapPosStr)
1875  						mapPosition._KByteInDoc = static_cast<intptr_t>(_ttoi64(mapPosStr));
1876  					mapPosStr = (childNode->ToElement())->Attribute(TEXT("mapWrapIndentMode"));
1877  					if (mapPosStr)
1878  						mapPosition._wrapIndentMode = static_cast<intptr_t>(_ttoi64(mapPosStr));
1879  					const TCHAR *boolStr = (childNode->ToElement())->Attribute(TEXT("mapIsWrap"));
1880  					if (boolStr)
1881  						mapPosition._isWrap = (lstrcmp(TEXT("yes"), boolStr) == 0);
1882  					const TCHAR *langName;
1883  					langName = (childNode->ToElement())->Attribute(TEXT("lang"));
1884  					int encoding = -1;
1885  					const TCHAR *encStr = (childNode->ToElement())->Attribute(TEXT("encoding"), &encoding);
1886  					const TCHAR *backupFilePath = (childNode->ToElement())->Attribute(TEXT("backupFilePath"));
1887  					FILETIME fileModifiedTimestamp{};
1888  					(childNode->ToElement())->Attribute(TEXT("originalFileLastModifTimestamp"), reinterpret_cast<int32_t*>(&fileModifiedTimestamp.dwLowDateTime));
1889  					(childNode->ToElement())->Attribute(TEXT("originalFileLastModifTimestampHigh"), reinterpret_cast<int32_t*>(&fileModifiedTimestamp.dwHighDateTime));
1890  					bool isUserReadOnly = false;
1891  					const TCHAR *boolStrReadOnly = (childNode->ToElement())->Attribute(TEXT("userReadOnly"));
1892  					if (boolStrReadOnly)
1893  						isUserReadOnly = _wcsicmp(TEXT("yes"), boolStrReadOnly) == 0;
1894  					sessionFileInfo sfi(fileName, langName, encStr ? encoding : -1, isUserReadOnly, position, backupFilePath, fileModifiedTimestamp, mapPosition);
1895  					const TCHAR* intStrTabColour = (childNode->ToElement())->Attribute(TEXT("tabColourId"));
1896  					if (intStrTabColour)
1897  					{
1898  						sfi._individualTabColour = _wtoi(intStrTabColour);
1899  					}
1900  					for (TiXmlNode *markNode = childNode->FirstChildElement(TEXT("Mark"));
1901  						markNode;
1902  						markNode = markNode->NextSibling(TEXT("Mark")))
1903  					{
1904  						const TCHAR* lineNumberStr = (markNode->ToElement())->Attribute(TEXT("line"));
1905  						if (lineNumberStr)
1906  						{
1907  							sfi._marks.push_back(static_cast<size_t>(_ttoi64(lineNumberStr)));
1908  						}
1909  					}
1910  					for (TiXmlNode *foldNode = childNode->FirstChildElement(TEXT("Fold"));
1911  						foldNode;
1912  						foldNode = foldNode->NextSibling(TEXT("Fold")))
1913  					{
1914  						const TCHAR *lineNumberStr = (foldNode->ToElement())->Attribute(TEXT("line"));
1915  						if (lineNumberStr)
1916  						{
1917  							sfi._foldStates.push_back(static_cast<size_t>(_ttoi64(lineNumberStr)));
1918  						}
1919  					}
1920  					if (k == 0)
1921  						session._mainViewFiles.push_back(sfi);
1922  					else 
1923  						session._subViewFiles.push_back(sfi);
1924  				}
1925  			}
1926  		}
1927  	}
1928  	TiXmlNode *fileBrowserRoot = sessionRoot->FirstChildElement(TEXT("FileBrowser"));
1929  	if (fileBrowserRoot)
1930  	{
1931  		const TCHAR *selectedItemPath = (fileBrowserRoot->ToElement())->Attribute(TEXT("latestSelectedItem"));
1932  		if (selectedItemPath)
1933  		{
1934  			session._fileBrowserSelectedItem = selectedItemPath;
1935  		}
1936  		for (TiXmlNode *childNode = fileBrowserRoot->FirstChildElement(TEXT("root"));
1937  			childNode;
1938  			childNode = childNode->NextSibling(TEXT("root")))
1939  		{
1940  			const TCHAR *fileName = (childNode->ToElement())->Attribute(TEXT("foldername"));
1941  			if (fileName)
1942  			{
1943  				session._fileBrowserRoots.push_back({ fileName });
1944  			}
1945  		}
1946  	}
1947  	return true;
1948  }
1949  void NppParameters::feedFileListParameters(TiXmlNode *node)
1950  {
1951  	TiXmlNode *historyRoot = node->FirstChildElement(TEXT("History"));
1952  	if (!historyRoot) return;
1953  	int nbMaxFile = _nbMaxRecentFile;
1954  	const TCHAR *strVal = (historyRoot->ToElement())->Attribute(TEXT("nbMaxFile"), &nbMaxFile);
1955  	if (strVal && (nbMaxFile >= 0) && (nbMaxFile <= NB_MAX_LRF_FILE))
1956  		_nbMaxRecentFile = nbMaxFile;
1957  	int customLen = RECENTFILES_SHOWFULLPATH;
1958  	strVal = (historyRoot->ToElement())->Attribute(TEXT("customLength"), &customLen);
1959  	if (strVal)
1960  		_recentFileCustomLength = std::min<int>(customLen, NB_MAX_LRF_CUSTOMLENGTH);
1961  	strVal = (historyRoot->ToElement())->Attribute(TEXT("inSubMenu"));
1962  	if (strVal)
1963  		_putRecentFileInSubMenu = (lstrcmp(strVal, TEXT("yes")) == 0);
1964  	for (TiXmlNode *childNode = historyRoot->FirstChildElement(TEXT("File"));
1965  		childNode && (_nbRecentFile < NB_MAX_LRF_FILE);
1966  		childNode = childNode->NextSibling(TEXT("File")) )
1967  	{
1968  		const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("filename"));
1969  		if (filePath)
1970  		{
1971  			_LRFileList[_nbRecentFile] = new generic_string(filePath);
1972  			++_nbRecentFile;
1973  		}
1974  	}
1975  }
1976  void NppParameters::feedFileBrowserParameters(TiXmlNode *node)
1977  {
1978  	TiXmlNode *fileBrowserRoot = node->FirstChildElement(TEXT("FileBrowser"));
1979  	if (!fileBrowserRoot) return;
1980  	const TCHAR *selectedItemPath = (fileBrowserRoot->ToElement())->Attribute(TEXT("latestSelectedItem"));
1981  	if (selectedItemPath)
1982  	{
1983  		_fileBrowserSelectedItemPath = selectedItemPath;
1984  	}
1985  	for (TiXmlNode *childNode = fileBrowserRoot->FirstChildElement(TEXT("root"));
1986  		childNode;
1987  		childNode = childNode->NextSibling(TEXT("root")) )
1988  	{
1989  		const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("foldername"));
1990  		if (filePath)
1991  		{
1992  			_fileBrowserRoot.push_back(filePath);
1993  		}
1994  	}
1995  }
1996  void NppParameters::feedProjectPanelsParameters(TiXmlNode *node)
1997  {
1998  	TiXmlNode *projPanelRoot = node->FirstChildElement(TEXT("ProjectPanels"));
1999  	if (!projPanelRoot) return;
2000  	for (TiXmlNode *childNode = projPanelRoot->FirstChildElement(TEXT("ProjectPanel"));
2001  		childNode;
2002  		childNode = childNode->NextSibling(TEXT("ProjectPanel")) )
2003  	{
2004  		int index = 0;
2005  		const TCHAR *idStr = (childNode->ToElement())->Attribute(TEXT("id"), &index);
2006  		if (idStr && (index >= 0 && index <= 2))
2007  		{
2008  			const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("workSpaceFile"));
2009  			if (filePath)
2010  			{
2011  				_workSpaceFilePathes[index] = filePath;
2012  			}
2013  		}
2014  	}
2015  }
2016  void NppParameters::feedColumnEditorParameters(TiXmlNode *node)
2017  {
2018  	TiXmlNode * columnEditorRoot = node->FirstChildElement(TEXT("ColumnEditor"));
2019  	if (!columnEditorRoot) return;
2020  	const TCHAR* strVal = (columnEditorRoot->ToElement())->Attribute(TEXT("choice"));
2021  	if (strVal)
2022  	{
2023  		if (lstrcmp(strVal, TEXT("text")) == 0)
2024  			_columnEditParam._mainChoice = activeText;
2025  		else
2026  			_columnEditParam._mainChoice = activeNumeric;
2027  	}
2028  	TiXmlNode *childNode = columnEditorRoot->FirstChildElement(TEXT("text"));
2029  	if (!childNode) return;
2030  	const TCHAR* content = (childNode->ToElement())->Attribute(TEXT("content"));
2031  	if (content)
2032  	{
2033  		_columnEditParam._insertedTextContent = content;
2034  	}
2035  	childNode = columnEditorRoot->FirstChildElement(TEXT("number"));
2036  	if (!childNode) return;
2037  	int val;
2038  	strVal = (childNode->ToElement())->Attribute(TEXT("initial"), &val);
2039  	if (strVal)
2040  		_columnEditParam._initialNum = val;
2041  	strVal = (childNode->ToElement())->Attribute(TEXT("increase"), &val);
2042  	if (strVal)
2043  		_columnEditParam._increaseNum = val;
2044  	strVal = (childNode->ToElement())->Attribute(TEXT("repeat"), &val);
2045  	if (strVal)
2046  		_columnEditParam._repeatNum = val;
2047  	strVal = (childNode->ToElement())->Attribute(TEXT("formatChoice"));
2048  	if (strVal)
2049  	{
2050  		if (lstrcmp(strVal, TEXT("hex")) == 0)
2051  			_columnEditParam._formatChoice = 1;
2052  		else if (lstrcmp(strVal, TEXT("oct")) == 0)
2053  			_columnEditParam._formatChoice = 2;
2054  		else if (lstrcmp(strVal, TEXT("bin")) == 0)
2055  			_columnEditParam._formatChoice = 3;
2056  		else 
2057  			_columnEditParam._formatChoice = 0;
2058  	}
2059  	strVal = (childNode->ToElement())->Attribute(TEXT("leadingChoice"));
2060  	if (strVal)
2061  	{
2062  		_columnEditParam._leadingChoice = ColumnEditorParam::noneLeading;
2063  		if (lstrcmp(strVal, TEXT("zeros")) == 0)
2064  		{
2065  			_columnEditParam._leadingChoice = ColumnEditorParam::zeroLeading;
2066  		}
2067  		else if (lstrcmp(strVal, TEXT("spaces")) == 0)
2068  		{
2069  			_columnEditParam._leadingChoice = ColumnEditorParam::spaceLeading;
2070  		}
2071  	}
2072  }
2073  void NppParameters::feedFindHistoryParameters(TiXmlNode *node)
2074  {
2075  	TiXmlNode *findHistoryRoot = node->FirstChildElement(TEXT("FindHistory"));
2076  	if (!findHistoryRoot) return;
2077  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryPath"), &_findHistory._nbMaxFindHistoryPath);
2078  	if (_findHistory._nbMaxFindHistoryPath > NB_MAX_FINDHISTORY_PATH)
2079  	{
2080  		_findHistory._nbMaxFindHistoryPath = NB_MAX_FINDHISTORY_PATH;
2081  	}
2082  	if ((_findHistory._nbMaxFindHistoryPath > 0) && (_findHistory._nbMaxFindHistoryPath <= NB_MAX_FINDHISTORY_PATH))
2083  	{
2084  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Path"));
2085  			childNode && (_findHistory._findHistoryPaths.size() < NB_MAX_FINDHISTORY_PATH);
2086  			childNode = childNode->NextSibling(TEXT("Path")) )
2087  		{
2088  			const TCHAR *filePath = (childNode->ToElement())->Attribute(TEXT("name"));
2089  			if (filePath)
2090  			{
2091  				_findHistory._findHistoryPaths.push_back(generic_string(filePath));
2092  			}
2093  		}
2094  	}
2095  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryFilter"), &_findHistory._nbMaxFindHistoryFilter);
2096  	if (_findHistory._nbMaxFindHistoryFilter > NB_MAX_FINDHISTORY_FILTER)
2097  	{
2098  		_findHistory._nbMaxFindHistoryFilter = NB_MAX_FINDHISTORY_FILTER;
2099  	}
2100  	if ((_findHistory._nbMaxFindHistoryFilter > 0) && (_findHistory._nbMaxFindHistoryFilter <= NB_MAX_FINDHISTORY_FILTER))
2101  	{
2102  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Filter"));
2103  			childNode && (_findHistory._findHistoryFilters.size() < NB_MAX_FINDHISTORY_FILTER);
2104  			childNode = childNode->NextSibling(TEXT("Filter")))
2105  		{
2106  			const TCHAR *fileFilter = (childNode->ToElement())->Attribute(TEXT("name"));
2107  			if (fileFilter)
2108  			{
2109  				_findHistory._findHistoryFilters.push_back(generic_string(fileFilter));
2110  			}
2111  		}
2112  	}
2113  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryFind"), &_findHistory._nbMaxFindHistoryFind);
2114  	if (_findHistory._nbMaxFindHistoryFind > NB_MAX_FINDHISTORY_FIND)
2115  	{
2116  		_findHistory._nbMaxFindHistoryFind = NB_MAX_FINDHISTORY_FIND;
2117  	}
2118  	if ((_findHistory._nbMaxFindHistoryFind > 0) && (_findHistory._nbMaxFindHistoryFind <= NB_MAX_FINDHISTORY_FIND))
2119  	{
2120  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Find"));
2121  			childNode && (_findHistory._findHistoryFinds.size() < NB_MAX_FINDHISTORY_FIND);
2122  			childNode = childNode->NextSibling(TEXT("Find")))
2123  		{
2124  			const TCHAR *fileFind = (childNode->ToElement())->Attribute(TEXT("name"));
2125  			if (fileFind)
2126  			{
2127  				_findHistory._findHistoryFinds.push_back(generic_string(fileFind));
2128  			}
2129  		}
2130  	}
2131  	(findHistoryRoot->ToElement())->Attribute(TEXT("nbMaxFindHistoryReplace"), &_findHistory._nbMaxFindHistoryReplace);
2132  	if (_findHistory._nbMaxFindHistoryReplace > NB_MAX_FINDHISTORY_REPLACE)
2133  	{
2134  		_findHistory._nbMaxFindHistoryReplace = NB_MAX_FINDHISTORY_REPLACE;
2135  	}
2136  	if ((_findHistory._nbMaxFindHistoryReplace > 0) && (_findHistory._nbMaxFindHistoryReplace <= NB_MAX_FINDHISTORY_REPLACE))
2137  	{
2138  		for (TiXmlNode *childNode = findHistoryRoot->FirstChildElement(TEXT("Replace"));
2139  			childNode && (_findHistory._findHistoryReplaces.size() < NB_MAX_FINDHISTORY_REPLACE);
2140  			childNode = childNode->NextSibling(TEXT("Replace")))
2141  		{
2142  			const TCHAR *fileReplace = (childNode->ToElement())->Attribute(TEXT("name"));
2143  			if (fileReplace)
2144  			{
2145  				_findHistory._findHistoryReplaces.push_back(generic_string(fileReplace));
2146  			}
2147  		}
2148  	}
2149  	const TCHAR *boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("matchWord"));
2150  	if (boolStr)
2151  		_findHistory._isMatchWord = (lstrcmp(TEXT("yes"), boolStr) == 0);
2152  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("matchCase"));
2153  	if (boolStr)
2154  		_findHistory._isMatchCase = (lstrcmp(TEXT("yes"), boolStr) == 0);
2155  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("wrap"));
2156  	if (boolStr)
2157  		_findHistory._isWrap = (lstrcmp(TEXT("yes"), boolStr) == 0);
2158  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("directionDown"));
2159  	if (boolStr)
2160  		_findHistory._isDirectionDown = (lstrcmp(TEXT("yes"), boolStr) == 0);
2161  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifRecuisive"));
2162  	if (boolStr)
2163  		_findHistory._isFifRecuisive = (lstrcmp(TEXT("yes"), boolStr) == 0);
2164  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifInHiddenFolder"));
2165  	if (boolStr)
2166  		_findHistory._isFifInHiddenFolder = (lstrcmp(TEXT("yes"), boolStr) == 0);
2167  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel1"));
2168  	if (boolStr)
2169  		_findHistory._isFifProjectPanel_1 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2170  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel2"));
2171  	if (boolStr)
2172  		_findHistory._isFifProjectPanel_2 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2173  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifProjectPanel3"));
2174  	if (boolStr)
2175  		_findHistory._isFifProjectPanel_3 = (lstrcmp(TEXT("yes"), boolStr) == 0);
2176  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifFilterFollowsDoc"));
2177  	if (boolStr)
2178  		_findHistory._isFilterFollowDoc = (lstrcmp(TEXT("yes"), boolStr) == 0);
2179  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("fifFolderFollowsDoc"));
2180  	if (boolStr)
2181  		_findHistory._isFolderFollowDoc = (lstrcmp(TEXT("yes"), boolStr) == 0);
2182  	int mode = 0;
2183  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("searchMode"), &mode);
2184  	if (boolStr)
2185  		_findHistory._searchMode = (FindHistory::searchMode)mode;
2186  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("transparencyMode"), &mode);
2187  	if (boolStr)
2188  		_findHistory._transparencyMode = (FindHistory::transparencyMode)mode;
2189  	(findHistoryRoot->ToElement())->Attribute(TEXT("transparency"), &_findHistory._transparency);
2190  	if (_findHistory._transparency <= 0 || _findHistory._transparency > 200)
2191  		_findHistory._transparency = 150;
2192  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("dotMatchesNewline"));
2193  	if (boolStr)
2194  		_findHistory._dotMatchesNewline = (lstrcmp(TEXT("yes"), boolStr) == 0);
2195  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("isSearch2ButtonsMode"));
2196  	if (boolStr)
2197  		_findHistory._isSearch2ButtonsMode = (lstrcmp(TEXT("yes"), boolStr) == 0);
2198  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("regexBackward4PowerUser"));
2199  	if (boolStr)
2200  		_findHistory._regexBackward4PowerUser = (lstrcmp(TEXT("yes"), boolStr) == 0);
2201  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("bookmarkLine"));
2202  	if (boolStr)
2203  		_findHistory._isBookmarkLine = (lstrcmp(TEXT("yes"), boolStr) == 0);
2204  	boolStr = (findHistoryRoot->ToElement())->Attribute(TEXT("purge"));
2205  	if (boolStr)
2206  		_findHistory._isPurge = (lstrcmp(TEXT("yes"), boolStr) == 0);
2207  }
2208  void NppParameters::feedShortcut(TiXmlNodeA *node)
2209  {
2210  	TiXmlNodeA *shortcutsRoot = node->FirstChildElement("InternalCommands");
2211  	if (!shortcutsRoot) return;
2212  	for (TiXmlNodeA *childNode = shortcutsRoot->FirstChildElement("Shortcut");
2213  		childNode ;
2214  		childNode = childNode->NextSibling("Shortcut"))
2215  	{
2216  		int id;
2217  		const char* idStr = (childNode->ToElement())->Attribute("id", &id);
2218  		if (idStr)
2219  		{
2220  			size_t len = _shortcuts.size();
2221  			for (size_t i = 0; i < len; ++i)
2222  			{
2223  				if (_shortcuts[i].getID() == (unsigned long)id)
2224  				{	
2225  					getShortcuts(childNode, _shortcuts[i]);
2226  					addUserModifiedIndex(i);
2227  				}
2228  			}
2229  		}
2230  	}
2231  }
2232  void NppParameters::feedMacros(TiXmlNodeA *node)
2233  {
2234  	TiXmlNodeA *macrosRoot = node->FirstChildElement("Macros");
2235  	if (!macrosRoot) return;
2236  	for (TiXmlNodeA *childNode = macrosRoot->FirstChildElement("Macro");
2237  		childNode ;
2238  		childNode = childNode->NextSibling("Macro"))
2239  	{
2240  		Shortcut sc;
2241  		string fdnm;
2242  		if (getShortcuts(childNode, sc, &fdnm))
2243  		{
2244  			Macro macro;
2245  			getActions(childNode, macro);
2246  			int cmdID = ID_MACRO + static_cast<int32_t>(_macros.size());
2247  			_macros.push_back(MacroShortcut(sc, macro, cmdID));
2248  			_macroMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2249  		}
2250  	}
2251  }
2252  void NppParameters::getActions(TiXmlNodeA *node, Macro & macro)
2253  {
2254  	for (TiXmlNodeA *childNode = node->FirstChildElement("Action");
2255  		childNode ;
2256  		childNode = childNode->NextSibling("Action") )
2257  	{
2258  		int type;
2259  		const char *typeStr = (childNode->ToElement())->Attribute("type", &type);
2260  		if ((!typeStr) || (type > 3))
2261  			continue;
2262  		int msg = 0;
2263  		(childNode->ToElement())->Attribute("message", &msg);
2264  		int wParam = 0;
2265  		(childNode->ToElement())->Attribute("wParam", &wParam);
2266  		int lParam = 0;
2267  		(childNode->ToElement())->Attribute("lParam", &lParam);
2268  		const char *sParam = (childNode->ToElement())->Attribute("sParam");
2269  		if (!sParam)
2270  			sParam = "";
2271  		recordedMacroStep step(msg, wParam, lParam, sParam, type);
2272  		if (step.isValid())
2273  			macro.push_back(step);
2274  	}
2275  }
2276  void NppParameters::feedUserCmds(TiXmlNodeA *node)
2277  {
2278  	TiXmlNodeA *userCmdsRoot = node->FirstChildElement("UserDefinedCommands");
2279  	if (!userCmdsRoot) return;
2280  	for (TiXmlNodeA *childNode = userCmdsRoot->FirstChildElement("Command");
2281  		childNode ;
2282  		childNode = childNode->NextSibling("Command") )
2283  	{
2284  		Shortcut sc;
2285  		string fdnm;
2286  		if (getShortcuts(childNode, sc, &fdnm))
2287  		{
2288  			TiXmlNodeA *aNode = childNode->FirstChild();
2289  			if (aNode)
2290  			{
2291  				const char* cmdStr = aNode->Value();
2292  				if (cmdStr)
2293  				{
2294  					int cmdID = ID_USER_CMD + static_cast<int32_t>(_userCommands.size());
2295  					_userCommands.push_back(UserCommand(sc, cmdStr, cmdID));
2296  					_runMenuItems.push_back(MenuItemUnit(cmdID, string2wstring(sc.getName(), CP_UTF8), string2wstring(fdnm, CP_UTF8)));
2297  				}
2298  			}
2299  		}
2300  	}
2301  }
2302  void NppParameters::feedPluginCustomizedCmds(TiXmlNodeA *node)
2303  {
2304  	TiXmlNodeA *pluginCustomizedCmdsRoot = node->FirstChildElement("PluginCommands");
2305  	if (!pluginCustomizedCmdsRoot) return;
2306  	for (TiXmlNodeA *childNode = pluginCustomizedCmdsRoot->FirstChildElement("PluginCommand");
2307  		childNode ;
2308  		childNode = childNode->NextSibling("PluginCommand") )
2309  	{
2310  		const char *moduleName = (childNode->ToElement())->Attribute("moduleName");
2311  		if (!moduleName)
2312  			continue;
2313  		int internalID = -1;
2314  		const char *internalIDStr = (childNode->ToElement())->Attribute("internalID", &internalID);
2315  		if (!internalIDStr)
2316  			continue;
2317  		size_t len = _pluginCommands.size();
2318  		for (size_t i = 0; i < len; ++i)
2319  		{
2320  			PluginCmdShortcut & pscOrig = _pluginCommands[i];
2321  			if (!strnicmp(pscOrig.getModuleName(), moduleName, strlen(moduleName)) && pscOrig.getInternalID() == internalID)
2322  			{
2323  				getShortcuts(childNode, _pluginCommands[i]);
2324  				addPluginModifiedIndex(i);
2325  				break;
2326  			}
2327  		}
2328  	}
2329  }
2330  void NppParameters::feedScintKeys(TiXmlNodeA *node)
2331  {
2332  	TiXmlNodeA *scintKeysRoot = node->FirstChildElement("ScintillaKeys");
2333  	if (!scintKeysRoot) return;
2334  	for (TiXmlNodeA *childNode = scintKeysRoot->FirstChildElement("ScintKey");
2335  		childNode ;
2336  		childNode = childNode->NextSibling("ScintKey") )
2337  	{
2338  		int scintKey;
2339  		const char *keyStr = (childNode->ToElement())->Attribute("ScintID", &scintKey);
2340  		if (!keyStr)
2341  			continue;
2342  		int menuID;
2343  		keyStr = (childNode->ToElement())->Attribute("menuCmdID", &menuID);
2344  		if (!keyStr)
2345  			continue;
2346  		size_t len = _scintillaKeyCommands.size();
2347  		for (int32_t i = 0; i < static_cast<int32_t>(len); ++i)
2348  		{
2349  			ScintillaKeyMap & skmOrig = _scintillaKeyCommands[i];
2350  			if (skmOrig.getScintillaKeyID() == (unsigned long)scintKey && skmOrig.getMenuCmdID() == menuID)
2351  			{
2352  				_scintillaKeyCommands[i].clearDups();
2353  				getShortcuts(childNode, _scintillaKeyCommands[i]);
2354  				_scintillaKeyCommands[i].setKeyComboByIndex(0, _scintillaKeyCommands[i].getKeyCombo());
2355  				addScintillaModifiedIndex(i);
2356  				KeyCombo kc;
2357  				for (TiXmlNodeA *nextNode = childNode->FirstChildElement("NextKey");
2358  					nextNode ;
2359  					nextNode = nextNode->NextSibling("NextKey"))
2360  				{
2361  					const char *str = (nextNode->ToElement())->Attribute("Ctrl");
2362  					if (!str)
2363  						continue;
2364  					kc._isCtrl = (strcmp("yes", str) == 0);
2365  					str = (nextNode->ToElement())->Attribute("Alt");
2366  					if (!str)
2367  						continue;
2368  					kc._isAlt = (strcmp("yes", str) == 0);
2369  					str = (nextNode->ToElement())->Attribute("Shift");
2370  					if (!str)
2371  						continue;
2372  					kc._isShift = (strcmp("yes", str) == 0);
2373  					int key;
2374  					str = (nextNode->ToElement())->Attribute("Key", &key);
2375  					if (!str)
2376  						continue;
2377  					kc._key = static_cast<unsigned char>(key);
2378  					_scintillaKeyCommands[i].addKeyCombo(kc);
2379  				}
2380  				break;
2381  			}
2382  		}
2383  	}
2384  }
2385  bool NppParameters::getShortcuts(TiXmlNodeA *node, Shortcut & sc, string* folderName)
2386  {
2387  	if (!node) return false;
2388  	const char* name = (node->ToElement())->Attribute("name");
2389  	if (!name)
2390  		name = "";
2391  	bool isCtrl = false;
2392  	const char* isCtrlStr = (node->ToElement())->Attribute("Ctrl");
2393  	if (isCtrlStr)
2394  		isCtrl = (strcmp("yes", isCtrlStr) == 0);
2395  	bool isAlt = false;
2396  	const char* isAltStr = (node->ToElement())->Attribute("Alt");
2397  	if (isAltStr)
2398  		isAlt = (strcmp("yes", isAltStr) == 0);
2399  	bool isShift = false;
2400  	const char* isShiftStr = (node->ToElement())->Attribute("Shift");
2401  	if (isShiftStr)
2402  		isShift = (strcmp("yes", isShiftStr) == 0);
2403  	int key;
2404  	const char* keyStr = (node->ToElement())->Attribute("Key", &key);
2405  	if (!keyStr)
2406  		return false;
2407  	if (folderName)
2408  	{
2409  		const char* fn = (node->ToElement())->Attribute("FolderName");
2410  		*folderName = fn ? fn : "";
2411  	}
2412  	sc = Shortcut(name, isCtrl, isAlt, isShift, static_cast<unsigned char>(key));
2413  	return true;
2414  }
2415  std::pair<unsigned char, unsigned char> NppParameters::feedUserLang(TiXmlNode *node)
2416  {
2417  	int iBegin = _nbUserLang;
2418  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("UserLang"));
2419  		childNode && (_nbUserLang < NB_MAX_USER_LANG);
2420  		childNode = childNode->NextSibling(TEXT("UserLang")) )
2421  	{
2422  		const TCHAR* name = (childNode->ToElement())->Attribute(TEXT("name"));
2423  		const TCHAR* ext = (childNode->ToElement())->Attribute(TEXT("ext"));
2424  		const TCHAR* darkModeTheme = (childNode->ToElement())->Attribute(TEXT("darkModeTheme"));
2425  		const TCHAR* udlVersion = (childNode->ToElement())->Attribute(TEXT("udlVersion"));
2426  		if (!name || !name[0] || !ext)
2427  		{
2428  			continue;
2429  		}
2430  		bool isDarkModeTheme = false;
2431  		if (darkModeTheme && darkModeTheme[0])
2432  		{
2433  			isDarkModeTheme = (lstrcmp(TEXT("yes"), darkModeTheme) == 0);
2434  		}
2435  		try {
2436  			_userLangArray[_nbUserLang] = new UserLangContainer(name, ext, isDarkModeTheme, udlVersion ? udlVersion : TEXT(""));
2437  			++_nbUserLang;
2438  			TiXmlNode *settingsRoot = childNode->FirstChildElement(TEXT("Settings"));
2439  			if (!settingsRoot)
2440  				throw std::runtime_error("NppParameters::feedUserLang : Settings node is missing");
2441  			feedUserSettings(settingsRoot);
2442  			TiXmlNode *keywordListsRoot = childNode->FirstChildElement(TEXT("KeywordLists"));
2443  			if (!keywordListsRoot)
2444  				throw std::runtime_error("NppParameters::feedUserLang : KeywordLists node is missing");
2445  			feedUserKeywordList(keywordListsRoot);
2446  			TiXmlNode *stylesRoot = childNode->FirstChildElement(TEXT("Styles"));
2447  			if (!stylesRoot)
2448  				throw std::runtime_error("NppParameters::feedUserLang : Styles node is missing");
2449  			feedUserStyles(stylesRoot);
2450  			for (int i = 0 ; i < SCE_USER_STYLE_TOTAL_STYLES ; ++i)
2451  			{
2452  				const Style * pStyle = _userLangArray[_nbUserLang - 1]->_styles.findByID(i);
2453  				if (!pStyle)
2454  					_userLangArray[_nbUserLang - 1]->_styles.addStyler(i, globalMappper().styleNameMapper[i]);
2455  			}
2456  		}
2457  		catch (const std::exception&)
2458  		{
2459  			delete _userLangArray[--_nbUserLang];
2460  		}
2461  	}
2462  	int iEnd = _nbUserLang;
2463  	return pair<unsigned char, unsigned char>(static_cast<unsigned char>(iBegin), static_cast<unsigned char>(iEnd));
2464  }
2465  bool NppParameters::importUDLFromFile(const generic_string& sourceFile)
2466  {
2467  	TiXmlDocument *pXmlUserLangDoc = new TiXmlDocument(sourceFile);
2468  	bool loadOkay = pXmlUserLangDoc->LoadFile();
2469  	if (loadOkay)
2470  	{
2471  		auto r = addUserDefineLangsFromXmlTree(pXmlUserLangDoc);
2472  		loadOkay = (r.second - r.first) != 0;
2473  		if (loadOkay)
2474  		{
2475  			_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, r));
2476  			setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
2477  		}
2478  	}
2479  	delete pXmlUserLangDoc;
2480  	return loadOkay;
2481  }
2482  bool NppParameters::exportUDLToFile(size_t langIndex2export, const generic_string& fileName2save)
2483  {
2484  	if (langIndex2export >= NB_MAX_USER_LANG)
2485  		return false;
2486  	if (static_cast<int32_t>(langIndex2export) >= _nbUserLang)
2487  		return false;
2488  	TiXmlDocument *pNewXmlUserLangDoc = new TiXmlDocument(fileName2save);
2489  	TiXmlNode *newRoot2export = pNewXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2490  	insertUserLang2Tree(newRoot2export, _userLangArray[langIndex2export]);
2491  	bool result = pNewXmlUserLangDoc->SaveFile();
2492  	delete pNewXmlUserLangDoc;
2493  	return result;
2494  }
2495  LangType NppParameters::getLangFromExt(const TCHAR *ext)
2496  {
2497  	int i = getNbLang();
2498  	i--;
2499  	while (i >= 0)
2500  	{
2501  		Lang *l = getLangFromIndex(i--);
2502  		const TCHAR *defList = l->getDefaultExtList();
2503  		const TCHAR *userList = NULL;
2504  		LexerStylerArray &lsa = getLStylerArray();
2505  		const TCHAR *lName = l->getLangName();
2506  		LexerStyler *pLS = lsa.getLexerStylerByName(lName);
2507  		if (pLS)
2508  			userList = pLS->getLexerUserExt();
2509  		generic_string list;
2510  		if (defList)
2511  			list += defList;
2512  		if (userList)
2513  		{
2514  			list += TEXT(" ");
2515  			list += userList;
2516  		}
2517  		if (isInList(ext, list.c_str()))
2518  			return l->getLangID();
2519  	}
2520  	return L_TEXT;
2521  }
2522  void NppParameters::setCloudChoice(const TCHAR *pathChoice)
2523  {
2524  	generic_string cloudChoicePath = getSettingsFolder();
2525  	cloudChoicePath += TEXT("\\cloud\\");
2526  	if (!PathFileExists(cloudChoicePath.c_str()))
2527  	{
2528  		::CreateDirectory(cloudChoicePath.c_str(), NULL);
2529  	}
2530  	cloudChoicePath += TEXT("choice");
2531  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2532  	std::string cloudPathA = wmc.wchar2char(pathChoice, SC_CP_UTF8);
2533  	writeFileContent(cloudChoicePath.c_str(), cloudPathA.c_str());
2534  }
2535  void NppParameters::removeCloudChoice()
2536  {
2537  	generic_string cloudChoicePath = getSettingsFolder();
2538  	cloudChoicePath += TEXT("\\cloud\\choice");
2539  	if (PathFileExists(cloudChoicePath.c_str()))
2540  	{
2541  		::DeleteFile(cloudChoicePath.c_str());
2542  	}
2543  }
2544  bool NppParameters::isCloudPathChanged() const
2545  {
2546  	if (_initialCloudChoice == _nppGUI._cloudPath)
2547  		return false;
2548  	else if (_initialCloudChoice.size() - _nppGUI._cloudPath.size() == 1)
2549  	{
2550  		TCHAR c = _initialCloudChoice.at(_initialCloudChoice.size()-1);
2551  		if (c == '\\' || c == '/')
2552  		{
2553  			if (_initialCloudChoice.find(_nppGUI._cloudPath) == 0)
2554  				return false;
2555  		}
2556  	}
2557  	else if (_nppGUI._cloudPath.size() - _initialCloudChoice.size() == 1)
2558  	{
2559  		TCHAR c = _nppGUI._cloudPath.at(_nppGUI._cloudPath.size() - 1);
2560  		if (c == '\\' || c == '/')
2561  		{
2562  			if (_nppGUI._cloudPath.find(_initialCloudChoice) == 0)
2563  				return false;
2564  		}
2565  	}
2566  	return true;
2567  }
2568  bool NppParameters::writeSettingsFilesOnCloudForThe1stTime(const generic_string & cloudSettingsPath)
2569  {
2570  	bool isOK = false;
2571  	if (cloudSettingsPath.empty())
2572  		return false;
2573  	generic_string cloudConfigPath = cloudSettingsPath;
2574  	pathAppend(cloudConfigPath, TEXT("config.xml"));
2575  	if (!::PathFileExists(cloudConfigPath.c_str()) && _pXmlUserDoc)
2576  	{
2577  		isOK = _pXmlUserDoc->SaveFile(cloudConfigPath.c_str());
2578  		if (!isOK)
2579  			return false;
2580  	}
2581  	generic_string cloudStylersPath = cloudSettingsPath;
2582  	pathAppend(cloudStylersPath, TEXT("stylers.xml"));
2583  	if (!::PathFileExists(cloudStylersPath.c_str()) && _pXmlUserStylerDoc)
2584  	{
2585  		isOK = _pXmlUserStylerDoc->SaveFile(cloudStylersPath.c_str());
2586  		if (!isOK)
2587  			return false;
2588  	}
2589  	generic_string cloudLangsPath = cloudSettingsPath;
2590  	pathAppend(cloudLangsPath, TEXT("langs.xml"));
2591  	if (!::PathFileExists(cloudLangsPath.c_str()) && _pXmlUserDoc)
2592  	{
2593  		isOK = _pXmlDoc->SaveFile(cloudLangsPath.c_str());
2594  		if (!isOK)
2595  			return false;
2596  	}
2597  	generic_string cloudUserLangsPath = cloudSettingsPath;
2598  	pathAppend(cloudUserLangsPath, TEXT("userDefineLang.xml"));
2599  	if (!::PathFileExists(cloudUserLangsPath.c_str()) && _pXmlUserLangDoc)
2600  	{
2601  		isOK = _pXmlUserLangDoc->SaveFile(cloudUserLangsPath.c_str());
2602  		if (!isOK)
2603  			return false;
2604  	}
2605  	generic_string cloudShortcutsPath = cloudSettingsPath;
2606  	pathAppend(cloudShortcutsPath, SHORTCUTSXML_FILENAME);
2607  	if (!::PathFileExists(cloudShortcutsPath.c_str()) && _pXmlShortcutDocA)
2608  	{
2609  		isOK = _pXmlShortcutDocA->SaveUnicodeFilePath(cloudShortcutsPath.c_str());
2610  		if (!isOK)
2611  			return false;
2612  	}
2613  	generic_string cloudContextMenuPath = cloudSettingsPath;
2614  	pathAppend(cloudContextMenuPath, TEXT("contextMenu.xml"));
2615  	if (!::PathFileExists(cloudContextMenuPath.c_str()) && _pXmlContextMenuDocA)
2616  	{
2617  		isOK = _pXmlContextMenuDocA->SaveUnicodeFilePath(cloudContextMenuPath.c_str());
2618  		if (!isOK)
2619  			return false;
2620  	}
2621  	generic_string cloudNativeLangPath = cloudSettingsPath;
2622  	pathAppend(cloudNativeLangPath, TEXT("nativeLang.xml"));
2623  	if (!::PathFileExists(cloudNativeLangPath.c_str()) && _pXmlNativeLangDocA)
2624  	{
2625  		isOK = _pXmlNativeLangDocA->SaveUnicodeFilePath(cloudNativeLangPath.c_str());
2626  		if (!isOK)
2627  			return false;
2628  	}
2629  	return true;
2630  }
2631  void NppParameters::writeDefaultUDL()
2632  {
2633  	bool firstCleanDone = false;
2634  	std::vector<std::pair<bool, bool>> deleteState; 
2635  	for (const auto& udl : _pXmlUserLangsDoc)
2636  	{
2637  		if (!_pXmlUserLangDoc)
2638  		{
2639  			_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);
2640  			TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
2641  			_pXmlUserLangDoc->LinkEndChild(decl);
2642  			_pXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2643  		}
2644  		bool toDelete = (udl._indexRange.second - udl._indexRange.first) == 0;
2645  		deleteState.push_back(std::pair(toDelete, udl._isInDefaultSharedContainer));
2646  		if ((!udl._udlXmlDoc || udl._udlXmlDoc == _pXmlUserLangDoc) && udl._isDirty && !toDelete) 
2647  		{
2648  			TiXmlNode *root = _pXmlUserLangDoc->FirstChild(TEXT("NotepadPlus"));
2649  			if (root && !firstCleanDone)
2650  			{
2651  				_pXmlUserLangDoc->RemoveChild(root);
2652  				_pXmlUserLangDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2653  				firstCleanDone = true;
2654  			}
2655  			root = _pXmlUserLangDoc->FirstChild(TEXT("NotepadPlus"));
2656  			for (int i = udl._indexRange.first; i < udl._indexRange.second; ++i)
2657  			{
2658  				insertUserLang2Tree(root, _userLangArray[i]);
2659  			}
2660  		}
2661  	}
2662  	bool deleteAll = true;
2663  	for (std::pair<bool, bool> udlState : deleteState)
2664  	{
2665  		if (!udlState.first && udlState.second) 
2666  		{
2667  			deleteAll = false; 
2668  			break;
2669  		}
2670  	}
2671  	if (firstCleanDone) 
2672  	{
2673  		_pXmlUserLangDoc->SaveFile();
2674  	}
2675  	else if (deleteAll)
2676  	{
2677  		if (::PathFileExists(_userDefineLangPath.c_str()))
2678  		{
2679  			::DeleteFile(_userDefineLangPath.c_str());
2680  		}
2681  	}
2682  }
2683  void NppParameters::writeNonDefaultUDL()
2684  {
2685  	for (auto& udl : _pXmlUserLangsDoc)
2686  	{
2687  		if (udl._isDirty && udl._udlXmlDoc != nullptr && udl._udlXmlDoc != _pXmlUserLangDoc)
2688  		{
2689  			if (udl._indexRange.second == udl._indexRange.first) 
2690  			{
2691  				const TCHAR* docFilePath = udl._udlXmlDoc->Value();
2692  				if (docFilePath && ::PathFileExists(docFilePath))
2693  				{
2694  					::DeleteFile(docFilePath);
2695  				}
2696  			}
2697  			else
2698  			{
2699  				TiXmlNode *root = udl._udlXmlDoc->FirstChild(TEXT("NotepadPlus"));
2700  				if (root)
2701  				{
2702  					udl._udlXmlDoc->RemoveChild(root);
2703  				}
2704  				udl._udlXmlDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2705  				root = udl._udlXmlDoc->FirstChild(TEXT("NotepadPlus"));
2706  				for (int i = udl._indexRange.first; i < udl._indexRange.second; ++i)
2707  				{
2708  					insertUserLang2Tree(root, _userLangArray[i]);
2709  				}
2710  				udl._udlXmlDoc->SaveFile();
2711  			}
2712  		}
2713  	}
2714  }
2715  void NppParameters::writeNeed2SaveUDL()
2716  {
2717  	writeDefaultUDL();
2718  	writeNonDefaultUDL();
2719  }
2720  void NppParameters::insertCmd(TiXmlNodeA *shortcutsRoot, const CommandShortcut & cmd)
2721  {
2722  	const KeyCombo & key = cmd.getKeyCombo();
2723  	TiXmlNodeA *sc = shortcutsRoot->InsertEndChild(TiXmlElementA("Shortcut"));
<span onclick='openModal()' class='match'>2724  	sc->ToElement()->SetAttribute("id", cmd.getID());
2725  	sc->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
</span>2726  	sc->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2727  	sc->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2728  	sc->ToElement()->SetAttribute("Key", key._key);
2729  }
2730  void NppParameters::insertMacro(TiXmlNodeA *macrosRoot, const MacroShortcut & macro, const string& folderName)
2731  {
2732  	const KeyCombo & key = macro.getKeyCombo();
2733  	TiXmlNodeA *macroRoot = macrosRoot->InsertEndChild(TiXmlElementA("Macro"));
2734  	macroRoot->ToElement()->SetAttribute("name", macro.getMenuName());
2735  	macroRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2736  	macroRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2737  	macroRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2738  	macroRoot->ToElement()->SetAttribute("Key", key._key);
2739  	if (!folderName.empty())
2740  	{
2741  		macroRoot->ToElement()->SetAttribute("FolderName", folderName);
2742  	}
2743  	for (size_t i = 0, len = macro._macro.size(); i < len ; ++i)
2744  	{
2745  		TiXmlNodeA *actionNode = macroRoot->InsertEndChild(TiXmlElementA("Action"));
2746  		const recordedMacroStep & action = macro._macro[i];
2747  		actionNode->ToElement()->SetAttribute("type", action._macroType);
2748  		actionNode->ToElement()->SetAttribute("message", action._message);
2749  		actionNode->ToElement()->SetAttribute("wParam", static_cast<int>(action._wParameter));
2750  		actionNode->ToElement()->SetAttribute("lParam", static_cast<int>(action._lParameter));
2751  		actionNode->ToElement()->SetAttribute("sParam", action._sParameter.c_str());
2752  	}
2753  }
2754  void NppParameters::insertUserCmd(TiXmlNodeA *userCmdRoot, const UserCommand & userCmd, const string& folderName)
2755  {
2756  	const KeyCombo & key = userCmd.getKeyCombo();
2757  	TiXmlNodeA *cmdRoot = userCmdRoot->InsertEndChild(TiXmlElementA("Command"));
2758  	cmdRoot->ToElement()->SetAttribute("name", userCmd.getMenuName());
2759  	cmdRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2760  	cmdRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2761  	cmdRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2762  	cmdRoot->ToElement()->SetAttribute("Key", key._key);
2763  	cmdRoot->InsertEndChild(TiXmlTextA(userCmd._cmd.c_str()));
2764  	if (!folderName.empty())
2765  	{
2766  		cmdRoot->ToElement()->SetAttribute("FolderName", folderName);
2767  	}
2768  }
2769  void NppParameters::insertPluginCmd(TiXmlNodeA *pluginCmdRoot, const PluginCmdShortcut & pluginCmd)
2770  {
2771  	const KeyCombo & key = pluginCmd.getKeyCombo();
2772  	TiXmlNodeA *pluginCmdNode = pluginCmdRoot->InsertEndChild(TiXmlElementA("PluginCommand"));
2773  	pluginCmdNode->ToElement()->SetAttribute("moduleName", pluginCmd.getModuleName());
2774  	pluginCmdNode->ToElement()->SetAttribute("internalID", pluginCmd.getInternalID());
2775  	pluginCmdNode->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2776  	pluginCmdNode->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2777  	pluginCmdNode->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2778  	pluginCmdNode->ToElement()->SetAttribute("Key", key._key);
2779  }
2780  void NppParameters::insertScintKey(TiXmlNodeA *scintKeyRoot, const ScintillaKeyMap & scintKeyMap)
2781  {
2782  	TiXmlNodeA *keyRoot = scintKeyRoot->InsertEndChild(TiXmlElementA("ScintKey"));
2783  	keyRoot->ToElement()->SetAttribute("ScintID", scintKeyMap.getScintillaKeyID());
2784  	keyRoot->ToElement()->SetAttribute("menuCmdID", scintKeyMap.getMenuCmdID());
2785  	KeyCombo key = scintKeyMap.getKeyComboByIndex(0);
2786  	keyRoot->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2787  	keyRoot->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2788  	keyRoot->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2789  	keyRoot->ToElement()->SetAttribute("Key", key._key);
2790  	size_t size = scintKeyMap.getSize();
2791  	if (size > 1)
2792  	{
2793  		for (size_t i = 1; i < size; ++i)
2794  		{
2795  			TiXmlNodeA *keyNext = keyRoot->InsertEndChild(TiXmlElementA("NextKey"));
2796  			key = scintKeyMap.getKeyComboByIndex(i);
2797  			keyNext->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
2798  			keyNext->ToElement()->SetAttribute("Alt", key._isAlt?"yes":"no");
2799  			keyNext->ToElement()->SetAttribute("Shift", key._isShift?"yes":"no");
2800  			keyNext->ToElement()->SetAttribute("Key", key._key);
2801  		}
2802  	}
2803  }
2804  void NppParameters::writeSession(const Session & session, const TCHAR *fileName)
2805  {
2806  	const TCHAR *sessionPathName = fileName ? fileName : _sessionPath.c_str();
2807  	TCHAR backupPathName[MAX_PATH]{};
2808  	if (PathFileExists(sessionPathName))
2809  	{
2810  		_tcscpy(backupPathName, sessionPathName);
2811  		_tcscat(backupPathName, TEXT(".inCaseOfCorruption.bak"));
2812  		CopyFile(sessionPathName, backupPathName, FALSE);
2813  	}
2814  	TiXmlDocument* pXmlSessionDoc = new TiXmlDocument(sessionPathName);
2815  	TiXmlDeclaration* decl = new TiXmlDeclaration(TEXT("1.0"), TEXT("UTF-8"), TEXT(""));
2816  	pXmlSessionDoc->LinkEndChild(decl);
2817  	TiXmlNode *root = pXmlSessionDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
2818  	if (root)
2819  	{
2820  		TiXmlNode *sessionNode = root->InsertEndChild(TiXmlElement(TEXT("Session")));
2821  		(sessionNode->ToElement())->SetAttribute(TEXT("activeView"), static_cast<int32_t>(session._activeView));
2822  		struct ViewElem {
2823  			TiXmlNode *viewNode;
2824  			vector<sessionFileInfo> *viewFiles;
2825  			size_t activeIndex;
2826  		};
2827  		const int nbElem = 2;
2828  		ViewElem viewElems[nbElem];
2829  		viewElems[0].viewNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("mainView")));
2830  		viewElems[1].viewNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("subView")));
2831  		viewElems[0].viewFiles = (vector<sessionFileInfo> *)(&(session._mainViewFiles));
2832  		viewElems[1].viewFiles = (vector<sessionFileInfo> *)(&(session._subViewFiles));
2833  		viewElems[0].activeIndex = session._activeMainIndex;
2834  		viewElems[1].activeIndex = session._activeSubIndex;
2835  		for (size_t k = 0; k < nbElem ; ++k)
2836  		{
2837  			(viewElems[k].viewNode->ToElement())->SetAttribute(TEXT("activeIndex"), static_cast<int32_t>(viewElems[k].activeIndex));
2838  			vector<sessionFileInfo> & viewSessionFiles = *(viewElems[k].viewFiles);
2839  			for (size_t i = 0, len = viewElems[k].viewFiles->size(); i < len ; ++i)
2840  			{
2841  				TiXmlNode *fileNameNode = viewElems[k].viewNode->InsertEndChild(TiXmlElement(TEXT("File")));
2842  				TCHAR szInt64[64];
2843  				(fileNameNode->ToElement())->SetAttribute(TEXT("firstVisibleLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._firstVisibleLine), szInt64, 10));
2844  				(fileNameNode->ToElement())->SetAttribute(TEXT("xOffset"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._xOffset), szInt64, 10));
2845  				(fileNameNode->ToElement())->SetAttribute(TEXT("scrollWidth"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._scrollWidth), szInt64, 10));
2846  				(fileNameNode->ToElement())->SetAttribute(TEXT("startPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._startPos), szInt64, 10));
2847  				(fileNameNode->ToElement())->SetAttribute(TEXT("endPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._endPos), szInt64, 10));
2848  				(fileNameNode->ToElement())->SetAttribute(TEXT("selMode"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._selMode), szInt64, 10));
2849  				(fileNameNode->ToElement())->SetAttribute(TEXT("offset"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._offset), szInt64, 10));
2850  				(fileNameNode->ToElement())->SetAttribute(TEXT("wrapCount"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._wrapCount), szInt64, 10));
2851  				(fileNameNode->ToElement())->SetAttribute(TEXT("lang"), viewSessionFiles[i]._langName.c_str());
2852  				(fileNameNode->ToElement())->SetAttribute(TEXT("encoding"), viewSessionFiles[i]._encoding);
2853  				(fileNameNode->ToElement())->SetAttribute(TEXT("userReadOnly"), (viewSessionFiles[i]._isUserReadOnly && !viewSessionFiles[i]._isMonitoring) ? TEXT("yes") : TEXT("no"));
2854  				(fileNameNode->ToElement())->SetAttribute(TEXT("filename"), viewSessionFiles[i]._fileName.c_str());
2855  				(fileNameNode->ToElement())->SetAttribute(TEXT("backupFilePath"), viewSessionFiles[i]._backupFilePath.c_str());
2856  				(fileNameNode->ToElement())->SetAttribute(TEXT("originalFileLastModifTimestamp"), static_cast<int32_t>(viewSessionFiles[i]._originalFileLastModifTimestamp.dwLowDateTime));
2857  				(fileNameNode->ToElement())->SetAttribute(TEXT("originalFileLastModifTimestampHigh"), static_cast<int32_t>(viewSessionFiles[i]._originalFileLastModifTimestamp.dwHighDateTime));
2858  				(fileNameNode->ToElement())->SetAttribute(TEXT("tabColourId"), static_cast<int32_t>(viewSessionFiles[i]._individualTabColour));
2859  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapFirstVisibleDisplayLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._firstVisibleDisplayLine), szInt64, 10));
2860  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapFirstVisibleDocLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._firstVisibleDocLine), szInt64, 10));
2861  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapLastVisibleDocLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._lastVisibleDocLine), szInt64, 10));
2862  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapNbLine"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._nbLine), szInt64, 10));
2863  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapHigherPos"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._higherPos), szInt64, 10));
2864  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapWidth"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._width), szInt64, 10));
2865  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapHeight"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._height), szInt64, 10));
2866  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapKByteInDoc"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._KByteInDoc), szInt64, 10));
2867  				(fileNameNode->ToElement())->SetAttribute(TEXT("mapWrapIndentMode"), _i64tot(static_cast<LONGLONG>(viewSessionFiles[i]._mapPos._wrapIndentMode), szInt64, 10));
2868  				fileNameNode->ToElement()->SetAttribute(TEXT("mapIsWrap"), viewSessionFiles[i]._mapPos._isWrap ? TEXT("yes") : TEXT("no"));
2869  				for (size_t j = 0, len = viewSessionFiles[i]._marks.size() ; j < len ; ++j)
2870  				{
2871  					size_t markLine = viewSessionFiles[i]._marks[j];
2872  					TiXmlNode *markNode = fileNameNode->InsertEndChild(TiXmlElement(TEXT("Mark")));
2873  					markNode->ToElement()->SetAttribute(TEXT("line"), _ui64tot(static_cast<ULONGLONG>(markLine), szInt64, 10));
2874  				}
2875  				for (size_t j = 0, len = viewSessionFiles[i]._foldStates.size() ; j < len ; ++j)
2876  				{
2877  					size_t foldLine = viewSessionFiles[i]._foldStates[j];
2878  					TiXmlNode *foldNode = fileNameNode->InsertEndChild(TiXmlElement(TEXT("Fold")));
2879  					foldNode->ToElement()->SetAttribute(TEXT("line"), _ui64tot(static_cast<ULONGLONG>(foldLine), szInt64, 10));
2880  				}
2881  			}
2882  		}
2883  		if (session._includeFileBrowser)
2884  		{
2885  			TiXmlNode* fileBrowserRootNode = sessionNode->InsertEndChild(TiXmlElement(TEXT("FileBrowser")));
2886  			fileBrowserRootNode->ToElement()->SetAttribute(TEXT("latestSelectedItem"), session._fileBrowserSelectedItem.c_str());
2887  			for (const auto& root : session._fileBrowserRoots)
2888  			{
2889  				TiXmlNode *fileNameNode = fileBrowserRootNode->InsertEndChild(TiXmlElement(TEXT("root")));
2890  				(fileNameNode->ToElement())->SetAttribute(TEXT("foldername"), root.c_str());
2891  			}
2892  		}
2893  	}
2894  	bool sessionSaveOK = pXmlSessionDoc->SaveFile();
2895  	if (sessionSaveOK)
2896  	{
2897  		TiXmlDocument* pXmlSessionCheck = new TiXmlDocument(sessionPathName);
2898  		sessionSaveOK = pXmlSessionCheck->LoadFile();
2899  		delete pXmlSessionCheck;
2900  	}
2901  	if (!sessionSaveOK)
2902  	{
2903  		if (backupPathName[0]) 
2904  		{
2905  			_pNativeLangSpeaker->messageBox("ErrorOfSavingSessionFile",
2906  				nullptr,
2907  				TEXT("The old session file will be restored."),
2908  				TEXT("Error of saving session file"),
2909  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2910  			wstring sessionPathNameFail2Load = sessionPathName;
2911  			sessionPathNameFail2Load += L".fail2Load";
2912  			MoveFileEx(sessionPathName, sessionPathNameFail2Load.c_str(), MOVEFILE_REPLACE_EXISTING);
2913  			CopyFile(backupPathName, sessionPathName, FALSE);
2914  		}
2915  	}
2916  	else
2917  	{
2918  		if (backupPathName[0]) 
2919  		{
2920  			::DeleteFile(backupPathName);
2921  		}
2922  	}
2923  	delete pXmlSessionDoc;
2924  }
2925  void NppParameters::writeShortcuts()
2926  {
2927  	if (!_isAnyShortcutModified) return;
2928  	if (!_pXmlShortcutDocA)
2929  	{
2930  		_pXmlShortcutDocA = new TiXmlDocumentA();
2931  		TiXmlDeclarationA* decl = new TiXmlDeclarationA("1.0", "UTF-8", "");
2932  		_pXmlShortcutDocA->LinkEndChild(decl);
2933  	}
2934  	else
2935  	{
2936  		wchar_t v852NoNeedShortcutsBackup[MAX_PATH]{};
2937  		::wcscpy_s(v852NoNeedShortcutsBackup, _shortcutsPath.c_str());
2938  		::PathRemoveFileSpec(v852NoNeedShortcutsBackup);
2939  		::PathAppend(v852NoNeedShortcutsBackup, NONEEDSHORTCUTSXMLBACKUP_FILENAME);
2940  		if (!::PathFileExists(v852NoNeedShortcutsBackup))
2941  		{
2942  			HANDLE hFile = ::CreateFile(v852NoNeedShortcutsBackup, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
2943  			::FlushFileBuffers(hFile);
2944  			::CloseHandle(hFile);
2945  			wstring v852ShortcutsBackupPath = _shortcutsPath;
2946  			v852ShortcutsBackupPath += L".v8.5.2.backup";
2947  			::CopyFile(_shortcutsPath.c_str(), v852ShortcutsBackupPath.c_str(), TRUE);
2948  			_pNativeLangSpeaker->messageBox("MacroAndRunCmdlWarning",
2949  				nullptr,
2950  				TEXT("Your Macro and Run commands saved in Notepad++ v.8.5.2 (or older) may not be compatible with the current version of Notepad++.\nPlease test those commands and, if needed, re-edit them.\n\nAlternatively, you can downgrade to Notepad++ v8.5.2 and restore your previous data.\nNotepad++ will backup your old \"shortcuts.xml\" and save it as \"shortcuts.xml.v8.5.2.backup\".\nRenaming \"shortcuts.xml.v8.5.2.backup\" -> \"shortcuts.xml\", your commands should be restored and work properly."),
2951  				TEXT("Macro and Run Commands Compatibility"),
2952  				MB_OK | MB_APPLMODAL | MB_ICONWARNING);
2953  		}
2954  	}
2955  	TiXmlNodeA *root = _pXmlShortcutDocA->FirstChild("NotepadPlus");
2956  	if (!root)
2957  	{
2958  		root = _pXmlShortcutDocA->InsertEndChild(TiXmlElementA("NotepadPlus"));
2959  	}
2960  	TiXmlNodeA *cmdRoot = root->FirstChild("InternalCommands");
2961  	if (cmdRoot)
2962  		root->RemoveChild(cmdRoot);
2963  	cmdRoot = root->InsertEndChild(TiXmlElementA("InternalCommands"));
2964  	for (size_t i = 0, len = _customizedShortcuts.size(); i < len ; ++i)
2965  	{
2966  		size_t index = _customizedShortcuts[i];
2967  		CommandShortcut csc = _shortcuts[index];
2968  		insertCmd(cmdRoot, csc);
2969  	}
2970  	TiXmlNodeA *macrosRoot = root->FirstChild("Macros");
2971  	if (macrosRoot)
2972  		root->RemoveChild(macrosRoot);
2973  	macrosRoot = root->InsertEndChild(TiXmlElementA("Macros"));
2974  	for (size_t i = 0, len = _macros.size(); i < len ; ++i)
2975  	{
2976  		insertMacro(macrosRoot, _macros[i], wstring2string(_macroMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2977  	}
2978  	TiXmlNodeA *userCmdRoot = root->FirstChild("UserDefinedCommands");
2979  	if (userCmdRoot)
2980  		root->RemoveChild(userCmdRoot);
2981  	userCmdRoot = root->InsertEndChild(TiXmlElementA("UserDefinedCommands"));
2982  	for (size_t i = 0, len = _userCommands.size(); i < len ; ++i)
2983  	{
2984  		insertUserCmd(userCmdRoot, _userCommands[i], wstring2string(_runMenuItems.getItemFromIndex(i)._parentFolderName, CP_UTF8));
2985  	}
2986  	TiXmlNodeA *pluginCmdRoot = root->FirstChild("PluginCommands");
2987  	if (pluginCmdRoot)
2988  		root->RemoveChild(pluginCmdRoot);
2989  	pluginCmdRoot = root->InsertEndChild(TiXmlElementA("PluginCommands"));
2990  	for (size_t i = 0, len = _pluginCustomizedCmds.size(); i < len ; ++i)
2991  	{
2992  		insertPluginCmd(pluginCmdRoot, _pluginCommands[_pluginCustomizedCmds[i]]);
2993  	}
2994  	TiXmlNodeA *scitillaKeyRoot = root->FirstChild("ScintillaKeys");
2995  	if (scitillaKeyRoot)
2996  		root->RemoveChild(scitillaKeyRoot);
2997  	scitillaKeyRoot = root->InsertEndChild(TiXmlElementA("ScintillaKeys"));
2998  	for (size_t i = 0, len = _scintillaModifiedKeyIndices.size(); i < len ; ++i)
2999  	{
3000  		insertScintKey(scitillaKeyRoot, _scintillaKeyCommands[_scintillaModifiedKeyIndices[i]]);
3001  	}
3002  	_pXmlShortcutDocA->SaveUnicodeFilePath(_shortcutsPath.c_str());
3003  }
3004  int NppParameters::addUserLangToEnd(const UserLangContainer & userLang, const TCHAR *newName)
3005  {
3006  	if (isExistingUserLangName(newName))
3007  		return -1;
3008  	unsigned char iBegin = _nbUserLang;
3009  	_userLangArray[_nbUserLang] = new UserLangContainer();
3010  	*(_userLangArray[_nbUserLang]) = userLang;
3011  	_userLangArray[_nbUserLang]->_name = newName;
3012  	++_nbUserLang;
3013  	unsigned char iEnd = _nbUserLang;
3014  	_pXmlUserLangsDoc.push_back(UdlXmlFileState(nullptr, true, true, make_pair(iBegin, iEnd)));
3015  	setUdlXmlDirtyFromXmlDoc(_pXmlUserLangDoc);
3016  	return _nbUserLang-1;
3017  }
3018  void NppParameters::removeUserLang(size_t index)
3019  {
3020  	if (static_cast<int32_t>(index) >= _nbUserLang)
3021  		return;
3022  	delete _userLangArray[index];
3023  	for (int32_t i = static_cast<int32_t>(index); i < (_nbUserLang - 1); ++i)
3024  		_userLangArray[i] = _userLangArray[i+1];
3025  	_nbUserLang--;
3026  	removeIndexFromXmlUdls(index);
3027  }
3028  void NppParameters::feedUserSettings(TiXmlNode *settingsRoot)
3029  {
3030  	const TCHAR *boolStr;
3031  	TiXmlNode *globalSettingNode = settingsRoot->FirstChildElement(TEXT("Global"));
3032  	if (globalSettingNode)
3033  	{
3034  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("caseIgnored"));
3035  		if (boolStr)
3036  			_userLangArray[_nbUserLang - 1]->_isCaseIgnored = (lstrcmp(TEXT("yes"), boolStr) == 0);
3037  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("allowFoldOfComments"));
3038  		if (boolStr)
3039  			_userLangArray[_nbUserLang - 1]->_allowFoldOfComments = (lstrcmp(TEXT("yes"), boolStr) == 0);
3040  		(globalSettingNode->ToElement())->Attribute(TEXT("forcePureLC"), &_userLangArray[_nbUserLang - 1]->_forcePureLC);
3041  		(globalSettingNode->ToElement())->Attribute(TEXT("decimalSeparator"), &_userLangArray[_nbUserLang - 1]->_decimalSeparator);
3042  		boolStr = (globalSettingNode->ToElement())->Attribute(TEXT("foldCompact"));
3043  		if (boolStr)
3044  			_userLangArray[_nbUserLang - 1]->_foldCompact = (lstrcmp(TEXT("yes"), boolStr) == 0);
3045  	}
3046  	TiXmlNode *prefixNode = settingsRoot->FirstChildElement(TEXT("Prefix"));
3047  	if (prefixNode)
3048  	{
3049  		const TCHAR *udlVersion = _userLangArray[_nbUserLang - 1]->_udlVersion.c_str();
3050  		if (!lstrcmp(udlVersion, TEXT("2.1")) || !lstrcmp(udlVersion, TEXT("2.0")))
3051  		{
3052  			for (int i = 0 ; i < SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
3053  			{
3054  				boolStr = (prefixNode->ToElement())->Attribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1]);
3055  				if (boolStr)
3056  					_userLangArray[_nbUserLang - 1]->_isPrefix[i] = (lstrcmp(TEXT("yes"), boolStr) == 0);
3057  			}
3058  		}
3059  		else	
3060  		{
3061  			TCHAR names[SCE_USER_TOTAL_KEYWORD_GROUPS][7] = {TEXT("words1"), TEXT("words2"), TEXT("words3"), TEXT("words4")};
3062  			for (int i = 0 ; i < 4 ; ++i)
3063  			{
3064  				boolStr = (prefixNode->ToElement())->Attribute(names[i]);
3065  				if (boolStr)
3066  					_userLangArray[_nbUserLang - 1]->_isPrefix[i] = (lstrcmp(TEXT("yes"), boolStr) == 0);
3067  			}
3068  		}
3069  	}
3070  }
3071  void NppParameters::feedUserKeywordList(TiXmlNode *node)
3072  {
3073  	const TCHAR * udlVersion = _userLangArray[_nbUserLang - 1]->_udlVersion.c_str();
3074  	int id = -1;
3075  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("Keywords"));
3076  		childNode ;
3077  		childNode = childNode->NextSibling(TEXT("Keywords")))
3078  	{
3079  		const TCHAR * keywordsName = (childNode->ToElement())->Attribute(TEXT("name"));
3080  		TiXmlNode *valueNode = childNode->FirstChild();
3081  		if (valueNode)
3082  		{
3083  			const TCHAR *kwl = nullptr;
3084  			if (!lstrcmp(udlVersion, TEXT("")) && !lstrcmp(keywordsName, TEXT("Delimiters")))	
3085  			{
3086  				basic_string<TCHAR> temp;
3087  				kwl = (valueNode)?valueNode->Value():TEXT("000000");
3088  				temp += TEXT("00");	 if (kwl[0] != '0') temp += kwl[0];	 temp += TEXT(" 01");
3089  				temp += TEXT(" 02");	if (kwl[3] != '0') temp += kwl[3];
3090  				temp += TEXT(" 03");	if (kwl[1] != '0') temp += kwl[1];	 temp += TEXT(" 04");
3091  				temp += TEXT(" 05");	if (kwl[4] != '0') temp += kwl[4];
3092  				temp += TEXT(" 06");	if (kwl[2] != '0') temp += kwl[2];	 temp += TEXT(" 07");
3093  				temp += TEXT(" 08");	if (kwl[5] != '0') temp += kwl[5];
3094  				temp += TEXT(" 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23");
3095  				wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[SCE_USER_KWLIST_DELIMITERS], temp.c_str());
3096  			}
3097  			else if (!lstrcmp(keywordsName, TEXT("Comment")))
3098  			{
3099  				kwl = (valueNode)?valueNode->Value():TEXT("");
3100  				basic_string<TCHAR> temp{TEXT(" ")};
3101  				temp += kwl;
3102  				size_t pos = 0;
3103  				pos = temp.find(TEXT(" 0"));
3104  				while (pos != string::npos)
3105  				{
3106  					temp.replace(pos, 2, TEXT(" 00"));
3107  					pos = temp.find(TEXT(" 0"), pos+1);
3108  				}
3109  				pos = temp.find(TEXT(" 1"));
3110  				while (pos != string::npos)
3111  				{
3112  					temp.replace(pos, 2, TEXT(" 03"));
3113  					pos = temp.find(TEXT(" 1"));
3114  				}
3115  				pos = temp.find(TEXT(" 2"));
3116  				while (pos != string::npos)
3117  				{
3118  					temp.replace(pos, 2, TEXT(" 04"));
3119  					pos = temp.find(TEXT(" 2"));
3120  				}
3121  				temp += TEXT(" 01 02");
3122  				if (temp[0] == ' ')
3123  					temp.erase(0, 1);
3124  				wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[SCE_USER_KWLIST_COMMENTS], temp.c_str());
3125  			}
3126  			else
3127  			{
3128  				kwl = (valueNode)?valueNode->Value():TEXT("");
3129  				if (globalMappper().keywordIdMapper.find(keywordsName) != globalMappper().keywordIdMapper.end())
3130  				{
3131  					id = globalMappper().keywordIdMapper[keywordsName];
3132  					if (wcslen(kwl) < max_char)
3133  					{
3134  						wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[id], kwl);
3135  					}
3136  					else
3137  					{
3138  						wcscpy_s(_userLangArray[_nbUserLang - 1]->_keywordLists[id], TEXT("imported string too long, needs to be < max_char(30720)"));
3139  					}
3140  				}
3141  			}
3142  		}
3143  	}
3144  }
3145  void NppParameters::feedUserStyles(TiXmlNode *node)
3146  {
3147  	int id = -1;
3148  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("WordsStyle"));
3149  		childNode ;
3150  		childNode = childNode->NextSibling(TEXT("WordsStyle")))
3151  	{
3152  		const TCHAR *styleName = (childNode->ToElement())->Attribute(TEXT("name"));
3153  		if (styleName)
3154  		{
3155  			if (globalMappper().styleIdMapper.find(styleName) != globalMappper().styleIdMapper.end())
3156  			{
3157  				id = globalMappper().styleIdMapper[styleName];
3158  				_userLangArray[_nbUserLang - 1]->_styles.addStyler((id | L_USER << 16), childNode);
3159  			}
3160  		}
3161  	}
3162  }
3163  bool NppParameters::feedStylerArray(TiXmlNode *node)
3164  {
3165  	TiXmlNode *styleRoot = node->FirstChildElement(TEXT("LexerStyles"));
3166  	if (!styleRoot) return false;
3167  	for (TiXmlNode *childNode = styleRoot->FirstChildElement(TEXT("LexerType"));
3168  		 childNode ;
3169  		 childNode = childNode->NextSibling(TEXT("LexerType")) )
3170  	{
3171  		TiXmlElement *element = childNode->ToElement();
3172  		const TCHAR *lexerName = element->Attribute(TEXT("name"));
3173  		const TCHAR *lexerDesc = element->Attribute(TEXT("desc"));
3174  		const TCHAR *lexerUserExt = element->Attribute(TEXT("ext"));
3175  		const TCHAR *lexerExcluded = element->Attribute(TEXT("excluded"));
3176  		if (lexerName)
3177  		{
3178  			_lexerStylerVect.addLexerStyler(lexerName, lexerDesc, lexerUserExt, childNode);
3179  			if (lexerExcluded != NULL && (lstrcmp(lexerExcluded, TEXT("yes")) == 0))
3180  			{
3181  				int index = getExternalLangIndexFromName(lexerName);
3182  				if (index != -1)
3183  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)(index + L_EXTERNAL)));
3184  			}
3185  		}
3186  	}
3187  	_lexerStylerVect.sort();
3188  	TiXmlNode *globalStyleRoot = node->FirstChildElement(TEXT("GlobalStyles"));
3189  	if (!globalStyleRoot) return false;
3190  	for (TiXmlNode *childNode = globalStyleRoot->FirstChildElement(TEXT("WidgetStyle"));
3191  		 childNode ;
3192  		 childNode = childNode->NextSibling(TEXT("WidgetStyle")) )
3193  	{
3194  		TiXmlElement *element = childNode->ToElement();
3195  		const TCHAR *styleIDStr = element->Attribute(TEXT("styleID"));
3196  		int styleID = -1;
3197  		if ((styleID = decStrVal(styleIDStr)) != -1)
3198  		{
3199  			_widgetStyleArray.addStyler(styleID, childNode);
3200  		}
3201  	}
3202  	constexpr auto rgbhex = [](COLORREF bbggrr) -> int {
3203  		return
3204  			((bbggrr & 0xFF0000) >> 16) |
3205  			((bbggrr & 0x00FF00)) |
3206  			((bbggrr & 0x0000FF) << 16);
3207  	};
3208  	const Style* pStyle = _widgetStyleArray.findByName(TEXT("EOL custom color"));
3209  	if (!pStyle)
3210  	{
3211  		TiXmlNode* eolColorkNode = globalStyleRoot->InsertEndChild(TiXmlElement(TEXT("WidgetStyle")));
3212  		eolColorkNode->ToElement()->SetAttribute(TEXT("name"), TEXT("EOL custom color"));
3213  		eolColorkNode->ToElement()->SetAttribute(TEXT("styleID"), TEXT("0"));
3214  		eolColorkNode->ToElement()->SetAttribute(TEXT("fgColor"), TEXT("DADADA"));
3215  		_widgetStyleArray.addStyler(0, eolColorkNode);
3216  	}
3217  	const Style* pStyleNpc = _widgetStyleArray.findByName(g_npcStyleName);
3218  	if (!pStyleNpc)
3219  	{
3220  		TiXmlNode* npcColorkNode = globalStyleRoot->InsertEndChild(TiXmlElement(TEXT("WidgetStyle")));
3221  		npcColorkNode->ToElement()->SetAttribute(TEXT("name"), g_npcStyleName);
3222  		npcColorkNode->ToElement()->SetAttribute(TEXT("styleID"), TEXT("0"));
3223  		const Style* pStyleWS = _widgetStyleArray.findByName(TEXT("White space symbol"));
3224  		if (pStyleWS)
3225  		{
3226  			constexpr size_t bufSize = 7;
3227  			wchar_t strColor[bufSize] = { '\0' };
3228  			swprintf(strColor, bufSize, L"%6X", rgbhex(pStyleWS->_fgColor));
3229  			npcColorkNode->ToElement()->SetAttribute(L"fgColor", strColor);
3230  		}
3231  		else
3232  		{
3233  			npcColorkNode->ToElement()->SetAttribute(L"fgColor", L"DADADA");
3234  		}
3235  		_widgetStyleArray.addStyler(0, npcColorkNode);
3236  	}
3237  	return true;
3238  }
3239  void LexerStylerArray::addLexerStyler(const TCHAR *lexerName, const TCHAR *lexerDesc, const TCHAR *lexerUserExt , TiXmlNode *lexerNode)
3240  {
3241  	_lexerStylerVect.emplace_back();
3242  	LexerStyler & ls = _lexerStylerVect.back();
3243  	ls.setLexerName(lexerName);
3244  	if (lexerDesc)
3245  		ls.setLexerDesc(lexerDesc);
3246  	if (lexerUserExt)
3247  		ls.setLexerUserExt(lexerUserExt);
3248  	for (TiXmlNode *childNode = lexerNode->FirstChildElement(TEXT("WordsStyle"));
3249  		 childNode ;
3250  		 childNode = childNode->NextSibling(TEXT("WordsStyle")) )
3251  	{
3252  		TiXmlElement *element = childNode->ToElement();
3253  		const TCHAR *styleIDStr = element->Attribute(TEXT("styleID"));
3254  		if (styleIDStr)
3255  		{
3256  			int styleID = -1;
3257  			if ((styleID = decStrVal(styleIDStr)) != -1)
3258  			{
3259  				ls.addStyler(styleID, childNode);
3260  			}
3261  		}
3262  	}
3263  }
3264  void StyleArray::addStyler(int styleID, TiXmlNode *styleNode)
3265  {
3266  	bool isUser = styleID >> 16 == L_USER;
3267  	if (isUser)
3268  	{
3269  		styleID = (styleID & 0xFFFF);
3270  		if (styleID >= SCE_USER_STYLE_TOTAL_STYLES || findByID(styleID))
3271  			return;
3272  	}
3273  	_styleVect.emplace_back();
3274  	Style & s = _styleVect.back();
3275  	s._styleID = styleID;
3276  	if (styleNode)
3277  	{
3278  		TiXmlElement *element = styleNode->ToElement();
3279  		const TCHAR *str = element->Attribute(TEXT("name"));
3280  		if (str)
3281  		{
3282  			if (isUser)
3283  				s._styleDesc = globalMappper().styleNameMapper[styleID];
3284  			else
3285  				s._styleDesc = str;
3286  		}
3287  		str = element->Attribute(TEXT("fgColor"));
3288  		if (str)
3289  		{
3290  			unsigned long result = hexStrVal(str);
3291  			s._fgColor = (RGB((result >> 16) & 0xFF, (result >> 8) & 0xFF, result & 0xFF)) | (result & 0xFF000000);
3292  		}
3293  		str = element->Attribute(TEXT("bgColor"));
3294  		if (str)
3295  		{
3296  			unsigned long result = hexStrVal(str);
3297  			s._bgColor = (RGB((result >> 16) & 0xFF, (result >> 8) & 0xFF, result & 0xFF)) | (result & 0xFF000000);
3298  		}
3299  		str = element->Attribute(TEXT("colorStyle"));
3300  		if (str)
3301  		{
3302  			s._colorStyle = decStrVal(str);
3303  		}
3304  		str = element->Attribute(TEXT("fontName"));
3305  		if (str)
3306  		{
3307  			s._fontName = str;
3308  			s._isFontEnabled = true;
3309  		}
3310  		str = element->Attribute(TEXT("fontStyle"));
3311  		if (str)
3312  		{
3313  			s._fontStyle = decStrVal(str);
3314  		}
3315  		str = element->Attribute(TEXT("fontSize"));
3316  		if (str)
3317  		{
3318  			s._fontSize = decStrVal(str);
3319  		}
3320  		str = element->Attribute(TEXT("nesting"));
3321  		if (str)
3322  		{
3323  			s._nesting = decStrVal(str);
3324  		}
3325  		str = element->Attribute(TEXT("keywordClass"));
3326  		if (str)
3327  		{
3328  			s._keywordClass = getKwClassFromName(str);
3329  		}
3330  		TiXmlNode *v = styleNode->FirstChild();
3331  		if (v)
3332  		{
3333  			s._keywords = v->Value();
3334  		}
3335  	}
3336  }
3337  bool NppParameters::writeRecentFileHistorySettings(int nbMaxFile) const
3338  {
3339  	if (!_pXmlUserDoc) return false;
3340  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3341  	if (!nppRoot)
3342  	{
3343  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3344  	}
3345  	TiXmlNode *historyNode = nppRoot->FirstChildElement(TEXT("History"));
3346  	if (!historyNode)
3347  	{
3348  		historyNode = nppRoot->InsertEndChild(TiXmlElement(TEXT("History")));
3349  	}
3350  	(historyNode->ToElement())->SetAttribute(TEXT("nbMaxFile"), nbMaxFile!=-1?nbMaxFile:_nbMaxRecentFile);
3351  	(historyNode->ToElement())->SetAttribute(TEXT("inSubMenu"), _putRecentFileInSubMenu?TEXT("yes"):TEXT("no"));
3352  	(historyNode->ToElement())->SetAttribute(TEXT("customLength"), _recentFileCustomLength);
3353  	return true;
3354  }
3355  bool NppParameters::writeColumnEditorSettings() const
3356  {
3357  	if (!_pXmlUserDoc) return false;
3358  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3359  	if (!nppRoot)
3360  	{
3361  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3362  	}
3363  	TiXmlNode *oldColumnEditorNode = nppRoot->FirstChildElement(TEXT("ColumnEditor"));
3364  	if (oldColumnEditorNode)
3365  	{
3366  		nppRoot->RemoveChild(oldColumnEditorNode);
3367  	}
3368  	TiXmlElement columnEditorRootNode{TEXT("ColumnEditor")};
3369  	(columnEditorRootNode.ToElement())->SetAttribute(TEXT("choice"), _columnEditParam._mainChoice == activeNumeric ? L"number" : L"text");
3370  	TiXmlElement textNode{ TEXT("text") };
3371  	(textNode.ToElement())->SetAttribute(TEXT("content"), _columnEditParam._insertedTextContent.c_str());
3372  	(columnEditorRootNode.ToElement())->InsertEndChild(textNode);
3373  	TiXmlElement numberNode{ TEXT("number") };
3374  	(numberNode.ToElement())->SetAttribute(TEXT("initial"), _columnEditParam._initialNum);
3375  	(numberNode.ToElement())->SetAttribute(TEXT("increase"), _columnEditParam._increaseNum);
3376  	(numberNode.ToElement())->SetAttribute(TEXT("repeat"), _columnEditParam._repeatNum);
3377  	wstring format = TEXT("dec");
3378  	if (_columnEditParam._formatChoice == 1)
3379  		format = TEXT("hex");
3380  	else if (_columnEditParam._formatChoice == 2)
3381  		format = TEXT("oct");
3382  	else if (_columnEditParam._formatChoice == 3)
3383  		format = TEXT("bin");
3384  	(numberNode.ToElement())->SetAttribute(TEXT("formatChoice"), format);
3385  	wstring leading = TEXT("none");
3386  	if (_columnEditParam._leadingChoice == ColumnEditorParam::zeroLeading)
3387  		leading = TEXT("zeros");
3388  	else if (_columnEditParam._leadingChoice == ColumnEditorParam::spaceLeading)
3389  		leading = TEXT("spaces");
3390  	(numberNode.ToElement())->SetAttribute(TEXT("leadingChoice"), leading);
3391  	(columnEditorRootNode.ToElement())->InsertEndChild(numberNode);
3392  	(nppRoot->ToElement())->InsertEndChild(columnEditorRootNode);
3393  	return true;
3394  }
3395  bool NppParameters::writeProjectPanelsSettings() const
3396  {
3397  	if (!_pXmlUserDoc) return false;
3398  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3399  	if (!nppRoot)
3400  	{
3401  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3402  	}
3403  	TiXmlNode *oldProjPanelRootNode = nppRoot->FirstChildElement(TEXT("ProjectPanels"));
3404  	if (oldProjPanelRootNode)
3405  	{
3406  		nppRoot->RemoveChild(oldProjPanelRootNode);
3407  	}
3408  	TiXmlElement projPanelRootNode{TEXT("ProjectPanels")};
3409  	for (int32_t i = 0 ; i < 3 ; ++i)
3410  	{
3411  		TiXmlElement projPanelNode{TEXT("ProjectPanel")};
3412  		(projPanelNode.ToElement())->SetAttribute(TEXT("id"), i);
3413  		(projPanelNode.ToElement())->SetAttribute(TEXT("workSpaceFile"), _workSpaceFilePathes[i]);
3414  		(projPanelRootNode.ToElement())->InsertEndChild(projPanelNode);
3415  	}
3416  	(nppRoot->ToElement())->InsertEndChild(projPanelRootNode);
3417  	return true;
3418  }
3419  bool NppParameters::writeFileBrowserSettings(const vector<generic_string> & rootPaths, const generic_string & latestSelectedItemPath) const
3420  {
3421  	if (!_pXmlUserDoc) return false;
3422  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3423  	if (!nppRoot)
3424  	{
3425  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3426  	}
3427  	TiXmlNode *oldFileBrowserRootNode = nppRoot->FirstChildElement(TEXT("FileBrowser"));
3428  	if (oldFileBrowserRootNode)
3429  	{
3430  		nppRoot->RemoveChild(oldFileBrowserRootNode);
3431  	}
3432  	TiXmlElement fileBrowserRootNode{ TEXT("FileBrowser") };
3433  	if (rootPaths.size() != 0)
3434  	{
3435  		fileBrowserRootNode.SetAttribute(TEXT("latestSelectedItem"), latestSelectedItemPath.c_str());
3436  		size_t len = rootPaths.size();
3437  		for (size_t i = 0; i < len; ++i)
3438  		{
3439  			TiXmlElement fbRootNode{ TEXT("root") };
3440  			(fbRootNode.ToElement())->SetAttribute(TEXT("foldername"), rootPaths[i].c_str());
3441  			(fileBrowserRootNode.ToElement())->InsertEndChild(fbRootNode);
3442  		}
3443  	}
3444  	(nppRoot->ToElement())->InsertEndChild(fileBrowserRootNode);
3445  	return true;
3446  }
3447  bool NppParameters::writeHistory(const TCHAR *fullpath)
3448  {
3449  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
3450  	if (!nppRoot)
3451  	{
3452  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
3453  	}
3454  	TiXmlNode *historyNode = nppRoot->FirstChildElement(TEXT("History"));
3455  	if (!historyNode)
3456  	{
3457  		historyNode = nppRoot->InsertEndChild(TiXmlElement(TEXT("History")));
3458  	}
3459  	TiXmlElement recentFileNode(TEXT("File"));
3460  	(recentFileNode.ToElement())->SetAttribute(TEXT("filename"), fullpath);
3461  	(historyNode->ToElement())->InsertEndChild(recentFileNode);
3462  	return true;
3463  }
3464  TiXmlNode * NppParameters::getChildElementByAttribut(TiXmlNode *pere, const TCHAR *childName,\
3465  			const TCHAR *attributName, const TCHAR *attributVal) const
3466  {
3467  	for (TiXmlNode *childNode = pere->FirstChildElement(childName);
3468  		childNode ;
3469  		childNode = childNode->NextSibling(childName))
3470  	{
3471  		TiXmlElement *element = childNode->ToElement();
3472  		const TCHAR *val = element->Attribute(attributName);
3473  		if (val)
3474  		{
3475  			if (!lstrcmp(val, attributVal))
3476  				return childNode;
3477  		}
3478  	}
3479  	return NULL;
3480  }
3481  LangType NppParameters::getLangIDFromStr(const TCHAR *langName)
3482  {
3483  	int lang = static_cast<int32_t>(L_TEXT);
3484  	for (; lang < L_EXTERNAL; ++lang)
3485  	{
3486  		const TCHAR * name = ScintillaEditView::_langNameInfoArray[lang]._langName;
3487  		if (!lstrcmp(name, langName)) 
3488  		{
3489  			return (LangType)lang;
3490  		}
3491  	}
3492  	LangType l = (LangType)lang;
3493  	if (l == L_EXTERNAL) 
3494  	{
3495  		int id = NppParameters::getInstance().getExternalLangIndexFromName(langName);
3496  		if (id != -1) return (LangType)(id + L_EXTERNAL);
3497  	}
3498  	return L_TEXT;
3499  }
3500  generic_string NppParameters::getLocPathFromStr(const generic_string & localizationCode)
3501  {
3502  	if (localizationCode == TEXT("en") || localizationCode == TEXT("en-au") || localizationCode == TEXT("en-bz") || localizationCode == TEXT("en-ca") || localizationCode == TEXT("en-cb") || localizationCode == TEXT("en-gb") || localizationCode == TEXT("en-ie") || localizationCode == TEXT("en-jm") || localizationCode == TEXT("en-nz") || localizationCode == TEXT("en-ph") || localizationCode == TEXT("en-tt") || localizationCode == TEXT("en-us") || localizationCode == TEXT("en-za") || localizationCode == TEXT("en-zw"))
3503  		return TEXT("english.xml");
3504  	if (localizationCode == TEXT("af"))
3505  		return TEXT("afrikaans.xml");
3506  	if (localizationCode == TEXT("sq"))
3507  		return TEXT("albanian.xml");
3508  	if (localizationCode == TEXT("ar") || localizationCode == TEXT("ar-dz") || localizationCode == TEXT("ar-bh") || localizationCode == TEXT("ar-eg") ||localizationCode == TEXT("ar-iq") || localizationCode == TEXT("ar-jo") || localizationCode == TEXT("ar-kw") || localizationCode == TEXT("ar-lb") || localizationCode == TEXT("ar-ly") || localizationCode == TEXT("ar-ma") || localizationCode == TEXT("ar-om") || localizationCode == TEXT("ar-qa") || localizationCode == TEXT("ar-sa") || localizationCode == TEXT("ar-sy") || localizationCode == TEXT("ar-tn") || localizationCode == TEXT("ar-ae") || localizationCode == TEXT("ar-ye"))
3509  		return TEXT("arabic.xml");
3510  	if (localizationCode == TEXT("an"))
3511  		return TEXT("aragonese.xml");
3512  	if (localizationCode == TEXT("az"))
3513  		return TEXT("azerbaijani.xml");
3514  	if (localizationCode == TEXT("eu"))
3515  		return TEXT("basque.xml");
3516  	if (localizationCode == TEXT("be"))
3517  		return TEXT("belarusian.xml");
3518  	if (localizationCode == TEXT("bn"))
3519  		return TEXT("bengali.xml");
3520  	if (localizationCode == TEXT("bs"))
3521  		return TEXT("bosnian.xml");
3522  	if (localizationCode == TEXT("pt-br"))
3523  		return TEXT("brazilian_portuguese.xml");
3524  	if (localizationCode == TEXT("br-fr"))
3525  		return TEXT("breton.xml");
3526  	if (localizationCode == TEXT("bg"))
3527  		return TEXT("bulgarian.xml");
3528  	if (localizationCode == TEXT("ca"))
3529  		return TEXT("catalan.xml");
3530  	if (localizationCode == TEXT("zh-tw") || localizationCode == TEXT("zh-hk") || localizationCode == TEXT("zh-sg"))
3531  		return TEXT("taiwaneseMandarin.xml");
3532  	if (localizationCode == TEXT("zh") || localizationCode == TEXT("zh-cn"))
3533  		return TEXT("chineseSimplified.xml");
3534  	if (localizationCode == TEXT("co") || localizationCode == TEXT("co-fr"))
3535  		return TEXT("corsican.xml");
3536  	if (localizationCode == TEXT("hr"))
3537  		return TEXT("croatian.xml");
3538  	if (localizationCode == TEXT("cs"))
3539  		return TEXT("czech.xml");
3540  	if (localizationCode == TEXT("da"))
3541  		return TEXT("danish.xml");
3542  	if (localizationCode == TEXT("nl") || localizationCode == TEXT("nl-be"))
3543  		return TEXT("dutch.xml");
3544  	if (localizationCode == TEXT("eo"))
3545  		return TEXT("esperanto.xml");
3546  	if (localizationCode == TEXT("et"))
3547  		return TEXT("estonian.xml");
3548  	if (localizationCode == TEXT("fa"))
3549  		return TEXT("farsi.xml");
3550  	if (localizationCode == TEXT("fi"))
3551  		return TEXT("finnish.xml");
3552  	if (localizationCode == TEXT("fr") || localizationCode == TEXT("fr-be") || localizationCode == TEXT("fr-ca") || localizationCode == TEXT("fr-fr") || localizationCode == TEXT("fr-lu") || localizationCode == TEXT("fr-mc") || localizationCode == TEXT("fr-ch"))
3553  		return TEXT("french.xml");
3554  	if (localizationCode == TEXT("fur"))
3555  		return TEXT("friulian.xml");
3556  	if (localizationCode == TEXT("gl"))
3557  		return TEXT("galician.xml");
3558  	if (localizationCode == TEXT("ka"))
3559  		return TEXT("georgian.xml");
3560  	if (localizationCode == TEXT("de") || localizationCode == TEXT("de-at") || localizationCode == TEXT("de-de") || localizationCode == TEXT("de-li") || localizationCode == TEXT("de-lu") || localizationCode == TEXT("de-ch"))
3561  		return TEXT("german.xml");
3562  	if (localizationCode == TEXT("el"))
3563  		return TEXT("greek.xml");
3564  	if (localizationCode == TEXT("gu"))
3565  		return TEXT("gujarati.xml");
3566  	if (localizationCode == TEXT("he"))
3567  		return TEXT("hebrew.xml");
3568  	if (localizationCode == TEXT("hi"))
3569  		return TEXT("hindi.xml");
3570  	if (localizationCode == TEXT("hu"))
3571  		return TEXT("hungarian.xml");
3572  	if (localizationCode == TEXT("id"))
3573  		return TEXT("indonesian.xml");
3574  	if (localizationCode == TEXT("it") || localizationCode == TEXT("it-ch"))
3575  		return TEXT("italian.xml");
3576  	if (localizationCode == TEXT("ja"))
3577  		return TEXT("japanese.xml");
3578  	if (localizationCode == TEXT("kn"))
3579  		return TEXT("kannada.xml");
3580  	if (localizationCode == TEXT("kk"))
3581  		return TEXT("kazakh.xml");
3582  	if (localizationCode == TEXT("ko") || localizationCode == TEXT("ko-kp") || localizationCode == TEXT("ko-kr"))
3583  		return TEXT("korean.xml");
3584  	if (localizationCode == TEXT("ku"))
3585  		return TEXT("kurdish.xml");
3586  	if (localizationCode == TEXT("ky"))
3587  		return TEXT("kyrgyz.xml");
3588  	if (localizationCode == TEXT("lv"))
3589  		return TEXT("latvian.xml");
3590  	if (localizationCode == TEXT("lt"))
3591  		return TEXT("lithuanian.xml");
3592  	if (localizationCode == TEXT("lb"))
3593  		return TEXT("luxembourgish.xml");
3594  	if (localizationCode == TEXT("mk"))
3595  		return TEXT("macedonian.xml");
3596  	if (localizationCode == TEXT("ms"))
3597  		return TEXT("malay.xml");
3598  	if (localizationCode == TEXT("mr"))
3599  		return TEXT("marathi.xml");
3600  	if (localizationCode == TEXT("mn"))
3601  		return TEXT("mongolian.xml");
3602  	if (localizationCode == TEXT("no") || localizationCode == TEXT("nb"))
3603  		return TEXT("norwegian.xml");
3604  	if (localizationCode == TEXT("nn"))
3605  		return TEXT("nynorsk.xml");
3606  	if (localizationCode == TEXT("oc"))
3607  		return TEXT("occitan.xml");
3608  	if (localizationCode == TEXT("pl"))
3609  		return TEXT("polish.xml");
3610  	if (localizationCode == TEXT("pt") || localizationCode == TEXT("pt-pt"))
3611  		return TEXT("portuguese.xml");
3612  	if (localizationCode == TEXT("pa") || localizationCode == TEXT("pa-in"))
3613  		return TEXT("punjabi.xml");
3614  	if (localizationCode == TEXT("ro") || localizationCode == TEXT("ro-mo"))
3615  		return TEXT("romanian.xml");
3616  	if (localizationCode == TEXT("ru") || localizationCode == TEXT("ru-mo"))
3617  		return TEXT("russian.xml");
3618  	if (localizationCode == TEXT("sc"))
3619  		return TEXT("sardinian.xml");
3620  	if (localizationCode == TEXT("sr"))
3621  		return TEXT("serbian.xml");
3622  	if (localizationCode == TEXT("sr-cyrl-ba") || localizationCode == TEXT("sr-cyrl-sp"))
3623  		return TEXT("serbianCyrillic.xml");
3624  	if (localizationCode == TEXT("si"))
3625  		return TEXT("sinhala.xml");
3626  	if (localizationCode == TEXT("sk"))
3627  		return TEXT("slovak.xml");
3628  	if (localizationCode == TEXT("sl"))
3629  		return TEXT("slovenian.xml");
3630  	if (localizationCode == TEXT("es") || localizationCode == TEXT("es-bo") || localizationCode == TEXT("es-cl") || localizationCode == TEXT("es-co") || localizationCode == TEXT("es-cr") || localizationCode == TEXT("es-do") || localizationCode == TEXT("es-ec") || localizationCode == TEXT("es-sv") || localizationCode == TEXT("es-gt") || localizationCode == TEXT("es-hn") || localizationCode == TEXT("es-mx") || localizationCode == TEXT("es-ni") || localizationCode == TEXT("es-pa") || localizationCode == TEXT("es-py") || localizationCode == TEXT("es-pe") || localizationCode == TEXT("es-pr") || localizationCode == TEXT("es-es") || localizationCode == TEXT("es-uy") || localizationCode == TEXT("es-ve"))
3631  		return TEXT("spanish.xml");
3632  	if (localizationCode == TEXT("es-ar"))
3633  		return TEXT("spanish_ar.xml");
3634  	if (localizationCode == TEXT("sv"))
3635  		return TEXT("swedish.xml");
3636  	if (localizationCode == TEXT("tl"))
3637  		return TEXT("tagalog.xml");
3638  	if (localizationCode == TEXT("tg-cyrl-tj"))
3639  		return TEXT("tajikCyrillic.xml");
3640  	if (localizationCode == TEXT("ta"))
3641  		return TEXT("tamil.xml");
3642  	if (localizationCode == TEXT("tt"))
3643  		return TEXT("tatar.xml");
3644  	if (localizationCode == TEXT("te"))
3645  		return TEXT("telugu.xml");
3646  	if (localizationCode == TEXT("th"))
3647  		return TEXT("thai.xml");
3648  	if (localizationCode == TEXT("tr"))
3649  		return TEXT("turkish.xml");
3650  	if (localizationCode == TEXT("uk"))
3651  		return TEXT("ukrainian.xml");
3652  	if (localizationCode == TEXT("ur") || localizationCode == TEXT("ur-pk"))
3653  		return TEXT("urdu.xml");
3654  	if (localizationCode == TEXT("ug-cn"))
3655  		return TEXT("uyghur.xml");
3656  	if (localizationCode == TEXT("uz"))
3657  		return TEXT("uzbek.xml");
3658  	if (localizationCode == TEXT("uz-cyrl-uz"))
3659  		return TEXT("uzbekCyrillic.xml");
3660  	if (localizationCode == TEXT("vec"))
3661  		return TEXT("venetian.xml");
3662  	if (localizationCode == TEXT("vi") || localizationCode == TEXT("vi-vn"))
3663  		return TEXT("vietnamese.xml");
3664  	if (localizationCode == TEXT("cy-gb"))
3665  		return TEXT("welsh.xml");
3666  	if (localizationCode == TEXT("zu") || localizationCode == TEXT("zu-za"))
3667  		return TEXT("zulu.xml");
3668  	if (localizationCode == TEXT("ne") || localizationCode == TEXT("nep"))
3669  		return TEXT("nepali.xml");
3670  	if (localizationCode == TEXT("oc-aranes"))
3671  		return TEXT("aranese.xml");
3672  	if (localizationCode == TEXT("exy"))
3673  		return TEXT("extremaduran.xml");
3674  	if (localizationCode == TEXT("keb"))
3675  		return TEXT("kabyle.xml");
3676  	if (localizationCode == TEXT("lij"))
3677  		return TEXT("ligurian.xml");
3678  	if (localizationCode == TEXT("ga"))
3679  		return TEXT("irish.xml");
3680  	if (localizationCode == TEXT("sgs"))
3681  		return TEXT("samogitian.xml");
3682  	if (localizationCode == TEXT("yue"))
3683  		return TEXT("hongKongCantonese.xml");
3684  	if (localizationCode == TEXT("ab") || localizationCode == TEXT("abk"))
3685  		return TEXT("abkhazian.xml");
3686  	return generic_string();
3687  }
3688  void NppParameters::feedKeyWordsParameters(TiXmlNode *node)
3689  {
3690  	TiXmlNode *langRoot = node->FirstChildElement(TEXT("Languages"));
3691  	if (!langRoot)
3692  		return;
3693  	for (TiXmlNode *langNode = langRoot->FirstChildElement(TEXT("Language"));
3694  		langNode ;
3695  		langNode = langNode->NextSibling(TEXT("Language")) )
3696  	{
3697  		if (_nbLang < NB_LANG)
3698  		{
3699  			TiXmlElement* element = langNode->ToElement();
3700  			const TCHAR* name = element->Attribute(TEXT("name"));
3701  			if (name)
3702  			{
3703  				_langList[_nbLang] = new Lang(getLangIDFromStr(name), name);
3704  				_langList[_nbLang]->setDefaultExtList(element->Attribute(TEXT("ext")));
3705  				_langList[_nbLang]->setCommentLineSymbol(element->Attribute(TEXT("commentLine")));
3706  				_langList[_nbLang]->setCommentStart(element->Attribute(TEXT("commentStart")));
3707  				_langList[_nbLang]->setCommentEnd(element->Attribute(TEXT("commentEnd")));
3708  				int tabSettings;
3709  				if (element->Attribute(TEXT("tabSettings"), &tabSettings))
3710  					_langList[_nbLang]->setTabInfo(tabSettings);
3711  				for (TiXmlNode *kwNode = langNode->FirstChildElement(TEXT("Keywords"));
3712  					kwNode ;
3713  					kwNode = kwNode->NextSibling(TEXT("Keywords")) )
3714  				{
3715  					const TCHAR *indexName = (kwNode->ToElement())->Attribute(TEXT("name"));
3716  					TiXmlNode *kwVal = kwNode->FirstChild();
3717  					const TCHAR *keyWords = TEXT("");
3718  					if ((indexName) && (kwVal))
3719  						keyWords = kwVal->Value();
3720  					int i = getKwClassFromName(indexName);
3721  					if (i >= 0 && i <= KEYWORDSET_MAX)
3722  						_langList[_nbLang]->setWords(keyWords, i);
3723  				}
3724  				++_nbLang;
3725  			}
3726  		}
3727  	}
3728  }
3729  extern "C" {
3730  typedef DWORD (WINAPI * EESFUNC) (LPCTSTR, LPTSTR, DWORD);
3731  }
3732  void NppParameters::feedGUIParameters(TiXmlNode *node)
3733  {
3734  	TiXmlNode *GUIRoot = node->FirstChildElement(TEXT("GUIConfigs"));
3735  	if (nullptr == GUIRoot)
3736  		return;
3737  	for (TiXmlNode *childNode = GUIRoot->FirstChildElement(TEXT("GUIConfig"));
3738  		childNode ;
3739  		childNode = childNode->NextSibling(TEXT("GUIConfig")) )
3740  	{
3741  		TiXmlElement* element = childNode->ToElement();
3742  		const TCHAR* nm = element->Attribute(TEXT("name"));
3743  		if (nullptr == nm)
3744  			continue;
3745  		auto parseYesNoBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
3746  			const TCHAR* val = element->Attribute(name);
3747  			if (val != nullptr)
3748  			{
3749  				if (!lstrcmp(val, TEXT("yes")))
3750  					return true;
3751  				else if (!lstrcmp(val, TEXT("no")))
3752  					return false;
3753  			}
3754  			return defaultValue;
3755  		};
3756  		if (!lstrcmp(nm, TEXT("ToolBar")))
3757  		{
3758  			const TCHAR* val = element->Attribute(TEXT("visible"));
3759  			if (val)
3760  			{
3761  				if (!lstrcmp(val, TEXT("no")))
3762  					_nppGUI._toolbarShow = false;
3763  				else
3764  					_nppGUI._toolbarShow = true;
3765  			}
3766  			TiXmlNode *n = childNode->FirstChild();
3767  			if (n)
3768  			{
3769  				val = n->Value();
3770  				if (val)
3771  				{
3772  					if (!lstrcmp(val, TEXT("small")))
3773  						_nppGUI._toolBarStatus = TB_SMALL;
3774  					else if (!lstrcmp(val, TEXT("large")))
3775  						_nppGUI._toolBarStatus = TB_LARGE;
3776  					else if (!lstrcmp(val, TEXT("small2")))
3777  						_nppGUI._toolBarStatus = TB_SMALL2;
3778  					else if (!lstrcmp(val, TEXT("large2")))
3779  						_nppGUI._toolBarStatus = TB_LARGE2;
3780  					else 
3781  						_nppGUI._toolBarStatus = TB_STANDARD;
3782  				}
3783  			}
3784  		}
3785  		else if (!lstrcmp(nm, TEXT("StatusBar")))
3786  		{
3787  			TiXmlNode *n = childNode->FirstChild();
3788  			if (n)
3789  			{
3790  				const TCHAR* val = n->Value();
3791  				if (val)
3792  				{
3793  					if (!lstrcmp(val, TEXT("hide")))
3794  						_nppGUI._statusBarShow = false;
3795  					else if (!lstrcmp(val, TEXT("show")))
3796  						_nppGUI._statusBarShow = true;
3797  				}
3798  			}
3799  		}
3800  		else if (!lstrcmp(nm, TEXT("MenuBar")))
3801  		{
3802  			TiXmlNode *n = childNode->FirstChild();
3803  			if (n)
3804  			{
3805  				const TCHAR* val = n->Value();
3806  				if (val)
3807  				{
3808  					if (!lstrcmp(val, TEXT("hide")))
3809  						_nppGUI._menuBarShow = false;
3810  					else if (!lstrcmp(val, TEXT("show")))
3811  						_nppGUI._menuBarShow = true;
3812  				}
3813  			}
3814  		}
3815  		else if (!lstrcmp(nm, TEXT("TabBar")))
3816  		{
3817  			bool isFailed = false;
3818  			int oldValue = _nppGUI._tabStatus;
3819  			const TCHAR* val = element->Attribute(TEXT("dragAndDrop"));
3820  			if (val)
3821  			{
3822  				if (!lstrcmp(val, TEXT("yes")))
3823  					_nppGUI._tabStatus = TAB_DRAGNDROP;
3824  				else if (!lstrcmp(val, TEXT("no")))
3825  					_nppGUI._tabStatus = 0;
3826  				else
3827  					isFailed = true;
3828  			}
3829  			val = element->Attribute(TEXT("drawTopBar"));
3830  			if (val)
3831  			{
3832  				if (!lstrcmp(val, TEXT("yes")))
3833  					_nppGUI._tabStatus |= TAB_DRAWTOPBAR;
3834  				else if (!lstrcmp(val, TEXT("no")))
3835  					_nppGUI._tabStatus |= 0;
3836  				else
3837  					isFailed = true;
3838  			}
3839  			val = element->Attribute(TEXT("drawInactiveTab"));
3840  			if (val)
3841  			{
3842  				if (!lstrcmp(val, TEXT("yes")))
3843  					_nppGUI._tabStatus |= TAB_DRAWINACTIVETAB;
3844  				else if (!lstrcmp(val, TEXT("no")))
3845  					_nppGUI._tabStatus |= 0;
3846  				else
3847  					isFailed = true;
3848  			}
3849  			val = element->Attribute(TEXT("reduce"));
3850  			if (val)
3851  			{
3852  				if (!lstrcmp(val, TEXT("yes")))
3853  					_nppGUI._tabStatus |= TAB_REDUCE;
3854  				else if (!lstrcmp(val, TEXT("no")))
3855  					_nppGUI._tabStatus |= 0;
3856  				else
3857  					isFailed = true;
3858  			}
3859  			val = element->Attribute(TEXT("closeButton"));
3860  			if (val)
3861  			{
3862  				if (!lstrcmp(val, TEXT("yes")))
3863  					_nppGUI._tabStatus |= TAB_CLOSEBUTTON;
3864  				else if (!lstrcmp(val, TEXT("no")))
3865  					_nppGUI._tabStatus |= 0;
3866  				else
3867  					isFailed = true;
3868  			}
3869  			val = element->Attribute(TEXT("doubleClick2Close"));
3870  			if (val)
3871  			{
3872  				if (!lstrcmp(val, TEXT("yes")))
3873  					_nppGUI._tabStatus |= TAB_DBCLK2CLOSE;
3874  				else if (!lstrcmp(val, TEXT("no")))
3875  					_nppGUI._tabStatus |= 0;
3876  				else
3877  					isFailed = true;
3878  			}
3879  			val = element->Attribute(TEXT("vertical"));
3880  			if (val)
3881  			{
3882  				if (!lstrcmp(val, TEXT("yes")))
3883  					_nppGUI._tabStatus |= TAB_VERTICAL;
3884  				else if (!lstrcmp(val, TEXT("no")))
3885  					_nppGUI._tabStatus |= 0;
3886  				else
3887  					isFailed = true;
3888  			}
3889  			val = element->Attribute(TEXT("multiLine"));
3890  			if (val)
3891  			{
3892  				if (!lstrcmp(val, TEXT("yes")))
3893  					_nppGUI._tabStatus |= TAB_MULTILINE;
3894  				else if (!lstrcmp(val, TEXT("no")))
3895  					_nppGUI._tabStatus |= 0;
3896  				else
3897  					isFailed = true;
3898  			}
3899  			val = element->Attribute(TEXT("hide"));
3900  			if (val)
3901  			{
3902  				if (!lstrcmp(val, TEXT("yes")))
3903  					_nppGUI._tabStatus |= TAB_HIDE;
3904  				else if (!lstrcmp(val, TEXT("no")))
3905  					_nppGUI._tabStatus |= 0;
3906  				else
3907  					isFailed = true;
3908  			}
3909  			val = element->Attribute(TEXT("quitOnEmpty"));
3910  			if (val)
3911  			{
3912  				if (!lstrcmp(val, TEXT("yes")))
3913  					_nppGUI._tabStatus |= TAB_QUITONEMPTY;
3914  				else if (!lstrcmp(val, TEXT("no")))
3915  					_nppGUI._tabStatus |= 0;
3916  				else
3917  					isFailed = true;
3918  			}
3919  			val = element->Attribute(TEXT("iconSetNumber"));
3920  			if (val)
3921  			{
3922  				if (!lstrcmp(val, TEXT("1")))
3923  					_nppGUI._tabStatus |= TAB_ALTICONS;
3924  				else if (!lstrcmp(val, TEXT("0")))
3925  					_nppGUI._tabStatus |= 0;
3926  				else
3927  					isFailed = true;
3928  			}
3929  			if (isFailed)
3930  				_nppGUI._tabStatus = oldValue;
3931  		}
3932  		else if (!lstrcmp(nm, TEXT("Auto-detection")))
3933  		{
3934  			TiXmlNode *n = childNode->FirstChild();
3935  			if (n)
3936  			{
3937  				const TCHAR* val = n->Value();
3938  				if (val)
3939  				{
3940  					if (!lstrcmp(val, TEXT("yesOld")))
3941  						_nppGUI._fileAutoDetection = cdEnabledOld;
3942  					else if (!lstrcmp(val, TEXT("autoOld")))
3943  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate);
3944  					else if (!lstrcmp(val, TEXT("Update2EndOld")))
3945  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdGo2end);
3946  					else if (!lstrcmp(val, TEXT("autoUpdate2EndOld")))
3947  						_nppGUI._fileAutoDetection = (cdEnabledOld | cdAutoUpdate | cdGo2end);
3948  					else if (!lstrcmp(val, TEXT("yes")))
3949  						_nppGUI._fileAutoDetection = cdEnabledNew;
3950  					else if (!lstrcmp(val, TEXT("auto")))
3951  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate);
3952  					else if (!lstrcmp(val, TEXT("Update2End")))
3953  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdGo2end);
3954  					else if (!lstrcmp(val, TEXT("autoUpdate2End")))
3955  						_nppGUI._fileAutoDetection = (cdEnabledNew | cdAutoUpdate | cdGo2end);
3956  					else 
3957  						_nppGUI._fileAutoDetection = cdDisabled;
3958  				}
3959  			}
3960  		}
3961  		else if (!lstrcmp(nm, TEXT("TrayIcon")))
3962  		{
3963  			TiXmlNode *n = childNode->FirstChild();
3964  			if (n)
3965  			{
3966  				const TCHAR* val = n->Value();
3967  				if (val)
3968  				{
3969  					_nppGUI._isMinimizedToTray = (lstrcmp(val, TEXT("yes")) == 0);
3970  				}
3971  			}
3972  		}
3973  		else if (!lstrcmp(nm, TEXT("RememberLastSession")))
3974  		{
3975  			TiXmlNode *n = childNode->FirstChild();
3976  			if (n)
3977  			{
3978  				const TCHAR* val = n->Value();
3979  				if (val)
3980  				{
3981  					if (lstrcmp(val, TEXT("yes")) == 0)
3982  						_nppGUI._rememberLastSession = true;
3983  					else
3984  						_nppGUI._rememberLastSession = false;
3985  				}
3986  			}
3987  		}
3988  		else if (!lstrcmp(nm, TEXT("DetectEncoding")))
3989  		{
3990  			TiXmlNode *n = childNode->FirstChild();
3991  			if (n)
3992  			{
3993  				const TCHAR* val = n->Value();
3994  				if (val)
3995  				{
3996  					if (lstrcmp(val, TEXT("yes")) == 0)
3997  						_nppGUI._detectEncoding = true;
3998  					else
3999  						_nppGUI._detectEncoding = false;
4000  				}
4001  			}
4002  		}
4003  		else if (!lstrcmp(nm, TEXT("SaveAllConfirm")))
4004  		{
4005  			TiXmlNode *n = childNode->FirstChild();
4006  			if (n)
4007  			{
4008  				const TCHAR* val = n->Value();
4009  				if (val)
4010  				{
4011  					if (lstrcmp(val, TEXT("yes")) == 0)
4012  						_nppGUI._saveAllConfirm = true;
4013  					else
4014  						_nppGUI._saveAllConfirm = false;
4015  				}
4016  			}
4017  		}
4018  		else if (lstrcmp(nm, TEXT("MaitainIndent")) == 0)
4019  		{
4020  			TiXmlNode *n = childNode->FirstChild();
4021  			if (n)
4022  			{
4023  				const TCHAR* val = n->Value();
4024  				if (val)
4025  				{
4026  					if (lstrcmp(val, TEXT("yes")) == 0)
4027  						_nppGUI._maitainIndent = true;
4028  					else
4029  						_nppGUI._maitainIndent = false;
4030  				}
4031  			}
4032  		}
4033  		else if (!lstrcmp(nm, TEXT("MarkAll")))
4034  		{
4035  			const TCHAR* val = element->Attribute(TEXT("matchCase"));
4036  			if (val)
4037  			{
4038  				if (lstrcmp(val, TEXT("yes")) == 0)
4039  					_nppGUI._markAllCaseSensitive = true;
4040  				else if (!lstrcmp(val, TEXT("no")))
4041  					_nppGUI._markAllCaseSensitive = false;
4042  			}
4043  			val = element->Attribute(TEXT("wholeWordOnly"));
4044  			if (val)
4045  			{
4046  				if (lstrcmp(val, TEXT("yes")) == 0)
4047  					_nppGUI._markAllWordOnly = true;
4048  				else if (!lstrcmp(val, TEXT("no")))
4049  					_nppGUI._markAllWordOnly = false;
4050  			}
4051  		}
4052  		else if (!lstrcmp(nm, TEXT("SmartHighLight")))
4053  		{
4054  			TiXmlNode *n = childNode->FirstChild();
4055  			if (n)
4056  			{
4057  				const TCHAR* val = n->Value();
4058  				if (val)
4059  				{
4060  					if (lstrcmp(val, TEXT("yes")) == 0)
4061  						_nppGUI._enableSmartHilite = true;
4062  					else
4063  						_nppGUI._enableSmartHilite = false;
4064  				}
4065  				val = element->Attribute(TEXT("matchCase"));
4066  				if (val)
4067  				{
4068  					if (lstrcmp(val, TEXT("yes")) == 0)
4069  						_nppGUI._smartHiliteCaseSensitive = true;
4070  					else if (!lstrcmp(val, TEXT("no")))
4071  						_nppGUI._smartHiliteCaseSensitive = false;
4072  				}
4073  				val = element->Attribute(TEXT("wholeWordOnly"));
4074  				if (val)
4075  				{
4076  					if (lstrcmp(val, TEXT("yes")) == 0)
4077  						_nppGUI._smartHiliteWordOnly = true;
4078  					else if (!lstrcmp(val, TEXT("no")))
4079  						_nppGUI._smartHiliteWordOnly = false;
4080  				}
4081  				val = element->Attribute(TEXT("useFindSettings"));
4082  				if (val)
4083  				{
4084  					if (lstrcmp(val, TEXT("yes")) == 0)
4085  						_nppGUI._smartHiliteUseFindSettings = true;
4086  					else if (!lstrcmp(val, TEXT("no")))
4087  						_nppGUI._smartHiliteUseFindSettings = false;
4088  				}
4089  				val = element->Attribute(TEXT("onAnotherView"));
4090  				if (val)
4091  				{
4092  					if (lstrcmp(val, TEXT("yes")) == 0)
4093  						_nppGUI._smartHiliteOnAnotherView = true;
4094  					else if (!lstrcmp(val, TEXT("no")))
4095  						_nppGUI._smartHiliteOnAnotherView = false;
4096  				}
4097  			}
4098  		}
4099  		else if (!lstrcmp(nm, TEXT("TagsMatchHighLight")))
4100  		{
4101  			TiXmlNode *n = childNode->FirstChild();
4102  			if (n)
4103  			{
4104  				const TCHAR* val = n->Value();
4105  				if (val)
4106  				{
4107  					_nppGUI._enableTagsMatchHilite = !lstrcmp(val, TEXT("yes"));
4108  					const TCHAR *tahl = element->Attribute(TEXT("TagAttrHighLight"));
4109  					if (tahl)
4110  						_nppGUI._enableTagAttrsHilite = !lstrcmp(tahl, TEXT("yes"));
4111  					tahl = element->Attribute(TEXT("HighLightNonHtmlZone"));
4112  					if (tahl)
4113  						_nppGUI._enableHiliteNonHTMLZone = !lstrcmp(tahl, TEXT("yes"));
4114  				}
4115  			}
4116  		}
4117  		else if (!lstrcmp(nm, TEXT("TaskList")))
4118  		{
4119  			TiXmlNode *n = childNode->FirstChild();
4120  			if (n)
4121  			{
4122  				const TCHAR* val = n->Value();
4123  				if (val)
4124  				{
4125  					_nppGUI._doTaskList = (!lstrcmp(val, TEXT("yes")))?true:false;
4126  				}
4127  			}
4128  		}
4129  		else if (!lstrcmp(nm, TEXT("MRU")))
4130  		{
4131  			TiXmlNode *n = childNode->FirstChild();
4132  			if (n)
4133  			{
4134  				const TCHAR* val = n->Value();
4135  				if (val)
4136  					_nppGUI._styleMRU = (!lstrcmp(val, TEXT("yes")));
4137  			}
4138  		}
4139  		else if (!lstrcmp(nm, TEXT("URL")))
4140  		{
4141  			TiXmlNode *n = childNode->FirstChild();
4142  			if (n)
4143  			{
4144  				const TCHAR* val = n->Value();
4145  				if (val)
4146  				{
4147  					int const i = _wtoi (val);
4148  					if ((i >= urlMin) && (i <= urlMax))
4149  						_nppGUI._styleURL = urlMode(i);
4150  				}
4151  			}
4152  		}
4153  		else if (!lstrcmp(nm, TEXT("uriCustomizedSchemes")))
4154  		{
4155  			TiXmlNode *n = childNode->FirstChild();
4156  			if (n)
4157  			{
4158  				const TCHAR* val = n->Value();
4159  				if (val)
4160  				_nppGUI._uriSchemes = val;
4161  			}
4162  		}
4163  		else if (!lstrcmp(nm, TEXT("CheckHistoryFiles")))
4164  		{
4165  			TiXmlNode *n = childNode->FirstChild();
4166  			if (n)
4167  			{
4168  				const TCHAR* val = n->Value();
4169  				if (val)
4170  				{
4171  					if (!lstrcmp(val, TEXT("no")))
4172  						_nppGUI._checkHistoryFiles = false;
4173  					else if (!lstrcmp(val, TEXT("yes")))
4174  						_nppGUI._checkHistoryFiles = true;
4175  				}
4176  			}
4177  		}
4178  		else if (!lstrcmp(nm, TEXT("ScintillaViewsSplitter")))
4179  		{
4180  			TiXmlNode *n = childNode->FirstChild();
4181  			if (n)
4182  			{
4183  				const TCHAR* val = n->Value();
4184  				if (val)
4185  				{
4186  					if (!lstrcmp(val, TEXT("vertical")))
4187  						_nppGUI._splitterPos = POS_VERTICAL;
4188  					else if (!lstrcmp(val, TEXT("horizontal")))
4189  						_nppGUI._splitterPos = POS_HORIZOTAL;
4190  				}
4191  			}
4192  		}
4193  		else if (!lstrcmp(nm, TEXT("UserDefineDlg")))
4194  		{
4195  			bool isFailed = false;
4196  			int oldValue = _nppGUI._userDefineDlgStatus;
4197  			TiXmlNode *n = childNode->FirstChild();
4198  			if (n)
4199  			{
4200  				const TCHAR* val = n->Value();
4201  				if (val)
4202  				{
4203  					if (!lstrcmp(val, TEXT("hide")))
4204  						_nppGUI._userDefineDlgStatus = 0;
4205  					else if (!lstrcmp(val, TEXT("show")))
4206  						_nppGUI._userDefineDlgStatus = UDD_SHOW;
4207  					else
4208  						isFailed = true;
4209  				}
4210  			}
4211  			const TCHAR* val = element->Attribute(TEXT("position"));
4212  			if (val)
4213  			{
4214  				if (!lstrcmp(val, TEXT("docked")))
4215  					_nppGUI._userDefineDlgStatus |= UDD_DOCKED;
4216  				else if (!lstrcmp(val, TEXT("undocked")))
4217  					_nppGUI._userDefineDlgStatus |= 0;
4218  				else
4219  					isFailed = true;
4220  			}
4221  			if (isFailed)
4222  				_nppGUI._userDefineDlgStatus = oldValue;
4223  		}
4224  		else if (!lstrcmp(nm, TEXT("TabSetting")))
4225  		{
4226  			int i;
4227  			const TCHAR* val = element->Attribute(TEXT("size"), &i);
4228  			if (val)
4229  				_nppGUI._tabSize = i;
4230  			if ((_nppGUI._tabSize == -1) || (_nppGUI._tabSize == 0))
4231  				_nppGUI._tabSize = 4;
4232  			val = element->Attribute(TEXT("replaceBySpace"));
4233  			if (val)
4234  				_nppGUI._tabReplacedBySpace = (!lstrcmp(val, TEXT("yes")));
4235  		}
4236  		else if (!lstrcmp(nm, TEXT("Caret")))
4237  		{
4238  			int i;
4239  			const TCHAR* val = element->Attribute(TEXT("width"), &i);
4240  			if (val)
4241  				_nppGUI._caretWidth = i;
4242  			val = element->Attribute(TEXT("blinkRate"), &i);
4243  			if (val)
4244  				_nppGUI._caretBlinkRate = i;
4245  		}
4246  		else if (!lstrcmp(nm, TEXT("ScintillaGlobalSettings")))
4247  		{
4248  			const TCHAR* val = element->Attribute(TEXT("enableMultiSelection"));
4249  			if (val)
4250  			{
4251  				if (lstrcmp(val, TEXT("yes")) == 0)
4252  					_nppGUI._enableMultiSelection = true;
4253  				else if (lstrcmp(val, TEXT("no")) == 0)
4254  					_nppGUI._enableMultiSelection = false;
4255  			}
4256  		}
4257  		else if (!lstrcmp(nm, TEXT("AppPosition")))
4258  		{
4259  			RECT oldRect = _nppGUI._appPos;
4260  			bool fuckUp = true;
4261  			int i;
4262  			if (element->Attribute(TEXT("x"), &i))
4263  			{
4264  				_nppGUI._appPos.left = i;
4265  				if (element->Attribute(TEXT("y"), &i))
4266  				{
4267  					_nppGUI._appPos.top = i;
4268  					if (element->Attribute(TEXT("width"), &i))
4269  					{
4270  						_nppGUI._appPos.right = i;
4271  						if (element->Attribute(TEXT("height"), &i))
4272  						{
4273  							_nppGUI._appPos.bottom = i;
4274  							fuckUp = false;
4275  						}
4276  					}
4277  				}
4278  			}
4279  			if (fuckUp)
4280  				_nppGUI._appPos = oldRect;
4281  			const TCHAR* val = element->Attribute(TEXT("isMaximized"));
4282  			if (val)
4283  				_nppGUI._isMaximized = (lstrcmp(val, TEXT("yes")) == 0);
4284  		}
4285  		else if (!lstrcmp(nm, TEXT("FindWindowPosition")))
4286  		{
4287  			RECT oldRect = _nppGUI._findWindowPos;
4288  			bool incomplete = true;
4289  			int i;
4290  			if (element->Attribute(TEXT("left"), &i))
4291  			{
4292  				_nppGUI._findWindowPos.left = i;
4293  				if (element->Attribute(TEXT("top"), &i))
4294  				{
4295  					_nppGUI._findWindowPos.top = i;
4296  					if (element->Attribute(TEXT("right"), &i))
4297  					{
4298  						_nppGUI._findWindowPos.right = i;
4299  						if (element->Attribute(TEXT("bottom"), &i))
4300  						{
4301  							_nppGUI._findWindowPos.bottom = i;
4302  							incomplete = false;
4303  						}
4304  					}
4305  				}
4306  			}
4307  			if (incomplete)
4308  			{
4309  				_nppGUI._findWindowPos = oldRect;
4310  			}
4311  			const TCHAR* val = element->Attribute(TEXT("isLessModeOn"));
4312  			if (val)
4313  				_nppGUI._findWindowLessMode = (lstrcmp(val, TEXT("yes")) == 0);
4314  		}
4315  		else if (!lstrcmp(nm, TEXT("FinderConfig")))
4316  		{
4317  			const TCHAR* val = element->Attribute(TEXT("wrappedLines"));
4318  			if (val)
4319  			{
4320  				_nppGUI._finderLinesAreCurrentlyWrapped = (!lstrcmp(val, TEXT("yes")));
4321  			}
4322  			val = element->Attribute(TEXT("purgeBeforeEverySearch"));
4323  			if (val)
4324  			{
4325  				_nppGUI._finderPurgeBeforeEverySearch = (!lstrcmp(val, TEXT("yes")));
4326  			}
4327  			val = element->Attribute(TEXT("showOnlyOneEntryPerFoundLine"));
4328  			if (val)
4329  			{
4330  				_nppGUI._finderShowOnlyOneEntryPerFoundLine = (!lstrcmp(val, TEXT("yes")));
4331  			}
4332  		}
4333  		else if (!lstrcmp(nm, TEXT("NewDocDefaultSettings")))
4334  		{
4335  			int i;
4336  			if (element->Attribute(TEXT("format"), &i))
4337  			{
4338  				EolType newFormat = EolType::osdefault;
4339  				switch (i)
4340  				{
4341  					case static_cast<LPARAM>(EolType::windows) :
4342  						newFormat = EolType::windows;
4343  						break;
4344  					case static_cast<LPARAM>(EolType::macos) :
4345  						newFormat = EolType::macos;
4346  						break;
4347  					case static_cast<LPARAM>(EolType::unix) :
4348  						newFormat = EolType::unix;
4349  						break;
4350  					default:
4351  						assert(false and "invalid buffer format - fallback to default");
4352  				}
4353  				_nppGUI._newDocDefaultSettings._format = newFormat;
4354  			}
4355  			if (element->Attribute(TEXT("encoding"), &i))
4356  				_nppGUI._newDocDefaultSettings._unicodeMode = (UniMode)i;
4357  			if (element->Attribute(TEXT("lang"), &i))
4358  				_nppGUI._newDocDefaultSettings._lang = (LangType)i;
4359  			if (element->Attribute(TEXT("codepage"), &i))
4360  				_nppGUI._newDocDefaultSettings._codepage = (LangType)i;
4361  			const TCHAR* val = element->Attribute(TEXT("openAnsiAsUTF8"));
4362  			if (val)
4363  				_nppGUI._newDocDefaultSettings._openAnsiAsUtf8 = (lstrcmp(val, TEXT("yes")) == 0);
4364  			val = element->Attribute(TEXT("addNewDocumentOnStartup"));
4365  			if (val)
4366  				_nppGUI._newDocDefaultSettings._addNewDocumentOnStartup = (lstrcmp(val, TEXT("yes")) == 0);
4367  		}
4368  		else if (!lstrcmp(nm, TEXT("langsExcluded")))
4369  		{
4370  			int g0 = 0; 
4371  			int g1 = 0; 
4372  			int g2 = 0; 
4373  			int g3 = 0; 
4374  			int g4 = 0; 
4375  			int g5 = 0; 
4376  			int g6 = 0; 
4377  			int g7 = 0; 
4378  			int g8 = 0; 
4379  			int g9 = 0; 
4380  			int g10= 0; 
4381  			int g11= 0; 
4382  			int g12= 0; 
4383  			{
4384  				int i;
4385  				if (element->Attribute(TEXT("gr0"), &i))
4386  				{
4387  					if (i <= 255)
4388  						g0 = i;
4389  				}
4390  				if (element->Attribute(TEXT("gr1"), &i))
4391  				{
4392  					if (i <= 255)
4393  						g1 = i;
4394  				}
4395  				if (element->Attribute(TEXT("gr2"), &i))
4396  				{
4397  					if (i <= 255)
4398  						g2 = i;
4399  				}
4400  				if (element->Attribute(TEXT("gr3"), &i))
4401  				{
4402  					if (i <= 255)
4403  						g3 = i;
4404  				}
4405  				if (element->Attribute(TEXT("gr4"), &i))
4406  				{
4407  					if (i <= 255)
4408  						g4 = i;
4409  				}
4410  				if (element->Attribute(TEXT("gr5"), &i))
4411  				{
4412  					if (i <= 255)
4413  						g5 = i;
4414  				}
4415  				if (element->Attribute(TEXT("gr6"), &i))
4416  				{
4417  					if (i <= 255)
4418  						g6 = i;
4419  				}
4420  				if (element->Attribute(TEXT("gr7"), &i))
4421  				{
4422  					if (i <= 255)
4423  						g7 = i;
4424  				}
4425  				if (element->Attribute(TEXT("gr8"), &i))
4426  				{
4427  					if (i <= 255)
4428  						g8 = i;
4429  				}
4430  				if (element->Attribute(TEXT("gr9"), &i))
4431  				{
4432  					if (i <= 255)
4433  						g9 = i;
4434  				}
4435  				if (element->Attribute(TEXT("gr10"), &i))
4436  				{
4437  					if (i <= 255)
4438  						g10 = i;
4439  				}
4440  				if (element->Attribute(TEXT("gr11"), &i))
4441  				{
4442  					if (i <= 255)
4443  						g11 = i;
4444  				}
4445  				if (element->Attribute(TEXT("gr12"), &i))
4446  				{
4447  					if (i <= 255)
4448  						g12 = i;
4449  				}
4450  			}
4451  			UCHAR mask = 1;
4452  			for (int i = 0 ; i < 8 ; ++i)
4453  			{
4454  				if (mask & g0)
4455  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4456  				mask <<= 1;
4457  			}
4458  			mask = 1;
4459  			for (int i = 8 ; i < 16 ; ++i)
4460  			{
4461  				if (mask & g1)
4462  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4463  				mask <<= 1;
4464  			}
4465  			mask = 1;
4466  			for (int i = 16 ; i < 24 ; ++i)
4467  			{
4468  				if (mask & g2)
4469  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4470  				mask <<= 1;
4471  			}
4472  			mask = 1;
4473  			for (int i = 24 ; i < 32 ; ++i)
4474  			{
4475  				if (mask & g3)
4476  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4477  				mask <<= 1;
4478  			}
4479  			mask = 1;
4480  			for (int i = 32 ; i < 40 ; ++i)
4481  			{
4482  				if (mask & g4)
4483  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4484  				mask <<= 1;
4485  			}
4486  			mask = 1;
4487  			for (int i = 40 ; i < 48 ; ++i)
4488  			{
4489  				if (mask & g5)
4490  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4491  				mask <<= 1;
4492  			}
4493  			mask = 1;
4494  			for (int i = 48 ; i < 56 ; ++i)
4495  			{
4496  				if (mask & g6)
4497  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4498  				mask <<= 1;
4499  			}
4500  			mask = 1;
4501  			for (int i = 56 ; i < 64 ; ++i)
4502  			{
4503  				if (mask & g7)
4504  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4505  				mask <<= 1;
4506  			}
4507  			mask = 1;
4508  			for (int i = 64; i < 72; ++i)
4509  			{
4510  				if (mask & g8)
4511  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4512  				mask <<= 1;
4513  			}
4514  			mask = 1;
4515  			for (int i = 72; i < 80; ++i)
4516  			{
4517  				if (mask & g9)
4518  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4519  				mask <<= 1;
4520  			}
4521  			mask = 1;
4522  			for (int i = 80; i < 88; ++i)
4523  			{
4524  				if (mask & g10)
4525  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4526  				mask <<= 1;
4527  			}
4528  			mask = 1;
4529  			for (int i = 88; i < 96; ++i)
4530  			{
4531  				if (mask & g11)
4532  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4533  				mask <<= 1;
4534  			}
4535  			mask = 1;
4536  			for (int i = 96; i < 104; ++i)
4537  			{
4538  				if (mask & g12)
4539  					_nppGUI._excludedLangList.push_back(LangMenuItem((LangType)i));
4540  				mask <<= 1;
4541  			}
4542  			const TCHAR* val = element->Attribute(TEXT("langMenuCompact"));
4543  			if (val)
4544  				_nppGUI._isLangMenuCompact = (!lstrcmp(val, TEXT("yes")));
4545  		}
4546  		else if (!lstrcmp(nm, TEXT("Print")))
4547  		{
4548  			const TCHAR* val = element->Attribute(TEXT("lineNumber"));
4549  			if (val)
4550  				_nppGUI._printSettings._printLineNumber = (!lstrcmp(val, TEXT("yes")));
4551  			int i;
4552  			if (element->Attribute(TEXT("printOption"), &i))
4553  				_nppGUI._printSettings._printOption = i;
4554  			val = element->Attribute(TEXT("headerLeft"));
4555  			if (val)
4556  				_nppGUI._printSettings._headerLeft = val;
4557  			val = element->Attribute(TEXT("headerMiddle"));
4558  			if (val)
4559  				_nppGUI._printSettings._headerMiddle = val;
4560  			val = element->Attribute(TEXT("headerRight"));
4561  			if (val)
4562  				_nppGUI._printSettings._headerRight = val;
4563  			val = element->Attribute(TEXT("footerLeft"));
4564  			if (val)
4565  				_nppGUI._printSettings._footerLeft = val;
4566  			val = element->Attribute(TEXT("footerMiddle"));
4567  			if (val)
4568  				_nppGUI._printSettings._footerMiddle = val;
4569  			val = element->Attribute(TEXT("footerRight"));
4570  			if (val)
4571  				_nppGUI._printSettings._footerRight = val;
4572  			val = element->Attribute(TEXT("headerFontName"));
4573  			if (val)
4574  				_nppGUI._printSettings._headerFontName = val;
4575  			val = element->Attribute(TEXT("footerFontName"));
4576  			if (val)
4577  				_nppGUI._printSettings._footerFontName = val;
4578  			if (element->Attribute(TEXT("headerFontStyle"), &i))
4579  				_nppGUI._printSettings._headerFontStyle = i;
4580  			if (element->Attribute(TEXT("footerFontStyle"), &i))
4581  				_nppGUI._printSettings._footerFontStyle = i;
4582  			if (element->Attribute(TEXT("headerFontSize"), &i))
4583  				_nppGUI._printSettings._headerFontSize = i;
4584  			if (element->Attribute(TEXT("footerFontSize"), &i))
4585  				_nppGUI._printSettings._footerFontSize = i;
4586  			if (element->Attribute(TEXT("margeLeft"), &i))
4587  				_nppGUI._printSettings._marge.left = i;
4588  			if (element->Attribute(TEXT("margeTop"), &i))
4589  				_nppGUI._printSettings._marge.top = i;
4590  			if (element->Attribute(TEXT("margeRight"), &i))
4591  				_nppGUI._printSettings._marge.right = i;
4592  			if (element->Attribute(TEXT("margeBottom"), &i))
4593  				_nppGUI._printSettings._marge.bottom = i;
4594  		}
4595  		else if (!lstrcmp(nm, TEXT("ScintillaPrimaryView")))
4596  		{
4597  			feedScintillaParam(element);
4598  		}
4599  		else if (!lstrcmp(nm, TEXT("Backup")))
4600  		{
4601  			int i;
4602  			if (element->Attribute(TEXT("action"), &i))
4603  				_nppGUI._backup = (BackupFeature)i;
4604  			const TCHAR *bDir = element->Attribute(TEXT("useCustumDir"));
4605  			if (bDir)
4606  			{
4607  				_nppGUI._useDir = (lstrcmp(bDir, TEXT("yes")) == 0);
4608  			}
4609  			const TCHAR *pDir = element->Attribute(TEXT("dir"));
4610  			if (pDir)
4611  				_nppGUI._backupDir = pDir;
4612  			const TCHAR *isSnapshotModeStr = element->Attribute(TEXT("isSnapshotMode"));
4613  			if (isSnapshotModeStr && !lstrcmp(isSnapshotModeStr, TEXT("no")))
4614  				_nppGUI._isSnapshotMode = false;
4615  			int timing;
4616  			if (element->Attribute(TEXT("snapshotBackupTiming"), &timing))
4617  				_nppGUI._snapshotBackupTiming = timing;
4618  		}
4619  		else if (!lstrcmp(nm, TEXT("DockingManager")))
4620  		{
4621  			feedDockingManager(element);
4622  		}
4623  		else if (!lstrcmp(nm, TEXT("globalOverride")))
4624  		{
4625  			const TCHAR *bDir = element->Attribute(TEXT("fg"));
4626  			if (bDir)
4627  				_nppGUI._globalOverride.enableFg = (lstrcmp(bDir, TEXT("yes")) == 0);
4628  			bDir = element->Attribute(TEXT("bg"));
4629  			if (bDir)
4630  				_nppGUI._globalOverride.enableBg = (lstrcmp(bDir, TEXT("yes")) == 0);
4631  			bDir = element->Attribute(TEXT("font"));
4632  			if (bDir)
4633  				_nppGUI._globalOverride.enableFont = (lstrcmp(bDir, TEXT("yes")) == 0);
4634  			bDir = element->Attribute(TEXT("fontSize"));
4635  			if (bDir)
4636  				_nppGUI._globalOverride.enableFontSize = (lstrcmp(bDir, TEXT("yes")) == 0);
4637  			bDir = element->Attribute(TEXT("bold"));
4638  			if (bDir)
4639  				_nppGUI._globalOverride.enableBold = (lstrcmp(bDir, TEXT("yes")) == 0);
4640  			bDir = element->Attribute(TEXT("italic"));
4641  			if (bDir)
4642  				_nppGUI._globalOverride.enableItalic = (lstrcmp(bDir, TEXT("yes")) == 0);
4643  			bDir = element->Attribute(TEXT("underline"));
4644  			if (bDir)
4645  				_nppGUI._globalOverride.enableUnderLine = (lstrcmp(bDir, TEXT("yes")) == 0);
4646  		}
4647  		else if (!lstrcmp(nm, TEXT("auto-completion")))
4648  		{
4649  			int i;
4650  			if (element->Attribute(TEXT("autoCAction"), &i))
4651  				_nppGUI._autocStatus = static_cast<NppGUI::AutocStatus>(i);
4652  			if (element->Attribute(TEXT("triggerFromNbChar"), &i))
4653  				_nppGUI._autocFromLen = i;
4654  			const TCHAR * optName = element->Attribute(TEXT("autoCIgnoreNumbers"));
4655  			if (optName)
4656  				_nppGUI._autocIgnoreNumbers = (lstrcmp(optName, TEXT("yes")) == 0);
4657  			optName = element->Attribute(TEXT("insertSelectedItemUseENTER"));
4658  			if (optName)
4659  				_nppGUI._autocInsertSelectedUseENTER = (lstrcmp(optName, TEXT("yes")) == 0);
4660  			optName = element->Attribute(TEXT("insertSelectedItemUseTAB"));
4661  			if (optName)
4662  				_nppGUI._autocInsertSelectedUseTAB = (lstrcmp(optName, TEXT("yes")) == 0);
4663  			optName = element->Attribute(TEXT("autoCBrief"));
4664  			if (optName)
4665  				_nppGUI._autocBrief = (lstrcmp(optName, TEXT("yes")) == 0);
4666  			optName = element->Attribute(TEXT("funcParams"));
4667  			if (optName)
4668  				_nppGUI._funcParams = (lstrcmp(optName, TEXT("yes")) == 0);
4669  		}
4670  		else if (!lstrcmp(nm, TEXT("auto-insert")))
4671  		{
4672  			const TCHAR * optName = element->Attribute(TEXT("htmlXmlTag"));
4673  			if (optName)
4674  				_nppGUI._matchedPairConf._doHtmlXmlTag = (lstrcmp(optName, TEXT("yes")) == 0);
4675  			optName = element->Attribute(TEXT("parentheses"));
4676  			if (optName)
4677  				_nppGUI._matchedPairConf._doParentheses = (lstrcmp(optName, TEXT("yes")) == 0);
4678  			optName = element->Attribute(TEXT("brackets"));
4679  			if (optName)
4680  				_nppGUI._matchedPairConf._doBrackets = (lstrcmp(optName, TEXT("yes")) == 0);
4681  			optName = element->Attribute(TEXT("curlyBrackets"));
4682  			if (optName)
4683  				_nppGUI._matchedPairConf._doCurlyBrackets = (lstrcmp(optName, TEXT("yes")) == 0);
4684  			optName = element->Attribute(TEXT("quotes"));
4685  			if (optName)
4686  				_nppGUI._matchedPairConf._doQuotes = (lstrcmp(optName, TEXT("yes")) == 0);
4687  			optName = element->Attribute(TEXT("doubleQuotes"));
4688  			if (optName)
4689  				_nppGUI._matchedPairConf._doDoubleQuotes = (lstrcmp(optName, TEXT("yes")) == 0);
4690  			for (TiXmlNode *subChildNode = childNode->FirstChildElement(TEXT("UserDefinePair"));
4691  				 subChildNode;
4692  				 subChildNode = subChildNode->NextSibling(TEXT("UserDefinePair")) )
4693  			{
4694  				int open = -1;
4695  				int openVal = 0;
4696  				const TCHAR *openValStr = (subChildNode->ToElement())->Attribute(TEXT("open"), &openVal);
4697  				if (openValStr && (openVal >= 0 && openVal < 128))
4698  					open = openVal;
4699  				int close = -1;
4700  				int closeVal = 0;
4701  				const TCHAR *closeValStr = (subChildNode->ToElement())->Attribute(TEXT("close"), &closeVal);
4702  				if (closeValStr && (closeVal >= 0 && closeVal <= 128))
4703  					close = closeVal;
4704  				if (open != -1 && close != -1)
4705  					_nppGUI._matchedPairConf._matchedPairsInit.push_back(pair<char, char>(char(open), char(close)));
4706  			}
4707  		}
4708  		else if (!lstrcmp(nm, TEXT("sessionExt")))
4709  		{
4710  			TiXmlNode *n = childNode->FirstChild();
4711  			if (n)
4712  			{
4713  				const TCHAR* val = n->Value();
4714  				if (val)
4715  					_nppGUI._definedSessionExt = val;
4716  			}
4717  		}
4718  		else if (!lstrcmp(nm, TEXT("workspaceExt")))
4719  		{
4720  			TiXmlNode *n = childNode->FirstChild();
4721  			if (n)
4722  			{
4723  				const TCHAR* val = n->Value();
4724  				if (val)
4725  					_nppGUI._definedWorkspaceExt = val;
4726  			}
4727  		}
4728  		else if (!lstrcmp(nm, TEXT("noUpdate")))
4729  		{
4730  			TiXmlNode *n = childNode->FirstChild();
4731  			if (n)
4732  			{
4733  				const TCHAR* val = n->Value();
4734  				if (val)
4735  					_nppGUI._autoUpdateOpt._doAutoUpdate = (!lstrcmp(val, TEXT("yes")))?false:true;
4736  				int i;
4737  				val = element->Attribute(TEXT("intervalDays"), &i);
4738  				if (val)
4739  					_nppGUI._autoUpdateOpt._intervalDays = i;
4740  				val = element->Attribute(TEXT("nextUpdateDate"));
4741  				if (val)
4742  					_nppGUI._autoUpdateOpt._nextUpdateDate = Date(val);
4743  			}
4744  		}
4745  		else if (!lstrcmp(nm, TEXT("openSaveDir")))
4746  		{
4747  			const TCHAR * value = element->Attribute(TEXT("value"));
4748  			if (value && value[0])
4749  			{
4750  				if (lstrcmp(value, TEXT("1")) == 0)
4751  					_nppGUI._openSaveDir = dir_last;
4752  				else if (lstrcmp(value, TEXT("2")) == 0)
4753  					_nppGUI._openSaveDir = dir_userDef;
4754  				else
4755  					_nppGUI._openSaveDir = dir_followCurrent;
4756  			}
4757  			const TCHAR * path = element->Attribute(TEXT("defaultDirPath"));
4758  			if (path && path[0])
4759  			{
4760  				lstrcpyn(_nppGUI._defaultDir, path, MAX_PATH);
4761  				::ExpandEnvironmentStrings(_nppGUI._defaultDir, _nppGUI._defaultDirExp, MAX_PATH);
4762  			}
4763   		}
4764  		else if (!lstrcmp(nm, TEXT("titleBar")))
4765  		{
4766  			const TCHAR * value = element->Attribute(TEXT("short"));
4767  			_nppGUI._shortTitlebar = false;	
4768  			if (value && value[0])
4769  			{
4770  				if (lstrcmp(value, TEXT("yes")) == 0)
4771  					_nppGUI._shortTitlebar = true;
4772  				else if (lstrcmp(value, TEXT("no")) == 0)
4773  					_nppGUI._shortTitlebar = false;
4774  			}
4775  		}
4776  		else if (!lstrcmp(nm, TEXT("insertDateTime")))
4777  		{
4778  			const TCHAR* customFormat = element->Attribute(TEXT("customizedFormat"));
4779  			if (customFormat != NULL && customFormat[0])
4780  				_nppGUI._dateTimeFormat = customFormat;
4781  			const TCHAR* value = element->Attribute(TEXT("reverseDefaultOrder"));
4782  			if (value && value[0])
4783  			{
4784  				if (lstrcmp(value, TEXT("yes")) == 0)
4785  					_nppGUI._dateTimeReverseDefaultOrder = true;
4786  				else if (lstrcmp(value, TEXT("no")) == 0)
4787  					_nppGUI._dateTimeReverseDefaultOrder = false;
4788  			}
4789  		}
4790  		else if (!lstrcmp(nm, TEXT("wordCharList")))
4791  		{
4792  			const TCHAR * value = element->Attribute(TEXT("useDefault"));
4793  			if (value && value[0])
4794  			{
4795  				if (lstrcmp(value, TEXT("yes")) == 0)
4796  					_nppGUI._isWordCharDefault = true;
4797  				else if (lstrcmp(value, TEXT("no")) == 0)
4798  					_nppGUI._isWordCharDefault = false;
4799  			}
4800  			const TCHAR *charsAddedW = element->Attribute(TEXT("charsAdded"));
4801  			if (charsAddedW)
4802  			{
4803  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
4804  				_nppGUI._customWordChars = wmc.wchar2char(charsAddedW, SC_CP_UTF8);
4805  			}
4806  		}
4807  		else if (!lstrcmp(nm, TEXT("delimiterSelection")))
4808  		{
4809  			int leftmost = 0;
4810  			element->Attribute(TEXT("leftmostDelimiter"), &leftmost);
4811  			if (leftmost > 0 && leftmost < 256)
4812  				_nppGUI._leftmostDelimiter = static_cast<char>(leftmost);
4813  			int rightmost = 0;
4814  			element->Attribute(TEXT("rightmostDelimiter"), &rightmost);
4815  			if (rightmost > 0 && rightmost < 256)
4816  				_nppGUI._rightmostDelimiter = static_cast<char>(rightmost);
4817  			const TCHAR *delimiterSelectionOnEntireDocument = element->Attribute(TEXT("delimiterSelectionOnEntireDocument"));
4818  			if (delimiterSelectionOnEntireDocument != NULL && !lstrcmp(delimiterSelectionOnEntireDocument, TEXT("yes")))
4819  				_nppGUI._delimiterSelectionOnEntireDocument = true;
4820  			else
4821  				_nppGUI._delimiterSelectionOnEntireDocument = false;
4822  		}
4823  		else if (!lstrcmp(nm, TEXT("largeFileRestriction")))
4824  		{
4825  			int fileSizeLimit4StylingMB = 0;
4826  			element->Attribute(TEXT("fileSizeMB"), &fileSizeLimit4StylingMB);
4827  			if (fileSizeLimit4StylingMB > 0 && fileSizeLimit4StylingMB <= 4096)
4828  				_nppGUI._largeFileRestriction._largeFileSizeDefInByte = (static_cast<int64_t>(fileSizeLimit4StylingMB) * 1024 * 1024);
4829  			const TCHAR* boolVal = element->Attribute(TEXT("isEnabled"));
4830  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("no")))
4831  				_nppGUI._largeFileRestriction._isEnabled = false;
4832  			else
4833  				_nppGUI._largeFileRestriction._isEnabled = true;
4834  			boolVal = element->Attribute(TEXT("allowAutoCompletion"));
4835  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4836  				_nppGUI._largeFileRestriction._allowAutoCompletion = true;
4837  			else
4838  				_nppGUI._largeFileRestriction._allowAutoCompletion = false;
4839  			boolVal = element->Attribute(TEXT("allowBraceMatch"));
4840  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4841  				_nppGUI._largeFileRestriction._allowBraceMatch = true;
4842  			else
4843  				_nppGUI._largeFileRestriction._allowBraceMatch = false;
4844  			boolVal = element->Attribute(TEXT("allowSmartHilite"));
4845  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4846  				_nppGUI._largeFileRestriction._allowSmartHilite = true;
4847  			else
4848  				_nppGUI._largeFileRestriction._allowSmartHilite = false;
4849  			boolVal = element->Attribute(TEXT("allowClickableLink"));
4850  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("yes")))
4851  				_nppGUI._largeFileRestriction._allowClickableLink = true;
4852  			else
4853  				_nppGUI._largeFileRestriction._allowClickableLink = false;
4854  			boolVal = element->Attribute(TEXT("deactivateWordWrap"));
4855  			if (boolVal != NULL && !lstrcmp(boolVal, TEXT("no")))
4856  				_nppGUI._largeFileRestriction._deactivateWordWrap = false;
4857  			else
4858  				_nppGUI._largeFileRestriction._deactivateWordWrap = true;
4859  		}
4860  		else if (!lstrcmp(nm, TEXT("multiInst")))
4861  		{
4862  			int val = 0;
4863  			element->Attribute(TEXT("setting"), &val);
4864  			if (val < 0 || val > 2)
4865  				val = 0;
4866  			_nppGUI._multiInstSetting = (MultiInstSetting)val;
4867  			_nppGUI._clipboardHistoryPanelKeepState = parseYesNoBoolAttribute(TEXT("clipboardHistory"));
4868  			_nppGUI._docListKeepState = parseYesNoBoolAttribute(TEXT("documentList"));
4869  			_nppGUI._charPanelKeepState = parseYesNoBoolAttribute(TEXT("characterPanel"));
4870  			_nppGUI._fileBrowserKeepState = parseYesNoBoolAttribute(TEXT("folderAsWorkspace"));
4871  			_nppGUI._projectPanelKeepState = parseYesNoBoolAttribute(TEXT("projectPanels"));
4872  			_nppGUI._docMapKeepState = parseYesNoBoolAttribute(TEXT("documentMap"));
4873  			_nppGUI._funcListKeepState = parseYesNoBoolAttribute(TEXT("fuctionList"));
4874  			_nppGUI._pluginPanelKeepState = parseYesNoBoolAttribute(TEXT("pluginPanels"));
4875  		}
4876  		else if (!lstrcmp(nm, TEXT("searchEngine")))
4877  		{
4878  			int i;
4879  			if (element->Attribute(TEXT("searchEngineChoice"), &i))
4880  				_nppGUI._searchEngineChoice = static_cast<NppGUI::SearchEngineChoice>(i);
4881  			const TCHAR * searchEngineCustom = element->Attribute(TEXT("searchEngineCustom"));
4882  			if (searchEngineCustom && searchEngineCustom[0])
4883  				_nppGUI._searchEngineCustom = searchEngineCustom;
4884  		}
4885  		else if (!lstrcmp(nm, TEXT("Searching")))
4886  		{
4887  			const TCHAR* optNameMonoFont = element->Attribute(TEXT("monospacedFontFindDlg"));
4888  			if (optNameMonoFont)
4889  				_nppGUI._monospacedFontFindDlg = (lstrcmp(optNameMonoFont, TEXT("yes")) == 0);
4890  			const TCHAR* optStopFillingFindField = element->Attribute(TEXT("stopFillingFindField"));
4891  			if (optStopFillingFindField) 
4892  			{
4893  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optStopFillingFindField, TEXT("no")) == 0);
4894  				_nppGUI._fillFindFieldSelectCaret = _nppGUI._fillFindFieldWithSelected;
4895  			}
4896  			const TCHAR* optFillFindFieldWithSelected = element->Attribute(TEXT("fillFindFieldWithSelected"));
4897  			if (optFillFindFieldWithSelected)
4898  				_nppGUI._fillFindFieldWithSelected = (lstrcmp(optFillFindFieldWithSelected, TEXT("yes")) == 0);
4899  			const TCHAR* optFillFindFieldSelectCaret = element->Attribute(TEXT("fillFindFieldSelectCaret"));
4900  			if (optFillFindFieldSelectCaret)
4901  				_nppGUI._fillFindFieldSelectCaret = (lstrcmp(optFillFindFieldSelectCaret, TEXT("yes")) == 0);
4902  			const TCHAR* optFindDlgAlwaysVisible = element->Attribute(TEXT("findDlgAlwaysVisible"));
4903  			if (optFindDlgAlwaysVisible)
4904  				_nppGUI._findDlgAlwaysVisible = (lstrcmp(optFindDlgAlwaysVisible, TEXT("yes")) == 0);
4905  			const TCHAR* optConfirmReplaceOpenDocs = element->Attribute(TEXT("confirmReplaceInAllOpenDocs"));
4906  			if (optConfirmReplaceOpenDocs)
4907  				_nppGUI._confirmReplaceInAllOpenDocs = (lstrcmp(optConfirmReplaceOpenDocs, TEXT("yes")) == 0);
4908  			const TCHAR* optReplaceStopsWithoutFindingNext = element->Attribute(TEXT("replaceStopsWithoutFindingNext"));
4909  			if (optReplaceStopsWithoutFindingNext)
4910  				_nppGUI._replaceStopsWithoutFindingNext = (lstrcmp(optReplaceStopsWithoutFindingNext, TEXT("yes")) == 0);
4911  		}
4912  		else if (!lstrcmp(nm, TEXT("MISC")))
4913  		{
4914  			const TCHAR * optName = element->Attribute(TEXT("fileSwitcherWithoutExtColumn"));
4915  			if (optName)
4916  				_nppGUI._fileSwitcherWithoutExtColumn = (lstrcmp(optName, TEXT("yes")) == 0);
4917  			int i = 0;
4918  			if (element->Attribute(TEXT("fileSwitcherExtWidth"), &i))
4919  				_nppGUI._fileSwitcherExtWidth = i;
4920  			const TCHAR * optNamePath = element->Attribute(TEXT("fileSwitcherWithoutPathColumn"));
4921  			if (optNamePath)
4922  				_nppGUI._fileSwitcherWithoutPathColumn = (lstrcmp(optNamePath, TEXT("yes")) == 0);
4923  			if (element->Attribute(TEXT("fileSwitcherPathWidth"), &i))
4924  				_nppGUI._fileSwitcherPathWidth = i;
4925  			_nppGUI._fileSwitcherDisableListViewGroups = parseYesNoBoolAttribute(TEXT("fileSwitcherNoGroups"));
4926  			const TCHAR * optNameBackSlashEscape = element->Attribute(TEXT("backSlashIsEscapeCharacterForSql"));
4927  			if (optNameBackSlashEscape && !lstrcmp(optNameBackSlashEscape, TEXT("no")))
4928  				_nppGUI._backSlashIsEscapeCharacterForSql = false;
4929  			const TCHAR * optNameWriteTechnologyEngine = element->Attribute(TEXT("writeTechnologyEngine"));
4930  			if (optNameWriteTechnologyEngine)
4931  				_nppGUI._writeTechnologyEngine = (lstrcmp(optNameWriteTechnologyEngine, TEXT("1")) == 0) ? directWriteTechnology : defaultTechnology;
4932  			const TCHAR * optNameFolderDroppedOpenFiles = element->Attribute(TEXT("isFolderDroppedOpenFiles"));
4933  			if (optNameFolderDroppedOpenFiles)
4934  				_nppGUI._isFolderDroppedOpenFiles = (lstrcmp(optNameFolderDroppedOpenFiles, TEXT("yes")) == 0);
4935  			const TCHAR * optDocPeekOnTab = element->Attribute(TEXT("docPeekOnTab"));
4936  			if (optDocPeekOnTab)
4937  				_nppGUI._isDocPeekOnTab = (lstrcmp(optDocPeekOnTab, TEXT("yes")) == 0);
4938  			const TCHAR * optDocPeekOnMap = element->Attribute(TEXT("docPeekOnMap"));
4939  			if (optDocPeekOnMap)
4940  				_nppGUI._isDocPeekOnMap = (lstrcmp(optDocPeekOnMap, TEXT("yes")) == 0);
4941  			const TCHAR* optSortFunctionList = element->Attribute(TEXT("sortFunctionList"));
4942  			if (optSortFunctionList)
4943  				_nppGUI._shouldSortFunctionList = (lstrcmp(optSortFunctionList, TEXT("yes")) == 0);
4944  			const TCHAR* saveDlgExtFilterToAllTypes = element->Attribute(TEXT("saveDlgExtFilterToAllTypes"));
4945  			if (saveDlgExtFilterToAllTypes)
4946  				_nppGUI._setSaveDlgExtFiltToAllTypes = (lstrcmp(saveDlgExtFilterToAllTypes, TEXT("yes")) == 0);
4947  			const TCHAR * optMuteSounds = element->Attribute(TEXT("muteSounds"));
4948  			if (optMuteSounds)
4949  				_nppGUI._muteSounds = lstrcmp(optMuteSounds, TEXT("yes")) == 0;
4950  			const TCHAR * optEnableFoldCmdToggable = element->Attribute(TEXT("enableFoldCmdToggable"));
4951  			if (optEnableFoldCmdToggable)
4952  				_nppGUI._enableFoldCmdToggable = lstrcmp(optEnableFoldCmdToggable, TEXT("yes")) == 0;
4953  			const TCHAR * hideMenuRightShortcuts = element->Attribute(TEXT("hideMenuRightShortcuts"));
4954  			if (hideMenuRightShortcuts)
4955  				_nppGUI._hideMenuRightShortcuts = lstrcmp(hideMenuRightShortcuts, TEXT("yes")) == 0;
4956  		}
4957  		else if (!lstrcmp(nm, TEXT("commandLineInterpreter")))
4958  		{
4959  			TiXmlNode *node = childNode->FirstChild();
4960  			if (node)
4961  			{
4962  				const TCHAR *cli = node->Value();
4963  				if (cli && cli[0])
4964  					_nppGUI._commandLineInterpreter.assign(cli);
4965  			}
4966  		}
4967  		else if (!lstrcmp(nm, TEXT("DarkMode")))
4968  		{
4969  			_nppGUI._darkmode._isEnabled = parseYesNoBoolAttribute(TEXT("enable"));
4970  			int i;
4971  			const TCHAR* val;
4972  			val = element->Attribute(TEXT("colorTone"), &i);
4973  			if (val)
4974  				_nppGUI._darkmode._colorTone = static_cast<NppDarkMode::ColorTone>(i);
4975  			val = element->Attribute(TEXT("customColorTop"), &i);
4976  			if (val)
4977  				_nppGUI._darkmode._customColors.pureBackground = i;
4978  			val = element->Attribute(TEXT("customColorMenuHotTrack"), &i);
4979  			if (val)
4980  				_nppGUI._darkmode._customColors.hotBackground = i;
4981  			val = element->Attribute(TEXT("customColorActive"), &i);
4982  			if (val)
4983  				_nppGUI._darkmode._customColors.softerBackground = i;
4984  			val = element->Attribute(TEXT("customColorMain"), &i);
4985  			if (val)
4986  				_nppGUI._darkmode._customColors.background = i;
4987  			val = element->Attribute(TEXT("customColorError"), &i);
4988  			if (val)
4989  				_nppGUI._darkmode._customColors.errorBackground = i;
4990  			val = element->Attribute(TEXT("customColorText"), &i);
4991  			if (val)
4992  				_nppGUI._darkmode._customColors.text = i;
4993  			val = element->Attribute(TEXT("customColorDarkText"), &i);
4994  			if (val)
4995  				_nppGUI._darkmode._customColors.darkerText = i;
4996  			val = element->Attribute(TEXT("customColorDisabledText"), &i);
4997  			if (val)
4998  				_nppGUI._darkmode._customColors.disabledText = i;
4999  			val = element->Attribute(TEXT("customColorLinkText"), &i);
5000  			if (val)
5001  				_nppGUI._darkmode._customColors.linkText = i;
5002  			val = element->Attribute(TEXT("customColorEdge"), &i);
5003  			if (val)
5004  				_nppGUI._darkmode._customColors.edge = i;
5005  			val = element->Attribute(TEXT("customColorHotEdge"), &i);
5006  			if (val)
5007  				_nppGUI._darkmode._customColors.hotEdge = i;
5008  			val = element->Attribute(TEXT("customColorDisabledEdge"), &i);
5009  			if (val)
5010  				_nppGUI._darkmode._customColors.disabledEdge = i;
5011  			auto parseStringAttribute = [&element](const TCHAR* name, const TCHAR* defaultName = TEXT("")) -> const TCHAR* {
5012  				const TCHAR* val = element->Attribute(name);
5013  				if (val != nullptr && val[0])
5014  				{
5015  					return element->Attribute(name);
5016  				}
5017  				return defaultName;
5018  			};
5019  			auto parseToolBarIconsAttribute = [&element](const TCHAR* name, int defaultValue = -1) -> int {
5020  				int val;
5021  				const TCHAR* valStr = element->Attribute(name, &val);
5022  				if (valStr != nullptr && (val >= 0 && val <= 4))
5023  				{
5024  					return val;
5025  				}
5026  				return defaultValue;
5027  			};
5028  			auto parseTabIconsAttribute = [&element](const TCHAR* name, int defaultValue = -1) -> int {
5029  				int val;
5030  				const TCHAR* valStr = element->Attribute(name, &val);
5031  				if (valStr != nullptr && (val >= 0 && val <= 2))
5032  				{
5033  					return val;
5034  				}
5035  				return defaultValue;
5036  			};
5037  			auto& windowsMode = _nppGUI._darkmode._advOptions._enableWindowsMode;
5038  			windowsMode = parseYesNoBoolAttribute(TEXT("enableWindowsMode"));
5039  			auto& darkDefaults = _nppGUI._darkmode._advOptions._darkDefaults;
5040  			auto& darkThemeName = darkDefaults._xmlFileName;
5041  			darkThemeName = parseStringAttribute(TEXT("darkThemeName"), TEXT("DarkModeDefault.xml"));
5042  			darkDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT("darkToolBarIconSet"), 0);
5043  			darkDefaults._tabIconSet = parseTabIconsAttribute(TEXT("darkTabIconSet"), 2);
5044  			darkDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT("darkTabUseTheme"));
5045  			auto& lightDefaults = _nppGUI._darkmode._advOptions._lightDefaults;
5046  			auto& lightThemeName = lightDefaults._xmlFileName;
5047  			lightThemeName = parseStringAttribute(TEXT("lightThemeName"));
5048  			lightDefaults._toolBarIconSet = parseToolBarIconsAttribute(TEXT("lightToolBarIconSet"), 4);
5049  			lightDefaults._tabIconSet = parseTabIconsAttribute(TEXT("lightTabIconSet"), 0);
5050  			lightDefaults._tabUseTheme = parseYesNoBoolAttribute(TEXT("lightTabUseTheme"), true);
5051  			if (!windowsMode)
5052  			{
5053  				generic_string themePath;
5054  				generic_string xmlFileName = _nppGUI._darkmode._isEnabled ? darkThemeName : lightThemeName;
5055  				const bool isLocalOnly = _isLocal && !_isCloud;
5056  				if (!xmlFileName.empty() && lstrcmp(xmlFileName.c_str(), TEXT("stylers.xml")) != 0)
5057  				{
5058  					themePath = isLocalOnly ? _nppPath : _userPath;
5059  					pathAppend(themePath, TEXT("themes\\"));
5060  					pathAppend(themePath, xmlFileName);
5061  					if (!isLocalOnly && ::PathFileExists(themePath.c_str()) == FALSE)
5062  					{
5063  						themePath = _nppPath;
5064  						pathAppend(themePath, TEXT("themes\\"));
5065  						pathAppend(themePath, xmlFileName);
5066  					}
5067  				}
5068  				else
5069  				{
5070  					themePath = isLocalOnly ? _nppPath : _userPath;
5071  					pathAppend(themePath, TEXT("stylers.xml"));
5072  					if (!isLocalOnly && ::PathFileExists(themePath.c_str()) == FALSE)
5073  					{
5074  						themePath = _nppPath;
5075  						pathAppend(themePath, TEXT("stylers.xml"));
5076  					}
5077  				}
5078  				if (::PathFileExists(themePath.c_str()) == TRUE)
5079  				{
5080  					_nppGUI._themeName.assign(themePath);
5081  				}
5082  			}
5083  		}
5084  	}
5085  }
5086  void NppParameters::feedScintillaParam(TiXmlNode *node)
5087  {
5088  	TiXmlElement* element = node->ToElement();
5089  	auto parseYesNoBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
5090  		const TCHAR* nm = element->Attribute(name);
5091  		if (nm)
5092  		{
5093  			if (!lstrcmp(nm, TEXT("yes")))
5094  				return true;
5095  			else if (!lstrcmp(nm, TEXT("no")))
5096  				return false;
5097  		}
5098  		return defaultValue;
5099  	};
5100  	auto parseShowHideBoolAttribute = [&element](const TCHAR* name, bool defaultValue = false) -> bool {
5101  		const TCHAR* nm = element->Attribute(name);
5102  		if (nm)
5103  		{
5104  			if (!lstrcmp(nm, TEXT("show")))
5105  				return true;
5106  			else if (!lstrcmp(nm, TEXT("hide")))
5107  				return false;
5108  		}
5109  		return defaultValue;
5110  	};
5111  	const TCHAR *nm = element->Attribute(TEXT("lineNumberMargin"));
5112  	if (nm)
5113  	{
5114  		if (!lstrcmp(nm, TEXT("show")))
5115  			_svp._lineNumberMarginShow = true;
5116  		else if (!lstrcmp(nm, TEXT("hide")))
5117  			_svp._lineNumberMarginShow = false;
5118  	}
5119  	nm = element->Attribute(TEXT("lineNumberDynamicWidth"));
5120  	if (nm)
5121  	{
5122  		if (!lstrcmp(nm, TEXT("yes")))
5123  			_svp._lineNumberMarginDynamicWidth = true;
5124  		else if (!lstrcmp(nm, TEXT("no")))
5125  			_svp._lineNumberMarginDynamicWidth = false;
5126  	}
5127  	nm = element->Attribute(TEXT("bookMarkMargin"));
5128  	if (nm)
5129  	{
5130  		if (!lstrcmp(nm, TEXT("show")))
5131  			_svp._bookMarkMarginShow = true;
5132  		else if (!lstrcmp(nm, TEXT("hide")))
5133  			_svp._bookMarkMarginShow = false;
5134  	}
5135  	nm = element->Attribute(TEXT("isChangeHistoryEnabled"));
5136  	if (nm)
5137  	{
5138  		if (!lstrcmp(nm, TEXT("yes")))
5139  		{
5140  			_svp._isChangeHistoryEnabled = true;
5141  			_svp._isChangeHistoryEnabled4NextSession = true;
5142  		}
5143  		else if (!lstrcmp(nm, TEXT("no")))
5144  		{
5145  			_svp._isChangeHistoryEnabled = false;
5146  			_svp._isChangeHistoryEnabled4NextSession = false;
5147  		}
5148  	}
5149  	nm = element->Attribute(TEXT("indentGuideLine"));
5150  	if (nm)
5151  	{
5152  		if (!lstrcmp(nm, TEXT("show")))
5153  			_svp._indentGuideLineShow = true;
5154  		else if (!lstrcmp(nm, TEXT("hide")))
5155  			_svp._indentGuideLineShow= false;
5156  	}
5157  	nm = element->Attribute(TEXT("folderMarkStyle"));
5158  	if (nm)
5159  	{
5160  		if (!lstrcmp(nm, TEXT("box")))
5161  			_svp._folderStyle = FOLDER_STYLE_BOX;
5162  		else if (!lstrcmp(nm, TEXT("circle")))
5163  			_svp._folderStyle = FOLDER_STYLE_CIRCLE;
5164  		else if (!lstrcmp(nm, TEXT("arrow")))
5165  			_svp._folderStyle = FOLDER_STYLE_ARROW;
5166  		else if (!lstrcmp(nm, TEXT("simple")))
5167  			_svp._folderStyle = FOLDER_STYLE_SIMPLE;
5168  		else if (!lstrcmp(nm, TEXT("none")))
5169  			_svp._folderStyle = FOLDER_STYLE_NONE;
5170  	}
5171  	nm = element->Attribute(TEXT("lineWrapMethod"));
5172  	if (nm)
5173  	{
5174  		if (!lstrcmp(nm, TEXT("default")))
5175  			_svp._lineWrapMethod = LINEWRAP_DEFAULT;
5176  		else if (!lstrcmp(nm, TEXT("aligned")))
5177  			_svp._lineWrapMethod = LINEWRAP_ALIGNED;
5178  		else if (!lstrcmp(nm, TEXT("indent")))
5179  			_svp._lineWrapMethod = LINEWRAP_INDENT;
5180  	}
5181  	nm = element->Attribute(TEXT("currentLineHilitingShow"));
5182  	if (nm)
5183  	{
5184  		if (!lstrcmp(nm, TEXT("show")))
5185  			_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5186  		else
5187  			_svp._currentLineHiliteMode = LINEHILITE_NONE;
5188  	}
5189  	else
5190  	{
5191  		const TCHAR* currentLineModeStr = element->Attribute(TEXT("currentLineIndicator"));
5192  		if (currentLineModeStr && currentLineModeStr[0])
5193  		{
5194  			if (lstrcmp(currentLineModeStr, TEXT("1")) == 0)
5195  				_svp._currentLineHiliteMode = LINEHILITE_HILITE;
5196  			else if (lstrcmp(currentLineModeStr, TEXT("2")) == 0)
5197  				_svp._currentLineHiliteMode = LINEHILITE_FRAME;
5198  			else
5199  				_svp._currentLineHiliteMode = LINEHILITE_NONE;
5200  		}
5201  	}
5202  	nm = element->Attribute(TEXT("currentLineFrameWidth"));
5203  	if (nm)
5204  	{
5205  		unsigned char frameWidth{ 1 };
5206  		try
5207  		{
5208  			frameWidth = static_cast<unsigned char>(std::stoi(nm));
5209  		}
5210  		catch (...)
5211  		{
5212  		}
5213  		_svp._currentLineFrameWidth = (frameWidth < 1) ? 1 : (frameWidth > 6) ? 6 : frameWidth;
5214  	}
5215  	nm = element->Attribute(TEXT("virtualSpace"));
5216  	if (nm)
5217  	{
5218  		if (!lstrcmp(nm, TEXT("yes")))
5219  			_svp._virtualSpace = true;
5220  		else if (!lstrcmp(nm, TEXT("no")))
5221  			_svp._virtualSpace = false;
5222  	}
5223  	nm = element->Attribute(TEXT("scrollBeyondLastLine"));
5224  	if (nm)
5225  	{
5226  		if (!lstrcmp(nm, TEXT("yes")))
5227  			_svp._scrollBeyondLastLine = true;
5228  		else if (!lstrcmp(nm, TEXT("no")))
5229  			_svp._scrollBeyondLastLine = false;
5230  	}
5231  	nm = element->Attribute(TEXT("rightClickKeepsSelection"));
5232  	if (nm)
5233  	{
5234  		if (!lstrcmp(nm, TEXT("yes")))
5235  			_svp._rightClickKeepsSelection = true;
5236  		else if (!lstrcmp(nm, TEXT("no")))
5237  			_svp._rightClickKeepsSelection = false;
5238  	}
5239  	nm = element->Attribute(TEXT("disableAdvancedScrolling"));
5240  	if (nm)
5241  	{
5242  		if (!lstrcmp(nm, TEXT("yes")))
5243  			_svp._disableAdvancedScrolling = true;
5244  		else if (!lstrcmp(nm, TEXT("no")))
5245  			_svp._disableAdvancedScrolling = false;
5246  	}
5247  	nm = element->Attribute(TEXT("wrapSymbolShow"));
5248  	if (nm)
5249  	{
5250  		if (!lstrcmp(nm, TEXT("show")))
5251  			_svp._wrapSymbolShow = true;
5252  		else if (!lstrcmp(nm, TEXT("hide")))
5253  			_svp._wrapSymbolShow = false;
5254  	}
5255  	nm = element->Attribute(TEXT("Wrap"));
5256  	if (nm)
5257  	{
5258  		if (!lstrcmp(nm, TEXT("yes")))
5259  			_svp._doWrap = true;
5260  		else if (!lstrcmp(nm, TEXT("no")))
5261  			_svp._doWrap = false;
5262  	}
5263  	nm = element->Attribute(TEXT("isEdgeBgMode"));
5264  	if (nm)
5265  	{
5266  		if (!lstrcmp(nm, TEXT("yes")))
5267  			_svp._isEdgeBgMode = true;
5268  		else if (!lstrcmp(nm, TEXT("no")))
5269  			_svp._isEdgeBgMode = false;
5270  	}
5271  	nm = element->Attribute(TEXT("borderEdge"));
5272  	if (nm)
5273  	{
5274  		if (!lstrcmp(nm, TEXT("yes")))
5275  			_svp._showBorderEdge = true;
5276  		else if (!lstrcmp(nm, TEXT("no")))
5277  			_svp._showBorderEdge = false;
5278  	}
5279  	nm = element->Attribute(TEXT("edgeMultiColumnPos"));
5280  	if (nm)
5281  	{
5282  		str2numberVector(nm, _svp._edgeMultiColumnPos);
5283  	}
5284  	int val;
5285  	nm = element->Attribute(TEXT("zoom"), &val);
5286  	if (nm)
5287  	{
5288  		_svp._zoom = val;
5289  	}
5290  	nm = element->Attribute(TEXT("zoom2"), &val);
5291  	if (nm)
5292  	{
5293  		_svp._zoom2 = val;
5294  	}
5295  	nm = element->Attribute(TEXT("whiteSpaceShow"));
5296  	if (nm)
5297  	{
5298  		if (!lstrcmp(nm, TEXT("show")))
5299  			_svp._whiteSpaceShow = true;
5300  		else if (!lstrcmp(nm, TEXT("hide")))
5301  			_svp._whiteSpaceShow = false;
5302  	}
5303  	nm = element->Attribute(TEXT("eolShow"));
5304  	if (nm)
5305  	{
5306  		if (!lstrcmp(nm, TEXT("show")))
5307  			_svp._eolShow = true;
5308  		else if (!lstrcmp(nm, TEXT("hide")))
5309  			_svp._eolShow = false;
5310  	}
5311  	nm = element->Attribute(TEXT("eolMode"), &val);
5312  	if (nm)
5313  	{
5314  		if (val >= 0 && val <= 3)
5315  			_svp._eolMode = static_cast<ScintillaViewParams::crlfMode>(val);
5316  	}
5317  	_svp._npcShow = parseShowHideBoolAttribute(TEXT("npcShow"), true);
5318  	nm = element->Attribute(TEXT("npcMode"), &val);
5319  	if (nm)
5320  	{
5321  		if (val >= 1 && val <= 2)
5322  			_svp._npcMode = static_cast<ScintillaViewParams::npcMode>(val);
5323  	}
5324  	_svp._npcCustomColor = parseYesNoBoolAttribute(TEXT("npcCustomColor"));
5325  	_svp._npcIncludeCcUniEol = parseYesNoBoolAttribute(TEXT("npcIncludeCcUniEOL"));
5326  	_svp._ccUniEolShow = parseYesNoBoolAttribute(TEXT("ccShow"), true);
5327  	nm = element->Attribute(TEXT("borderWidth"), &val);
5328  	if (nm)
5329  	{
5330  		if (val >= 0 && val <= 30)
5331  			_svp._borderWidth = val;
5332  	}
5333  	nm = element->Attribute(TEXT("smoothFont"));
5334  	if (nm)
5335  	{
5336  		if (!lstrcmp(nm, TEXT("yes")))
5337  			_svp._doSmoothFont = true;
5338  		else if (!lstrcmp(nm, TEXT("no")))
5339  			_svp._doSmoothFont = false;
5340  	}
5341  	nm = element->Attribute(TEXT("paddingLeft"), &val);
5342  	if (nm)
5343  	{
5344  		if (val >= 0 && val <= 30)
5345  			_svp._paddingLeft = static_cast<unsigned char>(val);
5346  	}
5347  	nm = element->Attribute(TEXT("paddingRight"), &val);
5348  	if (nm)
5349  	{
5350  		if (val >= 0 && val <= 30)
5351  			_svp._paddingRight = static_cast<unsigned char>(val);
5352  	}
5353  	nm = element->Attribute(TEXT("distractionFreeDivPart"), &val);
5354  	if (nm)
5355  	{
5356  		if (val >= 3 && val <= 9)
5357  			_svp._distractionFreeDivPart = static_cast<unsigned char>(val);
5358  	}
5359  }
5360  void NppParameters::feedDockingManager(TiXmlNode *node)
5361  {
5362  	TiXmlElement *element = node->ToElement();
5363  	int i;
5364  	if (element->Attribute(TEXT("leftWidth"), &i))
5365  		_nppGUI._dockingData._leftWidth = i;
5366  	if (element->Attribute(TEXT("rightWidth"), &i))
5367  		_nppGUI._dockingData._rightWidth = i;
5368  	if (element->Attribute(TEXT("topHeight"), &i))
5369  		_nppGUI._dockingData._topHeight = i;
5370  	if (element->Attribute(TEXT("bottomHeight"), &i))
5371  		_nppGUI._dockingData._bottomHight = i;
5372  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("FloatingWindow"));
5373  		childNode ;
5374  		childNode = childNode->NextSibling(TEXT("FloatingWindow")) )
5375  	{
5376  		TiXmlElement *floatElement = childNode->ToElement();
5377  		int cont;
5378  		if (floatElement->Attribute(TEXT("cont"), &cont))
5379  		{
5380  			int x = 0;
5381  			int y = 0;
5382  			int w = 100;
5383  			int h = 100;
5384  			floatElement->Attribute(TEXT("x"), &x);
5385  			floatElement->Attribute(TEXT("y"), &y);
5386  			floatElement->Attribute(TEXT("width"), &w);
5387  			floatElement->Attribute(TEXT("height"), &h);
5388  			_nppGUI._dockingData._flaotingWindowInfo.push_back(FloatingWindowInfo(cont, x, y, w, h));
5389  		}
5390  	}
5391  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("PluginDlg"));
5392  		childNode ;
5393  		childNode = childNode->NextSibling(TEXT("PluginDlg")) )
5394  	{
5395  		TiXmlElement *dlgElement = childNode->ToElement();
5396  		const TCHAR *name = dlgElement->Attribute(TEXT("pluginName"));
5397  		int id;
5398  		const TCHAR *idStr = dlgElement->Attribute(TEXT("id"), &id);
5399  		if (name && idStr)
5400  		{
5401  			int curr = 0; 
5402  			int prev = 0; 
5403  			dlgElement->Attribute(TEXT("curr"), &curr);
5404  			dlgElement->Attribute(TEXT("prev"), &prev);
5405  			bool isVisible = false;
5406  			const TCHAR *val = dlgElement->Attribute(TEXT("isVisible"));
5407  			if (val)
5408  			{
5409  				isVisible = (lstrcmp(val, TEXT("yes")) == 0);
5410  			}
5411  			_nppGUI._dockingData._pluginDockInfo.push_back(PluginDlgDockingInfo(name, id, curr, prev, isVisible));
5412  		}
5413  	}
5414  	for (TiXmlNode *childNode = node->FirstChildElement(TEXT("ActiveTabs"));
5415  		childNode ;
5416  		childNode = childNode->NextSibling(TEXT("ActiveTabs")) )
5417  	{
5418  		TiXmlElement *dlgElement = childNode->ToElement();
5419  		int cont;
5420  		if (dlgElement->Attribute(TEXT("cont"), &cont))
5421  		{
5422  			int activeTab = 0;
5423  			dlgElement->Attribute(TEXT("activeTab"), &activeTab);
5424  			_nppGUI._dockingData._containerTabInfo.push_back(ContainerTabInfo(cont, activeTab));
5425  		}
5426  	}
5427  }
5428  void NppParameters::duplicateDockingManager(TiXmlNode* dockMngNode, TiXmlElement* dockMngElmt2Clone)
5429  {
5430  	if (!dockMngNode || !dockMngElmt2Clone) return;
5431  	TiXmlElement *dockMngElmt = dockMngNode->ToElement();
5432  	int i;
5433  	if (dockMngElmt->Attribute(TEXT("leftWidth"), &i))
5434  		dockMngElmt2Clone->SetAttribute(TEXT("leftWidth"), i);
5435  	if (dockMngElmt->Attribute(TEXT("rightWidth"), &i))
5436  		dockMngElmt2Clone->SetAttribute(TEXT("rightWidth"), i);
5437  	if (dockMngElmt->Attribute(TEXT("topHeight"), &i))
5438  		dockMngElmt2Clone->SetAttribute(TEXT("topHeight"), i);
5439  	if (dockMngElmt->Attribute(TEXT("bottomHeight"), &i))
5440  		dockMngElmt2Clone->SetAttribute(TEXT("bottomHeight"), i);
5441  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("FloatingWindow"));
5442  		childNode;
5443  		childNode = childNode->NextSibling(TEXT("FloatingWindow")))
5444  	{
5445  		TiXmlElement *floatElement = childNode->ToElement();
5446  		int cont;
5447  		if (floatElement->Attribute(TEXT("cont"), &cont))
5448  		{
5449  			TiXmlElement FWNode(TEXT("FloatingWindow"));
5450  			FWNode.SetAttribute(TEXT("cont"), cont);
5451  			int x = 0;
5452  			int y = 0;
5453  			int w = 100;
5454  			int h = 100;
5455  			floatElement->Attribute(TEXT("x"), &x);
5456  			FWNode.SetAttribute(TEXT("x"), x);
5457  			floatElement->Attribute(TEXT("y"), &y);
5458  			FWNode.SetAttribute(TEXT("y"), y);
5459  			floatElement->Attribute(TEXT("width"), &w);
5460  			FWNode.SetAttribute(TEXT("width"), w);
5461  			floatElement->Attribute(TEXT("height"), &h);
5462  			FWNode.SetAttribute(TEXT("height"), h);
5463  			dockMngElmt2Clone->InsertEndChild(FWNode);
5464  		}
5465  	}
5466  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("PluginDlg"));
5467  		childNode;
5468  		childNode = childNode->NextSibling(TEXT("PluginDlg")))
5469  	{
5470  		TiXmlElement *dlgElement = childNode->ToElement();
5471  		const TCHAR *name = dlgElement->Attribute(TEXT("pluginName"));
5472  		TiXmlElement PDNode(TEXT("PluginDlg"));
5473  		int id;
5474  		const TCHAR *idStr = dlgElement->Attribute(TEXT("id"), &id);
5475  		if (name && idStr)
5476  		{
5477  			int curr = 0; 
5478  			int prev = 0; 
5479  			dlgElement->Attribute(TEXT("curr"), &curr);
5480  			dlgElement->Attribute(TEXT("prev"), &prev);
5481  			bool isVisible = false;
5482  			const TCHAR *val = dlgElement->Attribute(TEXT("isVisible"));
5483  			if (val)
5484  			{
5485  				isVisible = (lstrcmp(val, TEXT("yes")) == 0);
5486  			}
5487  			PDNode.SetAttribute(TEXT("pluginName"), name);
5488  			PDNode.SetAttribute(TEXT("id"), idStr);
5489  			PDNode.SetAttribute(TEXT("curr"), curr);
5490  			PDNode.SetAttribute(TEXT("prev"), prev);
5491  			PDNode.SetAttribute(TEXT("isVisible"), isVisible ? TEXT("yes") : TEXT("no"));
5492  			dockMngElmt2Clone->InsertEndChild(PDNode);
5493  		}
5494  	}
5495  	for (TiXmlNode *childNode = dockMngNode->FirstChildElement(TEXT("ActiveTabs"));
5496  		childNode;
5497  		childNode = childNode->NextSibling(TEXT("ActiveTabs")))
5498  	{
5499  		TiXmlElement *dlgElement = childNode->ToElement();
5500  		TiXmlElement CTNode(TEXT("ActiveTabs"));
5501  		int cont;
5502  		if (dlgElement->Attribute(TEXT("cont"), &cont))
5503  		{
5504  			int activeTab = 0;
5505  			dlgElement->Attribute(TEXT("activeTab"), &activeTab);
5506  			CTNode.SetAttribute(TEXT("cont"), cont);
5507  			CTNode.SetAttribute(TEXT("activeTab"), activeTab);
5508  			dockMngElmt2Clone->InsertEndChild(CTNode);
5509  		}
5510  	}
5511  }
5512  bool NppParameters::writeScintillaParams()
5513  {
5514  	if (!_pXmlUserDoc) return false;
5515  	const TCHAR *pViewName = TEXT("ScintillaPrimaryView");
5516  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
5517  	if (!nppRoot)
5518  	{
5519  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
5520  	}
5521  	TiXmlNode *configsRoot = nppRoot->FirstChildElement(TEXT("GUIConfigs"));
5522  	if (!configsRoot)
5523  	{
5524  		configsRoot = nppRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfigs")));
5525  	}
5526  	TiXmlNode *scintNode = getChildElementByAttribut(configsRoot, TEXT("GUIConfig"), TEXT("name"), pViewName);
5527  	if (!scintNode)
5528  	{
5529  		scintNode = configsRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig")));
5530  		(scintNode->ToElement())->SetAttribute(TEXT("name"), pViewName);
5531  	}
5532  	auto setYesNoBoolAttribute = [&scintNode](const TCHAR* name, bool value) -> void {
5533  		const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5534  		(scintNode->ToElement())->SetAttribute(name, pStr);
5535  	};
5536  	auto setShowHideBoolAttribute = [&scintNode](const TCHAR* name, bool value) -> void {
5537  		const TCHAR* pStr = value ? TEXT("show") : TEXT("hide");
5538  		(scintNode->ToElement())->SetAttribute(name, pStr);
5539  	};
5540  	(scintNode->ToElement())->SetAttribute(TEXT("lineNumberMargin"), _svp._lineNumberMarginShow?TEXT("show"):TEXT("hide"));
5541  	(scintNode->ToElement())->SetAttribute(TEXT("lineNumberDynamicWidth"), _svp._lineNumberMarginDynamicWidth ?TEXT("yes"):TEXT("no"));
5542  	(scintNode->ToElement())->SetAttribute(TEXT("bookMarkMargin"), _svp._bookMarkMarginShow?TEXT("show"):TEXT("hide"));
5543  	(scintNode->ToElement())->SetAttribute(TEXT("indentGuideLine"), _svp._indentGuideLineShow?TEXT("show"):TEXT("hide"));
5544  	const TCHAR *pFolderStyleStr = (_svp._folderStyle == FOLDER_STYLE_SIMPLE)?TEXT("simple"):
5545  									(_svp._folderStyle == FOLDER_STYLE_ARROW)?TEXT("arrow"):
5546  										(_svp._folderStyle == FOLDER_STYLE_CIRCLE)?TEXT("circle"):
5547  										(_svp._folderStyle == FOLDER_STYLE_NONE)?TEXT("none"):TEXT("box");
5548  	(scintNode->ToElement())->SetAttribute(TEXT("folderMarkStyle"), pFolderStyleStr);
5549  	(scintNode->ToElement())->SetAttribute(TEXT("isChangeHistoryEnabled"), _svp._isChangeHistoryEnabled4NextSession ? TEXT("yes") : TEXT("no"));
5550  	const TCHAR *pWrapMethodStr = (_svp._lineWrapMethod == LINEWRAP_ALIGNED)?TEXT("aligned"):
5551  								(_svp._lineWrapMethod == LINEWRAP_INDENT)?TEXT("indent"):TEXT("default");
5552  	(scintNode->ToElement())->SetAttribute(TEXT("lineWrapMethod"), pWrapMethodStr);
5553  	(scintNode->ToElement())->SetAttribute(TEXT("currentLineIndicator"), _svp._currentLineHiliteMode);
5554  	(scintNode->ToElement())->SetAttribute(TEXT("currentLineFrameWidth"), _svp._currentLineFrameWidth);
5555  	(scintNode->ToElement())->SetAttribute(TEXT("virtualSpace"), _svp._virtualSpace?TEXT("yes"):TEXT("no"));
5556  	(scintNode->ToElement())->SetAttribute(TEXT("scrollBeyondLastLine"), _svp._scrollBeyondLastLine?TEXT("yes"):TEXT("no"));
5557  	(scintNode->ToElement())->SetAttribute(TEXT("rightClickKeepsSelection"), _svp._rightClickKeepsSelection ? TEXT("yes") : TEXT("no"));
5558  	(scintNode->ToElement())->SetAttribute(TEXT("disableAdvancedScrolling"), _svp._disableAdvancedScrolling?TEXT("yes"):TEXT("no"));
5559  	(scintNode->ToElement())->SetAttribute(TEXT("wrapSymbolShow"), _svp._wrapSymbolShow?TEXT("show"):TEXT("hide"));
5560  	(scintNode->ToElement())->SetAttribute(TEXT("Wrap"), _svp._doWrap?TEXT("yes"):TEXT("no"));
5561  	(scintNode->ToElement())->SetAttribute(TEXT("borderEdge"), _svp._showBorderEdge ? TEXT("yes") : TEXT("no"));
5562  	generic_string edgeColumnPosStr;
5563  	for (auto i : _svp._edgeMultiColumnPos)
5564  	{
5565  		std::string s = std::to_string(i);
5566  		edgeColumnPosStr += generic_string(s.begin(), s.end());
5567  		edgeColumnPosStr += TEXT(" ");
5568  	}
5569  	(scintNode->ToElement())->SetAttribute(TEXT("isEdgeBgMode"), _svp._isEdgeBgMode ? TEXT("yes") : TEXT("no"));
5570  	(scintNode->ToElement())->SetAttribute(TEXT("edgeMultiColumnPos"), edgeColumnPosStr);
5571  	(scintNode->ToElement())->SetAttribute(TEXT("zoom"), static_cast<int>(_svp._zoom));
5572  	(scintNode->ToElement())->SetAttribute(TEXT("zoom2"), static_cast<int>(_svp._zoom2));
5573  	(scintNode->ToElement())->SetAttribute(TEXT("whiteSpaceShow"), _svp._whiteSpaceShow?TEXT("show"):TEXT("hide"));
5574  	(scintNode->ToElement())->SetAttribute(TEXT("eolShow"), _svp._eolShow?TEXT("show"):TEXT("hide"));
5575  	(scintNode->ToElement())->SetAttribute(TEXT("eolMode"), _svp._eolMode);
5576  	setShowHideBoolAttribute(TEXT("npcShow"), _svp._npcShow);
5577  	(scintNode->ToElement())->SetAttribute(TEXT("npcMode"), static_cast<int>(_svp._npcMode));
5578  	setYesNoBoolAttribute(TEXT("npcCustomColor"), _svp._npcCustomColor);
5579  	setYesNoBoolAttribute(TEXT("npcIncludeCcUniEOL"), _svp._npcIncludeCcUniEol);
5580  	setYesNoBoolAttribute(TEXT("ccShow"), _svp._ccUniEolShow);
5581  	(scintNode->ToElement())->SetAttribute(TEXT("borderWidth"), _svp._borderWidth);
5582  	(scintNode->ToElement())->SetAttribute(TEXT("smoothFont"), _svp._doSmoothFont ? TEXT("yes") : TEXT("no"));
5583  	(scintNode->ToElement())->SetAttribute(TEXT("paddingLeft"), _svp._paddingLeft);
5584  	(scintNode->ToElement())->SetAttribute(TEXT("paddingRight"), _svp._paddingRight);
5585  	(scintNode->ToElement())->SetAttribute(TEXT("distractionFreeDivPart"), _svp._distractionFreeDivPart);
5586  	return true;
5587  }
5588  void NppParameters::createXmlTreeFromGUIParams()
5589  {
5590  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
5591  	if (!nppRoot)
5592  	{
5593  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
5594  	}
5595  	TiXmlNode *oldGUIRoot = nppRoot->FirstChildElement(TEXT("GUIConfigs"));
5596  	TiXmlElement* dockMngNodeDup = nullptr;
5597  	TiXmlNode* dockMngNodeOriginal = nullptr;
5598  	if (oldGUIRoot && _nppGUI._isCmdlineNosessionActivated)
5599  	{
5600  		for (TiXmlNode *childNode = oldGUIRoot->FirstChildElement(TEXT("GUIConfig"));
5601  			childNode;
5602  			childNode = childNode->NextSibling(TEXT("GUIConfig")))
5603  		{
5604  			TiXmlElement* element = childNode->ToElement();
5605  			const TCHAR* nm = element->Attribute(TEXT("name"));
5606  			if (nullptr == nm)
5607  				continue;
5608  			if (!lstrcmp(nm, TEXT("DockingManager")))
5609  			{
5610  				dockMngNodeOriginal = childNode;
5611  				break;
5612  			}
5613  		}
5614  		if (dockMngNodeOriginal)
5615  		{
5616  			dockMngNodeDup = new TiXmlElement(TEXT("GUIConfig"));
5617  			dockMngNodeDup->SetAttribute(TEXT("name"), TEXT("DockingManager"));
5618  			duplicateDockingManager(dockMngNodeOriginal, dockMngNodeDup);
5619  		}
5620  	}
5621  	if (oldGUIRoot)
5622  	{
5623  		nppRoot->RemoveChild(oldGUIRoot);
5624  	}
5625  	TiXmlNode *newGUIRoot = nppRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfigs")));
5626  	{
5627  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5628  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ToolBar"));
5629  		const TCHAR *pStr = (_nppGUI._toolbarShow) ? TEXT("yes") : TEXT("no");
5630  		GUIConfigElement->SetAttribute(TEXT("visible"), pStr);
5631  		if (_nppGUI._toolBarStatus == TB_SMALL)
5632  			pStr = TEXT("small");
5633  		else if (_nppGUI._toolBarStatus == TB_LARGE)
5634  			pStr = TEXT("large");
5635  		else if (_nppGUI._toolBarStatus == TB_SMALL2)
5636  			pStr = TEXT("small2");
5637  		else if (_nppGUI._toolBarStatus == TB_LARGE2)
5638  			pStr = TEXT("large2");
5639  		else 
5640  			pStr = TEXT("standard");
5641  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5642  	}
5643  	{
5644  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5645  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("StatusBar"));
5646  		const TCHAR *pStr = _nppGUI._statusBarShow ? TEXT("show") : TEXT("hide");
5647  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5648  	}
5649  	{
5650  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5651  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("TabBar"));
5652  		const TCHAR *pStr = (_nppGUI._tabStatus & TAB_DRAWTOPBAR) ? TEXT("yes") : TEXT("no");
5653  		GUIConfigElement->SetAttribute(TEXT("dragAndDrop"), pStr);
5654  		pStr = (_nppGUI._tabStatus & TAB_DRAGNDROP) ? TEXT("yes") : TEXT("no");
5655  		GUIConfigElement->SetAttribute(TEXT("drawTopBar"), pStr);
5656  		pStr = (_nppGUI._tabStatus & TAB_DRAWINACTIVETAB) ? TEXT("yes") : TEXT("no");
5657  		GUIConfigElement->SetAttribute(TEXT("drawInactiveTab"), pStr);
5658  		pStr = (_nppGUI._tabStatus & TAB_REDUCE) ? TEXT("yes") : TEXT("no");
5659  		GUIConfigElement->SetAttribute(TEXT("reduce"), pStr);
5660  		pStr = (_nppGUI._tabStatus & TAB_CLOSEBUTTON) ? TEXT("yes") : TEXT("no");
5661  		GUIConfigElement->SetAttribute(TEXT("closeButton"), pStr);
5662  		pStr = (_nppGUI._tabStatus & TAB_DBCLK2CLOSE) ? TEXT("yes") : TEXT("no");
5663  		GUIConfigElement->SetAttribute(TEXT("doubleClick2Close"), pStr);
5664  		pStr = (_nppGUI._tabStatus & TAB_VERTICAL) ? TEXT("yes") : TEXT("no");
5665  		GUIConfigElement->SetAttribute(TEXT("vertical"), pStr);
5666  		pStr = (_nppGUI._tabStatus & TAB_MULTILINE) ? TEXT("yes") : TEXT("no");
5667  		GUIConfigElement->SetAttribute(TEXT("multiLine"), pStr);
5668  		pStr = (_nppGUI._tabStatus & TAB_HIDE) ? TEXT("yes") : TEXT("no");
5669  		GUIConfigElement->SetAttribute(TEXT("hide"), pStr);
5670  		pStr = (_nppGUI._tabStatus & TAB_QUITONEMPTY) ? TEXT("yes") : TEXT("no");
5671  		GUIConfigElement->SetAttribute(TEXT("quitOnEmpty"), pStr);
5672  		pStr = (_nppGUI._tabStatus & TAB_ALTICONS) ? TEXT("1") : TEXT("0");
5673  		GUIConfigElement->SetAttribute(TEXT("iconSetNumber"), pStr);
5674  	}
5675  	{
5676  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5677  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ScintillaViewsSplitter"));
5678  		const TCHAR *pStr = _nppGUI._splitterPos == POS_VERTICAL ? TEXT("vertical") : TEXT("horizontal");
5679  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5680  	}
5681  	{
5682  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5683  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("UserDefineDlg"));
5684  		const TCHAR *pStr = (_nppGUI._userDefineDlgStatus & UDD_DOCKED) ? TEXT("docked") : TEXT("undocked");
5685  		GUIConfigElement->SetAttribute(TEXT("position"), pStr);
5686  		pStr = (_nppGUI._userDefineDlgStatus & UDD_SHOW) ? TEXT("show") : TEXT("hide");
5687  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5688  	}
5689  	{
5690  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5691  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("TabSetting"));
5692  		const TCHAR *pStr = _nppGUI._tabReplacedBySpace ? TEXT("yes") : TEXT("no");
5693  		GUIConfigElement->SetAttribute(TEXT("replaceBySpace"), pStr);
5694  		GUIConfigElement->SetAttribute(TEXT("size"), _nppGUI._tabSize);
5695  	}
5696  	{
5697  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5698  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("AppPosition"));
5699  		GUIConfigElement->SetAttribute(TEXT("x"), _nppGUI._appPos.left);
5700  		GUIConfigElement->SetAttribute(TEXT("y"), _nppGUI._appPos.top);
5701  		GUIConfigElement->SetAttribute(TEXT("width"), _nppGUI._appPos.right);
5702  		GUIConfigElement->SetAttribute(TEXT("height"), _nppGUI._appPos.bottom);
5703  		GUIConfigElement->SetAttribute(TEXT("isMaximized"), _nppGUI._isMaximized ? TEXT("yes") : TEXT("no"));
5704  	}
5705  	{
5706  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5707  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("FindWindowPosition"));
5708  		GUIConfigElement->SetAttribute(TEXT("left"), _nppGUI._findWindowPos.left);
5709  		GUIConfigElement->SetAttribute(TEXT("top"), _nppGUI._findWindowPos.top);
5710  		GUIConfigElement->SetAttribute(TEXT("right"), _nppGUI._findWindowPos.right);
5711  		GUIConfigElement->SetAttribute(TEXT("bottom"), _nppGUI._findWindowPos.bottom);
5712  		GUIConfigElement->SetAttribute(TEXT("isLessModeOn"), _nppGUI._findWindowLessMode ? TEXT("yes") : TEXT("no"));
5713  	}
5714  	{
5715  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5716  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("FinderConfig"));
5717  		const TCHAR* pStr = _nppGUI._finderLinesAreCurrentlyWrapped ? TEXT("yes") : TEXT("no");
5718  		GUIConfigElement->SetAttribute(TEXT("wrappedLines"), pStr);
5719  		pStr = _nppGUI._finderPurgeBeforeEverySearch ? TEXT("yes") : TEXT("no");
5720  		GUIConfigElement->SetAttribute(TEXT("purgeBeforeEverySearch"), pStr);
5721  		pStr = _nppGUI._finderShowOnlyOneEntryPerFoundLine ? TEXT("yes") : TEXT("no");
5722  		GUIConfigElement->SetAttribute(TEXT("showOnlyOneEntryPerFoundLine"), pStr);
5723  	}
5724  	{
5725  		TiXmlElement *element = insertGUIConfigBoolNode(newGUIRoot, TEXT("noUpdate"), !_nppGUI._autoUpdateOpt._doAutoUpdate);
5726  		element->SetAttribute(TEXT("intervalDays"), _nppGUI._autoUpdateOpt._intervalDays);
5727  		element->SetAttribute(TEXT("nextUpdateDate"), _nppGUI._autoUpdateOpt._nextUpdateDate.toString().c_str());
5728  	}
5729  	{
5730  		const TCHAR *pStr = TEXT("no");
5731  		if (_nppGUI._fileAutoDetection & cdEnabledOld)
5732  		{
5733  			pStr = TEXT("yesOld");
5734  			if ((_nppGUI._fileAutoDetection & cdAutoUpdate) && (_nppGUI._fileAutoDetection & cdGo2end))
5735  			{
5736  				pStr = TEXT("autoUpdate2EndOld");
5737  			}
5738  			else if (_nppGUI._fileAutoDetection & cdAutoUpdate)
5739  			{
5740  				pStr = TEXT("autoOld");
5741  			}
5742  			else if (_nppGUI._fileAutoDetection & cdGo2end)
5743  			{
5744  				pStr = TEXT("Update2EndOld");
5745  			}
5746  		}
5747  		else if (_nppGUI._fileAutoDetection & cdEnabledNew)
5748  		{
5749  			pStr = TEXT("yes");
5750  			if ((_nppGUI._fileAutoDetection & cdAutoUpdate) && (_nppGUI._fileAutoDetection & cdGo2end))
5751  			{
5752  				pStr = TEXT("autoUpdate2End");
5753  			}
5754  			else if (_nppGUI._fileAutoDetection & cdAutoUpdate)
5755  			{
5756  				pStr = TEXT("auto");
5757  			}
5758  			else if (_nppGUI._fileAutoDetection & cdGo2end)
5759  			{
5760  				pStr = TEXT("Update2End");
5761  			}
5762  		}
5763  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5764  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Auto-detection"));
5765  		GUIConfigElement->InsertEndChild(TiXmlText(pStr));
5766  	}
5767  	{
5768  		insertGUIConfigBoolNode(newGUIRoot, TEXT("CheckHistoryFiles"), _nppGUI._checkHistoryFiles);
5769  	}
5770  	{
5771  		insertGUIConfigBoolNode(newGUIRoot, TEXT("TrayIcon"), _nppGUI._isMinimizedToTray);
5772  	}
5773  	{
5774  		insertGUIConfigBoolNode(newGUIRoot, TEXT("MaitainIndent"), _nppGUI._maitainIndent);
5775  	}
5776  	{
5777  		TiXmlElement * ele = insertGUIConfigBoolNode(newGUIRoot, TEXT("TagsMatchHighLight"), _nppGUI._enableTagsMatchHilite);
5778  		ele->SetAttribute(TEXT("TagAttrHighLight"), _nppGUI._enableTagAttrsHilite ? TEXT("yes") : TEXT("no"));
5779  		ele->SetAttribute(TEXT("HighLightNonHtmlZone"), _nppGUI._enableHiliteNonHTMLZone ? TEXT("yes") : TEXT("no"));
5780  	}
5781  	{
5782  		insertGUIConfigBoolNode(newGUIRoot, TEXT("RememberLastSession"), _nppGUI._rememberLastSession);
5783  	}
5784  	{
5785  		insertGUIConfigBoolNode(newGUIRoot, TEXT("DetectEncoding"), _nppGUI._detectEncoding);
5786  	}
5787  	{
5788  		insertGUIConfigBoolNode(newGUIRoot, TEXT("SaveAllConfirm"), _nppGUI._saveAllConfirm);
5789  	}
5790  	{
5791  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5792  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("NewDocDefaultSettings"));
5793  		GUIConfigElement->SetAttribute(TEXT("format"), static_cast<int32_t>(_nppGUI._newDocDefaultSettings._format));
5794  		GUIConfigElement->SetAttribute(TEXT("encoding"), _nppGUI._newDocDefaultSettings._unicodeMode);
5795  		GUIConfigElement->SetAttribute(TEXT("lang"), _nppGUI._newDocDefaultSettings._lang);
5796  		GUIConfigElement->SetAttribute(TEXT("codepage"), _nppGUI._newDocDefaultSettings._codepage);
5797  		GUIConfigElement->SetAttribute(TEXT("openAnsiAsUTF8"), _nppGUI._newDocDefaultSettings._openAnsiAsUtf8 ? TEXT("yes") : TEXT("no"));
5798  		GUIConfigElement->SetAttribute(TEXT("addNewDocumentOnStartup"), _nppGUI._newDocDefaultSettings._addNewDocumentOnStartup ? TEXT("yes") : TEXT("no"));
5799  	}
5800  	{
5801  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5802  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("langsExcluded"));
5803  		writeExcludedLangList(GUIConfigElement);
5804  		GUIConfigElement->SetAttribute(TEXT("langMenuCompact"), _nppGUI._isLangMenuCompact ? TEXT("yes") : TEXT("no"));
5805  	}
5806  	{
5807  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5808  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Print"));
5809  		writePrintSetting(GUIConfigElement);
5810  	}
5811  	{
5812  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5813  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Backup"));
5814  		GUIConfigElement->SetAttribute(TEXT("action"), _nppGUI._backup);
5815  		GUIConfigElement->SetAttribute(TEXT("useCustumDir"), _nppGUI._useDir ? TEXT("yes") : TEXT("no"));
5816  		GUIConfigElement->SetAttribute(TEXT("dir"), _nppGUI._backupDir.c_str());
5817  		GUIConfigElement->SetAttribute(TEXT("isSnapshotMode"), _nppGUI._isSnapshotMode ? TEXT("yes") : TEXT("no"));
5818  		GUIConfigElement->SetAttribute(TEXT("snapshotBackupTiming"), static_cast<int32_t>(_nppGUI._snapshotBackupTiming));
5819  	}
5820  	{
5821  		insertGUIConfigBoolNode(newGUIRoot, TEXT("TaskList"), _nppGUI._doTaskList);
5822  	}
5823  	{
5824  		insertGUIConfigBoolNode(newGUIRoot, TEXT("MRU"), _nppGUI._styleMRU);
5825  	}
5826  	{
5827  		TCHAR szStr [12] = TEXT("0");
5828  		_itow(_nppGUI._styleURL, szStr, 10);
5829  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5830  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("URL"));
5831  		GUIConfigElement->InsertEndChild(TiXmlText(szStr));
5832  	}
5833  	{
5834  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5835  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("uriCustomizedSchemes"));
5836  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._uriSchemes.c_str()));
5837  	}
5838  	{
5839  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5840  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("globalOverride"));
5841  		GUIConfigElement->SetAttribute(TEXT("fg"), _nppGUI._globalOverride.enableFg ? TEXT("yes") : TEXT("no"));
5842  		GUIConfigElement->SetAttribute(TEXT("bg"), _nppGUI._globalOverride.enableBg ? TEXT("yes") : TEXT("no"));
5843  		GUIConfigElement->SetAttribute(TEXT("font"), _nppGUI._globalOverride.enableFont ? TEXT("yes") : TEXT("no"));
5844  		GUIConfigElement->SetAttribute(TEXT("fontSize"), _nppGUI._globalOverride.enableFontSize ? TEXT("yes") : TEXT("no"));
5845  		GUIConfigElement->SetAttribute(TEXT("bold"), _nppGUI._globalOverride.enableBold ? TEXT("yes") : TEXT("no"));
5846  		GUIConfigElement->SetAttribute(TEXT("italic"), _nppGUI._globalOverride.enableItalic ? TEXT("yes") : TEXT("no"));
5847  		GUIConfigElement->SetAttribute(TEXT("underline"), _nppGUI._globalOverride.enableUnderLine ? TEXT("yes") : TEXT("no"));
5848  	}
5849  	{
5850  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5851  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("auto-completion"));
5852  		GUIConfigElement->SetAttribute(TEXT("autoCAction"), _nppGUI._autocStatus);
5853  		GUIConfigElement->SetAttribute(TEXT("triggerFromNbChar"), static_cast<int32_t>(_nppGUI._autocFromLen));
5854  		const TCHAR * pStr = _nppGUI._autocIgnoreNumbers ? TEXT("yes") : TEXT("no");
5855  		GUIConfigElement->SetAttribute(TEXT("autoCIgnoreNumbers"), pStr);
5856  		pStr = _nppGUI._autocInsertSelectedUseENTER ? TEXT("yes") : TEXT("no");
5857  		GUIConfigElement->SetAttribute(TEXT("insertSelectedItemUseENTER"), pStr);
5858  		pStr = _nppGUI._autocInsertSelectedUseTAB ? TEXT("yes") : TEXT("no");
5859  		GUIConfigElement->SetAttribute(TEXT("insertSelectedItemUseTAB"), pStr);
5860  		pStr = _nppGUI._autocBrief ? TEXT("yes") : TEXT("no");
5861  		GUIConfigElement->SetAttribute(TEXT("autoCBrief"), pStr);
5862  		pStr = _nppGUI._funcParams ? TEXT("yes") : TEXT("no");
5863  		GUIConfigElement->SetAttribute(TEXT("funcParams"), pStr);
5864  	}
5865  	{
5866  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5867  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("auto-insert"));
5868  		GUIConfigElement->SetAttribute(TEXT("parentheses"), _nppGUI._matchedPairConf._doParentheses ? TEXT("yes") : TEXT("no"));
5869  		GUIConfigElement->SetAttribute(TEXT("brackets"), _nppGUI._matchedPairConf._doBrackets ? TEXT("yes") : TEXT("no"));
5870  		GUIConfigElement->SetAttribute(TEXT("curlyBrackets"), _nppGUI._matchedPairConf._doCurlyBrackets ? TEXT("yes") : TEXT("no"));
5871  		GUIConfigElement->SetAttribute(TEXT("quotes"), _nppGUI._matchedPairConf._doQuotes ? TEXT("yes") : TEXT("no"));
5872  		GUIConfigElement->SetAttribute(TEXT("doubleQuotes"), _nppGUI._matchedPairConf._doDoubleQuotes ? TEXT("yes") : TEXT("no"));
5873  		GUIConfigElement->SetAttribute(TEXT("htmlXmlTag"), _nppGUI._matchedPairConf._doHtmlXmlTag ? TEXT("yes") : TEXT("no"));
5874  		TiXmlElement hist_element{ TEXT("") };
5875  		hist_element.SetValue(TEXT("UserDefinePair"));
5876  		for (size_t i = 0, nb = _nppGUI._matchedPairConf._matchedPairs.size(); i < nb; ++i)
5877  		{
5878  			int open = _nppGUI._matchedPairConf._matchedPairs[i].first;
5879  			int close = _nppGUI._matchedPairConf._matchedPairs[i].second;
5880  			(hist_element.ToElement())->SetAttribute(TEXT("open"), open);
5881  			(hist_element.ToElement())->SetAttribute(TEXT("close"), close);
5882  			GUIConfigElement->InsertEndChild(hist_element);
5883  		}
5884  	}
5885  	{
5886  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5887  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("sessionExt"));
5888  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._definedSessionExt.c_str()));
5889  	}
5890  	{
5891  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5892  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("workspaceExt"));
5893  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._definedWorkspaceExt.c_str()));
5894  	}
5895  	{
5896  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5897  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MenuBar"));
5898  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._menuBarShow ? TEXT("show") : TEXT("hide")));
5899  	}
5900  	{
5901  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5902  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Caret"));
5903  		GUIConfigElement->SetAttribute(TEXT("width"), _nppGUI._caretWidth);
5904  		GUIConfigElement->SetAttribute(TEXT("blinkRate"), _nppGUI._caretBlinkRate);
5905  	}
5906  	{
5907  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5908  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("ScintillaGlobalSettings"));
5909  		GUIConfigElement->SetAttribute(TEXT("enableMultiSelection"), _nppGUI._enableMultiSelection ? TEXT("yes") : TEXT("no"));
5910  	}
5911  	{
5912  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5913  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("openSaveDir"));
5914  		GUIConfigElement->SetAttribute(TEXT("value"), _nppGUI._openSaveDir);
5915  		GUIConfigElement->SetAttribute(TEXT("defaultDirPath"), _nppGUI._defaultDir);
5916  	}
5917  	{
5918  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5919  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("titleBar"));
5920  		const TCHAR *pStr = (_nppGUI._shortTitlebar) ? TEXT("yes") : TEXT("no");
5921  		GUIConfigElement->SetAttribute(TEXT("short"), pStr);
5922  	}
5923  	{
5924  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5925  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("insertDateTime"));
5926  		GUIConfigElement->SetAttribute(TEXT("customizedFormat"), _nppGUI._dateTimeFormat.c_str());
5927  		const TCHAR* pStr = (_nppGUI._dateTimeReverseDefaultOrder) ? TEXT("yes") : TEXT("no");
5928  		GUIConfigElement->SetAttribute(TEXT("reverseDefaultOrder"), pStr);
5929  	}
5930  	{
5931  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5932  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("wordCharList"));
5933  		GUIConfigElement->SetAttribute(TEXT("useDefault"), _nppGUI._isWordCharDefault ? TEXT("yes") : TEXT("no"));
5934  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
5935  		const wchar_t* charsAddStr = wmc.char2wchar(_nppGUI._customWordChars.c_str(), SC_CP_UTF8);
5936  		GUIConfigElement->SetAttribute(TEXT("charsAdded"), charsAddStr);
5937  	}
5938  	{
5939  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5940  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("delimiterSelection"));
5941  		GUIConfigElement->SetAttribute(TEXT("leftmostDelimiter"), _nppGUI._leftmostDelimiter);
5942  		GUIConfigElement->SetAttribute(TEXT("rightmostDelimiter"), _nppGUI._rightmostDelimiter);
5943  		GUIConfigElement->SetAttribute(TEXT("delimiterSelectionOnEntireDocument"), _nppGUI._delimiterSelectionOnEntireDocument ? TEXT("yes") : TEXT("no"));
5944  	}
5945  	{
5946  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5947  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("largeFileRestriction"));
5948  		GUIConfigElement->SetAttribute(TEXT("fileSizeMB"), static_cast<int>((_nppGUI._largeFileRestriction._largeFileSizeDefInByte / 1024) / 1024));
5949  		GUIConfigElement->SetAttribute(TEXT("isEnabled"), _nppGUI._largeFileRestriction._isEnabled ? TEXT("yes") : TEXT("no"));
5950  		GUIConfigElement->SetAttribute(TEXT("allowAutoCompletion"), _nppGUI._largeFileRestriction._allowAutoCompletion ? TEXT("yes") : TEXT("no"));
5951  		GUIConfigElement->SetAttribute(TEXT("allowBraceMatch"), _nppGUI._largeFileRestriction._allowBraceMatch ? TEXT("yes") : TEXT("no"));
5952  		GUIConfigElement->SetAttribute(TEXT("allowSmartHilite"), _nppGUI._largeFileRestriction._allowSmartHilite ? TEXT("yes") : TEXT("no"));
5953  		GUIConfigElement->SetAttribute(TEXT("allowClickableLink"), _nppGUI._largeFileRestriction._allowClickableLink ? TEXT("yes") : TEXT("no"));
5954  		GUIConfigElement->SetAttribute(TEXT("deactivateWordWrap"), _nppGUI._largeFileRestriction._deactivateWordWrap ? TEXT("yes") : TEXT("no"));
5955  	}
5956  	{
5957  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5958  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("multiInst"));
5959  		GUIConfigElement->SetAttribute(TEXT("setting"), _nppGUI._multiInstSetting);
5960  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) -> void {
5961  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5962  			GUIConfigElement->SetAttribute(name, pStr);
5963  		};
5964  		setYesNoBoolAttribute(TEXT("clipboardHistory"), _nppGUI._clipboardHistoryPanelKeepState);
5965  		setYesNoBoolAttribute(TEXT("documentList"), _nppGUI._docListKeepState);
5966  		setYesNoBoolAttribute(TEXT("characterPanel"), _nppGUI._charPanelKeepState);
5967  		setYesNoBoolAttribute(TEXT("folderAsWorkspace"), _nppGUI._fileBrowserKeepState);
5968  		setYesNoBoolAttribute(TEXT("projectPanels"), _nppGUI._projectPanelKeepState);
5969  		setYesNoBoolAttribute(TEXT("documentMap"), _nppGUI._docMapKeepState);
5970  		setYesNoBoolAttribute(TEXT("fuctionList"), _nppGUI._funcListKeepState);
5971  		setYesNoBoolAttribute(TEXT("pluginPanels"), _nppGUI._pluginPanelKeepState);
5972  	}
5973  	{
5974  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5975  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MISC"));
5976  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) -> void {
5977  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
5978  			GUIConfigElement->SetAttribute(name, pStr);
5979  		};
5980  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherWithoutExtColumn"), _nppGUI._fileSwitcherWithoutExtColumn ? TEXT("yes") : TEXT("no"));
5981  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherExtWidth"), _nppGUI._fileSwitcherExtWidth);
5982  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherWithoutPathColumn"), _nppGUI._fileSwitcherWithoutPathColumn ? TEXT("yes") : TEXT("no"));
5983  		GUIConfigElement->SetAttribute(TEXT("fileSwitcherPathWidth"), _nppGUI._fileSwitcherPathWidth);
5984  		setYesNoBoolAttribute(TEXT("fileSwitcherNoGroups"), _nppGUI._fileSwitcherDisableListViewGroups);
5985  		GUIConfigElement->SetAttribute(TEXT("backSlashIsEscapeCharacterForSql"), _nppGUI._backSlashIsEscapeCharacterForSql ? TEXT("yes") : TEXT("no"));
5986  		GUIConfigElement->SetAttribute(TEXT("writeTechnologyEngine"), _nppGUI._writeTechnologyEngine);
5987  		GUIConfigElement->SetAttribute(TEXT("isFolderDroppedOpenFiles"), _nppGUI._isFolderDroppedOpenFiles ? TEXT("yes") : TEXT("no"));
5988  		GUIConfigElement->SetAttribute(TEXT("docPeekOnTab"), _nppGUI._isDocPeekOnTab ? TEXT("yes") : TEXT("no"));
5989  		GUIConfigElement->SetAttribute(TEXT("docPeekOnMap"), _nppGUI._isDocPeekOnMap ? TEXT("yes") : TEXT("no"));
5990  		GUIConfigElement->SetAttribute(TEXT("sortFunctionList"), _nppGUI._shouldSortFunctionList ? TEXT("yes") : TEXT("no"));
5991  		GUIConfigElement->SetAttribute(TEXT("saveDlgExtFilterToAllTypes"), _nppGUI._setSaveDlgExtFiltToAllTypes ? TEXT("yes") : TEXT("no"));
5992  		GUIConfigElement->SetAttribute(TEXT("muteSounds"), _nppGUI._muteSounds ? TEXT("yes") : TEXT("no"));
5993  		GUIConfigElement->SetAttribute(TEXT("enableFoldCmdToggable"), _nppGUI._enableFoldCmdToggable ? TEXT("yes") : TEXT("no"));
5994  		GUIConfigElement->SetAttribute(TEXT("hideMenuRightShortcuts"), _nppGUI._hideMenuRightShortcuts ? TEXT("yes") : TEXT("no"));
5995  	}
5996  	{
5997  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
5998  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("Searching"));
5999  		GUIConfigElement->SetAttribute(TEXT("monospacedFontFindDlg"), _nppGUI._monospacedFontFindDlg ? TEXT("yes") : TEXT("no"));
6000  		GUIConfigElement->SetAttribute(TEXT("fillFindFieldWithSelected"), _nppGUI._fillFindFieldWithSelected ? TEXT("yes") : TEXT("no"));
6001  		GUIConfigElement->SetAttribute(TEXT("fillFindFieldSelectCaret"), _nppGUI._fillFindFieldSelectCaret ? TEXT("yes") : TEXT("no"));
6002  		GUIConfigElement->SetAttribute(TEXT("findDlgAlwaysVisible"), _nppGUI._findDlgAlwaysVisible ? TEXT("yes") : TEXT("no"));
6003  		GUIConfigElement->SetAttribute(TEXT("confirmReplaceInAllOpenDocs"), _nppGUI._confirmReplaceInAllOpenDocs ? TEXT("yes") : TEXT("no"));
6004  		GUIConfigElement->SetAttribute(TEXT("replaceStopsWithoutFindingNext"), _nppGUI._replaceStopsWithoutFindingNext ? TEXT("yes") : TEXT("no"));
6005  	}
6006  	{
6007  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6008  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("searchEngine"));
6009  		GUIConfigElement->SetAttribute(TEXT("searchEngineChoice"), _nppGUI._searchEngineChoice);
6010  		GUIConfigElement->SetAttribute(TEXT("searchEngineCustom"), _nppGUI._searchEngineCustom);
6011  	}
6012  	{
6013  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6014  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("MarkAll"));
6015  		GUIConfigElement->SetAttribute(TEXT("matchCase"), _nppGUI._markAllCaseSensitive ? TEXT("yes") : TEXT("no"));
6016  		GUIConfigElement->SetAttribute(TEXT("wholeWordOnly"), _nppGUI._markAllWordOnly ? TEXT("yes") : TEXT("no"));
6017  	}
6018  	{
6019  		TiXmlElement *GUIConfigElement = insertGUIConfigBoolNode(newGUIRoot, TEXT("SmartHighLight"), _nppGUI._enableSmartHilite);
6020  		GUIConfigElement->SetAttribute(TEXT("matchCase"), _nppGUI._smartHiliteCaseSensitive ? TEXT("yes") : TEXT("no"));
6021  		GUIConfigElement->SetAttribute(TEXT("wholeWordOnly"), _nppGUI._smartHiliteWordOnly ? TEXT("yes") : TEXT("no"));
6022  		GUIConfigElement->SetAttribute(TEXT("useFindSettings"), _nppGUI._smartHiliteUseFindSettings ? TEXT("yes") : TEXT("no"));
6023  		GUIConfigElement->SetAttribute(TEXT("onAnotherView"), _nppGUI._smartHiliteOnAnotherView ? TEXT("yes") : TEXT("no"));
6024  	}
6025  	if (_nppGUI._commandLineInterpreter.compare(CMD_INTERPRETER))
6026  	{
6027  		TiXmlElement *GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6028  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("commandLineInterpreter"));
6029  		GUIConfigElement->InsertEndChild(TiXmlText(_nppGUI._commandLineInterpreter.c_str()));
6030  	}
6031  	{
6032  		TiXmlElement* GUIConfigElement = (newGUIRoot->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6033  		GUIConfigElement->SetAttribute(TEXT("name"), TEXT("DarkMode"));
6034  		NppDarkMode::setAdvancedOptions();
6035  		auto setYesNoBoolAttribute = [&GUIConfigElement](const TCHAR* name, bool value) {
6036  			const TCHAR* pStr = value ? TEXT("yes") : TEXT("no");
6037  			GUIConfigElement->SetAttribute(name, pStr);
6038  		};
6039  		setYesNoBoolAttribute(TEXT("enable"), _nppGUI._darkmode._isEnabled);
6040  		GUIConfigElement->SetAttribute(TEXT("colorTone"), _nppGUI._darkmode._colorTone);
6041  		GUIConfigElement->SetAttribute(TEXT("customColorTop"), _nppGUI._darkmode._customColors.pureBackground);
6042  		GUIConfigElement->SetAttribute(TEXT("customColorMenuHotTrack"), _nppGUI._darkmode._customColors.hotBackground);
6043  		GUIConfigElement->SetAttribute(TEXT("customColorActive"), _nppGUI._darkmode._customColors.softerBackground);
6044  		GUIConfigElement->SetAttribute(TEXT("customColorMain"), _nppGUI._darkmode._customColors.background);
6045  		GUIConfigElement->SetAttribute(TEXT("customColorError"), _nppGUI._darkmode._customColors.errorBackground);
6046  		GUIConfigElement->SetAttribute(TEXT("customColorText"), _nppGUI._darkmode._customColors.text);
6047  		GUIConfigElement->SetAttribute(TEXT("customColorDarkText"), _nppGUI._darkmode._customColors.darkerText);
6048  		GUIConfigElement->SetAttribute(TEXT("customColorDisabledText"), _nppGUI._darkmode._customColors.disabledText);
6049  		GUIConfigElement->SetAttribute(TEXT("customColorLinkText"), _nppGUI._darkmode._customColors.linkText);
6050  		GUIConfigElement->SetAttribute(TEXT("customColorEdge"), _nppGUI._darkmode._customColors.edge);
6051  		GUIConfigElement->SetAttribute(TEXT("customColorHotEdge"), _nppGUI._darkmode._customColors.hotEdge);
6052  		GUIConfigElement->SetAttribute(TEXT("customColorDisabledEdge"), _nppGUI._darkmode._customColors.disabledEdge);
6053  		setYesNoBoolAttribute(TEXT("enableWindowsMode"), _nppGUI._darkmode._advOptions._enableWindowsMode);
6054  		GUIConfigElement->SetAttribute(TEXT("darkThemeName"), _nppGUI._darkmode._advOptions._darkDefaults._xmlFileName.c_str());
6055  		GUIConfigElement->SetAttribute(TEXT("darkToolBarIconSet"), _nppGUI._darkmode._advOptions._darkDefaults._toolBarIconSet);
6056  		GUIConfigElement->SetAttribute(TEXT("darkTabIconSet"), _nppGUI._darkmode._advOptions._darkDefaults._tabIconSet);
6057  		setYesNoBoolAttribute(TEXT("darkTabUseTheme"), _nppGUI._darkmode._advOptions._darkDefaults._tabUseTheme);
6058  		GUIConfigElement->SetAttribute(TEXT("lightThemeName"), _nppGUI._darkmode._advOptions._lightDefaults._xmlFileName.c_str());
6059  		GUIConfigElement->SetAttribute(TEXT("lightToolBarIconSet"), _nppGUI._darkmode._advOptions._lightDefaults._toolBarIconSet);
6060  		GUIConfigElement->SetAttribute(TEXT("lightTabIconSet"), _nppGUI._darkmode._advOptions._lightDefaults._tabIconSet);
6061  		setYesNoBoolAttribute(TEXT("lightTabUseTheme"), _nppGUI._darkmode._advOptions._lightDefaults._tabUseTheme);
6062  	}
6063  	writeScintillaParams();
6064  	if (_nppGUI._isCmdlineNosessionActivated && dockMngNodeDup)
6065  	{
6066  		newGUIRoot->InsertEndChild(*dockMngNodeDup);
6067  		delete dockMngNodeDup;
6068  	}
6069  	else
6070  	{
6071  		insertDockingParamNode(newGUIRoot);
6072  	}
6073  }
6074  bool NppParameters::writeFindHistory()
6075  {
6076  	if (!_pXmlUserDoc) return false;
6077  	TiXmlNode *nppRoot = _pXmlUserDoc->FirstChild(TEXT("NotepadPlus"));
6078  	if (!nppRoot)
6079  	{
6080  		nppRoot = _pXmlUserDoc->InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
6081  	}
6082  	TiXmlNode *findHistoryRoot = nppRoot->FirstChildElement(TEXT("FindHistory"));
6083  	if (!findHistoryRoot)
6084  	{
6085  		TiXmlElement element(TEXT("FindHistory"));
6086  		findHistoryRoot = nppRoot->InsertEndChild(element);
6087  	}
6088  	findHistoryRoot->Clear();
6089  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryPath"),	_findHistory._nbMaxFindHistoryPath);
6090  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryFilter"),  _findHistory._nbMaxFindHistoryFilter);
6091  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryFind"),	_findHistory._nbMaxFindHistoryFind);
6092  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("nbMaxFindHistoryReplace"), _findHistory._nbMaxFindHistoryReplace);
6093  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("matchWord"),				_findHistory._isMatchWord?TEXT("yes"):TEXT("no"));
6094  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("matchCase"),				_findHistory._isMatchCase?TEXT("yes"):TEXT("no"));
6095  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("wrap"),					_findHistory._isWrap?TEXT("yes"):TEXT("no"));
6096  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("directionDown"),			_findHistory._isDirectionDown?TEXT("yes"):TEXT("no"));
6097  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifRecuisive"),			_findHistory._isFifRecuisive?TEXT("yes"):TEXT("no"));
6098  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifInHiddenFolder"),		_findHistory._isFifInHiddenFolder?TEXT("yes"):TEXT("no"));
6099  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel1"),	    	_findHistory._isFifProjectPanel_1?TEXT("yes"):TEXT("no"));
6100  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel2"),	      	_findHistory._isFifProjectPanel_2?TEXT("yes"):TEXT("no"));
6101  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifProjectPanel3"),	       	_findHistory._isFifProjectPanel_3?TEXT("yes"):TEXT("no"));
6102  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifFilterFollowsDoc"),	_findHistory._isFilterFollowDoc?TEXT("yes"):TEXT("no"));
6103  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("fifFolderFollowsDoc"),	_findHistory._isFolderFollowDoc?TEXT("yes"):TEXT("no"));
6104  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("searchMode"), _findHistory._searchMode);
6105  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("transparencyMode"), _findHistory._transparencyMode);
6106  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("transparency"), _findHistory._transparency);
6107  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("dotMatchesNewline"),		_findHistory._dotMatchesNewline?TEXT("yes"):TEXT("no"));
6108  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("isSearch2ButtonsMode"),		_findHistory._isSearch2ButtonsMode?TEXT("yes"):TEXT("no"));
6109  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("regexBackward4PowerUser"),		_findHistory._regexBackward4PowerUser ? TEXT("yes") : TEXT("no"));
6110  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("bookmarkLine"), _findHistory._isBookmarkLine ? TEXT("yes") : TEXT("no"));
6111  	(findHistoryRoot->ToElement())->SetAttribute(TEXT("purge"), _findHistory._isPurge ? TEXT("yes") : TEXT("no"));
6112  	TiXmlElement hist_element{TEXT("")};
6113  	hist_element.SetValue(TEXT("Path"));
6114  	for (size_t i = 0, len = _findHistory._findHistoryPaths.size(); i < len; ++i)
6115  	{
6116  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryPaths[i].c_str());
6117  		findHistoryRoot->InsertEndChild(hist_element);
6118  	}
6119  	hist_element.SetValue(TEXT("Filter"));
6120  	for (size_t i = 0, len = _findHistory._findHistoryFilters.size(); i < len; ++i)
6121  	{
6122  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryFilters[i].c_str());
6123  		findHistoryRoot->InsertEndChild(hist_element);
6124  	}
6125  	hist_element.SetValue(TEXT("Find"));
6126  	for (size_t i = 0, len = _findHistory._findHistoryFinds.size(); i < len; ++i)
6127  	{
6128  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryFinds[i].c_str());
6129  		findHistoryRoot->InsertEndChild(hist_element);
6130  	}
6131  	hist_element.SetValue(TEXT("Replace"));
6132  	for (size_t i = 0, len = _findHistory._findHistoryReplaces.size(); i < len; ++i)
6133  	{
6134  		(hist_element.ToElement())->SetAttribute(TEXT("name"), _findHistory._findHistoryReplaces[i].c_str());
6135  		findHistoryRoot->InsertEndChild(hist_element);
6136  	}
6137  	return true;
6138  }
6139  void NppParameters::insertDockingParamNode(TiXmlNode *GUIRoot)
6140  {
6141  	TiXmlElement DMNode(TEXT("GUIConfig"));
6142  	DMNode.SetAttribute(TEXT("name"), TEXT("DockingManager"));
6143  	DMNode.SetAttribute(TEXT("leftWidth"), _nppGUI._dockingData._leftWidth);
6144  	DMNode.SetAttribute(TEXT("rightWidth"), _nppGUI._dockingData._rightWidth);
6145  	DMNode.SetAttribute(TEXT("topHeight"), _nppGUI._dockingData._topHeight);
6146  	DMNode.SetAttribute(TEXT("bottomHeight"), _nppGUI._dockingData._bottomHight);
6147  	for (size_t i = 0, len = _nppGUI._dockingData._flaotingWindowInfo.size(); i < len ; ++i)
6148  	{
6149  		FloatingWindowInfo & fwi = _nppGUI._dockingData._flaotingWindowInfo[i];
6150  		TiXmlElement FWNode(TEXT("FloatingWindow"));
6151  		FWNode.SetAttribute(TEXT("cont"), fwi._cont);
6152  		FWNode.SetAttribute(TEXT("x"), fwi._pos.left);
6153  		FWNode.SetAttribute(TEXT("y"), fwi._pos.top);
6154  		FWNode.SetAttribute(TEXT("width"), fwi._pos.right);
6155  		FWNode.SetAttribute(TEXT("height"), fwi._pos.bottom);
6156  		DMNode.InsertEndChild(FWNode);
6157  	}
6158  	for (size_t i = 0, len = _nppGUI._dockingData._pluginDockInfo.size() ; i < len ; ++i)
6159  	{
6160  		PluginDlgDockingInfo & pdi = _nppGUI._dockingData._pluginDockInfo[i];
6161  		TiXmlElement PDNode(TEXT("PluginDlg"));
6162  		PDNode.SetAttribute(TEXT("pluginName"), pdi._name);
6163  		PDNode.SetAttribute(TEXT("id"), pdi._internalID);
6164  		PDNode.SetAttribute(TEXT("curr"), pdi._currContainer);
6165  		PDNode.SetAttribute(TEXT("prev"), pdi._prevContainer);
6166  		PDNode.SetAttribute(TEXT("isVisible"), pdi._isVisible?TEXT("yes"):TEXT("no"));
6167  		DMNode.InsertEndChild(PDNode);
6168  	}
6169  	for (size_t i = 0, len = _nppGUI._dockingData._containerTabInfo.size(); i < len ; ++i)
6170  	{
6171  		ContainerTabInfo & cti = _nppGUI._dockingData._containerTabInfo[i];
6172  		TiXmlElement CTNode(TEXT("ActiveTabs"));
6173  		CTNode.SetAttribute(TEXT("cont"), cti._cont);
6174  		CTNode.SetAttribute(TEXT("activeTab"), cti._activeTab);
6175  		DMNode.InsertEndChild(CTNode);
6176  	}
6177  	GUIRoot->InsertEndChild(DMNode);
6178  }
6179  void NppParameters::writePrintSetting(TiXmlElement *element)
6180  {
6181  	const TCHAR *pStr = _nppGUI._printSettings._printLineNumber?TEXT("yes"):TEXT("no");
6182  	element->SetAttribute(TEXT("lineNumber"), pStr);
6183  	element->SetAttribute(TEXT("printOption"), _nppGUI._printSettings._printOption);
6184  	element->SetAttribute(TEXT("headerLeft"), _nppGUI._printSettings._headerLeft.c_str());
6185  	element->SetAttribute(TEXT("headerMiddle"), _nppGUI._printSettings._headerMiddle.c_str());
6186  	element->SetAttribute(TEXT("headerRight"), _nppGUI._printSettings._headerRight.c_str());
6187  	element->SetAttribute(TEXT("footerLeft"), _nppGUI._printSettings._footerLeft.c_str());
6188  	element->SetAttribute(TEXT("footerMiddle"), _nppGUI._printSettings._footerMiddle.c_str());
6189  	element->SetAttribute(TEXT("footerRight"), _nppGUI._printSettings._footerRight.c_str());
6190  	element->SetAttribute(TEXT("headerFontName"), _nppGUI._printSettings._headerFontName.c_str());
6191  	element->SetAttribute(TEXT("headerFontStyle"), _nppGUI._printSettings._headerFontStyle);
6192  	element->SetAttribute(TEXT("headerFontSize"), _nppGUI._printSettings._headerFontSize);
6193  	element->SetAttribute(TEXT("footerFontName"), _nppGUI._printSettings._footerFontName.c_str());
6194  	element->SetAttribute(TEXT("footerFontStyle"), _nppGUI._printSettings._footerFontStyle);
6195  	element->SetAttribute(TEXT("footerFontSize"), _nppGUI._printSettings._footerFontSize);
6196  	element->SetAttribute(TEXT("margeLeft"), _nppGUI._printSettings._marge.left);
6197  	element->SetAttribute(TEXT("margeRight"), _nppGUI._printSettings._marge.right);
6198  	element->SetAttribute(TEXT("margeTop"), _nppGUI._printSettings._marge.top);
6199  	element->SetAttribute(TEXT("margeBottom"), _nppGUI._printSettings._marge.bottom);
6200  }
6201  void NppParameters::writeExcludedLangList(TiXmlElement *element)
6202  {
6203  	int g0 = 0; 
6204  	int g1 = 0; 
6205  	int g2 = 0; 
6206  	int g3 = 0; 
6207  	int g4 = 0; 
6208  	int g5 = 0; 
6209  	int g6 = 0; 
6210  	int g7 = 0; 
6211  	int g8 = 0; 
6212  	int g9 = 0; 
6213  	int g10= 0; 
6214  	int g11= 0; 
6215  	int g12= 0; 
6216  	const int groupNbMember = 8;
6217  	for (size_t i = 0, len = _nppGUI._excludedLangList.size(); i < len ; ++i)
6218  	{
6219  		LangType langType = _nppGUI._excludedLangList[i]._langType;
6220  		if (langType >= L_EXTERNAL && langType < L_END)
6221  			continue;
6222  		int nGrp = langType / groupNbMember;
6223  		int nMask = 1 << langType % groupNbMember;
6224  		switch (nGrp)
6225  		{
6226  			case 0 :
6227  				g0 |= nMask;
6228  				break;
6229  			case 1 :
6230  				g1 |= nMask;
6231  				break;
6232  			case 2 :
6233  				g2 |= nMask;
6234  				break;
6235  			case 3 :
6236  				g3 |= nMask;
6237  				break;
6238  			case 4 :
6239  				g4 |= nMask;
6240  				break;
6241  			case 5 :
6242  				g5 |= nMask;
6243  				break;
6244  			case 6 :
6245  				g6 |= nMask;
6246  				break;
6247  			case 7 :
6248  				g7 |= nMask;
6249  				break;
6250  			case 8:
6251  				g8 |= nMask;
6252  				break;
6253  			case 9:
6254  				g9 |= nMask;
6255  				break;
6256  			case 10:
6257  				g10 |= nMask;
6258  				break;
6259  			case 11:
6260  				g11 |= nMask;
6261  				break;
6262  			case 12:
6263  				g12 |= nMask;
6264  				break;
6265  		}
6266  	}
6267  	element->SetAttribute(TEXT("gr0"), g0);
6268  	element->SetAttribute(TEXT("gr1"), g1);
6269  	element->SetAttribute(TEXT("gr2"), g2);
6270  	element->SetAttribute(TEXT("gr3"), g3);
6271  	element->SetAttribute(TEXT("gr4"), g4);
6272  	element->SetAttribute(TEXT("gr5"), g5);
6273  	element->SetAttribute(TEXT("gr6"), g6);
6274  	element->SetAttribute(TEXT("gr7"), g7);
6275  	element->SetAttribute(TEXT("gr8"), g8);
6276  	element->SetAttribute(TEXT("gr9"), g9);
6277  	element->SetAttribute(TEXT("gr10"), g10);
6278  	element->SetAttribute(TEXT("gr11"), g11);
6279  	element->SetAttribute(TEXT("gr12"), g12);
6280  }
6281  TiXmlElement * NppParameters::insertGUIConfigBoolNode(TiXmlNode *r2w, const TCHAR *name, bool bVal)
6282  {
6283  	const TCHAR *pStr = bVal?TEXT("yes"):TEXT("no");
6284  	TiXmlElement *GUIConfigElement = (r2w->InsertEndChild(TiXmlElement(TEXT("GUIConfig"))))->ToElement();
6285  	GUIConfigElement->SetAttribute(TEXT("name"), name);
6286  	GUIConfigElement->InsertEndChild(TiXmlText(pStr));
6287  	return GUIConfigElement;
6288  }
6289  int RGB2int(COLORREF color)
6290  {
6291  	return (((((DWORD)color) & 0x0000FF) << 16) | ((((DWORD)color) & 0x00FF00)) | ((((DWORD)color) & 0xFF0000) >> 16));
6292  }
6293  int NppParameters::langTypeToCommandID(LangType lt) const
6294  {
6295  	int id;
6296  	switch (lt)
6297  	{
6298  		case L_C :
6299  			id = IDM_LANG_C; break;
6300  		case L_CPP :
6301  			id = IDM_LANG_CPP; break;
6302  		case L_JAVA :
6303  			id = IDM_LANG_JAVA;	break;
6304  		case L_CS :
6305  			id = IDM_LANG_CS; break;
6306  		case L_OBJC :
6307  			id = IDM_LANG_OBJC;	break;
6308  		case L_HTML :
6309  			id = IDM_LANG_HTML;	break;
6310  		case L_XML :
6311  			id = IDM_LANG_XML; break;
6312  		case L_JS :
6313  		case L_JAVASCRIPT:
6314  			id = IDM_LANG_JS; break;
6315  		case L_JSON:
6316  			id = IDM_LANG_JSON; break;
6317  		case L_JSON5:
6318  			id = IDM_LANG_JSON5; break;
6319  		case L_PHP :
6320  			id = IDM_LANG_PHP; break;
6321  		case L_ASP :
6322  			id = IDM_LANG_ASP; break;
6323  		case L_JSP :
6324  			id = IDM_LANG_JSP; break;
6325  		case L_CSS :
6326  			id = IDM_LANG_CSS; break;
6327  		case L_LUA :
6328  			id = IDM_LANG_LUA; break;
6329  		case L_PERL :
6330  			id = IDM_LANG_PERL; break;
6331  		case L_PYTHON :
6332  			id = IDM_LANG_PYTHON; break;
6333  		case L_BATCH :
6334  			id = IDM_LANG_BATCH; break;
6335  		case L_PASCAL :
6336  			id = IDM_LANG_PASCAL; break;
6337  		case L_MAKEFILE :
6338  			id = IDM_LANG_MAKEFILE;	break;
6339  		case L_INI :
6340  			id = IDM_LANG_INI; break;
6341  		case L_ASCII :
6342  			id = IDM_LANG_ASCII; break;
6343  		case L_RC :
6344  			id = IDM_LANG_RC; break;
6345  		case L_TEX :
6346  			id = IDM_LANG_TEX; break;
6347  		case L_FORTRAN :
6348  			id = IDM_LANG_FORTRAN; break;
6349  		case L_FORTRAN_77 :
6350  			id = IDM_LANG_FORTRAN_77; break;
6351  		case L_BASH :
6352  			id = IDM_LANG_BASH; break;
6353  		case L_FLASH :
6354  			id = IDM_LANG_FLASH; break;
6355  		case L_NSIS :
6356  			id = IDM_LANG_NSIS; break;
6357  		case L_USER :
6358  			id = IDM_LANG_USER; break;
6359  		case L_SQL :
6360  			id = IDM_LANG_SQL; break;
6361  		case L_MSSQL :
6362  			id = IDM_LANG_MSSQL; break;
6363  		case L_VB :
6364  			id = IDM_LANG_VB; break;
6365  		case L_TCL :
6366  			id = IDM_LANG_TCL; break;
6367  		case L_LISP :
6368  			id = IDM_LANG_LISP; break;
6369  		case L_SCHEME :
6370  			id = IDM_LANG_SCHEME; break;
6371  		case L_ASM :
6372  			id = IDM_LANG_ASM; break;
6373  		case L_DIFF :
6374  			id = IDM_LANG_DIFF; break;
6375  		case L_PROPS :
6376  			id = IDM_LANG_PROPS; break;
6377  		case L_PS :
6378  			id = IDM_LANG_PS; break;
6379  		case L_RUBY :
6380  			id = IDM_LANG_RUBY; break;
6381  		case L_SMALLTALK :
6382  			id = IDM_LANG_SMALLTALK; break;
6383  		case L_VHDL :
6384  			id = IDM_LANG_VHDL; break;
6385  		case L_ADA :
6386  			id = IDM_LANG_ADA; break;
6387  		case L_MATLAB :
6388  			id = IDM_LANG_MATLAB; break;
6389  		case L_HASKELL :
6390  			id = IDM_LANG_HASKELL; break;
6391  		case L_KIX :
6392  			id = IDM_LANG_KIX; break;
6393  		case L_AU3 :
6394  			id = IDM_LANG_AU3; break;
6395  		case L_VERILOG :
6396  			id = IDM_LANG_VERILOG; break;
6397  		case L_CAML :
6398  			id = IDM_LANG_CAML; break;
6399  		case L_INNO :
6400  			id = IDM_LANG_INNO; break;
6401  		case L_CMAKE :
6402  			id = IDM_LANG_CMAKE; break;
6403  		case L_YAML :
6404  			id = IDM_LANG_YAML; break;
6405  		case L_COBOL :
6406  			id = IDM_LANG_COBOL; break;
6407  		case L_D :
6408  			id = IDM_LANG_D; break;
6409  		case L_GUI4CLI :
6410  			id = IDM_LANG_GUI4CLI; break;
6411  		case L_POWERSHELL :
6412  			id = IDM_LANG_POWERSHELL; break;
6413  		case L_R :
6414  			id = IDM_LANG_R; break;
6415  		case L_COFFEESCRIPT :
6416  			id = IDM_LANG_COFFEESCRIPT; break;
6417  		case L_BAANC:
6418  			id = IDM_LANG_BAANC; break;
6419  		case L_SREC :
6420  			id = IDM_LANG_SREC; break;
6421  		case L_IHEX :
6422  			id = IDM_LANG_IHEX; break;
6423  		case L_TEHEX :
6424  			id = IDM_LANG_TEHEX; break;
6425  		case L_SWIFT:
6426  			id = IDM_LANG_SWIFT; break;
6427  		case L_ASN1 :
6428  			id = IDM_LANG_ASN1; break;
6429          case L_AVS :
6430  			id = IDM_LANG_AVS; break;
6431  		case L_BLITZBASIC :
6432  			id = IDM_LANG_BLITZBASIC; break;
6433  		case L_PUREBASIC :
6434  			id = IDM_LANG_PUREBASIC; break;
6435  		case L_FREEBASIC :
6436  			id = IDM_LANG_FREEBASIC; break;
6437  		case L_CSOUND :
6438  			id = IDM_LANG_CSOUND; break;
6439  		case L_ERLANG :
6440  			id = IDM_LANG_ERLANG; break;
6441  		case L_ESCRIPT :
6442  			id = IDM_LANG_ESCRIPT; break;
6443  		case L_FORTH :
6444  			id = IDM_LANG_FORTH; break;
6445  		case L_LATEX :
6446  			id = IDM_LANG_LATEX; break;
6447  		case L_MMIXAL :
6448  			id = IDM_LANG_MMIXAL; break;
6449  		case L_NIM :
6450  			id = IDM_LANG_NIM; break;
6451  		case L_NNCRONTAB :
6452  			id = IDM_LANG_NNCRONTAB; break;
6453  		case L_OSCRIPT :
6454  			id = IDM_LANG_OSCRIPT; break;
6455  		case L_REBOL :
6456  			id = IDM_LANG_REBOL; break;
6457  		case L_REGISTRY :
6458  			id = IDM_LANG_REGISTRY; break;
6459  		case L_RUST :
6460  			id = IDM_LANG_RUST; break;
6461  		case L_SPICE :
6462  			id = IDM_LANG_SPICE; break;
6463  		case L_TXT2TAGS :
6464  			id = IDM_LANG_TXT2TAGS; break;
6465  		case L_VISUALPROLOG:
6466  			id = IDM_LANG_VISUALPROLOG; break;
6467  		case L_TYPESCRIPT:
6468  			id = IDM_LANG_TYPESCRIPT; break;
6469  		case L_GDSCRIPT:
6470  			id = IDM_LANG_GDSCRIPT; break;
6471  		case L_HOLLYWOOD:
6472  			id = IDM_LANG_HOLLYWOOD; break;
6473  		case L_SEARCHRESULT :
6474  			id = -1;	break;
6475  		case L_TEXT :
6476  			id = IDM_LANG_TEXT;	break;
6477  		default :
6478  			if (lt >= L_EXTERNAL && lt < L_END)
6479  				id = lt - L_EXTERNAL + IDM_LANG_EXTERNAL;
6480  			else
6481  				id = IDM_LANG_TEXT;
6482  	}
6483  	return id;
6484  }
6485  generic_string NppParameters:: getWinVersionStr() const
6486  {
6487  	switch (_winVersion)
6488  	{
6489  		case WV_WIN32S: return TEXT("Windows 3.1");
6490  		case WV_95: return TEXT("Windows 95");
6491  		case WV_98: return TEXT("Windows 98");
6492  		case WV_ME: return TEXT("Windows Millennium Edition");
6493  		case WV_NT: return TEXT("Windows NT");
6494  		case WV_W2K: return TEXT("Windows 2000");
6495  		case WV_XP: return TEXT("Windows XP");
6496  		case WV_S2003: return TEXT("Windows Server 2003");
6497  		case WV_XPX64: return TEXT("Windows XP 64 bits");
6498  		case WV_VISTA: return TEXT("Windows Vista");
6499  		case WV_WIN7: return TEXT("Windows 7");
6500  		case WV_WIN8: return TEXT("Windows 8");
6501  		case WV_WIN81: return TEXT("Windows 8.1");
6502  		case WV_WIN10: return TEXT("Windows 10");
6503  		case WV_WIN11: return TEXT("Windows 11");
6504  		default: &bsol;*case WV_UNKNOWN:*/ return TEXT("Windows unknown version");
6505  	}
6506  }
6507  generic_string NppParameters::getWinVerBitStr() const
6508  {
6509  	switch (_platForm)
6510  	{
6511  	case PF_X86:
6512  		return TEXT("32-bit");
6513  	case PF_X64:
6514  	case PF_IA64:
6515  	case PF_ARM64:
6516  		return TEXT("64-bit");
6517  	default:
6518  		return TEXT("Unknown-bit");
6519  	}
6520  }
6521  generic_string NppParameters::writeStyles(LexerStylerArray & lexersStylers, StyleArray & globalStylers)
6522  {
6523  	TiXmlNode *lexersRoot = (_pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("LexerStyles"));
6524  	for (TiXmlNode *childNode = lexersRoot->FirstChildElement(TEXT("LexerType"));
6525  		childNode ;
6526  		childNode = childNode->NextSibling(TEXT("LexerType")))
6527  	{
6528  		TiXmlElement *element = childNode->ToElement();
6529  		const TCHAR *nm = element->Attribute(TEXT("name"));
6530  		LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6531  		LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6532  		if (pLs)
6533  		{
6534  			const TCHAR *extStr = pLs->getLexerUserExt();
6535  			element->SetAttribute(TEXT("ext"), extStr);
6536  			for (TiXmlNode *grChildNode = childNode->FirstChildElement(TEXT("WordsStyle"));
6537  					grChildNode ;
6538  					grChildNode = grChildNode->NextSibling(TEXT("WordsStyle")))
6539  			{
6540  				TiXmlElement *grElement = grChildNode->ToElement();
6541  				const TCHAR *styleName = grElement->Attribute(TEXT("name"));
6542  				const Style * pStyle = pLs->findByName(styleName);
6543  				Style * pStyle2Sync = pLs2 ? pLs2->findByName(styleName) : nullptr;
6544  				if (pStyle && pStyle2Sync)
6545  				{
6546  					writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6547  				}
6548  			}
6549  		}
6550  	}
6551  	for (size_t x = 0; x < _pXmlExternalLexerDoc.size(); ++x)
6552  	{
6553  		TiXmlNode* lexersRoot2 = ( _pXmlExternalLexerDoc[x]->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("LexerStyles"));
6554  		for (TiXmlNode* childNode = lexersRoot2->FirstChildElement(TEXT("LexerType"));
6555  			childNode ;
6556  			childNode = childNode->NextSibling(TEXT("LexerType")))
6557  		{
6558  			TiXmlElement *element = childNode->ToElement();
6559  			const TCHAR *nm = element->Attribute(TEXT("name"));
6560  			LexerStyler *pLs = _lexerStylerVect.getLexerStylerByName(nm);
6561  			LexerStyler *pLs2 = lexersStylers.getLexerStylerByName(nm);
6562  			if (pLs)
6563  			{
6564  				const TCHAR *extStr = pLs->getLexerUserExt();
6565  				element->SetAttribute(TEXT("ext"), extStr);
6566  				for (TiXmlNode *grChildNode = childNode->FirstChildElement(TEXT("WordsStyle"));
6567  						grChildNode ;
6568  						grChildNode = grChildNode->NextSibling(TEXT("WordsStyle")))
6569  				{
6570  					TiXmlElement *grElement = grChildNode->ToElement();
6571  					const TCHAR *styleName = grElement->Attribute(TEXT("name"));
6572  					const Style * pStyle = pLs->findByName(styleName);
6573  					Style * pStyle2Sync = pLs2 ? pLs2->findByName(styleName) : nullptr;
6574  					if (pStyle && pStyle2Sync)
6575  					{
6576  						writeStyle2Element(*pStyle, *pStyle2Sync, grElement);
6577  					}
6578  				}
6579  			}
6580  		}
6581  		_pXmlExternalLexerDoc[x]->SaveFile();
6582  	}
6583  	TiXmlNode *globalStylesRoot = (_pXmlUserStylerDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("GlobalStyles"));
6584  	for (TiXmlNode *childNode = globalStylesRoot->FirstChildElement(TEXT("WidgetStyle"));
6585  		childNode ;
6586  		childNode = childNode->NextSibling(TEXT("WidgetStyle")))
6587  	{
6588  		TiXmlElement *pElement = childNode->ToElement();
6589  		const TCHAR *styleName = pElement->Attribute(TEXT("name"));
6590  		const Style * pStyle = _widgetStyleArray.findByName(styleName);
6591  		Style * pStyle2Sync = globalStylers.findByName(styleName);
6592  		if (pStyle && pStyle2Sync)
6593  		{
6594  			writeStyle2Element(*pStyle, *pStyle2Sync, pElement);
6595  		}
6596  	}
6597  	bool isSaved = _pXmlUserStylerDoc->SaveFile();
6598  	if (!isSaved)
6599  	{
6600  		auto savePath = _themeSwitcher.getSavePathFrom(_pXmlUserStylerDoc->Value());
6601  		if (!savePath.empty())
6602  		{
6603  			_pXmlUserStylerDoc->SaveFile(savePath.c_str());
6604  			return savePath;
6605  		}
6606  	}
6607  	return TEXT("");
6608  }
6609  bool NppParameters::insertTabInfo(const TCHAR *langName, int tabInfo)
6610  {
6611  	if (!_pXmlDoc) return false;
6612  	TiXmlNode *langRoot = (_pXmlDoc->FirstChild(TEXT("NotepadPlus")))->FirstChildElement(TEXT("Languages"));
6613  	for (TiXmlNode *childNode = langRoot->FirstChildElement(TEXT("Language"));
6614  		childNode ;
6615  		childNode = childNode->NextSibling(TEXT("Language")))
6616  	{
6617  		TiXmlElement *element = childNode->ToElement();
6618  		const TCHAR *nm = element->Attribute(TEXT("name"));
6619  		if (nm && lstrcmp(langName, nm) == 0)
6620  		{
6621  			childNode->ToElement()->SetAttribute(TEXT("tabSettings"), tabInfo);
6622  			_pXmlDoc->SaveFile();
6623  			return true;
6624  		}
6625  	}
6626  	return false;
6627  }
6628  void NppParameters::writeStyle2Element(const Style & style2Write, Style & style2Sync, TiXmlElement *element)
6629  {
6630  	if (HIBYTE(HIWORD(style2Write._fgColor)) != 0xFF)
6631  	{
6632  		int rgbVal = RGB2int(style2Write._fgColor);
6633  		TCHAR fgStr[7];
6634  		wsprintf(fgStr, TEXT("%.6X"), rgbVal);
6635  		element->SetAttribute(TEXT("fgColor"), fgStr);
6636  	}
6637  	if (HIBYTE(HIWORD(style2Write._bgColor)) != 0xFF)
6638  	{
6639  		int rgbVal = RGB2int(style2Write._bgColor);
6640  		TCHAR bgStr[7];
6641  		wsprintf(bgStr, TEXT("%.6X"), rgbVal);
6642  		element->SetAttribute(TEXT("bgColor"), bgStr);
6643  	}
6644  	if (style2Write._colorStyle != COLORSTYLE_ALL)
6645  	{
6646  		element->SetAttribute(TEXT("colorStyle"), style2Write._colorStyle);
6647  	}
6648  	if (!style2Write._fontName.empty())
6649  	{
6650  		const TCHAR * oldFontName = element->Attribute(TEXT("fontName"));
6651  		if (oldFontName && oldFontName != style2Write._fontName)
6652  		{
6653  			element->SetAttribute(TEXT("fontName"), style2Write._fontName);
6654  			style2Sync._fontName = style2Write._fontName;
6655  		}
6656  	}
6657  	if (style2Write._fontSize != STYLE_NOT_USED)
6658  	{
6659  		if (!style2Write._fontSize)
6660  			element->SetAttribute(TEXT("fontSize"), TEXT(""));
6661  		else
6662  			element->SetAttribute(TEXT("fontSize"), style2Write._fontSize);
6663  	}
6664  	if (style2Write._fontStyle != STYLE_NOT_USED)
6665  	{
6666  		element->SetAttribute(TEXT("fontStyle"), style2Write._fontStyle);
6667  	}
6668  	if (!style2Write._keywords.empty())
6669  	{
6670  		TiXmlNode *teteDeNoeud = element->LastChild();
6671  		if (teteDeNoeud)
6672  			teteDeNoeud->SetValue(style2Write._keywords.c_str());
6673  		else
6674  			element->InsertEndChild(TiXmlText(style2Write._keywords.c_str()));
6675  	}
6676  }
6677  void NppParameters::insertUserLang2Tree(TiXmlNode *node, UserLangContainer *userLang)
6678  {
6679  	TiXmlElement *rootElement = (node->InsertEndChild(TiXmlElement(TEXT("UserLang"))))->ToElement();
6680  	TCHAR temp[32];
6681  	generic_string udlVersion;
6682  	udlVersion += _itow(SCE_UDL_VERSION_MAJOR, temp, 10);
6683  	udlVersion += TEXT(".");
6684  	udlVersion += _itow(SCE_UDL_VERSION_MINOR, temp, 10);
6685  	rootElement->SetAttribute(TEXT("name"), userLang->_name);
6686  	rootElement->SetAttribute(TEXT("ext"), userLang->_ext);
6687  	if (userLang->_isDarkModeTheme)
6688  		rootElement->SetAttribute(TEXT("darkModeTheme"), TEXT("yes"));
6689  	rootElement->SetAttribute(TEXT("udlVersion"), udlVersion.c_str());
6690  	TiXmlElement *settingsElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("Settings"))))->ToElement();
6691  	{
6692  		TiXmlElement *globalElement = (settingsElement->InsertEndChild(TiXmlElement(TEXT("Global"))))->ToElement();
6693  		globalElement->SetAttribute(TEXT("caseIgnored"),			userLang->_isCaseIgnored ? TEXT("yes"):TEXT("no"));
6694  		globalElement->SetAttribute(TEXT("allowFoldOfComments"),	userLang->_allowFoldOfComments ? TEXT("yes"):TEXT("no"));
6695  		globalElement->SetAttribute(TEXT("foldCompact"),			userLang->_foldCompact ? TEXT("yes"):TEXT("no"));
6696  		globalElement->SetAttribute(TEXT("forcePureLC"),			userLang->_forcePureLC);
6697  		globalElement->SetAttribute(TEXT("decimalSeparator"),	   userLang->_decimalSeparator);
6698  		TiXmlElement *prefixElement = (settingsElement->InsertEndChild(TiXmlElement(TEXT("Prefix"))))->ToElement();
6699  		for (int i = 0 ; i < SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
6700  			prefixElement->SetAttribute(globalMappper().keywordNameMapper[i+SCE_USER_KWLIST_KEYWORDS1], userLang->_isPrefix[i]?TEXT("yes"):TEXT("no"));
6701  	}
6702  	TiXmlElement *kwlElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("KeywordLists"))))->ToElement();
6703  	for (int i = 0 ; i < SCE_USER_KWLIST_TOTAL ; ++i)
6704  	{
6705  		TiXmlElement *kwElement = (kwlElement->InsertEndChild(TiXmlElement(TEXT("Keywords"))))->ToElement();
6706  		kwElement->SetAttribute(TEXT("name"), globalMappper().keywordNameMapper[i]);
6707  		kwElement->InsertEndChild(TiXmlText(userLang->_keywordLists[i]));
6708  	}
6709  	TiXmlElement *styleRootElement = (rootElement->InsertEndChild(TiXmlElement(TEXT("Styles"))))->ToElement();
6710  	for (const Style & style2Write : userLang->_styles)
6711  	{
6712  		TiXmlElement *styleElement = (styleRootElement->InsertEndChild(TiXmlElement(TEXT("WordsStyle"))))->ToElement();
6713  		if (style2Write._styleID == -1)
6714  			continue;
6715  		styleElement->SetAttribute(TEXT("name"), style2Write._styleDesc);
6716  		{
6717  			int rgbVal = RGB2int(style2Write._fgColor);
6718  			TCHAR fgStr[7];
6719  			wsprintf(fgStr, TEXT("%.6X"), rgbVal);
6720  			styleElement->SetAttribute(TEXT("fgColor"), fgStr);
6721  		}
6722  		{
6723  			int rgbVal = RGB2int(style2Write._bgColor);
6724  			TCHAR bgStr[7];
6725  			wsprintf(bgStr, TEXT("%.6X"), rgbVal);
6726  			styleElement->SetAttribute(TEXT("bgColor"), bgStr);
6727  		}
6728  		if (style2Write._colorStyle != COLORSTYLE_ALL)
6729  		{
6730  			styleElement->SetAttribute(TEXT("colorStyle"), style2Write._colorStyle);
6731  		}
6732  		if (!style2Write._fontName.empty())
6733  		{
6734  			styleElement->SetAttribute(TEXT("fontName"), style2Write._fontName);
6735  		}
6736  		if (style2Write._fontStyle == STYLE_NOT_USED)
6737  		{
6738  			styleElement->SetAttribute(TEXT("fontStyle"), TEXT("0"));
6739  		}
6740  		else
6741  		{
6742  			styleElement->SetAttribute(TEXT("fontStyle"), style2Write._fontStyle);
6743  		}
6744  		if (style2Write._fontSize != STYLE_NOT_USED)
6745  		{
6746  			if (!style2Write._fontSize)
6747  				styleElement->SetAttribute(TEXT("fontSize"), TEXT(""));
6748  			else
6749  				styleElement->SetAttribute(TEXT("fontSize"), style2Write._fontSize);
6750  		}
6751  		styleElement->SetAttribute(TEXT("nesting"), style2Write._nesting);
6752  	}
6753  }
6754  void NppParameters::addUserModifiedIndex(size_t index)
6755  {
6756  	size_t len = _customizedShortcuts.size();
6757  	bool found = false;
6758  	for (size_t i = 0; i < len; ++i)
6759  	{
6760  		if (_customizedShortcuts[i] == index)
6761  		{
6762  			found = true;
6763  			break;
6764  		}
6765  	}
6766  	if (!found)
6767  	{
6768  		_customizedShortcuts.push_back(index);
6769  	}
6770  }
6771  void NppParameters::addPluginModifiedIndex(size_t index)
6772  {
6773  	size_t len = _pluginCustomizedCmds.size();
6774  	bool found = false;
6775  	for (size_t i = 0; i < len; ++i)
6776  	{
6777  		if (_pluginCustomizedCmds[i] == index)
6778  		{
6779  			found = true;
6780  			break;
6781  		}
6782  	}
6783  	if (!found)
6784  	{
6785  		_pluginCustomizedCmds.push_back(index);
6786  	}
6787  }
6788  void NppParameters::addScintillaModifiedIndex(int index)
6789  {
6790  	size_t len = _scintillaModifiedKeyIndices.size();
6791  	bool found = false;
6792  	for (size_t i = 0; i < len; ++i)
6793  	{
6794  		if (_scintillaModifiedKeyIndices[i] == index)
6795  		{
6796  			found = true;
6797  			break;
6798  		}
6799  	}
6800  	if (!found)
6801  	{
6802  		_scintillaModifiedKeyIndices.push_back(index);
6803  	}
6804  }
6805  void NppParameters::safeWow64EnableWow64FsRedirection(BOOL Wow64FsEnableRedirection)
6806  {
6807  	HMODULE kernel = GetModuleHandle(TEXT("kernel32"));
6808  	if (kernel)
6809  	{
6810  		BOOL isWow64 = FALSE;
6811  		typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
6812  		LPFN_ISWOW64PROCESS IsWow64ProcessFunc = (LPFN_ISWOW64PROCESS) GetProcAddress(kernel,"IsWow64Process");
6813  		if (IsWow64ProcessFunc)
6814  		{
6815  			IsWow64ProcessFunc(GetCurrentProcess(),&isWow64);
6816  			if (isWow64)
6817  			{
6818  				typedef BOOL (WINAPI *LPFN_WOW64ENABLEWOW64FSREDIRECTION)(BOOL);
6819  				LPFN_WOW64ENABLEWOW64FSREDIRECTION Wow64EnableWow64FsRedirectionFunc = (LPFN_WOW64ENABLEWOW64FSREDIRECTION)GetProcAddress(kernel, "Wow64EnableWow64FsRedirection");
6820  				if (Wow64EnableWow64FsRedirectionFunc)
6821  				{
6822  					Wow64EnableWow64FsRedirectionFunc(Wow64FsEnableRedirection);
6823  				}
6824  			}
6825  		}
6826  	}
6827  }
6828  void NppParameters::setUdlXmlDirtyFromIndex(size_t i)
6829  {
6830  	for (auto& uxfs : _pXmlUserLangsDoc)
6831  	{
6832  		if (i >= uxfs._indexRange.first && i < uxfs._indexRange.second)
6833  		{
6834  			uxfs._isDirty = true;
6835  			return;
6836  		}
6837  	}
6838  }
6839  void NppParameters::removeIndexFromXmlUdls(size_t i)
6840  {
6841  	bool isUpdateBegin = false;
6842  	for (auto& uxfs : _pXmlUserLangsDoc)
6843  	{
6844  		if (!isUpdateBegin && (i >= uxfs._indexRange.first && i < uxfs._indexRange.second)) 
6845  		{
6846  			if (uxfs._indexRange.second > 0)
6847  				uxfs._indexRange.second -= 1;
6848  			uxfs._isDirty = true;
6849  			isUpdateBegin = true;
6850  		}
6851  		else if (isUpdateBegin)
6852  		{
6853  			if (uxfs._indexRange.first > 0)
6854  				uxfs._indexRange.first -= 1;
6855  			if (uxfs._indexRange.second > 0)
6856  				uxfs._indexRange.second -= 1;
6857  		}
6858  	}
6859  }
6860  void NppParameters::setUdlXmlDirtyFromXmlDoc(const TiXmlDocument* xmlDoc)
6861  {
6862  	for (auto& uxfs : _pXmlUserLangsDoc)
6863  	{
6864  		if (xmlDoc == uxfs._udlXmlDoc)
6865  		{
6866  			uxfs._isDirty = true;
6867  			return;
6868  		}
6869  	}
6870  }
6871  Date::Date(const TCHAR *dateStr)
6872  {
6873  	assert(dateStr);
6874  	int D = lstrlen(dateStr);
6875  	if ( 8==D )
6876  	{
6877  		generic_string ds(dateStr);
6878  		generic_string yyyy(ds, 0, 4);
6879  		generic_string mm(ds, 4, 2);
6880  		generic_string dd(ds, 6, 2);
6881  		int y = _wtoi(yyyy.c_str());
6882  		int m = _wtoi(mm.c_str());
6883  		int d = _wtoi(dd.c_str());
6884  		if ((y > 0 && y <= 9999) && (m > 0 && m <= 12) && (d > 0 && d <= 31))
6885  		{
6886  			_year = y;
6887  			_month = m;
6888  			_day = d;
6889  			return;
6890  		}
6891  	}
6892  	now();
6893  }
6894  Date::Date(int nbDaysFromNow)
6895  {
6896  	const time_t oneDay = (60 * 60 * 24);
6897  	time_t rawtime;
6898  	tm* timeinfo;
6899  	time(&rawtime);
6900  	rawtime += (nbDaysFromNow * oneDay);
6901  	timeinfo = localtime(&rawtime);
6902  	if (timeinfo)
6903  	{
6904  		_year = timeinfo->tm_year + 1900;
6905  		_month = timeinfo->tm_mon + 1;
6906  		_day = timeinfo->tm_mday;
6907  	}
6908  }
6909  void Date::now()
6910  {
6911  	time_t rawtime;
6912  	tm* timeinfo;
6913  	time(&rawtime);
6914  	timeinfo = localtime(&rawtime);
6915  	if (timeinfo)
6916  	{
6917  		_year = timeinfo->tm_year + 1900;
6918  		_month = timeinfo->tm_mon + 1;
6919  		_day = timeinfo->tm_mday;
6920  	}
6921  }
6922  EolType convertIntToFormatType(int value, EolType defvalue)
6923  {
6924  	switch (value)
6925  	{
6926  		case static_cast<LPARAM>(EolType::windows) :
6927  			return EolType::windows;
6928  		case static_cast<LPARAM>(EolType::macos) :
6929  				return EolType::macos;
6930  		case static_cast<LPARAM>(EolType::unix) :
6931  			return EolType::unix;
6932  		default:
6933  			return defvalue;
6934  	}
6935  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.cpp</div>
                </div>
                <div class="column column_space"><pre><code>2774  	pluginCmdNode->ToElement()->SetAttribute("internalID", pluginCmd.getInternalID());
2775  	pluginCmdNode->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
</pre></code></div>
                <div class="column column_space"><pre><code>2724  	sc->ToElement()->SetAttribute("id", cmd.getID());
2725  	sc->ToElement()->SetAttribute("Ctrl", key._isCtrl?"yes":"no");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    