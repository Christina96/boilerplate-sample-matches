
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.252199413489736%, Tokens: 9</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_testing_helpers.h</h3>
            <pre><code>1  #ifndef ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_HELPERS_H_
2  #define ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_HELPERS_H_
3  #if (defined(__ANDROID__) || defined(ANDROID)) && !defined(OS_ANDROID)
4  #define ABSL_INTERNAL_OS_ANDROID
5  #endif
6  #if defined(OS_ANDROID) && (defined(__i386__) || defined(__x86_64__))
7  #define ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE 0
8  #elif (__GNUC__ >= 4 || (__GNUC__ >= 3 && __GNUC_MINOR__ >= 4)) && \
9      !defined(__mips__)
10  #define ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE 1
11  #elif defined(__clang__) && !defined(_MSC_VER)
12  #define ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE 1
13  #else
14  #define ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE 0
15  #endif
16  #include <tuple>
17  #include <type_traits>
18  #include <utility>
19  #include "absl/meta/type_traits.h"
20  #include "absl/strings/string_view.h"
21  #include "absl/utility/utility.h"
22  #if ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE
23  #include <cxxabi.h>
24  #include <cstdlib>
25  #endif
26  namespace absl {
27  ABSL_NAMESPACE_BEGIN
28  namespace types_internal {
29  template <class T>
30  absl::string_view NameOfImpl() {
31  #if ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE
32    int status = 0;
33    char* demangled_name = nullptr;
34    demangled_name =
35        abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, &status);
36    if (status == 0 && demangled_name != nullptr) {
37      return demangled_name;
38    } else {
39      return typeid(T).name();
40    }
41  #else
42    return typeid(T).name();
43  #endif
44  }
45  template <class T>
46  std::string NameOf() {
47    static const absl::string_view result = NameOfImpl<T>();
48    return std::string(result);
49  }
50  template <class Fun, class &bsol;*Enabler*/ = void>
51  struct IsNullaryCallableImpl : std::false_type {};
52  template <class Fun>
53  struct IsNullaryCallableImpl<
54      Fun, absl::void_t<decltype(std::declval<const Fun&>()())>>
55      : std::true_type {
56    using result_type = decltype(std::declval<const Fun&>()());
57    template <class ValueType>
58    using for_type = std::is_same<ValueType, result_type>;
59    using void_if_true = void;
60  };
61  template <class Fun>
62  struct IsNullaryCallable : IsNullaryCallableImpl<Fun> {};
63  template <class Fun>
64  struct GeneratorType;
65  template <class... Funs>
66  struct EquivalenceClassType;
67  template <class T>
68  struct IsEquivalenceClass : std::false_type {};
69  template <>
70  struct IsEquivalenceClass<EquivalenceClassType<>> : std::true_type {
71    using self = IsEquivalenceClass;
72    template <class ValueType>
73    using for_type = std::true_type;
74  };
75  template <class Head, class... Tail>
76  struct IsEquivalenceClass<EquivalenceClassType<Head, Tail...>>
77      : std::true_type {
78    using self = IsEquivalenceClass;
79    using result_type = typename IsNullaryCallable<Head>::result_type;
80    template <class ValueType>
81    using for_type = std::is_same<ValueType, result_type>;
82  };
83  template <class... EqClasses>
84  struct OrderedEquivalenceClasses;
85  template <class T>
86  struct ResultOfGenerator {};
87  template <class Fun>
88  struct ResultOfGenerator<GeneratorType<Fun>> {
89    using type = decltype(std::declval<const Fun&>()());
90  };
91  template <class Fun>
92  using ResultOfGeneratorT = typename ResultOfGenerator<GeneratorType<Fun>>::type;
93  template <class &bsol;*Enabler*/, class... Funs>
94  struct AreGeneratorsWithTheSameReturnTypeImpl : std::false_type {};
95  template <>
96  struct AreGeneratorsWithTheSameReturnTypeImpl<void> : std::true_type {};
97  template <class Head, class... Tail>
98  struct AreGeneratorsWithTheSameReturnTypeImpl<
99      typename std::enable_if<absl::conjunction<std::is_same<
100          ResultOfGeneratorT<Head>, ResultOfGeneratorT<Tail>>...>::value>::type,
101      Head, Tail...> : std::true_type {};
102  template <class... Funs>
103  struct AreGeneratorsWithTheSameReturnType
104      : AreGeneratorsWithTheSameReturnTypeImpl<void, Funs...>::type {};
105  template <class... EqClasses>
106  struct AreEquivalenceClassesOfTheSameType {
107    static_assert(sizeof...(EqClasses) != sizeof...(EqClasses), "");
108  };
109  template <>
110  struct AreEquivalenceClassesOfTheSameType<> : std::true_type {
111    using self = AreEquivalenceClassesOfTheSameType;
112    template <class &bsol;*ValueType*/>
113    using for_type = std::true_type;
114  };
115  template <class... Funs>
116  struct AreEquivalenceClassesOfTheSameType<EquivalenceClassType<Funs...>>
117      : std::true_type {
118    using self = AreEquivalenceClassesOfTheSameType;
119    template <class ValueType>
120    using for_type = typename IsEquivalenceClass<
121        EquivalenceClassType<Funs...>>::template for_type<ValueType>;
122  };
123  template <class... TailEqClasses>
124  struct AreEquivalenceClassesOfTheSameType<
125      EquivalenceClassType<>, EquivalenceClassType<>, TailEqClasses...>
126      : AreEquivalenceClassesOfTheSameType<TailEqClasses...>::self {};
127  template <class HeadNextFun, class... TailNextFuns, class... TailEqClasses>
128  struct AreEquivalenceClassesOfTheSameType<
129      EquivalenceClassType<>, EquivalenceClassType<HeadNextFun, TailNextFuns...>,
130      TailEqClasses...>
131      : AreEquivalenceClassesOfTheSameType<
132            EquivalenceClassType<HeadNextFun, TailNextFuns...>,
133            TailEqClasses...>::self {};
134  template <class HeadHeadFun, class... TailHeadFuns, class... TailEqClasses>
135  struct AreEquivalenceClassesOfTheSameType<
136      EquivalenceClassType<HeadHeadFun, TailHeadFuns...>, EquivalenceClassType<>,
137      TailEqClasses...>
138      : AreEquivalenceClassesOfTheSameType<
139            EquivalenceClassType<HeadHeadFun, TailHeadFuns...>,
140            TailEqClasses...>::self {};
141  template <class HeadHeadFun, class... TailHeadFuns, class HeadNextFun,
142            class... TailNextFuns, class... TailEqClasses>
143  struct AreEquivalenceClassesOfTheSameType<
144      EquivalenceClassType<HeadHeadFun, TailHeadFuns...>,
145      EquivalenceClassType<HeadNextFun, TailNextFuns...>, TailEqClasses...>
146      : absl::conditional_t<
147            IsNullaryCallable<HeadNextFun>::template for_type<
148                typename IsNullaryCallable<HeadHeadFun>::result_type>::value,
149            AreEquivalenceClassesOfTheSameType<
150                EquivalenceClassType<HeadHeadFun, TailHeadFuns...>,
151                TailEqClasses...>,
152            std::false_type> {};
153  template <class Fun, class... Cases>
154  void ForEachParameter(const Fun& fun, const Cases&... cases) {
155    const std::initializer_list<bool> results = {
156        (static_cast<void>(fun(cases)), true)...};
157    (void)results;
158  }
159  template <class Fun>
160  struct ForEachParameterFun {
161    template <class... T>
162    void operator()(const T&... cases) const {
163      (ForEachParameter)(fun, cases...);
164    }
165    Fun fun;
166  };
167  template <class Fun, class Tup>
168  void ForEachTupleElement(const Fun& fun, const Tup& tup) {
169    absl::apply(ForEachParameterFun<Fun>{fun}, tup);
<span onclick='openModal()' class='match'>170  }
171  template <class Fun, class... T>
172  struct ForEveryTwoImpl {
173    template <class Lhs>
</span>174    struct WithBoundLhs {
175      template <class Rhs>
176      void operator()(const Rhs& rhs) const {
177        fun(lhs, rhs);
178      }
179      Fun fun;
180      Lhs lhs;
181    };
182    template <class Lhs>
183    void operator()(const Lhs& lhs) const {
184      (ForEachTupleElement)(WithBoundLhs<Lhs>{fun, lhs}, args);
185    }
186    Fun fun;
187    std::tuple<T...> args;
188  };
189  template <class Fun, class... T>
190  void ForEveryTwo(const Fun& fun, std::tuple<T...> args) {
191    (ForEachTupleElement)(ForEveryTwoImpl<Fun, T...>{fun, args}, args);
192  }
193  template<class Container>
194  void InsertEach(Container* cont) {
195  }
196  template<class Container, class H, class... T>
197  void InsertEach(Container* cont, H&& head, T&&... tail) {
198    cont->insert(head);
199    (InsertEach)(cont, tail...);
200  }
201  template <bool Condition>
202  struct If;
203  template <>
204  struct If<&bsol;*Condition =*/false> {
205    template <class Fun, class... P>
206    static void Invoke(const Fun& &bsol;*fun*/, P&&... &bsol;*args*/) {}
207  };
208  template <>
209  struct If<&bsol;*Condition =*/true> {
210    template <class Fun, class... P>
211    static void Invoke(const Fun& fun, P&&... args) {
212      fun(absl::forward<P>(args)...);
213    }
214  };
215  #define ABSL_INTERNAL_STRINGIZE(...) ABSL_INTERNAL_STRINGIZE_IMPL((__VA_ARGS__))
216  #define ABSL_INTERNAL_STRINGIZE_IMPL(arg) ABSL_INTERNAL_STRINGIZE_IMPL2 arg
217  #define ABSL_INTERNAL_STRINGIZE_IMPL2(...) #__VA_ARGS__
218  }  
219  ABSL_NAMESPACE_END
220  }  
221  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_testing.h</h3>
            <pre><code>1  #ifndef ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_H_
2  #define ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_H_
3  #include <cstddef>
4  #include <set>
5  #include <tuple>
6  #include <type_traits>
7  #include <utility>
8  #include "gtest/gtest.h"
9  #include "absl/meta/type_traits.h"
10  #include "absl/strings/ascii.h"
11  #include "absl/strings/str_cat.h"
12  #include "absl/strings/string_view.h"
13  #include "absl/types/internal/conformance_aliases.h"
14  #include "absl/types/internal/conformance_archetype.h"
15  #include "absl/types/internal/conformance_profile.h"
16  #include "absl/types/internal/conformance_testing_helpers.h"
17  #include "absl/types/internal/parentheses.h"
18  #include "absl/types/internal/transform_args.h"
19  #include "absl/utility/utility.h"
20  namespace absl {
21  ABSL_NAMESPACE_BEGIN
22  namespace types_internal {
23  constexpr bool constexpr_instantiation_when_unevaluated() {
24  #if defined(__apple_build_version__)  
25    return true;
26  #elif defined(__clang__)
27    return __clang_major__ < 4;
28  #elif defined(__GNUC__)
29    return __GNUC__ < 5 || (__GNUC__ == 5 && __GNUC_MINOR__ < 2) || __GNUC__ >= 7;
30  #else
31    return false;
32  #endif
33  }
34  constexpr bool poisoned_hash_fails_instantiation() {
35  #if defined(_MSC_VER) && !defined(_LIBCPP_VERSION)
36    return _MSC_VER < 1914;
37  #else
38    return false;
39  #endif
40  }
41  template <class Fun>
42  struct GeneratorType {
43    decltype(std::declval<const Fun&>()()) operator()() const
44        noexcept(noexcept(std::declval<const Fun&>()())) {
45      return fun();
46    }
47    Fun fun;
48    const char* description;
49  };
50  template <class Fun,
51            absl::enable_if_t<IsNullaryCallable<Fun>::value>** = nullptr>
52  GeneratorType<Fun> Generator(Fun fun, const char* description) {
53    return GeneratorType<Fun>{absl::move(fun), description};
54  }
55  template <class... Funs>
56  struct EquivalenceClassType {
57    std::tuple<GeneratorType<Funs>...> generators;
58  };
59  template <class... Funs, absl::enable_if_t<AreGeneratorsWithTheSameReturnType<
60                               Funs...>::value>** = nullptr>
61  EquivalenceClassType<Funs...> EquivalenceClass(GeneratorType<Funs>... funs) {
62    return {std::make_tuple(absl::move(funs)...)};
63  }
64  template <class... EqClasses>
65  struct OrderedEquivalenceClasses {
66    std::tuple<EqClasses...> eq_classes;
67  };
68  struct GivenDeclaration {
69    std::string outputDeclaration(std::size_t width) const {
70      const std::size_t indent_size = 2;
71      std::string result = absl::StrCat("  ", name);
72      if (!expression.empty()) {
73        result.resize(indent_size + width, ' ');
74        absl::StrAppend(&result, " = ", expression, ";\n");
75      } else {
76        absl::StrAppend(&result, ";\n");
77      }
78      return result;
79    }
80    std::string name;
81    std::string expression;
82  };
83  template <class... Decls>
84  std::string PrepareGivenContext(const Decls&... decls) {
85    const std::size_t width = (std::max)({decls.name.size()...});
86    return absl::StrCat("Given:\n", decls.outputDeclaration(width)..., "\n");
87  }
88  #define ABSL_INTERNAL_EXPECT_OP(name, op)                                   \
89    struct Expect##name {                                                     \
90      template <class T>                                                      \
91      void operator()(absl::string_view test_name, absl::string_view context, \
92                      const T& lhs, const T& rhs, absl::string_view lhs_name, \
93                      absl::string_view rhs_name) const {                     \
94        if (!static_cast<bool>(lhs op rhs)) {                                 \
95          errors->addTestFailure(                                             \
96              test_name, absl::StrCat(context,                                \
97                                      "**Unexpected comparison result**\n"    \
98                                      "\n"                                    \
99                                      "Expression:\n"                         \
100                                      "  ",                                   \
101                                      lhs_name, " " #op " ", rhs_name,        \
102                                      "\n"                                    \
103                                      "\n"                                    \
104                                      "Expected: true\n"                      \
105                                      "  Actual: false"));                    \
106        } else {                                                              \
107          errors->addTestSuccess(test_name);                                  \
108        }                                                                     \
109      }                                                                       \
110                                                                              \
111      ConformanceErrors* errors;                                              \
112    };                                                                        \
113                                                                              \
114    struct ExpectNot##name {                                                  \
115      template <class T>                                                      \
116      void operator()(absl::string_view test_name, absl::string_view context, \
117                      const T& lhs, const T& rhs, absl::string_view lhs_name, \
118                      absl::string_view rhs_name) const {                     \
119        if (lhs op rhs) {                                                     \
120          errors->addTestFailure(                                             \
121              test_name, absl::StrCat(context,                                \
122                                      "**Unexpected comparison result**\n"    \
123                                      "\n"                                    \
124                                      "Expression:\n"                         \
125                                      "  ",                                   \
126                                      lhs_name, " " #op " ", rhs_name,        \
127                                      "\n"                                    \
128                                      "\n"                                    \
129                                      "Expected: false\n"                     \
130                                      "  Actual: true"));                     \
131        } else {                                                              \
132          errors->addTestSuccess(test_name);                                  \
133        }                                                                     \
134      }                                                                       \
135                                                                              \
136      ConformanceErrors* errors;                                              \
137    }
138  ABSL_INTERNAL_EXPECT_OP(Eq, ==);
139  ABSL_INTERNAL_EXPECT_OP(Ne, !=);
140  ABSL_INTERNAL_EXPECT_OP(Lt, <);
141  ABSL_INTERNAL_EXPECT_OP(Le, <=);
142  ABSL_INTERNAL_EXPECT_OP(Ge, >=);
143  ABSL_INTERNAL_EXPECT_OP(Gt, >);
144  #undef ABSL_INTERNAL_EXPECT_OP
145  struct ExpectSameHash {
146    template <class T>
147    void operator()(absl::string_view test_name, absl::string_view context,
148                    const T& lhs, const T& rhs, absl::string_view lhs_name,
149                    absl::string_view rhs_name) const {
150      if (std::hash<T>()(lhs) != std::hash<T>()(rhs)) {
151        errors->addTestFailure(
152            test_name, absl::StrCat(context,
153                                    "**Unexpected hash result**\n"
154                                    "\n"
155                                    "Expression:\n"
156                                    "  std::hash<T>()(",
157                                    lhs_name, ") == std::hash<T>()(", rhs_name,
158                                    ")\n"
159                                    "\n"
160                                    "Expected: true\n"
161                                    "  Actual: false"));
162      } else {
163        errors->addTestSuccess(test_name);
164      }
165    }
166    ConformanceErrors* errors;
167  };
168  template <class T, class Prof>
169  void ExpectOneWayEquality(ConformanceErrors* errors,
170                            absl::string_view test_name,
171                            absl::string_view context, const T& lhs, const T& rhs,
172                            absl::string_view lhs_name,
173                            absl::string_view rhs_name) {
174    If<PropertiesOfT<Prof>::is_equality_comparable>::Invoke(
175        ExpectEq{errors}, test_name, context, lhs, rhs, lhs_name, rhs_name);
176    If<PropertiesOfT<Prof>::is_inequality_comparable>::Invoke(
177        ExpectNotNe{errors}, test_name, context, lhs, rhs, lhs_name, rhs_name);
178    If<PropertiesOfT<Prof>::is_less_than_comparable>::Invoke(
179        ExpectNotLt{errors}, test_name, context, lhs, rhs, lhs_name, rhs_name);
180    If<PropertiesOfT<Prof>::is_less_equal_comparable>::Invoke(
181        ExpectLe{errors}, test_name, context, lhs, rhs, lhs_name, rhs_name);
182    If<PropertiesOfT<Prof>::is_greater_equal_comparable>::Invoke(
183        ExpectGe{errors}, test_name, context, lhs, rhs, lhs_name, rhs_name);
184    If<PropertiesOfT<Prof>::is_greater_than_comparable>::Invoke(
185        ExpectNotGt{errors}, test_name, context, lhs, rhs, lhs_name, rhs_name);
186    If<PropertiesOfT<Prof>::is_hashable>::Invoke(
187        ExpectSameHash{errors}, test_name, context, lhs, rhs, lhs_name, rhs_name);
188  }
189  template <class T, class Prof>
190  void ExpectEquality(ConformanceErrors* errors, absl::string_view test_name,
191                      absl::string_view context, const T& lhs, const T& rhs,
192                      absl::string_view lhs_name, absl::string_view rhs_name) {
193    (ExpectOneWayEquality<T, Prof>)(errors, test_name, context, lhs, rhs,
194                                    lhs_name, rhs_name);
195    (ExpectOneWayEquality<T, Prof>)(errors, test_name, context, rhs, lhs,
196                                    rhs_name, lhs_name);
197  }
198  template <class T, class Prof>
199  struct ExpectMoveConstructOneGenerator {
200    template <class Fun>
201    void operator()(const Fun& generator) const {
202      const T object = generator();
203      const T moved_object = absl::move(generator());  
204      (ExpectEquality<T, Prof>)(errors, "Move construction",
205                                PrepareGivenContext(
206                                    GivenDeclaration{"const _T object",
207                                                     generator.description},
208                                    GivenDeclaration{"const _T moved_object",
209                                                     std::string("std::move(") +
210                                                         generator.description +
211                                                         ")"}),
212                                object, moved_object, "object", "moved_object");
213    }
214    ConformanceErrors* errors;
215  };
216  template <class T, class Prof>
217  struct ExpectCopyConstructOneGenerator {
218    template <class Fun>
219    void operator()(const Fun& generator) const {
220      const T object = generator();
221      const T copied_object = static_cast<const T&>(generator());
222      (ExpectEquality<T, Prof>)(errors, "Copy construction",
223                                PrepareGivenContext(
224                                    GivenDeclaration{"const _T object",
225                                                     generator.description},
226                                    GivenDeclaration{
227                                        "const _T copied_object",
228                                        std::string("static_cast<const _T&>(") +
229                                            generator.description + ")"}),
230                                object, copied_object, "object", "copied_object");
231    }
232    ConformanceErrors* errors;
233  };
234  template <class T>
235  struct ExpectDefaultConstructWithDestruct {
236    void operator()() const {
237      {
238        T object;
239        static_cast<void>(object);
240      }
241      errors->addTestSuccess("Default construction");
242    }
243    ConformanceErrors* errors;
244  };
245  template <class T, class Prof>
246  struct ExpectDefaultConstructWithMoveAssign {
247    template <class Fun>
248    void operator()(const Fun& generator) const {
249      const T source_of_truth = generator();
250      T object;
251      object = generator();
252      (ExpectEquality<T, Prof>)(errors, "Move assignment",
253                                PrepareGivenContext(
254                                    GivenDeclaration{"const _T object",
255                                                     generator.description},
256                                    GivenDeclaration{"_T object", ""},
257                                    GivenDeclaration{"object",
258                                                     generator.description}),
259                                object, source_of_truth, "std::as_const(object)",
260                                "source_of_truth");
261    }
262    ConformanceErrors* errors;
263  };
264  template <class T, class Prof>
265  struct ExpectDefaultConstructWithCopyAssign {
266    template <class Fun>
267    void operator()(const Fun& generator) const {
268      const T source_of_truth = generator();
269      T object;
270      object = static_cast<const T&>(generator());
271      (ExpectEquality<T, Prof>)(errors, "Copy assignment",
272                                PrepareGivenContext(
273                                    GivenDeclaration{"const _T source_of_truth",
274                                                     generator.description},
275                                    GivenDeclaration{"_T object", ""},
276                                    GivenDeclaration{
277                                        "object",
278                                        std::string("static_cast<const _T&>(") +
279                                            generator.description + ")"}),
280                                object, source_of_truth, "std::as_const(object)",
281                                "source_of_truth");
282    }
283    ConformanceErrors* errors;
284  };
285  template <class T, class Prof>
286  struct ExpectSelfMoveAssign {
287    template <class Fun>
288    void operator()(const Fun& generator) const {
289      T object = generator();
290      object = absl::move(object);
291      (ExpectEquality<T, Prof>)(errors, "Move assignment",
292                                PrepareGivenContext(
293                                    GivenDeclaration{"_T object",
294                                                     generator.description},
295                                    GivenDeclaration{"object",
296                                                     "std::move(object)"}),
297                                object, object, "object", "object");
298    }
299    ConformanceErrors* errors;
300  };
301  template <class T, class Prof>
302  struct ExpectSelfCopyAssign {
303    template <class Fun>
304    void operator()(const Fun& generator) const {
305      const T source_of_truth = generator();
306      T object = generator();
307      const T& const_object = object;
308      object = const_object;
309      (ExpectEquality<T, Prof>)(errors, "Copy assignment",
310                                PrepareGivenContext(
311                                    GivenDeclaration{"const _T source_of_truth",
312                                                     generator.description},
313                                    GivenDeclaration{"_T object",
314                                                     generator.description},
315                                    GivenDeclaration{"object",
316                                                     "std::as_const(object)"}),
317                                const_object, source_of_truth,
318                                "std::as_const(object)", "source_of_truth");
319    }
320    ConformanceErrors* errors;
321  };
322  template <class T, class Prof>
323  struct ExpectSelfSwap {
324    template <class Fun>
325    void operator()(const Fun& generator) const {
326      const T source_of_truth = generator();
327      T object = generator();
328      type_traits_internal::Swap(object, object);
329      std::string preliminary_info = absl::StrCat(
330          PrepareGivenContext(
331              GivenDeclaration{"const _T source_of_truth", generator.description},
332              GivenDeclaration{"_T object", generator.description}),
333          "After performing a self-swap:\n"
334          "  using std::swap;\n"
335          "  swap(object, object);\n"
336          "\n");
337      (ExpectEquality<T, Prof>)(errors, "Swap", std::move(preliminary_info),
338                                object, source_of_truth, "std::as_const(object)",
339                                "source_of_truth");
340    }
341    ConformanceErrors* errors;
342  };
343  template <class T, class Prof>
344  struct ExpectSelfComparison {
345    template <class Fun>
346    void operator()(const Fun& generator) const {
347      const T object = generator();
348      (ExpectOneWayEquality<T, Prof>)(errors, "Comparison",
349                                      PrepareGivenContext(GivenDeclaration{
350                                          "const _T object",
351                                          generator.description}),
352                                      object, object, "object", "object");
353    }
354    ConformanceErrors* errors;
355  };
356  template <class T, class Prof>
357  struct ExpectConsistency {
358    template <class Fun>
359    void operator()(const Fun& generator) const {
360      If<PropertiesOfT<Prof>::is_move_constructible>::Invoke(
361          ExpectMoveConstructOneGenerator<T, Prof>{errors}, generator);
362      If<PropertiesOfT<Prof>::is_copy_constructible>::Invoke(
363          ExpectCopyConstructOneGenerator<T, Prof>{errors}, generator);
364      If<PropertiesOfT<Prof>::is_default_constructible &&
365         PropertiesOfT<Prof>::is_move_assignable>::
366          Invoke(ExpectDefaultConstructWithMoveAssign<T, Prof>{errors},
367                 generator);
368      If<PropertiesOfT<Prof>::is_default_constructible &&
369         PropertiesOfT<Prof>::is_copy_assignable>::
370          Invoke(ExpectDefaultConstructWithCopyAssign<T, Prof>{errors},
371                 generator);
372      If<PropertiesOfT<Prof>::is_move_assignable>::Invoke(
373          ExpectSelfMoveAssign<T, Prof>{errors}, generator);
374      If<PropertiesOfT<Prof>::is_copy_assignable>::Invoke(
375          ExpectSelfCopyAssign<T, Prof>{errors}, generator);
376      If<PropertiesOfT<Prof>::is_swappable>::Invoke(
377          ExpectSelfSwap<T, Prof>{errors}, generator);
378    }
379    ConformanceErrors* errors;
380  };
381  template <class T, class Prof>
382  struct ExpectMoveAssign {
383    template <class Fun0, class Fun1>
384    void operator()(const Fun0& generator0, const Fun1& generator1) const {
385      const T source_of_truth1 = generator1();
386      T object = generator0();
387      object = generator1();
388      (ExpectEquality<T, Prof>)(errors, "Move assignment",
389                                PrepareGivenContext(
390                                    GivenDeclaration{"const _T source_of_truth1",
391                                                     generator1.description},
392                                    GivenDeclaration{"_T object",
393                                                     generator0.description},
394                                    GivenDeclaration{"object",
395                                                     generator1.description}),
396                                object, source_of_truth1, "std::as_const(object)",
397                                "source_of_truth1");
398    }
399    ConformanceErrors* errors;
400  };
401  template <class T, class Prof>
402  struct ExpectCopyAssign {
403    template <class Fun0, class Fun1>
404    void operator()(const Fun0& generator0, const Fun1& generator1) const {
405      const T source_of_truth1 = generator1();
406      T object = generator0();
407      object = static_cast<const T&>(generator1());
408      (ExpectEquality<T, Prof>)(errors, "Copy assignment",
409                                PrepareGivenContext(
410                                    GivenDeclaration{"const _T source_of_truth1",
411                                                     generator1.description},
412                                    GivenDeclaration{"_T object",
413                                                     generator0.description},
414                                    GivenDeclaration{
415                                        "object",
416                                        std::string("static_cast<const _T&>(") +
417                                            generator1.description + ")"}),
418                                object, source_of_truth1, "std::as_const(object)",
419                                "source_of_truth1");
420    }
421    ConformanceErrors* errors;
422  };
423  template <class T, class Prof>
424  struct ExpectSwap {
425    template <class Fun0, class Fun1>
426    void operator()(const Fun0& generator0, const Fun1& generator1) const {
427      const T source_of_truth0 = generator0();
428      const T source_of_truth1 = generator1();
429      T object0 = generator0();
430      T object1 = generator1();
431      type_traits_internal::Swap(object0, object1);
432      const std::string context =
433          PrepareGivenContext(
434              GivenDeclaration{"const _T source_of_truth0",
435                               generator0.description},
436              GivenDeclaration{"const _T source_of_truth1",
437                               generator1.description},
438              GivenDeclaration{"_T object0", generator0.description},
439              GivenDeclaration{"_T object1", generator1.description}) +
440          "After performing a swap:\n"
441          "  using std::swap;\n"
442          "  swap(object0, object1);\n"
443          "\n";
444      (ExpectEquality<T, Prof>)(errors, "Swap", context, object0,
445                                source_of_truth1, "std::as_const(object0)",
446                                "source_of_truth1");
447      (ExpectEquality<T, Prof>)(errors, "Swap", context, object1,
448                                source_of_truth0, "std::as_const(object1)",
449                                "source_of_truth0");
450    }
451    ConformanceErrors* errors;
452  };
453  template <class T, class Prof>
454  struct ExpectEquivalenceClassComparison {
455    template <class Fun0, class Fun1>
456    void operator()(const Fun0& generator0, const Fun1& generator1) const {
457      const T object0 = generator0();
458      const T object1 = generator1();
459      (ExpectEquality<T, Prof>)(errors, "Comparison",
460                                PrepareGivenContext(
461                                    GivenDeclaration{"const _T object0",
462                                                     generator0.description},
463                                    GivenDeclaration{"const _T object1",
464                                                     generator1.description}),
465                                object0, object1, "object0", "object1");
466    }
467    ConformanceErrors* errors;
468  };
469  template <class T, class Prof>
470  struct ExpectEquivalenceClassConsistency {
471    template <class Fun0, class Fun1>
472    void operator()(const Fun0& generator0, const Fun1& generator1) const {
473      If<PropertiesOfT<Prof>::is_move_assignable>::Invoke(
474          ExpectMoveAssign<T, Prof>{errors}, generator0, generator1);
475      If<PropertiesOfT<Prof>::is_copy_assignable>::Invoke(
476          ExpectCopyAssign<T, Prof>{errors}, generator0, generator1);
477      If<PropertiesOfT<Prof>::is_swappable>::Invoke(ExpectSwap<T, Prof>{errors},
478                                                    generator0, generator1);
479    }
480    ConformanceErrors* errors;
481  };
482  template <class T, class Prof>
483  void ExpectOrdered(ConformanceErrors* errors, absl::string_view context,
484                     const T& small, const T& big, absl::string_view small_name,
485                     absl::string_view big_name) {
486    const absl::string_view test_name = "Comparison";
487    If<PropertiesOfT<Prof>::is_equality_comparable>::Invoke(
488        ExpectNotEq{errors}, test_name, context, small, big, small_name,
489        big_name);
490    If<PropertiesOfT<Prof>::is_equality_comparable>::Invoke(
491        ExpectNotEq{errors}, test_name, context, big, small, big_name,
492        small_name);
493    If<PropertiesOfT<Prof>::is_inequality_comparable>::Invoke(
494        ExpectNe{errors}, test_name, context, small, big, small_name, big_name);
495    If<PropertiesOfT<Prof>::is_inequality_comparable>::Invoke(
496        ExpectNe{errors}, test_name, context, big, small, big_name, small_name);
497    If<PropertiesOfT<Prof>::is_less_than_comparable>::Invoke(
498        ExpectLt{errors}, test_name, context, small, big, small_name, big_name);
499    If<PropertiesOfT<Prof>::is_less_than_comparable>::Invoke(
500        ExpectNotLt{errors}, test_name, context, big, small, big_name,
501        small_name);
502    If<PropertiesOfT<Prof>::is_less_equal_comparable>::Invoke(
503        ExpectLe{errors}, test_name, context, small, big, small_name, big_name);
504    If<PropertiesOfT<Prof>::is_less_equal_comparable>::Invoke(
505        ExpectNotLe{errors}, test_name, context, big, small, big_name,
506        small_name);
507    If<PropertiesOfT<Prof>::is_greater_equal_comparable>::Invoke(
508        ExpectNotGe{errors}, test_name, context, small, big, small_name,
509        big_name);
510    If<PropertiesOfT<Prof>::is_greater_equal_comparable>::Invoke(
511        ExpectGe{errors}, test_name, context, big, small, big_name, small_name);
512    If<PropertiesOfT<Prof>::is_greater_than_comparable>::Invoke(
513        ExpectNotGt{errors}, test_name, context, small, big, small_name,
514        big_name);
515    If<PropertiesOfT<Prof>::is_greater_than_comparable>::Invoke(
516        ExpectGt{errors}, test_name, context, big, small, big_name, small_name);
517  }
518  template <class T, class Prof>
519  struct ExpectEquivalenceClassComparisons {
520    template <class... Funs>
521    void operator()(EquivalenceClassType<Funs...> eq_class) const {
522      (ForEachTupleElement)(ExpectSelfComparison<T, Prof>{errors},
523                            eq_class.generators);
524      (ForEveryTwo)(ExpectEquivalenceClassComparison<T, Prof>{errors},
525                    eq_class.generators);
526    }
527    ConformanceErrors* errors;
528  };
529  template <class T, class Prof>
530  struct ExpectEquivalenceClass {
531    template <class... Funs>
532    void operator()(EquivalenceClassType<Funs...> eq_class) const {
533      (ForEachTupleElement)(ExpectConsistency<T, Prof>{errors},
534                            eq_class.generators);
535      (ForEveryTwo)(ExpectEquivalenceClassConsistency<T, Prof>{errors},
536                    eq_class.generators);
537    }
538    ConformanceErrors* errors;
539  };
540  template <class T, class Prof, class SmallGenerator>
541  struct ExpectBiggerGeneratorThanComparisons {
542    template <class BigGenerator>
543    void operator()(BigGenerator big_gen) const {
544      const T small = small_gen();
545      const T big = big_gen();
546      (ExpectOrdered<T, Prof>)(errors,
547                               PrepareGivenContext(
548                                   GivenDeclaration{"const _T small",
549                                                    small_gen.description},
550                                   GivenDeclaration{"const _T big",
551                                                    big_gen.description}),
552                               small, big, "small", "big");
553    }
554    SmallGenerator small_gen;
555    ConformanceErrors* errors;
556  };
557  template <class T, class Prof, class SmallGenerator>
558  struct ExpectBiggerGeneratorThan {
559    template <class BigGenerator>
560    void operator()(BigGenerator big_gen) const {
561      If<PropertiesOfT<Prof>::is_move_assignable>::Invoke(
562          ExpectMoveAssign<T, Prof>{errors}, small_gen, big_gen);
563      If<PropertiesOfT<Prof>::is_move_assignable>::Invoke(
564          ExpectMoveAssign<T, Prof>{errors}, big_gen, small_gen);
565      If<PropertiesOfT<Prof>::is_copy_assignable>::Invoke(
566          ExpectCopyAssign<T, Prof>{errors}, small_gen, big_gen);
567      If<PropertiesOfT<Prof>::is_copy_assignable>::Invoke(
568          ExpectCopyAssign<T, Prof>{errors}, big_gen, small_gen);
569      If<PropertiesOfT<Prof>::is_swappable>::Invoke(ExpectSwap<T, Prof>{errors},
570                                                    small_gen, big_gen);
571    }
572    SmallGenerator small_gen;
573    ConformanceErrors* errors;
574  };
575  template <class T, class Prof, class SmallGenerator>
576  struct ExpectBiggerGeneratorThanEqClassesComparisons {
577    template <class BigEqClass>
578    void operator()(BigEqClass big_eq_class) const {
579      (ForEachTupleElement)(
580          ExpectBiggerGeneratorThanComparisons<T, Prof, SmallGenerator>{small_gen,
581                                                                        errors},
582          big_eq_class.generators);
583    }
584    SmallGenerator small_gen;
585    ConformanceErrors* errors;
586  };
587  template <class T, class Prof, class SmallGenerator>
588  struct ExpectBiggerGeneratorThanEqClasses {
589    template <class BigEqClass>
590    void operator()(BigEqClass big_eq_class) const {
591      (ForEachTupleElement)(
592          ExpectBiggerGeneratorThan<T, Prof, SmallGenerator>{small_gen, errors},
593          big_eq_class.generators);
594    }
595    SmallGenerator small_gen;
596    ConformanceErrors* errors;
597  };
598  template <class T, class Prof>
599  struct ExpectOrderedEquivalenceClassesComparisons {
600    template <class... BigEqClasses>
601    struct Impl {
602      template <class SmallGenerator>
603      void operator()(SmallGenerator small_gen) const {
604        (ForEachTupleElement)(ExpectBiggerGeneratorThanEqClassesComparisons<
605                                  T, Prof, SmallGenerator>{small_gen, errors},
606                              big_eq_classes);
607      }
608      std::tuple<BigEqClasses...> big_eq_classes;
609      ConformanceErrors* errors;
610    };
611    void operator()() const {}
612    template <class SmallEqClass, class... BigEqClasses>
613    void operator()(SmallEqClass small_eq_class,
614                    BigEqClasses... big_eq_classes) const {
615      (ForEachTupleElement)(
616          Impl<BigEqClasses...>{std::make_tuple(absl::move(big_eq_classes)...),
617                                errors},
618          small_eq_class.generators);
619      (*this)(absl::move(big_eq_classes)...);
620    }
621    ConformanceErrors* errors;
622  };
623  template <class T, class Prof>
624  struct ExpectOrderedEquivalenceClasses {
625    template <class... BigEqClasses>
626    struct Impl {
627      template <class SmallGenerator>
628      void operator()(SmallGenerator small_gen) const {
629        (ForEachTupleElement)(
630            ExpectBiggerGeneratorThanEqClasses<T, Prof, SmallGenerator>{small_gen,
631                                                                        errors},
632            big_eq_classes);
633      }
634      std::tuple<BigEqClasses...> big_eq_classes;
635      ConformanceErrors* errors;
636    };
637    template <class SmallEqClass, class... BigEqClasses>
638    void operator()(SmallEqClass small_eq_class,
639                    BigEqClasses... big_eq_classes) const {
640      (ForEachTupleElement)(
641          Impl<BigEqClasses...>{std::make_tuple(absl::move(big_eq_classes)...),
642                                errors},
643          small_eq_class.generators);
644      (*this)(absl::move(big_eq_classes)...);
645    }
646    void operator()() const {}
647    ConformanceErrors* errors;
648  };
649  template <class T, class MinProf, class MaxProf>
650  struct ExpectHashable {
651    void operator()() const {
652      ExpectModelOfHashable<T, MinProf, MaxProf>(errors);
653    }
654    ConformanceErrors* errors;
655  };
656  template <class T, class MinProf, class MaxProf>
657  struct ExpectModels {
658    void operator()(ConformanceErrors* errors) const {
659      ExpectModelOfDefaultConstructible<T, MinProf, MaxProf>(errors);
660      ExpectModelOfMoveConstructible<T, MinProf, MaxProf>(errors);
661      ExpectModelOfCopyConstructible<T, MinProf, MaxProf>(errors);
662      ExpectModelOfMoveAssignable<T, MinProf, MaxProf>(errors);
663      ExpectModelOfCopyAssignable<T, MinProf, MaxProf>(errors);
664      ExpectModelOfDestructible<T, MinProf, MaxProf>(errors);
665      ExpectModelOfEqualityComparable<T, MinProf, MaxProf>(errors);
666      ExpectModelOfInequalityComparable<T, MinProf, MaxProf>(errors);
667      ExpectModelOfLessThanComparable<T, MinProf, MaxProf>(errors);
668      ExpectModelOfLessEqualComparable<T, MinProf, MaxProf>(errors);
669      ExpectModelOfGreaterEqualComparable<T, MinProf, MaxProf>(errors);
670      ExpectModelOfGreaterThanComparable<T, MinProf, MaxProf>(errors);
671      ExpectModelOfSwappable<T, MinProf, MaxProf>(errors);
672      If<!poisoned_hash_fails_instantiation()>::Invoke(
673          ExpectHashable<T, MinProf, MaxProf>{errors});
674    }
675  };
676  template <class LogicalProf, class T>
677  struct MinimalCheckableProfile {
678    using type =
679        MinimalProfiles<PropertiesOfT<LogicalProf>,
680                        PropertiesOfT<SyntacticConformanceProfileOf<
681                            T, !PropertiesOfT<LogicalProf>::is_hashable &&
682                                       poisoned_hash_fails_instantiation()
683                                   ? CheckHashability::no
684                                   : CheckHashability::yes>>>;
685  };
686  template <class T>
687  struct Always {
688    using type = T;
689  };
690  template <class T, class LogicalProf, class MinProf, class MaxProf,
691            class... EqClasses>
692  ConformanceErrors ExpectRegularityImpl(
693      OrderedEquivalenceClasses<EqClasses...> vals) {
694    ConformanceErrors errors((NameOf<T>()));
695    If<!constexpr_instantiation_when_unevaluated()>::Invoke(
696        ExpectModels<T, MinProf, MaxProf>(), &errors);
697    using minimal_profile = typename absl::conditional_t<
698        constexpr_instantiation_when_unevaluated(), Always<LogicalProf>,
699        MinimalCheckableProfile<LogicalProf, T>>::type;
700    If<PropertiesOfT<minimal_profile>::is_default_constructible>::Invoke(
701        ExpectDefaultConstructWithDestruct<T>{&errors});
702    (ForEachTupleElement)(
703        ExpectEquivalenceClassComparisons<T, minimal_profile>{&errors},
704        vals.eq_classes);
705    absl::apply(
706        ExpectOrderedEquivalenceClassesComparisons<T, minimal_profile>{&errors},
707        vals.eq_classes);
708    (ForEachTupleElement)(ExpectEquivalenceClass<T, minimal_profile>{&errors},
709                          vals.eq_classes);
710    absl::apply(ExpectOrderedEquivalenceClasses<T, minimal_profile>{&errors},
711                vals.eq_classes);
712    return errors;
713  }
714  template <class LogicalProf, class MinProf = LogicalProf,
715            class MaxProf = MinProf>
716  struct ProfileRange {
717    using logical_profile = LogicalProf;
718    using min_profile = MinProf;
719    using max_profile = MaxProf;
720  };
721  template <class StrictnessDomain, class LogicalProf,
722            class MinProf = LogicalProf, class MaxProf = MinProf>
723  struct StrictProfileRange {
724    static_assert(
725        std::is_same<StrictnessDomain, RegularityDomain>::value,
726        "Currently, the only valid StrictnessDomain is RegularityDomain.");
727    using strictness_domain = StrictnessDomain;
728    using logical_profile = LogicalProf;
729    using min_profile = MinProf;
730    using max_profile = MaxProf;
731  };
732  template <class StrictnessDomain, class ProfOrRange>
733  struct MakeStrictProfileRange;
734  template <class StrictnessDomain, class LogicalProf>
735  struct MakeStrictProfileRange {
736    using type = StrictProfileRange<StrictnessDomain, LogicalProf>;
737  };
738  template <class StrictnessDomain, class LogicalProf, class MinProf,
739            class MaxProf>
740  struct MakeStrictProfileRange<StrictnessDomain,
741                                ProfileRange<LogicalProf, MinProf, MaxProf>> {
742    using type =
743        StrictProfileRange<StrictnessDomain, LogicalProf, MinProf, MaxProf>;
744  };
745  template <class StrictnessDomain, class ProfOrRange>
746  using MakeStrictProfileRangeT =
747      typename MakeStrictProfileRange<StrictnessDomain, ProfOrRange>::type;
748  using MostStrictProfile =
749      CombineProfiles<TriviallyCompleteProfile, NothrowComparableProfile>;
750  template <class LogicalProf, class MinProf = LogicalProf>
751  using LooseProfileRange = StrictProfileRange<RegularityDomain, LogicalProf,
752                                               MinProf, MostStrictProfile>;
753  template <class Prof>
754  using MakeLooseProfileRangeT = Prof;
755  template <class T, class &bsol;*Enabler*/ = void>
756  struct ProfileRangeOfImpl;
757  template <class T>
758  struct ProfileRangeOfImpl<T, absl::void_t<PropertiesOfT<T>>> {
759    using type = LooseProfileRange<T>;
760  };
761  template <class T>
762  struct ProfileRangeOf : ProfileRangeOfImpl<T> {};
763  template <class StrictnessDomain, class LogicalProf, class MinProf,
764            class MaxProf>
765  struct ProfileRangeOf<
766      StrictProfileRange<StrictnessDomain, LogicalProf, MinProf, MaxProf>> {
767    using type =
768        StrictProfileRange<StrictnessDomain, LogicalProf, MinProf, MaxProf>;
769  };
770  template <class T>
771  using ProfileRangeOfT = typename ProfileRangeOf<T>::type;
772  template <class T>
773  using LogicalProfileOfT = typename ProfileRangeOfT<T>::logical_profile;
774  template <class T>
775  using MinProfileOfT = typename ProfileRangeOfT<T>::min_profile;
776  template <class T>
777  using MaxProfileOfT = typename ProfileRangeOfT<T>::max_profile;
778  template <class T>
779  struct IsProfileOrProfileRange : IsProfile<T>::type {};
780  template <class StrictnessDomain, class LogicalProf, class MinProf,
781            class MaxProf>
782  struct IsProfileOrProfileRange<
783      StrictProfileRange<StrictnessDomain, LogicalProf, MinProf, MaxProf>>
<span onclick='openModal()' class='match'>784      : std::true_type {};
785  template <bool ExpectSuccess, class T, class... EqClasses>
786  struct ExpectConformanceOf {
787    template <class Fun,
</span>788              absl::enable_if_t<std::is_same<
789                  ResultOfGeneratorT<GeneratorType<Fun>>, T>::value>** = nullptr>
790    ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess, T, EqClasses...,
791                                             EquivalenceClassType<Fun>>
792    initializer(GeneratorType<Fun> fun) && {
793      return {
794          {std::tuple_cat(absl::move(ordered_vals.eq_classes),
795                          std::make_tuple((EquivalenceClass)(absl::move(fun))))},
796          std::move(expected_failed_tests)};
797    }
798    template <class... TestNames,
799              absl::enable_if_t<!ExpectSuccess && sizeof...(EqClasses) == 0 &&
800                                absl::conjunction<std::is_convertible<
801                                    TestNames, absl::string_view>...>::value>** =
802                  nullptr>
803    ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess, T, EqClasses...>
804    due_to(TestNames&&... test_names) && {
805      (InsertEach)(&expected_failed_tests,
806                   absl::AsciiStrToLower(absl::string_view(test_names))...);
807      return {absl::move(ordered_vals), std::move(expected_failed_tests)};
808    }
809    template <class... TestNames, int = 0,  
810              absl::enable_if_t<ExpectSuccess && sizeof...(EqClasses) == 0 &&
811                                absl::conjunction<std::is_convertible<
812                                    TestNames, absl::string_view>...>::value>** =
813                  nullptr>
814    ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess, T, EqClasses...>
815    due_to(TestNames&&... test_names) && {
816      static_assert(!ExpectSuccess,
817                    "DUE_TO cannot be called when conformance is expected -- did "
818                    "you mean to use ASSERT_NONCONFORMANCE_OF?");
819    }
820    template <class Fun,
821              absl::enable_if_t<std::is_same<
822                  ResultOfGeneratorT<GeneratorType<Fun>>, T>::value>** = nullptr>
823    ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess, T, EqClasses...,
824                                             EquivalenceClassType<Fun>>
825    dont_class_directly_stateful_initializer(GeneratorType<Fun> fun) && {
826      return {
827          {std::tuple_cat(absl::move(ordered_vals.eq_classes),
828                          std::make_tuple((EquivalenceClass)(absl::move(fun))))},
829          std::move(expected_failed_tests)};
830    }
831    template <
832        class... Funs,
833        absl::void_t<absl::enable_if_t<std::is_same<
834            ResultOfGeneratorT<GeneratorType<Funs>>, T>::value>...>** = nullptr>
835    ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess, T, EqClasses...,
836                                             EquivalenceClassType<Funs...>>
837    equivalence_class(GeneratorType<Funs>... funs) && {
838      return {{std::tuple_cat(
839                  absl::move(ordered_vals.eq_classes),
840                  std::make_tuple((EquivalenceClass)(absl::move(funs)...)))},
841              std::move(expected_failed_tests)};
842    }
843    template <
844        class ProfRange,
845        absl::enable_if_t<IsProfileOrProfileRange<ProfRange>::value>** = nullptr>
846    ABSL_MUST_USE_RESULT ::testing::AssertionResult with_strict_profile(
847        ProfRange &bsol;*profile*/) {
848      ConformanceErrors test_result =
849          (ExpectRegularityImpl<
850              T, LogicalProfileOfT<ProfRange>, MinProfileOfT<ProfRange>,
851              MaxProfileOfT<ProfRange>>)(absl::move(ordered_vals));
852      return ExpectSuccess ? test_result.assertionResult()
853                           : test_result.expectFailedTests(expected_failed_tests);
854    }
855    template <class Prof, absl::enable_if_t<IsProfile<Prof>::value>** = nullptr>
856    ABSL_MUST_USE_RESULT ::testing::AssertionResult with_loose_profile(
857        Prof &bsol;*profile*/) {
858      ConformanceErrors test_result =
859          (ExpectRegularityImpl<
860              T, Prof, Prof,
861              CombineProfiles<TriviallyCompleteProfile,
862                              NothrowComparableProfile>>)(absl::
863                                                              move(ordered_vals));
864      return ExpectSuccess ? test_result.assertionResult()
865                           : test_result.expectFailedTests(expected_failed_tests);
866    }
867    OrderedEquivalenceClasses<EqClasses...> ordered_vals;
868    std::set<std::string> expected_failed_tests;
869  };
870  template <class T>
871  using ExpectConformanceOfType = ExpectConformanceOf<&bsol;*ExpectSuccess=*/true, T>;
872  template <class T>
873  using ExpectNonconformanceOfType =
874      ExpectConformanceOf<&bsol;*ExpectSuccess=*/false, T>;
875  struct EquivalenceClassMaker {
876    template <class Fun>
877    static GeneratorType<Fun> initializer(GeneratorType<Fun> fun) {
878      return fun;
879    }
880  };
881  #define ABSL_INTERNAL_ASSERT_CONFORMANCE_OF(...)                            \
882    GTEST_AMBIGUOUS_ELSE_BLOCKER_                                             \
883    if ABSL_INTERNAL_LPAREN                                                   \
884    const ::testing::AssertionResult gtest_ar =                               \
885        ABSL_INTERNAL_LPAREN ::absl::types_internal::ExpectConformanceOfType< \
886            __VA_ARGS__>()
887  #define ABSL_INTERNAL_ASSERT_NONCONFORMANCE_OF(...)                            \
888    GTEST_AMBIGUOUS_ELSE_BLOCKER_                                                \
889    if ABSL_INTERNAL_LPAREN                                                      \
890    const ::testing::AssertionResult gtest_ar =                                  \
891        ABSL_INTERNAL_LPAREN ::absl::types_internal::ExpectNonconformanceOfType< \
892            __VA_ARGS__>()
893  #define DUE_TO(...) due_to(__VA_ARGS__)
894  #define INITIALIZER(...)                         \
895    initializer(::absl::types_internal::Generator( \
896        [] { return __VA_ARGS__; }, ABSL_INTERNAL_STRINGIZE(__VA_ARGS__)))
897  #define STATEFUL_INITIALIZER(...)                         \
898    stateful_initializer(::absl::types_internal::Generator( \
899        [&] { return __VA_ARGS__; }, ABSL_INTERNAL_STRINGIZE(__VA_ARGS__)))
900  #define EQUIVALENCE_CLASS(...)                    \
901    equivalence_class(ABSL_INTERNAL_TRANSFORM_ARGS( \
902        ABSL_INTERNAL_PREPEND_EQ_MAKER, __VA_ARGS__))
903  #define WITH_LOOSE_PROFILE(...)                                      \
904    with_loose_profile(                                                \
905        ::absl::types_internal::MakeLooseProfileRangeT<__VA_ARGS__>()) \
906        ABSL_INTERNAL_RPAREN ABSL_INTERNAL_RPAREN;                     \
907    else GTEST_FATAL_FAILURE_(gtest_ar.failure_message())  
908  #define WITH_STRICT_PROFILE(...)                                      \
909    with_strict_profile(                                                \
910        ::absl::types_internal::MakeStrictProfileRangeT<__VA_ARGS__>()) \
911        ABSL_INTERNAL_RPAREN ABSL_INTERNAL_RPAREN;                      \
912    else GTEST_FATAL_FAILURE_(gtest_ar.failure_message())  
913  #define ABSL_INTERNAL_PREPEND_EQ_MAKER(arg) \
914    ::absl::types_internal::EquivalenceClassMaker().arg
915  }  
916  ABSL_NAMESPACE_END
917  }  
918  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_testing_helpers.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_testing.h</div>
                </div>
                <div class="column column_space"><pre><code>170  }
171  template <class Fun, class... T>
172  struct ForEveryTwoImpl {
173    template <class Lhs>
</pre></code></div>
                <div class="column column_space"><pre><code>784      : std::true_type {};
785  template <bool ExpectSuccess, class T, class... EqClasses>
786  struct ExpectConformanceOf {
787    template <class Fun,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    