
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &quot;memes.h&quot;
3  int TQuote::GetFq() const {
4    int fq=0;
5    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
6      fq+=TmUrlCntV[i].Cnt(); }
7    return fq;
8  }
9  int TQuote::GetFq(const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
10    int fq=0;
11    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
12      if (TmUrlCntV[i].Tm() &gt;= BegTm &amp;&amp; TmUrlCntV[i].Tm() &lt; EndTm) {
13        fq += TmUrlCntV[i].Cnt(); } 
14    }
15    return fq;
16  }
17  int TQuote::GetDoms(const TQuoteBs&amp; QtBs) const {
18    THashSet&lt;TChA&gt; DomSet;
19    for (int u = 0; u &lt; TmUrlCntV.Len(); u++) {
20      DomSet.AddKey(TStrUtil::GetDomNm(QtBs.GetStr(TmUrlCntV[u].UrlId())));
21    }
22    return DomSet.Len();
23  }
24  int TQuote::GetFq(const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
25    int fq=0;
26    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
27      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
28        fq += TmUrlCntV[i].Cnt(); } 
29    }
30    return fq;
31  }
32  int TQuote::GetFq(const TSecTm&amp; BegTm, const TSecTm&amp; EndTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
33    int fq=0;
34    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
35      if (TmUrlCntV[i].Tm() &gt;= BegTm &amp;&amp; TmUrlCntV[i].Tm() &lt;= EndTm &amp;&amp;
36       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
37        fq+=1; }
38    }
39    return fq;
40  }
41  int TQuote::GetUrls(const TSecTm&amp; BegTm, const TSecTm&amp; EndTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
42    int urls=0;
43    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
44      if (TmUrlCntV[i].Tm() &gt;= BegTm &amp;&amp; TmUrlCntV[i].Tm() &lt; EndTm &amp;&amp;
45       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
46        urls+=1; }
47    }
48    return urls;
49  }
50  TSecTm TQuote::GetPeakTm(const TTmUnit&amp; TmUnit, const TSecTm&amp; AfterTm) const {
51    TInt FreqAtPeak;
52    return GetPeakTm(TmUnit, AfterTm, FreqAtPeak);
53  }
54  TSecTm TQuote::GetPeakTm(const TTmUnit&amp; TmUnit, const TSecTm&amp; AfterTm, TInt&amp; FreqAtPeak) const {
55    const TSecTm After = AfterTm.Round(TmUnit);
56    THash&lt;TSecTm, TInt&gt; TmFqH;
57    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
58      if (TmUrlCntV[i].Tm().Round(TmUnit) &gt;= After) {
59        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); }
60    }
61    if (TmFqH.Empty()) {
62      FreqAtPeak = 0;
63      return GetPeakTm(TmUnit, TSecTm(1));
64    }
65    TmFqH.SortByDat(false);
66    FreqAtPeak = TmFqH[0];
67    return TmFqH.GetKey(0);
68  }
69  TSecTm TQuote::GetPeakTm(const TTmUnit&amp; TmUnit, const TSecTm&amp; AfterTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
70    const TSecTm After = AfterTm.Round(TmUnit);
71    THash&lt;TSecTm, TInt&gt; TmFqH;
72    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
73      if (TmUrlCntV[i].Tm().Round(TmUnit) &gt;= After &amp;&amp; (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
74        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); } 
75    }
76    if (TmFqH.Empty()) {
77      return GetPeakTm(TmUnit, TSecTm(1)); }
78    TmFqH.SortByDat(false);
79    return TmFqH.GetKey(0);
80  }
81  TSecTm TQuote::GetMeanTm(const TTmUnit&amp; TmUnit, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs, const TSecTm&amp; AfterTm) const {
82    const TSecTm After = AfterTm.Round(TmUnit);
83    double MeanTm = 0;
84    int Cnt = 0;
85    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
86      if (TmUrlCntV[i].Tm().Round(TmUnit) &gt;= After &amp;&amp; (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
87        MeanTm += TmUrlCntV[i].Tm().Round(TmUnit) * TmUrlCntV[i].Cnt();
88        Cnt += TmUrlCntV[i].Cnt();
89      }
90    }
91    return TSecTm(uint(MeanTm/double(Cnt))).Round(TmUnit);
92  }
93  TSecTm TQuote::GetMedianTm(const TTmUnit&amp; TmUnit, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs, const TSecTm&amp; AfterTm) const {
94    const TSecTm After = AfterTm.Round(TmUnit);
95    TMom Mom;
96    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
97      if (TmUrlCntV[i].Tm().Round(TmUnit) &gt;= After &amp;&amp; (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
98        Mom.Add(TmUrlCntV[i].Tm().Round(TmUnit).GetAbsSecs(), TmUrlCntV[i].Cnt());
99      }
100    }
101    Mom.Def();
102    return TSecTm(uint(Mom.GetMedian())).Round(TmUnit);
103  }
104  bool TQuote::IsSinglePeak(const TTmUnit&amp; TmUnit, const TSecTm&amp; AfterTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
105    const double PeakThresh = 0.4;
106    TTmFltPrV FqOtV, SmoothV;
107    GetFqOt(FqOtV, TmUnit, UrlTy, QtBs);
108    TQuote::GetSmoothFqOt(SmoothV, FqOtV, TmUnit, 48, 1.2, AfterTm); 
109    SmoothV.Swap(FqOtV);
110    double MaxVal=0;
111    int maxI=0, maxL=0, maxR=0;
112    for (int i = 0; i &lt; FqOtV.Len(); i++) {
113      if (MaxVal &lt; FqOtV[i].Val2) {
114        MaxVal = FqOtV[i].Val2;  maxI=i; }
115    }
116    MaxVal *= PeakThresh;
117    for (maxL = maxI; maxL&gt;0 &amp;&amp; FqOtV[maxL].Val2 &gt; MaxVal; maxL--) { }
118    for (maxR = maxI; maxR&lt;FqOtV.Len() &amp;&amp; FqOtV[maxR].Val2 &gt; MaxVal; maxR++) { }
119    if (maxR-maxL &gt; 100) { return false; }
120    for (int i = maxR; i &lt; FqOtV.Len(); i++) {
121      if (FqOtV[i].Val2 &gt; MaxVal) { return false; }
122    }
123    for (int i = maxL; i &gt;= 0; i--) {
124      if (FqOtV[i].Val2 &gt; MaxVal) { return false; }
125    }
126    return true;
127  }
128  void TQuote::GetFqOt(TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit) const {
129    THash&lt;TSecTm, TFlt&gt; TmCntH;
130    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
131      TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
132    }
133    TmCntH.SortByKey();
134    TmCntH.GetKeyDatPrV(RawFqOtV);
135  }
136  void TQuote::GetFqOt(TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
137    THash&lt;TSecTm, TFlt&gt; TmCntH;
138    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
139      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
140        TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
141      }
142    }
143    TmCntH.SortByKey();
144    TmCntH.GetKeyDatPrV(RawFqOtV);
145  }
146  void TQuote::GetFqOt(TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
147    const TSecTm RBegTm = BegTm.Round(TmUnit);
148    const TSecTm REndTm = EndTm.Round(TmUnit);
149    THash&lt;TSecTm, TFlt&gt; TmCntH;
150    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
151      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
152      if (Tm &gt;= RBegTm &amp;&amp; Tm &lt;= REndTm) {
153        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
154      }
155    }
156    TmCntH.SortByKey();
157    TmCntH.GetKeyDatPrV(RawFqOtV);
158  }
159  void TQuote::GetFqOt(TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
160    const TSecTm RBegTm = BegTm.Round(TmUnit);
161    const TSecTm REndTm = EndTm.Round(TmUnit);
162    THash&lt;TSecTm, TFlt&gt; TmCntH;
163    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
164      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
165      if (Tm &gt;= RBegTm &amp;&amp; Tm &lt;= REndTm &amp;&amp; (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
166        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
167      }
168    }
169    TmCntH.SortByKey();
170    TmCntH.GetKeyDatPrV(RawFqOtV);
171  }
172  void TQuote::GetSmoothFqOt(TTmFltPrV&amp; FqOtV, const TTmUnit&amp; TmUnit, const int&amp; WndSz, const double&amp; Smooth, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
173    TTmFltPrV RawFqOtV;
174    GetFqOt(RawFqOtV, TmUnit, BegTm, EndTm);
175    GetSmoothFqOt(FqOtV, RawFqOtV, TmUnit, WndSz, Smooth, BegTm, EndTm);
176  }
177  void TQuote::GetSmoothFqOt(TTmFltPrV&amp; SmoothFqOtV, const TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit, const int&amp; WndSz, const double&amp; Smooth, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) {
178    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
179    const int HalfWndSecs = (WndSz/2)*TmUnitSecs;
180    double FullNormConst = 1;
181    for (int j = 1; j &lt;= WndSz/2; j++) {
182      FullNormConst += 2*pow(Smooth, -j); }
183    THash&lt;TSecTm, TFlt&gt; TmCntH;
184    for (int i = 0; i &lt; RawFqOtV.Len(); i++) {
185      const TSecTm Tm = RawFqOtV[i].Val1;
186      double NormConst = FullNormConst;
187      if (Tm &lt; BegTm+HalfWndSecs || Tm+HalfWndSecs &gt; EndTm) {
188        NormConst = 1;
189        for (int j = 1; j &lt;= WndSz/2; j++) {
190          if (Tm &gt;= BegTm+j*TmUnitSecs) { NormConst += pow(Smooth, -j);  }
191          if (Tm+j*TmUnitSecs &lt;= EndTm) { NormConst += pow(Smooth, -j);  }
192      } }
193      const double NormFq = RawFqOtV[i].Val2 / NormConst;
194      for (int j = 1; j &lt;= WndSz/2; j++) {
195        const int Off = j*TmUnitSecs;
196        if (Tm+Off &lt;= EndTm) {
197          TmCntH.AddDat(TSecTm(Tm+Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
198        if (Tm &gt;= BegTm + Off) {
199          TmCntH.AddDat(TSecTm(Tm-Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
200      }
201      TmCntH.AddDat(Tm.Round(TmUnit)) += NormFq;
202    }
203    TmCntH.SortByKey();
204    TmCntH.GetKeyDatPrV(SmoothFqOtV);
205  }
206  TStr TQuote::GetDesc() const {
207    return TStr::Fmt(&quot;#:%d U:%d  %s&quot;, GetFq(), GetUrls(), QtStr.CStr());
208  }
209  void TQuote::PlotOverTm(const TStr&amp; OutFNm) {
210    TFltFltH HrCntH;
211    TmUrlCntV.Sort();
212    if (TmUrlCntV.Empty()) { return; }
213    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
214      double Hr = TSecTm(TmUrlCntV[i].Tm()-TmUrlCntV[0].Tm()).Round(tmu6Hour)/(24*3600.0);
215      HrCntH.AddDat(Hr) += TmUrlCntV[i].Cnt();
216    }
217    HrCntH.SortByKey();
218    TGnuPlot::PlotValCntH(HrCntH, OutFNm, TStr::Fmt(&quot;%d occurences, %d urls: %s&quot;, GetFq(), GetUrls(), QtStr.CStr()),
219      TStr::Fmt(&quot;Time [days] from %s&quot;, TmUrlCntV[0].Tm().GetYmdTmStr().CStr()), &quot;Frequency&quot;);
220  }
221  void TQuote::LoadQtV(const TStr&amp; InFNm, TVec&lt;TQuote&gt;&amp; QtV) {
222    PSIn SIn = TZipIn::IsZipFNm(InFNm) ? TZipIn::New(InFNm) : TFIn::New(InFNm);
223    QtV.Clr(false);
224    while (! SIn-&gt;Eof()) {
225      QtV.Add();
226      QtV.Last().Load(*SIn);
227    }
228  }
229  TQuoteBs::TQuoteBs(TSIn&amp; SIn) : StrQtIdH(SIn), QuoteH(SIn), UrlInDegH(SIn), UrlTyH(SIn) {
230    if (! SIn.Eof()) { ClustQtIdVH.Load(SIn); }
231    TIntSet CIdSet;
232    for (int q = 0; q &lt; ClustQtIdVH.Len(); q++) {
233      CIdSet.AddKey(ClustQtIdVH.GetKey(q));
234      for (int c = 0; c &lt; ClustQtIdVH[q].Len(); c++) {
235        CIdSet.AddKey(ClustQtIdVH[q][c]); } 
236      CIdSet.GetKeyV(ClustQtIdVH[q]);
237      ClustQtIdVH[q].Sort();
238      CIdSet.Clr(false);
239    }
240    Dump();
241  }
242  void TQuoteBs::Save(TSOut&amp; SOut) const {
243    StrQtIdH.Save(SOut);
244    QuoteH.Save(SOut);
245    UrlInDegH.Save(SOut);
246    UrlTyH.Save(SOut);
247    ClustQtIdVH.Save(SOut);
248  }
249  PQuoteBs TQuoteBs::New() {
250    return PQuoteBs(new TQuoteBs());
251  }
252  PQuoteBs TQuoteBs::Load(TSIn&amp; SIn) {
253    printf(&quot;loading %s...&quot;, SIn.GetSNm().CStr());
254    return PQuoteBs(new TQuoteBs(SIn));
255  }
256  void TQuoteBs::GetQtIdV(TIntV&amp; QtIdV) const {
257    QtIdV.Clr();
258    for (int q = 0; q &lt; QuoteH.Len(); q++) {
259      QtIdV.Add(QuoteH.GetKey(q)); }
260  }
261  TUrlTy TQuoteBs::GetUrlTy(const int&amp; UrlId) const {
262    if (UrlTyH.IsKey(UrlId)) {
263      return (TUrlTy) UrlTyH.GetDat(UrlId).Val; } 
264    return utBlog; 
265  }
266  void TQuoteBs::SetUrlTy(const TStr&amp; InFNm, const TUrlTy&amp; SetTy) {
267    printf(&quot;Set url type\n&quot;);
268    TStrHash&lt;TIntV&gt; DomUrlV; 
269    for (int q = 0; q &lt; Len(); q++) {
270      const TQuote::TTmUrlCntV&amp; V = GetQtN(q).TmUrlCntV;
271      for (int u = 0; u &lt; V.Len(); u++) {
272        const TChA Url = GetStr(V[u].UrlId());
273        DomUrlV.AddDat(TStrUtil::GetDomNm(Url).CStr()).Add(V[u].UrlId());
274      }
275    }
276    printf(&quot;  %d domains\n&quot;, DomUrlV.Len());
277    TStrV TyUrlV; TStr Ln;
278    if (! TFile::Exists(InFNm)) {
279      printf(&quot;!!! %s does not exist\n&quot;, InFNm.CStr());
280      return;
281    }
282    for (TFIn FIn(InFNm); FIn.GetNextLn(Ln); ) { TyUrlV.Add(Ln.GetTrunc()); }
283    printf(&quot;  %d domains with type label loaded\n&quot;, TyUrlV.Len());
284    int NDomSet=0, NUrlSet=0;
285    TExeTm ExeTm;
286    for (int d = 0; d &lt; DomUrlV.Len(); d++) {
287      for (int u = 0; u &lt; TyUrlV.Len(); u++) {
288        if (strstr(DomUrlV.GetKey(d), TyUrlV[u].CStr()) != NULL) {
289          const TIntV&amp; urlV = DomUrlV[d];
290          for (int i = 0; i &lt; urlV.Len(); i++) {
291            UrlTyH.AddDat(urlV[i], SetTy); }
292          NDomSet++;  NUrlSet+=urlV.Len();
293          break;
294        }
295      }
296      if (d % 1000 == 0) { printf(&quot;  %d/%d: labeled %d doms, %d urls [%s]\n&quot;, d, DomUrlV.Len(), NDomSet, NUrlSet, ExeTm.GetStr()); }
297    }
298    printf(&quot;  labeled %d doms, %d urls [%s]\n&quot;, NDomSet, NUrlSet, ExeTm.GetStr());
299    printf(&quot;  %d total labeled urls\n&quot;, UrlTyH.Len());
300  }
301  bool AppearsAt(const TIntSet&amp; UrlSet, const TQuote&amp; Q) {
302    for (int u = 0; u &lt; Q.GetUrls(); u++) {
303      if (UrlSet.IsKey(Q.GetUrlId(u))) { return true; }
304    }
305    return false;
306  }
307  void TQuoteBs::GetQtIdVByFq(TIntV&amp; QtIdV, const int&amp; MinWrdLen, const int&amp; MinQtFq, const bool&amp; OnlyClustRoots, const TStr&amp; HasWord, const TStr&amp; AppearsAtUrl, const TUrlTy&amp; OnlyCountTy, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
308    printf(&quot;Get top quotes from %d quotes\n&quot;, QuoteH.Len());
309    printf(&quot;  %s -- %s\n&quot;, BegTm.GetYmdTmStr().CStr(), EndTm.GetYmdTmStr().CStr());
310    TIntPrV FqQtIdV;
311    int words=0, minFq=0, hasWord=0;
312    TIntSet CSet, QSet;
313    TIntSet UrlSet;
314    if (! AppearsAtUrl.Empty()) {
315      for (int q = 0; q &lt; QuoteH.Len(); q++) {
316        const TQuote&amp; Q = GetQtN(q);
317        TQuote::TTmUrlCntV TmUrlCntV(Q.GetUrls(), 0);
318        for (int u = 0; u &lt; Q.GetUrls(); u++) {
319          if (UrlSet.IsKey(Q.GetUrlId(u))) {
320            TmUrlCntV.Add(Q.TmUrlCntV[u]);
321            continue; }
322          if (strstr(GetStr(Q.GetUrlId(u)), AppearsAtUrl.CStr())!=NULL) {
323            TmUrlCntV.Add(Q.TmUrlCntV[u]);
324            UrlSet.AddKey(Q.GetUrlId(u)); } 
325        }
326        TQuote* QPt = (TQuote*) &amp;(QuoteH[q]);
327        QPt-&gt;TmUrlCntV = TmUrlCntV; 
328      }
329    }
330    printf(&quot;done.&quot;);
331    for (int q = 0; q &lt; QuoteH.Len(); q++) {
332      const TQuote&amp; Qt = GetQtN(q);
333      if (TStrUtil::CountWords(Qt.QtStr.CStr()) &lt; MinWrdLen) { words++;  continue; }
334      if ((! HasWord.Empty()) &amp;&amp; Qt.QtStr.SearchStr(HasWord)==-1) { hasWord++;  continue; }
335      int Fq = 0;
336      if (OnlyClustRoots &amp;&amp; Qt.GetTy() == qtRoot) {
337        IAssert(Qt.GetCId() == GetQtId(q));
338        IAssert(! CSet.IsKey(Qt.GetCId()));  CSet.AddKey(Qt.GetCId());
339        if ((! HasWord.Empty()) &amp;&amp; GetQt(GetCentrQtId(Qt.GetCId())).GetStr().SearchStr(HasWord)==-1) { hasWord++; continue; } 
340        TQuote CentrQt;  GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
341        if (! UrlSet.Empty() &amp;&amp; ! AppearsAt(UrlSet, CentrQt)) { continue; }
342        Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
343        if (Fq &lt; MinQtFq) { minFq++; continue; }
344        const int Doms = CentrQt.GetDoms(*this);
345        if (Doms &lt; 3 || 5*Doms &lt; CentrQt.GetUrls()) { continue; }
346      }
347      else {
348        if (! UrlSet.Empty() &amp;&amp; ! AppearsAt(UrlSet, Qt)) { continue; }
349        Fq = Qt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
350        if (Fq &lt; MinQtFq) { minFq++; continue; }
351        const int Doms = Qt.GetDoms(*this);
352        if (Doms &lt; 3 || 4*Doms &lt; Qt.GetUrls()) { continue; }
353      }
354      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
355      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
356    }
357    printf(&quot;  skip %d : word len &lt; %d\n&quot;, words, MinWrdLen);
358    printf(&quot;  skip %d : qt fq &lt; %d\n&quot;, minFq, MinQtFq);
359    if (! HasWord.Empty()) { printf(&quot;  skip %d : not containing &#x27;%s&#x27;\n&quot;, hasWord, HasWord.CStr()); }
360    printf(&quot;  remaining %d quotes\n&quot;, FqQtIdV.Len());
361    FqQtIdV.Sort(false);
362    QtIdV.Clr(false);
363    TIntSet SeenSet;
364    for (int i = 0; i &lt; FqQtIdV.Len(); i++) {
365      if (i &lt; 100) { printf(&quot; fq:%d&quot;, FqQtIdV[i].Val1()); }
366      const int qid = FqQtIdV[i].Val2;
367      if (! SeenSet.IsKey(qid)) {
368        QtIdV.Add(qid);
369        SeenSet.AddKey(qid);
370        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
371          const TIntV&amp; ClustV = GetClust(GetQt(qid).GetCId());
372          for (int c = 0; c &lt; ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
373        }
374      }
375    }
376    printf(&quot;  return %d quotes\n&quot;, QtIdV.Len());
377  }
378  int AppearsAtDom(const TQuote&amp; CentrQt, const TIntSet&amp; GoodDom, const TIntH&amp; UrlDomH) {
379    int DomCnt = 0;
380    for (int u = 0; u &lt; CentrQt.GetUrls(); u++) {
381      const int U = CentrQt.GetUrlId(u);
382      IAssert(UrlDomH.IsKey(U));
383      if (GoodDom.IsKey(UrlDomH.GetDat(U))) { 
384        DomCnt++; }
385    }
386    return DomCnt;
387  }
388  void TQuoteBs::GetQtIdVByFq(TIntV&amp; QtIdV, const int&amp; MinWrdLen, const int&amp; MinQtFq, const TStrV&amp; FromDomains,
389                              const bool&amp; OnlyClustRoots, const TStr&amp; HasWord, int MinDoms) const {
390    printf(&quot;Get top quotes from %d quotes appearing at %d domains\n&quot;, QuoteH.Len(), FromDomains.Len());
391    TIntPrV FqQtIdV;
392    TIntH UrlDomH;
393    TStrSet DomainSet;
394    TIntSet QSet;
395    for (int q = 0; q &lt; QuoteH.Len(); q++) {
396      const TQuote&amp; Q = GetQtN(q);
397      for (int u = 0; u &lt; Q.GetUrls(); u++) {
398        const int U = Q.GetUrlId(u);
399        const int D = DomainSet.AddKey(TStrUtil::GetDomNm2(GetStr(U)));
400        UrlDomH.AddDat(U, D);
401      }
402    }
403    TIntSet GoodDom;
404    for (int d = 0; d &lt; DomainSet.Len(); d++) {
405      for (int f = 0; f &lt; FromDomains.Len(); f++) {
406        if (DomainSet[d].SearchStr(FromDomains[f]) != -1) {
407          GoodDom.AddKey(d); break; }
408      }
409    }
410    printf(&quot;%d total domains\n&quot;, DomainSet.Len());
411    printf(&quot;%d from domains\n&quot;, FromDomains.Len());
412    printf(&quot;%d good domains\n&quot;, GoodDom.Len());
413    printf(&quot;done.\n\n&quot;);
414    const TSecTm BegTm(1), EndTm(TSecTm::GetCurTm());
415    for (int q = 0; q &lt; QuoteH.Len(); q++) {
416      const TQuote&amp; Qt = GetQtN(q);
417      if (TStrUtil::CountWords(Qt.QtStr.CStr()) &lt; MinWrdLen) { continue; }
418      if ((! HasWord.Empty()) &amp;&amp; Qt.QtStr.SearchStr(HasWord)==-1) { continue; }
419      int Fq = 0;
420      if (Qt.GetTy() == qtRoot) {
421        TQuote CentrQt;
422        GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
423        if (AppearsAtDom(CentrQt, GoodDom, UrlDomH) &lt; MinDoms) { continue; }
424        Fq = CentrQt.GetFq(BegTm, EndTm, utUndef, *this);
425        if (Fq &lt; MinQtFq) { continue; }
426        const int Doms = CentrQt.GetDoms(*this);
427        if (Doms &lt; 3 || 5*Doms &lt; CentrQt.GetUrls()) { continue; }
428      }
429      else if (! OnlyClustRoots) {
430        if (AppearsAtDom(Qt, GoodDom, UrlDomH) &lt; MinDoms) { continue; }
431        Fq = Qt.GetFq(BegTm, EndTm, utUndef, *this);
432        if (Fq &lt; MinQtFq) { continue; }
433        const int Doms = Qt.GetDoms(*this);
434        if (Doms &lt; 3 || 4*Doms &lt; Qt.GetUrls()) { continue; }
435      }
436      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
437      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
438    }
439    printf(&quot;  remaining %d quotes\n&quot;, FqQtIdV.Len());
440    FqQtIdV.Sort(false);
441    QtIdV.Clr(false);
442    TIntSet SeenSet;
443    for (int i = 0; i &lt; FqQtIdV.Len(); i++) {
444      const int qid = FqQtIdV[i].Val2;
445      if (! SeenSet.IsKey(qid)) {
446        QtIdV.Add(qid);
447        SeenSet.AddKey(qid);
448        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
449          const TIntV&amp; ClustV = GetClust(GetQt(qid).GetCId());
450          for (int c = 0; c &lt; ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
451        }
452      }
453    }
454    printf(&quot;  return %d quotes\n&quot;, QtIdV.Len());
455  }
456  void TQuoteBs::GetQtIdVByTm(const int&amp; WndSzHr, const int&amp; StepHr, const int&amp; MinWrdLen, const int&amp; MinQtFq, const int&amp; TakePerStep) const {
457    const TTmUnit TmUnit = tmu4Hour;
458    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
459    MinTm=MinTm.Round(TmUnit); MaxTm=MaxTm.Round(TmUnit);
460    printf(&quot;Dataset span %s -- %s\n&quot;, MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
461    printf(&quot;  time window %dh, step size %dh, min wrd len %d, take top %d per step\n&quot;, WndSzHr, StepHr, MinWrdLen, TakePerStep);
462    TIntSet TopQtIdSet;
463    TIntV TopQtIdV;
464    int cnt=0;
465    FILE *F = fopen(&quot;top_qts_per_time_unit.txt&quot;, &quot;wt&quot;);
466    for (TSecTm Tm=MinTm; Tm &lt;= MaxTm; Tm += StepHr*3600, cnt++) {
467      GetQtIdVByFq(TopQtIdV, MinWrdLen, MinQtFq, true, &quot;&quot;, &quot;&quot;, utUndef, TSecTm(Tm), TSecTm(Tm+StepHr*3600));
468      fprintf(F,&quot;week of: %s\n&quot;, Tm.GetYmdTmStr().CStr());
469      for (int q = 0, j=0; q &lt; TopQtIdV.Len() &amp;&amp; j&lt;3; q++) {
470        if (! TopQtIdSet.IsKey(TopQtIdV[q])) {
471          fprintf(F, &quot;%s\t%d\n&quot;, GetQt(GetCentrQtId(TopQtIdV[q])).GetStr().CStr(), GetClustFq(TopQtIdV[q]));
472          j++; }
473        TopQtIdSet.AddKey(TopQtIdV[q]);
474      }
475      fprintf(F, &quot;\n&quot;);
476    }
477    fclose(F);
478    printf(&quot;  done %d quotes\n&quot;, TopQtIdSet.Len());
479  }
480  void TQuoteBs::GetCIdVByFq(TIntV&amp; CIdV, const int&amp; MinClFq, const TStr&amp; RootHasWord, const TUrlTy&amp; OnlyCountTy, const bool&amp; OnlyAfterRoot, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
481    printf(&quot;Get top clusters from %d clusters\n&quot;, GetClusts());
482    TIntPrV FqCIdV;
483    for (int c = 0; c &lt; GetClusts(); c++) {
484      const int CId = GetCId(c);
485      if ( ! IsQtId(CId)) { printf(&quot;!!! %d:%d\n&quot;, c, CId); continue; }
486      IAssert(GetQt(CId).GetTy()==qtRoot);
487      const int CentrQId = GetCentrQtId(CId);
488      if (CentrQId == -1) { continue; }
489      if ((! RootHasWord.Empty()) &amp;&amp; GetQt(CentrQId).GetStr().SearchStr(RootHasWord)==-1) { continue; } 
490      TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, OnlyAfterRoot); 
491      const int Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
492      if (Fq &lt; MinClFq) { continue; }
493      FqCIdV.Add(TIntPr(Fq, CId));
494    }
495    printf(&quot;  remaining %d clusters\n&quot;, FqCIdV.Len());
496    FqCIdV.Sort(false);
497    CIdV.Clr(false);
498    for (int i = 0; i &lt; FqCIdV.Len(); i++) {
499      CIdV.Add(FqCIdV[i].Val2); }
500  }
501  void TQuoteBs::GetMinMaxTm(TSecTm&amp; MinTm, TSecTm&amp; MaxTm) const {
502    MinTm = MaxTm = TSecTm();
503    for (int q = 0; q &lt; QuoteH.Len(); q++) {
504      const TQuote::TTmUrlCntV&amp; V = QuoteH[q].TmUrlCntV;
505      if (V.Empty()) { continue; }
506      if (! MinTm.IsDef() || MinTm &gt; V[0].Tm()) {
507        MinTm = V[0].Tm(); }
508      if (! MaxTm.IsDef() || MaxTm &lt; V[0].Tm()) {
509        MaxTm = V[0].Tm(); }
510    }
511  }
512  void TQuoteBs::GetMinMaxTm(const TIntV&amp; QtIdV, TSecTm&amp; MinTm, TSecTm&amp;MaxTm) const {
513    MinTm = MaxTm = TSecTm();
514    for (int q = 0; q &lt; QtIdV.Len(); q++) {
515      const TQuote::TTmUrlCntV&amp; V = GetQt(QtIdV[q]).TmUrlCntV;
516      if (V.Empty()) { continue; }
517      if (! MinTm.IsDef() || MinTm &gt; V[0].Tm()) {
518        MinTm = V[0].Tm(); }
519      if (! MaxTm.IsDef() || MaxTm &lt; V[0].Tm()) {
520        MaxTm = V[0].Tm(); }
521    }
522  }
523  void TQuoteBs::GetQtPageUrl(const TIntV&amp; QtIdV, TIntH&amp; QtUrlIdH) const {
524    THash&lt;TChA, TInt&gt; DomQtCntH;
525    for (int q = 0; q &lt; Len(); q++) {
526      const TQuote&amp; Q = GetQtN(q);
527      for (int u = 0; u &lt; Q.GetUrls(); u++) {
528        DomQtCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += Q.TmUrlCntV[u].Cnt(); }
529    }
530    const TStr StopList = &quot;blog.myspace.com|www.newsmeat.com|us.rd.yahoo.com|www.startribune.com|&quot;
531      &quot;news.originalsignal.com|uk.news.yahoo.com|ap.google.com|www.cnn.com|www.opednews.com&quot;;
532    TStrV StopListV; StopList.SplitOnAllCh(&#x27;|&#x27;, StopListV);
533    for (int s = 0; s &lt; StopListV.Len(); s++) {
534      DomQtCntH.AddDat(StopListV[s]) = 1; }
535    DomQtCntH.SortByDat(false);
536    QtUrlIdH.Clr(false);
537    for (int q = 0; q &lt; QtIdV.Len(); q++) {
538      const TQuote&amp; Q = GetQt(QtIdV[q]);
539      int DomFq=0, BestUrlId=0;
540      for (int u = 0; u &lt; Q.TmUrlCntV.Len(); u++) {
541        const TChA Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
542        if (DomFq &lt; DomQtCntH.GetDat(Dom)) {
543          DomFq = DomQtCntH.GetDat(Dom);
544          BestUrlId = Q.TmUrlCntV[u].UrlId();
545        }
546      }
547      QtUrlIdH.AddDat(QtIdV[q], BestUrlId);
548    }
549  }
550  void TQuoteBs::AddQuote(const TQuote&amp; Quote, const TQuoteBs&amp; CurQtBs) {
551    const int QtId = CurQtBs.GetQtId(Quote.GetStr().CStr());
552    TQuote&amp; Qt = QuoteH.AddDat(QtId);
553    StrQtIdH.AddDat(Quote.GetStr().CStr(), QtId);
554    Qt.QtCIdTy = TQuote::TQtIdTy(Quote.GetCId(), Quote.GetTy());
555    Qt.QtStr = Quote.QtStr;
556    Qt.TmUrlCntV = Quote.TmUrlCntV;
557    for (int u = 0; u &lt; Qt.TmUrlCntV.Len(); u++) {
558      Qt.TmUrlCntV[u].SetUrlId(AddStr(CurQtBs.GetStr(Quote.TmUrlCntV[u].UrlId())));
559    }
560  }
561  void TQuoteBs::AddQuote(const TVec&lt;TChA&gt;&amp; QuoteV, const TVec&lt;TChA&gt;&amp; LinkV, const TChA&amp; PostUrlStr, const TSecTm&amp; PubTm, const int&amp; MinQtWrdLen) {
562    TIntH QtCntH; 
563    for (int q = 0; q &lt; QuoteV.Len(); q++) {
564      if (TStrUtil::CountWords(QuoteV[q].CStr()) &lt; MinQtWrdLen) { continue; } 
565      int QtId = GetQtId(QuoteV[q].CStr());
566      if (QtId == -1) { 
567        IAssert(! IsStr(QuoteV[q].CStr()));
568        QtId = QuoteH.Len();
569        TQuote&amp; Qt = QuoteH.AddDat(QtId);
570        Qt.QtCIdTy = TQuote::TQtIdTy(QtId, qtQuote);
571        Qt.QtStr = QuoteV[q];
572        StrQtIdH.AddDat(QuoteV[q].CStr(), QtId);
573      } else { IAssert(IsStr(QuoteV[q].CStr())); }
574      IAssert(IsQtId(QtId));
575      QtCntH.AddDat(QtId) += 1; 
576    }
577    if (QtCntH.Len() &gt; 0) {
578      const int PostUrlId = AddStr(PostUrlStr);
579      for (int i = 0; i &lt; QtCntH.Len(); i++) {
580        QuoteH.GetDat(QtCntH.GetKey(i)).TmUrlCntV.Add(TQuote::TTmUrlCnt(PubTm, PostUrlId, QtCntH[i]));
581      }
582    }
583    const TChA PostDomain = TStrUtil::GetDomNm(PostUrlStr);
584    for (int l = 0; l &lt; LinkV.Len(); l++) {
585      const TChA&amp; Url = LinkV[l];
586      if (TStrUtil::GetDomNm(Url) == PostDomain) { continue; } 
587      if (IsStr(Url.CStr())) { UrlInDegH.AddDat(GetStrId(Url.CStr())) += 1; }
588    }
589  }
590  PQuoteBs TQuoteBs::GetQuoteBs(const TIntV&amp; QtIdV) const {
591    PQuoteBs _NewQtBs = TQuoteBs::New();
592    TQuoteBs&amp; NewQtBs = *_NewQtBs;
593    for (int q = 0; q &lt; QtIdV.Len(); q++) {
594      const TQuote&amp; Qt = GetQt(QtIdV[q]);
595      NewQtBs.AddQuote(Qt, *this);
596    }
597    for (int u = 0; u &lt; UrlInDegH.Len(); u++) {
598      const char* UrlStr = GetStr(UrlInDegH.GetKey(u));
599      if (NewQtBs.IsStr(UrlStr)) {
600        NewQtBs.UrlInDegH.AddDat(NewQtBs.GetStrId(UrlStr), UrlInDegH[u]); }
601    }
602    for (int t = 0; t &lt; UrlTyH.Len(); t++) {
603      const char* UrlStr = GetStr(UrlTyH.GetKey(t));
604      if (NewQtBs.IsStr(UrlStr)) {
605        NewQtBs.UrlTyH.AddDat(NewQtBs.GetStrId(UrlStr), UrlTyH[t]); }
606    }
607    for (int c = 0; c &lt; GetClusts(); c++) {
608      const int CId = GetCId(c);
609      if ( ! IsQtId(CId)) { printf(&quot;!!! %d:%d\n&quot;, c, CId); continue; }
610      const TIntV&amp; CQtIdV = GetClust(CId);
611      if (NewQtBs.IsQtId(CId)) {
612        IAssert(! NewQtBs.ClustQtIdVH.IsKey(CId));
613        TIntV&amp; CIdV = NewQtBs.ClustQtIdVH.AddDat(CId);
614        for (int i = 0; i &lt; CQtIdV.Len(); i++) {
615          if (NewQtBs.IsQtId(CQtIdV[i])) { CIdV.Add(CQtIdV[i]); }
616        }
617        IAssert(CIdV.Len() &gt; 0);
618      }
619    }
620    return _NewQtBs;
621  }
622  int TQuoteBs::GetQtsInClust() const {
623    int qts = 0;
624    for (int q = 0; q &lt; ClustQtIdVH.Len(); q++) {
625      qts += ClustQtIdVH[q].Len();
626    }
627    return qts;
628  }
629  int TQuoteBs::GetClustFq(const int&amp; CId) const {
630    int fq = 0;
631    TIntSet S;
632    const TIntV&amp; ClustV = ClustQtIdVH.GetDat(CId);
633    for (int c = 0; c &lt; ClustV.Len(); c++) {
634      fq += GetQt(ClustV[c]).GetFq();
635      IAssert(! S.IsKey(ClustV[c]));
636      S.AddKey((ClustV[c]));
637    }
638    return fq;
639  }
640  int TQuoteBs::GetClustFq(const int&amp; CId, const TUrlTy&amp; UrlTy) const {
641    int fq = 0;
642    const TIntV&amp; ClustV = ClustQtIdVH.GetDat(CId);
643    for (int c = 0; c &lt; ClustV.Len(); c++) {
644      fq += GetQt(ClustV[c]).GetFq(UrlTy, *this);
645    }
646    return fq;
647  }
648  int TQuoteBs::GetCentrQtId(const int&amp; CId) const {
649    return GetCentrQtId(GetClust(CId));
650  }
651  int TQuoteBs::GetCentrQtId(const TIntV&amp; ClustV) const {
652    TIntPrV QtFqIdV;
653    for (int c = 0; c &lt; ClustV.Len(); c++) {
654      if (! IsQtId(ClustV[c])) { continue; }
655      const TQuote&amp; Q = GetQt(ClustV[c]);
656      QtFqIdV.Add(TIntPr(Q.GetUrls(), ClustV[c]));
657    }
658    if (QtFqIdV.Empty()) { return -1; }
659    QtFqIdV.Sort(false);
660    const TStr FqStr = GetQt(QtFqIdV[0].Val2).GetStr(); 
661    for (int c = 0; c &lt; QtFqIdV.Len(); c++) {
662      IAssert(IsQtId(QtFqIdV[c].Val2));
663      const TQuote&amp; Q = GetQt(QtFqIdV[c].Val2);
664      const int Words = TStrUtil::CountWords(Q.GetStr().CStr());
665      if (Words &gt;= 6 &amp;&amp; Words &lt; 50 &amp;&amp; strstr(Q.GetStr().CStr(), FqStr.CStr())!=NULL) {
666        return QtFqIdV[c].Val2; }
667    }
668    return QtFqIdV[0].Val2;
669  }
670  void TQuoteBs::GetMergedClustQt(const int&amp; CId, TQuote&amp; NewQt, const bool&amp; OnlyAfterBegTm) const {
671    const TIntV&amp; ClustV = GetClust(CId);
672    GetMergedClustQt(ClustV, NewQt, OnlyAfterBegTm);
673  }
674  void TQuoteBs::GetMergedClustQt(const TIntV&amp; ClustV, TQuote&amp; NewQt, const bool&amp; OnlyAfterBegTm) const {
675    const int CentrQtId = GetCentrQtId(ClustV);
676    const TSecTm BegTm = OnlyAfterBegTm ? GetClustBegTm(ClustV, CentrQtId) : TSecTm(1);
677    THash&lt;TPair&lt;TSecTm, TInt&gt;, TInt&gt; TmUrlCntH;
678    for (int c = 0; c &lt; ClustV.Len(); c++) {
679      const TQuote&amp; Q = GetQt(ClustV[c]);
680      for (int u = 0; u &lt; Q.TmUrlCntV.Len(); u++) {
681        if (Q.TmUrlCntV[u].Tm() &gt;= BegTm) {
682          TmUrlCntH.AddDat(TPair&lt;TSecTm, TInt&gt;(Q.TmUrlCntV[u].Tm(), Q.TmUrlCntV[u].UrlId())) += Q.TmUrlCntV[u].Cnt(); }
683      }
684    }
685    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
686    NewQt.QtStr = GetQt(CentrQtId).GetStr(); 
687    if (! TmUrlCntH.Empty()) {
688      NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
689      for (int u = 0; u &lt; TmUrlCntH.Len(); u++) {
690        NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
691      }
692      NewQt.TmUrlCntV.Sort();
693    }
694  }
695  TSecTm TQuoteBs::GetClustBegTm(const int&amp; CId, const int&amp; CentrQtId) const {
696    const TIntV&amp; ClustV = GetClust(CId);
697    return GetClustBegTm(ClustV, CentrQtId);
698  }
699  TSecTm TQuoteBs::GetClustBegTm(const TIntV&amp; ClustV, const int&amp; CentrQtId) const {
700    TStrHash&lt;TInt&gt; StrH;
701    TIntV CntrWIdV, WIdV;
702    int WIdV1Start, WIdV2Start, SkipId;
703    TStrUtil::GetAddWIdV(StrH, GetQt(CentrQtId).GetStr().CStr(), CntrWIdV);
704    TSecTm BegTm = TSecTm::GetCurTm();
705    for (int c = 0; c &lt; ClustV.Len(); c++) {
706      TStrUtil::GetAddWIdV(StrH, GetQt(ClustV[c]).GetStr().CStr(), WIdV);
707      if (WIdV.Len() &lt; CntrWIdV.Len()) { continue; }
708      const int Overlap = LongestCmnSubSq(CntrWIdV, WIdV, WIdV1Start, WIdV2Start, SkipId);
709      if (Overlap &gt;= CntrWIdV.Len() &amp;&amp; SkipId==0) { 
710        if (GetQt(ClustV[c]).TmUrlCntV.Empty()) { continue; }
711        BegTm = TMath::Mn(BegTm, GetQt(ClustV[c]).TmUrlCntV[0].Tm()); 
712      }
713    }
714    return BegTm;
715  }
716  int TQuoteBs::LongestCmnSubSq(const TIntV&amp; WIdV1, const TIntV&amp; WIdV2, int&amp; WIdV1Start, int&amp; WIdV2Start, int&amp; SkipId) {
717    const TIntV&amp; V1 = WIdV1.Len()&gt;WIdV2.Len() ? WIdV1:WIdV2; 
718    const TIntV&amp; V2 = WIdV1.Len()&gt;WIdV2.Len() ? WIdV2:WIdV1; 
719    const int V1Len = V1.Len();
720    const int V2Len = V2.Len();
721    static THash&lt;TInt, TIntV&gt; WIdPosH;
722    static THashSet&lt;TInt&gt; V2WIdSet;
723    V2WIdSet.Clr(false);
724    for (int i=0; i &lt; WIdPosH.Len(); i++) { WIdPosH[i].Clr(false); }
725    WIdPosH.Clr(false, -1, false);
726    WIdV1Start = WIdV2Start = SkipId = 0;
727    for (int i = 0; i &lt; V2Len; i++) { 
728      V2WIdSet.AddKey(V2[i]); }
729    for (int i = 0; i &lt; V1Len; i++) { 
730      if (V2WIdSet.IsKey(V1[i])) { WIdPosH.AddDat(V1[i]).Add(i); } }
731    {const int cmnWords = WIdPosH.Len();
732    if (cmnWords &lt; V2WIdSet.Len()) {
733      if (cmnWords &lt; 4) { return 0; }
734      else if (V2Len &gt;= 5 &amp;&amp; cmnWords &lt; 5) { return 0; }
735      else if (V2Len &gt; 6 &amp;&amp; (2*cmnWords &lt; V2Len &amp;&amp; cmnWords &lt; 10)) { return 0; } }
736    }
737    int MaxLen = 0;
738    for (int w = 0; w &lt; V2Len; w++) { 
739      const int wid = V2[w];
740      if (! WIdPosH.IsKey(wid)) { continue; }
741      const TIntV&amp; OccV = WIdPosH.GetDat(wid);
742      for (int o = 0; o &lt; OccV.Len(); o++) {
743        const int beg = OccV[o];
744        int cnt = 0, tmp = 0;
745        while (w+cnt &lt; V2Len &amp;&amp; beg+cnt &lt; V1Len &amp;&amp; V2[w+cnt]==V1[beg+cnt]) { cnt++; tmp=0; }           
746        while (beg+1+cnt &lt; V1Len &amp;&amp; w+cnt &lt; V2Len &amp;&amp; V2[w+cnt]==V1[beg+cnt+1]) { cnt++; tmp=-1; }      
747        while (beg+cnt+1 &lt; V1Len &amp;&amp; w+cnt+1 &lt; V2Len &amp;&amp; V2[w+cnt+1]==V1[beg+cnt+1]) {  cnt++; tmp=-2;}  
748        while (beg+cnt &lt; V1Len &amp;&amp; w+cnt+1 &lt; V2Len &amp;&amp; V2[w+cnt+1]==V1[beg+cnt]) { cnt++; tmp=-3;}       
749        if (MaxLen &lt; cnt) { MaxLen = cnt; SkipId=tmp; WIdV1Start = beg;  WIdV2Start = w; }
750        IAssert(cnt &gt;= 1);
751      }
752    }
753    if (! (WIdV1.Len()&gt;WIdV2.Len())) {
754      int tmp=WIdV1Start; WIdV1Start=WIdV2Start; WIdV2Start=tmp;
755    }
756    return MaxLen;
757  }
758  void TQuoteBs::CreateClusters(const TVec&lt;TIntV&gt;&amp; ClustV) {
759    TIntV CIdV;
760    ClustQtIdVH.Clr();
761    printf(&quot;len %d\n&quot;, Len());
762    for (int q = 0; q &lt; Len(); q++) {
763      TQuote&amp; Q = GetQt(q);
764      Q.QtCIdTy = TQuote::TQtIdTy(q, qtQuote);
765    }
766    TIntH SeenNId;
767    for (int c = 0; c &lt; ClustV.Len(); c++) {
768      if (ClustV[c].Len() &lt; 3) { continue; } 
769      const int CentrQtId = GetCentrQtId(ClustV[c]);
770      if (CentrQtId == -1) {
771        printf(&quot;Cluster %d of size %d has no root!!!\n&quot;, c, ClustV[c].Len());
772        for (int i = 0; i &lt; ClustV[c].Len(); i++) {
773          printf(&quot;  %d%c&quot;, ClustV[c][i].Val, IsQtId(ClustV[c][i])?&#x27;t&#x27;:&#x27;f&#x27;); } printf(&quot;\n&quot;);
774        continue;
775      }
776      IAssert(! SeenNId.IsKey(CentrQtId));
777      SeenNId.AddKey(CentrQtId);
778      TQuote&amp; Q = GetQt(CentrQtId);
779      if (Q.GetTy() != qtQuote) { printf(&quot;  %d&quot;, Q.GetTy()); }
780      IAssert(! ClustQtIdVH.IsKey(CentrQtId));
781      Q.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtRoot);
782      ClustQtIdVH.AddDat(CentrQtId, ClustV[c]);
783      for (int q = 0; q &lt; ClustV[c].Len(); q++) {
784        if (ClustV[c][q] == CentrQtId) { continue; }
785        IAssert(! SeenNId.IsKey(ClustV[c][q]));
786        SeenNId.AddKey(ClustV[c][q]);
787        TQuote&amp; Q2 = GetQt(ClustV[c][q]);
788        Q2.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtInClust);
789      }
790    }
791  }
792  void TQuoteBs::ClusterQts(const int&amp; MinRootWrdLen, const int&amp; MinQtFq, const TStr&amp; OutFNmPref, const TStrV&amp; BlackListV) {
793    printf(&quot;Cluster quotes with min Fq &gt;= %d: %d total quotes\n&quot;, MinQtFq, Len());
794    TExeTm ExeTm;
795    TStrHash&lt;TInt&gt; StrH;
796    TVec&lt;TPair&lt;TInt, TIntV&gt; &gt; QWIdVV;  
797    { TIntPrV LenQIdV;  TIntV QWIdV;
798    printf(&quot;sort qid by len\n&quot;);
799    TStrHash&lt;TInt&gt; BlackListH;
800    for (int i = 0; i &lt; BlackListV.Len(); i++) { BlackListH.AddDatId(BlackListV[i].GetTrunc()); }
801    printf(&quot;blacklist len: %d\n&quot;, BlackListH.Len());
802    for (int q1 = 0; q1 &lt; Len(); q1++) {
803      const TQuote&amp; Q = GetQtN(q1);
804      const int Doms = Q.GetDoms(*this);
805      if ((Q.GetTy()==qtQuote || Q.GetTy()==qtRoot) &amp;&amp; Doms&gt;1 &amp;&amp; Doms*4&gt;Q.GetUrls()
806        &amp;&amp; Q.GetFq() &gt;= MinQtFq &amp;&amp; (! BlackListH.IsKey(Q.GetStr().CStr()))) { 
807          LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1))); }
808    }
809    printf(&quot;sort %d candidates\n&quot;, LenQIdV.Len());
810    LenQIdV.Sort(false);
811    printf(&quot;get word id vectors\n&quot;);
812    for (int q1 = 0; q1 &lt; LenQIdV.Len(); q1++) {
813      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
814      QWIdVV.Add(TPair&lt;TInt, TIntV&gt;(LenQIdV[q1].Val2, QWIdV));
815    } }
816    printf(&quot;  %d root quotes\n&quot;, ClustQtIdVH.Len());
817    printf(&quot;  %d quotes to merge\n&quot;, QWIdVV.Len());
818    int NMergers=0;
819    FILE *F = fopen(TStr(OutFNmPref+&quot;-merged.txt&quot;).CStr(), &quot;wt&quot;);
820    const int ClusterQ=QWIdVV.Len();
821    for (int q1 = 0; q1 &lt; ClusterQ; q1++) {
822      if (QWIdVV[q1].Val2.Len() &lt; MinRootWrdLen) { continue; } 
823      const int Qt1Id = QWIdVV[q1].Val1;
824      for (int q2 = q1+1; q2 &lt; ClusterQ; q2++) {
825        int idx1=0, idx2=0, SkipTy=0;
826        bool DoMerge = false;
827        const int ShortLen = TMath::Mn(QWIdVV[q1].Val2.Len(), QWIdVV[q2].Val2.Len());
828        if (ShortLen == 0) { continue; }
829        const int Overlap = LongestCmnSubSq(QWIdVV[q1].Val2, QWIdVV[q2].Val2, idx1, idx2, SkipTy);
830        if (ShortLen == 4 &amp;&amp; Overlap == 4 &amp;bsol;*&amp;&amp; SkipTy==0*/) { DoMerge=true; } 
831        else if (ShortLen == 5 &amp;&amp; Overlap == 5 &amp;bsol;*&amp;&amp; SkipTy==0*/) { DoMerge=true; } 
832        else if ((ShortLen == 6 &amp;&amp; Overlap &gt;= 5 &amp;bsol;*&amp;&amp; SkipTy==0) || (ShortLen == 6 &amp;&amp; Overlap == 5*/)) { DoMerge=true; }
833        else if (Overlap/double(ShortLen+3) &gt; 0.5 || Overlap &gt; 10) { DoMerge=true; }
834        if (DoMerge == true) {
835          NMergers++;
836          const int Qt2Id = QWIdVV[q2].Val1;
837          TQuote&amp; Q1 = GetQt(Qt1Id);
838          TQuote&amp; Q2 = GetQt(Qt2Id);
839          if (Q1.GetTy() != qtRoot) { 
840            IAssert(Q1.GetTy() == qtQuote);
841            IAssert(! ClustQtIdVH.IsKey(Qt1Id));
842            ClustQtIdVH.AddDat(Qt1Id).Add(Qt1Id);
843            Q1.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtRoot);
844          } else { IAssert(Q1.GetTy() == qtRoot); }
845          if (Q2.GetTy() == qtRoot) { 
846            for (int c = 0; c &lt; ClustQtIdVH.GetDat(Qt2Id).Len(); c++) {
847              ClustQtIdVH.AddDat(Qt1Id).Add(ClustQtIdVH.GetDat(Qt2Id)[c]); }
848            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
849            ClustQtIdVH.DelKey(Qt2Id);
850            IAssert(ClustQtIdVH.AddDat(Qt1Id).IsIn(Qt2Id));
851          } else {
852            IAssert(Q2.GetTy() == qtQuote);
853            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
854            ClustQtIdVH.AddDat(Qt1Id).Add(Qt2Id);
855          }
856          QWIdVV[q2].Val2.Clr(true); 
857          { TStr Str= &quot;    :&quot;; if(SkipTy==-1){Str=&quot;long=&quot;;} else if(SkipTy==-2){Str=&quot;both=&quot;;} else if(SkipTy==-3){Str=&quot;shrt=&quot;;}
858          if (Str.Len()&gt;0) { printf(&quot;%c&quot;, Str[0]); }
859          if (ClustQtIdVH.GetDat(Qt1Id).Len() == 2) { fprintf(F, &quot;\n[%d] %s \t%d\n&quot;, TStrUtil::CountWords(Q1.QtStr.CStr()), Q1.QtStr.CStr(), Q1.GetFq()); }
860          fprintf(F, &quot;%s%d [%d] %s \t%d\n&quot;, Str.CStr(), Overlap, TStrUtil::CountWords(Q2.QtStr.CStr()), Q2.QtStr.CStr(), Q2.GetFq()); }
861        }
862      }
863      if (ClustQtIdVH.IsKey(Qt1Id)) {
864        ClustQtIdVH.GetDat(Qt1Id).Pack();
865        ClustQtIdVH.GetDat(Qt1Id).Sort();
866        QWIdVV[q1].Val2.Clr(true);
867      }
868      if (q1&gt;0 &amp;&amp; q1 % 100 == 0) {
869        printf(&quot;\r  %d/%d: %d merged [%s]  &quot;, q1, ClusterQ, NMergers, ExeTm.GetStr());
870        if (q1 % 1000 == 0) { printf(&quot;save.\n&quot;);  fflush(F);
871          TFOut FOut(OutFNmPref+&quot;-QtBs.ClustQtIdVH&quot;); ClustQtIdVH.Save(FOut); }
872      }
873    }
874    fclose(F);
875    printf(&quot;\n%d quotes, %d clusters [%s]\n\n.&quot;, NMergers, ClustQtIdVH.Len(), ExeTm.GetStr());
876  }
877  void TQuoteBs::ResetClusters() {
878    ClustQtIdVH.Clr();
879    for (int q = 0; q &lt; Len(); q++) {
880      GetQtN(q).QtCIdTy = TQuote::TQtIdTy(GetQtId(q), qtQuote);
881    }
882  }
883  void TQuoteBs::ReassignToClust(const int&amp; QtId, const int&amp; NewCId) {
884    const int QtCl = GetQt(QtId).GetCId();
885    printf(&quot;assign %d from clust %d to %d\n&quot;, QtId, QtCl, NewCId);
886    if (QtCl != QtId) {
887      ClustQtIdVH.GetDat(QtCl).DelIfIn(QtId); }
888    GetQt(QtId).QtCIdTy = TQuote::TQtIdTy(NewCId, qtInClust);
889    ClustQtIdVH.AddDat(NewCId).Add(QtId);
890  }
891  void TQuoteBs::Mergec2Clusters(const int&amp; ParentCId, const int&amp; ChildCId) {
892    IAssert(IsClust(ParentCId) &amp;&amp; IsClust(ChildCId));
893    printf(&quot;merging %d (fq: %d) to %d (%d fq)\n&quot;, ChildCId, GetClustFq(ChildCId), ParentCId, GetClustFq(ParentCId));
894    TIntSet ClustSet;
895    { const TIntV&amp; ClustV = GetClust(ParentCId);
896    for (int c = 0; c &lt; ClustV.Len(); c++) {
897      ClustSet.AddKey(ClustV[c]); } }
898    { const TIntV&amp; ClustV = GetClust(ChildCId);
899    for (int c = 0; c &lt; ClustV.Len(); c++) {
900      ClustSet.AddKey(ClustV[c]); } }
901    ClustSet.GetKeyV(ClustQtIdVH.GetDat(ParentCId));
902    GetQt(ChildCId).QtCIdTy = TQuote::TQtIdTy(ChildCId, qtInClust);
903    ClustQtIdVH.DelKey(ChildCId);
904    ClustQtIdVH.Defrag();
905  }
906  PClustNet TQuoteBs::GetClustNet(const int&amp; MinQtFq, const TStr&amp; OutFNmPref) const {
907    printf(&quot;Cluster quotes with Fq &gt;= %d: %d total quotes\n&quot;, MinQtFq, Len());
908    TExeTm ExeTm;
909    TStrHash&lt;TInt&gt; StrH;
910    FILE *F = fopen(TStr(OutFNmPref+&quot;-candidates.txt&quot;).CStr(), &quot;wt&quot;);
911    THash&lt;TInt, TIntV&gt; QWIdVH;  
912    { TIntPrV LenQIdV;  TIntV QWIdV;
913    printf(&quot;sort qid by len\n&quot;);
914    for (int q1 = 0; q1 &lt; Len(); q1++) {
915      const TQuote&amp; Q = GetQtN(q1);
916      const int Doms = Q.GetDoms(*this);
917      if ((Q.GetTy()!=qtCentr) &amp;&amp; Doms&gt;1 &amp;&amp; Doms*4 &gt; Q.GetUrls() &amp;&amp; Q.GetFq() &gt;= MinQtFq) { 
918        LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1)));
919      }
920    }
921    printf(&quot;sort %d candidates by word length\n&quot;, LenQIdV.Len());
922    LenQIdV.Sort(false);
923    for (int q1 = 0; q1 &lt; LenQIdV.Len(); q1++) {
924      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
925      QWIdVH.AddDat(LenQIdV[q1].Val2, QWIdV);
926      fprintf(F, &quot;%s\n&quot;, GetQt(LenQIdV[q1].Val2).QtStr.CStr());
927    } }
928    printf(&quot;  %d root quotes\n&quot;, ClustQtIdVH.Len());
929    printf(&quot;  %d quotes to merge\n&quot;, QWIdVH.Len());
930    const int ClusterQ=QWIdVH.Len();
931    PClustNet ClustNet = TClustNet::New();
932    TIntH NIdDepthH;
933    TIntSet SeenQtIdSet;
934    int NMerges=0, idx1=0, idx2=0, SkipTy=0; 
935    for (int q1 = 0; q1 &lt; ClusterQ; q1++) { 
936      SeenQtIdSet.Clr(false);
937      const int Qt1Id = QWIdVH.GetKey(q1);
938      for (int q2 = q1-1; q2 &gt;= 0; q2--) { 
939        const int Qt2Id = QWIdVH.GetKey(q2);
940        if (SeenQtIdSet.IsKey(Qt2Id)) { continue; }
941        bool DoMerge = false;
942        const int Overlap = LongestCmnSubSq(QWIdVH[q1], QWIdVH[q2], idx1, idx2, SkipTy);
943        const int ShortLen = QWIdVH[q1].Len(); IAssert(QWIdVH[q1].Len()&lt;= QWIdVH[q2].Len());
944        if (ShortLen == 4 &amp;&amp; Overlap == 4) { DoMerge=true; } 
945        else if (ShortLen == 5 &amp;&amp; Overlap == 5) { DoMerge=true; } 
946        else if (ShortLen == 6 &amp;&amp; Overlap &gt;= 5) { DoMerge=true; }
947        else if (Overlap/double(ShortLen+3) &gt; 0.5 || Overlap &gt; 10) { DoMerge=true; }
948        if (DoMerge==true) { NMerges++;
949          if (! ClustNet-&gt;IsNode(Qt1Id)) { ClustNet-&gt;AddNode(Qt1Id, GetQt(Qt1Id)); }
950          if (! ClustNet-&gt;IsNode(Qt2Id)) { ClustNet-&gt;AddNode(Qt2Id, GetQt(Qt2Id)); }
951          ClustNet-&gt;AddEdge(Qt1Id, Qt2Id);
952          SeenQtIdSet.AddKey(Qt1Id);  SeenQtIdSet.AddKey(Qt2Id);
953          fprintf(F, &quot;%d Merge\t%d\t%d\ttree\t%d\n\t%s\n\t%s\n&quot;, q1, QWIdVH[q1].Len(), QWIdVH[q2].Len(), NIdDepthH.Len(), GetQt(Qt2Id).GetStr().CStr(), GetQt(Qt1Id).GetStr().CStr());
954          fflush(F);
955        }
956      }
957      if (q1&gt;0 &amp;&amp; q1 % 100 == 0) {
958        printf(&quot;\r  %d/%d: %d merged [%s]  &quot;, q1, ClusterQ, NMerges, ExeTm.GetStr());
959        if (q1 % 1000 == 0) {
960          printf(&quot;save: %d merges, %d nodes, %d edges in ClustNet [%s]\n.&quot;, NMerges, ClustNet-&gt;GetNodes(), ClustNet-&gt;GetEdges(), ExeTm.GetStr());
961          TFOut FOut(OutFNmPref+&quot;.ClustNet&quot;); ClustNet-&gt;Save(FOut); }
962      }
963    }
964    fclose(F);
965    printf(&quot;\n%d merges, %d nodes, %d edges in ClustNet [%s]\n\n.&quot;, NMerges, ClustNet-&gt;GetNodes(), ClustNet-&gt;GetEdges(), ExeTm.GetStr());
966    return ClustNet;
967  }
968  void TQuoteBs::AddMergedQtsToQtBs() {
969    printf(&quot;merge quote clusters and add them to the quote base\n&quot;);
970    TQuote MergedQt;
971    int toDel = ClustQtIdVH.Len();
972    for (int q = 0; q &lt; QuoteH.Len(); q++) {
973      if (QuoteH[q].GetFq() == 1) { QuoteH.DelKeyId(q); toDel--; }
974      if (toDel == 0) { break; }
975    }
976    for (int q = 0; q &lt; ClustQtIdVH.Len(); q++) {
977      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
978      IAssert(MergedQt.TmUrlCntV.Len() &gt; 0); 
979      QuoteH.AddDat(QuoteH.Len(), MergedQt); 
980    }
981    printf(&quot;IsKeyIdEqKeyN: %s\n&quot;, QuoteH.IsKeyIdEqKeyN()?&quot;T&quot;:&quot;F&quot;);
982  }
983  PQuoteBs TQuoteBs::GetMergeClusters(const bool&amp; OnlyClusters) const {
984    printf(&quot;Merging clusters into single quotes:\n&quot;);
985    PQuoteBs NewQtBs = TQuoteBs::New();
986    TQuote MergedQt;
987    printf(&quot;  %d quotes total\n&quot;, Len());
988    printf(&quot;  %d clusters\n&quot;, ClustQtIdVH.Len());
989    TIntSet SeenQtIdSet;
990    for (int q = 0; q &lt; ClustQtIdVH.Len(); q++) {
991      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
992      IAssert(MergedQt.TmUrlCntV.Len() &gt;0);
993      NewQtBs-&gt;AddQuote(MergedQt, *this);
994      const TIntV&amp; ClustQtIdV = ClustQtIdVH[q];
995      for (int c = 0; c &lt; ClustQtIdV.Len(); c++) {
996        const int qid = ClustQtIdV[c];
997        IAssert(! SeenQtIdSet.IsKey(qid)); 
998        SeenQtIdSet.AddKey(qid);
999      }
1000    }
1001    if (! OnlyClusters) {
1002      for (int q = 0; q &lt; Len(); q++) {
1003        const TQuote&amp; Q = GetQtN(q);
1004        if (! SeenQtIdSet.IsKey(GetQtId(q))) {
1005          NewQtBs-&gt;AddQuote(Q, *this); }
1006      }
1007    }
1008    printf(&quot;  %d quotes in new Quotes base\n&quot;, NewQtBs-&gt;Len());
1009    return NewQtBs;
1010  }
1011  void TQuoteBs::GetTopQtDoms(TStrIntPrV&amp; DomCntV, const int&amp; TakeNClust, const int&amp; MinClFq, const TStr&amp; RootHasWord, const TUrlTy&amp; OnlyCountTy) const {
1012    TIntV CIdV;
1013    GetCIdVByFq(CIdV, MinClFq, RootHasWord, OnlyCountTy);
1014    THash&lt;TStr, TInt&gt; DomCntH;
1015    for (int c = 0; c &lt; TMath::Mn(CIdV.Len(), TakeNClust); c++) {
1016      const TIntV&amp; ClustV = GetClust(CIdV[c]);
1017      for (int q = 0; q &lt; ClustV.Len(); q++) {
1018        const TQuote&amp; Q = GetQt(ClustV[q]);
1019        for (int u = 0; u &lt; Q.TmUrlCntV.Len(); u++) {
1020          DomCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += 1;
1021        }
1022      }
1023    }
1024    DomCntH.SortByDat(false);
1025    DomCntH.GetKeyDatPrV(DomCntV);
1026  }
1027  void TQuoteBs::TopDomsByLag(const TTmUnit&amp; TmUnit, const int&amp; TakeNDoms, const int&amp; TakeNClusts, const int&amp; Thresh) const {
1028    THash&lt;TStr, TMom&gt; DomLagH;
1029    TIntV CIdV;  GetCIdVByFq(CIdV, 10, &quot;&quot;, utUndef);
1030    TStrIntPrV DomCntV;  GetTopQtDoms(DomCntV, TakeNClusts, 10, &quot;&quot;, utUndef);
1031    printf(&quot;Take %d clusters, %d domains&quot;, TakeNClusts, TakeNDoms);
1032    for (int d = 0; d &lt; TMath::Mn(TakeNDoms, DomCntV.Len()); d++) {
1033      DomLagH.AddDat(DomCntV[d].Val1);
1034      printf(&quot;%d\t%s\n&quot;, DomCntV[d].Val2(), DomCntV[d].Val1.CStr());
1035    }
1036    int NQuotes=0;
1037    for (int c = 0; c &lt; TMath::Mn(CIdV.Len(), TakeNClusts); c++) {
1038      TQuote Q;  GetMergedClustQt(CIdV[c], Q, false);
1039      const TSecTm MedTm = Q.GetMedianTm(TmUnit, utUndef, *this).Round(TmUnit);
1040      TStrSet DomSet;
1041      for (int u = 0; u &lt; Q.TmUrlCntV.Len(); u++) {
1042        IAssert(IsStrId(Q.TmUrlCntV[u].UrlId()));
1043        const TStr Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
1044        if (DomSet.IsKey(Dom)) { continue; } 
1045        if (! DomLagH.IsKey(Dom)) { continue; }
1046        DomLagH.AddDat(Dom).Add((int(Q.TmUrlCntV[u].Tm().Round(TmUnit))-int(MedTm))/3600.0);
1047        DomSet.AddKey(Dom);
1048      }
1049      NQuotes += GetClust(CIdV[c]).Len();
1050    }
1051    FILE *F = fopen(TStr::Fmt(&quot;domsByLag-clust%d.tab&quot;, TakeNClusts).CStr(), &quot;wt&quot;);
1052    fprintf(F, &quot;Top clusters: %d, total quotes in top clusters: %d\n&quot;, TakeNClusts, NQuotes);
1053    TFltFltStrTrV MedLagDomV;
1054    for (int i = 0; i &lt; DomLagH.Len(); i++) {
1055      DomLagH[i].Def();
1056      MedLagDomV.Add(TFltFltStrTr(DomLagH[i].GetMedian(), DomLagH[i].GetVals(), DomLagH.GetKey(i)));
1057    }
1058    MedLagDomV.Sort();
1059    fprintf(F, &quot;AGGREGATE PEAK\nTop domains with least lag (out of top %d considered) that mention at least 10 pct of top %d quotes (clusters) :\n&quot;, TakeNDoms, TakeNClusts);
1060    for (int i = 0; i &lt; MedLagDomV.Len(); i++) {
1061      if (MedLagDomV[i].Val2() &lt; Thresh*TakeNClusts/100.0) { continue; }
1062      fprintf(F, &quot;%g\t%g\t%s\n&quot;, MedLagDomV[i].Val1(), MedLagDomV[i].Val2(), MedLagDomV[i].Val3.CStr());
1063    }
1064    fclose(F);
1065  }
1066  void TQuoteBs::PlotQtFqCnt(const TStr&amp; OutFNmPref) const {
1067    TIntH UrlCntH, DomCntH, CntFqH;
1068    THashSet&lt;TChA&gt; DomSet;
1069    for (int q = 0; q &lt; QuoteH.Len(); q++) {
1070      const TQuote&amp; Q = GetQtN(q);
1071      UrlCntH.AddDat(Q.GetUrls()) += 1;
1072      CntFqH.AddDat(Q.GetFq()) += 1;
1073      DomSet.Clr(false);
1074      for (int u = 0; u &lt; Q.GetUrls(); u++) {
1075        DomSet.AddKey(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))); }
1076      DomCntH.AddDat(DomSet.Len()) += 1;
1077    }
1078    TGnuPlot::PlotValCntH(UrlCntH, OutFNmPref+&quot;-url&quot;, &quot;&quot;, &quot;number of urls quote appears at&quot;, &quot;count&quot;, gpsLog10XY);
1079    TGnuPlot::PlotValCntH(DomCntH, OutFNmPref+&quot;-dom&quot;, &quot;&quot;, &quot;number of domains quote appears at&quot;, &quot;count&quot;, gpsLog10XY);
1080    TGnuPlot::PlotValCntH(CntFqH, OutFNmPref+&quot;-fq&quot;, &quot;&quot;, &quot;number of times quote appears&quot;, &quot;count&quot;, gpsLog10XY);
1081  }
1082  void TQuoteBs::PlotQtMediaVsBlogFq(const int&amp; QtId, const TStr&amp; OutFNmPref) const {
1083    TQuote::TTmFltPrV BlogFqV, MediaFqV, SmoothV;
1084    TFltPrV FqV;
1085    const TQuote&amp; ClQt = GetQt(QtId);
1086    ClQt.GetFqOt(BlogFqV, tmu4Hour, utBlog, *this);
1087    ClQt.GetFqOt(MediaFqV, tmu4Hour, utMedia, *this);
1088    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1089    TGnuPlot GP(&quot;mediaVsBlogs-&quot;+OutFNmPref, TStr::Fmt(&quot;%s. b:%d m:%d u:%d d:%d&quot;, ClQt.GetStr().CStr(),
1090      ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1091    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, tmu4Hour, 24, 1.2, MinTm);
1092    for (int i = 0; i &lt; SmoothV.Len(); i++) {
1093      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0), SmoothV[i].Val2())); }
1094    GP.AddPlot(FqV, gpwLines, &quot;Blog frequency&quot;);
1095    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, tmu4Hour, 24, 1.2, MinTm);
1096    FqV.Clr();
1097    for (int i = 0; i &lt; SmoothV.Len(); i++) {
1098      IAssert(SmoothV[i].Val1&gt;=MinTm);
1099      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0)*(54.0/46.0), SmoothV[i].Val2()));
1100    }
1101    GP.AddPlot(FqV, gpwLines, &quot;Media frequency&quot;);
1102    GP.SetXYLabel(TStr::Fmt(&quot;time [days] since %s&quot;, MinTm.GetYmdTmStr().CStr()), &quot;Quote frequency (normalized for the baseline 46 vs 54)&quot;);
1103    GP.SavePng();
1104  }
1105  int NormMaxTo1(const TQuote::TTmFltPrV&amp; TmFqV, TFltPrV&amp; OutV, const TSecTm&amp; BegTm) {
1106    int Idx=0;
1107    double MaxVal=0;
1108    for (int i = 0; i &lt; TmFqV.Len(); i++) {
1109      if (MaxVal &lt; TmFqV[i].Val2) {
1110        MaxVal=TmFqV[i].Val2; Idx = i; }
1111    }
1112    OutV.Gen(TmFqV.Len(), 0);
1113    for (int i = 0; i &lt; TmFqV.Len(); i++) {
1114      OutV.Add(TFltPr(double(TmFqV[i].Val1-BegTm)/(24.0*3600.0), TmFqV[i].Val2())); 
1115    }
1116    return Idx;
1117  }
1118  void TQuoteBs::PlotClustMediaVsBlogFq(const int&amp; CId, const TStr&amp; OutFNmPref) const {
1119    const TTmUnit TmUnit = tmu4Hour;
1120    TQuote::TTmFltPrV BlogFqV, MediaFqV, AllFqV, SmoothV;
1121    TFltPrV FqV, RawFqV;
1122    TQuote ClQt;
1123    GetMergedClustQt(CId, ClQt, false);
1124    ClQt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1125    ClQt.GetFqOt(MediaFqV, TmUnit, utMedia, *this);
1126    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1127    const TSecTm  MediaPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this);
1128    const TSecTm BlogPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utBlog, *this);
1129    const int Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600;
1130    const bool Is1Peak = ClQt.IsSinglePeak(TmUnit, TSecTm(1), utUndef, *this);
1131    TGnuPlot GP(&quot;mediaVsBlogs-&quot;+OutFNmPref, TStr::Fmt(&quot;%s. b:%d m:%d u:%d d:%d&quot;, Is1Peak?&quot;SINGLE PEAK&quot;: &quot;MORE PEAKS&quot;, 
1132      Lag, ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1133    int mx = NormMaxTo1(BlogFqV, RawFqV, MinTm);
1134    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, TmUnit, 2*24, 1.2, MinTm);
1135    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1136    GP.AddPlot(FqV, gpwLines, TStr::Fmt(&quot;SMOOTH Blog : max %s&quot;, SmoothV[mx].Val1.GetYmdTmStr().CStr()), &quot;pt 7 ps 1&quot;);
1137    const TSecTm SmBlog = SmoothV[mx].Val1;
1138    mx = NormMaxTo1(MediaFqV, RawFqV, MinTm);
1139    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, TmUnit, 2*24, 1.2, MinTm);
1140    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1141    const TSecTm SmMed = SmoothV[mx].Val1;
1142    const int SmLag = (int(SmBlog.Round(TmUnit))-int(SmMed.Round(TmUnit)))/3600;
1143    GP.AddPlot(FqV, gpwLines, TStr::Fmt(&quot;SMOOTH Media is behind: %dh, smooth: %dh.&quot;, -Lag, -SmLag), &quot;pt 5 ps 1&quot;);
1144    GP.SetXYLabel(TStr::Fmt(&quot;time [days] since %s&quot;, MinTm.GetYmdTmStr().CStr()), &quot;Cluster frequency (normalized for the baseline 46 vs 54)&quot;);
1145    GP.AddCmd(&quot;set xtics 10&quot;);
1146    GP.AddCmd(&quot;set mxtics 10&quot;);
1147    GP.SavePng();
1148  }
1149  void TQuoteBs::PlotMediaVsBlogLag(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, const int&amp; TakeN, const TStr&amp; OutFNmPref) const {
1150    TQuote Qt;  TIntV IdV;
1151    TMom LagMom1d, LagMom2d, LagMom3d, LagMom4d, LagMom7d;
1152    TFltFltH LagCntH, LagBCntH, LagMCntH;
1153    int Cnt=0;
1154    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, utUndef, false); }
1155    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1156    for (int c = 0; c &lt; TakeN; c++) {
1157      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1158      else { Qt = GetQt(IdV[c]); }
1159      const TSecTm  AllPeak = Qt.GetMedianTm(TmUnit, utUndef, *this);
1160      const TSecTm BlogPeak = Qt.GetMedianTm(TmUnit, utBlog, *this);
1161      const TSecTm  MediaPeak = Qt.GetMedianTm(TmUnit, utMedia, *this);
1162      const double Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600.0;
1163      const double Lag1 = (int(BlogPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1164      const double Lag2 = (int(MediaPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1165      if (fabs(Lag) &lt; 1*24) { LagMom1d.Add(Lag); }
1166      if (fabs(Lag) &lt; 2*24) { LagMom2d.Add(Lag); }
1167      if (fabs(Lag) &lt; 3*24) { LagMom3d.Add(Lag); }
1168      if (fabs(Lag) &lt; 4*24) { LagMom4d.Add(Lag); }
1169      if (fabs(Lag) &lt; 7*24) { LagMom7d.Add(Lag); }
1170      LagCntH.AddDat(Lag) += 1;
1171      LagBCntH.AddDat(Lag1) += 1;
1172      LagMCntH.AddDat(Lag2) += 1;
1173      Cnt++;
1174    }
1175    TFltPrV PrV;
1176    LagMom1d.Def();  LagMom2d.Def();  LagMom3d.Def();  LagMom4d.Def();  LagMom7d.Def();
1177    { TGnuPlot GP(&quot;lagBlogsVsMedia-&quot;+OutFNmPref, TStr::Fmt(&quot;Lag: 1D: %.2f %g;   2D: %.2f  %g;   3D: %.2f  %g;   4D: %.2f  %g;   7D: %.2f  %g&quot;,
1178      LagMom1d.GetMean(), LagMom1d.GetMedian(), LagMom2d.GetMean(), LagMom2d.GetMedian(), LagMom3d.GetMean(), LagMom3d.GetMedian(),
1179      LagMom4d.GetMean(), LagMom4d.GetMedian(), LagMom7d.GetMean(), LagMom7d.GetMedian()), true);
1180    LagBCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt(&quot;%s. b:%d m:%d u:%d d:%d BLOG&quot;, Qt.GetStr().CStr(),
1181      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1182    LagMCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt(&quot;%s. b:%d m:%d u:%d d:%d MEDIA&quot;, Qt.GetStr().CStr(),
1183      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1184    GP.AddCmd(&quot;set xrange[-24:24]\nset mxtics 5\nset xtics 5&quot;);
1185    GP.SetXYLabel(&quot;media lag in hours (+: news lag, -: news lead)&quot;, &quot;count&quot;);
1186    GP.SavePng(); }
1187    printf(&quot;\nTake top %d clusters. TmUnit: %s\n&quot;, TakeN, TTmInfo::GetTmUnitStr(TmUnit).CStr());
1188    printf(&quot;  1d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom1d.GetMean(), LagMom1d.GetMedian());
1189    printf(&quot;  2d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom2d.GetMean(), LagMom2d.GetMedian());
1190    printf(&quot;  3d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom3d.GetMean(), LagMom3d.GetMedian());
1191    printf(&quot;  4d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom4d.GetMean(), LagMom4d.GetMedian());
1192    printf(&quot;  7d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom7d.GetMean(), LagMom7d.GetMedian());
1193  }
1194  void TQuoteBs::PlotFqDecay(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, const TUrlTy&amp; CntUrlTy, const int&amp; PlotN, const int&amp; MinValsPerTm, const TStr&amp; OutFNmPref) const {
1195    THash&lt;TFlt, TMom&gt; MomH;
1196    TQuote Qt;
1197    TIntV IdV;
1198    TGnuPlot GP(&quot;decay-&quot;+OutFNmPref);
1199    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, CntUrlTy, false); }
1200    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, CntUrlTy); }
1201    for (int c = 0; c &lt; PlotN; c++) {
1202      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1203      else { Qt = GetQt(IdV[c]); }
1204      TQuote::TTmFltPrV QtV;  TFltPrV TmV;
1205      Qt.GetFqOt(QtV, TmUnit);
1206      int pos=0;  double val=0.0;
1207      for (int i = 0; i &lt; QtV.Len(); i++) {
1208        if (val &lt; QtV[i].Val2) { pos = i;  val = QtV[i].Val2; }
1209      }
1210      const double PeakVal = val;
1211      const TSecTm PeakTm = QtV[pos].Val1;
1212      for (int i = 0; i &lt; QtV.Len(); i++) {
1213        TmV.Add(TFltPr((double(QtV[i].Val1)-double(PeakTm))/(24.0*3600), QtV[i].Val2/PeakVal));
1214        MomH.AddDat(TmV.Last().Val1).Add(TmV.Last().Val2);
1215      }
1216      const TStr Label = &quot;&quot;;
1217    }
1218    TFltPrV AvgV, MedV;
1219    MomH.SortByKey();
1220    for (int i = 0; i &lt; MomH.Len(); i++) {
1221      MomH[i].Def();
1222      if (MomH[i].GetVals()&lt; MinValsPerTm) { printf(&quot;.&quot;); continue; }
1223      AvgV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMean()));
1224      MedV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMedian()));
1225    }
1226    GP.AddPlot(AvgV, gpwLines, &quot;Average&quot;, &quot;lt 2 lw 2&quot;);
1227    GP.AddPlot(MedV, gpwLines, TStr::Fmt(&quot;Median (last qt: %d %d %d)&quot;, Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(*this)), &quot;lt 1 lw 2&quot;);
1228    GP.SetXYLabel(&quot;time [days]&quot;, &quot;count&quot;);
1229    GP.AddCmd(&quot;set mxtics 6&quot;);
1230    GP.AddCmd(&quot;set xtics 1&quot;);
1231    GP.AddCmd(&quot;set yrange [0:1]&quot;);
1232    GP.AddCmd(&quot;set xrange [-5:5]&quot;);
1233    GP.AddCmd(&quot;set yzeroaxis lt -1&quot;);
1234    GP.SavePng();
1235  }
1236  void NormPeakAt1(THash&lt;TInt, TFlt&gt;&amp; H) {
1237    double PeakFq=1;
1238    for (int i = 0; i &lt; H.Len(); i++) {
1239      PeakFq=TMath::Mx((double)H[i], PeakFq); }
1240    for (int i = 0; i &lt; H.Len(); i++) {
1241      H[i]/=PeakFq; }
1242  }
1243  void TQuoteBs::PlotBlogVsMediaFqOt(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, int PlotN, const TStr&amp; OutFNmPref) const {
1244    THash&lt;TInt, TFlt&gt; Peak1AllH, Peak2AllH, Peak3AllH;
1245    THash&lt;TInt, TFlt&gt; Peak1MedH, Peak2MedH, Peak3MedH;
1246    THash&lt;TInt, TFlt&gt; Peak1BlogH, Peak2BlogH, Peak3BlogH;
1247    TQuote Qt;
1248    TIntV IdV;
1249    TInt FqAtPeak;
1250    if (TakeClusters) { GetCIdVByFq(IdV, 100, &quot;&quot;, utUndef, false); }
1251    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1252    for (int c = 0; c &lt; TMath::Mn(PlotN, IdV.Len()); c++) {
1253      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1254      else { Qt = GetQt(IdV[c]); }
1255      if (! Qt.IsSinglePeak(TmUnit, TSecTm(0), utUndef, *this)) { PlotN++; printf(&quot;.&quot;); continue; }
1256      TQuote::TTmFltPrV AllFqV, BlogFqV, MedFqV;  TFltPrV TmV;
1257      const double Peak1 = Qt.GetPeakTm(TmUnit, TSecTm(1), FqAtPeak).GetAbsSecs(); 
1258      const double Peak2 = Qt.GetMeanTm(TmUnit, utUndef, *this).GetAbsSecs();    
1259      const double Peak3 = Qt.GetMedianTm(TmUnit, utUndef, *this).GetAbsSecs();  
1260      double PeakFq = FqAtPeak;
1261      Qt.GetFqOt(AllFqV, TmUnit, utUndef, *this);
1262      Qt.GetFqOt(MedFqV, TmUnit, utMedia, *this);
1263      Qt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1264      PeakFq=1;
1265      for (int i = 0; i &lt; MedFqV.Len(); i++) { PeakFq=TMath::Mx((double)MedFqV[i].Val2(), PeakFq); }
1266      for (int i = 0; i &lt; MedFqV.Len(); i++) {
1267        const int T1 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1268        const int T2 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1269        const int T3 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1270        Peak1MedH.AddDat(T1) += MedFqV[i].Val2/PeakFq;
1271        Peak2MedH.AddDat(T2) += MedFqV[i].Val2/PeakFq;
1272        Peak3MedH.AddDat(T3) += MedFqV[i].Val2/PeakFq;
1273      }
1274      PeakFq=1;
1275      for (int i = 0; i &lt; BlogFqV.Len(); i++) { PeakFq=TMath::Mx((double)BlogFqV[i].Val2(), PeakFq); }
1276      for (int i = 0; i &lt; BlogFqV.Len(); i++) {
1277        const int T1 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1278        const int T2 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1279        const int T3 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1280        Peak1BlogH.AddDat(T1) += BlogFqV[i].Val2/PeakFq;
1281        Peak2BlogH.AddDat(T2) += BlogFqV[i].Val2/PeakFq;
1282        Peak3BlogH.AddDat(T3) += BlogFqV[i].Val2/PeakFq;
1283      }
1284    }
1285    NormPeakAt1(Peak1AllH); NormPeakAt1(Peak2AllH); NormPeakAt1(Peak3AllH);
1286    NormPeakAt1(Peak1MedH); NormPeakAt1(Peak2MedH); NormPeakAt1(Peak3MedH);
1287    NormPeakAt1(Peak1BlogH); NormPeakAt1(Peak2BlogH); NormPeakAt1(Peak3BlogH);
1288    TGnuPlot::PlotValCntH(Peak1AllH, &quot;ALL&quot;, Peak1MedH, &quot;MEDIA&quot;, Peak1BlogH, &quot;BLOG&quot;, &quot;peakMax-&quot;+OutFNmPref, &quot;Max is the peak&quot;, &quot;Time [h]&quot;, &quot;Count (sum of frequencies of all quotes)&quot;);
1289    TGnuPlot::PlotValCntH(Peak3AllH, &quot;ALL&quot;, Peak3MedH, &quot;MEDIA&quot;, Peak3BlogH, &quot;BLOG&quot;, &quot;peakMed-&quot;+OutFNmPref, &quot;Median is the peak&quot;, &quot;Time [h]&quot;, &quot;Count (sum of frequencies of all quotes)&quot;);
1290  }
1291  void TQuoteBs::PlotBlogFracOt(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, const int&amp; PlotN, const TStr&amp; OutFNmPref) const {
1292    TQuote Qt;
1293    TIntV IdV;
1294    THash&lt;TFlt, TMom&gt; TmMomH;
1295    THash&lt;TFlt, TFltPr&gt; TmBmH;
1296    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, utUndef, false); }
1297    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1298    for (int c = 0; c &lt; PlotN; c++) {
1299      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1300      else { Qt = GetQt(IdV[c]); }
1301      TQuote::TTmFltPrV MedQtV, BlgQtV;
1302      Qt.GetFqOt(MedQtV, TmUnit, utMedia, *this);
1303      Qt.GetFqOt(BlgQtV, TmUnit, utBlog, *this);
1304      TFltPrV FracV;
1305      const int PeakTm = Qt.GetPeakTm(TmUnit, TSecTm(1), utUndef, *this);
1306      for (int m=0, b=0; m &lt; MedQtV.Len(); m++) {
1307        while (b&lt;BlgQtV.Len() &amp;&amp; BlgQtV[b].Val1 &lt; MedQtV[m].Val1) { b++; }
1308        if (b&lt;BlgQtV.Len() &amp;&amp; BlgQtV[b].Val1 == MedQtV[m].Val1) {
1309          const double Tm = (int(MedQtV[m].Val1.Round(TmUnit))-PeakTm)/(24*3600.0);
1310            const double Frac = BlgQtV[b].Val2/double(BlgQtV[b].Val2+MedQtV[m].Val2);
1311            FracV.Add(TFltPr(Tm, Frac));
1312            TmMomH.AddDat(Tm).Add(Frac);
1313          TFltPr&amp; BM = TmBmH.AddDat(Tm);
1314          BM.Val1+= BlgQtV[b].Val2;
1315          BM.Val2+= MedQtV[m].Val2;
1316        }
1317      }
1318    }
1319    { TFltPrV PrV;
1320    for (int b = 0; b &lt; TmMomH.Len(); b++) {
1321      TmMomH[b].Def();
1322      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMean())); }
1323    TGnuPlot GP(TStr::Fmt(&quot;fqFracA-%s&quot;, OutFNmPref.CStr()));
1324    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1325    GP.AddCmd(&quot;set xrange [-7:7]\nset yzeroaxis lt -1&quot;); GP.SavePng(); }
1326    { TFltPrV PrV;
1327    for (int b = 0; b &lt; TmMomH.Len(); b++) {
1328      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMedian())); }
1329    TGnuPlot GP(TStr::Fmt(&quot;fqFracM-%s&quot;, OutFNmPref.CStr()));
1330    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
<span onclick='openModal()' class='match'>1331    GP.AddCmd(&quot;set xrange [-7:7]\nset yzeroaxis lt -1&quot;); GP.SavePng(); }
1332    { TFltPrV PrV;
</span>1333    for (int b = 0; b &lt; TmBmH.Len(); b++) {
1334      PrV.Add(TFltPr(TmBmH.GetKey(b), TmBmH[b].Val1/(TmBmH[b].Val1+TmBmH[b].Val2))); }
1335    TGnuPlot GP(TStr::Fmt(&quot;fqFracS-%s&quot;, OutFNmPref.CStr()));
1336    PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints);
1337    GP.AddCmd(&quot;set xrange [-7:7]\nset yzeroaxis lt -1&quot;); GP.SavePng(); }
1338  }
1339  void TQuoteBs::PlotPopularityCnt(const bool&amp; TakeClusters, const TUrlTy&amp; UrlTy, const int&amp; PlotN, const TStr&amp; OutFNmPref) const {
1340    TIntV IdV;
1341    TIntH FqCntH;
1342    TQuote Qt;
1343    for (int c = 0; c &lt; Len(); c++) {
1344      const TQuote&amp; Qt = GetQtN(c);
1345      if (Qt.GetStr().IsStrIn(&quot;lipstick&quot;) &amp;&amp; Qt.GetStr().IsStrIn(&quot;pig&quot;)) {
1346        FqCntH.AddDat(Qt.GetFq(UrlTy, *this)) += 1; }
1347    }
1348    TIntPrV FqCntV, CdfV;
1349    FqCntH.GetKeyDatPrV(FqCntV);  FqCntV.Sort();
1350    TGUtil::GetCCdf(FqCntV, CdfV);
1351    TGnuPlot::PlotValV(FqCntV, &quot;pop-&quot;+OutFNmPref, &quot;&quot;, &quot;total frequency&quot;, &quot;count&quot;, gpsLog10XY);
1352    TGnuPlot::PlotValV(CdfV, &quot;popCDF-&quot;+OutFNmPref+&quot;&quot;, &quot;&quot;, &quot;total frequency&quot;, &quot;NCDF&quot;, gpsLog10XY);
1353  }
1354  void TQuoteBs::PlotEmptyY(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, const int&amp; PlotN, const TStr&amp; OutFNmPref) const {
1355    TQuote Qt;
1356    TIntV IdV;
1357    THash&lt;TInt, TInt&gt; TmCumCntH;
1358    int MaxY=0;
1359    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, utUndef, false); }
1360    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1361    for (int c = 0; c &lt; PlotN; c++) {
1362      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1363      else { Qt = GetQt(IdV[c]); }
1364      TQuote::TTmFltPrV QtV;
1365      Qt.GetFqOt(QtV, TmUnit);
1366      for (int i = 0; i &lt; QtV.Len(); i++) {
1367        const int Tm = QtV[i].Val1.Round(tmu1Hour)/3600;
1368        TInt&amp; CumCnt = TmCumCntH.AddDat(Tm);
1369        CumCnt += (int) QtV[i].Val2;
1370        MaxY = TMath::Mx(CumCnt(), MaxY);
1371      }
1372    }
1373    TmCumCntH.SortByKey(true);
1374    const int BegHr = TmCumCntH.GetKey(0);
1375    THash&lt;TFlt, TFlt&gt; EmptyH;
1376    TFltPrV TmV;
1377    for (int t = 0; t &lt; TmCumCntH.Len(); t++) {
1378      printf(&quot;%d  &quot;, TmCumCntH[t]());
1379      for (int y = TmCumCntH[t]; y &lt; MaxY; y+=1) {
1380        EmptyH.AddDat(y) += 1; }
1381      TmV.Add(TFltPr((TmCumCntH.GetKey(t)-BegHr)/24.0, TmCumCntH[t].Val));
1382    }
1383    EmptyH.SortByKey(false);
1384    TFltPrV EmptyV;
1385    EmptyV.Add(TFltPr(EmptyH.GetKey(0), EmptyH[0]));
1386    for (int i = 1; i &lt; EmptyH.Len(); i++) {
1387      EmptyV.Add(TFltPr(EmptyH.GetKey(i), EmptyH[i]+EmptyV.Last().Val2));
1388    }
1389    TGnuPlot::PlotValCntH(EmptyH, &quot;emptyF-&quot;+OutFNmPref+&quot;-d&quot;, &quot;Amount of empty area above the cummulative query-frequency curve&quot;, &quot;y value&quot;, &quot;area at y&quot;);
1390    TGnuPlot::PlotValV(EmptyV, &quot;emptyF-&quot;+OutFNmPref+&quot;-c&quot;, &quot;Amount of empty area above the cummulative query-frequency curve&quot;, &quot;y value&quot;, &quot;area above y&quot;);
1391    TGnuPlot::PlotValV(TmV, &quot;emptyF1&quot;+OutFNmPref, &quot;Cummulative query frequency over time&quot;, &quot;time (days)&quot;, &quot;frequency&quot;);
1392  }
1393  PNGraph TQuoteBs::GetQuotePostNet(const TStr&amp; DatasetFNm) const {
1394    PNGraph Graph = TNGraph::New();
1395    for (TMemesDataLoader Memes(DatasetFNm); Memes.LoadNext(); ) {
1396      if (Memes.MemeV.Empty()) { continue; }
1397      if (! IsStr(Memes.PostUrlStr.CStr())) { continue; }
1398      const int SrcNId = GetStrId(Memes.PostUrlStr.CStr());
1399      for (int u = 0; u &lt; Memes.LinkV.Len(); u++) {
1400        if (! IsStr(Memes.LinkV[u].CStr())) { continue; }
1401        const int DstNId = GetStrId(Memes.LinkV[u].CStr());
1402        if (! Graph-&gt;IsNode(SrcNId)) { Graph-&gt;AddNode(SrcNId); }
1403        if (! Graph-&gt;IsNode(DstNId)) { Graph-&gt;AddNode(DstNId); }
1404        Graph-&gt;AddEdge(SrcNId, DstNId);
1405      }
1406    }
1407    TSnap::PrintInfo(Graph);
1408    return Graph;
1409  }
1410  PQtDomNet TQuoteBs::GetQuoteDomNet(const PNGraph&amp; PostGraph, const int&amp; CId) const {
1411    TQuote Qt;  GetMergedClustQt(CId, Qt, false);
1412    PQtDomNet DomG = TQtDomNet::New();
1413    TIntSet UrlSet;
1414    for (int i = 0; i &lt; Qt.GetTimes(); i++) { UrlSet.AddKey(Qt.GetUrlId(i)); }
1415    TStrSet DomH;
1416    for (int i = 0; i &lt; Qt.GetTimes(); i++) {
1417      const int url = Qt.GetUrlId(i);
1418      if (! PostGraph-&gt;IsNode(url)) { continue; }
1419      const int dom = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url)));
1420      TNGraph::TNodeI NI = PostGraph-&gt;GetNI(url);
1421      for (int o = 0; o &lt; NI.GetOutDeg(); o++) {
1422        if (! UrlSet.IsKey(NI.GetOutNId(o))) { continue; }
1423        const int url2 = NI.GetOutNId(o);
1424        const int dom2 = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url2)));
1425        if (dom==dom2) { continue; }
1426        if (! DomG-&gt;IsNode(dom)) {
1427          DomG-&gt;AddNode(dom, TPair&lt;TStr, TInt&gt;(DomH[dom], GetUrlTy(url))); }
1428        if (! DomG-&gt;IsNode(dom2)) {
1429          DomG-&gt;AddNode(dom2, TPair&lt;TStr, TInt&gt;(DomH[dom2], GetUrlTy(url2))); }
1430        if (DomG-&gt;IsEdge(dom, dom2)) {
1431          DomG-&gt;GetEDat(dom, dom2) += 1; }
1432        else {
1433          DomG-&gt;AddEdge(dom, dom2, 1); }
1434      }
1435    }
1436    return DomG;
1437  }
1438  void TQuoteBs::SaveQuotes(const int&amp; MinQtFq, const TStr&amp; OutFNm) const {
1439    TIntV QtIdV;
1440    GetQtIdVByFq(QtIdV, 0, MinQtFq);
1441    SaveQuotes(QtIdV, OutFNm);
1442  }
1443  void TQuoteBs::SaveQuotes(const TIntV&amp; QtIdV, const TStr&amp; OutFNm) const {
1444    TIntSet QtIdSet;
1445    FILE *F = fopen(OutFNm.CStr(), &quot;wt&quot;);
1446    printf(&quot;saving %d quotes\n&quot;, QtIdV.Len());
1447    fprintf(F, &quot;#Freq\tUrls\tDomains\tQuote\n&quot;);
1448    for (int q = 0; q &lt; QtIdV.Len(); q++) {
1449      const int QtId = QtIdV[q];
1450      if (QtIdSet.IsKey(QtId)) { continue; } 
1451      QtIdSet.AddKey(QtId);
1452      const TQuote&amp; Q = GetQt(QtId);
1453    fprintf(F, &quot;%d\t%d\t%d\t%s\n&quot;, Q.GetFq(), Q.GetUrls(), Q.GetDoms(*this), Q.QtStr.CStr());
1454      if (Q.GetTy() == qtRoot || Q.GetTy() == qtCentr) { 
1455        IAssert(ClustQtIdVH.IsKey(Q.GetCId()));
1456        const TIntV&amp; ClustV = ClustQtIdVH.GetDat(Q.GetCId());
1457        for (int i = 0; i &lt; ClustV.Len(); i++) {
1458          const TQuote&amp; Q1 = GetQt(ClustV[i]);
1459          fprintf(F, &quot;\t[%d] %d=%d %s\t%d\t%d\t%d\n&quot;, TStrUtil::CountWords(Q1.QtStr.CStr()),
1460            ClustV[i](), Q1.GetCId(), Q1.QtStr.CStr(), Q1.GetFq(), Q1.GetUrls(), Q1.GetDoms(*this));
1461          QtIdSet.AddKey(ClustV[i]);
1462        }
1463      }
1464    }
1465    fclose(F);
1466  }
1467  void TQuoteBs::SaveClusters(const TStr&amp; OutFNm, const bool&amp; SkipUrls) const {
1468    TIntPrV FqCIdV;
1469    TIntH ClSzCntH, ClFqCntH;
1470    for (int c = 0; c &lt; GetClusts(); c++) {
1471      const int CId = GetCId(c);
1472      if ( ! IsQtId(CId)) { printf(&quot;!!! %d:%d\n&quot;, c, CId); continue; }
1473      FqCIdV.Add(TIntPr(GetClustFq(CId), CId));
1474      ClSzCntH.AddDat(GetClust(CId).Len()) += 1;
1475      ClFqCntH.AddDat(GetClustFq(CId)) += 1;
1476    }
1477    TGnuPlot::PlotValCntH(ClSzCntH, OutFNm+&quot;-clSz&quot;, TStr::Fmt(&quot;%d clusters&quot;, GetClusts()), &quot;Number of quotes in the cluster&quot;, &quot;Number of clusters&quot;, gpsLog);
1478    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+&quot;-clFq&quot;, TStr::Fmt(&quot;%d clusters&quot;, GetClusts()), &quot;Volume of quotes in the cluster&quot;, &quot;Number of clusters&quot;, gpsLog, false, gpwLinesPoints, false, false);
1479    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+&quot;-clFqB&quot;, TStr::Fmt(&quot;%d clusters&quot;, GetClusts()), &quot;Volume of quotes in the cluster&quot;, &quot;Number of clusters&quot;, gpsLog, false, gpwLinesPoints, false, true);
1480    FqCIdV.Sort(false);
1481    TIntPrV QtFqV;
1482    FILE *F = fopen(TStr::Fmt(&quot;%s-clust.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1483    fprintf(F, &quot;format:\n&lt;ClSz&gt;\t&lt;TotFq&gt;\t&lt;Root&gt;\t&lt;ClusterId&gt;\n&quot;);
1484    fprintf(F, &quot;\t&lt;QtFq&gt;\t&lt;Urls&gt;\t&lt;QtStr&gt;\t&lt;QuteId&gt;\n&quot;);
1485    fprintf(F, &quot;\t\t&lt;Tm&gt;\t&lt;Fq&gt;\t&lt;UrlTy&gt;\t&lt;Url&gt;\n\n&quot;);
1486    for (int c = 0; c &lt; FqCIdV.Len(); c++) {
1487      const int CId = FqCIdV[c].Val2;
1488      const TIntV&amp; ClustV = GetClust(CId);
1489      fprintf(F, &quot;\n%d\t%d\t%s\t%d\n&quot;, ClustV.Len(), FqCIdV[c].Val1(), GetQt(CId).GetStr().CStr(), CId);
1490      QtFqV.Clr(false);
1491      for (int q = 0; q &lt; ClustV.Len(); q++) {
1492        IAssert(IsQtId(ClustV[q]));
1493        QtFqV.Add(TIntPr(GetQt(ClustV[q]).GetUrls(), ClustV[q])); }
1494      QtFqV.Sort(false);
1495      for (int q = 0; q &lt; QtFqV.Len(); q++) {
1496        IAssert(IsQtId(QtFqV[q].Val2));
1497        const TQuote&amp; Qt = GetQt(QtFqV[q].Val2);
1498        if ((! SkipUrls) &amp;&amp; q &gt; 0) { fprintf(F, &quot;\n&quot;); }
1499        fprintf(F, &quot;\t%d\t%d\t%s\t%d\n&quot;, Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), QtFqV[q].Val2());
1500        if (! SkipUrls) {
1501          for (int u = 0; u &lt; Qt.GetUrls(); u++) {
1502            fprintf(F, &quot;\t\t%s\t%d\t%s\t%s\n&quot;, Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1503              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?&quot;M&quot;:&quot;B&quot;, GetStr(Qt.TmUrlCntV[u].UrlId())); }
1504        }
1505      }
1506    }
1507    fclose(F);
1508  }
1509  void TQuoteBs::SaveClusters(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, const bool&amp; SkipUrls) const {
1510    FILE *F = fopen(TStr::Fmt(&quot;%s-clust.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1511    fprintf(F, &quot;format:\n&lt;ClSz&gt;\t&lt;TotFq&gt;\t&lt;Root&gt;\t&lt;ClusterId&gt;\n&quot;);
1512    fprintf(F, &quot;\t&lt;QtFq&gt;\t&lt;Urls&gt;\t&lt;QtStr&gt;\t&lt;QuteId&gt;\n&quot;);
1513    fprintf(F, &quot;\t\t&lt;Tm&gt;\t&lt;Fq&gt;\t&lt;UrlTy&gt;\t&lt;Url&gt;\n\n&quot;);
1514    for (int c = 0; c &lt; QtIdV.Len(); c++) {
1515      int CId = QtIdV[c];
1516      if (! IsClust(CId)) { CId = GetQt(CId).GetCId(); }
1517      const TIntV&amp; ClustV = GetClust(CId);
1518      fprintf(F, &quot;\n%d\t%d\t%s\t%d\n&quot;, ClustV.Len(), GetClustFq(CId), GetQt(CId).GetStr().CStr(), CId);
1519      for (int q = 0; q &lt; ClustV.Len(); q++) {
1520        const TQuote&amp; Qt = GetQt(ClustV[q]);
1521        if ((! SkipUrls) &amp;&amp; q &gt; 0) { fprintf(F, &quot;\n&quot;); }
1522        fprintf(F, &quot;\t%d\t%d\t%s\t%d\n&quot;, Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), ClustV[q]());
1523        if (! SkipUrls) {
1524          for (int u = 0; u &lt; Qt.GetUrls(); u++) {
1525            fprintf(F, &quot;\t\t%s\t%d\t%s\t%s\n&quot;, Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1526              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?&quot;M&quot;:&quot;B&quot;, GetStr(Qt.TmUrlCntV[u].UrlId())); }
1527        }
1528      }
1529    }
1530    fclose(F);
1531  }
1532  void TQuoteBs::SaveBigBlogMassQt(const TStr&amp; OutFNm) const {
1533    const TTmUnit TmUnit = tmuDay;
1534    const bool TakeClusters = true;
1535    TIntV IdV;
1536    TQuote Qt;
1537    int Candidates=0;
1538    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, utUndef, false); }
1539    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1540    TVec&lt;TPair&lt;TFlt, TStr&gt; &gt; ScoreV;
1541    for (int c = 0; c &lt; IdV.Len(); c++) {
1542      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1543      else { Qt = GetQt(IdV[c]); }
1544      const int MediaPeak = Qt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this); 
1545      const double BlogFq = Qt.GetUrls(TSecTm(MediaPeak-21*24*3600), TSecTm(MediaPeak-7*24*3600), utBlog, *this);  
1546      const double TotFq = Qt.GetUrls();
1547      if (BlogFq &lt; 10) { continue; }
1548      Candidates++;
1549      if (BlogFq &lt; TotFq*0.15 || BlogFq &gt; TotFq*0.75) { continue; }
1550      ScoreV.Add(TFltStrPr(TotFq, TStr::Fmt(&quot;%g\t%g\t%s&quot;, BlogFq, TotFq, Qt.GetStr().CStr())));
1551    }
1552    printf(&quot;Considered: %d quotes\n&quot;, IdV.Len());
1553    printf(&quot;            %d candidates\n&quot;, Candidates);
1554    printf(&quot;            %d selected\n&quot;, ScoreV.Len());
1555    ScoreV.Sort(false);
1556    FILE *F = fopen(TStr::Fmt(&quot;%s.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1557    fprintf(F, &quot;total %d items\n&quot;, IdV.Len());
1558    fprintf(F, &quot;items above blog threshdolg %d\n&quot;, ScoreV.Len());
1559    fprintf(F, &quot;counts are numbers of urls (not actually number of occurences)\n&quot;);
1560    fprintf(F, &quot;\nblog\ttotal\tQuote\n&quot;);
1561    for (int i = 0; i &lt; ScoreV.Len(); i++) {
1562      fprintf(F, &quot;%s\n&quot;, ScoreV[i].Val2.CStr());
1563    }
1564    fclose(F);
1565  }
1566  void TQuoteBs::SaveForFlash(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, const TTmUnit&amp; TmUnit, int SaveN, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm, const TUrlTy&amp; OnlyCountTy) const {
1567    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
1568    TVec&lt;TQuad&lt;TFlt, TInt, TInt, TQuote::TTmFltPrV&gt; &gt; QtInfoV, QtInfoV2; 
1569    TQuote::TTmFltPrV FqV, SmoothFqV;
1570    TIntV VizQtIdV;
1571    if (SaveN == -1) { SaveN = TInt::Mx; }
1572    TSecTm MinTm=TSecTm(TInt::Mx-1), MaxTm=TSecTm(1);
1573    printf(&quot;Saving top %d out of %d quotes\n&quot;, SaveN, QtIdV.Len());
1574    THash&lt;TInt, TIntPr&gt; WeekPeakQtIdH; 
1575    for (int q = 0; q &lt; QtIdV.Len() &amp;&amp; QtInfoV2.Len() &lt; (SaveN+100); q++) { 
1576      const TQuote&amp; Qt = GetQt(QtIdV[q]);
1577      if (Qt.GetTy() == qtQuote) {
1578        Qt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1579        if (FqV.Empty()) { continue; }
1580        QtInfoV2.Add(TQuad&lt;TFlt, TInt, TInt, TQuote::TTmFltPrV&gt;((double)Qt.GetPeakTm(TmUnit, BegTm)+1e-6*Qt.GetUrls(), QtIdV[q], Qt.GetFq(), FqV));
1581        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1582        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1583        VizQtIdV.Add(QtIdV[q]);
1584        TInt PeakFq;
1585        const int PeakTm = Qt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1586        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1587          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1588        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1&lt;PeakFq) {
1589          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1590      } else { 
1591        const int CId = Qt.GetCId();
1592        if (! ClustQtIdVH.IsKey(CId)) { continue; }
1593        const int CentrQtId = GetCentrQtId(CId);
1594        TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, true);
1595        CentrQt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1596        if (FqV.Empty()) { continue; }
1597        QtInfoV2.Add(TQuad&lt;TFlt, TInt, TInt, TQuote::TTmFltPrV&gt;((double)CentrQt.GetPeakTm(TmUnit, BegTm)+1e-6*CentrQt.GetUrls(), CentrQtId, GetClustFq(CId), FqV));
1598        TInt PeakFq;
1599        const int PeakTm = CentrQt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1600        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1601          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1602        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1&lt;PeakFq) {
1603          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1604        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1605        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1606        VizQtIdV.Add(CentrQtId);
1607      } /&amp;bsol;*/
1608    }
1609    { TIntSet QtIdSet;
1610    for (int i = 0; i &lt; WeekPeakQtIdH.Len(); i++) {
1611    }
1612    QtInfoV.Clr(true);
1613    for (int i = 0; i &lt; TMath::Mn(SaveN, QtInfoV2.Len()); i++) {
1614      if (QtIdSet.IsKey(i)) { continue; }
1615      QtInfoV.Add(QtInfoV2[i]);
1616    printf(&quot;%d  &quot;, (int) QtInfoV2[i].Val3()); 
1617      if (QtInfoV.Len() &gt; SaveN) { break; }
1618    } } 
1619    THash&lt;TSecTm, TIntFltH&gt; TmCntH; 
1620    for (int i = 0; i &lt; QtInfoV.Len(); i++) {
1621      const TQuote::TTmFltPrV&amp; FqV = QtInfoV[i].Val4;
1622      for (int t = 0; t &lt; FqV.Len(); t++) {
1623        TmCntH.AddDat(FqV[t].Val1).AddDat(i, FqV[t].Val2); }
1624    }
1625    for (int i = 0; i &lt; TmCntH.Len(); i++) {
1626      TmCntH[i].SortByDat(false); }
1627    const int K = 10;
1628    const int Slack = 3*24*3600; 
1629    THash&lt;TInt, TSecTm&gt; QtLastTopH; 
1630    for (int i = 0; i &lt; TmCntH.Len(); i++) {
1631      TIntFltH&amp; TmH = TmCntH[i];
1632      for (int j = 0; j &lt; TMath::Mn(K, TmH.Len()); j++) {
1633        QtLastTopH.AddDat(TmH.GetKey(j), TmCntH.GetKey(i));
1634      }
1635    }
1636    for (int i = 0; i &lt; QtInfoV.Len(); i++) {
1637      TQuote::TTmFltPrV&amp; FqV = QtInfoV[i].Val4;
1638      const TSecTm LastTime = QtLastTopH.GetDat(i);
1639      int x = 0; for (x = 0; x &lt; FqV.Len() &amp;&amp; FqV[x].Val1 &lt;= LastTime+Slack; x++) { }
1640      if (x &lt; FqV.Len()) { FqV.Del(x, FqV.Len()-1); }
1641    } 
1642    printf(&quot;save from %d quotes\n&quot;, QtInfoV.Len());
1643    QtInfoV.Sort();
1644    TIntH QtIdUrlH;  GetQtPageUrl(VizQtIdV, QtIdUrlH);
1645    FILE *F = fopen(TStr::Fmt(&quot;qtOt-%sQ.tab&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1646    fprintf(F, &quot;QuoteId\tQuote\tUrl\tTotalVol\n&quot;);
1647    for (int i = 0; i &lt; TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1648      fprintf(F, &quot;%d\t%s\t%s\t%d\n&quot;, SaveN-i, GetQt(QtInfoV[i].Val2).QtStr.CStr(), GetStr(QtIdUrlH.GetDat(QtInfoV[i].Val2)), (int) QtInfoV[i].Val3);
1649    }
1650    fclose(F);
1651    printf(&quot;saveT\n&quot;);
1652    F = fopen(TStr::Fmt(&quot;qtOt-%sT.tab&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1653    fprintf(F, &quot;Time\tQuoteId\tSmoothFreq\tRawFreq\n&quot;);
1654    for (int i = 0; i &lt; TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1655      const TQuote::TTmFltPrV RawFqV = QtInfoV[i].Val4;
1656      TQuote::GetSmoothFqOt(SmoothFqV, RawFqV, TmUnit, 6*24*3600/TmUnitSecs, 1.05, MinTm, MaxTm);  
1657      IAssert(SmoothFqV.Len() &gt;= RawFqV.Len());
1658      for (int d=0, ds = 0; ds &lt; SmoothFqV.Len(); ds++) {
1659        if (TmUnit == tmuDay) { fprintf(F, &quot;%s&quot;, SmoothFqV[ds].Val1.GetDtYmdStr().CStr()); }
1660        else { fprintf(F, &quot;%s_%02d&quot;, SmoothFqV[ds].Val1.GetDtYmdStr().CStr(), SmoothFqV[ds].Val1.GetHourN()); }
1661        fprintf(F, &quot;\t%d\t%.2f&quot;, SaveN-i, SmoothFqV[ds].Val2());
1662        if (d &lt; RawFqV.Len() &amp;&amp; SmoothFqV[ds].Val1 == RawFqV[d].Val1) { fprintf(F, &quot;\t%.0f&quot;, RawFqV[d].Val2()); d++; } else { fprintf(F, &quot;\t0&quot;); }
1663        fprintf(F, &quot;\n&quot;);
1664      }
1665    }
1666    fclose(F);
1667    printf(&quot;done.\n&quot;);
1668  }
1669  void TQuoteBs::SaveDomainStat(const TStr&amp; OutFNm, const int&amp; MinCnt) const {
1670    THash&lt;TInt, TInt&gt; MedOt, BlogOt, AllOt;
1671    int MedCnt=0, BlogCnt=0, AllCnt=0;
1672    TSecTm BegTm(2008,7,31,0,0,0);
1673    THash&lt;TStr, TIntPr&gt; DomCntH;
1674    for (int q = 0; q &lt; QuoteH.Len(); q++) {
1675      const TQuote&amp; Q = QuoteH[q];
1676      for (int u = 0; u &lt; Q.GetUrls(); u++) {
1677        const int Day = TSecTm(Q.GetTm(u)-BegTm).GetInUnits(tmuDay);
1678        AllOt.AddDat(Day) += 1;  AllCnt++;
1679        if (GetUrlTy(Q.GetUrlId(u)) ==  utMedia) { MedOt.AddDat(Day) += 1;  MedCnt++;}
1680        else { BlogOt.AddDat(Day) += 1;  BlogCnt++; }
1681        TStr Dom = TStrUtil::GetDomNm2(GetStr(Q.GetUrlId(u)));
1682        DomCntH.AddDat(Dom).Val1 += 1;
1683        DomCntH.AddDat(Dom).Val2 += Q.GetCnt(u);
1684      }
1685    }
1686    TGnuPlot::PlotValCntH(AllOt, &quot;ALL&quot;, MedOt, &quot;MEDIA&quot;, BlogOt, &quot;BLOGS&quot;, &quot;overTm-&quot;+OutFNm, TStr::Fmt(&quot;Quote freq over time: A:%d M:%d B:%d&quot;, AllCnt, MedCnt, BlogCnt),
1687      &quot;Time [days]&quot;, &quot;Number of quote mentions&quot;);
1688    DomCntH.SortByDat(false);
1689    FILE *F = fopen(TStr::Fmt(&quot;domains-%s.tab&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1690    fprintf(F, &quot;# %d domains, total mentions:\tAll:%d\tMedia:%d\tBlogs:%d&quot;, DomCntH.Len(), AllCnt, MedCnt, BlogCnt);
1691    fprintf(F, &quot;#Domain\tNumber of quotes mentioned\tNumber of mentions\n&quot;);
1692    for (int d = 0; d &lt; DomCntH.Len(); d++) {
1693      fprintf(F, &quot;%s\t%d\t%d\n&quot;, DomCntH.GetKey(d).CStr(), DomCntH[d].Val1(), DomCntH[d].Val2());
1694    }
1695    fclose(F);
1696  }
1697  void TQuoteBs::Dump(const bool&amp; Fast) const {
1698    printf(&quot;Quote base:\n&quot;);
1699    if (! Fast) {
1700      TSecTm MinTm, MaxTm; GetMinMaxTm(MinTm, MaxTm);
1701      printf(&quot;  %s -- %s\n&quot;, MinTm.GetYmdTmStr().CStr(), MaxTm.GetYmdTmStr().CStr());
1702      int totCnt=0, totVol=0;
1703      for (int q = 0; q &lt; QuoteH.Len(); q++) {
1704        const TQuote::TTmUrlCntV&amp; V = QuoteH[q].TmUrlCntV;
1705        totCnt += V.Len();
1706        for (int u = 0; u &lt; V.Len(); u++) {
1707          totVol += V[u].Cnt();
1708        }
1709      }
1710      printf(&quot;  %d number of posts mentioning quotes\n&quot;, totCnt);
1711      printf(&quot;  %d number of mentions\n&quot;, totVol);
1712    }
1713    printf(&quot;  %d quotes\n&quot;, Len());
1714    printf(&quot;  %d strings (quotes+urls, no domains)\n&quot;, StrQtIdH.Len());
1715    printf(&quot;  %d clusters\n&quot;, ClustQtIdVH.Len());
1716    printf(&quot;  %d quotes in clusters\n&quot;, GetQtsInClust());
1717    printf(&quot;  %d urls with type\n\n&quot;, UrlTyH.Len());
1718  }
1719  PQuoteBs TQuoteBs::FindQtInTxtQBs(const TStr&amp; InBinFNmWc, const TStrV&amp; QuoteStrV) {
1720    THashSet&lt;TMd5Sig&gt; SeenUrlH; 
1721    PQuoteBs QtBsPt = TQuoteBs::New();
1722    TQuoteBs&amp; QtBs = *QtBsPt;
1723    TStrHash&lt;TInt&gt; StrH;
1724    TVec&lt;TIntV&gt; QtWIdVV;
1725    TVec&lt;TIntV&gt; QtSkipLenVV; 
1726    for (int q = 0; q &lt; QuoteStrV.Len(); q++) {
1727      const int QId = QtBs.QuoteH.Len(); 
1728      TQuote&amp; Qt = QtBs.QuoteH.AddDat(QId);
1729      Qt.QtCIdTy = TQuote::TQtIdTy(QId, qtQuote);
1730      Qt.QtStr = QuoteStrV[q];
1731      QtWIdVV.Add();  QtSkipLenVV.Add();
1732      TStrUtil::GetAddWIdV(StrH, QuoteStrV[q].CStr(), QtWIdVV.Last());
1733      TIntV&amp; WIdV = QtWIdVV.Last();
1734      TIntV&amp; SkipV = QtSkipLenVV.Last();
1735      SkipV.Add(1);
1736      for (int w = 1; w &lt; WIdV.Len(); w++) {
1737        int skipLen = 1;
1738        while (w-skipLen &gt;= 0 &amp;&amp; WIdV[w-skipLen] != WIdV[w]) { skipLen++; }
1739        SkipV.Add(skipLen);
1740      }
1741    }
1742    TInt WId;
1743    TIntV TxtWIdV;
1744    TVec&lt;char *&gt; WrdV;
1745    TQuoteLoader QL(InBinFNmWc);
1746    while (QL.Next()) {
1747      if (SeenUrlH.IsKey(TMd5Sig(QL.PostUrlStr))) { continue; }
1748      SeenUrlH.AddKey(TMd5Sig(QL.PostUrlStr));
1749      TxtWIdV.Clr();  WrdV.Clr(false);
1750      { TStrUtil::SplitWords(QL.ContentStr, WrdV);
1751      for (int w = 0; w &lt; WrdV.Len(); w++) {
1752        if (StrH.IsKeyGetDat(WrdV[w], WId)) { TxtWIdV.Add(WId); }
1753        else if (TxtWIdV.Len()&gt;0 &amp;&amp; TxtWIdV.Last()!=-1) { TxtWIdV.Add(-1); }
1754      } }
1755      for (int q = 0; q &lt; QtWIdVV.Len(); q++) {
1756        const TIntV&amp; QWIdV = QtWIdVV[q];
1757        const TIntV&amp; SkipV = QtSkipLenVV[q];
1758        int cnt = 0;
1759        for (int w = 0; w &lt; TxtWIdV.Len()-QWIdV.Len(); ) {
1760          int len = 0;
1761          while (len &lt; QWIdV.Len() &amp;&amp; TxtWIdV[w+len] == QWIdV[len]) { len++; }
1762          if (len == QWIdV.Len()) { cnt+=1;  w+=len; }
1763          else { w += SkipV[len]; }
1764        }
1765        if (cnt &gt; 0) {
1766          QtBs.GetQtN(q).TmUrlCntV.Add(TQuote::TTmUrlCnt(QL.PubTm, QtBs.AddStr(QL.PostUrlStr), cnt));
1767          if (cnt &gt; 255) { printf(&quot;*&quot;); }
1768        }
1769      }
1770    }
1771    for (int i = 0; i &lt; QtBs.Len(); i++) { QtBs.QuoteH[i].TmUrlCntV.Sort(); }
1772    return QtBsPt;
1773  }
1774  #ifdef false
1775  void TQuoteBs::BuildQtSubSeqCounts(TIntV&amp; QtIdV, const TStr&amp; OutFNm) {
1776  }
1777  void TQuoteBs::PlotQtFqOverTm(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int PlotN) const {
1778    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1779    TGnuPlot GP(&quot;fqOT.&quot;+OutFNm);
1780    TFltPrV HrFqV;
1781    if (PlotN == -1) { PlotN = TInt::Mx; }
1782    for (int i = 0; i &lt; TMath::Mn(PlotN, QtIdV.Len()); i++) {
1783      const TQuote&amp; Qt = GetQt(QtIdV[i]);
1784      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1785      for (int h = 0; h &lt; HrFqV.Len(); h++) {
1786        HrFqV[h].Val1 = TMath::Round(HrFqV[h].Val1/24.0, 2);
1787      }
1788      GP.AddPlot(HrFqV, gpwLines, TStrUtil::GetShorStr(Qt.QtStr), &quot;lt 1&quot;);
1789    }
1790    GP.SetXYLabel(&quot;Time [days]&quot;, &quot;Frequency&quot;);
1791    GP.AddCmd(&quot;set nokey&quot;);
1792    GP.SavePng(&quot;fqOT.&quot;+OutFNm+&quot;.png&quot;, -1, -1, &quot;&quot;, &quot;set terminal png small size 3000,600&quot;);
1793    GP.AddCmd(&quot;set size 2,0.5&quot;);
1794    GP.SaveEps(10);
1795  }
1796  void TQuoteBs::PlotQtCumFqOverTm(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int PlotN) const {
1797    const int TmuSecs = TTmInfo::GetTmUnitSecs(tmu1Hour);
1798    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1799    const TSecTm StartTm = MinTm.Round(tmu1Hour);
1800    const TSecTm EndTm = MaxTm.Round(tmu1Hour);
1801    TQuote::TTmFltPrV HrFqV;
1802    TFltFltH SumCntH;
1803    for (TSecTm Tm = StartTm; Tm &lt;= MaxTm.Round(tmu1Hour); Tm += TmuSecs) {
1804      SumCntH.AddDat(double(Tm-StartTm)/(24.0*3600.0)) = 0;
1805    }
1806    TGnuPlot GP(&quot;cfqOT.&quot;+OutFNm);
1807    if (PlotN == -1) { PlotN = TInt::Mx; }
1808    for (int i = 0; i &lt; TMath::Mn(PlotN, QtIdV.Len()); i++) {
1809      const TQuote&amp; Qt = GetQt(QtIdV[i]);
1810      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, 48, 1.2);
1811      for (int h = 0; h &lt; HrFqV.Len(); h++) {
1812        const TSecTm roundTm = HrFqV[h].Val1.Round(tmu1Hour);
1813        if (roundTm &gt;= StartTm &amp;&amp; roundTm&lt;=EndTm) {
1814          SumCntH.AddDat(double(roundTm-StartTm)/(24.0*3600.0)) += HrFqV[h].Val2;
1815        }
1816      }
1817      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr, 100).CStr());
1818    }
1819    GP.SetXYLabel(TStr::Fmt(&quot;Time [days] since %s&quot;, StartTm.GetYmdTmStr().CStr()), &quot;Stacked frequency&quot;);
1820    GP.AddCmd(&quot;set notitle&quot;);
1821    GP.AddCmd(&quot;set nogrid&quot;);
1822    GP.AddCmd(&quot;set mxtics 4&quot;);
1823    GP.SavePng(&quot;cfqOT.&quot;+OutFNm+&quot;.png&quot;, -1, -1, &quot;&quot;, &quot;set terminal png small size 1000,600&quot;);
1824  }
1825  void TQuoteBs::PlotQtCumFqOverTm1(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int PlotN) const {
1826    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1827    TGnuPlot GP(&quot;cfqOT.&quot;+OutFNm);
1828    TFltPrV HrFqV, HrCFqV;
1829    TFltFltH SumCntH;
1830    if (PlotN == -1) { PlotN = TInt::Mx; }
1831    for (int i = 0; i &lt; TMath::Mn(PlotN, QtIdV.Len()); i++) {
1832      const TQuote&amp; Qt = GetQt(QtIdV[i]);
1833      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1834      HrCFqV.Clr(false);
1835      for (int h = 0; h &lt; HrFqV.Len(); h++) {
1836        const double hr = TMath::Round(HrFqV[h].Val1/24.0+0.001, 2);
1837        SumCntH.AddDat(hr) += HrFqV[h].Val2;
1838      }
1839      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr).CStr(), &quot;lt 1&quot;);
1840    }
1841    GP.SetXYLabel(&quot;Time [days]&quot;, &quot;Stacked frequency&quot;);
1842    GP.AddCmd(&quot;set nokey&quot;);
1843    GP.AddCmd(&quot;set notitle&quot;);
1844    GP.AddCmd(&quot;set nogrid&quot;);
1845    GP.AddCmd(&quot;set mxtics 5&quot;);
1846    GP.AddCmd(&quot;set xtics 5&quot;);
1847    GP.SavePng(&quot;cfqOT.&quot;+OutFNm+&quot;.png&quot;, -1, -1, &quot;&quot;, &quot;set terminal png small size 3000,600&quot;);
1848    GP.AddCmd(&quot;set size 2,0.5&quot;);
1849    GP.SaveEps(8);
1850  }
1851  void TQuoteBs::SaveForMatlab(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int SaveN) const {
1852    const TTmUnit TmUnit = tmu1Hour;
1853    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1854    THash&lt;TInt, TFlt&gt; TmCntH;
1855    TVec&lt;TFltV&gt; TmQtFqV;
1856    const int MinTmUnit = MinTm.GetInUnits(TmUnit);
1857    for (uint i = MinTmUnit; i &lt;= MaxTm.GetInUnits(TmUnit); i++) {
1858      TmCntH.AddDat(i, 0);  TmQtFqV.Add();
1859      TmQtFqV.Last().Add(i-MinTmUnit+1); 
1860    }
1861    TQuote::TTmFltPrV DayFqV;
1862    if (SaveN == -1) { SaveN = TInt::Mx; }
1863    for (int i = 0; i &lt; TMath::Mn(SaveN, QtIdV.Len()); i++) {
1864      const TQuote&amp; Qt = GetQt(QtIdV[i]);
1865      Qt.GetSmoothFqOverTm(DayFqV, TmUnit, 48, 1.2);
1866      for (int d = 0; d &lt; TmCntH.Len(); d++) { TmCntH[d] = 0; }
1867      for (int d = 0; d &lt; DayFqV.Len(); d++) {
1868        const int T = DayFqV[d].Val1.GetInUnits(TmUnit);
1869        if (TmCntH.IsKey(T)) {
1870          TmCntH.AddDat(T) += DayFqV[d].Val2; }
1871      }
1872      for (int d = 0; d &lt; TmCntH.Len(); d++) {
1873        TmQtFqV[d].Add(TmCntH[d]); }
1874    }
1875    FILE *F = fopen(TStr::Fmt(&quot;qtFqOtMATLAB-%s.tab&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1876    for (int d = 0; d &lt; TmQtFqV.Len(); d++) {
1877      fprintf(F, &quot;%g&quot;, TmQtFqV[d][0]());
1878      for (int q = 1; q &lt; TmQtFqV[d].Len(); q++) {
1879        fprintf(F, &quot;\t%g&quot;, TmQtFqV[d][q]()); }
1880      fprintf(F, &quot;\n&quot;);
1881    }
1882    fclose(F);
1883  }
1884  void TQuoteBs::SaveQtTmUrlTxt(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int SaveN) const {
1885    if (SaveN == -1) { SaveN = TInt::Mx; }
1886    SaveN = TMath::Mn(SaveN, QtIdV.Len());
1887    FILE *F = fopen(OutFNm.CStr(), &quot;wt&quot;);
1888    for (int q = 0; q &lt; QtIdV.Len(); q++) {
1889      const TQuote&amp; Qt = GetQt(QtIdV[q]);
1890      fprintf(F, &quot;%s\t%d\n&quot;, Qt.QtStr.CStr(), Qt.GetFq());
1891      for (int u = 0; u &lt; Qt.GetUrls(); u++) {
1892        fprintf(F, &quot;\t%s\t%s\n&quot;, Qt.TmUrlCntV[u].Val1.GetYmdTmStr().CStr(), GetStr(Qt.TmUrlCntV[u].Val2));
1893      }
1894      fprintf(F, &quot;\n&quot;);
1895    }
1896    fclose(F);
1897  }
1898  void TQuoteBs::PlotSubQtOverTm(const int&amp; QtId, const TStr&amp; OutFNm) const {
1899    TIntV PlotQtV;
1900    const TQuote Qt = GetQt(QtId);
1901    PlotQtV.Add(QtId);
1902    TIntV WrdBegV; WrdBegV.Add(0);
1903    for (int i = 1; i &lt; Qt.QtStr.Len()-1; i++) {
1904      if (TCh::IsAlNum(Qt.QtStr.GetCh(i)) &amp;&amp; TCh::IsWs(Qt.QtStr.GetCh(i-1))) { WrdBegV.Add(i); }
1905    }
1906    TInt subQtId;
1907    WrdBegV.Add(Qt.QtStr.Len()+1); 
1908    const int QtWords = TStrUtil::CountWords(Qt.QtStr.CStr());
1909    for (int WndSz = 5; WndSz &lt; QtWords; WndSz++) {
1910      for (int word = 0; word &lt; QtWords-WndSz; word++) {
1911        const TStr SubQtStr = Qt.QtStr.GetSubStr(WrdBegV[word], WrdBegV[word+WndSz]-2);
1912        if (StrH.IsKeyGetDat(SubQtStr, subQtId) &amp;&amp; QuoteH.IsKey(subQtId) &amp;&amp; subQtId!=QtId) { PlotQtV.Add(subQtId); printf(&quot;.&quot;); }
1913      }
1914    }
1915    TGnuPlot GP(OutFNm, TStr::Fmt(&quot;%d occurences, %d urls, %d domains: %s&quot;, Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(), Qt.QtStr.CStr()));
1916    TFltPrV HrFqV;
1917    for (int i = 0; i &lt; PlotQtV.Len(); i++) {
1918      const TQuote&amp; subQt = QuoteH.GetDat(PlotQtV[i]);
1919      subQt.GetSmoothFqOverTm(HrFqV, tmu1Hour);
1920      GP.AddPlot(HrFqV, gpwLines, subQt.QtStr.CStr());
1921    }
1922    GP.SetXYLabel(&quot;Time [hours]&quot;, &quot;Frequency&quot;);
1923    GP.SavePng(OutFNm+&quot;.png&quot;, -1, -1, &quot;&quot;, &quot;set terminal png small size 1000,800&quot;);
1924  }
1925  void TQuoteBs::PlotTopQuotesOverTm(const int&amp; StepSecs, const int&amp; IntervalSecs, const int&amp; TakeNPerStep, const TStr&amp; OutFNm) const {
1926    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1927    printf(&quot;Dataset span %s -- %s\n&quot;, MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1928    TIntSet TopQtIdSet;
1929    int cnt=0;
1930    TIntV TopQtIdV;
1931    for (TSecTm Tm(MinTm); Tm &lt; MaxTm; Tm += StepSecs, cnt++) {
1932      FailR(&quot;TopQuotesOverTm: take top quotes from each day&quot;);
1933      for (int q = 0; q &lt; TopQtIdV.Len(); q++) { TopQtIdSet.AddKey(TopQtIdV[q]); }
1934    }
1935    printf(&quot;\n%d time steps total, %d quotes per step: %d total quotes\n&quot;, cnt, TakeNPerStep, TopQtIdSet.Len());
1936    printf(&quot;%s   %d\n&quot;, MinTm.Round(tmuDay).GetStr().CStr(), MinTm.Round(tmuDay).GetInUnits(tmu1Hour));
1937    TFltPrV FqOverTm;
1938    TGnuPlot GP(TStr(&quot;topQtOverTm.&quot;)+OutFNm, &quot;&quot;);
1939    TFOut FOut(OutFNm+TStr(&quot;.Quote&quot;));
1940    for (int q = 0; q &lt; TopQtIdSet.Len(); q++) {
1941      const TQuote&amp; Q = QuoteH.GetDat(TopQtIdSet[q]);
1942      Q.Save(FOut);
1943      Q.GetSmoothFqOverTm(FqOverTm, tmu1Hour, MinTm.Round(tmuDay));
1944      GP.AddPlot(FqOverTm, gpwLines, Q.QtStr);
1945    }
1946    GP.AddCmd(&quot;set xtics 24&quot;); GP.AddCmd(&quot;set mxtics 4&quot;);
1947    GP.SetXYLabel(TStr(&quot;time [hours] from &quot;+MinTm.Round(tmuDay).GetStr()), &quot;frequency&quot;);
1948    GP.SavePng(TStr(&quot;topQtOverTm.&quot;)+OutFNm+TStr(&quot;.png&quot;), -1, -1, &quot;&quot;, &quot;set terminal png small size 2000,800&quot;);
1949  }
1950  PQuoteBs TQuoteBs::BuildQuoteBs(const TStr&amp; InBinFNmWc, const int&amp; MinQtWrdLen) {
1951    PQuoteBs QBsPt = TQuoteBs::New(InBinFNmWc);
1952    QBsPt-&gt;AddToQuoteBs(InBinFNmWc, MinQtWrdLen);
1953    return QBsPt;
1954  }
1955  #endif
1956  PClustNet TClustNet::GetSubGraph(const TIntV&amp; NIdV) const {
1957    PClustNet NewNetPt = TClustNet::New();
1958    TClustNet&amp; NewNet = *NewNetPt;
1959    NewNet.Reserve(NIdV.Len(), -1);
1960    int node, edge;
1961    TClustNet::TNodeI NI;
1962    for (node = 0; node &lt; NIdV.Len(); node++) {
1963      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
1964    }
1965    for (node = 0; node &lt; NIdV.Len(); node++) {
1966      NI = GetNI(NIdV[node]);
1967      const int SrcNId = NI.GetId();
1968      for (edge = 0; edge &lt; NI.GetOutDeg(); edge++) {
1969        const int OutNId = NI.GetOutNId(edge);
1970        if (NewNet.IsNode(OutNId)) {
1971          NewNet.AddEdge(SrcNId, OutNId); }
1972      }
1973    }
1974    NewNet.Defrag();
1975    return NewNetPt;
1976  }
1977  void TClustNet::AddLink(const TQuote&amp; SrcQt, const TQuote&amp; DstQt) {
1978    const int Qt1Id = SrcQt.GetCId();
1979    const int Qt2Id = DstQt.GetCId();
1980    if (! IsNode(Qt1Id)) {
1981      AddNode(Qt1Id, SrcQt); }
1982    if (! IsNode(Qt2Id)) {
1983      AddNode(Qt2Id, DstQt); }
1984    if (! IsEdge(Qt2Id, Qt1Id)) {
1985      AddEdge(Qt1Id, Qt2Id);
1986    }
1987  }
1988  PClustNet TClustNet::GetSubGraph(const int&amp; MinQtWords, const int&amp; MaxQtWords, const int&amp; MinFq) const {
1989    TIntV NIdV;
1990    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
1991      const int Wrds = TStrUtil::CountWords(NI().GetStr().CStr());
1992      if (NI().GetFq() &gt;= MinFq &amp;&amp;  Wrds &gt;= MinQtWords &amp;&amp; Wrds &lt;= MaxQtWords) {
1993        NIdV.Add(NI.GetId()); }
1994    }
1995    return GetSubGraph(NIdV);
1996  }
1997  void TClustNet::RecalcEdges(const double&amp; MinOverlapFrac) {
1998    printf(&quot;Recalculating edges...\n&quot;);
1999    TIntPrV DelEdgeV;
2000    TStrHash&lt;TInt&gt; StrH(Mega(1), true);
2001    int WIdV1Start, WIdV2Start, SkipTy;
2002    TIntV WIdV1, WIdV2;
2003    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2004      const TStr Q1 = NI().GetStr();
2005      TStrUtil::GetAddWIdV(StrH, Q1.CStr(), WIdV1);
2006      for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2007        const TStr Q2 = NI.GetOutNDat(e).GetStr();
2008        TStrUtil::GetAddWIdV(StrH, Q2.CStr(), WIdV2);
2009        const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, WIdV1Start, WIdV2Start, SkipTy);
2010        const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2011        const int LongLen = TMath::Mx(WIdV1.Len(), WIdV2.Len());
2012        IAssert(Overlap&lt;=ShortLen);
2013        if (2*ShortLen&gt;LongLen &amp;&amp; Overlap/double(ShortLen) &gt; MinOverlapFrac) { continue; }
2014        DelEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(e)));
2015      }
2016    }
2017    printf(&quot;Deleting %d/%d (%.4f) edges\n&quot;, DelEdgeV.Len(), GetEdges(), DelEdgeV.Len()/double(GetEdges()));
2018    for (int i = 0; i &lt; DelEdgeV.Len(); i++) {
2019      DelEdge(DelEdgeV[i].Val1, DelEdgeV[i].Val2);
2020    }
2021  }
2022  void TClustNet::MakeClusters(const TIntPrV&amp; KeepEdgeV) {
2023    PUNGraph G = TUNGraph::New();
2024    for (int e = 0; e &lt; KeepEdgeV.Len(); e++) {
2025      if (! G-&gt;IsNode(KeepEdgeV[e].Val1)) {
2026        G-&gt;AddNode(KeepEdgeV[e].Val1); }
2027      if (! G-&gt;IsNode(KeepEdgeV[e].Val2)) {
2028        G-&gt;AddNode(KeepEdgeV[e].Val2); }
2029      G-&gt;AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2030    }
2031    TCnComV CnComV;
2032    TSnap::GetWccs(G, CnComV);
2033    TIntH NIdCcIdH(GetNodes());
2034    for (int c = 0; c &lt; CnComV.Len(); c++) {
2035      const TIntV&amp; NIdV = CnComV[c].NIdV;
2036      for (int n = 0; n &lt; NIdV.Len(); n++) {
2037        NIdCcIdH.AddDat(NIdV[n], c);
2038      }
2039    }
2040    TIntPrV DelEdgeV;
2041    for (TEdgeI EI = BegEI(); EI &lt; EndEI(); EI++) {
2042      const int ccid1 = NIdCcIdH.IsKey(EI.GetSrcNId()) ? NIdCcIdH.GetDat(EI.GetSrcNId()).Val : -1;
2043      const int ccid2 = NIdCcIdH.IsKey(EI.GetDstNId()) ? NIdCcIdH.GetDat(EI.GetDstNId()).Val : -1;
2044      if (ccid1 != ccid2 &amp;&amp; ccid1!=-1 &amp;&amp; ccid2!=-1) {
2045        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
2046    }
2047    const int Edges = GetEdges();
2048    printf(&quot;Deleting %d out of %d  (%f) edges\n&quot;, DelEdgeV.Len(), Edges, DelEdgeV.Len()/double(Edges));
2049    for (int d = 0; d &lt; DelEdgeV.Len(); d++) {
2050      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2051    }
2052  }
2053  void TClustNet::KeepOnlyTree(const TIntPrV&amp; KeepEdgeV) {
2054    TIntPrSet EdgeSet(KeepEdgeV.Len());
2055    for (int i = 0; i &lt; KeepEdgeV.Len(); i++) {
2056      EdgeSet.AddKey(TIntPr(TMath::Mn(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2),
2057        TMath::Mx(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2)));
2058    }
2059    TIntPrSet DelEdgeV;
2060    for (TEdgeI EI = BegEI(); EI &lt; EndEI(); EI++) {
2061      const int N1 = TMath::Mn(EI.GetSrcNId(), EI.GetDstNId());
2062      const int N2 = TMath::Mx(EI.GetSrcNId(), EI.GetDstNId());
2063      if (! EdgeSet.IsKey(TIntPr(N1, N2))) {
2064        DelEdgeV.AddKey(TIntPr(N1, N2)); }
2065    }
2066    printf(&quot;deleting %d edges\n&quot;, DelEdgeV.Len());
2067    for (int d = 0; d &lt; DelEdgeV.Len(); d++) {
2068      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2069    }
2070  }
2071  void TClustNet::GetClusters(TVec&lt;TIntV&gt;&amp; QtNIdV) const {
2072    TCnComV CnComV;
2073    TSnap::GetWccs(GetThis(), CnComV);
2074    CnComV.Sort(false);
2075    QtNIdV.Clr(false);
2076    TIntSet SeenSet;
2077    for (int i = 0; i &lt; CnComV.Len(); i++) {
2078      for (int n = 0; n &lt; CnComV[i].NIdV.Len(); n++) {
2079        IAssert(! SeenSet.IsKey(CnComV[i].NIdV[n]));
2080        SeenSet.AddKey(CnComV[i].NIdV[n]);
2081      }
2082      QtNIdV.Add(CnComV[i].NIdV);
2083    }
2084  }
2085  void TClustNet::GetMergedClustQt(const TIntV&amp; QtIdV, TQuote&amp; NewQt) const {
2086    int CentrQtId=-1, MxFq=0;
2087    THash&lt;TPair&lt;TSecTm, TInt&gt;, TInt&gt; TmUrlCntH;
2088    for (int c = 0; c &lt; QtIdV.Len(); c++) {
2089      const TQuote&amp; Q = GetNDat(QtIdV[c]);
2090      IAssert(Q.GetId() == QtIdV[c]);
2091      for (int t = 0; t &lt; Q.GetTimes(); t++) {
2092        TmUrlCntH.AddDat(TPair&lt;TSecTm, TInt&gt;(Q.GetTm(t), Q.GetUrlId(t))) += Q.GetCnt(t);
2093      }
2094      if (MxFq &lt; Q.GetFq()) {
2095        MxFq = Q.GetFq();
2096        CentrQtId = Q.GetId();
2097      }
2098    }
2099    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
2100    NewQt.QtStr = GetNDat(CentrQtId).GetStr(); 
2101    NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
2102    for (int u = 0; u &lt; TmUrlCntH.Len(); u++) {
2103      NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
2104    }
2105    NewQt.TmUrlCntV.Sort();
2106  }
2107  int TClustNet::EvalPhraseClusters(const TIntPrV&amp; KeepEdgeV, const bool&amp; dump) const {
2108    PNGraph G = TNGraph::New();
2109    for (int e = 0; e &lt; KeepEdgeV.Len(); e++) {
2110      if (! G-&gt;IsNode(KeepEdgeV[e].Val1)) {
2111        G-&gt;AddNode(KeepEdgeV[e].Val1); }
2112      if (! G-&gt;IsNode(KeepEdgeV[e].Val2)) {
2113        G-&gt;AddNode(KeepEdgeV[e].Val2); }
2114      G-&gt;AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2115    }
2116    TCnComV CnComV;
2117    TSnap::GetWccs(G, CnComV);
2118    G = TSnap::ConvertGraph&lt;PNGraph&gt;(TPt&lt;TClustNet&gt;((TClustNet*) this));
2119    int TotEdges=0, EdgesInBigClust=0;
2120    int TotNodes=0, NodesInBigClust=0;
2121    int BigClust=0;
2122    for (int cc = 0; cc &lt; CnComV.Len(); cc++) {
2123      if (CnComV[cc].NIdV.Len() &lt; 3) { continue; }
2124      PNGraph CC = TSnap::GetSubGraph(G, CnComV[cc].NIdV);
2125      TotEdges += CC-&gt;GetEdges();
2126      TotNodes += CC-&gt;GetNodes()-1;
2127      if (CC-&gt;GetNodes() &gt; 10) {
2128        EdgesInBigClust += CC-&gt;GetEdges();
2129        NodesInBigClust += CC-&gt;GetNodes()-1;
2130        BigClust++;
2131      }
2132    }
2133    if (dump) {
2134      printf(&quot;                                all\tbig(&gt;10)\n&quot;);
2135      printf(&quot;  Number of clusters:           %d\t%d\n&quot;, CnComV.Len(), BigClust);
2136      printf(&quot;  Total edges inside clusters:  %d\t%d\n&quot;, TotEdges, TotEdges-TotNodes);
2137      printf(&quot;  Total edges deleted:          %d\t%d\n&quot;, GetEdges()-TotEdges, GetEdges()-TotEdges-TotNodes);
2138      printf(&quot;  Total edges in big clusters:  %d\t%d\n&quot;, EdgesInBigClust, EdgesInBigClust-NodesInBigClust);
2139    }
2140    return TotEdges-TotNodes;
2141  }
2142  void TClustNet::ClustKeepSingleEdge(const int&amp; MethodId) const {
2143    TIntPrV KeepEdgeV;
2144    ClustKeepSingleEdge(MethodId, KeepEdgeV);
2145  }
2146  void TClustNet::ClustKeepSingleEdge(const int&amp; MethodId, TIntPrV&amp; KeepEdgeV) const {
2147    PNGraph G = TSnap::ConvertGraph&lt;PNGraph&gt;(TPt&lt;TClustNet&gt;((TClustNet*) this));
2148    KeepEdgeV.Clr(false);
2149    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2150      IAssert(NI.GetId() == NI().GetId());
2151      int EdgeToKeep = -1, BestVal=0;
2152      for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2153        if (MethodId==1 &amp;&amp; NI.GetOutNDat(e).GetFq() &gt; BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetFq(); }
2154        if (MethodId==2 &amp;&amp; NI.GetOutNDat(e).GetStr().Len() &gt; BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2155        if (MethodId==3 &amp;&amp; NI.GetOutNDat(e).GetStr().Len() &lt; BestVal ||BestVal==0) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2156      }
2157      if (MethodId==4 &amp;&amp; NI.GetOutDeg()&gt;0) {
2158        EdgeToKeep = TInt::Rnd.GetUniDevInt(NI.GetOutDeg()); }
2159      if (EdgeToKeep!=-1) {
2160        KeepEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(EdgeToKeep))); }
2161    }
2162    if (MethodId==1) { printf(&quot;Keep edge to most frequent quote:\n&quot;); }
2163    if (MethodId==2) { printf(&quot;Keep edge to longest quote:\n&quot;); }
2164    if (MethodId==3) { printf(&quot;Keep edge to shortest quote:\n&quot;); }
2165    if (MethodId==4) { printf(&quot;Keep random edge:\n&quot;); }
2166    EvalPhraseClusters(KeepEdgeV);
2167  }
2168  void TClustNet::ClustGreedyTopDown() const {
2169    TIntPrV KeepEdgeV;
2170    ClustGreedyTopDown(KeepEdgeV);
2171  }
2172  void TClustNet::ClustGreedyTopDown(TIntPrV&amp; KeepEdgeV) const {
2173    TIntH NIdOutDegH;
2174    TIntH NIdClustH;
2175    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2176      NIdOutDegH.AddDat(NI.GetId(), NI.GetOutDeg());
2177      if (NI.GetOutDeg() == 0) {
2178        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2179    }
2180    printf(&quot;%d root nodes\n&quot;, NIdClustH.Len());
2181    printf(&quot;%d nodes\n&quot;, NIdOutDegH.Len());
2182    NIdOutDegH.SortByDat(true);
2183    THash&lt;TInt, TIntPr&gt; ClustCntH;
2184    KeepEdgeV.Clr(false);
2185    while (NIdOutDegH.Len() &gt; 0 &amp;&amp; NIdOutDegH[0] == 0) {
2186      for (int i = 0; i &lt; NIdOutDegH.Len() &amp;&amp; NIdOutDegH[i] == 0; i++) {
2187        IAssert(IsNode(NIdOutDegH.GetKey(i)));
2188        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2189        for (int e = 0; e &lt; NI.GetInDeg(); e++) {
2190          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2191        ClustCntH.Clr(false);
2192        for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2193          IAssert(NIdClustH.IsKey(NI.GetOutNId(e)));
2194          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1; 
2195          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2196        }
2197        ClustCntH.SortByDat(false);
2198        if (ClustCntH.Len() &gt; 0) {
2199          const int NId = NI.GetId();
2200          const int NId2 = ClustCntH[0].Val2;
2201          const int CId = NIdClustH.GetDat(NId2);
2202          KeepEdgeV.Add(TIntPr(NId, NId2)); 
2203          NIdClustH.AddDat(NId, CId); 
2204        }
2205        NIdOutDegH[i] = TInt::Mx;
2206      }
2207      NIdOutDegH.SortByDat(true);
2208    }
2209    printf(&quot;Greedy top down approach:\n&quot;);
2210    EvalPhraseClusters(KeepEdgeV);
2211  }
2212  void TClustNet::ClustGreedyRandom() const {
2213    printf(&quot;Greedy random:\n&quot;);
2214    THash&lt;TInt, TIntV&gt; OutNIdV;
2215    THash&lt;TInt, TInt&gt; EdgeH;
2216    TIntPrV KeepEdgeV;
2217    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2218      if (NI.GetOutDeg() &gt; 0) {
2219        EdgeH.AddDat(NI.GetId()) = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg()));
2220        if (NI.GetOutDeg() &gt; 1) {
2221          for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2222            OutNIdV.AddDat(NI.GetId()).Add(NI.GetOutNId(e)); }
2223        }
2224      }
2225    }
2226    { TIntH NIdOutDegH;
2227    TIntH NIdClustH;
2228    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2229      NIdOutDegH.AddDat(NI.GetId()) = NI.GetOutDeg();
2230      if (NI.GetOutDeg() == 0) {
2231        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2232    }
2233    NIdOutDegH.SortByDat(true);
2234    THash&lt;TInt, TIntPr&gt; ClustCntH;
2235    while (NIdOutDegH.Len() &gt; 0 &amp;&amp; NIdOutDegH[0] == 0) {
2236      for (int i = 0; i &lt; NIdOutDegH.Len() &amp;&amp; NIdOutDegH[i] == 0; i++) {
2237        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2238        for (int e = 0; e &lt; NI.GetInDeg(); e++) {
2239          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2240        ClustCntH.Clr(false);
2241        for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2242          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1;
2243          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2244        }
2245        ClustCntH.SortByDat(false);
2246        if (ClustCntH.Len() &gt; 0) {
2247          KeepEdgeV.Add(TIntPr(NI.GetId(), ClustCntH[0].Val2));
2248        }
2249        NIdOutDegH[i] = TInt::Mx;
2250      }
2251      NIdOutDegH.SortByDat(true);
2252    } }
2253    printf(&quot;%d\n&quot;, EdgeH.Len());
2254    for (int e = 0; e &lt; KeepEdgeV.Len(); e++) {
2255      EdgeH.AddDat(KeepEdgeV[e].Val1) = KeepEdgeV[e].Val2;
2256    }
2257    printf(&quot;%d\n&quot;, EdgeH.Len());
2258    EdgeH.GetKeyDatPrV(KeepEdgeV);
2259    int CurScore = EvalPhraseClusters(KeepEdgeV);
2260    while (true) {
2261        const int RndNId = OutNIdV.GetKey(TInt::Rnd.GetUniDevInt(OutNIdV.Len()));
2262        const int RndEdge = OutNIdV.GetDat(RndNId)[TInt::Rnd.GetUniDevInt(OutNIdV.GetDat(RndNId).Len())];
2263        const int id = EdgeH.GetKeyId(RndNId);  IAssert(KeepEdgeV[id].Val1 == RndNId);
2264        if (KeepEdgeV[id].Val2 == RndEdge) { continue; } 
2265        const int OldE = KeepEdgeV[id].Val2;
2266        KeepEdgeV[id].Val2 = RndEdge;
2267      const int NewScore = EvalPhraseClusters(KeepEdgeV, false);
2268      if (NewScore &gt; CurScore &amp;bsol;*|| TInt::Rnd.GetUniDev() &lt; 0.1*/) {
2269        printf(&quot;%6d --&gt; %6d\n&quot;, CurScore, NewScore);
2270        CurScore = NewScore;
2271      }
2272      else {  KeepEdgeV[id].Val2 = OldE; } 
2273    }
2274  }
2275  TChA InsertLineBreaks(const TChA&amp; ChA, const int&amp; BreakAtPost) {
2276    TChA Tmp = ChA, Out;
2277    int Lines = 1;
2278    TVec&lt;char*&gt; WrdV;
2279    TStrUtil::SplitWords(Tmp, WrdV);
2280    for (int w = 0; w &lt; WrdV.Len(); w++) {
2281      if (Out.Len() + (int)strlen(WrdV[w]) &gt; Lines*BreakAtPost) {
2282        Lines++; Out+=&quot;\\n&quot;; }
2283      Out += WrdV[w];
2284      Out += &quot; &quot;;
2285    }
2286    return Out;
2287  }
2288  void TClustNet::DrawNet(const TStr&amp; OutFNm, const int&amp; SaveTopN) const {
2289    TCnComV CnComV;
2290    TSnap::GetWccs(GetThis(), CnComV);
2291    CnComV.Sort(false);
2292    for (int Comp = 0; Comp&lt;TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2293      if (CnComV[Comp].Len() &lt; 5) { continue; }
2294      TPt&lt;TNet&gt; SubNet = TSnap::GetSubGraph(TPt&lt;TNet&gt;((TClustNet*) this), CnComV[Comp].NIdV);
2295      printf(&quot;draw: %d nodes, %d edges\n&quot;, SubNet-&gt;GetNodes(), SubNet-&gt;GetEdges());
2296      FILE *F = fopen(TStr::Fmt(&quot;%s-c%02d.dot&quot;, OutFNm.CStr(), Comp).CStr(), &quot;wt&quot;);
2297      fprintf(F, &quot;digraph G { &amp;bsol;*%d nodes, %d edges*/\n&quot;, SubNet-&gt;GetNodes(), SubNet-&gt;GetEdges());
2298      fprintf(F, &quot;  graph [splines=true overlap=false rankdir=LR]\n&quot;);
2299      fprintf(F, &quot;  node  [shape=box, fontsize=14]\n&quot;);
2300      for (TNet::TNodeI NI = SubNet-&gt;BegNI(); NI &lt; SubNet-&gt;EndNI(); NI++) {
2301        fprintf(F, &quot;  %d [label=\&quot;%s (%d, %d)\&quot;];\n&quot;, NI.GetId(), InsertLineBreaks(NI().GetStr(), 80).CStr(), NI().GetFq(), NI().GetUrls());
2302      }
2303      for (TNet::TEdgeI EI = SubNet-&gt;BegEI(); EI &lt; SubNet-&gt;EndEI(); EI++) {
2304        fprintf(F, &quot;  %d -&gt; %d;\n&quot;, EI.GetSrcNId(), EI.GetDstNId());
2305      }
2306      fprintf(F, &quot;}\n&quot;);
2307      fclose(F);
2308      TGraphViz::DoLayout(TStr::Fmt(&quot;%s-c%02d.dot&quot;, OutFNm.CStr(), Comp), TStr::Fmt(&quot;%s-c%02d.ps&quot;, OutFNm.CStr(), Comp), gvlDot);
2309      TSnap::SavePajek(SubNet, TStr::Fmt(&quot;%s-c%02d.net&quot;, OutFNm.CStr(), Comp));
2310    }
2311  }
2312  void TClustNet::DumpNodes(const TStr&amp; OutFNm, const int&amp; SaveTopN) const {
2313    TIntV NIdV;  GetNIdV(NIdV);
2314    TIntH NIdCompSzH;
2315    { TCnComV CnComV;
2316    TSnap::GetWccs(GetThis(), CnComV);
2317    for (int c = 0; c &lt; CnComV.Len(); c++) {
2318      for (int n = 0; n &lt; CnComV[c].NIdV.Len(); n++) {
2319        NIdCompSzH.AddDat(CnComV[c].NIdV[n], CnComV[c].Len());
2320      }
2321    } }
2322    TIntPrV FqNIdV;
2323    for (int n = 0; n &lt; NIdV.Len(); n++) {
2324      FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2325    }
2326    FqNIdV.Sort(false);
2327    FILE *F = fopen(TStr::Fmt(&quot;nodes-%s.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
2328    fprintf(F, &quot;#Freq\tClustSz\tQuote\n&quot;);
2329    for (int i = 0; i &lt; FqNIdV.Len(); i++) {
2330      const TQuote&amp; Q = GetNDat(FqNIdV[i].Val2);
2331      fprintf(F, &quot;%d\t%d\t%s\n&quot;, Q.GetFq(), NIdCompSzH.GetDat(FqNIdV[i].Val2).Val, Q.GetStr().CStr());
2332    }
2333  }
2334  void TClustNet::DumpClusters(const TStr&amp; OutFNm, int SaveTopN) const {
2335    TCnComV CnComV;
2336    TSnap::GetWccs(GetThis(), CnComV); 
2337    CnComV.Sort(false);
2338    FILE *F = fopen(TStr::Fmt(&quot;clust-%s.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
2339    if (SaveTopN==-1) { SaveTopN=TInt::Mx; }
2340    for (int Comp = 0; Comp&lt;TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2341      const TIntV&amp; NIdV = CnComV[Comp].NIdV;
2342      TIntPrV FqNIdV;
2343      int SumFq=0;
2344      for (int n = 0; n &lt; NIdV.Len(); n++) {
2345        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2346        SumFq += GetNDat(NIdV[n]).GetFq();
2347      }
2348      FqNIdV.Sort(false);
2349      fprintf(F, &quot;%d quotes, total freq %d\n&quot;, FqNIdV.Len(), SumFq);
2350      for (int i = 0; i &lt; FqNIdV.Len(); i++) {
2351        const TQuote&amp; Q = GetNDat(FqNIdV[i].Val2);
2352        fprintf(F, &quot;%d\t%s\n&quot;, Q.GetFq(), Q.GetStr().CStr());
2353      }
2354      fprintf(F, &quot;\n&quot;);
2355    }
2356  }
2357  void TClustNet::DumpClustersByVol(const TStr&amp; OutFNm, const int&amp; MinClustSz, const int&amp; MinVolume) const {
2358    TCnComV CnComV;
2359    TSnap::GetWccs(GetThis(), CnComV);
2360    CnComV.Sort(false);
2361    TIntPrV FqClustV;
2362    TIntH ClSzH, ClFqH;
2363    int FqMore1k=0;
2364    for (int Comp = 0; Comp &lt; CnComV.Len(); Comp++) {
2365      const TIntV&amp; NIdV = CnComV[Comp].NIdV;
2366      if (NIdV.Len() &lt; MinClustSz) { continue; } 
2367      int SumFq=0;
2368      for (int n = 0; n &lt; NIdV.Len(); n++) {
2369        SumFq += GetNDat(NIdV[n]).GetFq(); }
2370      FqClustV.Add(TIntPr(SumFq, Comp));
2371      ClFqH.AddDat(SumFq) += 1;
2372      ClSzH.AddDat(NIdV.Len()) += 1;
2373      if (SumFq&gt;500) { FqMore1k++; }
2374    }
2375    FqClustV.Sort(false);
2376    FILE *F = fopen(TStr::Fmt(&quot;clustFq-%s.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
2377    fprintf(F, &quot;Cluster network:\n%d nodes\n%d edges\n%d clusters\n%d big clusters (&gt;=%d)\n&quot;,
2378      GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz);
2379    for (int c = 0; c &lt; FqClustV.Len(); c++) {
2380      const TIntV&amp; NIdV = CnComV[FqClustV[c].Val2].NIdV;
2381      TIntPrV FqNIdV;
2382      int SumFq=0;
2383      for (int n = 0; n &lt; NIdV.Len(); n++) {
2384        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2385        SumFq += GetNDat(NIdV[n]).GetFq();
2386      }
2387      if (SumFq &lt; MinVolume) { continue; }
2388      FqNIdV.Sort(false);
2389      fprintf(F, &quot;%d\t%d items\t%d totFq\n&quot;, c, FqNIdV.Len(), SumFq);
2390      for (int i = 0; i &lt; FqNIdV.Len(); i++) {
2391        const TQuote&amp; Q = GetNDat(FqNIdV[i].Val2);
2392        fprintf(F, &quot;\t%d\t%s\n&quot;, Q.GetFq(), Q.GetStr().CStr());
2393      }
2394      fprintf(F, &quot;\n&quot;);
2395    }
2396    TGnuPlot::PlotValCntH(ClFqH, &quot;clVol.&quot;+OutFNm, TStr::Fmt(&quot;%s. %d nodes, %d edges, %d clusters, %d big clusters (&gt;=%d), %d with vol&gt;500&quot;,
2397      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), &quot;Cluster volume&quot;, &quot;Count&quot;, gpsLog);
2398    TGnuPlot::PlotValCntH(ClSzH, &quot;clSz.&quot;+OutFNm, TStr::Fmt(&quot;%s. %d nodes, %d edges, %d clusters, %d big clusters (&gt;=%d), %d with vol&gt;500&quot;,
2399      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), &quot;Cluster size&quot;, &quot;Count&quot;, gpsLog);
2400  }
2401  void BuildPhraseInvertIdx(const PQuoteBs&amp; QtBs, TStrHash&lt;TInt&gt;&amp; WordIdH, THash&lt;TInt, TIntV&gt;&amp; WIdQtIdVH) {
2402    printf(&quot;build quote word inverted index\n&quot;);
2403    TIntV WIdV;
2404    TIntSet WIdSet;
2405    for (int q = 0; q &lt; QtBs-&gt;Len(); q++) {
2406      const TQuote&amp; Q = QtBs-&gt;GetQtN(q);
2407      TStrUtil::GetAddWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2408      const int Doms = Q.GetDoms(*QtBs);
2409      if (! (Doms&gt;1 &amp;&amp; Doms*4 &gt; Q.GetUrls() &amp;&amp; Q.GetFq() &gt;= 5)) { 
2410        continue;
2411      }
2412      WIdSet.Clr(false); 
2413      for (int w = 0; w &lt; WIdV.Len(); w++) {
2414        WIdSet.AddKey(WIdV[w]);
2415      }
2416      for (int w = 0; w &lt; WIdSet.Len(); w++) {
2417        WIdQtIdVH.AddDat(WIdSet[w]).Add(q);
2418      }
2419    }
2420    for (int i = 0; i &lt; WIdQtIdVH.Len(); i++) {
2421      WIdQtIdVH[i].Pack();
2422    }
2423    printf(&quot;done.\n&quot;);
2424  }
2425  bool IsLinkPhrases(const PQuoteBs&amp; QtBs, const int&amp; QtN1, const int&amp; QtN2, TStrHash&lt;TInt&gt;&amp; WordIdH, THash&lt;TInt, TIntV&gt;&amp; QtToWordIdVH) {
2426    if (! QtToWordIdVH.IsKey(QtN1)) {
2427      TIntV WIdV;
2428      TStrUtil::GetWIdV(WordIdH, QtBs-&gt;GetQtN(QtN1).GetStr().CStr(), WIdV);
2429      WIdV.Pack();
2430      QtToWordIdVH.AddDat(QtN1, WIdV);
2431    }
2432    if (! QtToWordIdVH.IsKey(QtN2)) {
2433      TIntV WIdV;
2434      TStrUtil::GetWIdV(WordIdH, QtBs-&gt;GetQtN(QtN2).GetStr().CStr(), WIdV);
2435      WIdV.Pack();
2436      QtToWordIdVH.AddDat(QtN2, WIdV);
2437    }
2438    int idx1=0, idx2=0, SkipTy=0;
2439    const TIntV&amp; WIdV1 = QtToWordIdVH.GetDat(QtN1);
2440    const TIntV&amp; WIdV2 = QtToWordIdVH.GetDat(QtN2);
2441    const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2442    const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, idx1, idx2, SkipTy);
2443    bool DoMerge = false;
2444    if (ShortLen &lt;= 5 &amp;&amp; Overlap == ShortLen &amp;bsol;*&amp;&amp; SkipTy==0*/) { DoMerge=true; } 
2445    else if ((ShortLen == 6 &amp;&amp; Overlap &gt;= 5 &amp;bsol;*&amp;&amp; SkipTy==0) || (ShortLen == 6 &amp;&amp; Overlap == 5*/)) { DoMerge=true; }
2446    else if (Overlap/double(ShortLen+3) &gt; 0.5 || Overlap &gt; 10) { DoMerge=true; }
2447    return DoMerge;
2448  }
2449  PClustNet TClustNet::GetFromQtBs(const PQuoteBs&amp; QtBs, int MinQtFq, int MnWrdLen) {
2450    TStrHash&lt;TInt&gt; WordIdH;
2451    THash&lt;TInt, TIntV&gt; WIdQtIdVH; 
2452    BuildPhraseInvertIdx(QtBs, WordIdH, WIdQtIdVH);
2453    PClustNet Net = TClustNet::New();
2454    TVec&lt;int&gt; QtSharCnt(QtBs-&gt;Len()), QtWrdLen(QtBs-&gt;Len());
2455    THash&lt;TInt, TIntV&gt; QtToWordIdVH;   
2456    TIntV WIdV;
2457    TIntH CandLenH, LinkLenH;
2458    THash&lt;TInt, TIntH&gt; QtLenCandH, QtLenLinkH;
2459    int AllCand=0, AllLinks=0;
2460    TExeTm ExeTm;
2461    for (int qt = 0; qt &lt; QtBs-&gt;Len(); qt++) {
2462      QtWrdLen[qt] = TStrUtil::CountWords(QtBs-&gt;GetQtN(qt).GetStr().CStr());
2463    }
2464    const int QtBsLen = QtBs-&gt;Len();
2465    for (int qt = 0; qt &lt; QtBs-&gt;Len(); qt++) {
2466      const TQuote&amp; Q = QtBs-&gt;GetQtN(qt);
2467      const int Doms = Q.GetDoms(*QtBs);
2468    if (! (Doms&gt;1 &amp;&amp; Doms*4 &gt; Q.GetUrls() &amp;&amp; Q.GetFq() &gt;= MinQtFq &amp;&amp;
2469      TStrUtil::CountWords(Q.GetStr())&gt;=MnWrdLen)) {
2470        continue; }
2471      memset(QtSharCnt.BegI(), 0, sizeof(int)*QtSharCnt.Len());
2472      TStrUtil::GetWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2473      if (! QtToWordIdVH.IsKey(qt)) {
2474        WIdV.Pack();
2475        QtToWordIdVH.AddDat(qt, WIdV);
2476      }
2477      for (int w = 0; w &lt; WIdV.Len(); w++) {
2478        IAssert(WIdQtIdVH.IsKey(WIdV[w]));
2479        const TIntV&amp; QtIdV = WIdQtIdVH.GetDat(WIdV[w]);
2480        for (int q = 0; q &lt; QtIdV.Len(); q++) {
2481          QtSharCnt[QtIdV[q]] += 1;
2482        }
2483      }
2484      const int W = WIdV.Len();
2485      int Candidates = 0, Links = 0, MinSharedWords = W-3;
2486      if (W &lt;= 5) { MinSharedWords = W-1; }
2487      else if (W &lt;= 10) { MinSharedWords = W-2; }
2488      for (int q = 0; q &lt; QtSharCnt.Len(); q++) {
2489        if (QtSharCnt[q] &gt;= MinSharedWords &amp;&amp; (QtWrdLen[q] &gt;= W || QtWrdLen[q] &gt; 20)) {
2490          const TQuote&amp; Qt2 = QtBs-&gt;GetQtN(q);
2491          if (Doms&gt;1 &amp;&amp; Doms*4 &gt; Q.GetUrls() &amp;&amp; Q.GetFq() &gt;= MinQtFq) { 
2492            if (IsLinkPhrases(QtBs, qt, q, WordIdH, QtToWordIdVH)) {    
2493              Net-&gt;AddLink(Q, Qt2);
2494              Links++;
2495            }
2496          }
2497          Candidates++;
2498        }
2499      }
2500      AllCand += Candidates;
2501      AllLinks += Links;
2502      CandLenH.AddDat(Candidates) += 1;
2503      LinkLenH.AddDat(Links) += 1;
2504      if (W &lt; 21) {
2505        QtLenCandH.AddDat(W).AddDat(Candidates) += 1;
2506        QtLenLinkH.AddDat(W).AddDat(Links) += 1;
2507      }
2508      if (qt % 1000 == 0 || qt==QtBsLen-1) {
2509        printf(&quot;\r%d  %s    allCands: %d    allLinks: %d    nodes:%d&quot;, qt, ExeTm.GetStr(), AllCand, AllLinks, Net-&gt;GetNodes());
2510        if (qt % 100000 == 0 || qt==QtBsLen-1) {
2511          TGnuPlot::PlotValCntH(CandLenH, &quot;qtNet-NCand&quot;, &quot;Number of candidate links for each quote (candidate has at most 2*words)&quot;,
2512            &quot;ClustNet: number of candidate quotes to create link to&quot;, &quot;Count&quot;, gpsLog);
2513          TGnuPlot::PlotValCntH(LinkLenH, &quot;qtNet-NLink&quot;, &quot;Number of links for each quote (candidate has at most 2*words)&quot;,
2514            &quot;ClustNet: number of out-links of a quote&quot;, &quot;Count&quot;, gpsLog);
2515        }
2516      }
2517    }
2518    printf(&quot;done.\n&quot;);
2519    TGnuPlot::PlotValCntH(CandLenH, &quot;qtNet-NCand&quot;, &quot;Number of candidate links for each quote (candidate has at most 2*words)&quot;,
2520      &quot;ClustNet: number of candidate quotes to create link to&quot;, &quot;Count&quot;, gpsLog);
2521    TGnuPlot::PlotValCntH(LinkLenH, &quot;qtNet-NLink&quot;, &quot;Number of links for each quote (candidate has at most 2*words)&quot;,
2522      &quot;ClustNet: number of out-links of a quote&quot;, &quot;Count&quot;, gpsLog);
2523    return Net;
2524  }
2525  void TQuoteLoader::Clr() {
2526    PostTitleStr.Clr();
2527    PostUrlStr.Clr();
2528    PubTm = TSecTm();
2529    BlogUrlStr.Clr();
2530    BlogTitleStr.Clr();
2531    ContentStr.Clr();
2532    QuoteV.Clr(false);
2533    LinkV.Clr(false);
2534  }
2535  bool TQuoteLoader::LoadItem(TXmlLx&amp; XmlLx) {
2536    static const TSecTm BegOfTm(2008,8,30, 0, 0, 0);
2537    Clr();
2538    try {
2539      EAssert(XmlLx.TagNm == &quot;post&quot;);
2540      const TChA T = TStrUtil::GetXmlTagVal(XmlLx, &quot;pubDate&quot;);
2541      PubTm = TSecTm(atoi(T.GetSubStr(0,3).CStr()), atoi(T.GetSubStr(5,6).CStr()), atoi(T.GetSubStr(8,9).CStr()),
2542        atoi(T.GetSubStr(11,12).CStr()), atoi(T.GetSubStr(14,15).CStr()), atoi(T.GetSubStr(17,18).CStr()));
2543      EAssert(PubTm &gt; BegOfTm);
2544      PostUrlStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;postUrl&quot;);
2545      PostTitleStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;postTitle&quot;);
2546      BlogUrlStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;blogUrl&quot;);
2547      BlogTitleStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;blogTitle&quot;);
2548      ContentStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;content&quot;);
2549      while (XmlLx.GetSym()==xsySTag &amp;&amp; XmlLx.TagNm==&quot;q&quot;) {
2550        EAssert(XmlLx.GetSym() == xsyStr);
2551        QuoteV.Add(XmlLx.TxtChA);
2552        EAssert(XmlLx.GetSym() == xsyETag &amp;&amp; XmlLx.TagNm==&quot;q&quot;);
2553      }
2554    }
2555    catch (PExcept Except){
2556      ErrNotify(Except-&gt;GetStr());
2557      Fail;  return false;
2558    }
2559    return true;
2560  }
2561  void TQuoteLoader::Save(TSOut&amp; SOut) const {
2562    PubTm.Save(SOut);
2563    PostUrlStr.Save(SOut);
2564    PostTitleStr.Save(SOut);
2565    BlogUrlStr.Save(SOut);
2566    BlogTitleStr.Save(SOut);
2567    ContentStr.Save(SOut);
2568    QuoteV.Save(SOut);
2569    LinkV.Save(SOut);
2570  }
2571  void TQuoteLoader::Load(TSIn&amp; SIn) {
2572    PubTm.Load(SIn);
2573    PostUrlStr.Load(SIn);
2574    PostTitleStr.Load(SIn);
2575    BlogUrlStr.Load(SIn);
2576    BlogTitleStr.Load(SIn);
2577    ContentStr.Load(SIn);
2578    QuoteV.Load(SIn);
2579    LinkV.Load(SIn);
2580  }
2581  bool TQuoteLoader::Next() {
2582    if (SIn.Empty() || SIn-&gt;Eof()) {
2583      printf(&quot;  new file&quot;);
2584      if (! FFile.Next(CurFNm)) { return false; }
2585      printf(&quot; %s\n&quot;, CurFNm.GetFMid().CStr());
2586      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2587      StartProcFile(CurFNm);
2588    }
2589    Load(*SIn);
2590    if (++PostCnt % Kilo(10) == 0) { printf(&quot;\r  %dk [%s]  &quot;, PostCnt/Kilo(1), ExeTm.GetStr()); }
2591    return true;
2592  }
2593  void TQuoteLoader::ProcessPosts(const bool&amp; IsXml, int LoadN) {
2594    TExeTm ExeTm, TotalTm;
2595    StartProcess();
2596    if (LoadN &lt; 0) { LoadN = TInt::Mx; }
2597    int FilePostCnt=0;
2598    for (int f = 1; FFile.Next(CurFNm); f++) {
2599      printf(&quot;*** FILE:  %s\n&quot;, CurFNm.GetFMid().CStr());
2600      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2601      if (IsXml) {
2602        TXmlLx XmlLx(SIn, xspTruncate);
2603        StartProcFile(CurFNm);
2604        for (FilePostCnt=0; XmlLx.GetSym() != xsyEof; FilePostCnt++, PostCnt++) {
2605          if (! (XmlLx.Sym==xsySTag &amp;&amp; XmlLx.TagNm==&quot;post&quot;)) {
2606            while (XmlLx.GetSym()!=xsyEof &amp;&amp; ! (XmlLx.Sym==xsySTag &amp;&amp; XmlLx.TagNm==&quot;post&quot;)) { }
2607            if (XmlLx.Sym == xsyEof) { break; }
2608          }
2609          const bool IsGoodPost = LoadItem(XmlLx);
2610          ProcessPost(IsGoodPost);
2611          if (PostCnt % Kilo(1) == 0) {
2612            printf(&quot;\r%dk [%s] &quot;, PostCnt/Kilo(1), ExeTm.GetStr()); }
2613          if (PostCnt &gt;= LoadN) { break; }
2614        }
2615      } else {
2616        FilePostCnt = 0;
2617        while (! SIn-&gt;Eof()) {
2618          Load(*SIn);  FilePostCnt++;  PostCnt++;
2619          ProcessPost(true);
2620          if (PostCnt % Kilo(10) == 0) {
2621            printf(&quot;\r%dk [%s] &quot;, PostCnt/Kilo(1), ExeTm.GetStr()); }
2622          if (PostCnt &gt;= LoadN) { break; }
2623        }
2624      }
2625      printf(&quot;\n================================================================\n&quot;);
2626      printf(&quot;  file:  %s\n&quot;, CurFNm.GetFMid().CStr());
2627      printf(&quot;  time:  %s   &quot;, ExeTm.GetStr());
2628      printf(&quot;total: %s [%s]\n&quot;, TotalTm.GetStr(), TExeTm::GetCurTm());
2629      printf(&quot;  posts: %d   total: %d\n&quot;, FilePostCnt, PostCnt);
2630      EndProcFile(CurFNm);
2631      fflush(stdout);  ExeTm.Tick();
2632      if (PostCnt &gt;= LoadN) { break; }
2633    }
2634    EndProcess(PostCnt);
2635  }
2636  bool TMemesDataLoader::GetNextFile() {
2637    TStr FNm;
2638    if (! FFile.Empty()) {
2639      if (! FFile-&gt;Next(FNm)) { return false; }
2640      printf(&quot;NEXT-FL:  %s :\t%s\n&quot;, FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2641    } else {
2642      IAssert(! InFNmF.Empty());
2643      if (InFNmF-&gt;Eof()) { return false; }
2644    while (! InFNmF-&gt;Eof() &amp;&amp; InFNmF-&gt;GetNextLn(FNm) &amp;&amp; FNm.Empty()) { }
2645      printf(&quot;NEXT-LN:  %s :\t%s\n&quot;, FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2646    }
2647    if (FNm.Empty()) { return false; }
2648    if (TZipIn::IsZipExt(FNm.GetFExt())) {
2649      SInPt = TZipIn::New(FNm); }
2650    else {
2651      SInPt = TFIn::New(FNm); }  LineCnt = 0;
2652    return true;
2653  }
2654  void TMemesDataLoader::Clr() {
2655    PostUrlStr.Clr();
2656    ContentStr.Clr();
2657    PubTm = TSecTm();
2658    MemeV.Clr(false);
2659    MemePosV.Clr(false);
2660    LinkV.Clr(false);
2661    LinkPosV.Clr(false);
2662  }
2663  bool TMemesDataLoader::LoadNext() {
2664    Clr();
2665    if (SInPt.Empty() || SInPt-&gt;Eof()) {
2666      if (! GetNextFile()) { return false; }
2667    }
2668    TSIn&amp; SIn = *SInPt;
2669    CurLn.Clr();
2670    while (SIn.GetNextLn(CurLn) &amp;&amp; (CurLn.Empty() || (CurLn[0]!=&#x27;U&#x27; || CurLn[1]!=&#x27;\t&#x27;))) { 
2671      printf(&quot;L: %s\n&quot;, CurLn.CStr()); LineCnt++; }
2672    LineCnt++;
2673    if (CurLn.Empty()) { return LoadNext(); }
2674    IAssertR((! CurLn.Empty()) &amp;&amp; CurLn[0]==&#x27;U&#x27; &amp;&amp; CurLn[1]==&#x27;\t&#x27;, 
2675      TStr::Fmt(&quot;ERROR1: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());
2676    PostUrlStr = CurLn.CStr()+2;
2677    while (SIn.GetNextLn(CurLn) &amp;&amp; (CurLn.Empty() || (CurLn[0]!=&#x27;D&#x27; || CurLn[1]!=&#x27;\t&#x27;))) { LineCnt++; }
2678    IAssertR((! CurLn.Empty()) &amp;&amp; CurLn[0]==&#x27;D&#x27;, 
2679      TStr::Fmt(&quot;ERROR2: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2680    try {
2681      PubTm = TSecTm::GetDtTmFromStr(CurLn);
2682    } catch (PExcept Except){ PubTm = 1; ErrNotify(Except-&gt;GetStr());
2683      printf(&quot;ERROR3: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()); 
2684    }
2685    IAssertR(SIn.GetNextLn(CurLn) &amp;&amp; (! CurLn.Empty()) &amp;&amp; (CurLn[0]==&#x27;C&#x27; || CurLn[0]==&#x27;T&#x27;), 
2686      TStr::Fmt(&quot;ERROR4: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2687    if (CurLn[0] == &#x27;T&#x27;) { 
2688      IAssertR(SIn.GetNextLn(CurLn) &amp;&amp; (! CurLn.Empty()) &amp;&amp; CurLn[0]==&#x27;C&#x27;, 
2689        TStr::Fmt(&quot;ERROR5: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++; }
2690    ContentStr = CurLn.CStr()+2;
2691    while (SIn.GetNextLn(CurLn)) {  LineCnt++;
2692      if (CurLn.Empty() || CurLn[0]!=&#x27;L&#x27;) { break; }
2693      int linkb=2;
2694      while (CurLn[linkb]!=&#x27;\t&#x27;) { linkb++; }
2695      CurLn[linkb]=0;
2696      LinkV.Add(CurLn.CStr()+linkb+1);
2697      LinkPosV.Add(atoi(CurLn.CStr()+2));
2698    }
2699    do {
2700      if (CurLn.Empty() || CurLn[0]!=&#x27;Q&#x27;) { break; }
2701      int qb1=2;      while (CurLn[qb1]!=&#x27;\t&#x27;) { qb1++; }
2702      int qb2=qb1+1;  while (CurLn[qb2]!=&#x27;\t&#x27;) { qb2++; }
2703      CurLn[qb1]=0;  CurLn[qb2]=0;
2704      MemeV.Add(CurLn.CStr()+qb2+1);
2705      MemePosV.Add(TIntPr(atoi(CurLn.CStr()+2), atoi(CurLn.CStr()+qb1+1)));
2706      LineCnt++;
2707    } while (SIn.GetNextLn(CurLn));
2708    return true;
2709  }
2710  void TMemesDataLoader::SaveTxt(TSOut&amp; SOut) const {
2711  }
2712  void TMemesDataLoader::Dump(const bool&amp; DumpAll) const {
2713  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &quot;memes.h&quot;
3  int TQuote::GetFq() const {
4    int fq=0;
5    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
6      fq+=TmUrlCntV[i].Cnt(); }
7    return fq;
8  }
9  int TQuote::GetFq(const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
10    int fq=0;
11    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
12      if (TmUrlCntV[i].Tm() &gt;= BegTm &amp;&amp; TmUrlCntV[i].Tm() &lt; EndTm) {
13        fq += TmUrlCntV[i].Cnt(); } 
14    }
15    return fq;
16  }
17  int TQuote::GetDoms(const TQuoteBs&amp; QtBs) const {
18    THashSet&lt;TChA&gt; DomSet;
19    for (int u = 0; u &lt; TmUrlCntV.Len(); u++) {
20      DomSet.AddKey(TStrUtil::GetDomNm(QtBs.GetStr(TmUrlCntV[u].UrlId())));
21    }
22    return DomSet.Len();
23  }
24  int TQuote::GetFq(const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
25    int fq=0;
26    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
27      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
28        fq += TmUrlCntV[i].Cnt(); } 
29    }
30    return fq;
31  }
32  int TQuote::GetFq(const TSecTm&amp; BegTm, const TSecTm&amp; EndTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
33    int fq=0;
34    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
35      if (TmUrlCntV[i].Tm() &gt;= BegTm &amp;&amp; TmUrlCntV[i].Tm() &lt;= EndTm &amp;&amp;
36       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
37        fq+=1; }
38    }
39    return fq;
40  }
41  int TQuote::GetUrls(const TSecTm&amp; BegTm, const TSecTm&amp; EndTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
42    int urls=0;
43    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
44      if (TmUrlCntV[i].Tm() &gt;= BegTm &amp;&amp; TmUrlCntV[i].Tm() &lt; EndTm &amp;&amp;
45       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
46        urls+=1; }
47    }
48    return urls;
49  }
50  TSecTm TQuote::GetPeakTm(const TTmUnit&amp; TmUnit, const TSecTm&amp; AfterTm) const {
51    TInt FreqAtPeak;
52    return GetPeakTm(TmUnit, AfterTm, FreqAtPeak);
53  }
54  TSecTm TQuote::GetPeakTm(const TTmUnit&amp; TmUnit, const TSecTm&amp; AfterTm, TInt&amp; FreqAtPeak) const {
55    const TSecTm After = AfterTm.Round(TmUnit);
56    THash&lt;TSecTm, TInt&gt; TmFqH;
57    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
58      if (TmUrlCntV[i].Tm().Round(TmUnit) &gt;= After) {
59        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); }
60    }
61    if (TmFqH.Empty()) {
62      FreqAtPeak = 0;
63      return GetPeakTm(TmUnit, TSecTm(1));
64    }
65    TmFqH.SortByDat(false);
66    FreqAtPeak = TmFqH[0];
67    return TmFqH.GetKey(0);
68  }
69  TSecTm TQuote::GetPeakTm(const TTmUnit&amp; TmUnit, const TSecTm&amp; AfterTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
70    const TSecTm After = AfterTm.Round(TmUnit);
71    THash&lt;TSecTm, TInt&gt; TmFqH;
72    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
73      if (TmUrlCntV[i].Tm().Round(TmUnit) &gt;= After &amp;&amp; (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
74        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); } 
75    }
76    if (TmFqH.Empty()) {
77      return GetPeakTm(TmUnit, TSecTm(1)); }
78    TmFqH.SortByDat(false);
79    return TmFqH.GetKey(0);
80  }
81  TSecTm TQuote::GetMeanTm(const TTmUnit&amp; TmUnit, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs, const TSecTm&amp; AfterTm) const {
82    const TSecTm After = AfterTm.Round(TmUnit);
83    double MeanTm = 0;
84    int Cnt = 0;
85    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
86      if (TmUrlCntV[i].Tm().Round(TmUnit) &gt;= After &amp;&amp; (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
87        MeanTm += TmUrlCntV[i].Tm().Round(TmUnit) * TmUrlCntV[i].Cnt();
88        Cnt += TmUrlCntV[i].Cnt();
89      }
90    }
91    return TSecTm(uint(MeanTm/double(Cnt))).Round(TmUnit);
92  }
93  TSecTm TQuote::GetMedianTm(const TTmUnit&amp; TmUnit, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs, const TSecTm&amp; AfterTm) const {
94    const TSecTm After = AfterTm.Round(TmUnit);
95    TMom Mom;
96    for(int i=0; i&lt;TmUrlCntV.Len(); i++) {
97      if (TmUrlCntV[i].Tm().Round(TmUnit) &gt;= After &amp;&amp; (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
98        Mom.Add(TmUrlCntV[i].Tm().Round(TmUnit).GetAbsSecs(), TmUrlCntV[i].Cnt());
99      }
100    }
101    Mom.Def();
102    return TSecTm(uint(Mom.GetMedian())).Round(TmUnit);
103  }
104  bool TQuote::IsSinglePeak(const TTmUnit&amp; TmUnit, const TSecTm&amp; AfterTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
105    const double PeakThresh = 0.4;
106    TTmFltPrV FqOtV, SmoothV;
107    GetFqOt(FqOtV, TmUnit, UrlTy, QtBs);
108    TQuote::GetSmoothFqOt(SmoothV, FqOtV, TmUnit, 48, 1.2, AfterTm); 
109    SmoothV.Swap(FqOtV);
110    double MaxVal=0;
111    int maxI=0, maxL=0, maxR=0;
112    for (int i = 0; i &lt; FqOtV.Len(); i++) {
113      if (MaxVal &lt; FqOtV[i].Val2) {
114        MaxVal = FqOtV[i].Val2;  maxI=i; }
115    }
116    MaxVal *= PeakThresh;
117    for (maxL = maxI; maxL&gt;0 &amp;&amp; FqOtV[maxL].Val2 &gt; MaxVal; maxL--) { }
118    for (maxR = maxI; maxR&lt;FqOtV.Len() &amp;&amp; FqOtV[maxR].Val2 &gt; MaxVal; maxR++) { }
119    if (maxR-maxL &gt; 100) { return false; }
120    for (int i = maxR; i &lt; FqOtV.Len(); i++) {
121      if (FqOtV[i].Val2 &gt; MaxVal) { return false; }
122    }
123    for (int i = maxL; i &gt;= 0; i--) {
124      if (FqOtV[i].Val2 &gt; MaxVal) { return false; }
125    }
126    return true;
127  }
128  void TQuote::GetFqOt(TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit) const {
129    THash&lt;TSecTm, TFlt&gt; TmCntH;
130    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
131      TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
132    }
133    TmCntH.SortByKey();
134    TmCntH.GetKeyDatPrV(RawFqOtV);
135  }
136  void TQuote::GetFqOt(TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
137    THash&lt;TSecTm, TFlt&gt; TmCntH;
138    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
139      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
140        TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
141      }
142    }
143    TmCntH.SortByKey();
144    TmCntH.GetKeyDatPrV(RawFqOtV);
145  }
146  void TQuote::GetFqOt(TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
147    const TSecTm RBegTm = BegTm.Round(TmUnit);
148    const TSecTm REndTm = EndTm.Round(TmUnit);
149    THash&lt;TSecTm, TFlt&gt; TmCntH;
150    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
151      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
152      if (Tm &gt;= RBegTm &amp;&amp; Tm &lt;= REndTm) {
153        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
154      }
155    }
156    TmCntH.SortByKey();
157    TmCntH.GetKeyDatPrV(RawFqOtV);
158  }
159  void TQuote::GetFqOt(TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm, const TUrlTy&amp; UrlTy, const TQuoteBs&amp; QtBs) const {
160    const TSecTm RBegTm = BegTm.Round(TmUnit);
161    const TSecTm REndTm = EndTm.Round(TmUnit);
162    THash&lt;TSecTm, TFlt&gt; TmCntH;
163    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
164      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
165      if (Tm &gt;= RBegTm &amp;&amp; Tm &lt;= REndTm &amp;&amp; (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
166        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
167      }
168    }
169    TmCntH.SortByKey();
170    TmCntH.GetKeyDatPrV(RawFqOtV);
171  }
172  void TQuote::GetSmoothFqOt(TTmFltPrV&amp; FqOtV, const TTmUnit&amp; TmUnit, const int&amp; WndSz, const double&amp; Smooth, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
173    TTmFltPrV RawFqOtV;
174    GetFqOt(RawFqOtV, TmUnit, BegTm, EndTm);
175    GetSmoothFqOt(FqOtV, RawFqOtV, TmUnit, WndSz, Smooth, BegTm, EndTm);
176  }
177  void TQuote::GetSmoothFqOt(TTmFltPrV&amp; SmoothFqOtV, const TTmFltPrV&amp; RawFqOtV, const TTmUnit&amp; TmUnit, const int&amp; WndSz, const double&amp; Smooth, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) {
178    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
179    const int HalfWndSecs = (WndSz/2)*TmUnitSecs;
180    double FullNormConst = 1;
181    for (int j = 1; j &lt;= WndSz/2; j++) {
182      FullNormConst += 2*pow(Smooth, -j); }
183    THash&lt;TSecTm, TFlt&gt; TmCntH;
184    for (int i = 0; i &lt; RawFqOtV.Len(); i++) {
185      const TSecTm Tm = RawFqOtV[i].Val1;
186      double NormConst = FullNormConst;
187      if (Tm &lt; BegTm+HalfWndSecs || Tm+HalfWndSecs &gt; EndTm) {
188        NormConst = 1;
189        for (int j = 1; j &lt;= WndSz/2; j++) {
190          if (Tm &gt;= BegTm+j*TmUnitSecs) { NormConst += pow(Smooth, -j);  }
191          if (Tm+j*TmUnitSecs &lt;= EndTm) { NormConst += pow(Smooth, -j);  }
192      } }
193      const double NormFq = RawFqOtV[i].Val2 / NormConst;
194      for (int j = 1; j &lt;= WndSz/2; j++) {
195        const int Off = j*TmUnitSecs;
196        if (Tm+Off &lt;= EndTm) {
197          TmCntH.AddDat(TSecTm(Tm+Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
198        if (Tm &gt;= BegTm + Off) {
199          TmCntH.AddDat(TSecTm(Tm-Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
200      }
201      TmCntH.AddDat(Tm.Round(TmUnit)) += NormFq;
202    }
203    TmCntH.SortByKey();
204    TmCntH.GetKeyDatPrV(SmoothFqOtV);
205  }
206  TStr TQuote::GetDesc() const {
207    return TStr::Fmt(&quot;#:%d U:%d  %s&quot;, GetFq(), GetUrls(), QtStr.CStr());
208  }
209  void TQuote::PlotOverTm(const TStr&amp; OutFNm) {
210    TFltFltH HrCntH;
211    TmUrlCntV.Sort();
212    if (TmUrlCntV.Empty()) { return; }
213    for (int i = 0; i &lt; TmUrlCntV.Len(); i++) {
214      double Hr = TSecTm(TmUrlCntV[i].Tm()-TmUrlCntV[0].Tm()).Round(tmu6Hour)/(24*3600.0);
215      HrCntH.AddDat(Hr) += TmUrlCntV[i].Cnt();
216    }
217    HrCntH.SortByKey();
218    TGnuPlot::PlotValCntH(HrCntH, OutFNm, TStr::Fmt(&quot;%d occurences, %d urls: %s&quot;, GetFq(), GetUrls(), QtStr.CStr()),
219      TStr::Fmt(&quot;Time [days] from %s&quot;, TmUrlCntV[0].Tm().GetYmdTmStr().CStr()), &quot;Frequency&quot;);
220  }
221  void TQuote::LoadQtV(const TStr&amp; InFNm, TVec&lt;TQuote&gt;&amp; QtV) {
222    PSIn SIn = TZipIn::IsZipFNm(InFNm) ? TZipIn::New(InFNm) : TFIn::New(InFNm);
223    QtV.Clr(false);
224    while (! SIn-&gt;Eof()) {
225      QtV.Add();
226      QtV.Last().Load(*SIn);
227    }
228  }
229  TQuoteBs::TQuoteBs(TSIn&amp; SIn) : StrQtIdH(SIn), QuoteH(SIn), UrlInDegH(SIn), UrlTyH(SIn) {
230    if (! SIn.Eof()) { ClustQtIdVH.Load(SIn); }
231    TIntSet CIdSet;
232    for (int q = 0; q &lt; ClustQtIdVH.Len(); q++) {
233      CIdSet.AddKey(ClustQtIdVH.GetKey(q));
234      for (int c = 0; c &lt; ClustQtIdVH[q].Len(); c++) {
235        CIdSet.AddKey(ClustQtIdVH[q][c]); } 
236      CIdSet.GetKeyV(ClustQtIdVH[q]);
237      ClustQtIdVH[q].Sort();
238      CIdSet.Clr(false);
239    }
240    Dump();
241  }
242  void TQuoteBs::Save(TSOut&amp; SOut) const {
243    StrQtIdH.Save(SOut);
244    QuoteH.Save(SOut);
245    UrlInDegH.Save(SOut);
246    UrlTyH.Save(SOut);
247    ClustQtIdVH.Save(SOut);
248  }
249  PQuoteBs TQuoteBs::New() {
250    return PQuoteBs(new TQuoteBs());
251  }
252  PQuoteBs TQuoteBs::Load(TSIn&amp; SIn) {
253    printf(&quot;loading %s...&quot;, SIn.GetSNm().CStr());
254    return PQuoteBs(new TQuoteBs(SIn));
255  }
256  void TQuoteBs::GetQtIdV(TIntV&amp; QtIdV) const {
257    QtIdV.Clr();
258    for (int q = 0; q &lt; QuoteH.Len(); q++) {
259      QtIdV.Add(QuoteH.GetKey(q)); }
260  }
261  TUrlTy TQuoteBs::GetUrlTy(const int&amp; UrlId) const {
262    if (UrlTyH.IsKey(UrlId)) {
263      return (TUrlTy) UrlTyH.GetDat(UrlId).Val; } 
264    return utBlog; 
265  }
266  void TQuoteBs::SetUrlTy(const TStr&amp; InFNm, const TUrlTy&amp; SetTy) {
267    printf(&quot;Set url type\n&quot;);
268    TStrHash&lt;TIntV&gt; DomUrlV; 
269    for (int q = 0; q &lt; Len(); q++) {
270      const TQuote::TTmUrlCntV&amp; V = GetQtN(q).TmUrlCntV;
271      for (int u = 0; u &lt; V.Len(); u++) {
272        const TChA Url = GetStr(V[u].UrlId());
273        DomUrlV.AddDat(TStrUtil::GetDomNm(Url).CStr()).Add(V[u].UrlId());
274      }
275    }
276    printf(&quot;  %d domains\n&quot;, DomUrlV.Len());
277    TStrV TyUrlV; TStr Ln;
278    if (! TFile::Exists(InFNm)) {
279      printf(&quot;!!! %s does not exist\n&quot;, InFNm.CStr());
280      return;
281    }
282    for (TFIn FIn(InFNm); FIn.GetNextLn(Ln); ) { TyUrlV.Add(Ln.GetTrunc()); }
283    printf(&quot;  %d domains with type label loaded\n&quot;, TyUrlV.Len());
284    int NDomSet=0, NUrlSet=0;
285    TExeTm ExeTm;
286    for (int d = 0; d &lt; DomUrlV.Len(); d++) {
287      for (int u = 0; u &lt; TyUrlV.Len(); u++) {
288        if (strstr(DomUrlV.GetKey(d), TyUrlV[u].CStr()) != NULL) {
289          const TIntV&amp; urlV = DomUrlV[d];
290          for (int i = 0; i &lt; urlV.Len(); i++) {
291            UrlTyH.AddDat(urlV[i], SetTy); }
292          NDomSet++;  NUrlSet+=urlV.Len();
293          break;
294        }
295      }
296      if (d % 1000 == 0) { printf(&quot;  %d/%d: labeled %d doms, %d urls [%s]\n&quot;, d, DomUrlV.Len(), NDomSet, NUrlSet, ExeTm.GetStr()); }
297    }
298    printf(&quot;  labeled %d doms, %d urls [%s]\n&quot;, NDomSet, NUrlSet, ExeTm.GetStr());
299    printf(&quot;  %d total labeled urls\n&quot;, UrlTyH.Len());
300  }
301  bool AppearsAt(const TIntSet&amp; UrlSet, const TQuote&amp; Q) {
302    for (int u = 0; u &lt; Q.GetUrls(); u++) {
303      if (UrlSet.IsKey(Q.GetUrlId(u))) { return true; }
304    }
305    return false;
306  }
307  void TQuoteBs::GetQtIdVByFq(TIntV&amp; QtIdV, const int&amp; MinWrdLen, const int&amp; MinQtFq, const bool&amp; OnlyClustRoots, const TStr&amp; HasWord, const TStr&amp; AppearsAtUrl, const TUrlTy&amp; OnlyCountTy, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
308    printf(&quot;Get top quotes from %d quotes\n&quot;, QuoteH.Len());
309    printf(&quot;  %s -- %s\n&quot;, BegTm.GetYmdTmStr().CStr(), EndTm.GetYmdTmStr().CStr());
310    TIntPrV FqQtIdV;
311    int words=0, minFq=0, hasWord=0;
312    TIntSet CSet, QSet;
313    TIntSet UrlSet;
314    if (! AppearsAtUrl.Empty()) {
315      for (int q = 0; q &lt; QuoteH.Len(); q++) {
316        const TQuote&amp; Q = GetQtN(q);
317        TQuote::TTmUrlCntV TmUrlCntV(Q.GetUrls(), 0);
318        for (int u = 0; u &lt; Q.GetUrls(); u++) {
319          if (UrlSet.IsKey(Q.GetUrlId(u))) {
320            TmUrlCntV.Add(Q.TmUrlCntV[u]);
321            continue; }
322          if (strstr(GetStr(Q.GetUrlId(u)), AppearsAtUrl.CStr())!=NULL) {
323            TmUrlCntV.Add(Q.TmUrlCntV[u]);
324            UrlSet.AddKey(Q.GetUrlId(u)); } 
325        }
326        TQuote* QPt = (TQuote*) &amp;(QuoteH[q]);
327        QPt-&gt;TmUrlCntV = TmUrlCntV; 
328      }
329    }
330    printf(&quot;done.&quot;);
331    for (int q = 0; q &lt; QuoteH.Len(); q++) {
332      const TQuote&amp; Qt = GetQtN(q);
333      if (TStrUtil::CountWords(Qt.QtStr.CStr()) &lt; MinWrdLen) { words++;  continue; }
334      if ((! HasWord.Empty()) &amp;&amp; Qt.QtStr.SearchStr(HasWord)==-1) { hasWord++;  continue; }
335      int Fq = 0;
336      if (OnlyClustRoots &amp;&amp; Qt.GetTy() == qtRoot) {
337        IAssert(Qt.GetCId() == GetQtId(q));
338        IAssert(! CSet.IsKey(Qt.GetCId()));  CSet.AddKey(Qt.GetCId());
339        if ((! HasWord.Empty()) &amp;&amp; GetQt(GetCentrQtId(Qt.GetCId())).GetStr().SearchStr(HasWord)==-1) { hasWord++; continue; } 
340        TQuote CentrQt;  GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
341        if (! UrlSet.Empty() &amp;&amp; ! AppearsAt(UrlSet, CentrQt)) { continue; }
342        Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
343        if (Fq &lt; MinQtFq) { minFq++; continue; }
344        const int Doms = CentrQt.GetDoms(*this);
345        if (Doms &lt; 3 || 5*Doms &lt; CentrQt.GetUrls()) { continue; }
346      }
347      else {
348        if (! UrlSet.Empty() &amp;&amp; ! AppearsAt(UrlSet, Qt)) { continue; }
349        Fq = Qt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
350        if (Fq &lt; MinQtFq) { minFq++; continue; }
351        const int Doms = Qt.GetDoms(*this);
352        if (Doms &lt; 3 || 4*Doms &lt; Qt.GetUrls()) { continue; }
353      }
354      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
355      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
356    }
357    printf(&quot;  skip %d : word len &lt; %d\n&quot;, words, MinWrdLen);
358    printf(&quot;  skip %d : qt fq &lt; %d\n&quot;, minFq, MinQtFq);
359    if (! HasWord.Empty()) { printf(&quot;  skip %d : not containing &#x27;%s&#x27;\n&quot;, hasWord, HasWord.CStr()); }
360    printf(&quot;  remaining %d quotes\n&quot;, FqQtIdV.Len());
361    FqQtIdV.Sort(false);
362    QtIdV.Clr(false);
363    TIntSet SeenSet;
364    for (int i = 0; i &lt; FqQtIdV.Len(); i++) {
365      if (i &lt; 100) { printf(&quot; fq:%d&quot;, FqQtIdV[i].Val1()); }
366      const int qid = FqQtIdV[i].Val2;
367      if (! SeenSet.IsKey(qid)) {
368        QtIdV.Add(qid);
369        SeenSet.AddKey(qid);
370        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
371          const TIntV&amp; ClustV = GetClust(GetQt(qid).GetCId());
372          for (int c = 0; c &lt; ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
373        }
374      }
375    }
376    printf(&quot;  return %d quotes\n&quot;, QtIdV.Len());
377  }
378  int AppearsAtDom(const TQuote&amp; CentrQt, const TIntSet&amp; GoodDom, const TIntH&amp; UrlDomH) {
379    int DomCnt = 0;
380    for (int u = 0; u &lt; CentrQt.GetUrls(); u++) {
381      const int U = CentrQt.GetUrlId(u);
382      IAssert(UrlDomH.IsKey(U));
383      if (GoodDom.IsKey(UrlDomH.GetDat(U))) { 
384        DomCnt++; }
385    }
386    return DomCnt;
387  }
388  void TQuoteBs::GetQtIdVByFq(TIntV&amp; QtIdV, const int&amp; MinWrdLen, const int&amp; MinQtFq, const TStrV&amp; FromDomains,
389                              const bool&amp; OnlyClustRoots, const TStr&amp; HasWord, int MinDoms) const {
390    printf(&quot;Get top quotes from %d quotes appearing at %d domains\n&quot;, QuoteH.Len(), FromDomains.Len());
391    TIntPrV FqQtIdV;
392    TIntH UrlDomH;
393    TStrSet DomainSet;
394    TIntSet QSet;
395    for (int q = 0; q &lt; QuoteH.Len(); q++) {
396      const TQuote&amp; Q = GetQtN(q);
397      for (int u = 0; u &lt; Q.GetUrls(); u++) {
398        const int U = Q.GetUrlId(u);
399        const int D = DomainSet.AddKey(TStrUtil::GetDomNm2(GetStr(U)));
400        UrlDomH.AddDat(U, D);
401      }
402    }
403    TIntSet GoodDom;
404    for (int d = 0; d &lt; DomainSet.Len(); d++) {
405      for (int f = 0; f &lt; FromDomains.Len(); f++) {
406        if (DomainSet[d].SearchStr(FromDomains[f]) != -1) {
407          GoodDom.AddKey(d); break; }
408      }
409    }
410    printf(&quot;%d total domains\n&quot;, DomainSet.Len());
411    printf(&quot;%d from domains\n&quot;, FromDomains.Len());
412    printf(&quot;%d good domains\n&quot;, GoodDom.Len());
413    printf(&quot;done.\n\n&quot;);
414    const TSecTm BegTm(1), EndTm(TSecTm::GetCurTm());
415    for (int q = 0; q &lt; QuoteH.Len(); q++) {
416      const TQuote&amp; Qt = GetQtN(q);
417      if (TStrUtil::CountWords(Qt.QtStr.CStr()) &lt; MinWrdLen) { continue; }
418      if ((! HasWord.Empty()) &amp;&amp; Qt.QtStr.SearchStr(HasWord)==-1) { continue; }
419      int Fq = 0;
420      if (Qt.GetTy() == qtRoot) {
421        TQuote CentrQt;
422        GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
423        if (AppearsAtDom(CentrQt, GoodDom, UrlDomH) &lt; MinDoms) { continue; }
424        Fq = CentrQt.GetFq(BegTm, EndTm, utUndef, *this);
425        if (Fq &lt; MinQtFq) { continue; }
426        const int Doms = CentrQt.GetDoms(*this);
427        if (Doms &lt; 3 || 5*Doms &lt; CentrQt.GetUrls()) { continue; }
428      }
429      else if (! OnlyClustRoots) {
430        if (AppearsAtDom(Qt, GoodDom, UrlDomH) &lt; MinDoms) { continue; }
431        Fq = Qt.GetFq(BegTm, EndTm, utUndef, *this);
432        if (Fq &lt; MinQtFq) { continue; }
433        const int Doms = Qt.GetDoms(*this);
434        if (Doms &lt; 3 || 4*Doms &lt; Qt.GetUrls()) { continue; }
435      }
436      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
437      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
438    }
439    printf(&quot;  remaining %d quotes\n&quot;, FqQtIdV.Len());
440    FqQtIdV.Sort(false);
441    QtIdV.Clr(false);
442    TIntSet SeenSet;
443    for (int i = 0; i &lt; FqQtIdV.Len(); i++) {
444      const int qid = FqQtIdV[i].Val2;
445      if (! SeenSet.IsKey(qid)) {
446        QtIdV.Add(qid);
447        SeenSet.AddKey(qid);
448        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
449          const TIntV&amp; ClustV = GetClust(GetQt(qid).GetCId());
450          for (int c = 0; c &lt; ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
451        }
452      }
453    }
454    printf(&quot;  return %d quotes\n&quot;, QtIdV.Len());
455  }
456  void TQuoteBs::GetQtIdVByTm(const int&amp; WndSzHr, const int&amp; StepHr, const int&amp; MinWrdLen, const int&amp; MinQtFq, const int&amp; TakePerStep) const {
457    const TTmUnit TmUnit = tmu4Hour;
458    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
459    MinTm=MinTm.Round(TmUnit); MaxTm=MaxTm.Round(TmUnit);
460    printf(&quot;Dataset span %s -- %s\n&quot;, MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
461    printf(&quot;  time window %dh, step size %dh, min wrd len %d, take top %d per step\n&quot;, WndSzHr, StepHr, MinWrdLen, TakePerStep);
462    TIntSet TopQtIdSet;
463    TIntV TopQtIdV;
464    int cnt=0;
465    FILE *F = fopen(&quot;top_qts_per_time_unit.txt&quot;, &quot;wt&quot;);
466    for (TSecTm Tm=MinTm; Tm &lt;= MaxTm; Tm += StepHr*3600, cnt++) {
467      GetQtIdVByFq(TopQtIdV, MinWrdLen, MinQtFq, true, &quot;&quot;, &quot;&quot;, utUndef, TSecTm(Tm), TSecTm(Tm+StepHr*3600));
468      fprintf(F,&quot;week of: %s\n&quot;, Tm.GetYmdTmStr().CStr());
469      for (int q = 0, j=0; q &lt; TopQtIdV.Len() &amp;&amp; j&lt;3; q++) {
470        if (! TopQtIdSet.IsKey(TopQtIdV[q])) {
471          fprintf(F, &quot;%s\t%d\n&quot;, GetQt(GetCentrQtId(TopQtIdV[q])).GetStr().CStr(), GetClustFq(TopQtIdV[q]));
472          j++; }
473        TopQtIdSet.AddKey(TopQtIdV[q]);
474      }
475      fprintf(F, &quot;\n&quot;);
476    }
477    fclose(F);
478    printf(&quot;  done %d quotes\n&quot;, TopQtIdSet.Len());
479  }
480  void TQuoteBs::GetCIdVByFq(TIntV&amp; CIdV, const int&amp; MinClFq, const TStr&amp; RootHasWord, const TUrlTy&amp; OnlyCountTy, const bool&amp; OnlyAfterRoot, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm) const {
481    printf(&quot;Get top clusters from %d clusters\n&quot;, GetClusts());
482    TIntPrV FqCIdV;
483    for (int c = 0; c &lt; GetClusts(); c++) {
484      const int CId = GetCId(c);
485      if ( ! IsQtId(CId)) { printf(&quot;!!! %d:%d\n&quot;, c, CId); continue; }
486      IAssert(GetQt(CId).GetTy()==qtRoot);
487      const int CentrQId = GetCentrQtId(CId);
488      if (CentrQId == -1) { continue; }
489      if ((! RootHasWord.Empty()) &amp;&amp; GetQt(CentrQId).GetStr().SearchStr(RootHasWord)==-1) { continue; } 
490      TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, OnlyAfterRoot); 
491      const int Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
492      if (Fq &lt; MinClFq) { continue; }
493      FqCIdV.Add(TIntPr(Fq, CId));
494    }
495    printf(&quot;  remaining %d clusters\n&quot;, FqCIdV.Len());
496    FqCIdV.Sort(false);
497    CIdV.Clr(false);
498    for (int i = 0; i &lt; FqCIdV.Len(); i++) {
499      CIdV.Add(FqCIdV[i].Val2); }
500  }
501  void TQuoteBs::GetMinMaxTm(TSecTm&amp; MinTm, TSecTm&amp; MaxTm) const {
502    MinTm = MaxTm = TSecTm();
503    for (int q = 0; q &lt; QuoteH.Len(); q++) {
504      const TQuote::TTmUrlCntV&amp; V = QuoteH[q].TmUrlCntV;
505      if (V.Empty()) { continue; }
506      if (! MinTm.IsDef() || MinTm &gt; V[0].Tm()) {
507        MinTm = V[0].Tm(); }
508      if (! MaxTm.IsDef() || MaxTm &lt; V[0].Tm()) {
509        MaxTm = V[0].Tm(); }
510    }
511  }
512  void TQuoteBs::GetMinMaxTm(const TIntV&amp; QtIdV, TSecTm&amp; MinTm, TSecTm&amp;MaxTm) const {
513    MinTm = MaxTm = TSecTm();
514    for (int q = 0; q &lt; QtIdV.Len(); q++) {
515      const TQuote::TTmUrlCntV&amp; V = GetQt(QtIdV[q]).TmUrlCntV;
516      if (V.Empty()) { continue; }
517      if (! MinTm.IsDef() || MinTm &gt; V[0].Tm()) {
518        MinTm = V[0].Tm(); }
519      if (! MaxTm.IsDef() || MaxTm &lt; V[0].Tm()) {
520        MaxTm = V[0].Tm(); }
521    }
522  }
523  void TQuoteBs::GetQtPageUrl(const TIntV&amp; QtIdV, TIntH&amp; QtUrlIdH) const {
524    THash&lt;TChA, TInt&gt; DomQtCntH;
525    for (int q = 0; q &lt; Len(); q++) {
526      const TQuote&amp; Q = GetQtN(q);
527      for (int u = 0; u &lt; Q.GetUrls(); u++) {
528        DomQtCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += Q.TmUrlCntV[u].Cnt(); }
529    }
530    const TStr StopList = &quot;blog.myspace.com|www.newsmeat.com|us.rd.yahoo.com|www.startribune.com|&quot;
531      &quot;news.originalsignal.com|uk.news.yahoo.com|ap.google.com|www.cnn.com|www.opednews.com&quot;;
532    TStrV StopListV; StopList.SplitOnAllCh(&#x27;|&#x27;, StopListV);
533    for (int s = 0; s &lt; StopListV.Len(); s++) {
534      DomQtCntH.AddDat(StopListV[s]) = 1; }
535    DomQtCntH.SortByDat(false);
536    QtUrlIdH.Clr(false);
537    for (int q = 0; q &lt; QtIdV.Len(); q++) {
538      const TQuote&amp; Q = GetQt(QtIdV[q]);
539      int DomFq=0, BestUrlId=0;
540      for (int u = 0; u &lt; Q.TmUrlCntV.Len(); u++) {
541        const TChA Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
542        if (DomFq &lt; DomQtCntH.GetDat(Dom)) {
543          DomFq = DomQtCntH.GetDat(Dom);
544          BestUrlId = Q.TmUrlCntV[u].UrlId();
545        }
546      }
547      QtUrlIdH.AddDat(QtIdV[q], BestUrlId);
548    }
549  }
550  void TQuoteBs::AddQuote(const TQuote&amp; Quote, const TQuoteBs&amp; CurQtBs) {
551    const int QtId = CurQtBs.GetQtId(Quote.GetStr().CStr());
552    TQuote&amp; Qt = QuoteH.AddDat(QtId);
553    StrQtIdH.AddDat(Quote.GetStr().CStr(), QtId);
554    Qt.QtCIdTy = TQuote::TQtIdTy(Quote.GetCId(), Quote.GetTy());
555    Qt.QtStr = Quote.QtStr;
556    Qt.TmUrlCntV = Quote.TmUrlCntV;
557    for (int u = 0; u &lt; Qt.TmUrlCntV.Len(); u++) {
558      Qt.TmUrlCntV[u].SetUrlId(AddStr(CurQtBs.GetStr(Quote.TmUrlCntV[u].UrlId())));
559    }
560  }
561  void TQuoteBs::AddQuote(const TVec&lt;TChA&gt;&amp; QuoteV, const TVec&lt;TChA&gt;&amp; LinkV, const TChA&amp; PostUrlStr, const TSecTm&amp; PubTm, const int&amp; MinQtWrdLen) {
562    TIntH QtCntH; 
563    for (int q = 0; q &lt; QuoteV.Len(); q++) {
564      if (TStrUtil::CountWords(QuoteV[q].CStr()) &lt; MinQtWrdLen) { continue; } 
565      int QtId = GetQtId(QuoteV[q].CStr());
566      if (QtId == -1) { 
567        IAssert(! IsStr(QuoteV[q].CStr()));
568        QtId = QuoteH.Len();
569        TQuote&amp; Qt = QuoteH.AddDat(QtId);
570        Qt.QtCIdTy = TQuote::TQtIdTy(QtId, qtQuote);
571        Qt.QtStr = QuoteV[q];
572        StrQtIdH.AddDat(QuoteV[q].CStr(), QtId);
573      } else { IAssert(IsStr(QuoteV[q].CStr())); }
574      IAssert(IsQtId(QtId));
575      QtCntH.AddDat(QtId) += 1; 
576    }
577    if (QtCntH.Len() &gt; 0) {
578      const int PostUrlId = AddStr(PostUrlStr);
579      for (int i = 0; i &lt; QtCntH.Len(); i++) {
580        QuoteH.GetDat(QtCntH.GetKey(i)).TmUrlCntV.Add(TQuote::TTmUrlCnt(PubTm, PostUrlId, QtCntH[i]));
581      }
582    }
583    const TChA PostDomain = TStrUtil::GetDomNm(PostUrlStr);
584    for (int l = 0; l &lt; LinkV.Len(); l++) {
585      const TChA&amp; Url = LinkV[l];
586      if (TStrUtil::GetDomNm(Url) == PostDomain) { continue; } 
587      if (IsStr(Url.CStr())) { UrlInDegH.AddDat(GetStrId(Url.CStr())) += 1; }
588    }
589  }
590  PQuoteBs TQuoteBs::GetQuoteBs(const TIntV&amp; QtIdV) const {
591    PQuoteBs _NewQtBs = TQuoteBs::New();
592    TQuoteBs&amp; NewQtBs = *_NewQtBs;
593    for (int q = 0; q &lt; QtIdV.Len(); q++) {
594      const TQuote&amp; Qt = GetQt(QtIdV[q]);
595      NewQtBs.AddQuote(Qt, *this);
596    }
597    for (int u = 0; u &lt; UrlInDegH.Len(); u++) {
598      const char* UrlStr = GetStr(UrlInDegH.GetKey(u));
599      if (NewQtBs.IsStr(UrlStr)) {
600        NewQtBs.UrlInDegH.AddDat(NewQtBs.GetStrId(UrlStr), UrlInDegH[u]); }
601    }
602    for (int t = 0; t &lt; UrlTyH.Len(); t++) {
603      const char* UrlStr = GetStr(UrlTyH.GetKey(t));
604      if (NewQtBs.IsStr(UrlStr)) {
605        NewQtBs.UrlTyH.AddDat(NewQtBs.GetStrId(UrlStr), UrlTyH[t]); }
606    }
607    for (int c = 0; c &lt; GetClusts(); c++) {
608      const int CId = GetCId(c);
609      if ( ! IsQtId(CId)) { printf(&quot;!!! %d:%d\n&quot;, c, CId); continue; }
610      const TIntV&amp; CQtIdV = GetClust(CId);
611      if (NewQtBs.IsQtId(CId)) {
612        IAssert(! NewQtBs.ClustQtIdVH.IsKey(CId));
613        TIntV&amp; CIdV = NewQtBs.ClustQtIdVH.AddDat(CId);
614        for (int i = 0; i &lt; CQtIdV.Len(); i++) {
615          if (NewQtBs.IsQtId(CQtIdV[i])) { CIdV.Add(CQtIdV[i]); }
616        }
617        IAssert(CIdV.Len() &gt; 0);
618      }
619    }
620    return _NewQtBs;
621  }
622  int TQuoteBs::GetQtsInClust() const {
623    int qts = 0;
624    for (int q = 0; q &lt; ClustQtIdVH.Len(); q++) {
625      qts += ClustQtIdVH[q].Len();
626    }
627    return qts;
628  }
629  int TQuoteBs::GetClustFq(const int&amp; CId) const {
630    int fq = 0;
631    TIntSet S;
632    const TIntV&amp; ClustV = ClustQtIdVH.GetDat(CId);
633    for (int c = 0; c &lt; ClustV.Len(); c++) {
634      fq += GetQt(ClustV[c]).GetFq();
635      IAssert(! S.IsKey(ClustV[c]));
636      S.AddKey((ClustV[c]));
637    }
638    return fq;
639  }
640  int TQuoteBs::GetClustFq(const int&amp; CId, const TUrlTy&amp; UrlTy) const {
641    int fq = 0;
642    const TIntV&amp; ClustV = ClustQtIdVH.GetDat(CId);
643    for (int c = 0; c &lt; ClustV.Len(); c++) {
644      fq += GetQt(ClustV[c]).GetFq(UrlTy, *this);
645    }
646    return fq;
647  }
648  int TQuoteBs::GetCentrQtId(const int&amp; CId) const {
649    return GetCentrQtId(GetClust(CId));
650  }
651  int TQuoteBs::GetCentrQtId(const TIntV&amp; ClustV) const {
652    TIntPrV QtFqIdV;
653    for (int c = 0; c &lt; ClustV.Len(); c++) {
654      if (! IsQtId(ClustV[c])) { continue; }
655      const TQuote&amp; Q = GetQt(ClustV[c]);
656      QtFqIdV.Add(TIntPr(Q.GetUrls(), ClustV[c]));
657    }
658    if (QtFqIdV.Empty()) { return -1; }
659    QtFqIdV.Sort(false);
660    const TStr FqStr = GetQt(QtFqIdV[0].Val2).GetStr(); 
661    for (int c = 0; c &lt; QtFqIdV.Len(); c++) {
662      IAssert(IsQtId(QtFqIdV[c].Val2));
663      const TQuote&amp; Q = GetQt(QtFqIdV[c].Val2);
664      const int Words = TStrUtil::CountWords(Q.GetStr().CStr());
665      if (Words &gt;= 6 &amp;&amp; Words &lt; 50 &amp;&amp; strstr(Q.GetStr().CStr(), FqStr.CStr())!=NULL) {
666        return QtFqIdV[c].Val2; }
667    }
668    return QtFqIdV[0].Val2;
669  }
670  void TQuoteBs::GetMergedClustQt(const int&amp; CId, TQuote&amp; NewQt, const bool&amp; OnlyAfterBegTm) const {
671    const TIntV&amp; ClustV = GetClust(CId);
672    GetMergedClustQt(ClustV, NewQt, OnlyAfterBegTm);
673  }
674  void TQuoteBs::GetMergedClustQt(const TIntV&amp; ClustV, TQuote&amp; NewQt, const bool&amp; OnlyAfterBegTm) const {
675    const int CentrQtId = GetCentrQtId(ClustV);
676    const TSecTm BegTm = OnlyAfterBegTm ? GetClustBegTm(ClustV, CentrQtId) : TSecTm(1);
677    THash&lt;TPair&lt;TSecTm, TInt&gt;, TInt&gt; TmUrlCntH;
678    for (int c = 0; c &lt; ClustV.Len(); c++) {
679      const TQuote&amp; Q = GetQt(ClustV[c]);
680      for (int u = 0; u &lt; Q.TmUrlCntV.Len(); u++) {
681        if (Q.TmUrlCntV[u].Tm() &gt;= BegTm) {
682          TmUrlCntH.AddDat(TPair&lt;TSecTm, TInt&gt;(Q.TmUrlCntV[u].Tm(), Q.TmUrlCntV[u].UrlId())) += Q.TmUrlCntV[u].Cnt(); }
683      }
684    }
685    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
686    NewQt.QtStr = GetQt(CentrQtId).GetStr(); 
687    if (! TmUrlCntH.Empty()) {
688      NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
689      for (int u = 0; u &lt; TmUrlCntH.Len(); u++) {
690        NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
691      }
692      NewQt.TmUrlCntV.Sort();
693    }
694  }
695  TSecTm TQuoteBs::GetClustBegTm(const int&amp; CId, const int&amp; CentrQtId) const {
696    const TIntV&amp; ClustV = GetClust(CId);
697    return GetClustBegTm(ClustV, CentrQtId);
698  }
699  TSecTm TQuoteBs::GetClustBegTm(const TIntV&amp; ClustV, const int&amp; CentrQtId) const {
700    TStrHash&lt;TInt&gt; StrH;
701    TIntV CntrWIdV, WIdV;
702    int WIdV1Start, WIdV2Start, SkipId;
703    TStrUtil::GetAddWIdV(StrH, GetQt(CentrQtId).GetStr().CStr(), CntrWIdV);
704    TSecTm BegTm = TSecTm::GetCurTm();
705    for (int c = 0; c &lt; ClustV.Len(); c++) {
706      TStrUtil::GetAddWIdV(StrH, GetQt(ClustV[c]).GetStr().CStr(), WIdV);
707      if (WIdV.Len() &lt; CntrWIdV.Len()) { continue; }
708      const int Overlap = LongestCmnSubSq(CntrWIdV, WIdV, WIdV1Start, WIdV2Start, SkipId);
709      if (Overlap &gt;= CntrWIdV.Len() &amp;&amp; SkipId==0) { 
710        if (GetQt(ClustV[c]).TmUrlCntV.Empty()) { continue; }
711        BegTm = TMath::Mn(BegTm, GetQt(ClustV[c]).TmUrlCntV[0].Tm()); 
712      }
713    }
714    return BegTm;
715  }
716  int TQuoteBs::LongestCmnSubSq(const TIntV&amp; WIdV1, const TIntV&amp; WIdV2, int&amp; WIdV1Start, int&amp; WIdV2Start, int&amp; SkipId) {
717    const TIntV&amp; V1 = WIdV1.Len()&gt;WIdV2.Len() ? WIdV1:WIdV2; 
718    const TIntV&amp; V2 = WIdV1.Len()&gt;WIdV2.Len() ? WIdV2:WIdV1; 
719    const int V1Len = V1.Len();
720    const int V2Len = V2.Len();
721    static THash&lt;TInt, TIntV&gt; WIdPosH;
722    static THashSet&lt;TInt&gt; V2WIdSet;
723    V2WIdSet.Clr(false);
724    for (int i=0; i &lt; WIdPosH.Len(); i++) { WIdPosH[i].Clr(false); }
725    WIdPosH.Clr(false, -1, false);
726    WIdV1Start = WIdV2Start = SkipId = 0;
727    for (int i = 0; i &lt; V2Len; i++) { 
728      V2WIdSet.AddKey(V2[i]); }
729    for (int i = 0; i &lt; V1Len; i++) { 
730      if (V2WIdSet.IsKey(V1[i])) { WIdPosH.AddDat(V1[i]).Add(i); } }
731    {const int cmnWords = WIdPosH.Len();
732    if (cmnWords &lt; V2WIdSet.Len()) {
733      if (cmnWords &lt; 4) { return 0; }
734      else if (V2Len &gt;= 5 &amp;&amp; cmnWords &lt; 5) { return 0; }
735      else if (V2Len &gt; 6 &amp;&amp; (2*cmnWords &lt; V2Len &amp;&amp; cmnWords &lt; 10)) { return 0; } }
736    }
737    int MaxLen = 0;
738    for (int w = 0; w &lt; V2Len; w++) { 
739      const int wid = V2[w];
740      if (! WIdPosH.IsKey(wid)) { continue; }
741      const TIntV&amp; OccV = WIdPosH.GetDat(wid);
742      for (int o = 0; o &lt; OccV.Len(); o++) {
743        const int beg = OccV[o];
744        int cnt = 0, tmp = 0;
745        while (w+cnt &lt; V2Len &amp;&amp; beg+cnt &lt; V1Len &amp;&amp; V2[w+cnt]==V1[beg+cnt]) { cnt++; tmp=0; }           
746        while (beg+1+cnt &lt; V1Len &amp;&amp; w+cnt &lt; V2Len &amp;&amp; V2[w+cnt]==V1[beg+cnt+1]) { cnt++; tmp=-1; }      
747        while (beg+cnt+1 &lt; V1Len &amp;&amp; w+cnt+1 &lt; V2Len &amp;&amp; V2[w+cnt+1]==V1[beg+cnt+1]) {  cnt++; tmp=-2;}  
748        while (beg+cnt &lt; V1Len &amp;&amp; w+cnt+1 &lt; V2Len &amp;&amp; V2[w+cnt+1]==V1[beg+cnt]) { cnt++; tmp=-3;}       
749        if (MaxLen &lt; cnt) { MaxLen = cnt; SkipId=tmp; WIdV1Start = beg;  WIdV2Start = w; }
750        IAssert(cnt &gt;= 1);
751      }
752    }
753    if (! (WIdV1.Len()&gt;WIdV2.Len())) {
754      int tmp=WIdV1Start; WIdV1Start=WIdV2Start; WIdV2Start=tmp;
755    }
756    return MaxLen;
757  }
758  void TQuoteBs::CreateClusters(const TVec&lt;TIntV&gt;&amp; ClustV) {
759    TIntV CIdV;
760    ClustQtIdVH.Clr();
761    printf(&quot;len %d\n&quot;, Len());
762    for (int q = 0; q &lt; Len(); q++) {
763      TQuote&amp; Q = GetQt(q);
764      Q.QtCIdTy = TQuote::TQtIdTy(q, qtQuote);
765    }
766    TIntH SeenNId;
767    for (int c = 0; c &lt; ClustV.Len(); c++) {
768      if (ClustV[c].Len() &lt; 3) { continue; } 
769      const int CentrQtId = GetCentrQtId(ClustV[c]);
770      if (CentrQtId == -1) {
771        printf(&quot;Cluster %d of size %d has no root!!!\n&quot;, c, ClustV[c].Len());
772        for (int i = 0; i &lt; ClustV[c].Len(); i++) {
773          printf(&quot;  %d%c&quot;, ClustV[c][i].Val, IsQtId(ClustV[c][i])?&#x27;t&#x27;:&#x27;f&#x27;); } printf(&quot;\n&quot;);
774        continue;
775      }
776      IAssert(! SeenNId.IsKey(CentrQtId));
777      SeenNId.AddKey(CentrQtId);
778      TQuote&amp; Q = GetQt(CentrQtId);
779      if (Q.GetTy() != qtQuote) { printf(&quot;  %d&quot;, Q.GetTy()); }
780      IAssert(! ClustQtIdVH.IsKey(CentrQtId));
781      Q.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtRoot);
782      ClustQtIdVH.AddDat(CentrQtId, ClustV[c]);
783      for (int q = 0; q &lt; ClustV[c].Len(); q++) {
784        if (ClustV[c][q] == CentrQtId) { continue; }
785        IAssert(! SeenNId.IsKey(ClustV[c][q]));
786        SeenNId.AddKey(ClustV[c][q]);
787        TQuote&amp; Q2 = GetQt(ClustV[c][q]);
788        Q2.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtInClust);
789      }
790    }
791  }
792  void TQuoteBs::ClusterQts(const int&amp; MinRootWrdLen, const int&amp; MinQtFq, const TStr&amp; OutFNmPref, const TStrV&amp; BlackListV) {
793    printf(&quot;Cluster quotes with min Fq &gt;= %d: %d total quotes\n&quot;, MinQtFq, Len());
794    TExeTm ExeTm;
795    TStrHash&lt;TInt&gt; StrH;
796    TVec&lt;TPair&lt;TInt, TIntV&gt; &gt; QWIdVV;  
797    { TIntPrV LenQIdV;  TIntV QWIdV;
798    printf(&quot;sort qid by len\n&quot;);
799    TStrHash&lt;TInt&gt; BlackListH;
800    for (int i = 0; i &lt; BlackListV.Len(); i++) { BlackListH.AddDatId(BlackListV[i].GetTrunc()); }
801    printf(&quot;blacklist len: %d\n&quot;, BlackListH.Len());
802    for (int q1 = 0; q1 &lt; Len(); q1++) {
803      const TQuote&amp; Q = GetQtN(q1);
804      const int Doms = Q.GetDoms(*this);
805      if ((Q.GetTy()==qtQuote || Q.GetTy()==qtRoot) &amp;&amp; Doms&gt;1 &amp;&amp; Doms*4&gt;Q.GetUrls()
806        &amp;&amp; Q.GetFq() &gt;= MinQtFq &amp;&amp; (! BlackListH.IsKey(Q.GetStr().CStr()))) { 
807          LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1))); }
808    }
809    printf(&quot;sort %d candidates\n&quot;, LenQIdV.Len());
810    LenQIdV.Sort(false);
811    printf(&quot;get word id vectors\n&quot;);
812    for (int q1 = 0; q1 &lt; LenQIdV.Len(); q1++) {
813      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
814      QWIdVV.Add(TPair&lt;TInt, TIntV&gt;(LenQIdV[q1].Val2, QWIdV));
815    } }
816    printf(&quot;  %d root quotes\n&quot;, ClustQtIdVH.Len());
817    printf(&quot;  %d quotes to merge\n&quot;, QWIdVV.Len());
818    int NMergers=0;
819    FILE *F = fopen(TStr(OutFNmPref+&quot;-merged.txt&quot;).CStr(), &quot;wt&quot;);
820    const int ClusterQ=QWIdVV.Len();
821    for (int q1 = 0; q1 &lt; ClusterQ; q1++) {
822      if (QWIdVV[q1].Val2.Len() &lt; MinRootWrdLen) { continue; } 
823      const int Qt1Id = QWIdVV[q1].Val1;
824      for (int q2 = q1+1; q2 &lt; ClusterQ; q2++) {
825        int idx1=0, idx2=0, SkipTy=0;
826        bool DoMerge = false;
827        const int ShortLen = TMath::Mn(QWIdVV[q1].Val2.Len(), QWIdVV[q2].Val2.Len());
828        if (ShortLen == 0) { continue; }
829        const int Overlap = LongestCmnSubSq(QWIdVV[q1].Val2, QWIdVV[q2].Val2, idx1, idx2, SkipTy);
830        if (ShortLen == 4 &amp;&amp; Overlap == 4 &amp;bsol;*&amp;&amp; SkipTy==0*/) { DoMerge=true; } 
831        else if (ShortLen == 5 &amp;&amp; Overlap == 5 &amp;bsol;*&amp;&amp; SkipTy==0*/) { DoMerge=true; } 
832        else if ((ShortLen == 6 &amp;&amp; Overlap &gt;= 5 &amp;bsol;*&amp;&amp; SkipTy==0) || (ShortLen == 6 &amp;&amp; Overlap == 5*/)) { DoMerge=true; }
833        else if (Overlap/double(ShortLen+3) &gt; 0.5 || Overlap &gt; 10) { DoMerge=true; }
834        if (DoMerge == true) {
835          NMergers++;
836          const int Qt2Id = QWIdVV[q2].Val1;
837          TQuote&amp; Q1 = GetQt(Qt1Id);
838          TQuote&amp; Q2 = GetQt(Qt2Id);
839          if (Q1.GetTy() != qtRoot) { 
840            IAssert(Q1.GetTy() == qtQuote);
841            IAssert(! ClustQtIdVH.IsKey(Qt1Id));
842            ClustQtIdVH.AddDat(Qt1Id).Add(Qt1Id);
843            Q1.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtRoot);
844          } else { IAssert(Q1.GetTy() == qtRoot); }
845          if (Q2.GetTy() == qtRoot) { 
846            for (int c = 0; c &lt; ClustQtIdVH.GetDat(Qt2Id).Len(); c++) {
847              ClustQtIdVH.AddDat(Qt1Id).Add(ClustQtIdVH.GetDat(Qt2Id)[c]); }
848            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
849            ClustQtIdVH.DelKey(Qt2Id);
850            IAssert(ClustQtIdVH.AddDat(Qt1Id).IsIn(Qt2Id));
851          } else {
852            IAssert(Q2.GetTy() == qtQuote);
853            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
854            ClustQtIdVH.AddDat(Qt1Id).Add(Qt2Id);
855          }
856          QWIdVV[q2].Val2.Clr(true); 
857          { TStr Str= &quot;    :&quot;; if(SkipTy==-1){Str=&quot;long=&quot;;} else if(SkipTy==-2){Str=&quot;both=&quot;;} else if(SkipTy==-3){Str=&quot;shrt=&quot;;}
858          if (Str.Len()&gt;0) { printf(&quot;%c&quot;, Str[0]); }
859          if (ClustQtIdVH.GetDat(Qt1Id).Len() == 2) { fprintf(F, &quot;\n[%d] %s \t%d\n&quot;, TStrUtil::CountWords(Q1.QtStr.CStr()), Q1.QtStr.CStr(), Q1.GetFq()); }
860          fprintf(F, &quot;%s%d [%d] %s \t%d\n&quot;, Str.CStr(), Overlap, TStrUtil::CountWords(Q2.QtStr.CStr()), Q2.QtStr.CStr(), Q2.GetFq()); }
861        }
862      }
863      if (ClustQtIdVH.IsKey(Qt1Id)) {
864        ClustQtIdVH.GetDat(Qt1Id).Pack();
865        ClustQtIdVH.GetDat(Qt1Id).Sort();
866        QWIdVV[q1].Val2.Clr(true);
867      }
868      if (q1&gt;0 &amp;&amp; q1 % 100 == 0) {
869        printf(&quot;\r  %d/%d: %d merged [%s]  &quot;, q1, ClusterQ, NMergers, ExeTm.GetStr());
870        if (q1 % 1000 == 0) { printf(&quot;save.\n&quot;);  fflush(F);
871          TFOut FOut(OutFNmPref+&quot;-QtBs.ClustQtIdVH&quot;); ClustQtIdVH.Save(FOut); }
872      }
873    }
874    fclose(F);
875    printf(&quot;\n%d quotes, %d clusters [%s]\n\n.&quot;, NMergers, ClustQtIdVH.Len(), ExeTm.GetStr());
876  }
877  void TQuoteBs::ResetClusters() {
878    ClustQtIdVH.Clr();
879    for (int q = 0; q &lt; Len(); q++) {
880      GetQtN(q).QtCIdTy = TQuote::TQtIdTy(GetQtId(q), qtQuote);
881    }
882  }
883  void TQuoteBs::ReassignToClust(const int&amp; QtId, const int&amp; NewCId) {
884    const int QtCl = GetQt(QtId).GetCId();
885    printf(&quot;assign %d from clust %d to %d\n&quot;, QtId, QtCl, NewCId);
886    if (QtCl != QtId) {
887      ClustQtIdVH.GetDat(QtCl).DelIfIn(QtId); }
888    GetQt(QtId).QtCIdTy = TQuote::TQtIdTy(NewCId, qtInClust);
889    ClustQtIdVH.AddDat(NewCId).Add(QtId);
890  }
891  void TQuoteBs::Mergec2Clusters(const int&amp; ParentCId, const int&amp; ChildCId) {
892    IAssert(IsClust(ParentCId) &amp;&amp; IsClust(ChildCId));
893    printf(&quot;merging %d (fq: %d) to %d (%d fq)\n&quot;, ChildCId, GetClustFq(ChildCId), ParentCId, GetClustFq(ParentCId));
894    TIntSet ClustSet;
895    { const TIntV&amp; ClustV = GetClust(ParentCId);
896    for (int c = 0; c &lt; ClustV.Len(); c++) {
897      ClustSet.AddKey(ClustV[c]); } }
898    { const TIntV&amp; ClustV = GetClust(ChildCId);
899    for (int c = 0; c &lt; ClustV.Len(); c++) {
900      ClustSet.AddKey(ClustV[c]); } }
901    ClustSet.GetKeyV(ClustQtIdVH.GetDat(ParentCId));
902    GetQt(ChildCId).QtCIdTy = TQuote::TQtIdTy(ChildCId, qtInClust);
903    ClustQtIdVH.DelKey(ChildCId);
904    ClustQtIdVH.Defrag();
905  }
906  PClustNet TQuoteBs::GetClustNet(const int&amp; MinQtFq, const TStr&amp; OutFNmPref) const {
907    printf(&quot;Cluster quotes with Fq &gt;= %d: %d total quotes\n&quot;, MinQtFq, Len());
908    TExeTm ExeTm;
909    TStrHash&lt;TInt&gt; StrH;
910    FILE *F = fopen(TStr(OutFNmPref+&quot;-candidates.txt&quot;).CStr(), &quot;wt&quot;);
911    THash&lt;TInt, TIntV&gt; QWIdVH;  
912    { TIntPrV LenQIdV;  TIntV QWIdV;
913    printf(&quot;sort qid by len\n&quot;);
914    for (int q1 = 0; q1 &lt; Len(); q1++) {
915      const TQuote&amp; Q = GetQtN(q1);
916      const int Doms = Q.GetDoms(*this);
917      if ((Q.GetTy()!=qtCentr) &amp;&amp; Doms&gt;1 &amp;&amp; Doms*4 &gt; Q.GetUrls() &amp;&amp; Q.GetFq() &gt;= MinQtFq) { 
918        LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1)));
919      }
920    }
921    printf(&quot;sort %d candidates by word length\n&quot;, LenQIdV.Len());
922    LenQIdV.Sort(false);
923    for (int q1 = 0; q1 &lt; LenQIdV.Len(); q1++) {
924      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
925      QWIdVH.AddDat(LenQIdV[q1].Val2, QWIdV);
926      fprintf(F, &quot;%s\n&quot;, GetQt(LenQIdV[q1].Val2).QtStr.CStr());
927    } }
928    printf(&quot;  %d root quotes\n&quot;, ClustQtIdVH.Len());
929    printf(&quot;  %d quotes to merge\n&quot;, QWIdVH.Len());
930    const int ClusterQ=QWIdVH.Len();
931    PClustNet ClustNet = TClustNet::New();
932    TIntH NIdDepthH;
933    TIntSet SeenQtIdSet;
934    int NMerges=0, idx1=0, idx2=0, SkipTy=0; 
935    for (int q1 = 0; q1 &lt; ClusterQ; q1++) { 
936      SeenQtIdSet.Clr(false);
937      const int Qt1Id = QWIdVH.GetKey(q1);
938      for (int q2 = q1-1; q2 &gt;= 0; q2--) { 
939        const int Qt2Id = QWIdVH.GetKey(q2);
940        if (SeenQtIdSet.IsKey(Qt2Id)) { continue; }
941        bool DoMerge = false;
942        const int Overlap = LongestCmnSubSq(QWIdVH[q1], QWIdVH[q2], idx1, idx2, SkipTy);
943        const int ShortLen = QWIdVH[q1].Len(); IAssert(QWIdVH[q1].Len()&lt;= QWIdVH[q2].Len());
944        if (ShortLen == 4 &amp;&amp; Overlap == 4) { DoMerge=true; } 
945        else if (ShortLen == 5 &amp;&amp; Overlap == 5) { DoMerge=true; } 
946        else if (ShortLen == 6 &amp;&amp; Overlap &gt;= 5) { DoMerge=true; }
947        else if (Overlap/double(ShortLen+3) &gt; 0.5 || Overlap &gt; 10) { DoMerge=true; }
948        if (DoMerge==true) { NMerges++;
949          if (! ClustNet-&gt;IsNode(Qt1Id)) { ClustNet-&gt;AddNode(Qt1Id, GetQt(Qt1Id)); }
950          if (! ClustNet-&gt;IsNode(Qt2Id)) { ClustNet-&gt;AddNode(Qt2Id, GetQt(Qt2Id)); }
951          ClustNet-&gt;AddEdge(Qt1Id, Qt2Id);
952          SeenQtIdSet.AddKey(Qt1Id);  SeenQtIdSet.AddKey(Qt2Id);
953          fprintf(F, &quot;%d Merge\t%d\t%d\ttree\t%d\n\t%s\n\t%s\n&quot;, q1, QWIdVH[q1].Len(), QWIdVH[q2].Len(), NIdDepthH.Len(), GetQt(Qt2Id).GetStr().CStr(), GetQt(Qt1Id).GetStr().CStr());
954          fflush(F);
955        }
956      }
957      if (q1&gt;0 &amp;&amp; q1 % 100 == 0) {
958        printf(&quot;\r  %d/%d: %d merged [%s]  &quot;, q1, ClusterQ, NMerges, ExeTm.GetStr());
959        if (q1 % 1000 == 0) {
960          printf(&quot;save: %d merges, %d nodes, %d edges in ClustNet [%s]\n.&quot;, NMerges, ClustNet-&gt;GetNodes(), ClustNet-&gt;GetEdges(), ExeTm.GetStr());
961          TFOut FOut(OutFNmPref+&quot;.ClustNet&quot;); ClustNet-&gt;Save(FOut); }
962      }
963    }
964    fclose(F);
965    printf(&quot;\n%d merges, %d nodes, %d edges in ClustNet [%s]\n\n.&quot;, NMerges, ClustNet-&gt;GetNodes(), ClustNet-&gt;GetEdges(), ExeTm.GetStr());
966    return ClustNet;
967  }
968  void TQuoteBs::AddMergedQtsToQtBs() {
969    printf(&quot;merge quote clusters and add them to the quote base\n&quot;);
970    TQuote MergedQt;
971    int toDel = ClustQtIdVH.Len();
972    for (int q = 0; q &lt; QuoteH.Len(); q++) {
973      if (QuoteH[q].GetFq() == 1) { QuoteH.DelKeyId(q); toDel--; }
974      if (toDel == 0) { break; }
975    }
976    for (int q = 0; q &lt; ClustQtIdVH.Len(); q++) {
977      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
978      IAssert(MergedQt.TmUrlCntV.Len() &gt; 0); 
979      QuoteH.AddDat(QuoteH.Len(), MergedQt); 
980    }
981    printf(&quot;IsKeyIdEqKeyN: %s\n&quot;, QuoteH.IsKeyIdEqKeyN()?&quot;T&quot;:&quot;F&quot;);
982  }
983  PQuoteBs TQuoteBs::GetMergeClusters(const bool&amp; OnlyClusters) const {
984    printf(&quot;Merging clusters into single quotes:\n&quot;);
985    PQuoteBs NewQtBs = TQuoteBs::New();
986    TQuote MergedQt;
987    printf(&quot;  %d quotes total\n&quot;, Len());
988    printf(&quot;  %d clusters\n&quot;, ClustQtIdVH.Len());
989    TIntSet SeenQtIdSet;
990    for (int q = 0; q &lt; ClustQtIdVH.Len(); q++) {
991      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
992      IAssert(MergedQt.TmUrlCntV.Len() &gt;0);
993      NewQtBs-&gt;AddQuote(MergedQt, *this);
994      const TIntV&amp; ClustQtIdV = ClustQtIdVH[q];
995      for (int c = 0; c &lt; ClustQtIdV.Len(); c++) {
996        const int qid = ClustQtIdV[c];
997        IAssert(! SeenQtIdSet.IsKey(qid)); 
998        SeenQtIdSet.AddKey(qid);
999      }
1000    }
1001    if (! OnlyClusters) {
1002      for (int q = 0; q &lt; Len(); q++) {
1003        const TQuote&amp; Q = GetQtN(q);
1004        if (! SeenQtIdSet.IsKey(GetQtId(q))) {
1005          NewQtBs-&gt;AddQuote(Q, *this); }
1006      }
1007    }
1008    printf(&quot;  %d quotes in new Quotes base\n&quot;, NewQtBs-&gt;Len());
1009    return NewQtBs;
1010  }
1011  void TQuoteBs::GetTopQtDoms(TStrIntPrV&amp; DomCntV, const int&amp; TakeNClust, const int&amp; MinClFq, const TStr&amp; RootHasWord, const TUrlTy&amp; OnlyCountTy) const {
1012    TIntV CIdV;
1013    GetCIdVByFq(CIdV, MinClFq, RootHasWord, OnlyCountTy);
1014    THash&lt;TStr, TInt&gt; DomCntH;
1015    for (int c = 0; c &lt; TMath::Mn(CIdV.Len(), TakeNClust); c++) {
1016      const TIntV&amp; ClustV = GetClust(CIdV[c]);
1017      for (int q = 0; q &lt; ClustV.Len(); q++) {
1018        const TQuote&amp; Q = GetQt(ClustV[q]);
1019        for (int u = 0; u &lt; Q.TmUrlCntV.Len(); u++) {
1020          DomCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += 1;
1021        }
1022      }
1023    }
1024    DomCntH.SortByDat(false);
1025    DomCntH.GetKeyDatPrV(DomCntV);
1026  }
1027  void TQuoteBs::TopDomsByLag(const TTmUnit&amp; TmUnit, const int&amp; TakeNDoms, const int&amp; TakeNClusts, const int&amp; Thresh) const {
1028    THash&lt;TStr, TMom&gt; DomLagH;
1029    TIntV CIdV;  GetCIdVByFq(CIdV, 10, &quot;&quot;, utUndef);
1030    TStrIntPrV DomCntV;  GetTopQtDoms(DomCntV, TakeNClusts, 10, &quot;&quot;, utUndef);
1031    printf(&quot;Take %d clusters, %d domains&quot;, TakeNClusts, TakeNDoms);
1032    for (int d = 0; d &lt; TMath::Mn(TakeNDoms, DomCntV.Len()); d++) {
1033      DomLagH.AddDat(DomCntV[d].Val1);
1034      printf(&quot;%d\t%s\n&quot;, DomCntV[d].Val2(), DomCntV[d].Val1.CStr());
1035    }
1036    int NQuotes=0;
1037    for (int c = 0; c &lt; TMath::Mn(CIdV.Len(), TakeNClusts); c++) {
1038      TQuote Q;  GetMergedClustQt(CIdV[c], Q, false);
1039      const TSecTm MedTm = Q.GetMedianTm(TmUnit, utUndef, *this).Round(TmUnit);
1040      TStrSet DomSet;
1041      for (int u = 0; u &lt; Q.TmUrlCntV.Len(); u++) {
1042        IAssert(IsStrId(Q.TmUrlCntV[u].UrlId()));
1043        const TStr Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
1044        if (DomSet.IsKey(Dom)) { continue; } 
1045        if (! DomLagH.IsKey(Dom)) { continue; }
1046        DomLagH.AddDat(Dom).Add((int(Q.TmUrlCntV[u].Tm().Round(TmUnit))-int(MedTm))/3600.0);
1047        DomSet.AddKey(Dom);
1048      }
1049      NQuotes += GetClust(CIdV[c]).Len();
1050    }
1051    FILE *F = fopen(TStr::Fmt(&quot;domsByLag-clust%d.tab&quot;, TakeNClusts).CStr(), &quot;wt&quot;);
1052    fprintf(F, &quot;Top clusters: %d, total quotes in top clusters: %d\n&quot;, TakeNClusts, NQuotes);
1053    TFltFltStrTrV MedLagDomV;
1054    for (int i = 0; i &lt; DomLagH.Len(); i++) {
1055      DomLagH[i].Def();
1056      MedLagDomV.Add(TFltFltStrTr(DomLagH[i].GetMedian(), DomLagH[i].GetVals(), DomLagH.GetKey(i)));
1057    }
1058    MedLagDomV.Sort();
1059    fprintf(F, &quot;AGGREGATE PEAK\nTop domains with least lag (out of top %d considered) that mention at least 10 pct of top %d quotes (clusters) :\n&quot;, TakeNDoms, TakeNClusts);
1060    for (int i = 0; i &lt; MedLagDomV.Len(); i++) {
1061      if (MedLagDomV[i].Val2() &lt; Thresh*TakeNClusts/100.0) { continue; }
1062      fprintf(F, &quot;%g\t%g\t%s\n&quot;, MedLagDomV[i].Val1(), MedLagDomV[i].Val2(), MedLagDomV[i].Val3.CStr());
1063    }
1064    fclose(F);
1065  }
1066  void TQuoteBs::PlotQtFqCnt(const TStr&amp; OutFNmPref) const {
1067    TIntH UrlCntH, DomCntH, CntFqH;
1068    THashSet&lt;TChA&gt; DomSet;
1069    for (int q = 0; q &lt; QuoteH.Len(); q++) {
1070      const TQuote&amp; Q = GetQtN(q);
1071      UrlCntH.AddDat(Q.GetUrls()) += 1;
1072      CntFqH.AddDat(Q.GetFq()) += 1;
1073      DomSet.Clr(false);
1074      for (int u = 0; u &lt; Q.GetUrls(); u++) {
1075        DomSet.AddKey(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))); }
1076      DomCntH.AddDat(DomSet.Len()) += 1;
1077    }
1078    TGnuPlot::PlotValCntH(UrlCntH, OutFNmPref+&quot;-url&quot;, &quot;&quot;, &quot;number of urls quote appears at&quot;, &quot;count&quot;, gpsLog10XY);
1079    TGnuPlot::PlotValCntH(DomCntH, OutFNmPref+&quot;-dom&quot;, &quot;&quot;, &quot;number of domains quote appears at&quot;, &quot;count&quot;, gpsLog10XY);
1080    TGnuPlot::PlotValCntH(CntFqH, OutFNmPref+&quot;-fq&quot;, &quot;&quot;, &quot;number of times quote appears&quot;, &quot;count&quot;, gpsLog10XY);
1081  }
1082  void TQuoteBs::PlotQtMediaVsBlogFq(const int&amp; QtId, const TStr&amp; OutFNmPref) const {
1083    TQuote::TTmFltPrV BlogFqV, MediaFqV, SmoothV;
1084    TFltPrV FqV;
1085    const TQuote&amp; ClQt = GetQt(QtId);
1086    ClQt.GetFqOt(BlogFqV, tmu4Hour, utBlog, *this);
1087    ClQt.GetFqOt(MediaFqV, tmu4Hour, utMedia, *this);
1088    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1089    TGnuPlot GP(&quot;mediaVsBlogs-&quot;+OutFNmPref, TStr::Fmt(&quot;%s. b:%d m:%d u:%d d:%d&quot;, ClQt.GetStr().CStr(),
1090      ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1091    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, tmu4Hour, 24, 1.2, MinTm);
1092    for (int i = 0; i &lt; SmoothV.Len(); i++) {
1093      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0), SmoothV[i].Val2())); }
1094    GP.AddPlot(FqV, gpwLines, &quot;Blog frequency&quot;);
1095    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, tmu4Hour, 24, 1.2, MinTm);
1096    FqV.Clr();
1097    for (int i = 0; i &lt; SmoothV.Len(); i++) {
1098      IAssert(SmoothV[i].Val1&gt;=MinTm);
1099      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0)*(54.0/46.0), SmoothV[i].Val2()));
1100    }
1101    GP.AddPlot(FqV, gpwLines, &quot;Media frequency&quot;);
1102    GP.SetXYLabel(TStr::Fmt(&quot;time [days] since %s&quot;, MinTm.GetYmdTmStr().CStr()), &quot;Quote frequency (normalized for the baseline 46 vs 54)&quot;);
1103    GP.SavePng();
1104  }
1105  int NormMaxTo1(const TQuote::TTmFltPrV&amp; TmFqV, TFltPrV&amp; OutV, const TSecTm&amp; BegTm) {
1106    int Idx=0;
1107    double MaxVal=0;
1108    for (int i = 0; i &lt; TmFqV.Len(); i++) {
1109      if (MaxVal &lt; TmFqV[i].Val2) {
1110        MaxVal=TmFqV[i].Val2; Idx = i; }
1111    }
1112    OutV.Gen(TmFqV.Len(), 0);
1113    for (int i = 0; i &lt; TmFqV.Len(); i++) {
1114      OutV.Add(TFltPr(double(TmFqV[i].Val1-BegTm)/(24.0*3600.0), TmFqV[i].Val2())); 
1115    }
1116    return Idx;
1117  }
1118  void TQuoteBs::PlotClustMediaVsBlogFq(const int&amp; CId, const TStr&amp; OutFNmPref) const {
1119    const TTmUnit TmUnit = tmu4Hour;
1120    TQuote::TTmFltPrV BlogFqV, MediaFqV, AllFqV, SmoothV;
1121    TFltPrV FqV, RawFqV;
1122    TQuote ClQt;
1123    GetMergedClustQt(CId, ClQt, false);
1124    ClQt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1125    ClQt.GetFqOt(MediaFqV, TmUnit, utMedia, *this);
1126    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1127    const TSecTm  MediaPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this);
1128    const TSecTm BlogPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utBlog, *this);
1129    const int Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600;
1130    const bool Is1Peak = ClQt.IsSinglePeak(TmUnit, TSecTm(1), utUndef, *this);
1131    TGnuPlot GP(&quot;mediaVsBlogs-&quot;+OutFNmPref, TStr::Fmt(&quot;%s. b:%d m:%d u:%d d:%d&quot;, Is1Peak?&quot;SINGLE PEAK&quot;: &quot;MORE PEAKS&quot;, 
1132      Lag, ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1133    int mx = NormMaxTo1(BlogFqV, RawFqV, MinTm);
1134    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, TmUnit, 2*24, 1.2, MinTm);
1135    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1136    GP.AddPlot(FqV, gpwLines, TStr::Fmt(&quot;SMOOTH Blog : max %s&quot;, SmoothV[mx].Val1.GetYmdTmStr().CStr()), &quot;pt 7 ps 1&quot;);
1137    const TSecTm SmBlog = SmoothV[mx].Val1;
1138    mx = NormMaxTo1(MediaFqV, RawFqV, MinTm);
1139    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, TmUnit, 2*24, 1.2, MinTm);
1140    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1141    const TSecTm SmMed = SmoothV[mx].Val1;
1142    const int SmLag = (int(SmBlog.Round(TmUnit))-int(SmMed.Round(TmUnit)))/3600;
1143    GP.AddPlot(FqV, gpwLines, TStr::Fmt(&quot;SMOOTH Media is behind: %dh, smooth: %dh.&quot;, -Lag, -SmLag), &quot;pt 5 ps 1&quot;);
1144    GP.SetXYLabel(TStr::Fmt(&quot;time [days] since %s&quot;, MinTm.GetYmdTmStr().CStr()), &quot;Cluster frequency (normalized for the baseline 46 vs 54)&quot;);
1145    GP.AddCmd(&quot;set xtics 10&quot;);
1146    GP.AddCmd(&quot;set mxtics 10&quot;);
1147    GP.SavePng();
1148  }
1149  void TQuoteBs::PlotMediaVsBlogLag(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, const int&amp; TakeN, const TStr&amp; OutFNmPref) const {
1150    TQuote Qt;  TIntV IdV;
1151    TMom LagMom1d, LagMom2d, LagMom3d, LagMom4d, LagMom7d;
1152    TFltFltH LagCntH, LagBCntH, LagMCntH;
1153    int Cnt=0;
1154    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, utUndef, false); }
1155    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1156    for (int c = 0; c &lt; TakeN; c++) {
1157      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1158      else { Qt = GetQt(IdV[c]); }
1159      const TSecTm  AllPeak = Qt.GetMedianTm(TmUnit, utUndef, *this);
1160      const TSecTm BlogPeak = Qt.GetMedianTm(TmUnit, utBlog, *this);
1161      const TSecTm  MediaPeak = Qt.GetMedianTm(TmUnit, utMedia, *this);
1162      const double Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600.0;
1163      const double Lag1 = (int(BlogPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1164      const double Lag2 = (int(MediaPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1165      if (fabs(Lag) &lt; 1*24) { LagMom1d.Add(Lag); }
1166      if (fabs(Lag) &lt; 2*24) { LagMom2d.Add(Lag); }
1167      if (fabs(Lag) &lt; 3*24) { LagMom3d.Add(Lag); }
1168      if (fabs(Lag) &lt; 4*24) { LagMom4d.Add(Lag); }
1169      if (fabs(Lag) &lt; 7*24) { LagMom7d.Add(Lag); }
1170      LagCntH.AddDat(Lag) += 1;
1171      LagBCntH.AddDat(Lag1) += 1;
1172      LagMCntH.AddDat(Lag2) += 1;
1173      Cnt++;
1174    }
1175    TFltPrV PrV;
1176    LagMom1d.Def();  LagMom2d.Def();  LagMom3d.Def();  LagMom4d.Def();  LagMom7d.Def();
1177    { TGnuPlot GP(&quot;lagBlogsVsMedia-&quot;+OutFNmPref, TStr::Fmt(&quot;Lag: 1D: %.2f %g;   2D: %.2f  %g;   3D: %.2f  %g;   4D: %.2f  %g;   7D: %.2f  %g&quot;,
1178      LagMom1d.GetMean(), LagMom1d.GetMedian(), LagMom2d.GetMean(), LagMom2d.GetMedian(), LagMom3d.GetMean(), LagMom3d.GetMedian(),
1179      LagMom4d.GetMean(), LagMom4d.GetMedian(), LagMom7d.GetMean(), LagMom7d.GetMedian()), true);
1180    LagBCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt(&quot;%s. b:%d m:%d u:%d d:%d BLOG&quot;, Qt.GetStr().CStr(),
1181      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1182    LagMCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt(&quot;%s. b:%d m:%d u:%d d:%d MEDIA&quot;, Qt.GetStr().CStr(),
1183      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1184    GP.AddCmd(&quot;set xrange[-24:24]\nset mxtics 5\nset xtics 5&quot;);
1185    GP.SetXYLabel(&quot;media lag in hours (+: news lag, -: news lead)&quot;, &quot;count&quot;);
1186    GP.SavePng(); }
1187    printf(&quot;\nTake top %d clusters. TmUnit: %s\n&quot;, TakeN, TTmInfo::GetTmUnitStr(TmUnit).CStr());
1188    printf(&quot;  1d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom1d.GetMean(), LagMom1d.GetMedian());
1189    printf(&quot;  2d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom2d.GetMean(), LagMom2d.GetMedian());
1190    printf(&quot;  3d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom3d.GetMean(), LagMom3d.GetMedian());
1191    printf(&quot;  4d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom4d.GetMean(), LagMom4d.GetMedian());
1192    printf(&quot;  7d:\tavg:\t%f\tmed:\t%f\n&quot;, LagMom7d.GetMean(), LagMom7d.GetMedian());
1193  }
1194  void TQuoteBs::PlotFqDecay(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, const TUrlTy&amp; CntUrlTy, const int&amp; PlotN, const int&amp; MinValsPerTm, const TStr&amp; OutFNmPref) const {
1195    THash&lt;TFlt, TMom&gt; MomH;
1196    TQuote Qt;
1197    TIntV IdV;
1198    TGnuPlot GP(&quot;decay-&quot;+OutFNmPref);
1199    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, CntUrlTy, false); }
1200    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, CntUrlTy); }
1201    for (int c = 0; c &lt; PlotN; c++) {
1202      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1203      else { Qt = GetQt(IdV[c]); }
1204      TQuote::TTmFltPrV QtV;  TFltPrV TmV;
1205      Qt.GetFqOt(QtV, TmUnit);
1206      int pos=0;  double val=0.0;
1207      for (int i = 0; i &lt; QtV.Len(); i++) {
1208        if (val &lt; QtV[i].Val2) { pos = i;  val = QtV[i].Val2; }
1209      }
1210      const double PeakVal = val;
1211      const TSecTm PeakTm = QtV[pos].Val1;
1212      for (int i = 0; i &lt; QtV.Len(); i++) {
1213        TmV.Add(TFltPr((double(QtV[i].Val1)-double(PeakTm))/(24.0*3600), QtV[i].Val2/PeakVal));
1214        MomH.AddDat(TmV.Last().Val1).Add(TmV.Last().Val2);
1215      }
1216      const TStr Label = &quot;&quot;;
1217    }
1218    TFltPrV AvgV, MedV;
1219    MomH.SortByKey();
1220    for (int i = 0; i &lt; MomH.Len(); i++) {
1221      MomH[i].Def();
1222      if (MomH[i].GetVals()&lt; MinValsPerTm) { printf(&quot;.&quot;); continue; }
1223      AvgV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMean()));
1224      MedV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMedian()));
1225    }
1226    GP.AddPlot(AvgV, gpwLines, &quot;Average&quot;, &quot;lt 2 lw 2&quot;);
1227    GP.AddPlot(MedV, gpwLines, TStr::Fmt(&quot;Median (last qt: %d %d %d)&quot;, Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(*this)), &quot;lt 1 lw 2&quot;);
1228    GP.SetXYLabel(&quot;time [days]&quot;, &quot;count&quot;);
1229    GP.AddCmd(&quot;set mxtics 6&quot;);
1230    GP.AddCmd(&quot;set xtics 1&quot;);
1231    GP.AddCmd(&quot;set yrange [0:1]&quot;);
1232    GP.AddCmd(&quot;set xrange [-5:5]&quot;);
1233    GP.AddCmd(&quot;set yzeroaxis lt -1&quot;);
1234    GP.SavePng();
1235  }
1236  void NormPeakAt1(THash&lt;TInt, TFlt&gt;&amp; H) {
1237    double PeakFq=1;
1238    for (int i = 0; i &lt; H.Len(); i++) {
1239      PeakFq=TMath::Mx((double)H[i], PeakFq); }
1240    for (int i = 0; i &lt; H.Len(); i++) {
1241      H[i]/=PeakFq; }
1242  }
1243  void TQuoteBs::PlotBlogVsMediaFqOt(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, int PlotN, const TStr&amp; OutFNmPref) const {
1244    THash&lt;TInt, TFlt&gt; Peak1AllH, Peak2AllH, Peak3AllH;
1245    THash&lt;TInt, TFlt&gt; Peak1MedH, Peak2MedH, Peak3MedH;
1246    THash&lt;TInt, TFlt&gt; Peak1BlogH, Peak2BlogH, Peak3BlogH;
1247    TQuote Qt;
1248    TIntV IdV;
1249    TInt FqAtPeak;
1250    if (TakeClusters) { GetCIdVByFq(IdV, 100, &quot;&quot;, utUndef, false); }
1251    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1252    for (int c = 0; c &lt; TMath::Mn(PlotN, IdV.Len()); c++) {
1253      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1254      else { Qt = GetQt(IdV[c]); }
1255      if (! Qt.IsSinglePeak(TmUnit, TSecTm(0), utUndef, *this)) { PlotN++; printf(&quot;.&quot;); continue; }
1256      TQuote::TTmFltPrV AllFqV, BlogFqV, MedFqV;  TFltPrV TmV;
1257      const double Peak1 = Qt.GetPeakTm(TmUnit, TSecTm(1), FqAtPeak).GetAbsSecs(); 
1258      const double Peak2 = Qt.GetMeanTm(TmUnit, utUndef, *this).GetAbsSecs();    
1259      const double Peak3 = Qt.GetMedianTm(TmUnit, utUndef, *this).GetAbsSecs();  
1260      double PeakFq = FqAtPeak;
1261      Qt.GetFqOt(AllFqV, TmUnit, utUndef, *this);
1262      Qt.GetFqOt(MedFqV, TmUnit, utMedia, *this);
1263      Qt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1264      PeakFq=1;
1265      for (int i = 0; i &lt; MedFqV.Len(); i++) { PeakFq=TMath::Mx((double)MedFqV[i].Val2(), PeakFq); }
1266      for (int i = 0; i &lt; MedFqV.Len(); i++) {
1267        const int T1 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1268        const int T2 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1269        const int T3 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1270        Peak1MedH.AddDat(T1) += MedFqV[i].Val2/PeakFq;
1271        Peak2MedH.AddDat(T2) += MedFqV[i].Val2/PeakFq;
1272        Peak3MedH.AddDat(T3) += MedFqV[i].Val2/PeakFq;
1273      }
1274      PeakFq=1;
1275      for (int i = 0; i &lt; BlogFqV.Len(); i++) { PeakFq=TMath::Mx((double)BlogFqV[i].Val2(), PeakFq); }
1276      for (int i = 0; i &lt; BlogFqV.Len(); i++) {
1277        const int T1 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1278        const int T2 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1279        const int T3 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1280        Peak1BlogH.AddDat(T1) += BlogFqV[i].Val2/PeakFq;
1281        Peak2BlogH.AddDat(T2) += BlogFqV[i].Val2/PeakFq;
1282        Peak3BlogH.AddDat(T3) += BlogFqV[i].Val2/PeakFq;
1283      }
1284    }
1285    NormPeakAt1(Peak1AllH); NormPeakAt1(Peak2AllH); NormPeakAt1(Peak3AllH);
1286    NormPeakAt1(Peak1MedH); NormPeakAt1(Peak2MedH); NormPeakAt1(Peak3MedH);
1287    NormPeakAt1(Peak1BlogH); NormPeakAt1(Peak2BlogH); NormPeakAt1(Peak3BlogH);
1288    TGnuPlot::PlotValCntH(Peak1AllH, &quot;ALL&quot;, Peak1MedH, &quot;MEDIA&quot;, Peak1BlogH, &quot;BLOG&quot;, &quot;peakMax-&quot;+OutFNmPref, &quot;Max is the peak&quot;, &quot;Time [h]&quot;, &quot;Count (sum of frequencies of all quotes)&quot;);
1289    TGnuPlot::PlotValCntH(Peak3AllH, &quot;ALL&quot;, Peak3MedH, &quot;MEDIA&quot;, Peak3BlogH, &quot;BLOG&quot;, &quot;peakMed-&quot;+OutFNmPref, &quot;Median is the peak&quot;, &quot;Time [h]&quot;, &quot;Count (sum of frequencies of all quotes)&quot;);
1290  }
1291  void TQuoteBs::PlotBlogFracOt(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, const int&amp; PlotN, const TStr&amp; OutFNmPref) const {
1292    TQuote Qt;
1293    TIntV IdV;
1294    THash&lt;TFlt, TMom&gt; TmMomH;
1295    THash&lt;TFlt, TFltPr&gt; TmBmH;
1296    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, utUndef, false); }
1297    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1298    for (int c = 0; c &lt; PlotN; c++) {
1299      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1300      else { Qt = GetQt(IdV[c]); }
1301      TQuote::TTmFltPrV MedQtV, BlgQtV;
1302      Qt.GetFqOt(MedQtV, TmUnit, utMedia, *this);
1303      Qt.GetFqOt(BlgQtV, TmUnit, utBlog, *this);
1304      TFltPrV FracV;
1305      const int PeakTm = Qt.GetPeakTm(TmUnit, TSecTm(1), utUndef, *this);
1306      for (int m=0, b=0; m &lt; MedQtV.Len(); m++) {
1307        while (b&lt;BlgQtV.Len() &amp;&amp; BlgQtV[b].Val1 &lt; MedQtV[m].Val1) { b++; }
1308        if (b&lt;BlgQtV.Len() &amp;&amp; BlgQtV[b].Val1 == MedQtV[m].Val1) {
1309          const double Tm = (int(MedQtV[m].Val1.Round(TmUnit))-PeakTm)/(24*3600.0);
1310            const double Frac = BlgQtV[b].Val2/double(BlgQtV[b].Val2+MedQtV[m].Val2);
1311            FracV.Add(TFltPr(Tm, Frac));
1312            TmMomH.AddDat(Tm).Add(Frac);
1313          TFltPr&amp; BM = TmBmH.AddDat(Tm);
1314          BM.Val1+= BlgQtV[b].Val2;
1315          BM.Val2+= MedQtV[m].Val2;
1316        }
1317      }
1318    }
1319    { TFltPrV PrV;
1320    for (int b = 0; b &lt; TmMomH.Len(); b++) {
1321      TmMomH[b].Def();
1322      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMean())); }
1323    TGnuPlot GP(TStr::Fmt(&quot;fqFracA-%s&quot;, OutFNmPref.CStr()));
1324    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1325    GP.AddCmd(&quot;set xrange [-7:7]\nset yzeroaxis lt -1&quot;); GP.SavePng(); }
1326    { TFltPrV PrV;
1327    for (int b = 0; b &lt; TmMomH.Len(); b++) {
1328      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMedian())); }
1329    TGnuPlot GP(TStr::Fmt(&quot;fqFracM-%s&quot;, OutFNmPref.CStr()));
1330    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1331    GP.AddCmd(&quot;set xrange [-7:7]\nset yzeroaxis lt -1&quot;); GP.SavePng(); }
1332    { TFltPrV PrV;
1333    for (int b = 0; b &lt; TmBmH.Len(); b++) {
1334      PrV.Add(TFltPr(TmBmH.GetKey(b), TmBmH[b].Val1/(TmBmH[b].Val1+TmBmH[b].Val2))); }
1335    TGnuPlot GP(TStr::Fmt(&quot;fqFracS-%s&quot;, OutFNmPref.CStr()));
1336    PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints);
<span onclick='openModal()' class='match'>1337    GP.AddCmd(&quot;set xrange [-7:7]\nset yzeroaxis lt -1&quot;); GP.SavePng(); }
1338  }
</span>1339  void TQuoteBs::PlotPopularityCnt(const bool&amp; TakeClusters, const TUrlTy&amp; UrlTy, const int&amp; PlotN, const TStr&amp; OutFNmPref) const {
1340    TIntV IdV;
1341    TIntH FqCntH;
1342    TQuote Qt;
1343    for (int c = 0; c &lt; Len(); c++) {
1344      const TQuote&amp; Qt = GetQtN(c);
1345      if (Qt.GetStr().IsStrIn(&quot;lipstick&quot;) &amp;&amp; Qt.GetStr().IsStrIn(&quot;pig&quot;)) {
1346        FqCntH.AddDat(Qt.GetFq(UrlTy, *this)) += 1; }
1347    }
1348    TIntPrV FqCntV, CdfV;
1349    FqCntH.GetKeyDatPrV(FqCntV);  FqCntV.Sort();
1350    TGUtil::GetCCdf(FqCntV, CdfV);
1351    TGnuPlot::PlotValV(FqCntV, &quot;pop-&quot;+OutFNmPref, &quot;&quot;, &quot;total frequency&quot;, &quot;count&quot;, gpsLog10XY);
1352    TGnuPlot::PlotValV(CdfV, &quot;popCDF-&quot;+OutFNmPref+&quot;&quot;, &quot;&quot;, &quot;total frequency&quot;, &quot;NCDF&quot;, gpsLog10XY);
1353  }
1354  void TQuoteBs::PlotEmptyY(const TTmUnit&amp; TmUnit, const bool&amp; TakeClusters, const int&amp; PlotN, const TStr&amp; OutFNmPref) const {
1355    TQuote Qt;
1356    TIntV IdV;
1357    THash&lt;TInt, TInt&gt; TmCumCntH;
1358    int MaxY=0;
1359    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, utUndef, false); }
1360    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1361    for (int c = 0; c &lt; PlotN; c++) {
1362      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1363      else { Qt = GetQt(IdV[c]); }
1364      TQuote::TTmFltPrV QtV;
1365      Qt.GetFqOt(QtV, TmUnit);
1366      for (int i = 0; i &lt; QtV.Len(); i++) {
1367        const int Tm = QtV[i].Val1.Round(tmu1Hour)/3600;
1368        TInt&amp; CumCnt = TmCumCntH.AddDat(Tm);
1369        CumCnt += (int) QtV[i].Val2;
1370        MaxY = TMath::Mx(CumCnt(), MaxY);
1371      }
1372    }
1373    TmCumCntH.SortByKey(true);
1374    const int BegHr = TmCumCntH.GetKey(0);
1375    THash&lt;TFlt, TFlt&gt; EmptyH;
1376    TFltPrV TmV;
1377    for (int t = 0; t &lt; TmCumCntH.Len(); t++) {
1378      printf(&quot;%d  &quot;, TmCumCntH[t]());
1379      for (int y = TmCumCntH[t]; y &lt; MaxY; y+=1) {
1380        EmptyH.AddDat(y) += 1; }
1381      TmV.Add(TFltPr((TmCumCntH.GetKey(t)-BegHr)/24.0, TmCumCntH[t].Val));
1382    }
1383    EmptyH.SortByKey(false);
1384    TFltPrV EmptyV;
1385    EmptyV.Add(TFltPr(EmptyH.GetKey(0), EmptyH[0]));
1386    for (int i = 1; i &lt; EmptyH.Len(); i++) {
1387      EmptyV.Add(TFltPr(EmptyH.GetKey(i), EmptyH[i]+EmptyV.Last().Val2));
1388    }
1389    TGnuPlot::PlotValCntH(EmptyH, &quot;emptyF-&quot;+OutFNmPref+&quot;-d&quot;, &quot;Amount of empty area above the cummulative query-frequency curve&quot;, &quot;y value&quot;, &quot;area at y&quot;);
1390    TGnuPlot::PlotValV(EmptyV, &quot;emptyF-&quot;+OutFNmPref+&quot;-c&quot;, &quot;Amount of empty area above the cummulative query-frequency curve&quot;, &quot;y value&quot;, &quot;area above y&quot;);
1391    TGnuPlot::PlotValV(TmV, &quot;emptyF1&quot;+OutFNmPref, &quot;Cummulative query frequency over time&quot;, &quot;time (days)&quot;, &quot;frequency&quot;);
1392  }
1393  PNGraph TQuoteBs::GetQuotePostNet(const TStr&amp; DatasetFNm) const {
1394    PNGraph Graph = TNGraph::New();
1395    for (TMemesDataLoader Memes(DatasetFNm); Memes.LoadNext(); ) {
1396      if (Memes.MemeV.Empty()) { continue; }
1397      if (! IsStr(Memes.PostUrlStr.CStr())) { continue; }
1398      const int SrcNId = GetStrId(Memes.PostUrlStr.CStr());
1399      for (int u = 0; u &lt; Memes.LinkV.Len(); u++) {
1400        if (! IsStr(Memes.LinkV[u].CStr())) { continue; }
1401        const int DstNId = GetStrId(Memes.LinkV[u].CStr());
1402        if (! Graph-&gt;IsNode(SrcNId)) { Graph-&gt;AddNode(SrcNId); }
1403        if (! Graph-&gt;IsNode(DstNId)) { Graph-&gt;AddNode(DstNId); }
1404        Graph-&gt;AddEdge(SrcNId, DstNId);
1405      }
1406    }
1407    TSnap::PrintInfo(Graph);
1408    return Graph;
1409  }
1410  PQtDomNet TQuoteBs::GetQuoteDomNet(const PNGraph&amp; PostGraph, const int&amp; CId) const {
1411    TQuote Qt;  GetMergedClustQt(CId, Qt, false);
1412    PQtDomNet DomG = TQtDomNet::New();
1413    TIntSet UrlSet;
1414    for (int i = 0; i &lt; Qt.GetTimes(); i++) { UrlSet.AddKey(Qt.GetUrlId(i)); }
1415    TStrSet DomH;
1416    for (int i = 0; i &lt; Qt.GetTimes(); i++) {
1417      const int url = Qt.GetUrlId(i);
1418      if (! PostGraph-&gt;IsNode(url)) { continue; }
1419      const int dom = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url)));
1420      TNGraph::TNodeI NI = PostGraph-&gt;GetNI(url);
1421      for (int o = 0; o &lt; NI.GetOutDeg(); o++) {
1422        if (! UrlSet.IsKey(NI.GetOutNId(o))) { continue; }
1423        const int url2 = NI.GetOutNId(o);
1424        const int dom2 = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url2)));
1425        if (dom==dom2) { continue; }
1426        if (! DomG-&gt;IsNode(dom)) {
1427          DomG-&gt;AddNode(dom, TPair&lt;TStr, TInt&gt;(DomH[dom], GetUrlTy(url))); }
1428        if (! DomG-&gt;IsNode(dom2)) {
1429          DomG-&gt;AddNode(dom2, TPair&lt;TStr, TInt&gt;(DomH[dom2], GetUrlTy(url2))); }
1430        if (DomG-&gt;IsEdge(dom, dom2)) {
1431          DomG-&gt;GetEDat(dom, dom2) += 1; }
1432        else {
1433          DomG-&gt;AddEdge(dom, dom2, 1); }
1434      }
1435    }
1436    return DomG;
1437  }
1438  void TQuoteBs::SaveQuotes(const int&amp; MinQtFq, const TStr&amp; OutFNm) const {
1439    TIntV QtIdV;
1440    GetQtIdVByFq(QtIdV, 0, MinQtFq);
1441    SaveQuotes(QtIdV, OutFNm);
1442  }
1443  void TQuoteBs::SaveQuotes(const TIntV&amp; QtIdV, const TStr&amp; OutFNm) const {
1444    TIntSet QtIdSet;
1445    FILE *F = fopen(OutFNm.CStr(), &quot;wt&quot;);
1446    printf(&quot;saving %d quotes\n&quot;, QtIdV.Len());
1447    fprintf(F, &quot;#Freq\tUrls\tDomains\tQuote\n&quot;);
1448    for (int q = 0; q &lt; QtIdV.Len(); q++) {
1449      const int QtId = QtIdV[q];
1450      if (QtIdSet.IsKey(QtId)) { continue; } 
1451      QtIdSet.AddKey(QtId);
1452      const TQuote&amp; Q = GetQt(QtId);
1453    fprintf(F, &quot;%d\t%d\t%d\t%s\n&quot;, Q.GetFq(), Q.GetUrls(), Q.GetDoms(*this), Q.QtStr.CStr());
1454      if (Q.GetTy() == qtRoot || Q.GetTy() == qtCentr) { 
1455        IAssert(ClustQtIdVH.IsKey(Q.GetCId()));
1456        const TIntV&amp; ClustV = ClustQtIdVH.GetDat(Q.GetCId());
1457        for (int i = 0; i &lt; ClustV.Len(); i++) {
1458          const TQuote&amp; Q1 = GetQt(ClustV[i]);
1459          fprintf(F, &quot;\t[%d] %d=%d %s\t%d\t%d\t%d\n&quot;, TStrUtil::CountWords(Q1.QtStr.CStr()),
1460            ClustV[i](), Q1.GetCId(), Q1.QtStr.CStr(), Q1.GetFq(), Q1.GetUrls(), Q1.GetDoms(*this));
1461          QtIdSet.AddKey(ClustV[i]);
1462        }
1463      }
1464    }
1465    fclose(F);
1466  }
1467  void TQuoteBs::SaveClusters(const TStr&amp; OutFNm, const bool&amp; SkipUrls) const {
1468    TIntPrV FqCIdV;
1469    TIntH ClSzCntH, ClFqCntH;
1470    for (int c = 0; c &lt; GetClusts(); c++) {
1471      const int CId = GetCId(c);
1472      if ( ! IsQtId(CId)) { printf(&quot;!!! %d:%d\n&quot;, c, CId); continue; }
1473      FqCIdV.Add(TIntPr(GetClustFq(CId), CId));
1474      ClSzCntH.AddDat(GetClust(CId).Len()) += 1;
1475      ClFqCntH.AddDat(GetClustFq(CId)) += 1;
1476    }
1477    TGnuPlot::PlotValCntH(ClSzCntH, OutFNm+&quot;-clSz&quot;, TStr::Fmt(&quot;%d clusters&quot;, GetClusts()), &quot;Number of quotes in the cluster&quot;, &quot;Number of clusters&quot;, gpsLog);
1478    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+&quot;-clFq&quot;, TStr::Fmt(&quot;%d clusters&quot;, GetClusts()), &quot;Volume of quotes in the cluster&quot;, &quot;Number of clusters&quot;, gpsLog, false, gpwLinesPoints, false, false);
1479    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+&quot;-clFqB&quot;, TStr::Fmt(&quot;%d clusters&quot;, GetClusts()), &quot;Volume of quotes in the cluster&quot;, &quot;Number of clusters&quot;, gpsLog, false, gpwLinesPoints, false, true);
1480    FqCIdV.Sort(false);
1481    TIntPrV QtFqV;
1482    FILE *F = fopen(TStr::Fmt(&quot;%s-clust.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1483    fprintf(F, &quot;format:\n&lt;ClSz&gt;\t&lt;TotFq&gt;\t&lt;Root&gt;\t&lt;ClusterId&gt;\n&quot;);
1484    fprintf(F, &quot;\t&lt;QtFq&gt;\t&lt;Urls&gt;\t&lt;QtStr&gt;\t&lt;QuteId&gt;\n&quot;);
1485    fprintf(F, &quot;\t\t&lt;Tm&gt;\t&lt;Fq&gt;\t&lt;UrlTy&gt;\t&lt;Url&gt;\n\n&quot;);
1486    for (int c = 0; c &lt; FqCIdV.Len(); c++) {
1487      const int CId = FqCIdV[c].Val2;
1488      const TIntV&amp; ClustV = GetClust(CId);
1489      fprintf(F, &quot;\n%d\t%d\t%s\t%d\n&quot;, ClustV.Len(), FqCIdV[c].Val1(), GetQt(CId).GetStr().CStr(), CId);
1490      QtFqV.Clr(false);
1491      for (int q = 0; q &lt; ClustV.Len(); q++) {
1492        IAssert(IsQtId(ClustV[q]));
1493        QtFqV.Add(TIntPr(GetQt(ClustV[q]).GetUrls(), ClustV[q])); }
1494      QtFqV.Sort(false);
1495      for (int q = 0; q &lt; QtFqV.Len(); q++) {
1496        IAssert(IsQtId(QtFqV[q].Val2));
1497        const TQuote&amp; Qt = GetQt(QtFqV[q].Val2);
1498        if ((! SkipUrls) &amp;&amp; q &gt; 0) { fprintf(F, &quot;\n&quot;); }
1499        fprintf(F, &quot;\t%d\t%d\t%s\t%d\n&quot;, Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), QtFqV[q].Val2());
1500        if (! SkipUrls) {
1501          for (int u = 0; u &lt; Qt.GetUrls(); u++) {
1502            fprintf(F, &quot;\t\t%s\t%d\t%s\t%s\n&quot;, Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1503              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?&quot;M&quot;:&quot;B&quot;, GetStr(Qt.TmUrlCntV[u].UrlId())); }
1504        }
1505      }
1506    }
1507    fclose(F);
1508  }
1509  void TQuoteBs::SaveClusters(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, const bool&amp; SkipUrls) const {
1510    FILE *F = fopen(TStr::Fmt(&quot;%s-clust.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1511    fprintf(F, &quot;format:\n&lt;ClSz&gt;\t&lt;TotFq&gt;\t&lt;Root&gt;\t&lt;ClusterId&gt;\n&quot;);
1512    fprintf(F, &quot;\t&lt;QtFq&gt;\t&lt;Urls&gt;\t&lt;QtStr&gt;\t&lt;QuteId&gt;\n&quot;);
1513    fprintf(F, &quot;\t\t&lt;Tm&gt;\t&lt;Fq&gt;\t&lt;UrlTy&gt;\t&lt;Url&gt;\n\n&quot;);
1514    for (int c = 0; c &lt; QtIdV.Len(); c++) {
1515      int CId = QtIdV[c];
1516      if (! IsClust(CId)) { CId = GetQt(CId).GetCId(); }
1517      const TIntV&amp; ClustV = GetClust(CId);
1518      fprintf(F, &quot;\n%d\t%d\t%s\t%d\n&quot;, ClustV.Len(), GetClustFq(CId), GetQt(CId).GetStr().CStr(), CId);
1519      for (int q = 0; q &lt; ClustV.Len(); q++) {
1520        const TQuote&amp; Qt = GetQt(ClustV[q]);
1521        if ((! SkipUrls) &amp;&amp; q &gt; 0) { fprintf(F, &quot;\n&quot;); }
1522        fprintf(F, &quot;\t%d\t%d\t%s\t%d\n&quot;, Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), ClustV[q]());
1523        if (! SkipUrls) {
1524          for (int u = 0; u &lt; Qt.GetUrls(); u++) {
1525            fprintf(F, &quot;\t\t%s\t%d\t%s\t%s\n&quot;, Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1526              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?&quot;M&quot;:&quot;B&quot;, GetStr(Qt.TmUrlCntV[u].UrlId())); }
1527        }
1528      }
1529    }
1530    fclose(F);
1531  }
1532  void TQuoteBs::SaveBigBlogMassQt(const TStr&amp; OutFNm) const {
1533    const TTmUnit TmUnit = tmuDay;
1534    const bool TakeClusters = true;
1535    TIntV IdV;
1536    TQuote Qt;
1537    int Candidates=0;
1538    if (TakeClusters) { GetCIdVByFq(IdV, 10, &quot;&quot;, utUndef, false); }
1539    else { GetQtIdVByFq(IdV, 8, 10, false, &quot;&quot;, &quot;&quot;, utUndef); }
1540    TVec&lt;TPair&lt;TFlt, TStr&gt; &gt; ScoreV;
1541    for (int c = 0; c &lt; IdV.Len(); c++) {
1542      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1543      else { Qt = GetQt(IdV[c]); }
1544      const int MediaPeak = Qt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this); 
1545      const double BlogFq = Qt.GetUrls(TSecTm(MediaPeak-21*24*3600), TSecTm(MediaPeak-7*24*3600), utBlog, *this);  
1546      const double TotFq = Qt.GetUrls();
1547      if (BlogFq &lt; 10) { continue; }
1548      Candidates++;
1549      if (BlogFq &lt; TotFq*0.15 || BlogFq &gt; TotFq*0.75) { continue; }
1550      ScoreV.Add(TFltStrPr(TotFq, TStr::Fmt(&quot;%g\t%g\t%s&quot;, BlogFq, TotFq, Qt.GetStr().CStr())));
1551    }
1552    printf(&quot;Considered: %d quotes\n&quot;, IdV.Len());
1553    printf(&quot;            %d candidates\n&quot;, Candidates);
1554    printf(&quot;            %d selected\n&quot;, ScoreV.Len());
1555    ScoreV.Sort(false);
1556    FILE *F = fopen(TStr::Fmt(&quot;%s.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1557    fprintf(F, &quot;total %d items\n&quot;, IdV.Len());
1558    fprintf(F, &quot;items above blog threshdolg %d\n&quot;, ScoreV.Len());
1559    fprintf(F, &quot;counts are numbers of urls (not actually number of occurences)\n&quot;);
1560    fprintf(F, &quot;\nblog\ttotal\tQuote\n&quot;);
1561    for (int i = 0; i &lt; ScoreV.Len(); i++) {
1562      fprintf(F, &quot;%s\n&quot;, ScoreV[i].Val2.CStr());
1563    }
1564    fclose(F);
1565  }
1566  void TQuoteBs::SaveForFlash(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, const TTmUnit&amp; TmUnit, int SaveN, const TSecTm&amp; BegTm, const TSecTm&amp; EndTm, const TUrlTy&amp; OnlyCountTy) const {
1567    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
1568    TVec&lt;TQuad&lt;TFlt, TInt, TInt, TQuote::TTmFltPrV&gt; &gt; QtInfoV, QtInfoV2; 
1569    TQuote::TTmFltPrV FqV, SmoothFqV;
1570    TIntV VizQtIdV;
1571    if (SaveN == -1) { SaveN = TInt::Mx; }
1572    TSecTm MinTm=TSecTm(TInt::Mx-1), MaxTm=TSecTm(1);
1573    printf(&quot;Saving top %d out of %d quotes\n&quot;, SaveN, QtIdV.Len());
1574    THash&lt;TInt, TIntPr&gt; WeekPeakQtIdH; 
1575    for (int q = 0; q &lt; QtIdV.Len() &amp;&amp; QtInfoV2.Len() &lt; (SaveN+100); q++) { 
1576      const TQuote&amp; Qt = GetQt(QtIdV[q]);
1577      if (Qt.GetTy() == qtQuote) {
1578        Qt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1579        if (FqV.Empty()) { continue; }
1580        QtInfoV2.Add(TQuad&lt;TFlt, TInt, TInt, TQuote::TTmFltPrV&gt;((double)Qt.GetPeakTm(TmUnit, BegTm)+1e-6*Qt.GetUrls(), QtIdV[q], Qt.GetFq(), FqV));
1581        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1582        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1583        VizQtIdV.Add(QtIdV[q]);
1584        TInt PeakFq;
1585        const int PeakTm = Qt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1586        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1587          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1588        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1&lt;PeakFq) {
1589          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1590      } else { 
1591        const int CId = Qt.GetCId();
1592        if (! ClustQtIdVH.IsKey(CId)) { continue; }
1593        const int CentrQtId = GetCentrQtId(CId);
1594        TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, true);
1595        CentrQt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1596        if (FqV.Empty()) { continue; }
1597        QtInfoV2.Add(TQuad&lt;TFlt, TInt, TInt, TQuote::TTmFltPrV&gt;((double)CentrQt.GetPeakTm(TmUnit, BegTm)+1e-6*CentrQt.GetUrls(), CentrQtId, GetClustFq(CId), FqV));
1598        TInt PeakFq;
1599        const int PeakTm = CentrQt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1600        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1601          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1602        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1&lt;PeakFq) {
1603          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1604        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1605        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1606        VizQtIdV.Add(CentrQtId);
1607      } /&amp;bsol;*/
1608    }
1609    { TIntSet QtIdSet;
1610    for (int i = 0; i &lt; WeekPeakQtIdH.Len(); i++) {
1611    }
1612    QtInfoV.Clr(true);
1613    for (int i = 0; i &lt; TMath::Mn(SaveN, QtInfoV2.Len()); i++) {
1614      if (QtIdSet.IsKey(i)) { continue; }
1615      QtInfoV.Add(QtInfoV2[i]);
1616    printf(&quot;%d  &quot;, (int) QtInfoV2[i].Val3()); 
1617      if (QtInfoV.Len() &gt; SaveN) { break; }
1618    } } 
1619    THash&lt;TSecTm, TIntFltH&gt; TmCntH; 
1620    for (int i = 0; i &lt; QtInfoV.Len(); i++) {
1621      const TQuote::TTmFltPrV&amp; FqV = QtInfoV[i].Val4;
1622      for (int t = 0; t &lt; FqV.Len(); t++) {
1623        TmCntH.AddDat(FqV[t].Val1).AddDat(i, FqV[t].Val2); }
1624    }
1625    for (int i = 0; i &lt; TmCntH.Len(); i++) {
1626      TmCntH[i].SortByDat(false); }
1627    const int K = 10;
1628    const int Slack = 3*24*3600; 
1629    THash&lt;TInt, TSecTm&gt; QtLastTopH; 
1630    for (int i = 0; i &lt; TmCntH.Len(); i++) {
1631      TIntFltH&amp; TmH = TmCntH[i];
1632      for (int j = 0; j &lt; TMath::Mn(K, TmH.Len()); j++) {
1633        QtLastTopH.AddDat(TmH.GetKey(j), TmCntH.GetKey(i));
1634      }
1635    }
1636    for (int i = 0; i &lt; QtInfoV.Len(); i++) {
1637      TQuote::TTmFltPrV&amp; FqV = QtInfoV[i].Val4;
1638      const TSecTm LastTime = QtLastTopH.GetDat(i);
1639      int x = 0; for (x = 0; x &lt; FqV.Len() &amp;&amp; FqV[x].Val1 &lt;= LastTime+Slack; x++) { }
1640      if (x &lt; FqV.Len()) { FqV.Del(x, FqV.Len()-1); }
1641    } 
1642    printf(&quot;save from %d quotes\n&quot;, QtInfoV.Len());
1643    QtInfoV.Sort();
1644    TIntH QtIdUrlH;  GetQtPageUrl(VizQtIdV, QtIdUrlH);
1645    FILE *F = fopen(TStr::Fmt(&quot;qtOt-%sQ.tab&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1646    fprintf(F, &quot;QuoteId\tQuote\tUrl\tTotalVol\n&quot;);
1647    for (int i = 0; i &lt; TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1648      fprintf(F, &quot;%d\t%s\t%s\t%d\n&quot;, SaveN-i, GetQt(QtInfoV[i].Val2).QtStr.CStr(), GetStr(QtIdUrlH.GetDat(QtInfoV[i].Val2)), (int) QtInfoV[i].Val3);
1649    }
1650    fclose(F);
1651    printf(&quot;saveT\n&quot;);
1652    F = fopen(TStr::Fmt(&quot;qtOt-%sT.tab&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1653    fprintf(F, &quot;Time\tQuoteId\tSmoothFreq\tRawFreq\n&quot;);
1654    for (int i = 0; i &lt; TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1655      const TQuote::TTmFltPrV RawFqV = QtInfoV[i].Val4;
1656      TQuote::GetSmoothFqOt(SmoothFqV, RawFqV, TmUnit, 6*24*3600/TmUnitSecs, 1.05, MinTm, MaxTm);  
1657      IAssert(SmoothFqV.Len() &gt;= RawFqV.Len());
1658      for (int d=0, ds = 0; ds &lt; SmoothFqV.Len(); ds++) {
1659        if (TmUnit == tmuDay) { fprintf(F, &quot;%s&quot;, SmoothFqV[ds].Val1.GetDtYmdStr().CStr()); }
1660        else { fprintf(F, &quot;%s_%02d&quot;, SmoothFqV[ds].Val1.GetDtYmdStr().CStr(), SmoothFqV[ds].Val1.GetHourN()); }
1661        fprintf(F, &quot;\t%d\t%.2f&quot;, SaveN-i, SmoothFqV[ds].Val2());
1662        if (d &lt; RawFqV.Len() &amp;&amp; SmoothFqV[ds].Val1 == RawFqV[d].Val1) { fprintf(F, &quot;\t%.0f&quot;, RawFqV[d].Val2()); d++; } else { fprintf(F, &quot;\t0&quot;); }
1663        fprintf(F, &quot;\n&quot;);
1664      }
1665    }
1666    fclose(F);
1667    printf(&quot;done.\n&quot;);
1668  }
1669  void TQuoteBs::SaveDomainStat(const TStr&amp; OutFNm, const int&amp; MinCnt) const {
1670    THash&lt;TInt, TInt&gt; MedOt, BlogOt, AllOt;
1671    int MedCnt=0, BlogCnt=0, AllCnt=0;
1672    TSecTm BegTm(2008,7,31,0,0,0);
1673    THash&lt;TStr, TIntPr&gt; DomCntH;
1674    for (int q = 0; q &lt; QuoteH.Len(); q++) {
1675      const TQuote&amp; Q = QuoteH[q];
1676      for (int u = 0; u &lt; Q.GetUrls(); u++) {
1677        const int Day = TSecTm(Q.GetTm(u)-BegTm).GetInUnits(tmuDay);
1678        AllOt.AddDat(Day) += 1;  AllCnt++;
1679        if (GetUrlTy(Q.GetUrlId(u)) ==  utMedia) { MedOt.AddDat(Day) += 1;  MedCnt++;}
1680        else { BlogOt.AddDat(Day) += 1;  BlogCnt++; }
1681        TStr Dom = TStrUtil::GetDomNm2(GetStr(Q.GetUrlId(u)));
1682        DomCntH.AddDat(Dom).Val1 += 1;
1683        DomCntH.AddDat(Dom).Val2 += Q.GetCnt(u);
1684      }
1685    }
1686    TGnuPlot::PlotValCntH(AllOt, &quot;ALL&quot;, MedOt, &quot;MEDIA&quot;, BlogOt, &quot;BLOGS&quot;, &quot;overTm-&quot;+OutFNm, TStr::Fmt(&quot;Quote freq over time: A:%d M:%d B:%d&quot;, AllCnt, MedCnt, BlogCnt),
1687      &quot;Time [days]&quot;, &quot;Number of quote mentions&quot;);
1688    DomCntH.SortByDat(false);
1689    FILE *F = fopen(TStr::Fmt(&quot;domains-%s.tab&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1690    fprintf(F, &quot;# %d domains, total mentions:\tAll:%d\tMedia:%d\tBlogs:%d&quot;, DomCntH.Len(), AllCnt, MedCnt, BlogCnt);
1691    fprintf(F, &quot;#Domain\tNumber of quotes mentioned\tNumber of mentions\n&quot;);
1692    for (int d = 0; d &lt; DomCntH.Len(); d++) {
1693      fprintf(F, &quot;%s\t%d\t%d\n&quot;, DomCntH.GetKey(d).CStr(), DomCntH[d].Val1(), DomCntH[d].Val2());
1694    }
1695    fclose(F);
1696  }
1697  void TQuoteBs::Dump(const bool&amp; Fast) const {
1698    printf(&quot;Quote base:\n&quot;);
1699    if (! Fast) {
1700      TSecTm MinTm, MaxTm; GetMinMaxTm(MinTm, MaxTm);
1701      printf(&quot;  %s -- %s\n&quot;, MinTm.GetYmdTmStr().CStr(), MaxTm.GetYmdTmStr().CStr());
1702      int totCnt=0, totVol=0;
1703      for (int q = 0; q &lt; QuoteH.Len(); q++) {
1704        const TQuote::TTmUrlCntV&amp; V = QuoteH[q].TmUrlCntV;
1705        totCnt += V.Len();
1706        for (int u = 0; u &lt; V.Len(); u++) {
1707          totVol += V[u].Cnt();
1708        }
1709      }
1710      printf(&quot;  %d number of posts mentioning quotes\n&quot;, totCnt);
1711      printf(&quot;  %d number of mentions\n&quot;, totVol);
1712    }
1713    printf(&quot;  %d quotes\n&quot;, Len());
1714    printf(&quot;  %d strings (quotes+urls, no domains)\n&quot;, StrQtIdH.Len());
1715    printf(&quot;  %d clusters\n&quot;, ClustQtIdVH.Len());
1716    printf(&quot;  %d quotes in clusters\n&quot;, GetQtsInClust());
1717    printf(&quot;  %d urls with type\n\n&quot;, UrlTyH.Len());
1718  }
1719  PQuoteBs TQuoteBs::FindQtInTxtQBs(const TStr&amp; InBinFNmWc, const TStrV&amp; QuoteStrV) {
1720    THashSet&lt;TMd5Sig&gt; SeenUrlH; 
1721    PQuoteBs QtBsPt = TQuoteBs::New();
1722    TQuoteBs&amp; QtBs = *QtBsPt;
1723    TStrHash&lt;TInt&gt; StrH;
1724    TVec&lt;TIntV&gt; QtWIdVV;
1725    TVec&lt;TIntV&gt; QtSkipLenVV; 
1726    for (int q = 0; q &lt; QuoteStrV.Len(); q++) {
1727      const int QId = QtBs.QuoteH.Len(); 
1728      TQuote&amp; Qt = QtBs.QuoteH.AddDat(QId);
1729      Qt.QtCIdTy = TQuote::TQtIdTy(QId, qtQuote);
1730      Qt.QtStr = QuoteStrV[q];
1731      QtWIdVV.Add();  QtSkipLenVV.Add();
1732      TStrUtil::GetAddWIdV(StrH, QuoteStrV[q].CStr(), QtWIdVV.Last());
1733      TIntV&amp; WIdV = QtWIdVV.Last();
1734      TIntV&amp; SkipV = QtSkipLenVV.Last();
1735      SkipV.Add(1);
1736      for (int w = 1; w &lt; WIdV.Len(); w++) {
1737        int skipLen = 1;
1738        while (w-skipLen &gt;= 0 &amp;&amp; WIdV[w-skipLen] != WIdV[w]) { skipLen++; }
1739        SkipV.Add(skipLen);
1740      }
1741    }
1742    TInt WId;
1743    TIntV TxtWIdV;
1744    TVec&lt;char *&gt; WrdV;
1745    TQuoteLoader QL(InBinFNmWc);
1746    while (QL.Next()) {
1747      if (SeenUrlH.IsKey(TMd5Sig(QL.PostUrlStr))) { continue; }
1748      SeenUrlH.AddKey(TMd5Sig(QL.PostUrlStr));
1749      TxtWIdV.Clr();  WrdV.Clr(false);
1750      { TStrUtil::SplitWords(QL.ContentStr, WrdV);
1751      for (int w = 0; w &lt; WrdV.Len(); w++) {
1752        if (StrH.IsKeyGetDat(WrdV[w], WId)) { TxtWIdV.Add(WId); }
1753        else if (TxtWIdV.Len()&gt;0 &amp;&amp; TxtWIdV.Last()!=-1) { TxtWIdV.Add(-1); }
1754      } }
1755      for (int q = 0; q &lt; QtWIdVV.Len(); q++) {
1756        const TIntV&amp; QWIdV = QtWIdVV[q];
1757        const TIntV&amp; SkipV = QtSkipLenVV[q];
1758        int cnt = 0;
1759        for (int w = 0; w &lt; TxtWIdV.Len()-QWIdV.Len(); ) {
1760          int len = 0;
1761          while (len &lt; QWIdV.Len() &amp;&amp; TxtWIdV[w+len] == QWIdV[len]) { len++; }
1762          if (len == QWIdV.Len()) { cnt+=1;  w+=len; }
1763          else { w += SkipV[len]; }
1764        }
1765        if (cnt &gt; 0) {
1766          QtBs.GetQtN(q).TmUrlCntV.Add(TQuote::TTmUrlCnt(QL.PubTm, QtBs.AddStr(QL.PostUrlStr), cnt));
1767          if (cnt &gt; 255) { printf(&quot;*&quot;); }
1768        }
1769      }
1770    }
1771    for (int i = 0; i &lt; QtBs.Len(); i++) { QtBs.QuoteH[i].TmUrlCntV.Sort(); }
1772    return QtBsPt;
1773  }
1774  #ifdef false
1775  void TQuoteBs::BuildQtSubSeqCounts(TIntV&amp; QtIdV, const TStr&amp; OutFNm) {
1776  }
1777  void TQuoteBs::PlotQtFqOverTm(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int PlotN) const {
1778    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1779    TGnuPlot GP(&quot;fqOT.&quot;+OutFNm);
1780    TFltPrV HrFqV;
1781    if (PlotN == -1) { PlotN = TInt::Mx; }
1782    for (int i = 0; i &lt; TMath::Mn(PlotN, QtIdV.Len()); i++) {
1783      const TQuote&amp; Qt = GetQt(QtIdV[i]);
1784      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1785      for (int h = 0; h &lt; HrFqV.Len(); h++) {
1786        HrFqV[h].Val1 = TMath::Round(HrFqV[h].Val1/24.0, 2);
1787      }
1788      GP.AddPlot(HrFqV, gpwLines, TStrUtil::GetShorStr(Qt.QtStr), &quot;lt 1&quot;);
1789    }
1790    GP.SetXYLabel(&quot;Time [days]&quot;, &quot;Frequency&quot;);
1791    GP.AddCmd(&quot;set nokey&quot;);
1792    GP.SavePng(&quot;fqOT.&quot;+OutFNm+&quot;.png&quot;, -1, -1, &quot;&quot;, &quot;set terminal png small size 3000,600&quot;);
1793    GP.AddCmd(&quot;set size 2,0.5&quot;);
1794    GP.SaveEps(10);
1795  }
1796  void TQuoteBs::PlotQtCumFqOverTm(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int PlotN) const {
1797    const int TmuSecs = TTmInfo::GetTmUnitSecs(tmu1Hour);
1798    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1799    const TSecTm StartTm = MinTm.Round(tmu1Hour);
1800    const TSecTm EndTm = MaxTm.Round(tmu1Hour);
1801    TQuote::TTmFltPrV HrFqV;
1802    TFltFltH SumCntH;
1803    for (TSecTm Tm = StartTm; Tm &lt;= MaxTm.Round(tmu1Hour); Tm += TmuSecs) {
1804      SumCntH.AddDat(double(Tm-StartTm)/(24.0*3600.0)) = 0;
1805    }
1806    TGnuPlot GP(&quot;cfqOT.&quot;+OutFNm);
1807    if (PlotN == -1) { PlotN = TInt::Mx; }
1808    for (int i = 0; i &lt; TMath::Mn(PlotN, QtIdV.Len()); i++) {
1809      const TQuote&amp; Qt = GetQt(QtIdV[i]);
1810      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, 48, 1.2);
1811      for (int h = 0; h &lt; HrFqV.Len(); h++) {
1812        const TSecTm roundTm = HrFqV[h].Val1.Round(tmu1Hour);
1813        if (roundTm &gt;= StartTm &amp;&amp; roundTm&lt;=EndTm) {
1814          SumCntH.AddDat(double(roundTm-StartTm)/(24.0*3600.0)) += HrFqV[h].Val2;
1815        }
1816      }
1817      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr, 100).CStr());
1818    }
1819    GP.SetXYLabel(TStr::Fmt(&quot;Time [days] since %s&quot;, StartTm.GetYmdTmStr().CStr()), &quot;Stacked frequency&quot;);
1820    GP.AddCmd(&quot;set notitle&quot;);
1821    GP.AddCmd(&quot;set nogrid&quot;);
1822    GP.AddCmd(&quot;set mxtics 4&quot;);
1823    GP.SavePng(&quot;cfqOT.&quot;+OutFNm+&quot;.png&quot;, -1, -1, &quot;&quot;, &quot;set terminal png small size 1000,600&quot;);
1824  }
1825  void TQuoteBs::PlotQtCumFqOverTm1(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int PlotN) const {
1826    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1827    TGnuPlot GP(&quot;cfqOT.&quot;+OutFNm);
1828    TFltPrV HrFqV, HrCFqV;
1829    TFltFltH SumCntH;
1830    if (PlotN == -1) { PlotN = TInt::Mx; }
1831    for (int i = 0; i &lt; TMath::Mn(PlotN, QtIdV.Len()); i++) {
1832      const TQuote&amp; Qt = GetQt(QtIdV[i]);
1833      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1834      HrCFqV.Clr(false);
1835      for (int h = 0; h &lt; HrFqV.Len(); h++) {
1836        const double hr = TMath::Round(HrFqV[h].Val1/24.0+0.001, 2);
1837        SumCntH.AddDat(hr) += HrFqV[h].Val2;
1838      }
1839      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr).CStr(), &quot;lt 1&quot;);
1840    }
1841    GP.SetXYLabel(&quot;Time [days]&quot;, &quot;Stacked frequency&quot;);
1842    GP.AddCmd(&quot;set nokey&quot;);
1843    GP.AddCmd(&quot;set notitle&quot;);
1844    GP.AddCmd(&quot;set nogrid&quot;);
1845    GP.AddCmd(&quot;set mxtics 5&quot;);
1846    GP.AddCmd(&quot;set xtics 5&quot;);
1847    GP.SavePng(&quot;cfqOT.&quot;+OutFNm+&quot;.png&quot;, -1, -1, &quot;&quot;, &quot;set terminal png small size 3000,600&quot;);
1848    GP.AddCmd(&quot;set size 2,0.5&quot;);
1849    GP.SaveEps(8);
1850  }
1851  void TQuoteBs::SaveForMatlab(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int SaveN) const {
1852    const TTmUnit TmUnit = tmu1Hour;
1853    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1854    THash&lt;TInt, TFlt&gt; TmCntH;
1855    TVec&lt;TFltV&gt; TmQtFqV;
1856    const int MinTmUnit = MinTm.GetInUnits(TmUnit);
1857    for (uint i = MinTmUnit; i &lt;= MaxTm.GetInUnits(TmUnit); i++) {
1858      TmCntH.AddDat(i, 0);  TmQtFqV.Add();
1859      TmQtFqV.Last().Add(i-MinTmUnit+1); 
1860    }
1861    TQuote::TTmFltPrV DayFqV;
1862    if (SaveN == -1) { SaveN = TInt::Mx; }
1863    for (int i = 0; i &lt; TMath::Mn(SaveN, QtIdV.Len()); i++) {
1864      const TQuote&amp; Qt = GetQt(QtIdV[i]);
1865      Qt.GetSmoothFqOverTm(DayFqV, TmUnit, 48, 1.2);
1866      for (int d = 0; d &lt; TmCntH.Len(); d++) { TmCntH[d] = 0; }
1867      for (int d = 0; d &lt; DayFqV.Len(); d++) {
1868        const int T = DayFqV[d].Val1.GetInUnits(TmUnit);
1869        if (TmCntH.IsKey(T)) {
1870          TmCntH.AddDat(T) += DayFqV[d].Val2; }
1871      }
1872      for (int d = 0; d &lt; TmCntH.Len(); d++) {
1873        TmQtFqV[d].Add(TmCntH[d]); }
1874    }
1875    FILE *F = fopen(TStr::Fmt(&quot;qtFqOtMATLAB-%s.tab&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
1876    for (int d = 0; d &lt; TmQtFqV.Len(); d++) {
1877      fprintf(F, &quot;%g&quot;, TmQtFqV[d][0]());
1878      for (int q = 1; q &lt; TmQtFqV[d].Len(); q++) {
1879        fprintf(F, &quot;\t%g&quot;, TmQtFqV[d][q]()); }
1880      fprintf(F, &quot;\n&quot;);
1881    }
1882    fclose(F);
1883  }
1884  void TQuoteBs::SaveQtTmUrlTxt(const TIntV&amp; QtIdV, const TStr&amp; OutFNm, int SaveN) const {
1885    if (SaveN == -1) { SaveN = TInt::Mx; }
1886    SaveN = TMath::Mn(SaveN, QtIdV.Len());
1887    FILE *F = fopen(OutFNm.CStr(), &quot;wt&quot;);
1888    for (int q = 0; q &lt; QtIdV.Len(); q++) {
1889      const TQuote&amp; Qt = GetQt(QtIdV[q]);
1890      fprintf(F, &quot;%s\t%d\n&quot;, Qt.QtStr.CStr(), Qt.GetFq());
1891      for (int u = 0; u &lt; Qt.GetUrls(); u++) {
1892        fprintf(F, &quot;\t%s\t%s\n&quot;, Qt.TmUrlCntV[u].Val1.GetYmdTmStr().CStr(), GetStr(Qt.TmUrlCntV[u].Val2));
1893      }
1894      fprintf(F, &quot;\n&quot;);
1895    }
1896    fclose(F);
1897  }
1898  void TQuoteBs::PlotSubQtOverTm(const int&amp; QtId, const TStr&amp; OutFNm) const {
1899    TIntV PlotQtV;
1900    const TQuote Qt = GetQt(QtId);
1901    PlotQtV.Add(QtId);
1902    TIntV WrdBegV; WrdBegV.Add(0);
1903    for (int i = 1; i &lt; Qt.QtStr.Len()-1; i++) {
1904      if (TCh::IsAlNum(Qt.QtStr.GetCh(i)) &amp;&amp; TCh::IsWs(Qt.QtStr.GetCh(i-1))) { WrdBegV.Add(i); }
1905    }
1906    TInt subQtId;
1907    WrdBegV.Add(Qt.QtStr.Len()+1); 
1908    const int QtWords = TStrUtil::CountWords(Qt.QtStr.CStr());
1909    for (int WndSz = 5; WndSz &lt; QtWords; WndSz++) {
1910      for (int word = 0; word &lt; QtWords-WndSz; word++) {
1911        const TStr SubQtStr = Qt.QtStr.GetSubStr(WrdBegV[word], WrdBegV[word+WndSz]-2);
1912        if (StrH.IsKeyGetDat(SubQtStr, subQtId) &amp;&amp; QuoteH.IsKey(subQtId) &amp;&amp; subQtId!=QtId) { PlotQtV.Add(subQtId); printf(&quot;.&quot;); }
1913      }
1914    }
1915    TGnuPlot GP(OutFNm, TStr::Fmt(&quot;%d occurences, %d urls, %d domains: %s&quot;, Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(), Qt.QtStr.CStr()));
1916    TFltPrV HrFqV;
1917    for (int i = 0; i &lt; PlotQtV.Len(); i++) {
1918      const TQuote&amp; subQt = QuoteH.GetDat(PlotQtV[i]);
1919      subQt.GetSmoothFqOverTm(HrFqV, tmu1Hour);
1920      GP.AddPlot(HrFqV, gpwLines, subQt.QtStr.CStr());
1921    }
1922    GP.SetXYLabel(&quot;Time [hours]&quot;, &quot;Frequency&quot;);
1923    GP.SavePng(OutFNm+&quot;.png&quot;, -1, -1, &quot;&quot;, &quot;set terminal png small size 1000,800&quot;);
1924  }
1925  void TQuoteBs::PlotTopQuotesOverTm(const int&amp; StepSecs, const int&amp; IntervalSecs, const int&amp; TakeNPerStep, const TStr&amp; OutFNm) const {
1926    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1927    printf(&quot;Dataset span %s -- %s\n&quot;, MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1928    TIntSet TopQtIdSet;
1929    int cnt=0;
1930    TIntV TopQtIdV;
1931    for (TSecTm Tm(MinTm); Tm &lt; MaxTm; Tm += StepSecs, cnt++) {
1932      FailR(&quot;TopQuotesOverTm: take top quotes from each day&quot;);
1933      for (int q = 0; q &lt; TopQtIdV.Len(); q++) { TopQtIdSet.AddKey(TopQtIdV[q]); }
1934    }
1935    printf(&quot;\n%d time steps total, %d quotes per step: %d total quotes\n&quot;, cnt, TakeNPerStep, TopQtIdSet.Len());
1936    printf(&quot;%s   %d\n&quot;, MinTm.Round(tmuDay).GetStr().CStr(), MinTm.Round(tmuDay).GetInUnits(tmu1Hour));
1937    TFltPrV FqOverTm;
1938    TGnuPlot GP(TStr(&quot;topQtOverTm.&quot;)+OutFNm, &quot;&quot;);
1939    TFOut FOut(OutFNm+TStr(&quot;.Quote&quot;));
1940    for (int q = 0; q &lt; TopQtIdSet.Len(); q++) {
1941      const TQuote&amp; Q = QuoteH.GetDat(TopQtIdSet[q]);
1942      Q.Save(FOut);
1943      Q.GetSmoothFqOverTm(FqOverTm, tmu1Hour, MinTm.Round(tmuDay));
1944      GP.AddPlot(FqOverTm, gpwLines, Q.QtStr);
1945    }
1946    GP.AddCmd(&quot;set xtics 24&quot;); GP.AddCmd(&quot;set mxtics 4&quot;);
1947    GP.SetXYLabel(TStr(&quot;time [hours] from &quot;+MinTm.Round(tmuDay).GetStr()), &quot;frequency&quot;);
1948    GP.SavePng(TStr(&quot;topQtOverTm.&quot;)+OutFNm+TStr(&quot;.png&quot;), -1, -1, &quot;&quot;, &quot;set terminal png small size 2000,800&quot;);
1949  }
1950  PQuoteBs TQuoteBs::BuildQuoteBs(const TStr&amp; InBinFNmWc, const int&amp; MinQtWrdLen) {
1951    PQuoteBs QBsPt = TQuoteBs::New(InBinFNmWc);
1952    QBsPt-&gt;AddToQuoteBs(InBinFNmWc, MinQtWrdLen);
1953    return QBsPt;
1954  }
1955  #endif
1956  PClustNet TClustNet::GetSubGraph(const TIntV&amp; NIdV) const {
1957    PClustNet NewNetPt = TClustNet::New();
1958    TClustNet&amp; NewNet = *NewNetPt;
1959    NewNet.Reserve(NIdV.Len(), -1);
1960    int node, edge;
1961    TClustNet::TNodeI NI;
1962    for (node = 0; node &lt; NIdV.Len(); node++) {
1963      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
1964    }
1965    for (node = 0; node &lt; NIdV.Len(); node++) {
1966      NI = GetNI(NIdV[node]);
1967      const int SrcNId = NI.GetId();
1968      for (edge = 0; edge &lt; NI.GetOutDeg(); edge++) {
1969        const int OutNId = NI.GetOutNId(edge);
1970        if (NewNet.IsNode(OutNId)) {
1971          NewNet.AddEdge(SrcNId, OutNId); }
1972      }
1973    }
1974    NewNet.Defrag();
1975    return NewNetPt;
1976  }
1977  void TClustNet::AddLink(const TQuote&amp; SrcQt, const TQuote&amp; DstQt) {
1978    const int Qt1Id = SrcQt.GetCId();
1979    const int Qt2Id = DstQt.GetCId();
1980    if (! IsNode(Qt1Id)) {
1981      AddNode(Qt1Id, SrcQt); }
1982    if (! IsNode(Qt2Id)) {
1983      AddNode(Qt2Id, DstQt); }
1984    if (! IsEdge(Qt2Id, Qt1Id)) {
1985      AddEdge(Qt1Id, Qt2Id);
1986    }
1987  }
1988  PClustNet TClustNet::GetSubGraph(const int&amp; MinQtWords, const int&amp; MaxQtWords, const int&amp; MinFq) const {
1989    TIntV NIdV;
1990    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
1991      const int Wrds = TStrUtil::CountWords(NI().GetStr().CStr());
1992      if (NI().GetFq() &gt;= MinFq &amp;&amp;  Wrds &gt;= MinQtWords &amp;&amp; Wrds &lt;= MaxQtWords) {
1993        NIdV.Add(NI.GetId()); }
1994    }
1995    return GetSubGraph(NIdV);
1996  }
1997  void TClustNet::RecalcEdges(const double&amp; MinOverlapFrac) {
1998    printf(&quot;Recalculating edges...\n&quot;);
1999    TIntPrV DelEdgeV;
2000    TStrHash&lt;TInt&gt; StrH(Mega(1), true);
2001    int WIdV1Start, WIdV2Start, SkipTy;
2002    TIntV WIdV1, WIdV2;
2003    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2004      const TStr Q1 = NI().GetStr();
2005      TStrUtil::GetAddWIdV(StrH, Q1.CStr(), WIdV1);
2006      for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2007        const TStr Q2 = NI.GetOutNDat(e).GetStr();
2008        TStrUtil::GetAddWIdV(StrH, Q2.CStr(), WIdV2);
2009        const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, WIdV1Start, WIdV2Start, SkipTy);
2010        const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2011        const int LongLen = TMath::Mx(WIdV1.Len(), WIdV2.Len());
2012        IAssert(Overlap&lt;=ShortLen);
2013        if (2*ShortLen&gt;LongLen &amp;&amp; Overlap/double(ShortLen) &gt; MinOverlapFrac) { continue; }
2014        DelEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(e)));
2015      }
2016    }
2017    printf(&quot;Deleting %d/%d (%.4f) edges\n&quot;, DelEdgeV.Len(), GetEdges(), DelEdgeV.Len()/double(GetEdges()));
2018    for (int i = 0; i &lt; DelEdgeV.Len(); i++) {
2019      DelEdge(DelEdgeV[i].Val1, DelEdgeV[i].Val2);
2020    }
2021  }
2022  void TClustNet::MakeClusters(const TIntPrV&amp; KeepEdgeV) {
2023    PUNGraph G = TUNGraph::New();
2024    for (int e = 0; e &lt; KeepEdgeV.Len(); e++) {
2025      if (! G-&gt;IsNode(KeepEdgeV[e].Val1)) {
2026        G-&gt;AddNode(KeepEdgeV[e].Val1); }
2027      if (! G-&gt;IsNode(KeepEdgeV[e].Val2)) {
2028        G-&gt;AddNode(KeepEdgeV[e].Val2); }
2029      G-&gt;AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2030    }
2031    TCnComV CnComV;
2032    TSnap::GetWccs(G, CnComV);
2033    TIntH NIdCcIdH(GetNodes());
2034    for (int c = 0; c &lt; CnComV.Len(); c++) {
2035      const TIntV&amp; NIdV = CnComV[c].NIdV;
2036      for (int n = 0; n &lt; NIdV.Len(); n++) {
2037        NIdCcIdH.AddDat(NIdV[n], c);
2038      }
2039    }
2040    TIntPrV DelEdgeV;
2041    for (TEdgeI EI = BegEI(); EI &lt; EndEI(); EI++) {
2042      const int ccid1 = NIdCcIdH.IsKey(EI.GetSrcNId()) ? NIdCcIdH.GetDat(EI.GetSrcNId()).Val : -1;
2043      const int ccid2 = NIdCcIdH.IsKey(EI.GetDstNId()) ? NIdCcIdH.GetDat(EI.GetDstNId()).Val : -1;
2044      if (ccid1 != ccid2 &amp;&amp; ccid1!=-1 &amp;&amp; ccid2!=-1) {
2045        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
2046    }
2047    const int Edges = GetEdges();
2048    printf(&quot;Deleting %d out of %d  (%f) edges\n&quot;, DelEdgeV.Len(), Edges, DelEdgeV.Len()/double(Edges));
2049    for (int d = 0; d &lt; DelEdgeV.Len(); d++) {
2050      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2051    }
2052  }
2053  void TClustNet::KeepOnlyTree(const TIntPrV&amp; KeepEdgeV) {
2054    TIntPrSet EdgeSet(KeepEdgeV.Len());
2055    for (int i = 0; i &lt; KeepEdgeV.Len(); i++) {
2056      EdgeSet.AddKey(TIntPr(TMath::Mn(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2),
2057        TMath::Mx(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2)));
2058    }
2059    TIntPrSet DelEdgeV;
2060    for (TEdgeI EI = BegEI(); EI &lt; EndEI(); EI++) {
2061      const int N1 = TMath::Mn(EI.GetSrcNId(), EI.GetDstNId());
2062      const int N2 = TMath::Mx(EI.GetSrcNId(), EI.GetDstNId());
2063      if (! EdgeSet.IsKey(TIntPr(N1, N2))) {
2064        DelEdgeV.AddKey(TIntPr(N1, N2)); }
2065    }
2066    printf(&quot;deleting %d edges\n&quot;, DelEdgeV.Len());
2067    for (int d = 0; d &lt; DelEdgeV.Len(); d++) {
2068      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2069    }
2070  }
2071  void TClustNet::GetClusters(TVec&lt;TIntV&gt;&amp; QtNIdV) const {
2072    TCnComV CnComV;
2073    TSnap::GetWccs(GetThis(), CnComV);
2074    CnComV.Sort(false);
2075    QtNIdV.Clr(false);
2076    TIntSet SeenSet;
2077    for (int i = 0; i &lt; CnComV.Len(); i++) {
2078      for (int n = 0; n &lt; CnComV[i].NIdV.Len(); n++) {
2079        IAssert(! SeenSet.IsKey(CnComV[i].NIdV[n]));
2080        SeenSet.AddKey(CnComV[i].NIdV[n]);
2081      }
2082      QtNIdV.Add(CnComV[i].NIdV);
2083    }
2084  }
2085  void TClustNet::GetMergedClustQt(const TIntV&amp; QtIdV, TQuote&amp; NewQt) const {
2086    int CentrQtId=-1, MxFq=0;
2087    THash&lt;TPair&lt;TSecTm, TInt&gt;, TInt&gt; TmUrlCntH;
2088    for (int c = 0; c &lt; QtIdV.Len(); c++) {
2089      const TQuote&amp; Q = GetNDat(QtIdV[c]);
2090      IAssert(Q.GetId() == QtIdV[c]);
2091      for (int t = 0; t &lt; Q.GetTimes(); t++) {
2092        TmUrlCntH.AddDat(TPair&lt;TSecTm, TInt&gt;(Q.GetTm(t), Q.GetUrlId(t))) += Q.GetCnt(t);
2093      }
2094      if (MxFq &lt; Q.GetFq()) {
2095        MxFq = Q.GetFq();
2096        CentrQtId = Q.GetId();
2097      }
2098    }
2099    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
2100    NewQt.QtStr = GetNDat(CentrQtId).GetStr(); 
2101    NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
2102    for (int u = 0; u &lt; TmUrlCntH.Len(); u++) {
2103      NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
2104    }
2105    NewQt.TmUrlCntV.Sort();
2106  }
2107  int TClustNet::EvalPhraseClusters(const TIntPrV&amp; KeepEdgeV, const bool&amp; dump) const {
2108    PNGraph G = TNGraph::New();
2109    for (int e = 0; e &lt; KeepEdgeV.Len(); e++) {
2110      if (! G-&gt;IsNode(KeepEdgeV[e].Val1)) {
2111        G-&gt;AddNode(KeepEdgeV[e].Val1); }
2112      if (! G-&gt;IsNode(KeepEdgeV[e].Val2)) {
2113        G-&gt;AddNode(KeepEdgeV[e].Val2); }
2114      G-&gt;AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2115    }
2116    TCnComV CnComV;
2117    TSnap::GetWccs(G, CnComV);
2118    G = TSnap::ConvertGraph&lt;PNGraph&gt;(TPt&lt;TClustNet&gt;((TClustNet*) this));
2119    int TotEdges=0, EdgesInBigClust=0;
2120    int TotNodes=0, NodesInBigClust=0;
2121    int BigClust=0;
2122    for (int cc = 0; cc &lt; CnComV.Len(); cc++) {
2123      if (CnComV[cc].NIdV.Len() &lt; 3) { continue; }
2124      PNGraph CC = TSnap::GetSubGraph(G, CnComV[cc].NIdV);
2125      TotEdges += CC-&gt;GetEdges();
2126      TotNodes += CC-&gt;GetNodes()-1;
2127      if (CC-&gt;GetNodes() &gt; 10) {
2128        EdgesInBigClust += CC-&gt;GetEdges();
2129        NodesInBigClust += CC-&gt;GetNodes()-1;
2130        BigClust++;
2131      }
2132    }
2133    if (dump) {
2134      printf(&quot;                                all\tbig(&gt;10)\n&quot;);
2135      printf(&quot;  Number of clusters:           %d\t%d\n&quot;, CnComV.Len(), BigClust);
2136      printf(&quot;  Total edges inside clusters:  %d\t%d\n&quot;, TotEdges, TotEdges-TotNodes);
2137      printf(&quot;  Total edges deleted:          %d\t%d\n&quot;, GetEdges()-TotEdges, GetEdges()-TotEdges-TotNodes);
2138      printf(&quot;  Total edges in big clusters:  %d\t%d\n&quot;, EdgesInBigClust, EdgesInBigClust-NodesInBigClust);
2139    }
2140    return TotEdges-TotNodes;
2141  }
2142  void TClustNet::ClustKeepSingleEdge(const int&amp; MethodId) const {
2143    TIntPrV KeepEdgeV;
2144    ClustKeepSingleEdge(MethodId, KeepEdgeV);
2145  }
2146  void TClustNet::ClustKeepSingleEdge(const int&amp; MethodId, TIntPrV&amp; KeepEdgeV) const {
2147    PNGraph G = TSnap::ConvertGraph&lt;PNGraph&gt;(TPt&lt;TClustNet&gt;((TClustNet*) this));
2148    KeepEdgeV.Clr(false);
2149    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2150      IAssert(NI.GetId() == NI().GetId());
2151      int EdgeToKeep = -1, BestVal=0;
2152      for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2153        if (MethodId==1 &amp;&amp; NI.GetOutNDat(e).GetFq() &gt; BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetFq(); }
2154        if (MethodId==2 &amp;&amp; NI.GetOutNDat(e).GetStr().Len() &gt; BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2155        if (MethodId==3 &amp;&amp; NI.GetOutNDat(e).GetStr().Len() &lt; BestVal ||BestVal==0) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2156      }
2157      if (MethodId==4 &amp;&amp; NI.GetOutDeg()&gt;0) {
2158        EdgeToKeep = TInt::Rnd.GetUniDevInt(NI.GetOutDeg()); }
2159      if (EdgeToKeep!=-1) {
2160        KeepEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(EdgeToKeep))); }
2161    }
2162    if (MethodId==1) { printf(&quot;Keep edge to most frequent quote:\n&quot;); }
2163    if (MethodId==2) { printf(&quot;Keep edge to longest quote:\n&quot;); }
2164    if (MethodId==3) { printf(&quot;Keep edge to shortest quote:\n&quot;); }
2165    if (MethodId==4) { printf(&quot;Keep random edge:\n&quot;); }
2166    EvalPhraseClusters(KeepEdgeV);
2167  }
2168  void TClustNet::ClustGreedyTopDown() const {
2169    TIntPrV KeepEdgeV;
2170    ClustGreedyTopDown(KeepEdgeV);
2171  }
2172  void TClustNet::ClustGreedyTopDown(TIntPrV&amp; KeepEdgeV) const {
2173    TIntH NIdOutDegH;
2174    TIntH NIdClustH;
2175    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2176      NIdOutDegH.AddDat(NI.GetId(), NI.GetOutDeg());
2177      if (NI.GetOutDeg() == 0) {
2178        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2179    }
2180    printf(&quot;%d root nodes\n&quot;, NIdClustH.Len());
2181    printf(&quot;%d nodes\n&quot;, NIdOutDegH.Len());
2182    NIdOutDegH.SortByDat(true);
2183    THash&lt;TInt, TIntPr&gt; ClustCntH;
2184    KeepEdgeV.Clr(false);
2185    while (NIdOutDegH.Len() &gt; 0 &amp;&amp; NIdOutDegH[0] == 0) {
2186      for (int i = 0; i &lt; NIdOutDegH.Len() &amp;&amp; NIdOutDegH[i] == 0; i++) {
2187        IAssert(IsNode(NIdOutDegH.GetKey(i)));
2188        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2189        for (int e = 0; e &lt; NI.GetInDeg(); e++) {
2190          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2191        ClustCntH.Clr(false);
2192        for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2193          IAssert(NIdClustH.IsKey(NI.GetOutNId(e)));
2194          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1; 
2195          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2196        }
2197        ClustCntH.SortByDat(false);
2198        if (ClustCntH.Len() &gt; 0) {
2199          const int NId = NI.GetId();
2200          const int NId2 = ClustCntH[0].Val2;
2201          const int CId = NIdClustH.GetDat(NId2);
2202          KeepEdgeV.Add(TIntPr(NId, NId2)); 
2203          NIdClustH.AddDat(NId, CId); 
2204        }
2205        NIdOutDegH[i] = TInt::Mx;
2206      }
2207      NIdOutDegH.SortByDat(true);
2208    }
2209    printf(&quot;Greedy top down approach:\n&quot;);
2210    EvalPhraseClusters(KeepEdgeV);
2211  }
2212  void TClustNet::ClustGreedyRandom() const {
2213    printf(&quot;Greedy random:\n&quot;);
2214    THash&lt;TInt, TIntV&gt; OutNIdV;
2215    THash&lt;TInt, TInt&gt; EdgeH;
2216    TIntPrV KeepEdgeV;
2217    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2218      if (NI.GetOutDeg() &gt; 0) {
2219        EdgeH.AddDat(NI.GetId()) = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg()));
2220        if (NI.GetOutDeg() &gt; 1) {
2221          for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2222            OutNIdV.AddDat(NI.GetId()).Add(NI.GetOutNId(e)); }
2223        }
2224      }
2225    }
2226    { TIntH NIdOutDegH;
2227    TIntH NIdClustH;
2228    for (TNodeI NI = BegNI(); NI &lt; EndNI(); NI++) {
2229      NIdOutDegH.AddDat(NI.GetId()) = NI.GetOutDeg();
2230      if (NI.GetOutDeg() == 0) {
2231        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2232    }
2233    NIdOutDegH.SortByDat(true);
2234    THash&lt;TInt, TIntPr&gt; ClustCntH;
2235    while (NIdOutDegH.Len() &gt; 0 &amp;&amp; NIdOutDegH[0] == 0) {
2236      for (int i = 0; i &lt; NIdOutDegH.Len() &amp;&amp; NIdOutDegH[i] == 0; i++) {
2237        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2238        for (int e = 0; e &lt; NI.GetInDeg(); e++) {
2239          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2240        ClustCntH.Clr(false);
2241        for (int e = 0; e &lt; NI.GetOutDeg(); e++) {
2242          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1;
2243          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2244        }
2245        ClustCntH.SortByDat(false);
2246        if (ClustCntH.Len() &gt; 0) {
2247          KeepEdgeV.Add(TIntPr(NI.GetId(), ClustCntH[0].Val2));
2248        }
2249        NIdOutDegH[i] = TInt::Mx;
2250      }
2251      NIdOutDegH.SortByDat(true);
2252    } }
2253    printf(&quot;%d\n&quot;, EdgeH.Len());
2254    for (int e = 0; e &lt; KeepEdgeV.Len(); e++) {
2255      EdgeH.AddDat(KeepEdgeV[e].Val1) = KeepEdgeV[e].Val2;
2256    }
2257    printf(&quot;%d\n&quot;, EdgeH.Len());
2258    EdgeH.GetKeyDatPrV(KeepEdgeV);
2259    int CurScore = EvalPhraseClusters(KeepEdgeV);
2260    while (true) {
2261        const int RndNId = OutNIdV.GetKey(TInt::Rnd.GetUniDevInt(OutNIdV.Len()));
2262        const int RndEdge = OutNIdV.GetDat(RndNId)[TInt::Rnd.GetUniDevInt(OutNIdV.GetDat(RndNId).Len())];
2263        const int id = EdgeH.GetKeyId(RndNId);  IAssert(KeepEdgeV[id].Val1 == RndNId);
2264        if (KeepEdgeV[id].Val2 == RndEdge) { continue; } 
2265        const int OldE = KeepEdgeV[id].Val2;
2266        KeepEdgeV[id].Val2 = RndEdge;
2267      const int NewScore = EvalPhraseClusters(KeepEdgeV, false);
2268      if (NewScore &gt; CurScore &amp;bsol;*|| TInt::Rnd.GetUniDev() &lt; 0.1*/) {
2269        printf(&quot;%6d --&gt; %6d\n&quot;, CurScore, NewScore);
2270        CurScore = NewScore;
2271      }
2272      else {  KeepEdgeV[id].Val2 = OldE; } 
2273    }
2274  }
2275  TChA InsertLineBreaks(const TChA&amp; ChA, const int&amp; BreakAtPost) {
2276    TChA Tmp = ChA, Out;
2277    int Lines = 1;
2278    TVec&lt;char*&gt; WrdV;
2279    TStrUtil::SplitWords(Tmp, WrdV);
2280    for (int w = 0; w &lt; WrdV.Len(); w++) {
2281      if (Out.Len() + (int)strlen(WrdV[w]) &gt; Lines*BreakAtPost) {
2282        Lines++; Out+=&quot;\\n&quot;; }
2283      Out += WrdV[w];
2284      Out += &quot; &quot;;
2285    }
2286    return Out;
2287  }
2288  void TClustNet::DrawNet(const TStr&amp; OutFNm, const int&amp; SaveTopN) const {
2289    TCnComV CnComV;
2290    TSnap::GetWccs(GetThis(), CnComV);
2291    CnComV.Sort(false);
2292    for (int Comp = 0; Comp&lt;TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2293      if (CnComV[Comp].Len() &lt; 5) { continue; }
2294      TPt&lt;TNet&gt; SubNet = TSnap::GetSubGraph(TPt&lt;TNet&gt;((TClustNet*) this), CnComV[Comp].NIdV);
2295      printf(&quot;draw: %d nodes, %d edges\n&quot;, SubNet-&gt;GetNodes(), SubNet-&gt;GetEdges());
2296      FILE *F = fopen(TStr::Fmt(&quot;%s-c%02d.dot&quot;, OutFNm.CStr(), Comp).CStr(), &quot;wt&quot;);
2297      fprintf(F, &quot;digraph G { &amp;bsol;*%d nodes, %d edges*/\n&quot;, SubNet-&gt;GetNodes(), SubNet-&gt;GetEdges());
2298      fprintf(F, &quot;  graph [splines=true overlap=false rankdir=LR]\n&quot;);
2299      fprintf(F, &quot;  node  [shape=box, fontsize=14]\n&quot;);
2300      for (TNet::TNodeI NI = SubNet-&gt;BegNI(); NI &lt; SubNet-&gt;EndNI(); NI++) {
2301        fprintf(F, &quot;  %d [label=\&quot;%s (%d, %d)\&quot;];\n&quot;, NI.GetId(), InsertLineBreaks(NI().GetStr(), 80).CStr(), NI().GetFq(), NI().GetUrls());
2302      }
2303      for (TNet::TEdgeI EI = SubNet-&gt;BegEI(); EI &lt; SubNet-&gt;EndEI(); EI++) {
2304        fprintf(F, &quot;  %d -&gt; %d;\n&quot;, EI.GetSrcNId(), EI.GetDstNId());
2305      }
2306      fprintf(F, &quot;}\n&quot;);
2307      fclose(F);
2308      TGraphViz::DoLayout(TStr::Fmt(&quot;%s-c%02d.dot&quot;, OutFNm.CStr(), Comp), TStr::Fmt(&quot;%s-c%02d.ps&quot;, OutFNm.CStr(), Comp), gvlDot);
2309      TSnap::SavePajek(SubNet, TStr::Fmt(&quot;%s-c%02d.net&quot;, OutFNm.CStr(), Comp));
2310    }
2311  }
2312  void TClustNet::DumpNodes(const TStr&amp; OutFNm, const int&amp; SaveTopN) const {
2313    TIntV NIdV;  GetNIdV(NIdV);
2314    TIntH NIdCompSzH;
2315    { TCnComV CnComV;
2316    TSnap::GetWccs(GetThis(), CnComV);
2317    for (int c = 0; c &lt; CnComV.Len(); c++) {
2318      for (int n = 0; n &lt; CnComV[c].NIdV.Len(); n++) {
2319        NIdCompSzH.AddDat(CnComV[c].NIdV[n], CnComV[c].Len());
2320      }
2321    } }
2322    TIntPrV FqNIdV;
2323    for (int n = 0; n &lt; NIdV.Len(); n++) {
2324      FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2325    }
2326    FqNIdV.Sort(false);
2327    FILE *F = fopen(TStr::Fmt(&quot;nodes-%s.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
2328    fprintf(F, &quot;#Freq\tClustSz\tQuote\n&quot;);
2329    for (int i = 0; i &lt; FqNIdV.Len(); i++) {
2330      const TQuote&amp; Q = GetNDat(FqNIdV[i].Val2);
2331      fprintf(F, &quot;%d\t%d\t%s\n&quot;, Q.GetFq(), NIdCompSzH.GetDat(FqNIdV[i].Val2).Val, Q.GetStr().CStr());
2332    }
2333  }
2334  void TClustNet::DumpClusters(const TStr&amp; OutFNm, int SaveTopN) const {
2335    TCnComV CnComV;
2336    TSnap::GetWccs(GetThis(), CnComV); 
2337    CnComV.Sort(false);
2338    FILE *F = fopen(TStr::Fmt(&quot;clust-%s.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
2339    if (SaveTopN==-1) { SaveTopN=TInt::Mx; }
2340    for (int Comp = 0; Comp&lt;TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2341      const TIntV&amp; NIdV = CnComV[Comp].NIdV;
2342      TIntPrV FqNIdV;
2343      int SumFq=0;
2344      for (int n = 0; n &lt; NIdV.Len(); n++) {
2345        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2346        SumFq += GetNDat(NIdV[n]).GetFq();
2347      }
2348      FqNIdV.Sort(false);
2349      fprintf(F, &quot;%d quotes, total freq %d\n&quot;, FqNIdV.Len(), SumFq);
2350      for (int i = 0; i &lt; FqNIdV.Len(); i++) {
2351        const TQuote&amp; Q = GetNDat(FqNIdV[i].Val2);
2352        fprintf(F, &quot;%d\t%s\n&quot;, Q.GetFq(), Q.GetStr().CStr());
2353      }
2354      fprintf(F, &quot;\n&quot;);
2355    }
2356  }
2357  void TClustNet::DumpClustersByVol(const TStr&amp; OutFNm, const int&amp; MinClustSz, const int&amp; MinVolume) const {
2358    TCnComV CnComV;
2359    TSnap::GetWccs(GetThis(), CnComV);
2360    CnComV.Sort(false);
2361    TIntPrV FqClustV;
2362    TIntH ClSzH, ClFqH;
2363    int FqMore1k=0;
2364    for (int Comp = 0; Comp &lt; CnComV.Len(); Comp++) {
2365      const TIntV&amp; NIdV = CnComV[Comp].NIdV;
2366      if (NIdV.Len() &lt; MinClustSz) { continue; } 
2367      int SumFq=0;
2368      for (int n = 0; n &lt; NIdV.Len(); n++) {
2369        SumFq += GetNDat(NIdV[n]).GetFq(); }
2370      FqClustV.Add(TIntPr(SumFq, Comp));
2371      ClFqH.AddDat(SumFq) += 1;
2372      ClSzH.AddDat(NIdV.Len()) += 1;
2373      if (SumFq&gt;500) { FqMore1k++; }
2374    }
2375    FqClustV.Sort(false);
2376    FILE *F = fopen(TStr::Fmt(&quot;clustFq-%s.txt&quot;, OutFNm.CStr()).CStr(), &quot;wt&quot;);
2377    fprintf(F, &quot;Cluster network:\n%d nodes\n%d edges\n%d clusters\n%d big clusters (&gt;=%d)\n&quot;,
2378      GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz);
2379    for (int c = 0; c &lt; FqClustV.Len(); c++) {
2380      const TIntV&amp; NIdV = CnComV[FqClustV[c].Val2].NIdV;
2381      TIntPrV FqNIdV;
2382      int SumFq=0;
2383      for (int n = 0; n &lt; NIdV.Len(); n++) {
2384        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2385        SumFq += GetNDat(NIdV[n]).GetFq();
2386      }
2387      if (SumFq &lt; MinVolume) { continue; }
2388      FqNIdV.Sort(false);
2389      fprintf(F, &quot;%d\t%d items\t%d totFq\n&quot;, c, FqNIdV.Len(), SumFq);
2390      for (int i = 0; i &lt; FqNIdV.Len(); i++) {
2391        const TQuote&amp; Q = GetNDat(FqNIdV[i].Val2);
2392        fprintf(F, &quot;\t%d\t%s\n&quot;, Q.GetFq(), Q.GetStr().CStr());
2393      }
2394      fprintf(F, &quot;\n&quot;);
2395    }
2396    TGnuPlot::PlotValCntH(ClFqH, &quot;clVol.&quot;+OutFNm, TStr::Fmt(&quot;%s. %d nodes, %d edges, %d clusters, %d big clusters (&gt;=%d), %d with vol&gt;500&quot;,
2397      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), &quot;Cluster volume&quot;, &quot;Count&quot;, gpsLog);
2398    TGnuPlot::PlotValCntH(ClSzH, &quot;clSz.&quot;+OutFNm, TStr::Fmt(&quot;%s. %d nodes, %d edges, %d clusters, %d big clusters (&gt;=%d), %d with vol&gt;500&quot;,
2399      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), &quot;Cluster size&quot;, &quot;Count&quot;, gpsLog);
2400  }
2401  void BuildPhraseInvertIdx(const PQuoteBs&amp; QtBs, TStrHash&lt;TInt&gt;&amp; WordIdH, THash&lt;TInt, TIntV&gt;&amp; WIdQtIdVH) {
2402    printf(&quot;build quote word inverted index\n&quot;);
2403    TIntV WIdV;
2404    TIntSet WIdSet;
2405    for (int q = 0; q &lt; QtBs-&gt;Len(); q++) {
2406      const TQuote&amp; Q = QtBs-&gt;GetQtN(q);
2407      TStrUtil::GetAddWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2408      const int Doms = Q.GetDoms(*QtBs);
2409      if (! (Doms&gt;1 &amp;&amp; Doms*4 &gt; Q.GetUrls() &amp;&amp; Q.GetFq() &gt;= 5)) { 
2410        continue;
2411      }
2412      WIdSet.Clr(false); 
2413      for (int w = 0; w &lt; WIdV.Len(); w++) {
2414        WIdSet.AddKey(WIdV[w]);
2415      }
2416      for (int w = 0; w &lt; WIdSet.Len(); w++) {
2417        WIdQtIdVH.AddDat(WIdSet[w]).Add(q);
2418      }
2419    }
2420    for (int i = 0; i &lt; WIdQtIdVH.Len(); i++) {
2421      WIdQtIdVH[i].Pack();
2422    }
2423    printf(&quot;done.\n&quot;);
2424  }
2425  bool IsLinkPhrases(const PQuoteBs&amp; QtBs, const int&amp; QtN1, const int&amp; QtN2, TStrHash&lt;TInt&gt;&amp; WordIdH, THash&lt;TInt, TIntV&gt;&amp; QtToWordIdVH) {
2426    if (! QtToWordIdVH.IsKey(QtN1)) {
2427      TIntV WIdV;
2428      TStrUtil::GetWIdV(WordIdH, QtBs-&gt;GetQtN(QtN1).GetStr().CStr(), WIdV);
2429      WIdV.Pack();
2430      QtToWordIdVH.AddDat(QtN1, WIdV);
2431    }
2432    if (! QtToWordIdVH.IsKey(QtN2)) {
2433      TIntV WIdV;
2434      TStrUtil::GetWIdV(WordIdH, QtBs-&gt;GetQtN(QtN2).GetStr().CStr(), WIdV);
2435      WIdV.Pack();
2436      QtToWordIdVH.AddDat(QtN2, WIdV);
2437    }
2438    int idx1=0, idx2=0, SkipTy=0;
2439    const TIntV&amp; WIdV1 = QtToWordIdVH.GetDat(QtN1);
2440    const TIntV&amp; WIdV2 = QtToWordIdVH.GetDat(QtN2);
2441    const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2442    const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, idx1, idx2, SkipTy);
2443    bool DoMerge = false;
2444    if (ShortLen &lt;= 5 &amp;&amp; Overlap == ShortLen &amp;bsol;*&amp;&amp; SkipTy==0*/) { DoMerge=true; } 
2445    else if ((ShortLen == 6 &amp;&amp; Overlap &gt;= 5 &amp;bsol;*&amp;&amp; SkipTy==0) || (ShortLen == 6 &amp;&amp; Overlap == 5*/)) { DoMerge=true; }
2446    else if (Overlap/double(ShortLen+3) &gt; 0.5 || Overlap &gt; 10) { DoMerge=true; }
2447    return DoMerge;
2448  }
2449  PClustNet TClustNet::GetFromQtBs(const PQuoteBs&amp; QtBs, int MinQtFq, int MnWrdLen) {
2450    TStrHash&lt;TInt&gt; WordIdH;
2451    THash&lt;TInt, TIntV&gt; WIdQtIdVH; 
2452    BuildPhraseInvertIdx(QtBs, WordIdH, WIdQtIdVH);
2453    PClustNet Net = TClustNet::New();
2454    TVec&lt;int&gt; QtSharCnt(QtBs-&gt;Len()), QtWrdLen(QtBs-&gt;Len());
2455    THash&lt;TInt, TIntV&gt; QtToWordIdVH;   
2456    TIntV WIdV;
2457    TIntH CandLenH, LinkLenH;
2458    THash&lt;TInt, TIntH&gt; QtLenCandH, QtLenLinkH;
2459    int AllCand=0, AllLinks=0;
2460    TExeTm ExeTm;
2461    for (int qt = 0; qt &lt; QtBs-&gt;Len(); qt++) {
2462      QtWrdLen[qt] = TStrUtil::CountWords(QtBs-&gt;GetQtN(qt).GetStr().CStr());
2463    }
2464    const int QtBsLen = QtBs-&gt;Len();
2465    for (int qt = 0; qt &lt; QtBs-&gt;Len(); qt++) {
2466      const TQuote&amp; Q = QtBs-&gt;GetQtN(qt);
2467      const int Doms = Q.GetDoms(*QtBs);
2468    if (! (Doms&gt;1 &amp;&amp; Doms*4 &gt; Q.GetUrls() &amp;&amp; Q.GetFq() &gt;= MinQtFq &amp;&amp;
2469      TStrUtil::CountWords(Q.GetStr())&gt;=MnWrdLen)) {
2470        continue; }
2471      memset(QtSharCnt.BegI(), 0, sizeof(int)*QtSharCnt.Len());
2472      TStrUtil::GetWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2473      if (! QtToWordIdVH.IsKey(qt)) {
2474        WIdV.Pack();
2475        QtToWordIdVH.AddDat(qt, WIdV);
2476      }
2477      for (int w = 0; w &lt; WIdV.Len(); w++) {
2478        IAssert(WIdQtIdVH.IsKey(WIdV[w]));
2479        const TIntV&amp; QtIdV = WIdQtIdVH.GetDat(WIdV[w]);
2480        for (int q = 0; q &lt; QtIdV.Len(); q++) {
2481          QtSharCnt[QtIdV[q]] += 1;
2482        }
2483      }
2484      const int W = WIdV.Len();
2485      int Candidates = 0, Links = 0, MinSharedWords = W-3;
2486      if (W &lt;= 5) { MinSharedWords = W-1; }
2487      else if (W &lt;= 10) { MinSharedWords = W-2; }
2488      for (int q = 0; q &lt; QtSharCnt.Len(); q++) {
2489        if (QtSharCnt[q] &gt;= MinSharedWords &amp;&amp; (QtWrdLen[q] &gt;= W || QtWrdLen[q] &gt; 20)) {
2490          const TQuote&amp; Qt2 = QtBs-&gt;GetQtN(q);
2491          if (Doms&gt;1 &amp;&amp; Doms*4 &gt; Q.GetUrls() &amp;&amp; Q.GetFq() &gt;= MinQtFq) { 
2492            if (IsLinkPhrases(QtBs, qt, q, WordIdH, QtToWordIdVH)) {    
2493              Net-&gt;AddLink(Q, Qt2);
2494              Links++;
2495            }
2496          }
2497          Candidates++;
2498        }
2499      }
2500      AllCand += Candidates;
2501      AllLinks += Links;
2502      CandLenH.AddDat(Candidates) += 1;
2503      LinkLenH.AddDat(Links) += 1;
2504      if (W &lt; 21) {
2505        QtLenCandH.AddDat(W).AddDat(Candidates) += 1;
2506        QtLenLinkH.AddDat(W).AddDat(Links) += 1;
2507      }
2508      if (qt % 1000 == 0 || qt==QtBsLen-1) {
2509        printf(&quot;\r%d  %s    allCands: %d    allLinks: %d    nodes:%d&quot;, qt, ExeTm.GetStr(), AllCand, AllLinks, Net-&gt;GetNodes());
2510        if (qt % 100000 == 0 || qt==QtBsLen-1) {
2511          TGnuPlot::PlotValCntH(CandLenH, &quot;qtNet-NCand&quot;, &quot;Number of candidate links for each quote (candidate has at most 2*words)&quot;,
2512            &quot;ClustNet: number of candidate quotes to create link to&quot;, &quot;Count&quot;, gpsLog);
2513          TGnuPlot::PlotValCntH(LinkLenH, &quot;qtNet-NLink&quot;, &quot;Number of links for each quote (candidate has at most 2*words)&quot;,
2514            &quot;ClustNet: number of out-links of a quote&quot;, &quot;Count&quot;, gpsLog);
2515        }
2516      }
2517    }
2518    printf(&quot;done.\n&quot;);
2519    TGnuPlot::PlotValCntH(CandLenH, &quot;qtNet-NCand&quot;, &quot;Number of candidate links for each quote (candidate has at most 2*words)&quot;,
2520      &quot;ClustNet: number of candidate quotes to create link to&quot;, &quot;Count&quot;, gpsLog);
2521    TGnuPlot::PlotValCntH(LinkLenH, &quot;qtNet-NLink&quot;, &quot;Number of links for each quote (candidate has at most 2*words)&quot;,
2522      &quot;ClustNet: number of out-links of a quote&quot;, &quot;Count&quot;, gpsLog);
2523    return Net;
2524  }
2525  void TQuoteLoader::Clr() {
2526    PostTitleStr.Clr();
2527    PostUrlStr.Clr();
2528    PubTm = TSecTm();
2529    BlogUrlStr.Clr();
2530    BlogTitleStr.Clr();
2531    ContentStr.Clr();
2532    QuoteV.Clr(false);
2533    LinkV.Clr(false);
2534  }
2535  bool TQuoteLoader::LoadItem(TXmlLx&amp; XmlLx) {
2536    static const TSecTm BegOfTm(2008,8,30, 0, 0, 0);
2537    Clr();
2538    try {
2539      EAssert(XmlLx.TagNm == &quot;post&quot;);
2540      const TChA T = TStrUtil::GetXmlTagVal(XmlLx, &quot;pubDate&quot;);
2541      PubTm = TSecTm(atoi(T.GetSubStr(0,3).CStr()), atoi(T.GetSubStr(5,6).CStr()), atoi(T.GetSubStr(8,9).CStr()),
2542        atoi(T.GetSubStr(11,12).CStr()), atoi(T.GetSubStr(14,15).CStr()), atoi(T.GetSubStr(17,18).CStr()));
2543      EAssert(PubTm &gt; BegOfTm);
2544      PostUrlStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;postUrl&quot;);
2545      PostTitleStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;postTitle&quot;);
2546      BlogUrlStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;blogUrl&quot;);
2547      BlogTitleStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;blogTitle&quot;);
2548      ContentStr = TStrUtil::GetXmlTagVal(XmlLx, &quot;content&quot;);
2549      while (XmlLx.GetSym()==xsySTag &amp;&amp; XmlLx.TagNm==&quot;q&quot;) {
2550        EAssert(XmlLx.GetSym() == xsyStr);
2551        QuoteV.Add(XmlLx.TxtChA);
2552        EAssert(XmlLx.GetSym() == xsyETag &amp;&amp; XmlLx.TagNm==&quot;q&quot;);
2553      }
2554    }
2555    catch (PExcept Except){
2556      ErrNotify(Except-&gt;GetStr());
2557      Fail;  return false;
2558    }
2559    return true;
2560  }
2561  void TQuoteLoader::Save(TSOut&amp; SOut) const {
2562    PubTm.Save(SOut);
2563    PostUrlStr.Save(SOut);
2564    PostTitleStr.Save(SOut);
2565    BlogUrlStr.Save(SOut);
2566    BlogTitleStr.Save(SOut);
2567    ContentStr.Save(SOut);
2568    QuoteV.Save(SOut);
2569    LinkV.Save(SOut);
2570  }
2571  void TQuoteLoader::Load(TSIn&amp; SIn) {
2572    PubTm.Load(SIn);
2573    PostUrlStr.Load(SIn);
2574    PostTitleStr.Load(SIn);
2575    BlogUrlStr.Load(SIn);
2576    BlogTitleStr.Load(SIn);
2577    ContentStr.Load(SIn);
2578    QuoteV.Load(SIn);
2579    LinkV.Load(SIn);
2580  }
2581  bool TQuoteLoader::Next() {
2582    if (SIn.Empty() || SIn-&gt;Eof()) {
2583      printf(&quot;  new file&quot;);
2584      if (! FFile.Next(CurFNm)) { return false; }
2585      printf(&quot; %s\n&quot;, CurFNm.GetFMid().CStr());
2586      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2587      StartProcFile(CurFNm);
2588    }
2589    Load(*SIn);
2590    if (++PostCnt % Kilo(10) == 0) { printf(&quot;\r  %dk [%s]  &quot;, PostCnt/Kilo(1), ExeTm.GetStr()); }
2591    return true;
2592  }
2593  void TQuoteLoader::ProcessPosts(const bool&amp; IsXml, int LoadN) {
2594    TExeTm ExeTm, TotalTm;
2595    StartProcess();
2596    if (LoadN &lt; 0) { LoadN = TInt::Mx; }
2597    int FilePostCnt=0;
2598    for (int f = 1; FFile.Next(CurFNm); f++) {
2599      printf(&quot;*** FILE:  %s\n&quot;, CurFNm.GetFMid().CStr());
2600      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2601      if (IsXml) {
2602        TXmlLx XmlLx(SIn, xspTruncate);
2603        StartProcFile(CurFNm);
2604        for (FilePostCnt=0; XmlLx.GetSym() != xsyEof; FilePostCnt++, PostCnt++) {
2605          if (! (XmlLx.Sym==xsySTag &amp;&amp; XmlLx.TagNm==&quot;post&quot;)) {
2606            while (XmlLx.GetSym()!=xsyEof &amp;&amp; ! (XmlLx.Sym==xsySTag &amp;&amp; XmlLx.TagNm==&quot;post&quot;)) { }
2607            if (XmlLx.Sym == xsyEof) { break; }
2608          }
2609          const bool IsGoodPost = LoadItem(XmlLx);
2610          ProcessPost(IsGoodPost);
2611          if (PostCnt % Kilo(1) == 0) {
2612            printf(&quot;\r%dk [%s] &quot;, PostCnt/Kilo(1), ExeTm.GetStr()); }
2613          if (PostCnt &gt;= LoadN) { break; }
2614        }
2615      } else {
2616        FilePostCnt = 0;
2617        while (! SIn-&gt;Eof()) {
2618          Load(*SIn);  FilePostCnt++;  PostCnt++;
2619          ProcessPost(true);
2620          if (PostCnt % Kilo(10) == 0) {
2621            printf(&quot;\r%dk [%s] &quot;, PostCnt/Kilo(1), ExeTm.GetStr()); }
2622          if (PostCnt &gt;= LoadN) { break; }
2623        }
2624      }
2625      printf(&quot;\n================================================================\n&quot;);
2626      printf(&quot;  file:  %s\n&quot;, CurFNm.GetFMid().CStr());
2627      printf(&quot;  time:  %s   &quot;, ExeTm.GetStr());
2628      printf(&quot;total: %s [%s]\n&quot;, TotalTm.GetStr(), TExeTm::GetCurTm());
2629      printf(&quot;  posts: %d   total: %d\n&quot;, FilePostCnt, PostCnt);
2630      EndProcFile(CurFNm);
2631      fflush(stdout);  ExeTm.Tick();
2632      if (PostCnt &gt;= LoadN) { break; }
2633    }
2634    EndProcess(PostCnt);
2635  }
2636  bool TMemesDataLoader::GetNextFile() {
2637    TStr FNm;
2638    if (! FFile.Empty()) {
2639      if (! FFile-&gt;Next(FNm)) { return false; }
2640      printf(&quot;NEXT-FL:  %s :\t%s\n&quot;, FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2641    } else {
2642      IAssert(! InFNmF.Empty());
2643      if (InFNmF-&gt;Eof()) { return false; }
2644    while (! InFNmF-&gt;Eof() &amp;&amp; InFNmF-&gt;GetNextLn(FNm) &amp;&amp; FNm.Empty()) { }
2645      printf(&quot;NEXT-LN:  %s :\t%s\n&quot;, FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2646    }
2647    if (FNm.Empty()) { return false; }
2648    if (TZipIn::IsZipExt(FNm.GetFExt())) {
2649      SInPt = TZipIn::New(FNm); }
2650    else {
2651      SInPt = TFIn::New(FNm); }  LineCnt = 0;
2652    return true;
2653  }
2654  void TMemesDataLoader::Clr() {
2655    PostUrlStr.Clr();
2656    ContentStr.Clr();
2657    PubTm = TSecTm();
2658    MemeV.Clr(false);
2659    MemePosV.Clr(false);
2660    LinkV.Clr(false);
2661    LinkPosV.Clr(false);
2662  }
2663  bool TMemesDataLoader::LoadNext() {
2664    Clr();
2665    if (SInPt.Empty() || SInPt-&gt;Eof()) {
2666      if (! GetNextFile()) { return false; }
2667    }
2668    TSIn&amp; SIn = *SInPt;
2669    CurLn.Clr();
2670    while (SIn.GetNextLn(CurLn) &amp;&amp; (CurLn.Empty() || (CurLn[0]!=&#x27;U&#x27; || CurLn[1]!=&#x27;\t&#x27;))) { 
2671      printf(&quot;L: %s\n&quot;, CurLn.CStr()); LineCnt++; }
2672    LineCnt++;
2673    if (CurLn.Empty()) { return LoadNext(); }
2674    IAssertR((! CurLn.Empty()) &amp;&amp; CurLn[0]==&#x27;U&#x27; &amp;&amp; CurLn[1]==&#x27;\t&#x27;, 
2675      TStr::Fmt(&quot;ERROR1: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());
2676    PostUrlStr = CurLn.CStr()+2;
2677    while (SIn.GetNextLn(CurLn) &amp;&amp; (CurLn.Empty() || (CurLn[0]!=&#x27;D&#x27; || CurLn[1]!=&#x27;\t&#x27;))) { LineCnt++; }
2678    IAssertR((! CurLn.Empty()) &amp;&amp; CurLn[0]==&#x27;D&#x27;, 
2679      TStr::Fmt(&quot;ERROR2: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2680    try {
2681      PubTm = TSecTm::GetDtTmFromStr(CurLn);
2682    } catch (PExcept Except){ PubTm = 1; ErrNotify(Except-&gt;GetStr());
2683      printf(&quot;ERROR3: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()); 
2684    }
2685    IAssertR(SIn.GetNextLn(CurLn) &amp;&amp; (! CurLn.Empty()) &amp;&amp; (CurLn[0]==&#x27;C&#x27; || CurLn[0]==&#x27;T&#x27;), 
2686      TStr::Fmt(&quot;ERROR4: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2687    if (CurLn[0] == &#x27;T&#x27;) { 
2688      IAssertR(SIn.GetNextLn(CurLn) &amp;&amp; (! CurLn.Empty()) &amp;&amp; CurLn[0]==&#x27;C&#x27;, 
2689        TStr::Fmt(&quot;ERROR5: %s [line %llu]: &#x27;%s&#x27;\n&quot;, SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++; }
2690    ContentStr = CurLn.CStr()+2;
2691    while (SIn.GetNextLn(CurLn)) {  LineCnt++;
2692      if (CurLn.Empty() || CurLn[0]!=&#x27;L&#x27;) { break; }
2693      int linkb=2;
2694      while (CurLn[linkb]!=&#x27;\t&#x27;) { linkb++; }
2695      CurLn[linkb]=0;
2696      LinkV.Add(CurLn.CStr()+linkb+1);
2697      LinkPosV.Add(atoi(CurLn.CStr()+2));
2698    }
2699    do {
2700      if (CurLn.Empty() || CurLn[0]!=&#x27;Q&#x27;) { break; }
2701      int qb1=2;      while (CurLn[qb1]!=&#x27;\t&#x27;) { qb1++; }
2702      int qb2=qb1+1;  while (CurLn[qb2]!=&#x27;\t&#x27;) { qb2++; }
2703      CurLn[qb1]=0;  CurLn[qb2]=0;
2704      MemeV.Add(CurLn.CStr()+qb2+1);
2705      MemePosV.Add(TIntPr(atoi(CurLn.CStr()+2), atoi(CurLn.CStr()+qb1+1)));
2706      LineCnt++;
2707    } while (SIn.GetNextLn(CurLn));
2708    return true;
2709  }
2710  void TMemesDataLoader::SaveTxt(TSOut&amp; SOut) const {
2711  }
2712  void TMemesDataLoader::Dump(const bool&amp; DumpAll) const {
2713  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1331    GP.AddCmd(&quot;set xrange [-7:7]\nset yzeroaxis lt -1&quot;); GP.SavePng(); }
1332    { TFltPrV PrV;
</pre></code></div>
                <div class="column column_space"><pre><code>1337    GP.AddCmd(&quot;set xrange [-7:7]\nset yzeroaxis lt -1&quot;); GP.SavePng(); }
1338  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    