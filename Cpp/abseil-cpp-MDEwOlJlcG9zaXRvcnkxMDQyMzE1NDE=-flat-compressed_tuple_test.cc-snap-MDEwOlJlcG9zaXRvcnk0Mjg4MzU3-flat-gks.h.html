
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.1811023622047243%, Tokens: 9</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-compressed_tuple_test.cc</h3>
            <pre><code>1  #include "absl/container/internal/compressed_tuple.h"
2  #include <memory>
3  #include <string>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/container/internal/test_instance_tracker.h"
7  #include "absl/memory/memory.h"
8  #include "absl/types/any.h"
9  #include "absl/types/optional.h"
10  #include "absl/utility/utility.h"
11  enum class CallType { kConstRef, kConstMove };
12  template <int>
13  struct Empty {
<span onclick='openModal()' class='match'>14    constexpr CallType value() const& { return CallType::kConstRef; }
15    constexpr CallType value() const&& { return CallType::kConstMove; }
16  };
</span>17  template <typename T>
18  struct NotEmpty {
19    T value;
20  };
21  template <typename T, typename U>
22  struct TwoValues {
23    T value1;
24    U value2;
25  };
26  namespace absl {
27  ABSL_NAMESPACE_BEGIN
28  namespace container_internal {
29  namespace {
30  using absl::test_internal::CopyableMovableInstance;
31  using absl::test_internal::InstanceTracker;
32  TEST(CompressedTupleTest, Sizeof) {
33    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int>));
34    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int, Empty<0>>));
35    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int, Empty<0>, Empty<1>>));
36    EXPECT_EQ(sizeof(int),
37              sizeof(CompressedTuple<int, Empty<0>, Empty<1>, Empty<2>>));
38    EXPECT_EQ(sizeof(TwoValues<int, double>),
39              sizeof(CompressedTuple<int, NotEmpty<double>>));
40    EXPECT_EQ(sizeof(TwoValues<int, double>),
41              sizeof(CompressedTuple<int, Empty<0>, NotEmpty<double>>));
42    EXPECT_EQ(sizeof(TwoValues<int, double>),
43              sizeof(CompressedTuple<int, Empty<0>, NotEmpty<double>, Empty<1>>));
44  }
45  TEST(CompressedTupleTest, OneMoveOnRValueConstructionTemp) {
46    InstanceTracker tracker;
47    CompressedTuple<CopyableMovableInstance> x1(CopyableMovableInstance(1));
48    EXPECT_EQ(tracker.instances(), 1);
49    EXPECT_EQ(tracker.copies(), 0);
50    EXPECT_LE(tracker.moves(), 1);
51    EXPECT_EQ(x1.get<0>().value(), 1);
52  }
53  TEST(CompressedTupleTest, OneMoveOnRValueConstructionMove) {
54    InstanceTracker tracker;
55    CopyableMovableInstance i1(1);
56    CompressedTuple<CopyableMovableInstance> x1(std::move(i1));
57    EXPECT_EQ(tracker.instances(), 2);
58    EXPECT_EQ(tracker.copies(), 0);
59    EXPECT_LE(tracker.moves(), 1);
60    EXPECT_EQ(x1.get<0>().value(), 1);
61  }
62  TEST(CompressedTupleTest, OneMoveOnRValueConstructionMixedTypes) {
63    InstanceTracker tracker;
64    CopyableMovableInstance i1(1);
65    CopyableMovableInstance i2(2);
66    Empty<0> empty;
67    CompressedTuple<CopyableMovableInstance, CopyableMovableInstance&, Empty<0>>
68        x1(std::move(i1), i2, empty);
69    EXPECT_EQ(x1.get<0>().value(), 1);
70    EXPECT_EQ(x1.get<1>().value(), 2);
71    EXPECT_EQ(tracker.copies(), 0);
72    EXPECT_EQ(tracker.moves(), 1);
73  }
74  struct IncompleteType;
75  CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>>
76  MakeWithIncomplete(CopyableMovableInstance i1,
77                     IncompleteType& t,  
78                     Empty<0> empty) {
79    return CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>>{
80        std::move(i1), t, empty};
81  }
82  struct IncompleteType {};
83  TEST(CompressedTupleTest, OneMoveOnRValueConstructionWithIncompleteType) {
84    InstanceTracker tracker;
85    CopyableMovableInstance i1(1);
86    Empty<0> empty;
87    struct DerivedType : IncompleteType {int value = 0;};
88    DerivedType fd;
89    fd.value = 7;
90    CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>> x1 =
91        MakeWithIncomplete(std::move(i1), fd, empty);
92    EXPECT_EQ(x1.get<0>().value(), 1);
93    EXPECT_EQ(static_cast<DerivedType&>(x1.get<1>()).value, 7);
94    EXPECT_EQ(tracker.copies(), 0);
95    EXPECT_EQ(tracker.moves(), 2);
96  }
97  TEST(CompressedTupleTest,
98       OneMoveOnRValueConstructionMixedTypes_BraceInitPoisonPillExpected) {
99    InstanceTracker tracker;
100    CopyableMovableInstance i1(1);
101    CopyableMovableInstance i2(2);
102    CompressedTuple<CopyableMovableInstance, CopyableMovableInstance&, Empty<0>>
103        x1(std::move(i1), i2, {});  
104    EXPECT_EQ(x1.get<0>().value(), 1);
105    EXPECT_EQ(x1.get<1>().value(), 2);
106    EXPECT_EQ(tracker.instances(), 3);
107    EXPECT_EQ(tracker.copies(), 1);
108    EXPECT_EQ(tracker.moves(), 0);
109  }
110  TEST(CompressedTupleTest, OneCopyOnLValueConstruction) {
111    InstanceTracker tracker;
112    CopyableMovableInstance i1(1);
113    CompressedTuple<CopyableMovableInstance> x1(i1);
114    EXPECT_EQ(tracker.copies(), 1);
115    EXPECT_EQ(tracker.moves(), 0);
116    tracker.ResetCopiesMovesSwaps();
117    CopyableMovableInstance i2(2);
118    const CopyableMovableInstance& i2_ref = i2;
119    CompressedTuple<CopyableMovableInstance> x2(i2_ref);
120    EXPECT_EQ(tracker.copies(), 1);
121    EXPECT_EQ(tracker.moves(), 0);
122  }
123  TEST(CompressedTupleTest, OneMoveOnRValueAccess) {
124    InstanceTracker tracker;
125    CopyableMovableInstance i1(1);
126    CompressedTuple<CopyableMovableInstance> x(std::move(i1));
127    tracker.ResetCopiesMovesSwaps();
128    CopyableMovableInstance i2 = std::move(x).get<0>();
129    EXPECT_EQ(tracker.copies(), 0);
130    EXPECT_EQ(tracker.moves(), 1);
131  }
132  TEST(CompressedTupleTest, OneCopyOnLValueAccess) {
133    InstanceTracker tracker;
134    CompressedTuple<CopyableMovableInstance> x(CopyableMovableInstance(0));
135    EXPECT_EQ(tracker.copies(), 0);
136    EXPECT_EQ(tracker.moves(), 1);
137    CopyableMovableInstance t = x.get<0>();
138    EXPECT_EQ(tracker.copies(), 1);
139    EXPECT_EQ(tracker.moves(), 1);
140  }
141  TEST(CompressedTupleTest, ZeroCopyOnRefAccess) {
142    InstanceTracker tracker;
143    CompressedTuple<CopyableMovableInstance> x(CopyableMovableInstance(0));
144    EXPECT_EQ(tracker.copies(), 0);
145    EXPECT_EQ(tracker.moves(), 1);
146    CopyableMovableInstance& t1 = x.get<0>();
147    const CopyableMovableInstance& t2 = x.get<0>();
148    EXPECT_EQ(tracker.copies(), 0);
149    EXPECT_EQ(tracker.moves(), 1);
150    EXPECT_EQ(t1.value(), 0);
151    EXPECT_EQ(t2.value(), 0);
152  }
153  TEST(CompressedTupleTest, Access) {
154    struct S {
155      std::string x;
156    };
157    CompressedTuple<int, Empty<0>, S> x(7, {}, S{"ABC"});
158    EXPECT_EQ(sizeof(x), sizeof(TwoValues<int, S>));
159    EXPECT_EQ(7, x.get<0>());
160    EXPECT_EQ("ABC", x.get<2>().x);
161  }
162  TEST(CompressedTupleTest, NonClasses) {
163    CompressedTuple<int, const char*> x(7, "ABC");
164    EXPECT_EQ(7, x.get<0>());
165    EXPECT_STREQ("ABC", x.get<1>());
166  }
167  TEST(CompressedTupleTest, MixClassAndNonClass) {
168    CompressedTuple<int, const char*, Empty<0>, NotEmpty<double>> x(7, "ABC", {},
169                                                                    {1.25});
170    struct Mock {
171      int v;
172      const char* p;
173      double d;
174    };
175    EXPECT_EQ(sizeof(x), sizeof(Mock));
176    EXPECT_EQ(7, x.get<0>());
177    EXPECT_STREQ("ABC", x.get<1>());
178    EXPECT_EQ(1.25, x.get<3>().value);
179  }
180  TEST(CompressedTupleTest, Nested) {
181    CompressedTuple<int, CompressedTuple<int>,
182                    CompressedTuple<int, CompressedTuple<int>>>
183        x(1, CompressedTuple<int>(2),
184          CompressedTuple<int, CompressedTuple<int>>(3, CompressedTuple<int>(4)));
185    EXPECT_EQ(1, x.get<0>());
186    EXPECT_EQ(2, x.get<1>().get<0>());
187    EXPECT_EQ(3, x.get<2>().get<0>());
188    EXPECT_EQ(4, x.get<2>().get<1>().get<0>());
189    CompressedTuple<Empty<0>, Empty<0>,
190                    CompressedTuple<Empty<0>, CompressedTuple<Empty<0>>>>
191        y;
192    std::set<Empty<0>*> empties{&y.get<0>(), &y.get<1>(), &y.get<2>().get<0>(),
193                                &y.get<2>().get<1>().get<0>()};
194  #ifdef _MSC_VER
195    int expected = 1;
196  #else
197    int expected = 4;
198  #endif
199    EXPECT_EQ(expected, sizeof(y));
200    EXPECT_EQ(expected, empties.size());
201    EXPECT_EQ(sizeof(y), sizeof(Empty<0>) * empties.size());
202    EXPECT_EQ(4 * sizeof(char),
203              sizeof(CompressedTuple<CompressedTuple<char, char>,
204                                     CompressedTuple<char, char>>));
205    EXPECT_TRUE((std::is_empty<CompressedTuple<Empty<0>, Empty<1>>>::value));
206    struct CT_Empty : CompressedTuple<Empty<0>> {};
207    CompressedTuple<Empty<0>, CT_Empty> nested_empty;
208    auto contained = nested_empty.get<0>();
209    auto nested = nested_empty.get<1>().get<0>();
210    EXPECT_TRUE((std::is_same<decltype(contained), decltype(nested)>::value));
211  }
212  TEST(CompressedTupleTest, Reference) {
213    int i = 7;
214    std::string s = "Very long string that goes in the heap";
215    CompressedTuple<int, int&, std::string, std::string&> x(i, i, s, s);
216    EXPECT_EQ(s, "Very long string that goes in the heap");
217    EXPECT_EQ(x.get<0>(), x.get<1>());
218    EXPECT_NE(&x.get<0>(), &x.get<1>());
219    EXPECT_EQ(&x.get<1>(), &i);
220    EXPECT_EQ(x.get<2>(), x.get<3>());
221    EXPECT_NE(&x.get<2>(), &x.get<3>());
222    EXPECT_EQ(&x.get<3>(), &s);
223  }
224  TEST(CompressedTupleTest, NoElements) {
225    CompressedTuple<> x;
226    static_cast<void>(x);  
227    EXPECT_TRUE(std::is_empty<CompressedTuple<>>::value);
228  }
229  TEST(CompressedTupleTest, MoveOnlyElements) {
230    CompressedTuple<std::unique_ptr<std::string>> str_tup(
231        absl::make_unique<std::string>("str"));
232    CompressedTuple<CompressedTuple<std::unique_ptr<std::string>>,
233                    std::unique_ptr<int>>
234    x(std::move(str_tup), absl::make_unique<int>(5));
235    EXPECT_EQ(*x.get<0>().get<0>(), "str");
236    EXPECT_EQ(*x.get<1>(), 5);
237    std::unique_ptr<std::string> x0 = std::move(x.get<0>()).get<0>();
238    std::unique_ptr<int> x1 = std::move(x).get<1>();
239    EXPECT_EQ(*x0, "str");
240    EXPECT_EQ(*x1, 5);
241  }
242  TEST(CompressedTupleTest, MoveConstructionMoveOnlyElements) {
243    CompressedTuple<std::unique_ptr<std::string>> base(
244        absl::make_unique<std::string>("str"));
245    EXPECT_EQ(*base.get<0>(), "str");
246    CompressedTuple<std::unique_ptr<std::string>> copy(std::move(base));
247    EXPECT_EQ(*copy.get<0>(), "str");
248  }
249  TEST(CompressedTupleTest, AnyElements) {
250    any a(std::string("str"));
251    CompressedTuple<any, any&> x(any(5), a);
252    EXPECT_EQ(absl::any_cast<int>(x.get<0>()), 5);
253    EXPECT_EQ(absl::any_cast<std::string>(x.get<1>()), "str");
254    a = 0.5f;
255    EXPECT_EQ(absl::any_cast<float>(x.get<1>()), 0.5);
256  }
257  TEST(CompressedTupleTest, Constexpr) {
258    struct NonTrivialStruct {
259      constexpr NonTrivialStruct() = default;
260      constexpr int value() const { return v; }
261      int v = 5;
262    };
263    struct TrivialStruct {
264      TrivialStruct() = default;
265      constexpr int value() const { return v; }
266      int v;
267    };
268    constexpr CompressedTuple<int, double, CompressedTuple<int>, Empty<0>> x(
269        7, 1.25, CompressedTuple<int>(5), {});
270    constexpr int x0 = x.get<0>();
271    constexpr double x1 = x.get<1>();
272    constexpr int x2 = x.get<2>().get<0>();
273    constexpr CallType x3 = x.get<3>().value();
274    EXPECT_EQ(x0, 7);
275    EXPECT_EQ(x1, 1.25);
276    EXPECT_EQ(x2, 5);
277    EXPECT_EQ(x3, CallType::kConstRef);
278  #if !defined(__GNUC__) || defined(__clang__) || __GNUC__ > 4
279    constexpr CompressedTuple<Empty<0>, TrivialStruct, int> trivial = {};
280    constexpr CallType trivial0 = trivial.get<0>().value();
281    constexpr int trivial1 = trivial.get<1>().value();
282    constexpr int trivial2 = trivial.get<2>();
283    EXPECT_EQ(trivial0, CallType::kConstRef);
284    EXPECT_EQ(trivial1, 0);
285    EXPECT_EQ(trivial2, 0);
286  #endif
287    constexpr CompressedTuple<Empty<0>, NonTrivialStruct, absl::optional<int>>
288        non_trivial = {};
289    constexpr CallType non_trivial0 = non_trivial.get<0>().value();
290    constexpr int non_trivial1 = non_trivial.get<1>().value();
291    constexpr absl::optional<int> non_trivial2 = non_trivial.get<2>();
292    EXPECT_EQ(non_trivial0, CallType::kConstRef);
293    EXPECT_EQ(non_trivial1, 5);
294    EXPECT_EQ(non_trivial2, absl::nullopt);
295    static constexpr char data[] = "DEF";
296    constexpr CompressedTuple<const char*> z(data);
297    constexpr const char* z1 = z.get<0>();
298    EXPECT_EQ(std::string(z1), std::string(data));
299  #if defined(__clang__)
300    constexpr int x2m = absl::move(x.get<2>()).get<0>();
301    constexpr CallType x3m = absl::move(x).get<3>().value();
302    EXPECT_EQ(x2m, 5);
303    EXPECT_EQ(x3m, CallType::kConstMove);
304  #endif
305  }
306  #if defined(__clang__) || defined(__GNUC__)
307  TEST(CompressedTupleTest, EmptyFinalClass) {
308    struct S final {
309      int f() const { return 5; }
310    };
311    CompressedTuple<S> x;
312    EXPECT_EQ(x.get<0>().f(), 5);
313  }
314  #endif
315  TEST(CompressedTupleTest, DISABLED_NestedEbo) {
316    struct Empty1 {};
317    struct Empty2 {};
318    CompressedTuple<Empty1, CompressedTuple<Empty2>, int> x;
319    CompressedTuple<Empty1, Empty2, int> y;
320    EXPECT_EQ(sizeof(x), sizeof(y));
321  }
322  }  
323  }  
324  ABSL_NAMESPACE_END
325  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gks.h</h3>
            <pre><code>1  #ifndef gks_h
2  #define gks_h
3  #include "base.h"
4  class TGksColor{
5  private:
6    uint ArgbVal;
7  public:
8    TGksColor(): ArgbVal(0){}
9    TGksColor(const TGksColor& Color): ArgbVal(Color.ArgbVal){}
10    TGksColor(const uint& _RgbVal): ArgbVal((0xFF)|(_RgbVal<<8)){}
11    TGksColor(const uint& _ArgbVal, const bool& Alpha): ArgbVal(_ArgbVal){Assert(Alpha);}
12    TGksColor(const uint& RVal, const uint& GVal, const uint& BVal): ArgbVal(0){
13      ArgbVal=((0xFF)|(RVal&0xFF)<<8)|((GVal&0xFF)<<16)|((BVal&0xFF)<<24);}
14    TGksColor(const uint& AVal, const uint& RVal, const uint& GVal, const uint& BVal): 
15      ArgbVal(0){ ArgbVal=(AVal&0xFF)|((RVal&0xFF)<<8)|((GVal&0xFF)<<16)|((BVal&0xFF)<<24);}
16    TGksColor& operator=(const TGksColor& Color){
17      ArgbVal=Color.ArgbVal; return *this;}
18    bool operator==(const TGksColor& GksColor) const {
19      return ArgbVal==GksColor.ArgbVal;}
20    void PutArgbVal(const uint& _ArgbVal){ArgbVal=_ArgbVal;}
21    uint GetArgbVal() const {return ArgbVal;}
22    uint GetRgbVal() const {return ArgbVal>>8&0xffffff;}
23    int GetAVal() const {return ArgbVal&0xff;}
24    int GetRVal() const {return (ArgbVal>>8)&0xff;}
25    int GetGVal() const {return (ArgbVal>>16)&0xff;}
26    int GetBVal() const {return (ArgbVal>>24)&0xff;}
27    TGksColor Add(const uint& RVal, const uint& GVal, const uint& BVal) {
28        return TGksColor(GetRVal() + RVal, GetGVal() + GVal, GetBVal() + BVal); }
29    TGksColor Add(const TGksColor& AddColor) {
30        return TGksColor(GetRVal() + AddColor.GetRVal(), 
31            GetGVal() + AddColor.GetGVal(), GetBVal() + AddColor.GetBVal()); }
32    static TGksColor GetRndColor(TRnd& Rnd){
33      return TGksColor(Rnd.GetUniDevInt(0x1000000));}
34    static TGksColor GetWhite(){return TGksColor(255, 255, 255);}
35    static TGksColor GetBlack(){return TGksColor(0, 0, 0);}
36    static TGksColor GetRed(){return TGksColor(255, 0, 0);}
37    static TGksColor GetGreen(){return TGksColor(0, 255, 0);}
38    static TGksColor GetBlue(){return TGksColor(0, 0, 255);}
39    static TGksColor GetYellow(){return TGksColor(255, 255, 0);}
40    static TGksColor GetMagenta(){return TGksColor(255, 0, 255);}
41    static TGksColor GetCyan(){return TGksColor(0, 255, 255);}
42    static TGksColor GetTransparent(){return TGksColor(0, 255, 255, 255);}
43    static uint GetInvArgbVal(uint ArgbVal) {
44        return ((ArgbVal>>24)&0xff)|(((ArgbVal>>16)&0xff)<<8)|
45               (((ArgbVal>>8)&0xff)<<16)|((ArgbVal&0xff)<<24); }
46  };
47  class TGksSPoint{
48  public:
49    int X;
50    int Y;
51  public:
52    TGksSPoint(): X(0), Y(0){}
53    TGksSPoint(const TGksSPoint& Point): X(Point.X), Y(Point.Y){}
54    TGksSPoint(const int& _X, const int& _Y): X(_X), Y(_Y){}
55    TGksSPoint& operator=(const TGksSPoint& Point){
56      X=Point.X; Y=Point.Y; return *this;}
57  };
58  typedef TVec<TGksSPoint> TGksSPointV;
59  class TGksVPoint{
60  public:
61    double X;
62    double Y;
63  public:
64    TGksVPoint(): X(0), Y(0){}
65    TGksVPoint(const TGksVPoint& Point): X(Point.X), Y(Point.Y){}
66    TGksVPoint(const double& _X, const double& _Y): X(_X), Y(_Y){}
67    TGksVPoint& operator=(const TGksVPoint& Point){
68      X=Point.X; Y=Point.Y; return *this;}
69  };
70  typedef TVec<TGksVPoint> TGksVPointV;
71  class TGksPPoint{
72  public:
73    double Rad;
74    double Ang;
75  public:
76    TGksPPoint(): Rad(0), Ang(0){}
77    TGksPPoint(const TGksPPoint& Point): Rad(Point.Rad), Ang(Point.Ang){}
78    TGksPPoint(const double& _Rad, const double& _Ang): Rad(_Rad), Ang(_Ang){}
79    TGksPPoint(const TGksSPoint& Point):
80      Rad(sqrt(TMath::Sqr(Point.X)+TMath::Sqr(Point.Y))),
81      Ang((Point.X==0)&&(Point.Y==0)?0:atan2(double(Point.Y), double(Point.X))){}
82    TGksPPoint(const TGksVPoint& Point):
83      Rad(sqrt(TMath::Sqr(Point.X)+TMath::Sqr(Point.Y))),
84      Ang((Point.X==0)&&(Point.Y==0)?0:atan2(Point.Y, Point.X)){}
85    TGksPPoint& operator=(const TGksPPoint& Point){
86      Rad=Point.Rad; Ang=Point.Ang; return *this;}
87    TGksSPoint GetSPoint() const {
88      return TGksSPoint(int(Rad*cos(Ang)), int(Rad*sin(Ang)));}
89    TGksVPoint GetVPoint() const {
90      return TGksVPoint(Rad*cos(Ang), Rad*sin(Ang));}
91  };
92  typedef TVec<TGksPPoint> TGksPPointV;
93  class TGksRect{
94  public:
95    double X1, Y1, X2, Y2;
96  public:
97    TGksRect(): X1(0), Y1(0), X2(0), Y2(0){}
98    TGksRect(const TGksRect& Rect):
99      X1(Rect.X1), Y1(Rect.Y1), X2(Rect.X2), Y2(Rect.Y2){}
100    TGksRect(const TGksSPoint& Point1, const TGksSPoint& Point2):
101      X1(Point1.X), Y1(Point1.Y),
102      X2(Point2.X), Y2(Point2.Y){}
103    TGksRect(const int& _X1, const int& _Y1, const int& _X2, const int& _Y2):
104      X1(_X1), Y1(_Y1), X2(_X2), Y2(_Y2){}
105    TGksRect(const double& _X1, const double& _Y1, const double& _X2, const double& _Y2):
106      X1(_X1), Y1(_Y1), X2(_X2), Y2(_Y2){}
107    TGksRect& operator=(const TGksRect& Rect){
108      if (this!=&Rect){X1=Rect.X1; Y1=Rect.Y1; X2=Rect.X2; Y2=Rect.Y2;}
109      return *this;}
110    int GetX1() const {return int(X1);}
111    int GetY1() const {return int(Y1);}
112    int GetX2() const {return int(X2);}
113    int GetY2() const {return int(Y2);}
114    double GetXLen() const {return X2-X1;}
115    double GetYLen() const {return Y2-Y1;}
116    double GetXCenter() const {return X1+(X2-X1)/2;}
117    double GetYCenter() const {return Y1+(Y2-Y1)/2;}
118    void Sort(){
119      if (X1>X2){Swap<double>(X1,X2);}
120      if (Y1>Y2){Swap<double>(Y1,Y2);}}
121    bool IsIn(const double& X, const double& Y) const {
122      bool XOk; bool YOk;
123      if (X1<X2){XOk=(X1<=X)&&(X<=X2);} else {XOk=(X2<=X)&&(X<=X1);}
124      if (Y1<Y2){YOk=(Y1<=Y)&&(Y<=Y2);} else {YOk=(Y2<=Y)&&(Y<=Y1);}
125      return XOk&&YOk;
126    }
127    TFltRect GetFltRect() const {
128      return TFltRect(X1, Y1, X2, Y2);}
129  };
130  typedef TVec<TGksRect> TGksRectV;
131  typedef enum {gpmBlack, gpmWhite, gpmNop, gpmNot, gpmCopy, gpmNotCopy,
132   gpmMergePenNot, gpmMaskPenNot, gpmMergeNotPen, gpmMaskNotPen, gpmMerge,
133   gpmNotMerge, gpmMask, gpmNotMask, gpmXor, gpmNotXor} TGksPenMode;
134  typedef enum  {gpsSolid, gpsDash, gpsDot, gpsDashDot, gpsDashDotDot,
135   gpsClear, gpsInsideFrame} TGksPenStyle;
136  ClassTP(TGksPen, PGksPen)
137  private:
138    TGksColor Color;
139    TGksPenMode Mode;
140    TGksPenStyle Style;
141    int Width;
142  public:
143    TGksPen():
144      Color(), Mode(gpmCopy), Style(gpsSolid), Width(1){}
145    TGksPen(const TGksPen& Pen):
146      Color(Pen.Color), Mode(Pen.Mode), Style(Pen.Style), Width(Pen.Width){}
147    TGksPen(const TGksColor& _Color, const TGksPenMode& _Mode=gpmCopy,
148     const TGksPenStyle& _Style=gpsSolid, const int& _Width=1):
149      Color(_Color), Mode(_Mode), Style(_Style), Width(_Width){}
150    static PGksPen New(const TGksColor& Color, const TGksPenMode& Mode=gpmCopy,
151     const TGksPenStyle& Style=gpsSolid, const int& Width=1){
152      return new TGksPen(Color, Mode, Style, Width);}
153    TGksPen(TSIn&){Fail;}
154    static PGksPen Load(TSIn& SIn){return new TGksPen(SIn);}
155    void Save(TSOut&){Fail;}
156    TGksPen& operator=(const TGksPen& Pen){
157      if (this!=&Pen){
158        Color=Pen.Color; Mode=Pen.Mode; Style=Pen.Style; Width=Pen.Width;}
159      return *this;}
160    TGksColor GetColor() const {return Color;}
161    TGksPenMode GetMode() const {return Mode;}
162    TGksPenStyle GetStyle() const {return Style;}
163    int GetWidth() const {return Width;}
164  };
165  typedef enum  {gbsSolid, gbsClear, gbsHorizontal, gbsVertical,
166   gbsFDiagonal, gbsBDiagonal, gbsCross, gbsDiagCross} TGksBrushStyle;
167  ClassTP(TGksBrush, PGksBrush)
168  private:
169    TGksColor Color;
170    TGksBrushStyle Style;
171  public:
172    TGksBrush():
173      Color(), Style(gbsSolid){}
174    TGksBrush(const TGksBrush& Brush):
175      Color(Brush.Color), Style(Brush.Style){}
176    TGksBrush(const TGksColor& _Color, const TGksBrushStyle& _Style=gbsSolid):
177      Color(_Color), Style(_Style){}
178    static PGksBrush New(
179     const TGksColor& Color, const TGksBrushStyle& Style=gbsSolid){
180      return new TGksBrush(Color, Style);}
181    TGksBrush(TSIn&){Fail;}
182    static PGksBrush Load(TSIn& SIn){return new TGksBrush(SIn);}
183    void Save(TSOut&){Fail;}
184    TGksBrush& operator=(const TGksBrush& Brush){
185      if (this!=&Brush){Color=Brush.Color; Style=Brush.Style;} return *this;}
<span onclick='openModal()' class='match'>186    TGksColor GetColor() const {return Color;}
187    TGksBrushStyle GetStyle() const {return Style;}
188  };
</span>189  typedef enum  {gfsBold, gfsItalic, gfsUnderline, gfsStrikeOut} TGksFontStyle;
190  ClassTP(TGksFont, PGksFont)
191  private:
192    TStr Nm;
193    int Size;
194    TGksColor Color;
195    TFSet Style;
196  public:
197    TGksFont():
198      Nm("System"), Size(10), Color(), Style(){}
199    TGksFont(const TGksFont& Font):
200      Nm(Font.Nm), Size(Font.Size), Color(Font.Color), Style(Font.Style){}
201    TGksFont(const TStr& _Nm, const int& _Size=10,
202     const TGksColor& _Color=TGksColor::GetBlack(), const TFSet& _Style=TFSet()):
203      Nm(_Nm), Size(_Size), Color(_Color), Style(_Style){}
204    static PGksFont New(const TStr& Nm, const int& Size=10,
205     const TGksColor& Color=TGksColor::GetBlack(), const TFSet& Style=TFSet()){
206      return new TGksFont(Nm, Size, Color, Style);}
207    TGksFont(TSIn&){Fail;}
208    static PGksFont Load(TSIn& SIn){return new TGksFont(SIn);}
209    void Save(TSOut&){Fail;}
210    TGksFont& operator=(const TGksFont& Font){
211      if (this!=&Font){
212        Nm=Font.Nm; Size=Font.Size; Color=Font.Color; Style=Font.Style;}
213      return *this;}
214    TStr GetNm() const {return Nm;}
215    int GetSize() const {return Size;}
216    TGksColor GetColor() const {return Color;}
217    TFSet GetStyle() const {return Style;}
218  };
219  ClassTP(TGksBitmap, PGksBitmap)
220  private:
221    int Width;
222    int Height;
223    TVec<uint> PixelV;
224  public:
225    TGksBitmap(): Width(0), Height(0), PixelV() {};
226    TGksBitmap(const int& _Width, const int& _Height,
227     const TGksColor& Color=TGksColor::GetWhite());
228    static PGksBitmap New(const int& Width, const int& Height,
229     const TGksColor& Color=TGksColor::GetWhite()){
230      return new TGksBitmap(Width, Height, Color);}
231    int GetWidth() const {return Width;}
232    int GetHeight() const {return Height;}
233    TGksColor GetPixel(const int& X, const int& Y) const {
234      Assert((0<=X && X<Width)&&(0<=Y && Y<Height));
235      return TGksColor(PixelV[Y*Width+X], true);}
236    void SetPixel(const int& X, const int& Y, const TGksColor& Color) {
237      Assert((0<=X && X<Width)&&(0<=Y && Y<Height));
238      PixelV[Y*Width + X] = Color.GetArgbVal();}
239      TVec<uint>& GetPixelV() { return PixelV; }
240  };
241  typedef enum  {
242   gtbtUndef, gtbtRect, gtbtRoundRect, gtbtEllipse, gtbtRomb} TGksTxtBoxType;
243  ClassTP(TGks, PGks)
244  public:
245    void GetDbTxtData(
246     const TStr& TxtStr1, const TStr& TxtStr2, const int& X, const int& Y,
247     int& TxtWidth1, int& TxtHeight1, int& TxtWidth2, int& TxtHeight2,
248     int& TxtWidth, int& TxtHeight, int& Y1, int& Y2);
249    void GetStrVData(
250     const TStrV& StrV, const int& &bsol;*X*/, const int& Y,
251     TIntV& StrWidthV, TIntV& StrHeightV,
252     int& StrVWidth, int& StrVHeight, TIntV& YV);
253  public:
254    TGks(){}
255    TGks(TSIn&){Fail;}
256    virtual ~TGks(){}
257    static PGks Load(TSIn&){Fail; return NULL;}
258    void Save(TSOut&){Fail;}
259    TGks& operator=(const TGks&){Fail; return *this;}
260    virtual int GetWidth() const=0;
261    virtual int GetHeight() const=0;
262    virtual void Clr() const=0;
263    virtual void Inv() const=0;
264    virtual void BeginPaint(HDC Hdc = 0, HANDLE Handle = 0) const {}
265    virtual void EndPaint() const {}
266    virtual void SetPen(const PGksPen& Pen)=0;
267    virtual PGksPen GetPen()=0;
268    virtual void SetBrush(const PGksBrush& Brush)=0;
269    virtual PGksBrush GetBrush()=0;
270    virtual void SetFont(const PGksFont& Font)=0;
271    virtual PGksFont GetFont()=0;
272    int GetVToPX(const double& VX) const {return int(VX*GetWidth());}
273    int GetVToPY(const double& VY) const {return int(VY*GetHeight());}
274    double GetPToVX(const int& PX) const {return double(PX)/double(GetWidth());}
275    double GetPToVY(const int& PY) const {return double(PY)/double(GetHeight());}
276    TGksRect GetPToVRect(const TGksRect& Rect){
277      return TGksRect(
278       GetPToVX(Rect.GetX1()), GetPToVY(Rect.GetY1()),
279       GetPToVX(Rect.GetX2()), GetPToVY(Rect.GetY2()));}
280    TGksRect GetVToPRect(const TGksRect& Rect){
281      return TGksRect(
282       GetVToPX(Rect.GetX1()), GetVToPY(Rect.GetY1()),
283       GetVToPX(Rect.GetX2()), GetVToPY(Rect.GetY2()));}
284    TGksRect GetVToPRect(const TFltRect& Rect){
285      return TGksRect(
286       GetVToPX(Rect.GetMnX()), GetVToPY(Rect.GetMnY()),
287       GetVToPX(Rect.GetMxX()), GetVToPY(Rect.GetMxY()));}
288    virtual void PutPixel(const int& X, const int& Y, const TGksColor& Color)=0;
289    void PutPixel(const TGksSPoint& Point, const TGksColor& Color){
290      PutPixel(Point.X, Point.Y, Color);}
291    void PutPixelV(const TGksSPointV& PointV, const TGksColor& Color){
292      for (int PointN=0; PointN<PointV.Len(); PointN++){
293        PutPixel(PointV[PointN], Color);}}
294    virtual TGksColor GetPixel(const int& X, const int& Y)=0;
295    TGksColor GetPixel(const TGksSPoint& Point){
296      return GetPixel(Point.X, Point.X);}
297    TGksSPoint GetRndPoint(TRnd& Rnd){
298      return TGksSPoint(Rnd.GetUniDevInt(GetWidth()), Rnd.GetUniDevInt(GetHeight()));}
299    virtual void Line(
300     const int& X1, const int& Y1, const int& X2, const int& Y2)=0;
301    void Line(const TGksSPoint& Point1, const TGksSPoint& Point2){
302      Line(Point1.X, Point1.Y, Point2.X, Point2.Y);}
303    virtual void PolyLine(const TGksSPointV& PointV)=0;
304    virtual void Polygon(const TGksSPointV& PointV)=0;
305    virtual void PolyBezier(const TGksSPointV& PointV)=0;
306    void DirLine(const int& X1, const int& Y1, const int& X2, const int& Y2,
307     const bool& LeftDir, const bool& RightDir,
308     const int& ArrowLen=10, const double& ArrowOffset=0.25);
309    void DirLine(const TGksSPoint& Point1, const TGksSPoint& Point2,
310     const bool& LeftDir, const bool& RightDir,
311     const int& ArrowLen=10, const double& ArrowOffset=0.25){
312      DirLine(Point1.X, Point1.Y, Point2.X, Point2.Y,
313       LeftDir, RightDir, ArrowLen, ArrowOffset);}
314    TGksRect GetRndRect(TRnd& Rnd){
315      return TGksRect(
316       Rnd.GetUniDevInt(GetWidth()), Rnd.GetUniDevInt(GetHeight()),
317       Rnd.GetUniDevInt(GetWidth()), Rnd.GetUniDevInt(GetHeight()));}
318    virtual void FrameRect(
319     const int& X1, const int& Y1, const int& X2, const int& Y2)=0;
320    void FrameRect(const TGksRect& Rect){
321      FrameRect(Rect.GetX1(), Rect.GetY1(), Rect.GetX2(), Rect.GetY2());}
322    virtual void FillRect(
323     const int& X1, const int& Y1, const int& X2, const int& Y2)=0;
324    void FillRect(const TGksRect& Rect){
325      FillRect(Rect.GetX1(), Rect.GetY1(), Rect.GetX2(), Rect.GetY2());}
326    virtual void Rectangle(
327     const int& X1, const int& Y1, const int& X2, const int& Y2)=0;
328    void Rectangle(const TGksRect& Rect){
329      Rectangle(Rect.GetX1(), Rect.GetY1(), Rect.GetX2(), Rect.GetY2());}
330    virtual void RoundRect(const int& X1, const int& Y1,
331     const int& X2, const int& Y2, const int& EWidth, const int& EHeight)=0;
332    void RoundRect(const TGksRect& Rect, const int& EWidth, const int& EHeight){
333      RoundRect(Rect.GetX1(), Rect.GetY1(), Rect.GetX2(), Rect.GetY2(),
334       EWidth, EHeight);}
335    virtual void Ellipse(
336     const int& X1, const int& Y1, const int& X2, const int& Y2)=0;
337    void Ellipse(const TGksRect& Rect){
338      Ellipse(Rect.GetX1(), Rect.GetY1(), Rect.GetX2(), Rect.GetY2());}
339    virtual void FillEllipse(
340     const int& X1, const int& Y1, const int& X2, const int& Y2)=0;
341    void FillEllipse(const TGksRect& Rect){
342      FillEllipse(Rect.GetX1(), Rect.GetY1(), Rect.GetX2(), Rect.GetY2());}
343    void Circle(const int& X, const int& Y, const int& Rad){
344      Ellipse(X-Rad/2, Y-Rad/2, X+Rad/2, Y+Rad/2);}
345    void Circle(const TGksSPoint& Point, const int& Rad){
346      Circle(Point.X, Point.Y, Rad);}
347    virtual void Arc(
348     const int& X1, const int& Y1, const int& X2, const int& Y2,
349     const int& X3, const int& Y3, const int& X4, const int& Y4)=0;
350    virtual void Bitmap(const PGksBitmap& Bmp, const int& X, const int& Y)=0;
351    virtual void Bitmap(const PGksBitmap& Bmp,
352     const int& X1, const int& Y1, const int& X2, const int& Y2)=0;
353    void Bitmap(const PGksBitmap& Bmp, const TGksRect& Rect){
354     Bitmap(Bmp, Rect.GetX1(), Rect.GetY1(), Rect.GetX2(), Rect.GetY2());}
355    virtual int GetTxtWidth(const TStr& TxtStr)=0;
356    virtual int GetTxtHeight(const TStr& TxtStr)=0;
357    virtual void PutTxt(const TStr& TxtStr, const int& X, const int& Y)=0;
358    void PutTxt(const TStr& TxtStr, const TGksSPoint& Point){
359      PutTxt(TxtStr, Point.X, Point.Y);}
360    virtual void PutTxt(const TStr& TxtStr, const int& X, const int& Y,
361     const TGksRect& ClipRect)=0;
362    void PutTxt(const TStr& TxtStr, const TGksSPoint& Point,
363     const TGksRect& ClipRect){
364      PutTxt(TxtStr, Point.X, Point.Y, ClipRect);}
365    TStr BreakTxt(const TStr& TxtStr, const TStr& SplitStr, const TStr& EndLnStr,
366        const int& TxtWidth, const int& MxLines = -1);
367    TStr BreakTxt(const TStrV& PartV, const TStr& SplitStr, const TStr& EndLnStr, 
368        const int& TxtWidth, const int& MxLines = -1);
369    static TGksTxtBoxType GetTxtBoxType(const TStr& TxtBoxTypeNm);
370    static TStr GetTxtBoxTypeNm(const TGksTxtBoxType& Type);
371    TGksRect TxtBox(const TGksTxtBoxType& Type, const TStr& TxtStr,
372     const int& X, const int& Y, const int& Margin=5);
373    TGksRect TxtBox(const TGksTxtBoxType& Type, const TStr& TxtStr,
374     const TGksSPoint& Point, const int& Margin=5){
375      return TxtBox(Type, TxtStr, Point.X, Point.Y, Margin);}
376    TGksRect TxtBox(const TGksTxtBoxType& Type,
377     const TStr& TxtStr1, const TStr& TxtStr2,
378     const int& X, const int& Y, const int& Margin=5);
379    TGksRect TxtBox(const TGksTxtBoxType& Type,
380     const TStr& TxtStr1, const TStr& TxtStr2,
381     const TGksSPoint& Point, const int& Margin=5){
382      return TxtBox(Type, TxtStr1, TxtStr2, Point.X, Point.Y, Margin);}
383    TGksRect LineTxt(const TStr& TxtStr,
384     const int& X1, const int& Y1, const int& X2, const int& Y2);
385    TGksRect LineTxt(const TStr& TxtStr,
386     const TGksSPoint& Point1, const TGksSPoint& Point2){
387      return LineTxt(TxtStr, Point1.X, Point1.Y, Point2.X, Point2.Y);}
388    TGksRect RectTxtBox(const TStr& TxtStr,
389     const int& X, const int& Y, const int& Margin=5);
390    TGksRect RectTxtBox(const TStr& TxtStr,
391     const TGksSPoint& Point, const int& Margin=5){
392      return RectTxtBox(TxtStr, Point.X, Point.Y, Margin);}
393    TGksRect RectTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
394     const int& X, const int& Y, const int& Margin=5);
395    TGksRect RectTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
396     const TGksSPoint& Point, const int& Margin=5){
397      return RectTxtBox(TxtStr1, TxtStr2, Point.X, Point.Y, Margin);}
398    TGksRect RoundRectTxtBox(const TStr& TxtStr,
399     const int& X, const int& Y, const int& Margin=5);
400    TGksRect RoundRectTxtBox(const TStr& TxtStr,
401     const TGksSPoint& Point, const int& Margin=5){
402      return RoundRectTxtBox(TxtStr, Point.X, Point.Y, Margin);}
403    TGksRect RoundRectTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
404     const int& X, const int& Y, const int& Margin=5);
405    TGksRect RoundRectTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
406     const TGksSPoint& Point, const int& Margin=5){
407      return RoundRectTxtBox(TxtStr1, TxtStr2, Point.X, Point.Y, Margin);}
408    TGksRect EllipseTxtBox(const TStr& TxtStr,
409     const int& X, const int& Y, const int& Margin=5);
410    TGksRect EllipseTxtBox(const TStr& TxtStr,
411     const TGksSPoint& Point, const int& Margin=5){
412      return EllipseTxtBox(TxtStr, Point.X, Point.Y, Margin);}
413    TGksRect EllipseTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
414     const int& X, const int& Y, const int& Margin=5);
415    TGksRect EllipseTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
416     const TGksSPoint& Point, const int& Margin=5){
417      return EllipseTxtBox(TxtStr1, TxtStr2, Point.X, Point.Y, Margin);}
418    TGksRect RombTxtBox(const TStr& TxtStr,
419     const int& X, const int& Y, const int& Margin=5);
420    TGksRect RombTxtBox(const TStr& TxtStr,
421     const TGksSPoint& Point, const int& Margin=5){
422      return RombTxtBox(TxtStr, Point.X, Point.Y, Margin);}
423    TGksRect RombTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
424     const int& X, const int& Y, const int& Margin=5);
425    TGksRect RombTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
426     const TGksSPoint& Point, const int& Margin=5){
427      return RombTxtBox(TxtStr1, TxtStr2, Point.X, Point.Y, Margin);}
428    double GetLineLen(const int& X1, const int& Y1, const int& X2, const int& Y2){
429      return sqrt(TMath::Sqr(Y2-Y1)+TMath::Sqr(X2-X1));}
430  };
431  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-compressed_tuple_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gks.h</div>
                </div>
                <div class="column column_space"><pre><code>14    constexpr CallType value() const& { return CallType::kConstRef; }
15    constexpr CallType value() const&& { return CallType::kConstMove; }
16  };
</pre></code></div>
                <div class="column column_space"><pre><code>186    TGksColor GetColor() const {return Color;}
187    TGksBrushStyle GetStyle() const {return Style;}
188  };
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    