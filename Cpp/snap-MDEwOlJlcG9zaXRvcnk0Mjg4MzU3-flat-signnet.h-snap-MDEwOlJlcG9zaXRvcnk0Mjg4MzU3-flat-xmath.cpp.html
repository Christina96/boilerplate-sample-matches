
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.30730793254216%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-signnet.h</h3>
            <pre><code>1  #ifndef snap_signed_network_h
2  #define snap_signed_network_h
3  #include "Snap.h"
4  #include "mxdag.h"
5  class TSignNet;
6  typedef TPt<TSignNet> PSignNet;
7  class TSignNet : public TNodeEDatNet<TInt, TInt> {
8  public:
9    TSignNet() { }
10    TSignNet(TSIn& SIn) : TNet(SIn) { }
11    static PSignNet New() { return new TSignNet; }
12    static PSignNet Load(TSIn& SIn) { return new TSignNet(SIn); }
13    PSignNet GetEdgeSubNet(const int& EDat1, const int& EDat2=TInt::Mn, const int& EDat3=TInt::Mn) const;
14    void PermuteEdgeSigns();
15    void RewireNetwork();
16    void SimplifyNet();
17    void FlipMinusEdges(const int&  OldSign=-1, const int& NewSign=1);
18    PSignNet GetSubNet(const int& MinEdgeWgt) const {
19      return TSnap::GetEDatSubGraph<PSignNet, TInt>(PSignNet((TSignNet*) this), MinEdgeWgt, 1); }
20    PSignNet GetSignSubNet(const int& Sign) const {
21      return TSnap::GetEDatSubGraph<PSignNet, TInt>(PSignNet((TSignNet*) this), Sign, 0); }
22    void CountStructBalance() const;
23    void CountBalUnBal(const int& NId1, const int& NId2, int& BalTriads, int& UnBalTriads) const;
24    void SetNodePart(const int& PartId);
25    void SetNodePart(TVec<TIntV>& PartNIdV);
26    void GetPartStat(const TVec<TIntV>& PartNIdV, const TStr& Desc=TStr()) const;
27    void MakeStatusConsistent();
28    PSignNet GetTriad(const int& NId1, const int& NId2, const int& NId3) const;
29    bool IsClosedTriad() const;
30    bool IsBalanced() const;
31    double GetTriadProb(const double& PlusProb) const;
32    TIntPr GetNewEdge(const PSignNet& OldTriad) const;
33    int GetEdgeSig(const int& NId1, const int& NId2) const;
34    TChA GetEdgeStr(const int& NId1, const int& NId2) const;
35    TIntTr GetTriadSig(const bool& Canonical=true) const;
36    TChA GetTriadStr(const bool& Canonical=true) const;
37    static TChA GetEdgeStr(const int& EdgeSig);
38    static TChA GetTriadStr(const TIntTr& TriadSig);
39    void EdgeSignStat() const;
40    void PlotSignCmnNbrs(const TStr& OutFNm) const;
41    void CountSignedTriads(const TStr& OutFNm) const;
42    void PlotGraphProp(const TStr& OutFNm) const;
43    void PlotInOutPlusFrac(const TStr& OutFNm) const;
44    void SaveTxt(const TStr& OutFNm) const;
45    void SavePajek(const TStr& OutFNm);
46    void DrawGraphViz(const TStr& OutFNm, const TStr& Desc, const bool& NodeLabels=false, const bool& EdgeLabels=false, const bool& SaveDir=true);
47    void PrintInfo(const TStr& Desc=TStr()) const;
48    void Dump() const;
49    static int IsSameTriad(const PSignNet& Net1, const PSignNet& Net2);
50    static void GetPartOverlap(const TVec<TIntV>& PartNIdV1, const TVec<TIntV>& PartNIdV2);
51    static PSignNet LoadEpinions(const TStr& FNm);
52    static PSignNet LoadSlashdot(const TStr& FNm);
53    static PSignNet GetSmallNet();
54    friend class TPt<TSignNet>;
55  };
56  namespace TSnap {
57  template <> struct IsDirected<TSignNet> { enum { Val = 1 }; };
58  template <> struct IsNodeDat<TSignNet> { enum { Val = 1 }; };
59  template <> struct IsEdgeDat<TSignNet> { enum { Val = 1 }; };
60  }
61  class THopfield {
62  public:
63    PSignNet Net;
64    TIntH NIdPartH;
65    THash<TInt, TTuple<TInt, 5> > NIdPartCnt;
66    TIntH EnergDistr;
67    TInt MxEnergy;
68    TIntH BestPart;
69  public:
70    THopfield(const PSignNet& _Net) : Net(_Net) { }
71    int MinEnergy(const int& NPart);
72    int FindStableSet(const int& NPart, const int& NRuns);
73    void GetStableSet(const int& Tresh, TVec<TIntV>& PartNIdV);
74    void PlotPartStab(const TStr& FNm, TStr Desc=TStr()) const;
75    void DumpPartStat() const;
76  };
77  class TSignMicroEvol {
78  public:
79    struct TTransStat {
80      TInt Cnt;    
81      TFlt SumWgt; 
82      TFlt VarSq;  
83      TTransStat() { }
84      TTransStat(TSIn& SIn) : Cnt(SIn), SumWgt(SIn), VarSq(SIn) { }
85      void Save(TSOut& SOut) const { Cnt.Save(SOut); SumWgt.Save(SOut); VarSq.Save(SOut); }
86      bool operator < (const TTransStat& S) const { return Cnt<S.Cnt; }
87    };
88    struct TCloseStat {
89      TInt PlsCnt, MnsCnt;        
90      TFlt OutSumWgt, OutVarSq;   
91      TFlt InSumWgt, InVarSq;     
92      TIntH OutPlusPH, InPlusPH;  
93      TCloseStat() { }
94      TCloseStat(TSIn& SIn) : PlsCnt(SIn), MnsCnt(SIn), OutSumWgt(SIn), OutVarSq(SIn), InSumWgt(SIn), InVarSq(SIn), OutPlusPH(SIn), InPlusPH(SIn) { }
95      void Save(TSOut& SOut) const { PlsCnt.Save(SOut); MnsCnt.Save(SOut); OutSumWgt.Save(SOut); OutVarSq.Save(SOut); InSumWgt.Save(SOut); InVarSq.Save(SOut); OutPlusPH.Save(SOut); InPlusPH.Save(SOut); }
96      TStr GetMajorSign() const { return PlsCnt>=MnsCnt?"+":"-"; }
97      double GetMajorFrac() const { return TMath::Mx(PlsCnt,MnsCnt)/(PlsCnt+MnsCnt); }
98      double GetPlsFrac() const { return PlsCnt/double(PlsCnt+MnsCnt); }
99      double GetOutPlsSurp() const { return (PlsCnt - OutSumWgt)/sqrt(OutVarSq); }
100      double GetInPlsSurp() const { return  (PlsCnt - InSumWgt)/sqrt(InVarSq); }
101      void SaveHist(const TStr& OutFNm) const {
102        TGnuPlot::PlotValCntH(OutPlusPH, OutFNm+"_Out", "", "Probability of plus out", "Count");
103        TGnuPlot::PlotValCntH(InPlusPH, OutFNm+"_In", "", "Probability of plus in", "Count"); }
104    };
105    typedef TNodeEDatNet<TInt, TTransStat> TTransitionNet;
106    typedef TPt<TTransitionNet> PTransitionNet;
107    THash<TInt, TVec<TIntV> > PermH;
108    void BuildPerms();
109  public:
110    PSignNet Network;
111    TVec<PSignNet> TriadIdV;  
112    TVec<PSignNet> OpnTriadV; 
113    PTransitionNet TransNet;  
114    THash<TInt, TCloseStat> CloseTriadH;  
115    THash<TIntPr, TCloseStat> Triad3to4H; 
116    THash<TTuple<TInt, 16>, TIntPr> TriadVecV;
117    THash<TIntPr, TFltPr> RepLinkCntH;    
118  public:
119    TSignMicroEvol(PSignNet NetPt);
120    TSignMicroEvol(TSIn& SIn);
121    void Save(TSOut& SOut) const;
122    PSignNet GetSubGraph(const int& N1, const int& N2);
123    PSignNet GetSubGraph(const int& N1, const int& N2, const int& N3);
124    void CountTriadClose(const int& SrcNId, const int& DstNId, const int& Sign, const double& SrcOutPlusProb,
125      const double& DstInPlusProb, const bool& OnlySimpleTriads=false);
126    void CountTriad3to4Edges(const int& SrcNId, const int& DstNId, const int& Sign, const double& SrcOutPlusProb,
127      const double& DstInPlusProb);
128    void CountTriadCloseVec(const int& SrcNId, const int& DstNId, const int& Sign);
129    int IsSameOpnTriad(const PSignNet& Net1, const PSignNet& Net2);
130    int GetOpnTriadId(const PSignNet& Net1);
131    bool IsSameTriad(const PSignNet& Net1, const PSignNet& Net2, const TIntV& Perm) const;
132    bool IsSameTriad(const PSignNet& Net1, const PSignNet& Net2, int& PermId) const;
133    int GetTriadId(const PSignNet& Net1);
134    void GetEdgeDiff(const PSignNet& Net1, const PSignNet& Net2, int& SrcNId, int& DstNId, int& Sign);
135    static double GetStatusDelta(const PSignNet& Net, const int& NId1, const int& NId2);
136    static double GetStatus(const PSignNet& Net, const int& NId);
137    bool IsStatusFrac(const int& OpnTriadId, const bool& DstNode=true) const;
138    bool IsStatusSurp(const int& OpnTriadId, const bool& DstNode=true) const;
139    bool IsBalanceFrac(const int& OpnTriadId) const;
140    bool IsBalanceSurp(const int& OpnTriadId) const;
141    void PrintInfo() const;
142    void SaveCloseTriadTxt(const TStr& FNmPref, const bool& DrawNets=true, const bool& PlotHists=true);
143    void DrawCloseTriad(const TStr& FNmPref, const int& OpnTriadId, const TStr& Label="");
144    void SaveTriad3to4Edges(const TStr& FNmPref);
145    void SaveTriadCloseVec(const TStr& FNmPref);
146    static char GetEdgeChar(const PSignNet& Net, const int& n1, const int& n2);
147    static void EpinionsTriadEvolution(const bool& OnlySimpleTriads=false);
148    static void EpinionsStat();
149  };
150  class TEdgeSignPred {
151  public:
152    PSignNet Network;
153    THash<TStr, TIntQu> ResH; 
154    int MinCmnNbrs;
155  public:
156    TEdgeSignPred() : Network(TSignNet::New()), MinCmnNbrs(0) { }
157    void AddEdge(const int& SrcNId, const int& DstNId, const int& TrueSign) {
158      if (DstNId == SrcNId || Network->IsEdge(DstNId, SrcNId)) { return; }
159      Network->AddNode(SrcNId);  Network->AddNode(DstNId);
160      Network->AddEdge(SrcNId, DstNId, TrueSign);
161      if (MinCmnNbrs>0 && MinCmnNbrs>TSnap::GetCmnNbrs(Network, SrcNId, DstNId)) { return; }
162      PredictRandom(SrcNId, DstNId, TrueSign);
163      PredictOutSign(SrcNId, DstNId, TrueSign);
164      PredictInSign(SrcNId, DstNId, TrueSign);
165      PredictStatus(SrcNId, DstNId, TrueSign);
166      PredictBalance(SrcNId, DstNId, TrueSign);
167    }
168    void PredictOnStaticNet(const bool& SameNPlusNMinus) {
169      printf("\nPredict static network: MinCmnNbrs  %d\n", MinCmnNbrs);
170      ResH.Clr();
171      TIntTrV EdgeV;
172      int NegCnt=0;
173      for (TSignNet::TEdgeI EI = Network->BegEI(); EI < Network->EndEI(); EI++) {
174        if (MinCmnNbrs>0 && MinCmnNbrs>TSnap::GetCmnNbrs(Network, EI.GetSrcNId(), EI.GetDstNId())) { continue; }
175        EdgeV.Add(TIntTr(EI.GetSrcNId(), EI.GetDstNId(), EI()));
176        if (EI() == -1) { NegCnt++; }
<span onclick='openModal()' class='match'>177      }
178      int PlusCnt=0, MinusCnt=0;
179      EdgeV.Shuffle(TInt::Rnd);
180      for (int e = 0; e < EdgeV.Len(); e++) {
</span>181        const int SrcNId = EdgeV[e].Val1;
182        const int DstNId = EdgeV[e].Val2;
183        const int TrueSign = EdgeV[e].Val3;
184        if (SameNPlusNMinus) {
185          if (TrueSign==1 && PlusCnt>=NegCnt) { continue; }
186          if (TrueSign==-1 && MinusCnt>=NegCnt) { continue; }
187        }
188        if (TrueSign==1) { PlusCnt++; } else { MinusCnt++; }
189        Network->DelEdge(SrcNId, DstNId);
190        PredictRandom(SrcNId, DstNId, TrueSign);
191        PredictOutSign(SrcNId, DstNId, TrueSign);
192        PredictInSign(SrcNId, DstNId, TrueSign);
193        PredictStatus(SrcNId, DstNId, TrueSign);
194        PredictBalance(SrcNId, DstNId, TrueSign);
195        Network->AddEdge(SrcNId, DstNId, TrueSign);
196      }
197      printf("%d %d\n", PlusCnt, MinusCnt);
198      PrintRes();
199    }
200    void AddPred(const TStr& Method, const int& PredSign, const int& TrueSign) {
201      TIntQu& Q = ResH.AddDat(Method);
202      if (TrueSign == 1) { if (PredSign == 1) { Q.Val1++; } else { Q.Val2++; } }
203      else { if (PredSign == 1) { Q.Val3++; } else { Q.Val4++; } }
204    }
205    void PredictRandom(const int& SrcNId, const int& DstNId, const int& TrueSign) {
206      AddPred("Random", 1, TrueSign);
207    }
208    void PredictOutSign(const int& SrcNId, const int& DstNId, const int& TrueSign) {
209      TSignNet::TNodeI NI = Network->GetNI(SrcNId);
210      int plusCnt=0;
211      for (int e = 0; e < NI.GetOutDeg(); e++) {
212        plusCnt += NI.GetOutEDat(e); }
213      if (plusCnt >= 0) { AddPred("OutSign", 1, TrueSign); }
214      else { AddPred("OutSign", -1, TrueSign); }
215    }
216    void PredictInSign(const int& SrcNId, const int& DstNId, const int& TrueSign) {
217      TSignNet::TNodeI NI = Network->GetNI(DstNId);
218      int plusCnt=0;
219      for (int e = 0; e < NI.GetInDeg(); e++) {
220        plusCnt += NI.GetInEDat(e); }
221      if (plusCnt >= 0) { AddPred("InSign", 1, TrueSign); }
222      else { AddPred("InSign", -1, TrueSign); }
223    }
224    void PredictStatus(const int& SrcNId, const int& DstNId, const int& TrueSign) {
225      TIntV NbrV;
226      TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
227      double SrcS=0, DstS=0;
228      for (int n = 0; n < NbrV.Len(); n++) {
229        PSignNet TriadNet = Network->GetTriad(SrcNId, DstNId, NbrV[n]); 
230        SrcS += TSignMicroEvol::GetStatus(TriadNet, 0)>=0 ? 1:-1;
231        DstS += TSignMicroEvol::GetStatus(TriadNet, 1)>=0 ? 1:-1;
232      }
233      if (SrcS > 0) { AddPred("SrcStat", -1, TrueSign); }
234      else { AddPred("SrcStat", 1, TrueSign); }
235      if (DstS > 0) { AddPred("DstStat", 1, TrueSign); }
236      else { AddPred("DstStat", -1, TrueSign); }
237      if (SrcS > DstS) { AddPred("StatDif", -1, TrueSign); }
238      else { AddPred("StatDif", 1, TrueSign); }
239    }
240    void PredictBalance(const int& SrcNId, const int& DstNId, const int& TrueSign) {
241      TIntV NbrV;
242      TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
243      int Bal=0;
244      for (int n = 0; n < NbrV.Len(); n++) {
245        const int E1 = Network->IsEdge(SrcNId, NbrV[n])? Network->GetEDat(SrcNId, NbrV[n]) : Network->GetEDat(NbrV[n], SrcNId);
246        const int E2 = Network->IsEdge(DstNId, NbrV[n])? Network->GetEDat(DstNId, NbrV[n]) : Network->GetEDat(NbrV[n], DstNId);
247        if (E1*E2 == 1) { Bal++; }
248      }
249      if (Bal >= NbrV.Len()/2) { AddPred("Balance", +1, TrueSign); }
250      else { AddPred("Balance", -1, TrueSign); }
251    }
252    void PrintRes() const {
253      printf("method\t++\t+-\t-+\t--\tacc\n");
254      for (int i = 0; i < ResH.Len(); i++) {
255        const TIntQu& Q = ResH[i];
256        printf("%s\t%d\t%d\t%d\t%d\t%f\n", ResH.GetKey(i).CStr(),
257          Q.Val1(), Q.Val2(), Q.Val3(), Q.Val4(), double(Q.Val1+Q.Val4)/double(Q.Val1+Q.Val2+Q.Val3+Q.Val4));
258      }
259      printf("\n");
260    }
261    bool SaveEdgeAttrs(FILE *F, const int& SrcNId,const int& DstNId, const bool& SaveEol=true) {
262      TIntV NbrV;
263      bool DelEdge = false;
264      const int TrueSign = Network->IsEdge(SrcNId, DstNId) ? (int) Network->GetEDat(SrcNId, DstNId) : 0;
265      TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
266      if (Network->IsEdge(SrcNId, DstNId)) { Network->DelEdge(SrcNId, DstNId); DelEdge=true; }
267      TSignNet::TNodeI SrcNI = Network->GetNI(SrcNId);
268      TSignNet::TNodeI DstNI = Network->GetNI(DstNId);
269      int srcOutPlus=0, dstInPlus=0;
270      for (int e = 0; e < SrcNI.GetOutDeg(); e++) { srcOutPlus += SrcNI.GetOutEDat(e)>0 ? 1:0; }
271      for (int e = 0; e < DstNI.GetInDeg(); e++) { dstInPlus += DstNI.GetInEDat(e)>0 ? 1:0; }
272      fprintf(F, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d", TrueSign==1?1:0, SrcNI.GetOutDeg(), srcOutPlus,
273        SrcNI.GetOutDeg()-srcOutPlus, DstNI.GetInDeg(), dstInPlus, DstNI.GetInDeg()-dstInPlus, NbrV.Len());
274      THash<TIntPr, TInt> H;
275      for (int i = 1; i <=2; i++) {
276        for (int j = 1; j <=2; j++) {
277          H.AddDat(TIntPr(i,j)); H.AddDat(TIntPr(i,-j)); H.AddDat(TIntPr(-i,j)); H.AddDat(TIntPr(-i,-j));
278      } }
279      for (int n = 0; n < NbrV.Len(); n++) {
280        int AC=0, CB=0; 
281        const int Mid = NbrV[n];
282        if (Network->IsEdge(SrcNId, Mid)) { AC = 1 * Network->GetEDat(SrcNId, Mid); }
283        else  { AC = 2 * Network->GetEDat(Mid, SrcNId); }
284        if (Network->IsEdge(Mid, DstNId)) { CB = 1 * Network->GetEDat(Mid, DstNId); }
285        else  { CB = 2 * Network->GetEDat(DstNId, Mid); }
286        if (! (AC != 0 && CB != 0)) {
287          Network->PrintInfo();
288          IAssert(Network->IsNode(Mid));
289          printf("\nES: %d\t%d\n", (int)Network->IsEdge(SrcNId, Mid), (int)Network->IsEdge(Mid, SrcNId));
290          printf("\nED: %d\t%d\n", (int)Network->IsEdge(DstNId, Mid), (int)Network->IsEdge(Mid, DstNId));
291          if (Network->IsEdge(SrcNId, Mid)) { printf("S1: %d\n", (int)Network->GetEDat(SrcNId, Mid)); }
292          else  { printf("S2: %d\n", (int)Network->GetEDat(Mid, SrcNId)); }
293          if (Network->IsEdge(Mid, DstNId)) { printf("D1: %d\n", (int)Network->GetEDat(Mid, DstNId)); }
294          else  { printf("D2: %d\n", (int)Network->GetEDat(DstNId, Mid)); }
295        }
296        IAssert(Network->IsEdge(SrcNId, Mid) || Network->IsEdge(Mid, SrcNId));
297        IAssert(Network->IsEdge(DstNId, Mid) || Network->IsEdge(Mid, DstNId));
298        IAssert(AC != 0 && CB != 0);
299        H.AddDat(TIntPr(AC, CB)) += 1;
300      }
301      fprintf(F, "\t%d\t%d\t%d\t%d", (int)H.GetDat(TIntPr(1,1)), (int)H.GetDat(TIntPr(1,-1)), (int)H.GetDat(TIntPr(-1,1)), (int)H.GetDat(TIntPr(-1,-1)));
302      fprintf(F, "\t%d\t%d\t%d\t%d", (int)H.GetDat(TIntPr(1,2)), (int)H.GetDat(TIntPr(1,-2)), (int)H.GetDat(TIntPr(-1,2)), (int)H.GetDat(TIntPr(-1,-2)));
303      fprintf(F, "\t%d\t%d\t%d\t%d", (int)H.GetDat(TIntPr(2,1)), (int)H.GetDat(TIntPr(2,-1)), (int)H.GetDat(TIntPr(-2,1)), (int)H.GetDat(TIntPr(-2,-1)));
304      fprintf(F, "\t%d\t%d\t%d\t%d", (int)H.GetDat(TIntPr(2,2)), (int)H.GetDat(TIntPr(2,-2)), (int)H.GetDat(TIntPr(-2,2)), (int)H.GetDat(TIntPr(-2,-2)));
305      if (SaveEol) { fprintf(F, "\n"); }
306      if (DelEdge) { Network->AddEdge(SrcNId, DstNId, TrueSign); }
307      return true;
308    }
309    void SaveEdgeSignPredFeatures(const TStr& OutFNm) {
310      FILE *F = fopen(TStr::Fmt("tr16pred-%s-nbr%d.tab", OutFNm.CStr(), MinCmnNbrs).CStr(), "wt");
311      fprintf(F, "Edge\tAOutDeg\tAOutPlus\tAOutMinus\tBInDeg\tBInPlus\tBInMinus\tCmnNbrs");
312      fprintf(F, "\tFFpp\tFFpm\tFFmp\tFFmm"); 
313      fprintf(F, "\tFBpp\tFBpm\tFBmp\tFBmm"); 
314      fprintf(F, "\tBFpp\tBFpm\tBFmp\tBFmm"); 
315      fprintf(F, "\tBBpp\tBBpm\tBBmp\tBBmm\n"); 
316      TIntV NbrV;
317      int NegEdgeCnt=0;
318      TIntPrV EdgeV;
319      for (TSignNet::TEdgeI EI = Network->BegEI(); EI < Network->EndEI(); EI++) {
320        if (EI()==-1) { NegEdgeCnt++; }
321        EdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
322      }
323      EdgeV.Shuffle(TInt::Rnd);
324      NegEdgeCnt *= 2;
325      for (int edge = 0; edge < EdgeV.Len(); edge++) {
326        const int SrcNId = EdgeV[edge].Val1;
327        const int DstNId = EdgeV[edge].Val2;
328        const int TrueSign = Network->GetEDat(SrcNId, DstNId);
329        const int CmnNbrs = TSnap::GetCmnNbrs(Network, SrcNId, DstNId);
330        if (CmnNbrs < MinCmnNbrs) { continue; }
331        if (TrueSign==1 && NegEdgeCnt <= 0) { continue; }
332        if (SaveEdgeAttrs(F, SrcNId, DstNId) && TrueSign==1) { NegEdgeCnt--; }
333      }
334      fclose(F);
335    }
336    bool HasMinusEdge(const int& NId) const {
337      const TSignNet::TNodeI NI = Network->GetNI(NId);
338      for (int i = 0; i < NI.GetOutDeg(); i++) {
339        if (NI.GetOutEDat(i)==-1) { return true; } }
340      for (int i = 0; i < NI.GetInDeg(); i++) {
341        if (NI.GetInEDat(i)==-1) { return true; } }
342      return false;
343    }
344    void SaveEdgePredFeatures(const TStr& OutFNm, const int& SavePairs) {
345      FILE *F = fopen(TStr::Fmt("edgePred-%s-nbr%d.tab", OutFNm.CStr(), MinCmnNbrs).CStr(), "wt");
346      fprintf(F, "Edge\tAOutDeg\tAOutPlus\tAOutMinus\tBInDeg\tBInPlus\tBInMinus\tCmnNbrs");
347      fprintf(F, "\tFFpp\tFFpm\tFFmp\tFFmm"); 
348      fprintf(F, "\tFBpp\tFBpm\tFBmp\tFBmm"); 
349      fprintf(F, "\tBFpp\tBFpm\tBFmp\tBFmm"); 
350      fprintf(F, "\tBBpp\tBBpm\tBBmp\tBBmm\tCmnPlus\n"); 
351      TIntPrV EdgeV, NoEdgeV;
352      TIntV NbrV, Hop2NIdV;
353      TIntH EmbeddH;
354      PSignNet PlusNet = TSnap::GetEDatSubGraph(Network, 1, 0);
355      PlusNet->PrintInfo();
356      for (TSignNet::TEdgeI EI = PlusNet->BegEI(); EI < PlusNet->EndEI(); EI++) {
357        EdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
358      }
359      EdgeV.Shuffle(TInt::Rnd);
360      int SaveTrust=0, SaveNoEdge=0;
361      for (int e = 0; e < EdgeV.Len(); e++) {
362        int Src = EdgeV[e].Val1, Dst = EdgeV[e].Val2;
363        if (! HasMinusEdge(Src) || ! HasMinusEdge(Dst)) { continue; }
364        Hop2NIdV.Clr(false);
365        TSnap::GetNodesAtHop(PlusNet, Src, 2, Hop2NIdV);
366        const int CmnNbrs = TSnap::GetCmnNbrs(PlusNet, Src, Dst, NbrV);
367        if (CmnNbrs >= MinCmnNbrs && SaveTrust<SavePairs) {
368          SaveEdgeAttrs(F, Src, Dst, false);
369          fprintf(F, "\t%d\n", CmnNbrs);
370          EmbeddH.AddDat(CmnNbrs) += 1;
371          printf(" %d", CmnNbrs);
372          SaveTrust++;
373        }
374        for (int n = 0; n < Hop2NIdV.Len(); n++) {
375          const int CmnNbrs2 = TSnap::GetCmnNbrs(PlusNet, Src, Hop2NIdV[n], NbrV);
376          if(EmbeddH.IsKey(CmnNbrs2) && EmbeddH.GetDat(CmnNbrs2) > 0 && SaveNoEdge<SavePairs) {
377            SaveEdgeAttrs(F, Src, Hop2NIdV[n], false);
378            fprintf(F, "\t%d\n", CmnNbrs2);
379            printf("x");
380            EmbeddH.GetDat(CmnNbrs2)--;
381            SaveNoEdge++;
382          }
383        }
384        if (SaveTrust==SavePairs && SaveNoEdge==SavePairs) {
385          printf("%d pairs of nodes saved\ndone.\n", SaveNoEdge);
386          break;
387        }
388      }
389      fclose(F);
390    }
391    void SaveEdgePredFeatures2(const TStr& OutFNm, const int& SavePairs) {
392      FILE *F = fopen(TStr::Fmt("edgePred2-%s-nbr%d.tab", OutFNm.CStr(), MinCmnNbrs).CStr(), "wt");
393      fprintf(F, "Edge\tAOutDeg\tAOutPlus\tAOutMinus\tBInDeg\tBInPlus\tBInMinus\tCmnNbrs");
394      fprintf(F, "\tFFpp\tFFpm\tFFmp\tFFmm"); 
395      fprintf(F, "\tFBpp\tFBpm\tFBmp\tFBmm"); 
396      fprintf(F, "\tBFpp\tBFpm\tBFmp\tBFmm"); 
397      fprintf(F, "\tBBpp\tBBpm\tBBmp\tBBmm\tCmnPlus\n"); 
398      TIntPrV EdgeV, NoEdgeV;
399      TIntV NbrV, Hop2NIdV;
400      THash<TInt, TIntPrV> EmbedEdgeVH;
401      TIntH EmbedH;
402      PSignNet PlusNet = TSnap::GetEDatSubGraph(Network, 1, 0);
403      PlusNet->PrintInfo();
404      for (TSignNet::TEdgeI EI = PlusNet->BegEI(); EI < PlusNet->EndEI(); EI++) {
405        const int Cmn = TSnap::GetCmnNbrs(PlusNet, EI.GetSrcNId(), EI.GetDstNId(), NbrV);
406        EmbedEdgeVH.AddDat(Cmn).Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
407        EmbedH.AddDat(Cmn) += 1;
408      }
409      for (int e = 0; e < EmbedEdgeVH.Len(); e++) {
410        EmbedEdgeVH[e].Shuffle(TInt::Rnd);
411      }
412      for (int Saved = 0; Saved < SavePairs; ) {
413        const int SrcNId = Network->GetRndNId();
414        const int DstNId = Network->GetRndNId();
415        if (SrcNId == DstNId || Network->IsEdge(SrcNId, DstNId, false)) { continue; }
416        const int Cmn = TSnap::GetCmnNbrs(PlusNet, SrcNId, DstNId, NbrV);
417        if (Cmn < MinCmnNbrs) { continue; }
418        if (! EmbedH.IsKey(Cmn) || EmbedH.GetDat(Cmn)==0) { continue; }
419        const int i = EmbedH.GetDat(Cmn)-1;
420        SaveEdgeAttrs(F, EmbedEdgeVH.GetDat(Cmn)[i].Val1, EmbedEdgeVH.GetDat(Cmn)[i].Val2, false);  fprintf(F, "\t%d\n", Cmn);
421        SaveEdgeAttrs(F, SrcNId, DstNId, false);  fprintf(F, "\t%d\n", Cmn);
422        printf(".");
423        EmbedH.GetDat(Cmn)--;
424        Saved++;
425      }
426      fclose(F);
427    }
428  };
429  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.cpp</h3>
            <pre><code>1  double TMath::E=2.71828182845904523536;
2  double TMath::Pi=3.14159265358979323846;
3  double TMath::LogOf2=log(double(2));
4  void TSpecFunc::GammaPSeries&bsol;*gser*/(
5   double& gamser, const double& a, const double& x, double& gln){
6    static const int ITMAX=100;
7    static const double EPS=3.0e-7;
8    int n;
9    double sum, del, ap;
10    gln=LnGamma(a);
11    if (x <= 0.0){
12      IAssert(x>=0); &bsol;*if (x < 0.0) nrerror("x less than 0 in routine gser");*/
13      gamser=0.0;
14      return;
15    } else {
16      ap=a;
17      del=sum=1.0/a;
18      for (n=1; n<=ITMAX; n++){
19        ++ap;
20        del *= x/ap;
21        sum += del;
22        if (fabs(del) < fabs(sum)*EPS){
23          gamser=sum*exp(-x+a*log(x)-(gln));
24          return;
25        }
26      }
27      Fail; &bsol;*nrerror("a too large, ITMAX too small in routine gser");*/
28      return;
29    }
30  }
31  void TSpecFunc::GammaQContFrac&bsol;*gcf*/(
32   double& gammcf, const double& a, const double& x, double& gln){
33    static const int ITMAX=100;
34    static const double EPS=3.0e-7;
35    static const double  FPMIN=1.0e-30;
36    int i;
37    double an, b, c, d, del, h;
38    gln=LnGamma(a);
39    b=x+1.0-a;
40    c=1.0/FPMIN;
41    d=1.0/b;
42    h=d;
43    for (i=1;i<=ITMAX;i++){
44      an = -i*(i-a);
45      b += 2.0;
46      d=an*d+b;
47      if (fabs(d) < FPMIN) d=FPMIN;
48      c=b+an/c;
49      if (fabs(c) < FPMIN) c=FPMIN;
50      d=1.0/d;
51      del=d*c;
52      h *= del;
53      if (fabs(del-1.0) < EPS) break;
54    }
55    IAssert(i<=ITMAX);
56    gammcf=exp(-x+a*log(x)-(gln))*h;
57  }
58  double TSpecFunc::GammaQ&bsol;*gammq*/(const double& a, const double& x){
59    IAssert((x>=0)&&(a>0));
60    double gamser, gammcf, gln;
61    if (x<(a+1.0)){
62      GammaPSeries(gamser,a,x,gln);
63      return 1.0-gamser;
64    } else {
65      GammaQContFrac(gammcf,a,x,gln);
66      return gammcf;
67    }
68  }
69  double TSpecFunc::LnGamma&bsol;*gammln*/(const double& xx){
70    double x, y, tmp, ser;
71    static double cof[6]={76.18009172947146,-86.50532032941677,
72            24.01409824083091,-1.231739572450155,
73            0.1208650973866179e-2,-0.5395239384953e-5};
74    int j;
75    y=x=xx;
76    tmp=x+5.5;
77    tmp -= (x+0.5)*log(tmp);
78    ser=1.000000000190015;
79    for (j=0;j<=5;j++) ser += cof[j]/++y;
80    return -tmp+log(2.5066282746310005*ser/x);
81  }
82  double TSpecFunc::LnComb(const int& n, const int& k){
83    return LnGamma(n+1)-LnGamma(k+1)-LnGamma(n-k+1);
84  }
85  double TSpecFunc::BetaCf(const double& a, const double& b, const double& x){
86    static const double MAXIT=100;
87    static const double EPS=3.0e-7;
88    static const double FPMIN=1.0e-30;
89    int m,m2;
90    double aa,c,d,del,h,qab,qam,qap;
91    qab=a+b;
92    qap=a+1.0;
93    qam=a-1.0;
94    c=1.0;
95    d=1.0-qab*x/qap;
96    if (fabs(d) < FPMIN) d=FPMIN;
97    d=1.0/d;
98    h=d;
99    for (m=1;m<=MAXIT;m++) {
100      m2=2*m;
101      aa=m*(b-m)*x/((qam+m2)*(a+m2));
102      d=1.0+aa*d;
103      if (fabs(d) < FPMIN) d=FPMIN;
104      c=1.0+aa/c;
105      if (fabs(c) < FPMIN) c=FPMIN;
106      d=1.0/d;
107      h *= d*c;
108      aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
109      d=1.0+aa*d;
110      if (fabs(d) < FPMIN) d=FPMIN;
111      c=1.0+aa/c;
112      if (fabs(c) < FPMIN) c=FPMIN;
113      d=1.0/d;
114      del=d*c;
115      h *= del;
116      if (fabs(del-1.0) < EPS) break;
117    }
118    if (m > MAXIT){Fail;}
119    return h;
120  }
121  double TSpecFunc::BetaI(const double& a, const double& b, const double& x){
122    double bt;
123    if (x < 0.0 || x > 1.0){Fail;} 
124    if (x == 0.0 || x == 1.0) bt=0.0;
125    else
126      bt=exp(LnGamma(a+b)-LnGamma(a)-LnGamma(b)+a*log(x)+b*log(1.0-x));
127    if (x < (a+1.0)/(a+b+2.0))
128      return bt*BetaCf(a,b,x)/a;
129    else
130      return 1.0-bt*BetaCf(b,a,1.0-x)/b;
131  }
132  void TSpecFunc::LinearFit(
133   const TVec<TFltPr>& XY, double& A, double& B,
134   double& SigA, double& SigB, double& Chi2, double& R2) {
135    int i;
136    double t, sxoss, sx = 0.0, sy = 0.0, st2 = 0.0, ss, sigdat;
137    A = B = SigA = SigB = Chi2 = 0.0;
138    for (i = 0; i < XY.Len(); i++) {
139      sx += XY[i].Val1;
140      sy += XY[i].Val2;
141    }
142    ss = XY.Len();
143    sxoss = sx / ss;
144    for (i = 0; i <XY.Len(); i++) {
145      t = XY[i].Val1 - sxoss;
146      st2 += t*t;
147      B += t * XY[i].Val2;
148    }
149    B /= st2;
150    A = (sy - sx * B) / ss;
151    SigA = sqrt((1.0 + sx * sx / (ss * st2)) / ss);
152    SigB = sqrt(1.0 / st2);
153    for (i = 0; i < XY.Len(); i++)
154      Chi2 += TMath::Sqr(XY[i].Val2 - A - B * XY[i].Val1);
155    sigdat = sqrt(Chi2 / (XY.Len() - 2));
156    SigA *= sigdat;
157    SigB *= sigdat;
158    { double N = XY.Len(), sXY=0.0, sX=0.0, sY=0.0, sSqX=0.0, sSqY=0.0;
159    for (int s =0; s < XY.Len(); s++) {
160      sX += XY[s].Val1;  sY += XY[s].Val2;
161      sXY += XY[s].Val1 * XY[s].Val2;
162      sSqX += TMath::Sqr(XY[s].Val1);
163      sSqY += TMath::Sqr(XY[s].Val2);
164    }
165    R2 = TMath::Sqr(N*sXY - sX*sY) / ((N*sSqX - sX*sX) * (N*sSqY - sY*sY)); }
166    if (1.1 < R2 || -1.1 > R2) R2 = 0.0;
167    if (_isnan(A) || ! _finite(A)) A = 0.0;
168    if (_isnan(B) || ! _finite(B)) B = 0.0;
169  }
170  void TSpecFunc::PowerFit(const TVec<TFltPr>& XY, double& A, double& B,
171   double& SigA, double& SigB, double& Chi2, double& R2) {
172    double AA, BB;
173    TFltPrV LogXY(XY.Len(), 0);
174    for (int s = 0; s < XY.Len(); s++) {
175      LogXY.Add(TFltPr(log((double)XY[s].Val1), log((double)XY[s].Val2)));
176    }
177    TSpecFunc::LinearFit(LogXY, AA, BB, SigA, SigB, Chi2, R2);
178    A = exp(AA);  B = BB;
179    if (_isnan(AA) || ! _finite(AA)) A = 0.0;
180    if (_isnan(BB) || ! _finite(BB)) B = 0.0;
181  }
182  void TSpecFunc::LogFit(const TVec<TFltPr>& XY, double& A, double& B,
183   double& SigA, double& SigB, double& Chi2, double& R2) {
184    TFltPrV LogXY(XY.Len(), 0);
185    for (int s = 0; s < XY.Len(); s++) {
186      LogXY.Add(TFltPr(log((double)XY[s].Val1), XY[s].Val2));
187    }
188    TSpecFunc::LinearFit(LogXY, A, B, SigA, SigB, Chi2, R2);
189  }
190  void TSpecFunc::ExpFit(const TVec<TFltPr>& XY, double& A, double& B,
191   double& SigA, double& SigB, double& Chi2, double& R2) {
192    TFltPrV XLogY(XY.Len(), 0);
193    double AA, BB;
194    for (int s = 0; s < XY.Len(); s++) {
195      XLogY.Add(TFltPr(XY[s].Val1, log((double)XY[s].Val2)));
196    }
197    TSpecFunc::LinearFit(XLogY, AA, BB, SigA, SigB, Chi2, R2);
198    A = exp(AA);
199    B = BB;
200  }
201  double TSpecFunc::Entropy(const TIntV& ValV) {
202    TFltV NewValV(ValV.Len());
203    for (int i = 0; i < ValV.Len(); i++) { NewValV[i] = ValV[i]; }
204    return Entropy(NewValV);
205  }
206  double TSpecFunc::Entropy(const TFltV& ValV) {
207    double Sum=0, Ent=0;
208    for (int i = 0; i < ValV.Len(); i++) {
209      const double& Val = ValV[i];
210      if (Val > 0.0) { Ent -= Val * log(Val);  Sum += Val; }
211    }
212    if (Sum > 0.0) {
213      Ent /= Sum;
214      Ent += log(Sum);
215      Ent /= TMath::LogOf2;
216    } else return 1.0;
217    return Ent;
218  }
219  void TSpecFunc::EntropyFracDim(const TIntV& ValV, TFltV& EntropyV) {
220    TFltV NewValV(ValV.Len());
221    for (int i = 0; i < ValV.Len(); i++) { 
222      IAssert(ValV[i]==1 || ValV[i] == 0);
223      NewValV[i] = ValV[i]; 
224    }
225    EntropyFracDim(NewValV, EntropyV);
226  }
227  void TSpecFunc::EntropyFracDim(const TFltV& ValV, TFltV& EntropyV) {
228    TFltV ValV1, ValV2;
229    int Pow2 = 1;
230    while (2*Pow2 <= ValV.Len()) { Pow2 *= 2; }
231    ValV1.Gen(Pow2);
232    for (int i = 0; i < Pow2; i++) { ValV1[i] = ValV[i]; 
233      IAssert(ValV[i]==1.0 || ValV[i] == 0.0); }
234    EntropyV.Clr();
235    EntropyV.Add(Entropy(ValV1)); 
236    while (ValV1.Len() > 2) {
237      ValV2.Gen(ValV1.Len() / 2);
238      for (int i = 0; i < ValV1.Len(); i++) {
239        ValV2[i/2] += ValV1[i];
240      }
241      EntropyV.Add(Entropy(ValV2));
242      ValV1.MoveFrom(ValV2);
243    }
244    EntropyV.Reverse();
245  }
246  double TSpecFunc::EntropyBias(const double& B){
247    static TFltFltH BToP;
248    if (BToP.Empty()) {
249      for (double p = 0.5; p < 1.0; p +=0.0001) {
250        double H = p * log(p) + (1.0-p) * log(1.0 - p);
251        H = -H / log(2.0);
252        BToP.AddDat(TMath::Round(H, 3), p);
253      }
254    }
255    if (BToP.IsKey(TMath::Round(B, 3))) { return BToP.GetDat(TMath::Round(B, 3)); }
256    else { return -1.0; }
257  }
258  double TSpecFunc::GetPowerCoef(const TFltV& XValV, double MinX) {
259    for (int i = 0; MinX <= 0.0 && i < XValV.Len(); i++) { 
260      MinX = XValV[i]; }
261    IAssert(MinX > 0.0);
262    double LnSum=0.0;
263    for (int i = 0; i < XValV.Len(); i++) {
264      if (XValV[i].Val < MinX) continue;
265      LnSum += log(XValV[i] / MinX);
266    }
267    return 1.0 + double(XValV.Len()) / LnSum;
268  }
269  double TSpecFunc::GetPowerCoef(const TFltPrV& XValCntV, double MinX) {
270    for (int i = 0; MinX <= 0.0 && i < XValCntV.Len(); i++) { 
<span onclick='openModal()' class='match'>271      MinX = XValCntV[i].Val1; }
272    IAssert(MinX > 0.0);
273    double NSamples=0.0, LnSum=0.0;
274    for (int i = 0; i < XValCntV.Len(); i++) {
</span>275      if (XValCntV[i].Val1() < MinX) continue;
276      LnSum += XValCntV[i].Val2 * log(XValCntV[i].Val1 / MinX);
277      NSamples += XValCntV[i].Val2;
278    }
279    return 1.0 + NSamples / LnSum;
280  }
281  TMom::TMom(const TFltV& _ValV):
282    ValWgtV(_ValV.Len(), 0),
283    SumW(), ValSumW(),
284    UsableP(false), UnusableVal(-1),
285    Mn(), Mx(),
286    Mean(), Vari(), SDev(), SErr(),
287    Median(), Quart1(), Quart3(),
288    DecileV(), PercentileV(){
289    for (int ValN=0; ValN<_ValV.Len(); ValN++){Add(_ValV[ValN], 1);}
290    Def();
291  }
292  void TMom::Def(){
293    IAssert(!DefP); DefP=true;
294    UsableP=(SumW>0)&&(ValWgtV.Len()>0);
295    if (UsableP){
296      Mn=ValWgtV[0].Val1;
297      Mx=ValWgtV[0].Val1;
298      Mean=ValSumW/SumW;
299      Vari=0;
300      if (ValWgtV.Len()>1){
301        for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
302          const double Val=ValWgtV[ValN].Val1;
303          Vari+=ValWgtV[ValN].Val2*TMath::Sqr(Val-Mean);
304          if (Val<Mn){Mn=Val;}
305          if (Val>Mx){Mx=Val;}
306        }
307        Vari=Vari/SumW;
308        if (Vari > 0.0 && SumW > 0.0) {
309          SErr=sqrt(double(Vari))/sqrt(double(SumW)); 
310        } else { SErr = Mx; } 
311      }
312      SDev=sqrt(double(Vari));
313      ValWgtV.Sort();
314      double CurSumW = 0;
315      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
316        CurSumW += ValWgtV[ValN].Val2;
317        if (CurSumW > 0.5*SumW) { 
318          Median = ValWgtV[ValN].Val1; break; }
319        else if (CurSumW == 0.5*SumW) {
320          Median = 0.5 * (ValWgtV[ValN].Val1+ValWgtV[ValN+1].Val1); break; }
321      }
322      Quart1=Quart3=TFlt::Mn;
323      CurSumW = 0;
324      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
325        CurSumW += ValWgtV[ValN].Val2;
326        if (Quart1==TFlt::Mn) {
327          if (CurSumW > 0.25*SumW) {  Quart1 = ValWgtV[ValN].Val1; }
328        } 
329        if (Quart3==TFlt::Mn) {
330          if (CurSumW > 0.75*SumW) { Quart3 = ValWgtV[ValN].Val1; }
331        }
332      }
333      THash<TFlt, TFlt> ValWgtH;
334      for (int i = 0; i < ValWgtV.Len(); i++) {
335        ValWgtH.AddDat(ValWgtV[i].Val1) += ValWgtV[i].Val2; }
336      Mode = TFlt::Mn; double MxWgt=TFlt::Mn;
337      for (int v = 0; v < ValWgtH.Len(); v++) {
338        if (ValWgtH[v] > MxWgt) { MxWgt=ValWgtH[v]; Mode=ValWgtH.GetKey(v); }
339      }
340      CurSumW = 0;
341      int DecileN = 1, PercentileN = 1;
342      DecileV.Gen(11);  PercentileV.Gen(101);
343      DecileV[0]=Mn; DecileV[10]=Mx;
344      PercentileV[0]=Mn; PercentileV[100]=Mx;
345      for (int ValN=0; ValN<ValWgtV.Len(); ValN++){
346        CurSumW += ValWgtV[ValN].Val2;
347        if (CurSumW > SumW*DecileN*0.1) { 
348          DecileV[DecileN] = ValWgtV[ValN].Val1;  DecileN++; }
349        if (CurSumW > SumW*PercentileN*0.01) {
350          PercentileV[PercentileN] = ValWgtV[ValN].Val1;  PercentileN++; }
351      }
352    }
353    ValWgtV.Clr();
354  }
355  double TMom::GetByNm(const TStr& MomNm) const {
356    if (MomNm=="Mean"){return GetMean();}
357    else if (MomNm=="Vari"){return GetVari();}
358    else if (MomNm=="SDev"){return GetSDev();}
359    else if (MomNm=="SErr"){return GetSErr();}
360    else if (MomNm=="Median"){return GetMedian();}
361    else if (MomNm=="Quart1"){return GetQuart1();}
362    else if (MomNm=="Quart3"){return GetQuart3();}
363    else if (MomNm=="Decile0"){return GetDecile(0);}
364    else if (MomNm=="Decile1"){return GetDecile(1);}
365    else if (MomNm=="Decile2"){return GetDecile(2);}
366    else if (MomNm=="Decile3"){return GetDecile(3);}
367    else if (MomNm=="Decile4"){return GetDecile(4);}
368    else if (MomNm=="Decile5"){return GetDecile(5);}
369    else if (MomNm=="Decile6"){return GetDecile(6);}
370    else if (MomNm=="Decile7"){return GetDecile(7);}
371    else if (MomNm=="Decile8"){return GetDecile(8);}
372    else if (MomNm=="Decile9"){return GetDecile(9);}
373    else if (MomNm=="Decile10"){return GetDecile(10);}
374    else {Fail; return 0;}
375  }
376  TStr TMom::GetStrByNm(const TStr& MomNm, char* FmtStr) const {
377    if (IsUsable()){
378      if (FmtStr==NULL){
379        return TFlt::GetStr(GetByNm(MomNm));
380      } else {
381        return TFlt::GetStr(GetByNm(MomNm), FmtStr);
382      }
383    } else {
384      return "X";
385    }
386  }
387  TStr TMom::GetStr(
388   const char& SepCh, const char& DelimCh,
389   const bool& DecileP, const bool& PercentileP, const TStr& FmtStr) const {
390    TChA ChA;
391    if (IsUsable()){
392      ChA+="["; ChA+=SepCh;
393      ChA+="Vals"; ChA+=DelimCh; ChA+=TInt::GetStr(GetVals()); ChA+=SepCh;
394      ChA+="Min"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMn(), FmtStr.CStr()); ChA+=SepCh;
395      ChA+="Max"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMx(), FmtStr.CStr()); ChA+=SepCh;
396      ChA+="Mean"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMean(), FmtStr.CStr()); ChA+=SepCh;
397      ChA+="SDev"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetSDev(), FmtStr.CStr()); ChA+=SepCh;
398      ChA+="Quart1"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetQuart1(), FmtStr.CStr()); ChA+=SepCh;
399      ChA+="Median"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetMedian(), FmtStr.CStr()); ChA+=SepCh;
400      ChA+="Quart3"; ChA+=DelimCh; ChA+=TFlt::GetStr(GetQuart3(), FmtStr.CStr()); ChA+=SepCh;
401      if (DecileP){
402        for (int DecileN=0; DecileN<=10; DecileN++){
403          ChA+="Dec"; ChA+=TInt::GetStr(DecileN);
404          ChA+=DelimCh; ChA+=TFlt::GetStr(GetDecile(DecileN), FmtStr.CStr());
405          ChA+=SepCh;
406        }
407      }
408      if (PercentileP){
409        for (int PercentileN=0; PercentileN<=100; PercentileN++){
410          ChA+="Per"; ChA+=TInt::GetStr(PercentileN);
411          ChA+=DelimCh; ChA+=TFlt::GetStr(GetPercentile(PercentileN), FmtStr.CStr());
412          ChA+=SepCh;
413        }
414      }
415      ChA+="]";
416    } else {
417      ChA="[Unusable]";
418    }
419    return ChA;
420  }
421  TStr TMom::GetNmVStr(const TStr& VarPfx,
422   const char& SepCh, const bool& DecileP, const bool& PercentileP){
423    TChA ChA;
424    ChA+=VarPfx; ChA+="Vals"; ChA+=SepCh;
425    ChA+=VarPfx; ChA+="Min"; ChA+=SepCh;
426    ChA+=VarPfx; ChA+="Max"; ChA+=SepCh;
427    ChA+=VarPfx; ChA+="Mean"; ChA+=SepCh;
428    ChA+=VarPfx; ChA+="SDev"; ChA+=SepCh;
429    ChA+=VarPfx; ChA+="Quart1"; ChA+=SepCh;
430    ChA+=VarPfx; ChA+="Median"; ChA+=SepCh;
431    ChA+=VarPfx; ChA+="Quart3";
432    if (DecileP){
433      ChA+=SepCh;
434      for (int DecileN=0; DecileN<=10; DecileN++){
435        ChA+=VarPfx; ChA+="Dec"; ChA+=TInt::GetStr(DecileN);
436        if (DecileN<10){ChA+=SepCh;}
437      }
438    }
439    if (PercentileP){
440      ChA+=SepCh;
441      for (int PercentileN=0; PercentileN<=100; PercentileN++){
442        ChA+=VarPfx; ChA+="Per"; ChA+=TInt::GetStr(PercentileN);
443        if (PercentileN<100){ChA+=SepCh;}
444      }
445    }
446    return ChA;
447  }
448  TStr TMom::GetValVStr(
449   const char& SepCh, const bool& DecileP, const bool& PercentileP) const {
450    TChA ChA;
451    if (IsUsable()){
452      ChA+=TInt::GetStr(GetVals()); ChA+=SepCh;
453      ChA+=TFlt::GetStr(GetMn()); ChA+=SepCh;
454      ChA+=TFlt::GetStr(GetMx()); ChA+=SepCh;
455      ChA+=TFlt::GetStr(GetMean()); ChA+=SepCh;
456      ChA+=TFlt::GetStr(GetSDev()); ChA+=SepCh;
457      ChA+=TFlt::GetStr(GetQuart1()); ChA+=SepCh;
458      ChA+=TFlt::GetStr(GetMedian()); ChA+=SepCh;
459      ChA+=TFlt::GetStr(GetQuart3()); ChA+=SepCh;
460      if (DecileP){
461        for (int DecileN=0; DecileN<=10; DecileN++){
462          ChA+=TFlt::GetStr(GetDecile(DecileN)); ChA+=SepCh;
463        }
464      }
465      if (PercentileP){
466        for (int PercentileN=0; PercentileN<=100; PercentileN++){
467          ChA+=TFlt::GetStr(GetPercentile(PercentileN)); ChA+=SepCh;
468        }
469      }
470    } else {
471      int Vals=8;
472      if (DecileP){Vals+=11;}
473      if (PercentileP){Vals+=101;}
474      for (int ValN=0; ValN<Vals; ValN++){
475        ChA="[Unusable]";
476        if (ValN<Vals-1){ChA+=SepCh;}
477      }
478    }
479    return ChA;
480  }
481  TCorr::TCorr(const TFltV& ValV1, const TFltV& ValV2):
482    ValVLen(ValV1.Len()), CorrCf(), CorrCfPrb(), FisherZ(){
483    static const double TINY=1.0e-20;
484    IAssert(ValV1.Len()==ValV2.Len());
485    double MeanVal1=0; double MeanVal2=0;
486    {for (int ValN=0; ValN<ValVLen; ValN++){
487      MeanVal1+=ValV1[ValN]; MeanVal2+=ValV2[ValN];}}
488    MeanVal1/=ValVLen; MeanVal2/=ValVLen;
489    double yt, xt;
490    double syy=0.0; double sxy=0.0; double sxx=0.0;
491    {for (int ValN=0; ValN<ValVLen; ValN++){
492      xt=ValV1[ValN]-MeanVal1;
493      yt=ValV2[ValN]-MeanVal2;
494      sxx+=xt*xt;
495      syy+=yt*yt;
496      sxy+=xt*yt;
497    }}
498    if (sxx*syy==0){
499      CorrCf=0; /&bsol;** not in numerical recipes - check why (pojavi se, ko so same nicle)
500    } else {
501      CorrCf=sxy/sqrt(sxx*syy);
502    }
503    double df=ValVLen-2;
504    double t=CorrCf*sqrt(df/((1.0-CorrCf+TINY)*(1.0+CorrCf+TINY)));
505    CorrCfPrb=TSpecFunc::BetaI(0.5*df,0.5,df/(df+t*t));
506    FisherZ=0.5*log((1.0+(CorrCf)+TINY)/(1.0-(CorrCf)+TINY));
507  }
508  void TStatTest::AveVar(const TFltV& ValV, double& Ave, double& Var){
509    Ave=0;
510    for (int ValN=0; ValN<ValV.Len(); ValN++){
511      Ave+=ValV[ValN];}
512    Ave/=ValV.Len();
513    Var=0;
514    double ep=0;
515    for (int ValN=0; ValN<ValV.Len(); ValN++){
516      double s=ValV[ValN]-Ave;
517      ep+=s;
518      Var+=s*s;
519    }
520    Var=(Var-ep*ep/ValV.Len())/(ValV.Len()-1);
521  }
522  double TStatTest::KsProb(const double& Alam) {
523    const double EPS1 = 0.001;
524    const double EPS2 = 1.0e-8;
525    double a2 = -2.0*Alam*Alam, fac = 2.0, sum = 0.0, term, termbf = 0.0;
526    for (int j=1; j <= 100; j++) {
527      term = fac*exp(a2*j*j);
528      sum += term;
529      if (fabs(term) <= EPS1*termbf || fabs(term) <= EPS2*sum)
530        return sum;
531      fac = -fac;
532      termbf = fabs(term);
533    }
534    return 1.0;
535  }
536  void TStatTest::ChiSquareOne(
537   const TFltV& ObservedBinV, const TFltV& ExpectedBinV,
538   double& ChiSquareVal, double& SignificancePrb){
539    IAssert(ObservedBinV.Len()==ExpectedBinV.Len());
540    int Bins=ObservedBinV.Len();
541    int Constraints=0;
542    int DegreesOfFreedom=Bins-Constraints;
543    ChiSquareVal=0.0;
544    for (int BinN=0; BinN<Bins; BinN++){
545      IAssert(ExpectedBinV[BinN]>0);
546      double BinDiff=ObservedBinV[BinN]-ExpectedBinV[BinN];
547      ChiSquareVal+=BinDiff*BinDiff/ExpectedBinV[BinN];
548    }
549    SignificancePrb=
550     TSpecFunc::GammaQ(0.5*(DegreesOfFreedom), 0.5*(ChiSquareVal));
551  }
552  void TStatTest::ChiSquareTwo(
553   const TFltV& ObservedBin1V, const TFltV& ObservedBin2V,
554   double& ChiSquareVal, double& SignificancePrb){
555    IAssert(ObservedBin1V.Len()==ObservedBin1V.Len());
556    int Bins=ObservedBin1V.Len();
557    int Constraints=0;
558    int DegreesOfFreedom=Bins-Constraints;
559    ChiSquareVal=0.0;
560    for (int BinN=0; BinN<Bins; BinN++){
561      if ((ObservedBin1V[BinN]==0.0) && (ObservedBin2V[BinN]==0.0)){
562        DegreesOfFreedom--;
563      } else {
564        double BinDiff=ObservedBin1V[BinN]-ObservedBin2V[BinN];
565        ChiSquareVal+=BinDiff*BinDiff/(ObservedBin1V[BinN]+ObservedBin2V[BinN]);
566      }
567    }
568    SignificancePrb=
569     TSpecFunc::GammaQ(0.5*(DegreesOfFreedom),0.5*(ChiSquareVal));
570  }
571  void TStatTest::TTest(
572   const TFltV& ValV1, const TFltV& ValV2, double& TTestVal, double& TTestPrb){
573    PMom Val1Mom=TMom::New(ValV1);
574    PMom Val2Mom=TMom::New(ValV2);
575    double ave1=Val1Mom->GetMean();
576    double ave2=Val2Mom->GetMean();
577    double var1=Val1Mom->GetVari();
578    double var2=Val2Mom->GetVari();
579    int n1=ValV1.Len();
580    int n2=ValV2.Len();
581    TTestVal=(ave1-ave2)/sqrt(var1/n1+var2/n2);
582    double df=TMath::Sqr(var1/n1+var2/n2)/(TMath::Sqr(var1/n1)/(n1-1)+TMath::Sqr(var2/n2)/(n2-1));
583    TTestPrb=TSpecFunc::BetaI(0.5*df, 0.5, df/(df+TMath::Sqr(TTestVal)));
584  }
585  void TStatTest::KsTest(const TFltV& ValV1, const TFltV& ValV2, double& DStat, double& PVal) {
586    IAssert(ValV1.IsSorted() && ValV2.IsSorted());
587    int i1=0, i2=0;
588    double CumSum1=0.0, CumSum2=0.0, Cdf1=0.0, Cdf2=0.0;
589    const double N1 = ValV1.Len();
590    const double N2 = ValV2.Len();
591    if (! (N1 > 0.0 && N2 > 0.0)) { DStat = 1.0;  PVal = 0.0;  return; }
592    DStat=0.0; PVal=0.0;
593    while (i1 < ValV1.Len() && i2 < ValV2.Len()) {
594      const double X1 = ValV1[i1];
595      const double X2 = ValV2[i2];
596      if (X1 <= X2) {
597        CumSum1 += 1;
598        Cdf1 = (CumSum1 / N1);
599        i1++;
600      }
601      if (X2 <= X1) {
602        CumSum2 += 1;
603        Cdf2 = (CumSum2 / N2);
604        i2++;
605      }
606      DStat = TMath::Mx(DStat, fabs(Cdf1 - Cdf2));
607    }
608    const double En = sqrt( N1*N2 / (N1+N2));
609    PVal = TStatTest::KsProb((En+0.12+0.11/En)*DStat);
610  }
611  void TStatTest::KsTest(const TFltPrV& ValCntV1, const TFltPrV& ValCntV2, double& DStat, double& PVal) {
612    IAssert(ValCntV1.IsSorted() && ValCntV2.IsSorted());
613    int i1=0, i2=0;
614    double N1=0.0, N2=0.0, CumSum1=0.0, CumSum2=0.0, Cdf1=0.0, Cdf2=0.0;
615    DStat=0.0;  PVal=0.0;
616    for (int i = 0; i < ValCntV1.Len(); i++) N1 += ValCntV1[i].Val2;
617    for (int i = 0; i < ValCntV2.Len(); i++) N2 += ValCntV2[i].Val2;
618    if (! (N1 > 0.0 && N2 > 0.0)) { DStat = 1.0;  PVal = 0.0;  return; }
619    while (i1 < ValCntV1.Len() && i2 < ValCntV2.Len()) {
620      const double X1 = ValCntV1[i1].Val1;
621      const double X2 = ValCntV2[i2].Val1;
622      if (X1 <= X2) {
623        CumSum1 += ValCntV1[i1].Val2;
624        Cdf1 = (CumSum1 / N1);
625        i1++;
626      }
627      if (X2 <= X1) {
628        CumSum2 += ValCntV2[i2].Val2;
629        Cdf2 = (CumSum2 / N2);
630        i2++;
631      }
632      DStat = TMath::Mx(DStat, fabs(Cdf1 - Cdf2));
633    }
634    const double En = sqrt( N1*N2 / (N1+N2));
635    PVal = TStatTest::KsProb((En+0.12+0.11/En)*DStat);
636  }
637  bool TComb::GetNext(){
638    if (ItemV.Len()==0){
639      ItemV.Gen(Order, Order);
640      for (int OrderN=0; OrderN<Order; OrderN++){
641        ItemV[OrderN]=OrderN;}
642      return true;
643    } else {
644      if (ItemV.Last()==Items-1){
645        int OrderN=Order-1;
646        while ((OrderN>=0)&&(ItemV[OrderN]==Items-(Order-OrderN-1)-1)){OrderN--;}
647        if (OrderN<0){
648          return false;
649        } else {
650          ItemV[OrderN]++;
651          for (int SubOrderN=OrderN+1; SubOrderN<Order; SubOrderN++){
652            ItemV[SubOrderN]=ItemV[SubOrderN-1]+1;}
653          CombN++; return true;
654        }
655      } else {
656        ItemV.Last()++; CombN++; return true;
657      }
658    }
659  }
660  int TComb::GetCombs() const {
661    int LCombs=1; int HCombs=1;
662    for (int OrderN=0; OrderN<Order; OrderN++){
663      LCombs*=OrderN+1; HCombs*=Items-OrderN;}
664    int Combs=HCombs/LCombs;
665    return Combs;
666  }
667  void TComb::Wr(){
668    printf("%d:[", GetCombN());
669    for (int OrderN=0; OrderN<Order; OrderN++){
670      if (OrderN>0){printf(" ");}
671      printf("%d", ItemV[OrderN]());
672    }
673    printf("]\n");
674  }
675  PLinReg TLinReg::New(const TFltVV& _XVV, const TFltV& _YV, const TFltV& _SigV){
676    PLinReg LinReg=PLinReg(new TLinReg());
677    LinReg->XVV=_XVV;
678    LinReg->YV=_YV;
679    if (_SigV.Empty()){
680      LinReg->SigV.Gen(LinReg->YV.Len());
681      LinReg->SigV.PutAll(1);
682    } else {
683      LinReg->SigV=_SigV;
684    }
685    LinReg->Recs=LinReg->XVV.GetXDim();
686    LinReg->Vars=LinReg->XVV.GetYDim();
687    IAssert(LinReg->Recs>0);
688    IAssert(LinReg->Vars>0);
689    IAssert(LinReg->YV.Len()==LinReg->Recs);
690    IAssert(LinReg->SigV.Len()==LinReg->Recs);
691    LinReg->CovarVV.Gen(LinReg->Vars+1, LinReg->Vars+1);
692    LinReg->CfV.Gen(LinReg->Vars+1);
693    LinReg->NR_lfit();
694    return LinReg;
695  }
696  void TLinReg::NR_covsrt(
697   TFltVV& CovarVV, const int& Vars, const TIntV& ia, const int& mfit){
698    for (int i=mfit+1; i<=Vars; i++){
699      for (int j=1; j<=i; j++){
700        CovarVV.At(i, j)=0; CovarVV.At(j, i)=0.0;}
701    }
702    int k=mfit;
703    for (int j=Vars; j>=1; j--){
704      if (ia[j]!=0){
705        for (int i=1; i<=Vars; i++){Swap(CovarVV.At(i, k), CovarVV.At(i, j));}
706        {for (int i=1; i<=Vars; i++){Swap(CovarVV.At(k, i), CovarVV.At(j, i));}}
707        k--;
708      }
709    }
710  }
711  void TLinReg::NR_gaussj(TFltVV& a, const int& n, TFltVV& b, const int& m){
712    int i, icol=0, irow=0, j, k, l, ll;
713    double big, dum, pivinv;
714    TIntV indxc(n+1);
715    TIntV indxr(n+1);
716    TIntV ipiv(n+1);
717    for (j=1; j<=n; j++){ipiv[j]=0;}
718    for (i=1; i<=n; i++){
719      big=0.0;
720      for (j=1; j<=n; j++){
721        if (ipiv[j]!=1){
722          for (k=1; k<=n; k++){
723            if (ipiv[k]==0){
724              if (fabs(double(a.At(j, k))) >= big){
725                big=fabs(double(a.At(j, k)));
726                irow=j;
727                icol=k;
728              }
729            } else
730            if (ipiv[k]>1){
731              TExcept::Throw("Singular Matrix(1) in Gauss");}
732          }
733        }
734      }
735      ipiv[icol]++;
736      if (irow != icol){
737        for (l=1; l<=n; l++){Swap(a.At(irow, l), a.At(icol, l));}
738        for (l=1; l<=m; l++){Swap(b.At(irow, l), b.At(icol, l));}
739      }
740      indxr[i]=irow;
741      indxc[i]=icol;
742      if (a.At(icol, icol)==0.0){
743        TExcept::Throw("Singular Matrix(1) in Gauss");}
744      pivinv=1.0/a.At(icol, icol);
745      a.At(icol, icol)=1.0;
746      for (l=1; l<=n; l++){a.At(icol, l)=a.At(icol, l)*pivinv;}
747      for (l=1; l<=m; l++){b.At(icol, l)=b.At(icol, l)*pivinv;}
748      for (ll=1; ll<=n; ll++){
749        if (ll != icol){
750          dum=a.At(ll, icol);
751          a.At(ll, icol)=0.0;
752          for (l=1;l<=n;l++){a.At(ll, l)-=a.At(icol, l)*dum;}
753          for (l=1;l<=m;l++){b.At(ll, l)-=b.At(icol, l)*dum;}
754        }
755      }
756    }
757    for (l=n; l>=1; l--){
758      if (indxr[l]!=indxc[l]){
759        for (k=1; k<=n; k++){
760          Swap(a.At(k, indxr[l]), a.At(k, indxc[l]));}
761      }
762    }
763  }
764  void TLinReg::NR_lfit(){
765    int i,j,k,l,m,mfit=0;
766    double ym,wt,sum,sig2i;
767    TIntV ia(Vars+1); for (i=1; i<=Vars; i++){ia[i]=1;}
768    TFltVV beta(Vars+1, 1+1);
769    TFltV afunc(Vars+1);
770    for (j=1;j<=Vars;j++){
771      if (ia[j]!=0){mfit++;}}
772    if (mfit==0){TExcept::Throw("No parameters to be fitted in LFit");}
773    for (j=1; j<=mfit; j++){
774      for (k=1; k<=mfit; k++){CovarVV.At(j, k)=0.0;}
775      beta.At(j, 1)=0.0;
776    }
777    for (i=1; i<=Recs; i++){
778      GetXV(i, afunc); 
779      ym=GetY(i);
780      if (mfit<Vars){
781        for (j=1;j<=Vars;j++){
782          if (ia[j]==0){ym-=CfV[j]*afunc[j];}}
783      }
784      sig2i=1.0/TMath::Sqr(GetSig(i));
785      for (j=0, l=1; l<=Vars; l++){
786        if (ia[l]!=0){
787          wt=afunc[l]*sig2i;
788          for (j++, k=0, m=1; m<=l; m++){
789            if (ia[m]!=0){CovarVV.At(j, ++k)+=wt*afunc[m];}
790          }
791          beta.At(j, 1)+=ym*wt;
792        }
793      }
794    }
795    for (j=2; j<=mfit; j++){
796      for (k=1; k<j; k++){CovarVV.At(k, j)=CovarVV.At(j, k);}
797    }
798    NR_gaussj(CovarVV, mfit, beta, 1);
799    for (j=0, l=1; l<=Vars; l++){
800      if (ia[l]!=0){CfV[l]=beta.At(++j, 1);}
801    }
802    ChiSq=0.0;
803    for (i=1; i<=Recs; i++){
804      GetXV(i, afunc); 
805      for (sum=0.0, j=1; j<=Vars; j++){sum+=CfV[j]*afunc[j];}
806      ChiSq+=TMath::Sqr((GetY(i)-sum)/GetSig(i));
807    }
808    NR_covsrt(CovarVV, Vars, ia, mfit);
809  }
810  void TLinReg::Wr() const {
811    printf("\n%11s %21s\n","parameter","uncertainty");
812    for (int i=0; i<Vars;i++){
813      printf("  a[%1d] = %8.6f %12.6f\n",
814       i+1, GetCf(i), GetCfUncer(i));
815    }
816    printf("chi-squared = %12f\n", GetChiSq());
817    printf("full covariance matrix\n");
818    {for (int i=0;i<Vars;i++){
819      for (int j=0;j<Vars;j++){
820        printf("%12f", GetCovar(i, j));}
821      printf("\n");
822    }}
823  }
824  PSvd TSvd::New(const TFltVV& _XVV, const TFltV& _YV, const TFltV& _SigV){
825    PSvd Svd=PSvd(new TSvd());
826    Svd->XVV=_XVV;
827    Svd->YV=_YV;
828    if (_SigV.Empty()){
829      Svd->SigV.Gen(Svd->YV.Len());
830      Svd->SigV.PutAll(1);
831    } else {
832      Svd->SigV=_SigV;
833    }
834    Svd->Recs=Svd->XVV.GetXDim();
835    Svd->Vars=Svd->XVV.GetYDim();
836    IAssert(Svd->Recs>0);
837    IAssert(Svd->Vars>0);
838    IAssert(Svd->YV.Len()==Svd->Recs);
839    IAssert(Svd->SigV.Len()==Svd->Recs);
840    Svd->CovarVV.Gen(Svd->Vars+1, Svd->Vars+1);
841    Svd->CfV.Gen(Svd->Vars+1);
842    Svd->NR_svdfit();
843    return Svd;
844  }
845  double TSvd::NR_pythag(double a, double b){
846    double absa,absb;
847    absa=fabs(a);
848    absb=fabs(b);
849    if (absa > absb){
850      return absa*sqrt(1.0+TMath::Sqr(absb/absa));
851    } else {
852      return (absb == 0.0 ? 0.0 : absb*sqrt(1.0+TMath::Sqr(absa/absb)));
853    }
854  }
855  void TSvd::NR_svdcmp(TFltVV& a, int m, int n, TFltV& w, TFltVV& v){
856    int flag,i,its,j,jj,k,l=0,nm;
857    double anorm,c,f,g,h,s,scale,x,y,z;
858    TFltV rv1(n+1);
859    g=scale=anorm=0.0;
860    for (i=1;i<=n;i++) {
861      l=i+1;
862      rv1[i]=scale*g;
863      g=s=scale=0.0;
864      if (i <= m) {
865        for (k=i;k<=m;k++) scale += fabs(double(a.At(k,i)));
866        if (scale) {
867          for (k=i;k<=m;k++) {
868            a.At(k,i) /= scale;
869            s += a.At(k,i)*a.At(k,i);
870          }
871          f=a.At(i,i);
872          g = -NR_SIGN(sqrt(s),f);
873          h=f*g-s;
874          a.At(i,i)=f-g;
875          for (j=l;j<=n;j++) {
876            for (s=0.0,k=i;k<=m;k++) s += a.At(k,i)*a(k,j);
877            f=s/h;
878            for (k=i;k<=m;k++) a.At(k,j) += f*a.At(k,i);
879          }
880          for (k=i;k<=m;k++) a.At(k,i) *= scale;
881        }
882      }
883      w[i]=scale *g;
884      g=s=scale=0.0;
885      if (i <= m && i != n) {
886        for (k=l;k<=n;k++) scale += fabs(double(a.At(i,k)));
887        if (scale) {
888          for (k=l;k<=n;k++) {
889            a.At(i,k) /= scale;
890            s += a.At(i,k)*a.At(i,k);
891          }
892          f=a.At(i,l);
893          g = -NR_SIGN(sqrt(s),f);
894          h=f*g-s;
895          a.At(i,l)=f-g;
896          for (k=l;k<=n;k++) rv1[k]=a.At(i,k)/h;
897          for (j=l;j<=m;j++) {
898            for (s=0.0,k=l;k<=n;k++) s += a.At(j,k)*a.At(i,k);
899            for (k=l;k<=n;k++) a.At(j,k) += s*rv1[k];
900          }
901          for (k=l;k<=n;k++) a.At(i,k) *= scale;
902        }
903      }
904      anorm=NR_FMAX(anorm,(fabs(double(w[i]))+fabs(double(rv1[i]))));
905    }
906    for (i=n;i>=1;i--) {
907      if (i < n) {
908        if (g) {
909          for (j=l;j<=n;j++)
910            v.At(j,i)=(a.At(i,j)/a.At(i,l))/g;
911          for (j=l;j<=n;j++) {
912            for (s=0.0,k=l;k<=n;k++) s += a.At(i,k)*v.At(k,j);
913            for (k=l;k<=n;k++) v.At(k,j) += s*v.At(k,i);
914          }
915        }
916        for (j=l;j<=n;j++) v.At(i,j)=v.At(j,i)=0.0;
917      }
918      v.At(i,i)=1.0;
919      g=rv1[i];
920      l=i;
921    }
922    for (i=NR_IMIN(m,n);i>=1;i--) {
923      l=i+1;
924      g=w[i];
925      for (j=l;j<=n;j++) a.At(i,j)=0.0;
926      if (g) {
927        g=1.0/g;
928        for (j=l;j<=n;j++) {
929          for (s=0.0,k=l;k<=m;k++) s += a.At(k,i)*a.At(k,j);
930          f=(s/a.At(i,i))*g;
931          for (k=i;k<=m;k++) a.At(k,j) += f*a.At(k,i);
932        }
933        for (j=i;j<=m;j++) a.At(j,i) *= g;
934      } else for (j=i;j<=m;j++) a.At(j,i)=0.0;
935      a.At(i,i)++;
936    }
937    for (k=n;k>=1;k--) {
938      for (its=1;its<=30;its++) {
939        flag=1;
940        for (l=k;l>=1;l--) {
941          nm=l-1;
942          if ((double)(fabs(double(rv1[l])+anorm)) == anorm) {
943            flag=0;
944            break;
945          }
946          if ((double)(fabs(double(w[nm]))+anorm) == anorm) break;
947        }
948        if (flag) {
949          c=0.0;
950          s=1.0;
951          for (i=l;i<=k;i++) {
952            f=s*rv1[i];
953            rv1[i]=c*rv1[i];
954            if ((double)(fabs(f)+anorm) == anorm) break;
955            g=w[i];
956            h=NR_pythag(f,g);
957            w[i]=h;
958            h=1.0/h;
959            c=g*h;
960            s = -f*h;
961            for (j=1;j<=m;j++) {
962              y=a.At(j,nm);
963              z=a.At(j,i);
964              a.At(j,nm)=y*c+z*s;
965              a.At(j,i)=z*c-y*s;
966            }
967          }
968        }
969        z=w[k];
970        if (l == k) {
971          if (z < 0.0) {
972            w[k] = -z;
973            for (j=1;j<=n;j++) v.At(j,k) = -v.At(j,k);
974          }
975          break;
976        }
977        if (its==30){
978          TExcept::Throw("no convergence in 30 svdcmp iterations");}
979        x=w[l];
980        nm=k-1;
981        y=w[nm];
982        g=rv1[nm];
983        h=rv1[k];
984        f=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
985        g=NR_pythag(f,1.0);
986        f=((x-z)*(x+z)+h*((y/(f+NR_SIGN(g,f)))-h))/x;
987        c=s=1.0;
988        for (j=l;j<=nm;j++) {
989          i=j+1;
990          g=rv1[i];
991          y=w[i];
992          h=s*g;
993          g=c*g;
994          z=NR_pythag(f,h);
995          rv1[j]=z;
996          c=f/z;
997          s=h/z;
998          f=x*c+g*s;
999          g = g*c-x*s;
1000          h=y*s;
1001          y *= c;
1002          for (jj=1;jj<=n;jj++) {
1003            x=v.At(jj,j);
1004            z=v.At(jj,i);
1005            v.At(jj,j)=x*c+z*s;
1006            v.At(jj,i)=z*c-x*s;
1007          }
1008          z=NR_pythag(f,h);
1009          w[j]=z;
1010          if (z) {
1011            z=1.0/z;
1012            c=f*z;
1013            s=h*z;
1014          }
1015          f=c*g+s*y;
1016          x=c*y-s*g;
1017          for (jj=1;jj<=m;jj++) {
1018            y=a.At(jj,j);
1019            z=a.At(jj,i);
1020            a.At(jj,j)=y*c+z*s;
1021            a.At(jj,i)=z*c-y*s;
1022          }
1023        }
1024        rv1[l]=0.0;
1025        rv1[k]=f;
1026        w[k]=x;
1027      }
1028    }
1029  }
1030  void TSvd::NR_svbksb(
1031   TFltVV& u, TFltV& w, TFltVV& v, int m, int n, TFltV& b, TFltV& x){
1032    int jj,j,i;
1033    double s;
1034    TFltV tmp(n+1);
1035    for (j=1;j<=n;j++) {
1036      s=0.0;
1037      if (w[j]) {
1038        for (i=1;i<=m;i++) s += u.At(i,j)*b[i];
1039        s /= w[j];
1040      }
1041      tmp[j]=s;
1042    }
1043    for (j=1;j<=n;j++) {
1044      s=0.0;
1045      for (jj=1;jj<=n;jj++) s += v.At(j,jj)*tmp[jj];
1046      x[j]=s;
1047    }
1048  }
1049  void TSvd::NR_svdvar(TFltVV& v, int ma, TFltV& w, TFltVV& cvm){
1050    int k,j,i;
1051    double sum;
1052    TFltV wti(ma+1);
1053    for (i=1;i<=ma;i++) {
1054      wti[i]=0.0;
1055      if (w[i]) wti[i]=1.0/(w[i]*w[i]);
1056    }
1057    for (i=1;i<=ma;i++) {
1058      for (j=1;j<=i;j++) {
1059        for (sum=0.0,k=1;k<=ma;k++) sum += v.At(i,k)*v.At(j,k)*wti[k];
1060        cvm.At(j,i)=cvm.At(i,j)=sum;
1061      }
1062    }
1063  }
1064  void TSvd::NR_svdfit(){
1065    int j,i;
1066    double wmax,tmp,thresh,sum;
1067    double TOL=1.0e-5;
1068    TFltVV u(Recs+1, Vars+1);
1069    TFltVV v(Vars+1, Vars+1);
1070    TFltV w(Vars+1);
1071    TFltV b(Recs+1);
1072    TFltV afunc(Vars+1);
1073    for (i=1;i<=Recs;i++) {
1074      GetXV(i, afunc); 
1075      tmp=1.0/GetSig(i);
1076      for (j=1;j<=Vars;j++){u.At(i,j)=afunc[j]*tmp;}
1077      b[i]=GetY(i)*tmp;
1078    }
1079    NR_svdcmp(u,Recs,Vars,w,v);
1080    wmax=0.0;
1081    for (j=1;j<=Vars;j++){
1082      if (w[j] > wmax){wmax=w[j];}}
1083    thresh=TOL*wmax;
1084    for (j=1;j<=Vars;j++){
1085      if (double(w[j])<thresh){w[j]=0.0;}}
1086    NR_svbksb(u,w,v,Recs,Vars,b,CfV);
1087    ChiSq=0.0;
1088    for (i=1;i<=Recs;i++) {
1089      GetXV(i, afunc); 
1090      for (sum=0.0,j=1;j<=Vars;j++){sum += CfV[j]*afunc[j];}
1091      ChiSq += (tmp=(GetY(i)-sum)/GetSig(i),tmp*tmp);
1092    }
1093    CovarVV.Gen(Vars+1, Vars+1);
1094    NR_svdvar(v, Vars, w, CovarVV);
1095  }
1096  void TSvd::GetCfV(TFltV& _CfV){
1097    _CfV=CfV; _CfV.Del(0);
1098  }
1099  void TSvd::GetCfUncerV(TFltV& CfUncerV){
1100    CfUncerV.Gen(Vars);
1101    for (int VarN=0; VarN<Vars; VarN++){
1102      CfUncerV[VarN]=GetCfUncer(VarN);
1103    }
1104  }
1105  void TSvd::Svd(const TFltVV& InMtx, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV) {
1106    LSingV.Gen(InMtx.GetYDim()+1, InMtx.GetYDim()+1);
1107    for (int x = 0; x < InMtx.GetXDim(); x++) {
1108      for (int y = 0; y < InMtx.GetYDim(); y++) {
1109        LSingV.At(x+1, y+1) = InMtx.At(x, y);
1110      }
1111    }
1112    RSingV.Gen(InMtx.GetYDim()+1, InMtx.GetYDim()+1);
1113    SingValV.Gen(InMtx.GetYDim()+1);
1114    TSvd::NR_svdcmp(LSingV, InMtx.GetXDim(), InMtx.GetYDim(), SingValV, RSingV);
1115    SingValV.Del(0);
1116    LSingV.DelX(0); LSingV.DelY(0);
1117    RSingV.DelX(0); RSingV.DelY(0);
1118  }
1119  void TSvd::Svd1Based(const TFltVV& InMtx1, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV) {
1120    LSingV = InMtx1;
1121    SingValV.Gen(InMtx1.GetYDim());
1122    RSingV.Gen(InMtx1.GetYDim(), InMtx1.GetYDim());
1123    TSvd::NR_svdcmp(LSingV, InMtx1.GetXDim()-1, InMtx1.GetYDim()-1, SingValV, RSingV);
1124    SingValV.Del(0);
1125    LSingV.DelX(0); LSingV.DelY(0);
1126    RSingV.DelX(0); RSingV.DelY(0);
1127  }
1128  void TSvd::Wr() const {
1129    printf("\n%11s %21s\n","parameter","uncertainty");
1130    for (int i=0; i<Vars;i++){
1131      printf("  a[%1d] = %8.6f %12.6f\n",
1132       i+1, GetCf(i), GetCfUncer(i));
1133    }
1134    printf("chi-squared = %12f\n", GetChiSq());
1135    printf("full covariance matrix\n");
1136    {for (int i=0;i<Vars;i++){
1137      for (int j=0;j<Vars;j++){
1138        printf("%12f", GetCovar(i, j));}
1139      printf("\n");
1140    }}
1141  }
1142  void THist::Add(const double& Val, const bool& OnlyInP) {
1143      const int BucketN = int(floor((Val - MnVal) / BucketSize));
1144  	if (OnlyInP) { 
1145  		EAssert(MnVal <= Val && Val <= MxVal);
1146  		BucketV[BucketN]++;
1147  	} else {
1148  		if (BucketN < 0) {
1149  			BucketV[0]++;
1150  		} else if (BucketN < BucketV.Len()) {
1151  			BucketV[BucketN]++;
1152  		} else {
1153  			BucketV.Last()++;
1154  		}
1155  	}
1156  	Vals++;
1157  }
1158  void THist::SaveStat(const TStr& ValNm, TSOut& FOut) const {
1159      FOut.PutStrLn("#" + ValNm + ": " + Vals.GetStr());
1160      const int Buckets = BucketV.Len() - 1;
1161      for (int BucketN = 0; BucketN < Buckets; BucketN++) {
1162          FOut.PutStrLn(TStr::Fmt("%d-%d\t%d", BucketSize*BucketN,
1163              BucketSize*(BucketN+1), BucketV[BucketN]()));
1164      }
1165      if (BucketV.Last() > 0) {
1166          FOut.PutStrLn(TStr::Fmt("%d-\t%d", BucketSize*Buckets, BucketV.Last()()));
1167      }
1168  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-signnet.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.cpp</div>
                </div>
                <div class="column column_space"><pre><code>177      }
178      int PlusCnt=0, MinusCnt=0;
179      EdgeV.Shuffle(TInt::Rnd);
180      for (int e = 0; e < EdgeV.Len(); e++) {
</pre></code></div>
                <div class="column column_space"><pre><code>271      MinX = XValCntV[i].Val1; }
272    IAssert(MinX > 0.0);
273    double NSamples=0.0, LnSum=0.0;
274    for (int i = 0; i < XValCntV.Len(); i++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    