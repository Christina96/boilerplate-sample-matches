
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 25.294117647058822%, Tokens: 15</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_io.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <opencv2/core/core.hpp>
3  #include <opencv2/highgui/highgui.hpp>
4  #include <opencv2/highgui/highgui_c.h>
5  #include <opencv2/imgproc/imgproc.hpp>
6  #include <string>
7  #include "gtest/gtest.h"
8  #include "caffe/common.hpp"
9  #include "caffe/util/io.hpp"
10  #include "caffe/test/test_caffe_main.hpp"
11  namespace caffe {
12  class IOTest : public ::testing::Test {};
13  bool ReadImageToDatumReference(const string& filename, const int label,
14      const int height, const int width, const bool is_color, Datum* datum) {
15    cv::Mat cv_img;
16    int cv_read_flag = (is_color ? CV_LOAD_IMAGE_COLOR :
17      CV_LOAD_IMAGE_GRAYSCALE);
18    cv::Mat cv_img_origin = cv::imread(filename, cv_read_flag);
19    if (!cv_img_origin.data) {
20      LOG(ERROR) << "Could not open or find file " << filename;
21      return false;
22    }
23    if (height > 0 && width > 0) {
24      cv::resize(cv_img_origin, cv_img, cv::Size(width, height));
25    } else {
26      cv_img = cv_img_origin;
27    }
28    int num_channels = (is_color ? 3 : 1);
29    datum->set_channels(num_channels);
30    datum->set_height(cv_img.rows);
31    datum->set_width(cv_img.cols);
32    datum->set_label(label);
33    datum->clear_data();
34    datum->clear_float_data();
35    string* datum_string = datum->mutable_data();
36    if (is_color) {
<span onclick='openModal()' class='match'>37      for (int c = 0; c < num_channels; ++c) {
38        for (int h = 0; h < cv_img.rows; ++h) {
39          for (int w = 0; w < cv_img.cols; ++w) {
</span>40            datum_string->push_back(
41              static_cast<char>(cv_img.at<cv::Vec3b>(h, w)[c]));
42          }
43        }
44      }
45    } else {  
46      for (int h = 0; h < cv_img.rows; ++h) {
47        for (int w = 0; w < cv_img.cols; ++w) {
48          datum_string->push_back(
49            static_cast<char>(cv_img.at<uchar>(h, w)));
50          }
51        }
52    }
53    return true;
54  }
55  TEST_F(IOTest, TestReadImageToDatum) {
56    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
57    Datum datum;
58    ReadImageToDatum(filename, 0, &datum);
59    EXPECT_EQ(datum.channels(), 3);
60    EXPECT_EQ(datum.height(), 360);
61    EXPECT_EQ(datum.width(), 480);
62  }
63  TEST_F(IOTest, TestReadImageToDatumReference) {
64    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
65    Datum datum, datum_ref;
66    ReadImageToDatum(filename, 0, 0, 0, true, &datum);
67    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
68    EXPECT_EQ(datum.channels(), datum_ref.channels());
69    EXPECT_EQ(datum.height(), datum_ref.height());
70    EXPECT_EQ(datum.width(), datum_ref.width());
71    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
72    const string& data = datum.data();
73    const string& data_ref = datum.data();
74    for (int i = 0; i < datum.data().size(); ++i) {
75      EXPECT_TRUE(data[i] == data_ref[i]);
76    }
77  }
78  TEST_F(IOTest, TestReadImageToDatumReferenceResized) {
79    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
80    Datum datum, datum_ref;
81    ReadImageToDatum(filename, 0, 100, 200, true, &datum);
82    ReadImageToDatumReference(filename, 0, 100, 200, true, &datum_ref);
83    EXPECT_EQ(datum.channels(), datum_ref.channels());
84    EXPECT_EQ(datum.height(), datum_ref.height());
85    EXPECT_EQ(datum.width(), datum_ref.width());
86    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
87    const string& data = datum.data();
88    const string& data_ref = datum.data();
89    for (int i = 0; i < datum.data().size(); ++i) {
90      EXPECT_TRUE(data[i] == data_ref[i]);
91    }
92  }
93  TEST_F(IOTest, TestReadImageToDatumContent) {
94    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
95    Datum datum;
96    ReadImageToDatum(filename, 0, &datum);
97    cv::Mat cv_img = ReadImageToCVMat(filename);
98    EXPECT_EQ(datum.channels(), cv_img.channels());
99    EXPECT_EQ(datum.height(), cv_img.rows);
100    EXPECT_EQ(datum.width(), cv_img.cols);
101    const string& data = datum.data();
102    int index = 0;
103    for (int c = 0; c < datum.channels(); ++c) {
104      for (int h = 0; h < datum.height(); ++h) {
105        for (int w = 0; w < datum.width(); ++w) {
106          EXPECT_TRUE(data[index++] ==
107            static_cast<char>(cv_img.at<cv::Vec3b>(h, w)[c]));
108        }
109      }
110    }
111  }
112  TEST_F(IOTest, TestReadImageToDatumContentGray) {
113    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
114    Datum datum;
115    const bool is_color = false;
116    ReadImageToDatum(filename, 0, is_color, &datum);
117    cv::Mat cv_img = ReadImageToCVMat(filename, is_color);
118    EXPECT_EQ(datum.channels(), cv_img.channels());
119    EXPECT_EQ(datum.height(), cv_img.rows);
120    EXPECT_EQ(datum.width(), cv_img.cols);
121    const string& data = datum.data();
122    int index = 0;
123    for (int h = 0; h < datum.height(); ++h) {
124      for (int w = 0; w < datum.width(); ++w) {
125        EXPECT_TRUE(data[index++] == static_cast<char>(cv_img.at<uchar>(h, w)));
126      }
127    }
128  }
129  TEST_F(IOTest, TestReadImageToDatumResized) {
130    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
131    Datum datum;
132    ReadImageToDatum(filename, 0, 100, 200, &datum);
133    EXPECT_EQ(datum.channels(), 3);
134    EXPECT_EQ(datum.height(), 100);
135    EXPECT_EQ(datum.width(), 200);
136  }
137  TEST_F(IOTest, TestReadImageToDatumResizedSquare) {
138    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
139    Datum datum;
140    ReadImageToDatum(filename, 0, 256, 256, &datum);
141    EXPECT_EQ(datum.channels(), 3);
142    EXPECT_EQ(datum.height(), 256);
143    EXPECT_EQ(datum.width(), 256);
144  }
145  TEST_F(IOTest, TestReadImageToDatumGray) {
146    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
147    Datum datum;
148    const bool is_color = false;
149    ReadImageToDatum(filename, 0, is_color, &datum);
150    EXPECT_EQ(datum.channels(), 1);
151    EXPECT_EQ(datum.height(), 360);
152    EXPECT_EQ(datum.width(), 480);
153  }
154  TEST_F(IOTest, TestReadImageToDatumResizedGray) {
155    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
156    Datum datum;
157    const bool is_color = false;
158    ReadImageToDatum(filename, 0, 256, 256, is_color, &datum);
159    EXPECT_EQ(datum.channels(), 1);
160    EXPECT_EQ(datum.height(), 256);
161    EXPECT_EQ(datum.width(), 256);
162  }
163  TEST_F(IOTest, TestReadImageToCVMat) {
164    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
165    cv::Mat cv_img = ReadImageToCVMat(filename);
166    EXPECT_EQ(cv_img.channels(), 3);
167    EXPECT_EQ(cv_img.rows, 360);
168    EXPECT_EQ(cv_img.cols, 480);
169  }
170  TEST_F(IOTest, TestReadImageToCVMatResized) {
171    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
172    cv::Mat cv_img = ReadImageToCVMat(filename, 100, 200);
173    EXPECT_EQ(cv_img.channels(), 3);
174    EXPECT_EQ(cv_img.rows, 100);
175    EXPECT_EQ(cv_img.cols, 200);
176  }
177  TEST_F(IOTest, TestReadImageToCVMatResizedSquare) {
178    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
179    cv::Mat cv_img = ReadImageToCVMat(filename, 256, 256);
180    EXPECT_EQ(cv_img.channels(), 3);
181    EXPECT_EQ(cv_img.rows, 256);
182    EXPECT_EQ(cv_img.cols, 256);
183  }
184  TEST_F(IOTest, TestReadImageToCVMatGray) {
185    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
186    const bool is_color = false;
187    cv::Mat cv_img = ReadImageToCVMat(filename, is_color);
188    EXPECT_EQ(cv_img.channels(), 1);
189    EXPECT_EQ(cv_img.rows, 360);
190    EXPECT_EQ(cv_img.cols, 480);
191  }
192  TEST_F(IOTest, TestReadImageToCVMatResizedGray) {
193    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
194    const bool is_color = false;
195    cv::Mat cv_img = ReadImageToCVMat(filename, 256, 256, is_color);
196    EXPECT_EQ(cv_img.channels(), 1);
197    EXPECT_EQ(cv_img.rows, 256);
198    EXPECT_EQ(cv_img.cols, 256);
199  }
200  TEST_F(IOTest, TestCVMatToDatum) {
201    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
202    cv::Mat cv_img = ReadImageToCVMat(filename);
203    Datum datum;
204    CVMatToDatum(cv_img, &datum);
205    EXPECT_EQ(datum.channels(), 3);
206    EXPECT_EQ(datum.height(), 360);
207    EXPECT_EQ(datum.width(), 480);
208  }
209  TEST_F(IOTest, TestCVMatToDatumContent) {
210    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
211    cv::Mat cv_img = ReadImageToCVMat(filename);
212    Datum datum;
213    CVMatToDatum(cv_img, &datum);
214    Datum datum_ref;
215    ReadImageToDatum(filename, 0, &datum_ref);
216    EXPECT_EQ(datum.channels(), datum_ref.channels());
217    EXPECT_EQ(datum.height(), datum_ref.height());
218    EXPECT_EQ(datum.width(), datum_ref.width());
219    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
220    const string& data = datum.data();
221    const string& data_ref = datum_ref.data();
222    for (int i = 0; i < datum.data().size(); ++i) {
223      EXPECT_TRUE(data[i] == data_ref[i]);
224    }
225  }
226  TEST_F(IOTest, TestCVMatToDatumReference) {
227    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
228    cv::Mat cv_img = ReadImageToCVMat(filename);
229    Datum datum;
230    CVMatToDatum(cv_img, &datum);
231    Datum datum_ref;
232    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
233    EXPECT_EQ(datum.channels(), datum_ref.channels());
234    EXPECT_EQ(datum.height(), datum_ref.height());
235    EXPECT_EQ(datum.width(), datum_ref.width());
236    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
237    const string& data = datum.data();
238    const string& data_ref = datum_ref.data();
239    for (int i = 0; i < datum.data().size(); ++i) {
240      EXPECT_TRUE(data[i] == data_ref[i]);
241    }
242  }
243  TEST_F(IOTest, TestReadFileToDatum) {
244    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
245    Datum datum;
246    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
247    EXPECT_TRUE(datum.encoded());
248    EXPECT_EQ(datum.label(), -1);
249    EXPECT_EQ(datum.data().size(), 140391);
250  }
251  TEST_F(IOTest, TestDecodeDatum) {
252    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
253    Datum datum;
254    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
255    EXPECT_TRUE(DecodeDatum(&datum, true));
256    EXPECT_FALSE(DecodeDatum(&datum, true));
257    Datum datum_ref;
258    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
259    EXPECT_EQ(datum.channels(), datum_ref.channels());
260    EXPECT_EQ(datum.height(), datum_ref.height());
261    EXPECT_EQ(datum.width(), datum_ref.width());
262    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
263    const string& data = datum.data();
264    const string& data_ref = datum_ref.data();
265    for (int i = 0; i < datum.data().size(); ++i) {
266      EXPECT_TRUE(data[i] == data_ref[i]);
267    }
268  }
269  TEST_F(IOTest, TestDecodeDatumToCVMat) {
270    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
271    Datum datum;
272    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
273    cv::Mat cv_img = DecodeDatumToCVMat(datum, true);
274    EXPECT_EQ(cv_img.channels(), 3);
275    EXPECT_EQ(cv_img.rows, 360);
276    EXPECT_EQ(cv_img.cols, 480);
277    cv_img = DecodeDatumToCVMat(datum, false);
278    EXPECT_EQ(cv_img.channels(), 1);
279    EXPECT_EQ(cv_img.rows, 360);
280    EXPECT_EQ(cv_img.cols, 480);
281  }
282  TEST_F(IOTest, TestDecodeDatumToCVMatContent) {
283    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
284    Datum datum;
285    EXPECT_TRUE(ReadImageToDatum(filename, 0, std::string("jpg"), &datum));
286    cv::Mat cv_img = DecodeDatumToCVMat(datum, true);
287    cv::Mat cv_img_ref = ReadImageToCVMat(filename);
288    EXPECT_EQ(cv_img_ref.channels(), cv_img.channels());
289    EXPECT_EQ(cv_img_ref.rows, cv_img.rows);
290    EXPECT_EQ(cv_img_ref.cols, cv_img.cols);
291    for (int c = 0; c < datum.channels(); ++c) {
292      for (int h = 0; h < datum.height(); ++h) {
293        for (int w = 0; w < datum.width(); ++w) {
294          EXPECT_TRUE(cv_img.at<cv::Vec3b>(h, w)[c]==
295            cv_img_ref.at<cv::Vec3b>(h, w)[c]);
296        }
297      }
298    }
299  }
300  TEST_F(IOTest, TestDecodeDatumNative) {
301    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
302    Datum datum;
303    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
304    EXPECT_TRUE(DecodeDatumNative(&datum));
305    EXPECT_FALSE(DecodeDatumNative(&datum));
306    Datum datum_ref;
307    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
308    EXPECT_EQ(datum.channels(), datum_ref.channels());
309    EXPECT_EQ(datum.height(), datum_ref.height());
310    EXPECT_EQ(datum.width(), datum_ref.width());
311    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
312    const string& data = datum.data();
313    const string& data_ref = datum_ref.data();
314    for (int i = 0; i < datum.data().size(); ++i) {
315      EXPECT_TRUE(data[i] == data_ref[i]);
316    }
317  }
318  TEST_F(IOTest, TestDecodeDatumToCVMatNative) {
319    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
320    Datum datum;
321    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
322    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
323    EXPECT_EQ(cv_img.channels(), 3);
324    EXPECT_EQ(cv_img.rows, 360);
325    EXPECT_EQ(cv_img.cols, 480);
326  }
327  TEST_F(IOTest, TestDecodeDatumNativeGray) {
328    string filename = EXAMPLES_SOURCE_DIR "images/cat_gray.jpg";
329    Datum datum;
330    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
331    EXPECT_TRUE(DecodeDatumNative(&datum));
332    EXPECT_FALSE(DecodeDatumNative(&datum));
333    Datum datum_ref;
334    ReadImageToDatumReference(filename, 0, 0, 0, false, &datum_ref);
335    EXPECT_EQ(datum.channels(), datum_ref.channels());
336    EXPECT_EQ(datum.height(), datum_ref.height());
337    EXPECT_EQ(datum.width(), datum_ref.width());
338    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
339    const string& data = datum.data();
340    const string& data_ref = datum_ref.data();
341    for (int i = 0; i < datum.data().size(); ++i) {
342      EXPECT_TRUE(data[i] == data_ref[i]);
343    }
344  }
345  TEST_F(IOTest, TestDecodeDatumToCVMatNativeGray) {
346    string filename = EXAMPLES_SOURCE_DIR "images/cat_gray.jpg";
347    Datum datum;
348    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
349    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
350    EXPECT_EQ(cv_img.channels(), 1);
351    EXPECT_EQ(cv_img.rows, 360);
352    EXPECT_EQ(cv_img.cols, 480);
353  }
354  TEST_F(IOTest, TestDecodeDatumToCVMatContentNative) {
355    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
356    Datum datum;
357    EXPECT_TRUE(ReadImageToDatum(filename, 0, std::string("jpg"), &datum));
358    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
359    cv::Mat cv_img_ref = ReadImageToCVMat(filename);
360    EXPECT_EQ(cv_img_ref.channels(), cv_img.channels());
361    EXPECT_EQ(cv_img_ref.rows, cv_img.rows);
362    EXPECT_EQ(cv_img_ref.cols, cv_img.cols);
363    for (int c = 0; c < datum.channels(); ++c) {
364      for (int h = 0; h < datum.height(); ++h) {
365        for (int w = 0; w < datum.width(); ++w) {
366          EXPECT_TRUE(cv_img.at<cv::Vec3b>(h, w)[c]==
367            cv_img_ref.at<cv::Vec3b>(h, w)[c]);
368        }
369      }
370    }
371  }
372  }  
373  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_normalize_layer.cpp</h3>
            <pre><code>1  #include <cmath>
2  #include <cstring>
3  #include <vector>
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/normalize_layer.hpp"
8  #include "google/protobuf/text_format.h"
9  #include "gtest/gtest.h"
10  #include "caffe/test/test_caffe_main.hpp"
11  #include "caffe/test/test_gradient_check_util.hpp"
12  namespace caffe {
13  template <typename TypeParam>
14  class NormalizeLayerTest : public MultiDeviceTest<TypeParam> {
15    typedef typename TypeParam::Dtype Dtype;
16   protected:
17    NormalizeLayerTest()
18        : blob_bottom_(new Blob<Dtype>(2, 3, 2, 3)),
19          blob_top_(new Blob<Dtype>()) {
20      FillerParameter filler_param;
21      filler_param.set_value(1);
22      ConstantFiller<Dtype> filler(filler_param);
23      filler.Fill(this->blob_bottom_);
24      blob_bottom_vec_.push_back(blob_bottom_);
25      blob_top_vec_.push_back(blob_top_);
26    }
27    virtual ~NormalizeLayerTest() { delete blob_bottom_; delete blob_top_; }
28    Blob<Dtype>* const blob_bottom_;
29    Blob<Dtype>* const blob_top_;
30    vector<Blob<Dtype>*> blob_bottom_vec_;
31    vector<Blob<Dtype>*> blob_top_vec_;
32  };
33  TYPED_TEST_CASE(NormalizeLayerTest, TestDtypesAndDevices);
34  TYPED_TEST(NormalizeLayerTest, TestForward) {
35    typedef typename TypeParam::Dtype Dtype;
36    LayerParameter layer_param;
37    NormalizeLayer<Dtype> layer(layer_param);
38    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
39    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
40    int num = this->blob_bottom_->num();
41    int channels = this->blob_bottom_->channels();
42    int height = this->blob_bottom_->height();
43    int width = this->blob_bottom_->width();
44    for (int i = 0; i < num; ++i) {
45      Dtype norm = 0;
46      for (int j = 0; j < channels; ++j) {
47        for (int k = 0; k < height; ++k) {
48          for (int l = 0; l < width; ++l) {
49            Dtype data = this->blob_top_->data_at(i, j, k, l);
50            norm += data * data;
51          }
52        }
53      }
54      const Dtype kErrorBound = 1e-5;
55      EXPECT_NEAR(1, sqrt(norm), kErrorBound);
56    }
57  }
58  TYPED_TEST(NormalizeLayerTest, TestForwardScale) {
59    typedef typename TypeParam::Dtype Dtype;
60    LayerParameter layer_param;
61    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
62    norm_param->mutable_scale_filler()->set_type("constant");
63    norm_param->mutable_scale_filler()->set_value(10);
64    NormalizeLayer<Dtype> layer(layer_param);
65    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
66    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
67    int num = this->blob_bottom_->num();
68    int channels = this->blob_bottom_->channels();
69    int height = this->blob_bottom_->height();
70    int width = this->blob_bottom_->width();
71    for (int i = 0; i < num; ++i) {
72      Dtype norm = 0;
73      for (int j = 0; j < channels; ++j) {
74        for (int k = 0; k < height; ++k) {
75          for (int l = 0; l < width; ++l) {
76            Dtype data = this->blob_top_->data_at(i, j, k, l);
77            norm += data * data;
78          }
79        }
80      }
81      const Dtype kErrorBound = 1e-5;
82      EXPECT_NEAR(10, sqrt(norm), kErrorBound);
83    }
84  }
85  TYPED_TEST(NormalizeLayerTest, TestForwardScaleChannels) {
86    typedef typename TypeParam::Dtype Dtype;
87    LayerParameter layer_param;
88    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
89    norm_param->set_channel_shared(false);
90    norm_param->mutable_scale_filler()->set_type("constant");
91    norm_param->mutable_scale_filler()->set_value(10);
92    NormalizeLayer<Dtype> layer(layer_param);
93    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
94    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
95    int num = this->blob_bottom_->num();
96    int channels = this->blob_bottom_->channels();
97    int height = this->blob_bottom_->height();
98    int width = this->blob_bottom_->width();
99    for (int i = 0; i < num; ++i) {
100      Dtype norm = 0;
101      for (int j = 0; j < channels; ++j) {
102        for (int k = 0; k < height; ++k) {
103          for (int l = 0; l < width; ++l) {
104            Dtype data = this->blob_top_->data_at(i, j, k, l);
105            norm += data * data;
106          }
107        }
108      }
109      const Dtype kErrorBound = 1e-5;
110      EXPECT_NEAR(10, sqrt(norm), kErrorBound);
111    }
112  }
113  TYPED_TEST(NormalizeLayerTest, TestForwardEltWise) {
114    typedef typename TypeParam::Dtype Dtype;
115    LayerParameter layer_param;
116    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
117    norm_param->set_across_spatial(false);
118    NormalizeLayer<Dtype> layer(layer_param);
119    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
120    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
121    int num = this->blob_bottom_->num();
122    int channels = this->blob_bottom_->channels();
123    int height = this->blob_bottom_->height();
124    int width = this->blob_bottom_->width();
<span onclick='openModal()' class='match'>125    for (int i = 0; i < num; ++i) {
126      for (int k = 0; k < height; ++k) {
127        for (int l = 0; l < width; ++l) {
</span>128          Dtype norm = 0;
129          for (int j = 0; j < channels; ++j) {
130            Dtype data = this->blob_top_->data_at(i, j, k, l);
131            norm += data * data;
132          }
133          const Dtype kErrorBound = 1e-5;
134          EXPECT_NEAR(1, sqrt(norm), kErrorBound);
135        }
136      }
137    }
138  }
139  TYPED_TEST(NormalizeLayerTest, TestForwardEltWiseScale) {
140    typedef typename TypeParam::Dtype Dtype;
141    LayerParameter layer_param;
142    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
143    norm_param->set_across_spatial(false);
144    norm_param->mutable_scale_filler()->set_type("constant");
145    norm_param->mutable_scale_filler()->set_value(10);
146    NormalizeLayer<Dtype> layer(layer_param);
147    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
148    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
149    int num = this->blob_bottom_->num();
150    int channels = this->blob_bottom_->channels();
151    int height = this->blob_bottom_->height();
152    int width = this->blob_bottom_->width();
153    for (int i = 0; i < num; ++i) {
154      for (int k = 0; k < height; ++k) {
155        for (int l = 0; l < width; ++l) {
156          Dtype norm = 0;
157          for (int j = 0; j < channels; ++j) {
158            Dtype data = this->blob_top_->data_at(i, j, k, l);
159            norm += data * data;
160          }
161          const Dtype kErrorBound = 1e-5;
162          EXPECT_NEAR(10, sqrt(norm), kErrorBound);
163        }
164      }
165    }
166  }
167  TYPED_TEST(NormalizeLayerTest, TestForwardEltWiseScaleChannel) {
168    typedef typename TypeParam::Dtype Dtype;
169    LayerParameter layer_param;
170    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
171    norm_param->set_across_spatial(false);
172    norm_param->set_channel_shared(false);
173    norm_param->mutable_scale_filler()->set_type("constant");
174    norm_param->mutable_scale_filler()->set_value(10);
175    NormalizeLayer<Dtype> layer(layer_param);
176    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
177    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
178    int num = this->blob_bottom_->num();
179    int channels = this->blob_bottom_->channels();
180    int height = this->blob_bottom_->height();
181    int width = this->blob_bottom_->width();
182    for (int i = 0; i < num; ++i) {
183      for (int k = 0; k < height; ++k) {
184        for (int l = 0; l < width; ++l) {
185          Dtype norm = 0;
186          for (int j = 0; j < channels; ++j) {
187            Dtype data = this->blob_top_->data_at(i, j, k, l);
188            norm += data * data;
189          }
190          const Dtype kErrorBound = 1e-5;
191          EXPECT_NEAR(10, sqrt(norm), kErrorBound);
192        }
193      }
194    }
195  }
196  TYPED_TEST(NormalizeLayerTest, TestGradient) {
197    typedef typename TypeParam::Dtype Dtype;
198    LayerParameter layer_param;
199    NormalizeLayer<Dtype> layer(layer_param);
200    GradientChecker<Dtype> checker(1e-2, 1e-3);
201    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
202        this->blob_top_vec_, 0);
203  }
204  TYPED_TEST(NormalizeLayerTest, TestGradientScale) {
205    typedef typename TypeParam::Dtype Dtype;
206    LayerParameter layer_param;
207    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
208    norm_param->mutable_scale_filler()->set_type("constant");
209    norm_param->mutable_scale_filler()->set_value(3);
210    NormalizeLayer<Dtype> layer(layer_param);
211    GradientChecker<Dtype> checker(1e-2, 1e-3);
212    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
213        this->blob_top_vec_);
214  }
215  TYPED_TEST(NormalizeLayerTest, TestGradientScaleChannel) {
216    typedef typename TypeParam::Dtype Dtype;
217    LayerParameter layer_param;
218    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
219    norm_param->set_channel_shared(false);
220    norm_param->mutable_scale_filler()->set_type("constant");
221    norm_param->mutable_scale_filler()->set_value(3);
222    NormalizeLayer<Dtype> layer(layer_param);
223    GradientChecker<Dtype> checker(1e-2, 1e-3);
224    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
225        this->blob_top_vec_);
226  }
227  TYPED_TEST(NormalizeLayerTest, TestGradientEltWise) {
228    typedef typename TypeParam::Dtype Dtype;
229    LayerParameter layer_param;
230    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
231    norm_param->set_across_spatial(false);
232    NormalizeLayer<Dtype> layer(layer_param);
233    GradientChecker<Dtype> checker(1e-3, 1e-3);
234    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
235        this->blob_top_vec_);
236  }
237  TYPED_TEST(NormalizeLayerTest, TestGradientEltWiseScale) {
238    typedef typename TypeParam::Dtype Dtype;
239    LayerParameter layer_param;
240    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
241    norm_param->set_across_spatial(false);
242    norm_param->mutable_scale_filler()->set_type("constant");
243    norm_param->mutable_scale_filler()->set_value(3);
244    NormalizeLayer<Dtype> layer(layer_param);
245    GradientChecker<Dtype> checker(1e-3, 2e-3);
246    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
247        this->blob_top_vec_);
248  }
249  TYPED_TEST(NormalizeLayerTest, TestGradientEltWiseScaleChannel) {
250    typedef typename TypeParam::Dtype Dtype;
251    LayerParameter layer_param;
252    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
253    norm_param->set_across_spatial(false);
254    norm_param->set_channel_shared(false);
255    norm_param->mutable_scale_filler()->set_type("constant");
256    norm_param->mutable_scale_filler()->set_value(3);
257    NormalizeLayer<Dtype> layer(layer_param);
258    GradientChecker<Dtype> checker(1e-3, 2e-3);
259    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
260        this->blob_top_vec_);
261  }
262  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_io.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_normalize_layer.cpp</div>
                <div class="column column_space"><pre><code>37      for (int c = 0; c < num_channels; ++c) {
38        for (int h = 0; h < cv_img.rows; ++h) {
39          for (int w = 0; w < cv_img.cols; ++w) {
</pre></code></div>
                <div class="column column_space"><pre><code>125    for (int i = 0; i < num; ++i) {
126      for (int k = 0; k < height; ++k) {
127        for (int l = 0; l < width; ++l) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    