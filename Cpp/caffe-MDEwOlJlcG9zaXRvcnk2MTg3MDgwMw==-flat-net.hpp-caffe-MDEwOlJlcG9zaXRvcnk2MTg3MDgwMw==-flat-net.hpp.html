
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-net.hpp</h3>
            <pre><code>1  #ifndef CAFFE_NET_HPP_
2  #define CAFFE_NET_HPP_
3  #include <map>
4  #include <set>
5  #include <string>
6  #include <utility>
7  #include <vector>
8  #include "caffe/blob.hpp"
9  #include "caffe/common.hpp"
10  #include "caffe/layer.hpp"
11  #include "caffe/proto/caffe.pb.h"
12  #include "caffe/util/benchmark.hpp"
13  namespace caffe {
14  class CircleBuf {
15    private:
16      vector<pair<void*, int>> circleBuf;
17      size_t BufSize;
18    public:
19      static CircleBuf* Instance() {
20        static CircleBuf* instance = new CircleBuf();
21        return instance;
22      }
23      inline void* GetFreeBuf() {
24        if (BufSize == 0) return NULL;
25        for (auto & p : circleBuf) {
26          if (p.second == 0) {p.second = 1; return p.first;}
27        }
28        void* buf = NULL;
29        bool  cuda;
30        CaffeMallocHost(&buf, BufSize * 4, &cuda); 
31        circleBuf.push_back(make_pair(buf, 1));
32        return buf;
33      }
34      inline void IncRefCnt(const void* buf, size_t refcnt) {
35        for (auto & p : circleBuf) {
36          if (p.first == buf) {p.second += refcnt;}
37        }
38      }
39      inline void DecRefCnt(const void* buf) {
40        for (auto & p : circleBuf) {
41          if (p.first == buf) {if (p.second > 0) p.second -= 1;}
42        }
43      }
44      inline void   SetBufSize(size_t size) {BufSize = size;}
45      inline size_t GetBufSize() {return BufSize;}
46      inline size_t GetQueueSize() {return circleBuf.size();}
47    private:                         
48      CircleBuf() { BufSize = 0; circleBuf.clear(); }
49  };
50  template <typename Dtype>
51  class Net {
52   public:
<span onclick='openModal()' class='match'>53    explicit Net(const NetParameter& param, const Net* root_net = NULL);
54    explicit Net(const string& param_file, Phase phase,
</span>55        const int level = 0, const vector<string>* stages = NULL,
56        const Net* root_net = NULL, std::string engine = "");
57    virtual ~Net() {}
58    static vector<CircleBuf> circleBuf;
59    void Init(const NetParameter& param);
60    const vector<Blob<Dtype>*>& Forward(Dtype* loss = NULL);
61    const vector<Blob<Dtype>*>& ForwardPrefilled(Dtype* loss = NULL) {
62      LOG_EVERY_N(WARNING, 1000) << "DEPRECATED: ForwardPrefilled() "
63          << "will be removed in a future version. Use Forward().";
64      return Forward(loss);
65    }
66    Dtype ForwardFromTo(int start, int end);
67    Dtype ForwardFrom(int start);
68    Dtype ForwardTo(int end);
69    const vector<Blob<Dtype>*>& Forward(const vector<Blob<Dtype>* > & bottom,
70        Dtype* loss = NULL);
71    void ClearParamDiffs(int learnable_param_id);
72    void ClearParamDiffs();
73    void Backward();
74    void BackwardFromTo(int start, int end);
75    void BackwardFrom(int start);
76    void BackwardTo(int end);
77    void Reshape();
78    Dtype ForwardBackward() {
79      Dtype loss;
80      Forward(&loss);
81      Backward();
82      return loss;
83    }
84    void Update();
85    void ShareWeights();
86    void ShareTrainedLayersWith(const Net* other);
87    void CopyTrainedLayersFrom(const NetParameter& param);
88    void CopyTrainedLayersFrom(const string trained_filename);
89    void CopyTrainedLayersFromBinaryProto(const string trained_filename);
90    void CopyTrainedLayersFromHDF5(const string trained_filename);
91    void ToProto(NetParameter* param, bool write_diff = false) const;
92    void ToHDF5(const string& filename, bool write_diff = false) const;
93    inline const string& name() const { return name_; }
94    inline const vector<string>& layer_names() const { return layer_names_; }
95    inline const vector<string>& blob_names() const { return blob_names_; }
96    inline const vector<shared_ptr<Blob<Dtype> > >& blobs() const {
97      return blobs_;
98    }
99    inline const vector<shared_ptr<Layer<Dtype> > >& layers() const {
100      return layers_;
101    }
102    inline Phase phase() const { return phase_; }
103    inline const vector<vector<Blob<Dtype>*> >& bottom_vecs() const {
104      return bottom_vecs_;
105    }
106    inline const vector<vector<Blob<Dtype>*> >& top_vecs() const {
107      return top_vecs_;
108    }
109    inline const vector<int> & top_ids(int i) const {
110      CHECK_GE(i, 0) << "Invalid layer id";
111      CHECK_LT(i, top_id_vecs_.size()) << "Invalid layer id";
112      return top_id_vecs_[i];
113    }
114    inline const vector<int> & bottom_ids(int i) const {
115      CHECK_GE(i, 0) << "Invalid layer id";
116      CHECK_LT(i, bottom_id_vecs_.size()) << "Invalid layer id";
117      return bottom_id_vecs_[i];
118    }
119    inline const vector<vector<bool> >& bottom_need_backward() const {
120      return bottom_need_backward_;
121    }
122    inline const vector<Dtype>& blob_loss_weights() const {
123      return blob_loss_weights_;
124    }
125    inline const vector<bool>& layer_need_backward() const {
126      return layer_need_backward_;
127    }
128    inline const vector<shared_ptr<Blob<Dtype> > >& params() const {
129      return params_;
130    }
131    inline const vector<Blob<Dtype>*>& learnable_params() const {
132      return learnable_params_;
133    }
134    vector<int> get_layer_learnable_param_ids(int layer_id) const;
135    inline const vector<float>& params_lr() const { return params_lr_; }
136    inline const vector<bool>& has_params_lr() const { return has_params_lr_; }
137    inline const vector<float>& params_weight_decay() const {
138      return params_weight_decay_;
139    }
140    inline const vector<bool>& has_params_decay() const {
141      return has_params_decay_;
142    }
143    const map<string, int>& param_names_index() const {
144      return param_names_index_;
145    }
146    inline const vector<int>& param_owners() const { return param_owners_; }
147    inline const vector<string>& param_display_names() const {
148      return param_display_names_;
149    }
150    inline const pair<int, int>& param_layer_indices(int param_id) {
151      return param_layer_indices_[param_id];
152    }
153    inline int num_inputs() const { return net_input_blobs_.size(); }
154    inline int num_outputs() const { return net_output_blobs_.size(); }
155    inline const vector<Blob<Dtype>*>& input_blobs() const {
156      return net_input_blobs_;
157    }
158    inline const vector<Blob<Dtype>*>& output_blobs() const {
159      return net_output_blobs_;
160    }
161    inline const vector<int>& input_blob_indices() const {
162      return net_input_blob_indices_;
163    }
164    inline const vector<int>& output_blob_indices() const {
165      return net_output_blob_indices_;
166    }
167    bool has_blob(const string& blob_name) const;
168    const shared_ptr<Blob<Dtype> > blob_by_name(const string& blob_name) const;
169    bool has_layer(const string& layer_name) const;
170    const shared_ptr<Layer<Dtype> > layer_by_name(const string& layer_name) const;
171    void set_debug_info(const bool value) { debug_info_ = value; }
172    static void FilterNet(const NetParameter& param,
173        NetParameter* param_filtered);
174    static void CompileNet(const NetParameter& param,
175      NetParameter* param_compiled);
176    static void CompilationRuleRemoveScale(const NetParameter& param,
177                                   NetParameter* param_compiled);
178    static void CompilationRuleConvReluFusion(const NetParameter& param,
179                                   NetParameter* param_compiled);
180    static void CompilationRuleBNInplace(const NetParameter& param,
181                               NetParameter* param_compiled);
182    static void CompilationRuleConvSumFusion(const NetParameter& param,
183                               NetParameter* param_compiled);
184    static void CompilationRuleSparse(const NetParameter& param,
185                               NetParameter* param_compiled);
186    static void CompilationRuleFuseBnRelu(const NetParameter& param,
187                                   NetParameter* param_compiled);
188    static void CompilationRuleFuseFCRelu(const NetParameter& param,
189                                   NetParameter* param_compiled);
190    static void GetBlobConsumers(std::vector<const LayerParameter*> &cnsmer_blobs,
191                                                  const string& blob_name_to_find,
192                                                  const NetParameter& param,
193                                                  int layer_id);
194    static void GetBlobProducers(std::vector<const LayerParameter*> &producer_blobs,
195                                                  const string& blob_name_to_find,
196                                                  const NetParameter& param,
197                                                  int layer_id);
198    static void GetNeedToCancelInplaceLayers(
199        vector<vector<const LayerParameter*>>& layer_pairs,    
200        std::map<string, int>& specified_layer_blob_name_to_index,      
201        std::map<string, int>& inplace_blob_name_to_index,
202        vector<string>& each_blob_list,
203        const NetParameter& param);
204    static void ParseNetInplaceStatus(
205        std::map<string, int>& inplace_blob_name_to_index,
206        std::map<string, int>& specified_layer_blob_name_to_index,      
207        vector<vector<string>>& specified_layer_input_blob_names,
208        NetParameter* param, const string& specified_layer_type);
209    static bool StateMeetsRule(const NetState& state, const NetStateRule& rule,
210        const string& layer_name);
211    void RangeInLayers(vector<string>* layer_name, vector<Dtype>* max_in,
212        vector<Dtype>* max_out, vector<vector<Dtype>>* max_param, string scaling);
213    vector<Dtype> FindMax(Blob<Dtype>* blob, bool is_single=true);
214    inline const map<string,int>& blob_names_index() const {
215      return blob_names_index_;
216    }
217  #ifdef CAFFE_PER_LAYER_TIMINGS
218    Timer timer;
219  #ifdef FW_OVERLAP_OPT
220    Timer wait_timer;
221  #endif
222    std::vector<double> forward_time_per_layer;
223    std::vector<double> backward_time_per_layer;
224    std::vector<double> update_time_per_layer;
225    double cleardiffs_time_per_iter;
226  #ifdef USE_MLSL
227    std::vector<double> startcomm_time_per_layer;
228    std::vector<double> waitcomm_time_per_layer;
229    std::vector<double> startcomm_start_time_per_layer;
230    std::vector<double> waitcomm_start_time_per_layer;
231    std::vector<double> startcomm_stop_time_per_layer;
232    std::vector<double> waitcomm_stop_time_per_layer;
233  #ifdef FW_OVERLAP_OPT
234    std::vector<double> first_waitcomm_start_time_per_layer;
235    std::vector<double> first_waitcomm_stop_time_per_layer;
236    std::vector<double> first_update_start_time_per_layer;
237    std::vector<double> first_update_stop_time_per_layer;
238  #endif
239  #endif
240    std::vector<double> forward_time_per_layer_total;
241    std::vector<double> backward_time_per_layer_total;
242    std::vector<double> update_time_per_layer_total;
243    double cleardiffs_time_per_iter_total;
244  #ifdef USE_MLSL
245    std::vector<double> startcomm_time_per_layer_total;
246    std::vector<double> waitcomm_time_per_layer_total;
247  #endif
248    std::vector<double> forward_start_time_per_layer;
249    std::vector<double> backward_start_time_per_layer;
250    std::vector<double> update_start_time_per_layer;
251    std::vector<double> forward_stop_time_per_layer;
252    std::vector<double> backward_stop_time_per_layer;
253    std::vector<double> update_stop_time_per_layer;
254    void InitTimers();
255    void ResetTimers();
256    void PrintTimers(bool printTotal);
257    void PrintPayloadSize();
258    void SaveTimeline();
259  #endif &bsol;* CAFFE_PER_LAYER_TIMINGS */
260   protected:
261    void AppendTop(const NetParameter& param, const int layer_id,
262                   const int top_id, set<string>* available_blobs,
263                   map<string, int>* blob_name_to_idx);
264    int AppendBottom(const NetParameter& param, const int layer_id,
265                     const int bottom_id, set<string>* available_blobs,
266                     map<string, int>* blob_name_to_idx);
267    void AppendParam(const NetParameter& param, const int layer_id,
268                     const int param_id);
269    void ForwardDebugInfo(const int layer_id);
270    void BackwardDebugInfo(const int layer_id);
271    void UpdateDebugInfo(const int param_id);
272    bool bn_scale_remove_;
273    bool bn_scale_merge_;
274    vector<string> kept_bn_layers_;
275    vector<Dtype> first_conv_quantized_shift_;
276    vector<string> first_conv_names_;
277    string name_;
278    string engine_name_;
279    Phase phase_;
280    vector<shared_ptr<Layer<Dtype> > > layers_;
281    vector<string> layer_names_;
282    map<string, int> layer_names_index_;
283    vector<bool> layer_need_backward_;
284    vector<shared_ptr<Blob<Dtype> > > blobs_;
285    vector<string> blob_names_;
286    map<string, int> blob_names_index_;
287    vector<bool> blob_need_backward_;
288    vector<vector<Blob<Dtype>*> > bottom_vecs_;
289    vector<vector<int> > bottom_id_vecs_;
290    vector<vector<bool> > bottom_need_backward_;
291    vector<vector<Blob<Dtype>*> > top_vecs_;
292    vector<vector<int> > top_id_vecs_;
293    vector<Dtype> blob_loss_weights_;
294    vector<vector<int> > param_id_vecs_;
295    vector<int> param_owners_;
296    vector<string> param_display_names_;
297    vector<pair<int, int> > param_layer_indices_;
298    map<string, int> param_names_index_;
299    vector<int> net_input_blob_indices_;
300    vector<int> net_output_blob_indices_;
301    vector<Blob<Dtype>*> net_input_blobs_;
302    vector<Blob<Dtype>*> net_output_blobs_;
303    vector<shared_ptr<Blob<Dtype> > > params_;
304    vector<Blob<Dtype>*> learnable_params_;
305    vector<int> learnable_param_ids_;
306    vector<float> params_lr_;
307    vector<bool> has_params_lr_;
308    vector<float> params_weight_decay_;
309    vector<bool> has_params_decay_;
310    size_t memory_used_;
311    size_t max_blob_count;
312    bool debug_info_;
313    const Net* const root_net_;
314    DISABLE_COPY_AND_ASSIGN(Net);
315  };
316  template<typename Dtype> vector<CircleBuf> Net<Dtype>::circleBuf;
317  }  
318  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-net.hpp</h3>
            <pre><code>1  #ifndef CAFFE_NET_HPP_
2  #define CAFFE_NET_HPP_
3  #include <map>
4  #include <set>
5  #include <string>
6  #include <utility>
7  #include <vector>
8  #include "caffe/blob.hpp"
9  #include "caffe/common.hpp"
10  #include "caffe/layer.hpp"
11  #include "caffe/proto/caffe.pb.h"
12  #include "caffe/util/benchmark.hpp"
13  namespace caffe {
14  class CircleBuf {
15    private:
16      vector<pair<void*, int>> circleBuf;
17      size_t BufSize;
18    public:
19      static CircleBuf* Instance() {
20        static CircleBuf* instance = new CircleBuf();
21        return instance;
22      }
23      inline void* GetFreeBuf() {
24        if (BufSize == 0) return NULL;
25        for (auto & p : circleBuf) {
26          if (p.second == 0) {p.second = 1; return p.first;}
27        }
28        void* buf = NULL;
29        bool  cuda;
30        CaffeMallocHost(&buf, BufSize * 4, &cuda); 
31        circleBuf.push_back(make_pair(buf, 1));
32        return buf;
33      }
34      inline void IncRefCnt(const void* buf, size_t refcnt) {
35        for (auto & p : circleBuf) {
36          if (p.first == buf) {p.second += refcnt;}
37        }
38      }
39      inline void DecRefCnt(const void* buf) {
40        for (auto & p : circleBuf) {
41          if (p.first == buf) {if (p.second > 0) p.second -= 1;}
42        }
43      }
44      inline void   SetBufSize(size_t size) {BufSize = size;}
45      inline size_t GetBufSize() {return BufSize;}
46      inline size_t GetQueueSize() {return circleBuf.size();}
47    private:                         
48      CircleBuf() { BufSize = 0; circleBuf.clear(); }
49  };
50  template <typename Dtype>
51  class Net {
52   public:
<span onclick='openModal()' class='match'>53    explicit Net(const NetParameter& param, const Net* root_net = NULL);
54    explicit Net(const string& param_file, Phase phase,
</span>55        const int level = 0, const vector<string>* stages = NULL,
56        const Net* root_net = NULL, std::string engine = "");
57    virtual ~Net() {}
58    static vector<CircleBuf> circleBuf;
59    void Init(const NetParameter& param);
60    const vector<Blob<Dtype>*>& Forward(Dtype* loss = NULL);
61    const vector<Blob<Dtype>*>& ForwardPrefilled(Dtype* loss = NULL) {
62      LOG_EVERY_N(WARNING, 1000) << "DEPRECATED: ForwardPrefilled() "
63          << "will be removed in a future version. Use Forward().";
64      return Forward(loss);
65    }
66    Dtype ForwardFromTo(int start, int end);
67    Dtype ForwardFrom(int start);
68    Dtype ForwardTo(int end);
69    const vector<Blob<Dtype>*>& Forward(const vector<Blob<Dtype>* > & bottom,
70        Dtype* loss = NULL);
71    void ClearParamDiffs(int learnable_param_id);
72    void ClearParamDiffs();
73    void Backward();
74    void BackwardFromTo(int start, int end);
75    void BackwardFrom(int start);
76    void BackwardTo(int end);
77    void Reshape();
78    Dtype ForwardBackward() {
79      Dtype loss;
80      Forward(&loss);
81      Backward();
82      return loss;
83    }
84    void Update();
85    void ShareWeights();
86    void ShareTrainedLayersWith(const Net* other);
87    void CopyTrainedLayersFrom(const NetParameter& param);
88    void CopyTrainedLayersFrom(const string trained_filename);
89    void CopyTrainedLayersFromBinaryProto(const string trained_filename);
90    void CopyTrainedLayersFromHDF5(const string trained_filename);
91    void ToProto(NetParameter* param, bool write_diff = false) const;
92    void ToHDF5(const string& filename, bool write_diff = false) const;
93    inline const string& name() const { return name_; }
94    inline const vector<string>& layer_names() const { return layer_names_; }
95    inline const vector<string>& blob_names() const { return blob_names_; }
96    inline const vector<shared_ptr<Blob<Dtype> > >& blobs() const {
97      return blobs_;
98    }
99    inline const vector<shared_ptr<Layer<Dtype> > >& layers() const {
100      return layers_;
101    }
102    inline Phase phase() const { return phase_; }
103    inline const vector<vector<Blob<Dtype>*> >& bottom_vecs() const {
104      return bottom_vecs_;
105    }
106    inline const vector<vector<Blob<Dtype>*> >& top_vecs() const {
107      return top_vecs_;
108    }
109    inline const vector<int> & top_ids(int i) const {
110      CHECK_GE(i, 0) << "Invalid layer id";
111      CHECK_LT(i, top_id_vecs_.size()) << "Invalid layer id";
112      return top_id_vecs_[i];
113    }
114    inline const vector<int> & bottom_ids(int i) const {
115      CHECK_GE(i, 0) << "Invalid layer id";
116      CHECK_LT(i, bottom_id_vecs_.size()) << "Invalid layer id";
117      return bottom_id_vecs_[i];
118    }
119    inline const vector<vector<bool> >& bottom_need_backward() const {
120      return bottom_need_backward_;
121    }
122    inline const vector<Dtype>& blob_loss_weights() const {
123      return blob_loss_weights_;
124    }
125    inline const vector<bool>& layer_need_backward() const {
126      return layer_need_backward_;
127    }
128    inline const vector<shared_ptr<Blob<Dtype> > >& params() const {
129      return params_;
130    }
131    inline const vector<Blob<Dtype>*>& learnable_params() const {
132      return learnable_params_;
133    }
134    vector<int> get_layer_learnable_param_ids(int layer_id) const;
135    inline const vector<float>& params_lr() const { return params_lr_; }
136    inline const vector<bool>& has_params_lr() const { return has_params_lr_; }
137    inline const vector<float>& params_weight_decay() const {
138      return params_weight_decay_;
139    }
140    inline const vector<bool>& has_params_decay() const {
141      return has_params_decay_;
142    }
143    const map<string, int>& param_names_index() const {
144      return param_names_index_;
145    }
146    inline const vector<int>& param_owners() const { return param_owners_; }
147    inline const vector<string>& param_display_names() const {
148      return param_display_names_;
149    }
150    inline const pair<int, int>& param_layer_indices(int param_id) {
151      return param_layer_indices_[param_id];
152    }
153    inline int num_inputs() const { return net_input_blobs_.size(); }
154    inline int num_outputs() const { return net_output_blobs_.size(); }
155    inline const vector<Blob<Dtype>*>& input_blobs() const {
156      return net_input_blobs_;
157    }
158    inline const vector<Blob<Dtype>*>& output_blobs() const {
159      return net_output_blobs_;
160    }
161    inline const vector<int>& input_blob_indices() const {
162      return net_input_blob_indices_;
163    }
164    inline const vector<int>& output_blob_indices() const {
165      return net_output_blob_indices_;
166    }
167    bool has_blob(const string& blob_name) const;
168    const shared_ptr<Blob<Dtype> > blob_by_name(const string& blob_name) const;
169    bool has_layer(const string& layer_name) const;
170    const shared_ptr<Layer<Dtype> > layer_by_name(const string& layer_name) const;
171    void set_debug_info(const bool value) { debug_info_ = value; }
172    static void FilterNet(const NetParameter& param,
173        NetParameter* param_filtered);
174    static void CompileNet(const NetParameter& param,
175      NetParameter* param_compiled);
176    static void CompilationRuleRemoveScale(const NetParameter& param,
177                                   NetParameter* param_compiled);
178    static void CompilationRuleConvReluFusion(const NetParameter& param,
179                                   NetParameter* param_compiled);
180    static void CompilationRuleBNInplace(const NetParameter& param,
181                               NetParameter* param_compiled);
182    static void CompilationRuleConvSumFusion(const NetParameter& param,
183                               NetParameter* param_compiled);
184    static void CompilationRuleSparse(const NetParameter& param,
185                               NetParameter* param_compiled);
186    static void CompilationRuleFuseBnRelu(const NetParameter& param,
187                                   NetParameter* param_compiled);
188    static void CompilationRuleFuseFCRelu(const NetParameter& param,
189                                   NetParameter* param_compiled);
190    static void GetBlobConsumers(std::vector<const LayerParameter*> &cnsmer_blobs,
191                                                  const string& blob_name_to_find,
192                                                  const NetParameter& param,
193                                                  int layer_id);
194    static void GetBlobProducers(std::vector<const LayerParameter*> &producer_blobs,
195                                                  const string& blob_name_to_find,
196                                                  const NetParameter& param,
197                                                  int layer_id);
198    static void GetNeedToCancelInplaceLayers(
199        vector<vector<const LayerParameter*>>& layer_pairs,    
200        std::map<string, int>& specified_layer_blob_name_to_index,      
201        std::map<string, int>& inplace_blob_name_to_index,
202        vector<string>& each_blob_list,
203        const NetParameter& param);
204    static void ParseNetInplaceStatus(
205        std::map<string, int>& inplace_blob_name_to_index,
206        std::map<string, int>& specified_layer_blob_name_to_index,      
207        vector<vector<string>>& specified_layer_input_blob_names,
208        NetParameter* param, const string& specified_layer_type);
209    static bool StateMeetsRule(const NetState& state, const NetStateRule& rule,
210        const string& layer_name);
211    void RangeInLayers(vector<string>* layer_name, vector<Dtype>* max_in,
212        vector<Dtype>* max_out, vector<vector<Dtype>>* max_param, string scaling);
213    vector<Dtype> FindMax(Blob<Dtype>* blob, bool is_single=true);
214    inline const map<string,int>& blob_names_index() const {
215      return blob_names_index_;
216    }
217  #ifdef CAFFE_PER_LAYER_TIMINGS
218    Timer timer;
219  #ifdef FW_OVERLAP_OPT
220    Timer wait_timer;
221  #endif
222    std::vector<double> forward_time_per_layer;
223    std::vector<double> backward_time_per_layer;
224    std::vector<double> update_time_per_layer;
225    double cleardiffs_time_per_iter;
226  #ifdef USE_MLSL
227    std::vector<double> startcomm_time_per_layer;
228    std::vector<double> waitcomm_time_per_layer;
229    std::vector<double> startcomm_start_time_per_layer;
230    std::vector<double> waitcomm_start_time_per_layer;
231    std::vector<double> startcomm_stop_time_per_layer;
232    std::vector<double> waitcomm_stop_time_per_layer;
233  #ifdef FW_OVERLAP_OPT
234    std::vector<double> first_waitcomm_start_time_per_layer;
235    std::vector<double> first_waitcomm_stop_time_per_layer;
236    std::vector<double> first_update_start_time_per_layer;
237    std::vector<double> first_update_stop_time_per_layer;
238  #endif
239  #endif
240    std::vector<double> forward_time_per_layer_total;
241    std::vector<double> backward_time_per_layer_total;
242    std::vector<double> update_time_per_layer_total;
243    double cleardiffs_time_per_iter_total;
244  #ifdef USE_MLSL
245    std::vector<double> startcomm_time_per_layer_total;
246    std::vector<double> waitcomm_time_per_layer_total;
247  #endif
248    std::vector<double> forward_start_time_per_layer;
249    std::vector<double> backward_start_time_per_layer;
250    std::vector<double> update_start_time_per_layer;
251    std::vector<double> forward_stop_time_per_layer;
252    std::vector<double> backward_stop_time_per_layer;
253    std::vector<double> update_stop_time_per_layer;
254    void InitTimers();
255    void ResetTimers();
256    void PrintTimers(bool printTotal);
257    void PrintPayloadSize();
258    void SaveTimeline();
259  #endif &bsol;* CAFFE_PER_LAYER_TIMINGS */
260   protected:
261    void AppendTop(const NetParameter& param, const int layer_id,
262                   const int top_id, set<string>* available_blobs,
263                   map<string, int>* blob_name_to_idx);
264    int AppendBottom(const NetParameter& param, const int layer_id,
265                     const int bottom_id, set<string>* available_blobs,
266                     map<string, int>* blob_name_to_idx);
267    void AppendParam(const NetParameter& param, const int layer_id,
268                     const int param_id);
269    void ForwardDebugInfo(const int layer_id);
270    void BackwardDebugInfo(const int layer_id);
271    void UpdateDebugInfo(const int param_id);
272    bool bn_scale_remove_;
273    bool bn_scale_merge_;
274    vector<string> kept_bn_layers_;
275    vector<Dtype> first_conv_quantized_shift_;
276    vector<string> first_conv_names_;
277    string name_;
278    string engine_name_;
279    Phase phase_;
280    vector<shared_ptr<Layer<Dtype> > > layers_;
281    vector<string> layer_names_;
282    map<string, int> layer_names_index_;
283    vector<bool> layer_need_backward_;
284    vector<shared_ptr<Blob<Dtype> > > blobs_;
285    vector<string> blob_names_;
286    map<string, int> blob_names_index_;
287    vector<bool> blob_need_backward_;
288    vector<vector<Blob<Dtype>*> > bottom_vecs_;
289    vector<vector<int> > bottom_id_vecs_;
290    vector<vector<bool> > bottom_need_backward_;
291    vector<vector<Blob<Dtype>*> > top_vecs_;
292    vector<vector<int> > top_id_vecs_;
293    vector<Dtype> blob_loss_weights_;
294    vector<vector<int> > param_id_vecs_;
295    vector<int> param_owners_;
296    vector<string> param_display_names_;
297    vector<pair<int, int> > param_layer_indices_;
298    map<string, int> param_names_index_;
299    vector<int> net_input_blob_indices_;
300    vector<int> net_output_blob_indices_;
301    vector<Blob<Dtype>*> net_input_blobs_;
302    vector<Blob<Dtype>*> net_output_blobs_;
303    vector<shared_ptr<Blob<Dtype> > > params_;
304    vector<Blob<Dtype>*> learnable_params_;
305    vector<int> learnable_param_ids_;
306    vector<float> params_lr_;
307    vector<bool> has_params_lr_;
308    vector<float> params_weight_decay_;
309    vector<bool> has_params_decay_;
310    size_t memory_used_;
311    size_t max_blob_count;
312    bool debug_info_;
313    const Net* const root_net_;
314    DISABLE_COPY_AND_ASSIGN(Net);
315  };
316  template<typename Dtype> vector<CircleBuf> Net<Dtype>::circleBuf;
317  }  
318  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-net.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-net.hpp</div>
                </div>
                <div class="column column_space"><pre><code>53    explicit Net(const NetParameter& param, const Net* root_net = NULL);
54    explicit Net(const string& param_file, Phase phase,
</pre></code></div>
                <div class="column column_space"><pre><code>53    explicit Net(const NetParameter& param, const Net* root_net = NULL);
54    explicit Net(const string& param_file, Phase phase,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    