
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.865796155241204%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-googlex.cpp</h3>
            <pre><code>1  #include "google.h"
2  TMd5Sig TGgSchRef::GetMd5Sig() const {
3    TChA ChA;
4    ChA+=TitleStr;
5    for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
6      ChA+=';'; ChA+=AuthNmV[AuthN];}
7    ChA+=';'; ChA+=PubNm;
8    ChA+=';'; ChA+=YearStr;
9    return TMd5Sig(ChA);
10  }
11  void TGgSchRef::GetAuthNmVPubStr(
12   const TStr& AuthNmVPubStr, TStrV& AuthNmV, TStr& PubNm, TStr& PubYearStr){
13    TStr AuthNmVStr; TStr PubStr;
14    AuthNmVPubStr.SplitOnStr(AuthNmVStr, " - ", PubStr);
15    AuthNmVStr.SplitOnAllCh(',', AuthNmV, true);
16    for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
17      AuthNmV[AuthN].ToTrunc();
18    }
19    if ((!AuthNmV.Empty())&&
20     ((AuthNmV.Last().IsStrIn("..."))||(AuthNmV.Last().Len()<=2))){
21      AuthNmV.DelLast();
22    }
23    TStr OriginStr; TStr LinkStr;
24    PubStr.SplitOnStr(OriginStr, " - ", LinkStr);
25    OriginStr.SplitOnLastCh(PubNm, ',', PubYearStr);
26    PubNm.ToTrunc(); PubYearStr.ToTrunc();
27    if ((PubYearStr.Len()>=4)&&(PubYearStr.GetSubStr(0, 3).IsInt())){
28      PubYearStr=PubYearStr.GetSubStr(0, 3);
29    } else
30    if ((PubNm.Len()>=4)&&(PubNm.GetSubStr(0, 3).IsInt())){
31      PubYearStr=PubNm.GetSubStr(0, 3); PubNm="";
32    } else {
33      PubYearStr="";
34    }
35  }
36  void TGgSchRef::SaveXml(FILE* fOut, const int& RefN){
37    if (RefN==-1){
38      fprintf(fOut, "    <Ref>\n");
39    } else {
40      fprintf(fOut, "    <Ref Num=\"%d\">\n", RefN);
41    }
42    fprintf(fOut, "    <MD5>%s</MD5>\n", GetMd5Sig().GetStr().CStr());
43    fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(TitleStr).CStr());
44    if (AuthNmV.Len()>0){
45      fprintf(fOut, "      <Authors>");
46      for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
47        fprintf(fOut, "<Author>%s</Author>", TXmlLx::GetXmlStrFromPlainStr(AuthNmV[AuthN]).CStr());
48      }
49      fprintf(fOut, "</Authors>\n");
50    }
51    if (!PubNm.Empty()){
52      fprintf(fOut, "      <Pub>%s</Pub>\n", TXmlLx::GetXmlStrFromPlainStr(PubNm).CStr());}
53    if (!YearStr.Empty()){
54      fprintf(fOut, "      <Year>%s</Year>\n", TXmlLx::GetXmlStrFromPlainStr(YearStr).CStr());}
55    fprintf(fOut, "      <Citations>%d</Citations>\n", Citations);
56    if (!CitedByUrlStr.Empty()){
57      fprintf(fOut, "      <CitedByUrl>%s</CitedByUrl>\n", TXmlLx::GetXmlStrFromPlainStr(CitedByUrlStr).CStr());}
58    fprintf(fOut, "    </Ref>\n");
59  }
60  PGgSchRSet TGgSchRSet::NewScholar(const TStr& UrlStr, const TStr& HtmlStr){
61    PGgSchRSet RSet=TGgSchRSet::New();
62    PSIn HtmlSIn=TStrIn::New(HtmlStr);
63    THtmlLx HtmlLx(HtmlSIn);
64    HtmlLx.MoveToStrOrEof("Results");
65    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
66    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
67    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
68    AllHitsStr.DelChAll(',');
69    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
70    HtmlLx.MoveToBTagOrEof("<P>");
71    forever {
72      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<P>"))){break;}
73      HtmlLx.GetSym();
74      if (HtmlLx.Sym==hsyBTag){
75        TStr FullBTagStr=HtmlLx.GetFullBTagStr();
76        if (FullBTagStr=="<FONT SIZE=\"-2\">"){
77          TStr PubTypeNm=HtmlLx.GetStrInTag("<B>", true);
78        } else
79        if (FullBTagStr=="<SPAN CLASS=\"w\">"){
80        } else {
81          break;
82        }
83        TStr TitleStr=HtmlLx.GetStrToBTag("<BR>", true).GetTrunc();
84        if (TitleStr.IsPrefix("[PS] ")){
85          TitleStr=TitleStr.GetSubStr(5, TitleStr.Len()).GetTrunc();}
86        TStr AuthNmVPubStr=HtmlLx.GetStrToBTag("<BR>", true);
87        TStrV AuthNmV; TStr PubNm; TStr PubYearStr;
88        TGgSchRef::GetAuthNmVPubStr(AuthNmVPubStr, AuthNmV, PubNm, PubYearStr);
89        TStr CitedByUrlStr; int Citations=0;
90        HtmlLx.MoveToBTag3OrEof("<A>", "<P>", "<DIV>");
91        if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.ChA=="<A>")){
92          TStr CitedByRelUrlStr=HtmlLx.GetArg("HREF");
93          TStr AStr=HtmlLx.GetStrToETag("<A>", true);
94          if (AStr.IsPrefix("Cited by ")){
95            PUrl CitedByUrl=TUrl::New(CitedByRelUrlStr, UrlStr);
96            if (CitedByUrl->IsOk()){
97              CitedByUrlStr=CitedByUrl->GetUrlStr();
98              Citations=AStr.GetSubStr(TStr("Cited by ").Len(), AStr.Len()).GetInt(0);
99            }
100          }
101          HtmlLx.MoveToBTag2OrEof("<P>", "<DIV>");
102        }
103        PGgSchRef Ref=
104         TGgSchRef::New(TitleStr, AuthNmV, PubNm, PubYearStr, Citations, CitedByUrlStr);
105        RSet->AddHit(Ref);
106      } else {
107        break;
108      }
109    }
110    TStr NextUrlStr;
111    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>")){
112      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
113      if (!NextRelUrlStr.Empty()){
114        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
115        if (NextUrl->IsOk()){
116          NextUrlStr=NextUrl->GetUrlStr();
117        }
118      }
119    }
120    RSet->PutUrlStr(UrlStr);
121    RSet->PutNextUrlStr(NextUrlStr);
122    RSet->PutQueryStr(QueryStr);
123    RSet->PutAllHits(AllHitsStr.GetInt(-1));
124    return RSet;
125  }
126  PGgSchRSet TGgSchRSet::NewScholar(const PWebPg& WebPg){
127    TStr UrlStr=WebPg->GetUrlStr();
128    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
129    return TGgSchRSet::NewScholar(UrlStr, HtmlStr);
130  }
131  void TGgSchRSet::Merge(const PGgSchRSet& RSet){
132    if (RSet.Empty()){return;}
133    TStrH TitleStrH(GetHits());
134    for (int HitN=0; HitN<GetHits(); HitN++){
135      TitleStrH.AddKey(GetHit(HitN)->TitleStr);
136    }
137    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
138      PGgSchRef Ref=RSet->GetHit(HitN);
139      if (!TitleStrH.IsKey(Ref->TitleStr)){
140        AddHit(Ref);
141        TitleStrH.AddKey(Ref->TitleStr);
142      }
143    }
144    PutNextUrlStr("");
145    PutAllHits(-1);
146  }
147  PBowDocBs TGgSchRSet::GetBowDocBs() const {
148    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
149    PStemmer Stemmer=TStemmer::New(stmtPorter, true);
150    TStrV HtmlStrV(GetHits(), 0);
151    for (int HitN=0; HitN<GetHits(); HitN++){
152      TStr HtmlStr=GetHit(HitN)->TitleStr;
153      HtmlStrV.Add(HtmlStr);
154    }
155    PNGramBs NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
156     HtmlStrV, 3, 3, SwSet, Stemmer);
157    printf("Create Bag-Of-Words Base ... ");
158    PBowDocBs BowDocBs=TBowDocBs::New();
159    BowDocBs->PutNGramBs(NGramBs);
160    for (int HitN=0; HitN<GetHits(); HitN++){
161      BowDocBs->AddHtmlDoc(TInt::GetStr(HitN), TStrV(), HtmlStrV[HitN]);
162    }
163    BowDocBs->AssertOk();
164    printf("Done.\n");
165    return BowDocBs;
166  }
<span onclick='openModal()' class='match'>167  void TGgSchRSet::SaveBin(const TStr& FNm, const PGgSchRSet& GgSchRSet){
168    if (GgSchRSet.Empty()){
169      PGgSchRSet RSet=TGgSchRSet::New();
170      GgSchRSet->SaveBin(FNm);
171    } else {
</span>172      GgSchRSet->SaveBin(FNm);
173    }
174  }
175  void TGgSchRSet::SaveXml(const TStr& FNm, const PGgSchRSet& GgSchRSet){
176    if (GgSchRSet.Empty()){
177      TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
178      fprintf(fOut, "<GgSchRSets>\n");
179      fprintf(fOut, "  <Error/>\n");
180      fprintf(fOut, "</GgSchRSets>");
181    } else {
182      GgSchRSet->SaveXml(FNm);
183    }
184  }
185  void TGgSchRSet::SaveXml(const TStr& FNm){
186    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
187    fprintf(fOut, "<RSet>\n");
188    if (!GetUrlStr().Empty()){
189      fprintf(fOut, "  <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(GetUrlStr()).CStr());}
190    if (!GetNextUrlStr().Empty()){
191      fprintf(fOut, "  <NextUrl>%s</NextUrl>\n", TXmlLx::GetXmlStrFromPlainStr(GetNextUrlStr()).CStr());}
192    if (!GetQueryStr().Empty()){
193      fprintf(fOut, "  <Query>%s</Query>\n", TXmlLx::GetXmlStrFromPlainStr(GetQueryStr()).CStr());}
194    if (GetAllHits()!=-1){
195      fprintf(fOut, "  <AllHits>%d</AllHits>\n", GetAllHits());}
196    fprintf(fOut, "  <Hits Size=\"%d\">\n", GetHits());
197    for (int HitN=0; HitN<GetHits(); HitN++){
198      PGgSchRef Ref=GetHit(HitN);
199      Ref->SaveXml(fOut, 1+HitN);
200    }
201    fprintf(fOut, "  </Hits>\n");
202    fprintf(fOut, "</RSet>");
203  }
204  void TGgSchRSet::LoadRSetsBin(const TStr& FNm, TGgSchRSetV& RSetV){
205    TFIn SIn(FNm); RSetV.Clr(); int RSets=0;
206    while (!SIn.Eof()){
207      RSets++; if (RSets%100==0){printf("%d\r", RSets);}
208      PGgSchRSet RSet(SIn);
209      RSetV.Add(RSet);
210    }
211  }
212  void TGgSchRSet::SaveRSetsBin(const TStr& FNm, TGgSchRSetV& RSetV){
213    TFOut SOut(FNm);
214    for (int RSetN=0; RSetN<RSetV.Len(); RSetN++){
215      RSetV[RSetN].Save(SOut);
216    }
217  }
218  void TGgSchBs::AddRef(const PGgSchRef& Ref){
219    TMd5Sig Sig=Ref->GetMd5Sig();
220    if (!RefMd5ToRefH.IsKey(Sig)){
221      RefMd5ToRefH.AddDat(Sig)=Ref;
222      RefMd5ToRefCiteCrawlPH.AddDat(Sig)=false;
223      for (int AuthN=0; AuthN<Ref->AuthNmV.Len(); AuthN++){
224        TStr LcAuthNm=Ref->AuthNmV[AuthN].GetLc();
225        if ((!LcAuthNm.Empty())&&(!AuthNmToCrawlPH.IsKey(LcAuthNm))){
226          AuthNmToCrawlPH.AddDat(LcAuthNm)=false;
227        }
228      }
229      TStr LcPubNm=Ref->PubNm.GetLc();
230      if ((!Ref->PubNm.Empty())&&(!AuthNmToCrawlPH.IsKey(LcPubNm))){
231        PubNmToCrawlPH.AddDat(LcPubNm)=false;
232      }
233    }
234  }
235  void TGgSchBs::AddRSet(const PGgSchRSet& RSet){
236    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
237      PGgSchRef Ref=RSet->GetHit(HitN);
238      AddRef(Ref);
239    }
240  }
241  TStr TGgSchBs::GetAuthNmToCrawl() const {
242    TStr AuthNm;
243    for (int AuthN=0; AuthN<AuthNmToCrawlPH.Len(); AuthN++){
244      if (!AuthNmToCrawlPH[AuthN]){
245        AuthNm=AuthNmToCrawlPH.GetKey(AuthN); break;
246      }
247    }
248    return AuthNm;
249  }
250  void TGgSchBs::SetAuthCrawled(const TStr& AuthNm){
251    AuthNmToCrawlPH.AddDat(AuthNm.GetLc())=true;
252  }
253  void TGgSchBs::SaveXml(const TStr& FNm){
254    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
255    fprintf(fOut, "<GgSchBs>\n");
256    for (int RefN=0; RefN<GetRefs(); RefN++){
257      PGgSchRef Ref=GetRef(RefN);
258      Ref->SaveXml(fOut, 1+RefN);
259    }
260    fprintf(fOut, "</GgSchBs>");
261  }
262  PRSet TRSet::NewWeb(const TStr& UrlStr, const TStr& HtmlStr){
263    PRSet RSet=TRSet::New();
264    PSIn HtmlSIn=TStrIn::New(HtmlStr);
265    THtmlLx HtmlLx(HtmlSIn);
266    HtmlLx.MoveToStrOrEof("Results");
267    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
268    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
269    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
270    AllHitsStr.DelChAll(',');
271    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
272    forever {
273      HtmlLx.MoveToBTagOrEof("<P>", "CLASS", "g", "<DIV>", "CLASS", "n");
274      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<P>"))){break;}
275      HtmlLx.MoveToBTagOrEof("<A>");
276      if (HtmlLx.Sym!=hsyBTag){break;}
277      TStr HitUrlStr=HtmlLx.GetArg("HREF");
278      TStr HitTitleStr=HtmlLx.GetStrToETag("<A>", true);
279      HtmlLx.MoveToBTagOrEof("<FONT>");
280      TStr HitCtxStr=HtmlLx.GetStrToBTag("<FONT>", "COLOR", "#008000", true);
281      RSet->AddHit(HitUrlStr, HitTitleStr, "", HitCtxStr);
282    }
283    TStr NextUrlStr;
284    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>")){
285      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
286      if (!NextRelUrlStr.Empty()){
287        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
288        if (NextUrl->IsOk()){
289          NextUrlStr=NextUrl->GetUrlStr();
290        }
291      }
292    }
293    RSet->PutUrlStr(UrlStr);
294    RSet->PutNextUrlStr(NextUrlStr);
295    RSet->PutQueryStr(QueryStr);
296    RSet->PutAllHits(AllHitsStr.GetInt(-1));
297    return RSet;
298  }
299  PRSet TRSet::NewWeb(const PWebPg& WebPg){
300    TStr UrlStr=WebPg->GetUrlStr();
301    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
302    return TRSet::NewWeb(UrlStr, HtmlStr);
303  }
304  PRSet TRSet::NewNews(const TStr& UrlStr, const TStr& HtmlStr){
305    PRSet RSet=TRSet::New();
306    PSIn HtmlSIn=TStrIn::New(HtmlStr);
307    THtmlLx HtmlLx(HtmlSIn);
308    HtmlLx.MoveToStrOrEof("Results");
309    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
310    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
311    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
312    AllHitsStr.DelChAll(',');
313    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
314    forever {
315      HtmlLx.MoveToBTagOrEof("<TABLE>", "WIDTH", "75%", "<DIV>", "CLASS", "n");
316      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<TABLE>"))){break;}
317      HtmlLx.MoveToBTagOrEof("<A>");
318      if (HtmlLx.Sym!=hsyBTag){break;}
319      TStr HitUrlStr=HtmlLx.GetArg("HREF");
320      TStr IdStr=HtmlLx.GetArg("ID");
321      if ((!IdStr.Empty())&&(IdStr.LastCh()=='i')){
322        HtmlLx.MoveToBTagOrEof("<A>");
323        if (HtmlLx.Sym!=hsyBTag){break;}
324        HitUrlStr=HtmlLx.GetArg("HREF");
325      }
326      TStr HitTitleStr=HtmlLx.GetStrToETag("<A>", true);
327      TStr HitSrcNm=HtmlLx.GetStrToBTag("<NOBR>", true);
328      if (HitSrcNm.IsSuffix(" -")){
329        HitSrcNm=HitSrcNm.GetSubStr(0, HitSrcNm.Len()-3);}
330      HtmlLx.MoveToETagOrEof("<NOBR>");
331      TStr HitCtxStr=HtmlLx.GetStrToETag("<TABLE>", true);
332      RSet->AddHit(HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
333    }
334    TStr NextUrlStr;
335    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>")){
336      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
337      if (!NextRelUrlStr.Empty()){
338        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
339        if (NextUrl->IsOk()){
340          NextUrlStr=NextUrl->GetUrlStr();
341        }
342      }
343    }
344    RSet->PutUrlStr(UrlStr);
345    RSet->PutNextUrlStr(NextUrlStr);
346    RSet->PutQueryStr(QueryStr);
347    RSet->PutAllHits(AllHitsStr.GetInt(-1));
348    return RSet;
349  }
350  PRSet TRSet::NewNews(const PWebPg& WebPg){
351    TStr UrlStr=WebPg->GetUrlStr();
352    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
353    return TRSet::NewNews(UrlStr, HtmlStr);
354  }
355  int TRSet::GetHitN(const TStr& UrlStr, const bool& LcP) const {
356    int Hits=GetHits();
357    TStr LcUrlStr=UrlStr.GetLc();
358    for (int HitN=0; HitN<Hits; HitN++){
359      if (LcP){
360        if (GetHitUrlStr(HitN).GetLc()==LcUrlStr){return HitN;}
361      } else {
362        if (GetHitUrlStr(HitN)==UrlStr){return HitN;}
363      }
364    }
365    return -1;
366  }
367  void TRSet::Merge(const PRSet& RSet){
368    if (RSet.Empty()){return;}
369    TStrH UrlStrH(GetHits());
370    for (int HitN=0; HitN<GetHits(); HitN++){
371      UrlStrH.AddKey(GetHitUrlStr(HitN));
372    }
373    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
374      TStr HitUrlStr; TStr HitTitleStr; TStr HitSrcNm; TStr HitCtxStr;
375      RSet->GetHit(HitN, HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
376      if (!UrlStrH.IsKey(HitUrlStr)){
377        AddHit(HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
378        UrlStrH.AddKey(HitUrlStr);
379      }
380    }
381    PutNextUrlStr("");
382    PutAllHits(-1);
383  }
384  PBowDocBs TRSet::GetBowDocBs() const {
385    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
386    PStemmer Stemmer=TStemmer::New(stmtPorter, true);
387    TStrV HtmlStrV(GetHits(), 0);
388    for (int HitN=0; HitN<GetHits(); HitN++){
389      TStr TitleStr=GetHitTitleStr(HitN);
390      TStr CtxStr=GetHitCtxStr(HitN);
391      TStr HtmlStr=TitleStr+". "+CtxStr;
392      HtmlStrV.Add(HtmlStr);
393    }
394    PNGramBs NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
395     HtmlStrV, 3, 3, SwSet, Stemmer);
396    printf("Create Bag-Of-Words Base ... ");
397    PBowDocBs BowDocBs=TBowDocBs::New();
398    BowDocBs->PutNGramBs(NGramBs);
399    for (int HitN=0; HitN<GetHits(); HitN++){
400      BowDocBs->AddHtmlDoc(GetHitUrlStr(HitN), TStrV(), HtmlStrV[HitN]);
401    }
402    BowDocBs->AssertOk();
403    printf("Done.\n");
404    return BowDocBs;
405  }
406  void TRSet::SaveBin(const TStr& FNm, const PRSet& RSet){
407    if (RSet.Empty()){
408      PRSet RSet=TRSet::New();
409      RSet->SaveBin(FNm);
410    } else {
411      RSet->SaveBin(FNm);
412    }
413  }
414  void TRSet::SaveXml(const TStr& FNm, const PRSet& RSet){
415    if (RSet.Empty()){
416      TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
417      fprintf(fOut, "<RSets>\n");
418      fprintf(fOut, "  <Error/>\n");
419      fprintf(fOut, "</RSets>");
420    } else {
421      RSet->SaveXml(FNm);
422    }
423  }
424  void TRSet::SaveXml(const TStr& FNm){
425    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
426    fprintf(fOut, "<RSet>\n");
427    if (!GetUrlStr().Empty()){
428      fprintf(fOut, "  <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(GetUrlStr()).CStr());}
429    if (!GetNextUrlStr().Empty()){
430      fprintf(fOut, "  <NextUrl>%s</NextUrl>\n", TXmlLx::GetXmlStrFromPlainStr(GetNextUrlStr()).CStr());}
431    if (!GetQueryStr().Empty()){
432      fprintf(fOut, "  <Query>%s</Query>\n", TXmlLx::GetXmlStrFromPlainStr(GetQueryStr()).CStr());}
433    if (GetAllHits()!=-1){
434      fprintf(fOut, "  <AllHits>%d</AllHits>\n", GetAllHits());}
435    fprintf(fOut, "  <Hits Size=\"%d\">\n", GetHits());
436    for (int HitN=0; HitN<GetHits(); HitN++){
437      TStr HitUrlStr; TStr HitTitleStr; TStr HitSrcNm; TStr HitCtxStr;
438      GetHit(HitN, HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
439      fprintf(fOut, "    <Hit Num=\"%d\">\n", 1+HitN);
440      fprintf(fOut, "      <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(HitUrlStr).CStr());
441      fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(HitTitleStr).CStr());
442      if (!HitSrcNm.Empty()){
443        fprintf(fOut, "      <Source>%s</Source>\n", TXmlLx::GetXmlStrFromPlainStr(HitSrcNm).CStr());}
444      fprintf(fOut, "      <Snippet>%s</Snippet>\n", TXmlLx::GetXmlStrFromPlainStr(HitCtxStr).CStr());
445      fprintf(fOut, "    </Hit>\n");
446    }
447    fprintf(fOut, "  </Hits>\n");
448    fprintf(fOut, "</RSet>");
449  }
450  void TRSet::LoadRSetsBin(const TStr& FNm, TRSetV& RSetV){
451    TFIn SIn(FNm); RSetV.Clr(); int RSets=0;
452    while (!SIn.Eof()){
453      RSets++; if (RSets%100==0){printf("%d\r", RSets);}
454      PRSet RSet(SIn);
455      RSetV.Add(RSet);
456    }
457  }
458  void TRSet::SaveRSetsBin(const TStr& FNm, TRSetV& RSetV){
459    TFOut SOut(FNm);
460    for (int RSetN=0; RSetN<RSetV.Len(); RSetN++){
461      RSetV[RSetN].Save(SOut);
462    }
463  }
464  void TGgWebFetchSaver::OnFetch(const int&, const PWebPg& WebPg){
465    printf("Fetched [Wait:%d Conn.:%d]: %s\n",
466     GetWaitUrls(), GetConnUrls(), WebPg->GetUrlStr().CStr());
467    WebPgV.Add(WebPg);
468    if (Empty()){
469      TSysMsg::Quit();}
470  }
471  void TGgWebFetchSaver::OnError(const int&, const TStr& MsgStr){
472    printf("Error [Wait:%d Conn.:%d]: %s\n",
473     GetWaitUrls(), GetConnUrls(), MsgStr.CStr());
474    if (Empty()){
475      TSysMsg::Quit();}
476  }
477  PWebPg TGgWebFetchSaver::GetWebPg(const TStr& UrlStr) const {
478    for (int WebPgN=0; WebPgN<GetWebPgs(); WebPgN++){
479      if (GetWebPg(WebPgN)->GetUrlStr(0)==UrlStr){
480        return GetWebPg(WebPgN);}
481    }
482    return NULL;
483  }
484  PGgFCrawl TGgFCrawl::GetFCrawl(
485   const TStr& SrcUrlStr, const int& MxCands, const TStr& ProxyStr){
486    printf("Expand source URL: %s\n", SrcUrlStr.CStr());
487    PRSet SrcUrlRSet=
488     TGg::WebSearch(TStr("related:")+SrcUrlStr, -1, TNotify::NullNotify, ProxyStr);
489    PGgFCrawl FCrawl=TGgFCrawl::New();
490    FCrawl->SrcUrlStr=SrcUrlStr;
491    FCrawl->DstRSet=TRSet::New(SrcUrlRSet);
492    for (int HitN=0; HitN<SrcUrlRSet->GetHits(); HitN++){
493      if ((MxCands!=-1)&&(FCrawl->DstRSet->GetHits()>MxCands)){break;}
494      TStr HitUrlStr=SrcUrlRSet->GetHitUrlStr(HitN);
495      printf("Expand URL: %s\n", HitUrlStr.CStr());
496      PRSet RelUrlRSet=
497       TGg::WebSearch(TStr("related:")+HitUrlStr, -1, TNotify::NullNotify, ProxyStr);
498      FCrawl->DstRSet->Merge(RelUrlRSet);
499    }
500    TGgWebFetchSaver WebFetchSaver(100);
501    WebFetchSaver.PutProxyStr(ProxyStr);
502    {bool Ok; TStr MsgStr;
503    TWebFetchBlocking::GetWebPg(
504     SrcUrlStr, Ok, MsgStr, FCrawl->SrcWebPg, NULL, ProxyStr);
505    if (!Ok){FCrawl->SrcWebPg=NULL;}}
506    int FetchHits=FCrawl->DstRSet->GetHits();
507    if ((MxCands!=-1)&&(MxCands<FetchHits)){FetchHits=MxCands;}
508    for (int HitN=0; HitN<FetchHits; HitN++){
509      TStr HitUrlStr=FCrawl->DstRSet->GetHitUrlStr(HitN);
510      WebFetchSaver.FetchUrl(HitUrlStr);
511    }
512    TSysMsg::Loop();
513    for (int WebPgN=0; WebPgN<WebFetchSaver.GetWebPgs(); WebPgN++){
514      PWebPg WebPg=WebFetchSaver.GetWebPg(WebPgN);
515      FCrawl->UrlStrToWebPgH.AddDat(WebPg->GetUrlStr(), WebPg);
516    }
517    FCrawl->BowDocBs=TBowDocBs::New();
518    FCrawl->SrcDId=FCrawl->BowDocBs->AddHtmlDoc(
519     SrcUrlStr, TStrV(), FCrawl->SrcWebPg->GetHttpBodyAsStr());
520    for (int WebPgN=0; WebPgN<WebFetchSaver.GetWebPgs(); WebPgN++){
521      PWebPg WebPg=WebFetchSaver.GetWebPg(WebPgN);
522      FCrawl->BowDocBs->AddHtmlDoc(
523       WebPg->GetUrlStr(0), TStrV(), WebPg->GetHttpBodyAsStr());
524    }
525    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(FCrawl->BowDocBs, bwwtNrmTFIDF);
526    PBowSim BowSim=TBowSim::New(bstCos);
527    FCrawl->SimDIdKdV; FCrawl->SumSim=0;
528    for (int DIdN=0; DIdN<BowDocWgtBs->GetDocs(); DIdN++){
529      int DId=BowDocWgtBs->GetDId(DIdN);
530      if (DId!=FCrawl->SrcDId){
531        double Sim=BowSim->GetSim(
532         BowDocWgtBs->GetSpV(FCrawl->SrcDId), BowDocWgtBs->GetSpV(DId));
533        FCrawl->SimDIdKdV.Add(TFltIntKd(Sim, DId));
534        FCrawl->SumSim+=Sim;
535      }
536    }
537    FCrawl->SimDIdKdV.Sort(false);
538    FCrawl->Ok=true;
539    return FCrawl;
540  }
541  void TGgFCrawl::SaveXml(const TStr& FNm, const bool& SaveDocP){
542    if (!Ok){return;}
543    PSOut SOut=TFOut::New(FNm);
544    FILE* fOut=SOut->GetFileId();
545    fprintf(fOut, "<FocusedCrawl>\n");
546    fprintf(fOut, "  <SourceWebPage>\n");
547    fprintf(fOut, "    <Url>%s</Url>\n", SrcUrlStr.CStr());
548    if (SaveDocP){
549      THtmlDoc::SaveHtmlToXml(SrcWebPg->GetHttpBodyAsStr(), SOut,
550       SrcUrlStr, false, false, true, false, false);
551    }
552    fprintf(fOut, "  </SourceWebPage>\n");
553    fprintf(fOut, "  <FocusedWebPages>\n", SimDIdKdV.Len());
554    double SumSimSF=0;
555    for (int DIdN=0; DIdN<SimDIdKdV.Len(); DIdN++){
556      double Sim=SimDIdKdV[DIdN].Key;
557      SumSimSF+=Sim; if ((SumSim==0)||(SumSimSF>SumSim*0.99)){break;}
558      int DId=SimDIdKdV[DIdN].Dat;
559      TStr UrlStr=BowDocBs->GetDocNm(DId);
560      printf("%d. %.3f %s\n", 1+DIdN, Sim, UrlStr.CStr());
561      int HitN=DstRSet->GetHitN(UrlStr); IAssert(HitN!=-1);
562      fprintf(fOut, "    <WebPage Rank=\"%d\" Sim=\"%.3f\">\n", 1+DIdN, Sim, UrlStr.CStr());
563      fprintf(fOut, "      <Url>%s</Url>\n", UrlStr.CStr());
564      fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(DstRSet->GetHitTitleStr(HitN)).CStr());
565      fprintf(fOut, "      <Context>%s</Context>\n", TXmlLx::GetXmlStrFromPlainStr(DstRSet->GetHitCtxStr(HitN)).CStr());
566      if (SaveDocP){
567        PWebPg WebPg=UrlStrToWebPgH.GetDat(UrlStr);
568        THtmlDoc::SaveHtmlToXml(WebPg->GetHttpBodyAsStr(), SOut,
569         SrcUrlStr, false, false, true, false, false);
570      }
571      fprintf(fOut, "    </WebPage>\n");
572    }
573    printf("\n");
574    fprintf(fOut, "  </FocusedWebPages>\n");
575    fprintf(fOut, "</FocusedCrawl>\n");
576  }
577  void TGgFCrawl::SaveTxt(const TStr& FNm){
578    PSOut SOut=TFOut::New(FNm);
579    FILE* fOut=SOut->GetFileId();
580    if (Ok){
581      fprintf(fOut, "<SourceWebPage>\n");
582      fprintf(fOut, "%s\n", SrcUrlStr.CStr());
583      double SumSimSF=0;
584      for (int DIdN=0; DIdN<SimDIdKdV.Len(); DIdN++){
585        double Sim=SimDIdKdV[DIdN].Key;
586        SumSimSF+=Sim; if ((SumSim==0)||(SumSimSF>SumSim*0.99)){break;}
587        int DId=SimDIdKdV[DIdN].Dat;
588        TStr UrlStr=BowDocBs->GetDocNm(DId);
589        printf("%d. %.3f %s\n", 1+DIdN, Sim, UrlStr.CStr());
590        int HitN=DstRSet->GetHitN(UrlStr); IAssert(HitN!=-1);
591        TStr TitleStr=DstRSet->GetHitTitleStr(HitN);
592        TitleStr.ChangeChAll('\n', ' ');
593        TStr CtxStr=DstRSet->GetHitCtxStr(HitN);
594        CtxStr.ChangeChAll('\n', ' ');
595        fprintf(fOut, "<ResultWebPage>\n");
596        fprintf(fOut, "%s\n", UrlStr.CStr());
597        fprintf(fOut, "%s\n", TitleStr.CStr());
598        fprintf(fOut, "%s\n", CtxStr.CStr());
599      }
600    } else {
601      fprintf(fOut, "<Error>\n");
602    }
603    fprintf(fOut, "<End>\n");
604  }
605  PGgCtxGraph TGgCtxGraph::GetCtxGraph(const TStr& FocusUrlStr){
606    PGgCtxGraph CtxGraph=TGgCtxGraph::New();
607    CtxGraph->Ok=false;
608    CtxGraph->FocusUrlStr=FocusUrlStr;
609    {bool Ok; TStr MsgStr;
610    TWebFetchBlocking::GetWebPg(
611     CtxGraph->FocusUrlStr, Ok, MsgStr, CtxGraph->FocusWebPg, TNotify::StdNotify);
612    if (!Ok){return CtxGraph;}}
613    PRSet InRSet=
614     TGg::WebSearch(TStr("link:")+CtxGraph->FocusUrlStr, -1, TNotify::StdNotify);
615    for (int HitN=0; HitN<InRSet->GetHits(); HitN++){
616      TStr UrlStr; TStr TitleStr; TStr SrcNm; TStr CtxStr;
617      InRSet->GetHit(HitN, UrlStr, TitleStr, SrcNm, CtxStr);
618      TitleStr.ChangeChAll('\n', ' ');
619      CtxGraph->InUrlCtxStrPrV.Add(TStrPr(UrlStr, TitleStr));
620    }
621    TStrKdV OutDescUrlStrKdV;
622    CtxGraph->FocusWebPg->GetOutDescUrlStrKdV(OutDescUrlStrKdV);
623    for (int UrlN=0; UrlN<OutDescUrlStrKdV.Len(); UrlN++){
624      OutDescUrlStrKdV[UrlN].Key.ChangeChAll('\n', ' ');
625      CtxGraph->OutUrlCtxStrPrV.Add(
626       TStrPr(OutDescUrlStrKdV[UrlN].Dat, OutDescUrlStrKdV[UrlN].Key));
627    }
628    CtxGraph->Ok=true;
629    return CtxGraph;
630  }
631  void TGgCtxGraph::SaveTxt(const TStr& FNm){
632    PSOut SOut=TFOut::New(FNm);
633    FILE* fOut=SOut->GetFileId();
634    if (Ok){
635      fprintf(fOut, "<FocusWebPage>\n");
636      fprintf(fOut, "%s\n", FocusUrlStr.CStr());
637      for (int UrlN=0; UrlN<InUrlCtxStrPrV.Len(); UrlN++){
638        fprintf(fOut, "<InWebPage>\n");
639        fprintf(fOut, "%s\n", InUrlCtxStrPrV[UrlN].Val1.CStr());
640        fprintf(fOut, "%s\n", InUrlCtxStrPrV[UrlN].Val2.CStr());
641      }
642      for (int UrlN=0; UrlN<OutUrlCtxStrPrV.Len(); UrlN++){
643        fprintf(fOut, "<OutWebPage>\n");
644        fprintf(fOut, "%s\n", OutUrlCtxStrPrV[UrlN].Val1.CStr());
645        fprintf(fOut, "%s\n", OutUrlCtxStrPrV[UrlN].Val2.CStr());
646      }
647    } else {
648      fprintf(fOut, "<Error>\n");
649    }
650    fprintf(fOut, "<End>\n");
651  }
652  TStr TGg::GetWebSearchUrlStr(const TStr& QueryStr){
653    TStr SearchUrlStr=
654     "http:&bsol;&bsol;www.google.com/search?num=100&q="+
655     TUrl::GetUrlSearchStr(QueryStr);
656    return SearchUrlStr;
657  }
658  TStr TGg::GetNewsSearchUrlStr(const TStr& QueryStr){
659    TStr SearchUrlStr=
660     "http:&bsol;&bsol;news.google.com/news?num=100&q="+
661     TUrl::GetUrlSearchStr(QueryStr);
662    return SearchUrlStr;
663  }
664  TStr TGg::GetScholarSearchUrlStr(const TStr& QueryStr){
665    TStr SearchUrlStr=
666     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q="+
667     TUrl::GetUrlSearchStr(QueryStr);
668    return SearchUrlStr;
669  }
670  TStr TGg::GetScholarAuthorSearchUrlStr(const TStr& QueryStr){
671    TStr AuthorQueryStr=TStr("author:\"")+QueryStr+"\"";
672    TStr SearchUrlStr=
673     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q="+
674     TUrl::GetUrlSearchStr(AuthorQueryStr);
675    return SearchUrlStr;
676  }
677  TStr TGg::GetScholarPublicationSearchUrlStr(const TStr& QueryStr){
678    TStr PublicationQueryStr=TStr("\"")+QueryStr+"\"";
679    TStr SearchUrlStr=
680     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q=&as_publication="+
681     TUrl::GetUrlSearchStr(PublicationQueryStr);
682    return SearchUrlStr;
683  }
684  PRSet TGg::WebSearch(const TStr& QueryStr, const int& MxHits,
685   const PNotify& Notify, const TStr& ProxyStr){
686    TStr SearchUrlStr=TGg::GetWebSearchUrlStr(QueryStr);
687    bool Ok; TStr MsgStr; PWebPg WebPg;
688    TWebFetchBlocking::GetWebPg(
689     SearchUrlStr, Ok, MsgStr, WebPg, Notify, ProxyStr);
690    if (Ok){
691      PRSet RSet=TRSet::NewWeb(WebPg);
692      TStr NextSearchUrlStr=RSet->GetNextUrlStr();
693      while (!NextSearchUrlStr.Empty()){
694        if ((MxHits!=-1)&&(RSet->GetHits()>=MxHits)){break;}
695        bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
696        TWebFetchBlocking::GetWebPg(
697         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify, ProxyStr);
698        if (NextOk){
699          PRSet NextRSet=TRSet::NewWeb(NextWebPg);
700          RSet->Merge(NextRSet);
701          NextSearchUrlStr=NextRSet->GetNextUrlStr();
702        } else {
703          NextSearchUrlStr="";
704        }
705      }
706      RSet->Trunc(MxHits);
707      RSet->PutQueryStr(QueryStr);
708      return RSet;
709    } else {
710      return TRSet::New();
711    }
712  }
713  PRSet TGg::WebSearchExternal(
714   const TStr& QueryStr, const int& MxHits, const PNotify& Notify, const TStr& ProxyStr){
715    TStr ExeFPath=Env.GetExeFPath();
716    TStr ExeFNm=TStr::GetNrFPath(ExeFPath)+"Google2RSet.exe";
717    TStr RSetFNm=TStr::GetNrFPath(ExeFPath)+TTm::GetCurUniTm().GetIdStr()+".RSet";
718    TStr CmLn=
719     TStr::GetStr(QueryStr, " -iwq:%s")+
720     TInt::GetStr(MxHits, " -hits:%d")+
721     TStr::GetStr(RSetFNm, " -obin:\"%s\" -oxml: -obow: -ssilent")+
722     TStr::GetStr(ProxyStr, " -proxy:%s");
723    if (TSysProc::ExeProc(ExeFNm, CmLn)){
724      PRSet RSet;
725      {TFIn RSetFIn(RSetFNm);
726      RSet=TRSet::Load(RSetFIn);}
727      TFile::Del(RSetFNm);
728      return RSet;
729    } else {
730      return TRSet::New();
731    }
732  }
733  #ifdef MIHA_BLAZ_DOTNET_PROXY
734  PRSet TGg::WebSearchProxy(const TStr& QueryStr, const int& MxHits,
735   const PNotify& Notify, const TStr& ProxyStr){
736    TStr SearchUrlStr=TGg::GetWebSearchUrlStr(QueryStr);
737    char* WebPgHtmlCStr = fetchWebPage(SearchUrlStr.CStr(), ProxyStr.CStr());
738    TStr WebPgHtmlStr = TStr(WebPgHtmlCStr); GlobalFree(WebPgHtmlCStr);
739    bool Ok = (WebPgHtmlCStr != NULL);
740    if (Ok){
741      PRSet RSet=TRSet::NewWeb(SearchUrlStr, WebPgHtmlStr);
742      TStr NextSearchUrlStr=RSet->GetNextUrlStr();
743      while (!NextSearchUrlStr.Empty()){
744        if ((MxHits!=-1)&&(RSet->GetHits()>=MxHits)){break;}
745        char* NextWebPgHtmlCStr = fetchWebPage(NextSearchUrlStr.CStr(), ProxyStr.CStr());
746        TStr NextWebPgHtmlStr = TStr(NextWebPgHtmlCStr); GlobalFree(NextWebPgHtmlCStr);
747        bool NextOk = (NextWebPgHtmlCStr != NULL);
748        if (NextOk){
749          PRSet NextRSet=TRSet::NewWeb(NextSearchUrlStr, NextWebPgHtmlStr);
750          RSet->Merge(NextRSet);
751          NextSearchUrlStr=NextRSet->GetNextUrlStr();
752        } else {
753          NextSearchUrlStr="";
754        }
755      }
756      RSet->Trunc(MxHits);
757      RSet->PutQueryStr(QueryStr);
758      return RSet;
759    } else {
760      return TRSet::New();
761    }
762  }
763  #endif
764  PRSet TGg::NewsSearch(const TStr& QueryStr, const PNotify& Notify){
765    TStr SearchUrlStr=TGg::GetNewsSearchUrlStr(QueryStr);
766    bool Ok; TStr MsgStr; PWebPg WebPg;
767    TWebFetchBlocking::GetWebPg(
768     SearchUrlStr, Ok, MsgStr, WebPg, Notify);
769    if (Ok){
770      PRSet RSet=TRSet::NewNews(WebPg);
771      TStr NextSearchUrlStr=RSet->GetNextUrlStr();
772      while (!NextSearchUrlStr.Empty()){
773        bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
774        TWebFetchBlocking::GetWebPg(
775         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify);
776        if (NextOk){
777          PRSet NextRSet=TRSet::NewNews(NextWebPg);
778          RSet->Merge(NextRSet);
779          NextSearchUrlStr=NextRSet->GetNextUrlStr();
780        } else {
781          NextSearchUrlStr="";
782        }
783      }
784      return RSet;
785    } else {
786      return TRSet::New();
787    }
788  }
789  PGgSchRSet TGg::_ScholarSearch(
790   const TStr& SearchUrlStr, const PNotify& Notify){
791    bool Ok; TStr MsgStr; PWebPg WebPg;
792    TWebFetchBlocking::GetWebPg(
793     SearchUrlStr, Ok, MsgStr, WebPg, Notify);
794    if (Ok){
795      PGgSchRSet GgSchRSet=TGgSchRSet::NewScholar(WebPg);
796      TStr NextSearchUrlStr=GgSchRSet->GetNextUrlStr();
797      TRnd Rnd(0);
798      while (!NextSearchUrlStr.Empty()){
799        int WaitMSecs=int(1*1000*(Rnd.GetUniDev()+0.5));
800        TSysProc::Sleep(WaitMSecs);
801        bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
802        TWebFetchBlocking::GetWebPg(
803         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify);
804        if (NextOk){
805          PGgSchRSet NextRSet=TGgSchRSet::NewScholar(NextWebPg);
806          GgSchRSet->Merge(NextRSet);
807          NextSearchUrlStr=NextRSet->GetNextUrlStr();
808        } else {
809          NextSearchUrlStr="";
810        }
811      }
812      return GgSchRSet;
813    } else {
814      return TGgSchRSet::New();
815    }
816  }
817  PGgSchRSet TGg::ScholarSearch(const TStr& QueryStr, const PNotify& Notify){
818    TStr SearchUrlStr=GetScholarSearchUrlStr(QueryStr);
819    return _ScholarSearch(SearchUrlStr, Notify);
820  }
821  PGgSchRSet TGg::ScholarAuthorSearch(const TStr& AuthorNm, const PNotify& Notify){
822    TStr SearchUrlStr=GetScholarAuthorSearchUrlStr(AuthorNm);
823    return _ScholarSearch(SearchUrlStr, Notify);
824  }
825  PGgSchRSet TGg::ScholarPublicationSearch(const TStr& PublicationNm, const PNotify& Notify){
826    TStr SearchUrlStr=GetScholarPublicationSearchUrlStr(PublicationNm);
827    return _ScholarSearch(SearchUrlStr, Notify);
828  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-data_transformer.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <opencv2/core/core.hpp>
3  #endif  
4  #include <string>
5  #include <vector>
6  #include "caffe/data_reader.hpp"
7  #include "caffe/data_transformer.hpp"
8  #include "caffe/util/bbox_util.hpp"
9  #include "caffe/util/im_transforms.hpp"
10  #include "caffe/util/io.hpp"
11  namespace caffe {
12  template<typename Dtype>
13  void DataTransformer<Dtype>::Transform(const Datum& datum,
14                                         Blob<Dtype>* transformed_blob,
15                                         vector<BoxLabel>* box_labels) {
16    int float_size = datum.float_data_size();
17    CHECK_GT(float_size, 0) << 
18      "Every sample must have label";
19    CHECK_EQ(float_size % 6, 0) <<
20      "Every box label has 6 labels (class, difficult, box)";
21    /&bsol;*********************************************************************
22    vector<BoxLabel> ori_labels;
23    for (int j = 0; j < float_size; j += 6) {
24      BoxLabel box_label;
25      box_label.class_label_ = datum.float_data(j);
26      box_label.difficult_ = datum.float_data(j + 1);
27      for (int k = 2; k < 6; ++k) {
28        box_label.box_[k-2] = datum.float_data(j+k);
29      }
30      ori_labels.push_back(box_label);
31    }
32    CHECK(datum.encoded()) << "For box data, datum must be encoded";
33    CHECK(!(param_.force_color() && param_.force_gray()))
34      << "cannot set both force_color and force_gray";
35  #ifdef USE_OPENCV
36    cv::Mat cv_img;
37    if (param_.force_color() || param_.force_gray()) {
38      cv_img = DecodeDatumToCVMat(datum, param_.force_color());
39    } else {
40      cv_img = DecodeDatumToCVMatNative(datum);
41    }
42    if (phase_ == TEST) {
43      *box_labels = ori_labels;
44      Transform(cv_img, transformed_blob);
45      return;
46    }
47    int img_width = cv_img.cols;
48    int img_height = cv_img.rows;
49    cv::Mat cv_rand_img;
50    bool mirror = 0;
51    while (box_labels->size() == 0) {
52      float rand_scale = (1. - rand_num_(30) / 100.);
53      int rand_w = static_cast<int>(img_width * rand_scale) - 1;
54      int rand_h = static_cast<int>(img_height * rand_scale) - 1;
55      int rand_x = rand_num_(img_width - rand_w);
56      int rand_y = rand_num_(img_height - rand_h);
57      for (int i = 0; i < ori_labels.size(); ++i) {
58        int ori_x = static_cast<int>(ori_labels[i].box_[0] * img_width); 
59        int ori_y = static_cast<int>(ori_labels[i].box_[1] * img_height);
60        int ori_w = static_cast<int>(ori_labels[i].box_[2] * img_width); 
61        int ori_h = static_cast<int>(ori_labels[i].box_[3] * img_height);
62        if (!(ori_x >= rand_x && ori_x < rand_x + rand_w)) {
63          continue;
64        }
65        if (!(ori_y >= rand_y && ori_y < rand_y + rand_h)) {
66          continue;
67        }
68        BoxLabel box_label;
69        box_label.difficult_ = ori_labels[i].difficult_;
70        box_label.class_label_ = ori_labels[i].class_label_;
71        box_label.box_[0] = float(ori_x - rand_x) / float(rand_w);
72        box_label.box_[1] = float(ori_y - rand_y) / float(rand_h);
73        box_label.box_[2] = float(ori_w) / float(rand_w);
74        box_label.box_[3] = float(ori_h) / float(rand_h);
75        if (mirror) {
76          box_label.box_[0] = std::max(0., 1. - box_label.box_[0]);
77          box_label.box_[1] = std::max(0., 1. - box_label.box_[1]);
78        }
79        box_labels->push_back(box_label);
80      }
81      if (box_labels->size() > 0) {
82        cv::Rect roi(rand_x, rand_y, rand_w, rand_h); 
83        cv_rand_img = cv_img(roi);
84        if (mirror) {
85          cv::flip(cv_rand_img, cv_rand_img, 1); 
86        }
87      }
88    }
89    cv::resize(cv_rand_img, cv_rand_img, cv::Size(img_width, img_height));
90    Transform(cv_rand_img, transformed_blob);
91  #else
92    LOG(FATAL) << "Image transformer requires OpenCV; compile with USE_OPENCV.";
93  #endif
94    return;
95  }
96  template<typename Dtype>
97  DataTransformer<Dtype>::DataTransformer(const TransformationParameter& param,
98      Phase phase)
99      : param_(param), phase_(phase), data_reader_used(NULL) {
100    if (param_.has_mean_file()) {
101      CHECK_EQ(param_.mean_value_size(), 0) <<
102        "Cannot specify mean_file and mean_value at the same time";
103      const string& mean_file = param.mean_file();
104      if (Caffe::root_solver()) {
105        LOG(INFO) << "Loading mean file from: " << mean_file;
106      }
107      BlobProto blob_proto;
108      ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &blob_proto);
109      data_mean_.FromProto(blob_proto);
110    }
111    if (param_.mean_value_size() > 0) {
112      CHECK(param_.has_mean_file() == false) <<
113        "Cannot specify mean_file and mean_value at the same time";
114      for (int c = 0; c < param_.mean_value_size(); ++c) {
115        mean_values_.push_back(param_.mean_value(c));
116      }
117    }
118    if (param_.has_resize_param()) {
119      CHECK_GT(param_.resize_param().height(), 0);
120      CHECK_GT(param_.resize_param().width(), 0);
121    }
122    if (param_.has_expand_param()) {
123      CHECK_GT(param_.expand_param().max_expand_ratio(), 1.);
124    }
125  }
126  template<typename Dtype>
127  void DataTransformer<Dtype>::Transform(const Datum& datum, Dtype* transformed_data) {
128    const string& data = datum.data();
129    const int datum_channels = datum.channels();
130    const int datum_height = datum.height();
131    const int datum_width = datum.width();
132    const int crop_size = param_.crop_size();
133    const Dtype scale = param_.scale();
134    const bool do_mirror = param_.mirror() && rand_num_(2);
135    const bool has_mean_file = param_.has_mean_file();
136    const bool has_uint8 = data.size() > 0;
137    const bool has_mean_values = mean_values_.size() > 0;
138    const bool flow = param_.flow();
139    CHECK_GT(datum_channels, 0);
140    CHECK_GE(datum_height, crop_size);
141    CHECK_GE(datum_width, crop_size);
142    Dtype* mean = NULL;
143    if (has_mean_file) {
144      CHECK_EQ(datum_channels, data_mean_.channels());
145      CHECK_EQ(datum_height, data_mean_.height());
146      CHECK_EQ(datum_width, data_mean_.width());
147      mean = data_mean_.mutable_cpu_data();
148    }
149    if (has_mean_values) {
150     #ifdef _OPENMP
151     #pragma omp critical
152     #endif
153      {
154        CHECK(mean_values_.size() == 1 || mean_values_.size() == datum_channels) <<
155         "Specify either 1 mean_value or as many as channels: " << datum_channels;
156        if (datum_channels > 1 && mean_values_.size() == 1) {
157          for (int c = 1; c < datum_channels; ++c) {
158            mean_values_.push_back(mean_values_[0]);
159          }
160        }
161      }
162    }
163    int height = datum_height;
164    int width = datum_width;
165    int h_off = 0;
166    int w_off = 0;
167    if (crop_size) {
168      height = crop_size;
169      width = crop_size;
170      if (phase_ == TRAIN) {
171        h_off = rand_num_(datum_height - crop_size + 1);
172        w_off = rand_num_(datum_width - crop_size + 1);
173      } else {
174        h_off = (datum_height - crop_size) / 2;
175        w_off = (datum_width - crop_size) / 2;
176      }
177    }
178    Dtype datum_element;
179    int top_index, data_index;
180    for (int c = 0; c < datum_channels; ++c) {
181      for (int h = 0; h < height; ++h) {
182        for (int w = 0; w < width; ++w) {
183          data_index = (c * datum_height + h_off + h) * datum_width + w_off + w;
184          if (do_mirror) {
185            top_index = (c * height + h) * width + (width - 1 - w);
186          } else {
187            top_index = (c * height + h) * width + w;
188          }
189          if (has_uint8) {
190            datum_element =
191              static_cast<Dtype>(static_cast<uint8_t>(data[data_index]));
192            if (flow && c == 2 && do_mirror) {
193              datum_element = 255-datum_element;
194            }
195          } else {
196            datum_element = datum.float_data(data_index);
197            if (flow && c == 2 && do_mirror) {
198              datum_element = 255-datum_element;
199            }
200          }
201          if (has_mean_file) {
202            transformed_data[top_index] =
203              (datum_element - mean[data_index]) * scale;
204          } else {
205            if (has_mean_values) {
206              transformed_data[top_index] =
207                (datum_element - mean_values_[c]) * scale;
208            } else {
209              transformed_data[top_index] = datum_element * scale;
210            }
211          }
212        }
213      }
214    }
215  }
216  template<typename Dtype>
217  void DataTransformer<Dtype>::Transform(const Datum& datum, Dtype* transformed_data,
218                                         NormalizedBBox* crop_bbox, RandNumbers& rand_num,
219                                         const bool do_mirror, const bool has_uint8,
220                                         const bool has_mean_file, const bool has_mean_values)
221  {
222    int transform_func_id = (do_mirror << 2) +
223                            (has_mean_file << 1) +
224                            has_mean_values;
225    if (!has_uint8) {
226      switch (transform_func_id) {
227          case 0: Transform<false, false, false, false>(datum, transformed_data,
228            crop_bbox, rand_num); break;
229          case 1: Transform<false, false, false, true >(datum, transformed_data,
230            crop_bbox, rand_num); break;
231          case 2: Transform<false, false, true , false>(datum, transformed_data,
232            crop_bbox, rand_num); break;
233          case 3: Transform<false, false, true , true >(datum, transformed_data,
234            crop_bbox, rand_num); break;
235          case 4: Transform<false, true , false, false>(datum, transformed_data,
236            crop_bbox, rand_num); break;
237          case 5: Transform<false, true , false, true >(datum, transformed_data,
238            crop_bbox, rand_num); break;
239          case 6: Transform<false, true , true , false>(datum, transformed_data,
240            crop_bbox, rand_num); break;
241          case 7: Transform<false, true , true , true >(datum, transformed_data,
242            crop_bbox, rand_num); break;
243      }
244    } else {
245      switch (transform_func_id) {
246          case 0: Transform<true, false, false, false>(datum, transformed_data,
247            crop_bbox, rand_num); break;
248          case 1: Transform<true, false, false, true >(datum, transformed_data,
249            crop_bbox, rand_num); break;
250          case 2: Transform<true, false, true , false>(datum, transformed_data,
251            crop_bbox, rand_num); break;
252          case 3: Transform<true, false, true , true >(datum, transformed_data,
253            crop_bbox, rand_num); break;
254          case 4: Transform<true, true , false, false>(datum, transformed_data,
255            crop_bbox, rand_num); break;
256          case 5: Transform<true, true , false, true >(datum, transformed_data,
257            crop_bbox, rand_num); break;
258          case 6: Transform<true, true , true , false>(datum, transformed_data,
259            crop_bbox, rand_num); break;
260          case 7: Transform<true, true , true , true >(datum, transformed_data,
261            crop_bbox, rand_num); break;
262      }
263    }
264  }
265  namespace {
266    template<typename AnnotationHandler>
267    void call_annotation_handler(AnnotationHandler& anno_handler, const bool do_resize, const bool do_mirror)
268    {
269      anno_handler(do_resize, do_mirror);
270    }
271    template<>
272    void call_annotation_handler<EmptyType>(EmptyType&, const bool, const bool)
273    {
274    }
275  }
276  template<typename Dtype>
277  template<typename AnnotationHandler>
278  void DataTransformer<Dtype>::Transform(const Datum& datum,
279                                         Dtype* transformed_data,
280                                         NormalizedBBox* crop_bbox,
281                                         RandNumbers& rand_num,
282                                         AnnotationHandler anno_handler)
283  {
284    const bool do_mirror = param_.mirror() && rand_num(2);
285    const string& data = datum.data();
286    const bool has_uint8 = data.size() > 0;
287    const bool has_mean_file = param_.has_mean_file();
288    const bool has_mean_values = mean_values_.size() > 0;
289    Transform(datum, transformed_data, crop_bbox, rand_num,
290              do_mirror, has_uint8, has_mean_file, has_mean_values);
291    call_annotation_handler(anno_handler, &bsol;* do_resize */ true, do_mirror);
292  }
293  template<typename Dtype>
294  template<bool has_uint8, bool do_mirror, bool has_mean_file,
295    bool has_mean_values>
296  void DataTransformer<Dtype>::Transform(const Datum& datum_in,
297                                         Dtype* transformed_data,
298                                         NormalizedBBox* crop_bbox,
299                                         RandNumbers& rand_num) {
300    const Datum *datum = &datum_in;
301    Datum resized_datum;
302    if (param_.has_random_resize_param()) {
303  #ifdef USE_OPENCV
304      RandomResizeImage(datum_in, &resized_datum);
305      datum = &resized_datum;
306  #else
307      LOG(FATAL) << "Random image resizing requires OpenCV; compile with USE_OPENCV.";
308  #endif
309    } else if (param_.has_random_aspect_ratio_param()) {
310  #ifdef USE_OPENCV
311      RandomAlterAspectRatio(datum_in, &resized_datum);
312      datum = &resized_datum;
313  #else
314      LOG(FATAL) << "Aspect ratio changes require OpenCV; compile with USE_OPENCV.";
315  #endif
316    }
317    const string& data = datum->data();
318    const int datum_channels = datum->channels();
319    const int datum_height = datum->height();
320    const int datum_width = datum->width();
321    const int crop_size = param_.crop_size();
322    const Dtype scale = param_.scale();
323    CHECK_GT(datum_channels, 0);
324    CHECK_GE(datum_height, crop_size);
325    CHECK_GE(datum_width, crop_size);
326    Dtype* mean = NULL;
327    if (has_mean_file) {
328      CHECK_EQ(datum_channels, data_mean_.channels());
329      CHECK_EQ(datum_height, data_mean_.height());
330      CHECK_EQ(datum_width, data_mean_.width());
331      mean = data_mean_.mutable_cpu_data();
332    }
333    if (has_mean_values) {
334     #ifdef _OPENMP
335     #pragma omp critical
336     #endif
337      {
338        CHECK(mean_values_.size() == 1 || mean_values_.size() == datum_channels) <<
339         "Specify either 1 mean_value or as many as channels: " << datum_channels;
340        if (datum_channels > 1 && mean_values_.size() == 1) {
341          for (int c = 1; c < datum_channels; ++c) {
342            mean_values_.push_back(mean_values_[0]);
343          }
344        }
345      }
346    }
347    int height = datum_height;
348    int width = datum_width;
349    int h_off = 0;
350    int w_off = 0;
351    if (crop_size) {
352      height = crop_size;
353      width = crop_size;
354      if (phase_ == TRAIN) {
355        h_off = rand_num(datum_height - crop_size + 1);
356        w_off = rand_num(datum_width - crop_size + 1);
357      } else {
358        h_off = (datum_height - crop_size) / 2;
359        w_off = (datum_width - crop_size) / 2;
360      }
361    }
362    crop_bbox->set_xmin(Dtype(w_off) / datum_width);
363    crop_bbox->set_ymin(Dtype(h_off) / datum_height);
364    crop_bbox->set_xmax(Dtype(w_off + width) / datum_width);
365    crop_bbox->set_ymax(Dtype(h_off + height) / datum_height);
366    Dtype datum_element;
367    int top_index, data_index;
368    for (int c = 0; c < datum_channels; ++c) {
369      for (int h = 0; h < height; ++h) {
370        for (int w = 0; w < width; ++w) {
371          data_index = (c * datum_height + h_off + h) * datum_width + w_off + w;
372          if (do_mirror) {
373            top_index = (c * height + h) * width + (width - 1 - w);
374          } else {
375            top_index = (c * height + h) * width + w;
376          }
377          if (has_uint8) {
378            datum_element =
379              static_cast<Dtype>(static_cast<uint8_t>(data[data_index]));
380          } else {
381            datum_element = datum->float_data(data_index);
382          }
383          if (has_mean_file) {
384            transformed_data[top_index] =
385              (datum_element - mean[data_index]) * scale;
386          } else {
387            if (has_mean_values) {
388              transformed_data[top_index] =
389                (datum_element - mean_values_[c]) * scale;
390            } else {
391              transformed_data[top_index] = datum_element * scale;
392            }
393          }
394        }
395      }
396    }
397  }
398  template<typename Dtype>
399  void DataTransformer<Dtype>::GenerateRandNumbers(PreclcRandomNumbers& rn, bool sample_bboxes) {
400    int count = (sample_bboxes ? 1 : 0) + (param_.mirror()? 1:0) +
401                    ((phase_ == TRAIN && param_.crop_size())? 2 : 0);
402    rn.FillRandomNumbers(count, rand_num_);
403  }
404  template<typename Dtype>
405  void DataTransformer<Dtype>::Transform(const Datum& datum,
406                                         Dtype* transformed_data,
407                                         RandNumbers& rand_num) {
408    NormalizedBBox crop_bbox;
409    Transform(datum, transformed_data, &crop_bbox, rand_num);
410  }
411  template<typename Dtype>
412  template<typename AnnotationHandler>
413  void DataTransformer<Dtype>::Transform(const Datum& datum,
414                                         Blob<Dtype>* transformed_blob,
415                                         NormalizedBBox* crop_bbox,
416                                         RandNumbers& rand_num,
417                                         AnnotationHandler anno_handler)
418  {
419    if (datum.encoded()) {
420  #ifdef USE_OPENCV
421      CHECK(!(param_.force_color() && param_.force_gray()))
422          << "cannot set both force_color and force_gray";
423      cv::Mat cv_img;
424      if (param_.force_color() || param_.force_gray()) {
425        cv_img = DecodeDatumToCVMat(datum, param_.force_color());
426      } else {
427        cv_img = DecodeDatumToCVMatNative(datum);
428      }
429      return Transform(cv_img, transformed_blob, crop_bbox, rand_num, anno_handler);
430  #else
431      LOG(FATAL) << "Encoded datum requires OpenCV; compile with USE_OPENCV.";
432  #endif  
433    } else {
434      if (param_.force_color() || param_.force_gray()) {
435        LOG(ERROR) << "force_color and force_gray only for encoded datum";
436      }
437    }
438    const int crop_size = param_.crop_size();
439    const int datum_channels = datum.channels();
440    const int datum_height = datum.height();
441    const int datum_width = datum.width();
442    const int channels = transformed_blob->channels();
443    const int height = transformed_blob->height();
444    const int width = transformed_blob->width();
445    const int num = transformed_blob->num();
446    CHECK_EQ(channels, datum_channels);
447    CHECK_LE(height, datum_height);
448    CHECK_LE(width, datum_width);
449    CHECK_GE(num, 1);
450    if (crop_size) {
451      CHECK_EQ(crop_size, height);
452      CHECK_EQ(crop_size, width);
453    } else {
454      CHECK_EQ(datum_height, height);
455      CHECK_EQ(datum_width, width);
456    }
457    Dtype* transformed_data = transformed_blob->mutable_cpu_data();
458    Transform(datum, transformed_data, crop_bbox, rand_num, anno_handler);
459  }
460  template<typename Dtype>
461  void DataTransformer<Dtype>::Transform(const Datum& datum,
462                                         Blob<Dtype>* transformed_blob, RandNumbers& rand_num) {
463    NormalizedBBox crop_bbox;
464    Transform(datum, transformed_blob, &crop_bbox, rand_num);
465  }
466  template<typename Dtype>
467  void DataTransformer<Dtype>::Transform(const vector<Datum> & datum_vector,
468                                         Blob<Dtype>* transformed_blob) {
469    const int datum_num = datum_vector.size();
470    const int num = transformed_blob->num();
471    const int channels = transformed_blob->channels();
472    const int height = transformed_blob->height();
473    const int width = transformed_blob->width();
474    CHECK_GT(datum_num, 0) << "There is no datum to add";
475    CHECK_LE(datum_num, num) <<
476      "The size of datum_vector must be no greater than transformed_blob->num()";
477    Blob<Dtype> uni_blob(1, channels, height, width);
478    for (int item_id = 0; item_id < datum_num; ++item_id) {
479      int offset = transformed_blob->offset(item_id);
480      uni_blob.set_cpu_data(transformed_blob->mutable_cpu_data() + offset);
481      Transform(datum_vector[item_id], &uni_blob);
482    }
483  }
484  template<typename Dtype>
485  void DataTransformer<Dtype>::Transform(const AnnotatedDatum& anno_datum,
486                                         Blob<Dtype>* transformed_blob,
487                                         RepeatedPtrField<AnnotationGroup>* transformed_anno_group_all,
488  				       RandNumbers& rand_num) {
489    const Datum& datum = anno_datum.datum();
490    NormalizedBBox crop_bbox;
491    auto transform_annotation = [&](const bool do_resize, const bool do_mirror) -> void {
492      TransformAnnotation(anno_datum, do_resize, crop_bbox, do_mirror,
493                          transformed_anno_group_all);
494    };
495    Transform(datum, transformed_blob, &crop_bbox, rand_num, transform_annotation);
496  }
497  template<typename Dtype>
498  void DataTransformer<Dtype>::Transform(const AnnotatedDatum& anno_datum,
499                                         Blob<Dtype>* transformed_blob,
500                                         vector<AnnotationGroup>* transformed_anno_vec,
501  				       RandNumbers& rand_num) {
502    RepeatedPtrField<AnnotationGroup> transformed_anno_group_all;
503    Transform(anno_datum, transformed_blob, &transformed_anno_group_all, rand_num);
504    for (int g = 0; g < transformed_anno_group_all.size(); ++g) {
505      transformed_anno_vec->push_back(transformed_anno_group_all.Get(g));
506    }
507  }
508  template<typename Dtype>
509  void DataTransformer<Dtype>::Transform(const AnnotatedDatum& anno_datum, 
510                                         Blob<Dtype>* transformed_blob,
511                                         vector<AnnotationGroup>* transformed_anno_vec) {
512    Transform(anno_datum, transformed_blob, transformed_anno_vec, rand_num_);
513  }
514  template<typename Dtype>
515  void DataTransformer<Dtype>::TransformAnnotation(const AnnotatedDatum& anno_datum,
516                                                   const bool do_resize,
517                                                   const NormalizedBBox& crop_bbox,
518                                                   const bool do_mirror,
519                                                   RepeatedPtrField<AnnotationGroup>* transformed_anno_group_all) {
520    const int img_height = anno_datum.datum().height();
521    const int img_width = anno_datum.datum().width();
522    if (anno_datum.type() == AnnotatedDatum_AnnotationType_BBOX) {
523      for (int g = 0; g < anno_datum.annotation_group_size(); ++g) {
524        const AnnotationGroup& anno_group = anno_datum.annotation_group(g);
525        AnnotationGroup transformed_anno_group;
526        bool has_valid_annotation = false;
527        for (int a = 0; a < anno_group.annotation_size(); ++a) {
528          const Annotation& anno = anno_group.annotation(a);
529          const NormalizedBBox& bbox = anno.bbox();
530          NormalizedBBox resize_bbox = bbox;
531          if (do_resize && param_.has_resize_param()) {
532            CHECK_GT(img_height, 0);
533            CHECK_GT(img_width, 0);
534            UpdateBBoxByResizePolicy(param_.resize_param(), img_width, img_height,
535                                     &resize_bbox);
536          }
537          if (param_.has_emit_constraint() &&
538              !MeetEmitConstraint(crop_bbox, resize_bbox,
539                                  param_.emit_constraint())) {
540            continue;
541          }
542          NormalizedBBox proj_bbox;
543          if (ProjectBBox(crop_bbox, resize_bbox, &proj_bbox)) {
544            has_valid_annotation = true;
545            Annotation* transformed_anno =
546                transformed_anno_group.add_annotation();
547            transformed_anno->set_instance_id(anno.instance_id());
548            NormalizedBBox* transformed_bbox = transformed_anno->mutable_bbox();
549            transformed_bbox->CopyFrom(proj_bbox);
550            if (do_mirror) {
551              Dtype temp = transformed_bbox->xmin();
552              transformed_bbox->set_xmin(1 - transformed_bbox->xmax());
553              transformed_bbox->set_xmax(1 - temp);
554            }
555            if (do_resize && param_.has_resize_param()) {
556              ExtrapolateBBox(param_.resize_param(), img_height, img_width,
557                  crop_bbox, transformed_bbox);
558            }
559          }
560        }
561        if (has_valid_annotation) {
562          transformed_anno_group.set_group_label(anno_group.group_label());
563          transformed_anno_group_all->Add()->CopyFrom(transformed_anno_group);
564        }
565      }
566    } else {
567      LOG(FATAL) << "Unknown annotation type.";
568    }
569  }
570  template<typename Dtype>
571  void DataTransformer<Dtype>::CropImage(const Datum& datum,
572                                         const NormalizedBBox& bbox,
573                                         Datum* crop_datum) {
574    if (datum.encoded()) {
575  #ifdef USE_OPENCV
576      CHECK(!(param_.force_color() && param_.force_gray()))
577          << "cannot set both force_color and force_gray";
578      cv::Mat cv_img;
579      if (param_.force_color() || param_.force_gray()) {
580        cv_img = DecodeDatumToCVMat(datum, param_.force_color());
581      } else {
582        cv_img = DecodeDatumToCVMatNative(datum);
583      }
584      cv::Mat crop_img;
585      CropImage(cv_img, bbox, &crop_img);
586      EncodeCVMatToDatum(crop_img, "jpg", crop_datum);
587      crop_datum->set_label(datum.label());
588      return;
589  #else
590      LOG(FATAL) << "Encoded datum requires OpenCV; compile with USE_OPENCV.";
591  #endif  
592    } else {
593      if (param_.force_color() || param_.force_gray()) {
594        LOG(ERROR) << "force_color and force_gray only for encoded datum";
595      }
596    }
597    const int datum_channels = datum.channels();
598    const int datum_height = datum.height();
599    const int datum_width = datum.width();
600    NormalizedBBox clipped_bbox;
601    ClipBBox(bbox, &clipped_bbox);
602    NormalizedBBox scaled_bbox;
603    ScaleBBox(clipped_bbox, datum_height, datum_width, &scaled_bbox);
604    const int w_off = static_cast<int>(scaled_bbox.xmin());
605    const int h_off = static_cast<int>(scaled_bbox.ymin());
606    const int width = static_cast<int>(scaled_bbox.xmax() - scaled_bbox.xmin());
607    const int height = static_cast<int>(scaled_bbox.ymax() - scaled_bbox.ymin());
608    crop_datum->set_channels(datum_channels);
609    crop_datum->set_height(height);
610    crop_datum->set_width(width);
611    crop_datum->set_label(datum.label());
612    crop_datum->clear_data();
613    crop_datum->clear_float_data();
614    crop_datum->set_encoded(false);
615    const int crop_datum_size = datum_channels * height * width;
616    const std::string& datum_buffer = datum.data();
617    std::string buffer(crop_datum_size, ' ');
618    for (int h = h_off; h < h_off + height; ++h) {
619      for (int w = w_off; w < w_off + width; ++w) {
620        for (int c = 0; c < datum_channels; ++c) {
621          int datum_index = (c * datum_height + h) * datum_width + w;
622          int crop_datum_index = (c * height + h - h_off) * width + w - w_off;
623          buffer[crop_datum_index] = datum_buffer[datum_index];
624        }
625      }
626    }
627    crop_datum->set_data(buffer);
628  }
629  template<typename Dtype>
630  void DataTransformer<Dtype>::CropImage(const AnnotatedDatum& anno_datum,
631                                         const NormalizedBBox& bbox,
632                                         AnnotatedDatum* cropped_anno_datum) {
633    CropImage(anno_datum.datum(), bbox, cropped_anno_datum->mutable_datum());
634    cropped_anno_datum->set_type(anno_datum.type());
635    const bool do_resize = false;
636    const bool do_mirror = false;
637    NormalizedBBox crop_bbox;
638    ClipBBox(bbox, &crop_bbox);
639    TransformAnnotation(anno_datum, do_resize, crop_bbox, do_mirror,
640                        cropped_anno_datum->mutable_annotation_group());
641  }
642  template<typename Dtype>
643  void DataTransformer<Dtype>::ExpandImage(const Datum& datum,
644                                           const float expand_ratio,
645                                           NormalizedBBox* expand_bbox,
646                                           Datum* expand_datum) {
647    if (datum.encoded()) {
648  #ifdef USE_OPENCV
649      CHECK(!(param_.force_color() && param_.force_gray()))
650          << "cannot set both force_color and force_gray";
651      cv::Mat cv_img;
652      if (param_.force_color() || param_.force_gray()) {
653        cv_img = DecodeDatumToCVMat(datum, param_.force_color());
654      } else {
655        cv_img = DecodeDatumToCVMatNative(datum);
656      }
657      cv::Mat expand_img;
658      ExpandImage(cv_img, expand_ratio, expand_bbox, &expand_img);
659      EncodeCVMatToDatum(expand_img, "jpg", expand_datum);
660      expand_datum->set_label(datum.label());
661      return;
662  #else
663      LOG(FATAL) << "Encoded datum requires OpenCV; compile with USE_OPENCV.";
664  #endif  
665    } else {
666      if (param_.force_color() || param_.force_gray()) {
667        LOG(ERROR) << "force_color and force_gray only for encoded datum";
668      }
669    }
670    const int datum_channels = datum.channels();
671    const int datum_height = datum.height();
672    const int datum_width = datum.width();
673    int height = static_cast<int>(datum_height * expand_ratio);
674    int width = static_cast<int>(datum_width * expand_ratio);
675    float h_off, w_off;
676    caffe_rng_uniform(1, 0.f, static_cast<float>(height - datum_height), &h_off);
677    caffe_rng_uniform(1, 0.f, static_cast<float>(width - datum_width), &w_off);
678    h_off = floor(h_off);
679    w_off = floor(w_off);
680    expand_bbox->set_xmin(-w_off/datum_width);
681    expand_bbox->set_ymin(-h_off/datum_height);
682    expand_bbox->set_xmax((width - w_off)/datum_width);
683    expand_bbox->set_ymax((height - h_off)/datum_height);
684    expand_datum->set_channels(datum_channels);
685    expand_datum->set_height(height);
686    expand_datum->set_width(width);
687    expand_datum->set_label(datum.label());
688    expand_datum->clear_data();
689    expand_datum->clear_float_data();
690    expand_datum->set_encoded(false);
691    const int expand_datum_size = datum_channels * height * width;
692    const std::string& datum_buffer = datum.data();
693    std::string buffer(expand_datum_size, ' ');
694    for (int h = h_off; h < h_off + datum_height; ++h) {
695      for (int w = w_off; w < w_off + datum_width; ++w) {
696        for (int c = 0; c < datum_channels; ++c) {
697          int datum_index =
698              (c * datum_height + h - h_off) * datum_width + w - w_off;
699          int expand_datum_index = (c * height + h) * width + w;
700          buffer[expand_datum_index] = datum_buffer[datum_index];
701        }
702      }
703    }
704    expand_datum->set_data(buffer);
705  }
706  template<typename Dtype>
707  void DataTransformer<Dtype>::ExpandImage(const AnnotatedDatum& anno_datum,
708                                           AnnotatedDatum* expanded_anno_datum) {
709    if (!param_.has_expand_param()) {
710      expanded_anno_datum->CopyFrom(anno_datum);
711      return;
712    }
713    const ExpansionParameter& expand_param = param_.expand_param();
714    const float expand_prob = expand_param.prob();
715    float prob;
716    caffe_rng_uniform(1, 0.f, 1.f, &prob);
717    if (prob > expand_prob) {
718      expanded_anno_datum->CopyFrom(anno_datum);
719      return;
720    }
721    const float max_expand_ratio = expand_param.max_expand_ratio();
722    if (fabs(max_expand_ratio - 1.) < 1e-2) {
723      expanded_anno_datum->CopyFrom(anno_datum);
724      return;
725    }
726    float expand_ratio;
727    caffe_rng_uniform(1, 1.f, max_expand_ratio, &expand_ratio);
728    NormalizedBBox expand_bbox;
729    ExpandImage(anno_datum.datum(), expand_ratio, &expand_bbox,
730                expanded_anno_datum->mutable_datum());
731    expanded_anno_datum->set_type(anno_datum.type());
732    const bool do_resize = false;
733    const bool do_mirror = false;
734    TransformAnnotation(anno_datum, do_resize, expand_bbox, do_mirror,
735                        expanded_anno_datum->mutable_annotation_group());
736  }
737  template<typename Dtype>
738  void DataTransformer<Dtype>::DistortImage(const Datum& datum,
739                                            Datum* distort_datum) {
740    if (!param_.has_distort_param()) {
741      distort_datum->CopyFrom(datum);
742      return;
743    }
744    if (datum.encoded()) {
745  #ifdef USE_OPENCV
746      CHECK(!(param_.force_color() && param_.force_gray()))
747          << "cannot set both force_color and force_gray";
748      cv::Mat cv_img;
749      if (param_.force_color() || param_.force_gray()) {
750        cv_img = DecodeDatumToCVMat(datum, param_.force_color());
751      } else {
752        cv_img = DecodeDatumToCVMatNative(datum);
753      }
754      cv::Mat distort_img = ApplyDistort(cv_img, param_.distort_param());
755      EncodeCVMatToDatum(distort_img, "jpg", distort_datum);
756      distort_datum->set_label(datum.label());
757      return;
758  #else
759      LOG(FATAL) << "Encoded datum requires OpenCV; compile with USE_OPENCV.";
760  #endif  
761    } else {
762      LOG(ERROR) << "Only support encoded datum now";
763    }
764  }
765  #ifdef USE_OPENCV
766  template<typename Dtype>
767  void DataTransformer<Dtype>::Transform(const vector<cv::Mat> & mat_vector,
768                                         Blob<Dtype>* transformed_blob) {
769    const int mat_num = mat_vector.size();
770    const int num = transformed_blob->num();
771    const int channels = transformed_blob->channels();
772    const int height = transformed_blob->height();
773    const int width = transformed_blob->width();
774    CHECK_GT(mat_num, 0) << "There is no MAT to add";
775    CHECK_EQ(mat_num, num) <<
776      "The size of mat_vector must be equals to transformed_blob->num()";
777    Blob<Dtype> uni_blob(1, channels, height, width);
778    for (int item_id = 0; item_id < mat_num; ++item_id) {
779      int offset = transformed_blob->offset(item_id);
780      uni_blob.set_cpu_data(transformed_blob->mutable_cpu_data() + offset);
781      Transform(mat_vector[item_id], &uni_blob);
782    }
783  }
784  template<typename Dtype>
785  template<typename AnnotationHandler>
786  void DataTransformer<Dtype>::Transform(const cv::Mat& cv_img,
787                                         Blob<Dtype>* transformed_blob,
788                                         NormalizedBBox* crop_bbox,
789                                         RandNumbers& rand_num,
790                                         AnnotationHandler anno_handler)
791  {
792    const bool do_mirror = param_.mirror() && rand_num(2);
793    const bool has_mean_file = param_.has_mean_file();
794    const bool has_mean_values = mean_values_.size() > 0;
795    int transform_func_id = (do_mirror << 2) +
796                            (has_mean_file << 1) +
797                            has_mean_values;
798    switch (transform_func_id) {
799      case 0: Transform<false, false, false>(cv_img, transformed_blob, crop_bbox, rand_num);
800        break;
801      case 1: Transform<false, false, true >(cv_img, transformed_blob, crop_bbox, rand_num);
802        break;
803      case 2: Transform<false, true , false>(cv_img, transformed_blob, crop_bbox, rand_num);
804        break;
805      case 3: Transform<false, true , true >(cv_img, transformed_blob, crop_bbox, rand_num);
806        break;
807      case 4: Transform<true , false, false>(cv_img, transformed_blob, crop_bbox, rand_num);
808        break;
809      case 5: Transform<true , false, true >(cv_img, transformed_blob, crop_bbox, rand_num);
810        break;
811      case 6: Transform<true , true , false>(cv_img, transformed_blob, crop_bbox, rand_num);
812        break;
813      case 7: Transform<true , true , true >(cv_img, transformed_blob, crop_bbox, rand_num);
814        break;
815    }
816    call_annotation_handler(anno_handler, &bsol;* do_resize*/ true, do_mirror);
817  }
818  template<typename Dtype>
819  template<bool do_mirror, bool has_mean_file, bool has_mean_values>
820  void DataTransformer<Dtype>::Transform(const cv::Mat& cv_img_in,
821          Blob<Dtype>* transformed_blob, NormalizedBBox* crop_bbox, RandNumbers& rand_num) {
822    const cv::Mat *cv_img = &cv_img_in;
823    cv::Mat resized_img;
824    if (param_.has_random_resize_param()) {
825  #ifdef USE_OPENCV
826      RandomResizeImage(cv_img_in, &resized_img);
827      cv_img = &resized_img;
828  #else
829      LOG(FATAL) << "Random image resizing requires OpenCV; compile with USE_OPENCV.";
830  #endif
831    } else if (param_.has_random_aspect_ratio_param()) {
832  #ifdef USE_OPENCV
833      RandomAlterAspectRatio(cv_img_in, &resized_img);
834      cv_img = &resized_img;
835  #else
836      LOG(FATAL) << "Aspect ratio changes require OpenCV; compile with USE_OPENCV.";
837  #endif
838    }
839    const int crop_size = param_.crop_size();
840    const int img_channels = cv_img->channels();
841    const int channels = transformed_blob->channels();
842    const int height = transformed_blob->height();
843    const int width = transformed_blob->width();
844    const int num = transformed_blob->num();
845    CHECK_EQ(channels, img_channels);
846    CHECK_GE(num, 1);
847    CHECK(cv_img->depth() == CV_8U) << "Image data type must be unsigned byte";
848    const Dtype scale = param_.scale();
849    const int pad = param_.pad();
850    CHECK_GT(img_channels, 0);
851    Dtype* mean = NULL;
852    if (has_mean_file) {
853      CHECK_EQ(img_channels, data_mean_.channels());
854      mean = data_mean_.mutable_cpu_data();
855    }
856    if (has_mean_values) {
857     #ifdef _OPENMP
858     #pragma omp critical
859     #endif
860      {
861        CHECK(mean_values_.size() == 1 || mean_values_.size() == img_channels) <<
862            "Specify either 1 mean_value or as many as channels: " << img_channels;
863        if (img_channels > 1 && mean_values_.size() == 1) {
864          for (int c = 1; c < img_channels; ++c) {
865            mean_values_.push_back(mean_values_[0]);
866          }
867        }
868      }
869    }
870    cv::Mat cv_resized_img, cv_noised_img;
871    if (param_.has_resize_param()) {
872      cv_resized_img = ApplyResize(*cv_img, param_.resize_param());
873    } else {
874      cv_resized_img = *cv_img;
875    }
876    if (param_.has_noise_param()) {
877      cv_noised_img = ApplyNoise(cv_resized_img, param_.noise_param());
878    } else {
879      cv_noised_img = cv_resized_img;
880    }
881    int img_height = cv_noised_img.rows;
882    int img_width = cv_noised_img.cols;
883    CHECK_GE(img_height, crop_size);
884    CHECK_GE(img_width, crop_size);
885    int h_off = 0;
886    int w_off = 0;
887    cv::Mat cv_cropped_img = *cv_img;
888    if (crop_size) {
889      CHECK_EQ(crop_size + pad * 2, height);
890      CHECK_EQ(crop_size + pad * 2, width);
891      if (phase_ == TRAIN) {
892        h_off = rand_num(img_height - crop_size + 1);
893        w_off = rand_num(img_width - crop_size + 1);
894      } else {
895        h_off = (img_height - crop_size) / 2;
896        w_off = (img_width - crop_size) / 2;
897      }
898      cv::Rect roi(w_off, h_off, crop_size, crop_size);
899      cv_cropped_img = (*cv_img)(roi);
900    } else {
901      cv_cropped_img = cv_noised_img;
902    }
903    if(pad != 0) {
904      cv::copyMakeBorder(cv_cropped_img, cv_cropped_img, pad, pad, pad, pad, cv::BORDER_CONSTANT, 0);
905    }
906    crop_bbox->set_xmin(Dtype(w_off) / img_width);
907    crop_bbox->set_ymin(Dtype(h_off) / img_height);
908    crop_bbox->set_xmax(Dtype(w_off + width - pad * 2) / img_width);
909    crop_bbox->set_ymax(Dtype(h_off + height - pad * 2) / img_height);
910    CHECK(cv_cropped_img.data);
911    Dtype* transformed_data = transformed_blob->mutable_cpu_data();
912    int top_index;
913    for (int h = 0; h < height; ++h) {
914      const uchar* ptr = cv_cropped_img.ptr<uchar>(h);
915      int img_index = 0;
916      for (int w = 0; w < width; ++w) {
917        for (int c = 0; c < img_channels; ++c) {
918          if (do_mirror) {
919            top_index = (c * height + h) * width + (width - 1 - w);
920          } else {
921            top_index = (c * height + h) * width + w;
922          }
923          Dtype pixel = static_cast<Dtype>(ptr[img_index++]);
924          if(h < pad || w < pad || h > (height - pad) || w > (width - pad)) {
925            transformed_data[top_index] = pixel;
926          } else {
927            if (has_mean_file) {
928              int mean_index = (c * img_height + h_off + h) * img_width + w_off + w;
929              transformed_data[top_index] =
930                (pixel - mean[mean_index]) * scale;
931            } else {
932              if (has_mean_values) {
933                transformed_data[top_index] = pad == 0 ?
934                  (pixel - mean_values_[c]) * scale : nearbyint((pixel - mean_values_[c]) * scale);
935              } else {
936                transformed_data[top_index] = pixel * scale;
937              }
938            }
939          }
940        }
941      }
942    }
943  }
944  template<typename Dtype>
945  void DataTransformer<Dtype>::TransformInv(const Dtype* data, cv::Mat* cv_img,
946                                            const int height, const int width,
947                                            const int channels) {
948    const Dtype scale = param_.scale();
949    const bool has_mean_file = param_.has_mean_file();
950    const bool has_mean_values = mean_values_.size() > 0;
951    Dtype* mean = NULL;
952    if (has_mean_file) {
953      CHECK_EQ(channels, data_mean_.channels());
954      CHECK_EQ(height, data_mean_.height());
955      CHECK_EQ(width, data_mean_.width());
956      mean = data_mean_.mutable_cpu_data();
957    }
958    if (has_mean_values) {
959     #ifdef _OPENMP
960     #pragma omp critical
961     #endif
962      {
963        CHECK(mean_values_.size() == 1 || mean_values_.size() == channels) <<
964            "Specify either 1 mean_value or as many as channels: " << channels;
965        if (channels > 1 && mean_values_.size() == 1) {
966          for (int c = 1; c < channels; ++c) {
967            mean_values_.push_back(mean_values_[0]);
968          }
969        }
970      }
971    }
972    const int img_type = channels == 3 ? CV_8UC3 : CV_8UC1;
973    cv::Mat orig_img(height, width, img_type, cv::Scalar(0, 0, 0));
974    for (int h = 0; h < height; ++h) {
975      uchar* ptr = orig_img.ptr<uchar>(h);
976      int img_idx = 0;
977      for (int w = 0; w < width; ++w) {
978        for (int c = 0; c < channels; ++c) {
979          int idx = (c * height + h) * width + w;
980          if (has_mean_file) {
981            ptr[img_idx++] = static_cast<uchar>(data[idx] / scale + mean[idx]);
982          } else {
983            if (has_mean_values) {
984              ptr[img_idx++] =
985                  static_cast<uchar>(data[idx] / scale + mean_values_[c]);
986            } else {
987              ptr[img_idx++] = static_cast<uchar>(data[idx] / scale);
988            }
989          }
990        }
991      }
992    }
993    if (param_.has_resize_param()) {
994      *cv_img = ApplyResize(orig_img, param_.resize_param());
995    } else {
996      *cv_img = orig_img;
997    }
998  }
999  template<typename Dtype>
1000  void DataTransformer<Dtype>::TransformInv(const Blob<Dtype>* blob,
1001                                            vector<cv::Mat>* cv_imgs) {
1002    const int channels = blob->channels();
1003    const int height = blob->height();
1004    const int width = blob->width();
1005    const int num = blob->num();
1006    CHECK_GE(num, 1);
1007    const Dtype* image_data = blob->cpu_data();
1008    for (int i = 0; i < num; ++i) {
1009      cv::Mat cv_img;
1010      TransformInv(image_data, &cv_img, height, width, channels);
1011      cv_imgs->push_back(cv_img);
1012      image_data += blob->offset(1);
1013    }
1014  }
1015  template<typename Dtype>
1016  void DataTransformer<Dtype>::Transform(const cv::Mat& cv_img,
1017                                         Blob<Dtype>* transformed_blob,
1018                                         RandNumbers& rand_num) {
1019    NormalizedBBox crop_bbox;
1020    Transform(cv_img, transformed_blob, &crop_bbox, rand_num);
1021  }
1022  template <typename Dtype>
1023  void DataTransformer<Dtype>::CropImage(const cv::Mat& img,
1024                                         const NormalizedBBox& bbox,
1025                                         cv::Mat* crop_img) {
1026    const int img_height = img.rows;
1027    const int img_width = img.cols;
1028    NormalizedBBox clipped_bbox;
1029    ClipBBox(bbox, &clipped_bbox);
1030    NormalizedBBox scaled_bbox;
1031    ScaleBBox(clipped_bbox, img_height, img_width, &scaled_bbox);
1032    int w_off = static_cast<int>(scaled_bbox.xmin());
1033    int h_off = static_cast<int>(scaled_bbox.ymin());
1034    int width = static_cast<int>(scaled_bbox.xmax() - scaled_bbox.xmin());
1035    int height = static_cast<int>(scaled_bbox.ymax() - scaled_bbox.ymin());
1036    cv::Rect bbox_roi(w_off, h_off, width, height);
1037    img(bbox_roi).copyTo(*crop_img);
1038  }
1039  template <typename Dtype>
1040  void DataTransformer<Dtype>::ExpandImage(const cv::Mat& img,
1041                                           const float expand_ratio,
1042                                           NormalizedBBox* expand_bbox,
1043                                           cv::Mat* expand_img) {
1044    const int img_height = img.rows;
1045    const int img_width = img.cols;
1046    const int img_channels = img.channels();
1047    int height = static_cast<int>(img_height * expand_ratio);
1048    int width = static_cast<int>(img_width * expand_ratio);
1049    float h_off, w_off;
1050    caffe_rng_uniform(1, 0.f, static_cast<float>(height - img_height), &h_off);
1051    caffe_rng_uniform(1, 0.f, static_cast<float>(width - img_width), &w_off);
1052    h_off = floor(h_off);
1053    w_off = floor(w_off);
1054    expand_bbox->set_xmin(-w_off/img_width);
1055    expand_bbox->set_ymin(-h_off/img_height);
1056    expand_bbox->set_xmax((width - w_off)/img_width);
1057    expand_bbox->set_ymax((height - h_off)/img_height);
1058    expand_img->create(height, width, img.type());
1059    expand_img->setTo(cv::Scalar(0));
1060    const bool has_mean_file = param_.has_mean_file();
1061    const bool has_mean_values = mean_values_.size() > 0;
1062    if (has_mean_file) {
1063      CHECK_EQ(img_channels, data_mean_.channels());
1064      CHECK_EQ(height, data_mean_.height());
1065      CHECK_EQ(width, data_mean_.width());
1066      Dtype* mean = data_mean_.mutable_cpu_data();
1067      for (int h = 0; h < height; ++h) {
1068        uchar* ptr = expand_img->ptr<uchar>(h);
1069        int img_index = 0;
1070        for (int w = 0; w < width; ++w) {
1071          for (int c = 0; c < img_channels; ++c) {
1072            int blob_index = (c * height + h) * width + w;
1073            ptr[img_index++] = static_cast<char>(mean[blob_index]);
1074          }
1075        }
1076      }
1077    }
1078    if (has_mean_values) {
1079     #ifdef _OPENMP
1080     #pragma omp critical
1081     #endif
1082      {
1083        CHECK(mean_values_.size() == 1 || mean_values_.size() == img_channels) <<
1084            "Specify either 1 mean_value or as many as channels: " << img_channels;
1085        if (img_channels > 1 && mean_values_.size() == 1) {
1086          for (int c = 1; c < img_channels; ++c) {
1087            mean_values_.push_back(mean_values_[0]);
1088          }
1089        }
1090      }
1091      vector<cv::Mat> channels(img_channels);
1092      cv::split(*expand_img, channels);
1093      CHECK_EQ(channels.size(), mean_values_.size());
1094      for (int c = 0; c < img_channels; ++c) {
1095        channels[c] = mean_values_[c];
1096      }
1097      cv::merge(channels, *expand_img);
1098    }
1099    cv::Rect bbox_roi(w_off, h_off, img_width, img_height);
1100    img.copyTo((*expand_img)(bbox_roi));
1101  }
1102  static cv::Mat ResizeImagePerShorterSize(const cv::Mat& img, int shorter_size, ResizeParameter resize_param) {
1103    int h = img.size().height;
1104    int w = img.size().width;
1105    resize_param.set_height(shorter_size);
1106    resize_param.set_width(shorter_size);
1107    if (h < w) {
1108      resize_param.set_width(int(float(w) / h * shorter_size));
1109    } else {
1110      resize_param.set_height(int(float(h) / w * shorter_size));
1111    }
1112    return ApplyResize(img, resize_param);
1113  }
1114  template<typename Dtype>
<span onclick='openModal()' class='match'>1115  void DataTransformer<Dtype>::RandomResizeImage(const Datum& datum, Datum *resized_datum) {
1116    shared_ptr<cv::Mat> img;
1117    if (datum.encoded()) {
1118      img = shared_ptr<cv::Mat>(new cv::Mat(DecodeDatumToCVMatNative(datum)));
1119    } else {
</span>1120      img = shared_ptr<cv::Mat>(new cv::Mat(
1121                                  cv::Size(datum.width(), datum.height()),
1122                                  CV_8UC(datum.channels()),
1123                                  (void*)datum.data().data()));
1124    }
1125    cv::Mat resized_img;
1126    RandomResizeImage(*img, &resized_img);
1127    CVMatToDatum(resized_img, resized_datum);
1128  }
1129  template<typename Dtype>
1130  void DataTransformer<Dtype>::RandomResizeImage(const cv::Mat& img, cv::Mat *resized_img) {
1131    int h = img.size().height;
1132    int w = img.size().width;
1133    int min_size = param_.random_resize_param().min_size();
1134    int max_size = param_.random_resize_param().max_size();
1135    ResizeParameter resize_param = param_.random_resize_param().resize_param();
1136    if (min_size == 0) min_size = std::min(h,w);
1137    if (max_size == 0) max_size = std::max(h,w);
1138    int shorter_size = rand_num_(max_size - min_size + 1) + min_size;
1139    *resized_img = ResizeImagePerShorterSize(img, shorter_size, resize_param);
1140  }
1141  template<typename Dtype>
1142  void DataTransformer<Dtype>::RandomAlterAspectRatio(const Datum& datum, Datum *resized_datum) {
1143    shared_ptr<cv::Mat> img;
1144    if (datum.encoded()) {
1145      img = shared_ptr<cv::Mat>(new cv::Mat(DecodeDatumToCVMatNative(datum)));
1146    } else {
1147      img = shared_ptr<cv::Mat>(new cv::Mat(
1148                                  cv::Size(datum.width(), datum.height()),
1149                                  CV_8UC(datum.channels()),
1150                                  (void*)datum.data().data()));
1151    }
1152    cv::Mat resized_img;
1153    RandomAlterAspectRatio(*img, &resized_img);
1154    CVMatToDatum(resized_img, resized_datum);
1155  }
1156  static float RandRatio(float min, float max, RandNumbers& rand_num) {
1157    return (rand_num(int((max - min) * 1000 + 1)) + min * 1000) / 1000;
1158  }
1159  template<typename Dtype>
1160  void DataTransformer<Dtype>::RandomAlterAspectRatio(const cv::Mat& img, cv::Mat *resized_img) {
1161    const int crop_size = param_.crop_size();
1162    const int h = img.size().height;
1163    const int w = img.size().width;
1164    const float area = h * w;
1165    const float min_area_ratio = param_.random_aspect_ratio_param().min_area_ratio();
1166    const float max_area_ratio = param_.random_aspect_ratio_param().max_area_ratio();
1167    const float min_aspect_ratio_change =
1168      param_.random_aspect_ratio_param().aspect_ratio_change();
1169    CHECK(crop_size > 0);
1170    CHECK(max_area_ratio >= min_area_ratio);
1171    ResizeParameter resize_param = param_.random_aspect_ratio_param().resize_param();
1172    int attempt = 0;
1173    while (attempt++ < param_.random_aspect_ratio_param().max_attempt()) {
1174      float area_ratio = RandRatio(min_area_ratio, max_area_ratio, rand_num_);
1175      float aspect_ratio_change =
1176        RandRatio(min_aspect_ratio_change, 1 / min_aspect_ratio_change, rand_num_);
1177      float new_area = area_ratio * area;
1178      int new_h = int(sqrt(new_area) * aspect_ratio_change);
1179      int new_w = int(sqrt(new_area) / aspect_ratio_change);
1180      if (RandRatio(0, 1, rand_num_) < 0.5) {
1181        int tmp = new_h; new_h = new_w; new_w = tmp;
1182      }
1183      if (new_h <= h && new_w <= w) {
1184        int y = rand_num_(h - new_h + 1);
1185        int x = rand_num_(w - new_w + 1);
1186        cv::Rect roi(x, y, new_w, new_h);
1187        cv::Mat croppedImg = img(roi);
1188        resize_param.set_height(crop_size);
1189        resize_param.set_width(crop_size);
1190        *resized_img = ApplyResize(croppedImg, resize_param);
1191        return;
1192      }
1193    }
1194    *resized_img = ResizeImagePerShorterSize(img, crop_size, resize_param);
1195  }
1196  #endif  
1197  template<typename Dtype>
1198  void DataTransformer<Dtype>::Transform(Blob<Dtype>* input_blob,
1199                                         Blob<Dtype>* transformed_blob) {
1200    const int crop_size = param_.crop_size();
1201    const int input_num = input_blob->num();
1202    const int input_channels = input_blob->channels();
1203    const int input_height = input_blob->height();
1204    const int input_width = input_blob->width();
1205    if (transformed_blob->count() == 0) {
1206      if (crop_size) {
1207        transformed_blob->Reshape(input_num, input_channels,
1208                                  crop_size, crop_size);
1209      } else {
1210        transformed_blob->Reshape(input_num, input_channels,
1211                                  input_height, input_width);
1212      }
1213    }
1214    const int num = transformed_blob->num();
1215    const int channels = transformed_blob->channels();
1216    const int height = transformed_blob->height();
1217    const int width = transformed_blob->width();
1218    const int size = transformed_blob->count();
1219    CHECK_LE(input_num, num);
1220    CHECK_EQ(input_channels, channels);
1221    CHECK_GE(input_height, height);
1222    CHECK_GE(input_width, width);
1223    const Dtype scale = param_.scale();
1224    const bool do_mirror = param_.mirror() && rand_num_(2);
1225    const bool has_mean_file = param_.has_mean_file();
1226    const bool has_mean_values = mean_values_.size() > 0;
1227    int h_off = 0;
1228    int w_off = 0;
1229    if (crop_size) {
1230      CHECK_EQ(crop_size, height);
1231      CHECK_EQ(crop_size, width);
1232      if (phase_ == TRAIN) {
1233        h_off = rand_num_(input_height - crop_size + 1);
1234        w_off = rand_num_(input_width - crop_size + 1);
1235      } else {
1236        h_off = (input_height - crop_size) / 2;
1237        w_off = (input_width - crop_size) / 2;
1238      }
1239    } else {
1240      CHECK_EQ(input_height, height);
1241      CHECK_EQ(input_width, width);
1242    }
1243    Dtype* input_data = input_blob->mutable_cpu_data();
1244    if (has_mean_file) {
1245      CHECK_EQ(input_channels, data_mean_.channels());
1246      CHECK_EQ(input_height, data_mean_.height());
1247      CHECK_EQ(input_width, data_mean_.width());
1248      for (int n = 0; n < input_num; ++n) {
1249        int offset = input_blob->offset(n);
1250        caffe_sub(data_mean_.count(), input_data + offset,
1251                  data_mean_.cpu_data(), input_data + offset);
1252      }
1253    }
1254    if (has_mean_values) {
1255      CHECK(mean_values_.size() == 1 || mean_values_.size() == input_channels)
1256          << "Specify either 1 mean_value or as many as channels: "
1257          << input_channels;
1258      if (mean_values_.size() == 1) {
1259        caffe_add_scalar(input_blob->count(), -(mean_values_[0]), input_data);
1260      } else {
1261        for (int n = 0; n < input_num; ++n) {
1262          for (int c = 0; c < input_channels; ++c) {
1263            int offset = input_blob->offset(n, c);
1264            caffe_add_scalar(input_height * input_width, -(mean_values_[c]),
1265                             input_data + offset);
1266          }
1267        }
1268      }
1269    }
1270    Dtype* transformed_data = transformed_blob->mutable_cpu_data();
1271    for (int n = 0; n < input_num; ++n) {
1272      int top_index_n = n * channels;
1273      int data_index_n = n * channels;
1274      for (int c = 0; c < channels; ++c) {
1275        int top_index_c = (top_index_n + c) * height;
1276        int data_index_c = (data_index_n + c) * input_height + h_off;
1277        for (int h = 0; h < height; ++h) {
1278          int top_index_h = (top_index_c + h) * width;
1279          int data_index_h = (data_index_c + h) * input_width + w_off;
1280          if (do_mirror) {
1281            int top_index_w = top_index_h + width - 1;
1282            for (int w = 0; w < width; ++w) {
1283              transformed_data[top_index_w-w] = input_data[data_index_h + w];
1284            }
1285          } else {
1286            for (int w = 0; w < width; ++w) {
1287              transformed_data[top_index_h + w] = input_data[data_index_h + w];
1288            }
1289          }
1290        }
1291      }
1292    }
1293    if (scale != Dtype(1)) {
1294      DLOG(INFO) << "Scale: " << scale;
1295      caffe_scal(size, scale, transformed_data);
1296    }
1297  }
1298  template<typename Dtype>
1299  vector<int> DataTransformer<Dtype>::InferBlobShape(const Datum& datum) {
1300    if (datum.encoded()) {
1301  #ifdef USE_OPENCV
1302      CHECK(!(param_.force_color() && param_.force_gray()))
1303          << "cannot set both force_color and force_gray";
1304      cv::Mat cv_img;
1305      if (param_.force_color() || param_.force_gray()) {
1306        cv_img = DecodeDatumToCVMat(datum, param_.force_color());
1307      } else {
1308        cv_img = DecodeDatumToCVMatNative(datum);
1309      }
1310      return InferBlobShape(cv_img);
1311  #else
1312      LOG(FATAL) << "Encoded datum requires OpenCV; compile with USE_OPENCV.";
1313  #endif  
1314    }
1315    const int crop_size = param_.crop_size();
1316    const int datum_channels = datum.channels();
1317    int datum_height = datum.height();
1318    int datum_width = datum.width();
1319    CHECK_GT(datum_channels, 0);
1320    CHECK_GE(datum_height, crop_size);
1321    CHECK_GE(datum_width, crop_size);
1322    if (param_.has_resize_param()) {
1323      InferNewSize(param_.resize_param(), datum_width, datum_height,
1324                   &datum_width, &datum_height);
1325    }
1326    vector<int> shape(4);
1327    shape[0] = 1;
1328    shape[1] = datum_channels;
1329    shape[2] = (crop_size)? crop_size: datum_height;
1330    shape[3] = (crop_size)? crop_size: datum_width;
1331    return shape;
1332  }
1333  template<typename Dtype>
1334  vector<int> DataTransformer<Dtype>::InferBlobShape(
1335      const vector<Datum> & datum_vector) {
1336    const int num = datum_vector.size();
1337    CHECK_GT(num, 0) << "There is no datum to in the vector";
1338    vector<int> shape = InferBlobShape(datum_vector[0]);
1339    shape[0] = num;
1340    return shape;
1341  }
1342  #ifdef USE_OPENCV
1343  template<typename Dtype>
1344  vector<int> DataTransformer<Dtype>::InferBlobShape(const cv::Mat& cv_img) {
1345    const int crop_size = param_.crop_size();
1346    const int pad = param_.pad();
1347    const int img_channels = cv_img.channels();
1348    int img_height = cv_img.rows;
1349    int img_width = cv_img.cols;
1350    CHECK_GT(img_channels, 0);
1351    if (param_.has_random_resize_param() || param_.has_random_aspect_ratio_param()) {
1352      CHECK_GT(crop_size, 0);
1353    } else {
1354      CHECK_GE(img_height, crop_size);
1355      CHECK_GE(img_width, crop_size);
1356    }
1357    if (param_.has_resize_param()) {
1358      InferNewSize(param_.resize_param(), img_width, img_height,
1359                   &img_width, &img_height);
1360    }
1361    vector<int> shape(4);
1362    shape[0] = 1;
1363    shape[1] = img_channels;
1364    shape[2] = ((crop_size)? crop_size: img_height) + pad * 2;
1365    shape[3] = ((crop_size)? crop_size: img_width) + pad * 2;
1366    return shape;
1367  }
1368  template<typename Dtype>
1369  vector<int> DataTransformer<Dtype>::InferBlobShape(
1370      const vector<cv::Mat> & mat_vector) {
1371    const int num = mat_vector.size();
1372    CHECK_GT(num, 0) << "There is no cv_img to in the vector";
1373    vector<int> shape = InferBlobShape(mat_vector[0]);
1374    shape[0] = num;
1375    return shape;
1376  }
1377  #endif  
1378  template <typename Dtype>
1379  void DataTransformer<Dtype>::InitRand() {
1380    const bool needs_rand = param_.mirror() ||
1381        param_.has_random_resize_param() ||
1382        param_.has_random_aspect_ratio_param() ||
1383        (phase_ == TRAIN && param_.crop_size());
1384    if (needs_rand) {
1385      rand_num_.Init();
1386    } else {
1387      rand_num_.Reset();
1388    }
1389  }
1390  template <typename Dtype>
1391  void DataTransformer<Dtype>::ReinitRand() {
1392    if (rand_num_.IsEmpty()) {
1393      rand_num_.Init();
1394    }
1395  }
1396  INSTANTIATE_CLASS(DataTransformer);
1397  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-googlex.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-data_transformer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>167  void TGgSchRSet::SaveBin(const TStr& FNm, const PGgSchRSet& GgSchRSet){
168    if (GgSchRSet.Empty()){
169      PGgSchRSet RSet=TGgSchRSet::New();
170      GgSchRSet->SaveBin(FNm);
171    } else {
</pre></code></div>
                <div class="column column_space"><pre><code>1115  void DataTransformer<Dtype>::RandomResizeImage(const Datum& datum, Datum *resized_datum) {
1116    shared_ptr<cv::Mat> img;
1117    if (datum.encoded()) {
1118      img = shared_ptr<cv::Mat>(new cv::Mat(DecodeDatumToCVMatNative(datum)));
1119    } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    