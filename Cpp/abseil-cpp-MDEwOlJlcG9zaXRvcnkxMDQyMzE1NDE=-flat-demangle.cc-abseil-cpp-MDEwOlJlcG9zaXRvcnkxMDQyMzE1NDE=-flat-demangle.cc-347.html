
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-demangle.cc</h3>
            <pre><code>1  #include &quot;absl/debugging/internal/demangle.h&quot;
2  #include &lt;cstdint&gt;
3  #include &lt;cstdio&gt;
4  #include &lt;limits&gt;
5  namespace absl {
6  ABSL_NAMESPACE_BEGIN
7  namespace debugging_internal {
8  typedef struct {
9    const char *abbrev;
10    const char *real_name;
11    int arity;
12  } AbbrevPair;
13  static const AbbrevPair kOperatorList[] = {
14      {&quot;nw&quot;, &quot;new&quot;, 0},
15      {&quot;na&quot;, &quot;new[]&quot;, 0},
16      {&quot;dl&quot;, &quot;delete&quot;, 1},
17      {&quot;da&quot;, &quot;delete[]&quot;, 1},
18      {&quot;ps&quot;, &quot;+&quot;, 1},  
19      {&quot;ng&quot;, &quot;-&quot;, 1},  
20      {&quot;ad&quot;, &quot;&amp;&quot;, 1},  
21      {&quot;de&quot;, &quot;*&quot;, 1},  
22      {&quot;co&quot;, &quot;~&quot;, 1},
23      {&quot;pl&quot;, &quot;+&quot;, 2},
24      {&quot;mi&quot;, &quot;-&quot;, 2},
25      {&quot;ml&quot;, &quot;*&quot;, 2},
26      {&quot;dv&quot;, &quot;/&quot;, 2},
27      {&quot;rm&quot;, &quot;%&quot;, 2},
28      {&quot;an&quot;, &quot;&amp;&quot;, 2},
29      {&quot;or&quot;, &quot;|&quot;, 2},
30      {&quot;eo&quot;, &quot;^&quot;, 2},
31      {&quot;aS&quot;, &quot;=&quot;, 2},
32      {&quot;pL&quot;, &quot;+=&quot;, 2},
33      {&quot;mI&quot;, &quot;-=&quot;, 2},
34      {&quot;mL&quot;, &quot;*=&quot;, 2},
35      {&quot;dV&quot;, &quot;/=&quot;, 2},
36      {&quot;rM&quot;, &quot;%=&quot;, 2},
37      {&quot;aN&quot;, &quot;&amp;=&quot;, 2},
38      {&quot;oR&quot;, &quot;|=&quot;, 2},
39      {&quot;eO&quot;, &quot;^=&quot;, 2},
40      {&quot;ls&quot;, &quot;&lt;&lt;&quot;, 2},
41      {&quot;rs&quot;, &quot;&gt;&gt;&quot;, 2},
42      {&quot;lS&quot;, &quot;&lt;&lt;=&quot;, 2},
43      {&quot;rS&quot;, &quot;&gt;&gt;=&quot;, 2},
44      {&quot;eq&quot;, &quot;==&quot;, 2},
45      {&quot;ne&quot;, &quot;!=&quot;, 2},
46      {&quot;lt&quot;, &quot;&lt;&quot;, 2},
47      {&quot;gt&quot;, &quot;&gt;&quot;, 2},
48      {&quot;le&quot;, &quot;&lt;=&quot;, 2},
49      {&quot;ge&quot;, &quot;&gt;=&quot;, 2},
50      {&quot;nt&quot;, &quot;!&quot;, 1},
51      {&quot;aa&quot;, &quot;&amp;&amp;&quot;, 2},
52      {&quot;oo&quot;, &quot;||&quot;, 2},
53      {&quot;pp&quot;, &quot;++&quot;, 1},
54      {&quot;mm&quot;, &quot;--&quot;, 1},
55      {&quot;cm&quot;, &quot;,&quot;, 2},
56      {&quot;pm&quot;, &quot;-&gt;*&quot;, 2},
57      {&quot;pt&quot;, &quot;-&gt;&quot;, 0},  
58      {&quot;cl&quot;, &quot;()&quot;, 0},  
59      {&quot;ix&quot;, &quot;[]&quot;, 2},
60      {&quot;qu&quot;, &quot;?&quot;, 3},
61      {&quot;st&quot;, &quot;sizeof&quot;, 0},  
62      {&quot;sz&quot;, &quot;sizeof&quot;, 1},  
63      {nullptr, nullptr, 0},
64  };
65  static const AbbrevPair kBuiltinTypeList[] = {
66      {&quot;v&quot;, &quot;void&quot;, 0},
67      {&quot;w&quot;, &quot;wchar_t&quot;, 0},
68      {&quot;b&quot;, &quot;bool&quot;, 0},
69      {&quot;c&quot;, &quot;char&quot;, 0},
70      {&quot;a&quot;, &quot;signed char&quot;, 0},
71      {&quot;h&quot;, &quot;unsigned char&quot;, 0},
72      {&quot;s&quot;, &quot;short&quot;, 0},
73      {&quot;t&quot;, &quot;unsigned short&quot;, 0},
74      {&quot;i&quot;, &quot;int&quot;, 0},
75      {&quot;j&quot;, &quot;unsigned int&quot;, 0},
76      {&quot;l&quot;, &quot;long&quot;, 0},
77      {&quot;m&quot;, &quot;unsigned long&quot;, 0},
78      {&quot;x&quot;, &quot;long long&quot;, 0},
79      {&quot;y&quot;, &quot;unsigned long long&quot;, 0},
80      {&quot;n&quot;, &quot;__int128&quot;, 0},
81      {&quot;o&quot;, &quot;unsigned __int128&quot;, 0},
82      {&quot;f&quot;, &quot;float&quot;, 0},
83      {&quot;d&quot;, &quot;double&quot;, 0},
84      {&quot;e&quot;, &quot;long double&quot;, 0},
85      {&quot;g&quot;, &quot;__float128&quot;, 0},
86      {&quot;z&quot;, &quot;ellipsis&quot;, 0},
87      {&quot;De&quot;, &quot;decimal128&quot;, 0},      
88      {&quot;Dd&quot;, &quot;decimal64&quot;, 0},       
89      {&quot;Dc&quot;, &quot;decltype(auto)&quot;, 0},
90      {&quot;Da&quot;, &quot;auto&quot;, 0},
91      {&quot;Dn&quot;, &quot;std::nullptr_t&quot;, 0},  
92      {&quot;Df&quot;, &quot;decimal32&quot;, 0},       
93      {&quot;Di&quot;, &quot;char32_t&quot;, 0},
94      {&quot;Du&quot;, &quot;char8_t&quot;, 0},
95      {&quot;Ds&quot;, &quot;char16_t&quot;, 0},
96      {&quot;Dh&quot;, &quot;float16&quot;, 0},         
97      {nullptr, nullptr, 0},
98  };
99  static const AbbrevPair kSubstitutionList[] = {
100      {&quot;St&quot;, &quot;&quot;, 0},
101      {&quot;Sa&quot;, &quot;allocator&quot;, 0},
102      {&quot;Sb&quot;, &quot;basic_string&quot;, 0},
103      {&quot;Ss&quot;, &quot;string&quot;, 0},
104      {&quot;Si&quot;, &quot;istream&quot;, 0},
105      {&quot;So&quot;, &quot;ostream&quot;, 0},
106      {&quot;Sd&quot;, &quot;iostream&quot;, 0},
107      {nullptr, nullptr, 0},
108  };
109  typedef struct {
110    int mangled_idx;                     
111    int out_cur_idx;                     
112    int prev_name_idx;                   
113    unsigned int prev_name_length : 16;  
114    signed int nest_level : 15;          
115    unsigned int append : 1;             
116  } ParseState;
117  static_assert(sizeof(ParseState) == 4 * sizeof(int),
118                &quot;unexpected size of ParseState&quot;);
119  typedef struct {
120    const char *mangled_begin;  
121    char *out;                  
122    int out_end_idx;            
123    int recursion_depth;        
124    int steps;               
125    ParseState parse_state;  
126  } State;
127  namespace {
128  class ComplexityGuard {
129   public:
130    explicit ComplexityGuard(State *state) : state_(state) {
131      ++state-&gt;recursion_depth;
132      ++state-&gt;steps;
133    }
134    ~ComplexityGuard() { --state_-&gt;recursion_depth; }
135    static constexpr int kRecursionDepthLimit = 256;
136    static constexpr int kParseStepsLimit = 1 &lt;&lt; 17;
137    bool IsTooComplex() const {
138      return state_-&gt;recursion_depth &gt; kRecursionDepthLimit ||
139             state_-&gt;steps &gt; kParseStepsLimit;
140    }
141   private:
142    State *state_;
143  };
144  }  
145  static size_t StrLen(const char *str) {
146    size_t len = 0;
147    while (*str != &#x27;\0&#x27;) {
148      ++str;
149      ++len;
150    }
151    return len;
152  }
153  static bool AtLeastNumCharsRemaining(const char *str, size_t n) {
154    for (size_t i = 0; i &lt; n; ++i) {
155      if (str[i] == &#x27;\0&#x27;) {
156        return false;
157      }
158    }
159    return true;
160  }
161  static bool StrPrefix(const char *str, const char *prefix) {
162    size_t i = 0;
163    while (str[i] != &#x27;\0&#x27; &amp;&amp; prefix[i] != &#x27;\0&#x27; &amp;&amp; str[i] == prefix[i]) {
164      ++i;
165    }
166    return prefix[i] == &#x27;\0&#x27;;  
167  }
168  static void InitState(State* state,
169                        const char* mangled,
170                        char* out,
171                        size_t out_size) {
172    state-&gt;mangled_begin = mangled;
173    state-&gt;out = out;
174    state-&gt;out_end_idx = static_cast&lt;int&gt;(out_size);
175    state-&gt;recursion_depth = 0;
176    state-&gt;steps = 0;
177    state-&gt;parse_state.mangled_idx = 0;
178    state-&gt;parse_state.out_cur_idx = 0;
179    state-&gt;parse_state.prev_name_idx = 0;
180    state-&gt;parse_state.prev_name_length = 0;
181    state-&gt;parse_state.nest_level = -1;
182    state-&gt;parse_state.append = true;
183  }
184  static inline const char *RemainingInput(State *state) {
185    return &amp;state-&gt;mangled_begin[state-&gt;parse_state.mangled_idx];
186  }
187  static bool ParseOneCharToken(State *state, const char one_char_token) {
188    ComplexityGuard guard(state);
189    if (guard.IsTooComplex()) return false;
190    if (RemainingInput(state)[0] == one_char_token) {
191      ++state-&gt;parse_state.mangled_idx;
192      return true;
193    }
194    return false;
195  }
196  static bool ParseTwoCharToken(State *state, const char *two_char_token) {
197    ComplexityGuard guard(state);
198    if (guard.IsTooComplex()) return false;
199    if (RemainingInput(state)[0] == two_char_token[0] &amp;&amp;
200        RemainingInput(state)[1] == two_char_token[1]) {
201      state-&gt;parse_state.mangled_idx += 2;
202      return true;
203    }
204    return false;
205  }
206  static bool ParseCharClass(State *state, const char *char_class) {
207    ComplexityGuard guard(state);
208    if (guard.IsTooComplex()) return false;
209    if (RemainingInput(state)[0] == &#x27;\0&#x27;) {
210      return false;
211    }
212    const char *p = char_class;
213    for (; *p != &#x27;\0&#x27;; ++p) {
214      if (RemainingInput(state)[0] == *p) {
215        ++state-&gt;parse_state.mangled_idx;
216        return true;
217      }
218    }
219    return false;
220  }
221  static bool ParseDigit(State *state, int *digit) {
222    char c = RemainingInput(state)[0];
223    if (ParseCharClass(state, &quot;0123456789&quot;)) {
224      if (digit != nullptr) {
225        *digit = c - &#x27;0&#x27;;
226      }
227      return true;
228    }
229    return false;
230  }
231  static bool Optional(bool &amp;bsol;*status*/) { return true; }
232  typedef bool (*ParseFunc)(State *);
233  static bool OneOrMore(ParseFunc parse_func, State *state) {
234    if (parse_func(state)) {
235      while (parse_func(state)) {
236      }
237      return true;
238    }
239    return false;
240  }
241  static bool ZeroOrMore(ParseFunc parse_func, State *state) {
242    while (parse_func(state)) {
243    }
244    return true;
245  }
246  static void Append(State *state, const char *const str, const size_t length) {
247    for (size_t i = 0; i &lt; length; ++i) {
248      if (state-&gt;parse_state.out_cur_idx + 1 &lt;
249          state-&gt;out_end_idx) {  
250        state-&gt;out[state-&gt;parse_state.out_cur_idx++] = str[i];
251      } else {
252        state-&gt;parse_state.out_cur_idx = state-&gt;out_end_idx + 1;
253        break;
254      }
255    }
256    if (state-&gt;parse_state.out_cur_idx &lt; state-&gt;out_end_idx) {
257      state-&gt;out[state-&gt;parse_state.out_cur_idx] =
258          &#x27;\0&#x27;;  
259    }
260  }
261  static bool IsLower(char c) { return c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;; }
262  static bool IsAlpha(char c) {
263    return (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) || (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;);
264  }
265  static bool IsDigit(char c) { return c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; }
266  static bool IsFunctionCloneSuffix(const char *str) {
267    size_t i = 0;
268    while (str[i] != &#x27;\0&#x27;) {
269      bool parsed = false;
270      if (str[i] == &#x27;.&#x27; &amp;&amp; (IsAlpha(str[i + 1]) || str[i + 1] == &#x27;_&#x27;)) {
271        parsed = true;
272        i += 2;
273        while (IsAlpha(str[i]) || str[i] == &#x27;_&#x27;) {
274          ++i;
275        }
276      }
277      if (str[i] == &#x27;.&#x27; &amp;&amp; IsDigit(str[i + 1])) {
278        parsed = true;
279        i += 2;
280        while (IsDigit(str[i])) {
281          ++i;
282        }
283      }
284      if (!parsed)
285        return false;
286    }
287    return true;  
288  }
289  static bool EndsWith(State *state, const char chr) {
290    return state-&gt;parse_state.out_cur_idx &gt; 0 &amp;&amp;
291           state-&gt;parse_state.out_cur_idx &lt; state-&gt;out_end_idx &amp;&amp;
292           chr == state-&gt;out[state-&gt;parse_state.out_cur_idx - 1];
293  }
294  static void MaybeAppendWithLength(State *state, const char *const str,
295                                    const size_t length) {
296    if (state-&gt;parse_state.append &amp;&amp; length &gt; 0) {
297      if (str[0] == &#x27;&lt;&#x27; &amp;&amp; EndsWith(state, &#x27;&lt;&#x27;)) {
298        Append(state, &quot; &quot;, 1);
299      }
300      if (state-&gt;parse_state.out_cur_idx &lt; state-&gt;out_end_idx &amp;&amp;
301          (IsAlpha(str[0]) || str[0] == &#x27;_&#x27;)) {
302        state-&gt;parse_state.prev_name_idx = state-&gt;parse_state.out_cur_idx;
303        state-&gt;parse_state.prev_name_length = static_cast&lt;unsigned int&gt;(length);
304      }
305      Append(state, str, length);
306    }
307  }
308  static bool MaybeAppendDecimal(State *state, int val) {
309    constexpr size_t kMaxLength = 20;
310    char buf[kMaxLength];
311    if (state-&gt;parse_state.append) {
312      char *p = &amp;buf[kMaxLength];
313      do {  
314        *--p = static_cast&lt;char&gt;((val % 10) + &#x27;0&#x27;);
315        val /= 10;
316      } while (p &gt; buf &amp;&amp; val != 0);
317      Append(state, p, kMaxLength - static_cast&lt;size_t&gt;(p - buf));
318    }
319    return true;
320  }
321  static bool MaybeAppend(State *state, const char *const str) {
322    if (state-&gt;parse_state.append) {
323      size_t length = StrLen(str);
324      MaybeAppendWithLength(state, str, length);
325    }
326    return true;
327  }
328  static bool EnterNestedName(State *state) {
329    state-&gt;parse_state.nest_level = 0;
330    return true;
331  }
332  static bool LeaveNestedName(State *state, int16_t prev_value) {
333    state-&gt;parse_state.nest_level = prev_value;
334    return true;
335  }
336  static bool DisableAppend(State *state) {
337    state-&gt;parse_state.append = false;
338    return true;
339  }
340  static bool RestoreAppend(State *state, bool prev_value) {
341    state-&gt;parse_state.append = prev_value;
342    return true;
343  }
344  static void MaybeIncreaseNestLevel(State *state) {
345    if (state-&gt;parse_state.nest_level &gt; -1) {
346      ++state-&gt;parse_state.nest_level;
347    }
348  }
349  static void MaybeAppendSeparator(State *state) {
350    if (state-&gt;parse_state.nest_level &gt;= 1) {
351      MaybeAppend(state, &quot;::&quot;);
352    }
353  }
354  static void MaybeCancelLastSeparator(State *state) {
355    if (state-&gt;parse_state.nest_level &gt;= 1 &amp;&amp; state-&gt;parse_state.append &amp;&amp;
356        state-&gt;parse_state.out_cur_idx &gt;= 2) {
357      state-&gt;parse_state.out_cur_idx -= 2;
358      state-&gt;out[state-&gt;parse_state.out_cur_idx] = &#x27;\0&#x27;;
359    }
360  }
361  static bool IdentifierIsAnonymousNamespace(State *state, size_t length) {
362    static const char anon_prefix[] = &quot;_GLOBAL__N_&quot;;
363    return (length &gt; (sizeof(anon_prefix) - 1) &amp;&amp;
364            StrPrefix(RemainingInput(state), anon_prefix));
365  }
366  static bool ParseMangledName(State *state);
367  static bool ParseEncoding(State *state);
368  static bool ParseName(State *state);
369  static bool ParseUnscopedName(State *state);
370  static bool ParseNestedName(State *state);
371  static bool ParsePrefix(State *state);
372  static bool ParseUnqualifiedName(State *state);
373  static bool ParseSourceName(State *state);
374  static bool ParseLocalSourceName(State *state);
375  static bool ParseUnnamedTypeName(State *state);
376  static bool ParseNumber(State *state, int *number_out);
377  static bool ParseFloatNumber(State *state);
378  static bool ParseSeqId(State *state);
379  static bool ParseIdentifier(State *state, size_t length);
380  static bool ParseOperatorName(State *state, int *arity);
381  static bool ParseSpecialName(State *state);
382  static bool ParseCallOffset(State *state);
383  static bool ParseNVOffset(State *state);
384  static bool ParseVOffset(State *state);
385  static bool ParseAbiTags(State *state);
386  static bool ParseCtorDtorName(State *state);
387  static bool ParseDecltype(State *state);
388  static bool ParseType(State *state);
389  static bool ParseCVQualifiers(State *state);
390  static bool ParseBuiltinType(State *state);
391  static bool ParseFunctionType(State *state);
392  static bool ParseBareFunctionType(State *state);
393  static bool ParseClassEnumType(State *state);
394  static bool ParseArrayType(State *state);
395  static bool ParsePointerToMemberType(State *state);
396  static bool ParseTemplateParam(State *state);
397  static bool ParseTemplateTemplateParam(State *state);
398  static bool ParseTemplateArgs(State *state);
399  static bool ParseTemplateArg(State *state);
400  static bool ParseBaseUnresolvedName(State *state);
401  static bool ParseUnresolvedName(State *state);
402  static bool ParseExpression(State *state);
403  static bool ParseExprPrimary(State *state);
404  static bool ParseExprCastValue(State *state);
405  static bool ParseLocalName(State *state);
406  static bool ParseLocalNameSuffix(State *state);
407  static bool ParseDiscriminator(State *state);
408  static bool ParseSubstitution(State *state, bool accept_std);
409  static bool ParseMangledName(State *state) {
410    ComplexityGuard guard(state);
411    if (guard.IsTooComplex()) return false;
412    return ParseTwoCharToken(state, &quot;_Z&quot;) &amp;&amp; ParseEncoding(state);
413  }
414  static bool ParseEncoding(State *state) {
415    ComplexityGuard guard(state);
416    if (guard.IsTooComplex()) return false;
417    if (ParseName(state) &amp;&amp; Optional(ParseBareFunctionType(state))) {
418      return true;
419    }
420    if (ParseSpecialName(state)) {
421      return true;
422    }
423    return false;
424  }
425  static bool ParseName(State *state) {
426    ComplexityGuard guard(state);
427    if (guard.IsTooComplex()) return false;
428    if (ParseNestedName(state) || ParseLocalName(state)) {
429      return true;
430    }
431    ParseState copy = state-&gt;parse_state;
432    if (ParseSubstitution(state, &amp;bsol;*accept_std=*/false) &amp;&amp;
433        ParseTemplateArgs(state)) {
434      return true;
435    }
436    state-&gt;parse_state = copy;
437    return ParseUnscopedName(state) &amp;&amp; Optional(ParseTemplateArgs(state));
438  }
439  static bool ParseUnscopedName(State *state) {
440    ComplexityGuard guard(state);
441    if (guard.IsTooComplex()) return false;
442    if (ParseUnqualifiedName(state)) {
443      return true;
444    }
445    ParseState copy = state-&gt;parse_state;
446    if (ParseTwoCharToken(state, &quot;St&quot;) &amp;&amp; MaybeAppend(state, &quot;std::&quot;) &amp;&amp;
447        ParseUnqualifiedName(state)) {
448      return true;
449    }
450    state-&gt;parse_state = copy;
451    return false;
452  }
453  static inline bool ParseRefQualifier(State *state) {
454    return ParseCharClass(state, &quot;OR&quot;);
455  }
456  static bool ParseNestedName(State *state) {
457    ComplexityGuard guard(state);
458    if (guard.IsTooComplex()) return false;
459    ParseState copy = state-&gt;parse_state;
460    if (ParseOneCharToken(state, &#x27;N&#x27;) &amp;&amp; EnterNestedName(state) &amp;&amp;
461        Optional(ParseCVQualifiers(state)) &amp;&amp;
462        Optional(ParseRefQualifier(state)) &amp;&amp; ParsePrefix(state) &amp;&amp;
463        LeaveNestedName(state, copy.nest_level) &amp;&amp;
464        ParseOneCharToken(state, &#x27;E&#x27;)) {
465      return true;
466    }
467    state-&gt;parse_state = copy;
468    return false;
469  }
470  static bool ParsePrefix(State *state) {
471    ComplexityGuard guard(state);
472    if (guard.IsTooComplex()) return false;
473    bool has_something = false;
474    while (true) {
475      MaybeAppendSeparator(state);
476      if (ParseTemplateParam(state) ||
477          ParseSubstitution(state, &amp;bsol;*accept_std=*/true) ||
478          ParseUnscopedName(state) ||
479          (ParseOneCharToken(state, &#x27;M&#x27;) &amp;&amp; ParseUnnamedTypeName(state))) {
480        has_something = true;
481        MaybeIncreaseNestLevel(state);
482        continue;
483      }
484      MaybeCancelLastSeparator(state);
485      if (has_something &amp;&amp; ParseTemplateArgs(state)) {
486        return ParsePrefix(state);
487      } else {
488        break;
489      }
490    }
491    return true;
492  }
493  static bool ParseUnqualifiedName(State *state) {
494    ComplexityGuard guard(state);
495    if (guard.IsTooComplex()) return false;
496    if (ParseOperatorName(state, nullptr) || ParseCtorDtorName(state) ||
497        ParseSourceName(state) || ParseLocalSourceName(state) ||
498        ParseUnnamedTypeName(state)) {
499      return ParseAbiTags(state);
500    }
501    return false;
502  }
503  static bool ParseAbiTags(State *state) {
504    ComplexityGuard guard(state);
505    if (guard.IsTooComplex()) return false;
506    while (ParseOneCharToken(state, &#x27;B&#x27;)) {
507      ParseState copy = state-&gt;parse_state;
508      MaybeAppend(state, &quot;[abi:&quot;);
509      if (!ParseSourceName(state)) {
510        state-&gt;parse_state = copy;
511        return false;
512      }
513      MaybeAppend(state, &quot;]&quot;);
514    }
515    return true;
516  }
517  static bool ParseSourceName(State *state) {
518    ComplexityGuard guard(state);
519    if (guard.IsTooComplex()) return false;
520    ParseState copy = state-&gt;parse_state;
521    int length = -1;
522    if (ParseNumber(state, &amp;length) &amp;&amp;
523        ParseIdentifier(state, static_cast&lt;size_t&gt;(length))) {
524      return true;
525    }
526    state-&gt;parse_state = copy;
527    return false;
528  }
529  static bool ParseLocalSourceName(State *state) {
530    ComplexityGuard guard(state);
531    if (guard.IsTooComplex()) return false;
532    ParseState copy = state-&gt;parse_state;
533    if (ParseOneCharToken(state, &#x27;L&#x27;) &amp;&amp; ParseSourceName(state) &amp;&amp;
534        Optional(ParseDiscriminator(state))) {
535      return true;
536    }
537    state-&gt;parse_state = copy;
538    return false;
539  }
540  static bool ParseUnnamedTypeName(State *state) {
541    ComplexityGuard guard(state);
542    if (guard.IsTooComplex()) return false;
543    ParseState copy = state-&gt;parse_state;
544    int which = -1;
545    if (ParseTwoCharToken(state, &quot;Ut&quot;) &amp;&amp; Optional(ParseNumber(state, &amp;which)) &amp;&amp;
546        which &lt;= std::numeric_limits&lt;int&gt;::max() - 2 &amp;&amp;  
547        ParseOneCharToken(state, &#x27;_&#x27;)) {
548      MaybeAppend(state, &quot;{unnamed type#&quot;);
549      MaybeAppendDecimal(state, 2 + which);
550      MaybeAppend(state, &quot;}&quot;);
551      return true;
552    }
553    state-&gt;parse_state = copy;
554    which = -1;
555    if (ParseTwoCharToken(state, &quot;Ul&quot;) &amp;&amp; DisableAppend(state) &amp;&amp;
556        OneOrMore(ParseType, state) &amp;&amp; RestoreAppend(state, copy.append) &amp;&amp;
557        ParseOneCharToken(state, &#x27;E&#x27;) &amp;&amp; Optional(ParseNumber(state, &amp;which)) &amp;&amp;
558        which &lt;= std::numeric_limits&lt;int&gt;::max() - 2 &amp;&amp;  
559        ParseOneCharToken(state, &#x27;_&#x27;)) {
560      MaybeAppend(state, &quot;{lambda()#&quot;);
561      MaybeAppendDecimal(state, 2 + which);
562      MaybeAppend(state, &quot;}&quot;);
563      return true;
564    }
565    state-&gt;parse_state = copy;
566    return false;
567  }
568  static bool ParseNumber(State *state, int *number_out) {
569    ComplexityGuard guard(state);
570    if (guard.IsTooComplex()) return false;
571    bool negative = false;
572    if (ParseOneCharToken(state, &#x27;n&#x27;)) {
573      negative = true;
574    }
575    const char *p = RemainingInput(state);
576    uint64_t number = 0;
577    for (; *p != &#x27;\0&#x27;; ++p) {
578      if (IsDigit(*p)) {
579        number = number * 10 + static_cast&lt;uint64_t&gt;(*p - &#x27;0&#x27;);
580      } else {
581        break;
582      }
583    }
584    if (negative) {
585      number = ~number + 1;
586    }
587    if (p != RemainingInput(state)) {  
588      state-&gt;parse_state.mangled_idx += p - RemainingInput(state);
589      if (number_out != nullptr) {
590        *number_out = static_cast&lt;int&gt;(number);
591      }
592      return true;
593    }
594    return false;
595  }
596  static bool ParseFloatNumber(State *state) {
597    ComplexityGuard guard(state);
598    if (guard.IsTooComplex()) return false;
599    const char *p = RemainingInput(state);
600    for (; *p != &#x27;\0&#x27;; ++p) {
601      if (!IsDigit(*p) &amp;&amp; !(*p &gt;= &#x27;a&#x27; &amp;&amp; *p &lt;= &#x27;f&#x27;)) {
602        break;
603      }
604    }
605    if (p != RemainingInput(state)) {  
606      state-&gt;parse_state.mangled_idx += p - RemainingInput(state);
607      return true;
608    }
609    return false;
610  }
611  static bool ParseSeqId(State *state) {
612    ComplexityGuard guard(state);
613    if (guard.IsTooComplex()) return false;
614    const char *p = RemainingInput(state);
615    for (; *p != &#x27;\0&#x27;; ++p) {
616      if (!IsDigit(*p) &amp;&amp; !(*p &gt;= &#x27;A&#x27; &amp;&amp; *p &lt;= &#x27;Z&#x27;)) {
617        break;
618      }
619    }
620    if (p != RemainingInput(state)) {  
621      state-&gt;parse_state.mangled_idx += p - RemainingInput(state);
622      return true;
623    }
624    return false;
625  }
626  static bool ParseIdentifier(State *state, size_t length) {
627    ComplexityGuard guard(state);
628    if (guard.IsTooComplex()) return false;
629    if (!AtLeastNumCharsRemaining(RemainingInput(state), length)) {
630      return false;
631    }
632    if (IdentifierIsAnonymousNamespace(state, length)) {
633      MaybeAppend(state, &quot;(anonymous namespace)&quot;);
634    } else {
635      MaybeAppendWithLength(state, RemainingInput(state), length);
636    }
637    state-&gt;parse_state.mangled_idx += length;
638    return true;
639  }
640  static bool ParseOperatorName(State *state, int *arity) {
641    ComplexityGuard guard(state);
642    if (guard.IsTooComplex()) return false;
643    if (!AtLeastNumCharsRemaining(RemainingInput(state), 2)) {
644      return false;
645    }
646    ParseState copy = state-&gt;parse_state;
647    if (ParseTwoCharToken(state, &quot;cv&quot;) &amp;&amp; MaybeAppend(state, &quot;operator &quot;) &amp;&amp;
648        EnterNestedName(state) &amp;&amp; ParseType(state) &amp;&amp;
649        LeaveNestedName(state, copy.nest_level)) {
650      if (arity != nullptr) {
651        *arity = 1;
652      }
653      return true;
654    }
655    state-&gt;parse_state = copy;
656    if (ParseOneCharToken(state, &#x27;v&#x27;) &amp;&amp; ParseDigit(state, arity) &amp;&amp;
657        ParseSourceName(state)) {
658      return true;
659    }
660    state-&gt;parse_state = copy;
661    if (!(IsLower(RemainingInput(state)[0]) &amp;&amp;
662          IsAlpha(RemainingInput(state)[1]))) {
663      return false;
664    }
665    const AbbrevPair *p;
666    for (p = kOperatorList; p-&gt;abbrev != nullptr; ++p) {
667      if (RemainingInput(state)[0] == p-&gt;abbrev[0] &amp;&amp;
668          RemainingInput(state)[1] == p-&gt;abbrev[1]) {
669        if (arity != nullptr) {
670          *arity = p-&gt;arity;
671        }
672        MaybeAppend(state, &quot;operator&quot;);
673        if (IsLower(*p-&gt;real_name)) {  
674          MaybeAppend(state, &quot; &quot;);
675        }
676        MaybeAppend(state, p-&gt;real_name);
677        state-&gt;parse_state.mangled_idx += 2;
678        return true;
679      }
680    }
681    return false;
682  }
683  static bool ParseSpecialName(State *state) {
684    ComplexityGuard guard(state);
685    if (guard.IsTooComplex()) return false;
686    ParseState copy = state-&gt;parse_state;
687    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseCharClass(state, &quot;VTISH&quot;) &amp;&amp;
688        ParseType(state)) {
689      return true;
690    }
691    state-&gt;parse_state = copy;
692    if (ParseTwoCharToken(state, &quot;Tc&quot;) &amp;&amp; ParseCallOffset(state) &amp;&amp;
693        ParseCallOffset(state) &amp;&amp; ParseEncoding(state)) {
694      return true;
695    }
696    state-&gt;parse_state = copy;
697    if (ParseTwoCharToken(state, &quot;GV&quot;) &amp;&amp; ParseName(state)) {
698      return true;
699    }
700    state-&gt;parse_state = copy;
701    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseCallOffset(state) &amp;&amp;
702        ParseEncoding(state)) {
703      return true;
704    }
705    state-&gt;parse_state = copy;
706    if (ParseTwoCharToken(state, &quot;TC&quot;) &amp;&amp; ParseType(state) &amp;&amp;
707        ParseNumber(state, nullptr) &amp;&amp; ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp;
708        DisableAppend(state) &amp;&amp; ParseType(state)) {
709      RestoreAppend(state, copy.append);
710      return true;
711    }
712    state-&gt;parse_state = copy;
713    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseCharClass(state, &quot;FJ&quot;) &amp;&amp;
714        ParseType(state)) {
715      return true;
716    }
717    state-&gt;parse_state = copy;
718    if (ParseTwoCharToken(state, &quot;GR&quot;) &amp;&amp; ParseName(state)) {
719      return true;
720    }
721    state-&gt;parse_state = copy;
722    if (ParseTwoCharToken(state, &quot;GA&quot;) &amp;&amp; ParseEncoding(state)) {
723      return true;
724    }
725    state-&gt;parse_state = copy;
726    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseCharClass(state, &quot;hv&quot;) &amp;&amp;
727        ParseCallOffset(state) &amp;&amp; ParseEncoding(state)) {
728      return true;
729    }
730    state-&gt;parse_state = copy;
731    return false;
732  }
733  static bool ParseCallOffset(State *state) {
734    ComplexityGuard guard(state);
735    if (guard.IsTooComplex()) return false;
736    ParseState copy = state-&gt;parse_state;
737    if (ParseOneCharToken(state, &#x27;h&#x27;) &amp;&amp; ParseNVOffset(state) &amp;&amp;
738        ParseOneCharToken(state, &#x27;_&#x27;)) {
739      return true;
740    }
741    state-&gt;parse_state = copy;
742    if (ParseOneCharToken(state, &#x27;v&#x27;) &amp;&amp; ParseVOffset(state) &amp;&amp;
743        ParseOneCharToken(state, &#x27;_&#x27;)) {
744      return true;
745    }
746    state-&gt;parse_state = copy;
747    return false;
748  }
749  static bool ParseNVOffset(State *state) {
750    ComplexityGuard guard(state);
751    if (guard.IsTooComplex()) return false;
752    return ParseNumber(state, nullptr);
753  }
754  static bool ParseVOffset(State *state) {
755    ComplexityGuard guard(state);
756    if (guard.IsTooComplex()) return false;
757    ParseState copy = state-&gt;parse_state;
758    if (ParseNumber(state, nullptr) &amp;&amp; ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp;
759        ParseNumber(state, nullptr)) {
760      return true;
761    }
762    state-&gt;parse_state = copy;
763    return false;
764  }
765  static bool ParseCtorDtorName(State *state) {
766    ComplexityGuard guard(state);
767    if (guard.IsTooComplex()) return false;
768    ParseState copy = state-&gt;parse_state;
769    if (ParseOneCharToken(state, &#x27;C&#x27;)) {
770      if (ParseCharClass(state, &quot;1234&quot;)) {
771        const char *const prev_name =
772            state-&gt;out + state-&gt;parse_state.prev_name_idx;
<span onclick='openModal()' class='match'>773        MaybeAppendWithLength(state, prev_name,
774                              state-&gt;parse_state.prev_name_length);
775        return true;
776      } else if (ParseOneCharToken(state, &#x27;I&#x27;) &amp;&amp; ParseCharClass(state, &quot;12&quot;) &amp;&amp;
</span>777                 ParseClassEnumType(state)) {
778        return true;
779      }
780    }
781    state-&gt;parse_state = copy;
782    if (ParseOneCharToken(state, &#x27;D&#x27;) &amp;&amp; ParseCharClass(state, &quot;0124&quot;)) {
783      const char *const prev_name = state-&gt;out + state-&gt;parse_state.prev_name_idx;
784      MaybeAppend(state, &quot;~&quot;);
785      MaybeAppendWithLength(state, prev_name,
786                            state-&gt;parse_state.prev_name_length);
787      return true;
788    }
789    state-&gt;parse_state = copy;
790    return false;
791  }
792  static bool ParseDecltype(State *state) {
793    ComplexityGuard guard(state);
794    if (guard.IsTooComplex()) return false;
795    ParseState copy = state-&gt;parse_state;
796    if (ParseOneCharToken(state, &#x27;D&#x27;) &amp;&amp; ParseCharClass(state, &quot;tT&quot;) &amp;&amp;
797        ParseExpression(state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
798      return true;
799    }
800    state-&gt;parse_state = copy;
801    return false;
802  }
803  static bool ParseType(State *state) {
804    ComplexityGuard guard(state);
805    if (guard.IsTooComplex()) return false;
806    ParseState copy = state-&gt;parse_state;
807    if (ParseCVQualifiers(state)) {
808      const bool result = ParseType(state);
809      if (!result) state-&gt;parse_state = copy;
810      return result;
811    }
812    state-&gt;parse_state = copy;
813    if (ParseCharClass(state, &quot;OPRCG&quot;)) {
814      const bool result = ParseType(state);
815      if (!result) state-&gt;parse_state = copy;
816      return result;
817    }
818    state-&gt;parse_state = copy;
819    if (ParseTwoCharToken(state, &quot;Dp&quot;) &amp;&amp; ParseType(state)) {
820      return true;
821    }
822    state-&gt;parse_state = copy;
823    if (ParseOneCharToken(state, &#x27;U&#x27;) &amp;&amp; ParseSourceName(state) &amp;&amp;
824        ParseType(state)) {
825      return true;
826    }
827    state-&gt;parse_state = copy;
828    if (ParseBuiltinType(state) || ParseFunctionType(state) ||
829        ParseClassEnumType(state) || ParseArrayType(state) ||
830        ParsePointerToMemberType(state) || ParseDecltype(state) ||
831        ParseSubstitution(state, &amp;bsol;*accept_std=*/false)) {
832      return true;
833    }
834    if (ParseTemplateTemplateParam(state) &amp;&amp; ParseTemplateArgs(state)) {
835      return true;
836    }
837    state-&gt;parse_state = copy;
838    if (ParseTemplateParam(state)) {
839      return true;
840    }
841    if (ParseTwoCharToken(state, &quot;Dv&quot;) &amp;&amp; ParseNumber(state, nullptr) &amp;&amp;
842        ParseOneCharToken(state, &#x27;_&#x27;)) {
843      return true;
844    }
845    state-&gt;parse_state = copy;
846    return false;
847  }
848  static bool ParseCVQualifiers(State *state) {
849    ComplexityGuard guard(state);
850    if (guard.IsTooComplex()) return false;
851    int num_cv_qualifiers = 0;
852    num_cv_qualifiers += ParseOneCharToken(state, &#x27;r&#x27;);
853    num_cv_qualifiers += ParseOneCharToken(state, &#x27;V&#x27;);
854    num_cv_qualifiers += ParseOneCharToken(state, &#x27;K&#x27;);
855    return num_cv_qualifiers &gt; 0;
856  }
857  static bool ParseBuiltinType(State *state) {
858    ComplexityGuard guard(state);
859    if (guard.IsTooComplex()) return false;
860    const AbbrevPair *p;
861    for (p = kBuiltinTypeList; p-&gt;abbrev != nullptr; ++p) {
862      if (p-&gt;abbrev[1] == &#x27;\0&#x27;) {
863        if (ParseOneCharToken(state, p-&gt;abbrev[0])) {
864          MaybeAppend(state, p-&gt;real_name);
865          return true;
866        }
867      } else if (p-&gt;abbrev[2] == &#x27;\0&#x27; &amp;&amp; ParseTwoCharToken(state, p-&gt;abbrev)) {
868        MaybeAppend(state, p-&gt;real_name);
869        return true;
870      }
871    }
872    ParseState copy = state-&gt;parse_state;
873    if (ParseOneCharToken(state, &#x27;u&#x27;) &amp;&amp; ParseSourceName(state)) {
874      return true;
875    }
876    state-&gt;parse_state = copy;
877    return false;
878  }
879  static bool ParseExceptionSpec(State *state) {
880    ComplexityGuard guard(state);
881    if (guard.IsTooComplex()) return false;
882    if (ParseTwoCharToken(state, &quot;Do&quot;)) return true;
883    ParseState copy = state-&gt;parse_state;
884    if (ParseTwoCharToken(state, &quot;DO&quot;) &amp;&amp; ParseExpression(state) &amp;&amp;
885        ParseOneCharToken(state, &#x27;E&#x27;)) {
886      return true;
887    }
888    state-&gt;parse_state = copy;
889    if (ParseTwoCharToken(state, &quot;Dw&quot;) &amp;&amp; OneOrMore(ParseType, state) &amp;&amp;
890        ParseOneCharToken(state, &#x27;E&#x27;)) {
891      return true;
892    }
893    state-&gt;parse_state = copy;
894    return false;
895  }
896  static bool ParseFunctionType(State *state) {
897    ComplexityGuard guard(state);
898    if (guard.IsTooComplex()) return false;
899    ParseState copy = state-&gt;parse_state;
900    if (Optional(ParseExceptionSpec(state)) &amp;&amp; ParseOneCharToken(state, &#x27;F&#x27;) &amp;&amp;
901        Optional(ParseOneCharToken(state, &#x27;Y&#x27;)) &amp;&amp; ParseBareFunctionType(state) &amp;&amp;
902        Optional(ParseOneCharToken(state, &#x27;O&#x27;)) &amp;&amp;
903        ParseOneCharToken(state, &#x27;E&#x27;)) {
904      return true;
905    }
906    state-&gt;parse_state = copy;
907    return false;
908  }
909  static bool ParseBareFunctionType(State *state) {
910    ComplexityGuard guard(state);
911    if (guard.IsTooComplex()) return false;
912    ParseState copy = state-&gt;parse_state;
913    DisableAppend(state);
914    if (OneOrMore(ParseType, state)) {
915      RestoreAppend(state, copy.append);
916      MaybeAppend(state, &quot;()&quot;);
917      return true;
918    }
919    state-&gt;parse_state = copy;
920    return false;
921  }
922  static bool ParseClassEnumType(State *state) {
923    ComplexityGuard guard(state);
924    if (guard.IsTooComplex()) return false;
925    return ParseName(state);
926  }
927  static bool ParseArrayType(State *state) {
928    ComplexityGuard guard(state);
929    if (guard.IsTooComplex()) return false;
930    ParseState copy = state-&gt;parse_state;
931    if (ParseOneCharToken(state, &#x27;A&#x27;) &amp;&amp; ParseNumber(state, nullptr) &amp;&amp;
932        ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp; ParseType(state)) {
933      return true;
934    }
935    state-&gt;parse_state = copy;
936    if (ParseOneCharToken(state, &#x27;A&#x27;) &amp;&amp; Optional(ParseExpression(state)) &amp;&amp;
937        ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp; ParseType(state)) {
938      return true;
939    }
940    state-&gt;parse_state = copy;
941    return false;
942  }
943  static bool ParsePointerToMemberType(State *state) {
944    ComplexityGuard guard(state);
945    if (guard.IsTooComplex()) return false;
946    ParseState copy = state-&gt;parse_state;
947    if (ParseOneCharToken(state, &#x27;M&#x27;) &amp;&amp; ParseType(state) &amp;&amp; ParseType(state)) {
948      return true;
949    }
950    state-&gt;parse_state = copy;
951    return false;
952  }
953  static bool ParseTemplateParam(State *state) {
954    ComplexityGuard guard(state);
955    if (guard.IsTooComplex()) return false;
956    if (ParseTwoCharToken(state, &quot;T_&quot;)) {
957      MaybeAppend(state, &quot;?&quot;);  
958      return true;
959    }
960    ParseState copy = state-&gt;parse_state;
961    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseNumber(state, nullptr) &amp;&amp;
962        ParseOneCharToken(state, &#x27;_&#x27;)) {
963      MaybeAppend(state, &quot;?&quot;);  
964      return true;
965    }
966    state-&gt;parse_state = copy;
967    return false;
968  }
969  static bool ParseTemplateTemplateParam(State *state) {
970    ComplexityGuard guard(state);
971    if (guard.IsTooComplex()) return false;
972    return (ParseTemplateParam(state) ||
973            ParseSubstitution(state, &amp;bsol;*accept_std=*/false));
974  }
975  static bool ParseTemplateArgs(State *state) {
976    ComplexityGuard guard(state);
977    if (guard.IsTooComplex()) return false;
978    ParseState copy = state-&gt;parse_state;
979    DisableAppend(state);
980    if (ParseOneCharToken(state, &#x27;I&#x27;) &amp;&amp; OneOrMore(ParseTemplateArg, state) &amp;&amp;
981        ParseOneCharToken(state, &#x27;E&#x27;)) {
982      RestoreAppend(state, copy.append);
983      MaybeAppend(state, &quot;&lt;&gt;&quot;);
984      return true;
985    }
986    state-&gt;parse_state = copy;
987    return false;
988  }
989  static bool ParseTemplateArg(State *state) {
990    ComplexityGuard guard(state);
991    if (guard.IsTooComplex()) return false;
992    ParseState copy = state-&gt;parse_state;
993    if (ParseOneCharToken(state, &#x27;J&#x27;) &amp;&amp; ZeroOrMore(ParseTemplateArg, state) &amp;&amp;
994        ParseOneCharToken(state, &#x27;E&#x27;)) {
995      return true;
996    }
997    state-&gt;parse_state = copy;
998    if (ParseLocalSourceName(state) &amp;&amp; Optional(ParseTemplateArgs(state))) {
999      copy = state-&gt;parse_state;
1000      if (ParseExprCastValue(state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1001        return true;
1002      }
1003      state-&gt;parse_state = copy;
1004      return true;
1005    }
1006    if (ParseType(state) || ParseExprPrimary(state)) {
1007      return true;
1008    }
1009    state-&gt;parse_state = copy;
1010    if (ParseOneCharToken(state, &#x27;X&#x27;) &amp;&amp; ParseExpression(state) &amp;&amp;
1011        ParseOneCharToken(state, &#x27;E&#x27;)) {
1012      return true;
1013    }
1014    state-&gt;parse_state = copy;
1015    return false;
1016  }
1017  static inline bool ParseUnresolvedType(State *state) {
1018    return (ParseTemplateParam(state) &amp;&amp; Optional(ParseTemplateArgs(state))) ||
1019           ParseDecltype(state) || ParseSubstitution(state, &amp;bsol;*accept_std=*/false);
1020  }
1021  static inline bool ParseSimpleId(State *state) {
1022    return ParseSourceName(state) &amp;&amp; Optional(ParseTemplateArgs(state));
1023  }
1024  static bool ParseBaseUnresolvedName(State *state) {
1025    ComplexityGuard guard(state);
1026    if (guard.IsTooComplex()) return false;
1027    if (ParseSimpleId(state)) {
1028      return true;
1029    }
1030    ParseState copy = state-&gt;parse_state;
1031    if (ParseTwoCharToken(state, &quot;on&quot;) &amp;&amp; ParseOperatorName(state, nullptr) &amp;&amp;
1032        Optional(ParseTemplateArgs(state))) {
1033      return true;
1034    }
1035    state-&gt;parse_state = copy;
1036    if (ParseTwoCharToken(state, &quot;dn&quot;) &amp;&amp;
1037        (ParseUnresolvedType(state) || ParseSimpleId(state))) {
1038      return true;
1039    }
1040    state-&gt;parse_state = copy;
1041    return false;
1042  }
1043  static bool ParseUnresolvedName(State *state) {
1044    ComplexityGuard guard(state);
1045    if (guard.IsTooComplex()) return false;
1046    ParseState copy = state-&gt;parse_state;
1047    if (Optional(ParseTwoCharToken(state, &quot;gs&quot;)) &amp;&amp;
1048        ParseBaseUnresolvedName(state)) {
1049      return true;
1050    }
1051    state-&gt;parse_state = copy;
1052    if (ParseTwoCharToken(state, &quot;sr&quot;) &amp;&amp; ParseUnresolvedType(state) &amp;&amp;
1053        ParseBaseUnresolvedName(state)) {
1054      return true;
1055    }
1056    state-&gt;parse_state = copy;
1057    if (ParseTwoCharToken(state, &quot;sr&quot;) &amp;&amp; ParseOneCharToken(state, &#x27;N&#x27;) &amp;&amp;
1058        ParseUnresolvedType(state) &amp;&amp;
1059        OneOrMore(&amp;bsol;* &lt;unresolved-qualifier-level&gt; ::= */ ParseSimpleId, state) &amp;&amp;
1060        ParseOneCharToken(state, &#x27;E&#x27;) &amp;&amp; ParseBaseUnresolvedName(state)) {
1061      return true;
1062    }
1063    state-&gt;parse_state = copy;
1064    if (Optional(ParseTwoCharToken(state, &quot;gs&quot;)) &amp;&amp;
1065        ParseTwoCharToken(state, &quot;sr&quot;) &amp;&amp;
1066        OneOrMore(&amp;bsol;* &lt;unresolved-qualifier-level&gt; ::= */ ParseSimpleId, state) &amp;&amp;
1067        ParseOneCharToken(state, &#x27;E&#x27;) &amp;&amp; ParseBaseUnresolvedName(state)) {
1068      return true;
1069    }
1070    state-&gt;parse_state = copy;
1071    return false;
1072  }
1073  static bool ParseExpression(State *state) {
1074    ComplexityGuard guard(state);
1075    if (guard.IsTooComplex()) return false;
1076    if (ParseTemplateParam(state) || ParseExprPrimary(state)) {
1077      return true;
1078    }
1079    ParseState copy = state-&gt;parse_state;
1080    if (ParseTwoCharToken(state, &quot;cl&quot;) &amp;&amp; OneOrMore(ParseExpression, state) &amp;&amp;
1081        ParseOneCharToken(state, &#x27;E&#x27;)) {
1082      return true;
1083    }
1084    state-&gt;parse_state = copy;
1085    if (ParseTwoCharToken(state, &quot;cp&quot;) &amp;&amp; ParseSimpleId(state) &amp;&amp;
1086        ZeroOrMore(ParseExpression, state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1087      return true;
1088    }
1089    state-&gt;parse_state = copy;
1090    if (ParseTwoCharToken(state, &quot;fp&quot;) &amp;&amp; Optional(ParseCVQualifiers(state)) &amp;&amp;
1091        Optional(ParseNumber(state, nullptr)) &amp;&amp; ParseOneCharToken(state, &#x27;_&#x27;)) {
1092      return true;
1093    }
1094    state-&gt;parse_state = copy;
1095    if (ParseTwoCharToken(state, &quot;fL&quot;) &amp;&amp; Optional(ParseNumber(state, nullptr)) &amp;&amp;
1096        ParseOneCharToken(state, &#x27;p&#x27;) &amp;&amp; Optional(ParseCVQualifiers(state)) &amp;&amp;
1097        Optional(ParseNumber(state, nullptr)) &amp;&amp; ParseOneCharToken(state, &#x27;_&#x27;)) {
1098      return true;
1099    }
1100    state-&gt;parse_state = copy;
1101    if (ParseTwoCharToken(state, &quot;cv&quot;)) {
1102      if (ParseType(state)) {
1103        ParseState copy2 = state-&gt;parse_state;
1104        if (ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp; ZeroOrMore(ParseExpression, state) &amp;&amp;
1105            ParseOneCharToken(state, &#x27;E&#x27;)) {
1106          return true;
1107        }
1108        state-&gt;parse_state = copy2;
1109        if (ParseExpression(state)) {
1110          return true;
1111        }
1112      }
1113    } else {
1114      int arity = -1;
1115      if (ParseOperatorName(state, &amp;arity) &amp;&amp;
1116          arity &gt; 0 &amp;&amp;  
1117          (arity &lt; 3 || ParseExpression(state)) &amp;&amp;
1118          (arity &lt; 2 || ParseExpression(state)) &amp;&amp;
1119          (arity &lt; 1 || ParseExpression(state))) {
1120        return true;
1121      }
1122    }
1123    state-&gt;parse_state = copy;
1124    if (ParseTwoCharToken(state, &quot;st&quot;) &amp;&amp; ParseType(state)) {
1125      return true;
1126    }
1127    state-&gt;parse_state = copy;
1128    if ((ParseTwoCharToken(state, &quot;dt&quot;) || ParseTwoCharToken(state, &quot;pt&quot;)) &amp;&amp;
1129        ParseExpression(state) &amp;&amp; ParseType(state)) {
1130      return true;
1131    }
1132    state-&gt;parse_state = copy;
1133    if (ParseTwoCharToken(state, &quot;ds&quot;) &amp;&amp; ParseExpression(state) &amp;&amp;
1134        ParseExpression(state)) {
1135      return true;
1136    }
1137    state-&gt;parse_state = copy;
1138    if (ParseTwoCharToken(state, &quot;sp&quot;) &amp;&amp; ParseExpression(state)) {
1139      return true;
1140    }
1141    state-&gt;parse_state = copy;
1142    return ParseUnresolvedName(state);
1143  }
1144  static bool ParseExprPrimary(State *state) {
1145    ComplexityGuard guard(state);
1146    if (guard.IsTooComplex()) return false;
1147    ParseState copy = state-&gt;parse_state;
1148    if (ParseTwoCharToken(state, &quot;LZ&quot;)) {
1149      if (ParseEncoding(state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1150        return true;
1151      }
1152      state-&gt;parse_state = copy;
1153      return false;
1154    }
1155    if (ParseOneCharToken(state, &#x27;L&#x27;) &amp;&amp; ParseType(state) &amp;&amp;
1156        ParseExprCastValue(state)) {
1157      return true;
1158    }
1159    state-&gt;parse_state = copy;
1160    if (ParseOneCharToken(state, &#x27;L&#x27;) &amp;&amp; ParseMangledName(state) &amp;&amp;
1161        ParseOneCharToken(state, &#x27;E&#x27;)) {
1162      return true;
1163    }
1164    state-&gt;parse_state = copy;
1165    return false;
1166  }
1167  static bool ParseExprCastValue(State *state) {
1168    ComplexityGuard guard(state);
1169    if (guard.IsTooComplex()) return false;
1170    ParseState copy = state-&gt;parse_state;
1171    if (ParseNumber(state, nullptr) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1172      return true;
1173    }
1174    state-&gt;parse_state = copy;
1175    if (ParseFloatNumber(state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1176      return true;
1177    }
1178    state-&gt;parse_state = copy;
1179    return false;
1180  }
1181  static bool ParseLocalNameSuffix(State *state) {
1182    ComplexityGuard guard(state);
1183    if (guard.IsTooComplex()) return false;
1184    if (MaybeAppend(state, &quot;::&quot;) &amp;&amp; ParseName(state) &amp;&amp;
1185        Optional(ParseDiscriminator(state))) {
1186      return true;
1187    }
1188    if (state-&gt;parse_state.append) {
1189      state-&gt;out[state-&gt;parse_state.out_cur_idx - 2] = &#x27;\0&#x27;;
1190    }
1191    return ParseOneCharToken(state, &#x27;s&#x27;) &amp;&amp; Optional(ParseDiscriminator(state));
1192  }
1193  static bool ParseLocalName(State *state) {
1194    ComplexityGuard guard(state);
1195    if (guard.IsTooComplex()) return false;
1196    ParseState copy = state-&gt;parse_state;
1197    if (ParseOneCharToken(state, &#x27;Z&#x27;) &amp;&amp; ParseEncoding(state) &amp;&amp;
1198        ParseOneCharToken(state, &#x27;E&#x27;) &amp;&amp; ParseLocalNameSuffix(state)) {
1199      return true;
1200    }
1201    state-&gt;parse_state = copy;
1202    return false;
1203  }
1204  static bool ParseDiscriminator(State *state) {
1205    ComplexityGuard guard(state);
1206    if (guard.IsTooComplex()) return false;
1207    ParseState copy = state-&gt;parse_state;
1208    if (ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp; ParseNumber(state, nullptr)) {
1209      return true;
1210    }
1211    state-&gt;parse_state = copy;
1212    return false;
1213  }
1214  static bool ParseSubstitution(State *state, bool accept_std) {
1215    ComplexityGuard guard(state);
1216    if (guard.IsTooComplex()) return false;
1217    if (ParseTwoCharToken(state, &quot;S_&quot;)) {
1218      MaybeAppend(state, &quot;?&quot;);  
1219      return true;
1220    }
1221    ParseState copy = state-&gt;parse_state;
1222    if (ParseOneCharToken(state, &#x27;S&#x27;) &amp;&amp; ParseSeqId(state) &amp;&amp;
1223        ParseOneCharToken(state, &#x27;_&#x27;)) {
1224      MaybeAppend(state, &quot;?&quot;);  
1225      return true;
1226    }
1227    state-&gt;parse_state = copy;
1228    if (ParseOneCharToken(state, &#x27;S&#x27;)) {
1229      const AbbrevPair *p;
1230      for (p = kSubstitutionList; p-&gt;abbrev != nullptr; ++p) {
1231        if (RemainingInput(state)[0] == p-&gt;abbrev[1] &amp;&amp;
1232            (accept_std || p-&gt;abbrev[1] != &#x27;t&#x27;)) {
1233          MaybeAppend(state, &quot;std&quot;);
1234          if (p-&gt;real_name[0] != &#x27;\0&#x27;) {
1235            MaybeAppend(state, &quot;::&quot;);
1236            MaybeAppend(state, p-&gt;real_name);
1237          }
1238          ++state-&gt;parse_state.mangled_idx;
1239          return true;
1240        }
1241      }
1242    }
1243    state-&gt;parse_state = copy;
1244    return false;
1245  }
1246  static bool ParseTopLevelMangledName(State *state) {
1247    ComplexityGuard guard(state);
1248    if (guard.IsTooComplex()) return false;
1249    if (ParseMangledName(state)) {
1250      if (RemainingInput(state)[0] != &#x27;\0&#x27;) {
1251        if (IsFunctionCloneSuffix(RemainingInput(state))) {
1252          return true;
1253        }
1254        if (RemainingInput(state)[0] == &#x27;@&#x27;) {
1255          MaybeAppend(state, RemainingInput(state));
1256          return true;
1257        }
1258        return false;  
1259      }
1260      return true;
1261    }
1262    return false;
1263  }
1264  static bool Overflowed(const State *state) {
1265    return state-&gt;parse_state.out_cur_idx &gt;= state-&gt;out_end_idx;
1266  }
1267  bool Demangle(const char* mangled, char* out, size_t out_size) {
1268    State state;
1269    InitState(&amp;state, mangled, out, out_size);
1270    return ParseTopLevelMangledName(&amp;state) &amp;&amp; !Overflowed(&amp;state) &amp;&amp;
1271           state.parse_state.out_cur_idx &gt; 0;
1272  }
1273  }  
1274  ABSL_NAMESPACE_END
1275  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-demangle.cc</h3>
            <pre><code>1  #include &quot;absl/debugging/internal/demangle.h&quot;
2  #include &lt;cstdint&gt;
3  #include &lt;cstdio&gt;
4  #include &lt;limits&gt;
5  namespace absl {
6  ABSL_NAMESPACE_BEGIN
7  namespace debugging_internal {
8  typedef struct {
9    const char *abbrev;
10    const char *real_name;
11    int arity;
12  } AbbrevPair;
13  static const AbbrevPair kOperatorList[] = {
14      {&quot;nw&quot;, &quot;new&quot;, 0},
15      {&quot;na&quot;, &quot;new[]&quot;, 0},
16      {&quot;dl&quot;, &quot;delete&quot;, 1},
17      {&quot;da&quot;, &quot;delete[]&quot;, 1},
18      {&quot;ps&quot;, &quot;+&quot;, 1},  
19      {&quot;ng&quot;, &quot;-&quot;, 1},  
20      {&quot;ad&quot;, &quot;&amp;&quot;, 1},  
21      {&quot;de&quot;, &quot;*&quot;, 1},  
22      {&quot;co&quot;, &quot;~&quot;, 1},
23      {&quot;pl&quot;, &quot;+&quot;, 2},
24      {&quot;mi&quot;, &quot;-&quot;, 2},
25      {&quot;ml&quot;, &quot;*&quot;, 2},
26      {&quot;dv&quot;, &quot;/&quot;, 2},
27      {&quot;rm&quot;, &quot;%&quot;, 2},
28      {&quot;an&quot;, &quot;&amp;&quot;, 2},
29      {&quot;or&quot;, &quot;|&quot;, 2},
30      {&quot;eo&quot;, &quot;^&quot;, 2},
31      {&quot;aS&quot;, &quot;=&quot;, 2},
32      {&quot;pL&quot;, &quot;+=&quot;, 2},
33      {&quot;mI&quot;, &quot;-=&quot;, 2},
34      {&quot;mL&quot;, &quot;*=&quot;, 2},
35      {&quot;dV&quot;, &quot;/=&quot;, 2},
36      {&quot;rM&quot;, &quot;%=&quot;, 2},
37      {&quot;aN&quot;, &quot;&amp;=&quot;, 2},
38      {&quot;oR&quot;, &quot;|=&quot;, 2},
39      {&quot;eO&quot;, &quot;^=&quot;, 2},
40      {&quot;ls&quot;, &quot;&lt;&lt;&quot;, 2},
41      {&quot;rs&quot;, &quot;&gt;&gt;&quot;, 2},
42      {&quot;lS&quot;, &quot;&lt;&lt;=&quot;, 2},
43      {&quot;rS&quot;, &quot;&gt;&gt;=&quot;, 2},
44      {&quot;eq&quot;, &quot;==&quot;, 2},
45      {&quot;ne&quot;, &quot;!=&quot;, 2},
46      {&quot;lt&quot;, &quot;&lt;&quot;, 2},
47      {&quot;gt&quot;, &quot;&gt;&quot;, 2},
48      {&quot;le&quot;, &quot;&lt;=&quot;, 2},
49      {&quot;ge&quot;, &quot;&gt;=&quot;, 2},
50      {&quot;nt&quot;, &quot;!&quot;, 1},
51      {&quot;aa&quot;, &quot;&amp;&amp;&quot;, 2},
52      {&quot;oo&quot;, &quot;||&quot;, 2},
53      {&quot;pp&quot;, &quot;++&quot;, 1},
54      {&quot;mm&quot;, &quot;--&quot;, 1},
55      {&quot;cm&quot;, &quot;,&quot;, 2},
56      {&quot;pm&quot;, &quot;-&gt;*&quot;, 2},
57      {&quot;pt&quot;, &quot;-&gt;&quot;, 0},  
58      {&quot;cl&quot;, &quot;()&quot;, 0},  
59      {&quot;ix&quot;, &quot;[]&quot;, 2},
60      {&quot;qu&quot;, &quot;?&quot;, 3},
61      {&quot;st&quot;, &quot;sizeof&quot;, 0},  
62      {&quot;sz&quot;, &quot;sizeof&quot;, 1},  
63      {nullptr, nullptr, 0},
64  };
65  static const AbbrevPair kBuiltinTypeList[] = {
66      {&quot;v&quot;, &quot;void&quot;, 0},
67      {&quot;w&quot;, &quot;wchar_t&quot;, 0},
68      {&quot;b&quot;, &quot;bool&quot;, 0},
69      {&quot;c&quot;, &quot;char&quot;, 0},
70      {&quot;a&quot;, &quot;signed char&quot;, 0},
71      {&quot;h&quot;, &quot;unsigned char&quot;, 0},
72      {&quot;s&quot;, &quot;short&quot;, 0},
73      {&quot;t&quot;, &quot;unsigned short&quot;, 0},
74      {&quot;i&quot;, &quot;int&quot;, 0},
75      {&quot;j&quot;, &quot;unsigned int&quot;, 0},
76      {&quot;l&quot;, &quot;long&quot;, 0},
77      {&quot;m&quot;, &quot;unsigned long&quot;, 0},
78      {&quot;x&quot;, &quot;long long&quot;, 0},
79      {&quot;y&quot;, &quot;unsigned long long&quot;, 0},
80      {&quot;n&quot;, &quot;__int128&quot;, 0},
81      {&quot;o&quot;, &quot;unsigned __int128&quot;, 0},
82      {&quot;f&quot;, &quot;float&quot;, 0},
83      {&quot;d&quot;, &quot;double&quot;, 0},
84      {&quot;e&quot;, &quot;long double&quot;, 0},
85      {&quot;g&quot;, &quot;__float128&quot;, 0},
86      {&quot;z&quot;, &quot;ellipsis&quot;, 0},
87      {&quot;De&quot;, &quot;decimal128&quot;, 0},      
88      {&quot;Dd&quot;, &quot;decimal64&quot;, 0},       
89      {&quot;Dc&quot;, &quot;decltype(auto)&quot;, 0},
90      {&quot;Da&quot;, &quot;auto&quot;, 0},
91      {&quot;Dn&quot;, &quot;std::nullptr_t&quot;, 0},  
92      {&quot;Df&quot;, &quot;decimal32&quot;, 0},       
93      {&quot;Di&quot;, &quot;char32_t&quot;, 0},
94      {&quot;Du&quot;, &quot;char8_t&quot;, 0},
95      {&quot;Ds&quot;, &quot;char16_t&quot;, 0},
96      {&quot;Dh&quot;, &quot;float16&quot;, 0},         
97      {nullptr, nullptr, 0},
98  };
99  static const AbbrevPair kSubstitutionList[] = {
100      {&quot;St&quot;, &quot;&quot;, 0},
101      {&quot;Sa&quot;, &quot;allocator&quot;, 0},
102      {&quot;Sb&quot;, &quot;basic_string&quot;, 0},
103      {&quot;Ss&quot;, &quot;string&quot;, 0},
104      {&quot;Si&quot;, &quot;istream&quot;, 0},
105      {&quot;So&quot;, &quot;ostream&quot;, 0},
106      {&quot;Sd&quot;, &quot;iostream&quot;, 0},
107      {nullptr, nullptr, 0},
108  };
109  typedef struct {
110    int mangled_idx;                     
111    int out_cur_idx;                     
112    int prev_name_idx;                   
113    unsigned int prev_name_length : 16;  
114    signed int nest_level : 15;          
115    unsigned int append : 1;             
116  } ParseState;
117  static_assert(sizeof(ParseState) == 4 * sizeof(int),
118                &quot;unexpected size of ParseState&quot;);
119  typedef struct {
120    const char *mangled_begin;  
121    char *out;                  
122    int out_end_idx;            
123    int recursion_depth;        
124    int steps;               
125    ParseState parse_state;  
126  } State;
127  namespace {
128  class ComplexityGuard {
129   public:
130    explicit ComplexityGuard(State *state) : state_(state) {
131      ++state-&gt;recursion_depth;
132      ++state-&gt;steps;
133    }
134    ~ComplexityGuard() { --state_-&gt;recursion_depth; }
135    static constexpr int kRecursionDepthLimit = 256;
136    static constexpr int kParseStepsLimit = 1 &lt;&lt; 17;
137    bool IsTooComplex() const {
138      return state_-&gt;recursion_depth &gt; kRecursionDepthLimit ||
139             state_-&gt;steps &gt; kParseStepsLimit;
140    }
141   private:
142    State *state_;
143  };
144  }  
145  static size_t StrLen(const char *str) {
146    size_t len = 0;
147    while (*str != &#x27;\0&#x27;) {
148      ++str;
149      ++len;
150    }
151    return len;
152  }
153  static bool AtLeastNumCharsRemaining(const char *str, size_t n) {
154    for (size_t i = 0; i &lt; n; ++i) {
155      if (str[i] == &#x27;\0&#x27;) {
156        return false;
157      }
158    }
159    return true;
160  }
161  static bool StrPrefix(const char *str, const char *prefix) {
162    size_t i = 0;
163    while (str[i] != &#x27;\0&#x27; &amp;&amp; prefix[i] != &#x27;\0&#x27; &amp;&amp; str[i] == prefix[i]) {
164      ++i;
165    }
166    return prefix[i] == &#x27;\0&#x27;;  
167  }
168  static void InitState(State* state,
169                        const char* mangled,
170                        char* out,
171                        size_t out_size) {
172    state-&gt;mangled_begin = mangled;
173    state-&gt;out = out;
174    state-&gt;out_end_idx = static_cast&lt;int&gt;(out_size);
175    state-&gt;recursion_depth = 0;
176    state-&gt;steps = 0;
177    state-&gt;parse_state.mangled_idx = 0;
178    state-&gt;parse_state.out_cur_idx = 0;
179    state-&gt;parse_state.prev_name_idx = 0;
180    state-&gt;parse_state.prev_name_length = 0;
181    state-&gt;parse_state.nest_level = -1;
182    state-&gt;parse_state.append = true;
183  }
184  static inline const char *RemainingInput(State *state) {
185    return &amp;state-&gt;mangled_begin[state-&gt;parse_state.mangled_idx];
186  }
187  static bool ParseOneCharToken(State *state, const char one_char_token) {
188    ComplexityGuard guard(state);
189    if (guard.IsTooComplex()) return false;
190    if (RemainingInput(state)[0] == one_char_token) {
191      ++state-&gt;parse_state.mangled_idx;
192      return true;
193    }
194    return false;
195  }
196  static bool ParseTwoCharToken(State *state, const char *two_char_token) {
197    ComplexityGuard guard(state);
198    if (guard.IsTooComplex()) return false;
199    if (RemainingInput(state)[0] == two_char_token[0] &amp;&amp;
200        RemainingInput(state)[1] == two_char_token[1]) {
201      state-&gt;parse_state.mangled_idx += 2;
202      return true;
203    }
204    return false;
205  }
206  static bool ParseCharClass(State *state, const char *char_class) {
207    ComplexityGuard guard(state);
208    if (guard.IsTooComplex()) return false;
209    if (RemainingInput(state)[0] == &#x27;\0&#x27;) {
210      return false;
211    }
212    const char *p = char_class;
213    for (; *p != &#x27;\0&#x27;; ++p) {
214      if (RemainingInput(state)[0] == *p) {
215        ++state-&gt;parse_state.mangled_idx;
216        return true;
217      }
218    }
219    return false;
220  }
221  static bool ParseDigit(State *state, int *digit) {
222    char c = RemainingInput(state)[0];
223    if (ParseCharClass(state, &quot;0123456789&quot;)) {
224      if (digit != nullptr) {
225        *digit = c - &#x27;0&#x27;;
226      }
227      return true;
228    }
229    return false;
230  }
231  static bool Optional(bool &amp;bsol;*status*/) { return true; }
232  typedef bool (*ParseFunc)(State *);
233  static bool OneOrMore(ParseFunc parse_func, State *state) {
234    if (parse_func(state)) {
235      while (parse_func(state)) {
236      }
237      return true;
238    }
239    return false;
240  }
241  static bool ZeroOrMore(ParseFunc parse_func, State *state) {
242    while (parse_func(state)) {
243    }
244    return true;
245  }
246  static void Append(State *state, const char *const str, const size_t length) {
247    for (size_t i = 0; i &lt; length; ++i) {
248      if (state-&gt;parse_state.out_cur_idx + 1 &lt;
249          state-&gt;out_end_idx) {  
250        state-&gt;out[state-&gt;parse_state.out_cur_idx++] = str[i];
251      } else {
252        state-&gt;parse_state.out_cur_idx = state-&gt;out_end_idx + 1;
253        break;
254      }
255    }
256    if (state-&gt;parse_state.out_cur_idx &lt; state-&gt;out_end_idx) {
257      state-&gt;out[state-&gt;parse_state.out_cur_idx] =
258          &#x27;\0&#x27;;  
259    }
260  }
261  static bool IsLower(char c) { return c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;; }
262  static bool IsAlpha(char c) {
263    return (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) || (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;);
264  }
265  static bool IsDigit(char c) { return c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; }
266  static bool IsFunctionCloneSuffix(const char *str) {
267    size_t i = 0;
268    while (str[i] != &#x27;\0&#x27;) {
269      bool parsed = false;
270      if (str[i] == &#x27;.&#x27; &amp;&amp; (IsAlpha(str[i + 1]) || str[i + 1] == &#x27;_&#x27;)) {
271        parsed = true;
272        i += 2;
273        while (IsAlpha(str[i]) || str[i] == &#x27;_&#x27;) {
274          ++i;
275        }
276      }
277      if (str[i] == &#x27;.&#x27; &amp;&amp; IsDigit(str[i + 1])) {
278        parsed = true;
279        i += 2;
280        while (IsDigit(str[i])) {
281          ++i;
282        }
283      }
284      if (!parsed)
285        return false;
286    }
287    return true;  
288  }
289  static bool EndsWith(State *state, const char chr) {
290    return state-&gt;parse_state.out_cur_idx &gt; 0 &amp;&amp;
291           state-&gt;parse_state.out_cur_idx &lt; state-&gt;out_end_idx &amp;&amp;
292           chr == state-&gt;out[state-&gt;parse_state.out_cur_idx - 1];
293  }
294  static void MaybeAppendWithLength(State *state, const char *const str,
295                                    const size_t length) {
296    if (state-&gt;parse_state.append &amp;&amp; length &gt; 0) {
297      if (str[0] == &#x27;&lt;&#x27; &amp;&amp; EndsWith(state, &#x27;&lt;&#x27;)) {
298        Append(state, &quot; &quot;, 1);
299      }
300      if (state-&gt;parse_state.out_cur_idx &lt; state-&gt;out_end_idx &amp;&amp;
301          (IsAlpha(str[0]) || str[0] == &#x27;_&#x27;)) {
302        state-&gt;parse_state.prev_name_idx = state-&gt;parse_state.out_cur_idx;
303        state-&gt;parse_state.prev_name_length = static_cast&lt;unsigned int&gt;(length);
304      }
305      Append(state, str, length);
306    }
307  }
308  static bool MaybeAppendDecimal(State *state, int val) {
309    constexpr size_t kMaxLength = 20;
310    char buf[kMaxLength];
311    if (state-&gt;parse_state.append) {
312      char *p = &amp;buf[kMaxLength];
313      do {  
314        *--p = static_cast&lt;char&gt;((val % 10) + &#x27;0&#x27;);
315        val /= 10;
316      } while (p &gt; buf &amp;&amp; val != 0);
317      Append(state, p, kMaxLength - static_cast&lt;size_t&gt;(p - buf));
318    }
319    return true;
320  }
321  static bool MaybeAppend(State *state, const char *const str) {
322    if (state-&gt;parse_state.append) {
323      size_t length = StrLen(str);
324      MaybeAppendWithLength(state, str, length);
325    }
326    return true;
327  }
328  static bool EnterNestedName(State *state) {
329    state-&gt;parse_state.nest_level = 0;
330    return true;
331  }
332  static bool LeaveNestedName(State *state, int16_t prev_value) {
333    state-&gt;parse_state.nest_level = prev_value;
334    return true;
335  }
336  static bool DisableAppend(State *state) {
337    state-&gt;parse_state.append = false;
338    return true;
339  }
340  static bool RestoreAppend(State *state, bool prev_value) {
341    state-&gt;parse_state.append = prev_value;
342    return true;
343  }
344  static void MaybeIncreaseNestLevel(State *state) {
345    if (state-&gt;parse_state.nest_level &gt; -1) {
346      ++state-&gt;parse_state.nest_level;
347    }
348  }
349  static void MaybeAppendSeparator(State *state) {
350    if (state-&gt;parse_state.nest_level &gt;= 1) {
351      MaybeAppend(state, &quot;::&quot;);
352    }
353  }
354  static void MaybeCancelLastSeparator(State *state) {
355    if (state-&gt;parse_state.nest_level &gt;= 1 &amp;&amp; state-&gt;parse_state.append &amp;&amp;
356        state-&gt;parse_state.out_cur_idx &gt;= 2) {
357      state-&gt;parse_state.out_cur_idx -= 2;
358      state-&gt;out[state-&gt;parse_state.out_cur_idx] = &#x27;\0&#x27;;
359    }
360  }
361  static bool IdentifierIsAnonymousNamespace(State *state, size_t length) {
362    static const char anon_prefix[] = &quot;_GLOBAL__N_&quot;;
363    return (length &gt; (sizeof(anon_prefix) - 1) &amp;&amp;
364            StrPrefix(RemainingInput(state), anon_prefix));
365  }
366  static bool ParseMangledName(State *state);
367  static bool ParseEncoding(State *state);
368  static bool ParseName(State *state);
369  static bool ParseUnscopedName(State *state);
370  static bool ParseNestedName(State *state);
371  static bool ParsePrefix(State *state);
372  static bool ParseUnqualifiedName(State *state);
373  static bool ParseSourceName(State *state);
374  static bool ParseLocalSourceName(State *state);
375  static bool ParseUnnamedTypeName(State *state);
376  static bool ParseNumber(State *state, int *number_out);
377  static bool ParseFloatNumber(State *state);
378  static bool ParseSeqId(State *state);
379  static bool ParseIdentifier(State *state, size_t length);
380  static bool ParseOperatorName(State *state, int *arity);
381  static bool ParseSpecialName(State *state);
382  static bool ParseCallOffset(State *state);
383  static bool ParseNVOffset(State *state);
384  static bool ParseVOffset(State *state);
385  static bool ParseAbiTags(State *state);
386  static bool ParseCtorDtorName(State *state);
387  static bool ParseDecltype(State *state);
388  static bool ParseType(State *state);
389  static bool ParseCVQualifiers(State *state);
390  static bool ParseBuiltinType(State *state);
391  static bool ParseFunctionType(State *state);
392  static bool ParseBareFunctionType(State *state);
393  static bool ParseClassEnumType(State *state);
394  static bool ParseArrayType(State *state);
395  static bool ParsePointerToMemberType(State *state);
396  static bool ParseTemplateParam(State *state);
397  static bool ParseTemplateTemplateParam(State *state);
398  static bool ParseTemplateArgs(State *state);
399  static bool ParseTemplateArg(State *state);
400  static bool ParseBaseUnresolvedName(State *state);
401  static bool ParseUnresolvedName(State *state);
402  static bool ParseExpression(State *state);
403  static bool ParseExprPrimary(State *state);
404  static bool ParseExprCastValue(State *state);
405  static bool ParseLocalName(State *state);
406  static bool ParseLocalNameSuffix(State *state);
407  static bool ParseDiscriminator(State *state);
408  static bool ParseSubstitution(State *state, bool accept_std);
409  static bool ParseMangledName(State *state) {
410    ComplexityGuard guard(state);
411    if (guard.IsTooComplex()) return false;
412    return ParseTwoCharToken(state, &quot;_Z&quot;) &amp;&amp; ParseEncoding(state);
413  }
414  static bool ParseEncoding(State *state) {
415    ComplexityGuard guard(state);
416    if (guard.IsTooComplex()) return false;
417    if (ParseName(state) &amp;&amp; Optional(ParseBareFunctionType(state))) {
418      return true;
419    }
420    if (ParseSpecialName(state)) {
421      return true;
422    }
423    return false;
424  }
425  static bool ParseName(State *state) {
426    ComplexityGuard guard(state);
427    if (guard.IsTooComplex()) return false;
428    if (ParseNestedName(state) || ParseLocalName(state)) {
429      return true;
430    }
431    ParseState copy = state-&gt;parse_state;
432    if (ParseSubstitution(state, &amp;bsol;*accept_std=*/false) &amp;&amp;
433        ParseTemplateArgs(state)) {
434      return true;
435    }
436    state-&gt;parse_state = copy;
437    return ParseUnscopedName(state) &amp;&amp; Optional(ParseTemplateArgs(state));
438  }
439  static bool ParseUnscopedName(State *state) {
440    ComplexityGuard guard(state);
441    if (guard.IsTooComplex()) return false;
442    if (ParseUnqualifiedName(state)) {
443      return true;
444    }
445    ParseState copy = state-&gt;parse_state;
446    if (ParseTwoCharToken(state, &quot;St&quot;) &amp;&amp; MaybeAppend(state, &quot;std::&quot;) &amp;&amp;
447        ParseUnqualifiedName(state)) {
448      return true;
449    }
450    state-&gt;parse_state = copy;
451    return false;
452  }
453  static inline bool ParseRefQualifier(State *state) {
454    return ParseCharClass(state, &quot;OR&quot;);
455  }
456  static bool ParseNestedName(State *state) {
457    ComplexityGuard guard(state);
458    if (guard.IsTooComplex()) return false;
459    ParseState copy = state-&gt;parse_state;
460    if (ParseOneCharToken(state, &#x27;N&#x27;) &amp;&amp; EnterNestedName(state) &amp;&amp;
461        Optional(ParseCVQualifiers(state)) &amp;&amp;
462        Optional(ParseRefQualifier(state)) &amp;&amp; ParsePrefix(state) &amp;&amp;
463        LeaveNestedName(state, copy.nest_level) &amp;&amp;
464        ParseOneCharToken(state, &#x27;E&#x27;)) {
465      return true;
466    }
467    state-&gt;parse_state = copy;
468    return false;
469  }
470  static bool ParsePrefix(State *state) {
471    ComplexityGuard guard(state);
472    if (guard.IsTooComplex()) return false;
473    bool has_something = false;
474    while (true) {
475      MaybeAppendSeparator(state);
476      if (ParseTemplateParam(state) ||
477          ParseSubstitution(state, &amp;bsol;*accept_std=*/true) ||
478          ParseUnscopedName(state) ||
479          (ParseOneCharToken(state, &#x27;M&#x27;) &amp;&amp; ParseUnnamedTypeName(state))) {
480        has_something = true;
481        MaybeIncreaseNestLevel(state);
482        continue;
483      }
484      MaybeCancelLastSeparator(state);
485      if (has_something &amp;&amp; ParseTemplateArgs(state)) {
486        return ParsePrefix(state);
487      } else {
488        break;
489      }
490    }
491    return true;
492  }
493  static bool ParseUnqualifiedName(State *state) {
494    ComplexityGuard guard(state);
495    if (guard.IsTooComplex()) return false;
496    if (ParseOperatorName(state, nullptr) || ParseCtorDtorName(state) ||
497        ParseSourceName(state) || ParseLocalSourceName(state) ||
498        ParseUnnamedTypeName(state)) {
499      return ParseAbiTags(state);
500    }
501    return false;
502  }
503  static bool ParseAbiTags(State *state) {
504    ComplexityGuard guard(state);
505    if (guard.IsTooComplex()) return false;
506    while (ParseOneCharToken(state, &#x27;B&#x27;)) {
507      ParseState copy = state-&gt;parse_state;
508      MaybeAppend(state, &quot;[abi:&quot;);
509      if (!ParseSourceName(state)) {
510        state-&gt;parse_state = copy;
511        return false;
512      }
513      MaybeAppend(state, &quot;]&quot;);
514    }
515    return true;
516  }
517  static bool ParseSourceName(State *state) {
518    ComplexityGuard guard(state);
519    if (guard.IsTooComplex()) return false;
520    ParseState copy = state-&gt;parse_state;
521    int length = -1;
522    if (ParseNumber(state, &amp;length) &amp;&amp;
523        ParseIdentifier(state, static_cast&lt;size_t&gt;(length))) {
524      return true;
525    }
526    state-&gt;parse_state = copy;
527    return false;
528  }
529  static bool ParseLocalSourceName(State *state) {
530    ComplexityGuard guard(state);
531    if (guard.IsTooComplex()) return false;
532    ParseState copy = state-&gt;parse_state;
533    if (ParseOneCharToken(state, &#x27;L&#x27;) &amp;&amp; ParseSourceName(state) &amp;&amp;
534        Optional(ParseDiscriminator(state))) {
535      return true;
536    }
537    state-&gt;parse_state = copy;
538    return false;
539  }
540  static bool ParseUnnamedTypeName(State *state) {
541    ComplexityGuard guard(state);
542    if (guard.IsTooComplex()) return false;
543    ParseState copy = state-&gt;parse_state;
544    int which = -1;
545    if (ParseTwoCharToken(state, &quot;Ut&quot;) &amp;&amp; Optional(ParseNumber(state, &amp;which)) &amp;&amp;
546        which &lt;= std::numeric_limits&lt;int&gt;::max() - 2 &amp;&amp;  
547        ParseOneCharToken(state, &#x27;_&#x27;)) {
548      MaybeAppend(state, &quot;{unnamed type#&quot;);
549      MaybeAppendDecimal(state, 2 + which);
550      MaybeAppend(state, &quot;}&quot;);
551      return true;
552    }
553    state-&gt;parse_state = copy;
554    which = -1;
555    if (ParseTwoCharToken(state, &quot;Ul&quot;) &amp;&amp; DisableAppend(state) &amp;&amp;
556        OneOrMore(ParseType, state) &amp;&amp; RestoreAppend(state, copy.append) &amp;&amp;
557        ParseOneCharToken(state, &#x27;E&#x27;) &amp;&amp; Optional(ParseNumber(state, &amp;which)) &amp;&amp;
558        which &lt;= std::numeric_limits&lt;int&gt;::max() - 2 &amp;&amp;  
559        ParseOneCharToken(state, &#x27;_&#x27;)) {
560      MaybeAppend(state, &quot;{lambda()#&quot;);
561      MaybeAppendDecimal(state, 2 + which);
562      MaybeAppend(state, &quot;}&quot;);
563      return true;
564    }
565    state-&gt;parse_state = copy;
566    return false;
567  }
568  static bool ParseNumber(State *state, int *number_out) {
569    ComplexityGuard guard(state);
570    if (guard.IsTooComplex()) return false;
571    bool negative = false;
572    if (ParseOneCharToken(state, &#x27;n&#x27;)) {
573      negative = true;
574    }
575    const char *p = RemainingInput(state);
576    uint64_t number = 0;
577    for (; *p != &#x27;\0&#x27;; ++p) {
578      if (IsDigit(*p)) {
579        number = number * 10 + static_cast&lt;uint64_t&gt;(*p - &#x27;0&#x27;);
580      } else {
581        break;
582      }
583    }
584    if (negative) {
585      number = ~number + 1;
586    }
587    if (p != RemainingInput(state)) {  
588      state-&gt;parse_state.mangled_idx += p - RemainingInput(state);
589      if (number_out != nullptr) {
590        *number_out = static_cast&lt;int&gt;(number);
591      }
592      return true;
593    }
594    return false;
595  }
596  static bool ParseFloatNumber(State *state) {
597    ComplexityGuard guard(state);
598    if (guard.IsTooComplex()) return false;
599    const char *p = RemainingInput(state);
600    for (; *p != &#x27;\0&#x27;; ++p) {
601      if (!IsDigit(*p) &amp;&amp; !(*p &gt;= &#x27;a&#x27; &amp;&amp; *p &lt;= &#x27;f&#x27;)) {
602        break;
603      }
604    }
605    if (p != RemainingInput(state)) {  
606      state-&gt;parse_state.mangled_idx += p - RemainingInput(state);
607      return true;
608    }
609    return false;
610  }
611  static bool ParseSeqId(State *state) {
612    ComplexityGuard guard(state);
613    if (guard.IsTooComplex()) return false;
614    const char *p = RemainingInput(state);
615    for (; *p != &#x27;\0&#x27;; ++p) {
616      if (!IsDigit(*p) &amp;&amp; !(*p &gt;= &#x27;A&#x27; &amp;&amp; *p &lt;= &#x27;Z&#x27;)) {
617        break;
618      }
619    }
620    if (p != RemainingInput(state)) {  
621      state-&gt;parse_state.mangled_idx += p - RemainingInput(state);
622      return true;
623    }
624    return false;
625  }
626  static bool ParseIdentifier(State *state, size_t length) {
627    ComplexityGuard guard(state);
628    if (guard.IsTooComplex()) return false;
629    if (!AtLeastNumCharsRemaining(RemainingInput(state), length)) {
630      return false;
631    }
632    if (IdentifierIsAnonymousNamespace(state, length)) {
633      MaybeAppend(state, &quot;(anonymous namespace)&quot;);
634    } else {
635      MaybeAppendWithLength(state, RemainingInput(state), length);
636    }
637    state-&gt;parse_state.mangled_idx += length;
638    return true;
639  }
640  static bool ParseOperatorName(State *state, int *arity) {
641    ComplexityGuard guard(state);
642    if (guard.IsTooComplex()) return false;
643    if (!AtLeastNumCharsRemaining(RemainingInput(state), 2)) {
644      return false;
645    }
646    ParseState copy = state-&gt;parse_state;
647    if (ParseTwoCharToken(state, &quot;cv&quot;) &amp;&amp; MaybeAppend(state, &quot;operator &quot;) &amp;&amp;
648        EnterNestedName(state) &amp;&amp; ParseType(state) &amp;&amp;
649        LeaveNestedName(state, copy.nest_level)) {
650      if (arity != nullptr) {
651        *arity = 1;
652      }
653      return true;
654    }
655    state-&gt;parse_state = copy;
656    if (ParseOneCharToken(state, &#x27;v&#x27;) &amp;&amp; ParseDigit(state, arity) &amp;&amp;
657        ParseSourceName(state)) {
658      return true;
659    }
660    state-&gt;parse_state = copy;
661    if (!(IsLower(RemainingInput(state)[0]) &amp;&amp;
662          IsAlpha(RemainingInput(state)[1]))) {
663      return false;
664    }
665    const AbbrevPair *p;
666    for (p = kOperatorList; p-&gt;abbrev != nullptr; ++p) {
667      if (RemainingInput(state)[0] == p-&gt;abbrev[0] &amp;&amp;
668          RemainingInput(state)[1] == p-&gt;abbrev[1]) {
669        if (arity != nullptr) {
670          *arity = p-&gt;arity;
671        }
672        MaybeAppend(state, &quot;operator&quot;);
673        if (IsLower(*p-&gt;real_name)) {  
674          MaybeAppend(state, &quot; &quot;);
675        }
676        MaybeAppend(state, p-&gt;real_name);
677        state-&gt;parse_state.mangled_idx += 2;
678        return true;
679      }
680    }
681    return false;
682  }
683  static bool ParseSpecialName(State *state) {
684    ComplexityGuard guard(state);
685    if (guard.IsTooComplex()) return false;
686    ParseState copy = state-&gt;parse_state;
687    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseCharClass(state, &quot;VTISH&quot;) &amp;&amp;
688        ParseType(state)) {
689      return true;
690    }
691    state-&gt;parse_state = copy;
692    if (ParseTwoCharToken(state, &quot;Tc&quot;) &amp;&amp; ParseCallOffset(state) &amp;&amp;
693        ParseCallOffset(state) &amp;&amp; ParseEncoding(state)) {
694      return true;
695    }
696    state-&gt;parse_state = copy;
697    if (ParseTwoCharToken(state, &quot;GV&quot;) &amp;&amp; ParseName(state)) {
698      return true;
699    }
700    state-&gt;parse_state = copy;
701    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseCallOffset(state) &amp;&amp;
702        ParseEncoding(state)) {
703      return true;
704    }
705    state-&gt;parse_state = copy;
706    if (ParseTwoCharToken(state, &quot;TC&quot;) &amp;&amp; ParseType(state) &amp;&amp;
707        ParseNumber(state, nullptr) &amp;&amp; ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp;
708        DisableAppend(state) &amp;&amp; ParseType(state)) {
709      RestoreAppend(state, copy.append);
710      return true;
711    }
712    state-&gt;parse_state = copy;
713    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseCharClass(state, &quot;FJ&quot;) &amp;&amp;
714        ParseType(state)) {
715      return true;
716    }
717    state-&gt;parse_state = copy;
718    if (ParseTwoCharToken(state, &quot;GR&quot;) &amp;&amp; ParseName(state)) {
719      return true;
720    }
721    state-&gt;parse_state = copy;
722    if (ParseTwoCharToken(state, &quot;GA&quot;) &amp;&amp; ParseEncoding(state)) {
723      return true;
724    }
725    state-&gt;parse_state = copy;
726    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseCharClass(state, &quot;hv&quot;) &amp;&amp;
727        ParseCallOffset(state) &amp;&amp; ParseEncoding(state)) {
728      return true;
729    }
730    state-&gt;parse_state = copy;
731    return false;
732  }
733  static bool ParseCallOffset(State *state) {
734    ComplexityGuard guard(state);
735    if (guard.IsTooComplex()) return false;
736    ParseState copy = state-&gt;parse_state;
737    if (ParseOneCharToken(state, &#x27;h&#x27;) &amp;&amp; ParseNVOffset(state) &amp;&amp;
738        ParseOneCharToken(state, &#x27;_&#x27;)) {
739      return true;
740    }
741    state-&gt;parse_state = copy;
742    if (ParseOneCharToken(state, &#x27;v&#x27;) &amp;&amp; ParseVOffset(state) &amp;&amp;
743        ParseOneCharToken(state, &#x27;_&#x27;)) {
744      return true;
745    }
746    state-&gt;parse_state = copy;
747    return false;
748  }
749  static bool ParseNVOffset(State *state) {
750    ComplexityGuard guard(state);
751    if (guard.IsTooComplex()) return false;
752    return ParseNumber(state, nullptr);
753  }
754  static bool ParseVOffset(State *state) {
755    ComplexityGuard guard(state);
756    if (guard.IsTooComplex()) return false;
757    ParseState copy = state-&gt;parse_state;
758    if (ParseNumber(state, nullptr) &amp;&amp; ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp;
759        ParseNumber(state, nullptr)) {
760      return true;
761    }
762    state-&gt;parse_state = copy;
763    return false;
764  }
765  static bool ParseCtorDtorName(State *state) {
766    ComplexityGuard guard(state);
767    if (guard.IsTooComplex()) return false;
768    ParseState copy = state-&gt;parse_state;
769    if (ParseOneCharToken(state, &#x27;C&#x27;)) {
770      if (ParseCharClass(state, &quot;1234&quot;)) {
771        const char *const prev_name =
772            state-&gt;out + state-&gt;parse_state.prev_name_idx;
773        MaybeAppendWithLength(state, prev_name,
774                              state-&gt;parse_state.prev_name_length);
775        return true;
776      } else if (ParseOneCharToken(state, &#x27;I&#x27;) &amp;&amp; ParseCharClass(state, &quot;12&quot;) &amp;&amp;
777                 ParseClassEnumType(state)) {
778        return true;
779      }
780    }
781    state-&gt;parse_state = copy;
782    if (ParseOneCharToken(state, &#x27;D&#x27;) &amp;&amp; ParseCharClass(state, &quot;0124&quot;)) {
783      const char *const prev_name = state-&gt;out + state-&gt;parse_state.prev_name_idx;
784      MaybeAppend(state, &quot;~&quot;);
<span onclick='openModal()' class='match'>785      MaybeAppendWithLength(state, prev_name,
786                            state-&gt;parse_state.prev_name_length);
787      return true;
788    }
789    state-&gt;parse_state = copy;
</span>790    return false;
791  }
792  static bool ParseDecltype(State *state) {
793    ComplexityGuard guard(state);
794    if (guard.IsTooComplex()) return false;
795    ParseState copy = state-&gt;parse_state;
796    if (ParseOneCharToken(state, &#x27;D&#x27;) &amp;&amp; ParseCharClass(state, &quot;tT&quot;) &amp;&amp;
797        ParseExpression(state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
798      return true;
799    }
800    state-&gt;parse_state = copy;
801    return false;
802  }
803  static bool ParseType(State *state) {
804    ComplexityGuard guard(state);
805    if (guard.IsTooComplex()) return false;
806    ParseState copy = state-&gt;parse_state;
807    if (ParseCVQualifiers(state)) {
808      const bool result = ParseType(state);
809      if (!result) state-&gt;parse_state = copy;
810      return result;
811    }
812    state-&gt;parse_state = copy;
813    if (ParseCharClass(state, &quot;OPRCG&quot;)) {
814      const bool result = ParseType(state);
815      if (!result) state-&gt;parse_state = copy;
816      return result;
817    }
818    state-&gt;parse_state = copy;
819    if (ParseTwoCharToken(state, &quot;Dp&quot;) &amp;&amp; ParseType(state)) {
820      return true;
821    }
822    state-&gt;parse_state = copy;
823    if (ParseOneCharToken(state, &#x27;U&#x27;) &amp;&amp; ParseSourceName(state) &amp;&amp;
824        ParseType(state)) {
825      return true;
826    }
827    state-&gt;parse_state = copy;
828    if (ParseBuiltinType(state) || ParseFunctionType(state) ||
829        ParseClassEnumType(state) || ParseArrayType(state) ||
830        ParsePointerToMemberType(state) || ParseDecltype(state) ||
831        ParseSubstitution(state, &amp;bsol;*accept_std=*/false)) {
832      return true;
833    }
834    if (ParseTemplateTemplateParam(state) &amp;&amp; ParseTemplateArgs(state)) {
835      return true;
836    }
837    state-&gt;parse_state = copy;
838    if (ParseTemplateParam(state)) {
839      return true;
840    }
841    if (ParseTwoCharToken(state, &quot;Dv&quot;) &amp;&amp; ParseNumber(state, nullptr) &amp;&amp;
842        ParseOneCharToken(state, &#x27;_&#x27;)) {
843      return true;
844    }
845    state-&gt;parse_state = copy;
846    return false;
847  }
848  static bool ParseCVQualifiers(State *state) {
849    ComplexityGuard guard(state);
850    if (guard.IsTooComplex()) return false;
851    int num_cv_qualifiers = 0;
852    num_cv_qualifiers += ParseOneCharToken(state, &#x27;r&#x27;);
853    num_cv_qualifiers += ParseOneCharToken(state, &#x27;V&#x27;);
854    num_cv_qualifiers += ParseOneCharToken(state, &#x27;K&#x27;);
855    return num_cv_qualifiers &gt; 0;
856  }
857  static bool ParseBuiltinType(State *state) {
858    ComplexityGuard guard(state);
859    if (guard.IsTooComplex()) return false;
860    const AbbrevPair *p;
861    for (p = kBuiltinTypeList; p-&gt;abbrev != nullptr; ++p) {
862      if (p-&gt;abbrev[1] == &#x27;\0&#x27;) {
863        if (ParseOneCharToken(state, p-&gt;abbrev[0])) {
864          MaybeAppend(state, p-&gt;real_name);
865          return true;
866        }
867      } else if (p-&gt;abbrev[2] == &#x27;\0&#x27; &amp;&amp; ParseTwoCharToken(state, p-&gt;abbrev)) {
868        MaybeAppend(state, p-&gt;real_name);
869        return true;
870      }
871    }
872    ParseState copy = state-&gt;parse_state;
873    if (ParseOneCharToken(state, &#x27;u&#x27;) &amp;&amp; ParseSourceName(state)) {
874      return true;
875    }
876    state-&gt;parse_state = copy;
877    return false;
878  }
879  static bool ParseExceptionSpec(State *state) {
880    ComplexityGuard guard(state);
881    if (guard.IsTooComplex()) return false;
882    if (ParseTwoCharToken(state, &quot;Do&quot;)) return true;
883    ParseState copy = state-&gt;parse_state;
884    if (ParseTwoCharToken(state, &quot;DO&quot;) &amp;&amp; ParseExpression(state) &amp;&amp;
885        ParseOneCharToken(state, &#x27;E&#x27;)) {
886      return true;
887    }
888    state-&gt;parse_state = copy;
889    if (ParseTwoCharToken(state, &quot;Dw&quot;) &amp;&amp; OneOrMore(ParseType, state) &amp;&amp;
890        ParseOneCharToken(state, &#x27;E&#x27;)) {
891      return true;
892    }
893    state-&gt;parse_state = copy;
894    return false;
895  }
896  static bool ParseFunctionType(State *state) {
897    ComplexityGuard guard(state);
898    if (guard.IsTooComplex()) return false;
899    ParseState copy = state-&gt;parse_state;
900    if (Optional(ParseExceptionSpec(state)) &amp;&amp; ParseOneCharToken(state, &#x27;F&#x27;) &amp;&amp;
901        Optional(ParseOneCharToken(state, &#x27;Y&#x27;)) &amp;&amp; ParseBareFunctionType(state) &amp;&amp;
902        Optional(ParseOneCharToken(state, &#x27;O&#x27;)) &amp;&amp;
903        ParseOneCharToken(state, &#x27;E&#x27;)) {
904      return true;
905    }
906    state-&gt;parse_state = copy;
907    return false;
908  }
909  static bool ParseBareFunctionType(State *state) {
910    ComplexityGuard guard(state);
911    if (guard.IsTooComplex()) return false;
912    ParseState copy = state-&gt;parse_state;
913    DisableAppend(state);
914    if (OneOrMore(ParseType, state)) {
915      RestoreAppend(state, copy.append);
916      MaybeAppend(state, &quot;()&quot;);
917      return true;
918    }
919    state-&gt;parse_state = copy;
920    return false;
921  }
922  static bool ParseClassEnumType(State *state) {
923    ComplexityGuard guard(state);
924    if (guard.IsTooComplex()) return false;
925    return ParseName(state);
926  }
927  static bool ParseArrayType(State *state) {
928    ComplexityGuard guard(state);
929    if (guard.IsTooComplex()) return false;
930    ParseState copy = state-&gt;parse_state;
931    if (ParseOneCharToken(state, &#x27;A&#x27;) &amp;&amp; ParseNumber(state, nullptr) &amp;&amp;
932        ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp; ParseType(state)) {
933      return true;
934    }
935    state-&gt;parse_state = copy;
936    if (ParseOneCharToken(state, &#x27;A&#x27;) &amp;&amp; Optional(ParseExpression(state)) &amp;&amp;
937        ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp; ParseType(state)) {
938      return true;
939    }
940    state-&gt;parse_state = copy;
941    return false;
942  }
943  static bool ParsePointerToMemberType(State *state) {
944    ComplexityGuard guard(state);
945    if (guard.IsTooComplex()) return false;
946    ParseState copy = state-&gt;parse_state;
947    if (ParseOneCharToken(state, &#x27;M&#x27;) &amp;&amp; ParseType(state) &amp;&amp; ParseType(state)) {
948      return true;
949    }
950    state-&gt;parse_state = copy;
951    return false;
952  }
953  static bool ParseTemplateParam(State *state) {
954    ComplexityGuard guard(state);
955    if (guard.IsTooComplex()) return false;
956    if (ParseTwoCharToken(state, &quot;T_&quot;)) {
957      MaybeAppend(state, &quot;?&quot;);  
958      return true;
959    }
960    ParseState copy = state-&gt;parse_state;
961    if (ParseOneCharToken(state, &#x27;T&#x27;) &amp;&amp; ParseNumber(state, nullptr) &amp;&amp;
962        ParseOneCharToken(state, &#x27;_&#x27;)) {
963      MaybeAppend(state, &quot;?&quot;);  
964      return true;
965    }
966    state-&gt;parse_state = copy;
967    return false;
968  }
969  static bool ParseTemplateTemplateParam(State *state) {
970    ComplexityGuard guard(state);
971    if (guard.IsTooComplex()) return false;
972    return (ParseTemplateParam(state) ||
973            ParseSubstitution(state, &amp;bsol;*accept_std=*/false));
974  }
975  static bool ParseTemplateArgs(State *state) {
976    ComplexityGuard guard(state);
977    if (guard.IsTooComplex()) return false;
978    ParseState copy = state-&gt;parse_state;
979    DisableAppend(state);
980    if (ParseOneCharToken(state, &#x27;I&#x27;) &amp;&amp; OneOrMore(ParseTemplateArg, state) &amp;&amp;
981        ParseOneCharToken(state, &#x27;E&#x27;)) {
982      RestoreAppend(state, copy.append);
983      MaybeAppend(state, &quot;&lt;&gt;&quot;);
984      return true;
985    }
986    state-&gt;parse_state = copy;
987    return false;
988  }
989  static bool ParseTemplateArg(State *state) {
990    ComplexityGuard guard(state);
991    if (guard.IsTooComplex()) return false;
992    ParseState copy = state-&gt;parse_state;
993    if (ParseOneCharToken(state, &#x27;J&#x27;) &amp;&amp; ZeroOrMore(ParseTemplateArg, state) &amp;&amp;
994        ParseOneCharToken(state, &#x27;E&#x27;)) {
995      return true;
996    }
997    state-&gt;parse_state = copy;
998    if (ParseLocalSourceName(state) &amp;&amp; Optional(ParseTemplateArgs(state))) {
999      copy = state-&gt;parse_state;
1000      if (ParseExprCastValue(state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1001        return true;
1002      }
1003      state-&gt;parse_state = copy;
1004      return true;
1005    }
1006    if (ParseType(state) || ParseExprPrimary(state)) {
1007      return true;
1008    }
1009    state-&gt;parse_state = copy;
1010    if (ParseOneCharToken(state, &#x27;X&#x27;) &amp;&amp; ParseExpression(state) &amp;&amp;
1011        ParseOneCharToken(state, &#x27;E&#x27;)) {
1012      return true;
1013    }
1014    state-&gt;parse_state = copy;
1015    return false;
1016  }
1017  static inline bool ParseUnresolvedType(State *state) {
1018    return (ParseTemplateParam(state) &amp;&amp; Optional(ParseTemplateArgs(state))) ||
1019           ParseDecltype(state) || ParseSubstitution(state, &amp;bsol;*accept_std=*/false);
1020  }
1021  static inline bool ParseSimpleId(State *state) {
1022    return ParseSourceName(state) &amp;&amp; Optional(ParseTemplateArgs(state));
1023  }
1024  static bool ParseBaseUnresolvedName(State *state) {
1025    ComplexityGuard guard(state);
1026    if (guard.IsTooComplex()) return false;
1027    if (ParseSimpleId(state)) {
1028      return true;
1029    }
1030    ParseState copy = state-&gt;parse_state;
1031    if (ParseTwoCharToken(state, &quot;on&quot;) &amp;&amp; ParseOperatorName(state, nullptr) &amp;&amp;
1032        Optional(ParseTemplateArgs(state))) {
1033      return true;
1034    }
1035    state-&gt;parse_state = copy;
1036    if (ParseTwoCharToken(state, &quot;dn&quot;) &amp;&amp;
1037        (ParseUnresolvedType(state) || ParseSimpleId(state))) {
1038      return true;
1039    }
1040    state-&gt;parse_state = copy;
1041    return false;
1042  }
1043  static bool ParseUnresolvedName(State *state) {
1044    ComplexityGuard guard(state);
1045    if (guard.IsTooComplex()) return false;
1046    ParseState copy = state-&gt;parse_state;
1047    if (Optional(ParseTwoCharToken(state, &quot;gs&quot;)) &amp;&amp;
1048        ParseBaseUnresolvedName(state)) {
1049      return true;
1050    }
1051    state-&gt;parse_state = copy;
1052    if (ParseTwoCharToken(state, &quot;sr&quot;) &amp;&amp; ParseUnresolvedType(state) &amp;&amp;
1053        ParseBaseUnresolvedName(state)) {
1054      return true;
1055    }
1056    state-&gt;parse_state = copy;
1057    if (ParseTwoCharToken(state, &quot;sr&quot;) &amp;&amp; ParseOneCharToken(state, &#x27;N&#x27;) &amp;&amp;
1058        ParseUnresolvedType(state) &amp;&amp;
1059        OneOrMore(&amp;bsol;* &lt;unresolved-qualifier-level&gt; ::= */ ParseSimpleId, state) &amp;&amp;
1060        ParseOneCharToken(state, &#x27;E&#x27;) &amp;&amp; ParseBaseUnresolvedName(state)) {
1061      return true;
1062    }
1063    state-&gt;parse_state = copy;
1064    if (Optional(ParseTwoCharToken(state, &quot;gs&quot;)) &amp;&amp;
1065        ParseTwoCharToken(state, &quot;sr&quot;) &amp;&amp;
1066        OneOrMore(&amp;bsol;* &lt;unresolved-qualifier-level&gt; ::= */ ParseSimpleId, state) &amp;&amp;
1067        ParseOneCharToken(state, &#x27;E&#x27;) &amp;&amp; ParseBaseUnresolvedName(state)) {
1068      return true;
1069    }
1070    state-&gt;parse_state = copy;
1071    return false;
1072  }
1073  static bool ParseExpression(State *state) {
1074    ComplexityGuard guard(state);
1075    if (guard.IsTooComplex()) return false;
1076    if (ParseTemplateParam(state) || ParseExprPrimary(state)) {
1077      return true;
1078    }
1079    ParseState copy = state-&gt;parse_state;
1080    if (ParseTwoCharToken(state, &quot;cl&quot;) &amp;&amp; OneOrMore(ParseExpression, state) &amp;&amp;
1081        ParseOneCharToken(state, &#x27;E&#x27;)) {
1082      return true;
1083    }
1084    state-&gt;parse_state = copy;
1085    if (ParseTwoCharToken(state, &quot;cp&quot;) &amp;&amp; ParseSimpleId(state) &amp;&amp;
1086        ZeroOrMore(ParseExpression, state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1087      return true;
1088    }
1089    state-&gt;parse_state = copy;
1090    if (ParseTwoCharToken(state, &quot;fp&quot;) &amp;&amp; Optional(ParseCVQualifiers(state)) &amp;&amp;
1091        Optional(ParseNumber(state, nullptr)) &amp;&amp; ParseOneCharToken(state, &#x27;_&#x27;)) {
1092      return true;
1093    }
1094    state-&gt;parse_state = copy;
1095    if (ParseTwoCharToken(state, &quot;fL&quot;) &amp;&amp; Optional(ParseNumber(state, nullptr)) &amp;&amp;
1096        ParseOneCharToken(state, &#x27;p&#x27;) &amp;&amp; Optional(ParseCVQualifiers(state)) &amp;&amp;
1097        Optional(ParseNumber(state, nullptr)) &amp;&amp; ParseOneCharToken(state, &#x27;_&#x27;)) {
1098      return true;
1099    }
1100    state-&gt;parse_state = copy;
1101    if (ParseTwoCharToken(state, &quot;cv&quot;)) {
1102      if (ParseType(state)) {
1103        ParseState copy2 = state-&gt;parse_state;
1104        if (ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp; ZeroOrMore(ParseExpression, state) &amp;&amp;
1105            ParseOneCharToken(state, &#x27;E&#x27;)) {
1106          return true;
1107        }
1108        state-&gt;parse_state = copy2;
1109        if (ParseExpression(state)) {
1110          return true;
1111        }
1112      }
1113    } else {
1114      int arity = -1;
1115      if (ParseOperatorName(state, &amp;arity) &amp;&amp;
1116          arity &gt; 0 &amp;&amp;  
1117          (arity &lt; 3 || ParseExpression(state)) &amp;&amp;
1118          (arity &lt; 2 || ParseExpression(state)) &amp;&amp;
1119          (arity &lt; 1 || ParseExpression(state))) {
1120        return true;
1121      }
1122    }
1123    state-&gt;parse_state = copy;
1124    if (ParseTwoCharToken(state, &quot;st&quot;) &amp;&amp; ParseType(state)) {
1125      return true;
1126    }
1127    state-&gt;parse_state = copy;
1128    if ((ParseTwoCharToken(state, &quot;dt&quot;) || ParseTwoCharToken(state, &quot;pt&quot;)) &amp;&amp;
1129        ParseExpression(state) &amp;&amp; ParseType(state)) {
1130      return true;
1131    }
1132    state-&gt;parse_state = copy;
1133    if (ParseTwoCharToken(state, &quot;ds&quot;) &amp;&amp; ParseExpression(state) &amp;&amp;
1134        ParseExpression(state)) {
1135      return true;
1136    }
1137    state-&gt;parse_state = copy;
1138    if (ParseTwoCharToken(state, &quot;sp&quot;) &amp;&amp; ParseExpression(state)) {
1139      return true;
1140    }
1141    state-&gt;parse_state = copy;
1142    return ParseUnresolvedName(state);
1143  }
1144  static bool ParseExprPrimary(State *state) {
1145    ComplexityGuard guard(state);
1146    if (guard.IsTooComplex()) return false;
1147    ParseState copy = state-&gt;parse_state;
1148    if (ParseTwoCharToken(state, &quot;LZ&quot;)) {
1149      if (ParseEncoding(state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1150        return true;
1151      }
1152      state-&gt;parse_state = copy;
1153      return false;
1154    }
1155    if (ParseOneCharToken(state, &#x27;L&#x27;) &amp;&amp; ParseType(state) &amp;&amp;
1156        ParseExprCastValue(state)) {
1157      return true;
1158    }
1159    state-&gt;parse_state = copy;
1160    if (ParseOneCharToken(state, &#x27;L&#x27;) &amp;&amp; ParseMangledName(state) &amp;&amp;
1161        ParseOneCharToken(state, &#x27;E&#x27;)) {
1162      return true;
1163    }
1164    state-&gt;parse_state = copy;
1165    return false;
1166  }
1167  static bool ParseExprCastValue(State *state) {
1168    ComplexityGuard guard(state);
1169    if (guard.IsTooComplex()) return false;
1170    ParseState copy = state-&gt;parse_state;
1171    if (ParseNumber(state, nullptr) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1172      return true;
1173    }
1174    state-&gt;parse_state = copy;
1175    if (ParseFloatNumber(state) &amp;&amp; ParseOneCharToken(state, &#x27;E&#x27;)) {
1176      return true;
1177    }
1178    state-&gt;parse_state = copy;
1179    return false;
1180  }
1181  static bool ParseLocalNameSuffix(State *state) {
1182    ComplexityGuard guard(state);
1183    if (guard.IsTooComplex()) return false;
1184    if (MaybeAppend(state, &quot;::&quot;) &amp;&amp; ParseName(state) &amp;&amp;
1185        Optional(ParseDiscriminator(state))) {
1186      return true;
1187    }
1188    if (state-&gt;parse_state.append) {
1189      state-&gt;out[state-&gt;parse_state.out_cur_idx - 2] = &#x27;\0&#x27;;
1190    }
1191    return ParseOneCharToken(state, &#x27;s&#x27;) &amp;&amp; Optional(ParseDiscriminator(state));
1192  }
1193  static bool ParseLocalName(State *state) {
1194    ComplexityGuard guard(state);
1195    if (guard.IsTooComplex()) return false;
1196    ParseState copy = state-&gt;parse_state;
1197    if (ParseOneCharToken(state, &#x27;Z&#x27;) &amp;&amp; ParseEncoding(state) &amp;&amp;
1198        ParseOneCharToken(state, &#x27;E&#x27;) &amp;&amp; ParseLocalNameSuffix(state)) {
1199      return true;
1200    }
1201    state-&gt;parse_state = copy;
1202    return false;
1203  }
1204  static bool ParseDiscriminator(State *state) {
1205    ComplexityGuard guard(state);
1206    if (guard.IsTooComplex()) return false;
1207    ParseState copy = state-&gt;parse_state;
1208    if (ParseOneCharToken(state, &#x27;_&#x27;) &amp;&amp; ParseNumber(state, nullptr)) {
1209      return true;
1210    }
1211    state-&gt;parse_state = copy;
1212    return false;
1213  }
1214  static bool ParseSubstitution(State *state, bool accept_std) {
1215    ComplexityGuard guard(state);
1216    if (guard.IsTooComplex()) return false;
1217    if (ParseTwoCharToken(state, &quot;S_&quot;)) {
1218      MaybeAppend(state, &quot;?&quot;);  
1219      return true;
1220    }
1221    ParseState copy = state-&gt;parse_state;
1222    if (ParseOneCharToken(state, &#x27;S&#x27;) &amp;&amp; ParseSeqId(state) &amp;&amp;
1223        ParseOneCharToken(state, &#x27;_&#x27;)) {
1224      MaybeAppend(state, &quot;?&quot;);  
1225      return true;
1226    }
1227    state-&gt;parse_state = copy;
1228    if (ParseOneCharToken(state, &#x27;S&#x27;)) {
1229      const AbbrevPair *p;
1230      for (p = kSubstitutionList; p-&gt;abbrev != nullptr; ++p) {
1231        if (RemainingInput(state)[0] == p-&gt;abbrev[1] &amp;&amp;
1232            (accept_std || p-&gt;abbrev[1] != &#x27;t&#x27;)) {
1233          MaybeAppend(state, &quot;std&quot;);
1234          if (p-&gt;real_name[0] != &#x27;\0&#x27;) {
1235            MaybeAppend(state, &quot;::&quot;);
1236            MaybeAppend(state, p-&gt;real_name);
1237          }
1238          ++state-&gt;parse_state.mangled_idx;
1239          return true;
1240        }
1241      }
1242    }
1243    state-&gt;parse_state = copy;
1244    return false;
1245  }
1246  static bool ParseTopLevelMangledName(State *state) {
1247    ComplexityGuard guard(state);
1248    if (guard.IsTooComplex()) return false;
1249    if (ParseMangledName(state)) {
1250      if (RemainingInput(state)[0] != &#x27;\0&#x27;) {
1251        if (IsFunctionCloneSuffix(RemainingInput(state))) {
1252          return true;
1253        }
1254        if (RemainingInput(state)[0] == &#x27;@&#x27;) {
1255          MaybeAppend(state, RemainingInput(state));
1256          return true;
1257        }
1258        return false;  
1259      }
1260      return true;
1261    }
1262    return false;
1263  }
1264  static bool Overflowed(const State *state) {
1265    return state-&gt;parse_state.out_cur_idx &gt;= state-&gt;out_end_idx;
1266  }
1267  bool Demangle(const char* mangled, char* out, size_t out_size) {
1268    State state;
1269    InitState(&amp;state, mangled, out, out_size);
1270    return ParseTopLevelMangledName(&amp;state) &amp;&amp; !Overflowed(&amp;state) &amp;&amp;
1271           state.parse_state.out_cur_idx &gt; 0;
1272  }
1273  }  
1274  ABSL_NAMESPACE_END
1275  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-demangle.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-demangle.cc</div>
                </div>
                <div class="column column_space"><pre><code>773        MaybeAppendWithLength(state, prev_name,
774                              state-&gt;parse_state.prev_name_length);
775        return true;
776      } else if (ParseOneCharToken(state, &#x27;I&#x27;) &amp;&amp; ParseCharClass(state, &quot;12&quot;) &amp;&amp;
</pre></code></div>
                <div class="column column_space"><pre><code>785      MaybeAppendWithLength(state, prev_name,
786                            state-&gt;parse_state.prev_name_length);
787      return true;
788    }
789    state-&gt;parse_state = copy;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    