
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.29894660370505%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-signnet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "signnet.h"
3  PSignNet TSignNet::GetEdgeSubNet(const int& EDat1, const int& EDat2, const int& EDat3) const {
4    TIntSet EDatSet;
5    EDatSet.AddKey(EDat1);
6    if (EDat2!=TInt::Mn) { EDatSet.AddKey(EDat2); }
7    if (EDat3!=TInt::Mn) { EDatSet.AddKey(EDat3); }
8    PSignNet Net = TSignNet::New();
9    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
10      if (! EDatSet.IsKey(EI())) { continue; }
11      if (! Net->IsNode(EI.GetSrcNId())) {
12        Net->AddNode(EI.GetSrcNId(), EI.GetSrcNDat()); }
13      if (! Net->IsNode(EI.GetDstNId())) {
14        Net->AddNode(EI.GetDstNId(), EI.GetDstNDat()); }
15      Net->AddEdge(EI);
16    }
17    return Net;
18  }
19  void TSignNet::PermuteEdgeSigns() {
20    TIntV EDatV(GetEdges(), 0);
21    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
22      EDatV.Add(EI());
23    }
24    EDatV.Shuffle(TInt::Rnd);
25    int i = 0;
26    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
27      EI() = EDatV[i++];
28    }
29  }
30  void TSignNet::RewireNetwork() {
31    TIntH NIdDatH;
32    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
33      NIdDatH.AddDat(NI.GetId(), NI()); }
34    PNGraph PlusG = TSnap::ConvertGraph<PNGraph>(GetSignSubNet(+1));
35    PNGraph MinusG = TSnap::ConvertGraph<PNGraph>(GetSignSubNet(-1));
36    PlusG = TSnap::GenRewire(PlusG);
37    MinusG = TSnap::GenRewire(MinusG);
38    Clr(false);
39    for (TNGraph::TNodeI NI = PlusG->BegNI(); NI < PlusG->EndNI(); NI++) {
40      AddNode(NI.GetId()); }
41    for (TNGraph::TNodeI NI = MinusG->BegNI(); NI < MinusG->EndNI(); NI++) {
42      AddNode(NI.GetId(), NIdDatH.GetDat(NI.GetId())); }
43    for (TNGraph::TEdgeI EI = PlusG->BegEI(); EI < PlusG->EndEI(); EI++) {
44      AddEdge(EI.GetSrcNId(), EI.GetDstNId(), +1); }
45    for (TNGraph::TEdgeI EI = MinusG->BegEI(); EI < MinusG->EndEI(); EI++) {
46      AddEdge(EI.GetSrcNId(), EI.GetDstNId(), -1); }
47  }
48  void TSignNet::SimplifyNet() {
49    TIntPrV DelV;
50    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
51      if (EI.GetSrcNId() > EI.GetDstNId()) { continue; }
52      if (EI.GetSrcNId() == EI.GetDstNId()) {
53        DelV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
54      else if (EI.GetSrcNId() < EI.GetDstNId() && IsEdge(EI.GetDstNId(), EI.GetSrcNId())) {
55        if (TInt::Rnd.GetUniDev() < 0.5) {
56          DelV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
57        else {
58          DelV.Add(TIntPr(EI.GetDstNId(), EI.GetSrcNId())); }
59      }
60    }
61    printf("Deleting %d edges\n", DelV.Len());
62    for (int e = 0; e < DelV.Len(); e++) {
63      DelEdge(DelV[e].Val1, DelV[e].Val2);
64    }
65  }
66  void TSignNet::FlipMinusEdges(const int&  OldSign, const int& NewSign) {
67    TIntPrV MinusEV;
68    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
69      if (EI() == OldSign) {
70        MinusEV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
71    }
72    int NFlip = 0;
73    for (int e = 0; e < MinusEV.Len(); e++) {
74      DelEdge(MinusEV[e].Val1, MinusEV[e].Val2);
75      if (! IsEdge(MinusEV[e].Val2, MinusEV[e].Val1)) {
76        AddEdge(MinusEV[e].Val2, MinusEV[e].Val1, NewSign);
77        NFlip++;
78      }
79    }
80    printf("%d/%d (%.4f) edges flipped\n", NFlip, MinusEV.Len(), NFlip/double(MinusEV.Len()));
81  }
82  void TSignNet::CountStructBalance() const {
83    TIntSet NbrIdSet;
84    THash<TIntTr, TInt> TriadCntH;
85    TIntH SignH;
86    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
87      SignH.AddDat(EI()) += 1;
88    }
89    printf("Structural balance triads: %d nodes, %d edges\n  background sign distribution:\n", GetNodes(), GetEdges());
90    SignH.SortByKey(false);
91    for (int i = 0; i < SignH.Len(); i++) {
92      printf("\t%2d\t%d\n", SignH.GetKey(i)(), SignH[i]());
93    }
94    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
95      const TNodeI SrcNI = GetNI(EI.GetSrcNId());
96      const TNodeI DstNI = GetNI(EI.GetDstNId());
97      const TInt E1Dat = EI();
98      NbrIdSet.Clr(false);
99      for (int es = 0; es < SrcNI.GetDeg(); es++) {
100        NbrIdSet.AddKey(SrcNI.GetNbrNId(es));
101      }
102      for (int ed = 0; ed < DstNI.GetDeg(); ed++) {
103        const int nbr = DstNI.GetNbrNId(ed);
104        if (! NbrIdSet.IsKey(nbr)) { continue; }
105        const TInt E3Dat = DstNI.GetNbrEDat(ed);
106        for (int ed2 = 0; ed2 < SrcNI.GetDeg(); ed2++) {
107          if (nbr != SrcNI.GetNbrNId(ed2)) { continue; }
108          const TInt E2Dat = SrcNI.GetNbrEDat(ed2);
109          TriadCntH.AddDat(TIntTr(TMath::Mx(E1Dat, E2Dat, E3Dat),
110            TMath::Median(E1Dat, E2Dat, E3Dat), TMath::Mn(E1Dat, E2Dat, E3Dat))) += 1;
111        }
112      }
113    }
114    TriadCntH.SortByKey(false);
115    printf("triad counts (all counts are real, not times 3):\n");
116    int SumTriad = 0, SignTriad=0;
117    for (int i = 0; i < TriadCntH.Len(); i++) {
118      SumTriad += TriadCntH[i];
119      TIntTr SignTr = TriadCntH.GetKey(i);
120      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
121        SignTriad += TriadCntH[i]; }
122    }
123    for (int i = 0; i < TriadCntH.Len(); i++) {
124      TIntTr SignTr = TriadCntH.GetKey(i);
125      printf("\t%2d %2d %2d\t%8d\t%f", SignTr.Val1(), SignTr.Val2(), SignTr.Val3(),
126        TriadCntH[i]()/3, TriadCntH[i]()/double(SumTriad));
127      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
128        printf("\t%f", TriadCntH[i]()/double(SignTriad)); }
129      printf("\n");
130    }
131  }
132  void TSignNet::CountBalUnBal(const int& NId1, const int& NId2, int& BalTriads, int& UnBalTriads) const {
133    BalTriads=0; UnBalTriads=0;
134    int Sign=0;
135    if (IsEdge(NId1, NId2)) { Sign=GetEDat(NId1, NId2); }
136    else if (IsEdge(NId2, NId1)) { Sign=GetEDat(NId2, NId1); }
137    else { return; }
138    TNodeI NI1 = GetNI(NId1);
139    TNodeI NI2 = GetNI(NId2);
140    TIntH NbrH(NI1.GetDeg());
141    for (int i = 0; i < NI1.GetDeg(); i++) {
142      const int nid = NI1.GetNbrNId(i);
143      if (nid!=NId1 && nid!=NId2) {
144        NbrH.AddDat(nid, NI1.GetNbrEDat(i));
145      }
146    }
147    for (int i = 0; i < NI2.GetDeg(); i++) {
148      const int nid = NI2.GetNbrNId(i);
149      if (NbrH.IsKey(nid)) {
150        if (Sign*NbrH.GetDat(nid)*NI2.GetNbrEDat(i) == 1) { BalTriads++; }
151        else { UnBalTriads++; }
152      }
153    }
154  }
155  void TSignNet::SetNodePart(const int& PartId) {
156    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
157      NI() = PartId;
158    }
159  }
160  void TSignNet::SetNodePart(TVec<TIntV>& PartNIdV) {
161    SetNodePart(-1);
162    for (int p = 0; p < PartNIdV.Len(); p++) {
163      for (int n = 0; n < PartNIdV[p].Len(); n++) {
164        if (IsNode(PartNIdV[p][n])) {
165          GetNDat(PartNIdV[p][n]) = p+1; }
166      }
167    }
168  }
169  void TSignNet::GetPartStat(const TVec<TIntV>& PartNIdV, const TStr& Desc) const {
170    THash<TIntPr, TIntPr> PartEdgeH;
171    TIntH NIdPartH;
172    int PartSz=0;
173    for (int p = 0; p < PartNIdV.Len(); p++) {
174      for (int n = 0; n < PartNIdV[p].Len(); n++) {
175        NIdPartH.AddDat(PartNIdV[p][n], p);
176      }
177      PartSz += PartNIdV[p].Len();
178    }
179    TInt DstPart;
180    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
181      if (! NIdPartH.IsKey(NI.GetId())) { continue; }
182      const int SrcPart = NIdPartH.GetDat(NI.GetId());
183      for (int e = 0; e < NI.GetOutDeg(); e++) {
184        const int Sign = NI.GetOutEDat(e);
185        TIntPr& IOCnt = PartEdgeH.AddDat(TIntPr(SrcPart, Sign));
186        if (NIdPartH.IsKeyGetDat(NI.GetOutNId(e), DstPart) && SrcPart==DstPart) {
187          if (Sign>0) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
188        else {
189          if (Sign<0) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
190      }
191    }
192    PartEdgeH.SortByKey();
193    printf("%s: Satisfied edges (n:%d, e:%d, %d in partitions)\n", Desc.CStr(), GetNodes(), GetEdges(), PartSz);
194    int OkEdges=0, AllEdges=0;
195    for (int p = 0; p < PartEdgeH.Len(); p++) {
196      double frac = 0.0;
197      if (PartEdgeH[p].Val1+PartEdgeH[p].Val2>0) {
198        frac=PartEdgeH[p].Val1/double(PartEdgeH[p].Val1+PartEdgeH[p].Val2); }
199      OkEdges += PartEdgeH[p].Val1;
200      AllEdges += PartEdgeH[p].Val1 + PartEdgeH[p].Val2;
201      if (p==0 || PartEdgeH.GetKey(p).Val1!=PartEdgeH.GetKey(p-1).Val1) {
202        printf("  %2d  %2d : %6d : %6d  =  %f     size: %d\n", PartEdgeH.GetKey(p).Val1(), PartEdgeH.GetKey(p).Val2(),
203          PartEdgeH[p].Val1(), PartEdgeH[p].Val2(), frac,
204          PartNIdV[PartEdgeH.GetKey(p).Val1].Len());
205      } else {
206        printf("      %2d : %6d : %6d  =  %f\n", PartEdgeH.GetKey(p).Val2(),
207          PartEdgeH[p].Val1(), PartEdgeH[p].Val2(), frac);
208      }
209    }
210    printf("  all ok edges: %d / %d = %f\n\n", OkEdges, AllEdges, OkEdges/double(AllEdges));
211  }
212  void TSignNet::MakeStatusConsistent() {
213    printf("Make status consistent:\n");
214    PSignNet Net2 = TSignNet::New();
215    *Net2 = *this;
216    Net2->PrintInfo("NETWORK");
217    Net2->FlipMinusEdges(-1, 1);
218    TIntV NIdOrderV;
219    Fail;
220    TIntH NIdPosH;
221    for (int i = 0; i < NIdOrderV.Len(); i++) {
222      NIdPosH.AddDat(NIdOrderV[i], i); }
223    TIntPrV DelEdgeV;
224    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
225      if (NIdPosH.GetDat(EI.GetSrcNId()) > NIdPosH.GetDat(EI.GetDstNId())) {
226        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
227      }
228    }
229    printf("  Deleting %d/%d edges\n", DelEdgeV.Len(), GetEdges());
230    for (int e = 0; e < DelEdgeV.Len(); e++) {
231      DelEdge(DelEdgeV[e].Val1, DelEdgeV[e].Val2);
232    }
233    PrintInfo("STATUS CONSISTENT");
234  }
235  void TSignNet::EdgeSignStat() const {
236    int Plus=0, Minus=0;
237    int OneWayP=0, OneWayM=0;
238    int BWayPP=0, BWayPM=0, BWayMM=0;
239    TEdgeI EndE = EndEI();
240    for (TEdgeI EI = BegEI(); EI < EndE; EI++) {
241      const int Sign = EI();
242      TEdgeI EIX = GetEI(EI.GetDstNId(), EI.GetSrcNId());
243      if (Sign==1) { Plus++; } else { Minus++; }
244      if (EIX == EndE) {
245        if (Sign==1) { OneWayP++; } else { OneWayM++; }
246      } else {
247        if (Sign==EIX()) {
248          if (Sign==1) { BWayPP++; } else { BWayMM++; }
249        } else { BWayPM++; }
250      }
251    }
252    printf("Edges +1: %d\n", Plus);
253    printf("Edges -1: %d\n", Minus);
254    printf("One way +1:  %d\n", OneWayP);
255    printf("One way -1:  %d\n", OneWayM);
256    printf("Both way +1: %d\n", BWayPP);
257    printf("Both way -1: %d\n", BWayMM);
258    printf("Both way +1/-1: %d\n\n", BWayPM);
259  }
260  void TSignNet::PlotSignCmnNbrs(const TStr& OutFNm) const {
261    TFltFltH SupCmnH, SupCmnH2, OppCmnH, OppCmnH2;    
262    THash<TFlt, TMom> CmnFracH, CmnFracH2;  
263    PSignNet ThisPt = PSignNet((TSignNet*) this);
264    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
265      const int C = TSnap::GetCmnNbrs(ThisPt, EI.GetSrcNId(), EI.GetDstNId());
266      if (EI() == 1) { SupCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(1);
267      } else if (EI() == -1) { OppCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(0);  }
268    }
269    PSignNet PermNet = TSignNet::New();  *PermNet = *this;
270    PermNet->PermuteEdgeSigns();
271    for (TEdgeI EI = PermNet->BegEI(); EI < PermNet->EndEI(); EI++) {
272      const int C = TSnap::GetCmnNbrs(PermNet, EI.GetSrcNId(), EI.GetDstNId());
273      if (EI() == 1) { SupCmnH2.AddDat(C)++;  CmnFracH2.AddDat(C).Add(1);
274      } else if (EI() == -1) { OppCmnH2.AddDat(C)++;  CmnFracH2.AddDat(C).Add(0);  }
275    }
276    { TGnuPlot GP("cmnNbrs-"+OutFNm, "Number of common friends of votes");
277    GP.SetXYLabel("Number of common friends", "Number of votes"); GP.SetScale(gpsLog);
278    GP.AddPlot(SupCmnH, gpwLinesPoints, "Support vote");
279    GP.AddPlot(OppCmnH, gpwLinesPoints, "Oppose vote");
280    GP.AddPlot(SupCmnH2, gpwLinesPoints, "PERMUTED: Support vote");
281    GP.AddPlot(OppCmnH2, gpwLinesPoints, "PERMUTED: Oppose vote");
282    GP.SavePng(); }
283    TFltTrV V1, V2;
284    for (int i = 0; i < CmnFracH.Len(); i++) {
285      CmnFracH[i].Def();
286      const double StdErr = CmnFracH[i].GetSDev()/sqrt((double)CmnFracH[i].GetVals());
287      V1.Add(TFltTr(CmnFracH.GetKey(i), CmnFracH[i].GetMean(), StdErr));
288    }
289    for (int i = 0; i < CmnFracH2.Len(); i++) {
290      CmnFracH2[i].Def();
291      const double StdErr = CmnFracH2[i].GetSDev()/sqrt((double)CmnFracH2[i].GetVals());
292      V2.Add(TFltTr(CmnFracH2.GetKey(i), CmnFracH2[i].GetMean(), StdErr));
293    }
294    V1.Sort();  V2.Sort();
295    { TGnuPlot GP("cmnNbrsFrac-"+OutFNm, "Fraction of support votes");
296    GP.SetXYLabel("Number of common friends", "Fraction of support votes"); GP.SetScale(gpsLog);
297    GP.AddErrBar(V1, "True votes", "standard error");
298    GP.AddErrBar(V2, "PERMUTED edge signs", "standard error");
299    GP.SavePng(); }
300  }
301  PSignNet TSignNet::GetTriad(const int& N1, const int& N2, const int& N3) const {
302    PSignNet Net2 = TSignNet::New();
303    Net2->AddNode(0);  Net2->AddNode(1);  Net2->AddNode(2);
304    if (IsEdge(N1, N2)) { Net2->AddEdge(0, 1, GetEDat(N1, N2)); }
305    if (IsEdge(N2, N1)) { Net2->AddEdge(1, 0, GetEDat(N2, N1)); }
306    if (IsEdge(N1, N3)) { Net2->AddEdge(0, 2, GetEDat(N1, N3)); }
307    if (IsEdge(N3, N1)) { Net2->AddEdge(2, 0, GetEDat(N3, N1)); }
308    if (IsEdge(N2, N3)) { Net2->AddEdge(1, 2, GetEDat(N2, N3)); }
309    if (IsEdge(N3, N2)) { Net2->AddEdge(2, 1, GetEDat(N3, N2)); }
310    return Net2;
311  }
312  bool TSignNet::IsClosedTriad() const {
313    if (GetNodes() != 3) { return false; }
314    TNodeI NI = BegNI();
315    const int nid1 = NI.GetId(); NI++;
316    const int nid2 = NI.GetId(); NI++;
317    const int nid3 = NI.GetId();
318    if (IsEdge(nid1, nid2, false) && IsEdge(nid2, nid3, false) && IsEdge(nid1, nid3, false)) {
319      return true; }
320    return false;
321  }
322  bool TSignNet::IsBalanced() const {
323    if (GetEdges()!=3) { printf("%d\n", GetEdges()); }
324    IAssert(GetEdges()==3 && IsClosedTriad());
325    int Sig=1;
326    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
327      Sig *= EI();
328    }
329    if (Sig == 1) { return true; }
330    else { return false; }
331  }
332  double TSignNet::GetTriadProb(const double& PlusProb) const {
333    const int E = GetEdges();
334    int P = 0;
335    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
336      const int sign = EI();  IAssert(sign==1 || sign==-1);
337      if (sign==1) { P++; }
338    }
339    if (GetNodes()==3) { 
340      TNodeI NI = BegNI();
341      int Homo = 1;
342      if (P!=3 && P!=0 && NI.GetOutDeg()==1 && (NI++).GetOutDeg()==1 && (NI++).GetOutDeg()==1) {
343        NI = BegNI();
344        if (NI.GetId() == GetNI(GetNI(NI.GetOutNId(0)).GetOutNId(0)).GetOutNId(0)) {
345          Homo=3; 
346        }
347      }
348      return Homo * pow(PlusProb, P) * pow(1-PlusProb, E-P); 
349    }
350    return pow(PlusProb, P) * pow(1-PlusProb, E-P);
351  }
352  TIntPr TSignNet::GetNewEdge(const PSignNet& OldTriad) const {
353    IAssert(GetNodes()==3 && OldTriad->GetNodes()==3 && GetEdges()-OldTriad->GetEdges()==1);
354    PSignNet New = TSignNet::New(); *New=*this;
355    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
356      New->DelEdge(EI.GetSrcNId(), EI.GetDstNId());
357      if (TSignNet::IsSameTriad(OldTriad, New)!=-1) {
358        return TIntPr(EI.GetSrcNId(), EI.GetDstNId());
359      }
360      New->AddEdge(EI);
361    }
362    Fail;
363    return TIntPr(-1,-1);
364  }
365  int TSignNet::GetEdgeSig(const int& nid1, const int& nid2) const {
366    int e1, e2;
367    if (IsEdge(nid1, nid2)) { e1=GetEDat(nid1,nid2); } else { e1=0; }
368    if (IsEdge(nid2, nid1)) { e2=GetEDat(nid2,nid1); } else { e2=0; }
369    if (e1==0 && e2==0) { return 0; }
370    if (e1==1 && e2==0) { return 1; }
371    if (e1==-1 && e2==0) { return 2; }
372    if (e1==0 && e2==1) { return 3; }
373    if (e1==0 && e2==-1) { return 4; }
374    if (e1==1 && e2==1) { return 5; }
375    if (e1==1 && e2==-1) { return 6; }
376    if (e1==-1 && e2==1) { return 7; }
377    if (e1==-1 && e2==-1) { return 8; }
378    Fail; return -1;
379  }
380  TChA TSignNet::GetEdgeStr(const int& nid1, const int& nid2) const {
381    const int sig = GetEdgeSig(nid1, nid2);
382    return GetEdgeStr(sig);
383  }
384  TIntTr TSignNet::GetTriadSig(const bool& Canonical) const {
385    if (GetNodes()!=3) { return TIntTr(); }
386    TNodeI NI = BegNI();
387    const int nid1 = NI.GetId(); NI++;
388    const int nid2 = NI.GetId(); NI++;
389    const int nid3 = NI.GetId();
390    const int e1 = GetEdgeSig(nid1, nid2);
391    const int e2 = GetEdgeSig(nid2, nid3);
392    const int e3 = GetEdgeSig(nid3, nid1);
393    if (! Canonical) {
394      return TIntTr(e1, e2, e3); }
395    else { 
396      const TIntTr MinTr = TMath::Mn(TIntTr(e1, e2, e3), TIntTr(e2, e3, e1), TIntTr(e3, e1, e2));
397      const int e1a = GetEdgeSig(nid1, nid3);
398      const int e2a = GetEdgeSig(nid3, nid2);
399      const int e3a = GetEdgeSig(nid2, nid1);
400      return TMath::Mn(MinTr, TMath::Mn(TIntTr(e1a, e2a, e3a), TIntTr(e2a, e3a, e1a), TIntTr(e3a, e1a, e2a)));
401    }
402  }
403  TChA TSignNet::GetTriadStr(const bool& Canonical) const {
404    return GetTriadStr(GetTriadSig(Canonical));
405  }
406  TChA TSignNet::GetEdgeStr(const int& EdgeSig) {
407    switch(EdgeSig) {
408      case 1 : return "+o";
409      case 2 : return "-o";
410      case 3 : return "o+";
411      case 4 : return "o-";
412      case 5 : return "++";
413      case 6 : return "+-";
414      case 7 : return "-+";
415      case 8 : return "--";
416      default : return TChA();
417    }
418  }
419  TChA TSignNet::GetTriadStr(const TIntTr& TriadSig) {
420    return GetEdgeStr(TriadSig.Val1)+"\t"+GetEdgeStr(TriadSig.Val2)+"\t"+GetEdgeStr(TriadSig.Val3);
421  }
422  int TSignNet::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2) {
423    static THash<TInt, TVec<TIntV> > PermH;
424    if (PermH.Empty()) {
425      PermH.AddDat(2).Add(TIntV::GetV(0,1));
426      PermH.AddDat(2).Add(TIntV::GetV(1,0));
427      PermH.AddDat(3).Add(TIntV::GetV(0,1,2));
428      PermH.AddDat(3).Add(TIntV::GetV(0,2,1));
429      PermH.AddDat(3).Add(TIntV::GetV(1,0,2));
430      PermH.AddDat(3).Add(TIntV::GetV(1,2,0));
431      PermH.AddDat(3).Add(TIntV::GetV(2,0,1));
432      PermH.AddDat(3).Add(TIntV::GetV(2,1,0));
433    }
434    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) { return -1; }
435    IAssert(Net1->GetNodes()==2 || Net1->GetNodes()==3);
436    const TVec<TIntV>& PermV = PermH.GetDat(Net1->GetNodes());
437    for (int p = 0; p < PermV.Len(); p++) {
438      const TIntV& Perm = PermV[p];
439      TSignNet::TEdgeI EndEI2 = Net2->EndEI();
440      int i = 0;
441      bool Ok = true;
442      for (TSignNet::TNodeI NI1 = Net1->BegNI(); NI1 < Net1->EndNI(); NI1++, i++) {
443        TSignNet::TNodeI NI2 = Net2->GetNI(Perm[i]);
444        if (NI1.GetOutDeg() != NI2.GetOutDeg() || NI1.GetInDeg() != NI2.GetInDeg()) { Ok=false; break; }
445        for (int e = 0; e < NI1.GetOutDeg(); e++) {
446          const TSignNet::TEdgeI EI2 = Net2->GetEI(NI2.GetId(), Perm[NI1.GetOutNId(e)]);
447          if (EI2 == EndEI2 || NI1.GetOutEDat(e) != EI2()) { Ok=false; break; }
448        }
449      }
450      if (Ok) { return p; }
451    }
452    return -1;
453  }
454  void TSignNet::CountSignedTriads(const TStr& OutFNm) const {
455    printf("Count signed triads");
456    TVec<PSignNet> TriadIdV;
457    TVec<PSignNet> TriadIdV2;
458    TIntH TriadIdCntH;
459    TIntV NbrV;
460    PSignNet ThisPt = PSignNet((TSignNet*) this);
461    double AllPlusE=0, AllE = GetEdges();
462    int c=0, Decile=int(AllE/100);
463    TIntH UnSignCntH;
464    TIntH SignToUnsignH;
465    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
466      TSnap::GetCmnNbrs(ThisPt, EI.GetSrcNId(), EI.GetDstNId(), NbrV);
467      for (int n = 0; n < NbrV.Len(); n++) {
468        PSignNet TriadNet = GetTriad(EI.GetSrcNId(), EI.GetDstNId(), NbrV[n]);
469        int TriadId = -1;
470        for (int i = 0; i < TriadIdV.Len() && TriadId==-1; i++) {
471          if (IsSameTriad(TriadIdV[i], TriadNet)!=-1) { TriadId=i; break; } }
472        if (TriadId==-1) { TriadId=TriadIdV.Len();  TriadIdV.Add(TriadNet); }
473        TriadIdCntH.AddDat(TriadId) += 1;
474        TriadNet = GetTriad(EI.GetSrcNId(), EI.GetDstNId(), NbrV[n]);
475        TriadNet->SetAllEDat(1);
476        int TriadId2 = -1;
477        for (int i = 0; i < TriadIdV2.Len() && TriadId2==-1; i++) {
478          if (IsSameTriad(TriadIdV2[i], TriadNet)!=-1) { TriadId2=i; break; } }
479        if (TriadId2==-1) { TriadId2=TriadIdV2.Len();  TriadIdV2.Add(TriadNet); }
480        UnSignCntH.AddDat(TriadId2) += 1;
481        SignToUnsignH.AddDat(TriadId, TriadId2);
482      }
483      if (EI() == 1) { AllPlusE += 1; }
484      if (++c % Decile ==0) { printf("."); }
485    }
486    TVec<TTriple<TInt, TChA, TInt> > SortIdV;
487    for (int t = 0; t < TriadIdCntH.Len(); t++) {
488      PSignNet Net = TriadIdV[TriadIdCntH.GetKey(t)];
489      const int E = Net->GetEdges();
490      TriadIdCntH[t].Val /= E;
491      SortIdV.Add(TTriple<TInt, TChA, TInt>(Net->GetEdges(), Net->GetTriadStr(true), TriadIdCntH.GetKey(t)));
492    }
493    for (int u=0; u < UnSignCntH.Len(); u++) {
494      const int E = TriadIdV2[UnSignCntH.GetKey(u)]->GetEdges();
495      UnSignCntH[u].Val /= E;
496      printf("unsigned count:  %d\t%d\t%d\n", UnSignCntH.GetKey(u)(), E, UnSignCntH[u]());
497    }
498    SortIdV.Sort();
499    const double PlusProb = AllPlusE / AllE;
500    FILE *T = fopen(TStr::Fmt("SignTriad-%s.tab", OutFNm.CStr()).CStr(), "wt");
501    fprintf(T, "AB\tBC\tCA\tCount\tE[Count]\tSurprise\tTriadProb\n");
502    printf("%d triads\n", TriadIdCntH.Len());
503    printf("plus prob %d / %d = %f\n", int(AllPlusE), int(AllE), PlusProb);
504    for (int t = 0; t < SortIdV.Len(); t++) {
505      const int Id = SortIdV[t].Val3;
506      int PlusE = 0;
507      PSignNet TriadNet = TriadIdV[Id];
508      TStr FNm = TStr::Fmt("SignTriad-%s-%02d", OutFNm.CStr(), t+1);
509      FILE *F = fopen(TStr(FNm+".dot").CStr(), "wt");
510      fprintf(F, "digraph G {\n");
511      fprintf(F, "  graph [splines=true, overlap=false]\n  node  [shape=ellipse, width=0.3, height=0.3 label=\"\"]\n");
512      for (TEdgeI EI = TriadNet->BegEI(); EI < TriadNet->EndEI(); EI++) {
513        fprintf(F, "  n%d -> n%d [label=\"%s\" len=2];\n", EI.GetSrcNId(), EI.GetDstNId(),  EI()==1?"+":"--");
514        if (EI() == 1) { PlusE++; }
515      }
516      const double TriadCnt = TriadIdCntH.GetDat(Id);
517      const double TriadProb = TriadNet->GetTriadProb(PlusProb);
518      const double UnSignCnt = UnSignCntH.GetDat(SignToUnsignH.GetDat(Id)).Val;
519      const double ExpCnt = TriadProb * UnSignCnt; 
520      const double Surp = (TriadCnt-ExpCnt) / sqrt(UnSignCnt*TriadProb*(1.0-TriadProb));
521      fprintf(F, "  label = \"T=%d, E[T]=%d, S=%.1f\";\n}\n", int(TriadCnt), int(ExpCnt), Surp);
522      fclose(F);
523      TGraphViz::DoLayout(FNm+".dot", FNm+".gif",  gvlNeato);
524      fprintf(T, "%s\t%d\t%d\t%.2f\t%f\n", TriadNet->GetTriadStr(true).CStr(), int(TriadCnt), int(ExpCnt), Surp, TriadProb);
525    }
526    fclose(T);
527    printf("\n");
528  }
529  void TSignNet::PlotGraphProp(const TStr& OutFNm) const {
530    PSignNet Net = GetSignSubNet(+1);
531    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
532    TSnap::PlotOutDegDistr(Net, OutFNm+"-plus");
533    TSnap::PlotInDegDistr(Net, OutFNm+"-plus");
534    TSnap::PlotWccDistr(Net, OutFNm+"-plus");
535    TSnap::PlotClustCf(Net, OutFNm+"-plus");
536    const int NPlus = Net->GetEdges();
537    Net = TSnap::GetRndESubGraph(PSignNet((TSignNet*) this), NPlus);
538    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
539    TSnap::PlotOutDegDistr(Net, OutFNm+"-plusRnd");
540    TSnap::PlotInDegDistr(Net, OutFNm+"-plusRnd");
541    TSnap::PlotWccDistr(Net, OutFNm+"-plusRnd");
542    TSnap::PlotClustCf(Net, OutFNm+"-plusRnd");
543    Net = GetSignSubNet(-1);
544    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
545    TSnap::PlotOutDegDistr(Net, OutFNm+"-minus");
546    TSnap::PlotInDegDistr(Net, OutFNm+"-minus");
547    TSnap::PlotWccDistr(Net, OutFNm+"-minus");
548    TSnap::PlotClustCf(Net, OutFNm+"-minus");
549    const int NMinus = Net->GetEdges();
550    Net = TSnap::GetRndESubGraph(PSignNet((TSignNet*) this), NMinus);
551    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
552    TSnap::PlotOutDegDistr(Net, OutFNm+"-minusRnd");
553    TSnap::PlotInDegDistr(Net, OutFNm+"-minusRnd");
554    TSnap::PlotWccDistr(Net, OutFNm+"-minusRnd");
555    TSnap::PlotClustCf(Net, OutFNm+"-minusRnd");
556  }
557  void TSignNet::PlotInOutPlusFrac(const TStr& OutFNm) const {
558    THash<TFltPr, TInt> CntH, Cnt2H;
559    THash<TFltPr, TInt> FracH, Frac2H;
560    const int FracRes = 100;
561    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
562      int PlusIn=1, PlusOut=1, MinusIn=1, MinusOut=1;
563      for (int i = 0; i < NI.GetOutDeg(); i++) {
564        if (NI.GetOutEDat(i)==1) { PlusOut++; } else { MinusOut++; } }
565      for (int i = 0; i < NI.GetInDeg(); i++) {
566        if (NI.GetInEDat(i)==1) { PlusIn++; } else { MinusIn++; } }
567      CntH.AddDat(TFltPr(PlusOut+TInt::Rnd.GetUniDev(), PlusIn+TInt::Rnd.GetUniDev())) += 1;
568      Cnt2H.AddDat(TFltPr(MinusOut+TInt::Rnd.GetUniDev(), MinusIn+TInt::Rnd.GetUniDev())) += 1;
569      FracH.AddDat(TFltPr(TInt::Rnd.GetUniDev()+int(FracRes*PlusOut/double(NI.GetOutDeg()+1)), TInt::Rnd.GetUniDev()+int(FracRes*PlusIn/double(NI.GetInDeg()+1)))) += 1;
570      Frac2H.AddDat(TFltPr(TInt::Rnd.GetUniDev()+int(FracRes*MinusOut/double(NI.GetOutDeg()+1)), TInt::Rnd.GetUniDev()+int(FracRes*MinusIn/double(NI.GetInDeg()+1)))) += 1;
571    }
572    TFltPrV V1;  TFltPrV V2;
573    CntH.GetKeyV(V1);
574    FracH.GetKeyV(V2);
575    TGnuPlot::PlotValV(V1, "plusCnt."+OutFNm, OutFNm, "number of pluses out", "number of pluses in", gpsLog10XY, false, gpwPoints);
576    TGnuPlot::PlotValV(V2, "plusFrac."+OutFNm, OutFNm, "fraction of pluses out", "fraction of pluses in", gpsAuto, false, gpwPoints);
577    Cnt2H.GetKeyV(V1);
578    Frac2H.GetKeyV(V2);
579    TGnuPlot::PlotValV(V1, "minusCnt."+OutFNm, OutFNm, "number of minuses out", "number of minuses in", gpsLog10XY, false, gpwPoints);
580    TGnuPlot::PlotValV(V2, "minusFrac."+OutFNm, OutFNm, "fraction of minuses out", "fraction of minuses in", gpsAuto, false, gpwPoints);
581  }
582  void TSignNet::SavePajek(const TStr& OutFNm) {
583    const TStrV ClrV = TStrV::GetV("Gray45", "Green", "Magenta", "Cyan", "OliveGreen", "NavyBlue", "Orange", "Purple", "Brown");
584    const int Clrs = ClrV.Len();
585    TIntH NodeClr;
586    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NodeClr.AddKey(NI()); }
587    FILE *F = fopen(OutFNm.CStr(), "wt");
588    TIntH NIdToIdH(GetNodes(), true);
589    fprintf(F, "*Vertices %d\n", GetNodes());
590    int i = 0;
591    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, i++) {
592      fprintf(F, "%d  \"%d\" ic %s fos 10\n", i+1, NI.GetId(), ClrV[NodeClr.GetKeyId(NI())%Clrs].CStr());
593      NIdToIdH.AddDat(NI.GetId(), i+1);
594    }
595    fprintf(F, "*Arcs %d\n", GetEdges()); 
596    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
597      const int NId = NIdToIdH.GetDat(NI.GetId());
598      for (int e = 0; e < NI.GetOutDeg(); e++) {
599        TStr EdgeColor = "Gray45";
600        if (NI()!=-1 && NI.GetOutNDat(e)!=-1) { 
601          if (NI.GetOutEDat(e)==-1) {
602            EdgeColor = NI()!=NI.GetOutNDat(e) ? "Blue":"Red"; }  
603          else if (NI.GetOutEDat(e)==1) {
604            EdgeColor = NI()==NI.GetOutNDat(e) ? "Blue":"Red"; }  
605        }
606        fprintf(F, "%d %d %g c %s\n", NId, NIdToIdH.GetDat(NI.GetOutNId(e)).Val, 1.0, EdgeColor.CStr());
607      }
608    }
609    fclose(F);
610  }
611  void TSignNet::SaveTxt(const TStr& OutFNm) const {
612    FILE *F = fopen(OutFNm.CStr(), "wt");
613    fprintf(F, "# Signed network. %d nodes, %d edges\n", GetNodes(), GetEdges());
614    fprintf(F, "# Source\tDestination\tEdgeSign\n");
615    THashSet<TInt> NIdSet;
616    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
617      NIdSet.AddKey(EI.GetSrcNId());  NIdSet.AddKey(EI.GetDstNId());
618      fprintf(F, "%d\t%d\t%d\n", NIdSet.GetKeyId(EI.GetSrcNId()), NIdSet.GetKeyId(EI.GetDstNId()), EI());
619    }
620    fclose(F);
621  }
622  void TSignNet::DrawGraphViz(const TStr& OutFNm, const TStr& Desc, const bool& NodeLabels, const bool& EdgeLabels, const bool& SaveDir) {
623    FILE *F = fopen(TStr(OutFNm+".dot").CStr(), "wt");
624    if (! SaveDir) { fprintf(F, "graph G {\n"); }
625    else { fprintf(F, "digraph G {\n"); }
626    fprintf(F, "  graph [splines=true, overlap=false]\n");
627    fprintf(F, "  node  [shape=ellipse, width=0.3, height=0.3 %s]\n", NodeLabels?"":", label=\"\"");
628    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
629      fprintf(F, "  %d %s;\n", NI.GetId(), NodeLabels?TStr::Fmt("[label=\"%d : %d\"]", NI.GetId(), NI()).CStr():"");
630    }
631    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
632      for (int e = 0; e < NI.GetOutDeg(); e++) {
633        if (! SaveDir) {
634          if (! IsEdge(NI.GetOutNId(e), NI.GetId())) {
635            fprintf(F, "  %d -- %d [dir=\"forward\"%s];\n", NI.GetId(), NI.GetOutNId(e),
636              EdgeLabels?TStr::Fmt(", label=\"%d\"", GetEDat(NI.GetId(), NI.GetOutNId(e))).CStr():"");  
637          } else if (NI.GetId() < NI.GetOutNId(e)) {
638            fprintf(F, "  %d -- %d %s;\n", NI.GetId(), NI.GetOutNId(e),
639              EdgeLabels?TStr::Fmt("[label=\"%d/%d\"]", GetEDat(NI.GetId(), NI.GetOutNId(e)), 
640              GetEDat(NI.GetOutNId(e), NI.GetId())).CStr():"");  
641          }
642        } else {
643          fprintf(F, "  %d -> %d %s;\n", NI.GetId(), NI.GetOutNId(e),
644            EdgeLabels?TStr::Fmt("[label=\"%d\"]", GetEDat(NI.GetId(), NI.GetOutNId(e))).CStr():"");
645        }
646      }
647    }
648    if (! Desc.Empty()) {
649      fprintf(F, "  label = \"\\n%s\\n\";\n", Desc.CStr());
650    }
651    fprintf(F, "  fontsize=24;\n");
652    fprintf(F, "}\n");
653    fclose(F);
654    TGraphViz::DoLayout(OutFNm+".dot", OutFNm+".gif",  gvlNeato);
655  }
656  void TSignNet::PrintInfo(const TStr& Desc) const {
657    if (! Desc.Empty()) { printf("%s\n", Desc.CStr()); }
658    else { printf("Signed network\n"); }
659    TIntH SignH;
660    int edges = 0;
661    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
662      SignH.AddDat(EI()) += 1;
663      edges++;
664    }
665    SignH.SortByKey();
666    printf("  nodes: %d\n", GetNodes());
667    printf("  edges: %d\n", edges);
668    for (int i = 0; i < SignH.Len(); i++) {
669      printf("  %2d: %d\n", SignH.GetKey(i), SignH[i]);
670    }
671    printf("\n");
672  }
673  void TSignNet::Dump() const {
674    printf("Net (%d, %d)\n", GetNodes(), GetEdges());
675    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
676      printf("  %d\t%d\t%d\n", EI.GetSrcNId(), EI.GetDstNId(), EI());
677    }
678    printf("\n");
679  }
680  bool TSignMicroEvol::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2, const TIntV& Perm) const {
681    int i = 0;
682    TSignNet::TEdgeI EndEI2 = Net2->EndEI();
683    for (TSignNet::TNodeI NI1 = Net1->BegNI(); NI1 < Net1->EndNI(); NI1++, i++) {
684      TSignNet::TNodeI NI2 = Net2->GetNI(Perm[i]);
685      if (NI1.GetOutDeg() != NI2.GetOutDeg() || NI1.GetInDeg() != NI2.GetInDeg()) {
686        return false;
687      }
688      for (int e = 0; e < NI1.GetOutDeg(); e++) {
689        const TSignNet::TEdgeI EI2 = Net2->GetEI(NI2.GetId(), Perm[NI1.GetOutNId(e)]);
690        if (EI2 == EndEI2 || NI1.GetOutEDat(e) != EI2()) {
691          return false;
692        }
693      }
694    }
695    return true;
696  }
697  void TSignNet::GetPartOverlap(const TVec<TIntV>& PartNIdV1, const TVec<TIntV>& PartNIdV2) {
698    printf("Partition overlap:\n");
699    for (int p2 = 0; p2 < PartNIdV2.Len(); p2++) {
700      printf("\t%6d(%d)", p2, PartNIdV2[p2].Len());
701    }
702    printf("\n");
703    for (int p1 = 0; p1 < PartNIdV1.Len(); p1++) {
704      printf("%6d(%d)\t", p1, PartNIdV1[p1].Len());
705      for (int p2 = 0; p2 < PartNIdV2.Len(); p2++) {
706        printf("%9d\t", PartNIdV1[p1].IntrsLen(PartNIdV2[p2]));
707      }
708      printf("\n");
709    }
710  }
711  PSignNet TSignNet::LoadEpinions(const TStr& FNm) {
712    TSsParser Ss(FNm, ssfTabSep);
713    PSignNet Net = TSignNet::New();
714    while (Ss.Next()) {
715      const int src = Ss.GetInt(0);
716      const int dst = Ss.GetInt(1);
717      if (src == dst) { continue; } 
718      if (!Net->IsNode(Ss.GetInt(0))) {
719        Net->AddNode(Ss.GetInt(0));
720      }
721      if (!Net->IsNode(Ss.GetInt(0))) {
722        Net->AddNode(Ss.GetInt(1));
723      }
724      Net->AddEdge(Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2));
725    }
726    return Net;
727  }
728  PSignNet TSignNet::LoadSlashdot(const TStr& InFNm) {
729    THashSet<TChA> NIdSet;
730    TChA LnStr;
731    TVec<char *> WrdV;
732    int Sign;
733    PSignNet Net = TSignNet::New();
734    for (TFIn FIn(InFNm); FIn.GetNextLn(LnStr); ) {
735      if (LnStr.Empty() || LnStr[0]=='#') { continue; }
736      LnStr.ToLc();
737      TStrUtil::SplitOnCh(LnStr, WrdV, '\t', false);
738      NIdSet.AddKey(WrdV[0]);
739      if (strcmp(WrdV[1], "friends")==0) { Sign = 1; }
740      else if (strcmp(WrdV[1], "fans")==0) { continue; } 
741      else if (strcmp(WrdV[1], "foes")==0) { Sign = -1; } else { Fail; }
742      const int SrcNId = NIdSet.AddKey(WrdV[0]);
743      if (! Net->IsNode(SrcNId)) {
744        Net->AddNode(SrcNId); }
745      for (int e = 2; e < WrdV.Len(); e++) {
746        const int DstNId = NIdSet.AddKey(WrdV[e]);
747        if (SrcNId != DstNId && ! Net->IsEdge(SrcNId, DstNId)) {
748          Net->AddNode(DstNId);
749          Net->AddEdge(SrcNId, DstNId, Sign);
750        }
751      }
752    }
753    TSnap::PrintInfo(Net, InFNm);
754    return Net;
755  }
756  PSignNet TSignNet::GetSmallNet() {
757    PSignNet Net = TSignNet::New();
758    for (int i = 0; i < 5; i ++) { Net->AddNode(); }
759    Net->AddEdge(0,1, +1); Net->AddEdge(1,2, +1); Net->AddEdge(2,0, -1);  Net->AddEdge(0,2, -1);
760    Net->AddEdge(1,3, +1);
761    Net->AddEdge(3,4, +1); Net->AddEdge(4,3, +1);
762     Net->AddEdge(1,4, +1);
763    return Net;
764  }
765  int THopfield::MinEnergy(const int& NPart) {
766    TIntV NIdV(Net->GetNodes(), 0);
767    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
768      NIdPartH.AddDat(NI.GetId(), TInt::Rnd.GetUniDevInt(NPart));
769      NIdV.Add(NI.GetId());
770    }
771    TIntPrV EnergyV(NPart); 
772    int Flips = 0;
773    for (int iter = 0; iter < 100; iter++) {
774      NIdV.Shuffle(TInt::Rnd);
775      Flips = 0;
776      for (int n = 0; n < NIdV.Len(); n++) {
777        TSignNet::TNodeI NI = Net->GetNI(NIdV[n]);
778        for (int p = 0; p < NPart; p++) {
779          EnergyV[p].Val1=0;  EnergyV[p].Val2=p; }
780        for (int e = 0; e < NI.GetOutDeg(); e++) {
781          const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
782          const int Sign = NI.GetOutEDat(e);
783          EnergyV[DstPart].Val1 += Sign;
784        }
785        EnergyV.Sort(false); 
786        const int NewPart = EnergyV[0].Val2;
787        if (NIdPartH.GetDat(NI.GetId()) != NewPart) { 
788          NIdPartH.AddDat(NI.GetId(), NewPart);
789          Flips++;
790        }
791      }
792    }
793    int OkMns=0, OkPls=0, AllMns=0, AllPls=0;
794    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
795      const int SrcPart = NIdPartH.GetDat(NI.GetId());
796      for (int e = 0; e < NI.GetOutDeg(); e++) {
797        const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
798        const int Vote = NI.GetOutEDat(e);
799        if (Vote < 0) {
800          if (DstPart != SrcPart) { OkMns++; }
801          AllMns++; }
802        if (Vote > 0) {
803          if (DstPart == SrcPart) { OkPls++; }
804          AllPls++;
805        }
806      }
807    }
808    if (OkPls+OkMns > MxEnergy) {
809      MxEnergy = OkPls+OkMns;
810      BestPart = NIdPartH;
811    }
812    return OkPls+OkMns;
813  }
814  int THopfield::FindStableSet(const int& NPart, const int& NRuns) {
815    NIdPartH.Clr();
816    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
817      NIdPartH.AddDat(NI.GetId(), 0);
818    }
819    TIntPrV PartSzV(NPart);
820    int MxOk=0, SumOk=0;
821    printf("Find stable set %d runs\n", NRuns);
822    for (int runs = 0; runs < NRuns; runs++) {
823      const int OkEdges = MinEnergy(NPart);
824      EnergDistr.AddDat(OkEdges) += 1;
825      for (int i = 0; i < NPart; i++) {
826        PartSzV[i]=TIntPr(0,i); }
827      for (int i = 0; i < NIdPartH.Len(); i++) {
828        PartSzV[NIdPartH[i]].Val1 += 1; }
829      PartSzV.Sort(false); 
830      for (int i = 0; i < NIdPartH.Len(); i++) {
831        const int PartId = PartSzV[NIdPartH[i]].Val2;
832        NIdPartCnt.AddDat(NIdPartH.GetKey(i))[PartId] += 1;
833      }
834      SumOk += OkEdges;
835      MxOk = TMath::Mx(MxOk, OkEdges);
836    }
837    printf("  Best: %d   Average: %d\n", MxOk, SumOk/NRuns);
838    return MxOk;
839  }
840  void THopfield::GetStableSet(const int& Tresh, TVec<TIntV>& PartNIdV) {
841    PartNIdV.Gen(NIdPartCnt[0].Len());
842    for (int i = 0; i < NIdPartCnt.Len(); i++) {
843      const int MxPart = NIdPartCnt[i].FindMx();
844      if (NIdPartCnt[i][MxPart] >= Tresh) {
845        PartNIdV[MxPart].Add(NIdPartCnt.GetKey(i));
846      }
847    }
848    while (! PartNIdV.Empty() && PartNIdV.Last().Empty()) {
849      PartNIdV.DelLast();
850    }
851    for (int p = 0; p < PartNIdV.Len(); p++) {
852      PartNIdV[p].Sort();
853    }
854  }
855  void THopfield::PlotPartStab(const TStr& FNm, TStr Desc) const {
856    int runs = 0;
857    for (int r = 0; r < EnergDistr.Len(); r++) {
858      runs+=EnergDistr[r];
859    }
860    if (Desc.Empty()) { Desc = FNm; }
861    for (int part = 0; part < NIdPartCnt[0].Len(); part++) {
862      TIntH PartH;
863      for (int n = 0; n < NIdPartCnt.Len(); n++) {
864        if (NIdPartCnt[n][part]>0) {
865          PartH.AddDat(NIdPartCnt[n][part]) += 1;
866        }
867      }
868      if (PartH.Len() <= 1) { continue; }
869      TGnuPlot::PlotValCntH(PartH, TStr::Fmt("partStab-%s-%d", FNm.CStr(), part), TStr::Fmt("%s: Partition %d stability. %d runs. Best energy: %d",
870        Desc.CStr(), part, runs, MxEnergy), "Number of times in the partition", "Number of nodes", gpsAuto, false);
871    }
872    TGnuPlot::PlotValCntH(EnergDistr, "hopfEnerg-"+FNm, TStr::Fmt("%s: Hopfield energy distribution over %d runs. Max: %d", Desc.CStr(), runs, MxEnergy),
873      TStr::Fmt("Energy (number of satisfied edges, out of %d", Net->GetEdges()), "Number of solutions");
874  }
875  void THopfield::DumpPartStat() const {
876    int OkMns=0, OkPls=0, AllMns=0, AllPls=0;
877    TIntH OkPlsH, AllPlsH, OkMnsH, AllMnsH;
878    int NPart=0;
879    for (int i = 0; i < NIdPartH.Len(); i++) {
880      NPart = TMath::Mx(NIdPartH[i].Val, NPart);
881    }
882    for (int p = 0; p < NPart; p++) {
883      OkPlsH.AddDat(p,0); AllPlsH.AddDat(p,0);
884      OkMnsH.AddDat(p,0); AllMnsH.AddDat(p,0);
885    }
886    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
887      const int SrcPart = NIdPartH.GetDat(NI.GetId());
888      for (int e = 0; e < NI.GetOutDeg(); e++) {
889        const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
890        const int Vote = NI.GetOutEDat(e);
891        if (Vote == -1) {
892          if (DstPart != SrcPart) { OkMnsH.AddDat(SrcPart) += 1;  OkMns++; }
893          AllMnsH.AddDat(SrcPart) += 1;  AllMns++; }
894        if (Vote == +1) {
895          if (DstPart == SrcPart) { OkPlsH.AddDat(SrcPart) += 1;  OkPls++; }
896          AllPlsH.AddDat(SrcPart) += 1;  AllPls++;
897        }
898      }
899    }
900    printf("\nSatisfied edges: + : %5d / %5d  = %f\n", OkPls, AllPls, double(OkPls)/double(AllPls));
901    printf(  "                 - : %5d / %5d  = %f\n", OkMns, AllMns, double(OkMns)/double(AllMns));
902    TIntH PartCntH;
903    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
904      PartCntH.AddDat(NIdPartH.GetDat(NI.GetId())) += 1; }
905    PartCntH.SortByKey();
906    for (int p = 0; p < PartCntH.Len(); p++) {
907      printf("  part %2d : %5d (%.4f) nodes: +: %25s    -: %25s\n", p, PartCntH[p], PartCntH[p]/double(NIdPartH.Len()),
908        TStr::Fmt("%5d/%d=%.4f", OkPlsH.GetDat(PartCntH.GetKey(p)), AllPlsH.GetDat(PartCntH.GetKey(p)), OkPlsH.GetDat(PartCntH.GetKey(p))/double(AllPlsH.GetDat(PartCntH.GetKey(p)))).CStr(),
909        TStr::Fmt("%5d/%d=%.4f", OkMnsH.GetDat(PartCntH.GetKey(p)), AllMnsH.GetDat(PartCntH.GetKey(p)), OkMnsH.GetDat(PartCntH.GetKey(p))/double(AllMnsH.GetDat(PartCntH.GetKey(p)))).CStr() );
910    }
911  }
912  void TSignMicroEvol::BuildPerms() {
913    PermH.Clr();
914    PermH.AddDat(2).Add(TIntV::GetV(0,1));
915    PermH.AddDat(2).Add(TIntV::GetV(1,0));
916    PermH.AddDat(3).Add(TIntV::GetV(0,1,2));
917    PermH.AddDat(3).Add(TIntV::GetV(0,2,1));
918    PermH.AddDat(3).Add(TIntV::GetV(1,0,2));
919    PermH.AddDat(3).Add(TIntV::GetV(1,2,0));
920    PermH.AddDat(3).Add(TIntV::GetV(2,0,1));
921    PermH.AddDat(3).Add(TIntV::GetV(2,1,0));
922  }
923  TSignMicroEvol::TSignMicroEvol(PSignNet NetPt) : Network(NetPt) {
924    TransNet = TTransitionNet::New();
925    BuildPerms();
926  }
927  TSignMicroEvol::TSignMicroEvol(TSIn& SIn) {
928    TInt Nets(SIn);
929    for (int n = 0; n < Nets; n++) {
930      TriadIdV.Add(TSignNet::Load(SIn));
931    }
932    TransNet = TTransitionNet::Load(SIn);
933    TInt Diads(SIn);
934    for (int d = 0; d < Diads; d++) {
935      OpnTriadV.Add(TSignNet::Load(SIn));
936    }
937    CloseTriadH.Load(SIn);
938    Triad3to4H.Load(SIn);
939    BuildPerms();
940  }
941  void TSignMicroEvol::Save(TSOut& SOut) const {
942    SOut.Save(TriadIdV.Len());
943    for (int n = 0; n < TriadIdV.Len(); n++) {
944      TriadIdV[n]->Save(SOut);
945    }
946    TransNet->Save(SOut);
947    SOut.Save(OpnTriadV.Len());
948    for (int d = 0; d < OpnTriadV.Len(); d++) {
949      OpnTriadV[d]->Save(SOut);
950    }
951    CloseTriadH.Save(SOut);
952    Triad3to4H.Save(SOut);
953  }
954  PSignNet TSignMicroEvol::GetSubGraph(const int& N1, const int& N2) {
955    PSignNet Net2 = TSignNet::New();
956    Net2->AddNode(0);  Net2->AddNode(1);
957    if (Network->IsEdge(N1, N2)) { Net2->AddEdge(0, 1, Network->GetEDat(N1, N2)); }
958    if (Network->IsEdge(N2, N1)) { Net2->AddEdge(1, 0, Network->GetEDat(N2, N1)); }
959    return Net2;
960  }
961  PSignNet TSignMicroEvol::GetSubGraph(const int& N1, const int& N2, const int& N3) {
962    PSignNet Net2 = TSignNet::New();
963    Net2->AddNode(0);  Net2->AddNode(1);  Net2->AddNode(2);
964    if (Network->IsEdge(N1, N2)) { Net2->AddEdge(0, 1, Network->GetEDat(N1, N2)); }
965    if (Network->IsEdge(N2, N1)) { Net2->AddEdge(1, 0, Network->GetEDat(N2, N1)); }
966    if (Network->IsEdge(N1, N3)) { Net2->AddEdge(0, 2, Network->GetEDat(N1, N3)); }
967    if (Network->IsEdge(N3, N1)) { Net2->AddEdge(2, 0, Network->GetEDat(N3, N1)); }
968    if (Network->IsEdge(N2, N3)) { Net2->AddEdge(1, 2, Network->GetEDat(N2, N3)); }
969    if (Network->IsEdge(N3, N2)) { Net2->AddEdge(2, 1, Network->GetEDat(N3, N2)); }
970    return Net2;
971  }
972  void TSignMicroEvol::CountTriadClose(const int& SrcNId, const int& DstNId, const int& Sign, const double& SrcOutPlusProb,
973                               const double& DstInPlusProb, const bool& OnlySimpleTriads) {
974    IAssert(! Network->IsEdge(SrcNId, DstNId));
975    if (! Network->IsEdge(DstNId, SrcNId)) {
976      TIntV NbrV;
977      TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
978      for (int n = 0; n < NbrV.Len(); n++) {
979        PSignNet Net1 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
980        PSignNet Net2 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
981        Net2->AddEdge(0, 1, Sign); 
982        const int Net1Id = GetTriadId(Net1);
983        const int Net2Id = GetTriadId(Net2);
984        if (! TransNet->IsNode(Net1Id)) { TransNet->AddNode(Net1Id, 0); }
985        if (! TransNet->IsNode(Net2Id)) { TransNet->AddNode(Net2Id, 0); }
986        if (! TransNet->IsEdge(Net1Id, Net2Id)) { TransNet->AddEdge(Net1Id, Net2Id); }
987        TransNet->GetNDat(Net1Id) += 1;
988        TransNet->GetNDat(Net2Id) += 1;
989        { TTransStat& Stat = TransNet->GetEDat(Net1Id, Net2Id);
990        if (Sign == +1) { Stat.SumWgt += SrcOutPlusProb; }
991        else { Stat.SumWgt+= 1-SrcOutPlusProb; }
992        Stat.Cnt++;  Stat.VarSq += SrcOutPlusProb*(1-SrcOutPlusProb); }
993        { const int TrId = GetOpnTriadId(Net1);
994        TCloseStat& ClsStat = CloseTriadH.AddDat(TrId);
995        if (Sign == +1) { ClsStat.PlsCnt++; }
996        else { ClsStat.MnsCnt++; }
997        ClsStat.OutSumWgt += SrcOutPlusProb;
998        ClsStat.OutVarSq += SrcOutPlusProb*(1-SrcOutPlusProb);
999        ClsStat.InSumWgt += DstInPlusProb;
1000        ClsStat.InVarSq += DstInPlusProb*(1-DstInPlusProb);
1001        ClsStat.OutPlusPH.AddDat(int(SrcOutPlusProb*50)*2) += 1;
1002        ClsStat.InPlusPH.AddDat(int(DstInPlusProb*50)*2) += 1; }
1003      }
1004    } else { 
1005      RepLinkCntH.AddDat(TIntPr(Network->GetEDat(DstNId, SrcNId), Sign)).Val1 += 1;
1006      RepLinkCntH.AddDat(TIntPr(Network->GetEDat(DstNId, SrcNId), Sign)).Val2 += SrcOutPlusProb;
1007    }
1008    if (OnlySimpleTriads && Network->IsEdge(DstNId, SrcNId)) {
1009      return; }
1010    else {
1011      Network->AddNode(SrcNId);
1012      Network->AddNode(DstNId);
1013      Network->AddEdge(SrcNId, DstNId, Sign);
1014    }
1015  }
1016  void TSignMicroEvol::CountTriad3to4Edges(const int& SrcNId, const int& DstNId, const int& Sign, const double& SrcOutPlusProb, const double& DstInPlusProb) {
1017    IAssert(! Network->IsEdge(SrcNId, DstNId));
1018    TIntV NbrV;
1019    TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
1020    for (int n = 0; n < NbrV.Len(); n++) {
1021      PSignNet Net1 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1022      if (! (Net1->GetEdges()==3 && Net1->IsClosedTriad())) { continue; }
1023      PSignNet Net2 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1024      Net2->AddEdge(0, 1, +1); 
1025      const int Net1Id = GetTriadId(Net1);
1026      const int Net2Id = GetTriadId(Net2);
1027      TCloseStat& ClsStat = Triad3to4H.AddDat(TIntPr(Net1Id, Net2Id));
1028      if (Sign == +1) { ClsStat.PlsCnt++; }
1029      else { ClsStat.MnsCnt++; }
1030      ClsStat.OutSumWgt += SrcOutPlusProb;
1031      ClsStat.OutVarSq += SrcOutPlusProb*(1-SrcOutPlusProb);
1032      ClsStat.InSumWgt += DstInPlusProb;
1033      ClsStat.InVarSq += DstInPlusProb*(1-DstInPlusProb);
1034      ClsStat.OutPlusPH.AddDat(int(SrcOutPlusProb*50)*2) += 1;
1035      ClsStat.InPlusPH.AddDat(int(DstInPlusProb*50)*2) += 1;
1036    }
1037    Network->AddNode(SrcNId);
1038    Network->AddNode(DstNId);
1039    Network->AddEdge(SrcNId, DstNId, Sign);
1040  }
1041  void TSignMicroEvol::CountTriadCloseVec(const int& SrcNId, const int& DstNId, const int& Sign) {
1042    TIntV NbrV;
1043    TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
1044    TTuple<TInt, 16> CntV;
1045    for (int n = 0; n < NbrV.Len(); n++) {
1046      PSignNet OpnTriadNet = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1047      if (OpnTriadNet->GetEdges() != 2) { continue; }
1048      const int TdId = GetOpnTriadId(OpnTriadNet);
1049      IAssert(TdId < 16);
1050      CntV[TdId]++;
1051    }
1052    TIntPr& Cnt = TriadVecV.AddDat(CntV);
1053    if (Sign==+1) { Cnt.Val1 += 1; }
1054    else { Cnt.Val2 += 1; }
1055    IAssert(! Network->IsEdge(SrcNId, DstNId));
1056    Network->AddNode(SrcNId);  Network->AddNode(DstNId);
1057    Network->AddEdge(SrcNId, DstNId, Sign);
1058  }
1059  int TSignMicroEvol::IsSameOpnTriad(const PSignNet& Net1, const PSignNet& Net2) {
1060    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) {
1061      return false;
1062    }
1063    TSignNet::TEdgeI EI1 = Net1->BegEI();
1064    TSignNet::TEdgeI EI2 = Net2->BegEI();
1065    while (EI1 < Net1->EndEI()) {
1066      if (EI1.GetSrcNId() != EI2.GetSrcNId()) { return false; }
1067      if (EI1.GetDstNId() != EI2.GetDstNId()) { return false; }
1068      if (EI1() != EI2()) { return false; }
1069      EI1++;  EI2++;
1070    }
1071    return true;
1072  }
1073  int TSignMicroEvol::GetOpnTriadId(const PSignNet& Net1) {
1074    for (int i = 0; i < OpnTriadV.Len(); i++) {
1075      if (IsSameOpnTriad(OpnTriadV[i], Net1)) { return i; }
1076    }
1077    OpnTriadV.Add(Net1);
1078    return OpnTriadV.Len()-1;
1079  }
1080  bool TSignMicroEvol::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2, int& PermId) const {
1081    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) {
1082      return false; }
1083    const TVec<TIntV>& PermV = PermH.GetDat(Net1->GetNodes());
1084    for (int p = 0; p < PermV.Len(); p++) {
1085      if (IsSameTriad(Net1, Net2, PermV[p])) {
1086        PermId=p; return true;
1087      }
1088    }
1089    return false;
1090  }
1091  int TSignMicroEvol::GetTriadId(const PSignNet& Net1) {
1092    int PermId;
1093    for (int i = 0; i < TriadIdV.Len(); i++) {
1094      if (IsSameTriad(TriadIdV[i], Net1, PermId)) { TriadIdV[i]=Net1; return i; }
1095    }
1096    TriadIdV.Add(Net1);
1097    TransNet->AddNode(TriadIdV.Len()-1, 0);
1098    return TriadIdV.Len()-1;
1099  }
1100  double TSignMicroEvol::GetStatusDelta(const PSignNet& Net, const int& NId1, const int& NId2) {
1101    int S1, S2;
1102    if (! Net->IsEdge(NId1, NId2)) { S1 = 0; }
1103    else if (Net->GetEDat(NId1, NId2)>0) { S1 = 1; } else { S1 = -1; }
1104    if (! Net->IsEdge(NId2, NId1)) { S2 = 0; }
1105    else if (Net->GetEDat(NId2, NId1)>0) { S2 = 1; } else { S2 = -1; }
1106    if (S1==+1 && S2==0) { return +0.2; }
1107    if (S1==-1 && S2==0) { return -0.8; }
1108    if (S1==0 && S2==+1) { return -0.2; }
1109    if (S1==0 && S2==-1) { return +0.8; }
1110    if (S1==+1 && S2==+1) { return +0.4; }
1111    if (S1==-1 && S2==-1) { return -1.6; }
1112    if (S1==+1 && S2==-1) { return +1; }
1113    if (S1==-1 && S2==+1) { return -1; }
1114    Fail;  return -1;
1115  }
1116  double TSignMicroEvol::GetStatus(const PSignNet& Net, const int& NId) {
1117    if (NId == 2) { return 0; }
1118    return GetStatusDelta(Net, 2, NId);
1119  }
1120  bool TSignMicroEvol::IsStatusFrac(const int& OpnTriadId, const bool& DstNode) const {
1121    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1122    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1123    if (DstNode) {
1124      if (GetStatus(SrcNet, 1) > 0) { if (Stat.GetPlsFrac()>0.8) { return true; } }
1125      else { if(Stat.GetPlsFrac()<0.2) { return true; } }
1126    } else {
1127      if (GetStatus(SrcNet, 1) > 0) { if (Stat.GetPlsFrac()<0.2) { return true; } }
<span onclick='openModal()' class='match'>1128      else { if(Stat.GetPlsFrac()>0.8) { return true; } }
1129    }
1130    return false;
1131  }
</span>1132  bool TSignMicroEvol::IsStatusSurp(const int& OpnTriadId, const bool& DstNode) const {
1133    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1134    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1135    if (DstNode) {
1136      if (GetStatus(SrcNet, 1)*Stat.GetOutPlsSurp() > 0) { return true; } 
1137    } else {
1138      if (GetStatus(SrcNet, 0)*Stat.GetInPlsSurp() < 0) { return true; }
1139    }
1140    return false;
1141  }
1142  int GetUnDirEdgeSign(const PSignNet& Net, const int& NId1, const int& NId2) {
1143    int S1, S2, S;
1144    if (! Net->IsEdge(NId1, NId2)) { S1 = 0; }
1145    else if (Net->GetEDat(NId1, NId2)>0) { S1 = 1; } else { S1 = -1; }
1146    if (! Net->IsEdge(NId2, NId1)) { S2 = 0; }
1147    else if (Net->GetEDat(NId2, NId1)>0) { S2 = 1; } else { S2 = -1; }
1148    if (S1==0) { S=S2; }
1149    else if (S2==0) { S=S1; }
1150    else { S=TMath::Mx(S1,S2); }
1151    return S;
1152  }
1153  bool TSignMicroEvol::IsBalanceFrac(const int& OpnTriadId) const {
1154    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1155    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1156    const int S1 = GetUnDirEdgeSign(SrcNet, 0,2);
1157    const int S2 = GetUnDirEdgeSign(SrcNet, 1,2);
1158    const double Plus = Stat.GetPlsFrac();
1159    if (S1*S2 > 0 && Plus > 0.8) { return true; }
1160    if (S1*S2 < 0 && Plus < 0.8) { return true; }
1161    return false;
1162  }
1163  bool TSignMicroEvol::IsBalanceSurp(const int& OpnTriadId) const {
1164   const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1165    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1166    const int S1 = GetUnDirEdgeSign(SrcNet, 0,2);
1167    const int S2 = GetUnDirEdgeSign(SrcNet, 1,2);
1168    const double Surp = Stat.GetOutPlsSurp();
1169    if (S1*S2 > 0 && Surp > 0) { return true; }
1170    if (S1*S2 < 0 && Surp < 0) { return true; }
1171    return false;
1172  }
1173  void TSignMicroEvol::PrintInfo() const {
1174    TSnap::PrintInfo(Network);
1175    Network->PrintInfo();
1176    THash<TIntPr, TFltPr> H = RepLinkCntH;
1177    H.SortByDat(false);
1178    printf("*** RECIPROCAL Links\n");
1179    for (int i = 0; i < H.Len(); i++) {
1180      printf(" %c is reciprocated by %c :  cnt %g  surp: %f\n",
1181        H.GetKey(i).Val1==1?'+':'-', H.GetKey(i).Val2==1?'+':'-', H[i].Val1, H[i].Val2);
1182    }
1183  }
1184  char TSignMicroEvol::GetEdgeChar(const PSignNet& Network, const int& n1, const int& n2) {
1185    if (! Network->IsEdge(n1,n2)) { return 'o'; }
1186    else if (Network->GetEDat(n1,n2)>0) { return '+'; }
1187    else { return '-'; }
1188  }
1189  void TSignMicroEvol::SaveCloseTriadTxt(const TStr& FNmPref, const bool& DrawNets, const bool& PlotHists) {
1190    printf("*** OPEN TRIADS %d\n", OpnTriadV.Len());
1191    TVec<TTriple<TInt, TStr, TInt> > OpnIdV;
1192    for (int n = 0; n < OpnTriadV.Len(); n++) {
1193      PSignNet SrcNet = OpnTriadV[n];
1194      OpnIdV.Add(TTriple<TInt, TStr, TInt>(SrcNet->GetEdges(), TStr::Fmt("%c%c%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2)), n));
1195    }
1196    OpnIdV.Sort();
1197    FILE* F = fopen(TStr::Fmt("%s-diad.tab", FNmPref.CStr()).CStr(), "wt");
1198    fprintf(F, "AB\tBC\tAC+\tAC-\tPctAC+\tOUT-Surprise\tIN-Surprise\tDst-StsFrac\tDst-StsSurp\tSrc-StsFrac\tSrc-StsSurp\tBalFrac\tBalSurp\n");
1199    for (int n = 0; n < OpnIdV.Len(); n++) {
1200      const int Id = OpnIdV[n].Val3;
1201      PSignNet SrcNet = OpnTriadV[Id];
1202      const TCloseStat Stat = CloseTriadH.GetDat(Id); 
1203      fprintf(F, "%c%c\t%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2));
1204      fprintf(F, "\t%d\t%d\t%.4f\t%.4f\t%.4f\t%s\t%s\t%s\t%s\t%s\t%s\n", Stat.PlsCnt, Stat.MnsCnt, Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp(),
1205        IsStatusFrac(Id,true)?"1":"0", IsStatusSurp(Id,true)?"1":"0", IsStatusFrac(Id,false)?"1":"0", IsStatusSurp(Id,false)?"1":"0",
1206        IsBalanceFrac(Id)?"1":"0", IsBalanceSurp(Id)?"1":"0");
1207    }
1208    fclose(F);
1209    if (DrawNets) {
1210      for (int i = 0; i < 16; i++) {
1211        const int Id = OpnIdV[i].Val3;
1212        TStr Label = TStr::Fmt("dst-status: p+:%s  s+:%s\\nsrc-status: p+:%s  s+:%s\\nbalance: p+:%s s+:%s",
1213          IsStatusFrac(Id,true)?"Y":"N", IsStatusSurp(Id,true)?"Y":"N",
1214          IsStatusFrac(Id,false)?"Y":"N", IsStatusSurp(Id,false)?"Y":"N",
1215          IsBalanceFrac(Id)?"Y":"N", IsBalanceSurp(Id)?"Y":"N");
1216        DrawCloseTriad(TStr::Fmt("%s_%02d", FNmPref.CStr(), i), Id, Label);
1217      }
1218    }
1219    if (PlotHists) {
1220      for (int i = 0; i < 16; i++) {
1221        const int Id = OpnIdV[i].Val3;
1222        CloseTriadH.GetDat(Id).SaveHist(TStr::Fmt("%s_%02d", FNmPref.CStr(), i));
1223      }
1224    }
1225    printf("done.\n");
1226  }
1227  void TSignMicroEvol::DrawCloseTriad(const TStr& FNmPref, const int& OpnTriadId, const TStr& Label) {
1228    PSignNet Network = OpnTriadV[OpnTriadId];
1229    TStr FNm = TStr::Fmt("%s-OpnTriad.dot", FNmPref.CStr());
1230    FILE *F = fopen(FNm.CStr(), "wt");
1231    fprintf(F, "  digraph G {\n");
1232    fprintf(F, "    graph [splines=true, overlap=false];\n");
1233    fprintf(F, "    node  [shape=ellipse, width=0.3, height=0.3];\n");
1234    fprintf(F, "    edge  [len=4];\n");
1235    for (TSignNet::TNodeI NI = Network->BegNI(); NI < Network->EndNI(); NI++) {
1236      fprintf(F, "    node%d [label=\"%g\"];\n", NI.GetId(), GetStatus(Network, NI.GetId())); }
1237    for (TSignNet::TEdgeI EI = Network->BegEI(); EI < Network->EndEI(); EI++) {
1238      fprintf(F, "    node%d -> node%d [label=\"%s\"];\n",
1239        EI.GetSrcNId(), EI.GetDstNId(), EI()==1?"+":"--"); }
1240    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId);
1241    fprintf(F, "    node0 -> node1 [label=\"+:%d -:%d\\np+:%.3f  so: %.1f  si: %.1f\", color=\"red\"];\n",
1242      Stat.PlsCnt(), Stat.MnsCnt(), Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp());
1243    if (! Label.Empty()) { fprintf(F, "label = \"%s\";\n", Label.CStr()); }
1244    fprintf(F, "}\n");
1245    fclose(F);
1246    TSnap::TSnapDetail::GVizDoLayout(FNm, FNm.GetFMid()+".gif", gvlNeato);
1247  }
1248  bool IsBalancedSwapEdge(const PSignNet& Net, const TIntPr& BackEdge, const int& Sign) {
1249    const int s1 = Net->GetEDat(BackEdge.Val2, BackEdge.Val1);
1250    const int s2 = Net->GetEDat(BackEdge.Val1, BackEdge.Val2);
1251    Net->DelEdge(BackEdge.Val2, BackEdge.Val1);
1252    Net->GetEDat(BackEdge.Val1, BackEdge.Val2) = Sign;
1253    const bool IsBal = Net->IsBalanced();
1254    Net->AddEdge(BackEdge.Val2, BackEdge.Val1, s1);
1255    Net->GetEDat(BackEdge.Val1, BackEdge.Val2) = s2;
1256    return IsBal;
1257  }
1258  void TSignMicroEvol::SaveTriad3to4Edges(const TStr& FNmPref) {
1259    TVec<TPair<TIntTr, TInt> > SigTIdV;
1260    for (int t = 0; t < Triad3to4H.Len(); t++) {
1261      SigTIdV.Add(TPair<TIntTr, TInt>(TriadIdV[Triad3to4H.GetKey(t).Val1]->GetTriadSig(), t));
1262    }
1263    SigTIdV.Sort();
1264    FILE *F = fopen(TStr::Fmt("tr3to4-%s2.tab", FNmPref.CStr()).CStr(), "wt");
1265    fprintf(F, "Balanced\tSrcTriad\t\t\t\tDstTriad\t\t\tPlus-BAL\tMns-BAL\tPlusCnt\tPlusFrac\tOUT-Supr\tIN-Surp\tBal-Frac\tBal-OutSurp\tBal-InSurp\n");
1266    for (int t = 0; t < SigTIdV.Len(); t++) {
1267      const int SrcTId = Triad3to4H.GetKey(SigTIdV[t].Val2).Val1;
1268      const int DstTId = Triad3to4H.GetKey(SigTIdV[t].Val2).Val2;
1269      const TCloseStat& Stat = Triad3to4H[SigTIdV[t].Val2];
1270      TIntTr SrcSig = TriadIdV[SrcTId]->GetTriadSig();
1271      TIntTr DstSig = TriadIdV[DstTId]->GetTriadSig();
1272      TIntPr NewEdge = TriadIdV[DstTId]->GetNewEdge(TriadIdV[SrcTId]);
1273      const bool SrcBal = TriadIdV[SrcTId]->IsBalanced();
1274      const bool DstPlsBal = IsBalancedSwapEdge(TriadIdV[DstTId], NewEdge, 1);
1275      const bool DstMnsBal = IsBalancedSwapEdge(TriadIdV[DstTId], NewEdge, -1);
1276      IAssert(int(DstPlsBal)+int(DstMnsBal)==1);
1277      fprintf(F, "%d\t%s\t->\t%s\t%d\t%d\t%d\t%.3f\t%.3f\t%.3f",
1278        SrcBal?1:0, TSignNet::GetTriadStr(SrcSig).CStr(),
1279        TSignNet::GetTriadStr(DstSig).CStr(), DstPlsBal?1:0, DstMnsBal?1:0,
1280        Stat.PlsCnt, Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp());
1281      const bool IsPlusBal = (DstPlsBal && Stat.GetPlsFrac()>0.8) || (! DstPlsBal && Stat.GetPlsFrac()<0.8);
1282      const bool IsOutSur = (DstPlsBal && Stat.GetOutPlsSurp()>2) || (! DstPlsBal && Stat.GetOutPlsSurp()<-2);
1283      const bool IsInSur = (DstPlsBal && Stat.GetInPlsSurp()>2) || (! DstPlsBal && Stat.GetInPlsSurp()<-2);
1284      fprintf(F, "\t%d\t%d\t%d\n", IsPlusBal?1:0, IsOutSur?1:0, IsInSur?1:0);
1285    }
1286    fclose(F);
1287  }
1288  void TSignMicroEvol::SaveTriadCloseVec(const TStr& FNmPref) {
1289    IAssert(OpnTriadV.Len() == 16);
1290    TVec<TTriple<TInt, TStr, TInt> > OpnIdV;
1291    for (int n = 0; n < OpnTriadV.Len(); n++) {
1292      PSignNet SrcNet = OpnTriadV[n];
1293      OpnIdV.Add(TTriple<TInt, TStr, TInt>(SrcNet->GetEdges(), TStr::Fmt("%c%c%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2)), n));
1294    }
1295    OpnIdV.Sort();
1296    TriadVecV.SortByKey(false);
1297    FILE *F = fopen(TStr::Fmt("trVec2-%s.tab", FNmPref.CStr()).CStr(), "wt");
1298    for (int i = 0; i < OpnIdV.Len(); i++) { fprintf(F, "%s\t", OpnIdV[i].Val2.CStr()); }
1299    fprintf(F, "PlsCnt\tMnsCnt\n");
1300    printf("%d vectors\n", TriadVecV.Len());
1301    for (int v = 0; v < TMath::Mn(1000, TriadVecV.Len()); v++) {
1302      const TTuple<TInt, 16>& V = TriadVecV.GetKey(v);
1303      for (int i = 0; i < V.Len(); i++) {
1304        fprintf(F, "%d\t", V[OpnIdV[i].Val3]);
1305      }
1306      fprintf(F, "%d\t%d\n", TriadVecV[v].Val1, TriadVecV[v].Val2);
1307    }
1308    fclose(F);
1309  }
1310  void TSignMicroEvol::EpinionsTriadEvolution(const bool& OnlySimpleTriads) {
1311    TSsParser Ss("W:\\Data\\Epinions\\user_rating.txt", ssfTabSep);
1312    TVec<TIntQu> EdgeV;
1313    for (int c = 0; Ss.Next(); c++) {
1314      TChA ChA(Ss[3]);
1315      TVec<char*> V;  TStrUtil::SplitOnCh(ChA, V, '/');
1316      TSecTm Tm(atoi(V[0]), atoi(V[1]), atoi(V[2]));
1317      EdgeV.Add(TIntQu(Tm.GetAbsSecs(), Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2))); 
1318    }
1319    EdgeV.Sort();
1320    PSignNet Net = TSignNet::New();
1321    int e = 0;
1322    const TSecTm BegTm(2001, 01, 10);
1323    for (; e < EdgeV.Len() && (uint)EdgeV[e].Val1 <= BegTm.GetAbsSecs(); e++) {
1324      if (OnlySimpleTriads &&  Net->IsEdge(EdgeV[e].Val3, EdgeV[e].Val2)) { continue; }
1325      Net->AddNode(EdgeV[e].Val2);  Net->AddNode(EdgeV[e].Val3);
1326      Net->AddEdge(EdgeV[e].Val2, EdgeV[e].Val3, EdgeV[e].Val4);
1327    }
1328    TSnap::PrintInfo(Net);
1329    TSignMicroEvol SME(Net);
1330    TIntFltH OutPlusProbH, InPlusProbH;
1331    { THash<TInt, TIntPr> PlsMnsCnt1, PlsMnsCnt2;
1332    for (int e1=0; e1 < EdgeV.Len(); e1++) {
1333      if (EdgeV[e1].Val4==1) { PlsMnsCnt1.AddDat(EdgeV[e1].Val2).Val1++; } 
1334      else { PlsMnsCnt1.AddDat(EdgeV[e1].Val2).Val2++; }
1335      if (EdgeV[e1].Val4==1) { PlsMnsCnt2.AddDat(EdgeV[e1].Val3).Val1++; } 
1336      else { PlsMnsCnt2.AddDat(EdgeV[e1].Val3).Val2++; }
1337    }
1338    for (int u = 0; u < PlsMnsCnt1.Len(); u++) {
1339      OutPlusProbH.AddDat(PlsMnsCnt1.GetKey(u), PlsMnsCnt1[u].Val1/double(PlsMnsCnt1[u].Val1+PlsMnsCnt1[u].Val2)); }
1340    for (int u = 0; u < PlsMnsCnt2.Len(); u++) {
1341      InPlusProbH.AddDat(PlsMnsCnt2.GetKey(u), PlsMnsCnt2[u].Val1/double(PlsMnsCnt2[u].Val1+PlsMnsCnt2[u].Val2));
1342    } } /&bsol;*/
1343    printf("*** skip fist %d edges\n", e);
1344    int Plus=0, Minus=0, SkipEdges=e;
1345    const TStr OutFNm = TStr::Fmt("epin851-%s", OnlySimpleTriads?"SmpTr":"AllTr");
1346    for (; e < EdgeV.Len(); e++) {
1347      const int n1 = EdgeV[e].Val2;
1348      const int n2 = EdgeV[e].Val3;
1349      const int Sign = EdgeV[e].Val4;
1350      if (n1 == n2 || Net->IsEdge(n1,n2))  { continue; }
1351      if (Sign==1) { Plus++; } else { Minus++; }
1352      const double SrcOutPlusProb = OutPlusProbH.GetDat(n1);  
1353      const double DstInPlusProb = InPlusProbH.GetDat(n2);    
1354      SME.CountTriad3to4Edges(n1, n2, Sign, SrcOutPlusProb, DstInPlusProb);
1355      if ((e+1) % 1000 == 0) { printf("."); }
1356    }
1357    printf("\n\n*** %s\n", OutFNm.CStr());
1358    printf("In %d good edges %d plus %d minus.\n", EdgeV.Len()-SkipEdges, Plus, Minus);
1359    SME.PrintInfo();
1360    SME.SaveTriad3to4Edges(OutFNm);            
1361  }
1362  void GetKeyPrV(const THash<TIntPr, TInt>& H, const int& MinCnt, TFltPrV& V) {
1363    V.Clr(false);
1364    for (int i = 0; i < H.Len(); i++) {
1365      if (H[i] >= MinCnt) {
1366        V.Add(TFltPr(H.GetKey(i).Val1+TInt::Rnd.GetUniDev()+1.0,
1367          H.GetKey(i).Val2+TInt::Rnd.GetUniDev()+1.0));
1368      }
1369    }
1370  }
1371  void TSignMicroEvol::EpinionsStat() {
1372    TSsParser Ss("W:\\Data\\Epinions\\user_rating.txt", ssfTabSep);
1373    TVec<TIntQu> EdgeV;
1374    for (int c = 0; Ss.Next(); c++) {
1375      TChA ChA(Ss[3]);
1376      TVec<char*> V;  TStrUtil::SplitOnCh(ChA, V, '/');
1377      TSecTm Tm(atoi(V[0]), atoi(V[1]), atoi(V[2]));
1378      EdgeV.Add(TIntQu(Tm.GetAbsSecs(), Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2))); 
1379    }
1380    THash<TInt, TIntQu> NIdPmOutInH;
1381    for (int e = 0; e < EdgeV.Len(); e++) {
1382      TIntQu& Src = NIdPmOutInH.AddDat(EdgeV[e].Val2);
1383      TIntQu& Dst = NIdPmOutInH.AddDat(EdgeV[e].Val3);
1384      if (EdgeV[e].Val4 == 1) {
1385        Src.Val1++; Dst.Val3++; 
1386      } else {
1387        Src.Val2++; Dst.Val4++; 
1388      }
1389    }
1390    TFltPrV PiPo, PiMi, PiMo, PoMi, PoMo, MiMo;
1391    THash<TIntPr, TInt> PiPoH, PiMiH, PiMoH, PoMiH, PoMoH, MiMoH;
1392    for (int i = 0; i < NIdPmOutInH.Len(); i++) {
1393      TIntQu PMOI = NIdPmOutInH[i];
1394      PiPo.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val1+TInt::Rnd.GetUniDev()+1.0));
1395      PiMi.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val4+TInt::Rnd.GetUniDev()+1.0));
1396      PiMo.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));
1397      PoMi.Add(TFltPr(PMOI.Val1+TInt::Rnd.GetUniDev()+1.0, PMOI.Val4+TInt::Rnd.GetUniDev()+1.0));
1398      PoMo.Add(TFltPr(PMOI.Val1+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));
1399      MiMo.Add(TFltPr(PMOI.Val4+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));/&bsol;*/
1400      PiPoH.AddDat(TIntPr(PMOI.Val3, PMOI.Val1)) += 1;
1401      PiMiH.AddDat(TIntPr(PMOI.Val3, PMOI.Val4)) += 1;
1402      PiMoH.AddDat(TIntPr(PMOI.Val3, PMOI.Val2)) += 1;
1403      PoMiH.AddDat(TIntPr(PMOI.Val1, PMOI.Val4)) += 1;
1404      PoMoH.AddDat(TIntPr(PMOI.Val1, PMOI.Val2)) += 1;
1405      MiMoH.AddDat(TIntPr(PMOI.Val4, PMOI.Val2)) += 1;
1406    }
1407    TStr OutFNm = "EpinAll";
1408    TGnuPlot::PlotValV(PiPo, "pipo-"+OutFNm, OutFNm, "Number of + IN", "Number of + OUT", gpsLog, false, gpwPoints);
1409    TGnuPlot::PlotValV(PiMi, "pimi-"+OutFNm, OutFNm, "Number of + IN", "Number of - IN", gpsLog, false, gpwPoints);
1410    TGnuPlot::PlotValV(PiMo, "pimo-"+OutFNm, OutFNm, "Number of + IN", "Number of - OUT", gpsLog, false, gpwPoints);
1411    TGnuPlot::PlotValV(PoMi, "pomi-"+OutFNm, OutFNm, "Number of + OUT", "Number of - IN", gpsLog, false, gpwPoints);
1412    TGnuPlot::PlotValV(PoMo, "pomo-"+OutFNm, OutFNm, "Number of + OUT", "Number of - OUT", gpsLog, false, gpwPoints);
1413    TGnuPlot::PlotValV(MiMo, "mimo-"+OutFNm, OutFNm, "Number of - IN", "Number of - OUT", gpsLog, false, gpwPoints);
1414  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ds.h</h3>
            <pre><code>1  template <class TRec>
2  class TAPt{
3  private:
4    TRec* Addr;
5  public:
6    TAPt(): Addr(NULL){}
7    TAPt(const TAPt& Pt): Addr(Pt.Addr){}
8    TAPt(TRec* _Addr): Addr(_Addr){}
9    TAPt(TSIn&){Fail;}
10    void Save(TSOut&) const {Fail;}
11    TAPt& operator=(const TAPt& Pt){Addr=Pt.Addr; return *this;}
12    TAPt& operator=(TRec* _Addr){Addr=_Addr; return *this;}
13    bool operator==(const TAPt& Pt) const {return *Addr==*Pt.Addr;}
14    bool operator!=(const TAPt& Pt) const {return *Addr!=*Pt.Addr;}
15    bool operator<(const TAPt& Pt) const {return *Addr<*Pt.Addr;}
16    TRec* operator->() const {Assert(Addr!=NULL); return Addr;}
17    TRec& operator*() const {Assert(Addr!=NULL); return *Addr;}
18    TRec& operator[](const int& RecN) const {
19      Assert(Addr!=NULL); return Addr[RecN];}
20    TRec* operator()() const {return Addr;}
21    bool Empty() const {return Addr==NULL;}
22  };
23  template <class TVal1, class TVal2>
24  class TPair{
25  public:
26    TVal1 Val1;
27    TVal2 Val2;
28  public:
29    TPair(): Val1(), Val2(){}
30    TPair(const TPair& Pair): Val1(Pair.Val1), Val2(Pair.Val2){}
31    TPair(const TVal1& _Val1, const TVal2& _Val2): Val1(_Val1), Val2(_Val2){}
32    explicit TPair(TSIn& SIn): Val1(SIn), Val2(SIn){}
33    void Save(TSOut& SOut) const {
34      Val1.Save(SOut); Val2.Save(SOut);}
35    void Load(TSIn& SIn) {Val1.Load(SIn); Val2.Load(SIn);}
36    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
37    void SaveXml(TSOut& SOut, const TStr& Nm) const;
38    TPair& operator=(const TPair& Pair){
39      if (this!=&Pair){Val1=Pair.Val1; Val2=Pair.Val2;} return *this;}
40    bool operator==(const TPair& Pair) const {
41      return (Val1==Pair.Val1)&&(Val2==Pair.Val2);}
42    bool operator<(const TPair& Pair) const {
43      return (Val1<Pair.Val1)||((Val1==Pair.Val1)&&(Val2<Pair.Val2));}
44    int GetMemUsed() const {return Val1.GetMemUsed()+Val2.GetMemUsed();}
45    int GetPrimHashCd() const {return TPairHashImpl::GetHashCd(Val1.GetPrimHashCd(), Val2.GetPrimHashCd()); }
46    int GetSecHashCd() const {return TPairHashImpl::GetHashCd(Val2.GetSecHashCd(), Val1.GetSecHashCd()); }
47    void GetVal(TVal1& _Val1, TVal2& _Val2) const {_Val1=Val1; _Val2=Val2;}
48    const TVal1& GetVal1() const { return Val1;}
49    const TVal2& GetVal2() const { return Val2;}
50    TStr GetStr() const {
51      return TStr("Pair(")+Val1.GetStr()+", "+Val2.GetStr()+")";}
52  };
53  template <class TVal1, class TVal2, class TSizeTy>
54  void GetSwitchedPrV(const TVec<TPair<TVal1, TVal2>, TSizeTy>& SrcPrV, TVec<TPair<TVal2, TVal1>, TSizeTy>& DstPrV){
55    const TSizeTy Prs = SrcPrV.Len();
56    DstPrV.Gen(Prs, 0);
57    for (TSizeTy PrN=0; PrN<Prs; PrN++){
58      const TPair<TVal1, TVal2>& SrcPr=SrcPrV[PrN];
59      DstPrV.Add(TPair<TVal2, TVal1>(SrcPr.Val2, SrcPr.Val1));
60    }
61  }
62  typedef TPair<TBool, TCh> TBoolChPr;
63  typedef TPair<TBool, TFlt> TBoolFltPr;
64  typedef TPair<TUCh, TInt> TUChIntPr;
65  typedef TPair<TUCh, TUInt64> TUChUInt64Pr;
66  typedef TPair<TUCh, TStr> TUChStrPr;
67  typedef TPair<TInt, TBool> TIntBoolPr;
68  typedef TPair<TInt, TCh> TIntChPr;
69  typedef TPair<TInt, TInt> TIntPr;
70  typedef TPair<TInt, TUInt64> TIntUInt64Pr;
71  typedef TPair<TInt, TIntPr> TIntIntPrPr;
72  typedef TPair<TInt, TVec<TInt, int> > TIntIntVPr;
73  typedef TPair<TInt, TFlt> TIntFltPr;
74  typedef TPair<TInt, TStr> TIntStrPr;
75  typedef TPair<TInt, TStrV> TIntStrVPr;
76  typedef TPair<TIntPr, TInt> TIntPrIntPr;
77  typedef TPair<TUInt, TUInt> TUIntUIntPr;
78  typedef TPair<TUInt, TInt> TUIntIntPr;
79  typedef TPair<TUInt64, TInt> TUInt64IntPr;
80  typedef TPair<TUInt64, TUInt64> TUInt64Pr;
81  typedef TPair<TUInt64, TFlt> TUInt64FltPr;
82  typedef TPair<TUInt64, TStr> TUInt64StrPr;
83  typedef TPair<TFlt, TInt> TFltIntPr;
84  typedef TPair<TFlt, TUInt64> TFltUInt64Pr;
85  typedef TPair<TFlt, TFlt> TFltPr;
86  typedef TPair<TFlt, TStr> TFltStrPr;
87  typedef TPair<TAscFlt, TInt> TAscFltIntPr;
88  typedef TPair<TAscFlt, TAscFlt> TAscFltPr;
89  typedef TPair<TFlt, TStr> TFltStrPr;
90  typedef TPair<TAscFlt, TStr> TAscFltStrPr;
91  typedef TPair<TStr, TInt> TStrIntPr;
92  typedef TPair<TStr, TFlt> TStrFltPr;
93  typedef TPair<TStr, TStr> TStrPr;
94  typedef TPair<TStr, TStrV> TStrStrVPr;
95  typedef TPair<TStrV, TInt> TStrVIntPr;
96  typedef TPair<TInt, TIntPr> TIntIntPrPr;
97  typedef TPair<TInt, TStrPr> TIntStrPrPr;
98  typedef TPair<TFlt, TStrPr> TFltStrPrPr;
99  typedef TPair<TVec<TInt, int>, TVec<TFlt, int> > TIntVFltVPr;
100  template <class TVal1, class TVal2>
101  class TCmpPairByVal2 {
102  private:
103    bool IsAsc;
104  public:
105    TCmpPairByVal2(const bool& AscSort=true) : IsAsc(AscSort) { }
106    bool operator () (const TPair<TVal1, TVal2>& P1, const TPair<TVal1, TVal2>& P2) const {
107      if (IsAsc) { return P1.Val2 < P2.Val2; } else { return P2.Val2 < P1.Val2; }
108    }
109  };
110  template <class TVal1, class TVal2, class TVal3>
111  class TTriple{
112  public:
113    TVal1 Val1;
114    TVal2 Val2;
115    TVal3 Val3;
116  public:
117    TTriple(): Val1(), Val2(), Val3(){}
118    TTriple(const TTriple& Triple):
119      Val1(Triple.Val1), Val2(Triple.Val2), Val3(Triple.Val3){}
120    TTriple(const TVal1& _Val1, const TVal2& _Val2, const TVal3& _Val3):
121      Val1(_Val1), Val2(_Val2), Val3(_Val3){}
122    explicit TTriple(TSIn& SIn): Val1(SIn), Val2(SIn), Val3(SIn){}
123    void Save(TSOut& SOut) const {
124      Val1.Save(SOut); Val2.Save(SOut); Val3.Save(SOut);}
125    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
126    void SaveXml(TSOut& SOut, const TStr& Nm) const;
127    TTriple& operator=(const TTriple& Triple){
128      if (this!=&Triple){Val1=Triple.Val1; Val2=Triple.Val2; Val3=Triple.Val3;}
129      return *this;}
130    bool operator==(const TTriple& Triple) const {
131      return (Val1==Triple.Val1)&&(Val2==Triple.Val2)&&(Val3==Triple.Val3);}
132    bool operator<(const TTriple& Triple) const {
133      return (Val1<Triple.Val1)||((Val1==Triple.Val1)&&(Val2<Triple.Val2))||
134       ((Val1==Triple.Val1)&&(Val2==Triple.Val2)&&(Val3<Triple.Val3));}
135    int GetPrimHashCd() const {return  TPairHashImpl::GetHashCd(TPairHashImpl::GetHashCd(Val1.GetPrimHashCd(), Val2.GetPrimHashCd()), Val3.GetPrimHashCd()); }
136    int GetSecHashCd() const {return TPairHashImpl::GetHashCd(TPairHashImpl::GetHashCd(Val2.GetSecHashCd(), Val3.GetSecHashCd()), Val1.GetSecHashCd()); }
137    int GetMemUsed() const {return Val1.GetMemUsed()+Val2.GetMemUsed()+Val3.GetMemUsed();}
138    void GetVal(TVal1& _Val1, TVal2& _Val2, TVal3& _Val3) const {
139      _Val1=Val1; _Val2=Val2; _Val3=Val3;}
140    const TVal1& GetVal1() const { return Val1;}
141    const TVal2& GetVal2() const { return Val2;}
142    const TVal3& GetVal3() const { return Val3;}
143  };
144  typedef TTriple<TCh, TCh, TCh> TChTr;
145  typedef TTriple<TCh, TInt, TInt> TChIntIntTr;
146  typedef TTriple<TUCh, TInt, TInt> TUChIntIntTr;
147  typedef TTriple<TInt, TInt, TInt> TIntTr;
148  typedef TTriple<TUInt64, TUInt64, TUInt64> TUInt64Tr;
149  typedef TTriple<TInt, TStr, TInt> TIntStrIntTr;
150  typedef TTriple<TInt, TInt, TStr> TIntIntStrTr;
151  typedef TTriple<TInt, TInt, TFlt> TIntIntFltTr;
152  typedef TTriple<TInt, TFlt, TInt> TIntFltIntTr;
153  typedef TTriple<TInt, TFlt, TFlt> TIntFltFltTr;
154  typedef TTriple<TInt, TStr, TStr> TIntStrStrTr;
155  typedef TTriple<TInt, TVec<TInt, int>, TInt> TIntIntVIntTr;
156  typedef TTriple<TInt, TInt, TVec<TInt, int> > TIntIntIntVTr;
157  typedef TTriple<TFlt, TFlt, TFlt> TFltTr;
158  typedef TTriple<TFlt, TInt, TInt> TFltIntIntTr;
159  typedef TTriple<TFlt, TFlt, TInt> TFltFltIntTr;
160  typedef TTriple<TFlt, TFlt, TStr> TFltFltStrTr;
161  typedef TTriple<TChA, TChA, TChA> TChATr;
162  typedef TTriple<TStr, TStr, TStr> TStrTr;
163  typedef TTriple<TStr, TInt, TInt> TStrIntIntTr;
164  typedef TTriple<TStr, TFlt, TFlt> TStrFltFltTr;
165  typedef TTriple<TStr, TStr, TInt> TStrStrIntTr;
166  typedef TTriple<TStr, TInt, TStrV> TStrIntStrVTr;
167  template <class TVal1, class TVal2, class TVal3>
168  class TCmpTripleByVal2 {
169  private:
170    bool IsAsc;
171  public:
172    TCmpTripleByVal2(const bool& AscSort=true) : IsAsc(AscSort) { }
173    bool operator () (const TTriple<TVal1, TVal2, TVal3>& T1, const TTriple<TVal1, TVal2, TVal3>& T2) const {
174      if (IsAsc) { return T1.Val2 < T2.Val2; } else { return T2.Val2 < T1.Val2; }
175    }
176  };
177  template <class TVal1, class TVal2, class TVal3>
178  class TCmpTripleByVal3 {
179  private:
180    bool IsAsc;
181  public:
182    TCmpTripleByVal3(const bool& AscSort=true) : IsAsc(AscSort) { }
183    bool operator () (const TTriple<TVal1, TVal2, TVal3>& T1, const TTriple<TVal1, TVal2, TVal3>& T2) const {
184      if (IsAsc) { return T1.Val3 < T2.Val3; } else { return T2.Val3 < T1.Val3; }
185    }
186  };
187  template <class TVal1, class TVal2, class TVal3, class TVal4>
188  class TQuad{
189  public:
190    TVal1 Val1;
191    TVal2 Val2;
192    TVal3 Val3;
193    TVal4 Val4;
194  public:
195    TQuad():
196      Val1(), Val2(), Val3(), Val4(){}
197    TQuad(const TQuad& Quad):
198      Val1(Quad.Val1), Val2(Quad.Val2), Val3(Quad.Val3), Val4(Quad.Val4){}
199    TQuad(const TVal1& _Val1, const TVal2& _Val2, const TVal3& _Val3, const TVal4& _Val4):
200      Val1(_Val1), Val2(_Val2), Val3(_Val3), Val4(_Val4){}
201    explicit TQuad(TSIn& SIn):
202      Val1(SIn), Val2(SIn), Val3(SIn), Val4(SIn){}
203    void Save(TSOut& SOut) const {
204      Val1.Save(SOut); Val2.Save(SOut); Val3.Save(SOut); Val4.Save(SOut);}
205    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
206    void SaveXml(TSOut& SOut, const TStr& Nm) const;
207    TQuad& operator=(const TQuad& Quad){
208      if (this!=&Quad){
209        Val1=Quad.Val1; Val2=Quad.Val2; Val3=Quad.Val3; Val4=Quad.Val4;}
210      return *this;}
211    bool operator==(const TQuad& Quad) const {
212      return (Val1==Quad.Val1)&&(Val2==Quad.Val2)&&(Val3==Quad.Val3)&&(Val4==Quad.Val4);}
213    bool operator<(const TQuad& Quad) const {
214      return (Val1<Quad.Val1)||((Val1==Quad.Val1)&&(Val2<Quad.Val2))||
215       ((Val1==Quad.Val1)&&(Val2==Quad.Val2)&&(Val3<Quad.Val3))||
216       ((Val1==Quad.Val1)&&(Val2==Quad.Val2)&&(Val3==Quad.Val3)&&(Val4<Quad.Val4));}
217    int GetPrimHashCd() const {return  TPairHashImpl::GetHashCd(TPairHashImpl::GetHashCd(Val1.GetPrimHashCd(), Val2.GetPrimHashCd()), TPairHashImpl::GetHashCd(Val3.GetPrimHashCd(), Val4.GetPrimHashCd())); }
218    int GetSecHashCd() const {return TPairHashImpl::GetHashCd(TPairHashImpl::GetHashCd(Val2.GetSecHashCd(), Val3.GetSecHashCd()), TPairHashImpl::GetHashCd(Val4.GetSecHashCd(), Val1.GetSecHashCd())); }
219    void GetVal(TVal1& _Val1, TVal2& _Val2, TVal3& _Val3, TVal4& _Val4) const {
220      _Val1=Val1; _Val2=Val2; _Val3=Val3; _Val4=Val4;}
221    const TVal1& GetVal1() const { return Val1;}
222    const TVal2& GetVal2() const { return Val2;}
223    const TVal3& GetVal3() const { return Val3;}
224    const TVal4& GetVal4() const { return Val4;}
225  };
226  typedef TQuad<TStr, TStr, TInt, TInt> TStrStrIntIntQu;
227  typedef TQuad<TStr, TStr, TStr, TStr> TStrQu;
228  typedef TQuad<TInt, TInt, TInt, TInt> TIntQu;
229  typedef TQuad<TFlt, TFlt, TFlt, TFlt> TFltQu;
230  typedef TQuad<TFlt, TInt, TInt, TInt> TFltIntIntIntQu;
231  typedef TQuad<TInt, TStr, TInt, TInt> TIntStrIntIntQu;
232  typedef TQuad<TInt, TInt, TFlt, TFlt> TIntIntFltFltQu;
233  template<class TVal, int NVals>
234  class TTuple {
235  private:
236    TVal ValV [NVals];
237  public:
238    TTuple(){}
239    TTuple(const TVal& InitVal) { for (int i=0; i<Len(); i++) ValV[i]=InitVal; }
240    TTuple(const TTuple& Tup) { for (int i=0; i<Len(); i++) ValV[i]=Tup[i]; }
241    TTuple(TSIn& SIn) { for (int i=0; i<Len(); i++) ValV[i].Load(SIn); }
242    void Save(TSOut& SOut) const { for (int i=0; i<Len(); i++) ValV[i].Save(SOut); }
243    void Load(TSIn& SIn) { for (int i=0; i<Len(); i++) ValV[i].Load(SIn); }
244    int Len() const { return NVals; }
245    TVal& operator[] (const int& ValN) { return ValV[ValN]; }
246    const TVal& operator[] (const int& ValN) const { return ValV[ValN]; }
247    TTuple& operator = (const TTuple& Tup) { if (this != & Tup) {
248      for (int i=0; i<Len(); i++) ValV[i]=Tup[i]; } return *this; }
249    bool operator == (const TTuple& Tup) const {
250      if (Len()!=Tup.Len()) { return false; }  if (&Tup==this) { return true; }
251      for (int i=0; i<Len(); i++) if(ValV[i]!=Tup[i]){return false;} return true; }
252    bool operator < (const TTuple& Tup) const {
253      if (Len() == Tup.Len()) { for (int i=0; i<Len(); i++) {
254        if(ValV[i]<Tup[i]){return true;} else if(ValV[i]>Tup[i]){return false;} } return false; }
255      else { return Len() < Tup.Len(); } }
256    void Sort(const bool& Asc=true);
257    int FindMx() const;
258    int FindMn() const;
259    int GetPrimHashCd() const { int hc = 0;
260      for (int i = 0; i < NVals; i++) { hc = TPairHashImpl::GetHashCd(hc, ValV[i].GetPrimHashCd()); }
261      return hc; }
262    int GetSecHashCd() const { int hc = 0;
263      for (int i = 1; i < NVals; i++) { hc = TPairHashImpl::GetHashCd(hc, ValV[i].GetSecHashCd()); }
264      if (NVals > 0) { hc = TPairHashImpl::GetHashCd(hc, ValV[0].GetSecHashCd()); }
265      return hc; }
266    TStr GetStr() const { TChA ValsStr;
267      for (int i=0; i<Len(); i++) { ValsStr+=" "+ValV[i].GetStr(); }
268      return TStr::Fmt("Tuple(%d):", Len())+ValsStr; }
269  };
270  template<class TVal, int NVals>
271  void TTuple<TVal, NVals>::Sort(const bool& Asc) {
272    TVec<TVal, int> V(NVals);
273    for (int i=0; i<NVals; i++) { V.Add(ValV[i]); }
274    V.Sort(Asc);
275    for (int i=0; i<NVals; i++) { ValV[i] = V[i]; }
276  }
277  template<class TVal, int NVals>
278  int TTuple<TVal, NVals>::FindMx() const {
279    TVal MxVal = ValV[0];
280    int ValN = 0;
281    for (int i = 1; i < NVals; i++) {
282      if (MxVal<ValV[i]) {
283        MxVal=ValV[i]; ValN=i;
284      }
285    }
286    return ValN;
287  }
288  template<class TVal, int NVals>
289  int TTuple<TVal, NVals>::FindMn() const {
290    TVal MnVal = ValV[0];
291    int ValN = 0;
292    for (int i = 1; i < NVals; i++) {
293      if (MnVal>ValV[i]) {
294        MnVal=ValV[i]; ValN=i;
295      }
296    }
297    return ValN;
298  }
299  template <class TKey, class TDat>
300  class TKeyDat{
301  public:
302    TKey Key;
303    TDat Dat;
304  public:
305    TKeyDat(): Key(), Dat(){}
306    TKeyDat(const TKeyDat& KeyDat): Key(KeyDat.Key), Dat(KeyDat.Dat){}
307    explicit TKeyDat(const TKey& _Key): Key(_Key), Dat(){}
308    TKeyDat(const TKey& _Key, const TDat& _Dat): Key(_Key), Dat(_Dat){}
309    explicit TKeyDat(TSIn& SIn): Key(SIn), Dat(SIn){}
310    void Save(TSOut& SOut) const {Key.Save(SOut); Dat.Save(SOut);}
311    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
312    void SaveXml(TSOut& SOut, const TStr& Nm) const;
313    TKeyDat& operator=(const TKeyDat& KeyDat){
314      if (this!=&KeyDat){Key=KeyDat.Key; Dat=KeyDat.Dat;} return *this;}
315    bool operator==(const TKeyDat& KeyDat) const {return Key==KeyDat.Key;}
316    bool operator<(const TKeyDat& KeyDat) const {return Key<KeyDat.Key;}
317    int GetPrimHashCd() const {return Key.GetPrimHashCd();}
318    int GetSecHashCd() const {return Key.GetSecHashCd();}
319  };
320  template <class TKey, class TDat>
321  void GetSwitchedKdV(const TVec<TKeyDat<TKey, TDat>, int>& SrcKdV, TVec<TKeyDat<TDat, TKey>, int>& DstKdV){
322    const int Kds=SrcKdV.Len();
323    DstKdV.Gen(Kds, 0);
324    for (int KdN=0; KdN<Kds; KdN++){
325      const TKeyDat<TKey, TDat>& SrcKd=SrcKdV[KdN];
326      DstKdV.Add(TKeyDat<TDat, TKey>(SrcKd.Dat, SrcKd.Key));
327    }
328  }
329  typedef TKeyDat<TInt, TInt> TIntKd;
330  typedef TKeyDat<TInt, TUInt64> TIntUInt64Kd;
331  typedef TKeyDat<TInt, TFlt> TIntFltKd;
332  typedef TKeyDat<TIntPr, TFlt> TIntPrFltKd;
333  typedef TKeyDat<TInt, TFltPr> TIntFltPrKd;
334  typedef TKeyDat<TInt, TSFlt> TIntSFltKd;
335  typedef TKeyDat<TInt, TStr> TIntStrKd;
336  typedef TKeyDat<TUInt, TInt> TUIntIntKd;
337  typedef TKeyDat<TUInt, TUInt> TUIntKd;
338  typedef TKeyDat<TUInt64, TInt> TUInt64IntKd;
339  typedef TKeyDat<TUInt64, TFlt> TUInt64FltKd;
340  typedef TKeyDat<TUInt64, TStr> TUInt64StrKd;
341  typedef TKeyDat<TFlt, TBool> TFltBoolKd;
342  typedef TKeyDat<TFlt, TInt> TFltIntKd;
343  typedef TKeyDat<TFlt, TUInt64> TFltUInt64Kd;
344  typedef TKeyDat<TFlt, TIntPr> TFltIntPrKd;
345  typedef TKeyDat<TFlt, TUInt> TFltUIntKd;
346  typedef TKeyDat<TFlt, TFlt> TFltKd;
347  typedef TKeyDat<TFlt, TStr> TFltStrKd;
348  typedef TKeyDat<TFlt, TBool> TFltBoolKd;
349  typedef TKeyDat<TFlt, TIntBoolPr> TFltIntBoolPrKd;
350  typedef TKeyDat<TAscFlt, TInt> TAscFltIntKd;
351  typedef TKeyDat<TStr, TBool> TStrBoolKd;
352  typedef TKeyDat<TStr, TInt> TStrIntKd;
353  typedef TKeyDat<TStr, TFlt> TStrFltKd;
354  typedef TKeyDat<TStr, TAscFlt> TStrAscFltKd;
355  typedef TKeyDat<TStr, TStr> TStrKd;
356  template <class TVal1, class TVal2>
357  class TCmpKeyDatByDat {
358  private:
359    bool IsAsc;
360  public:
361    TCmpKeyDatByDat(const bool& AscSort=true) : IsAsc(AscSort) { }
362    bool operator () (const TKeyDat<TVal1, TVal2>& P1, const TKeyDat<TVal1, TVal2>& P2) const {
363      if (IsAsc) { return P1.Dat < P2.Dat; } else { return P2.Dat < P1.Dat; }
364    }
365  };
366  template <class TVal, class TSizeTy = int>
367  class TVec{
368  public:
369    typedef TVal* TIter;  
370  protected:
371    TSizeTy MxVals; 
372    TSizeTy Vals;   
373    TVal* ValT;     
374    bool IsShM; 
375    void Resize(const TSizeTy& _MxVals=-1);
376    TStr GetXOutOfBoundsErrMsg(const TSizeTy& ValN) const;
377  public:
378    TVec(): MxVals(0), Vals(0), ValT(NULL), IsShM(false) {}
379    TVec(const TVec<TVal, TSizeTy>& Vec);
380    explicit TVec(const TSizeTy& _Vals){
381      IsShM = false;
382      IAssert(0<=_Vals); MxVals=Vals=_Vals;
383      if (_Vals==0){ValT=NULL;} else {ValT=new TVal[_Vals];}}
384    TVec(const TSizeTy& _MxVals, const TSizeTy& _Vals){
385      IsShM = false;
386      IAssert((0<=_Vals)&&(_Vals<=_MxVals)); MxVals=_MxVals; Vals=_Vals;
387      if (_MxVals==0){ValT=NULL;} else {ValT=new TVal[_MxVals];}}
388    explicit TVec(TVal *_ValT, const TSizeTy& _Vals):
389      MxVals(-1), Vals(_Vals), ValT(_ValT), IsShM(false){}
390    ~TVec() {if ((ValT!=NULL) && (MxVals!=-1)) {delete[] ValT;}}
391    explicit TVec(TSIn& SIn): MxVals(0), Vals(0), ValT(NULL), IsShM(false) {Load(SIn);}
392    void LoadShM(TShMIn& ShMIn);
393    template <typename TLoadShMElem>
394    void LoadShM(TShMIn& ShMIn, TLoadShMElem LoadFromShMFn) {
395      if ((ValT!=NULL) && (MxVals!=-1)) {delete[] ValT;}
396      ShMIn.Load(MxVals);
397      ShMIn.Load(Vals);
398      if (MxVals == 0) {
399        ValT = NULL;
400      } else {
401          ValT=new TVal[MxVals];
402          for (TSizeTy ValN=0; ValN<Vals; ValN++) {
403            LoadFromShMFn(ValT+ValN, ShMIn);
404          }
405      }
406      IsShM = false;
407    }
408    void Load(TSIn& SIn);
409    void Save(TSOut& SOut) const;
410    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
411    void SaveXml(TSOut& SOut, const TStr& Nm) const;
412    TVec<TVal, TSizeTy>& operator=(const TVec<TVal, TSizeTy>& Vec);
413    TVec<TVal, TSizeTy>& operator+(const TVal& Val){Add(Val); return *this;}
414    bool operator==(const TVec<TVal, TSizeTy>& Vec) const;
415    bool operator<(const TVec<TVal, TSizeTy>& Vec) const;
416    const TVal& operator[](const TSizeTy& ValN) const {
417      AssertR((0<=ValN)&&(ValN<Vals), GetXOutOfBoundsErrMsg(ValN));
418      return ValT[ValN];}
419    TVal& operator[](const TSizeTy& ValN){
420      AssertR((0<=ValN)&&(ValN<Vals), GetXOutOfBoundsErrMsg(ValN));
421      return ValT[ValN];}
422    TSizeTy GetMemUsed() const {
423      return TSizeTy(2*sizeof(TSizeTy)+sizeof(TVal*)+MxVals*sizeof(TVal));}
424    TSizeTy GetMemSize() const {
425      return TSizeTy(2*sizeof(TVal)+sizeof(TSizeTy)*Vals);}
426    int GetPrimHashCd() const;
427    int GetSecHashCd() const;
428    void Gen(const TSizeTy& _Vals){ IAssert(0<=_Vals);
429      if (ValT!=NULL && MxVals!=-1){delete[] ValT;} MxVals=Vals=_Vals;
430      if (MxVals==0){ValT=NULL;} else {ValT=new TVal[MxVals];}}
431    void Gen(const TSizeTy& _MxVals, const TSizeTy& _Vals){ IAssert((0<=_Vals)&&(_Vals<=_MxVals));
432      if (ValT!=NULL  && MxVals!=-1){delete[] ValT;} MxVals=_MxVals; Vals=_Vals;
433      if (_MxVals==0){ValT=NULL;} else {ValT=new TVal[_MxVals];}}
434    void GenExt(TVal *_ValT, const TSizeTy& _Vals){
435      if (ValT!=NULL && MxVals!=-1){delete[] ValT;}
436      MxVals=-1; Vals=_Vals; ValT=_ValT;}
437    bool IsExt() const {return MxVals==-1;}
438    void Reserve(const TSizeTy& _MxVals){Resize(_MxVals);}
439    void Reserve(const TSizeTy& _MxVals, const TSizeTy& _Vals){ IAssert((0<=_Vals)&&(_Vals<=_MxVals)); Resize(_MxVals); Vals=_Vals;}
440    void Clr(const bool& DoDel=true, const TSizeTy& NoDelLim=-1);
441    void Trunc(const TSizeTy& _Vals=-1);
442    void Reduce(const TSizeTy& _Vals=-1) {Vals = _Vals;}
443    void Pack();
444    void MoveFrom(TVec<TVal, TSizeTy>& Vec);
445    void CopyUniqueFrom(TVec<TVal, TSizeTy>& Vec, TInt Offset, TInt Sz);
446    void Swap(TVec<TVal, TSizeTy>& Vec);
447    bool Empty() const {return Vals==0;}
448    TSizeTy Len() const {return Vals;}
449    TSizeTy Reserved() const {return MxVals;}
450    const TVal& Last() const {return GetVal(Len()-1);}
451    TVal& Last(){return GetVal(Len()-1);}
452    TSizeTy LastValN() const {return Len()-1;}
453    const TVal& LastLast() const { AssertR(1<Vals, GetXOutOfBoundsErrMsg(Vals-2)); return ValT[Vals-2];}
454    TVal& LastLast(){ AssertR(1<Vals, GetXOutOfBoundsErrMsg(Vals-2)); return ValT[Vals-2];}
455    const TVal& GetRndVal(TRnd& Rnd=TInt::Rnd) const { return GetVal(Rnd.GetUniDevInt(Len())); }
456    TVal& GetRndVal(TRnd& Rnd=TInt::Rnd) { return GetVal(Rnd.GetUniDevInt(Len())); }
457    TIter BegI() const {return ValT;}
458    TIter EndI() const {return ValT+Vals;}
459    TIter GetI(const TSizeTy& ValN) const {return ValT+ValN;}
460    TSizeTy Add(){ AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
461      if (Vals==MxVals){Resize();} return Vals++;}
462    TSizeTy Add(const TVal& Val){ AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
463      if (Vals==MxVals){Resize();} ValT[Vals]=Val; return Vals++;}
464    TSizeTy Add(TVal& Val){ AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
465      if (Vals==MxVals){Resize();} ValT[Vals]=Val; return Vals++;}
466    TSizeTy Add(const TVal& Val, const TSizeTy& ResizeLen){ AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
467      if (Vals==MxVals){Resize(MxVals+ResizeLen);} ValT[Vals]=Val; return Vals++;}
468  #ifdef USE_OPENMP
469    TSizeTy AddMP(const TVal& Val){ const int Idx = __sync_fetch_and_add(&Vals, 1);
470       ValT[Idx]=Val; return Idx;}
471    TSizeTy MoveLastMP(const TVal& Val, int Inc){ const int Idx = __sync_fetch_and_add(&Vals, Inc);
472    return Idx;}
473  #endif
474    TSizeTy AddV(const TVec<TVal, TSizeTy>& ValV);
475    TSizeTy AddSorted(const TVal& Val, const bool& Asc=true, const TSizeTy& _MxVals=-1);
476    TSizeTy AddBackSorted(const TVal& Val, const bool& Asc);
477    TSizeTy AddMerged(const TVal& Val);
478    TSizeTy AddVMerged(const TVec<TVal, TSizeTy>& ValV);
479    TSizeTy AddUnique(const TVal& Val);
480    const TVal& GetVal(const TSizeTy& ValN) const {return operator[](ValN);}
481    TVal& GetVal(const TSizeTy& ValN){return operator[](ValN);}
482    void SetVal(const TSizeTy& ValN, const TVal& Val){
483      EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
484      AssertR((0<=ValN)&&(ValN<Vals), GetXOutOfBoundsErrMsg(ValN)); ValT[ValN] = Val;}
485    void GetSubValV(const TSizeTy& BValN, const TSizeTy& EValN, TVec<TVal, TSizeTy>& ValV) const;
486    void Ins(const TSizeTy& ValN, const TVal& Val);
487    void Del(const TSizeTy& ValN);
488    void Del(const TSizeTy& MnValN, const TSizeTy& MxValN);
489    void DelLast(){Del(Len()-1);}
490    bool DelIfIn(const TVal& Val);
491    void DelAll(const TVal& Val);
492    void PutAll(const TVal& Val);
493    void Swap(const TSizeTy& ValN1, const TSizeTy& ValN2){EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
494      const TVal Val=ValT[ValN1]; ValT[ValN1]=ValT[ValN2]; ValT[ValN2]=Val;}
495    static void SwapI(TIter LVal, TIter RVal){const TVal Val=*LVal; *LVal=*RVal; *RVal=Val;}
496    bool NextPerm();
497    bool PrevPerm();
498    TSizeTy GetPivotValN(const TSizeTy& LValN, const TSizeTy& RValN) const;
499    void BSort(const TSizeTy& MnLValN, const TSizeTy& MxRValN, const bool& Asc);
500    void ISort(const TSizeTy& MnLValN, const TSizeTy& MxRValN, const bool& Asc);
501    TSizeTy Partition(const TSizeTy& MnLValN, const TSizeTy& MxRValN, const bool& Asc);
502    void QSort(const TSizeTy& MnLValN, const TSizeTy& MxRValN, const bool& Asc);
503    void Sort(const bool& Asc=true);
504    bool IsSorted(const bool& Asc=true) const;
505    void Shuffle(TRnd& Rnd);
506    void Reverse();
507    void Reverse(TSizeTy LValN, TSizeTy RValN){ Assert(LValN>=0 && RValN<Len()); while (LValN < RValN){Swap(LValN++, RValN--);} }
508    void Merge();
509    template <class TCmp>
510    static TIter GetPivotValNCmp(const TIter& BI, const TIter& EI, const TCmp& Cmp) {
511      TSizeTy SubVals=TSizeTy(EI-BI); if (SubVals > TInt::Mx-1) { SubVals = TInt::Mx-1; }
512      const TSizeTy ValN1=TInt::GetRnd(SubVals), ValN2=TInt::GetRnd(SubVals), ValN3=TInt::GetRnd(SubVals);
513      const TVal& Val1 = *(BI+ValN1);  const TVal& Val2 = *(BI+ValN2); const TVal& Val3 = *(BI+ValN3);
514      if (Cmp(Val1, Val2)) {
515        if (Cmp(Val2, Val3)) return BI+ValN2;
516        else if (Cmp(Val3, Val1)) return BI+ValN1;
517        else return BI+ValN3;
518      } else {
519        if (Cmp(Val1, Val3)) return BI+ValN1;
520        else if (Cmp(Val3, Val2)) return BI+ValN2;
521        else return BI+ValN3; } }
522    template <class TCmp>
523    static TIter PartitionCmp(TIter BI, TIter EI, const TVal Pivot, const TCmp& Cmp) {
524      forever {
525        while (Cmp(*BI, Pivot)){++BI;}  --EI;
526        while (Cmp(Pivot, *EI)){--EI;}
527        if (!(BI<EI)){return BI;}  SwapI(BI, EI);  ++BI; } }
528    template <class TCmp>
529    static void BSortCmp(TIter BI, TIter EI, const TCmp& Cmp) {
530      for (TIter i = BI; i != EI; ++i) {
531        for (TIter j = EI-1; j != i; --j) {
532          if (Cmp(*j, *(j-1))) { SwapI(j, j-1); } } } }
533    template <class TCmp>
534    static void ISortCmp(TIter BI, TIter EI, const TCmp& Cmp) {
535      if (BI + 1 < EI) {
536        for (TIter i = BI, j; i != EI; ++i) { TVal Tmp=*i;  j=i;
537          while (j > BI && Cmp(Tmp, *(j-1))) { *j = *(j-1); --j; } *j=Tmp; } } }
538    template <class TCmp>
539    static void QSortCmp(TIter BI, TIter EI, const TCmp& Cmp) {
540      if (BI + 1 < EI) {
541        if (EI - BI < 20) { ISortCmp(BI, EI, Cmp); }
542        else { const TVal Val = *GetPivotValNCmp(BI, EI, Cmp);
543          TIter Split = PartitionCmp(BI, EI, Val, Cmp);
544          QSortCmp(BI, Split, Cmp);  QSortCmp(Split, EI, Cmp); } } }
545    template <class TCmp>
546    void SortCmp(const TCmp& Cmp){ QSortCmp(BegI(), EndI(), Cmp);}
547    template <class TCmp>
548    bool IsSortedCmp(const TCmp& Cmp) const {
549      if (EndI() == BegI()) return true;
550      for (TIter i = BegI(); i != EndI()-1; ++i) {
551        if (Cmp(*(i+1), *i)){return false;} } return true; }
552    void Intrs(const TVec<TVal, TSizeTy>& ValV);
553    void Union(const TVec<TVal, TSizeTy>& ValV);
554    void Diff(const TVec<TVal, TSizeTy>& ValV);
555    void Intrs(const TVec<TVal, TSizeTy>& ValV, TVec<TVal, TSizeTy>& DstValV) const;
556    void Union(const TVec<TVal, TSizeTy>& ValV, TVec<TVal, TSizeTy>& DstValV) const;
557    void Diff(const TVec<TVal, TSizeTy>& ValV, TVec<TVal, TSizeTy>& DstValV) const;
558    TSizeTy IntrsLen(const TVec<TVal, TSizeTy>& ValV) const;
559    TSizeTy UnionLen(const TVec<TVal, TSizeTy>& ValV) const;
560    TSizeTy Count(const TVal& Val) const;
561    TSizeTy SearchBin(const TVal& Val) const;
562    TSizeTy SearchBin(const TVal& Val, TSizeTy& InsValN) const;
563    TSizeTy SearchBinLeft(const TVal& Val, TSizeTy& InsValN) const;
564    TSizeTy SearchForw(const TVal& Val, const TSizeTy& BValN=0) const;
565    TSizeTy SearchBack(const TVal& Val) const;
566    TSizeTy SearchVForw(const TVec<TVal, TSizeTy>& ValV, const TSizeTy& BValN=0) const;
567    bool IsIn(const TVal& Val) const {return SearchForw(Val)!=-1;}
568    bool IsIn(const TVal& Val, TSizeTy& ValN) const { ValN=SearchForw(Val); return ValN!=-1;}
569    bool IsInBin(const TVal& Val) const {return SearchBin(Val)!=-1;}
570    const TVal& GetDat(const TVal& Val) const { return GetVal(SearchForw(Val));}
571    TVal& GetAddDat(const TVal& Val){ AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
572      const TSizeTy ValN=SearchForw(Val); if (ValN==-1){Add(Val); return Last();} else {return GetVal(ValN);}}
573    TSizeTy GetMxValN() const;
574    static TVec<TVal, TSizeTy> GetV(const TVal& Val1){
575      TVec<TVal, TSizeTy> V(1, 0); V.Add(Val1); return V;}
576    static TVec<TVal, TSizeTy> GetV(const TVal& Val1, const TVal& Val2){
577      TVec<TVal, TSizeTy> V(2, 0); V.Add(Val1); V.Add(Val2); return V;}
578    static TVec<TVal, TSizeTy> GetV(const TVal& Val1, const TVal& Val2, const TVal& Val3){
579      TVec<TVal, TSizeTy> V(3, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); return V;}
580    static TVec<TVal, TSizeTy> GetV(const TVal& Val1, const TVal& Val2, const TVal& Val3, const TVal& Val4){
581      TVec<TVal, TSizeTy> V(4, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); return V;}
582    static TVec<TVal, TSizeTy> GetV(const TVal& Val1, const TVal& Val2, const TVal& Val3, const TVal& Val4, const TVal& Val5){
583      TVec<TVal, TSizeTy> V(5, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); return V;}
584    static TVec<TVal, TSizeTy> GetV(const TVal& Val1, const TVal& Val2, const TVal& Val3, const TVal& Val4, const TVal& Val5, const TVal& Val6){
585      TVec<TVal, TSizeTy> V(6, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); V.Add(Val6); return V;}
586    static TVec<TVal, TSizeTy> GetV(const TVal& Val1, const TVal& Val2, const TVal& Val3, const TVal& Val4, const TVal& Val5, const TVal& Val6, const TVal& Val7){
587      TVec<TVal, TSizeTy> V(7, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); V.Add(Val6); V.Add(Val7); return V;}
588    static TVec<TVal, TSizeTy> GetV(const TVal& Val1, const TVal& Val2, const TVal& Val3, const TVal& Val4, const TVal& Val5, const TVal& Val6, const TVal& Val7, const TVal& Val8){
589      TVec<TVal, TSizeTy> V(8, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); V.Add(Val6); V.Add(Val7); V.Add(Val8); return V;}
590    static TVec<TVal, TSizeTy> GetV(const TVal& Val1, const TVal& Val2, const TVal& Val3, const TVal& Val4, const TVal& Val5, const TVal& Val6, const TVal& Val7, const TVal& Val8, const TVal& Val9){
591      TVec<TVal, TSizeTy> V(9, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); V.Add(Val6); V.Add(Val7); V.Add(Val8); V.Add(Val9); return V;}
592  };
593  template <class TVal, class TSizeTy>
594  void TVec<TVal, TSizeTy>::Resize(const TSizeTy& _MxVals){
595    IAssertR(MxVals!=-1 || IsShM, TStr::Fmt("Can not increase the capacity of the vector. %s. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]", GetTypeNm(*this).CStr()).CStr());
596    IAssertR(MxVals!=(TInt::Mx-1024), TStr::Fmt("Buffer size at maximum. %s. [Program refuses to allocate more memory. Solution-1: Send your test case to developers.]", GetTypeNm(*this).CStr()).CStr());
597    TSizeTy OldMxVals = MxVals;
598    if (MxVals == -1) {MxVals = Vals;}
599    if (_MxVals==-1){
600      if (Vals==0){MxVals=16;} else {MxVals*=2;}
601    } else {
602      if (_MxVals<=MxVals){return;} else {MxVals=_MxVals;}
603    }
604    if (MxVals < 0) {
605      MxVals = TInt::Mx-1024;
606    }
607    if (ValT==NULL){
608      try {
609        ValT=new TVal[MxVals];
610      }
611      catch (std::exception Ex){
612        FailR(TStr::Fmt("TVec::Resize: %s, Length:%s, Capacity:%s, New capacity:%s, Type:%s [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]",
613          Ex.what(), TInt::GetStr(Vals).CStr(), TInt::GetStr(MxVals).CStr(), TInt::GetStr(_MxVals).CStr(), GetTypeNm(*this).CStr()).CStr());}
614    } else {
615      TVal* NewValT = NULL;
616      try {
617        NewValT=new TVal[MxVals];
618      }
619      catch (std::exception Ex){
620        FailR(TStr::Fmt("TVec::Resize: %s, Length:%s, Capacity:%s, New capacity:%s, Type:%s [Program failed to allocate more memory. Solution-1: Get a bigger machine and a 64-bit compiler.]",
621          Ex.what(), TInt::GetStr(Vals).CStr(), TInt::GetStr(MxVals).CStr(), TInt::GetStr(_MxVals).CStr(), GetTypeNm(*this).CStr()).CStr());}
622      IAssert(NewValT!=NULL);
623      for (TSizeTy ValN=0; ValN<Vals; ValN++){NewValT[ValN]=ValT[ValN];}
624      if (OldMxVals != -1) {delete[] ValT;} ValT=NewValT;
625    }
626    IsShM = false;
627  }
628  template <class TVal, class TSizeTy>
629  TStr TVec<TVal, TSizeTy>::GetXOutOfBoundsErrMsg(const TSizeTy& ValN) const {
630    return TStr()+
631    "Index:"+TInt::GetStr(ValN)+
632    " Vals:"+TInt::GetStr(Vals)+
633    " MxVals:"+TInt::GetStr(MxVals)+
634    " Type:"+GetTypeNm(*this);
635  }
636  template <class TVal, class TSizeTy>
637  TVec<TVal, TSizeTy>::TVec(const TVec<TVal, TSizeTy>& Vec){
638    MxVals=Vec.MxVals;
639    Vals=Vec.Vals;
640    if (MxVals==0) {ValT=NULL;} else {ValT=new TVal[MxVals];}
641    for (TSizeTy ValN=0; ValN<Vec.Vals; ValN++){ValT[ValN]=Vec.ValT[ValN];}
642    IsShM = false;
643  }
644  template <class TVal, class TSizeTy>
645  void TVec<TVal, TSizeTy>::LoadShM(TShMIn& ShMIn) {
646    if ((ValT!=NULL) && (MxVals!=-1)) {delete[] ValT;}
647    ShMIn.Load(MxVals);
648    MxVals = -1;
649    ShMIn.Load(Vals);
650    if (MxVals == 0) {
651      ValT = NULL;
652    } else {
653        ValT = (TVal*)(ShMIn.AdvanceCursor(Vals*sizeof(TVal)));
654        IsShM = true;
655    }
656  }
657  template <class TVal, class TSizeTy>
658  void TVec<TVal, TSizeTy>::Load(TSIn& SIn){
659    if ( (ValT!=NULL) && (MxVals!=-1)) {delete[] ValT;}
660    SIn.Load(MxVals); SIn.Load(Vals); MxVals=Vals;
661    if ( MxVals==0 ){ValT=NULL;} else {ValT=new TVal[MxVals];}
662    for (TSizeTy ValN=0; ValN<Vals; ValN++){ValT[ValN]=TVal(SIn);}
663  }
664  template <class TVal, class TSizeTy>
665  void TVec<TVal, TSizeTy>::Save(TSOut& SOut) const {
666    if (MxVals!=-1){SOut.Save(MxVals);} else {SOut.Save(Vals);}
667    SOut.Save(Vals);
668    for (TSizeTy ValN=0; ValN<Vals; ValN++){ValT[ValN].Save(SOut);}
669  }
670  template <class TVal, class TSizeTy>
671  TVec<TVal, TSizeTy>& TVec<TVal, TSizeTy>::operator=(const TVec<TVal, TSizeTy>& Vec){
672    if (this!=&Vec){
673      if ((ValT!=NULL)&&(MxVals!=-1)){delete[] ValT;}
674      MxVals=Vals=Vec.Vals;
675      if (MxVals==0){ValT=NULL;} else {ValT=new TVal[MxVals];}
676      for (TSizeTy ValN=0; ValN<Vec.Vals; ValN++){ValT[ValN]=Vec.ValT[ValN];}
677    }
678    return *this;
679  }
680  template <class TVal, class TSizeTy>
681  bool TVec<TVal, TSizeTy>::operator==(const TVec<TVal, TSizeTy>& Vec) const {
682    if (this==&Vec){return true;}
683    if (Len()!=Vec.Len()){return false;}
684    for (TSizeTy ValN=0; ValN<Vals; ValN++){
685      if (ValT[ValN]!=Vec.ValT[ValN]){return false;}}
686    return true;
687  }
688  template <class TVal, class TSizeTy>
689  bool TVec<TVal, TSizeTy>::operator<(const TVec<TVal, TSizeTy>& Vec) const {
690    if (this==&Vec){return false;}
691    if (Len()==Vec.Len()){
692      for (TSizeTy ValN=0; ValN<Vals; ValN++){
693        if (ValT[ValN]<Vec.ValT[ValN]){return true;}
694        else if (ValT[ValN]>Vec.ValT[ValN]){return false;}
695        else {}
696      }
697      return false;
698    } else {
699      return Len()<Vec.Len();
700    }
701  }
702  template <class TVal, class TSizeTy>
703  int TVec<TVal, TSizeTy>::GetPrimHashCd() const {
704    int hc = 0;
705    for (TSizeTy i=0; i<Vals; i++){
706      hc = TPairHashImpl::GetHashCd(hc, ValT[i].GetPrimHashCd());
707    }
708    return hc;
709  }
710  template <class TVal, class TSizeTy>
711  int TVec<TVal, TSizeTy>::GetSecHashCd() const {
712    int hc = 0;
713    for (TSizeTy i=0; i<Vals; i++){
714      hc = TPairHashImpl::GetHashCd(hc, ValT[i].GetSecHashCd());
715    }
716    if (Vals > 0) {
717      hc = TPairHashImpl::GetHashCd(hc, ValT[0].GetSecHashCd()); }
718    return hc;
719  }
720  template <class TVal, class TSizeTy>
721  void TVec<TVal, TSizeTy>::Clr(const bool& DoDel, const TSizeTy& NoDelLim){
722    if ((DoDel)||((!DoDel)&&(NoDelLim!=-1)&&(MxVals>NoDelLim))){
723      if ((ValT!=NULL)&&(MxVals!=-1)){delete[] ValT;}
724      MxVals=Vals=0; ValT=NULL;
725    } else {
726      IAssertR(MxVals!=-1 || IsShM, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
727      Vals=0;
728    }
729  }
730  template <class TVal, class TSizeTy>
731  void TVec<TVal, TSizeTy>::Trunc(const TSizeTy& _Vals){
732    EAssertR(!(MxVals==-1 && IsShM), "Cannot truncate a shared memory vector");
733    IAssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
734    IAssert((_Vals==-1)||(_Vals>=0));
735    if ((_Vals!=-1)&&(_Vals>=Vals)){
736      return;
737    } else
738      if (((_Vals==-1)&&(Vals==0))||(_Vals==0)){
739        if (ValT!=NULL){delete[] ValT;}
740        MxVals=Vals=0; ValT=NULL;
741      } else {
742        if (_Vals==-1){
743          if (MxVals==Vals){return;} else {MxVals=Vals;}
744        } else {
745          MxVals=Vals=_Vals;
746        }
747        TVal* NewValT=new TVal[MxVals];
748        IAssert(NewValT!=NULL);
749        for (TSizeTy ValN=0; ValN<Vals; ValN++){NewValT[ValN]=ValT[ValN];}
750        delete[] ValT; ValT=NewValT;
751      }
752  }
753  template <class TVal, class TSizeTy>
754  void TVec<TVal, TSizeTy>::Pack(){
755    EAssertR(!(IsShM && (MxVals == -1)), "Cannot pack accessed shared memory");
756    IAssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
757    if (Vals==0){
758      if (ValT!=NULL){delete[] ValT;} ValT=NULL;
759    } else
760      if (Vals<MxVals){
761        MxVals=Vals;
762        TVal* NewValT=new TVal[MxVals];
763        IAssert(NewValT!=NULL);
764        for (TSizeTy ValN=0; ValN<Vals; ValN++){NewValT[ValN]=ValT[ValN];}
765        delete[] ValT; ValT=NewValT;
766      }
767  }
768  template <class TVal, class TSizeTy>
769  void TVec<TVal, TSizeTy>::MoveFrom(TVec<TVal, TSizeTy>& Vec){
770    if (this!=&Vec){
771      if (ValT!=NULL && MxVals!=-1){delete[] ValT;}
772      MxVals=Vec.MxVals; Vals=Vec.Vals; ValT=Vec.ValT;
773      Vec.MxVals=0; Vec.Vals=0; Vec.ValT=NULL;
774    }
775  }
776  template <class TVal, class TSizeTy>
777  void TVec<TVal, TSizeTy>::CopyUniqueFrom(TVec<TVal, TSizeTy>& Vec, TInt Offset, TInt Sz){
778    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
779    if (this!=&Vec){
780      if (ValT!=NULL && MxVals!=-1 && MxVals < Sz){
781        delete[] ValT;
782        ValT=new TVal[Sz];
783      }
784      if (Sz == 0) { Vals = 0; return; }
785      ValT[0] = Vec.ValT[Offset];
786      Vals = 1;
787      for (TSizeTy ValN=1; ValN<Sz; ValN++){
788        if (ValT[Vals-1] != Vec.ValT[Offset+ValN]) {
789          ValT[Vals++] = Vec.ValT[Offset+ValN];
790        }
791      }
792    }
793  }
794  template <class TVal, class TSizeTy>
795  void TVec<TVal, TSizeTy>::Swap(TVec<TVal, TSizeTy>& Vec){
796    if (this!=&Vec){
797      ::Swap(MxVals, Vec.MxVals);
798      ::Swap(Vals, Vec.Vals);
799      ::Swap(ValT, Vec.ValT);
800    }
801  }
802  template <class TVal, class TSizeTy>
803  TSizeTy TVec<TVal, TSizeTy>::AddV(const TVec<TVal, TSizeTy>& ValV){
804    AssertR(MxVals!=-1 || IsShM, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
805    for (TSizeTy ValN=0; ValN<ValV.Vals; ValN++){Add(ValV[ValN]);}
806    return Len();
807  }
808  template <class TVal, class TSizeTy>
809  TSizeTy TVec<TVal, TSizeTy>::AddSorted(const TVal& Val, const bool& Asc, const TSizeTy& _MxVals){
810    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
811    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
812    TSizeTy ValN=Add(Val);
813    if (Asc){
814      while ((ValN>0)&&(ValT[ValN]<ValT[ValN-1])){
815        Swap(ValN, ValN-1); ValN--;}
816    } else {
817      while ((ValN>0)&&(ValT[ValN]>ValT[ValN-1])){
818        Swap(ValN, ValN-1); ValN--;}
819    }
820    if ((_MxVals!=-1)&&(Len()>_MxVals)){Del(_MxVals, Len()-1);}
821    return ValN;
822  }
823  template <class TVal, class TSizeTy>
824  TSizeTy TVec<TVal, TSizeTy>::AddBackSorted(const TVal& Val, const bool& Asc){
825    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
826    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
827    Add();
828    TSizeTy ValN=Vals-2;
829    while ((ValN>=0)&&((Asc&&(Val<ValT[ValN]))||(!Asc&&(Val>ValT[ValN])))){
830      ValT[ValN+1]=ValT[ValN]; ValN--;}
831    ValT[ValN+1]=Val;
832    return ValN+1;
833  }
834  template <class TVal, class TSizeTy>
835  TSizeTy TVec<TVal, TSizeTy>::AddMerged(const TVal& Val){
836    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
837    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
838    TSizeTy ValN=SearchBin(Val);
839    if (ValN==-1){return AddSorted(Val);}
840    else {GetVal(ValN)=Val; return -1;}
841  }
842  template <class TVal, class TSizeTy>
843  TSizeTy TVec<TVal, TSizeTy>::AddVMerged(const TVec<TVal, TSizeTy>& ValV){
844    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
845    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
846    for (TSizeTy ValN=0; ValN<ValV.Vals; ValN++){AddMerged(ValV[ValN]);}
847    return Len();
848  }
849  template <class TVal, class TSizeTy>
850  TSizeTy TVec<TVal, TSizeTy>::AddUnique(const TVal& Val){
851    AssertR(MxVals!=-1 || IsShM, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
852    TSizeTy ValN=SearchForw(Val);
853    if (ValN==-1){return Add(Val);}
854    else {GetVal(ValN)=Val; return -1;}
855  }
856  template <class TVal, class TSizeTy>
857  void TVec<TVal, TSizeTy>::GetSubValV(const TSizeTy& _BValN, const TSizeTy& _EValN, TVec<TVal, TSizeTy>& SubValV) const {
858    const TSizeTy BValN=TInt::GetInRng(_BValN, 0, Len()-1);
859    const TSizeTy EValN=TInt::GetInRng(_EValN, 0, Len()-1);
860    const TSizeTy SubVals=TInt::GetMx(0, EValN-BValN+1);
861    SubValV.Gen(SubVals, 0);
862    for (TSizeTy ValN=BValN; ValN<=EValN; ValN++){
863      SubValV.Add(GetVal(ValN));}
864  }
865  template <class TVal, class TSizeTy>
866  void TVec<TVal, TSizeTy>::Ins(const TSizeTy& ValN, const TVal& Val){
867    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
868    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
869    Add();  Assert((0<=ValN)&&(ValN<Vals));
870    for (TSizeTy MValN=Vals-2; MValN>=ValN; MValN--){ValT[MValN+1]=ValT[MValN];}
871    ValT[ValN]=Val;
872  }
873  template <class TVal, class TSizeTy>
874  void TVec<TVal, TSizeTy>::Del(const TSizeTy& ValN){
875    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
876    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
877    Assert((0<=ValN)&&(ValN<Vals));
878    for (TSizeTy MValN=ValN+1; MValN<Vals; MValN++){
879      ValT[MValN-1]=ValT[MValN];}
880    ValT[--Vals]=TVal();
881  }
882  template <class TVal, class TSizeTy>
883  void TVec<TVal, TSizeTy>::Del(const TSizeTy& MnValN, const TSizeTy& MxValN){
884    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
885    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
886    Assert((0<=MnValN)&&(MnValN<Vals)&&(0<=MxValN)&&(MxValN<Vals));
887    Assert(MnValN<=MxValN);
888    for (TSizeTy ValN=MxValN+1; ValN<Vals; ValN++){
889      ValT[MnValN+ValN-MxValN-1]=ValT[ValN];}
890    for (TSizeTy ValN=Vals-MxValN+MnValN-1; ValN<Vals; ValN++){
891      ValT[ValN]=TVal();}
892    Vals-=MxValN-MnValN+1;
893  }
894  template <class TVal, class TSizeTy>
895  bool TVec<TVal, TSizeTy>::DelIfIn(const TVal& Val){
896    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
897    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
898    TSizeTy ValN=SearchForw(Val);
899    if (ValN!=-1){Del(ValN); return true;}
900    else {return false;}
901  }
902  template <class TVal, class TSizeTy>
903  void TVec<TVal, TSizeTy>::DelAll(const TVal& Val){
904    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
905    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
906    TSizeTy ValN;
907    while ((ValN=SearchForw(Val))!=-1){Del(ValN);}
908  }
909  template <class TVal, class TSizeTy>
910  void TVec<TVal, TSizeTy>::PutAll(const TVal& Val){
911    EAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
912    for (TSizeTy ValN=0; ValN<Vals; ValN++){ValT[ValN]=Val;}
913  }
914  template <class TVal, class TSizeTy>
915  void TVec<TVal, TSizeTy>::BSort(const TSizeTy& MnLValN, const TSizeTy& MxRValN, const bool& Asc){
916    for (TSizeTy ValN1=MnLValN; ValN1<=MxRValN; ValN1++){
917      for (TSizeTy ValN2=MxRValN; ValN2>ValN1; ValN2--){
918        if (Asc){
919          if (ValT[ValN2]<ValT[ValN2-1]){Swap(ValN2, ValN2-1);}
920        } else {
921          if (ValT[ValN2]>ValT[ValN2-1]){Swap(ValN2, ValN2-1);}
922        }
923      }
924    }
925  }
926  template <class TVal, class TSizeTy>
927  void TVec<TVal, TSizeTy>::ISort(const TSizeTy& MnLValN, const TSizeTy& MxRValN, const bool& Asc){
928    if (MnLValN<MxRValN){
929      for (TSizeTy ValN1=MnLValN+1; ValN1<=MxRValN; ValN1++){
930        TVal Val=ValT[ValN1]; TSizeTy ValN2=ValN1;
931        if (Asc){
932          while ((ValN2>MnLValN)&&(ValT[ValN2-1]>Val)){
933            ValT[ValN2]=ValT[ValN2-1]; ValN2--;}
934        } else {
935          while ((ValN2>MnLValN)&&(ValT[ValN2-1]<Val)){
936            ValT[ValN2]=ValT[ValN2-1]; ValN2--;}
937        }
938        ValT[ValN2]=Val;
939      }
940    }
941  }
942  template <class TVal, class TSizeTy>
943  TSizeTy TVec<TVal, TSizeTy>::GetPivotValN(const TSizeTy& LValN, const TSizeTy& RValN) const {
944    TSizeTy SubVals=RValN-LValN+1;
945    if (SubVals > TInt::Mx-1) { SubVals = TInt::Mx-1; }
946    const TSizeTy ValN1=LValN+TInt::GetRnd(int(SubVals));
947    const TSizeTy ValN2=LValN+TInt::GetRnd(int(SubVals));
948    const TSizeTy ValN3=LValN+TInt::GetRnd(int(SubVals));
949    const TVal& Val1=ValT[ValN1];
950    const TVal& Val2=ValT[ValN2];
951    const TVal& Val3=ValT[ValN3];
952    if (Val1<Val2){
953      if (Val2<Val3){return ValN2;}
954      else if (Val3<Val1){return ValN1;}
955      else {return ValN3;}
956    } else {
957      if (Val1<Val3){return ValN1;}
958      else if (Val3<Val2){return ValN2;}
959      else {return ValN3;}
960    }
961  }
962  template <class TVal, class TSizeTy>
963  TSizeTy TVec<TVal, TSizeTy>::Partition(const TSizeTy& MnLValN, const TSizeTy& MxRValN, const bool& Asc){
964    TSizeTy PivotValN=GetPivotValN(MnLValN, MxRValN);
965    Swap(PivotValN, MnLValN);
966    TVal PivotVal=ValT[MnLValN];
967    TSizeTy LValN=MnLValN-1;  TSizeTy RValN=MxRValN+1;
968    forever {
969      if (Asc){
970        do {RValN--;} while (ValT[RValN]>PivotVal);
971        do {LValN++;} while (ValT[LValN]<PivotVal);
972      } else {
973        do {RValN--;} while (ValT[RValN]<PivotVal);
974        do {LValN++;} while (ValT[LValN]>PivotVal);
975      }
976      if (LValN<RValN){Swap(LValN, RValN);}
977      else {return RValN;}
978    };
979  }
980  template <class TVal, class TSizeTy>
981  void TVec<TVal, TSizeTy>::QSort(const TSizeTy& MnLValN, const TSizeTy& MxRValN, const bool& Asc){
982    if (MnLValN<MxRValN){
983      if (MxRValN-MnLValN<20){
984        ISort(MnLValN, MxRValN, Asc);
985      } else {
986        TSizeTy SplitValN=Partition(MnLValN, MxRValN, Asc);
987        QSort(MnLValN, SplitValN, Asc);
988        QSort(SplitValN+1, MxRValN, Asc);
989      }
990    }
991  }
992  template <class TVal, class TSizeTy>
993  void TVec<TVal, TSizeTy>::Sort(const bool& Asc){
994    QSort(0, Len()-1, Asc);
995  }
996  template <class TVal, class TSizeTy>
997  bool TVec<TVal, TSizeTy>::IsSorted(const bool& Asc) const {
998    if (Asc){
999      for (TSizeTy ValN=0; ValN<Vals-1; ValN++){
1000        if (ValT[ValN]>ValT[ValN+1]){return false;}}
1001    } else {
<span onclick='openModal()' class='match'>1002      for (TSizeTy ValN=0; ValN<Vals-1; ValN++){
1003        if (ValT[ValN]<ValT[ValN+1]){return false;}}
1004    }
1005    return true;
1006  }
</span>1007  template <class TVal, class TSizeTy>
1008  void TVec<TVal, TSizeTy>::Shuffle(TRnd& Rnd){
1009    if (Len() < TInt::Mx) {
1010      for (TSizeTy ValN=0; ValN<Vals-1; ValN++){
1011        const int Range = int(Vals-ValN);
1012        Swap(ValN, ValN+Rnd.GetUniDevInt(Range));
1013      }
1014    } else {
1015      for (TSizeTy ValN=0; ValN<Vals-1; ValN++){
1016        const TSizeTy Range = Vals-ValN;
1017        Swap(ValN, TSizeTy(ValN+Rnd.GetUniDevInt64(Range)));
1018      }
1019    }
1020  }
1021  template <class TVal, class TSizeTy>
1022  void TVec<TVal, TSizeTy>::Reverse(){
1023    for (TSizeTy ValN=0; ValN<Vals/2; ValN++){
1024      Swap(ValN, Vals-ValN-1);}
1025  }
1026  template <class TVal, class TSizeTy>
1027  void TVec<TVal, TSizeTy>::Merge(){
1028    IAssertR(!(IsShM && (MxVals == -1)), "Cannot write to shared memory");
1029    AssertR(MxVals!=-1, "This vector was obtained from TVecPool. Such vectors cannot change its size!");
1030    TVec<TVal, TSizeTy> SortedVec(*this); SortedVec.Sort();
1031    Clr();
1032    for (TSizeTy ValN=0; ValN<SortedVec.Len(); ValN++){
1033      if ((ValN==0)||(SortedVec[ValN-1]!=SortedVec[ValN])){
1034        Add(SortedVec[ValN]);}
1035    }
1036  }
1037  template <class TVal, class TSizeTy>
1038  bool TVec<TVal, TSizeTy>::NextPerm() {
1039    TSizeTy First = 0, Last = Len(), Next = Len()-1;
1040    if (Last < 2) return false;
1041    for(; ; ) {
1042      TSizeTy Next1 = Next;
1043      if (GetVal(--Next) < GetVal(Next1)) { 
1044        TSizeTy Mid = Last;
1045        for (; GetVal(Next) >= GetVal(--Mid); ) { }
1046        Swap(Next, Mid);
1047        Reverse(Next1, Last-1);
1048        return true;
1049      }
1050      if (Next == First) { 
1051        Reverse();
1052        return false;
1053      }
1054    }
1055  }
1056  template <class TVal, class TSizeTy>
1057  bool TVec<TVal, TSizeTy>::PrevPerm() {
1058    TSizeTy First = 0, Last = Len(), Next = Len()-1;
1059    if (Last < 2) return false;
1060    for(; ; ) {
1061      TSizeTy Next1 = Next;
1062      if (GetVal(--Next) >= GetVal(Next1)) { 
1063        TSizeTy Mid = Last;
1064        for (; GetVal(Next) < GetVal(--Mid); ) { }
1065        Swap(Next, Mid);
1066        Reverse(Next1, Last);
1067        return true;
1068      }
1069      if (Next == First) { 
1070        Reverse();
1071        return false;
1072      }
1073    }
1074  }
1075  template <class TVal, class TSizeTy>
1076  void TVec<TVal, TSizeTy>::Intrs(const TVec<TVal, TSizeTy>& ValV){
1077    TVec<TVal, TSizeTy> IntrsVec;
1078    Intrs(ValV, IntrsVec);
1079    MoveFrom(IntrsVec);
1080  }
1081  template <class TVal, class TSizeTy>
1082  void TVec<TVal, TSizeTy>::Union(const TVec<TVal, TSizeTy>& ValV){
1083    TVec<TVal, TSizeTy> UnionVec;
1084    Union(ValV, UnionVec);
1085    MoveFrom(UnionVec);
1086  }
1087  template <class TVal, class TSizeTy>
1088  void TVec<TVal, TSizeTy>::Diff(const TVec<TVal, TSizeTy>& ValV){
1089    TVec<TVal, TSizeTy> DiffVec;
1090    Diff(ValV, DiffVec);
1091    MoveFrom(DiffVec);
1092  }
1093  template <class TVal, class TSizeTy>
1094  void TVec<TVal, TSizeTy>::Intrs(const TVec<TVal, TSizeTy>& ValV, TVec<TVal, TSizeTy>& DstValV) const {
1095    DstValV.Clr();
1096    TSizeTy ValN1=0, ValN2=0;
1097    while ((ValN1<Len())&&(ValN2<ValV.Len())){
1098      const TVal& Val1=GetVal(ValN1);
1099      while ((ValN2<ValV.Len())&&(Val1>ValV.GetVal(ValN2))){
1100        ValN2++;}
1101      if ((ValN2<ValV.Len())&&(Val1==ValV.GetVal(ValN2))){
1102        DstValV.Add(Val1); ValN2++;}
1103      ValN1++;
1104    }
1105  }
1106  template <class TVal, class TSizeTy>
1107  void TVec<TVal, TSizeTy>::Union(const TVec<TVal, TSizeTy>& ValV, TVec<TVal, TSizeTy>& DstValV) const {
1108    DstValV.Gen(TInt::GetMx(Len(), ValV.Len()), 0);
1109    TSizeTy ValN1=0, ValN2=0;
1110    while ((ValN1<Len())&&(ValN2<ValV.Len())){
1111      const TVal& Val1=GetVal(ValN1);
1112      const TVal& Val2=ValV.GetVal(ValN2);
1113      if (Val1<Val2){DstValV.Add(Val1); ValN1++;}
1114      else if (Val1>Val2){DstValV.Add(Val2); ValN2++;}
1115      else {DstValV.Add(Val1); ValN1++; ValN2++;}
1116    }
1117    for (TSizeTy RestValN1=ValN1; RestValN1<Len(); RestValN1++){
1118      DstValV.Add(GetVal(RestValN1));}
1119    for (TSizeTy RestValN2=ValN2; RestValN2<ValV.Len(); RestValN2++){
1120      DstValV.Add(ValV.GetVal(RestValN2));}
1121  }
1122  template <class TVal, class TSizeTy>
1123  void TVec<TVal, TSizeTy>::Diff(const TVec<TVal, TSizeTy>& ValV, TVec<TVal, TSizeTy>& DstValV) const {
1124    DstValV.Clr();
1125    TSizeTy ValN1=0, ValN2=0;
1126    while (ValN1<Len() && ValN2<ValV.Len()) {
1127      const TVal& Val1 = GetVal(ValN1);
1128      while (ValN2<ValV.Len() && Val1>ValV.GetVal(ValN2)) ValN2++;
1129      if (ValN2<ValV.Len()) {
1130        if (Val1!=ValV.GetVal(ValN2)) { DstValV.Add(Val1); }
1131        ValN1++;
1132      }
1133    }
1134    for (TSizeTy RestValN1=ValN1; RestValN1<Len(); RestValN1++){
1135      DstValV.Add(GetVal(RestValN1));}
1136  }
1137  template <class TVal, class TSizeTy>
1138  TSizeTy TVec<TVal, TSizeTy>::IntrsLen(const TVec<TVal, TSizeTy>& ValV) const {
1139    TSizeTy Cnt=0, ValN1=0, ValN2=0;
1140    while ((ValN1<Len())&&(ValN2<ValV.Len())){
1141      const TVal& Val1=GetVal(ValN1);
1142      while ((ValN2<ValV.Len())&&(Val1>ValV.GetVal(ValN2))){
1143        ValN2++;}
1144      if ((ValN2<ValV.Len())&&(Val1==ValV.GetVal(ValN2))){
1145        ValN2++; Cnt++;}
1146      ValN1++;
1147    }
1148    return Cnt;
1149  }
1150  template <class TVal, class TSizeTy>
1151  TSizeTy TVec<TVal, TSizeTy>::UnionLen(const TVec<TVal, TSizeTy>& ValV) const {
1152    TSizeTy Cnt = 0, ValN1 = 0, ValN2 = 0;
1153    while ((ValN1 < Len()) && (ValN2 < ValV.Len())) {
1154      const TVal& Val1 = GetVal(ValN1);
1155      const TVal& Val2 = ValV.GetVal(ValN2);
1156      if (Val1 < Val2) {
1157        Cnt++; ValN1++;
1158      } else if (Val1 > Val2) {
1159        Cnt++; ValN2++;
1160      } else {
1161        Cnt++; ValN1++; ValN2++;
1162      }
1163    }
1164    Cnt += (Len() - ValN1) + (ValV.Len() - ValN2);
1165    return Cnt;
1166  }
1167  template <class TVal, class TSizeTy>
1168  TSizeTy TVec<TVal, TSizeTy>::Count(const TVal& Val) const {
1169    TSizeTy Count = 0;
1170    for (TSizeTy i = 0; i < Len(); i++){
1171      if (Val == ValT[i]){Count++;}}
1172    return Count;
1173  }
1174  template <class TVal, class TSizeTy>
1175  TSizeTy TVec<TVal, TSizeTy>::SearchBin(const TVal& Val) const {
1176    TSizeTy LValN=0, RValN=Len()-1;
1177    while (RValN>=LValN){
1178      TSizeTy ValN=(LValN+RValN)/2;
1179      if (Val==ValT[ValN]){return ValN;}
1180      if (Val<ValT[ValN]){RValN=ValN-1;} else {LValN=ValN+1;}
1181    }
1182    return -1;
1183  }
1184  template <class TVal, class TSizeTy>
1185  TSizeTy TVec<TVal, TSizeTy>::SearchBin(const TVal& Val, TSizeTy& InsValN) const {
1186    TSizeTy LValN=0, RValN=Len()-1;
1187    while (RValN>=LValN){
1188      TSizeTy ValN=(LValN+RValN)/2;
1189      if (Val==ValT[ValN]){InsValN=ValN; return ValN;}
1190      if (Val<ValT[ValN]){RValN=ValN-1;} else {LValN=ValN+1;}
1191    }
1192    InsValN=LValN; return -1;
1193  }
1194  template <class TVal, class TSizeTy>
1195  TSizeTy TVec<TVal, TSizeTy>::SearchBinLeft(const TVal& Val, TSizeTy& InsValN) const {
1196    TSizeTy LValN=0, RValN=Len()-1;
1197    while (RValN>=LValN){
1198      TSizeTy ValN=(LValN+RValN)/2;
1199      if (Val==ValT[ValN]){InsValN=ValN; return ValN;}
1200      if (Val<ValT[ValN]){RValN=ValN-1;} else {LValN=ValN+1;}
1201    }
1202    InsValN=RValN; return -1;
1203  }
1204  template <class TVal, class TSizeTy>
1205  TSizeTy TVec<TVal, TSizeTy>::SearchForw(const TVal& Val, const TSizeTy& BValN) const {
1206    for (TSizeTy ValN=BValN; ValN<Vals; ValN++){
1207      if (Val==ValT[ValN]){return ValN;}}
1208    return -1;
1209  }
1210  template <class TVal, class TSizeTy>
1211  TSizeTy TVec<TVal, TSizeTy>::SearchBack(const TVal& Val) const {
1212    for (TSizeTy ValN=Vals-1; ValN>=0; ValN--){
1213      if (Val==ValT[ValN]){return ValN;}}
1214    return -1;
1215  }
1216  template <class TVal, class TSizeTy>
1217  TSizeTy TVec<TVal, TSizeTy>::SearchVForw(const TVec<TVal, TSizeTy>& ValV, const TSizeTy& BValN) const {
1218    TSizeTy ValVLen=ValV.Len();
1219    for (TSizeTy ValN=BValN; ValN<Vals-ValVLen+1; ValN++){
1220      bool Found=true;
1221      for (TSizeTy SubValN=0; SubValN<ValVLen; SubValN++){
1222        if (ValV[SubValN]!=GetVal(ValN+SubValN)){Found=false; break;}
1223      }
1224      if (Found){return ValN;}
1225    }
1226    return -1;
1227  }
1228  template <class TVal, class TSizeTy>
1229  TSizeTy TVec<TVal, TSizeTy>::GetMxValN() const {
1230    if (Vals==0){return -1;}
1231    TSizeTy MxValN=0;
1232    for (TSizeTy ValN=1; ValN<Vals; ValN++){
1233      if (ValT[ValN]>ValT[MxValN]){MxValN=ValN;}
1234    }
1235    return MxValN;
1236  }
1237  typedef TVec<TBool> TBoolV;
1238  typedef TVec<TCh> TChV;
1239  typedef TVec<TUCh> TUChV;
1240  typedef TVec<TUInt> TUIntV;
1241  typedef TVec<TInt> TIntV;
1242  typedef TVec<TUInt64> TUInt64V;
1243  typedef TVec<TFlt> TFltV;
1244  typedef TVec<TSFlt> TSFltV;
1245  typedef TVec<TAscFlt> TAscFltV;
1246  typedef TVec<TStr> TStrV;
1247  typedef TVec<TChA> TChAV;
1248  typedef TVec<TIntPr> TIntPrV;
1249  typedef TVec<TIntTr> TIntTrV;
1250  typedef TVec<TIntQu> TIntQuV;
1251  typedef TVec<TFltPr> TFltPrV;
1252  typedef TVec<TFltTr> TFltTrV;
1253  typedef TVec<TIntKd> TIntKdV;
1254  typedef TVec<TUChIntPr> TUChIntPrV;
1255  typedef TVec<TUChUInt64Pr> TUChUInt64PrV;
1256  typedef TVec<TIntUInt64Pr> TIntUInt64PrV;
1257  typedef TVec<TIntUInt64Kd> TIntUInt64KdV;
1258  typedef TVec<TIntFltPr> TIntFltPrV;
1259  typedef TVec<TIntFltPrKd> TIntFltPrKdV;
1260  typedef TVec<TFltIntPr> TFltIntPrV;
1261  typedef TVec<TFltUInt64Pr> TFltUInt64PrV;
1262  typedef TVec<TFltStrPr> TFltStrPrV;
1263  typedef TVec<TAscFltStrPr> TAscFltStrPrV;
1264  typedef TVec<TIntStrPr> TIntStrPrV;
1265  typedef TVec<TIntIntStrTr> TIntIntStrTrV;
1266  typedef TVec<TIntIntFltTr> TIntIntFltTrV;
1267  typedef TVec<TIntFltIntTr> TIntFltIntTrV;
1268  typedef TVec<TIntStrIntTr> TIntStrIntTrV;
1269  typedef TVec<TIntStrStrTr> TIntStrStrTrV;
1270  typedef TVec<TIntKd> TIntKdV;
1271  typedef TVec<TUIntIntKd> TUIntIntKdV;
1272  typedef TVec<TIntFltKd> TIntFltKdV;
1273  typedef TVec<TIntPrFltKd> TIntPrFltKdV;
1274  typedef TVec<TIntStrKd> TIntStrKdV;
1275  typedef TVec<TIntStrPrPr> TIntStrPrPrV;
1276  typedef TVec<TIntStrVPr> TIntStrVPrV;
1277  typedef TVec<TIntIntVIntTr> TIntIntVIntTrV;
1278  typedef TVec<TIntIntIntVTr> TIntIntIntVTrV;
1279  typedef TVec<TUInt64IntPr> TUInt64IntPrV;
1280  typedef TVec<TUInt64FltPr> TUInt64FltPrV;
1281  typedef TVec<TUInt64StrPr> TUInt64StrPrV;
1282  typedef TVec<TUInt64IntKd> TUInt64IntKdV;
1283  typedef TVec<TUInt64FltKd> TUInt64FltKdV;
1284  typedef TVec<TUInt64StrKd> TUInt64StrKdV;
1285  typedef TVec<TFltBoolKd> TFltBoolKdV;
1286  typedef TVec<TFltIntKd> TFltIntKdV;
1287  typedef TVec<TFltUInt64Kd> TFltUInt64KdV;
1288  typedef TVec<TFltIntPrKd> TFltIntPrKdV;
1289  typedef TVec<TFltKd> TFltKdV;
1290  typedef TVec<TFltStrKd> TFltStrKdV;
1291  typedef TVec<TFltStrPrPr> TFltStrPrPrV;
1292  typedef TVec<TFltIntIntTr> TFltIntIntTrV;
1293  typedef TVec<TFltFltStrTr> TFltFltStrTrV;
1294  typedef TVec<TAscFltIntPr> TAscFltIntPrV;
1295  typedef TVec<TAscFltIntKd> TAscFltIntKdV;
1296  typedef TVec<TStrPr> TStrPrV;
1297  typedef TVec<TStrIntPr> TStrIntPrV;
1298  typedef TVec<TStrFltPr> TStrFltPrV;
1299  typedef TVec<TStrIntKd> TStrIntKdV;
1300  typedef TVec<TStrFltKd> TStrFltKdV;
1301  typedef TVec<TStrAscFltKd> TStrAscFltKdV;
1302  typedef TVec<TStrTr> TStrTrV;
1303  typedef TVec<TStrQu> TStrQuV;
1304  typedef TVec<TStrFltFltTr> TStrFltFltTrV;
1305  typedef TVec<TStrStrIntTr> TStrStrIntTrV;
1306  typedef TVec<TStrKd> TStrKdV;
1307  typedef TVec<TStrStrVPr> TStrStrVPrV;
1308  typedef TVec<TStrVIntPr> TStrVIntPrV;
1309  typedef TVec<TFltIntIntIntQu> TFltIntIntIntQuV;
1310  typedef TVec<TIntStrIntIntQu> TIntStrIntIntQuV;
1311  typedef TVec<TIntIntPrPr> TIntIntPrPrV;
1312  typedef TVec<TFltV> TFltVFltV;
1313  template <class TVal, class TSizeTy=int>
1314  class TVecPool {
1315  public:
1316    typedef TPt<TVecPool<TVal, TSizeTy> > PVecPool;
1317    typedef TVec<TVal, TSizeTy> TValV;
1318  private:
1319    TCRef CRef;
1320    TBool FastCopy;
1321    TSize GrowBy, MxVals, Vals;
1322    TVal EmptyVal;                
1323    TVal *ValBf;                  
1324    TVec<uint64, int> IdToOffV;   
1325  private:
1326    void Resize(const TSize& _MxVals);
1327  public:
1328    TVecPool(const TSize& ExpectVals=0, const TSize& _GrowBy=1000000, const bool& _FastCopy=false, const TVal& _EmptyVal=TVal());
1329    TVecPool(const TVecPool<TVal, TSizeTy>& Pool);
1330    TVecPool(TSIn& SIn);
1331    ~TVecPool() { if (ValBf != NULL) { delete [] ValBf; } ValBf=NULL; }
1332    static PVecPool New(const TSize& ExpectVals=0, const TSize& GrowBy=1000000, const bool& FastCopy=false) {
1333      return new TVecPool(ExpectVals, GrowBy, FastCopy); }
1334    static PVecPool Load(TSIn& SIn) { return new TVecPool(SIn); }
1335    static PVecPool Load(const TStr& FNm) { TFIn FIn(FNm); return Load(FIn); }
1336    void Save(TSOut& SOut) const;
1337    TVecPool& operator = (const TVecPool& Pool);
1338    int GetVecs() const { return IdToOffV.Len(); }
1339    TSize GetVals() const { return Vals; }
1340    bool IsVId(const int& VId) const { return (0 <= VId) && (VId < IdToOffV.Len()); }
1341    uint64 Reserved() const { return MxVals; }
1342    void Reserve(const TSize& MxVals) { Resize(MxVals); }
1343    const TVal& GetEmptyVal() const { return EmptyVal; }
1344    void SetEmptyVal(const TVal& _EmptyVal) { EmptyVal = _EmptyVal; }
1345    uint64 GetMemUsed() const {
1346      return sizeof(TCRef)+sizeof(TBool)+3*sizeof(TSize)+sizeof(TVal*)+MxVals*sizeof(TVal);}
1347    int AddV(const TValV& ValV);
1348    int AddEmptyV(const int& ValVLen);
1349    int GetVLen(const int& VId) const { if (VId==0){return 0;} else {return int(IdToOffV[VId]-IdToOffV[VId-1]);}}
1350    TVal* GetValVPt(const int& VId) const {
1351      if (GetVLen(VId)==0){return (TVal*)&EmptyVal;}
1352      else {return ValBf+IdToOffV[VId-1];}}
1353    void GetV(const int& VId, TValV& ValV) const {
1354      if (GetVLen(VId)==0){ValV.Clr();}
1355      else { ValV.GenExt(GetValVPt(VId), GetVLen(VId)); } }
1356    void PutV(const int& VId, const TValV& ValV) {
1357      IAssert(IsVId(VId) && GetVLen(VId) == ValV.Len());
1358      if (FastCopy) {
1359        memcpy(GetValVPt(VId), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1360      else { TVal* ValPt = GetValVPt(VId);
1361        for (::TSize ValN=0; ValN < ::TSize(ValV.Len()); ValN++, ValPt++) { *ValPt=ValV[ValN]; }
1362      } }
1363    void CompactPool(const TVal& DelVal);
1364    void ShuffleAll(TRnd& Rnd=TInt::Rnd);
1365    void Clr(bool DoDel = true) {
1366      IdToOffV.Clr(DoDel);  MxVals=0;  Vals=0;
1367      if (DoDel && ValBf!=NULL) { delete [] ValBf; ValBf=NULL;}
1368      if (! DoDel) { PutAll(EmptyVal); } }
1369    void PutAll(const TVal& Val) {
1370      for (TSize ValN = 0; ValN < MxVals; ValN++) { ValBf[ValN]=Val; } }
1371    friend class TPt<TVecPool<TVal> >;
1372  };
1373  template <class TVal, class TSizeTy>
1374  void TVecPool<TVal, TSizeTy>::Resize(const TSize& _MxVals){
1375    if (_MxVals <= MxVals){ return; } else { MxVals = _MxVals; }
1376    if (ValBf == NULL) {
1377      try { ValBf = new TVal [MxVals]; }
1378      catch (std::exception Ex) {
1379        FailR(TStr::Fmt("TVecPool::Resize 1: %s, MxVals: %s. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]", Ex.what(), TInt::GetStr(uint64(_MxVals)).CStr()).CStr()); }
1380      IAssert(ValBf != NULL);
1381      if (EmptyVal != TVal()) { PutAll(EmptyVal); }
1382    } else {
1383      TVal* NewValBf = NULL;
1384      try { NewValBf = new TVal [MxVals]; }
1385      catch (std::exception Ex) {
1386        FailR(TStr::Fmt("TVecPool::Resize 1: %s, MxVals: %s. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]", Ex.what(), TInt::GetStr(uint64(_MxVals)).CStr()).CStr()); }
1387      IAssert(NewValBf != NULL);
1388      if (FastCopy) {
1389        memcpy(NewValBf, ValBf, Vals*sizeof(TVal)); }
1390      else {
1391        for (TSize ValN = 0; ValN < Vals; ValN++){ NewValBf[ValN] = ValBf[ValN]; } }
1392      if (EmptyVal != TVal()) { 
1393        for (TSize ValN = Vals; ValN < MxVals; ValN++) { NewValBf[ValN] = EmptyVal; }
1394      }
1395      delete [] ValBf;
1396      ValBf = NewValBf;
1397    }
1398  }
1399  template <class TVal, class TSizeTy>
1400  TVecPool<TVal, TSizeTy>::TVecPool(const TSize& ExpectVals, const TSize& _GrowBy, const bool& _FastCopy, const TVal& _EmptyVal) : GrowBy(_GrowBy), MxVals(0), Vals(0), EmptyVal(_EmptyVal), ValBf(NULL) {
1401    IdToOffV.Add(0);
1402    Resize(ExpectVals);
1403  }
1404  template <class TVal, class TSizeTy>
1405  TVecPool<TVal, TSizeTy>::TVecPool(const TVecPool& Pool) : FastCopy(Pool.FastCopy), GrowBy(Pool.GrowBy), MxVals(Pool.MxVals), Vals(Pool.Vals), EmptyVal(Pool.EmptyVal), IdToOffV(Pool.IdToOffV) {
1406    try {
1407      ValBf = new TVal [MxVals]; }
1408    catch (std::exception Ex) {
1409      FailR(TStr::Fmt("TVecPool::TVecPool: %s, MxVals: %s. [Program failed to allocate memory. Solution: Get a bigger machine and a 64-bit compiler.]", Ex.what(), TInt::GetStr(uint64(MxVals)).CStr()).CStr()); }
1410    IAssert(ValBf != NULL);
1411    if (FastCopy) {
1412      memcpy(ValBf, Pool.ValBf, MxVals*sizeof(TVal)); }
1413    else {
1414      for (TSize ValN = 0; ValN < MxVals; ValN++){ ValBf[ValN] = Pool.ValBf[ValN]; } }
1415  }
1416  template <class TVal, class TSizeTy>
1417  TVecPool<TVal, TSizeTy>::TVecPool(TSIn& SIn) : FastCopy(SIn) {
1418    uint64 _GrowBy, _MxVals, _Vals;
1419    SIn.Load(_GrowBy); SIn.Load(_MxVals);  SIn.Load(_Vals);
1420    IAssertR(_GrowBy<TSizeMx && _MxVals<TSizeMx && _Vals<TSizeMx, "This is a 64-bit vector pool. Use a 64-bit compiler.");
1421    GrowBy=TSize(_GrowBy);  MxVals=TSize(_Vals);  Vals=TSize(_Vals); 
1422    EmptyVal = TVal(SIn);
1423    if (MxVals==0) { ValBf = NULL; } else { ValBf = new TVal [MxVals]; }
1424    for (TSize ValN = 0; ValN < Vals; ValN++) { ValBf[ValN] = TVal(SIn); }
1425    { TInt MxVals(SIn), Vals(SIn);
1426      IdToOffV.Gen(Vals);
1427      for (int ValN = 0; ValN < Vals; ValN++) {
1428        uint64 Offset;  SIn.Load(Offset);  IAssert(Offset < TSizeMx);
1429        IdToOffV[ValN]=TSize(Offset);
1430      } }
1431  }
1432  template <class TVal, class TSizeTy>
1433  void TVecPool<TVal, TSizeTy>::Save(TSOut& SOut) const {
1434    SOut.Save(FastCopy);
1435    uint64 _GrowBy=GrowBy, _MxVals=MxVals, _Vals=Vals;
1436    SOut.Save(_GrowBy); SOut.Save(_MxVals);  SOut.Save(_Vals);
1437    SOut.Save(EmptyVal);
1438    for (TSize ValN = 0; ValN < Vals; ValN++) { ValBf[ValN].Save(SOut); }
1439    { SOut.Save(IdToOffV.Len());  SOut.Save(IdToOffV.Len());
1440      for (int ValN = 0; ValN < IdToOffV.Len(); ValN++) {
1441        const uint64 Offset=IdToOffV[ValN];  SOut.Save(Offset);
1442      } }
1443  }
1444  template <class TVal, class TSizeTy>
1445  TVecPool<TVal, TSizeTy>& TVecPool<TVal, TSizeTy>::operator = (const TVecPool& Pool) {
1446    if (this!=&Pool) {
1447      FastCopy = Pool.FastCopy;
1448      GrowBy = Pool.GrowBy;
1449      MxVals = Pool.MxVals;
1450      Vals = Pool.Vals;
1451      EmptyVal = Pool.EmptyVal;
1452      IdToOffV=Pool.IdToOffV;
1453      try {
1454        ValBf = new TVal [MxVals]; }
1455      catch (std::exception Ex) {
1456        FailR(TStr::Fmt("TVecPool::operator=: %s, MxVals: %s. [Program failed to allocate memory. Solution: Get a bigger machine and a 64-bit compiler.]", Ex.what(), TInt::GetStr(uint64(MxVals)).CStr()).CStr()); }
1457      IAssert(ValBf != NULL);
1458      if (FastCopy) {
1459        memcpy(ValBf, Pool.ValBf, Vals*sizeof(TVal)); }
1460      else {
1461        for (TSize ValN = 0; ValN < Vals; ValN++){ ValBf[ValN] = Pool.ValBf[ValN]; } }
1462    }
1463    return *this;
1464  }
1465  template <class TVal, class TSizeTy>
1466  int TVecPool<TVal, TSizeTy>::AddV(const TValV& ValV) {
1467    const TSize ValVLen = ValV.Len();
1468    if (ValVLen == 0) { return 0; }
1469    if (MxVals < Vals+ValVLen) { Resize(Vals+MAX(ValVLen, GrowBy)); }
1470    if (FastCopy) { memcpy(ValBf+Vals, ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1471    else { for (TSize ValN=0; ValN < ValVLen; ValN++) { ValBf[Vals+ValN]=ValV[ValN]; } }
1472    Vals+=ValVLen;  IdToOffV.Add(Vals);
1473    return IdToOffV.Len()-1;
1474  }
1475  template <class TVal, class TSizeTy>
1476  int TVecPool<TVal, TSizeTy>::AddEmptyV(const int& ValVLen) {
1477    if (ValVLen==0){return 0;}
1478    if (MxVals < Vals+ValVLen){Resize(Vals+MAX(TSize(ValVLen), GrowBy)); }
1479    Vals+=ValVLen; IdToOffV.Add(Vals);
1480    return IdToOffV.Len()-1;
1481  }
1482  template <class TVal, class TSizeTy>
1483  void TVecPool<TVal, TSizeTy>::CompactPool(const TVal& DelVal) {
1484    ::TSize TotalDel=0, NDel=0;
1485    for (int vid = 1; vid < IdToOffV.Len(); vid++) {
1486      const uint Len = GetVLen(vid);
1487      TVal* ValV = GetValVPt(vid);
1488      if (TotalDel > 0) { IdToOffV[vid-1] -= TotalDel; } 
1489      if (Len == 0) { continue; }
1490      NDel = 0;
1491      for (TVal* v = ValV; v < ValV+Len-NDel; v++) {
1492        if (*v == DelVal) {
1493          TVal* Beg = v;
1494          while (*v == DelVal && v < ValV+Len) { v++; NDel++; }
1495          memcpy(Beg, v, sizeof(TVal)*int(Len - ::TSize(v - ValV)));
1496          v -= NDel;
1497        }
1498      }
1499      memcpy(ValV-TotalDel, ValV, sizeof(TVal)*Len);  
1500      TotalDel += NDel;
1501    }
1502    IdToOffV.Last() -= TotalDel;
1503    for (::TSize i = Vals-TotalDel; i < Vals; i++) { ValBf[i] = EmptyVal; }
1504    Vals -= TotalDel;
1505  }
1506  template <class TVal, class TSizeTy>
1507  void TVecPool<TVal, TSizeTy>::ShuffleAll(TRnd& Rnd) {
1508    for (::TSize n = Vals-1; n > 0; n--) {
1509      const ::TSize k = ::TSize(((uint64(Rnd.GetUniDevInt())<<32) | uint64(Rnd.GetUniDevInt())) % (n+1));
1510      const TVal Tmp = ValBf[n];
1511      ValBf[n] = ValBf[k];
1512      ValBf[k] = Tmp;
1513    }
1514  }
1515  namespace TGLib_OLD {
1516  template<class TVal>
1517  class TVecPool {
1518  public:
1519    typedef TPt<TVecPool<TVal> > PVecPool;
1520    typedef TVec<TVal> TValV;
1521  private:
1522    TCRef CRef;
1523    TBool FastCopy;
1524    ::TSize GrowBy, MxVals, Vals;
1525    TVal EmptyVal;           
1526    TVal *ValBf;             
1527    TVec< ::TSize> IdToOffV; 
1528  private:
1529    void Resize(const ::TSize& _MxVals);
1530  public:
1531    TVecPool(const ::TSize& ExpectVals=0, const ::TSize& _GrowBy=1000000, const bool& _FastCopy=false, const TVal& _EmptyVal=TVal());
1532    TVecPool(const TVecPool& Pool);
1533    TVecPool(TSIn& SIn);
1534    ~TVecPool() { if (ValBf != NULL) { delete [] ValBf; } ValBf=NULL; }
1535    static PVecPool New(const ::TSize& ExpectVals=0, const ::TSize& GrowBy=1000000, const bool& FastCopy=false) {
1536      return new TVecPool(ExpectVals, GrowBy, FastCopy); }
1537    static PVecPool Load(TSIn& SIn) { return new TVecPool(SIn); }
1538    static PVecPool Load(const TStr& FNm) { TFIn FIn(FNm); return Load(FIn); }
1539    void Save(TSOut& SOut) const;
1540    TVecPool& operator = (const TVecPool& Pool);
1541    ::TSize GetVals() const { return Vals; }
1542    ::TSize GetVecs() const { return IdToOffV.Len(); }
1543    bool IsVId(const int& VId) const { return (0 <= VId) && (VId < IdToOffV.Len()); }
1544    ::TSize Reserved() const { return MxVals; }
1545    void Reserve(const ::TSize& MxVals) { Resize(MxVals); }
1546    const TVal& GetEmptyVal() const { return EmptyVal; }
1547    void SetEmptyVal(const TVal& _EmptyVal) { EmptyVal = _EmptyVal; }
1548    ::TSize GetMemUsed() const {
1549      return sizeof(TCRef)+sizeof(TBool)+3*sizeof(TSize)+sizeof(TVal*)+MxVals*sizeof(TVal);}
1550    int AddV(const TValV& ValV);
1551    int AddEmptyV(const int& ValVLen);
1552    uint GetVLen(const int& VId) const {
1553      if (VId==0){return 0;}
1554      else {return uint(IdToOffV[VId]-IdToOffV[VId-1]);}}
1555    TVal* GetValVPt(const int& VId) const {
1556      if (GetVLen(VId)==0){return (TVal*)&EmptyVal;}
1557      else {return ValBf+IdToOffV[VId-1];}}
1558    void GetV(const int& VId, TValV& ValV) const {
1559      if (GetVLen(VId)==0){ValV.Clr();}
1560      else { ValV.GenExt(GetValVPt(VId), GetVLen(VId)); } }
1561    void PutV(const int& VId, const TValV& ValV) {
1562      IAssert(IsVId(VId) && GetVLen(VId) == ValV.Len());
1563      if (FastCopy) {
1564        memcpy(GetValVPt(VId), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1565      else { TVal* ValPt = GetValVPt(VId);
1566        for (uint ValN=0; ValN < uint(ValV.Len()); ValN++, ValPt++) { *ValPt=ValV[ValN]; }
1567      }
1568    }
1569    void CompactPool(const TVal& DelVal); 
1570    void ShuffleAll(TRnd& Rnd=TInt::Rnd); 
1571    void Clr(bool DoDel = true) {
1572      IdToOffV.Clr(DoDel);  MxVals=0;  Vals=0;
1573      if (DoDel && ValBf!=NULL) { delete [] ValBf; ValBf=NULL;}
1574      if (! DoDel) { PutAll(EmptyVal); }
1575    }
1576    void PutAll(const TVal& Val) {
1577      for (TSize ValN = 0; ValN < MxVals; ValN++) { ValBf[ValN]=Val; } }
1578    friend class TPt<TVecPool<TVal> >;
1579  };
1580  template <class TVal>
1581  void TVecPool<TVal>::Resize(const ::TSize& _MxVals){
1582    if (_MxVals <= MxVals){ return; } else { MxVals = _MxVals; }
1583    if (ValBf == NULL) {
1584      try { ValBf = new TVal [MxVals]; }
1585      catch (std::exception Ex) {
1586        FailR(TStr::Fmt("TVecPool::Resize 1: %s, MxVals: %d. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]", Ex.what(), _MxVals).CStr()); }
1587      IAssert(ValBf != NULL);
1588      if (EmptyVal != TVal()) { PutAll(EmptyVal); }
1589    } else {
1590      TVal* NewValBf = NULL;
1591      try { NewValBf = new TVal [MxVals]; }
1592      catch (std::exception Ex) { FailR(TStr::Fmt("TVecPool::Resize 2: %s, MxVals: %d. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]", Ex.what(), _MxVals).CStr()); }
1593      IAssert(NewValBf != NULL);
1594      if (FastCopy) {
1595        memcpy(NewValBf, ValBf, Vals*sizeof(TVal)); }
1596      else {
1597        for (TSize ValN = 0; ValN < Vals; ValN++){ NewValBf[ValN] = ValBf[ValN]; } }
1598      if (EmptyVal != TVal()) { 
1599        for (TSize ValN = Vals; ValN < MxVals; ValN++) { NewValBf[ValN] = EmptyVal; }
1600      }
1601      delete [] ValBf;
1602      ValBf = NewValBf;
1603    }
1604  }
1605  template <class TVal>
1606  TVecPool<TVal>::TVecPool(const ::TSize& ExpectVals, const ::TSize& _GrowBy, const bool& _FastCopy, const TVal& _EmptyVal) :
1607    GrowBy(_GrowBy), MxVals(0), Vals(0), EmptyVal(_EmptyVal), ValBf(NULL) {
1608    IdToOffV.Add(0);
1609    Resize(ExpectVals);
1610  }
1611  template <class TVal>
1612  TVecPool<TVal>::TVecPool(const TVecPool& Pool):
1613    FastCopy(Pool.FastCopy), GrowBy(Pool.GrowBy),
1614    MxVals(Pool.MxVals), Vals(Pool.Vals), EmptyVal(Pool.EmptyVal), IdToOffV(Pool.IdToOffV) {
1615    try { ValBf = new TVal [MxVals]; }
1616    catch (std::exception Ex) { FailR(TStr::Fmt("TVecPool::TVecPool: %s, MxVals: %d", Ex.what(), MxVals).CStr()); }
1617    IAssert(ValBf != NULL);
1618    if (FastCopy) {
1619      memcpy(ValBf, Pool.ValBf, MxVals*sizeof(TVal)); }
1620    else {
1621      for (TSize ValN = 0; ValN < MxVals; ValN++){ ValBf[ValN] = Pool.ValBf[ValN]; } }
1622  }
1623  template <class TVal>
1624  TVecPool<TVal>::TVecPool(TSIn& SIn):
1625    FastCopy(SIn) {
1626    uint64 _GrowBy, _MxVals, _Vals;
1627    SIn.Load(_GrowBy); SIn.Load(_MxVals);  SIn.Load(_Vals);
1628    IAssert(_GrowBy<TSizeMx && _MxVals<TSizeMx && _Vals<TSizeMx);
1629    GrowBy=TSize(_GrowBy);  MxVals=TSize(_Vals);  Vals=TSize(_Vals); 
1630    EmptyVal = TVal(SIn);
1631    if (MxVals==0) { ValBf = NULL; } else { ValBf = new TVal [MxVals]; }
1632    for (TSize ValN = 0; ValN < Vals; ValN++) { ValBf[ValN] = TVal(SIn); }
1633    { TInt MxVals(SIn), Vals(SIn);
1634    IdToOffV.Gen(Vals);
1635    for (int ValN = 0; ValN < Vals; ValN++) {
1636      uint64 Offset;  SIn.Load(Offset);  IAssert(Offset < TSizeMx);
1637      IdToOffV[ValN]=TSize(Offset);
1638    } }
1639  }
1640  template <class TVal>
1641  void TVecPool<TVal>::Save(TSOut& SOut) const {
1642    SOut.Save(FastCopy);
1643    uint64 _GrowBy=GrowBy, _MxVals=MxVals, _Vals=Vals;
1644    SOut.Save(_GrowBy); SOut.Save(_MxVals);  SOut.Save(_Vals);
1645    SOut.Save(EmptyVal);
1646    for (TSize ValN = 0; ValN < Vals; ValN++) { ValBf[ValN].Save(SOut); }
1647    { SOut.Save(IdToOffV.Len());  SOut.Save(IdToOffV.Len());
1648    for (int ValN = 0; ValN < IdToOffV.Len(); ValN++) {
1649      const uint64 Offset=IdToOffV[ValN];  SOut.Save(Offset);
1650    } }
1651  }
1652  template <class TVal>
1653  TVecPool<TVal>& TVecPool<TVal>::operator = (const TVecPool& Pool) {
1654    if (this!=&Pool) {
1655      FastCopy = Pool.FastCopy;
1656      GrowBy = Pool.GrowBy;
1657      MxVals = Pool.MxVals;
1658      Vals = Pool.Vals;
1659      EmptyVal = Pool.EmptyVal;
1660      IdToOffV=Pool.IdToOffV;
1661      try { ValBf = new TVal [MxVals]; }
1662      catch (std::exception Ex) { FailR(TStr::Fmt("TVec::operator= : %s, MxVals: %d", Ex.what(), MxVals).CStr()); }
1663      IAssert(ValBf != NULL);
1664      if (FastCopy) {
1665        memcpy(ValBf, Pool.ValBf, Vals*sizeof(TVal)); }
1666      else {
1667        for (uint64 ValN = 0; ValN < Vals; ValN++){ ValBf[ValN] = Pool.ValBf[ValN]; } }
1668    }
1669    return *this;
1670  }
1671  template<class TVal>
1672  int TVecPool<TVal>::AddV(const TValV& ValV) {
1673    const ::TSize ValVLen = ValV.Len();
1674    if (ValVLen == 0) { return 0; }
1675    if (MxVals < Vals+ValVLen) { Resize(Vals+MAX(ValVLen, GrowBy)); }
1676    if (FastCopy) { memcpy(ValBf+Vals, ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1677    else { for (uint ValN=0; ValN < ValVLen; ValN++) { ValBf[Vals+ValN]=ValV[ValN]; } }
1678    Vals+=ValVLen;  IdToOffV.Add(Vals);
1679    return IdToOffV.Len()-1;
1680  }
1681  template<class TVal>
1682  int TVecPool<TVal>::AddEmptyV(const int& ValVLen) {
1683    if (ValVLen==0){return 0;}
1684    if (MxVals < Vals+ValVLen){Resize(Vals+MAX(TSize(ValVLen), GrowBy)); }
1685    Vals+=ValVLen; IdToOffV.Add(Vals);
1686    return IdToOffV.Len()-1;
1687  }
1688  template<class TVal>
1689  void TVecPool<TVal>::CompactPool(const TVal& DelVal) {
1690    ::TSize TotalDel=0, NDel=0;
1691    for (int vid = 1; vid < IdToOffV.Len(); vid++) {
1692      const uint Len = GetVLen(vid);
1693      TVal* ValV = GetValVPt(vid);
1694      if (TotalDel > 0) { IdToOffV[vid-1] -= TotalDel; } 
1695      if (Len == 0) { continue; }
1696      NDel = 0;
1697      for (TVal* v = ValV; v < ValV+Len-NDel; v++) {
1698        if (*v == DelVal) {
1699          TVal* Beg = v;
1700          while (*v == DelVal && v < ValV+Len) { v++; NDel++; }
1701          memcpy(Beg, v, sizeof(TVal)*int(Len - ::TSize(v - ValV)));
1702          v -= NDel;
1703        }
1704      }
1705      memcpy(ValV-TotalDel, ValV, sizeof(TVal)*Len);  
1706      TotalDel += NDel;
1707    }
1708    IdToOffV.Last() -= TotalDel;
1709    for (::TSize i = Vals-TotalDel; i < Vals; i++) { ValBf[i] = EmptyVal; }
1710    Vals -= TotalDel;
1711  }
1712  template<class TVal>
1713  void TVecPool<TVal>::ShuffleAll(TRnd& Rnd) {
1714    for (::TSize n = Vals-1; n > 0; n--) {
1715      const ::TSize k = ::TSize(((uint64(Rnd.GetUniDevInt())<<32) | uint64(Rnd.GetUniDevInt())) % (n+1));
1716      const TVal Tmp = ValBf[n];
1717      ValBf[n] = ValBf[k];
1718      ValBf[k] = Tmp;
1719    }
1720  }
1721  }; 
1722  typedef TVecPool<TInt> TIntVecPool;
1723  typedef TPt<TIntVecPool> PIntVecPool;
1724  template <class TVal>
1725  class PVec{
1726  private:
1727    TCRef CRef;
1728  public:
1729    TVec<TVal> V;
1730  public:
1731    PVec<TVal>(): V(){}
1732    PVec<TVal>(const PVec<TVal>& Vec): V(Vec.V){}
1733    static TPt<PVec<TVal> > New(){
1734      return new PVec<TVal>();}
1735    PVec<TVal>(const int& MxVals, const int& Vals): V(MxVals, Vals){}
1736    static TPt<PVec<TVal> > New(const int& MxVals, const int& Vals){
1737      return new PVec<TVal>(MxVals, Vals);}
1738    PVec<TVal>(const TVec<TVal>& _V): V(_V){}
1739    static TPt<PVec<TVal> > New(const TVec<TVal>& V){
1740      return new PVec<TVal>(V);}
1741    explicit PVec<TVal>(TSIn& SIn): V(SIn){}
1742    static TPt<PVec<TVal> > Load(TSIn& SIn){return new PVec<TVal>(SIn);}
1743    void Save(TSOut& SOut) const {V.Save(SOut);}
1744    PVec<TVal>& operator=(const PVec<TVal>& Vec){
1745      if (this!=&Vec){V=Vec.V;} return *this;}
1746    bool operator==(const PVec<TVal>& Vec) const {return V==Vec.V;}
1747    bool operator<(const PVec<TVal>& Vec) const {return V<Vec.V;}
1748    TVal& operator[](const int& ValN) const {return V[ValN];}
1749    bool Empty() const {return V.Empty();}
1750    int Len() const {return V.Len();}
1751    TVal GetVal(const int& ValN) const {return V[ValN];}
1752    int Add(const TVal& Val){return V.Add(Val);}
1753    friend class TPt<PVec<TVal> >;
1754  };
1755  typedef PVec<TFlt> TFltVP;
1756  typedef TPt<TFltVP> PFltV;
1757  typedef PVec<TAscFlt> TAscFltVP;
1758  typedef TPt<TAscFltVP> PAscFltV;
1759  typedef PVec<TStr> TStrVP;
1760  typedef TPt<TStrVP> PStrV;
1761  template <class TVal, class TSizeTy = int>
1762  class TVVec{
1763  private:
1764    TInt64 XDim, YDim;
1765    TVec<TVal, TSizeTy> ValV;
1766  public:
1767    TVVec(): XDim(), YDim(), ValV(){}
1768    TVVec(const TVVec& Vec):
1769      XDim(Vec.XDim), YDim(Vec.YDim), ValV(Vec.ValV){}
1770    TVVec(const TSizeTy& _XDim, const TSizeTy& _YDim):
1771      XDim(), YDim(), ValV(){Gen(_XDim, _YDim);}
1772    explicit TVVec(const TVec<TVal,TSizeTy>& _ValV, const TSizeTy& _XDim, const TSizeTy& _YDim):
1773      XDim(_XDim), YDim(_YDim), ValV(_ValV){ IAssert(ValV.Len()==XDim*YDim); }
1774    explicit TVVec(TSIn& SIn) {Load(SIn);}
1775    void Load(TSIn& SIn){XDim.Load(SIn); YDim.Load(SIn); ValV.Load(SIn);}
1776    void Save(TSOut& SOut) const {
1777      XDim.Save(SOut); YDim.Save(SOut); ValV.Save(SOut);}
1778    TVVec<TVal, TSizeTy>& operator=(const TVVec<TVal, TSizeTy>& Vec){
1779      if (this!=&Vec){XDim=Vec.XDim; YDim=Vec.YDim; ValV=Vec.ValV;} return *this;}
1780    bool operator==(const TVVec& Vec) const {
1781      return (XDim==Vec.XDim)&&(YDim==Vec.YDim)&&(ValV==Vec.ValV);}
1782    bool Empty() const {return ValV.Len()==0;}
1783    void Clr(){XDim=0; YDim=0; ValV.Clr();}
1784    void Gen(const TSizeTy& _XDim, const TSizeTy& _YDim){
1785      Assert((_XDim>=0)&&(_YDim>=0));
1786      XDim=_XDim; YDim=_YDim; ValV.Gen(XDim*YDim);}
1787    TSizeTy GetXDim() const {return XDim;}
1788    TSizeTy GetYDim() const {return YDim;}
1789    TSizeTy GetRows() const {return XDim;}
1790    TSizeTy GetCols() const {return YDim;}
1791    TVec<TVal, TSizeTy>& Get1DVec(){return ValV;}
1792    const TVal& At(const TSizeTy& X, const TSizeTy& Y) const {
1793      Assert((0<=X)&&(X<TSizeTy(XDim))&&(0<=Y)&&(Y<TSizeTy(YDim)));
1794      return ValV[X*YDim+Y];}
1795    TVal& At(const TSizeTy& X, const TSizeTy& Y){
1796      Assert((0<=X)&&(X<TSizeTy(XDim))&&(0<=Y)&&(Y<TSizeTy(YDim)));
1797      return ValV[X*YDim+Y];}
1798    TVal& operator()(const TSizeTy& X, const TSizeTy& Y){
1799      return At(X, Y);}
1800    const TVal& operator()(const TSizeTy& X, const TSizeTy& Y) const {
1801      return At(X, Y);}
1802    void PutXY(const TSizeTy& X, const TSizeTy& Y, const TVal& Val){At(X, Y)=Val;}
1803    void PutAll(const TVal& Val){ValV.PutAll(Val);}
1804    void PutX(const TSizeTy& X, const TVal& Val){
1805      for (TSizeTy Y=0; Y<TSizeTy(YDim); Y++){At(X, Y)=Val;}}
1806    void PutY(const TSizeTy& Y, const TVal& Val){
1807      for (TSizeTy X=0; X<TSizeTy(XDim); X++){At(X, Y)=Val;}}
1808    TVal GetXY(const TSizeTy& X, const TSizeTy& Y) const {
1809      Assert((0<=X)&&(X<TSizeTy(XDim))&&(0<=Y)&&(Y<TSizeTy(YDim)));
1810      return ValV[X*YDim+Y];}
1811    void GetRow(const TSizeTy& RowN, TVec<TVal, TSizeTy>& Vec) const;
1812    void GetCol(const TSizeTy& ColN, TVec<TVal, TSizeTy>& Vec) const;
1813    void SwapX(const TSizeTy& X1, const TSizeTy& X2);
1814    void SwapY(const TSizeTy& Y1, const TSizeTy& Y2);
1815    void Swap(TVVec<TVal, TSizeTy>& Vec);
1816    void ShuffleX(TRnd& Rnd);
1817    void ShuffleY(TRnd& Rnd);
1818    void GetMxValXY(TSizeTy& X, TSizeTy& Y) const;
1819    void CopyFrom(const TVVec<TVal, TSizeTy>& VVec);
1820    void AddXDim();
1821    void AddYDim();
1822    void DelX(const TSizeTy& X);
1823    void DelY(const TSizeTy& Y);
1824  };
1825  template <class TVal, class TSizeTy>
1826  void TVVec<TVal, TSizeTy>::SwapX(const TSizeTy& X1, const TSizeTy& X2){
1827    for (TSizeTy Y=0; Y<TSizeTy(YDim); Y++){
1828      TVal Val=At(X1, Y); At(X1, Y)=At(X2, Y); At(X2, Y)=Val;}
1829  }
1830  template <class TVal, class TSizeTy>
1831  void TVVec<TVal, TSizeTy>::SwapY(const TSizeTy& Y1, const TSizeTy& Y2){
1832    for (TSizeTy X=0; X<TSizeTy(XDim); X++){
1833      TVal Val=At(X, Y1); At(X, Y1)=At(X, Y2); At(X, Y2)=Val;}
1834  }
1835  template <class TVal, class TSizeTy>
1836  void TVVec<TVal, TSizeTy>::Swap(TVVec<TVal, TSizeTy>& Vec){  
1837    if (this!=&Vec){
1838      ::Swap(XDim, Vec.XDim);
1839      ::Swap(YDim, Vec.YDim);
1840      ValV.Swap(Vec.ValV);
1841    }
1842  }
1843  template <class TVal, class TSizeTy>
1844  void TVVec<TVal, TSizeTy>::ShuffleX(TRnd& Rnd){
1845    for (TSizeTy X=0; X<XDim-1; X++){SwapX(X, X+Rnd.GetUniDevInt(XDim-X));}
1846  }
1847  template <class TVal, class TSizeTy>
1848  void TVVec<TVal, TSizeTy>::ShuffleY(TRnd& Rnd){
1849    for (TSizeTy Y=0; Y<YDim-1; Y++){SwapY(Y, Y+Rnd.GetUniDevInt(YDim-Y));}
1850  }
1851  template <class TVal, class TSizeTy>
1852  void TVVec<TVal, TSizeTy>::GetMxValXY(TSizeTy& X, TSizeTy& Y) const {
1853    TSizeTy MxValN=ValV.GetMxValN();
1854    Y=MxValN%YDim;
1855    X=MxValN/YDim;
1856  }
1857  template <class TVal, class TSizeTy>
1858  void TVVec<TVal, TSizeTy>::CopyFrom(const TVVec<TVal, TSizeTy>& VVec){
1859    TSizeTy CopyXDim = (GetXDim() < VVec.GetXDim()) ? GetXDim() : VVec.GetXDim();
1860    TSizeTy CopyYDim = (GetYDim() < VVec.GetYDim()) ? GetYDim() : VVec.GetYDim();
1861    for (TSizeTy X=0; X<CopyXDim; X++){
1862      for (TSizeTy Y=0; Y<CopyYDim; Y++){
1863        At(X, Y)=VVec.At(X, Y);
1864      }
1865    }
1866  }
1867  template <class TVal, class TSizeTy>
1868  void TVVec<TVal, TSizeTy>::AddXDim(){
1869    TVVec<TVal, TSizeTy> NewVVec(XDim+1, YDim);
1870    NewVVec.CopyFrom(*this);
1871    *this=NewVVec;
1872  }
1873  template <class TVal, class TSizeTy>
1874  void TVVec<TVal, TSizeTy>::AddYDim(){
1875    TVVec<TVal, TSizeTy> NewVVec(XDim, YDim+1);
1876    NewVVec.CopyFrom(*this);
1877    *this=NewVVec;
1878  }
1879  template <class TVal, class TSizeTy>
1880  void TVVec<TVal, TSizeTy>::DelX(const TSizeTy& X){
1881    TVVec<TVal, TSizeTy> NewVVec(XDim-1, YDim);
1882    for (TSizeTy Y=0; Y<YDim; Y++){
1883      for (TSizeTy LX=0; LX<X; LX++){
1884        NewVVec.At(LX, Y)=At(LX, Y);}
1885      for (TSizeTy RX=X+1; RX<XDim; RX++){
1886        NewVVec.At(RX-1, Y)=At(RX, Y);}
1887    }
1888    *this=NewVVec;
1889  }
1890  template <class TVal, class TSizeTy>
1891  void TVVec<TVal, TSizeTy>::DelY(const TSizeTy& Y){
1892    TVVec<TVal, TSizeTy> NewVVec(XDim, YDim-1);
1893    for (TSizeTy X=0; X<XDim; X++){
1894      for (TSizeTy LY=0; LY<Y; LY++){
1895        NewVVec.At(X, LY)=At(X, LY);}
1896      for (TSizeTy RY=Y+1; RY<YDim; RY++){
1897        NewVVec.At(X, RY-1)=At(X, RY);}
1898    }
1899    *this=NewVVec;
1900  }
1901  template <class TVal, class TSizeTy >
1902  void TVVec<TVal, TSizeTy>::GetRow(const TSizeTy& RowN, TVec<TVal, TSizeTy>& Vec) const {
1903    Vec.Gen(GetCols(), 0);
1904    for (TSizeTy col = 0; col < GetCols(); col++) {
1905      Vec.Add(At(RowN, col));
1906    }
1907  }
1908  template <class TVal, class TSizeTy>
1909  void TVVec<TVal, TSizeTy>::GetCol(const TSizeTy& ColN, TVec<TVal, TSizeTy>& Vec) const {
1910    Vec.Gen(GetRows(), 0);
1911    for (TSizeTy row = 0; row < GetRows(); row++) {
1912      Vec.Add(At(row, ColN));
1913    }
1914  }
1915  typedef TVVec<TBool> TBoolVV;
1916  typedef TVVec<TCh> TChVV;
1917  typedef TVVec<TInt> TIntVV;
1918  typedef TVVec<TSFlt> TSFltVV;
1919  typedef TVVec<TFlt> TFltVV;
1920  typedef TVVec<TStr> TStrVV;
1921  typedef TVVec<TIntPr> TIntPrVV;
1922  template <class TVal, class TSizeTy = int>
1923  class TVVVec{
1924  private:
1925    TInt64 XDim, YDim, ZDim;
1926    TVec<TVal, TSizeTy> ValV;
1927  public:
1928    TVVVec(): XDim(), YDim(), ZDim(), ValV(){}
1929    TVVVec(const TVVVec& Vec):
1930      XDim(Vec.XDim), YDim(Vec.YDim), ZDim(Vec.ZDim), ValV(Vec.ValV){}
1931    TVVVec(const TSizeTy& _XDim, const TSizeTy& _YDim, const TSizeTy& _ZDim):
1932      XDim(), YDim(), ZDim(), ValV(){Gen(_XDim, _YDim, _ZDim);}
1933    explicit TVVVec(TSIn& SIn):
1934      XDim(SIn), YDim(SIn), ZDim(SIn), ValV(SIn){}
1935    void Save(TSOut& SOut) const {
1936      XDim.Save(SOut); YDim.Save(SOut); ZDim.Save(SOut); ValV.Save(SOut);}
1937    TVVVec<TVal, TSizeTy>& operator=(const TVVVec<TVal, TSizeTy>& Vec){
1938      XDim=Vec.XDim; YDim=Vec.YDim; ZDim=Vec.ZDim; ValV=Vec.ValV;
1939      return *this;
1940    }
1941    bool operator==(const TVVVec& Vec) const {
1942      return (XDim==Vec.XDim)&&(YDim==Vec.YDim)&&(ZDim==Vec.ZDim)&&
1943       (ValV==Vec.ValV);}
1944    bool Empty() const {return ValV.Len()==0;}
1945    void Clr(){XDim=0; YDim=0; ZDim=0; ValV.Clr();}
1946    void Gen(const TSizeTy& _XDim, const TSizeTy& _YDim, const TSizeTy& _ZDim){
1947      Assert((_XDim>=0)&&(_YDim>=0)&&(_ZDim>=0));
1948      XDim=_XDim; YDim=_YDim; ZDim=_ZDim; ValV.Gen(XDim*YDim*ZDim);}
1949    TVal& At(const TSizeTy& X, const TSizeTy& Y, const TSizeTy& Z){
1950      Assert((0<=X)&&(X<TSizeTy(XDim))&&(0<=Y)&&(Y<TSizeTy(YDim))&&(0<=Z)&&(Z<TSizeTy(ZDim)));
1951      return ValV[X*YDim*ZDim+Y*ZDim+Z];}
1952    const TVal& At(const TSizeTy& X, const TSizeTy& Y, const TSizeTy& Z) const {
1953      Assert((0<=X)&&(X<TSizeTy(XDim))&&(0<=Y)&&(Y<TSizeTy(YDim))&&(0<=Z)&&(Z<TSizeTy(ZDim)));
1954      return ValV[X*YDim*ZDim+Y*ZDim+Z];}
1955    TVal& operator()(const TSizeTy& X, const TSizeTy& Y, const TSizeTy& Z){
1956      return At(X, Y, Z);}
1957    const TVal& operator()(const TSizeTy& X, const TSizeTy& Y, const TSizeTy& Z) const {
1958      return At(X, Y, Z);}
1959    TSizeTy GetXDim() const {return XDim;}
1960    TSizeTy GetYDim() const {return YDim;}
1961    TSizeTy GetZDim() const {return ZDim;}
1962  };
1963  typedef TVVVec<TInt> TIntVVV;
1964  typedef TVVVec<TFlt> TFltVVV;
1965  template <class TVal>
1966  class TTree{
1967  private:
1968    TVec<TTriple<TInt, TIntV, TVal> > NodeV; 
1969  public:
1970    TTree(): NodeV(){}
1971    TTree(const TTree& Tree): NodeV(Tree.NodeV){}
1972    explicit TTree(TSIn& SIn): NodeV(SIn){}
1973    void Save(TSOut& SOut) const {NodeV.Save(SOut);}
1974    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
1975    void SaveXml(TSOut& SOut, const TStr& Nm) const;
1976    TTree& operator=(const TTree& Tree){if (this!=&Tree){NodeV=Tree.NodeV;} return *this;}
1977    bool operator==(const TTree& Tree) const {return NodeV==Tree.NodeV;}
1978    bool operator<(const TTree& Tree) const {return false;}
1979    int GetPrimHashCd() const {return NodeV.GetPrimHashCd();}
1980    int GetSecHashCd() const {return NodeV.GetSecHashCd();}
1981    int GetMemUsed() const {return NodeV.GetMemUsed();}
1982    void Clr(){NodeV.Clr();}
1983    int AddNode(const int& ParentNodeId, const TVal& NodeVal=TVal()){
1984      IAssert(((ParentNodeId==-1)&&(NodeV.Len()==0))||(NodeV.Len()>0));
1985      if (ParentNodeId!=-1){NodeV[ParentNodeId].Val2.Add(NodeV.Len());}
1986      return NodeV.Add(TTriple<TInt, TIntV, TVal>(ParentNodeId, TIntV(), NodeVal));}
1987    int AddRoot(const TVal& NodeVal=TVal()){
1988      return AddNode(-1, NodeVal);}
1989    int GetNodes() const {return NodeV.Len();}
1990    void GetNodeIdV(TIntV& NodeIdV, const int& NodeId=0);
1991    int GetParentNodeId(const int& NodeId) const {return NodeV[NodeId].Val1;}
1992    int GetChildren(const int& NodeId) const {return NodeV[NodeId].Val2.Len();}
1993    int GetChildNodeId(const int& NodeId, const int& ChildN) const {return NodeV[NodeId].Val2[ChildN];}
1994    TVal& GetNodeVal(const int& NodeId){return NodeV[NodeId].Val3;}
1995    void GenRandomTree(const int& Nodes, TRnd& Rnd);
1996    void DelNode(const int& NodeId);
1997    void CopyTree(const int& SrcNodeId, TTree& DstTree, const int& DstParentNodeId=-1);
1998    void WrTree(const int& NodeId=0, const int& Lev=0);
1999  };
2000  template <class TVal>
2001  void TTree<TVal>::GetNodeIdV(TIntV& NodeIdV, const int& NodeId){
2002    if (NodeId==0){NodeIdV.Clr(); if (GetNodes()==0){return;}}
2003    else if (GetParentNodeId(NodeId)==-1){return;}
2004    NodeIdV.Add(NodeId);
2005    for (int ChildN=0; ChildN<GetChildren(NodeId); ChildN++){
2006      int ChildNodeId=GetChildNodeId(NodeId, ChildN);
2007      if (ChildNodeId!=-1){
2008        GetNodeIdV(NodeIdV, ChildNodeId);
2009      }
2010    }
2011  }
2012  template <class TVal>
2013  void TTree<TVal>::GenRandomTree(const int& Nodes, TRnd& Rnd){
2014    Clr();
2015    if (Nodes>0){
2016      AddRoot(TVal());
2017      for (int NodeN=1; NodeN<Nodes; NodeN++){
2018        int ParentNodeId=Rnd.GetUniDevInt(0, GetNodes()-1);
2019        AddNode(ParentNodeId, TVal());
2020      }
2021    }
2022  }
2023  template <class TVal>
2024  void TTree<TVal>::DelNode(const int& NodeId){
2025    if (NodeId==0){
2026      Clr();
2027    } else {
2028      TIntV& ChildNodeIdV=NodeV[GetParentNodeId(NodeId)].Val2;
2029      int ChildNodeIdN=ChildNodeIdV.SearchForw(NodeId);
2030      ChildNodeIdV[ChildNodeIdN]=-1;
2031    }
2032  }
2033  template <class TVal>
2034  void TTree<TVal>::CopyTree(const int& SrcNodeId, TTree& DstTree, const int& DstParentNodeId){
2035    int DstNodeId=DstTree.AddNode(DstParentNodeId, GetNodeVal(SrcNodeId));
2036    for (int ChildN=0; ChildN<GetChildren(SrcNodeId); ChildN++){
2037      int ChildNodeId=GetChildNodeId(SrcNodeId, ChildN);
2038      if (ChildNodeId!=-1){
2039        CopyTree(ChildNodeId, DstTree, DstNodeId);
2040      }
2041    }
2042  }
2043  template <class TVal>
2044  void TTree<TVal>::WrTree(const int& NodeId, const int& Lev){
2045    for (int LevN=0; LevN<Lev; LevN++){printf("| ");}
2046    printf("%d (%d)\n", NodeId, GetChildren(NodeId));
2047    for (int ChildN=0; ChildN<GetChildren(NodeId); ChildN++){
2048      int ChildNodeId=GetChildNodeId(NodeId, ChildN);
2049      if (ChildNodeId!=-1){
2050        WrTree(ChildNodeId, Lev+1);
2051      }
2052    }
2053  }
2054  typedef TTree<TInt> TIntTree;
2055  typedef TTree<TFlt> TFltTree;
2056  typedef TTree<TStr> TStrTree;
2057  typedef TTree<TStrIntPr> TStrIntPrTree;
2058  typedef TTree<TStrIntStrVTr> TStrIntStrVTrTree;
2059  template <class TVal>
2060  class TSStack{
2061  private:
2062    TVec<TVal> ValV;
2063  public:
2064    TSStack(): ValV(){}
2065    TSStack(const int& MxVals): ValV(MxVals, 0){}
2066    TSStack(const TSStack& Stack): ValV(Stack.ValV){}
2067    explicit TSStack(TSIn& SIn): ValV(SIn){}
2068    void Save(TSOut& SOut) const {ValV.Save(SOut);}
2069    TSStack& operator=(const TSStack& Stack){
2070      if (this!=&Stack){ValV=Stack.ValV;} return *this;}
2071    bool operator==(const TSStack& Stack) const {return this==&Stack;}
2072    const TVal& operator[](const int& ValN) const {return ValV[ValV.Len()-ValN-1];}
2073    TVal& operator[](const int& ValN) {return ValV[ValV.Len()-ValN-1];}
2074    bool Empty(){return ValV.Len()==0;}
2075    void Clr(const bool& DoDel=false) {ValV.Clr(DoDel);}
2076    bool IsIn(const TVal& Val) const {return ValV.IsIn(Val);}
2077    int Len(){return ValV.Len();}
2078    TVal& Top(){Assert(0<ValV.Len()); return ValV.Last();}
2079    const TVal& Top() const {Assert(0<ValV.Len()); return ValV.Last();}
2080    void Push(){ValV.Add();}
2081    void Push(const TVal& Val){ValV.Add(Val);}
2082    void Pop(){Assert(0<ValV.Len()); ValV.DelLast();}
2083  };
2084  typedef TSStack<TInt> TIntS;
2085  typedef TSStack<TBoolChPr> TBoolChS;
2086  template <class TVal>
2087  class TQQueue{
2088  private:
2089    TInt MxLast, MxLen;
2090    TInt First, Last;
2091    TVec<TVal> ValV;
2092  public:
2093    TQQueue(const int& _MxLast=64, const int& _MxLen=-1):
2094      MxLast(_MxLast), MxLen(_MxLen), First(0), Last(0), ValV(){
2095      Assert(int(MxLast)>0); Assert((MxLen==-1)||(int(MxLen)>0));}
2096    TQQueue(const TQQueue& Queue):
2097      MxLast(Queue.MxLast), MxLen(Queue.MxLen),
2098      First(Queue.First), Last(Queue.Last), ValV(Queue.ValV){}
2099    explicit TQQueue(TSIn& SIn):
2100      MxLast(SIn), MxLen(SIn), First(SIn), Last(SIn), ValV(SIn){}
2101    void Save(TSOut& SOut) const {
2102      MxLast.Save(SOut); MxLen.Save(SOut);
2103      First.Save(SOut); Last.Save(SOut); ValV.Save(SOut);}
2104    TQQueue& operator=(const TQQueue& Queue){
2105      if (this!=&Queue){MxLast=Queue.MxLast; MxLen=Queue.MxLen;
2106        First=Queue.First; Last=Queue.Last; ValV=Queue.ValV;}
2107      return *this;}
2108    const TVal& operator[](const int& ValN) const {Assert((0<=ValN)&&(ValN<Len()));
2109      return ValV[Last+ValN];}
2110    void Clr(const bool& DoDel=true){ValV.Clr(DoDel); First=Last=0;}
2111    void Gen(const int& _MxLast=64, const int& _MxLen=-1){
2112      MxLast=_MxLast; MxLen=_MxLen; First=0; Last=0; ValV.Clr();}
2113    void GetSubValV(const int& _BValN, const int& _EValN, TVec<TVal>& SubValV) const {
2114      int BValN=TInt::GetMx(0, _BValN);
2115      int EValN=TInt::GetMn(Len()-1, _EValN);
2116      SubValV.Gen(EValN-BValN+1);
2117      for (int ValN=BValN; ValN<=EValN; ValN++){
2118        SubValV[ValN-BValN]=ValV[Last+ValN];}
2119    }
2120    bool Empty() const {return First==Last;}
2121    int Len() const {return First-Last;}
2122    const TVal& Top() const {
2123      Assert(First!=Last); return ValV[Last];}
2124    void Pop(){
2125      IAssert(First!=Last); Last++;
2126      if (First==Last){ValV.Clr(); First=Last=0;}}
2127    void Push(const TVal& Val){
2128      if (Last>MxLast){ValV.Del(0, Last-1); First-=Last; Last=0;}
2129      if ((MxLen!=-1)&&(MxLen==Len())){Pop();}
2130      First++; ValV.Add(Val);}
2131    void Shuffle(TRnd& Rnd){
2132      TVec<TVal> ValV(Len(), 0); while (!Empty()){ValV.Add(Top()); Pop();}
2133      ValV.Shuffle(Rnd); Clr();
2134      for (int ValN=0; ValN<ValV.Len(); ValN++){Push(ValV[ValN]);}}
2135  };
2136  typedef TQQueue<TInt> TIntQ;
2137  typedef TQQueue<TFlt> TFltQ;
2138  typedef TQQueue<TStr> TStrQ;
2139  typedef TQQueue<TIntPr> TIntPrQ;
2140  typedef TQQueue<TIntStrPr> TIntStrPrQ;
2141  typedef TQQueue<TFltV> TFltVQ;
2142  typedef TQQueue<TAscFltV> TAscFltVQ;
2143  typedef TVec<TQQueue<TInt> > TIntQV;
2144  template <class TVal>
2145  class TLstNd{
2146  public:
2147    TLstNd* PrevNd;
2148    TLstNd* NextNd;
2149    TVal Val;
2150  public:
2151    TLstNd(): PrevNd(NULL), NextNd(NULL), Val(){}
2152    TLstNd(const TLstNd&);
2153    TLstNd(TLstNd* _PrevNd, TLstNd* _NextNd, const TVal& _Val):
2154      PrevNd(_PrevNd), NextNd(_NextNd), Val(_Val){}
2155    TLstNd& operator=(const TLstNd&);
2156    bool IsPrev() const {return (PrevNd != NULL); }
2157    bool IsNext() const {return (NextNd != NULL); }
2158    TLstNd* Prev() const {Assert(this!=NULL); return PrevNd;}
2159    TLstNd* Next() const {Assert(this!=NULL); return NextNd;}
2160    TVal& GetVal(){Assert(this!=NULL); return Val;}
2161    const TVal& GetVal() const {Assert(this!=NULL); return Val;}
2162  };
2163  template <class TVal>
2164  class TLst{
2165  public:
2166    typedef TLstNd<TVal>* PLstNd;
2167  private:
2168    int Nds;
2169    PLstNd FirstNd;
2170    PLstNd LastNd;
2171  public:
2172    TLst(): Nds(0), FirstNd(NULL), LastNd(NULL){}
2173    TLst(const TLst&);
2174    ~TLst(){Clr();}
2175    explicit TLst(TSIn& SIn);
2176    void Save(TSOut& SOut) const;
2177    TLst& operator=(const TLst&);
2178    void Clr(){
2179      PLstNd Nd=FirstNd;
2180      while (Nd!=NULL){PLstNd NextNd=Nd->NextNd; delete Nd; Nd=NextNd;}
2181      Nds=0; FirstNd=NULL; LastNd=NULL;}
2182    bool Empty() const {return Nds==0;}
2183    int Len() const {return Nds;}
2184    PLstNd First() const {return FirstNd;}
2185    PLstNd Last() const {return LastNd;}
2186    TVal& FirstVal() const {return FirstNd->GetVal();}
2187    TVal& LastVal() const {return LastNd->GetVal();}
2188    PLstNd AddFront(const TVal& Val);
2189    PLstNd AddBack(const TVal& Val);
2190    PLstNd AddFrontSorted(const TVal& Val, const bool& Asc=true);
2191    PLstNd AddBackSorted(const TVal& Val, const bool& Asc=true);
2192    void PutFront(const PLstNd& Nd);
2193    void PutBack(const PLstNd& Nd);
2194    PLstNd Ins(const PLstNd& Nd, const TVal& Val);
2195    void Del(const TVal& Val);
2196    void Del(const PLstNd& Nd);
2197    void DelFirst() { PLstNd DelNd = FirstNd; Del(DelNd); }
2198    void DelLast() { PLstNd DelNd = LastNd; Del(DelNd); }
2199    PLstNd SearchForw(const TVal& Val);
2200    PLstNd SearchBack(const TVal& Val);
2201    friend class TLstNd<TVal>;
2202  };
2203  template <class TVal>
2204  TLst<TVal>::TLst(TSIn& SIn):
2205    Nds(0), FirstNd(NULL), LastNd(NULL){
2206    int CheckNds=0; SIn.Load(CheckNds);
2207    for (int NdN=0; NdN<CheckNds; NdN++){AddBack(TVal(SIn));}
2208    Assert(Nds==CheckNds);
2209  }
2210  template <class TVal>
2211  void TLst<TVal>::Save(TSOut& SOut) const {
2212    SOut.Save(Nds);
2213    PLstNd Nd=FirstNd; int CheckNds=0;
2214    while (Nd!=NULL){
2215      Nd->Val.Save(SOut); Nd=Nd->NextNd; CheckNds++;}
2216    IAssert(Nds==CheckNds);
2217  }
2218  template <class TVal>
2219  TLstNd<TVal>* TLst<TVal>::AddFront(const TVal& Val){
2220    PLstNd Nd=new TLstNd<TVal>(NULL, FirstNd, Val);
2221    if (FirstNd!=NULL){FirstNd->PrevNd=Nd; FirstNd=Nd;}
2222    else {FirstNd=Nd; LastNd=Nd;}
2223    Nds++; return Nd;
2224  }
2225  template <class TVal>
2226  TLstNd<TVal>* TLst<TVal>::AddBack(const TVal& Val){
2227    PLstNd Nd=new TLstNd<TVal>(LastNd, NULL, Val);
2228    if (LastNd!=NULL){LastNd->NextNd=Nd; LastNd=Nd;}
2229    else {FirstNd=Nd; LastNd=Nd;}
2230    Nds++; return Nd;
2231  }
2232  template <class TVal>
2233  TLstNd<TVal>* TLst<TVal>::AddFrontSorted(const TVal& Val, const bool& Asc){
2234    PLstNd Nd=First();
2235    if (Nd==NULL){
2236      return Ins(Nd, Val);
2237    } else {
2238      while ((Nd!=NULL)&&((Asc&&(Val>Nd()))||(!Asc&&(Val<Nd())))){
2239        Nd=Nd->Next();}
2240      if (Nd==NULL){return Ins(Nd->Last(), Val);}
2241      else {return Ins(Nd->Prev(), Val);}
2242    }
2243  }
2244  template <class TVal>
2245  TLstNd<TVal>* TLst<TVal>::AddBackSorted(const TVal& Val, const bool& Asc){
2246    PLstNd Nd=Last();
2247    while ((Nd!=NULL)&&((Asc&&(Val<Nd->Val))||(!Asc&&(Val>Nd->Val)))){
2248      Nd=Nd->Prev();}
2249    return Ins(Nd, Val);
2250  }
2251  template <class TVal>
2252  void TLst<TVal>::PutFront(const PLstNd& Nd){
2253    Assert(Nd!=NULL);
2254    if (Nd->PrevNd==NULL){FirstNd=Nd->NextNd;}
2255    else {Nd->PrevNd->NextNd=Nd->NextNd;}
2256    if (Nd->NextNd==NULL){LastNd=Nd->PrevNd;}
2257    else {Nd->NextNd->PrevNd=Nd->PrevNd;}
2258    Nd->PrevNd=NULL; Nd->NextNd=FirstNd;
2259    if (FirstNd!=NULL){FirstNd->PrevNd=Nd; FirstNd=Nd;}
2260    else {FirstNd=Nd; LastNd=Nd;}
2261  }
2262  template <class TVal>
2263  void TLst<TVal>::PutBack(const PLstNd& Nd){
2264    Assert(Nd!=NULL);
2265    if (Nd->PrevNd==NULL){FirstNd=Nd->NextNd;}
2266    else {Nd->PrevNd->NextNd=Nd->NextNd;}
2267    if (Nd->NextNd==NULL){LastNd=Nd->PrevNd;}
2268    else {Nd->NextNd->PrevNd=Nd->PrevNd;}
2269    Nd->PrevNd=LastNd; Nd->NextNd=NULL;
2270    if (LastNd!=NULL){LastNd->NextNd=Nd; LastNd=Nd;}
2271    else {FirstNd=Nd; LastNd=Nd;}
2272  }
2273  template <class TVal>
2274  TLstNd<TVal>* TLst<TVal>::Ins(const PLstNd& Nd, const TVal& Val){
2275    if (Nd==NULL){return AddFront(Val);}
2276    else if (Nd->NextNd==NULL){return AddBack(Val);}
2277    else {
2278      PLstNd NewNd=new TLstNd<TVal>(Nd, Nd->NextNd, Val);
2279      Nd->NextNd=NewNd; NewNd->NextNd->PrevNd=Nd;
2280      Nds++; return Nd;
2281    }
2282  }
2283  template <class TVal>
2284  void TLst<TVal>::Del(const TVal& Val){
2285    PLstNd Nd=SearchForw(Val);
2286    if (Nd!=NULL){Del(Nd);}
2287  }
2288  template <class TVal>
2289  void TLst<TVal>::Del(const PLstNd& Nd){
2290    Assert(Nd!=NULL);
2291    if (Nd->PrevNd==NULL){FirstNd=Nd->NextNd;}
2292    else {Nd->PrevNd->NextNd=Nd->NextNd;}
2293    if (Nd->NextNd==NULL){LastNd=Nd->PrevNd;}
2294    else {Nd->NextNd->PrevNd=Nd->PrevNd;}
2295    Nds--; delete Nd;
2296  }
2297  template <class TVal>
2298  TLstNd<TVal>* TLst<TVal>::SearchForw(const TVal& Val){
2299    PLstNd Nd=First();
2300    while (Nd!=NULL){
2301      if (Nd->GetVal()==Val){return Nd;}
2302      Nd=Nd->Next();
2303    }
2304    return NULL;
2305  }
2306  template <class TVal>
2307  TLstNd<TVal>* TLst<TVal>::SearchBack(const TVal& Val){
2308    PLstNd Nd=Last();
2309    while (Nd!=NULL){
2310      if (Nd->GetVal()==Val){return Nd;}
2311      Nd=Nd->Prev();
2312    }
2313    return NULL;
2314  }
2315  typedef TLst<TInt> TIntL;
2316  typedef TLstNd<TInt>* PIntLN;
2317  typedef TLst<TIntKd> TIntKdL;
2318  typedef TLstNd<TIntKd>* PIntKdLN;
2319  typedef TLst<TFlt> TFltL;
2320  typedef TLstNd<TFlt>* PFltLN;
2321  typedef TLst<TFltIntKd> TFltIntKdL;
2322  typedef TLstNd<TFltIntKd>* PFltIntKdLN;
2323  typedef TLst<TAscFltIntKd> TAscFltIntKdL;
2324  typedef TLstNd<TAscFltIntKd>* PAscFltIntKdLN;
2325  typedef TLst<TStr> TStrL;
2326  typedef TLstNd<TStr>* PStrLN;
2327  template <class THd, class TRec>
2328  class TFRec{
2329  private:
2330    PFRnd FRnd;
2331  public:
2332    TFRec(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo):
2333      FRnd(PFRnd(new TFRnd(FNm, FAccess, CreateIfNo, sizeof(THd), sizeof(TRec)))){}
2334    TFRec(const TFRec&);
2335    TFRec& operator=(const TFRec&);
2336    void SetRecN(const int& RecN){FRnd->SetRecN(RecN);}
2337    int GetRecN(){return FRnd->GetRecN();}
2338    int GetRecs(){return FRnd->GetRecs();}
2339    void GetHd(THd& Hd){FRnd->GetHd(&Hd);}
2340    void PutHd(const THd& Hd){FRnd->PutHd(&Hd);}
2341    void GetRec(TRec& Rec, const int& RecN=-1){FRnd->GetRec(&Rec, RecN);}
2342    void PutRec(const TRec& Rec, const int& RecN=-1){FRnd->PutRec(&Rec, RecN);}
2343  };
2344  template <class TFuncPt>
2345  class TFunc{
2346  private:
2347    TFuncPt FuncPt;
2348  public:
2349    TFunc(): FuncPt(NULL){}
2350    TFunc(const TFunc& Func): FuncPt(Func.FuncPt){}
2351    TFunc(const TFuncPt& _FuncPt): FuncPt(_FuncPt){}
2352    TFunc(TSIn&){Fail;}
2353    void Save(TSOut&) const {Fail;}
2354    TFunc& operator=(const TFunc& Func){
2355      if (this!=&Func){FuncPt=Func.FuncPt;} return *this;}
2356    bool operator==(const TFunc& Func) const {
2357      return FuncPt==Func.FuncPt;}
2358    bool operator<(const TFunc&) const {
2359      Fail; return false;}
2360    TFuncPt operator()() const {return FuncPt;}
2361  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-signnet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ds.h</div>
                </div>
                <div class="column column_space"><pre><code>1128      else { if(Stat.GetPlsFrac()>0.8) { return true; } }
1129    }
1130    return false;
1131  }
</pre></code></div>
                <div class="column column_space"><pre><code>1002      for (TSizeTy ValN=0; ValN<Vals-1; ValN++){
1003        if (ValT[ValN]<ValT[ValN+1]){return false;}}
1004    }
1005    return true;
1006  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    