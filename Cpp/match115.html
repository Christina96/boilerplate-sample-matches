<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Utils_1.h &amp; Decompressor_4.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Utils_1.h &amp; Decompressor_4.cpp
      </h3>
<h1 align="center">
        4.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Utils_1.h (5.13834%)<th>Decompressor_4.cpp (3.7790697%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(105-111)<td><a href="#" name="0">(37-53)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Utils_1.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef ASTCENCODER_SRC_UTILS_H_
2 #define ASTCENCODER_SRC_UTILS_H_
3 #include "FasTC/ASTCCompressor.h"
4 #include "FasTC/TexCompTypes.h"
5 #include "FasTC/CompressionFormat.h"
6 #include "FasTC/Pixel.h"
7 namespace ASTCC {
8   static inline uint32 GetBlockHeight(FasTC::ECompressionFormat fmt) {
9     switch(fmt) {
10       case FasTC::eCompressionFormat_ASTC4x4: return 4;
11       case FasTC::eCompressionFormat_ASTC5x4: return 4;
12       case FasTC::eCompressionFormat_ASTC5x5: return 5;
13       case FasTC::eCompressionFormat_ASTC6x5: return 5;
14       case FasTC::eCompressionFormat_ASTC6x6: return 6;
15       case FasTC::eCompressionFormat_ASTC8x5: return 5;
16       case FasTC::eCompressionFormat_ASTC8x6: return 6;
17       case FasTC::eCompressionFormat_ASTC8x8: return 8;
18       case FasTC::eCompressionFormat_ASTC10x5: return 5;
19       case FasTC::eCompressionFormat_ASTC10x6: return 6;
20       case FasTC::eCompressionFormat_ASTC10x8: return 8;
21       case FasTC::eCompressionFormat_ASTC10x10: return 10;
22       case FasTC::eCompressionFormat_ASTC12x10: return 10;
23       case FasTC::eCompressionFormat_ASTC12x12: return 12;
24       default: assert(false); return static_cast&lt;uint32&gt;(-1);
25     }
26     assert(false);
27     return static_cast&lt;uint32&gt;(-1);
28   };
29   static inline uint32 GetBlockWidth(FasTC::ECompressionFormat fmt) {
30     switch(fmt) {
31       case FasTC::eCompressionFormat_ASTC4x4: return 4;
32       case FasTC::eCompressionFormat_ASTC5x4: return 5;
33       case FasTC::eCompressionFormat_ASTC5x5: return 5;
34       case FasTC::eCompressionFormat_ASTC6x5: return 6;
35       case FasTC::eCompressionFormat_ASTC6x6: return 6;
36       case FasTC::eCompressionFormat_ASTC8x5: return 8;
37       case FasTC::eCompressionFormat_ASTC8x6: return 8;
38       case FasTC::eCompressionFormat_ASTC8x8: return 8;
39       case FasTC::eCompressionFormat_ASTC10x5: return 10;
40       case FasTC::eCompressionFormat_ASTC10x6: return 10;
41       case FasTC::eCompressionFormat_ASTC10x8: return 10;
42       case FasTC::eCompressionFormat_ASTC10x10: return 10;
43       case FasTC::eCompressionFormat_ASTC12x10: return 12;
44       case FasTC::eCompressionFormat_ASTC12x12: return 12;
45       default: assert(false); return static_cast&lt;uint32&gt;(-1);
46     }
47     assert(false);
48     return static_cast&lt;uint32&gt;(-1);
49   };
50   static inline uint32 Popcnt(uint32 n) {
51     uint32 c;
52     for(c = 0; n; c++) {
53       n &amp;= n-1;
54     }
55     return c;
56   }
57   static inline void BitTransferSigned(int32 &amp;a, int32 &amp;b) {
58     b &gt;&gt;= 1;
59     b |= a &amp; 0x80;
60     a &gt;&gt;= 1;
61     a &amp;= 0x3F;
62     if(a &amp; 0x20)
63       a -= 0x40;
64   }
65   static inline FasTC::Pixel BlueContract(int32 a, int32 r, int32 g, int32 b) {
66     return FasTC::Pixel(
67             static_cast&lt;int16&gt;(a),
68             static_cast&lt;int16&gt;((r + b) &gt;&gt; 1),
69             static_cast&lt;int16&gt;((g + b) &gt;&gt; 1),
70             static_cast&lt;int16&gt;(b));
71   }
72 <a name="0"></a>    static inline uint32 hash52(uint32 p) {
73 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    p ^= p &gt;&gt; 15;  p -= p &lt;&lt; 17;  p += p &lt;&lt; 7; p += p &lt;&lt; 4;
74     p ^= p &gt;&gt;  5;  p += p &lt;&lt; 16;  p ^= p &gt;&gt; 7; p ^= p &gt;&gt; 3;
75     p ^= p &lt;&lt;  6;  p ^= p &gt;&gt; 17;
76     return p;
77   }
78   static uint32 SelectPartition(int32 seed, int32 x, int32 y, int32 z,</b></font>
79                                int32 partitionCount, int32 smallBlock) {
80     if(1 == partitionCount)
81       return 0;
82     if(smallBlock) {
83       x &lt;&lt;= 1;
84       y &lt;&lt;= 1;
85       z &lt;&lt;= 1;
86     }
87     seed += (partitionCount-1) * 1024;
88     uint32 rnum = hash52(static_cast&lt;uint32&gt;(seed));
89     uint8 seed1  = static_cast&lt;uint8&gt;(rnum        &amp; 0xF);
90     uint8 seed2  = static_cast&lt;uint8&gt;((rnum &gt;&gt;  4) &amp; 0xF);
91     uint8 seed3  = static_cast&lt;uint8&gt;((rnum &gt;&gt;  8) &amp; 0xF);
92     uint8 seed4  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 12) &amp; 0xF);
93     uint8 seed5  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 16) &amp; 0xF);
94     uint8 seed6  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 20) &amp; 0xF);
95     uint8 seed7  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 24) &amp; 0xF);
96     uint8 seed8  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 28) &amp; 0xF);
97     uint8 seed9  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 18) &amp; 0xF);
98     uint8 seed10 = static_cast&lt;uint8&gt;((rnum &gt;&gt; 22) &amp; 0xF);
99     uint8 seed11 = static_cast&lt;uint8&gt;((rnum &gt;&gt; 26) &amp; 0xF);
100     uint8 seed12 = static_cast&lt;uint8&gt;(((rnum &gt;&gt; 30) | (rnum &lt;&lt; 2)) &amp; 0xF);
101     seed1 *= seed1;     seed2 *= seed2;
102     seed3 *= seed3;     seed4 *= seed4;
103     seed5 *= seed5;     seed6 *= seed6;
104     seed7 *= seed7;     seed8 *= seed8;
105     seed9 *= seed9;     seed10 *= seed10;
106     seed11 *= seed11;   seed12 *= seed12;
107     int32 sh1, sh2, sh3;
108     if(seed &amp; 1) {
109       sh1 = (seed &amp; 2)? 4 : 5;
110       sh2 = (partitionCount == 3)? 6 : 5;
111     } else {
112       sh1 = (partitionCount == 3)? 6 : 5;
113       sh2 = (seed &amp; 2)? 4 : 5;
114     }
115     sh3 = (seed &amp; 0x10) ? sh1 : sh2;
116     seed1 &gt;&gt;= sh1; seed2  &gt;&gt;= sh2; seed3  &gt;&gt;= sh1; seed4  &gt;&gt;= sh2;
117     seed5 &gt;&gt;= sh1; seed6  &gt;&gt;= sh2; seed7  &gt;&gt;= sh1; seed8  &gt;&gt;= sh2;
118     seed9 &gt;&gt;= sh3; seed10 &gt;&gt;= sh3; seed11 &gt;&gt;= sh3; seed12 &gt;&gt;= sh3;
119     int32 a = seed1*x + seed2*y + seed11*z + (rnum &gt;&gt; 14);
120     int32 b = seed3*x + seed4*y + seed12*z + (rnum &gt;&gt; 10);
121     int32 c = seed5*x + seed6*y + seed9 *z + (rnum &gt;&gt;  6);
122     int32 d = seed7*x + seed8*y + seed10*z + (rnum &gt;&gt;  2);
123     a &amp;= 0x3F; b &amp;= 0x3F; c &amp;= 0x3F; d &amp;= 0x3F;
124     if( partitionCount &lt; 4 ) d = 0;
125     if( partitionCount &lt; 3 ) c = 0;
126     if( a &gt;= b &amp;&amp; a &gt;= c &amp;&amp; a &gt;= d ) return 0;
127     else if( b &gt;= c &amp;&amp; b &gt;= d ) return 1;
128     else if( c &gt;= d ) return 2;
129     return 3;
130   }
131   static inline uint32 Select2DPartition(int32 seed, int32 x, int32 y,
132                                         int32 partitionCount, int32 smallBlock) {
133     return SelectPartition(seed, x, y, 0, partitionCount, smallBlock);
134   }
135   static inline uint32 SelectSmall2DPartition(int32 seed, int32 x, int32 y,
136                                              int32 partitionCount) {
137     return Select2DPartition(seed, x, y, partitionCount, 1);
138   }
139   static inline uint32 SelectLarge2DPartition(int32 seed, int32 x, int32 y,
140                                              int32 partitionCount) {
141     return Select2DPartition(seed, x, y, partitionCount, 0);
142   }
143 }  
#endif  </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Decompressor_4.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "FasTC/PVRTCCompressor.h"
2 #include &lt;cassert&gt;
3 #include &lt;vector&gt;
4 #include "FasTC/Pixel.h"
5 #include "Block.h"
6 #include "PVRTCImage.h"
7 namespace PVRTCC {
8   static uint32 Interleave(uint16 inx, uint16 iny) {
9 <a name="0"></a>    static const uint32 B[] = {0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF};
10     static const uint32 S[] = {1, 2, 4, 8};
11 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    uint32 x = static_cast&lt;uint32&gt;(inx);
12     uint32 y = static_cast&lt;uint32&gt;(iny);
13     x = (x | (x &lt;&lt; S[3])) &amp; B[3];
14     x = (x | (x &lt;&lt; S[2])) &amp; B[2];
15     x = (x | (x &lt;&lt; S[1])) &amp; B[1];
16     x = (x | (x &lt;&lt; S[0])) &amp; B[0];
17     y = (y | (y &lt;&lt; S[3])) &amp; B[3];
18     y = (y | (y &lt;&lt; S[2])) &amp; B[2];
19     y = (y | (y &lt;&lt; S[1])) &amp; B[1];
20     y = (y | (y &lt;&lt; S[0])) &amp; B[0];
21     return x | (y &lt;&lt; 1);
22   }
23   static void Decompress4BPP(const Image &amp;imgA, const Image &amp;imgB,</b></font>
24                              const std::vector&lt;Block&gt; &amp;blocks,
25                              uint8 *const outBuf,
26                              bool bDebugImages = false) {
27     const uint32 w = imgA.GetWidth();
28     const uint32 h = imgA.GetHeight();
29     assert(imgA.GetWidth() == imgB.GetWidth());
30     assert(imgA.GetHeight() == imgB.GetHeight());
31     Image debugModulation(w, h);
32     const uint8 debugModulationBitDepth[4] = { 8, 4, 4, 4 };
33     debugModulation.ChangeBitDepth(debugModulationBitDepth);
34     for(uint32 j = 0; j &lt; h; j++) {
35       for(uint32 i = 0; i &lt; w; i++) {
36         const uint32 blockWidth = 4;
37         const uint32 blockHeight = 4;
38         const uint32 blockIdx =
39           (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
40         const Block &amp;b = blocks[blockIdx];
41         const uint32 texelIndex =
42           (j % blockHeight) * blockWidth + (i % blockWidth);
43         const Pixel &amp;pa = imgA(i, j);
44         const Pixel &amp;pb = imgB(i, j);
45         bool punchThrough = false;
46         uint8 lerpVal = 0;
47         if(b.GetModeBit()) {
48           const uint8 lerpVals[3] = { 8, 4, 0 };
49           uint8 modVal = b.GetLerpValue(texelIndex);
50           if(modVal &gt;= 2) {
51             if(modVal == 2) {
52               punchThrough = true;
53             }
54             modVal -= 1;
55           }
56           lerpVal = lerpVals[modVal];
57         } else {
58           const uint8 lerpVals[4] = { 8, 5, 3, 0 };
59           lerpVal = lerpVals[b.GetLerpValue(texelIndex)];
60         }
61         if(bDebugImages) {
62           Pixel &amp;modPx = debugModulation(i, j);
63           modPx.A() = 0xFF;
64           for(uint32 c = 1; c &lt; 4; c++) {
65             float fv = (static_cast&lt;float&gt;(lerpVal) / 8.0f) * 15.0f;
66             modPx.Component(c) = static_cast&lt;uint8&gt;(fv);
67           }
68           if(punchThrough) {
69             modPx.G() = modPx.B() = 0;
70           }
71         }
72         Pixel result = (pa * (8 - lerpVal) + pb * lerpVal) / 8;
73         if(punchThrough) {
74           result.A() = 0;
75         }
76         uint32 *outPixels = reinterpret_cast&lt;uint32 *&gt;(outBuf);
77         outPixels[(j * w) + i] = result.Pack();
78       }
79     }
80     if(bDebugImages) {
81       debugModulation.DebugOutput("Modulation");
82     }
83   }
84   static void Decompress2BPP(const Image &amp;imgA, const Image &amp;imgB,
85                              const std::vector&lt;Block&gt; &amp;blocks,
86                              uint8 *const outBuf,
87                              bool bDebugImages) {
88     const uint32 w = imgA.GetWidth();
89     const uint32 h = imgA.GetHeight();
90     assert(w &gt; 0);
91     assert(h &gt; 0);
92     assert(imgA.GetWidth() == imgB.GetWidth());
93     assert(imgA.GetHeight() == imgB.GetHeight());
94     std::vector&lt;uint8&gt; modValues;
95     modValues.reserve(w * h);
96     const uint32 blockWidth = 8;
97     const uint32 blockHeight = 4;
98     for(uint32 j = 0; j &lt; h; j++) {
99       for(uint32 i = 0; i &lt; w; i++) {
100         const uint32 blockIdx =
101           (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
102         const Block &amp;b = blocks[blockIdx];
103         const uint32 texelIndex =
104           (j % blockHeight) * blockWidth + (i % blockWidth);
105         uint8 lerpVal = 0;
106         if(b.GetModeBit()) {
107           uint32 texelX = texelIndex % blockWidth;
108           uint32 texelY = texelIndex / blockWidth;
109           const uint8 lerpVals[4] = { 8, 5, 3, 0 };
110           if(((texelX ^ texelY) &amp; 0x1) == 0) {
111             uint32 lerpIdx = texelY * (blockWidth / 2) + (texelX / 2);
112             lerpVal = lerpVals[b.Get2BPPLerpValue(lerpIdx)];
113           }
114         } else {
115           lerpVal = b.Get2BPPLerpValue(texelIndex);
116           lerpVal = lerpVal? 0 : 8;
117         }
118         modValues.push_back(lerpVal);
119       }
120     }
121     assert(modValues.size() == w * h);
122     for(uint32 j = 0; j &lt; h; j++) {
123       for(uint32 i = 0; i &lt; w; i++) {
124         const uint32 blockIdx =
125           (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
126         const Block &amp;b = blocks[blockIdx];
127         uint8 lerpVal = 0;
128         #define GET_LERP_VAL(x, y) modValues[(y) * w + (x)]
129         if(b.GetModeBit() &amp;&amp; ((i ^ j) &amp; 0x1)) {
130           switch(b.Get2BPPSubMode()) {
131             case Block::e2BPPSubMode_Horizontal:
132               lerpVal += GET_LERP_VAL((i + w - 1) % w, j);
133               lerpVal += GET_LERP_VAL((i + w + 1) % w, j);
134               lerpVal /= 2;
135             break;
136             case Block::e2BPPSubMode_Vertical:
137               lerpVal += GET_LERP_VAL(i, (j + h - 1) % h);
138               lerpVal += GET_LERP_VAL(i, (j + h + 1) % h);
139               lerpVal /= 2;
140             break;
141             default:
142             case Block::e2BPPSubMode_All:
143               lerpVal += GET_LERP_VAL(i, (j + h - 1) % h);
144               lerpVal += GET_LERP_VAL(i, (j + h + 1) % h);
145               lerpVal += GET_LERP_VAL((i + w - 1) % w, j);
146               lerpVal += GET_LERP_VAL((i + w + 1) % w, j);
147               lerpVal = (lerpVal + 1) / 4;
148             break;
149           }
150           GET_LERP_VAL(i, j) = lerpVal;
151         } else {
152           lerpVal = GET_LERP_VAL(i, j);
153         }
154         #undef GET_LERP_VAL
155         const Pixel &amp;pa = imgA(i, j);
156         const Pixel &amp;pb = imgB(i, j);
157         Pixel result = (pa * (8 - lerpVal) + pb * lerpVal) / 8;
158         uint32 *outPixels = reinterpret_cast&lt;uint32 *&gt;(outBuf);
159         outPixels[(j * w) + i] = result.Pack();
160       }
161     }
162     if(bDebugImages) {
163       Image dbgMod(w, h);
164       for(uint32 i = 0; i &lt; h*w; i++) {
165         float fb = static_cast&lt;float&gt;(modValues[i]);
166         uint8 val = static_cast&lt;uint8&gt;((fb / 8.0f) * 15.0f);
167         for(uint32 k = 1; k &lt; 4; k++) {
168           dbgMod(i%w, i/w).Component(k) = val;
169         }
170         dbgMod(i%w, i/w).A() = 0xFF;
171       }
172       dbgMod.DebugOutput("Modulation");
173     }
174   }
175   void Decompress(const FasTC::DecompressionJob &amp;dcj,
176                   const EWrapMode wrapMode,
177                   bool bDebugImages) {
178     const bool bTwoBitMode = dcj.Format() == FasTC::eCompressionFormat_PVRTC2;
179     const uint32 w = dcj.Width();
180     const uint32 h = dcj.Height();
181     assert(w &gt; 0);
182     assert(h &gt; 0);
183     assert(bTwoBitMode || w % 4 == 0);
184     assert(!bTwoBitMode || w % 8 == 0);
185     assert(h % 4 == 0);
186     std::vector&lt;Block&gt; blocks;
187     const uint32 blocksW = bTwoBitMode? (w / 8) : (w / 4);
188     const uint32 blocksH = h / 4;
189     blocks.reserve(blocksW * blocksH);
190     for(uint32 j = 0; j &lt; blocksH; j++) {
191       for(uint32 i = 0; i &lt; blocksW; i++) {
192         uint32 idx = Interleave(j, i);
193         uint32 offset = idx * kBlockSize;
194         blocks.push_back( Block(dcj.InBuf() + offset) );
195       }
196     }
197     assert(blocks.size() &gt; 0);
198     Image imgA(blocksW, blocksH);
199     Image imgB(blocksW, blocksH);
200     for(uint32 j = 0; j &lt; blocksH; j++) {
201       for(uint32 i = 0; i &lt; blocksW; i++) {
202         uint32 idx = j * blocksW + i;
203         assert(idx &lt; static_cast&lt;uint32&gt;(blocks.size()));
204         Block &amp;b = blocks[idx];
205         imgA(i, j) = b.GetColorA();
206         imgB(i, j) = b.GetColorB();
207       }
208     }
209     const uint8 scaleDepths[4] = { 4, 5, 5, 5 };
210     imgA.ChangeBitDepth(scaleDepths);
211     if(bDebugImages)
212       imgA.DebugOutput("UnscaledImgA");
213     imgB.ChangeBitDepth(scaleDepths);
214     if(bDebugImages)
215       imgB.DebugOutput("UnscaledImgB");
216     for(uint32 j = 0; j &lt; blocksH; j++) {
217       for(uint32 i = 0; i &lt; blocksW; i++) {
218         const uint32 blockIdx = j * blocksW + i;
219         Block &amp;b = blocks[blockIdx];
220         uint8 bitDepths[4];
221         b.GetColorA().GetBitDepth(bitDepths);
222         if(bitDepths[0] &gt; 0) {
223           Pixel &amp;p = imgA(i, j);
224           p.A() = p.A() &amp; 0xFE;
225         }
226         b.GetColorB().GetBitDepth(bitDepths);
227         if(bitDepths[0] &gt; 0) {
228           Pixel &amp;p = imgB(i, j);
229           p.A() = p.A() &amp; 0xFE;
230         }
231       }
232     }
233     if(bTwoBitMode) {
234       imgA.BilinearUpscale(3, 2, wrapMode);
235       imgB.BilinearUpscale(3, 2, wrapMode);
236     } else {
237       imgA.BilinearUpscale(2, 2, wrapMode);
238       imgB.BilinearUpscale(2, 2, wrapMode);
239     }
240     if(bDebugImages) {
241       imgA.DebugOutput("RawScaledImgA");
242       imgB.DebugOutput("RawScaledImgB");
243     }
244     imgA.ExpandTo8888();
245     imgB.ExpandTo8888();
246     if(bDebugImages) {
247       imgA.DebugOutput("ScaledImgA");
248       imgB.DebugOutput("ScaledImgB");
249     }
250     if(bTwoBitMode) {
251       Decompress2BPP(imgA, imgB, blocks, dcj.OutBuf(), bDebugImages);
252     } else {
253       Decompress4BPP(imgA, imgB, blocks, dcj.OutBuf(), bDebugImages);
254     }
255   }
}  </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
