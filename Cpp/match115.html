<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Utils_1.h & Decompressor_4.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Utils_1.h & Decompressor_4.cpp
      </h3>
      <h1 align="center">
        4.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Utils_1.h (5.13834%)<TH>Decompressor_4.cpp (3.7790697%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match115-0.html#0',2,'match115-1.html#0',3)" NAME="0">(105-111)<TD><A HREF="javascript:ZweiFrames('match115-0.html#0',2,'match115-1.html#0',3)" NAME="0">(37-53)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Utils_1.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright 2016 The University of North Carolina at Chapel Hill
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Please send all BUG REPORTS to &lt;pavel@cs.unc.edu&gt;.
// &lt;http://gamma.cs.unc.edu/FasTC/&gt;

#ifndef ASTCENCODER_SRC_UTILS_H_
#define ASTCENCODER_SRC_UTILS_H_

#include &quot;FasTC/ASTCCompressor.h&quot;

#include &quot;FasTC/TexCompTypes.h&quot;
#include &quot;FasTC/CompressionFormat.h&quot;
#include &quot;FasTC/Pixel.h&quot;

namespace ASTCC {

  static inline uint32 GetBlockHeight(FasTC::ECompressionFormat fmt) {
    switch(fmt) {
      case FasTC::eCompressionFormat_ASTC4x4: return 4;
      case FasTC::eCompressionFormat_ASTC5x4: return 4;
      case FasTC::eCompressionFormat_ASTC5x5: return 5;
      case FasTC::eCompressionFormat_ASTC6x5: return 5;
      case FasTC::eCompressionFormat_ASTC6x6: return 6;
      case FasTC::eCompressionFormat_ASTC8x5: return 5;
      case FasTC::eCompressionFormat_ASTC8x6: return 6;
      case FasTC::eCompressionFormat_ASTC8x8: return 8;
      case FasTC::eCompressionFormat_ASTC10x5: return 5;
      case FasTC::eCompressionFormat_ASTC10x6: return 6;
      case FasTC::eCompressionFormat_ASTC10x8: return 8;
      case FasTC::eCompressionFormat_ASTC10x10: return 10;
      case FasTC::eCompressionFormat_ASTC12x10: return 10;
      case FasTC::eCompressionFormat_ASTC12x12: return 12;
      default: assert(false); return static_cast&lt;uint32&gt;(-1);
    }
    assert(false);
    return static_cast&lt;uint32&gt;(-1);
  };

  static inline uint32 GetBlockWidth(FasTC::ECompressionFormat fmt) {
    switch(fmt) {
      case FasTC::eCompressionFormat_ASTC4x4: return 4;
      case FasTC::eCompressionFormat_ASTC5x4: return 5;
      case FasTC::eCompressionFormat_ASTC5x5: return 5;
      case FasTC::eCompressionFormat_ASTC6x5: return 6;
      case FasTC::eCompressionFormat_ASTC6x6: return 6;
      case FasTC::eCompressionFormat_ASTC8x5: return 8;
      case FasTC::eCompressionFormat_ASTC8x6: return 8;
      case FasTC::eCompressionFormat_ASTC8x8: return 8;
      case FasTC::eCompressionFormat_ASTC10x5: return 10;
      case FasTC::eCompressionFormat_ASTC10x6: return 10;
      case FasTC::eCompressionFormat_ASTC10x8: return 10;
      case FasTC::eCompressionFormat_ASTC10x10: return 10;
      case FasTC::eCompressionFormat_ASTC12x10: return 12;
      case FasTC::eCompressionFormat_ASTC12x12: return 12;
      default: assert(false); return static_cast&lt;uint32&gt;(-1);
    }
    assert(false);
    return static_cast&lt;uint32&gt;(-1);
  };

  // Count the number of bits set in a number.
  static inline uint32 Popcnt(uint32 n) {
    uint32 c;
    for(c = 0; n; c++) {
      n &amp;= n-1;
    }
    return c;
  }

  // Transfers a bit as described in C.2.14
  static inline void BitTransferSigned(int32 &amp;a, int32 &amp;b) {
    b &gt;&gt;= 1;
    b |= a &amp; 0x80;
    a &gt;&gt;= 1;
    a &amp;= 0x3F;
    if(a &amp; 0x20)
      a -= 0x40;
  }

  // Adds more precision to the blue channel as described
  // in C.2.14
  static inline FasTC::Pixel BlueContract(int32 a, int32 r, int32 g, int32 b) {
    return FasTC::Pixel(
            static_cast&lt;int16&gt;(a),
            static_cast&lt;int16&gt;((r + b) &gt;&gt; 1),
            static_cast&lt;int16&gt;((g + b) &gt;&gt; 1),
            static_cast&lt;int16&gt;(b));
  }

<A NAME="0"></A>  // Partition selection functions as specified in
  // C.2.21
  static inline uint32 hash52(uint32 p) {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match115-1.html#0',3,'match115-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    p ^= p &gt;&gt; 15;  p -= p &lt;&lt; 17;  p += p &lt;&lt; 7; p += p &lt;&lt; 4;
    p ^= p &gt;&gt;  5;  p += p &lt;&lt; 16;  p ^= p &gt;&gt; 7; p ^= p &gt;&gt; 3;
    p ^= p &lt;&lt;  6;  p ^= p &gt;&gt; 17;
    return p;
  }

  static uint32 SelectPartition(int32 seed, int32 x, int32 y, int32 z,</B></FONT>
                               int32 partitionCount, int32 smallBlock) {
    if(1 == partitionCount)
      return 0;

    if(smallBlock) {
      x &lt;&lt;= 1;
      y &lt;&lt;= 1;
      z &lt;&lt;= 1;
    }

    seed += (partitionCount-1) * 1024;

    uint32 rnum = hash52(static_cast&lt;uint32&gt;(seed));
    uint8 seed1  = static_cast&lt;uint8&gt;(rnum        &amp; 0xF);
    uint8 seed2  = static_cast&lt;uint8&gt;((rnum &gt;&gt;  4) &amp; 0xF);
    uint8 seed3  = static_cast&lt;uint8&gt;((rnum &gt;&gt;  8) &amp; 0xF);
    uint8 seed4  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 12) &amp; 0xF);
    uint8 seed5  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 16) &amp; 0xF);
    uint8 seed6  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 20) &amp; 0xF);
    uint8 seed7  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 24) &amp; 0xF);
    uint8 seed8  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 28) &amp; 0xF);
    uint8 seed9  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 18) &amp; 0xF);
    uint8 seed10 = static_cast&lt;uint8&gt;((rnum &gt;&gt; 22) &amp; 0xF);
    uint8 seed11 = static_cast&lt;uint8&gt;((rnum &gt;&gt; 26) &amp; 0xF);
    uint8 seed12 = static_cast&lt;uint8&gt;(((rnum &gt;&gt; 30) | (rnum &lt;&lt; 2)) &amp; 0xF);

    seed1 *= seed1;     seed2 *= seed2;
    seed3 *= seed3;     seed4 *= seed4;
    seed5 *= seed5;     seed6 *= seed6;
    seed7 *= seed7;     seed8 *= seed8;
    seed9 *= seed9;     seed10 *= seed10;
    seed11 *= seed11;   seed12 *= seed12;

    int32 sh1, sh2, sh3;
    if(seed &amp; 1) {
      sh1 = (seed &amp; 2)? 4 : 5;
      sh2 = (partitionCount == 3)? 6 : 5;
    } else {
      sh1 = (partitionCount == 3)? 6 : 5;
      sh2 = (seed &amp; 2)? 4 : 5;
    }
    sh3 = (seed &amp; 0x10) ? sh1 : sh2;

    seed1 &gt;&gt;= sh1; seed2  &gt;&gt;= sh2; seed3  &gt;&gt;= sh1; seed4  &gt;&gt;= sh2;
    seed5 &gt;&gt;= sh1; seed6  &gt;&gt;= sh2; seed7  &gt;&gt;= sh1; seed8  &gt;&gt;= sh2;
    seed9 &gt;&gt;= sh3; seed10 &gt;&gt;= sh3; seed11 &gt;&gt;= sh3; seed12 &gt;&gt;= sh3;

    int32 a = seed1*x + seed2*y + seed11*z + (rnum &gt;&gt; 14);
    int32 b = seed3*x + seed4*y + seed12*z + (rnum &gt;&gt; 10);
    int32 c = seed5*x + seed6*y + seed9 *z + (rnum &gt;&gt;  6);
    int32 d = seed7*x + seed8*y + seed10*z + (rnum &gt;&gt;  2);

    a &amp;= 0x3F; b &amp;= 0x3F; c &amp;= 0x3F; d &amp;= 0x3F;

    if( partitionCount &lt; 4 ) d = 0;
    if( partitionCount &lt; 3 ) c = 0;

    if( a &gt;= b &amp;&amp; a &gt;= c &amp;&amp; a &gt;= d ) return 0;
    else if( b &gt;= c &amp;&amp; b &gt;= d ) return 1;
    else if( c &gt;= d ) return 2;
    return 3;
  }

  static inline uint32 Select2DPartition(int32 seed, int32 x, int32 y,
                                        int32 partitionCount, int32 smallBlock) {
    return SelectPartition(seed, x, y, 0, partitionCount, smallBlock);
  }

  static inline uint32 SelectSmall2DPartition(int32 seed, int32 x, int32 y,
                                             int32 partitionCount) {
    return Select2DPartition(seed, x, y, partitionCount, 1);
  }

  static inline uint32 SelectLarge2DPartition(int32 seed, int32 x, int32 y,
                                             int32 partitionCount) {
    return Select2DPartition(seed, x, y, partitionCount, 0);
  }
}  // namespace ASTCC

#endif  // ASTCENCODER_SRC_UTILS_H_
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Decompressor_4.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright 2016 The University of North Carolina at Chapel Hill
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Please send all BUG REPORTS to &lt;pavel@cs.unc.edu&gt;.
// &lt;http://gamma.cs.unc.edu/FasTC/&gt;

#include &quot;FasTC/PVRTCCompressor.h&quot;

#include &lt;cassert&gt;
#include &lt;vector&gt;

#include &quot;FasTC/Pixel.h&quot;

#include &quot;Block.h&quot;
#include &quot;PVRTCImage.h&quot;

namespace PVRTCC {

  static uint32 Interleave(uint16 inx, uint16 iny) {
    // Taken from:
    // http://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN

<A NAME="0"></A>    static const uint32 B[] = {0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF};
    static const uint32 S[] = {1, 2, 4, 8};

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match115-0.html#0',2,'match115-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    uint32 x = static_cast&lt;uint32&gt;(inx);
    uint32 y = static_cast&lt;uint32&gt;(iny);

    x = (x | (x &lt;&lt; S[3])) &amp; B[3];
    x = (x | (x &lt;&lt; S[2])) &amp; B[2];
    x = (x | (x &lt;&lt; S[1])) &amp; B[1];
    x = (x | (x &lt;&lt; S[0])) &amp; B[0];

    y = (y | (y &lt;&lt; S[3])) &amp; B[3];
    y = (y | (y &lt;&lt; S[2])) &amp; B[2];
    y = (y | (y &lt;&lt; S[1])) &amp; B[1];
    y = (y | (y &lt;&lt; S[0])) &amp; B[0];

    return x | (y &lt;&lt; 1);
  }

  static void Decompress4BPP(const Image &amp;imgA, const Image &amp;imgB,</B></FONT>
                             const std::vector&lt;Block&gt; &amp;blocks,
                             uint8 *const outBuf,
                             bool bDebugImages = false) {
    const uint32 w = imgA.GetWidth();
    const uint32 h = imgA.GetHeight();

    assert(imgA.GetWidth() == imgB.GetWidth());
    assert(imgA.GetHeight() == imgB.GetHeight());

    Image debugModulation(w, h);
    const uint8 debugModulationBitDepth[4] = { 8, 4, 4, 4 };
    debugModulation.ChangeBitDepth(debugModulationBitDepth);

    for(uint32 j = 0; j &lt; h; j++) {
      for(uint32 i = 0; i &lt; w; i++) {
        const uint32 blockWidth = 4;
        const uint32 blockHeight = 4;

        const uint32 blockIdx =
          (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
        const Block &amp;b = blocks[blockIdx];

        const uint32 texelIndex =
          (j % blockHeight) * blockWidth + (i % blockWidth);

        const Pixel &amp;pa = imgA(i, j);
        const Pixel &amp;pb = imgB(i, j);

        bool punchThrough = false;
        uint8 lerpVal = 0;
        if(b.GetModeBit()) {
          const uint8 lerpVals[3] = { 8, 4, 0 };
          uint8 modVal = b.GetLerpValue(texelIndex);

          if(modVal &gt;= 2) {
            if(modVal == 2) {
              punchThrough = true;
            }
            modVal -= 1;
          }

          lerpVal = lerpVals[modVal];
        } else {
          const uint8 lerpVals[4] = { 8, 5, 3, 0 };
          lerpVal = lerpVals[b.GetLerpValue(texelIndex)];
        }

        if(bDebugImages) {
          Pixel &amp;modPx = debugModulation(i, j);
          modPx.A() = 0xFF;
          for(uint32 c = 1; c &lt; 4; c++) {
            float fv = (static_cast&lt;float&gt;(lerpVal) / 8.0f) * 15.0f;
            modPx.Component(c) = static_cast&lt;uint8&gt;(fv);
          }

          // Make punch through pixels red.
          if(punchThrough) {
            modPx.G() = modPx.B() = 0;
          }
        }

        Pixel result = (pa * (8 - lerpVal) + pb * lerpVal) / 8;
        if(punchThrough) {
          result.A() = 0;
        }

        uint32 *outPixels = reinterpret_cast&lt;uint32 *&gt;(outBuf);
        outPixels[(j * w) + i] = result.Pack();
      }
    }

    if(bDebugImages) {
      debugModulation.DebugOutput(&quot;Modulation&quot;);
    }
  }

  static void Decompress2BPP(const Image &amp;imgA, const Image &amp;imgB,
                             const std::vector&lt;Block&gt; &amp;blocks,
                             uint8 *const outBuf,
                             bool bDebugImages) {
    const uint32 w = imgA.GetWidth();
    const uint32 h = imgA.GetHeight();

    assert(w &gt; 0);
    assert(h &gt; 0);
    assert(imgA.GetWidth() == imgB.GetWidth());
    assert(imgA.GetHeight() == imgB.GetHeight());

    std::vector&lt;uint8&gt; modValues;
    modValues.reserve(w * h);

    const uint32 blockWidth = 8;
    const uint32 blockHeight = 4;

    for(uint32 j = 0; j &lt; h; j++) {
      for(uint32 i = 0; i &lt; w; i++) {

        const uint32 blockIdx =
          (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
        const Block &amp;b = blocks[blockIdx];

        const uint32 texelIndex =
          (j % blockHeight) * blockWidth + (i % blockWidth);

        uint8 lerpVal = 0;
        if(b.GetModeBit()) {
          uint32 texelX = texelIndex % blockWidth;
          uint32 texelY = texelIndex / blockWidth;

          const uint8 lerpVals[4] = { 8, 5, 3, 0 };
          if(((texelX ^ texelY) &amp; 0x1) == 0) {
            uint32 lerpIdx = texelY * (blockWidth / 2) + (texelX / 2);
            lerpVal = lerpVals[b.Get2BPPLerpValue(lerpIdx)];
          }
        } else {
          lerpVal = b.Get2BPPLerpValue(texelIndex);
          lerpVal = lerpVal? 0 : 8;
        }
        modValues.push_back(lerpVal);
      }
    }

    assert(modValues.size() == w * h);

    for(uint32 j = 0; j &lt; h; j++) {
      for(uint32 i = 0; i &lt; w; i++) {

        const uint32 blockIdx =
          (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
        const Block &amp;b = blocks[blockIdx];

        uint8 lerpVal = 0;
        #define GET_LERP_VAL(x, y) modValues[(y) * w + (x)]
        if(b.GetModeBit() &amp;&amp; ((i ^ j) &amp; 0x1)) {

          switch(b.Get2BPPSubMode()) {
            case Block::e2BPPSubMode_Horizontal:
              lerpVal += GET_LERP_VAL((i + w - 1) % w, j);
              lerpVal += GET_LERP_VAL((i + w + 1) % w, j);
              lerpVal /= 2;
            break;

            case Block::e2BPPSubMode_Vertical:
              lerpVal += GET_LERP_VAL(i, (j + h - 1) % h);
              lerpVal += GET_LERP_VAL(i, (j + h + 1) % h);
              lerpVal /= 2;
            break;

            default:
            case Block::e2BPPSubMode_All:
              lerpVal += GET_LERP_VAL(i, (j + h - 1) % h);
              lerpVal += GET_LERP_VAL(i, (j + h + 1) % h);
              lerpVal += GET_LERP_VAL((i + w - 1) % w, j);
              lerpVal += GET_LERP_VAL((i + w + 1) % w, j);
              lerpVal = (lerpVal + 1) / 4;
            break;
          }
          GET_LERP_VAL(i, j) = lerpVal;
        } else {
          lerpVal = GET_LERP_VAL(i, j);
        }
        #undef GET_LERP_VAL

        const Pixel &amp;pa = imgA(i, j);
        const Pixel &amp;pb = imgB(i, j);

        Pixel result = (pa * (8 - lerpVal) + pb * lerpVal) / 8;
        uint32 *outPixels = reinterpret_cast&lt;uint32 *&gt;(outBuf);
        outPixels[(j * w) + i] = result.Pack();
      }
    }

    if(bDebugImages) {
      Image dbgMod(w, h);
      for(uint32 i = 0; i &lt; h*w; i++) {
        float fb = static_cast&lt;float&gt;(modValues[i]);
        uint8 val = static_cast&lt;uint8&gt;((fb / 8.0f) * 15.0f);

        for(uint32 k = 1; k &lt; 4; k++) {
          dbgMod(i%w, i/w).Component(k) = val;
        }
        dbgMod(i%w, i/w).A() = 0xFF;
      }

      dbgMod.DebugOutput(&quot;Modulation&quot;);
    }
  }

  void Decompress(const FasTC::DecompressionJob &amp;dcj,
                  const EWrapMode wrapMode,
                  bool bDebugImages) {
    const bool bTwoBitMode = dcj.Format() == FasTC::eCompressionFormat_PVRTC2;
    const uint32 w = dcj.Width();
    const uint32 h = dcj.Height();

    assert(w &gt; 0);
    assert(h &gt; 0);
    assert(bTwoBitMode || w % 4 == 0);
    assert(!bTwoBitMode || w % 8 == 0);
    assert(h % 4 == 0);

    // First, extract all of the block information...
    std::vector&lt;Block&gt; blocks;

    const uint32 blocksW = bTwoBitMode? (w / 8) : (w / 4);
    const uint32 blocksH = h / 4;
    blocks.reserve(blocksW * blocksH);

    for(uint32 j = 0; j &lt; blocksH; j++) {
      for(uint32 i = 0; i &lt; blocksW; i++) {

        // The blocks are initially arranged in morton order. Let's
        // linearize them...
        uint32 idx = Interleave(j, i);

        uint32 offset = idx * kBlockSize;
        blocks.push_back( Block(dcj.InBuf() + offset) );
      }
    }

    assert(blocks.size() &gt; 0);

    // Extract the endpoints into A and B images
    Image imgA(blocksW, blocksH);
    Image imgB(blocksW, blocksH);

    for(uint32 j = 0; j &lt; blocksH; j++) {
      for(uint32 i = 0; i &lt; blocksW; i++) {

        uint32 idx = j * blocksW + i;
        assert(idx &lt; static_cast&lt;uint32&gt;(blocks.size()));

        Block &amp;b = blocks[idx];
        imgA(i, j) = b.GetColorA();
        imgB(i, j) = b.GetColorB();
      }
    }

    // Change the pixel mode so that all of the pixels are at the same
    // bit depth.
    const uint8 scaleDepths[4] = { 4, 5, 5, 5 };
    imgA.ChangeBitDepth(scaleDepths);
    if(bDebugImages)
      imgA.DebugOutput(&quot;UnscaledImgA&quot;);
    imgB.ChangeBitDepth(scaleDepths);
    if(bDebugImages)
      imgB.DebugOutput(&quot;UnscaledImgB&quot;);

    // Go through and change the alpha value of any pixel that came from
    // a transparent block. For some reason, alpha is not treated the same
    // as the other channels (to minimize hardware costs?) and the channels
    // do not their MSBs replicated.
    for(uint32 j = 0; j &lt; blocksH; j++) {
      for(uint32 i = 0; i &lt; blocksW; i++) {
        const uint32 blockIdx = j * blocksW + i;
        Block &amp;b = blocks[blockIdx];

        uint8 bitDepths[4];
        b.GetColorA().GetBitDepth(bitDepths);
        if(bitDepths[0] &gt; 0) {
          Pixel &amp;p = imgA(i, j);
          p.A() = p.A() &amp; 0xFE;
        }

        b.GetColorB().GetBitDepth(bitDepths);
        if(bitDepths[0] &gt; 0) {
          Pixel &amp;p = imgB(i, j);
          p.A() = p.A() &amp; 0xFE;
        }
      }
    }

    // Bilinearly upscale the images.
    if(bTwoBitMode) {
      imgA.BilinearUpscale(3, 2, wrapMode);
      imgB.BilinearUpscale(3, 2, wrapMode);
    } else {
      imgA.BilinearUpscale(2, 2, wrapMode);
      imgB.BilinearUpscale(2, 2, wrapMode);
    }

    if(bDebugImages) {
      imgA.DebugOutput(&quot;RawScaledImgA&quot;);
      imgB.DebugOutput(&quot;RawScaledImgB&quot;);
    }

    // Change the bitdepth to full resolution
    imgA.ExpandTo8888();
    imgB.ExpandTo8888();

    if(bDebugImages) {
      imgA.DebugOutput(&quot;ScaledImgA&quot;);
      imgB.DebugOutput(&quot;ScaledImgB&quot;);
    }

    if(bTwoBitMode) {
      Decompress2BPP(imgA, imgB, blocks, dcj.OutBuf(), bDebugImages);
    } else {
      Decompress4BPP(imgA, imgB, blocks, dcj.OutBuf(), bDebugImages);
    }
  }

}  // namespace PVRTCC
</PRE>
</div>
  </div>
</body>
</html>
