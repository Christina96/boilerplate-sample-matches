<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Utils_1.h &amp; Decompressor_4.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Utils_1.h &amp; Decompressor_4.cpp
      </h3>
<h1 align="center">
        4.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Utils_1.h (5.13834%)<th>Decompressor_4.cpp (3.7790697%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(105-111)<td><a href="#" name="0">(37-53)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Utils_1.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef ASTCENCODER_SRC_UTILS_H_
#define ASTCENCODER_SRC_UTILS_H_
#include "FasTC/ASTCCompressor.h"
#include "FasTC/TexCompTypes.h"
#include "FasTC/CompressionFormat.h"
#include "FasTC/Pixel.h"
namespace ASTCC {
  static inline uint32 GetBlockHeight(FasTC::ECompressionFormat fmt) {
    switch(fmt) {
      case FasTC::eCompressionFormat_ASTC4x4: return 4;
      case FasTC::eCompressionFormat_ASTC5x4: return 4;
      case FasTC::eCompressionFormat_ASTC5x5: return 5;
      case FasTC::eCompressionFormat_ASTC6x5: return 5;
      case FasTC::eCompressionFormat_ASTC6x6: return 6;
      case FasTC::eCompressionFormat_ASTC8x5: return 5;
      case FasTC::eCompressionFormat_ASTC8x6: return 6;
      case FasTC::eCompressionFormat_ASTC8x8: return 8;
      case FasTC::eCompressionFormat_ASTC10x5: return 5;
      case FasTC::eCompressionFormat_ASTC10x6: return 6;
      case FasTC::eCompressionFormat_ASTC10x8: return 8;
      case FasTC::eCompressionFormat_ASTC10x10: return 10;
      case FasTC::eCompressionFormat_ASTC12x10: return 10;
      case FasTC::eCompressionFormat_ASTC12x12: return 12;
      default: assert(false); return static_cast&lt;uint32&gt;(-1);
    }
    assert(false);
    return static_cast&lt;uint32&gt;(-1);
  };
  static inline uint32 GetBlockWidth(FasTC::ECompressionFormat fmt) {
    switch(fmt) {
      case FasTC::eCompressionFormat_ASTC4x4: return 4;
      case FasTC::eCompressionFormat_ASTC5x4: return 5;
      case FasTC::eCompressionFormat_ASTC5x5: return 5;
      case FasTC::eCompressionFormat_ASTC6x5: return 6;
      case FasTC::eCompressionFormat_ASTC6x6: return 6;
      case FasTC::eCompressionFormat_ASTC8x5: return 8;
      case FasTC::eCompressionFormat_ASTC8x6: return 8;
      case FasTC::eCompressionFormat_ASTC8x8: return 8;
      case FasTC::eCompressionFormat_ASTC10x5: return 10;
      case FasTC::eCompressionFormat_ASTC10x6: return 10;
      case FasTC::eCompressionFormat_ASTC10x8: return 10;
      case FasTC::eCompressionFormat_ASTC10x10: return 10;
      case FasTC::eCompressionFormat_ASTC12x10: return 12;
      case FasTC::eCompressionFormat_ASTC12x12: return 12;
      default: assert(false); return static_cast&lt;uint32&gt;(-1);
    }
    assert(false);
    return static_cast&lt;uint32&gt;(-1);
  };
  static inline uint32 Popcnt(uint32 n) {
    uint32 c;
    for(c = 0; n; c++) {
      n &amp;= n-1;
    }
    return c;
  }
  static inline void BitTransferSigned(int32 &amp;a, int32 &amp;b) {
    b &gt;&gt;= 1;
    b |= a &amp; 0x80;
    a &gt;&gt;= 1;
    a &amp;= 0x3F;
    if(a &amp; 0x20)
      a -= 0x40;
  }
  static inline FasTC::Pixel BlueContract(int32 a, int32 r, int32 g, int32 b) {
    return FasTC::Pixel(
            static_cast&lt;int16&gt;(a),
            static_cast&lt;int16&gt;((r + b) &gt;&gt; 1),
            static_cast&lt;int16&gt;((g + b) &gt;&gt; 1),
            static_cast&lt;int16&gt;(b));
  }
<a name="0"></a>    static inline uint32 hash52(uint32 p) {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    p ^= p &gt;&gt; 15;  p -= p &lt;&lt; 17;  p += p &lt;&lt; 7; p += p &lt;&lt; 4;
    p ^= p &gt;&gt;  5;  p += p &lt;&lt; 16;  p ^= p &gt;&gt; 7; p ^= p &gt;&gt; 3;
    p ^= p &lt;&lt;  6;  p ^= p &gt;&gt; 17;
    return p;
  }
  static uint32 SelectPartition(int32 seed, int32 x, int32 y, int32 z,</b></font>
                               int32 partitionCount, int32 smallBlock) {
    if(1 == partitionCount)
      return 0;
    if(smallBlock) {
      x &lt;&lt;= 1;
      y &lt;&lt;= 1;
      z &lt;&lt;= 1;
    }
    seed += (partitionCount-1) * 1024;
    uint32 rnum = hash52(static_cast&lt;uint32&gt;(seed));
    uint8 seed1  = static_cast&lt;uint8&gt;(rnum        &amp; 0xF);
    uint8 seed2  = static_cast&lt;uint8&gt;((rnum &gt;&gt;  4) &amp; 0xF);
    uint8 seed3  = static_cast&lt;uint8&gt;((rnum &gt;&gt;  8) &amp; 0xF);
    uint8 seed4  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 12) &amp; 0xF);
    uint8 seed5  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 16) &amp; 0xF);
    uint8 seed6  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 20) &amp; 0xF);
    uint8 seed7  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 24) &amp; 0xF);
    uint8 seed8  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 28) &amp; 0xF);
    uint8 seed9  = static_cast&lt;uint8&gt;((rnum &gt;&gt; 18) &amp; 0xF);
    uint8 seed10 = static_cast&lt;uint8&gt;((rnum &gt;&gt; 22) &amp; 0xF);
    uint8 seed11 = static_cast&lt;uint8&gt;((rnum &gt;&gt; 26) &amp; 0xF);
    uint8 seed12 = static_cast&lt;uint8&gt;(((rnum &gt;&gt; 30) | (rnum &lt;&lt; 2)) &amp; 0xF);
    seed1 *= seed1;     seed2 *= seed2;
    seed3 *= seed3;     seed4 *= seed4;
    seed5 *= seed5;     seed6 *= seed6;
    seed7 *= seed7;     seed8 *= seed8;
    seed9 *= seed9;     seed10 *= seed10;
    seed11 *= seed11;   seed12 *= seed12;
    int32 sh1, sh2, sh3;
    if(seed &amp; 1) {
      sh1 = (seed &amp; 2)? 4 : 5;
      sh2 = (partitionCount == 3)? 6 : 5;
    } else {
      sh1 = (partitionCount == 3)? 6 : 5;
      sh2 = (seed &amp; 2)? 4 : 5;
    }
    sh3 = (seed &amp; 0x10) ? sh1 : sh2;
    seed1 &gt;&gt;= sh1; seed2  &gt;&gt;= sh2; seed3  &gt;&gt;= sh1; seed4  &gt;&gt;= sh2;
    seed5 &gt;&gt;= sh1; seed6  &gt;&gt;= sh2; seed7  &gt;&gt;= sh1; seed8  &gt;&gt;= sh2;
    seed9 &gt;&gt;= sh3; seed10 &gt;&gt;= sh3; seed11 &gt;&gt;= sh3; seed12 &gt;&gt;= sh3;
    int32 a = seed1*x + seed2*y + seed11*z + (rnum &gt;&gt; 14);
    int32 b = seed3*x + seed4*y + seed12*z + (rnum &gt;&gt; 10);
    int32 c = seed5*x + seed6*y + seed9 *z + (rnum &gt;&gt;  6);
    int32 d = seed7*x + seed8*y + seed10*z + (rnum &gt;&gt;  2);
    a &amp;= 0x3F; b &amp;= 0x3F; c &amp;= 0x3F; d &amp;= 0x3F;
    if( partitionCount &lt; 4 ) d = 0;
    if( partitionCount &lt; 3 ) c = 0;
    if( a &gt;= b &amp;&amp; a &gt;= c &amp;&amp; a &gt;= d ) return 0;
    else if( b &gt;= c &amp;&amp; b &gt;= d ) return 1;
    else if( c &gt;= d ) return 2;
    return 3;
  }
  static inline uint32 Select2DPartition(int32 seed, int32 x, int32 y,
                                        int32 partitionCount, int32 smallBlock) {
    return SelectPartition(seed, x, y, 0, partitionCount, smallBlock);
  }
  static inline uint32 SelectSmall2DPartition(int32 seed, int32 x, int32 y,
                                             int32 partitionCount) {
    return Select2DPartition(seed, x, y, partitionCount, 1);
  }
  static inline uint32 SelectLarge2DPartition(int32 seed, int32 x, int32 y,
                                             int32 partitionCount) {
    return Select2DPartition(seed, x, y, partitionCount, 0);
  }
}  
#endif  </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Decompressor_4.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "FasTC/PVRTCCompressor.h"
#include &lt;cassert&gt;
#include &lt;vector&gt;
#include "FasTC/Pixel.h"
#include "Block.h"
#include "PVRTCImage.h"
namespace PVRTCC {
  static uint32 Interleave(uint16 inx, uint16 iny) {
<a name="0"></a>    static const uint32 B[] = {0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF};
    static const uint32 S[] = {1, 2, 4, 8};
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    uint32 x = static_cast&lt;uint32&gt;(inx);
    uint32 y = static_cast&lt;uint32&gt;(iny);
    x = (x | (x &lt;&lt; S[3])) &amp; B[3];
    x = (x | (x &lt;&lt; S[2])) &amp; B[2];
    x = (x | (x &lt;&lt; S[1])) &amp; B[1];
    x = (x | (x &lt;&lt; S[0])) &amp; B[0];
    y = (y | (y &lt;&lt; S[3])) &amp; B[3];
    y = (y | (y &lt;&lt; S[2])) &amp; B[2];
    y = (y | (y &lt;&lt; S[1])) &amp; B[1];
    y = (y | (y &lt;&lt; S[0])) &amp; B[0];
    return x | (y &lt;&lt; 1);
  }
  static void Decompress4BPP(const Image &amp;imgA, const Image &amp;imgB,</b></font>
                             const std::vector&lt;Block&gt; &amp;blocks,
                             uint8 *const outBuf,
                             bool bDebugImages = false) {
    const uint32 w = imgA.GetWidth();
    const uint32 h = imgA.GetHeight();
    assert(imgA.GetWidth() == imgB.GetWidth());
    assert(imgA.GetHeight() == imgB.GetHeight());
    Image debugModulation(w, h);
    const uint8 debugModulationBitDepth[4] = { 8, 4, 4, 4 };
    debugModulation.ChangeBitDepth(debugModulationBitDepth);
    for(uint32 j = 0; j &lt; h; j++) {
      for(uint32 i = 0; i &lt; w; i++) {
        const uint32 blockWidth = 4;
        const uint32 blockHeight = 4;
        const uint32 blockIdx =
          (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
        const Block &amp;b = blocks[blockIdx];
        const uint32 texelIndex =
          (j % blockHeight) * blockWidth + (i % blockWidth);
        const Pixel &amp;pa = imgA(i, j);
        const Pixel &amp;pb = imgB(i, j);
        bool punchThrough = false;
        uint8 lerpVal = 0;
        if(b.GetModeBit()) {
          const uint8 lerpVals[3] = { 8, 4, 0 };
          uint8 modVal = b.GetLerpValue(texelIndex);
          if(modVal &gt;= 2) {
            if(modVal == 2) {
              punchThrough = true;
            }
            modVal -= 1;
          }
          lerpVal = lerpVals[modVal];
        } else {
          const uint8 lerpVals[4] = { 8, 5, 3, 0 };
          lerpVal = lerpVals[b.GetLerpValue(texelIndex)];
        }
        if(bDebugImages) {
          Pixel &amp;modPx = debugModulation(i, j);
          modPx.A() = 0xFF;
          for(uint32 c = 1; c &lt; 4; c++) {
            float fv = (static_cast&lt;float&gt;(lerpVal) / 8.0f) * 15.0f;
            modPx.Component(c) = static_cast&lt;uint8&gt;(fv);
          }
          if(punchThrough) {
            modPx.G() = modPx.B() = 0;
          }
        }
        Pixel result = (pa * (8 - lerpVal) + pb * lerpVal) / 8;
        if(punchThrough) {
          result.A() = 0;
        }
        uint32 *outPixels = reinterpret_cast&lt;uint32 *&gt;(outBuf);
        outPixels[(j * w) + i] = result.Pack();
      }
    }
    if(bDebugImages) {
      debugModulation.DebugOutput("Modulation");
    }
  }
  static void Decompress2BPP(const Image &amp;imgA, const Image &amp;imgB,
                             const std::vector&lt;Block&gt; &amp;blocks,
                             uint8 *const outBuf,
                             bool bDebugImages) {
    const uint32 w = imgA.GetWidth();
    const uint32 h = imgA.GetHeight();
    assert(w &gt; 0);
    assert(h &gt; 0);
    assert(imgA.GetWidth() == imgB.GetWidth());
    assert(imgA.GetHeight() == imgB.GetHeight());
    std::vector&lt;uint8&gt; modValues;
    modValues.reserve(w * h);
    const uint32 blockWidth = 8;
    const uint32 blockHeight = 4;
    for(uint32 j = 0; j &lt; h; j++) {
      for(uint32 i = 0; i &lt; w; i++) {
        const uint32 blockIdx =
          (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
        const Block &amp;b = blocks[blockIdx];
        const uint32 texelIndex =
          (j % blockHeight) * blockWidth + (i % blockWidth);
        uint8 lerpVal = 0;
        if(b.GetModeBit()) {
          uint32 texelX = texelIndex % blockWidth;
          uint32 texelY = texelIndex / blockWidth;
          const uint8 lerpVals[4] = { 8, 5, 3, 0 };
          if(((texelX ^ texelY) &amp; 0x1) == 0) {
            uint32 lerpIdx = texelY * (blockWidth / 2) + (texelX / 2);
            lerpVal = lerpVals[b.Get2BPPLerpValue(lerpIdx)];
          }
        } else {
          lerpVal = b.Get2BPPLerpValue(texelIndex);
          lerpVal = lerpVal? 0 : 8;
        }
        modValues.push_back(lerpVal);
      }
    }
    assert(modValues.size() == w * h);
    for(uint32 j = 0; j &lt; h; j++) {
      for(uint32 i = 0; i &lt; w; i++) {
        const uint32 blockIdx =
          (j/blockHeight) * (w/blockWidth) + (i/blockWidth);
        const Block &amp;b = blocks[blockIdx];
        uint8 lerpVal = 0;
        #define GET_LERP_VAL(x, y) modValues[(y) * w + (x)]
        if(b.GetModeBit() &amp;&amp; ((i ^ j) &amp; 0x1)) {
          switch(b.Get2BPPSubMode()) {
            case Block::e2BPPSubMode_Horizontal:
              lerpVal += GET_LERP_VAL((i + w - 1) % w, j);
              lerpVal += GET_LERP_VAL((i + w + 1) % w, j);
              lerpVal /= 2;
            break;
            case Block::e2BPPSubMode_Vertical:
              lerpVal += GET_LERP_VAL(i, (j + h - 1) % h);
              lerpVal += GET_LERP_VAL(i, (j + h + 1) % h);
              lerpVal /= 2;
            break;
            default:
            case Block::e2BPPSubMode_All:
              lerpVal += GET_LERP_VAL(i, (j + h - 1) % h);
              lerpVal += GET_LERP_VAL(i, (j + h + 1) % h);
              lerpVal += GET_LERP_VAL((i + w - 1) % w, j);
              lerpVal += GET_LERP_VAL((i + w + 1) % w, j);
              lerpVal = (lerpVal + 1) / 4;
            break;
          }
          GET_LERP_VAL(i, j) = lerpVal;
        } else {
          lerpVal = GET_LERP_VAL(i, j);
        }
        #undef GET_LERP_VAL
        const Pixel &amp;pa = imgA(i, j);
        const Pixel &amp;pb = imgB(i, j);
        Pixel result = (pa * (8 - lerpVal) + pb * lerpVal) / 8;
        uint32 *outPixels = reinterpret_cast&lt;uint32 *&gt;(outBuf);
        outPixels[(j * w) + i] = result.Pack();
      }
    }
    if(bDebugImages) {
      Image dbgMod(w, h);
      for(uint32 i = 0; i &lt; h*w; i++) {
        float fb = static_cast&lt;float&gt;(modValues[i]);
        uint8 val = static_cast&lt;uint8&gt;((fb / 8.0f) * 15.0f);
        for(uint32 k = 1; k &lt; 4; k++) {
          dbgMod(i%w, i/w).Component(k) = val;
        }
        dbgMod(i%w, i/w).A() = 0xFF;
      }
      dbgMod.DebugOutput("Modulation");
    }
  }
  void Decompress(const FasTC::DecompressionJob &amp;dcj,
                  const EWrapMode wrapMode,
                  bool bDebugImages) {
    const bool bTwoBitMode = dcj.Format() == FasTC::eCompressionFormat_PVRTC2;
    const uint32 w = dcj.Width();
    const uint32 h = dcj.Height();
    assert(w &gt; 0);
    assert(h &gt; 0);
    assert(bTwoBitMode || w % 4 == 0);
    assert(!bTwoBitMode || w % 8 == 0);
    assert(h % 4 == 0);
    std::vector&lt;Block&gt; blocks;
    const uint32 blocksW = bTwoBitMode? (w / 8) : (w / 4);
    const uint32 blocksH = h / 4;
    blocks.reserve(blocksW * blocksH);
    for(uint32 j = 0; j &lt; blocksH; j++) {
      for(uint32 i = 0; i &lt; blocksW; i++) {
        uint32 idx = Interleave(j, i);
        uint32 offset = idx * kBlockSize;
        blocks.push_back( Block(dcj.InBuf() + offset) );
      }
    }
    assert(blocks.size() &gt; 0);
    Image imgA(blocksW, blocksH);
    Image imgB(blocksW, blocksH);
    for(uint32 j = 0; j &lt; blocksH; j++) {
      for(uint32 i = 0; i &lt; blocksW; i++) {
        uint32 idx = j * blocksW + i;
        assert(idx &lt; static_cast&lt;uint32&gt;(blocks.size()));
        Block &amp;b = blocks[idx];
        imgA(i, j) = b.GetColorA();
        imgB(i, j) = b.GetColorB();
      }
    }
    const uint8 scaleDepths[4] = { 4, 5, 5, 5 };
    imgA.ChangeBitDepth(scaleDepths);
    if(bDebugImages)
      imgA.DebugOutput("UnscaledImgA");
    imgB.ChangeBitDepth(scaleDepths);
    if(bDebugImages)
      imgB.DebugOutput("UnscaledImgB");
    for(uint32 j = 0; j &lt; blocksH; j++) {
      for(uint32 i = 0; i &lt; blocksW; i++) {
        const uint32 blockIdx = j * blocksW + i;
        Block &amp;b = blocks[blockIdx];
        uint8 bitDepths[4];
        b.GetColorA().GetBitDepth(bitDepths);
        if(bitDepths[0] &gt; 0) {
          Pixel &amp;p = imgA(i, j);
          p.A() = p.A() &amp; 0xFE;
        }
        b.GetColorB().GetBitDepth(bitDepths);
        if(bitDepths[0] &gt; 0) {
          Pixel &amp;p = imgB(i, j);
          p.A() = p.A() &amp; 0xFE;
        }
      }
    }
    if(bTwoBitMode) {
      imgA.BilinearUpscale(3, 2, wrapMode);
      imgB.BilinearUpscale(3, 2, wrapMode);
    } else {
      imgA.BilinearUpscale(2, 2, wrapMode);
      imgB.BilinearUpscale(2, 2, wrapMode);
    }
    if(bDebugImages) {
      imgA.DebugOutput("RawScaledImgA");
      imgB.DebugOutput("RawScaledImgB");
    }
    imgA.ExpandTo8888();
    imgB.ExpandTo8888();
    if(bDebugImages) {
      imgA.DebugOutput("ScaledImgA");
      imgB.DebugOutput("ScaledImgB");
    }
    if(bTwoBitMode) {
      Decompress2BPP(imgA, imgB, blocks, dcj.OutBuf(), bDebugImages);
    } else {
      Decompress4BPP(imgA, imgB, blocks, dcj.OutBuf(), bDebugImages);
    }
  }
}  </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
