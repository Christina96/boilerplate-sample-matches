
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hash.cpp</h3>
            <pre><code>1  void TBigStrPool::Resize(TSize _MxBfL) {
2    TSize newSize = MxBfL;
3    while (newSize < _MxBfL) {
4      if (newSize >= GrowBy && GrowBy > 0) newSize += GrowBy;
5      else if (newSize > 0) newSize *= 2;
6      else newSize = TInt::GetMn(GrowBy, 1024);
7    }
8    if (newSize > MxBfL) {
9      if (IsShM) {
10        Bf = (char*) malloc(newSize);
11        IsShM = false;
12      } else {
13        Bf = (char *) realloc(Bf, newSize);
14      }
15      IAssertR(Bf, TStr::Fmt("old Bf size: %u, new size: %u", MxBfL, newSize).CStr());
16      MxBfL = newSize;
17    }
18    IAssert(MxBfL >= _MxBfL);
19  }
20  TBigStrPool::TBigStrPool(TSize MxBfLen, uint _GrowBy) : MxBfL(MxBfLen), BfL(0), GrowBy(_GrowBy), Bf(0), IsShM(false) {
21    if (MxBfL > 0) { Bf = (char *) malloc(MxBfL);  IAssert(Bf); }
22    AddStr(""); 
23  }
24  TBigStrPool::TBigStrPool(TSIn& SIn, bool LoadCompact) : MxBfL(0), BfL(0), GrowBy(0), Bf(0), IsShM(false) {
25    uint64 Tmp;
26    SIn.Load(Tmp); IAssert(Tmp <= uint64(TSizeMx)); MxBfL=TSize(Tmp);
27    SIn.Load(Tmp); IAssert(Tmp <= uint64(TSizeMx)); BfL=TSize(Tmp);
28    SIn.Load(GrowBy);
29    IAssert(MxBfL >= BfL);  IAssert(BfL >= 0);  IAssert(GrowBy >= 0);
30    if (LoadCompact) MxBfL = BfL;
31    if (MxBfL > 0) { Bf = (char *) malloc(MxBfL); IAssert(Bf); }
32    if (BfL > 0) { SIn.LoadBf(Bf, BfL); }
33    SIn.LoadCs();
34    int NStr=0;  SIn.Load(NStr);
35    IdOffV.Gen(NStr, 0);
36    for (int i = 0; i < NStr; i++) {
37      SIn.Load(Tmp);
38      IAssert(Tmp <= uint64(TSizeMx));
39      IdOffV.Add(TSize(Tmp));
40    }
41  }
42  void TBigStrPool::LoadPoolShM(TShMIn& ShMIn, bool LoadCompact) {
43    uint64 Tmp;
44    ShMIn.Load(Tmp); IAssert(Tmp <= uint64(TSizeMx)); MxBfL=TSize(Tmp);
45    ShMIn.Load(Tmp); IAssert(Tmp <= uint64(TSizeMx)); BfL=TSize(Tmp);
46    ShMIn.Load(GrowBy); IAssert(MxBfL >= BfL);  IAssert(BfL >= 0);  IAssert(GrowBy >= 0);
47    IsShM = true;
48    if (LoadCompact) {
49      MxBfL = BfL;
50      Bf = (char*)(ShMIn.AdvanceCursor(BfL));
51      IsShM = true;
52    } else {
53      if (MxBfL > 0) { Bf = (char *) malloc(MxBfL); IAssert(Bf); IsShM = false;}
54      if (BfL > 0) { ShMIn.LoadBf(Bf, BfL); }
55      IsShM = false;
56    }
57    ShMIn.LoadCs();
58    int NStr=0;
59    ShMIn.Load(NStr);
60    IdOffV.Gen(NStr, 0);
61    for (int i = 0; i < NStr; i++) {
62      ShMIn.Load(Tmp);
63      IAssert(Tmp <= uint64(TSizeMx));
64      IdOffV.Add(TSize(Tmp));
65    }
66  }
67  void TBigStrPool::Save(TSOut& SOut) const {
68    SOut.Save(uint64(MxBfL));  SOut.Save(uint64(BfL));  SOut.Save(GrowBy);
69    if (BfL > 0) { SOut.SaveBf(Bf, BfL); }
70    SOut.SaveCs();
71    SOut.Save(IdOffV.Len());
72    for (int i = 0; i < IdOffV.Len(); i++) {
73      SOut.Save(uint64(IdOffV[i])); 
74    }
75  }
76  TBigStrPool& TBigStrPool::operator = (const TBigStrPool& Pool) {
77    if (this != &Pool) {
78      GrowBy = Pool.GrowBy;  MxBfL = Pool.MxBfL;  BfL = Pool.BfL;
79      if (Bf) free(Bf); else IAssert(MxBfL == 0);
80      Bf = (char *) malloc(MxBfL);  IAssert(Bf);  memcpy(Bf, Pool.Bf, BfL);
81    }
82    return *this;
83  }
84  int TBigStrPool::AddStr(const char *Str, uint Len) {
85    IAssertR(Len > 0, "String too short (lenght includes the null character)");  
86    Assert(Str);  Assert(Len > 0);
87    if (Len == 1 && IdOffV.Len() > 0) { return 0; } 
88    if (BfL + Len > MxBfL) { Resize(BfL + Len); }
89    memcpy(Bf + BfL, Str, Len);
90    TSize Pos = BfL;  BfL += Len;  
91    IdOffV.Add(Pos);
92    return IdOffV.Len()-1;
93  }
94  int TBigStrPool::GetPrimHashCd(const char *CStr) {
95    return TStrHashF_DJB::GetPrimHashCd(CStr);
96  }
97  int TBigStrPool::GetSecHashCd(const char *CStr) {
98    return TStrHashF_DJB::GetSecHashCd(CStr);
99  }
100  int TStrHashF_Md5::GetPrimHashCd(const char *p) {
101    TMd5Sig sig = TStr(p); 
102    return sig.GetPrimHashCd(); 
103  }
104  int TStrHashF_Md5::GetSecHashCd(const char *p) {
105    TMd5Sig sig = TStr(p);
106    return sig.GetSecHashCd(); 
107  }
108  int TStrHashF_Md5::GetPrimHashCd(const TStr& s) {
109    TMd5Sig sig(s);
110    return sig.GetPrimHashCd(); 
111  }
<span onclick='openModal()' class='match'>112  int TStrHashF_Md5::GetSecHashCd(const TStr& s) {
113    TMd5Sig sig(s);
114    return sig.GetSecHashCd();
</span>115  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablerecog.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "tablerecog.h"
5  #include <algorithm>
6  namespace tesseract {
7  const double kHorizontalSpacing = 0.30;
8  const double kVerticalSpacing = -0.2;
9  const int kCellSplitRowThreshold = 0;
10  const int kCellSplitColumnThreshold = 0;
11  const int kLinedTableMinVerticalLines = 3;
12  const int kLinedTableMinHorizontalLines = 3;
13  const double kRequiredColumns = 0.7;
14  const double kMarginFactor = 1.1;
15  const double kMaxRowSize = 2.5;
16  const double kGoodRowNumberOfColumnsSmall[] = {2, 2, 2, 2, 2, 3, 3};
17  const double kGoodRowNumberOfColumnsLarge = 0.7;
18  const double kMinFilledArea = 0.35;
19  static bool IsWeakTableRow(StructuredTable *table, int row) {
20    if (!table->VerifyRowFilled(row)) {
21      return false;
22    }
23    double threshold;
24    if (table->column_count() < countof(kGoodRowNumberOfColumnsSmall)) {
25      threshold = kGoodRowNumberOfColumnsSmall[table->column_count()];
26    } else {
27      threshold = table->column_count() * kGoodRowNumberOfColumnsLarge;
28    }
29    return table->CountFilledCellsInRow(row) < threshold;
30  }
31  StructuredTable::StructuredTable()
32      : text_grid_(nullptr)
33      , line_grid_(nullptr)
34      , is_lined_(false)
35      , space_above_(0)
36      , space_below_(0)
37      , space_left_(0)
38      , space_right_(0)
39      , median_cell_height_(0)
40      , median_cell_width_(0)
41      , max_text_height_(INT32_MAX) {}
42  void StructuredTable::Init() {}
43  void StructuredTable::set_text_grid(ColPartitionGrid *text_grid) {
44    text_grid_ = text_grid;
45  }
46  void StructuredTable::set_line_grid(ColPartitionGrid *line_grid) {
47    line_grid_ = line_grid;
48  }
49  void StructuredTable::set_max_text_height(int height) {
50    max_text_height_ = height;
51  }
52  bool StructuredTable::is_lined() const {
53    return is_lined_;
54  }
55  unsigned StructuredTable::row_count() const {
56    return cell_y_.empty() ? 0 : cell_y_.size() - 1;
57  }
58  unsigned StructuredTable::column_count() const {
59    return cell_x_.empty() ? 0 : cell_x_.size() - 1;
60  }
61  unsigned StructuredTable::cell_count() const {
62    return row_count() * column_count();
63  }
64  void StructuredTable::set_bounding_box(const TBOX &box) {
65    bounding_box_ = box;
66  }
67  const TBOX &StructuredTable::bounding_box() const {
68    return bounding_box_;
69  }
70  int StructuredTable::median_cell_height() {
71    return median_cell_height_;
72  }
73  int StructuredTable::median_cell_width() {
74    return median_cell_width_;
75  }
76  int StructuredTable::row_height(unsigned row) const {
77    ASSERT_HOST(row < row_count());
78    return cell_y_[row + 1] - cell_y_[row];
79  }
80  int StructuredTable::column_width(unsigned column) const {
81    ASSERT_HOST(column < column_count());
82    return cell_x_[column + 1] - cell_x_[column];
83  }
84  int StructuredTable::space_above() const {
85    return space_above_;
86  }
87  int StructuredTable::space_below() const {
88    return space_below_;
89  }
90  bool StructuredTable::FindLinedStructure() {
91    ClearStructure();
92    ColPartitionGridSearch box_search(line_grid_);
93    box_search.SetUniqueMode(true);
94    box_search.StartRectSearch(bounding_box_);
95    ColPartition *line = nullptr;
96    while ((line = box_search.NextRectSearch()) != nullptr) {
97      if (line->IsHorizontalLine()) {
98        cell_y_.push_back(line->MidY());
99      }
100      if (line->IsVerticalLine()) {
101        cell_x_.push_back(line->MidX());
102      }
103    }
104    if (cell_x_.size() < 3 || cell_y_.size() < 3) {
105      return false;
106    }
107    std::sort(cell_x_.begin(), cell_x_.end());
108    auto last_x = std::unique(cell_x_.begin(), cell_x_.end());
109    cell_x_.erase(last_x, cell_x_.end());
110    std::sort(cell_y_.begin(), cell_y_.end());
111    auto last_y = std::unique(cell_y_.begin(), cell_y_.end());
112    cell_y_.erase(last_y, cell_y_.end());
113    cell_x_[0] = bounding_box_.left();
114    cell_x_[cell_x_.size() - 1] = bounding_box_.right();
115    cell_y_[0] = bounding_box_.bottom();
116    cell_y_[cell_y_.size() - 1] = bounding_box_.top();
117    last_x = std::unique(cell_x_.begin(), cell_x_.end());
118    cell_x_.erase(last_x, cell_x_.end());
119    last_y = std::unique(cell_y_.begin(), cell_y_.end());
120    cell_y_.erase(last_y, cell_y_.end());
121    CalculateMargins();
122    CalculateStats();
123    is_lined_ = VerifyLinedTableCells();
124    return is_lined_;
125  }
126  bool StructuredTable::FindWhitespacedStructure() {
127    ClearStructure();
128    FindWhitespacedColumns();
129    FindWhitespacedRows();
130    if (!VerifyWhitespacedTable()) {
131      return false;
132    } else {
133      bounding_box_.set_left(cell_x_[0]);
134      bounding_box_.set_right(cell_x_[cell_x_.size() - 1]);
135      bounding_box_.set_bottom(cell_y_[0]);
136      bounding_box_.set_top(cell_y_[cell_y_.size() - 1]);
137      AbsorbNearbyLines();
138      CalculateMargins();
139      CalculateStats();
140      return true;
141    }
142  }
143  bool StructuredTable::DoesPartitionFit(const ColPartition &part) const {
144    const TBOX &box = part.bounding_box();
145    for (int i : cell_x_) {
146      if (box.left() < i && i < box.right()) {
147        return false;
148      }
149    }
150    for (int i : cell_y_) {
151      if (box.bottom() < i && i < box.top()) {
152        return false;
153      }
154    }
155    return true;
156  }
157  int StructuredTable::CountFilledCells() {
158    return CountFilledCells(0, row_count() - 1, 0, column_count() - 1);
159  }
160  int StructuredTable::CountFilledCellsInRow(int row) {
161    return CountFilledCells(row, row, 0, column_count() - 1);
162  }
163  int StructuredTable::CountFilledCellsInColumn(int column) {
164    return CountFilledCells(0, row_count() - 1, column, column);
165  }
166  int StructuredTable::CountFilledCells(unsigned row_start, unsigned row_end, unsigned column_start,
167                                        unsigned column_end) {
168    ASSERT_HOST(row_start <= row_end && row_end < row_count());
169    ASSERT_HOST(column_start <= column_end && column_end < column_count());
170    int cell_count = 0;
171    TBOX cell_box;
172    for (unsigned row = row_start; row <= row_end; ++row) {
173      cell_box.set_bottom(cell_y_[row]);
174      cell_box.set_top(cell_y_[row + 1]);
175      for (unsigned col = column_start; col <= column_end; ++col) {
176        cell_box.set_left(cell_x_[col]);
177        cell_box.set_right(cell_x_[col + 1]);
178        if (CountPartitions(cell_box) > 0) {
179          ++cell_count;
180        }
181      }
182    }
183    return cell_count;
184  }
185  bool StructuredTable::VerifyRowFilled(int row) {
186    for (unsigned i = 0; i < column_count(); ++i) {
187      auto area_filled = CalculateCellFilledPercentage(row, i);
188      if (area_filled >= kMinFilledArea) {
189        return true;
190      }
191    }
192    return false;
193  }
194  double StructuredTable::CalculateCellFilledPercentage(unsigned row, unsigned column) {
195    ASSERT_HOST(row <= row_count());
196    ASSERT_HOST(column <= column_count());
197    const TBOX kCellBox(cell_x_[column], cell_y_[row], cell_x_[column + 1], cell_y_[row + 1]);
198    ASSERT_HOST(!kCellBox.null_box());
199    ColPartitionGridSearch gsearch(text_grid_);
200    gsearch.SetUniqueMode(true);
201    gsearch.StartRectSearch(kCellBox);
202    double area_covered = 0;
203    ColPartition *text = nullptr;
204    while ((text = gsearch.NextRectSearch()) != nullptr) {
205      if (text->IsTextType()) {
206        area_covered += text->bounding_box().intersection(kCellBox).area();
207      }
208    }
209    const int32_t current_area = kCellBox.area();
210    if (current_area == 0) {
211      return 1.0;
212    }
213    return std::min(1.0, area_covered / current_area);
214  }
215  #ifndef GRAPHICS_DISABLED
216  void StructuredTable::Display(ScrollView *window, ScrollView::Color color) {
217    window->Brush(ScrollView::NONE);
218    window->Pen(color);
219    window->Rectangle(bounding_box_.left(), bounding_box_.bottom(), bounding_box_.right(),
220                      bounding_box_.top());
221    for (int i : cell_x_) {
222      window->Line(i, bounding_box_.bottom(), i, bounding_box_.top());
223    }
224    for (int i : cell_y_) {
225      window->Line(bounding_box_.left(), i, bounding_box_.right(), i);
226    }
227    window->UpdateWindow();
228  }
229  #endif
230  void StructuredTable::ClearStructure() {
231    cell_x_.clear();
232    cell_y_.clear();
233    is_lined_ = false;
234    space_above_ = 0;
235    space_below_ = 0;
236    space_left_ = 0;
237    space_right_ = 0;
238    median_cell_height_ = 0;
239    median_cell_width_ = 0;
240  }
241  bool StructuredTable::VerifyLinedTableCells() {
242    ASSERT_HOST(cell_y_.size() >= 2 && cell_x_.size() >= 2);
243    for (int i : cell_y_) {
244      if (CountHorizontalIntersections(i) > 0) {
245        return false;
246      }
247    }
248    for (int i : cell_x_) {
249      if (CountVerticalIntersections(i) > 0) {
250        return false;
251      }
252    }
253    return true;
254  }
255  bool StructuredTable::VerifyWhitespacedTable() {
256    return row_count() >= 2 && column_count() >= 2 && cell_count() >= 6;
257  }
258  void StructuredTable::FindWhitespacedColumns() {
259    std::vector<int> left_sides;
260    std::vector<int> right_sides;
261    ColPartitionGridSearch gsearch(text_grid_);
262    gsearch.SetUniqueMode(true);
263    gsearch.StartRectSearch(bounding_box_);
264    ColPartition *text = nullptr;
265    while ((text = gsearch.NextRectSearch()) != nullptr) {
266      if (!text->IsTextType()) {
267        continue;
268      }
269      ASSERT_HOST(text->bounding_box().left() < text->bounding_box().right());
270      int spacing = static_cast<int>(text->median_width() * kHorizontalSpacing / 2.0 + 0.5);
271      left_sides.push_back(text->bounding_box().left() - spacing);
272      right_sides.push_back(text->bounding_box().right() + spacing);
273    }
274    if (left_sides.empty() || right_sides.empty()) {
275      return;
276    }
277    std::sort(left_sides.begin(), left_sides.end());
278    std::sort(right_sides.begin(), right_sides.end());
279    FindCellSplitLocations(left_sides, right_sides, kCellSplitColumnThreshold, &cell_x_);
280  }
281  void StructuredTable::FindWhitespacedRows() {
282    std::vector<int> bottom_sides;
283    std::vector<int> top_sides;
284    int min_bottom = INT32_MAX;
285    int max_top = INT32_MIN;
286    ColPartitionGridSearch gsearch(text_grid_);
287    gsearch.SetUniqueMode(true);
288    gsearch.StartRectSearch(bounding_box_);
289    ColPartition *text = nullptr;
290    while ((text = gsearch.NextRectSearch()) != nullptr) {
291      if (!text->IsTextType()) {
292        continue;
293      }
294      ASSERT_HOST(text->bounding_box().bottom() < text->bounding_box().top());
295      min_bottom = std::min(min_bottom, static_cast<int>(text->bounding_box().bottom()));
296      max_top = std::max(max_top, static_cast<int>(text->bounding_box().top()));
297      if (text->bounding_box().height() > max_text_height_) {
298        continue;
299      }
300      int spacing = static_cast<int>(text->bounding_box().height() * kVerticalSpacing / 2.0 + 0.5);
301      int bottom = text->bounding_box().bottom() - spacing;
302      int top = text->bounding_box().top() + spacing;
303      if (bottom >= top) {
304        continue;
305      }
306      bottom_sides.push_back(bottom);
307      top_sides.push_back(top);
308    }
309    if (bottom_sides.empty() || top_sides.empty()) {
310      return;
311    }
312    std::sort(bottom_sides.begin(), bottom_sides.end());
313    std::sort(top_sides.begin(), top_sides.end());
314    FindCellSplitLocations(bottom_sides, top_sides, kCellSplitRowThreshold, &cell_y_);
315    cell_y_[0] = min_bottom;
316    cell_y_[cell_y_.size() - 1] = max_top;
317  }
318  void StructuredTable::CalculateMargins() {
319    space_above_ = INT32_MAX;
320    space_below_ = INT32_MAX;
321    space_right_ = INT32_MAX;
322    space_left_ = INT32_MAX;
323    UpdateMargins(text_grid_);
324    UpdateMargins(line_grid_);
325  }
326  void StructuredTable::UpdateMargins(ColPartitionGrid *grid) {
327    int below = FindVerticalMargin(grid, bounding_box_.bottom(), true);
328    space_below_ = std::min(space_below_, below);
329    int above = FindVerticalMargin(grid, bounding_box_.top(), false);
330    space_above_ = std::min(space_above_, above);
331    int left = FindHorizontalMargin(grid, bounding_box_.left(), true);
332    space_left_ = std::min(space_left_, left);
333    int right = FindHorizontalMargin(grid, bounding_box_.right(), false);
334    space_right_ = std::min(space_right_, right);
335  }
336  int StructuredTable::FindVerticalMargin(ColPartitionGrid *grid, int border, bool decrease) const {
337    ColPartitionGridSearch gsearch(grid);
338    gsearch.SetUniqueMode(true);
339    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), border);
340    ColPartition *part = nullptr;
341    while ((part = gsearch.NextVerticalSearch(decrease)) != nullptr) {
342      if (!part->IsTextType() && !part->IsHorizontalLine()) {
343        continue;
344      }
345      int distance =
346          decrease ? border - part->bounding_box().top() : part->bounding_box().bottom() - border;
347      if (distance >= 0) {
348        return distance;
349      }
350    }
351    return INT32_MAX;
352  }
353  int StructuredTable::FindHorizontalMargin(ColPartitionGrid *grid, int border, bool decrease) const {
354    ColPartitionGridSearch gsearch(grid);
355    gsearch.SetUniqueMode(true);
356    gsearch.StartSideSearch(border, bounding_box_.bottom(), bounding_box_.top());
357    ColPartition *part = nullptr;
358    while ((part = gsearch.NextSideSearch(decrease)) != nullptr) {
359      if (!part->IsTextType() && !part->IsVerticalLine()) {
360        continue;
361      }
362      int distance =
363          decrease ? border - part->bounding_box().right() : part->bounding_box().left() - border;
364      if (distance >= 0) {
365        return distance;
366      }
367    }
368    return INT32_MAX;
369  }
370  void StructuredTable::CalculateStats() {
371    const int kMaxCellHeight = 1000;
372    const int kMaxCellWidth = 1000;
373    STATS height_stats(0, kMaxCellHeight);
374    STATS width_stats(0, kMaxCellWidth);
375    for (unsigned i = 0; i < row_count(); ++i) {
376      height_stats.add(row_height(i), column_count());
377    }
378    for (unsigned i = 0; i < column_count(); ++i) {
379      width_stats.add(column_width(i), row_count());
380    }
381    median_cell_height_ = static_cast<int>(height_stats.median() + 0.5);
382    median_cell_width_ = static_cast<int>(width_stats.median() + 0.5);
383  }
384  void StructuredTable::AbsorbNearbyLines() {
385    ColPartitionGridSearch gsearch(line_grid_);
386    gsearch.SetUniqueMode(true);
387    ColPartition *line = nullptr;
388    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), bounding_box_.top());
389    while ((line = gsearch.NextVerticalSearch(false)) != nullptr) {
390      if (!line->IsHorizontalLine()) {
391        break;
392      }
393      TBOX text_search(bounding_box_.left(), bounding_box_.top() + 1, bounding_box_.right(),
394                       line->MidY());
395      if (text_search.height() > median_cell_height_ * 2) {
396        break;
397      }
398      if (CountPartitions(text_search) > 0) {
399        break;
400      }
401      bounding_box_.set_top(line->MidY());
402    }
403    line = nullptr;
404    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), bounding_box_.bottom());
405    while ((line = gsearch.NextVerticalSearch(true)) != nullptr) {
406      if (!line->IsHorizontalLine()) {
407        break;
408      }
409      TBOX text_search(bounding_box_.left(), line->MidY(), bounding_box_.right(),
410                       bounding_box_.bottom() - 1);
411      if (text_search.height() > median_cell_height_ * 2) {
412        break;
413      }
414      if (CountPartitions(text_search) > 0) {
415        break;
416      }
417      bounding_box_.set_bottom(line->MidY());
418    }
419  }
420  void StructuredTable::FindCellSplitLocations(const std::vector<int> &min_list,
421                                               const std::vector<int> &max_list, int max_merged,
422                                               std::vector<int> *locations) {
423    locations->clear();
424    ASSERT_HOST(min_list.size() == max_list.size());
425    if (min_list.empty()) {
426      return;
427    }
428    ASSERT_HOST(min_list.at(0) < max_list.at(0));
429    ASSERT_HOST(min_list.at(min_list.size() - 1) < max_list.at(max_list.size() - 1));
430    locations->push_back(min_list.at(0));
431    unsigned min_index = 0;
432    unsigned max_index = 0;
433    int stacked_partitions = 0;
434    int last_cross_position = INT32_MAX;
435    while (min_index < min_list.size()) {
436      if (min_list[min_index] < max_list[max_index]) {
437        ++stacked_partitions;
438        if (last_cross_position != INT32_MAX && stacked_partitions > max_merged) {
439          int mid = (last_cross_position + min_list[min_index]) / 2;
440          locations->push_back(mid);
441          last_cross_position = INT32_MAX;
442        }
443        ++min_index;
444      } else {
445        --stacked_partitions;
446        if (last_cross_position == INT32_MAX && stacked_partitions <= max_merged) {
447          last_cross_position = max_list[max_index];
448        }
449        ++max_index;
450      }
451    }
452    locations->push_back(max_list.at(max_list.size() - 1));
453  }
454  int StructuredTable::CountVerticalIntersections(int x) {
455    int count = 0;
456    const int kGridSize = text_grid_->gridsize();
457    TBOX vertical_box = bounding_box_;
458    vertical_box.set_left(x - kGridSize);
459    vertical_box.set_right(x + kGridSize);
460    ColPartitionGridSearch gsearch(text_grid_);
461    gsearch.SetUniqueMode(true);
462    gsearch.StartRectSearch(vertical_box);
463    ColPartition *text = nullptr;
464    while ((text = gsearch.NextRectSearch()) != nullptr) {
465      if (!text->IsTextType()) {
466        continue;
467      }
468      const TBOX &box = text->bounding_box();
469      if (box.left() < x && x < box.right()) {
470        ++count;
471      }
472    }
473    return count;
474  }
475  int StructuredTable::CountHorizontalIntersections(int y) {
476    int count = 0;
477    const int kGridSize = text_grid_->gridsize();
478    TBOX horizontal_box = bounding_box_;
479    horizontal_box.set_bottom(y - kGridSize);
480    horizontal_box.set_top(y + kGridSize);
481    ColPartitionGridSearch gsearch(text_grid_);
482    gsearch.SetUniqueMode(true);
483    gsearch.StartRectSearch(horizontal_box);
484    ColPartition *text = nullptr;
485    while ((text = gsearch.NextRectSearch()) != nullptr) {
486      if (!text->IsTextType()) {
487        continue;
488      }
489      const TBOX &box = text->bounding_box();
490      if (box.bottom() < y && y < box.top()) {
491        ++count;
492      }
493    }
494    return count;
495  }
<span onclick='openModal()' class='match'>496  int StructuredTable::CountPartitions(const TBOX &box) {
497    ColPartitionGridSearch gsearch(text_grid_);
498    gsearch.SetUniqueMode(true);
</span>499    gsearch.StartRectSearch(box);
500    int count = 0;
501    ColPartition *text = nullptr;
502    while ((text = gsearch.NextRectSearch()) != nullptr) {
503      if (text->IsTextType()) {
504        ++count;
505      }
506    }
507    return count;
508  }
509  void TableRecognizer::Init() {}
510  void TableRecognizer::set_text_grid(ColPartitionGrid *text_grid) {
511    text_grid_ = text_grid;
512  }
513  void TableRecognizer::set_line_grid(ColPartitionGrid *line_grid) {
514    line_grid_ = line_grid;
515  }
516  void TableRecognizer::set_min_height(int height) {
517    min_height_ = height;
518  }
519  void TableRecognizer::set_min_width(int width) {
520    min_width_ = width;
521  }
522  void TableRecognizer::set_max_text_height(int height) {
523    max_text_height_ = height;
524  }
525  StructuredTable *TableRecognizer::RecognizeTable(const TBOX &guess) {
526    auto *table = new StructuredTable();
527    table->Init();
528    table->set_text_grid(text_grid_);
529    table->set_line_grid(line_grid_);
530    table->set_max_text_height(max_text_height_);
531    if (RecognizeLinedTable(guess, table)) {
532      return table;
533    }
534    if (RecognizeWhitespacedTable(guess, table)) {
535      return table;
536    }
537    delete table;
538    return nullptr;
539  }
540  bool TableRecognizer::RecognizeLinedTable(const TBOX &guess_box, StructuredTable *table) {
541    if (!HasSignificantLines(guess_box)) {
542      return false;
543    }
544    TBOX line_bound = guess_box;
545    if (!FindLinesBoundingBox(&line_bound)) {
546      return false;
547    }
548    table->set_bounding_box(line_bound);
549    return table->FindLinedStructure();
550  }
551  bool TableRecognizer::HasSignificantLines(const TBOX &guess) {
552    ColPartitionGridSearch box_search(line_grid_);
553    box_search.SetUniqueMode(true);
554    box_search.StartRectSearch(guess);
555    ColPartition *line = nullptr;
556    int vertical_count = 0;
557    int horizontal_count = 0;
558    while ((line = box_search.NextRectSearch()) != nullptr) {
559      if (line->IsHorizontalLine()) {
560        ++horizontal_count;
561      }
562      if (line->IsVerticalLine()) {
563        ++vertical_count;
564      }
565    }
566    return vertical_count >= kLinedTableMinVerticalLines &&
567           horizontal_count >= kLinedTableMinHorizontalLines;
568  }
569  bool TableRecognizer::FindLinesBoundingBox(TBOX *bounding_box) {
570    if (!FindLinesBoundingBoxIteration(bounding_box)) {
571      return false;
572    }
573    bool changed = true;
574    while (changed) {
575      changed = false;
576      int old_area = bounding_box->area();
577      bool check = FindLinesBoundingBoxIteration(bounding_box);
578      ASSERT_HOST(check);
579      ASSERT_HOST(bounding_box->area() >= old_area);
580      changed = (bounding_box->area() > old_area);
581    }
582    return true;
583  }
584  bool TableRecognizer::FindLinesBoundingBoxIteration(TBOX *bounding_box) {
585    ColPartitionGridSearch box_search(line_grid_);
586    box_search.SetUniqueMode(true);
587    box_search.StartRectSearch(*bounding_box);
588    ColPartition *line = nullptr;
589    bool first_line = true;
590    while ((line = box_search.NextRectSearch()) != nullptr) {
591      if (line->IsLineType()) {
592        if (first_line) {
593          *bounding_box = line->bounding_box();
594          first_line = false;
595        } else {
596          *bounding_box += line->bounding_box();
597        }
598      }
599    }
600    return !first_line;
601  }
602  bool TableRecognizer::RecognizeWhitespacedTable(const TBOX &guess_box, StructuredTable *table) {
603    TBOX best_box = guess_box; 
604    int best_below = 0;        
605    int best_above = 0;        
606    TBOX adjusted = guess_box; 
607    const int kMidGuessY = (guess_box.bottom() + guess_box.top()) / 2;
608    unsigned best_cols = 0;
609    bool found_good_border = false;
610    int last_bottom = INT32_MAX;
611    int bottom =
612        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY - min_height_ / 2, true);
613    int top =
614        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY + min_height_ / 2, false);
615    adjusted.set_top(top);
616    int previous_below = 0;
617    const int kMaxChances = 10;
618    int chances = kMaxChances;
619    while (bottom != last_bottom) {
620      adjusted.set_bottom(bottom);
621      if (adjusted.height() >= min_height_) {
622        table->set_bounding_box(adjusted);
623        if (table->FindWhitespacedStructure() &&
624            table->column_count() >= best_cols * kRequiredColumns) {
625          if (false && IsWeakTableRow(table, 0)) {
626            --chances;
627          } else {
628            chances = kMaxChances;
629            double max_row_height = kMaxRowSize * table->median_cell_height();
630            if ((table->space_below() * kMarginFactor >= best_below &&
631                 table->space_below() >= previous_below) ||
632                (table->CountFilledCellsInRow(0) > 1 && table->row_height(0) < max_row_height)) {
633              best_box.set_bottom(bottom);
634              best_below = table->space_below();
635              best_cols = std::max(table->column_count(), best_cols);
636              found_good_border = true;
637            }
638          }
639          previous_below = table->space_below();
640        } else {
641          --chances;
642        }
643      }
644      if (chances <= 0) {
645        break;
646      }
647      last_bottom = bottom;
648      bottom = NextHorizontalSplit(guess_box.left(), guess_box.right(), last_bottom, true);
649    }
650    if (!found_good_border) {
651      return false;
652    }
653    found_good_border = false;
654    int last_top = INT32_MIN;
655    top =
656        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY + min_height_ / 2, false);
657    int previous_above = 0;
658    chances = kMaxChances;
659    adjusted.set_bottom(best_box.bottom());
660    while (last_top != top) {
661      adjusted.set_top(top);
662      if (adjusted.height() >= min_height_) {
663        table->set_bounding_box(adjusted);
664        if (table->FindWhitespacedStructure() &&
665            table->column_count() >= best_cols * kRequiredColumns) {
666          int last_row = table->row_count() - 1;
667          if (false && IsWeakTableRow(table, last_row)) {
668            --chances;
669          } else {
670            chances = kMaxChances;
671            double max_row_height = kMaxRowSize * table->median_cell_height();
672            if ((table->space_above() * kMarginFactor >= best_above &&
673                 table->space_above() >= previous_above) ||
674                (table->CountFilledCellsInRow(last_row) > 1 &&
675                 table->row_height(last_row) < max_row_height)) {
676              best_box.set_top(top);
677              best_above = table->space_above();
678              best_cols = std::max(table->column_count(), best_cols);
679              found_good_border = true;
680            }
681          }
682          previous_above = table->space_above();
683        } else {
684          --chances;
685        }
686      }
687      if (chances <= 0) {
688        break;
689      }
690      last_top = top;
691      top = NextHorizontalSplit(guess_box.left(), guess_box.right(), last_top, false);
692    }
693    if (!found_good_border) {
694      return false;
695    }
696    if (best_box.null_box()) {
697      return false;
698    }
699    table->set_bounding_box(best_box);
700    return table->FindWhitespacedStructure();
701  }
702  int TableRecognizer::NextHorizontalSplit(int left, int right, int y, bool top_to_bottom) {
703    ColPartitionGridSearch gsearch(text_grid_);
704    gsearch.SetUniqueMode(true);
705    gsearch.StartVerticalSearch(left, right, y);
706    ColPartition *text = nullptr;
707    int last_y = y;
708    while ((text = gsearch.NextVerticalSearch(top_to_bottom)) != nullptr) {
709      if (!text->IsTextType() || !text->IsHorizontalType()) {
710        continue;
711      }
712      if (text->bounding_box().height() > max_text_height_) {
713        continue;
714      }
715      const TBOX &text_box = text->bounding_box();
716      if (top_to_bottom && (last_y >= y || last_y <= text_box.top())) {
717        last_y = std::min(last_y, static_cast<int>(text_box.bottom()));
718        continue;
719      }
720      if (!top_to_bottom && (last_y <= y || last_y >= text_box.bottom())) {
721        last_y = std::max(last_y, static_cast<int>(text_box.top()));
722        continue;
723      }
724      return last_y;
725    }
726    return last_y;
727  }
728  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hash.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablerecog.cpp</div>
                </div>
                <div class="column column_space"><pre><code>112  int TStrHashF_Md5::GetSecHashCd(const TStr& s) {
113    TMd5Sig sig(s);
114    return sig.GetSecHashCd();
</pre></code></div>
                <div class="column column_space"><pre><code>496  int StructuredTable::CountPartitions(const TBOX &box) {
497    ColPartitionGridSearch gsearch(text_grid_);
498    gsearch.SetUniqueMode(true);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    