
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.901554404145078%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-mergenf.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #include <algorithm>
3  #include <cfloat> 
4  #include <cmath>  
5  #include <cstdio>
6  #include <cstring>
7  #include "cluster.h"
8  #include "clusttool.h"
9  #include "featdefs.h"
10  #include "intproto.h"
11  #include "mergenf.h"
12  #include "ocrfeatures.h"
13  #include "oldlist.h"
14  #include "params.h"
15  #include "protos.h"
16  using namespace tesseract;
17  static double_VAR(training_angle_match_scale, 1.0, "Angle Match Scale ...");
18  static double_VAR(training_similarity_midpoint, 0.0075, "Similarity Midpoint ...");
19  static double_VAR(training_similarity_curl, 2.0, "Similarity Curl ...");
20  static double_VAR(training_tangent_bbox_pad, 0.5, "Tangent bounding box pad ...");
21  static double_VAR(training_orthogonal_bbox_pad, 2.5, "Orthogonal bounding box pad ...");
22  static double_VAR(training_angle_pad, 45.0, "Angle pad ...");
23  float CompareProtos(PROTO_STRUCT *p1, PROTO_STRUCT *p2) {
24    float WorstEvidence = WORST_EVIDENCE;
25    float Evidence;
26    float Angle, Length;
27    Length = std::fabs(p1->Length - p2->Length);
28    if (Length > MAX_LENGTH_MISMATCH) {
29      return (0.0);
30    }
31    auto Feature = new FEATURE_STRUCT(&PicoFeatDesc);
32    Feature->Params[PicoFeatDir] = p1->Angle;
33    Angle = p1->Angle * 2.0 * M_PI;
34    Length = p1->Length / 2.0 - GetPicoFeatureLength() / 2.0;
35    if (Length < 0) {
36      Length = 0;
37    }
38    Feature->Params[PicoFeatX] = p1->X + std::cos(Angle) * Length;
39    Feature->Params[PicoFeatY] = p1->Y + std::sin(Angle) * Length;
40    if (DummyFastMatch(Feature, p2)) {
41      Evidence = SubfeatureEvidence(Feature, p2);
42      if (Evidence < WorstEvidence) {
43        WorstEvidence = Evidence;
44      }
45    } else {
46      delete Feature;
47      return 0.0;
48    }
49    Feature->Params[PicoFeatX] = p1->X - std::cos(Angle) * Length;
50    Feature->Params[PicoFeatY] = p1->Y - std::sin(Angle) * Length;
51    if (DummyFastMatch(Feature, p2)) {
52      Evidence = SubfeatureEvidence(Feature, p2);
53      if (Evidence < WorstEvidence) {
54        WorstEvidence = Evidence;
55      }
56    } else {
57      delete Feature;
58      return 0.0;
59    }
60    delete Feature;
61    return (WorstEvidence);
62  } &bsol;* CompareProtos */
63  void ComputeMergedProto(PROTO_STRUCT *p1, PROTO_STRUCT *p2, float w1, float w2, PROTO_STRUCT *MergedProto) {
64    float TotalWeight;
65    TotalWeight = w1 + w2;
66    w1 /= TotalWeight;
67    w2 /= TotalWeight;
68    MergedProto->X = p1->X * w1 + p2->X * w2;
69    MergedProto->Y = p1->Y * w1 + p2->Y * w2;
70    MergedProto->Length = p1->Length * w1 + p2->Length * w2;
71    MergedProto->Angle = p1->Angle * w1 + p2->Angle * w2;
72    FillABC(MergedProto);
73  } &bsol;* ComputeMergedProto */
74  int FindClosestExistingProto(CLASS_TYPE Class, int NumMerged[], PROTOTYPE *Prototype) {
75    PROTO_STRUCT NewProto;
76    PROTO_STRUCT MergedProto;
77    int Pid;
78    PROTO_STRUCT *Proto;
79    int BestProto;
80    float BestMatch;
81    float Match, OldMatch, NewMatch;
82    MakeNewFromOld(&NewProto, Prototype);
83    BestProto = NO_PROTO;
84    BestMatch = WORST_MATCH_ALLOWED;
85    for (Pid = 0; Pid < Class->NumProtos; Pid++) {
86      Proto = ProtoIn(Class, Pid);
87      ComputeMergedProto(Proto, &NewProto, static_cast<float>(NumMerged[Pid]), 1.0, &MergedProto);
88      OldMatch = CompareProtos(Proto, &MergedProto);
89      NewMatch = CompareProtos(&NewProto, &MergedProto);
90      Match = std::min(OldMatch, NewMatch);
91      if (Match > BestMatch) {
92        BestProto = Pid;
93        BestMatch = Match;
94      }
95    }
96    return BestProto;
97  } &bsol;* FindClosestExistingProto */
98  void MakeNewFromOld(PROTO_STRUCT *New, PROTOTYPE *Old) {
99    New->X = CenterX(Old->Mean);
100    New->Y = CenterY(Old->Mean);
101    New->Length = LengthOf(Old->Mean);
102    New->Angle = OrientationOf(Old->Mean);
103    FillABC(New);
104  } &bsol;* MakeNewFromOld */
105  float SubfeatureEvidence(FEATURE Feature, PROTO_STRUCT *Proto) {
106    float Distance;
107    float Dangle;
108    Dangle = Proto->Angle - Feature->Params[PicoFeatDir];
109    if (Dangle < -0.5) {
110      Dangle += 1.0;
111    }
112    if (Dangle > 0.5) {
113      Dangle -= 1.0;
114    }
115    Dangle *= training_angle_match_scale;
116    Distance =
117        Proto->A * Feature->Params[PicoFeatX] + Proto->B * Feature->Params[PicoFeatY] + Proto->C;
118    return (EvidenceOf(Distance * Distance + Dangle * Dangle));
119  }
120  double EvidenceOf(double Similarity) {
<span onclick='openModal()' class='match'>121    Similarity /= training_similarity_midpoint;
122    if (training_similarity_curl == 3) {
123      Similarity = Similarity * Similarity * Similarity;
124    } else if (training_similarity_curl == 2) {
125      Similarity = Similarity * Similarity;
</span>126    } else {
127      Similarity = pow(Similarity, training_similarity_curl);
128    }
129    return (1.0 / (1.0 + Similarity));
130  }
131  bool DummyFastMatch(FEATURE Feature, PROTO_STRUCT *Proto) {
132    FRECT BoundingBox;
133    float MaxAngleError;
134    float AngleError;
135    MaxAngleError = training_angle_pad / 360.0;
136    AngleError = std::fabs(Proto->Angle - Feature->Params[PicoFeatDir]);
137    if (AngleError > 0.5) {
138      AngleError = 1.0 - AngleError;
139    }
140    if (AngleError > MaxAngleError) {
141      return false;
142    }
143    ComputePaddedBoundingBox(Proto, training_tangent_bbox_pad * GetPicoFeatureLength(),
144                             training_orthogonal_bbox_pad * GetPicoFeatureLength(), &BoundingBox);
145    return PointInside(&BoundingBox, Feature->Params[PicoFeatX], Feature->Params[PicoFeatY]);
146  } &bsol;* DummyFastMatch */
147  void ComputePaddedBoundingBox(PROTO_STRUCT *Proto, float TangentPad, float OrthogonalPad,
148                                FRECT *BoundingBox) {
149    float Length = Proto->Length / 2.0 + TangentPad;
150    float Angle = Proto->Angle * 2.0 * M_PI;
151    float CosOfAngle = fabs(std::cos(Angle));
152    float SinOfAngle = fabs(std::sin(Angle));
153    float Pad = std::max(CosOfAngle * Length, SinOfAngle * OrthogonalPad);
154    BoundingBox->MinX = Proto->X - Pad;
155    BoundingBox->MaxX = Proto->X + Pad;
156    Pad = std::max(SinOfAngle * Length, CosOfAngle * OrthogonalPad);
157    BoundingBox->MinY = Proto->Y - Pad;
158    BoundingBox->MaxY = Proto->Y + Pad;
159  } &bsol;* ComputePaddedBoundingBox */
160  bool PointInside(FRECT *Rectangle, float X, float Y) {
161    return (X >= Rectangle->MinX) && (X <= Rectangle->MaxX) && (Y >= Rectangle->MinY) &&
162           (Y <= Rectangle->MaxY);
163  } &bsol;* PointInside */
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.cpp</h3>
            <pre><code>1  #include <memory>
2  #include <shlwapi.h>
3  #include <cinttypes>
4  #include <windowsx.h>
5  #include "ScintillaEditView.h"
6  #include "Parameters.h"
7  #include "Sorters.h"
8  #include "verifySignedfile.h"
9  #include "ILexer.h"
10  #include "Lexilla.h"
11  using namespace std;
12  bool ScintillaEditView::_SciInit = false;
13  int ScintillaEditView::_refCount = 0;
14  UserDefineDialog ScintillaEditView::_userDefineDlg;
15  const int ScintillaEditView::_SC_MARGE_LINENUMBER = 0;
16  const int ScintillaEditView::_SC_MARGE_SYMBOL = 1;
17  const int ScintillaEditView::_SC_MARGE_CHANGEHISTORY = 2;
18  const int ScintillaEditView::_SC_MARGE_FOLDER = 3;
19  WNDPROC ScintillaEditView::_scintillaDefaultProc = NULL;
20  string ScintillaEditView::_defaultCharList = "";
21  const int ScintillaEditView::_markersArray[][NB_FOLDER_STATE] = {
22    {SC_MARKNUM_FOLDEROPEN, SC_MARKNUM_FOLDER, SC_MARKNUM_FOLDERSUB, SC_MARKNUM_FOLDERTAIL, SC_MARKNUM_FOLDEREND,        SC_MARKNUM_FOLDEROPENMID,     SC_MARKNUM_FOLDERMIDTAIL},
23    {SC_MARK_MINUS,         SC_MARK_PLUS,      SC_MARK_EMPTY,        SC_MARK_EMPTY,         SC_MARK_EMPTY,               SC_MARK_EMPTY,                SC_MARK_EMPTY},
24    {SC_MARK_ARROWDOWN,     SC_MARK_ARROW,     SC_MARK_EMPTY,        SC_MARK_EMPTY,         SC_MARK_EMPTY,               SC_MARK_EMPTY,                SC_MARK_EMPTY},
25    {SC_MARK_CIRCLEMINUS,   SC_MARK_CIRCLEPLUS,SC_MARK_VLINE,        SC_MARK_LCORNERCURVE,  SC_MARK_CIRCLEPLUSCONNECTED, SC_MARK_CIRCLEMINUSCONNECTED, SC_MARK_TCORNERCURVE},
26    {SC_MARK_BOXMINUS,      SC_MARK_BOXPLUS,   SC_MARK_VLINE,        SC_MARK_LCORNER,       SC_MARK_BOXPLUSCONNECTED,    SC_MARK_BOXMINUSCONNECTED,    SC_MARK_TCORNER}
27  };
28  LanguageNameInfo ScintillaEditView::_langNameInfoArray[L_EXTERNAL + 1] = {
29  	{TEXT("normal"),		TEXT("Normal text"),		TEXT("Normal text file"),								L_TEXT,			"null"},
30  	{TEXT("php"),			TEXT("PHP"),				TEXT("PHP Hypertext Preprocessor file"),				L_PHP,			"phpscript"},
31  	{TEXT("c"),				TEXT("C"),					TEXT("C source file"),									L_C,			"cpp"},
32  	{TEXT("cpp"),			TEXT("C++"),				TEXT("C++ source file"),								L_CPP,			"cpp"},
33  	{TEXT("cs"),			TEXT("C#"),					TEXT("C# source file"),									L_CS,			"cpp"},
34  	{TEXT("objc"),			TEXT("Objective-C"),		TEXT("Objective-C source file"),						L_OBJC,			"objc"},
35  	{TEXT("java"),			TEXT("Java"),				TEXT("Java source file"),								L_JAVA,			"cpp"},
36  	{TEXT("rc"),			TEXT("RC"),					TEXT("Windows Resource file"),							L_RC,			"cpp"},
37  	{TEXT("html"),			TEXT("HTML"),				TEXT("Hyper Text Markup Language file"),				L_HTML,			"hypertext"},
38  	{TEXT("xml"),			TEXT("XML"),				TEXT("eXtensible Markup Language file"),				L_XML,			"xml"},
39  	{TEXT("makefile"),		TEXT("Makefile"),			TEXT("Makefile"),										L_MAKEFILE,		"makefile"},
40  	{TEXT("pascal"),		TEXT("Pascal"),				TEXT("Pascal source file"),								L_PASCAL,		"pascal"},
41  	{TEXT("batch"),			TEXT("Batch"),				TEXT("Batch file"),										L_BATCH,		"batch"},
42  	{TEXT("ini"),			TEXT("ini"),				TEXT("MS ini file"),									L_INI,			"props"},
43  	{TEXT("nfo"),			TEXT("NFO"),				TEXT("MSDOS Style/ASCII Art"),							L_ASCII,		"null"},
44  	{TEXT("udf"),			TEXT("udf"),				TEXT("User Defined language file"),						L_USER,			"user"},
45  	{TEXT("asp"),			TEXT("ASP"),				TEXT("Active Server Pages script file"),				L_ASP,			"hypertext"},
46  	{TEXT("sql"),			TEXT("SQL"),				TEXT("Structured Query Language file"),					L_SQL,			"sql"},
47  	{TEXT("vb"),			TEXT("Visual Basic"),		TEXT("Visual Basic file"),								L_VB,			"vb"},
48  	{TEXT("javascript"),	TEXT("JavaScript"),			TEXT("JavaScript file"),								L_JS,			"cpp"},
49  	{TEXT("css"),			TEXT("CSS"),				TEXT("Cascade Style Sheets File"),						L_CSS,			"css"},
50  	{TEXT("perl"),			TEXT("Perl"),				TEXT("Perl source file"),								L_PERL,			"perl"},
51  	{TEXT("python"),		TEXT("Python"),				TEXT("Python file"),									L_PYTHON,		"python"},
52  	{TEXT("lua"),			TEXT("Lua"),				TEXT("Lua source File"),								L_LUA,			"lua"},
53  	{TEXT("tex"),			TEXT("TeX"),				TEXT("TeX file"),										L_TEX,			"tex"},
54  	{TEXT("fortran"),		TEXT("Fortran free form"),	TEXT("Fortran free form source file"),					L_FORTRAN,		"fortran"},
55  	{TEXT("bash"),			TEXT("Shell"),				TEXT("Unix script file"),								L_BASH,			"bash"},
56  	{TEXT("actionscript"),	TEXT("ActionScript"),		TEXT("Flash ActionScript file"),						L_FLASH,		"cpp"},
57  	{TEXT("nsis"),			TEXT("NSIS"),				TEXT("Nullsoft Scriptable Install System script file"),	L_NSIS,			"nsis"},
58  	{TEXT("tcl"),			TEXT("TCL"),				TEXT("Tool Command Language file"),						L_TCL,			"tcl"},
59  	{TEXT("lisp"),			TEXT("Lisp"),				TEXT("List Processing language file"),					L_LISP,			"lisp"},
60  	{TEXT("scheme"),		TEXT("Scheme"),				TEXT("Scheme file"),									L_SCHEME,		"lisp"},
61  	{TEXT("asm"),			TEXT("Assembly"),			TEXT("Assembly language source file"),					L_ASM,			"asm"},
62  	{TEXT("diff"),			TEXT("Diff"),				TEXT("Diff file"),										L_DIFF,			"diff"},
63  	{TEXT("props"),			TEXT("Properties file"),	TEXT("Properties file"),								L_PROPS,		"props"},
64  	{TEXT("postscript"),	TEXT("PostScript"),			TEXT("PostScript file"),								L_PS,			"ps"},
65  	{TEXT("ruby"),			TEXT("Ruby"),				TEXT("Ruby file"),										L_RUBY,			"ruby"},
66  	{TEXT("smalltalk"),		TEXT("Smalltalk"),			TEXT("Smalltalk file"),									L_SMALLTALK,	"smalltalk"},
67  	{TEXT("vhdl"),			TEXT("VHDL"),				TEXT("VHSIC Hardware Description Language file"),		L_VHDL,			"vhdl"},
68  	{TEXT("kix"),			TEXT("KiXtart"),			TEXT("KiXtart file"),									L_KIX,			"kix"},
69  	{TEXT("autoit"),		TEXT("AutoIt"),				TEXT("AutoIt"),											L_AU3,			"au3"},
70  	{TEXT("caml"),			TEXT("CAML"),				TEXT("Categorical Abstract Machine Language"),			L_CAML,			"caml"},
71  	{TEXT("ada"),			TEXT("Ada"),				TEXT("Ada file"),										L_ADA,			"ada"},
72  	{TEXT("verilog"),		TEXT("Verilog"),			TEXT("Verilog file"),									L_VERILOG,		"verilog"},
73  	{TEXT("matlab"),		TEXT("MATLAB"),				TEXT("MATrix LABoratory"),								L_MATLAB,		"matlab"},
74  	{TEXT("haskell"),		TEXT("Haskell"),			TEXT("Haskell"),										L_HASKELL,		"haskell"},
75  	{TEXT("inno"),			TEXT("Inno Setup"),			TEXT("Inno Setup script"),								L_INNO,			"inno"},
76  	{TEXT("searchResult"),	TEXT("Internal Search"),	TEXT("Internal Search"),								L_SEARCHRESULT,	"searchResult"},
77  	{TEXT("cmake"),			TEXT("CMake"),				TEXT("CMake file"),										L_CMAKE,		"cmake"},
78  	{TEXT("yaml"),			TEXT("YAML"),				TEXT("YAML Ain't Markup Language"),						L_YAML,			"yaml"},
79  	{TEXT("cobol"),			TEXT("COBOL"),				TEXT("COmmon Business Oriented Language"),				L_COBOL,		"COBOL"},
80  	{TEXT("gui4cli"),		TEXT("Gui4Cli"),			TEXT("Gui4Cli file"),									L_GUI4CLI,		"gui4cli"},
81  	{TEXT("d"),				TEXT("D"),					TEXT("D programming language"),							L_D,			"d"},
82  	{TEXT("powershell"),	TEXT("PowerShell"),			TEXT("Windows PowerShell"),								L_POWERSHELL,	"powershell"},
83  	{TEXT("r"),				TEXT("R"),					TEXT("R programming language"),							L_R,			"r"},
84  	{TEXT("jsp"),			TEXT("JSP"),				TEXT("JavaServer Pages script file"),					L_JSP,			"hypertext"},
85  	{TEXT("coffeescript"),	TEXT("CoffeeScript"),		TEXT("CoffeeScript file"),								L_COFFEESCRIPT,	"coffeescript"},
86  	{TEXT("json"),			TEXT("json"),				TEXT("JSON file"),										L_JSON,			"json"},
87  	{TEXT("javascript.js"), TEXT("JavaScript"),			TEXT("JavaScript file"),								L_JAVASCRIPT,	"cpp"},
88  	{TEXT("fortran77"),		TEXT("Fortran fixed form"),	TEXT("Fortran fixed form source file"),					L_FORTRAN_77,	"f77"},
89  	{TEXT("baanc"),			TEXT("BaanC"),				TEXT("BaanC File"),										L_BAANC,		"baan"},
90  	{TEXT("srec"),			TEXT("S-Record"),			TEXT("Motorola S-Record binary data"),					L_SREC,			"srec"},
91  	{TEXT("ihex"),			TEXT("Intel HEX"),			TEXT("Intel HEX binary data"),							L_IHEX,			"ihex"},
92  	{TEXT("tehex"),			TEXT("Tektronix extended HEX"),	TEXT("Tektronix extended HEX binary data"),			L_TEHEX,		"tehex"},
93  	{TEXT("swift"),			TEXT("Swift"),              TEXT("Swift file"),										L_SWIFT,		"cpp"},
94  	{TEXT("asn1"),			TEXT("ASN.1"),				TEXT("Abstract Syntax Notation One file"),				L_ASN1,			"asn1"},
95  	{TEXT("avs"),			TEXT("AviSynth"),			TEXT("AviSynth scripts files"),							L_AVS,			"avs"},
96  	{TEXT("blitzbasic"),	TEXT("BlitzBasic"),			TEXT("BlitzBasic file"),								L_BLITZBASIC,	"blitzbasic"},
97  	{TEXT("purebasic"),		TEXT("PureBasic"),			TEXT("PureBasic file"),									L_PUREBASIC,	"purebasic"},
98  	{TEXT("freebasic"),		TEXT("FreeBasic"),			TEXT("FreeBasic file"),									L_FREEBASIC,	"freebasic"},
99  	{TEXT("csound"),		TEXT("Csound"),				TEXT("Csound file"),									L_CSOUND,		"csound"},
100  	{TEXT("erlang"),		TEXT("Erlang"),				TEXT("Erlang file"),									L_ERLANG,		"erlang"},
101  	{TEXT("escript"),		TEXT("ESCRIPT"),			TEXT("ESCRIPT file"),									L_ESCRIPT,		"escript"},
102  	{TEXT("forth"),			TEXT("Forth"),				TEXT("Forth file"),										L_FORTH,		"forth"},
103  	{TEXT("latex"),			TEXT("LaTeX"),				TEXT("LaTeX file"),										L_LATEX,		"latex"},
104  	{TEXT("mmixal"),		TEXT("MMIXAL"),				TEXT("MMIXAL file"),									L_MMIXAL,		"mmixal"},
105  	{TEXT("nim"),			TEXT("Nim"),				TEXT("Nim file"),										L_NIM,			"nimrod"},
106  	{TEXT("nncrontab"),		TEXT("Nncrontab"),			TEXT("extended crontab file"),							L_NNCRONTAB,	"nncrontab"},
107  	{TEXT("oscript"),		TEXT("OScript"),			TEXT("OScript source file"),							L_OSCRIPT,		"oscript"},
108  	{TEXT("rebol"),			TEXT("REBOL"),				TEXT("REBOL file"),										L_REBOL,		"rebol"},
109  	{TEXT("registry"),		TEXT("registry"),			TEXT("registry file"),									L_REGISTRY,		"registry"},
110  	{TEXT("rust"),			TEXT("Rust"),				TEXT("Rust file"),										L_RUST,			"rust"},
111  	{TEXT("spice"),			TEXT("Spice"),				TEXT("spice file"),										L_SPICE,		"spice"},
112  	{TEXT("txt2tags"),		TEXT("txt2tags"),			TEXT("txt2tags file"),									L_TXT2TAGS,		"txt2tags"},
113  	{TEXT("visualprolog"),	TEXT("Visual Prolog"),		TEXT("Visual Prolog file"),								L_VISUALPROLOG,	"visualprolog"},
114  	{TEXT("typescript"),	TEXT("TypeScript"),			TEXT("TypeScript file"),								L_TYPESCRIPT,	"cpp"},
115  	{TEXT("json5"),			TEXT("json5"),				TEXT("JSON5 file"),										L_JSON5,		"json"},
116  	{TEXT("mssql"),			TEXT("mssql"),				TEXT("Microsoft Transact-SQL (SQL Server) file"),		L_MSSQL,		"mssql"},
117  	{TEXT("gdscript"),		TEXT("GDScript"),			TEXT("GDScript file"),									L_GDSCRIPT,		"gdscript"},
118  	{TEXT("hollywood"),		TEXT("Hollywood"),			TEXT("Hollywood script"),								L_HOLLYWOOD,	"hollywood"},
119  	{TEXT("ext"),			TEXT("External"),			TEXT("External"),										L_EXTERNAL,		"null"}
120  };
121  int getNbDigits(int aNum, int base)
122  {
123  	int nbChiffre = 1;
124  	int diviseur = base;
125  	for (;;)
126  	{
127  		int result = aNum / diviseur;
128  		if (!result)
129  			break;
130  		else
131  		{
132  			diviseur *= base;
133  			++nbChiffre;
134  		}
135  	}
136  	if ((base == 16) && (nbChiffre % 2 != 0))
137  		nbChiffre += 1;
138  	return nbChiffre;
139  }
140  void ScintillaEditView::init(HINSTANCE hInst, HWND hPere)
141  {
142  	if (!_SciInit)
143  	{
144  		if (!Scintilla_RegisterClasses(hInst))
145  		{
146  			throw std::runtime_error("ScintillaEditView::init : SCINTILLA ERROR - Scintilla_RegisterClasses failed");
147  		}
148  		_SciInit = true;
149  	}
150  	Window::init(hInst, hPere);
151  	_hSelf = ::CreateWindowEx(
152  					0,\
153  					TEXT("Scintilla"),\
154  					TEXT("Notepad++"),\
155  					WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_CLIPCHILDREN | WS_EX_RTLREADING,\
156  					0, 0, 100, 100,\
157  					_hParent,\
158  					NULL,\
159  					_hInst,\
160  					NULL);
161  	if (!_hSelf)
162  	{
163  		throw std::runtime_error("ScintillaEditView::init : CreateWindowEx() function return null");
164  	}
165  	NppDarkMode::setDarkScrollBar(_hSelf);
166  	_pScintillaFunc = (SCINTILLA_FUNC)::SendMessage(_hSelf, SCI_GETDIRECTFUNCTION, 0, 0);
167  	_pScintillaPtr = (SCINTILLA_PTR)::SendMessage(_hSelf, SCI_GETDIRECTPOINTER, 0, 0);
168  	_userDefineDlg.init(_hInst, _hParent, this);
169  	if (!_pScintillaFunc)
170  	{
171  		throw std::runtime_error("ScintillaEditView::init : SCI_GETDIRECTFUNCTION message failed");
172  	}
173  	if (!_pScintillaPtr)
174  	{
175  		throw std::runtime_error("ScintillaEditView::init : SCI_GETDIRECTPOINTER message failed");
176  	}
177  	execute(SCI_SETMARGINMASKN, _SC_MARGE_FOLDER, SC_MASK_FOLDERS);
178  	showMargin(_SC_MARGE_FOLDER, true);
179  	execute(SCI_SETMARGINMASKN, _SC_MARGE_SYMBOL, (1 << MARK_BOOKMARK) | (1 << MARK_HIDELINESBEGIN) | (1 << MARK_HIDELINESEND));
180  	execute(SCI_SETMARGINMASKN, _SC_MARGE_CHANGEHISTORY, (1 << SC_MARKNUM_HISTORY_REVERTED_TO_ORIGIN) | (1 << SC_MARKNUM_HISTORY_SAVED) | (1 << SC_MARKNUM_HISTORY_MODIFIED) | (1 << SC_MARKNUM_HISTORY_REVERTED_TO_MODIFIED));
181  	COLORREF modifiedColor = RGB(255, 128, 0);
182  	execute(SCI_MARKERSETBACK, SC_MARKNUM_HISTORY_MODIFIED, modifiedColor);
183  	execute(SCI_MARKERSETALPHA, MARK_BOOKMARK, 70);
184  	const COLORREF hiddenLinesGreen = RGB(0x77, 0xCC, 0x77);
185  	long hiddenLinesGreenWithAlpha = hiddenLinesGreen | 0xFF000000;
186  	execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_HIDDEN_LINE, hiddenLinesGreenWithAlpha);
187  	if (NppParameters::getInstance()._dpiManager.scaleX(100) >= 150)
188  	{
189  		execute(SCI_RGBAIMAGESETWIDTH, 18);
190  		execute(SCI_RGBAIMAGESETHEIGHT, 18);
191  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_BOOKMARK, reinterpret_cast<LPARAM>(bookmark18));
192  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESBEGIN, reinterpret_cast<LPARAM>(hidelines_begin18));
193  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESEND, reinterpret_cast<LPARAM>(hidelines_end18));
194  	}
195  	else
196  	{
197  		execute(SCI_RGBAIMAGESETWIDTH, 14);
198  		execute(SCI_RGBAIMAGESETHEIGHT, 14);
199  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_BOOKMARK, reinterpret_cast<LPARAM>(bookmark14));
200  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESBEGIN, reinterpret_cast<LPARAM>(hidelines_begin14));
201  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESEND, reinterpret_cast<LPARAM>(hidelines_end14));
202  	}
203      execute(SCI_SETMARGINSENSITIVEN, _SC_MARGE_FOLDER, true); 
204      execute(SCI_SETMARGINSENSITIVEN, _SC_MARGE_SYMBOL, true); 
205      execute(SCI_SETFOLDFLAGS, SC_FOLDFLAG_LINEAFTER_CONTRACTED);
206  	execute(SCI_SETSCROLLWIDTHTRACKING, true);
207  	execute(SCI_SETSCROLLWIDTH, 1);	
208  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_SMART, INDIC_ROUNDBOX);
209  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE, INDIC_ROUNDBOX);
210  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_INC, INDIC_ROUNDBOX);
211  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_TAGMATCH, INDIC_ROUNDBOX);
212  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_TAGATTR, INDIC_ROUNDBOX);
213  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT1, INDIC_ROUNDBOX);
214  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT2, INDIC_ROUNDBOX);
215  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT3, INDIC_ROUNDBOX);
216  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT4, INDIC_ROUNDBOX);
217  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT5, INDIC_ROUNDBOX);
218  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_SMART, 100);
219  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE, 100);
220  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_INC, 100);
221  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_TAGMATCH, 100);
222  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_TAGATTR, 100);
223  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT1, 100);
224  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT2, 100);
225  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT3, 100);
226  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT4, 100);
227  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT5, 100);
228  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_SMART, true);
229  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE, true);
230  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_INC, true);
231  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_TAGMATCH, true);
232  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_TAGATTR, true);
233  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT1, true);
234  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT2, true);
235  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT3, true);
236  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT4, true);
237  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT5, true);
238  	if ((NppParameters::getInstance()).getNppGUI()._writeTechnologyEngine == directWriteTechnology)
239  		execute(SCI_SETTECHNOLOGY, SC_TECHNOLOGY_DIRECTWRITE);
240  	_codepage = ::GetACP();
241  	::SetWindowLongPtr(_hSelf, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
242  	_callWindowProc = CallWindowProc;
243  	_scintillaDefaultProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hSelf, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(scintillaStatic_Proc)));
244  	if (_defaultCharList.empty())
245  	{
246  		auto defaultCharListLen = execute(SCI_GETWORDCHARS);
247  		char *defaultCharList = new char[defaultCharListLen + 1];
248  		execute(SCI_GETWORDCHARS, 0, reinterpret_cast<LPARAM>(defaultCharList));
249  		defaultCharList[defaultCharListLen] = '\0';
250  		_defaultCharList = defaultCharList;
251  		delete[] defaultCharList;
252  	}
253  	attachDefaultDoc();
254  }
255  LRESULT CALLBACK ScintillaEditView::scintillaStatic_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
256  {
257  	ScintillaEditView *pScint = (ScintillaEditView *)(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
258  	if (Message == WM_MOUSEWHEEL || Message == WM_MOUSEHWHEEL)
259  	{
260  		POINT pt{};
261  		POINTS pts = MAKEPOINTS(lParam);
262  		POINTSTOPOINT(pt, pts);
263  		HWND hwndOnMouse = WindowFromPoint(pt);
264  		char synapticsHack[26]{};
265  		GetClassNameA(hwndOnMouse, (LPSTR)&synapticsHack, 26);
266  		bool isSynpnatic = std::string(synapticsHack) == "SynTrackCursorWindowClass";
267  		bool makeTouchPadCompetible = ((NppParameters::getInstance()).getSVP())._disableAdvancedScrolling;
268  		if (pScint && (isSynpnatic || makeTouchPadCompetible))
269  			return (pScint->scintillaNew_Proc(hwnd, Message, wParam, lParam));
270  		ScintillaEditView *pScintillaOnMouse = (ScintillaEditView *)(::GetWindowLongPtr(hwndOnMouse, GWLP_USERDATA));
271  		if (pScintillaOnMouse != pScint)
272  			return ::SendMessage(hwndOnMouse, Message, wParam, lParam);
273  	}
274  	if (pScint)
275  		return (pScint->scintillaNew_Proc(hwnd, Message, wParam, lParam));
276  	else
277  		return ::DefWindowProc(hwnd, Message, wParam, lParam);
278  }
279  LRESULT ScintillaEditView::scintillaNew_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
280  {
281  	switch (Message)
282  	{
283  		case NPPM_INTERNAL_REFRESHDARKMODE:
284  		{
285  			NppDarkMode::setDarkScrollBar(_hSelf);
286  			return TRUE;
287  		}
288  		case WM_MOUSEHWHEEL :
289  		{
290  			::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) > 0)?SB_LINERIGHT:SB_LINELEFT, 0);
291  			return TRUE;
292  		}
293  		case WM_MOUSEWHEEL :
294  		{
295  			if (LOWORD(wParam) & MK_RBUTTON)
296  			{
297  				::SendMessage(_hParent, Message, wParam, lParam);
298  				return TRUE;
299  			}
300  			if (LOWORD(wParam) & MK_SHIFT)
301  			{
302  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) < 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
303  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) < 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
304  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) < 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
305  				return TRUE;
306  			}
307  			LRESULT scrollResult = ::CallWindowProc(_scintillaDefaultProc, hwnd, Message, wParam, lParam);
308  			return scrollResult;
309  		}
310  		case WM_IME_REQUEST:
311  		{
312  			if (wParam == IMR_RECONVERTSTRING)
313  			{
314  				intptr_t					textLength = 0;
315  				intptr_t					selectSize = 0;
316  				char				smallTextBuffer[128] = { '\0' };
317  				char			  *	selectedStr = smallTextBuffer;
318  				RECONVERTSTRING   *	reconvert = (RECONVERTSTRING *)lParam;
319  				if (execute(SCI_SELECTIONISRECTANGLE, 0, 0))
320  					return 0;
321  				size_t cp = execute(SCI_GETCODEPAGE);
322  				UINT codepage = static_cast<UINT>(cp);
323  				Sci_CharacterRangeFull range = getSelection();
324  				if (range.cpMax == range.cpMin)
325  				{
326  					expandWordSelection();
327  					range = getSelection();
328  				}
329  				selectSize = range.cpMax - range.cpMin;
330  				if (selectSize == 0)
331  					return 0;
332  				if (static_cast<size_t>(selectSize + 1) > sizeof(smallTextBuffer))
333  					selectedStr = new char[selectSize + 1];
334  				getText(selectedStr, range.cpMin, range.cpMax);
335  				if (reconvert == NULL)
336  				{
337  					textLength = sizeof(WCHAR) * ::MultiByteToWideChar(codepage, 0, selectedStr, (int)selectSize, NULL, 0);
338  				}
339  				else
340  				{
341  					textLength = ::MultiByteToWideChar(	codepage, 0,
342  														selectedStr, (int)selectSize,
343  														(LPWSTR)((LPSTR)reconvert + sizeof(RECONVERTSTRING)),
344  														static_cast<int>(reconvert->dwSize - sizeof(RECONVERTSTRING)));
345  					reconvert->dwVersion		 = 0;
346  					reconvert->dwStrLen			 = static_cast<DWORD>(textLength);
347  					reconvert->dwStrOffset		 = sizeof(RECONVERTSTRING);
348  					reconvert->dwCompStrLen		 = static_cast<DWORD>(textLength);
349  					reconvert->dwCompStrOffset	 = 0;
350  					reconvert->dwTargetStrLen	 = reconvert->dwCompStrLen;
351  					reconvert->dwTargetStrOffset = reconvert->dwCompStrOffset;
352  					textLength *= sizeof(WCHAR);
353  				}
354  				if (selectedStr != smallTextBuffer)
355  					delete [] selectedStr;
356  				return sizeof(RECONVERTSTRING) + textLength;
357  			}
358  			break;
359  		}
360  		case WM_KEYUP :
361  		{
362  			if (wParam == VK_PRIOR || wParam == VK_NEXT)
363  			{
364  				SCNotification notification = {};
365  				notification.nmhdr.code = SCN_PAINTED;
366  				notification.nmhdr.hwndFrom = _hSelf;
367  				notification.nmhdr.idFrom = ::GetDlgCtrlID(_hSelf);
368  				::SendMessage(_hParent, WM_NOTIFY, LINKTRIGGERED, reinterpret_cast<LPARAM>(&notification));
369  			}
370  			break;
371  		}
372  		case WM_VSCROLL :
373  		{
374  			break;
375  		}
376  		case WM_RBUTTONDOWN:
377  		{
378  			bool rightClickKeepsSelection = ((NppParameters::getInstance()).getSVP())._rightClickKeepsSelection;
379  			if (rightClickKeepsSelection)
380  			{
381  				size_t clickX = GET_X_LPARAM(lParam);
382  				size_t marginX = execute(SCI_POINTXFROMPOSITION, 0, 0);
383  				if (clickX >= marginX)
384  				{
385  					return TRUE;
386  				}
387  			}
388  			break;
389  		}
390  	}
391  	return _callWindowProc(_scintillaDefaultProc, hwnd, Message, wParam, lParam);
392  }
393  #define DEFAULT_FONT_NAME "Courier New"
394  void ScintillaEditView::setSpecialStyle(const Style & styleToSet)
395  {
396  	int styleID = styleToSet._styleID;
397  	if ( styleToSet._colorStyle & COLORSTYLE_FOREGROUND )
398  	    execute(SCI_STYLESETFORE, styleID, styleToSet._fgColor);
399      if ( styleToSet._colorStyle & COLORSTYLE_BACKGROUND )
400  	    execute(SCI_STYLESETBACK, styleID, styleToSet._bgColor);
401      if (!styleToSet._fontName.empty())
402  	{
403  		if (!NppParameters::getInstance().isInFontList(styleToSet._fontName))
404  		{
405  			execute(SCI_STYLESETFONT, styleID, reinterpret_cast<LPARAM>(DEFAULT_FONT_NAME));
406  		}
407  		else
408  		{
409  			std::string fontNameA = wstring2string(styleToSet._fontName, CP_UTF8);
410  			execute(SCI_STYLESETFONT, styleID, reinterpret_cast<LPARAM>(fontNameA.c_str()));
411  		}
412  	}
413  	int fontStyle = styleToSet._fontStyle;
414      if (fontStyle != STYLE_NOT_USED)
415      {
416          execute(SCI_STYLESETBOLD,		styleID, fontStyle & FONTSTYLE_BOLD);
417          execute(SCI_STYLESETITALIC,		styleID, fontStyle & FONTSTYLE_ITALIC);
418          execute(SCI_STYLESETUNDERLINE,	styleID, fontStyle & FONTSTYLE_UNDERLINE);
419      }
420  	if (styleToSet._fontSize > 0)
421  		execute(SCI_STYLESETSIZE, styleID, styleToSet._fontSize);
422  }
423  void ScintillaEditView::setHotspotStyle(const Style& styleToSet)
424  {
425  	StyleMap* styleMap;
426  	if ( _hotspotStyles.find(_currentBuffer) == _hotspotStyles.end() )
427  	{
428  		_hotspotStyles[_currentBuffer] = new StyleMap;
429  	}
430  	styleMap = _hotspotStyles[_currentBuffer];
431  	(*styleMap)[styleToSet._styleID] = styleToSet;
432  	setStyle(styleToSet);
433  }
434  void ScintillaEditView::setStyle(Style styleToSet)
435  {
436  	GlobalOverride & go = NppParameters::getInstance().getGlobalOverrideStyle();
437  	if (go.isEnable())
438  	{
439  		const Style * pStyle = NppParameters::getInstance().getMiscStylerArray().findByName(TEXT("Global override"));
440  		if (pStyle)
441  		{
442  			if (go.enableFg)
443  			{
444  				if (pStyle->_colorStyle & COLORSTYLE_FOREGROUND)
445  				{
446  					styleToSet._colorStyle |= COLORSTYLE_FOREGROUND;
447  					styleToSet._fgColor = pStyle->_fgColor;
448  				}
449  				else
450  				{
451  					if (styleToSet._styleID == STYLE_DEFAULT) 
452  						styleToSet._colorStyle |= COLORSTYLE_FOREGROUND;
453  					else
454  						styleToSet._colorStyle &= ~COLORSTYLE_FOREGROUND;
455  				}
456  			}
457  			if (go.enableBg)
458  			{
459  				if (pStyle->_colorStyle & COLORSTYLE_BACKGROUND)
460  				{
461  					styleToSet._colorStyle |= COLORSTYLE_BACKGROUND;
462  					styleToSet._bgColor = pStyle->_bgColor;
463  				}
464  				else
465  				{
466  					if (styleToSet._styleID == STYLE_DEFAULT) 	
467  						styleToSet._colorStyle |= COLORSTYLE_BACKGROUND;
468  					else
469  						styleToSet._colorStyle &= ~COLORSTYLE_BACKGROUND;
470  				}
471  			}
472  			if (go.enableFont && !pStyle->_fontName.empty())
473  				styleToSet._fontName = pStyle->_fontName;
474  			if (go.enableFontSize && (pStyle->_fontSize > 0))
475  				styleToSet._fontSize = pStyle->_fontSize;
476  			if (pStyle->_fontStyle != STYLE_NOT_USED)
477  			{
478  				if (go.enableBold)
479  				{
480  					if (pStyle->_fontStyle & FONTSTYLE_BOLD)
481  						styleToSet._fontStyle |= FONTSTYLE_BOLD;
482  					else
483  						styleToSet._fontStyle &= ~FONTSTYLE_BOLD;
484  				}
485  				if (go.enableItalic)
486  				{
487  					if (pStyle->_fontStyle & FONTSTYLE_ITALIC)
488  						styleToSet._fontStyle |= FONTSTYLE_ITALIC;
489  					else
490  						styleToSet._fontStyle &= ~FONTSTYLE_ITALIC;
491  				}
492  				if (go.enableUnderLine)
493  				{
494  					if (pStyle->_fontStyle & FONTSTYLE_UNDERLINE)
495  						styleToSet._fontStyle |= FONTSTYLE_UNDERLINE;
496  					else
497  						styleToSet._fontStyle &= ~FONTSTYLE_UNDERLINE;
498  				}
499  			}
500  		}
501  	}
502  	setSpecialStyle(styleToSet);
503  }
504  void ScintillaEditView::setXmlLexer(LangType type)
505  {
506  	if (type == L_XML)
507  	{
508  		setLexerFromLangID(L_XML);
509  		for (int i = 0 ; i < 4 ; ++i)
510  			execute(SCI_SETKEYWORDS, i, reinterpret_cast<LPARAM>(TEXT("")));
511          makeStyle(type);
512  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.xml.allow.scripts"), reinterpret_cast<LPARAM>("0"));
513  	}
514  	else if ((type == L_HTML) || (type == L_PHP) || (type == L_ASP) || (type == L_JSP))
515  	{
516  		setLexerFromLangID(L_HTML);
517  		const TCHAR *htmlKeyWords_generic = NppParameters::getInstance().getWordList(L_HTML, LANG_INDEX_INSTR);
518  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
519  		const char *htmlKeyWords = wmc.wchar2char(htmlKeyWords_generic, CP_ACP);
520  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(htmlKeyWords?htmlKeyWords:""));
521  		makeStyle(L_HTML);
522          setEmbeddedJSLexer();
523          setEmbeddedPhpLexer();
524  		setEmbeddedAspLexer();
525  	}
526  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
527  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
528  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.html"), reinterpret_cast<LPARAM>("1"));
529  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.hypertext.comment"), reinterpret_cast<LPARAM>("1"));
530  }
531  void ScintillaEditView::setEmbeddedJSLexer()
532  {
533  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
534  	makeStyle(L_JS, pKwArray);
535  	basic_string<char> keywordList("");
536  	if (pKwArray[LANG_INDEX_INSTR])
537  	{
538  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
539  		keywordList = wstring2string(kwlW, CP_ACP);
540  	}
541  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, L_JS, LANG_INDEX_INSTR)));
542  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_DEFAULT, true);
543  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_COMMENT, true);
544  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_COMMENTDOC, true);
545  }
546  void ScintillaEditView::setJsonLexer(bool isJson5)
547  {
548  	LangType j = isJson5 ? L_JSON5 : L_JSON;
549  	setLexerFromLangID(j);
550  	const TCHAR *pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
551  	makeStyle(L_JSON, pKwArray);
552  	string keywordList;
553  	string keywordList2;
554  	if (pKwArray[LANG_INDEX_INSTR])
555  	{
556  		wstring kwlW = pKwArray[LANG_INDEX_INSTR];
557  		keywordList = wstring2string(kwlW, CP_ACP);
558  	}
559  	if (pKwArray[LANG_INDEX_INSTR2])
560  	{
561  		wstring kwlW = pKwArray[LANG_INDEX_INSTR2];
562  		keywordList2 = wstring2string(kwlW, CP_ACP);
563  	}
564  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, j, LANG_INDEX_INSTR)));
565  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList2, j, LANG_INDEX_INSTR2)));
566  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
567  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
568  	if (j == L_JSON5)
569  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.json.allow.comments"), reinterpret_cast<LPARAM>("1"));
570  }
571  void ScintillaEditView::setEmbeddedPhpLexer()
572  {
573  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
574  	makeStyle(L_PHP, pKwArray);
575  	basic_string<char> keywordList("");
576  	if (pKwArray[LANG_INDEX_INSTR])
577  	{
578  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
579  		keywordList = wstring2string(kwlW, CP_ACP);
580  	}
581  	execute(SCI_SETKEYWORDS, 4, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, L_PHP, LANG_INDEX_INSTR)));
582  	execute(SCI_STYLESETEOLFILLED, SCE_HPHP_DEFAULT, true);
583  	execute(SCI_STYLESETEOLFILLED, SCE_HPHP_COMMENT, true);
584  }
585  void ScintillaEditView::setEmbeddedAspLexer()
586  {
587  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
588  	makeStyle(L_ASP, pKwArray);
589  	basic_string<char> keywordList("");
590  	if (pKwArray[LANG_INDEX_INSTR])
591  	{
592  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
593  		keywordList = wstring2string(kwlW, CP_ACP);
594  	}
595  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("asp.default.language"), reinterpret_cast<LPARAM>("2"));
596  	execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, L_VB, LANG_INDEX_INSTR)));
597      execute(SCI_STYLESETEOLFILLED, SCE_HBA_DEFAULT, true);
598  }
599  void ScintillaEditView::setUserLexer(const TCHAR *userLangName)
600  {
601  	int setKeywordsCounter = 0;
602  	setLexerFromLangID(L_USER);
603  	UserLangContainer * userLangContainer = userLangName? NppParameters::getInstance().getULCFromName(userLangName):_userDefineDlg._pCurrentUserLang;
604  	if (!userLangContainer)
605  		return;
606  	UINT codepage = CP_ACP;
607  	UniMode unicodeMode = _currentBuffer->getUnicodeMode();
608  	int encoding = _currentBuffer->getEncoding();
609  	if (encoding == -1)
610  	{
611  		if (unicodeMode == uniUTF8 || unicodeMode == uniCookie)
612  			codepage = CP_UTF8;
613  	}
614  	else
615  	{
616  		codepage = CP_OEMCP;	
617  	}
618  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
619  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.isCaseIgnored"),		  reinterpret_cast<LPARAM>(userLangContainer->_isCaseIgnored ? "1":"0"));
620  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.allowFoldOfComments"),  reinterpret_cast<LPARAM>(userLangContainer->_allowFoldOfComments ? "1":"0"));
621  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.foldCompact"),		  reinterpret_cast<LPARAM>(userLangContainer->_foldCompact ? "1":"0"));
622      char name[] = "userDefine.prefixKeywords0";
623  	for (int i=0 ; i<SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
624  	{
625  		itoa(i+1, (name+25), 10);
626  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>(name), reinterpret_cast<LPARAM>(userLangContainer->_isPrefix[i] ? "1" : "0"));
627  	}
628  	char* temp = new char[max_char];
629  	for (int i = 0 ; i < SCE_USER_KWLIST_TOTAL ; ++i)
630  	{
631  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
632  		const char * keyWords_char = wmc.wchar2char(userLangContainer->_keywordLists[i], codepage);
633  		if (globalMappper().setLexerMapper.find(i) != globalMappper().setLexerMapper.end())
634  		{
635  			execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>(globalMappper().setLexerMapper[i].c_str()), reinterpret_cast<LPARAM>(keyWords_char));
636  		}
637  		else 
638  		{
639  			bool inDoubleQuote = false;
640  			bool inSingleQuote = false;
641  			bool nonWSFound = false;
642  			int index = 0;
643  			for (size_t j=0, len = strlen(keyWords_char); j<len && index < (max_char-1); ++j)
644  			{
645  				if (!inSingleQuote && keyWords_char[j] == '"')
646  				{
647  					inDoubleQuote = !inDoubleQuote;
648  					continue;
649  				}
650  				if (!inDoubleQuote && keyWords_char[j] == '\'')
651  				{
652  					inSingleQuote = !inSingleQuote;
653  					continue;
654  				}
655  				if (keyWords_char[j] == '\\' && (keyWords_char[j+1] == '"' || keyWords_char[j+1] == '\'' || keyWords_char[j+1] == '\\'))
656  				{
657  					++j;
658  					temp[index++] = keyWords_char[j];
659  					continue;
660  				}
661  				if (inDoubleQuote || inSingleQuote)
662  				{
663  					if (keyWords_char[j] > ' ')		
664  					{
665  						temp[index++] = keyWords_char[j];
666  						if (nonWSFound == false)
667  							nonWSFound = true;
668  					}
669  					else if (nonWSFound == true && keyWords_char[j-1] != '"' && keyWords_char[j+1] != '"' && keyWords_char[j+1] > ' ')
670  					{
671  						temp[index++] = inDoubleQuote ? '\v' : '\b';
672  					}
673  					else
674  						continue;
675  				}
676  				else
677  				{
678  					temp[index++] = keyWords_char[j];
679  				}
680  			}
681  			temp[index++] = 0;
682  			execute(SCI_SETKEYWORDS, setKeywordsCounter++, reinterpret_cast<LPARAM>(temp));
683  		}
684  	}
685  	delete[] temp;
686   	char intBuffer[32];
687  	sprintf(intBuffer, "%d", userLangContainer->_forcePureLC);
688  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.forcePureLC"), reinterpret_cast<LPARAM>(intBuffer));
689  	sprintf(intBuffer, "%d", userLangContainer->_decimalSeparator);
690  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.decimalSeparator"), reinterpret_cast<LPARAM>(intBuffer));
691  	sprintf(intBuffer, "%" PRIuPTR, reinterpret_cast<uintptr_t>(userLangContainer->getName())); 
692  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.udlName"), reinterpret_cast<LPARAM>(intBuffer));
693  	sprintf(intBuffer, "%" PRIuPTR, reinterpret_cast<uintptr_t>(_currentBufferID)); 
694      execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.currentBufferID"), reinterpret_cast<LPARAM>(intBuffer));
695  	for (const Style & style : userLangContainer->_styles)
696  	{
697  		if (style._styleID == STYLE_NOT_USED)
698  			continue;
699  		char nestingBuffer[32];
700  		sprintf(nestingBuffer, "userDefine.nesting.%02d", style._styleID);
701  		sprintf(intBuffer, "%d", style._nesting);
702  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>(nestingBuffer), reinterpret_cast<LPARAM>(intBuffer));
703  		setStyle(style);
704  	}
705  }
706  void ScintillaEditView::setExternalLexer(LangType typeDoc)
707  {
708  	int id = typeDoc - L_EXTERNAL;
709  	ExternalLangContainer& externalLexer = NppParameters::getInstance().getELCFromIndex(id);
710  	if (!externalLexer.fnCL)
711  		return;
712  	ILexer5* iLex5 = externalLexer.fnCL(externalLexer._name.c_str());
713  	if (!iLex5)
714  		return;
715  	execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(iLex5));
716  	::SendMessage(_hParent, NPPM_INTERNAL_EXTERNALLEXERBUFFER, 0, (LPARAM)getCurrentBufferID());
717  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
718  	const wchar_t* lexerNameW = wmc.char2wchar(externalLexer._name.c_str(), CP_ACP);
719  	LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerNameW);
720  	if (pStyler)
721  	{
722  		for (const Style & style : *pStyler)
723  		{
724  			setStyle(style);
725  			if (style._keywordClass >= 0 && style._keywordClass <= KEYWORDSET_MAX)
726  			{
727  				basic_string<char> keywordList("");
728  				if (!style._keywords.empty())
729  				{
730  					keywordList = wstring2string(style._keywords, CP_ACP);
731  				}
732  				execute(SCI_SETKEYWORDS, style._keywordClass, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, typeDoc, style._keywordClass)));
733  			}
734  		}
735  	}
736  }
737  void ScintillaEditView::setCppLexer(LangType langType)
738  {
739      const char *cppInstrs;
740      const char *cppTypes;
741      const TCHAR *doxygenKeyWords  = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
742      setLexerFromLangID(L_CPP);
743  	if (langType != L_RC)
744      {
745          if (doxygenKeyWords)
746  		{
747  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
748  			const char * doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
749  			execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(doxygenKeyWords_char));
750  		}
751      }
752  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
753  	makeStyle(langType, pKwArray);
754  	basic_string<char> keywordListInstruction("");
755  	basic_string<char> keywordListType("");
756  	if (pKwArray[LANG_INDEX_INSTR])
757  	{
758  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
759  		keywordListInstruction = wstring2string(kwlW, CP_ACP);
760  	}
761  	cppInstrs = getCompleteKeywordList(keywordListInstruction, langType, LANG_INDEX_INSTR);
762  	if (pKwArray[LANG_INDEX_TYPE])
763  	{
764  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_TYPE];
765  		keywordListType = wstring2string(kwlW, CP_ACP);
766  	}
767  	cppTypes = getCompleteKeywordList(keywordListType, langType, LANG_INDEX_TYPE);
768  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(cppInstrs));
769  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(cppTypes));
770  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
771  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
772  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
773  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.cpp.comment.explicit"), reinterpret_cast<LPARAM>("0"));
774  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
775  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.track.preprocessor"), reinterpret_cast<LPARAM>("0"));
776  }
777  void ScintillaEditView::setJsLexer()
778  {
779  	const TCHAR *doxygenKeyWords = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
780  	setLexerFromLangID(L_JAVASCRIPT);
781  	const TCHAR *pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
782  	makeStyle(L_JAVASCRIPT, pKwArray);
783  	if (doxygenKeyWords)
784  	{
785  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
786  		const char * doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
787  		execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(doxygenKeyWords_char));
788  	}
789  	const TCHAR *newLexerName = ScintillaEditView::_langNameInfoArray[L_JAVASCRIPT]._langName;
790  	LexerStyler *pNewStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(newLexerName);
791  	if (pNewStyler) 
792  	{
793  		for (const Style & style : *pNewStyler)
794  		{
795  			setStyle(style);
796  		}
797  		basic_string<char> keywordListInstruction("");
798  		basic_string<char> keywordListType("");
799  		basic_string<char> keywordListInstruction2("");
800  		if (pKwArray[LANG_INDEX_INSTR])
801  		{
802  			basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
803  			keywordListInstruction = wstring2string(kwlW, CP_ACP);
804  		}
805  		const char *jsInstrs = getCompleteKeywordList(keywordListInstruction, L_JAVASCRIPT, LANG_INDEX_INSTR);
806  		if (pKwArray[LANG_INDEX_TYPE])
807  		{
808  			basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_TYPE];
809  			keywordListType = wstring2string(kwlW, CP_ACP);
810  		}
811  		const char *jsTypes = getCompleteKeywordList(keywordListType, L_JAVASCRIPT, LANG_INDEX_TYPE);
812  		if (pKwArray[LANG_INDEX_INSTR2])
813  		{
814  			basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR2];
815  			keywordListInstruction2 = wstring2string(kwlW, CP_ACP);
816  		}
817  		const char *jsInstrs2 = getCompleteKeywordList(keywordListInstruction2, L_JAVASCRIPT, LANG_INDEX_INSTR2);
818  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(jsInstrs));
819  		execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(jsTypes));
820  		execute(SCI_SETKEYWORDS, 3, reinterpret_cast<LPARAM>(jsInstrs2));
821  	}
822  	else 
823  	{
824  		const TCHAR *lexerName = ScintillaEditView::_langNameInfoArray[L_JS]._langName;
825  		LexerStyler *pOldStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerName);
826  		if (pOldStyler)
827  		{
828  			for (Style style : *pOldStyler) 
829  			{
830  				int cppID = style._styleID;
831  				switch (style._styleID)
832  				{
833  					case SCE_HJ_DEFAULT: cppID = SCE_C_DEFAULT; break;
834  					case SCE_HJ_WORD: cppID = SCE_C_IDENTIFIER; break;
835  					case SCE_HJ_SYMBOLS: cppID = SCE_C_OPERATOR; break;
836  					case SCE_HJ_COMMENT: cppID = SCE_C_COMMENT; break;
837  					case SCE_HJ_COMMENTLINE: cppID = SCE_C_COMMENTLINE; break;
838  					case SCE_HJ_COMMENTDOC: cppID = SCE_C_COMMENTDOC; break;
839  					case SCE_HJ_NUMBER: cppID = SCE_C_NUMBER; break;
840  					case SCE_HJ_KEYWORD: cppID = SCE_C_WORD; break;
841  					case SCE_HJ_DOUBLESTRING: cppID = SCE_C_STRING; break;
842  					case SCE_HJ_SINGLESTRING: cppID = SCE_C_CHARACTER; break;
843  					case SCE_HJ_REGEX: cppID = SCE_C_REGEX; break;
844  				}
845  				style._styleID = cppID;
846  				setStyle(style);
847  			}
848  		}
849  		execute(SCI_STYLESETEOLFILLED, SCE_C_DEFAULT, true);
850  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENTLINE, true);
851  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENT, true);
852  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENTDOC, true);
853  		makeStyle(L_JS, pKwArray);
854  		basic_string<char> keywordListInstruction("");
855  		if (pKwArray[LANG_INDEX_INSTR])
856  		{
857  			basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
858  			keywordListInstruction = wstring2string(kwlW, CP_ACP);
859  		}
860  		const char *jsEmbeddedInstrs = getCompleteKeywordList(keywordListInstruction, L_JS, LANG_INDEX_INSTR);
861  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(jsEmbeddedInstrs));
862  	}
863  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
864  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
865  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
866  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.cpp.comment.explicit"), reinterpret_cast<LPARAM>("0"));
867  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
868  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.track.preprocessor"), reinterpret_cast<LPARAM>("0"));
869  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.backquoted.strings"), reinterpret_cast<LPARAM>("1"));
870  }
871  void ScintillaEditView::setTclLexer()
872  {
873  	const char *tclInstrs;
874      const char *tclTypes;
875  	setLexerFromLangID(L_TCL);
876  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
877  	makeStyle(L_TCL, pKwArray);
878  	basic_string<char> keywordListInstruction("");
879  	basic_string<char> keywordListType("");
880  	if (pKwArray[LANG_INDEX_INSTR])
881  	{
882  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
883  		keywordListInstruction = wstring2string(kwlW, CP_ACP);
884  	}
885  	tclInstrs = getCompleteKeywordList(keywordListInstruction, L_TCL, LANG_INDEX_INSTR);
886  	if (pKwArray[LANG_INDEX_TYPE])
887  	{
888  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_TYPE];
889  		keywordListType = wstring2string(kwlW, CP_ACP);
890  	}
891  	tclTypes = getCompleteKeywordList(keywordListType, L_TCL, LANG_INDEX_TYPE);
892  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(tclInstrs));
893  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(tclTypes));
894  }
895  void ScintillaEditView::setObjCLexer(LangType langType)
896  {
897  	setLexerFromLangID(L_OBJC);
898  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
899  	makeStyle(langType, pKwArray);
900  	basic_string<char> objcInstr1Kwl("");
901  	if (pKwArray[LANG_INDEX_INSTR])
902  	{
903  		objcInstr1Kwl = wstring2string(pKwArray[LANG_INDEX_INSTR], CP_ACP);
904  	}
905  	const char *objcInstrs = getCompleteKeywordList(objcInstr1Kwl, langType, LANG_INDEX_INSTR);
906  	basic_string<char> objcInstr2Kwl("");
907  	if (pKwArray[LANG_INDEX_INSTR2])
908  	{
909  		objcInstr2Kwl = wstring2string(pKwArray[LANG_INDEX_INSTR2], CP_ACP);
910  	}
911  	const char *objCDirective = getCompleteKeywordList(objcInstr2Kwl, langType, LANG_INDEX_INSTR2);
912  	basic_string<char> objcTypeKwl("");
913  	if (pKwArray[LANG_INDEX_TYPE])
914  	{
915  		objcTypeKwl = wstring2string(pKwArray[LANG_INDEX_TYPE], CP_ACP);
916  	}
917  	const char *objcTypes = getCompleteKeywordList(objcTypeKwl, langType, LANG_INDEX_TYPE);
918  	basic_string<char> objcType2Kwl("");
919  	if (pKwArray[LANG_INDEX_TYPE2])
920  	{
921  		objcType2Kwl = wstring2string(pKwArray[LANG_INDEX_TYPE2], CP_ACP);
922  	}
923  	const char *objCQualifier = getCompleteKeywordList(objcType2Kwl, langType, LANG_INDEX_TYPE2);
924  	basic_string<char> doxygenKeyWordsString("");
925  	const TCHAR *doxygenKeyWordsW = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
926  	if (doxygenKeyWordsW)
927  	{
928  		doxygenKeyWordsString = wstring2string(doxygenKeyWordsW, CP_ACP);
929  	}
930  	const char *doxygenKeyWords = doxygenKeyWordsString.c_str();
931  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(objcInstrs));
932      execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(objcTypes));
933  	execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(doxygenKeyWords));
934  	execute(SCI_SETKEYWORDS, 3, reinterpret_cast<LPARAM>(objCDirective));
935  	execute(SCI_SETKEYWORDS, 4, reinterpret_cast<LPARAM>(objCQualifier));
936  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
937  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
938  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
939  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.cpp.comment.explicit"), reinterpret_cast<LPARAM>("0"));
940  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
941  }
942  void ScintillaEditView::setTypeScriptLexer()
943  {
944  	const TCHAR* doxygenKeyWords = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
945  	setLexerFromLangID(L_TYPESCRIPT);
946  	if (doxygenKeyWords)
947  	{
948  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
949  		const char* doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
950  		execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(doxygenKeyWords_char));
951  	}
952  	const TCHAR* pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
953  	makeStyle(L_TYPESCRIPT, pKwArray);
954  	auto getKeywordList = [&pKwArray](const int i) 
955  	{
956  		if (pKwArray[i])
957  		{
958  			basic_string<wchar_t> kwlW = pKwArray[i];
959  			return wstring2string(kwlW, CP_ACP);
960  		}
961  		return basic_string<char>("");
962  	};
963  	std::string keywordListInstruction = getKeywordList(LANG_INDEX_INSTR);
964  	const char* tsInstructions = getCompleteKeywordList(keywordListInstruction, L_TYPESCRIPT, LANG_INDEX_INSTR);
965  	string keywordListType = getKeywordList(LANG_INDEX_TYPE);
966  	const char* tsTypes = getCompleteKeywordList(keywordListType, L_TYPESCRIPT, LANG_INDEX_TYPE);
967  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(tsInstructions));
968  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(tsTypes));
969  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
970  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
971  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
972  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.cpp.comment.explicit"), reinterpret_cast<LPARAM>("0"));
973  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
974  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.track.preprocessor"), reinterpret_cast<LPARAM>("0"));
975  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.backquoted.strings"), reinterpret_cast<LPARAM>("1"));
976  }
977  void ScintillaEditView::setKeywords(LangType langType, const char *keywords, int index)
978  {
979  	std::basic_string<char> wordList;
980  	wordList = (keywords)?keywords:"";
981  	execute(SCI_SETKEYWORDS, index, reinterpret_cast<LPARAM>(getCompleteKeywordList(wordList, langType, index)));
982  }
983  void ScintillaEditView::setLexer(LangType langType, int whichList)
984  {
985  	setLexerFromLangID(langType);
986  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
987  	makeStyle(langType, pKwArray);
988  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
989  	if (whichList & LIST_0)
990  	{
991  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_INSTR], CP_ACP);
992  		setKeywords(langType, keyWords_char, LANG_INDEX_INSTR);
993  	}
994  	if (whichList & LIST_1)
995  	{
996  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_INSTR2], CP_ACP);
997  		setKeywords(langType, keyWords_char, LANG_INDEX_INSTR2);
998  	}
999  	if (whichList & LIST_2)
1000  	{
1001  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE], CP_ACP);
1002  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE);
1003  	}
1004  	if (whichList & LIST_3)
1005  	{
1006  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE2], CP_ACP);
1007  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE2);
1008  	}
1009  	if (whichList & LIST_4)
1010  	{
1011  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE3], CP_ACP);
1012  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE3);
1013  	}
1014  	if (whichList & LIST_5)
1015  	{
1016  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE4], CP_ACP);
1017  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE4);
1018  	}
1019  	if (whichList & LIST_6)
1020  	{
1021  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE5], CP_ACP);
1022  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE5);
1023  	}
1024  	if (whichList & LIST_7)
1025  	{
1026  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE6], CP_ACP);
1027  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE6);
1028  	}
1029  	if (whichList & LIST_8)
1030  	{
1031  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE7], CP_ACP);
1032  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE7);
1033  	}
1034  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
1035  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
1036  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
1037  }
1038  void ScintillaEditView::makeStyle(LangType language, const TCHAR **keywordArray)
1039  {
1040  	const TCHAR * lexerName = ScintillaEditView::_langNameInfoArray[language]._langName;
1041  	LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerName);
1042  	if (pStyler)
1043  	{
1044  		for (const Style & style : *pStyler)
1045  		{
1046  			setStyle(style);
1047  			if (keywordArray)
1048  			{
1049  				if ((style._keywordClass != STYLE_NOT_USED) && (!style._keywords.empty()))
1050  					keywordArray[style._keywordClass] = style._keywords.c_str();
1051  			}
1052  		}
1053  	}
1054  }
1055  void ScintillaEditView::restoreDefaultWordChars()
1056  {
1057  	execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>(_defaultCharList.c_str()));
1058  }
1059  void ScintillaEditView::addCustomWordChars()
1060  {
1061  	NppParameters& nppParam = NppParameters::getInstance();
1062  	const NppGUI & nppGUI = nppParam.getNppGUI();
1063  	if (nppGUI._customWordChars.empty())
1064  		return;
1065  	string chars2addStr;
1066  	for (size_t i = 0; i < nppGUI._customWordChars.length(); ++i)
1067  	{
1068  		bool found = false;
1069  		char char2check = nppGUI._customWordChars[i];
1070  		for (size_t j = 0; j < _defaultCharList.length(); ++j)
1071  		{
1072  			char wordChar = _defaultCharList[j];
1073  			if (char2check == wordChar)
1074  			{
1075  				found = true;
1076  				break;
1077  			}
1078  		}
1079  		if (!found)
1080  		{
1081  			chars2addStr.push_back(char2check);
1082  		}
1083  	}
1084  	if (!chars2addStr.empty())
1085  	{
1086  		string newCharList = _defaultCharList;
1087  		newCharList += chars2addStr;
1088  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>(newCharList.c_str()));
1089  	}
1090  }
1091  void ScintillaEditView::setWordChars()
1092  {
1093  	NppParameters& nppParam = NppParameters::getInstance();
1094  	const NppGUI & nppGUI = nppParam.getNppGUI();
1095  	if (nppGUI._isWordCharDefault)
1096  		restoreDefaultWordChars();
1097  	else
1098  		addCustomWordChars();
1099  }
1100  void ScintillaEditView::setCRLF(long color)
1101  {
1102  	NppParameters& nppParams = NppParameters::getInstance();
1103  	const ScintillaViewParams& svp = nppParams.getSVP();
1104  	COLORREF eolCustomColor = liteGrey;
1105  	if (color == -1)
1106  	{
1107  		StyleArray& stylers = nppParams.getMiscStylerArray();
1108  		Style* pStyle = stylers.findByName(TEXT("EOL custom color"));
1109  		if (pStyle)
1110  		{
1111  			eolCustomColor = pStyle->_fgColor;
1112  		}
1113  	}
1114  	else
1115  	{
1116  		eolCustomColor = color;
1117  	}
1118  	ScintillaViewParams::crlfMode eolMode = svp._eolMode;
1119  	long appearance = SC_REPRESENTATION_BLOB;
1120  	if (eolMode == ScintillaViewParams::crlfMode::plainText)
1121  		appearance = SC_REPRESENTATION_PLAIN;
1122  	else if (eolMode == ScintillaViewParams::crlfMode::plainTextCustomColor)
1123  		appearance = SC_REPRESENTATION_PLAIN | SC_REPRESENTATION_COLOUR;
1124  	else if (eolMode == ScintillaViewParams::crlfMode::roundedRectangleText)
1125  		appearance = SC_REPRESENTATION_BLOB;
1126  	else if (eolMode == ScintillaViewParams::crlfMode::roundedRectangleTextCustomColor)
1127  		appearance = SC_REPRESENTATION_BLOB | SC_REPRESENTATION_COLOUR;
1128  	const wchar_t* cr = L"\x0d";
1129  	const wchar_t* lf = L"\x0a";
1130  	long alphaEolCustomColor = eolCustomColor;
1131  	alphaEolCustomColor |= 0xFF000000; 
1132  	execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast<WPARAM>(cr), alphaEolCustomColor);
1133  	execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast<WPARAM>(lf), alphaEolCustomColor);
1134  	execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(cr), appearance);
1135  	execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(lf), appearance);
1136  	redraw();
1137  }
1138  void ScintillaEditView::setNpcAndCcUniEOL(long color)
1139  {
1140  	NppParameters& nppParams = NppParameters::getInstance();
1141  	const ScintillaViewParams& svp = nppParams.getSVP();
1142  	COLORREF npcCustomColor = liteGrey;
1143  	if (color == -1)
1144  	{
1145  		StyleArray& stylers = nppParams.getMiscStylerArray();
1146  		Style* pStyle = stylers.findByName(g_npcStyleName);
1147  		if (pStyle)
1148  		{
1149  			npcCustomColor = pStyle->_fgColor;
1150  		}
1151  	}
1152  	else
1153  	{
1154  		npcCustomColor = color;
1155  	}
1156  	const long appearance = svp._npcCustomColor ? SC_REPRESENTATION_BLOB | SC_REPRESENTATION_COLOUR : SC_REPRESENTATION_BLOB;
1157  	const long alphaNpcCustomColor = npcCustomColor | 0xFF000000; 
1158  	if (svp._npcShow)
1159  	{
1160  		for (const auto& invChar : g_nonPrintingChars)
1161  		{
1162  			execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast<WPARAM>(invChar.at(0)), alphaNpcCustomColor);
1163  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(invChar.at(0)), appearance);
1164  		}
1165  	}
1166  	if (svp._ccUniEolShow && svp._npcIncludeCcUniEol)
1167  	{
1168  		for (const auto& invChar : g_ccUniEolChars)
1169  		{
1170  			execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast<WPARAM>(invChar.at(0)), alphaNpcCustomColor);
1171  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(invChar.at(0)), appearance);
1172  		}
1173  	}
1174  	redraw();
1175  }
1176  void ScintillaEditView::defineDocType(LangType typeDoc)
1177  {
1178  	StyleArray & stylers = NppParameters::getInstance().getMiscStylerArray();
1179  	Style * pStyleDefault = stylers.findByID(STYLE_DEFAULT);
1180  	if (pStyleDefault)
1181  	{
1182  		pStyleDefault->_colorStyle = COLORSTYLE_ALL;	
1183  		setStyle(*pStyleDefault);
1184  	}
1185  	execute(SCI_STYLECLEARALL);
1186  	Style defaultIndicatorStyle;
1187  	const Style * pStyle;
1188  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE;
1189  	defaultIndicatorStyle._bgColor = red;
1190  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1191  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1192  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_SMART;
1193  	defaultIndicatorStyle._bgColor = liteGreen;
1194  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1195  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1196  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_INC;
1197  	defaultIndicatorStyle._bgColor = blue;
1198  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1199  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1200  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_TAGMATCH;
1201  	defaultIndicatorStyle._bgColor = RGB(0x80, 0x00, 0xFF);
1202  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1203  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1204  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_TAGATTR;
1205  	defaultIndicatorStyle._bgColor = yellow;
1206  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1207  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1208  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1209  	defaultIndicatorStyle._bgColor = cyan;
1210  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1211  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1212  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1213  	defaultIndicatorStyle._bgColor = orange;
1214  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1215  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1216  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1217  	defaultIndicatorStyle._bgColor = yellow;
1218  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1219  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1220  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1221  	defaultIndicatorStyle._bgColor = purple;
1222  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1223  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1224  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1225  	defaultIndicatorStyle._bgColor = darkGreen;
1226  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1227  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1228  	if (isCJK())
1229  	{
1230  		if (getCurrentBuffer()->getUnicodeMode() == uni8Bit)
1231  		{
1232  			if (typeDoc == L_CSS || typeDoc == L_CAML || typeDoc == L_ASM || typeDoc == L_MATLAB)
1233  				execute(SCI_SETCODEPAGE, CP_ACP);
1234  			else
1235  				execute(SCI_SETCODEPAGE, _codepage);
1236  		}
1237  	}
1238  	ScintillaViewParams & svp = (ScintillaViewParams &)NppParameters::getInstance().getSVP();
1239  	if (svp._folderStyle != FOLDER_STYLE_NONE)
1240  		showMargin(_SC_MARGE_FOLDER, isNeededFolderMarge(typeDoc));
1241  	switch (typeDoc)
1242  	{
1243  		case L_C :
1244  		case L_CPP :
1245  		case L_JAVA :
1246  		case L_RC :
1247  		case L_CS :
1248  		case L_FLASH :
1249  		case L_SWIFT:
1250  			setCppLexer(typeDoc); break;
1251  		case L_JS:
1252  		case L_JAVASCRIPT:
1253  			setJsLexer(); break;
1254  		case L_TCL :
1255              setTclLexer(); break;
1256          case L_OBJC :
1257              setObjCLexer(typeDoc); break;
1258  	    case L_PHP :
1259  		case L_ASP :
1260          case L_JSP :
1261  		case L_HTML :
1262  		case L_XML :
1263  			setXmlLexer(typeDoc); break;
1264  		case L_JSON:
1265  			setJsonLexer(); break;
1266  		case L_JSON5:
1267  			setJsonLexer(true); break;
1268  		case L_CSS :
1269  			setCssLexer(); break;
1270  		case L_LUA :
1271  			setLuaLexer(); break;
1272  		case L_MAKEFILE :
1273  			setMakefileLexer(); break;
1274  		case L_INI :
1275  			setPropsLexer(false); break;
1276  		case L_USER : {
1277  			const TCHAR * langExt = _currentBuffer->getUserDefineLangName();
1278  			if (langExt[0])
1279  				setUserLexer(langExt);
1280  			else
1281  				setUserLexer();
1282  			break; }
1283          case L_ASCII :
1284  		{
1285  			LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(TEXT("nfo"));
1286  			Style nfoStyle;
1287  			nfoStyle._styleID = STYLE_DEFAULT;
1288  			nfoStyle._fontName = TEXT("Lucida Console");
1289  			nfoStyle._fontSize = 10;
1290  			if (pStyler)
1291  			{
1292  				const Style * pStyle = pStyler->findByName(TEXT("DEFAULT"));
1293  				if (pStyle)
1294  				{
1295  					nfoStyle._bgColor = pStyle->_bgColor;
1296  					nfoStyle._fgColor = pStyle->_fgColor;
1297  					nfoStyle._colorStyle = pStyle->_colorStyle;
1298  				}
1299  			}
1300  			setSpecialStyle(nfoStyle);
1301  			execute(SCI_STYLECLEARALL);
1302  			Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1303  			if (buf->getEncoding() != NPP_CP_DOS_437)
1304  			{
1305  			   buf->setEncoding(NPP_CP_DOS_437);
1306  			   ::SendMessage(_hParent, WM_COMMAND, IDM_FILE_RELOAD, 0);
1307  			}
1308  		}
1309  		break;
1310  		case L_SQL :
1311  			setSqlLexer(); break;
1312  		case L_MSSQL :
1313  			setMSSqlLexer(); break;
1314  		case L_VB :
1315  			setVBLexer(); break;
1316  		case L_PASCAL :
1317  			setPascalLexer(); break;
1318  		case L_PERL :
1319  			setPerlLexer(); break;
1320  		case L_PYTHON :
1321  			setPythonLexer(); break;
1322  		case L_BATCH :
1323  			setBatchLexer(); break;
1324  		case L_TEX :
1325  			setTeXLexer(); break;
1326  		case L_NSIS :
1327  			setNsisLexer(); break;
1328  		case L_BASH :
1329  			setBashLexer(); break;
1330  		case L_FORTRAN :
1331  			setFortranLexer(); break;
1332  		case L_FORTRAN_77 :
1333  			setFortran77Lexer(); break;
1334  		case L_LISP :
1335              setLispLexer(); break;
1336  		case L_SCHEME :
1337              setSchemeLexer(); break;
1338  		case L_ASM :
1339              setAsmLexer(); break;
1340  		case L_DIFF :
1341              setDiffLexer(); break;
1342  		case L_PROPS :
1343              setPropsLexer(); break;
1344  		case L_PS :
1345              setPostscriptLexer(); break;
1346  		case L_RUBY :
1347              setRubyLexer(); break;
1348  		case L_SMALLTALK :
1349              setSmalltalkLexer(); break;
1350  		case L_VHDL :
1351              setVhdlLexer(); break;
1352  		case L_KIX :
1353              setKixLexer(); break;
1354  		case L_CAML :
1355              setCamlLexer(); break;
1356  		case L_ADA :
1357              setAdaLexer(); break;
1358  		case L_VERILOG :
1359              setVerilogLexer(); break;
1360  		case L_AU3 :
1361              setAutoItLexer(); break;
1362  		case L_MATLAB :
1363              setMatlabLexer(); break;
1364  		case L_HASKELL :
1365              setHaskellLexer(); break;
1366  		case L_INNO :
1367  			setInnoLexer(); break;
1368  		case L_CMAKE :
1369  			setCmakeLexer(); break;
1370  		case L_YAML :
1371  			setYamlLexer(); break;
1372          case L_COBOL :
1373  			setCobolLexer(); break;
1374          case L_GUI4CLI :
1375  			setGui4CliLexer(); break;
1376          case L_D :
1377  			setDLexer(); break;
1378          case L_POWERSHELL :
1379  			setPowerShellLexer(); break;
1380          case L_R :
1381  			setRLexer(); break;
1382  		case L_COFFEESCRIPT :
1383  			setCoffeeScriptLexer(); break;
1384  		case L_BAANC:
1385  			setBaanCLexer(); break;
1386  		case L_SREC :
1387  			setSrecLexer(); break;
1388  		case L_IHEX :
1389  			setIHexLexer(); break;
1390  		case L_TEHEX :
1391  			setTEHexLexer(); break;
1392  		case L_ASN1 :
1393  			setAsn1Lexer(); break;
1394  		case L_AVS :
1395  			setAVSLexer(); break;
1396  		case L_BLITZBASIC :
1397  			setBlitzBasicLexer(); break;
1398  		case L_PUREBASIC :
1399  			setPureBasicLexer(); break;
1400  		case L_FREEBASIC :
1401  			setFreeBasicLexer(); break;
1402  		case L_CSOUND :
1403  			setCsoundLexer(); break;
1404  		case L_ERLANG :
1405  			setErlangLexer(); break;
1406  		case L_ESCRIPT :
1407  			setESCRIPTLexer(); break;
1408  		case L_FORTH :
1409  			setForthLexer(); break;
1410  		case L_LATEX :
1411  			setLatexLexer(); break;
1412  		case L_MMIXAL :
1413  			setMMIXALLexer(); break;
1414  		case L_NIM :
1415  			setNimrodLexer(); break;
1416  		case L_NNCRONTAB :
1417  			setNncrontabLexer(); break;
1418  		case L_OSCRIPT :
1419  			setOScriptLexer(); break;
1420  		case L_REBOL :
1421  			setREBOLLexer(); break;
1422  		case L_REGISTRY :
1423  			setRegistryLexer(); break;
1424  		case L_RUST :
1425  			setRustLexer(); break;
1426  		case L_SPICE :
1427  			setSpiceLexer(); break;
1428  		case L_TXT2TAGS :
1429  			setTxt2tagsLexer(); break;
1430  		case L_VISUALPROLOG:
1431  			setVisualPrologLexer(); break;
1432  		case L_TYPESCRIPT:
1433  			setTypeScriptLexer(); break;
1434  		case L_GDSCRIPT:
1435  			setGDScriptLexer(); break;
1436  		case L_HOLLYWOOD:
1437  			setHollywoodLexer(); break;
1438  		case L_TEXT :
1439  		default :
1440  			if (typeDoc >= L_EXTERNAL && typeDoc < NppParameters::getInstance().L_END)
1441  				setExternalLexer(typeDoc);
1442  			else
1443  				setLexerFromLangID(L_TEXT);
1444  			break;
1445  	}
1446  	pStyle = stylers.findByID(STYLE_INDENTGUIDE);
1447  	if (pStyle)
1448  	{
1449  		setStyle(*pStyle);
1450  	}
1451  	pStyle = stylers.findByID(STYLE_BRACELIGHT);
1452  	if (pStyle)
1453  	{
1454  		setStyle(*pStyle);
1455  	}
1456  	pStyle = stylers.findByID(STYLE_BRACEBAD);
1457  	if (pStyle)
1458  	{
1459  		setStyle(*pStyle);
1460  	}
1461  	pStyle = stylers.findByID(STYLE_LINENUMBER);
1462  	if (pStyle)
1463  	{
1464  		setSpecialStyle(*pStyle);
1465  	}
1466  	setTabSettings(NppParameters::getInstance().getLangFromID(typeDoc));
1467  	if (svp._indentGuideLineShow)
1468  	{
1469  		const auto currentIndentMode = execute(SCI_GETINDENTATIONGUIDES);
1470  		const int docIndentMode = isPythonStyleIndentation(typeDoc) ? SC_IV_LOOKFORWARD : SC_IV_LOOKBOTH;
1471  		if (currentIndentMode != docIndentMode)
1472  			execute(SCI_SETINDENTATIONGUIDES, docIndentMode);
1473  	}
1474  }
1475  BufferID ScintillaEditView::attachDefaultDoc()
1476  {
1477  	Document doc = execute(SCI_GETDOCPOINTER, 0, 0);
1478  	execute(SCI_ADDREFDOCUMENT, 0, doc);
1479  	BufferID id = MainFileManager.bufferFromDocument(doc, false, true);
1480  	Buffer * buf = MainFileManager.getBufferByID(id);
1481  	MainFileManager.addBufferReference(id, this);	
1482  	_currentBufferID = id;
1483  	_currentBuffer = buf;
1484  	bufferUpdated(buf, BufferChangeMask);	
1485  	return id;
1486  }
1487  void ScintillaEditView::saveCurrentPos()
1488  {
1489  	size_t displayedLine = execute(SCI_GETFIRSTVISIBLELINE);
1490  	size_t docLine = execute(SCI_DOCLINEFROMVISIBLE, displayedLine);		
1491  	size_t offset = displayedLine - execute(SCI_VISIBLEFROMDOCLINE, docLine);		
1492  	size_t wrapCount = execute(SCI_WRAPCOUNT, docLine);
1493  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1494  	Position pos;
1495  	pos._firstVisibleLine = docLine;
1496  	pos._startPos = execute(SCI_GETANCHOR);
1497  	pos._endPos = execute(SCI_GETCURRENTPOS);
1498  	pos._xOffset = execute(SCI_GETXOFFSET);
1499  	pos._selMode = execute(SCI_GETSELECTIONMODE);
1500  	pos._scrollWidth = execute(SCI_GETSCROLLWIDTH);
1501  	pos._offset = offset;
1502  	pos._wrapCount = wrapCount;
1503  	buf->setPosition(pos, this);
1504  }
1505  void ScintillaEditView::restoreCurrentPosPreStep()
1506  {
1507  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1508  	Position & pos = buf->getPosition(this);
1509  	execute(SCI_SETSELECTIONMODE, pos._selMode);	
1510  	execute(SCI_SETANCHOR, pos._startPos);
1511  	execute(SCI_SETCURRENTPOS, pos._endPos);
1512  	execute(SCI_CANCEL);							
1513  	if (!isWrap()) 
1514  	{
1515  		execute(SCI_SETSCROLLWIDTH, pos._scrollWidth);
1516  		execute(SCI_SETXOFFSET, pos._xOffset);
1517  	}
1518  	execute(SCI_CHOOSECARETX); 
1519  	intptr_t lineToShow = execute(SCI_VISIBLEFROMDOCLINE, pos._firstVisibleLine);
1520  	execute(SCI_SETFIRSTVISIBLELINE, lineToShow);
1521  	if (isWrap())
1522  	{
1523  		_positionRestoreNeeded = true;
1524  	}
1525  	_restorePositionRetryCount = 0;
1526  }
1527  void ScintillaEditView::restoreCurrentPosPostStep()
1528  {
1529  	if (!_positionRestoreNeeded)
1530  		return;
1531  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1532  	Position & pos = buf->getPosition(this);
1533  	++_restorePositionRetryCount;
1534  	if (_restorePositionRetryCount > 8)
1535  	{
1536  		_positionRestoreNeeded = false;
1537  		return;
1538  	}
1539  	intptr_t displayedLine = execute(SCI_GETFIRSTVISIBLELINE);
<span onclick='openModal()' class='match'>1540  	intptr_t docLine = execute(SCI_DOCLINEFROMVISIBLE, displayedLine);		
1541  	if (docLine != pos._firstVisibleLine)
1542  	{
1543  		intptr_t lineToShow = execute(SCI_VISIBLEFROMDOCLINE, pos._firstVisibleLine);
1544  		execute(SCI_SETFIRSTVISIBLELINE, lineToShow);
1545  	}
1546  	else if (pos._offset > 0)
1547  	{
1548  		intptr_t wrapCount = execute(SCI_WRAPCOUNT, docLine);
</span>1549  		if (wrapCount == pos._wrapCount)
1550  		{
1551  			scroll(0, pos._offset);
1552  			_positionRestoreNeeded = false;
1553  		}
1554  	}
1555  	else
1556  	{
1557  		_positionRestoreNeeded = false;
1558  	}
1559  }
1560  void ScintillaEditView::restyleBuffer()
1561  {
1562  	execute(SCI_CLEARDOCUMENTSTYLE);
1563  	execute(SCI_COLOURISE, 0, -1);
1564  	_currentBuffer->setNeedsLexing(false);
1565  }
1566  void ScintillaEditView::styleChange()
1567  {
1568  	defineDocType(_currentBuffer->getLangType());
1569  	restyleBuffer();
1570  }
1571  bool ScintillaEditView::setLexerFromLangID(int langID) 
1572  {
1573  	if (langID >= L_EXTERNAL)
1574  		return false;
1575  	const char* lexerNameID = _langNameInfoArray[langID]._lexerID;
1576  	execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(CreateLexer(lexerNameID)));
1577  	return true;
1578  }
1579  void ScintillaEditView::activateBuffer(BufferID buffer, bool force)
1580  {
1581  	if (buffer == BUFFER_INVALID)
1582  		return;
1583  	if (!force && buffer == _currentBuffer)
1584  		return;
1585  	Buffer * newBuf = MainFileManager.getBufferByID(buffer);
1586  	saveCurrentPos();
1587  	std::vector<size_t> lineStateVector;
1588  	getCurrentFoldStates(lineStateVector);
1589  	_currentBuffer->setHeaderLineState(lineStateVector, this);
1590  	_currentBufferID = buffer;	
1591  	_currentBuffer = newBuf;
1592  	execute(SCI_SETDOCPOINTER, 0, _currentBuffer->getDocument());
1593  	defineDocType(_currentBuffer->getLangType());
1594  	setWordChars();
1595  	if (_currentBuffer->getNeedsLexing())
1596  	{
1597  		restyleBuffer();
1598  	}
1599  	maintainStateForNpc();
1600  	bufferUpdated(_currentBuffer, (BufferChangeMask & ~BufferChangeLanguage));
1601  	const std::vector<size_t> & lineStateVectorNew = newBuf->getHeaderLineState(this);
1602  	syncFoldStateWith(lineStateVectorNew);
1603  	restoreCurrentPosPreStep();
1604  	runMarkers(true, 0, true, false);
1605  	setCRLF();
1606  	NppParameters& nppParam = NppParameters::getInstance();
1607  	const ScintillaViewParams& svp = nppParam.getSVP();
1608  	int enabledCH = svp._isChangeHistoryEnabled ? (SC_CHANGE_HISTORY_ENABLED | SC_CHANGE_HISTORY_MARKERS) : SC_CHANGE_HISTORY_DISABLED;
1609  	execute(SCI_SETCHANGEHISTORY, enabledCH);
1610      return;	
1611  }
1612  void ScintillaEditView::getCurrentFoldStates(std::vector<size_t> & lineStateVector)
1613  {
1614  	size_t contractedFoldHeaderLine = 0;
1615  	do {
1616  		contractedFoldHeaderLine = execute(SCI_CONTRACTEDFOLDNEXT, contractedFoldHeaderLine);
1617  		if (static_cast<intptr_t>(contractedFoldHeaderLine) != -1)
1618  		{
1619  			lineStateVector.push_back(contractedFoldHeaderLine);
1620  			++contractedFoldHeaderLine;
1621  		}
1622  	} while (static_cast<intptr_t>(contractedFoldHeaderLine) != -1);
1623  }
1624  void ScintillaEditView::syncFoldStateWith(const std::vector<size_t> & lineStateVectorNew)
1625  {
1626  	size_t nbLineState = lineStateVectorNew.size();
1627  	for (size_t i = 0 ; i < nbLineState ; ++i)
1628  	{
1629  		auto line = lineStateVectorNew.at(i);
1630  		fold(line, false);
1631  	}
1632  }
1633  void ScintillaEditView::bufferUpdated(Buffer * buffer, int mask)
1634  {
1635  	if (buffer == _currentBuffer)
1636  	{
1637  		if (mask & BufferChangeLanguage)
1638  		{
1639  			defineDocType(buffer->getLangType());
1640  			foldAll(fold_uncollapse);
1641  		}
1642  		if (mask & BufferChangeLexing)
1643  		{
1644  			if (buffer->getNeedsLexing())
1645  			{
1646  				restyleBuffer();	
1647  			}	
1648  		}
1649  		if (mask & BufferChangeFormat)
1650  		{
1651  			execute(SCI_SETEOLMODE, static_cast<int>(_currentBuffer->getEolFormat()));
1652  		}
1653  		if (mask & BufferChangeReadonly)
1654  		{
1655  			execute(SCI_SETREADONLY, _currentBuffer->isReadOnly());
1656  		}
1657  		if (mask & BufferChangeUnicode)
1658  		{
1659              int enc = CP_ACP;
1660  			if (buffer->getUnicodeMode() == uni8Bit)
1661  			{	
1662  				LangType typeDoc = buffer->getLangType();
1663  				if (isCJK())
1664  				{
1665  					if (typeDoc == L_CSS || typeDoc == L_CAML || typeDoc == L_ASM || typeDoc == L_MATLAB)
1666  						enc = CP_ACP;	
1667  					else
1668  						enc = _codepage;
1669  				}
1670                  else
1671                      enc = CP_ACP;
1672  			}
1673  			else	
1674  				enc = SC_CP_UTF8;
1675              execute(SCI_SETCODEPAGE, enc);
1676  		}
1677  	}
1678  }
1679  bool ScintillaEditView::isFoldIndentationBased() const
1680  {
1681  	const auto lexer = execute(SCI_GETLEXER);
1682  	return lexer == SCLEX_PYTHON
1683  		|| lexer == SCLEX_COFFEESCRIPT
1684  		|| lexer == SCLEX_HASKELL
1685  		|| lexer == SCLEX_NIMROD
1686  		|| lexer == SCLEX_VB
1687  		|| lexer == SCLEX_YAML
1688  	;
1689  }
1690  namespace {
1691  struct FoldLevelStack
1692  {
1693  	int levelCount = 0; 
1694  	intptr_t levelStack[MAX_FOLD_COLLAPSE_LEVEL]{};
1695  	void push(intptr_t level)
1696  	{
1697  		while (levelCount != 0 && level <= levelStack[levelCount - 1])
1698  		{
1699  			--levelCount;
1700  		}
1701  		levelStack[levelCount++] = level;
1702  	}
1703  };
1704  }
1705  void ScintillaEditView::collapseFoldIndentationBased(int level2Collapse, bool mode)
1706  {
1707  	execute(SCI_COLOURISE, 0, -1);
1708  	FoldLevelStack levelStack;
1709  	++level2Collapse; 
1710  	const intptr_t maxLine = execute(SCI_GETLINECOUNT);
1711  	intptr_t line = 0;
1712  	while (line < maxLine)
1713  	{
1714  		intptr_t level = execute(SCI_GETFOLDLEVEL, line);
1715  		if (level & SC_FOLDLEVELHEADERFLAG)
1716  		{
1717  			level &= SC_FOLDLEVELNUMBERMASK;
1718  			levelStack.push(level);
1719  			if (level2Collapse == levelStack.levelCount)
1720  			{
1721  				if (isFolded(line) != mode)
1722  				{
1723  					fold(line, mode);
1724  				}
1725  				line = execute(SCI_GETLASTCHILD, line, -1);
1726  			}
1727  		}
1728  		++line;
1729  	}
1730  	runMarkers(true, 0, true, false);
1731  }
1732  void ScintillaEditView::collapse(int level2Collapse, bool mode)
1733  {
1734  	if (isFoldIndentationBased())
1735  	{
1736  		collapseFoldIndentationBased(level2Collapse, mode);
1737  		return;
1738  	}
1739  	execute(SCI_COLOURISE, 0, -1);
1740  	intptr_t maxLine = execute(SCI_GETLINECOUNT);
1741  	for (int line = 0; line < maxLine; ++line)
1742  	{
1743  		intptr_t level = execute(SCI_GETFOLDLEVEL, line);
1744  		if (level & SC_FOLDLEVELHEADERFLAG)
1745  		{
1746  			level -= SC_FOLDLEVELBASE;
1747  			if (level2Collapse == (level & SC_FOLDLEVELNUMBERMASK))
1748  				if (isFolded(line) != mode)
1749  				{
1750  					fold(line, mode);
1751  				}
1752  		}
1753  	}
1754  	runMarkers(true, 0, true, false);
1755  }
1756  void ScintillaEditView::foldCurrentPos(bool mode)
1757  {
1758  	auto currentLine = getCurrentLineNumber();
1759  	fold(currentLine, mode);
1760  }
1761  bool ScintillaEditView::isCurrentLineFolded() const
1762  {
1763  	auto currentLine = getCurrentLineNumber();
1764  	intptr_t headerLine;
1765  	auto level = execute(SCI_GETFOLDLEVEL, currentLine);
1766  	if (level & SC_FOLDLEVELHEADERFLAG)
1767  		headerLine = currentLine;
1768  	else
1769  	{
1770  		headerLine = execute(SCI_GETFOLDPARENT, currentLine);
1771  		if (headerLine == -1)
1772  			return false;
1773  	}
1774  	bool isExpanded = execute(SCI_GETFOLDEXPANDED, headerLine);
1775  	return !isExpanded;
1776  }
1777  void ScintillaEditView::fold(size_t line, bool mode)
1778  {
1779  	auto endStyled = execute(SCI_GETENDSTYLED);
1780  	auto len = execute(SCI_GETTEXTLENGTH);
1781  	if (endStyled < len)
1782  		execute(SCI_COLOURISE, 0, -1);
1783  	intptr_t headerLine;
1784  	auto level = execute(SCI_GETFOLDLEVEL, line);
1785  	if (level & SC_FOLDLEVELHEADERFLAG)
1786  		headerLine = line;
1787  	else
1788  	{
1789  		headerLine = execute(SCI_GETFOLDPARENT, line);
1790  		if (headerLine == -1)
1791  			return;
1792  	}
1793  	if (isFolded(headerLine) != mode)
1794  	{
1795  		execute(SCI_TOGGLEFOLD, headerLine);
1796  		SCNotification scnN{};
1797  		scnN.nmhdr.code = SCN_FOLDINGSTATECHANGED;
1798  		scnN.nmhdr.hwndFrom = _hSelf;
1799  		scnN.nmhdr.idFrom = 0;
1800  		scnN.line = headerLine;
1801  		scnN.foldLevelNow = isFolded(headerLine)?1:0; 
1802  		::SendMessage(_hParent, WM_NOTIFY, 0, reinterpret_cast<LPARAM>(&scnN));
1803  	}
1804  }
1805  void ScintillaEditView::foldAll(bool mode)
1806  {
1807  	auto maxLine = execute(SCI_GETLINECOUNT);
1808  	for (int line = 0; line < maxLine; ++line)
1809  	{
1810  		auto level = execute(SCI_GETFOLDLEVEL, line);
1811  		if (level & SC_FOLDLEVELHEADERFLAG)
1812  			if (isFolded(line) != mode)
1813  				fold(line, mode);
1814  	}
1815  }
1816  void ScintillaEditView::getText(char *dest, size_t start, size_t end) const
1817  {
1818  	Sci_TextRangeFull tr{};
1819  	tr.chrg.cpMin = static_cast<Sci_Position>(start);
1820  	tr.chrg.cpMax = static_cast<Sci_Position>(end);
1821  	tr.lpstrText = dest;
1822  	execute(SCI_GETTEXTRANGEFULL, 0, reinterpret_cast<LPARAM>(&tr));
1823  }
1824  generic_string ScintillaEditView::getGenericTextAsString(size_t start, size_t end) const
1825  {
1826  	assert(end > start);
1827  	const size_t bufSize = end - start + 1;
1828  	TCHAR *buf = new TCHAR[bufSize];
1829  	getGenericText(buf, bufSize, start, end);
1830  	generic_string text = buf;
1831  	delete[] buf;
1832  	return text;
1833  }
1834  void ScintillaEditView::getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end) const
1835  {
1836  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1837  	char *destA = new char[end - start + 1];
1838  	getText(destA, start, end);
1839  	size_t cp = execute(SCI_GETCODEPAGE);
1840  	const TCHAR *destW = wmc.char2wchar(destA, cp);
1841  	wcsncpy_s(dest, destlen, destW, _TRUNCATE);
1842  	delete [] destA;
1843  }
1844  void ScintillaEditView::getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end, intptr_t* mstart, intptr_t* mend) const
1845  {
1846  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1847  	char *destA = new char[end - start + 1];
1848  	getText(destA, start, end);
1849  	size_t cp = execute(SCI_GETCODEPAGE)    ;
1850  	const TCHAR *destW = wmc.char2wchar(destA, cp, mstart, mend);
1851  	wcsncpy_s(dest, destlen, destW, _TRUNCATE);
1852  	delete [] destA;
1853  }
1854  void ScintillaEditView::insertGenericTextFrom(size_t position, const TCHAR *text2insert) const
1855  {
1856  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1857  	size_t cp = execute(SCI_GETCODEPAGE);
1858  	const char *text2insertA = wmc.wchar2char(text2insert, cp);
1859  	execute(SCI_INSERTTEXT, position, reinterpret_cast<LPARAM>(text2insertA));
1860  }
1861  void ScintillaEditView::replaceSelWith(const char * replaceText)
1862  {
1863  	execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(replaceText));
1864  }
1865  void ScintillaEditView::getVisibleStartAndEndPosition(intptr_t* startPos, intptr_t* endPos)
1866  {
1867  	assert(startPos != NULL && endPos != NULL);
1868  	RECT rcEditView{};
1869  	getClientRect(rcEditView);
1870  	LRESULT pos = execute(SCI_POSITIONFROMPOINT, 0, 0);
1871  	LRESULT line = execute(SCI_LINEFROMPOSITION, pos);
1872  	*startPos = execute(SCI_POSITIONFROMLINE, line);
1873  	pos = execute(SCI_POSITIONFROMPOINT, static_cast<WPARAM>(rcEditView.right - rcEditView.left), static_cast<LPARAM>(rcEditView.bottom - rcEditView.top));
1874  	line = execute(SCI_LINEFROMPOSITION, pos);
1875  	*endPos = execute(SCI_GETLINEENDPOSITION, line);
1876  }
1877  char * ScintillaEditView::getWordFromRange(char * txt, size_t size, size_t pos1, size_t pos2)
1878  {
1879      if (!size)
1880  		return NULL;
1881      if (pos1 > pos2)
1882      {
1883          size_t tmp = pos1;
1884          pos1 = pos2;
1885          pos2 = tmp;
1886      }
1887      if (size < pos2 - pos1)
1888          return NULL;
1889      getText(txt, pos1, pos2);
1890  	return txt;
1891  }
1892  char * ScintillaEditView::getWordOnCaretPos(char * txt, size_t size)
1893  {
1894      if (!size)
1895  		return NULL;
1896      pair<size_t, size_t> range = getWordRange();
1897      return getWordFromRange(txt, size, range.first, range.second);
1898  }
1899  TCHAR * ScintillaEditView::getGenericWordOnCaretPos(TCHAR * txt, int size)
1900  {
1901  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1902  	size_t cp = execute(SCI_GETCODEPAGE);
1903  	char *txtA = new char[size + 1];
1904  	getWordOnCaretPos(txtA, size);
1905  	const TCHAR * txtW = wmc.char2wchar(txtA, cp);
1906  	wcscpy_s(txt, size, txtW);
1907  	delete [] txtA;
1908  	return txt;
1909  }
1910  char * ScintillaEditView::getSelectedText(char * txt, size_t size, bool expand)
1911  {
1912  	if (!size)
1913  		return NULL;
1914  	Sci_CharacterRangeFull range = getSelection();
1915  	if (range.cpMax == range.cpMin && expand)
1916  	{
1917  		expandWordSelection();
1918  		range = getSelection();
1919  	}
1920  	if (!(static_cast<Sci_Position>(size) > (range.cpMax - range.cpMin)))	
1921  	{
1922  		range.cpMax = range.cpMin + size -1;	
1923  	}
1924  	return getWordFromRange(txt, size, range.cpMin, range.cpMax);
1925  }
1926  TCHAR * ScintillaEditView::getGenericSelectedText(TCHAR * txt, int size, bool expand)
1927  {
1928  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1929  	size_t cp = execute(SCI_GETCODEPAGE);
1930  	char *txtA = new char[size + 1];
1931  	getSelectedText(txtA, size, expand);
1932  	const TCHAR * txtW = wmc.char2wchar(txtA, cp);
1933  	wcscpy_s(txt, size, txtW);
1934  	delete [] txtA;
1935  	return txt;
1936  }
1937  intptr_t ScintillaEditView::searchInTarget(const TCHAR * text2Find, size_t lenOfText2Find, size_t fromPos, size_t toPos) const
1938  {
1939  	execute(SCI_SETTARGETRANGE, fromPos, toPos);
1940  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1941  	size_t cp = execute(SCI_GETCODEPAGE);
1942  	const char *text2FindA = wmc.wchar2char(text2Find, cp);
1943  	size_t text2FindALen = strlen(text2FindA);
1944     	size_t len = (lenOfText2Find > text2FindALen) ? lenOfText2Find : text2FindALen;
1945  	return execute(SCI_SEARCHINTARGET, len, reinterpret_cast<LPARAM>(text2FindA));
1946  }
1947  void ScintillaEditView::appandGenericText(const TCHAR * text2Append) const
1948  {
1949  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1950  	size_t cp = execute(SCI_GETCODEPAGE);
1951  	const char *text2AppendA =wmc.wchar2char(text2Append, cp);
1952  	execute(SCI_APPENDTEXT, strlen(text2AppendA), reinterpret_cast<LPARAM>(text2AppendA));
1953  }
1954  void ScintillaEditView::addGenericText(const TCHAR * text2Append) const
1955  {
1956  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1957  	size_t cp = execute(SCI_GETCODEPAGE);
1958  	const char *text2AppendA =wmc.wchar2char(text2Append, cp);
1959  	execute(SCI_ADDTEXT, strlen(text2AppendA), reinterpret_cast<LPARAM>(text2AppendA));
1960  }
1961  void ScintillaEditView::addGenericText(const TCHAR * text2Append, intptr_t* mstart, intptr_t* mend) const
1962  {
1963  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1964  	size_t cp = execute(SCI_GETCODEPAGE);
1965  	const char *text2AppendA =wmc.wchar2char(text2Append, cp, mstart, mend);
1966  	execute(SCI_ADDTEXT, strlen(text2AppendA), reinterpret_cast<LPARAM>(text2AppendA));
1967  }
1968  intptr_t ScintillaEditView::replaceTarget(const TCHAR * str2replace, intptr_t fromTargetPos, intptr_t toTargetPos) const
1969  {
1970  	if (fromTargetPos != -1 || toTargetPos != -1)
1971  	{
1972  		execute(SCI_SETTARGETRANGE, fromTargetPos, toTargetPos);
1973  	}
1974  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1975  	size_t cp = execute(SCI_GETCODEPAGE);
1976  	const char *str2replaceA = wmc.wchar2char(str2replace, cp);
1977  	return execute(SCI_REPLACETARGET, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(str2replaceA));
1978  }
1979  intptr_t ScintillaEditView::replaceTargetRegExMode(const TCHAR * re, intptr_t fromTargetPos, intptr_t toTargetPos) const
1980  {
1981  	if (fromTargetPos != -1 || toTargetPos != -1)
1982  	{
1983  		execute(SCI_SETTARGETRANGE, fromTargetPos, toTargetPos);
1984  	}
1985  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1986  	size_t cp = execute(SCI_GETCODEPAGE);
1987  	const char *reA = wmc.wchar2char(re, cp);
1988  	return execute(SCI_REPLACETARGETRE, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(reA));
1989  }
1990  void ScintillaEditView::showAutoComletion(size_t lenEntered, const TCHAR* list)
1991  {
1992  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1993  	size_t cp = execute(SCI_GETCODEPAGE);
1994  	const char *listA = wmc.wchar2char(list, cp);
1995  	execute(SCI_AUTOCSHOW, lenEntered, reinterpret_cast<LPARAM>(listA));
1996  	NppDarkMode::setDarkAutoCompletion();
1997  }
1998  void ScintillaEditView::showCallTip(size_t startPos, const TCHAR * def)
1999  {
2000  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2001  	size_t cp = execute(SCI_GETCODEPAGE);
2002  	const char *defA = wmc.wchar2char(def, cp);
2003  	execute(SCI_CALLTIPSHOW, startPos, reinterpret_cast<LPARAM>(defA));
2004  }
2005  generic_string ScintillaEditView::getLine(size_t lineNumber)
2006  {
2007  	size_t lineLen = execute(SCI_LINELENGTH, lineNumber);
2008  	const size_t bufSize = lineLen + 1;
2009  	std::unique_ptr<TCHAR[]> buf = std::make_unique<TCHAR[]>(bufSize);
2010  	getLine(lineNumber, buf.get(), bufSize);
2011  	return buf.get();
2012  }
2013  void ScintillaEditView::getLine(size_t lineNumber, TCHAR * line, size_t lineBufferLen)
2014  {
2015  	size_t lineLen = execute(SCI_LINELENGTH, lineNumber);
2016  	if (lineLen >= lineBufferLen)
2017  		return;
2018  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2019  	size_t cp = execute(SCI_GETCODEPAGE);
2020  	char *lineA = new char[lineBufferLen];
2021  	memset(lineA, 0x0, sizeof(char) * lineBufferLen);
2022  	execute(SCI_GETLINE, lineNumber, reinterpret_cast<LPARAM>(lineA));
2023  	const TCHAR *lineW = wmc.char2wchar(lineA, cp);
2024  	lstrcpyn(line, lineW, static_cast<int>(lineBufferLen));
2025  	delete [] lineA;
2026  }
2027  void ScintillaEditView::addText(size_t length, const char *buf)
2028  {
2029  	execute(SCI_ADDTEXT, length, reinterpret_cast<LPARAM>(buf));
2030  }
2031  void ScintillaEditView::beginOrEndSelect(bool isColumnMode)
2032  {
2033  	if (_beginSelectPosition == -1)
2034  	{
2035  		_beginSelectPosition = execute(SCI_GETCURRENTPOS);
2036  	}
2037  	else
2038  	{
2039  		execute(SCI_SETSELECTIONMODE, static_cast<WPARAM>(isColumnMode ? SC_SEL_RECTANGLE : SC_SEL_STREAM));
2040  		execute(SCI_SETANCHOR, static_cast<WPARAM>(_beginSelectPosition));
2041  		_beginSelectPosition = -1;
2042  	}
2043  }
2044  void ScintillaEditView::showMargin(int whichMarge, bool willBeShowed)
2045  {
2046  	if (whichMarge == _SC_MARGE_LINENUMBER)
2047  	{
2048  		bool forcedToHide = !willBeShowed;
2049  		updateLineNumbersMargin(forcedToHide);
2050  	}
2051  	else
2052  	{
2053  		DPIManager& dpiManager = NppParameters::getInstance()._dpiManager;
2054  		int width = dpiManager.scaleX(3);
2055  		if (whichMarge == _SC_MARGE_SYMBOL)
2056  			width = dpiManager.scaleX(16);
2057  		else if (whichMarge == _SC_MARGE_FOLDER)
2058  			width = dpiManager.scaleX(14);
2059  		execute(SCI_SETMARGINWIDTHN, whichMarge, willBeShowed ? width : 0);
2060  	}
2061  }
2062  void ScintillaEditView::showChangeHistoryMargin(bool willBeShowed)
2063  {
2064  	DPIManager& dpiManager = NppParameters::getInstance()._dpiManager;
2065  	int	width = dpiManager.scaleX(9);
2066  	execute(SCI_SETMARGINWIDTHN, _SC_MARGE_CHANGEHISTORY, willBeShowed ? width : 0);
2067  }
2068  void ScintillaEditView::updateBeginEndSelectPosition(bool is_insert, size_t position, size_t length)
2069  {
2070  	if (_beginSelectPosition != -1 && static_cast<intptr_t>(position) < _beginSelectPosition - 1)
2071  	{
2072  		if (is_insert)
2073  			_beginSelectPosition += length;
2074  		else
2075  			_beginSelectPosition -= length;
2076  		assert(_beginSelectPosition >= 0);
2077  	}
2078  }
2079  void ScintillaEditView::marginClick(Sci_Position position, int modifiers)
2080  {
2081  	size_t lineClick = execute(SCI_LINEFROMPOSITION, position, 0);
2082  	intptr_t levelClick = execute(SCI_GETFOLDLEVEL, lineClick, 0);
2083  	if (levelClick & SC_FOLDLEVELHEADERFLAG)
2084      {
2085  		if (modifiers & SCMOD_SHIFT)
2086          {
2087  			execute(SCI_SETFOLDEXPANDED, lineClick, 1);
2088  			expand(lineClick, true, true, 100, levelClick);
2089  		}
2090          else if (modifiers & SCMOD_CTRL)
2091          {
2092  			if (isFolded(lineClick))
2093              {
2094  				execute(SCI_SETFOLDEXPANDED, lineClick, 0);
2095  				expand(lineClick, false, true, 0, levelClick);
2096  			}
2097              else
2098              {
2099  				execute(SCI_SETFOLDEXPANDED, lineClick, 1);
2100  				expand(lineClick, true, true, 100, levelClick);
2101  			}
2102  		}
2103          else
2104          {
2105  			bool mode = isFolded(lineClick);
2106  			fold(lineClick, !mode);
2107  			runMarkers(true, lineClick, true, false);
2108  		}
2109  	}
2110  }
2111  void ScintillaEditView::expand(size_t& line, bool doExpand, bool force, intptr_t visLevels, intptr_t level)
2112  {
2113  	size_t lineMaxSubord = execute(SCI_GETLASTCHILD, line, level & SC_FOLDLEVELNUMBERMASK);
2114  	++line;
2115  	while (line <= lineMaxSubord)
2116      {
2117  		if (force)
2118          {
2119  			execute(((visLevels > 0) ? SCI_SHOWLINES : SCI_HIDELINES), line, line);
2120  		}
2121          else
2122          {
2123  			if (doExpand)
2124  				execute(SCI_SHOWLINES, line, line);
2125  		}
2126  		intptr_t levelLine = level;
2127  		if (levelLine == -1)
2128  			levelLine = execute(SCI_GETFOLDLEVEL, line, 0);
2129  		if (levelLine & SC_FOLDLEVELHEADERFLAG)
2130          {
2131  			if (force)
2132              {
2133  				if (visLevels > 1)
2134  					execute(SCI_SETFOLDEXPANDED, line, 1);
2135  				else
2136  					execute(SCI_SETFOLDEXPANDED, line, 0);
2137  				expand(line, doExpand, force, visLevels - 1);
2138  			}
2139              else
2140              {
2141  				if (doExpand)
2142                  {
2143  					if (!isFolded(line))
2144  						execute(SCI_SETFOLDEXPANDED, line, 1);
2145  					expand(line, true, force, visLevels - 1);
2146  				}
2147                  else
2148  					expand(line, false, force, visLevels - 1);
2149  			}
2150  		}
2151          else
2152  			++line;
2153  	}
2154  	runMarkers(true, 0, true, false);
2155  }
2156  void ScintillaEditView::performGlobalStyles()
2157  {
2158  	NppParameters& nppParams = NppParameters::getInstance();
2159  	const ScintillaViewParams& svp = nppParams.getSVP();
2160  	StyleArray& stylers = nppParams.getMiscStylerArray();
2161  	const Style* pStyle{};
2162  	if (svp._currentLineHiliteMode != LINEHILITE_NONE)
2163  	{
2164  		pStyle = stylers.findByName(TEXT("Current line background colour"));
2165  		if (pStyle)
2166  		{
2167  			execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, pStyle->_bgColor);
2168  		}
2169  	}
2170  	execute(SCI_SETCARETLINEFRAME, (svp._currentLineHiliteMode == LINEHILITE_FRAME) ? svp._currentLineFrameWidth : 0);
2171  	COLORREF selectColorBack = grey;
2172  	COLORREF selectColorFore = black;
2173  	pStyle = stylers.findByName(TEXT("Selected text colour"));
2174  	if (pStyle)
2175  	{
2176  		selectColorBack = pStyle->_bgColor;
2177  		selectColorFore = pStyle->_fgColor;
2178  	}
2179  	execute(SCI_SETSELBACK, 1, selectColorBack);
2180  	execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_SELECTION_INACTIVE_BACK, selectColorBack);
2181  	if (nppParams.isSelectFgColorEnabled())
2182  	{
2183  		execute(SCI_SETSELFORE, 1, selectColorFore);
2184  		long alphaSelectColorFore = selectColorFore;
2185  		alphaSelectColorFore |= 0xFF000000; 
2186  		execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_SELECTION_INACTIVE_TEXT, alphaSelectColorFore);
2187  	}
2188  	COLORREF caretColor = black;
2189  	pStyle = stylers.findByID(SCI_SETCARETFORE);
2190  	if (pStyle)
2191  	{
2192  		caretColor = pStyle->_fgColor;
2193  	}
2194  	execute(SCI_SETCARETFORE, caretColor);
2195  	COLORREF edgeColor = liteGrey;
2196  	pStyle = stylers.findByName(TEXT("Edge colour"));
2197  	if (pStyle)
2198  	{
2199  		edgeColor = pStyle->_fgColor;
2200  	}
2201  	execute(SCI_SETEDGECOLOUR, edgeColor);
2202  	::SendMessage(_hParent, NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
2203  	COLORREF foldMarginColor = grey;
2204  	COLORREF foldMarginHiColor = white;
2205  	pStyle = stylers.findByName(TEXT("Fold margin"));
2206  	if (pStyle)
2207  	{
2208  		foldMarginHiColor = pStyle->_fgColor;
2209  		foldMarginColor = pStyle->_bgColor;
2210  	}
2211  	execute(SCI_SETFOLDMARGINCOLOUR, true, foldMarginColor);
2212  	execute(SCI_SETFOLDMARGINHICOLOUR, true, foldMarginHiColor);
2213  	COLORREF bookmarkMarginColor = veryLiteGrey;
2214  	pStyle = stylers.findByName(TEXT("Bookmark margin"));
2215  	if (!pStyle)
2216  	{
2217  		pStyle = stylers.findByName(TEXT("Line number margin")); 
2218  		if (pStyle)                                              
2219  		{
2220  			bookmarkMarginColor = pStyle->_bgColor;
2221  		}
2222  	}
2223  	else
2224  	{
2225  		bookmarkMarginColor = pStyle->_bgColor;
2226  	}
2227  	execute(SCI_SETMARGINTYPEN, _SC_MARGE_SYMBOL, SC_MARGIN_COLOUR);
2228  	execute(SCI_SETMARGINBACKN, _SC_MARGE_SYMBOL, bookmarkMarginColor);
2229  	COLORREF changeHistoryMarginColor = veryLiteGrey;
2230  	pStyle = stylers.findByName(TEXT("Change History margin"));
2231  	if (!pStyle)
2232  	{
2233  		pStyle = stylers.findByName(TEXT("Line number margin"));
2234  		if (pStyle)
2235  		{
2236  			changeHistoryMarginColor = pStyle->_bgColor;
2237  		}
2238  	}
2239  	else
2240  	{
2241  		changeHistoryMarginColor = pStyle->_bgColor;
2242  	}
2243  	execute(SCI_SETMARGINTYPEN, _SC_MARGE_CHANGEHISTORY, SC_MARGIN_COLOUR);
2244  	execute(SCI_SETMARGINBACKN, _SC_MARGE_CHANGEHISTORY, changeHistoryMarginColor);
2245  	COLORREF urlHoveredFG = grey;
2246  	pStyle = stylers.findByName(TEXT("URL hovered"));
2247  	if (pStyle)
2248  	{
2249  		urlHoveredFG = pStyle->_fgColor;
2250  	}
2251  	execute(SCI_INDICSETHOVERFORE, URL_INDIC, urlHoveredFG);
2252  	COLORREF foldfgColor = white, foldbgColor = grey, activeFoldFgColor = red;
2253  	getFoldColor(foldfgColor, foldbgColor, activeFoldFgColor);
2254  	for (int j = 0 ; j < NB_FOLDER_STATE ; ++j)
2255  		defineMarker(_markersArray[FOLDER_TYPE][j], _markersArray[svp._folderStyle][j], foldfgColor, foldbgColor, activeFoldFgColor);
2256  	execute(SCI_MARKERENABLEHIGHLIGHT, true);
2257  	COLORREF wsSymbolFgColor = black;
2258  	pStyle = stylers.findByName(TEXT("White space symbol"));
2259  	if (pStyle)
2260  	{
2261  		wsSymbolFgColor = pStyle->_fgColor;
2262  	}
2263  	execute(SCI_SETWHITESPACEFORE, true, wsSymbolFgColor);
2264  	COLORREF eolCustomColor = liteGrey;
2265  	pStyle = stylers.findByName(TEXT("EOL custom color"));
2266  	if (pStyle)
2267  	{
2268  		eolCustomColor = pStyle->_fgColor;
2269  	}
2270  	setCRLF(eolCustomColor);
2271  	COLORREF npcCustomColor = liteGrey;
2272  	pStyle = stylers.findByName(g_npcStyleName);
2273  	if (pStyle)
2274  	{
2275  		npcCustomColor = pStyle->_fgColor;
2276  	}
2277  	setNpcAndCcUniEOL(npcCustomColor);
2278  }
2279  void ScintillaEditView::showNpc(bool willBeShowed, bool isSearchResult)
2280  {
2281  	auto& svp = NppParameters::getInstance().getSVP();
2282  	if (willBeShowed)
2283  	{
2284  		const auto& mode = static_cast<size_t>(svp._npcMode);
2285  		for (const auto& invChar : g_nonPrintingChars)
2286  		{
2287  			execute(SCI_SETREPRESENTATION, reinterpret_cast<WPARAM>(invChar.at(0)), reinterpret_cast<LPARAM>(invChar.at(mode)));
2288  		}
2289  		if (svp._npcCustomColor)
2290  		{
2291  			setNpcAndCcUniEOL();
2292  		}
2293  	}
2294  	else
2295  	{
2296  		execute(SCI_CLEARALLREPRESENTATIONS);
2297  		if (!isSearchResult && svp._eolMode != svp.roundedRectangleText)
2298  		{
2299  			setCRLF();
2300  		}
2301  		showCcUniEol(svp._ccUniEolShow);
2302  	}
2303  	showEOL(isShownEol());
2304  }
2305  void ScintillaEditView::showCcUniEol(bool willBeShowed, bool isSearchResult)
2306  {
2307  	auto& svp = NppParameters::getInstance().getSVP();
2308  	if (willBeShowed)
2309  	{
2310  		const auto& mode = static_cast<size_t>(svp._npcIncludeCcUniEol ? svp._npcMode : ScintillaViewParams::npcMode::abbreviation);
2311  		for (const auto& invChar : g_ccUniEolChars)
2312  		{
2313  			execute(SCI_SETREPRESENTATION, reinterpret_cast<WPARAM>(invChar.at(0)), reinterpret_cast<LPARAM>(invChar.at(mode)));
2314  		}
2315  		if (svp._npcIncludeCcUniEol && svp._npcCustomColor)
2316  		{
2317  			setNpcAndCcUniEOL();
2318  		}
2319  	}
2320  	else
2321  	{
2322  		execute(SCI_CLEARALLREPRESENTATIONS);
2323  		for (const auto& invChar : g_ccUniEolChars)
2324  		{
2325  			execute(SCI_SETREPRESENTATION, reinterpret_cast<WPARAM>(invChar.at(0)), reinterpret_cast<LPARAM>(g_ZWSP));
2326  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(invChar.at(0)), SC_REPRESENTATION_PLAIN);
2327  		}
2328  		if (!isSearchResult && svp._eolMode != svp.roundedRectangleText)
2329  		{
2330  			setCRLF();
2331  		}
2332  		if (svp._npcShow)
2333  		{
2334  			showNpc();
2335  		}
2336  	}
2337  	showEOL(isShownEol());
2338  }
2339  void ScintillaEditView::showIndentGuideLine(bool willBeShowed)
2340  {
2341  	auto typeDoc = _currentBuffer->getLangType();
2342  	const int docIndentMode = isPythonStyleIndentation(typeDoc) ? SC_IV_LOOKFORWARD : SC_IV_LOOKBOTH;
2343  	execute(SCI_SETINDENTATIONGUIDES, willBeShowed ? docIndentMode : SC_IV_NONE);
2344  }
2345  void ScintillaEditView::setLineIndent(size_t line, size_t indent) const
2346  {
2347  	Sci_CharacterRangeFull crange = getSelection();
2348  	int64_t posBefore = execute(SCI_GETLINEINDENTPOSITION, line);
2349  	execute(SCI_SETLINEINDENTATION, line, indent);
2350  	int64_t posAfter = execute(SCI_GETLINEINDENTPOSITION, line);
2351  	long long posDifference = posAfter - posBefore;
2352  	if (posAfter > posBefore)
2353  	{
2354  		if (crange.cpMin >= posBefore)
2355  		{
2356  			crange.cpMin += static_cast<Sci_Position>(posDifference);
2357  		}
2358  		if (crange.cpMax >= posBefore)
2359  		{
2360  			crange.cpMax += static_cast<Sci_Position>(posDifference);
2361  		}
2362  	}
2363  	else if (posAfter < posBefore)
2364  	{
2365  		if (crange.cpMin >= posAfter)
2366  		{
2367  			if (crange.cpMin >= posBefore)
2368  				crange.cpMin += static_cast<Sci_Position>(posDifference);
2369  			else
2370  				crange.cpMin = static_cast<Sci_Position>(posAfter);
2371  		}
2372  		if (crange.cpMax >= posAfter)
2373  		{
2374  			if (crange.cpMax >= posBefore)
2375  				crange.cpMax += static_cast<Sci_Position>(posDifference);
2376  			else
2377  				crange.cpMax = static_cast<Sci_Position>(posAfter);
2378  		}
2379  	}
2380  	execute(SCI_SETSEL, crange.cpMin, crange.cpMax);
2381  }
2382  void ScintillaEditView::updateLineNumberWidth()
2383  {
2384  	const ScintillaViewParams& svp = NppParameters::getInstance().getSVP();
2385  	if (svp._lineNumberMarginShow)
2386  	{
2387  		auto linesVisible = execute(SCI_LINESONSCREEN);
2388  		if (linesVisible)
2389  		{
2390  			int nbDigits = 0;
2391  			if (svp._lineNumberMarginDynamicWidth)
2392  			{
2393  				auto firstVisibleLineVis = execute(SCI_GETFIRSTVISIBLELINE);
2394  				auto lastVisibleLineVis = linesVisible + firstVisibleLineVis + 1;
2395  				auto lastVisibleLineDoc = execute(SCI_DOCLINEFROMVISIBLE, lastVisibleLineVis);
2396  				nbDigits = nbDigitsFromNbLines(lastVisibleLineDoc);
2397  				nbDigits = nbDigits < 3 ? 3 : nbDigits;
2398  			}
2399  			else
2400  			{
2401  				auto nbLines = execute(SCI_GETLINECOUNT);
2402  				nbDigits = nbDigitsFromNbLines(nbLines);
2403  				nbDigits = nbDigits < 4 ? 4 : nbDigits;
2404  			}
2405  			auto pixelWidth = 8 + nbDigits * execute(SCI_TEXTWIDTH, STYLE_LINENUMBER, reinterpret_cast<LPARAM>("8"));
2406  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, pixelWidth);
2407  		}
2408  	}
2409  }
2410  const char * ScintillaEditView::getCompleteKeywordList(std::basic_string<char> & kwl, LangType langType, int keywordIndex)
2411  {
2412  	kwl += " ";
2413  	const TCHAR *defKwl_generic = NppParameters::getInstance().getWordList(langType, keywordIndex);
2414  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2415  	const char * defKwl = wmc.wchar2char(defKwl_generic, CP_ACP);
2416  	kwl += defKwl?defKwl:"";
2417  	return kwl.c_str();
2418  }
2419  void ScintillaEditView::setMultiSelections(const ColumnModeInfos & cmi)
2420  {
2421  	for (size_t i = 0, len = cmi.size(); i < len ; ++i)
2422  	{
2423  		if (cmi[i].isValid())
2424  		{
2425  			intptr_t selStart = cmi[i]._direction == L2R?cmi[i]._selLpos:cmi[i]._selRpos;
2426  			intptr_t selEnd   = cmi[i]._direction == L2R?cmi[i]._selRpos:cmi[i]._selLpos;
2427  			execute(SCI_SETSELECTIONNSTART, i, selStart);
2428  			execute(SCI_SETSELECTIONNEND, i, selEnd);
2429  		}
2430  		if (cmi[i]._nbVirtualAnchorSpc)
2431  			execute(SCI_SETSELECTIONNANCHORVIRTUALSPACE, i, cmi[i]._nbVirtualAnchorSpc);
2432  		if (cmi[i]._nbVirtualCaretSpc)
2433  			execute(SCI_SETSELECTIONNCARETVIRTUALSPACE, i, cmi[i]._nbVirtualCaretSpc);
2434  	}
2435  }
2436  pair<size_t, size_t> ScintillaEditView::getSelectionLinesRange(intptr_t selectionNumber &bsol;* = -1 */) const
2437  {
2438  	size_t numSelections = execute(SCI_GETSELECTIONS);
2439  	size_t start_pos, end_pos;
2440  	if ((selectionNumber < 0) || (static_cast<size_t>(selectionNumber) >= numSelections))
2441  	{
2442  		start_pos = execute(SCI_GETSELECTIONSTART);
2443  		end_pos = execute(SCI_GETSELECTIONEND);
2444  	}
2445  	else
2446  	{
2447  		start_pos = execute(SCI_GETSELECTIONNSTART, selectionNumber);
2448  		end_pos = execute(SCI_GETSELECTIONNEND, selectionNumber);
2449  	}
2450  	size_t line1 = execute(SCI_LINEFROMPOSITION, start_pos);
2451  	size_t line2 = execute(SCI_LINEFROMPOSITION, end_pos);
2452  	if ((line1 != line2) && (static_cast<size_t>(execute(SCI_POSITIONFROMLINE, line2)) == end_pos))
2453  	{
2454  		--line2;
2455  	}
2456  	return pair<size_t, size_t>(line1, line2);
2457  }
2458  void ScintillaEditView::currentLinesUp() const
2459  {
2460  	execute(SCI_MOVESELECTEDLINESUP);
2461  }
2462  void ScintillaEditView::currentLinesDown() const
2463  {
2464  	execute(SCI_MOVESELECTEDLINESDOWN);
2465  	execute(SCI_SCROLLRANGE, execute(SCI_GETSELECTIONEND), execute(SCI_GETSELECTIONSTART));
2466  }
2467  intptr_t ScintillaEditView::caseConvertRange(intptr_t start, intptr_t end, TextCase caseToConvert)
2468  {
2469  	if (end <= start || uintptr_t(end) - uintptr_t(start) > INT_MAX/2)
2470  		return 0;
2471  	unsigned codepage = getCurrentBuffer()->getUnicodeMode() == uni8Bit ? _codepage : CP_UTF8;
2472  	int mbLen = int(end - start);
2473  	const int mbLenMax = 2 * mbLen + 1;  
2474  	char *mbStr = new char[mbLenMax];
2475  	getText(mbStr, start, end);
2476  	if (int wideLen = ::MultiByteToWideChar(codepage, 0, mbStr, mbLen, NULL, 0))
2477  	{
2478  		wchar_t *wideStr = new wchar_t[wideLen];  
2479  		::MultiByteToWideChar(codepage, 0, mbStr, mbLen, wideStr, wideLen);
2480  		changeCase(wideStr, wideLen, caseToConvert);
2481  		if (int mbLenOut = ::WideCharToMultiByte(codepage, 0, wideStr, wideLen, mbStr, mbLenMax, NULL, NULL))
2482  		{
2483  			mbLen = mbLenOut;
2484  			execute(SCI_SETTARGETRANGE, start, end);
2485  			execute(SCI_REPLACETARGET, mbLen, reinterpret_cast<LPARAM>(mbStr));
2486  		}
2487  		delete [] wideStr;
2488  	}
2489  	delete [] mbStr;
2490  	return (start + mbLen) - end;
2491  }
2492  void ScintillaEditView::changeCase(__inout wchar_t * const strWToConvert, const int & nbChars, const TextCase & caseToConvert) const
2493  {
2494  	if (strWToConvert == nullptr || nbChars == 0)
2495  		return;
2496  	switch (caseToConvert)
2497  	{
2498  		case UPPERCASE:
2499  		{
2500  			for (int i = 0; i < nbChars; ++i)
2501  			{
2502  				strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2503  			}
2504  			break; 
2505  		} 
2506  		case LOWERCASE:
2507  		{
2508  			for (int i = 0; i < nbChars; ++i)
2509  			{
2510  				strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2511  			}
2512  			break; 
2513  		} 
2514  		case TITLECASE_FORCE:
2515  		case TITLECASE_BLEND:
2516  		{
2517  			for (int i = 0; i < nbChars; ++i)
2518  			{
2519  				if (::IsCharAlphaW(strWToConvert[i]))
2520  				{
2521  					if ((i < 1) ? true : !::IsCharAlphaNumericW(strWToConvert[i - 1]))
2522  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2523  					else if (caseToConvert == TITLECASE_FORCE)
2524  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2525  					if ((i < 2) ? false : (strWToConvert[i - 1] == L'\'' && ::IsCharAlphaW(strWToConvert[i - 2])))
2526  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2527  				}
2528  			}
2529  			break; 
2530  		} 
2531  		case SENTENCECASE_FORCE:
2532  		case SENTENCECASE_BLEND:
2533  		{
2534  			bool isNewSentence = true;
2535  			bool wasEolR = false;
2536  			bool wasEolN = false;
2537  			for (int i = 0; i < nbChars; ++i)
2538  			{
2539  				if (::IsCharAlphaW(strWToConvert[i]))
2540  				{
2541  					if (isNewSentence)
2542  					{
2543  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2544  						isNewSentence = false;
2545  					}
2546  					else if (caseToConvert == SENTENCECASE_FORCE)
2547  					{
2548  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2549  					}
2550  					wasEolR = false;
2551  					wasEolN = false;
2552  					if (strWToConvert[i] == L'i' &&
2553  						((i < 1) ? false : (::iswspace(strWToConvert[i - 1]) || strWToConvert[i - 1] == L'(' || strWToConvert[i - 1] == L'"')) &&
2554  						((i + 1 == nbChars) ? false : (::iswspace(strWToConvert[i + 1]) || strWToConvert[i + 1] == L'\'')))
2555  					{
2556  						strWToConvert[i] = L'I';
2557  					}
2558  				}
2559  				else if (strWToConvert[i] == L'.' || strWToConvert[i] == L'!' || strWToConvert[i] == L'?')
2560  				{
2561  					if ((i + 1 == nbChars) ? true : ::IsCharAlphaNumericW(strWToConvert[i + 1]))
2562  						isNewSentence = false;
2563  					else
2564  						isNewSentence = true;
2565  				}
2566  				else if (strWToConvert[i] == L'\r')
2567  				{
2568  					if (wasEolR)
2569  						isNewSentence = true;
2570  					else
2571  						wasEolR = true;
2572  				}
2573  				else if (strWToConvert[i] == L'\n')
2574  				{
2575  					if (wasEolN)
2576  						isNewSentence = true;
2577  					else
2578  						wasEolN = true;
2579  				}
2580  			}
2581  			break;
2582  		} 
2583  		case INVERTCASE:
2584  		{
2585  			for (int i = 0; i < nbChars; ++i)
2586  			{
2587  				if (::IsCharLowerW(strWToConvert[i]))
2588  					strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2589  				else
2590  					strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2591  			}
2592  			break; 
2593  		} 
2594  		case RANDOMCASE:
2595  		{
2596  			for (int i = 0; i < nbChars; ++i)
2597  			{
2598  				if (::IsCharAlphaW(strWToConvert[i]))
2599  				{
2600  					if (std::rand() & true)
2601  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2602  					else
2603  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2604  				}
2605  			}
2606  			break; 
2607  		} 
2608  	} 
2609  }
2610  void ScintillaEditView::convertSelectedTextTo(const TextCase & caseToConvert)
2611  {
2612  	if (execute(SCI_GETSELECTIONS) > 1) 
2613  	{
2614          execute(SCI_BEGINUNDOACTION);
2615  		ColumnModeInfos cmi = getColumnModeSelectInfo();
2616  		bool reversed = !cmi.empty() && cmi.back()._selLpos < cmi.front()._selLpos;
2617  		std::sort(cmi.begin(), cmi.end(), SortInPositionOrder());
2618  		intptr_t sizedelta = 0;
2619  		for (ColumnModeInfo& info : cmi)
2620  		{
2621  			info._selLpos += sizedelta;
2622  			sizedelta += caseConvertRange(info._selLpos, info._selRpos + sizedelta, caseToConvert);
2623  			info._selRpos += sizedelta;
2624  		}
2625  		if (reversed)
2626  			std::reverse(cmi.begin(), cmi.end());
2627  		setMultiSelections(cmi);
2628  		execute(SCI_ENDUNDOACTION);
2629  		return;
2630  	}
2631  	size_t selectionStart = execute(SCI_GETSELECTIONSTART);
2632  	size_t selectionEnd = execute(SCI_GETSELECTIONEND);
2633  	if (selectionStart < selectionEnd)
2634  	{
2635  		selectionEnd += caseConvertRange(selectionStart, selectionEnd, caseToConvert);
2636  		execute(SCI_SETSEL, selectionStart, selectionEnd);
2637  	}
2638  }
2639  pair<size_t, size_t> ScintillaEditView::getWordRange()
2640  {
2641  	size_t caretPos = execute(SCI_GETCURRENTPOS, 0, 0);
2642  	size_t startPos = execute(SCI_WORDSTARTPOSITION, caretPos, true);
2643  	size_t endPos = execute(SCI_WORDENDPOSITION, caretPos, true);
2644      return pair<size_t, size_t>(startPos, endPos);
2645  }
2646  bool ScintillaEditView::expandWordSelection()
2647  {
2648      pair<size_t, size_t> wordRange = 	getWordRange();
2649      if (wordRange.first != wordRange.second)
2650  	{
2651          execute(SCI_SETSELECTIONSTART, wordRange.first);
2652          execute(SCI_SETSELECTIONEND, wordRange.second);
2653  		return true;
2654  	}
2655  	return false;
2656  }
2657  TCHAR* int2str(TCHAR* str, int strLen, int number, int base, int nbDigits, ColumnEditorParam::leadingChoice lead)
2658  {
2659  	if (nbDigits >= strLen) return NULL;
2660  	if (base == 2)
2661  	{
2662  		const unsigned int MASK_ULONG_BITFORT = 0x80000000;
2663  		int nbBits = sizeof(unsigned int) * 8;
2664  		int nbBit2Shift = (nbDigits >= nbBits) ? nbBits : (nbBits - nbDigits);
2665  		unsigned long mask = MASK_ULONG_BITFORT >> nbBit2Shift;
2666  		int i = 0;
2667  		for (; mask > 0; ++i)
2668  		{
2669  			str[i] = (mask & number) ? '1' : '0';
2670  			mask >>= 1;
2671  		}
2672  		str[i] = '\0';
2673  		if (lead == ColumnEditorParam::spaceLeading)
2674  		{
2675  			for (TCHAR* j = str; *j != '\0'; ++j)
2676  			{
2677  				if ((*j == '1') || (*(j + 1) == '\0'))
2678  				{
2679  					break;
2680  				}
2681  				else
2682  				{
2683  					*j = ' ';
2684  				}
2685  			}
2686  		}
2687  		else if (lead != ColumnEditorParam::zeroLeading)
2688  		{
2689  			for (TCHAR* j = str; *j != '\0'; ++j)
2690  			{
2691  				if (*j == '1' || *(j + 1) == '\0')
2692  				{
2693  					wcscpy_s(str, strLen, j);
2694  					break;
2695  				}
2696  			}
2697  			int i = lstrlen(str);
2698  			for (; i < nbDigits; ++i)
2699  			{
2700  				str[i] = ' ';
2701  			}
2702  			str[i] = '\0';
2703  		}
2704  	}
2705  	else
2706  	{
2707  		constexpr size_t bufSize = 64;
2708  		TCHAR f[bufSize] = { '\0' };
2709  		TCHAR fStr[2] = TEXT("d");
2710  		if (base == 16)
2711  			fStr[0] = 'X';
2712  		else if (base == 8)
2713  			fStr[0] = 'o';
2714  		if (lead == ColumnEditorParam::zeroLeading)
2715  		{
2716  			swprintf(f, bufSize, TEXT("%%.%d%s"), nbDigits, fStr);
2717  		}
2718  		else if (lead == ColumnEditorParam::spaceLeading)
2719  		{
2720  			swprintf(f, bufSize, TEXT("%%%d%s"), nbDigits, fStr);
2721  		}
2722  		else
2723  		{
2724  			swprintf(f, bufSize, TEXT("%%-%d%s"), nbDigits, fStr);
2725  		}
2726  		swprintf(str, strLen, f, number);
2727  	}
2728  	return str;
2729  }
2730  ColumnModeInfos ScintillaEditView::getColumnModeSelectInfo()
2731  {
2732  	ColumnModeInfos columnModeInfos;
2733  	if (execute(SCI_GETSELECTIONS) > 1) 
2734  	{
2735  		intptr_t nbSel = execute(SCI_GETSELECTIONS);
2736  		for (int i = 0 ; i < nbSel ; ++i)
2737  		{
2738  			intptr_t absPosSelStartPerLine = execute(SCI_GETSELECTIONNANCHOR, i);
2739  			intptr_t absPosSelEndPerLine = execute(SCI_GETSELECTIONNCARET, i);
2740  			intptr_t nbVirtualAnchorSpc = execute(SCI_GETSELECTIONNANCHORVIRTUALSPACE, i);
2741  			intptr_t nbVirtualCaretSpc = execute(SCI_GETSELECTIONNCARETVIRTUALSPACE, i);
2742  			if (absPosSelStartPerLine == absPosSelEndPerLine && execute(SCI_SELECTIONISRECTANGLE))
2743  			{
2744  				bool dir = nbVirtualAnchorSpc<nbVirtualCaretSpc?L2R:R2L;
2745  				columnModeInfos.push_back(ColumnModeInfo(absPosSelStartPerLine, absPosSelEndPerLine, i, dir, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2746  			}
2747  			else if (absPosSelStartPerLine > absPosSelEndPerLine)
2748  				columnModeInfos.push_back(ColumnModeInfo(absPosSelEndPerLine, absPosSelStartPerLine, i, R2L, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2749  			else
2750  				columnModeInfos.push_back(ColumnModeInfo(absPosSelStartPerLine, absPosSelEndPerLine, i, L2R, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2751  		}
2752  	}
2753  	return columnModeInfos;
2754  }
2755  void ScintillaEditView::columnReplace(ColumnModeInfos & cmi, const TCHAR *str)
2756  {
2757  	intptr_t totalDiff = 0;
2758  	for (size_t i = 0, len = cmi.size(); i < len ; ++i)
2759  	{
2760  		if (cmi[i].isValid())
2761  		{
2762  			intptr_t len2beReplace = cmi[i]._selRpos - cmi[i]._selLpos;
2763  			intptr_t diff = lstrlen(str) - len2beReplace;
2764  			cmi[i]._selLpos += totalDiff;
2765  			cmi[i]._selRpos += totalDiff;
2766  			bool hasVirtualSpc = cmi[i]._nbVirtualAnchorSpc > 0;
2767  			if (hasVirtualSpc) 
2768  			{
2769  				for (intptr_t j = 0, k = cmi[i]._selLpos; j < cmi[i]._nbVirtualCaretSpc ; ++j, ++k)
2770  				{
2771  					execute(SCI_INSERTTEXT, k, reinterpret_cast<LPARAM>(" "));
2772  				}
2773  				cmi[i]._selLpos += cmi[i]._nbVirtualAnchorSpc;
2774  				cmi[i]._selRpos += cmi[i]._nbVirtualCaretSpc;
2775  			}
2776  			execute(SCI_SETTARGETRANGE, cmi[i]._selLpos, cmi[i]._selRpos);
2777  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2778  			size_t cp = execute(SCI_GETCODEPAGE);
2779  			const char *strA = wmc.wchar2char(str, cp);
2780  			execute(SCI_REPLACETARGET, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(strA));
2781  			if (hasVirtualSpc)
2782  			{
2783  				totalDiff += cmi[i]._nbVirtualAnchorSpc + lstrlen(str);
2784  				cmi[i]._nbVirtualAnchorSpc = 0;
2785  				cmi[i]._nbVirtualCaretSpc = 0;
2786  			}
2787  			else
2788  			{
2789  				totalDiff += diff;
2790  			}
2791  			cmi[i]._selRpos += diff;
2792  		}
2793  	}
2794  }
2795  void ScintillaEditView::columnReplace(ColumnModeInfos & cmi, int initial, int incr, int repeat, UCHAR format, ColumnEditorParam::leadingChoice lead)
2796  {
2797  	assert(repeat > 0);
2798  	if (cmi.size() <= 0)
2799  		return;
2800  	UCHAR f = format & MASK_FORMAT;
2801  	int base = 10;
2802  	if (f == BASE_16)
2803  		base = 16;
2804  	else if (f == BASE_08)
2805  		base = 8;
2806  	else if (f == BASE_02)
2807  		base = 2;
2808  	const int stringSize = 512;
2809  	TCHAR str[stringSize];
2810  	std::vector<int> numbers;
2811  	{
2812  		int curNumber = initial;
2813  		const size_t kiMaxSize = cmi.size();
2814  		while (numbers.size() < kiMaxSize)
2815  		{
2816  			for (int i = 0; i < repeat; i++)
2817  			{
2818  				numbers.push_back(curNumber);
2819  				if (numbers.size() >= kiMaxSize)
2820  				{
2821  					break;
2822  				}
2823  			}
2824  			curNumber += incr;
2825  		}
2826  	}
2827  	assert(numbers.size()> 0);
2828  	const int kibEnd = getNbDigits(*numbers.rbegin(), base);
2829  	const int kibInit = getNbDigits(initial, base);
2830  	const int kib = std::max<int>(kibInit, kibEnd);
2831  	intptr_t totalDiff = 0;
2832  	const size_t len = cmi.size();
2833  	for (size_t i = 0 ; i < len ; i++)
2834  	{
2835  		if (cmi[i].isValid())
2836  		{
2837  			const intptr_t len2beReplaced = cmi[i]._selRpos - cmi[i]._selLpos;
2838  			const intptr_t diff = kib - len2beReplaced;
2839  			cmi[i]._selLpos += totalDiff;
2840  			cmi[i]._selRpos += totalDiff;
2841  			int2str(str, stringSize, numbers.at(i), base, kib, lead);
2842  			const bool hasVirtualSpc = cmi[i]._nbVirtualAnchorSpc > 0;
2843  			if (hasVirtualSpc) 
2844  			{
2845  				for (intptr_t j = 0, k = cmi[i]._selLpos; j < cmi[i]._nbVirtualCaretSpc ; ++j, ++k)
2846  				{
2847  					execute(SCI_INSERTTEXT, k, reinterpret_cast<LPARAM>(" "));
2848  				}
2849  				cmi[i]._selLpos += cmi[i]._nbVirtualAnchorSpc;
2850  				cmi[i]._selRpos += cmi[i]._nbVirtualCaretSpc;
2851  			}
2852  			execute(SCI_SETTARGETRANGE, cmi[i]._selLpos, cmi[i]._selRpos);
2853  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2854  			size_t cp = execute(SCI_GETCODEPAGE);
2855  			const char *strA = wmc.wchar2char(str, cp);
2856  			execute(SCI_REPLACETARGET, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(strA));
2857  			if (hasVirtualSpc)
2858  			{
2859  				totalDiff += cmi[i]._nbVirtualAnchorSpc + lstrlen(str);
2860  				cmi[i]._nbVirtualAnchorSpc = 0;
2861  				cmi[i]._nbVirtualCaretSpc = 0;
2862  			}
2863  			else
2864  			{
2865  				totalDiff += diff;
2866  			}
2867  			cmi[i]._selRpos += diff;
2868  		}
2869  	}
2870  }
2871  bool ScintillaEditView::getIndicatorRange(size_t indicatorNumber, size_t* from, size_t* to, size_t* cur)
2872  {
2873  	size_t curPos = execute(SCI_GETCURRENTPOS);
2874  	size_t indicMsk = execute(SCI_INDICATORALLONFOR, curPos);
2875  	if (!(static_cast<int>(indicMsk) & (1 << indicatorNumber)))
2876  		return false;
2877  	size_t startPos = execute(SCI_INDICATORSTART, indicatorNumber, curPos);
2878  	size_t endPos = execute(SCI_INDICATOREND, indicatorNumber, curPos);
2879  	if ((curPos < startPos) || (curPos > endPos))
2880  		return false;
2881  	if (from) *from = startPos;
2882  	if (to) *to = endPos;
2883  	if (cur) *cur = curPos;
2884  	return true;
2885  }
2886  void ScintillaEditView::scrollPosToCenter(size_t pos)
2887  {
2888  	_positionRestoreNeeded = false;
2889  	execute(SCI_GOTOPOS, pos);
2890  	size_t line = execute(SCI_LINEFROMPOSITION, pos);
2891  	size_t firstVisibleDisplayLine = execute(SCI_GETFIRSTVISIBLELINE);
2892  	size_t firstVisibleDocLine = execute(SCI_DOCLINEFROMVISIBLE, firstVisibleDisplayLine);
2893  	size_t nbLine = execute(SCI_LINESONSCREEN, firstVisibleDisplayLine);
2894  	size_t lastVisibleDocLine = execute(SCI_DOCLINEFROMVISIBLE, firstVisibleDisplayLine + nbLine);
2895  	size_t middleLine;
2896  	if (line - firstVisibleDocLine < lastVisibleDocLine - line)
2897  		middleLine = firstVisibleDocLine + nbLine/2;
2898  	else
2899  		middleLine = lastVisibleDocLine -  nbLine/2;
2900  	size_t nbLines2scroll =  line - middleLine;
2901  	scroll(0, nbLines2scroll);
2902  	execute(SCI_ENSUREVISIBLEENFORCEPOLICY, line);
2903  }
2904  void ScintillaEditView::hideLines()
2905  {
2906  	size_t startLine = execute(SCI_LINEFROMPOSITION, execute(SCI_GETSELECTIONSTART));
2907  	size_t endLine = execute(SCI_LINEFROMPOSITION, execute(SCI_GETSELECTIONEND));
2908  	size_t nbLines = execute(SCI_GETLINECOUNT);
2909  	if (nbLines < 3)
2910  		return;	
2911  	if (!startLine)
2912  		++startLine;
2913  	if (endLine == (nbLines-1))
2914  		--endLine;
2915  	if (startLine > endLine)
2916  		return;	
2917  	int scope = 0;
2918  	bool recentMarkerWasOpen = false;
2919  	auto removeMarker = [this, &scope, &recentMarkerWasOpen](size_t line)
2920  	{
2921  		auto state = execute(SCI_MARKERGET, line);
2922  		bool closePresent = (state & (1 << MARK_HIDELINESEND)) != 0;
2923  		bool openPresent = (state & (1 << MARK_HIDELINESBEGIN)) != 0;
2924  		if (closePresent)
2925  		{
2926  			execute(SCI_MARKERDELETE, line, MARK_HIDELINESEND);
2927  			recentMarkerWasOpen = false;
2928  			--scope;
2929  		}
2930  		if (openPresent)
2931  		{
2932  			execute(SCI_MARKERDELETE, line, MARK_HIDELINESBEGIN);
2933  			recentMarkerWasOpen = true;
2934  			++scope;
2935  		}
2936  	};
2937  	size_t startMarker = startLine - 1;
2938  	size_t endMarker = endLine + 1;
2939  	for (size_t i = startMarker; i <= endMarker; ++i)
2940  		removeMarker(i);
2941  	if (scope == 0 && recentMarkerWasOpen)
2942  	{
2943  		while (scope == 0)
2944  			removeMarker(--startMarker);
2945  		while (scope != 0)
2946  			removeMarker(++endMarker);
2947  	}
2948  	else
2949  	{
2950  		while (scope < 0)
2951  			removeMarker(--startMarker);
2952  		while (scope > 0)
2953  			removeMarker(++endMarker);
2954  	}
2955  	execute(SCI_MARKERADD, startMarker, MARK_HIDELINESBEGIN);
2956  	execute(SCI_MARKERADD, endMarker, MARK_HIDELINESEND);
2957  	_currentBuffer->setHideLineChanged(true, startMarker);
2958  }
2959  bool ScintillaEditView::markerMarginClick(intptr_t lineNumber)
2960  {
2961  	auto state = execute(SCI_MARKERGET, lineNumber);
2962  	bool openPresent = (state & (1 << MARK_HIDELINESBEGIN)) != 0;
2963  	bool closePresent = (state & (1 << MARK_HIDELINESEND)) != 0;
2964  	if (!openPresent && !closePresent)
2965  		return false;
2966  	if (openPresent)
2967  	{
2968  		_currentBuffer->setHideLineChanged(false, lineNumber);
2969  	}
2970  	if (closePresent)
2971  	{
2972  		openPresent = false;
2973  		for (lineNumber--; lineNumber >= 0 && !openPresent; lineNumber--)
2974  		{
2975  			state = execute(SCI_MARKERGET, lineNumber);
2976  			openPresent = (state & (1 << MARK_HIDELINESBEGIN)) != 0;
2977  		}
2978  		if (openPresent)
2979  		{
2980  			_currentBuffer->setHideLineChanged(false, lineNumber + 1);
2981  		}
2982  	}
2983  	return true;
2984  }
2985  void ScintillaEditView::notifyMarkers(Buffer * buf, bool isHide, size_t location, bool del)
2986  {
2987  	if (buf != _currentBuffer)	
2988  		return;
2989  	runMarkers(isHide, location, false, del);
2990  }
2991  void ScintillaEditView::runMarkers(bool doHide, size_t searchStart, bool endOfDoc, bool doDelete)
2992  {
2993  	size_t maxLines = execute(SCI_GETLINECOUNT);
2994  	if (doHide)
2995  	{
2996  		auto startHiding = searchStart;
2997  		bool isInSection = false;
2998  		for (auto i = searchStart; i < maxLines; ++i)
2999  		{
3000  			auto state = execute(SCI_MARKERGET, i);
3001  			if ( ((state & (1 << MARK_HIDELINESEND)) != 0) )
3002  			{
3003  				if (isInSection)
3004  				{
3005  					execute(SCI_HIDELINES, startHiding, i-1);
3006  					if (!endOfDoc)
3007  					{
3008  						return;	
3009  					}	
3010  				}
3011  				isInSection = false;
3012  			}
3013  			if ((state & (1 << MARK_HIDELINESBEGIN)) != 0)
3014  			{
3015  				isInSection = true;
3016  				startHiding = i+1;
3017  			}
3018  		}
3019  	}
3020  	else
3021  	{
3022  		auto startShowing = searchStart;
3023  		bool isInSection = false;
3024  		for (auto i = searchStart; i < maxLines; ++i)
3025  		{
3026  			auto state = execute(SCI_MARKERGET, i);
3027  			if ( ((state & (1 << MARK_HIDELINESEND)) != 0) )
3028  			{
3029  				if (doDelete)
3030  				{
3031  					execute(SCI_MARKERDELETE, i, MARK_HIDELINESEND);
3032  					if (!endOfDoc)
3033  					{
3034  						return;	
3035  					}	
3036  				}
3037  				 else if (isInSection)
3038  				 {
3039  					if (startShowing >= i)
3040  					{	
3041  						if (!endOfDoc)
3042  						{
3043  							return;
3044  						}
3045  						else
3046  						{
3047  							continue;
3048  						}
3049  					}
3050  					execute(SCI_SHOWLINES, startShowing, i-1);
3051  					if (!endOfDoc)
3052  					{
3053  						return;	
3054  					}	
3055  					isInSection = false;
3056  				}
3057  			}
3058  			if ((state & (1 << MARK_HIDELINESBEGIN)) != 0)
3059  			{
3060  				if (doDelete)
3061  				{
3062  					execute(SCI_MARKERDELETE, i, MARK_HIDELINESBEGIN);
3063  				}
3064  				else
3065  				{
3066  					isInSection = true;
3067  					startShowing = i+1;
3068  				}
3069  			}
3070  			auto levelLine = execute(SCI_GETFOLDLEVEL, i, 0);
3071  			if (levelLine & SC_FOLDLEVELHEADERFLAG)
3072  			{	
3073  				if (isInSection && !isFolded(i))
3074  				{
3075  					execute(SCI_SHOWLINES, startShowing, i);
3076  				}
3077  			}
3078  		}
3079  	}
3080  }
3081  void ScintillaEditView::setTabSettings(Lang *lang)
3082  {
3083  	if (lang && lang->_tabSize != -1 && lang->_tabSize != 0)
3084  	{
3085  		if (lang->_langID == L_JAVASCRIPT)
3086  		{
3087  			Lang *ljs = NppParameters::getInstance().getLangFromID(L_JS);
3088  			execute(SCI_SETTABWIDTH, ljs->_tabSize > 0 ? ljs->_tabSize : lang->_tabSize);
3089  			execute(SCI_SETUSETABS, !ljs->_isTabReplacedBySpace);
3090  			return;
3091  		}
3092  		execute(SCI_SETTABWIDTH, lang->_tabSize);
3093  		execute(SCI_SETUSETABS, !lang->_isTabReplacedBySpace);
3094  	}
3095      else
3096  	{
3097  		const NppGUI & nppgui = NppParameters::getInstance().getNppGUI();
3098  		execute(SCI_SETTABWIDTH, nppgui._tabSize  > 0 ? nppgui._tabSize : 4);
3099  		execute(SCI_SETUSETABS, !nppgui._tabReplacedBySpace);
3100  	}
3101  }
3102  void ScintillaEditView::insertNewLineAboveCurrentLine()
3103  {
3104  	generic_string newline = getEOLString();
3105  	const auto current_line = getCurrentLineNumber();
3106  	if (current_line == 0)
3107  	{
3108  		insertGenericTextFrom(0, newline.c_str());
3109  	}
3110  	else
3111  	{
3112  		const auto eol_length = newline.length();
3113  		const auto position = execute(SCI_POSITIONFROMLINE, current_line) - eol_length;
3114  		insertGenericTextFrom(position, newline.c_str());
3115  	}
3116  	execute(SCI_SETEMPTYSELECTION, execute(SCI_POSITIONFROMLINE, current_line));
3117  }
3118  void ScintillaEditView::insertNewLineBelowCurrentLine()
3119  {
3120  	generic_string newline = getEOLString();
3121  	const auto line_count = execute(SCI_GETLINECOUNT);
3122  	const auto current_line = getCurrentLineNumber();
3123  	if (current_line == line_count - 1)
3124  	{
3125  		appandGenericText(newline.c_str());
3126  	}
3127  	else
3128  	{
3129  		const auto eol_length = newline.length();
3130  		const auto position = eol_length + execute(SCI_GETLINEENDPOSITION, current_line);
3131  		insertGenericTextFrom(position, newline.c_str());
3132  	}
3133  	execute(SCI_SETEMPTYSELECTION, execute(SCI_POSITIONFROMLINE, current_line + 1));
3134  }
3135  void ScintillaEditView::sortLines(size_t fromLine, size_t toLine, ISorter* pSort)
3136  {
3137  	if (fromLine >= toLine)
3138  	{
3139  		return;
3140  	}
3141  	const auto startPos = execute(SCI_POSITIONFROMLINE, fromLine);
3142  	const auto endPos = execute(SCI_POSITIONFROMLINE, toLine) + execute(SCI_LINELENGTH, toLine);
3143  	const generic_string text = getGenericTextAsString(startPos, endPos);
3144  	std::vector<generic_string> splitText = stringSplit(text, getEOLString());
3145  	const size_t lineCount = execute(SCI_GETLINECOUNT);
3146  	const bool sortEntireDocument = toLine == lineCount - 1;
3147  	if (!sortEntireDocument)
3148  	{
3149  		if (splitText.rbegin()->empty())
3150  		{
3151  			splitText.pop_back();
3152  		}
3153  	}
3154  	assert(toLine - fromLine + 1 == splitText.size());
3155  	const std::vector<generic_string> sortedText = pSort->sort(splitText);
3156  	generic_string joined = stringJoin(sortedText, getEOLString());
3157  	if (sortEntireDocument)
3158  	{
3159  		assert(joined.length() == text.length());
3160  	}
3161  	else
3162  	{
3163  		assert(joined.length() + getEOLString().length() == text.length());
3164  		joined += getEOLString();
3165  	}
3166  	if (text != joined)
3167  	{
3168  		replaceTarget(joined.c_str(), startPos, endPos);
3169  	}
3170  }
3171  bool ScintillaEditView::isTextDirectionRTL() const
3172  {
3173  	long exStyle = static_cast<long>(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3174  	return (exStyle & WS_EX_LAYOUTRTL) != 0;
3175  }
3176  void ScintillaEditView::changeTextDirection(bool isRTL)
3177  {
3178  	long exStyle = static_cast<long>(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3179  	exStyle = isRTL ? (exStyle | WS_EX_LAYOUTRTL) : (exStyle & (~WS_EX_LAYOUTRTL));
3180  	::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, exStyle);
3181  	if (isRTL)
3182  	{
3183  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT, SCI_CHARLEFT);
3184  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_SHIFT << 16), SCI_CHARLEFTEXTEND);
3185  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_ALT) << 16), SCI_CHARLEFTRECTEXTEND);
3186  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_CTRL << 16), SCI_WORDLEFT);
3187  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_CTRL) << 16), SCI_WORDLEFTEXTEND);
3188  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT, SCI_CHARRIGHT);
3189  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_SHIFT << 16), SCI_CHARRIGHTEXTEND);
3190  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_ALT) << 16), SCI_CHARRIGHTRECTEXTEND);
3191  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_CTRL << 16), SCI_WORDRIGHT);
3192  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_CTRL) << 16), SCI_WORDRIGHTEXTEND);
3193  	}
3194  	else
3195  	{
3196  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT, SCI_CHARRIGHT);
3197  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_SHIFT << 16), SCI_CHARRIGHTEXTEND);
3198  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_ALT) << 16), SCI_CHARRIGHTRECTEXTEND);
3199  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_CTRL << 16), SCI_WORDRIGHT);
3200  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_CTRL) << 16), SCI_WORDRIGHTEXTEND);
3201  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT, SCI_CHARLEFT);
3202  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_SHIFT << 16), SCI_CHARLEFTEXTEND);
3203  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_ALT) << 16), SCI_CHARLEFTRECTEXTEND);
3204  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_CTRL << 16), SCI_WORDLEFT);
3205  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_CTRL) << 16), SCI_WORDLEFTEXTEND);
3206  	}
3207  }
3208  generic_string ScintillaEditView::getEOLString()
3209  {
3210  	intptr_t eol_mode = execute(SCI_GETEOLMODE);
3211  	if (eol_mode == SC_EOL_CRLF)
3212  	{
3213  		return TEXT("\r\n");
3214  	}
3215  	else if (eol_mode == SC_EOL_LF)
3216  	{
3217  		return TEXT("\n");
3218  	}
3219  	else
3220  	{
3221  		return TEXT("\r");
3222  	}
3223  }
3224  void ScintillaEditView::setBorderEdge(bool doWithBorderEdge)
3225  {
3226  	long style = static_cast<long>(::GetWindowLongPtr(_hSelf, GWL_STYLE));
3227  	long exStyle = static_cast<long>(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3228  	if (NppDarkMode::isEnabled())
3229  	{
3230  		exStyle &= ~WS_EX_CLIENTEDGE;
3231  		if (doWithBorderEdge)
3232  			style |= WS_BORDER;
3233  		else
3234  			style &= ~WS_BORDER;
3235  	}
3236  	else
3237  	{
3238  		style &= ~WS_BORDER;
3239  		if (doWithBorderEdge)
3240  			exStyle |= WS_EX_CLIENTEDGE;
3241  		else
3242  			exStyle &= ~WS_EX_CLIENTEDGE;
3243  	}
3244  	::SetWindowLongPtr(_hSelf, GWL_STYLE, style);
3245  	::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, exStyle);
3246  	::SetWindowPos(_hSelf, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
3247  }
3248  void ScintillaEditView::getFoldColor(COLORREF& fgColor, COLORREF& bgColor, COLORREF& activeFgColor)
3249  {
3250  	StyleArray & stylers = NppParameters::getInstance().getMiscStylerArray();
3251  	const Style * pStyle = stylers.findByName(TEXT("Fold"));
3252  	if (pStyle)
3253  	{
3254  		fgColor = pStyle->_bgColor;
3255  		bgColor = pStyle->_fgColor;
3256  	}
3257  	pStyle = stylers.findByName(TEXT("Fold active"));
3258  	if (pStyle)
3259  	{
3260  		activeFgColor = pStyle->_fgColor;
3261  	}
3262  }
3263  int ScintillaEditView::getTextZoneWidth() const
3264  {
3265  	RECT editorRect;
3266  	getClientRect(editorRect);
3267  	intptr_t marginWidths = 0;
3268  	for (int m = 0; m < 4; ++m)
3269  	{
3270  		marginWidths += execute(SCI_GETMARGINWIDTHN, m);
3271  	}
3272  	return editorRect.right - editorRect.left - static_cast<LONG>(marginWidths);
3273  }
3274  pair<size_t, size_t> ScintillaEditView::getSelectedCharsAndLinesCount(long long maxSelectionsForLineCount &bsol;* = -1 */) const
3275  {
3276  	pair<size_t, size_t> selectedCharsAndLines(0, 0);
3277  	selectedCharsAndLines.first = getUnicodeSelectedLength();
3278  	size_t numSelections = execute(SCI_GETSELECTIONS);
3279  	if (numSelections == 1)
3280  	{
3281  		pair<size_t, size_t> lineRange = getSelectionLinesRange();
3282  		selectedCharsAndLines.second = lineRange.second - lineRange.first + 1;
3283  	}
3284  	else if (execute(SCI_SELECTIONISRECTANGLE))
3285  	{
3286  		selectedCharsAndLines.second = numSelections;
3287  	}
3288  	else if ((maxSelectionsForLineCount == -1) ||  
3289  		(numSelections <= static_cast<size_t>(maxSelectionsForLineCount)))
3290  	{
3291  		vector< pair <size_t, size_t> > v;
3292  		for (size_t s = 0; s < numSelections; ++s)
3293  		{
3294  			v.push_back(getSelectionLinesRange(s));
3295  		}
3296  		sort(v.begin(), v.end());
3297  		intptr_t previousSecondLine = -1;
3298  		for (auto& lineRange : v)
3299  		{
3300  			selectedCharsAndLines.second += lineRange.second - lineRange.first;
3301  			if (lineRange.first != static_cast<size_t>(previousSecondLine))
3302  			{
3303  				++selectedCharsAndLines.second;
3304  			}
3305  			previousSecondLine = static_cast<intptr_t>(lineRange.second);
3306  		}
3307  	}
3308  	return selectedCharsAndLines;
3309  }
3310  size_t ScintillaEditView::getUnicodeSelectedLength() const
3311  {
3312  	size_t length = 0;
3313  	size_t numSelections = execute(SCI_GETSELECTIONS);
3314  	for (size_t s = 0; s < numSelections; ++s)
3315  	{
3316  		size_t start = execute(SCI_GETSELECTIONNSTART, s);
3317  		size_t end = execute(SCI_GETSELECTIONNEND, s);
3318  		length += execute(SCI_COUNTCHARACTERS, start, end);
3319  	}
3320  	return length;
3321  }
3322  void ScintillaEditView::markedTextToClipboard(int indiStyle, bool doAll &bsol;*= false*/)
3323  {
3324  	int styleIndicators[] =
3325  	{
3326  		SCE_UNIVERSAL_FOUND_STYLE_EXT1,
3327  		SCE_UNIVERSAL_FOUND_STYLE_EXT2,
3328  		SCE_UNIVERSAL_FOUND_STYLE_EXT3,
3329  		SCE_UNIVERSAL_FOUND_STYLE_EXT4,
3330  		SCE_UNIVERSAL_FOUND_STYLE_EXT5,
3331  		-1  
3332  	};
3333  	if (!doAll)
3334  	{
3335  		styleIndicators[0] = indiStyle;
3336  		styleIndicators[1] = -1;
3337  	}
3338  	std::vector<std::pair<size_t, generic_string>> styledVect;
3339  	const generic_string cr = TEXT("\r");
3340  	const generic_string lf = TEXT("\n");
3341  	bool textContainsLineEndingChar = false;
3342  	for (int si = 0; styleIndicators[si] != -1; ++si)
3343  	{
3344  		size_t pos = execute(SCI_INDICATOREND, styleIndicators[si], 0);
3345  		if (pos > 0)
3346  		{
3347  			bool atEndOfIndic = execute(SCI_INDICATORVALUEAT, styleIndicators[si], 0) != 0;
3348  			size_t prevPos = pos;
3349  			if (atEndOfIndic) prevPos = 0;
3350  			do
3351  			{
3352  				if (atEndOfIndic)
3353  				{
3354  					generic_string styledText = getGenericTextAsString(prevPos, pos);
3355  					if (!textContainsLineEndingChar)
3356  					{
3357  						if (styledText.find(cr) != std::string::npos ||
3358  							styledText.find(lf) != std::string::npos)
3359  						{
3360  							textContainsLineEndingChar = true;
3361  						}
3362  					}
3363  					styledVect.push_back(::make_pair(prevPos, styledText));
3364  				}
3365  				atEndOfIndic = !atEndOfIndic;
3366  				prevPos = pos;
3367  				pos = execute(SCI_INDICATOREND, styleIndicators[si], pos);
3368  			} while (pos != prevPos);
3369  		}
3370  	}
3371  	if (styledVect.size() > 0)
3372  	{
3373  		if (doAll)
3374  		{
3375  			std::sort(styledVect.begin(), styledVect.end());
3376  		}
3377  		const generic_string delim =
3378  			(textContainsLineEndingChar && styledVect.size() > 1) ?
3379  			TEXT("\r\n----\r\n") : TEXT("\r\n");
3380  		generic_string joined;
3381  		for (auto& item : styledVect)
3382  		{
3383  			joined += delim + item.second;
3384  		}
3385  		joined = joined.substr(delim.length());
3386  		if (styledVect.size() > 1)
3387  		{
3388  			joined += TEXT("\r\n");
3389  		}
3390  		str2Clipboard(joined, NULL);
3391  	}
3392  }
3393  void ScintillaEditView::removeAnyDuplicateLines()
3394  {
3395  	size_t fromLine = 0, toLine = 0;
3396  	bool hasLineSelection = false;
3397  	auto selStart = execute(SCI_GETSELECTIONSTART);
3398  	auto selEnd = execute(SCI_GETSELECTIONEND);
3399  	hasLineSelection = selStart != selEnd;
3400  	if (hasLineSelection)
3401  	{
3402  		const pair<size_t, size_t> lineRange = getSelectionLinesRange();
3403  		if (lineRange.first == lineRange.second)
3404  		{
3405  			return;
3406  		}
3407  		fromLine = lineRange.first;
3408  		toLine = lineRange.second;
3409  	}
3410  	else
3411  	{
3412  		fromLine = 0;
3413  		toLine = execute(SCI_GETLINECOUNT) - 1;
3414  	}
3415  	if (fromLine >= toLine)
3416  	{
3417  		return;
3418  	}
3419  	const auto startPos = execute(SCI_POSITIONFROMLINE, fromLine);
3420  	const auto endPos = execute(SCI_POSITIONFROMLINE, toLine) + execute(SCI_LINELENGTH, toLine);
3421  	const generic_string text = getGenericTextAsString(startPos, endPos);
3422  	std::vector<generic_string> linesVect = stringSplit(text, getEOLString());
3423  	const size_t lineCount = execute(SCI_GETLINECOUNT);
3424  	const bool doingEntireDocument = toLine == lineCount - 1;
3425  	if (!doingEntireDocument)
3426  	{
3427  		if (linesVect.rbegin()->empty())
3428  		{
3429  			linesVect.pop_back();
3430  		}
3431  	}
3432  	size_t origSize = linesVect.size();
3433  	size_t newSize = vecRemoveDuplicates(linesVect);
3434  	if (origSize != newSize)
3435  	{
3436  		generic_string joined = stringJoin(linesVect, getEOLString());
3437  		if (!doingEntireDocument)
3438  		{
3439  			joined += getEOLString();
3440  		}
3441  		if (text != joined)
3442  		{
3443  			replaceTarget(joined.c_str(), startPos, endPos);
3444  		}
3445  	}
3446  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-mergenf.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.cpp</div>
                </div>
                <div class="column column_space"><pre><code>121    Similarity /= training_similarity_midpoint;
122    if (training_similarity_curl == 3) {
123      Similarity = Similarity * Similarity * Similarity;
124    } else if (training_similarity_curl == 2) {
125      Similarity = Similarity * Similarity;
</pre></code></div>
                <div class="column column_space"><pre><code>1540  	intptr_t docLine = execute(SCI_DOCLINEFROMVISIBLE, displayedLine);		
1541  	if (docLine != pos._firstVisibleLine)
1542  	{
1543  		intptr_t lineToShow = execute(SCI_VISIBLEFROMDOCLINE, pos._firstVisibleLine);
1544  		execute(SCI_SETFIRSTVISIBLELINE, lineToShow);
1545  	}
1546  	else if (pos._offset > 0)
1547  	{
1548  		intptr_t wrapCount = execute(SCI_WRAPCOUNT, docLine);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    