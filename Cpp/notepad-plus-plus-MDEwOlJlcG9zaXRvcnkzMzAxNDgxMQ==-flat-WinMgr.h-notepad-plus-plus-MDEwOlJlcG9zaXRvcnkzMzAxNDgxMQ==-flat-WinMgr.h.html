
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WinMgr.h</h3>
            <pre><code>1  #pragma once
2  #include <algorithm>
3  #include <assert.h>
4  #include <windows.h>
5  const SIZE SIZEZERO = {0, 0};
6  const SIZE SIZEMAX = {SHRT_MAX, SHRT_MAX};
7  inline SIZE GetSize(LONG w, LONG h) { 
8  	SIZE sz = {w, h}; return sz; 
9  }
10  inline POINT GetPoint(LONG x, LONG y) { 
11  	POINT pt = {x, y}; return pt; 
12  }
13  inline LONG RectWidth(const RECT& rc) { 
14  	return rc.right - rc.left; 
15  }
16  inline LONG RectHeight(const RECT& rc) { 
17  	return rc.bottom - rc.top; 
18  }
19  inline SIZE RectToSize(const RECT& rc) { 
20  	return GetSize(RectWidth(rc), RectHeight(rc));
21  }
22  inline POINT RectToPoint(const RECT& rc) { 
23  	POINT pt = {rc.left, rc.top};
24  	return pt; 
25  }
26  inline POINT SizeToPoint(SIZE sz) { 
27  	return GetPoint(sz.cx, sz.cy);
28  }
29  inline RECT &OffsetRect(RECT& rc, POINT pt) {
30  	rc.left += pt.x; rc.right += pt.x;
31  	rc.top += pt.y; rc.bottom += pt.y;
32  	return rc;
33  }
34  inline SIZE minsize(SIZE a, SIZE b) {
35  	return GetSize(std::min<LONG>(a.cx, b.cx), std::min<LONG>(a.cy, b.cy));
36  }
37  inline SIZE maxsize(SIZE a, SIZE b) {
38  	return GetSize(std::max<LONG>(a.cx, b.cx), std::max<LONG>(a.cy, b.cy));
39  }
40  struct SIZEINFO {
41  	SIZE szAvail;		
42  	SIZE szDesired;	
43  	SIZE szMin;			
44  	SIZE szMax;			
45  };
46  #define	WRCT_END			0				
47  #define	WRCT_FIXED		0x0001		
48  #define	WRCT_PCT			0x0002		
49  #define	WRCT_REST		0x0003		
50  #define	WRCT_TOFIT		0x0004		
51  #define	WRCF_TYPEMASK	0x000F
52  #define	WRCF_ROWGROUP	0x0010		
53  #define	WRCF_COLGROUP	0x0020		
54  #define	WRCF_ENDGROUP	0x00F0		
55  #define	WRCF_GROUPMASK	0x00F0
56  class WINRECT {
57  protected:
58  	WINRECT* next;			
59  	WINRECT* prev;			
60  	RECT  rc;				
61  	WORD  flags;			
62  	UINT	nID;				
63  	LONG	param;			
64  public:
65  	WINRECT(WORD f, int id, LONG p);
66  	static WINRECT* InitMap(WINRECT* map, WINRECT* parent=NULL);
67  	WINRECT* Prev()			{ return prev; }
68  	WINRECT* Next()			{ return next; }
69  	WINRECT* Children()		{ return IsGroup() ? this+1 : NULL; }
70  	WINRECT* Parent();
71  	WORD GetFlags()			{ return flags; }
72  	WORD SetFlags(WORD f)	{ return flags=f; }
73  	LONG GetParam()			{ return param; }
74  	LONG SetParam(LONG p)	{ return param=p; }
<span onclick='openModal()' class='match'>75  	UINT GetID()				{ return nID; }
76  	UINT SetID(UINT id)		{ return nID=id; }
77  	RECT& GetRect()					{ return rc; }
</span>78  	void SetRect(const RECT& r)	{ rc = r; }
79  	WORD Type() const			{ return flags & WRCF_TYPEMASK; }
80  	WORD GroupType() const	{ return flags & WRCF_GROUPMASK; }
81  	BOOL IsGroup() const		{ return GroupType() && GroupType()!=WRCF_ENDGROUP; }
82  	BOOL IsEndGroup() const { return flags==0 || flags==WRCF_ENDGROUP; }
83  	BOOL IsEnd() const		{ return flags==0; }
84  	BOOL IsWindow() const	{ return nID>0; }
85  	BOOL IsRowGroup()	const { return (flags & WRCF_GROUPMASK)==WRCF_ROWGROUP; }
86  	void SetHeight(LONG h)	{ rc.bottom = rc.top + h; }
87  	void SetWidth(LONG w)	{ rc.right = rc.left + w; }
88  	LONG GetHeightOrWidth(BOOL bHeight) const {
89  		return bHeight ? RectHeight(rc) : RectWidth(rc);
90  	}
91  	void SetHeightOrWidth(LONG horw, BOOL bHeight) {
92  		bHeight ? SetHeight(horw) : SetWidth(horw);
93  	}
94  	BOOL GetMargins(int& w, int& h);
95  	BOOL HasToFitSize()			{ return param != 0; }
96  	SIZE GetToFitSize()			{ SIZE sz = {LOWORD(param),HIWORD(param)}; return sz; }
97  	void SetToFitSize(SIZE sz)	{ param = MAKELONG(sz.cx,sz.cy); }
98  };
99  #define BEGIN_WINDOW_MAP(name)	WINRECT name[] = {
100  #define END_WINDOW_MAP()			WINRECT(WRCT_END,-1,0) }; 
101  #define BEGINROWS(type,id,m)	WINRECT(WRCF_ROWGROUP|type,id,m),
102  #define BEGINCOLS(type,id,m)  WINRECT(WRCF_COLGROUP|type,id,m),
103  #define ENDGROUP()				WINRECT(WRCF_ENDGROUP,-1,0),
104  #define RCMARGINS(w,h)			MAKELONG(w,h)
105  #define RCFIXED(id,val)		WINRECT(WRCT_FIXED,id,val),
106  #define RCPERCENT(id,val)	WINRECT(WRCT_PCT,id,val),
107  #define RCREST(id)			WINRECT(WRCT_REST,id,0),
108  #define RCTOFIT(id)			WINRECT(WRCT_TOFIT,id,0),
109  #define RCSPACE(val)			RCFIXED(-1,val)
110  class CWinGroupIterator {
111  protected:
112  	WINRECT* pCur;	  
113  public:
114  	CWinGroupIterator() { pCur = NULL; }
115  	CWinGroupIterator& operator=(WINRECT* pg) {
116  		assert(pg->IsGroup()); 
117  		pCur = pg->Children();
118  		return *this;
119  	}
120  	operator WINRECT*()	{ return pCur; }
121  	WINRECT* pWINRECT()	{ return pCur; }
122  	WINRECT* Next()		{ return pCur = pCur ? pCur->Next() : NULL;}
123  };
124  extern const UINT WM_WINMGR;
125  struct NMWINMGR : public NMHDR {
126  	enum {								
127  		GET_SIZEINFO = 1,				
128  		SIZEBAR_MOVED					
129  	};
130  	union {
131  		SIZEINFO sizeinfo{};	
132  		struct {					
133  			POINT ptMoved{};		
134  		} sizebar;
135  	};
136  	BOOL processed = FALSE;
137  	NMWINMGR() : NMHDR{ nullptr, 0, 0 }, sizeinfo{}, processed(FALSE) {}
138  };
139  class CWinMgr &bsol;*: public CObject*/ {
140  public:
141  	explicit CWinMgr(WINRECT* map);
142  	virtual ~CWinMgr();
143  	virtual void GetWindowPositions(HWND hWnd); 
144  	virtual void SetWindowPositions(HWND hWnd); 
145  	virtual void OnGetSizeInfo(SIZEINFO& szi, WINRECT* pwrc, HWND hWnd=NULL);
146  	void CalcLayout(HWND hWnd) {
147  		assert(hWnd);
148  		RECT rcClient;
149  		GetClientRect(hWnd, &rcClient);
150  		CalcLayout(rcClient, hWnd);
151  	}
152  	void CalcLayout(int cx, int cy, HWND hWnd=NULL) {
153  		RECT rc = {0,0,cx,cy};
154  		CalcLayout(rc, hWnd);
155  	}
156  	void CalcLayout(RECT rcTotal, HWND hWnd=NULL) {
157  		assert(m_map);
158  		m_map->SetRect(rcTotal);
159  		CalcGroup(m_map, hWnd);
160  	}
161  	void MoveRect(int nID, POINT ptMove, HWND pParentWnd) {
162  		MoveRect(FindRect(nID), ptMove, pParentWnd);
163  	}
164  	void MoveRect(WINRECT* pwrcMove, POINT ptMove, HWND pParentWnd);
165  	RECT GetRect(UINT nID)						 { return FindRect(nID)->GetRect(); }
166  	void SetRect(UINT nID, const RECT& rc) { FindRect(nID)->SetRect(rc); }
167  	WINRECT* FindRect(int nID);
168  	void GetMinMaxInfo(HWND hWnd, MINMAXINFO* lpMMI);
169  	void GetMinMaxInfo(HWND hWnd, SIZEINFO& szi);
170  	void InitToFitSizeFromCurrent(HWND hWnd);
171  protected:
172  	WINRECT*	m_map = nullptr;			
173  	int  CountWindows();
174  	BOOL SendGetSizeInfo(SIZEINFO& szi, HWND hWnd, UINT nID);
175  	virtual void CalcGroup(WINRECT* group, HWND hWnd);
176  	virtual void AdjustSize(WINRECT* pEntry, BOOL bRow,
177  		int& hwRemaining, HWND hWnd);
178  	virtual void PositionRects(WINRECT* pGroup,
179  		const RECT& rcTotal,BOOL bRow);
180  private:
181  	CWinMgr() { assert(FALSE); } 
182  };
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WinMgr.h</h3>
            <pre><code>1  #pragma once
2  #include <algorithm>
3  #include <assert.h>
4  #include <windows.h>
5  const SIZE SIZEZERO = {0, 0};
6  const SIZE SIZEMAX = {SHRT_MAX, SHRT_MAX};
7  inline SIZE GetSize(LONG w, LONG h) { 
8  	SIZE sz = {w, h}; return sz; 
9  }
10  inline POINT GetPoint(LONG x, LONG y) { 
11  	POINT pt = {x, y}; return pt; 
12  }
13  inline LONG RectWidth(const RECT& rc) { 
14  	return rc.right - rc.left; 
15  }
16  inline LONG RectHeight(const RECT& rc) { 
17  	return rc.bottom - rc.top; 
18  }
19  inline SIZE RectToSize(const RECT& rc) { 
20  	return GetSize(RectWidth(rc), RectHeight(rc));
21  }
22  inline POINT RectToPoint(const RECT& rc) { 
23  	POINT pt = {rc.left, rc.top};
24  	return pt; 
25  }
26  inline POINT SizeToPoint(SIZE sz) { 
27  	return GetPoint(sz.cx, sz.cy);
28  }
29  inline RECT &OffsetRect(RECT& rc, POINT pt) {
30  	rc.left += pt.x; rc.right += pt.x;
31  	rc.top += pt.y; rc.bottom += pt.y;
32  	return rc;
33  }
34  inline SIZE minsize(SIZE a, SIZE b) {
35  	return GetSize(std::min<LONG>(a.cx, b.cx), std::min<LONG>(a.cy, b.cy));
36  }
37  inline SIZE maxsize(SIZE a, SIZE b) {
38  	return GetSize(std::max<LONG>(a.cx, b.cx), std::max<LONG>(a.cy, b.cy));
39  }
40  struct SIZEINFO {
41  	SIZE szAvail;		
42  	SIZE szDesired;	
43  	SIZE szMin;			
44  	SIZE szMax;			
45  };
46  #define	WRCT_END			0				
47  #define	WRCT_FIXED		0x0001		
48  #define	WRCT_PCT			0x0002		
49  #define	WRCT_REST		0x0003		
50  #define	WRCT_TOFIT		0x0004		
51  #define	WRCF_TYPEMASK	0x000F
52  #define	WRCF_ROWGROUP	0x0010		
53  #define	WRCF_COLGROUP	0x0020		
54  #define	WRCF_ENDGROUP	0x00F0		
55  #define	WRCF_GROUPMASK	0x00F0
56  class WINRECT {
57  protected:
58  	WINRECT* next;			
59  	WINRECT* prev;			
60  	RECT  rc;				
61  	WORD  flags;			
62  	UINT	nID;				
63  	LONG	param;			
64  public:
65  	WINRECT(WORD f, int id, LONG p);
66  	static WINRECT* InitMap(WINRECT* map, WINRECT* parent=NULL);
67  	WINRECT* Prev()			{ return prev; }
68  	WINRECT* Next()			{ return next; }
69  	WINRECT* Children()		{ return IsGroup() ? this+1 : NULL; }
70  	WINRECT* Parent();
71  	WORD GetFlags()			{ return flags; }
72  	WORD SetFlags(WORD f)	{ return flags=f; }
73  	LONG GetParam()			{ return param; }
74  	LONG SetParam(LONG p)	{ return param=p; }
<span onclick='openModal()' class='match'>75  	UINT GetID()				{ return nID; }
76  	UINT SetID(UINT id)		{ return nID=id; }
77  	RECT& GetRect()					{ return rc; }
</span>78  	void SetRect(const RECT& r)	{ rc = r; }
79  	WORD Type() const			{ return flags & WRCF_TYPEMASK; }
80  	WORD GroupType() const	{ return flags & WRCF_GROUPMASK; }
81  	BOOL IsGroup() const		{ return GroupType() && GroupType()!=WRCF_ENDGROUP; }
82  	BOOL IsEndGroup() const { return flags==0 || flags==WRCF_ENDGROUP; }
83  	BOOL IsEnd() const		{ return flags==0; }
84  	BOOL IsWindow() const	{ return nID>0; }
85  	BOOL IsRowGroup()	const { return (flags & WRCF_GROUPMASK)==WRCF_ROWGROUP; }
86  	void SetHeight(LONG h)	{ rc.bottom = rc.top + h; }
87  	void SetWidth(LONG w)	{ rc.right = rc.left + w; }
88  	LONG GetHeightOrWidth(BOOL bHeight) const {
89  		return bHeight ? RectHeight(rc) : RectWidth(rc);
90  	}
91  	void SetHeightOrWidth(LONG horw, BOOL bHeight) {
92  		bHeight ? SetHeight(horw) : SetWidth(horw);
93  	}
94  	BOOL GetMargins(int& w, int& h);
95  	BOOL HasToFitSize()			{ return param != 0; }
96  	SIZE GetToFitSize()			{ SIZE sz = {LOWORD(param),HIWORD(param)}; return sz; }
97  	void SetToFitSize(SIZE sz)	{ param = MAKELONG(sz.cx,sz.cy); }
98  };
99  #define BEGIN_WINDOW_MAP(name)	WINRECT name[] = {
100  #define END_WINDOW_MAP()			WINRECT(WRCT_END,-1,0) }; 
101  #define BEGINROWS(type,id,m)	WINRECT(WRCF_ROWGROUP|type,id,m),
102  #define BEGINCOLS(type,id,m)  WINRECT(WRCF_COLGROUP|type,id,m),
103  #define ENDGROUP()				WINRECT(WRCF_ENDGROUP,-1,0),
104  #define RCMARGINS(w,h)			MAKELONG(w,h)
105  #define RCFIXED(id,val)		WINRECT(WRCT_FIXED,id,val),
106  #define RCPERCENT(id,val)	WINRECT(WRCT_PCT,id,val),
107  #define RCREST(id)			WINRECT(WRCT_REST,id,0),
108  #define RCTOFIT(id)			WINRECT(WRCT_TOFIT,id,0),
109  #define RCSPACE(val)			RCFIXED(-1,val)
110  class CWinGroupIterator {
111  protected:
112  	WINRECT* pCur;	  
113  public:
114  	CWinGroupIterator() { pCur = NULL; }
115  	CWinGroupIterator& operator=(WINRECT* pg) {
116  		assert(pg->IsGroup()); 
117  		pCur = pg->Children();
118  		return *this;
119  	}
120  	operator WINRECT*()	{ return pCur; }
121  	WINRECT* pWINRECT()	{ return pCur; }
122  	WINRECT* Next()		{ return pCur = pCur ? pCur->Next() : NULL;}
123  };
124  extern const UINT WM_WINMGR;
125  struct NMWINMGR : public NMHDR {
126  	enum {								
127  		GET_SIZEINFO = 1,				
128  		SIZEBAR_MOVED					
129  	};
130  	union {
131  		SIZEINFO sizeinfo{};	
132  		struct {					
133  			POINT ptMoved{};		
134  		} sizebar;
135  	};
136  	BOOL processed = FALSE;
137  	NMWINMGR() : NMHDR{ nullptr, 0, 0 }, sizeinfo{}, processed(FALSE) {}
138  };
139  class CWinMgr &bsol;*: public CObject*/ {
140  public:
141  	explicit CWinMgr(WINRECT* map);
142  	virtual ~CWinMgr();
143  	virtual void GetWindowPositions(HWND hWnd); 
144  	virtual void SetWindowPositions(HWND hWnd); 
145  	virtual void OnGetSizeInfo(SIZEINFO& szi, WINRECT* pwrc, HWND hWnd=NULL);
146  	void CalcLayout(HWND hWnd) {
147  		assert(hWnd);
148  		RECT rcClient;
149  		GetClientRect(hWnd, &rcClient);
150  		CalcLayout(rcClient, hWnd);
151  	}
152  	void CalcLayout(int cx, int cy, HWND hWnd=NULL) {
153  		RECT rc = {0,0,cx,cy};
154  		CalcLayout(rc, hWnd);
155  	}
156  	void CalcLayout(RECT rcTotal, HWND hWnd=NULL) {
157  		assert(m_map);
158  		m_map->SetRect(rcTotal);
159  		CalcGroup(m_map, hWnd);
160  	}
161  	void MoveRect(int nID, POINT ptMove, HWND pParentWnd) {
162  		MoveRect(FindRect(nID), ptMove, pParentWnd);
163  	}
164  	void MoveRect(WINRECT* pwrcMove, POINT ptMove, HWND pParentWnd);
165  	RECT GetRect(UINT nID)						 { return FindRect(nID)->GetRect(); }
166  	void SetRect(UINT nID, const RECT& rc) { FindRect(nID)->SetRect(rc); }
167  	WINRECT* FindRect(int nID);
168  	void GetMinMaxInfo(HWND hWnd, MINMAXINFO* lpMMI);
169  	void GetMinMaxInfo(HWND hWnd, SIZEINFO& szi);
170  	void InitToFitSizeFromCurrent(HWND hWnd);
171  protected:
172  	WINRECT*	m_map = nullptr;			
173  	int  CountWindows();
174  	BOOL SendGetSizeInfo(SIZEINFO& szi, HWND hWnd, UINT nID);
175  	virtual void CalcGroup(WINRECT* group, HWND hWnd);
176  	virtual void AdjustSize(WINRECT* pEntry, BOOL bRow,
177  		int& hwRemaining, HWND hWnd);
178  	virtual void PositionRects(WINRECT* pGroup,
179  		const RECT& rcTotal,BOOL bRow);
180  private:
181  	CWinMgr() { assert(FALSE); } 
182  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WinMgr.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WinMgr.h</div>
                </div>
                <div class="column column_space"><pre><code>75  	UINT GetID()				{ return nID; }
76  	UINT SetID(UINT id)		{ return nID=id; }
77  	RECT& GetRect()					{ return rc; }
</pre></code></div>
                <div class="column column_space"><pre><code>75  	UINT GetID()				{ return nID; }
76  	UINT SetID(UINT id)		{ return nID=id; }
77  	RECT& GetRect()					{ return rc; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    