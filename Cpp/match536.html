<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for service.cpp &amp; measurements.t.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for service.cpp &amp; measurements.t.cpp
      </h3>
<h1 align="center">
        8.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>service.cpp (5.9925094%)<th>measurements.t.cpp (12.8%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(46-52)<td><a href="#" name="0">(208-215)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>service.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "service.hpp"

#include "fib-updater.hpp"
#include "readvertise/client-to-nlsr-readvertise-policy.hpp"
#include "readvertise/host-to-gateway-readvertise-policy.hpp"
#include "readvertise/nfd-rib-readvertise-destination.hpp"
#include "readvertise/readvertise.hpp"

#include "common/global.hpp"
#include "common/logger.hpp"

#include &lt;boost/property_tree/info_parser.hpp&gt;
#include &lt;ndn-cxx/transport/tcp-transport.hpp&gt;
#include &lt;ndn-cxx/transport/unix-transport.hpp&gt;

namespace nfd {
namespace rib {
<a name="0"></a>
NFD_LOG_INIT(RibService);

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Service* Service::s_instance = nullptr;

const std::string CFG_RIB = "rib";
const std::string CFG_LOCALHOST_SECURITY = "localhost_security";
const std::string CFG_LOCALHOP_SECURITY = "localhop_security";
const std::string CFG_PA_VALIDATION = "prefix_announcement_validation";
const std::string CFG_PREFIX_PROPAGATE = "auto_prefix_propagate";</b></font>
const std::string CFG_READVERTISE_NLSR = "readvertise_nlsr";
const Name READVERTISE_NLSR_PREFIX = "/localhost/nlsr";
const uint64_t PROPAGATE_DEFAULT_COST = 15;
const time::milliseconds PROPAGATE_DEFAULT_TIMEOUT = 10_s;

static ConfigSection
loadConfigSectionFromFile(const std::string&amp; filename)
{
  ConfigSection config;
  // Any format errors should have been caught already
  boost::property_tree::read_info(filename, config);
  return config;
}

/**
 * \brief Look into the config file and construct appropriate transport to communicate with NFD
 * If NFD-RIB instance was initialized with config file, INFO format is assumed
 */
static shared_ptr&lt;ndn::Transport&gt;
makeLocalNfdTransport(const ConfigSection&amp; config)
{
  if (config.get_child_optional("face_system.unix")) {
    // default socket path should be the same as in UnixStreamFactory::processConfig
#ifdef __linux__
    auto path = config.get&lt;std::string&gt;("face_system.unix.path", "/run/nfd.sock");
#else
    auto path = config.get&lt;std::string&gt;("face_system.unix.path", "/var/run/nfd.sock");
#endif // __linux__
    return make_shared&lt;ndn::UnixTransport&gt;(path);
  }
  else if (config.get_child_optional("face_system.tcp") &amp;&amp;
           config.get&lt;std::string&gt;("face_system.tcp.listen", "yes") == "yes") {
    // default port should be the same as in TcpFactory::processConfig
    auto port = config.get&lt;std::string&gt;("face_system.tcp.port", "6363");
    return make_shared&lt;ndn::TcpTransport&gt;("localhost", port);
  }
  else {
    NDN_THROW(ConfigFile::Error("No transport is available to communicate with NFD"));
  }
}

Service::Service(const std::string&amp; configFile, ndn::KeyChain&amp; keyChain)
  : Service(keyChain, makeLocalNfdTransport(loadConfigSectionFromFile(configFile)),
            [&amp;configFile] (ConfigFile&amp; config, bool isDryRun) {
              config.parse(configFile, isDryRun);
            })
{
}

Service::Service(const ConfigSection&amp; configSection, ndn::KeyChain&amp; keyChain)
  : Service(keyChain, makeLocalNfdTransport(configSection),
            [&amp;configSection] (ConfigFile&amp; config, bool isDryRun) {
              config.parse(configSection, isDryRun, "internal://nfd.conf");
            })
{
}

template&lt;typename ConfigParseFunc&gt;
Service::Service(ndn::KeyChain&amp; keyChain, shared_ptr&lt;ndn::Transport&gt; localNfdTransport,
                 const ConfigParseFunc&amp; configParse)
  : m_keyChain(keyChain)
  , m_face(std::move(localNfdTransport), getGlobalIoService(), m_keyChain)
  , m_nfdController(m_face, m_keyChain)
  , m_fibUpdater(m_rib, m_nfdController)
  , m_dispatcher(m_face, m_keyChain)
  , m_ribManager(m_rib, m_face, m_keyChain, m_nfdController, m_dispatcher)
{
  if (s_instance != nullptr) {
    NDN_THROW(std::logic_error("RIB service cannot be instantiated more than once"));
  }
  if (&amp;getGlobalIoService() != &amp;getRibIoService()) {
    NDN_THROW(std::logic_error("RIB service must run on RIB thread"));
  }
  s_instance = this;

  ConfigFile config(ConfigFile::ignoreUnknownSection);
  config.addSectionHandler(CFG_RIB, [this] (auto&amp;&amp;... args) {
    processConfig(std::forward&lt;decltype(args)&gt;(args)...);
  });
  configParse(config, true);
  configParse(config, false);

  m_ribManager.registerWithNfd();
  m_ribManager.enableLocalFields();
}

Service::~Service()
{
  s_instance = nullptr;
}

Service&amp;
Service::get()
{
  if (s_instance == nullptr) {
    NDN_THROW(std::logic_error("RIB service is not instantiated"));
  }
  if (&amp;getGlobalIoService() != &amp;getRibIoService()) {
    NDN_THROW(std::logic_error("Must get RIB service on RIB thread"));
  }
  return *s_instance;
}

void
Service::processConfig(const ConfigSection&amp; section, bool isDryRun, const std::string&amp; filename)
{
  if (isDryRun) {
    checkConfig(section, filename);
  }
  else {
    applyConfig(section, filename);
  }
}

void
Service::checkConfig(const ConfigSection&amp; section, const std::string&amp; filename)
{
  bool hasLocalhop = false;
  bool hasPropagate = false;

  for (const auto&amp; item : section) {
    const std::string&amp; key = item.first;
    const ConfigSection&amp; value = item.second;
    if (key == CFG_LOCALHOST_SECURITY || key == CFG_PA_VALIDATION) {
      ndn::ValidatorConfig testValidator(m_face);
      testValidator.load(value, filename);
    }
    else if (key == CFG_LOCALHOP_SECURITY) {
      hasLocalhop = true;
      ndn::ValidatorConfig testValidator(m_face);
      testValidator.load(value, filename);
    }
    else if (key == CFG_PREFIX_PROPAGATE) {
      hasPropagate = true;
      // AutoPrefixPropagator does not support config dry-run
    }
    else if (key == CFG_READVERTISE_NLSR) {
      ConfigFile::parseYesNo(item, CFG_RIB + "." + CFG_READVERTISE_NLSR);
    }
    else {
      NDN_THROW(ConfigFile::Error("Unrecognized option " + CFG_RIB + "." + key));
    }
  }

  if (hasLocalhop &amp;&amp; hasPropagate) {
    NDN_THROW(ConfigFile::Error(CFG_LOCALHOP_SECURITY + " and " + CFG_PREFIX_PROPAGATE +
                                " cannot be enabled at the same time"));
  }
}

void
Service::applyConfig(const ConfigSection&amp; section, const std::string&amp; filename)
{
  bool wantPrefixPropagate = false;
  bool wantReadvertiseNlsr = false;

  for (const auto&amp; item : section) {
    const std::string&amp; key = item.first;
    const ConfigSection&amp; value = item.second;
    if (key == CFG_LOCALHOST_SECURITY) {
      m_ribManager.applyLocalhostConfig(value, filename);
    }
    else if (key == CFG_LOCALHOP_SECURITY) {
      m_ribManager.enableLocalhop(value, filename);
    }
    else if (key == CFG_PA_VALIDATION) {
      m_ribManager.applyPaConfig(value, filename);
    }
    else if (key == CFG_PREFIX_PROPAGATE) {
      wantPrefixPropagate = true;

      if (!m_readvertisePropagation) {
        NFD_LOG_DEBUG("Enabling automatic prefix propagation");

        auto cost = item.second.get_optional&lt;uint64_t&gt;("cost");
        auto parameters = ndn::nfd::ControlParameters()
                          .setCost(cost.value_or(PROPAGATE_DEFAULT_COST))
                          .setOrigin(ndn::nfd::ROUTE_ORIGIN_CLIENT);

        auto timeout = item.second.get_optional&lt;uint64_t&gt;("timeout");
        auto options = ndn::nfd::CommandOptions()
                       .setPrefix(RibManager::LOCALHOP_TOP_PREFIX)
                       .setTimeout(timeout ? time::milliseconds(*timeout) : PROPAGATE_DEFAULT_TIMEOUT);

        m_readvertisePropagation = make_unique&lt;Readvertise&gt;(
          m_rib,
          make_unique&lt;HostToGatewayReadvertisePolicy&gt;(m_keyChain, item.second),
          make_unique&lt;NfdRibReadvertiseDestination&gt;(m_nfdController, m_rib, options, parameters));
      }
    }
    else if (key == CFG_READVERTISE_NLSR) {
      wantReadvertiseNlsr = ConfigFile::parseYesNo(item, CFG_RIB + "." + CFG_READVERTISE_NLSR);
    }
    else {
      NDN_THROW(ConfigFile::Error("Unrecognized option " + CFG_RIB + "." + key));
    }
  }

  if (!wantPrefixPropagate &amp;&amp; m_readvertisePropagation != nullptr) {
    NFD_LOG_DEBUG("Disabling automatic prefix propagation");
    m_readvertisePropagation.reset();
  }

  if (wantReadvertiseNlsr &amp;&amp; m_readvertiseNlsr == nullptr) {
    NFD_LOG_DEBUG("Enabling readvertise-to-nlsr");
    auto options = ndn::nfd::CommandOptions().setPrefix(READVERTISE_NLSR_PREFIX);
    m_readvertiseNlsr = make_unique&lt;Readvertise&gt;(
      m_rib,
      make_unique&lt;ClientToNlsrReadvertisePolicy&gt;(),
      make_unique&lt;NfdRibReadvertiseDestination&gt;(m_nfdController, m_rib, options));
  }
  else if (!wantReadvertiseNlsr &amp;&amp; m_readvertiseNlsr != nullptr) {
    NFD_LOG_DEBUG("Disabling readvertise-to-nlsr");
    m_readvertiseNlsr.reset();
  }
}

} // namespace rib
} // namespace nfd
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>measurements.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2019,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "table/measurements.hpp"
#include "table/fib.hpp"
#include "table/pit.hpp"

#include "tests/test-common.hpp"
#include "tests/daemon/global-io-fixture.hpp"

namespace nfd {
namespace measurements {
namespace tests {

using namespace nfd::tests;

BOOST_AUTO_TEST_SUITE(Table)

class MeasurementsFixture : public GlobalIoTimeFixture
{
public:
  MeasurementsFixture()
    : measurements(nameTree)
  {
  }

public:
  NameTree nameTree;
  Measurements measurements;
};

BOOST_FIXTURE_TEST_SUITE(TestMeasurements, MeasurementsFixture)

BOOST_AUTO_TEST_CASE(Get_Parent)
{
  Entry&amp; entryAB = measurements.get("/A/B");
  BOOST_CHECK_EQUAL(entryAB.getName(), "/A/B");

  Entry&amp; entry0 = measurements.get("/");
  BOOST_CHECK_EQUAL(entry0.getName(), "/");

  Entry* entryA = measurements.getParent(entryAB);
  BOOST_REQUIRE(entryA != nullptr);
  BOOST_CHECK_EQUAL(entryA-&gt;getName(), "/A");

  Entry* entry0c = measurements.getParent(*entryA);
  BOOST_REQUIRE(entry0c != nullptr);
  BOOST_CHECK_EQUAL(&amp;entry0, entry0c);
}

BOOST_AUTO_TEST_CASE(GetLongName)
{
  Name n;
  while (n.size() &lt; NameTree::getMaxDepth() - 1) {
    n.append("A");
  }
  Entry&amp; entry1 = measurements.get(n);
  BOOST_CHECK_EQUAL(entry1.getName().size(), NameTree::getMaxDepth() - 1);

  n.append("B");
  Entry&amp; entry2 = measurements.get(n);
  BOOST_CHECK_EQUAL(entry2.getName().size(), NameTree::getMaxDepth());

  n.append("C");
  Entry&amp; entry3 = measurements.get(n);
  BOOST_CHECK_EQUAL(entry3.getName().size(), NameTree::getMaxDepth());
}

BOOST_AUTO_TEST_CASE(GetWithFibEntry)
{
  Fib fib(nameTree);

  const fib::Entry* fibA = fib.insert("/A").first;
  const fib::Entry* fibAB = fib.insert("/A/B").first;

  Entry&amp; entryA = measurements.get(*fibA);
  BOOST_CHECK_EQUAL(entryA.getName(), "/A");

  Entry&amp; entryAB = measurements.get(*fibAB);
  BOOST_CHECK_EQUAL(entryAB.getName(), "/A/B");
}

BOOST_AUTO_TEST_CASE(GetWithEmptyFibEntry) // Bug 3275
{
  Fib fib(nameTree);

  const fib::Entry&amp; fib0 = fib.findLongestPrefixMatch("/");

  Entry&amp; entry0 = measurements.get(fib0);
  BOOST_CHECK_EQUAL(entry0.getName(), "/");
}

BOOST_AUTO_TEST_CASE(GetWithPitEntry)
{
  Pit pit(nameTree);

  shared_ptr&lt;Interest&gt; interestA = makeInterest("/A");
  shared_ptr&lt;pit::Entry&gt; pitA = pit.insert(*interestA).first;
  shared_ptr&lt;Data&gt; dataABC = makeData("/A/B/C");
  Name fullName = dataABC-&gt;getFullName();
  shared_ptr&lt;Interest&gt; interestFull = makeInterest(fullName);
  shared_ptr&lt;pit::Entry&gt; pitFull = pit.insert(*interestFull).first;

  Entry&amp; entryA = measurements.get(*pitA);
  BOOST_CHECK_EQUAL(entryA.getName(), "/A");

  Entry&amp; entryFull = measurements.get(*pitFull);
  BOOST_CHECK_EQUAL(entryFull.getName(), fullName);
}

class DummyStrategyInfo1 : public fw::StrategyInfo
{
public:
  static constexpr int
  getTypeId()
  {
    return 21;
  }
};

class DummyStrategyInfo2 : public fw::StrategyInfo
{
public:
  static constexpr int
  getTypeId()
  {
    return 22;
  }
};

BOOST_AUTO_TEST_CASE(FindLongestPrefixMatch)
{
  measurements.get("/A");
  measurements.get("/A/B/C").insertStrategyInfo&lt;DummyStrategyInfo1&gt;();
  measurements.get("/A/B/C/D");

  Entry* found1 = measurements.findLongestPrefixMatch("/A/B/C/D/E");
  BOOST_REQUIRE(found1 != nullptr);
  BOOST_CHECK_EQUAL(found1-&gt;getName(), "/A/B/C/D");

  Entry* found2 = measurements.findLongestPrefixMatch("/A/B/C/D/E",
      EntryWithStrategyInfo&lt;DummyStrategyInfo1&gt;());
  BOOST_REQUIRE(found2 != nullptr);
  BOOST_CHECK_EQUAL(found2-&gt;getName(), "/A/B/C");

  Entry* found3 = measurements.findLongestPrefixMatch("/A/B/C/D/E",
      EntryWithStrategyInfo&lt;DummyStrategyInfo2&gt;());
  BOOST_CHECK(found3 == nullptr);
}

BOOST_AUTO_TEST_CASE(FindLongestPrefixMatchWithPitEntry)
{
  Pit pit(nameTree);

  measurements.get("/A");
  measurements.get("/A/B/C").insertStrategyInfo&lt;DummyStrategyInfo1&gt;();
  measurements.get("/A/B/C/D");

  shared_ptr&lt;Interest&gt; interest = makeInterest("/A/B/C/D/E");
  shared_ptr&lt;pit::Entry&gt; pitEntry = pit.insert(*interest).first;

  Entry* found1 = measurements.findLongestPrefixMatch(*pitEntry);
  BOOST_REQUIRE(found1 != nullptr);
  BOOST_CHECK_EQUAL(found1-&gt;getName(), "/A/B/C/D");

  Entry* found2 = measurements.findLongestPrefixMatch(*pitEntry,
      EntryWithStrategyInfo&lt;DummyStrategyInfo1&gt;());
  BOOST_REQUIRE(found2 != nullptr);
  BOOST_CHECK_EQUAL(found2-&gt;getName(), "/A/B/C");

  Entry* found3 = measurements.findLongestPrefixMatch(*pitEntry,
      EntryWithStrategyInfo&lt;DummyStrategyInfo2&gt;());
  BOOST_CHECK(found3 == nullptr);
}

BOOST_AUTO_TEST_CASE(Lifetime)
{
  Name nameA("ndn:/A");
  Name nameB("ndn:/B");
  Name nameC("ndn:/C");

  BOOST_CHECK_EQUAL(measurements.size(), 0);
<a name="0"></a>
  Entry&amp; entryA = measurements.get(nameA);
  measurements.get(nameB);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  Entry&amp; entryC = measurements.get(nameC);
  BOOST_CHECK_EQUAL(measurements.size(), 3);

  const time::nanoseconds EXTEND_A = 2_s;
  const time::nanoseconds CHECK1 = 3_s;
  const time::nanoseconds CHECK2 = 5_s;
  const time::nanoseconds EXTEND_C = 6_s;
  const time::nanoseconds CHECK3 = 7_s;</b></font>
  BOOST_ASSERT(EXTEND_A &lt; CHECK1);
  BOOST_ASSERT(CHECK1 &lt; Measurements::getInitialLifetime());
  BOOST_ASSERT(Measurements::getInitialLifetime() &lt; CHECK2);
  BOOST_ASSERT(CHECK2 &lt; EXTEND_C);
  BOOST_ASSERT(EXTEND_C &lt; CHECK3);

  measurements.extendLifetime(entryA, EXTEND_A);
  measurements.extendLifetime(entryC, EXTEND_C);
  // remaining lifetime:
  //   A = initial lifetime, because it's extended by less duration
  //   B = initial lifetime
  //   C = EXTEND_C

  this-&gt;advanceClocks(100_ms, CHECK1);
  BOOST_CHECK(measurements.findExactMatch(nameA) != nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameB) != nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameC) != nullptr);
  BOOST_CHECK_EQUAL(measurements.size(), 3);

  this-&gt;advanceClocks(100_ms, CHECK2 - CHECK1);
  BOOST_CHECK(measurements.findExactMatch(nameA) == nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameB) == nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameC) != nullptr);
  BOOST_CHECK_EQUAL(measurements.size(), 1);

  this-&gt;advanceClocks(100_ms, CHECK3 - CHECK2);
  BOOST_CHECK(measurements.findExactMatch(nameA) == nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameB) == nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameC) == nullptr);
  BOOST_CHECK_EQUAL(measurements.size(), 0);
}

BOOST_AUTO_TEST_CASE(EraseNameTreeEntry)
{
  size_t nNameTreeEntriesBefore = nameTree.size();

  measurements.get("/A");
  BOOST_CHECK_EQUAL(measurements.size(), 1);

  this-&gt;advanceClocks(Measurements::getInitialLifetime() + 10_ms);
  BOOST_CHECK_EQUAL(measurements.size(), 0);
  BOOST_CHECK_EQUAL(nameTree.size(), nNameTreeEntriesBefore);
}

BOOST_AUTO_TEST_SUITE_END() // TestMeasurements
BOOST_AUTO_TEST_SUITE_END() // Table

} // namespace tests
} // namespace measurements
} // namespace nfd
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
