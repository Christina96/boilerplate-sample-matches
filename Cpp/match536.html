<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for service.cpp & measurements.t.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for service.cpp & measurements.t.cpp
      </h3>
      <h1 align="center">
        8.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>service.cpp (5.9925094%)<TH>measurements.t.cpp (12.8%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match536-0.html#0',2,'match536-1.html#0',3)" NAME="0">(46-52)<TD><A HREF="javascript:ZweiFrames('match536-0.html#0',2,'match536-1.html#0',3)" NAME="0">(208-215)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>service.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;service.hpp&quot;

#include &quot;fib-updater.hpp&quot;
#include &quot;readvertise/client-to-nlsr-readvertise-policy.hpp&quot;
#include &quot;readvertise/host-to-gateway-readvertise-policy.hpp&quot;
#include &quot;readvertise/nfd-rib-readvertise-destination.hpp&quot;
#include &quot;readvertise/readvertise.hpp&quot;

#include &quot;common/global.hpp&quot;
#include &quot;common/logger.hpp&quot;

#include &lt;boost/property_tree/info_parser.hpp&gt;
#include &lt;ndn-cxx/transport/tcp-transport.hpp&gt;
#include &lt;ndn-cxx/transport/unix-transport.hpp&gt;

namespace nfd {
namespace rib {
<A NAME="0"></A>
NFD_LOG_INIT(RibService);

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match536-1.html#0',3,'match536-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Service* Service::s_instance = nullptr;

const std::string CFG_RIB = &quot;rib&quot;;
const std::string CFG_LOCALHOST_SECURITY = &quot;localhost_security&quot;;
const std::string CFG_LOCALHOP_SECURITY = &quot;localhop_security&quot;;
const std::string CFG_PA_VALIDATION = &quot;prefix_announcement_validation&quot;;
const std::string CFG_PREFIX_PROPAGATE = &quot;auto_prefix_propagate&quot;;</B></FONT>
const std::string CFG_READVERTISE_NLSR = &quot;readvertise_nlsr&quot;;
const Name READVERTISE_NLSR_PREFIX = &quot;/localhost/nlsr&quot;;
const uint64_t PROPAGATE_DEFAULT_COST = 15;
const time::milliseconds PROPAGATE_DEFAULT_TIMEOUT = 10_s;

static ConfigSection
loadConfigSectionFromFile(const std::string&amp; filename)
{
  ConfigSection config;
  // Any format errors should have been caught already
  boost::property_tree::read_info(filename, config);
  return config;
}

/**
 * \brief Look into the config file and construct appropriate transport to communicate with NFD
 * If NFD-RIB instance was initialized with config file, INFO format is assumed
 */
static shared_ptr&lt;ndn::Transport&gt;
makeLocalNfdTransport(const ConfigSection&amp; config)
{
  if (config.get_child_optional(&quot;face_system.unix&quot;)) {
    // default socket path should be the same as in UnixStreamFactory::processConfig
#ifdef __linux__
    auto path = config.get&lt;std::string&gt;(&quot;face_system.unix.path&quot;, &quot;/run/nfd.sock&quot;);
#else
    auto path = config.get&lt;std::string&gt;(&quot;face_system.unix.path&quot;, &quot;/var/run/nfd.sock&quot;);
#endif // __linux__
    return make_shared&lt;ndn::UnixTransport&gt;(path);
  }
  else if (config.get_child_optional(&quot;face_system.tcp&quot;) &amp;&amp;
           config.get&lt;std::string&gt;(&quot;face_system.tcp.listen&quot;, &quot;yes&quot;) == &quot;yes&quot;) {
    // default port should be the same as in TcpFactory::processConfig
    auto port = config.get&lt;std::string&gt;(&quot;face_system.tcp.port&quot;, &quot;6363&quot;);
    return make_shared&lt;ndn::TcpTransport&gt;(&quot;localhost&quot;, port);
  }
  else {
    NDN_THROW(ConfigFile::Error(&quot;No transport is available to communicate with NFD&quot;));
  }
}

Service::Service(const std::string&amp; configFile, ndn::KeyChain&amp; keyChain)
  : Service(keyChain, makeLocalNfdTransport(loadConfigSectionFromFile(configFile)),
            [&amp;configFile] (ConfigFile&amp; config, bool isDryRun) {
              config.parse(configFile, isDryRun);
            })
{
}

Service::Service(const ConfigSection&amp; configSection, ndn::KeyChain&amp; keyChain)
  : Service(keyChain, makeLocalNfdTransport(configSection),
            [&amp;configSection] (ConfigFile&amp; config, bool isDryRun) {
              config.parse(configSection, isDryRun, &quot;internal://nfd.conf&quot;);
            })
{
}

template&lt;typename ConfigParseFunc&gt;
Service::Service(ndn::KeyChain&amp; keyChain, shared_ptr&lt;ndn::Transport&gt; localNfdTransport,
                 const ConfigParseFunc&amp; configParse)
  : m_keyChain(keyChain)
  , m_face(std::move(localNfdTransport), getGlobalIoService(), m_keyChain)
  , m_nfdController(m_face, m_keyChain)
  , m_fibUpdater(m_rib, m_nfdController)
  , m_dispatcher(m_face, m_keyChain)
  , m_ribManager(m_rib, m_face, m_keyChain, m_nfdController, m_dispatcher)
{
  if (s_instance != nullptr) {
    NDN_THROW(std::logic_error(&quot;RIB service cannot be instantiated more than once&quot;));
  }
  if (&amp;getGlobalIoService() != &amp;getRibIoService()) {
    NDN_THROW(std::logic_error(&quot;RIB service must run on RIB thread&quot;));
  }
  s_instance = this;

  ConfigFile config(ConfigFile::ignoreUnknownSection);
  config.addSectionHandler(CFG_RIB, [this] (auto&amp;&amp;... args) {
    processConfig(std::forward&lt;decltype(args)&gt;(args)...);
  });
  configParse(config, true);
  configParse(config, false);

  m_ribManager.registerWithNfd();
  m_ribManager.enableLocalFields();
}

Service::~Service()
{
  s_instance = nullptr;
}

Service&amp;
Service::get()
{
  if (s_instance == nullptr) {
    NDN_THROW(std::logic_error(&quot;RIB service is not instantiated&quot;));
  }
  if (&amp;getGlobalIoService() != &amp;getRibIoService()) {
    NDN_THROW(std::logic_error(&quot;Must get RIB service on RIB thread&quot;));
  }
  return *s_instance;
}

void
Service::processConfig(const ConfigSection&amp; section, bool isDryRun, const std::string&amp; filename)
{
  if (isDryRun) {
    checkConfig(section, filename);
  }
  else {
    applyConfig(section, filename);
  }
}

void
Service::checkConfig(const ConfigSection&amp; section, const std::string&amp; filename)
{
  bool hasLocalhop = false;
  bool hasPropagate = false;

  for (const auto&amp; item : section) {
    const std::string&amp; key = item.first;
    const ConfigSection&amp; value = item.second;
    if (key == CFG_LOCALHOST_SECURITY || key == CFG_PA_VALIDATION) {
      ndn::ValidatorConfig testValidator(m_face);
      testValidator.load(value, filename);
    }
    else if (key == CFG_LOCALHOP_SECURITY) {
      hasLocalhop = true;
      ndn::ValidatorConfig testValidator(m_face);
      testValidator.load(value, filename);
    }
    else if (key == CFG_PREFIX_PROPAGATE) {
      hasPropagate = true;
      // AutoPrefixPropagator does not support config dry-run
    }
    else if (key == CFG_READVERTISE_NLSR) {
      ConfigFile::parseYesNo(item, CFG_RIB + &quot;.&quot; + CFG_READVERTISE_NLSR);
    }
    else {
      NDN_THROW(ConfigFile::Error(&quot;Unrecognized option &quot; + CFG_RIB + &quot;.&quot; + key));
    }
  }

  if (hasLocalhop &amp;&amp; hasPropagate) {
    NDN_THROW(ConfigFile::Error(CFG_LOCALHOP_SECURITY + &quot; and &quot; + CFG_PREFIX_PROPAGATE +
                                &quot; cannot be enabled at the same time&quot;));
  }
}

void
Service::applyConfig(const ConfigSection&amp; section, const std::string&amp; filename)
{
  bool wantPrefixPropagate = false;
  bool wantReadvertiseNlsr = false;

  for (const auto&amp; item : section) {
    const std::string&amp; key = item.first;
    const ConfigSection&amp; value = item.second;
    if (key == CFG_LOCALHOST_SECURITY) {
      m_ribManager.applyLocalhostConfig(value, filename);
    }
    else if (key == CFG_LOCALHOP_SECURITY) {
      m_ribManager.enableLocalhop(value, filename);
    }
    else if (key == CFG_PA_VALIDATION) {
      m_ribManager.applyPaConfig(value, filename);
    }
    else if (key == CFG_PREFIX_PROPAGATE) {
      wantPrefixPropagate = true;

      if (!m_readvertisePropagation) {
        NFD_LOG_DEBUG(&quot;Enabling automatic prefix propagation&quot;);

        auto cost = item.second.get_optional&lt;uint64_t&gt;(&quot;cost&quot;);
        auto parameters = ndn::nfd::ControlParameters()
                          .setCost(cost.value_or(PROPAGATE_DEFAULT_COST))
                          .setOrigin(ndn::nfd::ROUTE_ORIGIN_CLIENT);

        auto timeout = item.second.get_optional&lt;uint64_t&gt;(&quot;timeout&quot;);
        auto options = ndn::nfd::CommandOptions()
                       .setPrefix(RibManager::LOCALHOP_TOP_PREFIX)
                       .setTimeout(timeout ? time::milliseconds(*timeout) : PROPAGATE_DEFAULT_TIMEOUT);

        m_readvertisePropagation = make_unique&lt;Readvertise&gt;(
          m_rib,
          make_unique&lt;HostToGatewayReadvertisePolicy&gt;(m_keyChain, item.second),
          make_unique&lt;NfdRibReadvertiseDestination&gt;(m_nfdController, m_rib, options, parameters));
      }
    }
    else if (key == CFG_READVERTISE_NLSR) {
      wantReadvertiseNlsr = ConfigFile::parseYesNo(item, CFG_RIB + &quot;.&quot; + CFG_READVERTISE_NLSR);
    }
    else {
      NDN_THROW(ConfigFile::Error(&quot;Unrecognized option &quot; + CFG_RIB + &quot;.&quot; + key));
    }
  }

  if (!wantPrefixPropagate &amp;&amp; m_readvertisePropagation != nullptr) {
    NFD_LOG_DEBUG(&quot;Disabling automatic prefix propagation&quot;);
    m_readvertisePropagation.reset();
  }

  if (wantReadvertiseNlsr &amp;&amp; m_readvertiseNlsr == nullptr) {
    NFD_LOG_DEBUG(&quot;Enabling readvertise-to-nlsr&quot;);
    auto options = ndn::nfd::CommandOptions().setPrefix(READVERTISE_NLSR_PREFIX);
    m_readvertiseNlsr = make_unique&lt;Readvertise&gt;(
      m_rib,
      make_unique&lt;ClientToNlsrReadvertisePolicy&gt;(),
      make_unique&lt;NfdRibReadvertiseDestination&gt;(m_nfdController, m_rib, options));
  }
  else if (!wantReadvertiseNlsr &amp;&amp; m_readvertiseNlsr != nullptr) {
    NFD_LOG_DEBUG(&quot;Disabling readvertise-to-nlsr&quot;);
    m_readvertiseNlsr.reset();
  }
}

} // namespace rib
} // namespace nfd
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>measurements.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2019,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;table/measurements.hpp&quot;
#include &quot;table/fib.hpp&quot;
#include &quot;table/pit.hpp&quot;

#include &quot;tests/test-common.hpp&quot;
#include &quot;tests/daemon/global-io-fixture.hpp&quot;

namespace nfd {
namespace measurements {
namespace tests {

using namespace nfd::tests;

BOOST_AUTO_TEST_SUITE(Table)

class MeasurementsFixture : public GlobalIoTimeFixture
{
public:
  MeasurementsFixture()
    : measurements(nameTree)
  {
  }

public:
  NameTree nameTree;
  Measurements measurements;
};

BOOST_FIXTURE_TEST_SUITE(TestMeasurements, MeasurementsFixture)

BOOST_AUTO_TEST_CASE(Get_Parent)
{
  Entry&amp; entryAB = measurements.get(&quot;/A/B&quot;);
  BOOST_CHECK_EQUAL(entryAB.getName(), &quot;/A/B&quot;);

  Entry&amp; entry0 = measurements.get(&quot;/&quot;);
  BOOST_CHECK_EQUAL(entry0.getName(), &quot;/&quot;);

  Entry* entryA = measurements.getParent(entryAB);
  BOOST_REQUIRE(entryA != nullptr);
  BOOST_CHECK_EQUAL(entryA-&gt;getName(), &quot;/A&quot;);

  Entry* entry0c = measurements.getParent(*entryA);
  BOOST_REQUIRE(entry0c != nullptr);
  BOOST_CHECK_EQUAL(&amp;entry0, entry0c);
}

BOOST_AUTO_TEST_CASE(GetLongName)
{
  Name n;
  while (n.size() &lt; NameTree::getMaxDepth() - 1) {
    n.append(&quot;A&quot;);
  }
  Entry&amp; entry1 = measurements.get(n);
  BOOST_CHECK_EQUAL(entry1.getName().size(), NameTree::getMaxDepth() - 1);

  n.append(&quot;B&quot;);
  Entry&amp; entry2 = measurements.get(n);
  BOOST_CHECK_EQUAL(entry2.getName().size(), NameTree::getMaxDepth());

  n.append(&quot;C&quot;);
  Entry&amp; entry3 = measurements.get(n);
  BOOST_CHECK_EQUAL(entry3.getName().size(), NameTree::getMaxDepth());
}

BOOST_AUTO_TEST_CASE(GetWithFibEntry)
{
  Fib fib(nameTree);

  const fib::Entry* fibA = fib.insert(&quot;/A&quot;).first;
  const fib::Entry* fibAB = fib.insert(&quot;/A/B&quot;).first;

  Entry&amp; entryA = measurements.get(*fibA);
  BOOST_CHECK_EQUAL(entryA.getName(), &quot;/A&quot;);

  Entry&amp; entryAB = measurements.get(*fibAB);
  BOOST_CHECK_EQUAL(entryAB.getName(), &quot;/A/B&quot;);
}

BOOST_AUTO_TEST_CASE(GetWithEmptyFibEntry) // Bug 3275
{
  Fib fib(nameTree);

  const fib::Entry&amp; fib0 = fib.findLongestPrefixMatch(&quot;/&quot;);

  Entry&amp; entry0 = measurements.get(fib0);
  BOOST_CHECK_EQUAL(entry0.getName(), &quot;/&quot;);
}

BOOST_AUTO_TEST_CASE(GetWithPitEntry)
{
  Pit pit(nameTree);

  shared_ptr&lt;Interest&gt; interestA = makeInterest(&quot;/A&quot;);
  shared_ptr&lt;pit::Entry&gt; pitA = pit.insert(*interestA).first;
  shared_ptr&lt;Data&gt; dataABC = makeData(&quot;/A/B/C&quot;);
  Name fullName = dataABC-&gt;getFullName();
  shared_ptr&lt;Interest&gt; interestFull = makeInterest(fullName);
  shared_ptr&lt;pit::Entry&gt; pitFull = pit.insert(*interestFull).first;

  Entry&amp; entryA = measurements.get(*pitA);
  BOOST_CHECK_EQUAL(entryA.getName(), &quot;/A&quot;);

  Entry&amp; entryFull = measurements.get(*pitFull);
  BOOST_CHECK_EQUAL(entryFull.getName(), fullName);
}

class DummyStrategyInfo1 : public fw::StrategyInfo
{
public:
  static constexpr int
  getTypeId()
  {
    return 21;
  }
};

class DummyStrategyInfo2 : public fw::StrategyInfo
{
public:
  static constexpr int
  getTypeId()
  {
    return 22;
  }
};

BOOST_AUTO_TEST_CASE(FindLongestPrefixMatch)
{
  measurements.get(&quot;/A&quot;);
  measurements.get(&quot;/A/B/C&quot;).insertStrategyInfo&lt;DummyStrategyInfo1&gt;();
  measurements.get(&quot;/A/B/C/D&quot;);

  Entry* found1 = measurements.findLongestPrefixMatch(&quot;/A/B/C/D/E&quot;);
  BOOST_REQUIRE(found1 != nullptr);
  BOOST_CHECK_EQUAL(found1-&gt;getName(), &quot;/A/B/C/D&quot;);

  Entry* found2 = measurements.findLongestPrefixMatch(&quot;/A/B/C/D/E&quot;,
      EntryWithStrategyInfo&lt;DummyStrategyInfo1&gt;());
  BOOST_REQUIRE(found2 != nullptr);
  BOOST_CHECK_EQUAL(found2-&gt;getName(), &quot;/A/B/C&quot;);

  Entry* found3 = measurements.findLongestPrefixMatch(&quot;/A/B/C/D/E&quot;,
      EntryWithStrategyInfo&lt;DummyStrategyInfo2&gt;());
  BOOST_CHECK(found3 == nullptr);
}

BOOST_AUTO_TEST_CASE(FindLongestPrefixMatchWithPitEntry)
{
  Pit pit(nameTree);

  measurements.get(&quot;/A&quot;);
  measurements.get(&quot;/A/B/C&quot;).insertStrategyInfo&lt;DummyStrategyInfo1&gt;();
  measurements.get(&quot;/A/B/C/D&quot;);

  shared_ptr&lt;Interest&gt; interest = makeInterest(&quot;/A/B/C/D/E&quot;);
  shared_ptr&lt;pit::Entry&gt; pitEntry = pit.insert(*interest).first;

  Entry* found1 = measurements.findLongestPrefixMatch(*pitEntry);
  BOOST_REQUIRE(found1 != nullptr);
  BOOST_CHECK_EQUAL(found1-&gt;getName(), &quot;/A/B/C/D&quot;);

  Entry* found2 = measurements.findLongestPrefixMatch(*pitEntry,
      EntryWithStrategyInfo&lt;DummyStrategyInfo1&gt;());
  BOOST_REQUIRE(found2 != nullptr);
  BOOST_CHECK_EQUAL(found2-&gt;getName(), &quot;/A/B/C&quot;);

  Entry* found3 = measurements.findLongestPrefixMatch(*pitEntry,
      EntryWithStrategyInfo&lt;DummyStrategyInfo2&gt;());
  BOOST_CHECK(found3 == nullptr);
}

BOOST_AUTO_TEST_CASE(Lifetime)
{
  Name nameA(&quot;ndn:/A&quot;);
  Name nameB(&quot;ndn:/B&quot;);
  Name nameC(&quot;ndn:/C&quot;);

  BOOST_CHECK_EQUAL(measurements.size(), 0);
<A NAME="0"></A>
  Entry&amp; entryA = measurements.get(nameA);
  measurements.get(nameB);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match536-0.html#0',2,'match536-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  Entry&amp; entryC = measurements.get(nameC);
  BOOST_CHECK_EQUAL(measurements.size(), 3);

  const time::nanoseconds EXTEND_A = 2_s;
  const time::nanoseconds CHECK1 = 3_s;
  const time::nanoseconds CHECK2 = 5_s;
  const time::nanoseconds EXTEND_C = 6_s;
  const time::nanoseconds CHECK3 = 7_s;</B></FONT>
  BOOST_ASSERT(EXTEND_A &lt; CHECK1);
  BOOST_ASSERT(CHECK1 &lt; Measurements::getInitialLifetime());
  BOOST_ASSERT(Measurements::getInitialLifetime() &lt; CHECK2);
  BOOST_ASSERT(CHECK2 &lt; EXTEND_C);
  BOOST_ASSERT(EXTEND_C &lt; CHECK3);

  measurements.extendLifetime(entryA, EXTEND_A);
  measurements.extendLifetime(entryC, EXTEND_C);
  // remaining lifetime:
  //   A = initial lifetime, because it's extended by less duration
  //   B = initial lifetime
  //   C = EXTEND_C

  this-&gt;advanceClocks(100_ms, CHECK1);
  BOOST_CHECK(measurements.findExactMatch(nameA) != nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameB) != nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameC) != nullptr);
  BOOST_CHECK_EQUAL(measurements.size(), 3);

  this-&gt;advanceClocks(100_ms, CHECK2 - CHECK1);
  BOOST_CHECK(measurements.findExactMatch(nameA) == nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameB) == nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameC) != nullptr);
  BOOST_CHECK_EQUAL(measurements.size(), 1);

  this-&gt;advanceClocks(100_ms, CHECK3 - CHECK2);
  BOOST_CHECK(measurements.findExactMatch(nameA) == nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameB) == nullptr);
  BOOST_CHECK(measurements.findExactMatch(nameC) == nullptr);
  BOOST_CHECK_EQUAL(measurements.size(), 0);
}

BOOST_AUTO_TEST_CASE(EraseNameTreeEntry)
{
  size_t nNameTreeEntriesBefore = nameTree.size();

  measurements.get(&quot;/A&quot;);
  BOOST_CHECK_EQUAL(measurements.size(), 1);

  this-&gt;advanceClocks(Measurements::getInitialLifetime() + 10_ms);
  BOOST_CHECK_EQUAL(measurements.size(), 0);
  BOOST_CHECK_EQUAL(nameTree.size(), nNameTreeEntriesBefore);
}

BOOST_AUTO_TEST_SUITE_END() // TestMeasurements
BOOST_AUTO_TEST_SUITE_END() // Table

} // namespace tests
} // namespace measurements
} // namespace nfd
</PRE>
</div>
  </div>
</body>
</html>
