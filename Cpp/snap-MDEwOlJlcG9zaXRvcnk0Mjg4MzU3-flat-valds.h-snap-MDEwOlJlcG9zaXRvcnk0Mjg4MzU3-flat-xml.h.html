
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-valds.h</h3>
            <pre><code>1  ClassTPV(TTbValDs, PTbValDs, TTbValDsV)
2  private:
3    TBool DefP;
4  private:
5    TFlt SumW;
6    TFltV ValTagWV;
7    TFltV DscWV;
8    PMom FltMom;
9  public:
10    TTbValDs(const int& Dscs=0):
11      DefP(), SumW(), ValTagWV(tvtMx), DscWV(Dscs), FltMom(TMom::New()){}
12    static PTbValDs New(const int& Dscs=0){
13      return PTbValDs(new TTbValDs(Dscs));}
14    TTbValDs(TSIn& SIn):
15      DefP(SIn), SumW(SIn), ValTagWV(SIn), DscWV(SIn), FltMom(SIn){}
16    static PTbValDs Load(TSIn& SIn){return new TTbValDs(SIn);}
17    void Save(TSOut& SOut){
18      IAssert(DefP); DefP.Save(SOut);
19      SumW.Save(SOut); ValTagWV.Save(SOut); DscWV.Save(SOut); FltMom.Save(SOut);}
20    void Def(){
21      IAssert(!DefP); DefP=true;
22      IAssert(!(IsDsc()&&IsFlt())); FltMom->Def();}
23    bool IsDef() const {return DefP;}
24    TTbValDs& operator=(const TTbValDs&){Fail; return *this;}
25    void AddVal(const TTbVal& Val, const double& Wgt=1);
26    void ExpW();
27    bool IsEmpty() const {Assert(DefP); return double(SumW)==0;}
28    bool IsDsc() const {Assert(DefP); return double(ValTagWV[tvtDsc])!=0;}
29    bool IsFlt() const {Assert(DefP); return double(ValTagWV[tvtFlt])!=0;}
30    int GetDscs() const {Assert(DefP); return DscWV.Len();}
31    double GetSumW() const {Assert(DefP); return SumW;}
32    double GetSumPrb(const double& PriorSumW) const {
33      Assert(DefP&&((double)SumW<=PriorSumW));
34      if (PriorSumW==0){return 0;} else {return SumW/PriorSumW;}}
35    double GetValTagW(const int& ValTag) const {
36      Assert(DefP); return ValTagWV[ValTag];}
37    double GetValW(const TTbVal& Val) const;
<span onclick='openModal()' class='match'>38    PMom GetFltMom() const {Assert(DefP); return FltMom;}
39    bool IsOneVal() const;
</span>40    TTbVal GetMajorVal() const;
41    double GetPrb_RelFq(const TTbVal& Val) const;
42    double GetPrb_Laplace(const TTbVal& Val) const;
43    double GetPrb_QuinLaplace(const TTbVal& Val, const double& PriorPrb) const;
44    double GetPrb_MEst(
45     const TTbVal& Val, const double& MParam, const double& PriorPrb) const;
46    TStr GetStr(const PTbVarType& VarType) const;
47    static PTbValDs GetCValDs(
48     const int& ClassN, const PDm& Dm, const PExSet& ExSet);
49    static PTbValDs GetBoolValDs(const double& NegValW, const double& PosValW);
50  };
51  ClassTP(TDmDs, PDmDs)
52  private:
53    UndefCopy(TDmDs);
54  public:
55    TDmDs(){}
56    virtual ~TDmDs(){}
57    TDmDs(TSIn&){}
58    static PDmDs Load(TSIn& SIn);
59    void Save(TSOut& SOut){GetTypeNm(*this).Save(SOut);}
60    TDmDs& operator=(const TDmDs&){return *this;}
61    virtual double GetSumW() const=0;
62    virtual PTbValDs GetCDs() const=0;
63    virtual PTbValDs GetAVDs(const int& AttrN) const=0;
64    virtual PTbValDs GetCAVDs(const TTbVal& CVal, const int& AttrN) const=0;
65    double GetCPrb_RelFq(const TTbVal& CVal){
66      return GetCDs()->GetPrb_RelFq(CVal);}
67    double GetCPrb_Laplace(const TTbVal& CVal){
68      return GetCDs()->GetPrb_Laplace(CVal);}
69    double GetCPrb_QuinLaplace(const TTbVal& CVal, const PDmDs& PriorDmDs){
70      double PriorPrb=PriorDmDs->GetCPrb_RelFq(CVal);
71      return GetCDs()->GetPrb_QuinLaplace(CVal, PriorPrb);}
72    double GetCPrb_MEst(const TTbVal& CVal,
73     const double& MParam, const PDmDs& PriorDmDs){
74      double PriorPrb=PriorDmDs->GetCPrb_RelFq(CVal);
75      return GetCDs()->GetPrb_MEst(CVal, MParam, PriorPrb);}
76    double GetAVPrb_RelFq(const int& AttrN, const TTbVal& AVal){
77      return GetAVDs(AttrN)->GetPrb_RelFq(AVal);}
78    double GetAVPrb_Laplace(const int& AttrN, const TTbVal& AVal){
79      return GetAVDs(AttrN)->GetPrb_Laplace(AVal);}
80    double GetAVPrb_QuinLaplace(
81     const int& AttrN, const TTbVal& AVal, const PDmDs& PriorDmDs){
82      double PriorPrb=PriorDmDs->GetAVPrb_RelFq(AttrN, AVal);
83      return GetAVDs(AttrN)->GetPrb_QuinLaplace(AVal, PriorPrb);}
84    double GetAVPrb_MEst(const int& AttrN, const TTbVal& AVal,
85     const double& MParam, const PDmDs& PriorDmDs){
86      double PriorPrb=PriorDmDs->GetAVPrb_RelFq(AttrN, AVal);
87      return GetAVDs(AttrN)->GetPrb_MEst(AVal, MParam, PriorPrb);}
88    double GetCAVPrb_RelFq(const TTbVal& CVal,
89     const int& AttrN, const TTbVal& AVal){
90      return GetCAVDs(CVal, AttrN)->GetPrb_RelFq(AVal);}
91    double GetCAVPrb_Laplace(const TTbVal& CVal,
92     const int& AttrN, const TTbVal& AVal){
93      return GetCAVDs(CVal, AttrN)->GetPrb_Laplace(AVal);}
94    double GetCAVPrb_QuinLaplace(const TTbVal& CVal,
95     const int& AttrN, const TTbVal& AVal, const PDmDs& PriorDmDs){
96      double PriorPrb=PriorDmDs->GetCAVPrb_RelFq(CVal, AttrN, AVal);
97      return GetCAVDs(CVal, AttrN)->GetPrb_QuinLaplace(AVal, PriorPrb);}
98    double GetCAVPrb_MEst(const TTbVal& CVal,
99     const int& AttrN, const TTbVal& AVal,
100     const double& MParam, const PDmDs& PriorDmDs){
101      double PriorPrb=PriorDmDs->GetCAVPrb_RelFq(CVal, AttrN, AVal);
102      return GetCAVDs(CVal, AttrN)->GetPrb_MEst(AVal, MParam, PriorPrb);}
103  };
104  class TGDmDs: public TDmDs{
105  private:
106    TFlt SumW;
107    PTbValDs CDs;
108    TTbValDsV AVDsV;
109    TVVec<PTbValDs> CAVDsVV;
110    inline void AddVal(
111     const TTbVal& CVal, const int& AttrN, const TTbVal& AVal, const double& Wgt);
112  public:
113    TGDmDs(const PDm& Dm, const int& ClassN, const PExSet& ExSet);
114    static PDmDs New(const PDm& Dm, const int& ClassN, const PExSet& ExSet){
115      return PDmDs(new TGDmDs(Dm, ClassN, ExSet));}
116    TGDmDs(TSIn& SIn):
117      SumW(SIn), CDs(SIn), AVDsV(SIn), CAVDsVV(SIn){}
118    void Save(TSOut& SOut){
119      SumW.Save(SOut); CDs.Save(SOut); AVDsV.Save(SOut); CAVDsVV.Save(SOut);}
120    TGDmDs& operator=(const TGDmDs& GDmDs){
121      TDmDs::operator=(GDmDs);
122      SumW=GDmDs.SumW; CDs=GDmDs.CDs; AVDsV=GDmDs.AVDsV; CAVDsVV=GDmDs.CAVDsVV;
123      return *this;}
124    double GetSumW() const {return SumW;}
125    PTbValDs GetCDs() const {return CDs;}
126    PTbValDs GetAVDs(const int& AttrN) const {return AVDsV[AttrN];}
127    PTbValDs GetCAVDs(const TTbVal& CVal, const int& AttrN) const {
128      return CAVDsVV.At(CVal.GetDsc(), AttrN);}
129  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.h</h3>
            <pre><code>1  #include "bd.h"
2  class TXmlObjSer{
3  private:
4    static TStrStrH TypeNmToTagNmH;
5  public:
6    static TStr GetTagNm(const TStr& TypeNm);
7    static void AssertXmlHd(
8     const PXmlTok& XmlTok, const TStr& Nm, const TStr& TypeNm);
9    static bool GetBoolArg(const PXmlTok& XmlTok, const TStr& Nm);
10    static int GetIntArg(const PXmlTok& XmlTok, const TStr& Nm);
11    static int64 GetInt64Arg(const PXmlTok& XmlTok, const TStr& Nm);
12    static double GetFltArg(const PXmlTok& XmlTok, const TStr& Nm);
13  };
14  class TXmlObjSerTagNm{
15  private:
16    TStr TagNm;
17    TSOut* SOut;
18    UndefDefaultCopyAssign(TXmlObjSerTagNm);
19  public:
20    TXmlObjSerTagNm(
21     TSOut& _SOut, const bool& ETagP,
22     const TStr& Nm, const TStr& TypeNm,
23     const TStr& ArgNm="", const TStr& ArgVal="");
24    TXmlObjSerTagNm(
25     TSOut& _SOut, const bool& ETagP,
26     const TStr& Nm, const TStr& TypeNm,
27     const TStr& ArgNm1, const TStr& ArgVal1,
28     const TStr& ArgNm2, const TStr& ArgVal2,
29     const TStr& ArgNm3="", const TStr& ArgVal3="",
30     const TStr& ArgNm4="", const TStr& ArgVal4="");
31    ~TXmlObjSerTagNm();
32  };
33  ClassTP(TXmlChDef, PXmlChDef)
34  private:
35    TInt Chs;
36    TBSet CharChSet, CombChSet, ExtChSet;
37    TBSet LetterChSet, DigitChSet, NameChSet, PubidChSet;
38    TStrStrH EntityNmToValH;
39    void SetChTy(TBSet& ChSet, const int& MnCh, const int& MxCh=-1);
40    void SetChTy(TBSet& ChSet, const TStr& Str);
41    void SetEntityVal(const TStr& Nm, const TStr& Val);
42  public:
43    TXmlChDef();
44    TXmlChDef(TSIn& SIn):
45      Chs(SIn),
46      CharChSet(SIn), CombChSet(SIn), ExtChSet(SIn),
47      LetterChSet(SIn), DigitChSet(SIn), NameChSet(SIn), PubidChSet(SIn),
48      EntityNmToValH(SIn){}
49    static PXmlChDef Load(TSIn& SIn){return new TXmlChDef(SIn);}
50    void Save(TSOut& SOut){
51      Chs.Save(SOut);
52      CharChSet.Save(SOut); CombChSet.Save(SOut); ExtChSet.Save(SOut);
53      LetterChSet.Save(SOut); DigitChSet.Save(SOut); NameChSet.Save(SOut);
54      PubidChSet.Save(SOut);
55      EntityNmToValH.Save(SOut);}
56    TXmlChDef& operator=(const TXmlChDef&){Fail; return *this;}
57    bool IsChar(const uchar& Ch) const {return CharChSet.GetBit(Ch);}
58    bool IsComb(const uchar& Ch) const {return CombChSet.GetBit(Ch);}
59    bool IsExt(const uchar& Ch) const {return ExtChSet.GetBit(Ch);}
60    bool IsLetter(const uchar& Ch) const {return LetterChSet.GetBit(Ch);}
61    bool IsDigit(const uchar& Ch) const {return DigitChSet.GetBit(Ch);}
62    bool IsName(const uchar& Ch) const {return NameChSet.GetBit(Ch);}
63    bool IsPubid(const uchar& Ch) const {return PubidChSet.GetBit(Ch);}
64    bool IsWs(const uchar& Ch) const {
65      return (Ch==' ')||(Ch==TCh::CrCh)||(Ch==TCh::LfCh)||(Ch==TCh::TabCh);}
66    bool IsFirstNameCh(const uchar& Ch) const {
67      return IsLetter(Ch)||(Ch=='_')||(Ch==':');}
68    bool IsEoln(const uchar& Ch) const {
69      return (Ch==TCh::CrCh)||(Ch==TCh::LfCh);}
70    bool IsEntityNm(const TStr& EntityNm, TStr& EntityVal) const {
71      return EntityNmToValH.IsKeyGetDat(EntityNm, EntityVal);}
72  };
73  typedef enum {
74    xsyUndef, xsyWs, xsyComment,
75    xsyXmlDecl, xsyPI,
76    xsyDocTypeDecl, xsyElement, xsyAttList, xsyEntity, xsyNotation,
77    xsyTag, xsySTag, xsyETag, xsySETag, xsyStr, xsyQStr,
78    xsyEof} TXmlLxSym;
79  typedef enum {xspIntact, xspPreserve, xspSeparate, xspTruncate} TXmlSpacing;
80  class TXmlLx{
81  private: 
82    static TXmlChDef ChDef;
83    PSIn SIn;
84    TSIn& RSIn;
85    TChA ChStack;
86    uchar PrevCh, Ch;
87    int LnN, LnChN, ChN;
88    TXmlSpacing Spacing;
89    uchar GetCh();
90    void PutCh(const uchar& _Ch){ChStack.Push(Ch); Ch=_Ch;}
91    void PutStr(const TStr& Str){
92      for (int ChN=Str.Len()-1; ChN>=0; ChN--){PutCh(Str[ChN]);}}
93    void ToNrSpacing();
94  private: 
95    TStrStrH EntityNmToValH, PEntityNmToValH;
96    void GetWs(const bool& IsRq);
97    TStr GetReference();
98    void GetEq();
99    TStr GetName();
100    TStr GetName(const TStr& RqNm);
101    void GetComment();
102    TStr GetAttValue();
103    TStr GetVersionNum();
104    TStr GetEncName();
105    TStr GetStalVal();
106    void GetXmlDecl();
107    void GetPI();
108    TStr GetSystemLiteral();
109    TStr GetPubidLiteral();
110    TStr GetPEReference();
111    void GetExternalId();
112    void GetNData();
113    void GetDocTypeDecl();
114    void GetElement();
115    void GetAttList();
116    TStr GetEntityValue();
117    void GetEntity();
118    void GetNotation();
119    void GetCDSect();
120  public: 
121    TXmlLxSym Sym;
122    TChA TxtChA;
123    TStr TagNm;
124    TStrKdV ArgNmValKdV;
125    void SkipWs();
126  public:
127    TXmlLx(const PSIn& _SIn, const TXmlSpacing& _Spacing=xspIntact):
128      SIn(_SIn), RSIn(*SIn),
129      ChStack(), PrevCh(' '), Ch(' '),
130      LnN(1), LnChN(0), ChN(0), Spacing(_Spacing),
131      EntityNmToValH(100), PEntityNmToValH(100),
132      Sym(xsyUndef), TxtChA(), TagNm(), ArgNmValKdV(10){GetCh();}
133    TXmlLx& operator=(const TXmlLx&){Fail; return *this;}
134    TXmlLxSym GetSym();
135    TStr GetSymStr() const;
136    void EThrow(const TStr& MsgStr) const;
137    TStr GetFPosStr() const;
138    void ClrArgV(){ArgNmValKdV.Clr();}
139    void AddArg(const TStr& ArgNm, const TStr& ArgVal){
140      ArgNmValKdV.Add(TStrKd(ArgNm, ArgVal));}
141    bool IsArgNm(const TStr& ArgNm) const {
142      return ArgNmValKdV.IsIn(TStrKd(ArgNm));}
143    int GetArgs() const {return ArgNmValKdV.Len();}
144    void GetArg(const int& ArgN, TStr& ArgNm, TStr& ArgVal) const {
145      ArgNm=ArgNmValKdV[ArgN].Key; ArgVal=ArgNmValKdV[ArgN].Dat;}
146    TStr GetArgVal(const TStr& ArgNm, const TStr& DfVal=TStr()) const {
147      int ArgN=ArgNmValKdV.SearchForw(TStrKd(ArgNm));
148      if (ArgN==-1){return DfVal;} else {return ArgNmValKdV[ArgN].Dat;}}
149    static char GetArgValQCh(const TStr& ArgVal){
150      if (ArgVal.IsChIn('\"')){return '\'';} else {return '\"';}}
151    bool IsEntityNm(const TStr& EntityNm, TStr& EntityVal) const {
152      return EntityNmToValH.IsKeyGetDat(EntityNm, EntityVal);}
153    void PutEntityVal(const TStr& Nm, const TStr& Val){
154      EntityNmToValH.AddDat(Nm, Val);}
155    bool IsPEntityNm(const TStr& EntityNm, TStr& EntityVal) const {
156      return PEntityNmToValH.IsKeyGetDat(EntityNm, EntityVal);}
157    void PutPEntityVal(const TStr& Nm, const TStr& Val){
158      PEntityNmToValH.AddDat(Nm, Val);}
159    static TStr GetXmlLxSymStr(const TXmlLxSym& XmlLxSym);
160    static bool IsTagNm(const TStr& Str);
161    static TStr GetXmlStrFromPlainMem(const TMem& PlainMem);
162    static TStr GetXmlStrFromPlainStr(const TChA& PlainChA);
163    static TStr GetPlainStrFromXmlStr(const TStr& XmlStr);
164    static TStr GetUsAsciiStrFromXmlStr(const TStr& EntRefStr);
165    static TStr GetChRefFromYuEntRef(const TStr& YuEntRefStr);
166  };
167  ClassTPV(TXmlTok, PXmlTok, TXmlTokV)
168  private:
169    TXmlLxSym Sym;
170    TStr Str;
171    TStrKdV ArgNmValV;
172    TXmlTokV SubTokV;
173  public:
174    TXmlTok(): Sym(xsyUndef), Str(), ArgNmValV(), SubTokV(){}
175    TXmlTok(const TXmlLxSym& _Sym):
176      Sym(_Sym), Str(), ArgNmValV(), SubTokV(){}
177    TXmlTok(const TXmlLxSym& _Sym, const TStr& _Str):
178      Sym(_Sym), Str(_Str), ArgNmValV(), SubTokV(){}
179    TXmlTok(const TXmlLxSym& _Sym, const TStr& _Str, const TStrKdV& _ArgNmValV):
180      Sym(_Sym), Str(_Str), ArgNmValV(_ArgNmValV){}
181    static PXmlTok New(){return PXmlTok(new TXmlTok());}
182    static PXmlTok New(const TXmlLxSym& Sym){return PXmlTok(new TXmlTok(Sym));}
183    static PXmlTok New(const TXmlLxSym& Sym, const TStr& Str){
184      return PXmlTok(new TXmlTok(Sym, Str));}
185    static PXmlTok New(
186     const TXmlLxSym& Sym, const TStr& Str, const TStrKdV& ArgNmValV){
187      return PXmlTok(new TXmlTok(Sym, Str, ArgNmValV));}
188    static PXmlTok New(
189     const TStr& TagNm, const TStrKdV& ArgNmValV){
190      return PXmlTok(new TXmlTok(xsyTag, TagNm, ArgNmValV));}
191    static PXmlTok New(const TStr& TagNm){
192      return PXmlTok(new TXmlTok(xsyTag, TagNm));}
193    static PXmlTok New(const TStr& TagNm, const TStr& ValStr){
194      PXmlTok TagXmlTok=PXmlTok(new TXmlTok(xsyTag, TagNm));
195      PXmlTok StrXmlTok=PXmlTok(new TXmlTok(xsyStr, ValStr));
196      TagXmlTok->AddSubTok(StrXmlTok); return TagXmlTok;}
197    static PXmlTok New(const TStr& TagNm,
198     const PXmlTok& XmlTok1, const PXmlTok& XmlTok2=NULL){
199      PXmlTok TagXmlTok=PXmlTok(new TXmlTok(xsyTag, TagNm));
200      if (!XmlTok1.Empty()){TagXmlTok->AddSubTok(XmlTok1);}
201      if (!XmlTok2.Empty()){TagXmlTok->AddSubTok(XmlTok2);}
202      return TagXmlTok;}
203    TXmlTok(TSIn&){Fail;}
204    static PXmlTok Load(TSIn&){Fail; return NULL;}
205    void Save(TSOut&){Fail;}
206    TXmlTok& operator=(const TXmlTok&){Fail; return *this;}
207    TXmlLxSym GetSym() const {return Sym;}
208    TStr GetSymStr() const {return TXmlLx::GetXmlLxSymStr(Sym);}
209    void PutStr(const TStr& _Str){Str=_Str;}
210    TStr GetStr() const {return Str;}
211    bool IsTag() const {return (Sym==xsyTag);}
212    bool IsTag(const TStr& TagNm) const {return (Sym==xsyTag)&&(Str==TagNm);}
213    TStr GetTagNm() const {IAssert(Sym==xsyTag); return Str;}
214    void AddArg(const TStr& ArgNm, const bool& ArgVal){
215      ArgNmValV.Add(TStrKd(ArgNm, TBool::GetStr(ArgVal)));}
216    void AddArg(const TStr& ArgNm, const int& ArgVal){
217      ArgNmValV.Add(TStrKd(ArgNm, TInt::GetStr(ArgVal)));}
218    void AddArg(const TStr& ArgNm, const uint64& ArgVal){
219      ArgNmValV.Add(TStrKd(ArgNm, TUInt64::GetStr(ArgVal)));}
220    void AddArg(const TStr& ArgNm, const double& ArgVal){
221      ArgNmValV.Add(TStrKd(ArgNm, TFlt::GetStr(ArgVal)));}
222    void AddArg(const TStr& ArgNm, const TStr& ArgVal){
223      ArgNmValV.Add(TStrKd(ArgNm, ArgVal));}
224    int GetArgs() const {return ArgNmValV.Len();}
225    void GetArg(const int& ArgN, TStr& ArgNm, TStr& ArgVal) const {
226      ArgNm=ArgNmValV[ArgN].Key; ArgVal=ArgNmValV[ArgN].Dat;}
227    bool IsArg(const TStr& ArgNm) const {
228      return ArgNmValV.SearchForw(TStrKd(ArgNm))!=-1;}
229    bool IsArg(const TStr& ArgNm, TStr& ArgVal) const {
230      int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
231      if (ArgN!=-1){ArgVal=ArgNmValV[ArgN].Dat;}
232      return ArgN!=-1;}
233    void PutArgVal(const TStr& ArgNm, const TStr& ArgVal){
234      ArgNmValV[ArgNmValV.SearchForw(TStrKd(ArgNm))].Dat=ArgVal;}
235    TStr GetArgVal(const TStr& ArgNm) const {
236      return ArgNmValV[ArgNmValV.SearchForw(TStrKd(ArgNm))].Dat;}
237    TStr GetArgVal(const TStr& ArgNm, const TStr& DfArgVal) const {
238      int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
239      return (ArgN==-1) ? DfArgVal : ArgNmValV[ArgN].Dat;}
240    bool GetBoolArgVal(const TStr& ArgNm, const bool& DfVal=false) const;
241    bool GetBoolArgVal(
242     const TStr& ArgNm, const TStr& TrueVal, const bool& DfVal=false) const;
243    bool GetBoolArgVal(const TStr& ArgNm,
244     const TStr& TrueVal, const TStr& FalseVal, const bool& DfVal=false) const;
245    int GetIntArgVal(const TStr& ArgNm, const int& DfVal=0) const;
246    double GetFltArgVal(const TStr& ArgNm, const double& DfVal=0) const;
247    TStr GetStrArgVal(const TStr& ArgNm, const TStr& DfVal=TStr()) const;
248    bool IsSubTag(const TStr& TagNm) const {
249      return !GetTagTok(TagNm).Empty();}
250    bool IsSubTag(const TStr& TagNm, PXmlTok& Tok) const {
251      Tok=GetTagTok(TagNm); return !Tok.Empty();}
252    void AddSubTok(const PXmlTok& Tok){SubTokV.Add(Tok);}
253    int GetSubToks() const {return SubTokV.Len();}
254    PXmlTok GetSubTok(const int& SubTokN) const {return SubTokV[SubTokN];}
255    void ClrSubTok(){SubTokV.Clr();}
256    void PutSubTok(const PXmlTok& Tok, const int& SubTokN=-1);
257    bool IsTagTok(const TStr& TagPath, PXmlTok& TagTok) const {
258      TagTok=GetTagTok(TagPath); return !TagTok.Empty();}
259    bool IsTagTok(const TStr& TagPath) const {
260      PXmlTok TagTok; return IsTagTok(TagPath, TagTok);}
261    PXmlTok GetTagTok(const TStr& TagPath) const;
262    void GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const;
263    void GetTagValV(const TStr& TagNm, const bool& XmlP, TStrV& ValV) const;
264    TStr GetTagVal(const TStr& TagNm, const bool& XmlP) const;
265    TStr GetTagTokStr(const TStr& TagPath) const {
266      return GetTagTok(TagPath)->GetTokStr(false);}
267    TStr GetTagTokStrOrDf(const TStr& TagPath, const TStr& DfVal=TStr()) const {
268      PXmlTok TagTok;
269      if (IsTagTok(TagPath, TagTok)){return TagTok->GetTokStr(false);}
270      else {return DfVal;}}
271    void AddTokToChA(const bool& XmlP, TChA& ChA) const;
272    TStr GetTokStr(const bool& XmlP=true) const {
273      TChA ChA; AddTokToChA(XmlP, ChA); return ChA;}
274    static TStr GetTokVStr(const TXmlTokV& TokV, const bool& XmlP=true);
275    static PXmlTok GetTok(TXmlLx& Lx);
276  };
277  ClassTPV(TXmlDoc, PXmlDoc, TXmlDocV)
278  private:
279    bool Ok;
280    TStr MsgStr;
281    PXmlTok Tok;
282    static void LoadTxtMiscStar(TXmlLx& Lx);
283    static PXmlTok LoadTxtElement(TXmlLx& Lx);
284  public:
285    TXmlDoc(): Ok(false), MsgStr(), Tok(){}
286    static PXmlDoc New(){return PXmlDoc(new TXmlDoc());}
287    TXmlDoc(const PXmlTok& _Tok): Ok(!_Tok.Empty()), MsgStr(), Tok(_Tok){}
288    static PXmlDoc New(const PXmlTok& Tok){return PXmlDoc(new TXmlDoc(Tok));}
289    TXmlDoc(TSIn&){Fail;}
290    static PXmlDoc Load(TSIn& SIn){return new TXmlDoc(SIn);}
291    void Save(TSOut&){Fail;}
292    TXmlDoc& operator=(const TXmlDoc&){Fail; return *this;}
293    bool IsOk() const {return Ok;}
294    TStr GetMsgStr() const {return MsgStr;}
<span onclick='openModal()' class='match'>295    PXmlTok GetTok() const {IAssert(Ok); return Tok;}
296    bool IsTagTok(const TStr& TagPath, PXmlTok& TagTok) const {
</span>297      IAssert(Ok); TagTok=GetTagTok(TagPath); return !TagTok.Empty();}
298    bool IsTagTok(const TStr& TagPath) const {
299      PXmlTok TagTok; return IsTagTok(TagPath, TagTok);}
300    PXmlTok GetTagTok(const TStr& TagPath) const;
301    void PutTagTokStr(const TStr& TagPath, const TStr& TokStr) const;
302    TStr GetTagTokStr(const TStr& TagPath) const {
303      return GetTagTok(TagPath)->GetTokStr(false);}
304    void GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const;
305    void GetTagValV(const TStr& TagNm, const bool& XmlP, TStrV& ValV) const {
306      IAssert(Ok); Tok->GetTagValV(TagNm, XmlP, ValV);}
307    TStr GetTagVal(const TStr& TagNm, const bool& XmlP) const {
308      TStrV ValV; GetTagValV(TagNm, XmlP, ValV);
309      if (ValV.Len()>0){return ValV[0];} else {return "";}}
310    bool GetTagTokBoolArgVal(
311     const TStr& TagPath, const TStr& ArgNm, const bool& DfVal=false) const;
312    int GetTagTokIntArgVal(
313     const TStr& TagPath, const TStr& ArgNm, const int& DfVal=0) const;
314    double GetTagTokFltArgVal(
315     const TStr& TagPath, const TStr& ArgNm, const double& DfVal=0) const;
316    TStr GetTagTokStrArgVal(
317     const TStr& TagPath, const TStr& ArgNm, const TStr& DfVal=TStr()) const;
318    static TStr GetXmlStr(const TStr& Str);
319    static bool SkipTopTag(const PSIn& SIn);
320    static PXmlDoc LoadTxt(TXmlLx& Lx);
321    static PXmlDoc LoadTxt(const PSIn& SIn, const TXmlSpacing& Spacing=xspIntact);
322    static PXmlDoc LoadTxt(const TStr& FNm, const TXmlSpacing& Spacing=xspIntact);
323    static void LoadTxt(
324     const TStr& FNm, TXmlDocV& XmlDocV, const TXmlSpacing& Spacing=xspIntact);
325    void SaveTxt(const PSOut& SOut){
326      SOut->PutStr(GetTok()->GetTokStr());}
327    void SaveTxt(const TStr& FNm, const bool& Append=false){
328      PSOut SOut=TFOut::New(FNm, Append); SaveTxt(SOut);}
329    static PXmlDoc LoadStr(const TStr& Str);
330    void SaveStr(TStr& Str);
331  };
332  class TXmlParser;
333  typedef TPt<TXmlParser> PXmlParser;
334  class TXmlParser {  
335  private:
336    TCRef CRef;
337    PSIn SIn;
338    TSIn& RSIn;
339    TChA _SymStr;
340  public:
341    TXmlLxSym Sym, NextSym;
342    TChA SymStr, NextSymStr;
343  private:
344    char GetCh() { return (! RSIn.Eof()) ? RSIn.GetCh() : TCh::EofCh; }
345  public:
346    TXmlParser(const PSIn& _SIn) : SIn(_SIn), RSIn(*SIn), Sym(xsyUndef), NextSym(xsyUndef) { }
347    static PXmlParser New(const PSIn& SIn) { return new TXmlParser(SIn); }
348    TXmlLxSym GetSym();
349    TXmlLxSym GetSym(TChA& _SymStr);
350    TXmlLxSym PeekSym();
351    TXmlLxSym PeekSym(TChA& _SymStr);
352    void SkipTillTag(const TChA& _SymStr);
353    TXmlLxSym GetTag(const TChA& TagStr);
354    void GetTagVal(const TChA& TagStr, TChA& TagVal);
355    static void GetPlainStrFromXmlStr(const TChA& XmlStr, TChA& PlainChA);
356    friend class TPt<TXmlParser>;
357  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-valds.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.h</div>
                </div>
                <div class="column column_space"><pre><code>38    PMom GetFltMom() const {Assert(DefP); return FltMom;}
39    bool IsOneVal() const;
</pre></code></div>
                <div class="column column_space"><pre><code>295    PXmlTok GetTok() const {IAssert(Ok); return Tok;}
296    bool IsTagTok(const TStr& TagPath, PXmlTok& TagTok) const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    