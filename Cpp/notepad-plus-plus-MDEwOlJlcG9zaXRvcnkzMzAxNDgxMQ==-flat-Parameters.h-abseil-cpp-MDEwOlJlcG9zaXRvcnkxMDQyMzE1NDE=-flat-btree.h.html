
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.035054967848994%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.h</h3>
            <pre><code>1  #pragma once
2  #include "tinyxmlA.h"
3  #include "tinyxml.h"
4  #include "Scintilla.h"
5  #include "ScintillaRef.h"
6  #include "ToolBar.h"
7  #include "UserDefineLangReference.h"
8  #include "colors.h"
9  #include "shortcut.h"
10  #include "ContextMenu.h"
11  #include "dpiManager.h"
12  #include "NppDarkMode.h"
13  #include <assert.h>
14  #include <tchar.h>
15  #include <map>
16  #include "ILexer.h"
17  #include "Lexilla.h"
18  #ifdef _WIN64
19  #ifdef _M_ARM64
20  #define ARCH_TYPE IMAGE_FILE_MACHINE_ARM64
21  #else
22  #define ARCH_TYPE IMAGE_FILE_MACHINE_AMD64
23  #endif
24  #else
25  #define ARCH_TYPE IMAGE_FILE_MACHINE_I386
26  #endif
27  #define CMD_INTERPRETER TEXT("%COMSPEC%")
28  class NativeLangSpeaker;
29  const bool POS_VERTICAL = true;
30  const bool POS_HORIZOTAL = false;
31  const int UDD_SHOW   = 1; 
32  const int UDD_DOCKED = 2; 
33  const int TAB_DRAWTOPBAR = 1;      
34  const int TAB_DRAWINACTIVETAB = 2; 
35  const int TAB_DRAGNDROP = 4;       
36  const int TAB_REDUCE = 8;          
37  const int TAB_CLOSEBUTTON = 16;    
38  const int TAB_DBCLK2CLOSE = 32;    
39  const int TAB_VERTICAL = 64;       
40  const int TAB_MULTILINE = 128;     
41  const int TAB_HIDE = 256;          
42  const int TAB_QUITONEMPTY = 512;   
43  const int TAB_ALTICONS = 1024;     
44  const bool activeText = true;
45  const bool activeNumeric = false;
46  enum class EolType: std::uint8_t
47  {
48  	windows,
49  	macos,
50  	unix,
51  	unknown, 
52  	osdefault = windows,
53  };
54  EolType convertIntToFormatType(int value, EolType defvalue = EolType::osdefault);
55  enum UniMode {uni8Bit=0, uniUTF8=1, uni16BE=2, uni16LE=3, uniCookie=4, uni7Bit=5, uni16BE_NoBOM=6, uni16LE_NoBOM=7, uniEnd};
56  enum ChangeDetect { cdDisabled = 0x0, cdEnabledOld = 0x01, cdEnabledNew = 0x02, cdAutoUpdate = 0x04, cdGo2end = 0x08 };
57  enum BackupFeature {bak_none = 0, bak_simple = 1, bak_verbose = 2};
58  enum OpenSaveDirSetting {dir_followCurrent = 0, dir_last = 1, dir_userDef = 2};
59  enum MultiInstSetting {monoInst = 0, multiInstOnSession = 1, multiInst = 2};
60  enum writeTechnologyEngine {defaultTechnology = 0, directWriteTechnology = 1};
61  enum urlMode {urlDisable = 0, urlNoUnderLineFg, urlUnderLineFg, urlNoUnderLineBg, urlUnderLineBg,
62                urlMin = urlDisable,
63                urlMax = urlUnderLineBg};
64  const int LANG_INDEX_INSTR = 0;
65  const int LANG_INDEX_INSTR2 = 1;
66  const int LANG_INDEX_TYPE = 2;
67  const int LANG_INDEX_TYPE2 = 3;
68  const int LANG_INDEX_TYPE3 = 4;
69  const int LANG_INDEX_TYPE4 = 5;
70  const int LANG_INDEX_TYPE5 = 6;
71  const int LANG_INDEX_TYPE6 = 7;
72  const int LANG_INDEX_TYPE7 = 8;
73  const int COPYDATA_PARAMS = 0;
74  const int COPYDATA_FILENAMESW = 2;
75  const int COPYDATA_FULL_CMDLINE = 3;
76  #define PURE_LC_NONE	0
77  #define PURE_LC_BOL	 1
78  #define PURE_LC_WSP	 2
79  #define DECSEP_DOT	  0
80  #define DECSEP_COMMA	1
81  #define DECSEP_BOTH	 2
82  #define DROPBOX_AVAILABLE 1
83  #define ONEDRIVE_AVAILABLE 2
84  #define GOOGLEDRIVE_AVAILABLE 4
85  #define NPP_STYLING_FILESIZE_LIMIT_DEFAULT (200 * 1024 * 1024) 
86  const TCHAR fontSizeStrs[][3] = {TEXT(""), TEXT("5"), TEXT("6"), TEXT("7"), TEXT("8"), TEXT("9"), TEXT("10"), TEXT("11"), TEXT("12"), TEXT("14"), TEXT("16"), TEXT("18"), TEXT("20"), TEXT("22"), TEXT("24"), TEXT("26"), TEXT("28")};
87  const TCHAR localConfFile[] = TEXT("doLocalConf.xml");
88  const TCHAR notepadStyleFile[] = TEXT("asNotepad.xml");
89  const TCHAR nppLogNetworkDriveIssue[] = TEXT("nppLogNetworkDriveIssue");
90  const TCHAR nppLogNulContentCorruptionIssue[] = TEXT("nppLogNulContentCorruptionIssue");
91  void cutString(const TCHAR *str2cut, std::vector<generic_string> & patternVect);
92  void cutStringBy(const TCHAR *str2cut, std::vector<generic_string> & patternVect, char byChar, bool allowEmptyStr);
93  const wchar_t g_npcStyleName[] = L"Non-printing characters custom color";
94  struct Position
95  {
96  	intptr_t _firstVisibleLine = 0;
97  	intptr_t _startPos = 0;
98  	intptr_t _endPos = 0;
99  	intptr_t _xOffset = 0;
100  	intptr_t _selMode = 0;
101  	intptr_t _scrollWidth = 1;
102  	intptr_t _offset = 0;
103  	intptr_t _wrapCount = 0;
104  };
105  struct MapPosition
106  {
107  private:
108  	intptr_t _maxPeekLenInKB = 512; 
109  public:
110  	intptr_t _firstVisibleDisplayLine = -1;
111  	intptr_t _firstVisibleDocLine = -1; 
112  	intptr_t _lastVisibleDocLine = -1;  
113  	intptr_t _nbLine = -1;              
114  	intptr_t _higherPos = -1;           
115  	intptr_t _width = -1;
116  	intptr_t _height = -1;
117  	intptr_t _wrapIndentMode = -1;
118  	intptr_t _KByteInDoc = _maxPeekLenInKB;
119  	bool _isWrap = false;
120  	bool isValid() const { return (_firstVisibleDisplayLine != -1); };
121  	bool canScroll() const { return (_KByteInDoc < _maxPeekLenInKB); }; 
122  };
123  struct sessionFileInfo : public Position
124  {
125  	sessionFileInfo(const TCHAR *fn, const TCHAR *ln, int encoding, bool userReadOnly, const Position& pos, const TCHAR *backupFilePath, FILETIME originalFileLastModifTimestamp, const MapPosition & mapPos) :
126  		Position(pos), _encoding(encoding), _isUserReadOnly(userReadOnly), _originalFileLastModifTimestamp(originalFileLastModifTimestamp), _mapPos(mapPos)
127  	{
128  		if (fn) _fileName = fn;
129  		if (ln)	_langName = ln;
130  		if (backupFilePath) _backupFilePath = backupFilePath;
131  	}
132  	sessionFileInfo(generic_string fn) : _fileName(fn) {}
133  	generic_string _fileName;
134  	generic_string	_langName;
135  	std::vector<size_t> _marks;
136  	std::vector<size_t> _foldStates;
137  	int	_encoding = -1;
138  	bool _isUserReadOnly = false;
139  	bool _isMonitoring = false;
140  	int _individualTabColour = -1;
141  	generic_string _backupFilePath;
142  	FILETIME _originalFileLastModifTimestamp = {};
143  	MapPosition _mapPos;
144  };
145  struct Session
146  {
147  	size_t nbMainFiles() const {return _mainViewFiles.size();};
148  	size_t nbSubFiles() const {return _subViewFiles.size();};
149  	size_t _activeView = 0;
150  	size_t _activeMainIndex = 0;
151  	size_t _activeSubIndex = 0;
152  	bool _includeFileBrowser = false;
153  	generic_string _fileBrowserSelectedItem;
154  	std::vector<sessionFileInfo> _mainViewFiles;
155  	std::vector<sessionFileInfo> _subViewFiles;
156  	std::vector<generic_string> _fileBrowserRoots;
157  };
158  struct CmdLineParams
159  {
160  	bool _isNoPlugin = false;
161  	bool _isReadOnly = false;
162  	bool _isNoSession = false;
163  	bool _isNoTab = false;
164  	bool _isPreLaunch = false;
165  	bool _showLoadingTime = false;
166  	bool _alwaysOnTop = false;
167  	intptr_t _line2go   = -1;
168  	intptr_t _column2go = -1;
169  	intptr_t _pos2go = -1;
170  	POINT _point = {};
171  	bool _isPointXValid = false;
172  	bool _isPointYValid = false;
173  	bool _isSessionFile = false;
174  	bool _isRecursive = false;
175  	bool _openFoldersAsWorkspace = false;
176  	bool _monitorFiles = false;
177  	LangType _langType = L_EXTERNAL;
178  	generic_string _localizationPath;
179  	generic_string _udlName;
180  	generic_string _pluginMessage;
181  	generic_string _easterEggName;
182  	unsigned char _quoteType = 0;
183  	int _ghostTypingSpeed = -1; 
184  	CmdLineParams()
185  	{
186  		_point.x = 0;
187  		_point.y = 0;
188  	}
189  	bool isPointValid() const
190  	{
191  		return _isPointXValid && _isPointYValid;
192  	}
193  };
194  struct CmdLineParamsDTO
195  {
196  	bool _isReadOnly = false;
197  	bool _isNoSession = false;
198  	bool _isSessionFile = false;
199  	bool _isRecursive = false;
200  	bool _openFoldersAsWorkspace = false;
201  	bool _monitorFiles = false;
202  	intptr_t _line2go = 0;
203  	intptr_t _column2go = 0;
204  	intptr_t _pos2go = 0;
205  	LangType _langType = L_EXTERNAL;
206  	wchar_t _udlName[MAX_PATH] = {'\0'};
207  	wchar_t _pluginMessage[MAX_PATH] = {'\0'};
208  	static CmdLineParamsDTO FromCmdLineParams(const CmdLineParams& params)
209  	{
210  		CmdLineParamsDTO dto;
211  		dto._isReadOnly = params._isReadOnly;
212  		dto._isNoSession = params._isNoSession;
213  		dto._isSessionFile = params._isSessionFile;
214  		dto._isRecursive = params._isRecursive;
215  		dto._openFoldersAsWorkspace = params._openFoldersAsWorkspace;
216  		dto._monitorFiles = params._monitorFiles;
217  		dto._line2go = params._line2go;
218  		dto._column2go = params._column2go;
219  		dto._pos2go = params._pos2go;
220  		dto._langType = params._langType;
221  		wcsncpy(dto._udlName, params._udlName.c_str(), MAX_PATH);
222  		wcsncpy(dto._pluginMessage, params._pluginMessage.c_str(), MAX_PATH);
223  		return dto;
224  	}
225  };
226  struct FloatingWindowInfo
227  {
228  	int _cont = 0;
229  	RECT _pos = {};
230  	FloatingWindowInfo(int cont, int x, int y, int w, int h)
231  		: _cont(cont)
232  	{
233  		_pos.left	= x;
234  		_pos.top	= y;
235  		_pos.right	= w;
236  		_pos.bottom = h;
237  	}
238  };
239  struct PluginDlgDockingInfo final
240  {
241  	generic_string _name;
242  	int _internalID = -1;
243  	int _currContainer = -1;
244  	int _prevContainer = -1;
245  	bool _isVisible = false;
246  	PluginDlgDockingInfo(const TCHAR* pluginName, int id, int curr, int prev, bool isVis)
247  		: _name(pluginName), _internalID(id), _currContainer(curr), _prevContainer(prev), _isVisible(isVis)
248  	{}
249  	bool operator == (const PluginDlgDockingInfo& rhs) const
250  	{
251  		return _internalID == rhs._internalID and _name == rhs._name;
252  	}
253  };
254  struct ContainerTabInfo final
255  {
256  	int _cont = 0;
257  	int _activeTab = 0;
258  	ContainerTabInfo(int cont, int activeTab) : _cont(cont), _activeTab(activeTab) {};
259  };
260  struct DockingManagerData final
261  {
262  	int _leftWidth = 200;
263  	int _rightWidth = 200;
264  	int _topHeight = 200;
265  	int _bottomHight = 200;
266  	std::vector<FloatingWindowInfo> _flaotingWindowInfo;
267  	std::vector<PluginDlgDockingInfo> _pluginDockInfo;
268  	std::vector<ContainerTabInfo> _containerTabInfo;
269  	bool getFloatingRCFrom(int floatCont, RECT& rc) const
270  	{
271  		for (size_t i = 0, fwiLen = _flaotingWindowInfo.size(); i < fwiLen; ++i)
272  		{
273  			if (_flaotingWindowInfo[i]._cont == floatCont)
274  			{
275  				rc.left   = _flaotingWindowInfo[i]._pos.left;
276  				rc.top	= _flaotingWindowInfo[i]._pos.top;
277  				rc.right  = _flaotingWindowInfo[i]._pos.right;
278  				rc.bottom = _flaotingWindowInfo[i]._pos.bottom;
279  				return true;
280  			}
281  		}
282  		return false;
283  	}
284  };
285  const int FONTSTYLE_NONE = 0;
286  const int FONTSTYLE_BOLD = 1;
287  const int FONTSTYLE_ITALIC = 2;
288  const int FONTSTYLE_UNDERLINE = 4;
289  const int STYLE_NOT_USED = -1;
290  const int COLORSTYLE_FOREGROUND = 0x01;
291  const int COLORSTYLE_BACKGROUND = 0x02;
292  const int COLORSTYLE_ALL = COLORSTYLE_FOREGROUND|COLORSTYLE_BACKGROUND;
293  struct Style final
294  {
295  	int _styleID = STYLE_NOT_USED;
296  	generic_string _styleDesc;
297  	COLORREF _fgColor = COLORREF(STYLE_NOT_USED);
298  	COLORREF _bgColor = COLORREF(STYLE_NOT_USED);
299  	int _colorStyle = COLORSTYLE_ALL;
300  	bool _isFontEnabled = false;
301  	generic_string _fontName;
302  	int _fontStyle = STYLE_NOT_USED;
303  	int _fontSize = STYLE_NOT_USED;
304  	int _nesting = FONTSTYLE_NONE;
305  	int _keywordClass = STYLE_NOT_USED;
306  	generic_string _keywords;
307  };
308  struct GlobalOverride final
309  {
310  	bool isEnable() const {return (enableFg || enableBg || enableFont || enableFontSize || enableBold || enableItalic || enableUnderLine);}
311  	bool enableFg = false;
312  	bool enableBg = false;
313  	bool enableFont = false;
314  	bool enableFontSize = false;
315  	bool enableBold = false;
316  	bool enableItalic = false;
317  	bool enableUnderLine = false;
318  };
319  struct StyleArray
320  {
321  	auto begin() { return _styleVect.begin(); };
322  	auto end() { return _styleVect.end(); };
323  	void clear() { _styleVect.clear(); };
324  	Style& getStyler(size_t index) {
325  		assert(index < _styleVect.size());
326  		return _styleVect[index];
327  	};
328  	void addStyler(int styleID, TiXmlNode *styleNode);
329  	void addStyler(int styleID, const generic_string& styleName) {
330  		_styleVect.emplace_back();
331  		Style& s = _styleVect.back();
332  		s._styleID = styleID;
333  		s._styleDesc = styleName;
334  		s._fgColor = black;
335  		s._bgColor = white;
336  	};
337  	Style* findByID(int id) {
338  		for (size_t i = 0; i < _styleVect.size(); ++i)
339  		{
340  			if (_styleVect[i]._styleID == id)
341  				return &(_styleVect[i]);
342  		}
343  		return nullptr;
344  	};
345  	Style* findByName(const generic_string& name) {
346  		for (size_t i = 0; i < _styleVect.size(); ++i)
347  		{
348  			if (_styleVect[i]._styleDesc == name)
349  				return &(_styleVect[i]);
350  		}
351  		return nullptr;
352  	};
353  protected:
354  	std::vector<Style> _styleVect;
355  };
356  struct LexerStyler : public StyleArray
357  {
358  public:
359  	LexerStyler & operator=(const LexerStyler & ls)
360  	{
361  		if (this != &ls)
362  		{
363  			*(static_cast<StyleArray *>(this)) = ls;
364  			this->_lexerName = ls._lexerName;
365  			this->_lexerDesc = ls._lexerDesc;
366  			this->_lexerUserExt = ls._lexerUserExt;
367  		}
368  		return *this;
369  	}
370  	void setLexerName(const TCHAR *lexerName)
371  	{
372  		_lexerName = lexerName;
373  	}
374  	void setLexerDesc(const TCHAR *lexerDesc)
375  	{
376  		_lexerDesc = lexerDesc;
377  	}
378  	void setLexerUserExt(const TCHAR *lexerUserExt) {
379  		_lexerUserExt = lexerUserExt;
380  	};
<span onclick='openModal()' class='match'>381  	const TCHAR * getLexerName() const {return _lexerName.c_str();};
382  	const TCHAR * getLexerDesc() const {return _lexerDesc.c_str();};
</span>383  	const TCHAR * getLexerUserExt() const {return _lexerUserExt.c_str();};
384  private :
385  	generic_string _lexerName;
386  	generic_string _lexerDesc;
387  	generic_string _lexerUserExt;
388  };
389  struct SortLexersInAlphabeticalOrder {
390  	bool operator() (LexerStyler& l, LexerStyler& r) {
391  		if (!lstrcmp(l.getLexerDesc(), TEXT("Search result")))
392  			return false;
393  		if (!lstrcmp(r.getLexerDesc(), TEXT("Search result")))
394  			return true;
395  		return lstrcmp(l.getLexerDesc(), r.getLexerDesc()) < 0;
396  	}
397  };
398  struct LexerStylerArray
399  {
400  	size_t getNbLexer() const { return _lexerStylerVect.size(); }
401  	void clear() { _lexerStylerVect.clear(); }
402  	LexerStyler & getLexerFromIndex(size_t index)
403  	{
404  		assert(index < _lexerStylerVect.size());
405  		return _lexerStylerVect[index];
406  	};
407  	const TCHAR * getLexerNameFromIndex(size_t index) const { return _lexerStylerVect[index].getLexerName(); }
408  	const TCHAR * getLexerDescFromIndex(size_t index) const { return _lexerStylerVect[index].getLexerDesc(); }
409  	LexerStyler * getLexerStylerByName(const TCHAR *lexerName) {
410  		if (!lexerName) return nullptr;
411  		for (size_t i = 0 ; i < _lexerStylerVect.size() ; ++i)
412  		{
413  			if (!lstrcmp(_lexerStylerVect[i].getLexerName(), lexerName))
414  				return &(_lexerStylerVect[i]);
415  		}
416  		return nullptr;
417  	};
418  	void addLexerStyler(const TCHAR *lexerName, const TCHAR *lexerDesc, const TCHAR *lexerUserExt, TiXmlNode *lexerNode);
419  	void sort() {
420  		std::sort(_lexerStylerVect.begin(), _lexerStylerVect.end(), SortLexersInAlphabeticalOrder());
421  	};
422  private :
423  	std::vector<LexerStyler> _lexerStylerVect;
424  };
425  struct NewDocDefaultSettings final
426  {
427  	EolType _format = EolType::osdefault;
428  	UniMode _unicodeMode = uniCookie;
429  	bool _openAnsiAsUtf8 = true;
430  	LangType _lang = L_TEXT;
431  	int _codepage = -1; 
432  };
433  struct LangMenuItem final
434  {
435  	LangType _langType = L_TEXT;
436  	int	_cmdID = -1;
437  	generic_string _langName;
438  	LangMenuItem(LangType lt, int cmdID = 0, const generic_string& langName = TEXT("")):
439  	_langType(lt), _cmdID(cmdID), _langName(langName){};
440  };
441  struct PrintSettings final {
442  	bool _printLineNumber = true;
443  	int _printOption = SC_PRINT_COLOURONWHITE;
444  	generic_string _headerLeft;
445  	generic_string _headerMiddle;
446  	generic_string _headerRight;
447  	generic_string _headerFontName;
448  	int _headerFontStyle = 0;
449  	int _headerFontSize = 0;
450  	generic_string _footerLeft;
451  	generic_string _footerMiddle;
452  	generic_string _footerRight;
453  	generic_string _footerFontName;
454  	int _footerFontStyle = 0;
455  	int _footerFontSize = 0;
456  	RECT _marge = {};
457  	PrintSettings() {
458  		_marge.left = 0; _marge.top = 0; _marge.right = 0; _marge.bottom = 0;
459  	};
460  	bool isHeaderPresent() const {
461  		return ((_headerLeft != TEXT("")) || (_headerMiddle != TEXT("")) || (_headerRight != TEXT("")));
462  	};
463  	bool isFooterPresent() const {
464  		return ((_footerLeft != TEXT("")) || (_footerMiddle != TEXT("")) || (_footerRight != TEXT("")));
465  	};
466  	bool isUserMargePresent() const {
467  		return ((_marge.left != 0) || (_marge.top != 0) || (_marge.right != 0) || (_marge.bottom != 0));
468  	};
469  };
470  class Date final
471  {
472  public:
473  	Date() = default;
474  	Date(unsigned long year, unsigned long month, unsigned long day)
475  		: _year(year)
476  		, _month(month)
477  		, _day(day)
478  	{
479  		assert(year > 0 && year <= 9999); 
480  		assert(month > 0 && month <= 12);
481  		assert(day > 0 && day <= 31);
482  		assert(!(month == 2 && day > 29) &&
483  			   !(month == 4 && day > 30) &&
484  			   !(month == 6 && day > 30) &&
485  			   !(month == 9 && day > 30) &&
486  			   !(month == 11 && day > 30));
487  	}
488  	explicit Date(const TCHAR *dateStr);
489  	Date(int nbDaysFromNow);
490  	void now();
491  	generic_string toString() const 
492  	{
493  		TCHAR dateStr[16];
494  		wsprintf(dateStr, TEXT("%04u%02u%02u"), _year, _month, _day);
495  		return dateStr;
496  	}
497  	bool operator < (const Date & compare) const
498  	{
499  		if (this->_year != compare._year)
500  			return (this->_year < compare._year);
501  		if (this->_month != compare._month)
502  			return (this->_month < compare._month);
503  		return (this->_day < compare._day);
504  	}
505  	bool operator > (const Date & compare) const
506  	{
507  		if (this->_year != compare._year)
508  			return (this->_year > compare._year);
509  		if (this->_month != compare._month)
510  			return (this->_month > compare._month);
511  		return (this->_day > compare._day);
512  	}
513  	bool operator == (const Date & compare) const
514  	{
515  		if (this->_year != compare._year)
516  			return false;
517  		if (this->_month != compare._month)
518  			return false;
519  		return (this->_day == compare._day);
520  	}
521  	bool operator != (const Date & compare) const
522  	{
523  		if (this->_year != compare._year)
524  			return true;
525  		if (this->_month != compare._month)
526  			return true;
527  		return (this->_day != compare._day);
528  	}
529  private:
530  	unsigned long _year  = 2008;
531  	unsigned long _month = 4;
532  	unsigned long _day   = 26;
533  };
534  class MatchedPairConf final
535  {
536  public:
537  	bool hasUserDefinedPairs() const { return _matchedPairs.size() != 0; }
538  	bool hasDefaultPairs() const { return _doParentheses||_doBrackets||_doCurlyBrackets||_doQuotes||_doDoubleQuotes||_doHtmlXmlTag; }
539  	bool hasAnyPairsPair() const { return hasUserDefinedPairs() || hasDefaultPairs(); }
540  public:
541  	std::vector<std::pair<char, char>> _matchedPairs;
542  	std::vector<std::pair<char, char>> _matchedPairsInit; 
543  	bool _doHtmlXmlTag = false;
544  	bool _doParentheses = false;
545  	bool _doBrackets = false;
546  	bool _doCurlyBrackets = false;
547  	bool _doQuotes = false;
548  	bool _doDoubleQuotes = false;
549  };
550  struct DarkModeConf final
551  {
552  	bool _isEnabled = false;
553  	bool _isEnabledPlugin = true;
554  	NppDarkMode::ColorTone _colorTone = NppDarkMode::blackTone;
555  	NppDarkMode::Colors _customColors = NppDarkMode::getDarkModeDefaultColors();
556  	NppDarkMode::AdvancedOptions _advOptions{};
557  };
558  struct LargeFileRestriction final
559  {
560  	int64_t _largeFileSizeDefInByte = NPP_STYLING_FILESIZE_LIMIT_DEFAULT;
561  	bool _isEnabled = true;
562  	bool _deactivateWordWrap = true;
563  	bool _allowBraceMatch = false;
564  	bool _allowAutoCompletion = false;
565  	bool _allowSmartHilite = false;
566  	bool _allowClickableLink = false;
567  };
568  struct NppGUI final
569  {
570  	NppGUI()
571  	{
572  		_appPos.left = 0;
573  		_appPos.top = 0;
574  		_appPos.right = 1100;
575  		_appPos.bottom = 700;
576  		_findWindowPos.left = 0;
577  		_findWindowPos.top = 0;
578  		_findWindowPos.right = 0;
579  		_findWindowPos.bottom = 0;
580  		_defaultDir[0] = 0;
581  		_defaultDirExp[0] = 0;
582  	}
583  	toolBarStatusType _toolBarStatus = TB_STANDARD;
584  	bool _toolbarShow = true;
585  	bool _statusBarShow = true;
586  	bool _menuBarShow = true;
587  	int _tabStatus = (TAB_DRAWTOPBAR | TAB_DRAWINACTIVETAB | TAB_DRAGNDROP | TAB_REDUCE | TAB_CLOSEBUTTON);
588  	bool _splitterPos = POS_VERTICAL;
589  	int _userDefineDlgStatus = UDD_DOCKED;
590  	int _tabSize = 4;
591  	bool _tabReplacedBySpace = false;
592  	bool _finderLinesAreCurrentlyWrapped = false;
593  	bool _finderPurgeBeforeEverySearch = false;
594  	bool _finderShowOnlyOneEntryPerFoundLine = true;
595  	int _fileAutoDetection = cdEnabledNew;
596  	bool _checkHistoryFiles = false;
597  	RECT _appPos = {};
598  	RECT _findWindowPos = {};
599  	bool _findWindowLessMode = false;
600  	bool _isMaximized = false;
601  	bool _isMinimizedToTray = false;
602  	bool _rememberLastSession = true; 
603  	bool _isCmdlineNosessionActivated = false; 
604  	bool _detectEncoding = true;
605  	bool _saveAllConfirm = true;
606  	bool _setSaveDlgExtFiltToAllTypes = false;
607  	bool _doTaskList = true;
608  	bool _maitainIndent = true;
609  	bool _enableSmartHilite = true;
610  	bool _smartHiliteCaseSensitive = false;
611  	bool _smartHiliteWordOnly = true;
612  	bool _smartHiliteUseFindSettings = false;
613  	bool _smartHiliteOnAnotherView = false;
614  	bool _markAllCaseSensitive = false;
615  	bool _markAllWordOnly = true;
616  	bool _disableSmartHiliteTmp = false;
617  	bool _enableTagsMatchHilite = true;
618  	bool _enableTagAttrsHilite = true;
619  	bool _enableHiliteNonHTMLZone = false;
620  	bool _styleMRU = true;
621  	char _leftmostDelimiter = '(';
622  	char _rightmostDelimiter = ')';
623  	bool _delimiterSelectionOnEntireDocument = false;
624  	bool _backSlashIsEscapeCharacterForSql = true;
625  	bool _fillFindFieldWithSelected = true;
626  	bool _fillFindFieldSelectCaret = true;
627  	bool _monospacedFontFindDlg = false;
628  	bool _findDlgAlwaysVisible = false;
629  	bool _confirmReplaceInAllOpenDocs = true;
630  	bool _replaceStopsWithoutFindingNext = false;
631  	bool _muteSounds = false;
632  	bool _enableFoldCmdToggable = false;
633  	bool _hideMenuRightShortcuts = false;
634  	writeTechnologyEngine _writeTechnologyEngine = defaultTechnology;
635  	bool _isWordCharDefault = true;
636  	std::string _customWordChars;
637  	urlMode _styleURL = urlUnderLineFg;
638  	generic_string _uriSchemes = TEXT("svn:&bsol;&bsol; cvs:&bsol;&bsol; git:&bsol;&bsol; imap:&bsol;&bsol; irc:&bsol;&bsol; irc6:&bsol;&bsol; ircs:&bsol;&bsol; ldap:&bsol;&bsol; ldaps:&bsol;&bsol; news: telnet:&bsol;&bsol; gopher:&bsol;&bsol; ssh:&bsol;&bsol; sftp:&bsol;&bsol; smb:&bsol;&bsol; skype: snmp:&bsol;&bsol; spotify: steam:&bsol;&bsol; sms: slack:&bsol;&bsol; chrome:&bsol;&bsol; bitcoin:");
639  	NewDocDefaultSettings _newDocDefaultSettings;
640  	generic_string _dateTimeFormat = TEXT("yyyy-MM-dd HH:mm:ss");
641  	bool _dateTimeReverseDefaultOrder = false;
642  	void setTabReplacedBySpace(bool b) {_tabReplacedBySpace = b;};
643  	const NewDocDefaultSettings & getNewDocDefaultSettings() const {return _newDocDefaultSettings;};
644  	std::vector<LangMenuItem> _excludedLangList;
645  	bool _isLangMenuCompact = true;
646  	PrintSettings _printSettings;
647  	BackupFeature _backup = bak_none;
648  	bool _useDir = false;
649  	generic_string _backupDir;
650  	DockingManagerData _dockingData;
651  	GlobalOverride _globalOverride;
652  	enum AutocStatus{autoc_none, autoc_func, autoc_word, autoc_both};
653  	AutocStatus _autocStatus = autoc_both;
654  	UINT  _autocFromLen = 1;
655  	bool _autocIgnoreNumbers = true;
656  	bool _autocInsertSelectedUseENTER = true;
657  	bool _autocInsertSelectedUseTAB = true;
658  	bool _autocBrief = false;
659  	bool _funcParams = true;
660  	MatchedPairConf _matchedPairConf;
661  	generic_string _definedSessionExt;
662  	generic_string _definedWorkspaceExt;
663  	generic_string _commandLineInterpreter = CMD_INTERPRETER;
664  	struct AutoUpdateOptions
665  	{
666  		bool _doAutoUpdate = true;
667  		int _intervalDays = 15;
668  		Date _nextUpdateDate;
669  		AutoUpdateOptions(): _nextUpdateDate(Date()) {};
670  	}
671  	_autoUpdateOpt;
672  	bool _doesExistUpdater = false;
673  	int _caretBlinkRate = 600;
674  	int _caretWidth = 1;
675  	bool _enableMultiSelection = false;
676  	bool _shortTitlebar = false;
677  	OpenSaveDirSetting _openSaveDir = dir_followCurrent;
678  	TCHAR _defaultDir[MAX_PATH];
679  	TCHAR _defaultDirExp[MAX_PATH];	
680  	generic_string _themeName;
681  	MultiInstSetting _multiInstSetting = monoInst;
682  	bool _clipboardHistoryPanelKeepState = false;
683  	bool _docListKeepState = false;
684  	bool _charPanelKeepState = false;
685  	bool _fileBrowserKeepState = false;
686  	bool _projectPanelKeepState = false;
687  	bool _docMapKeepState = false;
688  	bool _funcListKeepState = false;
689  	bool _pluginPanelKeepState = false;
690  	bool _fileSwitcherWithoutExtColumn = false;
691  	int _fileSwitcherExtWidth = 50;
692  	bool _fileSwitcherWithoutPathColumn = true;
693  	int _fileSwitcherPathWidth = 50;
694  	bool _fileSwitcherDisableListViewGroups = false;
695  	bool isSnapshotMode() const {return _isSnapshotMode && _rememberLastSession && !_isCmdlineNosessionActivated;};
696  	bool _isSnapshotMode = true;
697  	size_t _snapshotBackupTiming = 7000;
698  	generic_string _cloudPath; 
699  	unsigned char _availableClouds = '\0'; 
700  	enum SearchEngineChoice{ se_custom = 0, se_duckDuckGo = 1, se_google = 2, se_bing = 3, se_yahoo = 4, se_stackoverflow = 5 };
701  	SearchEngineChoice _searchEngineChoice = se_google;
702  	generic_string _searchEngineCustom;
703  	bool _isFolderDroppedOpenFiles = false;
704  	bool _isDocPeekOnTab = false;
705  	bool _isDocPeekOnMap = false;
706  	bool _shouldSortFunctionList = false;
707  	DarkModeConf _darkmode;
708  	LargeFileRestriction _largeFileRestriction;
709  };
710  struct ScintillaViewParams
711  {
712  	bool _lineNumberMarginShow = true;
713  	bool _lineNumberMarginDynamicWidth = true;
714  	bool _bookMarkMarginShow = true;
715  	bool _isChangeHistoryEnabled = true;
716  	bool _isChangeHistoryEnabled4NextSession = true;
717  	folderStyle  _folderStyle = FOLDER_STYLE_BOX; 
718  	lineWrapMethod _lineWrapMethod = LINEWRAP_ALIGNED;
719  	bool _foldMarginShow = true;
720  	bool _indentGuideLineShow = true;
721  	lineHiliteMode _currentLineHiliteMode = LINEHILITE_HILITE;
722  	unsigned char _currentLineFrameWidth = 1; 
723  	bool _wrapSymbolShow = false;
724  	bool _doWrap = false;
725  	bool _isEdgeBgMode = false;
726  	std::vector<size_t> _edgeMultiColumnPos;
727  	intptr_t _zoom = 0;
728  	intptr_t _zoom2 = 0;
729  	bool _whiteSpaceShow = false;
730  	bool _eolShow = false;
731  	enum crlfMode {plainText = 0, roundedRectangleText = 1, plainTextCustomColor = 2, roundedRectangleTextCustomColor = 3};
732  	crlfMode _eolMode = roundedRectangleText;
733  	bool _npcShow = false;
734  	enum npcMode { identity = 0, abbreviation = 1, codepoint = 2 };
735  	npcMode _npcMode = abbreviation;
736  	bool _npcCustomColor = false;
737  	bool _npcIncludeCcUniEol = false;
738  	bool _ccUniEolShow = true;
739  	int _borderWidth = 2;
740  	bool _virtualSpace = false;
741  	bool _scrollBeyondLastLine = true;
742  	bool _rightClickKeepsSelection = false;
743  	bool _disableAdvancedScrolling = false;
744  	bool _doSmoothFont = false;
745  	bool _showBorderEdge = true;
746  	unsigned char _paddingLeft = 0;  
747  	unsigned char _paddingRight = 0; 
748  	unsigned char _distractionFreeDivPart = 4;     
749  	int getDistractionFreePadding(int editViewWidth) const {
750  		const int defaultDiviser = 4;
751  		int diviser = _distractionFreeDivPart > 2 ? _distractionFreeDivPart : defaultDiviser;
752  		int paddingLen = editViewWidth / diviser;
753  		if (paddingLen <= 0)
754  			paddingLen = editViewWidth / defaultDiviser;
755  		return paddingLen;
756  	};
757  };
758  const int NB_LIST = 20;
759  const int NB_MAX_LRF_FILE = 30;
760  const int NB_MAX_USER_LANG = 30;
761  const int NB_MAX_EXTERNAL_LANG = 30;
762  const int NB_MAX_IMPORTED_UDL = 50;
763  constexpr int NB_DEFAULT_LRF_CUSTOMLENGTH = 100;
764  constexpr int NB_MAX_LRF_CUSTOMLENGTH = MAX_PATH - 1;
765  const int NB_MAX_FINDHISTORY_FIND	= 30;
766  const int NB_MAX_FINDHISTORY_REPLACE = 30;
767  const int NB_MAX_FINDHISTORY_PATH	= 30;
768  const int NB_MAX_FINDHISTORY_FILTER  = 20;
769  const int MASK_ReplaceBySpc = 0x80;
770  const int MASK_TabSize = 0x7F;
771  struct Lang final
772  {
773  	LangType _langID = L_TEXT;
774  	generic_string _langName;
775  	const TCHAR* _defaultExtList = nullptr;
776  	const TCHAR* _langKeyWordList[NB_LIST];
777  	const TCHAR* _pCommentLineSymbol = nullptr;
778  	const TCHAR* _pCommentStart = nullptr;
779  	const TCHAR* _pCommentEnd = nullptr;
780  	bool _isTabReplacedBySpace = false;
781  	int _tabSize = -1;
782  	Lang()
783  	{
784  		for (int i = 0 ; i < NB_LIST ; _langKeyWordList[i] = NULL, ++i);
785  	}
786  	Lang(LangType langID, const TCHAR *name) : _langID(langID), _langName(name ? name : TEXT(""))
787  	{
788  		for (int i = 0 ; i < NB_LIST ; _langKeyWordList[i] = NULL, ++i);
789  	}
790  	~Lang() = default;
791  	void setDefaultExtList(const TCHAR *extLst){
792  		_defaultExtList = extLst;
793  	}
794  	void setCommentLineSymbol(const TCHAR *commentLine){
795  		_pCommentLineSymbol = commentLine;
796  	}
797  	void setCommentStart(const TCHAR *commentStart){
798  		_pCommentStart = commentStart;
799  	}
800  	void setCommentEnd(const TCHAR *commentEnd){
801  		_pCommentEnd = commentEnd;
802  	}
803  	void setTabInfo(int tabInfo)
804  	{
805  		if (tabInfo != -1 && tabInfo & MASK_TabSize)
806  		{
807  			_isTabReplacedBySpace = (tabInfo & MASK_ReplaceBySpc) != 0;
808  			_tabSize = tabInfo & MASK_TabSize;
809  		}
810  	}
811  	const TCHAR * getDefaultExtList() const {
812  		return _defaultExtList;
813  	}
814  	void setWords(const TCHAR *words, int index) {
815  		_langKeyWordList[index] = words;
816  	}
817  	const TCHAR * getWords(int index) const {
818  		return _langKeyWordList[index];
819  	}
820  	LangType getLangID() const {return _langID;};
821  	const TCHAR * getLangName() const {return _langName.c_str();};
822  	int getTabInfo() const
823  	{
824  		if (_tabSize == -1) return -1;
825  		return (_isTabReplacedBySpace?0x80:0x00) | _tabSize;
826  	}
827  };
828  class UserLangContainer final
829  {
830  public:
831  	UserLangContainer() :_name(TEXT("new user define")), _ext(TEXT("")), _udlVersion(TEXT("")) {
832  		for (int i = 0; i < SCE_USER_KWLIST_TOTAL; ++i) *_keywordLists[i] = '\0';
833  	}
834  	UserLangContainer(const TCHAR *name, const TCHAR *ext, bool isDarkModeTheme, const TCHAR *udlVer):
835  		_name(name), _ext(ext), _isDarkModeTheme(isDarkModeTheme), _udlVersion(udlVer) {
836  		for (int i = 0; i < SCE_USER_KWLIST_TOTAL; ++i) *_keywordLists[i] = '\0';
837  	}
838  	UserLangContainer & operator = (const UserLangContainer & ulc)
839  	{
840  		if (this != &ulc)
841  		{
842  			this->_name = ulc._name;
843  			this->_ext = ulc._ext;
844  			this->_isDarkModeTheme = ulc._isDarkModeTheme;
845  			this->_udlVersion = ulc._udlVersion;
846  			this->_isCaseIgnored = ulc._isCaseIgnored;
847  			this->_styles = ulc._styles;
848  			this->_allowFoldOfComments = ulc._allowFoldOfComments;
849  			this->_forcePureLC = ulc._forcePureLC;
850  			this->_decimalSeparator = ulc._decimalSeparator;
851  			this->_foldCompact = ulc._foldCompact;
852  			for (Style & st : this->_styles)
853  			{
854  				if (st._bgColor == COLORREF(-1))
855  					st._bgColor = white;
856  				if (st._fgColor == COLORREF(-1))
857  					st._fgColor = black;
858  			}
859  			for (int i = 0 ; i < SCE_USER_KWLIST_TOTAL ; ++i)
860  				wcscpy_s(this->_keywordLists[i], ulc._keywordLists[i]);
861  			for (int i = 0 ; i < SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
862  				_isPrefix[i] = ulc._isPrefix[i];
863  		}
864  		return *this;
865  	}
866  	const TCHAR * getName() {return _name.c_str();};
867  	const TCHAR * getExtention() {return _ext.c_str();};
868  	const TCHAR * getUdlVersion() {return _udlVersion.c_str();};
869  private:
870  	StyleArray _styles;
871  	generic_string _name;
872  	generic_string _ext;
873  	bool _isDarkModeTheme = false;
874  	generic_string _udlVersion;
875  	TCHAR _keywordLists[SCE_USER_KWLIST_TOTAL][max_char];
876  	bool _isPrefix[SCE_USER_TOTAL_KEYWORD_GROUPS] = {false};
877  	bool _isCaseIgnored = false;
878  	bool _allowFoldOfComments = false;
879  	int  _forcePureLC = PURE_LC_NONE;
880  	int _decimalSeparator = DECSEP_DOT;
881  	bool _foldCompact = false;
882  	friend class Notepad_plus;
883  	friend class ScintillaEditView;
884  	friend class NppParameters;
885  	friend class SharedParametersDialog;
886  	friend class FolderStyleDialog;
887  	friend class KeyWordsStyleDialog;
888  	friend class CommentStyleDialog;
889  	friend class SymbolsStyleDialog;
890  	friend class UserDefineDialog;
891  	friend class StylerDlg;
892  };
893  #define MAX_EXTERNAL_LEXER_NAME_LEN 128
894  class ExternalLangContainer final
895  {
896  public:
897  	std::string _name;
898  	Lexilla::CreateLexerFn fnCL = nullptr;
899  	ExternalLexerAutoIndentMode _autoIndentMode = ExternalLexerAutoIndentMode::Standard;
900  };
901  struct FindHistory final
902  {
903  	enum searchMode{normal, extended, regExpr};
904  	enum transparencyMode{none, onLossingFocus, persistant};
905  	bool _isSearch2ButtonsMode = false;
906  	int _nbMaxFindHistoryPath    = 10;
907  	int _nbMaxFindHistoryFilter  = 10;
908  	int _nbMaxFindHistoryFind    = 10;
909  	int _nbMaxFindHistoryReplace = 10;
910  	std::vector<generic_string> _findHistoryPaths;
911  	std::vector<generic_string> _findHistoryFilters;
912  	std::vector<generic_string> _findHistoryFinds;
913  	std::vector<generic_string> _findHistoryReplaces;
914  	bool _isMatchWord = false;
915  	bool _isMatchCase = false;
916  	bool _isWrap = true;
917  	bool _isDirectionDown = true;
918  	bool _dotMatchesNewline = false;
919  	bool _isFifRecuisive = true;
920  	bool _isFifInHiddenFolder = false;
921      bool _isFifProjectPanel_1 = false;
922      bool _isFifProjectPanel_2 = false;
923      bool _isFifProjectPanel_3 = false;
924  	searchMode _searchMode = normal;
925  	transparencyMode _transparencyMode = onLossingFocus;
926  	int _transparency = 150;
927  	bool _isFilterFollowDoc = false;
928  	bool _isFolderFollowDoc = false;
929  	bool _isBookmarkLine = false;
930  	bool _isPurge = false;
931  	bool _regexBackward4PowerUser = false;
932  };
933  struct ColumnEditorParam final
934  {
935  	enum leadingChoice : UCHAR { noneLeading, zeroLeading, spaceLeading };
936  	bool _mainChoice = activeNumeric;
937  	std::wstring _insertedTextContent;
938  	int _initialNum = -1;
939  	int _increaseNum = -1;
940  	int _repeatNum = -1;
941  	int _formatChoice = 0; 
942  	leadingChoice _leadingChoice = noneLeading;
943  };
944  class LocalizationSwitcher final
945  {
946  friend class NppParameters;
947  public:
948  	struct LocalizationDefinition
949  	{
950  		const wchar_t *_langName = nullptr;
951  		const wchar_t *_xmlFileName = nullptr;
952  	};
953  	bool addLanguageFromXml(const std::wstring& xmlFullPath);
954  	std::wstring getLangFromXmlFileName(const wchar_t *fn) const;
955  	std::wstring getXmlFilePathFromLangName(const wchar_t *langName) const;
956  	bool switchToLang(const wchar_t *lang2switch) const;
957  	size_t size() const
958  	{
959  		return _localizationList.size();
960  	}
961  	std::pair<std::wstring, std::wstring> getElementFromIndex(size_t index) const
962  	{
963  		if (index >= _localizationList.size())
964  			return std::pair<std::wstring, std::wstring>(std::wstring(), std::wstring());
965  		return _localizationList[index];
966  	}
967  	void setFileName(const char *fn)
968  	{
969  		if (fn)
970  			_fileName = fn;
971  	}
972  	std::string getFileName() const
973  	{
974  		return _fileName;
975  	}
976  private:
977  	std::vector< std::pair< std::wstring, std::wstring > > _localizationList;
978  	std::wstring _nativeLangPath;
979  	std::string _fileName;
980  };
981  class ThemeSwitcher final
982  {
983  friend class NppParameters;
984  public:
985  	void addThemeFromXml(const generic_string& xmlFullPath) {
986  		_themeList.push_back(std::pair<generic_string, generic_string>(getThemeFromXmlFileName(xmlFullPath.c_str()), xmlFullPath));
987  	}
988  	void addDefaultThemeFromXml(const generic_string& xmlFullPath) {
989  		_themeList.push_back(std::pair<generic_string, generic_string>(_defaultThemeLabel, xmlFullPath));
990  	}
991  	generic_string getThemeFromXmlFileName(const TCHAR *fn) const;
992  	generic_string getXmlFilePathFromThemeName(const TCHAR *themeName) const {
993  		if (!themeName || themeName[0])
994  			return generic_string();
995  		generic_string themePath = _stylesXmlPath;
996  		return themePath;
997  	}
998  	bool themeNameExists(const TCHAR *themeName) {
999  		for (size_t i = 0; i < _themeList.size(); ++i )
1000  		{
1001  			auto& themeNameOnList = getElementFromIndex(i).first;
1002  			if (lstrcmp(themeName, themeNameOnList.c_str()) == 0)
1003  				return true;
1004  		}
1005  		return false;
1006  	}
1007  	size_t size() const { return _themeList.size(); }
1008  	std::pair<generic_string, generic_string> & getElementFromIndex(size_t index)
1009  	{
1010  		assert(index < _themeList.size());
1011  		return _themeList[index];
1012  	}
1013  	void setThemeDirPath(generic_string themeDirPath) { _themeDirPath = themeDirPath; }
1014  	generic_string getThemeDirPath() const { return _themeDirPath; }
1015  	generic_string getDefaultThemeLabel() const { return _defaultThemeLabel; }
1016  	generic_string getSavePathFrom(const generic_string& path) const {
1017  		const auto iter = _themeStylerSavePath.find(path);
1018  		if (iter == _themeStylerSavePath.end())
1019  		{
1020  			return TEXT("");
1021  		}
1022  		else
1023  		{
1024  			return iter->second;
1025  		}
1026  	};
1027  	void addThemeStylerSavePath(generic_string key, generic_string val) {
1028  		_themeStylerSavePath[key] = val;
1029  	};
1030  private:
1031  	std::vector<std::pair<generic_string, generic_string>> _themeList;
1032  	std::map<generic_string, generic_string> _themeStylerSavePath;
1033  	generic_string _themeDirPath;
1034  	const generic_string _defaultThemeLabel = TEXT("Default (stylers.xml)");
1035  	generic_string _stylesXmlPath;
1036  };
1037  struct UdlXmlFileState final {
1038  	TiXmlDocument* _udlXmlDoc = nullptr;
1039  	bool _isDirty = false;
1040  	bool _isInDefaultSharedContainer = false; 
1041  	std::pair<unsigned char, unsigned char> _indexRange;
1042  	UdlXmlFileState(TiXmlDocument* doc, bool isDirty, bool isInDefaultSharedContainer, std::pair<unsigned char, unsigned char> range)
1043  		: _udlXmlDoc(doc), _isDirty(isDirty), _isInDefaultSharedContainer(isInDefaultSharedContainer), _indexRange(range) {};
1044  };
1045  const int NB_LANG = 100;
1046  const int RECENTFILES_SHOWFULLPATH = -1;
1047  const int RECENTFILES_SHOWONLYFILENAME = 0;
1048  class DynamicMenu final
1049  {
1050  public:
1051  	bool attach(HMENU hMenu, unsigned int posBase, int lastCmd, const generic_string& lastCmdLabel);
1052  	bool createMenu() const;
1053  	bool clearMenu() const;
1054  	int getTopLevelItemNumber() const;
1055  	void push_back(const MenuItemUnit& m) {
1056  		_menuItems.push_back(m);
1057  	};
1058  	MenuItemUnit& getItemFromIndex(size_t i) {
1059  		return _menuItems[i];
1060  	};
1061  	void erase(size_t i) {
1062  		_menuItems.erase(_menuItems.begin() + i);
1063  	}
1064  	unsigned int getPosBase() const { return _posBase; };
1065  	generic_string getLastCmdLabel() const { return _lastCmdLabel; };
1066  private:
1067  	std::vector<MenuItemUnit> _menuItems;
1068  	HMENU _hMenu = nullptr;
1069  	unsigned int _posBase = 0;
1070  	int _lastCmd = 0;
1071  	generic_string _lastCmdLabel;
1072  };
1073  class NppParameters final
1074  {
1075  private:
1076  	static NppParameters* getInstancePointer() {
1077  		static NppParameters* instance = new NppParameters;
1078  		return instance;
1079  	};
1080  public:
1081  	static NppParameters& getInstance() {
1082  		return *getInstancePointer();
1083  	};
1084  	static LangType getLangIDFromStr(const TCHAR *langName);
1085  	static generic_string getLocPathFromStr(const generic_string & localizationCode);
1086  	bool load();
1087  	bool reloadLang();
1088  	bool reloadStylers(const TCHAR *stylePath = nullptr);
1089  	void destroyInstance();
1090  	generic_string getSettingsFolder();
1091  	bool _isTaskListRBUTTONUP_Active = false;
1092  	int L_END;
1093  	NppGUI & getNppGUI() {
1094  		return _nppGUI;
1095  	}
1096  	const TCHAR * getWordList(LangType langID, int typeIndex) const
1097  	{
1098  		Lang *pLang = getLangFromID(langID);
1099  		if (!pLang) return nullptr;
1100  		return pLang->getWords(typeIndex);
1101  	}
1102  	Lang * getLangFromID(LangType langID) const
1103  	{
1104  		for (int i = 0 ; i < _nbLang ; ++i)
1105  		{
1106  			if ( _langList[i] && _langList[i]->_langID == langID )
1107  				return _langList[i];
1108  		}
1109  		return nullptr;
1110  	}
1111  	Lang * getLangFromIndex(size_t i) const {
1112  		return (i < size_t(_nbLang)) ? _langList[i] : nullptr;
1113  	}
1114  	int getNbLang() const {return _nbLang;};
1115  	LangType getLangFromExt(const TCHAR *ext);
1116  	const TCHAR * getLangExtFromName(const TCHAR *langName) const
1117  	{
1118  		for (int i = 0 ; i < _nbLang ; ++i)
1119  		{
1120  			if (_langList[i]->_langName == langName)
1121  				return _langList[i]->_defaultExtList;
1122  		}
1123  		return nullptr;
1124  	}
1125  	const TCHAR * getLangExtFromLangType(LangType langType) const
1126  	{
1127  		for (int i = 0 ; i < _nbLang ; ++i)
1128  		{
1129  			if (_langList[i]->_langID == langType)
1130  				return _langList[i]->_defaultExtList;
1131  		}
1132  		return nullptr;
1133  	}
1134  	int getNbLRFile() const {return _nbRecentFile;};
1135  	generic_string *getLRFile(int index) const {
1136  		return _LRFileList[index];
1137  	};
1138  	void setNbMaxRecentFile(UINT nb) {
1139  		_nbMaxRecentFile = nb;
1140  	};
1141  	UINT getNbMaxRecentFile() const {return _nbMaxRecentFile;};
1142  	void setPutRecentFileInSubMenu(bool doSubmenu) {
1143  		_putRecentFileInSubMenu = doSubmenu;
1144  	}
1145  	bool putRecentFileInSubMenu() const {return _putRecentFileInSubMenu;};
1146  	void setRecentFileCustomLength(int len) {
1147  		_recentFileCustomLength = len;
1148  	}
1149  	int getRecentFileCustomLength() const {return _recentFileCustomLength;};
1150  	const ScintillaViewParams& getSVP() const {
1151  		return _svp;
1152  	}
1153  	bool writeRecentFileHistorySettings(int nbMaxFile = -1) const;
1154  	bool writeHistory(const TCHAR *fullpath);
1155  	bool writeProjectPanelsSettings() const;
1156  	bool writeColumnEditorSettings() const;
1157  	bool writeFileBrowserSettings(const std::vector<generic_string> & rootPath, const generic_string & latestSelectedItemPath) const;
1158  	TiXmlNode* getChildElementByAttribut(TiXmlNode *pere, const TCHAR *childName, const TCHAR *attributName, const TCHAR *attributVal) const;
1159  	bool writeScintillaParams();
1160  	void createXmlTreeFromGUIParams();
1161  	generic_string writeStyles(LexerStylerArray & lexersStylers, StyleArray & globalStylers); 
1162  	bool insertTabInfo(const TCHAR *langName, int tabInfo);
1163  	LexerStylerArray & getLStylerArray() {return _lexerStylerVect;};
1164  	StyleArray & getGlobalStylers() {return _widgetStyleArray;};
1165  	StyleArray & getMiscStylerArray() {return _widgetStyleArray;};
1166  	GlobalOverride & getGlobalOverrideStyle() {return _nppGUI._globalOverride;};
1167  	COLORREF getCurLineHilitingColour();
1168  	void setCurLineHilitingColour(COLORREF colour2Set);
1169  	void setFontList(HWND hWnd);
1170  	bool isInFontList(const generic_string& fontName2Search) const;
1171  	const std::vector<generic_string>& getFontList() const { return _fontlist; }
1172  	enum class DefaultFontType { menu, status, message, caption, smcaption };
1173  	static LOGFONT getDefaultGUIFont(DefaultFontType type = DefaultFontType::message);
1174  	int getNbUserLang() const {return _nbUserLang;}
1175  	UserLangContainer & getULCFromIndex(size_t i) {return *_userLangArray[i];};
1176  	UserLangContainer * getULCFromName(const TCHAR *userLangName);
1177  	int getNbExternalLang() const {return _nbExternalLang;};
1178  	int getExternalLangIndexFromName(const TCHAR *externalLangName) const;
1179  	ExternalLangContainer & getELCFromIndex(int i) {return *_externalLangArray[i];};
1180  	bool ExternalLangHasRoom() const {return _nbExternalLang < NB_MAX_EXTERNAL_LANG;};
1181  	void getExternalLexerFromXmlTree(TiXmlDocument* externalLexerDoc);
1182  	std::vector<TiXmlDocument *> * getExternalLexerDoc() { return &_pXmlExternalLexerDoc; };
1183  	void writeDefaultUDL();
1184  	void writeNonDefaultUDL();
1185  	void writeNeed2SaveUDL();
1186  	void writeShortcuts();
1187  	void writeSession(const Session & session, const TCHAR *fileName = NULL);
1188  	bool writeFindHistory();
1189  	bool isExistingUserLangName(const TCHAR *newName) const
1190  	{
1191  		if ((!newName) || (!newName[0]))
1192  			return true;
1193  		for (int i = 0 ; i < _nbUserLang ; ++i)
1194  		{
1195  			if (!lstrcmp(_userLangArray[i]->_name.c_str(), newName))
1196  				return true;
1197  		}
1198  		return false;
1199  	}
1200  	const TCHAR * getUserDefinedLangNameFromExt(TCHAR *ext, TCHAR *fullName) const;
1201  	int addUserLangToEnd(const UserLangContainer & userLang, const TCHAR *newName);
1202  	void removeUserLang(size_t index);
1203  	bool isExistingExternalLangName(const char* newName) const;
1204  	int addExternalLangToEnd(ExternalLangContainer * externalLang);
1205  	TiXmlDocumentA * getNativeLangA() const {return _pXmlNativeLangDocA;};
1206  	TiXmlDocument * getCustomizedToolIcons() const {return _pXmlToolIconsDoc;};
1207  	bool isTransparentAvailable() const {
1208  		return (_winVersion >= WV_VISTA);
1209  	}
1210  	void SetTransparent(HWND hwnd, int percent);
1211  	void removeTransparent(HWND hwnd);
1212  	void setCmdlineParam(const CmdLineParamsDTO & cmdLineParams)
1213  	{
1214  		_cmdLineParams = cmdLineParams;
1215  	}
1216  	const CmdLineParamsDTO & getCmdLineParams() const {return _cmdLineParams;};
1217  	const generic_string& getCmdLineString() const { return _cmdLineString; }
1218  	void setCmdLineString(const generic_string& str) { _cmdLineString = str; }
1219  	void setFileSaveDlgFilterIndex(int ln) {_fileSaveDlgFilterIndex = ln;};
1220  	int getFileSaveDlgFilterIndex() const {return _fileSaveDlgFilterIndex;};
1221  	bool isRemappingShortcut() const {return _shortcuts.size() != 0;};
1222  	std::vector<CommandShortcut> & getUserShortcuts() { return _shortcuts; };
1223  	std::vector<size_t> & getUserModifiedShortcuts() { return _customizedShortcuts; };
1224  	void addUserModifiedIndex(size_t index);
1225  	std::vector<MacroShortcut> & getMacroList() { return _macros; };
1226  	std::vector<UserCommand> & getUserCommandList() { return _userCommands; };
1227  	std::vector<PluginCmdShortcut> & getPluginCommandList() { return _pluginCommands; };
1228  	std::vector<size_t> & getPluginModifiedKeyIndices() { return _pluginCustomizedCmds; };
1229  	void addPluginModifiedIndex(size_t index);
1230  	std::vector<ScintillaKeyMap> & getScintillaKeyList() { return _scintillaKeyCommands; };
1231  	std::vector<int> & getScintillaModifiedKeyIndices() { return _scintillaModifiedKeyIndices; };
1232  	void addScintillaModifiedIndex(int index);
1233  	const Session & getSession() const {return _session;};
1234  	std::vector<MenuItemUnit>& getContextMenuItems() { return _contextMenuItems; };
1235  	std::vector<MenuItemUnit>& getTabContextMenuItems() { return _tabContextMenuItems; };
1236  	DynamicMenu& getMacroMenuItems() { return _macroMenuItems; };
1237  	DynamicMenu& getRunMenuItems() { return _runMenuItems; };
1238  	bool hasCustomContextMenu() const {return !_contextMenuItems.empty();};
1239  	bool hasCustomTabContextMenu() const {return !_tabContextMenuItems.empty();};
1240  	void setAccelerator(Accelerator *pAccel) {_pAccelerator = pAccel;};
1241  	Accelerator * getAccelerator() {return _pAccelerator;};
1242  	void setScintillaAccelerator(ScintillaAccelerator *pScintAccel) {_pScintAccelerator = pScintAccel;};
1243  	ScintillaAccelerator * getScintillaAccelerator() {return _pScintAccelerator;};
1244  	generic_string getNppPath() const {return _nppPath;};
1245  	generic_string getContextMenuPath() const {return _contextMenuPath;};
1246  	const TCHAR * getAppDataNppDir() const {return _appdataNppDir.c_str();};
1247  	const TCHAR * getPluginRootDir() const { return _pluginRootDir.c_str(); };
1248  	const TCHAR * getPluginConfDir() const { return _pluginConfDir.c_str(); };
1249  	const TCHAR * getUserPluginConfDir() const { return _userPluginConfDir.c_str(); };
1250  	const TCHAR * getWorkingDir() const {return _currentDirectory.c_str();};
1251  	const TCHAR * getWorkSpaceFilePath(int i) const {
1252  		if (i < 0 || i > 2) return nullptr;
1253  		return _workSpaceFilePathes[i].c_str();
1254  	};
1255  	const std::vector<generic_string> getFileBrowserRoots() const { return _fileBrowserRoot; };
1256  	generic_string getFileBrowserSelectedItemPath() const { return _fileBrowserSelectedItemPath; };
1257  	void setWorkSpaceFilePath(int i, const TCHAR *wsFile);
1258  	void setWorkingDir(const TCHAR * newPath);
1259  	void setStartWithLocFileName(const generic_string& locPath) {
1260  		_startWithLocFileName = locPath;
1261  	};
1262  	void setFunctionListExportBoolean(bool doIt) {
1263  		_doFunctionListExport = doIt;
1264  	};
1265  	bool doFunctionListExport() const {
1266  		return _doFunctionListExport;
1267  	};
1268  	void setPrintAndExitBoolean(bool doIt) {
1269  		_doPrintAndExit = doIt;
1270  	};
1271  	bool doPrintAndExit() const {
1272  		return _doPrintAndExit;
1273  	};
1274  	bool loadSession(Session & session, const TCHAR *sessionFileName);
1275  	void setLoadedSessionFilePath(const generic_string & loadedSessionFilePath) {
1276  		_loadedSessionFullFilePath = loadedSessionFilePath;
1277  	};
1278  	generic_string getLoadedSessionFilePath() {
1279  		return _loadedSessionFullFilePath;
1280  	};
1281  	int langTypeToCommandID(LangType lt) const;
1282  	struct FindDlgTabTitiles final {
1283  		generic_string _find;
1284  		generic_string _replace;
1285  		generic_string _findInFiles;
1286  		generic_string _findInProjects;
1287  		generic_string _mark;
1288  	};
1289  	FindDlgTabTitiles & getFindDlgTabTitiles() { return _findDlgTabTitiles;};
1290  	bool asNotepadStyle() const {return _asNotepadStyle;};
1291  	bool reloadPluginCmds() {
1292  		return getPluginCmdsFromXmlTree();
1293  	}
1294  	bool getContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu, bool isEditCM = true);
1295  	bool reloadContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu);
1296  	winVer getWinVersion() const {return _winVersion;};
1297  	generic_string getWinVersionStr() const;
1298  	generic_string getWinVerBitStr() const;
1299  	FindHistory & getFindHistory() {return _findHistory;};
1300  	bool _isFindReplacing = false; 
1301  	void safeWow64EnableWow64FsRedirection(BOOL Wow64FsEnableRedirection);
1302  	LocalizationSwitcher & getLocalizationSwitcher() {
1303  		return _localizationSwitcher;
1304  	}
1305  	ThemeSwitcher & getThemeSwitcher() {
1306  		return _themeSwitcher;
1307  	}
1308  	std::vector<generic_string> & getBlackList() { return _blacklist; };
1309  	bool isInBlackList(TCHAR *fn) const
1310  	{
1311  		for (auto& element: _blacklist)
1312  		{
1313  			if (element == fn)
1314  				return true;
1315  		}
1316  		return false;
1317  	}
1318  	bool importUDLFromFile(const generic_string& sourceFile);
1319  	bool exportUDLToFile(size_t langIndex2export, const generic_string& fileName2save);
1320  	NativeLangSpeaker* getNativeLangSpeaker() {
1321  		return _pNativeLangSpeaker;
1322  	}
1323  	void setNativeLangSpeaker(NativeLangSpeaker *nls) {
1324  		_pNativeLangSpeaker = nls;
1325  	}
1326  	bool isLocal() const {
1327  		return _isLocal;
1328  	}
1329  	bool isCloud() const {
1330  		return _isCloud;
1331  	}
1332  	void saveConfig_xml();
1333  	generic_string getUserPath() const {
1334  		return _userPath;
1335  	}
1336  	generic_string getUserDefineLangFolderPath() const {
1337  		return _userDefineLangsFolderPath;
1338  	}
1339  	generic_string getUserDefineLangPath() const {
1340  		return _userDefineLangPath;
1341  	}
1342  	bool writeSettingsFilesOnCloudForThe1stTime(const generic_string & cloudSettingsPath);
1343  	void setCloudChoice(const TCHAR *pathChoice);
1344  	void removeCloudChoice();
1345  	bool isCloudPathChanged() const;
1346  	int archType() const { return ARCH_TYPE; };
1347  	COLORREF getCurrentDefaultBgColor() const {
1348  		return _currentDefaultBgColor;
1349  	}
1350  	COLORREF getCurrentDefaultFgColor() const {
1351  		return _currentDefaultFgColor;
1352  	}
1353  	void setCurrentDefaultBgColor(COLORREF c) {
1354  		_currentDefaultBgColor = c;
1355  	}
1356  	void setCurrentDefaultFgColor(COLORREF c) {
1357  		_currentDefaultFgColor = c;
1358  	}
1359  	void setCmdSettingsDir(const generic_string& settingsDir) {
1360  		_cmdSettingsDir = settingsDir;
1361  	};
1362  	void setTitleBarAdd(const generic_string& titleAdd) {
1363  		_titleBarAdditional = titleAdd;
1364  	}
1365  	const generic_string& getTitleBarAdd() const {
1366  		return _titleBarAdditional;
1367  	}
1368  	DPIManager _dpiManager;
1369  	generic_string static getSpecialFolderLocation(int folderKind);
1370  	void setUdlXmlDirtyFromIndex(size_t i);
1371  	void setUdlXmlDirtyFromXmlDoc(const TiXmlDocument* xmlDoc);
1372  	void removeIndexFromXmlUdls(size_t i);
1373  	bool isStylerDocLoaded() const { return _pXmlUserStylerDoc != nullptr; };
1374  	ColumnEditorParam _columnEditParam;
1375  private:
1376  	NppParameters();
1377  	~NppParameters();
1378  	NppParameters(const NppParameters&) = delete;
1379  	NppParameters& operator=(const NppParameters&) = delete;
1380  	NppParameters(NppParameters&&) = delete;
1381  	NppParameters& operator=(NppParameters&&) = delete;
1382  	TiXmlDocument *_pXmlDoc = nullptr; 
1383  	TiXmlDocument *_pXmlUserDoc = nullptr; 
1384  	TiXmlDocument *_pXmlUserStylerDoc = nullptr; 
1385  	TiXmlDocument *_pXmlUserLangDoc = nullptr; 
1386  	std::vector<UdlXmlFileState> _pXmlUserLangsDoc; 
1387  	TiXmlDocument *_pXmlToolIconsDoc = nullptr; 
1388  	TiXmlDocumentA *_pXmlShortcutDocA = nullptr; 
1389  	TiXmlDocumentA *_pXmlNativeLangDocA = nullptr; 
1390  	TiXmlDocumentA *_pXmlContextMenuDocA = nullptr; 
1391  	TiXmlDocumentA *_pXmlTabContextMenuDocA = nullptr; 
1392  	std::vector<TiXmlDocument *> _pXmlExternalLexerDoc; 
1393  	NppGUI _nppGUI;
1394  	ScintillaViewParams _svp;
1395  	Lang* _langList[NB_LANG] = { nullptr };
1396  	int _nbLang = 0;
1397  	generic_string* _LRFileList[NB_MAX_LRF_FILE] = { nullptr };
1398  	int _nbRecentFile = 0;
1399  	UINT _nbMaxRecentFile = 10;
1400  	bool _putRecentFileInSubMenu = false;
1401  	int _recentFileCustomLength = RECENTFILES_SHOWFULLPATH;	
1402  	FindHistory _findHistory;
1403  	UserLangContainer* _userLangArray[NB_MAX_USER_LANG] = { nullptr };
1404  	unsigned char _nbUserLang = 0; 
1405  	generic_string _userDefineLangsFolderPath;
1406  	generic_string _userDefineLangPath;
1407  	ExternalLangContainer* _externalLangArray[NB_MAX_EXTERNAL_LANG] = { nullptr };
1408  	int _nbExternalLang = 0;
1409  	CmdLineParamsDTO _cmdLineParams;
1410  	generic_string _cmdLineString;
1411  	int _fileSaveDlgFilterIndex = -1;
1412  	LexerStylerArray _lexerStylerVect;
1413  	StyleArray _widgetStyleArray;
1414  	std::vector<generic_string> _fontlist;
1415  	std::vector<generic_string> _blacklist;
1416  	bool _isLocal = false;
1417  	bool _isx64 = false; 
1418  	bool _isCloud = false;
1419  	generic_string _cmdSettingsDir;
1420  	generic_string _titleBarAdditional;
1421  	generic_string _loadedSessionFullFilePath;
1422  public:
1423  	void setShortcutDirty() { _isAnyShortcutModified = true; };
1424  	void setAdminMode(bool isAdmin) { _isAdminMode = isAdmin; }
1425  	bool isAdmin() const { return _isAdminMode; }
1426  	bool regexBackward4PowerUser() const { return _findHistory._regexBackward4PowerUser; }
1427  	bool isSelectFgColorEnabled() const { return _isSelectFgColorEnabled; };
1428  private:
1429  	bool _isAnyShortcutModified = false;
1430  	std::vector<CommandShortcut> _shortcuts;			
1431  	std::vector<size_t> _customizedShortcuts;			
1432  	std::vector<MacroShortcut> _macros;				
1433  	std::vector<UserCommand> _userCommands;			
1434  	std::vector<PluginCmdShortcut> _pluginCommands;	
1435  	std::vector<size_t> _pluginCustomizedCmds;			
1436  	std::vector<ScintillaKeyMap> _scintillaKeyCommands;	
1437  	std::vector<int> _scintillaModifiedKeyIndices;		
1438  	LocalizationSwitcher _localizationSwitcher;
1439  	generic_string _startWithLocFileName;
1440  	bool _doFunctionListExport = false;
1441  	bool _doPrintAndExit = false;
1442  	ThemeSwitcher _themeSwitcher;
1443  	std::vector<MenuItemUnit> _contextMenuItems;
1444  	std::vector<MenuItemUnit> _tabContextMenuItems;
1445  	DynamicMenu _macroMenuItems;
1446  	DynamicMenu _runMenuItems;
1447  	Session _session;
1448  	generic_string _shortcutsPath;
1449  	generic_string _contextMenuPath;
1450  	generic_string _tabContextMenuPath;
1451  	generic_string _sessionPath;
1452  	generic_string _nppPath;
1453  	generic_string _userPath;
1454  	generic_string _stylerPath;
1455  	generic_string _appdataNppDir; 
1456  	generic_string _pluginRootDir; 
1457  	generic_string _pluginConfDir; 
1458  	generic_string _userPluginConfDir; 
1459  	generic_string _currentDirectory;
1460  	generic_string _workSpaceFilePathes[3];
1461  	std::vector<generic_string> _fileBrowserRoot;
1462  	generic_string _fileBrowserSelectedItemPath;
1463  	Accelerator* _pAccelerator = nullptr;
1464  	ScintillaAccelerator* _pScintAccelerator = nullptr;
1465  	FindDlgTabTitiles _findDlgTabTitiles;
1466  	bool _asNotepadStyle = false;
1467  	winVer _winVersion = WV_UNKNOWN;
1468  	Platform _platForm = PF_UNKNOWN;
1469  	NativeLangSpeaker *_pNativeLangSpeaker = nullptr;
1470  	COLORREF _currentDefaultBgColor = RGB(0xFF, 0xFF, 0xFF);
1471  	COLORREF _currentDefaultFgColor = RGB(0x00, 0x00, 0x00);
1472  	generic_string _initialCloudChoice;
1473  	generic_string _wingupFullPath;
1474  	generic_string _wingupParams;
1475  	generic_string _wingupDir;
1476  	bool _isElevationRequired = false;
1477  	bool _isAdminMode = false;
1478  	bool _isSelectFgColorEnabled = false;
1479  	bool _doNppLogNetworkDriveIssue = false;
1480  	bool _doNppLogNulContentCorruptionIssue = false;
1481  	bool _isEndSessionStarted = false;
1482  	bool _isEndSessionCritical = false;
1483  public:
1484  	generic_string getWingupFullPath() const { return _wingupFullPath; };
1485  	generic_string getWingupParams() const { return _wingupParams; };
1486  	generic_string getWingupDir() const { return _wingupDir; };
1487  	bool shouldDoUAC() const { return _isElevationRequired; };
1488  	void setWingupFullPath(const generic_string& val2set) { _wingupFullPath = val2set; };
1489  	void setWingupParams(const generic_string& val2set) { _wingupParams = val2set; };
1490  	void setWingupDir(const generic_string& val2set) { _wingupDir = val2set; };
1491  	void setElevationRequired(bool val2set) { _isElevationRequired = val2set; };
1492  	bool doNppLogNetworkDriveIssue() { return _doNppLogNetworkDriveIssue; };
1493  	bool doNppLogNulContentCorruptionIssue() { return _doNppLogNulContentCorruptionIssue; };
1494  	void endSessionStart() { _isEndSessionStarted = true; };
1495  	bool isEndSessionStarted() { return _isEndSessionStarted; };
1496  	void makeEndSessionCritical() { _isEndSessionCritical = true; };
1497  	bool isEndSessionCritical() { return _isEndSessionCritical; };
1498  private:
1499  	void getLangKeywordsFromXmlTree();
1500  	bool getUserParametersFromXmlTree();
1501  	bool getUserStylersFromXmlTree();
1502  	std::pair<unsigned char, unsigned char> addUserDefineLangsFromXmlTree(TiXmlDocument *tixmldoc);
1503  	bool getShortcutsFromXmlTree();
1504  	bool getMacrosFromXmlTree();
1505  	bool getUserCmdsFromXmlTree();
1506  	bool getPluginCmdsFromXmlTree();
1507  	bool getScintKeysFromXmlTree();
1508  	bool getSessionFromXmlTree(TiXmlDocument *pSessionDoc, Session& session);
1509  	void feedGUIParameters(TiXmlNode *node);
1510  	void feedKeyWordsParameters(TiXmlNode *node);
1511  	void feedFileListParameters(TiXmlNode *node);
1512  	void feedScintillaParam(TiXmlNode *node);
1513  	void feedDockingManager(TiXmlNode *node);
1514  	void duplicateDockingManager(TiXmlNode *dockMngNode, TiXmlElement* dockMngElmt2Clone);
1515  	void feedFindHistoryParameters(TiXmlNode *node);
1516  	void feedProjectPanelsParameters(TiXmlNode *node);
1517  	void feedFileBrowserParameters(TiXmlNode *node);
1518  	void feedColumnEditorParameters(TiXmlNode *node);
1519  	bool feedStylerArray(TiXmlNode *node);
1520  	std::pair<unsigned char, unsigned char> feedUserLang(TiXmlNode *node);
1521  	void feedUserStyles(TiXmlNode *node);
1522  	void feedUserKeywordList(TiXmlNode *node);
1523  	void feedUserSettings(TiXmlNode *node);
1524  	void feedShortcut(TiXmlNodeA *node);
1525  	void feedMacros(TiXmlNodeA *node);
1526  	void feedUserCmds(TiXmlNodeA *node);
1527  	void feedPluginCustomizedCmds(TiXmlNodeA *node);
1528  	void feedScintKeys(TiXmlNodeA *node);
1529  	void getActions(TiXmlNodeA *node, Macro & macro);
1530  	bool getShortcuts(TiXmlNodeA *node, Shortcut & sc, std::string* folderName = nullptr);
1531  	void writeStyle2Element(const Style & style2Write, Style & style2Sync, TiXmlElement *element);
1532  	void insertUserLang2Tree(TiXmlNode *node, UserLangContainer *userLang);
1533  	void insertCmd(TiXmlNodeA *cmdRoot, const CommandShortcut & cmd);
1534  	void insertMacro(TiXmlNodeA *macrosRoot, const MacroShortcut & macro, const std::string& folderName);
1535  	void insertUserCmd(TiXmlNodeA *userCmdRoot, const UserCommand & userCmd, const std::string& folderName);
1536  	void insertScintKey(TiXmlNodeA *scintKeyRoot, const ScintillaKeyMap & scintKeyMap);
1537  	void insertPluginCmd(TiXmlNodeA *pluginCmdRoot, const PluginCmdShortcut & pluginCmd);
1538  	TiXmlElement * insertGUIConfigBoolNode(TiXmlNode *r2w, const TCHAR *name, bool bVal);
1539  	void insertDockingParamNode(TiXmlNode *GUIRoot);
1540  	void writeExcludedLangList(TiXmlElement *element);
1541  	void writePrintSetting(TiXmlElement *element);
1542  	void initMenuKeys();		
1543  	void initScintillaKeys();	
1544  	int getCmdIdFromMenuEntryItemName(HMENU mainMenuHadle, const generic_string& menuEntryName, const generic_string& menuItemName); 
1545  	int getPluginCmdIdFromMenuEntryItemName(HMENU pluginsMenu, const generic_string& pluginName, const generic_string& pluginCmdName); 
1546  	winVer getWindowsVersion();
1547  };
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_BTREE_H_
2  #define ABSL_CONTAINER_INTERNAL_BTREE_H_
3  #include <algorithm>
4  #include <cassert>
5  #include <cstddef>
6  #include <cstdint>
7  #include <cstring>
8  #include <functional>
9  #include <iterator>
10  #include <limits>
11  #include <new>
12  #include <string>
13  #include <type_traits>
14  #include <utility>
15  #include "absl/base/internal/raw_logging.h"
16  #include "absl/base/macros.h"
17  #include "absl/container/internal/common.h"
18  #include "absl/container/internal/common_policy_traits.h"
19  #include "absl/container/internal/compressed_tuple.h"
20  #include "absl/container/internal/container_memory.h"
21  #include "absl/container/internal/layout.h"
22  #include "absl/memory/memory.h"
23  #include "absl/meta/type_traits.h"
24  #include "absl/strings/cord.h"
25  #include "absl/strings/string_view.h"
26  #include "absl/types/compare.h"
27  #include "absl/utility/utility.h"
28  namespace absl {
29  ABSL_NAMESPACE_BEGIN
30  namespace container_internal {
31  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
32  #error ABSL_BTREE_ENABLE_GENERATIONS cannot be directly set
33  #elif defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
34      defined(ABSL_HAVE_MEMORY_SANITIZER)
35  #define ABSL_BTREE_ENABLE_GENERATIONS
36  #endif
37  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
38  constexpr bool BtreeGenerationsEnabled() { return true; }
39  #else
40  constexpr bool BtreeGenerationsEnabled() { return false; }
41  #endif
42  template <typename Compare, typename T, typename U>
43  using compare_result_t = absl::result_of_t<const Compare(const T &, const U &)>;
44  template <typename Compare, typename T>
45  using btree_is_key_compare_to =
46      std::is_convertible<compare_result_t<Compare, T, T>, absl::weak_ordering>;
47  struct StringBtreeDefaultLess {
48    using is_transparent = void;
49    StringBtreeDefaultLess() = default;
50    StringBtreeDefaultLess(std::less<std::string>) {}        
51    StringBtreeDefaultLess(std::less<absl::string_view>) {}  
52    explicit operator std::less<std::string>() const { return {}; }
53    explicit operator std::less<absl::string_view>() const { return {}; }
54    explicit operator std::less<absl::Cord>() const { return {}; }
55    absl::weak_ordering operator()(absl::string_view lhs,
56                                   absl::string_view rhs) const {
57      return compare_internal::compare_result_as_ordering(lhs.compare(rhs));
58    }
59    StringBtreeDefaultLess(std::less<absl::Cord>) {}  
60    absl::weak_ordering operator()(const absl::Cord &lhs,
61                                   const absl::Cord &rhs) const {
62      return compare_internal::compare_result_as_ordering(lhs.Compare(rhs));
63    }
64    absl::weak_ordering operator()(const absl::Cord &lhs,
65                                   absl::string_view rhs) const {
66      return compare_internal::compare_result_as_ordering(lhs.Compare(rhs));
67    }
68    absl::weak_ordering operator()(absl::string_view lhs,
69                                   const absl::Cord &rhs) const {
70      return compare_internal::compare_result_as_ordering(-rhs.Compare(lhs));
71    }
72  };
73  struct StringBtreeDefaultGreater {
74    using is_transparent = void;
75    StringBtreeDefaultGreater() = default;
76    StringBtreeDefaultGreater(std::greater<std::string>) {}        
77    StringBtreeDefaultGreater(std::greater<absl::string_view>) {}  
78    explicit operator std::greater<std::string>() const { return {}; }
79    explicit operator std::greater<absl::string_view>() const { return {}; }
80    explicit operator std::greater<absl::Cord>() const { return {}; }
81    absl::weak_ordering operator()(absl::string_view lhs,
82                                   absl::string_view rhs) const {
83      return compare_internal::compare_result_as_ordering(rhs.compare(lhs));
84    }
85    StringBtreeDefaultGreater(std::greater<absl::Cord>) {}  
86    absl::weak_ordering operator()(const absl::Cord &lhs,
87                                   const absl::Cord &rhs) const {
88      return compare_internal::compare_result_as_ordering(rhs.Compare(lhs));
89    }
90    absl::weak_ordering operator()(const absl::Cord &lhs,
91                                   absl::string_view rhs) const {
92      return compare_internal::compare_result_as_ordering(-lhs.Compare(rhs));
93    }
94    absl::weak_ordering operator()(absl::string_view lhs,
95                                   const absl::Cord &rhs) const {
96      return compare_internal::compare_result_as_ordering(rhs.Compare(lhs));
97    }
98  };
99  template <typename Compare, bool is_class = std::is_class<Compare>::value>
100  struct checked_compare_base : Compare {
101    using Compare::Compare;
102    explicit checked_compare_base(Compare c) : Compare(std::move(c)) {}
103    const Compare &comp() const { return *this; }
104  };
105  template <typename Compare>
106  struct checked_compare_base<Compare, false> {
107    explicit checked_compare_base(Compare c) : compare(std::move(c)) {}
108    const Compare &comp() const { return compare; }
109    Compare compare;
110  };
111  struct BtreeTestOnlyCheckedCompareOptOutBase {};
112  template <typename Compare, typename Key>
113  struct key_compare_adapter {
114    struct checked_compare : checked_compare_base<Compare> {
115     private:
116      using Base = typename checked_compare::checked_compare_base;
117      using Base::comp;
118      bool is_self_equivalent(const Key &k) const {
119        return comp()(k, k) == 0;
120      }
121      template <typename T>
122      bool is_self_equivalent(const T &) const {
123        return true;
124      }
125     public:
126      using Base::Base;
127      checked_compare(Compare comp) : Base(std::move(comp)) {}  
128      explicit operator Compare() const { return comp(); }
129      template <typename T, typename U,
130                absl::enable_if_t<
131                    std::is_same<bool, compare_result_t<Compare, T, U>>::value,
132                    int> = 0>
133      bool operator()(const T &lhs, const U &rhs) const {
134        assert(is_self_equivalent(lhs));
135        assert(is_self_equivalent(rhs));
136        const bool lhs_comp_rhs = comp()(lhs, rhs);
137        assert(!lhs_comp_rhs || !comp()(rhs, lhs));
138        return lhs_comp_rhs;
139      }
140      template <
141          typename T, typename U,
142          absl::enable_if_t<std::is_convertible<compare_result_t<Compare, T, U>,
143                                                absl::weak_ordering>::value,
144                            int> = 0>
145      absl::weak_ordering operator()(const T &lhs, const U &rhs) const {
146        assert(is_self_equivalent(lhs));
147        assert(is_self_equivalent(rhs));
148        const absl::weak_ordering lhs_comp_rhs = comp()(lhs, rhs);
149  #ifndef NDEBUG
150        const absl::weak_ordering rhs_comp_lhs = comp()(rhs, lhs);
151        if (lhs_comp_rhs > 0) {
152          assert(rhs_comp_lhs < 0 && "lhs_comp_rhs > 0 -> rhs_comp_lhs < 0");
153        } else if (lhs_comp_rhs == 0) {
154          assert(rhs_comp_lhs == 0 && "lhs_comp_rhs == 0 -> rhs_comp_lhs == 0");
155        } else {
156          assert(rhs_comp_lhs > 0 && "lhs_comp_rhs < 0 -> rhs_comp_lhs > 0");
157        }
158  #endif
159        return lhs_comp_rhs;
160      }
161    };
162    using type = absl::conditional_t<
163        std::is_base_of<BtreeTestOnlyCheckedCompareOptOutBase, Compare>::value,
164        Compare, checked_compare>;
165  };
166  template <>
167  struct key_compare_adapter<std::less<std::string>, std::string> {
168    using type = StringBtreeDefaultLess;
169  };
170  template <>
171  struct key_compare_adapter<std::greater<std::string>, std::string> {
172    using type = StringBtreeDefaultGreater;
173  };
174  template <>
175  struct key_compare_adapter<std::less<absl::string_view>, absl::string_view> {
176    using type = StringBtreeDefaultLess;
177  };
178  template <>
179  struct key_compare_adapter<std::greater<absl::string_view>, absl::string_view> {
180    using type = StringBtreeDefaultGreater;
181  };
182  template <>
183  struct key_compare_adapter<std::less<absl::Cord>, absl::Cord> {
184    using type = StringBtreeDefaultLess;
185  };
186  template <>
187  struct key_compare_adapter<std::greater<absl::Cord>, absl::Cord> {
188    using type = StringBtreeDefaultGreater;
189  };
190  template <typename T, typename = void>
191  struct has_linear_node_search_preference : std::false_type {};
192  template <typename T, typename = void>
193  struct prefers_linear_node_search : std::false_type {};
194  template <typename T>
195  struct has_linear_node_search_preference<
196      T, absl::void_t<typename T::absl_btree_prefer_linear_node_search>>
197      : std::true_type {};
198  template <typename T>
199  struct prefers_linear_node_search<
200      T, absl::void_t<typename T::absl_btree_prefer_linear_node_search>>
201      : T::absl_btree_prefer_linear_node_search {};
202  template <typename Compare, typename Key>
203  constexpr bool compare_has_valid_result_type() {
204    using compare_result_type = compare_result_t<Compare, Key, Key>;
205    return std::is_same<compare_result_type, bool>::value ||
206           std::is_convertible<compare_result_type, absl::weak_ordering>::value;
207  }
208  template <typename original_key_compare, typename value_type>
209  class map_value_compare {
210    template <typename Params>
211    friend class btree;
212   protected:
213    explicit map_value_compare(original_key_compare c) : comp(std::move(c)) {}
214    original_key_compare comp;  
215   public:
216    auto operator()(const value_type &lhs, const value_type &rhs) const
217        -> decltype(comp(lhs.first, rhs.first)) {
218      return comp(lhs.first, rhs.first);
219    }
220  };
221  template <typename Key, typename Compare, typename Alloc, int TargetNodeSize,
222            bool IsMulti, bool IsMap, typename SlotPolicy>
223  struct common_params : common_policy_traits<SlotPolicy> {
224    using original_key_compare = Compare;
225    using key_compare =
226        absl::conditional_t<!compare_has_valid_result_type<Compare, Key>(),
227                            Compare,
228                            typename key_compare_adapter<Compare, Key>::type>;
229    static constexpr bool kIsKeyCompareStringAdapted =
230        std::is_same<key_compare, StringBtreeDefaultLess>::value ||
231        std::is_same<key_compare, StringBtreeDefaultGreater>::value;
232    static constexpr bool kIsKeyCompareTransparent =
233        IsTransparent<original_key_compare>::value || kIsKeyCompareStringAdapted;
234    using is_key_compare_to = btree_is_key_compare_to<key_compare, Key>;
235    using allocator_type = Alloc;
236    using key_type = Key;
237    using size_type = size_t;
238    using difference_type = ptrdiff_t;
239    using slot_policy = SlotPolicy;
240    using slot_type = typename slot_policy::slot_type;
241    using value_type = typename slot_policy::value_type;
242    using init_type = typename slot_policy::mutable_value_type;
243    using pointer = value_type *;
244    using const_pointer = const value_type *;
245    using reference = value_type &;
246    using const_reference = const value_type &;
247    using value_compare =
248        absl::conditional_t<IsMap,
249                            map_value_compare<original_key_compare, value_type>,
250                            original_key_compare>;
251    using is_map_container = std::integral_constant<bool, IsMap>;
252    template <typename LookupKey>
253    constexpr static bool can_have_multiple_equivalent_keys() {
254      return IsMulti || (IsTransparent<key_compare>::value &&
255                         !std::is_same<LookupKey, Key>::value &&
256                         !kIsKeyCompareStringAdapted);
257    }
258    enum {
259      kTargetNodeSize = TargetNodeSize,
260      kNodeSlotSpace = TargetNodeSize - &bsol;*minimum overhead=*/(sizeof(void *) + 4),
261    };
262    using node_count_type =
263        absl::conditional_t<(kNodeSlotSpace / sizeof(slot_type) >
264                             (std::numeric_limits<uint8_t>::max)()),
265                            uint16_t, uint8_t>;  
266  };
267  template <typename Compare>
268  struct upper_bound_adapter {
269    explicit upper_bound_adapter(const Compare &c) : comp(c) {}
270    template <typename K1, typename K2>
271    bool operator()(const K1 &a, const K2 &b) const {
272      return !compare_internal::compare_result_as_less_than(comp(b, a));
273    }
274   private:
275    Compare comp;
276  };
277  enum class MatchKind : uint8_t { kEq, kNe };
278  template <typename V, bool IsCompareTo>
279  struct SearchResult {
280    V value;
281    MatchKind match;
282    static constexpr bool HasMatch() { return true; }
283    bool IsEq() const { return match == MatchKind::kEq; }
284  };
285  template <typename V>
286  struct SearchResult<V, false> {
287    SearchResult() {}
288    explicit SearchResult(V v) : value(v) {}
289    SearchResult(V v, MatchKind &bsol;*match*/) : value(v) {}
290    V value;
291    static constexpr bool HasMatch() { return false; }
292    static constexpr bool IsEq() { return false; }
293  };
294  template <typename Params>
295  class btree_node {
296    using is_key_compare_to = typename Params::is_key_compare_to;
297    using field_type = typename Params::node_count_type;
298    using allocator_type = typename Params::allocator_type;
299    using slot_type = typename Params::slot_type;
300    using original_key_compare = typename Params::original_key_compare;
301   public:
302    using params_type = Params;
303    using key_type = typename Params::key_type;
304    using value_type = typename Params::value_type;
305    using pointer = typename Params::pointer;
306    using const_pointer = typename Params::const_pointer;
307    using reference = typename Params::reference;
308    using const_reference = typename Params::const_reference;
309    using key_compare = typename Params::key_compare;
310    using size_type = typename Params::size_type;
311    using difference_type = typename Params::difference_type;
312    using use_linear_search = std::integral_constant<
313        bool, has_linear_node_search_preference<original_key_compare>::value
314                  ? prefers_linear_node_search<original_key_compare>::value
315              : has_linear_node_search_preference<key_type>::value
316                  ? prefers_linear_node_search<key_type>::value
317                  : std::is_arithmetic<key_type>::value &&
318                        (std::is_same<std::less<key_type>,
319                                      original_key_compare>::value ||
320                         std::is_same<std::greater<key_type>,
321                                      original_key_compare>::value)>;
322    ~btree_node() = default;
323    btree_node(btree_node const &) = delete;
324    btree_node &operator=(btree_node const &) = delete;
325    constexpr static size_type Alignment() {
326      static_assert(LeafLayout(1).Alignment() == InternalLayout().Alignment(),
327                    "Alignment of all nodes must be equal.");
328      return InternalLayout().Alignment();
329    }
330   protected:
331    btree_node() = default;
332   private:
333    using layout_type =
334        absl::container_internal::Layout<btree_node *, uint32_t, field_type,
335                                         slot_type, btree_node *>;
336    constexpr static size_type SizeWithNSlots(size_type n) {
337      return layout_type(
338                  1,
339                  BtreeGenerationsEnabled() ? 1 : 0,
340                  4,
341                  n,
342                  0)
343          .AllocSize();
344    }
345    constexpr static size_type MinimumOverhead() {
346      return SizeWithNSlots(1) - sizeof(slot_type);
347    }
348    constexpr static size_type NodeTargetSlots(const size_type begin,
349                                               const size_type end) {
350      return begin == end ? begin
351             : SizeWithNSlots((begin + end) / 2 + 1) >
352                     params_type::kTargetNodeSize
353                 ? NodeTargetSlots(begin, (begin + end) / 2)
354                 : NodeTargetSlots((begin + end) / 2 + 1, end);
355    }
356    constexpr static size_type kTargetNodeSize = params_type::kTargetNodeSize;
357    constexpr static size_type kNodeTargetSlots =
358        NodeTargetSlots(0, kTargetNodeSize);
359    constexpr static size_type kMinNodeSlots = 4;
360    constexpr static size_type kNodeSlots =
361        kNodeTargetSlots >= kMinNodeSlots ? kNodeTargetSlots : kMinNodeSlots;
362    constexpr static field_type kInternalNodeMaxCount = 0;
363    constexpr static layout_type Layout(const size_type slot_count,
364                                        const size_type child_count) {
365      return layout_type(
366           1,
367           BtreeGenerationsEnabled() ? 1 : 0,
368           4,
369           slot_count,
370           child_count);
371    }
372    constexpr static layout_type LeafLayout(
373        const size_type slot_count = kNodeSlots) {
374      return Layout(slot_count, 0);
375    }
376    constexpr static layout_type InternalLayout() {
377      return Layout(kNodeSlots, kNodeSlots + 1);
378    }
379    constexpr static size_type LeafSize(const size_type slot_count = kNodeSlots) {
380      return LeafLayout(slot_count).AllocSize();
381    }
382    constexpr static size_type InternalSize() {
383      return InternalLayout().AllocSize();
384    }
385    template <size_type N>
386    inline typename layout_type::template ElementType<N> *GetField() {
387      assert(N < 4 || is_internal());
388      return InternalLayout().template Pointer<N>(reinterpret_cast<char *>(this));
389    }
390    template <size_type N>
391    inline const typename layout_type::template ElementType<N> *GetField() const {
392      assert(N < 4 || is_internal());
393      return InternalLayout().template Pointer<N>(
394          reinterpret_cast<const char *>(this));
395    }
396    void set_parent(btree_node *p) { *GetField<0>() = p; }
397    field_type &mutable_finish() { return GetField<2>()[2]; }
398    slot_type *slot(size_type i) { return &GetField<3>()[i]; }
399    slot_type *start_slot() { return slot(start()); }
400    slot_type *finish_slot() { return slot(finish()); }
401    const slot_type *slot(size_type i) const { return &GetField<3>()[i]; }
402    void set_position(field_type v) { GetField<2>()[0] = v; }
403    void set_start(field_type v) { GetField<2>()[1] = v; }
404    void set_finish(field_type v) { GetField<2>()[2] = v; }
405    void set_max_count(field_type v) { GetField<2>()[3] = v; }
406   public:
407    bool is_leaf() const { return GetField<2>()[3] != kInternalNodeMaxCount; }
408    bool is_internal() const { return !is_leaf(); }
409    field_type position() const { return GetField<2>()[0]; }
410    field_type start() const {
411      assert(GetField<2>()[1] == 0);
412      return 0;
413    }
414    field_type finish() const { return GetField<2>()[2]; }
415    field_type count() const {
416      assert(finish() >= start());
417      return finish() - start();
418    }
419    field_type max_count() const {
420      const field_type max_count = GetField<2>()[3];
421      return max_count == field_type{kInternalNodeMaxCount}
422                 ? field_type{kNodeSlots}
423                 : max_count;
424    }
425    btree_node *parent() const { return *GetField<0>(); }
426    bool is_root() const { return parent()->is_leaf(); }
427    void make_root() {
428      assert(parent()->is_root());
429      set_generation(parent()->generation());
430      set_parent(parent()->parent());
431    }
432    uint32_t *get_root_generation() const {
433      assert(BtreeGenerationsEnabled());
434      const btree_node *curr = this;
435      for (; !curr->is_root(); curr = curr->parent()) continue;
436      return const_cast<uint32_t *>(&curr->GetField<1>()[0]);
437    }
438    uint32_t generation() const {
439      return BtreeGenerationsEnabled() ? *get_root_generation() : 0;
440    }
441    void set_generation(uint32_t generation) {
442      if (BtreeGenerationsEnabled()) GetField<1>()[0] = generation;
443    }
444    void next_generation() {
445      if (BtreeGenerationsEnabled()) ++*get_root_generation();
446    }
447    const key_type &key(size_type i) const { return params_type::key(slot(i)); }
448    reference value(size_type i) { return params_type::element(slot(i)); }
449    const_reference value(size_type i) const {
450      return params_type::element(slot(i));
451    }
452    btree_node *child(field_type i) const { return GetField<4>()[i]; }
453    btree_node *start_child() const { return child(start()); }
454    btree_node *&mutable_child(field_type i) { return GetField<4>()[i]; }
455    void clear_child(field_type i) {
456      absl::container_internal::SanitizerPoisonObject(&mutable_child(i));
457    }
458    void set_child_noupdate_position(field_type i, btree_node *c) {
459      absl::container_internal::SanitizerUnpoisonObject(&mutable_child(i));
460      mutable_child(i) = c;
461    }
462    void set_child(field_type i, btree_node *c) {
463      set_child_noupdate_position(i, c);
464      c->set_position(i);
465    }
466    void init_child(field_type i, btree_node *c) {
467      set_child(i, c);
468      c->set_parent(this);
469    }
470    template <typename K>
471    SearchResult<size_type, is_key_compare_to::value> lower_bound(
472        const K &k, const key_compare &comp) const {
473      return use_linear_search::value ? linear_search(k, comp)
474                                      : binary_search(k, comp);
475    }
476    template <typename K>
477    size_type upper_bound(const K &k, const key_compare &comp) const {
478      auto upper_compare = upper_bound_adapter<key_compare>(comp);
479      return use_linear_search::value ? linear_search(k, upper_compare).value
480                                      : binary_search(k, upper_compare).value;
481    }
482    template <typename K, typename Compare>
483    SearchResult<size_type, btree_is_key_compare_to<Compare, key_type>::value>
484    linear_search(const K &k, const Compare &comp) const {
485      return linear_search_impl(k, start(), finish(), comp,
486                                btree_is_key_compare_to<Compare, key_type>());
487    }
488    template <typename K, typename Compare>
489    SearchResult<size_type, btree_is_key_compare_to<Compare, key_type>::value>
490    binary_search(const K &k, const Compare &comp) const {
491      return binary_search_impl(k, start(), finish(), comp,
492                                btree_is_key_compare_to<Compare, key_type>());
493    }
494    template <typename K, typename Compare>
495    SearchResult<size_type, false> linear_search_impl(
496        const K &k, size_type s, const size_type e, const Compare &comp,
497        std::false_type &bsol;* IsCompareTo */) const {
498      while (s < e) {
499        if (!comp(key(s), k)) {
500          break;
501        }
502        ++s;
503      }
504      return SearchResult<size_type, false>{s};
505    }
506    template <typename K, typename Compare>
507    SearchResult<size_type, true> linear_search_impl(
508        const K &k, size_type s, const size_type e, const Compare &comp,
509        std::true_type &bsol;* IsCompareTo */) const {
510      while (s < e) {
511        const absl::weak_ordering c = comp(key(s), k);
512        if (c == 0) {
513          return {s, MatchKind::kEq};
514        } else if (c > 0) {
515          break;
516        }
517        ++s;
518      }
519      return {s, MatchKind::kNe};
520    }
521    template <typename K, typename Compare>
522    SearchResult<size_type, false> binary_search_impl(
523        const K &k, size_type s, size_type e, const Compare &comp,
524        std::false_type &bsol;* IsCompareTo */) const {
525      while (s != e) {
526        const size_type mid = (s + e) >> 1;
527        if (comp(key(mid), k)) {
528          s = mid + 1;
529        } else {
530          e = mid;
531        }
532      }
533      return SearchResult<size_type, false>{s};
534    }
535    template <typename K, typename CompareTo>
536    SearchResult<size_type, true> binary_search_impl(
537        const K &k, size_type s, size_type e, const CompareTo &comp,
538        std::true_type &bsol;* IsCompareTo */) const {
539      if (params_type::template can_have_multiple_equivalent_keys<K>()) {
540        MatchKind exact_match = MatchKind::kNe;
541        while (s != e) {
542          const size_type mid = (s + e) >> 1;
543          const absl::weak_ordering c = comp(key(mid), k);
544          if (c < 0) {
545            s = mid + 1;
546          } else {
547            e = mid;
548            if (c == 0) {
549              exact_match = MatchKind::kEq;
550            }
551          }
552        }
553        return {s, exact_match};
554      } else {  
555        while (s != e) {
556          const size_type mid = (s + e) >> 1;
557          const absl::weak_ordering c = comp(key(mid), k);
558          if (c < 0) {
559            s = mid + 1;
560          } else if (c > 0) {
561            e = mid;
562          } else {
563            return {mid, MatchKind::kEq};
564          }
565        }
566        return {s, MatchKind::kNe};
567      }
568    }
569    template <typename Compare>
570    bool is_ordered_correctly(field_type i, const Compare &comp) const {
571      if (std::is_base_of<BtreeTestOnlyCheckedCompareOptOutBase,
572                          Compare>::value ||
573          params_type::kIsKeyCompareStringAdapted) {
574        return true;
575      }
576      const auto compare = [&](field_type a, field_type b) {
577        const absl::weak_ordering cmp =
578            compare_internal::do_three_way_comparison(comp, key(a), key(b));
579        return cmp < 0 ? -1 : cmp > 0 ? 1 : 0;
580      };
581      int cmp = -1;
582      constexpr bool kCanHaveEquivKeys =
583          params_type::template can_have_multiple_equivalent_keys<key_type>();
584      for (field_type j = start(); j < finish(); ++j) {
585        if (j == i) {
586          if (cmp > 0) return false;
587          continue;
588        }
589        int new_cmp = compare(j, i);
590        if (new_cmp < cmp || (!kCanHaveEquivKeys && new_cmp == 0)) return false;
591        cmp = new_cmp;
592      }
593      return true;
594    }
595    template <typename... Args>
596    void emplace_value(field_type i, allocator_type *alloc, Args &&...args);
597    void remove_values(field_type i, field_type to_erase, allocator_type *alloc);
598    void rebalance_right_to_left(field_type to_move, btree_node *right,
599                                 allocator_type *alloc);
600    void rebalance_left_to_right(field_type to_move, btree_node *right,
601                                 allocator_type *alloc);
602    void split(int insert_position, btree_node *dest, allocator_type *alloc);
603    void merge(btree_node *src, allocator_type *alloc);
604    void init_leaf(field_type position, field_type max_count,
605                   btree_node *parent) {
606      set_generation(0);
607      set_parent(parent);
608      set_position(position);
609      set_start(0);
610      set_finish(0);
611      set_max_count(max_count);
612      absl::container_internal::SanitizerPoisonMemoryRegion(
613          start_slot(), max_count * sizeof(slot_type));
614    }
615    void init_internal(field_type position, btree_node *parent) {
616      init_leaf(position, kNodeSlots, parent);
617      set_max_count(kInternalNodeMaxCount);
618      absl::container_internal::SanitizerPoisonMemoryRegion(
619          &mutable_child(start()), (kNodeSlots + 1) * sizeof(btree_node *));
620    }
621    static void deallocate(const size_type size, btree_node *node,
622                           allocator_type *alloc) {
623      absl::container_internal::SanitizerUnpoisonMemoryRegion(node, size);
624      absl::container_internal::Deallocate<Alignment()>(alloc, node, size);
625    }
626    static void clear_and_delete(btree_node *node, allocator_type *alloc);
627   private:
628    template <typename... Args>
629    void value_init(const field_type i, allocator_type *alloc, Args &&...args) {
630      next_generation();
631      absl::container_internal::SanitizerUnpoisonObject(slot(i));
632      params_type::construct(alloc, slot(i), std::forward<Args>(args)...);
633    }
634    void value_destroy(const field_type i, allocator_type *alloc) {
635      next_generation();
636      params_type::destroy(alloc, slot(i));
637      absl::container_internal::SanitizerPoisonObject(slot(i));
638    }
639    void value_destroy_n(const field_type i, const field_type n,
640                         allocator_type *alloc) {
641      next_generation();
642      for (slot_type *s = slot(i), *end = slot(i + n); s != end; ++s) {
643        params_type::destroy(alloc, s);
644        absl::container_internal::SanitizerPoisonObject(s);
645      }
646    }
647    static void transfer(slot_type *dest, slot_type *src, allocator_type *alloc) {
648      absl::container_internal::SanitizerUnpoisonObject(dest);
649      params_type::transfer(alloc, dest, src);
650      absl::container_internal::SanitizerPoisonObject(src);
651    }
652    void transfer(const size_type dest_i, const size_type src_i,
653                  btree_node *src_node, allocator_type *alloc) {
654      next_generation();
655      transfer(slot(dest_i), src_node->slot(src_i), alloc);
656    }
657    void transfer_n(const size_type n, const size_type dest_i,
658                    const size_type src_i, btree_node *src_node,
659                    allocator_type *alloc) {
660      next_generation();
661      for (slot_type *src = src_node->slot(src_i), *end = src + n,
662                     *dest = slot(dest_i);
663           src != end; ++src, ++dest) {
664        transfer(dest, src, alloc);
665      }
666    }
667    void transfer_n_backward(const size_type n, const size_type dest_i,
668                             const size_type src_i, btree_node *src_node,
669                             allocator_type *alloc) {
670      next_generation();
671      for (slot_type *src = src_node->slot(src_i + n), *end = src - n,
672                     *dest = slot(dest_i + n);
673           src != end; --src, --dest) {
674        transfer(dest - 1, src - 1, alloc);
675      }
676    }
677    template <typename P>
678    friend class btree;
679    template <typename N, typename R, typename P>
680    friend class btree_iterator;
681    friend class BtreeNodePeer;
682    friend struct btree_access;
683  };
684  template <typename Node>
685  bool AreNodesFromSameContainer(const Node *node_a, const Node *node_b) {
686    if (node_a == nullptr || node_b == nullptr) return true;
687    while (!node_a->is_root()) node_a = node_a->parent();
688    while (!node_b->is_root()) node_b = node_b->parent();
689    return node_a == node_b;
690  }
691  class btree_iterator_generation_info_enabled {
692   public:
693    explicit btree_iterator_generation_info_enabled(uint32_t g)
694        : generation_(g) {}
695    template <typename Node>
696    void update_generation(const Node *node) {
697      if (node != nullptr) generation_ = node->generation();
698    }
699    uint32_t generation() const { return generation_; }
700    template <typename Node>
701    void assert_valid_generation(const Node *node) const {
702      if (node != nullptr && node->generation() != generation_) {
703        ABSL_INTERNAL_LOG(
704            FATAL,
705            "Attempting to use an invalidated iterator. The corresponding b-tree "
706            "container has been mutated since this iterator was constructed.");
707      }
708    }
709   private:
710    uint32_t generation_;
711  };
712  class btree_iterator_generation_info_disabled {
713   public:
714    explicit btree_iterator_generation_info_disabled(uint32_t) {}
715    static void update_generation(const void *) {}
716    static uint32_t generation() { return 0; }
717    static void assert_valid_generation(const void *) {}
718  };
719  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
720  using btree_iterator_generation_info = btree_iterator_generation_info_enabled;
721  #else
722  using btree_iterator_generation_info = btree_iterator_generation_info_disabled;
723  #endif
724  template <typename Node, typename Reference, typename Pointer>
725  class btree_iterator : private btree_iterator_generation_info {
726    using field_type = typename Node::field_type;
727    using key_type = typename Node::key_type;
728    using size_type = typename Node::size_type;
729    using params_type = typename Node::params_type;
730    using is_map_container = typename params_type::is_map_container;
731    using node_type = Node;
732    using normal_node = typename std::remove_const<Node>::type;
733    using const_node = const Node;
734    using normal_pointer = typename params_type::pointer;
735    using normal_reference = typename params_type::reference;
736    using const_pointer = typename params_type::const_pointer;
737    using const_reference = typename params_type::const_reference;
738    using slot_type = typename params_type::slot_type;
739    using iterator =
740       btree_iterator<normal_node, normal_reference, normal_pointer>;
741    using const_iterator =
742        btree_iterator<const_node, const_reference, const_pointer>;
743   public:
744    using difference_type = typename Node::difference_type;
745    using value_type = typename params_type::value_type;
746    using pointer = Pointer;
747    using reference = Reference;
748    using iterator_category = std::bidirectional_iterator_tag;
749    btree_iterator() : btree_iterator(nullptr, -1) {}
750    explicit btree_iterator(Node *n) : btree_iterator(n, n->start()) {}
751    btree_iterator(Node *n, int p)
752        : btree_iterator_generation_info(n != nullptr ? n->generation()
753                                                      : ~uint32_t{}),
754          node_(n),
755          position_(p) {}
756    template <typename N, typename R, typename P,
757              absl::enable_if_t<
758                  std::is_same<btree_iterator<N, R, P>, iterator>::value &&
759                      std::is_same<btree_iterator, const_iterator>::value,
760                  int> = 0>
761    btree_iterator(const btree_iterator<N, R, P> other)  
762        : btree_iterator_generation_info(other),
763          node_(other.node_),
764          position_(other.position_) {}
765    bool operator==(const iterator &other) const {
766      return Equals(other);
767    }
768    bool operator==(const const_iterator &other) const {
769      return Equals(other);
770    }
771    bool operator!=(const iterator &other) const {
772      return !Equals(other);
773    }
774    bool operator!=(const const_iterator &other) const {
775      return !Equals(other);
776    }
777    difference_type operator-(const_iterator other) const {
778      if (node_ == other.node_) {
779        if (node_->is_leaf()) return position_ - other.position_;
780        if (position_ == other.position_) return 0;
781      }
782      return distance_slow(other);
783    }
784    reference operator*() const {
785      ABSL_HARDENING_ASSERT(node_ != nullptr);
786      assert_valid_generation(node_);
787      ABSL_HARDENING_ASSERT(position_ >= node_->start());
788      if (position_ >= node_->finish()) {
789        ABSL_HARDENING_ASSERT(!IsEndIterator() && "Dereferencing end() iterator");
790        ABSL_HARDENING_ASSERT(position_ < node_->finish());
791      }
792      return node_->value(static_cast<field_type>(position_));
793    }
794    pointer operator->() const { return &operator*(); }
795    btree_iterator &operator++() {
796      increment();
797      return *this;
798    }
799    btree_iterator &operator--() {
800      decrement();
801      return *this;
802    }
803    btree_iterator operator++(int) {
804      btree_iterator tmp = *this;
805      ++*this;
806      return tmp;
807    }
808    btree_iterator operator--(int) {
809      btree_iterator tmp = *this;
810      --*this;
811      return tmp;
812    }
813   private:
814    friend iterator;
815    friend const_iterator;
816    template <typename Params>
817    friend class btree;
818    template <typename Tree>
819    friend class btree_container;
820    template <typename Tree>
821    friend class btree_set_container;
822    template <typename Tree>
823    friend class btree_map_container;
824    template <typename Tree>
825    friend class btree_multiset_container;
826    template <typename TreeType, typename CheckerType>
827    friend class base_checker;
828    friend struct btree_access;
829    template <typename N, typename R, typename P,
830              absl::enable_if_t<
831                  std::is_same<btree_iterator<N, R, P>, const_iterator>::value &&
832                      std::is_same<btree_iterator, iterator>::value,
833                  int> = 0>
834    explicit btree_iterator(const btree_iterator<N, R, P> other)
835        : btree_iterator_generation_info(other.generation()),
836          node_(const_cast<node_type *>(other.node_)),
837          position_(other.position_) {}
838    bool Equals(const const_iterator other) const {
839      ABSL_HARDENING_ASSERT(((node_ == nullptr && other.node_ == nullptr) ||
840                             (node_ != nullptr && other.node_ != nullptr)) &&
841                            "Comparing default-constructed iterator with "
842                            "non-default-constructed iterator.");
843      assert(AreNodesFromSameContainer(node_, other.node_) &&
844             "Comparing iterators from different containers.");
845      assert_valid_generation(node_);
846      other.assert_valid_generation(other.node_);
847      return node_ == other.node_ && position_ == other.position_;
848    }
849    bool IsEndIterator() const {
850      if (position_ != node_->finish()) return false;
851      node_type *node = node_;
852      while (!node->is_root()) {
853        if (node->position() != node->parent()->finish()) return false;
854        node = node->parent();
855      }
856      return true;
857    }
858    difference_type distance_slow(const_iterator other) const;
859    void increment() {
860      assert_valid_generation(node_);
861      if (node_->is_leaf() && ++position_ < node_->finish()) {
862        return;
863      }
864      increment_slow();
865    }
866    void increment_slow();
867    void decrement() {
868      assert_valid_generation(node_);
869      if (node_->is_leaf() && --position_ >= node_->start()) {
870        return;
871      }
872      decrement_slow();
873    }
874    void decrement_slow();
875    const key_type &key() const {
876      return node_->key(static_cast<size_type>(position_));
877    }
878    decltype(std::declval<Node *>()->slot(0)) slot() {
879      return node_->slot(static_cast<size_type>(position_));
880    }
881    void update_generation() {
882      btree_iterator_generation_info::update_generation(node_);
883    }
884    Node *node_;
885    int position_;
886  };
887  template <typename Params>
888  class btree {
889    using node_type = btree_node<Params>;
890    using is_key_compare_to = typename Params::is_key_compare_to;
891    using field_type = typename node_type::field_type;
892    struct alignas(node_type::Alignment()) EmptyNodeType : node_type {
893      using field_type = typename node_type::field_type;
894      node_type *parent;
895  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
896      uint32_t generation = 0;
897  #endif
898      field_type position = 0;
899      field_type start = 0;
900      field_type finish = 0;
901      field_type max_count = node_type::kInternalNodeMaxCount + 1;
902  #ifdef _MSC_VER
903      EmptyNodeType() : parent(this) {}
904  #else
905      explicit constexpr EmptyNodeType(node_type *p) : parent(p) {}
906  #endif
907    };
908    static node_type *EmptyNode() {
909  #ifdef _MSC_VER
910      static EmptyNodeType *empty_node = new EmptyNodeType;
911      assert(empty_node->parent == empty_node);
912      return empty_node;
913  #else
914      static constexpr EmptyNodeType empty_node(
915          const_cast<EmptyNodeType *>(&empty_node));
916      return const_cast<EmptyNodeType *>(&empty_node);
917  #endif
918    }
919    enum : uint32_t {
920      kNodeSlots = node_type::kNodeSlots,
921      kMinNodeValues = kNodeSlots / 2,
922    };
923    struct node_stats {
924      using size_type = typename Params::size_type;
925      node_stats(size_type l, size_type i) : leaf_nodes(l), internal_nodes(i) {}
926      node_stats &operator+=(const node_stats &other) {
927        leaf_nodes += other.leaf_nodes;
928        internal_nodes += other.internal_nodes;
929        return *this;
930      }
931      size_type leaf_nodes;
932      size_type internal_nodes;
933    };
934   public:
935    using key_type = typename Params::key_type;
936    using value_type = typename Params::value_type;
937    using size_type = typename Params::size_type;
938    using difference_type = typename Params::difference_type;
939    using key_compare = typename Params::key_compare;
940    using original_key_compare = typename Params::original_key_compare;
941    using value_compare = typename Params::value_compare;
942    using allocator_type = typename Params::allocator_type;
943    using reference = typename Params::reference;
944    using const_reference = typename Params::const_reference;
945    using pointer = typename Params::pointer;
946    using const_pointer = typename Params::const_pointer;
947    using iterator =
948        typename btree_iterator<node_type, reference, pointer>::iterator;
949    using const_iterator = typename iterator::const_iterator;
950    using reverse_iterator = std::reverse_iterator<iterator>;
951    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
952    using node_handle_type = node_handle<Params, Params, allocator_type>;
953    using params_type = Params;
954    using slot_type = typename Params::slot_type;
955   private:
956    template <typename Btree>
957    void copy_or_move_values_in_order(Btree &other);
958    constexpr static bool static_assert_validation();
959   public:
960    btree(const key_compare &comp, const allocator_type &alloc)
961        : root_(EmptyNode()), rightmost_(comp, alloc, EmptyNode()), size_(0) {}
962    btree(const btree &other) : btree(other, other.allocator()) {}
963    btree(const btree &other, const allocator_type &alloc)
964        : btree(other.key_comp(), alloc) {
965      copy_or_move_values_in_order(other);
966    }
967    btree(btree &&other) noexcept
968        : root_(absl::exchange(other.root_, EmptyNode())),
969          rightmost_(std::move(other.rightmost_)),
970          size_(absl::exchange(other.size_, 0u)) {
971      other.mutable_rightmost() = EmptyNode();
972    }
973    btree(btree &&other, const allocator_type &alloc)
974        : btree(other.key_comp(), alloc) {
975      if (alloc == other.allocator()) {
976        swap(other);
977      } else {
978        copy_or_move_values_in_order(other);
979      }
980    }
981    ~btree() {
982      static_assert(static_assert_validation(), "This call must be elided.");
983      clear();
984    }
985    btree &operator=(const btree &other);
986    btree &operator=(btree &&other) noexcept;
987    iterator begin() { return iterator(leftmost()); }
988    const_iterator begin() const { return const_iterator(leftmost()); }
989    iterator end() { return iterator(rightmost(), rightmost()->finish()); }
990    const_iterator end() const {
991      return const_iterator(rightmost(), rightmost()->finish());
992    }
993    reverse_iterator rbegin() { return reverse_iterator(end()); }
994    const_reverse_iterator rbegin() const {
995      return const_reverse_iterator(end());
996    }
997    reverse_iterator rend() { return reverse_iterator(begin()); }
998    const_reverse_iterator rend() const {
999      return const_reverse_iterator(begin());
1000    }
1001    template <typename K>
1002    iterator lower_bound(const K &key) {
1003      return internal_end(internal_lower_bound(key).value);
1004    }
1005    template <typename K>
1006    const_iterator lower_bound(const K &key) const {
1007      return internal_end(internal_lower_bound(key).value);
1008    }
1009    template <typename K>
1010    std::pair<iterator, bool> lower_bound_equal(const K &key) const;
1011    template <typename K>
1012    iterator upper_bound(const K &key) {
1013      return internal_end(internal_upper_bound(key));
1014    }
1015    template <typename K>
1016    const_iterator upper_bound(const K &key) const {
1017      return internal_end(internal_upper_bound(key));
1018    }
1019    template <typename K>
1020    std::pair<iterator, iterator> equal_range(const K &key);
1021    template <typename K>
1022    std::pair<const_iterator, const_iterator> equal_range(const K &key) const {
1023      return const_cast<btree *>(this)->equal_range(key);
1024    }
1025    template <typename K, typename... Args>
1026    std::pair<iterator, bool> insert_unique(const K &key, Args &&...args);
1027    template <typename K, typename... Args>
1028    std::pair<iterator, bool> insert_hint_unique(iterator position, const K &key,
1029                                                 Args &&...args);
1030    template <typename InputIterator,
1031              typename = decltype(std::declval<const key_compare &>()(
1032                  params_type::key(*std::declval<InputIterator>()),
1033                  std::declval<const key_type &>()))>
1034    void insert_iterator_unique(InputIterator b, InputIterator e, int);
1035    template <typename InputIterator>
1036    void insert_iterator_unique(InputIterator b, InputIterator e, char);
1037    template <typename ValueType>
1038    iterator insert_multi(const key_type &key, ValueType &&v);
1039    template <typename ValueType>
1040    iterator insert_multi(ValueType &&v) {
1041      return insert_multi(params_type::key(v), std::forward<ValueType>(v));
1042    }
1043    template <typename ValueType>
1044    iterator insert_hint_multi(iterator position, ValueType &&v);
1045    template <typename InputIterator>
1046    void insert_iterator_multi(InputIterator b,
1047                               InputIterator e);
1048    iterator erase(iterator iter);
1049    std::pair<size_type, iterator> erase_range(iterator begin, iterator end);
1050    template <typename K>
1051    iterator find(const K &key) {
1052      return internal_end(internal_find(key));
1053    }
1054    template <typename K>
<span onclick='openModal()' class='match'>1055    const_iterator find(const K &key) const {
1056      return internal_end(internal_find(key));
1057    }
1058    void clear();
1059    void swap(btree &other);
1060    const key_compare &key_comp() const noexcept {
1061      return rightmost_.template get<0>();
</span>1062    }
1063    template <typename K1, typename K2>
1064    bool compare_keys(const K1 &a, const K2 &b) const {
1065      return compare_internal::compare_result_as_less_than(key_comp()(a, b));
1066    }
1067    value_compare value_comp() const {
1068      return value_compare(original_key_compare(key_comp()));
1069    }
1070    void verify() const;
1071    size_type size() const { return size_; }
1072    size_type max_size() const { return (std::numeric_limits<size_type>::max)(); }
1073    bool empty() const { return size_ == 0; }
1074    size_type height() const {
1075      size_type h = 0;
1076      if (!empty()) {
1077        const node_type *n = root();
1078        do {
1079          ++h;
1080          n = n->parent();
1081        } while (n != root());
1082      }
1083      return h;
1084    }
1085    size_type leaf_nodes() const { return internal_stats(root()).leaf_nodes; }
1086    size_type internal_nodes() const {
1087      return internal_stats(root()).internal_nodes;
1088    }
1089    size_type nodes() const {
1090      node_stats stats = internal_stats(root());
1091      return stats.leaf_nodes + stats.internal_nodes;
1092    }
1093    size_type bytes_used() const {
1094      node_stats stats = internal_stats(root());
1095      if (stats.leaf_nodes == 1 && stats.internal_nodes == 0) {
1096        return sizeof(*this) + node_type::LeafSize(root()->max_count());
1097      } else {
1098        return sizeof(*this) + stats.leaf_nodes * node_type::LeafSize() +
1099               stats.internal_nodes * node_type::InternalSize();
1100      }
1101    }
1102    static double average_bytes_per_value() {
1103      const double expected_values_per_node = (kNodeSlots + kMinNodeValues) / 2.0;
1104      return node_type::LeafSize() / expected_values_per_node;
1105    }
1106    double fullness() const {
1107      if (empty()) return 0.0;
1108      return static_cast<double>(size()) / (nodes() * kNodeSlots);
1109    }
1110    double overhead() const {
1111      if (empty()) return 0.0;
1112      return (bytes_used() - size() * sizeof(value_type)) /
1113             static_cast<double>(size());
1114    }
1115    allocator_type get_allocator() const { return allocator(); }
1116   private:
1117    friend struct btree_access;
1118    node_type *root() { return root_; }
1119    const node_type *root() const { return root_; }
1120    node_type *&mutable_root() noexcept { return root_; }
1121    node_type *rightmost() { return rightmost_.template get<2>(); }
1122    const node_type *rightmost() const { return rightmost_.template get<2>(); }
1123    node_type *&mutable_rightmost() noexcept {
1124      return rightmost_.template get<2>();
1125    }
1126    key_compare *mutable_key_comp() noexcept {
1127      return &rightmost_.template get<0>();
1128    }
1129    node_type *leftmost() { return root()->parent(); }
1130    const node_type *leftmost() const { return root()->parent(); }
1131    allocator_type *mutable_allocator() noexcept {
1132      return &rightmost_.template get<1>();
1133    }
1134    const allocator_type &allocator() const noexcept {
1135      return rightmost_.template get<1>();
1136    }
1137    node_type *allocate(size_type size) {
1138      return reinterpret_cast<node_type *>(
1139          absl::container_internal::Allocate<node_type::Alignment()>(
1140              mutable_allocator(), size));
1141    }
1142    node_type *new_internal_node(field_type position, node_type *parent) {
1143      node_type *n = allocate(node_type::InternalSize());
1144      n->init_internal(position, parent);
1145      return n;
1146    }
1147    node_type *new_leaf_node(field_type position, node_type *parent) {
1148      node_type *n = allocate(node_type::LeafSize());
1149      n->init_leaf(position, kNodeSlots, parent);
1150      return n;
1151    }
1152    node_type *new_leaf_root_node(field_type max_count) {
1153      node_type *n = allocate(node_type::LeafSize(max_count));
1154      n->init_leaf(&bsol;*position=*/0, max_count, &bsol;*parent=*/n);
1155      return n;
1156    }
1157    iterator rebalance_after_delete(iterator iter);
1158    void rebalance_or_split(iterator *iter);
1159    void merge_nodes(node_type *left, node_type *right);
1160    bool try_merge_or_rebalance(iterator *iter);
1161    void try_shrink();
1162    iterator internal_end(iterator iter) {
1163      return iter.node_ != nullptr ? iter : end();
1164    }
1165    const_iterator internal_end(const_iterator iter) const {
1166      return iter.node_ != nullptr ? iter : end();
1167    }
1168    template <typename... Args>
1169    iterator internal_emplace(iterator iter, Args &&...args);
1170    template <typename IterType>
1171    static IterType internal_last(IterType iter);
1172    template <typename K>
1173    SearchResult<iterator, is_key_compare_to::value> internal_locate(
1174        const K &key) const;
1175    template <typename K>
1176    SearchResult<iterator, is_key_compare_to::value> internal_lower_bound(
1177        const K &key) const;
1178    template <typename K>
1179    iterator internal_upper_bound(const K &key) const;
1180    template <typename K>
1181    iterator internal_find(const K &key) const;
1182    size_type internal_verify(const node_type *node, const key_type *lo,
1183                              const key_type *hi) const;
1184    node_stats internal_stats(const node_type *node) const {
1185      if (node == nullptr || (node == root() && empty())) {
1186        return node_stats(0, 0);
1187      }
1188      if (node->is_leaf()) {
1189        return node_stats(1, 0);
1190      }
1191      node_stats res(0, 1);
1192      for (int i = node->start(); i <= node->finish(); ++i) {
1193        res += internal_stats(node->child(i));
1194      }
1195      return res;
1196    }
1197    node_type *root_;
1198    absl::container_internal::CompressedTuple<key_compare, allocator_type,
1199                                              node_type *>
1200        rightmost_;
1201    size_type size_;
1202  };
1203  template <typename P>
1204  template <typename... Args>
1205  inline void btree_node<P>::emplace_value(const field_type i,
1206                                           allocator_type *alloc,
1207                                           Args &&...args) {
1208    assert(i >= start());
1209    assert(i <= finish());
1210    if (i < finish()) {
1211      transfer_n_backward(finish() - i, &bsol;*dest_i=*/i + 1, &bsol;*src_i=*/i, this,
1212                          alloc);
1213    }
1214    value_init(static_cast<field_type>(i), alloc, std::forward<Args>(args)...);
1215    set_finish(finish() + 1);
1216    if (is_internal() && finish() > i + 1) {
1217      for (field_type j = finish(); j > i + 1; --j) {
1218        set_child(j, child(j - 1));
1219      }
1220      clear_child(i + 1);
1221    }
1222  }
1223  template <typename P>
1224  inline void btree_node<P>::remove_values(const field_type i,
1225                                           const field_type to_erase,
1226                                           allocator_type *alloc) {
1227    value_destroy_n(i, to_erase, alloc);
1228    const field_type orig_finish = finish();
1229    const field_type src_i = i + to_erase;
1230    transfer_n(orig_finish - src_i, i, src_i, this, alloc);
1231    if (is_internal()) {
1232      for (field_type j = 0; j < to_erase; ++j) {
1233        clear_and_delete(child(i + j + 1), alloc);
1234      }
1235      for (field_type j = i + to_erase + 1; j <= orig_finish; ++j) {
1236        set_child(j - to_erase, child(j));
1237        clear_child(j);
1238      }
1239    }
1240    set_finish(orig_finish - to_erase);
1241  }
1242  template <typename P>
1243  void btree_node<P>::rebalance_right_to_left(field_type to_move,
1244                                              btree_node *right,
1245                                              allocator_type *alloc) {
1246    assert(parent() == right->parent());
1247    assert(position() + 1 == right->position());
1248    assert(right->count() >= count());
1249    assert(to_move >= 1);
1250    assert(to_move <= right->count());
1251    transfer(finish(), position(), parent(), alloc);
1252    transfer_n(to_move - 1, finish() + 1, right->start(), right, alloc);
1253    parent()->transfer(position(), right->start() + to_move - 1, right, alloc);
1254    right->transfer_n(right->count() - to_move, right->start(),
1255                      right->start() + to_move, right, alloc);
1256    if (is_internal()) {
1257      for (field_type i = 0; i < to_move; ++i) {
1258        init_child(finish() + i + 1, right->child(i));
1259      }
1260      for (field_type i = right->start(); i <= right->finish() - to_move; ++i) {
1261        assert(i + to_move <= right->max_count());
1262        right->init_child(i, right->child(i + to_move));
1263        right->clear_child(i + to_move);
1264      }
1265    }
1266    set_finish(finish() + to_move);
1267    right->set_finish(right->finish() - to_move);
1268  }
1269  template <typename P>
1270  void btree_node<P>::rebalance_left_to_right(field_type to_move,
1271                                              btree_node *right,
1272                                              allocator_type *alloc) {
1273    assert(parent() == right->parent());
1274    assert(position() + 1 == right->position());
1275    assert(count() >= right->count());
1276    assert(to_move >= 1);
1277    assert(to_move <= count());
1278    right->transfer_n_backward(right->count(), right->start() + to_move,
1279                               right->start(), right, alloc);
1280    right->transfer(right->start() + to_move - 1, position(), parent(), alloc);
1281    right->transfer_n(to_move - 1, right->start(), finish() - (to_move - 1), this,
1282                      alloc);
1283    parent()->transfer(position(), finish() - to_move, this, alloc);
1284    if (is_internal()) {
1285      for (field_type i = right->finish() + 1; i > right->start(); --i) {
1286        right->init_child(i - 1 + to_move, right->child(i - 1));
1287        right->clear_child(i - 1);
1288      }
1289      for (field_type i = 1; i <= to_move; ++i) {
1290        right->init_child(i - 1, child(finish() - to_move + i));
1291        clear_child(finish() - to_move + i);
1292      }
1293    }
1294    set_finish(finish() - to_move);
1295    right->set_finish(right->finish() + to_move);
1296  }
1297  template <typename P>
1298  void btree_node<P>::split(const int insert_position, btree_node *dest,
1299                            allocator_type *alloc) {
1300    assert(dest->count() == 0);
1301    assert(max_count() == kNodeSlots);
1302    assert(position() + 1 == dest->position());
1303    assert(parent() == dest->parent());
1304    if (insert_position == start()) {
1305      dest->set_finish(dest->start() + finish() - 1);
1306    } else if (insert_position == kNodeSlots) {
1307      dest->set_finish(dest->start());
1308    } else {
1309      dest->set_finish(dest->start() + count() / 2);
1310    }
1311    set_finish(finish() - dest->count());
1312    assert(count() >= 1);
1313    dest->transfer_n(dest->count(), dest->start(), finish(), this, alloc);
1314    --mutable_finish();
1315    parent()->emplace_value(position(), alloc, finish_slot());
1316    value_destroy(finish(), alloc);
1317    parent()->set_child_noupdate_position(position() + 1, dest);
1318    if (is_internal()) {
1319      for (field_type i = dest->start(), j = finish() + 1; i <= dest->finish();
1320           ++i, ++j) {
1321        assert(child(j) != nullptr);
1322        dest->init_child(i, child(j));
1323        clear_child(j);
1324      }
1325    }
1326  }
1327  template <typename P>
1328  void btree_node<P>::merge(btree_node *src, allocator_type *alloc) {
1329    assert(parent() == src->parent());
1330    assert(position() + 1 == src->position());
1331    value_init(finish(), alloc, parent()->slot(position()));
1332    transfer_n(src->count(), finish() + 1, src->start(), src, alloc);
1333    if (is_internal()) {
1334      for (field_type i = src->start(), j = finish() + 1; i <= src->finish();
1335           ++i, ++j) {
1336        init_child(j, src->child(i));
1337        src->clear_child(i);
1338      }
1339    }
1340    set_finish(start() + 1 + count() + src->count());
1341    src->set_finish(src->start());
1342    parent()->remove_values(position(), &bsol;*to_erase=*/1, alloc);
1343  }
1344  template <typename P>
1345  void btree_node<P>::clear_and_delete(btree_node *node, allocator_type *alloc) {
1346    if (node->is_leaf()) {
1347      node->value_destroy_n(node->start(), node->count(), alloc);
1348      deallocate(LeafSize(node->max_count()), node, alloc);
1349      return;
1350    }
1351    if (node->count() == 0) {
1352      deallocate(InternalSize(), node, alloc);
1353      return;
1354    }
1355    btree_node *delete_root_parent = node->parent();
1356    while (node->is_internal()) node = node->start_child();
1357  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1358    btree_node *leftmost_leaf = node;
1359  #endif
1360    size_type pos = node->position();
1361    btree_node *parent = node->parent();
1362    for (;;) {
1363      assert(pos <= parent->finish());
1364      do {
1365        node = parent->child(static_cast<field_type>(pos));
1366        if (node->is_internal()) {
1367          while (node->is_internal()) node = node->start_child();
1368          pos = node->position();
1369          parent = node->parent();
1370        }
1371        node->value_destroy_n(node->start(), node->count(), alloc);
1372  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1373        if (leftmost_leaf != node)
1374  #endif
1375          deallocate(LeafSize(node->max_count()), node, alloc);
1376        ++pos;
1377      } while (pos <= parent->finish());
1378      assert(pos > parent->finish());
1379      do {
1380        node = parent;
1381        pos = node->position();
1382        parent = node->parent();
1383        node->value_destroy_n(node->start(), node->count(), alloc);
1384        deallocate(InternalSize(), node, alloc);
1385        if (parent == delete_root_parent) {
1386  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1387          deallocate(LeafSize(leftmost_leaf->max_count()), leftmost_leaf, alloc);
1388  #endif
1389          return;
1390        }
1391        ++pos;
1392      } while (pos > parent->finish());
1393    }
1394  }
1395  template <typename N, typename R, typename P>
1396  auto btree_iterator<N, R, P>::distance_slow(const_iterator other) const
1397      -> difference_type {
1398    const_iterator begin = other;
1399    const_iterator end = *this;
1400    assert(begin.node_ != end.node_ || !begin.node_->is_leaf() ||
1401           begin.position_ != end.position_);
1402    const node_type *node = begin.node_;
1403    difference_type count = node->is_leaf() ? -begin.position_ : 0;
1404    if (node->is_internal()) {
1405      ++count;
1406      node = node->child(begin.position_ + 1);
1407    }
1408    while (node->is_internal()) node = node->start_child();
1409    size_type pos = node->position();
1410    const node_type *parent = node->parent();
1411    for (;;) {
1412      assert(pos <= parent->finish());
1413      do {
1414        node = parent->child(static_cast<field_type>(pos));
1415        if (node->is_internal()) {
1416          while (node->is_internal()) node = node->start_child();
1417          pos = node->position();
1418          parent = node->parent();
1419        }
1420        if (node == end.node_) return count + end.position_;
1421        if (parent == end.node_ && pos == static_cast<size_type>(end.position_))
1422          return count + node->count();
1423        count += node->count() + 1;
1424        ++pos;
1425      } while (pos <= parent->finish());
1426      assert(pos > parent->finish());
1427      do {
1428        node = parent;
1429        pos = node->position();
1430        parent = node->parent();
1431        if (parent == end.node_ && pos == static_cast<size_type>(end.position_))
1432          return count - 1;
1433        ++pos;
1434      } while (pos > parent->finish());
1435    }
1436  }
1437  template <typename N, typename R, typename P>
1438  void btree_iterator<N, R, P>::increment_slow() {
1439    if (node_->is_leaf()) {
1440      assert(position_ >= node_->finish());
1441      btree_iterator save(*this);
1442      while (position_ == node_->finish() && !node_->is_root()) {
1443        assert(node_->parent()->child(node_->position()) == node_);
1444        position_ = node_->position();
1445        node_ = node_->parent();
1446      }
1447      if (position_ == node_->finish()) {
1448        *this = save;
1449      }
1450    } else {
1451      assert(position_ < node_->finish());
1452      node_ = node_->child(static_cast<field_type>(position_ + 1));
1453      while (node_->is_internal()) {
1454        node_ = node_->start_child();
1455      }
1456      position_ = node_->start();
1457    }
1458  }
1459  template <typename N, typename R, typename P>
1460  void btree_iterator<N, R, P>::decrement_slow() {
1461    if (node_->is_leaf()) {
1462      assert(position_ <= -1);
1463      btree_iterator save(*this);
1464      while (position_ < node_->start() && !node_->is_root()) {
1465        assert(node_->parent()->child(node_->position()) == node_);
1466        position_ = node_->position() - 1;
1467        node_ = node_->parent();
1468      }
1469      if (position_ < node_->start()) {
1470        *this = save;
1471      }
1472    } else {
1473      assert(position_ >= node_->start());
1474      node_ = node_->child(static_cast<field_type>(position_));
1475      while (node_->is_internal()) {
1476        node_ = node_->child(node_->finish());
1477      }
1478      position_ = node_->finish() - 1;
1479    }
1480  }
1481  template <typename P>
1482  template <typename Btree>
1483  void btree<P>::copy_or_move_values_in_order(Btree &other) {
1484    static_assert(std::is_same<btree, Btree>::value ||
1485                      std::is_same<const btree, Btree>::value,
1486                  "Btree type must be same or const.");
1487    assert(empty());
1488    auto iter = other.begin();
1489    if (iter == other.end()) return;
1490    insert_multi(iter.slot());
1491    ++iter;
1492    for (; iter != other.end(); ++iter) {
1493      internal_emplace(end(), iter.slot());
1494    }
1495  }
1496  template <typename P>
1497  constexpr bool btree<P>::static_assert_validation() {
1498    static_assert(std::is_nothrow_copy_constructible<key_compare>::value,
1499                  "Key comparison must be nothrow copy constructible");
1500    static_assert(std::is_nothrow_copy_constructible<allocator_type>::value,
1501                  "Allocator must be nothrow copy constructible");
1502    static_assert(std::is_trivially_copyable<iterator>::value,
1503                  "iterator not trivially copyable.");
1504    static_assert(
1505        kNodeSlots < (1 << (8 * sizeof(typename node_type::field_type))),
1506        "target node size too large");
1507    static_assert(
1508        compare_has_valid_result_type<key_compare, key_type>(),
1509        "key comparison function must return absl::{weak,strong}_ordering or "
1510        "bool.");
1511    static_assert(node_type::MinimumOverhead() >= sizeof(void *) + 4,
1512                  "node space assumption incorrect");
1513    return true;
1514  }
1515  template <typename P>
1516  template <typename K>
1517  auto btree<P>::lower_bound_equal(const K &key) const
1518      -> std::pair<iterator, bool> {
1519    const SearchResult<iterator, is_key_compare_to::value> res =
1520        internal_lower_bound(key);
1521    const iterator lower = iterator(internal_end(res.value));
1522    const bool equal = res.HasMatch()
1523                           ? res.IsEq()
1524                           : lower != end() && !compare_keys(key, lower.key());
1525    return {lower, equal};
1526  }
1527  template <typename P>
1528  template <typename K>
1529  auto btree<P>::equal_range(const K &key) -> std::pair<iterator, iterator> {
1530    const std::pair<iterator, bool> lower_and_equal = lower_bound_equal(key);
1531    const iterator lower = lower_and_equal.first;
1532    if (!lower_and_equal.second) {
1533      return {lower, lower};
1534    }
1535    const iterator next = std::next(lower);
1536    if (!params_type::template can_have_multiple_equivalent_keys<K>()) {
1537      assert(next == end() || compare_keys(key, next.key()));
1538      return {lower, next};
1539    }
1540    if (next == end() || compare_keys(key, next.key())) return {lower, next};
1541    return {lower, upper_bound(key)};
1542  }
1543  template <typename P>
1544  template <typename K, typename... Args>
1545  auto btree<P>::insert_unique(const K &key, Args &&...args)
1546      -> std::pair<iterator, bool> {
1547    if (empty()) {
1548      mutable_root() = mutable_rightmost() = new_leaf_root_node(1);
1549    }
1550    SearchResult<iterator, is_key_compare_to::value> res = internal_locate(key);
1551    iterator iter = res.value;
1552    if (res.HasMatch()) {
1553      if (res.IsEq()) {
1554        return {iter, false};
1555      }
1556    } else {
1557      iterator last = internal_last(iter);
1558      if (last.node_ && !compare_keys(key, last.key())) {
1559        return {last, false};
1560      }
1561    }
1562    return {internal_emplace(iter, std::forward<Args>(args)...), true};
1563  }
1564  template <typename P>
1565  template <typename K, typename... Args>
1566  inline auto btree<P>::insert_hint_unique(iterator position, const K &key,
1567                                           Args &&...args)
1568      -> std::pair<iterator, bool> {
1569    if (!empty()) {
1570      if (position == end() || compare_keys(key, position.key())) {
1571        if (position == begin() || compare_keys(std::prev(position).key(), key)) {
1572          return {internal_emplace(position, std::forward<Args>(args)...), true};
1573        }
1574      } else if (compare_keys(position.key(), key)) {
1575        ++position;
1576        if (position == end() || compare_keys(key, position.key())) {
1577          return {internal_emplace(position, std::forward<Args>(args)...), true};
1578        }
1579      } else {
1580        return {position, false};
1581      }
1582    }
1583    return insert_unique(key, std::forward<Args>(args)...);
1584  }
1585  template <typename P>
1586  template <typename InputIterator, typename>
1587  void btree<P>::insert_iterator_unique(InputIterator b, InputIterator e, int) {
1588    for (; b != e; ++b) {
1589      insert_hint_unique(end(), params_type::key(*b), *b);
1590    }
1591  }
1592  template <typename P>
1593  template <typename InputIterator>
1594  void btree<P>::insert_iterator_unique(InputIterator b, InputIterator e, char) {
1595    for (; b != e; ++b) {
1596      auto node_handle =
1597          CommonAccess::Construct<node_handle_type>(get_allocator(), *b);
1598      slot_type *slot = CommonAccess::GetSlot(node_handle);
1599      insert_hint_unique(end(), params_type::key(slot), slot);
1600    }
1601  }
1602  template <typename P>
1603  template <typename ValueType>
1604  auto btree<P>::insert_multi(const key_type &key, ValueType &&v) -> iterator {
1605    if (empty()) {
1606      mutable_root() = mutable_rightmost() = new_leaf_root_node(1);
1607    }
1608    iterator iter = internal_upper_bound(key);
1609    if (iter.node_ == nullptr) {
1610      iter = end();
1611    }
1612    return internal_emplace(iter, std::forward<ValueType>(v));
1613  }
1614  template <typename P>
1615  template <typename ValueType>
1616  auto btree<P>::insert_hint_multi(iterator position, ValueType &&v) -> iterator {
1617    if (!empty()) {
1618      const key_type &key = params_type::key(v);
1619      if (position == end() || !compare_keys(position.key(), key)) {
1620        if (position == begin() ||
1621            !compare_keys(key, std::prev(position).key())) {
1622          return internal_emplace(position, std::forward<ValueType>(v));
1623        }
1624      } else {
1625        ++position;
1626        if (position == end() || !compare_keys(position.key(), key)) {
1627          return internal_emplace(position, std::forward<ValueType>(v));
1628        }
1629      }
1630    }
1631    return insert_multi(std::forward<ValueType>(v));
1632  }
1633  template <typename P>
1634  template <typename InputIterator>
1635  void btree<P>::insert_iterator_multi(InputIterator b, InputIterator e) {
1636    for (; b != e; ++b) {
1637      insert_hint_multi(end(), *b);
1638    }
1639  }
1640  template <typename P>
1641  auto btree<P>::operator=(const btree &other) -> btree & {
1642    if (this != &other) {
1643      clear();
1644      *mutable_key_comp() = other.key_comp();
1645      if (absl::allocator_traits<
1646              allocator_type>::propagate_on_container_copy_assignment::value) {
1647        *mutable_allocator() = other.allocator();
1648      }
1649      copy_or_move_values_in_order(other);
1650    }
1651    return *this;
1652  }
1653  template <typename P>
1654  auto btree<P>::operator=(btree &&other) noexcept -> btree & {
1655    if (this != &other) {
1656      clear();
1657      using std::swap;
1658      if (absl::allocator_traits<
1659              allocator_type>::propagate_on_container_copy_assignment::value) {
1660        swap(root_, other.root_);
1661        swap(rightmost_, other.rightmost_);
1662        swap(size_, other.size_);
1663      } else {
1664        if (allocator() == other.allocator()) {
1665          swap(mutable_root(), other.mutable_root());
1666          swap(*mutable_key_comp(), *other.mutable_key_comp());
1667          swap(mutable_rightmost(), other.mutable_rightmost());
1668          swap(size_, other.size_);
1669        } else {
1670          *mutable_key_comp() = other.key_comp();
1671          copy_or_move_values_in_order(other);
1672        }
1673      }
1674    }
1675    return *this;
1676  }
1677  template <typename P>
1678  auto btree<P>::erase(iterator iter) -> iterator {
1679    iter.node_->value_destroy(static_cast<field_type>(iter.position_),
1680                              mutable_allocator());
1681    iter.update_generation();
1682    const bool internal_delete = iter.node_->is_internal();
1683    if (internal_delete) {
1684      iterator internal_iter(iter);
1685      --iter;
1686      assert(iter.node_->is_leaf());
1687      internal_iter.node_->transfer(
1688          static_cast<size_type>(internal_iter.position_),
1689          static_cast<size_type>(iter.position_), iter.node_,
1690          mutable_allocator());
1691    } else {
1692      const field_type transfer_from =
1693          static_cast<field_type>(iter.position_ + 1);
1694      const field_type num_to_transfer = iter.node_->finish() - transfer_from;
1695      iter.node_->transfer_n(num_to_transfer,
1696                             static_cast<size_type>(iter.position_),
1697                             transfer_from, iter.node_, mutable_allocator());
1698    }
1699    iter.node_->set_finish(iter.node_->finish() - 1);
1700    --size_;
1701    iterator res = rebalance_after_delete(iter);
1702    if (internal_delete) {
1703      ++res;
1704    }
1705    return res;
1706  }
1707  template <typename P>
1708  auto btree<P>::rebalance_after_delete(iterator iter) -> iterator {
1709    iterator res(iter);
1710    bool first_iteration = true;
1711    for (;;) {
1712      if (iter.node_ == root()) {
1713        try_shrink();
1714        if (empty()) {
1715          return end();
1716        }
1717        break;
1718      }
1719      if (iter.node_->count() >= kMinNodeValues) {
1720        break;
1721      }
1722      bool merged = try_merge_or_rebalance(&iter);
1723      if (first_iteration) {
1724        res = iter;
1725        first_iteration = false;
1726      }
1727      if (!merged) {
1728        break;
1729      }
1730      iter.position_ = iter.node_->position();
1731      iter.node_ = iter.node_->parent();
1732    }
1733    res.update_generation();
1734    if (res.position_ == res.node_->finish()) {
1735      res.position_ = res.node_->finish() - 1;
1736      ++res;
1737    }
1738    return res;
1739  }
1740  template <typename P>
1741  auto btree<P>::erase_range(iterator begin, iterator end)
1742      -> std::pair<size_type, iterator> {
1743    size_type count = static_cast<size_type>(end - begin);
1744    assert(count >= 0);
1745    if (count == 0) {
1746      return {0, begin};
1747    }
1748    if (static_cast<size_type>(count) == size_) {
1749      clear();
1750      return {count, this->end()};
1751    }
1752    if (begin.node_ == end.node_) {
1753      assert(end.position_ > begin.position_);
1754      begin.node_->remove_values(
1755          static_cast<field_type>(begin.position_),
1756          static_cast<field_type>(end.position_ - begin.position_),
1757          mutable_allocator());
1758      size_ -= count;
1759      return {count, rebalance_after_delete(begin)};
1760    }
1761    const size_type target_size = size_ - count;
1762    while (size_ > target_size) {
1763      if (begin.node_->is_leaf()) {
1764        const size_type remaining_to_erase = size_ - target_size;
1765        const size_type remaining_in_node =
1766            static_cast<size_type>(begin.node_->finish() - begin.position_);
1767        const field_type to_erase = static_cast<field_type>(
1768            (std::min)(remaining_to_erase, remaining_in_node));
1769        begin.node_->remove_values(static_cast<field_type>(begin.position_),
1770                                   to_erase, mutable_allocator());
1771        size_ -= to_erase;
1772        begin = rebalance_after_delete(begin);
1773      } else {
1774        begin = erase(begin);
1775      }
1776    }
1777    begin.update_generation();
1778    return {count, begin};
1779  }
1780  template <typename P>
1781  void btree<P>::clear() {
1782    if (!empty()) {
1783      node_type::clear_and_delete(root(), mutable_allocator());
1784    }
1785    mutable_root() = mutable_rightmost() = EmptyNode();
1786    size_ = 0;
1787  }
1788  template <typename P>
1789  void btree<P>::swap(btree &other) {
1790    using std::swap;
1791    if (absl::allocator_traits<
1792            allocator_type>::propagate_on_container_swap::value) {
1793      swap(rightmost_, other.rightmost_);
1794    } else {
1795      assert(allocator() == other.allocator());
1796      swap(mutable_rightmost(), other.mutable_rightmost());
1797      swap(*mutable_key_comp(), *other.mutable_key_comp());
1798    }
1799    swap(mutable_root(), other.mutable_root());
1800    swap(size_, other.size_);
1801  }
1802  template <typename P>
1803  void btree<P>::verify() const {
1804    assert(root() != nullptr);
1805    assert(leftmost() != nullptr);
1806    assert(rightmost() != nullptr);
1807    assert(empty() || size() == internal_verify(root(), nullptr, nullptr));
1808    assert(leftmost() == (++const_iterator(root(), -1)).node_);
1809    assert(rightmost() == (--const_iterator(root(), root()->finish())).node_);
1810    assert(leftmost()->is_leaf());
1811    assert(rightmost()->is_leaf());
1812  }
1813  template <typename P>
1814  void btree<P>::rebalance_or_split(iterator *iter) {
1815    node_type *&node = iter->node_;
1816    int &insert_position = iter->position_;
1817    assert(node->count() == node->max_count());
1818    assert(kNodeSlots == node->max_count());
1819    node_type *parent = node->parent();
1820    if (node != root()) {
1821      if (node->position() > parent->start()) {
1822        node_type *left = parent->child(node->position() - 1);
1823        assert(left->max_count() == kNodeSlots);
1824        if (left->count() < kNodeSlots) {
1825          field_type to_move =
1826              (kNodeSlots - left->count()) /
1827              (1 + (static_cast<field_type>(insert_position) < kNodeSlots));
1828          to_move = (std::max)(field_type{1}, to_move);
1829          if (static_cast<field_type>(insert_position) - to_move >=
1830                  node->start() ||
1831              left->count() + to_move < kNodeSlots) {
1832            left->rebalance_right_to_left(to_move, node, mutable_allocator());
1833            assert(node->max_count() - node->count() == to_move);
1834            insert_position = static_cast<int>(
1835                static_cast<field_type>(insert_position) - to_move);
1836            if (insert_position < node->start()) {
1837              insert_position = insert_position + left->count() + 1;
1838              node = left;
1839            }
1840            assert(node->count() < node->max_count());
1841            return;
1842          }
1843        }
1844      }
1845      if (node->position() < parent->finish()) {
1846        node_type *right = parent->child(node->position() + 1);
1847        assert(right->max_count() == kNodeSlots);
1848        if (right->count() < kNodeSlots) {
1849          field_type to_move = (kNodeSlots - right->count()) /
1850                               (1 + (insert_position > node->start()));
1851          to_move = (std::max)(field_type{1}, to_move);
1852          if (static_cast<field_type>(insert_position) <=
1853                  node->finish() - to_move ||
1854              right->count() + to_move < kNodeSlots) {
1855            node->rebalance_left_to_right(to_move, right, mutable_allocator());
1856            if (insert_position > node->finish()) {
1857              insert_position = insert_position - node->count() - 1;
1858              node = right;
1859            }
1860            assert(node->count() < node->max_count());
1861            return;
1862          }
1863        }
1864      }
1865      assert(parent->max_count() == kNodeSlots);
1866      if (parent->count() == kNodeSlots) {
1867        iterator parent_iter(parent, node->position());
1868        rebalance_or_split(&parent_iter);
1869        parent = node->parent();
1870      }
1871    } else {
1872      parent = new_internal_node(&bsol;*position=*/0, parent);
1873      parent->set_generation(root()->generation());
1874      parent->init_child(parent->start(), node);
1875      mutable_root() = parent;
1876      assert(parent->start_child()->is_internal() ||
1877             parent->start_child() == rightmost());
1878    }
1879    node_type *split_node;
1880    if (node->is_leaf()) {
1881      split_node = new_leaf_node(node->position() + 1, parent);
1882      node->split(insert_position, split_node, mutable_allocator());
1883      if (rightmost() == node) mutable_rightmost() = split_node;
1884    } else {
1885      split_node = new_internal_node(node->position() + 1, parent);
1886      node->split(insert_position, split_node, mutable_allocator());
1887    }
1888    if (insert_position > node->finish()) {
1889      insert_position = insert_position - node->count() - 1;
1890      node = split_node;
1891    }
1892  }
1893  template <typename P>
1894  void btree<P>::merge_nodes(node_type *left, node_type *right) {
1895    left->merge(right, mutable_allocator());
1896    if (rightmost() == right) mutable_rightmost() = left;
1897  }
1898  template <typename P>
1899  bool btree<P>::try_merge_or_rebalance(iterator *iter) {
1900    node_type *parent = iter->node_->parent();
1901    if (iter->node_->position() > parent->start()) {
1902      node_type *left = parent->child(iter->node_->position() - 1);
1903      assert(left->max_count() == kNodeSlots);
1904      if (1U + left->count() + iter->node_->count() <= kNodeSlots) {
1905        iter->position_ += 1 + left->count();
1906        merge_nodes(left, iter->node_);
1907        iter->node_ = left;
1908        return true;
1909      }
1910    }
1911    if (iter->node_->position() < parent->finish()) {
1912      node_type *right = parent->child(iter->node_->position() + 1);
1913      assert(right->max_count() == kNodeSlots);
1914      if (1U + iter->node_->count() + right->count() <= kNodeSlots) {
1915        merge_nodes(iter->node_, right);
1916        return true;
1917      }
1918      if (right->count() > kMinNodeValues &&
1919          (iter->node_->count() == 0 || iter->position_ > iter->node_->start())) {
1920        field_type to_move = (right->count() - iter->node_->count()) / 2;
1921        to_move =
1922            (std::min)(to_move, static_cast<field_type>(right->count() - 1));
1923        iter->node_->rebalance_right_to_left(to_move, right, mutable_allocator());
1924        return false;
1925      }
1926    }
1927    if (iter->node_->position() > parent->start()) {
1928      node_type *left = parent->child(iter->node_->position() - 1);
1929      if (left->count() > kMinNodeValues &&
1930          (iter->node_->count() == 0 ||
1931           iter->position_ < iter->node_->finish())) {
1932        field_type to_move = (left->count() - iter->node_->count()) / 2;
1933        to_move = (std::min)(to_move, static_cast<field_type>(left->count() - 1));
1934        left->rebalance_left_to_right(to_move, iter->node_, mutable_allocator());
1935        iter->position_ += to_move;
1936        return false;
1937      }
1938    }
1939    return false;
1940  }
1941  template <typename P>
1942  void btree<P>::try_shrink() {
1943    node_type *orig_root = root();
1944    if (orig_root->count() > 0) {
1945      return;
1946    }
1947    if (orig_root->is_leaf()) {
1948      assert(size() == 0);
1949      mutable_root() = mutable_rightmost() = EmptyNode();
1950    } else {
1951      node_type *child = orig_root->start_child();
1952      child->make_root();
1953      mutable_root() = child;
1954    }
1955    node_type::clear_and_delete(orig_root, mutable_allocator());
1956  }
1957  template <typename P>
1958  template <typename IterType>
1959  inline IterType btree<P>::internal_last(IterType iter) {
1960    assert(iter.node_ != nullptr);
1961    while (iter.position_ == iter.node_->finish()) {
1962      iter.position_ = iter.node_->position();
1963      iter.node_ = iter.node_->parent();
1964      if (iter.node_->is_leaf()) {
1965        iter.node_ = nullptr;
1966        break;
1967      }
1968    }
1969    iter.update_generation();
1970    return iter;
1971  }
1972  template <typename P>
1973  template <typename... Args>
1974  inline auto btree<P>::internal_emplace(iterator iter, Args &&...args)
1975      -> iterator {
1976    if (iter.node_->is_internal()) {
1977      --iter;
1978      ++iter.position_;
1979    }
1980    const field_type max_count = iter.node_->max_count();
1981    allocator_type *alloc = mutable_allocator();
1982    const auto transfer_and_delete = [&](node_type *old_node,
1983                                         node_type *new_node) {
1984      new_node->transfer_n(old_node->count(), new_node->start(),
1985                           old_node->start(), old_node, alloc);
1986      new_node->set_finish(old_node->finish());
1987      old_node->set_finish(old_node->start());
1988      new_node->set_generation(old_node->generation());
1989      node_type::clear_and_delete(old_node, alloc);
1990    };
1991    const auto replace_leaf_root_node = [&](field_type new_node_size) {
1992      assert(iter.node_ == root());
1993      node_type *old_root = iter.node_;
1994      node_type *new_root = iter.node_ = new_leaf_root_node(new_node_size);
1995      transfer_and_delete(old_root, new_root);
1996      mutable_root() = mutable_rightmost() = new_root;
1997    };
1998    bool replaced_node = false;
1999    if (iter.node_->count() == max_count) {
2000      if (max_count < kNodeSlots) {
2001        replace_leaf_root_node(static_cast<field_type>(
2002            (std::min)(static_cast<int>(kNodeSlots), 2 * max_count)));
2003        replaced_node = true;
2004      } else {
2005        rebalance_or_split(&iter);
2006      }
2007    }
2008    (void)replaced_node;
2009  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
2010    if (!replaced_node) {
2011      assert(iter.node_->is_leaf());
2012      if (iter.node_->is_root()) {
2013        replace_leaf_root_node(max_count);
2014      } else {
2015        node_type *old_node = iter.node_;
2016        const bool was_rightmost = rightmost() == old_node;
2017        const bool was_leftmost = leftmost() == old_node;
2018        node_type *parent = old_node->parent();
2019        const field_type position = old_node->position();
2020        node_type *new_node = iter.node_ = new_leaf_node(position, parent);
2021        parent->set_child_noupdate_position(position, new_node);
2022        transfer_and_delete(old_node, new_node);
2023        if (was_rightmost) mutable_rightmost() = new_node;
2024        if (was_leftmost) root()->set_parent(new_node);
2025      }
2026    }
2027  #endif
2028    iter.node_->emplace_value(static_cast<field_type>(iter.position_), alloc,
2029                              std::forward<Args>(args)...);
2030    assert(
2031        iter.node_->is_ordered_correctly(static_cast<field_type>(iter.position_),
2032                                         original_key_compare(key_comp())) &&
2033        "If this assert fails, then either (1) the comparator may violate "
2034        "transitivity, i.e. comp(a,b) && comp(b,c) -> comp(a,c) (see "
2035        "https:&bsol;&bsol;en.cppreference.com/w/cpp/named_req/Compare), or (2) a "
2036        "key may have been mutated after it was inserted into the tree.");
2037    ++size_;
2038    iter.update_generation();
2039    return iter;
2040  }
2041  template <typename P>
2042  template <typename K>
2043  inline auto btree<P>::internal_locate(const K &key) const
2044      -> SearchResult<iterator, is_key_compare_to::value> {
2045    iterator iter(const_cast<node_type *>(root()));
2046    for (;;) {
2047      SearchResult<size_type, is_key_compare_to::value> res =
2048          iter.node_->lower_bound(key, key_comp());
2049      iter.position_ = static_cast<int>(res.value);
2050      if (res.IsEq()) {
2051        return {iter, MatchKind::kEq};
2052      }
2053      if (iter.node_->is_leaf()) {
2054        break;
2055      }
2056      iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));
2057    }
2058    return {iter, MatchKind::kNe};
2059  }
2060  template <typename P>
2061  template <typename K>
2062  auto btree<P>::internal_lower_bound(const K &key) const
2063      -> SearchResult<iterator, is_key_compare_to::value> {
2064    if (!params_type::template can_have_multiple_equivalent_keys<K>()) {
2065      SearchResult<iterator, is_key_compare_to::value> ret = internal_locate(key);
2066      ret.value = internal_last(ret.value);
2067      return ret;
2068    }
2069    iterator iter(const_cast<node_type *>(root()));
2070    SearchResult<size_type, is_key_compare_to::value> res;
2071    bool seen_eq = false;
2072    for (;;) {
2073      res = iter.node_->lower_bound(key, key_comp());
2074      iter.position_ = static_cast<int>(res.value);
2075      if (iter.node_->is_leaf()) {
2076        break;
2077      }
2078      seen_eq = seen_eq || res.IsEq();
2079      iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));
2080    }
2081    if (res.IsEq()) return {iter, MatchKind::kEq};
2082    return {internal_last(iter), seen_eq ? MatchKind::kEq : MatchKind::kNe};
2083  }
2084  template <typename P>
2085  template <typename K>
2086  auto btree<P>::internal_upper_bound(const K &key) const -> iterator {
2087    iterator iter(const_cast<node_type *>(root()));
2088    for (;;) {
2089      iter.position_ = static_cast<int>(iter.node_->upper_bound(key, key_comp()));
2090      if (iter.node_->is_leaf()) {
2091        break;
2092      }
2093      iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));
2094    }
2095    return internal_last(iter);
2096  }
2097  template <typename P>
2098  template <typename K>
2099  auto btree<P>::internal_find(const K &key) const -> iterator {
2100    SearchResult<iterator, is_key_compare_to::value> res = internal_locate(key);
2101    if (res.HasMatch()) {
2102      if (res.IsEq()) {
2103        return res.value;
2104      }
2105    } else {
2106      const iterator iter = internal_last(res.value);
2107      if (iter.node_ != nullptr && !compare_keys(key, iter.key())) {
2108        return iter;
2109      }
2110    }
2111    return {nullptr, 0};
2112  }
2113  template <typename P>
2114  typename btree<P>::size_type btree<P>::internal_verify(
2115      const node_type *node, const key_type *lo, const key_type *hi) const {
2116    assert(node->count() > 0);
2117    assert(node->count() <= node->max_count());
2118    if (lo) {
2119      assert(!compare_keys(node->key(node->start()), *lo));
2120    }
2121    if (hi) {
2122      assert(!compare_keys(*hi, node->key(node->finish() - 1)));
2123    }
2124    for (int i = node->start() + 1; i < node->finish(); ++i) {
2125      assert(!compare_keys(node->key(i), node->key(i - 1)));
2126    }
2127    size_type count = node->count();
2128    if (node->is_internal()) {
2129      for (field_type i = node->start(); i <= node->finish(); ++i) {
2130        assert(node->child(i) != nullptr);
2131        assert(node->child(i)->parent() == node);
2132        assert(node->child(i)->position() == i);
2133        count += internal_verify(node->child(i),
2134                                 i == node->start() ? lo : &node->key(i - 1),
2135                                 i == node->finish() ? hi : &node->key(i));
2136      }
2137    }
2138    return count;
2139  }
2140  struct btree_access {
2141    template <typename BtreeContainer, typename Pred>
2142    static auto erase_if(BtreeContainer &container, Pred pred) ->
2143        typename BtreeContainer::size_type {
2144      const auto initial_size = container.size();
2145      auto &tree = container.tree_;
2146      auto *alloc = tree.mutable_allocator();
2147      for (auto it = container.begin(); it != container.end();) {
2148        if (!pred(*it)) {
2149          ++it;
2150          continue;
2151        }
2152        auto *node = it.node_;
2153        if (node->is_internal()) {
2154          it = container.erase(it);
2155          continue;
2156        }
2157        int to_pos = it.position_;
2158        node->value_destroy(it.position_, alloc);
2159        while (++it.position_ < node->finish()) {
2160          it.update_generation();
2161          if (pred(*it)) {
2162            node->value_destroy(it.position_, alloc);
2163          } else {
2164            node->transfer(node->slot(to_pos++), node->slot(it.position_), alloc);
2165          }
2166        }
2167        const int num_deleted = node->finish() - to_pos;
2168        tree.size_ -= num_deleted;
2169        node->set_finish(to_pos);
2170        it.position_ = to_pos;
2171        it = tree.rebalance_after_delete(it);
2172      }
2173      return initial_size - container.size();
2174    }
2175  };
2176  #undef ABSL_BTREE_ENABLE_GENERATIONS
2177  }  
2178  ABSL_NAMESPACE_END
2179  }  
2180  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree.h</div>
                </div>
                <div class="column column_space"><pre><code>381  	const TCHAR * getLexerName() const {return _lexerName.c_str();};
382  	const TCHAR * getLexerDesc() const {return _lexerDesc.c_str();};
</pre></code></div>
                <div class="column column_space"><pre><code>1055    const_iterator find(const K &key) const {
1056      return internal_end(internal_find(key));
1057    }
1058    void clear();
1059    void swap(btree &other);
1060    const key_compare &key_comp() const noexcept {
1061      return rightmost_.template get<0>();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    