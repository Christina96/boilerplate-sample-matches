
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</h3>
            <pre><code>1  #include "lsionto.h"
2  void TOntoConcept::GenMedoid(PBowDocWgtBs BowDocWgtBs) {
3      TFltIntKdV WgtDIdV;
4      for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
5          const int DId = DIdV[DIdN];
6          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
7          const double Wgt = TBowSim::GetCosSim(ConceptSpV, DocSpV);
8          WgtDIdV.Add(TFltIntKd(Wgt, DId));
9      }
10      const int TopN = 33;
11      TFltIntKdV TopWgtDIdV;
12      if (WgtDIdV.Len() > TopN) {
13          TFltIntKdHp::GetTopV(htMin, TopN, WgtDIdV, TopWgtDIdV, true);
14      } else { 
15          TopWgtDIdV = WgtDIdV; TopWgtDIdV.Sort(false);
16      }
17      GetSwitchedKdV<TFlt, TInt>(TopWgtDIdV, MedoidDIdWgtV);
18  }
19  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
20          const int _Id, const TIntV& _DIdV): Id(_Id), DIdV(_DIdV)  { 
21      ResetCentroidSpV(BowDocWgtBs);
22      CptNm = GetKeyWdStr(BowDocBs, 3, 1.0, ", ", false, false);
23      SvmKeyWdSpV = TBowSpV::New();
24      if (!DIdV.IsSorted()) { DIdV.Sort(); }
25      Compactness = Clarity = -1.0;
26  };
27  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, const int _Id, 
28          const TStr& _CptNm, const TIntV& _DIdV): Id(_Id), CptNm(_CptNm), DIdV(_DIdV) { 
29      ResetCentroidSpV(BowDocWgtBs);
30      SvmKeyWdSpV = TBowSpV::New();
31      if (!DIdV.IsSorted()) { DIdV.Sort(); }
32      Compactness = Clarity = -1.0;
33  };
34  void TOntoConcept::ResetCentroidSpV(PBowDocWgtBs BowDocWgtBs) {
35      ConceptSpV = TBowClust::GetConceptSpV(BowDocWgtBs, NULL, DIdV);
36      GenMedoid(BowDocWgtBs);
37      IsValid = true;
38  }
39  void TOntoConcept::SetDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& _DIdV) {
40      if (Id == 0) return; 
41      DIdV = _DIdV; if (!DIdV.IsSorted()) { DIdV.Sort(); }
42      ResetCentroidSpV(BowDocWgtBs);
43  }
44  void TOntoConcept::AddDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV) {
45      DIdV.Union(SubDIdV);
46      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
47      else { IsValid = false; }
48  }
49  void TOntoConcept::AddDId(PBowDocWgtBs BowDocWgtBs, const int& DId) {
50      if (DIdV.SearchBin(DId) == -1) { DIdV.AddSorted(DId); }
51      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
52      else { IsValid = false; }
53  }
54  void TOntoConcept::DelDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV) {
55      if (Id == 0) return; 
56      DIdV.Diff(SubDIdV);
57      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
58      else { IsValid = false; }
59  }
60  bool TOntoConcept::DelDId(PBowDocWgtBs BowDocWgtBs, const int& DId) {
61      if (Id == 0) return false; 
62      bool DocDeletedP = DIdV.DelIfIn(DId);
63      if (DocDeletedP && !BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
64      else { IsValid = false; }
65      return DocDeletedP;
66  }
67  TStr TOntoConcept::GetKeyWdStr(PBowDocBs BowDocBs, const int& TopWords, 
68          const double& TopWordsWgtPrc, const TStr& SepStr, 
69          const bool& ShowWeights, const bool& UseMedoidP) const { 
70      if (!UseMedoidP) {
71          return ConceptSpV->GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
72      } else {
73          if (MedoidDIdWgtV.Empty()) { return "Empty concept"; }
74          TStr KeyWdStr = BowDocBs->GetDocNm(MedoidDIdWgtV[0].Key);
75          const int DIds = TInt::GetMn(TopWords, MedoidDIdWgtV.Len());
76          for (int DIdN = 1; DIdN < DIds; DIdN++) {
77              const int DId = MedoidDIdWgtV[DIdN].Key;
78              TStr DocNm = BowDocBs->GetDocNm(DId);
79              KeyWdStr += SepStr; KeyWdStr += DocNm;
80          }
81          return KeyWdStr;
82      }
83  }
84  TStr TOntoConcept::GetSvmKeyWdStr(PBowDocBs BowDocBs, const int& TopWords,
85          const double& TopWordsWgtPrc, const TStr& SepStr, const bool& ShowWeights) const {
86      return SvmKeyWdSpV->GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
87  }
88  void TOntoConcept::CalcCptMd(PBowDocBs BowDocBs, const TIntV& ContextDIdV,
89          const double& SvmC, const double& SvmJ, const int& SvmTime) {
90      if (Id == 0) return;
91      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, 
92          bwwtLogDFNrmTFIDF, 0.0, 0, ContextDIdV);
93      PSVMTrainSet TrainSet = TBowDocBs2TrainSet::NewBowAllCatV(
94          BowDocWgtBs, ContextDIdV, DIdV);
95      CptMd = TSVMModel::NewClsLinear(TrainSet, SvmC, SvmJ, TIntV(), 
96          TSVMLearnParam::Lin(SvmTime));
97      CptMd->MakeProb(TrainSet);
98  }
99  TStr TOntoRltType::SubCptOfRltStr = "SubConcept-Of";
100  TStr TOntoRltType::SimilarRltStr = "Similar";
101  void TOntoAlg::SuggestKMeans(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
102          const TIntV& DIdV, const int& _NewConceptN, PUniqueId UniqueId, 
103          TOntoConceptV& NewConceptV) {
104      const int NewConceptN = TInt::GetMn(DIdV.Len(), _NewConceptN);
105      NewConceptV.Clr(); if (NewConceptN < 2) return;
106      TIntV FullDIdV; BowDocWgtBs->GetDIdV(FullDIdV);
107      BowDocWgtBs->SetDIdV(DIdV);
108      PBowSim BowSim = TBowSim::New(bstCos);
109      PBowDocPart BowDocPart=TBowClust::GetKMeansPartForDocWgtBs(
110          TNotify::StdNotify, BowDocWgtBs, BowDocBs, 
111          BowSim, TRnd(1), NewConceptN, 1, 10, 1);
112      BowDocWgtBs->SetDIdV(FullDIdV);
113      IAssert(BowDocPart->GetClusts() == NewConceptN);
114      NewConceptV.Gen(NewConceptN, 0);
115      for (int ClustC = 0; ClustC < NewConceptN; ClustC++) {
116          PBowDocPartClust Clust = BowDocPart->GetClust(ClustC);
117          TIntV CptDIdV; Clust->GetDIdV(CptDIdV);
118          NewConceptV.Add(TOntoConcept::New(BowDocBs,
119              BowDocWgtBs, UniqueId->GetNextId(), CptDIdV));
120      }
121  }
122  void TOntoAlg::SuggestCat(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
123          const TIntV& DIdV, PUniqueId UniqueId, TOntoConceptV& NewConceptV) {
124      TIntIntVH CIdDIdVH;
125      for (int DocN = 0; DocN < DIdV.Len(); DocN++) {
126          const int DId = DIdV[DocN];
127          const int DocCIds = BowDocBs->GetDocCIds(DId);
128          for (int DocCIdN = 0; DocCIdN < DocCIds; DocCIdN++) {
129              const int DocCId = BowDocBs->GetDocCId(DId, DocCIdN);
130              if (CIdDIdVH.IsKey(DocCId)) {
131                  CIdDIdVH.GetDat(DocCId).Add(DId);
132              } else {
133                  CIdDIdVH.AddDat(DocCId, TIntV::GetV(DId));
134              }
135          }
136      }
137      TIntKdV DocsKeyIdV(CIdDIdVH.Len(), 0);
138      int KeyId = CIdDIdVH.FFirstKeyId();
139      while (CIdDIdVH.FNextKeyId(KeyId)) {
140          const int Docs = CIdDIdVH[KeyId].Len();
141          DocsKeyIdV.Add(TIntKd(Docs, KeyId));
142      }
143      DocsKeyIdV.Sort(false);
144      NewConceptV.Gen(CIdDIdVH.Len(), 0);
145      for (int CptN = 0; CptN < DocsKeyIdV.Len(); CptN++) {
146          const int CptKeyId = DocsKeyIdV[CptN].Dat;
147          const TIntV& CptDIdV = CIdDIdVH[CptKeyId];
148          TStr CptNm = BowDocBs->GetCatNm(CIdDIdVH.GetKey(CptKeyId));
149          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
150              UniqueId->GetNextId(), CptNm, CptDIdV));
151      }
152  }
153  void TOntoAlg::SuggestLwOntoCfier(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
154          const TIntV& DIdV, PLwOntoCfier LwOntoCfier, const int& _NewConcepts, 
155          PUniqueId UniqueId, TOntoConceptV& NewConceptV) {
156      TIntH TermIdFqH; TIntIntVH TermIdDIdVH;
157      for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
158          const int DId = DIdV[DIdN];
159          TStr DocStr = BowDocBs->GetDocStr(DId);
160          TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
161          LwOntoCfier->ClassifyStr(DocStr, SimTermIdPrV);
162          if (!SimTermIdPrV.Empty()) { 
163              const int TermId = SimTermIdPrV[0].Val2;
164              if (TermIdFqH.IsKey(TermId)) { 
165                  TermIdFqH(TermId)++; 
166                  TermIdDIdVH(TermId).Add(DId);
167              } else { 
168                  TermIdFqH.AddDat(TermId, 1); 
169                  TermIdDIdVH.AddDat(TermId, TIntV::GetV(DId));
170              }
171          }
172      }
173      TIntPrV TermFqIdV; TermIdFqH.GetDatKeyPrV(TermFqIdV); TermFqIdV.Sort(false);
174      const int NewConcepts = TInt::GetMn(_NewConcepts, TermFqIdV.Len());
175      NewConceptV.Gen(NewConcepts, 0);
176      PLwTermBs TermBs = LwOntoCfier->GetLwOnto()->GetTermBs();
177      for (int NewConceptN = 0; NewConceptN < NewConcepts; NewConceptN++) {
178          const int TermId = TermFqIdV[NewConceptN].Val2;
179          const TIntV& CptDIdV = TermIdDIdVH(TermId);
180          TStr TermNm = TermBs->GetTerm(TermId)->GetTermNm();
181          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
182              UniqueId->GetNextId(), TermNm, CptDIdV));
183      }
184  }
185  TStr TOntoExportPTO::GetUri(const int& Id, const TStr& Nm) {
186      TChA CleanChA; bool ToUc = true;
187      for (int ChN = 0; ChN < Nm.Len(); ChN++) {
188          char Ch = Nm[ChN];
189          if (TCh::IsAlpha(Ch)) { 
190              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
191              CleanChA += Ch; 
192          } else { ToUc = true; }
193      }
194      return TInt::GetStr(Id) + "_" + TStr(CleanChA);
195  }
196  void TOntoExportPTO::StartExport() {
197      SOut->PutStrLn("<?xml version='1.0' encoding='UTF-8'?>");
198      SOut->PutStrLn("");
199      SOut->PutStrLn("<!DOCTYPE rdf:RDF [");
200      SOut->PutStrLn("    <!ENTITY rdf  'http:&bsol;&bsol;www.w3.org/1999/02/22-rdf-syntax-ns#'>");
201      SOut->PutStrLn("    <!ENTITY rdfs 'http:&bsol;&bsol;www.w3.org/2000/01/rdf-schema#'>");
202      SOut->PutStrLn("    <!ENTITY owl  'http:&bsol;&bsol;www.w3.org/2002/07/owl#'>");
203      SOut->PutStrLn("    <!ENTITY xsd  'http:&bsol;&bsol;www.w3.org/2001/XMLSchema#' >");
204      SOut->PutStrLn("    <!ENTITY ptop 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont#'>");
205      SOut->PutStrLn("    <!ENTITY psys 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons#'>");
206      SOut->PutStrLn("    <!ENTITY protonkm  'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm#'>");
207      if (DigLibP) { SOut->PutStrLn("    <!ENTITY diglib 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons#'>"); }
208      SOut->PutStrLn("    <!ENTITY jsikm  'http:&bsol;&bsol;kt.ijs.si/blazf/jsikm#'>");
209      SOut->PutStrLn("]>");
210      SOut->PutStrLn("");
211      SOut->PutStrLn("<rdf:RDF");
212      SOut->PutStrLn("    xmlns:owl=\"&owl;\"");
213      SOut->PutStrLn("    xmlns:rdf=\"&rdf;\"");
214      SOut->PutStrLn("    xmlns:rdfs=\"&rdfs;\"");
215      SOut->PutStrLn("    xmlns:psys=\"&psys;\"");
216      SOut->PutStrLn("    xmlns:ptop=\"&ptop;\"");
217      SOut->PutStrLn("    xmlns:protonkm=\"&protonkm;\"");
218      SOut->PutStrLn("    xmlns=\"&protonkm;\"");
219      if (DigLibP) { SOut->PutStrLn("    xmlns:diglib=\"&diglib;\""); }
220      SOut->PutStrLn("    xmlns:jsikm=\"&jsikm;\"");
221      SOut->PutStrLn("    xml:base=\"&protonkm;\""); 
222      SOut->PutStrLn(">");
223      SOut->PutStrLn("");
224      SOut->PutStrLn("<owl:Ontology rdf:about=\"\">");
225      SOut->PutStrLn("  <rdfs:comment>PROTON Topics (from Inspec Thesaurus) ordered by algorithm X</rdfs:comment>");
226      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons\"/>");
227      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont\"/>");
228      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonu\"/>");
229      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm\"/>");
230      if (DigLibP) { SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;kt.ijs.si/blazf/jsikm\"/>"); }
231      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;kt.ijs.si/blazf/jsikm\"/>");
232      SOut->PutStrLn("  <owl:versionInfo>\"0.1\"</owl:versionInfo>");
233      SOut->PutStrLn("</owl:Ontology>");
234      SOut->PutStrLn("");
235  }
236  void TOntoExportPTO::EndExport() {
237      SOut->PutStrLn("</rdf:RDF>");
238      SOut->Flush();
239  }
240  void TOntoExportPTO::PutCpt(const int& CptId, const TStr CptNm, 
241          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, const TIntV& DIdV, 
242          PBowDocBs BowDocBs, PBowSpV KeyWdSpV, PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
243      SOut->PutStrLn("<ptop:Topic rdf:about=\"#Cpt" + GetUri(CptId, CptNm) + "\">");
244      SOut->PutStrLn("  <psys:description>" + CptNm + "</psys:description>");
245      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
246          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
247          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
248          SOut->PutStrLn("  <ptop:subTopicOf rdf:resource=\"#Cpt" + 
249              GetUri(SuperCptId, SuperCptNm) + "\" />");
250      }
251      if (DigLibP) {
252          for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
253              const int DId = DIdV[DIdN];
254              TStr DNm = BowDocBs->GetDocNm(DId);
255              SOut->PutStrLn("  <diglib:hasArticle rdf:resource=\"#Doc" + 
256                  GetUri(DId, DNm) + "\" />");
257          }
258      }
259      SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenClassProperties rdf:resource=\"#CLS_PROP_%d\" />", CptId));
260      SOut->PutStrLn("</ptop:Topic>");
261      SOut->PutStrLn(TStr::Fmt("<jsikm:OntoGenClassProperties rdf:about=\"#CLS_PROP_%d\">", CptId));
262      TStr KeyWdStr = KeyWdSpV->GetStr(BowDocBs, 10, 1.0, ", ", false, true);
263      SOut->PutStrLn("  <jsikm:hasCentroidKeywords>" + KeyWdStr + "</jsikm:hasCentroidKeywords>");
264      TStr SvmKeyWdStr = SvmKeyWdSpV->GetStr(BowDocBs, 10, 1.0, ", ", false, true);
265      SOut->PutStrLn("  <jsikm:hasSVMKeywords>" + SvmKeyWdStr + "</jsikm:hasSVMKeywords>");
266      SOut->PutStrLn("</jsikm:OntoGenClassProperties>");
267      SOut->PutStrLn("");
268  }
269  void TOntoExportPTO::PutDoc(const int& DId, const TStr& DocTitle, 
270          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
271      SOut->PutStrLn("<ptop:Document rdf:about=\"#Doc" + GetUri(DId, DocTitle) + "\">");
272      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
273          const int CptId = CptIdNmV[CptIdN].Val1;
274          TStr CptNm = CptIdNmV[CptIdN].Val2;
275          SOut->PutStrLn("  <ptop:hasSubject rdf:resource=\"#Cpt" + 
276              GetUri(CptId, CptNm) + "\" />");
277      }
278      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
279      CleanDocAbstract.ChangeChAll('\n', ' '); CleanDocAbstract.ChangeChAll('\n', ' ');
280      SOut->PutStrLn(TStr::Fmt("  <ptop:documentAbstract>%s</ptop:documentAbstract>", CleanDocAbstract.CStr()));
281      SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenInstanceProperties rdf:resource=\"#INST_PROP_%d\" />", DId));
282      SOut->PutStrLn("</ptop:Document>");
283      TStr ShortBowFNm = BowFNmStr.GetFMid() + BowFNmStr.GetFExt();
284      SOut->PutStrLn(TStr::Fmt("<jsikm:OntoGenInstanceProperties rdf:about=\"#INST_PROP_%d\">", DId));
<span onclick='openModal()' class='match'>285      SOut->PutStrLn(TStr::Fmt("  <jsikm:locationOfInstance>%s#%d</jsikm:locationOfInstance>", ShortBowFNm.CStr(), DId));
286      SOut->PutStrLn("</jsikm:OntoGenInstanceProperties>");
</span>287      SOut->PutStrLn("");
288  }
289  void TOntoExportProlog::StartExport() {
290      SOut->PutStrLn("% OntoGen export in Prolog.");
291  }
292  void TOntoExportProlog::EndExport() {
293      SOut->Flush();
294  }
295  void TOntoExportProlog::PutCpt(const int& CptId, const TStr CptNm, 
296          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
297          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
298          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
299      SOut->PutStrLn(TStr::Fmt("class( %s, label, '%s' ).", 
300          GetCptLabel(CptId).CStr(), CptNm.CStr()));
301      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
302          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
303          SOut->PutStrLn(TStr::Fmt("subClassOf( %s, %s ).", 
304              GetCptLabel(CptId).CStr(), GetCptLabel(SuperCptId).CStr()));
305      }
306  }
307  void TOntoExportProlog::PutDoc(const int& DId, const TStr& DocTitle, 
308          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
309      TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll('\'');
310      CleanDocTitle.DelChAll('\n'); CleanDocTitle.DelChAll('\r');
311      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
312      CleanDocAbstract.DelChAll('\''); CleanDocAbstract.DelChAll('\n'); 
313      CleanDocAbstract.DelChAll('\r');
314      SOut->PutStrLn(TStr::Fmt("instance( %s, label, '%s' ).", 
315          GetInstLabel(DId).CStr(), CleanDocTitle.CStr()));
316      SOut->PutStrLn(TStr::Fmt("instance( %s, text, '%s' ).", 
317          GetInstLabel(DId).CStr(), CleanDocAbstract.CStr()));
318      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
319          const int CptId = CptIdNmV[CptIdN].Val1;
320          SOut->PutStrLn(TStr::Fmt("instanceOf( %s, %s ).", 
321              GetInstLabel(DId).CStr(), GetCptLabel(CptId).CStr()));
322      }
323  }
324  TStr TOntoExportOWL::GetUri(const int& Id, const TStr& Nm) {
325      TChA CleanChA; bool ToUc = true;
326      for (int ChN = 0; ChN < Nm.Len(); ChN++) {
327          char Ch = Nm[ChN];
328          if (TCh::IsAlpha(Ch)) { 
329              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
330              CleanChA += Ch; 
331          } else { ToUc = true; }
332      }
333      return TInt::GetStr(Id) + "_" + TStr(CleanChA);
334  }
335  void TOntoExportOWL::StartExport() {
336      SOut->PutStrLn("<?xml version=\"1.0\"?>");
337      SOut->PutStrLn("<rdf:RDF");
338      SOut->PutStrLn("    xmlns:rdf=\"http:&bsol;&bsol;www.w3.org/1999/02/22-rdf-syntax-ns#\"");
339      SOut->PutStrLn("    xmlns:xsd=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema#\"");
340      SOut->PutStrLn("    xmlns:rdfs=\"http:&bsol;&bsol;www.w3.org/2000/01/rdf-schema#\"");
341      SOut->PutStrLn("    xmlns:owl=\"http:&bsol;&bsol;www.w3.org/2002/07/owl#\"");
342      SOut->PutStrLn("    xmlns=\"http:&bsol;&bsol;www.owl-ontologies.com/Ontology1150050933.owl#\"");
343      SOut->PutStrLn("    xml:base=\"http:&bsol;&bsol;www.owl-ontologies.com/Ontology1150050933.owl\">");
344      SOut->PutStrLn("");
345      SOut->PutStrLn("<owl:Ontology rdf:about=\"OntoGen OWL export\"/>");
346      SOut->PutStrLn("");
347  }
348  void TOntoExportOWL::EndExport() {
349      SOut->PutStrLn("");
350      SOut->PutStrLn("</rdf:RDF>");
351      SOut->Flush();
352  }
353  void TOntoExportOWL::PutCpt(const int& CptId, const TStr CptNm, 
354          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
355          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
356          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
357      SOut->PutStrLn("<owl:Class rdf:ID=\"Cpt" + GetUri(CptId, CptNm) + "\">");
358      SOut->PutStrLn("  <rdfs:label>" + CptNm + "</rdfs:label>");
359      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
360          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
361          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
362          SOut->PutStrLn("  <rdfs:subClassOf rdf:resource=\"#Cpt" + 
363              GetUri(SuperCptId, SuperCptNm) + "\"/>");
364      }
365      SOut->PutStrLn("</owl:Class>");
366      SOut->PutStrLn("");
367  }
368  void TOntoExportOWL::PutDoc(const int& DId, const TStr& DocTitle, 
369          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
370      if (!StoreDocsP) { return; }
371      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
372          const int CptId = CptIdNmV[CptIdN].Val1;
373          TStr CptNm = CptIdNmV[CptIdN].Val2;
374          SOut->PutStrLn("<Cpt" + GetUri(CptId, CptNm) + " rdf:ID=\"Doc" + 
375              GetUri(DId, DocTitle) + "\">");
376          if (CptIdN == 0) {
377              TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll('\'');
378              CleanDocTitle.DelChAll('\n'); CleanDocTitle.DelChAll('\r');
379              SOut->PutStrLn("  <rdfs:label>" + CleanDocTitle + "</rdfs:label>");
380              if (StoreAbstractsP) {
381                  TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
382                  CleanDocAbstract.DelChAll('\''); CleanDocAbstract.DelChAll('\n'); 
383                  CleanDocAbstract.DelChAll('\r');
384                  SOut->PutStrLn("  <rdfs:comment>" + CleanDocAbstract + "</rdfs:label>");
385              }
386          }
387          SOut->PutStrLn("</Cpt" + GetUri(CptId, CptNm) + ">");
388      }
389      SOut->PutStrLn("");
390  }
391  void TOntoExportOWL::PutRltType(const TStr& RltNm, const bool& DirectedP,
392          const bool& TransitiveP) {
393      SOut->PutStrLn("<owl:ObjectProperty rdf:ID=\"" + RltNm + "\"/>");
394      SOut->PutStrLn("");    
395  }
396  void TOntoExportOWL::PutRlt(const TStr& RltNm, const int& SrcCptId, 
397          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm) {
398      SOut->PutStrLn("<owl:Class rdf:ID=\"Cpt" + GetUri(SrcCptId, SrcCptNm) + "\">");
399      SOut->PutStrLn("  <rdfs:subClassOf><owl:Restriction>");
400      SOut->PutStrLn("    <owl:onProperty rdf:resource=\"#" + RltNm + "\"/>");
401      SOut->PutStrLn("    <owl:someValuesFrom>");
402      SOut->PutStrLn("      <owl:Class rdf:ID=\"Cpt" + GetUri(DstCptId, DstCptNm) + "\"/>");
403      SOut->PutStrLn("    </owl:someValuesFrom>");
404      SOut->PutStrLn("  </owl:Restriction></rdfs:subClassOf>");
405      SOut->PutStrLn("</owl:Class>");
406      SOut->PutStrLn("");    
407  }
408  TOntology::TOntology(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs, 
409      const TBowSimType& BowSimType): BowDocBs(_BowDocBs), 
410          BowDocWgtBs(_BowDocWgtBs) {
411      BowSim = TBowSim::New(BowSimType);
412      OntoGraph = TGGraph::New();
413      UniqueId = TUniqueId::New(0);
414      GenerateEmptyOnto();
415  }
416  void TOntology::GenerateEmptyOnto() {
417      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
418      POntoConcept RootCpt = TOntoConcept::New(BowDocBs, 
419          BowDocWgtBs, UniqueId->GetNextId(), AllDIdV);
420      RootCpt->SetName("root");
421      AddConcept(RootCpt, -1);
422      OntoGraph->GetPp()->AddPpStr("BoldVNm", "", "root");
423      RltTypeV.Add(TOntoRltType(TOntoRltType::SubCptOfRltStr, true, true));
424      RltTypeV.Add(TOntoRltType(TOntoRltType::SimilarRltStr, false, false));
425  }
426  void TOntology::RefreshCptIdPosH() {
427      CptIdPosH.Clr();
428      for (int CptC = 0; CptC < ConceptV.Len(); CptC++) {
429          const int CptId = ConceptV[CptC]->GetId();
430          IAssertR(!CptIdPosH.IsKey(CptId), "Concept ID not unique!");
431          CptIdPosH.AddDat(CptId, CptC);
432      }
433  }
434  void TOntology::ReconnectToRoot() {
435      for (int CptC = 0; CptC < ConceptV.Len(); CptC++) {
436          const int CptId = ConceptV[CptC]->GetId();
437          if (!IsRootCpt(CptId) && !HasSuperCpt(CptId)) {
438              AddRlt(CptId, 0, TOntoRltType::SubCptOfRltStr);
439          }
440      }
441  }
442  void TOntology::AddRltsFromList(TIntStrPrV& InRltV, 
443          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV) {
444      for (int InEdN = 0; InEdN < InRltV.Len(); InEdN++) {
445          const int CptId1 = InRltV[InEdN].Val1;
446          TStr RltNm1 = InRltV[InEdN].Val2; Assert(IsRltDir(RltNm1));
447          for (int OutEdN = 0; OutEdN < OutRltV.Len(); OutEdN++) {
448              const int CptId2 = OutRltV[OutEdN].Val1;
449              TStr RltNm2 = OutRltV[OutEdN].Val2; Assert(IsRltDir(RltNm2));
450              if (CptId1 != CptId2 && RltNm1 == RltNm2) {
451                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
452                  if (!IsRltTransitive(RltNm1)) continue;
453                  AddRlt(CptId1, CptId2, RltNm1);
454              }
455          }
456      }
457      for (int InEdN = 0; InEdN < UndirRltV.Len(); InEdN++) {
458          const int CptId1 = UndirRltV[InEdN].Val1;
459          TStr RltNm1 = UndirRltV[InEdN].Val2; Assert(!IsRltDir(RltNm1));
460          for (int OutEdN = 0; OutEdN < UndirRltV.Len(); OutEdN++) {
461              const int CptId2 = UndirRltV[OutEdN].Val1;
462              TStr RltNm2 = UndirRltV[OutEdN].Val2; Assert(!IsRltDir(RltNm2));
463              if (CptId1 != CptId2 && RltNm1 == RltNm2) {
464                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
465                  if (!IsRltTransitive(RltNm1)) continue;
466                  AddRlt(CptId1, CptId2, RltNm1);
467              }
468          }
469      }
470  }
471  void TOntology::AddSonDIdV(const int& CptId, TIntV& SonDIdV) {
472      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
473      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
474          const int SubCptId = SubCptIdV[SubCptIdN];
475          TIntV SubCptDIdV; GetCptDIdV(SubCptId, SubCptDIdV);
476          SonDIdV.Union(SubCptDIdV);
477          AddSonDIdV(SubCptId, SonDIdV);
478      }
479  }
480  void TOntology::CfyDIdR(const int& DId, const TIntV& CptIdV, TIntFltKdV& CfyResV) {
481      for (int CptIdN = 0; CptIdN < CptIdV.Len(); CptIdN++) {
482          const int CptId = CptIdV[CptIdN];
483          POntoConcept Cpt = GetConcept(CptId);
484          if (Cpt->IsCptMd()) {
485              bool IsDocInCpt; double Prob;
486              Cpt->CfyDocSpV(BowDocWgtBs->GetSpV(DId), IsDocInCpt, Prob);
487              if (IsDocInCpt) {
488                  CfyResV.Add(TIntFltKd(CptId, Prob));
489                  TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
490                  CfyDIdR(DId, SubCptIdV, CfyResV);
491              }
492          }
493      }
494  }
495  void TOntology::Export(POntoExport OntoExport) {
496      OntoExport->StartExport();
497      TIntV CptIdV; GetCptIdV(CptIdV);
498      TIntIntVH DIdCptIdVH;
499      for (int CptN = 0; CptN < CptIdV.Len(); CptN++) {
500          const int CptId = CptIdV[CptN];
501          TStr CptNm = TXmlDoc::GetXmlStr(GetCptName(CptId));
502          if (OntoExport->IsCptAlwaysSvm()) { ExtractKeywords(CptId); }
503          TIntStrPrV SubCptIdNmV;
504          if (OntoExport->IsCptSubCptLink()) {
505              TIntStrPrV CptInRltV; GetCptInRltV(CptId, CptInRltV);
506              for (int SubCptN = 0; SubCptN < CptInRltV.Len(); SubCptN++) {
507                  TStr RltNm = CptInRltV[SubCptN].Val2;
508                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
509                      const int SubCptId = CptInRltV[SubCptN].Val1;
510                      TStr SubCptNm = GetCptName(SubCptId);
511                      SubCptIdNmV.Add(TIntStrPr(SubCptId, SubCptNm));
512                  }
513              }
514          }
515          TIntStrPrV SuperCptIdNmV;
516          if (OntoExport->IsCptSuperCptLink()) {
517              TIntStrPrV CptOutRltV; GetCptOutRltV(CptId, CptOutRltV);
518              for (int SuperCptN = 0; SuperCptN < CptOutRltV.Len(); SuperCptN++) {
519                  TStr RltNm = CptOutRltV[SuperCptN].Val2;
520                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
521                      const int SuperCptId = CptOutRltV[SuperCptN].Val1;
522                      TStr SuperCptNm = GetCptName(SuperCptId);
523                      SuperCptIdNmV.Add(TIntStrPr(SuperCptId, SuperCptNm));
524                  }
525              }
526          }
527          TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
528          for (int DocN = 0; DocN < CptDIdV.Len(); DocN++) {
529              const int DId = CptDIdV[DocN];
530              if (DIdCptIdVH.IsKey(DId)) {
531                  DIdCptIdVH.GetDat(DId).Add(CptId);
532              } else {
533                  DIdCptIdVH.AddDat(DId, TIntV::GetV(CptId));
534              }
535          }
536          if (!OntoExport->IsCptDocLink()) { CptDIdV.Clr(); }
537          OntoExport->PutCpt(CptId, CptNm, SubCptIdNmV, SuperCptIdNmV, 
538              CptDIdV, BowDocBs, GetConcept(CptId)->GetCentroidSpV(), 
539              GetConcept(CptId)->GetSvmSpV(), TBowSpV::New(-1));
540      }
541      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
542      for (int DocN = 0; DocN < AllDIdV.Len(); DocN++) {
543          const int DId = AllDIdV[DocN];
544          TStr DocTitle = BowDocBs->GetDocNm(DId);
545          TStr DocAbstract = BowDocBs->GetDocStr(DId);
546          TIntStrPrV CptIdNmV;
547          if (DIdCptIdVH.IsKey(DId) && OntoExport->IsDocCptLink()) {
548              TIntV& DocCptIdV = DIdCptIdVH.GetDat(DId);
549              for (int DocCptIdN = 0; DocCptIdN < DocCptIdV.Len(); DocCptIdN++) {
550                  const int CptId = DocCptIdV[DocCptIdN];
551                  TStr CptNm = GetCptName(CptId);
552                  CptIdNmV.Add(TIntStrPr(CptId, CptNm));
553              }
554          }
555          OntoExport->PutDoc(DId, DocTitle, DocAbstract, CptIdNmV);
556      }        
557      if (OntoExport->IsRlt()) {
558          const int RltTypes = GetRltTypes();
559          for (int RltTypeN = 0; RltTypeN < RltTypes; RltTypeN++) {
560              TStr RltTypeNm = GetRltTypeNm(RltTypeN);
561              if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
562                  OntoExport->PutRltType(RltTypeNm, 
563                      IsRltDir(RltTypeNm), IsRltTransitive(RltTypeNm));
564              }
565          }
566          for (int CptN = 0; CptN < CptIdV.Len(); CptN++) {
567              const int SrcCptId = CptIdV[CptN];
568              TStr SrcCptNm = GetCptName(SrcCptId);
569              TIntStrPrV CptOutRltV; GetCptOutRltV(SrcCptId, CptOutRltV);
570              for (int OutRltN = 0; OutRltN < CptOutRltV.Len(); OutRltN++) {
571                  const TStr& RltTypeNm = CptOutRltV[OutRltN].Val2;
572                  if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
573                      const int DstCptId = CptOutRltV[OutRltN].Val1;
574                      OntoExport->PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
575                          DstCptId, GetCptName(DstCptId));
576                  }
577              }
578              TIntStrPrV CptUndirRltV; GetCptUndirRltV(SrcCptId, CptUndirRltV);
579              for (int UndirRltN = 0; UndirRltN < CptUndirRltV.Len(); UndirRltN++) {
580                  const TStr& RltTypeNm = CptUndirRltV[UndirRltN].Val2;
581                  const int DstCptId = CptUndirRltV[UndirRltN].Val1;
582                  if (SrcCptId < DstCptId) {
583                      OntoExport->PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
584                          DstCptId, GetCptName(DstCptId));
585                  }
586              }
587          }
588      }
589      OntoExport->EndExport();
590  }
591  void TOntology::GetCptIdV(TIntV& CptIdV) {
592      CptIdV.Gen(ConceptV.Len(), 0);
593      for (int CptIdN = 0; CptIdN < ConceptV.Len(); CptIdN++) {
594          CptIdV.Add(ConceptV[CptIdN]->GetId());
595      }
596      CptIdV.Sort();
597  }
598  void TOntology::SetCptName(const int& CptId, const TStr& NewName) {
599      GetConcept(CptId)->SetName(NewName);
600      OntoGraph->GetVrtx(CptId)->PutDNm(NewName);
601  }
602  void TOntology::SetCptDIdV(const int& CptId, const TIntV& _NewDIdV, const bool& PropagateP) {
603      if (PropagateP) {
604          TIntV NewDIdV = _NewDIdV;
605          if (!NewDIdV.IsSorted()) { NewDIdV.Sort(); }
606          TIntV OldDIdV; GetCptDIdV(CptId, OldDIdV);
607          TIntV BothDIdV; OldDIdV.Union(NewDIdV, BothDIdV);
608          TIntV AddDIdV; BothDIdV.Diff(OldDIdV, AddDIdV);
609          AddUpDIdV(CptId, AddDIdV);
610          TIntV DelDIdV; BothDIdV.Diff(NewDIdV, DelDIdV);
611          DelDownDIdV(CptId, DelDIdV);
612      } else {
613          GetConcept(CptId)->SetDIdV(BowDocWgtBs, _NewDIdV);
614      }
615  }
616  void TOntology::GetCptSimV(const int& CptId, TFltIntKdV& SimCptIdV) {
617      PBowSpV CptSpV = GetConcept(CptId)->GetCentroidSpV();
618      SimCptIdV.Gen(GetConcepts() - 1, 0);
619      for (int CptN = 0; CptN < GetConcepts(); CptN++) {
620          const int CptId2 = ConceptV[CptN]->GetId();
621          if (CptId != CptId2) {
622              PBowSpV CptSpV2 = ConceptV[CptN]->GetCentroidSpV();
623              SimCptIdV.Add(TFltIntKd(BowSim->GetSim(CptSpV, CptSpV2), CptId2));
624          }
625      }
626      SimCptIdV.Sort(false);
627  }
628  void TOntology::CalcCptMd(const int& CptId, const double& SvmC, 
629          const double& SvmJ, const int& SvmTime) {
630      if (IsRootCpt(CptId)) return;
631      TIntV ContextDIdV; BowDocBs->GetAllDIdV(ContextDIdV);
632      GetConcept(CptId)->CalcCptMd(BowDocBs, ContextDIdV, SvmC, SvmJ, SvmTime);
633  }
634  void TOntology::CfyDId(const int& DId, TIntFltKdV& CfyResV) {
635      const int CptIds = GetConcepts(); CfyResV.Gen(CptIds, 0);
636      for (int CptIdN = 0; CptIdN < CptIds; CptIdN++) {
637          const int CptId = GetCptId(CptIdN);
638          POntoConcept Cpt = GetConcept(CptId);
639          if (Cpt->IsCptMd()) {
640              bool IsDocInCpt; double Prob;
641              Cpt->CfyDocSpV(BowDocWgtBs->GetSpV(DId), IsDocInCpt, Prob);
642              if (IsDocInCpt) {
643                  CfyResV.Add(TIntFltKd(CptId, Prob));
644              } else {
645                  CfyResV.Add(TIntFltKd(CptId, Prob - 1.0));
646              }
647          } else if (IsRootCpt(CptId)) {
648              CfyResV.Add(TIntFltKd(CptId, 1.0));
649          } else {
650              CfyResV.Add(TIntFltKd(CptId, -1.0));
651          }
652      }
653      CfyResV.Sort();
654  }
655  void TOntology::IncludeLnDocs(const TStr& LnDocFNm, TIntV& NewDIdV) {
656      TBowFl::LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, true, -1, true);    
657      NewDIdV.Sort(); ReCalcWgtBs(); 
658      GetRootCpt()->AddDIdV(BowDocWgtBs, NewDIdV); 
659  }
660  void TOntology::IncludeFolder(const TStr& FPath, TIntV& NewDIdV, const bool& RecurseDirP) {
661      TBowFl::LoadHtmlTxt(BowDocBs, FPath, NewDIdV, RecurseDirP, -1, true);
662      NewDIdV.Sort(); ReCalcWgtBs(); 
663      GetRootCpt()->AddDIdV(BowDocWgtBs, NewDIdV); 
664  }
665  void TOntology::AddDocToCptV(const int& DId, const TIntV& CptIdV, const bool& UpdateCentroidP) {
666      for (int CptIdN = 0; CptIdN < CptIdV.Len(); CptIdN++) {
667          const int CptId = CptIdV[CptIdN];
668          if (UpdateCentroidP) {
669              GetConcept(CptId)->AddDId(BowDocWgtBs, DId);
670          } else {
671              GetConcept(CptId)->AddDId(NULL, DId);
672          }
673      }
674  }
675  void TOntology::ResetAllCptKeyWd() {
676      const int CptIds = GetConcepts();
677      for (int CptIdN = 0; CptIdN < CptIds; CptIdN++) {
678          const int CptId = GetCptId(CptIdN);
679          if (!GetConcept(CptId)->IsCentroidValid()) {
680              GetConcept(CptId)->ResetCentroidSpV(BowDocWgtBs);
681          }
682      }
683  }
684  void TOntology::GetSubCptIdV(const int& CptId, TIntV& SubCptIdV) {
685      TIntStrPrV InRltV; GetCptInRltV(CptId, InRltV);
686      SubCptIdV.Gen(InRltV.Len(), 0);
687      for (int InRltN = 0; InRltN < InRltV.Len(); InRltN++) {
688          if (InRltV[InRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
689              SubCptIdV.Add(InRltV[InRltN].Val1);
690          }
691      }
692      SubCptIdV.Sort();
693  }
694  void TOntology::GetSuperCptIdV(const int& CptId, TIntV& SuperCptIdV) {
695      TIntStrPrV OutRltV; GetCptOutRltV(CptId, OutRltV);
696      SuperCptIdV.Gen(OutRltV.Len(), 0);
697      for (int OutRltN = 0; OutRltN < OutRltV.Len(); OutRltN++) {
698          if (OutRltV[OutRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
699              SuperCptIdV.Add(OutRltV[OutRltN].Val1);
700          }
701      }
702      SuperCptIdV.Sort();
703  }
704  void TOntology::GetCptUnusedDIdV(const int& CptId, TIntV& DIdV) {
705      GetConcept(CptId)->GetDIdV(DIdV);
706      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
707      for (int SubCptN = 0; SubCptN < SubCptIdV.Len(); SubCptN++) {
708          const int SubCptId = SubCptIdV[SubCptN];
709          TIntV SubDIdV; GetConcept(SubCptId)->GetDIdV(SubDIdV);
710          DIdV.Diff(SubDIdV);
711      }   
712  }
713  void TOntology::GetCptContextDIdV(const int& CptId, 
714          TIntV& ContextDIdV, const bool& AddSonDIdP) {
715      ContextDIdV.Clr();
716      GetConcept(CptId)->GetDIdV(ContextDIdV);
717      if (HasSuperCpt(CptId)) {
718          TIntV SuperCptIdV, SuperDIdV; GetSuperCptIdV(CptId, SuperCptIdV);
719          for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
720              const int SuperCptId = SuperCptIdV[SuperCptIdN];
721              GetConcept(SuperCptId)->GetDIdV(SuperDIdV);    
722              ContextDIdV.Union(SuperDIdV);
723          }
724      }
725      if (AddSonDIdP) AddSonDIdV(CptId, ContextDIdV);
726  }
727  void TOntology::GetInconsistDIdV(const int& CptId, TIntV& InconsistDIdV) {
728      InconsistDIdV.Clr();
729      TIntV SonDIdV; AddSonDIdV(CptId, SonDIdV);
730      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
731      SonDIdV.Union(CptDIdV); 
732      SonDIdV.Diff(CptDIdV, InconsistDIdV);
733  }
734  void TOntology::GetCptDocSimV(const int& CptId, const TIntV& DIdV, TFltV& CptDocSimV) {
735      PBowSpV CptSpV = GetConcept(CptId)->GetCentroidSpV();
736      const int Docs = DIdV.Len(); CptDocSimV.Gen(Docs, 0);
737      for (int DocN = 0; DocN < Docs; DocN++) {
738          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DIdV[DocN]);
739          CptDocSimV.Add(BowSim->GetSim(CptSpV, DocSpV));
740      }
741  }
742  void TOntology::AddUpDIdV(const int& CptId, const TIntV& SubDIdV) {
743      GetConcept(CptId)->AddDIdV(BowDocWgtBs, SubDIdV);
744      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
745      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
746          const int SuperCptId = SuperCptIdV[SuperCptIdN];
747          if (!IsRootCpt(SuperCptId)) { AddUpDIdV(SuperCptId, SubDIdV); }
748      }
749  }
750  void TOntology::DelUpDIdV(const int& CptId, const TIntV& SubDIdV) {
751      GetConcept(CptId)->DelDIdV(BowDocWgtBs, SubDIdV);
752      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
753      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
754          const int SuperCptId = SuperCptIdV[SuperCptIdN];
755          if (!IsRootCpt(SuperCptId)) { DelUpDIdV(SuperCptId, SubDIdV); }
756      }
757  }
758  void TOntology::DelDownDIdV(const int& CptId, const TIntV& SubDIdV) {
759      GetConcept(CptId)->DelDIdV(BowDocWgtBs, SubDIdV);
760      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
761      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
762          const int SubCptId = SubCptIdV[SubCptIdN];
763          DelDownDIdV(SubCptId, SubDIdV);
764      }
765  }
766  void TOntology::DelDownDId(const int& CptId, const int& DId) {
767      GetConcept(CptId)->DelDId(BowDocWgtBs, DId);
768      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
769      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
770          const int SubCptId = SubCptIdV[SubCptIdN];
771          DelDownDId(SubCptId, DId);
772      }
773  }
774  void TOntology::GetCptInRltV(const int& CptId, TIntStrPrV& InRltV) {
775      POntoConcept Cpt = GetConcept(CptId);
776      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
777      InRltV.Gen(CptVrtx->GetInEIds(), 0);
778      for (int InEIdN = 0; InEIdN < CptVrtx->GetInEIds(); InEIdN++) {
779          PEdge InEdge = OntoGraph->GetEdge(CptVrtx->GetInEId(InEIdN));
780          if (InEdge->IsDir()) 
781              InRltV.Add(TIntStrPr(InEdge->GetOtherVId(CptVrtx), InEdge->GetDNm()));
782      }
783      InRltV.Sort();
784  }
785  void TOntology::GetCptOutRltV(const int& CptId, TIntStrPrV& OutRltV) {
786      POntoConcept Cpt = GetConcept(CptId);
787      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
788      OutRltV.Gen(CptVrtx->GetOutEIds(), 0);
789      for (int OutEIdN = 0; OutEIdN < CptVrtx->GetOutEIds(); OutEIdN++) {
790          PEdge OutEdge = OntoGraph->GetEdge(CptVrtx->GetOutEId(OutEIdN));
791          if (OutEdge->IsDir()) 
792              OutRltV.Add(TIntStrPr(OutEdge->GetOtherVId(CptVrtx), OutEdge->GetDNm()));
793      }
794      OutRltV.Sort();
795  }
796  void TOntology::GetCptUndirRltV(const int& CptId, TIntStrPrV& UndirRltV) {
797      POntoConcept Cpt = GetConcept(CptId);
798      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
799      UndirRltV.Gen(CptVrtx->GetOutEIds(), 0);
800      for (int OutEIdN = 0; OutEIdN < CptVrtx->GetOutEIds(); OutEIdN++) {
801          PEdge OutEdge = OntoGraph->GetEdge(CptVrtx->GetOutEId(OutEIdN));
802          if (!OutEdge->IsDir()) 
803              UndirRltV.Add(TIntStrPr(OutEdge->GetOtherVId(CptVrtx), OutEdge->GetDNm()));
804      }
805      UndirRltV.Sort();
806  }
807  void TOntology::GetCptRltV(const int& CptId, TIntStrPrV& InRltV, 
808          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV) {
809      GetCptInRltV(CptId, InRltV);
810      GetCptOutRltV(CptId, OutRltV); 
811      GetCptUndirRltV(CptId, UndirRltV); 
812  }
813  int TOntology::GetRltTypeN(const TStr& RltTypeNm) const {
814      for (int RltTypeN = 0; RltTypeN < RltTypeV.Len(); RltTypeN++) {
815          if (RltTypeV[RltTypeN].IsType(RltTypeNm)) {
816              return RltTypeN;
817          }
818      }
819      return -1;
820  }
821  bool TOntology::IsRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
822      Assert(IsCptId(CptId1) && IsCptId(CptId2));
823      PEdge Edge; 
824      if (OntoGraph->IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
825          return (Edge->GetDNm() == RltTypeNm);
826      }
827      return false;
828  }
829  void TOntology::AddRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
830      Assert(IsCptId(CptId1) && IsCptId(CptId2));
831      const bool IsDir = IsRltDir(RltTypeNm);
832      PEdge NewEdge = TGEdge::New(OntoGraph->GetVrtx(CptId1), 
833          OntoGraph->GetVrtx(CptId2), RltTypeNm, IsDir);
834      NewEdge->PutDNm(RltTypeNm);
835      OntoGraph->AddEdge(NewEdge);
836  }
837  bool TOntology::DelRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
838      Assert(IsCptId(CptId1) && IsCptId(CptId2));
839      PEdge Edge; bool DeletedP = false;
840      if (OntoGraph->IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
841          if (Edge->GetDNm() == RltTypeNm) {
842              OntoGraph->DelEdge(Edge);
843              DeletedP = true;
844          } else {
845              InfoNotify("There is no such relationship!!");
846          }
847      } else {
848          InfoNotify("There is no such relationship");
849          AssertR(false, TStr("There is no such relationship"));
850      }
851      ReconnectToRoot();
852      return DeletedP;
853  }
854  void TOntology::SuggestConcepts(const TIntV& DIdV, const TOntoSuggestAlgType& AlgType, 
855          const int& NewConceptN, TOntoConceptV& NewConceptV) {
856      NewConceptV.Clr();
857      if ((DIdV.Len() > NewConceptN) || (NewConceptN == -1)) {
858          if (AlgType == osatKMeans) {
859              TOntoAlg::SuggestKMeans(BowDocBs, BowDocWgtBs, DIdV, 
860                  NewConceptN, UniqueId, NewConceptV);
861          } else if (AlgType == osatCat) {
862              TOntoAlg::SuggestCat(BowDocBs, BowDocWgtBs, DIdV, 
863                  UniqueId, NewConceptV);
864          }
865      }
866  }
867  void TOntology::SuggestSubconcepts(const int& CptId, const TOntoSuggestAlgType& AlgType, 
868          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV) {
869      TIntV DIdV; 
870      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
871      else {  GetConcept(CptId)->GetDIdV(DIdV); }
872      SuggestConcepts(DIdV, AlgType, NewConceptN, NewConceptV);
873  }
874  void TOntology::SuggestSubconcepts(const int& CptId, const PLwOntoCfier& LwOntoCfier,
875          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV) {
876      TIntV DIdV; 
877      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
878      else {  GetConcept(CptId)->GetDIdV(DIdV); }
879      NewConceptV.Clr();
880      if (DIdV.Len() > NewConceptN) {
881          TOntoAlg::SuggestLwOntoCfier(BowDocBs, BowDocWgtBs,
882              DIdV, LwOntoCfier, NewConceptN, UniqueId, NewConceptV);
883      }
884  }
885  POntoConcept TOntology::GenSubconcept(const TStr& NewCptNm, const TIntV& NewCptDIdV) {
886      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
887          UniqueId->GetNextId(), NewCptNm, NewCptDIdV);
888  }
889  POntoConcept TOntology::GenSubconcept(const TIntV& NewCptDIdV) {
890      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
891          UniqueId->GetNextId(), NewCptDIdV);
892  }
893  void TOntology::SuggestConceptNm(const int& CptId, const TVec<PLwOntoCfier>& LwOntoCfierV, 
894          const int& MxSuggestNms, TStrV& SuggestNmV, TIntV& SuggestSuppV, TIntV& SuggestVocNV) {
895      TIntPrIntH TermIdVocNFqH; TIntV DIdV; GetCptDIdV(CptId, DIdV); 
896      for (int VocN = 0; VocN < LwOntoCfierV.Len(); VocN++) {
897          PLwOntoCfier LwOntoCfier = LwOntoCfierV[VocN];
898          PLwTermBs LwTermBs = LwOntoCfier->GetLwOnto()->GetTermBs();
899          for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
900              const int DId = DIdV[DIdN];
901              TStr DocStr = BowDocBs->GetDocStr(DId);
902              TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
903              LwOntoCfier->ClassifyStr(DocStr, SimTermIdPrV);
904              const int TermIds = TInt::GetMn(3, SimTermIdPrV.Len());
905              for (int TermIdN = 0; TermIdN < TermIds; TermIdN++) {
906                  const int TermId = SimTermIdPrV[TermIdN].Val2;
907                  TIntPr TermIdVocN(TermId, VocN);
908                  TStr TermNm = LwTermBs->GetTerm(TermId)->GetTermNm();
909                  if (TermIdVocNFqH.IsKey(TermIdVocN)) { TermIdVocNFqH(TermIdVocN)++; } 
910                  else { TermIdVocNFqH.AddDat(TermIdVocN, 1); }
911              }             
912          }
913      }
914      TIntIntPrPrV TermFqIdVocNV; TermIdVocNFqH.GetDatKeyPrV(TermFqIdVocNV); 
915      TermFqIdVocNV.Sort(false);
916      SuggestNmV.Clr(); SuggestSuppV.Clr(); SuggestVocNV.Clr();
917      const int SuggestNms = TInt::GetMn(MxSuggestNms, TermFqIdVocNV.Len());
918      for (int SuggestNmN = 0; SuggestNmN < SuggestNms; SuggestNmN++) {
919          const int TermId = TermFqIdVocNV[SuggestNmN].Val2.Val1;
920          const int Supp = TermFqIdVocNV[SuggestNmN].Val1;
921          const int VocN = TermFqIdVocNV[SuggestNmN].Val2.Val2;
922          PLwTermBs LwTermBs = LwOntoCfierV[VocN]->GetLwOnto()->GetTermBs();
923          TStr TermNm = LwTermBs->GetTerm(TermId)->GetTermNm();
924          SuggestNmV.Add(TermNm); 
925          SuggestSuppV.Add(Supp); 
926          SuggestVocNV.Add(VocN);
927      }
928  }
929  void TOntology::AddConcept(const POntoConcept& NewCpt, const int& FatherCptId) {
930      const int NewCptId = NewCpt->GetId();
931      IAssertR(!IsCptId(NewCptId), "There already is a conceptwith the same ID!");
932      ConceptV.Add(NewCpt); RefreshCptIdPosH();
933      TStr NewCptIdStr = TStr::Fmt("Cpt%d", NewCptId);
934      PVrtx NewCptVrtx = TGVrtx::New(NewCptId, NewCptIdStr);
935      TStr Name = NewCpt->GetName(); Name.ChangeChAll(' ', '\\');
936      NewCptVrtx->PutDNm(Name); 
937      NewCptVrtx->PutShape("Rect");
938      OntoGraph->AddVrtx(NewCptVrtx);
939      if (FatherCptId >= 0) {
940          IAssertR(IsCptId(FatherCptId), "There is no such concept!");
941          AddRlt(NewCptId, FatherCptId, TOntoRltType::SubCptOfRltStr);
942      } else {
943          IAssert(ConceptV.Len() == 1);
944      }
945  }
946  void TOntology::BreakConcept(const int& OldCptId, const TOntoConceptV& NewCptV) {
947      if (IsRootCpt(OldCptId)) return; 
948      IAssert(!NewCptV.Empty());
949      IAssertR(IsCptId(OldCptId), "There is no such concept!");
950      for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
951          POntoConcept NewCpt = NewCptV[CptC];
952          const int NewCptId = NewCpt->GetId();
953          IAssertR(!IsCptId(NewCptId), 
954              "There already is a concept with the same ID!");
955          ConceptV.Add(NewCpt); RefreshCptIdPosH();
956          TStr Name = NewCpt->GetName(); Name.ChangeStrAll(" ", "\\");
957          PVrtx v = TGVrtx::New(NewCptId, Name.CStr());
958          OntoGraph->AddVrtx(v);
959      }
960      TIntStrPrV InRltV, OutRltV, UndirRltV;
961      GetCptRltV(OldCptId, InRltV, OutRltV, UndirRltV);
962      for (int InRltN = 0; InRltN < InRltV.Len(); InRltN++) { 
963          const int VrtxId1 = InRltV[InRltN].Val1;
964          TStr RltNm = InRltV[InRltN].Val2;
965          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
966              const int NewCptId = NewCptV[CptC]->GetId();
967              AddRlt(VrtxId1, NewCptId, RltNm);
968          }
969      }
970      for (int OutRltN = 0; OutRltN < OutRltV.Len(); OutRltN++) {
971          const int VrtxId2 = OutRltV[OutRltN].Val1;
972          TStr RltNm = OutRltV[OutRltN].Val2;
973          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
974              const int NewCptId = NewCptV[CptC]->GetId();
975              AddRlt(NewCptId, VrtxId2, RltNm);
976          }
977      }
978      for (int UndirRltN = 0; UndirRltN < UndirRltV.Len(); UndirRltN++) {
979          const int VrtxId2 = UndirRltV[UndirRltN].Val1;
980          TStr RltNm = UndirRltV[UndirRltN].Val2;
981          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
982              const int NewCptId = NewCptV[CptC]->GetId();
983              AddRlt(NewCptId, VrtxId2, RltNm);
984          }
985      }
986      ConceptV.Del(CptIdPosH.GetDat(OldCptId)); RefreshCptIdPosH();
987      OntoGraph->DelVrtx(OldCptId); ReconnectToRoot();
988  }
989  void TOntology::PruneSubconcept(const POntoConcept& SubCpt, const int& FatherCptId) {
990      if (FatherCptId == 0) return; 
991      IAssertR(IsCptId(FatherCptId), "There is no such concept!");
992      TIntV SubCptDIdV; SubCpt->GetDIdV(SubCptDIdV);
993      GetConcept(FatherCptId)->DelDIdV(BowDocWgtBs, SubCptDIdV);
994  }
995  void TOntology::DeleteConcept(const int& CptId, const bool& DoRedirect) {
996      if (IsRootCpt(CptId)) return; 
997      IAssertR(IsCptId(CptId), "There is no such concept!");
998      if (DoRedirect) {
999          TIntStrPrV InRltV, OutRltV, UndirRltV;
1000          GetCptRltV(CptId, InRltV, OutRltV, UndirRltV);
1001          AddRltsFromList(InRltV, OutRltV, UndirRltV);
1002      }
1003      ConceptV.Del(CptIdPosH.GetDat(CptId)); RefreshCptIdPosH();
1004      OntoGraph->DelVrtx(CptId); ReconnectToRoot();
1005  }
1006  void TOntology::UniteConcepts(const int& CptId1, const int& CptId2) {
1007  }
1008  void TOntology::CopyConcept(const int& CptId, const int NewFatherCptId, const bool& MoveP) {
1009      if (IsRootCpt(CptId)) return; 
1010      IAssertR(IsCptId(CptId), "There is no such concept!");
1011      IAssertR(IsCptId(NewFatherCptId), "There is no such concept!");
1012      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
1013      SuperCptIdV.DelIfIn(NewFatherCptId);
1014      if (SuperCptIdV.Empty()) return; 
1015      AddRlt(CptId, NewFatherCptId, TOntoRltType::SubCptOfRltStr);
1016      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
1017          const int SuperCptId = SuperCptIdV[SuperCptIdN];
1018          DelRlt(CptId, SuperCptId, TOntoRltType::SubCptOfRltStr);
1019      }
1020      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1021      if (MoveP) {
1022          for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
1023              const int SuperCptId = SuperCptIdV[SuperCptIdN];
1024              DelUpDIdV(SuperCptId, CptDIdV);
1025          }
1026      }
1027      AddUpDIdV(NewFatherCptId, CptDIdV);
1028  }
1029  void TOntology::NewConcept() {
1030      POntoConcept Cpt = TOntoConcept::New(BowDocBs, 
1031          BowDocWgtBs, UniqueId->GetNextId(), "New Concept", TIntV());
1032      IAssert(ConceptV[0]->GetId() == 0);
1033      AddConcept(Cpt, 0);
1034  }
1035  void TOntology::ExtractKeywords(const int& CptId) {
1036      if (IsRootCpt(CptId)) return;
1037      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1038      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1039      PBowSpV SvmSpV;
1040      if (CptDIdV.Len() > 0) {
1041          SvmSpV = TBowSVMMd::GetKeywords(BowDocBs, ContextDIdV, CptDIdV, 50, 1.0, 5.0);
1042      } else {
1043          SvmSpV = TBowSpV::New();
1044      }
1045      GetConcept(CptId)->SetSvmSpV(SvmSpV);
1046  }
1047  void TOntology::CalcCptCompactness(const int& CptId) {
1048      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1049      if (CptDIdV.Len() > 0) {
1050          PBowSpV CentroidSpV = GetConcept(CptId)->GetCentroidSpV();
1051          double Qual = 0.0; 
1052          for (int DIdN = 0; DIdN < CptDIdV.Len(); DIdN++) {
1053              const int DId = CptDIdV[DIdN];
1054              PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
1055              Qual += BowSim->GetSim(CentroidSpV, DocSpV);
1056          }
1057          GetConcept(CptId)->SetCompactness(Qual / CptDIdV.Len());
1058      } else {
1059          GetConcept(CptId)->SetCompactness(1.0);
1060      }
1061  }
1062  void TOntology::CalcCptClarity(const int& CptId) {
1063      if (IsRootCpt(CptId)) return;
1064      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1065      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1066      if (CptDIdV.Len() > 20) {
1067          TCfyRes CfyRes = TBowSVMMd::CrossValidClsLinear(
1068              5, 1, BowDocBs, BowDocWgtBs, ContextDIdV, CptDIdV, 1, 5.0);
1069          const double Clarity = CfyRes.BreakEvenPoint();
1070          GetConcept(CptId)->SetClarity(Clarity);
1071      }
1072  }
1073  void TOntology::PrepareGraph(const int& SelectedCptId) {
1074      IAssert(GetConcepts() > 0);
1075      if (IsCptId(SelectedCptId)) {
1076          TStr VrtxNm = OntoGraph->GetVrtx(SelectedCptId)->GetDNm();
1077          OntoGraph->GetPp()->PutValStr("BoldVNm", VrtxNm);
1078      }
1079  }
1080  void TOntology::PlaceGraph() {
1081      IAssert(GetConcepts() > 0);
1082      PVrtx RootVrtx = OntoGraph->GetVrtx(0);
1083      OntoGraph->PlaceGraphAsStar(RootVrtx, TOntoRltType::SubCptOfRltStr);
1084      OntoGraph->RescaleXY(0.1, RootVrtx);
1085  }
1086  void TOntology::ExportPTO(const TStr& FNm, const bool& DigLibP) { 
1087      PSOut SOut = TFOut::New(FNm);
1088      TStr BowFNm = FNm + ".bow"; BowDocBs->SaveBin(BowFNm);
1089      POntoExport OntoExport = TOntoExportPTO::New(SOut, DigLibP, BowFNm);
1090      this->Export(OntoExport);
1091  }
1092  void TOntology::ExportProlog(const TStr& FNm) {
1093      PSOut SOut = TFOut::New(FNm);
1094      POntoExport OntoExport = TOntoExportProlog::New(SOut);
1095      this->Export(OntoExport);
1096  }
1097  void TOntology::ExportOwl(const TStr& FNm, const bool& StoreDocsP, const bool& StoreAbstractsP) {
1098      PSOut SOut = TFOut::New(FNm);
1099      POntoExport OntoExport = TOntoExportOWL::New(SOut, StoreDocsP, StoreAbstractsP);
1100      this->Export(OntoExport);
1101  }
1102  POntology TOntology::ImportPTO(const TStr& RdfFNm, const TStr& BowFNm) {
1103      PBowDocBs BowDocBs = TBowDocBs::LoadBin(BowFNm);
1104      const int MnWordFq = BowDocBs->GetDocs() > 111 ? 5 : 3;
1105      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1106          BowDocBs, bwwtLogDFNrmTFIDF, 0.2, MnWordFq);
1107      POntology Onto = TOntology::New(BowDocBs, BowDocWgtBs, bstCos);
1108      PXmlDoc Rdf = TXmlDoc::LoadTxt(RdfFNm);
1109      IAssertR(Rdf->IsOk(), "Wrong RDF format");
1110      TStrIntH TopicUriIdH;
1111      PXmlTok RootTok; IAssert(Rdf->IsTagTok("rdf:RDF", RootTok));
1112      TXmlTokV TopicV; RootTok->GetTagTokV("ptop:Topic", TopicV);
1113      TXmlTokV DocV; RootTok->GetTagTokV("ptop:Document", DocV);
1114      TXmlTokV DocPropV; RootTok->GetTagTokV("jsikm:OntoGenInstanceProperties", DocPropV);
1115      TIntIntVH TopicIdDocIdVH; TopicIdDocIdVH.AddDat(0, TIntV());
1116      for (int TopicN = 0; TopicN < TopicV.Len(); TopicN++) {
1117          PXmlTok TopicTok = TopicV[TopicN];
1118          TStr TopicURI = TopicTok->GetArgVal("rdf:about");
1119          TStr TopicName = TopicTok->GetTagTok("psys:description")->GetTagTokStr("");
1120          int UnderScorePos = TopicURI.SearchCh('_');
1121          TStr TopicURIPrefix = TopicURI.Left(UnderScorePos);
1122          if (TopicURIPrefix != "#Cpt0" && TopicURI != "#TOP_0") {
1123              const int TopicId = Onto->UniqueId->GetNextId(); 
1124              POntoConcept TopicCpt = TOntoConcept::New(Onto->BowDocBs, 
1125                  Onto->BowDocWgtBs, TopicId, TopicName, TIntV());
1126              Onto->AddConcept(TopicCpt, 0);
1127              TopicUriIdH.AddDat(TopicURI, TopicId);
1128              TopicIdDocIdVH.AddDat(TopicId, TIntV());
1129          } else {
1130              Onto->SetCptName(0, TopicName);
1131              TopicUriIdH.AddDat(TopicURI, 0);
1132          }        
1133      }
1134      for (int TopicN = 0; TopicN < TopicV.Len(); TopicN++) {
1135          PXmlTok TopicTok = TopicV[TopicN];
1136          TStr TopicURI = TopicTok->GetArgVal("rdf:about");
1137          const int TopicId = TopicUriIdH.GetDat(TopicURI);
1138          bool ConnectedToRoot = false;
1139          if (TopicId > 0) {
1140              TXmlTokV SuperTopicV; TopicTok->GetTagTokV("ptop:subTopicOf", SuperTopicV);
1141              for (int SupTopN = 0; SupTopN < SuperTopicV.Len(); SupTopN++) {
1142                  TStr SuperTopicURI = SuperTopicV[SupTopN]->GetArgVal("rdf:resource");
1143                  const int SuperTopicId = TopicUriIdH.GetDat(SuperTopicURI);
1144                  if (SuperTopicId == 0) {
1145                      ConnectedToRoot = true;
1146                  } else {            
1147                      Onto->AddRlt(TopicId, SuperTopicId, TOntoRltType::SubCptOfRltStr);
1148                  }
1149              }
1150              if (!ConnectedToRoot) {
1151                  Onto->DelRlt(TopicId, 0, TOntoRltType::SubCptOfRltStr);
1152              }
1153          }
1154      }
1155      TStrIntH DocPropIdH;
1156      for (int DocN = 0; DocN < DocPropV.Len(); DocN++) {
1157          PXmlTok DocPropTok = DocPropV[DocN];
1158          TStr DocPropURI = DocPropTok->GetArgVal("rdf:about");
1159          TStr Link = DocPropTok->GetTagTok("jsikm:locationOfInstance")->GetTagTokStr("");
1160          TStrV LinkPartV; Link.SplitOnAllCh('#', LinkPartV);
1161          IAssert(LinkPartV.Len() == 2);
1162          const int DocId = LinkPartV[1].GetInt();
1163          IAssert(BowDocBs->IsDId(DocId));
1164          DocPropIdH.AddDat(DocPropURI, DocId);
1165      }
1166      for (int DocN = 0; DocN < DocV.Len(); DocN++) {
1167          PXmlTok DocTok = DocV[DocN];
1168          TStr DocPropURI = DocTok->GetTagTok("jsikm:hasOntoGenInstanceProperties")->GetArgVal("rdf:resource");
1169          const int DocId = DocPropIdH.GetDat(DocPropURI);
1170          TopicIdDocIdVH.GetDat(0).Add(DocId);
1171          TXmlTokV SubjectTopicV; DocTok->GetTagTokV("ptop:hasSubject", SubjectTopicV);
1172          for (int SubjectN = 0; SubjectN < SubjectTopicV.Len(); SubjectN++) {
1173              PXmlTok SubjectTok = SubjectTopicV[SubjectN];
1174              TStr SubjectUri = SubjectTok->GetArgVal("rdf:resource");
1175              const int SubjectId = TopicUriIdH.GetDat(SubjectUri);
1176              if (SubjectId > 0) {
1177                  IAssert(TopicIdDocIdVH.IsKey(SubjectId));
1178                  TopicIdDocIdVH.GetDat(SubjectId).Add(DocId);
1179              }
1180          }
1181      }
1182      int KeyId = TopicIdDocIdVH.FFirstKeyId();
1183      while (TopicIdDocIdVH.FNextKeyId(KeyId)) {
1184          const int TopicId = TopicIdDocIdVH.GetKey(KeyId);
1185          Onto->SetCptDIdV(TopicId, TopicIdDocIdVH.GetDat(TopicId), false);
1186      }
1187      return Onto;
1188  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowclust.cpp</h3>
            <pre><code>1  void TBowDocPartClust::CalcEntropy(const PBowDocBs& BowDocBs){
2    int Docs=GetDocs();
3    int Cats=BowDocBs->GetCats();
4    TFltV CatWgtV(Cats);
5    double SumCatWgt=0;
6    for (int DIdN=0; DIdN<Docs; DIdN++){
7      int DId=DIdV[DIdN];
8      int DocCats=BowDocBs->GetDocCIds(DId);
9      for (int DocCIdN=0; DocCIdN<DocCats; DocCIdN++){
10        int CId=BowDocBs->GetDocCId(DId, DocCIdN);
11        double CatWgt=1/double(DocCats);
12        CatWgtV[CId]+=CatWgt; SumCatWgt+=CatWgt;
13      }
14    }
15    int NonZeroCatWgts=0;
16    if (SumCatWgt>0){
17      for (int CId=0; CId<Cats; CId++){
18        CatWgtV[CId]/=SumCatWgt;
19        if (double(CatWgtV[CId])!=0){NonZeroCatWgts++;}
20      }
21    }
22    CIdPrbKdV.Gen(NonZeroCatWgts, 0); Entropy=0;
23    for (int CId=0; CId<Cats; CId++){
24      double Prb=CatWgtV[CId];
25      if (Prb>0){
26        Entropy-=Prb*log(Prb);
27        CIdPrbKdV.Add(TIntFltKd(CId, Prb));
28      }
29    }
30  }
31  void TBowDocPartClust::GetTopWordStrWgtPrV(
32   const PBowDocBs& BowDocBs,
33   const int& TopWords, const double& TopWordsWgtPrc,
34   TStrFltPrV& WordStrWgtPrV) const {
35    int WIds=GetConceptWords();
36    TFltIntKdV WordWgtIdKdV(WIds); double WordWgtSum=0;
37    for (int WIdN=0; WIdN<WIds; WIdN++){
38      int WId; double WordWgt;
39      GetConceptSpV()->GetWIdWgt(WIdN, WId, WordWgt);
40      WordWgtSum+=WordWgt;
41      WordWgtIdKdV[WIdN]=TFltIntKd(WordWgt, WId);
42    }
43    WordWgtIdKdV.Sort(false);
44    double CutWordWgtSum=TopWordsWgtPrc*WordWgtSum;
45    WordStrWgtPrV.Clr();
46    {for (int WIdN=0; WIdN<WIds; WIdN++){
47      double WordWgt=WordWgtIdKdV[WIdN].Key;
48      int WId=WordWgtIdKdV[WIdN].Dat;
49      TStr WordStr=BowDocBs->GetWordStr(WId);
50      WordStrWgtPrV.Add(TStrFltPr(WordStr, WordWgt));
51      if ((TopWords!=-1)&&(1+WIdN>=TopWords)){break;}
52      CutWordWgtSum-=WordWgt; if (CutWordWgtSum<0){break;}
53    }}
54  }
55  double TBowDocPartClust::GetCatPrb(const int& CId) const {
56    int CatN;
57    if (CIdPrbKdV.IsIn(TIntFltKd(CId, 0), CatN)){
58      return CIdPrbKdV[CatN].Dat;
59    } else {
60      return 0;
61    }
62  }
63  int TBowDocPartClust::GetMxPrbCId() const {
64    int MxCId=-1; double MxPrb=0;
65    int CIdPrbs=GetCIdPrbs();
66    for (int CIdPrbN=0; CIdPrbN<CIdPrbs; CIdPrbN++){
67      int CId; double Prb; GetCIdPrb(CIdPrbN, CId, Prb);
68      if ((CIdPrbN==0)||(Prb>MxPrb)){MxCId=CId; MxPrb=Prb;}
69    }
70    return MxCId;
71  }
72  void TBowDocPart::GetTopClustSimV(
73   const double& ClustSimSumPrc, TFltIntIntTrV& ClustSimN1N2TrV) const {
74    ClustSimN1N2TrV.Clr();
75    int Clusts=GetClusts();
76    double ClustSimSum=0;
77    for (int ClustN1=0; ClustN1<Clusts; ClustN1++){
78      for (int ClustN2=ClustN1+1; ClustN2<Clusts; ClustN2++){
79        double ClustSim=GetClustSim(ClustN1, ClustN2);
80        ClustSimN1N2TrV.Add(TFltIntIntTr(ClustSim, ClustN1, ClustN2));
81        ClustSimSum+=ClustSim;
82      }
83    }
84    ClustSimN1N2TrV.Sort(false);
85    double CutClustSimSum=(1-ClustSimSumPrc)*ClustSimSum;
86    while (!ClustSimN1N2TrV.Empty()){
87      CutClustSimSum-=ClustSimN1N2TrV.Last().Val1;
88      if (CutClustSimSum<=0){
89        break;
90      } else {
91        ClustSimN1N2TrV.DelLast();
92      }
93    }
94  }
95  int TBowDocPart::GetDocs() const {
96    int Docs=0;
97    int Clusts=GetClusts();
98    for (int ClustN=0; ClustN<Clusts; ClustN++){
99      Docs+=GetClust(ClustN)->GetDocs();}
100    return Docs;
101  }
102  void TBowDocPart::GetDIdV(TIntV& DIdV) const {
103    DIdV.Gen(GetDocs(), 0);
104    int Clusts=GetClusts();
105    for (int ClustN=0; ClustN<Clusts; ClustN++){
106      TIntV DIdV; GetClust(ClustN)->GetDIdV(DIdV);
107      DIdV.AddV(DIdV);
108    }
109  }
110  int TBowDocPart::GetBestClust(const PBowSpV& SpV, const PBowSim& BowSim) const {
111    int BestClustN=-1; double BestSim=0;
112    int Clusts=GetClusts(); IAssert(Clusts>0);
113    for (int ClustN=0; ClustN<Clusts; ClustN++){
114      PBowDocPartClust Clust=GetClust(ClustN);
115      IAssert(Clust->IsConceptSpV());
116      double Sim=BowSim->GetSim(SpV, Clust->GetConceptSpV());
117      if ((BestClustN==-1)||(Sim>BestSim)){
118        BestClustN=ClustN; BestSim=Sim;
119      }
120    }
121    return BestClustN;
122  }
123  int TBowDocPart::GetBestCId(const PBowSpV& SpV, const PBowSim& BowSim) const {
124    int BestClustN=GetBestClust(SpV, BowSim);
125    PBowDocPartClust BestClust=GetClust(BestClustN);
126    int BestCId=-1;
127    if (BestClust->IsSubPart()){
128      BestCId=BestClust->GetSubPart()->GetBestCId(SpV, BowSim);
129    } else {
130      BestCId=BestClust->GetMxPrbCId();
131    }
132    return BestCId;
133  }
134  void TBowDocPart::GetClustSimV(
135   const PBowSpV& SpV, const PBowSim& BowSim, TIntFltKdV& ClustSimV) const {
136    int Clusts=GetClusts(); IAssert(Clusts>0);
137    ClustSimV.Gen(Clusts, 0);
138    for (int ClustN=0; ClustN<Clusts; ClustN++){
139      PBowDocPartClust Clust=GetClust(ClustN);
140      IAssert(Clust->IsConceptSpV());
141      double Sim=BowSim->GetSim(SpV, Clust->GetConceptSpV());
142      ClustSimV.Add(TIntFltKd(ClustN, Sim));
143    }
144    IAssert(ClustSimV.Len() == Clusts);
145  }
146  void TBowDocPart::GetDefClustNmV(const TStr& ClustNmPfx, TStrV& ClustNmV) const {
147    for (int ClustN=0; ClustN<GetClusts(); ClustN++){
148      TStr ClustNm=ClustNmPfx+"_"+TInt::GetStr(ClustN);
149      ClustNmV.Add(ClustNm);
150      PBowDocPartClust Clust=GetClust(ClustN);
151      if (Clust->IsSubPart()){
152        PBowDocPart SubPart=Clust->GetSubPart();
153        SubPart->GetDefClustNmV(ClustNm, ClustNmV);
154      }
155    }
156  }
157  void TBowDocPart::GetDefClustNmV(TStrV& ClustNmV) const {
158    ClustNmV.Clr();
159    for (int ClustN=0; ClustN<GetClusts(); ClustN++){
160      TStr ClustNm=TStr("C")+TInt::GetStr(ClustN);
161      ClustNmV.Add(ClustNm);
162      PBowDocPartClust Clust=GetClust(ClustN);
163      if (Clust->IsSubPart()){
164        PBowDocPart SubPart=Clust->GetSubPart();
165        SubPart->GetDefClustNmV(ClustNm, ClustNmV);
166      }
167    }
168  }
169  void TBowDocPart::GetCfClustNmV(
170   const PBowSpV TestDocSpV, const PBowSim& BowSim, TStrV& ClustNmV) const {
171    int ClustN=GetBestClust(TestDocSpV, BowSim);
172    PBowDocPartClust Clust=GetClust(ClustN);
173    TStr ClustNm=ClustNmV.Last()+"_"+TInt::GetStr(ClustN);
174    ClustNmV.Add(ClustNm);
175    if (Clust->IsSubPart()){
176      PBowDocPart SubPart=Clust->GetSubPart();
177      SubPart->GetCfClustNmV(TestDocSpV, BowSim, ClustNmV);
178    }
179  }
180  void TBowDocPart::GetCfClustNmVV(
181   const PBowDocBs& BowDocBs, const TBowWordWgtType& WordWgtType,
182   const PBowSim& BowSim, const TIntV& TrainDIdV, const TIntV& TestDIdV,
183   TVec<TStrV>& ClustNmVV, TVec<TBowDocPartClustV>& ClustVV) const {
184    PBowDocWgtBs TrainDocWgtBs=
185     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TrainDIdV);
186    PBowDocWgtBs TestDocWgtBs=
187     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TestDIdV, TrainDIdV);
188    int TestDocs=TestDocWgtBs->GetDocs();
189    ClustNmVV.Clr(); ClustVV.Clr();
190    for (int TestDIdN=0; TestDIdN<TestDocs; TestDIdN++){
191      int TestDId=TestDIdV[TestDIdN];
192      PBowSpV TestDocSpV=TestDocWgtBs->GetSpV(TestDId);
193      TStrV ClustNmV;
194      int ClustN=GetBestClust(TestDocSpV, BowSim);
195      PBowDocPartClust Clust=GetClust(ClustN);
196      TStr ClustNm=TStr("C")+TInt::GetStr(ClustN);
197      ClustNmV.Add(ClustNm);
198      if (Clust->IsSubPart()){
199        PBowDocPart SubPart=Clust->GetSubPart();
200        SubPart->GetCfClustNmV(TestDocSpV, BowSim, ClustNmV);
201      }
202      ClustNmVV.Add(ClustNmV); ClustVV.Add(ClustV);
203    }
204  }
205  void TBowDocPart::SaveXmlCfClustNmVV(
206   const PBowDocBs& BowDocBs, const TBowWordWgtType& WordWgtType,
207   const PBowSim& BowSim, const TIntV& TrainDIdV, const TIntV& _TestDIdV,
208   const TStr& FNm){
209    TIntV TestDIdV;
210    if (_TestDIdV.Empty()){BowDocBs->GetAllDIdV(TestDIdV);}
211    else {TestDIdV=_TestDIdV;}
212    TVec<TStrV> CfClustNmVV; TVec<TBowDocPartClustV> CfClustVV;
213    GetCfClustNmVV(
214     BowDocBs, WordWgtType, BowSim, TrainDIdV, TestDIdV, CfClustNmVV, CfClustVV);
215    TFOut SOut(FNm); TFileId OutFId=SOut.GetFileId();
216    fprintf(OutFId, "<DocClusterCf>\n");
217    fprintf(OutFId, "<ClusterDefs>\n");
218    TStrV DefClustNmV; GetDefClustNmV(DefClustNmV);
219    for (int DefClustNmN=0; DefClustNmN<DefClustNmV.Len(); DefClustNmN++){
220      fprintf(OutFId, "<ClusterDef>%s</ClusterDef>\n", DefClustNmV[DefClustNmN].CStr());}
221    fprintf(OutFId, "</ClusterDefs>\n");
222    fprintf(OutFId, "<DocCfs>\n");
223    int TestDocs=TestDIdV.Len();
224    for (int TestDIdN=0; TestDIdN<TestDocs; TestDIdN++){
225      int TestDId=TestDIdV[TestDIdN];
226      TStr TestDocNm=BowDocBs->GetDocNm(TestDId);
227      fprintf(OutFId, "<DocCf Nm=\"%s\">", TestDocNm.CStr());
228      TStrV& CfClustNmV=CfClustNmVV[TestDIdN];
229      for (int CfClustNmN=0; CfClustNmN<CfClustNmV.Len(); CfClustNmN++){
230        fprintf(OutFId, "<ClusterCf>%s</ClusterCf>", CfClustNmV[CfClustNmN].CStr());
231      }
232      fprintf(OutFId, "</DocCf>\n");
233    }
234    fprintf(OutFId, "</DocCfs>\n");
235    fprintf(OutFId, "</DocClusterCf>\n");
236  }
237  void TBowDocPart::GetAreaPart(
238   const TFltRect& Rect, TClustRectPrV& ClustRectPrV, const bool& ShuffleP) const {
239    int Clusts=GetClusts(); int Docs=GetDocs();
240    if ((Clusts==0)||(Docs==0)){return;}
241    double PrevMxX=Rect.MnX; double PrevMxY=Rect.MnY;
242    TIntV ClustNV(Clusts, 0);
243    for (int ClustN=0; ClustN<Clusts; ClustN++){ClustNV.Add(ClustN);}
244    if (ShuffleP){TRnd Rnd; ClustNV.Shuffle(Rnd);}
245    for (int ClustN=0; ClustN<Clusts; ClustN++){
246      PBowDocPartClust Clust=GetClust(ClustNV[ClustN]);
247      int ClustDocs=Clust->GetDocs();
248      TFltRect SubRect;
249      if (Rect.GetXLen()>=Rect.GetYLen()){
250        SubRect.MnX=PrevMxX;
251        SubRect.MxX=PrevMxX=PrevMxX+(ClustDocs/double(Docs))*Rect.GetXLen();
252        SubRect.MnY=Rect.MnY;
253        SubRect.MxY=Rect.MxY;
254      } else {
255        SubRect.MnX=Rect.MnX;
256        SubRect.MxX=Rect.MxX;
257        SubRect.MnY=PrevMxY;
258        SubRect.MxY=PrevMxY=PrevMxY+(ClustDocs/double(Docs))*Rect.GetYLen();
259      }
260      ClustRectPrV.Add(TClustRectPr(Clust, SubRect));
261      if (Clust->IsSubPart()){
262        PBowDocPart SubPart=Clust->GetSubPart();
263        SubPart->GetAreaPart(SubRect, ClustRectPrV);
264      }
265    }
266  }
267  void TBowDocPart::GetClustAtXY(const double& X, const double Y,
268   const TClustRectPrV& ClustRectPrV, const bool& LeafPartP,
269   TBowDocPartClustV& ClustV){
270    ClustV.Clr();
271    for (int ClustRectPrN=0; ClustRectPrN<ClustRectPrV.Len(); ClustRectPrN++){
272      PBowDocPartClust Clust=ClustRectPrV[ClustRectPrN].Val1;
273      TFltRect Rect=ClustRectPrV[ClustRectPrN].Val2;
274      if (Rect.IsXYIn(X, Y)){
275        if (((LeafPartP)&&(!Clust->IsSubPart()))||(!LeafPartP)){
276          ClustV.Add(Clust);
277        }
278      }
279    }
280  }
281  void TBowDocPart::SavePartEntropyTxt(
282   const PSOut& SOut, const PBowDocBs& BowDocBs) const {
283    int Clusts=GetClusts();
284    SOut->PutStr("----------------------------\n");
285    SOut->PutStr("Inter Cluster Similarity\n");
286    for (int ClustN=0; ClustN<Clusts; ClustN++){
287      SOut->PutInt(ClustN, "\tC-%d");}
288    SOut->PutLn();
289    for (int ClustN1=0; ClustN1<Clusts; ClustN1++){
290      SOut->PutInt(ClustN1, "C-%d");
291      for (int ClustN2=0; ClustN2<Clusts; ClustN2++){
292        if (ClustN1>=ClustN2){
293          SOut->PutStr("\t.");
294        } else {
295          double Sim=GetClustSim(ClustN1, ClustN2);
296          SOut->PutFlt(Sim, "\t%.3f");
297        }
298      }
299      SOut->PutLn();
300    }
301    SOut->PutStr("----------------------------\n");
302    SOut->PutStr("Cluster Summaries\n");
303    {for (int ClustN=0; ClustN<Clusts; ClustN++){
304      PBowDocPartClust Clust=GetClust(ClustN);
305      SOut->PutInt(ClustN, "C-%d:");
306      SOut->PutFlt(Clust->GetEntropy(), " [Entropy %0.3f]");
307      SOut->PutFlt(Clust->GetMeanSim(), " [Mean Sim. %0.2f]");
308      SOut->PutInt(Clust->GetDocs(), " [%d Docs.]");
309      SOut->PutInt(Clust->GetConceptWords(), " [%d Words]\n");
310    }}
311    SOut->PutStr("----------------------------\n");
312    SOut->PutStr("Category/Cluster Probabilities\n");
313    SOut->PutStr(" ", "%20s");
314    {for (int ClustN=0; ClustN<Clusts; ClustN++){
315      SOut->PutInt(ClustN, "\tC-%d");
316    }}
317    SOut->PutLn();
318    for (int CId=0; CId<BowDocBs->GetCats(); CId++){
319      SOut->PutStr(BowDocBs->GetCatNm(CId), "%20s");
320      for (int ClustN=0; ClustN<Clusts; ClustN++){
321        PBowDocPartClust Clust=GetClust(ClustN);
322        SOut->PutStr("\t");
323        double CatPrb=Clust->GetCatPrb(CId);
324        if (CatPrb>0){
325          int MxPrbCId=Clust->GetMxPrbCId();
326          SOut->PutFlt(CatPrb, "%0.3f");
327          if (MxPrbCId==CId){SOut->PutStr("!");}
328        } else {SOut->PutStr(".");}
329      }
330      SOut->PutLn();
331    }
332  }
333  void TBowDocPart::SaveTxt(
334   const PSOut& SOut, const PBowDocBs& BowDocBs,
335   const bool& SaveWordsP, const int& TopWords, const double& TopWordsWgtPrc,
336   const bool& SaveDocsP, const TStr& PathStr) const {
337    SOut->PutStr("***********************************\n");
338    SOut->PutStr(PathStr, "Path: %s\n");
339    SOut->PutInt(GetClusts(), "Clusters: %d\n");
340    SOut->PutInt(GetDocs(), "Documents: %d\n");
341    SOut->PutFlt(GetQual(), "Quality: %g\n");
342    SOut->PutFlt(GetMeanSim(), "Mean Similarity: %.3f\n");
343    if (!GetNm().Empty()){
344      SOut->PutStr(GetNm(), "Name: \"%s\"\n");}
345    SOut->Flush();
346    for (int ClustN=0; ClustN<GetClusts(); ClustN++){
347      PBowDocPartClust Clust=GetClust(ClustN);
348      SOut->PutStr("===================================\n");
349      SOut->PutInt(ClustN, "Cluster-%d: ");
350      SOut->PutFlt(Clust->GetMeanSim(), " [Mean Sim. %0.3f]");
351      SOut->PutInt(Clust->GetDocs(), " [%d Docs.]");
352      SOut->PutInt(Clust->GetConceptWords(), " [%d Words]\n");
353      if (!Clust->GetNm().Empty()){
354        SOut->PutStr(Clust->GetNm(), "[Name: \"%s\"]\n");}
355      if ((SaveWordsP)&&(!BowDocBs.Empty())){
356        SOut->PutStr("---Words------------------------\n");
357        int WIds=Clust->GetConceptWords();
358        TFltIntKdV WordWgtIdKdV(WIds); double WordWgtSum=0;
359        for (int WIdN=0; WIdN<WIds; WIdN++){
360          int WId; double WordWgt;
361          Clust->GetConceptSpV()->GetWIdWgt(WIdN, WId, WordWgt);
362          WordWgtSum+=WordWgt;
363          WordWgtIdKdV[WIdN]=TFltIntKd(WordWgt, WId);
364        }
365        WordWgtIdKdV.Sort(false);
366        double WordWgtSumSF=0;
367        {for (int WIdN=0; WIdN<WIds; WIdN++){
368          if (TopWords==WIdN){break;}
369          if ((WordWgtSum>0)&&(WordWgtSumSF/WordWgtSum>TopWordsWgtPrc)){break;}
370          double WordWgt=WordWgtIdKdV[WIdN].Key;
371          WordWgtSumSF+=WordWgt;
372          int WId=WordWgtIdKdV[WIdN].Dat;
373          TStr WordStr=BowDocBs->GetWordStr(WId);
374          SOut->PutStr(WordStr, "'%s':");
375          SOut->PutFlt(WordWgt, "%.3f\n");
376        }}
377      }
378      SOut->Flush();
379      if (SaveDocsP){
380        SOut->PutStr("---Documents--------------------\n");
381        int Docs=Clust->GetDocs();
382        if (Clust->IsDCSimV()){
383          TFltIntPrV DCSimDIdPrV(Docs, 0);
384          for (int DIdN=0; DIdN<Docs; DIdN++){
385            DCSimDIdPrV.Add(TFltIntPr(Clust->GetDCSim(DIdN), Clust->GetDId(DIdN)));
386          }
387          DCSimDIdPrV.Sort(false);
388          {for (int DIdN=0; DIdN<Docs; DIdN++){
389            double DCSim=DCSimDIdPrV[DIdN].Val1;
390            int DId=DCSimDIdPrV[DIdN].Val2;
391            SOut->PutStr(BowDocBs->GetDocNm(DId), "'%s'");
392            SOut->PutFlt(DCSim, " : %g");
393            if (!BowDocBs->GetDocDescStr(DId).Empty()){
394              SOut->PutStr(BowDocBs->GetDocDescStr(DId), " [%s]");}
395            SOut->PutStr("\n");
396          }}
397        } else {
398          for (int DIdN=0; DIdN<Docs; DIdN++){
399            int DId=Clust->GetDId(DIdN);
400            SOut->PutStr(BowDocBs->GetDocNm(DId), "'%s'");
401            if (!BowDocBs->GetDocDescStr(DId).Empty()){
402              SOut->PutStr(BowDocBs->GetDocDescStr(DId), " [%s]");}
403            SOut->PutStr("\n");
404          }
405        }
406        if (Clust->IsDDSimVV()){
407          SOut->PutStr("---Intra-Document-Similarity----\n");
408          for (int DIdN1=0; DIdN1<Docs; DIdN1++){
409            int DId1=Clust->GetDId(DIdN1);
410            SOut->PutStr(BowDocBs->GetDocNm(DId1), "'%s': ");
411            for (int DIdN2=0; DIdN2<Docs; DIdN2++){
412              double DDSim=Clust->GetDDSim(DIdN1, DIdN2);
413              SOut->PutFlt(DDSim, " %.4f");
414            }
415            SOut->PutLn();
416          }
417        }
418      }
419    }
420    if (BowDocBs->GetCats()>0){
421      SavePartEntropyTxt(SOut, BowDocBs);}
422    {for (int ClustN=0; ClustN<GetClusts(); ClustN++){
423      PBowDocPart SubPart=GetClust(ClustN)->GetSubPart();
424      if (!SubPart.Empty()){
425        TStr NewPathStr=PathStr+"|"+TInt::GetStr(ClustN);
426        SubPart->SaveTxt(SOut, BowDocBs,
427         SaveWordsP, TopWords, TopWordsWgtPrc, SaveDocsP, NewPathStr);
428      }
429    }}
430    SOut->Flush();
431  }
432  void TBowDocPart::SaveXml(
433   const PSOut& SOut, const PBowDocBs& BowDocBs, const TStr& PathStr) const {
434    SOut->PutStr("<Partition");
435    SOut->PutStr(PathStr, " Path=\"%s\"");
436    SOut->PutInt(GetClusts(), " Clusts=\"%d\"");
437    SOut->PutInt(GetDocs(), " Documents=\"%d\"");
438    SOut->PutFlt(GetQual(), " Quality=\"%g\"");
439    SOut->PutFlt(GetMeanSim(), " MeanSimilarity=\"%g\"");
440    if (!GetNm().Empty()){
441      SOut->PutStr(GetNm(), " Name=\"%s\"");}
442    SOut->PutStr(">\n");
443    for (int ClustN=0; ClustN<GetClusts(); ClustN++){
444      PBowDocPartClust Clust=GetClust(ClustN);
445      SOut->PutStr("<Cluster");
446      SOut->PutInt(ClustN, " Id=\"%d\"");
447      SOut->PutFlt(Clust->GetQual(), " Quality=\"%g\"");
448      SOut->PutFlt(Clust->GetMeanSim(), " MeanSimilarity=\"%g\"");
449      SOut->PutFlt(Clust->GetEntropy(), " Entropy=\"%g\"");
450      if (!Clust->GetNm().Empty()){
451        SOut->PutStr(Clust->GetNm(), " Name=\"%s\"");}
452      SOut->PutStr(">\n");
453      if (BowDocBs->GetCats()>0){
454        int MxPrbCId=Clust->GetMxPrbCId();
455        SOut->PutStr("<ClassDistr");
456        SOut->PutInt(MxPrbCId, " BestId=\"%d\"");
457        SOut->PutStr(">");
458        for (int CId=0; CId<BowDocBs->GetCats(); CId++){
459          SOut->PutStr("<Class");
460          SOut->PutInt(CId, " Id=\"%d\"");
461          SOut->PutStr(BowDocBs->GetCatNm(CId), " Name=\"%s\"");
462          double CatPrb=Clust->GetCatPrb(CId);
463          SOut->PutFlt(CatPrb, " Prob=\"%g\"");
464          SOut->PutStr("/>");
465        }
466        SOut->PutStr("</ClassDistr>");
467      }
468      int Docs=Clust->GetDocs();
469      SOut->PutInt(Docs, "<Documents Count=\"%d\">\n");
470      for (int DIdN=0; DIdN<Docs; DIdN++){
471        int DId=Clust->GetDId(DIdN);
472        SOut->PutStr(BowDocBs->GetDocNm(DId), "<D Nm=\"%s\"");
473        SOut->PutInt(DId, " Id=\"%d\"");
474        if (!BowDocBs->GetDocDescStr(DId).Empty()){
475          SOut->PutStr(BowDocBs->GetDocDescStr(DId), " Desc=\"%s\"");}
476        SOut->PutStr("/>");
477      }
478      SOut->PutStr("</Documents>\n");
479      SOut->PutInt(Clust->GetConceptWords(), "<Words Count=\"%d\">\n");
480      if (!BowDocBs.Empty()){
481        int WIds=Clust->GetConceptWords();
482        TFltIntKdV WordWgtIdKdV(WIds);
483        for (int WIdN=0; WIdN<WIds; WIdN++){
484          int WId; double WordWgt;
485          Clust->GetConceptSpV()->GetWIdWgt(WIdN, WId, WordWgt);
486          WordWgtIdKdV[WIdN]=TFltIntKd(WordWgt, WId);
487        }
488        WordWgtIdKdV.Sort(false);
489        {for (int WIdN=0; WIdN<WIds; WIdN++){
490          double WordWgt=WordWgtIdKdV[WIdN].Key;
491          int WId=WordWgtIdKdV[WIdN].Dat;
492          SOut->PutStr(BowDocBs->GetWordStr(WId), "<W Nm=\"%s\" ");
493          SOut->PutInt(WId, "Id=\"%d\" ");
494          SOut->PutFlt(WordWgt, "Wgt=\"%g\"/>");
495        }}
496        SOut->PutLn();
497      }
498      SOut->PutStr("</Words>\n");
499      SOut->PutStr("</Cluster>\n");
500    }
501    {for (int ClustN=0; ClustN<GetClusts(); ClustN++){
502      PBowDocPart SubPart=GetClust(ClustN)->GetSubPart();
503      if (!SubPart.Empty()){
504        TStr NewPathStr=PathStr+"|"+TInt::GetStr(ClustN);
505        SubPart->SaveXml(SOut, BowDocBs, NewPathStr);
506      }
507    }}
508    SOut->Flush();
509    SOut->PutStr("</Partition>\n");
510  }
511  void TBowDocPart::SaveRdfClusts(const PSOut& SOut, const PBowDocBs& BowDocBs, 
512          TIntIntVH& DIdClustIdVH, const int& FatherId, int& ClustId) const {
513      for (int ClustN=0; ClustN<GetClusts(); ClustN++) {
514          PBowDocPartClust Clust=GetClust(ClustN);
515          TStr CptNm, KeyWdStr;
516          if (!Clust->GetNm().Empty()){
517              CptNm = Clust->GetNm(); }
518          if (Clust->IsConceptSpV()) {
519              KeyWdStr = Clust->GetConceptSpV()->GetStr(BowDocBs, 20); 
520              if (CptNm.Empty()) {
521                  CptNm = Clust->GetConceptSpV()->GetStr(BowDocBs, 5, 1, ", ", false); }
522          }
523          if (CptNm.Empty()) {
524              CptNm = TStr::Fmt("Clust%d", ClustId); }
525          SOut->PutStrLn(TStr::Fmt("<ptop:Topic rdf:about=\"#TOP_%d\">", ClustId));
526          SOut->PutStrLn(TStr::Fmt("  <psys:description>%s</psys:description>", CptNm.CStr()));
527          if (FatherId != -1) {
528              SOut->PutStrLn(
529                  TStr::Fmt("  <ptop:subTopicOf rdf:resource=\"#TOP_%d\" />", FatherId));
530          }
531          if (!KeyWdStr.Empty()) {
532              SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenClassProperties rdf:resource=\"#CLS_PROP_%d\" />", ClustId)); }
533          SOut->PutStrLn("</ptop:Topic>");
534          if (!KeyWdStr.Empty()) {
535              SOut->PutStrLn(TStr::Fmt("<jsikm:OntoGenClassProperties rdf:about=\"#CLS_PROP_%d\">", ClustId));
536              SOut->PutStrLn(TStr::Fmt("  <jsikm:hasCentroidKeywords>%s</jsikm:hasCentroidKeywords>", KeyWdStr.CStr()));
537              SOut->PutStrLn("</jsikm:OntoGenClassProperties>");
538          }
539          SOut->PutStrLn("");
540          int Docs=Clust->GetDocs();
541          for (int DIdN=0; DIdN<Docs; DIdN++){
542              int DId=Clust->GetDId(DIdN);
543              if (DIdClustIdVH.IsKey(DId)) {
544                  DIdClustIdVH.GetDat(DId).Add(ClustId);
545              } else {
546                  DIdClustIdVH.AddDat(DId, TIntV::GetV(ClustId));
547              }
548          }
549          PBowDocPart SubPart=GetClust(ClustN)->GetSubPart();
550          const int MyId = ClustId; ClustId++;
551          if (!SubPart.Empty()){
552              SubPart->SaveRdfClusts(SOut, BowDocBs, DIdClustIdVH, MyId, ClustId);
553          }
554      }
555      SOut->Flush();
556  }
557  void TBowDocPart::SaveRdf(const TStr& FNm, const PBowDocBs& BowDocBs) const {
558      PSOut SOut=TFOut::New(FNm);
559      SOut->PutStrLn("<?xml version='1.0' encoding='UTF-8'?>");
560      SOut->PutStrLn("");
561      SOut->PutStrLn("<!DOCTYPE rdf:RDF [");
562      SOut->PutStrLn("    <!ENTITY rdf  'http:&bsol;&bsol;www.w3.org/1999/02/22-rdf-syntax-ns#'>");
563      SOut->PutStrLn("    <!ENTITY rdfs 'http:&bsol;&bsol;www.w3.org/TR/1999/PR-rdf-schema-19990303#'>");
564      SOut->PutStrLn("    <!ENTITY owl  'http:&bsol;&bsol;www.w3.org/2002/07/owl#'>");
565      SOut->PutStrLn("    <!ENTITY ptop 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont#'>");
566      SOut->PutStrLn("    <!ENTITY psys 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons#'>");
567      SOut->PutStrLn("    <!ENTITY pupp  'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonu#'>");
568      SOut->PutStrLn("    <!ENTITY protonkm  'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm#'>");
569      SOut->PutStrLn("    <!ENTITY jsikm  'http:&bsol;&bsol;kt.ijs.si/blazf/jsikm#'>");
570      SOut->PutStrLn("]>");
571      SOut->PutStrLn("");
572      SOut->PutStrLn("<rdf:RDF");
573      SOut->PutStrLn("    xmlns:rdf=\"&rdf;\"");
574      SOut->PutStrLn("    xmlns:rdfs=\"&rdfs;\"");
575      SOut->PutStrLn("    xmlns:owl=\"&owl;\"");
576      SOut->PutStrLn("    xmlns:protonkm=\"&protonkm;\"");
577      SOut->PutStrLn("    xmlns:psys=\"&psys;\"");
578      SOut->PutStrLn("    xmlns:pupp=\"&pupp;\"");
579      SOut->PutStrLn("    xmlns:jsikm=\"&jsikm;\"");
580      SOut->PutStrLn("    xmlns=\"&jsikm;\"");
581      SOut->PutStrLn("    xmlns:ptop=\"&ptop;\"");
582      SOut->PutStrLn("    xml:base=\"&jsikm;\"");
583      SOut->PutStrLn(">");
584      SOut->PutStrLn("");
585      SOut->PutStrLn("<owl:Ontology rdf:about=\"\">");
586      SOut->PutStrLn("  <rdfs:comment>PROTON Topics (from Inspec Thesaurus) ordered by algorithm X</rdfs:comment>");
587      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons\"/>");
588      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont\"/>");
589      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonu\"/>");
590      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm\"/>");
591      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;kt.ijs.si/blazf/jsikm\"/>");
592      SOut->PutStrLn("  <owl:versionInfo>\"0.1\"</owl:versionInfo>");
593      SOut->PutStrLn("</owl:Ontology>");
594      SOut->PutStrLn("");
595      TIntIntVH DIdClustIdVH; int ClustId = 0;
596      SaveRdfClusts(SOut, BowDocBs, DIdClustIdVH, -1, ClustId);  
597      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
598      TStr BowFNm = TStr::PutFExt(FNm, "_docs.bow");
599      TStr ShortBowFNm = BowFNm.GetFMid() + BowFNm.GetFExt();
600      BowDocBs->SaveBin(BowFNm);
601      for (int DocN = 0; DocN < AllDIdV.Len(); DocN++) {
602          const int DId = AllDIdV[DocN];
603          SOut->PutStrLn(TStr::Fmt("<ptop:Document rdf:about=\"#DOC_%d\">", DId));
604          if (DIdClustIdVH.IsKey(DId)) {
605              const TIntV& DocCptV = DIdClustIdVH.GetDat(DId);
606              for (int CptN = 0; CptN < DocCptV.Len(); CptN++) {
607                  const int FthCptId = DocCptV[CptN];
608                  SOut->PutStrLn(TStr::Fmt("  <ptop:hasSubject rdf:resource=\"#TOP_%d\" />", FthCptId));
609              }
610          }
611          SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenInstanceProperties rdf:resource=\"#INST_PROP_%d\" />", DId));
612          SOut->PutStrLn("</ptop:Topic>");
613          SOut->PutStrLn(TStr::Fmt("<jsikm:hasOntoGenInstanceProperties rdf:about=\"#INST_PROP_%d\">", DId));
<span onclick='openModal()' class='match'>614          SOut->PutStrLn(TStr::Fmt("  <jsikm:locationOfInstance>%s#%d</jsikm:locationOfInstance>", ShortBowFNm.CStr(), DId));
615          SOut->PutStrLn("</jsikm:OntoGenClassProperties>");
</span>616          SOut->PutStrLn("");
617      }        
618      SOut->PutStrLn("</rdf:RDF>");
619      SOut->Flush();
620  }
621  const TStr TBowDocPart::BowDocPartFExt=".BowPart";
622  PBowSpV TBowClust::GetConceptSpV(
623   const PBowDocWgtBs& BowDocWgtBs, const PBowSim& BowSim, const TIntV& DIdV,
624   const double& CutWordWgtSumPrc, const TIntFltPrV& DocIdWgtPrV){
625    PBowSpV ConceptSpV;
626    if (DIdV.Empty()){
627      ConceptSpV=TBowSpV::New();
628    } else
629    if ((!BowSim.Empty())&&(BowSim->GetSimType()==bstMtx)){
630      int DIds=DIdV.Len(); int DIdGran=1;
631      int BestDId=DIdV[0]; double BestAvgSim=0;
632      for (int DIdN1=0; DIdN1<DIds; DIdN1+=DIdGran){
633        int DId1=DIdV[DIdN1];
634        double SumSim=0; int TestDIds=0;
635        for (int DIdN2=0; DIdN2<DIds; DIdN2+=DIdGran){
636          if (DIdN1==DIdN2){continue;}
637          int DId2=DIdV[DIdN2];
638          SumSim+=BowSim->GetSim(DId1, DId2); TestDIds++;
639        }
640        if (TestDIds>0){
641          double AvgSim=SumSim/TestDIds;
642          if (AvgSim>BestAvgSim){BestDId=DId1;}
643        }
644      }
645      ConceptSpV=BowDocWgtBs->GetSpV(BestDId);
646    } else {
647      int Words=BowDocWgtBs->GetWords();
648      TFltV WordWgtSumV(Words); double WordWgtSum=0;
649      int DIds=DIdV.Len();
650      TIntFltH DocIdToWgtH(DIds); 
651      for (int DIdN=0; DIdN<DocIdWgtPrV.Len(); DIdN++){
652        DocIdToWgtH.AddDat(DocIdWgtPrV[DIdN].Val1, DocIdWgtPrV[DIdN].Val2);
653      }
654      for (int DIdN=0; DIdN<DIds; DIdN++){
655        int DId=DIdV[DIdN];
656        TFlt DocWgt=1.0;
657        if (DocIdWgtPrV.Len()>0){
658          DocIdToWgtH.IsKeyGetDat(DId, DocWgt);}
659        PBowSpV SpV=BowDocWgtBs->GetSpV(DId);
660        int WIds=SpV->GetWIds();
661        for (int WIdN=0; WIdN<WIds; WIdN++){
662          int WId; double WordWgt; SpV->GetWIdWgt(WIdN, WId, WordWgt);
663          WordWgtSumV[WId]+=DocWgt.Val*WordWgt; WordWgtSum+=DocWgt.Val*WordWgt;
664        }
665      }
666      ConceptSpV=TBowSpV::New(-1, Words/10);
667      for (int WId=0; WId<Words; WId++){
668        if (double(WordWgtSumV[WId])>0){
669          double WordWgtMean=WordWgtSumV[WId]/DIds;
670          ConceptSpV->AddWIdWgt(WId, WordWgtMean);
671        }
672      }
673      if (CutWordWgtSumPrc<1.0){
674        ConceptSpV->CutLowWgtWords(CutWordWgtSumPrc);}
675      ConceptSpV->PutUnitNorm();
676      ConceptSpV->Trunc();
677    }
678    return ConceptSpV;
679  }
680  void TBowClust::GetConceptSpVV(const PBowSim& &bsol;*BowSim*/,
681   const TBowSpVV& SpVV1, const TBowSpVV& SpVV2, TBowSpVV& ConceptSpVV){
682    ConceptSpVV.Gen(SpVV1.Len()+SpVV2.Len(), 0);
683    ConceptSpVV.AddV(SpVV1);
684    ConceptSpVV.AddV(SpVV2);
685  }
686  double TBowClust::GetClustQual(
687   const PBowDocWgtBs& BowDocWgtBs,
688   const TIntV& DIdV, const PBowSpV& ConceptSpV, const PBowSim& BowSim){
689    double Qual=0;
690    int DIds=DIdV.Len();
691    for (int DIdN=0; DIdN<DIds; DIdN++){
692      int DId=DIdV[DIdN];
693      Qual+=BowSim->GetSim(ConceptSpV, BowDocWgtBs->GetSpV(DId));
694    }
695    return Qual;
696  }
697  void TBowClust::GetPartQual(
698   const PBowDocWgtBs& BowDocWgtBs,
699   const TVec<TIntV>& DIdVV, const TBowSpVV& ConceptSpVV,
700   const PBowSim& BowSim, double& PartQual, TFltV& ClustQualV){
701    int Clusts=DIdVV.Len();
702    PartQual=0;
703    ClustQualV.Gen(Clusts);
704    for (int ClustN=0; ClustN<Clusts; ClustN++){
705      double ClustQual=
706       GetClustQual(BowDocWgtBs, DIdVV[ClustN], ConceptSpVV[ClustN], BowSim);
707      PartQual+=ClustQual;
708      ClustQualV[ClustN]=ClustQual;
709    }
710  }
711  PBowDocPart TBowClust::GetKMeansPartForDocWgtBs(
712   const PNotify& Notify,
713   const PBowDocWgtBs& BowDocWgtBs,
714   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& Rnd,
715   const int& Clusts, const int& ClustTrials,
716   const double& ConvergEps, const int& MnDocsPerClust,
717   const TIntFltPrV& DocIdWgtPrV){
718    int Docs=BowDocWgtBs->GetDocs();
719    int Words=BowDocWgtBs->GetWords();
720    TNotify::OnNotify(Notify, ntInfo, "-----------------------");
721    TNotify::OnNotify(Notify, ntInfo, TInt::GetStr(Docs, "Docs: %d"));
722    TNotify::OnNotify(Notify, ntInfo, TInt::GetStr(Words, "Words: %d"));
723    PBowDocPart BestPart=TBowDocPart::New();
724    int ClustTrialN=0; int AddClustTrials=0;
725    while (ClustTrialN<ClustTrials+AddClustTrials){
726      ClustTrialN++;
727      TNotify::OnNotify(Notify, ntInfo,
728       TInt::GetStr(ClustTrialN, "Clustering Trial %d"));
729      TBowSpVV ConceptSpVV(Clusts);
730      double BestStartConceptMeanSim=0;
731      TBowSpVV BestStartConceptSpVV(Clusts);
732      for (int CVTrialN=0; CVTrialN<3; CVTrialN++){
733        for (int ClustN=0; ClustN<Clusts; ClustN++){
734          int DIdN=Rnd.GetUniDevInt(Docs);
735          int DId=BowDocWgtBs->GetDId(DIdN);
736          ConceptSpVV[ClustN]=BowDocWgtBs->GetSpV(DId);
737        }
738        PMom SimMom=TMom::New();
739        for (int ClustN1=0; ClustN1<Clusts; ClustN1++){
740          for (int ClustN2=ClustN1+1; ClustN2<Clusts; ClustN2++){
741            double Sim=BowSim->GetSim(ConceptSpVV[ClustN1], ConceptSpVV[ClustN2]);
742            SimMom->Add(Sim);
743          }
744        }
745        SimMom->Def();
746        double ConceptMeanSim=SimMom->GetMean();
747        if ((CVTrialN==0)||(ConceptMeanSim<BestStartConceptMeanSim)){
748          BestStartConceptMeanSim=ConceptMeanSim;
749          BestStartConceptSpVV=ConceptSpVV;
750        }
751      }
752      ConceptSpVV=BestStartConceptSpVV;
753      double PrevPartQual=0; 
754      double PartQual=0; 
755      TFltV ClustQualV; 
756      TVec<TIntV> DIdVV; 
757      int ClustIters=0; 
758      forever {
759        ClustIters++;
760        bool EmptyClustP;
761        do {
762          DIdVV.Gen(Clusts);
763          for (int DIdN=0; DIdN<Docs; DIdN++){
764            int DId=BowDocWgtBs->GetDId(DIdN);
765            PBowSpV DocSpV=BowDocWgtBs->GetSpV(DId);
766            TFltIntKdV SimClustNKdV(Clusts);
767            for (int ClustN=0; ClustN<Clusts; ClustN++){
768              double Sim=BowSim->GetSim(ConceptSpVV[ClustN], DocSpV);
769              SimClustNKdV[ClustN]=TFltIntKd(Sim, ClustN);
770            }
771            SimClustNKdV.Sort(false); 
772            int BestClustN=SimClustNKdV[0].Dat; 
773            if ((SimClustNKdV.Len()>0)&&(SimClustNKdV[0].Key==SimClustNKdV[1].Key)){
774              int BestClusts=1;
775              for (int ClustN=1; ClustN<Clusts; ClustN++){
776                if (SimClustNKdV[0].Key==SimClustNKdV[ClustN].Key){
777                  BestClusts++;
778                } else {break;}
779              }
780              BestClustN=Rnd.GetUniDevInt(BestClusts);
781            }
782            DIdVV[BestClustN].Add(DId);
783          }
784          EmptyClustP=false;
785          for (int ClustN=0; ClustN<Clusts; ClustN++){
786            if ((MnDocsPerClust!=-1)&&(DIdVV[ClustN].Len()<MnDocsPerClust)){
787              int DId=BowDocWgtBs->GetDId(Rnd.GetUniDevInt(Docs));
788              ConceptSpVV[ClustN]=BowDocWgtBs->GetSpV(DId);
789              PrevPartQual=0; PartQual=0; ClustIters=1;
790              EmptyClustP=true; break;
791            } else {
792              ConceptSpVV[ClustN]=
793               TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, DIdVV[ClustN], 1, DocIdWgtPrV);
794            }
795          }
796        } while (EmptyClustP);
797        PrevPartQual=PartQual;
798        GetPartQual(BowDocWgtBs, DIdVV, ConceptSpVV, BowSim, PartQual, ClustQualV);
799        TStr MsgStr=
800         TInt::GetStr(ClustIters, "  Iteration %d:")+
801         TFlt::GetStr(PartQual, " [Quality: %g]");
802        TNotify::OnNotify(Notify, ntInfo, MsgStr);
803        if (fabs(PartQual-PrevPartQual)<ConvergEps){break;}
804      }
805      if ((ClustTrialN==1)||(PartQual>BestPart->GetQual())){
806        BestPart=TBowDocPart::New();
807        BestPart->PutQual(PartQual);
808        for (int ClustN=0; ClustN<Clusts; ClustN++){
809          PBowDocPartClust Clust=TBowDocPartClust::New(BowDocBs,
810           "", ClustQualV[ClustN], DIdVV[ClustN], ConceptSpVV[ClustN], NULL);
811          BestPart->AddClust(Clust);
812          {TIntV& DIdV=DIdVV[ClustN]; int Docs=DIdV.Len(); TFltV DCSimV(Docs, 0);
813          for (int DIdN=0; DIdN<Docs; DIdN++){
814            PBowSpV DocSpV=BowDocWgtBs->GetSpV(DIdV[DIdN]);
815            double Sim=BowSim->GetSim(ConceptSpVV[ClustN], DocSpV);
816            DCSimV.Add(Sim);
817          }
818          Clust->AddDCSimV(DCSimV);}
819          {TIntV& DIdV=DIdVV[ClustN]; int Docs=DIdV.Len();
820          if (Docs<=200){
821            TFltVV DDSimVV(Docs, Docs);
822            for (int DIdN1=0; DIdN1<Docs; DIdN1++){
823              PBowSpV DocSpV1=BowDocWgtBs->GetSpV(DIdV[DIdN1]);
824              for (int DIdN2=0; DIdN2<Docs; DIdN2++){
825                PBowSpV DocSpV2=BowDocWgtBs->GetSpV(DIdV[DIdN2]);
826                double Sim=BowSim->GetSim(DocSpV1, DocSpV2);
827                DDSimVV.At(DIdN1, DIdN2)=Sim;
828              }
829            }
830            Clust->AddDDSimVV(DDSimVV);
831          }}
832        }
833        TFltVV ClustSimVV(Clusts, Clusts);
834        for (int ClustN1=0; ClustN1<Clusts; ClustN1++){
835          ClustSimVV.At(ClustN1, ClustN1)=
836           BowSim->GetSim(ConceptSpVV[ClustN1], ConceptSpVV[ClustN1]);
837          for (int ClustN2=ClustN1+1; ClustN2<Clusts; ClustN2++){
838            double Sim=BowSim->GetSim(ConceptSpVV[ClustN1], ConceptSpVV[ClustN2]);
839            ClustSimVV.At(ClustN1, ClustN2)=Sim;
840            ClustSimVV.At(ClustN2, ClustN1)=Sim;
841          }
842        }
843        BestPart->PutClustSim(ClustSimVV);
844      }
845    }
846    TNotify::OnNotify(Notify, ntInfo,
847     TFlt::GetStr(BestPart->GetQual(), "Final Quality: %g"));
848    return BestPart;
849  }
850  PBowDocPart TBowClust::GetHPartForDocWgtBs(
851   const PNotify& Notify,
852   const PBowDocWgtBs& BowDocWgtBs,
853   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& &bsol;*Rnd*/){
854    int Docs=BowDocWgtBs->GetDocs();
855    TFltVV SimVV(Docs, Docs); SimVV.PutAll(-1);
856    TVec<TBowSpVV> ClustSpVVV(Docs, 0);
857    TBowDocPartV PartV(Docs, 0);
858    for (int DIdN1=0; DIdN1<Docs; DIdN1++){
859      int DId1=BowDocWgtBs->GetDId(DIdN1);
860      TBowSpVV ClustSpVV(1); ClustSpVV[0]=BowDocWgtBs->GetSpV(DId1);
861      ClustSpVVV.Add(ClustSpVV);
862      TIntV ClustDIdV(1); ClustDIdV[0]=DId1;
863      PBowDocPartClust Clust=
864       TBowDocPartClust::New(BowDocBs, "", 0, ClustDIdV, NULL, NULL);
865      PBowDocPart Part=TBowDocPart::New();
866      Part->AddClust(Clust);
867      PartV.Add(Part);
868      for (int DIdN2=DIdN1+1; DIdN2<Docs; DIdN2++){
869        int DId2=BowDocWgtBs->GetDId(DIdN2);
870        double Sim=
871         BowSim->GetSim(BowDocWgtBs->GetSpV(DId1), BowDocWgtBs->GetSpV(DId2));
872        SimVV.At(DIdN1, DIdN2)=Sim;
873        SimVV.At(DIdN2, DIdN1)=Sim;
874      }
875    }
876    int Clusts=Docs;
877    while (Clusts>1){
878      int DIdN1; int DIdN2; SimVV.GetMxValXY(DIdN1, DIdN2);
879      SimVV.PutX(DIdN1, -1); SimVV.PutY(DIdN1, -1);
880      SimVV.PutX(DIdN2, -1); SimVV.PutY(DIdN2, -1);
881      TBowSpVV ConceptSpVV;
882      GetConceptSpVV(BowSim, ClustSpVVV[DIdN1], ClustSpVVV[DIdN2], ConceptSpVV);
883      ClustSpVVV[DIdN1]=ConceptSpVV;
884      ClustSpVVV[DIdN2].Clr();
885      for (int DIdN=0; DIdN<Docs; DIdN++){
886        if ((ClustSpVVV[DIdN].Len()>0)&&(DIdN!=DIdN1)){
887          double Sim=BowSim->GetSim(ConceptSpVV, ClustSpVVV[DIdN]);
888          SimVV.At(DIdN1, DIdN)=Sim;
889          SimVV.At(DIdN, DIdN1)=Sim;
890        }
891      }
892      PBowDocPart Part1=PartV[DIdN1];
893      PBowDocPart Part2=PartV[DIdN2];
894      TIntV PartDIdV1; Part1->GetDIdV(PartDIdV1);
895      TIntV PartDIdV2; Part2->GetDIdV(PartDIdV2);
896      PBowDocPartClust Clust1=TBowDocPartClust::New(BowDocBs, "", 0, PartDIdV1, NULL, Part1);
897      PBowDocPartClust Clust2=TBowDocPartClust::New(BowDocBs, "", 0, PartDIdV2, NULL, Part2);
898      PBowDocPart Part=TBowDocPart::New();
899      Part->AddClust(Clust1);
900      Part->AddClust(Clust2);
901      PartV[DIdN1]=Part;
902      PartV[DIdN2]=NULL;
903      Clusts--;
904      TNotify::OnStatus(Notify, TInt::GetStr(Clusts, "Clusts: %4d\r"));
905    }
906    return PartV[0];
907  }
908  PBowDocPart TBowClust::GetKMeansPart(
909   const PNotify& Notify,
910   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& Rnd,
911   const int& Clusts, const int& ClustTrials,
912   const double& ConvergEps, const int& MnDocsPerClust,
913   const TBowWordWgtType& WordWgtType, const double& CutWordWgtSumPrc,
914   const int& MnWordFq, const TIntV& _DIdV){
915    TIntV DIdV;
916    if (_DIdV.Empty()){BowDocBs->GetAllDIdV(DIdV);} else {DIdV=_DIdV;}
917    PBowDocWgtBs BowDocWgtBs=
918     TBowDocWgtBs::New(BowDocBs, WordWgtType, CutWordWgtSumPrc, MnWordFq, DIdV);
919    PBowDocPart BowDocPart=TBowClust::GetKMeansPartForDocWgtBs(
920     Notify, BowDocWgtBs, BowDocBs, BowSim,
921     Rnd, Clusts, ClustTrials, ConvergEps, MnDocsPerClust);
922    return BowDocPart;
923  }
924  PBowDocPart TBowClust::GetHKMeansPart(
925   const PNotify& Notify,
926   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& Rnd,
927   const int& MxDocsPerLeafClust, const int& ClustTrials,
928   const double& ConvergEps, const int& MnDocsPerClust,
929   const TBowWordWgtType& WordWgtType, const double& CutWordWgtSumPrc,
930   const int& MnWordFq, const TIntV& _DIdV,
931   const bool& PropBowDocWgtBsP, const PBowDocWgtBs& _BowDocWgtBs){
932    TIntV DIdV;
933    if (_DIdV.Empty()){BowDocBs->GetAllDIdV(DIdV);} else {DIdV=_DIdV;}
934    PBowDocWgtBs BowDocWgtBs;
935    if ((PropBowDocWgtBsP)||(_BowDocWgtBs.Empty())){
936     BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, CutWordWgtSumPrc, MnWordFq, DIdV);
937    } else {
938      BowDocWgtBs=_BowDocWgtBs;
939    }
940    int BowDocWgtBsDocs=BowDocWgtBs->GetDocs();
941    PBowDocPart DocPart=TBowClust::GetKMeansPartForDocWgtBs(
942     Notify, BowDocWgtBs, BowDocBs, BowSim,
943     Rnd, 2, ClustTrials, ConvergEps, MnDocsPerClust);
944    if (!PropBowDocWgtBsP){
945      BowDocWgtBs=NULL;}
946    for (int ClustN=0; ClustN<DocPart->GetClusts(); ClustN++){
947      PBowDocPartClust Clust=DocPart->GetClust(ClustN);
948      int ClustDocs=Clust->GetDocs();
949      if ((ClustDocs>MxDocsPerLeafClust)||(ClustDocs==BowDocWgtBsDocs)){
950        TIntV ClustDIdV; Clust->GetDIdV(ClustDIdV);
951        PBowDocPart SubDocPart=GetHKMeansPart(Notify,
952         BowDocBs, BowSim, Rnd, MxDocsPerLeafClust, ClustTrials, ConvergEps,
953         MnDocsPerClust, WordWgtType, CutWordWgtSumPrc, MnWordFq, ClustDIdV,
954         PropBowDocWgtBsP, BowDocWgtBs);
955        Clust->PutSubPart(SubDocPart);
956      }
957    }
958    return DocPart;
959  }
960  PBowDocPart TBowClust::GetHPart(
961   const PNotify& Notify,
962   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& Rnd,
963   const TBowWordWgtType& WordWgtType, const double& CutWordWgtSumPrc,
964   const int& MnWordFq, const TIntV& DIdV){
965    PBowDocWgtBs BowDocWgtBs=
966     TBowDocWgtBs::New(BowDocBs, WordWgtType, CutWordWgtSumPrc, MnWordFq, DIdV);
967    PBowDocPart BowDocPart=
968     GetHPartForDocWgtBs(Notify, BowDocWgtBs, BowDocBs, BowSim, Rnd);
969    return BowDocPart;
970  }
971  double TBowClust::GetNNbrCfAcc(
972   const PNotify& Notify,
973   const PBowDocBs& BowDocBs, const PBowSim& BowSim,
974   const TBowWordWgtType& WordWgtType, const int& KNbrs,
975   const TIntV& TrainDIdV, const TIntV& TestDIdV){
976    PBowDocWgtBs TrainDocWgtBs=
977     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TrainDIdV);
978    PBowDocWgtBs TestDocWgtBs=
979     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TestDIdV, TrainDIdV);
980    int TrainDocs=TrainDocWgtBs->GetDocs();
981    int TestDocs=TestDocWgtBs->GetDocs();
982    int AllCfs=0; int CorrectCfs=0;
983    for (int TestDIdN=0; TestDIdN<TestDocs; TestDIdN++){
984      int TestDId=TestDIdV[TestDIdN];
985      PBowSpV TestDocSpV=TestDocWgtBs->GetSpV(TestDId);
986      TFltIntKdV SimDIdKdV(TrainDocs, 0);
987      for (int TrainDIdN=0; TrainDIdN<TrainDocs; TrainDIdN++){
988        int TrainDId=TrainDIdV[TrainDIdN];
989        PBowSpV TrainDocSpV=TrainDocWgtBs->GetSpV(TrainDId);
990        double Sim=BowSim->GetSim(TestDocSpV, TrainDocSpV);
991        SimDIdKdV.Add(TFltIntKd(Sim, TrainDId));
992      }
993      SimDIdKdV.Sort(false);
994      int Cats=BowDocBs->GetCats();
995      TFltV CatWgtV(Cats);
996      double SumCatWgt=0;
997      int NrKNbrs=TInt::GetMn(KNbrs, SimDIdKdV.Len());
998      for (int KNbrN=0; KNbrN<NrKNbrs; KNbrN++){
999        int DId=SimDIdKdV[KNbrN].Dat;
1000        int DocCats=BowDocBs->GetDocCIds(DId);
1001        for (int DocCIdN=0; DocCIdN<DocCats; DocCIdN++){
1002          int CId=BowDocBs->GetDocCId(DId, DocCIdN);
1003          double CatWgt=1/double(DocCats);
1004          CatWgtV[CId]+=CatWgt; SumCatWgt+=CatWgt;
1005        }
1006      }
1007      if (SumCatWgt>0){
1008        for (int CId=0; CId<Cats; CId++){
1009          CatWgtV[CId]=CatWgtV[CId]/SumCatWgt;
1010        }
1011      }
1012      int BestCId=CatWgtV.GetMxValN();
1013      if (BowDocBs->IsCatInDoc(TestDId, BestCId)){
1014        printf("+"); CorrectCfs++;} else {printf("-");}
1015      AllCfs++;
1016    }
1017    double CfAcc=double(CorrectCfs)/AllCfs;
1018    TStr MsgStr=TStr("NNbr:")+TInt::GetStr(CorrectCfs)+"/"+
1019     TInt::GetStr(AllCfs)+"="+TFlt::GetStr(CfAcc, "%.3f");
1020    TNotify::OnNotify(Notify, ntInfo, MsgStr);
1021    return CfAcc;
1022  }
1023  double TBowClust::GetClustCfAcc(
1024   const PNotify& Notify,
1025   const PBowDocBs& BowDocBs, const PBowDocPart& Part, const PBowSim& BowSim,
1026   const TBowWordWgtType& WordWgtType,
1027   const TIntV& TrainDIdV, const TIntV& TestDIdV){
1028    PBowDocWgtBs TrainDocWgtBs=
1029     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TrainDIdV);
1030    PBowDocWgtBs TestDocWgtBs=
1031     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TestDIdV, TrainDIdV);
1032    int TestDocs=TestDocWgtBs->GetDocs();
1033    int AllCfs=0; int CorrectCfs=0;
1034    for (int DIdN=0; DIdN<TestDocs; DIdN++){
1035      int DId=TestDIdV[DIdN];
1036      PBowSpV DocSpV=TestDocWgtBs->GetSpV(DId);
1037      int BestCId=Part->GetBestCId(DocSpV, BowSim);
1038      if (BowDocBs->IsCatInDoc(DId, BestCId)){printf("+"); CorrectCfs++;}
1039      else {printf("-");}
1040      AllCfs++;
1041    }
1042    double CfAcc=double(CorrectCfs)/AllCfs;
1043    TStr MsgStr=TStr("Clust:")+TInt::GetStr(CorrectCfs)+"/"+
1044     TInt::GetStr(AllCfs)+"="+TFlt::GetStr(CfAcc, "%.3f");
1045    TNotify::OnNotify(Notify, ntInfo, MsgStr);
1046    return CfAcc;
1047  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowclust.cpp</div>
                </div>
                <div class="column column_space"><pre><code>285      SOut->PutStrLn(TStr::Fmt("  <jsikm:locationOfInstance>%s#%d</jsikm:locationOfInstance>", ShortBowFNm.CStr(), DId));
286      SOut->PutStrLn("</jsikm:OntoGenInstanceProperties>");
</pre></code></div>
                <div class="column column_space"><pre><code>614          SOut->PutStrLn(TStr::Fmt("  <jsikm:locationOfInstance>%s#%d</jsikm:locationOfInstance>", ShortBowFNm.CStr(), DId));
615          SOut->PutStrLn("</jsikm:OntoGenClassProperties>");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    