
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 149, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hldoc.cpp</h3>
            <pre><code>1  #include "hldoc.h"
2  #include "yahooex.h"
3  void THldWordDs::AddWordIdFq(const TIntFltKd& WordIdFqKd){
4    double WordFq=WordIdFqKd.Dat;
5    if (WordFq>0){
6      int WordIdN=WordIdFqKdV.SearchBin(WordIdFqKd);
7      SumWordFq+=WordFq;
8      if (WordIdN==-1){
9        WordIdFqKdV.AddSorted(WordIdFqKd);
10      } else {
11        WordIdFqKdV[WordIdN].Dat+=WordFq;
12      }
13    }
14  }
15  bool THldWordDs::FNextWordId(
16   int& WordIdN, int& WordId, double& WordFq, double& WordPrb) const {
17    WordIdN++;
18    if (WordIdN<WordIdFqKdV.Len()){
19      WordId=WordIdFqKdV[WordIdN].Key;
20      WordFq=WordIdFqKdV[WordIdN].Dat;
21      WordPrb=WordFq/SumWordFq;
22      return true;
23    } else {
24      return false;
25    }
26  }
27  void THldWordDs::NrToSumWordFq(const double& NrSumWordFq){
28    if (SumWordFq!=NrSumWordFq){
29      double NrRatio=(double(SumWordFq)==0) ? 0 : NrSumWordFq/SumWordFq;
30      SumWordFq=NrSumWordFq;
31      if (SumWordFq>0){
32        for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
33          WordIdFqKdV[WordIdN].Dat=WordIdFqKdV[WordIdN].Dat*NrRatio;}
34      }
35    }
36  }
37  void THldWordDs::PowWordFq(const double& Exp){
38    if (SumWordFq>0){
39      SumWordFq=0;
40      for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
41        SumWordFq+=WordIdFqKdV[WordIdN].Dat=pow(WordIdFqKdV[WordIdN].Dat, Exp);
42      }
43    }
44  }
45  void THldWordDs::SaveTxt(const PSOut& SOut, const PHldBs& HldBs){
46    TFltIntKdV WordFqIdKdV(WordIdFqKdV.Len(), 0);
47    for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
48      int WordId=WordIdFqKdV[WordIdN].Key;
49      double WordFq=WordIdFqKdV[WordIdN].Dat/SumWordFq;
50      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
51    }
52    WordFqIdKdV.Sort(false);
53    IAssert(WordFqIdKdV.IsSorted(false));
54    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
55    Lx.PutVarFlt("SumWordFq", SumWordFq);
56    Lx.PutVar("WordIdFqKdV", true, true);
57    {for (int WordIdN=0; WordIdN<WordFqIdKdV.Len(); WordIdN++){
58      int WordId=WordFqIdKdV[WordIdN].Dat;
59      double WordFq=WordFqIdKdV[WordIdN].Key;
60      if (HldBs.Empty()){Lx.PutInt(WordId);}
61      else {Lx.PutQStr(HldBs->GetWordStr(WordId));}
62      Lx.PutFlt(WordFq); Lx.PutLn();
63    }}
64    Lx.PutSym(syRBracket); Lx.PutLn();
65  }
66  PHldWordDs THldWordDs::GetMerged(
67   const PHldWordDs& LWordDs, const PHldWordDs& RWordDs){
68    TIntFltKdV& LWordIdFqKdV=LWordDs->WordIdFqKdV;
69    TIntFltKdV& RWordIdFqKdV=RWordDs->WordIdFqKdV;
70    int LWordIds=LWordDs->GetWordIds();
71    int RWordIds=RWordDs->GetWordIds();
72    double LSumWordFq=LWordDs->GetSumWordFq();
73    double RSumWordFq=RWordDs->GetSumWordFq();
74    PHldWordDs WordDs=new THldWordDs(LWordIds+RWordIds);
75    int LWordIdN=0; int RWordIdN=0;
76    if ((LSumWordFq>0)&&(RSumWordFq>0)){
77      while ((LWordIdN<LWordIds)&&(RWordIdN<RWordIds)){
78        TIntFltKd& LWordIdFqKd=LWordIdFqKdV[LWordIdN];
79        TIntFltKd& RWordIdFqKd=RWordIdFqKdV[RWordIdN];
80        if (LWordIdFqKd==RWordIdFqKd){
81          double LFq=LWordIdFqKd.Dat;
82          double RFq=RWordIdFqKd.Dat;
83          WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq+RFq); LWordIdN++; RWordIdN++;
84        } else
85        if (LWordIdFqKd<RWordIdFqKd){
86          double LFq=LWordIdFqKd.Dat;
87          WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq); LWordIdN++;
88        } else {
89          double RFq=RWordIdFqKd.Dat;
90          WordDs->AddWordIdFq(RWordIdFqKd.Key, RFq); RWordIdN++;
91        }
92      }
93    }
94    if (LSumWordFq>0){
95      while (LWordIdN<LWordIds){
96        TIntFltKd& LWordIdFqKd=LWordIdFqKdV[LWordIdN];
97        double LFq=LWordIdFqKd.Dat;
98        WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq);
99        LWordIdN++;
100      }
101    }
102    if (RSumWordFq>0){
103      while (RWordIdN<RWordIds){
104        TIntFltKd& RWordIdFqKd=RWordIdFqKdV[RWordIdN];
105        double RFq=RWordIdFqKd.Dat;
106        WordDs->AddWordIdFq(RWordIdFqKd.Key, RFq);
107        RWordIdN++;
108      }
109    }
110    return WordDs;
111  }
112  PHldWordDs THldWordDs::GetTruncByMxWords(
113   const PHldWordDs& WordDs, const int& MxWords){
114    TFltIntKdV WordFqIdKdV(WordDs->WordIdFqKdV.Len(), 0);
115    for (int WordIdN=0; WordIdN<WordDs->WordIdFqKdV.Len(); WordIdN++){
116      int WordId=WordDs->WordIdFqKdV[WordIdN].Key;
117      double WordFq=WordDs->WordIdFqKdV[WordIdN].Dat;
118      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
119    }
120    WordFqIdKdV.Sort(false);
121    int TruncWordIds=TInt::GetMn(MxWords, WordDs->GetWordIds());
122    PHldWordDs TruncWordDs=PHldWordDs(new THldWordDs(TruncWordIds));
123    for (int WordIdN=0; WordIdN<TruncWordIds; WordIdN++){
124      double WordFq=WordFqIdKdV[WordIdN].Key;
125      int WordId=WordFqIdKdV[WordIdN].Dat;
126      TruncWordDs->AddWordIdFq(WordId, WordFq);
127    }
128    return TruncWordDs;
129  }
130  double THldWordDs::GetDist(
131   const PHldWordDs& LWordDs, const PHldWordDs& RWordDs,
132   const PHldBs& &bsol;*HldBs*/){
133    TIntFltKdV& LWordIdFqKdV=LWordDs->WordIdFqKdV;
134    TIntFltKdV& RWordIdFqKdV=RWordDs->WordIdFqKdV;
135    int LWordIds=LWordIdFqKdV.Len();
136    int RWordIds=RWordIdFqKdV.Len();
137    double Dist=0;
138    int LWordIdN=0; int RWordIdN=0;
139    while ((LWordIdN<LWordIds)&&(RWordIdN<RWordIds)){
140      TIntFltKd& LWordIdFqKd=LWordIdFqKdV[LWordIdN];
141      TIntFltKd& RWordIdFqKd=RWordIdFqKdV[RWordIdN];
142      if (LWordIdFqKd==RWordIdFqKd){
143        Dist++;
144        LWordIdN++; RWordIdN++;
145      } else
146      if (LWordIdFqKd<RWordIdFqKd){
147        LWordIdN++;
148      } else {
149        RWordIdN++;
150      }
151    }
152    Dist=1-Dist/(sqrt(LWordIdFqKdV.Len())*sqrt(RWordIdFqKdV.Len()));
153    return Dist;
154  }
155  void THldWordDs::GetHypTsEst(
156   const PHldWordDs& RefWordDs, const PHldWordDs& HypWordDs,
157   double& Precis, double& Recall, double& Dist, double& F2){
158    int RefWordIds=0; int IntsWordIds=0;
159    int WordIdN=RefWordDs->FFirstWordId(); int WordId; double WordFq; double WordPrb;
160    while (RefWordDs->FNextWordId(WordIdN, WordId, WordFq, WordPrb)){
161      if (HypWordDs->IsWordId(WordId)){IntsWordIds++;}
162      RefWordIds++;
163    }
164    int HypWordIds=HypWordDs->GetWordIds();
165    PHldWordDs RefHypWordDs=THldWordDs::GetMerged(RefWordDs, HypWordDs);
166    if ((RefWordIds==0)||(HypWordIds==0)){
167      Precis=1; Recall=1; Dist=1;
168    } else {
169      Precis=IntsWordIds/double(HypWordIds);
170      Recall=IntsWordIds/double(RefWordIds);
171      Dist=1-IntsWordIds/(sqrt(HypWordIds)*sqrt(RefWordIds));
172    }
173    if (Precis+Recall>0){F2=(5*Precis*Recall)/(4*Precis+Recall);}
174  }
175  THldWord::THldWord(THldBs* _HldBs, const TStr& Str):
176    HldBs(_HldBs), FirstChN(HldBs->WordChAHeap.Len()){
177    HldBs->WordChAHeap+=Str; HldBs->WordChAHeap+=CrCh;
178  }
179  TStr THldWord::GetStr() const {
180    TChA ChA; int ChN=FirstChN;
181    while (HldBs->WordChAHeap[ChN]!=CrCh){
182      ChA+=HldBs->WordChAHeap[ChN++];}
183    return ChA;
184  }
185  void THldBs::PutThisToWord(){
186    int WordToFqP=WordToFqH.FFirstKeyId();
187    while (WordToFqH.FNextKeyId(WordToFqP)){
188      WordToFqH.GetKey(WordToFqP).HldBs=this;
189    }
190  }
191  TStr THldBs::GetStrQStr(const TStrQ& StrQ, const int& Strs){
192    TChA ChA;
193    int FirstStrN=(Strs==-1) ? 0 : StrQ.Len()-Strs;
194    for (int StrN=FirstStrN; StrN<StrQ.Len(); StrN++){
195      if (!ChA.Empty()){ChA+=' ';} ChA+=StrQ[StrN];
196    }
197    return ChA;
198  }
199  THldBs::THldBs(
200   const TStrV& HlCtxStrV, const PXWebBs& WebBs,
201   const int& _MxNGram, const int& _MnWordFq,
202   const TSwSetTy& SwSetTy, const PNotify& _Notify):
203    MxNGram(_MxNGram), MnWordFq(_MnWordFq),
204    SwSet(new TSwSet(SwSetTy)),
205    WordToFqH(100000), WordChAHeap(1000000),
206    WordIdVHeap(100000, 0), DocIdToUrlStrH(50000),
207    HlDocV(), Notify(_Notify){
208    TIntPrV HlCtxWebPgPrV(HlCtxStrV.Len(), 0);
209    for (int HlCtxStrN=0; HlCtxStrN<HlCtxStrV.Len(); HlCtxStrN++){
210      TStr UrlStr=GetUrlStrFromHlCtxStr(HlCtxStrV[HlCtxStrN]);
211      IAssert(WebBs->IsUrlStr(UrlStr));
212      int WebPgId=WebBs->GetWebPgId(UrlStr);
213      HlCtxWebPgPrV.Add(TIntPr(HlCtxStrN, WebPgId));
214    }
215    TNotify::OnNotify(Notify, ntInfo, "Start Generation N-Grams");
216    for (int NGram=1; NGram<=MxNGram; NGram++){
217      int Hlds=0;
218      for (int HlCtxWebPgN=0; HlCtxWebPgN<HlCtxWebPgPrV.Len(); HlCtxWebPgN++){
219        int HlCtxStrN=HlCtxWebPgPrV[HlCtxWebPgN].Val1;
220        int WebPgId=HlCtxWebPgPrV[HlCtxWebPgN].Val2;
221        TStr HlCtxStr=HlCtxStrV[HlCtxStrN];
222        TStr WebPgStr=WebBs->GetBodyStr(WebPgId);
223        AddTxt(HlCtxStr, false, NGram);
224        AddTxt(WebPgStr, false, NGram);
225        if (++Hlds%100==0){
226          TStr DocProcStr=TStr("...")+TInt::GetStr(Hlds)+" Documents; "+
227           TInt::GetStr(GetWords())+" N-Grams";
228          TNotify::OnNotify(Notify, ntInfo, DocProcStr);
229        }
230      }
231      TStr NGramGenStr=TInt::GetStr(NGram)+"-Grams Generated ("+
232       TInt::GetStr(GetWords())+")";
233      TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
234      TStrIntPrV WordStrFqPrV(WordToFqH.Len(), 0);
235      int WordId=WordToFqH.FFirstKeyId();
236      while (WordToFqH.FNextKeyId(WordId)){
237        if (WordToFqH[WordId]>=MnWordFq){
238          WordStrFqPrV.Add(TStrIntPr(GetWordStr(WordId), TInt(GetWordFq(WordId))));}
239      }
240      WordToFqH.Clr(); WordChAHeap.Clr();
241      for (int WordN=0; WordN<WordStrFqPrV.Len(); WordN++){
242        AddWord(WordStrFqPrV[WordN].Val1)=WordStrFqPrV[WordN].Val2;}
243      TStr NGramReduceStr=TInt::GetStr(NGram)+"-Grams Reduced ("+
244       TInt::GetStr(GetWords())+")";
245      TNotify::OnNotify(Notify, ntInfo, NGramReduceStr);
246    }
247    TStr NGramGenStr=TInt::GetStr(MxNGram)+"-Grams Generation Finished ("+
248     TInt::GetStr(GetWords())+")";
249    TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
250    TNotify::OnNotify(Notify, ntInfo, "Start Processing Documents");
251    HlDocV.Gen(HlCtxWebPgPrV.Len(), 0);
252    int Hlds=0;
253    THash<TStr, TInt> UrlStrToDocIdH(HlCtxWebPgPrV.Len());
254    for (int HlCtxWebPgN=0; HlCtxWebPgN<HlCtxWebPgPrV.Len(); HlCtxWebPgN++){
255      int HlCtxStrN=HlCtxWebPgPrV[HlCtxWebPgN].Val1;
256      int WebPgId=HlCtxWebPgPrV[HlCtxWebPgN].Val2;
257      TStr HlCtxStr=HlCtxStrV[HlCtxStrN];
258      TStr WebPgStr=WebBs->GetBodyStr(WebPgId);
259      TStr UrlStr=WebBs->GetUrlStr(WebPgId);
260      int HlId=AddTxt(HlCtxStr, true, -1);
261      int DocId;
262      if (UrlStrToDocIdH.IsKey(UrlStr)){
263        DocId=UrlStrToDocIdH.GetDat(UrlStr);
264      } else {
265        DocId=AddTxt(WebPgStr, true, -1);
266        UrlStrToDocIdH.AddDat(UrlStr, DocId);
267        DocIdToUrlStrH.AddDat(DocId, UrlStr);
268      }
269      PHldWordDs HlWordDs=GetTxtWordDs(HlId);
270      HlDocV.Add(THlDoc(HlId, DocId, HlWordDs));
271      if (++Hlds%100==0){
272        TStr DocProcStr=TInt::GetStr(Hlds)+" Documents Processed";
273        TNotify::OnNotify(Notify, ntInfo, DocProcStr);
274      }
275    }
276    TStr DocProcStr=TStr("HyperLinkDocument Processing Finished (")+
277     TInt::GetStr(HlDocV.Len())+")";
278    TNotify::OnNotify(Notify, ntInfo, DocProcStr);
279  }
280  TInt& THldBs::AddWord(const TStr& WordStr){
281    int PrevLen=WordChAHeap.Len();
282    THldWord Word(this, WordStr);
283    int WordId=WordToFqH.GetKeyId(Word);
284    if (WordId==-1){
285      return WordToFqH.AddDat(Word);
286    } else {
287      WordChAHeap.Trunc(PrevLen);
288      return WordToFqH[WordId];
289    }
290  }
291  int THldBs::GetWordId(const TStr& WordStr){
292    int PrevLen=WordChAHeap.Len();
293    THldWord Word(this, WordStr);
294    int WordId=WordToFqH.GetKeyId(Word);
295    WordChAHeap.Trunc(PrevLen);
296    return WordId;
297  }
298  int THldBs::AddTxt(const TStr& TxtStr, const bool& DoGenDoc, const int& NGram){
299    int TxtId=-1;
300    TIntV TxtWordIdV;
301    if (DoGenDoc){
302      IAssert(NGram==-1);
303      TxtWordIdV.Gen(1000, 0);
304    }
305    PSIn SIn=TStrIn::New(TxtStr);
306    PHtmlDoc HtmlDoc=PHtmlDoc(new THtmlDoc(SIn, hdtAll));
307    PHtmlTok Tok; THtmlLxSym Sym=hlsyUndef; TStr Str; TStrQ PrevStrQ;
308    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
309      Tok=HtmlDoc->GetTok(TokN, Sym, Str);
310      switch (Sym){
311        case hlsyStr:
312          if (DoGenDoc){
313            if (!SwSet->IsIn(Str)){
314              int WordId=GetWordId(Str);
315              if (WordId!=-1){
316                TxtWordIdV.Add(WordId);
317                PrevStrQ.Push(Str);
318                int NGram=2;
319                while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
320                  int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
321                  if (WordId==-1){
322                    while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
323                  } else {
324                    TxtWordIdV.Add(WordId);
325                  }
326                  NGram++;
327                }
328              } else {
329                PrevStrQ.Clr();
330              }
331            }
332          } else {
333            if (NGram==1){
334              if (!SwSet->IsIn(Str)){AddWord(Str)++;}
335            } else {
336              if (!SwSet->IsIn(Str)){
337                int WordId=GetWordId(Str);
338                if (WordId!=-1){
339                  TStr WordStr=GetWordStr(WordId);
340                  if (PrevStrQ.Len()+1==NGram){
341                    if (GetWordId(GetStrQStr(PrevStrQ))!=-1){
342                      PrevStrQ.Push(WordStr);
343                      AddWord(GetStrQStr(PrevStrQ))++;
344                      PrevStrQ.Pop();
345                    } else {
346                      PrevStrQ.Push(WordStr); PrevStrQ.Pop();
347                    }
348                  } else {
349                    PrevStrQ.Push(WordStr);
350                  }
351                } else {
352                  PrevStrQ.Clr();
353                }
354              }
355            }
356          }
357          break;
358        case hlsyNum:
359        case hlsySSym:
360          PrevStrQ.Clr(); break;
361        case hlsyBTag:
362        case hlsyETag:
363          if (THtmlTok::IsBreakTag(Str)){PrevStrQ.Clr();} break;
364        default:;
365      }
366    }
367    if (DoGenDoc){
368      TxtId=WordIdVHeap.Len();
369      WordIdVHeap.AddV(TxtWordIdV); WordIdVHeap.Add(TInt(-1));
370    }
371    return TxtId;
372  }
373  int THldBs::GetTxtLen(const int& TxtId){
374    int WordIdN=TxtId; int TxtLen=0;
375    while (WordIdVHeap[WordIdN]!=-1){WordIdN++; TxtLen++;}
376    return TxtLen;
377  }
378  PHldWordDs THldBs::GetTxtWordDs(const int& TxtId){
379    PHldWordDs WordDs=PHldWordDs(new THldWordDs(GetTxtLen(TxtId)));
380    int WordIdN=TxtId;
381    while (WordIdVHeap[WordIdN]!=-1){
382      int WordId=WordIdVHeap[WordIdN++];
383      WordDs->AddWordIdFq(WordId, 1);
384    }
385    return WordDs;
386  }
387  PHldWordDs THldBs::GetWordDs(const PSIn& SIn){
388    PHldWordDs WordDs=PHldWordDs(new THldWordDs());
389    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtAll);
390    PHtmlTok Tok; THtmlLxSym Sym; TStr Str; TStrQ PrevStrQ;
391    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
392      Tok=HtmlDoc->GetTok(TokN, Sym, Str);
<span onclick='openModal()' class='match'>393      switch (Sym){
394        case hlsyStr:
395          if (!SwSet->IsIn(Str)){
396            int WordId=GetWordId(Str);
397            if (WordId!=-1){
398              WordDs->AddWordIdFq(WordId, 1);
399              PrevStrQ.Push(Str);
400              int NGram=2;
401              while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
402                int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
403                if (WordId==-1){
404                  while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
405                } else {
406                  WordDs->AddWordIdFq(WordId, 1);
407                }
408                NGram++;
409              }
410            } else {
411              PrevStrQ.Clr();
412            }
413          }
414          break;
415        case hlsyNum:
416        case hlsySSym:
</span>417          PrevStrQ.Clr(); break;
418        case hlsyBTag:
419        case hlsyETag:
420          if (THtmlTok::IsBreakTag(Str)){PrevStrQ.Clr();} break;
421        default:;
422      }
423    }
424    return WordDs;
425  }
426  void THldBs::GetDistHlDocNV(
427   const int& KNNbrs, const bool& RndSel,
428   const PHldWordDs& RefHlWordDs, const TStrV& SelUrlStrV,
429   TFltIntKdV& DistHlDocNKdV){
430    DistHlDocNKdV.Clr();
431    for (int HlDocN=0; HlDocN<GetHlDocs(); HlDocN++){
432      if (SelUrlStrV.Len()>0){
433        if (SelUrlStrV.SearchBin(GetDocUrlStr(HlDocN))==-1){continue;}}
434      PHldWordDs HlWordDs=GetHlWordDs(HlDocN);
435      double Dist=THldWordDs::GetDist(RefHlWordDs, HlWordDs, this);
436      if (RndSel){
437        DistHlDocNKdV.Add(TFltIntKd(Dist, HlDocN));
438      } else {
439        DistHlDocNKdV.AddSorted(TFltIntKd(Dist, HlDocN), true, KNNbrs);
440      }
441    }
442    if (RndSel){
443      TRnd Rnd(TRnd::RndSeed);
444      DistHlDocNKdV.Shuffle(Rnd);
445      int Docs=TInt::GetMn(DistHlDocNKdV.Len(), KNNbrs);
446      DistHlDocNKdV.Reserve(Docs, Docs);
447    }
448  }
449  PHldWordDs THldBs::GetHypDocWordDs(const TFltIntKdV& DistHlDocNKdV){
450    PHldWordDs HypWordDs=PHldWordDs(new THldWordDs());
451    PMom HypDocLenMom=PMom(new TMom());
452    for (int DistHlDocNKdN=0; DistHlDocNKdN<DistHlDocNKdV.Len(); DistHlDocNKdN++){
453      int HlDocN=DistHlDocNKdV[DistHlDocNKdN].Dat;
454      PHldWordDs DocWordDs=GetDocWordDs(HlDocN);
455      HypWordDs=THldWordDs::GetMerged(HypWordDs, DocWordDs);
456      HypDocLenMom->Add(GetTxtLen(GetDocId(HlDocN)));
457    }
458    HypDocLenMom->Def();
459    int HypDocLen=int(HypDocLenMom->GetMean());
460    HypWordDs=THldWordDs::GetTruncByMxWords(HypWordDs, HypDocLen);
461    return HypWordDs;
462  }
463  void THldBs::SaveTxt(const PSOut& SOut){
464    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
465    for (int HlDocN=0; HlDocN<HlDocV.Len(); HlDocN++){
466      int HlId=HlDocV[HlDocN].GetHlId();
467      int DocId=HlDocV[HlDocN].GetDocId();
468      PHldWordDs HlWordDs=HlDocV[HlDocN].GetHlWordDs();
469      TStr UrlStr=DocIdToUrlStrH.GetDat(DocId);
470      Lx.PutVarStr("UrlStr", UrlStr);
471      Lx.PutVar("Hl", true, true);
472      int HlWordIdN=HlId; TChA HlWordLn;
473      while (WordIdVHeap[HlWordIdN]!=-1){
474        TStr WordStr=GetWordStr(WordIdVHeap[HlWordIdN++]);
475        if (WordStr.SearchCh(' ')==-1){HlWordLn+=WordStr;}
476        else {HlWordLn+='('; HlWordLn+=WordStr; HlWordLn+=')';}
477        HlWordLn+=' ';
478        if (HlWordLn.Len()>50){
479          Lx.PutQStr(HlWordLn); Lx.PutLn(); HlWordLn.Clr();}
480      }
481      if (!HlWordLn.Empty()){Lx.PutQStr(HlWordLn); Lx.PutLn();}
482      Lx.PutSym(syRBracket); Lx.PutLn();
483      Lx.PutVar("Doc", true, true);
484      int DocWordIdN=DocId; TChA DocWordLn;
485      while (WordIdVHeap[DocWordIdN]!=-1){
486        TStr WordStr=GetWordStr(WordIdVHeap[DocWordIdN++]);
487        if (WordStr.SearchCh(' ')==-1){DocWordLn+=WordStr;}
488        else {DocWordLn+='('; DocWordLn+=WordStr; DocWordLn+=')';}
489        DocWordLn+=' ';
490        if (DocWordLn.Len()>50){
491          Lx.PutQStr(DocWordLn); Lx.PutLn(); DocWordLn.Clr();}
492      }
493      if (!DocWordLn.Empty()){Lx.PutQStr(DocWordLn); Lx.PutLn();}
494      Lx.PutSym(syRBracket); Lx.PutLn();
495      HlWordDs->SaveTxt(SOut, this);
496    }
497    Lx.PutVar("WordFqIdKdV", true, true);
498    TIntKdV WordFqIdKdV;
499    int WordToFqP=WordToFqH.FFirstKeyId();
500    while (WordToFqH.FNextKeyId(WordToFqP)){
501      int WordId=WordToFqP;
502      int WordFq=WordToFqH[WordToFqP];
503      WordFqIdKdV.Add(TIntKd(WordFq, WordId));
504    }
505    WordFqIdKdV.Sort(false);
506    for (int WordFqIdKdN=0; WordFqIdKdN<WordFqIdKdV.Len(); WordFqIdKdN++){
507      int WordFq=WordFqIdKdV[WordFqIdKdN].Key;
508      TStr WordStr=GetWordStr(WordFqIdKdV[WordFqIdKdN].Dat);
509      Lx.PutStr(WordStr); Lx.PutSym(syColon); Lx.PutInt(WordFq); Lx.PutLn();
510    }
511    Lx.PutSym(syRBracket); Lx.PutLn();
512  }
513  TStr THldBs::GetUrlStrFromHlCtxStr(const TStr& HlCtxStr){
514    PSIn SIn=TStrIn::New(HlCtxStr);
515    PHtmlDoc HtmlDoc=THtmlDoc::New(SIn, hdtA);
516    PHtmlTok Tok=HtmlDoc->GetTok(0);
517    IAssert((Tok->GetSym()==hlsyBTag)&&(Tok->GetStr()==THtmlTok::ATagNm));
518    TStr HRefStr=Tok->GetArg(THtmlTok::HRefArgNm);
519    PUrl Url=TUrl::New(HRefStr);
520    return Url->GetUrlStr();
521  }
522  void THldExpr::PutMomHd(TOLx& Lx, const TStr& VarNm){
523    Lx.PutUQStr(VarNm+"Mean"); Lx.PutUQStr(VarNm+"SDev");
524    Lx.PutUQStr(VarNm+"SErr"); Lx.PutUQStr(VarNm+"Med");
525    Lx.PutUQStr(VarNm+"Q1"); Lx.PutUQStr(VarNm+"Q3");
526  }
527  void THldExpr::PutMomVal(TOLx& Lx, const PMom& Mom){
528    if (Mom->IsUsable()){
529      Lx.PutFlt(Mom->GetMean()); Lx.PutFlt(Mom->GetSDev());
530      Lx.PutFlt(Mom->GetSErr()); Lx.PutFlt(Mom->GetMedian());
531      Lx.PutFlt(Mom->GetQuart1()); Lx.PutFlt(Mom->GetQuart3());
532    } else {
533      for (int MomN=0; MomN<6; MomN++){Lx.PutFlt(-1);}
534    }
535  }
536  void THldExpr::Go(
537   const PSOut& SOut, const bool& PutHd, const bool& SaveTmp,
538   const TStr& HldDmNm, const int& TsRuns,
539   const TStrV& AllHlCtxStrV, const PXWebBs& DocWebBs,
540   const int& MxNGram, const int& MnWordFq, const TSwSetTy& SwSetTy,
541   const int& KNNbrs, const bool& RndSel,
542   const PNotify& Notify){
543    PSOut LogSOut=new TFOut("log.t");
544    TOLx LogLx(LogSOut, TFSet()|oloFrcEoln|oloSigNum);
545    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
546    if (PutHd){
547      Lx.PutUQStr("DmNm"); Lx.PutUQStr("TsRunN");
548      Lx.PutUQStr("KNNbrs");
549      Lx.PutUQStr("RndSel");
550      PutMomHd(Lx, "HldPrecis");
551      PutMomHd(Lx, "HldRecall");
552      PutMomHd(Lx, "HldDist");
553      PutMomHd(Lx, "HldF2");
554      PutMomHd(Lx, "HlLen");
555      PutMomHd(Lx, "DocLen");
556      PutMomHd(Lx, "HypDocLen");
557      PutMomHd(Lx, "YHldPrecis");
558      PutMomHd(Lx, "YHldRecall");
559      Lx.PutLn();
560    }
561    TRnd Rnd;
562    TStrV ShHlCtxStrV=AllHlCtxStrV; ShHlCtxStrV.Shuffle(Rnd);
563    for (int TsRunN=0; TsRunN<TsRuns; TsRunN++){
564      TStrV TrHlCtxStrV; TStrV TsHlCtxStrV;
565      for (int ShHlCtxStrN=0; ShHlCtxStrN<ShHlCtxStrV.Len(); ShHlCtxStrN++){
566        if (ShHlCtxStrN%TsRuns==TsRunN){
567          TsHlCtxStrV.Add(ShHlCtxStrV[ShHlCtxStrN]);
568        } else {
569          TrHlCtxStrV.Add(ShHlCtxStrV[ShHlCtxStrN]);
570        }
571      }
572      PHldBs HldBs=PHldBs(new THldBs(
573       TrHlCtxStrV, DocWebBs, MxNGram, MnWordFq, SwSetTy, Notify));
574      if (SaveTmp){
575        TFOut FOut("HldBsRef.Dat");
576        HldBs->Save(FOut);
577        HldBs->SaveTxt(PSOut(new TFOut("hldRef.t")));
578      }
579      PMom HldPrecisMom=PMom(new TMom());
580      PMom HldRecallMom=PMom(new TMom());
581      PMom HldDistMom=PMom(new TMom());
582      PMom HldF2Mom=PMom(new TMom());
583      PMom HlLenMom=PMom(new TMom());
584      PMom DocLenMom=PMom(new TMom());
585      PMom HypDocLenMom=PMom(new TMom());
586      PMom YHldPrecisMom=PMom(new TMom());
587      PMom YHldRecallMom=PMom(new TMom());
588      for (int TsHlCtxStrN=0; TsHlCtxStrN<TsHlCtxStrV.Len(); TsHlCtxStrN++){
589        TStr TsHlCtxStr=TsHlCtxStrV[TsHlCtxStrN];
590        LogLx.PutVarStr("TsHlCtxStr", TsHlCtxStr);
591        {TStr UrlStr=THldBs::GetUrlStrFromHlCtxStr(TsHlCtxStr);
592        TStr WebPgStr=DocWebBs->GetBodyStr(UrlStr);
593        PHldWordDs TsHlWordDs=HldBs->GetWordDs(TsHlCtxStr);
594        PHldWordDs TsDocWordDs=HldBs->GetWordDs(WebPgStr);
595        TFltIntKdV DistHlDocNKdV;
596        HldBs->GetDistHlDocNV(KNNbrs, RndSel, TsHlWordDs, TStrV(), DistHlDocNKdV);
597        if (SaveTmp){
598          for (int DistHlDocNKdN=0; DistHlDocNKdN<DistHlDocNKdV.Len(); DistHlDocNKdN++){
599            double Dist=DistHlDocNKdV[DistHlDocNKdN].Key;
600            TStr UrlStr=HldBs->GetDocUrlStr(DistHlDocNKdV[DistHlDocNKdN].Dat);
601            LogLx.PutVarStr("UrlStr", TFlt::GetStr(Dist)+" "+UrlStr);
602          }
603        }
604        PHldWordDs HypDocWordDs=HldBs->GetHypDocWordDs(DistHlDocNKdV);
605        double Precis; double Recall; double Dist; double F2;
606        THldWordDs::GetHypTsEst(TsDocWordDs, HypDocWordDs, Precis, Recall, Dist, F2);
607        HldPrecisMom->Add(Precis); HldRecallMom->Add(Recall);
608        HldDistMom->Add(Dist); HldF2Mom->Add(F2);
609        double HlLen=TsHlWordDs->GetWordIds(); HlLenMom->Add(HlLen);
610        double DocLen=TsDocWordDs->GetWordIds(); DocLenMom->Add(DocLen);
611        double HypDocLen=HypDocWordDs->GetWordIds(); HypDocLenMom->Add(HypDocLen);
612        if (SaveTmp){
613          LogLx.PutVarFlt("Precis", Precis);
614          LogLx.PutVarFlt("Recall", Recall);
615          LogLx.PutVarFlt("Dist", Dist);
616          LogLx.PutVarFlt("F2", F2);
617          LogLx.PutVarFlt("HlLen", HlLen);
618          LogLx.PutVarFlt("DocLen", DocLen);
619          LogLx.PutVarFlt("HypDocLen", HypDocLen);
620        }}
621        if (SaveTmp){LogLx.PutLn();}
622      }
623      HldPrecisMom->Def();
624      HldRecallMom->Def();
625      HldDistMom->Def();
626      HldF2Mom->Def();
627      HlLenMom->Def();
628      DocLenMom->Def();
629      HypDocLenMom->Def();
630      YHldPrecisMom->Def();
631      YHldRecallMom->Def();
632      Lx.PutStr(HldDmNm); Lx.PutInt(TsRunN);
633      Lx.PutInt(KNNbrs);
634      Lx.PutBool(RndSel);
635      PutMomVal(Lx, HldPrecisMom);
636      PutMomVal(Lx, HldRecallMom);
637      PutMomVal(Lx, HldDistMom);
638      PutMomVal(Lx, HldF2Mom);
639      PutMomVal(Lx, HlLenMom);
640      PutMomVal(Lx, DocLenMom);
641      PutMomVal(Lx, HypDocLenMom);
642      PutMomVal(Lx, YHldPrecisMom);
643      PutMomVal(Lx, YHldRecallMom);
644      Lx.PutLn();
645      SOut->Flush();
646      LogSOut->Flush();
647    }
648  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoobs.cpp</h3>
            <pre><code>1  #include "yahoobs.h"
2  TYWord::TYWord(TYBs* _YBs, const TStr& Str):
3    YBs(_YBs), FirstChN(YBs->WordChAHeap.Len()){
4      YBs->WordChAHeap+=Str; YBs->WordChAHeap+=TCh::CrCh;
5  }
6  TStr TYWord::GetStr() const {
7    TChA ChA; int ChN=FirstChN;
8    while (YBs->WordChAHeap[ChN]!=TCh::CrCh){
9      ChA+=YBs->WordChAHeap[ChN++];}
10    return ChA;
11  }
12  int TYWord::GetSegs() const {
13    int Segs=1; int ChN=FirstChN;
14    while (YBs->WordChAHeap[ChN]!=TCh::CrCh){
15      if (YBs->WordChAHeap[ChN++]==' '){Segs++;}}
16    return Segs;
17  }
18  void TYWordDs::AddWordIdFq(const TIntFltKd& WordIdFqKd){
19    double WordFq=WordIdFqKd.Dat;
20    if (WordFq>0){
21      int WordIdN=WordIdFqKdV.SearchBin(WordIdFqKd);
22      SumWordFq+=WordFq;
23      if (WordIdN==-1){
24        WordIdFqKdV.AddSorted(WordIdFqKd);
25      } else {
26        WordIdFqKdV[WordIdN].Dat+=WordFq;
27      }
28    }
29  }
30  bool TYWordDs::FNextWordId(
31   int& WordIdN, int& WordId, double& WordFq, double& WordPrb) const {
32    WordIdN++;
33    if (WordIdN<WordIdFqKdV.Len()){
34      WordId=WordIdFqKdV[WordIdN].Key;
35      WordFq=WordIdFqKdV[WordIdN].Dat;
36      WordPrb=WordFq/SumWordFq;
37      return true;
38    } else {
39      return false;
40    }
41  }
42  void TYWordDs::NrToSumWordFq(const double& NrSumWordFq){
43    if (SumWordFq!=NrSumWordFq){
44      double NrRatio=(double(SumWordFq)==0) ? 0 : NrSumWordFq/SumWordFq;
45      SumWordFq=NrSumWordFq;
46      if (SumWordFq>0){
47        for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
48          WordIdFqKdV[WordIdN].Dat=WordIdFqKdV[WordIdN].Dat*NrRatio;}
49      }
50    }
51  }
52  void TYWordDs::PowWordFq(const double& Exp){
53    if (SumWordFq>0){
54      SumWordFq=0;
55      for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
56        SumWordFq+=WordIdFqKdV[WordIdN].Dat=pow(WordIdFqKdV[WordIdN].Dat, Exp);
57      }
58    }
59  }
60  void TYWordDs::SaveTxt(const PSOut& SOut, const TYBs* YBs, const int& DocId){
61    TFltIntKdV WordFqIdKdV(WordIdFqKdV.Len(), 0);
62    for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
63      int WordId=WordIdFqKdV[WordIdN].Key;
64      double WordFq=WordIdFqKdV[WordIdN].Dat/SumWordFq;
65      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
66    }
67    WordFqIdKdV.Sort(false);
68    IAssert(WordFqIdKdV.IsSorted(false));
69    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
70    if (DocId!=-1){Lx.PutVarStr("UrlStr", YBs->GetDocUrlStr(DocId));}
71    Lx.PutVarInt("DocId", DocId);
72    Lx.PutVarInt("Docs", Docs);
73    Lx.PutVarInt("Sects", Sects);
74    Lx.PutVarFlt("SumWordFq", SumWordFq);
75    Lx.PutVar("WordIdFqKdV", true, true);
76    {for (int WordIdN=0; WordIdN<WordFqIdKdV.Len(); WordIdN++){
77      int WordId=WordFqIdKdV[WordIdN].Dat;
78      double WordFq=WordFqIdKdV[WordIdN].Key;
79      if (YBs==NULL){Lx.PutInt(WordId);}
80      else {Lx.PutQStr(YBs->GetWordStr(WordId));}
81      Lx.PutFlt(WordFq); Lx.PutLn();
82    }}
83    Lx.PutSym(syRBracket); Lx.PutLn();
84  }
85  PYWordDs TYWordDs::GetMerged(const PYWordDs& LWordDs, const PYWordDs& RWordDs,
86   const double& LWgt, const double& RWgt){
87    TIntFltKdV& LWordIdFqKdV=LWordDs->WordIdFqKdV;
88    TIntFltKdV& RWordIdFqKdV=RWordDs->WordIdFqKdV;
89    int LWordIds=LWordDs->GetWordIds();
90    int RWordIds=RWordDs->GetWordIds();
91    double LSumWordFq=LWordDs->GetSumWordFq();
92    double RSumWordFq=RWordDs->GetSumWordFq();
93    int Docs=LWordDs->GetDocs()+RWordDs->GetDocs();
94    int Sects=LWordDs->GetSects()+RWordDs->GetSects();
95    int WordIds=LWordIds+RWordIds;
96    PYWordDs WordDs=new TYWordDs(Docs, Sects, WordIds);
97    int LWordIdN=0; int RWordIdN=0;
98    if ((LSumWordFq>0)&&(RSumWordFq>0)){
99      while ((LWordIdN<LWordIds)&&(RWordIdN<RWordIds)){
100        TIntFltKd& LWordIdFqKd=LWordIdFqKdV[LWordIdN];
101        TIntFltKd& RWordIdFqKd=RWordIdFqKdV[RWordIdN];
102        if (LWordIdFqKd==RWordIdFqKd){
103          double LFq=LWgt*LWordIdFqKd.Dat/LSumWordFq;
104          double RFq=RWgt*RWordIdFqKd.Dat/RSumWordFq;
105          WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq+RFq); LWordIdN++; RWordIdN++;
106        } else
107        if (LWordIdFqKd<RWordIdFqKd){
108          double LFq=LWgt*LWordIdFqKd.Dat/LSumWordFq;
109          WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq); LWordIdN++;
110        } else {
111          double RFq=RWgt*RWordIdFqKd.Dat/RSumWordFq;
112          WordDs->AddWordIdFq(RWordIdFqKd.Key, RFq); RWordIdN++;
113        }
114      }
115    }
116    if (LSumWordFq>0){
117      while (LWordIdN<LWordIds){
118        TIntFltKd& LWordIdFqKd=LWordIdFqKdV[LWordIdN];
119        double LFq=LWgt*LWordIdFqKd.Dat/LSumWordFq;
120        WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq);
121        LWordIdN++;
122      }
123    }
124    if (RSumWordFq>0){
125      while (RWordIdN<RWordIds){
126        TIntFltKd& RWordIdFqKd=RWordIdFqKdV[RWordIdN];
127        double RFq=RWgt*RWordIdFqKd.Dat/RSumWordFq;
128        WordDs->AddWordIdFq(RWordIdFqKd.Key, RFq);
129        RWordIdN++;
130      }
131    }
132    return WordDs;
133  }
134  PYWordDs TYWordDs::GetTruncByMnWordPrb(
135   const PYWordDs& WordDs, const double& MnWordPrb){
136    double MnWordFq=MnWordPrb*WordDs->GetSumWordFq();
137    int TruncWordIds=0;
138    {int WordIdN=WordDs->FFirstWordId(); int WordId; double WordFq;
139    while (WordDs->FNextWordId(WordIdN, WordId, WordFq)){
140      if (WordFq>=MnWordFq){TruncWordIds++;}
141    }}
142    PYWordDs TruncYWordDs=new
143     TYWordDs(WordDs->GetDocs(), WordDs->GetSects(), TruncWordIds);
144    {int WordIdN=WordDs->FFirstWordId(); int WordId; double WordFq;
145    while (WordDs->FNextWordId(WordIdN, WordId, WordFq)){
146      if (WordFq>=MnWordFq){TruncYWordDs->AddWordIdFq(WordId, WordFq);}
147    }}
148    return TruncYWordDs;
149  }
150  PYWordDs TYWordDs::GetTruncBySumWordPrb(
151   const PYWordDs& WordDs, const double& SumWordPrb){
152    double TruncSumWordFq=SumWordPrb*WordDs->GetSumWordFq();
153    TFltIntKdV WordFqIdKdV(WordDs->GetWordIds(), 0);
154    {int WordIdN=WordDs->FFirstWordId(); int WordId; double WordFq;
155    while (WordDs->FNextWordId(WordIdN, WordId, WordFq)){
156      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
157    }}
158    WordFqIdKdV.Sort(false); double CurSumWordFq=0;
159    TIntFltKdV WordIdFqKdV;
160    for (int WordIdN=0; WordIdN<WordFqIdKdV.Len(); WordIdN++){
161      if (CurSumWordFq>TruncSumWordFq){break;}
162      double WordFq=WordFqIdKdV[WordIdN].Key;
163      int WordId=WordFqIdKdV[WordIdN].Dat;
164      WordIdFqKdV.Add(TIntFltKd(WordId, WordFq));
165      CurSumWordFq+=WordFq;
166    }
167    WordIdFqKdV.Sort();
168    PYWordDs TruncYWordDs=new TYWordDs(WordDs->GetDocs(), WordDs->GetSects());
169    {for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
170      TruncYWordDs->AddWordIdFq(WordIdFqKdV[WordIdN]);
171    }}
172    return TruncYWordDs;
173  }
174  const TStr TYBs::ParWordStr="/";
175  void TYBs::PutThisToWord(){
176    int WordToFqP=WordToFqH.FFirstKeyId();
177    while (WordToFqH.FNextKeyId(WordToFqP)){
178      WordToFqH.GetKey(WordToFqP).YBs=this;
179    }
180  }
181  TStr TYBs::GetStrQStr(const TStrQ& StrQ, const int& Strs){
182    TChA ChA;
183    int FirstStrN=(Strs==-1) ? 0 : StrQ.Len()-Strs;
184    for (int StrN=FirstStrN; StrN<StrQ.Len(); StrN++){
185      if (!ChA.Empty()){ChA+=' ';} ChA+=StrQ[StrN];
186    }
187    return ChA;
188  }
189  TYBs::TYBs(const PXWebBs& WebBs,
190   const int& _MxNGram, const int& _MnWordFq,
191   const TSwSetTy& SwSetTy, const TStrV& ExclUrlStrV,
192   const PNotify& _Notify):
193    Notify(_Notify),
194    MxNGram(_MxNGram), MnWordFq(_MnWordFq), ParWordId(-1),
195    RootDocId(-1), RootUrlStr(),
196    Sects(0), AbsSects(0),
197    SwSet(new TSwSet(SwSetTy)), CtgStrToFqH(30000),
198    WordToFqH(100000), WordChAHeap(1000000),
199    UrlStrToDocH(50000),
200    PathCtgIdVHeap(10000, 0), CtgIdVHeap(10000, 0),
201    ReftoDocIdVHeap(10000, 0), RefbyDocIdVHeap(),
202    WordIdVHeap(100000, 0){
203    TIntPrV DocIdRefbyDocIdPrV;
204    TStrV SortedExclUrlStrV(ExclUrlStrV);
205    SortedExclUrlStrV.Sort();
206    {int WebPgP=WebBs->FFirstWebPg(); int WebPgId;
207    while (WebBs->FNextWebPg(WebPgP, WebPgId)){
208      TStr UrlStr=WebBs->GetUrlStr(WebPgId);
209      PUrl Url=PUrl(new TUrl(UrlStr));
210      static TStr TreeHtmlStr="tree.html";
211      if (!Url->GetPathStr().IsSuffix(TreeHtmlStr)){
212        UrlStrToDocH.AddDat(UrlStr, PYDoc(new TYDoc()));
213        TStr PathStr=Url->GetPathStr();
214        if (Url->GetPathStr()=="/"){
215          IAssert(RootDocId==-1);
216          RootDocId=UrlStrToDocH.GetKeyId(UrlStr);
217          RootUrlStr=UrlStr;
218        }
219        for (int PathSegN=0; PathSegN<Url->GetPathSegs(); PathSegN++){
220          TStr PathSegStr=Url->GetPathSeg(PathSegN);
221          if (!PathSegStr.Empty()){CtgStrToFqH.AddDat(PathSegStr);}
222        }
223      }
224    }}
225    IAssert(RootDocId!=-1);
226    TStr DocObjGenStr=
227     TStr("Document Objects Generated (")+TInt::GetStr(UrlStrToDocH.Len())+")";
228    TNotify::OnNotify(Notify, ntInfo, DocObjGenStr);
229    TNotify::OnNotify(Notify, ntInfo, "Start Generation N-Grams");
230    for (int NGram=1; NGram<=MxNGram; NGram++){
231      {int WebPgP=WebBs->FFirstWebPg(); int WebPgId; int Docs=0;
232      while (WebBs->FNextWebPg(WebPgP, WebPgId)){
233        PXWebPg WebPg=WebBs->GetWebPg(WebPgId);
234        if (UrlStrToDocH.IsKey(WebPg->GetUrlStr())){
235          AddDoc(WebPg, false, NGram, SortedExclUrlStrV, DocIdRefbyDocIdPrV);}
236        if (++Docs%100==0){
237          TStr DocProcStr=
238           TStr("...")+TInt::GetStr(Docs)+" Documents; "+
239           TInt::GetStr(GetWords())+" N-Grams";
240          TNotify::OnNotify(Notify, ntInfo, DocProcStr);
241        }
242      }}
243      TStr NGramGenStr=TInt::GetStr(NGram)+"-Grams Generated ("+
244       TInt::GetStr(GetWords())+")";
245      TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
246      TStrIntPrV WordStrFqPrV(WordToFqH.Len(), 0);
247      int WordId=WordToFqH.FFirstKeyId();
248      while (WordToFqH.FNextKeyId(WordId)){
249        if (WordToFqH[WordId]>=MnWordFq){
250          WordStrFqPrV.Add(TStrIntPr(GetWordStr(WordId), TInt(GetWordFq(WordId))));}
251      }
252      WordToFqH.Clr(); WordChAHeap.Clr();
253      for (int WordN=0; WordN<WordStrFqPrV.Len(); WordN++){
254        AddWord(WordStrFqPrV[WordN].Val1)=WordStrFqPrV[WordN].Val2;}
255      TStr NGramReduceStr=TInt::GetStr(NGram)+"-Grams Reduced ("+
256       TInt::GetStr(GetWords())+")";
257      TNotify::OnNotify(Notify, ntInfo, NGramReduceStr);
258    }
259    TStr NGramGenStr=TInt::GetStr(MxNGram)+"-Grams Generation Finished ("+
260     TInt::GetStr(GetWords())+")";
261    TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
262    AddWord(ParWordStr)=0; ParWordId=GetWordId(ParWordStr);
263    TNotify::OnNotify(Notify, ntInfo, "Start Processing Documents");
264    {int WebPgP=WebBs->FFirstWebPg(); int WebPgId; int Docs=0;
265    while (WebBs->FNextWebPg(WebPgP, WebPgId)){
266      PXWebPg WebPg=WebBs->GetWebPg(WebPgId);
267      if (UrlStrToDocH.IsKey(WebPg->GetUrlStr())){
268        AddDoc(WebPg, true, -1, SortedExclUrlStrV, DocIdRefbyDocIdPrV);}
269      if (++Docs%100==0){
270        TStr DocProcStr=TInt::GetStr(Docs)+" Documents Processed";
271        TNotify::OnNotify(Notify, ntInfo, DocProcStr);
272      }
273    }}
274    DocIdRefbyDocIdPrV.Sort();
275    RefbyDocIdVHeap.Gen(DocIdRefbyDocIdPrV.Len()+UrlStrToDocH.Len(), 0);
276    int PrevDocId=-1;
277    for (int DocIdN=0; DocIdN<DocIdRefbyDocIdPrV.Len(); DocIdN++){
278      int DocId=DocIdRefbyDocIdPrV[DocIdN].Val1;
279      int RefbyDocId=DocIdRefbyDocIdPrV[DocIdN].Val2;
280      if (PrevDocId!=DocId){
281        if (PrevDocId!=-1){RefbyDocIdVHeap.Add(TInt(-1));}
282        UrlStrToDocH[DocId]->FirstRefbyDocIdN=RefbyDocIdVHeap.Len();
283        PrevDocId=DocId;
284      }
285      RefbyDocIdVHeap.Add(RefbyDocId);
286    }
287    RefbyDocIdVHeap.Add(TInt(-1));
288    {int DocId=FFirstDocId();
289    while (FNextDocId(DocId)){
290      if ((GetDocRefbys(DocId)==0)&&(DocId!=GetRootDocId())){
291        TStr MsgStr=TStr("Unreferenced page: ")+GetDocUrlStr(DocId);
292        TNotify::OnNotify(Notify, ntWarn, MsgStr);
293      }
294    }}
295    {int DocId=FFirstDocId();
296    while (FNextDocId(DocId)){
297      PYDoc Doc=GetDoc(DocId);
298      TIntV CtgIdV;
299      TIntH DocIdH(20);
300      TIntQ DocIdQ; DocIdQ.Push(DocId);
301      while (!DocIdQ.Empty()){
302        int DocId=DocIdQ.Top(); DocIdQ.Pop();
303        if (!DocIdH.IsKey(DocId)){
304          DocIdH.AddKey(DocId);
305          int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
306          while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){
307            DocIdQ.Push(RefbyDocId);}
308          int CtgIdN=FFirstDocPathCtgId(DocId); int CtgId;
309          while (FNextDocPathCtgId(CtgIdN, CtgId)){
310            if (CtgIdV.SearchBin(CtgId)==-1){CtgIdV.AddSorted(CtgId);}}
311        }
312      }
313      if (!CtgIdV.Empty()){
314        Doc->FirstCtgIdN=CtgIdVHeap.Len();
315        CtgIdVHeap.AddV(CtgIdV); CtgIdVHeap.Add(TInt(-1));
316      }
317    }}
318    TStr DocProcStr=TStr("Documents Processing Finished (")+
319     TInt::GetStr(UrlStrToDocH.Len())+")";
320    TNotify::OnNotify(Notify, ntInfo, DocProcStr);
321  }
322  void TYBs::AddCtgStrWords(const TStr& CtgStr, TIntV& DocWordIdV){
323    if (!CtgStr.Empty()){
324      TStr UcCtgStr=CtgStr.GetUc();
325      if (!UcCtgStr.IsChIn('_')){
326        TStr WordStr=UcCtgStr;
327        if ((WordStr.IsWord())&&(!SwSet->IsIn(WordStr))){
328          AddWord(WordStr)++; DocWordIdV.Add(TInt(GetWordId(WordStr)));
329        }
330      } else {
331        TChA WordChA; TStrV WordStrV; int ChN=0;
332        while (ChN<=UcCtgStr.Len()){
333          if ((ChN==UcCtgStr.Len())||(UcCtgStr[ChN]=='_')){
334            if (!WordChA.Empty()){
335              TStr WordStr=WordChA; WordChA.Clr();
336              if ((WordStr.IsWord())&&(!SwSet->IsIn(WordStr))){
337                WordStrV.Add(WordStr);}
338            }
339            if ((ChN+1<UcCtgStr.Len())&&(UcCtgStr[ChN+1]=='_')){
340              WordStrV.Add(TStr()); ChN++;}
341          } else {
342            WordChA+=UcCtgStr[ChN];
343          }
344          ChN++;
345        }
346        WordStrV.Add(TStr());
347        TChA NGramWordChA;
348        for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
349          TStr WordStr=WordStrV[WordStrN];
350          if (WordStr.Empty()){
351            if (!NGramWordChA.Empty()){
352              TStr NGramWordStr=NGramWordChA; NGramWordChA.Clr();
353              if (NGramWordStr.IsChIn(' ')){
354                AddWord(NGramWordStr)++; DocWordIdV.Add(TInt(GetWordId(NGramWordStr)));
355              }
356            }
357          } else {
358            AddWord(WordStr)++; DocWordIdV.Add(TInt(GetWordId(WordStr)));
359            if (!NGramWordChA.Empty()){NGramWordChA+=' ';}
360            NGramWordChA+=WordStr;
361          }
362        }
363      }
364    }
365  }
366  void TYBs::AddDoc(
367   const PXWebPg& WebPg, const bool& DoGenDoc,
368   const int& NGram, const TStrV& ExclUrlStrV,
369   TIntPrV& DocIdRefbyDocIdPrV){
370    TStr DocUrlStr;
371    int DocId=-1;
372    PYDoc Doc;
373    bool IsDocWhitePg=false;
374    TIntV DocCtgIdV;
375    TIntV DocReftoDocIdV;
376    TIntV DocWordIdV;
377    int DocSects=0;
378    int DocAbsSects=0;
379    if (DoGenDoc){
380      DocUrlStr=WebPg->GetUrlStr();
381      DocId=UrlStrToDocH.GetKeyId(DocUrlStr);
382      Doc=UrlStrToDocH.AddDat(DocUrlStr);
383      PUrl DocUrl=new TUrl(DocUrlStr);
384      IsDocWhitePg=false;
385      int DocPathSegs=DocUrl->GetPathSegs();
386      if (DocPathSegs>=2){
387        IsDocWhitePg=DocUrl->GetPathSeg(DocPathSegs-2)=="White_Pages";}
388      DocCtgIdV.Gen(20, 0);
389      DocReftoDocIdV.Gen(100, 0);
390      DocWordIdV.Gen(1000, 0);
391      DocSects=0;
392      DocAbsSects=0;
393    }
394    if (DoGenDoc){
395      PUrl DocUrl=new TUrl(DocUrlStr); IAssert(DocUrl->IsOk());
396      for (int PathSegN=0; PathSegN<DocUrl->GetPathSegs(); PathSegN++){
397        TStr PathSegStr=DocUrl->GetPathSeg(PathSegN);
398        if (!PathSegStr.Empty()){
399          CtgStrToFqH.GetDat(PathSegStr)++;
400          DocCtgIdV.Add(TInt(CtgStrToFqH.GetKeyId(PathSegStr)));
401          AddCtgStrWords(PathSegStr, DocWordIdV);
402        }
403      }
404      if (DocUrl->GetPathSegs()>0){DocWordIdV.Add(ParWordId); DocSects++;}
405    }
406    PSIn SIn=TStrIn::New(WebPg->GetBodyStr());
407    PHtmlDoc HtmlDoc=PHtmlDoc(new THtmlDoc(SIn, hdtAll));
408    bool InLi=false; bool ActLi=false; TStrQ PrevStrQ;
409    PHtmlTok Tok; THtmlLxSym Sym=hsyUndef; TStr Str; int TokN=0;
410    while ((TokN<HtmlDoc->GetToks())&&((Sym!=hsyBTag)||(Str!=THtmlTok::UlTagNm))){
411      Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
412      if (DoGenDoc&& !IsDocWhitePg){
413        if ((Sym==hsyBTag)&&(Str==THtmlTok::CenterTagNm)){
414          Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
415          if ((Sym==hsySSym)&&(Str=="[")){
416            while ((TokN<HtmlDoc->GetToks())&&
417             ((Sym!=hsyBTag)||(Str!=THtmlTok::UlTagNm))){
418              Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
419              if ((Sym==hsyBTag)&&(Str==THtmlTok::ATagNm)){
420                PUrl Url=new TUrl(Tok->GetArg(THtmlTok::HRefArgNm), DocUrlStr);
421                if (Url->IsOk()){
422                  IAssert(Url->GetPathSeg(Url->GetPathSegs()-2)=="White_Pages");
423                  int ReftoDocId=UrlStrToDocH.GetKeyId(Url->GetUrlStr());
424                  if ((ReftoDocId!=-1)&&(ReftoDocId!=int(RootDocId))&&
425                   (ReftoDocId!=DocId)){
426                    DocReftoDocIdV.AddMerged(ReftoDocId);
427                    DocIdRefbyDocIdPrV.AddMerged(TIntPr(ReftoDocId, DocId));
428                  }
429                }
430              }
431            }
432          }
433        }
434      }
435    }
436    while (TokN<HtmlDoc->GetToks()){
437      Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
438      switch (Sym){
439        case hsyStr:
440          if (InLi&&ActLi){
441            if (DoGenDoc){
442              if (!SwSet->IsIn(Str)){
443                int WordId=GetWordId(Str);
444                if (WordId!=-1){
445                  DocWordIdV.Add(WordId);
446                  PrevStrQ.Push(Str);
447                  int NGram=2;
448                  while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
449                    int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
450                    if (WordId==-1){
451                      while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
452                    } else {
453                      DocWordIdV.Add(WordId);
454                    }
455                    NGram++;
456                  }
457                } else {
458                  PrevStrQ.Clr();
459                }
460              }
461            } else {
462              if (NGram==1){
463                if (!SwSet->IsIn(Str)){AddWord(Str)++;}
464              } else {
465                if (!SwSet->IsIn(Str)){
466                  int WordId=GetWordId(Str);
467                  if (WordId!=-1){
468                    TStr WordStr=GetWordStr(WordId);
469                    if (PrevStrQ.Len()+1==NGram){
470                      if (GetWordId(GetStrQStr(PrevStrQ))!=-1){
471                        PrevStrQ.Push(WordStr);
472                        AddWord(GetStrQStr(PrevStrQ))++;
473                        PrevStrQ.Pop();
474                      } else {
475                        PrevStrQ.Push(WordStr); PrevStrQ.Pop();
476                      }
477                    } else {
478                      PrevStrQ.Push(WordStr);
479                    }
480                  } else {
481                    PrevStrQ.Clr();
482                  }
483                }
484              }
485            }
486          }
487          break;
488        case hsyNum:
489          if (InLi&&ActLi){PrevStrQ.Clr();}
490          break;
491        case hsySSym:
492          if (InLi&&ActLi){PrevStrQ.Clr();}
493          break;
494        case hsyBTag:
495          if (Str==THtmlTok::LiTagNm){
496            if (DoGenDoc&&(DocWordIdV.Len()>0)&&(DocWordIdV.Last()!=ParWordId)){
497              DocWordIdV.Add(ParWordId); DocSects++;}
498            InLi=true; ActLi=true; PrevStrQ.Clr();
499          } else
500          if (InLi&&ActLi&&(Str==THtmlTok::ATagNm)){
501            TStr ItemUrlStr=Tok->GetArg(THtmlTok::HRefArgNm);
502            if (ExclUrlStrV.SearchBin(ItemUrlStr)!=-1){
503              ActLi=false;}
504            if (DoGenDoc&&InLi&&ActLi){
505              if (TUrl::IsAbs(ItemUrlStr)){
506                DocAbsSects++;}
507              PUrl ItemUrl=TUrl::New(ItemUrlStr, DocUrlStr);
508              if (ItemUrl->IsOk()){
509                int ReftoDocId=UrlStrToDocH.GetKeyId(ItemUrl->GetUrlStr());
510                if ((ReftoDocId!=-1)&&(ReftoDocId!=int(RootDocId))&&
511                 (ReftoDocId!=DocId)){
512                  DocReftoDocIdV.AddMerged(ReftoDocId);
513                  DocIdRefbyDocIdPrV.AddMerged(TIntPr(ReftoDocId, DocId));
514                }
515              }
516            }
517          }
518          break;
519        case hsyETag:
520          if (Str==THtmlTok::UlTagNm){
521            if (DoGenDoc&&(DocWordIdV.Len()>0)&&(DocWordIdV.Last()!=ParWordId)){
522              DocWordIdV.Add(ParWordId); DocSects++;
523            }
524            InLi=false; ActLi=false; PrevStrQ.Clr();
525          }
526          break;
527        default:;
528      }
529    }
530    if (DoGenDoc){
531      if (!DocCtgIdV.Empty()){
532        Doc->FirstPathCtgIdN=PathCtgIdVHeap.Len();
533        PathCtgIdVHeap.AddV(DocCtgIdV); PathCtgIdVHeap.Add(TInt(-1));
534      }
535      if (!DocReftoDocIdV.Empty()){
536        Doc->FirstReftoDocIdN=ReftoDocIdVHeap.Len();
537        ReftoDocIdVHeap.AddV(DocReftoDocIdV); ReftoDocIdVHeap.Add(TInt(-1));
538      }
539      if (!DocWordIdV.Empty()){
540        Doc->FirstWordIdN=WordIdVHeap.Len();
541        WordIdVHeap.AddV(DocWordIdV); WordIdVHeap.Add(TInt(-1));
542      }
543      Doc->Sects=DocSects; Sects+=DocSects;
544      Doc->AbsSects=DocAbsSects; AbsSects+=DocAbsSects;
545    }
546  }
547  TStr TYBs::GetCtgIdVStr(const TIntV& CtgIdV){
548    TChA ChA;
549    for (int CtgIdN=0; CtgIdN<CtgIdV.Len(); CtgIdN++){
550      if (CtgIdN>0){ChA+=' ';}
551      ChA+=GetCtgStr(CtgIdV[CtgIdN]);
552    }
553    return ChA;
554  }
555  void TYBs::GetCtgStrV(const TIntV& CtgIdV, TStrV& CtgStrV){
556    CtgStrV.Gen(CtgIdV.Len(), 0);
557    for (int CtgIdN=0; CtgIdN<CtgIdV.Len(); CtgIdN++){
558      TStr CtgStr=GetCtgStr(CtgIdV[CtgIdN]);
559      CtgStrV.Add(CtgStr);
560    }
561  }
562  TStr TYBs::GetCtgIdToWFqHStr(const TIntFltH& CtgIdToWFqH, const double& SumPrb){
563    TFltIntKdV CtgWFqIdKdV(CtgIdToWFqH.Len(), 0);
564    double SumCtgWFq=0;
565    int CtgIdToWFqP=CtgIdToWFqH.FFirstKeyId();
566    while (CtgIdToWFqH.FNextKeyId(CtgIdToWFqP)){
567      int CtgId=CtgIdToWFqH.GetKey(CtgIdToWFqP);
568      double CtgWFq=CtgIdToWFqH[CtgIdToWFqP];
569      CtgWFqIdKdV.Add(TFltIntKd(CtgWFq, CtgId));
570      SumCtgWFq+=CtgWFq;
571    }
572    CtgWFqIdKdV.Sort(false);
573    SumCtgWFq*=SumPrb;
574    TChA ChA;
575    for (int CtgWFqIdKdN=0; CtgWFqIdKdN<CtgWFqIdKdV.Len(); CtgWFqIdKdN++){
576      double CtgWFq=CtgWFqIdKdV[CtgWFqIdKdN].Key;
577      int CtgId=CtgWFqIdKdV[CtgWFqIdKdN].Dat;
578      SumCtgWFq-=CtgWFq;
579      if (SumCtgWFq>=0){
580        ChA+=GetCtgStr(CtgId);
581        ChA+=" ";
582      }
583    }
584    return ChA;
585  }
586  TInt& TYBs::AddWord(const TStr& WordStr){
587    int PrevLen=WordChAHeap.Len();
588    TYWord Word(this, WordStr);
589    int WordId=WordToFqH.GetKeyId(Word);
590    if (WordId==-1){
591      return WordToFqH.AddDat(Word);
592    } else {
593      WordChAHeap.Trunc(PrevLen);
594      return WordToFqH[WordId];
595    }
596  }
597  int TYBs::GetWordId(const TStr& WordStr){
598    int PrevLen=WordChAHeap.Len();
599    TYWord Word(this, WordStr);
600    int WordId=WordToFqH.GetKeyId(Word);
601    WordChAHeap.Trunc(PrevLen);
602    return WordId;
603  }
604  void TYBs::GetLevDocIdV(const int& Lev, TIntV& DocIdV){
605    DocIdV.Clr();
606    int DocId=FFirstDocId();
607    while (FNextDocId(DocId)){
608      PUrl Url=new TUrl(GetDocUrlStr(DocId));
609      if (Url->GetPathSegs()==Lev){
610        DocIdV.Add(DocId);}
611    }
612  }
613  void TYBs::GetCtgIdV(const int& DocId, TIntV& CtgIdV){
614    CtgIdV.Clr();
615    int CtgIdN=FFirstDocCtgId(DocId); int CtgId;
616    while (FNextDocCtgId(CtgIdN, CtgId)){
617      CtgIdV.Add(CtgId);}
618  }
619  void TYBs::GetParentDocIdV(const int& DocId, TIntV& DocIdV){
620    DocIdV.Clr();
621    TIntQ DocIdQ; DocIdQ.Push(DocId);
622    while (!DocIdQ.Empty()){
623      int DocId=DocIdQ.Top(); DocIdQ.Pop();
624      if (DocIdV.SearchBin(DocId)==-1){
625        DocIdV.AddSorted(DocId);
626        int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
627        while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){
628          DocIdQ.Push(RefbyDocId);}
629      }
630    }
631  }
632  int TYBs::GetDocDist(const int& LDocId, const int& RDocId){
633    TIntIntH LDocIdToDistH(100);
634    TIntPrQ LDocIdQ; LDocIdQ.Push(TIntPr(LDocId, TInt(0)));
635    while (!LDocIdQ.Empty()){
636      int DocId=LDocIdQ.Top().Val1; int Dist=LDocIdQ.Top().Val2; LDocIdQ.Pop();
637      if (!LDocIdToDistH.IsKey(DocId)){
638        LDocIdToDistH.AddDat(DocId, Dist);
639        int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
640        while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){
641          LDocIdQ.Push(TIntPr(RefbyDocId, TInt(Dist+1)));}
642      }
643    }
644    TIntPrQ RDocIdQ; RDocIdQ.Push(TIntPr(RDocId, TInt(0)));
645    while (!RDocIdQ.Empty()){
646      int DocId=RDocIdQ.Top().Val1; int Dist=RDocIdQ.Top().Val2; RDocIdQ.Pop();
647      if (LDocIdToDistH.IsKey(DocId)){
648        return Dist+LDocIdToDistH.GetDat(DocId);
649      } else {
650        int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
651        while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){
652          RDocIdQ.Push(TIntPr(RefbyDocId, TInt(Dist+1)));}
653      }
654    }
655    return -1;
656  }
657  int TYBs::GetDocReftos(const int& DocId){
658    int Reftos=0;
659    int ReftoDocIdN=FFirstDocReftoDocId(DocId); int ReftoDocId;
660    while (FNextDocReftoDocId(ReftoDocIdN, ReftoDocId)){Reftos++;}
661    return Reftos;
662  }
663  int TYBs::GetDocRefbys(const int& DocId){
664    int Refbys=0;
665    int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
666    while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){Refbys++;}
667    return Refbys;
668  }
669  PYWordDs TYBs::GetWordDs(const PSIn& SIn){
670    PYWordDs WordDs=PYWordDs(new TYWordDs());
671    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtAll);
672    TStrQ PrevStrQ;
673    PHtmlTok Tok; THtmlLxSym Sym; TStr Str;
674    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
675      Tok=HtmlDoc->GetTok(TokN, Sym, Str);
676      switch (Sym){
677        case hsyStr:
678          if (!SwSet->IsIn(Str)){
679            int WordId=GetWordId(Str);
680            if (WordId!=-1){
681              WordDs->AddWordIdFq(WordId, 1);
682              PrevStrQ.Push(Str);
683              int NGram=2;
684              while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
685                int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
686                if (WordId==-1){
687                  while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
688                } else {
689                  WordDs->AddWordIdFq(WordId, 1);
690                }
691                NGram++;
692              }
693            } else {
694              PrevStrQ.Clr();
695            }
696          }
697          break;
698        case hsyNum:
699        case hsySSym:
700          PrevStrQ.Clr(); break;
701        case hsyBTag:
702        case hsyETag:
703          if (THtmlTok::IsBreakTag(Str)){PrevStrQ.Clr();} break;
704        default:;
705      }
706    }
707    return WordDs;
708  }
709  void TYBs::GetAbsSectV(
710   const TStr& RefUrlStr, const PXWebPg& WebPg, TYSectV& YSectV){
711    YSectV.Gen(100, 0);
712    TChA TitleChA;
713    PUrl RefUrl=PUrl(new TUrl(RefUrlStr)); IAssert(RefUrl->IsOk());
714    TitleChA+=THtmlTok::TitleTagNm; TitleChA+=RefUrl->GetPathStr();
715    TitleChA+=THtmlTok::TitleETagNm; TitleChA.ChangeCh('_', ' ');
716    PSIn SIn=TStrIn::New(WebPg->GetBodyStr());
717    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtUL);
718    PHtmlTok Tok; THtmlLxSym Sym; TStr Str; int TokN=0;
719    while (TokN<HtmlDoc->GetToks()){
720      Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
721      if ((Sym==hsyBTag)&&(Str==THtmlTok::LiTagNm)){
722        IAssert(TokN<HtmlDoc->GetToks());
723        Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
724        IAssert((Sym==hsyBTag)&&(Str==THtmlTok::ATagNm));
725        IAssert(Tok->IsArg(THtmlTok::HRefArgNm));
726        TChA TxtChA; TxtChA+=TitleChA; TxtChA+=' '; TxtChA+=Tok->GetFullStr();
727        TStr UrlStr=Tok->GetArg(THtmlTok::HRefArgNm);
728        if (TUrl::IsAbs(UrlStr)){
729          PUrl Url=PUrl(new TUrl(UrlStr));
730          if (Url->IsOk()){
731            PYWordDs WordDs=PYWordDs(new TYWordDs());
732            TStrQ PrevStrQ; bool InSect=true;
733            while ((InSect)&&(TokN<HtmlDoc->GetToks())){
734              Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
<span onclick='openModal()' class='match'>735              switch (Sym){
736                case hsyStr:
737                  if (!SwSet->IsIn(Str)){
738                    int WordId=GetWordId(Str);
739                    if (WordId!=-1){
740                      WordDs->AddWordIdFq(WordId, 1);
741                      PrevStrQ.Push(Str);
742                      int NGram=2;
743                      while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
744                        int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
745                        if (WordId==-1){
746                          while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
747                        } else {
748                          WordDs->AddWordIdFq(WordId, 1);
749                        }
750                        NGram++;
751                      }
752                    } else {
753                      PrevStrQ.Clr();
754                    }
755                  }
756                  break;
757                case hsyNum: PrevStrQ.Clr(); break;
</span>758                case hsySSym: PrevStrQ.Clr(); break;
759                case hsyBTag: InSect=(Str!=THtmlTok::LiTagNm); break;
760                case hsyETag: InSect=(Str!=THtmlTok::UlTagNm); break;
761                default:;
762              }
763              if (InSect){TxtChA+=' '; TxtChA+=Tok->GetFullStr();;}
764            }
765            PYSect YSect=new TYSect(RefUrlStr, Url->GetUrlStr(), WordDs, TxtChA);
766            YSectV.Add(YSect);
767          }
768        }
769      }
770    }
771  }
772  void TYBs::GetAbsSectUrlStrV(const PXWebPg& WebPg, TStrV& UrlStrV){
773    UrlStrV.Gen(100, 0);
774    PSIn SIn=TStrIn::New(WebPg->GetBodyStr());
775    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtUL);
776    PHtmlTok Tok; THtmlLxSym Sym; TStr Str; int TokN=0;
777    while (TokN<HtmlDoc->GetToks()){
778      Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
779      if ((Sym==hsyBTag)&&(Str==THtmlTok::LiTagNm)){
780        IAssert(TokN<HtmlDoc->GetToks());
781        Tok=HtmlDoc->GetTok(TokN++, Sym, Str);
782        IAssert((Sym==hsyBTag)&&(Str==THtmlTok::ATagNm));
783        IAssert(Tok->IsArg(THtmlTok::HRefArgNm));
784        TStr UrlStr=Tok->GetArg(THtmlTok::HRefArgNm);
785        if (TUrl::IsAbs(UrlStr)){
786          PUrl Url=new TUrl(UrlStr);
787          if (Url->IsOk()){
788            UrlStrV.Add(Url->GetUrlStr());}
789        }
790      }
791    }
792  }
793  void TYBs::SaveTxt(const PSOut& SOut){
794    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
795    int UrlStrToDocP=UrlStrToDocH.FFirstKeyId();
796    while (UrlStrToDocH.FNextKeyId(UrlStrToDocP)){
797      TStr UrlStr=UrlStrToDocH.GetKey(UrlStrToDocP);
798      PYDoc Doc=UrlStrToDocH[UrlStrToDocP]; TChA ChA(10000);
799      int DocId=UrlStrToDocP;
800      Lx.PutVarStr("UrlStr", UrlStr);
801      Lx.PutVarInt("DocId", DocId);
802      Lx.PutVarInt("Sects", Doc->Sects);
803      Lx.PutVarInt("AbsSects", Doc->AbsSects);
804      TIntV CtgIdV; GetCtgIdV(DocId, CtgIdV);
805      Lx.PutVarStr("CtgIdV", GetCtgIdVStr(CtgIdV));
806      Lx.PutVar("ReftoDocIdV", true, false); 
807      if (Doc->FirstReftoDocIdN!=-1){
808        int ReftoDocIdN=Doc->FirstReftoDocIdN;
809        while (ReftoDocIdVHeap[ReftoDocIdN]!=-1){
810          Lx.PutInt(ReftoDocIdVHeap[ReftoDocIdN++]);}
811      }
812      Lx.PutSym(syRBracket); Lx.PutLn();
813      Lx.PutVar("RefbyDocIdV", true, false);
814      if (Doc->FirstRefbyDocIdN!=-1){
815        int RefbyDocIdN=Doc->FirstRefbyDocIdN;
816        while (RefbyDocIdVHeap[RefbyDocIdN]!=-1){
817          Lx.PutInt(RefbyDocIdVHeap[RefbyDocIdN++]);}
818      }
819      Lx.PutSym(syRBracket); Lx.PutLn();
820      Lx.PutVar("Doc", true, true);
821      if (Doc->FirstWordIdN!=-1){
822        int WordIdN=Doc->FirstWordIdN;
823        while (WordIdVHeap[WordIdN]!=-1){
824          int WordId=WordIdVHeap[WordIdN++];
825          TStr WordStr=GetWordStr(WordId);
826          int WordSegs=GetWordSegs(WordId);
827          if (WordId==int(ParWordId)){
828            Lx.PutQStr(ChA); Lx.PutLn(); ChA.Clr();
829          } else {
830            if (!ChA.Empty()){ChA+=' ';}
831            if (WordStr.SearchCh(' ')==-1){
832              ChA+=WordStr;
833            } else {
834              ChA+='('; ChA+='#'; ChA+=TInt::GetStr(WordSegs);
835              ChA+=' '; ChA+=WordStr; ChA+=')';
836            }
837          }
838        }
839      }
840      Lx.PutSym(syRBracket); Lx.PutLn(); Lx.PutLn();
841    }
842  }
843  void TYBs::SaveTxtWords(const TStr& FNm){
844    TIntStrKdV WordFqStrKdV;
845    int WordToFqP=WordToFqH.FFirstKeyId();
846    while (WordToFqH.FNextKeyId(WordToFqP)){
847      TStr WordStr=GetWordStr(WordToFqP);
848      int WordFq=WordToFqH[WordToFqP];
849      WordFqStrKdV.Add(TIntStrKd(WordFq, WordStr));
850    }
851    WordFqStrKdV.Sort(false);
852    PSOut WordSOut=PSOut(new TFOut(FNm));
853    for (int WordFqStrKdN=0; WordFqStrKdN<WordFqStrKdV.Len(); WordFqStrKdN++){
854      int WordFq=WordFqStrKdV[WordFqStrKdN].Key;
855      TStr WordStr=WordFqStrKdV[WordFqStrKdN].Dat;
856      WordSOut->PutStr(WordStr); WordSOut->PutStr(": ");
857      WordSOut->PutStr(TInt::GetStr(WordFq)); WordSOut->PutLn();
858    }
859  }
860  void TYBs::SaveTxtCtgs(const TStr& FNm){
861    TIntStrKdV CtgFqStrKdV;
862    int CtgStrToFqP=CtgStrToFqH.FFirstKeyId();
863    while (CtgStrToFqH.FNextKeyId(CtgStrToFqP)){
864      TStr CtgStr=CtgStrToFqH.GetKey(CtgStrToFqP);
865      int CtgFq=CtgStrToFqH[CtgStrToFqP];
866      CtgFqStrKdV.Add(TIntStrKd(CtgFq, CtgStr));
867    }
868    CtgFqStrKdV.Sort(false);
869    PSOut CtgSOut=PSOut(new TFOut(FNm));
870    for (int CtgFqStrKdN=0; CtgFqStrKdN<CtgFqStrKdV.Len(); CtgFqStrKdN++){
871      int CtgFq=CtgFqStrKdV[CtgFqStrKdN].Key;
872      TStr CtgStr=CtgFqStrKdV[CtgFqStrKdN].Dat;
873      int CtgId=GetCtgId(CtgStr);
874      CtgSOut->PutStr(CtgStr); CtgSOut->PutStr(": ");
875      CtgSOut->PutStr(TInt::GetStr(CtgFq));
876      CtgSOut->PutStr(TStr(" [Id:")+TInt::GetStr(CtgId)+"]");
877      CtgSOut->PutLn();
878    }
879  }
880  int TYDsBs::GetMissDss(const PYBs& YBs, const int& DocId){
881    int MissDss=0;
882    int ReftoDocIdN=YBs->FFirstDocReftoDocId(DocId); int ReftoDocId;
883    while (YBs->FNextDocReftoDocId(ReftoDocIdN, ReftoDocId)){
884      if (!DocIdToWordDsH.IsKey(ReftoDocId)){MissDss++;}}
885    return MissDss;
886  }
887  double TYDsBs::GetNrWgt(const TYDsBsNrType& NrType, const PYWordDs& WordDs){
888    switch (NrType){
889      case ydnConst: return 1;
890      case ydnWords: return WordDs->GetSumWordFq();
891      case ydnLnWords: return log10(1+WordDs->GetSumWordFq());
892      case ydnSects: return 1+WordDs->GetSects();
893      case ydnLnSects: return log10(1+WordDs->GetSects());
894      case ydnDocs: return 1+WordDs->GetDocs();
895      case ydnLnDocs: return log10(1+WordDs->GetDocs());
896      default: Fail; return -1;
897    }
898  }
899  TYDsBs::TYDsBs(const TYDsBsNrType& NrType, const double& WordFqExp,
900   const double& MnWordPrb, const double& &bsol;*MnAllWordPrb*/,
901   const PYBs& YBs, const PNotify& _Notify):
902    Notify(_Notify), AllWordDs(), DocIdToWordDsH(10000){
903    TNotify::OnNotify(Notify, ntInfo, "Start Creating Distributions");
904    int RootDocId=YBs->GetRootDocId();
905    int ParWordId=YBs->GetParWordId();
906    int PrevDocs=0; int MxMissDss=0;
907    TIntH RepDocIdH(1000); int RepDocIters=3;
908    while ((DocIdToWordDsH.Len()<YBs->GetDocs())||(!RepDocIdH.Empty())){
909      if ((DocIdToWordDsH.Len()>0)&&(PrevDocs==DocIdToWordDsH.Len())){
910        if (PrevDocs==YBs->GetDocs()){MxMissDss=-1;} else {MxMissDss++;}
911      }
912      PrevDocs=DocIdToWordDsH.Len();
913      int DocId=YBs->FFirstDocId();
914      while (YBs->FNextDocId(DocId)){
915        bool MkWordDs=false;
916        if (MxMissDss==-1){
917          if (RepDocIdH.IsKey(DocId)){
918            MkWordDs=true;
919            if (RepDocIters<=1){RepDocIdH.DelKey(DocId);}
920          }
921        } else {
922          if (!DocIdToWordDsH.IsKey(DocId)){
923            int MissDss=GetMissDss(YBs, DocId);
924            if (MissDss<=MxMissDss){
925              MkWordDs=true; if (MissDss>0){RepDocIdH.AddKey(DocId);}
926            }
927          }
928        }
929        if (MkWordDs){
930          PYWordDs WordDs=new TYWordDs(1);
931          int WordIdN=YBs->FFirstDocWordId(DocId); int WordId;
932          while (YBs->FNextDocWordId(WordIdN, WordId)){
933            if (WordId==ParWordId){WordDs->AddSect();}
934            else {WordDs->AddWordIdFq(WordId, 1);}
935          }
936          IAssert(WordDs->GetSects()==YBs->GetDocSects(DocId));
937          WordDs->NrToSumWordFq(GetNrWgt(NrType, WordDs));
938          int ReftoDocIdN=YBs->FFirstDocReftoDocId(DocId); int ReftoDocId;
939          while (YBs->FNextDocReftoDocId(ReftoDocIdN, ReftoDocId)){
940            if (DocIdToWordDsH.IsKey(ReftoDocId)){
941              PYWordDs ReftoWordDs=DocIdToWordDsH.GetDat(ReftoDocId);
942              double ReftoWordDsW=GetNrWgt(NrType, ReftoWordDs);
943              WordDs=TYWordDs::GetMerged(WordDs, ReftoWordDs,
944               WordDs->GetSumWordFq(), ReftoWordDsW);
945            }
946          }
947          WordDs->PowWordFq(WordFqExp);
948          WordDs=TYWordDs::GetTruncByMnWordPrb(WordDs, MnWordPrb);
949          DocIdToWordDsH.AddDat(DocId, WordDs);
950          if (DocIdToWordDsH.Len()%1000==0){
951            TNotify::OnNotify(Notify, ntInfo, TStr("...")+
952             TInt::GetStr(DocIdToWordDsH.Len())+" Distrs.");
953          }
954        }
955      }
956      if (MxMissDss==-1){
957        if (--RepDocIters==0){RepDocIdH.AddKey(RootDocId);}
958      }
959      TStr OnWordDsStr=TStr("Missing distrs.: ")+TInt::GetStr(MxMissDss)+";"+
960       " Docs.: "+TInt::GetStr(DocIdToWordDsH.Len());
961      TNotify::OnNotify(Notify, ntInfo, OnWordDsStr);
962    }
963    TNotify::OnNotify(Notify, ntInfo, "Create Overall Distribution");
964    int AllDocs=GetWordDs(RootDocId)->GetDocs();
965    int AllSects=GetWordDs(RootDocId)->GetSects();
966    AllWordDs=PYWordDs(new TYWordDs(AllDocs, AllSects, YBs->GetWords()));
967    {int WordId=YBs->FFirstWordId();
968    while (YBs->FNextWordId(WordId)){
969      AllWordDs->AddWordIdFq(WordId, YBs->GetWordFq(WordId));}}
970    AllWordDs->PowWordFq(WordFqExp);
971    AllWordDs=TYWordDs::GetTruncBySumWordPrb(AllWordDs, 0.9);
972    TNotify::OnNotify(Notify, ntInfo, "Finished Creating Distributions");
973  }
974  void TYDsBs::SaveTxt(const PSOut& SOut, const PYBs& YBs){
975    AllWordDs->SaveTxt(SOut, YBs(), -1);
976    int DocIdToWordDsP=DocIdToWordDsH.FFirstKeyId();
977    while (DocIdToWordDsH.FNextKeyId(DocIdToWordDsP)){
978      int DocId=DocIdToWordDsH.GetKey(DocIdToWordDsP);
979      PYWordDs WordDs=DocIdToWordDsH[DocIdToWordDsP];
980      WordDs->SaveTxt(SOut, YBs(), DocId);
981    }
982  }
983  TStr TYDsBs::GetNrTypeStr(const TYDsBsNrType& NrType){
984    switch (NrType){
985      case ydnConst: return "Const";
986      case ydnWords: return "Words";
987      case ydnLnWords: return "LnWords";
988      case ydnSects: return "Sects";
989      case ydnLnSects: return "LnSects";
990      case ydnDocs: return "Docs";
991      case ydnLnDocs: return "LnDocs";
992      default: Fail; return TStr();
993    }
994  }
995  TYTsBs::TYTsBs(
996   const double& AbsSectsPrb, const double& SectPrb, const TStr& TsWebBsFPath,
997   const PXWebBs& RefWebBs, const PYBs& RefYBs,
998   const PXWebTravelEvent& WebTravelEvent, const PNotify& Notify):
999    TsRefUrlStrH(1000), WebBs(), WebTravel(){
1000    IAssert((0<=AbsSectsPrb)&&(AbsSectsPrb<=1));
1001    if (AbsSectsPrb==1){
1002      TRnd Rnd;
1003      int DocId=RefYBs->FFirstDocId();
1004      while (RefYBs->FNextDocId(DocId)){
1005        if (RefYBs->GetDocRefbys(DocId)==0){continue;}
1006        TStr RefUrlStr=RefYBs->GetDocUrlStr(DocId);
1007        PXWebPg WebPg=RefWebBs->GetWebPg(RefUrlStr);
1008        TStrV UrlStrV; TYBs::GetAbsSectUrlStrV(WebPg, UrlStrV);
1009        for (int UrlStrN=0; UrlStrN<UrlStrV.Len(); UrlStrN++){
1010          if (Rnd.GetUniDev()<SectPrb){
1011            TsRefUrlStrH.AddDat(UrlStrV[UrlStrN], RefUrlStr);
1012          }
1013        }
1014      }
1015    } else {
1016      int TsDocs=int(AbsSectsPrb*RefYBs->GetAbsSects());
1017      TRnd Rnd;
1018      while (TsRefUrlStrH.Len()<TsDocs){
1019        int DocId=Rnd.GetUniDevInt(RefYBs->GetDocs());
1020        if (RefYBs->GetDocRefbys(DocId)==0){continue;}
1021        TStr RefUrlStr=RefYBs->GetDocUrlStr(DocId);
1022        PXWebPg WebPg=RefWebBs->GetWebPg(RefUrlStr);
1023        TStrV UrlStrV; TYBs::GetAbsSectUrlStrV(WebPg, UrlStrV);
1024        if (UrlStrV.Len()==0){continue;}
1025        int UrlStrN=Rnd.GetUniDevInt(UrlStrV.Len());
1026        TStr TsUrlStr=UrlStrV[UrlStrN];
1027        TsRefUrlStrH.AddDat(TsUrlStr, RefUrlStr);
1028      }
1029    }
1030    TNotify::OnNotify(Notify, ntInfo,
1031     TStr("Loading ")+TInt::GetStr(TsRefUrlStrH.Len())+" Documents.");
1032    WebBs=PXWebBs(new TWebMemBs(100, TsWebBsFPath, true));
1033    WebTravel=PXWebTravel(new TXWebTravel(WebBs, WebTravelEvent));
1034    int TsSrcUrlStrP=TsRefUrlStrH.FFirstKeyId();
1035    while (TsRefUrlStrH.FNextKeyId(TsSrcUrlStrP)){
1036      TStr TsUrlStr=TsRefUrlStrH.GetKey(TsSrcUrlStrP);
1037      WebTravel->Go(TsUrlStr);
1038    }
1039  }
1040  TYTsBs::~TYTsBs(){
1041    int WebPgP=WebBs->FFirstWebPg(); int WebPgId;
1042    while (WebBs->FNextWebPg(WebPgP, WebPgId)){
1043      TStr TsUrlStr=WebBs->GetUrlStr(WebPgId);
1044      TStr RefUrlStr=TsRefUrlStrH.GetDat(TsUrlStr);
1045      WebBs->AddWebPgRef(TsUrlStr, RefUrlStr);
1046    }
1047  }
1048  TYHlCtx::TYHlCtx(
1049   const PXWebBs& RefWebBs, const PYBs& RefYBs, const PXWebBs& DocWebBs,
1050   const PNotify& &bsol;*Notify*/): HlCtxStrV(){
1051    int RefDocId=RefYBs->FFirstDocId();
1052    while (RefYBs->FNextDocId(RefDocId)){
1053      TStr RefUrlStr=RefYBs->GetDocUrlStr(RefDocId);
1054      PXWebPg WebPg=RefWebBs->GetWebPg(RefUrlStr);
1055      TYSectV YSectV; RefYBs->GetAbsSectV(RefUrlStr, WebPg, YSectV);
1056      for (int YSectN=0; YSectN<YSectV.Len(); YSectN++){
1057        PYSect YSect=YSectV[YSectN];
1058        if (DocWebBs->IsUrlStr(YSect->GetUrlStr())){
1059          HlCtxStrV.Add(YSect->GetTxtStr());}
1060      }
1061      if (HlCtxStrV.Len()>500){break;}/&bsol;**
1062    }
1063  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hldoc.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoobs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>393      switch (Sym){
394        case hlsyStr:
395          if (!SwSet->IsIn(Str)){
396            int WordId=GetWordId(Str);
397            if (WordId!=-1){
398              WordDs->AddWordIdFq(WordId, 1);
399              PrevStrQ.Push(Str);
400              int NGram=2;
401              while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
402                int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
403                if (WordId==-1){
404                  while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
405                } else {
406                  WordDs->AddWordIdFq(WordId, 1);
407                }
408                NGram++;
409              }
410            } else {
411              PrevStrQ.Clr();
412            }
413          }
414          break;
415        case hlsyNum:
416        case hlsySSym:
</pre></code></div>
                <div class="column column_space"><pre><code>735              switch (Sym){
736                case hsyStr:
737                  if (!SwSet->IsIn(Str)){
738                    int WordId=GetWordId(Str);
739                    if (WordId!=-1){
740                      WordDs->AddWordIdFq(WordId, 1);
741                      PrevStrQ.Push(Str);
742                      int NGram=2;
743                      while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
744                        int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
745                        if (WordId==-1){
746                          while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
747                        } else {
748                          WordDs->AddWordIdFq(WordId, 1);
749                        }
750                        NGram++;
751                      }
752                    } else {
753                      PrevStrQ.Clr();
754                    }
755                  }
756                  break;
757                case hsyNum: PrevStrQ.Clr(); break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    