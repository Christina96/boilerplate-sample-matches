
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-bootstrap.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/node/bootstrap/bootstrap_connections.hpp>
3  #include <nano/node/common.hpp>
4  #include <boost/multi_index/hashed_index.hpp>
5  #include <boost/multi_index/member.hpp>
6  #include <boost/multi_index/ordered_index.hpp>
7  #include <boost/multi_index_container.hpp>
8  #include <boost/thread/thread.hpp>
9  #include <atomic>
10  #include <queue>
11  namespace mi = boost::multi_index;
12  namespace nano
13  {
14  class node;
15  class bootstrap_connections;
16  namespace transport
17  {
18  	class channel_tcp;
19  }
20  enum class bootstrap_mode
21  {
22  	legacy,
23  	lazy,
24  	wallet_lazy,
25  	ascending
26  };
27  enum class sync_result
28  {
29  	success,
30  	error,
31  	fork
32  };
33  class cached_pulls final
34  {
35  public:
36  	std::chrono::steady_clock::time_point time;
37  	nano::uint512_union account_head;
38  	nano::block_hash new_head;
39  };
40  class pulls_cache final
41  {
42  public:
43  	void add (nano::pull_info const &);
44  	void update_pull (nano::pull_info &);
45  	void remove (nano::pull_info const &);
46  	nano::mutex pulls_cache_mutex;
47  	class account_head_tag
48  	{
49  	};
50  	boost::multi_index_container<nano::cached_pulls,
51  	mi::indexed_by<
52  		mi::ordered_non_unique<
53  			mi::member<nano::cached_pulls, std::chrono::steady_clock::time_point, &nano::cached_pulls::time>>,
54  		mi::hashed_unique<mi::tag<account_head_tag>,
55  			mi::member<nano::cached_pulls, nano::uint512_union, &nano::cached_pulls::account_head>>>>
56  	cache;
57  	constexpr static std::size_t cache_size_max = 10000;
58  };
59  class bootstrap_attempts final
60  {
61  public:
62  	void add (std::shared_ptr<nano::bootstrap_attempt>);
63  	void remove (uint64_t);
64  	void clear ();
65  	std::shared_ptr<nano::bootstrap_attempt> find (uint64_t);
66  	std::size_t size ();
67  	std::atomic<uint64_t> incremental{ 0 };
68  	nano::mutex bootstrap_attempts_mutex;
69  	std::map<uint64_t, std::shared_ptr<nano::bootstrap_attempt>> attempts;
70  };
71  class bootstrap_attempt_lazy;
72  class bootstrap_attempt_wallet;
73  class bootstrap_initiator final
74  {
75  public:
76  	explicit bootstrap_initiator (nano::node &);
77  	~bootstrap_initiator ();
78  	void bootstrap (nano::endpoint const &, bool add_to_peers = true, std::string id_a = "");
79  	void bootstrap (bool force = false, std::string id_a = "", uint32_t const frontiers_age_a = std::numeric_limits<uint32_t>::max (), nano::account const & start_account_a = nano::account{});
80  	bool bootstrap_lazy (nano::hash_or_account const &, bool force = false, std::string id_a = "");
81  	void bootstrap_wallet (std::deque<nano::account> &);
82  	void run_bootstrap ();
83  	void lazy_requeue (nano::block_hash const &, nano::block_hash const &);
84  	void notify_listeners (bool);
85  	void add_observer (std::function<void (bool)> const &);
86  	bool in_progress ();
<span onclick='openModal()' class='match'>87  	void block_processed (nano::transaction const & tx, nano::process_return const & result, nano::block const & block);
88  	std::shared_ptr<nano::bootstrap_connections> connections;
</span>89  	std::shared_ptr<nano::bootstrap_attempt> new_attempt ();
90  	bool has_new_attempts ();
91  	void remove_attempt (std::shared_ptr<nano::bootstrap_attempt>);
92  	std::shared_ptr<nano::bootstrap_attempt> current_attempt ();
93  	std::shared_ptr<nano::bootstrap_attempt_lazy> current_lazy_attempt ();
94  	std::shared_ptr<nano::bootstrap_attempt_wallet> current_wallet_attempt ();
95  	nano::pulls_cache cache;
96  	nano::bootstrap_attempts attempts;
97  	void stop ();
98  private:
99  	nano::node & node;
100  	std::shared_ptr<nano::bootstrap_attempt> find_attempt (nano::bootstrap_mode);
101  	void stop_attempts ();
102  	std::vector<std::shared_ptr<nano::bootstrap_attempt>> attempts_list;
103  	std::atomic<bool> stopped{ false };
104  	nano::mutex mutex;
105  	nano::condition_variable condition;
106  	nano::mutex observers_mutex;
107  	std::vector<std::function<void (bool)>> observers;
108  	std::vector<boost::thread> bootstrap_initiator_threads;
109  	friend std::unique_ptr<container_info_component> collect_container_info (bootstrap_initiator & bootstrap_initiator, std::string const & name);
110  };
111  std::unique_ptr<container_info_component> collect_container_info (bootstrap_initiator & bootstrap_initiator, std::string const & name);
112  class bootstrap_limits final
113  {
114  public:
115  	static constexpr double bootstrap_connection_scale_target_blocks = 10000.0;
116  	static constexpr double bootstrap_connection_warmup_time_sec = 5.0;
117  	static constexpr double bootstrap_minimum_blocks_per_sec = 10.0;
118  	static constexpr double bootstrap_minimum_elapsed_seconds_blockrate = 0.02;
119  	static constexpr double bootstrap_minimum_frontier_blocks_per_sec = 1000.0;
120  	static constexpr double bootstrap_minimum_termination_time_sec = 30.0;
121  	static constexpr unsigned bootstrap_max_new_connections = 32;
122  	static constexpr unsigned requeued_pulls_limit = 256;
123  	static constexpr unsigned requeued_pulls_limit_dev = 1;
124  	static constexpr unsigned requeued_pulls_processed_blocks_factor = 4096;
125  	static constexpr uint64_t pull_count_per_check = 8 * 1024;
126  	static constexpr unsigned bulk_push_cost_limit = 200;
127  	static constexpr std::chrono::seconds lazy_flush_delay_sec = std::chrono::seconds (5);
128  	static constexpr uint64_t lazy_batch_pull_count_resize_blocks_limit = 4 * 1024 * 1024;
129  	static constexpr double lazy_batch_pull_count_resize_ratio = 2.0;
130  	static constexpr std::size_t lazy_blocks_restart_limit = 1024 * 1024;
131  };
132  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/config.hpp>
3  #include <nano/lib/stats.hpp>
4  #include <nano/lib/work.hpp>
5  #include <nano/node/active_transactions.hpp>
6  #include <nano/node/backlog_population.hpp>
7  #include <nano/node/bandwidth_limiter.hpp>
8  #include <nano/node/block_arrival.hpp>
9  #include <nano/node/block_broadcast.hpp>
10  #include <nano/node/block_publisher.hpp>
11  #include <nano/node/blockprocessor.hpp>
12  #include <nano/node/bootstrap/bootstrap.hpp>
13  #include <nano/node/bootstrap/bootstrap_attempt.hpp>
14  #include <nano/node/bootstrap/bootstrap_server.hpp>
15  #include <nano/node/bootstrap_ascending/service.hpp>
16  #include <nano/node/confirmation_height_processor.hpp>
17  #include <nano/node/distributed_work_factory.hpp>
18  #include <nano/node/election.hpp>
19  #include <nano/node/epoch_upgrader.hpp>
20  #include <nano/node/gap_cache.hpp>
21  #include <nano/node/gap_tracker.hpp>
22  #include <nano/node/network.hpp>
23  #include <nano/node/node_observers.hpp>
24  #include <nano/node/nodeconfig.hpp>
25  #include <nano/node/online_reps.hpp>
26  #include <nano/node/portmapping.hpp>
27  #include <nano/node/process_live_dispatcher.hpp>
28  #include <nano/node/repcrawler.hpp>
29  #include <nano/node/request_aggregator.hpp>
30  #include <nano/node/signatures.hpp>
31  #include <nano/node/telemetry.hpp>
32  #include <nano/node/transport/tcp_server.hpp>
33  #include <nano/node/unchecked_map.hpp>
34  #include <nano/node/vote_cache.hpp>
35  #include <nano/node/vote_processor.hpp>
36  #include <nano/node/wallet.hpp>
37  #include <nano/node/websocket.hpp>
38  #include <nano/node/write_database_queue.hpp>
39  #include <nano/secure/ledger.hpp>
40  #include <nano/secure/utility.hpp>
41  #include <boost/program_options.hpp>
42  #include <boost/thread/latch.hpp>
43  #include <atomic>
44  #include <memory>
45  #include <vector>
46  namespace nano
47  {
48  namespace rocksdb
49  {
50  } 
51  class node;
52  class work_pool;
53  namespace scheduler
54  {
55  	class component;
56  }
57  std::unique_ptr<container_info_component> collect_container_info (rep_crawler & rep_crawler, std::string const & name);
58  backlog_population::config backlog_population_config (node_config const &);
59  vote_cache::config nodeconfig_to_vote_cache_config (node_config const &, node_flags const &);
60  outbound_bandwidth_limiter::config outbound_bandwidth_limiter_config (node_config const &);
61  class node final : public std::enable_shared_from_this<nano::node>
62  {
63  public:
64  	node (boost::asio::io_context &, uint16_t, boost::filesystem::path const &, nano::logging const &, nano::work_pool &, nano::node_flags = nano::node_flags (), unsigned seq = 0);
65  	node (boost::asio::io_context &, boost::filesystem::path const &, nano::node_config const &, nano::work_pool &, nano::node_flags = nano::node_flags (), unsigned seq = 0);
66  	~node ();
67  public:
68  	template <typename T>
69  	void background (T action_a)
70  	{
71  		io_ctx.post (action_a);
72  	}
73  	bool copy_with_compaction (boost::filesystem::path const &);
74  	void keepalive (std::string const &, uint16_t);
75  	void start ();
76  	void stop ();
77  	std::shared_ptr<nano::node> shared ();
78  	int store_version ();
<span onclick='openModal()' class='match'>79  	void receive_confirmed (nano::transaction const & block_transaction_a, nano::block_hash const & hash_a, nano::account const & destination_a);
80  	void process_confirmed_data (nano::transaction const &, std::shared_ptr<nano::block> const &, nano::block_hash const &, nano::account &, nano::uint128_t &, bool &, bool &, nano::account &);
</span>81  	void process_confirmed (nano::election_status const &, uint64_t = 0);
82  	void process_active (std::shared_ptr<nano::block> const &);
83  	std::optional<nano::process_return> process_local (std::shared_ptr<nano::block> const &);
84  	void process_local_async (std::shared_ptr<nano::block> const &);
85  	void keepalive_preconfigured (std::vector<std::string> const &);
86  	std::shared_ptr<nano::block> block (nano::block_hash const &);
87  	std::pair<nano::uint128_t, nano::uint128_t> balance_pending (nano::account const &, bool only_confirmed);
88  	nano::uint128_t weight (nano::account const &);
89  	nano::block_hash rep_block (nano::account const &);
90  	nano::uint128_t minimum_principal_weight ();
91  	void ongoing_rep_calculation ();
92  	void ongoing_bootstrap ();
93  	void ongoing_peer_store ();
94  	void ongoing_unchecked_cleanup ();
95  	void backup_wallet ();
96  	void search_receivable_all ();
97  	void bootstrap_wallet ();
98  	void unchecked_cleanup ();
99  	bool collect_ledger_pruning_targets (std::deque<nano::block_hash> &, nano::account &, uint64_t const, uint64_t const, uint64_t const);
100  	void ledger_pruning (uint64_t const, bool, bool);
101  	void ongoing_ledger_pruning ();
102  	int price (nano::uint128_t const &, int);
103  	uint64_t default_difficulty (nano::work_version const) const;
104  	uint64_t default_receive_difficulty (nano::work_version const) const;
105  	uint64_t max_work_generate_difficulty (nano::work_version const) const;
106  	bool local_work_generation_enabled () const;
107  	bool work_generation_enabled () const;
108  	bool work_generation_enabled (std::vector<std::pair<std::string, uint16_t>> const &) const;
109  	boost::optional<uint64_t> work_generate_blocking (nano::block &, uint64_t);
110  	boost::optional<uint64_t> work_generate_blocking (nano::work_version const, nano::root const &, uint64_t, boost::optional<nano::account> const & = boost::none);
111  	void work_generate (nano::work_version const, nano::root const &, uint64_t, std::function<void (boost::optional<uint64_t>)>, boost::optional<nano::account> const & = boost::none, bool const = false);
112  	void add_initial_peers ();
113  	std::shared_ptr<nano::election> block_confirm (std::shared_ptr<nano::block> const &);
114  	bool block_confirmed (nano::block_hash const &);
115  	bool block_confirmed_or_being_confirmed (nano::block_hash const &);
116  	void do_rpc_callback (boost::asio::ip::tcp::resolver::iterator i_a, std::string const &, uint16_t, std::shared_ptr<std::string> const &, std::shared_ptr<std::string> const &, std::shared_ptr<boost::asio::ip::tcp::resolver> const &);
117  	void ongoing_online_weight_calculation ();
118  	void ongoing_online_weight_calculation_queue ();
119  	bool online () const;
120  	bool init_error () const;
121  	std::pair<uint64_t, decltype (nano::ledger::bootstrap_weights)> get_bootstrap_weights () const;
122  	uint64_t get_confirmation_height (nano::transaction const &, nano::account &);
123  	void bootstrap_block (nano::block_hash const &);
124  	nano::account get_node_id () const;
125  	nano::telemetry_data local_telemetry () const;
126  public:
127  	nano::write_database_queue write_database_queue;
128  	boost::asio::io_context & io_ctx;
129  	boost::latch node_initialized_latch;
130  	nano::node_config config;
131  	nano::network_params & network_params;
132  	nano::stats stats;
133  	nano::thread_pool workers;
134  	nano::thread_pool bootstrap_workers;
135  	nano::node_flags flags;
136  	nano::work_pool & work;
137  	nano::distributed_work_factory distributed_work;
138  	nano::logger_mt logger;
139  	std::unique_ptr<nano::store> store_impl;
140  	nano::store & store;
141  	nano::unchecked_map unchecked;
142  	std::unique_ptr<nano::wallets_store> wallets_store_impl;
143  	nano::wallets_store & wallets_store;
144  	nano::gap_cache gap_cache;
145  	nano::ledger ledger;
146  	nano::signature_checker checker;
147  	nano::outbound_bandwidth_limiter outbound_limiter;
148  	nano::network network;
149  	nano::telemetry telemetry;
150  	nano::bootstrap_initiator bootstrap_initiator;
151  	nano::bootstrap_server bootstrap_server;
152  	nano::transport::tcp_listener tcp_listener;
153  	boost::filesystem::path application_path;
154  	nano::node_observers observers;
155  	nano::port_mapping port_mapping;
156  	nano::online_reps online_reps;
157  	nano::rep_crawler rep_crawler;
158  	nano::vote_processor vote_processor;
159  	unsigned warmed_up;
160  	nano::block_processor block_processor;
161  	nano::block_arrival block_arrival;
162  	nano::local_vote_history history;
163  	nano::keypair node_id;
164  	nano::block_uniquer block_uniquer;
165  	nano::vote_uniquer vote_uniquer;
166  	nano::confirmation_height_processor confirmation_height_processor;
167  	nano::vote_cache inactive_vote_cache;
168  	nano::vote_generator generator;
169  	nano::vote_generator final_generator;
170  	nano::active_transactions active;
171  private: 
172  	std::unique_ptr<nano::scheduler::component> scheduler_impl;
173  public:
174  	nano::scheduler::component & scheduler;
175  	nano::request_aggregator aggregator;
176  	nano::wallets wallets;
177  	nano::backlog_population backlog;
178  	nano::bootstrap_ascending::service ascendboot;
179  	nano::websocket_server websocket;
180  	nano::epoch_upgrader epoch_upgrader;
181  	nano::block_broadcast block_broadcast;
182  	nano::block_publisher block_publisher;
183  	nano::gap_tracker gap_tracker;
184  	nano::process_live_dispatcher process_live_dispatcher;
185  	std::chrono::steady_clock::time_point const startup_time;
186  	std::chrono::seconds unchecked_cutoff = std::chrono::seconds (7 * 24 * 60 * 60); 
187  	std::atomic<bool> unresponsive_work_peers{ false };
188  	std::atomic<bool> stopped{ false };
189  	static double constexpr price_max = 16.0;
190  	static double constexpr free_cutoff = 1024.0;
191  	unsigned node_seq;
192  	boost::optional<uint64_t> work_generate_blocking (nano::block &);
193  	boost::optional<uint64_t> work_generate_blocking (nano::root const &, uint64_t);
194  	boost::optional<uint64_t> work_generate_blocking (nano::root const &);
195  public: 
196  	[[nodiscard]] nano::process_return process (nano::block & block);
197  	[[nodiscard]] nano::process_return process (nano::write_transaction const &, nano::block & block);
198  	nano::block_hash latest (nano::account const &);
199  	nano::uint128_t balance (nano::account const &);
200  private:
201  	void long_inactivity_cleanup ();
202  };
203  nano::keypair load_or_create_node_id (boost::filesystem::path const & application_path, nano::logger_mt & logger);
204  std::unique_ptr<container_info_component> collect_container_info (node & node, std::string const & name);
205  nano::node_flags const & inactive_node_flag_defaults ();
206  class node_wrapper final
207  {
208  public:
209  	node_wrapper (boost::filesystem::path const & path_a, boost::filesystem::path const & config_path_a, nano::node_flags const & node_flags_a);
210  	~node_wrapper ();
211  	nano::network_params network_params;
212  	std::shared_ptr<boost::asio::io_context> io_context;
213  	nano::work_pool work;
214  	std::shared_ptr<nano::node> node;
215  };
216  class inactive_node final
217  {
218  public:
219  	inactive_node (boost::filesystem::path const & path_a, nano::node_flags const & node_flags_a);
220  	inactive_node (boost::filesystem::path const & path_a, boost::filesystem::path const & config_path_a, nano::node_flags const & node_flags_a);
221  	nano::node_wrapper node_wrapper;
222  	std::shared_ptr<nano::node> node;
223  };
224  std::unique_ptr<nano::inactive_node> default_inactive_node (boost::filesystem::path const &, boost::program_options::variables_map const &);
225  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-bootstrap.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node.hpp</div>
                </div>
                <div class="column column_space"><pre><code>87  	void block_processed (nano::transaction const & tx, nano::process_return const & result, nano::block const & block);
88  	std::shared_ptr<nano::bootstrap_connections> connections;
</pre></code></div>
                <div class="column column_space"><pre><code>79  	void receive_confirmed (nano::transaction const & block_transaction_a, nano::block_hash const & hash_a, nano::account const & destination_a);
80  	void process_confirmed_data (nano::transaction const &, std::shared_ptr<nano::block> const &, nano::block_hash const &, nano::account &, nano::uint128_t &, bool &, bool &, nano::account &);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    