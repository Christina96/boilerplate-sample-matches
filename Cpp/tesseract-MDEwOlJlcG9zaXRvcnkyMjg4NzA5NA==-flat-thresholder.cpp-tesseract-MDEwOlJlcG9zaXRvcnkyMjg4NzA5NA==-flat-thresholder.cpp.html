
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-thresholder.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "otsuthr.h"
5  #include "thresholder.h"
6  #include "tprintf.h" 
7  #if defined(USE_OPENCL)
8  #  include "openclwrapper.h" 
9  #endif
10  #include <allheaders.h>
11  #include <tesseract/baseapi.h> 
12  #include <algorithm> 
13  #include <cstdint>   
14  #include <cstring>
15  #include <tuple>
16  namespace tesseract {
17  ImageThresholder::ImageThresholder()
18      : pix_(nullptr)
19      , image_width_(0)
20      , image_height_(0)
21      , pix_channels_(0)
22      , pix_wpl_(0)
23      , scale_(1)
24      , yres_(300)
25      , estimated_res_(300) {
26    SetRectangle(0, 0, 0, 0);
27  }
28  ImageThresholder::~ImageThresholder() {
29    Clear();
30  }
31  void ImageThresholder::Clear() {
32    pix_.destroy();
33  }
34  bool ImageThresholder::IsEmpty() const {
35    return pix_ == nullptr;
36  }
37  void ImageThresholder::SetImage(const unsigned char *imagedata, int width, int height,
38                                  int bytes_per_pixel, int bytes_per_line) {
39    int bpp = bytes_per_pixel * 8;
40    if (bpp == 0) {
41      bpp = 1;
42    }
43    Image pix = pixCreate(width, height, bpp == 24 ? 32 : bpp);
44    l_uint32 *data = pixGetData(pix);
45    int wpl = pixGetWpl(pix);
46    switch (bpp) {
47      case 1:
48        for (int y = 0; y < height; ++y, data += wpl, imagedata += bytes_per_line) {
49          for (int x = 0; x < width; ++x) {
50            if (imagedata[x / 8] & (0x80 >> (x % 8))) {
51              CLEAR_DATA_BIT(data, x);
52            } else {
53              SET_DATA_BIT(data, x);
54            }
55          }
56        }
57        break;
58      case 8:
59        for (int y = 0; y < height; ++y, data += wpl, imagedata += bytes_per_line) {
60          for (int x = 0; x < width; ++x) {
61            SET_DATA_BYTE(data, x, imagedata[x]);
62          }
63        }
64        break;
65      case 24:
66        for (int y = 0; y < height; ++y, imagedata += bytes_per_line) {
67          for (int x = 0; x < width; ++x, ++data) {
68            SET_DATA_BYTE(data, COLOR_RED, imagedata[3 * x]);
69            SET_DATA_BYTE(data, COLOR_GREEN, imagedata[3 * x + 1]);
70            SET_DATA_BYTE(data, COLOR_BLUE, imagedata[3 * x + 2]);
71          }
72        }
73        break;
74      case 32:
75        for (int y = 0; y < height; ++y, imagedata += bytes_per_line, data += wpl) {
76          for (int x = 0; x < width; ++x) {
77            data[x] = (imagedata[x * 4] << 24) | (imagedata[x * 4 + 1] << 16) |
78                      (imagedata[x * 4 + 2] << 8) | imagedata[x * 4 + 3];
79          }
80        }
81        break;
82      default:
83        tprintf("Cannot convert RAW image to Pix with bpp = %d\n", bpp);
84    }
85    SetImage(pix);
86    pix.destroy();
87  }
88  void ImageThresholder::SetRectangle(int left, int top, int width, int height) {
89    rect_left_ = left;
90    rect_top_ = top;
91    rect_width_ = width;
92    rect_height_ = height;
93  }
94  void ImageThresholder::GetImageSizes(int *left, int *top, int *width, int *height, int *imagewidth,
95                                       int *imageheight) {
96    *left = rect_left_;
97    *top = rect_top_;
98    *width = rect_width_;
99    *height = rect_height_;
100    *imagewidth = image_width_;
101    *imageheight = image_height_;
102  }
103  void ImageThresholder::SetImage(const Image pix) {
104    if (pix_ != nullptr) {
105      pix_.destroy();
106    }
107    Image src = pix;
108    int depth;
109    pixGetDimensions(src, &image_width_, &image_height_, &depth);
110    if (depth > 1 && depth < 8) {
<span onclick='openModal()' class='match'>111      pix_ = pixConvertTo8(src, false);
112    } else {
113      pix_ = src.copy();
114    }
115    depth = pixGetDepth(pix_);
</span>116    pix_channels_ = depth / 8;
117    pix_wpl_ = pixGetWpl(pix_);
118    scale_ = 1;
119    estimated_res_ = yres_ = pixGetYRes(pix_);
120    Init();
121  }
122  std::tuple<bool, Image, Image, Image> ImageThresholder::Threshold(
123                                                        TessBaseAPI *api,
124                                                        ThresholdMethod method) {
125    Image pix_binary = nullptr;
126    Image pix_thresholds = nullptr;
127    if (pix_channels_ == 0) {
128      Image original = GetPixRect();
129      pix_binary = original.copy();
130      original.destroy();
131      return std::make_tuple(true, nullptr, pix_binary, nullptr);
132    }
133    auto pix_grey = GetPixRectGrey();
134    int r;
135    l_int32 pix_w, pix_h;
136    pixGetDimensions(pix_grey, &pix_w, &pix_h, nullptr);
137    bool thresholding_debug;
138    api->GetBoolVariable("thresholding_debug", &thresholding_debug);
139    if (thresholding_debug) {
140      tprintf("\nimage width: %d  height: %d  ppi: %d\n", pix_w, pix_h, yres_);
141    }
142    if (method == ThresholdMethod::Sauvola) {
143      int window_size;
144      double window_size_factor;
145      api->GetDoubleVariable("thresholding_window_size", &window_size_factor);
146      window_size = window_size_factor * yres_;
147      window_size = std::max(7, window_size);
148      window_size = std::min(pix_w < pix_h ? pix_w - 3 : pix_h - 3, window_size);
149      int half_window_size = window_size / 2;
150      l_int32 nx, ny;
151      nx = std::max(1, (pix_w + 125) / 250);
152      ny = std::max(1, (pix_h + 125) / 250);
153      auto xrat = pix_w / nx;
154      auto yrat = pix_h / ny;
155      if (xrat < half_window_size + 2) {
156        nx = pix_w / (half_window_size + 2);
157      }
158      if (yrat < half_window_size + 2) {
159        ny = pix_h / (half_window_size + 2);
160      }
161      double kfactor;
162      api->GetDoubleVariable("thresholding_kfactor", &kfactor);
163      kfactor = std::max(0.0, kfactor);
164      if (thresholding_debug) {
165        tprintf("window size: %d  kfactor: %.3f  nx:%d  ny: %d\n", window_size, kfactor, nx, ny);
166      }
167      r = pixSauvolaBinarizeTiled(pix_grey, half_window_size, kfactor, nx, ny,
168                                 (PIX**)pix_thresholds,
169                                  (PIX**)pix_binary);
170    } else { 
171      int tile_size;
172      double tile_size_factor;
173      api->GetDoubleVariable("thresholding_tile_size", &tile_size_factor);
174      tile_size = tile_size_factor * yres_;
175      tile_size = std::max(16, tile_size);
176      int smooth_size;
177      double smooth_size_factor;
178      api->GetDoubleVariable("thresholding_smooth_kernel_size",
179                           &smooth_size_factor);
180      smooth_size_factor = std::max(0.0, smooth_size_factor);
181      smooth_size = smooth_size_factor * yres_;
182      int half_smooth_size = smooth_size / 2;
183      double score_fraction;
184      api->GetDoubleVariable("thresholding_score_fraction", &score_fraction);
185      if (thresholding_debug) {
186        tprintf("tile size: %d  smooth_size: %d  score_fraction: %.2f\n", tile_size, smooth_size, score_fraction);
187      }
188      r = pixOtsuAdaptiveThreshold(pix_grey, tile_size, tile_size,
189                                   half_smooth_size, half_smooth_size,
190                                   score_fraction,
191                                   (PIX**)pix_thresholds,
192                                   (PIX**)pix_binary);
193    }
194    bool ok = (r == 0);
195    return std::make_tuple(ok, pix_grey, pix_binary, pix_thresholds);
196  }
197  bool ImageThresholder::ThresholdToPix(Image *pix) {
198    if (image_width_ > INT16_MAX || image_height_ > INT16_MAX) {
199      tprintf("Image too large: (%d, %d)\n", image_width_, image_height_);
200      return false;
201    }
202    Image original = GetPixRect();
203    if (pix_channels_ == 0) {
204      *pix = original.copy();
205    } else {
206      if (pixGetColormap(original)) {
207        Image tmp;
208        Image without_cmap =
209            pixRemoveColormap(original, REMOVE_CMAP_BASED_ON_SRC);
210        int depth = pixGetDepth(without_cmap);
211        if (depth > 1 && depth < 8) {
212          tmp = pixConvertTo8(without_cmap, false);
213        } else {
214          tmp = without_cmap.copy();
215        }
216        without_cmap.destroy();
217        OtsuThresholdRectToPix(tmp, pix);
218        tmp.destroy();
219      } else {
220        OtsuThresholdRectToPix(pix_, pix);
221      }
222    }
223    original.destroy();
224    return true;
225  }
226  Image ImageThresholder::GetPixRectThresholds() {
227    if (IsBinary()) {
228      return nullptr;
229    }
230    Image pix_grey = GetPixRectGrey();
231    int width = pixGetWidth(pix_grey);
232    int height = pixGetHeight(pix_grey);
233    std::vector<int> thresholds;
234    std::vector<int> hi_values;
235    OtsuThreshold(pix_grey, 0, 0, width, height, thresholds, hi_values);
236    pix_grey.destroy();
237    Image pix_thresholds = pixCreate(width, height, 8);
238    int threshold = thresholds[0] > 0 ? thresholds[0] : 128;
239    pixSetAllArbitrary(pix_thresholds, threshold);
240    return pix_thresholds;
241  }
242  void ImageThresholder::Init() {
243    SetRectangle(0, 0, image_width_, image_height_);
244  }
245  Image ImageThresholder::GetPixRect() {
246    if (IsFullImage()) {
247      return pix_.clone();
248    } else {
249      Box *box = boxCreate(rect_left_, rect_top_, rect_width_, rect_height_);
250      Image cropped = pixClipRectangle(pix_, box, nullptr);
251      boxDestroy(&box);
252      return cropped;
253    }
254  }
255  Image ImageThresholder::GetPixRectGrey() {
256    auto pix = GetPixRect(); 
257    int depth = pixGetDepth(pix);
258    if (depth != 8 || pixGetColormap(pix)) {
259      if (depth == 24) {
260        auto tmp = pixConvert24To32(pix);
261        pix.destroy();
262        pix = tmp;
263      }
264      auto result = pixConvertTo8(pix, false);
265      pix.destroy();
266      return result;
267    }
268    return pix;
269  }
270  void ImageThresholder::OtsuThresholdRectToPix(Image src_pix, Image *out_pix) const {
271    std::vector<int> thresholds;
272    std::vector<int> hi_values;
273    int num_channels = OtsuThreshold(src_pix, rect_left_, rect_top_, rect_width_, rect_height_,
274                                     thresholds, hi_values);
275  #ifdef USE_OPENCL
276    OpenclDevice od;
277    if (num_channels == 4 && od.selectedDeviceIsOpenCL() && rect_top_ == 0 && rect_left_ == 0) {
278      od.ThresholdRectToPixOCL((unsigned char *)pixGetData(src_pix), num_channels,
279                               pixGetWpl(src_pix) * 4, &thresholds[0], &hi_values[0], out_pix &bsol;*pix_OCL*/,
280                               rect_height_, rect_width_, rect_top_, rect_left_);
281    } else {
282  #endif
283      ThresholdRectToPix(src_pix, num_channels, thresholds, hi_values, out_pix);
284  #ifdef USE_OPENCL
285    }
286  #endif
287  }
288  void ImageThresholder::ThresholdRectToPix(Image src_pix, int num_channels, const std::vector<int> &thresholds,
289                                            const std::vector<int> &hi_values, Image *pix) const {
290    *pix = pixCreate(rect_width_, rect_height_, 1);
291    uint32_t *pixdata = pixGetData(*pix);
292    int wpl = pixGetWpl(*pix);
293    int src_wpl = pixGetWpl(src_pix);
294    uint32_t *srcdata = pixGetData(src_pix);
295    pixSetXRes(*pix, pixGetXRes(src_pix));
296    pixSetYRes(*pix, pixGetYRes(src_pix));
297    for (int y = 0; y < rect_height_; ++y) {
298      const uint32_t *linedata = srcdata + (y + rect_top_) * src_wpl;
299      uint32_t *pixline = pixdata + y * wpl;
300      for (int x = 0; x < rect_width_; ++x) {
301        bool white_result = true;
302        for (int ch = 0; ch < num_channels; ++ch) {
303          int pixel = GET_DATA_BYTE(linedata, (x + rect_left_) * num_channels + ch);
304          if (hi_values[ch] >= 0 && (pixel > thresholds[ch]) == (hi_values[ch] == 0)) {
305            white_result = false;
306            break;
307          }
308        }
309        if (white_result) {
310          CLEAR_DATA_BIT(pixline, x);
311        } else {
312          SET_DATA_BIT(pixline, x);
313        }
314      }
315    }
316  }
317  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-thresholder.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "otsuthr.h"
5  #include "thresholder.h"
6  #include "tprintf.h" 
7  #if defined(USE_OPENCL)
8  #  include "openclwrapper.h" 
9  #endif
10  #include <allheaders.h>
11  #include <tesseract/baseapi.h> 
12  #include <algorithm> 
13  #include <cstdint>   
14  #include <cstring>
15  #include <tuple>
16  namespace tesseract {
17  ImageThresholder::ImageThresholder()
18      : pix_(nullptr)
19      , image_width_(0)
20      , image_height_(0)
21      , pix_channels_(0)
22      , pix_wpl_(0)
23      , scale_(1)
24      , yres_(300)
25      , estimated_res_(300) {
26    SetRectangle(0, 0, 0, 0);
27  }
28  ImageThresholder::~ImageThresholder() {
29    Clear();
30  }
31  void ImageThresholder::Clear() {
32    pix_.destroy();
33  }
34  bool ImageThresholder::IsEmpty() const {
35    return pix_ == nullptr;
36  }
37  void ImageThresholder::SetImage(const unsigned char *imagedata, int width, int height,
38                                  int bytes_per_pixel, int bytes_per_line) {
39    int bpp = bytes_per_pixel * 8;
40    if (bpp == 0) {
41      bpp = 1;
42    }
43    Image pix = pixCreate(width, height, bpp == 24 ? 32 : bpp);
44    l_uint32 *data = pixGetData(pix);
45    int wpl = pixGetWpl(pix);
46    switch (bpp) {
47      case 1:
48        for (int y = 0; y < height; ++y, data += wpl, imagedata += bytes_per_line) {
49          for (int x = 0; x < width; ++x) {
50            if (imagedata[x / 8] & (0x80 >> (x % 8))) {
51              CLEAR_DATA_BIT(data, x);
52            } else {
53              SET_DATA_BIT(data, x);
54            }
55          }
56        }
57        break;
58      case 8:
59        for (int y = 0; y < height; ++y, data += wpl, imagedata += bytes_per_line) {
60          for (int x = 0; x < width; ++x) {
61            SET_DATA_BYTE(data, x, imagedata[x]);
62          }
63        }
64        break;
65      case 24:
66        for (int y = 0; y < height; ++y, imagedata += bytes_per_line) {
67          for (int x = 0; x < width; ++x, ++data) {
68            SET_DATA_BYTE(data, COLOR_RED, imagedata[3 * x]);
69            SET_DATA_BYTE(data, COLOR_GREEN, imagedata[3 * x + 1]);
70            SET_DATA_BYTE(data, COLOR_BLUE, imagedata[3 * x + 2]);
71          }
72        }
73        break;
74      case 32:
75        for (int y = 0; y < height; ++y, imagedata += bytes_per_line, data += wpl) {
76          for (int x = 0; x < width; ++x) {
77            data[x] = (imagedata[x * 4] << 24) | (imagedata[x * 4 + 1] << 16) |
78                      (imagedata[x * 4 + 2] << 8) | imagedata[x * 4 + 3];
79          }
80        }
81        break;
82      default:
83        tprintf("Cannot convert RAW image to Pix with bpp = %d\n", bpp);
84    }
85    SetImage(pix);
86    pix.destroy();
87  }
88  void ImageThresholder::SetRectangle(int left, int top, int width, int height) {
89    rect_left_ = left;
90    rect_top_ = top;
91    rect_width_ = width;
92    rect_height_ = height;
93  }
94  void ImageThresholder::GetImageSizes(int *left, int *top, int *width, int *height, int *imagewidth,
95                                       int *imageheight) {
96    *left = rect_left_;
97    *top = rect_top_;
98    *width = rect_width_;
99    *height = rect_height_;
100    *imagewidth = image_width_;
101    *imageheight = image_height_;
102  }
103  void ImageThresholder::SetImage(const Image pix) {
104    if (pix_ != nullptr) {
105      pix_.destroy();
106    }
107    Image src = pix;
108    int depth;
109    pixGetDimensions(src, &image_width_, &image_height_, &depth);
110    if (depth > 1 && depth < 8) {
111      pix_ = pixConvertTo8(src, false);
112    } else {
113      pix_ = src.copy();
114    }
115    depth = pixGetDepth(pix_);
116    pix_channels_ = depth / 8;
117    pix_wpl_ = pixGetWpl(pix_);
118    scale_ = 1;
119    estimated_res_ = yres_ = pixGetYRes(pix_);
120    Init();
121  }
122  std::tuple<bool, Image, Image, Image> ImageThresholder::Threshold(
123                                                        TessBaseAPI *api,
124                                                        ThresholdMethod method) {
125    Image pix_binary = nullptr;
126    Image pix_thresholds = nullptr;
127    if (pix_channels_ == 0) {
128      Image original = GetPixRect();
129      pix_binary = original.copy();
130      original.destroy();
131      return std::make_tuple(true, nullptr, pix_binary, nullptr);
132    }
133    auto pix_grey = GetPixRectGrey();
134    int r;
135    l_int32 pix_w, pix_h;
136    pixGetDimensions(pix_grey, &pix_w, &pix_h, nullptr);
137    bool thresholding_debug;
138    api->GetBoolVariable("thresholding_debug", &thresholding_debug);
139    if (thresholding_debug) {
140      tprintf("\nimage width: %d  height: %d  ppi: %d\n", pix_w, pix_h, yres_);
141    }
142    if (method == ThresholdMethod::Sauvola) {
143      int window_size;
144      double window_size_factor;
145      api->GetDoubleVariable("thresholding_window_size", &window_size_factor);
146      window_size = window_size_factor * yres_;
147      window_size = std::max(7, window_size);
148      window_size = std::min(pix_w < pix_h ? pix_w - 3 : pix_h - 3, window_size);
149      int half_window_size = window_size / 2;
150      l_int32 nx, ny;
151      nx = std::max(1, (pix_w + 125) / 250);
152      ny = std::max(1, (pix_h + 125) / 250);
153      auto xrat = pix_w / nx;
154      auto yrat = pix_h / ny;
155      if (xrat < half_window_size + 2) {
156        nx = pix_w / (half_window_size + 2);
157      }
158      if (yrat < half_window_size + 2) {
159        ny = pix_h / (half_window_size + 2);
160      }
161      double kfactor;
162      api->GetDoubleVariable("thresholding_kfactor", &kfactor);
163      kfactor = std::max(0.0, kfactor);
164      if (thresholding_debug) {
165        tprintf("window size: %d  kfactor: %.3f  nx:%d  ny: %d\n", window_size, kfactor, nx, ny);
166      }
167      r = pixSauvolaBinarizeTiled(pix_grey, half_window_size, kfactor, nx, ny,
168                                 (PIX**)pix_thresholds,
169                                  (PIX**)pix_binary);
170    } else { 
171      int tile_size;
172      double tile_size_factor;
173      api->GetDoubleVariable("thresholding_tile_size", &tile_size_factor);
174      tile_size = tile_size_factor * yres_;
175      tile_size = std::max(16, tile_size);
176      int smooth_size;
177      double smooth_size_factor;
178      api->GetDoubleVariable("thresholding_smooth_kernel_size",
179                           &smooth_size_factor);
180      smooth_size_factor = std::max(0.0, smooth_size_factor);
181      smooth_size = smooth_size_factor * yres_;
182      int half_smooth_size = smooth_size / 2;
183      double score_fraction;
184      api->GetDoubleVariable("thresholding_score_fraction", &score_fraction);
185      if (thresholding_debug) {
186        tprintf("tile size: %d  smooth_size: %d  score_fraction: %.2f\n", tile_size, smooth_size, score_fraction);
187      }
188      r = pixOtsuAdaptiveThreshold(pix_grey, tile_size, tile_size,
189                                   half_smooth_size, half_smooth_size,
190                                   score_fraction,
191                                   (PIX**)pix_thresholds,
192                                   (PIX**)pix_binary);
193    }
194    bool ok = (r == 0);
195    return std::make_tuple(ok, pix_grey, pix_binary, pix_thresholds);
196  }
197  bool ImageThresholder::ThresholdToPix(Image *pix) {
198    if (image_width_ > INT16_MAX || image_height_ > INT16_MAX) {
199      tprintf("Image too large: (%d, %d)\n", image_width_, image_height_);
200      return false;
201    }
202    Image original = GetPixRect();
203    if (pix_channels_ == 0) {
204      *pix = original.copy();
205    } else {
206      if (pixGetColormap(original)) {
207        Image tmp;
208        Image without_cmap =
209            pixRemoveColormap(original, REMOVE_CMAP_BASED_ON_SRC);
210        int depth = pixGetDepth(without_cmap);
211        if (depth > 1 && depth < 8) {
<span onclick='openModal()' class='match'>212          tmp = pixConvertTo8(without_cmap, false);
213        } else {
214          tmp = without_cmap.copy();
215        }
216        without_cmap.destroy();
</span>217        OtsuThresholdRectToPix(tmp, pix);
218        tmp.destroy();
219      } else {
220        OtsuThresholdRectToPix(pix_, pix);
221      }
222    }
223    original.destroy();
224    return true;
225  }
226  Image ImageThresholder::GetPixRectThresholds() {
227    if (IsBinary()) {
228      return nullptr;
229    }
230    Image pix_grey = GetPixRectGrey();
231    int width = pixGetWidth(pix_grey);
232    int height = pixGetHeight(pix_grey);
233    std::vector<int> thresholds;
234    std::vector<int> hi_values;
235    OtsuThreshold(pix_grey, 0, 0, width, height, thresholds, hi_values);
236    pix_grey.destroy();
237    Image pix_thresholds = pixCreate(width, height, 8);
238    int threshold = thresholds[0] > 0 ? thresholds[0] : 128;
239    pixSetAllArbitrary(pix_thresholds, threshold);
240    return pix_thresholds;
241  }
242  void ImageThresholder::Init() {
243    SetRectangle(0, 0, image_width_, image_height_);
244  }
245  Image ImageThresholder::GetPixRect() {
246    if (IsFullImage()) {
247      return pix_.clone();
248    } else {
249      Box *box = boxCreate(rect_left_, rect_top_, rect_width_, rect_height_);
250      Image cropped = pixClipRectangle(pix_, box, nullptr);
251      boxDestroy(&box);
252      return cropped;
253    }
254  }
255  Image ImageThresholder::GetPixRectGrey() {
256    auto pix = GetPixRect(); 
257    int depth = pixGetDepth(pix);
258    if (depth != 8 || pixGetColormap(pix)) {
259      if (depth == 24) {
260        auto tmp = pixConvert24To32(pix);
261        pix.destroy();
262        pix = tmp;
263      }
264      auto result = pixConvertTo8(pix, false);
265      pix.destroy();
266      return result;
267    }
268    return pix;
269  }
270  void ImageThresholder::OtsuThresholdRectToPix(Image src_pix, Image *out_pix) const {
271    std::vector<int> thresholds;
272    std::vector<int> hi_values;
273    int num_channels = OtsuThreshold(src_pix, rect_left_, rect_top_, rect_width_, rect_height_,
274                                     thresholds, hi_values);
275  #ifdef USE_OPENCL
276    OpenclDevice od;
277    if (num_channels == 4 && od.selectedDeviceIsOpenCL() && rect_top_ == 0 && rect_left_ == 0) {
278      od.ThresholdRectToPixOCL((unsigned char *)pixGetData(src_pix), num_channels,
279                               pixGetWpl(src_pix) * 4, &thresholds[0], &hi_values[0], out_pix &bsol;*pix_OCL*/,
280                               rect_height_, rect_width_, rect_top_, rect_left_);
281    } else {
282  #endif
283      ThresholdRectToPix(src_pix, num_channels, thresholds, hi_values, out_pix);
284  #ifdef USE_OPENCL
285    }
286  #endif
287  }
288  void ImageThresholder::ThresholdRectToPix(Image src_pix, int num_channels, const std::vector<int> &thresholds,
289                                            const std::vector<int> &hi_values, Image *pix) const {
290    *pix = pixCreate(rect_width_, rect_height_, 1);
291    uint32_t *pixdata = pixGetData(*pix);
292    int wpl = pixGetWpl(*pix);
293    int src_wpl = pixGetWpl(src_pix);
294    uint32_t *srcdata = pixGetData(src_pix);
295    pixSetXRes(*pix, pixGetXRes(src_pix));
296    pixSetYRes(*pix, pixGetYRes(src_pix));
297    for (int y = 0; y < rect_height_; ++y) {
298      const uint32_t *linedata = srcdata + (y + rect_top_) * src_wpl;
299      uint32_t *pixline = pixdata + y * wpl;
300      for (int x = 0; x < rect_width_; ++x) {
301        bool white_result = true;
302        for (int ch = 0; ch < num_channels; ++ch) {
303          int pixel = GET_DATA_BYTE(linedata, (x + rect_left_) * num_channels + ch);
304          if (hi_values[ch] >= 0 && (pixel > thresholds[ch]) == (hi_values[ch] == 0)) {
305            white_result = false;
306            break;
307          }
308        }
309        if (white_result) {
310          CLEAR_DATA_BIT(pixline, x);
311        } else {
312          SET_DATA_BIT(pixline, x);
313        }
314      }
315    }
316  }
317  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-thresholder.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-thresholder.cpp</div>
                </div>
                <div class="column column_space"><pre><code>111      pix_ = pixConvertTo8(src, false);
112    } else {
113      pix_ = src.copy();
114    }
115    depth = pixGetDepth(pix_);
</pre></code></div>
                <div class="column column_space"><pre><code>212          tmp = pixConvertTo8(without_cmap, false);
213        } else {
214          tmp = without_cmap.copy();
215        }
216        without_cmap.destroy();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    