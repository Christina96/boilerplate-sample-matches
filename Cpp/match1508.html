<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for textidentificationframe.cpp &amp; flacproperties.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for textidentificationframe.cpp &amp; flacproperties.cpp
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>textidentificationframe.cpp (3.6939313%)<th>flacproperties.cpp (9.150327%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(110-120)<td><a href="#" name="0">(117-131)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>textidentificationframe.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;tbytevectorlist.h&gt;
2 #include &lt;id3v2tag.h&gt;
3 #include "textidentificationframe.h"
4 #include "tpropertymap.h"
5 #include "id3v1genres.h"
6 using namespace TagLib;
7 using namespace ID3v2;
8 class TextIdentificationFrame::TextIdentificationFramePrivate
9 {
10 public:
11   TextIdentificationFramePrivate() : textEncoding(String::Latin1) {}
12   String::Type textEncoding;
13   StringList fieldList;
14 };
15 TextIdentificationFrame::TextIdentificationFrame(const ByteVector &amp;type, String::Type encoding) :
16   Frame(type),
17   d(new TextIdentificationFramePrivate())
18 {
19   d-&gt;textEncoding = encoding;
20 }
21 TextIdentificationFrame::TextIdentificationFrame(const ByteVector &amp;data) :
22   Frame(data),
23   d(new TextIdentificationFramePrivate())
24 {
25   setData(data);
26 }
27 TextIdentificationFrame *TextIdentificationFrame::createTIPLFrame(const PropertyMap &amp;properties) {
28   TextIdentificationFrame *frame = new TextIdentificationFrame("TIPL");
29   StringList l;
30   for(PropertyMap::ConstIterator it = properties.begin(); it != properties.end(); ++it){
31     const String role = involvedPeopleMap()[it-&gt;first];
32     if(role.isEmpty())       continue;
33     l.append(role);
34     l.append(it-&gt;second.toString(","));   }
35   frame-&gt;setText(l);
36   return frame;
37 }
38 TextIdentificationFrame *TextIdentificationFrame::createTMCLFrame(const PropertyMap &amp;properties) {
39   TextIdentificationFrame *frame = new TextIdentificationFrame("TMCL");
40   StringList l;
41   for(PropertyMap::ConstIterator it = properties.begin(); it != properties.end(); ++it){
42     if(!it-&gt;first.startsWith(instrumentPrefix))       continue;
43     l.append(it-&gt;first.substr(instrumentPrefix.size()));
44     l.append(it-&gt;second.toString(","));
45   }
46   frame-&gt;setText(l);
47   return frame;
48 }
49 TextIdentificationFrame::~TextIdentificationFrame()
50 {
51   delete d;
52 }
53 void TextIdentificationFrame::setText(const StringList &amp;l)
54 {
55   d-&gt;fieldList = l;
56 }
57 void TextIdentificationFrame::setText(const String &amp;s)
58 {
59   d-&gt;fieldList = s;
60 }
61 String TextIdentificationFrame::toString() const
62 {
63 <a name="0"></a>  return d-&gt;fieldList.toString();
64 }
65 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>StringList TextIdentificationFrame::fieldList() const
66 {
67   return d-&gt;fieldList;
68 }
69 String::Type TextIdentificationFrame::textEncoding() const
70 {
71   return d-&gt;textEncoding;
72 }
73 void TextIdentificationFrame::setTextEncoding(String::Type encoding)</b></font>
74 {
75   d-&gt;textEncoding = encoding;
76 }
77 namespace
78 {
79   const std::pair&lt;const char *, const char *&gt; involvedPeople[] = {
80       std::make_pair("ARRANGER", "ARRANGER"),
81       std::make_pair("ENGINEER", "ENGINEER"),
82       std::make_pair("PRODUCER", "PRODUCER"),
83       std::make_pair("DJ-MIX", "DJMIXER"),
84       std::make_pair("MIX", "MIXER"),
85   };
86   const size_t involvedPeopleSize = sizeof(involvedPeople) / sizeof(involvedPeople[0]);
87 }  
88 const KeyConversionMap &amp;TextIdentificationFrame::involvedPeopleMap() {
89   static KeyConversionMap m;
90   if(m.isEmpty()) {
91     for(size_t i = 0; i &lt; involvedPeopleSize; ++i)
92       m.insert(involvedPeople[i].second, involvedPeople[i].first);
93   }
94   return m;
95 }
96 PropertyMap TextIdentificationFrame::asProperties() const
97 {
98   if(frameID() == "TIPL")
99     return makeTIPLProperties();
100   if(frameID() == "TMCL")
101     return makeTMCLProperties();
102   PropertyMap map;
103   String tagName = frameIDToKey(frameID());
104   if(tagName.isEmpty()) {
105     map.unsupportedData().append(frameID());
106     return map;
107   }
108   StringList values = fieldList();
109   if(tagName == "GENRE") {
110     for(StringList::Iterator it = values.begin(); it != values.end(); ++it) {
111       bool ok = false;
112       int test = it-&gt;toInt(&amp;ok);       if(ok)
113         *it = ID3v1::genre(test);
114     }
115   } else if(tagName == "DATE") {
116     for(StringList::Iterator it = values.begin(); it != values.end(); ++it) {
117       int tpos = it-&gt;find("T");
118       if(tpos != -1)
119         (*it)[tpos] = ' ';
120     }
121   }
122   PropertyMap ret;
123   ret.insert(tagName, values);
124   return ret;
125 }
126 void TextIdentificationFrame::parseFields(const ByteVector &amp;data)
127 {
128   if(data.size() &lt; 2)
129     return;
130   d-&gt;textEncoding = String::Type(data[0]);
131   int byteAlign = d-&gt;textEncoding == String::Latin1 || d-&gt;textEncoding == String::UTF8 ? 1 : 2;
132   int dataLength = data.size() - 1;
133   while(dataLength &gt; 0 &amp;&amp; data[dataLength] == 0)
134     dataLength--;
135   while(dataLength % byteAlign != 0)
136     dataLength++;
137   ByteVectorList l = ByteVectorList::split(data.mid(1, dataLength), textDelimiter(d-&gt;textEncoding), byteAlign);
138   d-&gt;fieldList.clear();
139   for(ByteVectorList::ConstIterator it = l.begin(); it != l.end(); it++) {
140     if(!(*it).isEmpty()) {
141       if(d-&gt;textEncoding == String::Latin1)
142         d-&gt;fieldList.append(Tag::latin1StringHandler()-&gt;parse(*it));
143       else
144         d-&gt;fieldList.append(String(*it, d-&gt;textEncoding));
145     }
146   }
147 }
148 ByteVector TextIdentificationFrame::renderFields() const
149 {
150   String::Type encoding = checkTextEncoding(d-&gt;fieldList, d-&gt;textEncoding);
151   ByteVector v;
152   v.append(char(encoding));
153   for(StringList::ConstIterator it = d-&gt;fieldList.begin(); it != d-&gt;fieldList.end(); it++) {
154     if(it != d-&gt;fieldList.begin())
155       v.append(textDelimiter(encoding));
156     v.append((*it).data(encoding));
157   }
158   return v;
159 }
160 TextIdentificationFrame::TextIdentificationFrame(const ByteVector &amp;data, Header *h) :
161   Frame(h),
162   d(new TextIdentificationFramePrivate())
163 {
164   parseFields(fieldData(data));
165 }
166 PropertyMap TextIdentificationFrame::makeTIPLProperties() const
167 {
168   PropertyMap map;
169   if(fieldList().size() % 2 != 0){
170     map.unsupportedData().append(frameID());
171     return map;
172   }
173   StringList l = fieldList();
174   for(StringList::ConstIterator it = l.begin(); it != l.end(); ++it) {
175     bool found = false;
176     for(size_t i = 0; i &lt; involvedPeopleSize; ++i)
177       if(*it == involvedPeople[i].first) {
178         map.insert(involvedPeople[i].second, (++it)-&gt;split(","));
179         found = true;
180         break;
181       }
182     if(!found){
183       map.clear();
184       map.unsupportedData().append(frameID());
185       return map;
186     }
187   }
188   return map;
189 }
190 PropertyMap TextIdentificationFrame::makeTMCLProperties() const
191 {
192   PropertyMap map;
193   if(fieldList().size() % 2 != 0){
194     map.unsupportedData().append(frameID());
195     return map;
196   }
197   StringList l = fieldList();
198   for(StringList::ConstIterator it = l.begin(); it != l.end(); ++it) {
199     String instrument = it-&gt;upper();
200     if(instrument.isEmpty()) {
201       map.clear();
202       map.unsupportedData().append(frameID());
203       return map;
204     }
205     map.insert(L"PERFORMER:" + instrument, (++it)-&gt;split(","));
206   }
207   return map;
208 }
209 UserTextIdentificationFrame::UserTextIdentificationFrame(String::Type encoding) :
210   TextIdentificationFrame("TXXX", encoding),
211   d(0)
212 {
213   StringList l;
214   l.append(String());
215   l.append(String());
216   setText(l);
217 }
218 UserTextIdentificationFrame::UserTextIdentificationFrame(const ByteVector &amp;data) :
219   TextIdentificationFrame(data)
220 {
221   checkFields();
222 }
223 UserTextIdentificationFrame::UserTextIdentificationFrame(const String &amp;description, const StringList &amp;values, String::Type encoding) :
224     TextIdentificationFrame("TXXX", encoding),
225     d(0)
226 {
227   setDescription(description);
228   setText(values);
229 }
230 String UserTextIdentificationFrame::toString() const
231 {
232   StringList l = fieldList();
233   for(StringList::Iterator it = l.begin(); it != l.end(); ++it) {
234     l.erase(it);
235     break;
236   }
237   return "[" + description() + "] " + l.toString();
238 }
239 String UserTextIdentificationFrame::description() const
240 {
241   return !TextIdentificationFrame::fieldList().isEmpty()
242     ? TextIdentificationFrame::fieldList().front()
243     : String();
244 }
245 StringList UserTextIdentificationFrame::fieldList() const
246 {
247   return TextIdentificationFrame::fieldList();
248 }
249 void UserTextIdentificationFrame::setText(const String &amp;text)
250 {
251   if(description().isEmpty())
252     setDescription(String());
253   TextIdentificationFrame::setText(StringList(description()).append(text));
254 }
255 void UserTextIdentificationFrame::setText(const StringList &amp;fields)
256 {
257   if(description().isEmpty())
258     setDescription(String());
259   TextIdentificationFrame::setText(StringList(description()).append(fields));
260 }
261 void UserTextIdentificationFrame::setDescription(const String &amp;s)
262 {
263   StringList l = fieldList();
264   if(l.isEmpty())
265     l.append(s);
266   else
267     l[0] = s;
268   TextIdentificationFrame::setText(l);
269 }
270 PropertyMap UserTextIdentificationFrame::asProperties() const
271 {
272   PropertyMap map;
273   String tagName = txxxToKey(description());
274   StringList v = fieldList();
275   for(StringList::ConstIterator it = v.begin(); it != v.end(); ++it)
276     if(it != v.begin())
277       map.insert(tagName, *it);
278   return map;
279 }
280 UserTextIdentificationFrame *UserTextIdentificationFrame::find(
281   ID3v2::Tag *tag, const String &amp;description) {
282   FrameList l = tag-&gt;frameList("TXXX");
283   for(FrameList::ConstIterator it = l.begin(); it != l.end(); ++it) {
284     UserTextIdentificationFrame *f = dynamic_cast&lt;UserTextIdentificationFrame *&gt;(*it);
285     if(f &amp;&amp; f-&gt;description() == description)
286       return f;
287   }
288   return 0;
289 }
290 UserTextIdentificationFrame::UserTextIdentificationFrame(const ByteVector &amp;data, Header *h) :
291   TextIdentificationFrame(data, h)
292 {
293   checkFields();
294 }
295 void UserTextIdentificationFrame::checkFields()
296 {
297   int fields = fieldList().size();
298   if(fields == 0)
299     setDescription(String());
300   if(fields &lt;= 1)
301     setText(String());
302 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>flacproperties.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;tstring.h&gt;
2 #include &lt;tdebug.h&gt;
3 #include "flacproperties.h"
4 #include "flacfile.h"
5 using namespace TagLib;
6 class FLAC::Properties::PropertiesPrivate
7 {
8 public:
9   PropertiesPrivate() :
10     length(0),
11     bitrate(0),
12     sampleRate(0),
13     bitsPerSample(0),
14     channels(0),
15     sampleFrames(0) {}
16   int length;
17   int bitrate;
18   int sampleRate;
19   int bitsPerSample;
20   int channels;
21   unsigned long long sampleFrames;
22   ByteVector signature;
23 };
24 FLAC::Properties::Properties(ByteVector data, long streamLength, ReadStyle style) :
25   AudioProperties(style),
26   d(new PropertiesPrivate())
27 {
28   read(data, streamLength);
29 }
30 FLAC::Properties::Properties(File *, ReadStyle style) :
31   AudioProperties(style),
32   d(new PropertiesPrivate())
33 {
34   debug("FLAC::Properties::Properties() - This constructor is no longer used.");
35 }
36 FLAC::Properties::~Properties()
37 {
38   delete d;
39 }
40 int FLAC::Properties::length() const
41 {
42   return lengthInSeconds();
43 }
44 int FLAC::Properties::lengthInSeconds() const
45 {
46   return d-&gt;length / 1000;
47 }
48 int FLAC::Properties::lengthInMilliseconds() const
49 {
50   return d-&gt;length;
51 }
52 int FLAC::Properties::bitrate() const
53 {
54   return d-&gt;bitrate;
55 }
56 int FLAC::Properties::sampleRate() const
57 {
58   return d-&gt;sampleRate;
59 }
60 int FLAC::Properties::bitsPerSample() const
61 {
62   return d-&gt;bitsPerSample;
63 }
64 int FLAC::Properties::sampleWidth() const
65 {
66   return bitsPerSample();
67 }
68 int FLAC::Properties::channels() const
69 {
70 <a name="0"></a>  return d-&gt;channels;
71 }
72 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>unsigned long long FLAC::Properties::sampleFrames() const
73 {
74   return d-&gt;sampleFrames;
75 }
76 ByteVector FLAC::Properties::signature() const
77 {
78   return d-&gt;signature;
79 }
80 void FLAC::Properties::read(const ByteVector &amp;data, long streamLength)</b></font>
81 {
82   if(data.size() &lt; 18) {
83     debug("FLAC::Properties::read() - FLAC properties must contain at least 18 bytes.");
84     return;
85   }
86   unsigned int pos = 0;
87   pos += 2;
88   pos += 2;
89   pos += 3;
90   pos += 3;
91   const unsigned int flags = data.toUInt(pos, true);
92   pos += 4;
93   d-&gt;sampleRate    = flags &gt;&gt; 12;
94   d-&gt;channels      = ((flags &gt;&gt; 9) &amp;  7) + 1;
95   d-&gt;bitsPerSample = ((flags &gt;&gt; 4) &amp; 31) + 1;
96   const unsigned long long hi = flags &amp; 0xf;
97   const unsigned long long lo = data.toUInt(pos, true);
98   pos += 4;
99   d-&gt;sampleFrames = (hi &lt;&lt; 32) | lo;
100   if(d-&gt;sampleFrames &gt; 0 &amp;&amp; d-&gt;sampleRate &gt; 0) {
101     const double length = d-&gt;sampleFrames * 1000.0 / d-&gt;sampleRate;
102     d-&gt;length  = static_cast&lt;int&gt;(length + 0.5);
103     d-&gt;bitrate = static_cast&lt;int&gt;(streamLength * 8.0 / length + 0.5);
104   }
105   if(data.size() &gt;= pos + 16)
106     d-&gt;signature = data.mid(pos, 16);
107 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
