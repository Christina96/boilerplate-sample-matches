
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tomlconfig.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/configbase.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <boost/filesystem/path.hpp>
5  #include <boost/lexical_cast.hpp>
6  #include <boost/optional.hpp>
7  #include <cpptoml.h>
8  namespace boost
9  {
10  namespace asio
11  {
12  	namespace ip
13  	{
14  		class address_v6;
15  	}
16  }
17  }
18  namespace nano
19  {
20  class error;
21  class tomlconfig : public nano::configbase
22  {
23  public:
24  	tomlconfig ();
25  	tomlconfig (std::shared_ptr<cpptoml::table> const & tree_a, std::shared_ptr<nano::error> const & error_a = nullptr);
26  	void doc (std::string const & key, std::string const & doc);
27  	nano::error & read (boost::filesystem::path const & path_a);
28  	nano::error & read (std::istream & stream_overrides, boost::filesystem::path const & path_a);
29  	nano::error & read (std::istream & stream_a);
30  	nano::error & read (std::istream & stream_first_a, std::istream & stream_second_a);
31  	void write (boost::filesystem::path const & path_a);
32  	void write (std::ostream & stream_a) const;
33  	void open_or_create (std::fstream & stream_a, std::string const & path_a);
34  	std::shared_ptr<cpptoml::table> get_tree ();
35  	bool empty () const;
36  	boost::optional<tomlconfig> get_optional_child (std::string const & key_a);
37  	tomlconfig get_required_child (std::string const & key_a);
38  	tomlconfig & put_child (std::string const & key_a, nano::tomlconfig & conf_a);
39  	tomlconfig & replace_child (std::string const & key_a, nano::tomlconfig & conf_a);
40  	bool has_key (std::string const & key_a);
41  	tomlconfig & erase (std::string const & key_a);
42  	std::shared_ptr<cpptoml::array> create_array (std::string const & key, boost::optional<char const *> documentation_a);
43  	void erase_default_values (tomlconfig & defaults_a);
44  	std::string to_string ();
45  	std::string to_string_commented_entries ();
46  	template <typename T>
47  	tomlconfig & put (std::string const & key, T const & value, boost::optional<char const *> documentation_a = boost::none)
48  	{
49  		tree->insert (key, value);
50  		if (documentation_a)
51  		{
52  			doc (key, *documentation_a);
53  		}
54  		return *this;
55  	}
56  	template <typename T>
57  	tomlconfig & push (std::string const & key, T const & value)
58  	{
59  		if (!has_key (key))
60  		{
61  			auto arr = cpptoml::make_array ();
62  			tree->insert (key, arr);
63  		}
64  		auto arr = tree->get_qualified (key)->as_array ();
65  		arr->push_back (value);
66  		return *this;
67  	}
68  	template <typename T>
69  	tomlconfig & array_entries_required (std::string const & key, std::function<void (T)> callback)
70  	{
71  		if (tree->contains_qualified (key))
72  		{
73  			auto items = tree->get_qualified_array_of<T> (key);
74  			for (auto & item : *items)
75  			{
76  				callback (item);
77  			}
78  		}
79  		else
80  		{
81  			conditionally_set_error<T> (nano::error_config::missing_value, false, key);
82  		}
83  		return *this;
84  	}
85  	template <typename T>
86  	tomlconfig & get_optional (std::string const & key, T & target, T default_value)
87  	{
88  		get_config (true, key, target, default_value);
89  		return *this;
90  	}
91  	template <typename T>
92  	tomlconfig & get_optional (std::string const & key, T & target)
93  	{
94  		get_config (true, key, target, target);
95  		return *this;
96  	}
97  	template <typename T>
98  	boost::optional<T> get_optional (std::string const & key)
99  	{
100  		boost::optional<T> res;
101  		if (has_key (key))
102  		{
103  			T target{};
104  			get_config (true, key, target, target);
105  			res = target;
106  		}
107  		return res;
108  	}
109  	template <typename T>
110  	tomlconfig & get (std::string const & key, T & target)
111  	{
112  		get_config (true, key, target, target);
113  		return *this;
114  	}
115  	template <typename T>
116  	T get (std::string const & key)
117  	{
118  		T target{};
119  		get_config (true, key, target, target);
<span onclick='openModal()' class='match'>120  		return target;
121  	}
122  	template <typename T>
123  	tomlconfig & get_required (std::string const & key, T & target)
124  	{
125  		get_config (false, key, target);
</span>126  		return *this;
127  	}
128  	template <typename T>
129  	tomlconfig & get_required (std::string const & key, T & target, T const & default_value)
130  	{
131  		get_config (false, key, target, default_value);
132  		return *this;
133  	}
134  protected:
135  	template <typename T, typename = std::enable_if_t<nano::is_lexical_castable<T>::value>>
136  	tomlconfig & get_config (bool optional, std::string const & key, T & target, T default_value = T ())
137  	{
138  		try
139  		{
140  			if (tree->contains_qualified (key))
141  			{
142  				auto val (tree->get_qualified_as<std::string> (key));
143  				if (!boost::conversion::try_lexical_convert<T> (*val, target))
144  				{
145  					conditionally_set_error<T> (nano::error_config::invalid_value, optional, key);
146  				}
147  			}
148  			else if (!optional)
149  			{
150  				conditionally_set_error<T> (nano::error_config::missing_value, optional, key);
151  			}
152  			else
153  			{
154  				target = default_value;
155  			}
156  		}
157  		catch (std::runtime_error & ex)
158  		{
159  			conditionally_set_error<T> (ex, optional, key);
160  		}
161  		return *this;
162  	}
163  	tomlconfig & get_config (bool optional, std::string const & key, uint8_t & target, uint8_t default_value = uint8_t ());
164  	tomlconfig & get_config (bool optional, std::string const & key, bool & target, bool default_value = false);
165  	tomlconfig & get_config (bool optional, std::string key, boost::asio::ip::address_v6 & target, boost::asio::ip::address_v6 const & default_value);
166  private:
167  	std::shared_ptr<cpptoml::table> tree;
168  	void erase_defaults (std::shared_ptr<cpptoml::table> const & base, std::shared_ptr<cpptoml::table> const & other, std::shared_ptr<cpptoml::table> const & update_target);
169  };
170  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-jsonconfig.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/configbase.hpp>
3  #include <nano/lib/errors.hpp>
4  #include <nano/lib/utility.hpp>
5  #include <boost/filesystem/path.hpp>
6  #include <boost/lexical_cast.hpp>
7  #include <boost/property_tree/ptree.hpp>
8  #include <fstream>
9  namespace boost
10  {
11  namespace asio
12  {
13  	namespace ip
14  	{
15  		class address_v6;
16  	}
17  }
18  }
19  namespace nano
20  {
21  class jsonconfig : public nano::configbase
22  {
23  public:
24  	jsonconfig ();
25  	jsonconfig (boost::property_tree::ptree & tree_a, std::shared_ptr<nano::error> const & error_a = nullptr);
26  	nano::error & read (boost::filesystem::path const & path_a);
27  	void write (boost::filesystem::path const & path_a);
28  	void write (std::ostream & stream_a) const;
29  	void read (std::istream & stream_a);
30  	void open_or_create (std::fstream & stream_a, std::string const & path_a);
31  	void create_backup_file (boost::filesystem::path const & filepath_a);
32  	boost::property_tree::ptree const & get_tree ();
33  	bool empty () const;
34  	boost::optional<jsonconfig> get_optional_child (std::string const & key_a);
35  	jsonconfig get_required_child (std::string const & key_a);
36  	jsonconfig & put_child (std::string const & key_a, nano::jsonconfig & conf_a);
37  	jsonconfig & replace_child (std::string const & key_a, nano::jsonconfig & conf_a);
38  	bool has_key (std::string const & key_a);
39  	jsonconfig & erase (std::string const & key_a);
40  	template <typename T>
41  	jsonconfig & put (std::string const & key, T const & value)
42  	{
43  		tree.put (key, value);
44  		return *this;
45  	}
46  	template <typename T>
47  	jsonconfig & push (T const & value)
48  	{
49  		boost::property_tree::ptree entry;
50  		entry.put ("", value);
51  		tree.push_back (std::make_pair ("", entry));
52  		return *this;
53  	}
54  	template <typename T>
55  	jsonconfig & array_entries (std::function<void (T)> callback)
56  	{
57  		for (auto & entry : tree)
58  		{
59  			callback (entry.second.get<T> (""));
60  		}
61  		return *this;
62  	}
63  	template <typename T>
64  	jsonconfig & get_optional (std::string const & key, T & target, T default_value)
65  	{
66  		get_config (true, key, target, default_value);
67  		return *this;
68  	}
69  	template <typename T>
70  	jsonconfig & get_optional (std::string const & key, T & target)
71  	{
72  		get_config (true, key, target, target);
73  		return *this;
74  	}
75  	template <typename T>
76  	boost::optional<T> get_optional (std::string const & key)
77  	{
78  		boost::optional<T> res;
79  		if (has_key (key))
80  		{
81  			T target{};
82  			get_config (true, key, target, target);
83  			res = target;
84  		}
<span onclick='openModal()' class='match'>85  		return res;
86  	}
87  	template <typename T>
88  	jsonconfig & get (std::string const & key, T & target)
89  	{
90  		get_config (true, key, target, target);
</span>91  		return *this;
92  	}
93  	template <typename T>
94  	T get (std::string const & key)
95  	{
96  		T target{};
97  		get_config (true, key, target, target);
98  		return target;
99  	}
100  	template <typename T>
101  	jsonconfig & get_required (std::string const & key, T & target)
102  	{
103  		get_config (false, key, target);
104  		return *this;
105  	}
106  	template <typename T>
107  	jsonconfig & get_required (std::string const & key, T & target, T const & default_value)
108  	{
109  		get_config (false, key, target, default_value);
110  		return *this;
111  	}
112  protected:
113  	template <typename T, typename = std::enable_if_t<nano::is_lexical_castable<T>::value>>
114  	jsonconfig & get_config (bool optional, std::string key, T & target, T default_value = T ())
115  	{
116  		try
117  		{
118  			auto val (tree.get<std::string> (key));
119  			if (!boost::conversion::try_lexical_convert<T> (val, target))
120  			{
121  				conditionally_set_error<T> (nano::error_config::invalid_value, optional, key);
122  			}
123  		}
124  		catch (boost::property_tree::ptree_bad_path const &)
125  		{
126  			if (!optional)
127  			{
128  				conditionally_set_error<T> (nano::error_config::missing_value, optional, key);
129  			}
130  			else
131  			{
132  				target = default_value;
133  			}
134  		}
135  		catch (std::runtime_error & ex)
136  		{
137  			conditionally_set_error<T> (ex, optional, key);
138  		}
139  		return *this;
140  	}
141  	jsonconfig & get_config (bool optional, std::string key, uint8_t & target, uint8_t default_value = uint8_t ());
142  	jsonconfig & get_config (bool optional, std::string key, bool & target, bool default_value = false);
143  	jsonconfig & get_config (bool optional, std::string key, boost::asio::ip::address_v6 & target, boost::asio::ip::address_v6 const & default_value);
144  private:
145  	boost::property_tree::ptree & tree;
146  	boost::property_tree::ptree tree_default;
147  	void write_json (std::fstream & stream);
148  };
149  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tomlconfig.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-jsonconfig.hpp</div>
                </div>
                <div class="column column_space"><pre><code>120  		return target;
121  	}
122  	template <typename T>
123  	tomlconfig & get_required (std::string const & key, T & target)
124  	{
125  		get_config (false, key, target);
</pre></code></div>
                <div class="column column_space"><pre><code>85  		return res;
86  	}
87  	template <typename T>
88  	jsonconfig & get (std::string const & key, T & target)
89  	{
90  		get_config (true, key, target, target);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    