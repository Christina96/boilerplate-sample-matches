
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bd.h</h3>
            <pre><code>1  #ifndef bd_h
2  #define bd_h
3  #define forever for(;;)
4  typedef unsigned char uchar;
5  typedef unsigned int uint;
6  typedef unsigned long ulong;
7  typedef unsigned short ushort;
8  typedef float sdouble;
9  typedef long double ldouble;
10  typedef FILE* TFileId;
11  typedef char int8;
12  typedef short int16;
13  typedef int int32;
14  #ifdef GLib_WIN32
15  typedef __int64 int64;
16  #elif defined(GLib_GLIBC)
17  typedef int64_t int64;
18  #else
19  typedef long long int64;
20  #endif
21  typedef unsigned char uint8;
22  typedef unsigned short uint16;
23  typedef unsigned int uint32;
24  #ifdef GLib_WIN32
25  typedef unsigned __int64 uint64;
26  #elif defined(GLib_GLIBC)
27  typedef u_int64_t uint64;
28  #else
29  typedef unsigned long long uint64;
30  #endif
31  #if (!defined(__ssize_t_defined) && !defined(GLib_MACOSX))
32  typedef ptrdiff_t ssize_t;
33  #endif
34  #if defined(GLib_UNIX)
35  #define _isnan(x) isnan(x)
36  #if defined(GLib_MACOSX)
37    #define _finite(x) isfinite(x)
38  #else
39    #define _finite(x) finite(x)
40  #endif
41  #endif
42  #if defined(GLib_WIN32)
43  #define _vsnprintf vsnprintf
44  #endif
45  typedef size_t TSize;
46  #define TSizeMx SIZE_MAX
47  #if 0
48  #if defined(GLib_GLIBC) || defined(GLib_BSD)
49  struct __exception {
50    int    type;      &bsol;* Exception type */
51    char*  name;      &bsol;* Name of function causing exception */
52    double arg1;      &bsol;* 1st argument to function */
53    double arg2;      &bsol;* 2nd argument to function */
54    double retval;    &bsol;* Function return value */
55  };
56  #endif
57  #endif
58  typedef enum {lUndef, lUs, lSi} TLoc;
59  void WrNotify(const char* CaptionCStr, const char* NotifyCStr);
60  void SaveToErrLog(const char* MsgCStr);
61  inline void InfoNotify(const char* NotifyCStr){
62    WrNotify("Information", NotifyCStr);}
63  inline void WarnNotify(const char* NotifyCStr){
64    WrNotify("Warning", NotifyCStr);}
65  inline void ErrNotify(const char* NotifyCStr){
66    WrNotify("Error", NotifyCStr);}
67  inline void StatNotify(const char* NotifyCStr){
68    WrNotify("Status", NotifyCStr);}
69  #if defined (GLib_WIN)
70    #define snprintf _snprintf
71    #define vsnprintf  _vsnprintf
72    #pragma warning(disable: 4786)
73    #pragma warning(disable: 4996)
74  #endif
75  #if defined (GLib_GCC)
76    #define _CONSOLE
77  #endif
78  #if defined(_CONSOLE)||defined(__CONSOLE__)
79    #define GLib_Console
80  #endif
81  #if defined(GLib_Console) && (! (defined(__CONSOLE__)||defined(_CONSOLE)))
82    #define GLib_CreateConsole
83  #endif
84  #define ClassT(TNm) \
85  class TNm{
86  #define ClassTV(TNm, TNmV) \
87  class TNm; \
88  typedef TVec<TNm> TNmV; \
89  class TNm{
90  #define ClassTVQ(TNm, TNmV, TNmQ) \
91  class TNm; \
92  typedef TVec<TNm> TNmV; \
93  typedef TQQueue<TNm> TNmQ; \
94  class TNm{
95  #define ClassTP(TNm, PNm) \
96  class TNm; \
97  typedef TPt<TNm> PNm; \
98  class TNm{ \
99  private: \
100    TCRef CRef; \
101  public: \
102    friend class TPt<TNm>;
103  #define ClassHdTP(TNm, PNm) \
104  class TNm; \
105  typedef TPt<TNm> PNm;
106  #define ClassTPE(TNm, PNm, ENm) \
107  class TNm; \
108  typedef TPt<TNm> PNm; \
109  class TNm: public ENm{ \
110  private: \
<span onclick='openModal()' class='match'>111    TCRef CRef; \
112  public: \
113    friend class TPt<TNm>;
114  #define ClassTPEE(TNm, PNm, ENm1, ENm2) \
</span>115  class TNm; \
116  typedef TPt<TNm> PNm; \
117  class TNm: public ENm1, public ENm2{ \
118  private: \
119    TCRef CRef; \
120  public: \
121    friend class TPt<TNm>;
122  #define ClassTE(TNm, ENm) \
123  class TNm; \
124  class TNm: public ENm{ \
125  public: \
126  
127  #define ClassTPV(TNm, PNm, TNmV) \
128  class TNm; \
129  typedef TPt<TNm> PNm; \
130  typedef TVec<PNm> TNmV; \
131  class TNm{ \
132  private: \
133    TCRef CRef; \
134  public: \
135    friend class TPt<TNm>;
136  #define ClassHdTPV(TNm, PNm, TNmV) \
137  class TNm; \
138  typedef TPt<TNm> PNm; \
139  typedef TVec<PNm> TNmV;
140  #define ClassTPVL(TNm, PNm, TNmV, TNmL, TNmLN) \
141  class TNm; \
142  typedef TPt<TNm> PNm; \
143  typedef TVec<PNm> TNmV; \
144  typedef TLst<PNm> TNmL; \
145  typedef TLstNd<PNm>* TNmLN; \
146  class TNm{ \
147  private: \
148    TCRef CRef; \
149  public: \
150    friend class TPt<TNm>;
151  class TSIn;
152  class TSOut;
153  class TStr;
154  class TXmlObjSer;
155  class TXmlObjSerTagNm;
156  template <class TRec> class TPt;
157  ClassHdTP(TXmlTok, PXmlTok)
158  ClassHdTP(TExcept, PExcept)
159  ClassHdTP(TXmlDoc, PXmlDoc)
160  #define UndefDefaultCopyAssign(TNm) \
161  private: \
162    TNm(){} \
163    TNm(const TNm&); \
164    TNm& operator=(const TNm&)
165  #define UndefCopyAssign(TNm) \
166  private: \
167    TNm(const TNm&); \
168    TNm& operator=(const TNm&)
169  #define UndefCopy(TNm) \
170  private: \
171    TNm(const TNm&)
172  #define UndefAssign(TNm) \
173  private: \
174    TNm& operator=(const TNm&)
175  class TOnExeStop{
176  private:
177    typedef bool (*TOnExeStopF)(char* MsgCStr);
178    static TOnExeStopF OnExeStopF;
179  public:
180    static bool IsOnExeStopF(){return OnExeStopF!=NULL;}
181    static void PutOnExeStopF(TOnExeStopF _OnExeStopF){OnExeStopF=_OnExeStopF;}
182    static TOnExeStopF GetOnExeStopF(){return OnExeStopF;}
183  };
184  void ExeStop(
185   const char* MsgStr, const char* ReasonStr,
186   const char* CondStr, const char* FNm, const int& LnN);
187  #define Fail ExeStop(NULL, NULL, "Fail", __FILE__, __LINE__)
188  #define FailR(Reason) ExeStop((Reason), NULL, "Fail", __FILE__, __LINE__)
189  #define FailRA(Reason, ArgStr) \
190    ExeStop((TStr(Reason)+" ("+ArgStr+")").CStr(), NULL, "Fail", __FILE__, __LINE__)
191  #define EFail TExcept::ThrowFull("", TStr("[")+ TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) + "]")
192  #define EFailR(Reason) TExcept::ThrowFull(Reason, TStr("[")+TStr(__FILE__)+" line "+TInt::GetStr(__LINE__)+"]")
193  #ifdef NDEBUG
194  #define Assert(Cond)
195  #else
196  #define Assert(Cond) \
197    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, NULL, #Cond, __FILE__, __LINE__))
198  #endif
199  #ifdef NDEBUG
200  #define AssertR(Cond, Reason)
201  #else
202  #define AssertR(Cond, Reason) ((Cond) ? static_cast<void>(0) : \
203    ExeStop(NULL, TStr(Reason).CStr(), #Cond, __FILE__, __LINE__))
204  #endif
205  #define IAssert(Cond) \
206    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, NULL, #Cond, __FILE__, __LINE__))
207  #define IAssertR(Cond, Reason) \
208    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, TStr(Reason).CStr(), #Cond, __FILE__, __LINE__))
209  #define WAssert(Cond, MsgCStr) \
210    ((Cond) ? static_cast<void>(0) : WarnNotify(MsgCStr))
211  #define SAssert(Cond) \
212    ((Cond) ? static_cast<void>(0) : ExeStop(TSysStr::GetLastMsgCStr(), NULL, #Cond, __FILE__, __LINE__))
213  #define FAssert(Cond, MsgCStr) \
214    ((Cond) ? static_cast<void>(0) : ExeStop(TStr(MsgCStr).CStr(), NULL, NULL, __FILE__, __LINE__))
215  #define FSAssert(Cond) \
216    ((Cond) ? static_cast<void>(0) : ExeStop(TSysStr::GetLastMsgCStr(), NULL, NULL, __FILE__, __LINE__))
217  #define EAssert(Cond) \
218    ((Cond) ? static_cast<void>(0) : TExcept::ThrowFull(#Cond, TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) +": "+ TStr(#Cond)))
219  #define EAssertR(Cond, MsgStr) \
220    ((Cond) ? static_cast<void>(0) : TExcept::ThrowFull(MsgStr, TStr(__FILE__)+" line "+TInt::GetStr(__LINE__)+": "+TStr(#Cond)))
221  #define EAssertRA(Cond, MsgStr, ArgStr) \
222    ((Cond) ? static_cast<void>(0) : TExcept::Throw(MsgStr, ArgStr))
223  #define EAssertRAA(Cond, MsgStr, ArgStr1, ArgStr2) \
224    ((Cond) ? static_cast<void>(0) : TExcept::Throw(MsgStr, ArgStr1, ArgStr2))
225  #define ESAssert(Cond) \
226    ((Cond) ? static_cast<void>(0) : TExcept::Throw(TSysStr::GetLastMsgCStr(), \
227    TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) +": "+ TStr(#Cond)))
228  template <bool BoolVal> struct TStaticAssert;
229  template <> struct TStaticAssert<true> { enum { value = 1 }; };
230  template<int IntVal> struct TStaticAssertTest{};
231  #define CAssert(Cond) \
232    
233  template <class TRec>
234  bool IsXLoadFromFileOk(const TStr& FNm, const TStr& Nm, TRec& Rec, TStr& MsgStr);
235  template <class TRec>
236  void XLoadFromFile(const TStr& FNm, const TStr& Nm, TRec& Rec);
237  #define XLoadHd(Nm) \
238    {TStr TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
239    TXmlObjSer::AssertXmlHd(XmlTok, Nm, TypeNm);}
240  #define XLoad(Nm) \
241    Nm.LoadXml(XmlTok->GetTagTok(#Nm), #Nm);
242  #define XSaveHd(Nm) \
243    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
244    TXmlObjSerTagNm XmlObjSerTagNm(SOut, false, Nm, _TypeNm);
245  #define XSaveHdArg(Nm, ArgNm, ArgVal) \
246    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
247    TXmlObjSerTagNm XmlObjSerTagNm(SOut, false, Nm, _TypeNm, ArgNm, ArgVal);
248  #define XSaveBETag(Nm) \
249    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
250    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm);
251  #define XSaveBETagArg(Nm, ArgNm, ArgVal) \
252    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
253    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm, ArgNm, ArgVal);
254  #define XSaveBETagArg4(Nm, ArgNm1, ArgVal1, ArgNm2, ArgVal2, ArgNm3, ArgVal3, ArgNm4, ArgVal4) \
255    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
256    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm, ArgNm1, ArgVal1, ArgNm2, ArgVal2, ArgNm3, ArgVal3, ArgNm4, ArgVal4);
257  #define XSave(Nm) \
258    Nm.SaveXml(SOut, #Nm)
259  #define XSaveToFile(Nm, FNm) \
260    {TFOut SOut(FNm); Nm.SaveXml(SOut, #Nm);}
261  typedef enum {loUndef, loNot, loAnd, loOr} TLogOp;
262  typedef enum {roUndef, roLs, roLEq, roEq, roNEq, roGEq, roGt} TRelOp;
263  #ifndef MIN
264    #define MIN(a,b) ((a)<(b)?(a):(b))
265  #endif
266  #ifndef MAX
267    #define MAX(a,b) ((a)>(b)?(a):(b))
268  #endif
269  template<class T>
270  class TEq{
271  public:
272    bool operator()(const T& x, const T& y) const {return x==y;}
273  };
274  template<class T>
275  class TNEq{
276  public:
277    bool operator()(const T& x, const T& y) const {return x!=y;}
278  };
279  template<class T>
280  class TLss{
281  public:
282    bool operator()(const T& x, const T& y) const {return x<y;}
283    int Cmp(const T& d1, const T& d2) const {
284      if (d1<d2){return -1;}
285      else if (d2<d1){return 1;}
286      else {return 0;}
287    }
288  };
289  template<class T>
290  class TLEq{
291  public:
292    bool operator()(const T& x, const T& y) const {return x<=y;}
293  };
294  template<class T>
295  class TGtr{
296  public:
297    bool operator() (const T& x, const T& y) const { return x>y; }
298    int Cmp(const T& d1, const T& d2) const { /&bsol;** vprasaj Janeza za uporabo
299      if (d1<d2){return 1;}
300      else if (d2<d1){return -1;}
301      else {return 0;}
302    }
303  };
304  template<class T>
305  class TGEq{
306  public:
307    bool operator()(const T& x, const T& y) const {return x>=y;}
308  };
309  template<class T>
310  class TCmp{
311  public:
312    int operator()(const T& x, const T& y) const {
313      if (x < y){return -1;}
314      else if (x > y){return 1;}
315      else {return 0;}
316    }
317  };
318  template <class TRec>
319  bool operator!=(const TRec& Rec1, const TRec& Rec2){return !(Rec1==Rec2);}
320  template <class TRec>
321  bool operator>(const TRec& Rec1, const TRec& Rec2){return Rec2<Rec1;}
322  template <class TRec>
323  bool operator<=(const TRec& Rec1, const TRec& Rec2){return !(Rec2<Rec1);}
324  template <class TRec>
325  bool operator>=(const TRec& Rec1, const TRec& Rec2){return !(Rec1<Rec2);}
326  template <class TRec>
327  bool Cmp(const int& RelOp, const TRec& Rec1, const TRec& Rec2){
328    switch (RelOp){
329      case roLs: return Rec1<Rec2;
330      case roLEq: return Rec1<=Rec2;
331      case roEq: return Rec1==Rec2;
332      case roNEq: return Rec1!=Rec2;
333      case roGEq: return Rec1>=Rec2;
334      case roGt: return Rec1>Rec2;
335      default: Fail; return false;
336    }
337  }
338  class TCRef{
339  private:
340    int Refs;
341  private:
342    TCRef& operator=(const TCRef&);
343    TCRef(const TCRef&);
344  public:
345    TCRef(): Refs(0){}
346    ~TCRef(){Assert(Refs==0);}
347    void MkRef(){Refs++;}
348    void UnRef(){Assert(Refs>0); Refs--;}
349    bool NoRef() const {return Refs==0;}
350    int GetRefs() const {return Refs;}
351  };
352  template <class TRec>
353  class TPt{
354  public:
355    typedef TRec TObj;
356  private:
357    TRec* Addr;
358    void MkRef() const {
359      if (Addr!=NULL){
360        Addr->CRef.MkRef();
361      }
362    }
363    void UnRef() const {
364      if (Addr!=NULL){
365        Addr->CRef.UnRef();
366        if (Addr->CRef.NoRef()){delete Addr;}
367      }
368    }
369  public:
370    TPt(): Addr(NULL){}
371    TPt(const TPt& Pt): Addr(Pt.Addr){MkRef();}
372    TPt(TRec* _Addr): Addr(_Addr){MkRef();}
373    static TPt New(){return TObj::New();}
374    ~TPt(){UnRef();}
375    explicit TPt(TSIn& SIn);
376    explicit TPt(TSIn& SIn, void* ThisPt);
377    void Save(TSOut& SOut) const;
378    void LoadXml(const TPt<TXmlTok>& XmlTok, const TStr& Nm);
379    void SaveXml(TSOut& SOut, const TStr& Nm) const;
380    TPt& operator=(const TPt& Pt){
381      if (this!=&Pt){Pt.MkRef(); UnRef(); Addr=Pt.Addr;} return *this;}
382    bool operator==(const TPt& Pt) const {return *Addr==*Pt.Addr;}
383    bool operator!=(const TPt& Pt) const {return *Addr!=*Pt.Addr;}
384    bool operator<(const TPt& Pt) const {return *Addr<*Pt.Addr;}
385    TRec* operator->() const {Assert(Addr!=NULL); return Addr;}
386    TRec& operator*() const {Assert(Addr!=NULL); return *Addr;}
387    TRec& operator[](const int& RecN) const {
388      Assert(Addr!=NULL); return Addr[RecN];}
389    TRec* operator()() const {return Addr;}
390    bool Empty() const { return Addr==NULL;}
391    void Clr(){UnRef(); Addr=NULL;}
392    int GetRefs() const {
393      if (Addr==NULL){return -1;} else {return Addr->CRef.GetRefs();}}
394    int GetPrimHashCd() const {return Addr->GetPrimHashCd();}
395    int GetSecHashCd() const {return Addr->GetSecHashCd();}
396    TPt<TRec> Clone(){return MkClone(*this);}
397  };
398  class TSStr{
399  private:
400    char* Bf;
401  public:
402    TSStr(): Bf(NULL){
403      Bf=new char[0+1]; Bf[0]=0;}
404    TSStr(const TSStr& SStr): Bf(NULL){
405      Bf=new char[strlen(SStr.Bf)+1]; strcpy(Bf, SStr.Bf);}
406    TSStr(const char* _Bf): Bf(NULL){
407      Bf=new char[strlen(_Bf)+1]; strcpy(Bf, _Bf);}
408    ~TSStr(){delete[] Bf;}
409    TSStr& operator=(const TSStr& SStr){
410      if (this!=&SStr){
411        delete[] Bf; Bf=new char[strlen(SStr.Bf)+1]; strcpy(Bf, SStr.Bf);}
412      return *this;}
413    char* CStr() {return Bf;}
414    const char* CStr() const {return Bf;}
415    bool Empty() const {return Bf[0]==0;}
416    int Len() const {return int(strlen(Bf));}
417  };
418  class TConv_Pt64Ints32{
419  private:
420    union{
421      void* Pt;
422      uint64 UInt64;
423      struct {uint Ls; uint Ms;} UInt32;
424    } Val;
425    UndefCopyAssign(TConv_Pt64Ints32);
426  public:
427    TConv_Pt64Ints32(){
428      Val.Pt=0; Val.UInt32.Ms=0; Val.UInt32.Ls=0;}
429    TConv_Pt64Ints32(void* Pt){
430      Val.UInt32.Ms=0; Val.UInt32.Ls=0; Val.Pt=Pt;}
431    TConv_Pt64Ints32(const uint& Ms, const uint& Ls){
432      Val.Pt=0; Val.UInt32.Ms=Ms; Val.UInt32.Ls=Ls;}
433    void PutPt(void* Pt){Val.Pt=Pt;}
434    void* GetPt() const {return Val.Pt;}
435    void PutUInt64(const uint64& _UInt64){Val.UInt64=_UInt64;}
436    uint64 GetUInt64() const {return Val.UInt64;}
437    void PutMsUInt32(const uint& Ms){Val.UInt32.Ms=Ms;}
438    uint GetMsUInt32() const {return Val.UInt32.Ms;}
439    void PutLsUInt32(const uint& Ls){Val.UInt32.Ls=Ls;}
440    uint GetLsUInt32() const {return Val.UInt32.Ls;}
441  };
442  template <class TRec>
443  void Swap(TRec& Rec1, TRec& Rec2){
444    TRec Rec=Rec1; Rec1=Rec2; Rec2=Rec;
445  }
446  class TPairHashImpl1 {
447  public:
448    static inline int GetHashCd(const int hc1, const int hc2) {
449      unsigned long long sum = ((unsigned long long) hc1) + ((unsigned long long) hc2);
450      unsigned long long c = ((sum * (sum + 1)) >> 1) + hc1;
451      return (int) (c % 0x7fffffffULL); }
452  };
453  class TPairHashImpl2 {
454  public:
455    static inline int GetHashCd(const int hc1, const int hc2) {
456      unsigned long long sum = ((unsigned long long) hc1) + ((unsigned long long) hc2);
457      unsigned long long c = ((sum * (sum + 1)) >> 1) + hc1;
458      unsigned int R = (unsigned int) (c >> 31), Q = (unsigned int) (c & 0x7fffffffULL);
459      if ((R & 0x80000000U) != 0) R -= 0x7fffffffU;
460      unsigned int RQ = R + Q;
461      if (RQ < 0x7fffffffU) return (int) RQ;
462      RQ -= 0x7fffffffU;
463      return (RQ == 0x7fffffffU) ? 0 : (int) RQ; }
464  };
465  #if (defined(GLib_64Bit)) && ! (defined(DEBUG) || defined(_DEBUG))
466    typedef TPairHashImpl1 TPairHashImpl;
467  #else
468    typedef TPairHashImpl2 TPairHashImpl;
469  #endif
470  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bd.h</h3>
            <pre><code>1  #ifndef bd_h
2  #define bd_h
3  #define forever for(;;)
4  typedef unsigned char uchar;
5  typedef unsigned int uint;
6  typedef unsigned long ulong;
7  typedef unsigned short ushort;
8  typedef float sdouble;
9  typedef long double ldouble;
10  typedef FILE* TFileId;
11  typedef char int8;
12  typedef short int16;
13  typedef int int32;
14  #ifdef GLib_WIN32
15  typedef __int64 int64;
16  #elif defined(GLib_GLIBC)
17  typedef int64_t int64;
18  #else
19  typedef long long int64;
20  #endif
21  typedef unsigned char uint8;
22  typedef unsigned short uint16;
23  typedef unsigned int uint32;
24  #ifdef GLib_WIN32
25  typedef unsigned __int64 uint64;
26  #elif defined(GLib_GLIBC)
27  typedef u_int64_t uint64;
28  #else
29  typedef unsigned long long uint64;
30  #endif
31  #if (!defined(__ssize_t_defined) && !defined(GLib_MACOSX))
32  typedef ptrdiff_t ssize_t;
33  #endif
34  #if defined(GLib_UNIX)
35  #define _isnan(x) isnan(x)
36  #if defined(GLib_MACOSX)
37    #define _finite(x) isfinite(x)
38  #else
39    #define _finite(x) finite(x)
40  #endif
41  #endif
42  #if defined(GLib_WIN32)
43  #define _vsnprintf vsnprintf
44  #endif
45  typedef size_t TSize;
46  #define TSizeMx SIZE_MAX
47  #if 0
48  #if defined(GLib_GLIBC) || defined(GLib_BSD)
49  struct __exception {
50    int    type;      &bsol;* Exception type */
51    char*  name;      &bsol;* Name of function causing exception */
52    double arg1;      &bsol;* 1st argument to function */
53    double arg2;      &bsol;* 2nd argument to function */
54    double retval;    &bsol;* Function return value */
55  };
56  #endif
57  #endif
58  typedef enum {lUndef, lUs, lSi} TLoc;
59  void WrNotify(const char* CaptionCStr, const char* NotifyCStr);
60  void SaveToErrLog(const char* MsgCStr);
61  inline void InfoNotify(const char* NotifyCStr){
62    WrNotify("Information", NotifyCStr);}
63  inline void WarnNotify(const char* NotifyCStr){
64    WrNotify("Warning", NotifyCStr);}
65  inline void ErrNotify(const char* NotifyCStr){
66    WrNotify("Error", NotifyCStr);}
67  inline void StatNotify(const char* NotifyCStr){
68    WrNotify("Status", NotifyCStr);}
69  #if defined (GLib_WIN)
70    #define snprintf _snprintf
71    #define vsnprintf  _vsnprintf
72    #pragma warning(disable: 4786)
73    #pragma warning(disable: 4996)
74  #endif
75  #if defined (GLib_GCC)
76    #define _CONSOLE
77  #endif
78  #if defined(_CONSOLE)||defined(__CONSOLE__)
79    #define GLib_Console
80  #endif
81  #if defined(GLib_Console) && (! (defined(__CONSOLE__)||defined(_CONSOLE)))
82    #define GLib_CreateConsole
83  #endif
84  #define ClassT(TNm) \
85  class TNm{
86  #define ClassTV(TNm, TNmV) \
87  class TNm; \
88  typedef TVec<TNm> TNmV; \
89  class TNm{
90  #define ClassTVQ(TNm, TNmV, TNmQ) \
91  class TNm; \
92  typedef TVec<TNm> TNmV; \
93  typedef TQQueue<TNm> TNmQ; \
94  class TNm{
95  #define ClassTP(TNm, PNm) \
96  class TNm; \
97  typedef TPt<TNm> PNm; \
98  class TNm{ \
99  private: \
100    TCRef CRef; \
101  public: \
102    friend class TPt<TNm>;
103  #define ClassHdTP(TNm, PNm) \
104  class TNm; \
105  typedef TPt<TNm> PNm;
106  #define ClassTPE(TNm, PNm, ENm) \
107  class TNm; \
108  typedef TPt<TNm> PNm; \
109  class TNm: public ENm{ \
110  private: \
111    TCRef CRef; \
112  public: \
113    friend class TPt<TNm>;
114  #define ClassTPEE(TNm, PNm, ENm1, ENm2) \
115  class TNm; \
116  typedef TPt<TNm> PNm; \
117  class TNm: public ENm1, public ENm2{ \
118  private: \
<span onclick='openModal()' class='match'>119    TCRef CRef; \
120  public: \
121    friend class TPt<TNm>;
122  #define ClassTE(TNm, ENm) \
</span>123  class TNm; \
124  class TNm: public ENm{ \
125  public: \
126  
127  #define ClassTPV(TNm, PNm, TNmV) \
128  class TNm; \
129  typedef TPt<TNm> PNm; \
130  typedef TVec<PNm> TNmV; \
131  class TNm{ \
132  private: \
133    TCRef CRef; \
134  public: \
135    friend class TPt<TNm>;
136  #define ClassHdTPV(TNm, PNm, TNmV) \
137  class TNm; \
138  typedef TPt<TNm> PNm; \
139  typedef TVec<PNm> TNmV;
140  #define ClassTPVL(TNm, PNm, TNmV, TNmL, TNmLN) \
141  class TNm; \
142  typedef TPt<TNm> PNm; \
143  typedef TVec<PNm> TNmV; \
144  typedef TLst<PNm> TNmL; \
145  typedef TLstNd<PNm>* TNmLN; \
146  class TNm{ \
147  private: \
148    TCRef CRef; \
149  public: \
150    friend class TPt<TNm>;
151  class TSIn;
152  class TSOut;
153  class TStr;
154  class TXmlObjSer;
155  class TXmlObjSerTagNm;
156  template <class TRec> class TPt;
157  ClassHdTP(TXmlTok, PXmlTok)
158  ClassHdTP(TExcept, PExcept)
159  ClassHdTP(TXmlDoc, PXmlDoc)
160  #define UndefDefaultCopyAssign(TNm) \
161  private: \
162    TNm(){} \
163    TNm(const TNm&); \
164    TNm& operator=(const TNm&)
165  #define UndefCopyAssign(TNm) \
166  private: \
167    TNm(const TNm&); \
168    TNm& operator=(const TNm&)
169  #define UndefCopy(TNm) \
170  private: \
171    TNm(const TNm&)
172  #define UndefAssign(TNm) \
173  private: \
174    TNm& operator=(const TNm&)
175  class TOnExeStop{
176  private:
177    typedef bool (*TOnExeStopF)(char* MsgCStr);
178    static TOnExeStopF OnExeStopF;
179  public:
180    static bool IsOnExeStopF(){return OnExeStopF!=NULL;}
181    static void PutOnExeStopF(TOnExeStopF _OnExeStopF){OnExeStopF=_OnExeStopF;}
182    static TOnExeStopF GetOnExeStopF(){return OnExeStopF;}
183  };
184  void ExeStop(
185   const char* MsgStr, const char* ReasonStr,
186   const char* CondStr, const char* FNm, const int& LnN);
187  #define Fail ExeStop(NULL, NULL, "Fail", __FILE__, __LINE__)
188  #define FailR(Reason) ExeStop((Reason), NULL, "Fail", __FILE__, __LINE__)
189  #define FailRA(Reason, ArgStr) \
190    ExeStop((TStr(Reason)+" ("+ArgStr+")").CStr(), NULL, "Fail", __FILE__, __LINE__)
191  #define EFail TExcept::ThrowFull("", TStr("[")+ TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) + "]")
192  #define EFailR(Reason) TExcept::ThrowFull(Reason, TStr("[")+TStr(__FILE__)+" line "+TInt::GetStr(__LINE__)+"]")
193  #ifdef NDEBUG
194  #define Assert(Cond)
195  #else
196  #define Assert(Cond) \
197    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, NULL, #Cond, __FILE__, __LINE__))
198  #endif
199  #ifdef NDEBUG
200  #define AssertR(Cond, Reason)
201  #else
202  #define AssertR(Cond, Reason) ((Cond) ? static_cast<void>(0) : \
203    ExeStop(NULL, TStr(Reason).CStr(), #Cond, __FILE__, __LINE__))
204  #endif
205  #define IAssert(Cond) \
206    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, NULL, #Cond, __FILE__, __LINE__))
207  #define IAssertR(Cond, Reason) \
208    ((Cond) ? static_cast<void>(0) : ExeStop(NULL, TStr(Reason).CStr(), #Cond, __FILE__, __LINE__))
209  #define WAssert(Cond, MsgCStr) \
210    ((Cond) ? static_cast<void>(0) : WarnNotify(MsgCStr))
211  #define SAssert(Cond) \
212    ((Cond) ? static_cast<void>(0) : ExeStop(TSysStr::GetLastMsgCStr(), NULL, #Cond, __FILE__, __LINE__))
213  #define FAssert(Cond, MsgCStr) \
214    ((Cond) ? static_cast<void>(0) : ExeStop(TStr(MsgCStr).CStr(), NULL, NULL, __FILE__, __LINE__))
215  #define FSAssert(Cond) \
216    ((Cond) ? static_cast<void>(0) : ExeStop(TSysStr::GetLastMsgCStr(), NULL, NULL, __FILE__, __LINE__))
217  #define EAssert(Cond) \
218    ((Cond) ? static_cast<void>(0) : TExcept::ThrowFull(#Cond, TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) +": "+ TStr(#Cond)))
219  #define EAssertR(Cond, MsgStr) \
220    ((Cond) ? static_cast<void>(0) : TExcept::ThrowFull(MsgStr, TStr(__FILE__)+" line "+TInt::GetStr(__LINE__)+": "+TStr(#Cond)))
221  #define EAssertRA(Cond, MsgStr, ArgStr) \
222    ((Cond) ? static_cast<void>(0) : TExcept::Throw(MsgStr, ArgStr))
223  #define EAssertRAA(Cond, MsgStr, ArgStr1, ArgStr2) \
224    ((Cond) ? static_cast<void>(0) : TExcept::Throw(MsgStr, ArgStr1, ArgStr2))
225  #define ESAssert(Cond) \
226    ((Cond) ? static_cast<void>(0) : TExcept::Throw(TSysStr::GetLastMsgCStr(), \
227    TStr(__FILE__) + " line " + TInt::GetStr(__LINE__) +": "+ TStr(#Cond)))
228  template <bool BoolVal> struct TStaticAssert;
229  template <> struct TStaticAssert<true> { enum { value = 1 }; };
230  template<int IntVal> struct TStaticAssertTest{};
231  #define CAssert(Cond) \
232    
233  template <class TRec>
234  bool IsXLoadFromFileOk(const TStr& FNm, const TStr& Nm, TRec& Rec, TStr& MsgStr);
235  template <class TRec>
236  void XLoadFromFile(const TStr& FNm, const TStr& Nm, TRec& Rec);
237  #define XLoadHd(Nm) \
238    {TStr TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
239    TXmlObjSer::AssertXmlHd(XmlTok, Nm, TypeNm);}
240  #define XLoad(Nm) \
241    Nm.LoadXml(XmlTok->GetTagTok(#Nm), #Nm);
242  #define XSaveHd(Nm) \
243    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
244    TXmlObjSerTagNm XmlObjSerTagNm(SOut, false, Nm, _TypeNm);
245  #define XSaveHdArg(Nm, ArgNm, ArgVal) \
246    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
247    TXmlObjSerTagNm XmlObjSerTagNm(SOut, false, Nm, _TypeNm, ArgNm, ArgVal);
248  #define XSaveBETag(Nm) \
249    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
250    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm);
251  #define XSaveBETagArg(Nm, ArgNm, ArgVal) \
252    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
253    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm, ArgNm, ArgVal);
254  #define XSaveBETagArg4(Nm, ArgNm1, ArgVal1, ArgNm2, ArgVal2, ArgNm3, ArgVal3, ArgNm4, ArgVal4) \
255    TStr _TypeNm=TXmlObjSer::GetTagNm(TStr(typeid(*this).name())); \
256    TXmlObjSerTagNm XmlObjSerTagNm(SOut, true, Nm, _TypeNm, ArgNm1, ArgVal1, ArgNm2, ArgVal2, ArgNm3, ArgVal3, ArgNm4, ArgVal4);
257  #define XSave(Nm) \
258    Nm.SaveXml(SOut, #Nm)
259  #define XSaveToFile(Nm, FNm) \
260    {TFOut SOut(FNm); Nm.SaveXml(SOut, #Nm);}
261  typedef enum {loUndef, loNot, loAnd, loOr} TLogOp;
262  typedef enum {roUndef, roLs, roLEq, roEq, roNEq, roGEq, roGt} TRelOp;
263  #ifndef MIN
264    #define MIN(a,b) ((a)<(b)?(a):(b))
265  #endif
266  #ifndef MAX
267    #define MAX(a,b) ((a)>(b)?(a):(b))
268  #endif
269  template<class T>
270  class TEq{
271  public:
272    bool operator()(const T& x, const T& y) const {return x==y;}
273  };
274  template<class T>
275  class TNEq{
276  public:
277    bool operator()(const T& x, const T& y) const {return x!=y;}
278  };
279  template<class T>
280  class TLss{
281  public:
282    bool operator()(const T& x, const T& y) const {return x<y;}
283    int Cmp(const T& d1, const T& d2) const {
284      if (d1<d2){return -1;}
285      else if (d2<d1){return 1;}
286      else {return 0;}
287    }
288  };
289  template<class T>
290  class TLEq{
291  public:
292    bool operator()(const T& x, const T& y) const {return x<=y;}
293  };
294  template<class T>
295  class TGtr{
296  public:
297    bool operator() (const T& x, const T& y) const { return x>y; }
298    int Cmp(const T& d1, const T& d2) const { /&bsol;** vprasaj Janeza za uporabo
299      if (d1<d2){return 1;}
300      else if (d2<d1){return -1;}
301      else {return 0;}
302    }
303  };
304  template<class T>
305  class TGEq{
306  public:
307    bool operator()(const T& x, const T& y) const {return x>=y;}
308  };
309  template<class T>
310  class TCmp{
311  public:
312    int operator()(const T& x, const T& y) const {
313      if (x < y){return -1;}
314      else if (x > y){return 1;}
315      else {return 0;}
316    }
317  };
318  template <class TRec>
319  bool operator!=(const TRec& Rec1, const TRec& Rec2){return !(Rec1==Rec2);}
320  template <class TRec>
321  bool operator>(const TRec& Rec1, const TRec& Rec2){return Rec2<Rec1;}
322  template <class TRec>
323  bool operator<=(const TRec& Rec1, const TRec& Rec2){return !(Rec2<Rec1);}
324  template <class TRec>
325  bool operator>=(const TRec& Rec1, const TRec& Rec2){return !(Rec1<Rec2);}
326  template <class TRec>
327  bool Cmp(const int& RelOp, const TRec& Rec1, const TRec& Rec2){
328    switch (RelOp){
329      case roLs: return Rec1<Rec2;
330      case roLEq: return Rec1<=Rec2;
331      case roEq: return Rec1==Rec2;
332      case roNEq: return Rec1!=Rec2;
333      case roGEq: return Rec1>=Rec2;
334      case roGt: return Rec1>Rec2;
335      default: Fail; return false;
336    }
337  }
338  class TCRef{
339  private:
340    int Refs;
341  private:
342    TCRef& operator=(const TCRef&);
343    TCRef(const TCRef&);
344  public:
345    TCRef(): Refs(0){}
346    ~TCRef(){Assert(Refs==0);}
347    void MkRef(){Refs++;}
348    void UnRef(){Assert(Refs>0); Refs--;}
349    bool NoRef() const {return Refs==0;}
350    int GetRefs() const {return Refs;}
351  };
352  template <class TRec>
353  class TPt{
354  public:
355    typedef TRec TObj;
356  private:
357    TRec* Addr;
358    void MkRef() const {
359      if (Addr!=NULL){
360        Addr->CRef.MkRef();
361      }
362    }
363    void UnRef() const {
364      if (Addr!=NULL){
365        Addr->CRef.UnRef();
366        if (Addr->CRef.NoRef()){delete Addr;}
367      }
368    }
369  public:
370    TPt(): Addr(NULL){}
371    TPt(const TPt& Pt): Addr(Pt.Addr){MkRef();}
372    TPt(TRec* _Addr): Addr(_Addr){MkRef();}
373    static TPt New(){return TObj::New();}
374    ~TPt(){UnRef();}
375    explicit TPt(TSIn& SIn);
376    explicit TPt(TSIn& SIn, void* ThisPt);
377    void Save(TSOut& SOut) const;
378    void LoadXml(const TPt<TXmlTok>& XmlTok, const TStr& Nm);
379    void SaveXml(TSOut& SOut, const TStr& Nm) const;
380    TPt& operator=(const TPt& Pt){
381      if (this!=&Pt){Pt.MkRef(); UnRef(); Addr=Pt.Addr;} return *this;}
382    bool operator==(const TPt& Pt) const {return *Addr==*Pt.Addr;}
383    bool operator!=(const TPt& Pt) const {return *Addr!=*Pt.Addr;}
384    bool operator<(const TPt& Pt) const {return *Addr<*Pt.Addr;}
385    TRec* operator->() const {Assert(Addr!=NULL); return Addr;}
386    TRec& operator*() const {Assert(Addr!=NULL); return *Addr;}
387    TRec& operator[](const int& RecN) const {
388      Assert(Addr!=NULL); return Addr[RecN];}
389    TRec* operator()() const {return Addr;}
390    bool Empty() const { return Addr==NULL;}
391    void Clr(){UnRef(); Addr=NULL;}
392    int GetRefs() const {
393      if (Addr==NULL){return -1;} else {return Addr->CRef.GetRefs();}}
394    int GetPrimHashCd() const {return Addr->GetPrimHashCd();}
395    int GetSecHashCd() const {return Addr->GetSecHashCd();}
396    TPt<TRec> Clone(){return MkClone(*this);}
397  };
398  class TSStr{
399  private:
400    char* Bf;
401  public:
402    TSStr(): Bf(NULL){
403      Bf=new char[0+1]; Bf[0]=0;}
404    TSStr(const TSStr& SStr): Bf(NULL){
405      Bf=new char[strlen(SStr.Bf)+1]; strcpy(Bf, SStr.Bf);}
406    TSStr(const char* _Bf): Bf(NULL){
407      Bf=new char[strlen(_Bf)+1]; strcpy(Bf, _Bf);}
408    ~TSStr(){delete[] Bf;}
409    TSStr& operator=(const TSStr& SStr){
410      if (this!=&SStr){
411        delete[] Bf; Bf=new char[strlen(SStr.Bf)+1]; strcpy(Bf, SStr.Bf);}
412      return *this;}
413    char* CStr() {return Bf;}
414    const char* CStr() const {return Bf;}
415    bool Empty() const {return Bf[0]==0;}
416    int Len() const {return int(strlen(Bf));}
417  };
418  class TConv_Pt64Ints32{
419  private:
420    union{
421      void* Pt;
422      uint64 UInt64;
423      struct {uint Ls; uint Ms;} UInt32;
424    } Val;
425    UndefCopyAssign(TConv_Pt64Ints32);
426  public:
427    TConv_Pt64Ints32(){
428      Val.Pt=0; Val.UInt32.Ms=0; Val.UInt32.Ls=0;}
429    TConv_Pt64Ints32(void* Pt){
430      Val.UInt32.Ms=0; Val.UInt32.Ls=0; Val.Pt=Pt;}
431    TConv_Pt64Ints32(const uint& Ms, const uint& Ls){
432      Val.Pt=0; Val.UInt32.Ms=Ms; Val.UInt32.Ls=Ls;}
433    void PutPt(void* Pt){Val.Pt=Pt;}
434    void* GetPt() const {return Val.Pt;}
435    void PutUInt64(const uint64& _UInt64){Val.UInt64=_UInt64;}
436    uint64 GetUInt64() const {return Val.UInt64;}
437    void PutMsUInt32(const uint& Ms){Val.UInt32.Ms=Ms;}
438    uint GetMsUInt32() const {return Val.UInt32.Ms;}
439    void PutLsUInt32(const uint& Ls){Val.UInt32.Ls=Ls;}
440    uint GetLsUInt32() const {return Val.UInt32.Ls;}
441  };
442  template <class TRec>
443  void Swap(TRec& Rec1, TRec& Rec2){
444    TRec Rec=Rec1; Rec1=Rec2; Rec2=Rec;
445  }
446  class TPairHashImpl1 {
447  public:
448    static inline int GetHashCd(const int hc1, const int hc2) {
449      unsigned long long sum = ((unsigned long long) hc1) + ((unsigned long long) hc2);
450      unsigned long long c = ((sum * (sum + 1)) >> 1) + hc1;
451      return (int) (c % 0x7fffffffULL); }
452  };
453  class TPairHashImpl2 {
454  public:
455    static inline int GetHashCd(const int hc1, const int hc2) {
456      unsigned long long sum = ((unsigned long long) hc1) + ((unsigned long long) hc2);
457      unsigned long long c = ((sum * (sum + 1)) >> 1) + hc1;
458      unsigned int R = (unsigned int) (c >> 31), Q = (unsigned int) (c & 0x7fffffffULL);
459      if ((R & 0x80000000U) != 0) R -= 0x7fffffffU;
460      unsigned int RQ = R + Q;
461      if (RQ < 0x7fffffffU) return (int) RQ;
462      RQ -= 0x7fffffffU;
463      return (RQ == 0x7fffffffU) ? 0 : (int) RQ; }
464  };
465  #if (defined(GLib_64Bit)) && ! (defined(DEBUG) || defined(_DEBUG))
466    typedef TPairHashImpl1 TPairHashImpl;
467  #else
468    typedef TPairHashImpl2 TPairHashImpl;
469  #endif
470  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bd.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bd.h</div>
                </div>
                <div class="column column_space"><pre><code>111    TCRef CRef; \
112  public: \
113    friend class TPt<TNm>;
114  #define ClassTPEE(TNm, PNm, ENm1, ENm2) \
</pre></code></div>
                <div class="column column_space"><pre><code>119    TCRef CRef; \
120  public: \
121    friend class TPt<TNm>;
122  #define ClassTE(TNm, ENm) \
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    