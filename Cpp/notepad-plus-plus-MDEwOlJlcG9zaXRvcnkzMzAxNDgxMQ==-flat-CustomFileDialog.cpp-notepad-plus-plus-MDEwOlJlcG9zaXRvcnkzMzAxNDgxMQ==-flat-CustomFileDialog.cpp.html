
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 38, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CustomFileDialog.cpp</h3>
            <pre><code>1  #include <shobjidl.h>
2  #include <shlwapi.h>	
3  #ifdef __MINGW32__
4  #include <cwchar>
5  #endif
6  #include <comdef.h>		
7  #include <comip.h>		
8  #include <unordered_map>
9  #include "CustomFileDialog.h"
10  #include "Parameters.h"
11  template<class T>
12  struct ComTraits
13  {
14  	static const GUID uid;
15  };
16  template<class T>
17  const GUID ComTraits<T>::uid = __uuidof(T);
18  template<class T, class InterfaceT = T>
19  using com_ptr = _com_ptr_t<_com_IIID<T, &ComTraits<InterfaceT>::uid>>;
20  namespace 
21  {
22  	struct Filter
23  	{
24  		generic_string name;
25  		generic_string ext;
26  	};
27  	static const int IDC_FILE_CUSTOM_CHECKBOX = 4;
28  	static const int IDC_FILE_TYPE_CHECKBOX = IDC_FILE_CUSTOM_CHECKBOX + 1;
29  	generic_string get1stExt(const generic_string& extSpec)
30  	{
31  		size_t pos = extSpec.find('.');
32  		if (pos != generic_string::npos)
33  		{
34  			size_t posEnd = extSpec.find(';', pos + 1);
35  			if (posEnd != generic_string::npos)
36  			{
37  				size_t extLen = posEnd - pos;
38  				return extSpec.substr(pos, extLen);
39  			}
40  			return extSpec.substr(pos);
41  		}
42  		return {};
43  	}
44  	bool replaceExt(generic_string& name, const generic_string& ext)
45  	{
46  		if (!name.empty() && !ext.empty())
47  		{
48  			size_t posNameExt = name.find_last_of('.');
49  			if (posNameExt != generic_string::npos)
50  				name.erase(posNameExt);
51  			name += ext;
52  			return true;
53  		}
54  		return false;
55  	}
56  	bool hasExt(const generic_string& name)
57  	{
58  		return name.find_last_of('.') != generic_string::npos;
59  	}
60  	void expandEnv(generic_string& s)
61  	{
62  		TCHAR buffer[MAX_PATH] = { '\0' };
63  		DWORD ret = ExpandEnvironmentStrings(s.c_str(), buffer, static_cast<DWORD>(std::size(buffer)));
64  		if (ret != 0)
65  		{
66  			if (ret == static_cast<DWORD>(lstrlen(buffer) + 1))
67  			{
68  				s = buffer;
69  			}
70  			else
71  			{
72  				std::vector<TCHAR> buffer2(ret, 0);
73  				ret = ExpandEnvironmentStrings(s.c_str(), buffer2.data(), static_cast<DWORD>(buffer2.size()));
74  				assert(ret == static_cast<DWORD>(lstrlen(buffer2.data()) + 1));
75  				s = buffer2.data();
76  			}
77  		}
78  	}
79  	generic_string getFilename(IShellItem* psi)
80  	{
81  		generic_string result;
82  		if (psi)
83  		{
84  			PWSTR pszFilePath = nullptr;
85  			HRESULT hr = psi->GetDisplayName(SIGDN_FILESYSPATH, &pszFilePath);
86  			if (SUCCEEDED(hr) && pszFilePath)
87  			{
88  				result = pszFilePath;
89  				CoTaskMemFree(pszFilePath);
90  			}
91  		}
92  		return result;
93  	}
94  	bool setDialogFolder(IFileDialog* dialog, const TCHAR* path)
95  	{
96  		com_ptr<IShellItem> shellItem;
97  		HRESULT hr = SHCreateItemFromParsingName(path,
98  			nullptr,
99  			IID_PPV_ARGS(&shellItem));
100  		if (SUCCEEDED(hr) && shellItem && !::PathIsDirectory(path))
101  		{
102  			com_ptr<IShellItem> parentItem;
103  			hr = shellItem->GetParent(&parentItem);
104  			if (SUCCEEDED(hr))
105  				shellItem = parentItem;
106  		}
107  		if (SUCCEEDED(hr))
108  			hr = dialog->SetFolder(shellItem);
109  		return SUCCEEDED(hr);
110  	}
111  	generic_string getDialogFileName(IFileDialog* dialog)
112  	{
113  		generic_string fileName;
114  		if (dialog)
115  		{
116  			PWSTR pszFilePath = nullptr;
117  			HRESULT hr = dialog->GetFileName(&pszFilePath);
118  			if (SUCCEEDED(hr) && pszFilePath)
119  			{
120  				fileName = pszFilePath;
121  				CoTaskMemFree(pszFilePath);
122  			}
123  		}
124  		return fileName;
125  	}
126  	generic_string getDialogFolder(IFileDialog* dialog)
127  	{
128  		com_ptr<IShellItem> psi;
129  		HRESULT hr = dialog->GetFolder(&psi);
130  		if (SUCCEEDED(hr))
131  			return getFilename(psi);
132  		return {};
133  	}
134  	HWND getDialogHandle(IFileDialog* dialog)
135  	{
136  		com_ptr<IOleWindow> pOleWnd = dialog;
137  		if (pOleWnd)
138  		{
139  			HWND hwnd = nullptr;
140  			if (SUCCEEDED(pOleWnd->GetWindow(&hwnd)))
141  				return hwnd;
142  		}
143  		return nullptr;
144  	}
145  	class CurrentDirBackup
146  	{
147  	public:
148  		CurrentDirBackup()
149  		{
150  			::GetCurrentDirectory(MAX_PATH, _dir);
151  		}
152  		~CurrentDirBackup()
153  		{
154  			::SetCurrentDirectory(_dir);
155  		}
156  	private:
157  		TCHAR _dir[MAX_PATH];
158  	};
159  } 
160  class FileDialogEventHandler : public IFileDialogEvents, public IFileDialogControlEvents
161  {
162  public:
163  	IFACEMETHODIMP QueryInterface(REFIID riid, void** ppv) override
164  	{
165  		if (!ppv)
166  			return E_INVALIDARG;
167  		*ppv = nullptr;
168  		if (riid == __uuidof(IUnknown) || riid == __uuidof(IFileDialogEvents))
169  		{
170  			*ppv = static_cast<IFileDialogEvents*>(this);
171  			AddRef();
172  			return NOERROR;
173  		}
174  		else if (riid == __uuidof(IFileDialogControlEvents))
175  		{
176  			*ppv = static_cast<IFileDialogControlEvents*>(this);
177  			AddRef();
178  			return NOERROR;
179  		}
180  		return E_NOINTERFACE;
181  	}
182  	IFACEMETHODIMP_(ULONG) AddRef() override
183  	{
184  		return InterlockedIncrement(&_cRef);
185  	}
186  	IFACEMETHODIMP_(ULONG) Release() override
187  	{
188  		long cRef = InterlockedDecrement(&_cRef);
189  		if (!cRef)
190  			delete this;
191  		return cRef;
192  	}
193  	IFACEMETHODIMP OnFileOk(IFileDialog* dlg) override
194  	{
195  		_lastUsedFolder = getDialogFolder(dlg);
196  		return S_OK;
197  	}
198  	IFACEMETHODIMP OnFolderChange(IFileDialog*) override
199  	{
200  		if (!foundControls())
201  			findControls();
202  		return S_OK;
203  	}
204  	IFACEMETHODIMP OnFolderChanging(IFileDialog*, IShellItem* psi) override
205  	{
206  		_lastUsedFolder = getFilename(psi);
207  		return S_OK;
208  	}
209  	IFACEMETHODIMP OnSelectionChange(IFileDialog*) override
210  	{
211  		if (!foundControls())
212  			findControls();
213  		return S_OK;
214  	}
215  	IFACEMETHODIMP OnShareViolation(IFileDialog*, IShellItem*, FDE_SHAREVIOLATION_RESPONSE*) override
216  	{
217  		return S_OK;
218  	}
219  	IFACEMETHODIMP OnTypeChange(IFileDialog*) override
220  	{
221  		UINT dialogIndex = 0;
222  		if (SUCCEEDED(_dialog->GetFileTypeIndex(&dialogIndex)))
223  		{
224  			if (OnTypeChange(dialogIndex))
225  				_customize->SetCheckButtonState(IDC_FILE_TYPE_CHECKBOX, TRUE);
226  		}
227  		return S_OK;
228  	}
229  	bool OnTypeChange(UINT dialogIndex)
230  	{
231  		if (dialogIndex == 0)
232  			return false;
233  		_currentType = dialogIndex;
234  		generic_string name = getDialogFileName(_dialog);
235  		if (changeExt(name, dialogIndex - 1))
236  		{
237  			DWORD selStart = 0;
238  			DWORD selEnd = 0;
239  			bool ok = SUCCEEDED(_dialog->SetFileName(name.c_str()));
240  			if (ok)
241  				SendMessage(_hwndNameEdit, EM_SETSEL, selStart, selEnd);
242  			return ok;
243  		}
244  		return false;
245  	}
246  	IFACEMETHODIMP OnOverwrite(IFileDialog*, IShellItem*, FDE_OVERWRITE_RESPONSE*) override
247  	{
248  		if (_hwndNameEdit)
249  			SetFocus(_hwndNameEdit);
250  		return S_OK;
251  	}
252  	IFACEMETHODIMP OnItemSelected(IFileDialogCustomize*, DWORD, DWORD) override
253  	{
254  		return E_NOTIMPL;
255  	}
256  	IFACEMETHODIMP OnButtonClicked(IFileDialogCustomize*, DWORD) override
257  	{
258  		return E_NOTIMPL;
259  	}
260  	IFACEMETHODIMP OnCheckButtonToggled(IFileDialogCustomize*, DWORD id, BOOL bChecked) override
261  	{
262  		if (id == IDC_FILE_TYPE_CHECKBOX)
263  		{
264  			UINT newFileType = 0;
265  			if (bChecked)
266  			{
267  				newFileType = _lastSelectedType;
268  			}
269  			else
270  			{
271  				if (_currentType != 0 && _currentType != _wildcardType)
272  					_lastSelectedType = _currentType;
273  				newFileType = _wildcardType;
274  			}
275  			_dialog->SetFileTypeIndex(newFileType);
276  			OnTypeChange(newFileType);
277  			return S_OK;
278  		}
279  		return E_NOTIMPL;
280  	}
281  	IFACEMETHODIMP OnControlActivating(IFileDialogCustomize*, DWORD) override
282  	{
283  		return E_NOTIMPL;
284  	}
285  	FileDialogEventHandler(IFileDialog* dlg, const std::vector<Filter>& filterSpec, int fileIndex, int wildcardIndex)
286  		: _cRef(1), _dialog(dlg), _customize(dlg), _filterSpec(filterSpec), _currentType(fileIndex + 1),
287  		_lastSelectedType(fileIndex + 1), _wildcardType(wildcardIndex >= 0 ? wildcardIndex + 1 : 0)
288  	{
289  		installHooks();
290  	}
291  	~FileDialogEventHandler()
292  	{
293  		eraseHandles();
294  		removeHooks();
295  	}
296  	const generic_string& getLastUsedFolder() const { return _lastUsedFolder; }
297  private:
298  	FileDialogEventHandler(const FileDialogEventHandler&) = delete;
299  	FileDialogEventHandler& operator=(const FileDialogEventHandler&) = delete;
300  	FileDialogEventHandler(FileDialogEventHandler&&) = delete;
301  	FileDialogEventHandler& operator=(FileDialogEventHandler&&) = delete;
302  	bool findControls()
303  	{
304  		assert(_dialog);
305  		HWND hwndDlg = getDialogHandle(_dialog);
306  		if (hwndDlg)
307  		{
308  			EnumChildWindows(hwndDlg, &EnumChildProc, reinterpret_cast<LPARAM>(this));
309  			if (_hwndButton)
310  				s_handleMap[_hwndButton] = this;
311  			if (_hwndNameEdit)
312  				s_handleMap[_hwndNameEdit] = this;
313  		}
314  		return foundControls();
315  	}
316  	bool foundControls() const
317  	{
318  		return _hwndButton && _hwndNameEdit;
319  	}
320  	void installHooks()
321  	{
322  		_prevKbdHook = ::SetWindowsHookEx(WH_KEYBOARD,
323  			reinterpret_cast<HOOKPROC>(&FileDialogEventHandler::KbdProcHook),
324  			nullptr,
325  			::GetCurrentThreadId()
326  		);
327  		_prevCallHook = ::SetWindowsHookEx(WH_CALLWNDPROC,
328  			reinterpret_cast<HOOKPROC>(&FileDialogEventHandler::CallProcHook),
329  			nullptr,
330  			::GetCurrentThreadId()
331  		);
332  	}
333  	void removeHooks()
334  	{
335  		if (_prevKbdHook)
336  			::UnhookWindowsHookEx(_prevKbdHook);
337  		if (_prevCallHook)
338  			::UnhookWindowsHookEx(_prevCallHook);
339  		_prevKbdHook = nullptr;
340  		_prevCallHook = nullptr;
341  	}
342  	void eraseHandles()
343  	{
344  		if (_hwndButton && _hwndNameEdit)
345  		{
346  			s_handleMap.erase(_hwndButton);
347  			s_handleMap.erase(_hwndNameEdit);
348  		}
349  		else
350  		{
351  			std::vector<HWND> handlesToErase;
352  			for (auto&& x : s_handleMap)
353  			{
354  				if (x.second == this)
355  					handlesToErase.push_back(x.first);
356  			}
357  			for (auto&& h : handlesToErase)
358  			{
359  				s_handleMap.erase(h);
360  			}
361  		}
362  	}
363  	bool changeExt(generic_string& name, int extIndex)
364  	{
365  		if (extIndex >= 0 && extIndex < static_cast<int>(_filterSpec.size()))
366  		{
367  			const generic_string ext = get1stExt(_filterSpec[extIndex].ext);
368  			if (!ext.ends_with(_T(".*")))
369  				return replaceExt(name, ext);
370  		}
371  		return false;
372  	}
373  	generic_string getAbsPath(const generic_string& fileName)
374  	{
375  		if (::PathIsRelative(fileName.c_str()))
376  		{
377  			TCHAR buffer[MAX_PATH] = { '\0' };
378  			const generic_string folder = getDialogFolder(_dialog);
379  			LPTSTR ret = ::PathCombine(buffer, folder.c_str(), fileName.c_str());
380  			if (ret)
381  				return buffer;
382  		}
383  		return fileName;
384  	}
385  	void onPreFileOk()
386  	{
387  		if (!_dialog)
388  			return;
389  		generic_string fileName = getDialogFileName(_dialog);
390  		expandEnv(fileName);
391  		bool nameChanged = transformPath(fileName);
392  		if (!::PathIsDirectory(getAbsPath(fileName).c_str()))
393  		{
394  			if (!hasExt(fileName))
395  				nameChanged |= changeExt(fileName, _currentType - 1);
396  		}
397  		if (nameChanged)
398  		{
399  			_dialog->SetFileName(_T(""));
400  			_dialog->SetFileName(fileName.c_str());
401  		}
402  	}
403  	static bool transformPath(generic_string& fileName)
404  	{
405  		if (fileName.empty())
406  			return false;
407  		bool transformed = false;
408  		std::replace_if(fileName.begin(), fileName.end(),
409  			[&transformed](generic_string::value_type c)
410  			{
411  				const bool eq = (c == '/');
412  				transformed |= eq;
413  				return eq;
414  			},
415  			'\\');
416  		return transformed;
417  	}
418  	static BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM param)
419  	{
420  		const int bufferLen = MAX_PATH;
421  		static TCHAR buffer[bufferLen];
422  		static bool isRTL = false;
423  		auto* inst = reinterpret_cast<FileDialogEventHandler*>(param);
424  		if (!inst)
425  			return FALSE;
426  		if (IsWindowEnabled(hwnd) && GetClassName(hwnd, buffer, bufferLen) != 0)
427  		{
428  			if (lstrcmpi(buffer, _T("ComboBox")) == 0)
429  			{
430  				HWND hwndChild = FindWindowEx(hwnd, nullptr, _T("Edit"), _T(""));
431  				if (hwndChild && !inst->_hwndNameEdit)
432  				{
433  					inst->_hwndNameEdit = hwndChild;
434  				}
435  			}
436  			else if (lstrcmpi(buffer, _T("Button")) == 0)
437  			{
438  				LONG style = GetWindowLong(hwnd, GWL_STYLE);
439  				if (style & (WS_CHILDWINDOW | WS_GROUP))
440  				{
441  					DWORD type = style & 0xF;
442  					DWORD appearance = style & 0xF0;
443  					if ((type == BS_PUSHBUTTON || type == BS_DEFPUSHBUTTON) && (appearance == BS_TEXT))
444  					{
445  						if (inst->_hwndButton)
446  						{
447  							RECT rc1 = {};
448  							RECT rc2 = {};
449  							if (GetWindowRect(hwnd, &rc1) && GetWindowRect(inst->_hwndButton, &rc2))
450  							{
451  								const bool isLess = isRTL ? (rc1.right > rc2.right) : (rc1.left < rc2.left);
452  								if (isLess)
453  									inst->_hwndButton = hwnd;
454  							}
455  						}
456  						else
457  						{
458  							isRTL = GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL;
459  							inst->_hwndButton = hwnd;
460  						}
461  					}
462  				}
463  			}
464  		}
465  		return TRUE;
466  	}
467  	static LRESULT CALLBACK CallProcHook(int nCode, WPARAM wParam, LPARAM lParam)
468  	{
469  		if (nCode == HC_ACTION)
470  		{
471  			auto* msg = reinterpret_cast<CWPSTRUCT*>(lParam);
472  			if (msg && msg->message == WM_COMMAND && HIWORD(msg->wParam) == BN_CLICKED)
473  			{
474  				auto ctrlId = LOWORD(msg->wParam);
475  				HWND hwnd = GetDlgItem(msg->hwnd, ctrlId);
476  				auto it = s_handleMap.find(hwnd);
477  				if (it != s_handleMap.end() && it->second && hwnd == it->second->_hwndButton)
478  					it->second->onPreFileOk();
479  			}
480  		}
481  		return ::CallNextHookEx(nullptr, nCode, wParam, lParam);
482  	}
483  	static LRESULT CALLBACK KbdProcHook(int nCode, WPARAM wParam, LPARAM lParam)
484  	{
485  		if (nCode == HC_ACTION)
486  		{
487  			if (wParam == VK_RETURN)
488  			{
489  				HWND hwnd = GetFocus();
490  				auto it = s_handleMap.find(hwnd);
491  				if (it != s_handleMap.end() && it->second && hwnd == it->second->_hwndNameEdit)
492  					it->second->onPreFileOk();
493  			}
494  		}
495  		return ::CallNextHookEx(nullptr, nCode, wParam, lParam);
496  	}
497  	static std::unordered_map<HWND, FileDialogEventHandler*> s_handleMap;
498  	long _cRef;
499  	com_ptr<IFileDialog> _dialog;
500  	com_ptr<IFileDialogCustomize> _customize;
501  	const std::vector<Filter> _filterSpec;
502  	generic_string _lastUsedFolder;
503  	HHOOK _prevKbdHook = nullptr;
504  	HHOOK _prevCallHook = nullptr;
505  	HWND _hwndNameEdit = nullptr;
506  	HWND _hwndButton = nullptr;
507  	UINT _currentType = 0;  
508  	UINT _lastSelectedType = 0;  
509  	UINT _wildcardType = 0;  
510  };
511  std::unordered_map<HWND, FileDialogEventHandler*> FileDialogEventHandler::s_handleMap;
512  class CustomFileDialog::Impl
513  {
514  public:
515  	Impl() = default;
516  	~Impl() = default;
517  	bool init(CLSID id)
518  	{
519  		if (_dialog)
520  			return false; 
521  		if (_fileTypeIndex >= static_cast<int>(_filterSpec.size()))
522  			_fileTypeIndex = 0;
523  		HRESULT hr = CoCreateInstance(id,
524  			NULL,
525  			CLSCTX_INPROC_SERVER,
526  			IID_PPV_ARGS(&_dialog));
527  		_customize = _dialog;
528  		if (SUCCEEDED(hr))
529  			_events.Attach(new FileDialogEventHandler(_dialog, _filterSpec, _fileTypeIndex, _wildcardIndex));
530  		if (_enableFileTypeCheckbox && !_fileTypeCheckboxValue && _wildcardIndex >= 0)
531  			_fileTypeIndex = _wildcardIndex;
532  		if (SUCCEEDED(hr) && _title)
533  			hr = _dialog->SetTitle(_title);
534  		if (SUCCEEDED(hr))
535  		{
536  			bool isFolderSet = false;
537  			if (!_initialFolder.empty())
538  				isFolderSet = setDialogFolder(_dialog, _initialFolder.c_str());
539  			if (!isFolderSet && !_fallbackFolder.empty())
540  				isFolderSet = setDialogFolder(_dialog, _fallbackFolder.c_str());
541  		}
542  		if (SUCCEEDED(hr) && _defExt && _defExt[0] != '\0')
543  			hr = _dialog->SetDefaultExtension(_defExt);
544  		if (SUCCEEDED(hr) && _initialFileName)
545  		{
546  			generic_string newFileName = _initialFileName;
547  			if (_fileTypeIndex >= 0 && _fileTypeIndex < static_cast<int>(_filterSpec.size()))
548  			{
549  				if (!hasExt(newFileName))
550  				{
551  					const generic_string ext = get1stExt(_filterSpec[_fileTypeIndex].ext);
552  					if (!ext.ends_with(_T(".*")))
553  						newFileName += ext;
554  				}
555  			}
556  			hr = _dialog->SetFileName(newFileName.c_str());
557  		}
558  		if (SUCCEEDED(hr) && !_filterSpec.empty())
559  		{
560  			std::vector<COMDLG_FILTERSPEC> fileTypes;
561  			fileTypes.reserve(_filterSpec.size());
562  			for (auto&& filter : _filterSpec)
563  				fileTypes.push_back({ filter.name.data(), filter.ext.data() });
564  			hr = _dialog->SetFileTypes(static_cast<UINT>(fileTypes.size()), fileTypes.data());
565  		}
566  		if (SUCCEEDED(hr) && _fileTypeIndex >= 0)
567  			hr = _dialog->SetFileTypeIndex(_fileTypeIndex + 1); 
568  		if (_enableFileTypeCheckbox)
569  			addCheckbox(IDC_FILE_TYPE_CHECKBOX, _fileTypeCheckboxLabel.c_str(), _fileTypeCheckboxValue);
570  		if (SUCCEEDED(hr))
571  			return addControls();
572  		return false;
573  	}
574  	bool initSave()
575  	{
576  		return init(CLSID_FileSaveDialog);
577  	}
578  	bool initOpen()
579  	{
580  		return init(CLSID_FileOpenDialog);
581  	}
582  	bool addFlags(DWORD dwNewFlags)
583  	{
584  		DWORD dwOldFlags = 0;
585  		HRESULT hr = _dialog->GetOptions(&dwOldFlags);
586  		if (SUCCEEDED(hr))
587  			hr = _dialog->SetOptions(dwOldFlags | dwNewFlags);
588  		return SUCCEEDED(hr);
589  	}
590  	bool addControls()
591  	{
592  		if (!_customize)
593  			return false;
594  		if (_checkboxLabel && _checkboxLabel[0] != '\0')
595  		{
596  			return addCheckbox(IDC_FILE_CUSTOM_CHECKBOX, _checkboxLabel, false, _isCheckboxActive);
597  		}
598  		return true;
599  	}
600  	bool addCheckbox(int id, const TCHAR* label, bool value, bool enabled = true)
601  	{
602  		if (!_customize)
603  			return false;
604  		HRESULT hr = _customize->AddCheckButton(id, label, value ? TRUE : FALSE);
605  		if (SUCCEEDED(hr) && !enabled)
606  		{
607  			hr = _customize->SetControlState(id, CDCS_INACTIVE | CDCS_VISIBLE);
608  			return SUCCEEDED(hr);
609  		}
610  		return SUCCEEDED(hr);
611  	}
612  	bool show()
613  	{
614  		static bool isActive = false;
615  		if (isActive)
616  			return false;
617  		assert(_dialog);
618  		if (!_dialog)
619  			return false;
620  		isActive = true;
621  		HRESULT hr = S_OK;
622  		DWORD dwCookie = 0;
623  		com_ptr<IFileDialogEvents> dialogEvents = _events;
624  		if (dialogEvents)
625  		{
626  			hr = _dialog->Advise(dialogEvents, &dwCookie);
627  			if (FAILED(hr))
628  				dialogEvents.Release();
629  		}
630  		bool okPressed = false;
631  		if (SUCCEEDED(hr))
632  		{
633  			hr = _dialog->Show(_hwndOwner);
634  			okPressed = SUCCEEDED(hr);
635  			NppParameters& params = NppParameters::getInstance();
636  			if (okPressed && params.getNppGUI()._openSaveDir == dir_last)
637  			{
638  				params.setWorkingDir(_events->getLastUsedFolder().c_str());
639  			}
640  		}
641  		if (dialogEvents)
642  			_dialog->Unadvise(dwCookie);
643  		isActive = false;
644  		return okPressed;
645  	}
646  	BOOL getCheckboxState(int id) const
647  	{
648  		if (_customize)
649  		{
650  			BOOL bChecked = FALSE;
651  			HRESULT hr = _customize->GetCheckButtonState(id, &bChecked);
652  			if (SUCCEEDED(hr))
653  				return bChecked;
654  		}
655  		return FALSE;
656  	}
657  	generic_string getResultFilename()
658  	{
659  		generic_string fileName;
660  		com_ptr<IShellItem> psiResult;
661  		HRESULT hr = _dialog->GetResult(&psiResult);
662  		if (SUCCEEDED(hr))
663  		{
664  			fileName = getFilename(psiResult);
665  			_hasReadonly = hasReadonlyAttr(psiResult);
666  		}
667  		return fileName;
668  	}
669  	static bool hasReadonlyAttr(IShellItem* psi)
670  	{
671  		SFGAOF attrs = 0;
672  		HRESULT hr = psi->GetAttributes(SFGAO_READONLY, &attrs);
673  		if (SUCCEEDED(hr))
674  			return attrs & SFGAO_READONLY;
675  		return false;
676  	}
677  	std::vector<generic_string> getFilenames()
678  	{
679  		std::vector<generic_string> result;
680  		com_ptr<IFileOpenDialog> pfd = _dialog;
681  		if (pfd)
682  		{
683  			com_ptr<IShellItemArray> psiaResults;
684  			HRESULT hr = pfd->GetResults(&psiaResults);
685  			if (SUCCEEDED(hr))
686  			{
687  				DWORD count = 0;
688  				hr = psiaResults->GetCount(&count);
689  				if (SUCCEEDED(hr))
690  				{
691  					for (DWORD i = 0; i != count; ++i)
692  					{
693  						com_ptr<IShellItem> psi;
694  						hr = psiaResults->GetItemAt(i, &psi);
695  						if (SUCCEEDED(hr))
696  						{
697  							_hasReadonly |= hasReadonlyAttr(psi);
698  							result.push_back(getFilename(psi));
699  						}
700  					}
701  				}
702  			}
703  		}
704  		return result;
705  	}
706  	HWND _hwndOwner = nullptr;
707  	const TCHAR* _title = nullptr;
708  	const TCHAR* _defExt = nullptr;
709  	generic_string _initialFolder;
710  	generic_string _fallbackFolder;
711  	const TCHAR* _checkboxLabel = nullptr;
712  	const TCHAR* _initialFileName = nullptr;
713  	bool _isCheckboxActive = true;
714  	std::vector<Filter> _filterSpec;
715  	int _fileTypeIndex = -1;	
716  	int _wildcardIndex = -1;	
717  	bool _hasReadonly = false;	
718  	bool _enableFileTypeCheckbox = false;
719  	bool _fileTypeCheckboxValue = false;	
720  	generic_string _fileTypeCheckboxLabel;
721  private:
722  	com_ptr<IFileDialog> _dialog;
723  	com_ptr<IFileDialogCustomize> _customize;
724  	com_ptr<FileDialogEventHandler, IFileDialogEvents> _events;
725  };
726  CustomFileDialog::CustomFileDialog(HWND hwnd) : _impl{ std::make_unique<Impl>() }
727  {
728  	_impl->_hwndOwner = hwnd;
729  	NppParameters& params = NppParameters::getInstance();
730  	const TCHAR* workDir = params.getWorkingDir();
731  	if (workDir)
732  		_impl->_fallbackFolder = workDir;
733  }
734  CustomFileDialog::~CustomFileDialog() = default;
735  void CustomFileDialog::setTitle(const TCHAR* title)
736  {
737  	_impl->_title = title;
738  }
739  void CustomFileDialog::setExtFilter(const TCHAR *extText, const TCHAR *exts)
740  {
741  	generic_string newExts{ exts ? exts : _T("") };
742  	for (size_t pos = 0; pos < newExts.size(); ++pos)
743  	{
744  		pos = newExts.find(_T('.'), pos);
745  		if (pos == generic_string::npos)
746  			break;
747  		if (pos == 0 || newExts[pos - 1] != _T('*'))
748  		{
749  			newExts.insert(pos, 1, _T('*'));
750  			++pos;
751  		}
752  	}
753  	if (newExts.find(_T("*.*")) == 0)
754  		_impl->_wildcardIndex = static_cast<int>(_impl->_filterSpec.size());
755  	_impl->_filterSpec.push_back({ extText, newExts });
756  }
757  void CustomFileDialog::setExtFilter(const TCHAR *extText, std::initializer_list<const TCHAR*> extList)
758  {
759  	generic_string exts;
760  	for (auto&& x : extList)
761  	{
762  		exts += x;
763  		exts += _T(';');
764  	}
765  	exts.pop_back();	
766  	setExtFilter(extText, exts.c_str());
767  }
768  void CustomFileDialog::setDefExt(const TCHAR* ext)
769  {
770  	_impl->_defExt = ext;
771  }
772  void CustomFileDialog::setDefFileName(const TCHAR* fn)
773  {
774  	_impl->_initialFileName = fn;
775  }
776  void CustomFileDialog::setFolder(const TCHAR* folder)
777  {
778  	_impl->_initialFolder = folder ? folder : _T("");
779  }
780  void CustomFileDialog::setCheckbox(const TCHAR* text, bool isActive)
781  {
782  	_impl->_checkboxLabel = text;
783  	_impl->_isCheckboxActive = isActive;
784  }
785  void CustomFileDialog::setExtIndex(int extTypeIndex)
786  {
787  	_impl->_fileTypeIndex = extTypeIndex;
788  }
789  bool CustomFileDialog::getCheckboxState() const
790  {
791  	return _impl->getCheckboxState(IDC_FILE_CUSTOM_CHECKBOX);
792  }
793  bool CustomFileDialog::isReadOnly() const
794  {
795  	return _impl->_hasReadonly;
796  }
797  void CustomFileDialog::enableFileTypeCheckbox(const generic_string& text, bool value)
798  {
799  	assert(!text.empty());
800  	if (!text.empty())
801  	{
802  		_impl->_fileTypeCheckboxLabel = text;
803  		_impl->_enableFileTypeCheckbox = true;
804  		_impl->_fileTypeCheckboxValue = value;
805  	}
806  }
807  bool CustomFileDialog::getFileTypeCheckboxValue() const
808  {
809  	return _impl->getCheckboxState(IDC_FILE_TYPE_CHECKBOX);
810  }
811  generic_string CustomFileDialog::doSaveDlg()
812  {
813  	if (!_impl->initSave())
814  		return {};
815  	CurrentDirBackup backup;
816  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM);
817  	bool bOk = _impl->show();
818  	return bOk ? _impl->getResultFilename() : _T("");
819  }
820  generic_string CustomFileDialog::doOpenSingleFileDlg()
821  {
822  	if (!_impl->initOpen())
823  		return {};
<span onclick='openModal()' class='match'>824  	CurrentDirBackup backup;
825  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM);
826  	bool bOk = _impl->show();
827  	return bOk ? _impl->getResultFilename() : _T("");
828  }
829  std::vector<generic_string> CustomFileDialog::doOpenMultiFilesDlg()
</span>830  {
831  	if (!_impl->initOpen())
832  		return {};
833  	CurrentDirBackup backup;
834  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM | FOS_ALLOWMULTISELECT);
835  	bool bOk = _impl->show();
836  	if (bOk)
837  		return _impl->getFilenames();
838  	return {};
839  }
840  generic_string CustomFileDialog::pickFolder()
841  {
842  	if (!_impl->initOpen())
843  		return {};
844  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM | FOS_PICKFOLDERS);
845  	bool bOk = _impl->show();
846  	return bOk ? _impl->getResultFilename() : _T("");
847  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CustomFileDialog.cpp</h3>
            <pre><code>1  #include <shobjidl.h>
2  #include <shlwapi.h>	
3  #ifdef __MINGW32__
4  #include <cwchar>
5  #endif
6  #include <comdef.h>		
7  #include <comip.h>		
8  #include <unordered_map>
9  #include "CustomFileDialog.h"
10  #include "Parameters.h"
11  template<class T>
12  struct ComTraits
13  {
14  	static const GUID uid;
15  };
16  template<class T>
17  const GUID ComTraits<T>::uid = __uuidof(T);
18  template<class T, class InterfaceT = T>
19  using com_ptr = _com_ptr_t<_com_IIID<T, &ComTraits<InterfaceT>::uid>>;
20  namespace 
21  {
22  	struct Filter
23  	{
24  		generic_string name;
25  		generic_string ext;
26  	};
27  	static const int IDC_FILE_CUSTOM_CHECKBOX = 4;
28  	static const int IDC_FILE_TYPE_CHECKBOX = IDC_FILE_CUSTOM_CHECKBOX + 1;
29  	generic_string get1stExt(const generic_string& extSpec)
30  	{
31  		size_t pos = extSpec.find('.');
32  		if (pos != generic_string::npos)
33  		{
34  			size_t posEnd = extSpec.find(';', pos + 1);
35  			if (posEnd != generic_string::npos)
36  			{
37  				size_t extLen = posEnd - pos;
38  				return extSpec.substr(pos, extLen);
39  			}
40  			return extSpec.substr(pos);
41  		}
42  		return {};
43  	}
44  	bool replaceExt(generic_string& name, const generic_string& ext)
45  	{
46  		if (!name.empty() && !ext.empty())
47  		{
48  			size_t posNameExt = name.find_last_of('.');
49  			if (posNameExt != generic_string::npos)
50  				name.erase(posNameExt);
51  			name += ext;
52  			return true;
53  		}
54  		return false;
55  	}
56  	bool hasExt(const generic_string& name)
57  	{
58  		return name.find_last_of('.') != generic_string::npos;
59  	}
60  	void expandEnv(generic_string& s)
61  	{
62  		TCHAR buffer[MAX_PATH] = { '\0' };
63  		DWORD ret = ExpandEnvironmentStrings(s.c_str(), buffer, static_cast<DWORD>(std::size(buffer)));
64  		if (ret != 0)
65  		{
66  			if (ret == static_cast<DWORD>(lstrlen(buffer) + 1))
67  			{
68  				s = buffer;
69  			}
70  			else
71  			{
72  				std::vector<TCHAR> buffer2(ret, 0);
73  				ret = ExpandEnvironmentStrings(s.c_str(), buffer2.data(), static_cast<DWORD>(buffer2.size()));
74  				assert(ret == static_cast<DWORD>(lstrlen(buffer2.data()) + 1));
75  				s = buffer2.data();
76  			}
77  		}
78  	}
79  	generic_string getFilename(IShellItem* psi)
80  	{
81  		generic_string result;
82  		if (psi)
83  		{
84  			PWSTR pszFilePath = nullptr;
85  			HRESULT hr = psi->GetDisplayName(SIGDN_FILESYSPATH, &pszFilePath);
86  			if (SUCCEEDED(hr) && pszFilePath)
87  			{
88  				result = pszFilePath;
89  				CoTaskMemFree(pszFilePath);
90  			}
91  		}
92  		return result;
93  	}
94  	bool setDialogFolder(IFileDialog* dialog, const TCHAR* path)
95  	{
96  		com_ptr<IShellItem> shellItem;
97  		HRESULT hr = SHCreateItemFromParsingName(path,
98  			nullptr,
99  			IID_PPV_ARGS(&shellItem));
100  		if (SUCCEEDED(hr) && shellItem && !::PathIsDirectory(path))
101  		{
102  			com_ptr<IShellItem> parentItem;
103  			hr = shellItem->GetParent(&parentItem);
104  			if (SUCCEEDED(hr))
105  				shellItem = parentItem;
106  		}
107  		if (SUCCEEDED(hr))
108  			hr = dialog->SetFolder(shellItem);
109  		return SUCCEEDED(hr);
110  	}
111  	generic_string getDialogFileName(IFileDialog* dialog)
112  	{
113  		generic_string fileName;
114  		if (dialog)
115  		{
116  			PWSTR pszFilePath = nullptr;
117  			HRESULT hr = dialog->GetFileName(&pszFilePath);
118  			if (SUCCEEDED(hr) && pszFilePath)
119  			{
120  				fileName = pszFilePath;
121  				CoTaskMemFree(pszFilePath);
122  			}
123  		}
124  		return fileName;
125  	}
126  	generic_string getDialogFolder(IFileDialog* dialog)
127  	{
128  		com_ptr<IShellItem> psi;
129  		HRESULT hr = dialog->GetFolder(&psi);
130  		if (SUCCEEDED(hr))
131  			return getFilename(psi);
132  		return {};
133  	}
134  	HWND getDialogHandle(IFileDialog* dialog)
135  	{
136  		com_ptr<IOleWindow> pOleWnd = dialog;
137  		if (pOleWnd)
138  		{
139  			HWND hwnd = nullptr;
140  			if (SUCCEEDED(pOleWnd->GetWindow(&hwnd)))
141  				return hwnd;
142  		}
143  		return nullptr;
144  	}
145  	class CurrentDirBackup
146  	{
147  	public:
148  		CurrentDirBackup()
149  		{
150  			::GetCurrentDirectory(MAX_PATH, _dir);
151  		}
152  		~CurrentDirBackup()
153  		{
154  			::SetCurrentDirectory(_dir);
155  		}
156  	private:
157  		TCHAR _dir[MAX_PATH];
158  	};
159  } 
160  class FileDialogEventHandler : public IFileDialogEvents, public IFileDialogControlEvents
161  {
162  public:
163  	IFACEMETHODIMP QueryInterface(REFIID riid, void** ppv) override
164  	{
165  		if (!ppv)
166  			return E_INVALIDARG;
167  		*ppv = nullptr;
168  		if (riid == __uuidof(IUnknown) || riid == __uuidof(IFileDialogEvents))
169  		{
170  			*ppv = static_cast<IFileDialogEvents*>(this);
171  			AddRef();
172  			return NOERROR;
173  		}
174  		else if (riid == __uuidof(IFileDialogControlEvents))
175  		{
176  			*ppv = static_cast<IFileDialogControlEvents*>(this);
177  			AddRef();
178  			return NOERROR;
179  		}
180  		return E_NOINTERFACE;
181  	}
182  	IFACEMETHODIMP_(ULONG) AddRef() override
183  	{
184  		return InterlockedIncrement(&_cRef);
185  	}
186  	IFACEMETHODIMP_(ULONG) Release() override
187  	{
188  		long cRef = InterlockedDecrement(&_cRef);
189  		if (!cRef)
190  			delete this;
191  		return cRef;
192  	}
193  	IFACEMETHODIMP OnFileOk(IFileDialog* dlg) override
194  	{
195  		_lastUsedFolder = getDialogFolder(dlg);
196  		return S_OK;
197  	}
198  	IFACEMETHODIMP OnFolderChange(IFileDialog*) override
199  	{
200  		if (!foundControls())
201  			findControls();
202  		return S_OK;
203  	}
204  	IFACEMETHODIMP OnFolderChanging(IFileDialog*, IShellItem* psi) override
205  	{
206  		_lastUsedFolder = getFilename(psi);
207  		return S_OK;
208  	}
209  	IFACEMETHODIMP OnSelectionChange(IFileDialog*) override
210  	{
211  		if (!foundControls())
212  			findControls();
213  		return S_OK;
214  	}
215  	IFACEMETHODIMP OnShareViolation(IFileDialog*, IShellItem*, FDE_SHAREVIOLATION_RESPONSE*) override
216  	{
217  		return S_OK;
218  	}
219  	IFACEMETHODIMP OnTypeChange(IFileDialog*) override
220  	{
221  		UINT dialogIndex = 0;
222  		if (SUCCEEDED(_dialog->GetFileTypeIndex(&dialogIndex)))
223  		{
224  			if (OnTypeChange(dialogIndex))
225  				_customize->SetCheckButtonState(IDC_FILE_TYPE_CHECKBOX, TRUE);
226  		}
227  		return S_OK;
228  	}
229  	bool OnTypeChange(UINT dialogIndex)
230  	{
231  		if (dialogIndex == 0)
232  			return false;
233  		_currentType = dialogIndex;
234  		generic_string name = getDialogFileName(_dialog);
235  		if (changeExt(name, dialogIndex - 1))
236  		{
237  			DWORD selStart = 0;
238  			DWORD selEnd = 0;
239  			bool ok = SUCCEEDED(_dialog->SetFileName(name.c_str()));
240  			if (ok)
241  				SendMessage(_hwndNameEdit, EM_SETSEL, selStart, selEnd);
242  			return ok;
243  		}
244  		return false;
245  	}
246  	IFACEMETHODIMP OnOverwrite(IFileDialog*, IShellItem*, FDE_OVERWRITE_RESPONSE*) override
247  	{
248  		if (_hwndNameEdit)
249  			SetFocus(_hwndNameEdit);
250  		return S_OK;
251  	}
252  	IFACEMETHODIMP OnItemSelected(IFileDialogCustomize*, DWORD, DWORD) override
253  	{
254  		return E_NOTIMPL;
255  	}
256  	IFACEMETHODIMP OnButtonClicked(IFileDialogCustomize*, DWORD) override
257  	{
258  		return E_NOTIMPL;
259  	}
260  	IFACEMETHODIMP OnCheckButtonToggled(IFileDialogCustomize*, DWORD id, BOOL bChecked) override
261  	{
262  		if (id == IDC_FILE_TYPE_CHECKBOX)
263  		{
264  			UINT newFileType = 0;
265  			if (bChecked)
266  			{
267  				newFileType = _lastSelectedType;
268  			}
269  			else
270  			{
271  				if (_currentType != 0 && _currentType != _wildcardType)
272  					_lastSelectedType = _currentType;
273  				newFileType = _wildcardType;
274  			}
275  			_dialog->SetFileTypeIndex(newFileType);
276  			OnTypeChange(newFileType);
277  			return S_OK;
278  		}
279  		return E_NOTIMPL;
280  	}
281  	IFACEMETHODIMP OnControlActivating(IFileDialogCustomize*, DWORD) override
282  	{
283  		return E_NOTIMPL;
284  	}
285  	FileDialogEventHandler(IFileDialog* dlg, const std::vector<Filter>& filterSpec, int fileIndex, int wildcardIndex)
286  		: _cRef(1), _dialog(dlg), _customize(dlg), _filterSpec(filterSpec), _currentType(fileIndex + 1),
287  		_lastSelectedType(fileIndex + 1), _wildcardType(wildcardIndex >= 0 ? wildcardIndex + 1 : 0)
288  	{
289  		installHooks();
290  	}
291  	~FileDialogEventHandler()
292  	{
293  		eraseHandles();
294  		removeHooks();
295  	}
296  	const generic_string& getLastUsedFolder() const { return _lastUsedFolder; }
297  private:
298  	FileDialogEventHandler(const FileDialogEventHandler&) = delete;
299  	FileDialogEventHandler& operator=(const FileDialogEventHandler&) = delete;
300  	FileDialogEventHandler(FileDialogEventHandler&&) = delete;
301  	FileDialogEventHandler& operator=(FileDialogEventHandler&&) = delete;
302  	bool findControls()
303  	{
304  		assert(_dialog);
305  		HWND hwndDlg = getDialogHandle(_dialog);
306  		if (hwndDlg)
307  		{
308  			EnumChildWindows(hwndDlg, &EnumChildProc, reinterpret_cast<LPARAM>(this));
309  			if (_hwndButton)
310  				s_handleMap[_hwndButton] = this;
311  			if (_hwndNameEdit)
312  				s_handleMap[_hwndNameEdit] = this;
313  		}
314  		return foundControls();
315  	}
316  	bool foundControls() const
317  	{
318  		return _hwndButton && _hwndNameEdit;
319  	}
320  	void installHooks()
321  	{
322  		_prevKbdHook = ::SetWindowsHookEx(WH_KEYBOARD,
323  			reinterpret_cast<HOOKPROC>(&FileDialogEventHandler::KbdProcHook),
324  			nullptr,
325  			::GetCurrentThreadId()
326  		);
327  		_prevCallHook = ::SetWindowsHookEx(WH_CALLWNDPROC,
328  			reinterpret_cast<HOOKPROC>(&FileDialogEventHandler::CallProcHook),
329  			nullptr,
330  			::GetCurrentThreadId()
331  		);
332  	}
333  	void removeHooks()
334  	{
335  		if (_prevKbdHook)
336  			::UnhookWindowsHookEx(_prevKbdHook);
337  		if (_prevCallHook)
338  			::UnhookWindowsHookEx(_prevCallHook);
339  		_prevKbdHook = nullptr;
340  		_prevCallHook = nullptr;
341  	}
342  	void eraseHandles()
343  	{
344  		if (_hwndButton && _hwndNameEdit)
345  		{
346  			s_handleMap.erase(_hwndButton);
347  			s_handleMap.erase(_hwndNameEdit);
348  		}
349  		else
350  		{
351  			std::vector<HWND> handlesToErase;
352  			for (auto&& x : s_handleMap)
353  			{
354  				if (x.second == this)
355  					handlesToErase.push_back(x.first);
356  			}
357  			for (auto&& h : handlesToErase)
358  			{
359  				s_handleMap.erase(h);
360  			}
361  		}
362  	}
363  	bool changeExt(generic_string& name, int extIndex)
364  	{
365  		if (extIndex >= 0 && extIndex < static_cast<int>(_filterSpec.size()))
366  		{
367  			const generic_string ext = get1stExt(_filterSpec[extIndex].ext);
368  			if (!ext.ends_with(_T(".*")))
369  				return replaceExt(name, ext);
370  		}
371  		return false;
372  	}
373  	generic_string getAbsPath(const generic_string& fileName)
374  	{
375  		if (::PathIsRelative(fileName.c_str()))
376  		{
377  			TCHAR buffer[MAX_PATH] = { '\0' };
378  			const generic_string folder = getDialogFolder(_dialog);
379  			LPTSTR ret = ::PathCombine(buffer, folder.c_str(), fileName.c_str());
380  			if (ret)
381  				return buffer;
382  		}
383  		return fileName;
384  	}
385  	void onPreFileOk()
386  	{
387  		if (!_dialog)
388  			return;
389  		generic_string fileName = getDialogFileName(_dialog);
390  		expandEnv(fileName);
391  		bool nameChanged = transformPath(fileName);
392  		if (!::PathIsDirectory(getAbsPath(fileName).c_str()))
393  		{
394  			if (!hasExt(fileName))
395  				nameChanged |= changeExt(fileName, _currentType - 1);
396  		}
397  		if (nameChanged)
398  		{
399  			_dialog->SetFileName(_T(""));
400  			_dialog->SetFileName(fileName.c_str());
401  		}
402  	}
403  	static bool transformPath(generic_string& fileName)
404  	{
405  		if (fileName.empty())
406  			return false;
407  		bool transformed = false;
408  		std::replace_if(fileName.begin(), fileName.end(),
409  			[&transformed](generic_string::value_type c)
410  			{
411  				const bool eq = (c == '/');
412  				transformed |= eq;
413  				return eq;
414  			},
415  			'\\');
416  		return transformed;
417  	}
418  	static BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM param)
419  	{
420  		const int bufferLen = MAX_PATH;
421  		static TCHAR buffer[bufferLen];
422  		static bool isRTL = false;
423  		auto* inst = reinterpret_cast<FileDialogEventHandler*>(param);
424  		if (!inst)
425  			return FALSE;
426  		if (IsWindowEnabled(hwnd) && GetClassName(hwnd, buffer, bufferLen) != 0)
427  		{
428  			if (lstrcmpi(buffer, _T("ComboBox")) == 0)
429  			{
430  				HWND hwndChild = FindWindowEx(hwnd, nullptr, _T("Edit"), _T(""));
431  				if (hwndChild && !inst->_hwndNameEdit)
432  				{
433  					inst->_hwndNameEdit = hwndChild;
434  				}
435  			}
436  			else if (lstrcmpi(buffer, _T("Button")) == 0)
437  			{
438  				LONG style = GetWindowLong(hwnd, GWL_STYLE);
439  				if (style & (WS_CHILDWINDOW | WS_GROUP))
440  				{
441  					DWORD type = style & 0xF;
442  					DWORD appearance = style & 0xF0;
443  					if ((type == BS_PUSHBUTTON || type == BS_DEFPUSHBUTTON) && (appearance == BS_TEXT))
444  					{
445  						if (inst->_hwndButton)
446  						{
447  							RECT rc1 = {};
448  							RECT rc2 = {};
449  							if (GetWindowRect(hwnd, &rc1) && GetWindowRect(inst->_hwndButton, &rc2))
450  							{
451  								const bool isLess = isRTL ? (rc1.right > rc2.right) : (rc1.left < rc2.left);
452  								if (isLess)
453  									inst->_hwndButton = hwnd;
454  							}
455  						}
456  						else
457  						{
458  							isRTL = GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL;
459  							inst->_hwndButton = hwnd;
460  						}
461  					}
462  				}
463  			}
464  		}
465  		return TRUE;
466  	}
467  	static LRESULT CALLBACK CallProcHook(int nCode, WPARAM wParam, LPARAM lParam)
468  	{
469  		if (nCode == HC_ACTION)
470  		{
471  			auto* msg = reinterpret_cast<CWPSTRUCT*>(lParam);
472  			if (msg && msg->message == WM_COMMAND && HIWORD(msg->wParam) == BN_CLICKED)
473  			{
474  				auto ctrlId = LOWORD(msg->wParam);
475  				HWND hwnd = GetDlgItem(msg->hwnd, ctrlId);
476  				auto it = s_handleMap.find(hwnd);
477  				if (it != s_handleMap.end() && it->second && hwnd == it->second->_hwndButton)
478  					it->second->onPreFileOk();
479  			}
480  		}
481  		return ::CallNextHookEx(nullptr, nCode, wParam, lParam);
482  	}
483  	static LRESULT CALLBACK KbdProcHook(int nCode, WPARAM wParam, LPARAM lParam)
484  	{
485  		if (nCode == HC_ACTION)
486  		{
487  			if (wParam == VK_RETURN)
488  			{
489  				HWND hwnd = GetFocus();
490  				auto it = s_handleMap.find(hwnd);
491  				if (it != s_handleMap.end() && it->second && hwnd == it->second->_hwndNameEdit)
492  					it->second->onPreFileOk();
493  			}
494  		}
495  		return ::CallNextHookEx(nullptr, nCode, wParam, lParam);
496  	}
497  	static std::unordered_map<HWND, FileDialogEventHandler*> s_handleMap;
498  	long _cRef;
499  	com_ptr<IFileDialog> _dialog;
500  	com_ptr<IFileDialogCustomize> _customize;
501  	const std::vector<Filter> _filterSpec;
502  	generic_string _lastUsedFolder;
503  	HHOOK _prevKbdHook = nullptr;
504  	HHOOK _prevCallHook = nullptr;
505  	HWND _hwndNameEdit = nullptr;
506  	HWND _hwndButton = nullptr;
507  	UINT _currentType = 0;  
508  	UINT _lastSelectedType = 0;  
509  	UINT _wildcardType = 0;  
510  };
511  std::unordered_map<HWND, FileDialogEventHandler*> FileDialogEventHandler::s_handleMap;
512  class CustomFileDialog::Impl
513  {
514  public:
515  	Impl() = default;
516  	~Impl() = default;
517  	bool init(CLSID id)
518  	{
519  		if (_dialog)
520  			return false; 
521  		if (_fileTypeIndex >= static_cast<int>(_filterSpec.size()))
522  			_fileTypeIndex = 0;
523  		HRESULT hr = CoCreateInstance(id,
524  			NULL,
525  			CLSCTX_INPROC_SERVER,
526  			IID_PPV_ARGS(&_dialog));
527  		_customize = _dialog;
528  		if (SUCCEEDED(hr))
529  			_events.Attach(new FileDialogEventHandler(_dialog, _filterSpec, _fileTypeIndex, _wildcardIndex));
530  		if (_enableFileTypeCheckbox && !_fileTypeCheckboxValue && _wildcardIndex >= 0)
531  			_fileTypeIndex = _wildcardIndex;
532  		if (SUCCEEDED(hr) && _title)
533  			hr = _dialog->SetTitle(_title);
534  		if (SUCCEEDED(hr))
535  		{
536  			bool isFolderSet = false;
537  			if (!_initialFolder.empty())
538  				isFolderSet = setDialogFolder(_dialog, _initialFolder.c_str());
539  			if (!isFolderSet && !_fallbackFolder.empty())
540  				isFolderSet = setDialogFolder(_dialog, _fallbackFolder.c_str());
541  		}
542  		if (SUCCEEDED(hr) && _defExt && _defExt[0] != '\0')
543  			hr = _dialog->SetDefaultExtension(_defExt);
544  		if (SUCCEEDED(hr) && _initialFileName)
545  		{
546  			generic_string newFileName = _initialFileName;
547  			if (_fileTypeIndex >= 0 && _fileTypeIndex < static_cast<int>(_filterSpec.size()))
548  			{
549  				if (!hasExt(newFileName))
550  				{
551  					const generic_string ext = get1stExt(_filterSpec[_fileTypeIndex].ext);
552  					if (!ext.ends_with(_T(".*")))
553  						newFileName += ext;
554  				}
555  			}
556  			hr = _dialog->SetFileName(newFileName.c_str());
557  		}
558  		if (SUCCEEDED(hr) && !_filterSpec.empty())
559  		{
560  			std::vector<COMDLG_FILTERSPEC> fileTypes;
561  			fileTypes.reserve(_filterSpec.size());
562  			for (auto&& filter : _filterSpec)
563  				fileTypes.push_back({ filter.name.data(), filter.ext.data() });
564  			hr = _dialog->SetFileTypes(static_cast<UINT>(fileTypes.size()), fileTypes.data());
565  		}
566  		if (SUCCEEDED(hr) && _fileTypeIndex >= 0)
567  			hr = _dialog->SetFileTypeIndex(_fileTypeIndex + 1); 
568  		if (_enableFileTypeCheckbox)
569  			addCheckbox(IDC_FILE_TYPE_CHECKBOX, _fileTypeCheckboxLabel.c_str(), _fileTypeCheckboxValue);
570  		if (SUCCEEDED(hr))
571  			return addControls();
572  		return false;
573  	}
574  	bool initSave()
575  	{
576  		return init(CLSID_FileSaveDialog);
577  	}
578  	bool initOpen()
579  	{
580  		return init(CLSID_FileOpenDialog);
581  	}
582  	bool addFlags(DWORD dwNewFlags)
583  	{
584  		DWORD dwOldFlags = 0;
585  		HRESULT hr = _dialog->GetOptions(&dwOldFlags);
586  		if (SUCCEEDED(hr))
587  			hr = _dialog->SetOptions(dwOldFlags | dwNewFlags);
588  		return SUCCEEDED(hr);
589  	}
590  	bool addControls()
591  	{
592  		if (!_customize)
593  			return false;
594  		if (_checkboxLabel && _checkboxLabel[0] != '\0')
595  		{
596  			return addCheckbox(IDC_FILE_CUSTOM_CHECKBOX, _checkboxLabel, false, _isCheckboxActive);
597  		}
598  		return true;
599  	}
600  	bool addCheckbox(int id, const TCHAR* label, bool value, bool enabled = true)
601  	{
602  		if (!_customize)
603  			return false;
604  		HRESULT hr = _customize->AddCheckButton(id, label, value ? TRUE : FALSE);
605  		if (SUCCEEDED(hr) && !enabled)
606  		{
607  			hr = _customize->SetControlState(id, CDCS_INACTIVE | CDCS_VISIBLE);
608  			return SUCCEEDED(hr);
609  		}
610  		return SUCCEEDED(hr);
611  	}
612  	bool show()
613  	{
614  		static bool isActive = false;
615  		if (isActive)
616  			return false;
617  		assert(_dialog);
618  		if (!_dialog)
619  			return false;
620  		isActive = true;
621  		HRESULT hr = S_OK;
622  		DWORD dwCookie = 0;
623  		com_ptr<IFileDialogEvents> dialogEvents = _events;
624  		if (dialogEvents)
625  		{
626  			hr = _dialog->Advise(dialogEvents, &dwCookie);
627  			if (FAILED(hr))
628  				dialogEvents.Release();
629  		}
630  		bool okPressed = false;
631  		if (SUCCEEDED(hr))
632  		{
633  			hr = _dialog->Show(_hwndOwner);
634  			okPressed = SUCCEEDED(hr);
635  			NppParameters& params = NppParameters::getInstance();
636  			if (okPressed && params.getNppGUI()._openSaveDir == dir_last)
637  			{
638  				params.setWorkingDir(_events->getLastUsedFolder().c_str());
639  			}
640  		}
641  		if (dialogEvents)
642  			_dialog->Unadvise(dwCookie);
643  		isActive = false;
644  		return okPressed;
645  	}
646  	BOOL getCheckboxState(int id) const
647  	{
648  		if (_customize)
649  		{
650  			BOOL bChecked = FALSE;
651  			HRESULT hr = _customize->GetCheckButtonState(id, &bChecked);
652  			if (SUCCEEDED(hr))
653  				return bChecked;
654  		}
655  		return FALSE;
656  	}
657  	generic_string getResultFilename()
658  	{
659  		generic_string fileName;
660  		com_ptr<IShellItem> psiResult;
661  		HRESULT hr = _dialog->GetResult(&psiResult);
662  		if (SUCCEEDED(hr))
663  		{
664  			fileName = getFilename(psiResult);
665  			_hasReadonly = hasReadonlyAttr(psiResult);
666  		}
667  		return fileName;
668  	}
669  	static bool hasReadonlyAttr(IShellItem* psi)
670  	{
671  		SFGAOF attrs = 0;
672  		HRESULT hr = psi->GetAttributes(SFGAO_READONLY, &attrs);
673  		if (SUCCEEDED(hr))
674  			return attrs & SFGAO_READONLY;
675  		return false;
676  	}
677  	std::vector<generic_string> getFilenames()
678  	{
679  		std::vector<generic_string> result;
680  		com_ptr<IFileOpenDialog> pfd = _dialog;
681  		if (pfd)
682  		{
683  			com_ptr<IShellItemArray> psiaResults;
684  			HRESULT hr = pfd->GetResults(&psiaResults);
685  			if (SUCCEEDED(hr))
686  			{
687  				DWORD count = 0;
688  				hr = psiaResults->GetCount(&count);
689  				if (SUCCEEDED(hr))
690  				{
691  					for (DWORD i = 0; i != count; ++i)
692  					{
693  						com_ptr<IShellItem> psi;
694  						hr = psiaResults->GetItemAt(i, &psi);
695  						if (SUCCEEDED(hr))
696  						{
697  							_hasReadonly |= hasReadonlyAttr(psi);
698  							result.push_back(getFilename(psi));
699  						}
700  					}
701  				}
702  			}
703  		}
704  		return result;
705  	}
706  	HWND _hwndOwner = nullptr;
707  	const TCHAR* _title = nullptr;
708  	const TCHAR* _defExt = nullptr;
709  	generic_string _initialFolder;
710  	generic_string _fallbackFolder;
711  	const TCHAR* _checkboxLabel = nullptr;
712  	const TCHAR* _initialFileName = nullptr;
713  	bool _isCheckboxActive = true;
714  	std::vector<Filter> _filterSpec;
715  	int _fileTypeIndex = -1;	
716  	int _wildcardIndex = -1;	
717  	bool _hasReadonly = false;	
718  	bool _enableFileTypeCheckbox = false;
719  	bool _fileTypeCheckboxValue = false;	
720  	generic_string _fileTypeCheckboxLabel;
721  private:
722  	com_ptr<IFileDialog> _dialog;
723  	com_ptr<IFileDialogCustomize> _customize;
724  	com_ptr<FileDialogEventHandler, IFileDialogEvents> _events;
725  };
726  CustomFileDialog::CustomFileDialog(HWND hwnd) : _impl{ std::make_unique<Impl>() }
727  {
728  	_impl->_hwndOwner = hwnd;
729  	NppParameters& params = NppParameters::getInstance();
730  	const TCHAR* workDir = params.getWorkingDir();
731  	if (workDir)
732  		_impl->_fallbackFolder = workDir;
733  }
734  CustomFileDialog::~CustomFileDialog() = default;
735  void CustomFileDialog::setTitle(const TCHAR* title)
736  {
737  	_impl->_title = title;
738  }
739  void CustomFileDialog::setExtFilter(const TCHAR *extText, const TCHAR *exts)
740  {
741  	generic_string newExts{ exts ? exts : _T("") };
742  	for (size_t pos = 0; pos < newExts.size(); ++pos)
743  	{
744  		pos = newExts.find(_T('.'), pos);
745  		if (pos == generic_string::npos)
746  			break;
747  		if (pos == 0 || newExts[pos - 1] != _T('*'))
748  		{
749  			newExts.insert(pos, 1, _T('*'));
750  			++pos;
751  		}
752  	}
753  	if (newExts.find(_T("*.*")) == 0)
754  		_impl->_wildcardIndex = static_cast<int>(_impl->_filterSpec.size());
755  	_impl->_filterSpec.push_back({ extText, newExts });
756  }
757  void CustomFileDialog::setExtFilter(const TCHAR *extText, std::initializer_list<const TCHAR*> extList)
758  {
759  	generic_string exts;
760  	for (auto&& x : extList)
761  	{
762  		exts += x;
763  		exts += _T(';');
764  	}
765  	exts.pop_back();	
766  	setExtFilter(extText, exts.c_str());
767  }
768  void CustomFileDialog::setDefExt(const TCHAR* ext)
769  {
770  	_impl->_defExt = ext;
771  }
772  void CustomFileDialog::setDefFileName(const TCHAR* fn)
773  {
774  	_impl->_initialFileName = fn;
775  }
776  void CustomFileDialog::setFolder(const TCHAR* folder)
777  {
778  	_impl->_initialFolder = folder ? folder : _T("");
779  }
780  void CustomFileDialog::setCheckbox(const TCHAR* text, bool isActive)
781  {
782  	_impl->_checkboxLabel = text;
783  	_impl->_isCheckboxActive = isActive;
784  }
785  void CustomFileDialog::setExtIndex(int extTypeIndex)
786  {
787  	_impl->_fileTypeIndex = extTypeIndex;
788  }
789  bool CustomFileDialog::getCheckboxState() const
790  {
791  	return _impl->getCheckboxState(IDC_FILE_CUSTOM_CHECKBOX);
792  }
793  bool CustomFileDialog::isReadOnly() const
794  {
795  	return _impl->_hasReadonly;
796  }
797  void CustomFileDialog::enableFileTypeCheckbox(const generic_string& text, bool value)
798  {
799  	assert(!text.empty());
800  	if (!text.empty())
801  	{
802  		_impl->_fileTypeCheckboxLabel = text;
803  		_impl->_enableFileTypeCheckbox = true;
804  		_impl->_fileTypeCheckboxValue = value;
805  	}
806  }
807  bool CustomFileDialog::getFileTypeCheckboxValue() const
808  {
809  	return _impl->getCheckboxState(IDC_FILE_TYPE_CHECKBOX);
810  }
811  generic_string CustomFileDialog::doSaveDlg()
812  {
813  	if (!_impl->initSave())
814  		return {};
815  	CurrentDirBackup backup;
816  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM);
817  	bool bOk = _impl->show();
818  	return bOk ? _impl->getResultFilename() : _T("");
819  }
820  generic_string CustomFileDialog::doOpenSingleFileDlg()
821  {
822  	if (!_impl->initOpen())
823  		return {};
<span onclick='openModal()' class='match'>824  	CurrentDirBackup backup;
825  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM);
826  	bool bOk = _impl->show();
827  	return bOk ? _impl->getResultFilename() : _T("");
828  }
829  std::vector<generic_string> CustomFileDialog::doOpenMultiFilesDlg()
</span>830  {
831  	if (!_impl->initOpen())
832  		return {};
833  	CurrentDirBackup backup;
834  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM | FOS_ALLOWMULTISELECT);
835  	bool bOk = _impl->show();
836  	if (bOk)
837  		return _impl->getFilenames();
838  	return {};
839  }
840  generic_string CustomFileDialog::pickFolder()
841  {
842  	if (!_impl->initOpen())
843  		return {};
844  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM | FOS_PICKFOLDERS);
845  	bool bOk = _impl->show();
846  	return bOk ? _impl->getResultFilename() : _T("");
847  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CustomFileDialog.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CustomFileDialog.cpp</div>
                </div>
                <div class="column column_space"><pre><code>824  	CurrentDirBackup backup;
825  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM);
826  	bool bOk = _impl->show();
827  	return bOk ? _impl->getResultFilename() : _T("");
828  }
829  std::vector<generic_string> CustomFileDialog::doOpenMultiFilesDlg()
</pre></code></div>
                <div class="column column_space"><pre><code>824  	CurrentDirBackup backup;
825  	_impl->addFlags(FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST | FOS_FORCEFILESYSTEM);
826  	bool bOk = _impl->show();
827  	return bOk ? _impl->getResultFilename() : _T("");
828  }
829  std::vector<generic_string> CustomFileDialog::doOpenMultiFilesDlg()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    