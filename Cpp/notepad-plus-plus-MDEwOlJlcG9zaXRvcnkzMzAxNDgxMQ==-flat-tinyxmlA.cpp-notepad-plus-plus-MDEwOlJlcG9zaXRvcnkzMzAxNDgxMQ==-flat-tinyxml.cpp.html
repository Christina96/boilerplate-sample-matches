
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 27, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlA.cpp</h3>
            <pre><code>1  #include "Common.h"
2  #include "tinyxmlA.h"
3  #ifdef TIXMLA_USE_STL
4  #include <sstream>
5  #endif
6  bool TiXmlBaseA::condenseWhiteSpace = true;
7  void TiXmlBaseA::PutString( const TIXMLA_STRING& str, TIXMLA_OSTREAM* stream )
8  {
9  	TIXMLA_STRING buffer;
10  	PutString( str, &buffer );
11  	(*stream) << buffer;
12  }
13  void TiXmlBaseA::PutString( const TIXMLA_STRING& str, TIXMLA_STRING* outString )
14  {
15  	int i=0;
16  	while( i<(int)str.length() )
17  	{
18  		int c = str[i];
19  		if (    c == '&' 
20  		     && i < ( static_cast<int>(str.length()) - 2 )
21  			 && str[i+1] == '#'
22  			 && str[i+2] == 'x' )
23  		{
24  			while (i < static_cast<int>(str.length()))
25  			{
26  				outString->append( str.c_str() + i, 1 );
27  				++i;
28  				if ( str[i] == ';' )
29  					break;
30  			}
31  		}
32  		else if ( c == '&' )
33  		{
34  			outString->append( entity[0].str, entity[0].strLength );
35  			++i;
36  		}
37  		else if ( c == '<' )
38  		{
39  			outString->append( entity[1].str, entity[1].strLength );
40  			++i;
41  		}
42  		else if ( c == '>' )
43  		{
44  			outString->append( entity[2].str, entity[2].strLength );
45  			++i;
46  		}
47  		else if ( c == '\"' )
48  		{
49  			outString->append( entity[3].str, entity[3].strLength );
50  			++i;
51  		}
52  		else if ( c == '\'' )
53  		{
54  			outString->append( entity[4].str, entity[4].strLength );
55  			++i;
56  		}
57  		else
58  		{
59  			char realc = static_cast<char>(c);
60  			outString->append( &realc, 1 );
61  			++i;
62  		}
63  	}
64  }
65  TiXmlBaseA::StringToBuffer::StringToBuffer( const TIXMLA_STRING& str )
66  {
67  	buffer = new char[ str.length()+1 ];
68  	if ( buffer )
69  	{
70  		strcpy( buffer, str.c_str() );
71  	}
72  }
73  TiXmlBaseA::StringToBuffer::~StringToBuffer()
74  {
75  	delete [] buffer;
76  }
77  TiXmlNodeA::TiXmlNodeA( NodeType _type )
78  {
79  	parent = 0;
80  	type = _type;
81  	firstChild = 0;
82  	lastChild = 0;
83  	prev = 0;
84  	next = 0;
85  	userData = 0;
86  }
87  TiXmlNodeA::~TiXmlNodeA()
88  {
89  	TiXmlNodeA* node = firstChild;
90  	TiXmlNodeA* temp = 0;
91  	while ( node )
92  	{
93  		temp = node;
94  		node = node->next;
95  		delete temp;
96  	}	
97  }
98  void TiXmlNodeA::Clear()
99  {
100  	TiXmlNodeA* node = firstChild;
101  	TiXmlNodeA* temp = 0;
102  	while ( node )
103  	{
104  		temp = node;
105  		node = node->next;
106  		delete temp;
107  	}	
108  	firstChild = 0;
109  	lastChild = 0;
110  }
111  TiXmlNodeA* TiXmlNodeA::LinkEndChild( TiXmlNodeA* node )
112  {
113  	node->parent = this;
114  	node->prev = lastChild;
115  	node->next = 0;
116  	if ( lastChild )
117  		lastChild->next = node;
118  	else
119  		firstChild = node;			
120  	lastChild = node;
121  	return node;
122  }
123  TiXmlNodeA* TiXmlNodeA::InsertEndChild( const TiXmlNodeA& addThis )
124  {
125  	TiXmlNodeA* node = addThis.Clone();
126  	if ( !node )
127  		return 0;
128  	return LinkEndChild( node );
129  }
130  TiXmlNodeA* TiXmlNodeA::InsertBeforeChild( TiXmlNodeA* beforeThis, const TiXmlNodeA& addThis )
131  {	
132  	if ( !beforeThis || beforeThis->parent != this )
133  		return 0;
134  	TiXmlNodeA* node = addThis.Clone();
135  	if ( !node )
136  		return 0;
137  	node->parent = this;
138  	node->next = beforeThis;
139  	node->prev = beforeThis->prev;
140  	if ( beforeThis->prev )
141  	{
142  		beforeThis->prev->next = node;
143  	}
144  	else
145  	{
146  		assert( firstChild == beforeThis );
147  		firstChild = node;
148  	}
149  	beforeThis->prev = node;
150  	return node;
151  }
152  TiXmlNodeA* TiXmlNodeA::InsertAfterChild( TiXmlNodeA* afterThis, const TiXmlNodeA& addThis )
153  {
154  	if ( !afterThis || afterThis->parent != this )
155  		return 0;
156  	TiXmlNodeA* node = addThis.Clone();
157  	if ( !node )
158  		return 0;
159  	node->parent = this;
160  	node->prev = afterThis;
161  	node->next = afterThis->next;
162  	if ( afterThis->next )
163  	{
164  		afterThis->next->prev = node;
165  	}
166  	else
167  	{
168  		assert( lastChild == afterThis );
169  		lastChild = node;
170  	}
171  	afterThis->next = node;
172  	return node;
173  }
174  TiXmlNodeA* TiXmlNodeA::ReplaceChild( TiXmlNodeA* replaceThis, const TiXmlNodeA& withThis )
175  {
176  	if ( replaceThis->parent != this )
177  		return 0;
178  	TiXmlNodeA* node = withThis.Clone();
179  	if ( !node )
180  		return 0;
181  	node->next = replaceThis->next;
182  	node->prev = replaceThis->prev;
183  	if ( replaceThis->next )
184  		replaceThis->next->prev = node;
185  	else
186  		lastChild = node;
187  	if ( replaceThis->prev )
188  		replaceThis->prev->next = node;
189  	else
190  		firstChild = node;
191  	delete replaceThis;
192  	node->parent = this;
193  	return node;
194  }
195  bool TiXmlNodeA::RemoveChild( TiXmlNodeA* removeThis )
196  {
197  	if ( removeThis->parent != this )
198  	{	
199  		assert( 0 );
200  		return false;
201  	}
202  	if ( removeThis->next )
203  		removeThis->next->prev = removeThis->prev;
204  	else
205  		lastChild = removeThis->prev;
206  	if ( removeThis->prev )
207  		removeThis->prev->next = removeThis->next;
208  	else
209  		firstChild = removeThis->next;
210  	delete removeThis;
211  	return true;
212  }
213  TiXmlNodeA* TiXmlNodeA::FirstChild( const char * _value ) const
214  {
215  	TiXmlNodeA* node;
216  	for ( node = firstChild; node; node = node->next )
217  	{
218  		if ( node->SValue() == TIXMLA_STRING( _value ))
219  			return node;
220  	}
221  	return 0;
222  }
223  TiXmlNodeA* TiXmlNodeA::LastChild( const char * _value ) const
224  {
225  	TiXmlNodeA* node;
226  	for ( node = lastChild; node; node = node->prev )
227  	{
228  		if ( node->SValue() == TIXMLA_STRING (_value))
229  			return node;
230  	}
231  	return 0;
232  }
233  TiXmlNodeA* TiXmlNodeA::IterateChildren( TiXmlNodeA* previous ) const
234  {
235  	if ( !previous )
236  	{
237  		return FirstChild();
238  	}
239  	else
240  	{
241  		assert( previous->parent == this );
242  		return previous->NextSibling();
243  	}
244  }
245  TiXmlNodeA* TiXmlNodeA::IterateChildren( const char * val, TiXmlNodeA* previous ) const
246  {
247  	if ( !previous )
248  	{
249  		return FirstChild( val );
250  	}
251  	else
252  	{
253  		assert( previous->parent == this );
254  		return previous->NextSibling( val );
255  	}
256  }
257  TiXmlNodeA* TiXmlNodeA::NextSibling( const char * _value ) const
258  {
259  	TiXmlNodeA* node;
260  	for ( node = next; node; node = node->next )
261  	{
262  		if ( node->SValue() == TIXMLA_STRING (_value))
263  			return node;
264  	}
265  	return 0;
266  }
267  TiXmlNodeA* TiXmlNodeA::PreviousSibling( const char * _value ) const
268  {
269  	TiXmlNodeA* node;
270  	for ( node = prev; node; node = node->prev )
271  	{
272  		if ( node->SValue() == TIXMLA_STRING (_value))
273  			return node;
274  	}
275  	return 0;
276  }
277  void TiXmlElementA::RemoveAttribute( const char * name )
278  {
279  	TiXmlAttributeA* node = attributeSet.Find( name );
280  	if ( node )
281  	{
282  		attributeSet.Remove( node );
283  		delete node;
284  	}
285  }
286  TiXmlElementA* TiXmlNodeA::FirstChildElement() const
287  {
288  	TiXmlNodeA* node;
289  	for (	node = FirstChild();
290  	node;
291  	node = node->NextSibling() )
292  	{
293  		if ( node->ToElement() )
294  			return node->ToElement();
295  	}
296  	return 0;
297  }
298  TiXmlElementA* TiXmlNodeA::FirstChildElement( const char * _value ) const
299  {
300  	TiXmlNodeA* node;
301  	for (	node = FirstChild( _value );
302  	node;
303  	node = node->NextSibling( _value ) )
304  	{
305  		if ( node->ToElement() )
306  			return node->ToElement();
307  	}
308  	return 0;
309  }
310  TiXmlElementA* TiXmlNodeA::NextSiblingElement() const
311  {
312  	TiXmlNodeA* node;
313  	for (	node = NextSibling();
314  	node;
315  	node = node->NextSibling() )
316  	{
317  		if ( node->ToElement() )
318  			return node->ToElement();
319  	}
320  	return 0;
321  }
322  TiXmlElementA* TiXmlNodeA::NextSiblingElement( const char * _value ) const
323  {
324  	TiXmlNodeA* node;
325  	for (	node = NextSibling( _value );
326  	node;
327  	node = node->NextSibling( _value ) )
328  	{
329  		if ( node->ToElement() )
330  			return node->ToElement();
331  	}
332  	return 0;
333  }
334  TiXmlDocumentA* TiXmlNodeA::GetDocument() const
335  {
336  	const TiXmlNodeA* node;
337  	for( node = this; node; node = node->parent )
338  	{
339  		if ( node->ToDocument() )
340  			return node->ToDocument();
341  	}
342  	return 0;
343  }
344  TiXmlElementA::TiXmlElementA (const char * _value)
345  : TiXmlNodeA( TiXmlNodeA::ELEMENT )
346  {
347  	firstChild = lastChild = 0;
348  	value = _value;
349  }
350  TiXmlElementA::~TiXmlElementA()
351  {
352  	while( attributeSet.First() )
353  	{
354  		TiXmlAttributeA* node = attributeSet.First();
355  		attributeSet.Remove( node );
356  		delete node;
357  	}
358  }
359  const char * TiXmlElementA::Attribute( const char * name ) const
360  {
361  	TiXmlAttributeA* node = attributeSet.Find( name );
362  	if ( node )
363  		return node->Value();
364  	return 0;
365  }
366  const char * TiXmlElementA::Attribute( const char * name, int* i ) const
367  {
368  	const char * s = Attribute( name );
369  	if ( i )
370  	{
371  		if ( s )
372  			*i = atoi( s );
373  		else
374  			*i = 0;
375  	}
376  	return s;
377  }
378  const char * TiXmlElementA::Attribute( const char * name, double* d ) const
379  {
380  	const char * s = Attribute( name );
381  	if ( d )
382  	{
383  		if ( s )
384  			*d = atof( s );
385  		else
386  			*d = 0;
387  	}
388  	return s;
389  }
390  int TiXmlElementA::QueryIntAttribute( const char* name, int* ival ) const
391  {
392  	TiXmlAttributeA* node = attributeSet.Find( name );
393  	if ( !node )
394  		return TIXMLA_NO_ATTRIBUTE;
395  	return node->QueryIntValue( ival );
396  }
397  int TiXmlElementA::QueryDoubleAttribute( const char* name, double* dval ) const
398  {
399  	TiXmlAttributeA* node = attributeSet.Find( name );
400  	if ( !node )
401  		return TIXMLA_NO_ATTRIBUTE;
402  	return node->QueryDoubleValue( dval );
403  }
404  void TiXmlElementA::SetAttribute( const char * name, int val )
405  {	
406  	char buf[64];
407  	sprintf( buf, "%d", val );
408  	SetAttribute( name, buf );
409  }
410  void TiXmlElementA::SetAttribute( const char * name, const char * _value )
411  {
412  	TiXmlAttributeA* node = attributeSet.Find( name );
413  	if ( node )
414  	{
415  		node->SetValue( _value );
416  		return;
417  	}
418  	TiXmlAttributeA* attrib = new TiXmlAttributeA( name, _value );
419  	if ( attrib )
420  	{
421  		attributeSet.Add( attrib );
422  	}
423  	else
424  	{
425  		TiXmlDocumentA* document = GetDocument();
426  		if ( document ) document->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, 0, 0 );
427  	}
428  }
429  void TiXmlElementA::Print( FILE* cfile, int depth ) const
430  {
431  	int i;
432  	for ( i=0; i<depth; i++ )
433  	{
434  		fprintf( cfile, "    " );
435  	}
436  	fprintf( cfile, "<%s", value.c_str() );
437  	TiXmlAttributeA* attrib;
438  	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
439  	{
440  		fprintf( cfile, " " );
441  		attrib->Print( cfile, depth );
442  	}
443  	TiXmlNodeA* node;
444  	if ( !firstChild )
445  	{
446  		fprintf( cfile, " />" );
447  	}
448  	else if ( firstChild == lastChild && firstChild->ToText() )
449  	{
450  		fprintf( cfile, ">" );
451  		firstChild->Print( cfile, depth + 1 );
452  		fprintf( cfile, "</%s>", value.c_str() );
453  	}
454  	else
455  	{
456  		fprintf( cfile, ">" );
457  		for ( node = firstChild; node; node=node->NextSibling() )
458  		{
459  			if ( !node->ToText() )
460  			{
461  				fprintf( cfile, "\n" );
462  			}
463  			node->Print( cfile, depth+1 );
464  		}
465  		fprintf( cfile, "\n" );
466  		for( i=0; i<depth; ++i )
467  		fprintf( cfile, "    " );
468  		fprintf( cfile, "</%s>", value.c_str() );
469  	}
470  }
471  void TiXmlElementA::StreamOut( TIXMLA_OSTREAM * stream ) const
472  {
473  	(*stream) << "<" << value;
474  	TiXmlAttributeA* attrib;
475  	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
476  	{	
477  		(*stream) << " ";
478  		attrib->StreamOut( stream );
479  	}
480  	TiXmlNodeA* node;
481  	if ( firstChild )
482  	{ 		
483  		(*stream) << ">";
484  		for ( node = firstChild; node; node=node->NextSibling() )
485  		{
486  			node->StreamOut( stream );
487  		}
488  		(*stream) << "</" << value << ">";
489  	}
490  	else
491  	{
492  		(*stream) << " />";
493  	}
494  }
495  TiXmlNodeA* TiXmlElementA::Clone() const
496  {
497  	TiXmlElementA* clone = new TiXmlElementA( Value() );
498  	if ( !clone )
499  		return 0;
500  	CopyToClone( clone );
501  	TiXmlAttributeA* attribute = 0;
502  	for(	attribute = attributeSet.First();
503  	attribute;
504  	attribute = attribute->Next() )
505  	{
506  		clone->SetAttribute( attribute->Name(), attribute->Value() );
507  	}
508  	TiXmlNodeA* node = 0;
509  	for ( node = firstChild; node; node = node->NextSibling() )
510  	{
511  		clone->LinkEndChild( node->Clone() );
512  	}
513  	return clone;
514  }
515  TiXmlDocumentA::TiXmlDocumentA() : TiXmlNodeA( TiXmlNodeA::DOCUMENT )
516  {
517  	tabsize = 4;
518  	ClearError();
519  }
520  TiXmlDocumentA::TiXmlDocumentA( const char * documentName ) : TiXmlNodeA( TiXmlNodeA::DOCUMENT )
521  {
522  	tabsize = 4;
523  	value = documentName;
524  	ClearError();
525  }
526  bool TiXmlDocumentA::LoadFile()
527  {
528  	StringToBuffer buf( value );
529  	if ( buf.buffer && LoadFile( buf.buffer ) )
530  		return true;
531  	return false;
532  }
533  bool TiXmlDocumentA::SaveFile() const
534  {
535  	StringToBuffer buf( value );
536  	if ( buf.buffer && SaveFile( buf.buffer ) )
537  		return true;
538  	return false;
539  }
540  bool TiXmlDocumentA::LoadFile( const char* filename )
541  {
542  	Clear();
543  	location.Clear();
544  	value = filename;
545  	FILE* file = fopen( value.c_str (), "r" );
546  	if ( file )
547  	{
548  		long length = 0;
549  		fseek( file, 0, SEEK_END );
550  		length = ftell( file );
551  		fseek( file, 0, SEEK_SET );
552  		if ( length == 0 )
553  		{
554  			fclose( file );
555  			return false;
556  		}
557  		TIXMLA_STRING data;
558  		data.reserve( length );
559  		const int BUF_SIZE = 2048;
560  		char buf[BUF_SIZE];
561  		while( fgets( buf, BUF_SIZE, file ) )
562  		{
563  			data += buf;
564  		}
565  		fclose( file );
566  		Parse( data.c_str(), 0 );
<span onclick='openModal()' class='match'>567  		if (  Error() )
568              return false;
569          else
570  			return true;
571  	}
572  	SetError( TIXMLA_ERROR_OPENING_FILE, 0, 0 );
573  	return false;
574  }
575  bool TiXmlDocumentA::LoadUnicodeFilePath( const TCHAR* filename )
</span>576  {
577  	Clear();
578  	location.Clear();
579  	FILE* file = _wfopen(filename, TEXT("r"));
580  	if ( file )
581  	{
582  		long length = 0;
583  		fseek( file, 0, SEEK_END );
584  		length = ftell( file );
585  		fseek( file, 0, SEEK_SET );
586  		if ( length == 0 )
587  		{
588  			fclose( file );
589  			return false;
590  		}
591  		TIXMLA_STRING data;
592  		data.reserve( length );
593  		const int BUF_SIZE = 2048;
594  		char buf[BUF_SIZE];
595  		while( fgets( buf, BUF_SIZE, file ) )
596  		{
597  			data += buf;
598  		}
599  		fclose( file );
600  		Parse( data.c_str(), 0 );
601  		if (  Error() )
602              return false;
603          else
604  			return true;
605  	}
606  	SetError( TIXMLA_ERROR_OPENING_FILE, 0, 0 );
607  	return false;
608  }
609  bool TiXmlDocumentA::SaveFile( const char * filename ) const
610  {
611  	FILE* fp = fopen( filename, "wc" );
612  	if ( fp )
613  	{
614  		Print( fp, 0 );
615  		fflush( fp );
616  		fclose( fp );
617  		return true;
618  	}
619  	return false;
620  }
621  bool TiXmlDocumentA::SaveUnicodeFilePath( const TCHAR* filename ) const
622  {
623  	FILE* fp = _wfopen( filename, TEXT("wc") );
624  	if ( fp )
625  	{
626  		Print( fp, 0 );
627  		fflush( fp );
628  		fclose( fp );
629  		return true;
630  	}
631  	return false;
632  }
633  TiXmlNodeA* TiXmlDocumentA::Clone() const
634  {
635  	TiXmlDocumentA* clone = new TiXmlDocumentA();
636  	if ( !clone )
637  		return 0;
638  	CopyToClone( clone );
639  	clone->error = error;
640  	clone->errorDesc = errorDesc.c_str ();
641  	TiXmlNodeA* node = 0;
642  	for ( node = firstChild; node; node = node->NextSibling() )
643  	{
644  		clone->LinkEndChild( node->Clone() );
645  	}
646  	return clone;
647  }
648  void TiXmlDocumentA::Print( FILE* cfile, int depth ) const
649  {
650  	TiXmlNodeA* node;
651  	for ( node=FirstChild(); node; node=node->NextSibling() )
652  	{
653  		node->Print( cfile, depth );
654  		fprintf( cfile, "\n" );
655  	}
656  }
657  void TiXmlDocumentA::StreamOut( TIXMLA_OSTREAM * out ) const
658  {
659  	TiXmlNodeA* node;
660  	for ( node=FirstChild(); node; node=node->NextSibling() )
661  	{
662  		node->StreamOut( out );
663  		if ( node->ToElement() )
664  			break;
665  	}
666  }
667  TiXmlAttributeA* TiXmlAttributeA::Next() const
668  {
669  	if ( next->value.empty() && next->name.empty() )
670  		return 0;
671  	return next;
672  }
673  TiXmlAttributeA* TiXmlAttributeA::Previous() const
674  {
675  	if ( prev->value.empty() && prev->name.empty() )
676  		return 0;
677  	return prev;
678  }
679  void TiXmlAttributeA::Print( FILE* cfile, int &bsol;*depth*/ ) const
680  {
681  	TIXMLA_STRING n, v;
682  	PutString( Name(), &n );
683  	PutString( Value(), &v );
684  	if (value.find ('\"') == TIXMLA_STRING::npos)
685  		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
686  	else
687  		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
688  }
689  void TiXmlAttributeA::StreamOut( TIXMLA_OSTREAM * stream ) const
690  {
691  	if (value.find( '\"' ) != TIXMLA_STRING::npos)
692  	{
693  		PutString( name, stream );
694  		(*stream) << "=" << "'";
695  		PutString( value, stream );
696  		(*stream) << "'";
697  	}
698  	else
699  	{
700  		PutString( name, stream );
701  		(*stream) << "=" << "\"";
702  		PutString( value, stream );
703  		(*stream) << "\"";
704  	}
705  }
706  int TiXmlAttributeA::QueryIntValue( int* ival ) const
707  {
708  	if ( sscanf( value.c_str(), "%d", ival ) == 1 )
709  		return TIXMLA_SUCCESS;
710  	return TIXMLA_WRONG_TYPE;
711  }
712  int TiXmlAttributeA::QueryDoubleValue( double* dval ) const
713  {
714  	if ( sscanf( value.c_str(), "%lf", dval ) == 1 )
715  		return TIXMLA_SUCCESS;
716  	return TIXMLA_WRONG_TYPE;
717  }
718  void TiXmlAttributeA::SetIntValue( int _value )
719  {
720  	char buf [64];
721  	sprintf (buf, "%d", _value);
722  	SetValue (buf);
723  }
724  void TiXmlAttributeA::SetDoubleValue( double _value )
725  {
726  	char buf [64];
727  	sprintf (buf, "%lf", _value);
728  	SetValue (buf);
729  }
730  int TiXmlAttributeA::IntValue() const
731  {
732  	return atoi (value.c_str ());
733  }
734  double TiXmlAttributeA::DoubleValue() const
735  {
736  	return atof (value.c_str ());
737  }
738  void TiXmlCommentA::Print( FILE* cfile, int depth ) const
739  {
740  	for ( int i=0; i<depth; i++ )
741  	{
742  		fputs( "    ", cfile );
743  	}
744  	fprintf( cfile, "<!--%s-->", value.c_str() );
745  }
746  void TiXmlCommentA::StreamOut( TIXMLA_OSTREAM * stream ) const
747  {
748  	(*stream) << "<!--";
749  	PutString( value, stream );
750  	(*stream) << "-->";
751  }
752  TiXmlNodeA* TiXmlCommentA::Clone() const
753  {
754  	TiXmlCommentA* clone = new TiXmlCommentA();
755  	if ( !clone )
756  		return 0;
757  	CopyToClone( clone );
758  	return clone;
759  }
760  void TiXmlTextA::Print( FILE* cfile, int &bsol;*depth*/ ) const
761  {
762  	TIXMLA_STRING buffer;
763  	PutString( value, &buffer );
764  	fprintf( cfile, "%s", buffer.c_str() );
765  }
766  void TiXmlTextA::StreamOut( TIXMLA_OSTREAM * stream ) const
767  {
768  	PutString( value, stream );
769  }
770  TiXmlNodeA* TiXmlTextA::Clone() const
771  {	
772  	TiXmlTextA* clone = 0;
773  	clone = new TiXmlTextA( "" );
774  	if ( !clone )
775  		return 0;
776  	CopyToClone( clone );
777  	return clone;
778  }
779  TiXmlDeclarationA::TiXmlDeclarationA( const char * _version,
780  	const char * _encoding,
781  	const char * _standalone )
782  : TiXmlNodeA( TiXmlNodeA::DECLARATION )
783  {
784  	version = _version;
785  	encoding = _encoding;
786  	standalone = _standalone;
787  }
788  void TiXmlDeclarationA::Print( FILE* cfile, int &bsol;*depth*/ ) const
789  {
790  	fprintf (cfile, "<?xml ");
791  	if ( !version.empty() )
792  		fprintf (cfile, "version=\"%s\" ", version.c_str ());
793  	if ( !encoding.empty() )
794  		fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
795  	if ( !standalone.empty() )
796  		fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
797  	fprintf (cfile, "?>");
798  }
799  void TiXmlDeclarationA::StreamOut( TIXMLA_OSTREAM * stream ) const
800  {
801  	(*stream) << "<?xml ";
802  	if ( !version.empty() )
803  	{
804  		(*stream) << "version=\"";
805  		PutString( version, stream );
806  		(*stream) << "\" ";
807  	}
808  	if ( !encoding.empty() )
809  	{
810  		(*stream) << "encoding=\"";
811  		PutString( encoding, stream );
812  		(*stream ) << "\" ";
813  	}
814  	if ( !standalone.empty() )
815  	{
816  		(*stream) << "standalone=\"";
817  		PutString( standalone, stream );
818  		(*stream) << "\" ";
819  	}
820  	(*stream) << "?>";
821  }
822  TiXmlNodeA* TiXmlDeclarationA::Clone() const
823  {	
824  	TiXmlDeclarationA* clone = new TiXmlDeclarationA();
825  	if ( !clone )
826  		return 0;
827  	CopyToClone( clone );
828  	clone->version = version;
829  	clone->encoding = encoding;
830  	clone->standalone = standalone;
831  	return clone;
832  }
833  void TiXmlUnknownA::Print( FILE* cfile, int depth ) const
834  {
835  	for ( int i=0; i<depth; i++ )
836  		fprintf( cfile, "    " );
837  	fprintf( cfile, "%s", value.c_str() );
838  }
839  void TiXmlUnknownA::StreamOut( TIXMLA_OSTREAM * stream ) const
840  {
841  	(*stream) << "<" << value << ">";		
842  }
843  TiXmlNodeA* TiXmlUnknownA::Clone() const
844  {
845  	TiXmlUnknownA* clone = new TiXmlUnknownA();
846  	if ( !clone )
847  		return 0;
848  	CopyToClone( clone );
849  	return clone;
850  }
851  TiXmlAttributeSetA::TiXmlAttributeSetA()
852  {
853  	sentinel.next = &sentinel;
854  	sentinel.prev = &sentinel;
855  }
856  TiXmlAttributeSetA::~TiXmlAttributeSetA()
857  {
858  	assert( sentinel.next == &sentinel );
859  	assert( sentinel.prev == &sentinel );
860  }
861  void TiXmlAttributeSetA::Add( TiXmlAttributeA* addMe )
862  {
863  	assert( !Find( addMe->Name() ) );	
864  	addMe->next = &sentinel;
865  	addMe->prev = sentinel.prev;
866  	sentinel.prev->next = addMe;
867  	sentinel.prev      = addMe;
868  }
869  void TiXmlAttributeSetA::Remove( TiXmlAttributeA* removeMe )
870  {
871  	TiXmlAttributeA* node;
872  	for( node = sentinel.next; node != &sentinel; node = node->next )
873  	{
874  		if ( node == removeMe )
875  		{
876  			node->prev->next = node->next;
877  			node->next->prev = node->prev;
878  			node->next = 0;
879  			node->prev = 0;
880  			return;
881  		}
882  	}
883  	assert( 0 );		
884  }
885  TiXmlAttributeA*	TiXmlAttributeSetA::Find( const char * name ) const
886  {
887  	TiXmlAttributeA* node;
888  	for( node = sentinel.next; node != &sentinel; node = node->next )
889  	{
890  		if ( node->name == name )
891  			return node;
892  	}
893  	return 0;
894  }
895  #ifdef TIXMLA_USE_STL	
896  TIXMLA_ISTREAM & operator >> (TIXMLA_ISTREAM & in, TiXmlNodeA & base)
897  {
898  	TIXMLA_STRING tag;
899  	tag.reserve( 8 * 1000 );
900  	base.StreamIn( &in, &tag );
901  	base.Parse( tag.c_str(), 0 );
902  	return in;
903  }
904  #endif
905  TIXMLA_OSTREAM & operator<< (TIXMLA_OSTREAM & out, const TiXmlNodeA & base)
906  {
907  	base.StreamOut (& out);
908  	return out;
909  }
910  #ifdef TIXMLA_USE_STL	
911  std::string & operator<< (std::string& out, const TiXmlNodeA& base )
912  {
913     std::ostringstream os_stream( std::ostringstream::out );
914     base.StreamOut( &os_stream );
915     out.append( os_stream.str() );
916     return out;
917  }
918  #endif
919  TiXmlHandleA TiXmlHandleA::FirstChild() const
920  {
921  	if ( node )
922  	{
923  		TiXmlNodeA* child = node->FirstChild();
924  		if ( child )
925  			return TiXmlHandleA( child );
926  	}
927  	return TiXmlHandleA( 0 );
928  }
929  TiXmlHandleA TiXmlHandleA::FirstChild( const char * value ) const
930  {
931  	if ( node )
932  	{
933  		TiXmlNodeA* child = node->FirstChild( value );
934  		if ( child )
935  			return TiXmlHandleA( child );
936  	}
937  	return TiXmlHandleA( 0 );
938  }
939  TiXmlHandleA TiXmlHandleA::FirstChildElement() const
940  {
941  	if ( node )
942  	{
943  		TiXmlElementA* child = node->FirstChildElement();
944  		if ( child )
945  			return TiXmlHandleA( child );
946  	}
947  	return TiXmlHandleA( 0 );
948  }
949  TiXmlHandleA TiXmlHandleA::FirstChildElement( const char * value ) const
950  {
951  	if ( node )
952  	{
953  		TiXmlElementA* child = node->FirstChildElement( value );
954  		if ( child )
955  			return TiXmlHandleA( child );
956  	}
957  	return TiXmlHandleA( 0 );
958  }
959  TiXmlHandleA TiXmlHandleA::Child( int count ) const
960  {
961  	if ( node )
962  	{
963  		int i;
964  		TiXmlNodeA* child = node->FirstChild();
965  		for (	i=0;
966  				child && i<count;
967  				child = child->NextSibling(), ++i )
968  		{
969  		}
970  		if ( child )
971  			return TiXmlHandleA( child );
972  	}
973  	return TiXmlHandleA( 0 );
974  }
975  TiXmlHandleA TiXmlHandleA::Child( const char* value, int count ) const
976  {
977  	if ( node )
978  	{
979  		int i;
980  		TiXmlNodeA* child = node->FirstChild( value );
981  		for (	i=0;
982  				child && i<count;
983  				child = child->NextSibling( value ), ++i )
984  		{
985  		}
986  		if ( child )
987  			return TiXmlHandleA( child );
988  	}
989  	return TiXmlHandleA( 0 );
990  }
991  TiXmlHandleA TiXmlHandleA::ChildElement( int count ) const
992  {
993  	if ( node )
994  	{
995  		int i;
996  		TiXmlElementA* child = node->FirstChildElement();
997  		for (	i=0;
998  				child && i<count;
999  				child = child->NextSiblingElement(), ++i )
1000  		{
1001  		}
1002  		if ( child )
1003  			return TiXmlHandleA( child );
1004  	}
1005  	return TiXmlHandleA( 0 );
1006  }
1007  TiXmlHandleA TiXmlHandleA::ChildElement( const char* value, int count ) const
1008  {
1009  	if ( node )
1010  	{
1011  		int i;
1012  		TiXmlElementA* child = node->FirstChildElement( value );
1013  		for (	i=0;
1014  				child && i<count;
1015  				child = child->NextSiblingElement( value ), ++i )
1016  		{
1017  		}
1018  		if ( child )
1019  			return TiXmlHandleA( child );
1020  	}
1021  	return TiXmlHandleA( 0 );
1022  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxml.cpp</h3>
            <pre><code>1  #include <sstream>
2  #include <memory>
3  #include "tinyxml.h"
4  bool TiXmlBase::condenseWhiteSpace = true;
5  void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_OSTREAM* stream )
6  {
7  	TIXML_STRING buffer;
8  	PutString( str, &buffer );
9  	(*stream) << buffer;
10  }
11  void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_STRING* outString )
12  {
13  	size_t i = 0;
14  	while (i < str.length())
15  	{
16  		int c = str[i];
17  		if (c == '&' 
18  		     && i < ( str.length() - 2 )
19  			 && str[i+1] == '#'
20  			 && str[i+2] == 'x' )
21  		{
22  			while ( i < str.length() )
23  			{
24  				outString->append( str.c_str() + i, 1 );
25  				++i;
26  				if ( str[i] == ';' )
27  					break;
28  			}
29  		}
30  		else if ( c == '&' )
31  		{
32  			outString->append( entity[0].str, entity[0].strLength );
33  			++i;
34  		}
35  		else if ( c == '<' )
36  		{
37  			outString->append( entity[1].str, entity[1].strLength );
38  			++i;
39  		}
40  		else if ( c == '>' )
41  		{
42  			outString->append( entity[2].str, entity[2].strLength );
43  			++i;
44  		}
45  		else if ( c == '\"' )
46  		{
47  			outString->append( entity[3].str, entity[3].strLength );
48  			++i;
49  		}
50  		else if ( c == '\'' )
51  		{
52  			outString->append( entity[4].str, entity[4].strLength );
53  			++i;
54  		}
55  		else if ( c < 32 || c > 126 )
56  		{
57  			TCHAR buf[32];
58  			wsprintf( buf, TEXT("&#x%04X;"), static_cast<unsigned int>(c & 0xffff) );
59  			outString->append( buf, lstrlen( buf ) );
60  			++i;
61  		}
62  		else
63  		{
64  			TCHAR realc = static_cast<TCHAR>(c);
65  			outString->append( &realc, 1 );
66  			++i;
67  		}
68  	}
69  }
70  TiXmlBase::StringToBuffer::StringToBuffer( const TIXML_STRING& str )
71  {
72  	const size_t strLen = str.length() + 1;
73  	buffer = new TCHAR[strLen];
74  	if (buffer)
75  	{
76  		wcscpy_s(buffer, strLen, str.c_str());
77  	}
78  }
79  TiXmlBase::StringToBuffer::~StringToBuffer()
80  {
81  	delete [] buffer;
82  }
83  TiXmlNode::TiXmlNode( NodeType _type )
84  {
85  	parent = 0;
86  	type = _type;
87  	firstChild = 0;
88  	lastChild = 0;
89  	prev = 0;
90  	next = 0;
91  	userData = 0;
92  }
93  TiXmlNode::~TiXmlNode()
94  {
95  	TiXmlNode* node = firstChild;
96  	TiXmlNode* temp = 0;
97  	while ( node )
98  	{
99  		temp = node;
100  		node = node->next;
101  		delete temp;
102  	}	
103  }
104  void TiXmlNode::Clear()
105  {
106  	TiXmlNode* node = firstChild;
107  	TiXmlNode* temp = 0;
108  	while ( node )
109  	{
110  		temp = node;
111  		node = node->next;
112  		delete temp;
113  	}	
114  	firstChild = 0;
115  	lastChild = 0;
116  }
117  TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
118  {
119  	node->parent = this;
120  	node->prev = lastChild;
121  	node->next = 0;
122  	if ( lastChild )
123  		lastChild->next = node;
124  	else
125  		firstChild = node;			
126  	lastChild = node;
127  	return node;
128  }
129  TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
130  {
131  	TiXmlNode* node = addThis.Clone();
132  	if ( !node )
133  		return 0;
134  	return LinkEndChild( node );
135  }
136  TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
137  {	
138  	if ( !beforeThis || beforeThis->parent != this )
139  		return 0;
140  	TiXmlNode* node = addThis.Clone();
141  	if ( !node )
142  		return 0;
143  	node->parent = this;
144  	node->next = beforeThis;
145  	node->prev = beforeThis->prev;
146  	if ( beforeThis->prev )
147  	{
148  		beforeThis->prev->next = node;
149  	}
150  	else
151  	{
152  		assert( firstChild == beforeThis );
153  		firstChild = node;
154  	}
155  	beforeThis->prev = node;
156  	return node;
157  }
158  TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
159  {
160  	if ( !afterThis || afterThis->parent != this )
161  		return 0;
162  	TiXmlNode* node = addThis.Clone();
163  	if ( !node )
164  		return 0;
165  	node->parent = this;
166  	node->prev = afterThis;
167  	node->next = afterThis->next;
168  	if ( afterThis->next )
169  	{
170  		afterThis->next->prev = node;
171  	}
172  	else
173  	{
174  		assert( lastChild == afterThis );
175  		lastChild = node;
176  	}
177  	afterThis->next = node;
178  	return node;
179  }
180  TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
181  {
182  	if ( replaceThis->parent != this )
183  		return 0;
184  	TiXmlNode* node = withThis.Clone();
185  	if ( !node )
186  		return 0;
187  	node->next = replaceThis->next;
188  	node->prev = replaceThis->prev;
189  	if ( replaceThis->next )
190  		replaceThis->next->prev = node;
191  	else
192  		lastChild = node;
193  	if ( replaceThis->prev )
194  		replaceThis->prev->next = node;
195  	else
196  		firstChild = node;
197  	delete replaceThis;
198  	node->parent = this;
199  	return node;
200  }
201  bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
202  {
203  	if ( removeThis->parent != this )
204  	{	
205  		assert( 0 );
206  		return false;
207  	}
208  	if ( removeThis->next )
209  		removeThis->next->prev = removeThis->prev;
210  	else
211  		lastChild = removeThis->prev;
212  	if ( removeThis->prev )
213  		removeThis->prev->next = removeThis->next;
214  	else
215  		firstChild = removeThis->next;
216  	delete removeThis;
217  	return true;
218  }
219  TiXmlNode* TiXmlNode::FirstChild( const TCHAR * _value ) const
220  {
221  	TiXmlNode* node;
222  	for ( node = firstChild; node; node = node->next )
223  	{
224  		if ( node->SValue() == TIXML_STRING( _value ))
225  			return node;
226  	}
227  	return 0;
228  }
229  TiXmlNode* TiXmlNode::LastChild( const TCHAR * _value ) const
230  {
231  	TiXmlNode* node;
232  	for ( node = lastChild; node; node = node->prev )
233  	{
234  		if ( node->SValue() == TIXML_STRING (_value))
235  			return node;
236  	}
237  	return 0;
238  }
239  TiXmlNode* TiXmlNode::IterateChildren( TiXmlNode* previous ) const
240  {
241  	if ( !previous )
242  	{
243  		return FirstChild();
244  	}
245  	else
246  	{
247  		assert( previous->parent == this );
248  		return previous->NextSibling();
249  	}
250  }
251  TiXmlNode* TiXmlNode::IterateChildren( const TCHAR * val, TiXmlNode* previous ) const
252  {
253  	if ( !previous )
254  	{
255  		return FirstChild( val );
256  	}
257  	else
258  	{
259  		assert( previous->parent == this );
260  		return previous->NextSibling( val );
261  	}
262  }
263  TiXmlNode* TiXmlNode::NextSibling( const TCHAR * _value ) const
264  {
265  	TiXmlNode* node;
266  	for ( node = next; node; node = node->next )
267  	{
268  		if ( node->SValue() == TIXML_STRING (_value))
269  			return node;
270  	}
271  	return 0;
272  }
273  TiXmlNode* TiXmlNode::PreviousSibling( const TCHAR * _value ) const
274  {
275  	TiXmlNode* node;
276  	for ( node = prev; node; node = node->prev )
277  	{
278  		if ( node->SValue() == TIXML_STRING (_value))
279  			return node;
280  	}
281  	return 0;
282  }
283  void TiXmlElement::RemoveAttribute( const TCHAR * name )
284  {
285  	TiXmlAttribute* node = attributeSet.Find( name );
286  	if ( node )
287  	{
288  		attributeSet.Remove( node );
289  		delete node;
290  	}
291  }
292  TiXmlElement* TiXmlNode::FirstChildElement() const
293  {
294  	TiXmlNode* node;
295  	for (	node = FirstChild();
296  	node;
297  	node = node->NextSibling() )
298  	{
299  		if ( node->ToElement() )
300  			return node->ToElement();
301  	}
302  	return 0;
303  }
304  TiXmlElement* TiXmlNode::FirstChildElement( const TCHAR * _value ) const
305  {
306  	TiXmlNode* node;
307  	for (	node = FirstChild( _value );
308  	node;
309  	node = node->NextSibling( _value ) )
310  	{
311  		if ( node->ToElement() )
312  			return node->ToElement();
313  	}
314  	return 0;
315  }
316  TiXmlElement* TiXmlNode::NextSiblingElement() const
317  {
318  	TiXmlNode* node;
319  	for (	node = NextSibling();
320  	node;
321  	node = node->NextSibling() )
322  	{
323  		if ( node->ToElement() )
324  			return node->ToElement();
325  	}
326  	return 0;
327  }
328  TiXmlElement* TiXmlNode::NextSiblingElement( const TCHAR * _value ) const
329  {
330  	TiXmlNode* node;
331  	for (	node = NextSibling( _value );
332  	node;
333  	node = node->NextSibling( _value ) )
334  	{
335  		if ( node->ToElement() )
336  			return node->ToElement();
337  	}
338  	return 0;
339  }
340  TiXmlDocument* TiXmlNode::GetDocument() const
341  {
342  	const TiXmlNode* node;
343  	for( node = this; node; node = node->parent )
344  	{
345  		if ( node->ToDocument() )
346  			return node->ToDocument();
347  	}
348  	return 0;
349  }
350  TiXmlElement::TiXmlElement (const TCHAR * _value)
351  : TiXmlNode( TiXmlNode::ELEMENT )
352  {
353  	firstChild = lastChild = 0;
354  	value = _value;
355  }
356  TiXmlElement::~TiXmlElement()
357  {
358  	while( attributeSet.First() )
359  	{
360  		TiXmlAttribute* node = attributeSet.First();
361  		attributeSet.Remove( node );
362  		delete node;
363  	}
364  }
365  const TCHAR * TiXmlElement::Attribute( const TCHAR * name ) const
366  {
367  	TiXmlAttribute* node = attributeSet.Find( name );
368  	if ( node )
369  		return node->Value();
370  	return 0;
371  }
372  const TCHAR * TiXmlElement::Attribute( const TCHAR * name, int* i ) const
373  {
374  	const TCHAR * s = Attribute( name );
375  	if ( i )
376  	{
377  		if ( s )
378  			*i = _wtoi( s );
379  		else
380  			*i = 0;
381  	}
382  	return s;
383  }
384  const TCHAR * TiXmlElement::Attribute( const TCHAR * name, double* d ) const
385  {
386  	const TCHAR * s = Attribute( name );
387  	if ( d )
388  	{
389  		if ( s )
390  			*d = _wtof( s );
391  		else
392  			*d = 0;
393  	}
394  	return s;
395  }
396  int TiXmlElement::QueryIntAttribute( const TCHAR* name, int* ival ) const
397  {
398  	TiXmlAttribute* node = attributeSet.Find( name );
399  	if ( !node )
400  		return TIXML_NO_ATTRIBUTE;
401  	return node->QueryIntValue( ival );
402  }
403  int TiXmlElement::QueryDoubleAttribute( const TCHAR* name, double* dval ) const
404  {
405  	TiXmlAttribute* node = attributeSet.Find( name );
406  	if ( !node )
407  		return TIXML_NO_ATTRIBUTE;
408  	return node->QueryDoubleValue( dval );
409  }
410  void TiXmlElement::SetAttribute( const TCHAR * name, int val )
411  {	
412  	TCHAR buf[64];
413  	wsprintf( buf, TEXT("%d"), val );
414  	SetAttribute( name, buf );
415  }
416  void TiXmlElement::SetAttribute( const TCHAR * name, const TCHAR * _value )
417  {
418  	TiXmlAttribute* node = attributeSet.Find( name );
419  	if ( node )
420  	{
421  		node->SetValue( _value );
422  		return;
423  	}
424  	TiXmlAttribute* attrib = new TiXmlAttribute( name, _value );
425  	if ( attrib )
426  	{
427  		attributeSet.Add( attrib );
428  	}
429  	else
430  	{
431  		TiXmlDocument* document = GetDocument();
432  		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0 );
433  	}
434  }
435  void TiXmlElement::Print( std::string& outputStream, int depth ) const
436  {
437  	int i;
438  	for ( i=0; i<depth; i++ )
439  	{
440  		outputStream += "    ";
441  	}
442  	std::string tagOpenValue = "<";
443  	tagOpenValue += wstring2string(value, CP_UTF8);
444  	outputStream += tagOpenValue;
445  	TiXmlAttribute* attrib;
446  	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
447  	{
448  		outputStream += " ";
449  		attrib->Print(outputStream, depth );
450  	}
451  	TiXmlNode* node;
452  	if ( !firstChild )
453  	{
454  		outputStream += " />";
455  	}
456  	else if ( firstChild == lastChild && firstChild->ToText() )
457  	{
458  		outputStream += ">";
459  		firstChild->Print(outputStream, depth + 1 );
460  		std::string tagCloseWithValue = "</";
461  		tagCloseWithValue += wstring2string(value, CP_UTF8) + ">";
462  		outputStream += tagCloseWithValue;
463  	}
464  	else
465  	{
466  		outputStream += ">";
467  		for ( node = firstChild; node; node=node->NextSibling() )
468  		{
469  			if ( !node->ToText() )
470  			{
471  				outputStream += "\r\n";
472  			}
473  			node->Print(outputStream, depth+1 );
474  		}
475  		outputStream += "\r\n";
476  		for( i=0; i<depth; ++i )
477  			outputStream += "    ";
478  		std::string tagCloseWithValue = "</";
479  		tagCloseWithValue += wstring2string(value, CP_UTF8) + ">";
480  		outputStream += tagCloseWithValue;
481  	}
482  }
483  void TiXmlElement::StreamOut( TIXML_OSTREAM * stream ) const
484  {
485  	(*stream) << TEXT("<") << value;
486  	TiXmlAttribute* attrib;
487  	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
488  	{	
489  		(*stream) << TEXT(" ");
490  		attrib->StreamOut( stream );
491  	}
492  	TiXmlNode* node;
493  	if ( firstChild )
494  	{ 		
495  		(*stream) << TEXT(">");
496  		for ( node = firstChild; node; node=node->NextSibling() )
497  		{
498  			node->StreamOut( stream );
499  		}
500  		(*stream) << TEXT("</") << value << TEXT(">");
501  	}
502  	else
503  	{
504  		(*stream) << TEXT(" />");
505  	}
506  }
507  TiXmlNode* TiXmlElement::Clone() const
508  {
509  	TiXmlElement* clone = new TiXmlElement( Value() );
510  	if ( !clone )
511  		return 0;
512  	CopyToClone( clone );
513  	TiXmlAttribute* attribute = 0;
514  	for(	attribute = attributeSet.First();
515  	attribute;
516  	attribute = attribute->Next() )
517  	{
518  		clone->SetAttribute( attribute->Name(), attribute->Value() );
519  	}
520  	TiXmlNode* node = 0;
521  	for ( node = firstChild; node; node = node->NextSibling() )
522  	{
523  		clone->LinkEndChild( node->Clone() );
524  	}
525  	return clone;
526  }
527  TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::DOCUMENT )
528  {
529  	tabsize = 4;
530  	ClearError();
531  }
532  TiXmlDocument::TiXmlDocument( const TCHAR * documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
533  {
534  	tabsize = 4;
535  	value = documentName;
536  	ClearError();
537  }
538  bool TiXmlDocument::LoadFile()
539  {
540  	StringToBuffer buf( value );
541  	if ( buf.buffer && LoadFile( buf.buffer ) )
542  		return true;
543  	return false;
544  }
545  bool TiXmlDocument::SaveFile() const
546  {
547  	StringToBuffer buf( value );
548  	if ( buf.buffer && SaveFile( buf.buffer ) )
549  		return true;
550  	return false;
551  }
552  bool TiXmlDocument::LoadFile( const TCHAR* filename )
553  {
554  	Clear();
555  	location.Clear();
556  	value = filename;
557  	FILE* file = _wfopen( value.c_str (), TEXT("r") );
558  	if ( file )
559  	{
560  		long length = 0;
561  		fseek( file, 0, SEEK_END );
562  		length = ftell( file );
563  		fseek( file, 0, SEEK_SET );
564  		if ( length == 0 )
565  		{
566  			fclose( file );
567  			return false;
568  		}
569  		TIXML_STRING data;
570  		data.reserve( length );
571  		const int BUF_SIZE = 2048;
572  		wchar_t buf[BUF_SIZE];
573  		while(fgetws( buf, BUF_SIZE, file ) )
574  		{
575  			data += buf;
576  		}
577  		fclose( file );
578  		Parse( data.c_str(), 0 );
<span onclick='openModal()' class='match'>579  		if (  Error() )
580              return false;
581          else
582  			return true;
583  	}
584  	SetError( TIXML_ERROR_OPENING_FILE, 0, 0 );
585  	return false;
586  }
587  bool TiXmlDocument::SaveFile( const TCHAR * filename ) const
</span>588  {
589  	Win32_IO_File file(filename);
590  	if (file.isOpened())
591  	{
592  		std::unique_ptr<std::string> outputStr = std::make_unique<std::string>();
593  		Print(*outputStr, 0);
594  		if (!outputStr->empty())
595  			return file.writeStr(*outputStr);
596  	}
597  	return false;
598  }
599  TiXmlNode* TiXmlDocument::Clone() const
600  {
601  	TiXmlDocument* clone = new TiXmlDocument();
602  	if ( !clone )
603  		return 0;
604  	CopyToClone( clone );
605  	clone->error = error;
606  	clone->errorDesc = errorDesc.c_str ();
607  	TiXmlNode* node = 0;
608  	for ( node = firstChild; node; node = node->NextSibling() )
609  	{
610  		clone->LinkEndChild( node->Clone() );
611  	}
612  	return clone;
613  }
614  void TiXmlDocument::Print( std::string& outputStream, int depth ) const
615  {
616  	TiXmlNode* node;
617  	for ( node=FirstChild(); node; node=node->NextSibling() )
618  	{
619  		node->Print(outputStream, depth );
620  		outputStream += "\r\n";
621  	}
622  }
623  void TiXmlDocument::StreamOut( TIXML_OSTREAM * out ) const
624  {
625  	TiXmlNode* node;
626  	for ( node=FirstChild(); node; node=node->NextSibling() )
627  	{
628  		node->StreamOut( out );
629  		if ( node->ToElement() )
630  			break;
631  	}
632  }
633  TiXmlAttribute* TiXmlAttribute::Next() const
634  {
635  	if ( next->value.empty() && next->name.empty() )
636  		return 0;
637  	return next;
638  }
639  TiXmlAttribute* TiXmlAttribute::Previous() const
640  {
641  	if ( prev->value.empty() && prev->name.empty() )
642  		return 0;
643  	return prev;
644  }
645  void TiXmlAttribute::Print( std::string& outputStream, int &bsol;*depth*/ ) const
646  {
647  	TIXML_STRING n, v;
648  	PutString( Name(), &n );
649  	PutString( Value(), &v );
650  	std::string attrVsValue = wstring2string(n, CP_UTF8);
651  	if (value.find('\"') == TIXML_STRING::npos)
652  	{
653  		attrVsValue += "=\"";
654  		attrVsValue += wstring2string(v, CP_UTF8);
655  		attrVsValue += "\"";
656  	}
657  	else
658  	{
659  		attrVsValue += "='";
660  		attrVsValue += wstring2string(v, CP_UTF8);
661  		attrVsValue += "'";
662  	}
663  	outputStream += attrVsValue;
664  }
665  void TiXmlAttribute::StreamOut( TIXML_OSTREAM * stream ) const
666  {
667  	if (value.find( '\"' ) != TIXML_STRING::npos)
668  	{
669  		PutString( name, stream );
670  		(*stream) << TEXT("=") << TEXT("'");
671  		PutString( value, stream );
672  		(*stream) << TEXT("'");
673  	}
674  	else
675  	{
676  		PutString( name, stream );
677  		(*stream) << TEXT("=") << TEXT("\"");
678  		PutString( value, stream );
679  		(*stream) << TEXT("\"");
680  	}
681  }
682  int TiXmlAttribute::QueryIntValue( int* ival ) const
683  {
684  	if (swscanf( value.c_str(), L"%d", ival ) == 1 )
685  		return TIXML_SUCCESS;
686  	return TIXML_WRONG_TYPE;
687  }
688  int TiXmlAttribute::QueryDoubleValue( double* dval ) const
689  {
690  	if (swscanf( value.c_str(), L"%lf", dval ) == 1 )
691  		return TIXML_SUCCESS;
692  	return TIXML_WRONG_TYPE;
693  }
694  void TiXmlAttribute::SetIntValue( int _value )
695  {
696  	TCHAR buf [64];
697  	wsprintf (buf, TEXT("%d"), _value);
698  	SetValue (buf);
699  }
700  void TiXmlAttribute::SetDoubleValue( double _value )
701  {
702  	TCHAR buf [64];
703  	wsprintf (buf, TEXT("%lf"), _value);
704  	SetValue (buf);
705  }
706  int TiXmlAttribute::IntValue() const
707  {
708  	return _wtoi (value.c_str ());
709  }
710  double  TiXmlAttribute::DoubleValue() const
711  {
712  	return _wtof(value.c_str ());
713  }
714  void TiXmlComment::Print( std::string& outputStream, int depth ) const
715  {
716  	for ( int i=0; i<depth; i++ )
717  	{
718  		outputStream += "    ";
719  	}
720  	std::string comment = "<!--";
721  	comment += wstring2string(value, CP_UTF8);
722  	comment += "-->";
723  	outputStream += comment;
724  }
725  void TiXmlComment::StreamOut( TIXML_OSTREAM * stream ) const
726  {
727  	(*stream) << TEXT("<!--");
728  	PutString( value, stream );
729  	(*stream) << TEXT("-->");
730  }
731  TiXmlNode* TiXmlComment::Clone() const
732  {
733  	TiXmlComment* clone = new TiXmlComment();
734  	if ( !clone )
735  		return 0;
736  	CopyToClone( clone );
737  	return clone;
738  }
739  void TiXmlText::Print( std::string& outputStream, int &bsol;*depth*/ ) const
740  {
741  	TIXML_STRING buffer;
742  	PutString( value, &buffer );
743  	outputStream += wstring2string(buffer, CP_UTF8);
744  }
745  void TiXmlText::StreamOut( TIXML_OSTREAM * stream ) const
746  {
747  	PutString( value, stream );
748  }
749  TiXmlNode* TiXmlText::Clone() const
750  {	
751  	TiXmlText* clone = 0;
752  	clone = new TiXmlText( TEXT("") );
753  	if ( !clone )
754  		return 0;
755  	CopyToClone( clone );
756  	return clone;
757  }
758  TiXmlDeclaration::TiXmlDeclaration( const TCHAR * _version,
759  	const TCHAR * _encoding,
760  	const TCHAR * _standalone )
761  : TiXmlNode( TiXmlNode::DECLARATION )
762  {
763  	version = _version;
764  	encoding = _encoding;
765  	standalone = _standalone;
766  }
767  void TiXmlDeclaration::Print( std::string& outputStream, int &bsol;*depth*/ ) const
768  {
769  	std::string xmlDcl = "<?xml ";
770  	if (!version.empty())
771  	{
772  		xmlDcl += "version=\"";
773  		xmlDcl += wstring2string(version, CP_UTF8);
774  		xmlDcl += "\" ";
775  	}
776  	if (!encoding.empty())
777  	{
778  		xmlDcl += "encoding=\"";
779  		xmlDcl += wstring2string(encoding, CP_UTF8);
780  		xmlDcl += "\" ";
781  	}
782  	if (!standalone.empty())
783  	{
784  		xmlDcl += "standalone=\"";
785  		xmlDcl += wstring2string(standalone, CP_UTF8);
786  		xmlDcl += "\" ";
787  	}
788  	xmlDcl += "?>";
789  	outputStream += xmlDcl;
790  }
791  void TiXmlDeclaration::StreamOut( TIXML_OSTREAM * stream ) const
792  {
793  	(*stream) << TEXT("<?xml ");
794  	if ( !version.empty() )
795  	{
796  		(*stream) << TEXT("version=\"");
797  		PutString( version, stream );
798  		(*stream) << TEXT("\" ");
799  	}
800  	if ( !encoding.empty() )
801  	{
802  		(*stream) << TEXT("encoding=\"");
803  		PutString( encoding, stream );
804  		(*stream ) << TEXT("\" ");
805  	}
806  	if ( !standalone.empty() )
807  	{
808  		(*stream) << TEXT("standalone=\"");
809  		PutString( standalone, stream );
810  		(*stream) << TEXT("\" ");
811  	}
812  	(*stream) << TEXT("?>");
813  }
814  TiXmlNode* TiXmlDeclaration::Clone() const
815  {	
816  	TiXmlDeclaration* clone = new TiXmlDeclaration();
817  	if ( !clone )
818  		return 0;
819  	CopyToClone( clone );
820  	clone->version = version;
821  	clone->encoding = encoding;
822  	clone->standalone = standalone;
823  	return clone;
824  }
825  void TiXmlUnknown::Print( std::string& outputStream, int depth ) const
826  {
827  	for ( int i=0; i<depth; i++ )
828  		outputStream += "    ";
829  	outputStream += wstring2string(value, CP_UTF8);
830  }
831  void TiXmlUnknown::StreamOut( TIXML_OSTREAM * stream ) const
832  {
833  	(*stream) << TEXT("<") << value << TEXT(">");		
834  }
835  TiXmlNode* TiXmlUnknown::Clone() const
836  {
837  	TiXmlUnknown* clone = new TiXmlUnknown();
838  	if ( !clone )
839  		return 0;
840  	CopyToClone( clone );
841  	return clone;
842  }
843  TiXmlAttributeSet::TiXmlAttributeSet()
844  {
845  	sentinel.next = &sentinel;
846  	sentinel.prev = &sentinel;
847  }
848  TiXmlAttributeSet::~TiXmlAttributeSet()
849  {
850  	assert( sentinel.next == &sentinel );
851  	assert( sentinel.prev == &sentinel );
852  }
853  void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
854  {
855  	assert( !Find( addMe->Name() ) );	
856  	addMe->next = &sentinel;
857  	addMe->prev = sentinel.prev;
858  	sentinel.prev->next = addMe;
859  	sentinel.prev      = addMe;
860  }
861  void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
862  {
863  	TiXmlAttribute* node;
864  	for( node = sentinel.next; node != &sentinel; node = node->next )
865  	{
866  		if ( node == removeMe )
867  		{
868  			node->prev->next = node->next;
869  			node->next->prev = node->prev;
870  			node->next = 0;
871  			node->prev = 0;
872  			return;
873  		}
874  	}
875  	assert( 0 );		
876  }
877  TiXmlAttribute*	TiXmlAttributeSet::Find( const TCHAR * name ) const
878  {
879  	TiXmlAttribute* node;
880  	for( node = sentinel.next; node != &sentinel; node = node->next )
881  	{
882  		if ( node->name == name )
883  			return node;
884  	}
885  	return 0;
886  }
887  #ifdef TIXML_USE_STL	
888  TIXML_ISTREAM & operator >> (TIXML_ISTREAM & in, TiXmlNode & base)
889  {
890  	TIXML_STRING tag;
891  	tag.reserve( 8 * 1000 );
892  	base.StreamIn( &in, &tag );
893  	base.Parse( tag.c_str(), 0 );
894  	return in;
895  }
896  #endif
897  TIXML_OSTREAM & operator<< (TIXML_OSTREAM & out, const TiXmlNode & base)
898  {
899  	base.StreamOut (& out);
900  	return out;
901  }
902  #ifdef TIXML_USE_STL	
903  generic_string & operator<< (generic_string& out, const TiXmlNode& base )
904  {
905  	std::basic_ostringstream<TCHAR> os_stream( std::ostringstream::out );
906     base.StreamOut( &os_stream );
907     out.append( os_stream.str() );
908     return out;
909  }
910  #endif
911  TiXmlHandle TiXmlHandle::FirstChild() const
912  {
913  	if ( node )
914  	{
915  		TiXmlNode* child = node->FirstChild();
916  		if ( child )
917  			return TiXmlHandle( child );
918  	}
919  	return TiXmlHandle( 0 );
920  }
921  TiXmlHandle TiXmlHandle::FirstChild( const TCHAR * value ) const
922  {
923  	if ( node )
924  	{
925  		TiXmlNode* child = node->FirstChild( value );
926  		if ( child )
927  			return TiXmlHandle( child );
928  	}
929  	return TiXmlHandle( 0 );
930  }
931  TiXmlHandle TiXmlHandle::FirstChildElement() const
932  {
933  	if ( node )
934  	{
935  		TiXmlElement* child = node->FirstChildElement();
936  		if ( child )
937  			return TiXmlHandle( child );
938  	}
939  	return TiXmlHandle( 0 );
940  }
941  TiXmlHandle TiXmlHandle::FirstChildElement( const TCHAR * value ) const
942  {
943  	if ( node )
944  	{
945  		TiXmlElement* child = node->FirstChildElement( value );
946  		if ( child )
947  			return TiXmlHandle( child );
948  	}
949  	return TiXmlHandle( 0 );
950  }
951  TiXmlHandle TiXmlHandle::Child( int count ) const
952  {
953  	if ( node )
954  	{
955  		int i;
956  		TiXmlNode* child = node->FirstChild();
957  		for (	i=0;
958  				child && i<count;
959  				child = child->NextSibling(), ++i )
960  		{
961  		}
962  		if ( child )
963  			return TiXmlHandle( child );
964  	}
965  	return TiXmlHandle( 0 );
966  }
967  TiXmlHandle TiXmlHandle::Child( const TCHAR* value, int count ) const
968  {
969  	if ( node )
970  	{
971  		int i;
972  		TiXmlNode* child = node->FirstChild( value );
973  		for (	i=0;
974  				child && i<count;
975  				child = child->NextSibling( value ), ++i )
976  		{
977  		}
978  		if ( child )
979  			return TiXmlHandle( child );
980  	}
981  	return TiXmlHandle( 0 );
982  }
983  TiXmlHandle TiXmlHandle::ChildElement( int count ) const
984  {
985  	if ( node )
986  	{
987  		int i;
988  		TiXmlElement* child = node->FirstChildElement();
989  		for (	i=0;
990  				child && i<count;
991  				child = child->NextSiblingElement(), ++i )
992  		{
993  		}
994  		if ( child )
995  			return TiXmlHandle( child );
996  	}
997  	return TiXmlHandle( 0 );
998  }
999  TiXmlHandle TiXmlHandle::ChildElement( const TCHAR* value, int count ) const
1000  {
1001  	if ( node )
1002  	{
1003  		int i;
1004  		TiXmlElement* child = node->FirstChildElement( value );
1005  		for (	i=0;
1006  				child && i<count;
1007  				child = child->NextSiblingElement( value ), ++i )
1008  		{
1009  		}
1010  		if ( child )
1011  			return TiXmlHandle( child );
1012  	}
1013  	return TiXmlHandle( 0 );
1014  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlA.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxml.cpp</div>
                </div>
                <div class="column column_space"><pre><code>567  		if (  Error() )
568              return false;
569          else
570  			return true;
571  	}
572  	SetError( TIXMLA_ERROR_OPENING_FILE, 0, 0 );
573  	return false;
574  }
575  bool TiXmlDocumentA::LoadUnicodeFilePath( const TCHAR* filename )
</pre></code></div>
                <div class="column column_space"><pre><code>579  		if (  Error() )
580              return false;
581          else
582  			return true;
583  	}
584  	SetError( TIXML_ERROR_OPENING_FILE, 0, 0 );
585  	return false;
586  }
587  bool TiXmlDocument::SaveFile( const TCHAR * filename ) const
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    