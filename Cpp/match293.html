<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mpcfile.cpp &amp; flacfile.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mpcfile.cpp &amp; flacfile.cpp
      </h3>
<h1 align="center">
        34.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mpcfile.cpp (50.988144%)<th>flacfile.cpp (25.903614%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(103-132)<td><a href="#" name="0">(131-161)</a><td align="center"><font color="#ff0000">36</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(261-283)<td><a href="#" name="1">(407-429)</a><td align="center"><font color="#9b0000">22</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(224-239)<td><a href="#" name="2">(311-326)</a><td align="center"><font color="#860000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(70-101)<td><a href="#" name="3">(93-120)</a><td align="center"><font color="#860000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(136-153)<td><a href="#" name="4">(162-177)</a><td align="center"><font color="#7f0000">18</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(164-186)<td><a href="#" name="5">(289-309)</a><td align="center"><font color="#6a0000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mpcfile.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;tbytevector.h&gt;
2 #include &lt;tstring.h&gt;
3 #include &lt;tagunion.h&gt;
4 #include &lt;tdebug.h&gt;
5 #include &lt;tpropertymap.h&gt;
6 #include &lt;tagutils.h&gt;
7 #include "mpcfile.h"
8 #include "id3v1tag.h"
9 #include "id3v2header.h"
10 #include "apetag.h"
11 #include "apefooter.h"
12 using namespace TagLib;
13 namespace
14 {
15   enum { MPCAPEIndex = 0, MPCID3v1Index = 1 };
16 }
17 class MPC::File::FilePrivate
18 {
19 public:
20   FilePrivate() :
21     APELocation(-1),
22     APESize(0),
23     ID3v1Location(-1),
24     ID3v2Header(0),
25     ID3v2Location(-1),
26     ID3v2Size(0),
27     properties(0) {}
28   ~FilePrivate()
29   {
30     delete ID3v2Header;
31     delete properties;
32   }
33   long APELocation;
34   long APESize;
35 <a name="3"></a>  long ID3v1Location;
36   ID3v2::Header *ID3v2Header;
37 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  long ID3v2Location;
38   long ID3v2Size;
39   TagUnion tag;
40   Properties *properties;
41 };
42 bool MPC::File::isSupported(IOStream *stream)
43 {
44   const ByteVector id = Utils::readHeader(stream, 4, false);
45   return (id == "MPCK" || id.startsWith("MP+"));
46 }
47 MPC::File::File(FileName file, bool readProperties, Properties::ReadStyle) :
48   TagLib::File(file),
49   d(new FilePrivate())
50 {
51   if(isOpen())
52 <a name="0"></a>    read(readProperties);
53 }</b></font>
54 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>MPC::File::File(IOStream *stream, bool readProperties, Properties::ReadStyle) :
55   TagLib::File(stream),
56   d(new FilePrivate())
57 {
58   if(isOpen())
59     read(readProperties);
60 }
61 MPC::File::~File()
62 {
63   delete d;
64 }
65 TagLib::Tag *MPC::File::tag() const
66 {
67   return &amp;d-&gt;tag;
68 }
69 PropertyMap MPC::File::properties() const
70 {
71   return d-&gt;tag.properties();
72 }
73 void MPC::File::removeUnsupportedProperties(const StringList &amp;properties)
74 {
75   d-&gt;tag.removeUnsupportedProperties(properties);
76 }
77 PropertyMap MPC::File::setProperties(const PropertyMap &amp;properties)
78 {</b></font>
79 <a name="4"></a>  if(ID3v1Tag())
80     ID3v1Tag()-&gt;setProperties(properties);
81 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  return APETag(true)-&gt;setProperties(properties);
82 }
83 MPC::Properties *MPC::File::audioProperties() const
84 {
85   return d-&gt;properties;
86 }
87 bool MPC::File::save()
88 {
89   if(readOnly()) {
90     debug("MPC::File::save() -- File is read only.");
91     return false;
92   }
93   if(!d-&gt;ID3v2Header &amp;&amp; d-&gt;ID3v2Location &gt;= 0) {</b></font>
94     removeBlock(d-&gt;ID3v2Location, d-&gt;ID3v2Size);
95     if(d-&gt;APELocation &gt;= 0)
96       d-&gt;APELocation -= d-&gt;ID3v2Size;
97     if(d-&gt;ID3v1Location &gt;= 0)
98       d-&gt;ID3v1Location -= d-&gt;ID3v2Size;
99 <a name="5"></a>
100     d-&gt;ID3v2Location = -1;
101     d-&gt;ID3v2Size = 0;
102 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
103   if(ID3v1Tag() &amp;&amp; !ID3v1Tag()-&gt;isEmpty()) {
104     if(d-&gt;ID3v1Location &gt;= 0) {
105       seek(d-&gt;ID3v1Location);
106     }
107     else {
108       seek(0, End);
109       d-&gt;ID3v1Location = tell();
110     }
111     writeBlock(ID3v1Tag()-&gt;render());
112   }
113   else {
114     if(d-&gt;ID3v1Location &gt;= 0) {</b></font>
115       truncate(d-&gt;ID3v1Location);
116       d-&gt;ID3v1Location = -1;
117     }
118   }
119   if(APETag() &amp;&amp; !APETag()-&gt;isEmpty()) {
120     if(d-&gt;APELocation &lt; 0) {
121       if(d-&gt;ID3v1Location &gt;= 0)
122         d-&gt;APELocation = d-&gt;ID3v1Location;
123       else
124         d-&gt;APELocation = length();
125     }
126     const ByteVector data = APETag()-&gt;render();
127     insert(data, d-&gt;APELocation, d-&gt;APESize);
128     if(d-&gt;ID3v1Location &gt;= 0)
129       d-&gt;ID3v1Location += (static_cast&lt;long&gt;(data.size()) - d-&gt;APESize);
130     d-&gt;APESize = data.size();
131   }
132   else {
133     if(d-&gt;APELocation &gt;= 0) {
134       removeBlock(d-&gt;APELocation, d-&gt;APESize);
135       if(d-&gt;ID3v1Location &gt;= 0)
136 <a name="2"></a>        d-&gt;ID3v1Location -= d-&gt;APESize;
137       d-&gt;APELocation = -1;
138 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      d-&gt;APESize = 0;
139     }
140   }
141   return true;
142 }
143 ID3v1::Tag *MPC::File::ID3v1Tag(bool create)
144 {
145   return d-&gt;tag.access&lt;ID3v1::Tag&gt;(MPCID3v1Index, create);
146 }
147 APE::Tag *MPC::File::APETag(bool create)
148 {
149   return d-&gt;tag.access&lt;APE::Tag&gt;(MPCAPEIndex, create);
150 }</b></font>
151 void MPC::File::strip(int tags)
152 {
153   if(tags &amp; ID3v1)
154     d-&gt;tag.set(MPCID3v1Index, 0);
155   if(tags &amp; APE)
156     d-&gt;tag.set(MPCAPEIndex, 0);
157   if(!ID3v1Tag())
158     APETag(true);
159   if(tags &amp; ID3v2) {
160     delete d-&gt;ID3v2Header;
161     d-&gt;ID3v2Header = 0;
162   }
163 }
164 <a name="1"></a>void MPC::File::remove(int tags)
165 {
166   strip(tags);
167 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
168 bool MPC::File::hasID3v1Tag() const
169 {
170   return (d-&gt;ID3v1Location &gt;= 0);
171 }
172 bool MPC::File::hasAPETag() const
173 {
174   return (d-&gt;APELocation &gt;= 0);
175 }
176 void MPC::File::read(bool readProperties)
177 {
178   d-&gt;ID3v2Location = Utils::findID3v2(this);
179   if(d-&gt;ID3v2Location &gt;= 0) {</b></font>
180     seek(d-&gt;ID3v2Location);
181     d-&gt;ID3v2Header = new ID3v2::Header(readBlock(ID3v2::Header::size()));
182     d-&gt;ID3v2Size = d-&gt;ID3v2Header-&gt;completeTagSize();
183   }
184   d-&gt;ID3v1Location = Utils::findID3v1(this);
185   if(d-&gt;ID3v1Location &gt;= 0)
186     d-&gt;tag.set(MPCID3v1Index, new ID3v1::Tag(this, d-&gt;ID3v1Location));
187   d-&gt;APELocation = Utils::findAPE(this, d-&gt;ID3v1Location);
188   if(d-&gt;APELocation &gt;= 0) {
189     d-&gt;tag.set(MPCAPEIndex, new APE::Tag(this, d-&gt;APELocation));
190     d-&gt;APESize = APETag()-&gt;footer()-&gt;completeTagSize();
191     d-&gt;APELocation = d-&gt;APELocation + APE::Footer::size() - d-&gt;APESize;
192   }
193   if(d-&gt;ID3v1Location &lt; 0)
194     APETag(true);
195   if(readProperties) {
196     long streamLength;
197     if(d-&gt;APELocation &gt;= 0)
198       streamLength = d-&gt;APELocation;
199     else if(d-&gt;ID3v1Location &gt;= 0)
200       streamLength = d-&gt;ID3v1Location;
201     else
202       streamLength = length();
203     if(d-&gt;ID3v2Location &gt;= 0) {
204       seek(d-&gt;ID3v2Location + d-&gt;ID3v2Size);
205       streamLength -= (d-&gt;ID3v2Location + d-&gt;ID3v2Size);
206     }
207     else {
208       seek(0);
209     }
210     d-&gt;properties = new Properties(this, streamLength);
211   }
212 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>flacfile.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;tbytevector.h&gt;
2 #include &lt;tstring.h&gt;
3 #include &lt;tlist.h&gt;
4 #include &lt;tdebug.h&gt;
5 #include &lt;tagunion.h&gt;
6 #include &lt;tpropertymap.h&gt;
7 #include &lt;tagutils.h&gt;
8 #include &lt;id3v2header.h&gt;
9 #include &lt;id3v2tag.h&gt;
10 #include &lt;id3v1tag.h&gt;
11 #include &lt;xiphcomment.h&gt;
12 #include "flacpicture.h"
13 #include "flacfile.h"
14 #include "flacmetadatablock.h"
15 #include "flacunknownmetadatablock.h"
16 using namespace TagLib;
17 namespace
18 {
19   typedef List&lt;FLAC::MetadataBlock *&gt; BlockList;
20   typedef BlockList::Iterator BlockIterator;
21   typedef BlockList::Iterator BlockConstIterator;
22   enum { FlacXiphIndex = 0, FlacID3v2Index = 1, FlacID3v1Index = 2 };
23   const long MinPaddingLength = 4096;
24   const long MaxPaddingLegnth = 1024 * 1024;
25   const char LastBlockFlag = '\x80';
26 }  
27 class FLAC::File::FilePrivate
28 {
29 public:
30   FilePrivate(const ID3v2::FrameFactory *frameFactory = ID3v2::FrameFactory::instance()) :
31     ID3v2FrameFactory(frameFactory),
32     ID3v2Location(-1),
33     ID3v2OriginalSize(0),
34     ID3v1Location(-1),
35     properties(0),
36     flacStart(0),
37     streamStart(0),
38     scanned(false)
39   {
40     blocks.setAutoDelete(true);
41   }
42   ~FilePrivate()
43   {
44     delete properties;
45   }
46   const ID3v2::FrameFactory *ID3v2FrameFactory;
47   long ID3v2Location;
48   long ID3v2OriginalSize;
49   long ID3v1Location;
50   TagUnion tag;
51   Properties *properties;
52 <a name="3"></a>  ByteVector xiphCommentData;
53   BlockList blocks;
54 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  long flacStart;
55   long streamStart;
56   bool scanned;
57 };
58 bool FLAC::File::isSupported(IOStream *stream)
59 {
60   const ByteVector buffer = Utils::readHeader(stream, bufferSize(), true);
61   return (buffer.find("fLaC") &gt;= 0);
62 }
63 FLAC::File::File(FileName file, bool readProperties, Properties::ReadStyle) :
64   TagLib::File(file),
65   d(new FilePrivate())
66 {
67   if(isOpen())
68     read(readProperties);
69 }</b></font>
70 FLAC::File::File(FileName file, ID3v2::FrameFactory *frameFactory,
71                  bool readProperties, Properties::ReadStyle) :
72   TagLib::File(file),
73   d(new FilePrivate(frameFactory))
74 {
75   if(isOpen())
76 <a name="0"></a>    read(readProperties);
77 }
78 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>FLAC::File::File(IOStream *stream, ID3v2::FrameFactory *frameFactory,
79                  bool readProperties, Properties::ReadStyle) :
80   TagLib::File(stream),
81   d(new FilePrivate(frameFactory))
82 {
83   if(isOpen())
84     read(readProperties);
85 }
86 FLAC::File::~File()
87 {
88   delete d;
89 }
90 TagLib::Tag *FLAC::File::tag() const
91 {
92   return &amp;d-&gt;tag;
93 }
94 PropertyMap FLAC::File::properties() const
95 {
96   return d-&gt;tag.properties();
97 }
98 void FLAC::File::removeUnsupportedProperties(const StringList &amp;unsupported)
99 {
100   d-&gt;tag.removeUnsupportedProperties(unsupported);
101 }
102 <a name="4"></a>
103 PropertyMap FLAC::File::setProperties(const PropertyMap &amp;properties)
104 {</b></font>
105 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  return xiphComment(true)-&gt;setProperties(properties);
106 }
107 FLAC::Properties *FLAC::File::audioProperties() const
108 {
109   return d-&gt;properties;
110 }
111 bool FLAC::File::save()
112 {
113   if(readOnly()) {
114     debug("FLAC::File::save() - Cannot save to a read only file.");
115     return false;
116   }
117   if(!isValid()) {</b></font>
118     debug("FLAC::File::save() -- Trying to save invalid file.");
119     return false;
120   }
121   if(!hasXiphComment())
122     Tag::duplicate(&amp;d-&gt;tag, xiphComment(true), false);
123   d-&gt;xiphCommentData = xiphComment()-&gt;render(false);
124   MetadataBlock *commentBlock =
125       new UnknownMetadataBlock(MetadataBlock::VorbisComment, d-&gt;xiphCommentData);
126   for(BlockIterator it = d-&gt;blocks.begin(); it != d-&gt;blocks.end();) {
127     if((*it)-&gt;code() == MetadataBlock::VorbisComment) {
128       delete *it;
129       it = d-&gt;blocks.erase(it);
130       continue;
131     }
132     if(commentBlock &amp;&amp; (*it)-&gt;code() == MetadataBlock::Picture) {
133       d-&gt;blocks.insert(it, commentBlock);
134       commentBlock = 0;
135     }
136     ++it;
137   }
138   if(commentBlock)
139     d-&gt;blocks.append(commentBlock);
140   ByteVector data;
141   for(BlockConstIterator it = d-&gt;blocks.begin(); it != d-&gt;blocks.end(); ++it) {
142     ByteVector blockData = (*it)-&gt;render();
143     ByteVector blockHeader = ByteVector::fromUInt(blockData.size());
144     blockHeader[0] = (*it)-&gt;code();
145     data.append(blockHeader);
146     data.append(blockData);
147   }
148   long originalLength = d-&gt;streamStart - d-&gt;flacStart;
149   long paddingLength = originalLength - data.size() - 4;
150   if(paddingLength &lt;= 0) {
151     paddingLength = MinPaddingLength;
152   }
153   else {
154     long threshold = length() / 100;
155     threshold = std::max(threshold, MinPaddingLength);
156     threshold = std::min(threshold, MaxPaddingLegnth);
157     if(paddingLength &gt; threshold)
158       paddingLength = MinPaddingLength;
159   }
160   ByteVector paddingHeader = ByteVector::fromUInt(paddingLength);
161   paddingHeader[0] = static_cast&lt;char&gt;(MetadataBlock::Padding | LastBlockFlag);
162   data.append(paddingHeader);
163   data.resize(static_cast&lt;unsigned int&gt;(data.size() + paddingLength));
164   insert(data, d-&gt;flacStart, originalLength);
165   d-&gt;streamStart += (static_cast&lt;long&gt;(data.size()) - originalLength);
166   if(d-&gt;ID3v1Location &gt;= 0)
167     d-&gt;ID3v1Location += (static_cast&lt;long&gt;(data.size()) - originalLength);
168   if(ID3v2Tag() &amp;&amp; !ID3v2Tag()-&gt;isEmpty()) {
169     if(d-&gt;ID3v2Location &lt; 0)
170       d-&gt;ID3v2Location = 0;
171     data = ID3v2Tag()-&gt;render();
172     insert(data, d-&gt;ID3v2Location, d-&gt;ID3v2OriginalSize);
173     d-&gt;flacStart   += (static_cast&lt;long&gt;(data.size()) - d-&gt;ID3v2OriginalSize);
174     d-&gt;streamStart += (static_cast&lt;long&gt;(data.size()) - d-&gt;ID3v2OriginalSize);
175     if(d-&gt;ID3v1Location &gt;= 0)
176       d-&gt;ID3v1Location += (static_cast&lt;long&gt;(data.size()) - d-&gt;ID3v2OriginalSize);
177     d-&gt;ID3v2OriginalSize = data.size();
178   }
179   else {
180     if(d-&gt;ID3v2Location &gt;= 0) {
181       removeBlock(d-&gt;ID3v2Location, d-&gt;ID3v2OriginalSize);
182       d-&gt;flacStart   -= d-&gt;ID3v2OriginalSize;
183       d-&gt;streamStart -= d-&gt;ID3v2OriginalSize;
184       if(d-&gt;ID3v1Location &gt;= 0)
185         d-&gt;ID3v1Location -= d-&gt;ID3v2OriginalSize;
186 <a name="5"></a>      d-&gt;ID3v2Location = -1;
187       d-&gt;ID3v2OriginalSize = 0;
188     }
189 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
190   if(ID3v1Tag() &amp;&amp; !ID3v1Tag()-&gt;isEmpty()) {
191     if(d-&gt;ID3v1Location &gt;= 0) {
192       seek(d-&gt;ID3v1Location);
193     }
194     else {
195       seek(0, End);
196       d-&gt;ID3v1Location = tell();
197     }
198     writeBlock(ID3v1Tag()-&gt;render());
199   }
200   else {
201 <a name="2"></a>
202     if(d-&gt;ID3v1Location &gt;= 0) {</b></font>
203       truncate(d-&gt;ID3v1Location);
204 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      d-&gt;ID3v1Location = -1;
205     }
206   }
207   return true;
208 }
209 ID3v2::Tag *FLAC::File::ID3v2Tag(bool create)
210 {
211   return d-&gt;tag.access&lt;ID3v2::Tag&gt;(FlacID3v2Index, create);
212 }
213 ID3v1::Tag *FLAC::File::ID3v1Tag(bool create)
214 {
215   return d-&gt;tag.access&lt;ID3v1::Tag&gt;(FlacID3v1Index, create);
216 }</b></font>
217 Ogg::XiphComment *FLAC::File::xiphComment(bool create)
218 {
219   return d-&gt;tag.access&lt;Ogg::XiphComment&gt;(FlacXiphIndex, create);
220 }
221 void FLAC::File::setID3v2FrameFactory(const ID3v2::FrameFactory *factory)
222 {
223   d-&gt;ID3v2FrameFactory = factory;
224 }
225 ByteVector FLAC::File::streamInfoData()
226 {
227   debug("FLAC::File::streamInfoData() -- This function is obsolete. Returning an empty ByteVector.");
228   return ByteVector();
229 }
230 long FLAC::File::streamLength()
231 {
232   debug("FLAC::File::streamLength() -- This function is obsolete. Returning zero.");
233   return 0;
234 }
235 List&lt;FLAC::Picture *&gt; FLAC::File::pictureList()
236 {
237   List&lt;Picture *&gt; pictures;
238   for(BlockConstIterator it = d-&gt;blocks.begin(); it != d-&gt;blocks.end(); ++it) {
239     Picture *picture = dynamic_cast&lt;Picture *&gt;(*it);
240     if(picture) {
241       pictures.append(picture);
242     }
243   }
244   return pictures;
245 }
246 void FLAC::File::addPicture(Picture *picture)
247 {
248   d-&gt;blocks.append(picture);
249 }
250 void FLAC::File::removePicture(Picture *picture, bool del)
251 {
252   BlockIterator it = d-&gt;blocks.find(picture);
253   if(it != d-&gt;blocks.end())
254     d-&gt;blocks.erase(it);
255   if(del)
256     delete picture;
257 }
258 void FLAC::File::removePictures()
259 {
260   for(BlockIterator it = d-&gt;blocks.begin(); it != d-&gt;blocks.end(); ) {
261     if(dynamic_cast&lt;Picture *&gt;(*it)) {
262       delete *it;
263       it = d-&gt;blocks.erase(it);
264     }
265     else {
266       ++it;
267     }
268   }
269 }
270 void FLAC::File::strip(int tags)
271 {
272   if(tags &amp; ID3v1)
273     d-&gt;tag.set(FlacID3v1Index, 0);
274   if(tags &amp; ID3v2)
275     d-&gt;tag.set(FlacID3v2Index, 0);
276   if(tags &amp; XiphComment) {
277     xiphComment()-&gt;removeAllFields();
278     xiphComment()-&gt;removeAllPictures();
279   }
280 }
281 <a name="1"></a>bool FLAC::File::hasXiphComment() const
282 {
283   return !d-&gt;xiphCommentData.isEmpty();
284 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
285 bool FLAC::File::hasID3v1Tag() const
286 {
287   return (d-&gt;ID3v1Location &gt;= 0);
288 }
289 bool FLAC::File::hasID3v2Tag() const
290 {
291   return (d-&gt;ID3v2Location &gt;= 0);
292 }
293 void FLAC::File::read(bool readProperties)
294 {
295   d-&gt;ID3v2Location = Utils::findID3v2(this);
296   if(d-&gt;ID3v2Location &gt;= 0) {</b></font>
297     d-&gt;tag.set(FlacID3v2Index, new ID3v2::Tag(this, d-&gt;ID3v2Location, d-&gt;ID3v2FrameFactory));
298     d-&gt;ID3v2OriginalSize = ID3v2Tag()-&gt;header()-&gt;completeTagSize();
299   }
300   d-&gt;ID3v1Location = Utils::findID3v1(this);
301   if(d-&gt;ID3v1Location &gt;= 0)
302     d-&gt;tag.set(FlacID3v1Index, new ID3v1::Tag(this, d-&gt;ID3v1Location));
303   scan();
304   if(!isValid())
305     return;
306   if(!d-&gt;xiphCommentData.isEmpty())
307     d-&gt;tag.set(FlacXiphIndex, new Ogg::XiphComment(d-&gt;xiphCommentData));
308   else
309     d-&gt;tag.set(FlacXiphIndex, new Ogg::XiphComment());
310   if(readProperties) {
311     const ByteVector infoData = d-&gt;blocks.front()-&gt;render();
312     long streamLength;
313     if(d-&gt;ID3v1Location &gt;= 0)
314       streamLength = d-&gt;ID3v1Location - d-&gt;streamStart;
315     else
316       streamLength = length() - d-&gt;streamStart;
317     d-&gt;properties = new Properties(infoData, streamLength);
318   }
319 }
320 void FLAC::File::scan()
321 {
322   if(d-&gt;scanned)
323     return;
324   if(!isValid())
325     return;
326   long nextBlockOffset;
327   if(d-&gt;ID3v2Location &gt;= 0)
328     nextBlockOffset = find("fLaC", d-&gt;ID3v2Location + d-&gt;ID3v2OriginalSize);
329   else
330     nextBlockOffset = find("fLaC");
331   if(nextBlockOffset &lt; 0) {
332     debug("FLAC::File::scan() -- FLAC stream not found");
333     setValid(false);
334     return;
335   }
336   nextBlockOffset += 4;
337   d-&gt;flacStart = nextBlockOffset;
338   while(true) {
339     seek(nextBlockOffset);
340     const ByteVector header = readBlock(4);
341     if(header.size() != 4) {
342       debug("FLAC::File::scan() -- Failed to read a block header");
343       setValid(false);
344       return;
345     }
346     const char blockType = header[0] &amp; ~LastBlockFlag;
347     const bool isLastBlock = (header[0] &amp; LastBlockFlag) != 0;
348     const unsigned int blockLength = header.toUInt(1U, 3U);
349     if(d-&gt;blocks.isEmpty() &amp;&amp; blockType != MetadataBlock::StreamInfo) {
350       debug("FLAC::File::scan() -- First block should be the stream_info metadata");
351       setValid(false);
352       return;
353     }
354     if(blockLength == 0
355       &amp;&amp; blockType != MetadataBlock::Padding &amp;&amp; blockType != MetadataBlock::SeekTable)
356     {
357       debug("FLAC::File::scan() -- Zero-sized metadata block found");
358       setValid(false);
359       return;
360     }
361     const ByteVector data = readBlock(blockLength);
362     if(data.size() != blockLength) {
363       debug("FLAC::File::scan() -- Failed to read a metadata block");
364       setValid(false);
365       return;
366     }
367     MetadataBlock *block = 0;
368     if(blockType == MetadataBlock::VorbisComment) {
369       if(d-&gt;xiphCommentData.isEmpty()) {
370         d-&gt;xiphCommentData = data;
371         block = new UnknownMetadataBlock(MetadataBlock::VorbisComment, data);
372       }
373       else {
374         debug("FLAC::File::scan() -- multiple Vorbis Comment blocks found, discarding");
375       }
376     }
377     else if(blockType == MetadataBlock::Picture) {
378       FLAC::Picture *picture = new FLAC::Picture();
379       if(picture-&gt;parse(data)) {
380         block = picture;
381       }
382       else {
383         debug("FLAC::File::scan() -- invalid picture found, discarding");
384         delete picture;
385       }
386     }
387     else if(blockType == MetadataBlock::Padding) {
388     }
389     else {
390       block = new UnknownMetadataBlock(blockType, data);
391     }
392     if(block)
393       d-&gt;blocks.append(block);
394     nextBlockOffset += blockLength + 4;
395     if(isLastBlock)
396       break;
397   }
398   d-&gt;streamStart = nextBlockOffset;
399   d-&gt;scanned = true;
400 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
