
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 58, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_ring.h"
2  #include <cassert>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iostream>
6  #include <limits>
7  #include <memory>
8  #include <string>
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/internal/throw_delegate.h"
11  #include "absl/base/macros.h"
12  #include "absl/container/inlined_vector.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_consume.h"
15  #include "absl/strings/internal/cord_rep_flat.h"
16  namespace absl {
17  ABSL_NAMESPACE_BEGIN
18  namespace cord_internal {
19  namespace {
20  using index_type = CordRepRing::index_type;
21  enum class Direction { kForward, kReversed };
22  inline bool IsFlatOrExternal(CordRep* rep) {
23    return rep->IsFlat() || rep->IsExternal();
24  }
25  inline void CheckCapacity(size_t n, size_t extra) {
26    if (ABSL_PREDICT_FALSE(extra > CordRepRing::kMaxCapacity - n)) {
27      base_internal::ThrowStdLengthError("Maximum capacity exceeded");
28    }
29  }
30  CordRepFlat* CreateFlat(const char* s, size_t n, size_t extra = 0) {  
31    assert(n <= kMaxFlatLength);
32    auto* rep = CordRepFlat::New(n + extra);
33    rep->length = n;
34    memcpy(rep->Data(), s, n);
35    return rep;
36  }
37  void UnrefEntries(const CordRepRing* rep, index_type head, index_type tail) {
38    rep->ForEach(head, tail, [rep](index_type ix) {
39      CordRep* child = rep->entry_child(ix);
40      if (!child->refcount.Decrement()) {
41        if (child->tag >= FLAT) {
42          CordRepFlat::Delete(child->flat());
43        } else {
44          CordRepExternal::Delete(child->external());
45        }
46      }
47    });
48  }
49  }  
50  std::ostream& operator<<(std::ostream& s, const CordRepRing& rep) {
51    s << "  CordRepRing(" << &rep << ", length = " << rep.length
52      << ", head = " << rep.head_ << ", tail = " << rep.tail_
53      << ", cap = " << rep.capacity_ << ", rc = " << rep.refcount.Get()
54      << ", begin_pos_ = " << static_cast<ptrdiff_t>(rep.begin_pos_) << ") {\n";
55    CordRepRing::index_type head = rep.head();
56    do {
57      CordRep* child = rep.entry_child(head);
58      s << " entry[" << head << "] length = " << rep.entry_length(head)
59        << ", child " << child << ", clen = " << child->length
60        << ", tag = " << static_cast<int>(child->tag)
61        << ", rc = " << child->refcount.Get()
62        << ", offset = " << rep.entry_data_offset(head)
63        << ", end_pos = " << static_cast<ptrdiff_t>(rep.entry_end_pos(head))
64        << "\n";
65      head = rep.advance(head);
66    } while (head != rep.tail());
67    return s << "}\n";
68  }
69  void CordRepRing::AddDataOffset(index_type index, size_t n) {
70    entry_data_offset()[index] += static_cast<offset_type>(n);
71  }
72  void CordRepRing::SubLength(index_type index, size_t n) {
73    entry_end_pos()[index] -= n;
74  }
75  class CordRepRing::Filler {
76   public:
77    Filler(CordRepRing* rep, index_type pos) : rep_(rep), head_(pos), pos_(pos) {}
78    index_type head() const { return head_; }
79    index_type pos() const { return pos_; }
80    void Add(CordRep* child, size_t offset, pos_type end_pos) {
81      rep_->entry_end_pos()[pos_] = end_pos;
82      rep_->entry_child()[pos_] = child;
83      rep_->entry_data_offset()[pos_] = static_cast<offset_type>(offset);
84      pos_ = rep_->advance(pos_);
85    }
86   private:
87    CordRepRing* rep_;
88    index_type head_;
89    index_type pos_;
90  };
91  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
92  constexpr size_t CordRepRing::kMaxCapacity;
93  #endif
94  bool CordRepRing::IsValid(std::ostream& output) const {
95    if (capacity_ == 0) {
96      output << "capacity == 0";
97      return false;
98    }
99    if (head_ >= capacity_ || tail_ >= capacity_) {
100      output << "head " << head_ << " and/or tail " << tail_ << "exceed capacity "
101             << capacity_;
102      return false;
103    }
104    const index_type back = retreat(tail_);
105    size_t pos_length = Distance(begin_pos_, entry_end_pos(back));
106    if (pos_length != length) {
107      output << "length " << length << " does not match positional length "
108             << pos_length << " from begin_pos " << begin_pos_ << " and entry["
109             << back << "].end_pos " << entry_end_pos(back);
110      return false;
111    }
112    index_type head = head_;
113    pos_type begin_pos = begin_pos_;
114    do {
115      pos_type end_pos = entry_end_pos(head);
116      size_t entry_length = Distance(begin_pos, end_pos);
117      if (entry_length == 0) {
118        output << "entry[" << head << "] has an invalid length " << entry_length
119               << " from begin_pos " << begin_pos << " and end_pos " << end_pos;
120        return false;
121      }
122      CordRep* child = entry_child(head);
123      if (child == nullptr) {
124        output << "entry[" << head << "].child == nullptr";
125        return false;
126      }
127      if (child->tag < FLAT && child->tag != EXTERNAL) {
128        output << "entry[" << head << "].child has an invalid tag "
129               << static_cast<int>(child->tag);
130        return false;
131      }
132      size_t offset = entry_data_offset(head);
133      if (offset >= child->length || entry_length > child->length - offset) {
134        output << "entry[" << head << "] has offset " << offset
135               << " and entry length " << entry_length
136               << " which are outside of the child's length of " << child->length;
137        return false;
138      }
139      begin_pos = end_pos;
140      head = advance(head);
141    } while (head != tail_);
142    return true;
143  }
144  #ifdef EXTRA_CORD_RING_VALIDATION
145  CordRepRing* CordRepRing::Validate(CordRepRing* rep, const char* file,
146                                     int line) {
147    if (!rep->IsValid(std::cerr)) {
148      std::cerr << "\nERROR: CordRepRing corrupted";
149      if (line) std::cerr << " at line " << line;
150      if (file) std::cerr << " in file " << file;
151      std::cerr << "\nContent = " << *rep;
152      abort();
153    }
154    return rep;
155  }
156  #endif  
157  CordRepRing* CordRepRing::New(size_t capacity, size_t extra) {
158    CheckCapacity(capacity, extra);
159    size_t size = AllocSize(capacity += extra);
160    void* mem = ::operator new(size);
161    auto* rep = new (mem) CordRepRing(static_cast<index_type>(capacity));
162    rep->tag = RING;
163    rep->capacity_ = static_cast<index_type>(capacity);
164    rep->begin_pos_ = 0;
165    return rep;
166  }
167  void CordRepRing::SetCapacityForTesting(size_t capacity) {
168    assert(capacity <= capacity_);
169    assert(head() == 0 || head() < tail());
170    memmove(Layout::Partial(capacity).Pointer<1>(data_) + head(),
171            Layout::Partial(capacity_).Pointer<1>(data_) + head(),
172            entries() * sizeof(Layout::ElementType<1>));
173    memmove(Layout::Partial(capacity, capacity).Pointer<2>(data_) + head(),
174            Layout::Partial(capacity_, capacity_).Pointer<2>(data_) + head(),
175            entries() * sizeof(Layout::ElementType<2>));
176    capacity_ = static_cast<index_type>(capacity);
177  }
178  void CordRepRing::Delete(CordRepRing* rep) {
179    assert(rep != nullptr && rep->IsRing());
180  #if defined(__cpp_sized_deallocation)
181    size_t size = AllocSize(rep->capacity_);
182    rep->~CordRepRing();
183    ::operator delete(rep, size);
184  #else
185    rep->~CordRepRing();
186    ::operator delete(rep);
187  #endif
188  }
189  void CordRepRing::Destroy(CordRepRing* rep) {
190    UnrefEntries(rep, rep->head(), rep->tail());
191    Delete(rep);
192  }
193  template <bool ref>
194  void CordRepRing::Fill(const CordRepRing* src, index_type head,
195                         index_type tail) {
196    this->length = src->length;
197    head_ = 0;
198    tail_ = advance(0, src->entries(head, tail));
199    begin_pos_ = src->begin_pos_;
200    auto* dst_pos = entry_end_pos();
201    auto* dst_child = entry_child();
202    auto* dst_offset = entry_data_offset();
203    src->ForEach(head, tail, [&](index_type index) {
204      *dst_pos++ = src->entry_end_pos(index);
205      CordRep* child = src->entry_child(index);
206      *dst_child++ = ref ? CordRep::Ref(child) : child;
207      *dst_offset++ = src->entry_data_offset(index);
208    });
209  }
210  CordRepRing* CordRepRing::Copy(CordRepRing* rep, index_type head,
211                                 index_type tail, size_t extra) {
212    CordRepRing* newrep = CordRepRing::New(rep->entries(head, tail), extra);
213    newrep->Fill<true>(rep, head, tail);
214    CordRep::Unref(rep);
215    return newrep;
216  }
217  CordRepRing* CordRepRing::Mutable(CordRepRing* rep, size_t extra) {
218    size_t entries = rep->entries();
219    if (!rep->refcount.IsOne()) {
220      return Copy(rep, rep->head(), rep->tail(), extra);
221    } else if (entries + extra > rep->capacity()) {
222      const size_t min_grow = rep->capacity() + rep->capacity() / 2;
223      const size_t min_extra = (std::max)(extra, min_grow - entries);
224      CordRepRing* newrep = CordRepRing::New(entries, min_extra);
225      newrep->Fill<false>(rep, rep->head(), rep->tail());
226      CordRepRing::Delete(rep);
227      return newrep;
228    } else {
229      return rep;
230    }
231  }
232  Span<char> CordRepRing::GetAppendBuffer(size_t size) {
233    assert(refcount.IsOne());
234    index_type back = retreat(tail_);
235    CordRep* child = entry_child(back);
236    if (child->tag >= FLAT && child->refcount.IsOne()) {
237      size_t capacity = child->flat()->Capacity();
238      pos_type end_pos = entry_end_pos(back);
239      size_t data_offset = entry_data_offset(back);
240      size_t entry_length = Distance(entry_begin_pos(back), end_pos);
241      size_t used = data_offset + entry_length;
242      if (size_t n = (std::min)(capacity - used, size)) {
243        child->length = data_offset + entry_length + n;
244        entry_end_pos()[back] = end_pos + n;
245        this->length += n;
246        return {child->flat()->Data() + used, n};
247      }
248    }
249    return {nullptr, 0};
250  }
251  Span<char> CordRepRing::GetPrependBuffer(size_t size) {
252    assert(refcount.IsOne());
253    CordRep* child = entry_child(head_);
254    size_t data_offset = entry_data_offset(head_);
255    if (data_offset && child->refcount.IsOne() && child->tag >= FLAT) {
256      size_t n = (std::min)(data_offset, size);
257      this->length += n;
258      begin_pos_ -= n;
259      data_offset -= n;
260      entry_data_offset()[head_] = static_cast<offset_type>(data_offset);
261      return {child->flat()->Data() + data_offset, n};
262    }
263    return {nullptr, 0};
264  }
265  CordRepRing* CordRepRing::CreateFromLeaf(CordRep* child, size_t offset,
266                                           size_t len, size_t extra) {
267    CordRepRing* rep = CordRepRing::New(1, extra);
268    rep->head_ = 0;
269    rep->tail_ = rep->advance(0);
270    rep->length = len;
271    rep->entry_end_pos()[0] = len;
272    rep->entry_child()[0] = child;
273    rep->entry_data_offset()[0] = static_cast<offset_type>(offset);
274    return Validate(rep);
275  }
276  CordRepRing* CordRepRing::CreateSlow(CordRep* child, size_t extra) {
277    CordRepRing* rep = nullptr;
278    Consume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
279      if (IsFlatOrExternal(child_arg)) {
280        rep = rep ? AppendLeaf(rep, child_arg, offset, len)
281                  : CreateFromLeaf(child_arg, offset, len, extra);
282      } else if (rep) {
283        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
284      } else if (offset == 0 && child_arg->length == len) {
285        rep = Mutable(child_arg->ring(), extra);
286      } else {
287        rep = SubRing(child_arg->ring(), offset, len, extra);
288      }
289    });
290    return Validate(rep, nullptr, __LINE__);
291  }
292  CordRepRing* CordRepRing::Create(CordRep* child, size_t extra) {
293    size_t length = child->length;
294    if (IsFlatOrExternal(child)) {
295      return CreateFromLeaf(child, 0, length, extra);
296    }
297    if (child->IsRing()) {
298      return Mutable(child->ring(), extra);
299    }
300    return CreateSlow(child, extra);
301  }
302  template <CordRepRing::AddMode mode>
303  CordRepRing* CordRepRing::AddRing(CordRepRing* rep, CordRepRing* ring,
304                                    size_t offset, size_t len) {
305    assert(offset < ring->length);
306    constexpr bool append = mode == AddMode::kAppend;
307    Position head = ring->Find(offset);
308    Position tail = ring->FindTail(head.index, offset + len);
309    const index_type entries = ring->entries(head.index, tail.index);
310    rep = Mutable(rep, entries);
311    const pos_type delta_length =
312        (append ? rep->begin_pos_ + rep->length : rep->begin_pos_ - len) -
313        ring->entry_begin_pos(head.index) - head.offset;
314    Filler filler(rep, append ? rep->tail_ : rep->retreat(rep->head_, entries));
315    if (ring->refcount.IsOne()) {
316      ring->ForEach(head.index, tail.index, [&](index_type ix) {
317        filler.Add(ring->entry_child(ix), ring->entry_data_offset(ix),
318                   ring->entry_end_pos(ix) + delta_length);
319      });
320      if (head.index != ring->head_) UnrefEntries(ring, ring->head_, head.index);
321      if (tail.index != ring->tail_) UnrefEntries(ring, tail.index, ring->tail_);
322      CordRepRing::Delete(ring);
323    } else {
324      ring->ForEach(head.index, tail.index, [&](index_type ix) {
325        CordRep* child = ring->entry_child(ix);
326        filler.Add(child, ring->entry_data_offset(ix),
327                   ring->entry_end_pos(ix) + delta_length);
328        CordRep::Ref(child);
329      });
330      CordRepRing::Unref(ring);
331    }
332    if (head.offset) {
333      rep->AddDataOffset(filler.head(), head.offset);
334    }
335    if (tail.offset) {
336      rep->SubLength(rep->retreat(filler.pos()), tail.offset);
337    }
338    rep->length += len;
339    if (append) {
340      rep->tail_ = filler.pos();
341    } else {
342      rep->head_ = filler.head();
343      rep->begin_pos_ -= len;
344    }
345    return Validate(rep);
346  }
347  CordRepRing* CordRepRing::AppendSlow(CordRepRing* rep, CordRep* child) {
348    Consume(child, [&rep](CordRep* child_arg, size_t offset, size_t len) {
349      if (child_arg->IsRing()) {
350        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
351      } else {
352        rep = AppendLeaf(rep, child_arg, offset, len);
353      }
354    });
355    return rep;
356  }
357  CordRepRing* CordRepRing::AppendLeaf(CordRepRing* rep, CordRep* child,
358                                       size_t offset, size_t len) {
359    rep = Mutable(rep, 1);
360    index_type back = rep->tail_;
361    const pos_type begin_pos = rep->begin_pos_ + rep->length;
362    rep->tail_ = rep->advance(rep->tail_);
363    rep->length += len;
364    rep->entry_end_pos()[back] = begin_pos + len;
365    rep->entry_child()[back] = child;
366    rep->entry_data_offset()[back] = static_cast<offset_type>(offset);
367    return Validate(rep, nullptr, __LINE__);
368  }
369  CordRepRing* CordRepRing::Append(CordRepRing* rep, CordRep* child) {
370    size_t length = child->length;
371    if (IsFlatOrExternal(child)) {
372      return AppendLeaf(rep, child, 0, length);
373    }
374    if (child->IsRing()) {
375      return AddRing<AddMode::kAppend>(rep, child->ring(), 0, length);
376    }
377    return AppendSlow(rep, child);
378  }
379  CordRepRing* CordRepRing::PrependSlow(CordRepRing* rep, CordRep* child) {
380    ReverseConsume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
381      if (IsFlatOrExternal(child_arg)) {
382        rep = PrependLeaf(rep, child_arg, offset, len);
383      } else {
384        rep = AddRing<AddMode::kPrepend>(rep, child_arg->ring(), offset, len);
385      }
386    });
387    return Validate(rep);
388  }
389  CordRepRing* CordRepRing::PrependLeaf(CordRepRing* rep, CordRep* child,
390                                        size_t offset, size_t len) {
391    rep = Mutable(rep, 1);
392    index_type head = rep->retreat(rep->head_);
393    pos_type end_pos = rep->begin_pos_;
394    rep->head_ = head;
395    rep->length += len;
396    rep->begin_pos_ -= len;
397    rep->entry_end_pos()[head] = end_pos;
398    rep->entry_child()[head] = child;
399    rep->entry_data_offset()[head] = static_cast<offset_type>(offset);
400    return Validate(rep);
401  }
402  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, CordRep* child) {
403    size_t length = child->length;
404    if (IsFlatOrExternal(child)) {
405      return PrependLeaf(rep, child, 0, length);
406    }
407    if (child->IsRing()) {
408      return AddRing<AddMode::kPrepend>(rep, child->ring(), 0, length);
409    }
410    return PrependSlow(rep, child);
411  }
412  CordRepRing* CordRepRing::Append(CordRepRing* rep, absl::string_view data,
413                                   size_t extra) {
414    if (rep->refcount.IsOne()) {
415      Span<char> avail = rep->GetAppendBuffer(data.length());
416      if (!avail.empty()) {
417        memcpy(avail.data(), data.data(), avail.length());
418        data.remove_prefix(avail.length());
419      }
420    }
421    if (data.empty()) return Validate(rep);
422    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
423    rep = Mutable(rep, flats);
424    Filler filler(rep, rep->tail_);
425    pos_type pos = rep->begin_pos_ + rep->length;
426    while (data.length() >= kMaxFlatLength) {
427      auto* flat = CreateFlat(data.data(), kMaxFlatLength);
428      filler.Add(flat, 0, pos += kMaxFlatLength);
429      data.remove_prefix(kMaxFlatLength);
430    }
431    if (data.length()) {
432      auto* flat = CreateFlat(data.data(), data.length(), extra);
433      filler.Add(flat, 0, pos += data.length());
434    }
435    rep->length = pos - rep->begin_pos_;
436    rep->tail_ = filler.pos();
437    return Validate(rep);
438  }
439  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, absl::string_view data,
440                                    size_t extra) {
441    if (rep->refcount.IsOne()) {
442      Span<char> avail = rep->GetPrependBuffer(data.length());
443      if (!avail.empty()) {
444        const char* tail = data.data() + data.length() - avail.length();
445        memcpy(avail.data(), tail, avail.length());
446        data.remove_suffix(avail.length());
447      }
448    }
449    if (data.empty()) return rep;
450    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
451    rep = Mutable(rep, flats);
452    pos_type pos = rep->begin_pos_;
453    Filler filler(rep, rep->retreat(rep->head_, static_cast<index_type>(flats)));
454    size_t first_size = data.size() - (flats - 1) * kMaxFlatLength;
455    CordRepFlat* flat = CordRepFlat::New(first_size + extra);
456    flat->length = first_size + extra;
457    memcpy(flat->Data() + extra, data.data(), first_size);
458    data.remove_prefix(first_size);
459    filler.Add(flat, extra, pos);
460    pos -= first_size;
461    while (!data.empty()) {
462      assert(data.size() >= kMaxFlatLength);
463      flat = CreateFlat(data.data(), kMaxFlatLength);
464      filler.Add(flat, 0, pos);
465      pos -= kMaxFlatLength;
466      data.remove_prefix(kMaxFlatLength);
467    }
468    rep->head_ = filler.head();
469    rep->length += rep->begin_pos_ - pos;
470    rep->begin_pos_ = pos;
471    return Validate(rep);
472  }
473  static constexpr index_type kBinarySearchThreshold = 32;
474  static constexpr index_type kBinarySearchEndCount = 8;
475  template <bool wrap>
476  CordRepRing::index_type CordRepRing::FindBinary(index_type head,
477                                                  index_type tail,
478                                                  size_t offset) const {
479    index_type count = tail + (wrap ? capacity_ : 0) - head;
480    do {
481      count = (count - 1) / 2;
482      assert(count < entries(head, tail_));
483      index_type mid = wrap ? advance(head, count) : head + count;
484      index_type after_mid = wrap ? advance(mid) : mid + 1;
485      bool larger = (offset >= entry_end_offset(mid));
486      head = larger ? after_mid : head;
487      tail = larger ? tail : mid;
488      assert(head != tail);
489    } while (ABSL_PREDICT_TRUE(count > kBinarySearchEndCount));
490    return head;
491  }
492  CordRepRing::Position CordRepRing::FindSlow(index_type head,
493                                              size_t offset) const {
494    index_type tail = tail_;
495    if (tail > head) {
496      index_type count = tail - head;
497      if (count > kBinarySearchThreshold) {
<span onclick='openModal()' class='match'>498        head = FindBinary<false>(head, tail, offset);
499      }
500    } else {
501      index_type count = capacity_ + tail - head;
502      if (count > kBinarySearchThreshold) {
503        head = FindBinary<true>(head, tail, offset);
504      }
505    }
506    pos_type pos = entry_begin_pos(head);
507    pos_type end_pos = entry_end_pos(head);
</span>508    while (offset >= Distance(begin_pos_, end_pos)) {
509      head = advance(head);
510      pos = end_pos;
511      end_pos = entry_end_pos(head);
512    }
513    return {head, offset - Distance(begin_pos_, pos)};
514  }
515  CordRepRing::Position CordRepRing::FindTailSlow(index_type head,
516                                                  size_t offset) const {
517    index_type tail = tail_;
518    const size_t tail_offset = offset - 1;
519    if (tail > head) {
520      index_type count = tail - head;
521      if (count > kBinarySearchThreshold) {
522        head = FindBinary<false>(head, tail, tail_offset);
523      }
524    } else {
525      index_type count = capacity_ + tail - head;
526      if (count > kBinarySearchThreshold) {
527        head = FindBinary<true>(head, tail, tail_offset);
528      }
529    }
530    size_t end_offset = entry_end_offset(head);
531    while (tail_offset >= end_offset) {
532      head = advance(head);
533      end_offset = entry_end_offset(head);
534    }
535    return {advance(head), end_offset - offset};
536  }
537  char CordRepRing::GetCharacter(size_t offset) const {
538    assert(offset < length);
539    Position pos = Find(offset);
540    size_t data_offset = entry_data_offset(pos.index) + pos.offset;
541    return GetRepData(entry_child(pos.index))[data_offset];
542  }
543  CordRepRing* CordRepRing::SubRing(CordRepRing* rep, size_t offset,
544                                    size_t len, size_t extra) {
545    assert(offset <= rep->length);
546    assert(offset <= rep->length - len);
547    if (len == 0) {
548      CordRep::Unref(rep);
549      return nullptr;
550    }
551    Position head = rep->Find(offset);
552    Position tail = rep->FindTail(head.index, offset + len);
553    const size_t new_entries = rep->entries(head.index, tail.index);
554    if (rep->refcount.IsOne() && extra <= (rep->capacity() - new_entries)) {
555      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
556      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
557      rep->head_ = head.index;
558      rep->tail_ = tail.index;
559    } else {
560      rep = Copy(rep, head.index, tail.index, extra);
561      head.index = rep->head_;
562      tail.index = rep->tail_;
563    }
564    rep->length = len;
565    rep->begin_pos_ += offset;
566    if (head.offset) {
567      rep->AddDataOffset(head.index, head.offset);
568    }
569    if (tail.offset) {
570      rep->SubLength(rep->retreat(tail.index), tail.offset);
571    }
572    return Validate(rep);
573  }
574  CordRepRing* CordRepRing::RemovePrefix(CordRepRing* rep, size_t len,
575                                         size_t extra) {
576    assert(len <= rep->length);
577    if (len == rep->length) {
578      CordRep::Unref(rep);
579      return nullptr;
580    }
581    Position head = rep->Find(len);
582    if (rep->refcount.IsOne()) {
583      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
584      rep->head_ = head.index;
585    } else {
586      rep = Copy(rep, head.index, rep->tail_, extra);
587      head.index = rep->head_;
588    }
589    rep->length -= len;
590    rep->begin_pos_ += len;
591    if (head.offset) {
592      rep->AddDataOffset(head.index, head.offset);
593    }
594    return Validate(rep);
595  }
596  CordRepRing* CordRepRing::RemoveSuffix(CordRepRing* rep, size_t len,
597                                         size_t extra) {
598    assert(len <= rep->length);
599    if (len == rep->length) {
600      CordRep::Unref(rep);
601      return nullptr;
602    }
603    Position tail = rep->FindTail(rep->length - len);
604    if (rep->refcount.IsOne()) {
605      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
606      rep->tail_ = tail.index;
607    } else {
608      rep = Copy(rep, rep->head_, tail.index, extra);
609      tail.index = rep->tail_;
610    }
611    rep->length -= len;
612    if (tail.offset) {
613      rep->SubLength(rep->retreat(tail.index), tail.offset);
614    }
615    return Validate(rep);
616  }
617  }  
618  ABSL_NAMESPACE_END
619  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_ring.h"
2  #include <cassert>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iostream>
6  #include <limits>
7  #include <memory>
8  #include <string>
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/internal/throw_delegate.h"
11  #include "absl/base/macros.h"
12  #include "absl/container/inlined_vector.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_consume.h"
15  #include "absl/strings/internal/cord_rep_flat.h"
16  namespace absl {
17  ABSL_NAMESPACE_BEGIN
18  namespace cord_internal {
19  namespace {
20  using index_type = CordRepRing::index_type;
21  enum class Direction { kForward, kReversed };
22  inline bool IsFlatOrExternal(CordRep* rep) {
23    return rep->IsFlat() || rep->IsExternal();
24  }
25  inline void CheckCapacity(size_t n, size_t extra) {
26    if (ABSL_PREDICT_FALSE(extra > CordRepRing::kMaxCapacity - n)) {
27      base_internal::ThrowStdLengthError("Maximum capacity exceeded");
28    }
29  }
30  CordRepFlat* CreateFlat(const char* s, size_t n, size_t extra = 0) {  
31    assert(n <= kMaxFlatLength);
32    auto* rep = CordRepFlat::New(n + extra);
33    rep->length = n;
34    memcpy(rep->Data(), s, n);
35    return rep;
36  }
37  void UnrefEntries(const CordRepRing* rep, index_type head, index_type tail) {
38    rep->ForEach(head, tail, [rep](index_type ix) {
39      CordRep* child = rep->entry_child(ix);
40      if (!child->refcount.Decrement()) {
41        if (child->tag >= FLAT) {
42          CordRepFlat::Delete(child->flat());
43        } else {
44          CordRepExternal::Delete(child->external());
45        }
46      }
47    });
48  }
49  }  
50  std::ostream& operator<<(std::ostream& s, const CordRepRing& rep) {
51    s << "  CordRepRing(" << &rep << ", length = " << rep.length
52      << ", head = " << rep.head_ << ", tail = " << rep.tail_
53      << ", cap = " << rep.capacity_ << ", rc = " << rep.refcount.Get()
54      << ", begin_pos_ = " << static_cast<ptrdiff_t>(rep.begin_pos_) << ") {\n";
55    CordRepRing::index_type head = rep.head();
56    do {
57      CordRep* child = rep.entry_child(head);
58      s << " entry[" << head << "] length = " << rep.entry_length(head)
59        << ", child " << child << ", clen = " << child->length
60        << ", tag = " << static_cast<int>(child->tag)
61        << ", rc = " << child->refcount.Get()
62        << ", offset = " << rep.entry_data_offset(head)
63        << ", end_pos = " << static_cast<ptrdiff_t>(rep.entry_end_pos(head))
64        << "\n";
65      head = rep.advance(head);
66    } while (head != rep.tail());
67    return s << "}\n";
68  }
69  void CordRepRing::AddDataOffset(index_type index, size_t n) {
70    entry_data_offset()[index] += static_cast<offset_type>(n);
71  }
72  void CordRepRing::SubLength(index_type index, size_t n) {
73    entry_end_pos()[index] -= n;
74  }
75  class CordRepRing::Filler {
76   public:
77    Filler(CordRepRing* rep, index_type pos) : rep_(rep), head_(pos), pos_(pos) {}
78    index_type head() const { return head_; }
79    index_type pos() const { return pos_; }
80    void Add(CordRep* child, size_t offset, pos_type end_pos) {
81      rep_->entry_end_pos()[pos_] = end_pos;
82      rep_->entry_child()[pos_] = child;
83      rep_->entry_data_offset()[pos_] = static_cast<offset_type>(offset);
84      pos_ = rep_->advance(pos_);
85    }
86   private:
87    CordRepRing* rep_;
88    index_type head_;
89    index_type pos_;
90  };
91  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
92  constexpr size_t CordRepRing::kMaxCapacity;
93  #endif
94  bool CordRepRing::IsValid(std::ostream& output) const {
95    if (capacity_ == 0) {
96      output << "capacity == 0";
97      return false;
98    }
99    if (head_ >= capacity_ || tail_ >= capacity_) {
100      output << "head " << head_ << " and/or tail " << tail_ << "exceed capacity "
101             << capacity_;
102      return false;
103    }
104    const index_type back = retreat(tail_);
105    size_t pos_length = Distance(begin_pos_, entry_end_pos(back));
106    if (pos_length != length) {
107      output << "length " << length << " does not match positional length "
108             << pos_length << " from begin_pos " << begin_pos_ << " and entry["
109             << back << "].end_pos " << entry_end_pos(back);
110      return false;
111    }
112    index_type head = head_;
113    pos_type begin_pos = begin_pos_;
114    do {
115      pos_type end_pos = entry_end_pos(head);
116      size_t entry_length = Distance(begin_pos, end_pos);
117      if (entry_length == 0) {
118        output << "entry[" << head << "] has an invalid length " << entry_length
119               << " from begin_pos " << begin_pos << " and end_pos " << end_pos;
120        return false;
121      }
122      CordRep* child = entry_child(head);
123      if (child == nullptr) {
124        output << "entry[" << head << "].child == nullptr";
125        return false;
126      }
127      if (child->tag < FLAT && child->tag != EXTERNAL) {
128        output << "entry[" << head << "].child has an invalid tag "
129               << static_cast<int>(child->tag);
130        return false;
131      }
132      size_t offset = entry_data_offset(head);
133      if (offset >= child->length || entry_length > child->length - offset) {
134        output << "entry[" << head << "] has offset " << offset
135               << " and entry length " << entry_length
136               << " which are outside of the child's length of " << child->length;
137        return false;
138      }
139      begin_pos = end_pos;
140      head = advance(head);
141    } while (head != tail_);
142    return true;
143  }
144  #ifdef EXTRA_CORD_RING_VALIDATION
145  CordRepRing* CordRepRing::Validate(CordRepRing* rep, const char* file,
146                                     int line) {
147    if (!rep->IsValid(std::cerr)) {
148      std::cerr << "\nERROR: CordRepRing corrupted";
149      if (line) std::cerr << " at line " << line;
150      if (file) std::cerr << " in file " << file;
151      std::cerr << "\nContent = " << *rep;
152      abort();
153    }
154    return rep;
155  }
156  #endif  
157  CordRepRing* CordRepRing::New(size_t capacity, size_t extra) {
158    CheckCapacity(capacity, extra);
159    size_t size = AllocSize(capacity += extra);
160    void* mem = ::operator new(size);
161    auto* rep = new (mem) CordRepRing(static_cast<index_type>(capacity));
162    rep->tag = RING;
163    rep->capacity_ = static_cast<index_type>(capacity);
164    rep->begin_pos_ = 0;
165    return rep;
166  }
167  void CordRepRing::SetCapacityForTesting(size_t capacity) {
168    assert(capacity <= capacity_);
169    assert(head() == 0 || head() < tail());
170    memmove(Layout::Partial(capacity).Pointer<1>(data_) + head(),
171            Layout::Partial(capacity_).Pointer<1>(data_) + head(),
172            entries() * sizeof(Layout::ElementType<1>));
173    memmove(Layout::Partial(capacity, capacity).Pointer<2>(data_) + head(),
174            Layout::Partial(capacity_, capacity_).Pointer<2>(data_) + head(),
175            entries() * sizeof(Layout::ElementType<2>));
176    capacity_ = static_cast<index_type>(capacity);
177  }
178  void CordRepRing::Delete(CordRepRing* rep) {
179    assert(rep != nullptr && rep->IsRing());
180  #if defined(__cpp_sized_deallocation)
181    size_t size = AllocSize(rep->capacity_);
182    rep->~CordRepRing();
183    ::operator delete(rep, size);
184  #else
185    rep->~CordRepRing();
186    ::operator delete(rep);
187  #endif
188  }
189  void CordRepRing::Destroy(CordRepRing* rep) {
190    UnrefEntries(rep, rep->head(), rep->tail());
191    Delete(rep);
192  }
193  template <bool ref>
194  void CordRepRing::Fill(const CordRepRing* src, index_type head,
195                         index_type tail) {
196    this->length = src->length;
197    head_ = 0;
198    tail_ = advance(0, src->entries(head, tail));
199    begin_pos_ = src->begin_pos_;
200    auto* dst_pos = entry_end_pos();
201    auto* dst_child = entry_child();
202    auto* dst_offset = entry_data_offset();
203    src->ForEach(head, tail, [&](index_type index) {
204      *dst_pos++ = src->entry_end_pos(index);
205      CordRep* child = src->entry_child(index);
206      *dst_child++ = ref ? CordRep::Ref(child) : child;
207      *dst_offset++ = src->entry_data_offset(index);
208    });
209  }
210  CordRepRing* CordRepRing::Copy(CordRepRing* rep, index_type head,
211                                 index_type tail, size_t extra) {
212    CordRepRing* newrep = CordRepRing::New(rep->entries(head, tail), extra);
213    newrep->Fill<true>(rep, head, tail);
214    CordRep::Unref(rep);
215    return newrep;
216  }
217  CordRepRing* CordRepRing::Mutable(CordRepRing* rep, size_t extra) {
218    size_t entries = rep->entries();
219    if (!rep->refcount.IsOne()) {
220      return Copy(rep, rep->head(), rep->tail(), extra);
221    } else if (entries + extra > rep->capacity()) {
222      const size_t min_grow = rep->capacity() + rep->capacity() / 2;
223      const size_t min_extra = (std::max)(extra, min_grow - entries);
224      CordRepRing* newrep = CordRepRing::New(entries, min_extra);
225      newrep->Fill<false>(rep, rep->head(), rep->tail());
226      CordRepRing::Delete(rep);
227      return newrep;
228    } else {
229      return rep;
230    }
231  }
232  Span<char> CordRepRing::GetAppendBuffer(size_t size) {
233    assert(refcount.IsOne());
234    index_type back = retreat(tail_);
235    CordRep* child = entry_child(back);
236    if (child->tag >= FLAT && child->refcount.IsOne()) {
237      size_t capacity = child->flat()->Capacity();
238      pos_type end_pos = entry_end_pos(back);
239      size_t data_offset = entry_data_offset(back);
240      size_t entry_length = Distance(entry_begin_pos(back), end_pos);
241      size_t used = data_offset + entry_length;
242      if (size_t n = (std::min)(capacity - used, size)) {
243        child->length = data_offset + entry_length + n;
244        entry_end_pos()[back] = end_pos + n;
245        this->length += n;
246        return {child->flat()->Data() + used, n};
247      }
248    }
249    return {nullptr, 0};
250  }
251  Span<char> CordRepRing::GetPrependBuffer(size_t size) {
252    assert(refcount.IsOne());
253    CordRep* child = entry_child(head_);
254    size_t data_offset = entry_data_offset(head_);
255    if (data_offset && child->refcount.IsOne() && child->tag >= FLAT) {
256      size_t n = (std::min)(data_offset, size);
257      this->length += n;
258      begin_pos_ -= n;
259      data_offset -= n;
260      entry_data_offset()[head_] = static_cast<offset_type>(data_offset);
261      return {child->flat()->Data() + data_offset, n};
262    }
263    return {nullptr, 0};
264  }
265  CordRepRing* CordRepRing::CreateFromLeaf(CordRep* child, size_t offset,
266                                           size_t len, size_t extra) {
267    CordRepRing* rep = CordRepRing::New(1, extra);
268    rep->head_ = 0;
269    rep->tail_ = rep->advance(0);
270    rep->length = len;
271    rep->entry_end_pos()[0] = len;
272    rep->entry_child()[0] = child;
273    rep->entry_data_offset()[0] = static_cast<offset_type>(offset);
274    return Validate(rep);
275  }
276  CordRepRing* CordRepRing::CreateSlow(CordRep* child, size_t extra) {
277    CordRepRing* rep = nullptr;
278    Consume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
279      if (IsFlatOrExternal(child_arg)) {
280        rep = rep ? AppendLeaf(rep, child_arg, offset, len)
281                  : CreateFromLeaf(child_arg, offset, len, extra);
282      } else if (rep) {
283        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
284      } else if (offset == 0 && child_arg->length == len) {
285        rep = Mutable(child_arg->ring(), extra);
286      } else {
287        rep = SubRing(child_arg->ring(), offset, len, extra);
288      }
289    });
290    return Validate(rep, nullptr, __LINE__);
291  }
292  CordRepRing* CordRepRing::Create(CordRep* child, size_t extra) {
293    size_t length = child->length;
294    if (IsFlatOrExternal(child)) {
295      return CreateFromLeaf(child, 0, length, extra);
296    }
297    if (child->IsRing()) {
298      return Mutable(child->ring(), extra);
299    }
300    return CreateSlow(child, extra);
301  }
302  template <CordRepRing::AddMode mode>
303  CordRepRing* CordRepRing::AddRing(CordRepRing* rep, CordRepRing* ring,
304                                    size_t offset, size_t len) {
305    assert(offset < ring->length);
306    constexpr bool append = mode == AddMode::kAppend;
307    Position head = ring->Find(offset);
308    Position tail = ring->FindTail(head.index, offset + len);
309    const index_type entries = ring->entries(head.index, tail.index);
310    rep = Mutable(rep, entries);
311    const pos_type delta_length =
312        (append ? rep->begin_pos_ + rep->length : rep->begin_pos_ - len) -
313        ring->entry_begin_pos(head.index) - head.offset;
314    Filler filler(rep, append ? rep->tail_ : rep->retreat(rep->head_, entries));
315    if (ring->refcount.IsOne()) {
316      ring->ForEach(head.index, tail.index, [&](index_type ix) {
317        filler.Add(ring->entry_child(ix), ring->entry_data_offset(ix),
318                   ring->entry_end_pos(ix) + delta_length);
319      });
320      if (head.index != ring->head_) UnrefEntries(ring, ring->head_, head.index);
321      if (tail.index != ring->tail_) UnrefEntries(ring, tail.index, ring->tail_);
322      CordRepRing::Delete(ring);
323    } else {
324      ring->ForEach(head.index, tail.index, [&](index_type ix) {
325        CordRep* child = ring->entry_child(ix);
326        filler.Add(child, ring->entry_data_offset(ix),
327                   ring->entry_end_pos(ix) + delta_length);
328        CordRep::Ref(child);
329      });
330      CordRepRing::Unref(ring);
331    }
332    if (head.offset) {
333      rep->AddDataOffset(filler.head(), head.offset);
334    }
335    if (tail.offset) {
336      rep->SubLength(rep->retreat(filler.pos()), tail.offset);
337    }
338    rep->length += len;
339    if (append) {
340      rep->tail_ = filler.pos();
341    } else {
342      rep->head_ = filler.head();
343      rep->begin_pos_ -= len;
344    }
345    return Validate(rep);
346  }
347  CordRepRing* CordRepRing::AppendSlow(CordRepRing* rep, CordRep* child) {
348    Consume(child, [&rep](CordRep* child_arg, size_t offset, size_t len) {
349      if (child_arg->IsRing()) {
350        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
351      } else {
352        rep = AppendLeaf(rep, child_arg, offset, len);
353      }
354    });
355    return rep;
356  }
357  CordRepRing* CordRepRing::AppendLeaf(CordRepRing* rep, CordRep* child,
358                                       size_t offset, size_t len) {
359    rep = Mutable(rep, 1);
360    index_type back = rep->tail_;
361    const pos_type begin_pos = rep->begin_pos_ + rep->length;
362    rep->tail_ = rep->advance(rep->tail_);
363    rep->length += len;
364    rep->entry_end_pos()[back] = begin_pos + len;
365    rep->entry_child()[back] = child;
366    rep->entry_data_offset()[back] = static_cast<offset_type>(offset);
367    return Validate(rep, nullptr, __LINE__);
368  }
369  CordRepRing* CordRepRing::Append(CordRepRing* rep, CordRep* child) {
370    size_t length = child->length;
371    if (IsFlatOrExternal(child)) {
372      return AppendLeaf(rep, child, 0, length);
373    }
374    if (child->IsRing()) {
375      return AddRing<AddMode::kAppend>(rep, child->ring(), 0, length);
376    }
377    return AppendSlow(rep, child);
378  }
379  CordRepRing* CordRepRing::PrependSlow(CordRepRing* rep, CordRep* child) {
380    ReverseConsume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
381      if (IsFlatOrExternal(child_arg)) {
382        rep = PrependLeaf(rep, child_arg, offset, len);
383      } else {
384        rep = AddRing<AddMode::kPrepend>(rep, child_arg->ring(), offset, len);
385      }
386    });
387    return Validate(rep);
388  }
389  CordRepRing* CordRepRing::PrependLeaf(CordRepRing* rep, CordRep* child,
390                                        size_t offset, size_t len) {
391    rep = Mutable(rep, 1);
392    index_type head = rep->retreat(rep->head_);
393    pos_type end_pos = rep->begin_pos_;
394    rep->head_ = head;
395    rep->length += len;
396    rep->begin_pos_ -= len;
397    rep->entry_end_pos()[head] = end_pos;
398    rep->entry_child()[head] = child;
399    rep->entry_data_offset()[head] = static_cast<offset_type>(offset);
400    return Validate(rep);
401  }
402  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, CordRep* child) {
403    size_t length = child->length;
404    if (IsFlatOrExternal(child)) {
405      return PrependLeaf(rep, child, 0, length);
406    }
407    if (child->IsRing()) {
408      return AddRing<AddMode::kPrepend>(rep, child->ring(), 0, length);
409    }
410    return PrependSlow(rep, child);
411  }
412  CordRepRing* CordRepRing::Append(CordRepRing* rep, absl::string_view data,
413                                   size_t extra) {
414    if (rep->refcount.IsOne()) {
415      Span<char> avail = rep->GetAppendBuffer(data.length());
416      if (!avail.empty()) {
417        memcpy(avail.data(), data.data(), avail.length());
418        data.remove_prefix(avail.length());
419      }
420    }
421    if (data.empty()) return Validate(rep);
422    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
423    rep = Mutable(rep, flats);
424    Filler filler(rep, rep->tail_);
425    pos_type pos = rep->begin_pos_ + rep->length;
426    while (data.length() >= kMaxFlatLength) {
427      auto* flat = CreateFlat(data.data(), kMaxFlatLength);
428      filler.Add(flat, 0, pos += kMaxFlatLength);
429      data.remove_prefix(kMaxFlatLength);
430    }
431    if (data.length()) {
432      auto* flat = CreateFlat(data.data(), data.length(), extra);
433      filler.Add(flat, 0, pos += data.length());
434    }
435    rep->length = pos - rep->begin_pos_;
436    rep->tail_ = filler.pos();
437    return Validate(rep);
438  }
439  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, absl::string_view data,
440                                    size_t extra) {
441    if (rep->refcount.IsOne()) {
442      Span<char> avail = rep->GetPrependBuffer(data.length());
443      if (!avail.empty()) {
444        const char* tail = data.data() + data.length() - avail.length();
445        memcpy(avail.data(), tail, avail.length());
446        data.remove_suffix(avail.length());
447      }
448    }
449    if (data.empty()) return rep;
450    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
451    rep = Mutable(rep, flats);
452    pos_type pos = rep->begin_pos_;
453    Filler filler(rep, rep->retreat(rep->head_, static_cast<index_type>(flats)));
454    size_t first_size = data.size() - (flats - 1) * kMaxFlatLength;
455    CordRepFlat* flat = CordRepFlat::New(first_size + extra);
456    flat->length = first_size + extra;
457    memcpy(flat->Data() + extra, data.data(), first_size);
458    data.remove_prefix(first_size);
459    filler.Add(flat, extra, pos);
460    pos -= first_size;
461    while (!data.empty()) {
462      assert(data.size() >= kMaxFlatLength);
463      flat = CreateFlat(data.data(), kMaxFlatLength);
464      filler.Add(flat, 0, pos);
465      pos -= kMaxFlatLength;
466      data.remove_prefix(kMaxFlatLength);
467    }
468    rep->head_ = filler.head();
469    rep->length += rep->begin_pos_ - pos;
470    rep->begin_pos_ = pos;
471    return Validate(rep);
472  }
473  static constexpr index_type kBinarySearchThreshold = 32;
474  static constexpr index_type kBinarySearchEndCount = 8;
475  template <bool wrap>
476  CordRepRing::index_type CordRepRing::FindBinary(index_type head,
477                                                  index_type tail,
478                                                  size_t offset) const {
479    index_type count = tail + (wrap ? capacity_ : 0) - head;
480    do {
481      count = (count - 1) / 2;
482      assert(count < entries(head, tail_));
483      index_type mid = wrap ? advance(head, count) : head + count;
484      index_type after_mid = wrap ? advance(mid) : mid + 1;
485      bool larger = (offset >= entry_end_offset(mid));
486      head = larger ? after_mid : head;
487      tail = larger ? tail : mid;
488      assert(head != tail);
489    } while (ABSL_PREDICT_TRUE(count > kBinarySearchEndCount));
490    return head;
491  }
492  CordRepRing::Position CordRepRing::FindSlow(index_type head,
493                                              size_t offset) const {
494    index_type tail = tail_;
495    if (tail > head) {
496      index_type count = tail - head;
497      if (count > kBinarySearchThreshold) {
498        head = FindBinary<false>(head, tail, offset);
499      }
500    } else {
501      index_type count = capacity_ + tail - head;
502      if (count > kBinarySearchThreshold) {
503        head = FindBinary<true>(head, tail, offset);
504      }
505    }
506    pos_type pos = entry_begin_pos(head);
507    pos_type end_pos = entry_end_pos(head);
508    while (offset >= Distance(begin_pos_, end_pos)) {
509      head = advance(head);
510      pos = end_pos;
511      end_pos = entry_end_pos(head);
512    }
513    return {head, offset - Distance(begin_pos_, pos)};
514  }
515  CordRepRing::Position CordRepRing::FindTailSlow(index_type head,
516                                                  size_t offset) const {
517    index_type tail = tail_;
518    const size_t tail_offset = offset - 1;
519    if (tail > head) {
520      index_type count = tail - head;
521      if (count > kBinarySearchThreshold) {
<span onclick='openModal()' class='match'>522        head = FindBinary<false>(head, tail, tail_offset);
523      }
524    } else {
525      index_type count = capacity_ + tail - head;
526      if (count > kBinarySearchThreshold) {
527        head = FindBinary<true>(head, tail, tail_offset);
528      }
529    }
530    size_t end_offset = entry_end_offset(head);
531    while (tail_offset >= end_offset) {
</span>532      head = advance(head);
533      end_offset = entry_end_offset(head);
534    }
535    return {advance(head), end_offset - offset};
536  }
537  char CordRepRing::GetCharacter(size_t offset) const {
538    assert(offset < length);
539    Position pos = Find(offset);
540    size_t data_offset = entry_data_offset(pos.index) + pos.offset;
541    return GetRepData(entry_child(pos.index))[data_offset];
542  }
543  CordRepRing* CordRepRing::SubRing(CordRepRing* rep, size_t offset,
544                                    size_t len, size_t extra) {
545    assert(offset <= rep->length);
546    assert(offset <= rep->length - len);
547    if (len == 0) {
548      CordRep::Unref(rep);
549      return nullptr;
550    }
551    Position head = rep->Find(offset);
552    Position tail = rep->FindTail(head.index, offset + len);
553    const size_t new_entries = rep->entries(head.index, tail.index);
554    if (rep->refcount.IsOne() && extra <= (rep->capacity() - new_entries)) {
555      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
556      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
557      rep->head_ = head.index;
558      rep->tail_ = tail.index;
559    } else {
560      rep = Copy(rep, head.index, tail.index, extra);
561      head.index = rep->head_;
562      tail.index = rep->tail_;
563    }
564    rep->length = len;
565    rep->begin_pos_ += offset;
566    if (head.offset) {
567      rep->AddDataOffset(head.index, head.offset);
568    }
569    if (tail.offset) {
570      rep->SubLength(rep->retreat(tail.index), tail.offset);
571    }
572    return Validate(rep);
573  }
574  CordRepRing* CordRepRing::RemovePrefix(CordRepRing* rep, size_t len,
575                                         size_t extra) {
576    assert(len <= rep->length);
577    if (len == rep->length) {
578      CordRep::Unref(rep);
579      return nullptr;
580    }
581    Position head = rep->Find(len);
582    if (rep->refcount.IsOne()) {
583      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
584      rep->head_ = head.index;
585    } else {
586      rep = Copy(rep, head.index, rep->tail_, extra);
587      head.index = rep->head_;
588    }
589    rep->length -= len;
590    rep->begin_pos_ += len;
591    if (head.offset) {
592      rep->AddDataOffset(head.index, head.offset);
593    }
594    return Validate(rep);
595  }
596  CordRepRing* CordRepRing::RemoveSuffix(CordRepRing* rep, size_t len,
597                                         size_t extra) {
598    assert(len <= rep->length);
599    if (len == rep->length) {
600      CordRep::Unref(rep);
601      return nullptr;
602    }
603    Position tail = rep->FindTail(rep->length - len);
604    if (rep->refcount.IsOne()) {
605      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
606      rep->tail_ = tail.index;
607    } else {
608      rep = Copy(rep, rep->head_, tail.index, extra);
609      tail.index = rep->tail_;
610    }
611    rep->length -= len;
612    if (tail.offset) {
613      rep->SubLength(rep->retreat(tail.index), tail.offset);
614    }
615    return Validate(rep);
616  }
617  }  
618  ABSL_NAMESPACE_END
619  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</div>
                </div>
                <div class="column column_space"><pre><code>498        head = FindBinary<false>(head, tail, offset);
499      }
500    } else {
501      index_type count = capacity_ + tail - head;
502      if (count > kBinarySearchThreshold) {
503        head = FindBinary<true>(head, tail, offset);
504      }
505    }
506    pos_type pos = entry_begin_pos(head);
507    pos_type end_pos = entry_end_pos(head);
</pre></code></div>
                <div class="column column_space"><pre><code>522        head = FindBinary<false>(head, tail, tail_offset);
523      }
524    } else {
525      index_type count = capacity_ + tail - head;
526      if (count > kBinarySearchThreshold) {
527        head = FindBinary<true>(head, tail, tail_offset);
528      }
529    }
530    size_t end_offset = entry_end_offset(head);
531    while (tail_offset >= end_offset) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    