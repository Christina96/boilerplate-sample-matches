
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.323645970937912%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-subgraph.cpp</h3>
            <pre><code>1  namespace TSnap {
2  PUNGraph GetSubGraph(const PUNGraph& Graph, const TIntV& NIdV, const bool& RenumberNodes) {
3    PUNGraph NewGraphPt = TUNGraph::New();
4    TUNGraph& NewGraph = *NewGraphPt;
5    NewGraph.Reserve(NIdV.Len(), -1);
6    TIntSet NIdSet(NIdV.Len());
7    for (int n = 0; n < NIdV.Len(); n++) {
8      if (Graph->IsNode(NIdV[n])) {
9        NIdSet.AddKey(NIdV[n]);
10        if (! RenumberNodes) { NewGraph.AddNode(NIdV[n]); }
11        else { NewGraph.AddNode(NIdSet.GetKeyId(NIdV[n])); }
12      }
13    }
14    if (! RenumberNodes) {
15      for (int n = 0; n < NIdSet.Len(); n++) {
16        const int SrcNId = NIdSet[n];
17        const TUNGraph::TNodeI NI = Graph->GetNI(SrcNId);
18        for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
19          const int OutNId = NI.GetOutNId(edge);
20          if (NIdSet.IsKey(OutNId)) {
21            NewGraph.AddEdge(SrcNId, OutNId); }
22        }
23      }
24    } else {
25      for (int n = 0; n < NIdSet.Len(); n++) {
26        const int SrcNId = NIdSet[n];
27        const TUNGraph::TNodeI NI = Graph->GetNI(SrcNId);
28        for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
29          const int OutNId = NI.GetOutNId(edge);
30          if (NIdSet.IsKey(OutNId)) {
31            NewGraph.AddEdge(NIdSet.GetKeyId(SrcNId), NIdSet.GetKeyId(OutNId)); }
32        }
33      }
34    }
35    return NewGraphPt;
36  }
37  PNGraph GetSubGraph(const PNGraph& Graph, const TIntV& NIdV, const bool& RenumberNodes) {
38    PNGraph NewGraphPt = TNGraph::New();
39    TNGraph& NewGraph = *NewGraphPt;
40    NewGraph.Reserve(NIdV.Len(), -1);
41    TIntSet NIdSet(NIdV.Len());
42    for (int n = 0; n < NIdV.Len(); n++) {
43      if (Graph->IsNode(NIdV[n])) {
44        NIdSet.AddKey(NIdV[n]);
45        if (! RenumberNodes) { NewGraph.AddNode(NIdV[n]); }
46        else { NewGraph.AddNode(NIdSet.GetKeyId(NIdV[n])); }
47      }
48    }
49    if (! RenumberNodes) {
50      for (int n = 0; n < NIdSet.Len(); n++) {
51        const int SrcNId = NIdSet[n];
<span onclick='openModal()' class='match'>52        const TNGraph::TNodeI NI = Graph->GetNI(SrcNId);
53        for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
54          const int OutNId = NI.GetOutNId(edge);
</span>55          if (NIdSet.IsKey(OutNId)) {
56            NewGraph.AddEdge(SrcNId, OutNId); }
57        }
58      }
59    } else {
60      for (int n = 0; n < NIdSet.Len(); n++) {
61        const int SrcNId = NIdSet[n];
62        const TNGraph::TNodeI NI = Graph->GetNI(SrcNId);
63        for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
64          const int OutNId = NI.GetOutNId(edge);
65          if (NIdSet.IsKey(OutNId)) {
66            NewGraph.AddEdge(NIdSet.GetKeyId(SrcNId), NIdSet.GetKeyId(OutNId)); }
67        }
68      }
69    }
70    return NewGraphPt;
71  }
72  PHGraph GetSubGraph(const TPt<THGraph>& Graph, const TIntV& NIdV) {
73    PHGraph NewGraphPt = THGraph::New();
74    THGraph& NewGraph = *NewGraphPt;
75    NewGraph.Reserve(NIdV.Len(), -1);
76    for (int n = 0; n < NIdV.Len(); n++) {
77      if (Graph->IsNode(NIdV[n])) {
78        NewGraph.AddNode(Graph->GetNI(NIdV[n]));
79      }
80    }
81    bool EdgeAddable;
82    TIntV NeiNIdV;
83    for (THGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
84      EdgeAddable = true;
85      EI.GetEdge().GetNbrNodes(NeiNIdV);
86      for (int e=0; e < NeiNIdV.Len(); e++) {
87        if (!NewGraph.IsNode(NeiNIdV[e])) { EdgeAddable = false; break; }
88      }
89      if (EdgeAddable) { NewGraph.AddEdge(EI); }
90    }
91    NewGraph.Defrag();
92    return NewGraphPt;
93  }
94  PUNGraph GetEgonet(const PUNGraph& Graph, const int CtrNId, int& ArndEdges) {
95    PUNGraph NewGraphPt = TUNGraph::New();
96    TUNGraph& NewGraph = *NewGraphPt;
97    NewGraph.AddNode(CtrNId);
98    const TUNGraph::TNodeI& CtrNode = Graph->GetNI(CtrNId);
99    for (int i = 0; i < CtrNode.GetInDeg(); ++i) {
100      NewGraph.AddNode(CtrNode.GetInNId(i));
101    }
102    ArndEdges = 0;
103    for (int i = 0; i < CtrNode.GetInDeg(); ++i) {
104      int NbrNId = CtrNode.GetInNId(i);
105      const TUNGraph::TNodeI& NbrNode = Graph->GetNI(NbrNId);
106      for (int j = 0; j < NbrNode.GetInDeg(); ++j) {
107        int NbrNbrNId = NbrNode.GetInNId(j);
108        if (NewGraph.IsNode(NbrNbrNId)) {
109          if (!NewGraph.IsEdge(NbrNId, NbrNbrNId)) {
110            NewGraph.AddEdge(NbrNId, NbrNbrNId);
111          }
112        } else {
113          ArndEdges++;
114        }
115      }
116    }
117    return NewGraphPt;
118  }
119  PNGraph GetEgonet(const PNGraph& Graph, const int CtrNId, int& InEdges, int& OutEdges) {
120    PNGraph NewGraphPt = TNGraph::New();
121    TNGraph& NewGraph = *NewGraphPt;
122    NewGraph.AddNode(CtrNId);
123    const TNGraph::TNodeI& CtrNode = Graph->GetNI(CtrNId);
124    for (int i = 0; i < CtrNode.GetDeg(); ++i) {
125      if (!NewGraph.IsNode(CtrNode.GetNbrNId(i))) {
126        NewGraph.AddNode(CtrNode.GetNbrNId(i));
127      }
128    }
129    InEdges = 0;
130    OutEdges = 0;
131    for (int i = 0; i < CtrNode.GetDeg(); ++i) {
132      int NbrNId = CtrNode.GetNbrNId(i);
133      const TNGraph::TNodeI& NbrNode = Graph->GetNI(NbrNId);
134      for (int j = 0; j < NbrNode.GetInDeg(); ++j) {
135        int NbrNbrNId = NbrNode.GetInNId(j);
136        if (NewGraph.IsNode(NbrNbrNId)) {
137          NewGraph.AddEdge(NbrNbrNId, NbrNId);
138        } else {
139          InEdges++;
140        }
141      }
142      for (int j = 0; j < NbrNode.GetOutDeg(); ++j) {
143        int NbrNbrNId = NbrNode.GetOutNId(j);
144        if (NewGraph.IsNode(NbrNbrNId)) {
145          NewGraph.AddEdge(NbrNId, NbrNbrNId);
146        } else {
147          OutEdges++;
148        }
149      }
150    }
151    return NewGraphPt;
152  }
153  void AddNodeWithAttributes(const PNEANet& Graph1, PNEANet& Graph2, const int NId) {
154    Graph2->AddNode(NId);
155    TStrV IntAttrNames;
156    TIntV IntAttrValues;
157    Graph1->IntAttrNameNI(NId, IntAttrNames);
158    Graph1->IntAttrValueNI(NId, IntAttrValues);
159    for (int i = 0; i < IntAttrNames.Len(); i++) {
160      Graph2->AddIntAttrDatN(NId, IntAttrValues[i], IntAttrNames[i]);
161    }
162    TStrV FltAttrNames;
163    TFltV FltAttrValues;
164    Graph1->FltAttrNameNI(NId, FltAttrNames);
165    Graph1->FltAttrValueNI(NId, FltAttrValues);
166    for (int i = 0; i < FltAttrNames.Len(); i++) {
167      Graph2->AddFltAttrDatN(NId, FltAttrValues[i], FltAttrNames[i]);
168    }
169    TStrV StrAttrNames;
170    TStrV StrAttrValues;
171    Graph1->StrAttrNameNI(NId, StrAttrNames);
172    Graph1->StrAttrValueNI(NId, StrAttrValues);
173    for (int i = 0; i < StrAttrNames.Len(); i++) {
174      Graph2->AddStrAttrDatN(NId, StrAttrValues[i], StrAttrNames[i]);
175    }
176    TStrV IntVAttrNames;
177    TVec<TIntV> IntVAttrValues;
178    Graph1->IntVAttrNameNI(NId, IntVAttrNames);
179    Graph1->IntVAttrValueNI(NId, IntVAttrValues);
180    for (int i = 0; i < IntVAttrNames.Len(); i++) {
181      Graph2->AddIntVAttrDatN(NId, IntVAttrValues[i], IntVAttrNames[i]);
182    }
183  }
184  void AddEdgeWithAttributes(const PNEANet &Graph1, PNEANet &Graph2, const int EId) {
185    const TNEANet::TEdgeI EI = Graph1->GetEI(EId);
186    Graph2->AddEdge(EI);
187    TStrV IntAttrNames;
188    TIntV IntAttrValues;
189    Graph1->IntAttrNameEI(EId, IntAttrNames);
190    Graph1->IntAttrValueEI(EId, IntAttrValues);
191    for (int i = 0; i < IntAttrNames.Len(); i++) {
192      Graph2->AddIntAttrDatE(EId, IntAttrValues[i], IntAttrNames[i]);
193    }
194    TStrV FltAttrNames;
195    TFltV FltAttrValues;
196    Graph1->FltAttrNameEI(EId, FltAttrNames);
197    Graph1->FltAttrValueEI(EId, FltAttrValues);
198    for (int i = 0; i < FltAttrNames.Len(); i++) {
199      Graph2->AddFltAttrDatE(EId, FltAttrValues[i], FltAttrNames[i]);
200    }
201    TStrV StrAttrNames;
202    TStrV StrAttrValues;
203    Graph1->StrAttrNameEI(EId, StrAttrNames);
204    Graph1->StrAttrValueEI(EId, StrAttrValues);
205    for (int i = 0; i < StrAttrNames.Len(); i++) {
206      Graph2->AddStrAttrDatE(EId, StrAttrValues[i], StrAttrNames[i]);
207    }
208    TStrV IntVAttrNames;
209    TVec<TIntV> IntVAttrValues;
210    Graph1->IntVAttrNameEI(EId, IntVAttrNames);
211    Graph1->IntVAttrValueEI(EId, IntVAttrValues);
212    for (int i = 0; i < IntVAttrNames.Len(); i++) {
213      Graph2->AddIntVAttrDatE(EId, IntVAttrValues[i], IntVAttrNames[i]);
214    }
215  }
216  void AddEdgeWithAttributes(const PNEANet &Graph1, PNEANet &Graph2, const int NId, const int NbrId) {
217    Graph2->AddEdge(NId, NbrId);
218    const int EId1 = Graph1->GetEId(NId, NbrId);
219    const int EId2 = Graph2->GetEId(NId, NbrId);
220    TStrV IntAttrNames;
221    TIntV IntAttrValues;
222    Graph1->IntAttrNameEI(EId1, IntAttrNames);
223    Graph1->IntAttrValueEI(EId1, IntAttrValues);
224    for (int i = 0; i < IntAttrNames.Len(); i++) {
225      Graph2->AddIntAttrDatE(EId2, IntAttrValues[i], IntAttrNames[i]);
226    }
227    TStrV FltAttrNames;
228    TFltV FltAttrValues;
229    Graph1->FltAttrNameEI(EId1, FltAttrNames);
230    Graph1->FltAttrValueEI(EId1, FltAttrValues);
231    for (int i = 0; i < FltAttrNames.Len(); i++) {
232      Graph2->AddFltAttrDatE(EId2, FltAttrValues[i], FltAttrNames[i]);
233    }
234    TStrV StrAttrNames;
235    TStrV StrAttrValues;
236    Graph1->StrAttrNameEI(EId1, StrAttrNames);
237    Graph1->StrAttrValueEI(EId1, StrAttrValues);
238    for (int i = 0; i < StrAttrNames.Len(); i++) {
239      Graph2->AddStrAttrDatE(EId2, StrAttrValues[i], StrAttrNames[i]);
240    }
241    TStrV IntVAttrNames;
242    TVec<TIntV> IntVAttrValues;
243    Graph1->IntVAttrNameEI(EId1, IntVAttrNames);
244    Graph1->IntVAttrValueEI(EId1, IntVAttrValues);
245    for (int i = 0; i < IntVAttrNames.Len(); i++) {
246      Graph2->AddIntVAttrDatE(EId2, IntVAttrValues[i], IntVAttrNames[i]);
247    }
248  }
249  PNEANet GetEgonetAttr(const PNEANet &Graph, const int CtrNId, const int Radius) {
250    PNEANet NewGraphPt = PNEANet::New();
251    TNEANet &NewGraph = *NewGraphPt;
252    TSnapQueue<int> Queue1;
253    TSnapQueue<int> Queue2;
254    TSnapQueue<int> tempSwapQueue;
255    AddNodeWithAttributes(Graph, NewGraphPt, CtrNId);
256    Queue1.Clr(false);
257    Queue1.Push(CtrNId);
258    for (int r = 0; r < Radius; ++r) {
259      while (!Queue1.Empty()) {
260        const int NId = Queue1.Top();
261        Queue1.Pop();
262        const TNEANet::TNodeI &Node = Graph->GetNI(NId);
263        for (int i = 0; i < Node.GetInDeg(); ++i) {
264          const int InNId = Node.GetInNId(i);
265          if (!NewGraph.IsNode(InNId)) {
266            AddNodeWithAttributes(Graph, NewGraphPt, InNId);
267            Queue2.Push(InNId);
268          }
269          const int InEId = Node.GetInEId(i);
270          if (!NewGraph.IsEdge(InEId)) {
271            AddEdgeWithAttributes(Graph, NewGraphPt, InEId);
272          }
273        }
274        for (int i = 0; i < Node.GetOutDeg(); ++i) {
275          const int OutNId = Node.GetOutNId(i);
276          if (!NewGraph.IsNode(OutNId)) {
277            AddNodeWithAttributes(Graph, NewGraphPt, OutNId);
278            Queue2.Push(OutNId);
279          }
280          const int OutEId = Node.GetOutEId(i);
281          if (!NewGraph.IsEdge(OutEId)) {
282            AddEdgeWithAttributes(Graph, NewGraphPt, OutEId);
283          }
284        }
285        for (int i = 0; i < Node.GetInDeg(); ++i) {
286          int InNId = Node.GetInNId(i);
287          const TNEANet::TNodeI &InNode = Graph->GetNI(InNId);
288          for (int j = 0; j < InNode.GetInDeg(); ++j) {
289            int NbrInNId = InNode.GetInNId(j);
290            if (NewGraph.IsNode(NbrInNId)) {
291              const int NbrInEId = InNode.GetInEId(j);
292              if (!NewGraph.IsEdge(NbrInEId)) {
293                AddEdgeWithAttributes(Graph, NewGraphPt, NbrInEId);
294              }
295            }
296          }
297          for (int j = 0; j < InNode.GetOutDeg(); ++j) {
298            int NbrOutNId = InNode.GetOutNId(j);
299            if (NewGraph.IsNode(NbrOutNId)) {
300              const int NbrOutEId = InNode.GetOutEId(j);
301              if (!NewGraph.IsEdge(NbrOutEId)) {
302                AddEdgeWithAttributes(Graph, NewGraphPt, NbrOutEId);
303              }
304            }
305          }
306        }
307        for (int i = 0; i < Node.GetOutDeg(); ++i) {
308          int OutNId = Node.GetOutNId(i);
309          const TNEANet::TNodeI &OutNode = Graph->GetNI(OutNId);
310          for (int j = 0; j < OutNode.GetInDeg(); ++j) {
311            int NbrInNId = OutNode.GetInNId(j);
312            if (NewGraph.IsNode(NbrInNId)) {
313              const int NbrInEId = OutNode.GetInEId(j);
314              if (!NewGraph.IsEdge(NbrInEId)) {
315                AddEdgeWithAttributes(Graph, NewGraphPt, NbrInEId);
316              }
317            }
318          }
319          for (int j = 0; j < OutNode.GetOutDeg(); ++j) {
320            int NbrOutNId = OutNode.GetOutNId(j);
321            if (NewGraph.IsNode(NbrOutNId)) {
322              const int NbrOutEId = OutNode.GetOutEId(j);
323              if (!NewGraph.IsEdge(NbrOutEId)) {
324                AddEdgeWithAttributes(Graph, NewGraphPt, NbrOutEId);
325              }
326            }
327          }
328        }
329      }
330      tempSwapQueue = Queue1;
331      Queue1 = Queue2;
332      Queue2 = tempSwapQueue;
333    }
334    return NewGraphPt;
335  }
336  PNEANet GetInEgonetAttr(const PNEANet &Graph, const int CtrNId, const int Radius) {
337    PNEANet NewGraphPt = PNEANet::New();
338    TNEANet &NewGraph = *NewGraphPt;
339    TSnapQueue<int> Queue1;
340    TSnapQueue<int> Queue2;
341    TSnapQueue<int> tempSwapQueue;
342    AddNodeWithAttributes(Graph, NewGraphPt, CtrNId);
343    Queue1.Clr(false);
344    Queue1.Push(CtrNId);
345    for (int r = 0; r < Radius; ++r) {
346      while (!Queue1.Empty()) {
347        const int NId = Queue1.Top();
348        Queue1.Pop();
349        const TNEANet::TNodeI &Node = Graph->GetNI(NId);
350        for (int i = 0; i < Node.GetInDeg(); ++i) {
351          const int InNId = Node.GetInNId(i);
352          if (!NewGraph.IsNode(InNId)) {
353            AddNodeWithAttributes(Graph, NewGraphPt, InNId);
354            Queue2.Push(InNId);
355          }
356          const int InEId = Node.GetInEId(i);
357          if (!NewGraph.IsEdge(InEId)) {
358            AddEdgeWithAttributes(Graph, NewGraphPt, InEId);
359          }
360        }
361        for (int i = 0; i < Node.GetInDeg(); ++i) {
362          int InNId = Node.GetInNId(i);
363          const TNEANet::TNodeI &InNode = Graph->GetNI(InNId);
364          for (int j = 0; j < InNode.GetInDeg(); ++j) {
365            int NbrInNId = InNode.GetInNId(j);
366            if (NewGraph.IsNode(NbrInNId)) {
367              const int NbrInEId = InNode.GetInEId(j);
368              if (!NewGraph.IsEdge(NbrInEId)) {
369                AddEdgeWithAttributes(Graph, NewGraphPt, NbrInEId);
370              }
371            }
372          }
373          for (int j = 0; j < InNode.GetOutDeg(); ++j) {
374            int NbrOutNId = InNode.GetOutNId(j);
375            if (NewGraph.IsNode(NbrOutNId)) {
376              const int NbrOutEId = InNode.GetOutEId(j);
377              if (!NewGraph.IsEdge(NbrOutEId)) {
378                AddEdgeWithAttributes(Graph, NewGraphPt, NbrOutEId);
379              }
380            }
381          }
382        }
383      }
384      tempSwapQueue = Queue1;
385      Queue1 = Queue2;
386      Queue2 = tempSwapQueue;
387    }
388    return NewGraphPt;
389  }
390  PNEANet GetOutEgonetAttr(const PNEANet &Graph, const int CtrNId, const int Radius) {
391    PNEANet NewGraphPt = PNEANet::New();
392    TNEANet &NewGraph = *NewGraphPt;
393    TSnapQueue<int> Queue1;
394    TSnapQueue<int> Queue2;
395    TSnapQueue<int> tempSwapQueue;
396    AddNodeWithAttributes(Graph, NewGraphPt, CtrNId);
397    Queue1.Clr(false);
398    Queue1.Push(CtrNId);
399    for (int r = 0; r < Radius; ++r) {
400      while (!Queue1.Empty()) {
401        const int NId = Queue1.Top();
402        Queue1.Pop();
403        const TNEANet::TNodeI &Node = Graph->GetNI(NId);
404        for (int i = 0; i < Node.GetOutDeg(); ++i) {
405          const int OutNId = Node.GetOutNId(i);
406          if (!NewGraph.IsNode(OutNId)) {
407            AddNodeWithAttributes(Graph, NewGraphPt, OutNId);
408            Queue2.Push(OutNId);
409          }
410          const int OutEId = Node.GetOutEId(i);
411          if (!NewGraph.IsEdge(OutEId)) {
412            AddEdgeWithAttributes(Graph, NewGraphPt, OutEId);
413          }
414        }
415        for (int i = 0; i < Node.GetOutDeg(); ++i) {
416          int OutNId = Node.GetOutNId(i);
417          const TNEANet::TNodeI &OutNode = Graph->GetNI(OutNId);
418          for (int j = 0; j < OutNode.GetInDeg(); ++j) {
419            int NbrInNId = OutNode.GetInNId(j);
420            if (NewGraph.IsNode(NbrInNId)) {
421              const int InEId = OutNode.GetInEId(j);
422              if (!NewGraph.IsEdge(InEId)) {
423                AddEdgeWithAttributes(Graph, NewGraphPt, InEId);
424              }
425            }
426          }
427          for (int j = 0; j < OutNode.GetOutDeg(); ++j) {
428            int NbrOutNId = OutNode.GetOutNId(j);
429            if (NewGraph.IsNode(NbrOutNId)) {
430              const int OutEId = OutNode.GetOutEId(j);
431              if (!NewGraph.IsEdge(OutEId)) {
432                AddEdgeWithAttributes(Graph, NewGraphPt, OutEId);
433              }
434            }
435          }
436        }
437      }
438      tempSwapQueue = Queue1;
439      Queue1 = Queue2;
440      Queue2 = tempSwapQueue;
441    }
442    return NewGraphPt;
443  }
444  PNEANet GetInEgonetSubAttr(const PNEANet &Graph, const int CtrNId, const int Radius, const int MaxNum, const float percent) {
445    PNEANet NewGraphPt = TNEANet::New();
446    TNEANet& NewGraph = *NewGraphPt;
447    TSnapQueue<int> Queue1;
448    TSnapQueue<int> Queue2;
449    TSnapQueue<int> tempSwapQueue;
450    TSnapQueue<int> sampleQueue;
451    AddNodeWithAttributes(Graph, NewGraphPt, CtrNId);
452    Queue1.Clr(false);
453    Queue1.Push(CtrNId);
454    bool usePercent = (percent != -1.0);
455    int numSamples = MaxNum;
456    for (int r = 0; r < Radius; ++r) {
457      while (!Queue1.Empty()) {
458        const int NId = Queue1.Top();
459        Queue1.Pop();
460        const TNEANet::TNodeI &Node = Graph->GetNI(NId);
461        sampleQueue.Clr(true);
462        for (int i = 0; i < Node.GetInDeg(); ++i) {
463          const int InNId = Node.GetInNId(i);
464          if (!NewGraph.IsNode(InNId)) {
465            sampleQueue.Push(InNId);
466          }
467        }
468        if (usePercent) {
469          numSamples = (int) (percent * sampleQueue.Len());
470        }
471        sampleQueue.Sample(numSamples);
472        for (int i = 0; i < numSamples && !sampleQueue.Empty(); ++i) {
473          const int InNId = sampleQueue.Top();
474          sampleQueue.Pop();
475          if (!NewGraph.IsNode(InNId)) {
476            AddNodeWithAttributes(Graph, NewGraphPt, InNId);
477            Queue2.Push(InNId);
478          }
479          if (!NewGraph.IsEdge(InNId, NId)) {
480            AddEdgeWithAttributes(Graph, NewGraphPt, InNId, NId);
481          }
482        }
483        for (int i = 0; i < Node.GetInDeg(); ++i) {
484          int InNId = Node.GetInNId(i);
485          if (!NewGraph.IsNode(InNId)) { continue; }
486          const TNEANet::TNodeI &InNode = Graph->GetNI(InNId);
487          for (int j = 0; j < InNode.GetInDeg(); ++j) {
488            int NbrInNId = InNode.GetInNId(j);
489            if (NewGraph.IsNode(NbrInNId)) {
490              if (!NewGraph.IsEdge(NbrInNId, InNId)) {
491                AddEdgeWithAttributes(Graph, NewGraphPt, NbrInNId, InNId);
492              }
493            }
494          }
495          for (int j = 0; j < InNode.GetOutDeg(); ++j) {
496            int NbrOutNId = InNode.GetOutNId(j);
497            if (NewGraph.IsNode(NbrOutNId)) {
498              if (!NewGraph.IsEdge(InNId, NbrOutNId)) {
499                AddEdgeWithAttributes(Graph, NewGraphPt, InNId, NbrOutNId);
500              }
501            }
502          }
503        }
504      }
505      tempSwapQueue = Queue1;
506      Queue1 = Queue2;
507      Queue2 = tempSwapQueue;
508    }
509    return NewGraphPt;
510  }
511  PNEANet GetGraphUnionAttr(PNEANet &DstGraph, const PNEANet &SrcGraph) {
512    for (PNEANet::TObj::TNodeI NI = SrcGraph->BegNI(); NI < SrcGraph->EndNI(); NI++) {
513      if (!DstGraph->IsNode(NI.GetId())) {
514        AddNodeWithAttributes(SrcGraph, DstGraph, NI.GetId());
515      }
516    }
517    for (PNEANet::TObj::TEdgeI EI = SrcGraph->BegEI(); EI < SrcGraph->EndEI(); EI++) {
518      if (!DstGraph->IsEdge(EI.GetSrcNId(), EI.GetDstNId())) {
519        AddEdgeWithAttributes(SrcGraph, DstGraph, EI.GetSrcNId(), EI.GetDstNId());
520      }
521    }
522    return DstGraph;
523  }
524  PNEANet GetGraphIntersectionAttr(const PNEANet &Graph, const PNEANet &Graph0){
525    PNEANet IntersectionGraph = PNEANet::New();
526    for (PNEANet::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
527      if (Graph0->IsNode(NI.GetId()) && ! IntersectionGraph->IsNode(NI.GetId())) {
528        AddNodeWithAttributes(Graph, IntersectionGraph, NI.GetId());
529      }
530    }
531    for (PNEANet::TObj::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
532      if (Graph0->IsEdge(EI.GetSrcNId(), EI.GetDstNId()) && ! IntersectionGraph->IsEdge(EI.GetSrcNId(), EI.GetDstNId())) {
533        AddEdgeWithAttributes(Graph, IntersectionGraph, EI.GetSrcNId(), EI.GetDstNId());
534      }   
535    }
536    return IntersectionGraph;
537  }
538  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-semspace.cpp</h3>
            <pre><code>1  THash<TStr, TSemSpace::TSemSpcLoadF> TSemSpace::TypeToLoadFH;
2  bool TSemSpace::Reg(const TStr& TypeNm, const TSemSpcLoadF& LoadF) {
3    IAssert(!TypeToLoadFH.IsKey(TypeNm));
4    TypeToLoadFH.AddDat(TypeNm, LoadF);
5    return true;
6  }
7  PSemSpace TSemSpace::Load(TSIn& SIn) {
8      TStr TypeNm(SIn);
9      int TypeKeyId=-1;
10      if (TypeToLoadFH.IsKey(TypeNm, TypeKeyId)){
11          TSemSpcLoadF LoadF=TypeToLoadFH[TypeKeyId];
12          return (*LoadF())(SIn);
13      } else {
14          return NULL;
15      }
16  }
17  double TSemSpace::GetAvgApprox(const TVec<PBowSpV>& BowSpV, const int& Dim) const {
18      PMom Mom = TMom::New();
19      for (int DocN = 0; DocN < BowSpV.Len(); DocN++) {
20          PBowSpV ProjSpV = this->ProjectSpV(BowSpV[DocN], Dim, false);
21          Mom->Add(ProjSpV->GetNorm());
22      }
23      Mom->Def();            
24      return Mom->GetMean();
25  }
26  int TSemSpace::GetDimNeededForApprox(const TVec<PBowSpV>& BowSpV, 
27          const double& ApproxThresh, double& ApproxVal, const int& MxDimDiff) const {
28      IAssert(0.0 < ApproxThresh && ApproxThresh < 1.0);
29      int BottomDim = 0, TopDim = this->GetVecs();
30      ApproxVal = GetAvgApprox(BowSpV, TopDim);
31      if (ApproxVal < ApproxThresh) { return TopDim; }
32      forever {
33          if (TopDim - BottomDim < MxDimDiff) {  return TopDim; }
34          IAssert(TopDim > BottomDim);
35          const int SemSpcDim = (TopDim + BottomDim) / 2;
36          ApproxVal = GetAvgApprox(BowSpV, SemSpcDim);
37          if (ApproxVal < ApproxThresh) {
38              IAssert(BottomDim < SemSpcDim);
39              BottomDim = SemSpcDim;
40          } else {
41              IAssert(TopDim > SemSpcDim);
42              TopDim = SemSpcDim;
43          }
44      }
45  }
46  PBowDocPart TSemSpace::GetBowDocPart(const PBowDocBs& BowDocBs,
47          const int& StartVecN, const int _Vecs, const double& Eps) const {
48      PBowDocPart BowDocPart = TBowDocPart::New();
49      const int Vecs = _Vecs == -1 ? this->GetVecs() : _Vecs;
50      IAssert(Vecs < this->GetVecs());
51      for (int VecN = StartVecN; VecN < Vecs; VecN++) {
52          PBowSpV PosSpV, NegSpV; 
53          this->GetVecBowSpV(VecN, PosSpV, NegSpV, Eps);
54          if (PosSpV->Len() > 0) {
55              PBowDocPartClust Clust = TBowDocPartClust::New(
56                  BowDocBs, TStr::Fmt("Vec%dPos", VecN), 0.0, TIntV(), PosSpV, NULL);
57              BowDocPart->AddClust(Clust);
58          }
59          if (NegSpV->Len() > 0) {
60              PBowDocPartClust Clust = TBowDocPartClust::New(
61                  BowDocBs, TStr::Fmt("Vec%dPos", VecN), 0.0, TIntV(), NegSpV, NULL);
62              BowDocPart->AddClust(Clust);
63          }
64      }
65      return BowDocPart;
66  }
67  void TSemSpace::GetVecBowSpV(const int& VecN, PBowSpV& PosSpV, 
68          PBowSpV& NegSpV, const double& Eps) const {
69      IAssert(0.0 <= Eps && Eps <= 1.0);
70      TFltV Vec; GetVec(VecN, Vec);
71      PosSpV = TBowSpV::New(); NegSpV = TBowSpV::New();
72      const int Len = Vec.Len();
73      for (int i = 0; i < Len; i++) {
74          if (Vec[i] > Eps) {
75              PosSpV->AddWIdWgt(i, Vec[i]);
76          } else if (-Vec[i] > Eps) {
77              NegSpV->AddWIdWgt(i, -Vec[i]);
78          }
79      }
80  }
81  void TSemSpace::GetWords(PBowDocBs BowDocBs, const int& VecN, 
82          const int& TopWords, const double& TopWordsWgtPrc, 
83          TStrFltPrV& PosWordStrWgtV, TStrFltPrV& NegWordStrWgtV) const {
84      PBowSpV PosSpV, NegSpV; this->GetVecBowSpV(VecN, PosSpV, NegSpV);
85      PosWordStrWgtV.Clr();
86      if (PosSpV->Len() > 0) {
87          PosSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtPrc, PosWordStrWgtV);
88      }
89      NegWordStrWgtV.Clr();
90      if (NegSpV->Len() > 0) {
91          NegSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtPrc, NegWordStrWgtV);
92      }
93  }
94  void TSemSpace::SaveTxt(const TStr& FNm, PBowDocBs BowDocBs, const int& TopWords, 
95          const double& TopWordsWgtPrc, const bool& ShowWgt) const {
96      PSOut Out = TFOut::New(FNm);
97      Out->PutStrLn("Semantic Space generation method: " + MethodeType);
98      Out->PutLn();
99      const int Vecs = GetVecs();
100      for (int VecN = 0; VecN < Vecs; VecN++) {
101          Out->PutStrLn(TStr::Fmt("Vector no.\t%d:", VecN));
102          TStrFltPrV PosWordStrWgtV, NegWordStrWgtV;
103          this->GetWords(BowDocBs, VecN, TopWords, TopWordsWgtPrc, 
104              PosWordStrWgtV, NegWordStrWgtV);
105          Out->PutStr("+\t");
106          for (int i = 0; i < PosWordStrWgtV.Len(); i++) {
107              if (ShowWgt) {
108                  Out->PutStr(TStr::Fmt("%s:%g\t", 
109                      PosWordStrWgtV[i].Val1.CStr(), PosWordStrWgtV[i].Val2.Val));
110              } else {
111                  Out->PutStr(TStr::Fmt("%s\t", PosWordStrWgtV[i].Val1.CStr()));
112              }
113          }
114          Out->PutLn(); 
115          Out->PutStr("-\t");
116          for (int i = 0; i < NegWordStrWgtV.Len(); i++) {
117              if (ShowWgt) {
118                  Out->PutStr(TStr::Fmt("%s:%g\t", 
119                      NegWordStrWgtV[i].Val1.CStr(), NegWordStrWgtV[i].Val2.Val));
120              } else {
121                  Out->PutStr(TStr::Fmt("%s\t", NegWordStrWgtV[i].Val1.CStr()));
122              }
123          }
124          Out->PutLn(2);
125      }
126  }
127  void TSemSpace::SaveTxtStat(const TStr& FNm, PSemSpace SemSp1, PBowDocBs BowBs1, 
128          PBowDocWgtBs BowWgt1, PSemSpace SemSp2, PBowDocBs BowBs2, 
129          PBowDocWgtBs BowWgt2, const bool& NormP, const TIntV& DIdV) {
130      printf("project first set...\n");
131      TIntV DIdV1 = DIdV; if (DIdV.Empty()) BowBs1->GetAllDIdV(DIdV1);
132      PBowDocBs Set1 = SemSp1->Project(BowBs1, BowWgt1, DIdV1, SemSp1->GetVecs(), NormP);
133      printf("project second set...\n");
134      TIntV DIdV2 = DIdV; if (DIdV.Empty()) BowBs2->GetAllDIdV(DIdV2);
135      PBowDocBs Set2 = SemSp2->Project(BowBs2, BowWgt2, DIdV2, SemSp2->GetVecs(), NormP);
136      IAssert(Set1->GetDocs() == Set2->GetDocs());
137      PSOut SOut = TFOut::New(FNm);
138      printf("comparing %s vs. %s...\n", 
139          SemSp1->GetMethodeType().CStr(), SemSp2->GetMethodeType().CStr());
140      SOut->PutStrLn("DId, ||Vec1||, ||Vec2||, <Vec1/||Vec1||,Vec2/||Vec2||>");
141      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
142          printf("%d\r", DocC);
143          TStr DocNm1 = BowBs1->GetDocNm(DIdV[DocC]), DocNm2 = BowBs2->GetDocNm(DIdV[DocC]);
144          IAssert(DocNm1.Left(DocNm1.Len() - 3) == DocNm2.Left(DocNm2.Len() - 3));
145          TStr NewDocNm1 = Set1->GetDocNm(DocC), NewDocNm2 = Set2->GetDocNm(DocC);
146          IAssertR(DocNm1 == NewDocNm1, DocNm1 + "!=" + NewDocNm1);
147          IAssertR(DocNm2 == NewDocNm2, DocNm2 + "!=" + NewDocNm2);
148          PBowSpV Vec1 = Set1->GetDocSpV(DocC);
149          PBowSpV Vec2 = Set2->GetDocSpV(DocC);
150          const double n1 = Vec1->GetNorm();
151          const double n2 = Vec2->GetNorm();
152          const double dp = (n1*n2 > 0.0) ? TBowLinAlg::DotProduct(Vec1, Vec2)/(n1*n2) : 0.0;
153          SOut->PutStrLn(TStr::Fmt("%d\t%.5f\t%.5f\t%.5f", DIdV[DocC].Val, n1, n2, dp));
154      }
155      SOut->Flush();
156      printf("\ndone\n");
157  }
158  void TSemSpace::SaveApproxStat(const TStr& FNm, 
159          const TVec<PBowSpV>& BowSpV, const int& Step) const {
160      PSOut SOut = TFOut::New(FNm);
161      SOut->PutStrLn("Testing approximation quality");
162      SOut->PutStrLn(TStr::Fmt("Average of norms should converge to 1.0 as dim->%d", GetVecs()));
163      SOut->PutStrLn("==============================================================");
164      for (int Dims = Step; Dims < GetVecs(); Dims+=Step) {  
165          PMom Mom = TMom::New();
166          for (int DocN = 0; DocN < BowSpV.Len(); DocN++) {
167              PBowSpV ProjSpV = ProjectSpV(BowSpV[DocN], Dims, false);
168              Mom->Add(ProjSpV->GetNorm());
169          }
170          Mom->Def();
171          SOut->PutStrLn(TStr::Fmt("Norm(dim:%d) = [avg: %.3f, sdev: %.3f]", Dims, Mom->GetMean(), Mom->GetSDev()));
172      }
173  }
174  bool TVecSemSpace::IsReg=TVecSemSpace::MkReg();
175  TVecSemSpace::TVecSemSpace(const TFltVV& BasisVV, 
176          const TStr& _MethodeType): TSemSpace(_MethodeType) {
177      const int Len = BasisVV.GetXDim();
178      const int Dim = BasisVV.GetYDim();
179      BasisV.Gen(Dim);
180      for (int VecN = 0; VecN < Dim; VecN++) {
181          BasisV[VecN].Gen(Len,0);
182          for (int i = 0; i < Len; i++) {
183              BasisV[VecN].Add(BasisVV(i, VecN)); }
184      }
185  }
186  TVecSemSpace::TVecSemSpace(PSVMTrainSet Set, PPartialGS R, 
187          const TVec<TFltV>& DrctV, const TStr& _MethodeType): TSemSpace(_MethodeType) { 
188      IAssert(Set->Len() == R->GetCols()); 
189      const int Dim = DrctV.Len();
190      const int DocN = R->GetCols(), AproxN = R->GetRows();
191      const TIntV& IdV = R->GetIdV();
192      BasisV.Gen(Dim, 0); TFltV AlphV(DocN);
193      TVec<TFltV> q(AproxN); R->GetBasisV(q);
194      TFltV ww(AproxN); 
195      for (int i = 0; i < Dim; i++) {
196          printf("\r%d", i);
197          const TFltV& w = DrctV[i];
198          IAssert(w.Len() <= AproxN);
199          ww.PutAll(0.0);
200          for (int j = 0; j < w.Len(); j++)
201              TLinAlg::AddVec(w[j], q[j], ww, ww);
202          AlphV.PutAll(0.0);
203          for (int j = 0; j < AproxN; j++)
204              AlphV[IdV[j]] = ww[j];
205          TFltV Col; Set->LinComb(AlphV, Col); BasisV.Add(Col);
206      }
207      printf("\n");
208  };
209  TVecSemSpace::TVecSemSpace(const TStr& MatlabFName): TSemSpace("Matlab") {
210      TLAMisc::LoadMatlabTFltVV(MatlabFName, BasisV);
211  }
212  TVecSemSpace::TVecSemSpace(const TStr& MatlabFName, 
213          const TStr& MapFName): TSemSpace("Matlab") {
214      TLAMisc::LoadMatlabTFltVV(MatlabFName, BasisV);
215      PSIn SIn = TFIn::New(MapFName);
216      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
217      int Words = BasisV[0].Len(); TIntV WIdV(Words, 0);
218      for (int WdN = 0; WdN < Words; WdN++) {
219          if (WdN % 100 == 0) { printf("%d\r", WdN); }
220          Lx.GetSym(syInt); WIdV.Add(Lx.Int);
221          Lx.GetSym(syInt); IAssertR((Lx.Int-1) == WdN, TStr::Fmt("line %d", WdN));
222          Lx.GetSym(syStr, syIdStr, syQStr);
223          Lx.GetSym(syEof, syEoln);
224      }
225      printf("\n"); IAssert(WIdV.IsSorted());
226      const int NewSize = WIdV.Last()+1;
227      for (int VecN = 0; VecN < BasisV.Len(); VecN++) {
228          TFltV NewVec(NewSize); NewVec.PutAll(0.0);
229          for (int WdN = 0; WdN < Words; WdN++) {
230              NewVec[WIdV[WdN]] = BasisV[VecN][WdN];
231          }
232          BasisV[VecN] = NewVec;
233      }
234  }
235  PBowDocBs TVecSemSpace::Project(const PBowDocBs& BowDocBs, 
236          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
237          const int& Vecs, const bool& NormP) const {
238      IAssert(Vecs <= BasisV.Len());
239      PBowDocBs NewBowDocBs = TBowDocBs::New();
240      for (int i = 0; i < Vecs; i++) {
241          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); }  
242      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
243          const int DId = DIdV[DocC];
<span onclick='openModal()' class='match'>244          TIntFltPrV PSpV(Vecs, 0); double VecNorm = 0.0;
245          for (int i = 0; i < Vecs; i++) {
246              const double Elt = TBowLinAlg::DotProduct(
</span>247                  BasisV[i], BowDocWgtBs->GetSpV(DId));
248              PSpV.Add(TIntFltPr(i, Elt)); 
249              VecNorm += TMath::Sqr(Elt);
250          }
251          if (NormP && VecNorm > 0.0) {
252              VecNorm = sqrt(VecNorm);
253              for (int i = 0; i < Vecs; i++) {
254                  PSpV[i].Val2 = PSpV[i].Val2 / VecNorm;
255              }
256          }
257          const int CatN = BowDocBs->GetDocCIds(DId);
258          TStrV CatNmV(CatN, 0);
259          for (int CatC = 0; CatC < CatN; CatC++) { 
260              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
261          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, PSpV); 
262      }
263      NewBowDocBs->AssertOk();
264      return NewBowDocBs;
265  }
266  PBowSpV TVecSemSpace::ProjectSpV(const PBowSpV& SpV, 
267          const int& Vecs, const bool& NormP) const {
268      PSVMTrainSet Set = TBowTrainSet::New(1); 
269      Set->AddAttrV(0, SpV, 1.0);
270      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
271      for (int i = 0; i < Vecs; i++) {
272          NewSpV->AddWIdWgt(i, TBowLinAlg::DotProduct(BasisV[i], SpV)); }
273      if (NormP) { NewSpV->PutUnitNorm(); }
274      return NewSpV;
275  }
276  void TVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
277          const bool& NormP, TIntFltKdV& ProjSpV) const {
278      ProjSpV.Gen(Vecs, 0);
279      for (int i = 0; i < Vecs; i++) {
280          ProjSpV.Add(TIntFltKd(i, TBowLinAlg::DotProduct(BasisV[i], SpV))); }
281      if (NormP) { TLinAlg::Normalize(ProjSpV); }
282  }
283  void TVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
284          const bool& NormP, TFltV& ProjV) const {
285      ProjV.Gen(Vecs, 0);
286      for (int i = 0; i < Vecs; i++) {
287          ProjV.Add(TBowLinAlg::DotProduct(BasisV[i], SpV)); }
288      if (NormP) { TLinAlg::Normalize(ProjV); }
289  }
290  void TVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
291          const bool& NormP, TIntFltKdV& ProjSpV) const {
292      ProjSpV.Gen(Vecs, 0);
293      for (int i = 0; i < Vecs; i++) {
294          ProjSpV.Add(TIntFltKd(i, TLinAlg::DotProduct(BasisV[i], SpV))); }
295      if (NormP) { TLinAlg::Normalize(ProjSpV); }   
296  }
297  void TVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
298          const bool& NormP, TFltV& ProjV) const {
299      ProjV.Gen(Vecs, 0);
300      for (int i = 0; i < Vecs; i++) {
301          ProjV.Add(TLinAlg::DotProduct(BasisV[i], SpV)); }
302      if (NormP) { TLinAlg::Normalize(ProjV); }   
303  }
304  void TVecSemSpace::ProjectV(const TFltV& FullV, const int& Vecs, 
305          const bool& NormP, TFltV& ProjV) const {
306      ProjV.Gen(Vecs, 0);
307      for (int i = 0; i < Vecs; i++) {
308          ProjV.Add(TLinAlg::DotProduct(BasisV[i], FullV)); }
309      if (NormP) { TLinAlg::Normalize(ProjV); }
310  }
311  bool TSpVecSemSpace::IsReg=TSpVecSemSpace::MkReg();
312  TSpVecSemSpace:: TSpVecSemSpace(const TVec<TIntFltKdV>& _BasisV, const TStr& _MethodeType): 
313        TSemSpace(_MethodeType), BasisV(_BasisV) { 
314      const int Vecs = BasisV.Len();
315      VecDim = 0;
316      for (int VecN = 0; VecN < Vecs; VecN++) {
317          VecDim = TInt::GetMx(VecDim, BasisV.Last().Last().Key);
318      }
319      VecDim++;
320  };
321  PBowDocBs TSpVecSemSpace::Project(const PBowDocBs& BowDocBs, 
322          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
323          const int& Vecs, const bool& NormP) const {
324      IAssert(Vecs <= BasisV.Len());
325      PBowDocBs NewBowDocBs = TBowDocBs::New();
326      for (int i = 0; i < Vecs; i++) {
327          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); } 
328      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
329          const int DId = DIdV[DocC];
330          TIntFltPrV PSpV(Vecs, 0); double VecNorm = 0.0;
331          for (int i = 0; i < Vecs; i++) {
332              const double Elt = TBowLinAlg::DotProduct(
333                  BasisV[i], BowDocWgtBs->GetSpV(DId));
334              PSpV.Add(TIntFltPr(i, Elt)); 
335              VecNorm += TMath::Sqr(Elt);
336          }
337          if (NormP && VecNorm > 0.0) {
338              VecNorm = sqrt(VecNorm);
339              for (int i = 0; i < Vecs; i++) {
340                  PSpV[i].Val2 = PSpV[i].Val2 / VecNorm;
341              }
342          }
343          const int CatN = BowDocBs->GetDocCIds(DId);
344          TStrV CatNmV(CatN, 0);
345          for (int CatC = 0; CatC < CatN; CatC++) { 
346              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
347          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, PSpV); 
348      }
349      NewBowDocBs->AssertOk();
350      return NewBowDocBs;
351  }
352  PBowSpV TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, 
353          const int& Vecs, const bool& NormP) const {
354      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
355      for (int i = 0; i < Vecs; i++) {
356          NewSpV->AddWIdWgt(i, TBowLinAlg::DotProduct(BasisV[i], SpV)); }
357      if (NormP) { NewSpV->PutUnitNorm(); }
358      return NewSpV;
359  }
360  void TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
361          const bool& NormP, TIntFltKdV& ProjSpV) const {
362      ProjSpV.Gen(Vecs, 0);
363      for (int i = 0; i < Vecs; i++) {
364          ProjSpV.Add(TIntFltKd(i, TBowLinAlg::DotProduct(BasisV[i], SpV))); }
365      if (NormP) { TLinAlg::Normalize(ProjSpV); }
366  }
367  void TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
368          const bool& NormP, TFltV& ProjV) const {
369      ProjV.Gen(Vecs, 0);
370      for (int i = 0; i < Vecs; i++) {
371          ProjV.Add(TBowLinAlg::DotProduct(BasisV[i], SpV)); }
372      if (NormP) { TLinAlg::Normalize(ProjV); }
373  }
374  void TSpVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
375          const bool& NormP, TIntFltKdV& ProjSpV) const {
376      ProjSpV.Gen(Vecs, 0);
377      for (int i = 0; i < Vecs; i++) {
378          ProjSpV.Add(TIntFltKd(i, TLinAlg::DotProduct(BasisV[i], SpV))); }
379      if (NormP) { TLinAlg::Normalize(ProjSpV); }  
380  }
381  void TSpVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
382          const bool& NormP, TFltV& ProjV) const {
383      ProjV.Gen(Vecs, 0);
384      for (int i = 0; i < Vecs; i++) {
385          ProjV.Add(TLinAlg::DotProduct(BasisV[i], SpV)); }
386      if (NormP) { TLinAlg::Normalize(ProjV); }  
387  }
388  void TSpVecSemSpace::ProjectV(const TFltV& FullV, const int& Vecs, 
389          const bool& NormP, TFltV& ProjV) const {
390      ProjV.Gen(Vecs, 0);
391      for (int i = 0; i < Vecs; i++) {
392          ProjV.Add(TLinAlg::DotProduct(FullV, BasisV[i])); }
393      if (NormP) { TLinAlg::Normalize(ProjV); }     
394  }
395  int TSpVecSemSpace::GetVecLen() const {
396      const int Vecs = GetVecs(); int MxDim = 0;
397      for (int i = 0; i < Vecs; i++) {
398          MxDim = TInt::GetMx(BasisV[i].Last().Key, 0); }
399      return MxDim;
400  }
401  bool TKCCASemSpace::IsReg=TKCCASemSpace::MkReg();
402  void TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
403          const bool& NormP, TIntFltPrV& ProjSpV) const {
404      const int N = TrainSet->Len(); TFltV z(N, 0);
405      TFltV DotProdV(N, 0);
406      for (int i = 0; i < N; i++)
407          DotProdV.Add(TrainSet->DotProduct(i, SpV));
408      for (int i = 0; i < N; i++) 
409          z.Add(TLinAlg::DotProduct(GSBasisV[i], DotProdV));
410      ProjSpV.Gen(Vecs, 0); double Norm = 0.0;
411      for (int i = 0; i < Vecs; i++) {
412          const double Wgt = TLinAlg::DotProduct(z, BasisV[i]);
413          ProjSpV.Add(TIntFltPr(i, Wgt));
414          Norm += TMath::Sqr(Wgt);
415      }
416      if (NormP) {
417          Norm = sqrt(Norm);
418          for (int i = 0; i < Vecs; i++) { ProjSpV[i].Val2 /= Norm; }
419      }
420  }
421  TKCCASemSpace::TKCCASemSpace(PSVMTrainSet Set, PPartialGS R, const TVec<TFltV>& DrctV, const TStr& _MethodeType): 
422          TSemSpace(_MethodeType), TrainSet(Set) { 
423      IAssert(Set->Len() == R->GetCols()); 
424      BasisV = DrctV;
425      R->GetBasisV(GSBasisV);
426      const TIntV& DIdV = R->GetIdV();
427      const int Dim = R->GetRows();
428      TrainSet = TBowTrainSet::New(Dim);
429      for (int VecC = 0; VecC < Dim; VecC++) {
430          const int DocId = DIdV[VecC];
431          TrainSet->AddAttrV(Set->GetVecDId(DocId), Set->GetAttrBowV(DocId), Set->GetVecParam(DocId));
432      }
433      IAssert(GSBasisV.Len() == TrainSet->Len() && GSBasisV[0].Len() == TrainSet->Len());
434  }
435  PBowDocBs TKCCASemSpace::Project(const PBowDocBs& BowDocBs, 
436          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
437          const int& Vecs, const bool& NormP) const {
438      IAssert(Vecs <= BasisV.Len());
439      PBowDocBs NewBowDocBs = TBowDocBs::New();
440      for (int i = 0; i < Vecs; i++) {
441          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); } 
442      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
443      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
444          const int DId = DIdV[DocC];
445          TIntFltPrV ProjVec; 
446          ProjectSpV(BowDocWgtBs->GetSpV(DId), Vecs, NormP, ProjVec);
447          const int CatN = BowDocBs->GetDocCIds(DId);
448          TStrV CatNmV(CatN, 0);
449          for (int CatC = 0; CatC < CatN; CatC++) { 
450              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
451          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, ProjVec); 
452      }
453      printf("\n");
454      NewBowDocBs->AssertOk();
455      return NewBowDocBs;
456  }
457  PBowSpV TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, 
458          const int& Vecs, const bool& NormP) const {
459      TIntFltPrV ProjVec; ProjectSpV(SpV, Vecs, NormP, ProjVec);
460      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
461      for (int i = 0; i < Vecs; i++) {
462          const TIntFltPr Wgt = ProjVec[i];
463          NewSpV->AddWIdWgt(Wgt.Val1, Wgt.Val2);
464      }
465      return NewSpV;
466  }
467  void TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
468          const bool& NormP, TIntFltKdV& ProjSpV) const {
469      const int N = TrainSet->Len(); TFltV z(N, 0);
470      TFltV DotProdV(N, 0);
471      for (int i = 0; i < N; i++)
472          DotProdV.Add(TrainSet->DotProduct(i, SpV));
473      for (int i = 0; i < N; i++) 
474          z.Add(TLinAlg::DotProduct(GSBasisV[i], DotProdV));
475      ProjSpV.Gen(Vecs, 0); double Norm = 0.0;
476      for (int i = 0; i < Vecs; i++) {
477          const double Wgt = TLinAlg::DotProduct(z, BasisV[i]);
478          ProjSpV.Add(TIntFltKd(i, Wgt));
479          Norm += TMath::Sqr(Wgt);
480      }
481      if (NormP) {
482          Norm = sqrt(Norm);
483          for (int i = 0; i < Vecs; i++) { ProjSpV[i].Dat /= Norm; }
484      }
485  }
486  void TKCCASemSpace::GetVec(const int& VecN, TFltV& VecV) const {
487      const int GSDim = GSBasisV[0].Len();
488      const TFltV& w = BasisV[VecN];
489      IAssert(w.Len() == GSDim);
490      TFltV AlphV(GSDim); AlphV.PutAll(0.0);
491      for (int j = 0; j < GSDim; j++)
492          TLinAlg::AddVec(w[j], GSBasisV[j], AlphV, AlphV);
493      TrainSet->LinComb(AlphV, VecV);
494  }
495  void TSemSpaceAlg::CalcKCCA(const TFltVV& Ra, const TFltVV& Rb, 
496          const double& ta, const double& tb, const TKCCACorrNrmType& CorrNrmType, 
497          TVec<TFltV>& DrctAV, TVec<TFltV>& DrctBV, TFltV& CorrV) {
498      IAssert(Ra.GetCols() == Rb.GetCols());
499      const int Size = Ra.GetCols();
500      IAssert(Ra.GetRows() >= Rb.GetRows());
501      const int SubSizeA = Ra.GetRows();
502      const int SubSizeB = Rb.GetRows();
503      printf("step (2)...\n");
504      TFltVV R(SubSizeB, SubSizeB); 
505      for (int i = 0; i < SubSizeB; i++) {
506          for (int j = i; j < SubSizeB; j++) {
507              double res = 0.0;
508              for (int k = 0; k < Size; k++) {
509                  res += Rb(i,k) * Rb(j,k);  
510              }
511              R(i,j) = (1-tb)*res;
512          }
513          R(i,i) += tb;
514      }
515      TFltV Rp(SubSizeB);
516      printf("choleksy decomposition...");
517      TNumericalStuff::CholeskyDecomposition(R, Rp);
518      for (int i = 0; i < SubSizeB; i++) {
519          R(i,i) = Rp[i];  
520          for (int j = i+1; j < SubSizeB; j++)
521              R(i,j) = R(j,i); 
522      }
523      printf("invR...\n");
524      TNumericalStuff::InverseTriagonal(R);
525      printf("step (3)...\n");
526      TFltVV A(SubSizeA, SubSizeA);
527      printf("calculating: A...");
528      for (int i = 0; i < SubSizeA; i++) {
529          for (int j = i; j < SubSizeA; j++) {
530              double res = 0.0;
531              for (int k = 0; k < Size; k++) {
532                  res += Ra(i,k) * Ra(j,k);  
533              }
534              A(j,i) = A(i,j) = (1-ta)*res;
535          }
536          A(i,i) += ta;
537      }
538      printf("invA..."); 
539      TNumericalStuff::InverseSymetric(A);
540      TFltVV invA(SubSizeA, SubSizeA); 
541      for (int i = 0; i < SubSizeA; i++) {
542          invA(i,i) = A(i,i);
543          for (int j = i+1; j < SubSizeA; j++)
544              A(j,i) = invA(j,i) = invA(i,j) = A(i,j);
545      }
546      printf("invR'*Rb*Ra'*invA*Ra*Rb'*invR...");
547      printf("1..");
548      TFltVV RbRaT(SubSizeB, SubSizeA);
549      for (int i = 0; i < SubSizeB; i++) {
550          for (int j = 0; j < SubSizeA; j++) {
551              double res = 0.0;
552              for (int k = 0; k < Size; k++)
553                  res += Rb(i,k) * Ra(j,k);
554              RbRaT(i,j) = res;
555          }
556      }
557      printf("2..");
558      TFltVV B(SubSizeB, SubSizeA);
559      TLinAlg::Multiply(RbRaT, A, B);
560      A.Gen(SubSizeB, SubSizeB);
561      for (int i = 0; i < SubSizeB; i++) {
562          for (int j = 0; j < SubSizeB; j++) {
563              double sum = 0.0;
564              for (int k = 0; k < SubSizeA; k++)
565                  sum += B(i,k)*RbRaT(j,k);
566              A(i,j) = sum;
567          }
568      }
569      printf("3..");
570      B.Gen(SubSizeB, SubSizeB);
571      for (int i = 0; i < SubSizeB; i++) {
572          for (int j = 0; j < SubSizeB; j++) {
573              double sum = 0.0;
574              for (int k = 0; k <= i; k++)
575                  sum += R(k,i)*A(k,j);
576              B(i,j) = sum;
577          }
578      }
579      printf("4..");
580      for (int i = 0; i < SubSizeB; i++) {
581          for (int j = 0; j < SubSizeB; j++) {
582              double sum = 0.0;
583              for (int k = 0; k <= j; k++)
584                  sum += B(i,k)*R(k,j);
585              A(i,j) = sum;
586          }
587      }
588      printf("\nsolving eigneproblem...");
589      TFltV d(SubSizeB+1), e(SubSizeB+1);
590      printf("1..");
591      TNumericalStuff::SymetricToTridiag(A, SubSizeB, d, e);
592      TLAMisc::FillIdentity(B);
593      printf("2..");
594      TNumericalStuff::EigSymmetricTridiag(d, e, SubSizeB, B);
595      printf("3..");
596      TFltVV V(SubSizeB, SubSizeB);
597      TLinAlg::Multiply(A, B, V);
598      for (int i = 1; i <= SubSizeB; i++) d[i-1] = d[i];
599      d.DelLast(); 
600      printf("\nstep (4)...\n");
601      printf("Wb...");
602      for (int i = 0; i < SubSizeB; i++) {
603          for (int j = 0; j < SubSizeB; j++) {
604              double sum = 0.0;
605              for (int k = i; k < SubSizeB; k++)
606                  sum += R(i,k)*V(k,j);
607              B(i,j) = sum;
608          }
609      }
610      for (int j = 0; j < SubSizeB; j++) {
611          double norm = 0.0;
612          for (int i = 0; i < SubSizeB; i++)
613              norm += TMath::Sqr(B(i,j));
614          IAssert(norm > 0.0); norm = sqrt(norm);
615          for (int i = 0; i < SubSizeB; i++)
616              B(i,j) /= norm;
617      }
618      printf("Wa...");
619      V.Gen(SubSizeA, SubSizeB);
620      for (int i = 0; i < SubSizeA; i++) {
621          for (int j = 0; j < SubSizeB; j++) {
622              double sum = 0.0;
623              for (int k = 0; k < SubSizeA; k++)
624                  sum += invA(i,k)*RbRaT(j,k);
625              V(i,j) = sum;
626          }
627      }
628      A.Gen(SubSizeA, SubSizeB);
629      TLinAlg::Multiply(V, B, A);
630      for (int j = 0; j < SubSizeB; j++) {
631          double norm = 0.0;
632          for (int i = 0; i < SubSizeA; i++)
633              norm += TMath::Sqr(A(i,j));
634          IAssert(norm > 0.0); norm = sqrt(norm);
635          for (int i = 0; i < SubSizeA; i++)
636              A(i,j) /= norm;
637      }
638      Rp.Clr(); invA.Clr(); e.Clr(); R.Clr(); RbRaT.Clr(); V.Clr();
639      printf("\ndone...\n");
640      TFltIntKdV EigV(SubSizeB, 0);
641      for (int i = 0; i < SubSizeB; i++) EigV.Add(TFltIntKd(d[i], i));
642      EigV.Sort(false);
643      const int DrctN = SubSizeB-1; printf("SubSizeB = %d\n", SubSizeB);
644      DrctAV.Gen(DrctN); DrctBV.Gen(DrctN); CorrV.Gen(DrctN, 0);
645      TFltV RaTwa(Size), RbTwb(Size);
646      for (int i = 0; i < DrctN; i++) {
647          TFltV& wa = DrctAV[i]; wa.Gen(SubSizeA);
648          TFltV& wb = DrctBV[i]; wb.Gen(SubSizeB);
649          const int EigId = EigV[i+1].Dat;
650          CorrV.Add(EigV[i+1].Key);
651          for (int j = 0; j < SubSizeA; j++)
652              wa[j] = A(j, EigId);
653          for (int j = 0; j < SubSizeB; j++)
654              wb[j] = B(j, EigId);
655          if (CorrNrmType != kcntNone) {
656              double Corr = 1.0; 
657              if (CorrNrmType == kcntOne) { Corr = 1.0; }
658              else if (CorrNrmType == kcntEigVal) { Corr = CorrV.Last()/CorrV[0]; }
659              IAssert(Corr > 0.0);
660              TLinAlg::MultiplyT(Ra, wa, RaTwa);
661              const double KoefA = sqrt(Corr/TLinAlg::Norm2(RaTwa));
662              TLinAlg::MultiplyScalar(KoefA, wa, wa);
663              TLinAlg::MultiplyT(Ra, wa, RaTwa); 
664              IAssert(TFlt::Abs(TLinAlg::Norm2(RaTwa) - Corr) < 1e-7);
665              TLinAlg::MultiplyT(Rb, wb, RbTwb);
666              const double KoefB = sqrt(Corr/TLinAlg::Norm2(RbTwb));
667              TLinAlg::MultiplyScalar(KoefB, wb, wb);
668              TLinAlg::MultiplyT(Rb, wb, RbTwb); 
669              IAssert(TFlt::Abs(TLinAlg::Norm2(RbTwb) - Corr) < 1e-7);
670          }
671      }
672  }
673  void TSemSpaceAlg::CalcKCCA(PSVMTrainSet SetA, PSVMTrainSet SetB, const double& t, 
674          const int& SpaceDim, const double& Eps, PPartialGS& Ra, PPartialGS& Rb, 
675          const TKCCACorrNrmType& CorrNrmType, TVec<TFltV>& DrctAV, 
676          TVec<TFltV>& DrctBV, TFltV& EigV) {
677      IAssertR(SetA->Len() == SetB->Len() && SetB->Len() >= SpaceDim, 
678          TStr::Fmt("(SetA->Len() == %d) != (SetB->Len() == %d)", SetA->Len(), SetB->Len()));
679      IAssertR(0.0 <= t && t <= 1.0, TStr::Fmt("t=%d must be between 0.0 and 1.0!", t));
680      IAssertR(0.0 <= Eps && Eps < 1.0, TStr::Fmt("Eps=%d must be between 0.0 and 1.0!", Eps));
681      printf("step (1)...\n");
682      TFltVV RaVV, RbVV; 
683      printf("incomplete Cholesky... SetA\n");
684      Ra = TPartialGS::New(SetA(), SetA->Len(), Eps); Ra->GetDocVV(RaVV);
685      printf("incomplete Cholesky... SetB\n");
686      Rb = TPartialGS::New(SetB(), SetB->Len(), Eps); Rb->GetDocVV(RbVV);
687      const int NewSpaceDim = TInt::GetMn(RaVV.GetRows(), RbVV.GetRows());
688      if (RaVV.GetRows() > RbVV.GetRows()) {
689          CalcKCCA(RaVV, RbVV, t, t, CorrNrmType, DrctAV, DrctBV, EigV);
690      } else {
691          CalcKCCA(RbVV, RaVV, t, t, CorrNrmType, DrctBV, DrctAV, EigV);
692      }
693      IAssertR(DrctAV.Len() == NewSpaceDim-1  && DrctAV.Len() == NewSpaceDim-1,
694          TStr::Fmt("%d, %d != %d", DrctAV.Len(), DrctBV.Len(), NewSpaceDim-1));
695      if (DrctAV.Len() < SpaceDim) {
696          printf("SpaceDim is lowerd to %d!\n", DrctAV.Len());
697      } else {
698          DrctAV.Trunc(SpaceDim); DrctBV.Trunc(SpaceDim);
699      }
700  }
701  void TSemSpaceAlg::CalcKCCA(const TVec<PBowSpV>& BowSpVA, const TVec<PBowSpV>& BowSpVB, 
702          const double& t, const int& SpaceDim, const double& Eps, PSemSpace& SpA, 
703          PSemSpace& SpB, TFltV& EigV, const TKCCACorrNrmType& CorrNrmType) {
704      PSVMTrainSet SetA = TBowDocBs2TrainSet::NewBowNoCat(BowSpVA);
705      PSVMTrainSet SetB = TBowDocBs2TrainSet::NewBowNoCat(BowSpVB);
706      PPartialGS Ra, Rb; TVec<TFltV> DrctAV, DrctBV;
707      CalcKCCA(SetA, SetB, t, SpaceDim, Eps, Ra, Rb, CorrNrmType, DrctAV, DrctBV, EigV);
708      SpA = TKCCASemSpace::New(SetA, Ra, DrctAV, "KCCA");
709      SpB = TKCCASemSpace::New(SetB, Rb, DrctBV, "KCCA");
710  }
711  void TSemSpaceAlg::CalcVecKCCA(const TVec<PBowSpV>& BowSpVA, const TVec<PBowSpV>& BowSpVB, 
712          const double& t, const int& SpaceDim, const double& Eps, PSemSpace& SpA, 
713          PSemSpace& SpB, const TKCCACorrNrmType& CorrNrmType) {
714      PSVMTrainSet SetA = TBowDocBs2TrainSet::NewBowNoCat(BowSpVA);
715      PSVMTrainSet SetB = TBowDocBs2TrainSet::NewBowNoCat(BowSpVB);
716      PPartialGS Ra, Rb; TVec<TFltV> DrctAV, DrctBV; TFltV EigV;
717      CalcKCCA(SetA, SetB, t, SpaceDim, Eps, Ra, Rb, CorrNrmType, DrctAV, DrctBV, EigV);
718      SpA = TVecSemSpace::New(SetA, Ra, DrctAV, "KCCA-Vec");
719      SpB = TVecSemSpace::New(SetB, Rb, DrctBV, "KCCA-Vec");
720  }
721  void TSemSpaceAlg::DecomposeKernelMatrix(PSVMTrainSet Set, const int& Dim, 
722          TVec<TFltV>& CompV, const bool& CenterMatrix) {
723      const int Size = Set->Len();
724      TFltVV K; TKernelUtil::CalcKernelMatrix(Set, K);
725      if (CenterMatrix) {
726          TKernelUtil::CenterKernelMatrix(K);
727      }
728      TFltV d(Size+1), e(Size+1);
729      TNumericalStuff::SymetricToTridiag(K, Size, d, e);
730      TFltVV V(Size, Size); TLAMisc::FillIdentity(V);
731      TNumericalStuff::EigSymmetricTridiag(d, e, Size, V);
732      TFltIntKdV EigV(Size, 0);
733      for (int i = 1; i <= Size; i++) {
734          EigV.Add(TFltIntKd(d[i], i-1));
735          d[i-1] = sqrt(1.0/d[i]);
736      }
737      EigV.Sort(false); d.DelLast();
738      CompV.Gen(Dim);
739      for (int i = 0; i < Dim; i++) {
740          const int ColId = EigV[i].Dat;
741          TFltV& v = CompV[i]; v.Gen(Size);
742          TLinAlg::Multiply(K, V, ColId, v); 
743          TLinAlg::MultiplyScalar(d[ColId], v, v);
744      }
745  }
746  PSemSpace TSemSpaceAlg::CalcKPCA(PSVMTrainSet Set) {
747      const int Dim = Set->Len(); TVec<TFltV> CompV;
748      DecomposeKernelMatrix(Set, Dim, CompV, true);
749      TVec<TFltV> PrCompV(CompV.Len());
750      for (int i = 0; i < PrCompV.Len(); i++)
751          Set->LinComb(CompV[i], PrCompV[i]);
752      return TVecSemSpace::New(PrCompV, "KPCA");
753  }
754  PSemSpace TSemSpaceAlg::CalcKPCA(const TVec<PBowSpV>& BowSpV) {
755      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowSpV);
756      return CalcKPCA(Set);
757  }
758  PSemSpace TSemSpaceAlg::CalcKPCA(PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV) {
759      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
760      return CalcKPCA(Set);
761  }
762  PSemSpace TSemSpaceAlg::CalcFullLSI(PSVMTrainSet Set, const int& SpaceDim) {
763      const int Dim = Set->Len(); TVec<TFltV> CompV;
764      DecomposeKernelMatrix(Set, Dim, CompV, false);
765      const int CompN = TInt::GetMn(CompV.Len(), SpaceDim+1);
766      TVec<TFltV> PrCompV(CompN-1);
767      for (int i = 1; i < CompN ; i++) {
768          Set->LinComb(CompV[i], PrCompV[i-1]);
769      }
770      return TVecSemSpace::New(PrCompV, "FullLSI");
771  }
772  PSemSpace TSemSpaceAlg::CalcFullLSI(const TVec<PBowSpV>& BowSpV, const int& SpaceDim) {
773      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowSpV);
774      return CalcFullLSI(Set, SpaceDim);
775  }
776  PSemSpace TSemSpaceAlg::CalcFullLSI(PBowDocWgtBs BowDocWgtBs, 
777          const TIntV& DIdV, const int& SpaceDim) {
778      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
779      return CalcFullLSI(Set, SpaceDim);
780  }
781  PSemSpace TSemSpaceAlg::CalcSparseLSI(TMatrix& TermDocM, const int& _SpaceDim, 
782          const int& _MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
783      const int SpaceDim = TInt::GetMn(_SpaceDim, TermDocM.GetCols());
784      const int MaxLanczos = TInt::GetMn(_MaxLanczos, TermDocM.GetCols());
785      IAssertR(SpaceDim <= MaxLanczos, TStr::Fmt("%d <= %d", SpaceDim, MaxLanczos));
786      TFltV SgnV; TFltVV U, V; const int SgnN = SpaceDim;
787      if (TermDocM.GetCols() <= TermDocM.GetRows()) {
788          TSparseSVD::LanczosSVD(TermDocM, SgnN, 
789              TInt::GetMn(SgnN*4, MaxLanczos), ReOrtoType, SgnV, U, V);
790      } else {
791  	    TermDocM.Transpose();
792  	    TSparseSVD::LanczosSVD(TermDocM, SgnN, 
793              TInt::GetMn(SgnN*4, MaxLanczos), ReOrtoType, SgnV, V, U);
794  	    TermDocM.Transpose();
795      }
796      IAssert(U.GetYDim() <= SgnN);
797      return TVecSemSpace::New(U, "SparseLSI");
798  }
799  PSemSpace TSemSpaceAlg::CalcSparseLSI(PSVMTrainSet Set, const int& SpaceDim, 
800          const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
801      TSTSetMatrix TermDocM(Set);
802      return CalcSparseLSI(TermDocM, SpaceDim, 
803          TInt::GetMn(MaxLanczos, Set->Len()), ReOrtoType);
804  }
805  PSemSpace TSemSpaceAlg::CalcSparseLSI(const TVec<PBowSpV>& BowSpV,
806          const int& SpaceDim, const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
807      TBowMatrix TermDocM(BowSpV);
808      return CalcSparseLSI(TermDocM, SpaceDim, 
809          TInt::GetMn(MaxLanczos, BowSpV.Len()), ReOrtoType);
810  }
811  PSemSpace TSemSpaceAlg::CalcSparseLSI(PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV,
812          const int& SpaceDim, const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
813      TBowMatrix TermDocM(BowDocWgtBs, DIdV);
814      return CalcSparseLSI(TermDocM, SpaceDim, 
815          TInt::GetMn(MaxLanczos, DIdV.Len()), ReOrtoType);
816  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-subgraph.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-semspace.cpp</div>
                </div>
                <div class="column column_space"><pre><code>52        const TNGraph::TNodeI NI = Graph->GetNI(SrcNId);
53        for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
54          const int OutNId = NI.GetOutNId(edge);
</pre></code></div>
                <div class="column column_space"><pre><code>244          TIntFltPrV PSpV(Vecs, 0); double VecNorm = 0.0;
245          for (int i = 0; i < Vecs; i++) {
246              const double Elt = TBowLinAlg::DotProduct(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    