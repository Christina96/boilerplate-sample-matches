
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.890089533806731%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssch.cpp</h3>
            <pre><code>1  #include "sch.h"
2  TSchTask::TSchTask(const int& _TaskId, const TStrV& _DimObjNmV,
3   const TSecTm& _StartTm, const TSecTm& _EndTm):
4    TaskId(_TaskId), DimObjNmV(_DimObjNmV), StartTm(_StartTm), EndTm(_EndTm){
5    IAssert(StartTm<EndTm);
6  }
7  TStr TSchTask::GetStr() const {
8    TChA ChA;
9    for (int DimN=0; DimN<DimObjNmV.Len(); DimN++){
10      if (DimN>0){ChA+=' ';}
11      ChA+=DimObjNmV[DimN];
<span onclick='openModal()' class='match'>12    }
13    return ChA;
14  }
15  bool TSchTask::IsCons(const PSchTask& Task1, const PSchTask& Task2){
16    return
17     (Task1->GetEndTm()<=Task2->GetStartTm())||
18     (Task2->GetEndTm()<=Task1->GetStartTm());
19  }
20  PSchTask TSchTask::LoadTxt(TILx& Lx){
</span>21    PSchTask SchTask=PSchTask(new TSchTask());
22    Lx.GetVar("SchTask", true, true);
23    SchTask->TaskId=Lx.GetVarInt("TaskId");
24    Lx.GetVarStrV("DimObjNmV", SchTask->DimObjNmV);
25    SchTask->StartTm=Lx.GetVarSecTm("StartTm");
26    SchTask->EndTm=Lx.GetVarSecTm("EndTm");
27    Lx.GetVarEnd(true, true);
28    return SchTask;
29  }
30  void TSchTask::SaveTxt(TOLx& Lx) const {
31    Lx.PutVar("SchTask", true, true);
32    Lx.PutVarInt("TaskId", TaskId);
33    Lx.PutVarStrV("DimObjNmV", DimObjNmV);
34    Lx.PutVarSecTm("StartTm", StartTm);
35    Lx.PutVarSecTm("EndTm", EndTm);
36    Lx.PutVarEnd(true, true);
37  }
38  void TSchObj::AddTask(const PSchTask& Task){
39    IAssert(IsTaskOk(Task));
40    TTmTaskKd TmTaskKd(Task->GetStartTm(), Task);
41    int TaskN=TaskV.AddSorted(TmTaskKd);
42    if (0<TaskN){
43      PSchTask PrevTask=TaskV[TaskN-1].Dat;
44      IAssert(TSchTask::IsCons(PrevTask, Task));
45    }
46    if (TaskN+1<TaskV.Len()){
47      PSchTask NextTask=TaskV[TaskN+1].Dat;
48      IAssert(TSchTask::IsCons(Task, NextTask));
49    }
50  }
51  void TSchObj::DelTask(const PSchTask& Task){
52    TTmTaskKd TmTaskKd(Task->GetStartTm(), Task);
53    int TaskN=TaskV.SearchBin(TmTaskKd);
54    IAssert(TaskN!=-1);
55    IAssert(Task->GetTaskId()==TaskV[TaskN].Dat->GetTaskId());
56    TaskV.Del(TaskN);
57  }
58  bool TSchObj::IsTaskAtTm(const TSecTm& Tm, PSchTask& Task) const {
59    TTmTaskKd TmTaskKd(Tm);
60    int InsTaskN; int TaskN=TaskV.SearchBin(TmTaskKd, InsTaskN);
61    if (TaskN==-1){
62      if (InsTaskN==0){
63        Task=NULL; return false;
64      } else
65      if (TaskV[InsTaskN-1].Dat->IsTmIn(Tm)){
66        Task=TaskV[InsTaskN-1].Dat; return true;
67      } else {
68        Task=NULL; return false;
69      }
70    } else {
71      Task=TaskV[TaskN].Dat; return true;
72    }
73  }
74  bool TSchObj::IsTaskInTm(
75   const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
76    TTmTaskKd StartTmTaskKd(MnTm);
77    TTmTaskKd EndTmTaskKd(MxTm);
78    int StartInsTaskN; int EndInsTaskN;
79    int StartTaskN=TaskV.SearchBin(StartTmTaskKd, StartInsTaskN);
80    int EndTaskN=TaskV.SearchBin(EndTmTaskKd, EndInsTaskN);
81    if ((StartTaskN==-1)&&(EndTaskN==-1)){
82      if (StartInsTaskN==EndInsTaskN){
83        if (StartInsTaskN==0){
84          Task=NULL; return false;
85        } else
86        if (TaskV[StartInsTaskN-1].Dat->IsTmIn(MnTm)){
87          Task=TaskV[StartInsTaskN-1].Dat; return true;
88        } else {
89          Task=NULL; return false;
90        }
91      } else {
92        Task=TaskV[StartInsTaskN].Dat; return true;
93      }
94    } else {
95      if (StartTaskN!=-1){IsTaskAtTm(MnTm, Task);}
96      else if (EndTaskN!=-1){IsTaskAtTm(MxTm, Task);}
97      else {Fail;}
98      IAssert(!Task.Empty());
99      return true;
100    }
101  }
102  PSchObj TSchObj::LoadTxt(TILx& Lx){
103    PSchObj SchObj=PSchObj(new TSchObj());
104    Lx.GetVar("SchObj", true, true);
105    SchObj->Nm=Lx.GetVarStr("Nm");
106    Lx.GetVar("TaskV", true, true);
107    while (!Lx.PeekVarEnd(true, true)){
108      PSchTask Task=TSchTask::LoadTxt(Lx);
109      SchObj->TaskV.Add(TTmTaskKd(Task->GetStartTm(), Task));
110    }
111    Lx.GetVarEnd(true, true);
112    Lx.GetVarEnd(true, true);
113    return SchObj;
114  }
115  void TSchObj::SaveTxt(TOLx& Lx) const {
116    Lx.PutVar("SchObj", true, true);
117    Lx.PutVarStr("Nm", Nm);
118    Lx.PutVar("TaskV", true, true);
119    for (int TaskN=0; TaskN<TaskV.Len(); TaskN++){
120      TaskV[TaskN].Dat->SaveTxt(Lx);}
121    Lx.PutVarEnd(true, true);
122    Lx.PutVarEnd(true, true);
123  }
124  int TSchDim::AddObj(const TStr& Nm){
125    IAssert(!NmToObjH.IsKey(Nm));
126    PSchObj Obj=PSchObj(new TSchObj(Nm));
127    NmToObjH.AddDat(Nm, Obj);
128    return NmToObjH.GetKeyId(Nm);
129  }
130  TStrV TSchDim::GetObjNmV() const {
131    TStrV NmV(NmToObjH.Len(), 0);
132    int NmToObjP=NmToObjH.FFirstKeyId();
133    while (NmToObjH.FNextKeyId(NmToObjP)){
134      NmV.Add(NmToObjH[NmToObjP]->GetNm());}
135    return NmV;
136  }
137  void TSchDim::AddTask(const PSchTask& Task){
138    PSchObj Obj=GetObj(Task->GetDimObjNm(DimN));
139    Obj->AddTask(Task);
140  }
141  void TSchDim::DelTask(const PSchTask& Task){
142    PSchObj Obj=GetObj(Task->GetDimObjNm(DimN));
143    Obj->DelTask(Task);
144  }
145  bool TSchDim::IsTaskOk(const PSchTask& Task, PSchTask& IcTask) const {
146    PSchObj Obj=GetObj(Task->GetDimObjNm(DimN));
147    return Obj->IsTaskOk(Task, IcTask);
148  }
149  bool TSchDim::IsTaskInTm(const TStr& ObjNm,
150   const TSecTm& MnTm, const TSecTm& MxTm, PSchTask& Task) const {
151    PSchObj Obj=GetObj(ObjNm);
152    return Obj->IsTaskInTm(MnTm, MxTm, Task);
153  }
154  PSchDim TSchDim::LoadTxt(TILx& Lx){
155    PSchDim SchDim=PSchDim(new TSchDim());
156    Lx.GetVar("SchDim", true, true);
157    SchDim->DimN=Lx.GetVarInt("DimN");
158    SchDim->Nm=Lx.GetVarStr("Nm");
159    Lx.GetVar("NmToObjH", true, true);
160    int Ports=Lx.GetVarInt("Ports");
161    SchDim->NmToObjH=TNmToObjH(Ports);
162    while (!Lx.PeekVarEnd(true, true)){
163      PSchObj Obj=TSchObj::LoadTxt(Lx);
164      SchDim->NmToObjH.AddDat(Obj->GetNm(), Obj);
165    }
166    Lx.GetVarEnd(true, true);
167    Lx.GetVarEnd(true, true);
168    return SchDim;
169  }
170  void TSchDim::SaveTxt(TOLx& Lx) const {
171    Lx.PutVar("SchDim", true, true);
172    Lx.PutVarInt("DimN", DimN);
173    Lx.PutVarStr("Nm", Nm);
174    Lx.PutVar("NmToObjH", true, true);
175    int NmToObjP=NmToObjH.FFirstKeyId();
176    Lx.PutVarInt("Ports", NmToObjH.GetPorts());
177    while (NmToObjH.FNextKeyId(NmToObjP)){
178      NmToObjH[NmToObjP]->SaveTxt(Lx);}
179    Lx.PutVarEnd(true, true);
180    Lx.PutVarEnd(true, true);
181  }
182  TSch::TSch(const TStr& _Nm, const int& Dims,
183   const int& ExpObjs, const int& ExpTasks):
184    Nm(_Nm), DimV(Dims), LastTaskId(0), IdToTaskH(ExpTasks){
185    for (int DimN=0; DimN<Dims; DimN++){
186      DimV[DimN]=PSchDim(new TSchDim(DimN, ExpObjs));}
187  }
188  TStrV TSch::GetDimNmV() const {
189    TStrV DimNmV(GetDims(), 0);
190    for (int DimN=0; DimN<GetDims(); DimN++){
191      DimNmV.Add(GetDimNm(DimN));}
192    return DimNmV;
193  }
194  int TSch::GetDimN(const TStr& DimNm) const {
195    for (int DimN=0; DimN<GetDims(); DimN++){
196      if (GetDimNm(DimN)==DimNm){return DimN;}}
197    return -1;
198  }
199  int TSch::AddTask(
200   const TStrV& DimObjNmV, const TSecTm& StartTm, const TSecTm& EndTm){
201    IAssert(DimObjNmV.Len()==GetDims());
202    int TaskId=GetNewTaskId();
203    PSchTask Task=PSchTask(new TSchTask(TaskId, DimObjNmV, StartTm, EndTm));
204    IdToTaskH.AddDat(TaskId, Task);
205    for (int DimN=0; DimN<GetDims(); DimN++){
206      DimV[DimN]->AddTask(Task);}
207    return TaskId;
208  }
209  int TSch::AddTask(
210   const TStr& DimObjNm1, const TStr& DimObjNm2, const TStr& DimObjNm3,
211   const TSecTm& StartTm, const TSecTm& EndTm){
212    TStrV DimObjNmV(3, 0);
213    DimObjNmV.Add(DimObjNm1);
214    DimObjNmV.Add(DimObjNm2);
215    DimObjNmV.Add(DimObjNm3);
216    return AddTask(DimObjNmV, StartTm, EndTm);
217  }
218  void TSch::DelTask(const int& TaskId){
219    PSchTask Task=IdToTaskH.GetDat(TaskId);
220    for (int DimN=0; DimN<GetDims(); DimN++){
221      DimV[DimN]->DelTask(Task);}
222  }
223  bool TSch::IsTask(const int& TaskId, PSchTask& Task) const {
224    int IdToTaskP;
225    if (IdToTaskH.IsKey(TaskId, IdToTaskP)){
226      Task=IdToTaskH[IdToTaskP]; return true;}
227    else {return false;}
228  }
229  bool TSch::IsTaskOk(const PSchTask& Task, TSchTaskV& DimIcTaskV) const {
230    DimIcTaskV.Gen(GetDims(), GetDims());
231    bool Ok=true;
232    for (int DimN=0; DimN<GetDims(); DimN++){
233      PSchTask IcTask;
234      if (!DimV[DimN]->IsTaskOk(Task, IcTask)){
235        DimIcTaskV[DimN]=IcTask; Ok=false;
236      }
237    }
238    return Ok;
239  }
240  PSch TSch::LoadTxt(TILx& Lx){
241    PSch Sch=PSch(new TSch());
242    Lx.GetVar("Sch", true, true);
243    Sch->Nm=Lx.GetVarStr("Nm");
244    Lx.GetVar("DimV", true, true);
245    while (!Lx.PeekVarEnd(true, true)){
246      Sch->DimV.Add(TSchDim::LoadTxt(Lx));}
247    Lx.GetVarEnd(true, true);
248    Sch->LastTaskId=Lx.GetVarInt("LastTaskId");
249    Lx.GetVar("IdToTaskH", true, true);
250    int Ports=Lx.GetVarInt("Ports");
251    Sch->IdToTaskH=TIdToTaskH(Ports);
252    while (!Lx.PeekVarEnd(true, true)){
253      PSchTask Task=TSchTask::LoadTxt(Lx);
254      Sch->IdToTaskH.AddDat(Task->GetTaskId(), Task);
255    }
256    Lx.GetVarEnd(true, true);
257    Lx.GetVarEnd(true, true);
258    return Sch;
259  }
260  PSch TSch::LoadTxt(const TStr& FNm){
261    PSIn SIn=PSIn(new TFIn(FNm));
262    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloCsSens);
263    return LoadTxt(Lx);
264  }
265  void TSch::SaveTxt(TOLx& Lx) const {
266    Lx.PutVar("Sch", true, true);
267    Lx.PutVarStr("Nm", Nm);
268    Lx.PutVar("DimV", true, true);
269    for (int DimN=0; DimN<DimV.Len(); DimN++){
270      DimV[DimN]->SaveTxt(Lx);}
271    Lx.PutVarEnd(true, true);
272    Lx.PutVarInt("LastTaskId", LastTaskId);
273    Lx.PutVar("IdToTaskH", true, true);
274    Lx.PutVarInt("Ports", IdToTaskH.GetPorts());
275    int IdToTaskP=IdToTaskH.FFirstKeyId();
276    while (IdToTaskH.FNextKeyId(IdToTaskP)){
277      IdToTaskH[IdToTaskP]->SaveTxt(Lx);}
278    Lx.PutVarEnd(true, true);
279    Lx.PutVarEnd(true, true);
280  }
281  void TSch::SaveTxt(const TStr& FNm) const {
282    PSOut SOut=PSOut(new TFOut(FNm));
283    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens|oloVarIndent);
284    SaveTxt(Lx);
285  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-shash.h</h3>
            <pre><code>1  #ifndef shash_h
2  #define shash_h
3  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
4  class TKeyDatFl {
5  private:
6    TInt ElemCnt;
7    TFIn FIn;
8    TKey Key;
9    TDat Dat;
10  public:
11    TKeyDatFl(const TStr& FNm) : FIn(FNm) { ElemCnt.Load(FIn); }
12    int Len() const { return ElemCnt; }
<span onclick='openModal()' class='match'>13    bool Next() { if (FIn.Eof()) { return false; }
14      Key.Load(FIn);  Dat.Load(FIn); return true; }
15    const TKey& GetKey() const { return Key; }
16    TKey& GetKey() { return Key; }
</span>17    const TDat& GetDat() const { return Dat; }
18    TDat& GetDat() { return Dat; }
19    static void Save(const TStr& OutFNm, const THash<TKey, TDat, THashFunc>& Hash) {
20      TFOut FOut(OutFNm);  Load(FOut, Hash); }
21    static void Save(TSOut& SOut, const THash<TKey, TDat, THashFunc>& Hash) {
22      SOut.Save(Hash.Len());
23      for (int k = Hash.FFirstKeyId(); Hash.FNextKeyId(k); ) {
24        Hash.GetKey(k).Save(SOut);  Hash[k].Save(SOut); }
25    }
26    static void LoadHash(const TStr& InFNm, THash<TKey, TDat, THashFunc>& Hash, const int& LoadN=-1) {
27      TFIn FIn(InFNm);  Load(FIn, Hash, LoadN); }
28    static void LoadHash(TSIn& SIn, THash<TKey, TDat, THashFunc>& Hash, int LoadN=-1) {
29      TInt ElemCnt(SIn);  const int Start=clock();
30      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
31      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  Hash.Gen(LoadN);
32      for (int i = 0; i < LoadN; i++) { Hash.AddDat(TKey(SIn)).Load(SIn); }
33      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
34    }
35    static void LoadKeyV(TSIn& SIn, TVec<TKey>& KeyV, int LoadN=-1) {
36      TInt ElemCnt(SIn);  const int Start=clock();
37      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
38      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  KeyV.Gen(LoadN, 0);
39      for (int i = 0; i < LoadN; i++) { KeyV.Add(TKey(SIn));  TDat D(SIn); }
40      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
41    }
42    static void LoadDatV(TSIn& SIn, TVec<TDat>& DatV, int LoadN=-1) {
43      TInt ElemCnt(SIn);  const int Start=clock();
44      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
45      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  DatV.Gen(LoadN, 0);
46      for (int i = 0; i < LoadN; i++) { TKey(SIn);  DatV.Add(TDat(SIn)); }
47      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
48    }
49  };
50  template <class TVal, uint16 GroupSize> 
51  class TSparseGroup {
52  private:
53    unsigned char BitSet [(GroupSize-1)/8 + 1];   
54    uint16 Buckets;                               
55    TVal *Group;
56  private:
57    static int CharBit(const int&  ValN) { return ValN >> 3; }
58    static int ModBit(const int&  ValN) { return 1 << (ValN&7); }
59    bool BMTest(const int&  ValN) const { return (BitSet[CharBit(ValN)] & ModBit(ValN)) != 0; }
60    void BMSet(const int&  ValN) { BitSet[CharBit(ValN)] |= ModBit(ValN); }
61    void BMClear(const int&  ValN) { BitSet[CharBit(ValN)] &= ~ModBit(ValN); }
62    static int PosToOffset(const unsigned char *BitSet, int Pos);
63  public:
64    TSparseGroup() : Buckets(0), Group(NULL) { memset(BitSet, 0, sizeof(BitSet)); }
65    TSparseGroup(TSIn& SIn) : Buckets(0), Group(NULL) { Load(SIn); }
66    TSparseGroup(const TSparseGroup& SG);
67    ~TSparseGroup() { if (Group != NULL) delete [] Group; }
68    void Load(TSIn& SIn);
69    void Save(TSOut& SOut) const;
70    TSparseGroup& operator = (const TSparseGroup& SG);
71    bool operator == (const TSparseGroup& SG) const;
72    bool operator < (const TSparseGroup& SG) const;
73    int Len() const { return Buckets; }
74    int MxLen() const { return GroupSize; }
75    int Reserved() const { return GroupSize; }
76    bool Empty() const { return Buckets == 0; }
77    void Clr(const bool& DoDel = true);
78    int GetGroupSize() const { return GroupSize; }
79    uint GetDiskSz() const { return sizeof(BitSet) + sizeof(uint16) + Buckets*sizeof(TVal); }
80    bool IsEmpty(const int& ValN) const { return ! BMTest(ValN); }
81    const TVal& Offset(const int& Pos) const { return Group[Pos]; }
82    TVal& Offset(const int& Pos) { return Group[Pos]; }
83    int OffsetToPos(int Offset) const;
84    int PosToOffset(int Pos) const { return PosToOffset(BitSet, Pos); }
85    const TVal& DefVal() const { static TVal DefValue = TVal();  return DefValue; }
86    const TVal& Get(const int& ValN) const {
87      if (BMTest(ValN)) return Group[PosToOffset(BitSet, ValN)]; else return DefVal(); }
88    const TVal& operator [] (const int ValN) const { return Get(ValN); }
89    TVal& Set(const int& ValN, const TVal& Val);
90    TVal& Set(const int& ValN) {
91      if (! BMTest(ValN)) Set(ValN, DefVal());
92      return Group[PosToOffset(BitSet, ValN)];
93    }
94    void Del(const int& ValN);
95  };
96  template <class TVal, uint16 GroupSize>
97  int TSparseGroup<TVal, GroupSize>::PosToOffset(const unsigned char *BitSet, int Pos) {
98    static const int bits_in [256] = {      
99      0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
100      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
101      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
102      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
103      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
104      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
105      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
106      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
107      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
108      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
109      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
110      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
111      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
112      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
113      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
114      4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
115    };
116    int Offset = 0;
117    for ( ; Pos > 8; Pos -= 8 )                        
118      Offset += bits_in[*BitSet++];                    
119    return Offset + bits_in[*BitSet & ((1 << Pos)-1)]; 
120  }
121  template <class TVal, uint16 GroupSize>
122  TSparseGroup<TVal, GroupSize>::TSparseGroup(const TSparseGroup& SG) : Buckets(SG.Buckets), Group(NULL) {
123    memcpy(BitSet, SG.BitSet, sizeof(BitSet));
124    if (Buckets > 0) {
125      Group = new TVal [Buckets];
126      for (int b = 0; b < Buckets; b++) { Group[b] = SG.Group[b]; }
127    }
128  }
129  template <class TVal, uint16 GroupSize>
130  void TSparseGroup<TVal, GroupSize>::Load(TSIn& SIn) {
131    SIn.LoadBf(BitSet, sizeof(BitSet));
132    SIn.Load(Buckets);
133    if (Group != NULL) delete [] Group;
134    Group = new TVal [Buckets];
135    for (int b = 0; b < Buckets; b++) { Group[b] = TVal(SIn); }
136  }
137  template <class TVal, uint16 GroupSize>
138  void TSparseGroup<TVal, GroupSize>::Save(TSOut& SOut) const {
139    SOut.SaveBf(BitSet, sizeof(BitSet));
140    SOut.Save(Buckets);
141    for (int b = 0; b < Buckets; b++) { Group[b].Save(SOut); }
142  }
143  template <class TVal, uint16 GroupSize>
144  TSparseGroup<TVal, GroupSize>& TSparseGroup<TVal, GroupSize>::operator = (const TSparseGroup& SG) {
145    if (this != &SG) {
146      if (SG.Buckets == 0 && Group != NULL) {
147        delete [] Group;
148        Group = 0;
149      } else {
150        if (Buckets != SG.Buckets) {
151          if (Group != NULL) delete [] Group;
152          Group = new TVal [SG.Buckets];
153        }
154        for (int b = 0; b < SG.Buckets; b++) { Group[b] = SG.Group[b]; }
155      }
156      Buckets = SG.Buckets;
157      memcpy(BitSet, SG.BitSet, sizeof(BitSet));
158    }
159    return *this;
160  }
161  template <class TVal, uint16 GroupSize>
162  bool TSparseGroup<TVal, GroupSize>::operator == (const TSparseGroup& SG) const {
163    if (Buckets == SG.Buckets && memcmp(BitSet, SG.BitSet, sizeof(BitSet)) == 0) {
164      for (int b = 0; b < Buckets; b++) {
165        if (Group[b] != SG.Group[b]) return false;
166      }
167      return true;
168    }
169    return false;
170  }
171  template <class TVal, uint16 GroupSize>
172  bool TSparseGroup<TVal, GroupSize>::operator < (const TSparseGroup& SG) const {
173    if (Buckets < SG.Buckets) return true;
174    if (memcmp(BitSet, SG.BitSet, sizeof(BitSet)) == -1) return true;
175    for (int b = 0; b < Buckets; b++) {
176      if (Group[b] < SG.Group[b]) return true;
177    }
178    return false;
179  }
180  template <class TVal, uint16 GroupSize>
181  int TSparseGroup<TVal, GroupSize>::OffsetToPos(int Offset) const {
182    Assert(Offset < Buckets);
183    for (int i = 0; i < sizeof(BitSet); i++) {
184      for (int b = 0; b < 8; b++) {
185        if (TB1Def::GetBit(b, BitSet[i])) {
186          if (Offset == 0) return i*8 + b;
187          Offset--;
188        }
189      }
190    }
191    Fail;
192    return -1;
193  }
194  template <class TVal, uint16 GroupSize>
195  void TSparseGroup<TVal, GroupSize>::Clr(const bool& DoDel) {
196    if (DoDel && Group != NULL) {
197      delete [] Group;
198      Group = 0;
199    }
200    memset(BitSet, 0, sizeof(BitSet));
201    Buckets = 0;
202  }
203  template <class TVal, uint16 GroupSize>
204  TVal& TSparseGroup<TVal, GroupSize>::Set(const int& ValN, const TVal& Val) {
205    const int Offset = PosToOffset(BitSet, ValN);
206    if (! BMTest(ValN)) {
207      const TVal *OldGroup = Group;
208      Group = new TVal [Buckets+1];
209      for (int b = 0; b < Offset; b++) Group[b] = OldGroup[b];
210      for (int b = Offset+1; b <= Buckets; b++) Group[b] = OldGroup[b-1];
211      if (OldGroup != NULL) delete [] OldGroup;
212      Buckets++;
213      BMSet(ValN);
214    }
215    Group[Offset] = Val;
216    return Group[Offset];
217  }
218  template <class TVal, uint16 GroupSize>
219  void TSparseGroup<TVal, GroupSize>::Del(const int& ValN) {
220    if (BMTest(ValN)) {
221      const int Offset = PosToOffset(BitSet, ValN);
222      if (--Buckets == 0) {
223        delete [] Group;
224        Group = 0;
225      } else {
226        const TVal *OldGroup = Group;
227        Group = new TVal [Buckets];
228        for (int b = 0; b < Offset; b++) Group[b] = OldGroup[b];
229        for (int b = Offset+1; b <= Buckets; b++) Group[b-1] = OldGroup[b];
230        if (OldGroup != NULL) delete [] OldGroup;
231      }
232      BMClear(ValN);
233    }
234  }
235  template <class TVal, uint16 GroupSize>
236  class TSparseTableI {
237  private:
238    typedef TSparseGroup<TVal, GroupSize> TValGroup;
239    typedef typename TVec<TValGroup>::TIter TGroupVI;
240    int CurOff; 
241    TGroupVI BegI, GroupI, EndI;
242  public:
243    TSparseTableI() : CurOff(0), GroupI(NULL), EndI(NULL) { }
244    TSparseTableI(const TGroupVI& BegIter, const TGroupVI& CurIter, const TGroupVI& EndIter,
245      const int& Offset = 0) : CurOff(Offset), BegI(BegIter), GroupI(CurIter), EndI(EndIter) { }
246    TSparseTableI(const TSparseTableI& STI) :
247      CurOff(STI.CurOff), BegI(STI.BegI), GroupI(STI.GroupI), EndI(STI.EndI) { }
248    TSparseTableI& operator = (const TSparseTableI& STI) {
249      CurOff=STI.CurOff;  BegI=STI.BegI;  GroupI=STI.GroupI;  EndI=STI.EndI;  return *this; }
250    bool operator == (const TSparseTableI& STI) const {
251      return GroupI == STI.GroupI && CurOff == STI.CurOff; }
252    bool operator < (const TSparseTableI& STI) const {
253      return GroupI < STI.GroupI || (GroupI == STI.GroupI && CurOff < STI.CurOff); }
254    TSparseTableI& operator++ (int) {
255      if (CurOff+1 == GroupI->Len()) { CurOff = 0;
256        if (GroupI < EndI) { GroupI++;
257          while (GroupI < EndI && GroupI->Empty()) { GroupI++; } }
258      } else { CurOff++; }
259      return *this;
260    }
261    TSparseTableI& operator-- (int) {
262      if (CurOff == 0) {
263        while (GroupI >= BegI && GroupI->Empty()) { GroupI--; }
264        if (GroupI >= BegI) CurOff = GroupI->Len()-1;
265      } else { CurOff--; }
266      return *this;
267    }
268    int GetValN() const { return int(GroupI-BegI)*GroupSize + GroupI->OffsetToPos(CurOff); }
269    bool IsEnd() const { return GroupI==EndI; }
270    TVal& operator*() const { return GroupI->Offset(CurOff); }
271    TVal& operator()() const { return GroupI->Offset(CurOff); }
272    TVal* operator->() const { return &(operator*()); }
273  };
274  template <class TVal, uint16 GroupSize = 48> 
275  class TSparseTable {
276  public:
277    typedef TSparseGroup<TVal, GroupSize> TSGroup;
278    typedef TSparseTableI<TVal, GroupSize> TIter;
279  private:
280    TInt MxVals, Vals;
281    TVec<TSGroup> GroupV;
282  private:
283    static int GetGroups(const int& Vals) { return Vals == 0 ? 0 : ((Vals-1) / GroupSize) + 1; }
284    int PosInGroup(const int& ValN) const { return ValN % GroupSize; }
285    int GroupNum(const int& ValN) const { return ValN / GroupSize; }
286    const TSGroup& GetGrp1(const int& ValN) const { return GroupV[GroupNum(ValN)]; }
287    TSGroup& GetGrp1(const int& ValN) { return GroupV[GroupNum(ValN)]; }
288  public:
289    TSparseTable(const int& MaxVals = 0) : MxVals(MaxVals),
290      Vals(0), GroupV(GetGroups(MaxVals), GetGroups(MaxVals)) { }
291    TSparseTable(const TSparseTable& ST) : MxVals(ST.MxVals), Vals(ST.Vals), GroupV(ST.GroupV) { }
292    TSparseTable(TSIn& SIn) : MxVals(SIn), Vals(SIn), GroupV(SIn) { }
293    void Load(TSIn& SIn) { MxVals.Load(SIn);  Vals.Load(SIn);  GroupV.Load(SIn); }
294    void Save(TSOut& SOut) const { MxVals.Save(SOut);  Vals.Save(SOut);  GroupV.Save(SOut); }
295    TSparseTable& operator = (const TSparseTable& ST);
296    bool operator == (const TSparseTable& ST) const;
297    bool operator < (const TSparseTable& ST) const;
298    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Vals*sizeof(TVal)+GroupV.GetMemUsed(); }
299    TIter BegI() const {
300      if (Len() > 0) { int B = 0;
301        while (B < Groups() && GroupV[B].Empty()) { B++; }
302        return TIter(GroupV.BegI(), GroupV.BegI()+B, GroupV.EndI()); }
303      return TIter(GroupV.BegI(), GroupV.EndI(), GroupV.EndI());
304    }
305    TIter EndI() const { return TIter(GroupV.BegI(), GroupV.EndI(), GroupV.EndI()); }
306    TIter GetI(const int& ValN) const { Assert(! IsEmpty(ValN));
307      typedef typename TVec<TSGroup>::TIter TVIter;
308      const TVIter GI = GroupV.GetI(GroupNum(ValN));
309      return TIter(GroupV.BegI(), GI, GroupV.EndI(), GI->PosToOffset(PosInGroup(ValN)));
310    }
311    int Len() const { return Vals; }
312    int Reserved() const { return MxVals; }
313    int Groups() const { return GroupV.Len(); }
314    bool Empty() const { return Vals == 0; }
315    uint GetDiskSz() const {
316      return sizeof(TInt)*4 + ((GroupSize+16)/8)*Groups() + sizeof(TVal)*Vals; }
317    void Clr(const bool& DoDel = true);
318    void Reserve(const int NewVals) { Resize(NewVals); }
319    void Resize(const int& NewVals);
320    void Swap(TSparseTable& ST);
321    bool IsEmpty(const int& ValN) const { return GroupV[GroupNum(ValN)].IsEmpty(PosInGroup(ValN)); }
322    const TVal& Get(const int& ValN) const { return GroupV[GroupNum(ValN)].Get(PosInGroup(ValN)); }
323    TVal& Set(const int& ValN, const TVal& Val);
324    TVal& Set(const int& ValN);
325    void Del(const int& ValN);
326    TSGroup& GetGroup(const int& GroupN) { return GroupV[GroupN]; }
327    const TSGroup& GetGroup(const int& GroupN) const { return GroupV[GroupN]; }
328  };
329  template <class TVal, uint16 GroupSize>
330  TSparseTable<TVal, GroupSize>& TSparseTable<TVal, GroupSize>::operator = (const TSparseTable& ST) {
331    if (this != &ST) {
332      MxVals = ST.MxVals;
333      Vals = ST.Vals;
334      GroupV = ST.GroupV;
335    }
336    return *this;
337  }
338  template <class TVal, uint16 GroupSize>
339  bool TSparseTable<TVal, GroupSize>::operator == (const TSparseTable& ST) const {
340    return Vals == ST.Vals && MxVals == ST.MxVals && GroupV == ST.GroupV;
341  }
342  template <class TVal, uint16 GroupSize>
343  bool TSparseTable<TVal, GroupSize>::operator < (const TSparseTable& ST) const {
344    return Vals < ST.Vals || (Vals == ST.Vals && GroupV < ST.GroupV);
345  }
346  template <class TVal, uint16 GroupSize>
347  void TSparseTable<TVal, GroupSize>::Clr(const bool& DoDel) {
348    if (! DoDel) {
349      for (int g = 0; g < GroupV.Len(); g++) GroupV[g].Clr(false);
350    } else {
351      MxVals = 0;
352      GroupV.Clr(true);
353    }
354    Vals = 0;
355  }
356  template <class TVal, uint16 GroupSize>
357  void TSparseTable<TVal, GroupSize>::Resize(const int& NewVals) {
358    if (NewVals > MxVals) {
359      const int Groups = GetGroups(NewVals);
360      GroupV.Reserve(Groups, Groups);
361      MxVals = NewVals;
362    }
363  }
364  template <class TVal, uint16 GroupSize>
365  void TSparseTable<TVal, GroupSize>::Swap(TSparseTable& ST) {
366    ::Swap(MxVals, ST.MxVals);
367    ::Swap(Vals, ST.Vals);
368    GroupV.Swap(ST.GroupV);
369  }
370  template <class TVal, uint16 GroupSize>
371  TVal& TSparseTable<TVal, GroupSize>::Set(const int& ValN, const TVal& Val) {
372    Assert(ValN < MxVals);
373    TSGroup& Group = GetGrp1(ValN);
374    const int OldVals = Group.Len();
375    TVal& ValRef = Group.Set(PosInGroup(ValN), Val);
376    Vals += Group.Len() - OldVals;
377    return ValRef;
378  }
379  template <class TVal, uint16 GroupSize>
380  TVal& TSparseTable<TVal, GroupSize>::Set(const int& ValN) {
381    Assert(ValN < MxVals);
382    TSGroup& Group = GetGrp1(ValN);
383    const int OldVals = Group.Len();
384    TVal& ValRef = Group.Set(PosInGroup(ValN));
385    Vals += Group.Len() - OldVals;
386    return ValRef;
387  }
388  template <class TVal, uint16 GroupSize>
389  void TSparseTable<TVal, GroupSize>::Del(const int& ValN) {
390    Assert(ValN < MxVals);
391    TSGroup& Group = GetGrp1(ValN);
392    const int OldVals = Group.Len();
393    Group.Del(PosInGroup(ValN));
394    Vals += Group.Len() - OldVals;
395  }
396  #pragma pack(push, 1) 
397  template <class TKey, class TDat>
398  class TSHashKeyDat {
399  public:
400    TKey Key;
401    TDat Dat;
402  public:
403    TSHashKeyDat() : Key(), Dat() { }
404    TSHashKeyDat(const TKey& _Key) : Key(_Key), Dat() { }
405    TSHashKeyDat(const TKey& _Key, const TDat& _Dat) : Key(_Key), Dat(_Dat) { }
406    TSHashKeyDat(const TSHashKeyDat& HashKeyDat) : Key(HashKeyDat.Key), Dat(HashKeyDat.Dat) { }
407    explicit TSHashKeyDat(TSIn& SIn) : Key(SIn), Dat(SIn) { }
408    void Save(TSOut& SOut) const { Key.Save(SOut);  Dat.Save(SOut); }
409    TSHashKeyDat& operator = (const TSHashKeyDat& HashKeyDat) { if (this != &HashKeyDat) {
410      Key = HashKeyDat.Key;  Dat = HashKeyDat.Dat; }  return *this; }
411    bool operator == (const TSHashKeyDat& HashKeyDat) const { return Key == HashKeyDat.Key; }
412    bool operator < (const TSHashKeyDat& HashKeyDat) const { return Key < HashKeyDat.Key; }
413    int Hash() const { return Key.GetPrimHashCd(); }
414  };
415  #pragma pack(pop)
416  template <class TKey, class TDat, uint16 GroupSize=48> 
417  class TSparseHash {
418  public:
419    typedef TSHashKeyDat<TKey, TDat> THashKeyDat;
420    typedef typename TSparseTable<THashKeyDat, GroupSize>::TIter TIter;
421    typedef typename TSparseTable<THashKeyDat, GroupSize>::TSGroup TSGroup;
422  public:
423    static const float MxOccupancy; 
424    static const float MnOccupancy; 
425    static const int MinBuckets;    
426  private:
427    void ResetThresh();
428    int GetMinSize(const int& CurVals, const int& WantedVals) const;
429    void CopyFrom(const TSparseHash& HT, const int& MnWanted);
430    void MoveFrom(TSparseHash& HT, const int& MnWanted);
431    void ResizeDelta(const int& ValsToAdd, const int& MnWanted = 0);
432    void FindPos(const TKey& Key, int& Pos, int& PosToIns) const;
433  private:
434    TInt ShrinkThresh, ExpandThresh;
435    TSparseTable<THashKeyDat, GroupSize> Table;
436  public:
437    TSparseHash(const int& WantedVals = 0) : Table(GetMinSize(0, WantedVals)) { ResetThresh(); }
438    TSparseHash(TSIn& SIn) : ShrinkThresh(SIn), ExpandThresh(SIn), Table(SIn) { }
439    void Load(TSIn& SIn) { ShrinkThresh.Load(SIn);  ExpandThresh.Load(SIn);  Table.Load(SIn); }
440    void Save(TSOut& SOut) const { ShrinkThresh.Save(SOut); ExpandThresh.Save(SOut); Table.Save(SOut); }
441    TSparseHash& operator = (const TSparseHash& SHT);
442    bool operator == (const TSparseHash& SHT) const;
443    bool operator < (const TSparseHash& SHT) const;
444    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Table.GetMemUsed(); }
445    TIter BegI() const { return Table.BegI(); }
446    TIter EndI() const { return Table.EndI(); }
447    TIter GetI(const TKey& Key) const { Assert(IsKey(Key));  return Table.GetI(GetKeyId(Key)); }
448    bool Empty() const { return Len() == 0; }
449    int Len() const { return Table.Len(); }
450    int Reserved() const  { return Table.Reserved(); }
451    uint GetDiskSz() const { return 2*sizeof(TInt) + Table.GetDiskSz(); }
452    void Reserve(const int& MxVals) { if (MxVals > Len()) ResizeDelta(MxVals - Len(), 0); }
453    void Clr(const bool& DoDel = true) { Table.Clr(DoDel);  ResetThresh(); }
454    void Swap(TSparseHash& HT);
455    int AddKey(const TKey& Key);
456    TDat& AddDat(const TKey& Key);
457    TDat& AddDat(const TKey& Key, const TDat& Dat);
458    const TKey& GetKey(const int& KeyId) const { return Table.Get(KeyId).Key; }
459    int GetKeyId(const TKey& Key) const {
460      int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);  return Pos; }
461    bool IsKey(const TKey& Key) const { return GetKeyId(Key) != -1; }
462    bool IsKey(const TKey& Key, int& KeyId) const {
463      KeyId = GetKeyId(Key);  return KeyId != -1; }
464    bool IsKeyId(const int& KeyId) const { return ! Table.IsEmpty(KeyId); }
465    int GetRndKeyId(TRnd& Rnd = TInt::Rnd) const { Assert(Len()>0);
466      int KeyId = Rnd.GetUniDevInt(Reserved());
467      while (! IsKeyId(KeyId)) { KeyId = Rnd.GetUniDevInt(Reserved()); } return KeyId; }
468    const TDat& GetDat(const TKey& Key) const;
469    TDat& GetDat(const TKey& Key);
470    const TDat& GetDatKeyId(const int& KeyId) const { return Table.Get(KeyId).Dat; }
471    TDat& GetDatKeyId(const int& KeyId) { return Table.Set(KeyId).Dat; }
472    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const;
473    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const;
474    void GetKeyV(TVec<TKey>& KeyV) const;
475    void GetDatV(TVec<TDat>& DatV) const;
476    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
477    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
478  };
479  template <class TKey, class TDat, uint16 GroupSize>
480  const float TSparseHash<TKey, TDat, GroupSize>::MxOccupancy = 0.8f; 
481  template <class TKey, class TDat, uint16 GroupSize>
482  const float TSparseHash<TKey, TDat, GroupSize>::MnOccupancy = 0.4f * 0.8f; 
483  template <class TKey, class TDat, uint16 GroupSize>
484  const int TSparseHash<TKey, TDat, GroupSize>::MinBuckets = 32;
485  template <class TKey, class TDat, uint16 GroupSize>
486  void TSparseHash<TKey, TDat, GroupSize>::ResetThresh() {
487    ExpandThresh = int(Table.Reserved() * MxOccupancy);
488    ShrinkThresh = int(Table.Reserved() * MnOccupancy);
489  }
490  template <class TKey, class TDat, uint16 GroupSize>
491  int TSparseHash<TKey, TDat, GroupSize>::GetMinSize(const int& CurVals, const int& WantedVals) const {
492    int Size = MinBuckets;
493    while (Size*MxOccupancy < WantedVals || CurVals >= Size * MxOccupancy) Size *= 2;
494    return Size;
495  }
496  template <class TKey, class TDat, uint16 GroupSize>
497  void TSparseHash<TKey, TDat, GroupSize>::CopyFrom(const TSparseHash& HT, const int& MnWanted) {
498    Clr(false);
499    const int NewSize = GetMinSize(HT.Reserved(), MnWanted);
500    if (NewSize > Reserved()) {
501      Table.Resize(NewSize);
502      ResetThresh();
503    }
504    const uint BuckM1 = Reserved() - 1;
505    for (int g = 0; g < HT.Table.Groups(); g++) {
506      const TSGroup& Group = HT.Table.GetGroup(g);
507      for (int b = 0; b < Group.Len(); b++) {
508        int Tries = 0; uint BuckNum;
509        for (BuckNum = Group.Offset(b).Hash() & BuckM1;
510         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
511          Tries++;
512          Assert(Tries < Reserved());
513        }
514        Table.Set(BuckNum, Group.Offset(b));
515      }
516    }
517  }
518  template <class TKey, class TDat, uint16 GroupSize>
519  void TSparseHash<TKey, TDat, GroupSize>::MoveFrom(TSparseHash& HT, const int& MnWanted) {
520    Clr(false);
521    int NewSize;
522    if (MnWanted == 0) NewSize = HT.Reserved();
523    else NewSize = GetMinSize(HT.Reserved(), MnWanted);
524    if (NewSize > Reserved()) {
525      Table.Resize(NewSize);
526      ResetThresh();
527    }
528    const uint BuckM1 = Reserved() - 1;
529    for (int g = 0; g < HT.Table.Groups(); g++) {
530      TSGroup& Group = HT.Table.GetGroup(g);
531      for (int b = 0; b < Group.Len(); b++) {
532        int Tries = 0; uint BuckNum;
533        for (BuckNum = Group.Offset(b).Hash() & BuckM1;
534         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
535          Tries++;
536          Assert(Tries < Reserved());
537        }
538        Assert(Table.IsEmpty(BuckNum));
539        Table.Set(BuckNum, Group.Offset(b));
540      }
541      Group.Clr(true); 
542    }
543  }
544  template <class TKey, class TDat, uint16 GroupSize>
545  void TSparseHash<TKey, TDat, GroupSize>::ResizeDelta(const int& ValsToAdd, const int& MnWanted) {
546    if (Reserved() > MnWanted && Len()+ValsToAdd < ExpandThresh) { return; }
547    const int NewSize = GetMinSize(Table.Len()+ValsToAdd, MnWanted);
548    if (NewSize > Reserved()) {
549      printf("***Resize SparseHash:%d->%d\n", Reserved(), NewSize);
550      TSparseHash TmpHt(ValsToAdd+Len());
551      TmpHt.ResetThresh();
552      TmpHt.MoveFrom(*this, Len());
553      Swap(TmpHt);
554    }
555  }
556  template <class TKey, class TDat, uint16 GroupSize>
557  void TSparseHash<TKey, TDat, GroupSize>::FindPos(const TKey& Key, int& Pos, int& PosToIns) const {
558    const uint BuckM1 = Reserved() - 1;
559    uint BuckNum = Key.GetPrimHashCd() & BuckM1;
560    int Tries = 0;
561    while (true) {
562      if (Table.IsEmpty(BuckNum)) {
563        Pos = -1;  PosToIns = BuckNum;  return;
564      }
565      else if (Key == Table.Get(BuckNum).Key) {
566        Pos = BuckNum;  PosToIns = -1;  return;
567      }
568      Tries++;
569      BuckNum = (BuckNum + Tries) & BuckM1;
570      Assert(Tries < Reserved());
571    }
572  }
573  template <class TKey, class TDat, uint16 GroupSize>
574  TSparseHash<TKey, TDat, GroupSize>& TSparseHash<TKey, TDat, GroupSize>::operator = (const TSparseHash& SHT) {
575    if (this != &SHT) {
576      ShrinkThresh = SHT.ShrinkThresh;
577      ExpandThresh = SHT.ExpandThresh;
578      Table = SHT.Table;
579    }
580    return *this;
581  }
582  template <class TKey, class TDat, uint16 GroupSize>
583  bool TSparseHash<TKey, TDat, GroupSize>::operator == (const TSparseHash& SHT) const {
584    return Table == SHT.Table;
585  }
586  template <class TKey, class TDat, uint16 GroupSize>
587  bool TSparseHash<TKey, TDat, GroupSize>::operator < (const TSparseHash& SHT) const {
588    return Table < SHT.Table;
589  }
590  template <class TKey, class TDat, uint16 GroupSize>
591  void TSparseHash<TKey, TDat, GroupSize>::Swap(TSparseHash& HT) {
592    ::Swap(ShrinkThresh, HT.ShrinkThresh);
593    ::Swap(ExpandThresh, HT.ExpandThresh);
594    Table.Swap(HT.Table);
595  }
596  template <class TKey, class TDat, uint16 GroupSize>
597  int TSparseHash<TKey, TDat, GroupSize>::AddKey(const TKey& Key) {
598    ResizeDelta(1);
599    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
600    if (Pos != -1) { return Pos; } 
601    else {
602      Table.Set(PosToIns, THashKeyDat(Key));
603      return PosToIns;
604    }
605  }
606  template <class TKey, class TDat, uint16 GroupSize>
607  TDat& TSparseHash<TKey, TDat, GroupSize>::AddDat(const TKey& Key) {
608    ResizeDelta(1);
609    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
610    if (PosToIns != -1) {
611      return Table.Set(PosToIns, THashKeyDat(Key)).Dat;
612    } else { return Table.Set(Pos).Dat; }
613  }
614  template <class TKey, class TDat, uint16 GroupSize>
615  TDat& TSparseHash<TKey, TDat, GroupSize>::AddDat(const TKey& Key, const TDat& Dat) {
616    ResizeDelta(1);
617    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
618    if (PosToIns != -1) {
619      return Table.Set(PosToIns, THashKeyDat(Key, Dat)).Dat;
620    } else { return Table.Set(Pos).Dat = Dat; }
621  }
622  template <class TKey, class TDat, uint16 GroupSize>
623  const TDat& TSparseHash<TKey, TDat, GroupSize>::GetDat(const TKey& Key) const {
624    int Pos, PosToIns;
625    FindPos(Key, Pos, PosToIns);
626    Assert(Pos != -1);
627    return Table.Get(Pos).Dat;
628  }
629  template <class TKey, class TDat, uint16 GroupSize>
630  TDat& TSparseHash<TKey, TDat, GroupSize>::GetDat(const TKey& Key) {
631    int Pos, PosToIns;
632    FindPos(Key, Pos, PosToIns);
633    Assert(Pos != -1);
634    return Table.Set(Pos).Dat;
635  }
636  template <class TKey, class TDat, uint16 GroupSize>
637  void TSparseHash<TKey, TDat, GroupSize>::GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
638    Assert(IsKey(KeyId));
639    const THashKeyDat& KeyDat = Table.Get(KeyId);
640    Key = KeyDat.Key;
641    Dat = KeyDat.Dat;
642  }
643  template <class TKey, class TDat, uint16 GroupSize>
644  bool TSparseHash<TKey, TDat, GroupSize>::IsKeyGetDat(const TKey& Key, TDat& Dat) const {
645    int KeyId;
646    if (IsKey(Key, KeyId)) {
647      Dat=Table.Get(KeyId).Dat;
648      return true;
649    } else { return false; }
650  }
651  template <class TKey, class TDat, uint16 GroupSize>
652  void TSparseHash<TKey, TDat, GroupSize>::GetKeyV(TVec<TKey>& KeyV) const {
653    KeyV.Gen(Len(), 0);
654    for (TIter i = BegI(); i < EndI(); i++) {
655      KeyV.Add(i->Key);
656    }
657  }
658  template <class TKey, class TDat, uint16 GroupSize>
659  void TSparseHash<TKey, TDat, GroupSize>::GetDatV(TVec<TDat>& DatV) const {
660    DatV.Gen(Len(), 0);
661    for (TIter i = BegI(); i < EndI(); i++) {
662      DatV.Add(i->Dat);
663    }
664  }
665  template <class TKey, class TDat, uint16 GroupSize>
666  void TSparseHash<TKey, TDat, GroupSize>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
667    KeyDatPrV.Gen(Len(), 0);
668    for (TIter i = BegI(); i < EndI(); i++) {
669      KeyDatPrV.Add(TPair<TKey, TDat>(i->Key, i->Dat));
670    }
671  }
672  template <class TKey, class TDat, uint16 GroupSize>
673  void TSparseHash<TKey, TDat, GroupSize>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
674    DatKeyPrV.Gen(Len(), 0);
675    for (TIter i = BegI(); i < EndI(); i++) {
676      DatKeyPrV.Add(TPair<TDat, TKey>(i->Dat, i->Key));
677    }
678  }
679  template <class TKey, uint16 GroupSize=48> 
680  class TSparseSet {
681  public:
682    typedef typename TSparseTable<TKey, GroupSize>::TIter TIter;
683    typedef typename TSparseTable<TKey, GroupSize>::TSGroup TSGroup;
684  public:
685    static const float MxOccupancy; 
686    static const float MnOccupancy; 
687    static const int MinBuckets;    
688  private:
689    void ResetThresh();
690    int GetMinSize(const int& CurVals, const int& WantedVals) const;
691    void CopyFrom(const TSparseSet& SSet, const int& MnWanted);
692    void MoveFrom(TSparseSet& SSet, const int& MnWanted);
693    void ResizeDelta(const int& ValsToAdd, const int& MnWanted = 0);
694    void FindPos(const TKey& Key, int& Pos, int& PosToIns) const;
695  private:
696    TInt ShrinkThresh, ExpandThresh;
697    TSparseTable<TKey, GroupSize> Table;
698  public:
699    TSparseSet(const int& WantedVals = 0) : Table(GetMinSize(0, WantedVals)) { ResetThresh(); }
700    TSparseSet(TSIn& SIn) : ShrinkThresh(SIn), ExpandThresh(SIn), Table(SIn) { }
701    void Load(TSIn& SIn) { ShrinkThresh.Load(SIn);  ExpandThresh.Load(SIn);  Table.Load(SIn); }
702    void Save(TSOut& SOut) const { ShrinkThresh.Save(SOut); ExpandThresh.Save(SOut); Table.Save(SOut); }
703    TSparseSet& operator = (const TSparseSet& SSet);
704    bool operator == (const TSparseSet& SSet) const;
705    bool operator < (const TSparseSet& SSet) const;
706    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Table.GetMemUsed(); }
707    TIter BegI() const { return Table.BegI(); }
708    TIter EndI() const { return Table.EndI(); }
709    TIter GetI(const int& KeyId) const { Assert(IsKeyId(KeyId));  return Table.GetI(KeyId); }
710    bool Empty() const { return Len() == 0; }
711    int Len() const { return Table.Len(); }
712    int Reserved() const  { return Table.Reserved(); }
713    uint GetDiskSz() const { return 2*sizeof(TInt) + Table.GetDiskSz(); }
714    void Reserve(const int& MxVals) { if (MxVals > Len()) ResizeDelta(MxVals - Len(), 0); }
715    void Clr(const bool& DoDel = true) { Table.Clr(DoDel);  ResetThresh(); }
716    void Swap(TSparseSet& SSet);
717    int AddKey(const TKey& Key);
718    const TKey& GetKey(const int& KeyId) const { return Table.Get(KeyId); }
719    int GetKeyId(const TKey& Key) const { int Pos, PosToIns;
720      FindPos(Key, Pos, PosToIns);  return Pos; }
721    bool IsKey(const TKey& Key) const { return GetKeyId(Key) != -1; }
722    bool IsKey(const TKey& Key, int& KeyId) const {
723      KeyId = GetKeyId(Key);  return KeyId != -1; }
724    bool IsKeyId(const int& KeyId) const { return ! Table.IsEmpty(KeyId); }
725    int GetRndKeyId(TRnd& Rnd = TInt::Rnd) const { Assert(Len()>0);
726      int KeyId = Rnd.GetUniDevInt(Reserved());
727      while (! IsKeyId(KeyId)) { KeyId = Rnd.GetUniDevInt(Reserved()); } return KeyId; }
728    void GetKeyV(TVec<TKey>& KeyV) const;
729  };
730  template <class TKey, uint16 GroupSize>
731  const float TSparseSet<TKey, GroupSize>::MxOccupancy = 0.8f;
732  template <class TKey, uint16 GroupSize>
733  const float TSparseSet<TKey, GroupSize>::MnOccupancy = 0.4f * 0.8f;
734  template <class TKey, uint16 GroupSize>
735  const int TSparseSet<TKey, GroupSize>::MinBuckets = 32;
736  template <class TKey, uint16 GroupSize>
737  void TSparseSet<TKey, GroupSize>::ResetThresh() {
738    ExpandThresh = int(Table.Reserved() * MxOccupancy);
739    ShrinkThresh = int(Table.Reserved() * MnOccupancy);
740  }
741  template <class TKey, uint16 GroupSize>
742  int TSparseSet<TKey, GroupSize>::GetMinSize(const int& CurVals, const int& WantedVals) const {
743    int Size = MinBuckets;
744    while (Size*MxOccupancy <= WantedVals || CurVals > Size * MxOccupancy) Size *= 2;
745    return Size;
746  }
747  template <class TKey, uint16 GroupSize>
748  void TSparseSet<TKey, GroupSize>::CopyFrom(const TSparseSet& SSet, const int& MnWanted) {
749    Clr(false);
750    const int NewSize = GetMinSize(SSet.Reserved(), MnWanted);
751    if (NewSize > Reserved()) {
752      Table.Resize(NewSize);
753      ResetThresh();
754    }
755    const uint BuckM1 = Reserved() - 1;
756    for (int g = 0; g < SSet.Table.Groups(); g++) {
757      const TSGroup& Group = SSet.Table.GetGroup(g);
758      for (int b = 0; b < Group.Len(); b++) {
759        int Tries = 0; uint BuckNum;
760        for (BuckNum = Group.Offset(b).GetPrimHashCd() & BuckM1;
761         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
762          Tries++;
763          Assert(Tries < Reserved());
764        }
765        Table.Set(BuckNum, Group.Offset(b));
766      }
767    }
768  }
769  template <class TKey, uint16 GroupSize>
770  void TSparseSet<TKey, GroupSize>::MoveFrom(TSparseSet& SSet, const int& MnWanted) {
771    Clr(false);
772    int NewSize;
773    if (MnWanted == 0) NewSize = SSet.Reserved();
774    else NewSize = GetMinSize(SSet.Reserved(), MnWanted);
775    if (NewSize > Reserved()) {
776      Table.Resize(NewSize);
777      ResetThresh();
778    }
779    const uint BuckM1 = Reserved() - 1;
780    for (int g = 0; g < SSet.Table.Groups(); g++) {
781      TSGroup& Group = SSet.Table.GetGroup(g);
782      for (int b = 0; b < Group.Len(); b++) {
783        int Tries = 0; uint BuckNum;
784        for (BuckNum = Group.Offset(b).GetPrimHashCd() & BuckM1;
785         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
786          Tries++;
787          Assert(Tries < Reserved());
788        }
789        Assert(Table.IsEmpty(BuckNum));
790        Table.Set(BuckNum, Group.Offset(b));
791      }
792      Group.Clr(true); 
793    }
794  }
795  template <class TKey, uint16 GroupSize>
796  void TSparseSet<TKey, GroupSize>::ResizeDelta(const int& ValsToAdd, const int& MnWanted) {
797    if (Reserved() > MnWanted && Len()+ValsToAdd < ExpandThresh) { return; }
798    const int NewSize = GetMinSize(Table.Len()+ValsToAdd, MnWanted);
799    if (NewSize > Reserved()) {
800      printf("***Resize SparseSet: %d->%d\n", Reserved(), NewSize);
801      TSparseSet TmpSSet(Len()+ValsToAdd);
802      TmpSSet.ResetThresh();
803      TmpSSet.MoveFrom(*this, Len());
804      Swap(TmpSSet);
805    }
806  }
807  template <class TKey, uint16 GroupSize>
808  void TSparseSet<TKey, GroupSize>::FindPos(const TKey& Key, int& Pos, int& PosToIns) const {
809    const uint BuckM1 = Reserved() - 1;
810    uint BuckNum = Key.GetPrimHashCd() & BuckM1;
811    int Tries = 0;
812    while (true) {
813      if (Table.IsEmpty(BuckNum)) {
814        Pos = -1;  PosToIns = BuckNum;  return;
815      }
816      else if (Key == Table.Get(BuckNum)) {
817        Pos = BuckNum;  PosToIns = -1;  return;
818      }
819      Tries++;
820      BuckNum = (BuckNum + Tries) & BuckM1;
821      Assert(Tries < Reserved());
822    }
823  }
824  template <class TKey, uint16 GroupSize>
825  TSparseSet<TKey, GroupSize>& TSparseSet<TKey, GroupSize>::operator = (const TSparseSet& SSet) {
826    if (this != &SSet) {
827      ShrinkThresh = SSet.ShrinkThresh;
828      ExpandThresh = SSet.ExpandThresh;
829      Table = SSet.Table;
830    }
831    return *this;
832  }
833  template <class TKey, uint16 GroupSize>
834  bool TSparseSet<TKey, GroupSize>::operator == (const TSparseSet& SSet) const {
835    return Table == SSet.Table;
836  }
837  template <class TKey, uint16 GroupSize>
838  bool TSparseSet<TKey, GroupSize>::operator < (const TSparseSet& SSet) const {
839    return Table < SSet.Table;
840  }
841  template <class TKey, uint16 GroupSize>
842  void TSparseSet<TKey, GroupSize>::Swap(TSparseSet& SSet) {
843    ::Swap(ShrinkThresh, SSet.ShrinkThresh);
844    ::Swap(ExpandThresh, SSet.ExpandThresh);
845    Table.Swap(SSet.Table);
846  }
847  template <class TKey, uint16 GroupSize>
848  int TSparseSet<TKey, GroupSize>::AddKey(const TKey& Key) {
849    ResizeDelta(1);
850    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
851    if (Pos != -1) { return Pos; } 
852    else {
853      Table.Set(PosToIns, Key);
854      return PosToIns;
855    }
856  }
857  template <class TKey, uint16 GroupSize>
858  void TSparseSet<TKey, GroupSize>::GetKeyV(TVec<TKey>& KeyV) const {
859    KeyV.Gen(Len(), 0);
860    for (TIter I = BegI(); I < EndI(); I++) {
861      KeyV.Add(I()); }
862  }
863  #pragma pack(push, 1) 
864  template <class TKey>
865  class THashSetKey{
866  public:
867    TInt Next;
868    TInt HashCd;
869    TKey Key;
870  public:
871    THashSetKey():
872      Next(-1), HashCd(-1), Key() {}
873    THashSetKey(const int& _Next, const int& _HashCd, const TKey& _Key):
874      Next(_Next), HashCd(_HashCd), Key(_Key) {}
875    explicit THashSetKey(TSIn& SIn):
876      Next(SIn), HashCd(SIn), Key(SIn) {}
877    void Save(TSOut& SOut) const {
878      Next.Save(SOut); HashCd.Save(SOut); Key.Save(SOut); }
879    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="") {
880      XLoadHd(Nm); XLoad(Key); }
881    void SaveXml(TSOut& SOut, const TStr& Nm) const {
882      XSaveHd(Nm); XSave(Key); }
883    THashSetKey& operator=(const THashSetKey& SetKey) {
884      if (this!=&SetKey) { Next=SetKey.Next; HashCd=SetKey.HashCd; Key=SetKey.Key; }
885      return *this; }
886  };
887  #pragma pack(pop)
888  template <class TKey>
889  class THashSetKeyI{
890  public:
891    typedef THashSetKey<TKey> TSetKey;
892  private:
893    TSetKey* KeyI;
894    TSetKey* EndI;
895  public:
896    THashSetKeyI(): KeyI(NULL), EndI(NULL) { }
897    THashSetKeyI(const THashSetKeyI& _SetKeyI):
898      KeyI(_SetKeyI.KeyI), EndI(_SetKeyI.EndI) { }
899    THashSetKeyI(const TSetKey* _KeyI, const TSetKey* _EndI):
900      KeyI((TSetKey*)_KeyI), EndI((TSetKey*)_EndI) { }
901    THashSetKeyI& operator=(const THashSetKeyI& SetKeyI) {
902      KeyI=SetKeyI.KeyI; EndI=SetKeyI.EndI; return *this; }
903    bool operator==(const THashSetKeyI& SetKeyI) const {
904      return KeyI==SetKeyI.KeyI; }
905    bool operator<(const THashSetKeyI& SetKeyI) const {
906      return KeyI<SetKeyI.KeyI; }
907    THashSetKeyI& operator++(int) { KeyI++; while (KeyI < EndI && KeyI->HashCd==-1) { KeyI++; } return *this; }
908    THashSetKeyI& operator--(int) { do { KeyI--; } while (KeyI->HashCd==-1); return *this; }
909    const TKey& operator*() const { return KeyI->Key; }
910    const TKey& operator()() const { return KeyI->Key; }
911    const TKey* operator->() const { return &KeyI->Key; }
912    THashSetKeyI& Next() { operator++(1); return *this; }
913    bool IsEmpty() const { return KeyI == NULL; }
914    bool IsEnd() const { return EndI == KeyI; }
915    const TKey& GetKey() const {Assert((KeyI!=NULL)&&(KeyI->HashCd!=-1)); return KeyI->Key; }
916  };
917  template <class TKey, class THashFunc = TDefaultHashFunc<TKey> >
918  class THashSet{
919  public:
920    typedef THashSetKeyI<TKey> TIter;
921  private:
922    typedef THashSetKey<TKey> TSetKey;
923    TIntV PortV;
924    TVec<TSetKey> KeyV;
925    TBool AutoSizeP;
926    TInt FFreeKeyId, FreeKeys;
927  private:
928    TSetKey& GetSetKey(const int& KeyId) {
929      TSetKey& SetKey=KeyV[KeyId];
930      Assert(SetKey.HashCd!=-1); return SetKey; }
931    const TSetKey& GetSetKey(const int& KeyId) const {
932      const TSetKey& SetKey=KeyV[KeyId];
933      Assert(SetKey.HashCd!=-1); return SetKey; }
934    uint GetNextPrime(const uint& Val) const;
935    void Resize();
936  public:
937    THashSet():
938      PortV(), KeyV(),
939      AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0) { }
940    THashSet(const THashSet& Set):
941      PortV(Set.PortV), KeyV(Set.KeyV), AutoSizeP(Set.AutoSizeP),
942      FFreeKeyId(Set.FFreeKeyId), FreeKeys(Set.FreeKeys) { }
943    THashSet(const int& ExpectVals, const bool& _AutoSizeP=false);
944    explicit THashSet(const TVec<TKey>& KeyV);
945    explicit THashSet(TSIn& SIn):
946      PortV(SIn), KeyV(SIn),
947      AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn) {
948      SIn.LoadCs(); }
949    void Load(TSIn& SIn) {
950      PortV.Load(SIn); KeyV.Load(SIn);
951      AutoSizeP=TBool(SIn); FFreeKeyId=TInt(SIn); FreeKeys=TInt(SIn);
952      SIn.LoadCs(); }
953    void Save(TSOut& SOut) const {
954      PortV.Save(SOut); KeyV.Save(SOut);
955      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut);
956      SOut.SaveCs(); }
957    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="") {
958      XLoadHd(Nm); TVec<TSetKey> KeyV; XLoad(KeyV); XLoad(AutoSizeP);
959      for (int KeyN=0; KeyN<KeyV.Len(); KeyN++) {
960        AddKey(KeyV[KeyN].Key); }}
961    void SaveXml(TSOut& SOut, const TStr& Nm) {
962      Defrag(); XSaveHd(Nm); XSave(KeyV); XSave(AutoSizeP); }
963    THashSet& operator=(const THashSet& Set) {
964      if (this!=&Set) {
965        PortV=Set.PortV; KeyV=Set.KeyV; AutoSizeP=Set.AutoSizeP;
966        FFreeKeyId=Set.FFreeKeyId; FreeKeys=Set.FreeKeys; }
967      return *this; }
968    bool operator==(const THashSet& Set) const;
969    const TKey& operator[](const int& KeyId) const {return GetSetKey(KeyId).Key; }
970    TKey& operator[](const int& KeyId) {return GetSetKey(KeyId).Key; }
971    ::TSize GetMemUsed() const {
972      return PortV.GetMemUsed() + KeyV.GetMemUsed() + sizeof(bool) + 2*sizeof(int); }
973    TIter BegI() const {
974      if (Len()>0) {
975        if (IsKeyIdEqKeyN()) { return TIter(KeyV.BegI(), KeyV.EndI()); }
976        int FKeyId=-1;  FNextKeyId(FKeyId);
977        return TIter(KeyV.BegI()+FKeyId, KeyV.EndI()); }
978      return TIter(KeyV.EndI(), KeyV.EndI());
979    }
980    TIter EndI() const {return TIter(KeyV.EndI(), KeyV.EndI()); }
981    TIter GetI(const TKey& Key) const {return TIter(&KeyV[GetKeyId(Key)], KeyV.EndI()); }
982    void Gen(const int& ExpectVals) {
983      PortV.Gen(GetNextPrime(ExpectVals/2)); KeyV.Gen(ExpectVals, 0);
984      FFreeKeyId=-1; FreeKeys=0; PortV.PutAll(TInt(-1)); }
985    void Clr(const bool& DoDel=true, const int& NoDelLim=-1);
986    bool Empty() const {return Len()==0; }
987    int Len() const {return KeyV.Len()-FreeKeys; }
988    int GetPorts() const {return PortV.Len(); }
989    bool IsAutoSize() const {return AutoSizeP; }
990    int GetMxKeyIds() const {return KeyV.Len(); }
991    int GetReservedKeyIds() const { return KeyV.Reserved(); }
992    bool IsKeyIdEqKeyN() const {return FreeKeys==0; }
993    int AddKey(const TKey& Key);
994    void AddKeyV(const TVec<TKey>& KeyV);
995    void DelKey(const TKey& Key);
996    bool DelIfKey(const TKey& Key) {
997      int KeyId; if (IsKey(Key, KeyId)) {DelKeyId(KeyId); return true;} return false;}
998    void DelKeyId(const int& KeyId) {DelKey(GetKey(KeyId)); }
999    void DelKeyIdV(const TIntV& KeyIdV) {
1000      for (int KeyIdN=0; KeyIdN<KeyIdV.Len(); KeyIdN++) {DelKeyId(KeyIdV[KeyIdN]); }}
1001    void MarkDelKey(const TKey& Key);
1002    void MarkDelKeyId(const int& KeyId) {MarkDelKey(GetKey(KeyId)); }
1003    const TKey& GetKey(const int& KeyId) const {
1004      return GetSetKey(KeyId).Key; }
1005    int GetKeyId(const TKey& Key) const;
1006    int GetRndKeyId(TRnd& Rnd) const {
1007      IAssert(IsKeyIdEqKeyN());
1008      IAssert(Len()>0);
1009      return Rnd.GetUniDevInt(Len()); }
1010    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1; }
1011    bool IsKey(const TKey& Key, int& KeyId) const {
1012      KeyId=GetKeyId(Key); return KeyId!=-1; }
1013    bool IsKeyId(const int& KeyId) const {
1014      return (0<=KeyId)&&(KeyId<KeyV.Len())&&(KeyV[KeyId].HashCd!=-1); }
1015    int FFirstKeyId() const {return 0-1; }
1016    bool FNextKeyId(int& KeyId) const;
1017    void GetKeyV(TVec<TKey>& KeyV) const;
1018    void Swap(THashSet& Set);
1019    void Defrag();
1020    void Pack() {KeyV.Pack(); }
1021    static THashSet<TKey> GetSet(const TKey& Key1){
1022  	THashSet<TKey> Set(1); Set.AddKey(Key1); return Set;}
1023    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2){
1024      THashSet<TKey> Set(2); Set.AddKey(Key1); Set.AddKey(Key2); return Set;}
1025    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3){
1026      THashSet<TKey> Set(3); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); return Set;}
1027    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4){
1028      THashSet<TKey> Set(4); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); return Set;}
1029    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5){
1030      THashSet<TKey> Set(5); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); return Set;}
1031    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6){
1032      THashSet<TKey> Set(6); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); return Set;}
1033    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7){
1034      THashSet<TKey> Set(7); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); return Set;}
1035    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7, const TKey& Key8){
1036      THashSet<TKey> Set(8); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); Set.AddKey(Key8); return Set;}
1037    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7, const TKey& Key8, const TKey& Key9){
1038      THashSet<TKey> Set(9); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); Set.AddKey(Key8); Set.AddKey(Key9); return Set;}
1039  };
1040  template <class TKey, class THashFunc>
1041  uint THashSet<TKey, THashFunc>::GetNextPrime(const uint& Val) const {
1042    uint* f=(uint*)TIntH::HashPrimeT, *m, *l=(uint*)TIntH::HashPrimeT + (int)TIntH::HashPrimes;
1043    int h, len = (int)TIntH::HashPrimes;
1044    while (len > 0) {
1045      h = len >> 1;  m = f + h;
1046      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
1047      else len = h;
1048    }
1049    return f == l ? *(l - 1) : *f;
1050  }
1051  template <class TKey, class THashFunc>
1052  void THashSet<TKey, THashFunc>::Resize() {
1053    if (PortV.Len()==0) {PortV.Gen(17); }
1054    else if (AutoSizeP&&(KeyV.Len()>2*PortV.Len())) {
1055      PortV.Gen(GetNextPrime(PortV.Len()+1));
1056    } else {
1057      return;
1058    }
1059    PortV.PutAll(TInt(-1));
1060    for (int KeyId=0; KeyId<KeyV.Len(); KeyId++) {
1061      TSetKey& SetKey=KeyV[KeyId];
1062      if (SetKey.HashCd!=-1) {
1063        int PortN=abs(THashFunc::GetPrimHashCd(SetKey.Key)%PortV.Len());
1064        SetKey.Next=PortV[PortN];
1065        PortV[PortN]=KeyId;
1066      }
1067    }
1068  }
1069  template <class TKey, class THashFunc>
1070  THashSet<TKey, THashFunc>::THashSet(const int& ExpectVals, const bool& _AutoSizeP):
1071    PortV(GetNextPrime(ExpectVals/2+1)), KeyV(ExpectVals, 0),
1072    AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0) {
1073    PortV.PutAll(TInt(-1));
1074  }
1075  template <class TKey, class THashFunc>
1076  THashSet<TKey, THashFunc>::THashSet(const TVec<TKey>& _KeyV) :
1077   PortV(GetNextPrime(_KeyV.Len()/2+1)), KeyV(_KeyV.Len(), 0),
1078   AutoSizeP(false), FFreeKeyId(-1), FreeKeys(0) {
1079    PortV.PutAll(TInt(-1));
1080    for (int i = 0; i < _KeyV.Len(); i++) {
1081      AddKey(_KeyV[i]);
1082    }
1083  }
1084  template <class TKey, class THashFunc>
1085  bool THashSet<TKey, THashFunc>::operator==(const THashSet& Set) const {
1086    if (Len() != Set.Len()) { return false; }
1087    for (int k = FFirstKeyId(); FNextKeyId(k); k++) {
1088      if (! Set.IsKey(GetKey(k))) { return false; }
1089    }
1090    return true;
1091  }
1092  template <class TKey, class THashFunc>
1093  void THashSet<TKey, THashFunc>::Clr(const bool& DoDel, const int& NoDelLim) {
1094    if (DoDel) {
1095      PortV.Clr(); KeyV.Clr();
1096    } else {
1097      PortV.PutAll(TInt(-1));
1098      KeyV.Clr(DoDel, NoDelLim);
1099    }
1100    FFreeKeyId=TInt(-1); FreeKeys=TInt(0);
1101  }
1102  template <class TKey, class THashFunc>
1103  int THashSet<TKey, THashFunc>::AddKey(const TKey& Key) {
1104    if ((KeyV.Len()>2*PortV.Len())||PortV.Empty()) {Resize(); }
1105    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1106    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1107    int PrevKeyId=-1;
1108    int KeyId=PortV[PortN];
1109    while ((KeyId!=-1) &&
1110     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1111      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1112    if (KeyId==-1) {
1113      if (FFreeKeyId==-1) {
1114        KeyId=KeyV.Add(TSetKey(-1, HashCd, Key));
1115      } else {
1116        KeyId=FFreeKeyId; FFreeKeyId=KeyV[FFreeKeyId].Next; FreeKeys--;
1117        KeyV[KeyId].Next = -1;
1118        KeyV[KeyId].HashCd = HashCd;
1119        KeyV[KeyId].Key = Key;
1120      }
1121      if (PrevKeyId==-1) {
1122        PortV[PortN]=KeyId;
1123      } else {
1124        KeyV[PrevKeyId].Next=KeyId;
1125      }
1126    }
1127    return KeyId;
1128  }
1129  template <class TKey, class THashFunc>
1130  void THashSet<TKey, THashFunc>::AddKeyV(const TVec<TKey>& KeyV) {
1131    for (int i = 0; i < KeyV.Len(); i++) { AddKey(KeyV[i]); }
1132  }
1133  template <class TKey, class THashFunc>
1134  void THashSet<TKey, THashFunc>::DelKey(const TKey& Key) {
1135    IAssert(!PortV.Empty());
1136    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1137    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1138    int PrevKeyId=-1;
1139    int KeyId=PortV[PortN];
1140    while ((KeyId!=-1) &&
1141     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1142      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1143    IAssertR(KeyId!=-1, Key.GetStr());
1144    if (PrevKeyId==-1) {PortV[PortN]=KeyV[KeyId].Next; }
1145    else {KeyV[PrevKeyId].Next=KeyV[KeyId].Next; }
1146    KeyV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
1147    KeyV[KeyId].HashCd=TInt(-1);
1148    KeyV[KeyId].Key=TKey();
1149  }
1150  template <class TKey, class THashFunc>
1151  void THashSet<TKey, THashFunc>::MarkDelKey(const TKey& Key) {
1152    IAssert(!PortV.Empty());
1153    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1154    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1155    int PrevKeyId=-1;
1156    int KeyId=PortV[PortN];
1157    while ((KeyId!=-1) &&
1158     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1159      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1160    IAssertR(KeyId!=-1, Key.GetStr());
1161    if (PrevKeyId==-1) {PortV[PortN]=KeyV[KeyId].Next; }
1162    else {KeyV[PrevKeyId].Next=KeyV[KeyId].Next; }
1163    KeyV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
1164    KeyV[KeyId].HashCd=TInt(-1);
1165  }
1166  template <class TKey, class THashFunc>
1167  int THashSet<TKey, THashFunc>::GetKeyId(const TKey& Key) const {
1168    if (PortV.Empty()) {return -1; }
1169    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1170    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1171    int KeyId=PortV[PortN];
1172    while ((KeyId!=-1) &&
1173     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1174      KeyId=KeyV[KeyId].Next; }
1175    return KeyId;
1176  }
1177  template <class TKey, class THashFunc>
1178  bool THashSet<TKey, THashFunc>::FNextKeyId(int& KeyId) const {
1179    do {KeyId++; } while ((KeyId<KeyV.Len())&&(KeyV[KeyId].HashCd==-1));
1180    return KeyId<KeyV.Len();
1181  }
1182  template <class TKey, class THashFunc>
1183  void THashSet<TKey, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
1184    KeyV.Clr();
1185    int KeyId=FFirstKeyId();
1186    while (FNextKeyId(KeyId)) {
1187      KeyV.Add(GetKey(KeyId)); }
1188  }
1189  template <class TKey, class THashFunc>
1190  void THashSet<TKey, THashFunc>::Swap(THashSet& Set) {
1191    if (this!=&Set) {
1192      PortV.Swap(Set.PortV);
1193      KeyV.Swap(Set.KeyV);
1194      ::Swap(AutoSizeP, Set.AutoSizeP);
1195      ::Swap(FFreeKeyId, Set.FFreeKeyId);
1196      ::Swap(FreeKeys, Set.FreeKeys);
1197    }
1198  }
1199  template <class TKey, class THashFunc>
1200  void THashSet<TKey, THashFunc>::Defrag() {
1201    if (!IsKeyIdEqKeyN()) {
1202      THashSet<TKey> Set(PortV.Len());
1203      int KeyId=FFirstKeyId();
1204      while (FNextKeyId(KeyId)) {
1205        Set.AddKey(GetKey(KeyId));
1206      }
1207      Pack();
1208      operator=(Set);
1209      IAssert(IsKeyIdEqKeyN());
1210    }
1211  }
1212  typedef THashSet<TUCh> TUChSet;
1213  typedef THashSet<TInt> TIntSet;
1214  typedef THashSet<TUInt64> TUInt64Set;
1215  typedef THashSet<TFlt> TFltSet;
1216  typedef THashSet<TStr> TStrSet;
1217  typedef THashSet<TUChIntPr> TUChIntPrSet;
1218  typedef THashSet<TUChUInt64Pr> TUChUInt64PrSet;
1219  typedef THashSet<TIntPr> TIntPrSet;
1220  template<class TVal>
1221  class TPackVec {
1222  public:
1223    typedef TVal* TIter;
1224  private:
1225    int Vals;
1226    TVal* ValT;
1227    void ResizeDelta(const int& ValsToAdd=1);
1228  public:
1229    TPackVec() : Vals(0), ValT(NULL) { }
1230    TPackVec(const TPackVec& Vec) : Vals(0), ValT(NULL) {
1231      Gen(Vec.Len());
1232      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals);
1233    }
1234    explicit TPackVec(const int& _Vals) : Vals(_Vals) {
1235      if (Vals==0) { ValT=NULL; } else { ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals); } }
1236    ~TPackVec() { if (ValT != NULL) { free(ValT); } }
1237    explicit TPackVec(TSIn& SIn): Vals(0), ValT(NULL) { Load(SIn); }
1238    void Load(TSIn& SIn);
1239    void Save(TSOut& SOut) const;
1240    const TVal& operator [] (const int& ValN) const { return ValT[ValN]; }
1241    TVal& operator [] (const int& ValN) { return ValT[ValN]; }
1242    TPackVec<TVal>& operator = (const TPackVec<TVal>& Vec) { Gen(Vec.Len());
1243      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals); return *this; }
1244    TVec<TVal>& operator = (const TVec<TVal>& Vec) { Gen(Vec.Len());
1245      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals); return *this; }
1246    void Gen(const int& _Vals) {
1247      if (ValT != NULL) { free(ValT); } Vals = _Vals;
1248      if (Vals==0) { ValT=NULL; } else { ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals); } }
1249    void Clr() { if (ValT != NULL) { free(ValT); ValT=NULL; } Vals = 0; }
1250    bool Empty() const {return Vals==0; }
1251    int Len() const {return Vals; }
1252    const TVal& Last() const { return ValT[Len()-1]; }
1253    TVal& Last() { return ValT[Len()-1]; }
1254    TIter BegI() const {return ValT; }
1255    TIter EndI() const {return ValT+Vals; }
1256    TIter GetI(const int& ValN) const { return ValT+ValN; }
1257    void Add(const TVal& Val) { ResizeDelta(1); ValT[Vals-1]=Val; }
1258    void AddV(const TPackVec<TVal>& ValV) { ResizeDelta(ValV.Len());
1259      memcpy(ValT+Vals-ValV.Len(), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1260    void AddV(const TVec<TVal>& ValV) { ResizeDelta(ValV.Len());
1261      memcpy(ValT+Vals-ValV.Len(), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1262    void AddV(TSIn& FIn) { int NVals;  FIn.Load(NVals);
1263      ResizeDelta(NVals);  FIn.LoadBf(ValT+Vals-NVals, sizeof(TVal)*NVals); }
1264    void Sort(const bool& Asc=true) {
1265      if (Asc) { TVec<TVal>::QSortCmp(BegI(), EndI(), TLss<TVal>()); }
1266      else { TVec<TVal>::QSortCmp(BegI(), EndI(), TGtr<TVal>()); }
1267    }
1268  };
1269  template<class TVal>
1270  void TPackVec<TVal>::ResizeDelta(const int& ValsToAdd) {
1271    if (ValsToAdd == 0) return;
1272    Vals += ValsToAdd;
1273    ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals);
1274    EAssert(ValT != NULL);
1275  }
1276  template<class TVal>
1277  void TPackVec<TVal>::Load(TSIn& SIn) {
1278    SIn.Load(Vals);
1279    if (Vals==0) {
1280      if (ValT != NULL) { free(ValT); }
1281      ValT = NULL; }
1282    else {
1283      ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals);
1284    }
1285    SIn.LoadBf(ValT, sizeof(TVal)*Vals);
1286  }
1287  template<class TVal>
1288  void TPackVec<TVal>::Save(TSOut& SOut) const {
1289    SOut.Save(Vals);
1290    if (Vals != 0) {
1291      SOut.SaveBf(ValT, sizeof(TVal)*Vals); }
1292  }
1293  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssch.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-shash.h</div>
                <div class="column column_space"><pre><code>12    }
13    return ChA;
14  }
15  bool TSchTask::IsCons(const PSchTask& Task1, const PSchTask& Task2){
16    return
17     (Task1->GetEndTm()<=Task2->GetStartTm())||
18     (Task2->GetEndTm()<=Task1->GetStartTm());
19  }
20  PSchTask TSchTask::LoadTxt(TILx& Lx){
</pre></code></div>
                <div class="column column_space"><pre><code>13    bool Next() { if (FIn.Eof()) { return false; }
14      Key.Load(FIn);  Dat.Load(FIn); return true; }
15    const TKey& GetKey() const { return Key; }
16    TKey& GetKey() { return Key; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    