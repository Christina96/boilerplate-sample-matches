<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_socket.cpp &amp; test_proxy.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_socket.cpp &amp; test_proxy.cpp
      </h3>
<h1 align="center">
        6.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_socket.cpp (3.4300792%)<th>test_proxy.cpp (52.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(159-186)<td><a href="#" name="0">(31-53)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_socket.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;array&gt;
2 #include &lt;list&gt;
3 #include &lt;memory&gt;
4 #include &lt;string&gt;
5 #include &lt;boost/test/unit_test.hpp&gt;
6 #include "zmqpp/context.hpp"
7 #include "zmqpp/socket.hpp"
8 #include "zmqpp/message.hpp"
9 #include "zmqpp/signal.hpp"
10 BOOST_AUTO_TEST_SUITE( socket )
11 const int bubble_poll_timeout = 1;
12 const int max_poll_timeout = 100;
13 void bubble_subscriptions(zmqpp::socket&amp; socket)
14 {
15 	zmq_pollitem_t item = { socket, 0, ZMQ_POLLIN, 0 };
16 	int result = zmq_poll(&amp;item, 1, bubble_poll_timeout);
17 	BOOST_REQUIRE_MESSAGE(0 == result, "polling command failed to timeout during subscription bubble");
18 }
19 void wait_for_socket(zmqpp::socket&amp; socket)
20 {
21 	zmq_pollitem_t item = { socket, 0, ZMQ_POLLIN, 0 };
22 	int result = zmq_poll(&amp;item, 1, max_poll_timeout);
23 	BOOST_REQUIRE_MESSAGE(result &gt;= 0, "polling command returned without expected value: " &lt;&lt; zmq_strerror(zmq_errno()));
24 	BOOST_REQUIRE_MESSAGE(0 != result, "polling command returned with timeout after " &lt;&lt; max_poll_timeout &lt;&lt; " milliseconds");
25 	BOOST_REQUIRE_MESSAGE(1 == result, "polling command claims " &lt;&lt; result &lt;&lt; " sockets have events but we only gave it one");
26 	BOOST_REQUIRE_MESSAGE(item.revents &amp; ZMQ_POLLIN, "events do not match expected POLLIN event: " &lt;&lt; item.revents);
27 }
28 BOOST_AUTO_TEST_CASE( socket_creation )
29 {
30 	zmqpp::context context;
31 	zmqpp::socket socket(context, zmqpp::socket_type::pull);
32 }
33 BOOST_AUTO_TEST_CASE( socket_creation_bad_type )
34 {
35 	zmqpp::context context;
36 	BOOST_CHECK_THROW(zmqpp::socket socket(context, static_cast&lt;zmqpp::socket_type&gt;(-1)), zmqpp::zmq_internal_exception);
37 }
38 BOOST_AUTO_TEST_CASE( valid_socket )
39 {
40 	zmqpp::context context;
41 	zmqpp::socket socket(context, zmqpp::socket_type::pull);
42 	socket.bind("inproc://test");
43 	zmqpp::message message;
44 	BOOST_CHECK(!socket.receive(message, true));
45 }
46 BOOST_AUTO_TEST_CASE( valid_move_supporting )
47 {
48 	zmqpp::context context;
49 	std::unique_ptr&lt;zmqpp::socket&gt; original(new zmqpp::socket(context, zmqpp::socket_type::pull));
50 	original-&gt;bind("inproc://test");
51 	zmqpp::socket clone(std::move(*original));
52 	zmqpp::message message;
53 	BOOST_CHECK(!clone.receive(message, true));
54 }
55 BOOST_AUTO_TEST_CASE( simple_pull_push )
56 {
57 	zmqpp::context context;
58 	zmqpp::socket puller(context, zmqpp::socket_type::pull);
59 	puller.bind("inproc://test");
60 	zmqpp::socket pusher(context, zmqpp::socket_type::push);
61 	pusher.connect("inproc://test");
62 	BOOST_CHECK(pusher.send("hello world!"));
63 	wait_for_socket(puller);
64 	std::string message;
65 	BOOST_CHECK(puller.receive(message));
66 	BOOST_CHECK_EQUAL("hello world!", message);
67 	BOOST_CHECK(!puller.has_more_parts());
68 }
69 BOOST_AUTO_TEST_CASE( simple_receive_raw )
70 {
71 	zmqpp::context context;
72 	char buf[64];
73 	size_t len;
74 	zmqpp::socket puller(context, zmqpp::socket_type::pull);
75 	puller.bind("inproc://test");
76 	zmqpp::socket pusher(context, zmqpp::socket_type::push);
77 	pusher.connect("inproc://test");
78 	BOOST_CHECK(pusher.send("hello world!"));
79 	wait_for_socket(puller);
80 	len = sizeof(buf);
81 	BOOST_CHECK(puller.receive_raw(buf, len));
82 	std::string message(buf, len);
83 	BOOST_CHECK_EQUAL("hello world!", message);
84 	BOOST_CHECK(!puller.has_more_parts());
85 }
86 BOOST_AUTO_TEST_CASE( simple_receive_raw_short_buf )
87 {
88 	zmqpp::context context;
89 	char buf[64];
90 	size_t len;
91 	zmqpp::socket puller(context, zmqpp::socket_type::pull);
92 	puller.bind("inproc://test");
93 	zmqpp::socket pusher(context, zmqpp::socket_type::push);
94 	pusher.connect("inproc://test");
95 	BOOST_CHECK(pusher.send("hello world!"));
96 	wait_for_socket(puller);
97 	memset(buf, 0xee, sizeof(buf));
98 	len = 5;
99 	BOOST_CHECK(puller.receive_raw(buf, len));
100 	BOOST_CHECK_EQUAL(5, len);
101 	BOOST_CHECK_EQUAL(0xee, buf[5] &amp; 0xff);
102 	BOOST_CHECK_EQUAL(0xee, buf[6] &amp; 0xff);
103 	std::string message(buf, len);
104 	BOOST_CHECK_EQUAL("hello", message);
105 	BOOST_CHECK(!puller.has_more_parts());
106 }
107 <a name="0"></a>
108 BOOST_AUTO_TEST_CASE( multipart_pair )
109 {
110 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	zmqpp::context context;
111 	zmqpp::socket alpha(context, zmqpp::socket_type::pair);
112 	alpha.bind("inproc://test");
113 	zmqpp::socket omega(context, zmqpp::socket_type::pair);
114 	omega.connect("inproc://test");
115 	BOOST_CHECK(alpha.send("hello", zmqpp::socket::send_more));
116 	BOOST_CHECK(alpha.send("world", zmqpp::socket::send_more));
117 	BOOST_CHECK(alpha.send("!"));
118 	wait_for_socket(omega);
119 	std::string message;
120 	BOOST_CHECK(omega.receive(message));
121 	BOOST_CHECK_EQUAL("hello", message);
122 	BOOST_REQUIRE(omega.has_more_parts());
123 	BOOST_CHECK(omega.receive(message));
124 	BOOST_CHECK_EQUAL("world", message);
125 	BOOST_REQUIRE(omega.has_more_parts());
126 	BOOST_CHECK(omega.receive(message));
127 	BOOST_CHECK_EQUAL("!", message);
128 	BOOST_CHECK(!omega.has_more_parts());
129 }</b></font>
130 BOOST_AUTO_TEST_CASE( subscribe_via_option )
131 {
132 	zmqpp::context context;
133 	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
134 	publisher.bind("inproc://test");
135 	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
136 	subscriber.connect("inproc://test");
137 	subscriber.set(zmqpp::socket_option::subscribe, "watch1");
138 	BOOST_CHECK(publisher.send("watch0", zmqpp::socket::send_more));
139 	BOOST_CHECK(publisher.send("contents0"));
140 	BOOST_CHECK(publisher.send("watch1", zmqpp::socket::send_more));
141 	BOOST_CHECK(publisher.send("contents1"));
142 	wait_for_socket(subscriber);
143 	std::string message;
144 	BOOST_CHECK(subscriber.receive(message));
145 	BOOST_CHECK_EQUAL("watch1", message);
146 	BOOST_REQUIRE(subscriber.has_more_parts());
147 	BOOST_CHECK(subscriber.receive(message));
148 	BOOST_CHECK_EQUAL("contents1", message);
149 	BOOST_CHECK(!subscriber.has_more_parts());
150 }
151 BOOST_AUTO_TEST_CASE( subscribe_helpers )
152 {
153 	zmqpp::context context;
154 	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
155 	publisher.bind("inproc://test");
156 	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
157 	subscriber.connect("inproc://test");
158 	subscriber.subscribe("watch1");
159 	subscriber.subscribe("watch2");
160 	BOOST_CHECK(publisher.send("watch0", zmqpp::socket::send_more));
161 	BOOST_CHECK(publisher.send("contents0"));
162 	BOOST_CHECK(publisher.send("watch1", zmqpp::socket::send_more));
163 	BOOST_CHECK(publisher.send("contents1"));
164 	BOOST_CHECK(publisher.send("watch2", zmqpp::socket::send_more));
165 	BOOST_CHECK(publisher.send("contents2"));
166 	BOOST_CHECK(publisher.send("watch3", zmqpp::socket::send_more));
167 	BOOST_CHECK(publisher.send("contents3"));
168 	wait_for_socket(subscriber);
169 	std::string message;
170 	BOOST_CHECK(subscriber.receive(message));
171 	BOOST_CHECK_EQUAL("watch1", message);
172 	BOOST_REQUIRE(subscriber.has_more_parts());
173 	BOOST_CHECK(subscriber.receive(message));
174 	BOOST_CHECK_EQUAL("contents1", message);
175 	BOOST_CHECK(!subscriber.has_more_parts());
176 	wait_for_socket(subscriber);
177 	BOOST_CHECK(subscriber.receive(message));
178 	BOOST_CHECK_EQUAL("watch2", message);
179 	BOOST_REQUIRE(subscriber.has_more_parts());
180 	BOOST_CHECK(subscriber.receive(message));
181 	BOOST_CHECK_EQUAL("contents2", message);
182 	BOOST_CHECK(!subscriber.has_more_parts());
183 	subscriber.unsubscribe("watch1");
184 	bubble_subscriptions(subscriber);
185 	BOOST_CHECK(publisher.send("watch0", zmqpp::socket::send_more));
186 	BOOST_CHECK(publisher.send("contents0"));
187 	BOOST_CHECK(publisher.send("watch1", zmqpp::socket::send_more));
188 	BOOST_CHECK(publisher.send("contents1"));
189 	BOOST_CHECK(publisher.send("watch2", zmqpp::socket::send_more));
190 	BOOST_CHECK(publisher.send("contents2"));
191 	wait_for_socket(subscriber);
192 	BOOST_CHECK(subscriber.receive(message));
193 	BOOST_CHECK_EQUAL("watch2", message);
194 	BOOST_REQUIRE(subscriber.has_more_parts());
195 	BOOST_CHECK(subscriber.receive(message));
196 	BOOST_CHECK_EQUAL("contents2", message);
197 	BOOST_CHECK(!subscriber.has_more_parts());
198 }
199 BOOST_AUTO_TEST_CASE( subscribe_helpers_multitopic_method )
200 {
201 	std::list&lt;std::string&gt; topics = { "watch1", "watch2" };
202 	zmqpp::context context;
203 	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
204 	publisher.bind("inproc://test");
205 	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
206 	subscriber.connect("inproc://test");
207 	subscriber.subscribe(topics.begin(), topics.end());
208 	BOOST_CHECK(publisher.send("watch0", zmqpp::socket::send_more));
209 	BOOST_CHECK(publisher.send("contents0"));
210 	BOOST_CHECK(publisher.send("watch1", zmqpp::socket::send_more));
211 	BOOST_CHECK(publisher.send("contents1"));
212 	BOOST_CHECK(publisher.send("watch2", zmqpp::socket::send_more));
213 	BOOST_CHECK(publisher.send("contents2"));
214 	BOOST_CHECK(publisher.send("watch3", zmqpp::socket::send_more));
215 	BOOST_CHECK(publisher.send("contents3"));
216 	wait_for_socket(subscriber);
217 	std::string message;
218 	BOOST_CHECK(subscriber.receive(message));
219 	BOOST_CHECK_EQUAL("watch1", message);
220 	BOOST_REQUIRE(subscriber.has_more_parts());
221 	BOOST_CHECK(subscriber.receive(message));
222 	BOOST_CHECK_EQUAL("contents1", message);
223 	BOOST_CHECK(!subscriber.has_more_parts());
224 	wait_for_socket(subscriber);
225 	BOOST_CHECK(subscriber.receive(message));
226 	BOOST_CHECK_EQUAL("watch2", message);
227 	BOOST_REQUIRE(subscriber.has_more_parts());
228 	BOOST_CHECK(subscriber.receive(message));
229 	BOOST_CHECK_EQUAL("contents2", message);
230 	BOOST_CHECK(!subscriber.has_more_parts());
231 }
232 BOOST_AUTO_TEST_CASE( sending_messages )
233 {
234 	zmqpp::context context;
235 	zmqpp::socket pusher(context, zmqpp::socket_type::push);
236 	pusher.bind("inproc://test");
237 	zmqpp::socket puller(context, zmqpp::socket_type::pull);
238 	puller.connect("inproc://test");
239 	zmqpp::message message;
240 	std::string part("another world");
241 	message.add("hello world!");
242 	message.add(part);
243 	pusher.send(message);
244 	BOOST_CHECK_EQUAL(0, message.parts());
245 	wait_for_socket(puller);
246 	BOOST_CHECK(puller.receive(part));
247 	BOOST_CHECK_EQUAL("hello world!", part);
248 	BOOST_REQUIRE(puller.has_more_parts());
249 	BOOST_CHECK(puller.receive(part));
250 	BOOST_CHECK_EQUAL("another world", part);
251 	BOOST_CHECK(!puller.has_more_parts());
252 }
253 BOOST_AUTO_TEST_CASE( receiving_messages )
254 {
255 	zmqpp::context context;
256 	zmqpp::socket pusher(context, zmqpp::socket_type::push);
257 	pusher.bind("inproc://test");
258 	zmqpp::socket puller(context, zmqpp::socket_type::pull);
259 	puller.connect("inproc://test");
260 	zmqpp::message message;
261 	std::string part("another world");
262 	message.add("hello world!");
263 	message.add(part);
264 	pusher.send(message);
265 	BOOST_CHECK_EQUAL(0, message.parts());
266 	wait_for_socket(puller);
267 	BOOST_CHECK(puller.receive(message));
268 	BOOST_REQUIRE_EQUAL(2, message.parts());
269 	BOOST_CHECK_EQUAL("hello world!", message.get(0));
270 	BOOST_CHECK_EQUAL("another world", message.get(1));
271 	BOOST_CHECK(!puller.has_more_parts());
272 }
273 BOOST_AUTO_TEST_CASE( receive_over_old_messages )
274 {
275 	zmqpp::context context;
276 	zmqpp::socket pusher( context, zmqpp::socket_type::push );
277 	pusher.bind( "inproc://test" );
278 	zmqpp::socket puller( context, zmqpp::socket_type::pull );
279 	puller.connect( "inproc://test");
280 	pusher.send( "first message" );
281 	pusher.send( "second message" );
282 	wait_for_socket( puller );
283 	zmqpp::message message;
284 	BOOST_CHECK( puller.receive( message ) );
285 	BOOST_REQUIRE_EQUAL( 1, message.parts() );
286 	BOOST_CHECK_EQUAL( "first message", message.get(0) );
287 	BOOST_CHECK( puller.receive( message ) );
288 	BOOST_REQUIRE_EQUAL( 1, message.parts() );
289 	BOOST_CHECK_EQUAL( "second message", message.get(0) );
290 }
291 BOOST_AUTO_TEST_CASE( cleanup_safe_with_pending_data )
292 {
293 	zmqpp::context context;
294 	zmqpp::socket pusher(context, zmqpp::socket_type::push);
295 	pusher.bind("inproc://test");
296 	zmqpp::socket puller(context, zmqpp::socket_type::pull);
297 	puller.connect("inproc://test");
298 	zmqpp::message message;
299 	std::string part("another world");
300 	message.add("hello world!");
301 	message.add(part);
302 	pusher.send(message);
303 	BOOST_CHECK_EQUAL(0, message.parts());
304 }
305 BOOST_AUTO_TEST_CASE( multitarget_puller )
306 {
307 	std::vector&lt;std::string&gt; endpoints = { "inproc://test1", "inproc://test2" };
308 	zmqpp::context context;
309 	zmqpp::socket pusher1(context, zmqpp::socket_type::push);
310 	pusher1.bind(endpoints[0]);
311 	zmqpp::socket pusher2(context, zmqpp::socket_type::push);
312 	pusher2.bind(endpoints[1]);
313 	zmqpp::socket puller(context, zmqpp::socket_type::pull);
314 	puller.connect(endpoints.begin(), endpoints.end());
315 	BOOST_CHECK(pusher1.send("hello world!"));
316 	BOOST_CHECK(pusher2.send("a test message"));
317 	wait_for_socket(puller);
318 	std::string message;
319 	BOOST_CHECK(puller.receive(message));
320 	BOOST_CHECK_EQUAL("hello world!", message);
321 	BOOST_CHECK(puller.receive(message));
322 	BOOST_CHECK_EQUAL("a test message", message);
323 }
324 BOOST_AUTO_TEST_CASE( test_receive_send_signals )
325 {
326     zmqpp::context ctx;
327     zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
328     zmqpp::socket p2(ctx, zmqpp::socket_type::pair);
329     p1.bind("inproc://test");
330     p2.connect("inproc://test");
331     p1.send(zmqpp::signal::test);
332     p1.send("....");
333     p1.send(zmqpp::signal::stop);
334     zmqpp::signal s;
335     std::string str;
336     p2.receive(s);
337     BOOST_CHECK_EQUAL(zmqpp::signal::test, s);
338     p2.receive(str);
339     p2.send(zmqpp::signal::test);
340     p2.receive(s);
341     BOOST_CHECK_EQUAL(zmqpp::signal::stop, s);
342     p1.receive(s);
343     BOOST_CHECK_EQUAL(zmqpp::signal::test, s);
344 }
345 BOOST_AUTO_TEST_CASE( test_wait )
346 {
347     zmqpp::context ctx;
348     zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
349     zmqpp::socket p2(ctx, zmqpp::socket_type::pair);
350     p1.bind("inproc://test");
351     p2.connect("inproc://test");
352     p1.send(zmqpp::signal::test);
353     p1.send("....");
354     p1.send("___");
355     p1.send(zmqpp::signal::stop);
356     BOOST_CHECK_EQUAL(zmqpp::signal::test, p2.wait());
357     BOOST_CHECK_EQUAL(zmqpp::signal::stop, p2.wait());
358 }
359 BOOST_AUTO_TEST_CASE( test_signal_block_noblock )
360 {
361     zmqpp::context ctx;
362     zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
363     zmqpp::socket p2(ctx, zmqpp::socket_type::pair);
364     p1.bind("inproc://test");
365     BOOST_CHECK_EQUAL(false, p1.send(zmqpp::signal::test, true)); //noblock
366     //p1.send(zmqpp::signal::test);     p2.connect("inproc://test");
367     zmqpp::signal sig;
368     BOOST_CHECK_EQUAL(false, p1.receive(sig, true)); //noblock
369     p1.send(zmqpp::signal::test);
370     BOOST_CHECK_EQUAL(true, p2.receive(sig, true)); //noblock
371 }
372 #if (ZMQ_VERSION_MAJOR &gt;= 4)
373 BOOST_AUTO_TEST_CASE( simple_stream )
374 {
375 	zmqpp::context context;
376 	zmqpp::socket s1(context, zmqpp::socket_type::stream);
377 	zmqpp::socket s2(context, zmqpp::socket_type::stream);
378 	s1.bind("inproc://test");
379 	s2.connect("inproc://test");
380 	std::string identity;
381 	s2.get(zmqpp::socket_option::identity, identity);
382 	zmqpp::message request;
383 	request &lt;&lt; identity;
384 	request &lt;&lt; "Hello world!";
385 	BOOST_CHECK(s2.send(request));
386 	zmqpp::message response;
387 	BOOST_CHECK(s1.receive(response));
388 	BOOST_CHECK(response.parts() == 2);
389 	BOOST_CHECK(response.get(1) == "Hello world!");
390 }
391 #endif
392 #ifndef TRAVIS_CI_BUILD //do not run when building on travis-ci (this cause oom error and kill the test process)
393 BOOST_AUTO_TEST_CASE( sending_large_messages_string )
394 {
395 	zmqpp::context context;
396 	zmqpp::socket pusher(context, zmqpp::socket_type::push);
397 	pusher.bind("inproc://test");
398 	zmqpp::socket puller(context, zmqpp::socket_type::pull);
399 	puller.connect("inproc://test");
400 	std::string message;
401     const size_t bytes_to_send = static_cast&lt;size_t&gt;(1024 * 1024 * 1024);
402     message.reserve(bytes_to_send);
403     for (size_t i = 0; i &lt; bytes_to_send; i++)
404     {
405         message.push_back('A' + (i % 26));
406     }
407 	BOOST_CHECK(pusher.send(message));
408 	zmq_pollitem_t item = { puller, 0, ZMQ_POLLIN, 0 };
409     const int poll_timeout = 1000000;
410 	int result = zmq_poll(&amp;item, 1, poll_timeout);
411 	BOOST_REQUIRE_MESSAGE(result &gt;= 0, "polling command returned without expected value: " &lt;&lt; zmq_strerror(zmq_errno()));
412 	BOOST_REQUIRE_MESSAGE(0 != result, "polling command returned with timeout after " &lt;&lt; poll_timeout &lt;&lt; " milliseconds");
413 	BOOST_REQUIRE_MESSAGE(1 == result, "polling command claims " &lt;&lt; result &lt;&lt; " sockets have events but we only gave it one");
414 	BOOST_REQUIRE_MESSAGE(item.revents &amp; ZMQ_POLLIN, "events do not match expected POLLIN event: " &lt;&lt; item.revents);
415     std::string received_message;
416 	BOOST_CHECK(puller.receive(received_message));
417 	BOOST_CHECK_EQUAL(0, message.compare(received_message));
418 	BOOST_CHECK(!puller.has_more_parts());
419 }
420 #endif
421 #if (ZMQ_VERSION_MAJOR &gt;= 4)
422 BOOST_AUTO_TEST_CASE( test_simple_monitor )
423 {
424     zmqpp::context ctx;
425     zmqpp::socket server(ctx, zmqpp::socket_type::push);
426 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  std::this_thread::sleep_for(std::chrono::milliseconds(1000));
427   zmqpp::socket puller(ctx, zmqpp::socket_type::pull);
428   zmqpp::socket pusher(ctx, zmqpp::socket_type::push);
429   pusher.connect(
430       "inproc://frontend");   puller.connect("inproc://backend"); 
431   zmqpp::message msg;
432   msg &lt;&lt; "Hello";
433   pusher.send(msg);
434   std::string ret;
435   puller.receive(ret);
436   BOOST_CHECK_EQUAL("Hello", ret);
437   puller.close();
438   pusher.close();
439   ctx.terminate();
440   t1.join();
441 }</b></font>
442 BOOST_AUTO_TEST_SUITE_END()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
