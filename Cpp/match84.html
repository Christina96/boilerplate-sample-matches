<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_socket.cpp &amp; test_proxy.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_socket.cpp &amp; test_proxy.cpp
      </h3>
<h1 align="center">
        6.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_socket.cpp (3.4300792%)<th>test_proxy.cpp (52.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(159-186)<td><a href="#" name="0">(31-53)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_socket.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;array&gt;
#include &lt;list&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;boost/test/unit_test.hpp&gt;
#include "zmqpp/context.hpp"
#include "zmqpp/socket.hpp"
#include "zmqpp/message.hpp"
#include "zmqpp/signal.hpp"
BOOST_AUTO_TEST_SUITE( socket )
const int bubble_poll_timeout = 1;
const int max_poll_timeout = 100;
void bubble_subscriptions(zmqpp::socket&amp; socket)
{
	zmq_pollitem_t item = { socket, 0, ZMQ_POLLIN, 0 };
	int result = zmq_poll(&amp;item, 1, bubble_poll_timeout);
	BOOST_REQUIRE_MESSAGE(0 == result, "polling command failed to timeout during subscription bubble");
}
void wait_for_socket(zmqpp::socket&amp; socket)
{
	zmq_pollitem_t item = { socket, 0, ZMQ_POLLIN, 0 };
	int result = zmq_poll(&amp;item, 1, max_poll_timeout);
	BOOST_REQUIRE_MESSAGE(result &gt;= 0, "polling command returned without expected value: " &lt;&lt; zmq_strerror(zmq_errno()));
	BOOST_REQUIRE_MESSAGE(0 != result, "polling command returned with timeout after " &lt;&lt; max_poll_timeout &lt;&lt; " milliseconds");
	BOOST_REQUIRE_MESSAGE(1 == result, "polling command claims " &lt;&lt; result &lt;&lt; " sockets have events but we only gave it one");
	BOOST_REQUIRE_MESSAGE(item.revents &amp; ZMQ_POLLIN, "events do not match expected POLLIN event: " &lt;&lt; item.revents);
}
BOOST_AUTO_TEST_CASE( socket_creation )
{
	zmqpp::context context;
	zmqpp::socket socket(context, zmqpp::socket_type::pull);
}
BOOST_AUTO_TEST_CASE( socket_creation_bad_type )
{
	zmqpp::context context;
	BOOST_CHECK_THROW(zmqpp::socket socket(context, static_cast&lt;zmqpp::socket_type&gt;(-1)), zmqpp::zmq_internal_exception);
}
BOOST_AUTO_TEST_CASE( valid_socket )
{
	zmqpp::context context;
	zmqpp::socket socket(context, zmqpp::socket_type::pull);
	socket.bind("inproc://test");
	zmqpp::message message;
	BOOST_CHECK(!socket.receive(message, true));
}
BOOST_AUTO_TEST_CASE( valid_move_supporting )
{
	zmqpp::context context;
	std::unique_ptr&lt;zmqpp::socket&gt; original(new zmqpp::socket(context, zmqpp::socket_type::pull));
	original-&gt;bind("inproc://test");
	zmqpp::socket clone(std::move(*original));
	zmqpp::message message;
	BOOST_CHECK(!clone.receive(message, true));
}
BOOST_AUTO_TEST_CASE( simple_pull_push )
{
	zmqpp::context context;
	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.bind("inproc://test");
	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.connect("inproc://test");
	BOOST_CHECK(pusher.send("hello world!"));
	wait_for_socket(puller);
	std::string message;
	BOOST_CHECK(puller.receive(message));
	BOOST_CHECK_EQUAL("hello world!", message);
	BOOST_CHECK(!puller.has_more_parts());
}
BOOST_AUTO_TEST_CASE( simple_receive_raw )
{
	zmqpp::context context;
	char buf[64];
	size_t len;
	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.bind("inproc://test");
	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.connect("inproc://test");
	BOOST_CHECK(pusher.send("hello world!"));
	wait_for_socket(puller);
	len = sizeof(buf);
	BOOST_CHECK(puller.receive_raw(buf, len));
	std::string message(buf, len);
	BOOST_CHECK_EQUAL("hello world!", message);
	BOOST_CHECK(!puller.has_more_parts());
}
BOOST_AUTO_TEST_CASE( simple_receive_raw_short_buf )
{
	zmqpp::context context;
	char buf[64];
	size_t len;
	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.bind("inproc://test");
	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.connect("inproc://test");
	BOOST_CHECK(pusher.send("hello world!"));
	wait_for_socket(puller);
	memset(buf, 0xee, sizeof(buf));
	len = 5;
	BOOST_CHECK(puller.receive_raw(buf, len));
	BOOST_CHECK_EQUAL(5, len);
	BOOST_CHECK_EQUAL(0xee, buf[5] &amp; 0xff);
	BOOST_CHECK_EQUAL(0xee, buf[6] &amp; 0xff);
	std::string message(buf, len);
	BOOST_CHECK_EQUAL("hello", message);
	BOOST_CHECK(!puller.has_more_parts());
}
<a name="0"></a>
BOOST_AUTO_TEST_CASE( multipart_pair )
{
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	zmqpp::context context;
	zmqpp::socket alpha(context, zmqpp::socket_type::pair);
	alpha.bind("inproc://test");
	zmqpp::socket omega(context, zmqpp::socket_type::pair);
	omega.connect("inproc://test");
	BOOST_CHECK(alpha.send("hello", zmqpp::socket::send_more));
	BOOST_CHECK(alpha.send("world", zmqpp::socket::send_more));
	BOOST_CHECK(alpha.send("!"));
	wait_for_socket(omega);
	std::string message;
	BOOST_CHECK(omega.receive(message));
	BOOST_CHECK_EQUAL("hello", message);
	BOOST_REQUIRE(omega.has_more_parts());
	BOOST_CHECK(omega.receive(message));
	BOOST_CHECK_EQUAL("world", message);
	BOOST_REQUIRE(omega.has_more_parts());
	BOOST_CHECK(omega.receive(message));
	BOOST_CHECK_EQUAL("!", message);
	BOOST_CHECK(!omega.has_more_parts());
}</b></font>
BOOST_AUTO_TEST_CASE( subscribe_via_option )
{
	zmqpp::context context;
	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
	publisher.bind("inproc://test");
	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
	subscriber.connect("inproc://test");
	subscriber.set(zmqpp::socket_option::subscribe, "watch1");
	BOOST_CHECK(publisher.send("watch0", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents0"));
	BOOST_CHECK(publisher.send("watch1", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents1"));
	wait_for_socket(subscriber);
	std::string message;
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("watch1", message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("contents1", message);
	BOOST_CHECK(!subscriber.has_more_parts());
}
BOOST_AUTO_TEST_CASE( subscribe_helpers )
{
	zmqpp::context context;
	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
	publisher.bind("inproc://test");
	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
	subscriber.connect("inproc://test");
	subscriber.subscribe("watch1");
	subscriber.subscribe("watch2");
	BOOST_CHECK(publisher.send("watch0", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents0"));
	BOOST_CHECK(publisher.send("watch1", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents1"));
	BOOST_CHECK(publisher.send("watch2", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents2"));
	BOOST_CHECK(publisher.send("watch3", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents3"));
	wait_for_socket(subscriber);
	std::string message;
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("watch1", message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("contents1", message);
	BOOST_CHECK(!subscriber.has_more_parts());
	wait_for_socket(subscriber);
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("watch2", message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("contents2", message);
	BOOST_CHECK(!subscriber.has_more_parts());
	subscriber.unsubscribe("watch1");
	bubble_subscriptions(subscriber);
	BOOST_CHECK(publisher.send("watch0", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents0"));
	BOOST_CHECK(publisher.send("watch1", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents1"));
	BOOST_CHECK(publisher.send("watch2", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents2"));
	wait_for_socket(subscriber);
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("watch2", message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("contents2", message);
	BOOST_CHECK(!subscriber.has_more_parts());
}
BOOST_AUTO_TEST_CASE( subscribe_helpers_multitopic_method )
{
	std::list&lt;std::string&gt; topics = { "watch1", "watch2" };
	zmqpp::context context;
	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
	publisher.bind("inproc://test");
	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
	subscriber.connect("inproc://test");
	subscriber.subscribe(topics.begin(), topics.end());
	BOOST_CHECK(publisher.send("watch0", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents0"));
	BOOST_CHECK(publisher.send("watch1", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents1"));
	BOOST_CHECK(publisher.send("watch2", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents2"));
	BOOST_CHECK(publisher.send("watch3", zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send("contents3"));
	wait_for_socket(subscriber);
	std::string message;
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("watch1", message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("contents1", message);
	BOOST_CHECK(!subscriber.has_more_parts());
	wait_for_socket(subscriber);
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("watch2", message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL("contents2", message);
	BOOST_CHECK(!subscriber.has_more_parts());
}
BOOST_AUTO_TEST_CASE( sending_messages )
{
	zmqpp::context context;
	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.bind("inproc://test");
	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect("inproc://test");
	zmqpp::message message;
	std::string part("another world");
	message.add("hello world!");
	message.add(part);
	pusher.send(message);
	BOOST_CHECK_EQUAL(0, message.parts());
	wait_for_socket(puller);
	BOOST_CHECK(puller.receive(part));
	BOOST_CHECK_EQUAL("hello world!", part);
	BOOST_REQUIRE(puller.has_more_parts());
	BOOST_CHECK(puller.receive(part));
	BOOST_CHECK_EQUAL("another world", part);
	BOOST_CHECK(!puller.has_more_parts());
}
BOOST_AUTO_TEST_CASE( receiving_messages )
{
	zmqpp::context context;
	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.bind("inproc://test");
	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect("inproc://test");
	zmqpp::message message;
	std::string part("another world");
	message.add("hello world!");
	message.add(part);
	pusher.send(message);
	BOOST_CHECK_EQUAL(0, message.parts());
	wait_for_socket(puller);
	BOOST_CHECK(puller.receive(message));
	BOOST_REQUIRE_EQUAL(2, message.parts());
	BOOST_CHECK_EQUAL("hello world!", message.get(0));
	BOOST_CHECK_EQUAL("another world", message.get(1));
	BOOST_CHECK(!puller.has_more_parts());
}
BOOST_AUTO_TEST_CASE( receive_over_old_messages )
{
	zmqpp::context context;
	zmqpp::socket pusher( context, zmqpp::socket_type::push );
	pusher.bind( "inproc://test" );
	zmqpp::socket puller( context, zmqpp::socket_type::pull );
	puller.connect( "inproc://test");
	pusher.send( "first message" );
	pusher.send( "second message" );
	wait_for_socket( puller );
	zmqpp::message message;
	BOOST_CHECK( puller.receive( message ) );
	BOOST_REQUIRE_EQUAL( 1, message.parts() );
	BOOST_CHECK_EQUAL( "first message", message.get(0) );
	BOOST_CHECK( puller.receive( message ) );
	BOOST_REQUIRE_EQUAL( 1, message.parts() );
	BOOST_CHECK_EQUAL( "second message", message.get(0) );
}
BOOST_AUTO_TEST_CASE( cleanup_safe_with_pending_data )
{
	zmqpp::context context;
	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.bind("inproc://test");
	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect("inproc://test");
	zmqpp::message message;
	std::string part("another world");
	message.add("hello world!");
	message.add(part);
	pusher.send(message);
	BOOST_CHECK_EQUAL(0, message.parts());
}
BOOST_AUTO_TEST_CASE( multitarget_puller )
{
	std::vector&lt;std::string&gt; endpoints = { "inproc://test1", "inproc://test2" };
	zmqpp::context context;
	zmqpp::socket pusher1(context, zmqpp::socket_type::push);
	pusher1.bind(endpoints[0]);
	zmqpp::socket pusher2(context, zmqpp::socket_type::push);
	pusher2.bind(endpoints[1]);
	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect(endpoints.begin(), endpoints.end());
	BOOST_CHECK(pusher1.send("hello world!"));
	BOOST_CHECK(pusher2.send("a test message"));
	wait_for_socket(puller);
	std::string message;
	BOOST_CHECK(puller.receive(message));
	BOOST_CHECK_EQUAL("hello world!", message);
	BOOST_CHECK(puller.receive(message));
	BOOST_CHECK_EQUAL("a test message", message);
}
BOOST_AUTO_TEST_CASE( test_receive_send_signals )
{
    zmqpp::context ctx;
    zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
    zmqpp::socket p2(ctx, zmqpp::socket_type::pair);
    p1.bind("inproc://test");
    p2.connect("inproc://test");
    p1.send(zmqpp::signal::test);
    p1.send("....");
    p1.send(zmqpp::signal::stop);
    zmqpp::signal s;
    std::string str;
    p2.receive(s);
    BOOST_CHECK_EQUAL(zmqpp::signal::test, s);
    p2.receive(str);
    p2.send(zmqpp::signal::test);
    p2.receive(s);
    BOOST_CHECK_EQUAL(zmqpp::signal::stop, s);
    p1.receive(s);
    BOOST_CHECK_EQUAL(zmqpp::signal::test, s);
}
BOOST_AUTO_TEST_CASE( test_wait )
{
    zmqpp::context ctx;
    zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
    zmqpp::socket p2(ctx, zmqpp::socket_type::pair);
    p1.bind("inproc://test");
    p2.connect("inproc://test");
    p1.send(zmqpp::signal::test);
    p1.send("....");
    p1.send("___");
    p1.send(zmqpp::signal::stop);
    BOOST_CHECK_EQUAL(zmqpp::signal::test, p2.wait());
    BOOST_CHECK_EQUAL(zmqpp::signal::stop, p2.wait());
}
BOOST_AUTO_TEST_CASE( test_signal_block_noblock )
{
    zmqpp::context ctx;
    zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
    zmqpp::socket p2(ctx, zmqpp::socket_type::pair);
    p1.bind("inproc://test");
    BOOST_CHECK_EQUAL(false, p1.send(zmqpp::signal::test, true)); //noblock
    //p1.send(zmqpp::signal::test);     p2.connect("inproc://test");
    zmqpp::signal sig;
    BOOST_CHECK_EQUAL(false, p1.receive(sig, true)); //noblock
    p1.send(zmqpp::signal::test);
    BOOST_CHECK_EQUAL(true, p2.receive(sig, true)); //noblock
}
#if (ZMQ_VERSION_MAJOR &gt;= 4)
BOOST_AUTO_TEST_CASE( simple_stream )
{
	zmqpp::context context;
	zmqpp::socket s1(context, zmqpp::socket_type::stream);
	zmqpp::socket s2(context, zmqpp::socket_type::stream);
	s1.bind("inproc://test");
	s2.connect("inproc://test");
	std::string identity;
	s2.get(zmqpp::socket_option::identity, identity);
	zmqpp::message request;
	request &lt;&lt; identity;
	request &lt;&lt; "Hello world!";
	BOOST_CHECK(s2.send(request));
	zmqpp::message response;
	BOOST_CHECK(s1.receive(response));
	BOOST_CHECK(response.parts() == 2);
	BOOST_CHECK(response.get(1) == "Hello world!");
}
#endif
#ifndef TRAVIS_CI_BUILD //do not run when building on travis-ci (this cause oom error and kill the test process)
BOOST_AUTO_TEST_CASE( sending_large_messages_string )
{
	zmqpp::context context;
	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.bind("inproc://test");
	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect("inproc://test");
	std::string message;
    const size_t bytes_to_send = static_cast&lt;size_t&gt;(1024 * 1024 * 1024);
    message.reserve(bytes_to_send);
    for (size_t i = 0; i &lt; bytes_to_send; i++)
    {
        message.push_back('A' + (i % 26));
    }
	BOOST_CHECK(pusher.send(message));
	zmq_pollitem_t item = { puller, 0, ZMQ_POLLIN, 0 };
    const int poll_timeout = 1000000;
	int result = zmq_poll(&amp;item, 1, poll_timeout);
	BOOST_REQUIRE_MESSAGE(result &gt;= 0, "polling command returned without expected value: " &lt;&lt; zmq_strerror(zmq_errno()));
	BOOST_REQUIRE_MESSAGE(0 != result, "polling command returned with timeout after " &lt;&lt; poll_timeout &lt;&lt; " milliseconds");
	BOOST_REQUIRE_MESSAGE(1 == result, "polling command claims " &lt;&lt; result &lt;&lt; " sockets have events but we only gave it one");
	BOOST_REQUIRE_MESSAGE(item.revents &amp; ZMQ_POLLIN, "events do not match expected POLLIN event: " &lt;&lt; item.revents);
    std::string received_message;
	BOOST_CHECK(puller.receive(received_message));
	BOOST_CHECK_EQUAL(0, message.compare(received_message));
	BOOST_CHECK(!puller.has_more_parts());
}
#endif
#if (ZMQ_VERSION_MAJOR &gt;= 4)
BOOST_AUTO_TEST_CASE( test_simple_monitor )
{
    zmqpp::context ctx;
    zmqpp::socket server(ctx, zmqpp::socket_type::push);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  std::this_thread::sleep_for(std::chrono::milliseconds(1000));
  zmqpp::socket puller(ctx, zmqpp::socket_type::pull);
  zmqpp::socket pusher(ctx, zmqpp::socket_type::push);
  pusher.connect(
      "inproc://frontend");   puller.connect("inproc://backend"); 
  zmqpp::message msg;
  msg &lt;&lt; "Hello";
  pusher.send(msg);
  std::string ret;
  puller.receive(ret);
  BOOST_CHECK_EQUAL("Hello", ret);
  puller.close();
  pusher.close();
  ctx.terminate();
  t1.join();
}</b></font>
BOOST_AUTO_TEST_SUITE_END()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
