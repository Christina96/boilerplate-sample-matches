
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.6129032258064515%, Tokens: 10</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-statusor_internal.h</h3>
            <pre><code>1  #ifndef ABSL_STATUS_INTERNAL_STATUSOR_INTERNAL_H_
2  #define ABSL_STATUS_INTERNAL_STATUSOR_INTERNAL_H_
3  #include <type_traits>
4  #include <utility>
5  #include "absl/base/attributes.h"
6  #include "absl/meta/type_traits.h"
7  #include "absl/status/status.h"
8  #include "absl/utility/utility.h"
9  namespace absl {
10  ABSL_NAMESPACE_BEGIN
11  template <typename T>
12  class ABSL_MUST_USE_RESULT StatusOr;
13  namespace internal_statusor {
14  template <typename T, typename U, typename = void>
15  struct HasConversionOperatorToStatusOr : std::false_type {};
16  template <typename T, typename U>
17  void test(char (*)[sizeof(std::declval<U>().operator absl::StatusOr<T>())]);
18  template <typename T, typename U>
19  struct HasConversionOperatorToStatusOr<T, U, decltype(test<T, U>(0))>
20      : std::true_type {};
21  template <typename T, typename U>
22  using IsConstructibleOrConvertibleFromStatusOr =
23      absl::disjunction<std::is_constructible<T, StatusOr<U>&>,
24                        std::is_constructible<T, const StatusOr<U>&>,
25                        std::is_constructible<T, StatusOr<U>&&>,
26                        std::is_constructible<T, const StatusOr<U>&&>,
27                        std::is_convertible<StatusOr<U>&, T>,
28                        std::is_convertible<const StatusOr<U>&, T>,
29                        std::is_convertible<StatusOr<U>&&, T>,
30                        std::is_convertible<const StatusOr<U>&&, T>>;
31  template <typename T, typename U>
32  using IsConstructibleOrConvertibleOrAssignableFromStatusOr =
33      absl::disjunction<IsConstructibleOrConvertibleFromStatusOr<T, U>,
34                        std::is_assignable<T&, StatusOr<U>&>,
35                        std::is_assignable<T&, const StatusOr<U>&>,
36                        std::is_assignable<T&, StatusOr<U>&&>,
37                        std::is_assignable<T&, const StatusOr<U>&&>>;
38  template <typename T, typename U>
39  struct IsDirectInitializationAmbiguous
40      : public absl::conditional_t<
41            std::is_same<absl::remove_cvref_t<U>, U>::value, std::false_type,
42            IsDirectInitializationAmbiguous<T, absl::remove_cvref_t<U>>> {};
43  template <typename T, typename V>
44  struct IsDirectInitializationAmbiguous<T, absl::StatusOr<V>>
45      : public IsConstructibleOrConvertibleFromStatusOr<T, V> {};
46  template <typename T, typename U>
47  using IsDirectInitializationValid = absl::disjunction<
48      std::is_same<T, absl::remove_cvref_t<U>>,
49      absl::negation<absl::disjunction<
50          std::is_same<absl::StatusOr<T>, absl::remove_cvref_t<U>>,
51          std::is_same<absl::Status, absl::remove_cvref_t<U>>,
52          std::is_same<absl::in_place_t, absl::remove_cvref_t<U>>,
53          IsDirectInitializationAmbiguous<T, U>>>>;
54  template <typename T, typename U>
55  struct IsForwardingAssignmentAmbiguous
56      : public absl::conditional_t<
57            std::is_same<absl::remove_cvref_t<U>, U>::value, std::false_type,
58            IsForwardingAssignmentAmbiguous<T, absl::remove_cvref_t<U>>> {};
59  template <typename T, typename U>
60  struct IsForwardingAssignmentAmbiguous<T, absl::StatusOr<U>>
61      : public IsConstructibleOrConvertibleOrAssignableFromStatusOr<T, U> {};
62  template <typename T, typename U>
63  using IsForwardingAssignmentValid = absl::disjunction<
64      std::is_same<T, absl::remove_cvref_t<U>>,
65      absl::negation<absl::disjunction<
66          std::is_same<absl::StatusOr<T>, absl::remove_cvref_t<U>>,
67          std::is_same<absl::Status, absl::remove_cvref_t<U>>,
68          std::is_same<absl::in_place_t, absl::remove_cvref_t<U>>,
69          IsForwardingAssignmentAmbiguous<T, U>>>>;
70  class Helper {
71   public:
72    static void HandleInvalidStatusCtorArg(Status*);
73    ABSL_ATTRIBUTE_NORETURN static void Crash(const absl::Status& status);
74  };
75  template <typename T, typename... Args>
76  ABSL_ATTRIBUTE_NONNULL(1) void PlacementNew(void* p, Args&&... args) {
77    new (p) T(std::forward<Args>(args)...);
78  }
79  template <typename T>
80  class StatusOrData {
81    template <typename U>
82    friend class StatusOrData;
83   public:
84    StatusOrData() = delete;
85    StatusOrData(const StatusOrData& other) {
86      if (other.ok()) {
87        MakeValue(other.data_);
88        MakeStatus();
89      } else {
90        MakeStatus(other.status_);
91      }
92    }
93    StatusOrData(StatusOrData&& other) noexcept {
94      if (other.ok()) {
95        MakeValue(std::move(other.data_));
96        MakeStatus();
97      } else {
98        MakeStatus(std::move(other.status_));
99      }
100    }
101    template <typename U>
102    explicit StatusOrData(const StatusOrData<U>& other) {
103      if (other.ok()) {
104        MakeValue(other.data_);
105        MakeStatus();
106      } else {
107        MakeStatus(other.status_);
108      }
109    }
110    template <typename U>
111    explicit StatusOrData(StatusOrData<U>&& other) {
112      if (other.ok()) {
113        MakeValue(std::move(other.data_));
114        MakeStatus();
115      } else {
116        MakeStatus(std::move(other.status_));
117      }
118    }
119    template <typename... Args>
120    explicit StatusOrData(absl::in_place_t, Args&&... args)
121        : data_(std::forward<Args>(args)...) {
122      MakeStatus();
123    }
124    explicit StatusOrData(const T& value) : data_(value) {
125      MakeStatus();
126    }
127    explicit StatusOrData(T&& value) : data_(std::move(value)) {
128      MakeStatus();
129    }
130    template <typename U,
131              absl::enable_if_t<std::is_constructible<absl::Status, U&&>::value,
132                                int> = 0>
133    explicit StatusOrData(U&& v) : status_(std::forward<U>(v)) {
134      EnsureNotOk();
135    }
136    StatusOrData& operator=(const StatusOrData& other) {
137      if (this == &other) return *this;
138      if (other.ok())
139        Assign(other.data_);
140      else
141        AssignStatus(other.status_);
142      return *this;
143    }
144    StatusOrData& operator=(StatusOrData&& other) {
145      if (this == &other) return *this;
146      if (other.ok())
147        Assign(std::move(other.data_));
148      else
149        AssignStatus(std::move(other.status_));
150      return *this;
151    }
152    ~StatusOrData() {
153      if (ok()) {
154        status_.~Status();
155        data_.~T();
156      } else {
157        status_.~Status();
158      }
159    }
160    template <typename U>
<span onclick='openModal()' class='match'>161    void Assign(U&& value) {
162      if (ok()) {
163        data_ = std::forward<U>(value);
164      } else {
165        MakeValue(std::forward<U>(value));
166        status_ = OkStatus();
167      }
168    }
</span>169    template <typename U>
170    void AssignStatus(U&& v) {
171      Clear();
172      status_ = static_cast<absl::Status>(std::forward<U>(v));
173      EnsureNotOk();
174    }
175    bool ok() const { return status_.ok(); }
176   protected:
177    union {
178      Status status_;
179    };
180    struct Dummy {};
181    union {
182      Dummy dummy_;
183      T data_;
184    };
185    void Clear() {
186      if (ok()) data_.~T();
187    }
188    void EnsureOk() const {
189      if (ABSL_PREDICT_FALSE(!ok())) Helper::Crash(status_);
190    }
191    void EnsureNotOk() {
192      if (ABSL_PREDICT_FALSE(ok())) Helper::HandleInvalidStatusCtorArg(&status_);
193    }
194    template <typename... Arg>
195    void MakeValue(Arg&&... arg) {
196      internal_statusor::PlacementNew<T>(&dummy_, std::forward<Arg>(arg)...);
197    }
198    template <typename... Args>
199    void MakeStatus(Args&&... args) {
200      internal_statusor::PlacementNew<Status>(&status_,
201                                              std::forward<Args>(args)...);
202    }
203  };
204  template <typename T, bool = std::is_copy_constructible<T>::value>
205  struct CopyCtorBase {
206    CopyCtorBase() = default;
207    CopyCtorBase(const CopyCtorBase&) = default;
208    CopyCtorBase(CopyCtorBase&&) = default;
209    CopyCtorBase& operator=(const CopyCtorBase&) = default;
210    CopyCtorBase& operator=(CopyCtorBase&&) = default;
211  };
212  template <typename T>
213  struct CopyCtorBase<T, false> {
214    CopyCtorBase() = default;
215    CopyCtorBase(const CopyCtorBase&) = delete;
216    CopyCtorBase(CopyCtorBase&&) = default;
217    CopyCtorBase& operator=(const CopyCtorBase&) = default;
218    CopyCtorBase& operator=(CopyCtorBase&&) = default;
219  };
220  template <typename T, bool = std::is_move_constructible<T>::value>
221  struct MoveCtorBase {
222    MoveCtorBase() = default;
223    MoveCtorBase(const MoveCtorBase&) = default;
224    MoveCtorBase(MoveCtorBase&&) = default;
225    MoveCtorBase& operator=(const MoveCtorBase&) = default;
226    MoveCtorBase& operator=(MoveCtorBase&&) = default;
227  };
228  template <typename T>
229  struct MoveCtorBase<T, false> {
230    MoveCtorBase() = default;
231    MoveCtorBase(const MoveCtorBase&) = default;
232    MoveCtorBase(MoveCtorBase&&) = delete;
233    MoveCtorBase& operator=(const MoveCtorBase&) = default;
234    MoveCtorBase& operator=(MoveCtorBase&&) = default;
235  };
236  template <typename T, bool = std::is_copy_constructible<T>::value&&
237                            std::is_copy_assignable<T>::value>
238  struct CopyAssignBase {
239    CopyAssignBase() = default;
240    CopyAssignBase(const CopyAssignBase&) = default;
241    CopyAssignBase(CopyAssignBase&&) = default;
242    CopyAssignBase& operator=(const CopyAssignBase&) = default;
243    CopyAssignBase& operator=(CopyAssignBase&&) = default;
244  };
245  template <typename T>
246  struct CopyAssignBase<T, false> {
247    CopyAssignBase() = default;
248    CopyAssignBase(const CopyAssignBase&) = default;
249    CopyAssignBase(CopyAssignBase&&) = default;
250    CopyAssignBase& operator=(const CopyAssignBase&) = delete;
251    CopyAssignBase& operator=(CopyAssignBase&&) = default;
252  };
253  template <typename T, bool = std::is_move_constructible<T>::value&&
254                            std::is_move_assignable<T>::value>
255  struct MoveAssignBase {
256    MoveAssignBase() = default;
257    MoveAssignBase(const MoveAssignBase&) = default;
258    MoveAssignBase(MoveAssignBase&&) = default;
259    MoveAssignBase& operator=(const MoveAssignBase&) = default;
260    MoveAssignBase& operator=(MoveAssignBase&&) = default;
261  };
262  template <typename T>
263  struct MoveAssignBase<T, false> {
264    MoveAssignBase() = default;
265    MoveAssignBase(const MoveAssignBase&) = default;
266    MoveAssignBase(MoveAssignBase&&) = default;
267    MoveAssignBase& operator=(const MoveAssignBase&) = default;
268    MoveAssignBase& operator=(MoveAssignBase&&) = delete;
269  };
270  ABSL_ATTRIBUTE_NORETURN void ThrowBadStatusOrAccess(absl::Status status);
271  }  
272  ABSL_NAMESPACE_END
273  }  
274  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.h</h3>
            <pre><code>1  #ifndef snap_memes_h
2  #define snap_memes_h
3  #include "Snap.h"
4  typedef enum {
5    qtUndef, qtQuote, qtInClust, qtRoot, qtCentr
6  } TQtTy;
7  typedef enum {
8    utUndef=0, utBlogLeft=1, utBlogRight=2, utBlog=3, utMedia=4
9  } TUrlTy; 
10  class TQuoteBs;
11  typedef TPt<TQuoteBs> PQuoteBs;
12  class TClustNet;
13  typedef TPt<TClustNet>  PClustNet;
14  typedef TNodeEDatNet<TPair<TStr, TInt>, TInt> TQtDomNet;  
15  typedef TPt<TQtDomNet> PQtDomNet;
16  #pragma pack(push, 1)
17  class TQuote {
18  public:
19    class TTmUrlCnt;
20    typedef TVec<TTmUrlCnt> TTmUrlCntV;
21    typedef TVec<TPair<TSecTm, TFlt> > TTmFltPrV;
22  public:
23    class TTmUrlCnt {
24    private:
25      TSecTm QtTm;
26      int QtUrlId;
27      uchar QtCnt;
28    public:
29      TTmUrlCnt() : QtTm(), QtUrlId(0), QtCnt(0) { }
<span onclick='openModal()' class='match'>30      TTmUrlCnt(const TSecTm& Tm, const int& Url, const int& _QtCnt) : QtTm(Tm), QtUrlId(Url) {
31        if (_QtCnt>255) { QtCnt=255; } else { QtCnt=_QtCnt; } }
</span>32      TTmUrlCnt(const TTmUrlCnt& UrlCnt) { memcpy((void*)this, (void*)&UrlCnt, sizeof(TTmUrlCnt)); }
33      TTmUrlCnt(TSIn& SIn) { SIn.LoadBf(this, sizeof(TTmUrlCnt)); }
34      void Load(TSIn& SIn) { SIn.LoadBf(this, sizeof(TTmUrlCnt)); }
35      void Save(TSOut& SOut) const { SOut.SaveBf(this, sizeof(TTmUrlCnt)); }
36      TSecTm Tm() const { return QtTm; }
37      int UrlId() const { return QtUrlId; }
38      void SetUrlId(const int& _UrlId) { QtUrlId=_UrlId; }
39      int Cnt() const { return (int)QtCnt; }
40      TTmUrlCnt& operator = (const TTmUrlCnt& Tuc) { if(this!=&Tuc){memcpy((void*)this, (void*)&Tuc, sizeof(TTmUrlCnt));} return *this; }
41      bool operator == (const TTmUrlCnt& Val) const { return memcmp((void*) this, (void*)&Val, sizeof(TTmUrlCnt))==0; }
42      bool operator < (const TTmUrlCnt& Val) const {
43        return QtTm < Val.QtTm || (QtTm==Val.QtTm && UrlId()<Val.UrlId()) || (QtTm==Val.QtTm && UrlId()==Val.UrlId() && Cnt()<Val.Cnt()); }
44    };
45    class TQtIdTy {
46    public:
47      uint Id:26;
48      uint Ty:4;
49    public:
50      TQtIdTy(const int& _Id=0, const TQtTy& _Ty=qtUndef) : Id(_Id), Ty((uint)_Ty) { IAssert(_Id<(int)TMath::Pow2(26) && int(_Ty)<16); }
51      TQtIdTy(TSIn& SIn) { SIn.LoadBf(this, sizeof(TQtIdTy)); }
52      void Load(TSIn& SIn) { SIn.LoadBf(this, sizeof(TQtIdTy)); }
53      void Save(TSOut& SOut) const { SOut.SaveBf(this, sizeof(TQtIdTy)); }
54    };
55  public:
56    TQtIdTy QtCIdTy; 
57    TStr QtStr;      
58    TVec<TTmUrlCnt> TmUrlCntV;
59  public:
60    TQuote() { }
61    TQuote(TSIn& SIn) : QtCIdTy(SIn), QtStr(SIn), TmUrlCntV(SIn) { }
62    void Save(TSOut& SOut) const { QtCIdTy.Save(SOut); QtStr.Save(SOut); TmUrlCntV.Save(SOut); }
63    void Load(TSIn& SIn) { QtCIdTy.Load(SIn); QtStr.Load(SIn); TmUrlCntV.Load(SIn); }
64    PXmlTok GetXmlTok() const { Fail; return TXmlTok::New("NodeData"); }
65    int GetId() const { return QtCIdTy.Id; }
66    int GetCId() const { return QtCIdTy.Id; }
67    TQtTy GetTy() const { return (TQtTy) QtCIdTy.Ty; }
68    TStr GetStr() const { return QtStr; }
69    int GetFq() const; 
70    int GetFq(const TSecTm& BegTm, const TSecTm& EndTm) const; 
71    int GetUrls() const { return TmUrlCntV.Len(); }
72    int GetDoms(const TQuoteBs& QtBs) const;
73    int GetFq(const TUrlTy& UrlTy, const TQuoteBs& QtBs) const;
74    int GetFq(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const;
75    int GetUrls(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const;
76    int GetTimes() const { return TmUrlCntV.Len(); }
77    TSecTm GetTm(const int& t) const { return TmUrlCntV[t].Tm(); }
78    int GetUrlId(const int& t) const { return TmUrlCntV[t].UrlId(); }
79    int GetCnt(const int& t) const { return TmUrlCntV[t].Cnt(); }
80    TSecTm GetMinTm() const { return TmUrlCntV.Empty()?TSecTm():TmUrlCntV[0].Tm(); }
81    TSecTm GetMaxTm() const { return TmUrlCntV.Empty()?TSecTm():TmUrlCntV.Last().Tm(); }
82    TSecTm GetPeakTm(const TTmUnit& TmUnit=tmuDay, const TSecTm& AfterTm=TSecTm(1)) const;
83    TSecTm GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, TInt& FreqAtPeak) const;
84    TSecTm GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const;
85    TSecTm GetMeanTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm=TSecTm(1)) const;
86    TSecTm GetMedianTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm=TSecTm(1)) const;
87    bool IsSinglePeak(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const;
88    TStr GetDesc() const;
89    void GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit) const;
90    void GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const;
91    void GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm) const;
92    void GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const;
93    void GetSmoothFqOt(TTmFltPrV& FqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth,
94      const TSecTm& BegTm=TSecTm(0), const TSecTm& EndTm=TSecTm(TInt::Mx-1)) const;
95    void PlotOverTm(const TStr& OutFNm);
96    static void GetSmoothFqOt(TTmFltPrV& FqOtV, const TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm=TSecTm(0), const TSecTm& EndTm=TSecTm(TInt::Mx-1));
97    static void LoadQtV(const TStr& InFNm, TVec<TQuote>& QtV);
98    friend class TQuoteBs;
99  };
100  #pragma pack(pop)
101  typedef TVec<TQuote> TQuoteV;
102  class TQuoteBs {
103  public:
104    TCRef CRef;
105    TStrHash<TInt, TBigStrPool> StrQtIdH;    
106    THash<TInt, TQuote> QuoteH; 
107    TIntH UrlInDegH;  
108    TIntH UrlTyH;     
109    THash<TInt, TIntV> ClustQtIdVH; 
110  public:
111    TQuoteBs() : StrQtIdH() { }
112    TQuoteBs(TSIn& SIn);
113    void Save(TSOut& SOut) const;
114    static PQuoteBs New();
115    static PQuoteBs Load(TSIn& SIn);
116    int GetStrs() const { return StrQtIdH.Len(); }
117    const char *GetStr(const int& StrId) const { return StrQtIdH.GetKey(StrId); }
118    bool IsStrId(const int& StrId) const { return StrId < StrQtIdH.Len(); }
119    bool IsStr(const char* CStr) const { return StrQtIdH.IsKey(CStr); }
120    bool IsStr(const TChA& Str) const { return StrQtIdH.IsKey(Str.CStr()); }
121    int GetStrId(const char* CStr) const { return StrQtIdH.GetKeyId(CStr); }
122    int GetStrId(const TChA& Str) const { return StrQtIdH.GetKeyId(Str.CStr()); }
123    int AddStr(const char* CStr) { return StrQtIdH.AddDat(CStr, -1); }
124    int AddStr(const TChA& ChA) { return StrQtIdH.AddDat(ChA.CStr(), -1); }
125    int Len() const { return QuoteH.Len(); }
126    bool IsQt(const char* CStr) const { return GetQtId(CStr)!=-1; }
127    bool IsQtId(const int& QtId) const { return QuoteH.IsKey(QtId); }
128    int GetQtId(const int& QtN) const { return QuoteH.GetKey(QtN); }
129    int GetQtId(const char* CStr) const { return IsStr(CStr)? StrQtIdH.GetDat(CStr).Val : -1; }
130    const TQuote& GetQt(const int& QtId) const { return QuoteH.GetDat(QtId); }
131    TQuote& GetQt(const int& QtId) { return QuoteH.GetDat(QtId); }
132    const TQuote& GetQtN(const int& QtN) const { return QuoteH[QtN]; }
133    TQuote& GetQtN(const int& QtN) { return QuoteH[QtN]; }
134    void DelQtId(const int& QtId) { return QuoteH.DelKey(QtId); }
135    TUrlTy GetUrlTy(const int& UrlId) const;
136    void SetUrlTy(const TStr& InFNm, const TUrlTy& SetTy);
137    void GetQtIdV(TIntV& QtIdV) const;
138    void GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const bool& OnlyClustRoots=true,
139      const TStr& HasWord="", const TStr& AppearsAtUrl="", const TUrlTy& OnlyCountTy=utUndef, const TSecTm& BegTm=TSecTm(0), const TSecTm& EndTm=TSecTm(TInt::Mx-1)) const;
140    void GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const TStrV& FromDomains, const bool& OnlyClustRoots=true, const TStr& HasWord="", int MinDoms=5) const;
141    void GetQtIdVByTm(const int& WndSzHr, const int& StepHr, const int& MinWrdLen, const int& MinQtFq, const int& TakePerStep) const;
142    void GetCIdVByFq(TIntV& CIdV, const int& MinClFq, const TStr& RootHasWord="", const TUrlTy& OnlyCountTy=utUndef,
143      const bool& OnlyAfterRoot=false, const TSecTm& BegTm=TSecTm(0), const TSecTm& EndTm=TSecTm(TInt::Mx-1)) const;
144    void GetMinMaxTm(TSecTm& MinTm, TSecTm&MaxTm) const;
145    void GetMinMaxTm(const TIntV& QtIdV, TSecTm& MinTm, TSecTm&MaxTm) const;
146    void GetQtPageUrl(const TIntV& QtIdV, TIntH& QtUrlIdH) const;
147    void AddQuote(const TQuote& Quote, const TQuoteBs& CurQtBs);
148    void AddQuote(const TVec<TChA>& QuoteV, const TVec<TChA>& LinkV, const TChA& PostUrlStr, const TSecTm& PubTm, const int& MinQtWrdLen=4);
149    PQuoteBs GetQuoteBs(const TIntV& QtIdV) const;
150    int GetClusts() const { return ClustQtIdVH.Len(); }
151    int GetCId(const int& ClustN) const { return ClustQtIdVH.GetKey(ClustN); }
152    bool IsClust(const int& CId) const { return ClustQtIdVH.IsKey(CId); }
153    const TIntV& GetClust(const int& CId) const { return ClustQtIdVH.GetDat(CId); } 
154    const TIntV& GetClustN(const int& N) const { return ClustQtIdVH[N]; } 
155    int GetQtsInClust() const;
156    int GetClustFq(const int& CId) const;
157    int GetClustFq(const int& CId, const TUrlTy& UrlTy) const;
158    int GetCentrQtId(const int& CId) const;
159    int GetCentrQtId(const TIntV& QtIdV) const;
160    void GetMergedClustQt(const int& CId, TQuote& NewQt, const bool& OnlyAfterBegTm=true) const;
161    void GetMergedClustQt(const TIntV& QtIdV, TQuote& NewQt, const bool& OnlyAfterBegTm=true) const;
162    TSecTm GetClustBegTm(const int& CId, const int& CentrQtId) const;
163    TSecTm GetClustBegTm(const TIntV& ClustV, const int& CentrQtId) const;
164    void CreateClusters(const TVec<TIntV>& ClustQtIdV);
165    void ClusterQts(const int& MinRootWrdLen, const int& MinQtFq, const TStr& OutFNmPref, const TStrV& BlackListV=TStrV());
166    void ResetClusters();
167    void ReassignToClust(const int& QtId, const int& NewCId);
168    void Mergec2Clusters(const int& ParentCId, const int& ChildCId);
169    PClustNet GetClustNet(const int& MinQtFq, const TStr& OutFNmPref) const;
170    PQuoteBs GetMergeClusters(const bool& OnlyClusters=true) const;
171    void AddMergedQtsToQtBs();
172    void GetTopQtDoms(TStrIntPrV& DomCntV, const int& TakeNClust, const int& MinClFq, const TStr& RootHasWord="", const TUrlTy& OnlyCountTy=utUndef) const;
173    void TopDomsByLag(const TTmUnit& TmUnit, const int& TakeNDoms, const int& TakeNClusts, const int& Thresh) const;
174    void PlotQtFqCnt(const TStr& OutFNmPref) const;
175    void PlotQtMediaVsBlogFq(const int& QtId, const TStr& OutFNmPref) const;
176    void PlotClustMediaVsBlogFq(const int& CId, const TStr& OutFNmPref) const;
177    void PlotMediaVsBlogLag(const TTmUnit& TmUnit, const bool& TakeClusters, const int& TakeN, const TStr& OutFNmPref) const;
178    void PlotFqDecay(const TTmUnit& TmUnit, const bool& TakeClusters, const TUrlTy& CntUrlTy, const int& PlotN, const int& MinValsPerTm, const TStr& OutFNmPref) const;
179    void PlotBlogVsMediaFqOt(const TTmUnit& TmUnit, const bool& TakeClusters, int PlotN, const TStr& OutFNmPref) const;
180    void PlotBlogFracOt(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const;
181    void PlotPopularityCnt(const bool& TakeClusters, const TUrlTy& UrlTy, const int& PlotN, const TStr& OutFNmPref) const;
182    void PlotEmptyY(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const;
183    PNGraph GetQuotePostNet(const TStr& DatasetFNm) const;
184    PQtDomNet GetQuoteDomNet(const PNGraph& PostLinkGraph, const int& CId) const;
185    void SaveQuotes(const int& MinQtFq, const TStr& OutFNm) const;
186    void SaveQuotes(const TIntV& QtIdV, const TStr& OutFNm) const;
187    void SaveClusters(const TStr& OutFNm, const bool& SkipUrls=true) const;
188    void SaveClusters(const TIntV& ClustIdV, const TStr& OutFNm, const bool& SkipUrls=true) const;
189    void SaveBigBlogMassQt(const TStr& OutFNm) const;
190    void SaveForFlash(const TIntV& QtIdV, const TStr& OutFNm, const TTmUnit& TmUnit, int SaveN, const TSecTm& BegTm=TSecTm(1), const TSecTm& EndTm=TSecTm(TInt::Mx-1), const TUrlTy& OnlyCountTy=utUndef) const;
191    void SaveForFlash2(const TIntV& QtIdV, const TStr& OutFNm, const TTmUnit& TmUnit, int SaveN, const TSecTm& BegTm=TSecTm(1), const TSecTm& EndTm=TSecTm(TInt::Mx-1), const TUrlTy& OnlyCountTy=utUndef) const;
192    void SaveDomainStat(const TStr& OutFNm, const int& MinCnt) const;
193    void Dump(const bool& Fast=false) const;
194    static int LongestCmnSubSq(const TIntV& WIdV1, const TIntV& WIdV2, int& WIdV1Start, int& WIdV2Start, int& SkipId);
195    static PQuoteBs FindQtInTxtQBs(const TStr& InBinFNmWc, const TStrV& QuoteStrV);
196    friend class TPt<TQuoteBs>;
197  };
198  class TClustNet : public TNodeNet<TQuote> {
199  public:
200    TClustNet() { }
201    TClustNet(TSIn& SIn) : TNet(SIn) { }
202    void Save(TSOut& SOut) const { TNet::Save(SOut); }
203    static PClustNet New() { return new TClustNet(); }
204    static PClustNet Load(TSIn& SIn) { return new TClustNet(SIn); }
205    void AddLink(const TQuote& SrcQt, const TQuote& DstQt);
206    PClustNet GetSubGraph(const TIntV& NIdV) const;
207    PClustNet GetSubGraph(const int& MinQtWords, const int& MaxQtWords, const int& MinFq) const;
208    void RecalcEdges(const double& MinOverlapFrac);
209    void MakeClusters(const TIntPrV& KeepEdgeV);
210    void KeepOnlyTree(const TIntPrV& KeepEdgeV);
211    void GetClusters(TVec<TIntV>& QtNIdV) const;
212    void GetMergedClustQt(const TIntV& QtIdV, TQuote& NewQt) const;
213    int EvalPhraseClusters(const TIntPrV& KeepEdgeV, const bool& dump=true) const;
214    void ClustKeepSingleEdge(const int& MethodId) const;
215    void ClustKeepSingleEdge(const int& MethodId, TIntPrV& KeepEdgeV) const;
216    void ClustGreedyTopDown() const;
217    void ClustGreedyTopDown(TIntPrV& KeepEdgeV) const;
218    void ClustGreedyRandom() const;
219    PClustNet GetThis() const { IAssert(CRef.GetRefs()>0); return PClustNet((TClustNet *) this); }
220    void DrawNet(const TStr& OutFNm, const int& SaveTopN=10) const;
221    void DumpNodes(const TStr& OutFNm, const int& SaveTopN=10) const;
222    void DumpClusters(const TStr& OutFNm, int SaveTopN=10) const;
223    void DumpClustersByVol(const TStr& OutFNm, const int& MinClustSz, const int& MinVolume) const;
224    static PClustNet GetFromQtBs(const PQuoteBs& QtBs, int MinQtFq=5, int MnWrdLen=5);
225    friend class TPt<TClustNet>;
226  };
227  class TQuoteLoader {
228  private:
229    TFFile FFile;
230    PSIn SIn;
231    TExeTm ExeTm;
232  public:
233    TStr CurFNm;
234    int PostCnt;
235    TSecTm PubTm;
236    TChA PostUrlStr;
237    TChA PostTitleStr;
238    TChA BlogUrlStr;
239    TChA BlogTitleStr;
240    TChA ContentStr;
241    TVec<TChA> QuoteV;
242    TVec<TChA> LinkV;
243  private:
244    bool LoadItem(TXmlLx& XmlLx);
245  public:
246    TQuoteLoader(const TStr& InFNmWc) : FFile(InFNmWc), PostCnt(0) { }
247    virtual ~TQuoteLoader() { }
248    void Save(TSOut& SOut) const;
249    void Load(TSIn& SIn);
250    void Clr();
251    bool Next();
252    void ProcessPosts(const bool& IsXml=false, int LoadN=-1);
253    virtual void StartProcess() { }
254    virtual void EndProcess(const int& PostCnt) { }
255    virtual void StartProcFile(const TStr& FNm) { }
256    virtual void EndProcFile(const TStr& FNm) { }
257    virtual void ProcessPost(const bool& GoodItem) { }
258  };
259  class TMemesDataLoader {
260  private:
261    PFFile FFile;
262    PSIn InFNmF;
263    PSIn SInPt;
264    TChA CurLn;
265    bool GetNextFile();
266  public:
267    uint64 LineCnt;
268    TChA PostUrlStr;
269    TChA ContentStr;
270    TSecTm PubTm;
271    TVec<TChA> MemeV;       
272    TVec<TIntPr> MemePosV;  
273    TVec<TChA> LinkV;       
274    TVec<TInt> LinkPosV;    
275  public:
276    TMemesDataLoader(const TStr& FNmWc, const bool& IsWc=true) {
277      if (IsWc) { FFile = TFFile::New(FNmWc, false); } 
278      else { InFNmF = TFIn::New(FNmWc); } 
279    }
280    void Clr();
281    bool LoadNext();
282    void SaveTxt(TSOut& SOut) const;
283    void Dump(const bool& DumpAll=false) const;
284  };
285  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-statusor_internal.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.h</div>
                </div>
                <div class="column column_space"><pre><code>161    void Assign(U&& value) {
162      if (ok()) {
163        data_ = std::forward<U>(value);
164      } else {
165        MakeValue(std::forward<U>(value));
166        status_ = OkStatus();
167      }
168    }
</pre></code></div>
                <div class="column column_space"><pre><code>30      TTmUrlCnt(const TSecTm& Tm, const int& Url, const int& _QtCnt) : QtTm(Tm), QtUrlId(Url) {
31        if (_QtCnt>255) { QtCnt=255; } else { QtCnt=_QtCnt; } }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    