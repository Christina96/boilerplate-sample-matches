
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.809648662821184%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoodm.cpp</h3>
            <pre><code>1  #include "yahoodm.h"
2  TYTb::TYTb(const PYBs& _YBs, const PYDsBs& _YDsBs):
3    YBs(_YBs), YDsBs(_YDsBs),
4    VarNToWordIdV(YBs->GetWords()), WordIdToVarNV(YBs->GetMxWordIds()),
5    TupNToDocIdV(YBs->GetDocs()), DocIdToTupNV(YBs->GetMxDocIds()){
6    int WordId=YBs->FFirstWordId(); int VarN=0-1;
7    while (YBs->FNextWordId(WordId)){VarN++;
8      VarNToWordIdV[VarN]=WordId; WordIdToVarNV[WordId]=VarN;}
9    int DocId=YBs->FFirstDocId(); int TupN=0-1;
10    while (YBs->FNextDocId(DocId)){TupN++;
11      TupNToDocIdV[TupN]=DocId; DocIdToTupNV[DocId]=TupN;}
12  }
13  TTbVal TYTb::GetVal(const int& TupN, const int& VarN){
14    int DocId=TupNToDocIdV[TupN];
15    int WordId=VarNToWordIdV[VarN];
16    double WordFq;
17    if (YDsBs->GetWordDs(DocId)->IsWordId(WordId, WordFq)){return WordFq;}
18    else {return double(0);}
19  }
20  TYDmDs::TYDmDs(
21   const bool& _DoPriorDmDs, const int& ClassN,
22   const int& _YNegDsType, const int& _YPriorType,
23   const PYBs& _YBs, const PYDsBs& _YDsBs, const PDmHd& _DmHd):
24    DoPriorDmDs(_DoPriorDmDs),
25    YNegDsType(_YNegDsType), YPriorType(_YPriorType),
26    YBs(_YBs), YDsBs(_YDsBs), DmHd(_DmHd),
27    NegWordDs(), PosWordDs(),
28    CValDs(), NegCValPrb(), PosCValPrb(){
29    NegWordDs=GetNegWordDs(YNegDsType, YBs, YDsBs);
30    PosWordDs=YDsBs->GetWordDs(ClassN);
31    CValDs=GetPriorValDs(YPriorType, NegWordDs, PosWordDs);
32    NegCValPrb=CValDs->GetPrb_RelFq(TTbVal::NegVal);
33    PosCValPrb=CValDs->GetPrb_RelFq(TTbVal::PosVal);
34  }
35  double TYDmDs::GetSumW(){
36    return CValDs->GetSumW();
37  }
38  PTbValDs TYDmDs::GetCDs(){
39    return CValDs;
40  }
41  PTbValDs TYDmDs::GetAVDs(const int& AttrN){
42    if (DoPriorDmDs){
43      return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
44    } else {
45      return TTbValDs::GetBoolValDs(-1,
46       NegCValPrb*NegWordDs->GetWordPrb(AttrN)+
47       PosCValPrb*PosWordDs->GetWordPrb(AttrN));
48    }
49  }
50  PTbValDs TYDmDs::GetCAVDs(const TTbVal& CVal, const int& AttrN){
51    if (DoPriorDmDs){
52      return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
53    } else {
54      if (CVal==TTbVal::NegVal){
55        return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
56      } else
57      if (CVal==TTbVal::PosVal){
58        return TTbValDs::GetBoolValDs(-1, PosWordDs->GetWordPrb(AttrN));
59      } else {
60        Fail; return NULL;
61      }
62    }
63  }
64  PYWordDs TYDmDs::GetNegWordDs(
65   const int& YNegDsType, const PYBs& YBs, const PYDsBs& YDsBs){
66    PYWordDs NegWordDs;
67    switch (TYNegDsType(YNegDsType)){
68      case yndtEmpty: NegWordDs=PYWordDs(new TYWordDs(0, 0, 0)); break;
69      case yndtRoot: NegWordDs=YDsBs->GetWordDs(YBs->GetRootDocId()); break;
70      case yndtAll: NegWordDs=YDsBs->GetAllWordDs(); break;
71      default: Fail;
72    }
73    return NegWordDs;
74  }
75  PTbValDs TYDmDs::GetPriorValDs(const int& YPriorType,
76   const PYWordDs& NegWordDs, const PYWordDs& PosWordDs){
77    double PosW; double AllW;
78    switch (TYPriorType(YPriorType)){
79      case yptWords:
80        PosW=PosWordDs->GetSumWordFq(); AllW=NegWordDs->GetSumWordFq(); break;
81      case yptSects:
82        PosW=PosWordDs->GetSects(); AllW=NegWordDs->GetSects(); break;
83      case yptDocs:
84        PosW=PosWordDs->GetDocs(); AllW=NegWordDs->GetDocs(); break;
85      default: Fail;
86    }
87    return TTbValDs::GetBoolValDs(AllW, PosW);
88  }
89  TStr TYDmDs::GetYNegDsTypeStr(const TYNegDsType& YNegDsType){
90    switch (YNegDsType){
91      case yndtEmpty: return "Empty";
92      case yndtRoot: return "Root";
93      case yndtAll: return "All";
94      default: Fail; return TStr();
95    }
96  }
97  TStr TYDmDs::GetYPriorTypeStr(const TYPriorType& YPriorType){
98    switch (YPriorType){
99      case yptWords: return "Words";
100      case yptSects: return "Sects";
101      case yptDocs: return "Docs";
102      default: Fail; return TStr();
103    }
104  }
105  TYFSelBs::TYFSelBs(
106   const TYFSelType& FSelType, const double& FSels,
107   const bool& FSelPosWords, const PAttrEst& AttrEst,
108   const TYNegDsType& _YNegDsType, const TYPriorType& YPriorType,
109   const PYBs& YBs, const PYDsBs& YDsBs, const PNotify& Notify):
110    YNegDsType(_YNegDsType), DocIdToWordIdEstVV(YBs->GetDocs()){
111    TNotify::OnNotify(Notify, ntInfo, "Start Feature Selection");
112    PDmHd DmHd=new TYDmHd(YBs, YDsBs);
113    PYWordDs NegWordDs=TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs);
114    PTbValSplit BoolValSplit=TTbValSplit::GetBoolValSplit();
115    int DocId=YBs->FFirstDocId(); int DocIds=0;
116    while (YBs->FNextDocId(DocId)){
117      PYWordDs PosWordDs=YDsBs->GetWordDs(DocId); DocIds++;
118      int SelWordIds;
119      switch (FSelType){
120        case yfstFix: SelWordIds=int(FSels); break;
121        case yfstPosPrc:
122          SelWordIds=int(FSels*double(PosWordDs->GetWordIds())); break;
123        case yfstUnionPrc:{
124          PYWordDs UnionWordDs=TYWordDs::GetMerged(PosWordDs, NegWordDs, 1, 1);
125          SelWordIds=int(FSels*double(UnionWordDs->GetWordIds())); break;}
126        default: Fail; SelWordIds=0;
127      }
128      if (SelWordIds<=0){SelWordIds=1;}
129      PDmDs DmDs=PDmDs(new TYDmDs(
130       false, DocId, YNegDsType, YPriorType, YBs, YDsBs, DmHd));
131      PDmDs PriorDmDs=PDmDs(new TYDmDs(
132       true, DocId, yndtAll, yptDocs, YBs, YDsBs, DmHd));
133      PYWordDs WordDs; PYWordDs TrvWordDs;
134      TIntH SelWordIdH(SelWordIds);
135      TFltIntKdV WordEstIdKdV(SelWordIds, 0);
136      for (int CDsc=0; CDsc<TTbVal::BoolVals; CDsc++){
137        switch (CDsc){
138          case 0: WordDs=NegWordDs; break;
139          case 1: WordDs=PosWordDs; break;
140          default: Fail;
141        }
142        if (FSelPosWords){TrvWordDs=PosWordDs;} else {TrvWordDs=WordDs;}
143        int WordIdN=TrvWordDs->FFirstWordId(); int WordId;
144        while (TrvWordDs->FNextWordId(WordIdN, WordId)){
145          if (SelWordIdH.IsKey(WordId)){continue;}
146          double WordEst;
147          if (AttrEst.Empty()){
148            double PriorSumW=YBs->GetDocs();
149            IAssert(PriorSumW>0);
150            double S1C0Prb=NegWordDs->GetWordPrb(WordId);
<span onclick='openModal()' class='match'>151            double S1C1Prb=PosWordDs->GetWordPrb(WordId);
152            if (S1C0Prb==0){S1C0Prb=1/sqr(PriorSumW);}
153            if (S1C0Prb==1){S1C0Prb=1-(1/sqr(PriorSumW));}
</span>154            double OddsS1C0=S1C0Prb/(1-S1C0Prb);
155            if (S1C1Prb==0){S1C1Prb=1/sqr(PriorSumW);}
156            if (S1C1Prb==1){S1C1Prb=1-(1/sqr(PriorSumW));}
157            double OddsS1C1=S1C1Prb/(1-S1C1Prb);
158            WordEst=log(OddsS1C1/OddsS1C0);
159          } else {
160            WordEst=AttrEst->GetAttrQ(WordId, BoolValSplit, DmDs, PriorDmDs);
161          }
162          WordEstIdKdV.AddSorted(TFltIntKd(WordEst, WordId), false, SelWordIds);
163          SelWordIdH.AddKey(WordId);
164        }
165      }
166      TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
167      WordIdEstKdV.Gen(WordEstIdKdV.Len(), 0);
168      for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
169        double WordEst=WordEstIdKdV[WordIdN].Key;
170        int WordId=WordEstIdKdV[WordIdN].Dat;
171        WordIdEstKdV.Add(TIntFltKd(WordId, WordEst));
172      }
173      WordIdEstKdV.Sort();
174      if (DocIds%100==0){
175        TNotify::OnNotify(Notify, ntInfo,
176         TStr("...")+TInt::GetStr(DocIds)+" Selections.");}
177    }
178    TNotify::OnNotify(Notify, ntInfo,
179     TStr("Feature Selection Finished (")+ TInt::GetStr(DocIds)+").");
180  }
181  void TYFSelBs::GetBestWordIdV(
182   const int& DocId, const double& EstExp, const double& SumEstPrb,
183   const PYWordDs& IntrsWordDs, TIntV& BestWordIdV){
184    TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
185    TFltIntKdV WordEstIdKdV(WordIdEstKdV.Len(), 0);
186    double MnWordEst=TFlt::Mx;
187    for (int WordIdN=0; WordIdN<WordIdEstKdV.Len(); WordIdN++){
188      int WordId=WordIdEstKdV[WordIdN].Key;
189      double WordEst=pow(WordIdEstKdV[WordIdN].Dat, EstExp);
190      if (IntrsWordDs->IsWordId(WordId)){
191        WordEstIdKdV.Add(TFltIntKd(WordEst, WordId));
192        MnWordEst=TFlt::GetMn(WordEst, MnWordEst);
193      }
194    }
195    double SumWordEst=0;
196    {for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
197      SumWordEst+=(WordEstIdKdV[WordIdN].Key-=MnWordEst);}}
198    WordEstIdKdV.Sort(false);
199    {BestWordIdV.Gen(WordEstIdKdV.Len(), 0);
200    SumWordEst*=SumEstPrb; int WordIdN=0;
201    while ((SumWordEst>=0)&&(WordIdN<WordEstIdKdV.Len())){
202      double WordEst=WordEstIdKdV[WordIdN].Key;
203      int WordId=WordEstIdKdV[WordIdN].Dat;
204      SumWordEst-=WordEst;
205      BestWordIdV.Add(WordId);
206      WordIdN++;
207    }}
208  }
209  void TYFSelBs::SaveTxt(
210   const PSOut& SOut, const PYBs& YBs, const PYDsBs& YDsBs){
211    PYWordDs NegWordDs=TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs);
212    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
213    for (int DocId=0; DocId<DocIdToWordIdEstVV.Len(); DocId++){
214      TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
215      TFltIntKdV WordEstIdKdV(WordIdEstKdV.Len(), 0);
216      for (int WordIdN=0; WordIdN<WordIdEstKdV.Len(); WordIdN++){
217        int WordId=WordIdEstKdV[WordIdN].Key;
218        double WordEst=WordIdEstKdV[WordIdN].Dat;
219        WordEstIdKdV.Add(TFltIntKd(WordEst, WordId));
220      }
221      WordEstIdKdV.Sort(false);
222      Lx.PutVarStr("UrlStr", YBs->GetDocUrlStr(DocId));
223      Lx.PutVarInt("DocId", DocId);
224      PYWordDs WordDs=YDsBs->GetWordDs(DocId);
225      Lx.PutVar("WordIdEstKdV", true, true); 
226      {for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
227        double WordEst=WordEstIdKdV[WordIdN].Key;
228        int WordId=WordEstIdKdV[WordIdN].Dat;
229        TStr WordStr=YBs->GetWordStr(WordId);
230        double PosWordPrb=WordDs->GetWordPrb(WordId);
231        double NegWordPrb=NegWordDs->GetWordPrb(WordId);
232        Lx.PutQStr(WordStr);
233        Lx.PutTab(); Lx.PutFlt(WordEst);
234        Lx.PutIndent(1); Lx.PutSym(syLBracket);
235        Lx.PutFlt(PosWordPrb); Lx.PutFlt(NegWordPrb);
236        Lx.PutSym(syRBracket);
237        Lx.PutLn();
238      }}
239      Lx.PutSym(syRBracket); Lx.PutLn();
240    }
241  }
242  TStr TYFSelBs::GetYFSelTypeStr(const TYFSelType& YFSelType){
243    switch (YFSelType){
244      case yfstFix: return "Fix";
245      case yfstPosPrc: return "PosPrc";
246      case yfstUnionPrc: return "NegPrc";
247      default: Fail; return TStr();
248    }
249  }
250  TYInvIx::TYInvIx(
251   const double& EstExp, const double& SumEstPrb,
252   const PYBs& YBs, const PYDsBs& YDsBs,
253   const PYFSelBs& YFSelBs, const PNotify& Notify):
254    WordIdToFirstDocIdNH(YBs->GetWords()/2),
255    DocIdVHeap(), AllDocIdV(YBs->GetDocs(), 0){
256    TNotify::OnNotify(Notify, ntInfo, "Start Creating Inverted Index");
257    TIntPrV WordIdDocIdPrV(YBs->GetDocs(), 0);
258    TIntV BestWordIdV;
259    int DocId=YBs->FFirstDocId();
260    while (YBs->FNextDocId(DocId)){
261      AllDocIdV.Add(DocId);
262      PYWordDs PosWordDs=YDsBs->GetWordDs(DocId);
263      YFSelBs->GetBestWordIdV(DocId, EstExp, SumEstPrb, PosWordDs, BestWordIdV);
264      for (int WordIdN=0; WordIdN<BestWordIdV.Len(); WordIdN++){
265        int WordId=BestWordIdV[WordIdN];
266        WordIdDocIdPrV.Add(TIntPr(WordId, DocId));
267      }
268    }
269    WordIdDocIdPrV.Sort();
270    DocIdVHeap.Gen(WordIdDocIdPrV.Len()+YBs->GetDocs(), 0);
271    int PrevWordId=-1;
272    for (int WordIdN=0; WordIdN<WordIdDocIdPrV.Len(); WordIdN++){
273      int WordId=WordIdDocIdPrV[WordIdN].Val1;
274      int DocId=WordIdDocIdPrV[WordIdN].Val2;
275      if (PrevWordId!=WordId){
276        if (PrevWordId!=-1){DocIdVHeap.Add(TInt(-1));}
277        PrevWordId=WordId;
278        WordIdToFirstDocIdNH.AddDat(TInt(WordId), TInt(DocIdVHeap.Len()));
279      }
280      DocIdVHeap.Add(DocId);
281    }
282    DocIdVHeap.Add(TInt(-1));
283    TNotify::OnNotify(Notify, ntInfo, "End Creating Inverted Index");
284  }
285  void TYInvIx::GetDocIdV(
286   const PYWordDs& WordDs, const int& MnDocFq, TIntV& DocIdV){
287    IAssert(MnDocFq>=0);
288    if (MnDocFq==0){
289      DocIdV=AllDocIdV;
290    } else {
291      TIntIntH DocIdFqH(100); int MxDocFq=0;
292      int WordIdN=WordDs->FFirstWordId(); int WordId; double WordFq;
293      while (WordDs->FNextWordId(WordIdN, WordId, WordFq)){
294        if (WordIdToFirstDocIdNH.IsKey(WordId)){
295          int DocIdN=FFirstDocId(WordId); int DocId;
296          while (FNextWordId(DocIdN, DocId)){
297            DocIdFqH.AddDat(DocId)+=int(WordFq);
298            MxDocFq=TInt::GetMx(MxDocFq, DocIdFqH.GetDat(DocId));
299          }
300        }
301      }
302      int NewMnDocFq=(MnDocFq<=MxDocFq) ? MnDocFq : MxDocFq-3;
303      DocIdV.Gen(DocIdFqH.Len(), 0);
304      int DocIdP=DocIdFqH.FFirstKeyId();
305      while (DocIdFqH.FNextKeyId(DocIdP)){
306        int DocId=DocIdFqH.GetKey(DocIdP);
307        int DocFq=DocIdFqH[DocIdP];
308        if (DocFq>=NewMnDocFq){DocIdV.Add(DocId);}
309      }
310    }
311  }
312  void TYInvIx::SaveTxt(const PSOut& SOut, const PYBs& YBs){
313    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
314    int WordIdToFirstDocIdNP=WordIdToFirstDocIdNH.FFirstKeyId();
315    while (WordIdToFirstDocIdNH.FNextKeyId(WordIdToFirstDocIdNP)){
316      int WordId=WordIdToFirstDocIdNH.GetKey(WordIdToFirstDocIdNP);
317      TStr WordStr;
318      if (YBs.Empty()){WordStr=TInt::GetStr(WordId);}
319      else {WordStr=YBs->GetWordStr(WordId);}
320      Lx.PutStr(WordStr); Lx.PutSym(syColon); Lx.PutSym(syLBracket);
321      int DocIdN=FFirstDocId(WordId); int DocId;
322      while (FNextWordId(DocIdN, DocId)){
323        Lx.PutInt(DocId);}
324      Lx.PutSym(syRBracket); Lx.PutLn();
325    }
326  }
327  bool TYValRet::FNextAttrN(int& AttrP, int& AttrN, TTbVal& AttrVal) const {
328    bool IsFNext; double WordFq; double WordPrb;
329    do {
330      IsFNext=WordDs->FNextWordId(AttrP, AttrN, WordFq, WordPrb);
331      if ((IsFNext)&&(WordPrb>MnWordPrb)){AttrVal=TTbVal(WordFq); return true;}
332    } while (IsFNext);
333    return false;
334  }
335  TMdYBayes::TMdYBayes(
336   const TYNegDsType& _YNegDsType, const TYPriorType& _YPriorType,
337   const PYBs& _YBs, const PYDsBs& _YDsBs,
338   const PYFSelBs& _YFSelBs, const PYInvIx& _YInvIx):
339    TMd(PDmHd(new TYDmHd(_YBs, _YDsBs))),
340    YNegDsType(_YNegDsType), YPriorType(_YPriorType),
341    YBs(_YBs), YDsBs(_YDsBs),
342    YFSelBs(_YFSelBs), YInvIx(_YInvIx),
343    NegWordDs(TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs)){
344    Def();
345  }
346  PMd TMdYBayes::Load(TSIn& SIn){
347    TStr TypeNm(SIn); 
348    IAssert(TypeNm==TTypeNm<TMdYBayes>());
349    TYNegDsType YNegDsType=TYNegDsType(int(TInt(SIn)));
350    TYPriorType YPriorType=TYPriorType(int(TInt(SIn)));
351    PYBs YBs(SIn);
352    PYDsBs YDsBs(SIn);
353    PYFSelBs YFSelBs(SIn);
354    PYInvIx YInvIx(SIn);
355    PYWordDs NegWordDs(SIn); SIn.LoadCs();
356    PMd Md=PMd(new TMdYBayes(
357     YNegDsType, YPriorType, YBs, YDsBs, YFSelBs, YInvIx));
358    return Md;
359  }
360  void TMdYBayes::Save(TSOut& SOut){
361    GetTypeNm(*this).Save(SOut);
362    YNegDsType.Save(SOut); YPriorType.Save(SOut);
363    YBs.Save(SOut);
364    YDsBs.Save(SOut);
365    YFSelBs.Save(SOut);
366    YInvIx.Save(SOut);
367    NegWordDs.Save(SOut);
368    SOut.SaveCs();
369  }
370  PTbValDs TMdYBayes::GetPostrValDs(
371   const PValRet& ValRet, const int& ClassN) const {
372    PYWordDs PosWordDs=YDsBs->GetWordDs(ClassN);
373    PTbValDs PriorValDs=GetPriorValDs(ClassN);
374    TIntFltKdV& WordIdEstKdV=YFSelBs->GetWordIdEstV(ClassN);
375    double LnSumW=log(PriorValDs->GetSumW());
376    PTbValDs ValDs=new TTbValDs(TTbVal::BoolVals);
377    double NegPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::NegVal);
378    double PosPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::PosVal);
379    double NegLnPriorCPrb=0; double NegLnPostrCPrb=0;
380    double PosLnPriorCPrb=0; double PosLnPostrCPrb=0;
381    if (NegPriorCPrb!=0){NegLnPostrCPrb=NegLnPriorCPrb=log(NegPriorCPrb);}
382    if (PosPriorCPrb!=0){PosLnPostrCPrb=PosLnPriorCPrb=log(PosPriorCPrb);}
383    int AttrP=ValRet->FFirstAttrN(); int AttrN; TTbVal AVal;
384    while (ValRet->FNextAttrN(AttrP, AttrN, AVal)){
385      int WordId=AttrN; double WordFq=AVal.GetFlt();
386      if (YFSelBs->IsWordId(WordIdEstKdV, WordId)){
387        if (NegPriorCPrb!=0){
388          double NegAValPrb=NegWordDs->GetWordPrb(WordId);
389          if (NegAValPrb==0){NegLnPostrCPrb+=NegLnPriorCPrb-LnSumW;}
390          else {NegLnPostrCPrb+=log(WordFq*NegAValPrb);}
391        }
392        if (PosPriorCPrb!=0){
393          double PosAValPrb=PosWordDs->GetWordPrb(WordId);
394          if (PosAValPrb==0){PosLnPostrCPrb+=PosLnPriorCPrb-LnSumW;}
395          else {PosLnPostrCPrb+=log(WordFq*PosAValPrb);}
396        }
397      }
398    }
399    if (NegPriorCPrb!=0){ValDs->AddVal(TTbVal::NegVal, NegLnPostrCPrb);}
400    if (PosPriorCPrb!=0){ValDs->AddVal(TTbVal::PosVal, PosLnPostrCPrb);}
401    ValDs->ExpW(); ValDs->Def();
402    return ValDs;
403  }
404  PTbValDs TMdYBayes::GetPostrValDs(
405   const PValRet& ValRet, const int& ClassN, TFltIntKdV& WordPrbIdV) const {
406    WordPrbIdV.Clr();
407    PYWordDs PosWordDs=YDsBs->GetWordDs(ClassN);
408    PTbValDs PriorValDs=GetPriorValDs(ClassN);
409    TIntFltKdV& WordIdEstKdV=YFSelBs->GetWordIdEstV(ClassN);
410    double LnSumW=log(PriorValDs->GetSumW());
411    PTbValDs ValDs=new TTbValDs(TTbVal::BoolVals);
412    double NegPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::NegVal);
413    double PosPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::PosVal);
414    double NegLnPriorCPrb=0; double NegLnPostrCPrb=0;
415    double PosLnPriorCPrb=0; double PosLnPostrCPrb=0;
416    if (NegPriorCPrb!=0){NegLnPostrCPrb=NegLnPriorCPrb=log(NegPriorCPrb);}
417    if (PosPriorCPrb!=0){PosLnPostrCPrb=PosLnPriorCPrb=log(PosPriorCPrb);}
418    int AttrP=ValRet->FFirstAttrN(); int AttrN; TTbVal AVal;
419    while (ValRet->FNextAttrN(AttrP, AttrN, AVal)){
420      int WordId=AttrN; double WordFq=AVal.GetFlt();
421      if (YFSelBs->IsWordId(WordIdEstKdV, WordId)){
422        if (NegPriorCPrb!=0){
423          double NegAValPrb=NegWordDs->GetWordPrb(WordId);
424          if (NegAValPrb==0){NegLnPostrCPrb+=NegLnPriorCPrb-LnSumW;}
425          else {NegLnPostrCPrb+=log(WordFq*NegAValPrb);}
426          if (NegAValPrb!=0){
427            WordPrbIdV.Add(TFltIntKd(-&bsol;*WordFq**/NegAValPrb, WordId));}
428        }
429        if (PosPriorCPrb!=0){
430          double PosAValPrb=PosWordDs->GetWordPrb(WordId);
431          if (PosAValPrb==0){PosLnPostrCPrb+=PosLnPriorCPrb-LnSumW;}
432          else {PosLnPostrCPrb+=log(WordFq*PosAValPrb);}
433          if (PosAValPrb!=0){
434            WordPrbIdV.Add(TFltIntKd(&bsol;*WordFq**/PosAValPrb, WordId));}
435        }
436      }
437    }
438    if (NegPriorCPrb!=0){ValDs->AddVal(TTbVal::NegVal, NegLnPostrCPrb);}
439    if (PosPriorCPrb!=0){ValDs->AddVal(TTbVal::PosVal, PosLnPostrCPrb);}
440    ValDs->ExpW(); ValDs->Def();
441    WordPrbIdV.Sort(false);
442    return ValDs;
443  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.h</h3>
            <pre><code>1  #ifndef yanglib_agmattr1_h
2  #define yanglib_agmattr1_h
3  #include "Snap.h"
4  class TCesnaUtil {
5  public:
6  template<class PGraph>
7  static double GetConductance(const PGraph& Graph, const TIntSet& CmtyS, const int Edges) {
8    const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
9    int Edges2;
10    if (GraphType) { Edges2 = Edges >= 0 ? Edges : Graph->GetEdges(); }
11    else { Edges2 = Edges >= 0 ? 2 * Edges : Graph->GetEdges(); }
12    int Vol = 0,  Cut = 0; 
13    double Phi = 0.0;
14    for (int i = 0; i < CmtyS.Len(); i++) {
15      if (! Graph->IsNode(CmtyS[i])) { continue; }
16      typename PGraph::TObj::TNodeI  NI = Graph->GetNI(CmtyS[i]);
17      for (int e = 0; e < NI.GetOutDeg(); e++) {
18        if (! CmtyS.IsKey(NI.GetOutNId(e))) { Cut += 1; }
19      }
20      Vol += NI.GetOutDeg();
21    }
22    if (Vol != Edges2) {
23      if (2 * Vol > Edges2) { Phi = Cut / double (Edges2 - Vol); }
24      else if (Vol == 0) { Phi = 0.0; }
25      else { Phi = Cut / double(Vol); }
26    } else {
27      if (Vol == Edges2) { Phi = 1.0; }
28    }
29    return Phi;
30  }
31  template<class PGraph>
32    static void GenHoldOutPairs(const PGraph& G, TVec<TIntSet>& HoldOutSet, double HOFrac, TRnd& Rnd)  {
33      TIntPrV EdgeV(G->GetEdges(), 0);
34      for (typename PGraph::TObj::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
35        EdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
36      }
37      EdgeV.Shuffle(Rnd);
38      const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
39      HoldOutSet.Gen(G->GetNodes());
40      int HOTotal = int(HOFrac * G->GetNodes() * (G->GetNodes() - 1) / 2.0);
41      if (GraphType) { HOTotal *= 2;}
42      int HOCnt = 0;
43      int HOEdges = (int) TMath::Round(HOFrac * G->GetEdges());
44      printf("holding out %d edges...\n", HOEdges);
45      for (int he = 0; he < (int) HOEdges; he++) {
46        HoldOutSet[EdgeV[he].Val1].AddKey(EdgeV[he].Val2);
47        if (! GraphType) { HoldOutSet[EdgeV[he].Val2].AddKey(EdgeV[he].Val1); }
48        HOCnt++;
49      }
50      printf("%d Edges hold out\n", HOCnt);
51      while(HOCnt++ < HOTotal) {
52        int SrcNID = Rnd.GetUniDevInt(G->GetNodes());
53        int DstNID = Rnd.GetUniDevInt(G->GetNodes());
54        if (SrcNID == DstNID) { continue; }
55        HoldOutSet[SrcNID].AddKey(DstNID);
56        if (! GraphType) { HoldOutSet[DstNID].AddKey(SrcNID); }
57      }
58    }
59  template<class PGraph>
60    static void GetNbhCom(const PGraph& Graph, const int NID, TIntSet& NBCmtyS) {
61      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NID);
62      NBCmtyS.Gen(NI.GetDeg());
63      NBCmtyS.AddKey(NID);
64      for (int e = 0; e < NI.GetDeg(); e++) {
65        NBCmtyS.AddKey(NI.GetNbrNId(e));
66      }
67    }
68  template<class PGraph>
69    static void GetNIdPhiV(const PGraph& G, TFltIntPrV& NIdPhiV) {
70      NIdPhiV.Gen(G->GetNodes(), 0);
71      const int Edges = G->GetEdges();
72      TExeTm RunTm;
73      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
74        TIntSet NBCmty(NI.GetDeg() + 1);
75        double Phi;
76        if (NI.GetDeg() < 5) { 
77          Phi = 1.0; 
78        } else {
79          TCesnaUtil::GetNbhCom<PGraph>(G, NI.GetId(), NBCmty);
80          Phi = TCesnaUtil::GetConductance(G, NBCmty, Edges);
81        }
82        NIdPhiV.Add(TFltIntPr(Phi, NI.GetId()));
83      }
84      printf("conductance computation completed [%s]\n", RunTm.GetTmStr());
85      fflush(stdout);
86    }
87    static void LoadNIDAttrHFromNIDKH(const TIntV& NIDV, const TStr& InFNm, THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& NodeNameH, const TSsFmt Sep = ssfTabSep) {
88      NIDAttrH.Clr();
89      NIDAttrH.Gen(NIDV.Len());
90      printf("nodes in the graph:%d\n", NIDV.Len());
91      for (int u = 0; u < NIDV.Len(); u++) { NIDAttrH.AddDat(NIDV[u]).Gen(0, 0); }
92      TSsParser Ss(InFNm, ssfTabSep);
93      while (Ss.Next()) {
94        TStr NodeName = Ss.GetFld(0);
95        TInt NID = NodeName.GetInt();
96        if (NodeNameH.Len() > 0 && ! NodeNameH.IsKey(NodeName)) { continue; }
97        if (NodeNameH.Len() > 0) { 
98          IAssertR(NodeNameH.IsKey(NodeName), TStr::Fmt("NodeName:%s", NodeName.CStr())); 
99          NID = NodeNameH.GetKeyId(NodeName);
100        }
101        if (! NIDAttrH.IsKey(NID)) { 
102          continue; } 
103        IAssertR(! NIDAttrH.GetDat(NID).IsIn(Ss.GetInt(1)), TStr::Fmt("NIdx:%d NID:%s, K:%d", NID.Val, NodeName.CStr(), Ss.GetInt(1)));
104        NIDAttrH.GetDat(NID).Add(Ss.GetInt(1));
105      }
106      printf("%s nodes, %s lines read \n",  TUInt64::GetStr(NIDAttrH.Len()).CStr(), TUInt64::GetStr(Ss.GetLineNo()).CStr());
107    }
108    static void LoadNIDAttrHFromNIDKH(const TIntV& NIDV, const TStr& InFNm, THash<TInt, TIntV>& NIDAttrH) {
109      TStrHash<TInt> TmpH;
110      LoadNIDAttrHFromNIDKH(NIDV, InFNm, NIDAttrH, TmpH);
111    }
112    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH, const TStrHash<TInt>& FeatNameH, const TStrHash<TInt>& NodeNameH) {
113      FILE* F = fopen(FNm.CStr(), "wt");
114      for (int u = 0; u < NIDAttrH.Len(); u++) {
115        int NID = NIDAttrH.GetKey(u);
116        TStr NodeName = NodeNameH.IsKeyId(NID)? NodeNameH.GetKey(NID): TStr::Fmt("%d", NID);
117        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
118          int KID = NIDAttrH[u][k];
119          TStr FeatName = FeatNameH.IsKeyId(KID)? FeatNameH.GetKey(KID): TStr::Fmt("%d", KID);
120          fprintf(F,"%s\t%s\n", NodeName.CStr(), FeatName.CStr());
121        }
122      }
123      fclose(F);
124    }
125    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH, const TStrHash<TInt>& FeatNameH) {
126      TStrHash<TInt> TmpH;
127      DumpNIDAttrHToNIDK(FNm, NIDAttrH, FeatNameH, TmpH);
128    }
129    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH) {
130      TStrHash<TInt> TmpH1, TmpH2;
131      DumpNIDAttrHToNIDK(FNm, NIDAttrH, TmpH1, TmpH2);
132    }
133    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& FeatNameH, const TStrHash<TInt>& NodeNameH) {
134      FILE* F = fopen(FNm.CStr(), "wt");
135      for (int u = 0; u < NIDAttrH.Len(); u++) {
136        int NID = NIDAttrH.GetKey(u);
137        TStr NodeName = NodeNameH.IsKeyId(NID)? NodeNameH.GetKey(NID): TStr::Fmt("%d", NID);
138        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
139          int KID = NIDAttrH[u][k];
140          TStr FeatName = FeatNameH.IsKeyId(KID)? FeatNameH.GetKey(KID): TStr::Fmt("%d", KID);
141          fprintf(F,"%s\t%s\n", NodeName.CStr(), FeatName.CStr());
142        }
143      }
144      fclose(F);
145    }
146    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& FeatNameH) {
147      TStrHash<TInt> TmpH;
148      DumpNIDAttrHToNIDK(FNm, NIDAttrH, FeatNameH, TmpH);
149    }
150    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH) {
151      TStrHash<TInt> TmpH1, TmpH2;
152      DumpNIDAttrHToNIDK(FNm, NIDAttrH, TmpH1, TmpH2);
153    }
154    static int GetAttrs(const THash<TInt, TIntV>& NIDAttrH) {
155      int Attrs = 0;
156      for (int u = 0; u < NIDAttrH.Len(); u++) {
157        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
158          if (NIDAttrH[u][k] >= Attrs) { Attrs = NIDAttrH[u][k] + 1; }
159        }
160      }
161      return Attrs;
162    }
163    static void DumpNIDAttrHToMetis(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TIntV& NIDV) {
164      int AttrCnt = 0;
165      for (int u = 1; u < NIDV.Len(); u++) {
166        if (! NIDAttrH.IsKey(NIDV[u])) { continue; }
167        AttrCnt += NIDAttrH.GetDat(NIDV[u]).Len();
168      }
169      IAssert (NIDV[0] == -1);
170      FILE* F = fopen(FNm.CStr(), "wt");
171      fprintf(F, "%d %d\n", NIDV.Len() - 1, AttrCnt);
172      int TmpCnt = 0;
173      for (int u = 1; u < NIDV.Len(); u++) {
174        if (NIDAttrH.IsKey(NIDV[u])) {  
175          for (int k = 0; k < NIDAttrH.GetDat(NIDV[u]).Len(); k++) {
176            if (k > 0) { fprintf(F, " "); }
177            fprintf(F, "%d", NIDAttrH.GetDat(NIDV[u])[k].Val + 1);
178            TmpCnt++;
179          }
180        }
181        fprintf(F, "\n");
182      }
183      fclose(F);
184      IAssert(AttrCnt == TmpCnt);
185    }
186    static void FilterLowEntropy(const THash<TInt, TIntV>& OldNIDAttrH, THash<TInt, TIntV>& NewNIDAttrH, const TIntStrH& OldNameH, TIntStrH& NewNameH, const double MinFrac = 0.00001, const double MaxFrac = 0.95, const int MinCnt = 3) {
187      TIntH KIDCntH;
188      for (int u = 0; u < OldNIDAttrH.Len(); u++) {
189        for (int k = 0; k < OldNIDAttrH[u].Len(); k++) {
190          KIDCntH.AddDat(OldNIDAttrH[u][k])++;
191        }
192      }
193      KIDCntH.SortByDat(false);
194      TIntSet SelectedK(KIDCntH.Len());
195      for (int c = 0; c < KIDCntH.Len(); c++) {
196        double Frac = (double) KIDCntH[c].Val / (double) OldNIDAttrH.Len();
197        if (KIDCntH[c].Val < MinCnt) { continue; }
198        if (Frac > MaxFrac || Frac < MinFrac) { continue; }
199        SelectedK.AddKey(KIDCntH.GetKey(c));
200      }
201      printf("%d attributes selected from %d\n", SelectedK.Len(), KIDCntH.Len());
202      NewNIDAttrH.Gen(OldNIDAttrH.Len());
203      for (int u = 0; u < OldNIDAttrH.Len(); u++) {
204        int NID = OldNIDAttrH.GetKey(u);
205        TIntV& AttrV = NewNIDAttrH.AddDat(NID);
206        for (int k = 0; k < OldNIDAttrH[u].Len(); k++) {
207          if (! SelectedK.IsKey(OldNIDAttrH[u][k])) { continue; }
208          AttrV.Add(SelectedK.GetKeyId(OldNIDAttrH[u][k]));
209        }
210      }
211      if (! OldNameH.Empty()) {
212        NewNameH.Gen(SelectedK.Len());
213        for (int k = 0; k < SelectedK.Len(); k++) {
214          int OldKID = SelectedK.GetKey(k);
215          if (OldNameH.IsKey(OldKID)) {
216            NewNameH.AddDat(k, OldNameH.GetDat(OldKID));
217          }
218        }
219        printf("%d attributes names copied\n", NewNameH.Len());
220      }
221    }
222    static void FilterLowEntropy(const THash<TInt, TIntV>& OldNIDAttrH, THash<TInt, TIntV>& NewNIDAttrH, const double MinFrac = 0.00001, const double MaxFrac = 0.95, const int MinCnt = 3) {
223      TIntStrH TmpH1, TmpH2;
224      FilterLowEntropy(OldNIDAttrH, NewNIDAttrH, TmpH1, TmpH2, MinFrac, MaxFrac, MinCnt);
225    }
226  };
227  class TCesna { 
228  private:
229    PUNGraph G; 
230    TVec<TIntSet> X; 
231    TVec<TIntFltH> F; 
232    TVec<TFltV> W; 
233    TInt Attrs; 
234    TRnd Rnd; 
235    TIntSet NIDToIdx; 
236    TFlt RegCoef; 
237    TFltV SumFV; 
238    TInt NumComs; 
239    TVec<TIntSet> HOVIDSV; 
240    TVec<TIntSet> HOKIDSV; 
241  public:
242    TFlt MinVal; 
243    TFlt MaxVal; 
244    TFlt MinValW; 
245    TFlt MaxValW; 
246    TFlt NegWgt; 
247    TFlt LassoCoef; 
248    TFlt WeightAttr; 
249    TFlt PNoCom; 
250    TBool DoParallel; 
251    TCesna() { G = TUNGraph::New(10, -1); }
252    TCesna(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH, const int& InitComs, const int RndSeed = 0): Rnd(RndSeed), RegCoef(0), 
253      MinVal(0.0), MaxVal(10.0), MinValW(-10.0), MaxValW(10.0), NegWgt(1.0), LassoCoef(1.0), WeightAttr(1.0) { SetGraph(GraphPt, NIDAttrH); NeighborComInit(InitComs); }
254    void Save(TSOut& SOut) {
255      G->Save(SOut);
256      X.Save(SOut);
257      F.Save(SOut);
258      W.Save(SOut);
259      Attrs.Save(SOut);
260      NIDToIdx.Save(SOut);
261      RegCoef.Save(SOut);
262      LassoCoef.Save(SOut);
263      SumFV.Save(SOut);
264      NumComs.Save(SOut);
265      HOVIDSV.Save(SOut);
266      HOKIDSV.Save(SOut);
267      MinVal.Save(SOut);
268      MaxVal.Save(SOut);
269      MinValW.Save(SOut);
270      MaxValW.Save(SOut);
271      NegWgt.Save(SOut);
272      PNoCom.Save(SOut);
273    }
274    void Load(TSIn& SIn, const int& RndSeed = 0) {
275      G->Load(SIn);
276      X.Load(SIn);
277      F.Load(SIn);
278      W.Load(SIn);
279      Attrs.Load(SIn);
280      NIDToIdx.Load(SIn);
281      RegCoef.Load(SIn);
282      LassoCoef.Load(SIn);
283      SumFV.Load(SIn);
284      NumComs.Load(SIn);
285      HOVIDSV.Load(SIn);
286      HOKIDSV.Load(SIn);
287      MinVal.Load(SIn);
288      MaxVal.Load(SIn);
289      MinValW.Load(SIn);
290      MaxValW.Load(SIn);
291      NegWgt.Load(SIn);
292      PNoCom.Load(SIn);
293    }
294    void SetGraph(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH);
295    void SetRegCoef(const double _RegCoef) { RegCoef = _RegCoef; }
296    double GetRegCoef() { return RegCoef; }
297    void SetWeightAttr(const double _WeightAttr) { IAssert (_WeightAttr <= 1.0 && _WeightAttr >= 0.0); WeightAttr = _WeightAttr; }
298    double GetWeightAttr() { return WeightAttr; }
299    void SetLassoCoef(const double _LassoCoef) { LassoCoef = _LassoCoef; }
300    int GetAttrs() { return Attrs; }
301    double GetComFromNID(const int& NID, const int& CID) {
302      int NIdx = NIDToIdx.GetKeyId(NID);
303      if (F[NIdx].IsKey(CID)) {
304        return F[NIdx].GetDat(CID);
305      } else {
306        return 0.0;
307      }
308    }
309    double GetLassoCoef() { return LassoCoef; }
310    void InitW() { 
311      W.Gen(Attrs);
312      for (int k = 0; k < Attrs; k++) {
313        W[k].Gen(NumComs + 1);
314      }
315    }
316    void SetAttrHoldOut(const int NID, const int KID) {
317      int NIdx = NIDToIdx.GetKeyId(NID);
318      HOKIDSV[NIdx].AddKey(KID);
319    }
320    void SetAttrHoldOutForOneNode(const int NID) {
321      for (int k = 0; k < Attrs; k++) {
322        SetAttrHoldOut(NID, k);
323      }
324    }
325    void GetW(TVec<TFltV>& _W) { _W = W; }
326    void SetW(TVec<TFltV>& _W) { W = _W; }
327    void RandomInit(const int InitComs);
328    void NeighborComInit(const int InitComs);
329    void NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs);
330    int GetNumComs() { return NumComs; }
331    void SetCmtyVV(const TVec<TIntV>& CmtyVV);
332    double Likelihood(const bool DoParallel = false);
333    double LikelihoodForRow(const int UID);
334    double LikelihoodForRow(const int UID, const TIntFltH& FU);
335    double LikelihoodAttrKForRow(const int UID, const int K) { return LikelihoodAttrKForRow(UID, K, F[UID]); }
336    double LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU) { return LikelihoodAttrKForRow(UID, K, FU, W[K]); }
337    double LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU, const TFltV& WK);
338    double LikelihoodForWK(const int K, const TFltV& WK) {
339      double L = 0.0;
340      for (int u = 0; u < F.Len(); u++) {
341        if (HOKIDSV[u].IsKey(K)) { continue; }
342        L += LikelihoodAttrKForRow(u, K, F[u], WK);
343      }
344      for (int c = 0; c < WK.Len() - 1; c++) {
345        L -= LassoCoef * fabs(WK[c]);
346      } 
347      return L;
348    }
349    double LikelihoodForWK(const int K) { return LikelihoodForWK(K, W[K]); }
350    double LikelihoodAttr() {
351      double L = 0.0;
352      for (int k = 0; k < Attrs; k++) {
353        for (int u = 0; u < F.Len(); u++) {
354          if (HOKIDSV[u].IsKey(k)) { continue; }
355          L += LikelihoodAttrKForRow(u, k, F[u], W[k]);
356        }
357      }
358      return L;
359    }
360    double LikelihoodGraph() {
361      double L = Likelihood();
362      if (RegCoef > 0.0) { 
363        for (int u = 0; u < F.Len(); u++) {
364          L += RegCoef * Sum(F[u]);
365        }
366      }
367      if (RegCoef < 0.0) { 
368        for (int u = 0; u < F.Len(); u++) {
369          L -= RegCoef * Norm2(F[u]);
370        }
371      }
372      return L - WeightAttr * LikelihoodAttr();
373    }
374    void GenHoldOutAttr(const double HOFrac, TVec<TIntSet>& HOSetV) {
375      HOSetV.Gen(F.Len());
376      int HoldOutCnt = (int) ceil(HOFrac * G->GetNodes() * Attrs);
377      TIntPrSet NIDKIDSet(HoldOutCnt);
378      int Cnt = 0;
379      for (int h = 0; h < 10 * HoldOutCnt; h++) {
380        int UID = Rnd.GetUniDevInt(F.Len());
381        int KID = Rnd.GetUniDevInt(Attrs);
382        if (! NIDKIDSet.IsKey(TIntPr(UID, KID))) { 
383          NIDKIDSet.AddKey(TIntPr(UID, KID)); 
384          HOSetV[UID].AddKey(KID);
385          Cnt++;
386        }
387        if (Cnt >= HoldOutCnt) { break; }
388      }
389      printf("%d hold out pairs generated for attributes\n", Cnt);
390    }
391    void SetHoldOut(const double HOFrac) { 
392      TVec<TIntSet> HoldOut; 
393      TCesnaUtil::GenHoldOutPairs(G, HoldOut, HOFrac, Rnd); 
394      GenHoldOutAttr(HOFrac, HOKIDSV);
395      HOVIDSV = HoldOut; 
396    }
397    void GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet);
398    void GradientForWK(TFltV& GradV, const int K) {
399      GradV.Gen(NumComs + 1);
400      for (int u = 0; u < F.Len(); u++) {
401        if (HOKIDSV[u].IsKey(K)) { continue; }
402        double Pred = PredictAttrK(u, K);
403        for (TIntFltH::TIter CI = F[u].BegI(); CI < F[u].EndI(); CI++) { 
404          GradV[CI.GetKey()] += (GetAttr(u, K) - Pred) * GetCom(u, CI.GetKey());
405        }
406        GradV[NumComs] += (GetAttr(u, K) - Pred);
407      }
408      for (int c = 0; c < GradV.Len() - 1; c++) {
409        GradV[c] -= LassoCoef * TMath::Sign(GetW(c, K));
410      }
411    }
412    void GetCmtyVV(TVec<TIntV>& CmtyVV);
413    void GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck, const double Thres, const int MinSz = 3);
414    void GetCmtyVV(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3) {
415      TVec<TFltV> TmpV;
416      GetCmtyVV(CmtyVV, TmpV, Thres, MinSz); 
417    }
418    void GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck) {
419      GetCmtyVV(CmtyVV, Wck, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
420    }
421    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV);
422    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
423    int FindComs(TIntV& ComsV, const bool UseBIC = false, const double HOFrac = 0.2, const int NumThreads = 20, const TStr PlotLFNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1);
424    int FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC = false, const double HOFrac = 0.1, const double StepAlpha = 0.3, const double StepBeta = 0.3);
425    void DisplayAttrs(const int TopK, const TStrHash<TInt>& NodeNameH) {
426      for (int u = 0; u < X.Len(); u++) {
427        if (NodeNameH.Len() > 0) {
428          printf("NID: %s\t Attrs: ", NodeNameH.GetKey(NIDToIdx[u]));
429        } else {
430          printf("NID: %d\t Attrs: ", NIDToIdx[u].Val);
431        }
432        for (int k = 0; k < X[u].Len(); k++) {
433          printf("%d, ", X[u][k].Val);
434        }
435        printf("\n");
436        if (u >= TopK) { break; }
437      }
438    }
439    double LikelihoodHoldOut();
440    double GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10);
441    double GetStepSizeByLineSearchForWK(const int K, const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10) {
442      double StepSize = 1.0;
443      double InitLikelihood = LikelihoodForWK(K);
444      TFltV NewVarV(DeltaV.Len());
445      IAssert(DeltaV.Len() == NumComs + 1);
446      for(int iter = 0; iter < MaxIter; iter++) {
447        for (int c = 0; c < DeltaV.Len(); c++){
<span onclick='openModal()' class='match'>448          double NewVal = W[K][c] + StepSize * DeltaV[c];
449          if (NewVal < MinValW) { NewVal = MinValW; }
450          if (NewVal > MaxValW) { NewVal = MaxValW; }
</span>451          NewVarV[c] = NewVal;
452        }
453        if (LikelihoodForWK(K, NewVarV) < InitLikelihood + Alpha * StepSize * TLinAlg::DotProduct(GradV, DeltaV)) {
454          StepSize *= Beta;
455        } else {
456          break;
457        }
458        if (iter == MaxIter - 1) { 
459          StepSize = 0.0;
460          break;
461        }
462      }
463      return StepSize;
464    }
465    int GetPositiveW() {
466      int PosCnt = 0;
467      for (int c = 0; c < NumComs; c++) {
468        for (int k = 0; k < Attrs; k++) {
469          if (GetW(c, k) > 0.0) { PosCnt++; }
470        }
471      }
472      return PosCnt;
473    }
474    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
475    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
476    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const TStr PlotNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1) {
477      int ChunkSize = G->GetNodes() / 10 / ChunkNum;
478      if (ChunkSize == 0) { ChunkSize = 1; }
479      return MLEGradAscentParallel(Thres, MaxIter, ChunkNum, ChunkSize, PlotNm, StepAlpha, StepBeta);
480    }
481    double inline GetCom(const int& NID, const int& CID) {
482      if (F[NID].IsKey(CID)) {
483        return F[NID].GetDat(CID);
484      } else {
485        return 0.0;
486      }
487    }
488    double inline GetAttr(const int& NID, const int& K) {
489      if (X[NID].IsKey(K)) {
490        return 1.0;
491      } else {
492        return 0.0;
493      }
494    }
495    void inline AddCom(const int& NID, const int& CID, const double& Val) {
496      if (F[NID].IsKey(CID)) {
497        SumFV[CID] -= F[NID].GetDat(CID);
498      }
499      F[NID].AddDat(CID) = Val;
500      SumFV[CID] += Val;
501    }
502    void inline DelCom(const int& NID, const int& CID) {
503      if (F[NID].IsKey(CID)) {
504        SumFV[CID] -= F[NID].GetDat(CID);
505        F[NID].DelKey(CID);
506      }
507    }
508    double inline DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
509      double DP = 0;
510      if (UV.Len() > VV.Len()) {
511        for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
512          if (VV.IsKey(HI.GetKey())) { 
513            DP += VV.GetDat(HI.GetKey()) * HI.GetDat(); 
514          }
515        }
516      } else {
517        for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
518          if (UV.IsKey(HI.GetKey())) { 
519            DP += UV.GetDat(HI.GetKey()) * HI.GetDat(); 
520          }
521        }
522      }
523      return DP;
524    }
525    double inline DotProduct(const int& UID, const int& VID) {
526      return DotProduct(F[UID], F[VID]);
527    }
528    double inline Prediction(const TIntFltH& FU, const TIntFltH& FV) {
529      double DP = log (1.0 / (1.0 - PNoCom)) + DotProduct(FU, FV);
530      IAssertR(DP > 0.0, TStr::Fmt("DP: %f", DP));
531      return exp(- DP);
532    }
533    double inline PredictAttrK(const TIntFltH& FU, const TFltV& WK) {
534      double DP = 0.0;
535      for (TIntFltH::TIter FI = FU.BegI(); FI < FU.EndI(); FI++) {
536        DP += FI.GetDat() * WK[FI.GetKey()];
537      }
538      DP += WK.Last();
539      return Sigmoid(DP);
540    }
541    double inline PredictAttrK(const TIntFltH& FU, const int K) {
542      return PredictAttrK(FU, W[K]);
543    }
544    double inline PredictAttrK(const int UID, const int K) {
545      return PredictAttrK(F[UID], W[K]);
546    }
547    double inline GetW(const int CID, const int K) {
548      return W[K][CID];
549    }
550    double inline Prediction(const int& UID, const int& VID) {
551      return Prediction(F[UID], F[VID]);
552    }
553    double inline Sum(const TIntFltH& UV) {
554      double N = 0.0;
555      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
556        N += HI.GetDat();
557      }
558      return N;
559    }
560    double inline Norm2(const TIntFltH& UV) {
561      double N = 0.0;
562      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
563        N += HI.GetDat() * HI.GetDat();
564      }
565      return N;
566    }
567    double inline Sigmoid(const double X) {
568      return 1.0 / ( 1.0 + exp(-X));
569    }
570  };
571  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoodm.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.h</div>
                </div>
                <div class="column column_space"><pre><code>151            double S1C1Prb=PosWordDs->GetWordPrb(WordId);
152            if (S1C0Prb==0){S1C0Prb=1/sqr(PriorSumW);}
153            if (S1C0Prb==1){S1C0Prb=1-(1/sqr(PriorSumW));}
</pre></code></div>
                <div class="column column_space"><pre><code>448          double NewVal = W[K][c] + StepSize * DeltaV[c];
449          if (NewVal < MinValW) { NewVal = MinValW; }
450          if (NewVal > MaxValW) { NewVal = MaxValW; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    