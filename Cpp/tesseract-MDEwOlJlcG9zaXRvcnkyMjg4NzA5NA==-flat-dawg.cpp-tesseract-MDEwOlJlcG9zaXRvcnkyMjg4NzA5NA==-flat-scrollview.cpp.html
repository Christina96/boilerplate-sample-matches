
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.891566265060241%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dawg.cpp</h3>
            <pre><code>1  #include "dawg.h"
2  #include "dict.h"
3  #include "helpers.h"
4  #include "tprintf.h"
5  #include <memory>
6  namespace tesseract {
7  Dawg::~Dawg() = default;
8  bool Dawg::prefix_in_dawg(const WERD_CHOICE &word,
9                            bool requires_complete) const {
10    if (word.empty()) {
11      return !requires_complete;
12    }
13    NODE_REF node = 0;
14    int end_index = word.length() - 1;
15    for (int i = 0; i < end_index; i++) {
16      EDGE_REF edge = edge_char_of(node, word.unichar_id(i), false);
17      if (edge == NO_EDGE) {
18        return false;
19      }
20      if ((node = next_node(edge)) == 0) {
21        return false;
22      }
23    }
24    return edge_char_of(node, word.unichar_id(end_index), requires_complete) !=
25           NO_EDGE;
26  }
27  bool Dawg::word_in_dawg(const WERD_CHOICE &word) const {
28    return prefix_in_dawg(word, true);
29  }
30  int Dawg::check_for_words(const char *filename, const UNICHARSET &unicharset,
31                            bool enable_wildcard) const {
32    if (filename == nullptr) {
33      return 0;
34    }
35    FILE *word_file;
36    char string[CHARS_PER_LINE];
37    int misses = 0;
38    UNICHAR_ID wildcard = unicharset.unichar_to_id(kWildcard);
39    word_file = fopen(filename, "r");
40    if (word_file == nullptr) {
41      tprintf("Error: Could not open file %s\n", filename);
42      ASSERT_HOST(word_file);
43    }
44    while (fgets(string, CHARS_PER_LINE, word_file) != nullptr) {
45      chomp_string(string); 
46      WERD_CHOICE word(string, unicharset);
47      if (word.length() > 0 && !word.contains_unichar_id(INVALID_UNICHAR_ID)) {
48        if (!match_words(&word, 0, 0,
49                         enable_wildcard ? wildcard : INVALID_UNICHAR_ID)) {
50          tprintf("Missing word: %s\n", string);
51          ++misses;
52        }
53      } else {
54        tprintf("Failed to create a valid word from %s\n", string);
55      }
56    }
57    fclose(word_file);
58    if (debug_level_) {
59      tprintf("Number of lost words=%d\n", misses);
60    }
61    return misses;
62  }
63  void Dawg::iterate_words(const UNICHARSET &unicharset,
64                           std::function<void(const WERD_CHOICE *)> cb) const {
65    WERD_CHOICE word(&unicharset);
66    iterate_words_rec(word, 0, cb);
67  }
68  static void CallWithUTF8(const std::function<void(const char *)> &cb,
69                           const WERD_CHOICE *wc) {
70    std::string s;
71    wc->string_and_lengths(&s, nullptr);
72    cb(s.c_str());
73  }
74  void Dawg::iterate_words(const UNICHARSET &unicharset,
75                           const std::function<void(const char *)> &cb) const {
76    using namespace std::placeholders; 
77    std::function<void(const WERD_CHOICE *)> shim(
78        std::bind(CallWithUTF8, cb, _1));
79    WERD_CHOICE word(&unicharset);
80    iterate_words_rec(word, 0, shim);
81  }
82  void Dawg::iterate_words_rec(
83      const WERD_CHOICE &word_so_far, NODE_REF to_explore,
84      const std::function<void(const WERD_CHOICE *)> &cb) const {
85    NodeChildVector children;
86    this->unichar_ids_of(to_explore, &children, false);
87    for (auto &i : children) {
88      WERD_CHOICE next_word(word_so_far);
89      next_word.append_unichar_id(i.unichar_id, 1, 0.0, 0.0);
90      if (this->end_of_word(i.edge_ref)) {
91        cb(&next_word);
92      }
93      NODE_REF next = next_node(i.edge_ref);
94      if (next != 0) {
95        iterate_words_rec(next_word, next, cb);
96      }
97    }
98  }
99  bool Dawg::match_words(WERD_CHOICE *word, uint32_t index, NODE_REF node,
100                         UNICHAR_ID wildcard) const {
101    if (wildcard != INVALID_UNICHAR_ID && word->unichar_id(index) == wildcard) {
102      bool any_matched = false;
103      NodeChildVector vec;
104      this->unichar_ids_of(node, &vec, false);
105      for (auto &i : vec) {
106        word->set_unichar_id(i.unichar_id, index);
107        if (match_words(word, index, node, wildcard)) {
108          any_matched = true;
109        }
110      }
111      word->set_unichar_id(wildcard, index);
112      return any_matched;
113    } else {
114      auto word_end = index == word->length() - 1;
115      auto edge = edge_char_of(node, word->unichar_id(index), word_end);
116      if (edge != NO_EDGE) { 
117        node = next_node(edge);
118        if (word_end) {
119          if (debug_level_ > 1) {
120            word->print("match_words() found: ");
121          }
122          return true;
123        } else if (node != 0) {
124          return match_words(word, index + 1, node, wildcard);
125        }
126      }
127    }
128    return false;
129  }
130  void Dawg::init(int unicharset_size) {
131    ASSERT_HOST(unicharset_size > 0);
132    unicharset_size_ = unicharset_size;
133    flag_start_bit_ = ceil(log(unicharset_size_ + 1.0) / log(2.0));
134    next_node_start_bit_ = flag_start_bit_ + NUM_FLAG_BITS;
135    letter_mask_ = ~(~0ull << flag_start_bit_);
136    next_node_mask_ = ~0ull << (flag_start_bit_ + NUM_FLAG_BITS);
137    flags_mask_ = ~(letter_mask_ | next_node_mask_);
138  }
139  SquishedDawg::~SquishedDawg() {
140    delete[] edges_;
141  }
142  EDGE_REF SquishedDawg::edge_char_of(NODE_REF node, UNICHAR_ID unichar_id,
143                                      bool word_end) const {
144    EDGE_REF edge = node;
145    if (node == 0) { 
146      EDGE_REF start = 0;
147      EDGE_REF end = num_forward_edges_in_node0 - 1;
148      int compare;
149      while (start <= end) {
150        edge = (start + end) >> 1; 
151        compare = given_greater_than_edge_rec(NO_EDGE, word_end, unichar_id,
152                                              edges_[edge]);
153        if (compare == 0) { 
154          return edge;
<span onclick='openModal()' class='match'>155        } else if (compare == 1) { 
156          start = edge + 1;
157        } else { 
158          end = edge - 1;
159        }
160      }
</span>161    } else { 
162      if (edge != NO_EDGE && edge_occupied(edge)) {
163        do {
164          if ((unichar_id_from_edge_rec(edges_[edge]) == unichar_id) &&
165              (!word_end || end_of_word_from_edge_rec(edges_[edge]))) {
166            return (edge);
167          }
168        } while (!last_edge(edge++));
169      }
170    }
171    return (NO_EDGE); 
172  }
173  int32_t SquishedDawg::num_forward_edges(NODE_REF node) const {
174    EDGE_REF edge = node;
175    int32_t num = 0;
176    if (forward_edge(edge)) {
177      do {
178        num++;
179      } while (!last_edge(edge++));
180    }
181    return (num);
182  }
183  void SquishedDawg::print_node(NODE_REF node, int max_num_edges) const {
184    if (node == NO_EDGE) {
185      return; 
186    }
187    EDGE_REF edge = node;
188    const char *forward_string = "FORWARD";
189    const char *backward_string = "       ";
190    const char *last_string = "LAST";
191    const char *not_last_string = "    ";
192    const char *eow_string = "EOW";
193    const char *not_eow_string = "   ";
194    const char *direction;
195    const char *is_last;
196    const char *eow;
197    UNICHAR_ID unichar_id;
198    if (edge_occupied(edge)) {
199      do {
200        direction = forward_edge(edge) ? forward_string : backward_string;
201        is_last = last_edge(edge) ? last_string : not_last_string;
202        eow = end_of_word(edge) ? eow_string : not_eow_string;
203        unichar_id = edge_letter(edge);
204        tprintf(REFFORMAT " : next = " REFFORMAT ", unichar_id = %d, %s %s %s\n",
205                edge, next_node(edge), unichar_id, direction, is_last, eow);
206        if (edge - node > max_num_edges) {
207          return;
208        }
209      } while (!last_edge(edge++));
210      if (edge < num_edges_ && edge_occupied(edge) && backward_edge(edge)) {
211        do {
212          direction = forward_edge(edge) ? forward_string : backward_string;
213          is_last = last_edge(edge) ? last_string : not_last_string;
214          eow = end_of_word(edge) ? eow_string : not_eow_string;
215          unichar_id = edge_letter(edge);
216          tprintf(REFFORMAT " : next = " REFFORMAT
217                            ", unichar_id = %d, %s %s %s\n",
218                  edge, next_node(edge), unichar_id, direction, is_last, eow);
219          if (edge - node > MAX_NODE_EDGES_DISPLAY) {
220            return;
221          }
222        } while (!last_edge(edge++));
223      }
224    } else {
225      tprintf(REFFORMAT " : no edges in this node\n", node);
226    }
227    tprintf("\n");
228  }
229  void SquishedDawg::print_edge(EDGE_REF edge) const {
230    if (edge == NO_EDGE) {
231      tprintf("NO_EDGE\n");
232    } else {
233      tprintf(REFFORMAT " : next = " REFFORMAT ", unichar_id = '%d', %s %s %s\n",
234              edge, next_node(edge), edge_letter(edge),
235              (forward_edge(edge) ? "FORWARD" : "       "),
236              (last_edge(edge) ? "LAST" : "    "),
237              (end_of_word(edge) ? "EOW" : ""));
238    }
239  }
240  bool SquishedDawg::read_squished_dawg(TFile *file) {
241    if (debug_level_) {
242      tprintf("Reading squished dawg\n");
243    }
244    int16_t magic;
245    if (!file->DeSerialize(&magic)) {
246      return false;
247    }
248    if (magic != kDawgMagicNumber) {
249      tprintf("Bad magic number on dawg: %d vs %d\n", magic, kDawgMagicNumber);
250      return false;
251    }
252    int32_t unicharset_size;
253    if (!file->DeSerialize(&unicharset_size)) {
254      return false;
255    }
256    if (!file->DeSerialize(&num_edges_)) {
257      return false;
258    }
259    ASSERT_HOST(num_edges_ > 0); 
260    Dawg::init(unicharset_size);
261    edges_ = new EDGE_RECORD[num_edges_];
262    if (!file->DeSerialize(&edges_[0], num_edges_)) {
263      return false;
264    }
265    if (debug_level_ > 2) {
266      tprintf("type: %d lang: %s perm: %d unicharset_size: %d num_edges: %d\n",
267              type_, lang_.c_str(), perm_, unicharset_size_, num_edges_);
268      for (EDGE_REF edge = 0; edge < num_edges_; ++edge) {
269        print_edge(edge);
270      }
271    }
272    return true;
273  }
274  std::unique_ptr<EDGE_REF[]> SquishedDawg::build_node_map(
275      int32_t *num_nodes) const {
276    EDGE_REF edge;
277    std::unique_ptr<EDGE_REF[]> node_map(new EDGE_REF[num_edges_]);
278    int32_t node_counter;
279    int32_t num_edges;
280    for (edge = 0; edge < num_edges_; edge++) { 
281      node_map[edge] = -1;
282    }
283    node_counter = num_forward_edges(0);
284    *num_nodes = 0;
285    for (edge = 0; edge < num_edges_; edge++) { 
286      if (forward_edge(edge)) {
287        (*num_nodes)++; 
288        node_map[edge] = (edge ? node_counter : 0);
289        num_edges = num_forward_edges(edge);
290        if (edge != 0) {
291          node_counter += num_edges;
292        }
293        edge += num_edges;
294        if (edge >= num_edges_) {
295          break;
296        }
297        if (backward_edge(edge)) {
298          while (!last_edge(edge++)) {
299            ;
300          }
301        }
302        edge--;
303      }
304    }
305    return node_map;
306  }
307  bool SquishedDawg::write_squished_dawg(TFile *file) {
308    EDGE_REF edge;
309    int32_t num_edges;
310    int32_t node_count = 0;
311    EDGE_REF old_index;
312    EDGE_RECORD temp_record;
313    if (debug_level_) {
314      tprintf("write_squished_dawg\n");
315    }
316    std::unique_ptr<EDGE_REF[]> node_map(build_node_map(&node_count));
317    int16_t magic = kDawgMagicNumber;
318    if (!file->Serialize(&magic)) {
319      return false;
320    }
321    if (!file->Serialize(&unicharset_size_)) {
322      return false;
323    }
324    num_edges = 0;
325    for (edge = 0; edge < num_edges_; edge++) {
326      if (forward_edge(edge)) {
327        num_edges++;
328      }
329    }
330    if (!file->Serialize(&num_edges)) {
331      return false;
332    }
333    if (debug_level_) {
334      tprintf("%d nodes in DAWG\n", node_count);
335      tprintf("%d edges in DAWG\n", num_edges);
336    }
337    for (edge = 0; edge < num_edges_; edge++) {
338      if (forward_edge(edge)) { 
339        do {
340          old_index = next_node_from_edge_rec(edges_[edge]);
341          set_next_node(edge, node_map[old_index]);
342          temp_record = edges_[edge];
343          if (!file->Serialize(&temp_record)) {
344            return false;
345          }
346          set_next_node(edge, old_index);
347        } while (!last_edge(edge++));
348        if (edge >= num_edges_) {
349          break;
350        }
351        if (backward_edge(edge)) { 
352          while (!last_edge(edge++)) {
353            ;
354          }
355        }
356        edge--;
357      }
358    }
359    return true;
360  }
361  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scrollview.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "scrollview.h"
5  #include "svutil.h" 
6  #include <allheaders.h>
7  #include <algorithm>
8  #include <climits>
9  #include <cstdarg>
10  #include <cstring>
11  #include <map>
12  #include <memory> 
13  #include <mutex> 
14  #include <string>
15  #include <thread> 
16  #include <utility>
17  #include <vector>
18  namespace tesseract {
19  const int kSvPort = 8461;
20  const int kMaxMsgSize = 4096;
21  const int kMaxIntPairSize = 45; 
22  struct SVPolyLineBuffer {
23    bool empty; 
24    std::vector<int> xcoords;
25    std::vector<int> ycoords;
26  };
27  static std::map<int, ScrollView *> svmap;
28  static std::mutex *svmap_mu;
29  static std::map<std::pair<ScrollView *, SVEventType>,
30                  std::pair<SVSemaphore *, std::unique_ptr<SVEvent>>> waiting_for_events;
31  static std::mutex *waiting_for_events_mu;
32  std::unique_ptr<SVEvent> SVEvent::copy() const {
33    auto any = std::unique_ptr<SVEvent>(new SVEvent);
34    any->command_id = command_id;
35    any->counter = counter;
36    any->parameter = new char[strlen(parameter) + 1];
37    strcpy(any->parameter, parameter);
38    any->type = type;
39    any->x = x;
40    any->y = y;
41    any->x_size = x_size;
42    any->y_size = y_size;
43    any->window = window;
44    return any;
45  }
46  SVEventHandler::~SVEventHandler() = default;
47  #ifndef GRAPHICS_DISABLED
48  void ScrollView::MessageReceiver() {
49    int counter_event_id = 0; 
50    char *message = nullptr;
51    do {
52      message = ScrollView::GetStream()->Receive();
53    } while (message == nullptr);
54    while (true) {
55      std::unique_ptr<SVEvent> cur(new SVEvent);
56      int window_id;
57      int ev_type;
58      int n;
59      sscanf(message, "%d,%d,%d,%d,%d,%d,%d,%n", &window_id, &ev_type, &cur->x, &cur->y, &cur->x_size,
60             &cur->y_size, &cur->command_id, &n);
61      char *p = (message + n);
62      svmap_mu->lock();
63      cur->window = svmap[window_id];
64      if (cur->window != nullptr) {
65        auto length = strlen(p);
66        cur->parameter = new char[length + 1];
67        strcpy(cur->parameter, p);
68        if (length > 0) { 
69          cur->parameter[length - 1] = '\0';
70        }
71        cur->type = static_cast<SVEventType>(ev_type);
72        if (cur->x_size > 0) {
73          cur->x -= cur->x_size;
74        } else {
75          cur->x_size = -cur->x_size;
76        }
77        if (cur->y_size > 0) {
78          cur->y -= cur->y_size;
79        } else {
80          cur->y_size = -cur->y_size;
81        }
82        if (cur->window->y_axis_is_reversed_) {
83          cur->y = cur->window->TranslateYCoordinate(cur->y + cur->y_size);
84        }
85        cur->counter = counter_event_id;
86        counter_event_id += 2;
87        if (ev_type == SVET_EXIT) {
88          SendRawMessage("svmain:exit()");
89          break;
90        }
91        cur->window->SetEvent(cur.get());
92        std::pair<ScrollView *, SVEventType> awaiting_list(cur->window, cur->type);
93        std::pair<ScrollView *, SVEventType> awaiting_list_any(cur->window, SVET_ANY);
94        std::pair<ScrollView *, SVEventType> awaiting_list_any_window((ScrollView *)nullptr,
95                                                                      SVET_ANY);
96        waiting_for_events_mu->lock();
97        if (waiting_for_events.count(awaiting_list) > 0) {
98          waiting_for_events[awaiting_list].second = std::move(cur);
99          waiting_for_events[awaiting_list].first->Signal();
100        } else if (waiting_for_events.count(awaiting_list_any) > 0) {
101          waiting_for_events[awaiting_list_any].second = std::move(cur);
102          waiting_for_events[awaiting_list_any].first->Signal();
103        } else if (waiting_for_events.count(awaiting_list_any_window) > 0) {
104          waiting_for_events[awaiting_list_any_window].second = std::move(cur);
105          waiting_for_events[awaiting_list_any_window].first->Signal();
106        }
107        waiting_for_events_mu->unlock();
108        ScrollView *sv = svmap[window_id];
109        if (sv != nullptr) {
110          sv->Signal();
111          sv->Signal();
112        }
113      }
114      svmap_mu->unlock();
115      do {
116        message = ScrollView::GetStream()->Receive();
117      } while (message == nullptr);
118    }
119  }
120  static const uint8_t table_colors[ScrollView::GREEN_YELLOW + 1][4] = {
121      {0, 0, 0, 0},         
122      {0, 0, 0, 255},       
123      {255, 255, 255, 255}, 
124      {255, 0, 0, 255},     
125      {255, 255, 0, 255},   
126      {0, 255, 0, 255},     
127      {0, 255, 255, 255},   
128      {0, 0, 255, 255},     
129      {255, 0, 255, 255},   
130      {0, 128, 255, 255},   
131      {0, 0, 64, 255},      
132      {128, 128, 255, 255}, 
133      {64, 64, 255, 255},   
134      {0, 0, 32, 255},      
135      {0, 0, 128, 255},     
136      {192, 192, 255, 255}, 
137      {64, 64, 128, 255},   
138      {32, 32, 64, 255},    
139      {255, 128, 128, 255}, 
140      {128, 64, 0, 255},    
141      {128, 128, 0, 255},   
142      {192, 192, 0, 255},   
143      {192, 192, 128, 255}, 
144      {0, 64, 0, 255},      
145      {32, 64, 0, 255},     
146      {64, 128, 0, 255},    
147      {128, 255, 0, 255},   
148      {192, 255, 192, 255}, 
149      {192, 255, 0, 255},   
150      {192, 192, 192, 255}, 
151      {64, 64, 128, 255},   
152      {64, 64, 64, 255},    
153      {128, 128, 128, 255}, 
154      {64, 192, 0, 255},    
155      {255, 0, 192, 255},   
156      {255, 128, 0, 255},   
157      {255, 128, 64, 255},  
158      {255, 192, 192, 255}, 
159      {128, 0, 128, 255},   
160      {255, 0, 64, 255},    
161      {255, 64, 0, 255},    
162      {255, 0, 192, 255},   
163      {255, 192, 128, 255}, 
164      {128, 128, 0, 255},   
165      {0, 255, 255, 255},   
166      {0, 128, 128, 255},   
167      {192, 0, 255, 255},   
168      {128, 128, 0, 255},   
169      {128, 255, 0, 255}    
170  };
171  SVNetwork *ScrollView::stream_ = nullptr;
172  int ScrollView::nr_created_windows_ = 0;
173  int ScrollView::image_index_ = 0;
174  ScrollView::ScrollView(const char *name, int x_pos, int y_pos, int x_size, int y_size,
175                         int x_canvas_size, int y_canvas_size, bool y_axis_reversed,
176                         const char *server_name) {
177    Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size, y_axis_reversed,
178               server_name);
179  }
180  ScrollView::ScrollView(const char *name, int x_pos, int y_pos, int x_size, int y_size,
181                         int x_canvas_size, int y_canvas_size, bool y_axis_reversed) {
182    Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size, y_axis_reversed,
183               "localhost");
184  }
185  ScrollView::ScrollView(const char *name, int x_pos, int y_pos, int x_size, int y_size,
186                         int x_canvas_size, int y_canvas_size) {
187    Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size, false, "localhost");
188  }
189  void ScrollView::Initialize(const char *name, int x_pos, int y_pos, int x_size, int y_size,
190                              int x_canvas_size, int y_canvas_size, bool y_axis_reversed,
191                              const char *server_name) {
192    if (stream_ == nullptr) {
193      nr_created_windows_ = 0;
194      stream_ = new SVNetwork(server_name, kSvPort);
195      waiting_for_events_mu = new std::mutex();
196      svmap_mu = new std::mutex();
197      SendRawMessage("svmain = luajava.bindClass('com.google.scrollview.ScrollView')\n");
198      std::thread t(&ScrollView::MessageReceiver);
199      t.detach();
200    }
201    nr_created_windows_++;
202    event_handler_ = nullptr;
203    event_handler_ended_ = false;
204    y_axis_is_reversed_ = y_axis_reversed;
205    y_size_ = y_canvas_size;
206    window_name_ = name;
207    window_id_ = nr_created_windows_;
208    points_ = new SVPolyLineBuffer;
209    points_->empty = true;
210    svmap_mu->lock();
211    svmap[window_id_] = this;
212    svmap_mu->unlock();
213    for (auto &i : event_table_) {
214      i = nullptr;
215    }
216    semaphore_ = new SVSemaphore();
217    char message[kMaxMsgSize];
218    snprintf(message, sizeof(message),
219             "w%u = luajava.newInstance('com.google.scrollview.ui"
220             ".SVWindow','%s',%u,%u,%u,%u,%u,%u,%u)\n",
221             window_id_, window_name_, window_id_, x_pos, y_pos, x_size, y_size, x_canvas_size,
222             y_canvas_size);
223    SendRawMessage(message);
224    std::thread t(&ScrollView::StartEventHandler, this);
225    t.detach();
226  }
227  void ScrollView::StartEventHandler() {
228    for (;;) {
229      stream_->Flush();
230      semaphore_->Wait();
231      int serial = -1;
232      int k = -1;
233      mutex_.lock();
234      for (int i = 0; i < SVET_COUNT; i++) {
235        if (event_table_[i] != nullptr && (serial < 0 || event_table_[i]->counter < serial)) {
236          serial = event_table_[i]->counter;
237          k = i;
238        }
239      }
240      if (k != -1) {
241        auto new_event = std::move(event_table_[k]);
242        mutex_.unlock();
243        if (event_handler_ != nullptr) {
244          event_handler_->Notify(new_event.get());
245        }
246        if (new_event->type == SVET_DESTROY) {
247          event_handler_ended_ = true;
248          return;
249        }
250      } else {
251        mutex_.unlock();
252      }
253    }
254  }
255  #endif 
256  ScrollView::~ScrollView() {
257  #ifndef GRAPHICS_DISABLED
258    svmap_mu->lock();
259    if (svmap[window_id_] != nullptr) {
260      svmap_mu->unlock();
261      SendMsg("destroy()");
262      AwaitEvent(SVET_DESTROY);
263      svmap_mu->lock();
264      svmap[window_id_] = nullptr;
265      svmap_mu->unlock();
266      while (!event_handler_ended_) {
267        Update();
268      }
269    } else {
270      svmap_mu->unlock();
271    }
272    delete semaphore_;
273    delete points_;
274  #endif 
275  }
276  #ifndef GRAPHICS_DISABLED
277  void ScrollView::SendMsg(const char *format, ...) {
278    if (!points_->empty) {
279      SendPolygon();
280    }
281    va_list args;
282    char message[kMaxMsgSize - 4];
283    va_start(args, format); 
284    vsnprintf(message, sizeof(message), format, args);
285    va_end(args);
286    char form[kMaxMsgSize];
287    snprintf(form, sizeof(form), "w%u:%s\n", window_id_, message);
288    stream_->Send(form);
289  }
290  void ScrollView::SendRawMessage(const char *msg) {
291    stream_->Send(msg);
292  }
293  void ScrollView::AddEventHandler(SVEventHandler *listener) {
294    event_handler_ = listener;
295  }
296  void ScrollView::Signal() {
297    semaphore_->Signal();
298  }
299  void ScrollView::SetEvent(const SVEvent *svevent) {
300    auto any = svevent->copy();
301    auto specific = svevent->copy();
302    any->counter = specific->counter + 1;
303    std::lock_guard<std::mutex> guard(mutex_);
304    event_table_[specific->type] = std::move(specific);
305    event_table_[SVET_ANY] = std::move(any);
306  }
307  std::unique_ptr<SVEvent> ScrollView::AwaitEvent(SVEventType type) {
308    auto *sem = new SVSemaphore();
309    std::pair<ScrollView *, SVEventType> ea(this, type);
310    waiting_for_events_mu->lock();
311    waiting_for_events[ea] = {sem, nullptr};
312    waiting_for_events_mu->unlock();
313    stream_->Flush();
314    sem->Wait();
315    waiting_for_events_mu->lock();
316    auto ret = std::move(waiting_for_events[ea].second);
317    waiting_for_events.erase(ea);
318    delete sem;
319    waiting_for_events_mu->unlock();
320    return ret;
321  }
322  void ScrollView::SendPolygon() {
323    if (!points_->empty) {
324      points_->empty = true; 
325      int length = points_->xcoords.size();
326      if (length == 2) {
327        SendMsg("drawLine(%d,%d,%d,%d)", points_->xcoords[0], points_->ycoords[0],
328                points_->xcoords[1], points_->ycoords[1]);
329      } else if (length > 2) {
330        SendMsg("createPolyline(%d)", length);
331        char coordpair[kMaxIntPairSize];
332        std::string decimal_coords;
333        for (int i = 0; i < length; ++i) {
334          snprintf(coordpair, kMaxIntPairSize, "%d,%d,", points_->xcoords[i], points_->ycoords[i]);
335          decimal_coords += coordpair;
336        }
337        decimal_coords += '\n';
338        SendRawMessage(decimal_coords.c_str());
339        SendMsg("drawPolyline()");
340      }
341      points_->xcoords.clear();
342      points_->ycoords.clear();
343    }
344  }
345  void ScrollView::SetCursor(int x, int y) {
346    SendPolygon();
347    DrawTo(x, y);
348  }
349  void ScrollView::DrawTo(int x, int y) {
350    points_->xcoords.push_back(x);
351    points_->ycoords.push_back(TranslateYCoordinate(y));
352    points_->empty = false;
353  }
354  void ScrollView::Line(int x1, int y1, int x2, int y2) {
355    if (!points_->xcoords.empty() && x1 == points_->xcoords.back() &&
356        TranslateYCoordinate(y1) == points_->ycoords.back()) {
357      DrawTo(x2, y2);
358    } else if (!points_->xcoords.empty() && x2 == points_->xcoords.back() &&
359               TranslateYCoordinate(y2) == points_->ycoords.back()) {
360      DrawTo(x1, y1);
361    } else {
362      SetCursor(x1, y1);
363      DrawTo(x2, y2);
364    }
365  }
366  void ScrollView::SetVisible(bool visible) {
367    if (visible) {
368      SendMsg("setVisible(true)");
369    } else {
370      SendMsg("setVisible(false)");
371    }
372  }
373  void ScrollView::AlwaysOnTop(bool b) {
374    if (b) {
375      SendMsg("setAlwaysOnTop(true)");
376    } else {
377      SendMsg("setAlwaysOnTop(false)");
378    }
379  }
380  void ScrollView::AddMessage(const char *message) {
381    char form[kMaxMsgSize];
382    snprintf(form, sizeof(form), "w%u:%s", window_id_, message);
383    char *esc = AddEscapeChars(form);
384    SendMsg("addMessage(\"%s\")", esc);
385    delete[] esc;
386  }
387  void ScrollView::AddMessageF(const char *format, ...) {
388    va_list args;
389    char message[kMaxMsgSize - 4];
390    va_start(args, format); 
391    vsnprintf(message, sizeof(message), format, args);
392    va_end(args);
393    AddMessage(message);
394  }
395  void ScrollView::AddMessageBox() {
396    SendMsg("addMessageBox()");
397  }
398  void ScrollView::Exit() {
399    SendRawMessage("svmain:exit()");
400    exit(0);
401  }
402  void ScrollView::Clear() {
403    SendMsg("clear()");
404  }
405  void ScrollView::Stroke(float width) {
406    SendMsg("setStrokeWidth(%f)", width);
407  }
408  void ScrollView::Rectangle(int x1, int y1, int x2, int y2) {
409    if (x1 == x2 && y1 == y2) {
410      return; 
411    }
412    SendMsg("drawRectangle(%d,%d,%d,%d)", x1, TranslateYCoordinate(y1), x2, TranslateYCoordinate(y2));
413  }
414  void ScrollView::Ellipse(int x1, int y1, int width, int height) {
415    SendMsg("drawEllipse(%d,%d,%u,%u)", x1, TranslateYCoordinate(y1), width, height);
416  }
417  void ScrollView::Pen(int red, int green, int blue) {
418    SendMsg("pen(%d,%d,%d)", red, green, blue);
419  }
420  void ScrollView::Pen(int red, int green, int blue, int alpha) {
421    SendMsg("pen(%d,%d,%d,%d)", red, green, blue, alpha);
422  }
423  void ScrollView::Brush(int red, int green, int blue) {
424    SendMsg("brush(%d,%d,%d)", red, green, blue);
425  }
426  void ScrollView::Brush(int red, int green, int blue, int alpha) {
427    SendMsg("brush(%d,%d,%d,%d)", red, green, blue, alpha);
428  }
429  void ScrollView::TextAttributes(const char *font, int pixel_size, bool bold, bool italic,
430                                  bool underlined) {
431    const char *b;
432    const char *i;
433    const char *u;
434    if (bold) {
435      b = "true";
436    } else {
437      b = "false";
438    }
439    if (italic) {
440      i = "true";
441    } else {
442      i = "false";
443    }
<span onclick='openModal()' class='match'>444    if (underlined) {
445      u = "true";
446    } else {
447      u = "false";
448    }
449    SendMsg("textAttributes('%s',%u,%s,%s,%s)", font, pixel_size, b, i, u);
450  }
</span>451  void ScrollView::Text(int x, int y, const char *mystring) {
452    SendMsg("drawText(%d,%d,'%s')", x, TranslateYCoordinate(y), mystring);
453  }
454  void ScrollView::Draw(const char *image, int x_pos, int y_pos) {
455    SendMsg("openImage('%s')", image);
456    SendMsg("drawImage('%s',%d,%d)", image, x_pos, TranslateYCoordinate(y_pos));
457  }
458  void ScrollView::MenuItem(const char *parent, const char *name, int cmdEvent, bool flag) {
459    if (parent == nullptr) {
460      parent = "";
461    }
462    if (flag) {
463      SendMsg("addMenuBarItem('%s','%s',%d,true)", parent, name, cmdEvent);
464    } else {
465      SendMsg("addMenuBarItem('%s','%s',%d,false)", parent, name, cmdEvent);
466    }
467  }
468  void ScrollView::MenuItem(const char *parent, const char *name, int cmdEvent) {
469    if (parent == nullptr) {
470      parent = "";
471    }
472    SendMsg("addMenuBarItem('%s','%s',%d)", parent, name, cmdEvent);
473  }
474  void ScrollView::MenuItem(const char *parent, const char *name) {
475    if (parent == nullptr) {
476      parent = "";
477    }
478    SendMsg("addMenuBarItem('%s','%s')", parent, name);
479  }
480  void ScrollView::PopupItem(const char *parent, const char *name) {
481    if (parent == nullptr) {
482      parent = "";
483    }
484    SendMsg("addPopupMenuItem('%s','%s')", parent, name);
485  }
486  void ScrollView::PopupItem(const char *parent, const char *name, int cmdEvent, const char *value,
487                             const char *desc) {
488    if (parent == nullptr) {
489      parent = "";
490    }
491    char *esc = AddEscapeChars(value);
492    char *esc2 = AddEscapeChars(desc);
493    SendMsg("addPopupMenuItem('%s','%s',%d,'%s','%s')", parent, name, cmdEvent, esc, esc2);
494    delete[] esc;
495    delete[] esc2;
496  }
497  void ScrollView::UpdateWindow() {
498    SendMsg("update()");
499  }
500  void ScrollView::Update() {
501    std::lock_guard<std::mutex> guard(*svmap_mu);
502    for (auto &iter : svmap) {
503      if (iter.second != nullptr) {
504        iter.second->UpdateWindow();
505      }
506    }
507  }
508  void ScrollView::Pen(Color color) {
509    Pen(table_colors[color][0], table_colors[color][1], table_colors[color][2],
510        table_colors[color][3]);
511  }
512  void ScrollView::Brush(Color color) {
513    Brush(table_colors[color][0], table_colors[color][1], table_colors[color][2],
514          table_colors[color][3]);
515  }
516  char *ScrollView::ShowInputDialog(const char *msg) {
517    SendMsg("showInputDialog(\"%s\")", msg);
518    auto ev = AwaitEvent(SVET_INPUT);
519    char *p = new char[strlen(ev->parameter) + 1];
520    strcpy(p, ev->parameter);
521    return p;
522  }
523  int ScrollView::ShowYesNoDialog(const char *msg) {
524    SendMsg("showYesNoDialog(\"%s\")", msg);
525    auto ev = AwaitEvent(SVET_INPUT);
526    int a = ev->parameter[0];
527    return a;
528  }
529  void ScrollView::ZoomToRectangle(int x1, int y1, int x2, int y2) {
530    y1 = TranslateYCoordinate(y1);
531    y2 = TranslateYCoordinate(y2);
532    SendMsg("zoomRectangle(%d,%d,%d,%d)", std::min(x1, x2), std::min(y1, y2), std::max(x1, x2),
533            std::max(y1, y2));
534  }
535  void ScrollView::Draw(Image image, int x_pos, int y_pos) {
536    l_uint8 *data;
537    size_t size;
538    pixWriteMem(&data, &size, image, IFF_PNG);
539    int base64_len = (size + 2) / 3 * 4;
540    y_pos = TranslateYCoordinate(y_pos);
541    SendMsg("readImage(%d,%d,%d)", x_pos, y_pos, base64_len);
542    const char kBase64Table[64] = {
543        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
544        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
545        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
546        'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
547    };
548    char *base64 = new char[base64_len + 1];
549    memset(base64, '=', base64_len);
550    base64[base64_len] = '\0';
551    int remainder = 0;
552    int bits_left = 0;
553    int code_len = 0;
554    for (size_t i = 0; i < size; ++i) {
555      int code = (data[i] >> (bits_left + 2)) | remainder;
556      base64[code_len++] = kBase64Table[code & 63];
557      bits_left += 2;
558      remainder = data[i] << (6 - bits_left);
559      if (bits_left == 6) {
560        base64[code_len++] = kBase64Table[remainder & 63];
561        bits_left = 0;
562        remainder = 0;
563      }
564    }
565    if (bits_left > 0) {
566      base64[code_len++] = kBase64Table[remainder & 63];
567    }
568    SendRawMessage(base64);
569    delete[] base64;
570    lept_free(data);
571  }
572  char *ScrollView::AddEscapeChars(const char *input) {
573    const char *nextptr = strchr(input, '\'');
574    const char *lastptr = input;
575    char *message = new char[kMaxMsgSize];
576    int pos = 0;
577    while (nextptr != nullptr) {
578      strncpy(message + pos, lastptr, nextptr - lastptr);
579      pos += nextptr - lastptr;
580      message[pos] = '\\';
581      pos += 1;
582      lastptr = nextptr;
583      nextptr = strchr(nextptr + 1, '\'');
584    }
585    strcpy(message + pos, lastptr);
586    return message;
587  }
588  int ScrollView::TranslateYCoordinate(int y) {
589    if (!y_axis_is_reversed_) {
590      return y;
591    } else {
592      return y_size_ - y;
593    }
594  }
595  char ScrollView::Wait() {
596    char ret = '\0';
597    SVEventType ev_type = SVET_ANY;
598    do {
599      std::unique_ptr<SVEvent> ev(AwaitEvent(SVET_ANY));
600      ev_type = ev->type;
601      if (ev_type == SVET_INPUT) {
602        ret = ev->parameter[0];
603      }
604    } while (ev_type != SVET_INPUT && ev_type != SVET_CLICK);
605    return ret;
606  }
607  #endif 
608  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dawg.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scrollview.cpp</div>
                <div class="column column_space"><pre><code>155        } else if (compare == 1) { 
156          start = edge + 1;
157        } else { 
158          end = edge - 1;
159        }
160      }
</pre></code></div>
                <div class="column column_space"><pre><code>444    if (underlined) {
445      u = "true";
446    } else {
447      u = "false";
448    }
449    SendMsg("textAttributes('%s',%u,%s,%s,%s)", font, pixel_size, b, i, u);
450  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    