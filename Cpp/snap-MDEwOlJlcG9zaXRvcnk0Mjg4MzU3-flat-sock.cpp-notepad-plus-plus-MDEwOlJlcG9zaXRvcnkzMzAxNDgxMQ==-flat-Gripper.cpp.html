
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 27, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock.cpp</h3>
            <pre><code>1  class TSockSys{
2  public:
3    static bool Active;
4    static HWND SockWndHnd;
5    static HWND DnsWndHnd;
6    static HWND ReportWndHnd;
7    static HWND TimerWndHnd;
8    static UINT SockMsgHnd;
9    static UINT SockErrMsgHnd;
10    static UINT DnsMsgHnd;
11    static UINT ReportMsgHnd;
12    static uint64 SockBytesRead;
13    static uint64 SockBytesWritten;
14    static THash<TInt, TUInt64> SockIdToHndH;
15    static THash<TUInt64, TInt> SockHndToIdH;
16    static THash<TUInt64, TInt> SockHndToEventIdH;
17    static TIntH SockTimerIdH;
18    static TUInt64H ActiveSockHndH;
19    static THash<TUInt64, PSockHost> HndToSockHostH;
20    static THash<TInt, PSockEvent> IdToSockEventH;
21    static TIntH ActiveSockEventIdH;
22    static THash<TInt, PReportEvent> IdToReportEventH;
23    static THash<TInt, ATimer> IdToTimerH;
24  public:
25    static TStr GetErrStr(const int ErrCd);
26    static LRESULT CALLBACK MainWndProc(
27     HWND WndHnd, UINT Msg, WPARAM wParam, LPARAM lParam);
28  public:
29    TSockSys();
30    ~TSockSys();
31    TSockSys& operator=(const TSockSys&){Fail; return *this;}
32    static HWND GetSockWndHnd(){IAssert(Active); return SockWndHnd;}
33    static HWND GetDnsWndHnd(){IAssert(Active); return DnsWndHnd;}
34    static HWND GetReportWndHnd(){IAssert(Active); return ReportWndHnd;}
35    static HWND GetTimerWndHnd(){IAssert(Active); return TimerWndHnd;}
36    static UINT GetSockMsgHnd(){IAssert(Active); return SockMsgHnd;}
37    static UINT GetSockErrMsgHnd(){IAssert(Active); return SockErrMsgHnd;}
38    static UINT GetDnsMsgHnd(){IAssert(Active); return DnsMsgHnd;}
39    static UINT GetReportMsgHnd(){IAssert(Active); return ReportMsgHnd;}
40    static int GetAllSockEventCdSet(){
41      return (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE);}
42    static uint64 GetSockBytesRead(){return SockBytesRead;}
43    static uint64 GetSockBytesWritten(){return SockBytesWritten;}
44    static void AddSock(
45     const int& SockId, const TSockHnd& SockHnd, const int& SockEventId);
46    static void DelSock(const int& SockId);
47    static bool IsSockId(const int& SockId){
48      IAssert(Active); return SockIdToHndH.IsKey(SockId);}
49    static bool IsSockHnd(const TSockHnd& SockHnd){
50      IAssert(Active); return SockHndToIdH.IsKey(SockHnd);}
51    static TSockHnd GetSockHnd(const int& SockId){
52      IAssert(Active); return TSockHnd(SockIdToHndH.GetDat(SockId));}
53    static TSockHnd GetSockId(const TSockHnd& SockHnd){
54      IAssert(Active); return SockHndToIdH.GetDat(SockHnd);}
55    static int GetSockEventId(const TSockHnd& SockHnd){
56      IAssert(Active); return SockHndToEventIdH.GetDat(SockHnd);}
57    static void AddSockTimer(const int& SockId, const int& MSecs){
58      UINT ErrCd=(UINT)SetTimer(GetSockWndHnd(), SockId, uint(MSecs), NULL);
59      ESAssert(ErrCd!=0);
60      SockTimerIdH.AddKey(SockId);}
61    static void DelIfSockTimer(const int& SockId){
62      KillTimer(GetSockWndHnd(), SockId);
63      SockTimerIdH.DelIfKey(SockId);}
64    static bool IsSockActive(const TSockHnd& SockHnd){
65      return ActiveSockHndH.IsKey(SockHnd);}
66    static void SetSockActive(const TSockHnd& SockHnd, const bool& Active){
67      IAssert(
68       (Active&&!IsSockActive(SockHnd))||
69       (!Active&&IsSockActive(SockHnd)));
70      if (Active){ActiveSockHndH.AddKey(SockHnd);}
71      else {ActiveSockHndH.DelKey(SockHnd);}}
72    static const int MxSockBfL;
73    static void AddSockHost(const TUInt64& SockHostHnd, const PSockHost& SockHost){
74      HndToSockHostH.AddDat(SockHostHnd, SockHost);}
75    static void DelSockHost(const TUInt64& SockHostHnd){
76      HndToSockHostH.DelKey(SockHostHnd);}
77    static bool IsSockHost(const TUInt64& SockHostHnd){
78      return HndToSockHostH.IsKey(SockHostHnd);}
79    static PSockHost GetSockHost(const TUInt64& SockHostHnd){
80      return HndToSockHostH.GetDat(SockHostHnd);}
81    static void AddSockEvent(const PSockEvent& SockEvent){
82      IAssert(!IsSockEvent(SockEvent));
83      IdToSockEventH.AddDat(SockEvent->GetSockEventId(), SockEvent);}
84    static void DelSockEvent(const PSockEvent& SockEvent){
85      IdToSockEventH.DelKey(SockEvent->GetSockEventId());}
86    static bool IsSockEvent(const int& SockEventId){
87      return IdToSockEventH.IsKey(TInt(SockEventId));}
88    static bool IsSockEvent(const PSockEvent& SockEvent){
89      return IdToSockEventH.IsKey(TInt(SockEvent->GetSockEventId()));}
90    static PSockEvent GetSockEvent(const int& SockEventId){
91      return IdToSockEventH.GetDat(SockEventId);}
92    static bool IsSockEventActive(const int& SockEventId){
93      return ActiveSockEventIdH.IsKey(SockEventId);}
94    static void SetSockEventActive(const int& SockEventId, const bool& Active){
95      IAssert(
96       (Active&&!IsSockEventActive(SockEventId))||
97       (!Active&&IsSockEventActive(SockEventId)));
98      if (Active){ActiveSockEventIdH.AddKey(SockEventId);}
99      else {ActiveSockEventIdH.DelKey(SockEventId);}}
100    static void AddReportEvent(const PReportEvent& ReportEvent){
101      IAssert(!IsReportEvent(ReportEvent));
102      IdToReportEventH.AddDat(TInt(ReportEvent->GetReportEventId()), ReportEvent);}
103    static void DelReportEvent(const PReportEvent& ReportEvent){
104      IdToReportEventH.DelKey(TInt(ReportEvent->GetReportEventId()));}
105    static bool IsReportEvent(const PReportEvent& ReportEvent){
106      return IdToReportEventH.IsKey(TInt(ReportEvent->GetReportEventId()));}
107    static PReportEvent GetReportEvent(const int& ReportEventId){
108      return IdToReportEventH.GetDat(ReportEventId);}
109    static void AddTimer(const ATimer& Timer){
110      IAssert(!IsTimer(Timer->GetTimerId()));
111      IdToTimerH.AddDat(TInt(Timer->GetTimerId()), Timer);}
112    static void DelTimer(const int& TimerId){
113      IdToTimerH.DelKey(TimerId);}
114    static bool IsTimer(const int& TimerId){
115      return IdToTimerH.IsKey(TimerId);}
116    static ATimer GetTimer(const int& TimerId){
117      return IdToTimerH.GetDat(TimerId);}
118    static void OnRead(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
119    static void OnWrite(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
120    static void OnOob(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
121    static void OnAccept(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
122    static void OnConnect(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
123    static void OnClose(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
124    static void OnTimeOut(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
125    static void OnError(
126     const TSockHnd& SockHnd, const PSockEvent& SockEvent, const int& ErrCd);
127    static void OnGetHost(const PSockHost& SockHost);
128    static TStr GetStatusStr();
129  };
130  bool TSockSys::Active=false;
131  HWND TSockSys::SockWndHnd=0;
132  HWND TSockSys::DnsWndHnd=0;
133  HWND TSockSys::ReportWndHnd=0;
134  HWND TSockSys::TimerWndHnd=0;
135  UINT TSockSys::SockMsgHnd=0;
136  UINT TSockSys::SockErrMsgHnd=0;
137  UINT TSockSys::DnsMsgHnd=0;
138  UINT TSockSys::ReportMsgHnd=0;
139  uint64 TSockSys::SockBytesRead=0;
140  uint64 TSockSys::SockBytesWritten=0;
141  THash<TInt, TUInt64> TSockSys::SockIdToHndH;
142  THash<TUInt64, TInt> TSockSys::SockHndToIdH;
143  THash<TUInt64, TInt> TSockSys::SockHndToEventIdH;
144  TIntH TSockSys::SockTimerIdH;
145  TUInt64H TSockSys::ActiveSockHndH;
146  const int TSockSys::MxSockBfL=100*1024;
147  THash<TUInt64, PSockHost> TSockSys::HndToSockHostH;
148  THash<TInt, PSockEvent> TSockSys::IdToSockEventH;
149  TIntH TSockSys::ActiveSockEventIdH;
150  THash<TInt, PReportEvent> TSockSys::IdToReportEventH;
151  THash<TInt, ATimer> TSockSys::IdToTimerH;
152  TSockSys SockSys; 
153  TStr TSockSys::GetErrStr(const int ErrCd){
154    switch (ErrCd){
155      case WSASYSNOTREADY: return "Underlying network subsystem is not ready for network communication.";
156      case WSAVERNOTSUPPORTED: return "The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation.";
157      case WSAEPROCLIM: return "Limit on the number of tasks supported by the Windows Sockets implementation has been reached.";
158      case WSANOTINITIALISED: return "Windows Sockets not initialized.";
159      case WSAENETDOWN: return "The network subsystem has failed.";
160      case WSAEWOULDBLOCK: return "Resource temporarily unavailable (op. would block).";
161      case WSAEINPROGRESS: return "A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.";
162      case WSAEADDRINUSE: return "The specified address is already in use.";
163      case WSAEADDRNOTAVAIL: return "The specified address is not available from the local machine.";
164      case WSAEAFNOSUPPORT: return "Addresses in the specified family cannot be used with this socket.";
165      case WSAECONNREFUSED: return "The attempt to connect was forcefully rejected.";
166      case WSAENETUNREACH: return "The network cannot be reached from this host at this time.";
167      case WSAEFAULT: return "Bad parameter.";
168      case WSAEINVAL: return "The socket is already bound to an address.";
169      case WSAEISCONN: return "The socket is already connected.";
170      case WSAEMFILE: return "No more file descriptors are available.";
171      case WSAENOBUFS: return "No buffer space is available. The socket cannot be connected.";
172      case WSAENOTCONN: return "The socket is not connected.";
173      case WSAETIMEDOUT: return "Attempt to connect timed out without establishing a connection.";
174      case WSAECONNRESET: return "The connection was reset by the remote side.";
175      case WSAECONNABORTED: return "The connection was terminated due to a time-out or other failure.";
176      default: return TStr("Unknown socket error (code ")+TInt::GetStr(ErrCd)+TStr(").");
177    }
178  }
179  LRESULT CALLBACK TSockSys::MainWndProc(
180   HWND WndHnd, UINT MsgHnd, WPARAM wParam, LPARAM lParam){
181    if (MsgHnd==TSockSys::SockMsgHnd){
182      IAssert(WndHnd==GetSockWndHnd());
183      TSockHnd SockHnd=wParam;
184      if (IsSockHnd(SockHnd)){
185        int SockEventId=GetSockEventId(SockHnd);
186        PSockEvent SockEvent=GetSockEvent(SockEventId);
187        SetSockEventActive(SockEventId, true);
188        try {
189          int ErrCd=WSAGETSELECTERROR(lParam);
190          if (ErrCd==0){
191            int EventCd=WSAGETSELECTEVENT(lParam);
192            switch (EventCd){
193              case FD_READ: OnRead(SockHnd, SockEvent); break;
194              case FD_WRITE: OnWrite(SockHnd, SockEvent); break;
195              case FD_OOB: OnOob(SockHnd, SockEvent); break;
196              case FD_ACCEPT: OnAccept(SockHnd, SockEvent); break;
197              case FD_CONNECT: OnConnect(SockHnd, SockEvent); break;
198              case FD_CLOSE: OnClose(SockHnd, SockEvent); break;
199              default: Fail;
200            }
201          } else {
202            OnError(SockHnd, SockEvent, ErrCd);
203          }
204        } catch (...){
205          SaveToErrLog("Exception from 'switch (EventCd)'");
206        }
207        SetSockEventActive(SockEventId, false);
208      }
209    } else
210    if (MsgHnd==TSockSys::SockErrMsgHnd){
211      IAssert(WndHnd==GetSockWndHnd());
212      TSockHnd SockHnd=wParam;
213      if (IsSockHnd(SockHnd)){
214        int SockEventId=GetSockEventId(SockHnd);
215        PSockEvent SockEvent=GetSockEvent(SockEventId);
216        SetSockEventActive(SockEventId, true);
217        try {
218          int ErrCd=int(lParam);
219          OnError(SockHnd, SockEvent, ErrCd);
220        } catch (...){
221          SaveToErrLog("Exception from 'OnError(SockHnd, SockEvent, ErrCd)'");
222        }
223        SetSockEventActive(SockEventId, false);
224      }
225    } else
226    if (MsgHnd==WM_TIMER){
227      if (WndHnd==GetSockWndHnd()){
228        int SockId=int(wParam);
229        DelIfSockTimer(SockId);
230        if (IsSockId(SockId)){
231          TSockHnd SockHnd=GetSockHnd(SockId);
232          int SockEventId=GetSockEventId(SockHnd);
233          PSockEvent SockEvent=GetSockEvent(SockEventId);
234          SetSockEventActive(SockEventId, true);
235          try {
236            OnTimeOut(SockHnd, SockEvent);
237          } catch (...){
238            SaveToErrLog("Exception from OnTimeOut(SockHnd, SockEvent);");
239          }
240          SetSockEventActive(SockEventId, false);
241        }
242      } else
243      if (WndHnd==GetTimerWndHnd()){
244        int TimerId=int(wParam);
245        if (TSockSys::IsTimer(TimerId)){
246          PTimer Timer=TSockSys::GetTimer(TimerId)();
247          Timer->IncTicks();
248          try {
249            Timer->OnTimeOut();
250          } catch (...){
251            SaveToErrLog("Exception from Timer->OnTimeOut();");
252          }
253        }
254      } else {
255        Fail;
256      }
257    } else
258    if (MsgHnd==TSockSys::DnsMsgHnd){
259      IAssert(WndHnd==GetDnsWndHnd());
260      uint SockHostHnd=int(wParam);
261      if (TSockSys::IsSockHost(SockHostHnd)){
262        TSockHostStatus Status=TSockHost::GetStatus(WSAGETASYNCERROR(lParam));
263        PSockHost SockHost=TSockSys::GetSockHost(SockHostHnd);
264        SockHost->GetFromHostEnt(Status, (hostent*)SockHost->HostEntBf);
265        DelSockHost(SockHostHnd);
266        try {
267          OnGetHost(SockHost);
268        } catch (...){
269          SaveToErrLog("Exception from OnGetHost(SockHost);");
270        }
271      }
272    } else
273    if (MsgHnd==TSockSys::ReportMsgHnd){
274      IAssert(WndHnd==GetReportWndHnd());
275      int ReportEventId=int(lParam);
276      PReportEvent ReportEvent=TSockSys::GetReportEvent(ReportEventId);
277      try {
278        ReportEvent->OnReport();
279      } catch (...){
280        SaveToErrLog("Exception from ReportEvent->OnReport()");
281      }
282      TSockSys::DelReportEvent(ReportEvent);
283    } else {
284      return DefWindowProc(WndHnd, MsgHnd, wParam, lParam);
285    }
286    return 0;
287  }
288  TSockSys::TSockSys(){
289    IAssert(Active==false);
<span onclick='openModal()' class='match'>290    WNDCLASS WndClass;
291    WndClass.style=0;
292    WndClass.lpfnWndProc=MainWndProc;
293    WndClass.cbClsExtra=0;
294    WndClass.cbWndExtra=0;
295    FSAssert((WndClass.hInstance=GetModuleHandle(NULL))!=NULL);
</span>296    WndClass.hIcon=NULL;
297    WndClass.hCursor=NULL;
298    WndClass.hbrBackground=NULL;
299    WndClass.lpszMenuName=NULL;
300    WndClass.lpszClassName="SockWndClass";
301    FSAssert(RegisterClass(&WndClass)!=0);
302    TSockSys::SockWndHnd=CreateWindow(
303     "SockWndClass", "Socket Window",
304     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
305     GetModuleHandle(NULL), NULL);
306    FSAssert(TSockSys::SockWndHnd!=NULL);
307    TSockSys::DnsWndHnd=CreateWindow(
308     "SockWndClass", "Dns Window",
309     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
310     GetModuleHandle(NULL), NULL);
311    FSAssert(TSockSys::DnsWndHnd!=NULL);
312    TSockSys::ReportWndHnd=CreateWindow(
313     "SockWndClass", "RepMsg Window",
314     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
315     GetModuleHandle(NULL), NULL);
316    FSAssert(TSockSys::ReportWndHnd!=NULL);
317    TSockSys::TimerWndHnd=CreateWindow(
318     "SockWndClass", "Net Timer",
319     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
320     GetModuleHandle(NULL), NULL);
321    FSAssert(TSockSys::TimerWndHnd!=NULL);
322    SockMsgHnd=RegisterWindowMessage("SockSys.SockMsg"); FSAssert(SockMsgHnd!=0);
323    SockErrMsgHnd=RegisterWindowMessage("SockSys.SockErrorMsg"); FSAssert(SockErrMsgHnd!=0);
324    DnsMsgHnd=RegisterWindowMessage("SockSys.DnsMsg"); FSAssert(DnsMsgHnd!=0);
325    ReportMsgHnd=RegisterWindowMessage("SockSys.RepMsg"); FSAssert(ReportMsgHnd!=0);
326    WORD Version=((WORD) (((BYTE) (2)) | (((WORD) ((BYTE) (0))) << 8)));
327    WSADATA WsaData;
328    int WsaErrCd=WSAStartup(Version, &WsaData);
329    FAssert(WsaErrCd==0, TSockSys::GetErrStr(WsaErrCd));
330    FAssert(
331     WsaData.wVersion==Version,
332     "Can not find appropriate version of WinSock DLL.");
333    Active=true;
334  }
335  TSockSys::~TSockSys(){
336    if (Active){
337      IAssert(ActiveSockHndH.Len()==0);
338      IAssert(ActiveSockEventIdH.Len()==0);
339      int WsaErrCd=WSACleanup();
340      FAssert(WsaErrCd==0, TSockSys::GetErrStr(WsaErrCd));
341      Active=false;
342    }
343  }
344  void TSockSys::AddSock(
345   const int& SockId, const TSockHnd& SockHnd, const int& SockEventId){
346    IAssert(Active);
347    SockIdToHndH.AddDat(SockId, SockHnd);
348    SockHndToIdH.AddDat(SockHnd, SockId);
349    SockHndToEventIdH.AddDat(SockHnd, SockEventId);
350  }
351  void TSockSys::DelSock(const int& SockId){
352    IAssert(Active);
353    TSockHnd SockHnd=TSockHnd(SockIdToHndH.GetDat(SockId));
354    IAssert(!IsSockActive(SockHnd));
355    SockIdToHndH.DelKey(SockId);
356    SockHndToIdH.DelKey(SockHnd);
357    SockHndToEventIdH.DelKey(SockHnd);
358    DelIfSockTimer(SockId);
359  }
360  void TSockSys::OnRead(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
361    TMem Mem(MxSockBfL);
362    char* Bf=new char[MxSockBfL]; int BfL;
363    do {
364      BfL=recv(SockHnd, Bf, MxSockBfL, 0);
365      if (BfL!=SOCKET_ERROR){
366        Mem.AddBf(Bf, BfL); SockBytesRead+=BfL;}
367    } while ((BfL>0)&&(BfL!=SOCKET_ERROR));
368    delete[] Bf;
369    if (!SockEvent.Empty()){
370      PSIn SIn=Mem.GetSIn();
371      SockEvent->OnRead(int(GetSockId(SockHnd)), SIn);
372    }
373  }
374  void TSockSys::OnWrite(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
375    if (!SockEvent.Empty()){
376      SockEvent->OnWrite(int(GetSockId(SockHnd)));}
377  }
378  void TSockSys::OnOob(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
379    if (!SockEvent.Empty()){
380      SockEvent->OnOob(int(GetSockId(SockHnd)));}
381  }
382  void TSockSys::OnAccept(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
383    PSock AccSock=TSock::Accept(SockHnd, SockEvent);
384    if (!SockEvent.Empty()){
385      SockEvent->OnAccept(AccSock->GetSockId(), AccSock);}
386  }
387  void TSockSys::OnConnect(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
388    if (!SockEvent.Empty()){
389      SockEvent->OnConnect(int(GetSockId(SockHnd)));}
390  }
391  void TSockSys::OnClose(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
392    if (!SockEvent.Empty()){
393      SockEvent->OnClose(int(GetSockId(SockHnd)));}
394  }
395  void TSockSys::OnTimeOut(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
396    if (!SockEvent.Empty()){
397      SockEvent->OnTimeOut(int(GetSockId(SockHnd)));}
398  }
399  void TSockSys::OnError(
400   const TSockHnd& SockHnd, const PSockEvent& SockEvent, const int& ErrCd){
401    if (!SockEvent.Empty()){
402      SockEvent->OnError(int(GetSockId(SockHnd)), ErrCd, GetErrStr(ErrCd));}
403  }
404  void TSockSys::OnGetHost(const PSockHost& SockHost){
405    if (IsSockEvent(SockHost->GetSockEventId())){
406      PSockEvent SockEvent=SockHost->GetSockEvent();
407      if (!SockEvent.Empty()){
408        SockEvent->OnGetHost(SockHost);}
409    }
410  }
411  TStr TSockSys::GetStatusStr(){
412    TChA ChA;
413    ChA+="Sockets: "; ChA+=TInt::GetStr(SockIdToHndH.Len()); ChA+="\r\n";
414    ChA+="Host-Resolutions: "; ChA+=TInt::GetStr(HndToSockHostH.Len()); ChA+="\r\n";
415    ChA+="Socket-Events: "; ChA+=TInt::GetStr(IdToSockEventH.Len()); ChA+="\r\n";
416    ChA+="Report-Events: "; ChA+=TInt::GetStr(IdToReportEventH.Len()); ChA+="\r\n";
417    ChA+="Timers: "; ChA+=TInt::GetStr(IdToTimerH.Len()); ChA+="\r\n";
418    return ChA;
419  }
420  int TSockEvent::LastSockEventId=0;
421  TSockEvent::~TSockEvent(){
422    IAssert(!TSockSys::IsSockEventActive(SockEventId));
423  }
424  bool TSockEvent::IsReg(const PSockEvent& SockEvent){
425    return TSockSys::IsSockEvent(SockEvent);
426  }
427  void TSockEvent::Reg(const PSockEvent& SockEvent){
428    IAssert(!TSockSys::IsSockEvent(SockEvent));
429    TSockSys::AddSockEvent(SockEvent);
430  }
431  void TSockEvent::UnReg(const PSockEvent& SockEvent){
432    IAssert(TSockSys::IsSockEvent(SockEvent));
433    TSockSys::DelSockEvent(SockEvent);
434  }
435  void TSockHost::GetFromHostEnt(
436   const TSockHostStatus& _Status, const hostent* HostEnt){
437    if ((Status=_Status)==shsOk){
438      IAssert(HostEnt!=NULL);
439      IAssert(HostEnt->h_addrtype==AF_INET);
440      IAssert(HostEnt->h_length==4);
441      HostNmV.Add(TStr(HostEnt->h_name).GetLc());
442      int HostNmN=0;
443      while (HostEnt->h_aliases[HostNmN]!=NULL){
444        HostNmV.Add(TStr(HostEnt->h_aliases[HostNmN]).GetLc()); HostNmN++;}
445      int IpNumN=0;
446      while (HostEnt->h_addr_list[IpNumN]!=NULL){
447        TStr IpNum=
448         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][0]))+"."+
449         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][1]))+"."+
450         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][2]))+"."+
451         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][3]));
452        IpNumV.Add(IpNum); IpNumN++;
453      }
454    }
455  }
456  PSockEvent TSockHost::GetSockEvent() const {
457    return TSockSys::GetSockEvent(SockEventId);
458  }
459  bool TSockHost::IsIpNum(const TStr& HostNm){
460    int HostNmLen=HostNm.Len();
461    for (int ChN=0; ChN<HostNmLen; ChN++){
462      if (TCh::IsAlpha(HostNm[ChN])){return false;}}
463    return true;
464  }
465  TStr TSockHost::GetIpNum(const uint& IpNum){
466    TChA IpNumChA;
467    IpNumChA+=TUInt::GetStr(IpNum/0x1000000);
468    IpNumChA+='.'; IpNumChA+=TUInt::GetStr((IpNum/0x10000)%0x100);
469    IpNumChA+='.'; IpNumChA+=TUInt::GetStr((IpNum/0x100)%0x100);
470    IpNumChA+='.'; IpNumChA+=TUInt::GetStr(IpNum%0x100);
471    return IpNumChA;
472  }
473  PSockHost TSockHost::GetSyncSockHost(const TStr& HostNm){
474    hostent* HostEnt; TSockHostStatus Status(shsUndef);
475    if ((HostNm.Len()>0)&&(!IsIpNum(HostNm))){
476      HostEnt=gethostbyname(HostNm.CStr());
477      if (HostEnt==NULL){Status=GetStatus(WSAGetLastError());}
478      else {Status=shsOk;}
479    } else {
480      uint HostIpNum=inet_addr(HostNm.CStr());
481      if (HostIpNum==INADDR_NONE){
482        Status=shsError; HostEnt=NULL;
483      } else {
484        HostEnt=gethostbyaddr((char*)&HostIpNum, 4, AF_INET);
485        if (HostEnt==NULL){Status=GetStatus(WSAGetLastError());}
486        else {Status=shsOk;}
487      }
488    }
489    PSockHost SockHost=PSockHost(new TSockHost());
490    SockHost->GetFromHostEnt(Status, HostEnt);
491    return SockHost;
492  }
493  void TSockHost::GetAsyncSockHost(
494   const TStr& HostNm, const PSockEvent& SockEvent){
495    PSockHost SockHost=PSockHost(new TSockHost(SockEvent));
496    HANDLE SockHostHnd=0;
497    if ((HostNm.Len()>0)){
498      SockHostHnd=WSAAsyncGetHostByName(TSockSys::GetDnsWndHnd(),
499       TSockSys::GetDnsMsgHnd(), HostNm.CStr(),
500       SockHost->HostEntBf, MAXGETHOSTSTRUCT);
501    } else {
502      uint HostIpNum=inet_addr(HostNm.CStr());
503      if (HostIpNum==INADDR_NONE){
504        SockHostHnd=0;
505      } else {
506        SockHostHnd=WSAAsyncGetHostByAddr(TSockSys::GetDnsWndHnd(),
507         TSockSys::GetDnsMsgHnd(), (char*)&HostIpNum, 4, AF_INET,
508         SockHost->HostEntBf, MAXGETHOSTSTRUCT);
509      }
510    }
511    EAssertR(SockHostHnd!=0, TSockSys::GetErrStr(WSAGetLastError()));
512    if (SockHostHnd!=0){
513      TSockSys::AddSockHost(TUInt64(SockHostHnd), SockHost);
514    }
515  }
516  TSockHostStatus TSockHost::GetStatus(const int& ErrCd){
517    switch (ErrCd){
518      case 0: return shsOk;
519      case WSAHOST_NOT_FOUND: return shsHostNotFound;
520      case WSATRY_AGAIN: return shsTryAgain;
521      default: return shsError;
522    }
523  }
524  PSockHost TSockHost::GetLocalSockHost(){
525    PSockHost SockHost=TSockHost::GetSyncSockHost(LocalHostNm);
526    if (SockHost->IsOk()){
527      SockHost=TSockHost::GetSyncSockHost(SockHost->GetHostNm());}
528    return SockHost;
529  }
530  const TStr TSockHost::LocalHostNm("localhost");
531  int TSock::LastSockId=0;
532  TSock::TSock(const PSockEvent& SockEvent):
533    SockId(++LastSockId), SockHnd(0),
534    SockEventId(SockEvent->GetSockEventId()){
535    SockHnd=socket(AF_INET, SOCK_STREAM, 0);
536    EAssertR(SockHnd!=INVALID_SOCKET, TSockSys::GetErrStr(WSAGetLastError()));
537    TSockSys::AddSock(SockId, SockHnd, SockEventId);
538    IAssert(TSockEvent::IsReg(SockEvent));
539  }
540  TSock::TSock(const TSockHnd& _SockHnd, const PSockEvent& SockEvent):
541    SockId(++LastSockId), SockHnd(_SockHnd),
542    SockEventId(SockEvent->GetSockEventId()){
543    TSockSys::AddSock(SockId, SockHnd, SockEventId);
544    IAssert(TSockEvent::IsReg(SockEvent));
545  }
546  TSock::~TSock(){
547    IAssert(!TSockSys::IsSockActive(SockHnd));
548    TSockSys::DelSock(SockId);
549    closesocket(SockHnd);
550  }
551  PSockEvent TSock::GetSockEvent() const {
552    return TSockSys::GetSockEvent(SockEventId);
553  }
554  void TSock::Listen(const int& PortN){
555    sockaddr_in SockAddr;
556    memset(&SockAddr, 0, sizeof(SockAddr));
557    SockAddr.sin_family=AF_INET;
558    SockAddr.sin_addr.s_addr=INADDR_ANY;
559    SockAddr.sin_port=htons(u_short(PortN));
560    EAssertR(
561     bind(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr))==0,
562     TSockSys::GetErrStr(WSAGetLastError()));
563    EAssertR(
564     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
565      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
566     TSockSys::GetErrStr(WSAGetLastError()));
567    EAssertR(
568     listen(SockHnd, SOMAXCONN)==0,
569     TSockSys::GetErrStr(WSAGetLastError()));
570  }
571  int TSock::GetPortAndListen(const int& MnPortN){
572    int PortN=MnPortN-1;
573    int ErrCd=0;
574    forever {
575      PortN++;
576      sockaddr_in SockAddr;
577      memset(&SockAddr, 0, sizeof(SockAddr));
578      SockAddr.sin_family=AF_INET;
579      SockAddr.sin_addr.s_addr=INADDR_ANY;
580      SockAddr.sin_port=htons(u_short(PortN));
581      int OkCd=bind(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr));
582      if (OkCd==SOCKET_ERROR){
583        ErrCd=WSAGetLastError();
584        if (ErrCd!=WSAEADDRINUSE){break;}
585      } else {
586        ErrCd=0; break;
587      }
588    }
589    EAssertR(ErrCd==0, TSockSys::GetErrStr(ErrCd));
590    EAssertR(
591     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
592     TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
593     TSockSys::GetErrStr(WSAGetLastError()));
594    EAssertR(
595     listen(SockHnd, SOMAXCONN)==0,
596     TSockSys::GetErrStr(WSAGetLastError()));
597    return PortN;
598  }
599  void TSock::Connect(const PSockHost& SockHost, const int& PortN){
600    IAssert(SockHost->IsOk());
601    uint HostIpNum=inet_addr(SockHost->GetIpNum().CStr());
602    IAssert(HostIpNum!=INADDR_NONE);
603    sockaddr_in SockAddr;
604    memset(&SockAddr, 0, sizeof(SockAddr));
605    memcpy(&(SockAddr.sin_addr), &HostIpNum, sizeof(HostIpNum));
606    SockAddr.sin_family=AF_INET;
607    SockAddr.sin_port=htons(u_short(PortN));
608    EAssertR(
609     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
610      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
611     TSockSys::GetErrStr(WSAGetLastError()));
612    int ErrCd=connect(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr));
613    EAssertR(
614     (ErrCd==SOCKET_ERROR)&&(WSAGetLastError()==WSAEWOULDBLOCK),
615     "Unsuccessful socket-connect.");
616  }
617  void TSock::Send(const PSIn& SIn, bool& Ok, int& ErrCd){
618    if (!SIn.Empty()){UnsentBf+=SIn;}
619    Ok=true; ErrCd=0;
620    int SentChs=0;
621    while (SentChs<UnsentBf.Len()){
622      int SendBfL=UnsentBf.Len()-SentChs;
623      if (SendBfL>TSockSys::MxSockBfL){SendBfL=TSockSys::MxSockBfL;}
624      int LSentChs=send(SockHnd, &UnsentBf[SentChs], SendBfL, 0);
625      if (LSentChs==SOCKET_ERROR){
626        ErrCd=WSAGetLastError();
627        Ok=(ErrCd==WSAEWOULDBLOCK);
628        break;
629      } else {
630        SentChs+=LSentChs;
631        TSockSys::SockBytesWritten+=LSentChs;
632      }
633    }
634    UnsentBf.Del(0, SentChs-1);
635  }
636  void TSock::Send(const PSIn& SIn){
637    bool Ok; int ErrCd; Send(SIn, Ok, ErrCd);
638    if (!Ok){
639     ESAssert(PostMessage(
640      TSockSys::GetSockWndHnd(), TSockSys::SockErrMsgHnd, SockHnd, ErrCd));
641    }
642  }
643  void TSock::SendSafe(const PSIn& SIn){
644    bool Ok; int ErrCd; Send(SIn, Ok, ErrCd);
645  }
646  TStr TSock::GetPeerIpNum() const {
647    sockaddr_in SockAddr;
648    memset(&SockAddr, 0, sizeof(SockAddr));
649    int NmLen=sizeof(sockaddr_in);
650    EAssertR(
651     getpeername(SockHnd, (sockaddr*)&SockAddr, &NmLen)==0,
652     TSockSys::GetErrStr(WSAGetLastError()));
653    TStr IpNum=
654     TInt::GetStr(SockAddr.sin_addr.s_net)+"."+
655     TInt::GetStr(SockAddr.sin_addr.s_host)+"."+
656     TInt::GetStr(SockAddr.sin_addr.s_lh)+"."+
657     TInt::GetStr(SockAddr.sin_addr.s_impno);
658    return IpNum;
659  }
660  TStr TSock::GetLocalIpNum() const {
661    sockaddr_in SockAddr;
662    memset(&SockAddr, 0, sizeof(SockAddr));
663    int NmLen=sizeof(sockaddr_in);
664    EAssertR(
665     getsockname(SockHnd, (sockaddr*)&SockAddr, &NmLen)==0,
666     TSockSys::GetErrStr(WSAGetLastError()));
667    TStr IpNum=
668     TInt::GetStr(SockAddr.sin_addr.s_net)+"."+
669     TInt::GetStr(SockAddr.sin_addr.s_host)+"."+
670     TInt::GetStr(SockAddr.sin_addr.s_lh)+"."+
671     TInt::GetStr(SockAddr.sin_addr.s_impno);
672    return IpNum;
673  }
674  void TSock::PutTimeOut(const int& MSecs){
675    TSockSys::AddSockTimer(SockId, MSecs);
676  }
677  void TSock::DelTimeOut(){
678    TSockSys::DelIfSockTimer(SockId);
679  }
680  PSock TSock::Accept(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
681    sockaddr_in SockAddr;
682    int SockAddrLen=sizeof(SockAddr);
683    memset(&SockAddr, 0, sizeof(SockAddr));
684    TSockHnd AccSockHnd=accept(SockHnd, (sockaddr*)&SockAddr, &SockAddrLen);
685    EAssertR(
686     AccSockHnd!=INVALID_SOCKET,
687     TSockSys::GetErrStr(WSAGetLastError()));
688    PSock AccSock=PSock(new TSock(AccSockHnd, SockEvent));
689    EAssertR(
690     WSAAsyncSelect(AccSock->GetSockHnd(), TSockSys::GetSockWndHnd(),
691      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
692     TSockSys::GetErrStr(WSAGetLastError()));
693    return AccSock;
694  }
695  TStr TSock::GetSockSysStatusStr(){
696    return TSockSys::GetStatusStr();
697  }
698  uint64 TSock::GetSockSysBytesRead(){
699    return TSockSys::SockBytesRead;
700  }
701  uint64 TSock::GetSockSysBytesWritten(){
702    return TSockSys::SockBytesWritten;
703  }
704  bool TSock::IsSockId(const int& SockId){
705    return TSockSys::IsSockId(SockId);
706  }
707  int TReportEvent::LastReportEventId=0;
708  void TReportEvent::SendReport(){
709    TSockSys::AddReportEvent(this);
710    ESAssert(PostMessage(
711     TSockSys::GetReportWndHnd(), TSockSys::GetReportMsgHnd(), 0, ReportEventId));
712  }
713  int TTTimer::LastTimerId=0;
714  TTTimer::TTTimer(const int& _TimeOut):
715    TimerId(++LastTimerId), TimerHnd(0), TimeOut(_TimeOut),
716    Ticks(0), StartTm(TSecTm::GetCurTm()){
717    IAssert(TimeOut>=0);
718    StartTimer(TimeOut);
719  }
720  TTTimer::~TTTimer(){
721    StopTimer();
722  }
723  void TTTimer::StartTimer(const int& _TimeOut){
724    IAssert((_TimeOut==-1)||(_TimeOut>=0));
725    if (_TimeOut!=-1){
726      TimeOut=_TimeOut;}
727    StopTimer();
728    if (TimeOut>0){
729      TimerHnd=uint(SetTimer(
730       TSockSys::GetTimerWndHnd(), UINT(TimerId), UINT(TimeOut), NULL));
731      ESAssert(TimerHnd!=0);
732      TSockSys::AddTimer(this);
733    }
734  }
735  void TTTimer::StopTimer(){
736    if (TimerHnd!=0){
737      ESAssert(KillTimer(TSockSys::GetTimerWndHnd(), TimerId));
738      TSockSys::DelTimer(TimerId);
739      TimerHnd=0;
740    }
741  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Gripper.cpp</h3>
            <pre><code>1  #include <stdexcept>
2  #include "Gripper.h"
3  #include "DockingManager.h"
4  #include "Parameters.h"
5  using namespace std;
6  #ifndef WH_KEYBOARD_LL
7  #define WH_KEYBOARD_LL 13
8  #endif
9  #ifndef WH_MOUSE_LL
10  #define WH_MOUSE_LL 14
11  #endif
12  BOOL Gripper::_isRegistered	= FALSE;
13  static HWND		hWndServer		= NULL;
14  static HHOOK	hookMouse		= NULL;
15  static HHOOK	hookKeyboard	= NULL;
16  static LRESULT CALLBACK hookProcMouse(int nCode, WPARAM wParam, LPARAM lParam)
17  {
18      if (nCode >= 0)
19      {
20  		switch (wParam)
21  		{
22  			case WM_MOUSEMOVE:
23  			case WM_NCMOUSEMOVE:
24  				::SendMessage(hWndServer, static_cast<UINT>(wParam), 0, 0);
25  				break;
26  			case WM_LBUTTONUP:
27  			case WM_NCLBUTTONUP:
28  				::SendMessage(hWndServer, static_cast<UINT>(wParam), 0, 0);
29  				return TRUE;
30  			default:
31  				break;
32  		}
33  	}
34  	return ::CallNextHookEx(hookMouse, nCode, wParam, lParam);
35  }
36  static LRESULT CALLBACK hookProcKeyboard(int nCode, WPARAM wParam, LPARAM lParam)
37  {
38      if (nCode >= 0)
39      {
40  		if (wParam == VK_ESCAPE)
41  		{
42  			::PostMessage(hWndServer, DMM_CANCEL_MOVE, 0, 0);
43  			return FALSE;
44  		}
45  	}
46  	return ::CallNextHookEx(hookKeyboard, nCode, wParam, lParam);
47  }
48  void Gripper::startGrip(DockingCont* pCont, DockingManager* pDockMgr)
49  {
50  	_pDockMgr   = pDockMgr;
51  	_pCont		= pCont;
52  	_pDockMgr->getDockInfo(&_dockData);
53  	if (!_isRegistered)
54  	{
<span onclick='openModal()' class='match'>55  		WNDCLASS clz;
56  		clz.style = 0;
57  		clz.lpfnWndProc = staticWinProc;
58  		clz.cbClsExtra = 0;
59  		clz.cbWndExtra = 0;
60  		clz.hInstance = _hInst;
</span>61  		clz.hIcon = NULL;
62  		clz.hCursor = ::LoadCursor(NULL, IDC_ARROW);
63  		clz.hbrBackground = NULL;
64  		clz.lpszMenuName = NULL;
65  		clz.lpszClassName = MDLG_CLASS_NAME;
66  		if (!::RegisterClass(&clz))
67  		{
68  			throw std::runtime_error("Gripper::startGrip : RegisterClass() function failed");
69  		}
70  		_isRegistered = TRUE;
71  	}
72  	_hSelf = ::CreateWindowEx(
73  					0,
74  					MDLG_CLASS_NAME,
75  					TEXT(""), 0,
76  					CW_USEDEFAULT, CW_USEDEFAULT,
77  					CW_USEDEFAULT, CW_USEDEFAULT,
78  					NULL,
79  					NULL,
80  					_hInst,
81  					(LPVOID)this);
82  	hWndServer = _hSelf;
83  	if (!_hSelf)
84  	{
85  		throw std::runtime_error("Gripper::startGrip : CreateWindowEx() function return null");
86  	}
87  }
88  LRESULT CALLBACK Gripper::staticWinProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
89  {
90  	Gripper *pDlgMoving = NULL;
91  	switch (message)
92  	{
93  		case WM_NCCREATE :
94  			pDlgMoving = static_cast<Gripper *>(reinterpret_cast<LPCREATESTRUCT>(lParam)->lpCreateParams);
95  			pDlgMoving->_hSelf = hwnd;
96  			::SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pDlgMoving));
97  			return TRUE;
98  		default :
99  			pDlgMoving = reinterpret_cast<Gripper *>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
100  			if (!pDlgMoving)
101  				return ::DefWindowProc(hwnd, message, wParam, lParam);
102  			return pDlgMoving->runProc(message, wParam, lParam);
103  	}
104  }
105  LRESULT Gripper::runProc(UINT message, WPARAM wParam, LPARAM lParam)
106  {
107  	switch (message)
108  	{
109  		case WM_CREATE:
110  		{
111  			create();
112  			break;
113  		}
114  		case WM_MOUSEMOVE:
115  		case WM_NCMOUSEMOVE:
116  		{
117  			onMove();
118  			return TRUE;
119  		}
120  		case WM_LBUTTONUP:
121  		case WM_NCLBUTTONUP:
122  		{
123  			if (hookMouse)
124  			{
125  				::UnhookWindowsHookEx(hookMouse);
126  				::UnhookWindowsHookEx(hookKeyboard);
127  				hookMouse = NULL;
128  				hookKeyboard = NULL;
129  			}
130  			onButtonUp();
131  			::DestroyWindow(_hSelf);
132  			return TRUE;
133  		}
134  		case DMM_CANCEL_MOVE:
135  		{
136  			POINT			pt			= {0,0};
137  			POINT			ptBuf		= {0,0};
138  			::GetCursorPos(&pt);
139  			getMousePoints(&pt, &ptBuf);
140  			drawRectangle(NULL);
141  			::UnhookWindowsHookEx(hookMouse);
142  			::UnhookWindowsHookEx(hookKeyboard);
143  			::DestroyWindow(_hSelf);
144  			return FALSE;
145  		}
146  		case WM_DESTROY:
147  		{
148  			mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
149  			::SetWindowPos(_hParent, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
150  			_pCont->focusClient();
151  			delete this; 
152  			return TRUE;
153  		}
154  		default:
155  			break;
156  	}
157  	return ::DefWindowProc(_hSelf, message, wParam, lParam);
158  }
159  void Gripper::create()
160  {
161  	RECT		rc		= {};
162  	POINT		pt		= {};
163  	::SetWindowPos(_pCont->getHSelf(), HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
164  	::SetCapture(_hSelf);
165  	winVer ver = (NppParameters::getInstance()).getWinVersion();
166  	hookMouse = ::SetWindowsHookEx(WH_MOUSE_LL, hookProcMouse, _hInst, 0);
167      if (!hookMouse)
168      {
169          DWORD dwError = ::GetLastError();
170          TCHAR  str[128];
171          ::wsprintf(str, TEXT("GetLastError() returned %lu"), dwError);
172          ::MessageBox(NULL, str, TEXT("SetWindowsHookEx(MOUSE) failed on Gripper::create()"), MB_OK | MB_ICONERROR);
173      }
174  	if (ver != WV_UNKNOWN && ver < WV_VISTA)
175  	{
176  		hookKeyboard = ::SetWindowsHookEx(WH_KEYBOARD_LL, hookProcKeyboard, _hInst, 0);
177  		if (!hookKeyboard)
178  		{
179  			DWORD dwError = ::GetLastError();
180  			TCHAR  str[128];
181  			::wsprintf(str, TEXT("GetLastError() returned %lu"), dwError);
182  			::MessageBox(NULL, str, TEXT("SetWindowsHookEx(KEYBOARD) failed on Gripper::create()"), MB_OK | MB_ICONERROR);
183  		}
184  	}
185  	::GetCursorPos(&pt);
186  	initTabInformation();
187  	if (_pCont->isFloating() == true)
188  	{
189  		::GetWindowRect(_pCont->getHSelf(), &rc);
190  	}
191  	else
192  	{
193  		_pCont->getClientRect(rc);
194  		::ScreenToClient(_pCont->getHSelf(), &pt);
195  	}
196  	_ptOffset.x	= pt.x - rc.left;
197  	_ptOffset.y	= pt.y - rc.top;
198  }
199  void Gripper::onMove()
200  {
201  	POINT		pt		= {0,0};
202  	POINT		ptBuf	= {0,0};
203  	::GetCursorPos(&pt);
204  	getMousePoints(&pt, &ptBuf);
205  	if (_startMovingFromTab == TRUE)
206  	{
207  		doTabReordering(pt);
208  	}
209  	drawRectangle(&pt);
210  }
211  void Gripper::onButtonUp()
212  {
213  	POINT			pt			= {0,0};
214  	POINT			ptBuf		= {0,0};
215  	RECT			rc			= {};
216  	RECT			rcCorr		= {};
217  	::GetCursorPos(&pt);
218  	getMousePoints(&pt, &ptBuf);
219  	if (_bPtOldValid == FALSE)
220  		return;
221  	drawRectangle(NULL);
222  	DockingCont*	pDockCont = contHitTest(pt);
223  	if (pDockCont == NULL)
224  	{
225  		pDockCont = workHitTest(pt);
226  	}
227  	if (pDockCont == NULL)
228  	{
229  		rc = _pCont->getDataOfActiveTb()->rcFloat;
230  		_pCont->getClientRect(rcCorr);
231  		CalcRectToScreen(_dockData.hWnd, &rc);
232  		CalcRectToScreen(_dockData.hWnd, &rcCorr);
233  		rc.left    = pt.x - _ptOffset.x;
234  		rc.top     = pt.y - _ptOffset.y;
235  		DoCalcGripperRect(&rc, rcCorr, pt);
236  		DockingCont* pContMove	= NULL;
237  		if (_startMovingFromTab == TRUE)
238  		{
239  			if ((!_pCont->isFloating()) ||
240  				((_pCont->isFloating()) && (::SendMessage(_hTabSource, TCM_GETITEMCOUNT, 0, 0) > 1)))
241  			{
242  				pContMove = _pDockMgr->toggleActiveTb(_pCont, DMM_FLOAT, TRUE, &rc);
243  			}
244  		}
245  		else if (!_pCont->isFloating())
246  		{
247  			pContMove = _pDockMgr->toggleVisTb(_pCont, DMM_FLOAT, &rc);
248  		}
249  		if (pContMove == NULL)
250  		{
251  			pContMove = _pCont;
252  		}
253  		::MoveWindow(pContMove->getHSelf(), rc.left, rc.top, rc.right, rc.bottom, TRUE);
254  		::SendMessage(pContMove->getHSelf(), WM_SIZE, 0, 0);
255  	}
256  	else if (_pCont != pDockCont)
257  	{
258  		if ((_startMovingFromTab == TRUE) && (::SendMessage(_hTabSource, TCM_GETITEMCOUNT, 0, 0) != 1))
259  		{
260  			_pDockMgr->toggleActiveTb(_pCont, pDockCont);
261  		}
262  		else
263  		{
264  			_pDockMgr->toggleVisTb(_pCont, pDockCont);
265  		}
266  	}
267  }
268  void Gripper::doTabReordering(POINT pt)
269  {
270  	vector<DockingCont*>	vCont		= _pDockMgr->getContainerInfo();
271  	BOOL					inTab		= FALSE;
272  	HWND					hTab		= NULL;
273  	HWND					hTabOld		= _hTab;
274  	int						iItemOld	= _iItem;
275  	for (size_t iCont = 0, len = vCont.size(); iCont < len; ++iCont)
276  	{
277  		hTab = vCont[iCont]->getTabWnd();
278  		if (::IsWindowVisible(hTab) == TRUE)
279  		{
280  			RECT	rc		= {};
281  			::GetWindowRect(hTab, &rc);
282  			if (::PtInRect(&rc, pt) == TRUE)
283  			{
284  				TCHITTESTINFO	info	= {};
285  				if (_hTab == NULL)
286  				{
287  					initTabInformation();
288  					hTabOld  = _hTab;
289  					iItemOld = _iItem;
290  				}
291  				info.pt	= pt;
292  				::ScreenToClient(hTab, &info.pt);
293  				auto iItem = ::SendMessage(hTab, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info));
294  				if (iItem != -1)
295  				{
296  					::SendMessage(hTab, TCM_GETITEMRECT, iItem, reinterpret_cast<LPARAM>(&rc));
297  					ClientRectToScreenRect(hTab, &rc);
298  					if ((rc.left + (_rcItem.right  - _rcItem.left)) < pt.x)
299  					{
300  						return;
301  					}
302  					_iItem = static_cast<int32_t>(iItem);
303  				}
304  				else if (_hTab && ((hTab != _hTab) || (_iItem == -1)))
305  				{
306  					auto iLastItem = ::SendMessage(hTab, TCM_GETITEMCOUNT, 0, 0) - 1;
307  					::SendMessage(hTab, TCM_GETITEMRECT, iLastItem, reinterpret_cast<LPARAM>(&rc));
308  					if ((rc.left + rc.right) < pt.x)
309  					{
310  						_iItem = static_cast<int32_t>(iLastItem) + 1;
311  					}
312  				}
313  				_hTab = hTab;
314  				inTab = TRUE;
315  				break;
316  			}
317  		}
318  	}
319  	if ((inTab == TRUE) && (iItemOld != _iItem))
320  	{
321  		if (_hTab == _hTabSource)
322  		{
323  			auto iSel = ::SendMessage(_hTab, TCM_GETCURSEL, 0, 0);
324  			::SendMessage(_hTab, TCM_DELETEITEM, iSel, 0);
325  		}
326  		else if (_hTab && _hTab == hTabOld)
327  		{
328  			::SendMessage(_hTab, TCM_DELETEITEM, iItemOld, 0);
329  		}
330  	}
331  	else if (inTab == FALSE)
332  	{
333  		if (hTabOld != _hTabSource)
334  		{
335  			::SendMessage(hTabOld, TCM_DELETEITEM, iItemOld, 0);
336  		}
337  		_iItem = -1;
338  	}
339  	if (_hTab && ((_hTab != hTabOld) || (_iItem != iItemOld)))
340  	{
341  		_tcItem.mask	= TCIF_PARAM | (_hTab == _hTabSource ? TCIF_TEXT : 0);
342  		::SendMessage(_hTab, TCM_INSERTITEM, _iItem, reinterpret_cast<LPARAM>(&_tcItem));
343  	}
344  	if ((_hTab != nullptr && _hTab == _hTabSource) && (_iItem != -1))
345  	{
346  		::SendMessage(_hTab, TCM_SETCURSEL, _iItem, 0);
347  	}
348  #if 0
349  	extern HWND g_hMainWnd;
350  	TCHAR str[128];
351  	wsprintf(str, TEXT("Size: %i"), vCont.size());
352  	::SetWindowText(g_hMainWnd, str);
353  #endif
354  	::UpdateWindow(_hParent);
355  }
356  void Gripper::drawRectangle(const POINT* pPt)
357  {
358  	HBRUSH hbrushOrig= NULL;
359  	HBITMAP hbmOrig  = NULL;
360  	RECT   rc	 = {};
361  	RECT   rcNew	 = {};
362  	RECT   rcOld	 = _rcPrev;
363  	if (!_hdc)
364  	{
365  		HWND hWnd = ::GetDesktopWindow();
366  		#if defined (USE_LOCKWINDOWUPDATE)
367  		_hdc = ::GetDCEx(hWnd, NULL, ::LockWindowUpdate(hWnd) ? DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE : DCX_WINDOW|DCX_CACHE);
368  		#else
369  		_hdc = ::GetDCEx(hWnd, NULL, DCX_WINDOW|DCX_CACHE);
370  		#endif
371  	}
372  	if (!_hbm)
373  		_hbm = ::CreateBitmap(8, 8, 1, 1, DotPattern);
374  	if (!_hbrush)
375  		_hbrush = ::CreatePatternBrush(_hbm);
376  	if (pPt != NULL)
377  	{
378  		getMovingRect(*pPt, &rcNew);
379  		_rcPrev= rcNew;		
380  		if (_bPtOldValid)
381  		{
382  			if (rcOld.left==rcNew.left && rcOld.right==rcNew.right && rcOld.top== rcNew.top && rcOld.bottom==rcNew.bottom)
383  				return;
384  			rc.left   = std::min<LONG>(rcOld.left, rcNew.left);
385  			rc.top    = std::min<LONG>(rcOld.top,  rcNew.top);
386  			rc.right  = std::max<LONG>(rcOld.left + rcOld.right,  rcNew.left + rcNew.right);
387  			rc.bottom = std::max<LONG>(rcOld.top  + rcOld.bottom, rcNew.top  + rcNew.bottom);
388  			rc.right -= rc.left;
389  			rc.bottom-= rc.top;
390  		}
391  		else	rc = rcNew;	
392  	}
393  	else	rc = rcOld;	
394  	rcOld.left = rcOld.left - rc.left;
395  	rcOld.top = rcOld.top  - rc.top;
396  	rcNew.left = rcNew.left - rc.left;
397  	rcNew.top = rcNew.top  - rc.top;
398  	HDC hdcMem = ::CreateCompatibleDC(_hdc);
399  	HBITMAP hBm = ::CreateCompatibleBitmap(_hdc, rc.right, rc.bottom);
400  	hbrushOrig = (HBRUSH)::SelectObject(hdcMem, hBm);
401  	::SetBrushOrgEx(hdcMem, rc.left%8, rc.top%8, 0);
402  	hbmOrig = (HBITMAP)::SelectObject(hdcMem, _hbrush);
403  	::BitBlt(hdcMem, 0, 0, rc.right, rc.bottom, _hdc, rc.left, rc.top, SRCCOPY);
404  	if (_bPtOldValid)
405  	{	
406  		::PatBlt(hdcMem, rcOld.left  , rcOld.top  , rcOld.right  , rcOld.bottom  , PATINVERT);
407  		::PatBlt(hdcMem, rcOld.left+3, rcOld.top+3, rcOld.right-6, rcOld.bottom-6, PATINVERT);
408  	}
409  	if (pPt != NULL)
410  	{	
411  		::PatBlt(hdcMem, rcNew.left  , rcNew.top  , rcNew.right  , rcNew.bottom  , PATINVERT);
412  		::PatBlt(hdcMem, rcNew.left+3, rcNew.top+3, rcNew.right-6, rcNew.bottom-6, PATINVERT);
413  	}
414  	::BitBlt(_hdc, rc.left, rc.top, rc.right, rc.bottom, hdcMem, 0, 0, SRCCOPY);
415  	SelectObject(hdcMem, hbrushOrig);
416  	SelectObject(hdcMem, hbmOrig);
417  	DeleteObject(hBm);
418  	DeleteDC(hdcMem);
419  	if (pPt == NULL)
420  	{
421  		#if defined(USE_LOCKWINDOWUPDATE)
422  		::LockWindowUpdate(NULL);
423  		#endif
424  		_bPtOldValid = FALSE;
425  		if (_hdc)
426  		{
427  			::ReleaseDC(0, _hdc);
428  			_hdc = NULL;
429  		}
430  	}
431  	else
432  		_bPtOldValid = TRUE;
433  }
434  void Gripper::getMousePoints(POINT* pt, POINT* ptPrev)
435  {
436  	*ptPrev	= _ptOld;
437  	_ptOld	= *pt;
438  }
439  void Gripper::getMovingRect(POINT pt, RECT *rc)
440  {
441  	RECT			rcCorr			= {};
442  	DockingCont*	pContHit		= NULL;
443  	pContHit = contHitTest(pt);
444  	if (pContHit != NULL)
445  	{
446  		::GetWindowRect(pContHit->getHSelf(), rc);
447  		if (_pCont->isFloating() == TRUE)
448  			rcCorr = _pCont->getDataOfActiveTb()->rcFloat;
449  		else
450  			_pCont->getClientRect(rcCorr);
451  		ShrinkRcToSize(rc);
452  		ShrinkRcToSize(&rcCorr);
453  		DoCalcGripperRect(rc, rcCorr, pt);
454  	}
455  	else
456  	{
457  		pContHit = workHitTest(pt, rc);
458  		if (pContHit == NULL)
459  		{
460  			if (!_pCont->isFloating())
461  				*rc = _pCont->getDataOfActiveTb()->rcFloat;
462  			else
463  				_pCont->getWindowRect(*rc);
464  			_pCont->getClientRect(rcCorr);
465  			CalcRectToScreen(_dockData.hWnd, rc);
466  			CalcRectToScreen(_dockData.hWnd, &rcCorr);
467  			rc->left    = pt.x - _ptOffset.x;
468  			rc->top     = pt.y - _ptOffset.y;
469  			DoCalcGripperRect(rc, rcCorr, pt);
470  		}
471  	}
472  }
473  DockingCont* Gripper::contHitTest(POINT pt)
474  {
475  	vector<DockingCont*>	vCont	= _pDockMgr->getContainerInfo();
476  	HWND					hWnd	= ::WindowFromPoint(pt);
477  	for (size_t iCont = 0, len = vCont.size(); iCont < len; ++iCont)
478  	{
479  		if (hWnd == vCont[iCont]->getCaptionWnd())
480  		{
481  			if (vCont[iCont]->isFloating())
482  			{
483  				RECT	rc	= {};
484  				vCont[iCont]->getWindowRect(rc);
485  				if ((rc.top < pt.y) && (pt.y < (rc.top + 24)))
486  				{
487  					if (vCont[iCont] == _pCont)
488  					{
489  						return NULL;
490  					}
491  					else
492  					{
493  						return vCont[iCont];
494  					}
495  				}
496  			}
497  			else
498  			{
499  				return vCont[iCont];
500  			}
501  		}
502  		if (::IsWindowVisible(vCont[iCont]->getTabWnd()))
503  		{
504  			RECT		rc	= {};
505  			::GetWindowRect(vCont[iCont]->getTabWnd(), &rc);
506  			if (::PtInRect(&rc, pt))
507  			{
508  				return vCont[iCont];
509  			}
510  		}
511  	}
512  	return NULL;
513  }
514  DockingCont* Gripper::workHitTest(POINT pt, RECT *rc)
515  {
516  	RECT					rcCont	= {};
517  	vector<DockingCont*>	vCont	= _pDockMgr->getContainerInfo();
518  	for (size_t iCont = 0, len = vCont.size(); iCont < len; ++iCont)
519  	{
520  		if (vCont[iCont]->isVisible())
521  		{
522  			vCont[iCont]->getWindowRect(rcCont);
523  			if (::PtInRect(&rcCont, pt) == TRUE)
524  			{
525  				return NULL;
526  			}
527  		}
528  	}
529  	for (int iWork = 0; iWork < DOCKCONT_MAX; ++iWork)
530  	{
531  		if (!vCont[iWork]->isVisible())
532  		{
533  			rcCont = _dockData.rcRegion[iWork];
534  			rcCont.right  += rcCont.left;
535  			rcCont.bottom += rcCont.top;
536  			if (rc != NULL)
537  			{
538  				*rc = rcCont;
539  			}
540  			switch(iWork)
541  			{
542  				case CONT_LEFT:
543  					rcCont.right   = rcCont.left + HIT_TEST_THICKNESS;
544  					rcCont.left   -= HIT_TEST_THICKNESS;
545  					break;
546  				case CONT_RIGHT:
547  					rcCont.left    = rcCont.right - HIT_TEST_THICKNESS;
548  					rcCont.right  += HIT_TEST_THICKNESS;
549  					break;
550  				case CONT_TOP:
551  					rcCont.bottom  = rcCont.top + HIT_TEST_THICKNESS;
552  					rcCont.top    -= HIT_TEST_THICKNESS;
553  					break;
554  				case CONT_BOTTOM:
555  					rcCont.top     = rcCont.bottom - HIT_TEST_THICKNESS;
556  					rcCont.bottom += HIT_TEST_THICKNESS;
557  					break;
558  				default:
559  					break;
560  			}
561  			::MapWindowPoints(_dockData.hWnd, NULL, (LPPOINT)(&rcCont), 2);
562  			if (::PtInRect(&rcCont, pt) == TRUE)
563  			{
564  				if (rc != NULL)
565  				{
566  					::MapWindowPoints(_dockData.hWnd, NULL, (LPPOINT)(rc), 2);
567  					rc->right  -= rc->left;
568  					rc->bottom -= rc->top;
569  				}
570  				return vCont[iWork];
571  			}
572  		}
573  	}
574  	return NULL;
575  }
576  void Gripper::initTabInformation()
577  {
578  	_hTabSource = _pCont->getTabWnd();
579  	_startMovingFromTab	= _pCont->startMovingFromTab();
580  	if ((_startMovingFromTab == FALSE) && (::SendMessage(_hTabSource, TCM_GETITEMCOUNT, 0, 0) == 1))
581  	{
582  		_startMovingFromTab = TRUE;
583  		_iItem				= 0;
584  	}
585  	else
586  	{
587  		_iItem = static_cast<int32_t>(::SendMessage(_hTabSource, TCM_GETCURSEL, 0, 0));
588  	}
589  	_hTab = _hTabSource;
590  	::SendMessage(_hTabSource, TCM_GETITEMRECT, _iItem, reinterpret_cast<LPARAM>(&_rcItem));
591  	static TCHAR	szText[64];
592  	_tcItem.mask		= TCIF_PARAM | TCIF_TEXT;
593  	_tcItem.pszText		= szText;
594  	_tcItem.cchTextMax	= 64;
595  	::SendMessage(_hTabSource, TCM_GETITEM, _iItem, reinterpret_cast<LPARAM>(&_tcItem));
596  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Gripper.cpp</div>
                </div>
                <div class="column column_space"><pre><code>290    WNDCLASS WndClass;
291    WndClass.style=0;
292    WndClass.lpfnWndProc=MainWndProc;
293    WndClass.cbClsExtra=0;
294    WndClass.cbWndExtra=0;
295    FSAssert((WndClass.hInstance=GetModuleHandle(NULL))!=NULL);
</pre></code></div>
                <div class="column column_space"><pre><code>55  		WNDCLASS clz;
56  		clz.style = 0;
57  		clz.lpfnWndProc = staticWinProc;
58  		clz.cbClsExtra = 0;
59  		clz.cbWndExtra = 0;
60  		clz.hInstance = _hInst;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    