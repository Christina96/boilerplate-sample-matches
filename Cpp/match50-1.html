<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Tree.h & Client.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Tree.h & Client.h
      </h3>
      <h1 align="center">
        6.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Tree.h (9.027778%)<TH>Client.h (4.980843%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match50-0.html#0',2,'match50-1.html#0',3)" NAME="0">(43-93)<TD><A HREF="javascript:ZweiFrames('match50-0.html#0',2,'match50-1.html#0',3)" NAME="0">(185-238)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Tree.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Copyright (c) 2012 Stanford University
 * Copyright (c) 2014 Diego Ongaro
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &quot;Core/ProtoBuf.h&quot;

#ifndef LOGCABIN_TREE_TREE_H
#define LOGCABIN_TREE_TREE_H

namespace LogCabin {

// forward declaration
namespace Protocol {
class ServerStats_Tree;
}

namespace Tree {

/**
 * Status codes returned by Tree operations.
 */
enum class Status {

<A NAME="0"></A>    /**
     * The operation completed successfully.
     */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match50-1.html#0',3,'match50-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    OK = 0,

    /**
     * If an argument is malformed (for example, a path that does not start
     * with a slash).
     */
    INVALID_ARGUMENT = 1,

    /**
     * If a file or directory that is required for the operation does not
     * exist.
     */
    LOOKUP_ERROR = 2,

    /**
     * If a directory exists where a file is required or a file exists where
     * a directory is required. 
     */
    TYPE_ERROR = 3,

    /**
     * A predicate on an operation was not satisfied.
     */
    CONDITION_NOT_MET = 4,
};

/**
 * Print a status code to a stream.
 */
std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, Status status);

/**
 * Returned by Tree operations; contain a status code and an error message.
 */
struct Result {
    /**
     * Default constructor. Sets status to OK and error to the empty string.
     */
    Result();
    /**
     * A code for whether an operation succeeded or why it did not. This is
     * meant to be used programmatically.
     */
    Status status;
    /**
     * If status is not OK, this is a human-readable message describing what
     * went wrong.
     */
    std::string error;
};</B></FONT>

namespace Internal {

/**
 * A leaf object in the Tree; stores an opaque blob of data.
 */
class File {
  public:
    /// Default constructor.
    File();
    /**
     * Write the file to the stream.
     */
    void dumpSnapshot(Core::ProtoBuf::OutputStream&amp; stream) const;
    /**
     * Load the file from the stream.
     */
    void loadSnapshot(Core::ProtoBuf::InputStream&amp; stream);
    /**
     * Opaque data stored in the File.
     */
    std::string contents;
};

/**
 * An interior object in the Tree; stores other Directories and Files.
 * Pointers returned by this class are valid until the File or Directory they
 * refer to is removed.
 */
class Directory {
  public:
    /// Default constructor.
    Directory();

    /**
     * List the contents of the directory.
     * \return
     *      The names of the directories and files that this directory
     *      immediately contains. The names of directories in this listing will
     *      have a trailing slash. The order is first directories (sorted
     *      lexicographically), then files (sorted lexicographically).
     */
    std::vector&lt;std::string&gt; getChildren() const;

    /**
     * Find the child directory by the given name.
     * \param name
     *      Must not contain a trailing slash.
     * \return
     *      The directory by the given name, or
     *      NULL if it is not found or a file exists by that name.
     */
    Directory* lookupDirectory(const std::string&amp; name);
    /**
     * Find the child directory by the given name (const version).
     * \copydetails lookupDirectory
     */
    const Directory* lookupDirectory(const std::string&amp; name) const;
    /**
     * Find the child directory by the given name, or create it if it doesn't
     * exist.
     * \param name
     *      Must not contain a trailing slash.
     * \return
     *      The directory by the given name, or
     *      NULL if a file exists by that name.
     */
    Directory* makeDirectory(const std::string&amp; name);
    /**
     * Remove the child directory by the given name, if any. This will remove
     * all the contents of the directory as well.
     * \param name
     *      Must not contain a trailing slash.
     */
    void removeDirectory(const std::string&amp; name);

    /**
     * Find the child file by the given name.
     * \param name
     *      Must not contain a trailing slash.
     * \return
     *      The file by the given name, or
     *      NULL if it is not found or a directory exists by that name.
     */
    File* lookupFile(const std::string&amp; name);
    /**
     * Find the child file by the given name (const version).
     * \copydetails lookupFile
     */
    const File* lookupFile(const std::string&amp; name) const;
    /**
     * Find the child file by the given name, or create it if it doesn't exist.
     * \param name
     *      Must not contain a trailing slash.
     * \return
     *      The file by the given name, or
     *      NULL if a directory exists by that name.
     */
    File* makeFile(const std::string&amp; name);
    /**
     * Remove the child file by the given name, if any.
     * \param name
     *      Must not contain a trailing slash.
     * \return
     *      True if child file removed, false if no such file existed. This is
     *      mostly useful for counting statistics.
     */
    bool removeFile(const std::string&amp; name);

    /**
     * Write the directory and its children to the stream.
     */
    void dumpSnapshot(Core::ProtoBuf::OutputStream&amp; stream) const;
    /**
     * Load the directory and its children from the stream.
     */
    void loadSnapshot(Core::ProtoBuf::InputStream&amp; stream);

  private:
    /**
     * Map from names of child directories (without trailing slashes) to the
     * Directory objects.
     */
    std::map&lt;std::string, Directory&gt; directories;
    /**
     * Map from names of child files to the File objects.
     */
    std::map&lt;std::string, File&gt; files;
};

/**
 * This is used by Tree to parse symbolic paths into their components.
 */
class Path {
  public:
    /**
     * Constructor.
     * \param symbolic
     *      A path delimited by slashes. This must begin with a slash.
     *      (It should not include &quot;/root&quot; to arrive at the root directory.)
     * \warning
     *      The caller must check &quot;result&quot; to see if the path was parsed
     *      successfully.
     */
    explicit Path(const std::string&amp; symbolic);

    /**
     * Used to generate error messages during path lookup.
     * \param end
     *      The last component of 'parents' to include in the returned string;
     *      this is typically the component that caused an error in path
     *      traversal.
     * \return
     *      The prefix of 'parents' up to and including the given end position.
     *      This is returned as a slash-delimited string not including &quot;/root&quot;.
     */
    std::string
    parentsThrough(std::vector&lt;std::string&gt;::const_iterator end) const;

  public:
    /**
     * Status and error message from the constructor. Possible errors are:
     * - INVALID_ARGUMENT if path is malformed.
     */
    Result result;

    /**
     * The exact argument given to the constructor.
     */
    std::string symbolic;
    /**
     * The directories needed to traverse to get to the target.
     * This usually begins with &quot;root&quot; to get from the super root to the root
     * directory, then includes the components of the symbolic path up to but
     * not including the target. If the symbolic path is &quot;/&quot;, this will be
     * empty.
     */
    std::vector&lt;std::string&gt; parents;
    /**
     * The final component of the path.
     * This is usually at the end of the symbolic path. If the symbolic path is
     * &quot;/&quot;, this will be &quot;root&quot;, used to get from the super root to the root
     * directory.
     */
    std::string target;
};

} // LogCabin::Tree::Internal

/**
 * This is an in-memory, hierarchical key-value store.
 * TODO(ongaro): Document how this fits into the rest of the system.
 */
class Tree {
  public:
    /**
     * Constructor.
     */
    Tree();

    /**
     * Write the tree to the given stream.
     */
    void dumpSnapshot(Core::ProtoBuf::OutputStream&amp; stream) const;

    /**
     * Load the tree from the given stream.
     * \warning
     *      This will blow away any existing files and directories.
     */
    void loadSnapshot(Core::ProtoBuf::InputStream&amp; stream);

    /**
     * Verify that the file at path has the given contents.
     * \param path
     *      The path to the file that must have the contents specified in
     *      'contents'.
     * \param contents
     *      The contents that the file specified by 'path' should have for an
     *      OK response. An OK response is also returned if 'contents' is the
     *      empty string and the file specified by 'path' does not exist.
     * \return
     *      Status and error message. Possible errors are:
     *       - CONDITION_NOT_MET upon any error.
     */
    Result
    checkCondition(const std::string&amp; path,
                   const std::string&amp; contents) const;

    /**
     * Make sure a directory exists at the given path.
     * Create parent directories listed in path as necessary.
     * \param path
     *      The path where there should be a directory after this call.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a file.
     */
    Result
    makeDirectory(const std::string&amp; path);

    /**
     * List the contents of a directory.
     * \param path
     *      The directory whose direct children to list.
     * \param[out] children
     *      This will be replaced by a listing of the names of the directories
     *      and files that the directory at 'path' immediately contains. The
     *      names of directories in this listing will have a trailing slash.
     *      The order is first directories (sorted lexicographically), then
     *      files (sorted lexicographically).
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - LOOKUP_ERROR if a parent of path does not exist.
     *       - LOOKUP_ERROR if path does not exist.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a file.
     */
    Result
    listDirectory(const std::string&amp; path,
                  std::vector&lt;std::string&gt;&amp; children) const;

    /**
     * Make sure a directory does not exist.
     * Also removes all direct and indirect children of the directory.
     *
     * If called with the root directory, this will remove all descendants but
     * not actually remove the root directory; it will still return status OK.
     *
     * \param path
     *      The path where there should not be a directory after this call.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a file.
     */
    Result
    removeDirectory(const std::string&amp; path);

    /**
     * Set the value of a file.
     * \param path
     *      The path where there should be a file with the given contents after
     *      this call.
     * \param contents
     *      The new value associated with the file.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - INVALID_ARGUMENT if contents are too large to fit in a file.
     *       - LOOKUP_ERROR if a parent of path does not exist.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a directory.
     */
    Result
    write(const std::string&amp; path, const std::string&amp; contents);

    /**
     * Get the value of a file.
     * \param path
     *      The path of the file whose contents to read.
     * \param contents
     *      The current value associated with the file.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - LOOKUP_ERROR if a parent of path does not exist.
     *       - LOOKUP_ERROR if path does not exist.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path is a directory.
     */
    Result
    read(const std::string&amp; path, std::string&amp; contents) const;

    /**
     * Make sure a file does not exist.
     * \param path
     *      The path where there should not be a file after this call.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a directory.
     */
    Result
    removeFile(const std::string&amp; path);

    /**
     * Add metrics about the tree to the given structure.
     */
    void
    updateServerStats(Protocol::ServerStats_Tree&amp; tstats) const;

  private:
    /**
     * Resolve the final next-to-last component of the given path (the target's
     * parent).
     * \param[in] path
     *      The path whose parent directory to find.
     * \param[out] parent
     *      Upon successful return, points to the target's parent directory.
     * \return
     *      Status and error message. Possible errors are:
     *       - LOOKUP_ERROR if a parent of path does not exist.
     *       - TYPE_ERROR if a parent of path is a file.
     */
    Result
    normalLookup(const Internal::Path&amp; path,
                 Internal::Directory** parent);

    /**
     * Resolve the final next-to-last component of the given path (the target's
     * parent) -- const version.
     * \copydetails normalLookup
     */
    Result
    normalLookup(const Internal::Path&amp; path,
                 const Internal::Directory** parent) const;

    /**
     * Like normalLookup but creates parent directories as necessary.
     * \param[in] path
     *      The path whose parent directory to find.
     * \param[out] parent
     *      Upon successful return, points to the target's parent directory.
     * \return
     *      Status and error message. Possible errors are:
     *       - TYPE_ERROR if a parent of path is a file.
     */
    Result
    mkdirLookup(const Internal::Path&amp; path, Internal::Directory** parent);

    /**
     * This directory contains the root directory. The super root has a single
     * child directory named &quot;root&quot;, and the rest of the tree lies below
     * &quot;root&quot;. This is just an implementation detail; this class prepends
     * &quot;/root&quot; to every path provided by the caller.
     *
     * This removes a lot of special-case branches because every operation now
     * has a name of a target within a parent directory -- even those operating
     * on the root directory.
     */
    Internal::Directory superRoot;

    // Server stats collected in updateServerStats.
    // Note that when a condition fails, the operation is not invoked,
    // so operations whose conditions fail are not counted as 'Attempted'.
    mutable uint64_t numConditionsChecked;
    mutable uint64_t numConditionsFailed;
    uint64_t numMakeDirectoryAttempted;
    uint64_t numMakeDirectorySuccess;
    mutable uint64_t numListDirectoryAttempted;
    mutable uint64_t numListDirectorySuccess;
    uint64_t numRemoveDirectoryAttempted;
    uint64_t numRemoveDirectoryParentNotFound;
    uint64_t numRemoveDirectoryTargetNotFound;
    uint64_t numRemoveDirectoryDone;
    uint64_t numRemoveDirectorySuccess;
    uint64_t numWriteAttempted;
    uint64_t numWriteSuccess;
    mutable uint64_t numReadAttempted;
    mutable uint64_t numReadSuccess;
    uint64_t numRemoveFileAttempted;
    uint64_t numRemoveFileParentNotFound;
    uint64_t numRemoveFileTargetNotFound;
    uint64_t numRemoveFileDone;
    uint64_t numRemoveFileSuccess;
};


} // namespace LogCabin::Tree
} // namespace LogCabin

#endif // LOGCABIN_TREE_TREE_H
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Client.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Copyright (c) 2011-2014 Stanford University
 * Copyright (c) 2014-2015 Diego Ongaro
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * \file
 * This file declares the interface for LogCabin's client library.
 */

#include &lt;cstddef&gt;
#include &lt;memory&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#ifndef LOGCABIN_INCLUDE_LOGCABIN_CLIENT_H
#define LOGCABIN_INCLUDE_LOGCABIN_CLIENT_H

namespace LogCabin {

// forward declarations
namespace Core {
namespace Debug {
} // namespace LogCabin::Core::Debug
} // namespace LogCabin::Core

// forward declarations
namespace Protocol {
class ServerStats;
namespace Client {
class StateMachineQuery_Request;
class StateMachineQuery_Response;
class StateMachineCommand_Request;
class StateMachineCommand_Response;
} // namespace LogCabin::Protocol::Client
} // namespace LogCabin::Protocol

namespace Client {

class ClientImpl; // forward declaration
class TreeDetails; // forward declaration

// To control how the debug log operates, clients should
// #include &lt;LogCabin/Debug.h&gt;
// and access it through
// LogCabin::Client::Debug.
namespace Debug = Core::Debug;

/**
 * A member of the cluster Configuration.
 */
struct Server {
    /// Constructor.
    Server(uint64_t serverId, const std::string&amp; addresses);
    /// Default constructor.
    Server();
    /// Copy constructor.
    Server(const Server&amp; other);
    /// Destructor.
    ~Server();
    /// Copy assignment.
    Server&amp; operator=(const Server&amp; other);

    /**
     * The unique ID of the server.
     */
    uint64_t serverId;

    /**
     * The network addresses of the server (comma-delimited).
     */
    std::string addresses;
};

/**
 * Defines the members of the cluster.
 * Used in Cluster::getConfiguration and Cluster::setConfiguration.
 */
typedef std::vector&lt;Server&gt; Configuration;

/**
 * Returned by Cluster::setConfiguration.
 */
struct ConfigurationResult {
    ConfigurationResult();
    ~ConfigurationResult();

    enum Status {
        /**
         * The operation succeeded.
         */
        OK = 0,
        /**
         * The supplied 'oldId' is no longer current.
         * Call GetConfiguration, re-apply your changes, and try again.
         */
        CHANGED = 1,
        /**
         * The reconfiguration was aborted because some servers are
         * unavailable.
         */
        BAD = 2,
        /**
         * The reconfiguration could not be completed in the requested
         * timeframe.
         * \since LogCabin v1.2.0
         */
        TIMEOUT = 3,
    } status;

    /**
     * If status is BAD, the servers that were unavailable to join the cluster.
     */
    Configuration badServers;

    /**
     * Error message, if status is not OK.
     */
    std::string error;
};

/**
 * Returned by Cluster::getConfiguration2().
 * \since LogCabin v1.2.0
 */
struct GetConfigurationResult {
    GetConfigurationResult();
    ~GetConfigurationResult();

    enum Status {
        /**
         * The operation succeeded.
         */
        OK = 0,
        /**
         * The call could not be completed in the requested timeframe.
         */
        TIMEOUT = 1,
    } status;

    /**
     * If status is OK, identifies the configuration. Pass this to
     * setConfiguration later.
     */
    uint64_t configuration;

    /**
     * If status is OK, the list of servers in the configuration.
     */
    Configuration servers;

    /**
     * Error message, if status is not OK.
     */
    std::string error;
};

/**
 * Status codes returned by Tree operations.
 */
enum class Status {

    /**
     * The operation completed successfully.
     */
    OK = 0,

    /**
<A NAME="0"></A>     * If an argument is malformed (for example, a path that does not start
     * with a slash).
     */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match50-0.html#0',2,'match50-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    INVALID_ARGUMENT = 1,

    /**
     * If a file or directory that is required for the operation does not
     * exist.
     */
    LOOKUP_ERROR = 2,

    /**
     * If a directory exists where a file is required or a file exists where
     * a directory is required.
     */
    TYPE_ERROR = 3,

    /**
     * A predicate which was previously set on operations with
     * Tree::setCondition() was not satisfied.
     */
    CONDITION_NOT_MET = 4,

    /**
     * A timeout specified by Tree::setTimeout() elapsed while waiting for
     * an operation to complete. It is not known whether the operation has or
     * will complete, only that a positive acknowledgment was not received
     * before the timeout elapsed.
     */
    TIMEOUT = 5,
};

/**
 * Print a status code to a stream.
 */
std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, Status status);

/**
 * Returned by Tree operations; contain a status code and an error message.
 */
struct Result {
    /**
     * Default constructor. Sets status to OK and error to the empty string.
     */
    Result();
    /**
     * A code for whether an operation succeeded or why it did not. This is
     * meant to be used programmatically.
     */
    Status status;
    /**
     * If status is not OK, this is a human-readable message describing what
     * went wrong.
     */
    std::string error;
};</B></FONT>

/**
 * Base class for LogCabin client exceptions.
 */
class Exception : public std::runtime_error {
  public:
    explicit Exception(const std::string&amp; error);
};

/**
 * See Status::INVALID_ARGUMENT.
 */
class InvalidArgumentException : public Exception {
  public:
    explicit InvalidArgumentException(const std::string&amp; error);
};

/**
 * See Status::LOOKUP_ERROR.
 */
class LookupException : public Exception {
  public:
    explicit LookupException(const std::string&amp; error);
};

/**
 * See Status::TYPE_ERROR.
 */
class TypeException : public Exception {
  public:
    explicit TypeException(const std::string&amp; error);
};

/**
 * See Status::CONDITION_NOT_MET.
 */
class ConditionNotMetException : public Exception {
  public:
    explicit ConditionNotMetException(const std::string&amp; error);
};

/**
 * See Status::TIMEOUT.
 */
class TimeoutException : public Exception {
  public:
    explicit TimeoutException(const std::string&amp; error);
};

/**
 * See ConfigurationResult::BAD
 * \since LogCabin v1.2.0
 */
class ConfigurationExceptionBad : public Exception {
  public:
    explicit ConfigurationExceptionBad(const std::string&amp; error);
};

/**
 * See ConfigurationResult::CHANGED
 * \since LogCabin v1.2.0
 */
class ConfigurationExceptionChanged : public Exception {
  public:
    explicit ConfigurationExceptionChanged(const std::string&amp; error);
};

/**
 * Provides access to the hierarchical key-value store.
 * You can get an instance of Tree through Cluster::getTree() or by copying
 * an existing Tree.
 *
 * A Tree has a working directory from which all relative paths (those that do
 * not begin with a '/' are resolved). This allows different applications and
 * modules to conveniently access their own subtrees -- they can have their own
 * Tree instances and set their working directories accordingly.
 *
 * Methods that can fail come in two flavors. The first flavor returns Result
 * values with error codes and messages; the second throws exceptions upon
 * errors. These can be distinguished by the &quot;Ex&quot; suffix in the names of
 * methods that throw exceptions.
 */
class Tree {
  private:
    /// Constructor.
    Tree(std::shared_ptr&lt;ClientImpl&gt; clientImpl,
         const std::string&amp; workingDirectory);
  public:
    /// Copy constructor.
    Tree(const Tree&amp; other);
    /// Assignment operator.
    Tree&amp; operator=(const Tree&amp; other);

    /**
     * Set the working directory for this object. This directory will be
     * created if it does not exist.
     * \param workingDirectory
     *      The new working directory, which may be relative to the current
     *      working directory.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if workingDirectory is malformed.
     *       - TYPE_ERROR if parent of workingDirectory is a file.
     *       - TYPE_ERROR if workingDirectory exists but is a file.
     *       - CONDITION_NOT_MET if predicate from setCondition() was false.
     *       - TIMEOUT if timeout elapsed before the operation completed.
     *      If this returns an error, future operations on this tree using
     *      relative paths will fail until a valid working directory is set.
     */
    Result setWorkingDirectory(const std::string&amp; workingDirectory);

    /**
     * Like setWorkingDirectory but throws exceptions upon errors.
     */
    void setWorkingDirectoryEx(const std::string&amp; workingDirectory);

    /**
     * Return the working directory for this object.
     * \return
     *      An absolute path that is the prefix for relative paths used with
     *      this Tree object.
     */
    std::string getWorkingDirectory() const;

    /**
     * Return the condition set by a previous call to setCondition().
     * \return
     *      First component: the absolute path corresponding to the 'path'
     *      argument of setCondition().
     *      Second component: the file contents given as the 'value' argument
     *      of setCondition().
     */
    std::pair&lt;std::string, std::string&gt; getCondition() const;

    /**
     * Set a predicate on all future operations. Future operations will return
     * Status::CONDITION_NOT_MET and have no effect unless the file at 'path'
     * has the contents 'value'. To remove the predicate, pass an empty string
     * as 'path'.
     * \param path
     *      The relative or absolute path to the file that must have the
     *      contents specified in value, or an empty string to clear the
     *      condition.
     * \param value
     *      The contents that the file specified by 'path' must have for future
     *      operations to succeed. If 'value' is the empty string and the
     *      file does not exist, the condition will also be satisfied.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *      If this returns an error, future operations on this tree will fail
     *      until a new condition is set or the condition is cleared.
     */
    Result setCondition(const std::string&amp; path, const std::string&amp; value);

    /**
     * Like setCondition but throws exceptions upon errors.
     */
    void setConditionEx(const std::string&amp; path, const std::string&amp; value);

    /**
     * Return the timeout set by a previous call to setTimeout().
     * \return
     *      The maximum duration of each operation (in nanoseconds), or 0
     *      for no timeout.
     */
    uint64_t getTimeout() const;

    /**
     * Abort each future operation if it may not have completed within the
     * specified period of time.
     * \warning
     *      The client library does not currently implement timeouts for DNS
     *      lookups. See https://github.com/logcabin/logcabin/issues/75
     * \param nanoseconds
     *      The maximum duration of each operation (in nanoseconds). Set to 0
     *      for no timeout.
     */
    void setTimeout(uint64_t nanoseconds);

    /**
     * Make sure a directory exists at the given path.
     * Create parent directories listed in path as necessary.
     * \param path
     *      The path where there should be a directory after this call.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a file.
     *       - CONDITION_NOT_MET if predicate from setCondition() was false.
     *       - TIMEOUT if timeout elapsed before the operation completed.
     */
    Result
    makeDirectory(const std::string&amp; path);

    /**
     * Like makeDirectory but throws exceptions upon errors.
     */
    void makeDirectoryEx(const std::string&amp; path);

    /**
     * List the contents of a directory.
     * \param path
     *      The directory whose direct children to list.
     * \param[out] children
     *      This will be replaced by a listing of the names of the directories
     *      and files that the directory at 'path' immediately contains. The
     *      names of directories in this listing will have a trailing slash.
     *      The order is first directories (sorted lexicographically), then
     *      files (sorted lexicographically).
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - LOOKUP_ERROR if a parent of path does not exist.
     *       - LOOKUP_ERROR if path does not exist.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a file.
     *       - CONDITION_NOT_MET if predicate from setCondition() was false.
     *       - TIMEOUT if timeout elapsed before the operation completed.
     */
    Result
    listDirectory(const std::string&amp; path,
                  std::vector&lt;std::string&gt;&amp; children) const;

    /**
     * Like listDirectory but throws exceptions upon errors.
     */
    std::vector&lt;std::string&gt; listDirectoryEx(const std::string&amp; path) const;

    /**
     * Make sure a directory does not exist.
     * Also removes all direct and indirect children of the directory.
     *
     * If called with the root directory, this will remove all descendants but
     * not actually remove the root directory; it will still return status OK.
     *
     * \param path
     *      The path where there should not be a directory after this call.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a file.
     *       - CONDITION_NOT_MET if predicate from setCondition() was false.
     *       - TIMEOUT if timeout elapsed before the operation completed.
     */
    Result
    removeDirectory(const std::string&amp; path);

    /**
     * Like removeDirectory but throws exceptions upon errors.
     */
    void
    removeDirectoryEx(const std::string&amp; path);

    /**
     * Set the value of a file.
     * \param path
     *      The path where there should be a file with the given contents after
     *      this call.
     * \param contents
     *      The new value associated with the file.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - INVALID_ARGUMENT if contents are too large to fit in a file.
     *       - LOOKUP_ERROR if a parent of path does not exist.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a directory.
     *       - CONDITION_NOT_MET if predicate from setCondition() was false.
     *       - TIMEOUT if timeout elapsed before the operation completed.
     */
    Result
    write(const std::string&amp; path, const std::string&amp; contents);

    /**
     * Like write but throws exceptions upon errors.
     */
    void
    writeEx(const std::string&amp; path, const std::string&amp; contents);

    /**
     * Get the value of a file.
     * \param path
     *      The path of the file whose contents to read.
     * \param contents
     *      The current value associated with the file.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - LOOKUP_ERROR if a parent of path does not exist.
     *       - LOOKUP_ERROR if path does not exist.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path is a directory.
     *       - CONDITION_NOT_MET if predicate from setCondition() was false.
     *       - TIMEOUT if timeout elapsed before the operation completed.
     */
    Result
    read(const std::string&amp; path, std::string&amp; contents) const;

    /**
     * Like read but throws exceptions upon errors.
     */
    std::string
    readEx(const std::string&amp; path) const;

    /**
     * Make sure a file does not exist.
     * \param path
     *      The path where there should not be a file after this call.
     * \return
     *      Status and error message. Possible errors are:
     *       - INVALID_ARGUMENT if path is malformed.
     *       - TYPE_ERROR if a parent of path is a file.
     *       - TYPE_ERROR if path exists but is a directory.
     *       - CONDITION_NOT_MET if predicate from setCondition() was false.
     *       - TIMEOUT if timeout elapsed before the operation completed.
     */
    Result
    removeFile(const std::string&amp; path);

    /**
     * Like removeFile but throws exceptions upon errors.
     */
    void
    removeFileEx(const std::string&amp; path);

  private:
    /**
     * Get a reference to the implementation-specific members of this class.
     */
    std::shared_ptr&lt;const TreeDetails&gt; getTreeDetails() const;
    /**
     * Provides mutual exclusion to treeDetails pointer.
     */
    mutable std::mutex mutex;
    /**
     * Reference-counted pointer to implementation-specific members. This is
     * copy-on-write, so 'mutex' need not be held after taking a reference to
     * treeDetails.
     */
    std::shared_ptr&lt;const TreeDetails&gt; treeDetails;
    friend class Cluster;
};

/**
 * When running in testing mode, these callbacks serve as a way for the
 * application to interpose on requests and responses to inject failures and
 * model dynamic scenarios. See Cluster's constructor for more information.
 *
 * This is experimental and is not part of LogCabin's public API.
 */
class TestingCallbacks {
  public:

    /**
     * Constructor. Does nothing.
     */
    TestingCallbacks();

    /**
     * Destructor. Does nothing.
     */
    virtual ~TestingCallbacks();

    /**
     * Handle a read-only state machine query, such as Tree::read or
     * Tree::listDirectory.
     * The default implementation just returns false.
     * \param[in,out] request
     *      Protocol buffer containing request details. You can modify this and
     *      return false to have a slightly different request executed against
     *      the in-memory data structure.
     * \param[out] response
     *      Protocol buffer where response details should be filled in if true
     *      is returned.
     * \return
     *      True if handled, false to query the in-memory data structure.
     */
    virtual bool stateMachineQuery(
        Protocol::Client::StateMachineQuery_Request&amp; request,
        Protocol::Client::StateMachineQuery_Response&amp; response);

    /**
     * Handle a read-write state machine command, such as Tree::read or
     * Tree::listDirectory.
     * The default implementation just returns false.
     * \param[in,out] request
     *      Protocol buffer containing request details. You can modify this and
     *      return false to have a slightly different request executed against
     *      the in-memory data structure.
     * \param[out] response
     *      Protocol buffer where response details should be filled in if true
     *      is returned.
     * \return
     *      True if handled, false to query the in-memory data structure.
     */
    virtual bool stateMachineCommand(
        Protocol::Client::StateMachineCommand_Request&amp; request,
        Protocol::Client::StateMachineCommand_Response&amp; response);
};


/**
 * A handle to the LogCabin cluster.
 *
 * If the client requests changes to the cluster's replicated state machine
 * (for example, by writing a value), the client library will first open a
 * session with the cluster. It will thereafter periodically send keep-alive
 * requests to the cluster during periods of inactivity to maintain this
 * session. If communication to the LogCabin cluster is lost for an extended
 * period of time, the client's session will expire, and this library will
 * force the client to crash.
 */
class Cluster {
  public:

    /**
     * Settings for the client library. These are all optional.
     * Currently supported options:
     * - clusterUUID (see sample.conf)
     * - tcpHeartbeatTimeoutMilliseconds (see sample.conf)
     * - tcpConnectTimeoutMilliseconds (see sample.conf)
     * - sessionCloseTimeoutMilliseconds:
     *      This Cluster object opens a session with LogCabin before issuing
     *      any read-write commands to the replicated state machine. When this
     *      Cluster object is destroyed, it will attempt to close its session
     *      gracefully. This timeout controls the number of milliseconds that
     *      the client will wait until giving up on the close session RPC. It
     *      defaults to tcpConnectTimeoutMilliseconds, since they should be on
     *      the same order of magnitude.
     */
    typedef std::map&lt;std::string, std::string&gt; Options;

    /**
     * Construct a Cluster object for testing purposes only. Instead of
     * connecting to a LogCabin cluster, it will keep all state locally in
     * memory.
     *
     * This is experimental and is not part of LogCabin's public API.
     *
     * \param testingCallbacks
     *      These allow the application to interpose on requests. A
     *      default-constructed TestingCallbacks will execute requests against
     *      an in-memory structure. Applications can pass in classes derived
     *      from TestingCallbacks to model failures and more dynamic scenarios.
     * \param options
     *      Settings for the client library (see #Options).
     */
    explicit Cluster(std::shared_ptr&lt;TestingCallbacks&gt; testingCallbacks,
                     const Options&amp; options = Options());

    /**
     * Constructor.
     * \param hosts
     *      A string describing the hosts in the cluster. This should be of the
     *      form host:port, where host is usually a DNS name that resolves to
     *      multiple IP addresses. Alternatively, you can pass a list of hosts
     *      as host1:port1,host2:port2,host3:port3.
     * \param options
     *      Settings for the client library (see #Options).
     */
    explicit Cluster(const std::string&amp; hosts,
                     const Options&amp; options = Options());

    /**
     * Destructor.
     */
    ~Cluster();

    /**
     * Get the current, stable cluster configuration.
     * \return
     *      first: configurationId: Identifies the configuration.
     *             Pass this to setConfiguration later.
     *      second: The list of servers in the configuration.
     */
    std::pair&lt;uint64_t, Configuration&gt; getConfiguration() const;

    /**
     * Get the current, stable cluster configuration.
     * \param timeoutNanoseconds
     *      Amount of time to wait for getConfiguration to
     *      complete. Passing 0 indicates that no timeout is desired.
     * \return
     *      See GetConfigurationResult
     * \since LogCabin v1.2.0.
     */
    GetConfigurationResult getConfiguration2(
                                uint64_t timeoutNanoseconds) const;

    /**
     * Like getConfiguration2 but throws exceptions upon errors.
     * \since LogCabin v1.2.0.
     */
    GetConfigurationResult getConfiguration2Ex(
                                uint64_t timeoutNanoseconds) const;

    /**
     * Change the cluster's configuration.
     * \param oldId
     *      The ID of the cluster's current configuration.
     * \param newConfiguration
     *      The list of servers in the new configuration.
     */
    ConfigurationResult setConfiguration(
                                uint64_t oldId,
                                const Configuration&amp; newConfiguration);

    /**
     * Like setConfiguration but allows a timeout.
     * \param oldId
     *      The ID of the cluster's current configuration.
     * \param newConfiguration
     *      The list of servers in the new configuration.
     * \param timeoutNanoseconds
     *      Amount of time to wait for the call to complete. 0=wait
     *      forever
     * \since LogCabin v1.2.0.
     */
    ConfigurationResult setConfiguration2(
                                uint64_t oldId,
                                const Configuration&amp; newConfiguration,
                                uint64_t timeoutNanoseconds);
    /**
     * Like setConfiguration2 but throws exceptions upon errors.
     * \since LogCabin v1.2.0.
     */
    ConfigurationResult setConfiguration2Ex(
                                uint64_t oldId,
                                const Configuration&amp; newConfiguration,
                                uint64_t timeoutNanoseconds);

    /**
     * Retrieve basic information from the given server, like its ID and the
     * addresses on which it is listening.
     * \param host
     *      The hostname or IP address of the server to retrieve stats from. It
     *      is recommended that you do not use a DNS name that resolves to
     *      multiple hosts here.
     * \param timeoutNanoseconds
     *      Abort the operation if it has not completed within the specified
     *      period of time. Time is specified in nanoseconds, and the special
     *      value of 0 indicates no timeout.
     * \warning
     *      The client library does not currently implement timeouts for DNS
     *      lookups. See https://github.com/logcabin/logcabin/issues/75
     * \param[out] info
     *      Protocol buffer of Stats as retrieved from the server.
     * \return
     *      Either OK or TIMEOUT.
     */
    Result
    getServerInfo(const std::string&amp; host,
                  uint64_t timeoutNanoseconds,
                  Server&amp; info);
    /**
     * Like getServerInfo but throws exceptions upon errors.
     */
    Server
    getServerInfoEx(const std::string&amp; host,
                    uint64_t timeoutNanoseconds);

    /**
     * Retrieve statistics from the given server, which are useful for
     * diagnostics.
     * \param host
     *      The hostname or IP address of the server to retrieve stats from. It
     *      is recommended that you do not use a DNS name that resolves to
     *      multiple hosts here.
     * \param timeoutNanoseconds
     *      Abort the operation if it has not completed within the specified
     *      period of time. Time is specified in nanoseconds, and the special
     *      value of 0 indicates no timeout.
     * \warning
     *      The client library does not currently implement timeouts for DNS
     *      lookups. See https://github.com/logcabin/logcabin/issues/75
     * \param[out] stats
     *      Protocol buffer of Stats as retrieved from the server.
     * \return
     *      Either OK or TIMEOUT.
     */
    Result
    getServerStats(const std::string&amp; host,
                   uint64_t timeoutNanoseconds,
                   Protocol::ServerStats&amp; stats);
    /**
     * Like getServerStats but throws exceptions upon errors.
     */
    Protocol::ServerStats
    getServerStatsEx(const std::string&amp; host,
                     uint64_t timeoutNanoseconds);

    /**
     * Return an object to access the hierarchical key-value store.
     * \return
     *      A Tree object with the working directory of '/'.
     */
    Tree getTree();

  private:
    std::shared_ptr&lt;ClientImpl&gt; clientImpl;
};

} // namespace LogCabin::Client
} // namespace LogCabin

#endif /* LOGCABIN_INCLUDE_LOGCABIN_CLIENT_H */
</PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
