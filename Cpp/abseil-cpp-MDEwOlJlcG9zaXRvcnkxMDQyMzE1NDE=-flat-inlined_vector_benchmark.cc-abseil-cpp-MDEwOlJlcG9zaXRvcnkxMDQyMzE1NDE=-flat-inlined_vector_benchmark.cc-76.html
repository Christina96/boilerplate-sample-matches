
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 46, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</h3>
            <pre><code>1  #include &lt;array&gt;
2  #include &lt;string&gt;
3  #include &lt;vector&gt;
4  #include &quot;absl/base/internal/raw_logging.h&quot;
5  #include &quot;absl/base/macros.h&quot;
6  #include &quot;absl/container/inlined_vector.h&quot;
7  #include &quot;absl/strings/str_cat.h&quot;
8  #include &quot;benchmark/benchmark.h&quot;
9  namespace {
10  void BM_InlinedVectorFill(benchmark::State&amp; state) {
11    const int len = state.range(0);
12    absl::InlinedVector&lt;int, 8&gt; v;
13    v.reserve(len);
14    for (auto _ : state) {
15      v.resize(0);  
16      for (int i = 0; i &lt; len; ++i) {
17        v.push_back(i);
18      }
19      benchmark::DoNotOptimize(v);
20    }
21  }
22  BENCHMARK(BM_InlinedVectorFill)-&gt;Range(1, 256);
23  void BM_InlinedVectorFillRange(benchmark::State&amp; state) {
24    const int len = state.range(0);
25    const std::vector&lt;int&gt; src(len, len);
26    absl::InlinedVector&lt;int, 8&gt; v;
27    v.reserve(len);
28    for (auto _ : state) {
29      benchmark::DoNotOptimize(src);
30      v.assign(src.begin(), src.end());
31      benchmark::DoNotOptimize(v);
32    }
33  }
34  BENCHMARK(BM_InlinedVectorFillRange)-&gt;Range(1, 256);
35  void BM_StdVectorFill(benchmark::State&amp; state) {
36    const int len = state.range(0);
37    std::vector&lt;int&gt; v;
38    v.reserve(len);
39    for (auto _ : state) {
40      v.clear();
41      for (int i = 0; i &lt; len; ++i) {
42        v.push_back(i);
43      }
44      benchmark::DoNotOptimize(v);
45    }
46  }
47  BENCHMARK(BM_StdVectorFill)-&gt;Range(1, 256);
48  bool StringRepresentedInline(std::string s) {
49    const char* chars = s.data();
50    std::string s1 = std::move(s);
51    return s1.data() != chars;
52  }
53  int GetNonShortStringOptimizationSize() {
54    for (int i = 24; i &lt;= 192; i *= 2) {
55      if (!StringRepresentedInline(std::string(i, &#x27;A&#x27;))) {
56        return i;
57      }
58    }
59    ABSL_RAW_LOG(
60        FATAL,
61        &quot;Failed to find a string larger than the short string optimization&quot;);
62    return -1;
63  }
64  void BM_InlinedVectorFillString(benchmark::State&amp; state) {
65    const int len = state.range(0);
66    const int no_sso = GetNonShortStringOptimizationSize();
67    std::string strings[4] = {std::string(no_sso, &#x27;A&#x27;), std::string(no_sso, &#x27;B&#x27;),
68                              std::string(no_sso, &#x27;C&#x27;), std::string(no_sso, &#x27;D&#x27;)};
69    for (auto _ : state) {
70      absl::InlinedVector&lt;std::string, 8&gt; v;
71      for (int i = 0; i &lt; len; i++) {
<span onclick='openModal()' class='match'>72        v.push_back(strings[i &amp; 3]);
73      }
74    }
75    state.SetItemsProcessed(static_cast&lt;int64_t&gt;(state.iterations()) * len);
76  }
77  BENCHMARK(BM_InlinedVectorFillString)-&gt;Range(0, 1024);
78  void BM_StdVectorFillString(benchmark::State&amp; state) {
</span>79    const int len = state.range(0);
80    const int no_sso = GetNonShortStringOptimizationSize();
81    std::string strings[4] = {std::string(no_sso, &#x27;A&#x27;), std::string(no_sso, &#x27;B&#x27;),
82                              std::string(no_sso, &#x27;C&#x27;), std::string(no_sso, &#x27;D&#x27;)};
83    for (auto _ : state) {
84      std::vector&lt;std::string&gt; v;
85      for (int i = 0; i &lt; len; i++) {
86        v.push_back(strings[i &amp; 3]);
87      }
88    }
89    state.SetItemsProcessed(static_cast&lt;int64_t&gt;(state.iterations()) * len);
90  }
91  BENCHMARK(BM_StdVectorFillString)-&gt;Range(0, 1024);
92  struct Buffer {  
93    char* base;
94    int length;
95    int capacity;
96    void* user_data;
97  };
98  void BM_InlinedVectorAssignments(benchmark::State&amp; state) {
99    const int len = state.range(0);
100    using BufferVec = absl::InlinedVector&lt;Buffer, 2&gt;;
101    BufferVec src;
102    src.resize(len);
103    BufferVec dst;
104    for (auto _ : state) {
105      benchmark::DoNotOptimize(dst);
106      benchmark::DoNotOptimize(src);
107      dst = src;
108    }
109  }
110  BENCHMARK(BM_InlinedVectorAssignments)
111      -&gt;Arg(0)
112      -&gt;Arg(1)
113      -&gt;Arg(2)
114      -&gt;Arg(3)
115      -&gt;Arg(4)
116      -&gt;Arg(20);
117  void BM_CreateFromContainer(benchmark::State&amp; state) {
118    for (auto _ : state) {
119      absl::InlinedVector&lt;int, 4&gt; src{1, 2, 3};
120      benchmark::DoNotOptimize(src);
121      absl::InlinedVector&lt;int, 4&gt; dst(std::move(src));
122      benchmark::DoNotOptimize(dst);
123    }
124  }
125  BENCHMARK(BM_CreateFromContainer);
126  struct LargeCopyableOnly {
127    LargeCopyableOnly() : d(1024, 17) {}
128    LargeCopyableOnly(const LargeCopyableOnly&amp; o) = default;
129    LargeCopyableOnly&amp; operator=(const LargeCopyableOnly&amp; o) = default;
130    std::vector&lt;int&gt; d;
131  };
132  struct LargeCopyableSwappable {
133    LargeCopyableSwappable() : d(1024, 17) {}
134    LargeCopyableSwappable(const LargeCopyableSwappable&amp; o) = default;
135    LargeCopyableSwappable&amp; operator=(LargeCopyableSwappable o) {
136      using std::swap;
137      swap(*this, o);
138      return *this;
139    }
140    friend void swap(LargeCopyableSwappable&amp; a, LargeCopyableSwappable&amp; b) {
141      using std::swap;
142      swap(a.d, b.d);
143    }
144    std::vector&lt;int&gt; d;
145  };
146  struct LargeCopyableMovable {
147    LargeCopyableMovable() : d(1024, 17) {}
148    std::vector&lt;int&gt; d;
149  };
150  struct LargeCopyableMovableSwappable {
151    LargeCopyableMovableSwappable() : d(1024, 17) {}
152    LargeCopyableMovableSwappable(const LargeCopyableMovableSwappable&amp; o) =
153        default;
154    LargeCopyableMovableSwappable(LargeCopyableMovableSwappable&amp;&amp; o) = default;
155    LargeCopyableMovableSwappable&amp; operator=(LargeCopyableMovableSwappable o) {
156      using std::swap;
157      swap(*this, o);
158      return *this;
159    }
160    LargeCopyableMovableSwappable&amp; operator=(LargeCopyableMovableSwappable&amp;&amp; o) =
161        default;
162    friend void swap(LargeCopyableMovableSwappable&amp; a,
163                     LargeCopyableMovableSwappable&amp; b) {
164      using std::swap;
165      swap(a.d, b.d);
166    }
167    std::vector&lt;int&gt; d;
168  };
169  template &lt;typename ElementType&gt;
170  void BM_SwapElements(benchmark::State&amp; state) {
171    const int len = state.range(0);
172    using Vec = absl::InlinedVector&lt;ElementType, 32&gt;;
173    Vec a(len);
174    Vec b;
175    for (auto _ : state) {
176      using std::swap;
177      benchmark::DoNotOptimize(a);
178      benchmark::DoNotOptimize(b);
179      swap(a, b);
180    }
181  }
182  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableOnly)-&gt;Range(0, 1024);
183  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableSwappable)-&gt;Range(0, 1024);
184  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovable)-&gt;Range(0, 1024);
185  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovableSwappable)
186      -&gt;Range(0, 1024);
187  template &lt;typename VecType&gt;
188  void BM_Sizeof(benchmark::State&amp; state) {
189    int size = 0;
190    for (auto _ : state) {
191      VecType vec;
192      size = sizeof(vec);
193    }
194    state.SetLabel(absl::StrCat(&quot;sz=&quot;, size));
195  }
196  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;char, 1&gt;);
197  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;char, 4&gt;);
198  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;char, 7&gt;);
199  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;char, 8&gt;);
200  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;int, 1&gt;);
201  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;int, 4&gt;);
202  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;int, 7&gt;);
203  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;int, 8&gt;);
204  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;void*, 1&gt;);
205  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;void*, 4&gt;);
206  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;void*, 7&gt;);
207  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;void*, 8&gt;);
208  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;std::string, 1&gt;);
209  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;std::string, 4&gt;);
210  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;std::string, 7&gt;);
211  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;std::string, 8&gt;);
212  void BM_InlinedVectorIndexInlined(benchmark::State&amp; state) {
213    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7};
214    for (auto _ : state) {
215      benchmark::DoNotOptimize(v);
216      benchmark::DoNotOptimize(v[4]);
217    }
218  }
219  BENCHMARK(BM_InlinedVectorIndexInlined);
220  void BM_InlinedVectorIndexExternal(benchmark::State&amp; state) {
221    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
222    for (auto _ : state) {
223      benchmark::DoNotOptimize(v);
224      benchmark::DoNotOptimize(v[4]);
225    }
226  }
227  BENCHMARK(BM_InlinedVectorIndexExternal);
228  void BM_StdVectorIndex(benchmark::State&amp; state) {
229    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
230    for (auto _ : state) {
231      benchmark::DoNotOptimize(v);
232      benchmark::DoNotOptimize(v[4]);
233    }
234  }
235  BENCHMARK(BM_StdVectorIndex);
236  void BM_InlinedVectorDataInlined(benchmark::State&amp; state) {
237    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7};
238    for (auto _ : state) {
239      benchmark::DoNotOptimize(v);
240      benchmark::DoNotOptimize(v.data());
241    }
242  }
243  BENCHMARK(BM_InlinedVectorDataInlined);
244  void BM_InlinedVectorDataExternal(benchmark::State&amp; state) {
245    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
246    for (auto _ : state) {
247      benchmark::DoNotOptimize(v);
248      benchmark::DoNotOptimize(v.data());
249    }
250    state.SetItemsProcessed(16 * static_cast&lt;int64_t&gt;(state.iterations()));
251  }
252  BENCHMARK(BM_InlinedVectorDataExternal);
253  void BM_StdVectorData(benchmark::State&amp; state) {
254    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
255    for (auto _ : state) {
256      benchmark::DoNotOptimize(v);
257      benchmark::DoNotOptimize(v.data());
258    }
259    state.SetItemsProcessed(16 * static_cast&lt;int64_t&gt;(state.iterations()));
260  }
261  BENCHMARK(BM_StdVectorData);
262  void BM_InlinedVectorSizeInlined(benchmark::State&amp; state) {
263    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7};
264    for (auto _ : state) {
265      benchmark::DoNotOptimize(v);
266      benchmark::DoNotOptimize(v.size());
267    }
268  }
269  BENCHMARK(BM_InlinedVectorSizeInlined);
270  void BM_InlinedVectorSizeExternal(benchmark::State&amp; state) {
271    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
272    for (auto _ : state) {
273      benchmark::DoNotOptimize(v);
274      benchmark::DoNotOptimize(v.size());
275    }
276  }
277  BENCHMARK(BM_InlinedVectorSizeExternal);
278  void BM_StdVectorSize(benchmark::State&amp; state) {
279    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
280    for (auto _ : state) {
281      benchmark::DoNotOptimize(v);
282      benchmark::DoNotOptimize(v.size());
283    }
284  }
285  BENCHMARK(BM_StdVectorSize);
286  void BM_InlinedVectorEmptyInlined(benchmark::State&amp; state) {
287    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7};
288    for (auto _ : state) {
289      benchmark::DoNotOptimize(v);
290      benchmark::DoNotOptimize(v.empty());
291    }
292  }
293  BENCHMARK(BM_InlinedVectorEmptyInlined);
294  void BM_InlinedVectorEmptyExternal(benchmark::State&amp; state) {
295    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
296    for (auto _ : state) {
297      benchmark::DoNotOptimize(v);
298      benchmark::DoNotOptimize(v.empty());
299    }
300  }
301  BENCHMARK(BM_InlinedVectorEmptyExternal);
302  void BM_StdVectorEmpty(benchmark::State&amp; state) {
303    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
304    for (auto _ : state) {
305      benchmark::DoNotOptimize(v);
306      benchmark::DoNotOptimize(v.empty());
307    }
308  }
309  BENCHMARK(BM_StdVectorEmpty);
310  constexpr size_t kInlinedCapacity = 4;
311  constexpr size_t kLargeSize = kInlinedCapacity * 2;
312  constexpr size_t kSmallSize = kInlinedCapacity / 2;
313  constexpr size_t kBatchSize = 100;
314  #define ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_FunctionTemplate, T) \
315    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize);        \
316    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize)
317  #define ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_FunctionTemplate, T)      \
318    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kLargeSize); \
319    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kSmallSize); \
320    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kLargeSize); \
321    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kSmallSize)
322  template &lt;typename T&gt;
323  using InlVec = absl::InlinedVector&lt;T, kInlinedCapacity&gt;;
324  struct TrivialType {
325    size_t val;
326  };
327  class NontrivialType {
328   public:
329    ABSL_ATTRIBUTE_NOINLINE NontrivialType() : val_() {
330      benchmark::DoNotOptimize(*this);
331    }
332    ABSL_ATTRIBUTE_NOINLINE NontrivialType(const NontrivialType&amp; other)
333        : val_(other.val_) {
334      benchmark::DoNotOptimize(*this);
335    }
336    ABSL_ATTRIBUTE_NOINLINE NontrivialType&amp; operator=(
337        const NontrivialType&amp; other) {
338      val_ = other.val_;
339      benchmark::DoNotOptimize(*this);
340      return *this;
341    }
342    ABSL_ATTRIBUTE_NOINLINE ~NontrivialType() noexcept {
343      benchmark::DoNotOptimize(*this);
344    }
345   private:
346    size_t val_;
347  };
348  template &lt;typename T, typename PrepareVecFn, typename TestVecFn&gt;
349  void BatchedBenchmark(benchmark::State&amp; state, PrepareVecFn prepare_vec,
350                        TestVecFn test_vec) {
351    std::array&lt;InlVec&lt;T&gt;, kBatchSize&gt; vector_batch{};
352    while (state.KeepRunningBatch(kBatchSize)) {
353      state.PauseTiming();
354      for (size_t i = 0; i &lt; kBatchSize; ++i) {
355        prepare_vec(vector_batch.data() + i, i);
356      }
357      benchmark::DoNotOptimize(vector_batch);
358      state.ResumeTiming();
359      for (size_t i = 0; i &lt; kBatchSize; ++i) {
360        test_vec(vector_batch.data() + i, i);
361      }
362    }
363  }
364  template &lt;typename T, size_t ToSize&gt;
365  void BM_ConstructFromSize(benchmark::State&amp; state) {
366    using VecT = InlVec&lt;T&gt;;
367    auto size = ToSize;
368    BatchedBenchmark&lt;T&gt;(
369        state,
370         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;~VecT(); },
371        [&amp;](void* ptr, size_t) {
372          benchmark::DoNotOptimize(size);
373          ::new (ptr) VecT(size);
374        });
375  }
376  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, TrivialType);
377  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, NontrivialType);
378  template &lt;typename T, size_t ToSize&gt;
379  void BM_ConstructFromSizeRef(benchmark::State&amp; state) {
380    using VecT = InlVec&lt;T&gt;;
381    auto size = ToSize;
382    auto ref = T();
383    BatchedBenchmark&lt;T&gt;(
384        state,
385         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;~VecT(); },
386        [&amp;](void* ptr, size_t) {
387          benchmark::DoNotOptimize(size);
388          benchmark::DoNotOptimize(ref);
389          ::new (ptr) VecT(size, ref);
390        });
391  }
392  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, TrivialType);
393  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, NontrivialType);
394  template &lt;typename T, size_t ToSize&gt;
395  void BM_ConstructFromRange(benchmark::State&amp; state) {
396    using VecT = InlVec&lt;T&gt;;
397    std::array&lt;T, ToSize&gt; arr{};
398    BatchedBenchmark&lt;T&gt;(
399        state,
400         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;~VecT(); },
401        [&amp;](void* ptr, size_t) {
402          benchmark::DoNotOptimize(arr);
403          ::new (ptr) VecT(arr.begin(), arr.end());
404        });
405  }
406  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, TrivialType);
407  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, NontrivialType);
408  template &lt;typename T, size_t ToSize&gt;
409  void BM_ConstructFromCopy(benchmark::State&amp; state) {
410    using VecT = InlVec&lt;T&gt;;
411    VecT other_vec(ToSize);
412    BatchedBenchmark&lt;T&gt;(
413        state,
414        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;~VecT(); },
415        [&amp;](void* ptr, size_t) {
416          benchmark::DoNotOptimize(other_vec);
417          ::new (ptr) VecT(other_vec);
418        });
419  }
420  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, TrivialType);
421  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, NontrivialType);
422  template &lt;typename T, size_t ToSize&gt;
423  void BM_ConstructFromMove(benchmark::State&amp; state) {
424    using VecT = InlVec&lt;T&gt;;
425    std::array&lt;VecT, kBatchSize&gt; vector_batch{};
426    BatchedBenchmark&lt;T&gt;(
427        state,
428        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
429          vector_batch[i].clear();
430          vector_batch[i].resize(ToSize);
431          vec-&gt;~VecT();
432        },
433        [&amp;](void* ptr, size_t i) {
434          benchmark::DoNotOptimize(vector_batch[i]);
435          ::new (ptr) VecT(std::move(vector_batch[i]));
436        });
437  }
438  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, TrivialType);
439  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, NontrivialType);
440  void BM_CopyTrivial(benchmark::State&amp; state) {
441    const int n = state.range(0);
442    InlVec&lt;int64_t&gt; src(n);
443    for (auto s : state) {
444      InlVec&lt;int64_t&gt; copy(src);
445      benchmark::DoNotOptimize(copy);
446    }
447  }
448  BENCHMARK(BM_CopyTrivial)-&gt;Arg(0)-&gt;Arg(1)-&gt;Arg(kLargeSize);
449  void BM_CopyNonTrivial(benchmark::State&amp; state) {
450    const int n = state.range(0);
451    InlVec&lt;InlVec&lt;int64_t&gt;&gt; src(n);
452    for (auto s : state) {
453      InlVec&lt;InlVec&lt;int64_t&gt;&gt; copy(src);
454      benchmark::DoNotOptimize(copy);
455    }
456  }
457  BENCHMARK(BM_CopyNonTrivial)-&gt;Arg(0)-&gt;Arg(1)-&gt;Arg(kLargeSize);
458  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
459  void BM_AssignSizeRef(benchmark::State&amp; state) {
460    auto size = ToSize;
461    auto ref = T();
462    BatchedBenchmark&lt;T&gt;(
463        state,
464         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(FromSize); },
465        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
466          benchmark::DoNotOptimize(size);
467          benchmark::DoNotOptimize(ref);
468          vec-&gt;assign(size, ref);
469        });
470  }
471  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, TrivialType);
472  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, NontrivialType);
473  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
474  void BM_AssignRange(benchmark::State&amp; state) {
475    std::array&lt;T, ToSize&gt; arr{};
476    BatchedBenchmark&lt;T&gt;(
477        state,
478         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(FromSize); },
479        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
480          benchmark::DoNotOptimize(arr);
481          vec-&gt;assign(arr.begin(), arr.end());
482        });
483  }
484  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, TrivialType);
485  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, NontrivialType);
486  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
487  void BM_AssignFromCopy(benchmark::State&amp; state) {
488    InlVec&lt;T&gt; other_vec(ToSize);
489    BatchedBenchmark&lt;T&gt;(
490        state,
491         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(FromSize); },
492        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
493          benchmark::DoNotOptimize(other_vec);
494          *vec = other_vec;
495        });
496  }
497  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, TrivialType);
498  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, NontrivialType);
499  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
500  void BM_AssignFromMove(benchmark::State&amp; state) {
501    using VecT = InlVec&lt;T&gt;;
502    std::array&lt;VecT, kBatchSize&gt; vector_batch{};
503    BatchedBenchmark&lt;T&gt;(
504        state,
505        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
506          vector_batch[i].clear();
507          vector_batch[i].resize(ToSize);
508          vec-&gt;resize(FromSize);
509        },
510        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
511          benchmark::DoNotOptimize(vector_batch[i]);
512          *vec = std::move(vector_batch[i]);
513        });
514  }
515  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, TrivialType);
516  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, NontrivialType);
517  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
518  void BM_ResizeSize(benchmark::State&amp; state) {
519    BatchedBenchmark&lt;T&gt;(
520        state,
521        [](InlVec&lt;T&gt;* vec, size_t) {
522          vec-&gt;clear();
523          vec-&gt;resize(FromSize);
524        },
525        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(ToSize); });
526  }
527  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, TrivialType);
528  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, NontrivialType);
529  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
530  void BM_ResizeSizeRef(benchmark::State&amp; state) {
531    auto t = T();
532    BatchedBenchmark&lt;T&gt;(
533        state,
534        [](InlVec&lt;T&gt;* vec, size_t) {
535          vec-&gt;clear();
536          vec-&gt;resize(FromSize);
537        },
538        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
539          benchmark::DoNotOptimize(t);
540          vec-&gt;resize(ToSize, t);
541        });
542  }
543  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, TrivialType);
544  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, NontrivialType);
545  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
546  void BM_InsertSizeRef(benchmark::State&amp; state) {
547    auto t = T();
548    BatchedBenchmark&lt;T&gt;(
549        state,
550        [](InlVec&lt;T&gt;* vec, size_t) {
551          vec-&gt;clear();
552          vec-&gt;resize(FromSize);
553        },
554        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
555          benchmark::DoNotOptimize(t);
556          auto* pos = vec-&gt;data() + (vec-&gt;size() / 2);
557          vec-&gt;insert(pos, t);
558        });
559  }
560  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, TrivialType);
561  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, NontrivialType);
562  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
563  void BM_InsertRange(benchmark::State&amp; state) {
564    InlVec&lt;T&gt; other_vec(ToSize);
565    BatchedBenchmark&lt;T&gt;(
566        state,
567        [](InlVec&lt;T&gt;* vec, size_t) {
568          vec-&gt;clear();
569          vec-&gt;resize(FromSize);
570        },
571        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
572          benchmark::DoNotOptimize(other_vec);
573          auto* pos = vec-&gt;data() + (vec-&gt;size() / 2);
574          vec-&gt;insert(pos, other_vec.begin(), other_vec.end());
575        });
576  }
577  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, TrivialType);
578  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, NontrivialType);
579  template &lt;typename T, size_t FromSize&gt;
580  void BM_EmplaceBack(benchmark::State&amp; state) {
581    BatchedBenchmark&lt;T&gt;(
582        state,
583        [](InlVec&lt;T&gt;* vec, size_t) {
584          vec-&gt;clear();
585          vec-&gt;resize(FromSize);
586        },
587        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;emplace_back(); });
588  }
589  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, TrivialType);
590  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, NontrivialType);
591  template &lt;typename T, size_t FromSize&gt;
592  void BM_PopBack(benchmark::State&amp; state) {
593    BatchedBenchmark&lt;T&gt;(
594        state,
595        [](InlVec&lt;T&gt;* vec, size_t) {
596          vec-&gt;clear();
597          vec-&gt;resize(FromSize);
598        },
599        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;pop_back(); });
600  }
601  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, TrivialType);
602  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, NontrivialType);
603  template &lt;typename T, size_t FromSize&gt;
604  void BM_EraseOne(benchmark::State&amp; state) {
605    BatchedBenchmark&lt;T&gt;(
606        state,
607        [](InlVec&lt;T&gt;* vec, size_t) {
608          vec-&gt;clear();
609          vec-&gt;resize(FromSize);
610        },
611        [](InlVec&lt;T&gt;* vec, size_t) {
612          auto* pos = vec-&gt;data() + (vec-&gt;size() / 2);
613          vec-&gt;erase(pos);
614        });
615  }
616  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, TrivialType);
617  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, NontrivialType);
618  template &lt;typename T, size_t FromSize&gt;
619  void BM_EraseRange(benchmark::State&amp; state) {
620    BatchedBenchmark&lt;T&gt;(
621        state,
622        [](InlVec&lt;T&gt;* vec, size_t) {
623          vec-&gt;clear();
624          vec-&gt;resize(FromSize);
625        },
626        [](InlVec&lt;T&gt;* vec, size_t) {
627          auto* pos = vec-&gt;data() + (vec-&gt;size() / 2);
628          vec-&gt;erase(pos, pos + 1);
629        });
630  }
631  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, TrivialType);
632  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, NontrivialType);
633  template &lt;typename T, size_t FromSize&gt;
634  void BM_Clear(benchmark::State&amp; state) {
635    BatchedBenchmark&lt;T&gt;(
636        state,
637         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(FromSize); },
638         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;clear(); });
639  }
640  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, TrivialType);
641  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, NontrivialType);
642  template &lt;typename T, size_t FromSize, size_t ToCapacity&gt;
643  void BM_Reserve(benchmark::State&amp; state) {
644    BatchedBenchmark&lt;T&gt;(
645        state,
646        [](InlVec&lt;T&gt;* vec, size_t) {
647          vec-&gt;clear();
648          vec-&gt;resize(FromSize);
649        },
650        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;reserve(ToCapacity); });
651  }
652  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, TrivialType);
653  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, NontrivialType);
654  template &lt;typename T, size_t FromCapacity, size_t ToCapacity&gt;
655  void BM_ShrinkToFit(benchmark::State&amp; state) {
656    BatchedBenchmark&lt;T&gt;(
657        state,
658        [](InlVec&lt;T&gt;* vec, size_t) {
659          vec-&gt;clear();
660          vec-&gt;resize(ToCapacity);
661          vec-&gt;reserve(FromCapacity);
662        },
663         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;shrink_to_fit(); });
664  }
665  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, TrivialType);
666  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, NontrivialType);
667  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
668  void BM_Swap(benchmark::State&amp; state) {
669    using VecT = InlVec&lt;T&gt;;
670    std::array&lt;VecT, kBatchSize&gt; vector_batch{};
671    BatchedBenchmark&lt;T&gt;(
672        state,
673        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
674          vector_batch[i].clear();
675          vector_batch[i].resize(ToSize);
676          vec-&gt;resize(FromSize);
677        },
678        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
679          using std::swap;
680          benchmark::DoNotOptimize(vector_batch[i]);
681          swap(*vec, vector_batch[i]);
682        });
683  }
684  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, TrivialType);
685  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, NontrivialType);
686  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</h3>
            <pre><code>1  #include &lt;array&gt;
2  #include &lt;string&gt;
3  #include &lt;vector&gt;
4  #include &quot;absl/base/internal/raw_logging.h&quot;
5  #include &quot;absl/base/macros.h&quot;
6  #include &quot;absl/container/inlined_vector.h&quot;
7  #include &quot;absl/strings/str_cat.h&quot;
8  #include &quot;benchmark/benchmark.h&quot;
9  namespace {
10  void BM_InlinedVectorFill(benchmark::State&amp; state) {
11    const int len = state.range(0);
12    absl::InlinedVector&lt;int, 8&gt; v;
13    v.reserve(len);
14    for (auto _ : state) {
15      v.resize(0);  
16      for (int i = 0; i &lt; len; ++i) {
17        v.push_back(i);
18      }
19      benchmark::DoNotOptimize(v);
20    }
21  }
22  BENCHMARK(BM_InlinedVectorFill)-&gt;Range(1, 256);
23  void BM_InlinedVectorFillRange(benchmark::State&amp; state) {
24    const int len = state.range(0);
25    const std::vector&lt;int&gt; src(len, len);
26    absl::InlinedVector&lt;int, 8&gt; v;
27    v.reserve(len);
28    for (auto _ : state) {
29      benchmark::DoNotOptimize(src);
30      v.assign(src.begin(), src.end());
31      benchmark::DoNotOptimize(v);
32    }
33  }
34  BENCHMARK(BM_InlinedVectorFillRange)-&gt;Range(1, 256);
35  void BM_StdVectorFill(benchmark::State&amp; state) {
36    const int len = state.range(0);
37    std::vector&lt;int&gt; v;
38    v.reserve(len);
39    for (auto _ : state) {
40      v.clear();
41      for (int i = 0; i &lt; len; ++i) {
42        v.push_back(i);
43      }
44      benchmark::DoNotOptimize(v);
45    }
46  }
47  BENCHMARK(BM_StdVectorFill)-&gt;Range(1, 256);
48  bool StringRepresentedInline(std::string s) {
49    const char* chars = s.data();
50    std::string s1 = std::move(s);
51    return s1.data() != chars;
52  }
53  int GetNonShortStringOptimizationSize() {
54    for (int i = 24; i &lt;= 192; i *= 2) {
55      if (!StringRepresentedInline(std::string(i, &#x27;A&#x27;))) {
56        return i;
57      }
58    }
59    ABSL_RAW_LOG(
60        FATAL,
61        &quot;Failed to find a string larger than the short string optimization&quot;);
62    return -1;
63  }
64  void BM_InlinedVectorFillString(benchmark::State&amp; state) {
65    const int len = state.range(0);
66    const int no_sso = GetNonShortStringOptimizationSize();
67    std::string strings[4] = {std::string(no_sso, &#x27;A&#x27;), std::string(no_sso, &#x27;B&#x27;),
68                              std::string(no_sso, &#x27;C&#x27;), std::string(no_sso, &#x27;D&#x27;)};
69    for (auto _ : state) {
70      absl::InlinedVector&lt;std::string, 8&gt; v;
71      for (int i = 0; i &lt; len; i++) {
72        v.push_back(strings[i &amp; 3]);
73      }
74    }
75    state.SetItemsProcessed(static_cast&lt;int64_t&gt;(state.iterations()) * len);
76  }
77  BENCHMARK(BM_InlinedVectorFillString)-&gt;Range(0, 1024);
78  void BM_StdVectorFillString(benchmark::State&amp; state) {
79    const int len = state.range(0);
80    const int no_sso = GetNonShortStringOptimizationSize();
81    std::string strings[4] = {std::string(no_sso, &#x27;A&#x27;), std::string(no_sso, &#x27;B&#x27;),
82                              std::string(no_sso, &#x27;C&#x27;), std::string(no_sso, &#x27;D&#x27;)};
83    for (auto _ : state) {
84      std::vector&lt;std::string&gt; v;
85      for (int i = 0; i &lt; len; i++) {
<span onclick='openModal()' class='match'>86        v.push_back(strings[i &amp; 3]);
87      }
88    }
89    state.SetItemsProcessed(static_cast&lt;int64_t&gt;(state.iterations()) * len);
90  }
91  BENCHMARK(BM_StdVectorFillString)-&gt;Range(0, 1024);
92  struct Buffer {  
</span>93    char* base;
94    int length;
95    int capacity;
96    void* user_data;
97  };
98  void BM_InlinedVectorAssignments(benchmark::State&amp; state) {
99    const int len = state.range(0);
100    using BufferVec = absl::InlinedVector&lt;Buffer, 2&gt;;
101    BufferVec src;
102    src.resize(len);
103    BufferVec dst;
104    for (auto _ : state) {
105      benchmark::DoNotOptimize(dst);
106      benchmark::DoNotOptimize(src);
107      dst = src;
108    }
109  }
110  BENCHMARK(BM_InlinedVectorAssignments)
111      -&gt;Arg(0)
112      -&gt;Arg(1)
113      -&gt;Arg(2)
114      -&gt;Arg(3)
115      -&gt;Arg(4)
116      -&gt;Arg(20);
117  void BM_CreateFromContainer(benchmark::State&amp; state) {
118    for (auto _ : state) {
119      absl::InlinedVector&lt;int, 4&gt; src{1, 2, 3};
120      benchmark::DoNotOptimize(src);
121      absl::InlinedVector&lt;int, 4&gt; dst(std::move(src));
122      benchmark::DoNotOptimize(dst);
123    }
124  }
125  BENCHMARK(BM_CreateFromContainer);
126  struct LargeCopyableOnly {
127    LargeCopyableOnly() : d(1024, 17) {}
128    LargeCopyableOnly(const LargeCopyableOnly&amp; o) = default;
129    LargeCopyableOnly&amp; operator=(const LargeCopyableOnly&amp; o) = default;
130    std::vector&lt;int&gt; d;
131  };
132  struct LargeCopyableSwappable {
133    LargeCopyableSwappable() : d(1024, 17) {}
134    LargeCopyableSwappable(const LargeCopyableSwappable&amp; o) = default;
135    LargeCopyableSwappable&amp; operator=(LargeCopyableSwappable o) {
136      using std::swap;
137      swap(*this, o);
138      return *this;
139    }
140    friend void swap(LargeCopyableSwappable&amp; a, LargeCopyableSwappable&amp; b) {
141      using std::swap;
142      swap(a.d, b.d);
143    }
144    std::vector&lt;int&gt; d;
145  };
146  struct LargeCopyableMovable {
147    LargeCopyableMovable() : d(1024, 17) {}
148    std::vector&lt;int&gt; d;
149  };
150  struct LargeCopyableMovableSwappable {
151    LargeCopyableMovableSwappable() : d(1024, 17) {}
152    LargeCopyableMovableSwappable(const LargeCopyableMovableSwappable&amp; o) =
153        default;
154    LargeCopyableMovableSwappable(LargeCopyableMovableSwappable&amp;&amp; o) = default;
155    LargeCopyableMovableSwappable&amp; operator=(LargeCopyableMovableSwappable o) {
156      using std::swap;
157      swap(*this, o);
158      return *this;
159    }
160    LargeCopyableMovableSwappable&amp; operator=(LargeCopyableMovableSwappable&amp;&amp; o) =
161        default;
162    friend void swap(LargeCopyableMovableSwappable&amp; a,
163                     LargeCopyableMovableSwappable&amp; b) {
164      using std::swap;
165      swap(a.d, b.d);
166    }
167    std::vector&lt;int&gt; d;
168  };
169  template &lt;typename ElementType&gt;
170  void BM_SwapElements(benchmark::State&amp; state) {
171    const int len = state.range(0);
172    using Vec = absl::InlinedVector&lt;ElementType, 32&gt;;
173    Vec a(len);
174    Vec b;
175    for (auto _ : state) {
176      using std::swap;
177      benchmark::DoNotOptimize(a);
178      benchmark::DoNotOptimize(b);
179      swap(a, b);
180    }
181  }
182  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableOnly)-&gt;Range(0, 1024);
183  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableSwappable)-&gt;Range(0, 1024);
184  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovable)-&gt;Range(0, 1024);
185  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovableSwappable)
186      -&gt;Range(0, 1024);
187  template &lt;typename VecType&gt;
188  void BM_Sizeof(benchmark::State&amp; state) {
189    int size = 0;
190    for (auto _ : state) {
191      VecType vec;
192      size = sizeof(vec);
193    }
194    state.SetLabel(absl::StrCat(&quot;sz=&quot;, size));
195  }
196  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;char, 1&gt;);
197  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;char, 4&gt;);
198  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;char, 7&gt;);
199  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;char, 8&gt;);
200  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;int, 1&gt;);
201  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;int, 4&gt;);
202  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;int, 7&gt;);
203  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;int, 8&gt;);
204  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;void*, 1&gt;);
205  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;void*, 4&gt;);
206  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;void*, 7&gt;);
207  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;void*, 8&gt;);
208  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;std::string, 1&gt;);
209  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;std::string, 4&gt;);
210  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;std::string, 7&gt;);
211  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector&lt;std::string, 8&gt;);
212  void BM_InlinedVectorIndexInlined(benchmark::State&amp; state) {
213    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7};
214    for (auto _ : state) {
215      benchmark::DoNotOptimize(v);
216      benchmark::DoNotOptimize(v[4]);
217    }
218  }
219  BENCHMARK(BM_InlinedVectorIndexInlined);
220  void BM_InlinedVectorIndexExternal(benchmark::State&amp; state) {
221    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
222    for (auto _ : state) {
223      benchmark::DoNotOptimize(v);
224      benchmark::DoNotOptimize(v[4]);
225    }
226  }
227  BENCHMARK(BM_InlinedVectorIndexExternal);
228  void BM_StdVectorIndex(benchmark::State&amp; state) {
229    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
230    for (auto _ : state) {
231      benchmark::DoNotOptimize(v);
232      benchmark::DoNotOptimize(v[4]);
233    }
234  }
235  BENCHMARK(BM_StdVectorIndex);
236  void BM_InlinedVectorDataInlined(benchmark::State&amp; state) {
237    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7};
238    for (auto _ : state) {
239      benchmark::DoNotOptimize(v);
240      benchmark::DoNotOptimize(v.data());
241    }
242  }
243  BENCHMARK(BM_InlinedVectorDataInlined);
244  void BM_InlinedVectorDataExternal(benchmark::State&amp; state) {
245    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
246    for (auto _ : state) {
247      benchmark::DoNotOptimize(v);
248      benchmark::DoNotOptimize(v.data());
249    }
250    state.SetItemsProcessed(16 * static_cast&lt;int64_t&gt;(state.iterations()));
251  }
252  BENCHMARK(BM_InlinedVectorDataExternal);
253  void BM_StdVectorData(benchmark::State&amp; state) {
254    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
255    for (auto _ : state) {
256      benchmark::DoNotOptimize(v);
257      benchmark::DoNotOptimize(v.data());
258    }
259    state.SetItemsProcessed(16 * static_cast&lt;int64_t&gt;(state.iterations()));
260  }
261  BENCHMARK(BM_StdVectorData);
262  void BM_InlinedVectorSizeInlined(benchmark::State&amp; state) {
263    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7};
264    for (auto _ : state) {
265      benchmark::DoNotOptimize(v);
266      benchmark::DoNotOptimize(v.size());
267    }
268  }
269  BENCHMARK(BM_InlinedVectorSizeInlined);
270  void BM_InlinedVectorSizeExternal(benchmark::State&amp; state) {
271    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
272    for (auto _ : state) {
273      benchmark::DoNotOptimize(v);
274      benchmark::DoNotOptimize(v.size());
275    }
276  }
277  BENCHMARK(BM_InlinedVectorSizeExternal);
278  void BM_StdVectorSize(benchmark::State&amp; state) {
279    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
280    for (auto _ : state) {
281      benchmark::DoNotOptimize(v);
282      benchmark::DoNotOptimize(v.size());
283    }
284  }
285  BENCHMARK(BM_StdVectorSize);
286  void BM_InlinedVectorEmptyInlined(benchmark::State&amp; state) {
287    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7};
288    for (auto _ : state) {
289      benchmark::DoNotOptimize(v);
290      benchmark::DoNotOptimize(v.empty());
291    }
292  }
293  BENCHMARK(BM_InlinedVectorEmptyInlined);
294  void BM_InlinedVectorEmptyExternal(benchmark::State&amp; state) {
295    absl::InlinedVector&lt;int, 8&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
296    for (auto _ : state) {
297      benchmark::DoNotOptimize(v);
298      benchmark::DoNotOptimize(v.empty());
299    }
300  }
301  BENCHMARK(BM_InlinedVectorEmptyExternal);
302  void BM_StdVectorEmpty(benchmark::State&amp; state) {
303    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
304    for (auto _ : state) {
305      benchmark::DoNotOptimize(v);
306      benchmark::DoNotOptimize(v.empty());
307    }
308  }
309  BENCHMARK(BM_StdVectorEmpty);
310  constexpr size_t kInlinedCapacity = 4;
311  constexpr size_t kLargeSize = kInlinedCapacity * 2;
312  constexpr size_t kSmallSize = kInlinedCapacity / 2;
313  constexpr size_t kBatchSize = 100;
314  #define ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_FunctionTemplate, T) \
315    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize);        \
316    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize)
317  #define ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_FunctionTemplate, T)      \
318    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kLargeSize); \
319    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kSmallSize); \
320    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kLargeSize); \
321    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kSmallSize)
322  template &lt;typename T&gt;
323  using InlVec = absl::InlinedVector&lt;T, kInlinedCapacity&gt;;
324  struct TrivialType {
325    size_t val;
326  };
327  class NontrivialType {
328   public:
329    ABSL_ATTRIBUTE_NOINLINE NontrivialType() : val_() {
330      benchmark::DoNotOptimize(*this);
331    }
332    ABSL_ATTRIBUTE_NOINLINE NontrivialType(const NontrivialType&amp; other)
333        : val_(other.val_) {
334      benchmark::DoNotOptimize(*this);
335    }
336    ABSL_ATTRIBUTE_NOINLINE NontrivialType&amp; operator=(
337        const NontrivialType&amp; other) {
338      val_ = other.val_;
339      benchmark::DoNotOptimize(*this);
340      return *this;
341    }
342    ABSL_ATTRIBUTE_NOINLINE ~NontrivialType() noexcept {
343      benchmark::DoNotOptimize(*this);
344    }
345   private:
346    size_t val_;
347  };
348  template &lt;typename T, typename PrepareVecFn, typename TestVecFn&gt;
349  void BatchedBenchmark(benchmark::State&amp; state, PrepareVecFn prepare_vec,
350                        TestVecFn test_vec) {
351    std::array&lt;InlVec&lt;T&gt;, kBatchSize&gt; vector_batch{};
352    while (state.KeepRunningBatch(kBatchSize)) {
353      state.PauseTiming();
354      for (size_t i = 0; i &lt; kBatchSize; ++i) {
355        prepare_vec(vector_batch.data() + i, i);
356      }
357      benchmark::DoNotOptimize(vector_batch);
358      state.ResumeTiming();
359      for (size_t i = 0; i &lt; kBatchSize; ++i) {
360        test_vec(vector_batch.data() + i, i);
361      }
362    }
363  }
364  template &lt;typename T, size_t ToSize&gt;
365  void BM_ConstructFromSize(benchmark::State&amp; state) {
366    using VecT = InlVec&lt;T&gt;;
367    auto size = ToSize;
368    BatchedBenchmark&lt;T&gt;(
369        state,
370         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;~VecT(); },
371        [&amp;](void* ptr, size_t) {
372          benchmark::DoNotOptimize(size);
373          ::new (ptr) VecT(size);
374        });
375  }
376  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, TrivialType);
377  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, NontrivialType);
378  template &lt;typename T, size_t ToSize&gt;
379  void BM_ConstructFromSizeRef(benchmark::State&amp; state) {
380    using VecT = InlVec&lt;T&gt;;
381    auto size = ToSize;
382    auto ref = T();
383    BatchedBenchmark&lt;T&gt;(
384        state,
385         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;~VecT(); },
386        [&amp;](void* ptr, size_t) {
387          benchmark::DoNotOptimize(size);
388          benchmark::DoNotOptimize(ref);
389          ::new (ptr) VecT(size, ref);
390        });
391  }
392  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, TrivialType);
393  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, NontrivialType);
394  template &lt;typename T, size_t ToSize&gt;
395  void BM_ConstructFromRange(benchmark::State&amp; state) {
396    using VecT = InlVec&lt;T&gt;;
397    std::array&lt;T, ToSize&gt; arr{};
398    BatchedBenchmark&lt;T&gt;(
399        state,
400         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;~VecT(); },
401        [&amp;](void* ptr, size_t) {
402          benchmark::DoNotOptimize(arr);
403          ::new (ptr) VecT(arr.begin(), arr.end());
404        });
405  }
406  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, TrivialType);
407  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, NontrivialType);
408  template &lt;typename T, size_t ToSize&gt;
409  void BM_ConstructFromCopy(benchmark::State&amp; state) {
410    using VecT = InlVec&lt;T&gt;;
411    VecT other_vec(ToSize);
412    BatchedBenchmark&lt;T&gt;(
413        state,
414        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;~VecT(); },
415        [&amp;](void* ptr, size_t) {
416          benchmark::DoNotOptimize(other_vec);
417          ::new (ptr) VecT(other_vec);
418        });
419  }
420  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, TrivialType);
421  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, NontrivialType);
422  template &lt;typename T, size_t ToSize&gt;
423  void BM_ConstructFromMove(benchmark::State&amp; state) {
424    using VecT = InlVec&lt;T&gt;;
425    std::array&lt;VecT, kBatchSize&gt; vector_batch{};
426    BatchedBenchmark&lt;T&gt;(
427        state,
428        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
429          vector_batch[i].clear();
430          vector_batch[i].resize(ToSize);
431          vec-&gt;~VecT();
432        },
433        [&amp;](void* ptr, size_t i) {
434          benchmark::DoNotOptimize(vector_batch[i]);
435          ::new (ptr) VecT(std::move(vector_batch[i]));
436        });
437  }
438  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, TrivialType);
439  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, NontrivialType);
440  void BM_CopyTrivial(benchmark::State&amp; state) {
441    const int n = state.range(0);
442    InlVec&lt;int64_t&gt; src(n);
443    for (auto s : state) {
444      InlVec&lt;int64_t&gt; copy(src);
445      benchmark::DoNotOptimize(copy);
446    }
447  }
448  BENCHMARK(BM_CopyTrivial)-&gt;Arg(0)-&gt;Arg(1)-&gt;Arg(kLargeSize);
449  void BM_CopyNonTrivial(benchmark::State&amp; state) {
450    const int n = state.range(0);
451    InlVec&lt;InlVec&lt;int64_t&gt;&gt; src(n);
452    for (auto s : state) {
453      InlVec&lt;InlVec&lt;int64_t&gt;&gt; copy(src);
454      benchmark::DoNotOptimize(copy);
455    }
456  }
457  BENCHMARK(BM_CopyNonTrivial)-&gt;Arg(0)-&gt;Arg(1)-&gt;Arg(kLargeSize);
458  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
459  void BM_AssignSizeRef(benchmark::State&amp; state) {
460    auto size = ToSize;
461    auto ref = T();
462    BatchedBenchmark&lt;T&gt;(
463        state,
464         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(FromSize); },
465        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
466          benchmark::DoNotOptimize(size);
467          benchmark::DoNotOptimize(ref);
468          vec-&gt;assign(size, ref);
469        });
470  }
471  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, TrivialType);
472  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, NontrivialType);
473  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
474  void BM_AssignRange(benchmark::State&amp; state) {
475    std::array&lt;T, ToSize&gt; arr{};
476    BatchedBenchmark&lt;T&gt;(
477        state,
478         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(FromSize); },
479        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
480          benchmark::DoNotOptimize(arr);
481          vec-&gt;assign(arr.begin(), arr.end());
482        });
483  }
484  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, TrivialType);
485  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, NontrivialType);
486  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
487  void BM_AssignFromCopy(benchmark::State&amp; state) {
488    InlVec&lt;T&gt; other_vec(ToSize);
489    BatchedBenchmark&lt;T&gt;(
490        state,
491         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(FromSize); },
492        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
493          benchmark::DoNotOptimize(other_vec);
494          *vec = other_vec;
495        });
496  }
497  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, TrivialType);
498  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, NontrivialType);
499  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
500  void BM_AssignFromMove(benchmark::State&amp; state) {
501    using VecT = InlVec&lt;T&gt;;
502    std::array&lt;VecT, kBatchSize&gt; vector_batch{};
503    BatchedBenchmark&lt;T&gt;(
504        state,
505        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
506          vector_batch[i].clear();
507          vector_batch[i].resize(ToSize);
508          vec-&gt;resize(FromSize);
509        },
510        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
511          benchmark::DoNotOptimize(vector_batch[i]);
512          *vec = std::move(vector_batch[i]);
513        });
514  }
515  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, TrivialType);
516  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, NontrivialType);
517  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
518  void BM_ResizeSize(benchmark::State&amp; state) {
519    BatchedBenchmark&lt;T&gt;(
520        state,
521        [](InlVec&lt;T&gt;* vec, size_t) {
522          vec-&gt;clear();
523          vec-&gt;resize(FromSize);
524        },
525        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(ToSize); });
526  }
527  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, TrivialType);
528  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, NontrivialType);
529  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
530  void BM_ResizeSizeRef(benchmark::State&amp; state) {
531    auto t = T();
532    BatchedBenchmark&lt;T&gt;(
533        state,
534        [](InlVec&lt;T&gt;* vec, size_t) {
535          vec-&gt;clear();
536          vec-&gt;resize(FromSize);
537        },
538        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
539          benchmark::DoNotOptimize(t);
540          vec-&gt;resize(ToSize, t);
541        });
542  }
543  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, TrivialType);
544  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, NontrivialType);
545  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
546  void BM_InsertSizeRef(benchmark::State&amp; state) {
547    auto t = T();
548    BatchedBenchmark&lt;T&gt;(
549        state,
550        [](InlVec&lt;T&gt;* vec, size_t) {
551          vec-&gt;clear();
552          vec-&gt;resize(FromSize);
553        },
554        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
555          benchmark::DoNotOptimize(t);
556          auto* pos = vec-&gt;data() + (vec-&gt;size() / 2);
557          vec-&gt;insert(pos, t);
558        });
559  }
560  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, TrivialType);
561  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, NontrivialType);
562  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
563  void BM_InsertRange(benchmark::State&amp; state) {
564    InlVec&lt;T&gt; other_vec(ToSize);
565    BatchedBenchmark&lt;T&gt;(
566        state,
567        [](InlVec&lt;T&gt;* vec, size_t) {
568          vec-&gt;clear();
569          vec-&gt;resize(FromSize);
570        },
571        [&amp;](InlVec&lt;T&gt;* vec, size_t) {
572          benchmark::DoNotOptimize(other_vec);
573          auto* pos = vec-&gt;data() + (vec-&gt;size() / 2);
574          vec-&gt;insert(pos, other_vec.begin(), other_vec.end());
575        });
576  }
577  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, TrivialType);
578  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, NontrivialType);
579  template &lt;typename T, size_t FromSize&gt;
580  void BM_EmplaceBack(benchmark::State&amp; state) {
581    BatchedBenchmark&lt;T&gt;(
582        state,
583        [](InlVec&lt;T&gt;* vec, size_t) {
584          vec-&gt;clear();
585          vec-&gt;resize(FromSize);
586        },
587        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;emplace_back(); });
588  }
589  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, TrivialType);
590  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, NontrivialType);
591  template &lt;typename T, size_t FromSize&gt;
592  void BM_PopBack(benchmark::State&amp; state) {
593    BatchedBenchmark&lt;T&gt;(
594        state,
595        [](InlVec&lt;T&gt;* vec, size_t) {
596          vec-&gt;clear();
597          vec-&gt;resize(FromSize);
598        },
599        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;pop_back(); });
600  }
601  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, TrivialType);
602  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, NontrivialType);
603  template &lt;typename T, size_t FromSize&gt;
604  void BM_EraseOne(benchmark::State&amp; state) {
605    BatchedBenchmark&lt;T&gt;(
606        state,
607        [](InlVec&lt;T&gt;* vec, size_t) {
608          vec-&gt;clear();
609          vec-&gt;resize(FromSize);
610        },
611        [](InlVec&lt;T&gt;* vec, size_t) {
612          auto* pos = vec-&gt;data() + (vec-&gt;size() / 2);
613          vec-&gt;erase(pos);
614        });
615  }
616  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, TrivialType);
617  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, NontrivialType);
618  template &lt;typename T, size_t FromSize&gt;
619  void BM_EraseRange(benchmark::State&amp; state) {
620    BatchedBenchmark&lt;T&gt;(
621        state,
622        [](InlVec&lt;T&gt;* vec, size_t) {
623          vec-&gt;clear();
624          vec-&gt;resize(FromSize);
625        },
626        [](InlVec&lt;T&gt;* vec, size_t) {
627          auto* pos = vec-&gt;data() + (vec-&gt;size() / 2);
628          vec-&gt;erase(pos, pos + 1);
629        });
630  }
631  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, TrivialType);
632  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, NontrivialType);
633  template &lt;typename T, size_t FromSize&gt;
634  void BM_Clear(benchmark::State&amp; state) {
635    BatchedBenchmark&lt;T&gt;(
636        state,
637         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;resize(FromSize); },
638         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;clear(); });
639  }
640  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, TrivialType);
641  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, NontrivialType);
642  template &lt;typename T, size_t FromSize, size_t ToCapacity&gt;
643  void BM_Reserve(benchmark::State&amp; state) {
644    BatchedBenchmark&lt;T&gt;(
645        state,
646        [](InlVec&lt;T&gt;* vec, size_t) {
647          vec-&gt;clear();
648          vec-&gt;resize(FromSize);
649        },
650        [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;reserve(ToCapacity); });
651  }
652  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, TrivialType);
653  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, NontrivialType);
654  template &lt;typename T, size_t FromCapacity, size_t ToCapacity&gt;
655  void BM_ShrinkToFit(benchmark::State&amp; state) {
656    BatchedBenchmark&lt;T&gt;(
657        state,
658        [](InlVec&lt;T&gt;* vec, size_t) {
659          vec-&gt;clear();
660          vec-&gt;resize(ToCapacity);
661          vec-&gt;reserve(FromCapacity);
662        },
663         [](InlVec&lt;T&gt;* vec, size_t) { vec-&gt;shrink_to_fit(); });
664  }
665  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, TrivialType);
666  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, NontrivialType);
667  template &lt;typename T, size_t FromSize, size_t ToSize&gt;
668  void BM_Swap(benchmark::State&amp; state) {
669    using VecT = InlVec&lt;T&gt;;
670    std::array&lt;VecT, kBatchSize&gt; vector_batch{};
671    BatchedBenchmark&lt;T&gt;(
672        state,
673        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
674          vector_batch[i].clear();
675          vector_batch[i].resize(ToSize);
676          vec-&gt;resize(FromSize);
677        },
678        [&amp;](InlVec&lt;T&gt;* vec, size_t i) {
679          using std::swap;
680          benchmark::DoNotOptimize(vector_batch[i]);
681          swap(*vec, vector_batch[i]);
682        });
683  }
684  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, TrivialType);
685  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, NontrivialType);
686  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</div>
                </div>
                <div class="column column_space"><pre><code>72        v.push_back(strings[i &amp; 3]);
73      }
74    }
75    state.SetItemsProcessed(static_cast&lt;int64_t&gt;(state.iterations()) * len);
76  }
77  BENCHMARK(BM_InlinedVectorFillString)-&gt;Range(0, 1024);
78  void BM_StdVectorFillString(benchmark::State&amp; state) {
</pre></code></div>
                <div class="column column_space"><pre><code>86        v.push_back(strings[i &amp; 3]);
87      }
88    }
89    state.SetItemsProcessed(static_cast&lt;int64_t&gt;(state.iterations()) * len);
90  }
91  BENCHMARK(BM_StdVectorFillString)-&gt;Range(0, 1024);
92  struct Buffer {  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    