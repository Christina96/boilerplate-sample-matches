
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</h3>
            <pre><code>1  #include "absl/strings/ascii.h"
2  #include <algorithm>
3  #include <cctype>
4  #include <clocale>
5  #include <cstring>
6  #include <string>
7  #include "gtest/gtest.h"
8  #include "absl/base/macros.h"
9  #include "absl/base/port.h"
10  namespace {
11  TEST(AsciiIsFoo, All) {
12    for (int i = 0; i < 256; i++) {
13      const auto c = static_cast<unsigned char>(i);
14      if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
15        EXPECT_TRUE(absl::ascii_isalpha(c)) << ": failed on " << c;
16      else
17        EXPECT_TRUE(!absl::ascii_isalpha(c)) << ": failed on " << c;
18    }
19    for (int i = 0; i < 256; i++) {
20      const auto c = static_cast<unsigned char>(i);
21      if ((c >= '0' && c <= '9'))
22        EXPECT_TRUE(absl::ascii_isdigit(c)) << ": failed on " << c;
23      else
24        EXPECT_TRUE(!absl::ascii_isdigit(c)) << ": failed on " << c;
25    }
26    for (int i = 0; i < 256; i++) {
27      const auto c = static_cast<unsigned char>(i);
28      if (absl::ascii_isalpha(c) || absl::ascii_isdigit(c))
29        EXPECT_TRUE(absl::ascii_isalnum(c)) << ": failed on " << c;
30      else
31        EXPECT_TRUE(!absl::ascii_isalnum(c)) << ": failed on " << c;
32    }
33    for (int i = 0; i < 256; i++) {
34      const auto c = static_cast<unsigned char>(i);
35      if (i != '\0' && strchr(" \r\n\t\v\f", i))
36        EXPECT_TRUE(absl::ascii_isspace(c)) << ": failed on " << c;
37      else
38        EXPECT_TRUE(!absl::ascii_isspace(c)) << ": failed on " << c;
39    }
40    for (int i = 0; i < 256; i++) {
41      const auto c = static_cast<unsigned char>(i);
42      if (i >= 32 && i < 127)
43        EXPECT_TRUE(absl::ascii_isprint(c)) << ": failed on " << c;
44      else
45        EXPECT_TRUE(!absl::ascii_isprint(c)) << ": failed on " << c;
46    }
47    for (int i = 0; i < 256; i++) {
48      const auto c = static_cast<unsigned char>(i);
49      if (absl::ascii_isprint(c) && !absl::ascii_isspace(c) &&
50          !absl::ascii_isalnum(c)) {
51        EXPECT_TRUE(absl::ascii_ispunct(c)) << ": failed on " << c;
52      } else {
53        EXPECT_TRUE(!absl::ascii_ispunct(c)) << ": failed on " << c;
54      }
55    }
56    for (int i = 0; i < 256; i++) {
57      const auto c = static_cast<unsigned char>(i);
58      if (i == ' ' || i == '\t')
59        EXPECT_TRUE(absl::ascii_isblank(c)) << ": failed on " << c;
60      else
61        EXPECT_TRUE(!absl::ascii_isblank(c)) << ": failed on " << c;
62    }
63    for (int i = 0; i < 256; i++) {
64      const auto c = static_cast<unsigned char>(i);
65      if (i < 32 || i == 127)
66        EXPECT_TRUE(absl::ascii_iscntrl(c)) << ": failed on " << c;
67      else
68        EXPECT_TRUE(!absl::ascii_iscntrl(c)) << ": failed on " << c;
69    }
70    for (int i = 0; i < 256; i++) {
71      const auto c = static_cast<unsigned char>(i);
72      if (absl::ascii_isdigit(c) || (i >= 'A' && i <= 'F') ||
73          (i >= 'a' && i <= 'f')) {
74        EXPECT_TRUE(absl::ascii_isxdigit(c)) << ": failed on " << c;
75      } else {
76        EXPECT_TRUE(!absl::ascii_isxdigit(c)) << ": failed on " << c;
77      }
78    }
79    for (int i = 0; i < 256; i++) {
80      const auto c = static_cast<unsigned char>(i);
81      if (i > 32 && i < 127)
82        EXPECT_TRUE(absl::ascii_isgraph(c)) << ": failed on " << c;
83      else
84        EXPECT_TRUE(!absl::ascii_isgraph(c)) << ": failed on " << c;
85    }
86    for (int i = 0; i < 256; i++) {
87      const auto c = static_cast<unsigned char>(i);
88      if (i >= 'A' && i <= 'Z')
89        EXPECT_TRUE(absl::ascii_isupper(c)) << ": failed on " << c;
90      else
91        EXPECT_TRUE(!absl::ascii_isupper(c)) << ": failed on " << c;
92    }
93    for (int i = 0; i < 256; i++) {
94      const auto c = static_cast<unsigned char>(i);
95      if (i >= 'a' && i <= 'z')
96        EXPECT_TRUE(absl::ascii_islower(c)) << ": failed on " << c;
97      else
98        EXPECT_TRUE(!absl::ascii_islower(c)) << ": failed on " << c;
99    }
100    for (unsigned char c = 0; c < 128; c++) {
101      EXPECT_TRUE(absl::ascii_isascii(c)) << ": failed on " << c;
102    }
103    for (int i = 128; i < 256; i++) {
104      const auto c = static_cast<unsigned char>(i);
105      EXPECT_TRUE(!absl::ascii_isascii(c)) << ": failed on " << c;
106    }
107  }
108  TEST(AsciiIsFoo, SameAsIsFoo) {
109  #ifndef __ANDROID__
110    const char* old_locale = setlocale(LC_CTYPE, "C");
111    ASSERT_TRUE(old_locale != nullptr);
112  #endif
113    for (int i = 0; i < 256; i++) {
114      const auto c = static_cast<unsigned char>(i);
115      EXPECT_EQ(isalpha(c) != 0, absl::ascii_isalpha(c)) << c;
116      EXPECT_EQ(isdigit(c) != 0, absl::ascii_isdigit(c)) << c;
117      EXPECT_EQ(isalnum(c) != 0, absl::ascii_isalnum(c)) << c;
118      EXPECT_EQ(isspace(c) != 0, absl::ascii_isspace(c)) << c;
119      EXPECT_EQ(ispunct(c) != 0, absl::ascii_ispunct(c)) << c;
120      EXPECT_EQ(isblank(c) != 0, absl::ascii_isblank(c)) << c;
121      EXPECT_EQ(iscntrl(c) != 0, absl::ascii_iscntrl(c)) << c;
122      EXPECT_EQ(isxdigit(c) != 0, absl::ascii_isxdigit(c)) << c;
123      EXPECT_EQ(isprint(c) != 0, absl::ascii_isprint(c)) << c;
124      EXPECT_EQ(isgraph(c) != 0, absl::ascii_isgraph(c)) << c;
125      EXPECT_EQ(isupper(c) != 0, absl::ascii_isupper(c)) << c;
126      EXPECT_EQ(islower(c) != 0, absl::ascii_islower(c)) << c;
127      EXPECT_EQ(isascii(c) != 0, absl::ascii_isascii(c)) << c;
128    }
129  #ifndef __ANDROID__
130    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
131  #endif
132  }
133  TEST(AsciiToFoo, All) {
134  #ifndef __ANDROID__
135    const char* old_locale = setlocale(LC_CTYPE, "C");
136    ASSERT_TRUE(old_locale != nullptr);
137  #endif
138    for (int i = 0; i < 256; i++) {
139      const auto c = static_cast<unsigned char>(i);
140      if (absl::ascii_islower(c))
141        EXPECT_EQ(absl::ascii_toupper(c), 'A' + (i - 'a')) << c;
142      else
143        EXPECT_EQ(absl::ascii_toupper(c), static_cast<char>(i)) << c;
144      if (absl::ascii_isupper(c))
145        EXPECT_EQ(absl::ascii_tolower(c), 'a' + (i - 'A')) << c;
146      else
147        EXPECT_EQ(absl::ascii_tolower(c), static_cast<char>(i)) << c;
148      EXPECT_EQ(static_cast<char>(tolower(i)), absl::ascii_tolower(c)) << c;
149      EXPECT_EQ(static_cast<char>(toupper(i)), absl::ascii_toupper(c)) << c;
150    }
151  #ifndef __ANDROID__
152    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
153  #endif
154  }
155  TEST(AsciiStrTo, Lower) {
156    const char buf[] = "ABCDEF";
157    const std::string str("GHIJKL");
158    const std::string str2("MNOPQR");
159    const absl::string_view sp(str2);
160    std::string mutable_str("_`?@[{AMNOPQRSTUVWXYZ");
161    EXPECT_EQ("abcdef", absl::AsciiStrToLower(buf));
162    EXPECT_EQ("ghijkl", absl::AsciiStrToLower(str));
163    EXPECT_EQ("mnopqr", absl::AsciiStrToLower(sp));
164    absl::AsciiStrToLower(&mutable_str);
165    EXPECT_EQ("_`?@[{amnopqrstuvwxyz", mutable_str);
166    char mutable_buf[] = "Mutable";
167    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
<span onclick='openModal()' class='match'>168                   mutable_buf, absl::ascii_tolower);
169    EXPECT_STREQ("mutable", mutable_buf);
170  }
171  TEST(AsciiStrTo, Upper) {
172    const char buf[] = "abcdef";
</span>173    const std::string str("ghijkl");
174    const std::string str2("_`?@[{amnopqrstuvwxyz");
175    const absl::string_view sp(str2);
176    EXPECT_EQ("ABCDEF", absl::AsciiStrToUpper(buf));
177    EXPECT_EQ("GHIJKL", absl::AsciiStrToUpper(str));
178    EXPECT_EQ("_`?@[{AMNOPQRSTUVWXYZ", absl::AsciiStrToUpper(sp));
179    char mutable_buf[] = "Mutable";
180    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
181                   mutable_buf, absl::ascii_toupper);
182    EXPECT_STREQ("MUTABLE", mutable_buf);
183  }
184  TEST(StripLeadingAsciiWhitespace, FromStringView) {
185    EXPECT_EQ(absl::string_view{},
186              absl::StripLeadingAsciiWhitespace(absl::string_view{}));
187    EXPECT_EQ("foo", absl::StripLeadingAsciiWhitespace({"foo"}));
188    EXPECT_EQ("foo", absl::StripLeadingAsciiWhitespace({"\t  \n\f\r\n\vfoo"}));
189    EXPECT_EQ("foo foo\n ",
190              absl::StripLeadingAsciiWhitespace({"\t  \n\f\r\n\vfoo foo\n "}));
191    EXPECT_EQ(absl::string_view{}, absl::StripLeadingAsciiWhitespace(
192                                       {"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
193  }
194  TEST(StripLeadingAsciiWhitespace, InPlace) {
195    std::string str;
196    absl::StripLeadingAsciiWhitespace(&str);
197    EXPECT_EQ("", str);
198    str = "foo";
199    absl::StripLeadingAsciiWhitespace(&str);
200    EXPECT_EQ("foo", str);
201    str = "\t  \n\f\r\n\vfoo";
202    absl::StripLeadingAsciiWhitespace(&str);
203    EXPECT_EQ("foo", str);
204    str = "\t  \n\f\r\n\vfoo foo\n ";
205    absl::StripLeadingAsciiWhitespace(&str);
206    EXPECT_EQ("foo foo\n ", str);
207    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
208    absl::StripLeadingAsciiWhitespace(&str);
209    EXPECT_EQ(absl::string_view{}, str);
210  }
211  TEST(StripTrailingAsciiWhitespace, FromStringView) {
212    EXPECT_EQ(absl::string_view{},
213              absl::StripTrailingAsciiWhitespace(absl::string_view{}));
214    EXPECT_EQ("foo", absl::StripTrailingAsciiWhitespace({"foo"}));
215    EXPECT_EQ("foo", absl::StripTrailingAsciiWhitespace({"foo\t  \n\f\r\n\v"}));
216    EXPECT_EQ(" \nfoo foo",
217              absl::StripTrailingAsciiWhitespace({" \nfoo foo\t  \n\f\r\n\v"}));
218    EXPECT_EQ(absl::string_view{}, absl::StripTrailingAsciiWhitespace(
219                                       {"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
220  }
221  TEST(StripTrailingAsciiWhitespace, InPlace) {
222    std::string str;
223    absl::StripTrailingAsciiWhitespace(&str);
224    EXPECT_EQ("", str);
225    str = "foo";
226    absl::StripTrailingAsciiWhitespace(&str);
227    EXPECT_EQ("foo", str);
228    str = "foo\t  \n\f\r\n\v";
229    absl::StripTrailingAsciiWhitespace(&str);
230    EXPECT_EQ("foo", str);
231    str = " \nfoo foo\t  \n\f\r\n\v";
232    absl::StripTrailingAsciiWhitespace(&str);
233    EXPECT_EQ(" \nfoo foo", str);
234    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
235    absl::StripTrailingAsciiWhitespace(&str);
236    EXPECT_EQ(absl::string_view{}, str);
237  }
238  TEST(StripAsciiWhitespace, FromStringView) {
239    EXPECT_EQ(absl::string_view{},
240              absl::StripAsciiWhitespace(absl::string_view{}));
241    EXPECT_EQ("foo", absl::StripAsciiWhitespace({"foo"}));
242    EXPECT_EQ("foo",
243              absl::StripAsciiWhitespace({"\t  \n\f\r\n\vfoo\t  \n\f\r\n\v"}));
244    EXPECT_EQ("foo foo", absl::StripAsciiWhitespace(
245                             {"\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v"}));
246    EXPECT_EQ(absl::string_view{},
247              absl::StripAsciiWhitespace({"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
248  }
249  TEST(StripAsciiWhitespace, InPlace) {
250    std::string str;
251    absl::StripAsciiWhitespace(&str);
252    EXPECT_EQ("", str);
253    str = "foo";
254    absl::StripAsciiWhitespace(&str);
255    EXPECT_EQ("foo", str);
256    str = "\t  \n\f\r\n\vfoo\t  \n\f\r\n\v";
257    absl::StripAsciiWhitespace(&str);
258    EXPECT_EQ("foo", str);
259    str = "\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v";
260    absl::StripAsciiWhitespace(&str);
261    EXPECT_EQ("foo foo", str);
262    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
263    absl::StripAsciiWhitespace(&str);
264    EXPECT_EQ(absl::string_view{}, str);
265  }
266  TEST(RemoveExtraAsciiWhitespace, InPlace) {
267    const char* inputs[] = {"No extra space",
268                            "  Leading whitespace",
269                            "Trailing whitespace  ",
270                            "  Leading and trailing  ",
271                            " Whitespace \t  in\v   middle  ",
272                            "'Eeeeep!  \n Newlines!\n",
273                            "nospaces",
274                            "",
275                            "\n\t a\t\n\nb \t\n"};
276    const char* outputs[] = {
277        "No extra space",
278        "Leading whitespace",
279        "Trailing whitespace",
280        "Leading and trailing",
281        "Whitespace in middle",
282        "'Eeeeep! Newlines!",
283        "nospaces",
284        "",
285        "a\nb",
286    };
287    const int NUM_TESTS = ABSL_ARRAYSIZE(inputs);
288    for (int i = 0; i < NUM_TESTS; i++) {
289      std::string s(inputs[i]);
290      absl::RemoveExtraAsciiWhitespace(&s);
291      EXPECT_EQ(outputs[i], s);
292    }
293  }
294  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</h3>
            <pre><code>1  #include "absl/strings/ascii.h"
2  #include <algorithm>
3  #include <cctype>
4  #include <clocale>
5  #include <cstring>
6  #include <string>
7  #include "gtest/gtest.h"
8  #include "absl/base/macros.h"
9  #include "absl/base/port.h"
10  namespace {
11  TEST(AsciiIsFoo, All) {
12    for (int i = 0; i < 256; i++) {
13      const auto c = static_cast<unsigned char>(i);
14      if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
15        EXPECT_TRUE(absl::ascii_isalpha(c)) << ": failed on " << c;
16      else
17        EXPECT_TRUE(!absl::ascii_isalpha(c)) << ": failed on " << c;
18    }
19    for (int i = 0; i < 256; i++) {
20      const auto c = static_cast<unsigned char>(i);
21      if ((c >= '0' && c <= '9'))
22        EXPECT_TRUE(absl::ascii_isdigit(c)) << ": failed on " << c;
23      else
24        EXPECT_TRUE(!absl::ascii_isdigit(c)) << ": failed on " << c;
25    }
26    for (int i = 0; i < 256; i++) {
27      const auto c = static_cast<unsigned char>(i);
28      if (absl::ascii_isalpha(c) || absl::ascii_isdigit(c))
29        EXPECT_TRUE(absl::ascii_isalnum(c)) << ": failed on " << c;
30      else
31        EXPECT_TRUE(!absl::ascii_isalnum(c)) << ": failed on " << c;
32    }
33    for (int i = 0; i < 256; i++) {
34      const auto c = static_cast<unsigned char>(i);
35      if (i != '\0' && strchr(" \r\n\t\v\f", i))
36        EXPECT_TRUE(absl::ascii_isspace(c)) << ": failed on " << c;
37      else
38        EXPECT_TRUE(!absl::ascii_isspace(c)) << ": failed on " << c;
39    }
40    for (int i = 0; i < 256; i++) {
41      const auto c = static_cast<unsigned char>(i);
42      if (i >= 32 && i < 127)
43        EXPECT_TRUE(absl::ascii_isprint(c)) << ": failed on " << c;
44      else
45        EXPECT_TRUE(!absl::ascii_isprint(c)) << ": failed on " << c;
46    }
47    for (int i = 0; i < 256; i++) {
48      const auto c = static_cast<unsigned char>(i);
49      if (absl::ascii_isprint(c) && !absl::ascii_isspace(c) &&
50          !absl::ascii_isalnum(c)) {
51        EXPECT_TRUE(absl::ascii_ispunct(c)) << ": failed on " << c;
52      } else {
53        EXPECT_TRUE(!absl::ascii_ispunct(c)) << ": failed on " << c;
54      }
55    }
56    for (int i = 0; i < 256; i++) {
57      const auto c = static_cast<unsigned char>(i);
58      if (i == ' ' || i == '\t')
59        EXPECT_TRUE(absl::ascii_isblank(c)) << ": failed on " << c;
60      else
61        EXPECT_TRUE(!absl::ascii_isblank(c)) << ": failed on " << c;
62    }
63    for (int i = 0; i < 256; i++) {
64      const auto c = static_cast<unsigned char>(i);
65      if (i < 32 || i == 127)
66        EXPECT_TRUE(absl::ascii_iscntrl(c)) << ": failed on " << c;
67      else
68        EXPECT_TRUE(!absl::ascii_iscntrl(c)) << ": failed on " << c;
69    }
70    for (int i = 0; i < 256; i++) {
71      const auto c = static_cast<unsigned char>(i);
72      if (absl::ascii_isdigit(c) || (i >= 'A' && i <= 'F') ||
73          (i >= 'a' && i <= 'f')) {
74        EXPECT_TRUE(absl::ascii_isxdigit(c)) << ": failed on " << c;
75      } else {
76        EXPECT_TRUE(!absl::ascii_isxdigit(c)) << ": failed on " << c;
77      }
78    }
79    for (int i = 0; i < 256; i++) {
80      const auto c = static_cast<unsigned char>(i);
81      if (i > 32 && i < 127)
82        EXPECT_TRUE(absl::ascii_isgraph(c)) << ": failed on " << c;
83      else
84        EXPECT_TRUE(!absl::ascii_isgraph(c)) << ": failed on " << c;
85    }
86    for (int i = 0; i < 256; i++) {
87      const auto c = static_cast<unsigned char>(i);
88      if (i >= 'A' && i <= 'Z')
89        EXPECT_TRUE(absl::ascii_isupper(c)) << ": failed on " << c;
90      else
91        EXPECT_TRUE(!absl::ascii_isupper(c)) << ": failed on " << c;
92    }
93    for (int i = 0; i < 256; i++) {
94      const auto c = static_cast<unsigned char>(i);
95      if (i >= 'a' && i <= 'z')
96        EXPECT_TRUE(absl::ascii_islower(c)) << ": failed on " << c;
97      else
98        EXPECT_TRUE(!absl::ascii_islower(c)) << ": failed on " << c;
99    }
100    for (unsigned char c = 0; c < 128; c++) {
101      EXPECT_TRUE(absl::ascii_isascii(c)) << ": failed on " << c;
102    }
103    for (int i = 128; i < 256; i++) {
104      const auto c = static_cast<unsigned char>(i);
105      EXPECT_TRUE(!absl::ascii_isascii(c)) << ": failed on " << c;
106    }
107  }
108  TEST(AsciiIsFoo, SameAsIsFoo) {
109  #ifndef __ANDROID__
110    const char* old_locale = setlocale(LC_CTYPE, "C");
111    ASSERT_TRUE(old_locale != nullptr);
112  #endif
113    for (int i = 0; i < 256; i++) {
114      const auto c = static_cast<unsigned char>(i);
115      EXPECT_EQ(isalpha(c) != 0, absl::ascii_isalpha(c)) << c;
116      EXPECT_EQ(isdigit(c) != 0, absl::ascii_isdigit(c)) << c;
117      EXPECT_EQ(isalnum(c) != 0, absl::ascii_isalnum(c)) << c;
118      EXPECT_EQ(isspace(c) != 0, absl::ascii_isspace(c)) << c;
119      EXPECT_EQ(ispunct(c) != 0, absl::ascii_ispunct(c)) << c;
120      EXPECT_EQ(isblank(c) != 0, absl::ascii_isblank(c)) << c;
121      EXPECT_EQ(iscntrl(c) != 0, absl::ascii_iscntrl(c)) << c;
122      EXPECT_EQ(isxdigit(c) != 0, absl::ascii_isxdigit(c)) << c;
123      EXPECT_EQ(isprint(c) != 0, absl::ascii_isprint(c)) << c;
124      EXPECT_EQ(isgraph(c) != 0, absl::ascii_isgraph(c)) << c;
125      EXPECT_EQ(isupper(c) != 0, absl::ascii_isupper(c)) << c;
126      EXPECT_EQ(islower(c) != 0, absl::ascii_islower(c)) << c;
127      EXPECT_EQ(isascii(c) != 0, absl::ascii_isascii(c)) << c;
128    }
129  #ifndef __ANDROID__
130    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
131  #endif
132  }
133  TEST(AsciiToFoo, All) {
134  #ifndef __ANDROID__
135    const char* old_locale = setlocale(LC_CTYPE, "C");
136    ASSERT_TRUE(old_locale != nullptr);
137  #endif
138    for (int i = 0; i < 256; i++) {
139      const auto c = static_cast<unsigned char>(i);
140      if (absl::ascii_islower(c))
141        EXPECT_EQ(absl::ascii_toupper(c), 'A' + (i - 'a')) << c;
142      else
143        EXPECT_EQ(absl::ascii_toupper(c), static_cast<char>(i)) << c;
144      if (absl::ascii_isupper(c))
145        EXPECT_EQ(absl::ascii_tolower(c), 'a' + (i - 'A')) << c;
146      else
147        EXPECT_EQ(absl::ascii_tolower(c), static_cast<char>(i)) << c;
148      EXPECT_EQ(static_cast<char>(tolower(i)), absl::ascii_tolower(c)) << c;
149      EXPECT_EQ(static_cast<char>(toupper(i)), absl::ascii_toupper(c)) << c;
150    }
151  #ifndef __ANDROID__
152    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
153  #endif
154  }
155  TEST(AsciiStrTo, Lower) {
156    const char buf[] = "ABCDEF";
157    const std::string str("GHIJKL");
158    const std::string str2("MNOPQR");
159    const absl::string_view sp(str2);
160    std::string mutable_str("_`?@[{AMNOPQRSTUVWXYZ");
161    EXPECT_EQ("abcdef", absl::AsciiStrToLower(buf));
162    EXPECT_EQ("ghijkl", absl::AsciiStrToLower(str));
163    EXPECT_EQ("mnopqr", absl::AsciiStrToLower(sp));
164    absl::AsciiStrToLower(&mutable_str);
165    EXPECT_EQ("_`?@[{amnopqrstuvwxyz", mutable_str);
166    char mutable_buf[] = "Mutable";
167    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
168                   mutable_buf, absl::ascii_tolower);
169    EXPECT_STREQ("mutable", mutable_buf);
170  }
171  TEST(AsciiStrTo, Upper) {
172    const char buf[] = "abcdef";
173    const std::string str("ghijkl");
174    const std::string str2("_`?@[{amnopqrstuvwxyz");
175    const absl::string_view sp(str2);
176    EXPECT_EQ("ABCDEF", absl::AsciiStrToUpper(buf));
177    EXPECT_EQ("GHIJKL", absl::AsciiStrToUpper(str));
178    EXPECT_EQ("_`?@[{AMNOPQRSTUVWXYZ", absl::AsciiStrToUpper(sp));
179    char mutable_buf[] = "Mutable";
180    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
<span onclick='openModal()' class='match'>181                   mutable_buf, absl::ascii_toupper);
182    EXPECT_STREQ("MUTABLE", mutable_buf);
183  }
184  TEST(StripLeadingAsciiWhitespace, FromStringView) {
185    EXPECT_EQ(absl::string_view{},
</span>186              absl::StripLeadingAsciiWhitespace(absl::string_view{}));
187    EXPECT_EQ("foo", absl::StripLeadingAsciiWhitespace({"foo"}));
188    EXPECT_EQ("foo", absl::StripLeadingAsciiWhitespace({"\t  \n\f\r\n\vfoo"}));
189    EXPECT_EQ("foo foo\n ",
190              absl::StripLeadingAsciiWhitespace({"\t  \n\f\r\n\vfoo foo\n "}));
191    EXPECT_EQ(absl::string_view{}, absl::StripLeadingAsciiWhitespace(
192                                       {"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
193  }
194  TEST(StripLeadingAsciiWhitespace, InPlace) {
195    std::string str;
196    absl::StripLeadingAsciiWhitespace(&str);
197    EXPECT_EQ("", str);
198    str = "foo";
199    absl::StripLeadingAsciiWhitespace(&str);
200    EXPECT_EQ("foo", str);
201    str = "\t  \n\f\r\n\vfoo";
202    absl::StripLeadingAsciiWhitespace(&str);
203    EXPECT_EQ("foo", str);
204    str = "\t  \n\f\r\n\vfoo foo\n ";
205    absl::StripLeadingAsciiWhitespace(&str);
206    EXPECT_EQ("foo foo\n ", str);
207    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
208    absl::StripLeadingAsciiWhitespace(&str);
209    EXPECT_EQ(absl::string_view{}, str);
210  }
211  TEST(StripTrailingAsciiWhitespace, FromStringView) {
212    EXPECT_EQ(absl::string_view{},
213              absl::StripTrailingAsciiWhitespace(absl::string_view{}));
214    EXPECT_EQ("foo", absl::StripTrailingAsciiWhitespace({"foo"}));
215    EXPECT_EQ("foo", absl::StripTrailingAsciiWhitespace({"foo\t  \n\f\r\n\v"}));
216    EXPECT_EQ(" \nfoo foo",
217              absl::StripTrailingAsciiWhitespace({" \nfoo foo\t  \n\f\r\n\v"}));
218    EXPECT_EQ(absl::string_view{}, absl::StripTrailingAsciiWhitespace(
219                                       {"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
220  }
221  TEST(StripTrailingAsciiWhitespace, InPlace) {
222    std::string str;
223    absl::StripTrailingAsciiWhitespace(&str);
224    EXPECT_EQ("", str);
225    str = "foo";
226    absl::StripTrailingAsciiWhitespace(&str);
227    EXPECT_EQ("foo", str);
228    str = "foo\t  \n\f\r\n\v";
229    absl::StripTrailingAsciiWhitespace(&str);
230    EXPECT_EQ("foo", str);
231    str = " \nfoo foo\t  \n\f\r\n\v";
232    absl::StripTrailingAsciiWhitespace(&str);
233    EXPECT_EQ(" \nfoo foo", str);
234    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
235    absl::StripTrailingAsciiWhitespace(&str);
236    EXPECT_EQ(absl::string_view{}, str);
237  }
238  TEST(StripAsciiWhitespace, FromStringView) {
239    EXPECT_EQ(absl::string_view{},
240              absl::StripAsciiWhitespace(absl::string_view{}));
241    EXPECT_EQ("foo", absl::StripAsciiWhitespace({"foo"}));
242    EXPECT_EQ("foo",
243              absl::StripAsciiWhitespace({"\t  \n\f\r\n\vfoo\t  \n\f\r\n\v"}));
244    EXPECT_EQ("foo foo", absl::StripAsciiWhitespace(
245                             {"\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v"}));
246    EXPECT_EQ(absl::string_view{},
247              absl::StripAsciiWhitespace({"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
248  }
249  TEST(StripAsciiWhitespace, InPlace) {
250    std::string str;
251    absl::StripAsciiWhitespace(&str);
252    EXPECT_EQ("", str);
253    str = "foo";
254    absl::StripAsciiWhitespace(&str);
255    EXPECT_EQ("foo", str);
256    str = "\t  \n\f\r\n\vfoo\t  \n\f\r\n\v";
257    absl::StripAsciiWhitespace(&str);
258    EXPECT_EQ("foo", str);
259    str = "\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v";
260    absl::StripAsciiWhitespace(&str);
261    EXPECT_EQ("foo foo", str);
262    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
263    absl::StripAsciiWhitespace(&str);
264    EXPECT_EQ(absl::string_view{}, str);
265  }
266  TEST(RemoveExtraAsciiWhitespace, InPlace) {
267    const char* inputs[] = {"No extra space",
268                            "  Leading whitespace",
269                            "Trailing whitespace  ",
270                            "  Leading and trailing  ",
271                            " Whitespace \t  in\v   middle  ",
272                            "'Eeeeep!  \n Newlines!\n",
273                            "nospaces",
274                            "",
275                            "\n\t a\t\n\nb \t\n"};
276    const char* outputs[] = {
277        "No extra space",
278        "Leading whitespace",
279        "Trailing whitespace",
280        "Leading and trailing",
281        "Whitespace in middle",
282        "'Eeeeep! Newlines!",
283        "nospaces",
284        "",
285        "a\nb",
286    };
287    const int NUM_TESTS = ABSL_ARRAYSIZE(inputs);
288    for (int i = 0; i < NUM_TESTS; i++) {
289      std::string s(inputs[i]);
290      absl::RemoveExtraAsciiWhitespace(&s);
291      EXPECT_EQ(outputs[i], s);
292    }
293  }
294  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>168                   mutable_buf, absl::ascii_tolower);
169    EXPECT_STREQ("mutable", mutable_buf);
170  }
171  TEST(AsciiStrTo, Upper) {
172    const char buf[] = "abcdef";
</pre></code></div>
                <div class="column column_space"><pre><code>181                   mutable_buf, absl::ascii_toupper);
182    EXPECT_STREQ("MUTABLE", mutable_buf);
183  }
184  TEST(StripLeadingAsciiWhitespace, FromStringView) {
185    EXPECT_EQ(absl::string_view{},
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    