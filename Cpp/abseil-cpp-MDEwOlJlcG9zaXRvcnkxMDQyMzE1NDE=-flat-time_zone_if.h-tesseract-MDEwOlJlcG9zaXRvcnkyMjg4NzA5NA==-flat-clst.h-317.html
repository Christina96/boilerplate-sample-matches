
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_if.h</h3>
            <pre><code>1  #ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_
2  #define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_
3  #include &lt;chrono&gt;
4  #include &lt;cstdint&gt;
5  #include &lt;memory&gt;
6  #include &lt;string&gt;
7  #include &quot;absl/base/config.h&quot;
8  #include &quot;absl/time/internal/cctz/include/cctz/civil_time.h&quot;
9  #include &quot;absl/time/internal/cctz/include/cctz/time_zone.h&quot;
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  namespace time_internal {
13  namespace cctz {
14  class TimeZoneIf {
15   public:
16    static std::unique_ptr&lt;TimeZoneIf&gt; UTC();  
17    static std::unique_ptr&lt;TimeZoneIf&gt; Make(const std::string&amp; name);
18    virtual ~TimeZoneIf();
19    virtual time_zone::absolute_lookup BreakTime(
20        const time_point&lt;seconds&gt;&amp; tp) const = 0;
21    virtual time_zone::civil_lookup MakeTime(const civil_second&amp; cs) const = 0;
22    virtual bool NextTransition(const time_point&lt;seconds&gt;&amp; tp,
23                                time_zone::civil_transition* trans) const = 0;
24    virtual bool PrevTransition(const time_point&lt;seconds&gt;&amp; tp,
25                                time_zone::civil_transition* trans) const = 0;
26    virtual std::string Version() const = 0;
27    virtual std::string Description() const = 0;
28   protected:
<span onclick='openModal()' class='match'>29    TimeZoneIf() = default;
30    TimeZoneIf(const TimeZoneIf&amp;) = delete;
31    TimeZoneIf&amp; operator=(const TimeZoneIf&amp;) = delete;
</span>32  };
33  inline std::int_fast64_t ToUnixSeconds(const time_point&lt;seconds&gt;&amp; tp) {
34    return (tp - std::chrono::time_point_cast&lt;seconds&gt;(
35                     std::chrono::system_clock::from_time_t(0)))
36        .count();
37  }
38  inline time_point&lt;seconds&gt; FromUnixSeconds(std::int_fast64_t t) {
39    return std::chrono::time_point_cast&lt;seconds&gt;(
40               std::chrono::system_clock::from_time_t(0)) +
41           seconds(t);
42  }
43  }  
44  }  
45  ABSL_NAMESPACE_END
46  }  
47  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-clst.h</h3>
            <pre><code>1  #ifndef CLST_H
2  #define CLST_H
3  #include &quot;list.h&quot;
4  #include &quot;lsterr.h&quot;
5  #include &quot;serialis.h&quot;
6  #include &lt;cstdio&gt;
7  namespace tesseract {
8  class CLIST_ITERATOR;
9  class CLIST_LINK {
10    friend class CLIST_ITERATOR;
11    friend class CLIST;
12    CLIST_LINK *next;
13    void *data;
14  public:
15    CLIST_LINK() { 
16      data = next = nullptr;
17    }
18    CLIST_LINK(const CLIST_LINK &amp;) = delete;
19    void operator=(const CLIST_LINK &amp;) = delete;
20  };
21  class TESS_API CLIST {
22    friend class CLIST_ITERATOR;
23    CLIST_LINK *last = nullptr; 
24    CLIST_LINK *First() { 
25      return last != nullptr ? last-&gt;next : nullptr;
26    }
27    const CLIST_LINK *First() const { 
28      return last != nullptr ? last-&gt;next : nullptr;
29    }
30  public:
31    ~CLIST() { 
32      shallow_clear();
33    }
34    void internal_deep_clear(    
35        void (*zapper)(void *)); 
36    void shallow_clear(); 
37    bool empty() const { 
38      return !last;
39    }
40    bool singleton() const {
41      return last != nullptr ? (last == last-&gt;next) : false;
42    }
43    void shallow_copy(      
44        CLIST *from_list) { 
45      last = from_list-&gt;last;
46    }
47    void assign_to_sublist(       
48        CLIST_ITERATOR *start_it, 
49        CLIST_ITERATOR *end_it);  
50    int32_t length() const { 
51      int32_t count = 0;
52      if (last != nullptr) {
53        count = 1;
54        for (auto it = last-&gt;next; it != last; it = it-&gt;next) {
55          count++;
56        }
57      }
58      return count;
59    }
60    void sort(          
61        int comparator( 
62            const void *, const void *));
63    bool add_sorted(int comparator(const void *, const void *), bool unique, void *new_data);
64    void set_subtract(int comparator(const void *, const void *), bool unique, CLIST *minuend,
65                      CLIST *subtrahend);
66  };
67  class TESS_API CLIST_ITERATOR {
68    friend void CLIST::assign_to_sublist(CLIST_ITERATOR *, CLIST_ITERATOR *);
69    CLIST *list;                  
70    CLIST_LINK *prev;             
71    CLIST_LINK *current;          
72    CLIST_LINK *next;             
73    CLIST_LINK *cycle_pt;         
74    bool ex_current_was_last;     
75    bool ex_current_was_cycle_pt; 
76    bool started_cycling;         
77    CLIST_LINK *extract_sublist(   
78        CLIST_ITERATOR *other_it); 
79  public:
80    CLIST_ITERATOR() { 
81      list = nullptr;
82    } 
83    CLIST_ITERATOR( 
84        CLIST *list_to_iterate);
85    void set_to_list( 
86        CLIST *list_to_iterate);
87    void add_after_then_move( 
88        void *new_data);      
89    void add_after_stay_put( 
90        void *new_data);     
91    void add_before_then_move( 
92        void *new_data);       
93    void add_before_stay_put( 
94        void *new_data);      
95    void add_list_after(     
96        CLIST *list_to_add); 
97    void add_list_before(    
98        CLIST *list_to_add); 
99    void *data() { 
100  #ifndef NDEBUG
101      if (!list) {
102        NO_LIST.error(&quot;CLIST_ITERATOR::data&quot;, ABORT);
103      }
104  #endif
105      return current-&gt;data;
106    }
107    void *data_relative( 
108        int8_t offset);  
109    void *forward(); 
110    void *extract(); 
111    void *move_to_first(); 
112    void *move_to_last(); 
113    void mark_cycle_pt(); 
114    bool empty() const { 
115      return list-&gt;empty();
116    }
117    bool current_extracted() const { 
118      return !current;
119    }
120    bool at_first() const; 
121    bool at_last() const; 
122    bool cycled_list() const; 
123    void add_to_end(     
124        void *new_data); 
125    void exchange(                 
126        CLIST_ITERATOR *other_it); 
127    int32_t length() const; 
128    void sort(          
129        int comparator( 
130            const void *, const void *));
131  };
132  inline void CLIST_ITERATOR::set_to_list( 
133      CLIST *list_to_iterate) {
134    list = list_to_iterate;
135    prev = list-&gt;last;
136    current = list-&gt;First();
137    next = current != nullptr ? current-&gt;next : nullptr;
138    cycle_pt = nullptr; 
139    started_cycling = false;
140    ex_current_was_last = false;
141    ex_current_was_cycle_pt = false;
142  }
143  inline CLIST_ITERATOR::CLIST_ITERATOR(CLIST *list_to_iterate) {
144    set_to_list(list_to_iterate);
145  }
146  inline void CLIST_ITERATOR::add_after_then_move( 
147      void *new_data) {
148  #ifndef NDEBUG
149    if (!new_data) {
150      BAD_PARAMETER.error(&quot;CLIST_ITERATOR::add_after_then_move&quot;, ABORT, &quot;new_data is nullptr&quot;);
151    }
152  #endif
153    auto new_element = new CLIST_LINK;
154    new_element-&gt;data = new_data;
155    if (list-&gt;empty()) {
156      new_element-&gt;next = new_element;
157      list-&gt;last = new_element;
158      prev = next = new_element;
159    } else {
160      new_element-&gt;next = next;
161      if (current) { 
162        current-&gt;next = new_element;
163        prev = current;
164        if (current == list-&gt;last) {
165          list-&gt;last = new_element;
166        }
167      } else { 
168        prev-&gt;next = new_element;
169        if (ex_current_was_last) {
170          list-&gt;last = new_element;
171        }
172        if (ex_current_was_cycle_pt) {
173          cycle_pt = new_element;
174        }
175      }
176    }
177    current = new_element;
178  }
179  inline void CLIST_ITERATOR::add_after_stay_put( 
180      void *new_data) {
181  #ifndef NDEBUG
182    if (!new_data) {
183      BAD_PARAMETER.error(&quot;CLIST_ITERATOR::add_after_stay_put&quot;, ABORT, &quot;new_data is nullptr&quot;);
184    }
185  #endif
186    auto new_element = new CLIST_LINK;
187    new_element-&gt;data = new_data;
188    if (list-&gt;empty()) {
189      new_element-&gt;next = new_element;
190      list-&gt;last = new_element;
191      prev = next = new_element;
192      ex_current_was_last = false;
193      current = nullptr;
194    } else {
195      new_element-&gt;next = next;
196      if (current) { 
197        current-&gt;next = new_element;
198        if (prev == current) {
199          prev = new_element;
200        }
201        if (current == list-&gt;last) {
202          list-&gt;last = new_element;
203        }
204      } else { 
205        prev-&gt;next = new_element;
206        if (ex_current_was_last) {
207          list-&gt;last = new_element;
208          ex_current_was_last = false;
209        }
210      }
211      next = new_element;
212    }
213  }
214  inline void CLIST_ITERATOR::add_before_then_move( 
215      void *new_data) {
216  #ifndef NDEBUG
217    if (!new_data) {
218      BAD_PARAMETER.error(&quot;CLIST_ITERATOR::add_before_then_move&quot;, ABORT, &quot;new_data is nullptr&quot;);
219    }
220  #endif
221    auto new_element = new CLIST_LINK;
222    new_element-&gt;data = new_data;
223    if (list-&gt;empty()) {
224      new_element-&gt;next = new_element;
225      list-&gt;last = new_element;
226      prev = next = new_element;
227    } else {
228      prev-&gt;next = new_element;
229      if (current) { 
230        new_element-&gt;next = current;
231        next = current;
232      } else { 
233        new_element-&gt;next = next;
234        if (ex_current_was_last) {
235          list-&gt;last = new_element;
236        }
237        if (ex_current_was_cycle_pt) {
238          cycle_pt = new_element;
239        }
240      }
241    }
242    current = new_element;
243  }
244  inline void CLIST_ITERATOR::add_before_stay_put( 
245      void *new_data) {
246  #ifndef NDEBUG
247    if (!new_data) {
248      BAD_PARAMETER.error(&quot;CLIST_ITERATOR::add_before_stay_put&quot;, ABORT, &quot;new_data is nullptr&quot;);
249    }
250  #endif
251    auto new_element = new CLIST_LINK;
252    new_element-&gt;data = new_data;
253    if (list-&gt;empty()) {
254      new_element-&gt;next = new_element;
255      list-&gt;last = new_element;
256      prev = next = new_element;
257      ex_current_was_last = true;
258      current = nullptr;
259    } else {
260      prev-&gt;next = new_element;
261      if (current) { 
262        new_element-&gt;next = current;
263        if (next == current) {
264          next = new_element;
265        }
266      } else { 
267        new_element-&gt;next = next;
268        if (ex_current_was_last) {
269          list-&gt;last = new_element;
270        }
271      }
272      prev = new_element;
273    }
274  }
275  inline void CLIST_ITERATOR::add_list_after(CLIST *list_to_add) {
276    if (!list_to_add-&gt;empty()) {
277      if (list-&gt;empty()) {
278        list-&gt;last = list_to_add-&gt;last;
279        prev = list-&gt;last;
280        next = list-&gt;First();
281        ex_current_was_last = true;
282        current = nullptr;
283      } else {
284        if (current) { 
285          current-&gt;next = list_to_add-&gt;First();
286          if (current == list-&gt;last) {
287            list-&gt;last = list_to_add-&gt;last;
288          }
289          list_to_add-&gt;last-&gt;next = next;
290          next = current-&gt;next;
291        } else { 
292          prev-&gt;next = list_to_add-&gt;First();
293          if (ex_current_was_last) {
294            list-&gt;last = list_to_add-&gt;last;
295            ex_current_was_last = false;
296          }
297          list_to_add-&gt;last-&gt;next = next;
298          next = prev-&gt;next;
299        }
300      }
301      list_to_add-&gt;last = nullptr;
302    }
303  }
304  inline void CLIST_ITERATOR::add_list_before(CLIST *list_to_add) {
305    if (!list_to_add-&gt;empty()) {
306      if (list-&gt;empty()) {
307        list-&gt;last = list_to_add-&gt;last;
308        prev = list-&gt;last;
309        current = list-&gt;First();
310        next = current-&gt;next;
311        ex_current_was_last = false;
312      } else {
313        prev-&gt;next = list_to_add-&gt;First();
314        if (current) { 
315          list_to_add-&gt;last-&gt;next = current;
316        } else { 
317          list_to_add-&gt;last-&gt;next = next;
318          if (ex_current_was_last) {
319            list-&gt;last = list_to_add-&gt;last;
320          }
321          if (ex_current_was_cycle_pt) {
322            cycle_pt = prev-&gt;next;
323          }
324        }
325        current = prev-&gt;next;
326        next = current-&gt;next;
327      }
328      list_to_add-&gt;last = nullptr;
329    }
330  }
331  inline void *CLIST_ITERATOR::extract() {
332  #ifndef NDEBUG
333    if (!current) { 
334      NULL_CURRENT.error(&quot;CLIST_ITERATOR::extract&quot;, ABORT);
335    }
336  #endif
337    if (list-&gt;singleton()) {
338      prev = next = list-&gt;last = nullptr;
339    } else {
340      prev-&gt;next = next; 
341      if (current == list-&gt;last) {
342        list-&gt;last = prev;
343        ex_current_was_last = true;
344      } else {
345        ex_current_was_last = false;
346      }
347    }
348    ex_current_was_cycle_pt = (current == cycle_pt);
349    auto extracted_data = current-&gt;data;
350    delete (current); 
351    current = nullptr;
352    return extracted_data;
353  }
354  inline void *CLIST_ITERATOR::move_to_first() {
355    current = list-&gt;First();
356    prev = list-&gt;last;
357    next = current != nullptr ? current-&gt;next : nullptr;
358    return current != nullptr ? current-&gt;data : nullptr;
359  }
360  inline void CLIST_ITERATOR::mark_cycle_pt() {
361  #ifndef NDEBUG
362    if (!list) {
363      NO_LIST.error(&quot;CLIST_ITERATOR::mark_cycle_pt&quot;, ABORT);
364    }
365  #endif
366    if (current) {
367      cycle_pt = current;
368    } else {
369      ex_current_was_cycle_pt = true;
370    }
371    started_cycling = false;
372  }
373  inline bool CLIST_ITERATOR::at_first() const {
374    return ((list-&gt;empty()) || (current == list-&gt;First()) ||
375            ((current == nullptr) &amp;&amp; (prev == list-&gt;last) &amp;&amp; 
376             !ex_current_was_last));                         
377  }
378  inline bool CLIST_ITERATOR::at_last() const {
379    return ((list-&gt;empty()) || (current == list-&gt;last) ||
380            ((current == nullptr) &amp;&amp; (prev == list-&gt;last) &amp;&amp; 
381             ex_current_was_last));                          
382  }
383  inline bool CLIST_ITERATOR::cycled_list() const {
384    return ((list-&gt;empty()) || ((current == cycle_pt) &amp;&amp; started_cycling));
385  }
386  inline int32_t CLIST_ITERATOR::length() const {
387    return list-&gt;length();
388  }
389  inline void CLIST_ITERATOR::sort( 
390      int comparator(               
391          const void *, const void *)) {
392    list-&gt;sort(comparator);
393    move_to_first();
394  }
395  inline void CLIST_ITERATOR::add_to_end( 
396      void *new_data) {
397  #ifndef NDEBUG
398    if (!list) {
399      NO_LIST.error(&quot;CLIST_ITERATOR::add_to_end&quot;, ABORT);
400    }
401    if (!new_data) {
402      BAD_PARAMETER.error(&quot;CLIST_ITERATOR::add_to_end&quot;, ABORT, &quot;new_data is nullptr&quot;);
403    }
404  #endif
405    if (this-&gt;at_last()) {
406      this-&gt;add_after_stay_put(new_data);
407    } else {
408      if (this-&gt;at_first()) {
409        this-&gt;add_before_stay_put(new_data);
410        list-&gt;last = prev;
411      } else { 
412        auto new_element = new CLIST_LINK;
413        new_element-&gt;data = new_data;
414        new_element-&gt;next = list-&gt;last-&gt;next;
415        list-&gt;last-&gt;next = new_element;
416        list-&gt;last = new_element;
417      }
418    }
419  }
420  template &lt;typename CLASSNAME&gt;
421  class X_CLIST : public CLIST {
422  public:
<span onclick='openModal()' class='match'>423    X_CLIST() = default;
424    X_CLIST(const X_CLIST &amp;) = delete;
425    X_CLIST &amp;operator=(const X_CLIST &amp;) = delete;
</span>426    void deep_clear() {
427      internal_deep_clear([](void *link) {delete static_cast&lt;CLASSNAME *&gt;(link);});
428    }
429  };
430  #define CLISTIZEH(CLASSNAME)                                    \
431    class CLASSNAME##_CLIST : public X_CLIST&lt;CLASSNAME&gt; {         \
432      using X_CLIST&lt;CLASSNAME&gt;::X_CLIST;                          \
433    };                                                            \
434    struct CLASSNAME##_C_IT : X_ITER&lt;CLIST_ITERATOR, CLASSNAME&gt; { \
435      using X_ITER&lt;CLIST_ITERATOR, CLASSNAME&gt;::X_ITER;            \
436    };
437  } 
438  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_if.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-clst.h</div>
                </div>
                <div class="column column_space"><pre><code>29    TimeZoneIf() = default;
30    TimeZoneIf(const TimeZoneIf&amp;) = delete;
31    TimeZoneIf&amp; operator=(const TimeZoneIf&amp;) = delete;
</pre></code></div>
                <div class="column column_space"><pre><code>423    X_CLIST() = default;
424    X_CLIST(const X_CLIST &amp;) = delete;
425    X_CLIST &amp;operator=(const X_CLIST &amp;) = delete;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    