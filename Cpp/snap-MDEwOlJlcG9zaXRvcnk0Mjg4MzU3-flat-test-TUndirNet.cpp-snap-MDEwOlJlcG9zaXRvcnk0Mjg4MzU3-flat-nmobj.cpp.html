
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.0067895247332688%, Tokens: 11</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-TUndirNet.cpp</h3>
            <pre><code>1  #include <gtest/gtest.h>
2  #include "Snap.h"
3  TEST(TUndirNet, DefaultConstructor) {
4    PUndirNet Graph;
5    Graph = TUndirNet::New();
6    EXPECT_EQ(0,Graph->GetNodes());
7    EXPECT_EQ(0,Graph->GetEdges());
8    EXPECT_EQ(1,Graph->IsOk());
9    EXPECT_EQ(1,Graph->Empty());
10    EXPECT_EQ(0,Graph->HasFlag(gfDirected));
11  }
12  TEST(TUndirNet, ManipulateNodesEdges) {
13    int NNodes = 10000;
14    int NEdges = 100000;
15    const char *FName = "test.graph.dat";
16    PUndirNet Graph;
17    PUndirNet Graph1;
18    PUndirNet Graph2;
19    int i;
20    int n;
21    int NCount;
22    int LCount;
23    int x,y;
24    int Deg, InDeg, OutDeg;
25    Graph = TUndirNet::New();
26    EXPECT_EQ(1,Graph->Empty());
27    for (i = 0; i < NNodes; i++) {
28      Graph->AddNode(i);
29    }
30    EXPECT_EQ(0,Graph->Empty());
31    EXPECT_EQ(NNodes,Graph->GetNodes());
32    NCount = NEdges;
33    LCount = 0;
34    while (NCount > 0) {
35      x = (long) (drand48() * NNodes);
36      y = (long) (drand48() * NNodes);
37      if (!Graph->IsEdge(x,y)) {
38        n = Graph->AddEdge(x, y);
39        NCount--;
40        if (x == y) {
41          LCount++;
42        }
43      }
44    }
45    EXPECT_EQ(NEdges,Graph->GetEdges());
46    EXPECT_EQ(0,Graph->Empty());
47    EXPECT_EQ(1,Graph->IsOk());
48    for (i = 0; i < NNodes; i++) {
49      EXPECT_EQ(1,Graph->IsNode(i));
50    }
51    EXPECT_EQ(0,Graph->IsNode(NNodes));
52    EXPECT_EQ(0,Graph->IsNode(NNodes+1));
53    EXPECT_EQ(0,Graph->IsNode(2*NNodes));
54    NCount = 0;
55    for (TUndirNet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
56      NCount++;
57    }
58    EXPECT_EQ(NNodes,NCount);
59    NCount = 0;
60    for (TUndirNet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
61      for (int e = 0; e < NI.GetOutDeg(); e++) {
62        NCount++;
63      }
64    }
65    EXPECT_EQ(NEdges*2-LCount,NCount);
66    NCount = 0;
67    for (TUndirNet::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
68      NCount++;
69    }
70    EXPECT_EQ(NEdges,NCount);
71    for (TUndirNet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
72      Deg = NI.GetDeg();
73      InDeg = NI.GetInDeg();
74      OutDeg = NI.GetOutDeg();
75      EXPECT_EQ(Deg,InDeg);
76      EXPECT_EQ(Deg,OutDeg);
77    }
78    Graph1 = TUndirNet::New();
79    *Graph1 = *Graph;
80    EXPECT_EQ(NNodes,Graph1->GetNodes());
81    EXPECT_EQ(NEdges,Graph1->GetEdges());
82    EXPECT_EQ(0,Graph1->Empty());
83    EXPECT_EQ(1,Graph1->IsOk());
84    {
85      TFOut FOut(FName);
86      Graph->Save(FOut);
87      FOut.Flush();
88    }
89    {
90      TFIn FIn(FName);
91      Graph2 = TUndirNet::Load(FIn);
92    }
93    EXPECT_EQ(NNodes,Graph2->GetNodes());
94    EXPECT_EQ(NEdges,Graph2->GetEdges());
95    EXPECT_EQ(0,Graph2->Empty());
96    EXPECT_EQ(1,Graph2->IsOk());
97    for (i = 0; i < NNodes; i++) {
98      n = Graph->GetRndNId();
99      Graph->DelNode(n);
100    }
101    EXPECT_EQ(0,Graph->GetNodes());
102    EXPECT_EQ(0,Graph->GetEdges());
103    EXPECT_EQ(1,Graph->IsOk());
104    EXPECT_EQ(1,Graph->Empty());
105    Graph1->Clr();
106    EXPECT_EQ(0,Graph1->GetNodes());
107    EXPECT_EQ(0,Graph1->GetEdges());
108    EXPECT_EQ(1,Graph1->IsOk());
109    EXPECT_EQ(1,Graph1->Empty());
110  }
111  TEST(TUndirNet, ManipulateEdges) {
112    int Iterations = 100;
113    int NNodes;
114    int NNodesStart = 8;
115    int NNodesEnd = 25;
116    int NEdges;
117    int NEdgesStart = 0;
118    int NEdgesEnd = 50;
119    PUndirNet Graph;
120    PUndirNet Graph1;
121    PUndirNet Graph2;
122    int NCount, ECount;
123    int x,y;
124    TIntV NodeIds;
125    THashSet<TIntPr> EdgeSet;
126    TInt::Rnd.PutSeed(0);
127    for (int i = 0; i < Iterations; i++) {
128      for (NEdges = NEdgesStart; NEdges <= NEdgesEnd; NEdges++) {
129        for (NNodes = NNodesStart; NNodes <= NNodesEnd; NNodes++) {
130          if (NEdges > (NNodes * (NNodes+1)/2)) {
131            continue;
132          }
133          Graph = TUndirNet::New();
134          EXPECT_TRUE(Graph->Empty());
135          NodeIds.Gen(NNodes);
136          for (int n = 0; n < NNodes; n++) {
137            NodeIds[n] = n;
138          }
139          NodeIds.Shuffle(TInt::Rnd);
140          for (int n = 0; n < NodeIds.Len(); n++) {
141            Graph->AddNode(NodeIds[n]);
142          }
143          EXPECT_FALSE(Graph->Empty());
144          EdgeSet.Clr();
145          NCount = NEdges;
146          while (NCount > 0) {
147            x = (long) (drand48() * NNodes);
148            y = (long) (drand48() * NNodes);
149            if (!Graph->IsEdge(x,y)) {
150              Graph->AddEdge(x, y);
151              EdgeSet.AddKey(TIntPr(x, y));
152              EdgeSet.AddKey(TIntPr(y, x));
153              NCount--;
154            }
155          }
156          TIntPrV DelEdgeV;
157          for (TUndirNet::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
158            TIntPr Edge(EI.GetSrcNId(), EI.GetDstNId());
159            TIntPr EdgeR(EI.GetDstNId(), EI.GetSrcNId());
160            EXPECT_TRUE(EdgeSet.IsKey(Edge) || EdgeSet.IsKey(EdgeR));
161            if (EdgeSet.IsKey(Edge)) {
162                EdgeSet.DelKey(Edge);
163            }
164            if (EdgeSet.IsKey(EdgeR)) {
165              EdgeSet.DelKey(EdgeR);
<span onclick='openModal()' class='match'>166            }
167            DelEdgeV.Add(Edge);
168          }
169          EXPECT_TRUE(EdgeSet.Empty());
170          EXPECT_TRUE(DelEdgeV.Len() == NEdges);
171          NodeIds.Shuffle(TInt::Rnd);
172          for (int n = 0; n < NNodes; n++) {
173            TIntPrV DelEdgeNodeV;
174            int DelNodeId = NodeIds[n];
175            int EdgesBeforeDel;
176            EdgesBeforeDel = Graph->GetEdges();
</span>177            for (TUndirNet::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
178              if (EI.GetSrcNId() == DelNodeId || EI.GetDstNId() == DelNodeId) {
179                DelEdgeNodeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
180              }
181            }
182            Graph->DelNode(DelNodeId);
183            EXPECT_TRUE(EdgesBeforeDel == DelEdgeNodeV.Len() + Graph->GetEdges());
184            EXPECT_FALSE(Graph->IsNode(DelNodeId));
185            EXPECT_TRUE(Graph->IsOk());
186            for (int e = 0; e < DelEdgeNodeV.Len(); e++) {
187              EXPECT_FALSE(Graph->IsEdge(DelEdgeNodeV[e].Val1, DelEdgeNodeV[e].Val2));
188            }
189            ECount = 0;
190            for (TUndirNet::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
191              EXPECT_FALSE(EI.GetSrcNId() == DelNodeId || EI.GetDstNId() == DelNodeId);
192              ECount++;
193            }
194            EXPECT_TRUE(ECount == Graph->GetEdges());
195          }
196          EXPECT_TRUE(0 == Graph->GetEdges());
197          Graph->Clr();
198          EXPECT_TRUE(Graph->Empty());
199        }
200      }
201    }
202  }
203  TEST(TUndirNet, GetSmallGraph) {
204    PUndirNet Graph;
205    Graph = TUndirNet::GetSmallGraph();
206    EXPECT_EQ(5,Graph->GetNodes());
207    EXPECT_EQ(5,Graph->GetEdges());
208    EXPECT_EQ(1,Graph->IsOk());
209    EXPECT_EQ(0,Graph->Empty());
210    EXPECT_EQ(0,Graph->HasFlag(gfDirected));
211  }
212  TEST(TUndirNet, AddSAttrN) {
213    PUndirNet Graph;
214    Graph = TUndirNet::New();
215    TInt AttrId;
216    int status = Graph->AddSAttrN("TestInt", atInt, AttrId);
217    EXPECT_EQ(0, status);
218    EXPECT_EQ(0, AttrId.Val);
219    status = Graph->AddSAttrN("TestFlt", atFlt, AttrId);
220    EXPECT_EQ(0, status);
221    EXPECT_EQ(1, AttrId.Val);
222    status = Graph->AddSAttrN("TestStr", atStr, AttrId);
223    EXPECT_EQ(0, status);
224    EXPECT_EQ(2, AttrId.Val);
225  }
226  TEST(TUndirNet, GetSAttrIdN) {
227    PUndirNet Graph;
228    Graph = TUndirNet::New();
229    TInt AttrId;
230    Graph->AddSAttrN("TestInt", atInt, AttrId);
231    Graph->AddSAttrN("TestFlt", atFlt, AttrId);
232    Graph->AddSAttrN("TestStr", atStr, AttrId);
233    TAttrType AttrType;
234    int status = Graph->GetSAttrIdN(TStr("TestInt"), AttrId, AttrType);
235    EXPECT_EQ(0, status);
236    EXPECT_EQ(atInt, AttrType);
237    EXPECT_EQ(0, AttrId.Val);
238    status = Graph->GetSAttrIdN(TStr("TestFlt"), AttrId, AttrType);
239    EXPECT_EQ(0, status);
240    EXPECT_EQ(atFlt, AttrType);
241    EXPECT_EQ(1, AttrId.Val);
242    status = Graph->GetSAttrIdN(TStr("TestStr"), AttrId, AttrType);
243    EXPECT_EQ(0, status);
244    EXPECT_EQ(atStr, AttrType);
245    EXPECT_EQ(2, AttrId.Val);
246    status = Graph->GetSAttrIdN(TStr("TestError"), AttrId, AttrType);
247    EXPECT_EQ(-1, status);
248  }
249  TEST(TUndirNet, GetSAttrNameN) {
250    PUndirNet Graph;
251    Graph = TUndirNet::New();
252    TInt AttrId;
253    Graph->AddSAttrN("TestInt", atInt, AttrId);
254    Graph->AddSAttrN("TestFlt", atFlt, AttrId);
255    Graph->AddSAttrN("TestStr", atStr, AttrId);
256    TAttrType AttrType;
257    TStr Name;
258    int status = Graph->GetSAttrNameN(0, Name, AttrType);
259    EXPECT_EQ(0, status);
260    EXPECT_EQ(atInt, AttrType);
261    EXPECT_STREQ("TestInt", Name.CStr());
262    status = Graph->GetSAttrNameN(1, Name, AttrType);
263    EXPECT_EQ(0, status);
264    EXPECT_EQ(atFlt, AttrType);
265    EXPECT_STREQ("TestFlt", Name.CStr());
266    status = Graph->GetSAttrNameN(2, Name, AttrType);
267    EXPECT_EQ(0, status);
268    EXPECT_EQ(atStr, AttrType);
269    EXPECT_STREQ("TestStr", Name.CStr());
270    status = Graph->GetSAttrNameN(3, Name, AttrType);
271    EXPECT_EQ(-1, status);
272  }
273  TEST(TUndirNet, AddSAttrDatN_int) {
274    PUndirNet Graph;
275    Graph = TUndirNet::New();
276    Graph->AddNode(0);
277    TInt Val(5);
278    TInt Id(0);
279    int status = Graph->AddSAttrDatN(Id, 1, Val);
280    EXPECT_EQ(-1, status);
281    TInt AttrId;
282    TStr AttrName("TestInt");
283    Graph->AddSAttrN(AttrName, atInt, AttrId);
284    TFlt ErrorVal(1);
285    status = Graph->AddSAttrDatN(Id, AttrId, ErrorVal);
286    EXPECT_EQ(-2, status);
287    status = Graph->AddSAttrDatN(Id, AttrId, Val);
288    EXPECT_EQ(0, status);
289    status = Graph->AddSAttrDatN(Id, AttrName, Val);
290    EXPECT_EQ(0, status);
291    TStr NewName("TestInt2");
292    status = Graph->AddSAttrDatN(Id, NewName, Val);
293    EXPECT_EQ(0, status);
294    TInt ErrorId(1);
295    status = Graph->AddSAttrDatN(ErrorId, AttrId, Val);
296    EXPECT_EQ(-1, status);
297  }
298  TEST(TUndirNet, AddSAttrDatN_flt) {
299    PUndirNet Graph;
300    Graph = TUndirNet::New();
301    Graph->AddNode(0);
302    TFlt Val(5.0);
303    TInt Id(0);
304    int status = Graph->AddSAttrDatN(Id, 1, Val);
305    EXPECT_EQ(-1, status);
306    TInt AttrId;
307    TStr AttrName("TestFlt");
308    Graph->AddSAttrN(AttrName, atFlt, AttrId);
309    TInt ErrorVal(1);
310    status = Graph->AddSAttrDatN(Id, AttrId, ErrorVal);
311    EXPECT_EQ(-2, status);
312    status = Graph->AddSAttrDatN(Id, AttrId, Val);
313    EXPECT_EQ(0, status);
314    status = Graph->AddSAttrDatN(Id, AttrName, Val);
315    EXPECT_EQ(0, status);
316    TStr NewName("TestFlt2");
317    status = Graph->AddSAttrDatN(Id, NewName, Val);
318    EXPECT_EQ(0, status);
319    TInt ErrorId(1);
320    status = Graph->AddSAttrDatN(ErrorId, AttrId, Val);
321    EXPECT_EQ(-1, status);
322  }
323  TEST(TUndirNet, AddSAttrDatN_str) {
324    PUndirNet Graph;
325    Graph = TUndirNet::New();
326    Graph->AddNode(0);
327    TStr Val("5");
328    TInt Id(0);
329    int status = Graph->AddSAttrDatN(Id, 1, Val);
330    EXPECT_EQ(-1, status);
331    TInt AttrId;
332    TStr AttrName("TestFlt");
333    Graph->AddSAttrN(AttrName, atStr, AttrId);
334    TInt ErrorVal(1);
335    status = Graph->AddSAttrDatN(Id, AttrId, ErrorVal);
336    EXPECT_EQ(-2, status);
337    status = Graph->AddSAttrDatN(Id, AttrId, Val);
338    EXPECT_EQ(0, status);
339    status = Graph->AddSAttrDatN(Id, AttrName, Val);
340    EXPECT_EQ(0, status);
341    TStr NewName("TestStr2");
342    status = Graph->AddSAttrDatN(Id, NewName, Val);
343    EXPECT_EQ(0, status);
344    TInt ErrorId(1);
345    status = Graph->AddSAttrDatN(ErrorId, AttrId, Val);
346    EXPECT_EQ(-1, status);
347  }
348  TEST(TUndirNet, GetSAttrDatN_int) {
349    PUndirNet Graph;
350    Graph = TUndirNet::New();
351    Graph->AddNode(0);
352    TInt Val;
353    TInt AttrId(0);
354    TStr AttrName("TestInt");
355    TInt NId(0);
356    int status = Graph->GetSAttrDatN(NId, AttrName, Val);
357    EXPECT_EQ(-1, status);
358    status = Graph->GetSAttrDatN(NId, AttrId, Val);
359    EXPECT_EQ(-1, status);
360    Graph->AddSAttrN(AttrName, atInt, AttrId);
361    TInt TestVal(5);
362    Graph->AddSAttrDatN(NId, AttrId, TestVal);
363    status = Graph->GetSAttrDatN(NId, AttrId, Val);
364    EXPECT_EQ(0, status);
365    EXPECT_EQ(TestVal.Val, Val.Val);
366    status = Graph->GetSAttrDatN(NId, AttrName, Val);
367    EXPECT_EQ(0, status);
368    EXPECT_EQ(TestVal.Val, Val.Val);
369    TInt ErrorId(1);
370    status = Graph->GetSAttrDatN(ErrorId, AttrId, Val);
371    EXPECT_EQ(-1, status);
372  }
373  TEST(TUndirNet, GetSAttrDatN_flt) {
374    PUndirNet Graph;
375    Graph = TUndirNet::New();
376    Graph->AddNode(0);
377    TFlt Val;
378    TInt AttrId(0);
379    TStr AttrName("TestInt");
380    TInt NId(0);
381    int status = Graph->GetSAttrDatN(NId, AttrName, Val);
382    EXPECT_EQ(-1, status);
383    status = Graph->GetSAttrDatN(NId, AttrId, Val);
384    EXPECT_EQ(-1, status);
385    Graph->AddSAttrN(AttrName, atFlt, AttrId);
386    TFlt TestVal(5.0);
387    Graph->AddSAttrDatN(NId, AttrId, TestVal);
388    status = Graph->GetSAttrDatN(NId, AttrId, Val);
389    EXPECT_EQ(0, status);
390    EXPECT_EQ(TestVal.Val, Val.Val);
391    status = Graph->GetSAttrDatN(NId, AttrName, Val);
392    EXPECT_EQ(0, status);
393    EXPECT_EQ(TestVal.Val, Val.Val);
394    TInt ErrorId(1);
395    status = Graph->GetSAttrDatN(ErrorId, AttrId, Val);
396    EXPECT_EQ(-1, status);
397  }
398  TEST(TUndirNet, GetSAttrDatN_str) {
399    PUndirNet Graph;
400    Graph = TUndirNet::New();
401    Graph->AddNode(0);
402    TStr Val;
403    TInt AttrId(0);
404    TStr AttrName("TestInt");
405    TInt NId(0);
406    int status = Graph->GetSAttrDatN(NId, AttrName, Val);
407    EXPECT_EQ(-1, status);
408    status = Graph->GetSAttrDatN(NId, AttrId, Val);
409    EXPECT_EQ(-1, status);
410    Graph->AddSAttrN(AttrName, atStr, AttrId);
411    TStr TestVal("5");
412    Graph->AddSAttrDatN(NId, AttrId, TestVal);
413    status = Graph->GetSAttrDatN(NId, AttrId, Val);
414    EXPECT_EQ(0, status);
415    EXPECT_STREQ(TestVal.CStr(), Val.CStr());
416    status = Graph->GetSAttrDatN(NId, AttrName, Val);
417    EXPECT_EQ(0, status);
418    EXPECT_STREQ(TestVal.CStr(), Val.CStr());
419    TInt ErrorId(1);
420    status = Graph->GetSAttrDatN(ErrorId, AttrId, Val);
421    EXPECT_EQ(-1, status);
422  }
423  TEST(TUndirNet, DelSAttrDatN) {
424    PUndirNet Graph;
425    Graph = TUndirNet::New();
426    Graph->AddNode(0);
427    TStr IntAttr("TestInt");
428    TInt IntId;
429    Graph->AddSAttrN(IntAttr, atInt, IntId);
430    TStr FltAttr("TestFlt");
431    TInt FltId;
432    Graph->AddSAttrN(FltAttr, atFlt, FltId);
433    TStr StrAttr("TestStr");
434    TInt StrId;
435    Graph->AddSAttrN(StrAttr, atStr, StrId);
436    TInt Id(0);
437    int status = Graph->DelSAttrDatN(Id, IntAttr);
438    EXPECT_EQ(-1, status);
439    status = Graph->DelSAttrDatN(Id, IntId);
440    EXPECT_EQ(-1, status);
441    TInt IntVal(5);
442    Graph->AddSAttrDatN(Id, IntId, IntVal);
443    status = Graph->DelSAttrDatN(Id, IntAttr);
444    EXPECT_EQ(0, status);
445    Graph->AddSAttrDatN(Id, IntId, IntVal);
446    status = Graph->DelSAttrDatN(Id, IntId);
447    EXPECT_EQ(0, status);
448    status = Graph->DelSAttrDatN(Id, IntId);
449    EXPECT_EQ(-1, status);
450    TInt ErrorId(1);
451    status = Graph->DelSAttrDatN(ErrorId, IntId);
452    EXPECT_EQ(-1, status);
453    TFlt FltVal(5.0);
454    Graph->AddSAttrDatN(Id, FltId, FltVal);
455    status = Graph->DelSAttrDatN(Id, FltAttr);
456    EXPECT_EQ(0, status);
457    Graph->AddSAttrDatN(Id, FltId, FltVal);
458    status = Graph->DelSAttrDatN(Id, FltId);
459    EXPECT_EQ(0, status);
460    status = Graph->DelSAttrDatN(Id, FltId);
461    EXPECT_EQ(-1, status);
462    status = Graph->DelSAttrDatN(ErrorId, FltId);
463    EXPECT_EQ(-1, status);
464    TStr StrVal("5");
465    Graph->AddSAttrDatN(Id, StrId, StrVal);
466    status = Graph->DelSAttrDatN(Id, StrAttr);
467    EXPECT_EQ(0, status);
468    Graph->AddSAttrDatN(Id, StrId, StrVal);
469    status = Graph->DelSAttrDatN(Id, StrId);
470    EXPECT_EQ(0, status);
471    status = Graph->DelSAttrDatN(Id, StrId);
472    EXPECT_EQ(-1, status);
473    status = Graph->DelSAttrDatN(ErrorId, StrId);
474    EXPECT_EQ(-1, status);
475  }
476  TEST(TUndirNet, GetSAttrVN) {
477    PUndirNet Graph;
478    Graph = TUndirNet::New();
479    Graph->AddNode(0);
480    TStr IntAttr("TestInt");
481    TInt IntId;
482    Graph->AddSAttrN(IntAttr, atInt, IntId);
483    TStr FltAttr("TestFlt");
484    TInt FltId;
485    Graph->AddSAttrN(FltAttr, atFlt, FltId);
486    TStr StrAttr("TestStr");
487    TInt StrId;
488    Graph->AddSAttrN(StrAttr, atStr, StrId);
489    TInt Id(0);
490    TInt IntVal(5);
491    Graph->AddSAttrDatN(Id, IntId, IntVal);
492    TFlt FltVal(5.0);
493    Graph->AddSAttrDatN(Id, FltId, FltVal);
494    TStr StrVal("5");
495    Graph->AddSAttrDatN(Id, StrId, StrVal);
496    TAttrPrV AttrV;
497    int status = Graph->GetSAttrVN(Id, atInt, AttrV);
498    EXPECT_EQ(0, status);
499    EXPECT_EQ(1, AttrV.Len());
500    status = Graph->GetSAttrVN(Id, atFlt, AttrV);
501    EXPECT_EQ(0, status);
502    EXPECT_EQ(1, AttrV.Len());
503    status = Graph->GetSAttrVN(Id, atStr, AttrV);
504    EXPECT_EQ(0, status);
505    EXPECT_EQ(1, AttrV.Len());
506  }
507  TEST(TUndirNet, GetIdVSAttrN) {
508    PUndirNet Graph;
509    Graph = TUndirNet::New();
510    TStr IntAttr("TestInt");
511    TInt IntId;
512    Graph->AddSAttrN(IntAttr, atInt, IntId);
513    TStr FltAttr("TestFlt");
514    TInt FltId;
515    Graph->AddSAttrN(FltAttr, atFlt, FltId);
516    TStr StrAttr("TestStr");
517    TInt StrId;
518    Graph->AddSAttrN(StrAttr, atStr, StrId);
519    TInt IntVal(0);
520    TFlt FltVal(0);
521    TStr StrVal("test");
522    for (int i = 0; i < 10; i++) {
523      Graph->AddNode(i);
524      TInt Id(i);
525      Graph->AddSAttrDatN(Id, IntId, IntVal);
526      if (i%2 == 0) {
527        Graph->AddSAttrDatN(Id, FltId, FltVal);
528      }
529    }
530    Graph->AddSAttrDatN(0, StrId, StrVal);
531    TIntV IdV;
532    Graph->GetIdVSAttrN(IntAttr, IdV);
533    EXPECT_EQ(10, IdV.Len());
534    Graph->GetIdVSAttrN(IntId, IdV);
535    EXPECT_EQ(10, IdV.Len());
536    Graph->GetIdVSAttrN(FltAttr, IdV);
537    EXPECT_EQ(5, IdV.Len());
538    Graph->GetIdVSAttrN(FltId, IdV);
539    EXPECT_EQ(5, IdV.Len());
540    Graph->GetIdVSAttrN(StrAttr, IdV);
541    EXPECT_EQ(1, IdV.Len());
542    Graph->GetIdVSAttrN(StrId, IdV);
543    EXPECT_EQ(1, IdV.Len());
544  }
545  TEST(TUndirNet, AddSAttrE) {
546    PUndirNet Graph;
547    Graph = TUndirNet::New();
548    TInt AttrId;
549    int status = Graph->AddSAttrE("TestInt", atInt, AttrId);
550    EXPECT_EQ(0, status);
551    EXPECT_EQ(0, AttrId.Val);
552    status = Graph->AddSAttrE("TestFlt", atFlt, AttrId);
553    EXPECT_EQ(0, status);
554    EXPECT_EQ(1, AttrId.Val);
555    status = Graph->AddSAttrE("TestStr", atStr, AttrId);
556    EXPECT_EQ(0, status);
557    EXPECT_EQ(2, AttrId.Val);
558  }
559  TEST(TUndirNet, GetSAttrIdE) {
560    PUndirNet Graph;
561    Graph = TUndirNet::New();
562    TInt AttrId;
563    Graph->AddSAttrE("TestInt", atInt, AttrId);
564    Graph->AddSAttrE("TestFlt", atFlt, AttrId);
565    Graph->AddSAttrE("TestStr", atStr, AttrId);
566    TAttrType AttrType;
567    int status = Graph->GetSAttrIdE(TStr("TestInt"), AttrId, AttrType);
568    EXPECT_EQ(0, status);
569    EXPECT_EQ(atInt, AttrType);
570    EXPECT_EQ(0, AttrId.Val);
571    status = Graph->GetSAttrIdE(TStr("TestFlt"), AttrId, AttrType);
572    EXPECT_EQ(0, status);
573    EXPECT_EQ(atFlt, AttrType);
574    EXPECT_EQ(1, AttrId.Val);
575    status = Graph->GetSAttrIdE(TStr("TestStr"), AttrId, AttrType);
576    EXPECT_EQ(0, status);
577    EXPECT_EQ(atStr, AttrType);
578    EXPECT_EQ(2, AttrId.Val);
579    status = Graph->GetSAttrIdE(TStr("TestError"), AttrId, AttrType);
580    EXPECT_EQ(-1, status);
581  }
582  TEST(TUndirNet, GetSAttrNameE) {
583    PUndirNet Graph;
584    Graph = TUndirNet::New();
585    TInt AttrId;
586    Graph->AddSAttrE("TestInt", atInt, AttrId);
587    Graph->AddSAttrE("TestFlt", atFlt, AttrId);
588    Graph->AddSAttrE("TestStr", atStr, AttrId);
589    TAttrType AttrType;
590    TStr Name;
591    int status = Graph->GetSAttrNameE(0, Name, AttrType);
592    EXPECT_EQ(0, status);
593    EXPECT_EQ(atInt, AttrType);
594    EXPECT_STREQ("TestInt", Name.CStr());
595    status = Graph->GetSAttrNameE(1, Name, AttrType);
596    EXPECT_EQ(0, status);
597    EXPECT_EQ(atFlt, AttrType);
598    EXPECT_STREQ("TestFlt", Name.CStr());
599    status = Graph->GetSAttrNameE(2, Name, AttrType);
600    EXPECT_EQ(0, status);
601    EXPECT_EQ(atStr, AttrType);
602    EXPECT_STREQ("TestStr", Name.CStr());
603    status = Graph->GetSAttrNameE(3, Name, AttrType);
604    EXPECT_EQ(-1, status);
605  }
606  TEST(TUndirNet, AddSAttrDatE_int) {
607    PUndirNet Graph;
608    Graph = TUndirNet::New();
609    Graph->AddNode(0);
610    Graph->AddNode(1);
611    Graph->AddEdge(0, 1);
612    TInt Val(5);
613    int SrcId = 0;
614    int DstId = 1;
615    int status = Graph->AddSAttrDatE(SrcId, DstId, 1, Val);
616    EXPECT_EQ(-1, status);
617    TInt AttrId;
618    TStr AttrName("TestInt");
619    Graph->AddSAttrE(AttrName, atInt, AttrId);
620    TFlt ErrorVal(1);
621    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, ErrorVal);
622    EXPECT_EQ(-2, status);
623    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, Val);
624    EXPECT_EQ(0, status);
625    status = Graph->AddSAttrDatE(SrcId, DstId, AttrName, Val);
626    EXPECT_EQ(0, status);
627    TStr NewName("TestInt2");
628    status = Graph->AddSAttrDatE(SrcId, DstId, NewName, Val);
629    EXPECT_EQ(0, status);
630    int ErrorId = 5;
631    status = Graph->AddSAttrDatE(SrcId, ErrorId, AttrId, Val);
632    EXPECT_EQ(-1, status);
633  }
634  TEST(TUndirNet, AddSAttrDatE_flt) {
635    PUndirNet Graph;
636    Graph = TUndirNet::New();
637    Graph->AddNode(0);
638    Graph->AddNode(1);
639    Graph->AddEdge(0, 1);
640    TFlt Val(5.0);
641    int SrcId = 0;
642    int DstId = 1;
643    int status = Graph->AddSAttrDatE(SrcId, DstId, 1, Val);
644    EXPECT_EQ(-1, status);
645    TInt AttrId;
646    TStr AttrName("TestFlt");
647    Graph->AddSAttrE(AttrName, atFlt, AttrId);
648    TInt ErrorVal(1);
649    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, ErrorVal);
650    EXPECT_EQ(-2, status);
651    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, Val);
652    EXPECT_EQ(0, status);
653    status = Graph->AddSAttrDatE(SrcId, DstId, AttrName, Val);
654    EXPECT_EQ(0, status);
655    TStr NewName("TestFlt2");
656    status = Graph->AddSAttrDatE(SrcId, DstId, NewName, Val);
657    EXPECT_EQ(0, status);
658    int ErrorId = 5;
659    status = Graph->AddSAttrDatE(SrcId, ErrorId, AttrId, Val);
660    EXPECT_EQ(-1, status);
661  }
662  TEST(TUndirNet, AddSAttrDatE_str) {
663    PUndirNet Graph;
664    Graph = TUndirNet::New();
665    Graph->AddNode(0);
666    Graph->AddNode(1);
667    Graph->AddEdge(0, 1);
668    TStr Val("5");
669    int SrcId = 0;
670    int DstId = 1;
671    int status = Graph->AddSAttrDatE(SrcId, DstId, 1, Val);
672    EXPECT_EQ(-1, status);
673    TInt AttrId;
674    TStr AttrName("TestFlt");
675    Graph->AddSAttrE(AttrName, atStr, AttrId);
676    TInt ErrorVal(1);
677    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, ErrorVal);
678    EXPECT_EQ(-2, status);
679    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, Val);
680    EXPECT_EQ(0, status);
681    status = Graph->AddSAttrDatE(SrcId, DstId, AttrName, Val);
682    EXPECT_EQ(0, status);
683    TStr NewName("TestStr2");
684    status = Graph->AddSAttrDatE(SrcId, DstId, NewName, Val);
685    EXPECT_EQ(0, status);
686    int ErrorId = 5;
687    status = Graph->AddSAttrDatE(SrcId, ErrorId, AttrId, Val);
688    EXPECT_EQ(-1, status);
689  }
690  TEST(TUndirNet, GetSAttrDatE_int) {
691    PUndirNet Graph;
692    Graph = TUndirNet::New();
693    Graph->AddNode(0);
694    Graph->AddNode(1);
695    Graph->AddEdge(0, 1);
696    TInt Val;
697    TInt AttrId(0);
698    TStr AttrName("TestInt");
699    int SrcId = 0;
700    int DstId = 1;
701    int status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
702    EXPECT_EQ(-1, status);
703    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
704    EXPECT_EQ(-1, status);
705    Graph->AddSAttrE(AttrName, atInt, AttrId);
706    TInt TestVal(5);
707    Graph->AddSAttrDatE(SrcId, DstId, AttrId, TestVal);
708    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
709    EXPECT_EQ(0, status);
710    EXPECT_EQ(TestVal.Val, Val.Val);
711    status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
712    EXPECT_EQ(0, status);
713    EXPECT_EQ(TestVal.Val, Val.Val);
714    int ErrorId = 5;
715    status = Graph->GetSAttrDatE(SrcId, ErrorId, AttrId, Val);
716    EXPECT_EQ(-1, status);
717  }
718  TEST(TUndirNet, GetSAttrDatE_flt) {
719    PUndirNet Graph;
720    Graph = TUndirNet::New();
721    Graph->AddNode(0);
722    Graph->AddNode(1);
723    Graph->AddEdge(0, 1);
724    TFlt Val;
725    TInt AttrId(0);
726    TStr AttrName("TestInt");
727    int SrcId = 0;
728    int DstId = 1;
729    int status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
730    EXPECT_EQ(-1, status);
731    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
732    EXPECT_EQ(-1, status);
733    Graph->AddSAttrE(AttrName, atFlt, AttrId);
734    TFlt TestVal(5.0);
735    Graph->AddSAttrDatE(SrcId, DstId, AttrId, TestVal);
736    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
737    EXPECT_EQ(0, status);
738    EXPECT_EQ(TestVal.Val, Val.Val);
739    status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
740    EXPECT_EQ(0, status);
741    EXPECT_EQ(TestVal.Val, Val.Val);
742    int ErrorId = 5;
743    status = Graph->GetSAttrDatE(SrcId, ErrorId, AttrId, Val);
744    EXPECT_EQ(-1, status);
745  }
746  TEST(TUndirNet, GetSAttrDatE_str) {
747    PUndirNet Graph;
748    Graph = TUndirNet::New();
749    Graph->AddNode(0);
750    Graph->AddNode(1);
751    Graph->AddEdge(0, 1);
752    TStr Val;
753    TInt AttrId(0);
754    TStr AttrName("TestInt");
755    int SrcId = 0;
756    int DstId = 1;
757    int status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
758    EXPECT_EQ(-1, status);
759    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
760    EXPECT_EQ(-1, status);
761    Graph->AddSAttrE(AttrName, atStr, AttrId);
762    TStr TestVal("5");
763    Graph->AddSAttrDatE(SrcId, DstId, AttrId, TestVal);
764    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
765    EXPECT_EQ(0, status);
766    EXPECT_STREQ(TestVal.CStr(), Val.CStr());
767    status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
768    EXPECT_EQ(0, status);
769    EXPECT_STREQ(TestVal.CStr(), Val.CStr());
770    int ErrorId = 5;
771    status = Graph->GetSAttrDatE(SrcId, ErrorId, AttrId, Val);
772    EXPECT_EQ(-1, status);
773  }
774  TEST(TUndirNet, DelSAttrDatE) {
775    PUndirNet Graph;
776    Graph = TUndirNet::New();
777    Graph->AddNode(0);
778    Graph->AddNode(1);
779    Graph->AddEdge(0, 1);
780    TStr IntAttr("TestInt");
781    TInt IntId;
782    Graph->AddSAttrE(IntAttr, atInt, IntId);
783    TStr FltAttr("TestFlt");
784    TInt FltId;
785    Graph->AddSAttrE(FltAttr, atFlt, FltId);
786    TStr StrAttr("TestStr");
787    TInt StrId;
788    Graph->AddSAttrE(StrAttr, atStr, StrId);
789    int SrcId = 0;
790    int DstId = 1;
791    int status = Graph->DelSAttrDatE(SrcId, DstId, IntAttr);
792    EXPECT_EQ(-1, status);
793    status = Graph->DelSAttrDatE(SrcId, DstId, IntId);
794    EXPECT_EQ(-1, status);
795    TInt IntVal(5);
796    Graph->AddSAttrDatE(SrcId, DstId, IntId, IntVal);
797    status = Graph->DelSAttrDatE(SrcId, DstId, IntAttr);
798    EXPECT_EQ(0, status);
799    Graph->AddSAttrDatE(SrcId, DstId, IntId, IntVal);
800    status = Graph->DelSAttrDatE(SrcId, DstId, IntId);
801    EXPECT_EQ(0, status);
802    status = Graph->DelSAttrDatE(SrcId, DstId, IntId);
803    EXPECT_EQ(-1, status);
804    int ErrorId = 5;
805    status = Graph->DelSAttrDatE(SrcId, ErrorId, IntId);
806    EXPECT_EQ(-1, status);
807    TFlt FltVal(5.0);
808    Graph->AddSAttrDatE(SrcId, DstId, FltId, FltVal);
809    status = Graph->DelSAttrDatE(SrcId, DstId, FltAttr);
810    EXPECT_EQ(0, status);
811    Graph->AddSAttrDatE(SrcId, DstId, FltId, FltVal);
812    status = Graph->DelSAttrDatE(SrcId, DstId, FltId);
813    EXPECT_EQ(0, status);
814    status = Graph->DelSAttrDatE(SrcId, DstId, FltId);
815    EXPECT_EQ(-1, status);
816    status = Graph->DelSAttrDatE(SrcId, ErrorId, FltId);
817    EXPECT_EQ(-1, status);
818    TStr StrVal("5");
819    Graph->AddSAttrDatE(SrcId, DstId, StrId, StrVal);
820    status = Graph->DelSAttrDatE(SrcId, DstId, StrAttr);
821    EXPECT_EQ(0, status);
822    Graph->AddSAttrDatE(SrcId, DstId, StrId, StrVal);
823    status = Graph->DelSAttrDatE(SrcId, DstId, StrId);
824    EXPECT_EQ(0, status);
825    status = Graph->DelSAttrDatE(SrcId, DstId, StrId);
826    EXPECT_EQ(-1, status);
827    status = Graph->DelSAttrDatE(SrcId, ErrorId, StrId);
828    EXPECT_EQ(-1, status);
829  }
830  TEST(TUndirNet, GetSAttrVE) {
831    PUndirNet Graph;
832    Graph = TUndirNet::New();
833    Graph->AddNode(0);
834    Graph->AddNode(1);
835    Graph->AddEdge(0, 1);
836    TStr IntAttr("TestInt");
837    TInt IntId;
838    Graph->AddSAttrE(IntAttr, atInt, IntId);
839    TStr FltAttr("TestFlt");
840    TInt FltId;
841    Graph->AddSAttrE(FltAttr, atFlt, FltId);
842    TStr StrAttr("TestStr");
843    TInt StrId;
844    Graph->AddSAttrE(StrAttr, atStr, StrId);
845    int SrcId = 0;
846    int DstId = 1;
847    TInt IntVal(5);
848    Graph->AddSAttrDatE(SrcId, DstId, IntId, IntVal);
849    TFlt FltVal(5.0);
850    Graph->AddSAttrDatE(SrcId, DstId, FltId, FltVal);
851    TStr StrVal("5");
852    Graph->AddSAttrDatE(SrcId, DstId, StrId, StrVal);
853    TAttrPrV AttrV;
854    int status = Graph->GetSAttrVE(SrcId, DstId, atInt, AttrV);
855    EXPECT_EQ(0, status);
856    EXPECT_EQ(1, AttrV.Len());
857    status = Graph->GetSAttrVE(SrcId, DstId, atFlt, AttrV);
858    EXPECT_EQ(0, status);
859    EXPECT_EQ(1, AttrV.Len());
860    status = Graph->GetSAttrVE(SrcId, DstId, atStr, AttrV);
861    EXPECT_EQ(0, status);
862    EXPECT_EQ(1, AttrV.Len());
863  }
864  TEST(TUndirNet, GetIdVSAttrE) {
865    PUndirNet Graph;
866    Graph = TUndirNet::New();
867    TStr IntAttr("TestInt");
868    TInt IntId;
869    Graph->AddSAttrE(IntAttr, atInt, IntId);
870    TStr FltAttr("TestFlt");
871    TInt FltId;
872    Graph->AddSAttrE(FltAttr, atFlt, FltId);
873    TStr StrAttr("TestStr");
874    TInt StrId;
875    Graph->AddSAttrE(StrAttr, atStr, StrId);
876    TInt IntVal(0);
877    TFlt FltVal(0);
878    TStr StrVal("test");
879    Graph->AddNode(0);
880    for (int i = 0; i < 10; i++) {
881      Graph->AddNode(i+1);
882      Graph->AddEdge(i, i+1);
883      Graph->AddSAttrDatE(i, i+1, IntId, IntVal);
884      if (i%2 == 0) {
885        Graph->AddSAttrDatE(i, i+1, FltId, FltVal);
886      }
887    }
888    Graph->AddSAttrDatE(0, 1, StrId, StrVal);
889    TIntPrV IdV;
890    Graph->GetIdVSAttrE(IntAttr, IdV);
891    EXPECT_EQ(10, IdV.Len());
892    Graph->GetIdVSAttrE(IntId, IdV);
893    EXPECT_EQ(10, IdV.Len());
894    Graph->GetIdVSAttrE(FltAttr, IdV);
895    EXPECT_EQ(5, IdV.Len());
896    Graph->GetIdVSAttrE(FltId, IdV);
897    EXPECT_EQ(5, IdV.Len());
898    Graph->GetIdVSAttrE(StrAttr, IdV);
899    EXPECT_EQ(1, IdV.Len());
900    Graph->GetIdVSAttrE(StrId, IdV);
901    EXPECT_EQ(1, IdV.Len());
902  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</h3>
            <pre><code>1  #include "nmobj.h"
2  TNmObjBs::TNmObjBs(
3   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
4   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm):
5    ChDef(),
6    WordStrToNrH(),
7    WordStrVToNmObjAttrSetH(),
8    NmObjWordStrVToNrH(),
9    NmObjWordStrVToDocIdVH(),
10    DocNmToNmObjDocH(){
11    ChDef=THtmlLxChDef::GetChDef();
12    SwSet=TSwSet::GetSwSet(SwSetType);
13    LoadCustSwSet(CustSwSetSIn);
14    LoadNrWordBs(NrWordBsSIn);
15    LoadNmObjTypeBs(WordTypeBsSIn);
16    if (!MteFNm.Empty()){
17      }
18  }
19  TStr TNmObjBs::PeriodTagStr="<.>";
20  TStr TNmObjBs::BreakTagStr="<br>";
21  TStr TNmObjBs::ParagraphTagStr="<p>";
22  TStr TNmObjBs::EofTagStr="<eof>";
23  void TNmObjBs::LoadCustSwSet(const PSIn& SIn){
24    if (SIn.Empty()){return;}
25    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
26    Lx.GetSym(syLn, syEof);
27    while (Lx.Sym!=syEof){
28      TStr WordStrVStr=Lx.Str;
29      TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
30      if (!WordStrV.Empty()){
31        WordStrVToNmObjAttrSetH.AddDat(WordStrV).Incl(noaIgnore);
32      }
33      Lx.GetSym(syLn, syEof);
34    }
35  }
36  void TNmObjBs::LoadNrWordBs(const PSIn& SIn){
37    if (SIn.Empty()){return;}
38    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
39    Lx.GetSym(syQStr, syEoln, syEof);
40    while (Lx.Sym!=syEof){
41      if (Lx.Sym==syQStr){
42        TStr NrWordStr=Lx.Str;
43        Lx.GetSym(syColon);
44        Lx.GetSym(syQStr, syEoln);
45        while (Lx.Sym!=syEoln){
46          TStr WordStr=Lx.Str;
47          if (WordStrToNrH.IsKey(WordStr)){
48            printf("Word already normalized (%s)", WordStr.CStr());}
49          WordStrToNrH.AddDat(WordStr, NrWordStr);
50          Lx.GetSym(syQStr, syEoln);
51        }
52        Lx.GetSym(syQStr, syEoln, syEof);
53      } else
54      if (Lx.Sym==syEoln){
55        Lx.GetSym(syQStr, syEoln, syEof);
56      } else {
57        Fail;
58      }
59    }
60  }
61  TStr TNmObjBs::GetNrWordStr(const TStr& _WordStr) const {
62    TStr WordStr=_WordStr;
63    if (WordStr.IsChIn('_')){
64      WordStr.ChangeChAll('_', '$');
65    }
66    TStr NrWordStr;
67    if (WordStrToNrH.IsKeyGetDat(WordStr, NrWordStr)){
68      return NrWordStr;
69    } else
70    if (MteLex.Empty()){
71      return WordStr;
72    } else {
73      TStr UcWordStr=ChDef->GetUcStr(WordStr); 
74      TStr NrUcWordStr;
75      if (MteLex->IsInfWord(UcWordStr, NrUcWordStr)){
76        if (UcWordStr==NrUcWordStr){
77          return WordStr;
78        } else
79        if (IsAllCapWordStr(WordStr)){
80          return NrUcWordStr;
81        } else
82        if (IsFirstCapWordStr(WordStr)){
83          TChA NrWordChA(NrUcWordStr);
84          ChDef->GetLcChA(NrWordChA);
85          if (NrWordChA.Len()>0){
86            NrWordChA.PutCh(0, ChDef->GetUc(NrWordChA[0]));}
87          return NrWordChA;
88        } else {
89          TStr NrLcWordStr=ChDef->GetLcStr(NrUcWordStr);
90          return NrLcWordStr;
91        }
92      } else {
93        return WordStr;
94      }
95    }
96  }
97  TNmObjAttr TNmObjBs::GetNmObjTypeFromStr(const TStr& Str){
98    if (Str=="Ignore"){return noaIgnore;}
99    if (Str=="Standalone"){return noaStandalone;}
100    if (Str=="AsCapitalized"){return noaAsCapitalized;}
101    if (Str=="Unperiod"){return noaUnperiod;}
102    if (Str=="Acronym"){return noaAcronym;}
103    if (Str=="FirstName"){return noaFirstName;}
104    if (Str=="Person"){return noaPerson;}
105    if (Str=="Company"){return noaCompany;}
106    if (Str=="Organization"){return noaOrganization;}
107    if (Str=="Country"){return noaCountry;}
108    if (Str=="Geography"){return noaGeography;}
109    TExcept::Throw("Invalid Named-Object name.", Str);
110    return noaIgnore;
111  }
112  void TNmObjBs::LoadNmObjTypeBs(const PSIn& SIn){
113    if (SIn.Empty()){return;}
114    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
115    Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
116    while (Lx.Sym!=syEof){
117      if ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
118        TVec<TStrV> NmObjWordStrVV;
119        TB32Set NmObjAttrSet;
120        while ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
121          if (Lx.Sym==syQStr){
122            TStr WordStrVStr=Lx.Str;
123            TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
124            NmObjWordStrVV.Add(WordStrV);
125          } else
126          if (Lx.Sym==syIdStr){
127            TNmObjAttr NmObjAttr=TNmObjBs::GetNmObjTypeFromStr(Lx.Str);
128            NmObjAttrSet.Incl(NmObjAttr);
129          } else {
130            Fail;
131          }
132          Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
133        }
134        if (!NmObjAttrSet.In(noaIgnore)){
135          NmObjAttrSet.Incl(noaDefined);}
136        for (int NmObjN=0; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
137          WordStrVToNmObjAttrSetH.AddDat(NmObjWordStrVV[NmObjN])|=NmObjAttrSet;
138        }
139        {for (int NmObjN=1; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
140          NmObjWordStrVToNrH.AddDat(NmObjWordStrVV[NmObjN], NmObjWordStrVV[0]);
141        }}
142      } else
143      if (Lx.Sym==syEoln){
144        Lx.GetSym(syQStr, syEoln, syEof);
145      } else {
146        Fail;
147      }
148    }
149  }
150  bool TNmObjBs::IsNmObjAttr(const TStr& WordStr, const TNmObjAttr& NmObjAttr) const {
151    TStrV WordStrV; WordStrV.Add(WordStr);
152    return IsNmObjAttr(WordStrV, NmObjAttr);
153  }
154  bool TNmObjBs::IsNmObjAttr(const TStrV& WordStrV, const TNmObjAttr& NmObjAttr) const {
155    int WordStrVToNmObjAttrSetP=WordStrVToNmObjAttrSetH.GetKeyId(WordStrV);
156    if (WordStrVToNmObjAttrSetP==-1){return false;}
157    else {return WordStrVToNmObjAttrSetH[WordStrVToNmObjAttrSetP].In(NmObjAttr);}
158  }
159  bool TNmObjBs::IsFirstCapWordStr(const TStr& Str) const {
160    if (Str.Empty()){return false;}
161    char FirstCh=Str[0];
162    if (!ChDef->IsAlpha(FirstCh)){return false;}
163    if (!ChDef->IsUc(FirstCh)){return false;}
164    return true;
165  }
166  bool TNmObjBs::IsAllCapWordStr(const TStr& Str) const {
167    TChA ChA=Str;
168    for (int ChN=0; ChN<ChA.Len(); ChN++){
169      if (!ChDef->IsUc(ChA[ChN])){return false;}
170    }
171    return true;
172  }
173  bool TNmObjBs::IsNumStr(const TStr& Str) const {
174    if (Str.Empty()){return false;}
175    char FirstCh=Str[0];
176    if (!ChDef->IsNum(FirstCh)){return false;}
177    return true;
178  }
179  bool TNmObjBs::IsTagStr(const TStr& Str) const {
180    return (!Str.Empty())&&(Str[0]=='<');
181  }
182  bool TNmObjBs::IsMatchPfx(
183   const TStr& Str1, const TStr& Str2,
184   const int& MnPfxLen, const int& MxSfxLen) const {
185    TChA ChA1=Str1; TChA ChA2=Str2;
186    int ChN=0;
187    forever {
188      if (ChN>=ChA1.Len()){break;}
189      if (ChN>=ChA2.Len()){break;}
190      if (ChA1[ChN]!=ChA2[ChN]){break;}
191      ChN++;
192    }
193    if (ChN+1<=MnPfxLen){return false;}
194    if (ChA1.Len()-ChN+1>MxSfxLen){return false;}
195    if (ChA2.Len()-ChN+1>MxSfxLen){return false;}
196    return true;
197  }
198  int TNmObjBs::GetNmObjId(const TStrV& WordStrV, const bool& DefP){
199    int NmObjId=-1;
200    if (DefP){
201      NmObjId=NmObjWordStrVToDocIdVH.AddKey(WordStrV);
202    } else {
203      NmObjId=NmObjWordStrVToDocIdVH.GetKeyId(WordStrV);
204    }
205    return NmObjId;
206  }
207  TStr TNmObjBs::GetWordStrVStr(const TStrV& WordStrV, const char& SepCh) const {
208    TChA WordChA;
209    for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
210      if (WordStrN>0){WordChA+=SepCh;}
211      WordChA+=WordStrV[WordStrN];
212    }
213    return WordChA;
214  }
215  void TNmObjBs::GetNrNmObjStrV(const TStrV& NmObjStrV, TStrV& NrNmObjStrV) const {
216    int NmObjWordStrVToNrP=NmObjWordStrVToNrH.GetKeyId(NmObjStrV);
217    if (NmObjWordStrVToNrP==-1){NrNmObjStrV=NmObjStrV;}
218    else {NrNmObjStrV=NmObjWordStrVToNrH[NmObjWordStrVToNrP];}
219  }
220  void TNmObjBs::ExtrCandWordStrV(
221   const TStr& HtmlStr, TStrV& CandWordStrV, const bool& DumpP){
222    CandWordStrV.Clr();
223    PSIn HtmlSIn=TStrIn::New(HtmlStr);
224    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
225    PHtmlTok Tok;
226    THtmlLxSym Sym; TStr Str; TStr NrStr;
227    CandWordStrV.Add(PeriodTagStr);
228    bool InTitle=false; bool InScript=false; int LastNmObjTokN=-1;
229    if (DumpP){printf("Tokens: ");}
230    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
231      PHtmlTok Tok=HtmlDoc->GetTok(TokN);
232      HtmlDoc->GetTok(TokN, Sym, Str);
233      switch (Sym){
234        case hsyUndef: break;
235        case hsyStr:
236        case hsyNum:
237          if (InTitle){break;}
238          if (InScript){break;}
239          NrStr=GetNrWordStr(Str);
240          if (DumpP){
241            if (Str==NrStr){printf("%s ", Str.CStr());}
242            else {printf("%s(%s) ", Str.CStr(), NrStr.CStr());}
243          }
244          if (IsFirstCapWordStr(NrStr)||IsNmObjAttr(NrStr, noaAsCapitalized)){
245            if ((LastNmObjTokN!=-1)&&(LastNmObjTokN<TokN-1)){
246              if (CandWordStrV.Last()!=PeriodTagStr){
247                CandWordStrV.Add(BreakTagStr);
248              }
249            }
250            CandWordStrV.Add(NrStr); LastNmObjTokN=TokN;
251          }
252          break;
253        case hsySSym:
254          if (InTitle){break;}
255          if (InScript){break;}
256          if (DumpP){
257            printf("%s ", Str.CStr());}
258          if (
259           (Str==".")||(Str=="!")||(Str=="?")||
260           (Str=="\"")||(Str=="-")||(Str=="/")||
261           (Str==":")||(Str==";")){
262            if (CandWordStrV.Last()!=PeriodTagStr){
263              CandWordStrV.Add(PeriodTagStr);
264            }
265          }
266          break;
267        case hsyBTag:
268        case hsyETag:
269          if (Str=="<TITLE>"){
270            InTitle=(Sym==hsyBTag);
271          } else
272          if (Str=="<SCRIPT>"){
273            InScript=(Sym==hsyBTag);
274          } else
275          if (Str=="<P>"){
276            if ((!CandWordStrV.Empty())&&(CandWordStrV.Last()!=ParagraphTagStr)){
277              CandWordStrV.Add(ParagraphTagStr);
278              CandWordStrV.Add(PeriodTagStr);
279            }
280          } else
281          if ((Str=="<TD>")||(Str=="<BR>")){
282            CandWordStrV.Add(PeriodTagStr);
283          }
284          break;
285        case hsyEof: break;
286        default: break;
287      }
288    }
289    CandWordStrV.Add(EofTagStr);
290    if (DumpP){printf("\n");}
291    if (DumpP){
292      printf("Candidates: ");
293      for (int CandWordStrN=0; CandWordStrN<CandWordStrV.Len(); CandWordStrN++){
294        printf("%s ", CandWordStrV[CandWordStrN].CStr());}
295      printf("\n");
296    }
297  }
298  void TNmObjBs::FilterCandToNmObjIdV(
299   const TStrV& CandWordStrV, TIntV& NmObjIdV, const bool& DumpP){
300    TVec<TStrV> NmObjIdWordStrVV;
301    int CandWordStrN=0; int CandWordStrs=CandWordStrV.Len();
302    while (CandWordStrN<CandWordStrs){
303      TStr WordStr=CandWordStrV[CandWordStrN];
304      if (WordStr.Len()<=1){CandWordStrN++; continue;}
305      if (WordStr==ParagraphTagStr){CandWordStrN++; continue;}
306      if (WordStr==BreakTagStr){CandWordStrN++; continue;}
307      if (WordStr==EofTagStr){CandWordStrN++; break;}
308      if (IsNumStr(WordStr)){CandWordStrN++; continue;}
309      TStr UcWordStr=ChDef->GetUcStr(WordStr);
310      if ((WordStr==UcWordStr)&&((WordStr.Len()>4)&&(!IsNmObjAttr(WordStr, noaAcronym)))){
311        CandWordStrN++; continue;}
312      if (IsNmObjAttr(WordStr, noaUnperiod)&&(CandWordStrV[CandWordStrN+1]==PeriodTagStr)){
313        CandWordStrN+=1;
314      }
315      if (WordStr==PeriodTagStr){
316        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
317        if (IsTagStr(WordStr)){continue;}
318        if (IsNmObjAttr(WordStr, noaDefined)){
319          continue;
320        } else 
321        if ((CandWordStrN>1)&&(IsNmObjAttr(CandWordStrV[CandWordStrN-2], noaUnperiod))){
322          continue;
323        } else {
324          TStr NextWordStr=CandWordStrV[CandWordStrN+1];
325          if (IsFirstCapWordStr(NextWordStr)||IsNmObjAttr(NextWordStr, noaAsCapitalized)){
326            continue;
327          } else 
328          if (!IsNmObj(WordStr)){
329            CandWordStrN++; continue;
330          }
331        }
332      }
333      if (IsNmObjAttr(WordStr, noaIgnore)){
334        CandWordStrN++; continue;
335      } 
336      TStrV WordStrV;
337      forever {
338        WordStrV.Add(WordStr);
339        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
340        if (IsTagStr(WordStr)){break;}
341        if (WordStr.Len()<=1){break;}
342        if (IsNmObjAttr(WordStr, noaIgnore)){CandWordStrN++; break;}
343        if (IsNmObjAttr(WordStr, noaStandalone)){break;}
344        if (IsNmObjAttr(WordStrV, noaStandalone)){break;}
345      }
346      TStrV NrWordStrV; GetNrNmObjStrV(WordStrV, NrWordStrV);
347      if (IsNmObjAttr(NrWordStrV, noaIgnore)){continue;}
348      if (IsNmObjAttr(NrWordStrV, noaFirstName)){continue;}
349      if (NrWordStrV.Len()>5){
350        while (NrWordStrV.Len()>2){NrWordStrV.Del(0);}}
351      if (NrWordStrV.Len()==1){
352        TStr UcWordStr=ChDef->GetUcStr(NrWordStrV[0]);
353        if (SwSet->IsIn(UcWordStr, true)){continue;}
354      }
355      NmObjIdWordStrVV.Add(NrWordStrV);
356    }
357    for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
358      TStrV& WordStrV=NmObjIdWordStrVV[NmObjN];
359      if (WordStrV.Len()==1){
360        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
361          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
362          if (SubWordStrV.Len()==1){
363            if (WordStrV[0]!=SubWordStrV[0]){
364              if (IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4)){
365                if (WordStrV[0].Len()<SubWordStrV[0].Len()){SubWordStrV=WordStrV;}
366                else {WordStrV=SubWordStrV;}
367              }
368            }
369          }
370        }
371      } else
372      if (WordStrV.Len()>=2){
373        TStr LastNm=WordStrV.Last();
374        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
375          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
376          if (SubWordStrV.Len()==1){
377            TStr SubLastNm=SubWordStrV[0];
378            if (LastNm!=SubLastNm){
379              if (IsMatchPfx(LastNm, SubLastNm, 3, 4)){
380                if (LastNm.Len()<SubLastNm.Len()){SubWordStrV=WordStrV;} 
381                else {WordStrV=SubWordStrV;}
382              }
383            }
384          } else
385          if (false&&(SubWordStrV.Len()==2)){
386            if ((WordStrV[0]!=SubWordStrV[0])||(WordStrV[1]!=SubWordStrV[1])){
387              if ((IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4))&&
388               (IsMatchPfx(WordStrV[1], SubWordStrV[1], 3, 4))){
389                if (WordStrV[0].Len()<SubWordStrV[0].Len()){
390                  SubWordStrV[0]=WordStrV[0];}
391                else {WordStrV[0]=SubWordStrV[0];}
392                if (WordStrV[1].Len()<SubWordStrV[1].Len()){
393                  SubWordStrV[1]=WordStrV[1];}
394                else {WordStrV[1]=SubWordStrV[1];}
395              }
396            }
397          }
398        }
399      }
400    }
401    NmObjIdV.Gen(NmObjIdWordStrVV.Len(), 0);
402    {for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
403      TStrV& NmObjWordStrV=NmObjIdWordStrVV[NmObjN];
404      int NmObjId=GetNmObjId(NmObjWordStrV, true);
405      NmObjIdV.Add(NmObjId);
406    }}
407    if (DumpP){
408      printf("Named-Objects: ");
409      for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
410        int NmObjId=NmObjIdV[NmObjN];
411        TStr NmObjStr=GetNmObjStr(NmObjId);
412        printf("%s ", NmObjStr.CStr());
413      }
414      printf("\n");
415    }
416  }
417  PNmObjBs TNmObjBs::GetFromStrQuV(
418   const TStrQuV& IdTitleSrcHtmlQuV,
419   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
420   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
421   const int& MxDocs, const bool& DumpP){
422    PSIn CustSwSetSIn;
423    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
424      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
425    PSIn NrWordBsSIn;
426    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
427      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
428    PSIn WordTypeBsSIn;
429    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
430      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
431    PNmObjBs NmObjBs=
432     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
433    for (int DocN=0; DocN<IdTitleSrcHtmlQuV.Len(); DocN++){
434      if ((MxDocs!=-1)&&(DocN>MxDocs)){break;}
435      TStr DocNm=IdTitleSrcHtmlQuV[DocN].Val1;
436      TStr TitleStr=IdTitleSrcHtmlQuV[DocN].Val2;
437      TStr HtmlStr=IdTitleSrcHtmlQuV[DocN].Val4;
438      if (DumpP){
439        printf("===============================================\n");
440        printf("%s\n", DocNm.CStr());
441      }
442      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
443      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
444      NmObjBs->AddDoc(DocNm, "", NmObjIdV);
445    }
446    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
447    NmObjBs->PutMergedNmObj(NewNmObjIdV);
448    return NmObjBs;
449  }
450  PNmObjBs TNmObjBs::GetFromCpd(
451   const PSIn& _CpdSIn,
452   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
453   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm,
454   const int& MxDocs, const bool& DumpP){
455    PNmObjBs NmObjBs=
456     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
457    PSIn CpdSIn=TCpDoc::FFirstCpd(_CpdSIn); PCpDoc CpDoc; int Docs=0;
458    while (TCpDoc::FNextCpd(CpdSIn, CpDoc)){
459      if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
460      TStr DocNm=CpDoc->GetDocNm();
461      TStr DateStr=CpDoc->GetDateStr();
462      TStr HtmlStr=CpDoc->GetTxtStr();
463      Docs++; printf("%d %s\r", Docs, DocNm.CStr());
464      if (DumpP){
465        printf("===============================================\n");
466        printf("%s\n", DocNm.CStr());
467      }
468      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
469      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
470      NmObjBs->AddDoc(DocNm, DateStr, NmObjIdV);
471    }
472    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
473    NmObjBs->PutMergedNmObj(NewNmObjIdV);
474    return NmObjBs;
475  }
476  PNmObjBs TNmObjBs::GetFromCpd(
477   const TStr& CpdFNm,
478   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
479   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
480   const int& MxDocs, const bool& DumpP){
481    PSIn CpdSIn=TFIn::New(CpdFNm);
482    PSIn CustSwSetSIn;
483    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
484      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
485    PSIn NrWordBsSIn;
486    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
487      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
488    PSIn WordTypeBsSIn;
489    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
490      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
491    return TNmObjBs::GetFromCpd(
492     CpdSIn, SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm,
493     MxDocs, DumpP);
494  }
495  void TNmObjBs::GetMergedNmObj(TIntV& NewNmObjIdV){
496    int MnPfxLen=3; int MxSfxLen=2;
497    int NmObjs=NmObjWordStrVToDocIdVH.Len();
498    NewNmObjIdV.Gen(NmObjs); NewNmObjIdV.PutAll(-1);
499    {int SingleWords=0; int ReducedSingleWords=0;
500    TStrIntVH PfxStrToNmObjIdVH;
501    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
502      if (NewNmObjIdV[NmObjId]!=-1){continue;}
503      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
504      if (WordStrV.Len()==1){
505        TStr PfxStr=WordStrV[0].GetSubStr(0, 2);
506        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
507        SingleWords++;
508      }
509    }
510    int Pfxs=PfxStrToNmObjIdVH.Len();
511    for (int PfxId=0; PfxId<Pfxs; PfxId++){
512      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
513      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
514        int NmObjId=NmObjIdV[NmObjIdN];
515        if (NewNmObjIdV[NmObjId]!=-1){continue;}
516        NewNmObjIdV[NmObjId]=NmObjId;
517        const TStr& WordStr=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
518        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
519        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
520        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
521        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
522          int SubNmObjId=NmObjIdV[SubNmObjIdN];
523          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
524          const TStr& SubWordStr=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
525          if (IsMatchPfx(WordStr, SubWordStr, MnPfxLen, MxSfxLen)){
526            NewNmObjIdV[SubNmObjId]=NmObjId;
527            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
528            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
529          }
530        }
531        ReducedSingleWords++;
532        if (FqNmObjIdPrV.Len()>1){
533          FqNmObjIdPrV.Sort(false);
534          int MainNmObjId=FqNmObjIdPrV[0].Val2;
535          NewNmObjIdV[MainNmObjId]=MainNmObjId;
536          TStr MainWordStr=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
537          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
538            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
539            NewNmObjIdV[SubNmObjId]=MainNmObjId;
540          }
541        }
542      }
543    }
544    }
545    {int DoubleWords=0; int ReducedDoubleWords=0;
546    TStrIntVH PfxStrToNmObjIdVH;
547    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
548      if (NewNmObjIdV[NmObjId]!=-1){continue;}
549      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
550      if (WordStrV.Len()==2){
551        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2);
552        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
553        DoubleWords++;
554      }
555    }
556    int Pfxs=PfxStrToNmObjIdVH.Len();
557    for (int PfxId=0; PfxId<Pfxs; PfxId++){
558      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
559      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
560        int NmObjId=NmObjIdV[NmObjIdN];
561        if (NewNmObjIdV[NmObjId]!=-1){continue;}
562        NewNmObjIdV[NmObjId]=NmObjId;
563        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
564        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
565        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
566        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
567        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
568        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
569          int SubNmObjId=NmObjIdV[SubNmObjIdN];
570          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
571          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
572          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
573          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
574           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)){
575            NewNmObjIdV[SubNmObjId]=NmObjId;
576            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
577            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
578          }
579        }
580        ReducedDoubleWords++;
581        if (FqNmObjIdPrV.Len()>1){
582          FqNmObjIdPrV.Sort(false);
583          int MainNmObjId=FqNmObjIdPrV[0].Val2;
584          NewNmObjIdV[MainNmObjId]=MainNmObjId;
585          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
586          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
587          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
588            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
589            NewNmObjIdV[SubNmObjId]=MainNmObjId;
590          }
591        }
592      }
593    }
594    }
595    {int TripleWords=0; int ReducedTripleWords=0;
596    TStrIntVH PfxStrToNmObjIdVH;
597    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
598      if (NewNmObjIdV[NmObjId]!=-1){continue;}
599      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
600      if (WordStrV.Len()==3){
601        TripleWords++;
602        TStrV DbWordStrV(2, 0);
603        DbWordStrV.Add(WordStrV[1]); DbWordStrV.Add(WordStrV[2]);
604        int DbNmObjId=NmObjWordStrVToDocIdVH.GetKeyId(DbWordStrV);
605        if (DbNmObjId!=-1){
606          ReducedTripleWords++;
607          int NewDbNmObjId=NewNmObjIdV[DbNmObjId];
608          NewNmObjIdV[NmObjId]=NewDbNmObjId;
609        }
610      }
611    }
612    }
613    {int TripleWords=0; int ReducedTripleWords=0;
614    TStrIntVH PfxStrToNmObjIdVH;
615    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
616      if (NewNmObjIdV[NmObjId]!=-1){continue;}
617      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
618      if (WordStrV.Len()==3){
619        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2)+WordStrV[2].GetSubStr(0, 2);
620        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
621        TripleWords++;
622      }
623    }
624    int Pfxs=PfxStrToNmObjIdVH.Len();
625    for (int PfxId=0; PfxId<Pfxs; PfxId++){
626      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
627      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
628        int NmObjId=NmObjIdV[NmObjIdN];
629        if (NewNmObjIdV[NmObjId]!=-1){continue;}
630        NewNmObjIdV[NmObjId]=NmObjId;
631        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
632        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
633        const TStr& WordStr3=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[2];
634        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
635        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
636        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
637        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
638          int SubNmObjId=NmObjIdV[SubNmObjIdN];
639          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
640          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
641          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
642          const TStr& SubWordStr3=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[2];
643          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
644           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)&&
645           IsMatchPfx(WordStr3, SubWordStr3, MnPfxLen, MxSfxLen+1)){
646            NewNmObjIdV[SubNmObjId]=NmObjId;
647            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
648            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
649          }
650        }
651        ReducedTripleWords++;
652        if (FqNmObjIdPrV.Len()>1){
653          FqNmObjIdPrV.Sort(false);
654          int MainNmObjId=FqNmObjIdPrV[0].Val2;
655          NewNmObjIdV[MainNmObjId]=MainNmObjId;
656          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
657          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
658          TStr MainWordStr3=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[2];
659          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
660            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
661            NewNmObjIdV[SubNmObjId]=MainNmObjId;
662          }
663        }
664      }
665    }
666    }
667  }
668  void TNmObjBs::PutMergedNmObj(const TIntV& NewNmObjIdV){
669    TStrVIntVH NewNmObjWordStrVToDocIdVH;
670    for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
671      if (NewNmObjIdV[NmObjId]!=NmObjId){continue;}
672      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
673      NewNmObjWordStrVToDocIdVH.AddDat(WordStrV);
674    }
675    {for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
676      if (NewNmObjIdV[NmObjId]==NmObjId){continue;}
677      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
678      int NrNmObjId=NewNmObjIdV[NmObjId];
679      if (NrNmObjId!=-1){
680        const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
681        NmObjWordStrVToNrH.AddDat(WordStrV, NrWordStrV);
682      }
683    }}
684    int Docs=GetDocs();
685    for (int DocId=0; DocId<Docs; DocId++){
686      TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
687      TIntIntH NewNmObjIdToFqH(NmObjIdFqPrV.Len());
688      for (int NmObjN=0; NmObjN<NmObjIdFqPrV.Len(); NmObjN++){
689        int NmObjId=NmObjIdFqPrV[NmObjN].Val1;
690        int Fq=NmObjIdFqPrV[NmObjN].Val2;
691        int NrNmObjId=NewNmObjIdV[NmObjId];
692        if (NrNmObjId!=-1){
693          const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
694          int NewNmObjId=NewNmObjWordStrVToDocIdVH.GetKeyId(NrWordStrV);
695          NewNmObjIdToFqH.AddDat(NewNmObjId)+=Fq;
<span onclick='openModal()' class='match'>696        }
697      }
698      NmObjIdFqPrV.Gen(NewNmObjIdToFqH.Len(), 0);
699      for (int NmObjP=0; NmObjP<NewNmObjIdToFqH.Len(); NmObjP++){
700        int NewNmObjId=NewNmObjIdToFqH.GetKey(NmObjP);
701        int Fq=NewNmObjIdToFqH[NmObjP];
</span>702        NmObjIdFqPrV.Add(TIntPr(NewNmObjId, Fq));
703        NewNmObjWordStrVToDocIdVH[NewNmObjId].Add(DocId);
704      }
705      NmObjIdFqPrV.Sort();
706    }
707    NmObjWordStrVToDocIdVH=NewNmObjWordStrVToDocIdVH;
708  }
709  void TNmObjBs::GetNmObjStrFqPrV(TStrIntPrV& NmObjStrFqPrV, const int& MnFq) const {
710    int NmObjs=GetNmObjs();
711    NmObjStrFqPrV.Gen(NmObjs, 0);
712    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
713      TStrIntPr NmObjStrFqPr;
714      NmObjStrFqPr.Val1=GetNmObjStr(NmObjId);
715      NmObjStrFqPr.Val2=GetNmObjDocs(NmObjId);
716      if (NmObjStrFqPr.Val2>=MnFq){
717        NmObjStrFqPrV.Add(NmObjStrFqPr);}
718    }
719  }
720  void TNmObjBs::GetNmObjFqStrPrV(TIntStrPrV& NmObjFqStrPrV, const int& MnFq) const {
721    int NmObjs=GetNmObjs();
722    NmObjFqStrPrV.Gen(NmObjs, 0);
723    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
724      TIntStrPr NmObjFqStrPr;
725      NmObjFqStrPr.Val1=GetNmObjDocs(NmObjId);
726      NmObjFqStrPr.Val2=GetNmObjStr(NmObjId);
727      if (NmObjFqStrPr.Val1>=MnFq){
728        NmObjFqStrPrV.Add(NmObjFqStrPr);}
729    }
730  }
731  void TNmObjBs::GetNmObjDIdV(
732   const PBowDocBs& BowDocBs, TIntV& BowDIdV, 
733   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
734    int NmObjId1=GetNmObjId(NmObjStr1);
735    TIntV NmObjDocIdV1; GetNmObjDocIdV(NmObjId1, NmObjDocIdV1);
736    NmObjDocIdV1.Sort();
737    TIntV NmObjDocIdV2;
738    if (!NmObjStr2.Empty()){
739      int NmObjId2=GetNmObjId(NmObjStr2);
740      GetNmObjDocIdV(NmObjId2, NmObjDocIdV2);
741      NmObjDocIdV2.Sort();
742    }
743    TIntV NmObjDocIdV;
744    if (NmObjDocIdV2.Empty()){
745      NmObjDocIdV=NmObjDocIdV1;
746    } else {
747      NmObjDocIdV1.Intrs(NmObjDocIdV2, NmObjDocIdV);
748    }
749    BowDIdV.Gen(NmObjDocIdV.Len(), 0);
750    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocIdV.Len(); NmObjDocIdN++){
751      TStr DocNm=GetDocNm(NmObjDocIdV[NmObjDocIdN]);
752      int DId=BowDocBs->GetDId(DocNm);
753      if (DId!=-1){
754        BowDIdV.Add(DId);
755      } 
756    }
757  }
758  PBowSpV TNmObjBs::GetNmObjConcept(
759   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs,
760   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
761    TIntV BowDIdV; GetNmObjDIdV(BowDocBs, BowDIdV, NmObjStr1, NmObjStr2);
762    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, NULL, BowDIdV);
763    return ConceptSpV;
764  }
765  void TNmObjBs::GetFqNmObjIdPrV(
766   const TStr& TargetNmObjStr, TIntPrV& FqNmObjIdPrV) const {
767    int TargetNmObjId=GetNmObjId(TargetNmObjStr);
768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
772      int DocNmObjs=GetDocNmObjs(DocId);
773      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
774        int NmObjId; int TermFq;
775        GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
776        NmObjIdToFqH.AddDat(NmObjId)++;
777      }
778    }
779    FqNmObjIdPrV.Clr(); NmObjIdToFqH.GetDatKeyPrV(FqNmObjIdPrV);
780    FqNmObjIdPrV.Sort(false);
781  }
782  int TNmObjBs::AddDoc(const TStr& DocNm, const TStr& DateStr, const TIntV& NmObjIdV){
783    TIntIntH NmObjIdToFqH(NmObjIdV.Len());
784    for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
785      int NmObjId=NmObjIdV[NmObjN];
786      NmObjIdToFqH.AddDat(NmObjId)++;
787    }
788    IAssert(!IsDoc(DocNm));
789    int DocId=DocNmToNmObjDocH.AddKey(DocNm);
790    DocNmToNmObjDocH[DocId]=TNmObjDoc::New();
791    DocNmToNmObjDocH[DocId]->DateStr=DateStr;
792    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
793    for (int NmObjP=0; NmObjP<NmObjIdToFqH.Len(); NmObjP++){
794      int NmObjId=NmObjIdToFqH.GetKey(NmObjP);
795      int Fq=NmObjIdToFqH[NmObjP];
796      NmObjIdFqPrV.Add(TIntPr(NmObjId, Fq));
797      NmObjWordStrVToDocIdVH[NmObjId].AddSorted(DocId);
798    }
799    NmObjIdFqPrV.Sort();
800    return DocId;
801  }
802  TStr TNmObjBs::GetDoc_NmObjStrVStr(const int& DocId, const char& SepCh) const {
803    TChA NmObjStrVChA;
804    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
805    for (int NmObjIdN=0; NmObjIdN<NmObjIdFqPrV.Len(); NmObjIdN++){
806      if (NmObjIdN>0){NmObjStrVChA+=SepCh;}
807      int NmObjId=NmObjIdFqPrV[NmObjIdN].Val1;
808      TStr NmObjStr=GetNmObjStr(NmObjId);
809      NmObjStrVChA+=NmObjStr;
810    }
811    return NmObjStrVChA;
812  }
813  PBowDocBs TNmObjBs::GetBowDocBs(const int& MnNmObjFq) const {
814    printf("Generating Bag-Of-Words...\n");
815    PBowDocBs BowDocBs=TBowDocBs::New();
816    for (int DocId=0; DocId<GetDocs(); DocId++){
817      if (DocId%100==0){printf("%d\r", DocId);}
818      TStr DocNm=GetDocNm(DocId);
819      TStr DateStr=GetDocDateStr(DocId);
820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
824        if ((MnNmObjFq==-1)||(GetNmObjDocs(NmObjId)>=MnNmObjFq)){
825          TStr NmObjStr=GetNmObjStr(NmObjId);
826          for (int TermOccN=0; TermOccN<TermFq; TermOccN++){
827            WordStrV.Add(NmObjStr);
828          }
829        }
830      }
831      if (!WordStrV.Empty()){
832        int DId=BowDocBs->AddDoc(DocNm, TStrV(), WordStrV);
833        BowDocBs->PutDateStr(DId, DateStr);
834     }
835    }
836    BowDocBs->AssertOk();
837    printf("\nDone.\n");
838    return BowDocBs;
839  }
840  PBowDocBs TNmObjBs::GetNmBowDocBs(
841   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
842    int NmObjs=GetNmObjs();
843    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
844      printf("%d/%d\r", (1+NmObjId), NmObjs);
845      TStr NmObjStr=GetNmObjStr(NmObjId);
846      PBowSpV BowSpV=GetNmObjConcept(BowDocBs, BowDocWgtBs, NmObjStr);
847    }
848    printf("\n");
849    return NULL;
850  }
851  PBowDocBs TNmObjBs::GetRelBowDocBs(const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
852    return NULL;
853  }
854  void TNmObjBs::SaveTxtNmObj(const TStr& FqFNm, const TStr& SwFNm,
855   const TStr& AbcFNm, const TStr& DocFNm) const {
856    TIntStrVPrV FqWordStrVPrV(NmObjWordStrVToDocIdVH.Len(), 0);
857    TStrVIntPrV WordStrVFqPrV(NmObjWordStrVToDocIdVH.Len(), 0);
858    for (int NmObjId=0; NmObjId<NmObjWordStrVToDocIdVH.Len(); NmObjId++){
859      int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
860      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
861      FqWordStrVPrV.Add(TIntStrVPr(Fq, WordStrV));
862      WordStrVFqPrV.Add(TStrVIntPr(WordStrV, Fq));
863    }
864    FqWordStrVPrV.Sort(false);
865    WordStrVFqPrV.Sort();
866    if (!FqFNm.Empty()){
867      printf("Saving by frequency to '%s' ...", FqFNm.CStr());
868      TFOut SOut(FqFNm); FILE* fOut=SOut.GetFileId();
869      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
870        int Fq=FqWordStrVPrV[PrN].Val1;
871        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
872        TStr WordStrVStr=GetWordStrVStr(WordStrV);
873        fprintf(fOut, "%d - %s\n", Fq, WordStrVStr.CStr());
874      }
875      printf(" Done.\n");
876    }
877    if (!SwFNm.Empty()){
878      printf("Saving by frequency for stop-words proposal to '%s' ...", SwFNm.CStr());
879      TFOut SOut(SwFNm); FILE* fOut=SOut.GetFileId();
880      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
881        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
882        TStr WordStrVStr=GetWordStrVStr(WordStrV, ' ');
883        fprintf(fOut, "%s\n", WordStrVStr.CStr());
884      }
885      printf(" Done.\n");
886    }
887    if (!AbcFNm.Empty()){
888      printf("Saving by alphabet to '%s' ...", AbcFNm.CStr());
889      TFOut SOut(AbcFNm); FILE* fOut=SOut.GetFileId();
890      for (int PrN=0; PrN<WordStrVFqPrV.Len(); PrN++){
891        TStrV& WordStrV=WordStrVFqPrV[PrN].Val1;
892        int Fq=WordStrVFqPrV[PrN].Val2;
893        TStr WordStrVStr=GetWordStrVStr(WordStrV);
894        fprintf(fOut, "%s - %d [", WordStrVStr.CStr(), Fq);
895        int NmObjId=GetNmObjId(WordStrV);
896        TIntV DocIdV;
897        GetNmObjDocIdV(NmObjId, DocIdV);
898        for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
899          TStr DocNm=GetDocNm(DocIdV[DocIdN]);
900          fprintf(fOut, "'%s' ", DocNm.CStr());
901        }
902        fprintf(fOut, "]\n");
903      }
904      printf(" Done.\n");
905    }
906    if (!DocFNm.Empty()){
907      printf("Saving by documents to '%s' ...", DocFNm.CStr());
908      TFOut SOut(DocFNm); FILE* fOut=SOut.GetFileId();
909      for (int DocId=0; DocId<GetDocs(); DocId++){
910        TStr DocNm=GetDocNm(DocId);
911        fprintf(fOut, "'%s'(%d):", DocNm.CStr(), DocId);
912        TStr DateStr=GetDocDateStr(DocId);
913        if (!DateStr.Empty()){
914          fprintf(fOut, "[%s]", DateStr.CStr());}
915        int DocNmObjs=GetDocNmObjs(DocId);
916        for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
917          int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
918          TStr NmObjStr=GetNmObjStr(NmObjId);
919          fprintf(fOut, " [%s:%d]", NmObjStr.CStr(), TermFq);
920        }
921        fprintf(fOut, "\n");
922      }
923      printf(" Done.\n");
924    }
925  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-TUndirNet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</div>
                </div>
                <div class="column column_space"><pre><code>166            }
167            DelEdgeV.Add(Edge);
168          }
169          EXPECT_TRUE(EdgeSet.Empty());
170          EXPECT_TRUE(DelEdgeV.Len() == NEdges);
171          NodeIds.Shuffle(TInt::Rnd);
172          for (int n = 0; n < NNodes; n++) {
173            TIntPrV DelEdgeNodeV;
174            int DelNodeId = NodeIds[n];
175            int EdgesBeforeDel;
176            EdgesBeforeDel = Graph->GetEdges();
</pre></code></div>
                <div class="column column_space"><pre><code>696        }
697      }
698      NmObjIdFqPrV.Gen(NewNmObjIdToFqH.Len(), 0);
699      for (int NmObjP=0; NmObjP<NewNmObjIdToFqH.Len(); NmObjP++){
700        int NewNmObjId=NewNmObjIdToFqH.GetKey(NmObjP);
701        int Fq=NewNmObjIdToFqH[NmObjP];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    