
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.184990125082291%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-polyaprx.cpp</h3>
            <pre><code>1  #include "polyaprx.h"
2  #include "blobs.h"   
3  #include "coutln.h"  
4  #include "errcode.h" 
5  #include "mod128.h"  
6  #include "params.h"  
7  #include "points.h"  
8  #include "rect.h"    
9  #include "tprintf.h" 
10  #include <cstdint> 
11  namespace tesseract {
12  #define FASTEDGELENGTH 256
13  static BOOL_VAR(poly_debug, false, "Debug old poly");
14  static BOOL_VAR(poly_wide_objects_better, true,
15                  "More accurate approx on wide things");
16  #define fixed_dist 20  
17  #define approx_dist 15 
18  const int par1 = 4500 / (approx_dist * approx_dist);
19  const int par2 = 6750 / (approx_dist * approx_dist);
20  static void cutline(       
21      EDGEPT *first,         
22      EDGEPT *last, int area 
23  ) {
24    EDGEPT *edge;     
25    TPOINT vecsum;    
26    int vlen;         
27    TPOINT vec;       
28    EDGEPT *maxpoint; 
29    int maxperp;      
30    int perp;         
31    int ptcount;      
32    int squaresum;    
33    edge = first; 
34    if (edge->next == last) {
35      return; 
36    }
37    vecsum.x = last->pos.x - edge->pos.x;
38    vecsum.y = last->pos.y - edge->pos.y;
39    if (vecsum.x == 0 && vecsum.y == 0) {
40      vecsum.x = -edge->prev->vec.x;
41      vecsum.y = -edge->prev->vec.y;
42    }
43    vlen = vecsum.x > 0 ? vecsum.x : -vecsum.x;
44    if (vecsum.y > vlen) {
45      vlen = vecsum.y; 
46    } else if (-vecsum.y > vlen) {
47      vlen = -vecsum.y; 
48    }
49    vec.x = edge->vec.x; 
50    vec.y = edge->vec.y;
51    maxperp = 0; 
52    squaresum = ptcount = 0;
53    edge = edge->next; 
54    maxpoint = edge;   
55    do {
56      perp = vec.cross(vecsum); 
57      if (perp != 0) {
58        perp *= perp; 
59      }
60      squaresum += perp; 
61      ptcount++;         
62      if (poly_debug) {
63        tprintf("Cutline:Final perp=%d\n", perp);
64      }
65      if (perp > maxperp) {
66        maxperp = perp;
67        maxpoint = edge; 
68      }
69      vec.x += edge->vec.x; 
70      vec.y += edge->vec.y;
71      edge = edge->next;
72    } while (edge != last); 
73    perp = vecsum.length();
74    ASSERT_HOST(perp != 0);
75    if (maxperp < 256 * INT16_MAX) {
76      maxperp <<= 8;
77      maxperp /= perp; 
78    } else {
79      maxperp /= perp;
80      maxperp <<= 8; 
81    }
82    if (squaresum < 256 * INT16_MAX) {
83      perp = (squaresum << 8) / (perp * ptcount);
84    } else {
85      perp = (squaresum / perp << 8) / ptcount;
86    }
87    if (poly_debug) {
88      tprintf("Cutline:A=%d, max=%.2f(%.2f%%), msd=%.2f(%.2f%%)\n", area,
89              maxperp / 256.0, maxperp * 200.0 / area, perp / 256.0,
90              perp * 300.0 / area);
91    }
92    if (maxperp * par1 >= 10 * area || perp * par2 >= 10 * area || vlen >= 126) {
93      maxpoint->fixed = true;
94      cutline(first, maxpoint, area);
95      cutline(maxpoint, last, area);
96    }
97  }
98  static EDGEPT *edgesteps_to_edgepts( 
99      C_OUTLINE *c_outline,            
100      EDGEPT edgepts[]                 
101  ) {
102    int32_t length;    
103    ICOORD pos;        
104    int32_t stepindex; 
105    int32_t stepinc;   
106    int32_t epindex;   
107    ICOORD vec;        
108    ICOORD prev_vec;
109    int8_t epdir;   
110    DIR128 prevdir; 
111    DIR128 dir;     
112    pos = c_outline->start_pos(); 
113    length = c_outline->pathlength();
114    stepindex = 0;
115    epindex = 0;
116    prevdir = -1;
117    uint32_t count = 0;
118    int prev_stepindex = 0;
119    do {
120      dir = c_outline->step_dir(stepindex);
121      vec = c_outline->step(stepindex);
122      if (stepindex < length - 1 &&
123          c_outline->step_dir(stepindex + 1) - dir == -32) {
124        dir += 128 - 16;
125        vec += c_outline->step(stepindex + 1);
126        stepinc = 2;
127      } else {
128        stepinc = 1;
129      }
130      if (count == 0) {
131        prevdir = dir;
132        prev_vec = vec;
133      }
<span onclick='openModal()' class='match'>134      if (prevdir.get_dir() != dir.get_dir()) {
135        edgepts[epindex].pos.x = pos.x();
136        edgepts[epindex].pos.y = pos.y();
137        prev_vec *= count;
138        edgepts[epindex].vec.x = prev_vec.x();
139        edgepts[epindex].vec.y = prev_vec.y();
140        pos += prev_vec;
141        edgepts[epindex].runlength = count;
142        edgepts[epindex].prev = &edgepts[epindex - 1];
</span>143        edgepts[epindex].fixed = false;
144        edgepts[epindex].next = &edgepts[epindex + 1];
145        prevdir += 64;
146        epdir = DIR128(0) - prevdir;
147        epdir >>= 4;
148        epdir &= 7;
149        edgepts[epindex].dir = epdir;
150        edgepts[epindex].src_outline = c_outline;
151        edgepts[epindex].start_step = prev_stepindex;
152        edgepts[epindex].step_count = stepindex - prev_stepindex;
153        epindex++;
154        prevdir = dir;
155        prev_vec = vec;
156        count = 1;
157        prev_stepindex = stepindex;
158      } else {
159        count++;
160      }
161      stepindex += stepinc;
162    } while (stepindex < length);
163    edgepts[epindex].pos.x = pos.x();
164    edgepts[epindex].pos.y = pos.y();
165    prev_vec *= count;
166    edgepts[epindex].vec.x = prev_vec.x();
167    edgepts[epindex].vec.y = prev_vec.y();
168    pos += prev_vec;
169    edgepts[epindex].runlength = count;
170    edgepts[epindex].fixed = false;
171    edgepts[epindex].src_outline = c_outline;
172    edgepts[epindex].start_step = prev_stepindex;
173    edgepts[epindex].step_count = stepindex - prev_stepindex;
174    edgepts[epindex].prev = &edgepts[epindex - 1];
175    edgepts[epindex].next = &edgepts[0];
176    prevdir += 64;
177    epdir = DIR128(0) - prevdir;
178    epdir >>= 4;
179    epdir &= 7;
180    edgepts[epindex].dir = epdir;
181    edgepts[0].prev = &edgepts[epindex];
182    ASSERT_HOST(pos.x() == c_outline->start_pos().x() &&
183                pos.y() == c_outline->start_pos().y());
184    return &edgepts[0];
185  }
186  static void fix2(  
187      EDGEPT *start, 
188      int area) {
189    EDGEPT *edgept; 
190    EDGEPT *edgept1;
191    EDGEPT *loopstart; 
192    EDGEPT *linestart; 
193    int fixed_count;   
194    int8_t dir;
195    int d01, d12, d23, gapmin;
196    TPOINT d01vec, d12vec, d23vec;
197    EDGEPT *edgefix, *startfix;
198    EDGEPT *edgefix0, *edgefix1, *edgefix2, *edgefix3;
199    edgept = start; 
200    while (((edgept->dir - edgept->prev->dir + 1) & 7) < 3 &&
201           (dir = (edgept->prev->dir - edgept->next->dir) & 7) != 2 && dir != 6) {
202      edgept = edgept->next; 
203    }
204    loopstart = edgept; 
205    bool stopped = false;
206    edgept->fixed = true; 
207    do {
208      linestart = edgept;      
209      auto dir1 = edgept->dir; 
210      auto sum1 = edgept->runlength;
211      edgept = edgept->next;
212      auto dir2 = edgept->dir; 
213      auto sum2 = edgept->runlength;
214      if (((dir1 - dir2 + 1) & 7) < 3) {
215        while (edgept->prev->dir == edgept->next->dir) {
216          edgept = edgept->next; 
217          if (edgept->dir == dir1) {
218            sum1 += edgept->runlength;
219          } else {
220            sum2 += edgept->runlength;
221          }
222        }
223        if (edgept == loopstart) {
224          stopped = true;
225        }
226        if (sum2 + sum1 > 2 && linestart->prev->dir == dir2 &&
227            (linestart->prev->runlength > linestart->runlength || sum2 > sum1)) {
228          linestart = linestart->prev;
229          linestart->fixed = true;
230        }
231        if (((edgept->next->dir - edgept->dir + 1) & 7) >= 3 ||
232            (edgept->dir == dir1 && sum1 >= sum2) ||
233            ((edgept->prev->runlength < edgept->runlength ||
234              (edgept->dir == dir2 && sum2 >= sum1)) &&
235             linestart->next != edgept)) {
236          edgept = edgept->next;
237        }
238      }
239      edgept->fixed = true;
240    }
241    while (edgept != loopstart && !stopped);
242    edgept = start;
243    do {
244      if (((edgept->runlength >= 8) && (edgept->dir != 2) &&
245           (edgept->dir != 6)) ||
246          ((edgept->runlength >= 8) &&
247           ((edgept->dir == 2) || (edgept->dir == 6)))) {
248        edgept->fixed = true;
249        edgept1 = edgept->next;
250        edgept1->fixed = true;
251      }
252      edgept = edgept->next;
253    } while (edgept != start);
254    edgept = start;
255    do {
256      if (edgept->fixed &&
257          edgept->runlength == 1
258          && edgept->next->fixed &&
259          !edgept->prev->fixed
260          && !edgept->next->next->fixed &&
261          edgept->prev->dir == edgept->next->dir &&
262          edgept->prev->prev->dir == edgept->next->next->dir &&
263          ((edgept->prev->dir - edgept->dir + 1) & 7) < 3) {
264        edgept->fixed = false;
265        edgept->next->fixed = false;
266      }
267      edgept = edgept->next;   
268    } while (edgept != start); 
269    stopped = false;
270    if (area < 450) {
271      area = 450;
272    }
273    gapmin = area * fixed_dist * fixed_dist / 44000;
274    edgept = start;
275    fixed_count = 0;
276    do {
277      if (edgept->fixed) {
278        fixed_count++;
279      }
280      edgept = edgept->next;
281    } while (edgept != start);
282    while (!edgept->fixed) {
283      edgept = edgept->next;
284    }
285    edgefix0 = edgept;
286    edgept = edgept->next;
287    while (!edgept->fixed) {
288      edgept = edgept->next;
289    }
290    edgefix1 = edgept;
291    edgept = edgept->next;
292    while (!edgept->fixed) {
293      edgept = edgept->next;
294    }
295    edgefix2 = edgept;
296    edgept = edgept->next;
297    while (!edgept->fixed) {
298      edgept = edgept->next;
299    }
300    edgefix3 = edgept;
301    startfix = edgefix2;
302    do {
303      if (fixed_count <= 3) {
304        break; 
305      }
306      d12vec.diff(edgefix1->pos, edgefix2->pos);
307      d12 = d12vec.length();
308      if (d12 <= gapmin) {
309        d01vec.diff(edgefix0->pos, edgefix1->pos);
310        d01 = d01vec.length();
311        d23vec.diff(edgefix2->pos, edgefix3->pos);
312        d23 = d23vec.length();
313        if (d01 > d23) {
314          edgefix2->fixed = false;
315          fixed_count--;
316        } else {
317          edgefix1->fixed = false;
318          fixed_count--;
319          edgefix1 = edgefix2;
320        }
321      } else {
322        edgefix0 = edgefix1;
323        edgefix1 = edgefix2;
324      }
325      edgefix2 = edgefix3;
326      edgept = edgept->next;
327      while (!edgept->fixed) {
328        if (edgept == startfix) {
329          stopped = true;
330        }
331        edgept = edgept->next;
332      }
333      edgefix3 = edgept;
334      edgefix = edgefix2;
335    } while ((edgefix != startfix) && (!stopped));
336  }
337  static EDGEPT *poly2( 
338      EDGEPT *startpt,  
339      int area          
340  ) {
341    EDGEPT *edgept;    
342    EDGEPT *loopstart; 
343    EDGEPT *linestart; 
344    int edgesum;       
345    if (area < 1200) {
346      area = 1200; 
347    }
348    loopstart = nullptr; 
349    edgept = startpt;    
350    do {
351      if (edgept->fixed && !edgept->next->fixed) {
352        loopstart = edgept; 
353        break;
354      }
355      edgept = edgept->next;     
356    } while (edgept != startpt); 
357    if (loopstart == nullptr && !startpt->fixed) {
358      startpt->fixed = true;
359      loopstart = startpt; 
360    }
361    if (loopstart) {
362      do {
363        edgept = loopstart; 
364        do {
365          linestart = edgept;
366          edgesum = 0; 
367          do {
368            edgesum += edgept->runlength;
369            edgept = edgept->next; 
370          } while (!edgept->fixed && edgept != loopstart && edgesum < 126);
371          if (poly_debug) {
372            tprintf("Poly2:starting at (%d,%d)+%d=(%d,%d),%d to (%d,%d)\n",
373                    linestart->pos.x, linestart->pos.y, linestart->dir,
374                    linestart->vec.x, linestart->vec.y, edgesum, edgept->pos.x,
375                    edgept->pos.y);
376          }
377          cutline(linestart, edgept, area);
378          while (edgept->next->fixed && edgept != loopstart) {
379            edgept = edgept->next; 
380          }
381        }
382        while (edgept != loopstart);
383        edgesum = 0;
384        do {
385          if (edgept->fixed) {
386            edgesum++;
387          }
388          edgept = edgept->next;
389        }
390        while (edgept != loopstart);
391        if (edgesum < 3) {
392          area /= 2; 
393        }
394      } while (edgesum < 3);
395      do {
396        linestart = edgept;
397        do {
398          edgept = edgept->next;
399        } while (!edgept->fixed);
400        linestart->next = edgept;
401        edgept->prev = linestart;
402        linestart->vec.x = edgept->pos.x - linestart->pos.x;
403        linestart->vec.y = edgept->pos.y - linestart->pos.y;
404      } while (edgept != loopstart);
405    } else {
406      edgept = startpt; 
407    }
408    loopstart = edgept; 
409    return loopstart;   
410  }
411  TESSLINE *ApproximateOutline(bool allow_detailed_fx, C_OUTLINE *c_outline) {
412    EDGEPT stack_edgepts[FASTEDGELENGTH]; 
413    EDGEPT *edgepts = stack_edgepts;
414    if (c_outline->pathlength() > FASTEDGELENGTH) {
415      edgepts = new EDGEPT[c_outline->pathlength()];
416    }
417    const auto &loop_box = c_outline->bounding_box();
418    int32_t area = loop_box.height();
419    if (!poly_wide_objects_better && loop_box.width() > area) {
420      area = loop_box.width();
421    }
422    area *= area;
423    edgesteps_to_edgepts(c_outline, edgepts);
424    fix2(edgepts, area);
425    EDGEPT *edgept = poly2(edgepts, area); 
426    EDGEPT *startpt = edgept;
427    EDGEPT *result = nullptr;
428    EDGEPT *prev_result = nullptr;
429    do {
430      auto *new_pt = new EDGEPT;
431      new_pt->pos = edgept->pos;
432      new_pt->prev = prev_result;
433      if (prev_result == nullptr) {
434        result = new_pt;
435      } else {
436        prev_result->next = new_pt;
437        new_pt->prev = prev_result;
438      }
439      if (allow_detailed_fx) {
440        new_pt->src_outline = edgept->src_outline;
441        new_pt->start_step = edgept->start_step;
442        new_pt->step_count = edgept->step_count;
443      }
444      prev_result = new_pt;
445      edgept = edgept->next;
446    } while (edgept != startpt);
447    prev_result->next = result;
448    result->prev = prev_result;
449    if (edgepts != stack_edgepts) {
450      delete[] edgepts;
451    }
452    return TESSLINE::BuildFromOutlineList(result);
453  }
454  } 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_btree.h"
2  #include <cmath>
3  #include <deque>
4  #include <iostream>
5  #include <string>
6  #include <vector>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/raw_logging.h"
11  #include "absl/cleanup/cleanup.h"
12  #include "absl/strings/internal/cord_data_edge.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_test_util.h"
15  #include "absl/strings/str_cat.h"
16  #include "absl/strings/string_view.h"
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace cord_internal {
20  class CordRepBtreeTestPeer {
21   public:
22    static void SetEdge(CordRepBtree* node, size_t idx, CordRep* edge) {
23      node->edges_[idx] = edge;
24    }
25    static void AddEdge(CordRepBtree* node, CordRep* edge) {
26      node->edges_[node->fetch_add_end(1)] = edge;
27    }
28  };
29  namespace {
30  using ::absl::cordrep_testing::AutoUnref;
31  using ::absl::cordrep_testing::CordCollectRepsIf;
32  using ::absl::cordrep_testing::CordToString;
33  using ::absl::cordrep_testing::CordVisitReps;
34  using ::absl::cordrep_testing::CreateFlatsFromString;
35  using ::absl::cordrep_testing::CreateRandomString;
36  using ::absl::cordrep_testing::MakeExternal;
37  using ::absl::cordrep_testing::MakeFlat;
38  using ::absl::cordrep_testing::MakeSubstring;
39  using ::testing::_;
40  using ::testing::AllOf;
41  using ::testing::AnyOf;
42  using ::testing::Conditional;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::Eq;
46  using ::testing::HasSubstr;
47  using ::testing::Le;
48  using ::testing::Ne;
49  using ::testing::Not;
50  using ::testing::SizeIs;
51  using ::testing::TypedEq;
52  MATCHER_P(EqFlatHolding, data, "Equals flat holding data") {
53    if (arg->tag < FLAT) {
54      *result_listener << "Expected FLAT, got tag " << static_cast<int>(arg->tag);
55      return false;
56    }
57    std::string actual = CordToString(arg);
58    if (actual != data) {
59      *result_listener << "Expected flat holding \"" << data
60                       << "\", got flat holding \"" << actual << "\"";
61      return false;
62    }
63    return true;
64  }
65  MATCHER_P(IsNode, height, absl::StrCat("Is a valid node of height ", height)) {
66    if (arg == nullptr) {
67      *result_listener << "Expected NODE, got nullptr";
68      return false;
69    }
70    if (arg->tag != BTREE) {
71      *result_listener << "Expected NODE, got " << static_cast<int>(arg->tag);
72      return false;
73    }
74    if (!CordRepBtree::IsValid(arg->btree())) {
75      CordRepBtree::Dump(arg->btree(), "Expected valid NODE, got:", false,
76                         *result_listener->stream());
77      return false;
78    }
79    if (arg->btree()->height() != height) {
80      *result_listener << "Expected NODE of height " << height << ", got "
81                       << arg->btree()->height();
82      return false;
83    }
84    return true;
85  }
86  MATCHER_P2(IsSubstring, start, length,
87             absl::StrCat("Is a substring(start = ", start, ", length = ", length,
88                          ")")) {
89    if (arg == nullptr) {
90      *result_listener << "Expected substring, got nullptr";
91      return false;
92    }
93    if (arg->tag != SUBSTRING) {
94      *result_listener << "Expected SUBSTRING, got "
95                       << static_cast<int>(arg->tag);
96      return false;
97    }
98    const CordRepSubstring* const substr = arg->substring();
99    if (substr->start != start || substr->length != length) {
100      *result_listener << "Expected substring(" << start << ", " << length
101                       << "), got substring(" << substr->start << ", "
102                       << substr->length << ")";
103      return false;
104    }
105    return true;
106  }
107  MATCHER_P2(EqExtractResult, tree, rep, "Equals ExtractResult") {
108    if (arg.tree != tree || arg.extracted != rep) {
109      *result_listener << "Expected {" << static_cast<const void*>(tree) << ", "
110                       << static_cast<const void*>(rep) << "}, got {" << arg.tree
111                       << ", " << arg.extracted << "}";
112      return false;
113    }
114    return true;
115  }
116  class DataConsumer {
117   public:
118    DataConsumer(absl::string_view data, bool forward)
119        : data_(data), forward_(forward) {}
120    absl::string_view Next(size_t n) {
121      assert(n <= data_.size() - consumed_);
122      consumed_ += n;
123      return data_.substr(forward_ ? consumed_ - n : data_.size() - consumed_, n);
124    }
125    absl::string_view Consumed() const {
126      return forward_ ? data_.substr(0, consumed_)
127                      : data_.substr(data_.size() - consumed_);
128    }
129   private:
130    absl::string_view data_;
131    size_t consumed_ = 0;
132    bool forward_;
133  };
134  CordRepBtree* BtreeAdd(CordRepBtree* node, bool append,
135                         absl::string_view data) {
136    return append ? CordRepBtree::Append(node, data)
137                  : CordRepBtree::Prepend(node, data);
138  }
139  void GetLeafEdges(const CordRepBtree* tree, std::vector<CordRep*>& edges) {
140    if (tree->height() == 0) {
141      for (CordRep* edge : tree->Edges()) {
142        edges.push_back(edge);
143      }
144    } else {
145      for (CordRep* edge : tree->Edges()) {
146        GetLeafEdges(edge->btree(), edges);
147      }
148    }
149  }
150  std::vector<CordRep*> GetLeafEdges(const CordRepBtree* tree) {
151    std::vector<CordRep*> edges;
152    GetLeafEdges(tree, edges);
153    return edges;
154  }
155  CordRepFlat* MakeHexFlat(size_t i) {
156    return MakeFlat(absl::StrCat("0x", absl::Hex(i, absl::kZeroPad4)));
157  }
158  CordRepBtree* MakeLeaf(size_t size = CordRepBtree::kMaxCapacity) {
159    assert(size <= CordRepBtree::kMaxCapacity);
160    CordRepBtree* leaf = CordRepBtree::Create(MakeHexFlat(0));
161    for (size_t i = 1; i < size; ++i) {
162      leaf = CordRepBtree::Append(leaf, MakeHexFlat(i));
163    }
164    return leaf;
165  }
166  CordRepBtree* MakeTree(size_t size, bool append = true) {
167    CordRepBtree* tree = CordRepBtree::Create(MakeHexFlat(0));
168    for (size_t i = 1; i < size; ++i) {
169      tree = append ? CordRepBtree::Append(tree, MakeHexFlat(i))
170                    : CordRepBtree::Prepend(tree, MakeHexFlat(i));
171    }
172    return tree;
173  }
174  CordRepBtree* CreateTree(absl::Span<CordRep* const> reps) {
175    auto it = reps.begin();
176    CordRepBtree* tree = CordRepBtree::Create(*it);
177    while (++it != reps.end()) tree = CordRepBtree::Append(tree, *it);
178    return tree;
179  }
180  CordRepBtree* CreateTree(absl::string_view data, size_t chunk_size) {
181    return CreateTree(CreateFlatsFromString(data, chunk_size));
182  }
183  CordRepBtree* CreateTreeReverse(absl::string_view data, size_t chunk_size) {
184    std::vector<CordRep*> flats = CreateFlatsFromString(data, chunk_size);
185    auto rit = flats.rbegin();
186    CordRepBtree* tree = CordRepBtree::Create(*rit);
187    while (++rit != flats.rend()) tree = CordRepBtree::Prepend(tree, *rit);
188    return tree;
189  }
190  class CordRepBtreeTest : public testing::TestWithParam<bool> {
191   public:
192    bool shared() const { return GetParam(); }
193    static std::string ToString(testing::TestParamInfo<bool> param) {
194      return param.param ? "Shared" : "Private";
195    }
196  };
197  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeTest, testing::Bool(),
198                           CordRepBtreeTest::ToString);
199  class CordRepBtreeHeightTest : public testing::TestWithParam<int> {
200   public:
201    int height() const { return GetParam(); }
202    static std::string ToString(testing::TestParamInfo<int> param) {
203      return absl::StrCat(param.param);
204    }
205  };
206  INSTANTIATE_TEST_SUITE_P(WithHeights, CordRepBtreeHeightTest,
207                           testing::Range(0, CordRepBtree::kMaxHeight),
208                           CordRepBtreeHeightTest::ToString);
209  using TwoBools = testing::tuple<bool, bool>;
210  class CordRepBtreeDualTest : public testing::TestWithParam<TwoBools> {
211   public:
212    bool first_shared() const { return std::get<0>(GetParam()); }
213    bool second_shared() const { return std::get<1>(GetParam()); }
214    static std::string ToString(testing::TestParamInfo<TwoBools> param) {
215      if (std::get<0>(param.param)) {
216        return std::get<1>(param.param) ? "BothShared" : "FirstShared";
217      }
218      return std::get<1>(param.param) ? "SecondShared" : "Private";
219    }
220  };
221  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeDualTest,
222                           testing::Combine(testing::Bool(), testing::Bool()),
223                           CordRepBtreeDualTest::ToString);
224  TEST(CordRepBtreeTest, SizeIsMultipleOf64) {
225    if (sizeof(size_t) == 8 && sizeof(void*) == 8) {
226      EXPECT_THAT(sizeof(CordRepBtree) % 64, Eq(0u))
227          << "Should be multiple of 64";
228    }
229  }
230  TEST(CordRepBtreeTest, NewDestroyEmptyTree) {
231    auto* tree = CordRepBtree::New();
232    EXPECT_THAT(tree->size(), Eq(0u));
233    EXPECT_THAT(tree->height(), Eq(0));
234    EXPECT_THAT(tree->Edges(), ElementsAre());
235    CordRepBtree::Destroy(tree);
236  }
237  TEST(CordRepBtreeTest, NewDestroyEmptyTreeAtHeight) {
238    auto* tree = CordRepBtree::New(3);
239    EXPECT_THAT(tree->size(), Eq(0u));
240    EXPECT_THAT(tree->height(), Eq(3));
241    EXPECT_THAT(tree->Edges(), ElementsAre());
242    CordRepBtree::Destroy(tree);
243  }
244  TEST(CordRepBtreeTest, Btree) {
245    CordRep* rep = CordRepBtree::New();
246    EXPECT_THAT(rep->btree(), Eq(rep));
247    EXPECT_THAT(static_cast<const CordRep*>(rep)->btree(), Eq(rep));
248    CordRep::Unref(rep);
249  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
250    rep = MakeFlat("Hello world");
251    EXPECT_DEATH(rep->btree(), ".*");
252    EXPECT_DEATH(static_cast<const CordRep*>(rep)->btree(), ".*");
253    CordRep::Unref(rep);
254  #endif
255  }
256  TEST(CordRepBtreeTest, EdgeData) {
257    CordRepFlat* flat = MakeFlat("Hello world");
258    CordRepExternal* external = MakeExternal("Hello external");
259    CordRep* substr1 = MakeSubstring(1, 6, CordRep::Ref(flat));
260    CordRep* substr2 = MakeSubstring(1, 6, CordRep::Ref(external));
261    CordRep* bad_substr = MakeSubstring(1, 2, CordRep::Ref(substr1));
262    EXPECT_TRUE(IsDataEdge(flat));
263    EXPECT_THAT(EdgeData(flat).data(), TypedEq<const void*>(flat->Data()));
264    EXPECT_THAT(EdgeData(flat), Eq("Hello world"));
265    EXPECT_TRUE(IsDataEdge(external));
266    EXPECT_THAT(EdgeData(external).data(), TypedEq<const void*>(external->base));
267    EXPECT_THAT(EdgeData(external), Eq("Hello external"));
268    EXPECT_TRUE(IsDataEdge(substr1));
269    EXPECT_THAT(EdgeData(substr1).data(), TypedEq<const void*>(flat->Data() + 1));
270    EXPECT_THAT(EdgeData(substr1), Eq("ello w"));
271    EXPECT_TRUE(IsDataEdge(substr2));
272    EXPECT_THAT(EdgeData(substr2).data(),
273                TypedEq<const void*>(external->base + 1));
274    EXPECT_THAT(EdgeData(substr2), Eq("ello e"));
275    EXPECT_FALSE(IsDataEdge(bad_substr));
276  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
277    EXPECT_DEATH(EdgeData(bad_substr), ".*");
278  #endif
279    CordRep::Unref(bad_substr);
280    CordRep::Unref(substr2);
281    CordRep::Unref(substr1);
282    CordRep::Unref(external);
283    CordRep::Unref(flat);
284  }
285  TEST(CordRepBtreeTest, CreateUnrefLeaf) {
286    auto* flat = MakeFlat("a");
287    auto* leaf = CordRepBtree::Create(flat);
288    EXPECT_THAT(leaf->size(), Eq(1u));
289    EXPECT_THAT(leaf->height(), Eq(0));
290    EXPECT_THAT(leaf->Edges(), ElementsAre(flat));
291    CordRepBtree::Unref(leaf);
292  }
293  TEST(CordRepBtreeTest, NewUnrefNode) {
294    auto* leaf = CordRepBtree::Create(MakeFlat("a"));
295    CordRepBtree* tree = CordRepBtree::New(leaf);
296    EXPECT_THAT(tree->size(), Eq(1u));
297    EXPECT_THAT(tree->height(), Eq(1));
298    EXPECT_THAT(tree->Edges(), ElementsAre(leaf));
299    CordRepBtree::Unref(tree);
300  }
301  TEST_P(CordRepBtreeTest, AppendToLeafToCapacity) {
302    AutoUnref refs;
303    std::vector<CordRep*> flats;
304    flats.push_back(MakeHexFlat(0));
305    auto* leaf = CordRepBtree::Create(flats.back());
306    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
307      refs.RefIf(shared(), leaf);
308      flats.push_back(MakeHexFlat(i));
309      auto* result = CordRepBtree::Append(leaf, flats.back());
310      EXPECT_THAT(result->height(), Eq(0));
311      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
312      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
313      leaf = result;
314    }
315    CordRep::Unref(leaf);
316  }
317  TEST_P(CordRepBtreeTest, PrependToLeafToCapacity) {
318    AutoUnref refs;
319    std::deque<CordRep*> flats;
320    flats.push_front(MakeHexFlat(0));
321    auto* leaf = CordRepBtree::Create(flats.front());
322    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
323      refs.RefIf(shared(), leaf);
324      flats.push_front(MakeHexFlat(i));
325      auto* result = CordRepBtree::Prepend(leaf, flats.front());
326      EXPECT_THAT(result->height(), Eq(0));
327      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
328      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
329      leaf = result;
330    }
331    CordRep::Unref(leaf);
332  }
333  TEST_P(CordRepBtreeTest, AppendPrependToLeafToCapacity) {
334    AutoUnref refs;
335    std::deque<CordRep*> flats;
336    flats.push_front(MakeHexFlat(0));
337    auto* leaf = CordRepBtree::Create(flats.front());
338    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
339      refs.RefIf(shared(), leaf);
340      CordRepBtree* result;
341      if (i % 2 != 0) {
342        flats.push_front(MakeHexFlat(i));
343        result = CordRepBtree::Prepend(leaf, flats.front());
344      } else {
345        flats.push_back(MakeHexFlat(i));
346        result = CordRepBtree::Append(leaf, flats.back());
347      }
348      EXPECT_THAT(result->height(), Eq(0));
349      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
350      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
351      leaf = result;
352    }
353    CordRep::Unref(leaf);
354  }
355  TEST_P(CordRepBtreeTest, AppendToLeafBeyondCapacity) {
356    AutoUnref refs;
357    auto* leaf = MakeLeaf();
358    refs.RefIf(shared(), leaf);
359    CordRep* flat = MakeFlat("abc");
360    auto* result = CordRepBtree::Append(leaf, flat);
361    ASSERT_THAT(result, IsNode(1));
362    EXPECT_THAT(result, Ne(leaf));
363    absl::Span<CordRep* const> edges = result->Edges();
364    ASSERT_THAT(edges, ElementsAre(leaf, IsNode(0)));
365    EXPECT_THAT(edges[1]->btree()->Edges(), ElementsAre(flat));
366    CordRep::Unref(result);
367  }
368  TEST_P(CordRepBtreeTest, PrependToLeafBeyondCapacity) {
369    AutoUnref refs;
370    auto* leaf = MakeLeaf();
371    refs.RefIf(shared(), leaf);
372    CordRep* flat = MakeFlat("abc");
373    auto* result = CordRepBtree::Prepend(leaf, flat);
374    ASSERT_THAT(result, IsNode(1));
375    EXPECT_THAT(result, Ne(leaf));
376    absl::Span<CordRep* const> edges = result->Edges();
377    ASSERT_THAT(edges, ElementsAre(IsNode(0), leaf));
378    EXPECT_THAT(edges[0]->btree()->Edges(), ElementsAre(flat));
379    CordRep::Unref(result);
380  }
381  TEST_P(CordRepBtreeTest, AppendToTreeOneDeep) {
382    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
383    AutoUnref refs;
384    std::vector<CordRep*> flats;
385    flats.push_back(MakeHexFlat(0));
386    CordRepBtree* tree = CordRepBtree::Create(flats.back());
387    for (size_t i = 1; i <= max_cap; ++i) {
388      flats.push_back(MakeHexFlat(i));
389      tree = CordRepBtree::Append(tree, flats.back());
390    }
391    ASSERT_THAT(tree, IsNode(1));
392    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
393      refs.RefIf(shared(), tree);
394      refs.RefIf(i % 4 == 0, tree->Edges().back());
395      flats.push_back(MakeHexFlat(i));
396      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
397      ASSERT_THAT(result, IsNode(1));
398      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
399      std::vector<CordRep*> edges = GetLeafEdges(result);
400      ASSERT_THAT(edges, ElementsAreArray(flats));
401      tree = result;
402    }
403    CordRep::Unref(tree);
404  }
405  TEST_P(CordRepBtreeTest, AppendToTreeTwoDeep) {
406    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
407    AutoUnref refs;
408    std::vector<CordRep*> flats;
409    flats.push_back(MakeHexFlat(0));
410    CordRepBtree* tree = CordRepBtree::Create(flats.back());
411    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
412      flats.push_back(MakeHexFlat(i));
413      tree = CordRepBtree::Append(tree, flats.back());
414    }
415    ASSERT_THAT(tree, IsNode(2));
416    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
417      refs.RefIf(shared(), tree);
418      refs.RefIf(i % 16 == 0, tree->Edges().back());
419      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
420      flats.push_back(MakeHexFlat(i));
421      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
422      ASSERT_THAT(result, IsNode(2));
423      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
424      std::vector<CordRep*> edges = GetLeafEdges(result);
425      ASSERT_THAT(edges, ElementsAreArray(flats));
426      tree = result;
427    }
428    CordRep::Unref(tree);
429  }
430  TEST_P(CordRepBtreeTest, PrependToTreeOneDeep) {
431    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
432    AutoUnref refs;
433    std::deque<CordRep*> flats;
434    flats.push_back(MakeHexFlat(0));
435    CordRepBtree* tree = CordRepBtree::Create(flats.back());
436    for (size_t i = 1; i <= max_cap; ++i) {
437      flats.push_front(MakeHexFlat(i));
438      tree = CordRepBtree::Prepend(tree, flats.front());
439    }
440    ASSERT_THAT(tree, IsNode(1));
441    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
442      refs.RefIf(shared(), tree);
443      refs.RefIf(i % 4 == 0, tree->Edges().back());
444      flats.push_front(MakeHexFlat(i));
445      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
446      ASSERT_THAT(result, IsNode(1));
447      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
448      std::vector<CordRep*> edges = GetLeafEdges(result);
449      ASSERT_THAT(edges, ElementsAreArray(flats));
450      tree = result;
451    }
452    CordRep::Unref(tree);
453  }
454  TEST_P(CordRepBtreeTest, PrependToTreeTwoDeep) {
455    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
456    AutoUnref refs;
457    std::deque<CordRep*> flats;
458    flats.push_back(MakeHexFlat(0));
459    CordRepBtree* tree = CordRepBtree::Create(flats.back());
460    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
461      flats.push_front(MakeHexFlat(i));
462      tree = CordRepBtree::Prepend(tree, flats.front());
463    }
464    ASSERT_THAT(tree, IsNode(2));
465    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
466      refs.RefIf(shared(), tree);
467      refs.RefIf(i % 16 == 0, tree->Edges().back());
468      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
469      flats.push_front(MakeHexFlat(i));
470      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
471      ASSERT_THAT(result, IsNode(2));
472      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
473      std::vector<CordRep*> edges = GetLeafEdges(result);
474      ASSERT_THAT(edges, ElementsAreArray(flats));
475      tree = result;
476    }
477    CordRep::Unref(tree);
478  }
479  TEST_P(CordRepBtreeDualTest, MergeLeafsNotExceedingCapacity) {
480    for (bool use_append : {false, true}) {
481      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
482      AutoUnref refs;
483      std::vector<CordRep*> flats;
484      CordRepBtree* left = MakeLeaf(3);
485      GetLeafEdges(left, flats);
486      refs.RefIf(first_shared(), left);
487      CordRepBtree* right = MakeLeaf(2);
488      GetLeafEdges(right, flats);
489      refs.RefIf(second_shared(), right);
490      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
491                                      : CordRepBtree::Prepend(right, left);
492      EXPECT_THAT(tree, IsNode(0));
493      EXPECT_THAT(tree->Edges(), ElementsAreArray(flats));
494      CordRepBtree::Unref(tree);
495    }
496  }
497  TEST_P(CordRepBtreeDualTest, MergeLeafsExceedingCapacity) {
498    for (bool use_append : {false, true}) {
499      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
500      AutoUnref refs;
501      CordRepBtree* left = MakeLeaf(CordRepBtree::kMaxCapacity - 2);
502      refs.RefIf(first_shared(), left);
503      CordRepBtree* right = MakeLeaf(CordRepBtree::kMaxCapacity - 1);
504      refs.RefIf(second_shared(), right);
505      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
506                                      : CordRepBtree::Prepend(right, left);
507      EXPECT_THAT(tree, IsNode(1));
508      EXPECT_THAT(tree->Edges(), ElementsAre(left, right));
509      CordRepBtree::Unref(tree);
510    }
511  }
512  TEST_P(CordRepBtreeDualTest, MergeEqualHeightTrees) {
513    for (bool use_append : {false, true}) {
514      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
515      AutoUnref refs;
516      std::vector<CordRep*> flats;
517      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3);
518      GetLeafEdges(left, flats);
519      refs.RefIf(first_shared(), left);
520      CordRepBtree* right = MakeTree(CordRepBtree::kMaxCapacity * 2);
521      GetLeafEdges(right, flats);
522      refs.RefIf(second_shared(), right);
523      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
524                                      : CordRepBtree::Prepend(right, left);
525      EXPECT_THAT(tree, IsNode(1));
526      EXPECT_THAT(tree->Edges(), SizeIs(5u));
527      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
528      CordRepBtree::Unref(tree);
529    }
530  }
531  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeNotExceedingLeafCapacity) {
532    for (bool use_append : {false, true}) {
533      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
534      AutoUnref refs;
535      std::vector<CordRep*> flats;
536      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 2 + 2);
537      GetLeafEdges(left, flats);
538      refs.RefIf(first_shared(), left);
539      CordRepBtree* right = MakeTree(3);
540      GetLeafEdges(right, flats);
541      refs.RefIf(second_shared(), right);
542      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
543                                      : CordRepBtree::Prepend(right, left);
544      EXPECT_THAT(tree, IsNode(1));
545      EXPECT_THAT(tree->Edges(), SizeIs(3u));
546      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
547      CordRepBtree::Unref(tree);
548    }
549  }
550  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeExceedingLeafCapacity) {
551    for (bool use_append : {false, true}) {
552      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
553      AutoUnref refs;
554      std::vector<CordRep*> flats;
555      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3 - 2);
556      GetLeafEdges(left, flats);
557      refs.RefIf(first_shared(), left);
558      CordRepBtree* right = MakeTree(3);
559      GetLeafEdges(right, flats);
560      refs.RefIf(second_shared(), right);
561      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
562                                      : CordRepBtree::Prepend(right, left);
563      EXPECT_THAT(tree, IsNode(1));
564      EXPECT_THAT(tree->Edges(), SizeIs(4u));
565      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
566      CordRepBtree::Unref(tree);
567    }
568  }
569  void RefEdgesAt(size_t depth, AutoUnref& refs, CordRepBtree* tree) {
570    absl::Span<CordRep* const> edges = tree->Edges();
571    if (depth == 0) {
572      refs.Ref(edges.front());
573      refs.Ref(edges.back());
574    } else {
575      assert(tree->height() > 0);
576      RefEdgesAt(depth - 1, refs, edges.front()->btree());
577      RefEdgesAt(depth - 1, refs, edges.back()->btree());
578    }
579  }
580  TEST(CordRepBtreeTest, MergeFuzzTest) {
581    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
582    std::minstd_rand rnd;
583    std::uniform_int_distribution<int> coin_flip(0, 1);
584    std::uniform_int_distribution<int> dice_throw(1, 6);
585    auto random_leaf_count = [&]() {
586      std::uniform_int_distribution<int> dist_height(0, 3);
587      std::uniform_int_distribution<int> dist_leaf(0, max_cap - 1);
588      const int height = dist_height(rnd);
589      return (height ? pow(max_cap, height) : 0) + dist_leaf(rnd);
590    };
591    for (int i = 0; i < 10000; ++i) {
592      AutoUnref refs;
593      std::vector<CordRep*> flats;
594      CordRepBtree* left = MakeTree(random_leaf_count(), coin_flip(rnd));
595      GetLeafEdges(left, flats);
596      if (dice_throw(rnd) == 1) {
597        std::uniform_int_distribution<size_t> dist(
598            0, static_cast<size_t>(left->height()));
599        RefEdgesAt(dist(rnd), refs, left);
600      }
601      CordRepBtree* right = MakeTree(random_leaf_count(), coin_flip(rnd));
602      GetLeafEdges(right, flats);
603      if (dice_throw(rnd) == 1) {
604        std::uniform_int_distribution<size_t> dist(
605            0, static_cast<size_t>(right->height()));
606        RefEdgesAt(dist(rnd), refs, right);
607      }
608      CordRepBtree* tree = CordRepBtree::Append(left, right);
609      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
610      CordRepBtree::Unref(tree);
611    }
612  }
613  TEST_P(CordRepBtreeTest, RemoveSuffix) {
614    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
615    for (size_t cap : {max_cap - 1, max_cap * 2, max_cap * max_cap * 2}) {
616      const std::string data = CreateRandomString(cap * 512);
617      {
618        AutoUnref refs;
619        CordRepBtree* node = refs.RefIf(shared(), CreateTree(data, 512));
620        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, data.length()), Eq(nullptr));
621        node = refs.RefIf(shared(), CreateTree(data, 512));
622        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, 0), Eq(node));
623        CordRep::Unref(node);
624      }
625      for (size_t n = 1; n < data.length(); ++n) {
626        AutoUnref refs;
627        auto flats = CreateFlatsFromString(data, 512);
628        CordRepBtree* node = refs.RefIf(shared(), CreateTree(flats));
629        CordRep* rep = refs.Add(CordRepBtree::RemoveSuffix(node, n));
630        EXPECT_THAT(CordToString(rep), Eq(data.substr(0, data.length() - n)));
631        auto is_flat = [](CordRep* rep) { return rep->tag >= FLAT; };
632        std::vector<CordRep*> edges = CordCollectRepsIf(is_flat, rep);
633        ASSERT_THAT(edges.size(), Le(flats.size()));
634        CordRep* last_edge = edges.back();
635        edges.pop_back();
636        const size_t last_length = rep->length - edges.size() * 512;
637        size_t index = 0;
638        for (CordRep* edge : edges) {
639          ASSERT_THAT(edge, Eq(flats[index++]));
640          ASSERT_THAT(edge->length, Eq(512u));
641        }
642        if (last_length >= 500) {
643          EXPECT_THAT(last_edge, Eq(flats[index++]));
644          if (shared()) {
645            EXPECT_THAT(last_edge->length, Eq(512u));
646          } else {
647            EXPECT_TRUE(last_edge->refcount.IsOne());
648            EXPECT_THAT(last_edge->length, Eq(last_length));
649          }
650        }
651      }
652    }
653  }
654  TEST(CordRepBtreeTest, SubTree) {
655    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
656    const size_t n = max_cap * max_cap * 2;
657    const std::string data = CreateRandomString(n * 3);
658    std::vector<CordRep*> flats;
659    for (absl::string_view s = data; !s.empty(); s.remove_prefix(3)) {
660      flats.push_back(MakeFlat(s.substr(0, 3)));
661    }
662    CordRepBtree* node = CordRepBtree::Create(CordRep::Ref(flats[0]));
663    for (size_t i = 1; i < flats.size(); ++i) {
664      node = CordRepBtree::Append(node, CordRep::Ref(flats[i]));
665    }
666    for (size_t offset = 0; offset < data.length(); ++offset) {
667      for (size_t length = 1; length <= data.length() - offset; ++length) {
668        CordRep* rep = node->SubTree(offset, length);
669        EXPECT_THAT(CordToString(rep), Eq(data.substr(offset, length)));
670        CordRep::Unref(rep);
671      }
672    }
673    CordRepBtree::Unref(node);
674    for (CordRep* rep : flats) {
675      CordRep::Unref(rep);
676    }
677  }
678  TEST(CordRepBtreeTest, SubTreeOnExistingSubstring) {
679    AutoUnref refs;
680    std::string data = CreateRandomString(1000);
681    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
682    CordRep* flat = MakeFlat(data);
683    leaf = CordRepBtree::Append(leaf, flat);
684    CordRep* result = leaf->SubTree(0, 3 + 990);
685    ASSERT_THAT(result->tag, Eq(BTREE));
686    CordRep::Unref(leaf);
687    leaf = result->btree();
688    ASSERT_THAT(leaf->Edges(), ElementsAre(_, IsSubstring(0u, 990u)));
689    EXPECT_THAT(leaf->Edges()[1]->substring()->child, Eq(flat));
690    result = leaf->SubTree(3 + 5, 970);
691    ASSERT_THAT(result, IsSubstring(5u, 970u));
692    EXPECT_THAT(result->substring()->child, Eq(flat));
693    CordRep::Unref(result);
694    CordRep::Unref(leaf);
695  }
696  TEST_P(CordRepBtreeTest, AddDataToLeaf) {
697    const size_t n = CordRepBtree::kMaxCapacity;
698    const std::string data = CreateRandomString(n * 3);
699    for (bool append : {true, false}) {
700      AutoUnref refs;
701      DataConsumer consumer(data, append);
702      SCOPED_TRACE(append ? "Append" : "Prepend");
703      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
704      for (size_t i = 1; i < n; ++i) {
705        refs.RefIf(shared(), leaf);
706        CordRepBtree* result = BtreeAdd(leaf, append, consumer.Next(3));
707        EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
708        EXPECT_THAT(CordToString(result), Eq(consumer.Consumed()));
709        leaf = result;
710      }
711      CordRep::Unref(leaf);
712    }
713  }
714  TEST_P(CordRepBtreeTest, AppendDataToTree) {
715    AutoUnref refs;
716    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
717    std::string data = CreateRandomString(n * 3);
718    CordRepBtree* tree = refs.RefIf(shared(), CreateTree(data, 3));
719    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
720    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
721    CordRepBtree* result = CordRepBtree::Append(tree, "123456789");
722    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
723    EXPECT_THAT(result->Edges(),
724                ElementsAre(leaf0, Conditional(shared(), Ne(leaf1), Eq(leaf1))));
725    EXPECT_THAT(CordToString(result), Eq(data + "123456789"));
726    CordRep::Unref(result);
727  }
728  TEST_P(CordRepBtreeTest, PrependDataToTree) {
729    AutoUnref refs;
730    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
731    std::string data = CreateRandomString(n * 3);
732    CordRepBtree* tree = refs.RefIf(shared(), CreateTreeReverse(data, 3));
733    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
734    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
735    CordRepBtree* result = CordRepBtree::Prepend(tree, "123456789");
736    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
737    EXPECT_THAT(result->Edges(),
738                ElementsAre(Conditional(shared(), Ne(leaf0), Eq(leaf0)), leaf1));
739    EXPECT_THAT(CordToString(result), Eq("123456789" + data));
740    CordRep::Unref(result);
741  }
742  TEST_P(CordRepBtreeTest, AddDataToTreeThreeLevelsDeep) {
743    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
744    const size_t n = max_cap * max_cap * max_cap;
745    const std::string data = CreateRandomString(n * 3);
746    for (bool append : {true, false}) {
747      AutoUnref refs;
748      DataConsumer consumer(data, append);
749      SCOPED_TRACE(append ? "Append" : "Prepend");
750      CordRepBtree* tree = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
751      for (size_t i = 1; i < max_cap; ++i) {
752        tree = BtreeAdd(tree, append, consumer.Next(3));
753      }
754      ASSERT_THAT(CordToString(tree), Eq(consumer.Consumed()));
755      refs.RefIf(shared(), tree);
756      CordRepBtree* result = BtreeAdd(tree, append, consumer.Next(3));
757      ASSERT_THAT(result, IsNode(1));
758      ASSERT_THAT(result, Ne(tree));
759      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
760      tree = result;
761      for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
762        refs.RefIf(shared(), tree);
763        result = BtreeAdd(tree, append, consumer.Next(3));
764        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
765        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
766        tree = result;
767      }
768      refs.RefIf(shared(), tree);
769      result = BtreeAdd(tree, append, consumer.Next(3));
770      ASSERT_THAT(result, IsNode(2));
771      ASSERT_THAT(result, Ne(tree));
772      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
773      tree = result;
774      for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap;
775           ++i) {
776        refs.RefIf(shared(), tree);
777        result = BtreeAdd(tree, append, consumer.Next(3));
778        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
779        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
780        tree = result;
781      }
782      CordRep::Unref(tree);
783    }
784  }
785  TEST_P(CordRepBtreeTest, AddLargeDataToLeaf) {
786    const size_t max_cap = CordRepBtree::kMaxCapacity;
787    const size_t n = max_cap * max_cap * max_cap * 3 + 2;
788    const std::string data = CreateRandomString(n * kMaxFlatLength);
789    for (bool append : {true, false}) {
790      AutoUnref refs;
791      SCOPED_TRACE(append ? "Append" : "Prepend");
792      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
793      refs.RefIf(shared(), leaf);
794      CordRepBtree* result = BtreeAdd(leaf, append, data);
795      EXPECT_THAT(CordToString(result), Eq(append ? "abc" + data : data + "abc"));
796      CordRep::Unref(result);
797    }
798  }
799  TEST_P(CordRepBtreeTest, CreateFromTreeReturnsTree) {
800    AutoUnref refs;
801    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
802    refs.RefIf(shared(), leaf);
803    CordRepBtree* result = CordRepBtree::Create(leaf);
804    EXPECT_THAT(result, Eq(leaf));
805    CordRep::Unref(result);
806  }
807  TEST(CordRepBtreeTest, GetCharacter) {
808    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
809    std::string data = CreateRandomString(n * 3);
810    CordRepBtree* tree = CreateTree(data, 3);
811    tree = tree->Append(tree, MakeSubstring(4, 5, MakeFlat("abcdefghijklm")));
812    data += "efghi";
813    for (size_t i = 0; i < data.length(); ++i) {
814      ASSERT_THAT(tree->GetCharacter(i), Eq(data[i]));
815    }
816    CordRep::Unref(tree);
817  }
818  TEST_P(CordRepBtreeTest, IsFlatSingleFlat) {
819    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
820    absl::string_view fragment;
821    EXPECT_TRUE(leaf->IsFlat(nullptr));
822    EXPECT_TRUE(leaf->IsFlat(&fragment));
823    EXPECT_THAT(fragment, Eq("Hello world"));
824    fragment = "";
825    EXPECT_TRUE(leaf->IsFlat(0, 11, nullptr));
826    EXPECT_TRUE(leaf->IsFlat(0, 11, &fragment));
827    EXPECT_THAT(fragment, Eq("Hello world"));
828    EXPECT_TRUE(leaf->IsFlat(1, 4, &fragment));
829    EXPECT_THAT(fragment, Eq("ello"));
830    EXPECT_TRUE(leaf->IsFlat(6, 5, &fragment));
831    EXPECT_THAT(fragment, Eq("world"));
832    CordRep::Unref(leaf);
833  }
834  TEST(CordRepBtreeTest, IsFlatMultiFlat) {
835    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
836    std::string data = CreateRandomString(n * 3);
837    CordRepBtree* tree = CreateTree(data, 3);
838    tree = tree->Append(tree, MakeSubstring(4, 3, MakeFlat("abcdefghijklm")));
839    tree = tree->Append(tree, MakeSubstring(8, 3, MakeFlat("abcdefghijklm")));
840    data += "efgijk";
841    EXPECT_FALSE(tree->IsFlat(nullptr));
842    absl::string_view fragment = "Can't touch this";
843    EXPECT_FALSE(tree->IsFlat(&fragment));
844    EXPECT_THAT(fragment, Eq("Can't touch this"));
845    for (size_t offset = 0; offset < data.size(); offset += 3) {
846      EXPECT_TRUE(tree->IsFlat(offset, 3, nullptr));
847      EXPECT_TRUE(tree->IsFlat(offset, 3, &fragment));
848      EXPECT_THAT(fragment, Eq(data.substr(offset, 3)));
849      fragment = "Can't touch this";
850      if (offset > 0) {
851        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, nullptr));
852        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, &fragment));
853        EXPECT_THAT(fragment, Eq("Can't touch this"));
854      }
855      if (offset < data.size() - 4) {
856        EXPECT_FALSE(tree->IsFlat(offset, 4, nullptr));
857        EXPECT_FALSE(tree->IsFlat(offset, 4, &fragment));
858        EXPECT_THAT(fragment, Eq("Can't touch this"));
859      }
860    }
861    CordRep::Unref(tree);
862  }
863  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
864  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotPrivate) {
865    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
866    CordRepBtree::Ref(tree);
867    EXPECT_DEATH(tree->GetAppendBuffer(1), ".*");
868    CordRepBtree::Unref(tree);
869    CordRepBtree::Unref(tree);
870  }
871  #endif  
872  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotFlat) {
873    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
874    for (int i = 1; i <= height(); ++i) {
875      tree = CordRepBtree::New(tree);
876    }
877    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
878    CordRepBtree::Unref(tree);
879  }
880  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNotPrivate) {
881    CordRepFlat* flat = MakeFlat("abc");
882    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
883    for (int i = 1; i <= height(); ++i) {
884      tree = CordRepBtree::New(tree);
885    }
886    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
887    CordRepBtree::Unref(tree);
888    CordRep::Unref(flat);
889  }
890  TEST_P(CordRepBtreeHeightTest, GetAppendBufferTreeNotPrivate) {
891    if (height() == 0) return;
892    AutoUnref refs;
893    CordRepFlat* flat = MakeFlat("abc");
894    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
895    for (int i = 1; i <= height(); ++i) {
896      if (i == (height() + 1) / 2) refs.Ref(tree);
897      tree = CordRepBtree::New(tree);
898    }
899    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
900    CordRepBtree::Unref(tree);
901    CordRep::Unref(flat);
902  }
903  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNoCapacity) {
904    CordRepFlat* flat = MakeFlat("abc");
905    flat->length = flat->Capacity();
906    CordRepBtree* tree = CordRepBtree::Create(flat);
907    for (int i = 1; i <= height(); ++i) {
908      tree = CordRepBtree::New(tree);
909    }
910    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
911    CordRepBtree::Unref(tree);
912  }
913  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatWithCapacity) {
914    CordRepFlat* flat = MakeFlat("abc");
915    CordRepBtree* tree = CordRepBtree::Create(flat);
916    for (int i = 1; i <= height(); ++i) {
917      tree = CordRepBtree::New(tree);
918    }
919    absl::Span<char> span = tree->GetAppendBuffer(2);
920    EXPECT_THAT(span, SizeIs(2u));
921    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 3));
922    EXPECT_THAT(tree->length, Eq(5u));
923    size_t avail = flat->Capacity() - 5;
924    span = tree->GetAppendBuffer(avail + 100);
925    EXPECT_THAT(span, SizeIs(avail));
926    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 5));
927    EXPECT_THAT(tree->length, Eq(5 + avail));
928    CordRepBtree::Unref(tree);
929  }
<span onclick='openModal()' class='match'>930  TEST(CordRepBtreeTest, Dump) {
931    std::stringstream ss;
932    CordRepBtree::Dump(nullptr, ss);
933    CordRepBtree::Dump(nullptr, "Once upon a label", ss);
934    CordRepBtree::Dump(nullptr, "Once upon a label", false, ss);
935    CordRepBtree::Dump(nullptr, "Once upon a label", true, ss);
936    CordRepFlat* flat = MakeFlat("Hello world");
937    CordRepExternal* external = MakeExternal("Hello external");
938    CordRep* substr_flat = MakeSubstring(1, 6, CordRep::Ref(flat));
939    CordRep* substr_external = MakeSubstring(2, 7, CordRep::Ref(external));
940    CordRepBtree* tree = CordRepBtree::Create(flat);
941    tree = CordRepBtree::Append(tree, external);
942    tree = CordRepBtree::Append(tree, substr_flat);
943    tree = CordRepBtree::Append(tree, substr_external);
</span>944    while (tree->height() == 0) {
945      tree = CordRepBtree::Append(tree, CordRep::Ref(flat));
946      tree = CordRepBtree::Append(tree, CordRep::Ref(external));
947      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_flat));
948      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_external));
949    }
950    for (int api = 0; api <= 3; ++api) {
951      absl::string_view api_scope;
952      std::stringstream ss;
953      switch (api) {
954        case 0:
955          api_scope = "Bare";
956          CordRepBtree::Dump(tree, ss);
957          break;
958        case 1:
959          api_scope = "Label only";
960          CordRepBtree::Dump(tree, "Once upon a label", ss);
961          break;
962        case 2:
963          api_scope = "Label no content";
964          CordRepBtree::Dump(tree, "Once upon a label", false, ss);
965          break;
966        default:
967          api_scope = "Label and content";
968          CordRepBtree::Dump(tree, "Once upon a label", true, ss);
969          break;
970      }
971      SCOPED_TRACE(api_scope);
972      std::string str = ss.str();
973      EXPECT_THAT(str, AllOf(HasSubstr("Node(1)"), HasSubstr("Leaf"),
974                             HasSubstr("Private"), HasSubstr("Shared")));
975      EXPECT_THAT(str, AllOf(HasSubstr("len = 11"), HasSubstr("len = 14"),
976                             HasSubstr("len = 6"), HasSubstr("len = 7"),
977                             HasSubstr("start = 1"), HasSubstr("start = 2")));
978      EXPECT_THAT(
979          str, AllOf(HasSubstr(absl::StrCat("0x", absl::Hex(flat))),
980                     HasSubstr(absl::StrCat("0x", absl::Hex(external))),
981                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_flat))),
982                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_external)))));
983      if (api != 0) {
984        EXPECT_THAT(str, HasSubstr("Once upon a label"));
985      }
986      if (api != 3) {
987        EXPECT_THAT(str, Not(AnyOf((HasSubstr("data = \"Hello world\""),
988                                    HasSubstr("data = \"Hello external\""),
989                                    HasSubstr("data = \"ello w\""),
990                                    HasSubstr("data = \"llo ext\"")))));
991      } else {
992        EXPECT_THAT(str, AllOf((HasSubstr("data = \"Hello world\""),
993                                HasSubstr("data = \"Hello external\""),
994                                HasSubstr("data = \"ello w\""),
995                                HasSubstr("data = \"llo ext\""))));
996      }
997    }
998    CordRep::Unref(tree);
999  }
1000  TEST(CordRepBtreeTest, IsValid) {
1001    EXPECT_FALSE(CordRepBtree::IsValid(nullptr));
1002    CordRepBtree* empty = CordRepBtree::New(0);
1003    EXPECT_TRUE(CordRepBtree::IsValid(empty));
1004    CordRep::Unref(empty);
1005    for (bool as_tree : {false, true}) {
1006      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
1007      CordRepBtree* tree = as_tree ? CordRepBtree::New(leaf) : nullptr;
1008      CordRepBtree* check = as_tree ? tree : leaf;
1009      ASSERT_TRUE(CordRepBtree::IsValid(check));
1010      leaf->length--;
1011      EXPECT_FALSE(CordRepBtree::IsValid(check));
1012      leaf->length++;
1013      ASSERT_TRUE(CordRepBtree::IsValid(check));
1014      leaf->tag--;
1015      EXPECT_FALSE(CordRepBtree::IsValid(check));
1016      leaf->tag++;
1017      ASSERT_TRUE(CordRepBtree::IsValid(check));
1018      leaf->storage[0] = static_cast<uint8_t>(CordRepBtree::kMaxHeight + 1);
1019      EXPECT_FALSE(CordRepBtree::IsValid(check));
1020      leaf->storage[0] = 1;
1021      EXPECT_FALSE(CordRepBtree::IsValid(check));
1022      leaf->storage[0] = 0;
1023      ASSERT_TRUE(CordRepBtree::IsValid(check));
1024      const uint8_t begin = leaf->storage[1];
1025      leaf->storage[1] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity);
1026      EXPECT_FALSE(CordRepBtree::IsValid(check));
1027      leaf->storage[1] = 2;
1028      EXPECT_FALSE(CordRepBtree::IsValid(check));
1029      leaf->storage[1] = begin;
1030      ASSERT_TRUE(CordRepBtree::IsValid(check));
1031      const uint8_t end = leaf->storage[2];
1032      leaf->storage[2] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity + 1);
1033      EXPECT_FALSE(CordRepBtree::IsValid(check));
1034      leaf->storage[2] = end;
1035      ASSERT_TRUE(CordRepBtree::IsValid(check));
1036      CordRep* const edge = leaf->Edges()[0];
1037      const uint8_t tag = edge->tag;
1038      CordRepBtreeTestPeer::SetEdge(leaf, begin, nullptr);
1039      EXPECT_FALSE(CordRepBtree::IsValid(check));
1040      CordRepBtreeTestPeer::SetEdge(leaf, begin, edge);
1041      edge->tag = BTREE;
1042      EXPECT_FALSE(CordRepBtree::IsValid(check));
1043      edge->tag = tag;
1044      if (as_tree) {
1045        ASSERT_TRUE(CordRepBtree::IsValid(check));
1046        leaf->length--;
1047        EXPECT_FALSE(CordRepBtree::IsValid(check));
1048        leaf->length++;
1049        ASSERT_TRUE(CordRepBtree::IsValid(check));
1050        tree->storage[0] = static_cast<uint8_t>(2);
1051        EXPECT_FALSE(CordRepBtree::IsValid(check));
1052        tree->storage[0] = 1;
1053        ASSERT_TRUE(CordRepBtree::IsValid(check));
1054        CordRep* const edge = tree->Edges()[0];
1055        const uint8_t tag = edge->tag;
1056        edge->tag = FLAT;
1057        EXPECT_FALSE(CordRepBtree::IsValid(check));
1058        edge->tag = tag;
1059      }
1060      ASSERT_TRUE(CordRepBtree::IsValid(check));
1061      CordRep::Unref(check);
1062    }
1063  }
1064  TEST(CordRepBtreeTest, AssertValid) {
1065    CordRepBtree* tree = CordRepBtree::Create(MakeFlat("abc"));
1066    const CordRepBtree* ctree = tree;
1067    EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree));
1068    EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree));
1069  #if defined(GTEST_HAS_DEATH_TEST)
1070    CordRepBtree* nulltree = nullptr;
1071    const CordRepBtree* cnulltree = nullptr;
1072    EXPECT_DEBUG_DEATH(
1073        EXPECT_THAT(CordRepBtree::AssertValid(nulltree), Eq(nulltree)), ".*");
1074    EXPECT_DEBUG_DEATH(
1075        EXPECT_THAT(CordRepBtree::AssertValid(cnulltree), Eq(cnulltree)), ".*");
1076    tree->length--;
1077    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree)),
1078                       ".*");
1079    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree)),
1080                       ".*");
1081    tree->length++;
1082  #endif
1083    CordRep::Unref(tree);
1084  }
1085  TEST(CordRepBtreeTest, CheckAssertValidShallowVsDeep) {
1086    const bool exhaustive_validation = IsCordBtreeExhaustiveValidationEnabled();
1087    auto cleanup = absl::MakeCleanup([exhaustive_validation] {
1088      SetCordBtreeExhaustiveValidation(exhaustive_validation);
1089    });
1090    CordRep* flat = MakeFlat("abc");
1091    CordRepBtree* tree = CordRepBtree::Create(flat);
1092    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
1093    const size_t n = max_cap * max_cap * 2;
1094    for (size_t i = 0; i < n; ++i) {
1095      tree = CordRepBtree::Append(tree, MakeFlat("Hello world"));
1096    }
1097    flat->length = 100;
1098    SetCordBtreeExhaustiveValidation(false);
1099    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1100    EXPECT_TRUE(CordRepBtree::IsValid(tree, true));
1101    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1102    CordRepBtree::AssertValid(tree);
1103    CordRepBtree::AssertValid(tree, true);
1104  #if defined(GTEST_HAS_DEATH_TEST)
1105    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, false), ".*");
1106  #endif
1107    SetCordBtreeExhaustiveValidation(true);
1108    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1109    EXPECT_FALSE(CordRepBtree::IsValid(tree, true));
1110    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1111  #if defined(GTEST_HAS_DEATH_TEST)
1112    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree), ".*");
1113    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, true), ".*");
1114  #endif
1115    flat->length = 3;
1116    CordRep::Unref(tree);
1117  }
1118  TEST_P(CordRepBtreeTest, Rebuild) {
1119    for (size_t size : {3u, 8u, 100u, 10000u, 1000000u}) {
1120      SCOPED_TRACE(absl::StrCat("Rebuild @", size));
1121      std::vector<CordRepFlat*> flats;
1122      for (size_t i = 0; i < size; ++i) {
1123        flats.push_back(CordRepFlat::New(2));
1124        flats.back()->Data()[0] = 'x';
1125        flats.back()->length = 1;
1126      }
1127      size_t split_count = 0;
1128      size_t split_limit = 3;
1129      auto it = flats.begin();
1130      CordRepBtree* left = nullptr;
1131      CordRepBtree* right = CordRepBtree::New(*it);
1132      while (++it != flats.end()) {
1133        if (++split_count >= split_limit) {
1134          split_limit += split_limit / 16;
1135          left = left ? CordRepBtree::Append(left, right) : right;
1136          right = CordRepBtree::New(*it);
1137        } else {
1138          right = CordRepBtree::Append(right, *it);
1139        }
1140      }
1141      left = left ? CordRepBtree::Append(left, right) : right;
1142      AutoUnref ref;
1143      left = ref.Add(CordRepBtree::Rebuild(ref.RefIf(shared(), left)));
1144      ASSERT_TRUE(CordRepBtree::IsValid(left));
1145      bool ok = true;
1146      it = flats.begin();
1147      CordVisitReps(left, [&](CordRep* edge) {
1148        if (edge->tag < FLAT) return;
1149        ok = ok && (it != flats.end() && *it++ == edge);
1150      });
1151      EXPECT_TRUE(ok && it == flats.end()) << "Rebuild edges mismatch";
1152    }
1153  }
1154  CordRepBtree::ExtractResult ExtractLast(CordRepBtree* input, size_t cap = 1) {
1155    return CordRepBtree::ExtractAppendBuffer(input, cap);
1156  }
1157  TEST(CordRepBtreeTest, ExtractAppendBufferLeafSingleFlat) {
1158    CordRep* flat = MakeFlat("Abc");
1159    CordRepBtree* leaf = CordRepBtree::Create(flat);
1160    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(nullptr, flat));
1161    CordRep::Unref(flat);
1162  }
1163  TEST(CordRepBtreeTest, ExtractAppendBufferNodeSingleFlat) {
1164    CordRep* flat = MakeFlat("Abc");
1165    CordRepBtree* leaf = CordRepBtree::Create(flat);
1166    CordRepBtree* node = CordRepBtree::New(leaf);
1167    EXPECT_THAT(ExtractLast(node), EqExtractResult(nullptr, flat));
1168    CordRep::Unref(flat);
1169  }
1170  TEST(CordRepBtreeTest, ExtractAppendBufferLeafTwoFlats) {
1171    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1172    CordRepBtree* leaf = CreateTree(flats);
1173    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(flats[0], flats[1]));
1174    CordRep::Unref(flats[0]);
1175    CordRep::Unref(flats[1]);
1176  }
1177  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlats) {
1178    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1179    CordRepBtree* leaf = CreateTree(flats);
1180    CordRepBtree* node = CordRepBtree::New(leaf);
1181    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1182    CordRep::Unref(flats[0]);
1183    CordRep::Unref(flats[1]);
1184  }
1185  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlatsInTwoLeafs) {
1186    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1187    CordRepBtree* leaf1 = CordRepBtree::Create(flats[0]);
1188    CordRepBtree* leaf2 = CordRepBtree::Create(flats[1]);
1189    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1190    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1191    CordRep::Unref(flats[0]);
1192    CordRep::Unref(flats[1]);
1193  }
1194  TEST(CordRepBtreeTest, ExtractAppendBufferLeafThreeFlats) {
1195    std::vector<CordRep*> flats = CreateFlatsFromString("abcdefghi", 3);
1196    CordRepBtree* leaf = CreateTree(flats);
1197    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, flats[2]));
1198    CordRep::Unref(flats[2]);
1199    CordRep::Unref(leaf);
1200  }
1201  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightNoFolding) {
1202    CordRep* flat = MakeFlat("Abc");
1203    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1204    CordRepBtree* leaf1 = CordRepBtree::Create(flat);
1205    CordRepBtree* leaf2 = CreateTree(flats);
1206    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1207    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, flats[1]));
1208    EXPECT_THAT(node->Edges(), ElementsAre(leaf1, leaf2));
1209    EXPECT_THAT(leaf1->Edges(), ElementsAre(flat));
1210    EXPECT_THAT(leaf2->Edges(), ElementsAre(flats[0]));
1211    CordRep::Unref(node);
1212    CordRep::Unref(flats[1]);
1213  }
1214  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightLeafFolding) {
1215    CordRep* flat = MakeFlat("Abc");
1216    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1217    CordRepBtree* leaf1 = CreateTree(flats);
1218    CordRepBtree* leaf2 = CordRepBtree::Create(flat);
1219    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1220    EXPECT_THAT(ExtractLast(node), EqExtractResult(leaf1, flat));
1221    EXPECT_THAT(leaf1->Edges(), ElementsAreArray(flats));
1222    CordRep::Unref(leaf1);
1223    CordRep::Unref(flat);
1224  }
1225  TEST(CordRepBtreeTest, ExtractAppendBufferNoCapacity) {
1226    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1227    CordRepBtree* leaf = CreateTree(flats);
1228    size_t avail = flats[1]->flat()->Capacity() - flats[1]->length;
1229    EXPECT_THAT(ExtractLast(leaf, avail + 1), EqExtractResult(leaf, nullptr));
1230    EXPECT_THAT(ExtractLast(leaf, avail), EqExtractResult(flats[0], flats[1]));
1231    CordRep::Unref(flats[0]);
1232    CordRep::Unref(flats[1]);
1233  }
1234  TEST(CordRepBtreeTest, ExtractAppendBufferNotFlat) {
1235    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1236    auto substr = MakeSubstring(1, 2, flats[1]);
1237    CordRepBtree* leaf = CreateTree({flats[0], substr});
1238    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1239    CordRep::Unref(leaf);
1240  }
1241  TEST(CordRepBtreeTest, ExtractAppendBufferShared) {
1242    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1243    CordRepBtree* leaf = CreateTree(flats);
1244    CordRep::Ref(flats[1]);
1245    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1246    CordRep::Unref(flats[1]);
1247    CordRep::Ref(leaf);
1248    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1249    CordRep::Unref(leaf);
1250    CordRepBtree* node = CordRepBtree::New(leaf);
1251    CordRep::Ref(node);
1252    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, nullptr));
1253    CordRep::Unref(node);
1254    CordRep::Unref(node);
1255  }
1256  }  
1257  }  
1258  ABSL_NAMESPACE_END
1259  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-polyaprx.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>134      if (prevdir.get_dir() != dir.get_dir()) {
135        edgepts[epindex].pos.x = pos.x();
136        edgepts[epindex].pos.y = pos.y();
137        prev_vec *= count;
138        edgepts[epindex].vec.x = prev_vec.x();
139        edgepts[epindex].vec.y = prev_vec.y();
140        pos += prev_vec;
141        edgepts[epindex].runlength = count;
142        edgepts[epindex].prev = &edgepts[epindex - 1];
</pre></code></div>
                <div class="column column_space"><pre><code>930  TEST(CordRepBtreeTest, Dump) {
931    std::stringstream ss;
932    CordRepBtree::Dump(nullptr, ss);
933    CordRepBtree::Dump(nullptr, "Once upon a label", ss);
934    CordRepBtree::Dump(nullptr, "Once upon a label", false, ss);
935    CordRepBtree::Dump(nullptr, "Once upon a label", true, ss);
936    CordRepFlat* flat = MakeFlat("Hello world");
937    CordRepExternal* external = MakeExternal("Hello external");
938    CordRep* substr_flat = MakeSubstring(1, 6, CordRep::Ref(flat));
939    CordRep* substr_external = MakeSubstring(2, 7, CordRep::Ref(external));
940    CordRepBtree* tree = CordRepBtree::Create(flat);
941    tree = CordRepBtree::Append(tree, external);
942    tree = CordRepBtree::Append(tree, substr_flat);
943    tree = CordRepBtree::Append(tree, substr_external);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    