<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for fib-manager.t.cpp & rib-manager.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for fib-manager.t.cpp & rib-manager.cpp
      </h3>
      <h1 align="center">
        7.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>fib-manager.t.cpp (9.354838%)<TH>rib-manager.cpp (5.7768927%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match587-0.html#0',2,'match587-1.html#0',3)" NAME="0">(129-145)<TD><A HREF="javascript:ZweiFrames('match587-0.html#0',2,'match587-1.html#0',3)" NAME="0">(322-338)</A><TD ALIGN=center><FONT COLOR="#ff0000">29</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>fib-manager.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2019,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;mgmt/fib-manager.hpp&quot;
#include &quot;table/fib-nexthop.hpp&quot;

#include &quot;manager-common-fixture.hpp&quot;
#include &quot;tests/daemon/face/dummy-face.hpp&quot;

#include &lt;ndn-cxx/lp/tags.hpp&gt;
#include &lt;ndn-cxx/mgmt/nfd/fib-entry.hpp&gt;

namespace nfd {
namespace tests {

class FibManagerFixture : public ManagerFixtureWithAuthenticator
{
public:
  FibManagerFixture()
    : m_fib(m_forwarder.getFib())
    , m_manager(m_fib, m_faceTable, m_dispatcher, *m_authenticator)
  {
    setTopPrefix();
    setPrivilege(&quot;fib&quot;);
  }

public: // for test
  static ControlParameters
  makeParameters(const Name&amp; name, const FaceId&amp; id)
  {
    return ControlParameters().setName(name).setFaceId(id);
  }

  static ControlParameters
  makeParameters(const Name&amp; name, const FaceId&amp; id, const uint32_t&amp; cost)
  {
    return ControlParameters().setName(name).setFaceId(id).setCost(cost);
  }

  FaceId
  addFace()
  {
    auto face = make_shared&lt;DummyFace&gt;();
    m_faceTable.add(face);
    advanceClocks(1_ms, 10);
    m_responses.clear(); // clear all event notifications, if any
    return face-&gt;getId();
  }

public: // for check
  enum class CheckNextHopResult
  {
    OK,
    NO_FIB_ENTRY,
    WRONG_N_NEXTHOPS,
    NO_NEXTHOP,
    WRONG_COST
  };

  /**
   * @brief check whether the nexthop record is added / removed properly
   *
   * @param expectedNNextHops use nullopt to skip this check
   * @param faceId use nullopt to skip NextHopRecord checks
   * @param expectedCost use nullopt to skip this check
   *
   * @retval OK FIB entry is found by exact match and has the expected number of nexthops;
   *            NextHopRe record for faceId is found and has the expected cost
   * @retval NO_FIB_ENTRY FIB entry is not found
   * @retval WRONG_N_NEXTHOPS FIB entry is found but has wrong number of nexthops
   * @retval NO_NEXTHOP NextHopRecord for faceId is not found
   * @retval WRONG_COST NextHopRecord for faceId has wrong cost
   */
  CheckNextHopResult
  checkNextHop(const Name&amp; prefix,
               optional&lt;size_t&gt; expectedNNextHops = nullopt,
               optional&lt;FaceId&gt; faceId = nullopt,
               optional&lt;uint64_t&gt; expectedCost = nullopt) const
  {
    const fib::Entry* entry = m_fib.findExactMatch(prefix);
    if (entry == nullptr) {
      return CheckNextHopResult::NO_FIB_ENTRY;
    }

    const auto&amp; nextHops = entry-&gt;getNextHops();
    if (expectedNNextHops &amp;&amp; nextHops.size() != *expectedNNextHops) {
      return CheckNextHopResult::WRONG_N_NEXTHOPS;
    }

    if (faceId) {
      for (const auto&amp; record : nextHops) {
        if (record.getFace().getId() == *faceId) {
          if (expectedCost &amp;&amp; record.getCost() != *expectedCost)
            return CheckNextHopResult::WRONG_COST;
          else
            return CheckNextHopResult::OK;
        }
      }
      return CheckNextHopResult::NO_NEXTHOP;
    }
    return CheckNextHopResult::OK;
  }

<A NAME="0"></A>protected:
  Fib&amp;       m_fib;
  FibManager m_manager;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match587-1.html#0',3,'match587-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, FibManagerFixture::CheckNextHopResult result)
{
  switch (result) {
  case FibManagerFixture::CheckNextHopResult::OK:
    return os &lt;&lt; &quot;OK&quot;;
  case FibManagerFixture::CheckNextHopResult::NO_FIB_ENTRY:
    return os &lt;&lt; &quot;NO_FIB_ENTRY&quot;;
  case FibManagerFixture::CheckNextHopResult::WRONG_N_NEXTHOPS:
    return os &lt;&lt; &quot;WRONG_N_NEXTHOPS&quot;;
  case FibManagerFixture::CheckNextHopResult::NO_NEXTHOP:
    return os &lt;&lt; &quot;NO_NEXTHOP&quot;;
  case FibManagerFixture::CheckNextHopResult::WRONG_COST:
    return os &lt;&lt; &quot;WRONG_COST&quot;;
  }</B></FONT>
  return os &lt;&lt; static_cast&lt;int&gt;(result);
}

BOOST_AUTO_TEST_SUITE(Mgmt)
BOOST_FIXTURE_TEST_SUITE(TestFibManager, FibManagerFixture)

BOOST_AUTO_TEST_SUITE(AddNextHop)

BOOST_AUTO_TEST_CASE(UnknownFaceId)
{
  auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/add-nexthop&quot;,
                                       makeParameters(&quot;hello&quot;, face::FACEID_NULL, 101));
  receiveInterest(req);
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);

  // check response
  BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), ControlResponse(410, &quot;Face not found&quot;)),
                    CheckResponseResult::OK);

  // double check that the next hop was not added
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, nullopt, nullopt, 101), CheckNextHopResult::NO_FIB_ENTRY);
}

BOOST_AUTO_TEST_CASE(NameTooLong)
{
  Name prefix;
  while (prefix.size() &lt;= Fib::getMaxDepth()) {
    prefix.append(&quot;A&quot;);
  }

  auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/add-nexthop&quot;,
                                       makeParameters(prefix, addFace()));
  receiveInterest(req);

  ControlResponse expected(414, &quot;FIB entry prefix cannot exceed &quot; +
                                ndn::to_string(Fib::getMaxDepth()) + &quot; components&quot;);
  BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), expected), CheckResponseResult::OK);

  BOOST_CHECK_EQUAL(checkNextHop(prefix), CheckNextHopResult::NO_FIB_ENTRY);
}

BOOST_AUTO_TEST_CASE(ImplicitFaceId)
{
  auto face1 = addFace();
  auto face2 = addFace();
  BOOST_REQUIRE_NE(face1, face::INVALID_FACEID);
  BOOST_REQUIRE_NE(face2, face::INVALID_FACEID);

  Name expectedName;
  ControlResponse expectedResponse;
  auto testAddNextHop = [&amp;] (ControlParameters parameters, const FaceId&amp; faceId) {
    auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/add-nexthop&quot;, parameters);
    req.setTag(make_shared&lt;lp::IncomingFaceIdTag&gt;(faceId));
    m_responses.clear();
    expectedName = req.getName();
    expectedResponse = makeResponse(200, &quot;Success&quot;, parameters.setFaceId(faceId));
    receiveInterest(req);
  };

  testAddNextHop(ControlParameters().setName(&quot;/hello&quot;).setCost(100).setFaceId(0), face1);
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 1, face1, 100), CheckNextHopResult::OK);

  testAddNextHop(ControlParameters().setName(&quot;/hello&quot;).setCost(100), face2);
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 2, face2, 100), CheckNextHopResult::OK);
}

BOOST_AUTO_TEST_CASE(InitialAdd)
{
  FaceId addedFaceId = addFace();
  BOOST_REQUIRE_NE(addedFaceId, face::INVALID_FACEID);

  auto parameters = makeParameters(&quot;hello&quot;, addedFaceId, 101);
  auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/add-nexthop&quot;, parameters);
  receiveInterest(req);

  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), makeResponse(200, &quot;Success&quot;, parameters)),
                    CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 1, addedFaceId, 101), CheckNextHopResult::OK);
}

BOOST_AUTO_TEST_CASE(ImplicitCost)
{
  FaceId addedFaceId = addFace();
  BOOST_REQUIRE_NE(addedFaceId, face::INVALID_FACEID);

  auto originalParameters = ControlParameters().setName(&quot;/hello&quot;).setFaceId(addedFaceId);
  auto parameters = makeParameters(&quot;/hello&quot;, addedFaceId, 0);
  auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/add-nexthop&quot;, originalParameters);
  receiveInterest(req);

  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), makeResponse(200, &quot;Success&quot;, parameters)),
                    CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 1, addedFaceId, 0), CheckNextHopResult::OK);
}

BOOST_AUTO_TEST_CASE(AddToExisting)
{
  FaceId face = addFace();
  BOOST_REQUIRE_NE(face, face::INVALID_FACEID);

  Name expectedName;
  ControlResponse expectedResponse;
  auto testAddNextHop = [&amp;] (const ControlParameters&amp; parameters) {
    m_responses.clear();
    auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/add-nexthop&quot;, parameters);
    expectedName = req.getName();
    expectedResponse = makeResponse(200, &quot;Success&quot;, parameters);
    receiveInterest(req);
  };

  // add initial, succeeds
  testAddNextHop(makeParameters(&quot;/hello&quot;, face, 101));
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);

  // add to existing --&gt; update cost, succeeds
  testAddNextHop(makeParameters(&quot;/hello&quot;, face, 102));
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);

  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 2, face, 102), CheckNextHopResult::WRONG_N_NEXTHOPS);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 1, face, 101), CheckNextHopResult::WRONG_COST);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 1, face, 102), CheckNextHopResult::OK);
}

BOOST_AUTO_TEST_SUITE_END() // AddNextHop

BOOST_AUTO_TEST_SUITE(RemoveNextHop)

BOOST_AUTO_TEST_CASE(Basic)
{
  Name expectedName;
  ControlResponse expectedResponse;
  auto testRemoveNextHop = [&amp;] (const ControlParameters&amp; parameters) {
    m_responses.clear();
    auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/remove-nexthop&quot;, parameters);
    expectedName = req.getName();
    expectedResponse = makeResponse(200, &quot;Success&quot;, parameters);
    receiveInterest(req);
  };

  FaceId face1 = addFace();
  FaceId face2 = addFace();
  FaceId face3 = addFace();
  BOOST_REQUIRE_NE(face1, face::INVALID_FACEID);
  BOOST_REQUIRE_NE(face2, face::INVALID_FACEID);
  BOOST_REQUIRE_NE(face3, face::INVALID_FACEID);

  fib::Entry* entry = m_fib.insert(&quot;/hello&quot;).first;
  m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face1), 101);
  m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face2), 202);
  m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face3), 303);

  testRemoveNextHop(makeParameters(&quot;/hello&quot;, face1));
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 2, face1, 101), CheckNextHopResult::NO_NEXTHOP);

  testRemoveNextHop(makeParameters(&quot;/hello&quot;, face2));
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 1, face2, 202), CheckNextHopResult::NO_NEXTHOP);

  testRemoveNextHop(makeParameters(&quot;/hello&quot;, face3));
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 0, face3, 303), CheckNextHopResult::NO_FIB_ENTRY);
}

BOOST_AUTO_TEST_CASE(PrefixNotFound)
{
  FaceId addedFaceId = addFace();
  BOOST_REQUIRE_NE(addedFaceId, face::INVALID_FACEID);

  auto parameters = makeParameters(&quot;hello&quot;, addedFaceId);
  auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/remove-nexthop&quot;, parameters);
  receiveInterest(req);
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);

  auto expectedResponse = makeResponse(200, &quot;Success&quot;, parameters);
  BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), expectedResponse), CheckResponseResult::OK);
}

BOOST_AUTO_TEST_CASE(ImplicitFaceId)
{
  auto face1 = addFace();
  auto face2 = addFace();
  BOOST_REQUIRE_NE(face1, face::INVALID_FACEID);
  BOOST_REQUIRE_NE(face2, face::INVALID_FACEID);

  Name expectedName;
  ControlResponse expectedResponse;
  auto testWithImplicitFaceId = [&amp;] (ControlParameters parameters, FaceId face) {
    m_responses.clear();
    auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/remove-nexthop&quot;, parameters);
    req.setTag(make_shared&lt;lp::IncomingFaceIdTag&gt;(face));
    expectedName = req.getName();
    expectedResponse = makeResponse(200, &quot;Success&quot;, parameters.setFaceId(face));
    receiveInterest(req);
  };

  fib::Entry* entry = m_fib.insert(&quot;/hello&quot;).first;
  m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face1), 101);
  m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face2), 202);

  testWithImplicitFaceId(ControlParameters().setName(&quot;/hello&quot;).setFaceId(0), face1);
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 1, face1, 101), CheckNextHopResult::NO_NEXTHOP);

  testWithImplicitFaceId(ControlParameters().setName(&quot;/hello&quot;), face2);
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, 0, face2, 202), CheckNextHopResult::NO_FIB_ENTRY);
}

BOOST_AUTO_TEST_CASE(RecordNotExist)
{
  auto face1 = addFace();
  auto face2 = addFace();
  BOOST_REQUIRE_NE(face1, face::INVALID_FACEID);
  BOOST_REQUIRE_NE(face2, face::INVALID_FACEID);

  Name expectedName;
  ControlResponse expectedResponse;
  auto testRemoveNextHop = [&amp;] (ControlParameters parameters) {
    m_responses.clear();
    auto req = makeControlCommandRequest(&quot;/localhost/nfd/fib/remove-nexthop&quot;, parameters);
    expectedName = req.getName();
    expectedResponse = makeResponse(200, &quot;Success&quot;, parameters);
    receiveInterest(req);
  };

  fib::Entry* entry = m_fib.insert(&quot;/hello&quot;).first;
  m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face1), 101);

  testRemoveNextHop(makeParameters(&quot;/hello&quot;, face2 + 100));
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1); // face does not exist
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, nullopt, face2 + 100), CheckNextHopResult::NO_NEXTHOP);

  testRemoveNextHop(makeParameters(&quot;/hello&quot;, face2));
  BOOST_REQUIRE_EQUAL(m_responses.size(), 1); // record does not exist
  BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
  BOOST_CHECK_EQUAL(checkNextHop(&quot;/hello&quot;, nullopt, face2), CheckNextHopResult::NO_NEXTHOP);
}

BOOST_AUTO_TEST_SUITE_END() // RemoveNextHop

BOOST_AUTO_TEST_SUITE(List)

BOOST_AUTO_TEST_CASE(FibDataset)
{
  const size_t nEntries = 108;
  std::set&lt;Name&gt; actualPrefixes;
  for (size_t i = 0 ; i &lt; nEntries ; i ++) {
    Name prefix = Name(&quot;test&quot;).appendSegment(i);
    actualPrefixes.insert(prefix);
    fib::Entry* fibEntry = m_fib.insert(prefix).first;
    m_fib.addOrUpdateNextHop(*fibEntry, *m_faceTable.get(addFace()), std::numeric_limits&lt;uint8_t&gt;::max() - 1);
    m_fib.addOrUpdateNextHop(*fibEntry, *m_faceTable.get(addFace()), std::numeric_limits&lt;uint8_t&gt;::max() - 2);
  }

  receiveInterest(Interest(&quot;/localhost/nfd/fib/list&quot;).setCanBePrefix(true));

  Block content = concatenateResponses();
  content.parse();
  BOOST_REQUIRE_EQUAL(content.elements().size(), nEntries);

  std::vector&lt;ndn::nfd::FibEntry&gt; receivedRecords, expectedRecords;
  for (size_t idx = 0; idx &lt; nEntries; ++idx) {
    ndn::nfd::FibEntry decodedEntry(content.elements()[idx]);
    receivedRecords.push_back(decodedEntry);
    actualPrefixes.erase(decodedEntry.getPrefix());

    auto matchedEntry = m_fib.findExactMatch(decodedEntry.getPrefix());
    BOOST_REQUIRE(matchedEntry != nullptr);

    expectedRecords.emplace_back();
    expectedRecords.back().setPrefix(matchedEntry-&gt;getPrefix());
    for (const auto&amp; nh : matchedEntry-&gt;getNextHops()) {
      expectedRecords.back().addNextHopRecord(ndn::nfd::NextHopRecord()
                                              .setFaceId(nh.getFace().getId())
                                              .setCost(nh.getCost()));
    }
  }

  BOOST_CHECK_EQUAL(actualPrefixes.size(), 0);
  BOOST_CHECK_EQUAL_COLLECTIONS(receivedRecords.begin(), receivedRecords.end(),
                                expectedRecords.begin(), expectedRecords.end());
}

BOOST_AUTO_TEST_SUITE_END() // List

BOOST_AUTO_TEST_SUITE_END() // TestFibManager
BOOST_AUTO_TEST_SUITE_END() // Mgmt

} // namespace tests
} // namespace nfd
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rib-manager.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;rib-manager.hpp&quot;

#include &quot;common/global.hpp&quot;
#include &quot;common/logger.hpp&quot;
#include &quot;rib/rib.hpp&quot;
#include &quot;table/fib.hpp&quot;

#include &lt;ndn-cxx/lp/tags.hpp&gt;
#include &lt;ndn-cxx/mgmt/nfd/face-status.hpp&gt;
#include &lt;ndn-cxx/mgmt/nfd/rib-entry.hpp&gt;
#include &lt;ndn-cxx/security/certificate-fetcher-direct-fetch.hpp&gt;

namespace nfd {

using rib::RibUpdate;
using rib::Route;

NFD_LOG_INIT(RibManager);

static const std::string MGMT_MODULE_NAME = &quot;rib&quot;;
static const Name LOCALHOST_TOP_PREFIX = &quot;/localhost/nfd&quot;;
static const time::seconds ACTIVE_FACE_FETCH_INTERVAL = 5_min;

const Name RibManager::LOCALHOP_TOP_PREFIX = &quot;/localhop/nfd&quot;;

RibManager::RibManager(rib::Rib&amp; rib, ndn::Face&amp; face, ndn::KeyChain&amp; keyChain,
                       ndn::nfd::Controller&amp; nfdController, Dispatcher&amp; dispatcher)
  : ManagerBase(MGMT_MODULE_NAME, dispatcher)
  , m_rib(rib)
  , m_keyChain(keyChain)
  , m_nfdController(nfdController)
  , m_dispatcher(dispatcher)
  , m_faceMonitor(face)
  , m_localhostValidator(face)
  , m_localhopValidator(make_unique&lt;ndn::security::CertificateFetcherDirectFetch&gt;(face))
  , m_paValidator(make_unique&lt;ndn::security::CertificateFetcherDirectFetch&gt;(face))
  , m_isLocalhopEnabled(false)
{
  registerCommandHandler&lt;ndn::nfd::RibRegisterCommand&gt;(&quot;register&quot;,
    std::bind(&amp;RibManager::registerEntry, this, _2, _3, _4, _5));
  registerCommandHandler&lt;ndn::nfd::RibUnregisterCommand&gt;(&quot;unregister&quot;,
    std::bind(&amp;RibManager::unregisterEntry, this, _2, _3, _4, _5));

  registerStatusDatasetHandler(&quot;list&quot;, std::bind(&amp;RibManager::listEntries, this, _1, _2, _3));
}

void
RibManager::applyLocalhostConfig(const ConfigSection&amp; section, const std::string&amp; filename)
{
  m_localhostValidator.load(section, filename);
}

void
RibManager::enableLocalhop(const ConfigSection&amp; section, const std::string&amp; filename)
{
  m_localhopValidator.load(section, filename);
  m_isLocalhopEnabled = true;
}

void
RibManager::disableLocalhop()
{
  m_isLocalhopEnabled = false;
}

void
RibManager::applyPaConfig(const ConfigSection&amp; section, const std::string&amp; filename)
{
  m_paValidator.load(section, filename);
}

void
RibManager::registerWithNfd()
{
  registerTopPrefix(LOCALHOST_TOP_PREFIX);

  if (m_isLocalhopEnabled) {
    registerTopPrefix(LOCALHOP_TOP_PREFIX);
  }

  NFD_LOG_INFO(&quot;Start monitoring face create/destroy events&quot;);
  m_faceMonitor.onNotification.connect([this] (const auto&amp; notif) { onNotification(notif); });
  m_faceMonitor.start();

  scheduleActiveFaceFetch(ACTIVE_FACE_FETCH_INTERVAL);
}

void
RibManager::enableLocalFields()
{
  m_nfdController.start&lt;ndn::nfd::FaceUpdateCommand&gt;(
    ControlParameters().setFlagBit(ndn::nfd::BIT_LOCAL_FIELDS_ENABLED, true),
    [] (const ControlParameters&amp;) {
      NFD_LOG_DEBUG(&quot;Local fields enabled&quot;);
    },
    [] (const ControlResponse&amp; res) {
      NDN_THROW(Error(&quot;Couldn't enable local fields (&quot; + to_string(res.getCode()) +
                      &quot; &quot; + res.getText() + &quot;)&quot;));
    });
}

void
RibManager::beginAddRoute(const Name&amp; name, Route route, optional&lt;time::nanoseconds&gt; expires,
                          const std::function&lt;void(RibUpdateResult)&gt;&amp; done)
{
  if (expires) {
    route.expires = time::steady_clock::now() + *expires;
  }
  else if (route.expires) {
    expires = *route.expires - time::steady_clock::now();
  }

  if (expires &amp;&amp; *expires &lt;= 0_s) {
    m_rib.onRouteExpiration(name, route);
    return done(RibUpdateResult::EXPIRED);
  }

  NFD_LOG_INFO(&quot;Adding route &quot; &lt;&lt; name &lt;&lt; &quot; nexthop=&quot; &lt;&lt; route.faceId &lt;&lt;
               &quot; origin=&quot; &lt;&lt; route.origin &lt;&lt; &quot; cost=&quot; &lt;&lt; route.cost);

  if (expires) {
    auto event = getScheduler().schedule(*expires, [=] { m_rib.onRouteExpiration(name, route); });
    route.setExpirationEvent(event);
    NFD_LOG_TRACE(&quot;Scheduled unregistration at: &quot; &lt;&lt; *route.expires);
  }

  RibUpdate update;
  update.setAction(RibUpdate::REGISTER)
        .setName(name)
        .setRoute(route);
  beginRibUpdate(update, done);
}

void
RibManager::beginRemoveRoute(const Name&amp; name, const Route&amp; route,
                             const std::function&lt;void(RibUpdateResult)&gt;&amp; done)
{
  NFD_LOG_INFO(&quot;Removing route &quot; &lt;&lt; name &lt;&lt; &quot; nexthop=&quot; &lt;&lt; route.faceId &lt;&lt;
               &quot; origin=&quot; &lt;&lt; route.origin);

  RibUpdate update;
  update.setAction(RibUpdate::UNREGISTER)
        .setName(name)
        .setRoute(route);
  beginRibUpdate(update, done);
}

void
RibManager::beginRibUpdate(const RibUpdate&amp; update,
                           const std::function&lt;void(RibUpdateResult)&gt;&amp; done)
{
  m_rib.beginApplyUpdate(update,
    [=] {
      NFD_LOG_DEBUG(&quot;RIB update succeeded for &quot; &lt;&lt; update);
      done(RibUpdateResult::OK);
    },
    [=] (uint32_t code, const std::string&amp; error) {
      NFD_LOG_DEBUG(&quot;RIB update failed for &quot; &lt;&lt; update &lt;&lt; &quot; (&quot; &lt;&lt; code &lt;&lt; &quot; &quot; &lt;&lt; error &lt;&lt; &quot;)&quot;);

      // Since the FIB rejected the update, clean up invalid routes
      scheduleActiveFaceFetch(1_s);

      done(RibUpdateResult::ERROR);
    });
}

void
RibManager::registerTopPrefix(const Name&amp; topPrefix)
{
  // add FIB nexthop
  m_nfdController.start&lt;ndn::nfd::FibAddNextHopCommand&gt;(
    ControlParameters().setName(Name(topPrefix).append(MGMT_MODULE_NAME))
                       .setFaceId(0),
    [=] (const ControlParameters&amp; res) {
      NFD_LOG_DEBUG(&quot;Successfully registered &quot; &lt;&lt; topPrefix &lt;&lt; &quot; with NFD&quot;);

      // Routes must be inserted into the RIB so route flags can be applied
      Route route;
      route.faceId = res.getFaceId();
      route.origin = ndn::nfd::ROUTE_ORIGIN_APP;
      route.flags = ndn::nfd::ROUTE_FLAG_CHILD_INHERIT;

      m_rib.insert(topPrefix, route);
    },
    [=] (const ControlResponse&amp; res) {
      NDN_THROW(Error(&quot;Cannot add FIB entry &quot; + topPrefix.toUri() + &quot; (&quot; +
                      to_string(res.getCode()) + &quot; &quot; + res.getText() + &quot;)&quot;));
    });

  // add top prefix to the dispatcher without prefix registration
  m_dispatcher.addTopPrefix(topPrefix, false);
}

void
RibManager::registerEntry(const Name&amp; topPrefix, const Interest&amp; interest,
                          ControlParameters parameters,
                          const ndn::mgmt::CommandContinuation&amp; done)
{
  if (parameters.getName().size() &gt; Fib::getMaxDepth()) {
    done(ControlResponse(414, &quot;Route prefix cannot exceed &quot; + to_string(Fib::getMaxDepth()) +
                              &quot; components&quot;));
    return;
  }

  setFaceForSelfRegistration(interest, parameters);

  // Respond since command is valid and authorized
  done(ControlResponse(200, &quot;Success&quot;).setBody(parameters.wireEncode()));

  Route route;
  route.faceId = parameters.getFaceId();
  route.origin = parameters.getOrigin();
  route.cost = parameters.getCost();
  route.flags = parameters.getFlags();

  optional&lt;time::nanoseconds&gt; expires;
  if (parameters.hasExpirationPeriod() &amp;&amp;
      parameters.getExpirationPeriod() != time::milliseconds::max()) {
    expires = time::duration_cast&lt;time::nanoseconds&gt;(parameters.getExpirationPeriod());
  }

  beginAddRoute(parameters.getName(), std::move(route), expires, [] (RibUpdateResult) {});
}

void
RibManager::unregisterEntry(const Name&amp;, const Interest&amp; interest,
                            ControlParameters parameters,
                            const ndn::mgmt::CommandContinuation&amp; done)
{
  setFaceForSelfRegistration(interest, parameters);

  // Respond since command is valid and authorized
  done(ControlResponse(200, &quot;Success&quot;).setBody(parameters.wireEncode()));

  Route route;
  route.faceId = parameters.getFaceId();
  route.origin = parameters.getOrigin();

  beginRemoveRoute(parameters.getName(), route, [] (RibUpdateResult) {});
}

void
RibManager::listEntries(const Name&amp;, const Interest&amp; interest,
                        ndn::mgmt::StatusDatasetContext&amp; context)
{
  auto now = time::steady_clock::now();
  for (const auto&amp; kv : m_rib) {
    const rib::RibEntry&amp; entry = *kv.second;
    ndn::nfd::RibEntry item;
    item.setName(entry.getName());
    for (const Route&amp; route : entry.getRoutes()) {
      ndn::nfd::Route r;
      r.setFaceId(route.faceId);
      r.setOrigin(route.origin);
      r.setCost(route.cost);
      r.setFlags(route.flags);
      if (route.expires) {
        r.setExpirationPeriod(time::duration_cast&lt;time::milliseconds&gt;(*route.expires - now));
      }
      item.addRoute(r);
    }
    context.append(item.wireEncode());
  }
  context.end();
}

void
RibManager::setFaceForSelfRegistration(const Interest&amp; request, ControlParameters&amp; parameters)
{
  bool isSelfRegistration = (parameters.getFaceId() == 0);
  if (isSelfRegistration) {
    shared_ptr&lt;lp::IncomingFaceIdTag&gt; incomingFaceIdTag = request.getTag&lt;lp::IncomingFaceIdTag&gt;();
    // NDNLPv2 says &quot;application MUST be prepared to receive a packet without IncomingFaceId field&quot;,
    // but it's fine to assert IncomingFaceId is available, because InternalFace lives inside NFD
    // and is initialized synchronously with IncomingFaceId field enabled.
    BOOST_ASSERT(incomingFaceIdTag != nullptr);
    parameters.setFaceId(*incomingFaceIdTag);
  }
}

ndn::mgmt::Authorization
RibManager::makeAuthorization(const std::string&amp;)
{
  return [this] (const Name&amp; prefix, const Interest&amp; interest,
                 const ndn::mgmt::ControlParameters* params,
                 const ndn::mgmt::AcceptContinuation&amp; accept,
                 const ndn::mgmt::RejectContinuation&amp; reject) {
    BOOST_ASSERT(params != nullptr);
    BOOST_ASSERT(typeid(*params) == typeid(ndn::nfd::ControlParameters));
    BOOST_ASSERT(prefix == LOCALHOST_TOP_PREFIX || prefix == LOCALHOP_TOP_PREFIX);

    auto&amp; validator = prefix == LOCALHOST_TOP_PREFIX ? m_localhostValidator : m_localhopValidator;
    validator.validate(interest,
<A NAME="0"></A>                       [&amp;interest, accept] (auto&amp;&amp;...) { extractRequester(interest, accept); },
                       [reject] (auto&amp;&amp;...) { reject(ndn::mgmt::RejectReply::STATUS403); });
  };
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match587-0.html#0',2,'match587-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, RibManager::SlAnnounceResult res)
{
  switch (res) {
  case RibManager::SlAnnounceResult::OK:
    return os &lt;&lt; &quot;OK&quot;;
  case RibManager::SlAnnounceResult::ERROR:
    return os &lt;&lt; &quot;ERROR&quot;;
  case RibManager::SlAnnounceResult::VALIDATION_FAILURE:
    return os &lt;&lt; &quot;VALIDATION_FAILURE&quot;;
  case RibManager::SlAnnounceResult::EXPIRED:
    return os &lt;&lt; &quot;EXPIRED&quot;;
  case RibManager::SlAnnounceResult::NOT_FOUND:
    return os &lt;&lt; &quot;NOT_FOUND&quot;;
  }</B></FONT>
  NDN_THROW(std::invalid_argument(&quot;Unknown SlAnnounceResult&quot;));
}

RibManager::SlAnnounceResult
RibManager::getSlAnnounceResultFromRibUpdateResult(RibUpdateResult r)
{
  switch (r) {
  case RibUpdateResult::OK:
    return SlAnnounceResult::OK;
  case RibUpdateResult::ERROR:
    return SlAnnounceResult::ERROR;
  case RibUpdateResult::EXPIRED:
    return SlAnnounceResult::EXPIRED;
  }
  NDN_CXX_UNREACHABLE;
}

void
RibManager::slAnnounce(const ndn::PrefixAnnouncement&amp; pa, uint64_t faceId,
                       time::milliseconds maxLifetime, const SlAnnounceCallback&amp; cb)
{
  BOOST_ASSERT(pa.getData());

  m_paValidator.validate(*pa.getData(),
    [=] (const Data&amp;) {
      Route route(pa, faceId);
      route.expires = std::min(route.annExpires, time::steady_clock::now() + maxLifetime);
      beginAddRoute(pa.getAnnouncedName(), route, nullopt,
        [=] (RibUpdateResult ribRes) {
          auto res = getSlAnnounceResultFromRibUpdateResult(ribRes);
          NFD_LOG_INFO(&quot;slAnnounce &quot; &lt;&lt; pa.getAnnouncedName() &lt;&lt; &quot; &quot; &lt;&lt; faceId &lt;&lt; &quot;: &quot; &lt;&lt; res);
          cb(res);
        });
    },
    [=] (const Data&amp;, ndn::security::ValidationError err) {
      NFD_LOG_INFO(&quot;slAnnounce &quot; &lt;&lt; pa.getAnnouncedName() &lt;&lt; &quot; &quot; &lt;&lt; faceId &lt;&lt;
                   &quot; validation error: &quot; &lt;&lt; err);
      cb(SlAnnounceResult::VALIDATION_FAILURE);
    }
  );
}

void
RibManager::slRenew(const Name&amp; name, uint64_t faceId, time::milliseconds maxLifetime,
                    const SlAnnounceCallback&amp; cb)
{
  Route routeQuery;
  routeQuery.faceId = faceId;
  routeQuery.origin = ndn::nfd::ROUTE_ORIGIN_PREFIXANN;
  Route* oldRoute = m_rib.findLongestPrefix(name, routeQuery);

  if (oldRoute == nullptr || !oldRoute-&gt;announcement) {
    NFD_LOG_DEBUG(&quot;slRenew &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; faceId &lt;&lt; &quot;: not found&quot;);
    return cb(SlAnnounceResult::NOT_FOUND);
  }
  Name routeName = oldRoute-&gt;announcement-&gt;getAnnouncedName();

  Route route = *oldRoute;
  route.expires = std::min(route.annExpires, time::steady_clock::now() + maxLifetime);
  beginAddRoute(routeName, route, nullopt,
    [=] (RibUpdateResult ribRes) {
      auto res = getSlAnnounceResultFromRibUpdateResult(ribRes);
      NFD_LOG_INFO(&quot;slRenew &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; faceId &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; routeName);
      cb(res);
    });
}

void
RibManager::slFindAnn(const Name&amp; name, const SlFindAnnCallback&amp; cb) const
{
  shared_ptr&lt;rib::RibEntry&gt; entry;
  auto exactMatch = m_rib.find(name);
  if (exactMatch != m_rib.end()) {
    entry = exactMatch-&gt;second;
  }
  else {
    entry = m_rib.findParent(name);
  }
  if (entry == nullptr) {
    return cb(nullopt);
  }

  auto pa = entry-&gt;getPrefixAnnouncement();
  pa.toData(m_keyChain);
  cb(pa);
}

void
RibManager::fetchActiveFaces()
{
  NFD_LOG_DEBUG(&quot;Fetching active faces&quot;);

  m_nfdController.fetch&lt;ndn::nfd::FaceDataset&gt;(
    std::bind(&amp;RibManager::removeInvalidFaces, this, _1),
    std::bind(&amp;RibManager::onFetchActiveFacesFailure, this, _1, _2),
    ndn::nfd::CommandOptions());
}

void
RibManager::onFetchActiveFacesFailure(uint32_t code, const std::string&amp; reason)
{
  NFD_LOG_DEBUG(&quot;Face Status Dataset request failure &quot; &lt;&lt; code &lt;&lt; &quot; &quot; &lt;&lt; reason);
  scheduleActiveFaceFetch(ACTIVE_FACE_FETCH_INTERVAL);
}

void
RibManager::scheduleActiveFaceFetch(const time::seconds&amp; timeToWait)
{
  m_activeFaceFetchEvent = getScheduler().schedule(timeToWait, [this] { fetchActiveFaces(); });
}

void
RibManager::removeInvalidFaces(const std::vector&lt;ndn::nfd::FaceStatus&gt;&amp; activeFaces)
{
  NFD_LOG_DEBUG(&quot;Checking for invalid face registrations&quot;);

  std::set&lt;uint64_t&gt; activeFaceIds;
  for (const auto&amp; faceStatus : activeFaces) {
    activeFaceIds.insert(faceStatus.getFaceId());
  }
  getGlobalIoService().post([=] { m_rib.beginRemoveFailedFaces(activeFaceIds); });

  // Reschedule the check for future clean up
  scheduleActiveFaceFetch(ACTIVE_FACE_FETCH_INTERVAL);
}

void
RibManager::onNotification(const ndn::nfd::FaceEventNotification&amp; notification)
{
  NFD_LOG_TRACE(&quot;onNotification: &quot; &lt;&lt; notification);

  if (notification.getKind() == ndn::nfd::FACE_EVENT_DESTROYED) {
    NFD_LOG_DEBUG(&quot;Received notification for destroyed FaceId &quot; &lt;&lt; notification.getFaceId());
    getGlobalIoService().post([this, id = notification.getFaceId()] { m_rib.beginRemoveFace(id); });
  }
}

} // namespace nfd
</PRE>
</div>
  </div>
</body>
</html>
