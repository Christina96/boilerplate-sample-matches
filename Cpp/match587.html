<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for fib-manager.t.cpp &amp; rib-manager.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for fib-manager.t.cpp &amp; rib-manager.cpp
      </h3>
<h1 align="center">
        7.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>fib-manager.t.cpp (9.354838%)<th>rib-manager.cpp (5.7768927%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(129-145)<td><a href="#" name="0">(322-338)</a><td align="center"><font color="#ff0000">29</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>fib-manager.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "mgmt/fib-manager.hpp"
2 #include "table/fib-nexthop.hpp"
3 #include "manager-common-fixture.hpp"
4 #include "tests/daemon/face/dummy-face.hpp"
5 #include &lt;ndn-cxx/lp/tags.hpp&gt;
6 #include &lt;ndn-cxx/mgmt/nfd/fib-entry.hpp&gt;
7 namespace nfd {
8 namespace tests {
9 class FibManagerFixture : public ManagerFixtureWithAuthenticator
10 {
11 public:
12   FibManagerFixture()
13     : m_fib(m_forwarder.getFib())
14     , m_manager(m_fib, m_faceTable, m_dispatcher, *m_authenticator)
15   {
16     setTopPrefix();
17     setPrivilege("fib");
18   }
19 public:   static ControlParameters
20   makeParameters(const Name&amp; name, const FaceId&amp; id)
21   {
22     return ControlParameters().setName(name).setFaceId(id);
23   }
24   static ControlParameters
25   makeParameters(const Name&amp; name, const FaceId&amp; id, const uint32_t&amp; cost)
26   {
27     return ControlParameters().setName(name).setFaceId(id).setCost(cost);
28   }
29   FaceId
30   addFace()
31   {
32     auto face = make_shared&lt;DummyFace&gt;();
33     m_faceTable.add(face);
34     advanceClocks(1_ms, 10);
35     m_responses.clear();     return face-&gt;getId();
36   }
37 public:   enum class CheckNextHopResult
38   {
39     OK,
40     NO_FIB_ENTRY,
41     WRONG_N_NEXTHOPS,
42     NO_NEXTHOP,
43     WRONG_COST
44   };
45   CheckNextHopResult
46   checkNextHop(const Name&amp; prefix,
47                optional&lt;size_t&gt; expectedNNextHops = nullopt,
48                optional&lt;FaceId&gt; faceId = nullopt,
49                optional&lt;uint64_t&gt; expectedCost = nullopt) const
50   {
51     const fib::Entry* entry = m_fib.findExactMatch(prefix);
52     if (entry == nullptr) {
53       return CheckNextHopResult::NO_FIB_ENTRY;
54     }
55     const auto&amp; nextHops = entry-&gt;getNextHops();
56     if (expectedNNextHops &amp;&amp; nextHops.size() != *expectedNNextHops) {
57       return CheckNextHopResult::WRONG_N_NEXTHOPS;
58     }
59     if (faceId) {
60       for (const auto&amp; record : nextHops) {
61         if (record.getFace().getId() == *faceId) {
62           if (expectedCost &amp;&amp; record.getCost() != *expectedCost)
63             return CheckNextHopResult::WRONG_COST;
64           else
65             return CheckNextHopResult::OK;
66         }
67       }
68       return CheckNextHopResult::NO_NEXTHOP;
69     }
70     return CheckNextHopResult::OK;
71   }
72 <a name="0"></a>protected:
73   Fib&amp;       m_fib;
74   FibManager m_manager;
75 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
76 std::ostream&amp;
77 operator&lt;&lt;(std::ostream&amp; os, FibManagerFixture::CheckNextHopResult result)
78 {
79   switch (result) {
80   case FibManagerFixture::CheckNextHopResult::OK:
81     return os &lt;&lt; "OK";
82   case FibManagerFixture::CheckNextHopResult::NO_FIB_ENTRY:
83     return os &lt;&lt; "NO_FIB_ENTRY";
84   case FibManagerFixture::CheckNextHopResult::WRONG_N_NEXTHOPS:
85     return os &lt;&lt; "WRONG_N_NEXTHOPS";
86   case FibManagerFixture::CheckNextHopResult::NO_NEXTHOP:
87     return os &lt;&lt; "NO_NEXTHOP";
88   case FibManagerFixture::CheckNextHopResult::WRONG_COST:
89     return os &lt;&lt; "WRONG_COST";
90   }</b></font>
91   return os &lt;&lt; static_cast&lt;int&gt;(result);
92 }
93 BOOST_AUTO_TEST_SUITE(Mgmt)
94 BOOST_FIXTURE_TEST_SUITE(TestFibManager, FibManagerFixture)
95 BOOST_AUTO_TEST_SUITE(AddNextHop)
96 BOOST_AUTO_TEST_CASE(UnknownFaceId)
97 {
98   auto req = makeControlCommandRequest("/localhost/nfd/fib/add-nexthop",
99                                        makeParameters("hello", face::FACEID_NULL, 101));
100   receiveInterest(req);
101   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
102   BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), ControlResponse(410, "Face not found")),
103                     CheckResponseResult::OK);
104   BOOST_CHECK_EQUAL(checkNextHop("/hello", nullopt, nullopt, 101), CheckNextHopResult::NO_FIB_ENTRY);
105 }
106 BOOST_AUTO_TEST_CASE(NameTooLong)
107 {
108   Name prefix;
109   while (prefix.size() &lt;= Fib::getMaxDepth()) {
110     prefix.append("A");
111   }
112   auto req = makeControlCommandRequest("/localhost/nfd/fib/add-nexthop",
113                                        makeParameters(prefix, addFace()));
114   receiveInterest(req);
115   ControlResponse expected(414, "FIB entry prefix cannot exceed " +
116                                 ndn::to_string(Fib::getMaxDepth()) + " components");
117   BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), expected), CheckResponseResult::OK);
118   BOOST_CHECK_EQUAL(checkNextHop(prefix), CheckNextHopResult::NO_FIB_ENTRY);
119 }
120 BOOST_AUTO_TEST_CASE(ImplicitFaceId)
121 {
122   auto face1 = addFace();
123   auto face2 = addFace();
124   BOOST_REQUIRE_NE(face1, face::INVALID_FACEID);
125   BOOST_REQUIRE_NE(face2, face::INVALID_FACEID);
126   Name expectedName;
127   ControlResponse expectedResponse;
128   auto testAddNextHop = [&amp;] (ControlParameters parameters, const FaceId&amp; faceId) {
129     auto req = makeControlCommandRequest("/localhost/nfd/fib/add-nexthop", parameters);
130     req.setTag(make_shared&lt;lp::IncomingFaceIdTag&gt;(faceId));
131     m_responses.clear();
132     expectedName = req.getName();
133     expectedResponse = makeResponse(200, "Success", parameters.setFaceId(faceId));
134     receiveInterest(req);
135   };
136   testAddNextHop(ControlParameters().setName("/hello").setCost(100).setFaceId(0), face1);
137   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
138   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
139   BOOST_CHECK_EQUAL(checkNextHop("/hello", 1, face1, 100), CheckNextHopResult::OK);
140   testAddNextHop(ControlParameters().setName("/hello").setCost(100), face2);
141   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
142   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
143   BOOST_CHECK_EQUAL(checkNextHop("/hello", 2, face2, 100), CheckNextHopResult::OK);
144 }
145 BOOST_AUTO_TEST_CASE(InitialAdd)
146 {
147   FaceId addedFaceId = addFace();
148   BOOST_REQUIRE_NE(addedFaceId, face::INVALID_FACEID);
149   auto parameters = makeParameters("hello", addedFaceId, 101);
150   auto req = makeControlCommandRequest("/localhost/nfd/fib/add-nexthop", parameters);
151   receiveInterest(req);
152   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
153   BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), makeResponse(200, "Success", parameters)),
154                     CheckResponseResult::OK);
155   BOOST_CHECK_EQUAL(checkNextHop("/hello", 1, addedFaceId, 101), CheckNextHopResult::OK);
156 }
157 BOOST_AUTO_TEST_CASE(ImplicitCost)
158 {
159   FaceId addedFaceId = addFace();
160   BOOST_REQUIRE_NE(addedFaceId, face::INVALID_FACEID);
161   auto originalParameters = ControlParameters().setName("/hello").setFaceId(addedFaceId);
162   auto parameters = makeParameters("/hello", addedFaceId, 0);
163   auto req = makeControlCommandRequest("/localhost/nfd/fib/add-nexthop", originalParameters);
164   receiveInterest(req);
165   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
166   BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), makeResponse(200, "Success", parameters)),
167                     CheckResponseResult::OK);
168   BOOST_CHECK_EQUAL(checkNextHop("/hello", 1, addedFaceId, 0), CheckNextHopResult::OK);
169 }
170 BOOST_AUTO_TEST_CASE(AddToExisting)
171 {
172   FaceId face = addFace();
173   BOOST_REQUIRE_NE(face, face::INVALID_FACEID);
174   Name expectedName;
175   ControlResponse expectedResponse;
176   auto testAddNextHop = [&amp;] (const ControlParameters&amp; parameters) {
177     m_responses.clear();
178     auto req = makeControlCommandRequest("/localhost/nfd/fib/add-nexthop", parameters);
179     expectedName = req.getName();
180     expectedResponse = makeResponse(200, "Success", parameters);
181     receiveInterest(req);
182   };
183   testAddNextHop(makeParameters("/hello", face, 101));
184   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
185   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
186   testAddNextHop(makeParameters("/hello", face, 102));
187   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
188   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
189   BOOST_CHECK_EQUAL(checkNextHop("/hello", 2, face, 102), CheckNextHopResult::WRONG_N_NEXTHOPS);
190   BOOST_CHECK_EQUAL(checkNextHop("/hello", 1, face, 101), CheckNextHopResult::WRONG_COST);
191   BOOST_CHECK_EQUAL(checkNextHop("/hello", 1, face, 102), CheckNextHopResult::OK);
192 }
193 BOOST_AUTO_TEST_SUITE_END() 
194 BOOST_AUTO_TEST_SUITE(RemoveNextHop)
195 BOOST_AUTO_TEST_CASE(Basic)
196 {
197   Name expectedName;
198   ControlResponse expectedResponse;
199   auto testRemoveNextHop = [&amp;] (const ControlParameters&amp; parameters) {
200     m_responses.clear();
201     auto req = makeControlCommandRequest("/localhost/nfd/fib/remove-nexthop", parameters);
202     expectedName = req.getName();
203     expectedResponse = makeResponse(200, "Success", parameters);
204     receiveInterest(req);
205   };
206   FaceId face1 = addFace();
207   FaceId face2 = addFace();
208   FaceId face3 = addFace();
209   BOOST_REQUIRE_NE(face1, face::INVALID_FACEID);
210   BOOST_REQUIRE_NE(face2, face::INVALID_FACEID);
211   BOOST_REQUIRE_NE(face3, face::INVALID_FACEID);
212   fib::Entry* entry = m_fib.insert("/hello").first;
213   m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face1), 101);
214   m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face2), 202);
215   m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face3), 303);
216   testRemoveNextHop(makeParameters("/hello", face1));
217   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
218   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
219   BOOST_CHECK_EQUAL(checkNextHop("/hello", 2, face1, 101), CheckNextHopResult::NO_NEXTHOP);
220   testRemoveNextHop(makeParameters("/hello", face2));
221   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
222   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
223   BOOST_CHECK_EQUAL(checkNextHop("/hello", 1, face2, 202), CheckNextHopResult::NO_NEXTHOP);
224   testRemoveNextHop(makeParameters("/hello", face3));
225   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
226   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
227   BOOST_CHECK_EQUAL(checkNextHop("/hello", 0, face3, 303), CheckNextHopResult::NO_FIB_ENTRY);
228 }
229 BOOST_AUTO_TEST_CASE(PrefixNotFound)
230 {
231   FaceId addedFaceId = addFace();
232   BOOST_REQUIRE_NE(addedFaceId, face::INVALID_FACEID);
233   auto parameters = makeParameters("hello", addedFaceId);
234   auto req = makeControlCommandRequest("/localhost/nfd/fib/remove-nexthop", parameters);
235   receiveInterest(req);
236   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
237   auto expectedResponse = makeResponse(200, "Success", parameters);
238   BOOST_CHECK_EQUAL(checkResponse(0, req.getName(), expectedResponse), CheckResponseResult::OK);
239 }
240 BOOST_AUTO_TEST_CASE(ImplicitFaceId)
241 {
242   auto face1 = addFace();
243   auto face2 = addFace();
244   BOOST_REQUIRE_NE(face1, face::INVALID_FACEID);
245   BOOST_REQUIRE_NE(face2, face::INVALID_FACEID);
246   Name expectedName;
247   ControlResponse expectedResponse;
248   auto testWithImplicitFaceId = [&amp;] (ControlParameters parameters, FaceId face) {
249     m_responses.clear();
250     auto req = makeControlCommandRequest("/localhost/nfd/fib/remove-nexthop", parameters);
251     req.setTag(make_shared&lt;lp::IncomingFaceIdTag&gt;(face));
252     expectedName = req.getName();
253     expectedResponse = makeResponse(200, "Success", parameters.setFaceId(face));
254     receiveInterest(req);
255   };
256   fib::Entry* entry = m_fib.insert("/hello").first;
257   m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face1), 101);
258   m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face2), 202);
259   testWithImplicitFaceId(ControlParameters().setName("/hello").setFaceId(0), face1);
260   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
261   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
262   BOOST_CHECK_EQUAL(checkNextHop("/hello", 1, face1, 101), CheckNextHopResult::NO_NEXTHOP);
263   testWithImplicitFaceId(ControlParameters().setName("/hello"), face2);
264   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);
265   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
266   BOOST_CHECK_EQUAL(checkNextHop("/hello", 0, face2, 202), CheckNextHopResult::NO_FIB_ENTRY);
267 }
268 BOOST_AUTO_TEST_CASE(RecordNotExist)
269 {
270   auto face1 = addFace();
271   auto face2 = addFace();
272   BOOST_REQUIRE_NE(face1, face::INVALID_FACEID);
273   BOOST_REQUIRE_NE(face2, face::INVALID_FACEID);
274   Name expectedName;
275   ControlResponse expectedResponse;
276   auto testRemoveNextHop = [&amp;] (ControlParameters parameters) {
277     m_responses.clear();
278     auto req = makeControlCommandRequest("/localhost/nfd/fib/remove-nexthop", parameters);
279     expectedName = req.getName();
280     expectedResponse = makeResponse(200, "Success", parameters);
281     receiveInterest(req);
282   };
283   fib::Entry* entry = m_fib.insert("/hello").first;
284   m_fib.addOrUpdateNextHop(*entry, *m_faceTable.get(face1), 101);
285   testRemoveNextHop(makeParameters("/hello", face2 + 100));
286   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
287   BOOST_CHECK_EQUAL(checkNextHop("/hello", nullopt, face2 + 100), CheckNextHopResult::NO_NEXTHOP);
288   testRemoveNextHop(makeParameters("/hello", face2));
289   BOOST_REQUIRE_EQUAL(m_responses.size(), 1);   BOOST_CHECK_EQUAL(checkResponse(0, expectedName, expectedResponse), CheckResponseResult::OK);
290   BOOST_CHECK_EQUAL(checkNextHop("/hello", nullopt, face2), CheckNextHopResult::NO_NEXTHOP);
291 }
292 BOOST_AUTO_TEST_SUITE_END() 
293 BOOST_AUTO_TEST_SUITE(List)
294 BOOST_AUTO_TEST_CASE(FibDataset)
295 {
296   const size_t nEntries = 108;
297   std::set&lt;Name&gt; actualPrefixes;
298   for (size_t i = 0 ; i &lt; nEntries ; i ++) {
299     Name prefix = Name("test").appendSegment(i);
300     actualPrefixes.insert(prefix);
301     fib::Entry* fibEntry = m_fib.insert(prefix).first;
302     m_fib.addOrUpdateNextHop(*fibEntry, *m_faceTable.get(addFace()), std::numeric_limits&lt;uint8_t&gt;::max() - 1);
303     m_fib.addOrUpdateNextHop(*fibEntry, *m_faceTable.get(addFace()), std::numeric_limits&lt;uint8_t&gt;::max() - 2);
304   }
305   receiveInterest(Interest("/localhost/nfd/fib/list").setCanBePrefix(true));
306   Block content = concatenateResponses();
307   content.parse();
308   BOOST_REQUIRE_EQUAL(content.elements().size(), nEntries);
309   std::vector&lt;ndn::nfd::FibEntry&gt; receivedRecords, expectedRecords;
310   for (size_t idx = 0; idx &lt; nEntries; ++idx) {
311     ndn::nfd::FibEntry decodedEntry(content.elements()[idx]);
312     receivedRecords.push_back(decodedEntry);
313     actualPrefixes.erase(decodedEntry.getPrefix());
314     auto matchedEntry = m_fib.findExactMatch(decodedEntry.getPrefix());
315     BOOST_REQUIRE(matchedEntry != nullptr);
316     expectedRecords.emplace_back();
317     expectedRecords.back().setPrefix(matchedEntry-&gt;getPrefix());
318     for (const auto&amp; nh : matchedEntry-&gt;getNextHops()) {
319       expectedRecords.back().addNextHopRecord(ndn::nfd::NextHopRecord()
320                                               .setFaceId(nh.getFace().getId())
321                                               .setCost(nh.getCost()));
322     }
323   }
324   BOOST_CHECK_EQUAL(actualPrefixes.size(), 0);
325   BOOST_CHECK_EQUAL_COLLECTIONS(receivedRecords.begin(), receivedRecords.end(),
326                                 expectedRecords.begin(), expectedRecords.end());
327 }
328 BOOST_AUTO_TEST_SUITE_END() 
329 BOOST_AUTO_TEST_SUITE_END() BOOST_AUTO_TEST_SUITE_END() 
} } </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rib-manager.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "rib-manager.hpp"
2 #include "common/global.hpp"
3 #include "common/logger.hpp"
4 #include "rib/rib.hpp"
5 #include "table/fib.hpp"
6 #include &lt;ndn-cxx/lp/tags.hpp&gt;
7 #include &lt;ndn-cxx/mgmt/nfd/face-status.hpp&gt;
8 #include &lt;ndn-cxx/mgmt/nfd/rib-entry.hpp&gt;
9 #include &lt;ndn-cxx/security/certificate-fetcher-direct-fetch.hpp&gt;
10 namespace nfd {
11 using rib::RibUpdate;
12 using rib::Route;
13 NFD_LOG_INIT(RibManager);
14 static const std::string MGMT_MODULE_NAME = "rib";
15 static const Name LOCALHOST_TOP_PREFIX = "/localhost/nfd";
16 static const time::seconds ACTIVE_FACE_FETCH_INTERVAL = 5_min;
17 const Name RibManager::LOCALHOP_TOP_PREFIX = "/localhop/nfd";
18 RibManager::RibManager(rib::Rib&amp; rib, ndn::Face&amp; face, ndn::KeyChain&amp; keyChain,
19                        ndn::nfd::Controller&amp; nfdController, Dispatcher&amp; dispatcher)
20   : ManagerBase(MGMT_MODULE_NAME, dispatcher)
21   , m_rib(rib)
22   , m_keyChain(keyChain)
23   , m_nfdController(nfdController)
24   , m_dispatcher(dispatcher)
25   , m_faceMonitor(face)
26   , m_localhostValidator(face)
27   , m_localhopValidator(make_unique&lt;ndn::security::CertificateFetcherDirectFetch&gt;(face))
28   , m_paValidator(make_unique&lt;ndn::security::CertificateFetcherDirectFetch&gt;(face))
29   , m_isLocalhopEnabled(false)
30 {
31   registerCommandHandler&lt;ndn::nfd::RibRegisterCommand&gt;("register",
32     std::bind(&amp;RibManager::registerEntry, this, _2, _3, _4, _5));
33   registerCommandHandler&lt;ndn::nfd::RibUnregisterCommand&gt;("unregister",
34     std::bind(&amp;RibManager::unregisterEntry, this, _2, _3, _4, _5));
35   registerStatusDatasetHandler("list", std::bind(&amp;RibManager::listEntries, this, _1, _2, _3));
36 }
37 void
38 RibManager::applyLocalhostConfig(const ConfigSection&amp; section, const std::string&amp; filename)
39 {
40   m_localhostValidator.load(section, filename);
41 }
42 void
43 RibManager::enableLocalhop(const ConfigSection&amp; section, const std::string&amp; filename)
44 {
45   m_localhopValidator.load(section, filename);
46   m_isLocalhopEnabled = true;
47 }
48 void
49 RibManager::disableLocalhop()
50 {
51   m_isLocalhopEnabled = false;
52 }
53 void
54 RibManager::applyPaConfig(const ConfigSection&amp; section, const std::string&amp; filename)
55 {
56   m_paValidator.load(section, filename);
57 }
58 void
59 RibManager::registerWithNfd()
60 {
61   registerTopPrefix(LOCALHOST_TOP_PREFIX);
62   if (m_isLocalhopEnabled) {
63     registerTopPrefix(LOCALHOP_TOP_PREFIX);
64   }
65   NFD_LOG_INFO("Start monitoring face create/destroy events");
66   m_faceMonitor.onNotification.connect([this] (const auto&amp; notif) { onNotification(notif); });
67   m_faceMonitor.start();
68   scheduleActiveFaceFetch(ACTIVE_FACE_FETCH_INTERVAL);
69 }
70 void
71 RibManager::enableLocalFields()
72 {
73   m_nfdController.start&lt;ndn::nfd::FaceUpdateCommand&gt;(
74     ControlParameters().setFlagBit(ndn::nfd::BIT_LOCAL_FIELDS_ENABLED, true),
75     [] (const ControlParameters&amp;) {
76       NFD_LOG_DEBUG("Local fields enabled");
77     },
78     [] (const ControlResponse&amp; res) {
79       NDN_THROW(Error("Couldn't enable local fields (" + to_string(res.getCode()) +
80                       " " + res.getText() + ")"));
81     });
82 }
83 void
84 RibManager::beginAddRoute(const Name&amp; name, Route route, optional&lt;time::nanoseconds&gt; expires,
85                           const std::function&lt;void(RibUpdateResult)&gt;&amp; done)
86 {
87   if (expires) {
88     route.expires = time::steady_clock::now() + *expires;
89   }
90   else if (route.expires) {
91     expires = *route.expires - time::steady_clock::now();
92   }
93   if (expires &amp;&amp; *expires &lt;= 0_s) {
94     m_rib.onRouteExpiration(name, route);
95     return done(RibUpdateResult::EXPIRED);
96   }
97   NFD_LOG_INFO("Adding route " &lt;&lt; name &lt;&lt; " nexthop=" &lt;&lt; route.faceId &lt;&lt;
98                " origin=" &lt;&lt; route.origin &lt;&lt; " cost=" &lt;&lt; route.cost);
99   if (expires) {
100     auto event = getScheduler().schedule(*expires, [=] { m_rib.onRouteExpiration(name, route); });
101     route.setExpirationEvent(event);
102     NFD_LOG_TRACE("Scheduled unregistration at: " &lt;&lt; *route.expires);
103   }
104   RibUpdate update;
105   update.setAction(RibUpdate::REGISTER)
106         .setName(name)
107         .setRoute(route);
108   beginRibUpdate(update, done);
109 }
110 void
111 RibManager::beginRemoveRoute(const Name&amp; name, const Route&amp; route,
112                              const std::function&lt;void(RibUpdateResult)&gt;&amp; done)
113 {
114   NFD_LOG_INFO("Removing route " &lt;&lt; name &lt;&lt; " nexthop=" &lt;&lt; route.faceId &lt;&lt;
115                " origin=" &lt;&lt; route.origin);
116   RibUpdate update;
117   update.setAction(RibUpdate::UNREGISTER)
118         .setName(name)
119         .setRoute(route);
120   beginRibUpdate(update, done);
121 }
122 void
123 RibManager::beginRibUpdate(const RibUpdate&amp; update,
124                            const std::function&lt;void(RibUpdateResult)&gt;&amp; done)
125 {
126   m_rib.beginApplyUpdate(update,
127     [=] {
128       NFD_LOG_DEBUG("RIB update succeeded for " &lt;&lt; update);
129       done(RibUpdateResult::OK);
130     },
131     [=] (uint32_t code, const std::string&amp; error) {
132       NFD_LOG_DEBUG("RIB update failed for " &lt;&lt; update &lt;&lt; " (" &lt;&lt; code &lt;&lt; " " &lt;&lt; error &lt;&lt; ")");
133       scheduleActiveFaceFetch(1_s);
134       done(RibUpdateResult::ERROR);
135     });
136 }
137 void
138 RibManager::registerTopPrefix(const Name&amp; topPrefix)
139 {
140   m_nfdController.start&lt;ndn::nfd::FibAddNextHopCommand&gt;(
141     ControlParameters().setName(Name(topPrefix).append(MGMT_MODULE_NAME))
142                        .setFaceId(0),
143     [=] (const ControlParameters&amp; res) {
144       NFD_LOG_DEBUG("Successfully registered " &lt;&lt; topPrefix &lt;&lt; " with NFD");
145       Route route;
146       route.faceId = res.getFaceId();
147       route.origin = ndn::nfd::ROUTE_ORIGIN_APP;
148       route.flags = ndn::nfd::ROUTE_FLAG_CHILD_INHERIT;
149       m_rib.insert(topPrefix, route);
150     },
151     [=] (const ControlResponse&amp; res) {
152       NDN_THROW(Error("Cannot add FIB entry " + topPrefix.toUri() + " (" +
153                       to_string(res.getCode()) + " " + res.getText() + ")"));
154     });
155   m_dispatcher.addTopPrefix(topPrefix, false);
156 }
157 void
158 RibManager::registerEntry(const Name&amp; topPrefix, const Interest&amp; interest,
159                           ControlParameters parameters,
160                           const ndn::mgmt::CommandContinuation&amp; done)
161 {
162   if (parameters.getName().size() &gt; Fib::getMaxDepth()) {
163     done(ControlResponse(414, "Route prefix cannot exceed " + to_string(Fib::getMaxDepth()) +
164                               " components"));
165     return;
166   }
167   setFaceForSelfRegistration(interest, parameters);
168   done(ControlResponse(200, "Success").setBody(parameters.wireEncode()));
169   Route route;
170   route.faceId = parameters.getFaceId();
171   route.origin = parameters.getOrigin();
172   route.cost = parameters.getCost();
173   route.flags = parameters.getFlags();
174   optional&lt;time::nanoseconds&gt; expires;
175   if (parameters.hasExpirationPeriod() &amp;&amp;
176       parameters.getExpirationPeriod() != time::milliseconds::max()) {
177     expires = time::duration_cast&lt;time::nanoseconds&gt;(parameters.getExpirationPeriod());
178   }
179   beginAddRoute(parameters.getName(), std::move(route), expires, [] (RibUpdateResult) {});
180 }
181 void
182 RibManager::unregisterEntry(const Name&amp;, const Interest&amp; interest,
183                             ControlParameters parameters,
184                             const ndn::mgmt::CommandContinuation&amp; done)
185 {
186   setFaceForSelfRegistration(interest, parameters);
187   done(ControlResponse(200, "Success").setBody(parameters.wireEncode()));
188   Route route;
189   route.faceId = parameters.getFaceId();
190   route.origin = parameters.getOrigin();
191   beginRemoveRoute(parameters.getName(), route, [] (RibUpdateResult) {});
192 }
193 void
194 RibManager::listEntries(const Name&amp;, const Interest&amp; interest,
195                         ndn::mgmt::StatusDatasetContext&amp; context)
196 {
197   auto now = time::steady_clock::now();
198   for (const auto&amp; kv : m_rib) {
199     const rib::RibEntry&amp; entry = *kv.second;
200     ndn::nfd::RibEntry item;
201     item.setName(entry.getName());
202     for (const Route&amp; route : entry.getRoutes()) {
203       ndn::nfd::Route r;
204       r.setFaceId(route.faceId);
205       r.setOrigin(route.origin);
206       r.setCost(route.cost);
207       r.setFlags(route.flags);
208       if (route.expires) {
209         r.setExpirationPeriod(time::duration_cast&lt;time::milliseconds&gt;(*route.expires - now));
210       }
211       item.addRoute(r);
212     }
213     context.append(item.wireEncode());
214   }
215   context.end();
216 }
217 void
218 RibManager::setFaceForSelfRegistration(const Interest&amp; request, ControlParameters&amp; parameters)
219 {
220   bool isSelfRegistration = (parameters.getFaceId() == 0);
221   if (isSelfRegistration) {
222     shared_ptr&lt;lp::IncomingFaceIdTag&gt; incomingFaceIdTag = request.getTag&lt;lp::IncomingFaceIdTag&gt;();
223     BOOST_ASSERT(incomingFaceIdTag != nullptr);
224     parameters.setFaceId(*incomingFaceIdTag);
225   }
226 }
227 ndn::mgmt::Authorization
228 RibManager::makeAuthorization(const std::string&amp;)
229 {
230   return [this] (const Name&amp; prefix, const Interest&amp; interest,
231                  const ndn::mgmt::ControlParameters* params,
232                  const ndn::mgmt::AcceptContinuation&amp; accept,
233                  const ndn::mgmt::RejectContinuation&amp; reject) {
234     BOOST_ASSERT(params != nullptr);
235     BOOST_ASSERT(typeid(*params) == typeid(ndn::nfd::ControlParameters));
236     BOOST_ASSERT(prefix == LOCALHOST_TOP_PREFIX || prefix == LOCALHOP_TOP_PREFIX);
237     auto&amp; validator = prefix == LOCALHOST_TOP_PREFIX ? m_localhostValidator : m_localhopValidator;
238     validator.validate(interest,
239 <a name="0"></a>                       [&amp;interest, accept] (auto&amp;&amp;...) { extractRequester(interest, accept); },
240                        [reject] (auto&amp;&amp;...) { reject(ndn::mgmt::RejectReply::STATUS403); });
241   };
242 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
243 std::ostream&amp;
244 operator&lt;&lt;(std::ostream&amp; os, RibManager::SlAnnounceResult res)
245 {
246   switch (res) {
247   case RibManager::SlAnnounceResult::OK:
248     return os &lt;&lt; "OK";
249   case RibManager::SlAnnounceResult::ERROR:
250     return os &lt;&lt; "ERROR";
251   case RibManager::SlAnnounceResult::VALIDATION_FAILURE:
252     return os &lt;&lt; "VALIDATION_FAILURE";
253   case RibManager::SlAnnounceResult::EXPIRED:
254     return os &lt;&lt; "EXPIRED";
255   case RibManager::SlAnnounceResult::NOT_FOUND:
256     return os &lt;&lt; "NOT_FOUND";
257   }</b></font>
258   NDN_THROW(std::invalid_argument("Unknown SlAnnounceResult"));
259 }
260 RibManager::SlAnnounceResult
261 RibManager::getSlAnnounceResultFromRibUpdateResult(RibUpdateResult r)
262 {
263   switch (r) {
264   case RibUpdateResult::OK:
265     return SlAnnounceResult::OK;
266   case RibUpdateResult::ERROR:
267     return SlAnnounceResult::ERROR;
268   case RibUpdateResult::EXPIRED:
269     return SlAnnounceResult::EXPIRED;
270   }
271   NDN_CXX_UNREACHABLE;
272 }
273 void
274 RibManager::slAnnounce(const ndn::PrefixAnnouncement&amp; pa, uint64_t faceId,
275                        time::milliseconds maxLifetime, const SlAnnounceCallback&amp; cb)
276 {
277   BOOST_ASSERT(pa.getData());
278   m_paValidator.validate(*pa.getData(),
279     [=] (const Data&amp;) {
280       Route route(pa, faceId);
281       route.expires = std::min(route.annExpires, time::steady_clock::now() + maxLifetime);
282       beginAddRoute(pa.getAnnouncedName(), route, nullopt,
283         [=] (RibUpdateResult ribRes) {
284           auto res = getSlAnnounceResultFromRibUpdateResult(ribRes);
285           NFD_LOG_INFO("slAnnounce " &lt;&lt; pa.getAnnouncedName() &lt;&lt; " " &lt;&lt; faceId &lt;&lt; ": " &lt;&lt; res);
286           cb(res);
287         });
288     },
289     [=] (const Data&amp;, ndn::security::ValidationError err) {
290       NFD_LOG_INFO("slAnnounce " &lt;&lt; pa.getAnnouncedName() &lt;&lt; " " &lt;&lt; faceId &lt;&lt;
291                    " validation error: " &lt;&lt; err);
292       cb(SlAnnounceResult::VALIDATION_FAILURE);
293     }
294   );
295 }
296 void
297 RibManager::slRenew(const Name&amp; name, uint64_t faceId, time::milliseconds maxLifetime,
298                     const SlAnnounceCallback&amp; cb)
299 {
300   Route routeQuery;
301   routeQuery.faceId = faceId;
302   routeQuery.origin = ndn::nfd::ROUTE_ORIGIN_PREFIXANN;
303   Route* oldRoute = m_rib.findLongestPrefix(name, routeQuery);
304   if (oldRoute == nullptr || !oldRoute-&gt;announcement) {
305     NFD_LOG_DEBUG("slRenew " &lt;&lt; name &lt;&lt; " " &lt;&lt; faceId &lt;&lt; ": not found");
306     return cb(SlAnnounceResult::NOT_FOUND);
307   }
308   Name routeName = oldRoute-&gt;announcement-&gt;getAnnouncedName();
309   Route route = *oldRoute;
310   route.expires = std::min(route.annExpires, time::steady_clock::now() + maxLifetime);
311   beginAddRoute(routeName, route, nullopt,
312     [=] (RibUpdateResult ribRes) {
313       auto res = getSlAnnounceResultFromRibUpdateResult(ribRes);
314       NFD_LOG_INFO("slRenew " &lt;&lt; name &lt;&lt; " " &lt;&lt; faceId &lt;&lt; ": " &lt;&lt; res &lt;&lt; " " &lt;&lt; routeName);
315       cb(res);
316     });
317 }
318 void
319 RibManager::slFindAnn(const Name&amp; name, const SlFindAnnCallback&amp; cb) const
320 {
321   shared_ptr&lt;rib::RibEntry&gt; entry;
322   auto exactMatch = m_rib.find(name);
323   if (exactMatch != m_rib.end()) {
324     entry = exactMatch-&gt;second;
325   }
326   else {
327     entry = m_rib.findParent(name);
328   }
329   if (entry == nullptr) {
330     return cb(nullopt);
331   }
332   auto pa = entry-&gt;getPrefixAnnouncement();
333   pa.toData(m_keyChain);
334   cb(pa);
335 }
336 void
337 RibManager::fetchActiveFaces()
338 {
339   NFD_LOG_DEBUG("Fetching active faces");
340   m_nfdController.fetch&lt;ndn::nfd::FaceDataset&gt;(
341     std::bind(&amp;RibManager::removeInvalidFaces, this, _1),
342     std::bind(&amp;RibManager::onFetchActiveFacesFailure, this, _1, _2),
343     ndn::nfd::CommandOptions());
344 }
345 void
346 RibManager::onFetchActiveFacesFailure(uint32_t code, const std::string&amp; reason)
347 {
348   NFD_LOG_DEBUG("Face Status Dataset request failure " &lt;&lt; code &lt;&lt; " " &lt;&lt; reason);
349   scheduleActiveFaceFetch(ACTIVE_FACE_FETCH_INTERVAL);
350 }
351 void
352 RibManager::scheduleActiveFaceFetch(const time::seconds&amp; timeToWait)
353 {
354   m_activeFaceFetchEvent = getScheduler().schedule(timeToWait, [this] { fetchActiveFaces(); });
355 }
356 void
357 RibManager::removeInvalidFaces(const std::vector&lt;ndn::nfd::FaceStatus&gt;&amp; activeFaces)
358 {
359   NFD_LOG_DEBUG("Checking for invalid face registrations");
360   std::set&lt;uint64_t&gt; activeFaceIds;
361   for (const auto&amp; faceStatus : activeFaces) {
362     activeFaceIds.insert(faceStatus.getFaceId());
363   }
364   getGlobalIoService().post([=] { m_rib.beginRemoveFailedFaces(activeFaceIds); });
365   scheduleActiveFaceFetch(ACTIVE_FACE_FETCH_INTERVAL);
366 }
367 void
368 RibManager::onNotification(const ndn::nfd::FaceEventNotification&amp; notification)
369 {
370   NFD_LOG_TRACE("onNotification: " &lt;&lt; notification);
371   if (notification.getKind() == ndn::nfd::FACE_EVENT_DESTROYED) {
372     NFD_LOG_DEBUG("Received notification for destroyed FaceId " &lt;&lt; notification.getFaceId());
373     getGlobalIoService().post([this, id = notification.getFaceId()] { m_rib.beginRemoveFace(id); });
374   }
375 }
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
