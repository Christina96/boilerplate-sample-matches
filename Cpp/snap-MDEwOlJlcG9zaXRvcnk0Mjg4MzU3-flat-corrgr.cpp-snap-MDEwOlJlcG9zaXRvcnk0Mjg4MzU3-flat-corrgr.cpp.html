
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-corrgr.cpp</h3>
            <pre><code>1  #include "corrgr.h"
2  void TCorrGroups::GetCorrSimVV(TFltVV& SimVV) const {
3    int Vars=GetVars();
4    SimVV.Gen(Vars, Vars);
5    for (int VarN1=0; VarN1<Vars; VarN1++){
6      TStr MsgStr=TStr("Var:")+TInt::GetStr(VarN1+1)+"/"+TInt::GetStr(Vars)+"\r";
7      TNotify::OnStatus(Notify, MsgStr);
8      SimVV.At(VarN1, VarN1)=1;
9      for (int VarN2=VarN1+1; VarN2<Vars; VarN2++){
10        PCorr Corr=TCorr::New(VarValVV[VarN1], VarValVV[VarN2]);
11        SimVV.At(VarN1, VarN2)=fabs(Corr->GetCorrCf());
12        SimVV.At(VarN2, VarN1)=fabs(Corr->GetCorrCf());
13      }
14    }
15    TNotify::OnStatus(Notify, "\n");
16  }
17  void TCorrGroups::GetEuclSimVV(TFltVV& SimVV) const {
18    int Vars=GetVars();
19    SimVV.Gen(Vars, Vars);
20    for (int VarN1=0; VarN1<Vars; VarN1++){
21      TStr MsgStr=TStr("Var:")+TInt::GetStr(VarN1+1)+"/"+TInt::GetStr(Vars)+"\r";
22      TNotify::OnStatus(Notify, MsgStr);
23      SimVV.At(VarN1, VarN1)=1;
24      for (int VarN2=VarN1+1; VarN2<Vars; VarN2++){
25        double Sim=0;
26        for (int ValN=0; ValN<VarValVV[VarN1].Len(); ValN++){
27          double ValSim=VarValVV[VarN1][ValN]-VarValVV[VarN2][ValN];
28          Sim+=TMath::Sqr(ValSim);
29        }
30        Sim=-sqrt(Sim);
31        SimVV.At(VarN1, VarN2)=Sim;
32        SimVV.At(VarN2, VarN1)=Sim;
33      }
34    }
35    TNotify::OnStatus(Notify, "\n");
36  }
37  void TCorrGroups::GetSimVVFromData(TFltVV& SimVV) const {
38    IAssert(VarValVV[0].Len()==VarValVV.Len());
39    SimVV.Gen(VarValVV.Len(), VarValVV.Len());
40    for (int Y=0; Y<VarValVV.Len(); Y++){
41      for (int X=0; X<VarValVV.Len(); X++){
42        SimVV.At(Y, X)=VarValVV[Y][X];
43      }
44    }
45  }
46  void TCorrGroups::SetGroups(const double& _CorrCfTsh){
47    TNotify::OnNotify(Notify, ntInfo,
48     "Calculating Correlation Groups for Threshold "+TFlt::GetStr(CorrCfTsh));
49    CorrCfTsh=_CorrCfTsh;
50    int Vars=GetVars();
51    TFltVV CorrCfVV; GetCorrSimVV(CorrCfVV);
52    PGraph Graph=TGGraph::New();
53    for (int VarN=0; VarN<Vars; VarN++){
54      TStr VarNm=TInt::GetStr(VarN);
55      PVrtx Vrtx=PVrtx(new TGVrtx(VarNm));
56      Graph->AddVrtx(Vrtx);
57    }
58    int GoodCorrs=0;
59    for (int VarN1=0; VarN1<Vars; VarN1++){
60      for (int VarN2=VarN1; VarN2<Vars; VarN2++){
61        if ((VarN1!=VarN2)&&(fabs(CorrCfVV.At(VarN1, VarN2))>CorrCfTsh)){
62          GoodCorrs++;
63          TStr MsgStr=TStr("Good Correlations:")+TInt::GetStr(GoodCorrs)+"\r";
64          TNotify::OnStatus(Notify, MsgStr);
65          TStr VrtxNm1=TInt::GetStr(VarN1);
66          TStr VrtxNm2=TInt::GetStr(VarN2);
67          TStr ENm=TFlt::GetStr(CorrCfVV.At(VarN1, VarN2), "%0.2f");
68          PVrtx Vrtx1=Graph->GetVrtx(VrtxNm1);
69          PVrtx Vrtx2=Graph->GetVrtx(VrtxNm2);
70          PEdge Edge=PEdge(new TGEdge(Vrtx1, Vrtx2, ENm, false));
71          Graph->AddEdge(Edge);
72        }
73      }
74    }
75    TNotify::OnStatus(Notify, "\n");
76    VarNVV.Clr();
77    TBoolV VarUsedV(Vars);
78    {for (int VarN=0; VarN<Vars; VarN++){
79      if (!VarUsedV[VarN]){
80        VarUsedV[VarN]=true;
81        VarNVV.Add();
82        TStr VrtxNm=TInt::GetStr(VarN);
83        PVrtx Vrtx=Graph->GetVrtx(VrtxNm);
84        TVrtxV ConnVrtxV;
85        Graph->GetConnVrtxV(Vrtx, ConnVrtxV);
86        for (int ConnVrtxN=0; ConnVrtxN<ConnVrtxV.Len(); ConnVrtxN++){
87          PVrtx ConnVrtx=ConnVrtxV[ConnVrtxN];
88          TStr ConnVrtxVNm=ConnVrtx->GetVNm();
89          int ConnVarN=ConnVrtxVNm.GetInt();
90          VarNVV.Last().Add(ConnVarN);
91          VarUsedV[ConnVrtx->GetVId()]=true;
92        }
93      }
94    }}
95    TNotify::OnNotify(Notify, ntInfo, "... Done.");
96  }
97  void TCorrGroups::GetGroupCentroid(const TIntV& VarNV, TMomV& VarValMomV) const {
98    int Recs=GetRecs();
99    TMom::NewV(VarValMomV, Recs);
100    for (int VarNN=0; VarNN<VarNV.Len(); VarNN++){
101      int VarN=VarNV[VarNN];
102      for (int RecN=0; RecN<Recs; RecN++){
103        double Val=VarValVV[VarN][RecN];
104        VarValMomV[RecN]->Add(Val);
105      }
106    }
107    TMom::DefV(VarValMomV);
108  }
109  PGraph TCorrGroups::GetHClustGraph(const TFltVV& SimVV) const {
110    PGraph HClustGraph=TGGraph::New();
111    TVrtxV VrtxV(GetVars()); TVec<TIntV> VarNVV(GetVars());
112    for (int VarN=0; VarN<GetVars(); VarN++){
113      PVrtx Vrtx=PVrtx(new TGVrtx(VarN, GetVarNm(VarN)));
114      HClustGraph->AddVrtx(Vrtx);
115      VrtxV[VarN]=Vrtx; VarNVV[VarN].Add(VarN);
116    }
117    for (int HClustJoinN=0; HClustJoinN<GetVars()-1; HClustJoinN++){
118      printf("Join %d\r", HClustJoinN);
119      bool FirstMx=true; double MxMeanSim=0; int MxVrtxN1=-1; int MxVrtxN2=-1;
120      for (int VrtxN1=0; VrtxN1<VrtxV.Len(); VrtxN1++){
121        PVrtx Vrtx1=VrtxV[VrtxN1];
122        if (!Vrtx1.Empty()){
123          for (int VrtxN2=VrtxN1+1; VrtxN2<VrtxV.Len(); VrtxN2++){
124            PVrtx Vrtx2=VrtxV[VrtxN2];
125            if (!Vrtx2.Empty()){
126              TIntV& VarNV1=VarNVV[VrtxN1];
127              TIntV& VarNV2=VarNVV[VrtxN2];
128              double SumSim=0;
129              for (int VarNN1=0; VarNN1<VarNV1.Len(); VarNN1++){
130                for (int VarNN2=0; VarNN2<VarNV2.Len(); VarNN2++){
131                  SumSim+=SimVV.At(VarNV1[VarNN1], VarNV2[VarNN2]);
132                }
133              }
134              double MeanSim=SumSim/(VarNV1.Len()*VarNV2.Len());
135              if ((FirstMx)||(MeanSim>MxMeanSim)){
136                FirstMx=false;
137                MxMeanSim=MeanSim; MxVrtxN1=VrtxN1; MxVrtxN2=VrtxN2;
138              }
139            }
140          }
141        }
142      }
143      PVrtx JoinVrtx=PVrtx(new TGVrtx()); HClustGraph->AddVrtx(JoinVrtx);
144      PEdge JoinEdge1=PEdge(new TGEdge(JoinVrtx, VrtxV[MxVrtxN1]));
145      PEdge JoinEdge2=PEdge(new TGEdge(JoinVrtx, VrtxV[MxVrtxN2]));
146      HClustGraph->AddEdge(JoinEdge1); HClustGraph->AddEdge(JoinEdge2);
147      JoinVrtx->PutWgt(MxMeanSim);
148      VrtxV[MxVrtxN1]=JoinVrtx; VrtxV[MxVrtxN2]=NULL;
149      VarNVV[MxVrtxN1].AddV(VarNVV[MxVrtxN2]); VarNVV[MxVrtxN2].Clr();
150    }
151    return HClustGraph;
152  }
153  PGraph TCorrGroups::GetHClustGraph() const {
154    TFltVV SimVV; GetCorrSimVV(SimVV);
155    return GetHClustGraph(SimVV);
156  }
157  void TCorrGroups::SetHClustGroups(const TFltVV& SimVV, const int& Groups){
158    int Vars=GetVars();
159    IAssert((0<Groups)&&(Groups<=Vars));
160    VarNVV.Gen(Vars);
161    for (int VarN=0; VarN<Vars; VarN++){VarNVV[VarN].Add(VarN);}
162    for (int HClustJoinN=0; HClustJoinN<Vars-Groups; HClustJoinN++){
163      printf("Join %d\r", HClustJoinN);
164      bool FirstMx=true; double MxMeanSim=0; int MxVarNVN1=-1; int MxVarNVN2=-1;
165      for (int VarNVN1=0; VarNVN1<VarNVV.Len(); VarNVN1++){
166        for (int VarNVN2=VarNVN1+1; VarNVN2<VarNVV.Len(); VarNVN2++){
167          TIntV& VarNV1=VarNVV[VarNVN1];
168          TIntV& VarNV2=VarNVV[VarNVN2];
169          double SumSim=0;
170          for (int VarNN1=0; VarNN1<VarNV1.Len(); VarNN1++){
171            for (int VarNN2=0; VarNN2<VarNV2.Len(); VarNN2++){
172              SumSim+=SimVV.At(VarNV1[VarNN1], VarNV2[VarNN2]);
173            }
174          }
175          double MeanSim=SumSim/(VarNV1.Len()*VarNV2.Len());
176          if ((FirstMx)||(MeanSim>MxMeanSim)){
177            FirstMx=false;
178            MxMeanSim=MeanSim; MxVarNVN1=VarNVN1; MxVarNVN2=VarNVN2;
179          }
180        }
181      }
182      VarNVV[MxVarNVN1].AddV(VarNVV[MxVarNVN2]);
183      VarNVV.Del(MxVarNVN2);
184    }
185  }
186  void TCorrGroups::SetKMeansGroups(const int& Groups, const int& Trials){
187    TRnd Rnd(1); int Vars=GetVars(); int Recs=GetRecs();
188    IAssert((0<Groups)&&(Groups<=Vars));
189    double BestQual=0; TVec<TIntV> BestVarNVV;
190    for (int TrialN=0; TrialN<Trials; TrialN++){
191      printf("Trial: %d\n", TrialN);
192      TVec<TFltV> CentrVarNV(Groups);
193      for (int CentrN=0; CentrN<Groups; CentrN++){
194        int CentrVarN=Rnd.GetUniDevInt(Vars);
195        CentrVarNV[CentrN]=VarValVV[CentrVarN];
196      }
197      double PrevQual=0; double Qual=0;
198      do {
199        PrevQual=Qual;
200        VarNVV.Gen(Groups);
201        for (int VarN=0; VarN<Vars; VarN++){
202          TFltV SimV(Groups);
203          for (int CentrN=0; CentrN<Groups; CentrN++){
<span onclick='openModal()' class='match'>204            PCorr Corr=TCorr::New(CentrVarNV[CentrN], VarValVV[VarN]);
205            SimV[CentrN]=fabs(Corr->GetCorrCf());
</span>206          }
207          int BestGroupN=SimV.GetMxValN();
208          VarNVV[BestGroupN].Add(VarN);
209        }
210        for (int CentrN=0; CentrN<Groups; CentrN++){
211          TMomV VarValMomV; GetGroupCentroid(VarNVV[CentrN], VarValMomV);
212          for (int RecN=0; RecN<Recs; RecN++){
213            if (VarValMomV[RecN]->IsUsable()){
214              CentrVarNV[CentrN][RecN]=VarValMomV[RecN]->GetMedian();
215            } else {
216              CentrVarNV[CentrN][RecN]=0;
217            }
218          }
219        }
220        Qual=0;
221        for (int GroupN=0; GroupN<Groups; GroupN++){
222          int GroupVars=VarNVV[GroupN].Len();
223          for (int VarNN=0; VarNN<GroupVars; VarNN++){
224            int VarN=VarNVV[GroupN][VarNN];
225            PCorr Corr=TCorr::New(CentrVarNV[GroupN], VarValVV[VarN]);
226            double Sim=fabs(Corr->GetCorrCf());
227            Qual+=TMath::Sqr(Sim);
228          }
229        }
230        if ((PrevQual==0)||(Qual<BestQual)){
231          BestQual=Qual; BestVarNVV=VarNVV;
232        }
233        if (PrevQual!=0){
234          printf("   %g (%g)\n", Qual, PrevQual/Qual);}
235      } while ((PrevQual==0)||(PrevQual/Qual<0.9999));
236    }
237    VarNVV=BestVarNVV;
238  }
239  PCorrGroups TCorrGroups::LoadTxtVarCVal(const TStr& FNm){
240    TStrV VarNmV; 
241    TStrV RecNmV; 
242    TVec<TFltV> VarValVV; 
243    TILx Lx(TFIn::New(FNm), TFSet(iloRetEoln, iloSigNum));
244    Lx.GetSym(syInt, syEof); int RecN=0;
245    while (Lx.Sym!=syEof){
246      RecN++; TStr RecNm=TInt::GetStr(RecN);
247      RecNmV.Add(RecNm);
248      int PrevVarN=-1; TStrV CurVarNmV; TFltV VarValV(VarNmV.Len(), 0);
249      while (Lx.Sym!=syEoln){
250        IAssert((PrevVarN==-1)||(PrevVarN+1==Lx.Int));
251        PrevVarN=Lx.Int;
252        TStr VarNm=TInt::GetStr(Lx.Int);
253        CurVarNmV.Add(VarNm);
254        Lx.GetSym(syColon);
255        double VarVal=Lx.GetFlt();
256        VarValV.Add(VarVal);
257        Lx.GetSym(syInt, syEoln);
258      }
259      if (VarNmV.Empty()){VarNmV=CurVarNmV;}
260      else {IAssert(VarNmV==CurVarNmV);}
261      VarValVV.Add(VarValV);
262      Lx.GetSym(syInt, syEof);
263    }
264    PCorrGroups CorrGroups=New(VarNmV, RecNmV, VarValVV, TNotify::StdNotify);
265    return CorrGroups;
266  }
267  void TCorrGroups::SaveTxt(
268   const PSOut& SOut, const bool& CentrP, const bool& SqrtValP) const {
269    SOut->PutStr("==============================="); SOut->PutLn();
270    for (int GroupN=0; GroupN<VarNVV.Len(); GroupN++){
271      SOut->PutStr("Group"); SOut->PutInt(GroupN);
272      SOut->PutInt(VarNVV[GroupN].Len(), "(%d)");
273      SOut->PutStr(":"); SOut->PutLn();
274      for (int VarNN=0; VarNN<VarNVV[GroupN].Len(); VarNN++){
275        int VarN=VarNVV[GroupN][VarNN];
276        SOut->PutStr("   ");
277        SOut->PutStr(GetVarNm(VarN));
278        SOut->PutLn();
279      }
280      VarNVV[GroupN].Sort();
281      if (CentrP){
282        TIntV VarNV; GetGroup(GroupN, VarNV);
283        TMomV VarValMomV; GetGroupCentroid(VarNV, VarValMomV);
284        SOut->PutStr("Centroid:\n");
285        for (int RecN=0; RecN<GetRecs(); RecN++){
286          SOut->PutStr("  ");
287          SOut->PutStr(GetRecNm(RecN));
288          SOut->PutStr(":");
289          if (!VarValMomV[RecN]->IsUsable()){
290            SOut->PutStr("X");
291          } else {
292            if (SqrtValP){
293              SOut->PutFlt(sqrt(VarValMomV[RecN]->GetMean()), "%0.0f");
294            } else {
295              SOut->PutFlt(VarValMomV[RecN]->GetMean());
296            }
297          }
298          if ((RecN+1)%8==0){SOut->PutLn();}
299        }
300        SOut->PutLn();
301      }
302      SOut->PutLn();
303    }
304  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-corrgr.cpp</h3>
            <pre><code>1  #include "corrgr.h"
2  void TCorrGroups::GetCorrSimVV(TFltVV& SimVV) const {
3    int Vars=GetVars();
4    SimVV.Gen(Vars, Vars);
5    for (int VarN1=0; VarN1<Vars; VarN1++){
6      TStr MsgStr=TStr("Var:")+TInt::GetStr(VarN1+1)+"/"+TInt::GetStr(Vars)+"\r";
7      TNotify::OnStatus(Notify, MsgStr);
8      SimVV.At(VarN1, VarN1)=1;
9      for (int VarN2=VarN1+1; VarN2<Vars; VarN2++){
<span onclick='openModal()' class='match'>10        PCorr Corr=TCorr::New(VarValVV[VarN1], VarValVV[VarN2]);
11        SimVV.At(VarN1, VarN2)=fabs(Corr->GetCorrCf());
</span>12        SimVV.At(VarN2, VarN1)=fabs(Corr->GetCorrCf());
13      }
14    }
15    TNotify::OnStatus(Notify, "\n");
16  }
17  void TCorrGroups::GetEuclSimVV(TFltVV& SimVV) const {
18    int Vars=GetVars();
19    SimVV.Gen(Vars, Vars);
20    for (int VarN1=0; VarN1<Vars; VarN1++){
21      TStr MsgStr=TStr("Var:")+TInt::GetStr(VarN1+1)+"/"+TInt::GetStr(Vars)+"\r";
22      TNotify::OnStatus(Notify, MsgStr);
23      SimVV.At(VarN1, VarN1)=1;
24      for (int VarN2=VarN1+1; VarN2<Vars; VarN2++){
25        double Sim=0;
26        for (int ValN=0; ValN<VarValVV[VarN1].Len(); ValN++){
27          double ValSim=VarValVV[VarN1][ValN]-VarValVV[VarN2][ValN];
28          Sim+=TMath::Sqr(ValSim);
29        }
30        Sim=-sqrt(Sim);
31        SimVV.At(VarN1, VarN2)=Sim;
32        SimVV.At(VarN2, VarN1)=Sim;
33      }
34    }
35    TNotify::OnStatus(Notify, "\n");
36  }
37  void TCorrGroups::GetSimVVFromData(TFltVV& SimVV) const {
38    IAssert(VarValVV[0].Len()==VarValVV.Len());
39    SimVV.Gen(VarValVV.Len(), VarValVV.Len());
40    for (int Y=0; Y<VarValVV.Len(); Y++){
41      for (int X=0; X<VarValVV.Len(); X++){
42        SimVV.At(Y, X)=VarValVV[Y][X];
43      }
44    }
45  }
46  void TCorrGroups::SetGroups(const double& _CorrCfTsh){
47    TNotify::OnNotify(Notify, ntInfo,
48     "Calculating Correlation Groups for Threshold "+TFlt::GetStr(CorrCfTsh));
49    CorrCfTsh=_CorrCfTsh;
50    int Vars=GetVars();
51    TFltVV CorrCfVV; GetCorrSimVV(CorrCfVV);
52    PGraph Graph=TGGraph::New();
53    for (int VarN=0; VarN<Vars; VarN++){
54      TStr VarNm=TInt::GetStr(VarN);
55      PVrtx Vrtx=PVrtx(new TGVrtx(VarNm));
56      Graph->AddVrtx(Vrtx);
57    }
58    int GoodCorrs=0;
59    for (int VarN1=0; VarN1<Vars; VarN1++){
60      for (int VarN2=VarN1; VarN2<Vars; VarN2++){
61        if ((VarN1!=VarN2)&&(fabs(CorrCfVV.At(VarN1, VarN2))>CorrCfTsh)){
62          GoodCorrs++;
63          TStr MsgStr=TStr("Good Correlations:")+TInt::GetStr(GoodCorrs)+"\r";
64          TNotify::OnStatus(Notify, MsgStr);
65          TStr VrtxNm1=TInt::GetStr(VarN1);
66          TStr VrtxNm2=TInt::GetStr(VarN2);
67          TStr ENm=TFlt::GetStr(CorrCfVV.At(VarN1, VarN2), "%0.2f");
68          PVrtx Vrtx1=Graph->GetVrtx(VrtxNm1);
69          PVrtx Vrtx2=Graph->GetVrtx(VrtxNm2);
70          PEdge Edge=PEdge(new TGEdge(Vrtx1, Vrtx2, ENm, false));
71          Graph->AddEdge(Edge);
72        }
73      }
74    }
75    TNotify::OnStatus(Notify, "\n");
76    VarNVV.Clr();
77    TBoolV VarUsedV(Vars);
78    {for (int VarN=0; VarN<Vars; VarN++){
79      if (!VarUsedV[VarN]){
80        VarUsedV[VarN]=true;
81        VarNVV.Add();
82        TStr VrtxNm=TInt::GetStr(VarN);
83        PVrtx Vrtx=Graph->GetVrtx(VrtxNm);
84        TVrtxV ConnVrtxV;
85        Graph->GetConnVrtxV(Vrtx, ConnVrtxV);
86        for (int ConnVrtxN=0; ConnVrtxN<ConnVrtxV.Len(); ConnVrtxN++){
87          PVrtx ConnVrtx=ConnVrtxV[ConnVrtxN];
88          TStr ConnVrtxVNm=ConnVrtx->GetVNm();
89          int ConnVarN=ConnVrtxVNm.GetInt();
90          VarNVV.Last().Add(ConnVarN);
91          VarUsedV[ConnVrtx->GetVId()]=true;
92        }
93      }
94    }}
95    TNotify::OnNotify(Notify, ntInfo, "... Done.");
96  }
97  void TCorrGroups::GetGroupCentroid(const TIntV& VarNV, TMomV& VarValMomV) const {
98    int Recs=GetRecs();
99    TMom::NewV(VarValMomV, Recs);
100    for (int VarNN=0; VarNN<VarNV.Len(); VarNN++){
101      int VarN=VarNV[VarNN];
102      for (int RecN=0; RecN<Recs; RecN++){
103        double Val=VarValVV[VarN][RecN];
104        VarValMomV[RecN]->Add(Val);
105      }
106    }
107    TMom::DefV(VarValMomV);
108  }
109  PGraph TCorrGroups::GetHClustGraph(const TFltVV& SimVV) const {
110    PGraph HClustGraph=TGGraph::New();
111    TVrtxV VrtxV(GetVars()); TVec<TIntV> VarNVV(GetVars());
112    for (int VarN=0; VarN<GetVars(); VarN++){
113      PVrtx Vrtx=PVrtx(new TGVrtx(VarN, GetVarNm(VarN)));
114      HClustGraph->AddVrtx(Vrtx);
115      VrtxV[VarN]=Vrtx; VarNVV[VarN].Add(VarN);
116    }
117    for (int HClustJoinN=0; HClustJoinN<GetVars()-1; HClustJoinN++){
118      printf("Join %d\r", HClustJoinN);
119      bool FirstMx=true; double MxMeanSim=0; int MxVrtxN1=-1; int MxVrtxN2=-1;
120      for (int VrtxN1=0; VrtxN1<VrtxV.Len(); VrtxN1++){
121        PVrtx Vrtx1=VrtxV[VrtxN1];
122        if (!Vrtx1.Empty()){
123          for (int VrtxN2=VrtxN1+1; VrtxN2<VrtxV.Len(); VrtxN2++){
124            PVrtx Vrtx2=VrtxV[VrtxN2];
125            if (!Vrtx2.Empty()){
126              TIntV& VarNV1=VarNVV[VrtxN1];
127              TIntV& VarNV2=VarNVV[VrtxN2];
128              double SumSim=0;
129              for (int VarNN1=0; VarNN1<VarNV1.Len(); VarNN1++){
130                for (int VarNN2=0; VarNN2<VarNV2.Len(); VarNN2++){
131                  SumSim+=SimVV.At(VarNV1[VarNN1], VarNV2[VarNN2]);
132                }
133              }
134              double MeanSim=SumSim/(VarNV1.Len()*VarNV2.Len());
135              if ((FirstMx)||(MeanSim>MxMeanSim)){
136                FirstMx=false;
137                MxMeanSim=MeanSim; MxVrtxN1=VrtxN1; MxVrtxN2=VrtxN2;
138              }
139            }
140          }
141        }
142      }
143      PVrtx JoinVrtx=PVrtx(new TGVrtx()); HClustGraph->AddVrtx(JoinVrtx);
144      PEdge JoinEdge1=PEdge(new TGEdge(JoinVrtx, VrtxV[MxVrtxN1]));
145      PEdge JoinEdge2=PEdge(new TGEdge(JoinVrtx, VrtxV[MxVrtxN2]));
146      HClustGraph->AddEdge(JoinEdge1); HClustGraph->AddEdge(JoinEdge2);
147      JoinVrtx->PutWgt(MxMeanSim);
148      VrtxV[MxVrtxN1]=JoinVrtx; VrtxV[MxVrtxN2]=NULL;
149      VarNVV[MxVrtxN1].AddV(VarNVV[MxVrtxN2]); VarNVV[MxVrtxN2].Clr();
150    }
151    return HClustGraph;
152  }
153  PGraph TCorrGroups::GetHClustGraph() const {
154    TFltVV SimVV; GetCorrSimVV(SimVV);
155    return GetHClustGraph(SimVV);
156  }
157  void TCorrGroups::SetHClustGroups(const TFltVV& SimVV, const int& Groups){
158    int Vars=GetVars();
159    IAssert((0<Groups)&&(Groups<=Vars));
160    VarNVV.Gen(Vars);
161    for (int VarN=0; VarN<Vars; VarN++){VarNVV[VarN].Add(VarN);}
162    for (int HClustJoinN=0; HClustJoinN<Vars-Groups; HClustJoinN++){
163      printf("Join %d\r", HClustJoinN);
164      bool FirstMx=true; double MxMeanSim=0; int MxVarNVN1=-1; int MxVarNVN2=-1;
165      for (int VarNVN1=0; VarNVN1<VarNVV.Len(); VarNVN1++){
166        for (int VarNVN2=VarNVN1+1; VarNVN2<VarNVV.Len(); VarNVN2++){
167          TIntV& VarNV1=VarNVV[VarNVN1];
168          TIntV& VarNV2=VarNVV[VarNVN2];
169          double SumSim=0;
170          for (int VarNN1=0; VarNN1<VarNV1.Len(); VarNN1++){
171            for (int VarNN2=0; VarNN2<VarNV2.Len(); VarNN2++){
172              SumSim+=SimVV.At(VarNV1[VarNN1], VarNV2[VarNN2]);
173            }
174          }
175          double MeanSim=SumSim/(VarNV1.Len()*VarNV2.Len());
176          if ((FirstMx)||(MeanSim>MxMeanSim)){
177            FirstMx=false;
178            MxMeanSim=MeanSim; MxVarNVN1=VarNVN1; MxVarNVN2=VarNVN2;
179          }
180        }
181      }
182      VarNVV[MxVarNVN1].AddV(VarNVV[MxVarNVN2]);
183      VarNVV.Del(MxVarNVN2);
184    }
185  }
186  void TCorrGroups::SetKMeansGroups(const int& Groups, const int& Trials){
187    TRnd Rnd(1); int Vars=GetVars(); int Recs=GetRecs();
188    IAssert((0<Groups)&&(Groups<=Vars));
189    double BestQual=0; TVec<TIntV> BestVarNVV;
190    for (int TrialN=0; TrialN<Trials; TrialN++){
191      printf("Trial: %d\n", TrialN);
192      TVec<TFltV> CentrVarNV(Groups);
193      for (int CentrN=0; CentrN<Groups; CentrN++){
194        int CentrVarN=Rnd.GetUniDevInt(Vars);
195        CentrVarNV[CentrN]=VarValVV[CentrVarN];
196      }
197      double PrevQual=0; double Qual=0;
198      do {
199        PrevQual=Qual;
200        VarNVV.Gen(Groups);
201        for (int VarN=0; VarN<Vars; VarN++){
202          TFltV SimV(Groups);
203          for (int CentrN=0; CentrN<Groups; CentrN++){
204            PCorr Corr=TCorr::New(CentrVarNV[CentrN], VarValVV[VarN]);
205            SimV[CentrN]=fabs(Corr->GetCorrCf());
206          }
207          int BestGroupN=SimV.GetMxValN();
208          VarNVV[BestGroupN].Add(VarN);
209        }
210        for (int CentrN=0; CentrN<Groups; CentrN++){
211          TMomV VarValMomV; GetGroupCentroid(VarNVV[CentrN], VarValMomV);
212          for (int RecN=0; RecN<Recs; RecN++){
213            if (VarValMomV[RecN]->IsUsable()){
214              CentrVarNV[CentrN][RecN]=VarValMomV[RecN]->GetMedian();
215            } else {
216              CentrVarNV[CentrN][RecN]=0;
217            }
218          }
219        }
220        Qual=0;
221        for (int GroupN=0; GroupN<Groups; GroupN++){
222          int GroupVars=VarNVV[GroupN].Len();
223          for (int VarNN=0; VarNN<GroupVars; VarNN++){
224            int VarN=VarNVV[GroupN][VarNN];
225            PCorr Corr=TCorr::New(CentrVarNV[GroupN], VarValVV[VarN]);
226            double Sim=fabs(Corr->GetCorrCf());
227            Qual+=TMath::Sqr(Sim);
228          }
229        }
230        if ((PrevQual==0)||(Qual<BestQual)){
231          BestQual=Qual; BestVarNVV=VarNVV;
232        }
233        if (PrevQual!=0){
234          printf("   %g (%g)\n", Qual, PrevQual/Qual);}
235      } while ((PrevQual==0)||(PrevQual/Qual<0.9999));
236    }
237    VarNVV=BestVarNVV;
238  }
239  PCorrGroups TCorrGroups::LoadTxtVarCVal(const TStr& FNm){
240    TStrV VarNmV; 
241    TStrV RecNmV; 
242    TVec<TFltV> VarValVV; 
243    TILx Lx(TFIn::New(FNm), TFSet(iloRetEoln, iloSigNum));
244    Lx.GetSym(syInt, syEof); int RecN=0;
245    while (Lx.Sym!=syEof){
246      RecN++; TStr RecNm=TInt::GetStr(RecN);
247      RecNmV.Add(RecNm);
248      int PrevVarN=-1; TStrV CurVarNmV; TFltV VarValV(VarNmV.Len(), 0);
249      while (Lx.Sym!=syEoln){
250        IAssert((PrevVarN==-1)||(PrevVarN+1==Lx.Int));
251        PrevVarN=Lx.Int;
252        TStr VarNm=TInt::GetStr(Lx.Int);
253        CurVarNmV.Add(VarNm);
254        Lx.GetSym(syColon);
255        double VarVal=Lx.GetFlt();
256        VarValV.Add(VarVal);
257        Lx.GetSym(syInt, syEoln);
258      }
259      if (VarNmV.Empty()){VarNmV=CurVarNmV;}
260      else {IAssert(VarNmV==CurVarNmV);}
261      VarValVV.Add(VarValV);
262      Lx.GetSym(syInt, syEof);
263    }
264    PCorrGroups CorrGroups=New(VarNmV, RecNmV, VarValVV, TNotify::StdNotify);
265    return CorrGroups;
266  }
267  void TCorrGroups::SaveTxt(
268   const PSOut& SOut, const bool& CentrP, const bool& SqrtValP) const {
269    SOut->PutStr("==============================="); SOut->PutLn();
270    for (int GroupN=0; GroupN<VarNVV.Len(); GroupN++){
271      SOut->PutStr("Group"); SOut->PutInt(GroupN);
272      SOut->PutInt(VarNVV[GroupN].Len(), "(%d)");
273      SOut->PutStr(":"); SOut->PutLn();
274      for (int VarNN=0; VarNN<VarNVV[GroupN].Len(); VarNN++){
275        int VarN=VarNVV[GroupN][VarNN];
276        SOut->PutStr("   ");
277        SOut->PutStr(GetVarNm(VarN));
278        SOut->PutLn();
279      }
280      VarNVV[GroupN].Sort();
281      if (CentrP){
282        TIntV VarNV; GetGroup(GroupN, VarNV);
283        TMomV VarValMomV; GetGroupCentroid(VarNV, VarValMomV);
284        SOut->PutStr("Centroid:\n");
285        for (int RecN=0; RecN<GetRecs(); RecN++){
286          SOut->PutStr("  ");
287          SOut->PutStr(GetRecNm(RecN));
288          SOut->PutStr(":");
289          if (!VarValMomV[RecN]->IsUsable()){
290            SOut->PutStr("X");
291          } else {
292            if (SqrtValP){
293              SOut->PutFlt(sqrt(VarValMomV[RecN]->GetMean()), "%0.0f");
294            } else {
295              SOut->PutFlt(VarValMomV[RecN]->GetMean());
296            }
297          }
298          if ((RecN+1)%8==0){SOut->PutLn();}
299        }
300        SOut->PutLn();
301      }
302      SOut->PutLn();
303    }
304  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-corrgr.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-corrgr.cpp</div>
                </div>
                <div class="column column_space"><pre><code>204            PCorr Corr=TCorr::New(CentrVarNV[CentrN], VarValVV[VarN]);
205            SimV[CentrN]=fabs(Corr->GetCorrCf());
</pre></code></div>
                <div class="column column_space"><pre><code>10        PCorr Corr=TCorr::New(VarValVV[VarN1], VarValVV[VarN2]);
11        SimVV.At(VarN1, VarN2)=fabs(Corr->GetCorrCf());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    