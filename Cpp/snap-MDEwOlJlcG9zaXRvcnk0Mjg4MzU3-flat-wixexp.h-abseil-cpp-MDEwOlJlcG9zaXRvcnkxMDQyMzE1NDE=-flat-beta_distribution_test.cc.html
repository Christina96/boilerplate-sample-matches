
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.3846153846153846%, Tokens: 11</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wixexp.h</h3>
            <pre><code>1  typedef enum {
2    welctSpace, welctAlpha, welctNum, welctSym, welctEof} TWixExpLxChTy;
3  class TWixExpLxChDef{
4  private:
5    TIntV ChTyV;
6    void SetChTy(const TWixExpLxChTy& ChTy, const TStr& Str);
7  public:
8    TWixExpLxChDef();
9    TWixExpLxChDef& operator=(const TWixExpLxChDef&){Fail; return *this;}
10    int GetChTy(const char& Ch){return ChTyV[Ch-TCh::Mn];}
11    bool IsSpace(const char& Ch){return ChTyV[Ch-TCh::Mn]==welctSpace;}
12    bool IsAlpha(const char& Ch){return ChTyV[Ch-TCh::Mn]==welctAlpha;}
13    bool IsNum(const char& Ch){return ChTyV[Ch-TCh::Mn]==welctNum;}
14    bool IsAlNum(const char& Ch){return IsAlpha(Ch)||IsNum(Ch);}
15    bool IsSym(const char& Ch){return ChTyV[Ch-TCh::Mn]==welctSym;}
16  };
17  typedef enum {
18    wekDomain, wekDepth, wekFeature, wekOutgoingUrl, wekTitle,
19    wekAfter, wekBefore, wekWithin
20  } TWixExpKw;
21  class TWixExpKwMap{
22  private:
23    TStrIntH StrToKwH;
24  public:
25    TWixExpKwMap();
26    TWixExpKwMap& operator=(const TWixExpKwMap&){Fail; return *this;}
27    bool IsExpKw(const TStr& ExpKwStr, TWixExpKw& ExpKw);
28  };
29  typedef enum {
30    wesyUndef, wesyWord, wesyNum, wesySSym, 
31    wesyDQuote, wesyColon, wesyLParen, wesyRParen, 
32    wesyOr, wesyAnd, wesyNot, 
33    wesyIncl, wesyExcl, wesyWCard, 
34    wesyEof} TWixExpLxSym;
35  class TWixExpLx{
36  private:
37    static TWixExpLxChDef ChDef;
38    PSIn SIn;
39    char Ch;
40    void GetCh(){Ch=(SIn->Eof()) ? TCh::EofCh : SIn->GetCh();}
41  public:
42    TWixExpLxSym Sym;
43    TChA Str;
44  public:
45    TWixExpLx(const TStr& ExpStr);
46    TWixExpLx& operator=(const TWixExpLx&){Fail; return *this;}
47    TWixExpLxSym GetSym(const TFSet& Expect);
48    TWixExpLxSym GetSym(){return GetSym(TFSet());}
49    TWixExpLxSym GetSym(const TWixExpLxSym& Sym){return GetSym(TFSet()|Sym);}
50    TWixExpLxSym GetSym(const TWixExpLxSym& Sym1, const TWixExpLxSym& Sym2){
51      return GetSym(TFSet()|Sym1|Sym2);}
52    TWixExpLxSym GetSym(const TWixExpLxSym& Sym1, const TWixExpLxSym& Sym2,
53     const TWixExpLxSym& Sym3){
54      return GetSym(TFSet()|Sym1|Sym2|Sym3);}
55  };
56  ClassTP(TWixExpDocIdSet, PWixExpDocIdSet)
57  private:
58    TBlobPtV DocIdV;
59    bool NegatedP;
60  public:
61    TWixExpDocIdSet():
62      DocIdV(), NegatedP(false){}
63    TWixExpDocIdSet(const TBlobPtV& _DocIdV, const bool& _NegatedP=false):
64      DocIdV(_DocIdV), NegatedP(_NegatedP){}
65    ~TWixExpDocIdSet(){}
66    TWixExpDocIdSet(TSIn&){Fail;}
67    static PWixExpDocIdSet Load(TSIn&){Fail; return NULL;}
68    void Save(TSOut&){}
69    TWixExpDocIdSet& operator=(const TWixExpDocIdSet&){Fail; return *this;}
<span onclick='openModal()' class='match'>70    TBlobPtV& GetDocIdV(){return DocIdV;}
71    int GetDocIds() const {return DocIdV.Len();}
72    TBlobPt GetDocId(const int& DocIdN) const {return DocIdV[DocIdN];}
</span>73    void PutNegated(const bool& _NegatedP){NegatedP=_NegatedP;}
74    bool IsNegated() const {return NegatedP;}
75    void GetDocIdV(TBlobPtV& _DocIdV){_DocIdV=DocIdV;}
76    PWixExpDocIdSet AndDocSet(const PWixExpDocIdSet& DocSet);
77    PWixExpDocIdSet OrDocSet(const PWixExpDocIdSet& DocSet);
78  };
79  typedef enum {
80    weitUndef,
81    weitOr, weitAnd, weitNot, weitIncl, weitExcl, weitWCard,
82    weitWord, weitPhrase, weitMeta} TWixExpItemType;
83  ClassTPV(TWixExpItem, PWixExpItem, TWixExpItemV)
84  private:
85    TWixExpItemType Type;
86    TWixExpItemV ExpItemV;
87    TStrV WordStrV;
88  public:
89    TWixExpItem():
90      Type(weitUndef), ExpItemV(), WordStrV(){}
91    TWixExpItem(const TWixExpItemType& _Type,
92     const PWixExpItem& ExpItem1, const PWixExpItem& ExpItem2=NULL);
93    TWixExpItem(const TStr& WordStr);
94    TWixExpItem(const TStrV& WordStrV);
95    TWixExpItem(const TStr& MetaTag, const TStrV& ArgStrV);
96    ~TWixExpItem(){}
97    TWixExpItem(TSIn&){Fail;}
98    static PWixExpItem Load(TSIn&){Fail; return NULL;}
99    void Save(TSOut&){Fail;}
100    TWixExpItem& operator=(const TWixExpItem&){Fail; return *this;}
101    TWixExpItemType GetType(){return Type;}
102    PWixExpItem GetExpItem(const int& ExpItemN=0);
103    TStr GetWordStr();
104    int GetPhraseLen();
105    TStr GetPhraseWordStr(const int& WordStrN);
106    PWixExpDocIdSet Eval(const PWix& Wix);
107  };
108  ClassTP(TWixExp, PWixExp)
109  private:
110    TStr ExpStr;
111    bool Ok;
112    TStr ErrMsg;
113    PWixExpItem ExpItem;
114  private:
115    TFSet FactExpect, TermExpect, ExpExpect;
116    PWixExpItem ParseFact(TWixExpLx& Lx, const TFSet& Expect);
117    PWixExpItem ParseTerm(TWixExpLx& Lx, const TFSet& Expect);
118    PWixExpItem ParseExp(TWixExpLx& Lx, const TFSet& Expect);
119  public:
120    TWixExp(const TWixExp&);
121    TWixExp(const TStr& _ExpStr);
122    static PWixExp New(const TStr& ExpStr){
123      return PWixExp(new TWixExp(ExpStr));}
124    ~TWixExp(){}
125    TWixExp(TSIn&){Fail;}
126    static PWixExp Load(TSIn&){Fail; return NULL;}
127    void Save(TSOut&){Fail;}
128    TWixExp& operator=(const TWixExp&){Fail; return *this;}
129    bool IsOk() const {return Ok;}
130    TStr GetErrMsg() const {return ErrMsg;}
131    PWixExpDocIdSet Eval(const PWix& Wix);
132  };
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-beta_distribution_test.cc</h3>
            <pre><code>1  #include "absl/random/beta_distribution.h"
2  #include <algorithm>
3  #include <cfloat>
4  #include <cstddef>
5  #include <cstdint>
6  #include <iterator>
7  #include <random>
8  #include <sstream>
9  #include <string>
10  #include <type_traits>
11  #include <unordered_map>
12  #include <vector>
13  #include "gmock/gmock.h"
14  #include "gtest/gtest.h"
15  #include "absl/log/log.h"
16  #include "absl/numeric/internal/representation.h"
17  #include "absl/random/internal/chi_square.h"
18  #include "absl/random/internal/distribution_test_util.h"
19  #include "absl/random/internal/pcg_engine.h"
20  #include "absl/random/internal/sequence_urbg.h"
21  #include "absl/random/random.h"
22  #include "absl/strings/str_cat.h"
23  #include "absl/strings/str_format.h"
24  #include "absl/strings/str_replace.h"
25  #include "absl/strings/strip.h"
26  namespace {
27  template <typename IntType>
28  class BetaDistributionInterfaceTest : public ::testing::Test {};
29  constexpr bool ShouldExerciseLongDoubleTests() {
30  #if defined(__i686__) && defined(__x86_64__)
31    return !absl::numeric_internal::IsDoubleDouble();
32  #else
33    return false;
34  #endif
35  }
36  using RealTypes = std::conditional<ShouldExerciseLongDoubleTests(),
37                                     ::testing::Types<float, double, long double>,
38                                     ::testing::Types<float, double>>::type;
39  TYPED_TEST_SUITE(BetaDistributionInterfaceTest, RealTypes);
40  TYPED_TEST(BetaDistributionInterfaceTest, SerializeTest) {
41    const TypeParam kSmallA =
42        1.0f / std::log((std::numeric_limits<TypeParam>::max)());
43    const TypeParam kLargeA =
44        std::exp(std::log((std::numeric_limits<TypeParam>::max)()) -
45                 std::log(std::log((std::numeric_limits<TypeParam>::max)())));
46    using param_type = typename absl::beta_distribution<TypeParam>::param_type;
47    constexpr int kCount = 1000;
48    absl::InsecureBitGen gen;
49    const TypeParam kValues[] = {
50        TypeParam(1e-20), TypeParam(1e-12), TypeParam(1e-8), TypeParam(1e-4),
51        TypeParam(1e-3), TypeParam(0.1), TypeParam(0.25),
52        std::nextafter(TypeParam(0.5), TypeParam(0)),  
53        std::nextafter(TypeParam(0.5), TypeParam(1)),  
54        TypeParam(0.5), TypeParam(1.0),                
55        std::nextafter(TypeParam(1), TypeParam(0)),    
56        std::nextafter(TypeParam(1), TypeParam(2)),    
57        TypeParam(12.5), TypeParam(1e2), TypeParam(1e8), TypeParam(1e12),
58        TypeParam(1e20),                        
59        kSmallA,                                
60        std::nextafter(kSmallA, TypeParam(0)),  
61        std::nextafter(kSmallA, TypeParam(1)),  
62        kLargeA,                                
63        std::nextafter(kLargeA, TypeParam(0)),  
64        std::nextafter(kLargeA, std::numeric_limits<TypeParam>::max()),
65        std::numeric_limits<TypeParam>::max(),
66        std::numeric_limits<TypeParam>::epsilon(),
67        std::nextafter(std::numeric_limits<TypeParam>::min(),
68                       TypeParam(1)),                  
69        std::numeric_limits<TypeParam>::min(),         
70        std::numeric_limits<TypeParam>::denorm_min(),  
71        std::numeric_limits<TypeParam>::min() / 2,     
72        std::nextafter(std::numeric_limits<TypeParam>::min(),
73                       TypeParam(0)),  
74    };
75    for (TypeParam alpha : kValues) {
76      for (TypeParam beta : kValues) {
77        LOG(INFO) << absl::StreamFormat("Smoke test for Beta(%a, %a)", alpha,
78                                        beta);
79        param_type param(alpha, beta);
80        absl::beta_distribution<TypeParam> before(alpha, beta);
81        EXPECT_EQ(before.alpha(), param.alpha());
82        EXPECT_EQ(before.beta(), param.beta());
83        {
84          absl::beta_distribution<TypeParam> via_param(param);
85          EXPECT_EQ(via_param, before);
86          EXPECT_EQ(via_param.param(), before.param());
87        }
88        for (int i = 0; i < kCount; ++i) {
89          auto sample = before(gen);
90          EXPECT_TRUE(std::isfinite(sample));
91          EXPECT_GE(sample, before.min());
92          EXPECT_LE(sample, before.max());
93        }
94        std::stringstream ss;
95        ss << before;
96        absl::beta_distribution<TypeParam> after(3.8f, 1.43f);
97        EXPECT_NE(before.alpha(), after.alpha());
98        EXPECT_NE(before.beta(), after.beta());
99        EXPECT_NE(before.param(), after.param());
100        EXPECT_NE(before, after);
101        ss >> after;
102        EXPECT_EQ(before.alpha(), after.alpha());
103        EXPECT_EQ(before.beta(), after.beta());
104        EXPECT_EQ(before, after)           
105            << ss.str() << " "             
106            << (ss.good() ? "good " : "")  
107            << (ss.bad() ? "bad " : "")    
108            << (ss.eof() ? "eof " : "")    
109            << (ss.fail() ? "fail " : "");
110      }
111    }
112  }
113  TYPED_TEST(BetaDistributionInterfaceTest, DegenerateCases) {
114    absl::random_internal::pcg64_2018_engine rng(0x2B7E151628AED2A6);
115    constexpr int kCount = 1000;
116    const TypeParam kSmallValues[] = {
117        std::numeric_limits<TypeParam>::min(),
118        std::numeric_limits<TypeParam>::denorm_min(),
119        std::nextafter(std::numeric_limits<TypeParam>::min(),
120                       TypeParam(0)),  
121        std::numeric_limits<TypeParam>::epsilon(),
122    };
123    const TypeParam kLargeValues[] = {
124        std::numeric_limits<TypeParam>::max() * static_cast<TypeParam>(0.9999),
125        std::numeric_limits<TypeParam>::max() - 1,
126        std::numeric_limits<TypeParam>::max(),
127    };
128    {
129      for (TypeParam alpha : kSmallValues) {
130        for (TypeParam beta : kSmallValues) {
131          int zeros = 0;
132          int ones = 0;
133          absl::beta_distribution<TypeParam> d(alpha, beta);
134          for (int i = 0; i < kCount; ++i) {
135            TypeParam x = d(rng);
136            if (x == 0.0) {
137              zeros++;
138            } else if (x == 1.0) {
139              ones++;
140            }
141          }
142          EXPECT_EQ(ones + zeros, kCount);
143          if (alpha == beta) {
144            EXPECT_NE(ones, 0);
145            EXPECT_NE(zeros, 0);
146          }
147        }
148      }
149    }
150    {
151      for (TypeParam alpha : kSmallValues) {
152        for (TypeParam beta : kLargeValues) {
153          absl::beta_distribution<TypeParam> d(alpha, beta);
154          for (int i = 0; i < kCount; ++i) {
155            EXPECT_EQ(d(rng), 0.0);
156          }
157        }
158      }
159    }
160    {
161      for (TypeParam alpha : kLargeValues) {
162        for (TypeParam beta : kSmallValues) {
163          absl::beta_distribution<TypeParam> d(alpha, beta);
164          for (int i = 0; i < kCount; ++i) {
165            EXPECT_EQ(d(rng), 1.0);
166          }
167        }
168      }
169    }
170    {
171      absl::beta_distribution<TypeParam> d(std::numeric_limits<TypeParam>::max(),
172                                           std::numeric_limits<TypeParam>::max());
173      for (int i = 0; i < kCount; ++i) {
174        EXPECT_EQ(d(rng), 0.5);
175      }
176    }
177    {
178      absl::beta_distribution<TypeParam> d(
179          std::numeric_limits<TypeParam>::max(),
180          std::numeric_limits<TypeParam>::max() * 0.9999);
181      for (int i = 0; i < kCount; ++i) {
182        TypeParam x = d(rng);
183        EXPECT_NE(x, 0.5f);
184        EXPECT_FLOAT_EQ(x, 0.500025f);
185      }
186    }
187  }
188  class BetaDistributionModel {
189   public:
190    explicit BetaDistributionModel(::testing::tuple<double, double> p)
191        : alpha_(::testing::get<0>(p)), beta_(::testing::get<1>(p)) {}
192    double Mean() const { return alpha_ / (alpha_ + beta_); }
<span onclick='openModal()' class='match'>193    double Variance() const {
194      return alpha_ * beta_ / (alpha_ + beta_ + 1) / (alpha_ + beta_) /
195             (alpha_ + beta_);
196    }
197    double Kurtosis() const {
198      return 3 + 6 *
199                     ((alpha_ - beta_) * (alpha_ - beta_) * (alpha_ + beta_ + 1) -
200                      alpha_ * beta_ * (2 + alpha_ + beta_)) /
201                     alpha_ / beta_ / (alpha_ + beta_ + 2) / (alpha_ + beta_ + 3);
202    }
203   protected:
204    const double alpha_;
205    const double beta_;
</span>206  };
207  class BetaDistributionTest
208      : public ::testing::TestWithParam<::testing::tuple<double, double>>,
209        public BetaDistributionModel {
210   public:
211    BetaDistributionTest() : BetaDistributionModel(GetParam()) {}
212   protected:
213    template <class D>
214    bool SingleZTestOnMeanAndVariance(double p, size_t samples);
215    template <class D>
216    bool SingleChiSquaredTest(double p, size_t samples, size_t buckets);
217    absl::InsecureBitGen rng_;
218  };
219  template <class D>
220  bool BetaDistributionTest::SingleZTestOnMeanAndVariance(double p,
221                                                          size_t samples) {
222    D dis(alpha_, beta_);
223    std::vector<double> data;
224    data.reserve(samples);
225    for (size_t i = 0; i < samples; i++) {
226      const double variate = dis(rng_);
227      EXPECT_FALSE(std::isnan(variate));
228      EXPECT_GE(variate, 0.0);
229      EXPECT_LE(variate, 1.0);
230      data.push_back(variate);
231    }
232    const auto m = absl::random_internal::ComputeDistributionMoments(data);
233    const double mean_stddev = std::sqrt(Variance() / static_cast<double>(m.n));
234    const double variance_stddev = std::sqrt(
235        (Kurtosis() - 1) * Variance() * Variance() / static_cast<double>(m.n));
236    const double z_variance = (m.variance - Variance()) / variance_stddev;
237    const double max_err = absl::random_internal::MaxErrorTolerance(p);
238    const double z_mean = absl::random_internal::ZScore(Mean(), m);
239    const bool pass =
240        absl::random_internal::Near("z", z_mean, 0.0, max_err) &&
241        absl::random_internal::Near("z_variance", z_variance, 0.0, max_err);
242    if (!pass) {
243      LOG(INFO) << "Beta(" << alpha_ << ", " << beta_ << "), mean: sample "
244                << m.mean << ", expect " << Mean() << ", which is "
245                << std::abs(m.mean - Mean()) / mean_stddev
246                << " stddevs away, variance: sample " << m.variance << ", expect "
247                << Variance() << ", which is "
248                << std::abs(m.variance - Variance()) / variance_stddev
249                << " stddevs away.";
250    }
251    return pass;
252  }
253  template <class D>
254  bool BetaDistributionTest::SingleChiSquaredTest(double p, size_t samples,
255                                                  size_t buckets) {
256    constexpr double kErr = 1e-7;
257    std::vector<double> cutoffs, expected;
258    const double bucket_width = 1.0 / static_cast<double>(buckets);
259    int i = 1;
260    int unmerged_buckets = 0;
261    for (; i < buckets; ++i) {
262      const double p = bucket_width * static_cast<double>(i);
263      const double boundary =
264          absl::random_internal::BetaIncompleteInv(alpha_, beta_, p);
265      if ((cutoffs.empty() && boundary < kErr) ||
266          (!cutoffs.empty() && boundary <= cutoffs.back())) {
267        unmerged_buckets++;
268        continue;
269      }
270      if (boundary >= 1.0 - 1e-10) {
271        break;
272      }
273      cutoffs.push_back(boundary);
274      expected.push_back(static_cast<double>(1 + unmerged_buckets) *
275                         bucket_width * static_cast<double>(samples));
276      unmerged_buckets = 0;
277    }
278    cutoffs.push_back(std::numeric_limits<double>::infinity());
279    expected.push_back(static_cast<double>(buckets - i + 1) * bucket_width *
280                       static_cast<double>(samples));
281    EXPECT_GE(cutoffs.size(), 3) << alpha_ << ", " << beta_;
282    D dis(alpha_, beta_);
283    std::vector<int32_t> counts(cutoffs.size(), 0);
284    for (int i = 0; i < samples; i++) {
285      const double x = dis(rng_);
286      auto it = std::upper_bound(cutoffs.begin(), cutoffs.end(), x);
287      counts[std::distance(cutoffs.begin(), it)]++;
288    }
289    const int dof = cutoffs.size() - 1;
290    const double chi_square = absl::random_internal::ChiSquare(
291        counts.begin(), counts.end(), expected.begin(), expected.end());
292    const bool pass =
293        (absl::random_internal::ChiSquarePValue(chi_square, dof) >= p);
294    if (!pass) {
295      for (size_t i = 0; i < cutoffs.size(); i++) {
296        LOG(INFO) << "cutoff[" << i << "] = " << cutoffs[i] << ", actual count "
297                  << counts[i] << ", expected " << static_cast<int>(expected[i]);
298      }
299      LOG(INFO) << "Beta(" << alpha_ << ", " << beta_ << ") "
300                << absl::random_internal::kChiSquared << " " << chi_square
301                << ", p = "
302                << absl::random_internal::ChiSquarePValue(chi_square, dof);
303    }
304    return pass;
305  }
306  TEST_P(BetaDistributionTest, TestSampleStatistics) {
307    static constexpr int kRuns = 20;
308    static constexpr double kPFail = 0.02;
309    const double p =
310        absl::random_internal::RequiredSuccessProbability(kPFail, kRuns);
311    static constexpr int kSampleCount = 10000;
312    static constexpr int kBucketCount = 100;
313    int failed = 0;
314    for (int i = 0; i < kRuns; ++i) {
315      if (!SingleZTestOnMeanAndVariance<absl::beta_distribution<double>>(
316              p, kSampleCount)) {
317        failed++;
318      }
319      if (!SingleChiSquaredTest<absl::beta_distribution<double>>(
320              0.005, kSampleCount, kBucketCount)) {
321        failed++;
322      }
323    }
324    EXPECT_LE(failed, 5);
325  }
326  std::string ParamName(
327      const ::testing::TestParamInfo<::testing::tuple<double, double>>& info) {
328    std::string name = absl::StrCat("alpha_", ::testing::get<0>(info.param),
329                                    "__beta_", ::testing::get<1>(info.param));
330    return absl::StrReplaceAll(name, {{"+", "_"}, {"-", "_"}, {".", "_"}});
331  }
332  INSTANTIATE_TEST_SUITE_P(
333      TestSampleStatisticsCombinations, BetaDistributionTest,
334      ::testing::Combine(::testing::Values(0.1, 0.2, 0.9, 1.1, 2.5, 10.0, 123.4),
335                         ::testing::Values(0.1, 0.2, 0.9, 1.1, 2.5, 10.0, 123.4)),
336      ParamName);
337  INSTANTIATE_TEST_SUITE_P(
338      TestSampleStatistics_SelectedPairs, BetaDistributionTest,
339      ::testing::Values(std::make_pair(0.5, 1000), std::make_pair(1000, 0.5),
340                        std::make_pair(900, 1000), std::make_pair(10000, 20000),
341                        std::make_pair(4e5, 2e7), std::make_pair(1e7, 1e5)),
342      ParamName);
343  TEST(BetaDistributionTest, StabilityTest) {
344    using testing::ElementsAre;
345    absl::random_internal::sequence_urbg urbg({
346        0xffff00000000e6c8ull, 0xffff0000000006c8ull, 0x800003766295CFA9ull,
347        0x11C819684E734A41ull, 0x832603766295CFA9ull, 0x7fbe76c8b4395800ull,
348        0xB3472DCA7B14A94Aull, 0x0003eb76f6f7f755ull, 0xFFCEA50FDB2F953Bull,
349        0x13CCA830EB61BD96ull, 0x0334FE1EAA0363CFull, 0x00035C904C70A239ull,
350        0x00009E0BCBAADE14ull, 0x0000000000622CA7ull, 0x4864f22c059bf29eull,
351        0x247856d8b862665cull, 0xe46e86e9a1337e10ull, 0xd8c8541f3519b133ull,
352        0xffe75b52c567b9e4ull, 0xfffff732e5709c5bull, 0xff1f7f0b983532acull,
353        0x1ec2e8986d2362caull, 0xC332DDEFBE6C5AA5ull, 0x6558218568AB9702ull,
354        0x2AEF7DAD5B6E2F84ull, 0x1521B62829076170ull, 0xECDD4775619F1510ull,
355        0x814c8e35fe9a961aull, 0x0c3cd59c9b638a02ull, 0xcb3bb6478a07715cull,
356        0x1224e62c978bbc7full, 0x671ef2cb04e81f6eull, 0x3c1cbd811eaf1808ull,
357        0x1bbc23cfa8fac721ull, 0xa4c2cda65e596a51ull, 0xb77216fad37adf91ull,
358        0x836d794457c08849ull, 0xe083df03475f49d7ull, 0xbc9feb512e6b0d6cull,
359        0xb12d74fdd718c8c5ull, 0x12ff09653bfbe4caull, 0x8dd03a105bc4ee7eull,
360        0x5738341045ba0d85ull, 0xf3fd722dc65ad09eull, 0xfa14fd21ea2a5705ull,
361        0xffe6ea4d6edb0c73ull, 0xD07E9EFE2BF11FB4ull, 0x95DBDA4DAE909198ull,
362        0xEAAD8E716B93D5A0ull, 0xD08ED1D0AFC725E0ull, 0x8E3C5B2F8E7594B7ull,
363        0x8FF6E2FBF2122B64ull, 0x8888B812900DF01Cull, 0x4FAD5EA0688FC31Cull,
364        0xD1CFF191B3A8C1ADull, 0x2F2F2218BE0E1777ull, 0xEA752DFE8B021FA1ull,
365    });
366    auto float_to_u64 = [](float d) {
367      int exp = 0;
368      auto f = std::frexp(d, &exp);
369      return (static_cast<uint64_t>(1e5 * f) * 10000) + std::abs(exp);
370    };
371    auto double_to_u64 = [](double d) {
372      int exp = 0;
373      auto f = std::frexp(d, &exp);
374      return (static_cast<uint64_t>(1e10 * f) * 10000) + std::abs(exp);
375    };
376    std::vector<uint64_t> output(20);
377    {
378      absl::beta_distribution<float> dist(0.1f, 0.2f);
379      std::generate(std::begin(output), std::end(output),
380                    [&] { return float_to_u64(dist(urbg)); });
381      EXPECT_EQ(44, urbg.invocations());
382      EXPECT_THAT(output,  
383                  testing::ElementsAre(
384                      998340000, 619030004, 500000001, 999990000, 996280000,
385                      500000001, 844740004, 847210001, 999970000, 872320000,
386                      585480007, 933280000, 869080042, 647670031, 528240004,
387                      969980004, 626050008, 915930002, 833440033, 878040015));
388    }
389    urbg.reset();
390    {
391      absl::beta_distribution<double> dist(0.1, 0.2);
392      std::generate(std::begin(output), std::end(output),
393                    [&] { return double_to_u64(dist(urbg)); });
394      EXPECT_EQ(44, urbg.invocations());
395      EXPECT_THAT(
396          output,  
397          testing::ElementsAre(
398              99834713000000, 61903356870004, 50000000000001, 99999721170000,
399              99628374770000, 99999999990000, 84474397860004, 84721276240001,
400              99997407490000, 87232528120000, 58548364780007, 93328932910000,
401              86908237770042, 64767917930031, 52824581970004, 96998544140004,
402              62605946270008, 91593604380002, 83345031740033, 87804397230015));
403    }
404    urbg.reset();
405    {
406      absl::beta_distribution<double> dist(0.9, 2.0);
407      std::generate(std::begin(output), std::end(output),
408                    [&] { return double_to_u64(dist(urbg)); });
409      EXPECT_EQ(62, urbg.invocations());
410      EXPECT_THAT(
411          output,  
412          testing::ElementsAre(
413              62069004780001, 64433204450001, 53607416560000, 89644295430008,
414              61434586310019, 55172615890002, 62187161490000, 56433684810003,
415              80454622050005, 86418558710003, 92920514700001, 64645184680001,
416              58549183380000, 84881283650005, 71078728590002, 69949694970000,
417              73157461710001, 68592191300001, 70747623900000, 78584696930005));
418    }
419    urbg.reset();
420    {
421      absl::beta_distribution<double> dist(1.5, 2.5);
422      std::generate(std::begin(output), std::end(output),
423                    [&] { return double_to_u64(dist(urbg)); });
424      EXPECT_EQ(54, urbg.invocations());
425      EXPECT_THAT(
426          output,  
427          testing::ElementsAre(
428              75000029250001, 76751482860001, 53264575220000, 69193133650005,
429              78028324470013, 91573587560002, 59167523770000, 60658618560002,
430              80075870540000, 94141320460004, 63196592770003, 78883906300002,
431              96797992590001, 76907587800001, 56645167560000, 65408302280003,
432              53401156320001, 64731238570000, 83065573750001, 79788333820001));
433    }
434  }
435  TEST(BetaDistributionTest, AlgorithmBounds) {
436  #if (defined(__i386__) || defined(_M_IX86)) && FLT_EVAL_METHOD != 0
437    GTEST_SKIP()
438        << "Skipping the test because we detected x87 floating-point semantics";
439  #endif
440    {
441      absl::random_internal::sequence_urbg urbg(
442          {0x7fbe76c8b4395800ull, 0x8000000000000000ull});
443      absl::beta_distribution<double> dist(1e-4, 1e-4);
444      double a = dist(urbg);
445      EXPECT_EQ(a, 2.0202860861567108529e-09);
446      EXPECT_EQ(2, urbg.invocations());
447    }
448    {
449      absl::beta_distribution<float> dist(0.5, 0.5);
450      absl::random_internal::sequence_urbg urbg(
451          {0xffff00000006e6c8ull, 0xffff00000007c7c8ull, 0x800003766295CFA9ull,
452           0x11C819684E734A41ull});
453      {
454        double y = absl::beta_distribution<double>(0.5, 0.5)(urbg);
455        EXPECT_EQ(4, urbg.invocations());
456        EXPECT_EQ(y, 0.9810668952633862) << y;
457      }
458      urbg.reset();
459      {
460        float x = absl::beta_distribution<float>(0.5, 0.5)(urbg);
461        EXPECT_EQ(4, urbg.invocations());
462        EXPECT_NEAR(0.98106688261032104, x, 0.0000005) << x << "f";
463      }
464    }
465  }
466  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wixexp.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-beta_distribution_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>70    TBlobPtV& GetDocIdV(){return DocIdV;}
71    int GetDocIds() const {return DocIdV.Len();}
72    TBlobPt GetDocId(const int& DocIdN) const {return DocIdV[DocIdN];}
</pre></code></div>
                <div class="column column_space"><pre><code>193    double Variance() const {
194      return alpha_ * beta_ / (alpha_ + beta_ + 1) / (alpha_ + beta_) /
195             (alpha_ + beta_);
196    }
197    double Kurtosis() const {
198      return 3 + 6 *
199                     ((alpha_ - beta_) * (alpha_ - beta_) * (alpha_ + beta_ + 1) -
200                      alpha_ * beta_ * (2 + alpha_ + beta_)) /
201                     alpha_ / beta_ / (alpha_ + beta_ + 2) / (alpha_ + beta_ + 3);
202    }
203   protected:
204    const double alpha_;
205    const double beta_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    