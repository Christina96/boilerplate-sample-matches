
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexObjC.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <ctype.h>
4  #include <stdio.h>
5  #include <stdarg.h>
6  #include <assert.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "LexAccessor.h"
11  #include "Accessor.h"
12  #include "StyleContext.h"
13  #include "WordList.h"
14  #include "CharacterSet.h"
15  #include "LexerModule.h"
16  #include "Scintilla.h"
17  #include "SciLexer.h"
18  using namespace Lexilla;
19  constexpr auto KEYWORD_BOXHEADER = 1;
20  static bool IsOKBeforeRE(const int ch) {
21  	return (ch == '(') || (ch == '=') || (ch == ',');
22  }
23  static inline bool IsAWordChar(const int ch) {
24  	return (ch < 0x80) && (isalnum(ch) || ch == '.' || ch == '_');
25  }
26  static inline bool IsAWordStart(const int ch) {
27  	return (ch < 0x80) && (isalnum(ch) || ch == '_');
28  }
29  inline bool IsASpace(unsigned int ch) {
30      return (ch == ' ') || ((ch >= 0x09) && (ch <= 0x0d));
31  }
32  static inline bool IsADigit(char ch) {
33  	return isascii(ch) && isdigit(ch);
34  }
35  static inline bool IsADoxygenChar(const int ch) {
36  	return (islower(ch) || ch == '$' || ch == '@' ||
37  	        ch == '\\' || ch == '&' || ch == '<' ||
38  	        ch == '>' || ch == '#' || ch == '{' ||
39  	        ch == '}' || ch == '[' || ch == ']');
40  }
41  static void ColouriseObjCDoc(size_t startPos, int length, int initStyle, WordList *keywordlists[],
42                              Accessor &styler, bool caseSensitive) {
43  	WordList &mainInstrsList = *keywordlists[0]; 
44  	WordList &mainTypesList = *keywordlists[1]; 
45  	WordList &DoxygenList = *keywordlists[2]; 
46  	WordList &objcDirectiveList = *keywordlists[3]; 
47  	WordList &objcQualifierList = *keywordlists[4]; 
48  	bool stylingWithinPreprocessor = styler.GetPropertyInt("styling.within.preprocessor") != 0;
49  	if (initStyle == SCE_C_STRINGEOL)
50  		initStyle = SCE_C_DEFAULT;
51  	int chPrevNonWhite = ' ';
52  	int visibleChars = 0;
53  	bool lastWordWasUUID = false;
54  	StyleContext sc(startPos, length, initStyle, styler);
55  	for (; sc.More(); sc.Forward()) 
56  	{
57  		if (sc.atLineStart && (sc.state == SCE_C_STRING)) 
58  		{
59  			sc.SetState(SCE_C_STRING);
60  		}
61  		if (sc.ch == '\\') 
62  		{
63  			if (sc.chNext == '\n' || sc.chNext == '\r') 
64  			{
65  				sc.Forward();
66  				if (sc.ch == '\r' && sc.chNext == '\n') 
67  				{
68  					sc.Forward();
69  				}
70  				continue;
71  			}
72  		}
73  		switch (sc.state)
74  		{
75  			case SCE_C_OPERATOR :
76  			{
77  				sc.SetState(SCE_C_DEFAULT);
78  				break;
79  			} 
80  			case SCE_C_NUMBER :
81  			{
82  				if (!IsAWordChar(sc.ch)) 
83  					sc.SetState(SCE_C_DEFAULT);
84  				break;
85  			} 
86  			case SCE_C_IDENTIFIER : 
87  			{
88  				if (!IsAWordChar(sc.ch) || (sc.ch == '.')) 
89  				{
90  					char s[100];
91  					sc.GetCurrent(s, sizeof(s));
92  					if (s[0] == '@')
93  					{
94  						char *ps = s + 1;
95  						if (objcDirectiveList.InList(ps))
96  							sc.ChangeState(SCE_OBJC_DIRECTIVE);
97  					}
98  					else 
99  					{
100  						if (mainInstrsList.InList(s)) 
101  						{
102  							lastWordWasUUID = strcmp(s, "uuid") == 0;
103  							sc.ChangeState(SCE_C_WORD);
104  						} 
105  						else if (mainTypesList.InList(s)) 
106  						{
107  							sc.ChangeState(SCE_C_WORD2);
108  						}
109  						else if (objcQualifierList.InList(s)) 
110  						{
111  							sc.ChangeState(SCE_OBJC_QUALIFIER);
112  						}
113  					}
114  					sc.SetState(SCE_C_DEFAULT);
115  				}
116  				break;
117  			} 
118  			case SCE_C_PREPROCESSOR :
119  			{
120  				if (stylingWithinPreprocessor) 
121  				{
122  					if (IsASpace(sc.ch)) 
123  						sc.SetState(SCE_C_DEFAULT);
124  				} 
125  				else 
126  				{
127  					if ((sc.atLineEnd) || (sc.Match('/', '*')) || (sc.Match('/', '/'))) 
128  						sc.SetState(SCE_C_DEFAULT);
129  				}
130  				break;
131  			} 
132  			case SCE_C_COMMENT :
133  			{
134  				if (sc.Match('*', '/')) 
135  				{
136  					sc.Forward();
137  					sc.ForwardSetState(SCE_C_DEFAULT);
138  				}
139  				break;
140  			} 
141  			case SCE_C_COMMENTDOC :
142  			{
143  				if (sc.Match('*', '/')) 
144  				{
145  					sc.Forward();
146  					sc.ForwardSetState(SCE_C_DEFAULT);
147  				} 
148  				else if (sc.ch == '@' || sc.ch == '\\') 
149  				{
150  					sc.SetState(SCE_C_COMMENTDOCKEYWORD);
151  				}
152  				break;
153  			} 
154  			case SCE_C_COMMENTLINE :
155  			case SCE_C_COMMENTLINEDOC :
156  			{
157  				if (sc.atLineEnd) 
158  				{
159  					sc.SetState(SCE_C_DEFAULT);
160  					visibleChars = 0;
161  				}
162  				break;
163  			} 
164  			case SCE_C_COMMENTDOCKEYWORD :
165  			{
166  				if (sc.Match('*', '/')) 
167  				{
168  					sc.ChangeState(SCE_C_COMMENTDOCKEYWORDERROR);
169  					sc.Forward();
170  					sc.ForwardSetState(SCE_C_DEFAULT);
171  				} 
172  				else if (!IsADoxygenChar(sc.ch)) 
173  				{
174  					char s[100];
175  					if (caseSensitive) 
176  						sc.GetCurrent(s, sizeof(s));
177  					else 
178  						sc.GetCurrentLowered(s, sizeof(s));
179  					if (!isspace(sc.ch) || !DoxygenList.InList(s + 1)) 
180  						sc.ChangeState(SCE_C_COMMENTDOCKEYWORDERROR);
181  					sc.SetState(SCE_C_COMMENTDOC);
182  				}
183  				break;
184  			}
185  			case SCE_C_STRING :
186  			{
187  				if (sc.ch == '\\') 
188  				{
189  					if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\')
190  						sc.Forward();
191  				} 
192  				else if (sc.ch == '\"') 
193  				{
194  					sc.ForwardSetState(SCE_C_DEFAULT);
195  				} 
196  				else if (sc.atLineEnd) 
197  				{
198  					sc.ChangeState(SCE_C_STRINGEOL);
199  					sc.ForwardSetState(SCE_C_DEFAULT);
200  					visibleChars = 0;
201  				}
202  				break;
203  			} 
204  			case SCE_C_CHARACTER :
205  			{
206  				if (sc.atLineEnd) 
207  				{
208  					sc.ChangeState(SCE_C_STRINGEOL);
209  					sc.ForwardSetState(SCE_C_DEFAULT);
210  					visibleChars = 0;
211  				} 
212  				else if (sc.ch == '\\') 
213  				{
214  					if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\') 
215  					{
216  						sc.Forward();
217  					}
218  				} 
219  				else if (sc.ch == '\'') 
220  				{
221  					sc.ForwardSetState(SCE_C_DEFAULT);
222  				}
223  				break;
224  			} 
225  			case SCE_C_REGEX :
226  			{
227  				if (sc.ch == '\r' || sc.ch == '\n' || sc.ch == '/') 
228  				{
229  					sc.ForwardSetState(SCE_C_DEFAULT);
230  				} 
231  				else if (sc.ch == '\\') 
232  				{
233  					if (sc.chNext == '\\' || sc.chNext == '/') 
234  					{
235  						sc.Forward();
236  					}
237  				}
238  				break;
239  			} 
240  			case SCE_C_VERBATIM :
241  			{
242  				if (sc.ch == '\"') 
243  				{
244  					if (sc.chNext == '\"') 
245  						sc.Forward();
246  					else 
247  						sc.ForwardSetState(SCE_C_DEFAULT);
248  				}
249  				break;
250  			} 
251  			case SCE_C_UUID :
252  			{
253  				if (sc.ch == '\r' || sc.ch == '\n' || sc.ch == ')') 
254  					sc.SetState(SCE_C_DEFAULT);
255  				break;
256  			}
257  			default :
258  				break;
259  		}
260  		if (sc.state == SCE_C_DEFAULT) 
261  		{
262  			if (sc.Match('@', '\"')) 
263  			{
264  				sc.SetState(SCE_C_VERBATIM);
265  				sc.Forward();
266  			}
267  			else if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) 
268  			{
269  				if (lastWordWasUUID) 
270  				{
271  					sc.SetState(SCE_C_UUID);
272  					lastWordWasUUID = false;
273  				} 
274  				else 
275  				{
276  					sc.SetState(SCE_C_NUMBER);
277  				}
278  			} 
279  			else if (IsAWordStart(sc.ch) || (sc.ch == '@')) 
280  			{
281  				if (lastWordWasUUID) 
282  				{
283  					sc.SetState(SCE_C_UUID);
284  					lastWordWasUUID = false;
285  				} 
286  				else 
287  				{
288  					sc.SetState(SCE_C_IDENTIFIER);
289  				}
290  			} 
291  			else if (sc.Match('/', '*')) 
292  			{
293  				if (sc.Match("&bsol;**") || sc.Match("&bsol;*!")) 
294  					sc.SetState(SCE_C_COMMENTDOC);
295  				else 
296  					sc.SetState(SCE_C_COMMENT);
297  				sc.Forward();	
298  			} 
299  			else if (sc.Match('/', '/')) 
300  			{
301  				if (sc.Match("&bsol;&bsol;/") || sc.Match("&bsol;&bsol;!"))	&bsol;&bsol; Support of Qt/Doxygen doc. style
302  					sc.SetState(SCE_C_COMMENTLINEDOC);
303  				else
304  					sc.SetState(SCE_C_COMMENTLINE);
305  			} 
306  			else if (sc.ch == '/' && IsOKBeforeRE(chPrevNonWhite)) 
307  			{
308  				sc.SetState(SCE_C_REGEX);
309  			} 
310  			else if (sc.ch == '\"') 
311  			{
312  				sc.SetState(SCE_C_STRING);
313  			} 
314  			else if (sc.ch == '\'') 
315  			{
316  				sc.SetState(SCE_C_CHARACTER);
317  			} 
318  			else if (sc.ch == '#' && visibleChars == 0) 
319  			{
320  				sc.SetState(SCE_C_PREPROCESSOR);
321  				do {
322  					sc.Forward();
323  				} while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
324  				if (sc.atLineEnd) 
325  					sc.SetState(SCE_C_DEFAULT);
326  			}
327  			else if (isoperator(static_cast<char>(sc.ch)))
328  			{
329  				sc.SetState(SCE_C_OPERATOR);
330  			}
331  		}
332  		if (sc.atLineEnd) {
333  			chPrevNonWhite = ' ';
334  			visibleChars = 0;
335  			lastWordWasUUID = false;
336  		}
337  		if (!IsASpace(sc.ch)) {
338  			chPrevNonWhite = sc.ch;
339  			visibleChars++;
340  		}
341  	}
342  	sc.Complete();
343  }
344  static bool IsStreamCommentStyle(int style) {
345  	return style == SCE_C_COMMENT ||
346  	       style == SCE_C_COMMENTDOC ||
347  	       style == SCE_C_COMMENTDOCKEYWORD ||
348  	       style == SCE_C_COMMENTDOCKEYWORDERROR;
349  }
350  static bool matchKeyword(size_t start, WordList &keywords, Accessor &styler, int keywordtype) {
351  	bool FoundKeyword = false;
352  	for (unsigned int i = 0;
353  			strlen(keywords.WordAt(i)) > 0 && !FoundKeyword;
354  	        i++) {
355  		if (atoi(keywords.WordAt(i)) == keywordtype) {
356  			FoundKeyword = styler.Match(start, ((char *)keywords.WordAt(i)) + 2);
357  		}
358  	}
359  	return FoundKeyword;
360  }
361  static bool IsCommentLine(int line, Accessor &styler) {
362  	unsigned int Pos = styler.LineStart(line);
363  	while (styler.GetLine(Pos) == line) {
364  		int PosStyle = styler.StyleAt(Pos);
365  		if (	!IsStreamCommentStyle(PosStyle)
366  		        &&
367  		        PosStyle != SCE_C_COMMENTLINEDOC
368  		        &&
369  		        PosStyle != SCE_C_COMMENTLINE
370  		        &&
371  		        !IsASpace(styler.SafeGetCharAt(Pos))
372  		   )
373  			return false;
374  		Pos++;
375  	}
376  	return true;
377  }
378  static void FoldObjCDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
379                         Accessor &styler) {
380  	WordList &keywords4 = *keywordlists[3];
381  	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
382  	bool foldPreprocessor = styler.GetPropertyInt("fold.preprocessor") != 0;
383  	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
384  	bool firstLine = true;
385  	size_t endPos = startPos + length;
386  	int visibleChars = 0;
387  	int lineCurrent = styler.GetLine(startPos);
388  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
389  	int levelCurrent = levelPrev;
390  	int levelPrevPrev;
391  	int levelUnindent = 0;
392  	char chNext = styler[startPos];
393  	int styleNext = styler.StyleAt(startPos);
394  	int style = initStyle;
395  	if (lineCurrent == 0) {
396  		levelPrevPrev = levelPrev;
397  	} else {
398  		levelPrevPrev = styler.LevelAt(static_cast<Sci_Position>(lineCurrent) - 1) & SC_FOLDLEVELNUMBERMASK;
399  	}
400  	for (size_t i = startPos; i < endPos; i++) {
401  		char ch = chNext;
402  		chNext = styler.SafeGetCharAt(i + 1);
403  		int stylePrev = style;
404  		style = styleNext;
405  		styleNext = styler.StyleAt(i + 1);
406  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
407  		if (foldComment && IsStreamCommentStyle(style)) {
408  			if (!IsStreamCommentStyle(stylePrev)) {
409  				levelCurrent++;
410  			} else if (!IsStreamCommentStyle(styleNext) && !atEOL) {
411  				levelCurrent--;
412  			}
413  		}
414  		if (foldPreprocessor && (style == SCE_C_PREPROCESSOR)) {
415  			if (ch == '#') {
416  				size_t j = i + 1;
417  				while ((j < endPos) && IsASpaceOrTab(styler.SafeGetCharAt(j))) {
418  					j++;
419  				}
420  				if (styler.Match(j, "region") || styler.Match(j, "if")) {
421  					levelCurrent++;
422  				} else if (styler.Match(j, "end")) {
423  					levelCurrent--;
424  				}
425  			}
426  		}
427  		if (style == SCE_C_OPERATOR
428  		        ||
429  		        style == SCE_C_COMMENT
430  		        ||
431  		        style == SCE_C_COMMENTLINE) {
432  			if (ch == '{') {
433  				levelCurrent++;
434  				if (levelCurrent == levelPrev) {
435  					if (firstLine)
436  						levelUnindent = 1;
437  					else
438  						levelUnindent = -1;
439  				}
440  			} else if (ch == '}') {
441  				levelCurrent--;
442  			}
443  		}
444  		if (style == SCE_OBJC_DIRECTIVE)
445  		{
446  			if (ch == '@') 
447  			{
448  				size_t j = i + 1;
449  				if (styler.Match(j, "interface") || styler.Match(j, "implementation") || styler.Match(j, "protocol")) 
450  				{
451  					levelCurrent++;
452  				} 
453  				else if (styler.Match(j, "end")) 
454  				{
455  					levelCurrent--;
456  				}
457  			}
458  		}
459  		if ((style == SCE_C_WORD || style == SCE_C_COMMENT || style == SCE_C_COMMENTLINE)
460  		 && (style != stylePrev)) {
461  			if (matchKeyword(i, keywords4, styler, KEYWORD_BOXHEADER)) {
462  				int line;
463  				for (line = lineCurrent - 1;
464  				        line >= 0
465  				        &&
466  				        levelCurrent == (styler.LevelAt(line) & SC_FOLDLEVELNUMBERMASK)
467  				        &&
468  				        IsCommentLine(line, styler);
469  				        line--) {
470  				}
471  				line++;
472                  if (line == lineCurrent) {
473                  } else {
<span onclick='openModal()' class='match'>474                      styler.SetLevel(line, styler.LevelAt(line));
475                  }
</span>476  			}
477  		}
478  		if (atEOL) {
479  			int lev;
480  			if (levelUnindent < 0) {
481  				levelPrev += levelUnindent;
482  			} else {
483  				levelCurrent += levelUnindent;
484  			}
485  			lev = levelPrev;
486  			if (visibleChars == 0 && foldCompact)
487  				lev |= SC_FOLDLEVELWHITEFLAG;
488  			if (levelPrev < levelPrevPrev) {
489  				styler.SetLevel(static_cast<Sci_Position>(lineCurrent) - 1, styler.LevelAt(static_cast<Sci_Position>(lineCurrent) - 1));
490  			}
491  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
492  				lev |= SC_FOLDLEVELHEADERFLAG;
493  			if (lev != styler.LevelAt(lineCurrent)) {
494  				styler.SetLevel(lineCurrent, lev);
495  			}
496  			lineCurrent++;
497  			levelPrevPrev = levelPrev;
498  			levelPrev = levelCurrent;
499  			levelUnindent = 0;
500  			visibleChars = 0;
501  			firstLine = false;
502  		}
503  		if (!isspacechar(ch))
504  			visibleChars++;
505  	}
506  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
507  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
508  }
509  static const char * const cppWordLists[] = {
510              "Primary keywords and identifiers",
511              "Secondary keywords and identifiers",
512              "Documentation comment keywords",
513              "Fold header keywords",
514              0,
515          };
516  static void ColouriseObjCDocSensitive(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
517                                       Accessor &styler) {
518  	ColouriseObjCDoc(startPos, length, initStyle, keywordlists, styler, true);
519  }
520  LexerModule lmObjC(SCLEX_OBJC, ColouriseObjCDocSensitive, "objc", FoldObjCDoc, cppWordLists);
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-shash.h</h3>
            <pre><code>1  #ifndef shash_h
2  #define shash_h
3  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
4  class TKeyDatFl {
5  private:
6    TInt ElemCnt;
7    TFIn FIn;
8    TKey Key;
9    TDat Dat;
10  public:
11    TKeyDatFl(const TStr& FNm) : FIn(FNm) { ElemCnt.Load(FIn); }
12    int Len() const { return ElemCnt; }
13    bool Next() { if (FIn.Eof()) { return false; }
14      Key.Load(FIn);  Dat.Load(FIn); return true; }
15    const TKey& GetKey() const { return Key; }
16    TKey& GetKey() { return Key; }
17    const TDat& GetDat() const { return Dat; }
18    TDat& GetDat() { return Dat; }
19    static void Save(const TStr& OutFNm, const THash<TKey, TDat, THashFunc>& Hash) {
20      TFOut FOut(OutFNm);  Load(FOut, Hash); }
21    static void Save(TSOut& SOut, const THash<TKey, TDat, THashFunc>& Hash) {
22      SOut.Save(Hash.Len());
23      for (int k = Hash.FFirstKeyId(); Hash.FNextKeyId(k); ) {
24        Hash.GetKey(k).Save(SOut);  Hash[k].Save(SOut); }
25    }
26    static void LoadHash(const TStr& InFNm, THash<TKey, TDat, THashFunc>& Hash, const int& LoadN=-1) {
27      TFIn FIn(InFNm);  Load(FIn, Hash, LoadN); }
28    static void LoadHash(TSIn& SIn, THash<TKey, TDat, THashFunc>& Hash, int LoadN=-1) {
29      TInt ElemCnt(SIn);  const int Start=clock();
30      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
31      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  Hash.Gen(LoadN);
32      for (int i = 0; i < LoadN; i++) { Hash.AddDat(TKey(SIn)).Load(SIn); }
33      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
34    }
35    static void LoadKeyV(TSIn& SIn, TVec<TKey>& KeyV, int LoadN=-1) {
36      TInt ElemCnt(SIn);  const int Start=clock();
37      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
38      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  KeyV.Gen(LoadN, 0);
39      for (int i = 0; i < LoadN; i++) { KeyV.Add(TKey(SIn));  TDat D(SIn); }
40      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
41    }
42    static void LoadDatV(TSIn& SIn, TVec<TDat>& DatV, int LoadN=-1) {
43      TInt ElemCnt(SIn);  const int Start=clock();
44      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
45      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  DatV.Gen(LoadN, 0);
46      for (int i = 0; i < LoadN; i++) { TKey(SIn);  DatV.Add(TDat(SIn)); }
47      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
48    }
49  };
50  template <class TVal, uint16 GroupSize> 
51  class TSparseGroup {
52  private:
53    unsigned char BitSet [(GroupSize-1)/8 + 1];   
54    uint16 Buckets;                               
55    TVal *Group;
56  private:
57    static int CharBit(const int&  ValN) { return ValN >> 3; }
58    static int ModBit(const int&  ValN) { return 1 << (ValN&7); }
59    bool BMTest(const int&  ValN) const { return (BitSet[CharBit(ValN)] & ModBit(ValN)) != 0; }
60    void BMSet(const int&  ValN) { BitSet[CharBit(ValN)] |= ModBit(ValN); }
61    void BMClear(const int&  ValN) { BitSet[CharBit(ValN)] &= ~ModBit(ValN); }
62    static int PosToOffset(const unsigned char *BitSet, int Pos);
63  public:
64    TSparseGroup() : Buckets(0), Group(NULL) { memset(BitSet, 0, sizeof(BitSet)); }
65    TSparseGroup(TSIn& SIn) : Buckets(0), Group(NULL) { Load(SIn); }
66    TSparseGroup(const TSparseGroup& SG);
67    ~TSparseGroup() { if (Group != NULL) delete [] Group; }
68    void Load(TSIn& SIn);
69    void Save(TSOut& SOut) const;
70    TSparseGroup& operator = (const TSparseGroup& SG);
71    bool operator == (const TSparseGroup& SG) const;
72    bool operator < (const TSparseGroup& SG) const;
73    int Len() const { return Buckets; }
74    int MxLen() const { return GroupSize; }
75    int Reserved() const { return GroupSize; }
76    bool Empty() const { return Buckets == 0; }
77    void Clr(const bool& DoDel = true);
78    int GetGroupSize() const { return GroupSize; }
79    uint GetDiskSz() const { return sizeof(BitSet) + sizeof(uint16) + Buckets*sizeof(TVal); }
80    bool IsEmpty(const int& ValN) const { return ! BMTest(ValN); }
81    const TVal& Offset(const int& Pos) const { return Group[Pos]; }
82    TVal& Offset(const int& Pos) { return Group[Pos]; }
83    int OffsetToPos(int Offset) const;
84    int PosToOffset(int Pos) const { return PosToOffset(BitSet, Pos); }
85    const TVal& DefVal() const { static TVal DefValue = TVal();  return DefValue; }
86    const TVal& Get(const int& ValN) const {
87      if (BMTest(ValN)) return Group[PosToOffset(BitSet, ValN)]; else return DefVal(); }
88    const TVal& operator [] (const int ValN) const { return Get(ValN); }
89    TVal& Set(const int& ValN, const TVal& Val);
90    TVal& Set(const int& ValN) {
91      if (! BMTest(ValN)) Set(ValN, DefVal());
92      return Group[PosToOffset(BitSet, ValN)];
93    }
94    void Del(const int& ValN);
95  };
96  template <class TVal, uint16 GroupSize>
97  int TSparseGroup<TVal, GroupSize>::PosToOffset(const unsigned char *BitSet, int Pos) {
98    static const int bits_in [256] = {      
99      0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
100      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
101      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
102      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
103      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
104      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
105      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
106      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
107      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
108      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
109      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
110      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
111      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
112      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
113      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
114      4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
115    };
116    int Offset = 0;
117    for ( ; Pos > 8; Pos -= 8 )                        
118      Offset += bits_in[*BitSet++];                    
119    return Offset + bits_in[*BitSet & ((1 << Pos)-1)]; 
120  }
121  template <class TVal, uint16 GroupSize>
122  TSparseGroup<TVal, GroupSize>::TSparseGroup(const TSparseGroup& SG) : Buckets(SG.Buckets), Group(NULL) {
123    memcpy(BitSet, SG.BitSet, sizeof(BitSet));
124    if (Buckets > 0) {
125      Group = new TVal [Buckets];
126      for (int b = 0; b < Buckets; b++) { Group[b] = SG.Group[b]; }
127    }
128  }
129  template <class TVal, uint16 GroupSize>
130  void TSparseGroup<TVal, GroupSize>::Load(TSIn& SIn) {
131    SIn.LoadBf(BitSet, sizeof(BitSet));
132    SIn.Load(Buckets);
133    if (Group != NULL) delete [] Group;
134    Group = new TVal [Buckets];
135    for (int b = 0; b < Buckets; b++) { Group[b] = TVal(SIn); }
136  }
137  template <class TVal, uint16 GroupSize>
138  void TSparseGroup<TVal, GroupSize>::Save(TSOut& SOut) const {
139    SOut.SaveBf(BitSet, sizeof(BitSet));
140    SOut.Save(Buckets);
141    for (int b = 0; b < Buckets; b++) { Group[b].Save(SOut); }
142  }
143  template <class TVal, uint16 GroupSize>
144  TSparseGroup<TVal, GroupSize>& TSparseGroup<TVal, GroupSize>::operator = (const TSparseGroup& SG) {
145    if (this != &SG) {
146      if (SG.Buckets == 0 && Group != NULL) {
147        delete [] Group;
148        Group = 0;
149      } else {
150        if (Buckets != SG.Buckets) {
151          if (Group != NULL) delete [] Group;
152          Group = new TVal [SG.Buckets];
153        }
154        for (int b = 0; b < SG.Buckets; b++) { Group[b] = SG.Group[b]; }
155      }
156      Buckets = SG.Buckets;
157      memcpy(BitSet, SG.BitSet, sizeof(BitSet));
158    }
159    return *this;
160  }
161  template <class TVal, uint16 GroupSize>
162  bool TSparseGroup<TVal, GroupSize>::operator == (const TSparseGroup& SG) const {
163    if (Buckets == SG.Buckets && memcmp(BitSet, SG.BitSet, sizeof(BitSet)) == 0) {
164      for (int b = 0; b < Buckets; b++) {
165        if (Group[b] != SG.Group[b]) return false;
166      }
167      return true;
168    }
169    return false;
170  }
171  template <class TVal, uint16 GroupSize>
172  bool TSparseGroup<TVal, GroupSize>::operator < (const TSparseGroup& SG) const {
173    if (Buckets < SG.Buckets) return true;
174    if (memcmp(BitSet, SG.BitSet, sizeof(BitSet)) == -1) return true;
175    for (int b = 0; b < Buckets; b++) {
176      if (Group[b] < SG.Group[b]) return true;
177    }
178    return false;
179  }
180  template <class TVal, uint16 GroupSize>
181  int TSparseGroup<TVal, GroupSize>::OffsetToPos(int Offset) const {
182    Assert(Offset < Buckets);
183    for (int i = 0; i < sizeof(BitSet); i++) {
184      for (int b = 0; b < 8; b++) {
185        if (TB1Def::GetBit(b, BitSet[i])) {
186          if (Offset == 0) return i*8 + b;
187          Offset--;
188        }
189      }
190    }
191    Fail;
192    return -1;
193  }
194  template <class TVal, uint16 GroupSize>
195  void TSparseGroup<TVal, GroupSize>::Clr(const bool& DoDel) {
196    if (DoDel && Group != NULL) {
197      delete [] Group;
198      Group = 0;
199    }
200    memset(BitSet, 0, sizeof(BitSet));
201    Buckets = 0;
202  }
203  template <class TVal, uint16 GroupSize>
204  TVal& TSparseGroup<TVal, GroupSize>::Set(const int& ValN, const TVal& Val) {
205    const int Offset = PosToOffset(BitSet, ValN);
206    if (! BMTest(ValN)) {
207      const TVal *OldGroup = Group;
208      Group = new TVal [Buckets+1];
209      for (int b = 0; b < Offset; b++) Group[b] = OldGroup[b];
210      for (int b = Offset+1; b <= Buckets; b++) Group[b] = OldGroup[b-1];
211      if (OldGroup != NULL) delete [] OldGroup;
212      Buckets++;
213      BMSet(ValN);
214    }
215    Group[Offset] = Val;
216    return Group[Offset];
217  }
218  template <class TVal, uint16 GroupSize>
219  void TSparseGroup<TVal, GroupSize>::Del(const int& ValN) {
220    if (BMTest(ValN)) {
221      const int Offset = PosToOffset(BitSet, ValN);
222      if (--Buckets == 0) {
223        delete [] Group;
224        Group = 0;
225      } else {
226        const TVal *OldGroup = Group;
227        Group = new TVal [Buckets];
228        for (int b = 0; b < Offset; b++) Group[b] = OldGroup[b];
229        for (int b = Offset+1; b <= Buckets; b++) Group[b-1] = OldGroup[b];
230        if (OldGroup != NULL) delete [] OldGroup;
231      }
232      BMClear(ValN);
233    }
234  }
235  template <class TVal, uint16 GroupSize>
236  class TSparseTableI {
237  private:
238    typedef TSparseGroup<TVal, GroupSize> TValGroup;
239    typedef typename TVec<TValGroup>::TIter TGroupVI;
240    int CurOff; 
241    TGroupVI BegI, GroupI, EndI;
242  public:
243    TSparseTableI() : CurOff(0), GroupI(NULL), EndI(NULL) { }
244    TSparseTableI(const TGroupVI& BegIter, const TGroupVI& CurIter, const TGroupVI& EndIter,
245      const int& Offset = 0) : CurOff(Offset), BegI(BegIter), GroupI(CurIter), EndI(EndIter) { }
246    TSparseTableI(const TSparseTableI& STI) :
247      CurOff(STI.CurOff), BegI(STI.BegI), GroupI(STI.GroupI), EndI(STI.EndI) { }
248    TSparseTableI& operator = (const TSparseTableI& STI) {
249      CurOff=STI.CurOff;  BegI=STI.BegI;  GroupI=STI.GroupI;  EndI=STI.EndI;  return *this; }
250    bool operator == (const TSparseTableI& STI) const {
251      return GroupI == STI.GroupI && CurOff == STI.CurOff; }
252    bool operator < (const TSparseTableI& STI) const {
253      return GroupI < STI.GroupI || (GroupI == STI.GroupI && CurOff < STI.CurOff); }
254    TSparseTableI& operator++ (int) {
255      if (CurOff+1 == GroupI->Len()) { CurOff = 0;
256        if (GroupI < EndI) { GroupI++;
257          while (GroupI < EndI && GroupI->Empty()) { GroupI++; } }
258      } else { CurOff++; }
259      return *this;
260    }
261    TSparseTableI& operator-- (int) {
262      if (CurOff == 0) {
263        while (GroupI >= BegI && GroupI->Empty()) { GroupI--; }
264        if (GroupI >= BegI) CurOff = GroupI->Len()-1;
265      } else { CurOff--; }
266      return *this;
267    }
268    int GetValN() const { return int(GroupI-BegI)*GroupSize + GroupI->OffsetToPos(CurOff); }
269    bool IsEnd() const { return GroupI==EndI; }
270    TVal& operator*() const { return GroupI->Offset(CurOff); }
271    TVal& operator()() const { return GroupI->Offset(CurOff); }
272    TVal* operator->() const { return &(operator*()); }
273  };
274  template <class TVal, uint16 GroupSize = 48> 
275  class TSparseTable {
276  public:
277    typedef TSparseGroup<TVal, GroupSize> TSGroup;
278    typedef TSparseTableI<TVal, GroupSize> TIter;
279  private:
280    TInt MxVals, Vals;
281    TVec<TSGroup> GroupV;
282  private:
283    static int GetGroups(const int& Vals) { return Vals == 0 ? 0 : ((Vals-1) / GroupSize) + 1; }
284    int PosInGroup(const int& ValN) const { return ValN % GroupSize; }
285    int GroupNum(const int& ValN) const { return ValN / GroupSize; }
286    const TSGroup& GetGrp1(const int& ValN) const { return GroupV[GroupNum(ValN)]; }
287    TSGroup& GetGrp1(const int& ValN) { return GroupV[GroupNum(ValN)]; }
288  public:
289    TSparseTable(const int& MaxVals = 0) : MxVals(MaxVals),
290      Vals(0), GroupV(GetGroups(MaxVals), GetGroups(MaxVals)) { }
291    TSparseTable(const TSparseTable& ST) : MxVals(ST.MxVals), Vals(ST.Vals), GroupV(ST.GroupV) { }
292    TSparseTable(TSIn& SIn) : MxVals(SIn), Vals(SIn), GroupV(SIn) { }
293    void Load(TSIn& SIn) { MxVals.Load(SIn);  Vals.Load(SIn);  GroupV.Load(SIn); }
294    void Save(TSOut& SOut) const { MxVals.Save(SOut);  Vals.Save(SOut);  GroupV.Save(SOut); }
295    TSparseTable& operator = (const TSparseTable& ST);
296    bool operator == (const TSparseTable& ST) const;
297    bool operator < (const TSparseTable& ST) const;
298    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Vals*sizeof(TVal)+GroupV.GetMemUsed(); }
299    TIter BegI() const {
300      if (Len() > 0) { int B = 0;
301        while (B < Groups() && GroupV[B].Empty()) { B++; }
302        return TIter(GroupV.BegI(), GroupV.BegI()+B, GroupV.EndI()); }
303      return TIter(GroupV.BegI(), GroupV.EndI(), GroupV.EndI());
304    }
305    TIter EndI() const { return TIter(GroupV.BegI(), GroupV.EndI(), GroupV.EndI()); }
306    TIter GetI(const int& ValN) const { Assert(! IsEmpty(ValN));
307      typedef typename TVec<TSGroup>::TIter TVIter;
308      const TVIter GI = GroupV.GetI(GroupNum(ValN));
309      return TIter(GroupV.BegI(), GI, GroupV.EndI(), GI->PosToOffset(PosInGroup(ValN)));
310    }
311    int Len() const { return Vals; }
312    int Reserved() const { return MxVals; }
313    int Groups() const { return GroupV.Len(); }
314    bool Empty() const { return Vals == 0; }
315    uint GetDiskSz() const {
316      return sizeof(TInt)*4 + ((GroupSize+16)/8)*Groups() + sizeof(TVal)*Vals; }
317    void Clr(const bool& DoDel = true);
318    void Reserve(const int NewVals) { Resize(NewVals); }
319    void Resize(const int& NewVals);
320    void Swap(TSparseTable& ST);
321    bool IsEmpty(const int& ValN) const { return GroupV[GroupNum(ValN)].IsEmpty(PosInGroup(ValN)); }
322    const TVal& Get(const int& ValN) const { return GroupV[GroupNum(ValN)].Get(PosInGroup(ValN)); }
323    TVal& Set(const int& ValN, const TVal& Val);
324    TVal& Set(const int& ValN);
325    void Del(const int& ValN);
326    TSGroup& GetGroup(const int& GroupN) { return GroupV[GroupN]; }
327    const TSGroup& GetGroup(const int& GroupN) const { return GroupV[GroupN]; }
328  };
329  template <class TVal, uint16 GroupSize>
330  TSparseTable<TVal, GroupSize>& TSparseTable<TVal, GroupSize>::operator = (const TSparseTable& ST) {
331    if (this != &ST) {
332      MxVals = ST.MxVals;
333      Vals = ST.Vals;
334      GroupV = ST.GroupV;
335    }
336    return *this;
337  }
338  template <class TVal, uint16 GroupSize>
339  bool TSparseTable<TVal, GroupSize>::operator == (const TSparseTable& ST) const {
340    return Vals == ST.Vals && MxVals == ST.MxVals && GroupV == ST.GroupV;
341  }
342  template <class TVal, uint16 GroupSize>
343  bool TSparseTable<TVal, GroupSize>::operator < (const TSparseTable& ST) const {
344    return Vals < ST.Vals || (Vals == ST.Vals && GroupV < ST.GroupV);
345  }
346  template <class TVal, uint16 GroupSize>
347  void TSparseTable<TVal, GroupSize>::Clr(const bool& DoDel) {
348    if (! DoDel) {
349      for (int g = 0; g < GroupV.Len(); g++) GroupV[g].Clr(false);
350    } else {
351      MxVals = 0;
352      GroupV.Clr(true);
353    }
354    Vals = 0;
355  }
356  template <class TVal, uint16 GroupSize>
357  void TSparseTable<TVal, GroupSize>::Resize(const int& NewVals) {
358    if (NewVals > MxVals) {
359      const int Groups = GetGroups(NewVals);
360      GroupV.Reserve(Groups, Groups);
361      MxVals = NewVals;
362    }
363  }
364  template <class TVal, uint16 GroupSize>
365  void TSparseTable<TVal, GroupSize>::Swap(TSparseTable& ST) {
366    ::Swap(MxVals, ST.MxVals);
367    ::Swap(Vals, ST.Vals);
368    GroupV.Swap(ST.GroupV);
369  }
370  template <class TVal, uint16 GroupSize>
371  TVal& TSparseTable<TVal, GroupSize>::Set(const int& ValN, const TVal& Val) {
372    Assert(ValN < MxVals);
373    TSGroup& Group = GetGrp1(ValN);
374    const int OldVals = Group.Len();
375    TVal& ValRef = Group.Set(PosInGroup(ValN), Val);
376    Vals += Group.Len() - OldVals;
377    return ValRef;
378  }
379  template <class TVal, uint16 GroupSize>
380  TVal& TSparseTable<TVal, GroupSize>::Set(const int& ValN) {
381    Assert(ValN < MxVals);
382    TSGroup& Group = GetGrp1(ValN);
383    const int OldVals = Group.Len();
384    TVal& ValRef = Group.Set(PosInGroup(ValN));
385    Vals += Group.Len() - OldVals;
386    return ValRef;
387  }
388  template <class TVal, uint16 GroupSize>
389  void TSparseTable<TVal, GroupSize>::Del(const int& ValN) {
390    Assert(ValN < MxVals);
391    TSGroup& Group = GetGrp1(ValN);
392    const int OldVals = Group.Len();
393    Group.Del(PosInGroup(ValN));
394    Vals += Group.Len() - OldVals;
395  }
396  #pragma pack(push, 1) 
397  template <class TKey, class TDat>
398  class TSHashKeyDat {
399  public:
400    TKey Key;
401    TDat Dat;
402  public:
403    TSHashKeyDat() : Key(), Dat() { }
404    TSHashKeyDat(const TKey& _Key) : Key(_Key), Dat() { }
405    TSHashKeyDat(const TKey& _Key, const TDat& _Dat) : Key(_Key), Dat(_Dat) { }
406    TSHashKeyDat(const TSHashKeyDat& HashKeyDat) : Key(HashKeyDat.Key), Dat(HashKeyDat.Dat) { }
407    explicit TSHashKeyDat(TSIn& SIn) : Key(SIn), Dat(SIn) { }
408    void Save(TSOut& SOut) const { Key.Save(SOut);  Dat.Save(SOut); }
409    TSHashKeyDat& operator = (const TSHashKeyDat& HashKeyDat) { if (this != &HashKeyDat) {
410      Key = HashKeyDat.Key;  Dat = HashKeyDat.Dat; }  return *this; }
411    bool operator == (const TSHashKeyDat& HashKeyDat) const { return Key == HashKeyDat.Key; }
412    bool operator < (const TSHashKeyDat& HashKeyDat) const { return Key < HashKeyDat.Key; }
413    int Hash() const { return Key.GetPrimHashCd(); }
414  };
415  #pragma pack(pop)
416  template <class TKey, class TDat, uint16 GroupSize=48> 
417  class TSparseHash {
418  public:
419    typedef TSHashKeyDat<TKey, TDat> THashKeyDat;
420    typedef typename TSparseTable<THashKeyDat, GroupSize>::TIter TIter;
421    typedef typename TSparseTable<THashKeyDat, GroupSize>::TSGroup TSGroup;
422  public:
423    static const float MxOccupancy; 
424    static const float MnOccupancy; 
425    static const int MinBuckets;    
426  private:
427    void ResetThresh();
428    int GetMinSize(const int& CurVals, const int& WantedVals) const;
429    void CopyFrom(const TSparseHash& HT, const int& MnWanted);
430    void MoveFrom(TSparseHash& HT, const int& MnWanted);
431    void ResizeDelta(const int& ValsToAdd, const int& MnWanted = 0);
432    void FindPos(const TKey& Key, int& Pos, int& PosToIns) const;
433  private:
434    TInt ShrinkThresh, ExpandThresh;
435    TSparseTable<THashKeyDat, GroupSize> Table;
436  public:
437    TSparseHash(const int& WantedVals = 0) : Table(GetMinSize(0, WantedVals)) { ResetThresh(); }
438    TSparseHash(TSIn& SIn) : ShrinkThresh(SIn), ExpandThresh(SIn), Table(SIn) { }
439    void Load(TSIn& SIn) { ShrinkThresh.Load(SIn);  ExpandThresh.Load(SIn);  Table.Load(SIn); }
440    void Save(TSOut& SOut) const { ShrinkThresh.Save(SOut); ExpandThresh.Save(SOut); Table.Save(SOut); }
441    TSparseHash& operator = (const TSparseHash& SHT);
442    bool operator == (const TSparseHash& SHT) const;
443    bool operator < (const TSparseHash& SHT) const;
444    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Table.GetMemUsed(); }
445    TIter BegI() const { return Table.BegI(); }
446    TIter EndI() const { return Table.EndI(); }
447    TIter GetI(const TKey& Key) const { Assert(IsKey(Key));  return Table.GetI(GetKeyId(Key)); }
448    bool Empty() const { return Len() == 0; }
449    int Len() const { return Table.Len(); }
450    int Reserved() const  { return Table.Reserved(); }
451    uint GetDiskSz() const { return 2*sizeof(TInt) + Table.GetDiskSz(); }
452    void Reserve(const int& MxVals) { if (MxVals > Len()) ResizeDelta(MxVals - Len(), 0); }
453    void Clr(const bool& DoDel = true) { Table.Clr(DoDel);  ResetThresh(); }
454    void Swap(TSparseHash& HT);
455    int AddKey(const TKey& Key);
456    TDat& AddDat(const TKey& Key);
457    TDat& AddDat(const TKey& Key, const TDat& Dat);
458    const TKey& GetKey(const int& KeyId) const { return Table.Get(KeyId).Key; }
459    int GetKeyId(const TKey& Key) const {
460      int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);  return Pos; }
461    bool IsKey(const TKey& Key) const { return GetKeyId(Key) != -1; }
462    bool IsKey(const TKey& Key, int& KeyId) const {
463      KeyId = GetKeyId(Key);  return KeyId != -1; }
464    bool IsKeyId(const int& KeyId) const { return ! Table.IsEmpty(KeyId); }
465    int GetRndKeyId(TRnd& Rnd = TInt::Rnd) const { Assert(Len()>0);
466      int KeyId = Rnd.GetUniDevInt(Reserved());
467      while (! IsKeyId(KeyId)) { KeyId = Rnd.GetUniDevInt(Reserved()); } return KeyId; }
468    const TDat& GetDat(const TKey& Key) const;
469    TDat& GetDat(const TKey& Key);
470    const TDat& GetDatKeyId(const int& KeyId) const { return Table.Get(KeyId).Dat; }
471    TDat& GetDatKeyId(const int& KeyId) { return Table.Set(KeyId).Dat; }
472    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const;
473    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const;
474    void GetKeyV(TVec<TKey>& KeyV) const;
475    void GetDatV(TVec<TDat>& DatV) const;
476    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
477    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
478  };
479  template <class TKey, class TDat, uint16 GroupSize>
480  const float TSparseHash<TKey, TDat, GroupSize>::MxOccupancy = 0.8f; 
481  template <class TKey, class TDat, uint16 GroupSize>
482  const float TSparseHash<TKey, TDat, GroupSize>::MnOccupancy = 0.4f * 0.8f; 
483  template <class TKey, class TDat, uint16 GroupSize>
484  const int TSparseHash<TKey, TDat, GroupSize>::MinBuckets = 32;
485  template <class TKey, class TDat, uint16 GroupSize>
486  void TSparseHash<TKey, TDat, GroupSize>::ResetThresh() {
487    ExpandThresh = int(Table.Reserved() * MxOccupancy);
488    ShrinkThresh = int(Table.Reserved() * MnOccupancy);
489  }
490  template <class TKey, class TDat, uint16 GroupSize>
491  int TSparseHash<TKey, TDat, GroupSize>::GetMinSize(const int& CurVals, const int& WantedVals) const {
492    int Size = MinBuckets;
493    while (Size*MxOccupancy < WantedVals || CurVals >= Size * MxOccupancy) Size *= 2;
494    return Size;
495  }
496  template <class TKey, class TDat, uint16 GroupSize>
497  void TSparseHash<TKey, TDat, GroupSize>::CopyFrom(const TSparseHash& HT, const int& MnWanted) {
498    Clr(false);
499    const int NewSize = GetMinSize(HT.Reserved(), MnWanted);
500    if (NewSize > Reserved()) {
501      Table.Resize(NewSize);
502      ResetThresh();
503    }
504    const uint BuckM1 = Reserved() - 1;
505    for (int g = 0; g < HT.Table.Groups(); g++) {
506      const TSGroup& Group = HT.Table.GetGroup(g);
507      for (int b = 0; b < Group.Len(); b++) {
508        int Tries = 0; uint BuckNum;
509        for (BuckNum = Group.Offset(b).Hash() & BuckM1;
510         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
511          Tries++;
512          Assert(Tries < Reserved());
513        }
514        Table.Set(BuckNum, Group.Offset(b));
515      }
516    }
517  }
518  template <class TKey, class TDat, uint16 GroupSize>
519  void TSparseHash<TKey, TDat, GroupSize>::MoveFrom(TSparseHash& HT, const int& MnWanted) {
520    Clr(false);
521    int NewSize;
522    if (MnWanted == 0) NewSize = HT.Reserved();
523    else NewSize = GetMinSize(HT.Reserved(), MnWanted);
524    if (NewSize > Reserved()) {
525      Table.Resize(NewSize);
526      ResetThresh();
527    }
528    const uint BuckM1 = Reserved() - 1;
529    for (int g = 0; g < HT.Table.Groups(); g++) {
530      TSGroup& Group = HT.Table.GetGroup(g);
531      for (int b = 0; b < Group.Len(); b++) {
532        int Tries = 0; uint BuckNum;
533        for (BuckNum = Group.Offset(b).Hash() & BuckM1;
534         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
535          Tries++;
536          Assert(Tries < Reserved());
537        }
538        Assert(Table.IsEmpty(BuckNum));
<span onclick='openModal()' class='match'>539        Table.Set(BuckNum, Group.Offset(b));
540      }
</span>541      Group.Clr(true); 
542    }
543  }
544  template <class TKey, class TDat, uint16 GroupSize>
545  void TSparseHash<TKey, TDat, GroupSize>::ResizeDelta(const int& ValsToAdd, const int& MnWanted) {
546    if (Reserved() > MnWanted && Len()+ValsToAdd < ExpandThresh) { return; }
547    const int NewSize = GetMinSize(Table.Len()+ValsToAdd, MnWanted);
548    if (NewSize > Reserved()) {
549      printf("***Resize SparseHash:%d->%d\n", Reserved(), NewSize);
550      TSparseHash TmpHt(ValsToAdd+Len());
551      TmpHt.ResetThresh();
552      TmpHt.MoveFrom(*this, Len());
553      Swap(TmpHt);
554    }
555  }
556  template <class TKey, class TDat, uint16 GroupSize>
557  void TSparseHash<TKey, TDat, GroupSize>::FindPos(const TKey& Key, int& Pos, int& PosToIns) const {
558    const uint BuckM1 = Reserved() - 1;
559    uint BuckNum = Key.GetPrimHashCd() & BuckM1;
560    int Tries = 0;
561    while (true) {
562      if (Table.IsEmpty(BuckNum)) {
563        Pos = -1;  PosToIns = BuckNum;  return;
564      }
565      else if (Key == Table.Get(BuckNum).Key) {
566        Pos = BuckNum;  PosToIns = -1;  return;
567      }
568      Tries++;
569      BuckNum = (BuckNum + Tries) & BuckM1;
570      Assert(Tries < Reserved());
571    }
572  }
573  template <class TKey, class TDat, uint16 GroupSize>
574  TSparseHash<TKey, TDat, GroupSize>& TSparseHash<TKey, TDat, GroupSize>::operator = (const TSparseHash& SHT) {
575    if (this != &SHT) {
576      ShrinkThresh = SHT.ShrinkThresh;
577      ExpandThresh = SHT.ExpandThresh;
578      Table = SHT.Table;
579    }
580    return *this;
581  }
582  template <class TKey, class TDat, uint16 GroupSize>
583  bool TSparseHash<TKey, TDat, GroupSize>::operator == (const TSparseHash& SHT) const {
584    return Table == SHT.Table;
585  }
586  template <class TKey, class TDat, uint16 GroupSize>
587  bool TSparseHash<TKey, TDat, GroupSize>::operator < (const TSparseHash& SHT) const {
588    return Table < SHT.Table;
589  }
590  template <class TKey, class TDat, uint16 GroupSize>
591  void TSparseHash<TKey, TDat, GroupSize>::Swap(TSparseHash& HT) {
592    ::Swap(ShrinkThresh, HT.ShrinkThresh);
593    ::Swap(ExpandThresh, HT.ExpandThresh);
594    Table.Swap(HT.Table);
595  }
596  template <class TKey, class TDat, uint16 GroupSize>
597  int TSparseHash<TKey, TDat, GroupSize>::AddKey(const TKey& Key) {
598    ResizeDelta(1);
599    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
600    if (Pos != -1) { return Pos; } 
601    else {
602      Table.Set(PosToIns, THashKeyDat(Key));
603      return PosToIns;
604    }
605  }
606  template <class TKey, class TDat, uint16 GroupSize>
607  TDat& TSparseHash<TKey, TDat, GroupSize>::AddDat(const TKey& Key) {
608    ResizeDelta(1);
609    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
610    if (PosToIns != -1) {
611      return Table.Set(PosToIns, THashKeyDat(Key)).Dat;
612    } else { return Table.Set(Pos).Dat; }
613  }
614  template <class TKey, class TDat, uint16 GroupSize>
615  TDat& TSparseHash<TKey, TDat, GroupSize>::AddDat(const TKey& Key, const TDat& Dat) {
616    ResizeDelta(1);
617    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
618    if (PosToIns != -1) {
619      return Table.Set(PosToIns, THashKeyDat(Key, Dat)).Dat;
620    } else { return Table.Set(Pos).Dat = Dat; }
621  }
622  template <class TKey, class TDat, uint16 GroupSize>
623  const TDat& TSparseHash<TKey, TDat, GroupSize>::GetDat(const TKey& Key) const {
624    int Pos, PosToIns;
625    FindPos(Key, Pos, PosToIns);
626    Assert(Pos != -1);
627    return Table.Get(Pos).Dat;
628  }
629  template <class TKey, class TDat, uint16 GroupSize>
630  TDat& TSparseHash<TKey, TDat, GroupSize>::GetDat(const TKey& Key) {
631    int Pos, PosToIns;
632    FindPos(Key, Pos, PosToIns);
633    Assert(Pos != -1);
634    return Table.Set(Pos).Dat;
635  }
636  template <class TKey, class TDat, uint16 GroupSize>
637  void TSparseHash<TKey, TDat, GroupSize>::GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
638    Assert(IsKey(KeyId));
639    const THashKeyDat& KeyDat = Table.Get(KeyId);
640    Key = KeyDat.Key;
641    Dat = KeyDat.Dat;
642  }
643  template <class TKey, class TDat, uint16 GroupSize>
644  bool TSparseHash<TKey, TDat, GroupSize>::IsKeyGetDat(const TKey& Key, TDat& Dat) const {
645    int KeyId;
646    if (IsKey(Key, KeyId)) {
647      Dat=Table.Get(KeyId).Dat;
648      return true;
649    } else { return false; }
650  }
651  template <class TKey, class TDat, uint16 GroupSize>
652  void TSparseHash<TKey, TDat, GroupSize>::GetKeyV(TVec<TKey>& KeyV) const {
653    KeyV.Gen(Len(), 0);
654    for (TIter i = BegI(); i < EndI(); i++) {
655      KeyV.Add(i->Key);
656    }
657  }
658  template <class TKey, class TDat, uint16 GroupSize>
659  void TSparseHash<TKey, TDat, GroupSize>::GetDatV(TVec<TDat>& DatV) const {
660    DatV.Gen(Len(), 0);
661    for (TIter i = BegI(); i < EndI(); i++) {
662      DatV.Add(i->Dat);
663    }
664  }
665  template <class TKey, class TDat, uint16 GroupSize>
666  void TSparseHash<TKey, TDat, GroupSize>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
667    KeyDatPrV.Gen(Len(), 0);
668    for (TIter i = BegI(); i < EndI(); i++) {
669      KeyDatPrV.Add(TPair<TKey, TDat>(i->Key, i->Dat));
670    }
671  }
672  template <class TKey, class TDat, uint16 GroupSize>
673  void TSparseHash<TKey, TDat, GroupSize>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
674    DatKeyPrV.Gen(Len(), 0);
675    for (TIter i = BegI(); i < EndI(); i++) {
676      DatKeyPrV.Add(TPair<TDat, TKey>(i->Dat, i->Key));
677    }
678  }
679  template <class TKey, uint16 GroupSize=48> 
680  class TSparseSet {
681  public:
682    typedef typename TSparseTable<TKey, GroupSize>::TIter TIter;
683    typedef typename TSparseTable<TKey, GroupSize>::TSGroup TSGroup;
684  public:
685    static const float MxOccupancy; 
686    static const float MnOccupancy; 
687    static const int MinBuckets;    
688  private:
689    void ResetThresh();
690    int GetMinSize(const int& CurVals, const int& WantedVals) const;
691    void CopyFrom(const TSparseSet& SSet, const int& MnWanted);
692    void MoveFrom(TSparseSet& SSet, const int& MnWanted);
693    void ResizeDelta(const int& ValsToAdd, const int& MnWanted = 0);
694    void FindPos(const TKey& Key, int& Pos, int& PosToIns) const;
695  private:
696    TInt ShrinkThresh, ExpandThresh;
697    TSparseTable<TKey, GroupSize> Table;
698  public:
699    TSparseSet(const int& WantedVals = 0) : Table(GetMinSize(0, WantedVals)) { ResetThresh(); }
700    TSparseSet(TSIn& SIn) : ShrinkThresh(SIn), ExpandThresh(SIn), Table(SIn) { }
701    void Load(TSIn& SIn) { ShrinkThresh.Load(SIn);  ExpandThresh.Load(SIn);  Table.Load(SIn); }
702    void Save(TSOut& SOut) const { ShrinkThresh.Save(SOut); ExpandThresh.Save(SOut); Table.Save(SOut); }
703    TSparseSet& operator = (const TSparseSet& SSet);
704    bool operator == (const TSparseSet& SSet) const;
705    bool operator < (const TSparseSet& SSet) const;
706    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Table.GetMemUsed(); }
707    TIter BegI() const { return Table.BegI(); }
708    TIter EndI() const { return Table.EndI(); }
709    TIter GetI(const int& KeyId) const { Assert(IsKeyId(KeyId));  return Table.GetI(KeyId); }
710    bool Empty() const { return Len() == 0; }
711    int Len() const { return Table.Len(); }
712    int Reserved() const  { return Table.Reserved(); }
713    uint GetDiskSz() const { return 2*sizeof(TInt) + Table.GetDiskSz(); }
714    void Reserve(const int& MxVals) { if (MxVals > Len()) ResizeDelta(MxVals - Len(), 0); }
715    void Clr(const bool& DoDel = true) { Table.Clr(DoDel);  ResetThresh(); }
716    void Swap(TSparseSet& SSet);
717    int AddKey(const TKey& Key);
718    const TKey& GetKey(const int& KeyId) const { return Table.Get(KeyId); }
719    int GetKeyId(const TKey& Key) const { int Pos, PosToIns;
720      FindPos(Key, Pos, PosToIns);  return Pos; }
721    bool IsKey(const TKey& Key) const { return GetKeyId(Key) != -1; }
722    bool IsKey(const TKey& Key, int& KeyId) const {
723      KeyId = GetKeyId(Key);  return KeyId != -1; }
724    bool IsKeyId(const int& KeyId) const { return ! Table.IsEmpty(KeyId); }
725    int GetRndKeyId(TRnd& Rnd = TInt::Rnd) const { Assert(Len()>0);
726      int KeyId = Rnd.GetUniDevInt(Reserved());
727      while (! IsKeyId(KeyId)) { KeyId = Rnd.GetUniDevInt(Reserved()); } return KeyId; }
728    void GetKeyV(TVec<TKey>& KeyV) const;
729  };
730  template <class TKey, uint16 GroupSize>
731  const float TSparseSet<TKey, GroupSize>::MxOccupancy = 0.8f;
732  template <class TKey, uint16 GroupSize>
733  const float TSparseSet<TKey, GroupSize>::MnOccupancy = 0.4f * 0.8f;
734  template <class TKey, uint16 GroupSize>
735  const int TSparseSet<TKey, GroupSize>::MinBuckets = 32;
736  template <class TKey, uint16 GroupSize>
737  void TSparseSet<TKey, GroupSize>::ResetThresh() {
738    ExpandThresh = int(Table.Reserved() * MxOccupancy);
739    ShrinkThresh = int(Table.Reserved() * MnOccupancy);
740  }
741  template <class TKey, uint16 GroupSize>
742  int TSparseSet<TKey, GroupSize>::GetMinSize(const int& CurVals, const int& WantedVals) const {
743    int Size = MinBuckets;
744    while (Size*MxOccupancy <= WantedVals || CurVals > Size * MxOccupancy) Size *= 2;
745    return Size;
746  }
747  template <class TKey, uint16 GroupSize>
748  void TSparseSet<TKey, GroupSize>::CopyFrom(const TSparseSet& SSet, const int& MnWanted) {
749    Clr(false);
750    const int NewSize = GetMinSize(SSet.Reserved(), MnWanted);
751    if (NewSize > Reserved()) {
752      Table.Resize(NewSize);
753      ResetThresh();
754    }
755    const uint BuckM1 = Reserved() - 1;
756    for (int g = 0; g < SSet.Table.Groups(); g++) {
757      const TSGroup& Group = SSet.Table.GetGroup(g);
758      for (int b = 0; b < Group.Len(); b++) {
759        int Tries = 0; uint BuckNum;
760        for (BuckNum = Group.Offset(b).GetPrimHashCd() & BuckM1;
761         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
762          Tries++;
763          Assert(Tries < Reserved());
764        }
765        Table.Set(BuckNum, Group.Offset(b));
766      }
767    }
768  }
769  template <class TKey, uint16 GroupSize>
770  void TSparseSet<TKey, GroupSize>::MoveFrom(TSparseSet& SSet, const int& MnWanted) {
771    Clr(false);
772    int NewSize;
773    if (MnWanted == 0) NewSize = SSet.Reserved();
774    else NewSize = GetMinSize(SSet.Reserved(), MnWanted);
775    if (NewSize > Reserved()) {
776      Table.Resize(NewSize);
777      ResetThresh();
778    }
779    const uint BuckM1 = Reserved() - 1;
780    for (int g = 0; g < SSet.Table.Groups(); g++) {
781      TSGroup& Group = SSet.Table.GetGroup(g);
782      for (int b = 0; b < Group.Len(); b++) {
783        int Tries = 0; uint BuckNum;
784        for (BuckNum = Group.Offset(b).GetPrimHashCd() & BuckM1;
785         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
786          Tries++;
787          Assert(Tries < Reserved());
788        }
789        Assert(Table.IsEmpty(BuckNum));
790        Table.Set(BuckNum, Group.Offset(b));
791      }
792      Group.Clr(true); 
793    }
794  }
795  template <class TKey, uint16 GroupSize>
796  void TSparseSet<TKey, GroupSize>::ResizeDelta(const int& ValsToAdd, const int& MnWanted) {
797    if (Reserved() > MnWanted && Len()+ValsToAdd < ExpandThresh) { return; }
798    const int NewSize = GetMinSize(Table.Len()+ValsToAdd, MnWanted);
799    if (NewSize > Reserved()) {
800      printf("***Resize SparseSet: %d->%d\n", Reserved(), NewSize);
801      TSparseSet TmpSSet(Len()+ValsToAdd);
802      TmpSSet.ResetThresh();
803      TmpSSet.MoveFrom(*this, Len());
804      Swap(TmpSSet);
805    }
806  }
807  template <class TKey, uint16 GroupSize>
808  void TSparseSet<TKey, GroupSize>::FindPos(const TKey& Key, int& Pos, int& PosToIns) const {
809    const uint BuckM1 = Reserved() - 1;
810    uint BuckNum = Key.GetPrimHashCd() & BuckM1;
811    int Tries = 0;
812    while (true) {
813      if (Table.IsEmpty(BuckNum)) {
814        Pos = -1;  PosToIns = BuckNum;  return;
815      }
816      else if (Key == Table.Get(BuckNum)) {
817        Pos = BuckNum;  PosToIns = -1;  return;
818      }
819      Tries++;
820      BuckNum = (BuckNum + Tries) & BuckM1;
821      Assert(Tries < Reserved());
822    }
823  }
824  template <class TKey, uint16 GroupSize>
825  TSparseSet<TKey, GroupSize>& TSparseSet<TKey, GroupSize>::operator = (const TSparseSet& SSet) {
826    if (this != &SSet) {
827      ShrinkThresh = SSet.ShrinkThresh;
828      ExpandThresh = SSet.ExpandThresh;
829      Table = SSet.Table;
830    }
831    return *this;
832  }
833  template <class TKey, uint16 GroupSize>
834  bool TSparseSet<TKey, GroupSize>::operator == (const TSparseSet& SSet) const {
835    return Table == SSet.Table;
836  }
837  template <class TKey, uint16 GroupSize>
838  bool TSparseSet<TKey, GroupSize>::operator < (const TSparseSet& SSet) const {
839    return Table < SSet.Table;
840  }
841  template <class TKey, uint16 GroupSize>
842  void TSparseSet<TKey, GroupSize>::Swap(TSparseSet& SSet) {
843    ::Swap(ShrinkThresh, SSet.ShrinkThresh);
844    ::Swap(ExpandThresh, SSet.ExpandThresh);
845    Table.Swap(SSet.Table);
846  }
847  template <class TKey, uint16 GroupSize>
848  int TSparseSet<TKey, GroupSize>::AddKey(const TKey& Key) {
849    ResizeDelta(1);
850    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
851    if (Pos != -1) { return Pos; } 
852    else {
853      Table.Set(PosToIns, Key);
854      return PosToIns;
855    }
856  }
857  template <class TKey, uint16 GroupSize>
858  void TSparseSet<TKey, GroupSize>::GetKeyV(TVec<TKey>& KeyV) const {
859    KeyV.Gen(Len(), 0);
860    for (TIter I = BegI(); I < EndI(); I++) {
861      KeyV.Add(I()); }
862  }
863  #pragma pack(push, 1) 
864  template <class TKey>
865  class THashSetKey{
866  public:
867    TInt Next;
868    TInt HashCd;
869    TKey Key;
870  public:
871    THashSetKey():
872      Next(-1), HashCd(-1), Key() {}
873    THashSetKey(const int& _Next, const int& _HashCd, const TKey& _Key):
874      Next(_Next), HashCd(_HashCd), Key(_Key) {}
875    explicit THashSetKey(TSIn& SIn):
876      Next(SIn), HashCd(SIn), Key(SIn) {}
877    void Save(TSOut& SOut) const {
878      Next.Save(SOut); HashCd.Save(SOut); Key.Save(SOut); }
879    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="") {
880      XLoadHd(Nm); XLoad(Key); }
881    void SaveXml(TSOut& SOut, const TStr& Nm) const {
882      XSaveHd(Nm); XSave(Key); }
883    THashSetKey& operator=(const THashSetKey& SetKey) {
884      if (this!=&SetKey) { Next=SetKey.Next; HashCd=SetKey.HashCd; Key=SetKey.Key; }
885      return *this; }
886  };
887  #pragma pack(pop)
888  template <class TKey>
889  class THashSetKeyI{
890  public:
891    typedef THashSetKey<TKey> TSetKey;
892  private:
893    TSetKey* KeyI;
894    TSetKey* EndI;
895  public:
896    THashSetKeyI(): KeyI(NULL), EndI(NULL) { }
897    THashSetKeyI(const THashSetKeyI& _SetKeyI):
898      KeyI(_SetKeyI.KeyI), EndI(_SetKeyI.EndI) { }
899    THashSetKeyI(const TSetKey* _KeyI, const TSetKey* _EndI):
900      KeyI((TSetKey*)_KeyI), EndI((TSetKey*)_EndI) { }
901    THashSetKeyI& operator=(const THashSetKeyI& SetKeyI) {
902      KeyI=SetKeyI.KeyI; EndI=SetKeyI.EndI; return *this; }
903    bool operator==(const THashSetKeyI& SetKeyI) const {
904      return KeyI==SetKeyI.KeyI; }
905    bool operator<(const THashSetKeyI& SetKeyI) const {
906      return KeyI<SetKeyI.KeyI; }
907    THashSetKeyI& operator++(int) { KeyI++; while (KeyI < EndI && KeyI->HashCd==-1) { KeyI++; } return *this; }
908    THashSetKeyI& operator--(int) { do { KeyI--; } while (KeyI->HashCd==-1); return *this; }
909    const TKey& operator*() const { return KeyI->Key; }
910    const TKey& operator()() const { return KeyI->Key; }
911    const TKey* operator->() const { return &KeyI->Key; }
912    THashSetKeyI& Next() { operator++(1); return *this; }
913    bool IsEmpty() const { return KeyI == NULL; }
914    bool IsEnd() const { return EndI == KeyI; }
915    const TKey& GetKey() const {Assert((KeyI!=NULL)&&(KeyI->HashCd!=-1)); return KeyI->Key; }
916  };
917  template <class TKey, class THashFunc = TDefaultHashFunc<TKey> >
918  class THashSet{
919  public:
920    typedef THashSetKeyI<TKey> TIter;
921  private:
922    typedef THashSetKey<TKey> TSetKey;
923    TIntV PortV;
924    TVec<TSetKey> KeyV;
925    TBool AutoSizeP;
926    TInt FFreeKeyId, FreeKeys;
927  private:
928    TSetKey& GetSetKey(const int& KeyId) {
929      TSetKey& SetKey=KeyV[KeyId];
930      Assert(SetKey.HashCd!=-1); return SetKey; }
931    const TSetKey& GetSetKey(const int& KeyId) const {
932      const TSetKey& SetKey=KeyV[KeyId];
933      Assert(SetKey.HashCd!=-1); return SetKey; }
934    uint GetNextPrime(const uint& Val) const;
935    void Resize();
936  public:
937    THashSet():
938      PortV(), KeyV(),
939      AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0) { }
940    THashSet(const THashSet& Set):
941      PortV(Set.PortV), KeyV(Set.KeyV), AutoSizeP(Set.AutoSizeP),
942      FFreeKeyId(Set.FFreeKeyId), FreeKeys(Set.FreeKeys) { }
943    THashSet(const int& ExpectVals, const bool& _AutoSizeP=false);
944    explicit THashSet(const TVec<TKey>& KeyV);
945    explicit THashSet(TSIn& SIn):
946      PortV(SIn), KeyV(SIn),
947      AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn) {
948      SIn.LoadCs(); }
949    void Load(TSIn& SIn) {
950      PortV.Load(SIn); KeyV.Load(SIn);
951      AutoSizeP=TBool(SIn); FFreeKeyId=TInt(SIn); FreeKeys=TInt(SIn);
952      SIn.LoadCs(); }
953    void Save(TSOut& SOut) const {
954      PortV.Save(SOut); KeyV.Save(SOut);
955      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut);
956      SOut.SaveCs(); }
957    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="") {
958      XLoadHd(Nm); TVec<TSetKey> KeyV; XLoad(KeyV); XLoad(AutoSizeP);
959      for (int KeyN=0; KeyN<KeyV.Len(); KeyN++) {
960        AddKey(KeyV[KeyN].Key); }}
961    void SaveXml(TSOut& SOut, const TStr& Nm) {
962      Defrag(); XSaveHd(Nm); XSave(KeyV); XSave(AutoSizeP); }
963    THashSet& operator=(const THashSet& Set) {
964      if (this!=&Set) {
965        PortV=Set.PortV; KeyV=Set.KeyV; AutoSizeP=Set.AutoSizeP;
966        FFreeKeyId=Set.FFreeKeyId; FreeKeys=Set.FreeKeys; }
967      return *this; }
968    bool operator==(const THashSet& Set) const;
969    const TKey& operator[](const int& KeyId) const {return GetSetKey(KeyId).Key; }
970    TKey& operator[](const int& KeyId) {return GetSetKey(KeyId).Key; }
971    ::TSize GetMemUsed() const {
972      return PortV.GetMemUsed() + KeyV.GetMemUsed() + sizeof(bool) + 2*sizeof(int); }
973    TIter BegI() const {
974      if (Len()>0) {
975        if (IsKeyIdEqKeyN()) { return TIter(KeyV.BegI(), KeyV.EndI()); }
976        int FKeyId=-1;  FNextKeyId(FKeyId);
977        return TIter(KeyV.BegI()+FKeyId, KeyV.EndI()); }
978      return TIter(KeyV.EndI(), KeyV.EndI());
979    }
980    TIter EndI() const {return TIter(KeyV.EndI(), KeyV.EndI()); }
981    TIter GetI(const TKey& Key) const {return TIter(&KeyV[GetKeyId(Key)], KeyV.EndI()); }
982    void Gen(const int& ExpectVals) {
983      PortV.Gen(GetNextPrime(ExpectVals/2)); KeyV.Gen(ExpectVals, 0);
984      FFreeKeyId=-1; FreeKeys=0; PortV.PutAll(TInt(-1)); }
985    void Clr(const bool& DoDel=true, const int& NoDelLim=-1);
986    bool Empty() const {return Len()==0; }
987    int Len() const {return KeyV.Len()-FreeKeys; }
988    int GetPorts() const {return PortV.Len(); }
989    bool IsAutoSize() const {return AutoSizeP; }
990    int GetMxKeyIds() const {return KeyV.Len(); }
991    int GetReservedKeyIds() const { return KeyV.Reserved(); }
992    bool IsKeyIdEqKeyN() const {return FreeKeys==0; }
993    int AddKey(const TKey& Key);
994    void AddKeyV(const TVec<TKey>& KeyV);
995    void DelKey(const TKey& Key);
996    bool DelIfKey(const TKey& Key) {
997      int KeyId; if (IsKey(Key, KeyId)) {DelKeyId(KeyId); return true;} return false;}
998    void DelKeyId(const int& KeyId) {DelKey(GetKey(KeyId)); }
999    void DelKeyIdV(const TIntV& KeyIdV) {
1000      for (int KeyIdN=0; KeyIdN<KeyIdV.Len(); KeyIdN++) {DelKeyId(KeyIdV[KeyIdN]); }}
1001    void MarkDelKey(const TKey& Key);
1002    void MarkDelKeyId(const int& KeyId) {MarkDelKey(GetKey(KeyId)); }
1003    const TKey& GetKey(const int& KeyId) const {
1004      return GetSetKey(KeyId).Key; }
1005    int GetKeyId(const TKey& Key) const;
1006    int GetRndKeyId(TRnd& Rnd) const {
1007      IAssert(IsKeyIdEqKeyN());
1008      IAssert(Len()>0);
1009      return Rnd.GetUniDevInt(Len()); }
1010    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1; }
1011    bool IsKey(const TKey& Key, int& KeyId) const {
1012      KeyId=GetKeyId(Key); return KeyId!=-1; }
1013    bool IsKeyId(const int& KeyId) const {
1014      return (0<=KeyId)&&(KeyId<KeyV.Len())&&(KeyV[KeyId].HashCd!=-1); }
1015    int FFirstKeyId() const {return 0-1; }
1016    bool FNextKeyId(int& KeyId) const;
1017    void GetKeyV(TVec<TKey>& KeyV) const;
1018    void Swap(THashSet& Set);
1019    void Defrag();
1020    void Pack() {KeyV.Pack(); }
1021    static THashSet<TKey> GetSet(const TKey& Key1){
1022  	THashSet<TKey> Set(1); Set.AddKey(Key1); return Set;}
1023    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2){
1024      THashSet<TKey> Set(2); Set.AddKey(Key1); Set.AddKey(Key2); return Set;}
1025    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3){
1026      THashSet<TKey> Set(3); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); return Set;}
1027    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4){
1028      THashSet<TKey> Set(4); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); return Set;}
1029    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5){
1030      THashSet<TKey> Set(5); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); return Set;}
1031    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6){
1032      THashSet<TKey> Set(6); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); return Set;}
1033    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7){
1034      THashSet<TKey> Set(7); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); return Set;}
1035    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7, const TKey& Key8){
1036      THashSet<TKey> Set(8); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); Set.AddKey(Key8); return Set;}
1037    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7, const TKey& Key8, const TKey& Key9){
1038      THashSet<TKey> Set(9); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); Set.AddKey(Key8); Set.AddKey(Key9); return Set;}
1039  };
1040  template <class TKey, class THashFunc>
1041  uint THashSet<TKey, THashFunc>::GetNextPrime(const uint& Val) const {
1042    uint* f=(uint*)TIntH::HashPrimeT, *m, *l=(uint*)TIntH::HashPrimeT + (int)TIntH::HashPrimes;
1043    int h, len = (int)TIntH::HashPrimes;
1044    while (len > 0) {
1045      h = len >> 1;  m = f + h;
1046      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
1047      else len = h;
1048    }
1049    return f == l ? *(l - 1) : *f;
1050  }
1051  template <class TKey, class THashFunc>
1052  void THashSet<TKey, THashFunc>::Resize() {
1053    if (PortV.Len()==0) {PortV.Gen(17); }
1054    else if (AutoSizeP&&(KeyV.Len()>2*PortV.Len())) {
1055      PortV.Gen(GetNextPrime(PortV.Len()+1));
1056    } else {
1057      return;
1058    }
1059    PortV.PutAll(TInt(-1));
1060    for (int KeyId=0; KeyId<KeyV.Len(); KeyId++) {
1061      TSetKey& SetKey=KeyV[KeyId];
1062      if (SetKey.HashCd!=-1) {
1063        int PortN=abs(THashFunc::GetPrimHashCd(SetKey.Key)%PortV.Len());
1064        SetKey.Next=PortV[PortN];
1065        PortV[PortN]=KeyId;
1066      }
1067    }
1068  }
1069  template <class TKey, class THashFunc>
1070  THashSet<TKey, THashFunc>::THashSet(const int& ExpectVals, const bool& _AutoSizeP):
1071    PortV(GetNextPrime(ExpectVals/2+1)), KeyV(ExpectVals, 0),
1072    AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0) {
1073    PortV.PutAll(TInt(-1));
1074  }
1075  template <class TKey, class THashFunc>
1076  THashSet<TKey, THashFunc>::THashSet(const TVec<TKey>& _KeyV) :
1077   PortV(GetNextPrime(_KeyV.Len()/2+1)), KeyV(_KeyV.Len(), 0),
1078   AutoSizeP(false), FFreeKeyId(-1), FreeKeys(0) {
1079    PortV.PutAll(TInt(-1));
1080    for (int i = 0; i < _KeyV.Len(); i++) {
1081      AddKey(_KeyV[i]);
1082    }
1083  }
1084  template <class TKey, class THashFunc>
1085  bool THashSet<TKey, THashFunc>::operator==(const THashSet& Set) const {
1086    if (Len() != Set.Len()) { return false; }
1087    for (int k = FFirstKeyId(); FNextKeyId(k); k++) {
1088      if (! Set.IsKey(GetKey(k))) { return false; }
1089    }
1090    return true;
1091  }
1092  template <class TKey, class THashFunc>
1093  void THashSet<TKey, THashFunc>::Clr(const bool& DoDel, const int& NoDelLim) {
1094    if (DoDel) {
1095      PortV.Clr(); KeyV.Clr();
1096    } else {
1097      PortV.PutAll(TInt(-1));
1098      KeyV.Clr(DoDel, NoDelLim);
1099    }
1100    FFreeKeyId=TInt(-1); FreeKeys=TInt(0);
1101  }
1102  template <class TKey, class THashFunc>
1103  int THashSet<TKey, THashFunc>::AddKey(const TKey& Key) {
1104    if ((KeyV.Len()>2*PortV.Len())||PortV.Empty()) {Resize(); }
1105    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1106    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1107    int PrevKeyId=-1;
1108    int KeyId=PortV[PortN];
1109    while ((KeyId!=-1) &&
1110     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1111      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1112    if (KeyId==-1) {
1113      if (FFreeKeyId==-1) {
1114        KeyId=KeyV.Add(TSetKey(-1, HashCd, Key));
1115      } else {
1116        KeyId=FFreeKeyId; FFreeKeyId=KeyV[FFreeKeyId].Next; FreeKeys--;
1117        KeyV[KeyId].Next = -1;
1118        KeyV[KeyId].HashCd = HashCd;
1119        KeyV[KeyId].Key = Key;
1120      }
1121      if (PrevKeyId==-1) {
1122        PortV[PortN]=KeyId;
1123      } else {
1124        KeyV[PrevKeyId].Next=KeyId;
1125      }
1126    }
1127    return KeyId;
1128  }
1129  template <class TKey, class THashFunc>
1130  void THashSet<TKey, THashFunc>::AddKeyV(const TVec<TKey>& KeyV) {
1131    for (int i = 0; i < KeyV.Len(); i++) { AddKey(KeyV[i]); }
1132  }
1133  template <class TKey, class THashFunc>
1134  void THashSet<TKey, THashFunc>::DelKey(const TKey& Key) {
1135    IAssert(!PortV.Empty());
1136    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1137    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1138    int PrevKeyId=-1;
1139    int KeyId=PortV[PortN];
1140    while ((KeyId!=-1) &&
1141     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1142      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1143    IAssertR(KeyId!=-1, Key.GetStr());
1144    if (PrevKeyId==-1) {PortV[PortN]=KeyV[KeyId].Next; }
1145    else {KeyV[PrevKeyId].Next=KeyV[KeyId].Next; }
1146    KeyV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
1147    KeyV[KeyId].HashCd=TInt(-1);
1148    KeyV[KeyId].Key=TKey();
1149  }
1150  template <class TKey, class THashFunc>
1151  void THashSet<TKey, THashFunc>::MarkDelKey(const TKey& Key) {
1152    IAssert(!PortV.Empty());
1153    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1154    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1155    int PrevKeyId=-1;
1156    int KeyId=PortV[PortN];
1157    while ((KeyId!=-1) &&
1158     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1159      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1160    IAssertR(KeyId!=-1, Key.GetStr());
1161    if (PrevKeyId==-1) {PortV[PortN]=KeyV[KeyId].Next; }
1162    else {KeyV[PrevKeyId].Next=KeyV[KeyId].Next; }
1163    KeyV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
1164    KeyV[KeyId].HashCd=TInt(-1);
1165  }
1166  template <class TKey, class THashFunc>
1167  int THashSet<TKey, THashFunc>::GetKeyId(const TKey& Key) const {
1168    if (PortV.Empty()) {return -1; }
1169    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1170    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1171    int KeyId=PortV[PortN];
1172    while ((KeyId!=-1) &&
1173     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1174      KeyId=KeyV[KeyId].Next; }
1175    return KeyId;
1176  }
1177  template <class TKey, class THashFunc>
1178  bool THashSet<TKey, THashFunc>::FNextKeyId(int& KeyId) const {
1179    do {KeyId++; } while ((KeyId<KeyV.Len())&&(KeyV[KeyId].HashCd==-1));
1180    return KeyId<KeyV.Len();
1181  }
1182  template <class TKey, class THashFunc>
1183  void THashSet<TKey, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
1184    KeyV.Clr();
1185    int KeyId=FFirstKeyId();
1186    while (FNextKeyId(KeyId)) {
1187      KeyV.Add(GetKey(KeyId)); }
1188  }
1189  template <class TKey, class THashFunc>
1190  void THashSet<TKey, THashFunc>::Swap(THashSet& Set) {
1191    if (this!=&Set) {
1192      PortV.Swap(Set.PortV);
1193      KeyV.Swap(Set.KeyV);
1194      ::Swap(AutoSizeP, Set.AutoSizeP);
1195      ::Swap(FFreeKeyId, Set.FFreeKeyId);
1196      ::Swap(FreeKeys, Set.FreeKeys);
1197    }
1198  }
1199  template <class TKey, class THashFunc>
1200  void THashSet<TKey, THashFunc>::Defrag() {
1201    if (!IsKeyIdEqKeyN()) {
1202      THashSet<TKey> Set(PortV.Len());
1203      int KeyId=FFirstKeyId();
1204      while (FNextKeyId(KeyId)) {
1205        Set.AddKey(GetKey(KeyId));
1206      }
1207      Pack();
1208      operator=(Set);
1209      IAssert(IsKeyIdEqKeyN());
1210    }
1211  }
1212  typedef THashSet<TUCh> TUChSet;
1213  typedef THashSet<TInt> TIntSet;
1214  typedef THashSet<TUInt64> TUInt64Set;
1215  typedef THashSet<TFlt> TFltSet;
1216  typedef THashSet<TStr> TStrSet;
1217  typedef THashSet<TUChIntPr> TUChIntPrSet;
1218  typedef THashSet<TUChUInt64Pr> TUChUInt64PrSet;
1219  typedef THashSet<TIntPr> TIntPrSet;
1220  template<class TVal>
1221  class TPackVec {
1222  public:
1223    typedef TVal* TIter;
1224  private:
1225    int Vals;
1226    TVal* ValT;
1227    void ResizeDelta(const int& ValsToAdd=1);
1228  public:
1229    TPackVec() : Vals(0), ValT(NULL) { }
1230    TPackVec(const TPackVec& Vec) : Vals(0), ValT(NULL) {
1231      Gen(Vec.Len());
1232      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals);
1233    }
1234    explicit TPackVec(const int& _Vals) : Vals(_Vals) {
1235      if (Vals==0) { ValT=NULL; } else { ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals); } }
1236    ~TPackVec() { if (ValT != NULL) { free(ValT); } }
1237    explicit TPackVec(TSIn& SIn): Vals(0), ValT(NULL) { Load(SIn); }
1238    void Load(TSIn& SIn);
1239    void Save(TSOut& SOut) const;
1240    const TVal& operator [] (const int& ValN) const { return ValT[ValN]; }
1241    TVal& operator [] (const int& ValN) { return ValT[ValN]; }
1242    TPackVec<TVal>& operator = (const TPackVec<TVal>& Vec) { Gen(Vec.Len());
1243      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals); return *this; }
1244    TVec<TVal>& operator = (const TVec<TVal>& Vec) { Gen(Vec.Len());
1245      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals); return *this; }
1246    void Gen(const int& _Vals) {
1247      if (ValT != NULL) { free(ValT); } Vals = _Vals;
1248      if (Vals==0) { ValT=NULL; } else { ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals); } }
1249    void Clr() { if (ValT != NULL) { free(ValT); ValT=NULL; } Vals = 0; }
1250    bool Empty() const {return Vals==0; }
1251    int Len() const {return Vals; }
1252    const TVal& Last() const { return ValT[Len()-1]; }
1253    TVal& Last() { return ValT[Len()-1]; }
1254    TIter BegI() const {return ValT; }
1255    TIter EndI() const {return ValT+Vals; }
1256    TIter GetI(const int& ValN) const { return ValT+ValN; }
1257    void Add(const TVal& Val) { ResizeDelta(1); ValT[Vals-1]=Val; }
1258    void AddV(const TPackVec<TVal>& ValV) { ResizeDelta(ValV.Len());
1259      memcpy(ValT+Vals-ValV.Len(), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1260    void AddV(const TVec<TVal>& ValV) { ResizeDelta(ValV.Len());
1261      memcpy(ValT+Vals-ValV.Len(), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1262    void AddV(TSIn& FIn) { int NVals;  FIn.Load(NVals);
1263      ResizeDelta(NVals);  FIn.LoadBf(ValT+Vals-NVals, sizeof(TVal)*NVals); }
1264    void Sort(const bool& Asc=true) {
1265      if (Asc) { TVec<TVal>::QSortCmp(BegI(), EndI(), TLss<TVal>()); }
1266      else { TVec<TVal>::QSortCmp(BegI(), EndI(), TGtr<TVal>()); }
1267    }
1268  };
1269  template<class TVal>
1270  void TPackVec<TVal>::ResizeDelta(const int& ValsToAdd) {
1271    if (ValsToAdd == 0) return;
1272    Vals += ValsToAdd;
1273    ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals);
1274    EAssert(ValT != NULL);
1275  }
1276  template<class TVal>
1277  void TPackVec<TVal>::Load(TSIn& SIn) {
1278    SIn.Load(Vals);
1279    if (Vals==0) {
1280      if (ValT != NULL) { free(ValT); }
1281      ValT = NULL; }
1282    else {
1283      ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals);
1284    }
1285    SIn.LoadBf(ValT, sizeof(TVal)*Vals);
1286  }
1287  template<class TVal>
1288  void TPackVec<TVal>::Save(TSOut& SOut) const {
1289    SOut.Save(Vals);
1290    if (Vals != 0) {
1291      SOut.SaveBf(ValT, sizeof(TVal)*Vals); }
1292  }
1293  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexObjC.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-shash.h</div>
                </div>
                <div class="column column_space"><pre><code>474                      styler.SetLevel(line, styler.LevelAt(line));
475                  }
</pre></code></div>
                <div class="column column_space"><pre><code>539        Table.Set(BuckNum, Group.Offset(b));
540      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    