<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for endgame_1.cpp &amp; endgame.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for endgame_1.cpp &amp; endgame.cpp
      </h3>
<h1 align="center">
        95.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>endgame_1.cpp (96.86192%)<th>endgame.cpp (95.07187%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(133-848)<td><a href="#" name="0">(141-856)</a><td align="center"><font color="#ff0000">418</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(28-99)<td><a href="#" name="1">(28-99)</a><td align="center"><font color="#1b0000">45</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>endgame_1.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
  Copyright (C) 2004-2008 Tord Romstad (Glaurung author)
  Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad

  Stockfish is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Stockfish is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

#include &lt;algorithm&gt;
#include &lt;cassert&gt;

#include "bitboard.h"
#include "bitcount.h"
<a name="1"></a>#include "endgame.h"
#include "movegen.h"

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>using std::string;

namespace {

  // Table used to drive the king towards the edge of the board
  // in KX vs K and KQ vs KR endgames.
  const int PushToEdges[SQUARE_NB] = {
    100, 90, 80, 70, 70, 80, 90, 100,
     90, 70, 60, 50, 50, 60, 70,  90,
     80, 60, 40, 30, 30, 40, 60,  80,
     70, 50, 30, 20, 20, 30, 50,  70,
     70, 50, 30, 20, 20, 30, 50,  70,
     80, 60, 40, 30, 30, 40, 60,  80,
     90, 70, 60, 50, 50, 60, 70,  90,
    100, 90, 80, 70, 70, 80, 90, 100,
  };

  // Table used to drive the king towards a corner square of the
  // right color in KBN vs K endgames.
  const int PushToCorners[SQUARE_NB] = {
    200, 190, 180, 170, 160, 150, 140, 130,
    190, 180, 170, 160, 150, 140, 130, 140,
    180, 170, 155, 140, 140, 125, 140, 150,
    170, 160, 140, 120, 110, 140, 150, 160,
    160, 150, 140, 110, 120, 140, 160, 170,
    150, 140, 125, 140, 140, 155, 170, 180,
    140, 130, 140, 150, 160, 170, 180, 190,
    130, 140, 150, 160, 170, 180, 190, 200
  };

  // Tables used to drive a piece towards or away from another piece
  const int PushClose[8] = { 0, 0, 100, 80, 60, 40, 20, 10 };
  const int PushAway [8] = { 0, 5, 20, 40, 60, 80, 90, 100 };

#ifndef NDEBUG
  bool verify_material(const Position&amp; pos, Color c, Value npm, int num_pawns) {
    return pos.non_pawn_material(c) == npm &amp;&amp; pos.count&lt;PAWN&gt;(c) == num_pawns;
  }
#endif

  // Map the square as if strongSide is white and strongSide's only pawn
  // is on the left half of the board.
  Square normalize(const Position&amp; pos, Color strongSide, Square sq) {

    assert(pos.count&lt;PAWN&gt;(strongSide) == 1);

    if (file_of(pos.list&lt;PAWN&gt;(strongSide)[0]) &gt;= FILE_E)
        sq = Square(sq ^ 7); // Mirror SQ_H1 -&gt; SQ_A1

    if (strongSide == BLACK)
        sq = ~sq;

    return sq;
  }

  // Get the material key of Position out of the given endgame key code
  // like "KBPKN". The trick here is to first forge an ad-hoc FEN string
  // and then let a Position object do the work for us.
  Key key(const string&amp; code, Color c) {

    assert(code.length() &gt; 0 &amp;&amp; code.length() &lt; 8);
    assert(code[0] == 'K');

    string sides[] = { code.substr(code.find('K', 1)),      // Weak
                       code.substr(0, code.find('K', 1)) }; // Strong

    std::transform(sides[c].begin(), sides[c].end(), sides[c].begin(), tolower);

    string fen =  sides[0] + char(8 - sides[0].length() + '0') + "/8/8/8/8/8/8/"
                + sides[1] + char(8 - sides[1].length() + '0') + " w - - 0 10";

    return Position(fen, false, nullptr).material_key();</b></font>
  }

} // namespace


/// Endgames members definitions

Endgames::Endgames() {

  add&lt;KPK&gt;("KPK");
  add&lt;KNNK&gt;("KNNK");
  add&lt;KBNK&gt;("KBNK");
  add&lt;KRKP&gt;("KRKP");
  add&lt;KRKB&gt;("KRKB");
  add&lt;KRKN&gt;("KRKN");
  add&lt;KQKP&gt;("KQKP");
  add&lt;KQKR&gt;("KQKR");

  add&lt;KNPK&gt;("KNPK");
  add&lt;KNPKB&gt;("KNPKB");
  add&lt;KRPKR&gt;("KRPKR");
  add&lt;KRPKB&gt;("KRPKB");
  add&lt;KBPKB&gt;("KBPKB");
  add&lt;KBPKN&gt;("KBPKN");
  add&lt;KBPPKB&gt;("KBPPKB");
  add&lt;KRPPKRP&gt;("KRPPKRP");
}


template&lt;EndgameType E, typename T&gt;
<a name="0"></a>void Endgames::add(const string&amp; code) {

  map&lt;T&gt;()[key(code, WHITE)] = std::unique_ptr&lt;T&gt;(new Endgame&lt;E&gt;(WHITE));
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  map&lt;T&gt;()[key(code, BLACK)] = std::unique_ptr&lt;T&gt;(new Endgame&lt;E&gt;(BLACK));
}


/// Mate with KX vs K. This function is used to evaluate positions with
/// king and plenty of material vs a lone king. It simply gives the
/// attacking side a bonus for driving the defending king towards the edge
/// of the board, and for keeping the distance between the two kings small.
template&lt;&gt;
Value Endgame&lt;KXK&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
  assert(!pos.checkers()); // Eval is never called when in check

  // Stalemate detection with lone king
  if (pos.side_to_move() == weakSide &amp;&amp; !MoveList&lt;LEGAL&gt;(pos).size())
      return VALUE_DRAW;

  Square winnerKSq = pos.king_square(strongSide);
  Square loserKSq = pos.king_square(weakSide);

  Value result =  pos.non_pawn_material(strongSide)
                + pos.count&lt;PAWN&gt;(strongSide) * PawnValueEg
                + PushToEdges[loserKSq]
                + PushClose[square_distance(winnerKSq, loserKSq)];

  if (   pos.count&lt;QUEEN&gt;(strongSide)
      || pos.count&lt;ROOK&gt;(strongSide)
      ||(pos.count&lt;BISHOP&gt;(strongSide) &amp;&amp; pos.count&lt;KNIGHT&gt;(strongSide))
      || pos.bishop_pair(strongSide))
      result += VALUE_KNOWN_WIN;

  return strongSide == pos.side_to_move() ? result : -result;
}


/// Mate with KBN vs K. This is similar to KX vs K, but we have to drive the
/// defending king towards a corner square of the right color.
template&lt;&gt;
Value Endgame&lt;KBNK&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, KnightValueMg + BishopValueMg, 0));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));

  Square winnerKSq = pos.king_square(strongSide);
  Square loserKSq = pos.king_square(weakSide);
  Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];

  // kbnk_mate_table() tries to drive toward corners A1 or H8. If we have a
  // bishop that cannot reach the above squares, we flip the kings in order
  // to drive the enemy toward corners A8 or H1.
  if (opposite_colors(bishopSq, SQ_A1))
  {
      winnerKSq = ~winnerKSq;
      loserKSq  = ~loserKSq;
  }

  Value result =  VALUE_KNOWN_WIN
                + PushClose[square_distance(winnerKSq, loserKSq)]
                + PushToCorners[loserKSq];

  return strongSide == pos.side_to_move() ? result : -result;
}


/// KP vs K. This endgame is evaluated with the help of a bitbase.
template&lt;&gt;
Value Endgame&lt;KPK&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, VALUE_ZERO, 1));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));

  // Assume strongSide is white and the pawn is on files A-D
  Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
  Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
  Square psq  = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);

  Color us = strongSide == pos.side_to_move() ? WHITE : BLACK;

  if (!Bitbases::probe_kpk(wksq, psq, bksq, us))
      return VALUE_DRAW;

  Value result = VALUE_KNOWN_WIN + PawnValueEg + Value(rank_of(psq));

  return strongSide == pos.side_to_move() ? result : -result;
}


/// KR vs KP. This is a somewhat tricky endgame to evaluate precisely without
/// a bitbase. The function below returns drawish scores when the pawn is
/// far advanced with support of the king, while the attacking king is far
/// away.
template&lt;&gt;
Value Endgame&lt;KRKP&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 0));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 1));

  Square wksq = relative_square(strongSide, pos.king_square(strongSide));
  Square bksq = relative_square(strongSide, pos.king_square(weakSide));
  Square rsq  = relative_square(strongSide, pos.list&lt;ROOK&gt;(strongSide)[0]);
  Square psq  = relative_square(strongSide, pos.list&lt;PAWN&gt;(weakSide)[0]);

  Square queeningSq = make_square(file_of(psq), RANK_1);
  Value result;

  // If the stronger side's king is in front of the pawn, it's a win
  if (wksq &lt; psq &amp;&amp; file_of(wksq) == file_of(psq))
      result = RookValueEg - square_distance(wksq, psq);

  // If the weaker side's king is too far from the pawn and the rook,
  // it's a win.
  else if (   square_distance(bksq, psq) &gt;= 3 + (pos.side_to_move() == weakSide)
           &amp;&amp; square_distance(bksq, rsq) &gt;= 3)
      result = RookValueEg - square_distance(wksq, psq);

  // If the pawn is far advanced and supported by the defending king,
  // the position is drawish
  else if (   rank_of(bksq) &lt;= RANK_3
           &amp;&amp; square_distance(bksq, psq) == 1
           &amp;&amp; rank_of(wksq) &gt;= RANK_4
           &amp;&amp; square_distance(wksq, psq) &gt; 2 + (pos.side_to_move() == strongSide))
      result = Value(80) - 8 * square_distance(wksq, psq);

  else
      result =  Value(200) - 8 * (  square_distance(wksq, psq + DELTA_S)
                                  - square_distance(bksq, psq + DELTA_S)
                                  - square_distance(psq, queeningSq));

  return strongSide == pos.side_to_move() ? result : -result;
}


/// KR vs KB. This is very simple, and always returns drawish scores.  The
/// score is slightly bigger when the defending king is close to the edge.
template&lt;&gt;
Value Endgame&lt;KRKB&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 0));
  assert(verify_material(pos, weakSide, BishopValueMg, 0));

  Value result = Value(PushToEdges[pos.king_square(weakSide)]);
  return strongSide == pos.side_to_move() ? result : -result;
}


/// KR vs KN. The attacking side has slightly better winning chances than
/// in KR vs KB, particularly if the king and the knight are far apart.
template&lt;&gt;
Value Endgame&lt;KRKN&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 0));
  assert(verify_material(pos, weakSide, KnightValueMg, 0));

  Square bksq = pos.king_square(weakSide);
  Square bnsq = pos.list&lt;KNIGHT&gt;(weakSide)[0];
  Value result = Value(PushToEdges[bksq] + PushAway[square_distance(bksq, bnsq)]);
  return strongSide == pos.side_to_move() ? result : -result;
}


/// KQ vs KP. In general, this is a win for the stronger side, but there are a
/// few important exceptions. A pawn on 7th rank and on the A,C,F or H files
/// with a king positioned next to it can be a draw, so in that case, we only
/// use the distance between the kings.
template&lt;&gt;
Value Endgame&lt;KQKP&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, QueenValueMg, 0));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 1));

  Square winnerKSq = pos.king_square(strongSide);
  Square loserKSq = pos.king_square(weakSide);
  Square pawnSq = pos.list&lt;PAWN&gt;(weakSide)[0];

  Value result = Value(PushClose[square_distance(winnerKSq, loserKSq)]);

  if (   relative_rank(weakSide, pawnSq) != RANK_7
      || square_distance(loserKSq, pawnSq) != 1
      || !((FileABB | FileCBB | FileFBB | FileHBB) &amp; pawnSq))
      result += QueenValueEg - PawnValueEg;

  return strongSide == pos.side_to_move() ? result : -result;
}


/// KQ vs KR.  This is almost identical to KX vs K:  We give the attacking
/// king a bonus for having the kings close together, and for forcing the
/// defending king towards the edge. If we also take care to avoid null move for
/// the defending side in the search, this is usually sufficient to win KQ vs KR.
template&lt;&gt;
Value Endgame&lt;KQKR&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, QueenValueMg, 0));
  assert(verify_material(pos, weakSide, RookValueMg, 0));

  Square winnerKSq = pos.king_square(strongSide);
  Square loserKSq = pos.king_square(weakSide);

  Value result =  QueenValueEg
                - RookValueEg
                + PushToEdges[loserKSq]
                + PushClose[square_distance(winnerKSq, loserKSq)];

  return strongSide == pos.side_to_move() ? result : -result;
}


/// Some cases of trivial draws
template&lt;&gt; Value Endgame&lt;KNNK&gt;::operator()(const Position&amp;) const { return VALUE_DRAW; }


/// KB and one or more pawns vs K. It checks for draws with rook pawns and
/// a bishop of the wrong color. If such a draw is detected, SCALE_FACTOR_DRAW
/// is returned. If not, the return value is SCALE_FACTOR_NONE, i.e. no scaling
/// will be used.
template&lt;&gt;
ScaleFactor Endgame&lt;KBPsK&gt;::operator()(const Position&amp; pos) const {

  assert(pos.non_pawn_material(strongSide) == BishopValueMg);
  assert(pos.count&lt;PAWN&gt;(strongSide) &gt;= 1);

  // No assertions about the material of weakSide, because we want draws to
  // be detected even when the weaker side has some pawns.

  Bitboard pawns = pos.pieces(strongSide, PAWN);
  File pawnFile = file_of(pos.list&lt;PAWN&gt;(strongSide)[0]);

  // All pawns are on a single rook file ?
  if (    (pawnFile == FILE_A || pawnFile == FILE_H)
      &amp;&amp; !(pawns &amp; ~file_bb(pawnFile)))
  {
      Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
      Square queeningSq = relative_square(strongSide, make_square(pawnFile, RANK_8));
      Square kingSq = pos.king_square(weakSide);

      if (   opposite_colors(queeningSq, bishopSq)
          &amp;&amp; square_distance(queeningSq, kingSq) &lt;= 1)
          return SCALE_FACTOR_DRAW;
  }

  // If all the pawns are on the same B or G file, then it's potentially a draw
  if (    (pawnFile == FILE_B || pawnFile == FILE_G)
      &amp;&amp; !(pos.pieces(PAWN) &amp; ~file_bb(pawnFile))
      &amp;&amp; pos.non_pawn_material(weakSide) == 0
      &amp;&amp; pos.count&lt;PAWN&gt;(weakSide) &gt;= 1)
  {
      // Get weakSide pawn that is closest to the home rank
      Square weakPawnSq = backmost_sq(weakSide, pos.pieces(weakSide, PAWN));

      Square strongKingSq = pos.king_square(strongSide);
      Square weakKingSq = pos.king_square(weakSide);
      Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];

      // There's potential for a draw if our pawn is blocked on the 7th rank,
      // the bishop cannot attack it or they only have one pawn left
      if (   relative_rank(strongSide, weakPawnSq) == RANK_7
          &amp;&amp; (pos.pieces(strongSide, PAWN) &amp; (weakPawnSq + pawn_push(weakSide)))
          &amp;&amp; (opposite_colors(bishopSq, weakPawnSq) || pos.count&lt;PAWN&gt;(strongSide) == 1))
      {
          int strongKingDist = square_distance(weakPawnSq, strongKingSq);
          int weakKingDist = square_distance(weakPawnSq, weakKingSq);

          // It's a draw if the weak king is on its back two ranks, within 2
          // squares of the blocking pawn and the strong king is not
          // closer. (I think this rule only fails in practically
          // unreachable positions such as 5k1K/6p1/6P1/8/8/3B4/8/8 w
          // and positions where qsearch will immediately correct the
          // problem such as 8/4k1p1/6P1/1K6/3B4/8/8/8 w)
          if (   relative_rank(strongSide, weakKingSq) &gt;= RANK_7
              &amp;&amp; weakKingDist &lt;= 2
              &amp;&amp; weakKingDist &lt;= strongKingDist)
              return SCALE_FACTOR_DRAW;
      }
  }

  return SCALE_FACTOR_NONE;
}


/// KQ vs KR and one or more pawns. It tests for fortress draws with a rook on
/// the third rank defended by a pawn.
template&lt;&gt;
ScaleFactor Endgame&lt;KQKRPs&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, QueenValueMg, 0));
  assert(pos.count&lt;ROOK&gt;(weakSide) == 1);
  assert(pos.count&lt;PAWN&gt;(weakSide) &gt;= 1);

  Square kingSq = pos.king_square(weakSide);
  Square rsq = pos.list&lt;ROOK&gt;(weakSide)[0];

  if (    relative_rank(weakSide, kingSq) &lt;= RANK_2
      &amp;&amp;  relative_rank(weakSide, pos.king_square(strongSide)) &gt;= RANK_4
      &amp;&amp;  relative_rank(weakSide, rsq) == RANK_3
      &amp;&amp; (  pos.pieces(weakSide, PAWN)
          &amp; pos.attacks_from&lt;KING&gt;(kingSq)
          &amp; pos.attacks_from&lt;PAWN&gt;(rsq, strongSide)))
          return SCALE_FACTOR_DRAW;

  return SCALE_FACTOR_NONE;
}


/// KRP vs KR. This function knows a handful of the most important classes of
/// drawn positions, but is far from perfect. It would probably be a good idea
/// to add more knowledge in the future.
///
/// It would also be nice to rewrite the actual code for this function,
/// which is mostly copied from Glaurung 1.x, and isn't very pretty.
template&lt;&gt;
ScaleFactor Endgame&lt;KRPKR&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 1));
  assert(verify_material(pos, weakSide,   RookValueMg, 0));

  // Assume strongSide is white and the pawn is on files A-D
  Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
  Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
  Square wrsq = normalize(pos, strongSide, pos.list&lt;ROOK&gt;(strongSide)[0]);
  Square wpsq = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
  Square brsq = normalize(pos, strongSide, pos.list&lt;ROOK&gt;(weakSide)[0]);

  File f = file_of(wpsq);
  Rank r = rank_of(wpsq);
  Square queeningSq = make_square(f, RANK_8);
  int tempo = (pos.side_to_move() == strongSide);

  // If the pawn is not too far advanced and the defending king defends the
  // queening square, use the third-rank defence.
  if (   r &lt;= RANK_5
      &amp;&amp; square_distance(bksq, queeningSq) &lt;= 1
      &amp;&amp; wksq &lt;= SQ_H5
      &amp;&amp; (rank_of(brsq) == RANK_6 || (r &lt;= RANK_3 &amp;&amp; rank_of(wrsq) != RANK_6)))
      return SCALE_FACTOR_DRAW;

  // The defending side saves a draw by checking from behind in case the pawn
  // has advanced to the 6th rank with the king behind.
  if (   r == RANK_6
      &amp;&amp; square_distance(bksq, queeningSq) &lt;= 1
      &amp;&amp; rank_of(wksq) + tempo &lt;= RANK_6
      &amp;&amp; (rank_of(brsq) == RANK_1 || (!tempo &amp;&amp; abs(file_of(brsq) - f) &gt;= 3)))
      return SCALE_FACTOR_DRAW;

  if (   r &gt;= RANK_6
      &amp;&amp; bksq == queeningSq
      &amp;&amp; rank_of(brsq) == RANK_1
      &amp;&amp; (!tempo || square_distance(wksq, wpsq) &gt;= 2))
      return SCALE_FACTOR_DRAW;

  // White pawn on a7 and rook on a8 is a draw if black's king is on g7 or h7
  // and the black rook is behind the pawn.
  if (   wpsq == SQ_A7
      &amp;&amp; wrsq == SQ_A8
      &amp;&amp; (bksq == SQ_H7 || bksq == SQ_G7)
      &amp;&amp; file_of(brsq) == FILE_A
      &amp;&amp; (rank_of(brsq) &lt;= RANK_3 || file_of(wksq) &gt;= FILE_D || rank_of(wksq) &lt;= RANK_5))
      return SCALE_FACTOR_DRAW;

  // If the defending king blocks the pawn and the attacking king is too far
  // away, it's a draw.
  if (   r &lt;= RANK_5
      &amp;&amp; bksq == wpsq + DELTA_N
      &amp;&amp; square_distance(wksq, wpsq) - tempo &gt;= 2
      &amp;&amp; square_distance(wksq, brsq) - tempo &gt;= 2)
      return SCALE_FACTOR_DRAW;

  // Pawn on the 7th rank supported by the rook from behind usually wins if the
  // attacking king is closer to the queening square than the defending king,
  // and the defending king cannot gain tempi by threatening the attacking rook.
  if (   r == RANK_7
      &amp;&amp; f != FILE_A
      &amp;&amp; file_of(wrsq) == f
      &amp;&amp; wrsq != queeningSq
      &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, queeningSq) - 2 + tempo)
      &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, wrsq) + tempo))
      return ScaleFactor(SCALE_FACTOR_MAX - 2 * square_distance(wksq, queeningSq));

  // Similar to the above, but with the pawn further back
  if (   f != FILE_A
      &amp;&amp; file_of(wrsq) == f
      &amp;&amp; wrsq &lt; wpsq
      &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, queeningSq) - 2 + tempo)
      &amp;&amp; (square_distance(wksq, wpsq + DELTA_N) &lt; square_distance(bksq, wpsq + DELTA_N) - 2 + tempo)
      &amp;&amp; (  square_distance(bksq, wrsq) + tempo &gt;= 3
          || (    square_distance(wksq, queeningSq) &lt; square_distance(bksq, wrsq) + tempo
              &amp;&amp; (square_distance(wksq, wpsq + DELTA_N) &lt; square_distance(bksq, wrsq) + tempo))))
      return ScaleFactor(  SCALE_FACTOR_MAX
                         - 8 * square_distance(wpsq, queeningSq)
                         - 2 * square_distance(wksq, queeningSq));

  // If the pawn is not far advanced and the defending king is somewhere in
  // the pawn's path, it's probably a draw.
  if (r &lt;= RANK_4 &amp;&amp; bksq &gt; wpsq)
  {
      if (file_of(bksq) == file_of(wpsq))
          return ScaleFactor(10);
      if (   abs(file_of(bksq) - file_of(wpsq)) == 1
          &amp;&amp; square_distance(wksq, bksq) &gt; 2)
          return ScaleFactor(24 - 2 * square_distance(wksq, bksq));
  }
  return SCALE_FACTOR_NONE;
}

template&lt;&gt;
ScaleFactor Endgame&lt;KRPKB&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 1));
  assert(verify_material(pos, weakSide, BishopValueMg, 0));

  // Test for a rook pawn
  if (pos.pieces(PAWN) &amp; (FileABB | FileHBB))
  {
      Square ksq = pos.king_square(weakSide);
      Square bsq = pos.list&lt;BISHOP&gt;(weakSide)[0];
      Square psq = pos.list&lt;PAWN&gt;(strongSide)[0];
      Rank rk = relative_rank(strongSide, psq);
      Square push = pawn_push(strongSide);

      // If the pawn is on the 5th rank and the pawn (currently) is on
      // the same color square as the bishop then there is a chance of
      // a fortress. Depending on the king position give a moderate
      // reduction or a stronger one if the defending king is near the
      // corner but not trapped there.
      if (rk == RANK_5 &amp;&amp; !opposite_colors(bsq, psq))
      {
          int d = square_distance(psq + 3 * push, ksq);

          if (d &lt;= 2 &amp;&amp; !(d == 0 &amp;&amp; ksq == pos.king_square(strongSide) + 2 * push))
              return ScaleFactor(24);
          else
              return ScaleFactor(48);
      }

      // When the pawn has moved to the 6th rank we can be fairly sure
      // it's drawn if the bishop attacks the square in front of the
      // pawn from a reasonable distance and the defending king is near
      // the corner
      if (   rk == RANK_6
          &amp;&amp; square_distance(psq + 2 * push, ksq) &lt;= 1
          &amp;&amp; (PseudoAttacks[BISHOP][bsq] &amp; (psq + push))
          &amp;&amp; file_distance(bsq, psq) &gt;= 2)
          return ScaleFactor(8);
  }

  return SCALE_FACTOR_NONE;
}

/// KRPP vs KRP. There is just a single rule: if the stronger side has no passed
/// pawns and the defending king is actively placed, the position is drawish.
template&lt;&gt;
ScaleFactor Endgame&lt;KRPPKRP&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 2));
  assert(verify_material(pos, weakSide,   RookValueMg, 1));

  Square wpsq1 = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square wpsq2 = pos.list&lt;PAWN&gt;(strongSide)[1];
  Square bksq = pos.king_square(weakSide);

  // Does the stronger side have a passed pawn?
  if (pos.pawn_passed(strongSide, wpsq1) || pos.pawn_passed(strongSide, wpsq2))
      return SCALE_FACTOR_NONE;

  Rank r = std::max(relative_rank(strongSide, wpsq1), relative_rank(strongSide, wpsq2));

  if (   file_distance(bksq, wpsq1) &lt;= 1
      &amp;&amp; file_distance(bksq, wpsq2) &lt;= 1
      &amp;&amp; relative_rank(strongSide, bksq) &gt; r)
  {
      switch (r) {
      case RANK_2: return ScaleFactor(10);
      case RANK_3: return ScaleFactor(10);
      case RANK_4: return ScaleFactor(15);
      case RANK_5: return ScaleFactor(20);
      case RANK_6: return ScaleFactor(40);
      default: assert(false);
      }
  }
  return SCALE_FACTOR_NONE;
}


/// K and two or more pawns vs K. There is just a single rule here: If all pawns
/// are on the same rook file and are blocked by the defending king, it's a draw.
template&lt;&gt;
ScaleFactor Endgame&lt;KPsK&gt;::operator()(const Position&amp; pos) const {

  assert(pos.non_pawn_material(strongSide) == VALUE_ZERO);
  assert(pos.count&lt;PAWN&gt;(strongSide) &gt;= 2);
  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));

  Square ksq = pos.king_square(weakSide);
  Bitboard pawns = pos.pieces(strongSide, PAWN);
  Square psq = pos.list&lt;PAWN&gt;(strongSide)[0];

  // If all pawns are ahead of the king, on a single rook file and
  // the king is within one file of the pawns, it's a draw.
  if (   !(pawns &amp; ~in_front_bb(weakSide, rank_of(ksq)))
      &amp;&amp; !((pawns &amp; ~FileABB) &amp;&amp; (pawns &amp; ~FileHBB))
      &amp;&amp; file_distance(ksq, psq) &lt;= 1)
      return SCALE_FACTOR_DRAW;

  return SCALE_FACTOR_NONE;
}


/// KBP vs KB. There are two rules: if the defending king is somewhere along the
/// path of the pawn, and the square of the king is not of the same color as the
/// stronger side's bishop, it's a draw. If the two bishops have opposite color,
/// it's almost always a draw.
template&lt;&gt;
ScaleFactor Endgame&lt;KBPKB&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, BishopValueMg, 1));
  assert(verify_material(pos, weakSide,   BishopValueMg, 0));

  Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square strongBishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
  Square weakBishopSq = pos.list&lt;BISHOP&gt;(weakSide)[0];
  Square weakKingSq = pos.king_square(weakSide);

  // Case 1: Defending king blocks the pawn, and cannot be driven away
  if (   file_of(weakKingSq) == file_of(pawnSq)
      &amp;&amp; relative_rank(strongSide, pawnSq) &lt; relative_rank(strongSide, weakKingSq)
      &amp;&amp; (   opposite_colors(weakKingSq, strongBishopSq)
          || relative_rank(strongSide, weakKingSq) &lt;= RANK_6))
      return SCALE_FACTOR_DRAW;

  // Case 2: Opposite colored bishops
  if (opposite_colors(strongBishopSq, weakBishopSq))
  {
      // We assume that the position is drawn in the following three situations:
      //
      //   a. The pawn is on rank 5 or further back.
      //   b. The defending king is somewhere in the pawn's path.
      //   c. The defending bishop attacks some square along the pawn's path,
      //      and is at least three squares away from the pawn.
      //
      // These rules are probably not perfect, but in practice they work
      // reasonably well.

      if (relative_rank(strongSide, pawnSq) &lt;= RANK_5)
          return SCALE_FACTOR_DRAW;
      else
      {
          Bitboard path = forward_bb(strongSide, pawnSq);

          if (path &amp; pos.pieces(weakSide, KING))
              return SCALE_FACTOR_DRAW;

          if (  (pos.attacks_from&lt;BISHOP&gt;(weakBishopSq) &amp; path)
              &amp;&amp; square_distance(weakBishopSq, pawnSq) &gt;= 3)
              return SCALE_FACTOR_DRAW;
      }
  }
  return SCALE_FACTOR_NONE;
}


/// KBPP vs KB. It detects a few basic draws with opposite-colored bishops
template&lt;&gt;
ScaleFactor Endgame&lt;KBPPKB&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, BishopValueMg, 2));
  assert(verify_material(pos, weakSide,   BishopValueMg, 0));

  Square wbsq = pos.list&lt;BISHOP&gt;(strongSide)[0];
  Square bbsq = pos.list&lt;BISHOP&gt;(weakSide)[0];

  if (!opposite_colors(wbsq, bbsq))
      return SCALE_FACTOR_NONE;

  Square ksq = pos.king_square(weakSide);
  Square psq1 = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square psq2 = pos.list&lt;PAWN&gt;(strongSide)[1];
  Rank r1 = rank_of(psq1);
  Rank r2 = rank_of(psq2);
  Square blockSq1, blockSq2;

  if (relative_rank(strongSide, psq1) &gt; relative_rank(strongSide, psq2))
  {
      blockSq1 = psq1 + pawn_push(strongSide);
      blockSq2 = make_square(file_of(psq2), rank_of(psq1));
  }
  else
  {
      blockSq1 = psq2 + pawn_push(strongSide);
      blockSq2 = make_square(file_of(psq1), rank_of(psq2));
  }

  switch (file_distance(psq1, psq2))
  {
  case 0:
    // Both pawns are on the same file. It's an easy draw if the defender firmly
    // controls some square in the frontmost pawn's path.
    if (   file_of(ksq) == file_of(blockSq1)
        &amp;&amp; relative_rank(strongSide, ksq) &gt;= relative_rank(strongSide, blockSq1)
        &amp;&amp; opposite_colors(ksq, wbsq))
        return SCALE_FACTOR_DRAW;
    else
        return SCALE_FACTOR_NONE;

  case 1:
    // Pawns on adjacent files. It's a draw if the defender firmly controls the
    // square in front of the frontmost pawn's path, and the square diagonally
    // behind this square on the file of the other pawn.
    if (   ksq == blockSq1
        &amp;&amp; opposite_colors(ksq, wbsq)
        &amp;&amp; (   bbsq == blockSq2
            || (pos.attacks_from&lt;BISHOP&gt;(blockSq2) &amp; pos.pieces(weakSide, BISHOP))
            || abs(r1 - r2) &gt;= 2))
        return SCALE_FACTOR_DRAW;

    else if (   ksq == blockSq2
             &amp;&amp; opposite_colors(ksq, wbsq)
             &amp;&amp; (   bbsq == blockSq1
                 || (pos.attacks_from&lt;BISHOP&gt;(blockSq1) &amp; pos.pieces(weakSide, BISHOP))))
        return SCALE_FACTOR_DRAW;
    else
        return SCALE_FACTOR_NONE;

  default:
    // The pawns are not on the same file or adjacent files. No scaling.
    return SCALE_FACTOR_NONE;
  }
}


/// KBP vs KN. There is a single rule: If the defending king is somewhere along
/// the path of the pawn, and the square of the king is not of the same color as
/// the stronger side's bishop, it's a draw.
template&lt;&gt;
ScaleFactor Endgame&lt;KBPKN&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, BishopValueMg, 1));
  assert(verify_material(pos, weakSide, KnightValueMg, 0));

  Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square strongBishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
  Square weakKingSq = pos.king_square(weakSide);

  if (   file_of(weakKingSq) == file_of(pawnSq)
      &amp;&amp; relative_rank(strongSide, pawnSq) &lt; relative_rank(strongSide, weakKingSq)
      &amp;&amp; (   opposite_colors(weakKingSq, strongBishopSq)
          || relative_rank(strongSide, weakKingSq) &lt;= RANK_6))
      return SCALE_FACTOR_DRAW;

  return SCALE_FACTOR_NONE;
}


/// KNP vs K. There is a single rule: if the pawn is a rook pawn on the 7th rank
/// and the defending king prevents the pawn from advancing, the position is drawn.
template&lt;&gt;
ScaleFactor Endgame&lt;KNPK&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, KnightValueMg, 1));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));

  // Assume strongSide is white and the pawn is on files A-D
  Square pawnSq     = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
  Square weakKingSq = normalize(pos, strongSide, pos.king_square(weakSide));

  if (pawnSq == SQ_A7 &amp;&amp; square_distance(SQ_A8, weakKingSq) &lt;= 1)
      return SCALE_FACTOR_DRAW;

  return SCALE_FACTOR_NONE;
}


/// KNP vs KB. If knight can block bishop from taking pawn, it's a win.
/// Otherwise the position is drawn.
template&lt;&gt;
ScaleFactor Endgame&lt;KNPKB&gt;::operator()(const Position&amp; pos) const {

  Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square bishopSq = pos.list&lt;BISHOP&gt;(weakSide)[0];
  Square weakKingSq = pos.king_square(weakSide);

  // King needs to get close to promoting pawn to prevent knight from blocking.
  // Rules for this are very tricky, so just approximate.
  if (forward_bb(strongSide, pawnSq) &amp; pos.attacks_from&lt;BISHOP&gt;(bishopSq))
      return ScaleFactor(square_distance(weakKingSq, pawnSq));

  return SCALE_FACTOR_NONE;
}


/// KP vs KP. This is done by removing the weakest side's pawn and probing the
/// KP vs K bitbase: If the weakest side has a draw without the pawn, it probably
/// has at least a draw with the pawn as well. The exception is when the stronger
/// side's pawn is far advanced and not on a rook file; in this case it is often
/// possible to win (e.g. 8/4k3/3p4/3P4/6K1/8/8/8 w - - 0 1).
template&lt;&gt;
ScaleFactor Endgame&lt;KPKP&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, VALUE_ZERO, 1));
  assert(verify_material(pos, weakSide,   VALUE_ZERO, 1));

  // Assume strongSide is white and the pawn is on files A-D
  Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
  Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
  Square psq  = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);

  Color us = strongSide == pos.side_to_move() ? WHITE : BLACK;

  // If the pawn has advanced to the fifth rank or further, and is not a
  // rook pawn, it's too dangerous to assume that it's at least a draw.
  if (rank_of(psq) &gt;= RANK_5 &amp;&amp; file_of(psq) != FILE_A)
      return SCALE_FACTOR_NONE;

  // Probe the KPK bitbase with the weakest side's pawn removed. If it's a draw,
  // it's probably at least a draw even with the pawn.
  return Bitbases::probe_kpk(wksq, psq, bksq, us) ? SCALE_FACTOR_NONE : SCALE_FACTOR_DRAW;
}</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>endgame.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
  Copyright (C) 2004-2008 Tord Romstad (Glaurung author)
  Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad

  Stockfish is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Stockfish is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

#include &lt;algorithm&gt;
#include &lt;cassert&gt;

#include "bitboard.h"
#include "bitcount.h"
<a name="1"></a>#include "endgame.h"
#include "movegen.h"

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>using std::string;

namespace {

  // Table used to drive the king towards the edge of the board
  // in KX vs K and KQ vs KR endgames.
  const int PushToEdges[SQUARE_NB] = {
    100, 90, 80, 70, 70, 80, 90, 100,
     90, 70, 60, 50, 50, 60, 70,  90,
     80, 60, 40, 30, 30, 40, 60,  80,
     70, 50, 30, 20, 20, 30, 50,  70,
     70, 50, 30, 20, 20, 30, 50,  70,
     80, 60, 40, 30, 30, 40, 60,  80,
     90, 70, 60, 50, 50, 60, 70,  90,
    100, 90, 80, 70, 70, 80, 90, 100,
  };

  // Table used to drive the king towards a corner square of the
  // right color in KBN vs K endgames.
  const int PushToCorners[SQUARE_NB] = {
    200, 190, 180, 170, 160, 150, 140, 130,
    190, 180, 170, 160, 150, 140, 130, 140,
    180, 170, 155, 140, 140, 125, 140, 150,
    170, 160, 140, 120, 110, 140, 150, 160,
    160, 150, 140, 110, 120, 140, 160, 170,
    150, 140, 125, 140, 140, 155, 170, 180,
    140, 130, 140, 150, 160, 170, 180, 190,
    130, 140, 150, 160, 170, 180, 190, 200
  };

  // Tables used to drive a piece towards or away from another piece
  const int PushClose[8] = { 0, 0, 100, 80, 60, 40, 20, 10 };
  const int PushAway [8] = { 0, 5, 20, 40, 60, 80, 90, 100 };

#ifndef NDEBUG
  bool verify_material(const Position&amp; pos, Color c, Value npm, int num_pawns) {
    return pos.non_pawn_material(c) == npm &amp;&amp; pos.count&lt;PAWN&gt;(c) == num_pawns;
  }
#endif

  // Map the square as if strongSide is white and strongSide's only pawn
  // is on the left half of the board.
  Square normalize(const Position&amp; pos, Color strongSide, Square sq) {

    assert(pos.count&lt;PAWN&gt;(strongSide) == 1);

    if (file_of(pos.list&lt;PAWN&gt;(strongSide)[0]) &gt;= FILE_E)
        sq = Square(sq ^ 7); // Mirror SQ_H1 -&gt; SQ_A1

    if (strongSide == BLACK)
        sq = ~sq;

    return sq;
  }

  // Get the material key of Position out of the given endgame key code
  // like "KBPKN". The trick here is to first forge an ad-hoc FEN string
  // and then let a Position object do the work for us.
  Key key(const string&amp; code, Color c) {

    assert(code.length() &gt; 0 &amp;&amp; code.length() &lt; 8);
    assert(code[0] == 'K');

    string sides[] = { code.substr(code.find('K', 1)),      // Weak
                       code.substr(0, code.find('K', 1)) }; // Strong

    std::transform(sides[c].begin(), sides[c].end(), sides[c].begin(), tolower);

    string fen =  sides[0] + char(8 - sides[0].length() + '0') + "/8/8/8/8/8/8/"
                + sides[1] + char(8 - sides[1].length() + '0') + " w - - 0 10";

    return Position(fen, false, NULL).material_key();</b></font>
  }

  template&lt;typename M&gt;
  void delete_endgame(const typename M::value_type&amp; p) { delete p.second; }

} // namespace


/// Endgames members definitions

Endgames::Endgames() {

  add&lt;KPK&gt;("KPK");
  add&lt;KNNK&gt;("KNNK");
  add&lt;KBNK&gt;("KBNK");
  add&lt;KRKP&gt;("KRKP");
  add&lt;KRKB&gt;("KRKB");
  add&lt;KRKN&gt;("KRKN");
  add&lt;KQKP&gt;("KQKP");
  add&lt;KQKR&gt;("KQKR");

  add&lt;KNPK&gt;("KNPK");
  add&lt;KNPKB&gt;("KNPKB");
  add&lt;KRPKR&gt;("KRPKR");
  add&lt;KRPKB&gt;("KRPKB");
  add&lt;KBPKB&gt;("KBPKB");
  add&lt;KBPKN&gt;("KBPKN");
  add&lt;KBPPKB&gt;("KBPPKB");
  add&lt;KRPPKRP&gt;("KRPPKRP");
}

Endgames::~Endgames() {

  for_each(m1.begin(), m1.end(), delete_endgame&lt;M1&gt;);
  for_each(m2.begin(), m2.end(), delete_endgame&lt;M2&gt;);
}

template&lt;EndgameType E&gt;
<a name="0"></a>void Endgames::add(const string&amp; code) {

  map((Endgame&lt;E&gt;*)0)[key(code, WHITE)] = new Endgame&lt;E&gt;(WHITE);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  map((Endgame&lt;E&gt;*)0)[key(code, BLACK)] = new Endgame&lt;E&gt;(BLACK);
}


/// Mate with KX vs K. This function is used to evaluate positions with
/// king and plenty of material vs a lone king. It simply gives the
/// attacking side a bonus for driving the defending king towards the edge
/// of the board, and for keeping the distance between the two kings small.
template&lt;&gt;
Value Endgame&lt;KXK&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
  assert(!pos.checkers()); // Eval is never called when in check

  // Stalemate detection with lone king
  if (pos.side_to_move() == weakSide &amp;&amp; !MoveList&lt;LEGAL&gt;(pos).size())
      return VALUE_DRAW;

  Square winnerKSq = pos.king_square(strongSide);
  Square loserKSq = pos.king_square(weakSide);

  Value result =  pos.non_pawn_material(strongSide)
                + pos.count&lt;PAWN&gt;(strongSide) * PawnValueEg
                + PushToEdges[loserKSq]
                + PushClose[square_distance(winnerKSq, loserKSq)];

  if (   pos.count&lt;QUEEN&gt;(strongSide)
      || pos.count&lt;ROOK&gt;(strongSide)
      ||(pos.count&lt;BISHOP&gt;(strongSide) &amp;&amp; pos.count&lt;KNIGHT&gt;(strongSide))
      || pos.bishop_pair(strongSide))
      result += VALUE_KNOWN_WIN;

  return strongSide == pos.side_to_move() ? result : -result;
}


/// Mate with KBN vs K. This is similar to KX vs K, but we have to drive the
/// defending king towards a corner square of the right color.
template&lt;&gt;
Value Endgame&lt;KBNK&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, KnightValueMg + BishopValueMg, 0));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));

  Square winnerKSq = pos.king_square(strongSide);
  Square loserKSq = pos.king_square(weakSide);
  Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];

  // kbnk_mate_table() tries to drive toward corners A1 or H8. If we have a
  // bishop that cannot reach the above squares, we flip the kings in order
  // to drive the enemy toward corners A8 or H1.
  if (opposite_colors(bishopSq, SQ_A1))
  {
      winnerKSq = ~winnerKSq;
      loserKSq  = ~loserKSq;
  }

  Value result =  VALUE_KNOWN_WIN
                + PushClose[square_distance(winnerKSq, loserKSq)]
                + PushToCorners[loserKSq];

  return strongSide == pos.side_to_move() ? result : -result;
}


/// KP vs K. This endgame is evaluated with the help of a bitbase.
template&lt;&gt;
Value Endgame&lt;KPK&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, VALUE_ZERO, 1));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));

  // Assume strongSide is white and the pawn is on files A-D
  Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
  Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
  Square psq  = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);

  Color us = strongSide == pos.side_to_move() ? WHITE : BLACK;

  if (!Bitbases::probe_kpk(wksq, psq, bksq, us))
      return VALUE_DRAW;

  Value result = VALUE_KNOWN_WIN + PawnValueEg + Value(rank_of(psq));

  return strongSide == pos.side_to_move() ? result : -result;
}


/// KR vs KP. This is a somewhat tricky endgame to evaluate precisely without
/// a bitbase. The function below returns drawish scores when the pawn is
/// far advanced with support of the king, while the attacking king is far
/// away.
template&lt;&gt;
Value Endgame&lt;KRKP&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 0));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 1));

  Square wksq = relative_square(strongSide, pos.king_square(strongSide));
  Square bksq = relative_square(strongSide, pos.king_square(weakSide));
  Square rsq  = relative_square(strongSide, pos.list&lt;ROOK&gt;(strongSide)[0]);
  Square psq  = relative_square(strongSide, pos.list&lt;PAWN&gt;(weakSide)[0]);

  Square queeningSq = make_square(file_of(psq), RANK_1);
  Value result;

  // If the stronger side's king is in front of the pawn, it's a win
  if (wksq &lt; psq &amp;&amp; file_of(wksq) == file_of(psq))
      result = RookValueEg - square_distance(wksq, psq);

  // If the weaker side's king is too far from the pawn and the rook,
  // it's a win.
  else if (   square_distance(bksq, psq) &gt;= 3 + (pos.side_to_move() == weakSide)
           &amp;&amp; square_distance(bksq, rsq) &gt;= 3)
      result = RookValueEg - square_distance(wksq, psq);

  // If the pawn is far advanced and supported by the defending king,
  // the position is drawish
  else if (   rank_of(bksq) &lt;= RANK_3
           &amp;&amp; square_distance(bksq, psq) == 1
           &amp;&amp; rank_of(wksq) &gt;= RANK_4
           &amp;&amp; square_distance(wksq, psq) &gt; 2 + (pos.side_to_move() == strongSide))
      result = Value(80) - 8 * square_distance(wksq, psq);

  else
      result =  Value(200) - 8 * (  square_distance(wksq, psq + DELTA_S)
                                  - square_distance(bksq, psq + DELTA_S)
                                  - square_distance(psq, queeningSq));

  return strongSide == pos.side_to_move() ? result : -result;
}


/// KR vs KB. This is very simple, and always returns drawish scores.  The
/// score is slightly bigger when the defending king is close to the edge.
template&lt;&gt;
Value Endgame&lt;KRKB&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 0));
  assert(verify_material(pos, weakSide, BishopValueMg, 0));

  Value result = Value(PushToEdges[pos.king_square(weakSide)]);
  return strongSide == pos.side_to_move() ? result : -result;
}


/// KR vs KN. The attacking side has slightly better winning chances than
/// in KR vs KB, particularly if the king and the knight are far apart.
template&lt;&gt;
Value Endgame&lt;KRKN&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 0));
  assert(verify_material(pos, weakSide, KnightValueMg, 0));

  Square bksq = pos.king_square(weakSide);
  Square bnsq = pos.list&lt;KNIGHT&gt;(weakSide)[0];
  Value result = Value(PushToEdges[bksq] + PushAway[square_distance(bksq, bnsq)]);
  return strongSide == pos.side_to_move() ? result : -result;
}


/// KQ vs KP. In general, this is a win for the stronger side, but there are a
/// few important exceptions. A pawn on 7th rank and on the A,C,F or H files
/// with a king positioned next to it can be a draw, so in that case, we only
/// use the distance between the kings.
template&lt;&gt;
Value Endgame&lt;KQKP&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, QueenValueMg, 0));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 1));

  Square winnerKSq = pos.king_square(strongSide);
  Square loserKSq = pos.king_square(weakSide);
  Square pawnSq = pos.list&lt;PAWN&gt;(weakSide)[0];

  Value result = Value(PushClose[square_distance(winnerKSq, loserKSq)]);

  if (   relative_rank(weakSide, pawnSq) != RANK_7
      || square_distance(loserKSq, pawnSq) != 1
      || !((FileABB | FileCBB | FileFBB | FileHBB) &amp; pawnSq))
      result += QueenValueEg - PawnValueEg;

  return strongSide == pos.side_to_move() ? result : -result;
}


/// KQ vs KR.  This is almost identical to KX vs K:  We give the attacking
/// king a bonus for having the kings close together, and for forcing the
/// defending king towards the edge. If we also take care to avoid null move for
/// the defending side in the search, this is usually sufficient to win KQ vs KR.
template&lt;&gt;
Value Endgame&lt;KQKR&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, QueenValueMg, 0));
  assert(verify_material(pos, weakSide, RookValueMg, 0));

  Square winnerKSq = pos.king_square(strongSide);
  Square loserKSq = pos.king_square(weakSide);

  Value result =  QueenValueEg
                - RookValueEg
                + PushToEdges[loserKSq]
                + PushClose[square_distance(winnerKSq, loserKSq)];

  return strongSide == pos.side_to_move() ? result : -result;
}


/// Some cases of trivial draws
template&lt;&gt; Value Endgame&lt;KNNK&gt;::operator()(const Position&amp;) const { return VALUE_DRAW; }


/// KB and one or more pawns vs K. It checks for draws with rook pawns and
/// a bishop of the wrong color. If such a draw is detected, SCALE_FACTOR_DRAW
/// is returned. If not, the return value is SCALE_FACTOR_NONE, i.e. no scaling
/// will be used.
template&lt;&gt;
ScaleFactor Endgame&lt;KBPsK&gt;::operator()(const Position&amp; pos) const {

  assert(pos.non_pawn_material(strongSide) == BishopValueMg);
  assert(pos.count&lt;PAWN&gt;(strongSide) &gt;= 1);

  // No assertions about the material of weakSide, because we want draws to
  // be detected even when the weaker side has some pawns.

  Bitboard pawns = pos.pieces(strongSide, PAWN);
  File pawnFile = file_of(pos.list&lt;PAWN&gt;(strongSide)[0]);

  // All pawns are on a single rook file ?
  if (    (pawnFile == FILE_A || pawnFile == FILE_H)
      &amp;&amp; !(pawns &amp; ~file_bb(pawnFile)))
  {
      Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
      Square queeningSq = relative_square(strongSide, make_square(pawnFile, RANK_8));
      Square kingSq = pos.king_square(weakSide);

      if (   opposite_colors(queeningSq, bishopSq)
          &amp;&amp; square_distance(queeningSq, kingSq) &lt;= 1)
          return SCALE_FACTOR_DRAW;
  }

  // If all the pawns are on the same B or G file, then it's potentially a draw
  if (    (pawnFile == FILE_B || pawnFile == FILE_G)
      &amp;&amp; !(pos.pieces(PAWN) &amp; ~file_bb(pawnFile))
      &amp;&amp; pos.non_pawn_material(weakSide) == 0
      &amp;&amp; pos.count&lt;PAWN&gt;(weakSide) &gt;= 1)
  {
      // Get weakSide pawn that is closest to the home rank
      Square weakPawnSq = backmost_sq(weakSide, pos.pieces(weakSide, PAWN));

      Square strongKingSq = pos.king_square(strongSide);
      Square weakKingSq = pos.king_square(weakSide);
      Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];

      // There's potential for a draw if our pawn is blocked on the 7th rank,
      // the bishop cannot attack it or they only have one pawn left
      if (   relative_rank(strongSide, weakPawnSq) == RANK_7
          &amp;&amp; (pos.pieces(strongSide, PAWN) &amp; (weakPawnSq + pawn_push(weakSide)))
          &amp;&amp; (opposite_colors(bishopSq, weakPawnSq) || pos.count&lt;PAWN&gt;(strongSide) == 1))
      {
          int strongKingDist = square_distance(weakPawnSq, strongKingSq);
          int weakKingDist = square_distance(weakPawnSq, weakKingSq);

          // It's a draw if the weak king is on its back two ranks, within 2
          // squares of the blocking pawn and the strong king is not
          // closer. (I think this rule only fails in practically
          // unreachable positions such as 5k1K/6p1/6P1/8/8/3B4/8/8 w
          // and positions where qsearch will immediately correct the
          // problem such as 8/4k1p1/6P1/1K6/3B4/8/8/8 w)
          if (   relative_rank(strongSide, weakKingSq) &gt;= RANK_7
              &amp;&amp; weakKingDist &lt;= 2
              &amp;&amp; weakKingDist &lt;= strongKingDist)
              return SCALE_FACTOR_DRAW;
      }
  }

  return SCALE_FACTOR_NONE;
}


/// KQ vs KR and one or more pawns. It tests for fortress draws with a rook on
/// the third rank defended by a pawn.
template&lt;&gt;
ScaleFactor Endgame&lt;KQKRPs&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, QueenValueMg, 0));
  assert(pos.count&lt;ROOK&gt;(weakSide) == 1);
  assert(pos.count&lt;PAWN&gt;(weakSide) &gt;= 1);

  Square kingSq = pos.king_square(weakSide);
  Square rsq = pos.list&lt;ROOK&gt;(weakSide)[0];

  if (    relative_rank(weakSide, kingSq) &lt;= RANK_2
      &amp;&amp;  relative_rank(weakSide, pos.king_square(strongSide)) &gt;= RANK_4
      &amp;&amp;  relative_rank(weakSide, rsq) == RANK_3
      &amp;&amp; (  pos.pieces(weakSide, PAWN)
          &amp; pos.attacks_from&lt;KING&gt;(kingSq)
          &amp; pos.attacks_from&lt;PAWN&gt;(rsq, strongSide)))
          return SCALE_FACTOR_DRAW;

  return SCALE_FACTOR_NONE;
}


/// KRP vs KR. This function knows a handful of the most important classes of
/// drawn positions, but is far from perfect. It would probably be a good idea
/// to add more knowledge in the future.
///
/// It would also be nice to rewrite the actual code for this function,
/// which is mostly copied from Glaurung 1.x, and isn't very pretty.
template&lt;&gt;
ScaleFactor Endgame&lt;KRPKR&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 1));
  assert(verify_material(pos, weakSide,   RookValueMg, 0));

  // Assume strongSide is white and the pawn is on files A-D
  Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
  Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
  Square wrsq = normalize(pos, strongSide, pos.list&lt;ROOK&gt;(strongSide)[0]);
  Square wpsq = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
  Square brsq = normalize(pos, strongSide, pos.list&lt;ROOK&gt;(weakSide)[0]);

  File f = file_of(wpsq);
  Rank r = rank_of(wpsq);
  Square queeningSq = make_square(f, RANK_8);
  int tempo = (pos.side_to_move() == strongSide);

  // If the pawn is not too far advanced and the defending king defends the
  // queening square, use the third-rank defence.
  if (   r &lt;= RANK_5
      &amp;&amp; square_distance(bksq, queeningSq) &lt;= 1
      &amp;&amp; wksq &lt;= SQ_H5
      &amp;&amp; (rank_of(brsq) == RANK_6 || (r &lt;= RANK_3 &amp;&amp; rank_of(wrsq) != RANK_6)))
      return SCALE_FACTOR_DRAW;

  // The defending side saves a draw by checking from behind in case the pawn
  // has advanced to the 6th rank with the king behind.
  if (   r == RANK_6
      &amp;&amp; square_distance(bksq, queeningSq) &lt;= 1
      &amp;&amp; rank_of(wksq) + tempo &lt;= RANK_6
      &amp;&amp; (rank_of(brsq) == RANK_1 || (!tempo &amp;&amp; abs(file_of(brsq) - f) &gt;= 3)))
      return SCALE_FACTOR_DRAW;

  if (   r &gt;= RANK_6
      &amp;&amp; bksq == queeningSq
      &amp;&amp; rank_of(brsq) == RANK_1
      &amp;&amp; (!tempo || square_distance(wksq, wpsq) &gt;= 2))
      return SCALE_FACTOR_DRAW;

  // White pawn on a7 and rook on a8 is a draw if black's king is on g7 or h7
  // and the black rook is behind the pawn.
  if (   wpsq == SQ_A7
      &amp;&amp; wrsq == SQ_A8
      &amp;&amp; (bksq == SQ_H7 || bksq == SQ_G7)
      &amp;&amp; file_of(brsq) == FILE_A
      &amp;&amp; (rank_of(brsq) &lt;= RANK_3 || file_of(wksq) &gt;= FILE_D || rank_of(wksq) &lt;= RANK_5))
      return SCALE_FACTOR_DRAW;

  // If the defending king blocks the pawn and the attacking king is too far
  // away, it's a draw.
  if (   r &lt;= RANK_5
      &amp;&amp; bksq == wpsq + DELTA_N
      &amp;&amp; square_distance(wksq, wpsq) - tempo &gt;= 2
      &amp;&amp; square_distance(wksq, brsq) - tempo &gt;= 2)
      return SCALE_FACTOR_DRAW;

  // Pawn on the 7th rank supported by the rook from behind usually wins if the
  // attacking king is closer to the queening square than the defending king,
  // and the defending king cannot gain tempi by threatening the attacking rook.
  if (   r == RANK_7
      &amp;&amp; f != FILE_A
      &amp;&amp; file_of(wrsq) == f
      &amp;&amp; wrsq != queeningSq
      &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, queeningSq) - 2 + tempo)
      &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, wrsq) + tempo))
      return ScaleFactor(SCALE_FACTOR_MAX - 2 * square_distance(wksq, queeningSq));

  // Similar to the above, but with the pawn further back
  if (   f != FILE_A
      &amp;&amp; file_of(wrsq) == f
      &amp;&amp; wrsq &lt; wpsq
      &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, queeningSq) - 2 + tempo)
      &amp;&amp; (square_distance(wksq, wpsq + DELTA_N) &lt; square_distance(bksq, wpsq + DELTA_N) - 2 + tempo)
      &amp;&amp; (  square_distance(bksq, wrsq) + tempo &gt;= 3
          || (    square_distance(wksq, queeningSq) &lt; square_distance(bksq, wrsq) + tempo
              &amp;&amp; (square_distance(wksq, wpsq + DELTA_N) &lt; square_distance(bksq, wrsq) + tempo))))
      return ScaleFactor(  SCALE_FACTOR_MAX
                         - 8 * square_distance(wpsq, queeningSq)
                         - 2 * square_distance(wksq, queeningSq));

  // If the pawn is not far advanced and the defending king is somewhere in
  // the pawn's path, it's probably a draw.
  if (r &lt;= RANK_4 &amp;&amp; bksq &gt; wpsq)
  {
      if (file_of(bksq) == file_of(wpsq))
          return ScaleFactor(10);
      if (   abs(file_of(bksq) - file_of(wpsq)) == 1
          &amp;&amp; square_distance(wksq, bksq) &gt; 2)
          return ScaleFactor(24 - 2 * square_distance(wksq, bksq));
  }
  return SCALE_FACTOR_NONE;
}

template&lt;&gt;
ScaleFactor Endgame&lt;KRPKB&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 1));
  assert(verify_material(pos, weakSide, BishopValueMg, 0));

  // Test for a rook pawn
  if (pos.pieces(PAWN) &amp; (FileABB | FileHBB))
  {
      Square ksq = pos.king_square(weakSide);
      Square bsq = pos.list&lt;BISHOP&gt;(weakSide)[0];
      Square psq = pos.list&lt;PAWN&gt;(strongSide)[0];
      Rank rk = relative_rank(strongSide, psq);
      Square push = pawn_push(strongSide);

      // If the pawn is on the 5th rank and the pawn (currently) is on
      // the same color square as the bishop then there is a chance of
      // a fortress. Depending on the king position give a moderate
      // reduction or a stronger one if the defending king is near the
      // corner but not trapped there.
      if (rk == RANK_5 &amp;&amp; !opposite_colors(bsq, psq))
      {
          int d = square_distance(psq + 3 * push, ksq);

          if (d &lt;= 2 &amp;&amp; !(d == 0 &amp;&amp; ksq == pos.king_square(strongSide) + 2 * push))
              return ScaleFactor(24);
          else
              return ScaleFactor(48);
      }

      // When the pawn has moved to the 6th rank we can be fairly sure
      // it's drawn if the bishop attacks the square in front of the
      // pawn from a reasonable distance and the defending king is near
      // the corner
      if (   rk == RANK_6
          &amp;&amp; square_distance(psq + 2 * push, ksq) &lt;= 1
          &amp;&amp; (PseudoAttacks[BISHOP][bsq] &amp; (psq + push))
          &amp;&amp; file_distance(bsq, psq) &gt;= 2)
          return ScaleFactor(8);
  }

  return SCALE_FACTOR_NONE;
}

/// KRPP vs KRP. There is just a single rule: if the stronger side has no passed
/// pawns and the defending king is actively placed, the position is drawish.
template&lt;&gt;
ScaleFactor Endgame&lt;KRPPKRP&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, RookValueMg, 2));
  assert(verify_material(pos, weakSide,   RookValueMg, 1));

  Square wpsq1 = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square wpsq2 = pos.list&lt;PAWN&gt;(strongSide)[1];
  Square bksq = pos.king_square(weakSide);

  // Does the stronger side have a passed pawn?
  if (pos.pawn_passed(strongSide, wpsq1) || pos.pawn_passed(strongSide, wpsq2))
      return SCALE_FACTOR_NONE;

  Rank r = std::max(relative_rank(strongSide, wpsq1), relative_rank(strongSide, wpsq2));

  if (   file_distance(bksq, wpsq1) &lt;= 1
      &amp;&amp; file_distance(bksq, wpsq2) &lt;= 1
      &amp;&amp; relative_rank(strongSide, bksq) &gt; r)
  {
      switch (r) {
      case RANK_2: return ScaleFactor(10);
      case RANK_3: return ScaleFactor(10);
      case RANK_4: return ScaleFactor(15);
      case RANK_5: return ScaleFactor(20);
      case RANK_6: return ScaleFactor(40);
      default: assert(false);
      }
  }
  return SCALE_FACTOR_NONE;
}


/// K and two or more pawns vs K. There is just a single rule here: If all pawns
/// are on the same rook file and are blocked by the defending king, it's a draw.
template&lt;&gt;
ScaleFactor Endgame&lt;KPsK&gt;::operator()(const Position&amp; pos) const {

  assert(pos.non_pawn_material(strongSide) == VALUE_ZERO);
  assert(pos.count&lt;PAWN&gt;(strongSide) &gt;= 2);
  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));

  Square ksq = pos.king_square(weakSide);
  Bitboard pawns = pos.pieces(strongSide, PAWN);
  Square psq = pos.list&lt;PAWN&gt;(strongSide)[0];

  // If all pawns are ahead of the king, on a single rook file and
  // the king is within one file of the pawns, it's a draw.
  if (   !(pawns &amp; ~in_front_bb(weakSide, rank_of(ksq)))
      &amp;&amp; !((pawns &amp; ~FileABB) &amp;&amp; (pawns &amp; ~FileHBB))
      &amp;&amp; file_distance(ksq, psq) &lt;= 1)
      return SCALE_FACTOR_DRAW;

  return SCALE_FACTOR_NONE;
}


/// KBP vs KB. There are two rules: if the defending king is somewhere along the
/// path of the pawn, and the square of the king is not of the same color as the
/// stronger side's bishop, it's a draw. If the two bishops have opposite color,
/// it's almost always a draw.
template&lt;&gt;
ScaleFactor Endgame&lt;KBPKB&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, BishopValueMg, 1));
  assert(verify_material(pos, weakSide,   BishopValueMg, 0));

  Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square strongBishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
  Square weakBishopSq = pos.list&lt;BISHOP&gt;(weakSide)[0];
  Square weakKingSq = pos.king_square(weakSide);

  // Case 1: Defending king blocks the pawn, and cannot be driven away
  if (   file_of(weakKingSq) == file_of(pawnSq)
      &amp;&amp; relative_rank(strongSide, pawnSq) &lt; relative_rank(strongSide, weakKingSq)
      &amp;&amp; (   opposite_colors(weakKingSq, strongBishopSq)
          || relative_rank(strongSide, weakKingSq) &lt;= RANK_6))
      return SCALE_FACTOR_DRAW;

  // Case 2: Opposite colored bishops
  if (opposite_colors(strongBishopSq, weakBishopSq))
  {
      // We assume that the position is drawn in the following three situations:
      //
      //   a. The pawn is on rank 5 or further back.
      //   b. The defending king is somewhere in the pawn's path.
      //   c. The defending bishop attacks some square along the pawn's path,
      //      and is at least three squares away from the pawn.
      //
      // These rules are probably not perfect, but in practice they work
      // reasonably well.

      if (relative_rank(strongSide, pawnSq) &lt;= RANK_5)
          return SCALE_FACTOR_DRAW;
      else
      {
          Bitboard path = forward_bb(strongSide, pawnSq);

          if (path &amp; pos.pieces(weakSide, KING))
              return SCALE_FACTOR_DRAW;

          if (  (pos.attacks_from&lt;BISHOP&gt;(weakBishopSq) &amp; path)
              &amp;&amp; square_distance(weakBishopSq, pawnSq) &gt;= 3)
              return SCALE_FACTOR_DRAW;
      }
  }
  return SCALE_FACTOR_NONE;
}


/// KBPP vs KB. It detects a few basic draws with opposite-colored bishops
template&lt;&gt;
ScaleFactor Endgame&lt;KBPPKB&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, BishopValueMg, 2));
  assert(verify_material(pos, weakSide,   BishopValueMg, 0));

  Square wbsq = pos.list&lt;BISHOP&gt;(strongSide)[0];
  Square bbsq = pos.list&lt;BISHOP&gt;(weakSide)[0];

  if (!opposite_colors(wbsq, bbsq))
      return SCALE_FACTOR_NONE;

  Square ksq = pos.king_square(weakSide);
  Square psq1 = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square psq2 = pos.list&lt;PAWN&gt;(strongSide)[1];
  Rank r1 = rank_of(psq1);
  Rank r2 = rank_of(psq2);
  Square blockSq1, blockSq2;

  if (relative_rank(strongSide, psq1) &gt; relative_rank(strongSide, psq2))
  {
      blockSq1 = psq1 + pawn_push(strongSide);
      blockSq2 = make_square(file_of(psq2), rank_of(psq1));
  }
  else
  {
      blockSq1 = psq2 + pawn_push(strongSide);
      blockSq2 = make_square(file_of(psq1), rank_of(psq2));
  }

  switch (file_distance(psq1, psq2))
  {
  case 0:
    // Both pawns are on the same file. It's an easy draw if the defender firmly
    // controls some square in the frontmost pawn's path.
    if (   file_of(ksq) == file_of(blockSq1)
        &amp;&amp; relative_rank(strongSide, ksq) &gt;= relative_rank(strongSide, blockSq1)
        &amp;&amp; opposite_colors(ksq, wbsq))
        return SCALE_FACTOR_DRAW;
    else
        return SCALE_FACTOR_NONE;

  case 1:
    // Pawns on adjacent files. It's a draw if the defender firmly controls the
    // square in front of the frontmost pawn's path, and the square diagonally
    // behind this square on the file of the other pawn.
    if (   ksq == blockSq1
        &amp;&amp; opposite_colors(ksq, wbsq)
        &amp;&amp; (   bbsq == blockSq2
            || (pos.attacks_from&lt;BISHOP&gt;(blockSq2) &amp; pos.pieces(weakSide, BISHOP))
            || abs(r1 - r2) &gt;= 2))
        return SCALE_FACTOR_DRAW;

    else if (   ksq == blockSq2
             &amp;&amp; opposite_colors(ksq, wbsq)
             &amp;&amp; (   bbsq == blockSq1
                 || (pos.attacks_from&lt;BISHOP&gt;(blockSq1) &amp; pos.pieces(weakSide, BISHOP))))
        return SCALE_FACTOR_DRAW;
    else
        return SCALE_FACTOR_NONE;

  default:
    // The pawns are not on the same file or adjacent files. No scaling.
    return SCALE_FACTOR_NONE;
  }
}


/// KBP vs KN. There is a single rule: If the defending king is somewhere along
/// the path of the pawn, and the square of the king is not of the same color as
/// the stronger side's bishop, it's a draw.
template&lt;&gt;
ScaleFactor Endgame&lt;KBPKN&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, BishopValueMg, 1));
  assert(verify_material(pos, weakSide, KnightValueMg, 0));

  Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square strongBishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
  Square weakKingSq = pos.king_square(weakSide);

  if (   file_of(weakKingSq) == file_of(pawnSq)
      &amp;&amp; relative_rank(strongSide, pawnSq) &lt; relative_rank(strongSide, weakKingSq)
      &amp;&amp; (   opposite_colors(weakKingSq, strongBishopSq)
          || relative_rank(strongSide, weakKingSq) &lt;= RANK_6))
      return SCALE_FACTOR_DRAW;

  return SCALE_FACTOR_NONE;
}


/// KNP vs K. There is a single rule: if the pawn is a rook pawn on the 7th rank
/// and the defending king prevents the pawn from advancing, the position is drawn.
template&lt;&gt;
ScaleFactor Endgame&lt;KNPK&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, KnightValueMg, 1));
  assert(verify_material(pos, weakSide, VALUE_ZERO, 0));

  // Assume strongSide is white and the pawn is on files A-D
  Square pawnSq     = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
  Square weakKingSq = normalize(pos, strongSide, pos.king_square(weakSide));

  if (pawnSq == SQ_A7 &amp;&amp; square_distance(SQ_A8, weakKingSq) &lt;= 1)
      return SCALE_FACTOR_DRAW;

  return SCALE_FACTOR_NONE;
}


/// KNP vs KB. If knight can block bishop from taking pawn, it's a win.
/// Otherwise the position is drawn.
template&lt;&gt;
ScaleFactor Endgame&lt;KNPKB&gt;::operator()(const Position&amp; pos) const {

  Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
  Square bishopSq = pos.list&lt;BISHOP&gt;(weakSide)[0];
  Square weakKingSq = pos.king_square(weakSide);

  // King needs to get close to promoting pawn to prevent knight from blocking.
  // Rules for this are very tricky, so just approximate.
  if (forward_bb(strongSide, pawnSq) &amp; pos.attacks_from&lt;BISHOP&gt;(bishopSq))
      return ScaleFactor(square_distance(weakKingSq, pawnSq));

  return SCALE_FACTOR_NONE;
}


/// KP vs KP. This is done by removing the weakest side's pawn and probing the
/// KP vs K bitbase: If the weakest side has a draw without the pawn, it probably
/// has at least a draw with the pawn as well. The exception is when the stronger
/// side's pawn is far advanced and not on a rook file; in this case it is often
/// possible to win (e.g. 8/4k3/3p4/3P4/6K1/8/8/8 w - - 0 1).
template&lt;&gt;
ScaleFactor Endgame&lt;KPKP&gt;::operator()(const Position&amp; pos) const {

  assert(verify_material(pos, strongSide, VALUE_ZERO, 1));
  assert(verify_material(pos, weakSide,   VALUE_ZERO, 1));

  // Assume strongSide is white and the pawn is on files A-D
  Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
  Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
  Square psq  = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);

  Color us = strongSide == pos.side_to_move() ? WHITE : BLACK;

  // If the pawn has advanced to the fifth rank or further, and is not a
  // rook pawn, it's too dangerous to assume that it's at least a draw.
  if (rank_of(psq) &gt;= RANK_5 &amp;&amp; file_of(psq) != FILE_A)
      return SCALE_FACTOR_NONE;

  // Probe the KPK bitbase with the weakest side's pawn removed. If it's a draw,
  // it's probably at least a draw even with the pawn.
  return Bitbases::probe_kpk(wksq, psq, bksq, us) ? SCALE_FACTOR_NONE : SCALE_FACTOR_DRAW;
}</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
