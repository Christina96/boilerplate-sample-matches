<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for endgame_1.cpp &amp; endgame.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for endgame_1.cpp &amp; endgame.cpp
      </h3>
<h1 align="center">
        95.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>endgame_1.cpp (96.86192%)<th>endgame.cpp (95.07187%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(133-848)<td><a href="#" name="0">(141-856)</a><td align="center"><font color="#ff0000">418</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(28-99)<td><a href="#" name="1">(28-99)</a><td align="center"><font color="#1b0000">45</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>endgame_1.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;algorithm&gt;
2 #include &lt;cassert&gt;
3 #include "bitboard.h"
4 #include "bitcount.h"
5 <a name="1"></a>#include "endgame.h"
6 #include "movegen.h"
7 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>using std::string;
8 namespace {
9   const int PushToEdges[SQUARE_NB] = {
10     100, 90, 80, 70, 70, 80, 90, 100,
11      90, 70, 60, 50, 50, 60, 70,  90,
12      80, 60, 40, 30, 30, 40, 60,  80,
13      70, 50, 30, 20, 20, 30, 50,  70,
14      70, 50, 30, 20, 20, 30, 50,  70,
15      80, 60, 40, 30, 30, 40, 60,  80,
16      90, 70, 60, 50, 50, 60, 70,  90,
17     100, 90, 80, 70, 70, 80, 90, 100,
18   };
19   const int PushToCorners[SQUARE_NB] = {
20     200, 190, 180, 170, 160, 150, 140, 130,
21     190, 180, 170, 160, 150, 140, 130, 140,
22     180, 170, 155, 140, 140, 125, 140, 150,
23     170, 160, 140, 120, 110, 140, 150, 160,
24     160, 150, 140, 110, 120, 140, 160, 170,
25     150, 140, 125, 140, 140, 155, 170, 180,
26     140, 130, 140, 150, 160, 170, 180, 190,
27     130, 140, 150, 160, 170, 180, 190, 200
28   };
29   const int PushClose[8] = { 0, 0, 100, 80, 60, 40, 20, 10 };
30   const int PushAway [8] = { 0, 5, 20, 40, 60, 80, 90, 100 };
31 #ifndef NDEBUG
32   bool verify_material(const Position&amp; pos, Color c, Value npm, int num_pawns) {
33     return pos.non_pawn_material(c) == npm &amp;&amp; pos.count&lt;PAWN&gt;(c) == num_pawns;
34   }
35 #endif
36   Square normalize(const Position&amp; pos, Color strongSide, Square sq) {
37     assert(pos.count&lt;PAWN&gt;(strongSide) == 1);
38     if (file_of(pos.list&lt;PAWN&gt;(strongSide)[0]) &gt;= FILE_E)
39         sq = Square(sq ^ 7); 
40     if (strongSide == BLACK)
41         sq = ~sq;
42     return sq;
43   }
44   Key key(const string&amp; code, Color c) {
45     assert(code.length() &gt; 0 &amp;&amp; code.length() &lt; 8);
46     assert(code[0] == 'K');
47     string sides[] = { code.substr(code.find('K', 1)),                             code.substr(0, code.find('K', 1)) }; 
48     std::transform(sides[c].begin(), sides[c].end(), sides[c].begin(), tolower);
49     string fen =  sides[0] + char(8 - sides[0].length() + '0') + "/8/8/8/8/8/8/"
50                 + sides[1] + char(8 - sides[1].length() + '0') + " w - - 0 10";
51     return Position(fen, false, nullptr).material_key();</b></font>
52   }
53 } 
54 Endgames::Endgames() {
55   add&lt;KPK&gt;("KPK");
56   add&lt;KNNK&gt;("KNNK");
57   add&lt;KBNK&gt;("KBNK");
58   add&lt;KRKP&gt;("KRKP");
59   add&lt;KRKB&gt;("KRKB");
60   add&lt;KRKN&gt;("KRKN");
61   add&lt;KQKP&gt;("KQKP");
62   add&lt;KQKR&gt;("KQKR");
63   add&lt;KNPK&gt;("KNPK");
64   add&lt;KNPKB&gt;("KNPKB");
65   add&lt;KRPKR&gt;("KRPKR");
66   add&lt;KRPKB&gt;("KRPKB");
67   add&lt;KBPKB&gt;("KBPKB");
68   add&lt;KBPKN&gt;("KBPKN");
69   add&lt;KBPPKB&gt;("KBPPKB");
70   add&lt;KRPPKRP&gt;("KRPPKRP");
71 }
72 template&lt;EndgameType E, typename T&gt;
73 <a name="0"></a>void Endgames::add(const string&amp; code) {
74   map&lt;T&gt;()[key(code, WHITE)] = std::unique_ptr&lt;T&gt;(new Endgame&lt;E&gt;(WHITE));
75 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  map&lt;T&gt;()[key(code, BLACK)] = std::unique_ptr&lt;T&gt;(new Endgame&lt;E&gt;(BLACK));
76 }
77 template&lt;&gt;
78 Value Endgame&lt;KXK&gt;::operator()(const Position&amp; pos) const {
79   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
80   assert(!pos.checkers()); 
81   if (pos.side_to_move() == weakSide &amp;&amp; !MoveList&lt;LEGAL&gt;(pos).size())
82       return VALUE_DRAW;
83   Square winnerKSq = pos.king_square(strongSide);
84   Square loserKSq = pos.king_square(weakSide);
85   Value result =  pos.non_pawn_material(strongSide)
86                 + pos.count&lt;PAWN&gt;(strongSide) * PawnValueEg
87                 + PushToEdges[loserKSq]
88                 + PushClose[square_distance(winnerKSq, loserKSq)];
89   if (   pos.count&lt;QUEEN&gt;(strongSide)
90       || pos.count&lt;ROOK&gt;(strongSide)
91       ||(pos.count&lt;BISHOP&gt;(strongSide) &amp;&amp; pos.count&lt;KNIGHT&gt;(strongSide))
92       || pos.bishop_pair(strongSide))
93       result += VALUE_KNOWN_WIN;
94   return strongSide == pos.side_to_move() ? result : -result;
95 }
96 template&lt;&gt;
97 Value Endgame&lt;KBNK&gt;::operator()(const Position&amp; pos) const {
98   assert(verify_material(pos, strongSide, KnightValueMg + BishopValueMg, 0));
99   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
100   Square winnerKSq = pos.king_square(strongSide);
101   Square loserKSq = pos.king_square(weakSide);
102   Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
103   if (opposite_colors(bishopSq, SQ_A1))
104   {
105       winnerKSq = ~winnerKSq;
106       loserKSq  = ~loserKSq;
107   }
108   Value result =  VALUE_KNOWN_WIN
109                 + PushClose[square_distance(winnerKSq, loserKSq)]
110                 + PushToCorners[loserKSq];
111   return strongSide == pos.side_to_move() ? result : -result;
112 }
113 template&lt;&gt;
114 Value Endgame&lt;KPK&gt;::operator()(const Position&amp; pos) const {
115   assert(verify_material(pos, strongSide, VALUE_ZERO, 1));
116   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
117   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
118   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
119   Square psq  = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
120   Color us = strongSide == pos.side_to_move() ? WHITE : BLACK;
121   if (!Bitbases::probe_kpk(wksq, psq, bksq, us))
122       return VALUE_DRAW;
123   Value result = VALUE_KNOWN_WIN + PawnValueEg + Value(rank_of(psq));
124   return strongSide == pos.side_to_move() ? result : -result;
125 }
126 template&lt;&gt;
127 Value Endgame&lt;KRKP&gt;::operator()(const Position&amp; pos) const {
128   assert(verify_material(pos, strongSide, RookValueMg, 0));
129   assert(verify_material(pos, weakSide, VALUE_ZERO, 1));
130   Square wksq = relative_square(strongSide, pos.king_square(strongSide));
131   Square bksq = relative_square(strongSide, pos.king_square(weakSide));
132   Square rsq  = relative_square(strongSide, pos.list&lt;ROOK&gt;(strongSide)[0]);
133   Square psq  = relative_square(strongSide, pos.list&lt;PAWN&gt;(weakSide)[0]);
134   Square queeningSq = make_square(file_of(psq), RANK_1);
135   Value result;
136   if (wksq &lt; psq &amp;&amp; file_of(wksq) == file_of(psq))
137       result = RookValueEg - square_distance(wksq, psq);
138   else if (   square_distance(bksq, psq) &gt;= 3 + (pos.side_to_move() == weakSide)
139            &amp;&amp; square_distance(bksq, rsq) &gt;= 3)
140       result = RookValueEg - square_distance(wksq, psq);
141   else if (   rank_of(bksq) &lt;= RANK_3
142            &amp;&amp; square_distance(bksq, psq) == 1
143            &amp;&amp; rank_of(wksq) &gt;= RANK_4
144            &amp;&amp; square_distance(wksq, psq) &gt; 2 + (pos.side_to_move() == strongSide))
145       result = Value(80) - 8 * square_distance(wksq, psq);
146   else
147       result =  Value(200) - 8 * (  square_distance(wksq, psq + DELTA_S)
148                                   - square_distance(bksq, psq + DELTA_S)
149                                   - square_distance(psq, queeningSq));
150   return strongSide == pos.side_to_move() ? result : -result;
151 }
152 template&lt;&gt;
153 Value Endgame&lt;KRKB&gt;::operator()(const Position&amp; pos) const {
154   assert(verify_material(pos, strongSide, RookValueMg, 0));
155   assert(verify_material(pos, weakSide, BishopValueMg, 0));
156   Value result = Value(PushToEdges[pos.king_square(weakSide)]);
157   return strongSide == pos.side_to_move() ? result : -result;
158 }
159 template&lt;&gt;
160 Value Endgame&lt;KRKN&gt;::operator()(const Position&amp; pos) const {
161   assert(verify_material(pos, strongSide, RookValueMg, 0));
162   assert(verify_material(pos, weakSide, KnightValueMg, 0));
163   Square bksq = pos.king_square(weakSide);
164   Square bnsq = pos.list&lt;KNIGHT&gt;(weakSide)[0];
165   Value result = Value(PushToEdges[bksq] + PushAway[square_distance(bksq, bnsq)]);
166   return strongSide == pos.side_to_move() ? result : -result;
167 }
168 template&lt;&gt;
169 Value Endgame&lt;KQKP&gt;::operator()(const Position&amp; pos) const {
170   assert(verify_material(pos, strongSide, QueenValueMg, 0));
171   assert(verify_material(pos, weakSide, VALUE_ZERO, 1));
172   Square winnerKSq = pos.king_square(strongSide);
173   Square loserKSq = pos.king_square(weakSide);
174   Square pawnSq = pos.list&lt;PAWN&gt;(weakSide)[0];
175   Value result = Value(PushClose[square_distance(winnerKSq, loserKSq)]);
176   if (   relative_rank(weakSide, pawnSq) != RANK_7
177       || square_distance(loserKSq, pawnSq) != 1
178       || !((FileABB | FileCBB | FileFBB | FileHBB) &amp; pawnSq))
179       result += QueenValueEg - PawnValueEg;
180   return strongSide == pos.side_to_move() ? result : -result;
181 }
182 template&lt;&gt;
183 Value Endgame&lt;KQKR&gt;::operator()(const Position&amp; pos) const {
184   assert(verify_material(pos, strongSide, QueenValueMg, 0));
185   assert(verify_material(pos, weakSide, RookValueMg, 0));
186   Square winnerKSq = pos.king_square(strongSide);
187   Square loserKSq = pos.king_square(weakSide);
188   Value result =  QueenValueEg
189                 - RookValueEg
190                 + PushToEdges[loserKSq]
191                 + PushClose[square_distance(winnerKSq, loserKSq)];
192   return strongSide == pos.side_to_move() ? result : -result;
193 }
194 template&lt;&gt; Value Endgame&lt;KNNK&gt;::operator()(const Position&amp;) const { return VALUE_DRAW; }
195 template&lt;&gt;
196 ScaleFactor Endgame&lt;KBPsK&gt;::operator()(const Position&amp; pos) const {
197   assert(pos.non_pawn_material(strongSide) == BishopValueMg);
198   assert(pos.count&lt;PAWN&gt;(strongSide) &gt;= 1);
199   Bitboard pawns = pos.pieces(strongSide, PAWN);
200   File pawnFile = file_of(pos.list&lt;PAWN&gt;(strongSide)[0]);
201   if (    (pawnFile == FILE_A || pawnFile == FILE_H)
202       &amp;&amp; !(pawns &amp; ~file_bb(pawnFile)))
203   {
204       Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
205       Square queeningSq = relative_square(strongSide, make_square(pawnFile, RANK_8));
206       Square kingSq = pos.king_square(weakSide);
207       if (   opposite_colors(queeningSq, bishopSq)
208           &amp;&amp; square_distance(queeningSq, kingSq) &lt;= 1)
209           return SCALE_FACTOR_DRAW;
210   }
211   if (    (pawnFile == FILE_B || pawnFile == FILE_G)
212       &amp;&amp; !(pos.pieces(PAWN) &amp; ~file_bb(pawnFile))
213       &amp;&amp; pos.non_pawn_material(weakSide) == 0
214       &amp;&amp; pos.count&lt;PAWN&gt;(weakSide) &gt;= 1)
215   {
216       Square weakPawnSq = backmost_sq(weakSide, pos.pieces(weakSide, PAWN));
217       Square strongKingSq = pos.king_square(strongSide);
218       Square weakKingSq = pos.king_square(weakSide);
219       Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
220       if (   relative_rank(strongSide, weakPawnSq) == RANK_7
221           &amp;&amp; (pos.pieces(strongSide, PAWN) &amp; (weakPawnSq + pawn_push(weakSide)))
222           &amp;&amp; (opposite_colors(bishopSq, weakPawnSq) || pos.count&lt;PAWN&gt;(strongSide) == 1))
223       {
224           int strongKingDist = square_distance(weakPawnSq, strongKingSq);
225           int weakKingDist = square_distance(weakPawnSq, weakKingSq);
226           if (   relative_rank(strongSide, weakKingSq) &gt;= RANK_7
227               &amp;&amp; weakKingDist &lt;= 2
228               &amp;&amp; weakKingDist &lt;= strongKingDist)
229               return SCALE_FACTOR_DRAW;
230       }
231   }
232   return SCALE_FACTOR_NONE;
233 }
234 template&lt;&gt;
235 ScaleFactor Endgame&lt;KQKRPs&gt;::operator()(const Position&amp; pos) const {
236   assert(verify_material(pos, strongSide, QueenValueMg, 0));
237   assert(pos.count&lt;ROOK&gt;(weakSide) == 1);
238   assert(pos.count&lt;PAWN&gt;(weakSide) &gt;= 1);
239   Square kingSq = pos.king_square(weakSide);
240   Square rsq = pos.list&lt;ROOK&gt;(weakSide)[0];
241   if (    relative_rank(weakSide, kingSq) &lt;= RANK_2
242       &amp;&amp;  relative_rank(weakSide, pos.king_square(strongSide)) &gt;= RANK_4
243       &amp;&amp;  relative_rank(weakSide, rsq) == RANK_3
244       &amp;&amp; (  pos.pieces(weakSide, PAWN)
245           &amp; pos.attacks_from&lt;KING&gt;(kingSq)
246           &amp; pos.attacks_from&lt;PAWN&gt;(rsq, strongSide)))
247           return SCALE_FACTOR_DRAW;
248   return SCALE_FACTOR_NONE;
249 }
250 template&lt;&gt;
251 ScaleFactor Endgame&lt;KRPKR&gt;::operator()(const Position&amp; pos) const {
252   assert(verify_material(pos, strongSide, RookValueMg, 1));
253   assert(verify_material(pos, weakSide,   RookValueMg, 0));
254   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
255   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
256   Square wrsq = normalize(pos, strongSide, pos.list&lt;ROOK&gt;(strongSide)[0]);
257   Square wpsq = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
258   Square brsq = normalize(pos, strongSide, pos.list&lt;ROOK&gt;(weakSide)[0]);
259   File f = file_of(wpsq);
260   Rank r = rank_of(wpsq);
261   Square queeningSq = make_square(f, RANK_8);
262   int tempo = (pos.side_to_move() == strongSide);
263   if (   r &lt;= RANK_5
264       &amp;&amp; square_distance(bksq, queeningSq) &lt;= 1
265       &amp;&amp; wksq &lt;= SQ_H5
266       &amp;&amp; (rank_of(brsq) == RANK_6 || (r &lt;= RANK_3 &amp;&amp; rank_of(wrsq) != RANK_6)))
267       return SCALE_FACTOR_DRAW;
268   if (   r == RANK_6
269       &amp;&amp; square_distance(bksq, queeningSq) &lt;= 1
270       &amp;&amp; rank_of(wksq) + tempo &lt;= RANK_6
271       &amp;&amp; (rank_of(brsq) == RANK_1 || (!tempo &amp;&amp; abs(file_of(brsq) - f) &gt;= 3)))
272       return SCALE_FACTOR_DRAW;
273   if (   r &gt;= RANK_6
274       &amp;&amp; bksq == queeningSq
275       &amp;&amp; rank_of(brsq) == RANK_1
276       &amp;&amp; (!tempo || square_distance(wksq, wpsq) &gt;= 2))
277       return SCALE_FACTOR_DRAW;
278   if (   wpsq == SQ_A7
279       &amp;&amp; wrsq == SQ_A8
280       &amp;&amp; (bksq == SQ_H7 || bksq == SQ_G7)
281       &amp;&amp; file_of(brsq) == FILE_A
282       &amp;&amp; (rank_of(brsq) &lt;= RANK_3 || file_of(wksq) &gt;= FILE_D || rank_of(wksq) &lt;= RANK_5))
283       return SCALE_FACTOR_DRAW;
284   if (   r &lt;= RANK_5
285       &amp;&amp; bksq == wpsq + DELTA_N
286       &amp;&amp; square_distance(wksq, wpsq) - tempo &gt;= 2
287       &amp;&amp; square_distance(wksq, brsq) - tempo &gt;= 2)
288       return SCALE_FACTOR_DRAW;
289   if (   r == RANK_7
290       &amp;&amp; f != FILE_A
291       &amp;&amp; file_of(wrsq) == f
292       &amp;&amp; wrsq != queeningSq
293       &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, queeningSq) - 2 + tempo)
294       &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, wrsq) + tempo))
295       return ScaleFactor(SCALE_FACTOR_MAX - 2 * square_distance(wksq, queeningSq));
296   if (   f != FILE_A
297       &amp;&amp; file_of(wrsq) == f
298       &amp;&amp; wrsq &lt; wpsq
299       &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, queeningSq) - 2 + tempo)
300       &amp;&amp; (square_distance(wksq, wpsq + DELTA_N) &lt; square_distance(bksq, wpsq + DELTA_N) - 2 + tempo)
301       &amp;&amp; (  square_distance(bksq, wrsq) + tempo &gt;= 3
302           || (    square_distance(wksq, queeningSq) &lt; square_distance(bksq, wrsq) + tempo
303               &amp;&amp; (square_distance(wksq, wpsq + DELTA_N) &lt; square_distance(bksq, wrsq) + tempo))))
304       return ScaleFactor(  SCALE_FACTOR_MAX
305                          - 8 * square_distance(wpsq, queeningSq)
306                          - 2 * square_distance(wksq, queeningSq));
307   if (r &lt;= RANK_4 &amp;&amp; bksq &gt; wpsq)
308   {
309       if (file_of(bksq) == file_of(wpsq))
310           return ScaleFactor(10);
311       if (   abs(file_of(bksq) - file_of(wpsq)) == 1
312           &amp;&amp; square_distance(wksq, bksq) &gt; 2)
313           return ScaleFactor(24 - 2 * square_distance(wksq, bksq));
314   }
315   return SCALE_FACTOR_NONE;
316 }
317 template&lt;&gt;
318 ScaleFactor Endgame&lt;KRPKB&gt;::operator()(const Position&amp; pos) const {
319   assert(verify_material(pos, strongSide, RookValueMg, 1));
320   assert(verify_material(pos, weakSide, BishopValueMg, 0));
321   if (pos.pieces(PAWN) &amp; (FileABB | FileHBB))
322   {
323       Square ksq = pos.king_square(weakSide);
324       Square bsq = pos.list&lt;BISHOP&gt;(weakSide)[0];
325       Square psq = pos.list&lt;PAWN&gt;(strongSide)[0];
326       Rank rk = relative_rank(strongSide, psq);
327       Square push = pawn_push(strongSide);
328       if (rk == RANK_5 &amp;&amp; !opposite_colors(bsq, psq))
329       {
330           int d = square_distance(psq + 3 * push, ksq);
331           if (d &lt;= 2 &amp;&amp; !(d == 0 &amp;&amp; ksq == pos.king_square(strongSide) + 2 * push))
332               return ScaleFactor(24);
333           else
334               return ScaleFactor(48);
335       }
336       if (   rk == RANK_6
337           &amp;&amp; square_distance(psq + 2 * push, ksq) &lt;= 1
338           &amp;&amp; (PseudoAttacks[BISHOP][bsq] &amp; (psq + push))
339           &amp;&amp; file_distance(bsq, psq) &gt;= 2)
340           return ScaleFactor(8);
341   }
342   return SCALE_FACTOR_NONE;
343 }
344 template&lt;&gt;
345 ScaleFactor Endgame&lt;KRPPKRP&gt;::operator()(const Position&amp; pos) const {
346   assert(verify_material(pos, strongSide, RookValueMg, 2));
347   assert(verify_material(pos, weakSide,   RookValueMg, 1));
348   Square wpsq1 = pos.list&lt;PAWN&gt;(strongSide)[0];
349   Square wpsq2 = pos.list&lt;PAWN&gt;(strongSide)[1];
350   Square bksq = pos.king_square(weakSide);
351   if (pos.pawn_passed(strongSide, wpsq1) || pos.pawn_passed(strongSide, wpsq2))
352       return SCALE_FACTOR_NONE;
353   Rank r = std::max(relative_rank(strongSide, wpsq1), relative_rank(strongSide, wpsq2));
354   if (   file_distance(bksq, wpsq1) &lt;= 1
355       &amp;&amp; file_distance(bksq, wpsq2) &lt;= 1
356       &amp;&amp; relative_rank(strongSide, bksq) &gt; r)
357   {
358       switch (r) {
359       case RANK_2: return ScaleFactor(10);
360       case RANK_3: return ScaleFactor(10);
361       case RANK_4: return ScaleFactor(15);
362       case RANK_5: return ScaleFactor(20);
363       case RANK_6: return ScaleFactor(40);
364       default: assert(false);
365       }
366   }
367   return SCALE_FACTOR_NONE;
368 }
369 template&lt;&gt;
370 ScaleFactor Endgame&lt;KPsK&gt;::operator()(const Position&amp; pos) const {
371   assert(pos.non_pawn_material(strongSide) == VALUE_ZERO);
372   assert(pos.count&lt;PAWN&gt;(strongSide) &gt;= 2);
373   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
374   Square ksq = pos.king_square(weakSide);
375   Bitboard pawns = pos.pieces(strongSide, PAWN);
376   Square psq = pos.list&lt;PAWN&gt;(strongSide)[0];
377   if (   !(pawns &amp; ~in_front_bb(weakSide, rank_of(ksq)))
378       &amp;&amp; !((pawns &amp; ~FileABB) &amp;&amp; (pawns &amp; ~FileHBB))
379       &amp;&amp; file_distance(ksq, psq) &lt;= 1)
380       return SCALE_FACTOR_DRAW;
381   return SCALE_FACTOR_NONE;
382 }
383 template&lt;&gt;
384 ScaleFactor Endgame&lt;KBPKB&gt;::operator()(const Position&amp; pos) const {
385   assert(verify_material(pos, strongSide, BishopValueMg, 1));
386   assert(verify_material(pos, weakSide,   BishopValueMg, 0));
387   Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
388   Square strongBishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
389   Square weakBishopSq = pos.list&lt;BISHOP&gt;(weakSide)[0];
390   Square weakKingSq = pos.king_square(weakSide);
391   if (   file_of(weakKingSq) == file_of(pawnSq)
392       &amp;&amp; relative_rank(strongSide, pawnSq) &lt; relative_rank(strongSide, weakKingSq)
393       &amp;&amp; (   opposite_colors(weakKingSq, strongBishopSq)
394           || relative_rank(strongSide, weakKingSq) &lt;= RANK_6))
395       return SCALE_FACTOR_DRAW;
396   if (opposite_colors(strongBishopSq, weakBishopSq))
397   {
398       if (relative_rank(strongSide, pawnSq) &lt;= RANK_5)
399           return SCALE_FACTOR_DRAW;
400       else
401       {
402           Bitboard path = forward_bb(strongSide, pawnSq);
403           if (path &amp; pos.pieces(weakSide, KING))
404               return SCALE_FACTOR_DRAW;
405           if (  (pos.attacks_from&lt;BISHOP&gt;(weakBishopSq) &amp; path)
406               &amp;&amp; square_distance(weakBishopSq, pawnSq) &gt;= 3)
407               return SCALE_FACTOR_DRAW;
408       }
409   }
410   return SCALE_FACTOR_NONE;
411 }
412 template&lt;&gt;
413 ScaleFactor Endgame&lt;KBPPKB&gt;::operator()(const Position&amp; pos) const {
414   assert(verify_material(pos, strongSide, BishopValueMg, 2));
415   assert(verify_material(pos, weakSide,   BishopValueMg, 0));
416   Square wbsq = pos.list&lt;BISHOP&gt;(strongSide)[0];
417   Square bbsq = pos.list&lt;BISHOP&gt;(weakSide)[0];
418   if (!opposite_colors(wbsq, bbsq))
419       return SCALE_FACTOR_NONE;
420   Square ksq = pos.king_square(weakSide);
421   Square psq1 = pos.list&lt;PAWN&gt;(strongSide)[0];
422   Square psq2 = pos.list&lt;PAWN&gt;(strongSide)[1];
423   Rank r1 = rank_of(psq1);
424   Rank r2 = rank_of(psq2);
425   Square blockSq1, blockSq2;
426   if (relative_rank(strongSide, psq1) &gt; relative_rank(strongSide, psq2))
427   {
428       blockSq1 = psq1 + pawn_push(strongSide);
429       blockSq2 = make_square(file_of(psq2), rank_of(psq1));
430   }
431   else
432   {
433       blockSq1 = psq2 + pawn_push(strongSide);
434       blockSq2 = make_square(file_of(psq1), rank_of(psq2));
435   }
436   switch (file_distance(psq1, psq2))
437   {
438   case 0:
439     if (   file_of(ksq) == file_of(blockSq1)
440         &amp;&amp; relative_rank(strongSide, ksq) &gt;= relative_rank(strongSide, blockSq1)
441         &amp;&amp; opposite_colors(ksq, wbsq))
442         return SCALE_FACTOR_DRAW;
443     else
444         return SCALE_FACTOR_NONE;
445   case 1:
446     if (   ksq == blockSq1
447         &amp;&amp; opposite_colors(ksq, wbsq)
448         &amp;&amp; (   bbsq == blockSq2
449             || (pos.attacks_from&lt;BISHOP&gt;(blockSq2) &amp; pos.pieces(weakSide, BISHOP))
450             || abs(r1 - r2) &gt;= 2))
451         return SCALE_FACTOR_DRAW;
452     else if (   ksq == blockSq2
453              &amp;&amp; opposite_colors(ksq, wbsq)
454              &amp;&amp; (   bbsq == blockSq1
455                  || (pos.attacks_from&lt;BISHOP&gt;(blockSq1) &amp; pos.pieces(weakSide, BISHOP))))
456         return SCALE_FACTOR_DRAW;
457     else
458         return SCALE_FACTOR_NONE;
459   default:
460     return SCALE_FACTOR_NONE;
461   }
462 }
463 template&lt;&gt;
464 ScaleFactor Endgame&lt;KBPKN&gt;::operator()(const Position&amp; pos) const {
465   assert(verify_material(pos, strongSide, BishopValueMg, 1));
466   assert(verify_material(pos, weakSide, KnightValueMg, 0));
467   Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
468   Square strongBishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
469   Square weakKingSq = pos.king_square(weakSide);
470   if (   file_of(weakKingSq) == file_of(pawnSq)
471       &amp;&amp; relative_rank(strongSide, pawnSq) &lt; relative_rank(strongSide, weakKingSq)
472       &amp;&amp; (   opposite_colors(weakKingSq, strongBishopSq)
473           || relative_rank(strongSide, weakKingSq) &lt;= RANK_6))
474       return SCALE_FACTOR_DRAW;
475   return SCALE_FACTOR_NONE;
476 }
477 template&lt;&gt;
478 ScaleFactor Endgame&lt;KNPK&gt;::operator()(const Position&amp; pos) const {
479   assert(verify_material(pos, strongSide, KnightValueMg, 1));
480   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
481   Square pawnSq     = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
482   Square weakKingSq = normalize(pos, strongSide, pos.king_square(weakSide));
483   if (pawnSq == SQ_A7 &amp;&amp; square_distance(SQ_A8, weakKingSq) &lt;= 1)
484       return SCALE_FACTOR_DRAW;
485   return SCALE_FACTOR_NONE;
486 }
487 template&lt;&gt;
488 ScaleFactor Endgame&lt;KNPKB&gt;::operator()(const Position&amp; pos) const {
489   Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
490   Square bishopSq = pos.list&lt;BISHOP&gt;(weakSide)[0];
491   Square weakKingSq = pos.king_square(weakSide);
492   if (forward_bb(strongSide, pawnSq) &amp; pos.attacks_from&lt;BISHOP&gt;(bishopSq))
493       return ScaleFactor(square_distance(weakKingSq, pawnSq));
494   return SCALE_FACTOR_NONE;
495 }
496 template&lt;&gt;
497 ScaleFactor Endgame&lt;KPKP&gt;::operator()(const Position&amp; pos) const {
498   assert(verify_material(pos, strongSide, VALUE_ZERO, 1));
499   assert(verify_material(pos, weakSide,   VALUE_ZERO, 1));
500   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
501   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
502   Square psq  = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
503   Color us = strongSide == pos.side_to_move() ? WHITE : BLACK;
504   if (rank_of(psq) &gt;= RANK_5 &amp;&amp; file_of(psq) != FILE_A)
505       return SCALE_FACTOR_NONE;
506   return Bitbases::probe_kpk(wksq, psq, bksq, us) ? SCALE_FACTOR_NONE : SCALE_FACTOR_DRAW;
507 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>endgame.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;algorithm&gt;
2 #include &lt;cassert&gt;
3 #include "bitboard.h"
4 #include "bitcount.h"
5 <a name="1"></a>#include "endgame.h"
6 #include "movegen.h"
7 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>using std::string;
8 namespace {
9   const int PushToEdges[SQUARE_NB] = {
10     100, 90, 80, 70, 70, 80, 90, 100,
11      90, 70, 60, 50, 50, 60, 70,  90,
12      80, 60, 40, 30, 30, 40, 60,  80,
13      70, 50, 30, 20, 20, 30, 50,  70,
14      70, 50, 30, 20, 20, 30, 50,  70,
15      80, 60, 40, 30, 30, 40, 60,  80,
16      90, 70, 60, 50, 50, 60, 70,  90,
17     100, 90, 80, 70, 70, 80, 90, 100,
18   };
19   const int PushToCorners[SQUARE_NB] = {
20     200, 190, 180, 170, 160, 150, 140, 130,
21     190, 180, 170, 160, 150, 140, 130, 140,
22     180, 170, 155, 140, 140, 125, 140, 150,
23     170, 160, 140, 120, 110, 140, 150, 160,
24     160, 150, 140, 110, 120, 140, 160, 170,
25     150, 140, 125, 140, 140, 155, 170, 180,
26     140, 130, 140, 150, 160, 170, 180, 190,
27     130, 140, 150, 160, 170, 180, 190, 200
28   };
29   const int PushClose[8] = { 0, 0, 100, 80, 60, 40, 20, 10 };
30   const int PushAway [8] = { 0, 5, 20, 40, 60, 80, 90, 100 };
31 #ifndef NDEBUG
32   bool verify_material(const Position&amp; pos, Color c, Value npm, int num_pawns) {
33     return pos.non_pawn_material(c) == npm &amp;&amp; pos.count&lt;PAWN&gt;(c) == num_pawns;
34   }
35 #endif
36   Square normalize(const Position&amp; pos, Color strongSide, Square sq) {
37     assert(pos.count&lt;PAWN&gt;(strongSide) == 1);
38     if (file_of(pos.list&lt;PAWN&gt;(strongSide)[0]) &gt;= FILE_E)
39         sq = Square(sq ^ 7); 
40     if (strongSide == BLACK)
41         sq = ~sq;
42     return sq;
43   }
44   Key key(const string&amp; code, Color c) {
45     assert(code.length() &gt; 0 &amp;&amp; code.length() &lt; 8);
46     assert(code[0] == 'K');
47     string sides[] = { code.substr(code.find('K', 1)),                             code.substr(0, code.find('K', 1)) }; 
48     std::transform(sides[c].begin(), sides[c].end(), sides[c].begin(), tolower);
49     string fen =  sides[0] + char(8 - sides[0].length() + '0') + "/8/8/8/8/8/8/"
50                 + sides[1] + char(8 - sides[1].length() + '0') + " w - - 0 10";
51     return Position(fen, false, NULL).material_key();</b></font>
52   }
53   template&lt;typename M&gt;
54   void delete_endgame(const typename M::value_type&amp; p) { delete p.second; }
55 } 
56 Endgames::Endgames() {
57   add&lt;KPK&gt;("KPK");
58   add&lt;KNNK&gt;("KNNK");
59   add&lt;KBNK&gt;("KBNK");
60   add&lt;KRKP&gt;("KRKP");
61   add&lt;KRKB&gt;("KRKB");
62   add&lt;KRKN&gt;("KRKN");
63   add&lt;KQKP&gt;("KQKP");
64   add&lt;KQKR&gt;("KQKR");
65   add&lt;KNPK&gt;("KNPK");
66   add&lt;KNPKB&gt;("KNPKB");
67   add&lt;KRPKR&gt;("KRPKR");
68   add&lt;KRPKB&gt;("KRPKB");
69   add&lt;KBPKB&gt;("KBPKB");
70   add&lt;KBPKN&gt;("KBPKN");
71   add&lt;KBPPKB&gt;("KBPPKB");
72   add&lt;KRPPKRP&gt;("KRPPKRP");
73 }
74 Endgames::~Endgames() {
75   for_each(m1.begin(), m1.end(), delete_endgame&lt;M1&gt;);
76   for_each(m2.begin(), m2.end(), delete_endgame&lt;M2&gt;);
77 }
78 template&lt;EndgameType E&gt;
79 <a name="0"></a>void Endgames::add(const string&amp; code) {
80   map((Endgame&lt;E&gt;*)0)[key(code, WHITE)] = new Endgame&lt;E&gt;(WHITE);
81 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  map((Endgame&lt;E&gt;*)0)[key(code, BLACK)] = new Endgame&lt;E&gt;(BLACK);
82 }
83 template&lt;&gt;
84 Value Endgame&lt;KXK&gt;::operator()(const Position&amp; pos) const {
85   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
86   assert(!pos.checkers()); 
87   if (pos.side_to_move() == weakSide &amp;&amp; !MoveList&lt;LEGAL&gt;(pos).size())
88       return VALUE_DRAW;
89   Square winnerKSq = pos.king_square(strongSide);
90   Square loserKSq = pos.king_square(weakSide);
91   Value result =  pos.non_pawn_material(strongSide)
92                 + pos.count&lt;PAWN&gt;(strongSide) * PawnValueEg
93                 + PushToEdges[loserKSq]
94                 + PushClose[square_distance(winnerKSq, loserKSq)];
95   if (   pos.count&lt;QUEEN&gt;(strongSide)
96       || pos.count&lt;ROOK&gt;(strongSide)
97       ||(pos.count&lt;BISHOP&gt;(strongSide) &amp;&amp; pos.count&lt;KNIGHT&gt;(strongSide))
98       || pos.bishop_pair(strongSide))
99       result += VALUE_KNOWN_WIN;
100   return strongSide == pos.side_to_move() ? result : -result;
101 }
102 template&lt;&gt;
103 Value Endgame&lt;KBNK&gt;::operator()(const Position&amp; pos) const {
104   assert(verify_material(pos, strongSide, KnightValueMg + BishopValueMg, 0));
105   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
106   Square winnerKSq = pos.king_square(strongSide);
107   Square loserKSq = pos.king_square(weakSide);
108   Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
109   if (opposite_colors(bishopSq, SQ_A1))
110   {
111       winnerKSq = ~winnerKSq;
112       loserKSq  = ~loserKSq;
113   }
114   Value result =  VALUE_KNOWN_WIN
115                 + PushClose[square_distance(winnerKSq, loserKSq)]
116                 + PushToCorners[loserKSq];
117   return strongSide == pos.side_to_move() ? result : -result;
118 }
119 template&lt;&gt;
120 Value Endgame&lt;KPK&gt;::operator()(const Position&amp; pos) const {
121   assert(verify_material(pos, strongSide, VALUE_ZERO, 1));
122   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
123   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
124   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
125   Square psq  = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
126   Color us = strongSide == pos.side_to_move() ? WHITE : BLACK;
127   if (!Bitbases::probe_kpk(wksq, psq, bksq, us))
128       return VALUE_DRAW;
129   Value result = VALUE_KNOWN_WIN + PawnValueEg + Value(rank_of(psq));
130   return strongSide == pos.side_to_move() ? result : -result;
131 }
132 template&lt;&gt;
133 Value Endgame&lt;KRKP&gt;::operator()(const Position&amp; pos) const {
134   assert(verify_material(pos, strongSide, RookValueMg, 0));
135   assert(verify_material(pos, weakSide, VALUE_ZERO, 1));
136   Square wksq = relative_square(strongSide, pos.king_square(strongSide));
137   Square bksq = relative_square(strongSide, pos.king_square(weakSide));
138   Square rsq  = relative_square(strongSide, pos.list&lt;ROOK&gt;(strongSide)[0]);
139   Square psq  = relative_square(strongSide, pos.list&lt;PAWN&gt;(weakSide)[0]);
140   Square queeningSq = make_square(file_of(psq), RANK_1);
141   Value result;
142   if (wksq &lt; psq &amp;&amp; file_of(wksq) == file_of(psq))
143       result = RookValueEg - square_distance(wksq, psq);
144   else if (   square_distance(bksq, psq) &gt;= 3 + (pos.side_to_move() == weakSide)
145            &amp;&amp; square_distance(bksq, rsq) &gt;= 3)
146       result = RookValueEg - square_distance(wksq, psq);
147   else if (   rank_of(bksq) &lt;= RANK_3
148            &amp;&amp; square_distance(bksq, psq) == 1
149            &amp;&amp; rank_of(wksq) &gt;= RANK_4
150            &amp;&amp; square_distance(wksq, psq) &gt; 2 + (pos.side_to_move() == strongSide))
151       result = Value(80) - 8 * square_distance(wksq, psq);
152   else
153       result =  Value(200) - 8 * (  square_distance(wksq, psq + DELTA_S)
154                                   - square_distance(bksq, psq + DELTA_S)
155                                   - square_distance(psq, queeningSq));
156   return strongSide == pos.side_to_move() ? result : -result;
157 }
158 template&lt;&gt;
159 Value Endgame&lt;KRKB&gt;::operator()(const Position&amp; pos) const {
160   assert(verify_material(pos, strongSide, RookValueMg, 0));
161   assert(verify_material(pos, weakSide, BishopValueMg, 0));
162   Value result = Value(PushToEdges[pos.king_square(weakSide)]);
163   return strongSide == pos.side_to_move() ? result : -result;
164 }
165 template&lt;&gt;
166 Value Endgame&lt;KRKN&gt;::operator()(const Position&amp; pos) const {
167   assert(verify_material(pos, strongSide, RookValueMg, 0));
168   assert(verify_material(pos, weakSide, KnightValueMg, 0));
169   Square bksq = pos.king_square(weakSide);
170   Square bnsq = pos.list&lt;KNIGHT&gt;(weakSide)[0];
171   Value result = Value(PushToEdges[bksq] + PushAway[square_distance(bksq, bnsq)]);
172   return strongSide == pos.side_to_move() ? result : -result;
173 }
174 template&lt;&gt;
175 Value Endgame&lt;KQKP&gt;::operator()(const Position&amp; pos) const {
176   assert(verify_material(pos, strongSide, QueenValueMg, 0));
177   assert(verify_material(pos, weakSide, VALUE_ZERO, 1));
178   Square winnerKSq = pos.king_square(strongSide);
179   Square loserKSq = pos.king_square(weakSide);
180   Square pawnSq = pos.list&lt;PAWN&gt;(weakSide)[0];
181   Value result = Value(PushClose[square_distance(winnerKSq, loserKSq)]);
182   if (   relative_rank(weakSide, pawnSq) != RANK_7
183       || square_distance(loserKSq, pawnSq) != 1
184       || !((FileABB | FileCBB | FileFBB | FileHBB) &amp; pawnSq))
185       result += QueenValueEg - PawnValueEg;
186   return strongSide == pos.side_to_move() ? result : -result;
187 }
188 template&lt;&gt;
189 Value Endgame&lt;KQKR&gt;::operator()(const Position&amp; pos) const {
190   assert(verify_material(pos, strongSide, QueenValueMg, 0));
191   assert(verify_material(pos, weakSide, RookValueMg, 0));
192   Square winnerKSq = pos.king_square(strongSide);
193   Square loserKSq = pos.king_square(weakSide);
194   Value result =  QueenValueEg
195                 - RookValueEg
196                 + PushToEdges[loserKSq]
197                 + PushClose[square_distance(winnerKSq, loserKSq)];
198   return strongSide == pos.side_to_move() ? result : -result;
199 }
200 template&lt;&gt; Value Endgame&lt;KNNK&gt;::operator()(const Position&amp;) const { return VALUE_DRAW; }
201 template&lt;&gt;
202 ScaleFactor Endgame&lt;KBPsK&gt;::operator()(const Position&amp; pos) const {
203   assert(pos.non_pawn_material(strongSide) == BishopValueMg);
204   assert(pos.count&lt;PAWN&gt;(strongSide) &gt;= 1);
205   Bitboard pawns = pos.pieces(strongSide, PAWN);
206   File pawnFile = file_of(pos.list&lt;PAWN&gt;(strongSide)[0]);
207   if (    (pawnFile == FILE_A || pawnFile == FILE_H)
208       &amp;&amp; !(pawns &amp; ~file_bb(pawnFile)))
209   {
210       Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
211       Square queeningSq = relative_square(strongSide, make_square(pawnFile, RANK_8));
212       Square kingSq = pos.king_square(weakSide);
213       if (   opposite_colors(queeningSq, bishopSq)
214           &amp;&amp; square_distance(queeningSq, kingSq) &lt;= 1)
215           return SCALE_FACTOR_DRAW;
216   }
217   if (    (pawnFile == FILE_B || pawnFile == FILE_G)
218       &amp;&amp; !(pos.pieces(PAWN) &amp; ~file_bb(pawnFile))
219       &amp;&amp; pos.non_pawn_material(weakSide) == 0
220       &amp;&amp; pos.count&lt;PAWN&gt;(weakSide) &gt;= 1)
221   {
222       Square weakPawnSq = backmost_sq(weakSide, pos.pieces(weakSide, PAWN));
223       Square strongKingSq = pos.king_square(strongSide);
224       Square weakKingSq = pos.king_square(weakSide);
225       Square bishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
226       if (   relative_rank(strongSide, weakPawnSq) == RANK_7
227           &amp;&amp; (pos.pieces(strongSide, PAWN) &amp; (weakPawnSq + pawn_push(weakSide)))
228           &amp;&amp; (opposite_colors(bishopSq, weakPawnSq) || pos.count&lt;PAWN&gt;(strongSide) == 1))
229       {
230           int strongKingDist = square_distance(weakPawnSq, strongKingSq);
231           int weakKingDist = square_distance(weakPawnSq, weakKingSq);
232           if (   relative_rank(strongSide, weakKingSq) &gt;= RANK_7
233               &amp;&amp; weakKingDist &lt;= 2
234               &amp;&amp; weakKingDist &lt;= strongKingDist)
235               return SCALE_FACTOR_DRAW;
236       }
237   }
238   return SCALE_FACTOR_NONE;
239 }
240 template&lt;&gt;
241 ScaleFactor Endgame&lt;KQKRPs&gt;::operator()(const Position&amp; pos) const {
242   assert(verify_material(pos, strongSide, QueenValueMg, 0));
243   assert(pos.count&lt;ROOK&gt;(weakSide) == 1);
244   assert(pos.count&lt;PAWN&gt;(weakSide) &gt;= 1);
245   Square kingSq = pos.king_square(weakSide);
246   Square rsq = pos.list&lt;ROOK&gt;(weakSide)[0];
247   if (    relative_rank(weakSide, kingSq) &lt;= RANK_2
248       &amp;&amp;  relative_rank(weakSide, pos.king_square(strongSide)) &gt;= RANK_4
249       &amp;&amp;  relative_rank(weakSide, rsq) == RANK_3
250       &amp;&amp; (  pos.pieces(weakSide, PAWN)
251           &amp; pos.attacks_from&lt;KING&gt;(kingSq)
252           &amp; pos.attacks_from&lt;PAWN&gt;(rsq, strongSide)))
253           return SCALE_FACTOR_DRAW;
254   return SCALE_FACTOR_NONE;
255 }
256 template&lt;&gt;
257 ScaleFactor Endgame&lt;KRPKR&gt;::operator()(const Position&amp; pos) const {
258   assert(verify_material(pos, strongSide, RookValueMg, 1));
259   assert(verify_material(pos, weakSide,   RookValueMg, 0));
260   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
261   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
262   Square wrsq = normalize(pos, strongSide, pos.list&lt;ROOK&gt;(strongSide)[0]);
263   Square wpsq = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
264   Square brsq = normalize(pos, strongSide, pos.list&lt;ROOK&gt;(weakSide)[0]);
265   File f = file_of(wpsq);
266   Rank r = rank_of(wpsq);
267   Square queeningSq = make_square(f, RANK_8);
268   int tempo = (pos.side_to_move() == strongSide);
269   if (   r &lt;= RANK_5
270       &amp;&amp; square_distance(bksq, queeningSq) &lt;= 1
271       &amp;&amp; wksq &lt;= SQ_H5
272       &amp;&amp; (rank_of(brsq) == RANK_6 || (r &lt;= RANK_3 &amp;&amp; rank_of(wrsq) != RANK_6)))
273       return SCALE_FACTOR_DRAW;
274   if (   r == RANK_6
275       &amp;&amp; square_distance(bksq, queeningSq) &lt;= 1
276       &amp;&amp; rank_of(wksq) + tempo &lt;= RANK_6
277       &amp;&amp; (rank_of(brsq) == RANK_1 || (!tempo &amp;&amp; abs(file_of(brsq) - f) &gt;= 3)))
278       return SCALE_FACTOR_DRAW;
279   if (   r &gt;= RANK_6
280       &amp;&amp; bksq == queeningSq
281       &amp;&amp; rank_of(brsq) == RANK_1
282       &amp;&amp; (!tempo || square_distance(wksq, wpsq) &gt;= 2))
283       return SCALE_FACTOR_DRAW;
284   if (   wpsq == SQ_A7
285       &amp;&amp; wrsq == SQ_A8
286       &amp;&amp; (bksq == SQ_H7 || bksq == SQ_G7)
287       &amp;&amp; file_of(brsq) == FILE_A
288       &amp;&amp; (rank_of(brsq) &lt;= RANK_3 || file_of(wksq) &gt;= FILE_D || rank_of(wksq) &lt;= RANK_5))
289       return SCALE_FACTOR_DRAW;
290   if (   r &lt;= RANK_5
291       &amp;&amp; bksq == wpsq + DELTA_N
292       &amp;&amp; square_distance(wksq, wpsq) - tempo &gt;= 2
293       &amp;&amp; square_distance(wksq, brsq) - tempo &gt;= 2)
294       return SCALE_FACTOR_DRAW;
295   if (   r == RANK_7
296       &amp;&amp; f != FILE_A
297       &amp;&amp; file_of(wrsq) == f
298       &amp;&amp; wrsq != queeningSq
299       &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, queeningSq) - 2 + tempo)
300       &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, wrsq) + tempo))
301       return ScaleFactor(SCALE_FACTOR_MAX - 2 * square_distance(wksq, queeningSq));
302   if (   f != FILE_A
303       &amp;&amp; file_of(wrsq) == f
304       &amp;&amp; wrsq &lt; wpsq
305       &amp;&amp; (square_distance(wksq, queeningSq) &lt; square_distance(bksq, queeningSq) - 2 + tempo)
306       &amp;&amp; (square_distance(wksq, wpsq + DELTA_N) &lt; square_distance(bksq, wpsq + DELTA_N) - 2 + tempo)
307       &amp;&amp; (  square_distance(bksq, wrsq) + tempo &gt;= 3
308           || (    square_distance(wksq, queeningSq) &lt; square_distance(bksq, wrsq) + tempo
309               &amp;&amp; (square_distance(wksq, wpsq + DELTA_N) &lt; square_distance(bksq, wrsq) + tempo))))
310       return ScaleFactor(  SCALE_FACTOR_MAX
311                          - 8 * square_distance(wpsq, queeningSq)
312                          - 2 * square_distance(wksq, queeningSq));
313   if (r &lt;= RANK_4 &amp;&amp; bksq &gt; wpsq)
314   {
315       if (file_of(bksq) == file_of(wpsq))
316           return ScaleFactor(10);
317       if (   abs(file_of(bksq) - file_of(wpsq)) == 1
318           &amp;&amp; square_distance(wksq, bksq) &gt; 2)
319           return ScaleFactor(24 - 2 * square_distance(wksq, bksq));
320   }
321   return SCALE_FACTOR_NONE;
322 }
323 template&lt;&gt;
324 ScaleFactor Endgame&lt;KRPKB&gt;::operator()(const Position&amp; pos) const {
325   assert(verify_material(pos, strongSide, RookValueMg, 1));
326   assert(verify_material(pos, weakSide, BishopValueMg, 0));
327   if (pos.pieces(PAWN) &amp; (FileABB | FileHBB))
328   {
329       Square ksq = pos.king_square(weakSide);
330       Square bsq = pos.list&lt;BISHOP&gt;(weakSide)[0];
331       Square psq = pos.list&lt;PAWN&gt;(strongSide)[0];
332       Rank rk = relative_rank(strongSide, psq);
333       Square push = pawn_push(strongSide);
334       if (rk == RANK_5 &amp;&amp; !opposite_colors(bsq, psq))
335       {
336           int d = square_distance(psq + 3 * push, ksq);
337           if (d &lt;= 2 &amp;&amp; !(d == 0 &amp;&amp; ksq == pos.king_square(strongSide) + 2 * push))
338               return ScaleFactor(24);
339           else
340               return ScaleFactor(48);
341       }
342       if (   rk == RANK_6
343           &amp;&amp; square_distance(psq + 2 * push, ksq) &lt;= 1
344           &amp;&amp; (PseudoAttacks[BISHOP][bsq] &amp; (psq + push))
345           &amp;&amp; file_distance(bsq, psq) &gt;= 2)
346           return ScaleFactor(8);
347   }
348   return SCALE_FACTOR_NONE;
349 }
350 template&lt;&gt;
351 ScaleFactor Endgame&lt;KRPPKRP&gt;::operator()(const Position&amp; pos) const {
352   assert(verify_material(pos, strongSide, RookValueMg, 2));
353   assert(verify_material(pos, weakSide,   RookValueMg, 1));
354   Square wpsq1 = pos.list&lt;PAWN&gt;(strongSide)[0];
355   Square wpsq2 = pos.list&lt;PAWN&gt;(strongSide)[1];
356   Square bksq = pos.king_square(weakSide);
357   if (pos.pawn_passed(strongSide, wpsq1) || pos.pawn_passed(strongSide, wpsq2))
358       return SCALE_FACTOR_NONE;
359   Rank r = std::max(relative_rank(strongSide, wpsq1), relative_rank(strongSide, wpsq2));
360   if (   file_distance(bksq, wpsq1) &lt;= 1
361       &amp;&amp; file_distance(bksq, wpsq2) &lt;= 1
362       &amp;&amp; relative_rank(strongSide, bksq) &gt; r)
363   {
364       switch (r) {
365       case RANK_2: return ScaleFactor(10);
366       case RANK_3: return ScaleFactor(10);
367       case RANK_4: return ScaleFactor(15);
368       case RANK_5: return ScaleFactor(20);
369       case RANK_6: return ScaleFactor(40);
370       default: assert(false);
371       }
372   }
373   return SCALE_FACTOR_NONE;
374 }
375 template&lt;&gt;
376 ScaleFactor Endgame&lt;KPsK&gt;::operator()(const Position&amp; pos) const {
377   assert(pos.non_pawn_material(strongSide) == VALUE_ZERO);
378   assert(pos.count&lt;PAWN&gt;(strongSide) &gt;= 2);
379   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
380   Square ksq = pos.king_square(weakSide);
381   Bitboard pawns = pos.pieces(strongSide, PAWN);
382   Square psq = pos.list&lt;PAWN&gt;(strongSide)[0];
383   if (   !(pawns &amp; ~in_front_bb(weakSide, rank_of(ksq)))
384       &amp;&amp; !((pawns &amp; ~FileABB) &amp;&amp; (pawns &amp; ~FileHBB))
385       &amp;&amp; file_distance(ksq, psq) &lt;= 1)
386       return SCALE_FACTOR_DRAW;
387   return SCALE_FACTOR_NONE;
388 }
389 template&lt;&gt;
390 ScaleFactor Endgame&lt;KBPKB&gt;::operator()(const Position&amp; pos) const {
391   assert(verify_material(pos, strongSide, BishopValueMg, 1));
392   assert(verify_material(pos, weakSide,   BishopValueMg, 0));
393   Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
394   Square strongBishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
395   Square weakBishopSq = pos.list&lt;BISHOP&gt;(weakSide)[0];
396   Square weakKingSq = pos.king_square(weakSide);
397   if (   file_of(weakKingSq) == file_of(pawnSq)
398       &amp;&amp; relative_rank(strongSide, pawnSq) &lt; relative_rank(strongSide, weakKingSq)
399       &amp;&amp; (   opposite_colors(weakKingSq, strongBishopSq)
400           || relative_rank(strongSide, weakKingSq) &lt;= RANK_6))
401       return SCALE_FACTOR_DRAW;
402   if (opposite_colors(strongBishopSq, weakBishopSq))
403   {
404       if (relative_rank(strongSide, pawnSq) &lt;= RANK_5)
405           return SCALE_FACTOR_DRAW;
406       else
407       {
408           Bitboard path = forward_bb(strongSide, pawnSq);
409           if (path &amp; pos.pieces(weakSide, KING))
410               return SCALE_FACTOR_DRAW;
411           if (  (pos.attacks_from&lt;BISHOP&gt;(weakBishopSq) &amp; path)
412               &amp;&amp; square_distance(weakBishopSq, pawnSq) &gt;= 3)
413               return SCALE_FACTOR_DRAW;
414       }
415   }
416   return SCALE_FACTOR_NONE;
417 }
418 template&lt;&gt;
419 ScaleFactor Endgame&lt;KBPPKB&gt;::operator()(const Position&amp; pos) const {
420   assert(verify_material(pos, strongSide, BishopValueMg, 2));
421   assert(verify_material(pos, weakSide,   BishopValueMg, 0));
422   Square wbsq = pos.list&lt;BISHOP&gt;(strongSide)[0];
423   Square bbsq = pos.list&lt;BISHOP&gt;(weakSide)[0];
424   if (!opposite_colors(wbsq, bbsq))
425       return SCALE_FACTOR_NONE;
426   Square ksq = pos.king_square(weakSide);
427   Square psq1 = pos.list&lt;PAWN&gt;(strongSide)[0];
428   Square psq2 = pos.list&lt;PAWN&gt;(strongSide)[1];
429   Rank r1 = rank_of(psq1);
430   Rank r2 = rank_of(psq2);
431   Square blockSq1, blockSq2;
432   if (relative_rank(strongSide, psq1) &gt; relative_rank(strongSide, psq2))
433   {
434       blockSq1 = psq1 + pawn_push(strongSide);
435       blockSq2 = make_square(file_of(psq2), rank_of(psq1));
436   }
437   else
438   {
439       blockSq1 = psq2 + pawn_push(strongSide);
440       blockSq2 = make_square(file_of(psq1), rank_of(psq2));
441   }
442   switch (file_distance(psq1, psq2))
443   {
444   case 0:
445     if (   file_of(ksq) == file_of(blockSq1)
446         &amp;&amp; relative_rank(strongSide, ksq) &gt;= relative_rank(strongSide, blockSq1)
447         &amp;&amp; opposite_colors(ksq, wbsq))
448         return SCALE_FACTOR_DRAW;
449     else
450         return SCALE_FACTOR_NONE;
451   case 1:
452     if (   ksq == blockSq1
453         &amp;&amp; opposite_colors(ksq, wbsq)
454         &amp;&amp; (   bbsq == blockSq2
455             || (pos.attacks_from&lt;BISHOP&gt;(blockSq2) &amp; pos.pieces(weakSide, BISHOP))
456             || abs(r1 - r2) &gt;= 2))
457         return SCALE_FACTOR_DRAW;
458     else if (   ksq == blockSq2
459              &amp;&amp; opposite_colors(ksq, wbsq)
460              &amp;&amp; (   bbsq == blockSq1
461                  || (pos.attacks_from&lt;BISHOP&gt;(blockSq1) &amp; pos.pieces(weakSide, BISHOP))))
462         return SCALE_FACTOR_DRAW;
463     else
464         return SCALE_FACTOR_NONE;
465   default:
466     return SCALE_FACTOR_NONE;
467   }
468 }
469 template&lt;&gt;
470 ScaleFactor Endgame&lt;KBPKN&gt;::operator()(const Position&amp; pos) const {
471   assert(verify_material(pos, strongSide, BishopValueMg, 1));
472   assert(verify_material(pos, weakSide, KnightValueMg, 0));
473   Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
474   Square strongBishopSq = pos.list&lt;BISHOP&gt;(strongSide)[0];
475   Square weakKingSq = pos.king_square(weakSide);
476   if (   file_of(weakKingSq) == file_of(pawnSq)
477       &amp;&amp; relative_rank(strongSide, pawnSq) &lt; relative_rank(strongSide, weakKingSq)
478       &amp;&amp; (   opposite_colors(weakKingSq, strongBishopSq)
479           || relative_rank(strongSide, weakKingSq) &lt;= RANK_6))
480       return SCALE_FACTOR_DRAW;
481   return SCALE_FACTOR_NONE;
482 }
483 template&lt;&gt;
484 ScaleFactor Endgame&lt;KNPK&gt;::operator()(const Position&amp; pos) const {
485   assert(verify_material(pos, strongSide, KnightValueMg, 1));
486   assert(verify_material(pos, weakSide, VALUE_ZERO, 0));
487   Square pawnSq     = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
488   Square weakKingSq = normalize(pos, strongSide, pos.king_square(weakSide));
489   if (pawnSq == SQ_A7 &amp;&amp; square_distance(SQ_A8, weakKingSq) &lt;= 1)
490       return SCALE_FACTOR_DRAW;
491   return SCALE_FACTOR_NONE;
492 }
493 template&lt;&gt;
494 ScaleFactor Endgame&lt;KNPKB&gt;::operator()(const Position&amp; pos) const {
495   Square pawnSq = pos.list&lt;PAWN&gt;(strongSide)[0];
496   Square bishopSq = pos.list&lt;BISHOP&gt;(weakSide)[0];
497   Square weakKingSq = pos.king_square(weakSide);
498   if (forward_bb(strongSide, pawnSq) &amp; pos.attacks_from&lt;BISHOP&gt;(bishopSq))
499       return ScaleFactor(square_distance(weakKingSq, pawnSq));
500   return SCALE_FACTOR_NONE;
501 }
502 template&lt;&gt;
503 ScaleFactor Endgame&lt;KPKP&gt;::operator()(const Position&amp; pos) const {
504   assert(verify_material(pos, strongSide, VALUE_ZERO, 1));
505   assert(verify_material(pos, weakSide,   VALUE_ZERO, 1));
506   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
507   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
508   Square psq  = normalize(pos, strongSide, pos.list&lt;PAWN&gt;(strongSide)[0]);
509   Color us = strongSide == pos.side_to_move() ? WHITE : BLACK;
510   if (rank_of(psq) &gt;= RANK_5 &amp;&amp; file_of(psq) != FILE_A)
511       return SCALE_FACTOR_NONE;
512   return Bitbases::probe_kpk(wksq, psq, bksq, us) ? SCALE_FACTOR_NONE : SCALE_FACTOR_DRAW;
513 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
