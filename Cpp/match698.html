<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for apefooter.cpp & flacpicture.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for apefooter.cpp & flacpicture.cpp
      </h3>
      <h1 align="center">
        15.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>apefooter.cpp (18.562874%)<TH>flacpicture.cpp (13.839286%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match698-0.html#0',2,'match698-1.html#0',3)" NAME="0">(72-92)<TD><A HREF="javascript:ZweiFrames('match698-0.html#0',2,'match698-1.html#0',3)" NAME="0">(51-67)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match698-0.html#1',2,'match698-1.html#1',3)" NAME="1">(107-117)<TD><A HREF="javascript:ZweiFrames('match698-0.html#1',2,'match698-1.html#1',3)" NAME="1">(146-156)</A><TD ALIGN=center><FONT COLOR="#d20000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>apefooter.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/***************************************************************************
    copyright            : (C) 2004 by Allan Sandfeld Jensen
                           (C) 2002 - 2008 by Scott Wheeler (id3v2header.cpp)
    email                : kde@carewolf.org
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;iostream&gt;
#include &lt;bitset&gt;

#include &lt;tstring.h&gt;
#include &lt;tdebug.h&gt;

#include &quot;apefooter.h&quot;

using namespace TagLib;
using namespace APE;

class APE::Footer::FooterPrivate
{
public:
  FooterPrivate() :
    version(0),
    footerPresent(true),
    headerPresent(false),
    isHeader(false),
    itemCount(0),
    tagSize(0) {}

  unsigned int version;

  bool footerPresent;
  bool headerPresent;

  bool isHeader;

  unsigned int itemCount;
  unsigned int tagSize;
};

////////////////////////////////////////////////////////////////////////////////
// static members
////////////////////////////////////////////////////////////////////////////////

unsigned int APE::Footer::size()
{
  return 32;
}

<A NAME="0"></A>ByteVector APE::Footer::fileIdentifier()
{
  return ByteVector(&quot;APETAGEX&quot;);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match698-1.html#0',3,'match698-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

////////////////////////////////////////////////////////////////////////////////
// public members
////////////////////////////////////////////////////////////////////////////////

APE::Footer::Footer() :
  d(new FooterPrivate())
{
}

APE::Footer::Footer(const ByteVector &amp;data) :
  d(new FooterPrivate())
{
  parse(data);
}

APE::Footer::~Footer()
{
  delete d;
}</B></FONT>

unsigned int APE::Footer::version() const
{
  return d-&gt;version;
}

bool APE::Footer::headerPresent() const
{
  return d-&gt;headerPresent;
}

<A NAME="1"></A>bool APE::Footer::footerPresent() const
{
  return d-&gt;footerPresent;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match698-1.html#1',3,'match698-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

bool APE::Footer::isHeader() const
{
  return d-&gt;isHeader;
}

void APE::Footer::setHeaderPresent(bool b) const
{
  d-&gt;headerPresent = b;
}</B></FONT>

unsigned int APE::Footer::itemCount() const
{
  return d-&gt;itemCount;
}

void APE::Footer::setItemCount(unsigned int s)
{
  d-&gt;itemCount = s;
}

unsigned int APE::Footer::tagSize() const
{
  return d-&gt;tagSize;
}

unsigned int APE::Footer::completeTagSize() const
{
  if(d-&gt;headerPresent)
    return d-&gt;tagSize + size();
  return d-&gt;tagSize;
}

void APE::Footer::setTagSize(unsigned int s)
{
  d-&gt;tagSize = s;
}

void APE::Footer::setData(const ByteVector &amp;data)
{
  parse(data);
}

ByteVector APE::Footer::renderFooter() const
{
  return render(false);
}

ByteVector APE::Footer::renderHeader() const
{
  if(!d-&gt;headerPresent)
    return ByteVector();
  return render(true);
}

////////////////////////////////////////////////////////////////////////////////
// protected members
////////////////////////////////////////////////////////////////////////////////

void APE::Footer::parse(const ByteVector &amp;data)
{
  if(data.size() &lt; size())
    return;

  // The first eight bytes, data[0..7], are the File Identifier, &quot;APETAGEX&quot;.

  // Read the version number

  d-&gt;version = data.toUInt(8, false);

  // Read the tag size

  d-&gt;tagSize = data.toUInt(12, false);

  // Read the item count

  d-&gt;itemCount = data.toUInt(16, false);

  // Read the flags

  std::bitset&lt;32&gt; flags(TAGLIB_CONSTRUCT_BITSET(data.toUInt(20, false)));

  d-&gt;headerPresent = flags[31];
  d-&gt;footerPresent = !flags[30];
  d-&gt;isHeader = flags[29];

}

ByteVector APE::Footer::render(bool isHeader) const
{
  ByteVector v;

  // add the file identifier -- &quot;APETAGEX&quot;

  v.append(fileIdentifier());

  // add the version number -- we always render a 2.000 tag regardless of what
  // the tag originally was.

  v.append(ByteVector::fromUInt(2000, false));

  // add the tag size

  v.append(ByteVector::fromUInt(d-&gt;tagSize, false));

  // add the item count

  v.append(ByteVector::fromUInt(d-&gt;itemCount, false));

  // render and add the flags

  std::bitset&lt;32&gt; flags;

  flags[31] = d-&gt;headerPresent;
  flags[30] = false; // footer is always present
  flags[29] = isHeader;

  v.append(ByteVector::fromUInt(flags.to_ulong(), false));

  // add the reserved 64bit

  v.append(ByteVector::fromLongLong(0));

  return v;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>flacpicture.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/**************************************************************************
    copyright            : (C) 2010 by Lukáš Lalinský
    email                : lalinsky@gmail.com
 **************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;taglib.h&gt;
#include &lt;tdebug.h&gt;
#include &quot;flacpicture.h&quot;

using namespace TagLib;

class FLAC::Picture::PicturePrivate
{
public:
  PicturePrivate() :
    type(FLAC::Picture::Other),
    width(0),
    height(0),
    colorDepth(0),
    numColors(0)
    {}

  Type type;
  String mimeType;
  String description;
  int width;
  int height;
<A NAME="0"></A>  int colorDepth;
  int numColors;
  ByteVector data;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match698-0.html#0',2,'match698-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>};

FLAC::Picture::Picture() :
  d(new PicturePrivate())
{
}

FLAC::Picture::Picture(const ByteVector &amp;data) :
  d(new PicturePrivate())
{
  parse(data);
}

FLAC::Picture::~Picture()
{
  delete d;
}</B></FONT>

int FLAC::Picture::code() const
{
  return FLAC::MetadataBlock::Picture;
}

bool FLAC::Picture::parse(const ByteVector &amp;data)
{
  if(data.size() &lt; 32) {
    debug(&quot;A picture block must contain at least 5 bytes.&quot;);
    return false;
  }

  unsigned int pos = 0;
  d-&gt;type = FLAC::Picture::Type(data.toUInt(pos));
  pos += 4;
  unsigned int mimeTypeLength = data.toUInt(pos);
  pos += 4;
  if(pos + mimeTypeLength + 24 &gt; data.size()) {
    debug(&quot;Invalid picture block.&quot;);
    return false;
  }
  d-&gt;mimeType = String(data.mid(pos, mimeTypeLength), String::UTF8);
  pos += mimeTypeLength;
  unsigned int descriptionLength = data.toUInt(pos);
  pos += 4;
  if(pos + descriptionLength + 20 &gt; data.size()) {
    debug(&quot;Invalid picture block.&quot;);
    return false;
  }
  d-&gt;description = String(data.mid(pos, descriptionLength), String::UTF8);
  pos += descriptionLength;
  d-&gt;width = data.toUInt(pos);
  pos += 4;
  d-&gt;height = data.toUInt(pos);
  pos += 4;
  d-&gt;colorDepth = data.toUInt(pos);
  pos += 4;
  d-&gt;numColors = data.toUInt(pos);
  pos += 4;
  unsigned int dataLength = data.toUInt(pos);
  pos += 4;
  if(pos + dataLength &gt; data.size()) {
    debug(&quot;Invalid picture block.&quot;);
    return false;
  }
  d-&gt;data = data.mid(pos, dataLength);

  return true;
}

ByteVector FLAC::Picture::render() const
{
  ByteVector result;
  result.append(ByteVector::fromUInt(d-&gt;type));
  ByteVector mimeTypeData = d-&gt;mimeType.data(String::UTF8);
  result.append(ByteVector::fromUInt(mimeTypeData.size()));
  result.append(mimeTypeData);
  ByteVector descriptionData = d-&gt;description.data(String::UTF8);
  result.append(ByteVector::fromUInt(descriptionData.size()));
  result.append(descriptionData);
  result.append(ByteVector::fromUInt(d-&gt;width));
  result.append(ByteVector::fromUInt(d-&gt;height));
  result.append(ByteVector::fromUInt(d-&gt;colorDepth));
  result.append(ByteVector::fromUInt(d-&gt;numColors));
  result.append(ByteVector::fromUInt(d-&gt;data.size()));
  result.append(d-&gt;data);
  return result;
}

FLAC::Picture::Type FLAC::Picture::type() const
{
  return d-&gt;type;
}

<A NAME="1"></A>void FLAC::Picture::setType(FLAC::Picture::Type type)
{
  d-&gt;type = type;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match698-0.html#1',2,'match698-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

String FLAC::Picture::mimeType() const
{
  return d-&gt;mimeType;
}

void FLAC::Picture::setMimeType(const String &amp;mimeType)
{
  d-&gt;mimeType = mimeType;
}</B></FONT>

String FLAC::Picture::description() const
{
  return d-&gt;description;
}

void FLAC::Picture::setDescription(const String &amp;description)
{
  d-&gt;description = description;
}

int FLAC::Picture::width() const
{
  return d-&gt;width;
}

void FLAC::Picture::setWidth(int width)
{
  d-&gt;width = width;
}

int FLAC::Picture::height() const
{
  return d-&gt;height;
}

void FLAC::Picture::setHeight(int height)
{
  d-&gt;height = height;
}

int FLAC::Picture::colorDepth() const
{
  return d-&gt;colorDepth;
}

void FLAC::Picture::setColorDepth(int colorDepth)
{
  d-&gt;colorDepth = colorDepth;
}

int FLAC::Picture::numColors() const
{
  return d-&gt;numColors;
}

void FLAC::Picture::setNumColors(int numColors)
{
  d-&gt;numColors = numColors;
}

ByteVector FLAC::Picture::data() const
{
  return d-&gt;data;
}

void FLAC::Picture::setData(const ByteVector &amp;data)
{
  d-&gt;data = data;
}

</PRE>
</div>
  </div>
</body>
</html>
