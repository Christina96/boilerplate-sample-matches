
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal.h</h3>
            <pre><code>1  #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
2  #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
3  #include "gtest/internal/gtest-port.h"
4  #if GTEST_OS_LINUX
5  # include <stdlib.h>
6  # include <sys/types.h>
7  # include <sys/wait.h>
8  # include <unistd.h>
9  #endif  
10  #if GTEST_HAS_EXCEPTIONS
11  # include <stdexcept>
12  #endif
13  #include <ctype.h>
14  #include <float.h>
15  #include <string.h>
16  #include <iomanip>
17  #include <limits>
18  #include <set>
19  #include "gtest/gtest-message.h"
20  #include "gtest/internal/gtest-string.h"
21  #include "gtest/internal/gtest-filepath.h"
22  #include "gtest/internal/gtest-type-util.h"
23  #define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)
24  #define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar
25  class ProtocolMessage;
26  namespace proto2 { class Message; }
27  namespace testing {
28  class AssertionResult;                 
29  class Message;                         
30  class Test;                            
31  class TestInfo;                        
32  class TestPartResult;                  
33  class UnitTest;                        
34  template <typename T>
35  ::std::string PrintToString(const T& value);
36  namespace internal {
37  struct TraceInfo;                      
38  class ScopedTrace;                     
39  class TestInfoImpl;                    
40  class UnitTestImpl;                    
41  GTEST_API_ extern int g_init_gtest_count;
42  GTEST_API_ extern const char kStackTraceMarker[];
43  char IsNullLiteralHelper(Secret* p);
44  char (&IsNullLiteralHelper(...))[2];  
45  #ifdef GTEST_ELLIPSIS_NEEDS_POD_
46  # define GTEST_IS_NULL_LITERAL_(x) false
47  #else
48  # define GTEST_IS_NULL_LITERAL_(x) \
49      (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)
50  #endif  
51  GTEST_API_ std::string AppendUserMessage(
52      const std::string& gtest_msg, const Message& user_msg);
53  #if GTEST_HAS_EXCEPTIONS
54  class GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {
55   public:
56    explicit GoogleTestFailureException(const TestPartResult& failure);
57  };
58  #endif  
59  class GTEST_API_ ScopedTrace {
60   public:
61    ScopedTrace(const char* file, int line, const Message& message);
62    ~ScopedTrace();
63   private:
64    GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);
65  } GTEST_ATTRIBUTE_UNUSED_;  
66  GTEST_API_ AssertionResult EqFailure(const char* expected_expression,
67                                       const char* actual_expression,
68                                       const std::string& expected_value,
69                                       const std::string& actual_value,
70                                       bool ignoring_case);
71  GTEST_API_ std::string GetBoolAssertionFailureMessage(
72      const AssertionResult& assertion_result,
73      const char* expression_text,
74      const char* actual_predicate_value,
75      const char* expected_predicate_value);
76  template <typename RawType>
77  class FloatingPoint {
78   public:
79    typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;
80    static const size_t kBitCount = 8*sizeof(RawType);
81    static const size_t kFractionBitCount =
82      std::numeric_limits<RawType>::digits - 1;
83    static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;
84    static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);
85    static const Bits kFractionBitMask =
86      ~static_cast<Bits>(0) >> (kExponentBitCount + 1);
87    static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);
88    static const size_t kMaxUlps = 4;
89    explicit FloatingPoint(const RawType& x) { u_.value_ = x; }
90    static RawType ReinterpretBits(const Bits bits) {
91      FloatingPoint fp(0);
92      fp.u_.bits_ = bits;
93      return fp.u_.value_;
94    }
95    static RawType Infinity() {
96      return ReinterpretBits(kExponentBitMask);
97    }
98    static RawType Max();
99    const Bits &bits() const { return u_.bits_; }
100    Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }
101    Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }
102    Bits sign_bit() const { return kSignBitMask & u_.bits_; }
103    bool is_nan() const {
104      return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);
105    }
106    bool AlmostEquals(const FloatingPoint& rhs) const {
107      if (is_nan() || rhs.is_nan()) return false;
108      return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)
109          <= kMaxUlps;
110    }
111   private:
112    union FloatingPointUnion {
113      RawType value_;  
114      Bits bits_;      
115    };
116    static Bits SignAndMagnitudeToBiased(const Bits &sam) {
117      if (kSignBitMask & sam) {
118        return ~sam + 1;
119      } else {
120        return kSignBitMask | sam;
121      }
122    }
123    static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,
124                                                       const Bits &sam2) {
125      const Bits biased1 = SignAndMagnitudeToBiased(sam1);
126      const Bits biased2 = SignAndMagnitudeToBiased(sam2);
127      return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);
128    }
129    FloatingPointUnion u_;
130  };
131  template <>
132  inline float FloatingPoint<float>::Max() { return FLT_MAX; }
133  template <>
134  inline double FloatingPoint<double>::Max() { return DBL_MAX; }
135  typedef FloatingPoint<float> Float;
136  typedef FloatingPoint<double> Double;
137  typedef const void* TypeId;
138  template <typename T>
139  class TypeIdHelper {
140   public:
141    static bool dummy_;
142  };
143  template <typename T>
144  bool TypeIdHelper<T>::dummy_ = false;
145  template <typename T>
146  TypeId GetTypeId() {
147    return &(TypeIdHelper<T>::dummy_);
148  }
149  GTEST_API_ TypeId GetTestTypeId();
150  class TestFactoryBase {
151   public:
152    virtual ~TestFactoryBase() {}
153    virtual Test* CreateTest() = 0;
154   protected:
155    TestFactoryBase() {}
156   private:
157    GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);
158  };
159  template <class TestClass>
160  class TestFactoryImpl : public TestFactoryBase {
161   public:
162    virtual Test* CreateTest() { return new TestClass; }
163  };
164  #if GTEST_OS_WINDOWS
165  GTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,
166                                              long hr);  
167  GTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,
168                                              long hr);  
169  #endif  
170  typedef void (*SetUpTestCaseFunc)();
171  typedef void (*TearDownTestCaseFunc)();
172  GTEST_API_ TestInfo* MakeAndRegisterTestInfo(
173      const char* test_case_name,
174      const char* name,
175      const char* type_param,
176      const char* value_param,
177      TypeId fixture_class_id,
178      SetUpTestCaseFunc set_up_tc,
179      TearDownTestCaseFunc tear_down_tc,
180      TestFactoryBase* factory);
181  GTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);
182  #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
183  class GTEST_API_ TypedTestCasePState {
184   public:
185    TypedTestCasePState() : registered_(false) {}
186    bool AddTestName(const char* file, int line, const char* case_name,
187                     const char* test_name) {
188      if (registered_) {
189        fprintf(stderr, "%s Test %s must be defined before "
190                "REGISTER_TYPED_TEST_CASE_P(%s, ...).\n",
191                FormatFileLocation(file, line).c_str(), test_name, case_name);
192        fflush(stderr);
193        posix::Abort();
194      }
195      defined_test_names_.insert(test_name);
196      return true;
197    }
198    const char* VerifyRegisteredTestNames(
199        const char* file, int line, const char* registered_tests);
200   private:
201    bool registered_;
202    ::std::set<const char*> defined_test_names_;
203  };
204  inline const char* SkipComma(const char* str) {
205    const char* comma = strchr(str, ',');
206    if (comma == NULL) {
207      return NULL;
208    }
209    while (IsSpace(*(++comma))) {}
210    return comma;
211  }
212  inline std::string GetPrefixUntilComma(const char* str) {
213    const char* comma = strchr(str, ',');
214    return comma == NULL ? str : std::string(str, comma);
215  }
216  template <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>
217  class TypeParameterizedTest {
218   public:
219    static bool Register(const char* prefix, const char* case_name,
220                         const char* test_names, int index) {
221      typedef typename Types::Head Type;
222      typedef Fixture<Type> FixtureClass;
223      typedef typename GTEST_BIND_(TestSel, Type) TestClass;
224      MakeAndRegisterTestInfo(
225          (std::string(prefix) + (prefix[0] == '\0' ? "" : "/") + case_name + "/"
226           + StreamableToString(index)).c_str(),
227          GetPrefixUntilComma(test_names).c_str(),
228          GetTypeName<Type>().c_str(),
229          NULL,  
230          GetTypeId<FixtureClass>(),
231          TestClass::SetUpTestCase,
232          TestClass::TearDownTestCase,
233          new TestFactoryImpl<TestClass>);
234      return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>
235          ::Register(prefix, case_name, test_names, index + 1);
236    }
237  };
238  template <GTEST_TEMPLATE_ Fixture, class TestSel>
239  class TypeParameterizedTest<Fixture, TestSel, Types0> {
240   public:
241    static bool Register(const char* &bsol;*prefix*/, const char* &bsol;*case_name*/,
242                         const char* &bsol;*test_names*/, int &bsol;*index*/) {
243      return true;
244    }
245  };
246  template <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>
247  class TypeParameterizedTestCase {
248   public:
249    static bool Register(const char* prefix, const char* case_name,
250                         const char* test_names) {
251      typedef typename Tests::Head Head;
252      TypeParameterizedTest<Fixture, Head, Types>::Register(
253          prefix, case_name, test_names, 0);
254      return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>
255          ::Register(prefix, case_name, SkipComma(test_names));
256    }
257  };
258  template <GTEST_TEMPLATE_ Fixture, typename Types>
259  class TypeParameterizedTestCase<Fixture, Templates0, Types> {
260   public:
261    static bool Register(const char* &bsol;*prefix*/, const char* &bsol;*case_name*/,
262                         const char* &bsol;*test_names*/) {
263      return true;
264    }
265  };
266  #endif  
267  GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(
268      UnitTest* unit_test, int skip_count);
269  GTEST_API_ bool AlwaysTrue();
270  inline bool AlwaysFalse() { return !AlwaysTrue(); }
271  struct GTEST_API_ ConstCharPtr {
272    ConstCharPtr(const char* str) : value(str) {}
273    operator bool() const { return true; }
274    const char* value;
275  };
276  class GTEST_API_ Random {
277   public:
278    static const UInt32 kMaxRange = 1u << 31;
279    explicit Random(UInt32 seed) : state_(seed) {}
280    void Reseed(UInt32 seed) { state_ = seed; }
281    UInt32 Generate(UInt32 range);
282   private:
283    UInt32 state_;
284    GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);
285  };
286  template <typename T1, typename T2>
287  struct CompileAssertTypesEqual;
288  template <typename T>
289  struct CompileAssertTypesEqual<T, T> {
290  };
291  template <typename T>
292  struct RemoveReference { typedef T type; };  
293  template <typename T>
294  struct RemoveReference<T&> { typedef T type; };  
295  #define GTEST_REMOVE_REFERENCE_(T) \
296      typename ::testing::internal::RemoveReference<T>::type
297  template <typename T>
298  struct RemoveConst { typedef T type; };  
299  template <typename T>
300  struct RemoveConst<const T> { typedef T type; };  
301  template <typename T, size_t N>
302  struct RemoveConst<const T[N]> {
303    typedef typename RemoveConst<T>::type type[N];
304  };
305  #if defined(_MSC_VER) && _MSC_VER < 1400
306  template <typename T, size_t N>
307  struct RemoveConst<T[N]> {
308    typedef typename RemoveConst<T>::type type[N];
309  };
310  #endif
311  #define GTEST_REMOVE_CONST_(T) \
312      typename ::testing::internal::RemoveConst<T>::type
313  #define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \
314      GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))
315  template <typename T>
316  struct AddReference { typedef T& type; };  
317  template <typename T>
318  struct AddReference<T&> { typedef T& type; };  
319  #define GTEST_ADD_REFERENCE_(T) \
320      typename ::testing::internal::AddReference<T>::type
321  #define GTEST_REFERENCE_TO_CONST_(T) \
322      GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))
323  template <typename From, typename To>
324  class ImplicitlyConvertible {
325   private:
326    static From MakeFrom();
327    static char Helper(To);
328    static char (&Helper(...))[2];  
329   public:
330  #ifdef _MSC_VER
331  # pragma warning(push)          
332  # pragma warning(disable:4244)  
<span onclick='openModal()' class='match'>333    static const bool value =
334        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
335  # pragma warning(pop)           
</span>336  #elif defined(__BORLANDC__)
337    static const bool value = __is_convertible(From, To);
338  #else
339    static const bool value =
340        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
341  #endif  
342  };
343  template <typename From, typename To>
344  const bool ImplicitlyConvertible<From, To>::value;
345  template <typename T>
346  struct IsAProtocolMessage
347      : public bool_constant<
348    ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||
349    ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {
350  };
351  typedef int IsContainer;
352  template <class C>
353  IsContainer IsContainerTest(int &bsol;* dummy */,
354                              typename C::iterator* &bsol;* it */ = NULL,
355                              typename C::const_iterator* &bsol;* const_it */ = NULL) {
356    return 0;
357  }
358  typedef char IsNotContainer;
359  template <class C>
360  IsNotContainer IsContainerTest(long &bsol;* dummy */) { return '\0'; }
361  template<bool> struct EnableIf;
362  template<> struct EnableIf<true> { typedef void type; };  
363  template <typename T, typename U>
364  bool ArrayEq(const T* lhs, size_t size, const U* rhs);
365  template <typename T, typename U>
366  inline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }
367  template <typename T, typename U, size_t N>
368  inline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {
369    return internal::ArrayEq(lhs, N, rhs);
370  }
371  template <typename T, typename U>
372  bool ArrayEq(const T* lhs, size_t size, const U* rhs) {
373    for (size_t i = 0; i != size; i++) {
374      if (!internal::ArrayEq(lhs[i], rhs[i]))
375        return false;
376    }
377    return true;
378  }
379  template <typename Iter, typename Element>
380  Iter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {
381    for (Iter it = begin; it != end; ++it) {
382      if (internal::ArrayEq(*it, elem))
383        return it;
384    }
385    return end;
386  }
387  template <typename T, typename U>
388  void CopyArray(const T* from, size_t size, U* to);
389  template <typename T, typename U>
390  inline void CopyArray(const T& from, U* to) { *to = from; }
391  template <typename T, typename U, size_t N>
392  inline void CopyArray(const T(&from)[N], U(*to)[N]) {
393    internal::CopyArray(from, N, *to);
394  }
395  template <typename T, typename U>
396  void CopyArray(const T* from, size_t size, U* to) {
397    for (size_t i = 0; i != size; i++) {
398      internal::CopyArray(from[i], to + i);
399    }
400  }
401  enum RelationToSource {
402    kReference,  
403    kCopy        
404  };
405  template <typename Element>
406  class NativeArray {
407   public:
408    typedef Element value_type;
409    typedef Element* iterator;
410    typedef const Element* const_iterator;
411    NativeArray(const Element* array, size_t count, RelationToSource relation) {
412      Init(array, count, relation);
413    }
414    NativeArray(const NativeArray& rhs) {
415      Init(rhs.array_, rhs.size_, rhs.relation_to_source_);
416    }
417    ~NativeArray() {
418      static_cast<void>(StaticAssertTypeEqHelper<Element,
419          GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>());
420      if (relation_to_source_ == kCopy)
421        delete[] array_;
422    }
423    size_t size() const { return size_; }
424    const_iterator begin() const { return array_; }
425    const_iterator end() const { return array_ + size_; }
426    bool operator==(const NativeArray& rhs) const {
427      return size() == rhs.size() &&
428          ArrayEq(begin(), size(), rhs.begin());
429    }
430   private:
431    void Init(const Element* array, size_t a_size, RelationToSource relation) {
432      if (relation == kReference) {
433        array_ = array;
434      } else {
435        Element* const copy = new Element[a_size];
436        CopyArray(array, a_size, copy);
437        array_ = copy;
438      }
439      size_ = a_size;
440      relation_to_source_ = relation;
441    }
442    const Element* array_;
443    size_t size_;
444    RelationToSource relation_to_source_;
445    GTEST_DISALLOW_ASSIGN_(NativeArray);
446  };
447  }  
448  }  
449  #define GTEST_MESSAGE_AT_(file, line, message, result_type) \
450    ::testing::internal::AssertHelper(result_type, file, line, message) \
451      = ::testing::Message()
452  #define GTEST_MESSAGE_(message, result_type) \
453    GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)
454  #define GTEST_FATAL_FAILURE_(message) \
455    return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)
456  #define GTEST_NONFATAL_FAILURE_(message) \
457    GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)
458  #define GTEST_SUCCESS_(message) \
459    GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)
460  #define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \
461    if (::testing::internal::AlwaysTrue()) { statement; }
462  #define GTEST_TEST_THROW_(statement, expected_exception, fail) \
463    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
464    if (::testing::internal::ConstCharPtr gtest_msg = "") { \
465      bool gtest_caught_expected = false; \
466      try { \
467        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
468      } \
469      catch (expected_exception const&) { \
470        gtest_caught_expected = true; \
471      } \
472      catch (...) { \
473        gtest_msg.value = \
474            "Expected: " #statement " throws an exception of type " \
475            #expected_exception ".\n  Actual: it throws a different type."; \
476        goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
477      } \
478      if (!gtest_caught_expected) { \
479        gtest_msg.value = \
480            "Expected: " #statement " throws an exception of type " \
481            #expected_exception ".\n  Actual: it throws nothing."; \
482        goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
483      } \
484    } else \
485      GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \
486        fail(gtest_msg.value)
487  #define GTEST_TEST_NO_THROW_(statement, fail) \
488    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
489    if (::testing::internal::AlwaysTrue()) { \
490      try { \
491        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
492      } \
493      catch (...) { \
494        goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \
495      } \
496    } else \
497      GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \
498        fail("Expected: " #statement " doesn't throw an exception.\n" \
499             "  Actual: it throws.")
500  #define GTEST_TEST_ANY_THROW_(statement, fail) \
501    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
502    if (::testing::internal::AlwaysTrue()) { \
503      bool gtest_caught_any = false; \
504      try { \
505        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
506      } \
507      catch (...) { \
508        gtest_caught_any = true; \
509      } \
510      if (!gtest_caught_any) { \
511        goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \
512      } \
513    } else \
514      GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \
515        fail("Expected: " #statement " throws an exception.\n" \
516             "  Actual: it doesn't.")
517  #define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \
518    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
519    if (const ::testing::AssertionResult gtest_ar_ = \
520        ::testing::AssertionResult(expression)) \
521      ; \
522    else \
523      fail(::testing::internal::GetBoolAssertionFailureMessage(\
524          gtest_ar_, text, #actual, #expected).c_str())
525  #define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \
526    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
527    if (::testing::internal::AlwaysTrue()) { \
528      ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \
529      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
530      if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \
531        goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \
532      } \
533    } else \
534      GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \
535        fail("Expected: " #statement " doesn't generate new fatal " \
536             "failures in the current thread.\n" \
537             "  Actual: it does.")
538  #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \
539    test_case_name##_##test_name##_Test
540  #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\
541  class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\
542   public:\
543    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\
544   private:\
545    virtual void TestBody();\
546    static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\
547    GTEST_DISALLOW_COPY_AND_ASSIGN_(\
548        GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\
549  };\
550  \
551  ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\
552    ::test_info_ =\
553      ::testing::internal::MakeAndRegisterTestInfo(\
554          #test_case_name, #test_name, NULL, NULL, \
555          (parent_id), \
556          parent_class::SetUpTestCase, \
557          parent_class::TearDownTestCase, \
558          new ::testing::internal::TestFactoryImpl<\
559              GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\
560  void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()
561  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal.h</h3>
            <pre><code>1  #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
2  #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
3  #include "gtest/internal/gtest-port.h"
4  #if GTEST_OS_LINUX
5  # include <stdlib.h>
6  # include <sys/types.h>
7  # include <sys/wait.h>
8  # include <unistd.h>
9  #endif  
10  #if GTEST_HAS_EXCEPTIONS
11  # include <stdexcept>
12  #endif
13  #include <ctype.h>
14  #include <float.h>
15  #include <string.h>
16  #include <iomanip>
17  #include <limits>
18  #include <set>
19  #include "gtest/gtest-message.h"
20  #include "gtest/internal/gtest-string.h"
21  #include "gtest/internal/gtest-filepath.h"
22  #include "gtest/internal/gtest-type-util.h"
23  #define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)
24  #define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar
25  class ProtocolMessage;
26  namespace proto2 { class Message; }
27  namespace testing {
28  class AssertionResult;                 
29  class Message;                         
30  class Test;                            
31  class TestInfo;                        
32  class TestPartResult;                  
33  class UnitTest;                        
34  template <typename T>
35  ::std::string PrintToString(const T& value);
36  namespace internal {
37  struct TraceInfo;                      
38  class ScopedTrace;                     
39  class TestInfoImpl;                    
40  class UnitTestImpl;                    
41  GTEST_API_ extern int g_init_gtest_count;
42  GTEST_API_ extern const char kStackTraceMarker[];
43  char IsNullLiteralHelper(Secret* p);
44  char (&IsNullLiteralHelper(...))[2];  
45  #ifdef GTEST_ELLIPSIS_NEEDS_POD_
46  # define GTEST_IS_NULL_LITERAL_(x) false
47  #else
48  # define GTEST_IS_NULL_LITERAL_(x) \
49      (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)
50  #endif  
51  GTEST_API_ std::string AppendUserMessage(
52      const std::string& gtest_msg, const Message& user_msg);
53  #if GTEST_HAS_EXCEPTIONS
54  class GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {
55   public:
56    explicit GoogleTestFailureException(const TestPartResult& failure);
57  };
58  #endif  
59  class GTEST_API_ ScopedTrace {
60   public:
61    ScopedTrace(const char* file, int line, const Message& message);
62    ~ScopedTrace();
63   private:
64    GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);
65  } GTEST_ATTRIBUTE_UNUSED_;  
66  GTEST_API_ AssertionResult EqFailure(const char* expected_expression,
67                                       const char* actual_expression,
68                                       const std::string& expected_value,
69                                       const std::string& actual_value,
70                                       bool ignoring_case);
71  GTEST_API_ std::string GetBoolAssertionFailureMessage(
72      const AssertionResult& assertion_result,
73      const char* expression_text,
74      const char* actual_predicate_value,
75      const char* expected_predicate_value);
76  template <typename RawType>
77  class FloatingPoint {
78   public:
79    typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;
80    static const size_t kBitCount = 8*sizeof(RawType);
81    static const size_t kFractionBitCount =
82      std::numeric_limits<RawType>::digits - 1;
83    static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;
84    static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);
85    static const Bits kFractionBitMask =
86      ~static_cast<Bits>(0) >> (kExponentBitCount + 1);
87    static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);
88    static const size_t kMaxUlps = 4;
89    explicit FloatingPoint(const RawType& x) { u_.value_ = x; }
90    static RawType ReinterpretBits(const Bits bits) {
91      FloatingPoint fp(0);
92      fp.u_.bits_ = bits;
93      return fp.u_.value_;
94    }
95    static RawType Infinity() {
96      return ReinterpretBits(kExponentBitMask);
97    }
98    static RawType Max();
99    const Bits &bits() const { return u_.bits_; }
100    Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }
101    Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }
102    Bits sign_bit() const { return kSignBitMask & u_.bits_; }
103    bool is_nan() const {
104      return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);
105    }
106    bool AlmostEquals(const FloatingPoint& rhs) const {
107      if (is_nan() || rhs.is_nan()) return false;
108      return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)
109          <= kMaxUlps;
110    }
111   private:
112    union FloatingPointUnion {
113      RawType value_;  
114      Bits bits_;      
115    };
116    static Bits SignAndMagnitudeToBiased(const Bits &sam) {
117      if (kSignBitMask & sam) {
118        return ~sam + 1;
119      } else {
120        return kSignBitMask | sam;
121      }
122    }
123    static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,
124                                                       const Bits &sam2) {
125      const Bits biased1 = SignAndMagnitudeToBiased(sam1);
126      const Bits biased2 = SignAndMagnitudeToBiased(sam2);
127      return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);
128    }
129    FloatingPointUnion u_;
130  };
131  template <>
132  inline float FloatingPoint<float>::Max() { return FLT_MAX; }
133  template <>
134  inline double FloatingPoint<double>::Max() { return DBL_MAX; }
135  typedef FloatingPoint<float> Float;
136  typedef FloatingPoint<double> Double;
137  typedef const void* TypeId;
138  template <typename T>
139  class TypeIdHelper {
140   public:
141    static bool dummy_;
142  };
143  template <typename T>
144  bool TypeIdHelper<T>::dummy_ = false;
145  template <typename T>
146  TypeId GetTypeId() {
147    return &(TypeIdHelper<T>::dummy_);
148  }
149  GTEST_API_ TypeId GetTestTypeId();
150  class TestFactoryBase {
151   public:
152    virtual ~TestFactoryBase() {}
153    virtual Test* CreateTest() = 0;
154   protected:
155    TestFactoryBase() {}
156   private:
157    GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);
158  };
159  template <class TestClass>
160  class TestFactoryImpl : public TestFactoryBase {
161   public:
162    virtual Test* CreateTest() { return new TestClass; }
163  };
164  #if GTEST_OS_WINDOWS
165  GTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,
166                                              long hr);  
167  GTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,
168                                              long hr);  
169  #endif  
170  typedef void (*SetUpTestCaseFunc)();
171  typedef void (*TearDownTestCaseFunc)();
172  GTEST_API_ TestInfo* MakeAndRegisterTestInfo(
173      const char* test_case_name,
174      const char* name,
175      const char* type_param,
176      const char* value_param,
177      TypeId fixture_class_id,
178      SetUpTestCaseFunc set_up_tc,
179      TearDownTestCaseFunc tear_down_tc,
180      TestFactoryBase* factory);
181  GTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);
182  #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
183  class GTEST_API_ TypedTestCasePState {
184   public:
185    TypedTestCasePState() : registered_(false) {}
186    bool AddTestName(const char* file, int line, const char* case_name,
187                     const char* test_name) {
188      if (registered_) {
189        fprintf(stderr, "%s Test %s must be defined before "
190                "REGISTER_TYPED_TEST_CASE_P(%s, ...).\n",
191                FormatFileLocation(file, line).c_str(), test_name, case_name);
192        fflush(stderr);
193        posix::Abort();
194      }
195      defined_test_names_.insert(test_name);
196      return true;
197    }
198    const char* VerifyRegisteredTestNames(
199        const char* file, int line, const char* registered_tests);
200   private:
201    bool registered_;
202    ::std::set<const char*> defined_test_names_;
203  };
204  inline const char* SkipComma(const char* str) {
205    const char* comma = strchr(str, ',');
206    if (comma == NULL) {
207      return NULL;
208    }
209    while (IsSpace(*(++comma))) {}
210    return comma;
211  }
212  inline std::string GetPrefixUntilComma(const char* str) {
213    const char* comma = strchr(str, ',');
214    return comma == NULL ? str : std::string(str, comma);
215  }
216  template <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>
217  class TypeParameterizedTest {
218   public:
219    static bool Register(const char* prefix, const char* case_name,
220                         const char* test_names, int index) {
221      typedef typename Types::Head Type;
222      typedef Fixture<Type> FixtureClass;
223      typedef typename GTEST_BIND_(TestSel, Type) TestClass;
224      MakeAndRegisterTestInfo(
225          (std::string(prefix) + (prefix[0] == '\0' ? "" : "/") + case_name + "/"
226           + StreamableToString(index)).c_str(),
227          GetPrefixUntilComma(test_names).c_str(),
228          GetTypeName<Type>().c_str(),
229          NULL,  
230          GetTypeId<FixtureClass>(),
231          TestClass::SetUpTestCase,
232          TestClass::TearDownTestCase,
233          new TestFactoryImpl<TestClass>);
234      return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>
235          ::Register(prefix, case_name, test_names, index + 1);
236    }
237  };
238  template <GTEST_TEMPLATE_ Fixture, class TestSel>
239  class TypeParameterizedTest<Fixture, TestSel, Types0> {
240   public:
241    static bool Register(const char* &bsol;*prefix*/, const char* &bsol;*case_name*/,
242                         const char* &bsol;*test_names*/, int &bsol;*index*/) {
243      return true;
244    }
245  };
246  template <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>
247  class TypeParameterizedTestCase {
248   public:
249    static bool Register(const char* prefix, const char* case_name,
250                         const char* test_names) {
251      typedef typename Tests::Head Head;
252      TypeParameterizedTest<Fixture, Head, Types>::Register(
253          prefix, case_name, test_names, 0);
254      return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>
255          ::Register(prefix, case_name, SkipComma(test_names));
256    }
257  };
258  template <GTEST_TEMPLATE_ Fixture, typename Types>
259  class TypeParameterizedTestCase<Fixture, Templates0, Types> {
260   public:
261    static bool Register(const char* &bsol;*prefix*/, const char* &bsol;*case_name*/,
262                         const char* &bsol;*test_names*/) {
263      return true;
264    }
265  };
266  #endif  
267  GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(
268      UnitTest* unit_test, int skip_count);
269  GTEST_API_ bool AlwaysTrue();
270  inline bool AlwaysFalse() { return !AlwaysTrue(); }
271  struct GTEST_API_ ConstCharPtr {
272    ConstCharPtr(const char* str) : value(str) {}
273    operator bool() const { return true; }
274    const char* value;
275  };
276  class GTEST_API_ Random {
277   public:
278    static const UInt32 kMaxRange = 1u << 31;
279    explicit Random(UInt32 seed) : state_(seed) {}
280    void Reseed(UInt32 seed) { state_ = seed; }
281    UInt32 Generate(UInt32 range);
282   private:
283    UInt32 state_;
284    GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);
285  };
286  template <typename T1, typename T2>
287  struct CompileAssertTypesEqual;
288  template <typename T>
289  struct CompileAssertTypesEqual<T, T> {
290  };
291  template <typename T>
292  struct RemoveReference { typedef T type; };  
293  template <typename T>
294  struct RemoveReference<T&> { typedef T type; };  
295  #define GTEST_REMOVE_REFERENCE_(T) \
296      typename ::testing::internal::RemoveReference<T>::type
297  template <typename T>
298  struct RemoveConst { typedef T type; };  
299  template <typename T>
300  struct RemoveConst<const T> { typedef T type; };  
301  template <typename T, size_t N>
302  struct RemoveConst<const T[N]> {
303    typedef typename RemoveConst<T>::type type[N];
304  };
305  #if defined(_MSC_VER) && _MSC_VER < 1400
306  template <typename T, size_t N>
307  struct RemoveConst<T[N]> {
308    typedef typename RemoveConst<T>::type type[N];
309  };
310  #endif
311  #define GTEST_REMOVE_CONST_(T) \
312      typename ::testing::internal::RemoveConst<T>::type
313  #define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \
314      GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))
315  template <typename T>
316  struct AddReference { typedef T& type; };  
317  template <typename T>
318  struct AddReference<T&> { typedef T& type; };  
319  #define GTEST_ADD_REFERENCE_(T) \
320      typename ::testing::internal::AddReference<T>::type
321  #define GTEST_REFERENCE_TO_CONST_(T) \
322      GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))
323  template <typename From, typename To>
324  class ImplicitlyConvertible {
325   private:
326    static From MakeFrom();
327    static char Helper(To);
328    static char (&Helper(...))[2];  
329   public:
330  #ifdef _MSC_VER
331  # pragma warning(push)          
332  # pragma warning(disable:4244)  
333    static const bool value =
334        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
335  # pragma warning(pop)           
336  #elif defined(__BORLANDC__)
337    static const bool value = __is_convertible(From, To);
338  #else
<span onclick='openModal()' class='match'>339    static const bool value =
340        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
341  #endif  
</span>342  };
343  template <typename From, typename To>
344  const bool ImplicitlyConvertible<From, To>::value;
345  template <typename T>
346  struct IsAProtocolMessage
347      : public bool_constant<
348    ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||
349    ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {
350  };
351  typedef int IsContainer;
352  template <class C>
353  IsContainer IsContainerTest(int &bsol;* dummy */,
354                              typename C::iterator* &bsol;* it */ = NULL,
355                              typename C::const_iterator* &bsol;* const_it */ = NULL) {
356    return 0;
357  }
358  typedef char IsNotContainer;
359  template <class C>
360  IsNotContainer IsContainerTest(long &bsol;* dummy */) { return '\0'; }
361  template<bool> struct EnableIf;
362  template<> struct EnableIf<true> { typedef void type; };  
363  template <typename T, typename U>
364  bool ArrayEq(const T* lhs, size_t size, const U* rhs);
365  template <typename T, typename U>
366  inline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }
367  template <typename T, typename U, size_t N>
368  inline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {
369    return internal::ArrayEq(lhs, N, rhs);
370  }
371  template <typename T, typename U>
372  bool ArrayEq(const T* lhs, size_t size, const U* rhs) {
373    for (size_t i = 0; i != size; i++) {
374      if (!internal::ArrayEq(lhs[i], rhs[i]))
375        return false;
376    }
377    return true;
378  }
379  template <typename Iter, typename Element>
380  Iter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {
381    for (Iter it = begin; it != end; ++it) {
382      if (internal::ArrayEq(*it, elem))
383        return it;
384    }
385    return end;
386  }
387  template <typename T, typename U>
388  void CopyArray(const T* from, size_t size, U* to);
389  template <typename T, typename U>
390  inline void CopyArray(const T& from, U* to) { *to = from; }
391  template <typename T, typename U, size_t N>
392  inline void CopyArray(const T(&from)[N], U(*to)[N]) {
393    internal::CopyArray(from, N, *to);
394  }
395  template <typename T, typename U>
396  void CopyArray(const T* from, size_t size, U* to) {
397    for (size_t i = 0; i != size; i++) {
398      internal::CopyArray(from[i], to + i);
399    }
400  }
401  enum RelationToSource {
402    kReference,  
403    kCopy        
404  };
405  template <typename Element>
406  class NativeArray {
407   public:
408    typedef Element value_type;
409    typedef Element* iterator;
410    typedef const Element* const_iterator;
411    NativeArray(const Element* array, size_t count, RelationToSource relation) {
412      Init(array, count, relation);
413    }
414    NativeArray(const NativeArray& rhs) {
415      Init(rhs.array_, rhs.size_, rhs.relation_to_source_);
416    }
417    ~NativeArray() {
418      static_cast<void>(StaticAssertTypeEqHelper<Element,
419          GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>());
420      if (relation_to_source_ == kCopy)
421        delete[] array_;
422    }
423    size_t size() const { return size_; }
424    const_iterator begin() const { return array_; }
425    const_iterator end() const { return array_ + size_; }
426    bool operator==(const NativeArray& rhs) const {
427      return size() == rhs.size() &&
428          ArrayEq(begin(), size(), rhs.begin());
429    }
430   private:
431    void Init(const Element* array, size_t a_size, RelationToSource relation) {
432      if (relation == kReference) {
433        array_ = array;
434      } else {
435        Element* const copy = new Element[a_size];
436        CopyArray(array, a_size, copy);
437        array_ = copy;
438      }
439      size_ = a_size;
440      relation_to_source_ = relation;
441    }
442    const Element* array_;
443    size_t size_;
444    RelationToSource relation_to_source_;
445    GTEST_DISALLOW_ASSIGN_(NativeArray);
446  };
447  }  
448  }  
449  #define GTEST_MESSAGE_AT_(file, line, message, result_type) \
450    ::testing::internal::AssertHelper(result_type, file, line, message) \
451      = ::testing::Message()
452  #define GTEST_MESSAGE_(message, result_type) \
453    GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)
454  #define GTEST_FATAL_FAILURE_(message) \
455    return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)
456  #define GTEST_NONFATAL_FAILURE_(message) \
457    GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)
458  #define GTEST_SUCCESS_(message) \
459    GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)
460  #define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \
461    if (::testing::internal::AlwaysTrue()) { statement; }
462  #define GTEST_TEST_THROW_(statement, expected_exception, fail) \
463    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
464    if (::testing::internal::ConstCharPtr gtest_msg = "") { \
465      bool gtest_caught_expected = false; \
466      try { \
467        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
468      } \
469      catch (expected_exception const&) { \
470        gtest_caught_expected = true; \
471      } \
472      catch (...) { \
473        gtest_msg.value = \
474            "Expected: " #statement " throws an exception of type " \
475            #expected_exception ".\n  Actual: it throws a different type."; \
476        goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
477      } \
478      if (!gtest_caught_expected) { \
479        gtest_msg.value = \
480            "Expected: " #statement " throws an exception of type " \
481            #expected_exception ".\n  Actual: it throws nothing."; \
482        goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
483      } \
484    } else \
485      GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \
486        fail(gtest_msg.value)
487  #define GTEST_TEST_NO_THROW_(statement, fail) \
488    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
489    if (::testing::internal::AlwaysTrue()) { \
490      try { \
491        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
492      } \
493      catch (...) { \
494        goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \
495      } \
496    } else \
497      GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \
498        fail("Expected: " #statement " doesn't throw an exception.\n" \
499             "  Actual: it throws.")
500  #define GTEST_TEST_ANY_THROW_(statement, fail) \
501    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
502    if (::testing::internal::AlwaysTrue()) { \
503      bool gtest_caught_any = false; \
504      try { \
505        GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
506      } \
507      catch (...) { \
508        gtest_caught_any = true; \
509      } \
510      if (!gtest_caught_any) { \
511        goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \
512      } \
513    } else \
514      GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \
515        fail("Expected: " #statement " throws an exception.\n" \
516             "  Actual: it doesn't.")
517  #define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \
518    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
519    if (const ::testing::AssertionResult gtest_ar_ = \
520        ::testing::AssertionResult(expression)) \
521      ; \
522    else \
523      fail(::testing::internal::GetBoolAssertionFailureMessage(\
524          gtest_ar_, text, #actual, #expected).c_str())
525  #define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \
526    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
527    if (::testing::internal::AlwaysTrue()) { \
528      ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \
529      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
530      if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \
531        goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \
532      } \
533    } else \
534      GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \
535        fail("Expected: " #statement " doesn't generate new fatal " \
536             "failures in the current thread.\n" \
537             "  Actual: it does.")
538  #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \
539    test_case_name##_##test_name##_Test
540  #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\
541  class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\
542   public:\
543    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\
544   private:\
545    virtual void TestBody();\
546    static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\
547    GTEST_DISALLOW_COPY_AND_ASSIGN_(\
548        GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\
549  };\
550  \
551  ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\
552    ::test_info_ =\
553      ::testing::internal::MakeAndRegisterTestInfo(\
554          #test_case_name, #test_name, NULL, NULL, \
555          (parent_id), \
556          parent_class::SetUpTestCase, \
557          parent_class::TearDownTestCase, \
558          new ::testing::internal::TestFactoryImpl<\
559              GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\
560  void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()
561  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal.h</div>
                </div>
                <div class="column column_space"><pre><code>333    static const bool value =
334        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
335  # pragma warning(pop)           
</pre></code></div>
                <div class="column column_space"><pre><code>339    static const bool value =
340        sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
341  #endif  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    