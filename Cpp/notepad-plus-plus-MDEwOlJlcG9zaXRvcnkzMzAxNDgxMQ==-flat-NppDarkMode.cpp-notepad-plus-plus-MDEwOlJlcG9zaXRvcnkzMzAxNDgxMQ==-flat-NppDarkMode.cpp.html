
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 143, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppDarkMode.cpp</h3>
            <pre><code>1  #include "NppDarkMode.h"
2  #include "DarkMode/DarkMode.h"
3  #include "DarkMode/UAHMenuBar.h"
4  #include <dwmapi.h>
5  #include <uxtheme.h>
6  #include <vssym32.h>
7  #include "Parameters.h"
8  #include "resource.h"
9  #include <shlwapi.h>
10  #include <array>
11  #ifdef __GNUC__
12  #include <cmath>
13  #define WINAPI_LAMBDA WINAPI
14  #ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
15  #define DWMWA_USE_IMMERSIVE_DARK_MODE 20
16  #endif
17  #else
18  #define WINAPI_LAMBDA
19  #endif
20  constexpr COLORREF HEXRGB(DWORD rrggbb) {
21  	return
22  		((rrggbb & 0xFF0000) >> 16) |
23  		((rrggbb & 0x00FF00)) |
24  		((rrggbb & 0x0000FF) << 16);
25  }
26  namespace NppDarkMode
27  {
28  	struct Brushes
29  	{
30  		HBRUSH background = nullptr;
31  		HBRUSH softerBackground = nullptr;
32  		HBRUSH hotBackground = nullptr;
33  		HBRUSH pureBackground = nullptr;
34  		HBRUSH errorBackground = nullptr;
35  		HBRUSH edgeBrush = nullptr;
36  		HBRUSH hotEdgeBrush = nullptr;
37  		HBRUSH disabledEdgeBrush = nullptr;
38  		Brushes(const Colors& colors)
39  			: background(::CreateSolidBrush(colors.background))
40  			, softerBackground(::CreateSolidBrush(colors.softerBackground))
41  			, hotBackground(::CreateSolidBrush(colors.hotBackground))
42  			, pureBackground(::CreateSolidBrush(colors.pureBackground))
43  			, errorBackground(::CreateSolidBrush(colors.errorBackground))
44  			, edgeBrush(::CreateSolidBrush(colors.edge))
45  			, hotEdgeBrush(::CreateSolidBrush(colors.hotEdge))
46  			, disabledEdgeBrush(::CreateSolidBrush(colors.disabledEdge))
47  		{}
48  		~Brushes()
49  		{
50  			::DeleteObject(background);			background = nullptr;
51  			::DeleteObject(softerBackground);	softerBackground = nullptr;
52  			::DeleteObject(hotBackground);		hotBackground = nullptr;
53  			::DeleteObject(pureBackground);		pureBackground = nullptr;
54  			::DeleteObject(errorBackground);	errorBackground = nullptr;
55  			::DeleteObject(edgeBrush);			edgeBrush = nullptr;
56  			::DeleteObject(hotEdgeBrush);		hotEdgeBrush = nullptr;
57  			::DeleteObject(disabledEdgeBrush);	disabledEdgeBrush = nullptr;
58  		}
59  		void change(const Colors& colors)
60  		{
61  			::DeleteObject(background);
62  			::DeleteObject(softerBackground);
63  			::DeleteObject(hotBackground);
64  			::DeleteObject(pureBackground);
65  			::DeleteObject(errorBackground);
66  			::DeleteObject(edgeBrush);
67  			::DeleteObject(hotEdgeBrush);
68  			::DeleteObject(disabledEdgeBrush);
69  			background = ::CreateSolidBrush(colors.background);
70  			softerBackground = ::CreateSolidBrush(colors.softerBackground);
71  			hotBackground = ::CreateSolidBrush(colors.hotBackground);
72  			pureBackground = ::CreateSolidBrush(colors.pureBackground);
73  			errorBackground = ::CreateSolidBrush(colors.errorBackground);
74  			edgeBrush = ::CreateSolidBrush(colors.edge);
75  			hotEdgeBrush = ::CreateSolidBrush(colors.hotEdge);
76  			disabledEdgeBrush = ::CreateSolidBrush(colors.disabledEdge);
77  		}
78  	};
79  	struct Pens
80  	{
81  		HPEN darkerTextPen = nullptr;
82  		HPEN edgePen = nullptr;
83  		HPEN hotEdgePen = nullptr;
84  		HPEN disabledEdgePen = nullptr;
85  		Pens(const Colors& colors)
86  			: darkerTextPen(::CreatePen(PS_SOLID, 1, colors.darkerText))
87  			, edgePen(::CreatePen(PS_SOLID, 1, colors.edge))
88  			, hotEdgePen(::CreatePen(PS_SOLID, 1, colors.hotEdge))
89  			, disabledEdgePen(::CreatePen(PS_SOLID, 1, colors.disabledEdge))
90  		{}
91  		~Pens()
92  		{
93  			::DeleteObject(darkerTextPen);		darkerTextPen = nullptr;
94  			::DeleteObject(edgePen);			edgePen = nullptr;
95  			::DeleteObject(hotEdgePen);			hotEdgePen = nullptr;
96  			::DeleteObject(disabledEdgePen);	disabledEdgePen = nullptr;
97  		}
98  		void change(const Colors& colors)
99  		{
100  			::DeleteObject(darkerTextPen);
101  			::DeleteObject(edgePen);
102  			::DeleteObject(hotEdgePen);
103  			::DeleteObject(disabledEdgePen);
104  			darkerTextPen = ::CreatePen(PS_SOLID, 1, colors.darkerText);
105  			edgePen = ::CreatePen(PS_SOLID, 1, colors.edge);
106  			hotEdgePen = ::CreatePen(PS_SOLID, 1, colors.hotEdge);
107  			disabledEdgePen = ::CreatePen(PS_SOLID, 1, colors.disabledEdge);
108  		}
109  	};
110  	static const Colors darkColors{
111  		HEXRGB(0x202020),	
112  		HEXRGB(0x404040),	
113  		HEXRGB(0x404040),	
114  		HEXRGB(0x202020),	
115  		HEXRGB(0xB00000),	
116  		HEXRGB(0xE0E0E0),	
117  		HEXRGB(0xC0C0C0),	
118  		HEXRGB(0x808080),	
119  		HEXRGB(0xFFFF00),	
120  		HEXRGB(0x646464),	
121  		HEXRGB(0x9B9B9B),	
122  		HEXRGB(0x484848)	
123  	};
124  	static const Colors darkRedColors{
125  		HEXRGB(0x302020),	
126  		HEXRGB(0x504040),	
127  		HEXRGB(0x504040),	
128  		HEXRGB(0x302020),	
129  		HEXRGB(0xC00000),	
130  		HEXRGB(0xE0E0E0),	
131  		HEXRGB(0xC0C0C0),	
132  		HEXRGB(0x808080),	
133  		HEXRGB(0xFFFF00),	
134  		HEXRGB(0x908080),	
135  		HEXRGB(0xBBABAB),	
136  		HEXRGB(0x584848)	
137  	};
138  	static const Colors darkGreenColors{
139  		HEXRGB(0x203020),	
140  		HEXRGB(0x405040),	
141  		HEXRGB(0x405040),	
142  		HEXRGB(0x203020),	
143  		HEXRGB(0xB01000),	
144  		HEXRGB(0xE0E0E0),	
145  		HEXRGB(0xC0C0C0),	
146  		HEXRGB(0x808080),	
147  		HEXRGB(0xFFFF00),	
148  		HEXRGB(0x809080),	
149  		HEXRGB(0xABBBAB),	
150  		HEXRGB(0x485848)	
151  	};
152  	static const Colors darkBlueColors{
153  		HEXRGB(0x202040),	
154  		HEXRGB(0x404060),	
155  		HEXRGB(0x404060),	
156  		HEXRGB(0x202040),	
157  		HEXRGB(0xB00020),	
158  		HEXRGB(0xE0E0E0),	
159  		HEXRGB(0xC0C0C0),	
160  		HEXRGB(0x808080),	
161  		HEXRGB(0xFFFF00),	
162  		HEXRGB(0x8080A0),	
163  		HEXRGB(0xABABCB),	
164  		HEXRGB(0x484868)	
165  	};
166  	static const Colors darkPurpleColors{
167  		HEXRGB(0x302040),	
168  		HEXRGB(0x504060),	
169  		HEXRGB(0x504060),	
170  		HEXRGB(0x302040),	
171  		HEXRGB(0xC00020),	
172  		HEXRGB(0xE0E0E0),	
173  		HEXRGB(0xC0C0C0),	
174  		HEXRGB(0x808080),	
175  		HEXRGB(0xFFFF00),	
176  		HEXRGB(0x9080A0),	
177  		HEXRGB(0xBBABCB),	
178  		HEXRGB(0x584868)	
179  	};
180  	static const Colors darkCyanColors{
181  		HEXRGB(0x203040),	
182  		HEXRGB(0x405060),	
183  		HEXRGB(0x405060),	
184  		HEXRGB(0x203040),	
185  		HEXRGB(0xB01020),	
186  		HEXRGB(0xE0E0E0),	
187  		HEXRGB(0xC0C0C0),	
188  		HEXRGB(0x808080),	
189  		HEXRGB(0xFFFF00),	
190  		HEXRGB(0x8090A0),	
191  		HEXRGB(0xBBBBCB),	
192  		HEXRGB(0x485868)	
193  	};
194  	static const Colors darkOliveColors{
195  		HEXRGB(0x303020),	
196  		HEXRGB(0x505040),	
197  		HEXRGB(0x505040),	
198  		HEXRGB(0x303020),	
199  		HEXRGB(0xC01000),	
200  		HEXRGB(0xE0E0E0),	
201  		HEXRGB(0xC0C0C0),	
202  		HEXRGB(0x808080),	
203  		HEXRGB(0xFFFF00),	
204  		HEXRGB(0x909080),	
205  		HEXRGB(0xBBBBAB),	
206  		HEXRGB(0x585848)	
207  	};
208  	Colors darkCustomizedColors{
209  		HEXRGB(0x202020),	
210  		HEXRGB(0x404040),	
211  		HEXRGB(0x404040),	
212  		HEXRGB(0x202020),	
213  		HEXRGB(0xB00000),	
214  		HEXRGB(0xE0E0E0),	
215  		HEXRGB(0xC0C0C0),	
216  		HEXRGB(0x808080),	
217  		HEXRGB(0xFFFF00),	
218  		HEXRGB(0x646464),	
219  		HEXRGB(0x9B9B9B),	
220  		HEXRGB(0x484848)	
221  	};
222  	ColorTone g_colorToneChoice = blackTone;
223  	void setDarkTone(ColorTone colorToneChoice)
224  	{
225  		g_colorToneChoice = colorToneChoice;
226  	}
227  	struct Theme
228  	{
229  		Colors _colors;
230  		Brushes _brushes;
231  		Pens _pens;
232  		Theme(const Colors& colors)
233  			: _colors(colors)
234  			, _brushes(colors)
235  			, _pens(colors)
236  		{}
237  		void change(const Colors& colors)
238  		{
239  			_colors = colors;
240  			_brushes.change(colors);
241  			_pens.change(colors);
242  		}
243  	};
244  	Theme tDefault(darkColors);
245  	Theme tR(darkRedColors);
246  	Theme tG(darkGreenColors);
247  	Theme tB(darkBlueColors);
248  	Theme tP(darkPurpleColors);
249  	Theme tC(darkCyanColors);
250  	Theme tO(darkOliveColors);
251  	Theme tCustom(darkCustomizedColors);
252  	Theme& getTheme()
253  	{
254  		switch (g_colorToneChoice)
255  		{
256  			case redTone:
257  				return tR;
258  			case greenTone:
259  				return tG;
260  			case blueTone:
261  				return tB;
262  			case purpleTone:
263  				return tP;
264  			case cyanTone:
265  				return tC;
266  			case oliveTone:
267  				return tO;
268  			case customizedTone:
269  				return tCustom;
270  			default:
271  				return tDefault;
272  		}
273  	}
274  	static Options _options;			
275  	static AdvancedOptions g_advOptions;
276  	Options configuredOptions()
277  	{
278  		NppGUI nppGui = NppParameters::getInstance().getNppGUI();
279  		Options opt;
280  		opt.enable = nppGui._darkmode._isEnabled;
281  		opt.enableMenubar = opt.enable;
282  		opt.enablePlugin = nppGui._darkmode._isEnabledPlugin;
283  		g_colorToneChoice = nppGui._darkmode._colorTone;
284  		tCustom.change(nppGui._darkmode._customColors);
285  		return opt;
286  	}
287  	static bool g_isAtLeastWindows10 = false;
288  	static bool g_isWine = false;
289  	void initDarkMode()
290  	{
291  		_options = configuredOptions();
292  		initExperimentalDarkMode();
293  		initAdvancedOptions();
294  		g_isAtLeastWindows10 = NppDarkMode::isWindows10();
295  		if (!g_isAtLeastWindows10)
296  		{
297  			g_advOptions._enableWindowsMode = false;
298  		}
299  		else if (NppDarkMode::isWindowsModeEnabled())
300  		{
301  			NppParameters& nppParam = NppParameters::getInstance();
302  			NppGUI& nppGUI = nppParam.getNppGUI();
303  			nppGUI._darkmode._isEnabled = NppDarkMode::isDarkModeReg() && !IsHighContrast();
304  			_options.enable = nppGUI._darkmode._isEnabled;
305  			_options.enableMenubar = _options.enable;
306  		}
307  		setDarkMode(_options.enable, true);
308  		using PWINEGETVERSION = const CHAR* (__cdecl *)(void);
309  		PWINEGETVERSION pWGV = nullptr;
310  		auto hNtdllModule = GetModuleHandle(L"ntdll.dll");
311  		if (hNtdllModule)
312  		{
313  			pWGV = reinterpret_cast<PWINEGETVERSION>(GetProcAddress(hNtdllModule, "wine_get_version"));
314  		}
315  		g_isWine = pWGV != nullptr;
316  	}
317  	void refreshDarkMode(HWND hwnd, bool forceRefresh)
318  	{
319  		bool supportedChanged = false;
320  		auto config = configuredOptions();
321  		if (_options.enable != config.enable)
322  		{
323  			supportedChanged = true;
324  			_options.enable = config.enable;
325  			setDarkMode(_options.enable, _options.enable);
326  		}
327  		if (_options.enableMenubar != config.enableMenubar)
328  		{
329  			supportedChanged = true;
330  			_options.enableMenubar = config.enableMenubar;
331  		}
332  		if (!supportedChanged && !forceRefresh)
333  		{
334  			return;
335  		}
336  		HWND hwndRoot = GetAncestor(hwnd, GA_ROOTOWNER);
337  		::SendMessage(hwndRoot, NPPM_INTERNAL_REFRESHDARKMODE, static_cast<WPARAM>(!forceRefresh), 0);
338  	}
339  	void initAdvancedOptions()
340  	{
341  		NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
342  		g_advOptions = nppGui._darkmode._advOptions;
343  	}
344  	bool isEnabled()
345  	{
346  		return _options.enable;
347  	}
348  	bool isEnabledForPlugins()
349  	{
350  		return _options.enablePlugin;
351  	}
352  	bool isDarkMenuEnabled()
353  	{
354  		return _options.enableMenubar;
355  	}
356  	bool isExperimentalActive()
357  	{
358  		return g_darkModeEnabled;
359  	}
360  	bool isExperimentalSupported()
361  	{
362  		return g_darkModeSupported;
363  	}
364  	bool isWindowsModeEnabled()
365  	{
366  		return g_advOptions._enableWindowsMode;
367  	}
368  	void setWindowsMode(bool enable)
369  	{
370  		g_advOptions._enableWindowsMode = enable;
371  	}
372  	void setThemeName(const generic_string& newThemeName)
373  	{
374  		if (NppDarkMode::isEnabled())
375  			g_advOptions._darkDefaults._xmlFileName = newThemeName;
376  		else
377  			g_advOptions._lightDefaults._xmlFileName = newThemeName;
378  	}
379  	generic_string getThemeName()
380  	{
381  		auto& theme = NppDarkMode::isEnabled() ? g_advOptions._darkDefaults._xmlFileName : g_advOptions._lightDefaults._xmlFileName;
382  		return (lstrcmp(theme.c_str(), L"stylers.xml") == 0) ? L"" : theme;
383  	}
384  	static bool g_isCustomToolIconUsed = NppParameters::getInstance().getCustomizedToolIcons() != nullptr;
385  	void setToolBarIconSet(int state2Set, bool useDark)
386  	{
387  		if (useDark)
388  			g_advOptions._darkDefaults._toolBarIconSet = state2Set;
389  		else
390  			g_advOptions._lightDefaults._toolBarIconSet = state2Set;
391  	}
392  	int getToolBarIconSet(bool useDark)
393  	{
394  		if (g_isCustomToolIconUsed)
395  		{
396  			return -1;
397  		}
398  		return useDark ? g_advOptions._darkDefaults._toolBarIconSet : g_advOptions._lightDefaults._toolBarIconSet;
399  	}
400  	void setTabIconSet(bool useAltIcons, bool useDark)
401  	{
402  		if (useDark)
403  			g_advOptions._darkDefaults._tabIconSet = useAltIcons ? 1 : 2;
404  		else	
405  			g_advOptions._lightDefaults._tabIconSet = useAltIcons ? 1 : 0;
406  	}
407  	int getTabIconSet(bool useDark)
408  	{
409  		return useDark ? g_advOptions._darkDefaults._tabIconSet : g_advOptions._lightDefaults._tabIconSet;
410  	}
411  	bool useTabTheme()
412  	{
413  		return NppDarkMode::isEnabled() ? g_advOptions._darkDefaults._tabUseTheme : g_advOptions._lightDefaults._tabUseTheme;
414  	}
415  	void setAdvancedOptions()
416  	{
417  		NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
418  		auto& advOpt = nppGui._darkmode._advOptions;
419  		advOpt = g_advOptions;
420  	}
421  	bool isWindows10()
422  	{
423  		return IsWindows10();
424  	}
425  	bool isWindows11()
426  	{
427  		return IsWindows11();
428  	}
429  	DWORD getWindowsBuildNumber()
430  	{
431  		return GetWindowsBuildNumber();
432  	}
433  	COLORREF invertLightness(COLORREF c)
434  	{
435  		WORD h = 0;
436  		WORD s = 0;
437  		WORD l = 0;
438  		ColorRGBToHLS(c, &h, &l, &s);
439  		l = 240 - l;
440  		COLORREF invert_c = ColorHLSToRGB(h, l, s);
441  		return invert_c;
442  	}
443  	COLORREF invertLightnessSofter(COLORREF c)
444  	{
445  		WORD h = 0;
446  		WORD s = 0;
447  		WORD l = 0;
448  		ColorRGBToHLS(c, &h, &l, &s);
449  		l = std::min<WORD>(240U - l, 211U);
450  		COLORREF invert_c = ColorHLSToRGB(h, l, s);
451  		return invert_c;
452  	}
453  	static TreeViewStyle g_treeViewStyle = TreeViewStyle::classic;
454  	static COLORREF g_treeViewBg = NppParameters::getInstance().getCurrentDefaultBgColor();
455  	static double g_lighnessTreeView = 50.0;
456  	double calculatePerceivedLighness(COLORREF c)
457  	{
458  		auto linearValue = [](double colorChannel) -> double
459  		{
460  			colorChannel /= 255.0;
461  			if (colorChannel <= 0.04045)
462  				return colorChannel / 12.92;
463  			return std::pow(((colorChannel + 0.055) / 1.055), 2.4);
464  		};
465  		double r = linearValue(static_cast<double>(GetRValue(c)));
466  		double g = linearValue(static_cast<double>(GetGValue(c)));
467  		double b = linearValue(static_cast<double>(GetBValue(c)));
468  		double luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
469  		double lighness = (luminance <= 216.0 / 24389.0) ? (luminance * 24389.0 / 27.0) : (std::pow(luminance, (1.0 / 3.0)) * 116.0 - 16.0);
470  		return lighness;
471  	}
472  	COLORREF getBackgroundColor()         { return getTheme()._colors.background; }
473  	COLORREF getSofterBackgroundColor()   { return getTheme()._colors.softerBackground; }
474  	COLORREF getHotBackgroundColor()      { return getTheme()._colors.hotBackground; }
475  	COLORREF getDarkerBackgroundColor()   { return getTheme()._colors.pureBackground; }
476  	COLORREF getErrorBackgroundColor()    { return getTheme()._colors.errorBackground; }
477  	COLORREF getTextColor()               { return getTheme()._colors.text; }
478  	COLORREF getDarkerTextColor()         { return getTheme()._colors.darkerText; }
479  	COLORREF getDisabledTextColor()       { return getTheme()._colors.disabledText; }
480  	COLORREF getLinkTextColor()           { return getTheme()._colors.linkText; }
481  	COLORREF getEdgeColor()               { return getTheme()._colors.edge; }
482  	COLORREF getHotEdgeColor()            { return getTheme()._colors.hotEdge; }
483  	COLORREF getDisabledEdgeColor()       { return getTheme()._colors.disabledEdge; }
484  	HBRUSH getBackgroundBrush()           { return getTheme()._brushes.background; }
485  	HBRUSH getSofterBackgroundBrush()     { return getTheme()._brushes.softerBackground; }
486  	HBRUSH getHotBackgroundBrush()        { return getTheme()._brushes.hotBackground; }
487  	HBRUSH getDarkerBackgroundBrush()     { return getTheme()._brushes.pureBackground; }
488  	HBRUSH getErrorBackgroundBrush()      { return getTheme()._brushes.errorBackground; }
489  	HBRUSH getEdgeBrush()                 { return getTheme()._brushes.edgeBrush; }
490  	HBRUSH getHotEdgeBrush()              { return getTheme()._brushes.hotEdgeBrush; }
491  	HBRUSH getDisabledEdgeBrush()         { return getTheme()._brushes.disabledEdgeBrush; }
492  	HPEN getDarkerTextPen()               { return getTheme()._pens.darkerTextPen; }
493  	HPEN getEdgePen()                     { return getTheme()._pens.edgePen; }
494  	HPEN getHotEdgePen()                  { return getTheme()._pens.hotEdgePen; }
495  	HPEN getDisabledEdgePen()             { return getTheme()._pens.disabledEdgePen; }
496  	void setBackgroundColor(COLORREF c)
497  	{
498  		Colors clrs = getTheme()._colors;
499  		clrs.background = c;
500  		getTheme().change(clrs);
501  	}
502  	void setSofterBackgroundColor(COLORREF c)
503  	{
504  		Colors clrs = getTheme()._colors;
505  		clrs.softerBackground = c;
506  		getTheme().change(clrs);
507  	}
508  	void setHotBackgroundColor(COLORREF c)
509  	{
510  		Colors clrs = getTheme()._colors;
511  		clrs.hotBackground = c;
512  		getTheme().change(clrs);
513  	}
514  	void setDarkerBackgroundColor(COLORREF c)
515  	{
516  		Colors clrs = getTheme()._colors;
517  		clrs.pureBackground = c;
518  		getTheme().change(clrs);
519  	}
520  	void setErrorBackgroundColor(COLORREF c)
521  	{
522  		Colors clrs = getTheme()._colors;
523  		clrs.errorBackground = c;
524  		getTheme().change(clrs);
525  	}
526  	void setTextColor(COLORREF c)
527  	{
528  		Colors clrs = getTheme()._colors;
529  		clrs.text = c;
530  		getTheme().change(clrs);
531  	}
532  	void setDarkerTextColor(COLORREF c)
533  	{
534  		Colors clrs = getTheme()._colors;
535  		clrs.darkerText = c;
536  		getTheme().change(clrs);
537  	}
538  	void setDisabledTextColor(COLORREF c)
539  	{
540  		Colors clrs = getTheme()._colors;
541  		clrs.disabledText = c;
542  		getTheme().change(clrs);
543  	}
544  	void setLinkTextColor(COLORREF c)
545  	{
546  		Colors clrs = getTheme()._colors;
547  		clrs.linkText = c;
548  		getTheme().change(clrs);
549  	}
550  	void setEdgeColor(COLORREF c)
551  	{
552  		Colors clrs = getTheme()._colors;
553  		clrs.edge = c;
554  		getTheme().change(clrs);
555  	}
556  	void setHotEdgeColor(COLORREF c)
557  	{
558  		Colors clrs = getTheme()._colors;
559  		clrs.hotEdge = c;
560  		getTheme().change(clrs);
561  	}
562  	void setDisabledEdgeColor(COLORREF c)
563  	{
564  		Colors clrs = getTheme()._colors;
565  		clrs.disabledEdge = c;
566  		getTheme().change(clrs);
567  	}
568  	Colors getDarkModeDefaultColors()
569  	{
570  		return darkColors;
571  	}
572  	void changeCustomTheme(const Colors& colors)
573  	{
574  		tCustom.change(colors);
575  	}
576  	void handleSettingChange(HWND hwnd, LPARAM lParam, bool isFromBtn)
577  	{
578  		UNREFERENCED_PARAMETER(hwnd);
579  		if (!isExperimentalSupported())
580  		{
581  			return;
582  		}
583  		if (IsColorSchemeChangeMessage(lParam) || isFromBtn)
584  		{
585  			g_darkModeEnabled = NppDarkMode::isDarkModeReg() && !IsHighContrast();
586  		}
587  	}
588  	bool isDarkModeReg()
589  	{
590  		DWORD data{};
591  		DWORD dwBufSize = sizeof(data);
592  		LPCTSTR lpSubKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
593  		LPCTSTR lpValue = L"AppsUseLightTheme";
594  		auto result = RegGetValue(HKEY_CURRENT_USER, lpSubKey, lpValue, RRF_RT_REG_DWORD, nullptr, &data, &dwBufSize);
595  		if (result != ERROR_SUCCESS)
596  		{
597  			return false;
598  		}
599  		return data == 0UL;
600  	}
601  	bool runUAHWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT* lr)
602  	{
603  		static HTHEME g_menuTheme = nullptr;
604  		UNREFERENCED_PARAMETER(wParam);
605  		switch (message)
606  		{
607  		case WM_UAHDRAWMENU:
608  		{
609  			UAHMENU* pUDM = (UAHMENU*)lParam;
610  			RECT rc{};
611  			{
612  				MENUBARINFO mbi{};
613  				mbi.cbSize = sizeof(MENUBARINFO);
614  				GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi);
615  				RECT rcWindow{};
616  				GetWindowRect(hWnd, &rcWindow);
617  				rc = mbi.rcBar;
618  				OffsetRect(&rc, -rcWindow.left, -rcWindow.top);
619  				rc.top -= 1;
620  			}
621  			FillRect(pUDM->hdc, &rc, NppDarkMode::getDarkerBackgroundBrush());
622  			*lr = 0;
623  			return true;
624  		}
625  		case WM_UAHDRAWMENUITEM:
626  		{
627  			UAHDRAWMENUITEM* pUDMI = (UAHDRAWMENUITEM*)lParam;
628  			wchar_t menuString[256] = { '\0' };
629  			MENUITEMINFO mii{};
630  			{
631  				mii.cbSize = sizeof(MENUITEMINFO);
632  				mii.fMask = MIIM_STRING;
633  				mii.dwTypeData = menuString;
634  				mii.cch = (sizeof(menuString) / 2) - 1;
635  				GetMenuItemInfo(pUDMI->um.hmenu, pUDMI->umi.iPosition, TRUE, &mii);
636  			}
637  			DWORD dwFlags = DT_CENTER | DT_SINGLELINE | DT_VCENTER;
638  			int iTextStateID = MPI_NORMAL;
639  			int iBackgroundStateID = MPI_NORMAL;
640  			{
641  				if ((pUDMI->dis.itemState & ODS_INACTIVE) | (pUDMI->dis.itemState & ODS_DEFAULT))
642  				{
643  					iTextStateID = MPI_NORMAL;
644  					iBackgroundStateID = MPI_NORMAL;
645  				}
646  				if (pUDMI->dis.itemState & ODS_HOTLIGHT)
647  				{
648  					iTextStateID = MPI_HOT;
649  					iBackgroundStateID = MPI_HOT;
650  				}
651  				if (pUDMI->dis.itemState & ODS_SELECTED)
652  				{
653  					iTextStateID = MPI_HOT;
654  					iBackgroundStateID = MPI_HOT;
655  				}
656  				if ((pUDMI->dis.itemState & ODS_GRAYED) || (pUDMI->dis.itemState & ODS_DISABLED))
657  				{
658  					iTextStateID = MPI_DISABLED;
659  					iBackgroundStateID = MPI_DISABLED;
660  				}
661  				if (pUDMI->dis.itemState & ODS_NOACCEL)
662  				{
663  					dwFlags |= DT_HIDEPREFIX;
664  				}
665  			}
666  			if (!g_menuTheme)
667  			{
668  				g_menuTheme = OpenThemeData(hWnd, L"Menu");
669  			}
670  			if (iBackgroundStateID == MPI_NORMAL || iBackgroundStateID == MPI_DISABLED)
671  			{
672  				FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, NppDarkMode::getDarkerBackgroundBrush());
673  			}
674  			else if (iBackgroundStateID == MPI_HOT || iBackgroundStateID == MPI_DISABLEDHOT)
675  			{
676  				FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, NppDarkMode::getHotBackgroundBrush());
677  			}
678  			else
679  			{
680  				DrawThemeBackground(g_menuTheme, pUDMI->um.hdc, MENU_POPUPITEM, iBackgroundStateID, &pUDMI->dis.rcItem, nullptr);
681  			}
682  			DTTOPTS dttopts{};
683  			dttopts.dwSize = sizeof(DTTOPTS);
684  			if (iTextStateID == MPI_NORMAL || iTextStateID == MPI_HOT)
685  			{
686  				dttopts.dwFlags |= DTT_TEXTCOLOR;
687  				dttopts.crText = NppDarkMode::getTextColor();
688  			}
689  			DrawThemeTextEx(g_menuTheme, pUDMI->um.hdc, MENU_POPUPITEM, iTextStateID, menuString, mii.cch, dwFlags, &pUDMI->dis.rcItem, &dttopts);
690  			*lr = 0;
691  			return true;
692  		}
693  		case WM_THEMECHANGED:
694  		{
695  			if (g_menuTheme)
696  			{
697  				CloseThemeData(g_menuTheme);
698  				g_menuTheme = nullptr;
699  			}
700  			return false;
701  		}
702  		default:
703  			return false;
704  		}
705  	}
706  	void drawUAHMenuNCBottomLine(HWND hWnd)
707  	{
708  		MENUBARINFO mbi{};
709  		mbi.cbSize = sizeof(MENUBARINFO);
710  		if (!GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi))
711  		{
712  			return;
713  		}
714  		RECT rcClient{};
715  		GetClientRect(hWnd, &rcClient);
716  		MapWindowPoints(hWnd, nullptr, (POINT*)&rcClient, 2);
717  		RECT rcWindow{};
718  		GetWindowRect(hWnd, &rcWindow);
719  		OffsetRect(&rcClient, -rcWindow.left, -rcWindow.top);
720  		RECT rcAnnoyingLine = rcClient;
721  		rcAnnoyingLine.bottom = rcAnnoyingLine.top;
722  		rcAnnoyingLine.top--;
723  		HDC hdc = GetWindowDC(hWnd);
724  		FillRect(hdc, &rcAnnoyingLine, NppDarkMode::getDarkerBackgroundBrush());
725  		ReleaseDC(hWnd, hdc);
726  	}
727  	void initExperimentalDarkMode()
728  	{
729  		::InitDarkMode();
730  	}
731  	void setDarkMode(bool useDark, bool fixDarkScrollbar)
732  	{
733  		::SetDarkMode(useDark, fixDarkScrollbar);
734  	}
735  	void allowDarkModeForApp(bool allow)
736  	{
737  		::AllowDarkModeForApp(allow);
738  	}
739  	bool allowDarkModeForWindow(HWND hWnd, bool allow)
740  	{
741  		return ::AllowDarkModeForWindow(hWnd, allow);
742  	}
743  	void setTitleBarThemeColor(HWND hWnd)
744  	{
745  		::RefreshTitleBarThemeColor(hWnd);
746  	}
747  	void enableDarkScrollBarForWindowAndChildren(HWND hwnd)
748  	{
749  		::EnableDarkScrollBarForWindowAndChildren(hwnd);
750  	}
751  	void paintRoundFrameRect(HDC hdc, const RECT rect, const HPEN hpen, int width, int height)
752  	{
753  		auto holdBrush = ::SelectObject(hdc, ::GetStockObject(NULL_BRUSH));
754  		auto holdPen = ::SelectObject(hdc, hpen);
755  		::RoundRect(hdc, rect.left, rect.top, rect.right, rect.bottom, width, height);
756  		::SelectObject(hdc, holdBrush);
757  		::SelectObject(hdc, holdPen);
758  	}
759  	struct ButtonData
760  	{
761  		HTHEME hTheme = nullptr;
762  		int iStateID = 0;
763  		~ButtonData()
764  		{
765  			closeTheme();
766  		}
767  		bool ensureTheme(HWND hwnd)
768  		{
769  			if (!hTheme)
770  			{
771  				hTheme = OpenThemeData(hwnd, WC_BUTTON);
772  			}
773  			return hTheme != nullptr;
774  		}
775  		void closeTheme()
776  		{
777  			if (hTheme)
778  			{
779  				CloseThemeData(hTheme);
780  				hTheme = nullptr;
781  			}
782  		}
783  	};
784  	void renderButton(HWND hwnd, HDC hdc, HTHEME hTheme, int iPartID, int iStateID)
785  	{
786  		RECT rcClient{};
787  		WCHAR szText[256] = { '\0' };
788  		DWORD nState = static_cast<DWORD>(SendMessage(hwnd, BM_GETSTATE, 0, 0));
789  		DWORD uiState = static_cast<DWORD>(SendMessage(hwnd, WM_QUERYUISTATE, 0, 0));
790  		auto nStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
791  		HFONT hFont = nullptr;
792  		HFONT hOldFont = nullptr;
793  		HFONT hCreatedFont = nullptr;
794  		LOGFONT lf{};
795  		if (SUCCEEDED(GetThemeFont(hTheme, hdc, iPartID, iStateID, TMT_FONT, &lf)))
796  		{
797  			hCreatedFont = CreateFontIndirect(&lf);
798  			hFont = hCreatedFont;
799  		}
800  		if (!hFont) {
801  			hFont = reinterpret_cast<HFONT>(SendMessage(hwnd, WM_GETFONT, 0, 0));
802  		}
803  		hOldFont = static_cast<HFONT>(SelectObject(hdc, hFont));
804  		DWORD dtFlags = DT_LEFT; 
805  		dtFlags |= (nStyle & BS_MULTILINE) ? DT_WORDBREAK : DT_SINGLELINE;
806  		dtFlags |= ((nStyle & BS_CENTER) == BS_CENTER) ? DT_CENTER : (nStyle & BS_RIGHT) ? DT_RIGHT : 0;
807  		dtFlags |= ((nStyle & BS_VCENTER) == BS_VCENTER) ? DT_VCENTER : (nStyle & BS_BOTTOM) ? DT_BOTTOM : 0;
808  		dtFlags |= (uiState & UISF_HIDEACCEL) ? DT_HIDEPREFIX : 0;
809  		if (!(nStyle & BS_MULTILINE) && !(nStyle & BS_BOTTOM) && !(nStyle & BS_TOP))
810  		{
811  			dtFlags |= DT_VCENTER;
812  		}
813  		GetClientRect(hwnd, &rcClient);
814  		GetWindowText(hwnd, szText, _countof(szText));
815  		SIZE szBox = { 13, 13 };
816  		GetThemePartSize(hTheme, hdc, iPartID, iStateID, NULL, TS_DRAW, &szBox);
817  		RECT rcText = rcClient;
818  		GetThemeBackgroundContentRect(hTheme, hdc, iPartID, iStateID, &rcClient, &rcText);
819  		RECT rcBackground = rcClient;
820  		if (dtFlags & DT_SINGLELINE)
821  		{
822  			rcBackground.top += (rcText.bottom - rcText.top - szBox.cy) / 2;
823  		}
824  		rcBackground.bottom = rcBackground.top + szBox.cy;
825  		rcBackground.right = rcBackground.left + szBox.cx;
826  		rcText.left = rcBackground.right + 3;
827  		DrawThemeParentBackground(hwnd, hdc, &rcClient);
828  		DrawThemeBackground(hTheme, hdc, iPartID, iStateID, &rcBackground, nullptr);
829  		DTTOPTS dtto{};
830  		dtto.dwSize = sizeof(DTTOPTS);
831  		dtto.dwFlags = DTT_TEXTCOLOR;
832  		dtto.crText = NppDarkMode::getTextColor();
833  		if (nStyle & WS_DISABLED)
834  		{
835  			dtto.crText = NppDarkMode::getDisabledTextColor();
836  		}
837  		DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, szText, -1, dtFlags, &rcText, &dtto);
838  		if ((nState & BST_FOCUS) && !(uiState & UISF_HIDEFOCUS))
839  		{
840  			RECT rcTextOut = rcText;
841  			dtto.dwFlags |= DTT_CALCRECT;
842  			DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, szText, -1, dtFlags | DT_CALCRECT, &rcTextOut, &dtto);
843  			RECT rcFocus = rcTextOut;
844  			rcFocus.bottom++;
845  			rcFocus.left--;
846  			rcFocus.right++;
847  			DrawFocusRect(hdc, &rcFocus);
848  		}
849  		if (hCreatedFont) DeleteObject(hCreatedFont);
850  		SelectObject(hdc, hOldFont);
851  	}
852  	void paintButton(HWND hwnd, HDC hdc, ButtonData& buttonData)
853  	{
854  		DWORD nState = static_cast<DWORD>(SendMessage(hwnd, BM_GETSTATE, 0, 0));
855  		const auto nStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
856  		const auto nButtonStyle = nStyle & BS_TYPEMASK;
857  		int iPartID = BP_CHECKBOX;
858  		if (nButtonStyle == BS_CHECKBOX || nButtonStyle == BS_AUTOCHECKBOX || nButtonStyle == BS_3STATE || nButtonStyle == BS_AUTO3STATE)
859  		{
860  			iPartID = BP_CHECKBOX;
861  		}
862  		else if (nButtonStyle == BS_RADIOBUTTON || nButtonStyle == BS_AUTORADIOBUTTON)
863  		{
864  			iPartID = BP_RADIOBUTTON;
865  		}
866  		else
867  		{
868  			assert(false);
869  		}
870  		int iStateID = RBS_UNCHECKEDNORMAL;
871  		if (nStyle & WS_DISABLED)		iStateID = RBS_UNCHECKEDDISABLED;
872  		else if (nState & BST_PUSHED)	iStateID = RBS_UNCHECKEDPRESSED;
873  		else if (nState & BST_HOT)		iStateID = RBS_UNCHECKEDHOT;
874  		if (nState & BST_CHECKED)		iStateID += 4;
875  		if (BufferedPaintRenderAnimation(hwnd, hdc))
876  		{
877  			return;
878  		}
879  		BP_ANIMATIONPARAMS animParams{};
880  		animParams.cbSize = sizeof(BP_ANIMATIONPARAMS);
881  		animParams.style = BPAS_LINEAR;
882  		if (iStateID != buttonData.iStateID)
883  		{
884  			GetThemeTransitionDuration(buttonData.hTheme, iPartID, buttonData.iStateID, iStateID, TMT_TRANSITIONDURATIONS, &animParams.dwDuration);
885  		}
886  		RECT rcClient{};
887  		GetClientRect(hwnd, &rcClient);
888  		HDC hdcFrom = nullptr;
889  		HDC hdcTo = nullptr;
890  		HANIMATIONBUFFER hbpAnimation = BeginBufferedAnimation(hwnd, hdc, &rcClient, BPBF_COMPATIBLEBITMAP, nullptr, &animParams, &hdcFrom, &hdcTo);
891  		if (hbpAnimation)
892  		{
893  			if (hdcFrom)
894  			{
895  				renderButton(hwnd, hdcFrom, buttonData.hTheme, iPartID, buttonData.iStateID);
896  			}
897  			if (hdcTo)
898  			{
899  				renderButton(hwnd, hdcTo, buttonData.hTheme, iPartID, iStateID);
900  			}
901  			buttonData.iStateID = iStateID;
902  			EndBufferedAnimation(hbpAnimation, TRUE);
903  		}
904  		else
905  		{
906  			renderButton(hwnd, hdc, buttonData.hTheme, iPartID, iStateID);
907  			buttonData.iStateID = iStateID;
908  		}
909  	}
910  	constexpr UINT_PTR g_buttonSubclassID = 42;
911  	LRESULT CALLBACK ButtonSubclass(
912  		HWND hWnd,
913  		UINT uMsg,
914  		WPARAM wParam,
915  		LPARAM lParam,
916  		UINT_PTR uIdSubclass,
917  		DWORD_PTR dwRefData
918  	)
919  	{
920  		UNREFERENCED_PARAMETER(uIdSubclass);
921  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
922  		switch (uMsg)
923  		{
924  			case WM_UPDATEUISTATE:
925  				if (HIWORD(wParam) & (UISF_HIDEACCEL | UISF_HIDEFOCUS))
926  				{
927  					InvalidateRect(hWnd, nullptr, FALSE);
928  				}
929  				break;
930  			case WM_NCDESTROY:
<span onclick='openModal()' class='match'>931  				RemoveWindowSubclass(hWnd, ButtonSubclass, g_buttonSubclassID);
932  				delete pButtonData;
933  				break;
934  			case WM_ERASEBKGND:
935  				if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
936  				{
937  					return TRUE;
938  				}
939  				else
940  				{
941  					break;
942  				}
943  			case WM_THEMECHANGED:
944  				pButtonData->closeTheme();
945  				break;
946  			case WM_PRINTCLIENT:
947  			case WM_PAINT:
948  				if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
949  				{
950  					PAINTSTRUCT ps{};
951  					HDC hdc = reinterpret_cast<HDC>(wParam);
952  					if (!hdc)
953  					{
954  						hdc = BeginPaint(hWnd, &ps);
955  					}
956  					paintButton(hWnd, hdc, *pButtonData);
957  					if (ps.hdc)
958  					{
959  						EndPaint(hWnd, &ps);
960  					}
961  					return 0;
962  				}
963  				else
964  				{
965  					break;
966  				}
967  			case WM_SIZE:
</span>968  			case WM_DESTROY:
969  				BufferedPaintStopAllAnimations(hWnd);
970  				break;
971  			case WM_ENABLE:
972  				if (NppDarkMode::isEnabled())
973  				{
974  					LRESULT lr = DefWindowProc(hWnd, uMsg, wParam, lParam);
975  					InvalidateRect(hWnd, nullptr, FALSE);
976  					return lr;
977  				}
978  				break;
979  		}
980  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
981  	}
982  	void subclassButtonControl(HWND hwnd)
983  	{
984  		DWORD_PTR pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
985  		SetWindowSubclass(hwnd, ButtonSubclass, g_buttonSubclassID, pButtonData);
986  	}
987  	void paintGroupbox(HWND hwnd, HDC hdc, ButtonData& buttonData)
988  	{
989  		auto nStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
990  		bool isDisabled = (nStyle & WS_DISABLED) == WS_DISABLED;
991  		int iPartID = BP_GROUPBOX;
992  		int iStateID = isDisabled ? GBS_DISABLED : GBS_NORMAL;
993  		RECT rcClient{};
994  		GetClientRect(hwnd, &rcClient);
995  		RECT rcText = rcClient;
996  		RECT rcBackground = rcClient;
997  		HFONT hFont = nullptr;
998  		HFONT hOldFont = nullptr;
999  		HFONT hCreatedFont = nullptr;
1000  		LOGFONT lf{};
1001  		if (SUCCEEDED(GetThemeFont(buttonData.hTheme, hdc, iPartID, iStateID, TMT_FONT, &lf)))
1002  		{
1003  			hCreatedFont = CreateFontIndirect(&lf);
1004  			hFont = hCreatedFont;
1005  		}
1006  		if (!hFont)
1007  		{
1008  			hFont = reinterpret_cast<HFONT>(SendMessage(hwnd, WM_GETFONT, 0, 0));
1009  		}
1010  		hOldFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
1011  		WCHAR szText[256] = { '\0' };
1012  		GetWindowText(hwnd, szText, _countof(szText));
1013  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
1014  		bool isCenter = (style & BS_CENTER) == BS_CENTER;
1015  		if (szText[0])
1016  		{
1017  			SIZE textSize{};
1018  			GetTextExtentPoint32(hdc, szText, static_cast<int>(wcslen(szText)), &textSize);
1019  			int centerPosX = isCenter ? ((rcClient.right - rcClient.left - textSize.cx) / 2) : 7;
1020  			rcBackground.top += textSize.cy / 2;
1021  			rcText.left += centerPosX;
1022  			rcText.bottom = rcText.top + textSize.cy;
1023  			rcText.right = rcText.left + textSize.cx + 4;
1024  			ExcludeClipRect(hdc, rcText.left, rcText.top, rcText.right, rcText.bottom);
1025  		}
1026  		else
1027  		{
1028  			SIZE textSize{};
1029  			GetTextExtentPoint32(hdc, L"M", 1, &textSize);
1030  			rcBackground.top += textSize.cy / 2;
1031  		}
1032  		RECT rcContent = rcBackground;
1033  		GetThemeBackgroundContentRect(buttonData.hTheme, hdc, BP_GROUPBOX, iStateID, &rcBackground, &rcContent);
1034  		ExcludeClipRect(hdc, rcContent.left, rcContent.top, rcContent.right, rcContent.bottom);
1035  		NppDarkMode::paintRoundFrameRect(hdc, rcBackground, NppDarkMode::getEdgePen());
1036  		SelectClipRgn(hdc, nullptr);
1037  		if (szText[0])
1038  		{
1039  			rcText.right -= 2;
1040  			rcText.left += 2;
1041  			DTTOPTS dtto{};
1042  			dtto.dwSize = sizeof(DTTOPTS);
1043  			dtto.dwFlags = DTT_TEXTCOLOR;
1044  			dtto.crText = isDisabled ? NppDarkMode::getDisabledTextColor() : NppDarkMode::getTextColor();
1045  			DWORD textFlags = isCenter ? DT_CENTER : DT_LEFT;
1046  			if(::SendMessage(hwnd, WM_QUERYUISTATE, 0, 0) != static_cast<LRESULT>(NULL))
1047  			{
1048  				textFlags |= DT_HIDEPREFIX;
1049  			}
1050  			DrawThemeTextEx(buttonData.hTheme, hdc, BP_GROUPBOX, iStateID, szText, -1, textFlags | DT_SINGLELINE, &rcText, &dtto);
1051  		}
1052  		if (hCreatedFont) DeleteObject(hCreatedFont);
1053  		SelectObject(hdc, hOldFont);
1054  	}
1055  	constexpr UINT_PTR g_groupboxSubclassID = 42;
1056  	LRESULT CALLBACK GroupboxSubclass(
1057  		HWND hWnd,
1058  		UINT uMsg,
1059  		WPARAM wParam,
1060  		LPARAM lParam,
1061  		UINT_PTR uIdSubclass,
1062  		DWORD_PTR dwRefData
1063  	)
1064  	{
1065  		UNREFERENCED_PARAMETER(uIdSubclass);
1066  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
1067  		switch (uMsg)
1068  		{
1069  		case WM_NCDESTROY:
1070  			RemoveWindowSubclass(hWnd, GroupboxSubclass, g_groupboxSubclassID);
1071  			delete pButtonData;
1072  			break;
1073  		case WM_ERASEBKGND:
1074  			if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
1075  			{
1076  				return TRUE;
1077  			}
1078  			else
1079  			{
1080  				break;
1081  			}
1082  		case WM_THEMECHANGED:
1083  			pButtonData->closeTheme();
1084  			break;
1085  		case WM_PRINTCLIENT:
1086  		case WM_PAINT:
1087  			if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
1088  			{
1089  				PAINTSTRUCT ps{};
1090  				HDC hdc = reinterpret_cast<HDC>(wParam);
1091  				if (!hdc)
1092  				{
1093  					hdc = BeginPaint(hWnd, &ps);
1094  				}
1095  				paintGroupbox(hWnd, hdc, *pButtonData);
1096  				if (ps.hdc)
1097  				{
1098  					EndPaint(hWnd, &ps);
1099  				}
1100  				return 0;
1101  			}
1102  			else
1103  			{
1104  				break;
1105  			}
1106  			break;
1107  		}
1108  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1109  	}
1110  	void subclassGroupboxControl(HWND hwnd)
1111  	{
1112  		DWORD_PTR pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
1113  		SetWindowSubclass(hwnd, GroupboxSubclass, g_groupboxSubclassID, pButtonData);
1114  	}
1115  	constexpr UINT_PTR g_tabSubclassID = 42;
1116  	LRESULT CALLBACK TabSubclass(
1117  		HWND hWnd,
1118  		UINT uMsg,
1119  		WPARAM wParam,
1120  		LPARAM lParam,
1121  		UINT_PTR uIdSubclass,
1122  		DWORD_PTR dwRefData
1123  	)
1124  	{
1125  		UNREFERENCED_PARAMETER(uIdSubclass);
1126  		UNREFERENCED_PARAMETER(dwRefData);
1127  		switch (uMsg)
1128  		{
1129  		case WM_PAINT:
1130  		{
1131  			if (!NppDarkMode::isEnabled())
1132  			{
1133  				break;
1134  			}
1135  			LONG_PTR dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
1136  			if ((dwStyle & TCS_BUTTONS) || (dwStyle & TCS_VERTICAL))
1137  			{
1138  				break;
1139  			}
1140  			PAINTSTRUCT ps{};
1141  			HDC hdc = ::BeginPaint(hWnd, &ps);
1142  			::FillRect(hdc, &ps.rcPaint, NppDarkMode::getDarkerBackgroundBrush());
1143  			auto holdPen = static_cast<HPEN>(::SelectObject(hdc, NppDarkMode::getEdgePen()));
1144  			HRGN holdClip = CreateRectRgn(0, 0, 0, 0);
1145  			if (1 != GetClipRgn(hdc, holdClip))
1146  			{
1147  				DeleteObject(holdClip);
1148  				holdClip = nullptr;
1149  			}
1150  			HFONT hFont = reinterpret_cast<HFONT>(SendMessage(hWnd, WM_GETFONT, 0, 0));
1151  			auto hOldFont = SelectObject(hdc, hFont);
1152  			POINT ptCursor{};
1153  			::GetCursorPos(&ptCursor);
1154  			ScreenToClient(hWnd, &ptCursor);
1155  			int nTabs = TabCtrl_GetItemCount(hWnd);
1156  			int nSelTab = TabCtrl_GetCurSel(hWnd);
1157  			for (int i = 0; i < nTabs; ++i)
1158  			{
1159  				RECT rcItem{};
1160  				TabCtrl_GetItemRect(hWnd, i, &rcItem);
1161  				RECT rcFrame = rcItem;
1162  				RECT rcIntersect{};
1163  				if (IntersectRect(&rcIntersect, &ps.rcPaint, &rcItem))
1164  				{
1165  					bool bHot = PtInRect(&rcItem, ptCursor);
1166  					bool isSelectedTab = (i == nSelTab);
1167  					HRGN hClip = CreateRectRgnIndirect(&rcItem);
1168  					SelectClipRgn(hdc, hClip);
1169  					SetTextColor(hdc, (bHot || isSelectedTab ) ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
1170  					::InflateRect(&rcItem, -1, -1);
1171  					rcItem.right += 1;
1172  					::FillRect(hdc, &rcItem, isSelectedTab ? NppDarkMode::getDarkerBackgroundBrush() : bHot ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getSofterBackgroundBrush());
1173  					SetBkMode(hdc, TRANSPARENT);
1174  					TCHAR label[MAX_PATH]{};
1175  					TCITEM tci{};
1176  					tci.mask = TCIF_TEXT;
1177  					tci.pszText = label;
1178  					tci.cchTextMax = MAX_PATH - 1;
1179  					::SendMessage(hWnd, TCM_GETITEM, i, reinterpret_cast<LPARAM>(&tci));
1180  					auto dpiManager = NppParameters::getInstance()._dpiManager;
1181  					RECT rcText = rcItem;
1182  					rcText.left += dpiManager.scaleX(5);
1183  					rcText.right -= dpiManager.scaleX(3);
1184  					if (isSelectedTab)
1185  					{
1186  						rcText.bottom -= dpiManager.scaleY(4);
1187  						::InflateRect(&rcFrame, 0, 1);
1188  					}
1189  					if (i != nTabs - 1)
1190  					{
1191  						rcFrame.right += 1;
1192  					}
1193  					::FrameRect(hdc, &rcFrame, NppDarkMode::getEdgeBrush());
1194  					DrawText(hdc, label, -1, &rcText, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
1195  					DeleteObject(hClip);
1196  					SelectClipRgn(hdc, holdClip);
1197  				}
1198  			}
1199  			SelectObject(hdc, hOldFont);
1200  			SelectClipRgn(hdc, holdClip);
1201  			if (holdClip)
1202  			{
1203  				DeleteObject(holdClip);
1204  				holdClip = nullptr;
1205  			}
1206  			SelectObject(hdc, holdPen);
1207  			EndPaint(hWnd, &ps);
1208  			return 0;
1209  		}
1210  		case WM_NCDESTROY:
1211  		{
1212  			RemoveWindowSubclass(hWnd, TabSubclass, g_tabSubclassID);
1213  			break;
1214  		}
1215  		case WM_PARENTNOTIFY:
1216  		{
1217  			switch (LOWORD(wParam))
1218  			{
1219  				case WM_CREATE:
1220  				{
1221  					auto hwndUpdown = reinterpret_cast<HWND>(lParam);
1222  					if (NppDarkMode::subclassTabUpDownControl(hwndUpdown))
1223  					{
1224  						return 0;
1225  					}
1226  					break;
1227  				}
1228  			}
1229  			return 0;
1230  		}
1231  		}
1232  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1233  	}
1234  	void subclassTabControl(HWND hwnd)
1235  	{
1236  		SetWindowSubclass(hwnd, TabSubclass, g_tabSubclassID, 0);
1237  	}
1238  	constexpr UINT_PTR g_customBorderSubclassID = 42;
1239  	LRESULT CALLBACK CustomBorderSubclass(
1240  		HWND hWnd,
1241  		UINT uMsg,
1242  		WPARAM wParam,
1243  		LPARAM lParam,
1244  		UINT_PTR uIdSubclass,
1245  		DWORD_PTR dwRefData
1246  	)
1247  	{
1248  		UNREFERENCED_PARAMETER(dwRefData);
1249  		static bool isHotStatic = false;
1250  		switch (uMsg)
1251  		{
1252  			case WM_NCPAINT:
1253  			{
1254  				if (!NppDarkMode::isEnabled())
1255  				{
1256  					break;
1257  				}
1258  				DefSubclassProc(hWnd, uMsg, wParam, lParam);
1259  				HDC hdc = ::GetWindowDC(hWnd);
1260  				RECT rcClient{};
1261  				::GetClientRect(hWnd, &rcClient);
1262  				rcClient.right += (2 * ::GetSystemMetrics(SM_CXEDGE));
1263  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1264  				bool hasVerScrollbar = (style & WS_VSCROLL) == WS_VSCROLL;
1265  				if (hasVerScrollbar)
1266  				{
1267  					rcClient.right += ::GetSystemMetrics(SM_CXVSCROLL);
1268  				}
1269  				rcClient.bottom += (2 * ::GetSystemMetrics(SM_CYEDGE));
1270  				bool hasHorScrollbar = (style & WS_HSCROLL) == WS_HSCROLL;
1271  				if (hasHorScrollbar)
1272  				{
1273  					rcClient.bottom += ::GetSystemMetrics(SM_CYHSCROLL);
1274  				}
1275  				HPEN hPen = ::CreatePen(PS_SOLID, 1, NppDarkMode::getBackgroundColor());
1276  				RECT rcInner = rcClient;
1277  				::InflateRect(&rcInner, -1, -1);
1278  				NppDarkMode::paintRoundFrameRect(hdc, rcInner, hPen);
1279  				::DeleteObject(hPen);
1280  				bool hasFocus = ::GetFocus() == hWnd;
1281  				POINT ptCursor{};
1282  				::GetCursorPos(&ptCursor);
1283  				::ScreenToClient(hWnd, &ptCursor);
1284  				bool isHot = ::PtInRect(&rcClient, ptCursor);
1285  				bool isWindowEnabled = ::IsWindowEnabled(hWnd) == TRUE;
1286  				HPEN hEnabledPen = ((isHotStatic && isHot) || hasFocus ? NppDarkMode::getHotEdgePen() : NppDarkMode::getEdgePen());
1287  				NppDarkMode::paintRoundFrameRect(hdc, rcClient, isWindowEnabled ? hEnabledPen : NppDarkMode::getDisabledEdgePen());
1288  				::ReleaseDC(hWnd, hdc);
1289  				return 0;
1290  			}
1291  			break;
1292  			case WM_NCCALCSIZE:
1293  			{
1294  				if (!NppDarkMode::isEnabled())
1295  				{
1296  					break;
1297  				}
1298  				auto lpRect = reinterpret_cast<LPRECT>(lParam);
1299  				::InflateRect(lpRect, -(::GetSystemMetrics(SM_CXEDGE)), -(::GetSystemMetrics(SM_CYEDGE)));
1300  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1301  				bool hasVerScrollbar = (style & WS_VSCROLL) == WS_VSCROLL;
1302  				if (hasVerScrollbar)
1303  				{
1304  					lpRect->right -= ::GetSystemMetrics(SM_CXVSCROLL);
1305  				}
1306  				bool hasHorScrollbar = (style & WS_HSCROLL) == WS_HSCROLL;
1307  				if (hasHorScrollbar)
1308  				{
1309  					lpRect->bottom -= ::GetSystemMetrics(SM_CYHSCROLL);
1310  				}
1311  				return 0;
1312  			}
1313  			break;
1314  			case WM_MOUSEMOVE:
1315  			{
1316  				if (!NppDarkMode::isEnabled())
1317  				{
1318  					break;
1319  				}
1320  				if (::GetFocus() == hWnd)
1321  				{
1322  					break;
1323  				}
1324  				TRACKMOUSEEVENT tme{};
1325  				tme.cbSize = sizeof(TRACKMOUSEEVENT);
1326  				tme.dwFlags = TME_LEAVE;
1327  				tme.hwndTrack = hWnd;
1328  				tme.dwHoverTime = HOVER_DEFAULT;
1329  				TrackMouseEvent(&tme);
1330  				if (!isHotStatic)
1331  				{
1332  					isHotStatic = true;
1333  					::SetWindowPos(hWnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1334  				}
1335  			}
1336  			break;
1337  			case WM_MOUSELEAVE:
1338  			{
1339  				if (!NppDarkMode::isEnabled())
1340  				{
1341  					break;
1342  				}
1343  				if (isHotStatic)
1344  				{
1345  					isHotStatic = false;
1346  					::SetWindowPos(hWnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1347  				}
1348  				TRACKMOUSEEVENT tme{};
1349  				tme.cbSize = sizeof(TRACKMOUSEEVENT);
1350  				tme.dwFlags = TME_LEAVE | TME_CANCEL;
1351  				tme.hwndTrack = hWnd;
1352  				tme.dwHoverTime = HOVER_DEFAULT;
1353  				TrackMouseEvent(&tme);
1354  			}
1355  			break;
1356  			case WM_NCDESTROY:
1357  			{
1358  				RemoveWindowSubclass(hWnd, CustomBorderSubclass, uIdSubclass);
1359  			}
1360  			break;
1361  		}
1362  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1363  	}
1364  	void subclassCustomBorderForListBoxAndEditControls(HWND hwnd)
1365  	{
1366  		SetWindowSubclass(hwnd, CustomBorderSubclass, g_customBorderSubclassID, 0);
1367  	}
1368  	constexpr UINT_PTR g_comboBoxSubclassID = 42;
1369  	LRESULT CALLBACK ComboBoxSubclass(
1370  		HWND hWnd,
1371  		UINT uMsg,
1372  		WPARAM wParam,
1373  		LPARAM lParam,
1374  		UINT_PTR uIdSubclass,
1375  		DWORD_PTR dwRefData
1376  	)
1377  	{
1378  		auto hwndEdit = reinterpret_cast<HWND>(dwRefData);
1379  		switch (uMsg)
1380  		{
1381  			case WM_PAINT:
1382  			{
1383  				if (!NppDarkMode::isEnabled())
1384  				{
1385  					break;
1386  				}
1387  				RECT rc{};
1388  				::GetClientRect(hWnd, &rc);
1389  				PAINTSTRUCT ps{};
1390  				auto hdc = ::BeginPaint(hWnd, &ps);
1391  				::SelectObject(hdc, reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0)));
1392  				::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1393  				auto holdBrush = ::SelectObject(hdc, NppDarkMode::getDarkerBackgroundBrush());
1394  				auto& dpiManager = NppParameters::getInstance()._dpiManager;
1395  				RECT rcArrow{};
1396  				COMBOBOXINFO cbi{};
1397  				cbi.cbSize = sizeof(COMBOBOXINFO);
1398  				const bool resultCbi = ::GetComboBoxInfo(hWnd, &cbi) != FALSE;
1399  				if (resultCbi)
1400  				{
1401  					rcArrow = cbi.rcButton;
1402  					rcArrow.left -= 1;
1403  				}
1404  				else
1405  				{
1406  					rcArrow = {
1407  					rc.right - dpiManager.scaleX(17), rc.top + 1,
1408  					rc.right - 1, rc.bottom - 1
1409  					};
1410  				}
1411  				bool hasFocus = false;
1412  				const bool isWindowEnabled = ::IsWindowEnabled(hWnd) == TRUE;
1413  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1414  				if ((style & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST)
1415  				{
1416  					hasFocus = ::GetFocus() == hWnd;
1417  					RECT rcTextBg{};
1418  					if (resultCbi)
1419  					{
1420  						rcTextBg = cbi.rcItem;
1421  					}
1422  					else
1423  					{
1424  						rcTextBg = rc;
1425  						rcTextBg.left += 1;
1426  						rcTextBg.top += 1;
1427  						rcTextBg.right = rcArrow.left - 1;
1428  						rcTextBg.bottom -= 1;
1429  					}
1430  					::FillRect(hdc, &rcTextBg, NppDarkMode::getBackgroundBrush()); 
1431  					auto index = static_cast<int>(::SendMessage(hWnd, CB_GETCURSEL, 0, 0));
1432  					if (index != CB_ERR)
1433  					{
1434  						::SetTextColor(hdc, isWindowEnabled ? NppDarkMode::getTextColor() : NppDarkMode::getDisabledTextColor());
1435  						::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1436  						auto bufferLen = static_cast<size_t>(::SendMessage(hWnd, CB_GETLBTEXTLEN, index, 0));
1437  						TCHAR* buffer = new TCHAR[(bufferLen + 1)];
1438  						::SendMessage(hWnd, CB_GETLBTEXT, index, reinterpret_cast<LPARAM>(buffer));
1439  						RECT rcText = rcTextBg;
1440  						rcText.left += 4;
1441  						rcText.right -= 4;
1442  						::DrawText(hdc, buffer, -1, &rcText, DT_NOPREFIX | DT_LEFT | DT_VCENTER | DT_SINGLELINE);
1443  						delete[] buffer;
1444  					}
1445  					if (hasFocus && ::SendMessage(hWnd, CB_GETDROPPEDSTATE, 0, 0) == FALSE)
1446  					{
1447  						::DrawFocusRect(hdc, &rcTextBg);
1448  					}
1449  				}
1450  				else if ((style & CBS_DROPDOWN) == CBS_DROPDOWN && hwndEdit != nullptr)
1451  				{
1452  					hasFocus = ::GetFocus() == hwndEdit;
1453  				}
1454  				POINT ptCursor{};
1455  				::GetCursorPos(&ptCursor);
1456  				::ScreenToClient(hWnd, &ptCursor);
1457  				bool isHot = ::PtInRect(&rc, ptCursor);
1458  				auto colorEnabledText = isHot ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor();
1459  				::SetTextColor(hdc, isWindowEnabled ? colorEnabledText : NppDarkMode::getDisabledTextColor());
1460  				::SetBkColor(hdc, isHot ? NppDarkMode::getHotBackgroundColor() : NppDarkMode::getBackgroundColor());
1461  				::FillRect(hdc, &rcArrow, isHot ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
1462  				TCHAR arrow[] = L"˅";
1463  				::DrawText(hdc, arrow, -1, &rcArrow, DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
1464  				::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1465  				auto hEnabledPen = (isHot || hasFocus) ? NppDarkMode::getHotEdgePen() : NppDarkMode::getEdgePen();
1466  				auto hSelectedPen = isWindowEnabled ? hEnabledPen : NppDarkMode::getDisabledEdgePen();
1467  				auto holdPen = static_cast<HPEN>(::SelectObject(hdc, hSelectedPen));
1468  				POINT edge[] = {
1469  					{rcArrow.left - 1, rcArrow.top},
1470  					{rcArrow.left - 1, rcArrow.bottom}
1471  				};
1472  				::Polyline(hdc, edge, _countof(edge));
1473  				int roundCornerValue = NppDarkMode::isWindows11() ? dpiManager.scaleX(4) : 0;
1474  				NppDarkMode::paintRoundFrameRect(hdc, rc, hSelectedPen, roundCornerValue, roundCornerValue);
1475  				::SelectObject(hdc, holdPen);
1476  				::SelectObject(hdc, holdBrush);
1477  				::EndPaint(hWnd, &ps);
1478  				return 0;
1479  			}
1480  			case WM_NCDESTROY:
1481  			{
1482  				::RemoveWindowSubclass(hWnd, ComboBoxSubclass, uIdSubclass);
1483  				break;
1484  			}
1485  		}
1486  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1487  	}
1488  	void subclassComboBoxControl(HWND hwnd)
1489  	{
1490  		DWORD_PTR hwndEditData = 0;
1491  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1492  		if ((style & CBS_DROPDOWN) == CBS_DROPDOWN)
1493  		{
1494  			POINT pt = { 5, 5 };
1495  			hwndEditData = reinterpret_cast<DWORD_PTR>(::ChildWindowFromPoint(hwnd, pt));
1496  		}
1497  		SetWindowSubclass(hwnd, ComboBoxSubclass, g_comboBoxSubclassID, hwndEditData);
1498  	}
1499  	constexpr UINT_PTR g_listViewSubclassID = 42;
1500  	LRESULT CALLBACK ListViewSubclass(
1501  		HWND hWnd,
1502  		UINT uMsg,
1503  		WPARAM wParam,
1504  		LPARAM lParam,
1505  		UINT_PTR uIdSubclass,
1506  		DWORD_PTR dwRefData
1507  	)
1508  	{
1509  		UNREFERENCED_PARAMETER(dwRefData);
1510  		switch (uMsg)
1511  		{
1512  			case WM_NCDESTROY:
1513  			{
1514  				::RemoveWindowSubclass(hWnd, ListViewSubclass, uIdSubclass);
1515  				break;
1516  			}
1517  			case WM_NOTIFY:
1518  			{
1519  				switch (reinterpret_cast<LPNMHDR>(lParam)->code)
1520  				{
1521  					case NM_CUSTOMDRAW:
1522  					{
1523  						auto lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
1524  						switch (lpnmcd->dwDrawStage)
1525  						{
1526  							case CDDS_PREPAINT:
1527  							{
1528  								if (NppDarkMode::isExperimentalSupported() && NppDarkMode::isEnabled())
1529  								{
1530  									return CDRF_NOTIFYITEMDRAW;
1531  								}
1532  								return CDRF_DODEFAULT;
1533  							}
1534  							case CDDS_ITEMPREPAINT:
1535  							{
1536  								SetTextColor(lpnmcd->hdc, NppDarkMode::getDarkerTextColor());
1537  								return CDRF_NEWFONT;
1538  							}
1539  							default:
1540  								return CDRF_DODEFAULT;
1541  						}
1542  					}
1543  					break;
1544  				}
1545  				break;
1546  			}
1547  			break;
1548  		}
1549  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1550  	}
1551  	void subclassListViewControl(HWND hwnd)
1552  	{
1553  		SetWindowSubclass(hwnd, ListViewSubclass, g_listViewSubclassID, 0);
1554  	}
1555  	constexpr UINT_PTR g_upDownSubclassID = 42;
1556  	LRESULT CALLBACK UpDownSubclass(
1557  		HWND hWnd,
1558  		UINT uMsg,
1559  		WPARAM wParam,
1560  		LPARAM lParam,
1561  		UINT_PTR uIdSubclass,
1562  		DWORD_PTR dwRefData
1563  	)
1564  	{
1565  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
1566  		switch (uMsg)
1567  		{
1568  			case WM_PRINTCLIENT:
1569  			case WM_PAINT:
1570  			{
1571  				if (!NppDarkMode::isEnabled())
1572  				{
1573  					break;
1574  				}
1575  				const auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1576  				const bool isHorizontal = ((style & UDS_HORZ) == UDS_HORZ);
1577  				bool hasTheme = pButtonData->ensureTheme(hWnd);
1578  				RECT rcClient{};
1579  				::GetClientRect(hWnd, &rcClient);
1580  				PAINTSTRUCT ps{};
1581  				auto hdc = ::BeginPaint(hWnd, &ps);
1582  				::FillRect(hdc, &rcClient, NppDarkMode::getDarkerBackgroundBrush());
1583  				RECT rcArrowPrev{};
1584  				RECT rcArrowNext{};
1585  				if (isHorizontal)
1586  				{
1587  					RECT rcArrowLeft{
1588  						rcClient.left, rcClient.top,
1589  						rcClient.right - ((rcClient.right - rcClient.left) / 2), rcClient.bottom
1590  					};
1591  					RECT rcArrowRight{
1592  						rcArrowLeft.right - 1, rcClient.top,
1593  						rcClient.right, rcClient.bottom
1594  					};
1595  					rcArrowPrev = rcArrowLeft;
1596  					rcArrowNext = rcArrowRight;
1597  				}
1598  				else
1599  				{
1600  					RECT rcArrowTop{
1601  						rcClient.left, rcClient.top,
1602  						rcClient.right, rcClient.bottom - ((rcClient.bottom - rcClient.top) / 2)
1603  					};
1604  					RECT rcArrowBottom{
1605  						rcClient.left, rcArrowTop.bottom - 1,
1606  						rcClient.right, rcClient.bottom
1607  					};
1608  					rcArrowPrev = rcArrowTop;
1609  					rcArrowNext = rcArrowBottom;
1610  				}
1611  				POINT ptCursor{};
1612  				::GetCursorPos(&ptCursor);
1613  				::ScreenToClient(hWnd, &ptCursor);
1614  				bool isHotPrev = ::PtInRect(&rcArrowPrev, ptCursor);
1615  				bool isHotNext = ::PtInRect(&rcArrowNext, ptCursor);
1616  				::SetBkMode(hdc, TRANSPARENT);
1617  				if (hasTheme)
1618  				{
1619  					::DrawThemeBackground(pButtonData->hTheme, hdc, BP_PUSHBUTTON, isHotPrev ? PBS_HOT : PBS_NORMAL, &rcArrowPrev, nullptr);
1620  					::DrawThemeBackground(pButtonData->hTheme, hdc, BP_PUSHBUTTON, isHotNext ? PBS_HOT : PBS_NORMAL, &rcArrowNext, nullptr);
1621  				}
1622  				else
1623  				{
1624  					::FillRect(hdc, &rcArrowPrev, isHotPrev ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
1625  					::FillRect(hdc, &rcArrowNext, isHotNext ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
1626  				}
1627  				const auto arrowTextFlags = DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP;
1628  				::SetTextColor(hdc, isHotPrev ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
1629  				::DrawText(hdc, isHorizontal ? L"<" : L"˄", -1, &rcArrowPrev, arrowTextFlags);
1630  				::SetTextColor(hdc, isHotNext ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
1631  				::DrawText(hdc, isHorizontal ? L">" : L"˅", -1, &rcArrowNext, arrowTextFlags);
1632  				if (!hasTheme)
1633  				{
1634  					NppDarkMode::paintRoundFrameRect(hdc, rcArrowPrev, NppDarkMode::getEdgePen());
1635  					NppDarkMode::paintRoundFrameRect(hdc, rcArrowNext, NppDarkMode::getEdgePen());
1636  				}
1637  				::EndPaint(hWnd, &ps);
1638  				return FALSE;
1639  			}
1640  			case WM_THEMECHANGED:
1641  			{
1642  				pButtonData->closeTheme();
1643  				break;
1644  			}
1645  			case WM_NCDESTROY:
1646  			{
1647  				::RemoveWindowSubclass(hWnd, UpDownSubclass, uIdSubclass);
1648  				delete pButtonData;
1649  				break;
1650  			}
1651  			case WM_ERASEBKGND:
1652  			{
1653  				if (NppDarkMode::isEnabled())
1654  				{
1655  					RECT rcClient{};
1656  					::GetClientRect(hWnd, &rcClient);
1657  					::FillRect(reinterpret_cast<HDC>(wParam), &rcClient, NppDarkMode::getDarkerBackgroundBrush());
1658  					return TRUE;
1659  				}
1660  				break;
1661  			}
1662  		}
1663  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1664  	}
1665  	void subclassAndThemeUpDownControl(HWND hwnd, NppDarkModeParams p)
1666  	{
1667  		if (p._subclass)
1668  		{
1669  			auto pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
1670  			SetWindowSubclass(hwnd, UpDownSubclass, g_upDownSubclassID, pButtonData);
1671  		}
1672  		if (p._theme)
1673  		{
1674  			SetWindowTheme(hwnd, p._themeClassName, nullptr);
1675  		}
1676  	}
1677  	bool subclassTabUpDownControl(HWND hwnd)
1678  	{
1679  		constexpr size_t classNameLen = 16;
1680  		TCHAR className[classNameLen]{};
1681  		GetClassName(hwnd, className, classNameLen);
1682  		if (wcscmp(className, UPDOWN_CLASS) == 0)
1683  		{
1684  			auto pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
1685  			SetWindowSubclass(hwnd, UpDownSubclass, g_upDownSubclassID, pButtonData);
1686  			NppDarkMode::setDarkExplorerTheme(hwnd);
1687  			return true;
1688  		}
1689  		return false;
1690  	}
1691  	void autoSubclassAndThemeChildControls(HWND hwndParent, bool subclass, bool theme)
1692  	{
1693  		NppDarkModeParams p{
1694  			g_isAtLeastWindows10 && NppDarkMode::isEnabled() ? L"DarkMode_Explorer" : nullptr
1695  			, subclass
1696  			, theme
1697  		};
1698  		::EnableThemeDialogTexture(hwndParent, theme && !NppDarkMode::isEnabled() ? ETDT_ENABLETAB : ETDT_DISABLE);
1699  		EnumChildWindows(hwndParent, [](HWND hwnd, LPARAM lParam) WINAPI_LAMBDA {
1700  			auto& p = *reinterpret_cast<NppDarkModeParams*>(lParam);
1701  			constexpr size_t classNameLen = 32;
1702  			TCHAR className[classNameLen]{};
1703  			GetClassName(hwnd, className, classNameLen);
1704  			if (wcscmp(className, WC_BUTTON) == 0)
1705  			{
1706  				NppDarkMode::subclassAndThemeButton(hwnd, p);
1707  				return TRUE;
1708  			}
1709  			if (wcscmp(className, WC_COMBOBOX) == 0)
1710  			{
1711  				NppDarkMode::subclassAndThemeComboBox(hwnd, p);
1712  				return TRUE;
1713  			}
1714  			if (wcscmp(className, WC_EDIT) == 0)
1715  			{
1716  				if (!g_isWine)
1717  				{
1718  					NppDarkMode::subclassAndThemeListBoxOrEditControl(hwnd, p, false);
1719  				}
1720  				return TRUE;
1721  			}
1722  			if (wcscmp(className, WC_LISTBOX) == 0)
1723  			{
1724  				if (!g_isWine)
1725  				{
1726  					NppDarkMode::subclassAndThemeListBoxOrEditControl(hwnd, p, true);
1727  				}
1728  				return TRUE;
1729  			}
1730  			if (wcscmp(className, WC_LISTVIEW) == 0)
1731  			{
1732  				NppDarkMode::subclassAndThemeListView(hwnd, p);
1733  				return TRUE;
1734  			}
1735  			if (wcscmp(className, WC_TREEVIEW) == 0)
1736  			{
1737  				NppDarkMode::themeTreeView(hwnd, p);
1738  				return TRUE;
1739  			}
1740  			if (wcscmp(className, TOOLBARCLASSNAME) == 0)
1741  			{
1742  				NppDarkMode::themeToolbar(hwnd, p);
1743  				return TRUE;
1744  			}
1745  			if (wcscmp(className, L"RichEdit20W") == 0 || wcscmp(className, L"RICHEDIT50W") == 0)
1746  			{
1747  				NppDarkMode::themeRichEdit(hwnd, p);
1748  				return TRUE;
1749  			}
1750  			if (wcscmp(className, UPDOWN_CLASS) == 0)
1751  			{
1752  				NppDarkMode::subclassAndThemeUpDownControl(hwnd, p);
1753  				return TRUE;
1754  			}
1755  			return TRUE;
1756  		}, reinterpret_cast<LPARAM>(&p));
1757  	}
1758  	void autoThemeChildControls(HWND hwndParent)
1759  	{
1760  		autoSubclassAndThemeChildControls(hwndParent, false, g_isAtLeastWindows10);
1761  	}
1762  	void subclassAndThemeButton(HWND hwnd, NppDarkModeParams p)
1763  	{
1764  		auto nButtonStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1765  		switch (nButtonStyle & BS_TYPEMASK)
1766  		{
1767  			case BS_CHECKBOX:
1768  			case BS_AUTOCHECKBOX:
1769  			case BS_3STATE:
1770  			case BS_AUTO3STATE:
1771  			case BS_RADIOBUTTON:
1772  			case BS_AUTORADIOBUTTON:
1773  			{
1774  				if ((nButtonStyle & BS_PUSHLIKE) == BS_PUSHLIKE)
1775  				{
1776  					if (p._theme)
1777  					{
1778  						SetWindowTheme(hwnd, p._themeClassName, nullptr);
1779  					}
1780  					break;
1781  				}
1782  				if (p._subclass)
1783  				{
1784  					NppDarkMode::subclassButtonControl(hwnd);
1785  				}
1786  				break;
1787  			}
1788  			case BS_GROUPBOX:
1789  			{
1790  				if (p._subclass)
1791  				{
1792  					NppDarkMode::subclassGroupboxControl(hwnd);
1793  				}
1794  				break;
1795  			}
1796  			case BS_PUSHBUTTON:
1797  			case BS_DEFPUSHBUTTON:
1798  			case BS_SPLITBUTTON:
1799  			case BS_DEFSPLITBUTTON:
1800  			{
1801  				if (p._theme)
1802  				{
1803  					SetWindowTheme(hwnd, p._themeClassName, nullptr);
1804  				}
1805  				break;
1806  			}
1807  			default:
1808  			{
1809  				break;
1810  			}
1811  		}
1812  	}
1813  	void subclassAndThemeComboBox(HWND hwnd, NppDarkModeParams p)
1814  	{
1815  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1816  		if ((style & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST || (style & CBS_DROPDOWN) == CBS_DROPDOWN)
1817  		{
1818  			COMBOBOXINFO cbi{};
1819  			cbi.cbSize = sizeof(COMBOBOXINFO);
1820  			BOOL result = ::GetComboBoxInfo(hwnd, &cbi);
1821  			if (result == TRUE)
1822  			{
1823  				if (p._theme && cbi.hwndList)
1824  				{
1825  					::SetWindowTheme(cbi.hwndList, p._themeClassName, nullptr);
1826  				}
1827  			}
1828  			if (p._subclass)
1829  			{
1830  				NppDarkMode::subclassComboBoxControl(hwnd);
1831  			}
1832  		}
1833  	}
1834  	void subclassAndThemeListBoxOrEditControl(HWND hwnd, NppDarkModeParams p, bool isListBox)
1835  	{
1836  		const auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1837  		bool hasScrollBar = ((style & WS_HSCROLL) == WS_HSCROLL) || ((style & WS_VSCROLL) == WS_VSCROLL);
1838  		if (p._theme && (isListBox || hasScrollBar))
1839  		{
1840  			SetWindowTheme(hwnd, p._themeClassName, nullptr);
1841  		}
1842  		const auto exStyle = ::GetWindowLongPtr(hwnd, GWL_EXSTYLE);
1843  		bool hasClientEdge = (exStyle & WS_EX_CLIENTEDGE) == WS_EX_CLIENTEDGE;
1844  		bool isCBoxListBox = isListBox && (style & LBS_COMBOBOX) == LBS_COMBOBOX;
1845  		if (p._subclass && hasClientEdge && !isCBoxListBox)
1846  		{
1847  			NppDarkMode::subclassCustomBorderForListBoxAndEditControls(hwnd);
1848  		}
1849  #ifndef __MINGW64__ 
1850  		bool changed = false;
1851  		if (::GetWindowSubclass(hwnd, CustomBorderSubclass, g_customBorderSubclassID, nullptr) == TRUE)
1852  		{
1853  			if (NppDarkMode::isEnabled())
1854  			{
1855  				if (hasClientEdge)
1856  				{
1857  					::SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle & ~WS_EX_CLIENTEDGE);
1858  					changed = true;
1859  				}
1860  			}
1861  			else if (!hasClientEdge)
1862  			{
1863  				::SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle | WS_EX_CLIENTEDGE);
1864  				changed = true;
1865  			}
1866  		}
1867  		if (changed)
1868  		{
1869  			::SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1870  		}
1871  #endif 
1872  	}
1873  	void subclassAndThemeListView(HWND hwnd, NppDarkModeParams p)
1874  	{
1875  		if (p._theme)
1876  		{
1877  			NppDarkMode::setDarkListView(hwnd);
1878  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::listview);
1879  		}
1880  		ListView_SetTextColor(hwnd, NppParameters::getInstance().getCurrentDefaultFgColor());
1881  		ListView_SetTextBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1882  		ListView_SetBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1883  		if (p._subclass)
1884  		{
1885  			auto exStyle = ListView_GetExtendedListViewStyle(hwnd);
1886  			ListView_SetExtendedListViewStyle(hwnd, exStyle | LVS_EX_DOUBLEBUFFER);
1887  			NppDarkMode::subclassListViewControl(hwnd);
1888  		}
1889  	}
1890  	void themeTreeView(HWND hwnd, NppDarkModeParams p)
1891  	{
1892  		TreeView_SetTextColor(hwnd, NppParameters::getInstance().getCurrentDefaultFgColor());
1893  		TreeView_SetBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1894  		NppDarkMode::calculateTreeViewStyle();
1895  		NppDarkMode::setTreeViewStyle(hwnd);
1896  		if (p._theme)
1897  		{
1898  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::treeview);
1899  		}
1900  	}
1901  	void themeToolbar(HWND hwnd, NppDarkModeParams p)
1902  	{
1903  		NppDarkMode::setDarkLineAbovePanelToolbar(hwnd);
1904  		if (p._theme)
1905  		{
1906  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::toolbar);
1907  		}
1908  	}
1909  	void themeRichEdit(HWND hwnd, NppDarkModeParams p)
1910  	{
1911  		if (p._theme)
1912  		{
1913  			SetWindowTheme(hwnd, p._themeClassName, nullptr);
1914  		}
1915  	}
1916  	LRESULT darkToolBarNotifyCustomDraw(LPARAM lParam)
1917  	{
1918  		auto nmtbcd = reinterpret_cast<LPNMTBCUSTOMDRAW>(lParam);
1919  		static int roundCornerValue = 0;
1920  		switch (nmtbcd->nmcd.dwDrawStage)
1921  		{
1922  			case CDDS_PREPAINT:
1923  			{
1924  				if (NppDarkMode::isEnabled())
1925  				{
1926  					auto dpiManager = NppParameters::getInstance()._dpiManager;
1927  					roundCornerValue = NppDarkMode::isWindows11() ? dpiManager.scaleX(5) : 0;
1928  					::FillRect(nmtbcd->nmcd.hdc, &nmtbcd->nmcd.rc, NppDarkMode::getDarkerBackgroundBrush());
1929  					return CDRF_NOTIFYITEMDRAW;
1930  				}
1931  				return CDRF_DODEFAULT;
1932  			}
1933  			case CDDS_ITEMPREPAINT:
1934  			{
1935  				nmtbcd->hbrLines = NppDarkMode::getEdgeBrush();
1936  				nmtbcd->clrText = NppDarkMode::getTextColor();
1937  				nmtbcd->clrTextHighlight = NppDarkMode::getTextColor();
1938  				nmtbcd->clrBtnFace = NppDarkMode::getBackgroundColor();
1939  				nmtbcd->clrBtnHighlight = NppDarkMode::getSofterBackgroundColor();
1940  				nmtbcd->clrHighlightHotTrack = NppDarkMode::getHotBackgroundColor();
1941  				nmtbcd->nStringBkMode = TRANSPARENT;
1942  				nmtbcd->nHLStringBkMode = TRANSPARENT;
1943  				if ((nmtbcd->nmcd.uItemState & CDIS_CHECKED) == CDIS_CHECKED)
1944  				{
1945  					auto holdBrush = ::SelectObject(nmtbcd->nmcd.hdc, NppDarkMode::getSofterBackgroundBrush());
1946  					auto holdPen = ::SelectObject(nmtbcd->nmcd.hdc, NppDarkMode::getEdgePen());
1947  					::RoundRect(nmtbcd->nmcd.hdc, nmtbcd->nmcd.rc.left, nmtbcd->nmcd.rc.top, nmtbcd->nmcd.rc.right, nmtbcd->nmcd.rc.bottom, roundCornerValue, roundCornerValue);
1948  					::SelectObject(nmtbcd->nmcd.hdc, holdBrush);
1949  					::SelectObject(nmtbcd->nmcd.hdc, holdPen);
1950  					nmtbcd->nmcd.uItemState &= ~CDIS_CHECKED;
1951  				}
1952  				return TBCDRF_HILITEHOTTRACK | TBCDRF_USECDCOLORS | CDRF_NOTIFYPOSTPAINT;
1953  			}
1954  			case CDDS_ITEMPOSTPAINT:
1955  			{
1956  				bool isDropDown = false;
1957  				auto exStyle = ::SendMessage(nmtbcd->nmcd.hdr.hwndFrom, TB_GETEXTENDEDSTYLE, 0, 0);
1958  				if ((exStyle & TBSTYLE_EX_DRAWDDARROWS) == TBSTYLE_EX_DRAWDDARROWS)
1959  				{
1960  					TBBUTTONINFO tbButtonInfo{};
1961  					tbButtonInfo.cbSize = sizeof(TBBUTTONINFO);
1962  					tbButtonInfo.dwMask = TBIF_STYLE;
1963  					::SendMessage(nmtbcd->nmcd.hdr.hwndFrom, TB_GETBUTTONINFO, nmtbcd->nmcd.dwItemSpec, reinterpret_cast<LPARAM>(&tbButtonInfo));
1964  					isDropDown = (tbButtonInfo.fsStyle & BTNS_DROPDOWN) == BTNS_DROPDOWN;
1965  				}
1966  				if ( !isDropDown && (nmtbcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
1967  				{
1968  					NppDarkMode::paintRoundFrameRect(nmtbcd->nmcd.hdc, nmtbcd->nmcd.rc, NppDarkMode::getHotEdgePen(), roundCornerValue, roundCornerValue);
1969  				}
1970  				return CDRF_DODEFAULT;
1971  			}
1972  			default:
1973  				return CDRF_DODEFAULT;
1974  		}
1975  	}
1976  	LRESULT darkListViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool isPlugin)
1977  	{
1978  		auto lplvcd = reinterpret_cast<LPNMLVCUSTOMDRAW>(lParam);
1979  		switch (lplvcd->nmcd.dwDrawStage)
1980  		{
1981  			case CDDS_PREPAINT:
1982  			{
1983  				return CDRF_NOTIFYITEMDRAW;
1984  			}
1985  			case CDDS_ITEMPREPAINT:
1986  			{
1987  				auto isSelected = ListView_GetItemState(lplvcd->nmcd.hdr.hwndFrom, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
1988  				if (NppDarkMode::isEnabled())
1989  				{
1990  					if (isSelected)
1991  					{
1992  						lplvcd->clrText = NppDarkMode::getTextColor();
1993  						lplvcd->clrTextBk = NppDarkMode::getSofterBackgroundColor();
1994  						::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, NppDarkMode::getSofterBackgroundBrush());
1995  					}
1996  					else if ((lplvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
1997  					{
1998  						lplvcd->clrText = NppDarkMode::getTextColor();
1999  						lplvcd->clrTextBk = NppDarkMode::getHotBackgroundColor();
2000  						::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, NppDarkMode::getHotBackgroundBrush());
2001  					}
2002  				}
2003  				if (isSelected)
2004  				{
2005  					::DrawFocusRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc);
2006  				}
2007  				LRESULT lr = CDRF_DODEFAULT;
2008  				if (isPlugin)
2009  				{
2010  					lr = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
2011  				}
2012  				return lr | CDRF_NEWFONT;
2013  			}
2014  			default:
2015  				break;
2016  		}
2017  		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
2018  	}
2019  	LRESULT darkTreeViewNotifyCustomDraw(LPARAM lParam)
2020  	{
2021  		auto lptvcd = reinterpret_cast<LPNMTVCUSTOMDRAW>(lParam);
2022  		switch (lptvcd->nmcd.dwDrawStage)
2023  		{
2024  			case CDDS_PREPAINT:
2025  			{
2026  				if (NppDarkMode::isEnabled())
2027  				{
2028  					return CDRF_NOTIFYITEMDRAW;
2029  				}
2030  				return CDRF_DODEFAULT;
2031  			}
2032  			case CDDS_ITEMPREPAINT:
2033  			{
2034  				if ((lptvcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
2035  				{
2036  					lptvcd->clrText = NppDarkMode::getTextColor();
2037  					lptvcd->clrTextBk = NppDarkMode::getSofterBackgroundColor();
2038  					::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, NppDarkMode::getSofterBackgroundBrush());
2039  					return CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
2040  				}
2041  				if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
2042  				{
2043  					lptvcd->clrText = NppDarkMode::getTextColor();
2044  					lptvcd->clrTextBk = NppDarkMode::getHotBackgroundColor();
2045  					auto notifyResult =  CDRF_DODEFAULT;
2046  					if (g_isAtLeastWindows10 || g_treeViewStyle == TreeViewStyle::light)
2047  					{
2048  						::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, NppDarkMode::getHotBackgroundBrush());
2049  						notifyResult = CDRF_NOTIFYPOSTPAINT;
2050  					}
2051  					return CDRF_NEWFONT | notifyResult;
2052  				}
2053  				return CDRF_DODEFAULT;
2054  			}
2055  			case CDDS_ITEMPOSTPAINT:
2056  			{
2057  				RECT rcFrame = lptvcd->nmcd.rc;
2058  				rcFrame.left -= 1;
2059  				rcFrame.right += 1;
2060  				if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
2061  				{
2062  					NppDarkMode::paintRoundFrameRect(lptvcd->nmcd.hdc, rcFrame, NppDarkMode::getHotEdgePen(), 0, 0);
2063  				}
2064  				else if ((lptvcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
2065  				{
2066  					NppDarkMode::paintRoundFrameRect(lptvcd->nmcd.hdc, rcFrame, NppDarkMode::getEdgePen(), 0, 0);
2067  				}
2068  				return CDRF_DODEFAULT;
2069  			}
2070  			default:
2071  				return CDRF_DODEFAULT;
2072  		}
2073  	}
2074  	constexpr UINT_PTR g_pluginDockWindowSubclassID = 42;
2075  	LRESULT CALLBACK PluginDockWindowSubclass(
2076  		HWND hWnd,
2077  		UINT uMsg,
2078  		WPARAM wParam,
2079  		LPARAM lParam,
2080  		UINT_PTR uIdSubclass,
2081  		DWORD_PTR dwRefData
2082  	)
2083  	{
2084  		UNREFERENCED_PARAMETER(dwRefData);
2085  		switch (uMsg)
2086  		{
2087  			case WM_ERASEBKGND:
2088  			{
2089  				if (NppDarkMode::isEnabled())
2090  				{
2091  					RECT rect{};
2092  					GetClientRect(hWnd, &rect);
2093  					::FillRect(reinterpret_cast<HDC>(wParam), &rect, NppDarkMode::getDarkerBackgroundBrush());
2094  					return TRUE;
2095  				}
2096  				break;
2097  			}
2098  			case WM_NCDESTROY:
2099  			{
2100  				::RemoveWindowSubclass(hWnd, PluginDockWindowSubclass, uIdSubclass);
2101  				break;
2102  			}
2103  			case NPPM_INTERNAL_REFRESHDARKMODE:
2104  			{
2105  				NppDarkMode::autoThemeChildControls(hWnd);
2106  				return TRUE;
2107  			}
2108  			case WM_CTLCOLOREDIT:
2109  			{
2110  				if (NppDarkMode::isEnabled())
2111  				{
2112  					return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2113  				}
2114  				break;
2115  			}
2116  			case WM_CTLCOLORLISTBOX:
2117  			{
2118  				if (NppDarkMode::isEnabled())
2119  				{
2120  					return NppDarkMode::onCtlColorListbox(wParam, lParam);
2121  				}
2122  				break;
2123  			}
2124  			case WM_CTLCOLORDLG:
2125  			{
2126  				if (NppDarkMode::isEnabled())
2127  				{
2128  					return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2129  				}
2130  				break;
2131  			}
2132  			case WM_CTLCOLORSTATIC:
2133  			{
2134  				if (NppDarkMode::isEnabled())
2135  				{
2136  					constexpr size_t classNameLen = 16;
2137  					TCHAR className[classNameLen]{};
2138  					auto hwndEdit = reinterpret_cast<HWND>(lParam);
2139  					GetClassName(hwndEdit, className, classNameLen);
2140  					if (wcscmp(className, WC_EDIT) == 0)
2141  					{
2142  						return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
2143  					}
2144  					return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2145  				}
2146  				break;
2147  			}
2148  			case WM_PRINTCLIENT:
2149  			{
2150  				if (NppDarkMode::isEnabled())
2151  				{
2152  					return TRUE;
2153  				}
2154  				break;
2155  			}
2156  			case WM_NOTIFY:
2157  			{
2158  				const auto nmhdr = reinterpret_cast<LPNMHDR>(lParam);
2159  				switch (nmhdr->code)
2160  				{
2161  					case NM_CUSTOMDRAW:
2162  					{
2163  						constexpr size_t classNameLen = 16;
2164  						TCHAR className[classNameLen]{};
2165  						GetClassName(nmhdr->hwndFrom, className, classNameLen);
2166  						if (wcscmp(className, TOOLBARCLASSNAME) == 0)
2167  						{
2168  							return NppDarkMode::darkToolBarNotifyCustomDraw(lParam);
2169  						}
2170  						if (wcscmp(className, WC_LISTVIEW) == 0)
2171  						{
2172  							return NppDarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam, true);
2173  						}
2174  						if (wcscmp(className, WC_TREEVIEW) == 0)
2175  						{
2176  							return NppDarkMode::darkTreeViewNotifyCustomDraw(lParam);
2177  						}
2178  					}
2179  					break;
2180  				}
2181  				break;
2182  			}
2183  		}
2184  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
2185  	}
2186  	void autoSubclassAndThemePluginDockWindow(HWND hwnd)
2187  	{
2188  		SetWindowSubclass(hwnd, PluginDockWindowSubclass, g_pluginDockWindowSubclassID, 0);
2189  		NppDarkMode::autoSubclassAndThemeChildControls(hwnd, true, g_isAtLeastWindows10);
2190  	}
2191  	ULONG autoSubclassAndThemePlugin(HWND hwnd, ULONG dmFlags)
2192  	{
2193  		constexpr ULONG dmfSubclassParent =     0x00000001UL;
2194  		constexpr ULONG dmfSubclassChildren =   0x00000002UL;
2195  		constexpr ULONG dmfSetThemeChildren =   0x00000004UL;
2196  		constexpr ULONG dmfSetTitleBar =        0x00000008UL;
2197  		constexpr ULONG dmfSetThemeDirectly =   0x00000010UL;
2198  		constexpr ULONG dmfRequiredMask =       dmfSubclassParent | dmfSubclassChildren | dmfSetThemeChildren | dmfSetTitleBar | dmfSetThemeDirectly;
2199  		if (hwnd == nullptr || (dmFlags & dmfRequiredMask) == 0)
2200  		{
2201  			return 0;
2202  		}
2203  		auto dmfBitwiseCheck = [dmFlags](ULONG flag) -> bool {
2204  			return (dmFlags & flag) == flag;
2205  		};
2206  		ULONG result = 0UL;
2207  		if (dmfBitwiseCheck(dmfSubclassParent))
2208  		{
2209  			const bool success = ::SetWindowSubclass(hwnd, PluginDockWindowSubclass, g_pluginDockWindowSubclassID, 0) == TRUE;
2210  			if (success)
2211  			{
2212  				result |= dmfSubclassParent;
2213  			}
2214  		}
2215  		const bool subclassChildren = dmfBitwiseCheck(dmfSubclassChildren);
2216  		if (dmfBitwiseCheck(dmfSetThemeChildren) || subclassChildren)
2217  		{
2218  			NppDarkMode::autoSubclassAndThemeChildControls(hwnd, subclassChildren, g_isAtLeastWindows10);
2219  			result |= dmfSetThemeChildren;
2220  			if (subclassChildren)
2221  			{
2222  				result |= dmfSubclassChildren;
2223  			}
2224  		}
2225  		if (dmfBitwiseCheck(dmfSetTitleBar))
2226  		{
2227  			const auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
2228  			if (NppDarkMode::isExperimentalSupported() && ((style & WS_CAPTION) == WS_CAPTION))
2229  			{
2230  				NppDarkMode::setDarkTitleBar(hwnd);
2231  				result |= dmfSetTitleBar;
2232  			}
2233  		}
2234  		if (dmfBitwiseCheck(dmfSetThemeDirectly))
2235  		{
2236  			if (NppDarkMode::isWindows10())
2237  			{
2238  				NppDarkMode::setDarkExplorerTheme(hwnd);
2239  				result |= dmfSetThemeDirectly;
2240  			}
2241  		}
2242  		return result;
2243  	}
2244  	constexpr UINT_PTR g_windowNotifySubclassID = 42;
2245  	LRESULT CALLBACK WindowNotifySubclass(
2246  		HWND hWnd,
2247  		UINT uMsg,
2248  		WPARAM wParam,
2249  		LPARAM lParam,
2250  		UINT_PTR uIdSubclass,
2251  		DWORD_PTR dwRefData
2252  	)
2253  	{
2254  		UNREFERENCED_PARAMETER(dwRefData);
2255  		switch (uMsg)
2256  		{
2257  			case WM_NCDESTROY:
2258  			{
2259  				::RemoveWindowSubclass(hWnd, WindowNotifySubclass, uIdSubclass);
2260  				break;
2261  			}
2262  			case WM_NOTIFY:
2263  			{
2264  				auto nmhdr = reinterpret_cast<LPNMHDR>(lParam);
2265  				constexpr size_t classNameLen = 16;
2266  				TCHAR className[classNameLen]{};
2267  				GetClassName(nmhdr->hwndFrom, className, classNameLen);
2268  				switch (nmhdr->code)
2269  				{
2270  					case NM_CUSTOMDRAW:
2271  					{
2272  						if (wcscmp(className, TOOLBARCLASSNAME) == 0)
2273  						{
2274  							return NppDarkMode::darkToolBarNotifyCustomDraw(lParam);
2275  						}
2276  						if (wcscmp(className, WC_LISTVIEW) == 0)
2277  						{
2278  							return NppDarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam, false);
2279  						}
2280  						if (wcscmp(className, WC_TREEVIEW) == 0)
2281  						{
2282  							return NppDarkMode::darkTreeViewNotifyCustomDraw(lParam);
2283  						}
2284  					}
2285  					break;
2286  				}
2287  				break;
2288  			}
2289  		}
2290  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
2291  	}
2292  	void autoSubclassAndThemeWindowNotify(HWND hwnd)
2293  	{
2294  		SetWindowSubclass(hwnd, WindowNotifySubclass, g_windowNotifySubclassID, 0);
2295  	}
2296  	void setDarkTitleBar(HWND hwnd)
2297  	{
2298  		constexpr DWORD win10Build2004 = 19041;
2299  		if (NppDarkMode::getWindowsBuildNumber() >= win10Build2004)
2300  		{
2301  			BOOL value = NppDarkMode::isEnabled() ? TRUE : FALSE;
2302  			::DwmSetWindowAttribute(hwnd, DWMWA_USE_IMMERSIVE_DARK_MODE, &value, sizeof(value));
2303  		}
2304  		else
2305  		{
2306  			NppDarkMode::allowDarkModeForWindow(hwnd, NppDarkMode::isEnabled());
2307  			NppDarkMode::setTitleBarThemeColor(hwnd);
2308  		}
2309  	}
2310  	void setDarkExplorerTheme(HWND hwnd)
2311  	{
2312  		SetWindowTheme(hwnd, g_isAtLeastWindows10 && NppDarkMode::isEnabled() ? L"DarkMode_Explorer" : nullptr, nullptr);
2313  	}
2314  	void setDarkScrollBar(HWND hwnd)
2315  	{
2316  		NppDarkMode::setDarkExplorerTheme(hwnd);
2317  	}
2318  	void setDarkTooltips(HWND hwnd, ToolTipsType type)
2319  	{
2320  		UINT msg = 0;
2321  		switch (type)
2322  		{
2323  			case NppDarkMode::ToolTipsType::toolbar:
2324  				msg = TB_GETTOOLTIPS;
2325  				break;
2326  			case NppDarkMode::ToolTipsType::listview:
2327  				msg = LVM_GETTOOLTIPS;
2328  				break;
2329  			case NppDarkMode::ToolTipsType::treeview:
2330  				msg = TVM_GETTOOLTIPS;
2331  				break;
2332  			case NppDarkMode::ToolTipsType::tabbar:
2333  				msg = TCM_GETTOOLTIPS;
2334  				break;
2335  			default:
2336  				msg = 0;
2337  				break;
2338  		}
2339  		if (msg == 0)
2340  		{
2341  			NppDarkMode::setDarkExplorerTheme(hwnd);
2342  		}
2343  		else
2344  		{
2345  			auto hTips = reinterpret_cast<HWND>(::SendMessage(hwnd, msg, 0, 0));
2346  			if (hTips != nullptr)
2347  			{
2348  				NppDarkMode::setDarkExplorerTheme(hTips);
2349  			}
2350  		}
2351  	}
2352  	void setDarkLineAbovePanelToolbar(HWND hwnd)
2353  	{
2354  		COLORSCHEME scheme{};
2355  		scheme.dwSize = sizeof(COLORSCHEME);
2356  		if (NppDarkMode::isEnabled())
2357  		{
2358  			scheme.clrBtnHighlight = NppDarkMode::getDarkerBackgroundColor();
2359  			scheme.clrBtnShadow = NppDarkMode::getDarkerBackgroundColor();
2360  		}
2361  		else
2362  		{
2363  			scheme.clrBtnHighlight = CLR_DEFAULT;
2364  			scheme.clrBtnShadow = CLR_DEFAULT;
2365  		}
2366  		::SendMessage(hwnd, TB_SETCOLORSCHEME, 0, reinterpret_cast<LPARAM>(&scheme));
2367  	}
2368  	void setDarkListView(HWND hwnd)
2369  	{
2370  		if (NppDarkMode::isExperimentalSupported())
2371  		{
2372  			bool useDark = NppDarkMode::isEnabled();
2373  			HWND hHeader = ListView_GetHeader(hwnd);
2374  			NppDarkMode::allowDarkModeForWindow(hHeader, useDark);
2375  			SetWindowTheme(hHeader, useDark ? L"ItemsView" : nullptr, nullptr);
2376  			NppDarkMode::allowDarkModeForWindow(hwnd, useDark);
2377  			SetWindowTheme(hwnd, L"Explorer", nullptr);
2378  		}
2379  	}
2380  	void disableVisualStyle(HWND hwnd, bool doDisable)
2381  	{
2382  		if (doDisable)
2383  		{
2384  			SetWindowTheme(hwnd, L"", L"");
2385  		}
2386  		else
2387  		{
2388  			SetWindowTheme(hwnd, nullptr, nullptr);
2389  		}
2390  	}
2391  	constexpr double g_middleGrayRange = 2.0;
2392  	void calculateTreeViewStyle()
2393  	{
2394  		COLORREF bgColor = NppParameters::getInstance().getCurrentDefaultBgColor();
2395  		if (g_treeViewBg != bgColor || g_lighnessTreeView == 50.0)
2396  		{
2397  			g_lighnessTreeView = calculatePerceivedLighness(bgColor);
2398  			g_treeViewBg = bgColor;
2399  		}
2400  		if (g_lighnessTreeView < (50.0 - g_middleGrayRange))
2401  		{
2402  			g_treeViewStyle = TreeViewStyle::dark;
2403  		}
2404  		else if (g_lighnessTreeView > (50.0 + g_middleGrayRange))
2405  		{
2406  			g_treeViewStyle = TreeViewStyle::light;
2407  		}
2408  		else
2409  		{
2410  			g_treeViewStyle = TreeViewStyle::classic;
2411  		}
2412  	}
2413  	void setTreeViewStyle(HWND hwnd)
2414  	{
2415  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
2416  		bool hasHotStyle = (style & TVS_TRACKSELECT) == TVS_TRACKSELECT;
2417  		bool change = false;
2418  		switch (g_treeViewStyle)
2419  		{
2420  			case TreeViewStyle::light:
2421  			{
2422  				if (!hasHotStyle)
2423  				{
2424  					style |= TVS_TRACKSELECT;
2425  					change = true;
2426  				}
2427  				SetWindowTheme(hwnd, L"Explorer", nullptr);
2428  				break;
2429  			}
2430  			case TreeViewStyle::dark:
2431  			{
2432  				if (!hasHotStyle)
2433  				{
2434  					style |= TVS_TRACKSELECT;
2435  					change = true;
2436  				}
2437  				SetWindowTheme(hwnd, g_isAtLeastWindows10 ? L"DarkMode_Explorer" : nullptr, nullptr);
2438  				break;
2439  			}
2440  			default:
2441  			{
2442  				if (hasHotStyle)
2443  				{
2444  					style &= ~TVS_TRACKSELECT;
2445  					change = true;
2446  				}
2447  				SetWindowTheme(hwnd, nullptr, nullptr);
2448  				break;
2449  			}
2450  		}
2451  		if (change)
2452  		{
2453  			::SetWindowLongPtr(hwnd, GWL_STYLE, style);
2454  		}
2455  	}
2456  	bool isThemeDark()
2457  	{
2458  		return g_treeViewStyle == TreeViewStyle::dark;
2459  	}
2460  	void setBorder(HWND hwnd, bool border)
2461  	{
2462  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
2463  		bool hasBorder = (style & WS_BORDER) == WS_BORDER;
2464  		bool change = false;
2465  		if (!hasBorder && border)
2466  		{
2467  			style |= WS_BORDER;
2468  			change = true;
2469  		}
2470  		else if (hasBorder && !border)
2471  		{
2472  			style &= ~WS_BORDER;
2473  			change = true;
2474  		}
2475  		if (change)
2476  		{
2477  			::SetWindowLongPtr(hwnd, GWL_STYLE, style);
2478  			::SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
2479  		}
2480  	}
2481  	BOOL CALLBACK enumAutocompleteProc(HWND hwnd, LPARAM &bsol;*lParam*/)
2482  	{
2483  		constexpr size_t classNameLen = 16;
2484  		TCHAR className[classNameLen]{};
2485  		GetClassName(hwnd, className, classNameLen);
2486  		if ((wcscmp(className, L"ListBoxX") == 0))
2487  		{
2488  			NppDarkMode::setDarkTitleBar(hwnd);
2489  			NppDarkMode::autoThemeChildControls(hwnd);
2490  			return FALSE;
2491  		}
2492  		return TRUE;
2493  	}
2494  	void setDarkAutoCompletion()
2495  	{
2496  		::EnumThreadWindows(::GetCurrentThreadId(), (WNDENUMPROC)enumAutocompleteProc, 0);
2497  	}
2498  	LRESULT onCtlColor(HDC hdc)
2499  	{
2500  		if (!NppDarkMode::isEnabled())
2501  		{
2502  			return FALSE;
2503  		}
2504  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2505  		::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
2506  		return reinterpret_cast<LRESULT>(NppDarkMode::getBackgroundBrush());
2507  	}
2508  	LRESULT onCtlColorSofter(HDC hdc)
2509  	{
2510  		if (!NppDarkMode::isEnabled())
2511  		{
2512  			return FALSE;
2513  		}
2514  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2515  		::SetBkColor(hdc, NppDarkMode::getSofterBackgroundColor());
2516  		return reinterpret_cast<LRESULT>(NppDarkMode::getSofterBackgroundBrush());
2517  	}
2518  	LRESULT onCtlColorDarker(HDC hdc)
2519  	{
2520  		if (!NppDarkMode::isEnabled())
2521  		{
2522  			return FALSE;
2523  		}
2524  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2525  		::SetBkColor(hdc, NppDarkMode::getDarkerBackgroundColor());
2526  		return reinterpret_cast<LRESULT>(NppDarkMode::getDarkerBackgroundBrush());
2527  	}
2528  	LRESULT onCtlColorError(HDC hdc)
2529  	{
2530  		if (!NppDarkMode::isEnabled())
2531  		{
2532  			return FALSE;
2533  		}
2534  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2535  		::SetBkColor(hdc, NppDarkMode::getErrorBackgroundColor());
2536  		return reinterpret_cast<LRESULT>(NppDarkMode::getErrorBackgroundBrush());
2537  	}
2538  	LRESULT onCtlColorDarkerBGStaticText(HDC hdc, bool isTextEnabled)
2539  	{
2540  		if (!NppDarkMode::isEnabled())
2541  		{
2542  			::SetTextColor(hdc, ::GetSysColor(isTextEnabled ? COLOR_WINDOWTEXT : COLOR_GRAYTEXT));
2543  			return FALSE;
2544  		}
2545  		::SetTextColor(hdc, isTextEnabled ? NppDarkMode::getTextColor() : NppDarkMode::getDisabledTextColor());
2546  		::SetBkColor(hdc, NppDarkMode::getDarkerBackgroundColor());
2547  		return reinterpret_cast<LRESULT>(NppDarkMode::getDarkerBackgroundBrush());
2548  	}
2549  	INT_PTR onCtlColorListbox(WPARAM wParam, LPARAM lParam)
2550  	{
2551  		auto hdc = reinterpret_cast<HDC>(wParam);
2552  		auto hwnd = reinterpret_cast<HWND>(lParam);
2553  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
2554  		bool isComboBox = (style & LBS_COMBOBOX) == LBS_COMBOBOX;
2555  		if (!isComboBox && ::IsWindowEnabled(hwnd))
2556  		{
2557  			return static_cast<INT_PTR>(NppDarkMode::onCtlColorSofter(hdc));
2558  		}
2559  		return static_cast<INT_PTR>(NppDarkMode::onCtlColor(hdc));
2560  	}
2561  	struct HLSColour
2562  	{
2563  		WORD _hue;
2564  		WORD _lightness;
2565  		WORD _saturation;
2566  		COLORREF toRGB() const { return ColorHLSToRGB(_hue, _lightness, _saturation); }
2567  	};
2568  	using IndividualTabColours = std::array<HLSColour, 5>;
2569  	static constexpr IndividualTabColours individualTabHuesFor_Dark  { { HLSColour{37, 60, 60}, HLSColour{70, 60, 60}, HLSColour{144, 70, 60}, HLSColour{255, 60, 60}, HLSColour{195, 60, 60} } };
2570  	static constexpr IndividualTabColours individualTabHues          { { HLSColour{37, 210, 150}, HLSColour{70, 210, 150}, HLSColour{144, 210, 150}, HLSColour{255, 210, 150}, HLSColour{195, 210, 150}}};
2571  	COLORREF getIndividualTabColour(int colourIndex, bool themeDependant, bool saturated)
2572  	{
2573  		if (colourIndex < 0 || colourIndex > 4) return {};
2574  		HLSColour result;
2575  		if (themeDependant)
2576  		{
2577  			result = individualTabHuesFor_Dark[colourIndex];
2578  			if (saturated)
2579  			{
2580  				result._lightness = 146U;
2581  				result._saturation = std::min<WORD>(240U, result._saturation + 100U);
2582  			}
2583  		}
2584  		else
2585  		{
2586  			result = individualTabHues[colourIndex];
2587  			if (saturated)
2588  			{
2589  				result._lightness = 140U;
2590  				result._saturation = std::min<WORD>(240U, result._saturation + 30U);
2591  			}
2592  		}
2593  		return result.toRGB();
2594  	}
2595  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppDarkMode.cpp</h3>
            <pre><code>1  #include "NppDarkMode.h"
2  #include "DarkMode/DarkMode.h"
3  #include "DarkMode/UAHMenuBar.h"
4  #include <dwmapi.h>
5  #include <uxtheme.h>
6  #include <vssym32.h>
7  #include "Parameters.h"
8  #include "resource.h"
9  #include <shlwapi.h>
10  #include <array>
11  #ifdef __GNUC__
12  #include <cmath>
13  #define WINAPI_LAMBDA WINAPI
14  #ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
15  #define DWMWA_USE_IMMERSIVE_DARK_MODE 20
16  #endif
17  #else
18  #define WINAPI_LAMBDA
19  #endif
20  constexpr COLORREF HEXRGB(DWORD rrggbb) {
21  	return
22  		((rrggbb & 0xFF0000) >> 16) |
23  		((rrggbb & 0x00FF00)) |
24  		((rrggbb & 0x0000FF) << 16);
25  }
26  namespace NppDarkMode
27  {
28  	struct Brushes
29  	{
30  		HBRUSH background = nullptr;
31  		HBRUSH softerBackground = nullptr;
32  		HBRUSH hotBackground = nullptr;
33  		HBRUSH pureBackground = nullptr;
34  		HBRUSH errorBackground = nullptr;
35  		HBRUSH edgeBrush = nullptr;
36  		HBRUSH hotEdgeBrush = nullptr;
37  		HBRUSH disabledEdgeBrush = nullptr;
38  		Brushes(const Colors& colors)
39  			: background(::CreateSolidBrush(colors.background))
40  			, softerBackground(::CreateSolidBrush(colors.softerBackground))
41  			, hotBackground(::CreateSolidBrush(colors.hotBackground))
42  			, pureBackground(::CreateSolidBrush(colors.pureBackground))
43  			, errorBackground(::CreateSolidBrush(colors.errorBackground))
44  			, edgeBrush(::CreateSolidBrush(colors.edge))
45  			, hotEdgeBrush(::CreateSolidBrush(colors.hotEdge))
46  			, disabledEdgeBrush(::CreateSolidBrush(colors.disabledEdge))
47  		{}
48  		~Brushes()
49  		{
50  			::DeleteObject(background);			background = nullptr;
51  			::DeleteObject(softerBackground);	softerBackground = nullptr;
52  			::DeleteObject(hotBackground);		hotBackground = nullptr;
53  			::DeleteObject(pureBackground);		pureBackground = nullptr;
54  			::DeleteObject(errorBackground);	errorBackground = nullptr;
55  			::DeleteObject(edgeBrush);			edgeBrush = nullptr;
56  			::DeleteObject(hotEdgeBrush);		hotEdgeBrush = nullptr;
57  			::DeleteObject(disabledEdgeBrush);	disabledEdgeBrush = nullptr;
58  		}
59  		void change(const Colors& colors)
60  		{
61  			::DeleteObject(background);
62  			::DeleteObject(softerBackground);
63  			::DeleteObject(hotBackground);
64  			::DeleteObject(pureBackground);
65  			::DeleteObject(errorBackground);
66  			::DeleteObject(edgeBrush);
67  			::DeleteObject(hotEdgeBrush);
68  			::DeleteObject(disabledEdgeBrush);
69  			background = ::CreateSolidBrush(colors.background);
70  			softerBackground = ::CreateSolidBrush(colors.softerBackground);
71  			hotBackground = ::CreateSolidBrush(colors.hotBackground);
72  			pureBackground = ::CreateSolidBrush(colors.pureBackground);
73  			errorBackground = ::CreateSolidBrush(colors.errorBackground);
74  			edgeBrush = ::CreateSolidBrush(colors.edge);
75  			hotEdgeBrush = ::CreateSolidBrush(colors.hotEdge);
76  			disabledEdgeBrush = ::CreateSolidBrush(colors.disabledEdge);
77  		}
78  	};
79  	struct Pens
80  	{
81  		HPEN darkerTextPen = nullptr;
82  		HPEN edgePen = nullptr;
83  		HPEN hotEdgePen = nullptr;
84  		HPEN disabledEdgePen = nullptr;
85  		Pens(const Colors& colors)
86  			: darkerTextPen(::CreatePen(PS_SOLID, 1, colors.darkerText))
87  			, edgePen(::CreatePen(PS_SOLID, 1, colors.edge))
88  			, hotEdgePen(::CreatePen(PS_SOLID, 1, colors.hotEdge))
89  			, disabledEdgePen(::CreatePen(PS_SOLID, 1, colors.disabledEdge))
90  		{}
91  		~Pens()
92  		{
93  			::DeleteObject(darkerTextPen);		darkerTextPen = nullptr;
94  			::DeleteObject(edgePen);			edgePen = nullptr;
95  			::DeleteObject(hotEdgePen);			hotEdgePen = nullptr;
96  			::DeleteObject(disabledEdgePen);	disabledEdgePen = nullptr;
97  		}
98  		void change(const Colors& colors)
99  		{
100  			::DeleteObject(darkerTextPen);
101  			::DeleteObject(edgePen);
102  			::DeleteObject(hotEdgePen);
103  			::DeleteObject(disabledEdgePen);
104  			darkerTextPen = ::CreatePen(PS_SOLID, 1, colors.darkerText);
105  			edgePen = ::CreatePen(PS_SOLID, 1, colors.edge);
106  			hotEdgePen = ::CreatePen(PS_SOLID, 1, colors.hotEdge);
107  			disabledEdgePen = ::CreatePen(PS_SOLID, 1, colors.disabledEdge);
108  		}
109  	};
110  	static const Colors darkColors{
111  		HEXRGB(0x202020),	
112  		HEXRGB(0x404040),	
113  		HEXRGB(0x404040),	
114  		HEXRGB(0x202020),	
115  		HEXRGB(0xB00000),	
116  		HEXRGB(0xE0E0E0),	
117  		HEXRGB(0xC0C0C0),	
118  		HEXRGB(0x808080),	
119  		HEXRGB(0xFFFF00),	
120  		HEXRGB(0x646464),	
121  		HEXRGB(0x9B9B9B),	
122  		HEXRGB(0x484848)	
123  	};
124  	static const Colors darkRedColors{
125  		HEXRGB(0x302020),	
126  		HEXRGB(0x504040),	
127  		HEXRGB(0x504040),	
128  		HEXRGB(0x302020),	
129  		HEXRGB(0xC00000),	
130  		HEXRGB(0xE0E0E0),	
131  		HEXRGB(0xC0C0C0),	
132  		HEXRGB(0x808080),	
133  		HEXRGB(0xFFFF00),	
134  		HEXRGB(0x908080),	
135  		HEXRGB(0xBBABAB),	
136  		HEXRGB(0x584848)	
137  	};
138  	static const Colors darkGreenColors{
139  		HEXRGB(0x203020),	
140  		HEXRGB(0x405040),	
141  		HEXRGB(0x405040),	
142  		HEXRGB(0x203020),	
143  		HEXRGB(0xB01000),	
144  		HEXRGB(0xE0E0E0),	
145  		HEXRGB(0xC0C0C0),	
146  		HEXRGB(0x808080),	
147  		HEXRGB(0xFFFF00),	
148  		HEXRGB(0x809080),	
149  		HEXRGB(0xABBBAB),	
150  		HEXRGB(0x485848)	
151  	};
152  	static const Colors darkBlueColors{
153  		HEXRGB(0x202040),	
154  		HEXRGB(0x404060),	
155  		HEXRGB(0x404060),	
156  		HEXRGB(0x202040),	
157  		HEXRGB(0xB00020),	
158  		HEXRGB(0xE0E0E0),	
159  		HEXRGB(0xC0C0C0),	
160  		HEXRGB(0x808080),	
161  		HEXRGB(0xFFFF00),	
162  		HEXRGB(0x8080A0),	
163  		HEXRGB(0xABABCB),	
164  		HEXRGB(0x484868)	
165  	};
166  	static const Colors darkPurpleColors{
167  		HEXRGB(0x302040),	
168  		HEXRGB(0x504060),	
169  		HEXRGB(0x504060),	
170  		HEXRGB(0x302040),	
171  		HEXRGB(0xC00020),	
172  		HEXRGB(0xE0E0E0),	
173  		HEXRGB(0xC0C0C0),	
174  		HEXRGB(0x808080),	
175  		HEXRGB(0xFFFF00),	
176  		HEXRGB(0x9080A0),	
177  		HEXRGB(0xBBABCB),	
178  		HEXRGB(0x584868)	
179  	};
180  	static const Colors darkCyanColors{
181  		HEXRGB(0x203040),	
182  		HEXRGB(0x405060),	
183  		HEXRGB(0x405060),	
184  		HEXRGB(0x203040),	
185  		HEXRGB(0xB01020),	
186  		HEXRGB(0xE0E0E0),	
187  		HEXRGB(0xC0C0C0),	
188  		HEXRGB(0x808080),	
189  		HEXRGB(0xFFFF00),	
190  		HEXRGB(0x8090A0),	
191  		HEXRGB(0xBBBBCB),	
192  		HEXRGB(0x485868)	
193  	};
194  	static const Colors darkOliveColors{
195  		HEXRGB(0x303020),	
196  		HEXRGB(0x505040),	
197  		HEXRGB(0x505040),	
198  		HEXRGB(0x303020),	
199  		HEXRGB(0xC01000),	
200  		HEXRGB(0xE0E0E0),	
201  		HEXRGB(0xC0C0C0),	
202  		HEXRGB(0x808080),	
203  		HEXRGB(0xFFFF00),	
204  		HEXRGB(0x909080),	
205  		HEXRGB(0xBBBBAB),	
206  		HEXRGB(0x585848)	
207  	};
208  	Colors darkCustomizedColors{
209  		HEXRGB(0x202020),	
210  		HEXRGB(0x404040),	
211  		HEXRGB(0x404040),	
212  		HEXRGB(0x202020),	
213  		HEXRGB(0xB00000),	
214  		HEXRGB(0xE0E0E0),	
215  		HEXRGB(0xC0C0C0),	
216  		HEXRGB(0x808080),	
217  		HEXRGB(0xFFFF00),	
218  		HEXRGB(0x646464),	
219  		HEXRGB(0x9B9B9B),	
220  		HEXRGB(0x484848)	
221  	};
222  	ColorTone g_colorToneChoice = blackTone;
223  	void setDarkTone(ColorTone colorToneChoice)
224  	{
225  		g_colorToneChoice = colorToneChoice;
226  	}
227  	struct Theme
228  	{
229  		Colors _colors;
230  		Brushes _brushes;
231  		Pens _pens;
232  		Theme(const Colors& colors)
233  			: _colors(colors)
234  			, _brushes(colors)
235  			, _pens(colors)
236  		{}
237  		void change(const Colors& colors)
238  		{
239  			_colors = colors;
240  			_brushes.change(colors);
241  			_pens.change(colors);
242  		}
243  	};
244  	Theme tDefault(darkColors);
245  	Theme tR(darkRedColors);
246  	Theme tG(darkGreenColors);
247  	Theme tB(darkBlueColors);
248  	Theme tP(darkPurpleColors);
249  	Theme tC(darkCyanColors);
250  	Theme tO(darkOliveColors);
251  	Theme tCustom(darkCustomizedColors);
252  	Theme& getTheme()
253  	{
254  		switch (g_colorToneChoice)
255  		{
256  			case redTone:
257  				return tR;
258  			case greenTone:
259  				return tG;
260  			case blueTone:
261  				return tB;
262  			case purpleTone:
263  				return tP;
264  			case cyanTone:
265  				return tC;
266  			case oliveTone:
267  				return tO;
268  			case customizedTone:
269  				return tCustom;
270  			default:
271  				return tDefault;
272  		}
273  	}
274  	static Options _options;			
275  	static AdvancedOptions g_advOptions;
276  	Options configuredOptions()
277  	{
278  		NppGUI nppGui = NppParameters::getInstance().getNppGUI();
279  		Options opt;
280  		opt.enable = nppGui._darkmode._isEnabled;
281  		opt.enableMenubar = opt.enable;
282  		opt.enablePlugin = nppGui._darkmode._isEnabledPlugin;
283  		g_colorToneChoice = nppGui._darkmode._colorTone;
284  		tCustom.change(nppGui._darkmode._customColors);
285  		return opt;
286  	}
287  	static bool g_isAtLeastWindows10 = false;
288  	static bool g_isWine = false;
289  	void initDarkMode()
290  	{
291  		_options = configuredOptions();
292  		initExperimentalDarkMode();
293  		initAdvancedOptions();
294  		g_isAtLeastWindows10 = NppDarkMode::isWindows10();
295  		if (!g_isAtLeastWindows10)
296  		{
297  			g_advOptions._enableWindowsMode = false;
298  		}
299  		else if (NppDarkMode::isWindowsModeEnabled())
300  		{
301  			NppParameters& nppParam = NppParameters::getInstance();
302  			NppGUI& nppGUI = nppParam.getNppGUI();
303  			nppGUI._darkmode._isEnabled = NppDarkMode::isDarkModeReg() && !IsHighContrast();
304  			_options.enable = nppGUI._darkmode._isEnabled;
305  			_options.enableMenubar = _options.enable;
306  		}
307  		setDarkMode(_options.enable, true);
308  		using PWINEGETVERSION = const CHAR* (__cdecl *)(void);
309  		PWINEGETVERSION pWGV = nullptr;
310  		auto hNtdllModule = GetModuleHandle(L"ntdll.dll");
311  		if (hNtdllModule)
312  		{
313  			pWGV = reinterpret_cast<PWINEGETVERSION>(GetProcAddress(hNtdllModule, "wine_get_version"));
314  		}
315  		g_isWine = pWGV != nullptr;
316  	}
317  	void refreshDarkMode(HWND hwnd, bool forceRefresh)
318  	{
319  		bool supportedChanged = false;
320  		auto config = configuredOptions();
321  		if (_options.enable != config.enable)
322  		{
323  			supportedChanged = true;
324  			_options.enable = config.enable;
325  			setDarkMode(_options.enable, _options.enable);
326  		}
327  		if (_options.enableMenubar != config.enableMenubar)
328  		{
329  			supportedChanged = true;
330  			_options.enableMenubar = config.enableMenubar;
331  		}
332  		if (!supportedChanged && !forceRefresh)
333  		{
334  			return;
335  		}
336  		HWND hwndRoot = GetAncestor(hwnd, GA_ROOTOWNER);
337  		::SendMessage(hwndRoot, NPPM_INTERNAL_REFRESHDARKMODE, static_cast<WPARAM>(!forceRefresh), 0);
338  	}
339  	void initAdvancedOptions()
340  	{
341  		NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
342  		g_advOptions = nppGui._darkmode._advOptions;
343  	}
344  	bool isEnabled()
345  	{
346  		return _options.enable;
347  	}
348  	bool isEnabledForPlugins()
349  	{
350  		return _options.enablePlugin;
351  	}
352  	bool isDarkMenuEnabled()
353  	{
354  		return _options.enableMenubar;
355  	}
356  	bool isExperimentalActive()
357  	{
358  		return g_darkModeEnabled;
359  	}
360  	bool isExperimentalSupported()
361  	{
362  		return g_darkModeSupported;
363  	}
364  	bool isWindowsModeEnabled()
365  	{
366  		return g_advOptions._enableWindowsMode;
367  	}
368  	void setWindowsMode(bool enable)
369  	{
370  		g_advOptions._enableWindowsMode = enable;
371  	}
372  	void setThemeName(const generic_string& newThemeName)
373  	{
374  		if (NppDarkMode::isEnabled())
375  			g_advOptions._darkDefaults._xmlFileName = newThemeName;
376  		else
377  			g_advOptions._lightDefaults._xmlFileName = newThemeName;
378  	}
379  	generic_string getThemeName()
380  	{
381  		auto& theme = NppDarkMode::isEnabled() ? g_advOptions._darkDefaults._xmlFileName : g_advOptions._lightDefaults._xmlFileName;
382  		return (lstrcmp(theme.c_str(), L"stylers.xml") == 0) ? L"" : theme;
383  	}
384  	static bool g_isCustomToolIconUsed = NppParameters::getInstance().getCustomizedToolIcons() != nullptr;
385  	void setToolBarIconSet(int state2Set, bool useDark)
386  	{
387  		if (useDark)
388  			g_advOptions._darkDefaults._toolBarIconSet = state2Set;
389  		else
390  			g_advOptions._lightDefaults._toolBarIconSet = state2Set;
391  	}
392  	int getToolBarIconSet(bool useDark)
393  	{
394  		if (g_isCustomToolIconUsed)
395  		{
396  			return -1;
397  		}
398  		return useDark ? g_advOptions._darkDefaults._toolBarIconSet : g_advOptions._lightDefaults._toolBarIconSet;
399  	}
400  	void setTabIconSet(bool useAltIcons, bool useDark)
401  	{
402  		if (useDark)
403  			g_advOptions._darkDefaults._tabIconSet = useAltIcons ? 1 : 2;
404  		else	
405  			g_advOptions._lightDefaults._tabIconSet = useAltIcons ? 1 : 0;
406  	}
407  	int getTabIconSet(bool useDark)
408  	{
409  		return useDark ? g_advOptions._darkDefaults._tabIconSet : g_advOptions._lightDefaults._tabIconSet;
410  	}
411  	bool useTabTheme()
412  	{
413  		return NppDarkMode::isEnabled() ? g_advOptions._darkDefaults._tabUseTheme : g_advOptions._lightDefaults._tabUseTheme;
414  	}
415  	void setAdvancedOptions()
416  	{
417  		NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
418  		auto& advOpt = nppGui._darkmode._advOptions;
419  		advOpt = g_advOptions;
420  	}
421  	bool isWindows10()
422  	{
423  		return IsWindows10();
424  	}
425  	bool isWindows11()
426  	{
427  		return IsWindows11();
428  	}
429  	DWORD getWindowsBuildNumber()
430  	{
431  		return GetWindowsBuildNumber();
432  	}
433  	COLORREF invertLightness(COLORREF c)
434  	{
435  		WORD h = 0;
436  		WORD s = 0;
437  		WORD l = 0;
438  		ColorRGBToHLS(c, &h, &l, &s);
439  		l = 240 - l;
440  		COLORREF invert_c = ColorHLSToRGB(h, l, s);
441  		return invert_c;
442  	}
443  	COLORREF invertLightnessSofter(COLORREF c)
444  	{
445  		WORD h = 0;
446  		WORD s = 0;
447  		WORD l = 0;
448  		ColorRGBToHLS(c, &h, &l, &s);
449  		l = std::min<WORD>(240U - l, 211U);
450  		COLORREF invert_c = ColorHLSToRGB(h, l, s);
451  		return invert_c;
452  	}
453  	static TreeViewStyle g_treeViewStyle = TreeViewStyle::classic;
454  	static COLORREF g_treeViewBg = NppParameters::getInstance().getCurrentDefaultBgColor();
455  	static double g_lighnessTreeView = 50.0;
456  	double calculatePerceivedLighness(COLORREF c)
457  	{
458  		auto linearValue = [](double colorChannel) -> double
459  		{
460  			colorChannel /= 255.0;
461  			if (colorChannel <= 0.04045)
462  				return colorChannel / 12.92;
463  			return std::pow(((colorChannel + 0.055) / 1.055), 2.4);
464  		};
465  		double r = linearValue(static_cast<double>(GetRValue(c)));
466  		double g = linearValue(static_cast<double>(GetGValue(c)));
467  		double b = linearValue(static_cast<double>(GetBValue(c)));
468  		double luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
469  		double lighness = (luminance <= 216.0 / 24389.0) ? (luminance * 24389.0 / 27.0) : (std::pow(luminance, (1.0 / 3.0)) * 116.0 - 16.0);
470  		return lighness;
471  	}
472  	COLORREF getBackgroundColor()         { return getTheme()._colors.background; }
473  	COLORREF getSofterBackgroundColor()   { return getTheme()._colors.softerBackground; }
474  	COLORREF getHotBackgroundColor()      { return getTheme()._colors.hotBackground; }
475  	COLORREF getDarkerBackgroundColor()   { return getTheme()._colors.pureBackground; }
476  	COLORREF getErrorBackgroundColor()    { return getTheme()._colors.errorBackground; }
477  	COLORREF getTextColor()               { return getTheme()._colors.text; }
478  	COLORREF getDarkerTextColor()         { return getTheme()._colors.darkerText; }
479  	COLORREF getDisabledTextColor()       { return getTheme()._colors.disabledText; }
480  	COLORREF getLinkTextColor()           { return getTheme()._colors.linkText; }
481  	COLORREF getEdgeColor()               { return getTheme()._colors.edge; }
482  	COLORREF getHotEdgeColor()            { return getTheme()._colors.hotEdge; }
483  	COLORREF getDisabledEdgeColor()       { return getTheme()._colors.disabledEdge; }
484  	HBRUSH getBackgroundBrush()           { return getTheme()._brushes.background; }
485  	HBRUSH getSofterBackgroundBrush()     { return getTheme()._brushes.softerBackground; }
486  	HBRUSH getHotBackgroundBrush()        { return getTheme()._brushes.hotBackground; }
487  	HBRUSH getDarkerBackgroundBrush()     { return getTheme()._brushes.pureBackground; }
488  	HBRUSH getErrorBackgroundBrush()      { return getTheme()._brushes.errorBackground; }
489  	HBRUSH getEdgeBrush()                 { return getTheme()._brushes.edgeBrush; }
490  	HBRUSH getHotEdgeBrush()              { return getTheme()._brushes.hotEdgeBrush; }
491  	HBRUSH getDisabledEdgeBrush()         { return getTheme()._brushes.disabledEdgeBrush; }
492  	HPEN getDarkerTextPen()               { return getTheme()._pens.darkerTextPen; }
493  	HPEN getEdgePen()                     { return getTheme()._pens.edgePen; }
494  	HPEN getHotEdgePen()                  { return getTheme()._pens.hotEdgePen; }
495  	HPEN getDisabledEdgePen()             { return getTheme()._pens.disabledEdgePen; }
496  	void setBackgroundColor(COLORREF c)
497  	{
498  		Colors clrs = getTheme()._colors;
499  		clrs.background = c;
500  		getTheme().change(clrs);
501  	}
502  	void setSofterBackgroundColor(COLORREF c)
503  	{
504  		Colors clrs = getTheme()._colors;
505  		clrs.softerBackground = c;
506  		getTheme().change(clrs);
507  	}
508  	void setHotBackgroundColor(COLORREF c)
509  	{
510  		Colors clrs = getTheme()._colors;
511  		clrs.hotBackground = c;
512  		getTheme().change(clrs);
513  	}
514  	void setDarkerBackgroundColor(COLORREF c)
515  	{
516  		Colors clrs = getTheme()._colors;
517  		clrs.pureBackground = c;
518  		getTheme().change(clrs);
519  	}
520  	void setErrorBackgroundColor(COLORREF c)
521  	{
522  		Colors clrs = getTheme()._colors;
523  		clrs.errorBackground = c;
524  		getTheme().change(clrs);
525  	}
526  	void setTextColor(COLORREF c)
527  	{
528  		Colors clrs = getTheme()._colors;
529  		clrs.text = c;
530  		getTheme().change(clrs);
531  	}
532  	void setDarkerTextColor(COLORREF c)
533  	{
534  		Colors clrs = getTheme()._colors;
535  		clrs.darkerText = c;
536  		getTheme().change(clrs);
537  	}
538  	void setDisabledTextColor(COLORREF c)
539  	{
540  		Colors clrs = getTheme()._colors;
541  		clrs.disabledText = c;
542  		getTheme().change(clrs);
543  	}
544  	void setLinkTextColor(COLORREF c)
545  	{
546  		Colors clrs = getTheme()._colors;
547  		clrs.linkText = c;
548  		getTheme().change(clrs);
549  	}
550  	void setEdgeColor(COLORREF c)
551  	{
552  		Colors clrs = getTheme()._colors;
553  		clrs.edge = c;
554  		getTheme().change(clrs);
555  	}
556  	void setHotEdgeColor(COLORREF c)
557  	{
558  		Colors clrs = getTheme()._colors;
559  		clrs.hotEdge = c;
560  		getTheme().change(clrs);
561  	}
562  	void setDisabledEdgeColor(COLORREF c)
563  	{
564  		Colors clrs = getTheme()._colors;
565  		clrs.disabledEdge = c;
566  		getTheme().change(clrs);
567  	}
568  	Colors getDarkModeDefaultColors()
569  	{
570  		return darkColors;
571  	}
572  	void changeCustomTheme(const Colors& colors)
573  	{
574  		tCustom.change(colors);
575  	}
576  	void handleSettingChange(HWND hwnd, LPARAM lParam, bool isFromBtn)
577  	{
578  		UNREFERENCED_PARAMETER(hwnd);
579  		if (!isExperimentalSupported())
580  		{
581  			return;
582  		}
583  		if (IsColorSchemeChangeMessage(lParam) || isFromBtn)
584  		{
585  			g_darkModeEnabled = NppDarkMode::isDarkModeReg() && !IsHighContrast();
586  		}
587  	}
588  	bool isDarkModeReg()
589  	{
590  		DWORD data{};
591  		DWORD dwBufSize = sizeof(data);
592  		LPCTSTR lpSubKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
593  		LPCTSTR lpValue = L"AppsUseLightTheme";
594  		auto result = RegGetValue(HKEY_CURRENT_USER, lpSubKey, lpValue, RRF_RT_REG_DWORD, nullptr, &data, &dwBufSize);
595  		if (result != ERROR_SUCCESS)
596  		{
597  			return false;
598  		}
599  		return data == 0UL;
600  	}
601  	bool runUAHWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT* lr)
602  	{
603  		static HTHEME g_menuTheme = nullptr;
604  		UNREFERENCED_PARAMETER(wParam);
605  		switch (message)
606  		{
607  		case WM_UAHDRAWMENU:
608  		{
609  			UAHMENU* pUDM = (UAHMENU*)lParam;
610  			RECT rc{};
611  			{
612  				MENUBARINFO mbi{};
613  				mbi.cbSize = sizeof(MENUBARINFO);
614  				GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi);
615  				RECT rcWindow{};
616  				GetWindowRect(hWnd, &rcWindow);
617  				rc = mbi.rcBar;
618  				OffsetRect(&rc, -rcWindow.left, -rcWindow.top);
619  				rc.top -= 1;
620  			}
621  			FillRect(pUDM->hdc, &rc, NppDarkMode::getDarkerBackgroundBrush());
622  			*lr = 0;
623  			return true;
624  		}
625  		case WM_UAHDRAWMENUITEM:
626  		{
627  			UAHDRAWMENUITEM* pUDMI = (UAHDRAWMENUITEM*)lParam;
628  			wchar_t menuString[256] = { '\0' };
629  			MENUITEMINFO mii{};
630  			{
631  				mii.cbSize = sizeof(MENUITEMINFO);
632  				mii.fMask = MIIM_STRING;
633  				mii.dwTypeData = menuString;
634  				mii.cch = (sizeof(menuString) / 2) - 1;
635  				GetMenuItemInfo(pUDMI->um.hmenu, pUDMI->umi.iPosition, TRUE, &mii);
636  			}
637  			DWORD dwFlags = DT_CENTER | DT_SINGLELINE | DT_VCENTER;
638  			int iTextStateID = MPI_NORMAL;
639  			int iBackgroundStateID = MPI_NORMAL;
640  			{
641  				if ((pUDMI->dis.itemState & ODS_INACTIVE) | (pUDMI->dis.itemState & ODS_DEFAULT))
642  				{
643  					iTextStateID = MPI_NORMAL;
644  					iBackgroundStateID = MPI_NORMAL;
645  				}
646  				if (pUDMI->dis.itemState & ODS_HOTLIGHT)
647  				{
648  					iTextStateID = MPI_HOT;
649  					iBackgroundStateID = MPI_HOT;
650  				}
651  				if (pUDMI->dis.itemState & ODS_SELECTED)
652  				{
653  					iTextStateID = MPI_HOT;
654  					iBackgroundStateID = MPI_HOT;
655  				}
656  				if ((pUDMI->dis.itemState & ODS_GRAYED) || (pUDMI->dis.itemState & ODS_DISABLED))
657  				{
658  					iTextStateID = MPI_DISABLED;
659  					iBackgroundStateID = MPI_DISABLED;
660  				}
661  				if (pUDMI->dis.itemState & ODS_NOACCEL)
662  				{
663  					dwFlags |= DT_HIDEPREFIX;
664  				}
665  			}
666  			if (!g_menuTheme)
667  			{
668  				g_menuTheme = OpenThemeData(hWnd, L"Menu");
669  			}
670  			if (iBackgroundStateID == MPI_NORMAL || iBackgroundStateID == MPI_DISABLED)
671  			{
672  				FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, NppDarkMode::getDarkerBackgroundBrush());
673  			}
674  			else if (iBackgroundStateID == MPI_HOT || iBackgroundStateID == MPI_DISABLEDHOT)
675  			{
676  				FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, NppDarkMode::getHotBackgroundBrush());
677  			}
678  			else
679  			{
680  				DrawThemeBackground(g_menuTheme, pUDMI->um.hdc, MENU_POPUPITEM, iBackgroundStateID, &pUDMI->dis.rcItem, nullptr);
681  			}
682  			DTTOPTS dttopts{};
683  			dttopts.dwSize = sizeof(DTTOPTS);
684  			if (iTextStateID == MPI_NORMAL || iTextStateID == MPI_HOT)
685  			{
686  				dttopts.dwFlags |= DTT_TEXTCOLOR;
687  				dttopts.crText = NppDarkMode::getTextColor();
688  			}
689  			DrawThemeTextEx(g_menuTheme, pUDMI->um.hdc, MENU_POPUPITEM, iTextStateID, menuString, mii.cch, dwFlags, &pUDMI->dis.rcItem, &dttopts);
690  			*lr = 0;
691  			return true;
692  		}
693  		case WM_THEMECHANGED:
694  		{
695  			if (g_menuTheme)
696  			{
697  				CloseThemeData(g_menuTheme);
698  				g_menuTheme = nullptr;
699  			}
700  			return false;
701  		}
702  		default:
703  			return false;
704  		}
705  	}
706  	void drawUAHMenuNCBottomLine(HWND hWnd)
707  	{
708  		MENUBARINFO mbi{};
709  		mbi.cbSize = sizeof(MENUBARINFO);
710  		if (!GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi))
711  		{
712  			return;
713  		}
714  		RECT rcClient{};
715  		GetClientRect(hWnd, &rcClient);
716  		MapWindowPoints(hWnd, nullptr, (POINT*)&rcClient, 2);
717  		RECT rcWindow{};
718  		GetWindowRect(hWnd, &rcWindow);
719  		OffsetRect(&rcClient, -rcWindow.left, -rcWindow.top);
720  		RECT rcAnnoyingLine = rcClient;
721  		rcAnnoyingLine.bottom = rcAnnoyingLine.top;
722  		rcAnnoyingLine.top--;
723  		HDC hdc = GetWindowDC(hWnd);
724  		FillRect(hdc, &rcAnnoyingLine, NppDarkMode::getDarkerBackgroundBrush());
725  		ReleaseDC(hWnd, hdc);
726  	}
727  	void initExperimentalDarkMode()
728  	{
729  		::InitDarkMode();
730  	}
731  	void setDarkMode(bool useDark, bool fixDarkScrollbar)
732  	{
733  		::SetDarkMode(useDark, fixDarkScrollbar);
734  	}
735  	void allowDarkModeForApp(bool allow)
736  	{
737  		::AllowDarkModeForApp(allow);
738  	}
739  	bool allowDarkModeForWindow(HWND hWnd, bool allow)
740  	{
741  		return ::AllowDarkModeForWindow(hWnd, allow);
742  	}
743  	void setTitleBarThemeColor(HWND hWnd)
744  	{
745  		::RefreshTitleBarThemeColor(hWnd);
746  	}
747  	void enableDarkScrollBarForWindowAndChildren(HWND hwnd)
748  	{
749  		::EnableDarkScrollBarForWindowAndChildren(hwnd);
750  	}
751  	void paintRoundFrameRect(HDC hdc, const RECT rect, const HPEN hpen, int width, int height)
752  	{
753  		auto holdBrush = ::SelectObject(hdc, ::GetStockObject(NULL_BRUSH));
754  		auto holdPen = ::SelectObject(hdc, hpen);
755  		::RoundRect(hdc, rect.left, rect.top, rect.right, rect.bottom, width, height);
756  		::SelectObject(hdc, holdBrush);
757  		::SelectObject(hdc, holdPen);
758  	}
759  	struct ButtonData
760  	{
761  		HTHEME hTheme = nullptr;
762  		int iStateID = 0;
763  		~ButtonData()
764  		{
765  			closeTheme();
766  		}
767  		bool ensureTheme(HWND hwnd)
768  		{
769  			if (!hTheme)
770  			{
771  				hTheme = OpenThemeData(hwnd, WC_BUTTON);
772  			}
773  			return hTheme != nullptr;
774  		}
775  		void closeTheme()
776  		{
777  			if (hTheme)
778  			{
779  				CloseThemeData(hTheme);
780  				hTheme = nullptr;
781  			}
782  		}
783  	};
784  	void renderButton(HWND hwnd, HDC hdc, HTHEME hTheme, int iPartID, int iStateID)
785  	{
786  		RECT rcClient{};
787  		WCHAR szText[256] = { '\0' };
788  		DWORD nState = static_cast<DWORD>(SendMessage(hwnd, BM_GETSTATE, 0, 0));
789  		DWORD uiState = static_cast<DWORD>(SendMessage(hwnd, WM_QUERYUISTATE, 0, 0));
790  		auto nStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
791  		HFONT hFont = nullptr;
792  		HFONT hOldFont = nullptr;
793  		HFONT hCreatedFont = nullptr;
794  		LOGFONT lf{};
795  		if (SUCCEEDED(GetThemeFont(hTheme, hdc, iPartID, iStateID, TMT_FONT, &lf)))
796  		{
797  			hCreatedFont = CreateFontIndirect(&lf);
798  			hFont = hCreatedFont;
799  		}
800  		if (!hFont) {
801  			hFont = reinterpret_cast<HFONT>(SendMessage(hwnd, WM_GETFONT, 0, 0));
802  		}
803  		hOldFont = static_cast<HFONT>(SelectObject(hdc, hFont));
804  		DWORD dtFlags = DT_LEFT; 
805  		dtFlags |= (nStyle & BS_MULTILINE) ? DT_WORDBREAK : DT_SINGLELINE;
806  		dtFlags |= ((nStyle & BS_CENTER) == BS_CENTER) ? DT_CENTER : (nStyle & BS_RIGHT) ? DT_RIGHT : 0;
807  		dtFlags |= ((nStyle & BS_VCENTER) == BS_VCENTER) ? DT_VCENTER : (nStyle & BS_BOTTOM) ? DT_BOTTOM : 0;
808  		dtFlags |= (uiState & UISF_HIDEACCEL) ? DT_HIDEPREFIX : 0;
809  		if (!(nStyle & BS_MULTILINE) && !(nStyle & BS_BOTTOM) && !(nStyle & BS_TOP))
810  		{
811  			dtFlags |= DT_VCENTER;
812  		}
813  		GetClientRect(hwnd, &rcClient);
814  		GetWindowText(hwnd, szText, _countof(szText));
815  		SIZE szBox = { 13, 13 };
816  		GetThemePartSize(hTheme, hdc, iPartID, iStateID, NULL, TS_DRAW, &szBox);
817  		RECT rcText = rcClient;
818  		GetThemeBackgroundContentRect(hTheme, hdc, iPartID, iStateID, &rcClient, &rcText);
819  		RECT rcBackground = rcClient;
820  		if (dtFlags & DT_SINGLELINE)
821  		{
822  			rcBackground.top += (rcText.bottom - rcText.top - szBox.cy) / 2;
823  		}
824  		rcBackground.bottom = rcBackground.top + szBox.cy;
825  		rcBackground.right = rcBackground.left + szBox.cx;
826  		rcText.left = rcBackground.right + 3;
827  		DrawThemeParentBackground(hwnd, hdc, &rcClient);
828  		DrawThemeBackground(hTheme, hdc, iPartID, iStateID, &rcBackground, nullptr);
829  		DTTOPTS dtto{};
830  		dtto.dwSize = sizeof(DTTOPTS);
831  		dtto.dwFlags = DTT_TEXTCOLOR;
832  		dtto.crText = NppDarkMode::getTextColor();
833  		if (nStyle & WS_DISABLED)
834  		{
835  			dtto.crText = NppDarkMode::getDisabledTextColor();
836  		}
837  		DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, szText, -1, dtFlags, &rcText, &dtto);
838  		if ((nState & BST_FOCUS) && !(uiState & UISF_HIDEFOCUS))
839  		{
840  			RECT rcTextOut = rcText;
841  			dtto.dwFlags |= DTT_CALCRECT;
842  			DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, szText, -1, dtFlags | DT_CALCRECT, &rcTextOut, &dtto);
843  			RECT rcFocus = rcTextOut;
844  			rcFocus.bottom++;
845  			rcFocus.left--;
846  			rcFocus.right++;
847  			DrawFocusRect(hdc, &rcFocus);
848  		}
849  		if (hCreatedFont) DeleteObject(hCreatedFont);
850  		SelectObject(hdc, hOldFont);
851  	}
852  	void paintButton(HWND hwnd, HDC hdc, ButtonData& buttonData)
853  	{
854  		DWORD nState = static_cast<DWORD>(SendMessage(hwnd, BM_GETSTATE, 0, 0));
855  		const auto nStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
856  		const auto nButtonStyle = nStyle & BS_TYPEMASK;
857  		int iPartID = BP_CHECKBOX;
858  		if (nButtonStyle == BS_CHECKBOX || nButtonStyle == BS_AUTOCHECKBOX || nButtonStyle == BS_3STATE || nButtonStyle == BS_AUTO3STATE)
859  		{
860  			iPartID = BP_CHECKBOX;
861  		}
862  		else if (nButtonStyle == BS_RADIOBUTTON || nButtonStyle == BS_AUTORADIOBUTTON)
863  		{
864  			iPartID = BP_RADIOBUTTON;
865  		}
866  		else
867  		{
868  			assert(false);
869  		}
870  		int iStateID = RBS_UNCHECKEDNORMAL;
871  		if (nStyle & WS_DISABLED)		iStateID = RBS_UNCHECKEDDISABLED;
872  		else if (nState & BST_PUSHED)	iStateID = RBS_UNCHECKEDPRESSED;
873  		else if (nState & BST_HOT)		iStateID = RBS_UNCHECKEDHOT;
874  		if (nState & BST_CHECKED)		iStateID += 4;
875  		if (BufferedPaintRenderAnimation(hwnd, hdc))
876  		{
877  			return;
878  		}
879  		BP_ANIMATIONPARAMS animParams{};
880  		animParams.cbSize = sizeof(BP_ANIMATIONPARAMS);
881  		animParams.style = BPAS_LINEAR;
882  		if (iStateID != buttonData.iStateID)
883  		{
884  			GetThemeTransitionDuration(buttonData.hTheme, iPartID, buttonData.iStateID, iStateID, TMT_TRANSITIONDURATIONS, &animParams.dwDuration);
885  		}
886  		RECT rcClient{};
887  		GetClientRect(hwnd, &rcClient);
888  		HDC hdcFrom = nullptr;
889  		HDC hdcTo = nullptr;
890  		HANIMATIONBUFFER hbpAnimation = BeginBufferedAnimation(hwnd, hdc, &rcClient, BPBF_COMPATIBLEBITMAP, nullptr, &animParams, &hdcFrom, &hdcTo);
891  		if (hbpAnimation)
892  		{
893  			if (hdcFrom)
894  			{
895  				renderButton(hwnd, hdcFrom, buttonData.hTheme, iPartID, buttonData.iStateID);
896  			}
897  			if (hdcTo)
898  			{
899  				renderButton(hwnd, hdcTo, buttonData.hTheme, iPartID, iStateID);
900  			}
901  			buttonData.iStateID = iStateID;
902  			EndBufferedAnimation(hbpAnimation, TRUE);
903  		}
904  		else
905  		{
906  			renderButton(hwnd, hdc, buttonData.hTheme, iPartID, iStateID);
907  			buttonData.iStateID = iStateID;
908  		}
909  	}
910  	constexpr UINT_PTR g_buttonSubclassID = 42;
911  	LRESULT CALLBACK ButtonSubclass(
912  		HWND hWnd,
913  		UINT uMsg,
914  		WPARAM wParam,
915  		LPARAM lParam,
916  		UINT_PTR uIdSubclass,
917  		DWORD_PTR dwRefData
918  	)
919  	{
920  		UNREFERENCED_PARAMETER(uIdSubclass);
921  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
922  		switch (uMsg)
923  		{
924  			case WM_UPDATEUISTATE:
925  				if (HIWORD(wParam) & (UISF_HIDEACCEL | UISF_HIDEFOCUS))
926  				{
927  					InvalidateRect(hWnd, nullptr, FALSE);
928  				}
929  				break;
930  			case WM_NCDESTROY:
931  				RemoveWindowSubclass(hWnd, ButtonSubclass, g_buttonSubclassID);
932  				delete pButtonData;
933  				break;
934  			case WM_ERASEBKGND:
935  				if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
936  				{
937  					return TRUE;
938  				}
939  				else
940  				{
941  					break;
942  				}
943  			case WM_THEMECHANGED:
944  				pButtonData->closeTheme();
945  				break;
946  			case WM_PRINTCLIENT:
947  			case WM_PAINT:
948  				if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
949  				{
950  					PAINTSTRUCT ps{};
951  					HDC hdc = reinterpret_cast<HDC>(wParam);
952  					if (!hdc)
953  					{
954  						hdc = BeginPaint(hWnd, &ps);
955  					}
956  					paintButton(hWnd, hdc, *pButtonData);
957  					if (ps.hdc)
958  					{
959  						EndPaint(hWnd, &ps);
960  					}
961  					return 0;
962  				}
963  				else
964  				{
965  					break;
966  				}
967  			case WM_SIZE:
968  			case WM_DESTROY:
969  				BufferedPaintStopAllAnimations(hWnd);
970  				break;
971  			case WM_ENABLE:
972  				if (NppDarkMode::isEnabled())
973  				{
974  					LRESULT lr = DefWindowProc(hWnd, uMsg, wParam, lParam);
975  					InvalidateRect(hWnd, nullptr, FALSE);
976  					return lr;
977  				}
978  				break;
979  		}
980  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
981  	}
982  	void subclassButtonControl(HWND hwnd)
983  	{
984  		DWORD_PTR pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
985  		SetWindowSubclass(hwnd, ButtonSubclass, g_buttonSubclassID, pButtonData);
986  	}
987  	void paintGroupbox(HWND hwnd, HDC hdc, ButtonData& buttonData)
988  	{
989  		auto nStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
990  		bool isDisabled = (nStyle & WS_DISABLED) == WS_DISABLED;
991  		int iPartID = BP_GROUPBOX;
992  		int iStateID = isDisabled ? GBS_DISABLED : GBS_NORMAL;
993  		RECT rcClient{};
994  		GetClientRect(hwnd, &rcClient);
995  		RECT rcText = rcClient;
996  		RECT rcBackground = rcClient;
997  		HFONT hFont = nullptr;
998  		HFONT hOldFont = nullptr;
999  		HFONT hCreatedFont = nullptr;
1000  		LOGFONT lf{};
1001  		if (SUCCEEDED(GetThemeFont(buttonData.hTheme, hdc, iPartID, iStateID, TMT_FONT, &lf)))
1002  		{
1003  			hCreatedFont = CreateFontIndirect(&lf);
1004  			hFont = hCreatedFont;
1005  		}
1006  		if (!hFont)
1007  		{
1008  			hFont = reinterpret_cast<HFONT>(SendMessage(hwnd, WM_GETFONT, 0, 0));
1009  		}
1010  		hOldFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
1011  		WCHAR szText[256] = { '\0' };
1012  		GetWindowText(hwnd, szText, _countof(szText));
1013  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
1014  		bool isCenter = (style & BS_CENTER) == BS_CENTER;
1015  		if (szText[0])
1016  		{
1017  			SIZE textSize{};
1018  			GetTextExtentPoint32(hdc, szText, static_cast<int>(wcslen(szText)), &textSize);
1019  			int centerPosX = isCenter ? ((rcClient.right - rcClient.left - textSize.cx) / 2) : 7;
1020  			rcBackground.top += textSize.cy / 2;
1021  			rcText.left += centerPosX;
1022  			rcText.bottom = rcText.top + textSize.cy;
1023  			rcText.right = rcText.left + textSize.cx + 4;
1024  			ExcludeClipRect(hdc, rcText.left, rcText.top, rcText.right, rcText.bottom);
1025  		}
1026  		else
1027  		{
1028  			SIZE textSize{};
1029  			GetTextExtentPoint32(hdc, L"M", 1, &textSize);
1030  			rcBackground.top += textSize.cy / 2;
1031  		}
1032  		RECT rcContent = rcBackground;
1033  		GetThemeBackgroundContentRect(buttonData.hTheme, hdc, BP_GROUPBOX, iStateID, &rcBackground, &rcContent);
1034  		ExcludeClipRect(hdc, rcContent.left, rcContent.top, rcContent.right, rcContent.bottom);
1035  		NppDarkMode::paintRoundFrameRect(hdc, rcBackground, NppDarkMode::getEdgePen());
1036  		SelectClipRgn(hdc, nullptr);
1037  		if (szText[0])
1038  		{
1039  			rcText.right -= 2;
1040  			rcText.left += 2;
1041  			DTTOPTS dtto{};
1042  			dtto.dwSize = sizeof(DTTOPTS);
1043  			dtto.dwFlags = DTT_TEXTCOLOR;
1044  			dtto.crText = isDisabled ? NppDarkMode::getDisabledTextColor() : NppDarkMode::getTextColor();
1045  			DWORD textFlags = isCenter ? DT_CENTER : DT_LEFT;
1046  			if(::SendMessage(hwnd, WM_QUERYUISTATE, 0, 0) != static_cast<LRESULT>(NULL))
1047  			{
1048  				textFlags |= DT_HIDEPREFIX;
1049  			}
1050  			DrawThemeTextEx(buttonData.hTheme, hdc, BP_GROUPBOX, iStateID, szText, -1, textFlags | DT_SINGLELINE, &rcText, &dtto);
1051  		}
1052  		if (hCreatedFont) DeleteObject(hCreatedFont);
1053  		SelectObject(hdc, hOldFont);
1054  	}
1055  	constexpr UINT_PTR g_groupboxSubclassID = 42;
1056  	LRESULT CALLBACK GroupboxSubclass(
1057  		HWND hWnd,
1058  		UINT uMsg,
1059  		WPARAM wParam,
1060  		LPARAM lParam,
1061  		UINT_PTR uIdSubclass,
1062  		DWORD_PTR dwRefData
1063  	)
1064  	{
1065  		UNREFERENCED_PARAMETER(uIdSubclass);
1066  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
1067  		switch (uMsg)
1068  		{
1069  		case WM_NCDESTROY:
<span onclick='openModal()' class='match'>1070  			RemoveWindowSubclass(hWnd, GroupboxSubclass, g_groupboxSubclassID);
1071  			delete pButtonData;
1072  			break;
1073  		case WM_ERASEBKGND:
1074  			if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
1075  			{
1076  				return TRUE;
1077  			}
1078  			else
1079  			{
1080  				break;
1081  			}
1082  		case WM_THEMECHANGED:
1083  			pButtonData->closeTheme();
1084  			break;
1085  		case WM_PRINTCLIENT:
1086  		case WM_PAINT:
1087  			if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
1088  			{
1089  				PAINTSTRUCT ps{};
1090  				HDC hdc = reinterpret_cast<HDC>(wParam);
1091  				if (!hdc)
1092  				{
1093  					hdc = BeginPaint(hWnd, &ps);
1094  				}
1095  				paintGroupbox(hWnd, hdc, *pButtonData);
1096  				if (ps.hdc)
1097  				{
1098  					EndPaint(hWnd, &ps);
1099  				}
1100  				return 0;
1101  			}
1102  			else
1103  			{
1104  				break;
1105  			}
1106  			break;
</span>1107  		}
1108  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1109  	}
1110  	void subclassGroupboxControl(HWND hwnd)
1111  	{
1112  		DWORD_PTR pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
1113  		SetWindowSubclass(hwnd, GroupboxSubclass, g_groupboxSubclassID, pButtonData);
1114  	}
1115  	constexpr UINT_PTR g_tabSubclassID = 42;
1116  	LRESULT CALLBACK TabSubclass(
1117  		HWND hWnd,
1118  		UINT uMsg,
1119  		WPARAM wParam,
1120  		LPARAM lParam,
1121  		UINT_PTR uIdSubclass,
1122  		DWORD_PTR dwRefData
1123  	)
1124  	{
1125  		UNREFERENCED_PARAMETER(uIdSubclass);
1126  		UNREFERENCED_PARAMETER(dwRefData);
1127  		switch (uMsg)
1128  		{
1129  		case WM_PAINT:
1130  		{
1131  			if (!NppDarkMode::isEnabled())
1132  			{
1133  				break;
1134  			}
1135  			LONG_PTR dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
1136  			if ((dwStyle & TCS_BUTTONS) || (dwStyle & TCS_VERTICAL))
1137  			{
1138  				break;
1139  			}
1140  			PAINTSTRUCT ps{};
1141  			HDC hdc = ::BeginPaint(hWnd, &ps);
1142  			::FillRect(hdc, &ps.rcPaint, NppDarkMode::getDarkerBackgroundBrush());
1143  			auto holdPen = static_cast<HPEN>(::SelectObject(hdc, NppDarkMode::getEdgePen()));
1144  			HRGN holdClip = CreateRectRgn(0, 0, 0, 0);
1145  			if (1 != GetClipRgn(hdc, holdClip))
1146  			{
1147  				DeleteObject(holdClip);
1148  				holdClip = nullptr;
1149  			}
1150  			HFONT hFont = reinterpret_cast<HFONT>(SendMessage(hWnd, WM_GETFONT, 0, 0));
1151  			auto hOldFont = SelectObject(hdc, hFont);
1152  			POINT ptCursor{};
1153  			::GetCursorPos(&ptCursor);
1154  			ScreenToClient(hWnd, &ptCursor);
1155  			int nTabs = TabCtrl_GetItemCount(hWnd);
1156  			int nSelTab = TabCtrl_GetCurSel(hWnd);
1157  			for (int i = 0; i < nTabs; ++i)
1158  			{
1159  				RECT rcItem{};
1160  				TabCtrl_GetItemRect(hWnd, i, &rcItem);
1161  				RECT rcFrame = rcItem;
1162  				RECT rcIntersect{};
1163  				if (IntersectRect(&rcIntersect, &ps.rcPaint, &rcItem))
1164  				{
1165  					bool bHot = PtInRect(&rcItem, ptCursor);
1166  					bool isSelectedTab = (i == nSelTab);
1167  					HRGN hClip = CreateRectRgnIndirect(&rcItem);
1168  					SelectClipRgn(hdc, hClip);
1169  					SetTextColor(hdc, (bHot || isSelectedTab ) ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
1170  					::InflateRect(&rcItem, -1, -1);
1171  					rcItem.right += 1;
1172  					::FillRect(hdc, &rcItem, isSelectedTab ? NppDarkMode::getDarkerBackgroundBrush() : bHot ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getSofterBackgroundBrush());
1173  					SetBkMode(hdc, TRANSPARENT);
1174  					TCHAR label[MAX_PATH]{};
1175  					TCITEM tci{};
1176  					tci.mask = TCIF_TEXT;
1177  					tci.pszText = label;
1178  					tci.cchTextMax = MAX_PATH - 1;
1179  					::SendMessage(hWnd, TCM_GETITEM, i, reinterpret_cast<LPARAM>(&tci));
1180  					auto dpiManager = NppParameters::getInstance()._dpiManager;
1181  					RECT rcText = rcItem;
1182  					rcText.left += dpiManager.scaleX(5);
1183  					rcText.right -= dpiManager.scaleX(3);
1184  					if (isSelectedTab)
1185  					{
1186  						rcText.bottom -= dpiManager.scaleY(4);
1187  						::InflateRect(&rcFrame, 0, 1);
1188  					}
1189  					if (i != nTabs - 1)
1190  					{
1191  						rcFrame.right += 1;
1192  					}
1193  					::FrameRect(hdc, &rcFrame, NppDarkMode::getEdgeBrush());
1194  					DrawText(hdc, label, -1, &rcText, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
1195  					DeleteObject(hClip);
1196  					SelectClipRgn(hdc, holdClip);
1197  				}
1198  			}
1199  			SelectObject(hdc, hOldFont);
1200  			SelectClipRgn(hdc, holdClip);
1201  			if (holdClip)
1202  			{
1203  				DeleteObject(holdClip);
1204  				holdClip = nullptr;
1205  			}
1206  			SelectObject(hdc, holdPen);
1207  			EndPaint(hWnd, &ps);
1208  			return 0;
1209  		}
1210  		case WM_NCDESTROY:
1211  		{
1212  			RemoveWindowSubclass(hWnd, TabSubclass, g_tabSubclassID);
1213  			break;
1214  		}
1215  		case WM_PARENTNOTIFY:
1216  		{
1217  			switch (LOWORD(wParam))
1218  			{
1219  				case WM_CREATE:
1220  				{
1221  					auto hwndUpdown = reinterpret_cast<HWND>(lParam);
1222  					if (NppDarkMode::subclassTabUpDownControl(hwndUpdown))
1223  					{
1224  						return 0;
1225  					}
1226  					break;
1227  				}
1228  			}
1229  			return 0;
1230  		}
1231  		}
1232  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1233  	}
1234  	void subclassTabControl(HWND hwnd)
1235  	{
1236  		SetWindowSubclass(hwnd, TabSubclass, g_tabSubclassID, 0);
1237  	}
1238  	constexpr UINT_PTR g_customBorderSubclassID = 42;
1239  	LRESULT CALLBACK CustomBorderSubclass(
1240  		HWND hWnd,
1241  		UINT uMsg,
1242  		WPARAM wParam,
1243  		LPARAM lParam,
1244  		UINT_PTR uIdSubclass,
1245  		DWORD_PTR dwRefData
1246  	)
1247  	{
1248  		UNREFERENCED_PARAMETER(dwRefData);
1249  		static bool isHotStatic = false;
1250  		switch (uMsg)
1251  		{
1252  			case WM_NCPAINT:
1253  			{
1254  				if (!NppDarkMode::isEnabled())
1255  				{
1256  					break;
1257  				}
1258  				DefSubclassProc(hWnd, uMsg, wParam, lParam);
1259  				HDC hdc = ::GetWindowDC(hWnd);
1260  				RECT rcClient{};
1261  				::GetClientRect(hWnd, &rcClient);
1262  				rcClient.right += (2 * ::GetSystemMetrics(SM_CXEDGE));
1263  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1264  				bool hasVerScrollbar = (style & WS_VSCROLL) == WS_VSCROLL;
1265  				if (hasVerScrollbar)
1266  				{
1267  					rcClient.right += ::GetSystemMetrics(SM_CXVSCROLL);
1268  				}
1269  				rcClient.bottom += (2 * ::GetSystemMetrics(SM_CYEDGE));
1270  				bool hasHorScrollbar = (style & WS_HSCROLL) == WS_HSCROLL;
1271  				if (hasHorScrollbar)
1272  				{
1273  					rcClient.bottom += ::GetSystemMetrics(SM_CYHSCROLL);
1274  				}
1275  				HPEN hPen = ::CreatePen(PS_SOLID, 1, NppDarkMode::getBackgroundColor());
1276  				RECT rcInner = rcClient;
1277  				::InflateRect(&rcInner, -1, -1);
1278  				NppDarkMode::paintRoundFrameRect(hdc, rcInner, hPen);
1279  				::DeleteObject(hPen);
1280  				bool hasFocus = ::GetFocus() == hWnd;
1281  				POINT ptCursor{};
1282  				::GetCursorPos(&ptCursor);
1283  				::ScreenToClient(hWnd, &ptCursor);
1284  				bool isHot = ::PtInRect(&rcClient, ptCursor);
1285  				bool isWindowEnabled = ::IsWindowEnabled(hWnd) == TRUE;
1286  				HPEN hEnabledPen = ((isHotStatic && isHot) || hasFocus ? NppDarkMode::getHotEdgePen() : NppDarkMode::getEdgePen());
1287  				NppDarkMode::paintRoundFrameRect(hdc, rcClient, isWindowEnabled ? hEnabledPen : NppDarkMode::getDisabledEdgePen());
1288  				::ReleaseDC(hWnd, hdc);
1289  				return 0;
1290  			}
1291  			break;
1292  			case WM_NCCALCSIZE:
1293  			{
1294  				if (!NppDarkMode::isEnabled())
1295  				{
1296  					break;
1297  				}
1298  				auto lpRect = reinterpret_cast<LPRECT>(lParam);
1299  				::InflateRect(lpRect, -(::GetSystemMetrics(SM_CXEDGE)), -(::GetSystemMetrics(SM_CYEDGE)));
1300  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1301  				bool hasVerScrollbar = (style & WS_VSCROLL) == WS_VSCROLL;
1302  				if (hasVerScrollbar)
1303  				{
1304  					lpRect->right -= ::GetSystemMetrics(SM_CXVSCROLL);
1305  				}
1306  				bool hasHorScrollbar = (style & WS_HSCROLL) == WS_HSCROLL;
1307  				if (hasHorScrollbar)
1308  				{
1309  					lpRect->bottom -= ::GetSystemMetrics(SM_CYHSCROLL);
1310  				}
1311  				return 0;
1312  			}
1313  			break;
1314  			case WM_MOUSEMOVE:
1315  			{
1316  				if (!NppDarkMode::isEnabled())
1317  				{
1318  					break;
1319  				}
1320  				if (::GetFocus() == hWnd)
1321  				{
1322  					break;
1323  				}
1324  				TRACKMOUSEEVENT tme{};
1325  				tme.cbSize = sizeof(TRACKMOUSEEVENT);
1326  				tme.dwFlags = TME_LEAVE;
1327  				tme.hwndTrack = hWnd;
1328  				tme.dwHoverTime = HOVER_DEFAULT;
1329  				TrackMouseEvent(&tme);
1330  				if (!isHotStatic)
1331  				{
1332  					isHotStatic = true;
1333  					::SetWindowPos(hWnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1334  				}
1335  			}
1336  			break;
1337  			case WM_MOUSELEAVE:
1338  			{
1339  				if (!NppDarkMode::isEnabled())
1340  				{
1341  					break;
1342  				}
1343  				if (isHotStatic)
1344  				{
1345  					isHotStatic = false;
1346  					::SetWindowPos(hWnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1347  				}
1348  				TRACKMOUSEEVENT tme{};
1349  				tme.cbSize = sizeof(TRACKMOUSEEVENT);
1350  				tme.dwFlags = TME_LEAVE | TME_CANCEL;
1351  				tme.hwndTrack = hWnd;
1352  				tme.dwHoverTime = HOVER_DEFAULT;
1353  				TrackMouseEvent(&tme);
1354  			}
1355  			break;
1356  			case WM_NCDESTROY:
1357  			{
1358  				RemoveWindowSubclass(hWnd, CustomBorderSubclass, uIdSubclass);
1359  			}
1360  			break;
1361  		}
1362  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1363  	}
1364  	void subclassCustomBorderForListBoxAndEditControls(HWND hwnd)
1365  	{
1366  		SetWindowSubclass(hwnd, CustomBorderSubclass, g_customBorderSubclassID, 0);
1367  	}
1368  	constexpr UINT_PTR g_comboBoxSubclassID = 42;
1369  	LRESULT CALLBACK ComboBoxSubclass(
1370  		HWND hWnd,
1371  		UINT uMsg,
1372  		WPARAM wParam,
1373  		LPARAM lParam,
1374  		UINT_PTR uIdSubclass,
1375  		DWORD_PTR dwRefData
1376  	)
1377  	{
1378  		auto hwndEdit = reinterpret_cast<HWND>(dwRefData);
1379  		switch (uMsg)
1380  		{
1381  			case WM_PAINT:
1382  			{
1383  				if (!NppDarkMode::isEnabled())
1384  				{
1385  					break;
1386  				}
1387  				RECT rc{};
1388  				::GetClientRect(hWnd, &rc);
1389  				PAINTSTRUCT ps{};
1390  				auto hdc = ::BeginPaint(hWnd, &ps);
1391  				::SelectObject(hdc, reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0)));
1392  				::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1393  				auto holdBrush = ::SelectObject(hdc, NppDarkMode::getDarkerBackgroundBrush());
1394  				auto& dpiManager = NppParameters::getInstance()._dpiManager;
1395  				RECT rcArrow{};
1396  				COMBOBOXINFO cbi{};
1397  				cbi.cbSize = sizeof(COMBOBOXINFO);
1398  				const bool resultCbi = ::GetComboBoxInfo(hWnd, &cbi) != FALSE;
1399  				if (resultCbi)
1400  				{
1401  					rcArrow = cbi.rcButton;
1402  					rcArrow.left -= 1;
1403  				}
1404  				else
1405  				{
1406  					rcArrow = {
1407  					rc.right - dpiManager.scaleX(17), rc.top + 1,
1408  					rc.right - 1, rc.bottom - 1
1409  					};
1410  				}
1411  				bool hasFocus = false;
1412  				const bool isWindowEnabled = ::IsWindowEnabled(hWnd) == TRUE;
1413  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1414  				if ((style & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST)
1415  				{
1416  					hasFocus = ::GetFocus() == hWnd;
1417  					RECT rcTextBg{};
1418  					if (resultCbi)
1419  					{
1420  						rcTextBg = cbi.rcItem;
1421  					}
1422  					else
1423  					{
1424  						rcTextBg = rc;
1425  						rcTextBg.left += 1;
1426  						rcTextBg.top += 1;
1427  						rcTextBg.right = rcArrow.left - 1;
1428  						rcTextBg.bottom -= 1;
1429  					}
1430  					::FillRect(hdc, &rcTextBg, NppDarkMode::getBackgroundBrush()); 
1431  					auto index = static_cast<int>(::SendMessage(hWnd, CB_GETCURSEL, 0, 0));
1432  					if (index != CB_ERR)
1433  					{
1434  						::SetTextColor(hdc, isWindowEnabled ? NppDarkMode::getTextColor() : NppDarkMode::getDisabledTextColor());
1435  						::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1436  						auto bufferLen = static_cast<size_t>(::SendMessage(hWnd, CB_GETLBTEXTLEN, index, 0));
1437  						TCHAR* buffer = new TCHAR[(bufferLen + 1)];
1438  						::SendMessage(hWnd, CB_GETLBTEXT, index, reinterpret_cast<LPARAM>(buffer));
1439  						RECT rcText = rcTextBg;
1440  						rcText.left += 4;
1441  						rcText.right -= 4;
1442  						::DrawText(hdc, buffer, -1, &rcText, DT_NOPREFIX | DT_LEFT | DT_VCENTER | DT_SINGLELINE);
1443  						delete[] buffer;
1444  					}
1445  					if (hasFocus && ::SendMessage(hWnd, CB_GETDROPPEDSTATE, 0, 0) == FALSE)
1446  					{
1447  						::DrawFocusRect(hdc, &rcTextBg);
1448  					}
1449  				}
1450  				else if ((style & CBS_DROPDOWN) == CBS_DROPDOWN && hwndEdit != nullptr)
1451  				{
1452  					hasFocus = ::GetFocus() == hwndEdit;
1453  				}
1454  				POINT ptCursor{};
1455  				::GetCursorPos(&ptCursor);
1456  				::ScreenToClient(hWnd, &ptCursor);
1457  				bool isHot = ::PtInRect(&rc, ptCursor);
1458  				auto colorEnabledText = isHot ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor();
1459  				::SetTextColor(hdc, isWindowEnabled ? colorEnabledText : NppDarkMode::getDisabledTextColor());
1460  				::SetBkColor(hdc, isHot ? NppDarkMode::getHotBackgroundColor() : NppDarkMode::getBackgroundColor());
1461  				::FillRect(hdc, &rcArrow, isHot ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
1462  				TCHAR arrow[] = L"˅";
1463  				::DrawText(hdc, arrow, -1, &rcArrow, DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
1464  				::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1465  				auto hEnabledPen = (isHot || hasFocus) ? NppDarkMode::getHotEdgePen() : NppDarkMode::getEdgePen();
1466  				auto hSelectedPen = isWindowEnabled ? hEnabledPen : NppDarkMode::getDisabledEdgePen();
1467  				auto holdPen = static_cast<HPEN>(::SelectObject(hdc, hSelectedPen));
1468  				POINT edge[] = {
1469  					{rcArrow.left - 1, rcArrow.top},
1470  					{rcArrow.left - 1, rcArrow.bottom}
1471  				};
1472  				::Polyline(hdc, edge, _countof(edge));
1473  				int roundCornerValue = NppDarkMode::isWindows11() ? dpiManager.scaleX(4) : 0;
1474  				NppDarkMode::paintRoundFrameRect(hdc, rc, hSelectedPen, roundCornerValue, roundCornerValue);
1475  				::SelectObject(hdc, holdPen);
1476  				::SelectObject(hdc, holdBrush);
1477  				::EndPaint(hWnd, &ps);
1478  				return 0;
1479  			}
1480  			case WM_NCDESTROY:
1481  			{
1482  				::RemoveWindowSubclass(hWnd, ComboBoxSubclass, uIdSubclass);
1483  				break;
1484  			}
1485  		}
1486  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1487  	}
1488  	void subclassComboBoxControl(HWND hwnd)
1489  	{
1490  		DWORD_PTR hwndEditData = 0;
1491  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1492  		if ((style & CBS_DROPDOWN) == CBS_DROPDOWN)
1493  		{
1494  			POINT pt = { 5, 5 };
1495  			hwndEditData = reinterpret_cast<DWORD_PTR>(::ChildWindowFromPoint(hwnd, pt));
1496  		}
1497  		SetWindowSubclass(hwnd, ComboBoxSubclass, g_comboBoxSubclassID, hwndEditData);
1498  	}
1499  	constexpr UINT_PTR g_listViewSubclassID = 42;
1500  	LRESULT CALLBACK ListViewSubclass(
1501  		HWND hWnd,
1502  		UINT uMsg,
1503  		WPARAM wParam,
1504  		LPARAM lParam,
1505  		UINT_PTR uIdSubclass,
1506  		DWORD_PTR dwRefData
1507  	)
1508  	{
1509  		UNREFERENCED_PARAMETER(dwRefData);
1510  		switch (uMsg)
1511  		{
1512  			case WM_NCDESTROY:
1513  			{
1514  				::RemoveWindowSubclass(hWnd, ListViewSubclass, uIdSubclass);
1515  				break;
1516  			}
1517  			case WM_NOTIFY:
1518  			{
1519  				switch (reinterpret_cast<LPNMHDR>(lParam)->code)
1520  				{
1521  					case NM_CUSTOMDRAW:
1522  					{
1523  						auto lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
1524  						switch (lpnmcd->dwDrawStage)
1525  						{
1526  							case CDDS_PREPAINT:
1527  							{
1528  								if (NppDarkMode::isExperimentalSupported() && NppDarkMode::isEnabled())
1529  								{
1530  									return CDRF_NOTIFYITEMDRAW;
1531  								}
1532  								return CDRF_DODEFAULT;
1533  							}
1534  							case CDDS_ITEMPREPAINT:
1535  							{
1536  								SetTextColor(lpnmcd->hdc, NppDarkMode::getDarkerTextColor());
1537  								return CDRF_NEWFONT;
1538  							}
1539  							default:
1540  								return CDRF_DODEFAULT;
1541  						}
1542  					}
1543  					break;
1544  				}
1545  				break;
1546  			}
1547  			break;
1548  		}
1549  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1550  	}
1551  	void subclassListViewControl(HWND hwnd)
1552  	{
1553  		SetWindowSubclass(hwnd, ListViewSubclass, g_listViewSubclassID, 0);
1554  	}
1555  	constexpr UINT_PTR g_upDownSubclassID = 42;
1556  	LRESULT CALLBACK UpDownSubclass(
1557  		HWND hWnd,
1558  		UINT uMsg,
1559  		WPARAM wParam,
1560  		LPARAM lParam,
1561  		UINT_PTR uIdSubclass,
1562  		DWORD_PTR dwRefData
1563  	)
1564  	{
1565  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
1566  		switch (uMsg)
1567  		{
1568  			case WM_PRINTCLIENT:
1569  			case WM_PAINT:
1570  			{
1571  				if (!NppDarkMode::isEnabled())
1572  				{
1573  					break;
1574  				}
1575  				const auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1576  				const bool isHorizontal = ((style & UDS_HORZ) == UDS_HORZ);
1577  				bool hasTheme = pButtonData->ensureTheme(hWnd);
1578  				RECT rcClient{};
1579  				::GetClientRect(hWnd, &rcClient);
1580  				PAINTSTRUCT ps{};
1581  				auto hdc = ::BeginPaint(hWnd, &ps);
1582  				::FillRect(hdc, &rcClient, NppDarkMode::getDarkerBackgroundBrush());
1583  				RECT rcArrowPrev{};
1584  				RECT rcArrowNext{};
1585  				if (isHorizontal)
1586  				{
1587  					RECT rcArrowLeft{
1588  						rcClient.left, rcClient.top,
1589  						rcClient.right - ((rcClient.right - rcClient.left) / 2), rcClient.bottom
1590  					};
1591  					RECT rcArrowRight{
1592  						rcArrowLeft.right - 1, rcClient.top,
1593  						rcClient.right, rcClient.bottom
1594  					};
1595  					rcArrowPrev = rcArrowLeft;
1596  					rcArrowNext = rcArrowRight;
1597  				}
1598  				else
1599  				{
1600  					RECT rcArrowTop{
1601  						rcClient.left, rcClient.top,
1602  						rcClient.right, rcClient.bottom - ((rcClient.bottom - rcClient.top) / 2)
1603  					};
1604  					RECT rcArrowBottom{
1605  						rcClient.left, rcArrowTop.bottom - 1,
1606  						rcClient.right, rcClient.bottom
1607  					};
1608  					rcArrowPrev = rcArrowTop;
1609  					rcArrowNext = rcArrowBottom;
1610  				}
1611  				POINT ptCursor{};
1612  				::GetCursorPos(&ptCursor);
1613  				::ScreenToClient(hWnd, &ptCursor);
1614  				bool isHotPrev = ::PtInRect(&rcArrowPrev, ptCursor);
1615  				bool isHotNext = ::PtInRect(&rcArrowNext, ptCursor);
1616  				::SetBkMode(hdc, TRANSPARENT);
1617  				if (hasTheme)
1618  				{
1619  					::DrawThemeBackground(pButtonData->hTheme, hdc, BP_PUSHBUTTON, isHotPrev ? PBS_HOT : PBS_NORMAL, &rcArrowPrev, nullptr);
1620  					::DrawThemeBackground(pButtonData->hTheme, hdc, BP_PUSHBUTTON, isHotNext ? PBS_HOT : PBS_NORMAL, &rcArrowNext, nullptr);
1621  				}
1622  				else
1623  				{
1624  					::FillRect(hdc, &rcArrowPrev, isHotPrev ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
1625  					::FillRect(hdc, &rcArrowNext, isHotNext ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
1626  				}
1627  				const auto arrowTextFlags = DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP;
1628  				::SetTextColor(hdc, isHotPrev ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
1629  				::DrawText(hdc, isHorizontal ? L"<" : L"˄", -1, &rcArrowPrev, arrowTextFlags);
1630  				::SetTextColor(hdc, isHotNext ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
1631  				::DrawText(hdc, isHorizontal ? L">" : L"˅", -1, &rcArrowNext, arrowTextFlags);
1632  				if (!hasTheme)
1633  				{
1634  					NppDarkMode::paintRoundFrameRect(hdc, rcArrowPrev, NppDarkMode::getEdgePen());
1635  					NppDarkMode::paintRoundFrameRect(hdc, rcArrowNext, NppDarkMode::getEdgePen());
1636  				}
1637  				::EndPaint(hWnd, &ps);
1638  				return FALSE;
1639  			}
1640  			case WM_THEMECHANGED:
1641  			{
1642  				pButtonData->closeTheme();
1643  				break;
1644  			}
1645  			case WM_NCDESTROY:
1646  			{
1647  				::RemoveWindowSubclass(hWnd, UpDownSubclass, uIdSubclass);
1648  				delete pButtonData;
1649  				break;
1650  			}
1651  			case WM_ERASEBKGND:
1652  			{
1653  				if (NppDarkMode::isEnabled())
1654  				{
1655  					RECT rcClient{};
1656  					::GetClientRect(hWnd, &rcClient);
1657  					::FillRect(reinterpret_cast<HDC>(wParam), &rcClient, NppDarkMode::getDarkerBackgroundBrush());
1658  					return TRUE;
1659  				}
1660  				break;
1661  			}
1662  		}
1663  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1664  	}
1665  	void subclassAndThemeUpDownControl(HWND hwnd, NppDarkModeParams p)
1666  	{
1667  		if (p._subclass)
1668  		{
1669  			auto pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
1670  			SetWindowSubclass(hwnd, UpDownSubclass, g_upDownSubclassID, pButtonData);
1671  		}
1672  		if (p._theme)
1673  		{
1674  			SetWindowTheme(hwnd, p._themeClassName, nullptr);
1675  		}
1676  	}
1677  	bool subclassTabUpDownControl(HWND hwnd)
1678  	{
1679  		constexpr size_t classNameLen = 16;
1680  		TCHAR className[classNameLen]{};
1681  		GetClassName(hwnd, className, classNameLen);
1682  		if (wcscmp(className, UPDOWN_CLASS) == 0)
1683  		{
1684  			auto pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
1685  			SetWindowSubclass(hwnd, UpDownSubclass, g_upDownSubclassID, pButtonData);
1686  			NppDarkMode::setDarkExplorerTheme(hwnd);
1687  			return true;
1688  		}
1689  		return false;
1690  	}
1691  	void autoSubclassAndThemeChildControls(HWND hwndParent, bool subclass, bool theme)
1692  	{
1693  		NppDarkModeParams p{
1694  			g_isAtLeastWindows10 && NppDarkMode::isEnabled() ? L"DarkMode_Explorer" : nullptr
1695  			, subclass
1696  			, theme
1697  		};
1698  		::EnableThemeDialogTexture(hwndParent, theme && !NppDarkMode::isEnabled() ? ETDT_ENABLETAB : ETDT_DISABLE);
1699  		EnumChildWindows(hwndParent, [](HWND hwnd, LPARAM lParam) WINAPI_LAMBDA {
1700  			auto& p = *reinterpret_cast<NppDarkModeParams*>(lParam);
1701  			constexpr size_t classNameLen = 32;
1702  			TCHAR className[classNameLen]{};
1703  			GetClassName(hwnd, className, classNameLen);
1704  			if (wcscmp(className, WC_BUTTON) == 0)
1705  			{
1706  				NppDarkMode::subclassAndThemeButton(hwnd, p);
1707  				return TRUE;
1708  			}
1709  			if (wcscmp(className, WC_COMBOBOX) == 0)
1710  			{
1711  				NppDarkMode::subclassAndThemeComboBox(hwnd, p);
1712  				return TRUE;
1713  			}
1714  			if (wcscmp(className, WC_EDIT) == 0)
1715  			{
1716  				if (!g_isWine)
1717  				{
1718  					NppDarkMode::subclassAndThemeListBoxOrEditControl(hwnd, p, false);
1719  				}
1720  				return TRUE;
1721  			}
1722  			if (wcscmp(className, WC_LISTBOX) == 0)
1723  			{
1724  				if (!g_isWine)
1725  				{
1726  					NppDarkMode::subclassAndThemeListBoxOrEditControl(hwnd, p, true);
1727  				}
1728  				return TRUE;
1729  			}
1730  			if (wcscmp(className, WC_LISTVIEW) == 0)
1731  			{
1732  				NppDarkMode::subclassAndThemeListView(hwnd, p);
1733  				return TRUE;
1734  			}
1735  			if (wcscmp(className, WC_TREEVIEW) == 0)
1736  			{
1737  				NppDarkMode::themeTreeView(hwnd, p);
1738  				return TRUE;
1739  			}
1740  			if (wcscmp(className, TOOLBARCLASSNAME) == 0)
1741  			{
1742  				NppDarkMode::themeToolbar(hwnd, p);
1743  				return TRUE;
1744  			}
1745  			if (wcscmp(className, L"RichEdit20W") == 0 || wcscmp(className, L"RICHEDIT50W") == 0)
1746  			{
1747  				NppDarkMode::themeRichEdit(hwnd, p);
1748  				return TRUE;
1749  			}
1750  			if (wcscmp(className, UPDOWN_CLASS) == 0)
1751  			{
1752  				NppDarkMode::subclassAndThemeUpDownControl(hwnd, p);
1753  				return TRUE;
1754  			}
1755  			return TRUE;
1756  		}, reinterpret_cast<LPARAM>(&p));
1757  	}
1758  	void autoThemeChildControls(HWND hwndParent)
1759  	{
1760  		autoSubclassAndThemeChildControls(hwndParent, false, g_isAtLeastWindows10);
1761  	}
1762  	void subclassAndThemeButton(HWND hwnd, NppDarkModeParams p)
1763  	{
1764  		auto nButtonStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1765  		switch (nButtonStyle & BS_TYPEMASK)
1766  		{
1767  			case BS_CHECKBOX:
1768  			case BS_AUTOCHECKBOX:
1769  			case BS_3STATE:
1770  			case BS_AUTO3STATE:
1771  			case BS_RADIOBUTTON:
1772  			case BS_AUTORADIOBUTTON:
1773  			{
1774  				if ((nButtonStyle & BS_PUSHLIKE) == BS_PUSHLIKE)
1775  				{
1776  					if (p._theme)
1777  					{
1778  						SetWindowTheme(hwnd, p._themeClassName, nullptr);
1779  					}
1780  					break;
1781  				}
1782  				if (p._subclass)
1783  				{
1784  					NppDarkMode::subclassButtonControl(hwnd);
1785  				}
1786  				break;
1787  			}
1788  			case BS_GROUPBOX:
1789  			{
1790  				if (p._subclass)
1791  				{
1792  					NppDarkMode::subclassGroupboxControl(hwnd);
1793  				}
1794  				break;
1795  			}
1796  			case BS_PUSHBUTTON:
1797  			case BS_DEFPUSHBUTTON:
1798  			case BS_SPLITBUTTON:
1799  			case BS_DEFSPLITBUTTON:
1800  			{
1801  				if (p._theme)
1802  				{
1803  					SetWindowTheme(hwnd, p._themeClassName, nullptr);
1804  				}
1805  				break;
1806  			}
1807  			default:
1808  			{
1809  				break;
1810  			}
1811  		}
1812  	}
1813  	void subclassAndThemeComboBox(HWND hwnd, NppDarkModeParams p)
1814  	{
1815  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1816  		if ((style & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST || (style & CBS_DROPDOWN) == CBS_DROPDOWN)
1817  		{
1818  			COMBOBOXINFO cbi{};
1819  			cbi.cbSize = sizeof(COMBOBOXINFO);
1820  			BOOL result = ::GetComboBoxInfo(hwnd, &cbi);
1821  			if (result == TRUE)
1822  			{
1823  				if (p._theme && cbi.hwndList)
1824  				{
1825  					::SetWindowTheme(cbi.hwndList, p._themeClassName, nullptr);
1826  				}
1827  			}
1828  			if (p._subclass)
1829  			{
1830  				NppDarkMode::subclassComboBoxControl(hwnd);
1831  			}
1832  		}
1833  	}
1834  	void subclassAndThemeListBoxOrEditControl(HWND hwnd, NppDarkModeParams p, bool isListBox)
1835  	{
1836  		const auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1837  		bool hasScrollBar = ((style & WS_HSCROLL) == WS_HSCROLL) || ((style & WS_VSCROLL) == WS_VSCROLL);
1838  		if (p._theme && (isListBox || hasScrollBar))
1839  		{
1840  			SetWindowTheme(hwnd, p._themeClassName, nullptr);
1841  		}
1842  		const auto exStyle = ::GetWindowLongPtr(hwnd, GWL_EXSTYLE);
1843  		bool hasClientEdge = (exStyle & WS_EX_CLIENTEDGE) == WS_EX_CLIENTEDGE;
1844  		bool isCBoxListBox = isListBox && (style & LBS_COMBOBOX) == LBS_COMBOBOX;
1845  		if (p._subclass && hasClientEdge && !isCBoxListBox)
1846  		{
1847  			NppDarkMode::subclassCustomBorderForListBoxAndEditControls(hwnd);
1848  		}
1849  #ifndef __MINGW64__ 
1850  		bool changed = false;
1851  		if (::GetWindowSubclass(hwnd, CustomBorderSubclass, g_customBorderSubclassID, nullptr) == TRUE)
1852  		{
1853  			if (NppDarkMode::isEnabled())
1854  			{
1855  				if (hasClientEdge)
1856  				{
1857  					::SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle & ~WS_EX_CLIENTEDGE);
1858  					changed = true;
1859  				}
1860  			}
1861  			else if (!hasClientEdge)
1862  			{
1863  				::SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle | WS_EX_CLIENTEDGE);
1864  				changed = true;
1865  			}
1866  		}
1867  		if (changed)
1868  		{
1869  			::SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1870  		}
1871  #endif 
1872  	}
1873  	void subclassAndThemeListView(HWND hwnd, NppDarkModeParams p)
1874  	{
1875  		if (p._theme)
1876  		{
1877  			NppDarkMode::setDarkListView(hwnd);
1878  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::listview);
1879  		}
1880  		ListView_SetTextColor(hwnd, NppParameters::getInstance().getCurrentDefaultFgColor());
1881  		ListView_SetTextBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1882  		ListView_SetBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1883  		if (p._subclass)
1884  		{
1885  			auto exStyle = ListView_GetExtendedListViewStyle(hwnd);
1886  			ListView_SetExtendedListViewStyle(hwnd, exStyle | LVS_EX_DOUBLEBUFFER);
1887  			NppDarkMode::subclassListViewControl(hwnd);
1888  		}
1889  	}
1890  	void themeTreeView(HWND hwnd, NppDarkModeParams p)
1891  	{
1892  		TreeView_SetTextColor(hwnd, NppParameters::getInstance().getCurrentDefaultFgColor());
1893  		TreeView_SetBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1894  		NppDarkMode::calculateTreeViewStyle();
1895  		NppDarkMode::setTreeViewStyle(hwnd);
1896  		if (p._theme)
1897  		{
1898  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::treeview);
1899  		}
1900  	}
1901  	void themeToolbar(HWND hwnd, NppDarkModeParams p)
1902  	{
1903  		NppDarkMode::setDarkLineAbovePanelToolbar(hwnd);
1904  		if (p._theme)
1905  		{
1906  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::toolbar);
1907  		}
1908  	}
1909  	void themeRichEdit(HWND hwnd, NppDarkModeParams p)
1910  	{
1911  		if (p._theme)
1912  		{
1913  			SetWindowTheme(hwnd, p._themeClassName, nullptr);
1914  		}
1915  	}
1916  	LRESULT darkToolBarNotifyCustomDraw(LPARAM lParam)
1917  	{
1918  		auto nmtbcd = reinterpret_cast<LPNMTBCUSTOMDRAW>(lParam);
1919  		static int roundCornerValue = 0;
1920  		switch (nmtbcd->nmcd.dwDrawStage)
1921  		{
1922  			case CDDS_PREPAINT:
1923  			{
1924  				if (NppDarkMode::isEnabled())
1925  				{
1926  					auto dpiManager = NppParameters::getInstance()._dpiManager;
1927  					roundCornerValue = NppDarkMode::isWindows11() ? dpiManager.scaleX(5) : 0;
1928  					::FillRect(nmtbcd->nmcd.hdc, &nmtbcd->nmcd.rc, NppDarkMode::getDarkerBackgroundBrush());
1929  					return CDRF_NOTIFYITEMDRAW;
1930  				}
1931  				return CDRF_DODEFAULT;
1932  			}
1933  			case CDDS_ITEMPREPAINT:
1934  			{
1935  				nmtbcd->hbrLines = NppDarkMode::getEdgeBrush();
1936  				nmtbcd->clrText = NppDarkMode::getTextColor();
1937  				nmtbcd->clrTextHighlight = NppDarkMode::getTextColor();
1938  				nmtbcd->clrBtnFace = NppDarkMode::getBackgroundColor();
1939  				nmtbcd->clrBtnHighlight = NppDarkMode::getSofterBackgroundColor();
1940  				nmtbcd->clrHighlightHotTrack = NppDarkMode::getHotBackgroundColor();
1941  				nmtbcd->nStringBkMode = TRANSPARENT;
1942  				nmtbcd->nHLStringBkMode = TRANSPARENT;
1943  				if ((nmtbcd->nmcd.uItemState & CDIS_CHECKED) == CDIS_CHECKED)
1944  				{
1945  					auto holdBrush = ::SelectObject(nmtbcd->nmcd.hdc, NppDarkMode::getSofterBackgroundBrush());
1946  					auto holdPen = ::SelectObject(nmtbcd->nmcd.hdc, NppDarkMode::getEdgePen());
1947  					::RoundRect(nmtbcd->nmcd.hdc, nmtbcd->nmcd.rc.left, nmtbcd->nmcd.rc.top, nmtbcd->nmcd.rc.right, nmtbcd->nmcd.rc.bottom, roundCornerValue, roundCornerValue);
1948  					::SelectObject(nmtbcd->nmcd.hdc, holdBrush);
1949  					::SelectObject(nmtbcd->nmcd.hdc, holdPen);
1950  					nmtbcd->nmcd.uItemState &= ~CDIS_CHECKED;
1951  				}
1952  				return TBCDRF_HILITEHOTTRACK | TBCDRF_USECDCOLORS | CDRF_NOTIFYPOSTPAINT;
1953  			}
1954  			case CDDS_ITEMPOSTPAINT:
1955  			{
1956  				bool isDropDown = false;
1957  				auto exStyle = ::SendMessage(nmtbcd->nmcd.hdr.hwndFrom, TB_GETEXTENDEDSTYLE, 0, 0);
1958  				if ((exStyle & TBSTYLE_EX_DRAWDDARROWS) == TBSTYLE_EX_DRAWDDARROWS)
1959  				{
1960  					TBBUTTONINFO tbButtonInfo{};
1961  					tbButtonInfo.cbSize = sizeof(TBBUTTONINFO);
1962  					tbButtonInfo.dwMask = TBIF_STYLE;
1963  					::SendMessage(nmtbcd->nmcd.hdr.hwndFrom, TB_GETBUTTONINFO, nmtbcd->nmcd.dwItemSpec, reinterpret_cast<LPARAM>(&tbButtonInfo));
1964  					isDropDown = (tbButtonInfo.fsStyle & BTNS_DROPDOWN) == BTNS_DROPDOWN;
1965  				}
1966  				if ( !isDropDown && (nmtbcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
1967  				{
1968  					NppDarkMode::paintRoundFrameRect(nmtbcd->nmcd.hdc, nmtbcd->nmcd.rc, NppDarkMode::getHotEdgePen(), roundCornerValue, roundCornerValue);
1969  				}
1970  				return CDRF_DODEFAULT;
1971  			}
1972  			default:
1973  				return CDRF_DODEFAULT;
1974  		}
1975  	}
1976  	LRESULT darkListViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool isPlugin)
1977  	{
1978  		auto lplvcd = reinterpret_cast<LPNMLVCUSTOMDRAW>(lParam);
1979  		switch (lplvcd->nmcd.dwDrawStage)
1980  		{
1981  			case CDDS_PREPAINT:
1982  			{
1983  				return CDRF_NOTIFYITEMDRAW;
1984  			}
1985  			case CDDS_ITEMPREPAINT:
1986  			{
1987  				auto isSelected = ListView_GetItemState(lplvcd->nmcd.hdr.hwndFrom, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
1988  				if (NppDarkMode::isEnabled())
1989  				{
1990  					if (isSelected)
1991  					{
1992  						lplvcd->clrText = NppDarkMode::getTextColor();
1993  						lplvcd->clrTextBk = NppDarkMode::getSofterBackgroundColor();
1994  						::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, NppDarkMode::getSofterBackgroundBrush());
1995  					}
1996  					else if ((lplvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
1997  					{
1998  						lplvcd->clrText = NppDarkMode::getTextColor();
1999  						lplvcd->clrTextBk = NppDarkMode::getHotBackgroundColor();
2000  						::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, NppDarkMode::getHotBackgroundBrush());
2001  					}
2002  				}
2003  				if (isSelected)
2004  				{
2005  					::DrawFocusRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc);
2006  				}
2007  				LRESULT lr = CDRF_DODEFAULT;
2008  				if (isPlugin)
2009  				{
2010  					lr = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
2011  				}
2012  				return lr | CDRF_NEWFONT;
2013  			}
2014  			default:
2015  				break;
2016  		}
2017  		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
2018  	}
2019  	LRESULT darkTreeViewNotifyCustomDraw(LPARAM lParam)
2020  	{
2021  		auto lptvcd = reinterpret_cast<LPNMTVCUSTOMDRAW>(lParam);
2022  		switch (lptvcd->nmcd.dwDrawStage)
2023  		{
2024  			case CDDS_PREPAINT:
2025  			{
2026  				if (NppDarkMode::isEnabled())
2027  				{
2028  					return CDRF_NOTIFYITEMDRAW;
2029  				}
2030  				return CDRF_DODEFAULT;
2031  			}
2032  			case CDDS_ITEMPREPAINT:
2033  			{
2034  				if ((lptvcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
2035  				{
2036  					lptvcd->clrText = NppDarkMode::getTextColor();
2037  					lptvcd->clrTextBk = NppDarkMode::getSofterBackgroundColor();
2038  					::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, NppDarkMode::getSofterBackgroundBrush());
2039  					return CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
2040  				}
2041  				if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
2042  				{
2043  					lptvcd->clrText = NppDarkMode::getTextColor();
2044  					lptvcd->clrTextBk = NppDarkMode::getHotBackgroundColor();
2045  					auto notifyResult =  CDRF_DODEFAULT;
2046  					if (g_isAtLeastWindows10 || g_treeViewStyle == TreeViewStyle::light)
2047  					{
2048  						::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, NppDarkMode::getHotBackgroundBrush());
2049  						notifyResult = CDRF_NOTIFYPOSTPAINT;
2050  					}
2051  					return CDRF_NEWFONT | notifyResult;
2052  				}
2053  				return CDRF_DODEFAULT;
2054  			}
2055  			case CDDS_ITEMPOSTPAINT:
2056  			{
2057  				RECT rcFrame = lptvcd->nmcd.rc;
2058  				rcFrame.left -= 1;
2059  				rcFrame.right += 1;
2060  				if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
2061  				{
2062  					NppDarkMode::paintRoundFrameRect(lptvcd->nmcd.hdc, rcFrame, NppDarkMode::getHotEdgePen(), 0, 0);
2063  				}
2064  				else if ((lptvcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
2065  				{
2066  					NppDarkMode::paintRoundFrameRect(lptvcd->nmcd.hdc, rcFrame, NppDarkMode::getEdgePen(), 0, 0);
2067  				}
2068  				return CDRF_DODEFAULT;
2069  			}
2070  			default:
2071  				return CDRF_DODEFAULT;
2072  		}
2073  	}
2074  	constexpr UINT_PTR g_pluginDockWindowSubclassID = 42;
2075  	LRESULT CALLBACK PluginDockWindowSubclass(
2076  		HWND hWnd,
2077  		UINT uMsg,
2078  		WPARAM wParam,
2079  		LPARAM lParam,
2080  		UINT_PTR uIdSubclass,
2081  		DWORD_PTR dwRefData
2082  	)
2083  	{
2084  		UNREFERENCED_PARAMETER(dwRefData);
2085  		switch (uMsg)
2086  		{
2087  			case WM_ERASEBKGND:
2088  			{
2089  				if (NppDarkMode::isEnabled())
2090  				{
2091  					RECT rect{};
2092  					GetClientRect(hWnd, &rect);
2093  					::FillRect(reinterpret_cast<HDC>(wParam), &rect, NppDarkMode::getDarkerBackgroundBrush());
2094  					return TRUE;
2095  				}
2096  				break;
2097  			}
2098  			case WM_NCDESTROY:
2099  			{
2100  				::RemoveWindowSubclass(hWnd, PluginDockWindowSubclass, uIdSubclass);
2101  				break;
2102  			}
2103  			case NPPM_INTERNAL_REFRESHDARKMODE:
2104  			{
2105  				NppDarkMode::autoThemeChildControls(hWnd);
2106  				return TRUE;
2107  			}
2108  			case WM_CTLCOLOREDIT:
2109  			{
2110  				if (NppDarkMode::isEnabled())
2111  				{
2112  					return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
2113  				}
2114  				break;
2115  			}
2116  			case WM_CTLCOLORLISTBOX:
2117  			{
2118  				if (NppDarkMode::isEnabled())
2119  				{
2120  					return NppDarkMode::onCtlColorListbox(wParam, lParam);
2121  				}
2122  				break;
2123  			}
2124  			case WM_CTLCOLORDLG:
2125  			{
2126  				if (NppDarkMode::isEnabled())
2127  				{
2128  					return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2129  				}
2130  				break;
2131  			}
2132  			case WM_CTLCOLORSTATIC:
2133  			{
2134  				if (NppDarkMode::isEnabled())
2135  				{
2136  					constexpr size_t classNameLen = 16;
2137  					TCHAR className[classNameLen]{};
2138  					auto hwndEdit = reinterpret_cast<HWND>(lParam);
2139  					GetClassName(hwndEdit, className, classNameLen);
2140  					if (wcscmp(className, WC_EDIT) == 0)
2141  					{
2142  						return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
2143  					}
2144  					return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2145  				}
2146  				break;
2147  			}
2148  			case WM_PRINTCLIENT:
2149  			{
2150  				if (NppDarkMode::isEnabled())
2151  				{
2152  					return TRUE;
2153  				}
2154  				break;
2155  			}
2156  			case WM_NOTIFY:
2157  			{
2158  				const auto nmhdr = reinterpret_cast<LPNMHDR>(lParam);
2159  				switch (nmhdr->code)
2160  				{
2161  					case NM_CUSTOMDRAW:
2162  					{
2163  						constexpr size_t classNameLen = 16;
2164  						TCHAR className[classNameLen]{};
2165  						GetClassName(nmhdr->hwndFrom, className, classNameLen);
2166  						if (wcscmp(className, TOOLBARCLASSNAME) == 0)
2167  						{
2168  							return NppDarkMode::darkToolBarNotifyCustomDraw(lParam);
2169  						}
2170  						if (wcscmp(className, WC_LISTVIEW) == 0)
2171  						{
2172  							return NppDarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam, true);
2173  						}
2174  						if (wcscmp(className, WC_TREEVIEW) == 0)
2175  						{
2176  							return NppDarkMode::darkTreeViewNotifyCustomDraw(lParam);
2177  						}
2178  					}
2179  					break;
2180  				}
2181  				break;
2182  			}
2183  		}
2184  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
2185  	}
2186  	void autoSubclassAndThemePluginDockWindow(HWND hwnd)
2187  	{
2188  		SetWindowSubclass(hwnd, PluginDockWindowSubclass, g_pluginDockWindowSubclassID, 0);
2189  		NppDarkMode::autoSubclassAndThemeChildControls(hwnd, true, g_isAtLeastWindows10);
2190  	}
2191  	ULONG autoSubclassAndThemePlugin(HWND hwnd, ULONG dmFlags)
2192  	{
2193  		constexpr ULONG dmfSubclassParent =     0x00000001UL;
2194  		constexpr ULONG dmfSubclassChildren =   0x00000002UL;
2195  		constexpr ULONG dmfSetThemeChildren =   0x00000004UL;
2196  		constexpr ULONG dmfSetTitleBar =        0x00000008UL;
2197  		constexpr ULONG dmfSetThemeDirectly =   0x00000010UL;
2198  		constexpr ULONG dmfRequiredMask =       dmfSubclassParent | dmfSubclassChildren | dmfSetThemeChildren | dmfSetTitleBar | dmfSetThemeDirectly;
2199  		if (hwnd == nullptr || (dmFlags & dmfRequiredMask) == 0)
2200  		{
2201  			return 0;
2202  		}
2203  		auto dmfBitwiseCheck = [dmFlags](ULONG flag) -> bool {
2204  			return (dmFlags & flag) == flag;
2205  		};
2206  		ULONG result = 0UL;
2207  		if (dmfBitwiseCheck(dmfSubclassParent))
2208  		{
2209  			const bool success = ::SetWindowSubclass(hwnd, PluginDockWindowSubclass, g_pluginDockWindowSubclassID, 0) == TRUE;
2210  			if (success)
2211  			{
2212  				result |= dmfSubclassParent;
2213  			}
2214  		}
2215  		const bool subclassChildren = dmfBitwiseCheck(dmfSubclassChildren);
2216  		if (dmfBitwiseCheck(dmfSetThemeChildren) || subclassChildren)
2217  		{
2218  			NppDarkMode::autoSubclassAndThemeChildControls(hwnd, subclassChildren, g_isAtLeastWindows10);
2219  			result |= dmfSetThemeChildren;
2220  			if (subclassChildren)
2221  			{
2222  				result |= dmfSubclassChildren;
2223  			}
2224  		}
2225  		if (dmfBitwiseCheck(dmfSetTitleBar))
2226  		{
2227  			const auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
2228  			if (NppDarkMode::isExperimentalSupported() && ((style & WS_CAPTION) == WS_CAPTION))
2229  			{
2230  				NppDarkMode::setDarkTitleBar(hwnd);
2231  				result |= dmfSetTitleBar;
2232  			}
2233  		}
2234  		if (dmfBitwiseCheck(dmfSetThemeDirectly))
2235  		{
2236  			if (NppDarkMode::isWindows10())
2237  			{
2238  				NppDarkMode::setDarkExplorerTheme(hwnd);
2239  				result |= dmfSetThemeDirectly;
2240  			}
2241  		}
2242  		return result;
2243  	}
2244  	constexpr UINT_PTR g_windowNotifySubclassID = 42;
2245  	LRESULT CALLBACK WindowNotifySubclass(
2246  		HWND hWnd,
2247  		UINT uMsg,
2248  		WPARAM wParam,
2249  		LPARAM lParam,
2250  		UINT_PTR uIdSubclass,
2251  		DWORD_PTR dwRefData
2252  	)
2253  	{
2254  		UNREFERENCED_PARAMETER(dwRefData);
2255  		switch (uMsg)
2256  		{
2257  			case WM_NCDESTROY:
2258  			{
2259  				::RemoveWindowSubclass(hWnd, WindowNotifySubclass, uIdSubclass);
2260  				break;
2261  			}
2262  			case WM_NOTIFY:
2263  			{
2264  				auto nmhdr = reinterpret_cast<LPNMHDR>(lParam);
2265  				constexpr size_t classNameLen = 16;
2266  				TCHAR className[classNameLen]{};
2267  				GetClassName(nmhdr->hwndFrom, className, classNameLen);
2268  				switch (nmhdr->code)
2269  				{
2270  					case NM_CUSTOMDRAW:
2271  					{
2272  						if (wcscmp(className, TOOLBARCLASSNAME) == 0)
2273  						{
2274  							return NppDarkMode::darkToolBarNotifyCustomDraw(lParam);
2275  						}
2276  						if (wcscmp(className, WC_LISTVIEW) == 0)
2277  						{
2278  							return NppDarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam, false);
2279  						}
2280  						if (wcscmp(className, WC_TREEVIEW) == 0)
2281  						{
2282  							return NppDarkMode::darkTreeViewNotifyCustomDraw(lParam);
2283  						}
2284  					}
2285  					break;
2286  				}
2287  				break;
2288  			}
2289  		}
2290  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
2291  	}
2292  	void autoSubclassAndThemeWindowNotify(HWND hwnd)
2293  	{
2294  		SetWindowSubclass(hwnd, WindowNotifySubclass, g_windowNotifySubclassID, 0);
2295  	}
2296  	void setDarkTitleBar(HWND hwnd)
2297  	{
2298  		constexpr DWORD win10Build2004 = 19041;
2299  		if (NppDarkMode::getWindowsBuildNumber() >= win10Build2004)
2300  		{
2301  			BOOL value = NppDarkMode::isEnabled() ? TRUE : FALSE;
2302  			::DwmSetWindowAttribute(hwnd, DWMWA_USE_IMMERSIVE_DARK_MODE, &value, sizeof(value));
2303  		}
2304  		else
2305  		{
2306  			NppDarkMode::allowDarkModeForWindow(hwnd, NppDarkMode::isEnabled());
2307  			NppDarkMode::setTitleBarThemeColor(hwnd);
2308  		}
2309  	}
2310  	void setDarkExplorerTheme(HWND hwnd)
2311  	{
2312  		SetWindowTheme(hwnd, g_isAtLeastWindows10 && NppDarkMode::isEnabled() ? L"DarkMode_Explorer" : nullptr, nullptr);
2313  	}
2314  	void setDarkScrollBar(HWND hwnd)
2315  	{
2316  		NppDarkMode::setDarkExplorerTheme(hwnd);
2317  	}
2318  	void setDarkTooltips(HWND hwnd, ToolTipsType type)
2319  	{
2320  		UINT msg = 0;
2321  		switch (type)
2322  		{
2323  			case NppDarkMode::ToolTipsType::toolbar:
2324  				msg = TB_GETTOOLTIPS;
2325  				break;
2326  			case NppDarkMode::ToolTipsType::listview:
2327  				msg = LVM_GETTOOLTIPS;
2328  				break;
2329  			case NppDarkMode::ToolTipsType::treeview:
2330  				msg = TVM_GETTOOLTIPS;
2331  				break;
2332  			case NppDarkMode::ToolTipsType::tabbar:
2333  				msg = TCM_GETTOOLTIPS;
2334  				break;
2335  			default:
2336  				msg = 0;
2337  				break;
2338  		}
2339  		if (msg == 0)
2340  		{
2341  			NppDarkMode::setDarkExplorerTheme(hwnd);
2342  		}
2343  		else
2344  		{
2345  			auto hTips = reinterpret_cast<HWND>(::SendMessage(hwnd, msg, 0, 0));
2346  			if (hTips != nullptr)
2347  			{
2348  				NppDarkMode::setDarkExplorerTheme(hTips);
2349  			}
2350  		}
2351  	}
2352  	void setDarkLineAbovePanelToolbar(HWND hwnd)
2353  	{
2354  		COLORSCHEME scheme{};
2355  		scheme.dwSize = sizeof(COLORSCHEME);
2356  		if (NppDarkMode::isEnabled())
2357  		{
2358  			scheme.clrBtnHighlight = NppDarkMode::getDarkerBackgroundColor();
2359  			scheme.clrBtnShadow = NppDarkMode::getDarkerBackgroundColor();
2360  		}
2361  		else
2362  		{
2363  			scheme.clrBtnHighlight = CLR_DEFAULT;
2364  			scheme.clrBtnShadow = CLR_DEFAULT;
2365  		}
2366  		::SendMessage(hwnd, TB_SETCOLORSCHEME, 0, reinterpret_cast<LPARAM>(&scheme));
2367  	}
2368  	void setDarkListView(HWND hwnd)
2369  	{
2370  		if (NppDarkMode::isExperimentalSupported())
2371  		{
2372  			bool useDark = NppDarkMode::isEnabled();
2373  			HWND hHeader = ListView_GetHeader(hwnd);
2374  			NppDarkMode::allowDarkModeForWindow(hHeader, useDark);
2375  			SetWindowTheme(hHeader, useDark ? L"ItemsView" : nullptr, nullptr);
2376  			NppDarkMode::allowDarkModeForWindow(hwnd, useDark);
2377  			SetWindowTheme(hwnd, L"Explorer", nullptr);
2378  		}
2379  	}
2380  	void disableVisualStyle(HWND hwnd, bool doDisable)
2381  	{
2382  		if (doDisable)
2383  		{
2384  			SetWindowTheme(hwnd, L"", L"");
2385  		}
2386  		else
2387  		{
2388  			SetWindowTheme(hwnd, nullptr, nullptr);
2389  		}
2390  	}
2391  	constexpr double g_middleGrayRange = 2.0;
2392  	void calculateTreeViewStyle()
2393  	{
2394  		COLORREF bgColor = NppParameters::getInstance().getCurrentDefaultBgColor();
2395  		if (g_treeViewBg != bgColor || g_lighnessTreeView == 50.0)
2396  		{
2397  			g_lighnessTreeView = calculatePerceivedLighness(bgColor);
2398  			g_treeViewBg = bgColor;
2399  		}
2400  		if (g_lighnessTreeView < (50.0 - g_middleGrayRange))
2401  		{
2402  			g_treeViewStyle = TreeViewStyle::dark;
2403  		}
2404  		else if (g_lighnessTreeView > (50.0 + g_middleGrayRange))
2405  		{
2406  			g_treeViewStyle = TreeViewStyle::light;
2407  		}
2408  		else
2409  		{
2410  			g_treeViewStyle = TreeViewStyle::classic;
2411  		}
2412  	}
2413  	void setTreeViewStyle(HWND hwnd)
2414  	{
2415  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
2416  		bool hasHotStyle = (style & TVS_TRACKSELECT) == TVS_TRACKSELECT;
2417  		bool change = false;
2418  		switch (g_treeViewStyle)
2419  		{
2420  			case TreeViewStyle::light:
2421  			{
2422  				if (!hasHotStyle)
2423  				{
2424  					style |= TVS_TRACKSELECT;
2425  					change = true;
2426  				}
2427  				SetWindowTheme(hwnd, L"Explorer", nullptr);
2428  				break;
2429  			}
2430  			case TreeViewStyle::dark:
2431  			{
2432  				if (!hasHotStyle)
2433  				{
2434  					style |= TVS_TRACKSELECT;
2435  					change = true;
2436  				}
2437  				SetWindowTheme(hwnd, g_isAtLeastWindows10 ? L"DarkMode_Explorer" : nullptr, nullptr);
2438  				break;
2439  			}
2440  			default:
2441  			{
2442  				if (hasHotStyle)
2443  				{
2444  					style &= ~TVS_TRACKSELECT;
2445  					change = true;
2446  				}
2447  				SetWindowTheme(hwnd, nullptr, nullptr);
2448  				break;
2449  			}
2450  		}
2451  		if (change)
2452  		{
2453  			::SetWindowLongPtr(hwnd, GWL_STYLE, style);
2454  		}
2455  	}
2456  	bool isThemeDark()
2457  	{
2458  		return g_treeViewStyle == TreeViewStyle::dark;
2459  	}
2460  	void setBorder(HWND hwnd, bool border)
2461  	{
2462  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
2463  		bool hasBorder = (style & WS_BORDER) == WS_BORDER;
2464  		bool change = false;
2465  		if (!hasBorder && border)
2466  		{
2467  			style |= WS_BORDER;
2468  			change = true;
2469  		}
2470  		else if (hasBorder && !border)
2471  		{
2472  			style &= ~WS_BORDER;
2473  			change = true;
2474  		}
2475  		if (change)
2476  		{
2477  			::SetWindowLongPtr(hwnd, GWL_STYLE, style);
2478  			::SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
2479  		}
2480  	}
2481  	BOOL CALLBACK enumAutocompleteProc(HWND hwnd, LPARAM &bsol;*lParam*/)
2482  	{
2483  		constexpr size_t classNameLen = 16;
2484  		TCHAR className[classNameLen]{};
2485  		GetClassName(hwnd, className, classNameLen);
2486  		if ((wcscmp(className, L"ListBoxX") == 0))
2487  		{
2488  			NppDarkMode::setDarkTitleBar(hwnd);
2489  			NppDarkMode::autoThemeChildControls(hwnd);
2490  			return FALSE;
2491  		}
2492  		return TRUE;
2493  	}
2494  	void setDarkAutoCompletion()
2495  	{
2496  		::EnumThreadWindows(::GetCurrentThreadId(), (WNDENUMPROC)enumAutocompleteProc, 0);
2497  	}
2498  	LRESULT onCtlColor(HDC hdc)
2499  	{
2500  		if (!NppDarkMode::isEnabled())
2501  		{
2502  			return FALSE;
2503  		}
2504  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2505  		::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
2506  		return reinterpret_cast<LRESULT>(NppDarkMode::getBackgroundBrush());
2507  	}
2508  	LRESULT onCtlColorSofter(HDC hdc)
2509  	{
2510  		if (!NppDarkMode::isEnabled())
2511  		{
2512  			return FALSE;
2513  		}
2514  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2515  		::SetBkColor(hdc, NppDarkMode::getSofterBackgroundColor());
2516  		return reinterpret_cast<LRESULT>(NppDarkMode::getSofterBackgroundBrush());
2517  	}
2518  	LRESULT onCtlColorDarker(HDC hdc)
2519  	{
2520  		if (!NppDarkMode::isEnabled())
2521  		{
2522  			return FALSE;
2523  		}
2524  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2525  		::SetBkColor(hdc, NppDarkMode::getDarkerBackgroundColor());
2526  		return reinterpret_cast<LRESULT>(NppDarkMode::getDarkerBackgroundBrush());
2527  	}
2528  	LRESULT onCtlColorError(HDC hdc)
2529  	{
2530  		if (!NppDarkMode::isEnabled())
2531  		{
2532  			return FALSE;
2533  		}
2534  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2535  		::SetBkColor(hdc, NppDarkMode::getErrorBackgroundColor());
2536  		return reinterpret_cast<LRESULT>(NppDarkMode::getErrorBackgroundBrush());
2537  	}
2538  	LRESULT onCtlColorDarkerBGStaticText(HDC hdc, bool isTextEnabled)
2539  	{
2540  		if (!NppDarkMode::isEnabled())
2541  		{
2542  			::SetTextColor(hdc, ::GetSysColor(isTextEnabled ? COLOR_WINDOWTEXT : COLOR_GRAYTEXT));
2543  			return FALSE;
2544  		}
2545  		::SetTextColor(hdc, isTextEnabled ? NppDarkMode::getTextColor() : NppDarkMode::getDisabledTextColor());
2546  		::SetBkColor(hdc, NppDarkMode::getDarkerBackgroundColor());
2547  		return reinterpret_cast<LRESULT>(NppDarkMode::getDarkerBackgroundBrush());
2548  	}
2549  	INT_PTR onCtlColorListbox(WPARAM wParam, LPARAM lParam)
2550  	{
2551  		auto hdc = reinterpret_cast<HDC>(wParam);
2552  		auto hwnd = reinterpret_cast<HWND>(lParam);
2553  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
2554  		bool isComboBox = (style & LBS_COMBOBOX) == LBS_COMBOBOX;
2555  		if (!isComboBox && ::IsWindowEnabled(hwnd))
2556  		{
2557  			return static_cast<INT_PTR>(NppDarkMode::onCtlColorSofter(hdc));
2558  		}
2559  		return static_cast<INT_PTR>(NppDarkMode::onCtlColor(hdc));
2560  	}
2561  	struct HLSColour
2562  	{
2563  		WORD _hue;
2564  		WORD _lightness;
2565  		WORD _saturation;
2566  		COLORREF toRGB() const { return ColorHLSToRGB(_hue, _lightness, _saturation); }
2567  	};
2568  	using IndividualTabColours = std::array<HLSColour, 5>;
2569  	static constexpr IndividualTabColours individualTabHuesFor_Dark  { { HLSColour{37, 60, 60}, HLSColour{70, 60, 60}, HLSColour{144, 70, 60}, HLSColour{255, 60, 60}, HLSColour{195, 60, 60} } };
2570  	static constexpr IndividualTabColours individualTabHues          { { HLSColour{37, 210, 150}, HLSColour{70, 210, 150}, HLSColour{144, 210, 150}, HLSColour{255, 210, 150}, HLSColour{195, 210, 150}}};
2571  	COLORREF getIndividualTabColour(int colourIndex, bool themeDependant, bool saturated)
2572  	{
2573  		if (colourIndex < 0 || colourIndex > 4) return {};
2574  		HLSColour result;
2575  		if (themeDependant)
2576  		{
2577  			result = individualTabHuesFor_Dark[colourIndex];
2578  			if (saturated)
2579  			{
2580  				result._lightness = 146U;
2581  				result._saturation = std::min<WORD>(240U, result._saturation + 100U);
2582  			}
2583  		}
2584  		else
2585  		{
2586  			result = individualTabHues[colourIndex];
2587  			if (saturated)
2588  			{
2589  				result._lightness = 140U;
2590  				result._saturation = std::min<WORD>(240U, result._saturation + 30U);
2591  			}
2592  		}
2593  		return result.toRGB();
2594  	}
2595  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppDarkMode.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppDarkMode.cpp</div>
                </div>
                <div class="column column_space"><pre><code>931  				RemoveWindowSubclass(hWnd, ButtonSubclass, g_buttonSubclassID);
932  				delete pButtonData;
933  				break;
934  			case WM_ERASEBKGND:
935  				if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
936  				{
937  					return TRUE;
938  				}
939  				else
940  				{
941  					break;
942  				}
943  			case WM_THEMECHANGED:
944  				pButtonData->closeTheme();
945  				break;
946  			case WM_PRINTCLIENT:
947  			case WM_PAINT:
948  				if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
949  				{
950  					PAINTSTRUCT ps{};
951  					HDC hdc = reinterpret_cast<HDC>(wParam);
952  					if (!hdc)
953  					{
954  						hdc = BeginPaint(hWnd, &ps);
955  					}
956  					paintButton(hWnd, hdc, *pButtonData);
957  					if (ps.hdc)
958  					{
959  						EndPaint(hWnd, &ps);
960  					}
961  					return 0;
962  				}
963  				else
964  				{
965  					break;
966  				}
967  			case WM_SIZE:
</pre></code></div>
                <div class="column column_space"><pre><code>1070  			RemoveWindowSubclass(hWnd, GroupboxSubclass, g_groupboxSubclassID);
1071  			delete pButtonData;
1072  			break;
1073  		case WM_ERASEBKGND:
1074  			if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
1075  			{
1076  				return TRUE;
1077  			}
1078  			else
1079  			{
1080  				break;
1081  			}
1082  		case WM_THEMECHANGED:
1083  			pButtonData->closeTheme();
1084  			break;
1085  		case WM_PRINTCLIENT:
1086  		case WM_PAINT:
1087  			if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
1088  			{
1089  				PAINTSTRUCT ps{};
1090  				HDC hdc = reinterpret_cast<HDC>(wParam);
1091  				if (!hdc)
1092  				{
1093  					hdc = BeginPaint(hWnd, &ps);
1094  				}
1095  				paintGroupbox(hWnd, hdc, *pButtonData);
1096  				if (ps.hdc)
1097  				{
1098  					EndPaint(hWnd, &ps);
1099  				}
1100  				return 0;
1101  			}
1102  			else
1103  			{
1104  				break;
1105  			}
1106  			break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    