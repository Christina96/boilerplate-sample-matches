
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoobs.cpp</h3>
            <pre><code>1  #include &quot;yahoobs.h&quot;
2  TYWord::TYWord(TYBs* _YBs, const TStr&amp; Str):
<span onclick='openModal()' class='match'>3    YBs(_YBs), FirstChN(YBs-&gt;WordChAHeap.Len()){
4      YBs-&gt;WordChAHeap+=Str; YBs-&gt;WordChAHeap+=TCh::CrCh;
</span>5  }
6  TStr TYWord::GetStr() const {
7    TChA ChA; int ChN=FirstChN;
8    while (YBs-&gt;WordChAHeap[ChN]!=TCh::CrCh){
9      ChA+=YBs-&gt;WordChAHeap[ChN++];}
10    return ChA;
11  }
12  int TYWord::GetSegs() const {
13    int Segs=1; int ChN=FirstChN;
14    while (YBs-&gt;WordChAHeap[ChN]!=TCh::CrCh){
15      if (YBs-&gt;WordChAHeap[ChN++]==&#x27; &#x27;){Segs++;}}
16    return Segs;
17  }
18  void TYWordDs::AddWordIdFq(const TIntFltKd&amp; WordIdFqKd){
19    double WordFq=WordIdFqKd.Dat;
20    if (WordFq&gt;0){
21      int WordIdN=WordIdFqKdV.SearchBin(WordIdFqKd);
22      SumWordFq+=WordFq;
23      if (WordIdN==-1){
24        WordIdFqKdV.AddSorted(WordIdFqKd);
25      } else {
26        WordIdFqKdV[WordIdN].Dat+=WordFq;
27      }
28    }
29  }
30  bool TYWordDs::FNextWordId(
31   int&amp; WordIdN, int&amp; WordId, double&amp; WordFq, double&amp; WordPrb) const {
32    WordIdN++;
33    if (WordIdN&lt;WordIdFqKdV.Len()){
34      WordId=WordIdFqKdV[WordIdN].Key;
35      WordFq=WordIdFqKdV[WordIdN].Dat;
36      WordPrb=WordFq/SumWordFq;
37      return true;
38    } else {
39      return false;
40    }
41  }
42  void TYWordDs::NrToSumWordFq(const double&amp; NrSumWordFq){
43    if (SumWordFq!=NrSumWordFq){
44      double NrRatio=(double(SumWordFq)==0) ? 0 : NrSumWordFq/SumWordFq;
45      SumWordFq=NrSumWordFq;
46      if (SumWordFq&gt;0){
47        for (int WordIdN=0; WordIdN&lt;WordIdFqKdV.Len(); WordIdN++){
48          WordIdFqKdV[WordIdN].Dat=WordIdFqKdV[WordIdN].Dat*NrRatio;}
49      }
50    }
51  }
52  void TYWordDs::PowWordFq(const double&amp; Exp){
53    if (SumWordFq&gt;0){
54      SumWordFq=0;
55      for (int WordIdN=0; WordIdN&lt;WordIdFqKdV.Len(); WordIdN++){
56        SumWordFq+=WordIdFqKdV[WordIdN].Dat=pow(WordIdFqKdV[WordIdN].Dat, Exp);
57      }
58    }
59  }
60  void TYWordDs::SaveTxt(const PSOut&amp; SOut, const TYBs* YBs, const int&amp; DocId){
61    TFltIntKdV WordFqIdKdV(WordIdFqKdV.Len(), 0);
62    for (int WordIdN=0; WordIdN&lt;WordIdFqKdV.Len(); WordIdN++){
63      int WordId=WordIdFqKdV[WordIdN].Key;
64      double WordFq=WordIdFqKdV[WordIdN].Dat/SumWordFq;
65      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
66    }
67    WordFqIdKdV.Sort(false);
68    IAssert(WordFqIdKdV.IsSorted(false));
69    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
70    if (DocId!=-1){Lx.PutVarStr(&quot;UrlStr&quot;, YBs-&gt;GetDocUrlStr(DocId));}
71    Lx.PutVarInt(&quot;DocId&quot;, DocId);
72    Lx.PutVarInt(&quot;Docs&quot;, Docs);
73    Lx.PutVarInt(&quot;Sects&quot;, Sects);
74    Lx.PutVarFlt(&quot;SumWordFq&quot;, SumWordFq);
75    Lx.PutVar(&quot;WordIdFqKdV&quot;, true, true);
76    {for (int WordIdN=0; WordIdN&lt;WordFqIdKdV.Len(); WordIdN++){
77      int WordId=WordFqIdKdV[WordIdN].Dat;
78      double WordFq=WordFqIdKdV[WordIdN].Key;
79      if (YBs==NULL){Lx.PutInt(WordId);}
80      else {Lx.PutQStr(YBs-&gt;GetWordStr(WordId));}
81      Lx.PutFlt(WordFq); Lx.PutLn();
82    }}
83    Lx.PutSym(syRBracket); Lx.PutLn();
84  }
85  PYWordDs TYWordDs::GetMerged(const PYWordDs&amp; LWordDs, const PYWordDs&amp; RWordDs,
86   const double&amp; LWgt, const double&amp; RWgt){
87    TIntFltKdV&amp; LWordIdFqKdV=LWordDs-&gt;WordIdFqKdV;
88    TIntFltKdV&amp; RWordIdFqKdV=RWordDs-&gt;WordIdFqKdV;
89    int LWordIds=LWordDs-&gt;GetWordIds();
90    int RWordIds=RWordDs-&gt;GetWordIds();
91    double LSumWordFq=LWordDs-&gt;GetSumWordFq();
92    double RSumWordFq=RWordDs-&gt;GetSumWordFq();
93    int Docs=LWordDs-&gt;GetDocs()+RWordDs-&gt;GetDocs();
94    int Sects=LWordDs-&gt;GetSects()+RWordDs-&gt;GetSects();
95    int WordIds=LWordIds+RWordIds;
96    PYWordDs WordDs=new TYWordDs(Docs, Sects, WordIds);
97    int LWordIdN=0; int RWordIdN=0;
98    if ((LSumWordFq&gt;0)&amp;&amp;(RSumWordFq&gt;0)){
99      while ((LWordIdN&lt;LWordIds)&amp;&amp;(RWordIdN&lt;RWordIds)){
100        TIntFltKd&amp; LWordIdFqKd=LWordIdFqKdV[LWordIdN];
101        TIntFltKd&amp; RWordIdFqKd=RWordIdFqKdV[RWordIdN];
102        if (LWordIdFqKd==RWordIdFqKd){
103          double LFq=LWgt*LWordIdFqKd.Dat/LSumWordFq;
104          double RFq=RWgt*RWordIdFqKd.Dat/RSumWordFq;
105          WordDs-&gt;AddWordIdFq(LWordIdFqKd.Key, LFq+RFq); LWordIdN++; RWordIdN++;
106        } else
107        if (LWordIdFqKd&lt;RWordIdFqKd){
108          double LFq=LWgt*LWordIdFqKd.Dat/LSumWordFq;
109          WordDs-&gt;AddWordIdFq(LWordIdFqKd.Key, LFq); LWordIdN++;
110        } else {
111          double RFq=RWgt*RWordIdFqKd.Dat/RSumWordFq;
112          WordDs-&gt;AddWordIdFq(RWordIdFqKd.Key, RFq); RWordIdN++;
113        }
114      }
115    }
116    if (LSumWordFq&gt;0){
117      while (LWordIdN&lt;LWordIds){
118        TIntFltKd&amp; LWordIdFqKd=LWordIdFqKdV[LWordIdN];
119        double LFq=LWgt*LWordIdFqKd.Dat/LSumWordFq;
120        WordDs-&gt;AddWordIdFq(LWordIdFqKd.Key, LFq);
121        LWordIdN++;
122      }
123    }
124    if (RSumWordFq&gt;0){
125      while (RWordIdN&lt;RWordIds){
126        TIntFltKd&amp; RWordIdFqKd=RWordIdFqKdV[RWordIdN];
127        double RFq=RWgt*RWordIdFqKd.Dat/RSumWordFq;
128        WordDs-&gt;AddWordIdFq(RWordIdFqKd.Key, RFq);
129        RWordIdN++;
130      }
131    }
132    return WordDs;
133  }
134  PYWordDs TYWordDs::GetTruncByMnWordPrb(
135   const PYWordDs&amp; WordDs, const double&amp; MnWordPrb){
136    double MnWordFq=MnWordPrb*WordDs-&gt;GetSumWordFq();
137    int TruncWordIds=0;
138    {int WordIdN=WordDs-&gt;FFirstWordId(); int WordId; double WordFq;
139    while (WordDs-&gt;FNextWordId(WordIdN, WordId, WordFq)){
140      if (WordFq&gt;=MnWordFq){TruncWordIds++;}
141    }}
142    PYWordDs TruncYWordDs=new
143     TYWordDs(WordDs-&gt;GetDocs(), WordDs-&gt;GetSects(), TruncWordIds);
144    {int WordIdN=WordDs-&gt;FFirstWordId(); int WordId; double WordFq;
145    while (WordDs-&gt;FNextWordId(WordIdN, WordId, WordFq)){
146      if (WordFq&gt;=MnWordFq){TruncYWordDs-&gt;AddWordIdFq(WordId, WordFq);}
147    }}
148    return TruncYWordDs;
149  }
150  PYWordDs TYWordDs::GetTruncBySumWordPrb(
151   const PYWordDs&amp; WordDs, const double&amp; SumWordPrb){
152    double TruncSumWordFq=SumWordPrb*WordDs-&gt;GetSumWordFq();
153    TFltIntKdV WordFqIdKdV(WordDs-&gt;GetWordIds(), 0);
154    {int WordIdN=WordDs-&gt;FFirstWordId(); int WordId; double WordFq;
155    while (WordDs-&gt;FNextWordId(WordIdN, WordId, WordFq)){
156      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
157    }}
158    WordFqIdKdV.Sort(false); double CurSumWordFq=0;
159    TIntFltKdV WordIdFqKdV;
160    for (int WordIdN=0; WordIdN&lt;WordFqIdKdV.Len(); WordIdN++){
161      if (CurSumWordFq&gt;TruncSumWordFq){break;}
162      double WordFq=WordFqIdKdV[WordIdN].Key;
163      int WordId=WordFqIdKdV[WordIdN].Dat;
164      WordIdFqKdV.Add(TIntFltKd(WordId, WordFq));
165      CurSumWordFq+=WordFq;
166    }
167    WordIdFqKdV.Sort();
168    PYWordDs TruncYWordDs=new TYWordDs(WordDs-&gt;GetDocs(), WordDs-&gt;GetSects());
169    {for (int WordIdN=0; WordIdN&lt;WordIdFqKdV.Len(); WordIdN++){
170      TruncYWordDs-&gt;AddWordIdFq(WordIdFqKdV[WordIdN]);
171    }}
172    return TruncYWordDs;
173  }
174  const TStr TYBs::ParWordStr=&quot;/&quot;;
175  void TYBs::PutThisToWord(){
176    int WordToFqP=WordToFqH.FFirstKeyId();
177    while (WordToFqH.FNextKeyId(WordToFqP)){
178      WordToFqH.GetKey(WordToFqP).YBs=this;
179    }
180  }
181  TStr TYBs::GetStrQStr(const TStrQ&amp; StrQ, const int&amp; Strs){
182    TChA ChA;
183    int FirstStrN=(Strs==-1) ? 0 : StrQ.Len()-Strs;
184    for (int StrN=FirstStrN; StrN&lt;StrQ.Len(); StrN++){
185      if (!ChA.Empty()){ChA+=&#x27; &#x27;;} ChA+=StrQ[StrN];
186    }
187    return ChA;
188  }
189  TYBs::TYBs(const PXWebBs&amp; WebBs,
190   const int&amp; _MxNGram, const int&amp; _MnWordFq,
191   const TSwSetTy&amp; SwSetTy, const TStrV&amp; ExclUrlStrV,
192   const PNotify&amp; _Notify):
193    Notify(_Notify),
194    MxNGram(_MxNGram), MnWordFq(_MnWordFq), ParWordId(-1),
195    RootDocId(-1), RootUrlStr(),
196    Sects(0), AbsSects(0),
197    SwSet(new TSwSet(SwSetTy)), CtgStrToFqH(30000),
198    WordToFqH(100000), WordChAHeap(1000000),
199    UrlStrToDocH(50000),
200    PathCtgIdVHeap(10000, 0), CtgIdVHeap(10000, 0),
201    ReftoDocIdVHeap(10000, 0), RefbyDocIdVHeap(),
202    WordIdVHeap(100000, 0){
203    TIntPrV DocIdRefbyDocIdPrV;
204    TStrV SortedExclUrlStrV(ExclUrlStrV);
205    SortedExclUrlStrV.Sort();
206    {int WebPgP=WebBs-&gt;FFirstWebPg(); int WebPgId;
207    while (WebBs-&gt;FNextWebPg(WebPgP, WebPgId)){
208      TStr UrlStr=WebBs-&gt;GetUrlStr(WebPgId);
209      PUrl Url=PUrl(new TUrl(UrlStr));
210      static TStr TreeHtmlStr=&quot;tree.html&quot;;
211      if (!Url-&gt;GetPathStr().IsSuffix(TreeHtmlStr)){
212        UrlStrToDocH.AddDat(UrlStr, PYDoc(new TYDoc()));
213        TStr PathStr=Url-&gt;GetPathStr();
214        if (Url-&gt;GetPathStr()==&quot;/&quot;){
215          IAssert(RootDocId==-1);
216          RootDocId=UrlStrToDocH.GetKeyId(UrlStr);
217          RootUrlStr=UrlStr;
218        }
219        for (int PathSegN=0; PathSegN&lt;Url-&gt;GetPathSegs(); PathSegN++){
220          TStr PathSegStr=Url-&gt;GetPathSeg(PathSegN);
221          if (!PathSegStr.Empty()){CtgStrToFqH.AddDat(PathSegStr);}
222        }
223      }
224    }}
225    IAssert(RootDocId!=-1);
226    TStr DocObjGenStr=
227     TStr(&quot;Document Objects Generated (&quot;)+TInt::GetStr(UrlStrToDocH.Len())+&quot;)&quot;;
228    TNotify::OnNotify(Notify, ntInfo, DocObjGenStr);
229    TNotify::OnNotify(Notify, ntInfo, &quot;Start Generation N-Grams&quot;);
230    for (int NGram=1; NGram&lt;=MxNGram; NGram++){
231      {int WebPgP=WebBs-&gt;FFirstWebPg(); int WebPgId; int Docs=0;
232      while (WebBs-&gt;FNextWebPg(WebPgP, WebPgId)){
233        PXWebPg WebPg=WebBs-&gt;GetWebPg(WebPgId);
234        if (UrlStrToDocH.IsKey(WebPg-&gt;GetUrlStr())){
235          AddDoc(WebPg, false, NGram, SortedExclUrlStrV, DocIdRefbyDocIdPrV);}
236        if (++Docs%100==0){
237          TStr DocProcStr=
238           TStr(&quot;...&quot;)+TInt::GetStr(Docs)+&quot; Documents; &quot;+
239           TInt::GetStr(GetWords())+&quot; N-Grams&quot;;
240          TNotify::OnNotify(Notify, ntInfo, DocProcStr);
241        }
242      }}
243      TStr NGramGenStr=TInt::GetStr(NGram)+&quot;-Grams Generated (&quot;+
244       TInt::GetStr(GetWords())+&quot;)&quot;;
245      TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
246      TStrIntPrV WordStrFqPrV(WordToFqH.Len(), 0);
247      int WordId=WordToFqH.FFirstKeyId();
248      while (WordToFqH.FNextKeyId(WordId)){
249        if (WordToFqH[WordId]&gt;=MnWordFq){
250          WordStrFqPrV.Add(TStrIntPr(GetWordStr(WordId), TInt(GetWordFq(WordId))));}
251      }
252      WordToFqH.Clr(); WordChAHeap.Clr();
253      for (int WordN=0; WordN&lt;WordStrFqPrV.Len(); WordN++){
254        AddWord(WordStrFqPrV[WordN].Val1)=WordStrFqPrV[WordN].Val2;}
255      TStr NGramReduceStr=TInt::GetStr(NGram)+&quot;-Grams Reduced (&quot;+
256       TInt::GetStr(GetWords())+&quot;)&quot;;
257      TNotify::OnNotify(Notify, ntInfo, NGramReduceStr);
258    }
259    TStr NGramGenStr=TInt::GetStr(MxNGram)+&quot;-Grams Generation Finished (&quot;+
260     TInt::GetStr(GetWords())+&quot;)&quot;;
261    TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
262    AddWord(ParWordStr)=0; ParWordId=GetWordId(ParWordStr);
263    TNotify::OnNotify(Notify, ntInfo, &quot;Start Processing Documents&quot;);
264    {int WebPgP=WebBs-&gt;FFirstWebPg(); int WebPgId; int Docs=0;
265    while (WebBs-&gt;FNextWebPg(WebPgP, WebPgId)){
266      PXWebPg WebPg=WebBs-&gt;GetWebPg(WebPgId);
267      if (UrlStrToDocH.IsKey(WebPg-&gt;GetUrlStr())){
268        AddDoc(WebPg, true, -1, SortedExclUrlStrV, DocIdRefbyDocIdPrV);}
269      if (++Docs%100==0){
270        TStr DocProcStr=TInt::GetStr(Docs)+&quot; Documents Processed&quot;;
271        TNotify::OnNotify(Notify, ntInfo, DocProcStr);
272      }
273    }}
274    DocIdRefbyDocIdPrV.Sort();
275    RefbyDocIdVHeap.Gen(DocIdRefbyDocIdPrV.Len()+UrlStrToDocH.Len(), 0);
276    int PrevDocId=-1;
277    for (int DocIdN=0; DocIdN&lt;DocIdRefbyDocIdPrV.Len(); DocIdN++){
278      int DocId=DocIdRefbyDocIdPrV[DocIdN].Val1;
279      int RefbyDocId=DocIdRefbyDocIdPrV[DocIdN].Val2;
280      if (PrevDocId!=DocId){
281        if (PrevDocId!=-1){RefbyDocIdVHeap.Add(TInt(-1));}
282        UrlStrToDocH[DocId]-&gt;FirstRefbyDocIdN=RefbyDocIdVHeap.Len();
283        PrevDocId=DocId;
284      }
285      RefbyDocIdVHeap.Add(RefbyDocId);
286    }
287    RefbyDocIdVHeap.Add(TInt(-1));
288    {int DocId=FFirstDocId();
289    while (FNextDocId(DocId)){
290      if ((GetDocRefbys(DocId)==0)&amp;&amp;(DocId!=GetRootDocId())){
291        TStr MsgStr=TStr(&quot;Unreferenced page: &quot;)+GetDocUrlStr(DocId);
292        TNotify::OnNotify(Notify, ntWarn, MsgStr);
293      }
294    }}
295    {int DocId=FFirstDocId();
296    while (FNextDocId(DocId)){
297      PYDoc Doc=GetDoc(DocId);
298      TIntV CtgIdV;
299      TIntH DocIdH(20);
300      TIntQ DocIdQ; DocIdQ.Push(DocId);
301      while (!DocIdQ.Empty()){
302        int DocId=DocIdQ.Top(); DocIdQ.Pop();
303        if (!DocIdH.IsKey(DocId)){
304          DocIdH.AddKey(DocId);
305          int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
306          while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){
307            DocIdQ.Push(RefbyDocId);}
308          int CtgIdN=FFirstDocPathCtgId(DocId); int CtgId;
309          while (FNextDocPathCtgId(CtgIdN, CtgId)){
310            if (CtgIdV.SearchBin(CtgId)==-1){CtgIdV.AddSorted(CtgId);}}
311        }
312      }
313      if (!CtgIdV.Empty()){
314        Doc-&gt;FirstCtgIdN=CtgIdVHeap.Len();
315        CtgIdVHeap.AddV(CtgIdV); CtgIdVHeap.Add(TInt(-1));
316      }
317    }}
318    TStr DocProcStr=TStr(&quot;Documents Processing Finished (&quot;)+
319     TInt::GetStr(UrlStrToDocH.Len())+&quot;)&quot;;
320    TNotify::OnNotify(Notify, ntInfo, DocProcStr);
321  }
322  void TYBs::AddCtgStrWords(const TStr&amp; CtgStr, TIntV&amp; DocWordIdV){
323    if (!CtgStr.Empty()){
324      TStr UcCtgStr=CtgStr.GetUc();
325      if (!UcCtgStr.IsChIn(&#x27;_&#x27;)){
326        TStr WordStr=UcCtgStr;
327        if ((WordStr.IsWord())&amp;&amp;(!SwSet-&gt;IsIn(WordStr))){
328          AddWord(WordStr)++; DocWordIdV.Add(TInt(GetWordId(WordStr)));
329        }
330      } else {
331        TChA WordChA; TStrV WordStrV; int ChN=0;
332        while (ChN&lt;=UcCtgStr.Len()){
333          if ((ChN==UcCtgStr.Len())||(UcCtgStr[ChN]==&#x27;_&#x27;)){
334            if (!WordChA.Empty()){
335              TStr WordStr=WordChA; WordChA.Clr();
336              if ((WordStr.IsWord())&amp;&amp;(!SwSet-&gt;IsIn(WordStr))){
337                WordStrV.Add(WordStr);}
338            }
339            if ((ChN+1&lt;UcCtgStr.Len())&amp;&amp;(UcCtgStr[ChN+1]==&#x27;_&#x27;)){
340              WordStrV.Add(TStr()); ChN++;}
341          } else {
342            WordChA+=UcCtgStr[ChN];
343          }
344          ChN++;
345        }
346        WordStrV.Add(TStr());
347        TChA NGramWordChA;
348        for (int WordStrN=0; WordStrN&lt;WordStrV.Len(); WordStrN++){
349          TStr WordStr=WordStrV[WordStrN];
350          if (WordStr.Empty()){
351            if (!NGramWordChA.Empty()){
352              TStr NGramWordStr=NGramWordChA; NGramWordChA.Clr();
353              if (NGramWordStr.IsChIn(&#x27; &#x27;)){
354                AddWord(NGramWordStr)++; DocWordIdV.Add(TInt(GetWordId(NGramWordStr)));
355              }
356            }
357          } else {
358            AddWord(WordStr)++; DocWordIdV.Add(TInt(GetWordId(WordStr)));
359            if (!NGramWordChA.Empty()){NGramWordChA+=&#x27; &#x27;;}
360            NGramWordChA+=WordStr;
361          }
362        }
363      }
364    }
365  }
366  void TYBs::AddDoc(
367   const PXWebPg&amp; WebPg, const bool&amp; DoGenDoc,
368   const int&amp; NGram, const TStrV&amp; ExclUrlStrV,
369   TIntPrV&amp; DocIdRefbyDocIdPrV){
370    TStr DocUrlStr;
371    int DocId=-1;
372    PYDoc Doc;
373    bool IsDocWhitePg=false;
374    TIntV DocCtgIdV;
375    TIntV DocReftoDocIdV;
376    TIntV DocWordIdV;
377    int DocSects=0;
378    int DocAbsSects=0;
379    if (DoGenDoc){
380      DocUrlStr=WebPg-&gt;GetUrlStr();
381      DocId=UrlStrToDocH.GetKeyId(DocUrlStr);
382      Doc=UrlStrToDocH.AddDat(DocUrlStr);
383      PUrl DocUrl=new TUrl(DocUrlStr);
384      IsDocWhitePg=false;
385      int DocPathSegs=DocUrl-&gt;GetPathSegs();
386      if (DocPathSegs&gt;=2){
387        IsDocWhitePg=DocUrl-&gt;GetPathSeg(DocPathSegs-2)==&quot;White_Pages&quot;;}
388      DocCtgIdV.Gen(20, 0);
389      DocReftoDocIdV.Gen(100, 0);
390      DocWordIdV.Gen(1000, 0);
391      DocSects=0;
392      DocAbsSects=0;
393    }
394    if (DoGenDoc){
395      PUrl DocUrl=new TUrl(DocUrlStr); IAssert(DocUrl-&gt;IsOk());
396      for (int PathSegN=0; PathSegN&lt;DocUrl-&gt;GetPathSegs(); PathSegN++){
397        TStr PathSegStr=DocUrl-&gt;GetPathSeg(PathSegN);
398        if (!PathSegStr.Empty()){
399          CtgStrToFqH.GetDat(PathSegStr)++;
400          DocCtgIdV.Add(TInt(CtgStrToFqH.GetKeyId(PathSegStr)));
401          AddCtgStrWords(PathSegStr, DocWordIdV);
402        }
403      }
404      if (DocUrl-&gt;GetPathSegs()&gt;0){DocWordIdV.Add(ParWordId); DocSects++;}
405    }
406    PSIn SIn=TStrIn::New(WebPg-&gt;GetBodyStr());
407    PHtmlDoc HtmlDoc=PHtmlDoc(new THtmlDoc(SIn, hdtAll));
408    bool InLi=false; bool ActLi=false; TStrQ PrevStrQ;
409    PHtmlTok Tok; THtmlLxSym Sym=hsyUndef; TStr Str; int TokN=0;
410    while ((TokN&lt;HtmlDoc-&gt;GetToks())&amp;&amp;((Sym!=hsyBTag)||(Str!=THtmlTok::UlTagNm))){
411      Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
412      if (DoGenDoc&amp;&amp; !IsDocWhitePg){
413        if ((Sym==hsyBTag)&amp;&amp;(Str==THtmlTok::CenterTagNm)){
414          Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
415          if ((Sym==hsySSym)&amp;&amp;(Str==&quot;[&quot;)){
416            while ((TokN&lt;HtmlDoc-&gt;GetToks())&amp;&amp;
417             ((Sym!=hsyBTag)||(Str!=THtmlTok::UlTagNm))){
418              Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
419              if ((Sym==hsyBTag)&amp;&amp;(Str==THtmlTok::ATagNm)){
420                PUrl Url=new TUrl(Tok-&gt;GetArg(THtmlTok::HRefArgNm), DocUrlStr);
421                if (Url-&gt;IsOk()){
422                  IAssert(Url-&gt;GetPathSeg(Url-&gt;GetPathSegs()-2)==&quot;White_Pages&quot;);
423                  int ReftoDocId=UrlStrToDocH.GetKeyId(Url-&gt;GetUrlStr());
424                  if ((ReftoDocId!=-1)&amp;&amp;(ReftoDocId!=int(RootDocId))&amp;&amp;
425                   (ReftoDocId!=DocId)){
426                    DocReftoDocIdV.AddMerged(ReftoDocId);
427                    DocIdRefbyDocIdPrV.AddMerged(TIntPr(ReftoDocId, DocId));
428                  }
429                }
430              }
431            }
432          }
433        }
434      }
435    }
436    while (TokN&lt;HtmlDoc-&gt;GetToks()){
437      Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
438      switch (Sym){
439        case hsyStr:
440          if (InLi&amp;&amp;ActLi){
441            if (DoGenDoc){
442              if (!SwSet-&gt;IsIn(Str)){
443                int WordId=GetWordId(Str);
444                if (WordId!=-1){
445                  DocWordIdV.Add(WordId);
446                  PrevStrQ.Push(Str);
447                  int NGram=2;
448                  while ((NGram&lt;=MxNGram)&amp;&amp;(NGram&lt;=PrevStrQ.Len())){
449                    int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
450                    if (WordId==-1){
451                      while (PrevStrQ.Len()&gt;=NGram){PrevStrQ.Pop();} break;
452                    } else {
453                      DocWordIdV.Add(WordId);
454                    }
455                    NGram++;
456                  }
457                } else {
458                  PrevStrQ.Clr();
459                }
460              }
461            } else {
462              if (NGram==1){
463                if (!SwSet-&gt;IsIn(Str)){AddWord(Str)++;}
464              } else {
465                if (!SwSet-&gt;IsIn(Str)){
466                  int WordId=GetWordId(Str);
467                  if (WordId!=-1){
468                    TStr WordStr=GetWordStr(WordId);
469                    if (PrevStrQ.Len()+1==NGram){
470                      if (GetWordId(GetStrQStr(PrevStrQ))!=-1){
471                        PrevStrQ.Push(WordStr);
472                        AddWord(GetStrQStr(PrevStrQ))++;
473                        PrevStrQ.Pop();
474                      } else {
475                        PrevStrQ.Push(WordStr); PrevStrQ.Pop();
476                      }
477                    } else {
478                      PrevStrQ.Push(WordStr);
479                    }
480                  } else {
481                    PrevStrQ.Clr();
482                  }
483                }
484              }
485            }
486          }
487          break;
488        case hsyNum:
489          if (InLi&amp;&amp;ActLi){PrevStrQ.Clr();}
490          break;
491        case hsySSym:
492          if (InLi&amp;&amp;ActLi){PrevStrQ.Clr();}
493          break;
494        case hsyBTag:
495          if (Str==THtmlTok::LiTagNm){
496            if (DoGenDoc&amp;&amp;(DocWordIdV.Len()&gt;0)&amp;&amp;(DocWordIdV.Last()!=ParWordId)){
497              DocWordIdV.Add(ParWordId); DocSects++;}
498            InLi=true; ActLi=true; PrevStrQ.Clr();
499          } else
500          if (InLi&amp;&amp;ActLi&amp;&amp;(Str==THtmlTok::ATagNm)){
501            TStr ItemUrlStr=Tok-&gt;GetArg(THtmlTok::HRefArgNm);
502            if (ExclUrlStrV.SearchBin(ItemUrlStr)!=-1){
503              ActLi=false;}
504            if (DoGenDoc&amp;&amp;InLi&amp;&amp;ActLi){
505              if (TUrl::IsAbs(ItemUrlStr)){
506                DocAbsSects++;}
507              PUrl ItemUrl=TUrl::New(ItemUrlStr, DocUrlStr);
508              if (ItemUrl-&gt;IsOk()){
509                int ReftoDocId=UrlStrToDocH.GetKeyId(ItemUrl-&gt;GetUrlStr());
510                if ((ReftoDocId!=-1)&amp;&amp;(ReftoDocId!=int(RootDocId))&amp;&amp;
511                 (ReftoDocId!=DocId)){
512                  DocReftoDocIdV.AddMerged(ReftoDocId);
513                  DocIdRefbyDocIdPrV.AddMerged(TIntPr(ReftoDocId, DocId));
514                }
515              }
516            }
517          }
518          break;
519        case hsyETag:
520          if (Str==THtmlTok::UlTagNm){
521            if (DoGenDoc&amp;&amp;(DocWordIdV.Len()&gt;0)&amp;&amp;(DocWordIdV.Last()!=ParWordId)){
522              DocWordIdV.Add(ParWordId); DocSects++;
523            }
524            InLi=false; ActLi=false; PrevStrQ.Clr();
525          }
526          break;
527        default:;
528      }
529    }
530    if (DoGenDoc){
531      if (!DocCtgIdV.Empty()){
532        Doc-&gt;FirstPathCtgIdN=PathCtgIdVHeap.Len();
533        PathCtgIdVHeap.AddV(DocCtgIdV); PathCtgIdVHeap.Add(TInt(-1));
534      }
535      if (!DocReftoDocIdV.Empty()){
536        Doc-&gt;FirstReftoDocIdN=ReftoDocIdVHeap.Len();
537        ReftoDocIdVHeap.AddV(DocReftoDocIdV); ReftoDocIdVHeap.Add(TInt(-1));
538      }
539      if (!DocWordIdV.Empty()){
540        Doc-&gt;FirstWordIdN=WordIdVHeap.Len();
541        WordIdVHeap.AddV(DocWordIdV); WordIdVHeap.Add(TInt(-1));
542      }
543      Doc-&gt;Sects=DocSects; Sects+=DocSects;
544      Doc-&gt;AbsSects=DocAbsSects; AbsSects+=DocAbsSects;
545    }
546  }
547  TStr TYBs::GetCtgIdVStr(const TIntV&amp; CtgIdV){
548    TChA ChA;
549    for (int CtgIdN=0; CtgIdN&lt;CtgIdV.Len(); CtgIdN++){
550      if (CtgIdN&gt;0){ChA+=&#x27; &#x27;;}
551      ChA+=GetCtgStr(CtgIdV[CtgIdN]);
552    }
553    return ChA;
554  }
555  void TYBs::GetCtgStrV(const TIntV&amp; CtgIdV, TStrV&amp; CtgStrV){
556    CtgStrV.Gen(CtgIdV.Len(), 0);
557    for (int CtgIdN=0; CtgIdN&lt;CtgIdV.Len(); CtgIdN++){
558      TStr CtgStr=GetCtgStr(CtgIdV[CtgIdN]);
559      CtgStrV.Add(CtgStr);
560    }
561  }
562  TStr TYBs::GetCtgIdToWFqHStr(const TIntFltH&amp; CtgIdToWFqH, const double&amp; SumPrb){
563    TFltIntKdV CtgWFqIdKdV(CtgIdToWFqH.Len(), 0);
564    double SumCtgWFq=0;
565    int CtgIdToWFqP=CtgIdToWFqH.FFirstKeyId();
566    while (CtgIdToWFqH.FNextKeyId(CtgIdToWFqP)){
567      int CtgId=CtgIdToWFqH.GetKey(CtgIdToWFqP);
568      double CtgWFq=CtgIdToWFqH[CtgIdToWFqP];
569      CtgWFqIdKdV.Add(TFltIntKd(CtgWFq, CtgId));
570      SumCtgWFq+=CtgWFq;
571    }
572    CtgWFqIdKdV.Sort(false);
573    SumCtgWFq*=SumPrb;
574    TChA ChA;
575    for (int CtgWFqIdKdN=0; CtgWFqIdKdN&lt;CtgWFqIdKdV.Len(); CtgWFqIdKdN++){
576      double CtgWFq=CtgWFqIdKdV[CtgWFqIdKdN].Key;
577      int CtgId=CtgWFqIdKdV[CtgWFqIdKdN].Dat;
578      SumCtgWFq-=CtgWFq;
579      if (SumCtgWFq&gt;=0){
580        ChA+=GetCtgStr(CtgId);
581        ChA+=&quot; &quot;;
582      }
583    }
584    return ChA;
585  }
586  TInt&amp; TYBs::AddWord(const TStr&amp; WordStr){
587    int PrevLen=WordChAHeap.Len();
588    TYWord Word(this, WordStr);
589    int WordId=WordToFqH.GetKeyId(Word);
590    if (WordId==-1){
591      return WordToFqH.AddDat(Word);
592    } else {
593      WordChAHeap.Trunc(PrevLen);
594      return WordToFqH[WordId];
595    }
596  }
597  int TYBs::GetWordId(const TStr&amp; WordStr){
598    int PrevLen=WordChAHeap.Len();
599    TYWord Word(this, WordStr);
600    int WordId=WordToFqH.GetKeyId(Word);
601    WordChAHeap.Trunc(PrevLen);
602    return WordId;
603  }
604  void TYBs::GetLevDocIdV(const int&amp; Lev, TIntV&amp; DocIdV){
605    DocIdV.Clr();
606    int DocId=FFirstDocId();
607    while (FNextDocId(DocId)){
608      PUrl Url=new TUrl(GetDocUrlStr(DocId));
609      if (Url-&gt;GetPathSegs()==Lev){
610        DocIdV.Add(DocId);}
611    }
612  }
613  void TYBs::GetCtgIdV(const int&amp; DocId, TIntV&amp; CtgIdV){
614    CtgIdV.Clr();
615    int CtgIdN=FFirstDocCtgId(DocId); int CtgId;
616    while (FNextDocCtgId(CtgIdN, CtgId)){
617      CtgIdV.Add(CtgId);}
618  }
619  void TYBs::GetParentDocIdV(const int&amp; DocId, TIntV&amp; DocIdV){
620    DocIdV.Clr();
621    TIntQ DocIdQ; DocIdQ.Push(DocId);
622    while (!DocIdQ.Empty()){
623      int DocId=DocIdQ.Top(); DocIdQ.Pop();
624      if (DocIdV.SearchBin(DocId)==-1){
625        DocIdV.AddSorted(DocId);
626        int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
627        while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){
628          DocIdQ.Push(RefbyDocId);}
629      }
630    }
631  }
632  int TYBs::GetDocDist(const int&amp; LDocId, const int&amp; RDocId){
633    TIntIntH LDocIdToDistH(100);
634    TIntPrQ LDocIdQ; LDocIdQ.Push(TIntPr(LDocId, TInt(0)));
635    while (!LDocIdQ.Empty()){
636      int DocId=LDocIdQ.Top().Val1; int Dist=LDocIdQ.Top().Val2; LDocIdQ.Pop();
637      if (!LDocIdToDistH.IsKey(DocId)){
638        LDocIdToDistH.AddDat(DocId, Dist);
639        int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
640        while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){
641          LDocIdQ.Push(TIntPr(RefbyDocId, TInt(Dist+1)));}
642      }
643    }
644    TIntPrQ RDocIdQ; RDocIdQ.Push(TIntPr(RDocId, TInt(0)));
645    while (!RDocIdQ.Empty()){
646      int DocId=RDocIdQ.Top().Val1; int Dist=RDocIdQ.Top().Val2; RDocIdQ.Pop();
647      if (LDocIdToDistH.IsKey(DocId)){
648        return Dist+LDocIdToDistH.GetDat(DocId);
649      } else {
650        int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
651        while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){
652          RDocIdQ.Push(TIntPr(RefbyDocId, TInt(Dist+1)));}
653      }
654    }
655    return -1;
656  }
657  int TYBs::GetDocReftos(const int&amp; DocId){
658    int Reftos=0;
659    int ReftoDocIdN=FFirstDocReftoDocId(DocId); int ReftoDocId;
660    while (FNextDocReftoDocId(ReftoDocIdN, ReftoDocId)){Reftos++;}
661    return Reftos;
662  }
663  int TYBs::GetDocRefbys(const int&amp; DocId){
664    int Refbys=0;
665    int RefbyDocIdN=FFirstDocRefbyDocId(DocId); int RefbyDocId;
666    while (FNextDocRefbyDocId(RefbyDocIdN, RefbyDocId)){Refbys++;}
667    return Refbys;
668  }
669  PYWordDs TYBs::GetWordDs(const PSIn&amp; SIn){
670    PYWordDs WordDs=PYWordDs(new TYWordDs());
671    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtAll);
672    TStrQ PrevStrQ;
673    PHtmlTok Tok; THtmlLxSym Sym; TStr Str;
674    for (int TokN=0; TokN&lt;HtmlDoc-&gt;GetToks(); TokN++){
675      Tok=HtmlDoc-&gt;GetTok(TokN, Sym, Str);
676      switch (Sym){
677        case hsyStr:
678          if (!SwSet-&gt;IsIn(Str)){
679            int WordId=GetWordId(Str);
680            if (WordId!=-1){
681              WordDs-&gt;AddWordIdFq(WordId, 1);
682              PrevStrQ.Push(Str);
683              int NGram=2;
684              while ((NGram&lt;=MxNGram)&amp;&amp;(NGram&lt;=PrevStrQ.Len())){
685                int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
686                if (WordId==-1){
687                  while (PrevStrQ.Len()&gt;=NGram){PrevStrQ.Pop();} break;
688                } else {
689                  WordDs-&gt;AddWordIdFq(WordId, 1);
690                }
691                NGram++;
692              }
693            } else {
694              PrevStrQ.Clr();
695            }
696          }
697          break;
698        case hsyNum:
699        case hsySSym:
700          PrevStrQ.Clr(); break;
701        case hsyBTag:
702        case hsyETag:
703          if (THtmlTok::IsBreakTag(Str)){PrevStrQ.Clr();} break;
704        default:;
705      }
706    }
707    return WordDs;
708  }
709  void TYBs::GetAbsSectV(
710   const TStr&amp; RefUrlStr, const PXWebPg&amp; WebPg, TYSectV&amp; YSectV){
711    YSectV.Gen(100, 0);
712    TChA TitleChA;
713    PUrl RefUrl=PUrl(new TUrl(RefUrlStr)); IAssert(RefUrl-&gt;IsOk());
714    TitleChA+=THtmlTok::TitleTagNm; TitleChA+=RefUrl-&gt;GetPathStr();
715    TitleChA+=THtmlTok::TitleETagNm; TitleChA.ChangeCh(&#x27;_&#x27;, &#x27; &#x27;);
716    PSIn SIn=TStrIn::New(WebPg-&gt;GetBodyStr());
717    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtUL);
718    PHtmlTok Tok; THtmlLxSym Sym; TStr Str; int TokN=0;
719    while (TokN&lt;HtmlDoc-&gt;GetToks()){
720      Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
721      if ((Sym==hsyBTag)&amp;&amp;(Str==THtmlTok::LiTagNm)){
722        IAssert(TokN&lt;HtmlDoc-&gt;GetToks());
723        Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
724        IAssert((Sym==hsyBTag)&amp;&amp;(Str==THtmlTok::ATagNm));
725        IAssert(Tok-&gt;IsArg(THtmlTok::HRefArgNm));
726        TChA TxtChA; TxtChA+=TitleChA; TxtChA+=&#x27; &#x27;; TxtChA+=Tok-&gt;GetFullStr();
727        TStr UrlStr=Tok-&gt;GetArg(THtmlTok::HRefArgNm);
728        if (TUrl::IsAbs(UrlStr)){
729          PUrl Url=PUrl(new TUrl(UrlStr));
730          if (Url-&gt;IsOk()){
731            PYWordDs WordDs=PYWordDs(new TYWordDs());
732            TStrQ PrevStrQ; bool InSect=true;
733            while ((InSect)&amp;&amp;(TokN&lt;HtmlDoc-&gt;GetToks())){
734              Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
735              switch (Sym){
736                case hsyStr:
737                  if (!SwSet-&gt;IsIn(Str)){
738                    int WordId=GetWordId(Str);
739                    if (WordId!=-1){
740                      WordDs-&gt;AddWordIdFq(WordId, 1);
741                      PrevStrQ.Push(Str);
742                      int NGram=2;
743                      while ((NGram&lt;=MxNGram)&amp;&amp;(NGram&lt;=PrevStrQ.Len())){
744                        int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
745                        if (WordId==-1){
746                          while (PrevStrQ.Len()&gt;=NGram){PrevStrQ.Pop();} break;
747                        } else {
748                          WordDs-&gt;AddWordIdFq(WordId, 1);
749                        }
750                        NGram++;
751                      }
752                    } else {
753                      PrevStrQ.Clr();
754                    }
755                  }
756                  break;
757                case hsyNum: PrevStrQ.Clr(); break;
758                case hsySSym: PrevStrQ.Clr(); break;
759                case hsyBTag: InSect=(Str!=THtmlTok::LiTagNm); break;
760                case hsyETag: InSect=(Str!=THtmlTok::UlTagNm); break;
761                default:;
762              }
763              if (InSect){TxtChA+=&#x27; &#x27;; TxtChA+=Tok-&gt;GetFullStr();;}
764            }
765            PYSect YSect=new TYSect(RefUrlStr, Url-&gt;GetUrlStr(), WordDs, TxtChA);
766            YSectV.Add(YSect);
767          }
768        }
769      }
770    }
771  }
772  void TYBs::GetAbsSectUrlStrV(const PXWebPg&amp; WebPg, TStrV&amp; UrlStrV){
773    UrlStrV.Gen(100, 0);
774    PSIn SIn=TStrIn::New(WebPg-&gt;GetBodyStr());
775    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtUL);
776    PHtmlTok Tok; THtmlLxSym Sym; TStr Str; int TokN=0;
777    while (TokN&lt;HtmlDoc-&gt;GetToks()){
778      Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
779      if ((Sym==hsyBTag)&amp;&amp;(Str==THtmlTok::LiTagNm)){
780        IAssert(TokN&lt;HtmlDoc-&gt;GetToks());
781        Tok=HtmlDoc-&gt;GetTok(TokN++, Sym, Str);
782        IAssert((Sym==hsyBTag)&amp;&amp;(Str==THtmlTok::ATagNm));
783        IAssert(Tok-&gt;IsArg(THtmlTok::HRefArgNm));
784        TStr UrlStr=Tok-&gt;GetArg(THtmlTok::HRefArgNm);
785        if (TUrl::IsAbs(UrlStr)){
786          PUrl Url=new TUrl(UrlStr);
787          if (Url-&gt;IsOk()){
788            UrlStrV.Add(Url-&gt;GetUrlStr());}
789        }
790      }
791    }
792  }
793  void TYBs::SaveTxt(const PSOut&amp; SOut){
794    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
795    int UrlStrToDocP=UrlStrToDocH.FFirstKeyId();
796    while (UrlStrToDocH.FNextKeyId(UrlStrToDocP)){
797      TStr UrlStr=UrlStrToDocH.GetKey(UrlStrToDocP);
798      PYDoc Doc=UrlStrToDocH[UrlStrToDocP]; TChA ChA(10000);
799      int DocId=UrlStrToDocP;
800      Lx.PutVarStr(&quot;UrlStr&quot;, UrlStr);
801      Lx.PutVarInt(&quot;DocId&quot;, DocId);
802      Lx.PutVarInt(&quot;Sects&quot;, Doc-&gt;Sects);
803      Lx.PutVarInt(&quot;AbsSects&quot;, Doc-&gt;AbsSects);
804      TIntV CtgIdV; GetCtgIdV(DocId, CtgIdV);
805      Lx.PutVarStr(&quot;CtgIdV&quot;, GetCtgIdVStr(CtgIdV));
806      Lx.PutVar(&quot;ReftoDocIdV&quot;, true, false); 
807      if (Doc-&gt;FirstReftoDocIdN!=-1){
808        int ReftoDocIdN=Doc-&gt;FirstReftoDocIdN;
809        while (ReftoDocIdVHeap[ReftoDocIdN]!=-1){
810          Lx.PutInt(ReftoDocIdVHeap[ReftoDocIdN++]);}
811      }
812      Lx.PutSym(syRBracket); Lx.PutLn();
813      Lx.PutVar(&quot;RefbyDocIdV&quot;, true, false);
814      if (Doc-&gt;FirstRefbyDocIdN!=-1){
815        int RefbyDocIdN=Doc-&gt;FirstRefbyDocIdN;
816        while (RefbyDocIdVHeap[RefbyDocIdN]!=-1){
817          Lx.PutInt(RefbyDocIdVHeap[RefbyDocIdN++]);}
818      }
819      Lx.PutSym(syRBracket); Lx.PutLn();
820      Lx.PutVar(&quot;Doc&quot;, true, true);
821      if (Doc-&gt;FirstWordIdN!=-1){
822        int WordIdN=Doc-&gt;FirstWordIdN;
823        while (WordIdVHeap[WordIdN]!=-1){
824          int WordId=WordIdVHeap[WordIdN++];
825          TStr WordStr=GetWordStr(WordId);
826          int WordSegs=GetWordSegs(WordId);
827          if (WordId==int(ParWordId)){
828            Lx.PutQStr(ChA); Lx.PutLn(); ChA.Clr();
829          } else {
830            if (!ChA.Empty()){ChA+=&#x27; &#x27;;}
831            if (WordStr.SearchCh(&#x27; &#x27;)==-1){
832              ChA+=WordStr;
833            } else {
834              ChA+=&#x27;(&#x27;; ChA+=&#x27;#&#x27;; ChA+=TInt::GetStr(WordSegs);
835              ChA+=&#x27; &#x27;; ChA+=WordStr; ChA+=&#x27;)&#x27;;
836            }
837          }
838        }
839      }
840      Lx.PutSym(syRBracket); Lx.PutLn(); Lx.PutLn();
841    }
842  }
843  void TYBs::SaveTxtWords(const TStr&amp; FNm){
844    TIntStrKdV WordFqStrKdV;
845    int WordToFqP=WordToFqH.FFirstKeyId();
846    while (WordToFqH.FNextKeyId(WordToFqP)){
847      TStr WordStr=GetWordStr(WordToFqP);
848      int WordFq=WordToFqH[WordToFqP];
849      WordFqStrKdV.Add(TIntStrKd(WordFq, WordStr));
850    }
851    WordFqStrKdV.Sort(false);
852    PSOut WordSOut=PSOut(new TFOut(FNm));
853    for (int WordFqStrKdN=0; WordFqStrKdN&lt;WordFqStrKdV.Len(); WordFqStrKdN++){
854      int WordFq=WordFqStrKdV[WordFqStrKdN].Key;
855      TStr WordStr=WordFqStrKdV[WordFqStrKdN].Dat;
856      WordSOut-&gt;PutStr(WordStr); WordSOut-&gt;PutStr(&quot;: &quot;);
857      WordSOut-&gt;PutStr(TInt::GetStr(WordFq)); WordSOut-&gt;PutLn();
858    }
859  }
860  void TYBs::SaveTxtCtgs(const TStr&amp; FNm){
861    TIntStrKdV CtgFqStrKdV;
862    int CtgStrToFqP=CtgStrToFqH.FFirstKeyId();
863    while (CtgStrToFqH.FNextKeyId(CtgStrToFqP)){
864      TStr CtgStr=CtgStrToFqH.GetKey(CtgStrToFqP);
865      int CtgFq=CtgStrToFqH[CtgStrToFqP];
866      CtgFqStrKdV.Add(TIntStrKd(CtgFq, CtgStr));
867    }
868    CtgFqStrKdV.Sort(false);
869    PSOut CtgSOut=PSOut(new TFOut(FNm));
870    for (int CtgFqStrKdN=0; CtgFqStrKdN&lt;CtgFqStrKdV.Len(); CtgFqStrKdN++){
871      int CtgFq=CtgFqStrKdV[CtgFqStrKdN].Key;
872      TStr CtgStr=CtgFqStrKdV[CtgFqStrKdN].Dat;
873      int CtgId=GetCtgId(CtgStr);
874      CtgSOut-&gt;PutStr(CtgStr); CtgSOut-&gt;PutStr(&quot;: &quot;);
875      CtgSOut-&gt;PutStr(TInt::GetStr(CtgFq));
876      CtgSOut-&gt;PutStr(TStr(&quot; [Id:&quot;)+TInt::GetStr(CtgId)+&quot;]&quot;);
877      CtgSOut-&gt;PutLn();
878    }
879  }
880  int TYDsBs::GetMissDss(const PYBs&amp; YBs, const int&amp; DocId){
881    int MissDss=0;
882    int ReftoDocIdN=YBs-&gt;FFirstDocReftoDocId(DocId); int ReftoDocId;
883    while (YBs-&gt;FNextDocReftoDocId(ReftoDocIdN, ReftoDocId)){
884      if (!DocIdToWordDsH.IsKey(ReftoDocId)){MissDss++;}}
885    return MissDss;
886  }
887  double TYDsBs::GetNrWgt(const TYDsBsNrType&amp; NrType, const PYWordDs&amp; WordDs){
888    switch (NrType){
889      case ydnConst: return 1;
890      case ydnWords: return WordDs-&gt;GetSumWordFq();
891      case ydnLnWords: return log10(1+WordDs-&gt;GetSumWordFq());
892      case ydnSects: return 1+WordDs-&gt;GetSects();
893      case ydnLnSects: return log10(1+WordDs-&gt;GetSects());
894      case ydnDocs: return 1+WordDs-&gt;GetDocs();
895      case ydnLnDocs: return log10(1+WordDs-&gt;GetDocs());
896      default: Fail; return -1;
897    }
898  }
899  TYDsBs::TYDsBs(const TYDsBsNrType&amp; NrType, const double&amp; WordFqExp,
900   const double&amp; MnWordPrb, const double&amp; &amp;bsol;*MnAllWordPrb*/,
901   const PYBs&amp; YBs, const PNotify&amp; _Notify):
902    Notify(_Notify), AllWordDs(), DocIdToWordDsH(10000){
903    TNotify::OnNotify(Notify, ntInfo, &quot;Start Creating Distributions&quot;);
904    int RootDocId=YBs-&gt;GetRootDocId();
905    int ParWordId=YBs-&gt;GetParWordId();
906    int PrevDocs=0; int MxMissDss=0;
907    TIntH RepDocIdH(1000); int RepDocIters=3;
908    while ((DocIdToWordDsH.Len()&lt;YBs-&gt;GetDocs())||(!RepDocIdH.Empty())){
909      if ((DocIdToWordDsH.Len()&gt;0)&amp;&amp;(PrevDocs==DocIdToWordDsH.Len())){
910        if (PrevDocs==YBs-&gt;GetDocs()){MxMissDss=-1;} else {MxMissDss++;}
911      }
912      PrevDocs=DocIdToWordDsH.Len();
913      int DocId=YBs-&gt;FFirstDocId();
914      while (YBs-&gt;FNextDocId(DocId)){
915        bool MkWordDs=false;
916        if (MxMissDss==-1){
917          if (RepDocIdH.IsKey(DocId)){
918            MkWordDs=true;
919            if (RepDocIters&lt;=1){RepDocIdH.DelKey(DocId);}
920          }
921        } else {
922          if (!DocIdToWordDsH.IsKey(DocId)){
923            int MissDss=GetMissDss(YBs, DocId);
924            if (MissDss&lt;=MxMissDss){
925              MkWordDs=true; if (MissDss&gt;0){RepDocIdH.AddKey(DocId);}
926            }
927          }
928        }
929        if (MkWordDs){
930          PYWordDs WordDs=new TYWordDs(1);
931          int WordIdN=YBs-&gt;FFirstDocWordId(DocId); int WordId;
932          while (YBs-&gt;FNextDocWordId(WordIdN, WordId)){
933            if (WordId==ParWordId){WordDs-&gt;AddSect();}
934            else {WordDs-&gt;AddWordIdFq(WordId, 1);}
935          }
936          IAssert(WordDs-&gt;GetSects()==YBs-&gt;GetDocSects(DocId));
937          WordDs-&gt;NrToSumWordFq(GetNrWgt(NrType, WordDs));
938          int ReftoDocIdN=YBs-&gt;FFirstDocReftoDocId(DocId); int ReftoDocId;
939          while (YBs-&gt;FNextDocReftoDocId(ReftoDocIdN, ReftoDocId)){
940            if (DocIdToWordDsH.IsKey(ReftoDocId)){
941              PYWordDs ReftoWordDs=DocIdToWordDsH.GetDat(ReftoDocId);
942              double ReftoWordDsW=GetNrWgt(NrType, ReftoWordDs);
943              WordDs=TYWordDs::GetMerged(WordDs, ReftoWordDs,
944               WordDs-&gt;GetSumWordFq(), ReftoWordDsW);
945            }
946          }
947          WordDs-&gt;PowWordFq(WordFqExp);
948          WordDs=TYWordDs::GetTruncByMnWordPrb(WordDs, MnWordPrb);
949          DocIdToWordDsH.AddDat(DocId, WordDs);
950          if (DocIdToWordDsH.Len()%1000==0){
951            TNotify::OnNotify(Notify, ntInfo, TStr(&quot;...&quot;)+
952             TInt::GetStr(DocIdToWordDsH.Len())+&quot; Distrs.&quot;);
953          }
954        }
955      }
956      if (MxMissDss==-1){
957        if (--RepDocIters==0){RepDocIdH.AddKey(RootDocId);}
958      }
959      TStr OnWordDsStr=TStr(&quot;Missing distrs.: &quot;)+TInt::GetStr(MxMissDss)+&quot;;&quot;+
960       &quot; Docs.: &quot;+TInt::GetStr(DocIdToWordDsH.Len());
961      TNotify::OnNotify(Notify, ntInfo, OnWordDsStr);
962    }
963    TNotify::OnNotify(Notify, ntInfo, &quot;Create Overall Distribution&quot;);
964    int AllDocs=GetWordDs(RootDocId)-&gt;GetDocs();
965    int AllSects=GetWordDs(RootDocId)-&gt;GetSects();
966    AllWordDs=PYWordDs(new TYWordDs(AllDocs, AllSects, YBs-&gt;GetWords()));
967    {int WordId=YBs-&gt;FFirstWordId();
968    while (YBs-&gt;FNextWordId(WordId)){
969      AllWordDs-&gt;AddWordIdFq(WordId, YBs-&gt;GetWordFq(WordId));}}
970    AllWordDs-&gt;PowWordFq(WordFqExp);
971    AllWordDs=TYWordDs::GetTruncBySumWordPrb(AllWordDs, 0.9);
972    TNotify::OnNotify(Notify, ntInfo, &quot;Finished Creating Distributions&quot;);
973  }
974  void TYDsBs::SaveTxt(const PSOut&amp; SOut, const PYBs&amp; YBs){
975    AllWordDs-&gt;SaveTxt(SOut, YBs(), -1);
976    int DocIdToWordDsP=DocIdToWordDsH.FFirstKeyId();
977    while (DocIdToWordDsH.FNextKeyId(DocIdToWordDsP)){
978      int DocId=DocIdToWordDsH.GetKey(DocIdToWordDsP);
979      PYWordDs WordDs=DocIdToWordDsH[DocIdToWordDsP];
980      WordDs-&gt;SaveTxt(SOut, YBs(), DocId);
981    }
982  }
983  TStr TYDsBs::GetNrTypeStr(const TYDsBsNrType&amp; NrType){
984    switch (NrType){
985      case ydnConst: return &quot;Const&quot;;
986      case ydnWords: return &quot;Words&quot;;
987      case ydnLnWords: return &quot;LnWords&quot;;
988      case ydnSects: return &quot;Sects&quot;;
989      case ydnLnSects: return &quot;LnSects&quot;;
990      case ydnDocs: return &quot;Docs&quot;;
991      case ydnLnDocs: return &quot;LnDocs&quot;;
992      default: Fail; return TStr();
993    }
994  }
995  TYTsBs::TYTsBs(
996   const double&amp; AbsSectsPrb, const double&amp; SectPrb, const TStr&amp; TsWebBsFPath,
997   const PXWebBs&amp; RefWebBs, const PYBs&amp; RefYBs,
998   const PXWebTravelEvent&amp; WebTravelEvent, const PNotify&amp; Notify):
999    TsRefUrlStrH(1000), WebBs(), WebTravel(){
1000    IAssert((0&lt;=AbsSectsPrb)&amp;&amp;(AbsSectsPrb&lt;=1));
1001    if (AbsSectsPrb==1){
1002      TRnd Rnd;
1003      int DocId=RefYBs-&gt;FFirstDocId();
1004      while (RefYBs-&gt;FNextDocId(DocId)){
1005        if (RefYBs-&gt;GetDocRefbys(DocId)==0){continue;}
1006        TStr RefUrlStr=RefYBs-&gt;GetDocUrlStr(DocId);
1007        PXWebPg WebPg=RefWebBs-&gt;GetWebPg(RefUrlStr);
1008        TStrV UrlStrV; TYBs::GetAbsSectUrlStrV(WebPg, UrlStrV);
1009        for (int UrlStrN=0; UrlStrN&lt;UrlStrV.Len(); UrlStrN++){
1010          if (Rnd.GetUniDev()&lt;SectPrb){
1011            TsRefUrlStrH.AddDat(UrlStrV[UrlStrN], RefUrlStr);
1012          }
1013        }
1014      }
1015    } else {
1016      int TsDocs=int(AbsSectsPrb*RefYBs-&gt;GetAbsSects());
1017      TRnd Rnd;
1018      while (TsRefUrlStrH.Len()&lt;TsDocs){
1019        int DocId=Rnd.GetUniDevInt(RefYBs-&gt;GetDocs());
1020        if (RefYBs-&gt;GetDocRefbys(DocId)==0){continue;}
1021        TStr RefUrlStr=RefYBs-&gt;GetDocUrlStr(DocId);
1022        PXWebPg WebPg=RefWebBs-&gt;GetWebPg(RefUrlStr);
1023        TStrV UrlStrV; TYBs::GetAbsSectUrlStrV(WebPg, UrlStrV);
1024        if (UrlStrV.Len()==0){continue;}
1025        int UrlStrN=Rnd.GetUniDevInt(UrlStrV.Len());
1026        TStr TsUrlStr=UrlStrV[UrlStrN];
1027        TsRefUrlStrH.AddDat(TsUrlStr, RefUrlStr);
1028      }
1029    }
1030    TNotify::OnNotify(Notify, ntInfo,
1031     TStr(&quot;Loading &quot;)+TInt::GetStr(TsRefUrlStrH.Len())+&quot; Documents.&quot;);
1032    WebBs=PXWebBs(new TWebMemBs(100, TsWebBsFPath, true));
1033    WebTravel=PXWebTravel(new TXWebTravel(WebBs, WebTravelEvent));
1034    int TsSrcUrlStrP=TsRefUrlStrH.FFirstKeyId();
1035    while (TsRefUrlStrH.FNextKeyId(TsSrcUrlStrP)){
1036      TStr TsUrlStr=TsRefUrlStrH.GetKey(TsSrcUrlStrP);
1037      WebTravel-&gt;Go(TsUrlStr);
1038    }
1039  }
1040  TYTsBs::~TYTsBs(){
1041    int WebPgP=WebBs-&gt;FFirstWebPg(); int WebPgId;
1042    while (WebBs-&gt;FNextWebPg(WebPgP, WebPgId)){
1043      TStr TsUrlStr=WebBs-&gt;GetUrlStr(WebPgId);
1044      TStr RefUrlStr=TsRefUrlStrH.GetDat(TsUrlStr);
1045      WebBs-&gt;AddWebPgRef(TsUrlStr, RefUrlStr);
1046    }
1047  }
1048  TYHlCtx::TYHlCtx(
1049   const PXWebBs&amp; RefWebBs, const PYBs&amp; RefYBs, const PXWebBs&amp; DocWebBs,
1050   const PNotify&amp; &amp;bsol;*Notify*/): HlCtxStrV(){
1051    int RefDocId=RefYBs-&gt;FFirstDocId();
1052    while (RefYBs-&gt;FNextDocId(RefDocId)){
1053      TStr RefUrlStr=RefYBs-&gt;GetDocUrlStr(RefDocId);
1054      PXWebPg WebPg=RefWebBs-&gt;GetWebPg(RefUrlStr);
1055      TYSectV YSectV; RefYBs-&gt;GetAbsSectV(RefUrlStr, WebPg, YSectV);
1056      for (int YSectN=0; YSectN&lt;YSectV.Len(); YSectN++){
1057        PYSect YSect=YSectV[YSectN];
1058        if (DocWebBs-&gt;IsUrlStr(YSect-&gt;GetUrlStr())){
1059          HlCtxStrV.Add(YSect-&gt;GetTxtStr());}
1060      }
1061      if (HlCtxStrV.Len()&gt;500){break;}/&amp;bsol;**
1062    }
1063  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hldoc.cpp</h3>
            <pre><code>1  #include &quot;hldoc.h&quot;
2  #include &quot;yahooex.h&quot;
3  void THldWordDs::AddWordIdFq(const TIntFltKd&amp; WordIdFqKd){
4    double WordFq=WordIdFqKd.Dat;
5    if (WordFq&gt;0){
6      int WordIdN=WordIdFqKdV.SearchBin(WordIdFqKd);
7      SumWordFq+=WordFq;
8      if (WordIdN==-1){
9        WordIdFqKdV.AddSorted(WordIdFqKd);
10      } else {
11        WordIdFqKdV[WordIdN].Dat+=WordFq;
12      }
13    }
14  }
15  bool THldWordDs::FNextWordId(
16   int&amp; WordIdN, int&amp; WordId, double&amp; WordFq, double&amp; WordPrb) const {
17    WordIdN++;
18    if (WordIdN&lt;WordIdFqKdV.Len()){
19      WordId=WordIdFqKdV[WordIdN].Key;
20      WordFq=WordIdFqKdV[WordIdN].Dat;
21      WordPrb=WordFq/SumWordFq;
22      return true;
23    } else {
24      return false;
25    }
26  }
27  void THldWordDs::NrToSumWordFq(const double&amp; NrSumWordFq){
28    if (SumWordFq!=NrSumWordFq){
29      double NrRatio=(double(SumWordFq)==0) ? 0 : NrSumWordFq/SumWordFq;
30      SumWordFq=NrSumWordFq;
31      if (SumWordFq&gt;0){
32        for (int WordIdN=0; WordIdN&lt;WordIdFqKdV.Len(); WordIdN++){
33          WordIdFqKdV[WordIdN].Dat=WordIdFqKdV[WordIdN].Dat*NrRatio;}
34      }
35    }
36  }
37  void THldWordDs::PowWordFq(const double&amp; Exp){
38    if (SumWordFq&gt;0){
39      SumWordFq=0;
40      for (int WordIdN=0; WordIdN&lt;WordIdFqKdV.Len(); WordIdN++){
41        SumWordFq+=WordIdFqKdV[WordIdN].Dat=pow(WordIdFqKdV[WordIdN].Dat, Exp);
42      }
43    }
44  }
45  void THldWordDs::SaveTxt(const PSOut&amp; SOut, const PHldBs&amp; HldBs){
46    TFltIntKdV WordFqIdKdV(WordIdFqKdV.Len(), 0);
47    for (int WordIdN=0; WordIdN&lt;WordIdFqKdV.Len(); WordIdN++){
48      int WordId=WordIdFqKdV[WordIdN].Key;
49      double WordFq=WordIdFqKdV[WordIdN].Dat/SumWordFq;
50      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
51    }
52    WordFqIdKdV.Sort(false);
53    IAssert(WordFqIdKdV.IsSorted(false));
54    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
55    Lx.PutVarFlt(&quot;SumWordFq&quot;, SumWordFq);
56    Lx.PutVar(&quot;WordIdFqKdV&quot;, true, true);
57    {for (int WordIdN=0; WordIdN&lt;WordFqIdKdV.Len(); WordIdN++){
58      int WordId=WordFqIdKdV[WordIdN].Dat;
59      double WordFq=WordFqIdKdV[WordIdN].Key;
60      if (HldBs.Empty()){Lx.PutInt(WordId);}
61      else {Lx.PutQStr(HldBs-&gt;GetWordStr(WordId));}
62      Lx.PutFlt(WordFq); Lx.PutLn();
63    }}
64    Lx.PutSym(syRBracket); Lx.PutLn();
65  }
66  PHldWordDs THldWordDs::GetMerged(
67   const PHldWordDs&amp; LWordDs, const PHldWordDs&amp; RWordDs){
68    TIntFltKdV&amp; LWordIdFqKdV=LWordDs-&gt;WordIdFqKdV;
69    TIntFltKdV&amp; RWordIdFqKdV=RWordDs-&gt;WordIdFqKdV;
70    int LWordIds=LWordDs-&gt;GetWordIds();
71    int RWordIds=RWordDs-&gt;GetWordIds();
72    double LSumWordFq=LWordDs-&gt;GetSumWordFq();
73    double RSumWordFq=RWordDs-&gt;GetSumWordFq();
74    PHldWordDs WordDs=new THldWordDs(LWordIds+RWordIds);
75    int LWordIdN=0; int RWordIdN=0;
76    if ((LSumWordFq&gt;0)&amp;&amp;(RSumWordFq&gt;0)){
77      while ((LWordIdN&lt;LWordIds)&amp;&amp;(RWordIdN&lt;RWordIds)){
78        TIntFltKd&amp; LWordIdFqKd=LWordIdFqKdV[LWordIdN];
79        TIntFltKd&amp; RWordIdFqKd=RWordIdFqKdV[RWordIdN];
80        if (LWordIdFqKd==RWordIdFqKd){
81          double LFq=LWordIdFqKd.Dat;
82          double RFq=RWordIdFqKd.Dat;
83          WordDs-&gt;AddWordIdFq(LWordIdFqKd.Key, LFq+RFq); LWordIdN++; RWordIdN++;
84        } else
85        if (LWordIdFqKd&lt;RWordIdFqKd){
86          double LFq=LWordIdFqKd.Dat;
87          WordDs-&gt;AddWordIdFq(LWordIdFqKd.Key, LFq); LWordIdN++;
88        } else {
89          double RFq=RWordIdFqKd.Dat;
90          WordDs-&gt;AddWordIdFq(RWordIdFqKd.Key, RFq); RWordIdN++;
91        }
92      }
93    }
94    if (LSumWordFq&gt;0){
95      while (LWordIdN&lt;LWordIds){
96        TIntFltKd&amp; LWordIdFqKd=LWordIdFqKdV[LWordIdN];
97        double LFq=LWordIdFqKd.Dat;
98        WordDs-&gt;AddWordIdFq(LWordIdFqKd.Key, LFq);
99        LWordIdN++;
100      }
101    }
102    if (RSumWordFq&gt;0){
103      while (RWordIdN&lt;RWordIds){
104        TIntFltKd&amp; RWordIdFqKd=RWordIdFqKdV[RWordIdN];
105        double RFq=RWordIdFqKd.Dat;
106        WordDs-&gt;AddWordIdFq(RWordIdFqKd.Key, RFq);
107        RWordIdN++;
108      }
109    }
110    return WordDs;
111  }
112  PHldWordDs THldWordDs::GetTruncByMxWords(
113   const PHldWordDs&amp; WordDs, const int&amp; MxWords){
114    TFltIntKdV WordFqIdKdV(WordDs-&gt;WordIdFqKdV.Len(), 0);
115    for (int WordIdN=0; WordIdN&lt;WordDs-&gt;WordIdFqKdV.Len(); WordIdN++){
116      int WordId=WordDs-&gt;WordIdFqKdV[WordIdN].Key;
117      double WordFq=WordDs-&gt;WordIdFqKdV[WordIdN].Dat;
118      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
119    }
120    WordFqIdKdV.Sort(false);
121    int TruncWordIds=TInt::GetMn(MxWords, WordDs-&gt;GetWordIds());
122    PHldWordDs TruncWordDs=PHldWordDs(new THldWordDs(TruncWordIds));
123    for (int WordIdN=0; WordIdN&lt;TruncWordIds; WordIdN++){
124      double WordFq=WordFqIdKdV[WordIdN].Key;
125      int WordId=WordFqIdKdV[WordIdN].Dat;
126      TruncWordDs-&gt;AddWordIdFq(WordId, WordFq);
127    }
128    return TruncWordDs;
129  }
130  double THldWordDs::GetDist(
131   const PHldWordDs&amp; LWordDs, const PHldWordDs&amp; RWordDs,
132   const PHldBs&amp; &amp;bsol;*HldBs*/){
133    TIntFltKdV&amp; LWordIdFqKdV=LWordDs-&gt;WordIdFqKdV;
134    TIntFltKdV&amp; RWordIdFqKdV=RWordDs-&gt;WordIdFqKdV;
135    int LWordIds=LWordIdFqKdV.Len();
136    int RWordIds=RWordIdFqKdV.Len();
137    double Dist=0;
138    int LWordIdN=0; int RWordIdN=0;
139    while ((LWordIdN&lt;LWordIds)&amp;&amp;(RWordIdN&lt;RWordIds)){
140      TIntFltKd&amp; LWordIdFqKd=LWordIdFqKdV[LWordIdN];
141      TIntFltKd&amp; RWordIdFqKd=RWordIdFqKdV[RWordIdN];
142      if (LWordIdFqKd==RWordIdFqKd){
143        Dist++;
144        LWordIdN++; RWordIdN++;
145      } else
146      if (LWordIdFqKd&lt;RWordIdFqKd){
147        LWordIdN++;
148      } else {
149        RWordIdN++;
150      }
151    }
152    Dist=1-Dist/(sqrt(LWordIdFqKdV.Len())*sqrt(RWordIdFqKdV.Len()));
153    return Dist;
154  }
155  void THldWordDs::GetHypTsEst(
156   const PHldWordDs&amp; RefWordDs, const PHldWordDs&amp; HypWordDs,
157   double&amp; Precis, double&amp; Recall, double&amp; Dist, double&amp; F2){
158    int RefWordIds=0; int IntsWordIds=0;
159    int WordIdN=RefWordDs-&gt;FFirstWordId(); int WordId; double WordFq; double WordPrb;
160    while (RefWordDs-&gt;FNextWordId(WordIdN, WordId, WordFq, WordPrb)){
161      if (HypWordDs-&gt;IsWordId(WordId)){IntsWordIds++;}
162      RefWordIds++;
163    }
164    int HypWordIds=HypWordDs-&gt;GetWordIds();
165    PHldWordDs RefHypWordDs=THldWordDs::GetMerged(RefWordDs, HypWordDs);
166    if ((RefWordIds==0)||(HypWordIds==0)){
167      Precis=1; Recall=1; Dist=1;
168    } else {
169      Precis=IntsWordIds/double(HypWordIds);
170      Recall=IntsWordIds/double(RefWordIds);
171      Dist=1-IntsWordIds/(sqrt(HypWordIds)*sqrt(RefWordIds));
172    }
173    if (Precis+Recall&gt;0){F2=(5*Precis*Recall)/(4*Precis+Recall);}
174  }
175  THldWord::THldWord(THldBs* _HldBs, const TStr&amp; Str):
<span onclick='openModal()' class='match'>176    HldBs(_HldBs), FirstChN(HldBs-&gt;WordChAHeap.Len()){
177    HldBs-&gt;WordChAHeap+=Str; HldBs-&gt;WordChAHeap+=CrCh;
</span>178  }
179  TStr THldWord::GetStr() const {
180    TChA ChA; int ChN=FirstChN;
181    while (HldBs-&gt;WordChAHeap[ChN]!=CrCh){
182      ChA+=HldBs-&gt;WordChAHeap[ChN++];}
183    return ChA;
184  }
185  void THldBs::PutThisToWord(){
186    int WordToFqP=WordToFqH.FFirstKeyId();
187    while (WordToFqH.FNextKeyId(WordToFqP)){
188      WordToFqH.GetKey(WordToFqP).HldBs=this;
189    }
190  }
191  TStr THldBs::GetStrQStr(const TStrQ&amp; StrQ, const int&amp; Strs){
192    TChA ChA;
193    int FirstStrN=(Strs==-1) ? 0 : StrQ.Len()-Strs;
194    for (int StrN=FirstStrN; StrN&lt;StrQ.Len(); StrN++){
195      if (!ChA.Empty()){ChA+=&#x27; &#x27;;} ChA+=StrQ[StrN];
196    }
197    return ChA;
198  }
199  THldBs::THldBs(
200   const TStrV&amp; HlCtxStrV, const PXWebBs&amp; WebBs,
201   const int&amp; _MxNGram, const int&amp; _MnWordFq,
202   const TSwSetTy&amp; SwSetTy, const PNotify&amp; _Notify):
203    MxNGram(_MxNGram), MnWordFq(_MnWordFq),
204    SwSet(new TSwSet(SwSetTy)),
205    WordToFqH(100000), WordChAHeap(1000000),
206    WordIdVHeap(100000, 0), DocIdToUrlStrH(50000),
207    HlDocV(), Notify(_Notify){
208    TIntPrV HlCtxWebPgPrV(HlCtxStrV.Len(), 0);
209    for (int HlCtxStrN=0; HlCtxStrN&lt;HlCtxStrV.Len(); HlCtxStrN++){
210      TStr UrlStr=GetUrlStrFromHlCtxStr(HlCtxStrV[HlCtxStrN]);
211      IAssert(WebBs-&gt;IsUrlStr(UrlStr));
212      int WebPgId=WebBs-&gt;GetWebPgId(UrlStr);
213      HlCtxWebPgPrV.Add(TIntPr(HlCtxStrN, WebPgId));
214    }
215    TNotify::OnNotify(Notify, ntInfo, &quot;Start Generation N-Grams&quot;);
216    for (int NGram=1; NGram&lt;=MxNGram; NGram++){
217      int Hlds=0;
218      for (int HlCtxWebPgN=0; HlCtxWebPgN&lt;HlCtxWebPgPrV.Len(); HlCtxWebPgN++){
219        int HlCtxStrN=HlCtxWebPgPrV[HlCtxWebPgN].Val1;
220        int WebPgId=HlCtxWebPgPrV[HlCtxWebPgN].Val2;
221        TStr HlCtxStr=HlCtxStrV[HlCtxStrN];
222        TStr WebPgStr=WebBs-&gt;GetBodyStr(WebPgId);
223        AddTxt(HlCtxStr, false, NGram);
224        AddTxt(WebPgStr, false, NGram);
225        if (++Hlds%100==0){
226          TStr DocProcStr=TStr(&quot;...&quot;)+TInt::GetStr(Hlds)+&quot; Documents; &quot;+
227           TInt::GetStr(GetWords())+&quot; N-Grams&quot;;
228          TNotify::OnNotify(Notify, ntInfo, DocProcStr);
229        }
230      }
231      TStr NGramGenStr=TInt::GetStr(NGram)+&quot;-Grams Generated (&quot;+
232       TInt::GetStr(GetWords())+&quot;)&quot;;
233      TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
234      TStrIntPrV WordStrFqPrV(WordToFqH.Len(), 0);
235      int WordId=WordToFqH.FFirstKeyId();
236      while (WordToFqH.FNextKeyId(WordId)){
237        if (WordToFqH[WordId]&gt;=MnWordFq){
238          WordStrFqPrV.Add(TStrIntPr(GetWordStr(WordId), TInt(GetWordFq(WordId))));}
239      }
240      WordToFqH.Clr(); WordChAHeap.Clr();
241      for (int WordN=0; WordN&lt;WordStrFqPrV.Len(); WordN++){
242        AddWord(WordStrFqPrV[WordN].Val1)=WordStrFqPrV[WordN].Val2;}
243      TStr NGramReduceStr=TInt::GetStr(NGram)+&quot;-Grams Reduced (&quot;+
244       TInt::GetStr(GetWords())+&quot;)&quot;;
245      TNotify::OnNotify(Notify, ntInfo, NGramReduceStr);
246    }
247    TStr NGramGenStr=TInt::GetStr(MxNGram)+&quot;-Grams Generation Finished (&quot;+
248     TInt::GetStr(GetWords())+&quot;)&quot;;
249    TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
250    TNotify::OnNotify(Notify, ntInfo, &quot;Start Processing Documents&quot;);
251    HlDocV.Gen(HlCtxWebPgPrV.Len(), 0);
252    int Hlds=0;
253    THash&lt;TStr, TInt&gt; UrlStrToDocIdH(HlCtxWebPgPrV.Len());
254    for (int HlCtxWebPgN=0; HlCtxWebPgN&lt;HlCtxWebPgPrV.Len(); HlCtxWebPgN++){
255      int HlCtxStrN=HlCtxWebPgPrV[HlCtxWebPgN].Val1;
256      int WebPgId=HlCtxWebPgPrV[HlCtxWebPgN].Val2;
257      TStr HlCtxStr=HlCtxStrV[HlCtxStrN];
258      TStr WebPgStr=WebBs-&gt;GetBodyStr(WebPgId);
259      TStr UrlStr=WebBs-&gt;GetUrlStr(WebPgId);
260      int HlId=AddTxt(HlCtxStr, true, -1);
261      int DocId;
262      if (UrlStrToDocIdH.IsKey(UrlStr)){
263        DocId=UrlStrToDocIdH.GetDat(UrlStr);
264      } else {
265        DocId=AddTxt(WebPgStr, true, -1);
266        UrlStrToDocIdH.AddDat(UrlStr, DocId);
267        DocIdToUrlStrH.AddDat(DocId, UrlStr);
268      }
269      PHldWordDs HlWordDs=GetTxtWordDs(HlId);
270      HlDocV.Add(THlDoc(HlId, DocId, HlWordDs));
271      if (++Hlds%100==0){
272        TStr DocProcStr=TInt::GetStr(Hlds)+&quot; Documents Processed&quot;;
273        TNotify::OnNotify(Notify, ntInfo, DocProcStr);
274      }
275    }
276    TStr DocProcStr=TStr(&quot;HyperLinkDocument Processing Finished (&quot;)+
277     TInt::GetStr(HlDocV.Len())+&quot;)&quot;;
278    TNotify::OnNotify(Notify, ntInfo, DocProcStr);
279  }
280  TInt&amp; THldBs::AddWord(const TStr&amp; WordStr){
281    int PrevLen=WordChAHeap.Len();
282    THldWord Word(this, WordStr);
283    int WordId=WordToFqH.GetKeyId(Word);
284    if (WordId==-1){
285      return WordToFqH.AddDat(Word);
286    } else {
287      WordChAHeap.Trunc(PrevLen);
288      return WordToFqH[WordId];
289    }
290  }
291  int THldBs::GetWordId(const TStr&amp; WordStr){
292    int PrevLen=WordChAHeap.Len();
293    THldWord Word(this, WordStr);
294    int WordId=WordToFqH.GetKeyId(Word);
295    WordChAHeap.Trunc(PrevLen);
296    return WordId;
297  }
298  int THldBs::AddTxt(const TStr&amp; TxtStr, const bool&amp; DoGenDoc, const int&amp; NGram){
299    int TxtId=-1;
300    TIntV TxtWordIdV;
301    if (DoGenDoc){
302      IAssert(NGram==-1);
303      TxtWordIdV.Gen(1000, 0);
304    }
305    PSIn SIn=TStrIn::New(TxtStr);
306    PHtmlDoc HtmlDoc=PHtmlDoc(new THtmlDoc(SIn, hdtAll));
307    PHtmlTok Tok; THtmlLxSym Sym=hlsyUndef; TStr Str; TStrQ PrevStrQ;
308    for (int TokN=0; TokN&lt;HtmlDoc-&gt;GetToks(); TokN++){
309      Tok=HtmlDoc-&gt;GetTok(TokN, Sym, Str);
310      switch (Sym){
311        case hlsyStr:
312          if (DoGenDoc){
313            if (!SwSet-&gt;IsIn(Str)){
314              int WordId=GetWordId(Str);
315              if (WordId!=-1){
316                TxtWordIdV.Add(WordId);
317                PrevStrQ.Push(Str);
318                int NGram=2;
319                while ((NGram&lt;=MxNGram)&amp;&amp;(NGram&lt;=PrevStrQ.Len())){
320                  int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
321                  if (WordId==-1){
322                    while (PrevStrQ.Len()&gt;=NGram){PrevStrQ.Pop();} break;
323                  } else {
324                    TxtWordIdV.Add(WordId);
325                  }
326                  NGram++;
327                }
328              } else {
329                PrevStrQ.Clr();
330              }
331            }
332          } else {
333            if (NGram==1){
334              if (!SwSet-&gt;IsIn(Str)){AddWord(Str)++;}
335            } else {
336              if (!SwSet-&gt;IsIn(Str)){
337                int WordId=GetWordId(Str);
338                if (WordId!=-1){
339                  TStr WordStr=GetWordStr(WordId);
340                  if (PrevStrQ.Len()+1==NGram){
341                    if (GetWordId(GetStrQStr(PrevStrQ))!=-1){
342                      PrevStrQ.Push(WordStr);
343                      AddWord(GetStrQStr(PrevStrQ))++;
344                      PrevStrQ.Pop();
345                    } else {
346                      PrevStrQ.Push(WordStr); PrevStrQ.Pop();
347                    }
348                  } else {
349                    PrevStrQ.Push(WordStr);
350                  }
351                } else {
352                  PrevStrQ.Clr();
353                }
354              }
355            }
356          }
357          break;
358        case hlsyNum:
359        case hlsySSym:
360          PrevStrQ.Clr(); break;
361        case hlsyBTag:
362        case hlsyETag:
363          if (THtmlTok::IsBreakTag(Str)){PrevStrQ.Clr();} break;
364        default:;
365      }
366    }
367    if (DoGenDoc){
368      TxtId=WordIdVHeap.Len();
369      WordIdVHeap.AddV(TxtWordIdV); WordIdVHeap.Add(TInt(-1));
370    }
371    return TxtId;
372  }
373  int THldBs::GetTxtLen(const int&amp; TxtId){
374    int WordIdN=TxtId; int TxtLen=0;
375    while (WordIdVHeap[WordIdN]!=-1){WordIdN++; TxtLen++;}
376    return TxtLen;
377  }
378  PHldWordDs THldBs::GetTxtWordDs(const int&amp; TxtId){
379    PHldWordDs WordDs=PHldWordDs(new THldWordDs(GetTxtLen(TxtId)));
380    int WordIdN=TxtId;
381    while (WordIdVHeap[WordIdN]!=-1){
382      int WordId=WordIdVHeap[WordIdN++];
383      WordDs-&gt;AddWordIdFq(WordId, 1);
384    }
385    return WordDs;
386  }
387  PHldWordDs THldBs::GetWordDs(const PSIn&amp; SIn){
388    PHldWordDs WordDs=PHldWordDs(new THldWordDs());
389    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtAll);
390    PHtmlTok Tok; THtmlLxSym Sym; TStr Str; TStrQ PrevStrQ;
391    for (int TokN=0; TokN&lt;HtmlDoc-&gt;GetToks(); TokN++){
392      Tok=HtmlDoc-&gt;GetTok(TokN, Sym, Str);
393      switch (Sym){
394        case hlsyStr:
395          if (!SwSet-&gt;IsIn(Str)){
396            int WordId=GetWordId(Str);
397            if (WordId!=-1){
398              WordDs-&gt;AddWordIdFq(WordId, 1);
399              PrevStrQ.Push(Str);
400              int NGram=2;
401              while ((NGram&lt;=MxNGram)&amp;&amp;(NGram&lt;=PrevStrQ.Len())){
402                int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
403                if (WordId==-1){
404                  while (PrevStrQ.Len()&gt;=NGram){PrevStrQ.Pop();} break;
405                } else {
406                  WordDs-&gt;AddWordIdFq(WordId, 1);
407                }
408                NGram++;
409              }
410            } else {
411              PrevStrQ.Clr();
412            }
413          }
414          break;
415        case hlsyNum:
416        case hlsySSym:
417          PrevStrQ.Clr(); break;
418        case hlsyBTag:
419        case hlsyETag:
420          if (THtmlTok::IsBreakTag(Str)){PrevStrQ.Clr();} break;
421        default:;
422      }
423    }
424    return WordDs;
425  }
426  void THldBs::GetDistHlDocNV(
427   const int&amp; KNNbrs, const bool&amp; RndSel,
428   const PHldWordDs&amp; RefHlWordDs, const TStrV&amp; SelUrlStrV,
429   TFltIntKdV&amp; DistHlDocNKdV){
430    DistHlDocNKdV.Clr();
431    for (int HlDocN=0; HlDocN&lt;GetHlDocs(); HlDocN++){
432      if (SelUrlStrV.Len()&gt;0){
433        if (SelUrlStrV.SearchBin(GetDocUrlStr(HlDocN))==-1){continue;}}
434      PHldWordDs HlWordDs=GetHlWordDs(HlDocN);
435      double Dist=THldWordDs::GetDist(RefHlWordDs, HlWordDs, this);
436      if (RndSel){
437        DistHlDocNKdV.Add(TFltIntKd(Dist, HlDocN));
438      } else {
439        DistHlDocNKdV.AddSorted(TFltIntKd(Dist, HlDocN), true, KNNbrs);
440      }
441    }
442    if (RndSel){
443      TRnd Rnd(TRnd::RndSeed);
444      DistHlDocNKdV.Shuffle(Rnd);
445      int Docs=TInt::GetMn(DistHlDocNKdV.Len(), KNNbrs);
446      DistHlDocNKdV.Reserve(Docs, Docs);
447    }
448  }
449  PHldWordDs THldBs::GetHypDocWordDs(const TFltIntKdV&amp; DistHlDocNKdV){
450    PHldWordDs HypWordDs=PHldWordDs(new THldWordDs());
451    PMom HypDocLenMom=PMom(new TMom());
452    for (int DistHlDocNKdN=0; DistHlDocNKdN&lt;DistHlDocNKdV.Len(); DistHlDocNKdN++){
453      int HlDocN=DistHlDocNKdV[DistHlDocNKdN].Dat;
454      PHldWordDs DocWordDs=GetDocWordDs(HlDocN);
455      HypWordDs=THldWordDs::GetMerged(HypWordDs, DocWordDs);
456      HypDocLenMom-&gt;Add(GetTxtLen(GetDocId(HlDocN)));
457    }
458    HypDocLenMom-&gt;Def();
459    int HypDocLen=int(HypDocLenMom-&gt;GetMean());
460    HypWordDs=THldWordDs::GetTruncByMxWords(HypWordDs, HypDocLen);
461    return HypWordDs;
462  }
463  void THldBs::SaveTxt(const PSOut&amp; SOut){
464    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
465    for (int HlDocN=0; HlDocN&lt;HlDocV.Len(); HlDocN++){
466      int HlId=HlDocV[HlDocN].GetHlId();
467      int DocId=HlDocV[HlDocN].GetDocId();
468      PHldWordDs HlWordDs=HlDocV[HlDocN].GetHlWordDs();
469      TStr UrlStr=DocIdToUrlStrH.GetDat(DocId);
470      Lx.PutVarStr(&quot;UrlStr&quot;, UrlStr);
471      Lx.PutVar(&quot;Hl&quot;, true, true);
472      int HlWordIdN=HlId; TChA HlWordLn;
473      while (WordIdVHeap[HlWordIdN]!=-1){
474        TStr WordStr=GetWordStr(WordIdVHeap[HlWordIdN++]);
475        if (WordStr.SearchCh(&#x27; &#x27;)==-1){HlWordLn+=WordStr;}
476        else {HlWordLn+=&#x27;(&#x27;; HlWordLn+=WordStr; HlWordLn+=&#x27;)&#x27;;}
477        HlWordLn+=&#x27; &#x27;;
478        if (HlWordLn.Len()&gt;50){
479          Lx.PutQStr(HlWordLn); Lx.PutLn(); HlWordLn.Clr();}
480      }
481      if (!HlWordLn.Empty()){Lx.PutQStr(HlWordLn); Lx.PutLn();}
482      Lx.PutSym(syRBracket); Lx.PutLn();
483      Lx.PutVar(&quot;Doc&quot;, true, true);
484      int DocWordIdN=DocId; TChA DocWordLn;
485      while (WordIdVHeap[DocWordIdN]!=-1){
486        TStr WordStr=GetWordStr(WordIdVHeap[DocWordIdN++]);
487        if (WordStr.SearchCh(&#x27; &#x27;)==-1){DocWordLn+=WordStr;}
488        else {DocWordLn+=&#x27;(&#x27;; DocWordLn+=WordStr; DocWordLn+=&#x27;)&#x27;;}
489        DocWordLn+=&#x27; &#x27;;
490        if (DocWordLn.Len()&gt;50){
491          Lx.PutQStr(DocWordLn); Lx.PutLn(); DocWordLn.Clr();}
492      }
493      if (!DocWordLn.Empty()){Lx.PutQStr(DocWordLn); Lx.PutLn();}
494      Lx.PutSym(syRBracket); Lx.PutLn();
495      HlWordDs-&gt;SaveTxt(SOut, this);
496    }
497    Lx.PutVar(&quot;WordFqIdKdV&quot;, true, true);
498    TIntKdV WordFqIdKdV;
499    int WordToFqP=WordToFqH.FFirstKeyId();
500    while (WordToFqH.FNextKeyId(WordToFqP)){
501      int WordId=WordToFqP;
502      int WordFq=WordToFqH[WordToFqP];
503      WordFqIdKdV.Add(TIntKd(WordFq, WordId));
504    }
505    WordFqIdKdV.Sort(false);
506    for (int WordFqIdKdN=0; WordFqIdKdN&lt;WordFqIdKdV.Len(); WordFqIdKdN++){
507      int WordFq=WordFqIdKdV[WordFqIdKdN].Key;
508      TStr WordStr=GetWordStr(WordFqIdKdV[WordFqIdKdN].Dat);
509      Lx.PutStr(WordStr); Lx.PutSym(syColon); Lx.PutInt(WordFq); Lx.PutLn();
510    }
511    Lx.PutSym(syRBracket); Lx.PutLn();
512  }
513  TStr THldBs::GetUrlStrFromHlCtxStr(const TStr&amp; HlCtxStr){
514    PSIn SIn=TStrIn::New(HlCtxStr);
515    PHtmlDoc HtmlDoc=THtmlDoc::New(SIn, hdtA);
516    PHtmlTok Tok=HtmlDoc-&gt;GetTok(0);
517    IAssert((Tok-&gt;GetSym()==hlsyBTag)&amp;&amp;(Tok-&gt;GetStr()==THtmlTok::ATagNm));
518    TStr HRefStr=Tok-&gt;GetArg(THtmlTok::HRefArgNm);
519    PUrl Url=TUrl::New(HRefStr);
520    return Url-&gt;GetUrlStr();
521  }
522  void THldExpr::PutMomHd(TOLx&amp; Lx, const TStr&amp; VarNm){
523    Lx.PutUQStr(VarNm+&quot;Mean&quot;); Lx.PutUQStr(VarNm+&quot;SDev&quot;);
524    Lx.PutUQStr(VarNm+&quot;SErr&quot;); Lx.PutUQStr(VarNm+&quot;Med&quot;);
525    Lx.PutUQStr(VarNm+&quot;Q1&quot;); Lx.PutUQStr(VarNm+&quot;Q3&quot;);
526  }
527  void THldExpr::PutMomVal(TOLx&amp; Lx, const PMom&amp; Mom){
528    if (Mom-&gt;IsUsable()){
529      Lx.PutFlt(Mom-&gt;GetMean()); Lx.PutFlt(Mom-&gt;GetSDev());
530      Lx.PutFlt(Mom-&gt;GetSErr()); Lx.PutFlt(Mom-&gt;GetMedian());
531      Lx.PutFlt(Mom-&gt;GetQuart1()); Lx.PutFlt(Mom-&gt;GetQuart3());
532    } else {
533      for (int MomN=0; MomN&lt;6; MomN++){Lx.PutFlt(-1);}
534    }
535  }
536  void THldExpr::Go(
537   const PSOut&amp; SOut, const bool&amp; PutHd, const bool&amp; SaveTmp,
538   const TStr&amp; HldDmNm, const int&amp; TsRuns,
539   const TStrV&amp; AllHlCtxStrV, const PXWebBs&amp; DocWebBs,
540   const int&amp; MxNGram, const int&amp; MnWordFq, const TSwSetTy&amp; SwSetTy,
541   const int&amp; KNNbrs, const bool&amp; RndSel,
542   const PNotify&amp; Notify){
543    PSOut LogSOut=new TFOut(&quot;log.t&quot;);
544    TOLx LogLx(LogSOut, TFSet()|oloFrcEoln|oloSigNum);
545    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
546    if (PutHd){
547      Lx.PutUQStr(&quot;DmNm&quot;); Lx.PutUQStr(&quot;TsRunN&quot;);
548      Lx.PutUQStr(&quot;KNNbrs&quot;);
549      Lx.PutUQStr(&quot;RndSel&quot;);
550      PutMomHd(Lx, &quot;HldPrecis&quot;);
551      PutMomHd(Lx, &quot;HldRecall&quot;);
552      PutMomHd(Lx, &quot;HldDist&quot;);
553      PutMomHd(Lx, &quot;HldF2&quot;);
554      PutMomHd(Lx, &quot;HlLen&quot;);
555      PutMomHd(Lx, &quot;DocLen&quot;);
556      PutMomHd(Lx, &quot;HypDocLen&quot;);
557      PutMomHd(Lx, &quot;YHldPrecis&quot;);
558      PutMomHd(Lx, &quot;YHldRecall&quot;);
559      Lx.PutLn();
560    }
561    TRnd Rnd;
562    TStrV ShHlCtxStrV=AllHlCtxStrV; ShHlCtxStrV.Shuffle(Rnd);
563    for (int TsRunN=0; TsRunN&lt;TsRuns; TsRunN++){
564      TStrV TrHlCtxStrV; TStrV TsHlCtxStrV;
565      for (int ShHlCtxStrN=0; ShHlCtxStrN&lt;ShHlCtxStrV.Len(); ShHlCtxStrN++){
566        if (ShHlCtxStrN%TsRuns==TsRunN){
567          TsHlCtxStrV.Add(ShHlCtxStrV[ShHlCtxStrN]);
568        } else {
569          TrHlCtxStrV.Add(ShHlCtxStrV[ShHlCtxStrN]);
570        }
571      }
572      PHldBs HldBs=PHldBs(new THldBs(
573       TrHlCtxStrV, DocWebBs, MxNGram, MnWordFq, SwSetTy, Notify));
574      if (SaveTmp){
575        TFOut FOut(&quot;HldBsRef.Dat&quot;);
576        HldBs-&gt;Save(FOut);
577        HldBs-&gt;SaveTxt(PSOut(new TFOut(&quot;hldRef.t&quot;)));
578      }
579      PMom HldPrecisMom=PMom(new TMom());
580      PMom HldRecallMom=PMom(new TMom());
581      PMom HldDistMom=PMom(new TMom());
582      PMom HldF2Mom=PMom(new TMom());
583      PMom HlLenMom=PMom(new TMom());
584      PMom DocLenMom=PMom(new TMom());
585      PMom HypDocLenMom=PMom(new TMom());
586      PMom YHldPrecisMom=PMom(new TMom());
587      PMom YHldRecallMom=PMom(new TMom());
588      for (int TsHlCtxStrN=0; TsHlCtxStrN&lt;TsHlCtxStrV.Len(); TsHlCtxStrN++){
589        TStr TsHlCtxStr=TsHlCtxStrV[TsHlCtxStrN];
590        LogLx.PutVarStr(&quot;TsHlCtxStr&quot;, TsHlCtxStr);
591        {TStr UrlStr=THldBs::GetUrlStrFromHlCtxStr(TsHlCtxStr);
592        TStr WebPgStr=DocWebBs-&gt;GetBodyStr(UrlStr);
593        PHldWordDs TsHlWordDs=HldBs-&gt;GetWordDs(TsHlCtxStr);
594        PHldWordDs TsDocWordDs=HldBs-&gt;GetWordDs(WebPgStr);
595        TFltIntKdV DistHlDocNKdV;
596        HldBs-&gt;GetDistHlDocNV(KNNbrs, RndSel, TsHlWordDs, TStrV(), DistHlDocNKdV);
597        if (SaveTmp){
598          for (int DistHlDocNKdN=0; DistHlDocNKdN&lt;DistHlDocNKdV.Len(); DistHlDocNKdN++){
599            double Dist=DistHlDocNKdV[DistHlDocNKdN].Key;
600            TStr UrlStr=HldBs-&gt;GetDocUrlStr(DistHlDocNKdV[DistHlDocNKdN].Dat);
601            LogLx.PutVarStr(&quot;UrlStr&quot;, TFlt::GetStr(Dist)+&quot; &quot;+UrlStr);
602          }
603        }
604        PHldWordDs HypDocWordDs=HldBs-&gt;GetHypDocWordDs(DistHlDocNKdV);
605        double Precis; double Recall; double Dist; double F2;
606        THldWordDs::GetHypTsEst(TsDocWordDs, HypDocWordDs, Precis, Recall, Dist, F2);
607        HldPrecisMom-&gt;Add(Precis); HldRecallMom-&gt;Add(Recall);
608        HldDistMom-&gt;Add(Dist); HldF2Mom-&gt;Add(F2);
609        double HlLen=TsHlWordDs-&gt;GetWordIds(); HlLenMom-&gt;Add(HlLen);
610        double DocLen=TsDocWordDs-&gt;GetWordIds(); DocLenMom-&gt;Add(DocLen);
611        double HypDocLen=HypDocWordDs-&gt;GetWordIds(); HypDocLenMom-&gt;Add(HypDocLen);
612        if (SaveTmp){
613          LogLx.PutVarFlt(&quot;Precis&quot;, Precis);
614          LogLx.PutVarFlt(&quot;Recall&quot;, Recall);
615          LogLx.PutVarFlt(&quot;Dist&quot;, Dist);
616          LogLx.PutVarFlt(&quot;F2&quot;, F2);
617          LogLx.PutVarFlt(&quot;HlLen&quot;, HlLen);
618          LogLx.PutVarFlt(&quot;DocLen&quot;, DocLen);
619          LogLx.PutVarFlt(&quot;HypDocLen&quot;, HypDocLen);
620        }}
621        if (SaveTmp){LogLx.PutLn();}
622      }
623      HldPrecisMom-&gt;Def();
624      HldRecallMom-&gt;Def();
625      HldDistMom-&gt;Def();
626      HldF2Mom-&gt;Def();
627      HlLenMom-&gt;Def();
628      DocLenMom-&gt;Def();
629      HypDocLenMom-&gt;Def();
630      YHldPrecisMom-&gt;Def();
631      YHldRecallMom-&gt;Def();
632      Lx.PutStr(HldDmNm); Lx.PutInt(TsRunN);
633      Lx.PutInt(KNNbrs);
634      Lx.PutBool(RndSel);
635      PutMomVal(Lx, HldPrecisMom);
636      PutMomVal(Lx, HldRecallMom);
637      PutMomVal(Lx, HldDistMom);
638      PutMomVal(Lx, HldF2Mom);
639      PutMomVal(Lx, HlLenMom);
640      PutMomVal(Lx, DocLenMom);
641      PutMomVal(Lx, HypDocLenMom);
642      PutMomVal(Lx, YHldPrecisMom);
643      PutMomVal(Lx, YHldRecallMom);
644      Lx.PutLn();
645      SOut-&gt;Flush();
646      LogSOut-&gt;Flush();
647    }
648  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoobs.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hldoc.cpp</div>
                </div>
                <div class="column column_space"><pre><code>3    YBs(_YBs), FirstChN(YBs-&gt;WordChAHeap.Len()){
4      YBs-&gt;WordChAHeap+=Str; YBs-&gt;WordChAHeap+=TCh::CrCh;
</pre></code></div>
                <div class="column column_space"><pre><code>176    HldBs(_HldBs), FirstChN(HldBs-&gt;WordChAHeap.Len()){
177    HldBs-&gt;WordChAHeap+=Str; HldBs-&gt;WordChAHeap+=CrCh;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    