
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.412928293889085%, Tokens: 11</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-marshalling_test.cc</h3>
            <pre><code>1  #include "absl/flags/marshalling.h"
2  #include <stdint.h>
3  #include <cmath>
4  #include <limits>
5  #include <string>
6  #include <vector>
7  #include "gtest/gtest.h"
8  namespace {
9  TEST(MarshallingTest, TestBoolParsing) {
10    std::string err;
11    bool value;
12    EXPECT_TRUE(absl::ParseFlag("True", &value, &err));
13    EXPECT_TRUE(value);
14    EXPECT_TRUE(absl::ParseFlag("true", &value, &err));
15    EXPECT_TRUE(value);
16    EXPECT_TRUE(absl::ParseFlag("TRUE", &value, &err));
17    EXPECT_TRUE(value);
18    EXPECT_TRUE(absl::ParseFlag("Yes", &value, &err));
19    EXPECT_TRUE(value);
20    EXPECT_TRUE(absl::ParseFlag("yes", &value, &err));
21    EXPECT_TRUE(value);
22    EXPECT_TRUE(absl::ParseFlag("YES", &value, &err));
23    EXPECT_TRUE(value);
24    EXPECT_TRUE(absl::ParseFlag("t", &value, &err));
25    EXPECT_TRUE(value);
26    EXPECT_TRUE(absl::ParseFlag("T", &value, &err));
27    EXPECT_TRUE(value);
28    EXPECT_TRUE(absl::ParseFlag("y", &value, &err));
29    EXPECT_TRUE(value);
30    EXPECT_TRUE(absl::ParseFlag("Y", &value, &err));
31    EXPECT_TRUE(value);
32    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
33    EXPECT_TRUE(value);
34    EXPECT_TRUE(absl::ParseFlag("False", &value, &err));
35    EXPECT_FALSE(value);
36    EXPECT_TRUE(absl::ParseFlag("false", &value, &err));
37    EXPECT_FALSE(value);
38    EXPECT_TRUE(absl::ParseFlag("FALSE", &value, &err));
39    EXPECT_FALSE(value);
40    EXPECT_TRUE(absl::ParseFlag("No", &value, &err));
41    EXPECT_FALSE(value);
42    EXPECT_TRUE(absl::ParseFlag("no", &value, &err));
43    EXPECT_FALSE(value);
44    EXPECT_TRUE(absl::ParseFlag("NO", &value, &err));
45    EXPECT_FALSE(value);
46    EXPECT_TRUE(absl::ParseFlag("f", &value, &err));
47    EXPECT_FALSE(value);
48    EXPECT_TRUE(absl::ParseFlag("F", &value, &err));
49    EXPECT_FALSE(value);
50    EXPECT_TRUE(absl::ParseFlag("n", &value, &err));
51    EXPECT_FALSE(value);
52    EXPECT_TRUE(absl::ParseFlag("N", &value, &err));
53    EXPECT_FALSE(value);
54    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
55    EXPECT_FALSE(value);
56    EXPECT_TRUE(absl::ParseFlag("  true", &value, &err));
57    EXPECT_TRUE(value);
58    EXPECT_TRUE(absl::ParseFlag("true  ", &value, &err));
59    EXPECT_TRUE(value);
60    EXPECT_TRUE(absl::ParseFlag("  true   ", &value, &err));
61    EXPECT_TRUE(value);
62    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
63    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
64    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
65    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
66    EXPECT_FALSE(absl::ParseFlag("2", &value, &err));
67    EXPECT_FALSE(absl::ParseFlag("11", &value, &err));
68    EXPECT_FALSE(absl::ParseFlag("tt", &value, &err));
69  }
70  TEST(MarshallingTest, TestInt16Parsing) {
71    std::string err;
72    int16_t value;
73    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
74    EXPECT_EQ(value, 1);
75    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
76    EXPECT_EQ(value, 0);
77    EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
78    EXPECT_EQ(value, -1);
79    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
80    EXPECT_EQ(value, 123);
81    EXPECT_TRUE(absl::ParseFlag("-18765", &value, &err));
82    EXPECT_EQ(value, -18765);
83    EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
84    EXPECT_EQ(value, 3);
85    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
86    EXPECT_EQ(value, 1);
87    EXPECT_TRUE(absl::ParseFlag("-001", &value, &err));
88    EXPECT_EQ(value, -1);
89    EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
90    EXPECT_EQ(value, 100);
91    EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
92    EXPECT_EQ(value, 16);
93    EXPECT_TRUE(absl::ParseFlag("0X234", &value, &err));
94    EXPECT_EQ(value, 564);
95    EXPECT_FALSE(absl::ParseFlag("-0x7FFD", &value, &err));
96    EXPECT_NE(value, -3);
97    EXPECT_FALSE(absl::ParseFlag("+0x31", &value, &err));
98    EXPECT_NE(value, 49);
99    EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
100    EXPECT_EQ(value, 10);
101    EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
102    EXPECT_EQ(value, 11);
103    EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
104    EXPECT_EQ(value, 12);
105    EXPECT_TRUE(absl::ParseFlag(" 0x22    ", &value, &err));
106    EXPECT_EQ(value, 34);
107    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
108    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
109    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
110    EXPECT_FALSE(absl::ParseFlag("40000", &value, &err));
111    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
112    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
113    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
114    EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
115    EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
116  }
117  TEST(MarshallingTest, TestUint16Parsing) {
118    std::string err;
119    uint16_t value;
120    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
121    EXPECT_EQ(value, 1);
122    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
123    EXPECT_EQ(value, 0);
124    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
125    EXPECT_EQ(value, 123);
126    EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
127    EXPECT_EQ(value, 3);
128    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
129    EXPECT_EQ(value, 1);
130    EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
131    EXPECT_EQ(value, 1);
132    EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
133    EXPECT_EQ(value, 100);
134    EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
135    EXPECT_EQ(value, 16);
136    EXPECT_TRUE(absl::ParseFlag("0X234", &value, &err));
137    EXPECT_EQ(value, 564);
138    EXPECT_FALSE(absl::ParseFlag("+0x31", &value, &err));
139    EXPECT_NE(value, 49);
140    EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
141    EXPECT_EQ(value, 10);
142    EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
143    EXPECT_EQ(value, 11);
144    EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
145    EXPECT_EQ(value, 12);
146    EXPECT_TRUE(absl::ParseFlag(" 0x22    ", &value, &err));
147    EXPECT_EQ(value, 34);
148    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
149    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
150    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
151    EXPECT_FALSE(absl::ParseFlag("70000", &value, &err));
152    EXPECT_FALSE(absl::ParseFlag("-1", &value, &err));
153    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
154    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
155    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
156    EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
157    EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
158  }
159  TEST(MarshallingTest, TestInt32Parsing) {
160    std::string err;
161    int32_t value;
162    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
163    EXPECT_EQ(value, 1);
164    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
165    EXPECT_EQ(value, 0);
166    EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
167    EXPECT_EQ(value, -1);
168    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
169    EXPECT_EQ(value, 123);
170    EXPECT_TRUE(absl::ParseFlag("-98765", &value, &err));
171    EXPECT_EQ(value, -98765);
172    EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
173    EXPECT_EQ(value, 3);
174    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
175    EXPECT_EQ(value, 1);
176    EXPECT_TRUE(absl::ParseFlag("-001", &value, &err));
177    EXPECT_EQ(value, -1);
178    EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
179    EXPECT_EQ(value, 100);
180    EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
181    EXPECT_EQ(value, 16);
182    EXPECT_TRUE(absl::ParseFlag("0X234", &value, &err));
183    EXPECT_EQ(value, 564);
184    EXPECT_FALSE(absl::ParseFlag("-0x7FFFFFFD", &value, &err));
185    EXPECT_NE(value, -3);
186    EXPECT_FALSE(absl::ParseFlag("+0x31", &value, &err));
187    EXPECT_NE(value, 49);
188    EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
189    EXPECT_EQ(value, 10);
190    EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
191    EXPECT_EQ(value, 11);
192    EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
193    EXPECT_EQ(value, 12);
194    EXPECT_TRUE(absl::ParseFlag(" 0x22    ", &value, &err));
195    EXPECT_EQ(value, 34);
196    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
197    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
198    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
199    EXPECT_FALSE(absl::ParseFlag("70000000000", &value, &err));
200    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
201    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
202    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
203    EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
204    EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
205  }
206  TEST(MarshallingTest, TestUint32Parsing) {
207    std::string err;
208    uint32_t value;
209    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
210    EXPECT_EQ(value, 1);
211    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
212    EXPECT_EQ(value, 0);
213    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
214    EXPECT_EQ(value, 123);
215    EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
216    EXPECT_EQ(value, 3);
217    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
218    EXPECT_EQ(value, 1);
219    EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
220    EXPECT_EQ(value, 100);
221    EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
222    EXPECT_EQ(value, 16);
223    EXPECT_TRUE(absl::ParseFlag("0X234", &value, &err));
224    EXPECT_EQ(value, 564);
225    EXPECT_TRUE(absl::ParseFlag("0xFFFFFFFD", &value, &err));
226    EXPECT_EQ(value, 4294967293);
227    EXPECT_FALSE(absl::ParseFlag("+0x31", &value, &err));
228    EXPECT_NE(value, 49);
229    EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
230    EXPECT_EQ(value, 10);
231    EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
232    EXPECT_EQ(value, 11);
233    EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
234    EXPECT_EQ(value, 12);
235    EXPECT_TRUE(absl::ParseFlag(" 0x22    ", &value, &err));
236    EXPECT_EQ(value, 34);
237    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
238    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
239    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
240    EXPECT_FALSE(absl::ParseFlag("140000000000", &value, &err));
241    EXPECT_FALSE(absl::ParseFlag("-1", &value, &err));
242    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
243    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
244    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
245    EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
246    EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
247  }
248  TEST(MarshallingTest, TestInt64Parsing) {
249    std::string err;
250    int64_t value;
251    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
252    EXPECT_EQ(value, 1);
253    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
254    EXPECT_EQ(value, 0);
255    EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
256    EXPECT_EQ(value, -1);
257    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
258    EXPECT_EQ(value, 123);
259    EXPECT_TRUE(absl::ParseFlag("-98765", &value, &err));
260    EXPECT_EQ(value, -98765);
261    EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
262    EXPECT_EQ(value, 3);
263    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
264    EXPECT_EQ(value, 1);
265    EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
266    EXPECT_EQ(value, 1);
267    EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
268    EXPECT_EQ(value, 100);
269    EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
270    EXPECT_EQ(value, 16);
271    EXPECT_TRUE(absl::ParseFlag("0XFFFAAABBBCCCDDD", &value, &err));
272    EXPECT_EQ(value, 1152827684197027293);
273    EXPECT_FALSE(absl::ParseFlag("-0x7FFFFFFFFFFFFFFE", &value, &err));
274    EXPECT_NE(value, -2);
275    EXPECT_FALSE(absl::ParseFlag("+0x31", &value, &err));
276    EXPECT_NE(value, 49);
277    EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
278    EXPECT_EQ(value, 10);
279    EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
280    EXPECT_EQ(value, 11);
281    EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
282    EXPECT_EQ(value, 12);
283    EXPECT_TRUE(absl::ParseFlag(" 0x7F    ", &value, &err));
284    EXPECT_EQ(value, 127);
285    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
286    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
287    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
288    EXPECT_FALSE(absl::ParseFlag("0xFFFFFFFFFFFFFFFFFF", &value, &err));
289    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
290    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
291    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
292    EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
293    EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
294  }
295  TEST(MarshallingTest, TestUInt64Parsing) {
296    std::string err;
297    uint64_t value;
298    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
299    EXPECT_EQ(value, 1);
300    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
301    EXPECT_EQ(value, 0);
302    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
303    EXPECT_EQ(value, 123);
304    EXPECT_TRUE(absl::ParseFlag("+13", &value, &err));
305    EXPECT_EQ(value, 13);
306    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
307    EXPECT_EQ(value, 1);
308    EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
309    EXPECT_EQ(value, 1);
310    EXPECT_TRUE(absl::ParseFlag("0000300", &value, &err));
311    EXPECT_EQ(value, 300);
312    EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
313    EXPECT_EQ(value, 16);
314    EXPECT_TRUE(absl::ParseFlag("0XFFFF", &value, &err));
315    EXPECT_EQ(value, 65535);
316    EXPECT_FALSE(absl::ParseFlag("+0x31", &value, &err));
317    EXPECT_NE(value, 49);
318    EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
319    EXPECT_EQ(value, 10);
320    EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
321    EXPECT_EQ(value, 11);
322    EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
323    EXPECT_EQ(value, 12);
324    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
325    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
326    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
327    EXPECT_FALSE(absl::ParseFlag("0xFFFFFFFFFFFFFFFFFF", &value, &err));
328    EXPECT_FALSE(absl::ParseFlag("-1", &value, &err));
329    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
330    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
331    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
332    EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
333    EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
334  }
<span onclick='openModal()' class='match'>335  TEST(MarshallingTest, TestInt128Parsing) {
336    std::string err;
337    absl::int128 value;
338    absl::int128 zero = 0;
339    absl::int128 one = 1;
340    absl::int128 neg_one = -1;
341    absl::int128 hundred = 100;
342    absl::int128 hundreds_val = 123;
343    absl::int128 neg_thousands_val = -98765;
344    absl::int128 pos_three = 3;
345    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
346    EXPECT_EQ(value, zero);
347    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
348    EXPECT_EQ(value, one);
349    EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
350    EXPECT_EQ(value, neg_one);
351    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
352    EXPECT_EQ(value, hundreds_val);
353    EXPECT_TRUE(absl::ParseFlag("-98765", &value, &err));
354    EXPECT_EQ(value, neg_thousands_val);
355    EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
356    EXPECT_EQ(value, pos_three);
357    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
358    EXPECT_EQ(value, one);
359    EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
360    EXPECT_EQ(value, one);
361    EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
362    EXPECT_EQ(value, hundred);
363    absl::int128 sixteen = 16;
364    absl::int128 quintillion_val = 1152827684197027293;
365    absl::int128 quintillion_val2 =
</span>366        absl::MakeInt128(0x000000000000fff, 0xFFFFFFFFFFFFFFF);
367    EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
368    EXPECT_EQ(value, sixteen);
369    EXPECT_TRUE(absl::ParseFlag("0xFFFAAABBBCCCDDD", &value, &err));
370    EXPECT_EQ(value, quintillion_val);
371    EXPECT_TRUE(absl::ParseFlag("0xFFF0FFFFFFFFFFFFFFF", &value, &err));
372    EXPECT_EQ(value, quintillion_val2);
373    EXPECT_TRUE(absl::ParseFlag("16  ", &value, &err));
374    EXPECT_EQ(value, sixteen);
375    EXPECT_TRUE(absl::ParseFlag("  16", &value, &err));
376    EXPECT_EQ(value, sixteen);
377    EXPECT_TRUE(absl::ParseFlag("  0100  ", &value, &err));
378    EXPECT_EQ(value, hundred);
379    EXPECT_TRUE(absl::ParseFlag(" 0x7B    ", &value, &err));
380    EXPECT_EQ(value, hundreds_val);  
381    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
382    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
383    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
384    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
385    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
386    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
387    EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
388    EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
389  }
390  TEST(MarshallingTest, TestUint128Parsing) {
391    std::string err;
392    absl::uint128 value;
393    absl::uint128 zero = 0;
394    absl::uint128 one = 1;
395    absl::uint128 hundred = 100;
396    absl::uint128 hundreds_val = 123;
397    absl::uint128 pos_three = 3;
398    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
399    EXPECT_EQ(value, zero);
400    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
401    EXPECT_EQ(value, one);
402    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
403    EXPECT_EQ(value, hundreds_val);
404    EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
405    EXPECT_EQ(value, pos_three);
406    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
407    EXPECT_EQ(value, one);
408    EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
409    EXPECT_EQ(value, one);
410    EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
411    EXPECT_EQ(value, hundred);
412    absl::uint128 sixteen = 16;
413    absl::uint128 quintillion_val = 1152827684197027293;
414    absl::uint128 quintillion_val2 =
415        absl::MakeInt128(0x000000000000fff, 0xFFFFFFFFFFFFFFF);
416    EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
417    EXPECT_EQ(value, sixteen);
418    EXPECT_TRUE(absl::ParseFlag("0xFFFAAABBBCCCDDD", &value, &err));
419    EXPECT_EQ(value, quintillion_val);
420    EXPECT_TRUE(absl::ParseFlag("0xFFF0FFFFFFFFFFFFFFF", &value, &err));
421    EXPECT_EQ(value, quintillion_val2);
422    EXPECT_TRUE(absl::ParseFlag("16  ", &value, &err));
423    EXPECT_EQ(value, sixteen);
424    EXPECT_TRUE(absl::ParseFlag("  16", &value, &err));
425    EXPECT_EQ(value, sixteen);
426    EXPECT_TRUE(absl::ParseFlag("  0100  ", &value, &err));
427    EXPECT_EQ(value, hundred);
428    EXPECT_TRUE(absl::ParseFlag(" 0x7B    ", &value, &err));
429    EXPECT_EQ(value, hundreds_val);  
430    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
431    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
432    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
433    EXPECT_FALSE(absl::ParseFlag("-1", &value, &err));
434    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
435    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
436    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
437    EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
438    EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
439  }
440  TEST(MarshallingTest, TestFloatParsing) {
441    std::string err;
442    float value;
443    EXPECT_TRUE(absl::ParseFlag("1.3", &value, &err));
444    EXPECT_FLOAT_EQ(value, 1.3f);
445    EXPECT_TRUE(absl::ParseFlag("-0.1", &value, &err));
446    EXPECT_DOUBLE_EQ(value, -0.1f);
447    EXPECT_TRUE(absl::ParseFlag("+0.01", &value, &err));
448    EXPECT_DOUBLE_EQ(value, 0.01f);
449    EXPECT_TRUE(absl::ParseFlag("1.2e3", &value, &err));
450    EXPECT_DOUBLE_EQ(value, 1.2e3f);
451    EXPECT_TRUE(absl::ParseFlag("9.8765402e-37", &value, &err));
452    EXPECT_DOUBLE_EQ(value, 9.8765402e-37f);
453    EXPECT_TRUE(absl::ParseFlag("0.11e+3", &value, &err));
454    EXPECT_DOUBLE_EQ(value, 0.11e+3f);
455    EXPECT_TRUE(absl::ParseFlag("1.e-2300", &value, &err));
456    EXPECT_DOUBLE_EQ(value, 0.f);
457    EXPECT_TRUE(absl::ParseFlag("1.e+2300", &value, &err));
458    EXPECT_TRUE(std::isinf(value));
459    EXPECT_TRUE(absl::ParseFlag("01.6", &value, &err));
460    EXPECT_DOUBLE_EQ(value, 1.6f);
461    EXPECT_TRUE(absl::ParseFlag("000.0001", &value, &err));
462    EXPECT_DOUBLE_EQ(value, 0.0001f);
463    EXPECT_TRUE(absl::ParseFlag("-5.1000", &value, &err));
464    EXPECT_DOUBLE_EQ(value, -5.1f);
465    EXPECT_TRUE(absl::ParseFlag("NaN", &value, &err));
466    EXPECT_TRUE(std::isnan(value));
467    EXPECT_TRUE(absl::ParseFlag("Inf", &value, &err));
468    EXPECT_TRUE(std::isinf(value));
469    EXPECT_TRUE(absl::ParseFlag("0x10.23p12", &value, &err));
470    EXPECT_DOUBLE_EQ(value, 66096.f);
471    EXPECT_TRUE(absl::ParseFlag("-0xF1.A3p-2", &value, &err));
472    EXPECT_NEAR(value, -60.4092f, 5e-5f);
473    EXPECT_TRUE(absl::ParseFlag("+0x0.0AAp-12", &value, &err));
474    EXPECT_NEAR(value, 1.01328e-05f, 5e-11f);
475    EXPECT_TRUE(absl::ParseFlag("0x.01p1", &value, &err));
476    EXPECT_NEAR(value, 0.0078125f, 5e-8f);
477    EXPECT_TRUE(absl::ParseFlag("10.1  ", &value, &err));
478    EXPECT_DOUBLE_EQ(value, 10.1f);
479    EXPECT_TRUE(absl::ParseFlag("  2.34", &value, &err));
480    EXPECT_DOUBLE_EQ(value, 2.34f);
481    EXPECT_TRUE(absl::ParseFlag("  5.7  ", &value, &err));
482    EXPECT_DOUBLE_EQ(value, 5.7f);
483    EXPECT_TRUE(absl::ParseFlag("  -0xE0.F3p01  ", &value, &err));
484    EXPECT_NEAR(value, -449.8984375f, 5e-8f);
485    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
486    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
487    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
488    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
489    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
490    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
491    EXPECT_FALSE(absl::ParseFlag("2.3xxx", &value, &err));
492    EXPECT_FALSE(absl::ParseFlag("0x0.1pAA", &value, &err));
493    EXPECT_TRUE(absl::ParseFlag("0x0.1", &value, &err));
494  }
495  TEST(MarshallingTest, TestDoubleParsing) {
496    std::string err;
497    double value;
498    EXPECT_TRUE(absl::ParseFlag("1.3", &value, &err));
499    EXPECT_DOUBLE_EQ(value, 1.3);
500    EXPECT_TRUE(absl::ParseFlag("-0.1", &value, &err));
501    EXPECT_DOUBLE_EQ(value, -0.1);
502    EXPECT_TRUE(absl::ParseFlag("+0.01", &value, &err));
503    EXPECT_DOUBLE_EQ(value, 0.01);
504    EXPECT_TRUE(absl::ParseFlag("1.2e3", &value, &err));
505    EXPECT_DOUBLE_EQ(value, 1.2e3);
506    EXPECT_TRUE(absl::ParseFlag("9.00000002e-123", &value, &err));
507    EXPECT_DOUBLE_EQ(value, 9.00000002e-123);
508    EXPECT_TRUE(absl::ParseFlag("0.11e+3", &value, &err));
509    EXPECT_DOUBLE_EQ(value, 0.11e+3);
510    EXPECT_TRUE(absl::ParseFlag("1.e-2300", &value, &err));
511    EXPECT_DOUBLE_EQ(value, 0);
512    EXPECT_TRUE(absl::ParseFlag("1.e+2300", &value, &err));
513    EXPECT_TRUE(std::isinf(value));
514    EXPECT_TRUE(absl::ParseFlag("01.6", &value, &err));
515    EXPECT_DOUBLE_EQ(value, 1.6);
516    EXPECT_TRUE(absl::ParseFlag("000.0001", &value, &err));
517    EXPECT_DOUBLE_EQ(value, 0.0001);
518    EXPECT_TRUE(absl::ParseFlag("-5.1000", &value, &err));
519    EXPECT_DOUBLE_EQ(value, -5.1);
520    EXPECT_TRUE(absl::ParseFlag("NaN", &value, &err));
521    EXPECT_TRUE(std::isnan(value));
522    EXPECT_TRUE(absl::ParseFlag("nan", &value, &err));
523    EXPECT_TRUE(std::isnan(value));
524    EXPECT_TRUE(absl::ParseFlag("Inf", &value, &err));
525    EXPECT_TRUE(std::isinf(value));
526    EXPECT_TRUE(absl::ParseFlag("inf", &value, &err));
527    EXPECT_TRUE(std::isinf(value));
528    EXPECT_TRUE(absl::ParseFlag("0x10.23p12", &value, &err));
529    EXPECT_DOUBLE_EQ(value, 66096);
530    EXPECT_TRUE(absl::ParseFlag("-0xF1.A3p-2", &value, &err));
531    EXPECT_NEAR(value, -60.4092, 5e-5);
532    EXPECT_TRUE(absl::ParseFlag("+0x0.0AAp-12", &value, &err));
533    EXPECT_NEAR(value, 1.01328e-05, 5e-11);
534    EXPECT_TRUE(absl::ParseFlag("0x.01p1", &value, &err));
535    EXPECT_NEAR(value, 0.0078125, 5e-8);
536    EXPECT_TRUE(absl::ParseFlag("10.1  ", &value, &err));
537    EXPECT_DOUBLE_EQ(value, 10.1);
538    EXPECT_TRUE(absl::ParseFlag("  2.34", &value, &err));
539    EXPECT_DOUBLE_EQ(value, 2.34);
540    EXPECT_TRUE(absl::ParseFlag("  5.7  ", &value, &err));
541    EXPECT_DOUBLE_EQ(value, 5.7);
542    EXPECT_TRUE(absl::ParseFlag("  -0xE0.F3p01  ", &value, &err));
543    EXPECT_NEAR(value, -449.8984375, 5e-8);
544    EXPECT_FALSE(absl::ParseFlag("", &value, &err));
545    EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
546    EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
547    EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
548    EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
549    EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
550    EXPECT_FALSE(absl::ParseFlag("2.3xxx", &value, &err));
551    EXPECT_FALSE(absl::ParseFlag("0x0.1pAA", &value, &err));
552    EXPECT_TRUE(absl::ParseFlag("0x0.1", &value, &err));
553  }
554  TEST(MarshallingTest, TestStringParsing) {
555    std::string err;
556    std::string value;
557    EXPECT_TRUE(absl::ParseFlag("", &value, &err));
558    EXPECT_EQ(value, "");
559    EXPECT_TRUE(absl::ParseFlag(" ", &value, &err));
560    EXPECT_EQ(value, " ");
561    EXPECT_TRUE(absl::ParseFlag("   ", &value, &err));
562    EXPECT_EQ(value, "   ");
563    EXPECT_TRUE(absl::ParseFlag("\n", &value, &err));
564    EXPECT_EQ(value, "\n");
565    EXPECT_TRUE(absl::ParseFlag("\t", &value, &err));
566    EXPECT_EQ(value, "\t");
567    EXPECT_TRUE(absl::ParseFlag("asdfg", &value, &err));
568    EXPECT_EQ(value, "asdfg");
569    EXPECT_TRUE(absl::ParseFlag("asdf ghjk", &value, &err));
570    EXPECT_EQ(value, "asdf ghjk");
571    EXPECT_TRUE(absl::ParseFlag("a\nb\nc", &value, &err));
572    EXPECT_EQ(value, "a\nb\nc");
573    EXPECT_TRUE(absl::ParseFlag("asd\0fgh", &value, &err));
574    EXPECT_EQ(value, "asd");
575    EXPECT_TRUE(absl::ParseFlag("\\\\", &value, &err));
576    EXPECT_EQ(value, "\\\\");
577  }
578  TEST(MarshallingTest, TestVectorOfStringParsing) {
579    std::string err;
580    std::vector<std::string> value;
581    EXPECT_TRUE(absl::ParseFlag("", &value, &err));
582    EXPECT_EQ(value, std::vector<std::string>{});
583    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
584    EXPECT_EQ(value, std::vector<std::string>({"1"}));
585    EXPECT_TRUE(absl::ParseFlag("a,b", &value, &err));
586    EXPECT_EQ(value, std::vector<std::string>({"a", "b"}));
587    EXPECT_TRUE(absl::ParseFlag("a,b,c,", &value, &err));
588    EXPECT_EQ(value, std::vector<std::string>({"a", "b", "c", ""}));
589    EXPECT_TRUE(absl::ParseFlag("a,,", &value, &err));
590    EXPECT_EQ(value, std::vector<std::string>({"a", "", ""}));
591    EXPECT_TRUE(absl::ParseFlag(",", &value, &err));
592    EXPECT_EQ(value, std::vector<std::string>({"", ""}));
593    EXPECT_TRUE(absl::ParseFlag("a, b,c ", &value, &err));
594    EXPECT_EQ(value, std::vector<std::string>({"a", " b", "c "}));
595  }
596  TEST(MarshallingTest, TestOptionalBoolParsing) {
597    std::string err;
598    absl::optional<bool> value;
599    EXPECT_TRUE(absl::ParseFlag("", &value, &err));
600    EXPECT_FALSE(value.has_value());
601    EXPECT_TRUE(absl::ParseFlag("true", &value, &err));
602    EXPECT_TRUE(value.has_value());
603    EXPECT_TRUE(*value);
604    EXPECT_TRUE(absl::ParseFlag("false", &value, &err));
605    EXPECT_TRUE(value.has_value());
606    EXPECT_FALSE(*value);
607    EXPECT_FALSE(absl::ParseFlag("nullopt", &value, &err));
608  }
609  TEST(MarshallingTest, TestOptionalIntParsing) {
610    std::string err;
611    absl::optional<int> value;
612    EXPECT_TRUE(absl::ParseFlag("", &value, &err));
613    EXPECT_FALSE(value.has_value());
614    EXPECT_TRUE(absl::ParseFlag("10", &value, &err));
615    EXPECT_TRUE(value.has_value());
616    EXPECT_EQ(*value, 10);
617    EXPECT_TRUE(absl::ParseFlag("0x1F", &value, &err));
618    EXPECT_TRUE(value.has_value());
619    EXPECT_EQ(*value, 31);
620    EXPECT_FALSE(absl::ParseFlag("nullopt", &value, &err));
621  }
622  TEST(MarshallingTest, TestOptionalDoubleParsing) {
623    std::string err;
624    absl::optional<double> value;
625    EXPECT_TRUE(absl::ParseFlag("", &value, &err));
626    EXPECT_FALSE(value.has_value());
627    EXPECT_TRUE(absl::ParseFlag("1.11", &value, &err));
628    EXPECT_TRUE(value.has_value());
629    EXPECT_EQ(*value, 1.11);
630    EXPECT_TRUE(absl::ParseFlag("-0.12", &value, &err));
631    EXPECT_TRUE(value.has_value());
632    EXPECT_EQ(*value, -0.12);
633    EXPECT_FALSE(absl::ParseFlag("nullopt", &value, &err));
634  }
635  TEST(MarshallingTest, TestOptionalStringParsing) {
636    std::string err;
637    absl::optional<std::string> value;
638    EXPECT_TRUE(absl::ParseFlag("", &value, &err));
639    EXPECT_FALSE(value.has_value());
640    EXPECT_TRUE(absl::ParseFlag(" ", &value, &err));
641    EXPECT_TRUE(value.has_value());
642    EXPECT_EQ(*value, " ");
643    EXPECT_TRUE(absl::ParseFlag("aqswde", &value, &err));
644    EXPECT_TRUE(value.has_value());
645    EXPECT_EQ(*value, "aqswde");
646    EXPECT_TRUE(absl::ParseFlag("nullopt", &value, &err));
647    EXPECT_TRUE(value.has_value());
648    EXPECT_EQ(*value, "nullopt");
649  }
650  TEST(MarshallingTest, TestBoolUnparsing) {
651    EXPECT_EQ(absl::UnparseFlag(true), "true");
652    EXPECT_EQ(absl::UnparseFlag(false), "false");
653  }
654  TEST(MarshallingTest, TestInt16Unparsing) {
655    int16_t value;
656    value = 1;
657    EXPECT_EQ(absl::UnparseFlag(value), "1");
658    value = 0;
659    EXPECT_EQ(absl::UnparseFlag(value), "0");
660    value = -1;
661    EXPECT_EQ(absl::UnparseFlag(value), "-1");
662    value = 9876;
663    EXPECT_EQ(absl::UnparseFlag(value), "9876");
664    value = -987;
665    EXPECT_EQ(absl::UnparseFlag(value), "-987");
666  }
667  TEST(MarshallingTest, TestUint16Unparsing) {
668    uint16_t value;
669    value = 1;
670    EXPECT_EQ(absl::UnparseFlag(value), "1");
671    value = 0;
672    EXPECT_EQ(absl::UnparseFlag(value), "0");
673    value = 19876;
674    EXPECT_EQ(absl::UnparseFlag(value), "19876");
675  }
676  TEST(MarshallingTest, TestInt32Unparsing) {
677    int32_t value;
678    value = 1;
679    EXPECT_EQ(absl::UnparseFlag(value), "1");
680    value = 0;
681    EXPECT_EQ(absl::UnparseFlag(value), "0");
682    value = -1;
683    EXPECT_EQ(absl::UnparseFlag(value), "-1");
684    value = 12345;
685    EXPECT_EQ(absl::UnparseFlag(value), "12345");
686    value = -987;
687    EXPECT_EQ(absl::UnparseFlag(value), "-987");
688  }
689  TEST(MarshallingTest, TestUint32Unparsing) {
690    uint32_t value;
691    value = 1;
692    EXPECT_EQ(absl::UnparseFlag(value), "1");
693    value = 0;
694    EXPECT_EQ(absl::UnparseFlag(value), "0");
695    value = 1234500;
696    EXPECT_EQ(absl::UnparseFlag(value), "1234500");
697  }
698  TEST(MarshallingTest, TestInt64Unparsing) {
699    int64_t value;
700    value = 1;
701    EXPECT_EQ(absl::UnparseFlag(value), "1");
702    value = 0;
703    EXPECT_EQ(absl::UnparseFlag(value), "0");
704    value = -1;
705    EXPECT_EQ(absl::UnparseFlag(value), "-1");
706    value = 123456789L;
707    EXPECT_EQ(absl::UnparseFlag(value), "123456789");
708    value = -987654321L;
709    EXPECT_EQ(absl::UnparseFlag(value), "-987654321");
710    value = 0x7FFFFFFFFFFFFFFF;
711    EXPECT_EQ(absl::UnparseFlag(value), "9223372036854775807");
712    value = 0xFFFFFFFFFFFFFFFF;
713    EXPECT_EQ(absl::UnparseFlag(value), "-1");
714  }
715  TEST(MarshallingTest, TestUint64Unparsing) {
716    uint64_t value;
717    value = 1;
718    EXPECT_EQ(absl::UnparseFlag(value), "1");
719    value = 0;
720    EXPECT_EQ(absl::UnparseFlag(value), "0");
721    value = 123456789L;
722    EXPECT_EQ(absl::UnparseFlag(value), "123456789");
723    value = 0xFFFFFFFFFFFFFFFF;
724    EXPECT_EQ(absl::UnparseFlag(value), "18446744073709551615");
725  }
726  TEST(MarshallingTest, TestFloatUnparsing) {
727    float value;
728    value = 1.1f;
729    EXPECT_EQ(absl::UnparseFlag(value), "1.1");
730    value = 0.01f;
731    EXPECT_EQ(absl::UnparseFlag(value), "0.01");
732    value = 1.23e-2f;
733    EXPECT_EQ(absl::UnparseFlag(value), "0.0123");
734    value = -0.71f;
735    EXPECT_EQ(absl::UnparseFlag(value), "-0.71");
736  }
737  TEST(MarshallingTest, TestDoubleUnparsing) {
738    double value;
739    value = 1.1;
740    EXPECT_EQ(absl::UnparseFlag(value), "1.1");
741    value = 0.01;
742    EXPECT_EQ(absl::UnparseFlag(value), "0.01");
743    value = 1.23e-2;
744    EXPECT_EQ(absl::UnparseFlag(value), "0.0123");
745    value = -0.71;
746    EXPECT_EQ(absl::UnparseFlag(value), "-0.71");
747    value = -0;
748    EXPECT_EQ(absl::UnparseFlag(value), "0");
749    value = std::nan("");
750    EXPECT_EQ(absl::UnparseFlag(value), "nan");
751    value = std::numeric_limits<double>::infinity();
752    EXPECT_EQ(absl::UnparseFlag(value), "inf");
753  }
754  TEST(MarshallingTest, TestStringUnparsing) {
755    EXPECT_EQ(absl::UnparseFlag(""), "");
756    EXPECT_EQ(absl::UnparseFlag(" "), " ");
757    EXPECT_EQ(absl::UnparseFlag("qwerty"), "qwerty");
758    EXPECT_EQ(absl::UnparseFlag("ASDFGH"), "ASDFGH");
759    EXPECT_EQ(absl::UnparseFlag("\n\t  "), "\n\t  ");
760  }
761  TEST(MarshallingTest, TestOptionalBoolUnparsing) {
762    absl::optional<bool> value;
763    EXPECT_EQ(absl::UnparseFlag(value), "");
764    value = true;
765    EXPECT_EQ(absl::UnparseFlag(value), "true");
766    value = false;
767    EXPECT_EQ(absl::UnparseFlag(value), "false");
768    value = absl::nullopt;
769    EXPECT_EQ(absl::UnparseFlag(value), "");
770  }
771  TEST(MarshallingTest, TestOptionalIntUnparsing) {
772    absl::optional<int> value;
773    EXPECT_EQ(absl::UnparseFlag(value), "");
774    value = 0;
775    EXPECT_EQ(absl::UnparseFlag(value), "0");
776    value = -12;
777    EXPECT_EQ(absl::UnparseFlag(value), "-12");
778    value = absl::nullopt;
779    EXPECT_EQ(absl::UnparseFlag(value), "");
780  }
781  TEST(MarshallingTest, TestOptionalDoubleUnparsing) {
782    absl::optional<double> value;
783    EXPECT_EQ(absl::UnparseFlag(value), "");
784    value = 1.;
785    EXPECT_EQ(absl::UnparseFlag(value), "1");
786    value = -1.23;
787    EXPECT_EQ(absl::UnparseFlag(value), "-1.23");
788    value = absl::nullopt;
789    EXPECT_EQ(absl::UnparseFlag(value), "");
790  }
791  TEST(MarshallingTest, TestOptionalStringUnparsing) {
792    absl::optional<std::string> strvalue;
793    EXPECT_EQ(absl::UnparseFlag(strvalue), "");
794    strvalue = "asdfg";
795    EXPECT_EQ(absl::UnparseFlag(strvalue), "asdfg");
796    strvalue = " ";
797    EXPECT_EQ(absl::UnparseFlag(strvalue), " ");
798    strvalue = "";  
799    EXPECT_EQ(absl::UnparseFlag(strvalue), "");
800  }
801  #if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
802  TEST(MarshallingTest, TestStdOptionalUnparsing) {
803    std::optional<std::string> strvalue;
804    EXPECT_EQ(absl::UnparseFlag(strvalue), "");
805    strvalue = "asdfg";
806    EXPECT_EQ(absl::UnparseFlag(strvalue), "asdfg");
807    strvalue = " ";
808    EXPECT_EQ(absl::UnparseFlag(strvalue), " ");
809    strvalue = "";  
810    EXPECT_EQ(absl::UnparseFlag(strvalue), "");
811    std::optional<int> intvalue;
812    EXPECT_EQ(absl::UnparseFlag(intvalue), "");
813    intvalue = 10;
814    EXPECT_EQ(absl::UnparseFlag(intvalue), "10");
815  }
816  #endif
817  template <typename T>
818  void TestRoundtrip(T v) {
819    T new_v;
820    std::string err;
821    EXPECT_TRUE(absl::ParseFlag(absl::UnparseFlag(v), &new_v, &err));
822    EXPECT_EQ(new_v, v);
823  }
824  TEST(MarshallingTest, TestFloatRoundTrip) {
825    TestRoundtrip(0.1f);
826    TestRoundtrip(0.12f);
827    TestRoundtrip(0.123f);
828    TestRoundtrip(0.1234f);
829    TestRoundtrip(0.12345f);
830    TestRoundtrip(0.123456f);
831    TestRoundtrip(0.1234567f);
832    TestRoundtrip(0.12345678f);
833    TestRoundtrip(0.1e20f);
834    TestRoundtrip(0.12e20f);
835    TestRoundtrip(0.123e20f);
836    TestRoundtrip(0.1234e20f);
837    TestRoundtrip(0.12345e20f);
838    TestRoundtrip(0.123456e20f);
839    TestRoundtrip(0.1234567e20f);
840    TestRoundtrip(0.12345678e20f);
841    TestRoundtrip(0.1e-20f);
842    TestRoundtrip(0.12e-20f);
843    TestRoundtrip(0.123e-20f);
844    TestRoundtrip(0.1234e-20f);
845    TestRoundtrip(0.12345e-20f);
846    TestRoundtrip(0.123456e-20f);
847    TestRoundtrip(0.1234567e-20f);
848    TestRoundtrip(0.12345678e-20f);
849  }
850  TEST(MarshallingTest, TestDoubleRoundTrip) {
851    TestRoundtrip(0.1);
852    TestRoundtrip(0.12);
853    TestRoundtrip(0.123);
854    TestRoundtrip(0.1234);
855    TestRoundtrip(0.12345);
856    TestRoundtrip(0.123456);
857    TestRoundtrip(0.1234567);
858    TestRoundtrip(0.12345678);
859    TestRoundtrip(0.123456789);
860    TestRoundtrip(0.1234567891);
861    TestRoundtrip(0.12345678912);
862    TestRoundtrip(0.123456789123);
863    TestRoundtrip(0.1234567891234);
864    TestRoundtrip(0.12345678912345);
865    TestRoundtrip(0.123456789123456);
866    TestRoundtrip(0.1234567891234567);
867    TestRoundtrip(0.12345678912345678);
868    TestRoundtrip(0.1e50);
869    TestRoundtrip(0.12e50);
870    TestRoundtrip(0.123e50);
871    TestRoundtrip(0.1234e50);
872    TestRoundtrip(0.12345e50);
873    TestRoundtrip(0.123456e50);
874    TestRoundtrip(0.1234567e50);
875    TestRoundtrip(0.12345678e50);
876    TestRoundtrip(0.123456789e50);
877    TestRoundtrip(0.1234567891e50);
878    TestRoundtrip(0.12345678912e50);
879    TestRoundtrip(0.123456789123e50);
880    TestRoundtrip(0.1234567891234e50);
881    TestRoundtrip(0.12345678912345e50);
882    TestRoundtrip(0.123456789123456e50);
883    TestRoundtrip(0.1234567891234567e50);
884    TestRoundtrip(0.12345678912345678e50);
885    TestRoundtrip(0.1e-50);
886    TestRoundtrip(0.12e-50);
887    TestRoundtrip(0.123e-50);
888    TestRoundtrip(0.1234e-50);
889    TestRoundtrip(0.12345e-50);
890    TestRoundtrip(0.123456e-50);
891    TestRoundtrip(0.1234567e-50);
892    TestRoundtrip(0.12345678e-50);
893    TestRoundtrip(0.123456789e-50);
894    TestRoundtrip(0.1234567891e-50);
895    TestRoundtrip(0.12345678912e-50);
896    TestRoundtrip(0.123456789123e-50);
897    TestRoundtrip(0.1234567891234e-50);
898    TestRoundtrip(0.12345678912345e-50);
899    TestRoundtrip(0.123456789123456e-50);
900    TestRoundtrip(0.1234567891234567e-50);
901    TestRoundtrip(0.12345678912345678e-50);
902  }
903  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_BTREE_H_
2  #define ABSL_CONTAINER_INTERNAL_BTREE_H_
3  #include <algorithm>
4  #include <cassert>
5  #include <cstddef>
6  #include <cstdint>
7  #include <cstring>
8  #include <functional>
9  #include <iterator>
10  #include <limits>
11  #include <new>
12  #include <string>
13  #include <type_traits>
14  #include <utility>
15  #include "absl/base/internal/raw_logging.h"
16  #include "absl/base/macros.h"
17  #include "absl/container/internal/common.h"
18  #include "absl/container/internal/common_policy_traits.h"
19  #include "absl/container/internal/compressed_tuple.h"
20  #include "absl/container/internal/container_memory.h"
21  #include "absl/container/internal/layout.h"
22  #include "absl/memory/memory.h"
23  #include "absl/meta/type_traits.h"
24  #include "absl/strings/cord.h"
25  #include "absl/strings/string_view.h"
26  #include "absl/types/compare.h"
27  #include "absl/utility/utility.h"
28  namespace absl {
29  ABSL_NAMESPACE_BEGIN
30  namespace container_internal {
31  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
32  #error ABSL_BTREE_ENABLE_GENERATIONS cannot be directly set
33  #elif defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
34      defined(ABSL_HAVE_MEMORY_SANITIZER)
35  #define ABSL_BTREE_ENABLE_GENERATIONS
36  #endif
37  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
38  constexpr bool BtreeGenerationsEnabled() { return true; }
39  #else
40  constexpr bool BtreeGenerationsEnabled() { return false; }
41  #endif
42  template <typename Compare, typename T, typename U>
43  using compare_result_t = absl::result_of_t<const Compare(const T &, const U &)>;
44  template <typename Compare, typename T>
45  using btree_is_key_compare_to =
46      std::is_convertible<compare_result_t<Compare, T, T>, absl::weak_ordering>;
47  struct StringBtreeDefaultLess {
48    using is_transparent = void;
49    StringBtreeDefaultLess() = default;
50    StringBtreeDefaultLess(std::less<std::string>) {}        
51    StringBtreeDefaultLess(std::less<absl::string_view>) {}  
52    explicit operator std::less<std::string>() const { return {}; }
53    explicit operator std::less<absl::string_view>() const { return {}; }
54    explicit operator std::less<absl::Cord>() const { return {}; }
55    absl::weak_ordering operator()(absl::string_view lhs,
56                                   absl::string_view rhs) const {
57      return compare_internal::compare_result_as_ordering(lhs.compare(rhs));
58    }
59    StringBtreeDefaultLess(std::less<absl::Cord>) {}  
60    absl::weak_ordering operator()(const absl::Cord &lhs,
61                                   const absl::Cord &rhs) const {
62      return compare_internal::compare_result_as_ordering(lhs.Compare(rhs));
63    }
64    absl::weak_ordering operator()(const absl::Cord &lhs,
65                                   absl::string_view rhs) const {
66      return compare_internal::compare_result_as_ordering(lhs.Compare(rhs));
67    }
68    absl::weak_ordering operator()(absl::string_view lhs,
69                                   const absl::Cord &rhs) const {
70      return compare_internal::compare_result_as_ordering(-rhs.Compare(lhs));
71    }
72  };
73  struct StringBtreeDefaultGreater {
74    using is_transparent = void;
75    StringBtreeDefaultGreater() = default;
76    StringBtreeDefaultGreater(std::greater<std::string>) {}        
77    StringBtreeDefaultGreater(std::greater<absl::string_view>) {}  
78    explicit operator std::greater<std::string>() const { return {}; }
79    explicit operator std::greater<absl::string_view>() const { return {}; }
80    explicit operator std::greater<absl::Cord>() const { return {}; }
81    absl::weak_ordering operator()(absl::string_view lhs,
82                                   absl::string_view rhs) const {
83      return compare_internal::compare_result_as_ordering(rhs.compare(lhs));
84    }
85    StringBtreeDefaultGreater(std::greater<absl::Cord>) {}  
86    absl::weak_ordering operator()(const absl::Cord &lhs,
87                                   const absl::Cord &rhs) const {
88      return compare_internal::compare_result_as_ordering(rhs.Compare(lhs));
89    }
90    absl::weak_ordering operator()(const absl::Cord &lhs,
91                                   absl::string_view rhs) const {
92      return compare_internal::compare_result_as_ordering(-lhs.Compare(rhs));
93    }
94    absl::weak_ordering operator()(absl::string_view lhs,
95                                   const absl::Cord &rhs) const {
96      return compare_internal::compare_result_as_ordering(rhs.Compare(lhs));
97    }
98  };
99  template <typename Compare, bool is_class = std::is_class<Compare>::value>
100  struct checked_compare_base : Compare {
101    using Compare::Compare;
102    explicit checked_compare_base(Compare c) : Compare(std::move(c)) {}
103    const Compare &comp() const { return *this; }
104  };
105  template <typename Compare>
106  struct checked_compare_base<Compare, false> {
107    explicit checked_compare_base(Compare c) : compare(std::move(c)) {}
108    const Compare &comp() const { return compare; }
109    Compare compare;
110  };
111  struct BtreeTestOnlyCheckedCompareOptOutBase {};
112  template <typename Compare, typename Key>
113  struct key_compare_adapter {
114    struct checked_compare : checked_compare_base<Compare> {
115     private:
116      using Base = typename checked_compare::checked_compare_base;
117      using Base::comp;
118      bool is_self_equivalent(const Key &k) const {
119        return comp()(k, k) == 0;
120      }
121      template <typename T>
122      bool is_self_equivalent(const T &) const {
123        return true;
124      }
125     public:
126      using Base::Base;
127      checked_compare(Compare comp) : Base(std::move(comp)) {}  
128      explicit operator Compare() const { return comp(); }
129      template <typename T, typename U,
130                absl::enable_if_t<
131                    std::is_same<bool, compare_result_t<Compare, T, U>>::value,
132                    int> = 0>
133      bool operator()(const T &lhs, const U &rhs) const {
134        assert(is_self_equivalent(lhs));
135        assert(is_self_equivalent(rhs));
136        const bool lhs_comp_rhs = comp()(lhs, rhs);
137        assert(!lhs_comp_rhs || !comp()(rhs, lhs));
138        return lhs_comp_rhs;
139      }
140      template <
141          typename T, typename U,
142          absl::enable_if_t<std::is_convertible<compare_result_t<Compare, T, U>,
143                                                absl::weak_ordering>::value,
144                            int> = 0>
145      absl::weak_ordering operator()(const T &lhs, const U &rhs) const {
146        assert(is_self_equivalent(lhs));
147        assert(is_self_equivalent(rhs));
148        const absl::weak_ordering lhs_comp_rhs = comp()(lhs, rhs);
149  #ifndef NDEBUG
150        const absl::weak_ordering rhs_comp_lhs = comp()(rhs, lhs);
151        if (lhs_comp_rhs > 0) {
152          assert(rhs_comp_lhs < 0 && "lhs_comp_rhs > 0 -> rhs_comp_lhs < 0");
153        } else if (lhs_comp_rhs == 0) {
154          assert(rhs_comp_lhs == 0 && "lhs_comp_rhs == 0 -> rhs_comp_lhs == 0");
155        } else {
156          assert(rhs_comp_lhs > 0 && "lhs_comp_rhs < 0 -> rhs_comp_lhs > 0");
157        }
158  #endif
159        return lhs_comp_rhs;
160      }
161    };
162    using type = absl::conditional_t<
163        std::is_base_of<BtreeTestOnlyCheckedCompareOptOutBase, Compare>::value,
164        Compare, checked_compare>;
165  };
166  template <>
167  struct key_compare_adapter<std::less<std::string>, std::string> {
168    using type = StringBtreeDefaultLess;
169  };
170  template <>
171  struct key_compare_adapter<std::greater<std::string>, std::string> {
172    using type = StringBtreeDefaultGreater;
173  };
174  template <>
175  struct key_compare_adapter<std::less<absl::string_view>, absl::string_view> {
176    using type = StringBtreeDefaultLess;
177  };
178  template <>
179  struct key_compare_adapter<std::greater<absl::string_view>, absl::string_view> {
180    using type = StringBtreeDefaultGreater;
181  };
182  template <>
183  struct key_compare_adapter<std::less<absl::Cord>, absl::Cord> {
184    using type = StringBtreeDefaultLess;
185  };
186  template <>
187  struct key_compare_adapter<std::greater<absl::Cord>, absl::Cord> {
188    using type = StringBtreeDefaultGreater;
189  };
190  template <typename T, typename = void>
191  struct has_linear_node_search_preference : std::false_type {};
192  template <typename T, typename = void>
193  struct prefers_linear_node_search : std::false_type {};
194  template <typename T>
195  struct has_linear_node_search_preference<
196      T, absl::void_t<typename T::absl_btree_prefer_linear_node_search>>
197      : std::true_type {};
198  template <typename T>
199  struct prefers_linear_node_search<
200      T, absl::void_t<typename T::absl_btree_prefer_linear_node_search>>
201      : T::absl_btree_prefer_linear_node_search {};
202  template <typename Compare, typename Key>
203  constexpr bool compare_has_valid_result_type() {
204    using compare_result_type = compare_result_t<Compare, Key, Key>;
205    return std::is_same<compare_result_type, bool>::value ||
206           std::is_convertible<compare_result_type, absl::weak_ordering>::value;
207  }
208  template <typename original_key_compare, typename value_type>
209  class map_value_compare {
210    template <typename Params>
211    friend class btree;
212   protected:
213    explicit map_value_compare(original_key_compare c) : comp(std::move(c)) {}
214    original_key_compare comp;  
215   public:
216    auto operator()(const value_type &lhs, const value_type &rhs) const
217        -> decltype(comp(lhs.first, rhs.first)) {
218      return comp(lhs.first, rhs.first);
219    }
220  };
221  template <typename Key, typename Compare, typename Alloc, int TargetNodeSize,
222            bool IsMulti, bool IsMap, typename SlotPolicy>
223  struct common_params : common_policy_traits<SlotPolicy> {
224    using original_key_compare = Compare;
225    using key_compare =
226        absl::conditional_t<!compare_has_valid_result_type<Compare, Key>(),
227                            Compare,
228                            typename key_compare_adapter<Compare, Key>::type>;
229    static constexpr bool kIsKeyCompareStringAdapted =
230        std::is_same<key_compare, StringBtreeDefaultLess>::value ||
231        std::is_same<key_compare, StringBtreeDefaultGreater>::value;
232    static constexpr bool kIsKeyCompareTransparent =
233        IsTransparent<original_key_compare>::value || kIsKeyCompareStringAdapted;
234    using is_key_compare_to = btree_is_key_compare_to<key_compare, Key>;
235    using allocator_type = Alloc;
236    using key_type = Key;
237    using size_type = size_t;
238    using difference_type = ptrdiff_t;
239    using slot_policy = SlotPolicy;
240    using slot_type = typename slot_policy::slot_type;
241    using value_type = typename slot_policy::value_type;
242    using init_type = typename slot_policy::mutable_value_type;
243    using pointer = value_type *;
244    using const_pointer = const value_type *;
245    using reference = value_type &;
246    using const_reference = const value_type &;
247    using value_compare =
248        absl::conditional_t<IsMap,
249                            map_value_compare<original_key_compare, value_type>,
250                            original_key_compare>;
251    using is_map_container = std::integral_constant<bool, IsMap>;
252    template <typename LookupKey>
253    constexpr static bool can_have_multiple_equivalent_keys() {
254      return IsMulti || (IsTransparent<key_compare>::value &&
255                         !std::is_same<LookupKey, Key>::value &&
256                         !kIsKeyCompareStringAdapted);
257    }
258    enum {
259      kTargetNodeSize = TargetNodeSize,
260      kNodeSlotSpace = TargetNodeSize - &bsol;*minimum overhead=*/(sizeof(void *) + 4),
261    };
262    using node_count_type =
263        absl::conditional_t<(kNodeSlotSpace / sizeof(slot_type) >
264                             (std::numeric_limits<uint8_t>::max)()),
265                            uint16_t, uint8_t>;  
266  };
267  template <typename Compare>
268  struct upper_bound_adapter {
269    explicit upper_bound_adapter(const Compare &c) : comp(c) {}
270    template <typename K1, typename K2>
271    bool operator()(const K1 &a, const K2 &b) const {
272      return !compare_internal::compare_result_as_less_than(comp(b, a));
273    }
274   private:
275    Compare comp;
276  };
277  enum class MatchKind : uint8_t { kEq, kNe };
278  template <typename V, bool IsCompareTo>
279  struct SearchResult {
280    V value;
281    MatchKind match;
282    static constexpr bool HasMatch() { return true; }
283    bool IsEq() const { return match == MatchKind::kEq; }
284  };
285  template <typename V>
286  struct SearchResult<V, false> {
287    SearchResult() {}
288    explicit SearchResult(V v) : value(v) {}
289    SearchResult(V v, MatchKind &bsol;*match*/) : value(v) {}
290    V value;
291    static constexpr bool HasMatch() { return false; }
292    static constexpr bool IsEq() { return false; }
293  };
294  template <typename Params>
<span onclick='openModal()' class='match'>295  class btree_node {
296    using is_key_compare_to = typename Params::is_key_compare_to;
297    using field_type = typename Params::node_count_type;
298    using allocator_type = typename Params::allocator_type;
299    using slot_type = typename Params::slot_type;
300    using original_key_compare = typename Params::original_key_compare;
301   public:
302    using params_type = Params;
303    using key_type = typename Params::key_type;
304    using value_type = typename Params::value_type;
305    using pointer = typename Params::pointer;
306    using const_pointer = typename Params::const_pointer;
</span>307    using reference = typename Params::reference;
308    using const_reference = typename Params::const_reference;
309    using key_compare = typename Params::key_compare;
310    using size_type = typename Params::size_type;
311    using difference_type = typename Params::difference_type;
312    using use_linear_search = std::integral_constant<
313        bool, has_linear_node_search_preference<original_key_compare>::value
314                  ? prefers_linear_node_search<original_key_compare>::value
315              : has_linear_node_search_preference<key_type>::value
316                  ? prefers_linear_node_search<key_type>::value
317                  : std::is_arithmetic<key_type>::value &&
318                        (std::is_same<std::less<key_type>,
319                                      original_key_compare>::value ||
320                         std::is_same<std::greater<key_type>,
321                                      original_key_compare>::value)>;
322    ~btree_node() = default;
323    btree_node(btree_node const &) = delete;
324    btree_node &operator=(btree_node const &) = delete;
325    constexpr static size_type Alignment() {
326      static_assert(LeafLayout(1).Alignment() == InternalLayout().Alignment(),
327                    "Alignment of all nodes must be equal.");
328      return InternalLayout().Alignment();
329    }
330   protected:
331    btree_node() = default;
332   private:
333    using layout_type =
334        absl::container_internal::Layout<btree_node *, uint32_t, field_type,
335                                         slot_type, btree_node *>;
336    constexpr static size_type SizeWithNSlots(size_type n) {
337      return layout_type(
338                  1,
339                  BtreeGenerationsEnabled() ? 1 : 0,
340                  4,
341                  n,
342                  0)
343          .AllocSize();
344    }
345    constexpr static size_type MinimumOverhead() {
346      return SizeWithNSlots(1) - sizeof(slot_type);
347    }
348    constexpr static size_type NodeTargetSlots(const size_type begin,
349                                               const size_type end) {
350      return begin == end ? begin
351             : SizeWithNSlots((begin + end) / 2 + 1) >
352                     params_type::kTargetNodeSize
353                 ? NodeTargetSlots(begin, (begin + end) / 2)
354                 : NodeTargetSlots((begin + end) / 2 + 1, end);
355    }
356    constexpr static size_type kTargetNodeSize = params_type::kTargetNodeSize;
357    constexpr static size_type kNodeTargetSlots =
358        NodeTargetSlots(0, kTargetNodeSize);
359    constexpr static size_type kMinNodeSlots = 4;
360    constexpr static size_type kNodeSlots =
361        kNodeTargetSlots >= kMinNodeSlots ? kNodeTargetSlots : kMinNodeSlots;
362    constexpr static field_type kInternalNodeMaxCount = 0;
363    constexpr static layout_type Layout(const size_type slot_count,
364                                        const size_type child_count) {
365      return layout_type(
366           1,
367           BtreeGenerationsEnabled() ? 1 : 0,
368           4,
369           slot_count,
370           child_count);
371    }
372    constexpr static layout_type LeafLayout(
373        const size_type slot_count = kNodeSlots) {
374      return Layout(slot_count, 0);
375    }
376    constexpr static layout_type InternalLayout() {
377      return Layout(kNodeSlots, kNodeSlots + 1);
378    }
379    constexpr static size_type LeafSize(const size_type slot_count = kNodeSlots) {
380      return LeafLayout(slot_count).AllocSize();
381    }
382    constexpr static size_type InternalSize() {
383      return InternalLayout().AllocSize();
384    }
385    template <size_type N>
386    inline typename layout_type::template ElementType<N> *GetField() {
387      assert(N < 4 || is_internal());
388      return InternalLayout().template Pointer<N>(reinterpret_cast<char *>(this));
389    }
390    template <size_type N>
391    inline const typename layout_type::template ElementType<N> *GetField() const {
392      assert(N < 4 || is_internal());
393      return InternalLayout().template Pointer<N>(
394          reinterpret_cast<const char *>(this));
395    }
396    void set_parent(btree_node *p) { *GetField<0>() = p; }
397    field_type &mutable_finish() { return GetField<2>()[2]; }
398    slot_type *slot(size_type i) { return &GetField<3>()[i]; }
399    slot_type *start_slot() { return slot(start()); }
400    slot_type *finish_slot() { return slot(finish()); }
401    const slot_type *slot(size_type i) const { return &GetField<3>()[i]; }
402    void set_position(field_type v) { GetField<2>()[0] = v; }
403    void set_start(field_type v) { GetField<2>()[1] = v; }
404    void set_finish(field_type v) { GetField<2>()[2] = v; }
405    void set_max_count(field_type v) { GetField<2>()[3] = v; }
406   public:
407    bool is_leaf() const { return GetField<2>()[3] != kInternalNodeMaxCount; }
408    bool is_internal() const { return !is_leaf(); }
409    field_type position() const { return GetField<2>()[0]; }
410    field_type start() const {
411      assert(GetField<2>()[1] == 0);
412      return 0;
413    }
414    field_type finish() const { return GetField<2>()[2]; }
415    field_type count() const {
416      assert(finish() >= start());
417      return finish() - start();
418    }
419    field_type max_count() const {
420      const field_type max_count = GetField<2>()[3];
421      return max_count == field_type{kInternalNodeMaxCount}
422                 ? field_type{kNodeSlots}
423                 : max_count;
424    }
425    btree_node *parent() const { return *GetField<0>(); }
426    bool is_root() const { return parent()->is_leaf(); }
427    void make_root() {
428      assert(parent()->is_root());
429      set_generation(parent()->generation());
430      set_parent(parent()->parent());
431    }
432    uint32_t *get_root_generation() const {
433      assert(BtreeGenerationsEnabled());
434      const btree_node *curr = this;
435      for (; !curr->is_root(); curr = curr->parent()) continue;
436      return const_cast<uint32_t *>(&curr->GetField<1>()[0]);
437    }
438    uint32_t generation() const {
439      return BtreeGenerationsEnabled() ? *get_root_generation() : 0;
440    }
441    void set_generation(uint32_t generation) {
442      if (BtreeGenerationsEnabled()) GetField<1>()[0] = generation;
443    }
444    void next_generation() {
445      if (BtreeGenerationsEnabled()) ++*get_root_generation();
446    }
447    const key_type &key(size_type i) const { return params_type::key(slot(i)); }
448    reference value(size_type i) { return params_type::element(slot(i)); }
449    const_reference value(size_type i) const {
450      return params_type::element(slot(i));
451    }
452    btree_node *child(field_type i) const { return GetField<4>()[i]; }
453    btree_node *start_child() const { return child(start()); }
454    btree_node *&mutable_child(field_type i) { return GetField<4>()[i]; }
455    void clear_child(field_type i) {
456      absl::container_internal::SanitizerPoisonObject(&mutable_child(i));
457    }
458    void set_child_noupdate_position(field_type i, btree_node *c) {
459      absl::container_internal::SanitizerUnpoisonObject(&mutable_child(i));
460      mutable_child(i) = c;
461    }
462    void set_child(field_type i, btree_node *c) {
463      set_child_noupdate_position(i, c);
464      c->set_position(i);
465    }
466    void init_child(field_type i, btree_node *c) {
467      set_child(i, c);
468      c->set_parent(this);
469    }
470    template <typename K>
471    SearchResult<size_type, is_key_compare_to::value> lower_bound(
472        const K &k, const key_compare &comp) const {
473      return use_linear_search::value ? linear_search(k, comp)
474                                      : binary_search(k, comp);
475    }
476    template <typename K>
477    size_type upper_bound(const K &k, const key_compare &comp) const {
478      auto upper_compare = upper_bound_adapter<key_compare>(comp);
479      return use_linear_search::value ? linear_search(k, upper_compare).value
480                                      : binary_search(k, upper_compare).value;
481    }
482    template <typename K, typename Compare>
483    SearchResult<size_type, btree_is_key_compare_to<Compare, key_type>::value>
484    linear_search(const K &k, const Compare &comp) const {
485      return linear_search_impl(k, start(), finish(), comp,
486                                btree_is_key_compare_to<Compare, key_type>());
487    }
488    template <typename K, typename Compare>
489    SearchResult<size_type, btree_is_key_compare_to<Compare, key_type>::value>
490    binary_search(const K &k, const Compare &comp) const {
491      return binary_search_impl(k, start(), finish(), comp,
492                                btree_is_key_compare_to<Compare, key_type>());
493    }
494    template <typename K, typename Compare>
495    SearchResult<size_type, false> linear_search_impl(
496        const K &k, size_type s, const size_type e, const Compare &comp,
497        std::false_type &bsol;* IsCompareTo */) const {
498      while (s < e) {
499        if (!comp(key(s), k)) {
500          break;
501        }
502        ++s;
503      }
504      return SearchResult<size_type, false>{s};
505    }
506    template <typename K, typename Compare>
507    SearchResult<size_type, true> linear_search_impl(
508        const K &k, size_type s, const size_type e, const Compare &comp,
509        std::true_type &bsol;* IsCompareTo */) const {
510      while (s < e) {
511        const absl::weak_ordering c = comp(key(s), k);
512        if (c == 0) {
513          return {s, MatchKind::kEq};
514        } else if (c > 0) {
515          break;
516        }
517        ++s;
518      }
519      return {s, MatchKind::kNe};
520    }
521    template <typename K, typename Compare>
522    SearchResult<size_type, false> binary_search_impl(
523        const K &k, size_type s, size_type e, const Compare &comp,
524        std::false_type &bsol;* IsCompareTo */) const {
525      while (s != e) {
526        const size_type mid = (s + e) >> 1;
527        if (comp(key(mid), k)) {
528          s = mid + 1;
529        } else {
530          e = mid;
531        }
532      }
533      return SearchResult<size_type, false>{s};
534    }
535    template <typename K, typename CompareTo>
536    SearchResult<size_type, true> binary_search_impl(
537        const K &k, size_type s, size_type e, const CompareTo &comp,
538        std::true_type &bsol;* IsCompareTo */) const {
539      if (params_type::template can_have_multiple_equivalent_keys<K>()) {
540        MatchKind exact_match = MatchKind::kNe;
541        while (s != e) {
542          const size_type mid = (s + e) >> 1;
543          const absl::weak_ordering c = comp(key(mid), k);
544          if (c < 0) {
545            s = mid + 1;
546          } else {
547            e = mid;
548            if (c == 0) {
549              exact_match = MatchKind::kEq;
550            }
551          }
552        }
553        return {s, exact_match};
554      } else {  
555        while (s != e) {
556          const size_type mid = (s + e) >> 1;
557          const absl::weak_ordering c = comp(key(mid), k);
558          if (c < 0) {
559            s = mid + 1;
560          } else if (c > 0) {
561            e = mid;
562          } else {
563            return {mid, MatchKind::kEq};
564          }
565        }
566        return {s, MatchKind::kNe};
567      }
568    }
569    template <typename Compare>
570    bool is_ordered_correctly(field_type i, const Compare &comp) const {
571      if (std::is_base_of<BtreeTestOnlyCheckedCompareOptOutBase,
572                          Compare>::value ||
573          params_type::kIsKeyCompareStringAdapted) {
574        return true;
575      }
576      const auto compare = [&](field_type a, field_type b) {
577        const absl::weak_ordering cmp =
578            compare_internal::do_three_way_comparison(comp, key(a), key(b));
579        return cmp < 0 ? -1 : cmp > 0 ? 1 : 0;
580      };
581      int cmp = -1;
582      constexpr bool kCanHaveEquivKeys =
583          params_type::template can_have_multiple_equivalent_keys<key_type>();
584      for (field_type j = start(); j < finish(); ++j) {
585        if (j == i) {
586          if (cmp > 0) return false;
587          continue;
588        }
589        int new_cmp = compare(j, i);
590        if (new_cmp < cmp || (!kCanHaveEquivKeys && new_cmp == 0)) return false;
591        cmp = new_cmp;
592      }
593      return true;
594    }
595    template <typename... Args>
596    void emplace_value(field_type i, allocator_type *alloc, Args &&...args);
597    void remove_values(field_type i, field_type to_erase, allocator_type *alloc);
598    void rebalance_right_to_left(field_type to_move, btree_node *right,
599                                 allocator_type *alloc);
600    void rebalance_left_to_right(field_type to_move, btree_node *right,
601                                 allocator_type *alloc);
602    void split(int insert_position, btree_node *dest, allocator_type *alloc);
603    void merge(btree_node *src, allocator_type *alloc);
604    void init_leaf(field_type position, field_type max_count,
605                   btree_node *parent) {
606      set_generation(0);
607      set_parent(parent);
608      set_position(position);
609      set_start(0);
610      set_finish(0);
611      set_max_count(max_count);
612      absl::container_internal::SanitizerPoisonMemoryRegion(
613          start_slot(), max_count * sizeof(slot_type));
614    }
615    void init_internal(field_type position, btree_node *parent) {
616      init_leaf(position, kNodeSlots, parent);
617      set_max_count(kInternalNodeMaxCount);
618      absl::container_internal::SanitizerPoisonMemoryRegion(
619          &mutable_child(start()), (kNodeSlots + 1) * sizeof(btree_node *));
620    }
621    static void deallocate(const size_type size, btree_node *node,
622                           allocator_type *alloc) {
623      absl::container_internal::SanitizerUnpoisonMemoryRegion(node, size);
624      absl::container_internal::Deallocate<Alignment()>(alloc, node, size);
625    }
626    static void clear_and_delete(btree_node *node, allocator_type *alloc);
627   private:
628    template <typename... Args>
629    void value_init(const field_type i, allocator_type *alloc, Args &&...args) {
630      next_generation();
631      absl::container_internal::SanitizerUnpoisonObject(slot(i));
632      params_type::construct(alloc, slot(i), std::forward<Args>(args)...);
633    }
634    void value_destroy(const field_type i, allocator_type *alloc) {
635      next_generation();
636      params_type::destroy(alloc, slot(i));
637      absl::container_internal::SanitizerPoisonObject(slot(i));
638    }
639    void value_destroy_n(const field_type i, const field_type n,
640                         allocator_type *alloc) {
641      next_generation();
642      for (slot_type *s = slot(i), *end = slot(i + n); s != end; ++s) {
643        params_type::destroy(alloc, s);
644        absl::container_internal::SanitizerPoisonObject(s);
645      }
646    }
647    static void transfer(slot_type *dest, slot_type *src, allocator_type *alloc) {
648      absl::container_internal::SanitizerUnpoisonObject(dest);
649      params_type::transfer(alloc, dest, src);
650      absl::container_internal::SanitizerPoisonObject(src);
651    }
652    void transfer(const size_type dest_i, const size_type src_i,
653                  btree_node *src_node, allocator_type *alloc) {
654      next_generation();
655      transfer(slot(dest_i), src_node->slot(src_i), alloc);
656    }
657    void transfer_n(const size_type n, const size_type dest_i,
658                    const size_type src_i, btree_node *src_node,
659                    allocator_type *alloc) {
660      next_generation();
661      for (slot_type *src = src_node->slot(src_i), *end = src + n,
662                     *dest = slot(dest_i);
663           src != end; ++src, ++dest) {
664        transfer(dest, src, alloc);
665      }
666    }
667    void transfer_n_backward(const size_type n, const size_type dest_i,
668                             const size_type src_i, btree_node *src_node,
669                             allocator_type *alloc) {
670      next_generation();
671      for (slot_type *src = src_node->slot(src_i + n), *end = src - n,
672                     *dest = slot(dest_i + n);
673           src != end; --src, --dest) {
674        transfer(dest - 1, src - 1, alloc);
675      }
676    }
677    template <typename P>
678    friend class btree;
679    template <typename N, typename R, typename P>
680    friend class btree_iterator;
681    friend class BtreeNodePeer;
682    friend struct btree_access;
683  };
684  template <typename Node>
685  bool AreNodesFromSameContainer(const Node *node_a, const Node *node_b) {
686    if (node_a == nullptr || node_b == nullptr) return true;
687    while (!node_a->is_root()) node_a = node_a->parent();
688    while (!node_b->is_root()) node_b = node_b->parent();
689    return node_a == node_b;
690  }
691  class btree_iterator_generation_info_enabled {
692   public:
693    explicit btree_iterator_generation_info_enabled(uint32_t g)
694        : generation_(g) {}
695    template <typename Node>
696    void update_generation(const Node *node) {
697      if (node != nullptr) generation_ = node->generation();
698    }
699    uint32_t generation() const { return generation_; }
700    template <typename Node>
701    void assert_valid_generation(const Node *node) const {
702      if (node != nullptr && node->generation() != generation_) {
703        ABSL_INTERNAL_LOG(
704            FATAL,
705            "Attempting to use an invalidated iterator. The corresponding b-tree "
706            "container has been mutated since this iterator was constructed.");
707      }
708    }
709   private:
710    uint32_t generation_;
711  };
712  class btree_iterator_generation_info_disabled {
713   public:
714    explicit btree_iterator_generation_info_disabled(uint32_t) {}
715    static void update_generation(const void *) {}
716    static uint32_t generation() { return 0; }
717    static void assert_valid_generation(const void *) {}
718  };
719  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
720  using btree_iterator_generation_info = btree_iterator_generation_info_enabled;
721  #else
722  using btree_iterator_generation_info = btree_iterator_generation_info_disabled;
723  #endif
724  template <typename Node, typename Reference, typename Pointer>
725  class btree_iterator : private btree_iterator_generation_info {
726    using field_type = typename Node::field_type;
727    using key_type = typename Node::key_type;
728    using size_type = typename Node::size_type;
729    using params_type = typename Node::params_type;
730    using is_map_container = typename params_type::is_map_container;
731    using node_type = Node;
732    using normal_node = typename std::remove_const<Node>::type;
733    using const_node = const Node;
734    using normal_pointer = typename params_type::pointer;
735    using normal_reference = typename params_type::reference;
736    using const_pointer = typename params_type::const_pointer;
737    using const_reference = typename params_type::const_reference;
738    using slot_type = typename params_type::slot_type;
739    using iterator =
740       btree_iterator<normal_node, normal_reference, normal_pointer>;
741    using const_iterator =
742        btree_iterator<const_node, const_reference, const_pointer>;
743   public:
744    using difference_type = typename Node::difference_type;
745    using value_type = typename params_type::value_type;
746    using pointer = Pointer;
747    using reference = Reference;
748    using iterator_category = std::bidirectional_iterator_tag;
749    btree_iterator() : btree_iterator(nullptr, -1) {}
750    explicit btree_iterator(Node *n) : btree_iterator(n, n->start()) {}
751    btree_iterator(Node *n, int p)
752        : btree_iterator_generation_info(n != nullptr ? n->generation()
753                                                      : ~uint32_t{}),
754          node_(n),
755          position_(p) {}
756    template <typename N, typename R, typename P,
757              absl::enable_if_t<
758                  std::is_same<btree_iterator<N, R, P>, iterator>::value &&
759                      std::is_same<btree_iterator, const_iterator>::value,
760                  int> = 0>
761    btree_iterator(const btree_iterator<N, R, P> other)  
762        : btree_iterator_generation_info(other),
763          node_(other.node_),
764          position_(other.position_) {}
765    bool operator==(const iterator &other) const {
766      return Equals(other);
767    }
768    bool operator==(const const_iterator &other) const {
769      return Equals(other);
770    }
771    bool operator!=(const iterator &other) const {
772      return !Equals(other);
773    }
774    bool operator!=(const const_iterator &other) const {
775      return !Equals(other);
776    }
777    difference_type operator-(const_iterator other) const {
778      if (node_ == other.node_) {
779        if (node_->is_leaf()) return position_ - other.position_;
780        if (position_ == other.position_) return 0;
781      }
782      return distance_slow(other);
783    }
784    reference operator*() const {
785      ABSL_HARDENING_ASSERT(node_ != nullptr);
786      assert_valid_generation(node_);
787      ABSL_HARDENING_ASSERT(position_ >= node_->start());
788      if (position_ >= node_->finish()) {
789        ABSL_HARDENING_ASSERT(!IsEndIterator() && "Dereferencing end() iterator");
790        ABSL_HARDENING_ASSERT(position_ < node_->finish());
791      }
792      return node_->value(static_cast<field_type>(position_));
793    }
794    pointer operator->() const { return &operator*(); }
795    btree_iterator &operator++() {
796      increment();
797      return *this;
798    }
799    btree_iterator &operator--() {
800      decrement();
801      return *this;
802    }
803    btree_iterator operator++(int) {
804      btree_iterator tmp = *this;
805      ++*this;
806      return tmp;
807    }
808    btree_iterator operator--(int) {
809      btree_iterator tmp = *this;
810      --*this;
811      return tmp;
812    }
813   private:
814    friend iterator;
815    friend const_iterator;
816    template <typename Params>
817    friend class btree;
818    template <typename Tree>
819    friend class btree_container;
820    template <typename Tree>
821    friend class btree_set_container;
822    template <typename Tree>
823    friend class btree_map_container;
824    template <typename Tree>
825    friend class btree_multiset_container;
826    template <typename TreeType, typename CheckerType>
827    friend class base_checker;
828    friend struct btree_access;
829    template <typename N, typename R, typename P,
830              absl::enable_if_t<
831                  std::is_same<btree_iterator<N, R, P>, const_iterator>::value &&
832                      std::is_same<btree_iterator, iterator>::value,
833                  int> = 0>
834    explicit btree_iterator(const btree_iterator<N, R, P> other)
835        : btree_iterator_generation_info(other.generation()),
836          node_(const_cast<node_type *>(other.node_)),
837          position_(other.position_) {}
838    bool Equals(const const_iterator other) const {
839      ABSL_HARDENING_ASSERT(((node_ == nullptr && other.node_ == nullptr) ||
840                             (node_ != nullptr && other.node_ != nullptr)) &&
841                            "Comparing default-constructed iterator with "
842                            "non-default-constructed iterator.");
843      assert(AreNodesFromSameContainer(node_, other.node_) &&
844             "Comparing iterators from different containers.");
845      assert_valid_generation(node_);
846      other.assert_valid_generation(other.node_);
847      return node_ == other.node_ && position_ == other.position_;
848    }
849    bool IsEndIterator() const {
850      if (position_ != node_->finish()) return false;
851      node_type *node = node_;
852      while (!node->is_root()) {
853        if (node->position() != node->parent()->finish()) return false;
854        node = node->parent();
855      }
856      return true;
857    }
858    difference_type distance_slow(const_iterator other) const;
859    void increment() {
860      assert_valid_generation(node_);
861      if (node_->is_leaf() && ++position_ < node_->finish()) {
862        return;
863      }
864      increment_slow();
865    }
866    void increment_slow();
867    void decrement() {
868      assert_valid_generation(node_);
869      if (node_->is_leaf() && --position_ >= node_->start()) {
870        return;
871      }
872      decrement_slow();
873    }
874    void decrement_slow();
875    const key_type &key() const {
876      return node_->key(static_cast<size_type>(position_));
877    }
878    decltype(std::declval<Node *>()->slot(0)) slot() {
879      return node_->slot(static_cast<size_type>(position_));
880    }
881    void update_generation() {
882      btree_iterator_generation_info::update_generation(node_);
883    }
884    Node *node_;
885    int position_;
886  };
887  template <typename Params>
888  class btree {
889    using node_type = btree_node<Params>;
890    using is_key_compare_to = typename Params::is_key_compare_to;
891    using field_type = typename node_type::field_type;
892    struct alignas(node_type::Alignment()) EmptyNodeType : node_type {
893      using field_type = typename node_type::field_type;
894      node_type *parent;
895  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
896      uint32_t generation = 0;
897  #endif
898      field_type position = 0;
899      field_type start = 0;
900      field_type finish = 0;
901      field_type max_count = node_type::kInternalNodeMaxCount + 1;
902  #ifdef _MSC_VER
903      EmptyNodeType() : parent(this) {}
904  #else
905      explicit constexpr EmptyNodeType(node_type *p) : parent(p) {}
906  #endif
907    };
908    static node_type *EmptyNode() {
909  #ifdef _MSC_VER
910      static EmptyNodeType *empty_node = new EmptyNodeType;
911      assert(empty_node->parent == empty_node);
912      return empty_node;
913  #else
914      static constexpr EmptyNodeType empty_node(
915          const_cast<EmptyNodeType *>(&empty_node));
916      return const_cast<EmptyNodeType *>(&empty_node);
917  #endif
918    }
919    enum : uint32_t {
920      kNodeSlots = node_type::kNodeSlots,
921      kMinNodeValues = kNodeSlots / 2,
922    };
923    struct node_stats {
924      using size_type = typename Params::size_type;
925      node_stats(size_type l, size_type i) : leaf_nodes(l), internal_nodes(i) {}
926      node_stats &operator+=(const node_stats &other) {
927        leaf_nodes += other.leaf_nodes;
928        internal_nodes += other.internal_nodes;
929        return *this;
930      }
931      size_type leaf_nodes;
932      size_type internal_nodes;
933    };
934   public:
935    using key_type = typename Params::key_type;
936    using value_type = typename Params::value_type;
937    using size_type = typename Params::size_type;
938    using difference_type = typename Params::difference_type;
939    using key_compare = typename Params::key_compare;
940    using original_key_compare = typename Params::original_key_compare;
941    using value_compare = typename Params::value_compare;
942    using allocator_type = typename Params::allocator_type;
943    using reference = typename Params::reference;
944    using const_reference = typename Params::const_reference;
945    using pointer = typename Params::pointer;
946    using const_pointer = typename Params::const_pointer;
947    using iterator =
948        typename btree_iterator<node_type, reference, pointer>::iterator;
949    using const_iterator = typename iterator::const_iterator;
950    using reverse_iterator = std::reverse_iterator<iterator>;
951    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
952    using node_handle_type = node_handle<Params, Params, allocator_type>;
953    using params_type = Params;
954    using slot_type = typename Params::slot_type;
955   private:
956    template <typename Btree>
957    void copy_or_move_values_in_order(Btree &other);
958    constexpr static bool static_assert_validation();
959   public:
960    btree(const key_compare &comp, const allocator_type &alloc)
961        : root_(EmptyNode()), rightmost_(comp, alloc, EmptyNode()), size_(0) {}
962    btree(const btree &other) : btree(other, other.allocator()) {}
963    btree(const btree &other, const allocator_type &alloc)
964        : btree(other.key_comp(), alloc) {
965      copy_or_move_values_in_order(other);
966    }
967    btree(btree &&other) noexcept
968        : root_(absl::exchange(other.root_, EmptyNode())),
969          rightmost_(std::move(other.rightmost_)),
970          size_(absl::exchange(other.size_, 0u)) {
971      other.mutable_rightmost() = EmptyNode();
972    }
973    btree(btree &&other, const allocator_type &alloc)
974        : btree(other.key_comp(), alloc) {
975      if (alloc == other.allocator()) {
976        swap(other);
977      } else {
978        copy_or_move_values_in_order(other);
979      }
980    }
981    ~btree() {
982      static_assert(static_assert_validation(), "This call must be elided.");
983      clear();
984    }
985    btree &operator=(const btree &other);
986    btree &operator=(btree &&other) noexcept;
987    iterator begin() { return iterator(leftmost()); }
988    const_iterator begin() const { return const_iterator(leftmost()); }
989    iterator end() { return iterator(rightmost(), rightmost()->finish()); }
990    const_iterator end() const {
991      return const_iterator(rightmost(), rightmost()->finish());
992    }
993    reverse_iterator rbegin() { return reverse_iterator(end()); }
994    const_reverse_iterator rbegin() const {
995      return const_reverse_iterator(end());
996    }
997    reverse_iterator rend() { return reverse_iterator(begin()); }
998    const_reverse_iterator rend() const {
999      return const_reverse_iterator(begin());
1000    }
1001    template <typename K>
1002    iterator lower_bound(const K &key) {
1003      return internal_end(internal_lower_bound(key).value);
1004    }
1005    template <typename K>
1006    const_iterator lower_bound(const K &key) const {
1007      return internal_end(internal_lower_bound(key).value);
1008    }
1009    template <typename K>
1010    std::pair<iterator, bool> lower_bound_equal(const K &key) const;
1011    template <typename K>
1012    iterator upper_bound(const K &key) {
1013      return internal_end(internal_upper_bound(key));
1014    }
1015    template <typename K>
1016    const_iterator upper_bound(const K &key) const {
1017      return internal_end(internal_upper_bound(key));
1018    }
1019    template <typename K>
1020    std::pair<iterator, iterator> equal_range(const K &key);
1021    template <typename K>
1022    std::pair<const_iterator, const_iterator> equal_range(const K &key) const {
1023      return const_cast<btree *>(this)->equal_range(key);
1024    }
1025    template <typename K, typename... Args>
1026    std::pair<iterator, bool> insert_unique(const K &key, Args &&...args);
1027    template <typename K, typename... Args>
1028    std::pair<iterator, bool> insert_hint_unique(iterator position, const K &key,
1029                                                 Args &&...args);
1030    template <typename InputIterator,
1031              typename = decltype(std::declval<const key_compare &>()(
1032                  params_type::key(*std::declval<InputIterator>()),
1033                  std::declval<const key_type &>()))>
1034    void insert_iterator_unique(InputIterator b, InputIterator e, int);
1035    template <typename InputIterator>
1036    void insert_iterator_unique(InputIterator b, InputIterator e, char);
1037    template <typename ValueType>
1038    iterator insert_multi(const key_type &key, ValueType &&v);
1039    template <typename ValueType>
1040    iterator insert_multi(ValueType &&v) {
1041      return insert_multi(params_type::key(v), std::forward<ValueType>(v));
1042    }
1043    template <typename ValueType>
1044    iterator insert_hint_multi(iterator position, ValueType &&v);
1045    template <typename InputIterator>
1046    void insert_iterator_multi(InputIterator b,
1047                               InputIterator e);
1048    iterator erase(iterator iter);
1049    std::pair<size_type, iterator> erase_range(iterator begin, iterator end);
1050    template <typename K>
1051    iterator find(const K &key) {
1052      return internal_end(internal_find(key));
1053    }
1054    template <typename K>
1055    const_iterator find(const K &key) const {
1056      return internal_end(internal_find(key));
1057    }
1058    void clear();
1059    void swap(btree &other);
1060    const key_compare &key_comp() const noexcept {
1061      return rightmost_.template get<0>();
1062    }
1063    template <typename K1, typename K2>
1064    bool compare_keys(const K1 &a, const K2 &b) const {
1065      return compare_internal::compare_result_as_less_than(key_comp()(a, b));
1066    }
1067    value_compare value_comp() const {
1068      return value_compare(original_key_compare(key_comp()));
1069    }
1070    void verify() const;
1071    size_type size() const { return size_; }
1072    size_type max_size() const { return (std::numeric_limits<size_type>::max)(); }
1073    bool empty() const { return size_ == 0; }
1074    size_type height() const {
1075      size_type h = 0;
1076      if (!empty()) {
1077        const node_type *n = root();
1078        do {
1079          ++h;
1080          n = n->parent();
1081        } while (n != root());
1082      }
1083      return h;
1084    }
1085    size_type leaf_nodes() const { return internal_stats(root()).leaf_nodes; }
1086    size_type internal_nodes() const {
1087      return internal_stats(root()).internal_nodes;
1088    }
1089    size_type nodes() const {
1090      node_stats stats = internal_stats(root());
1091      return stats.leaf_nodes + stats.internal_nodes;
1092    }
1093    size_type bytes_used() const {
1094      node_stats stats = internal_stats(root());
1095      if (stats.leaf_nodes == 1 && stats.internal_nodes == 0) {
1096        return sizeof(*this) + node_type::LeafSize(root()->max_count());
1097      } else {
1098        return sizeof(*this) + stats.leaf_nodes * node_type::LeafSize() +
1099               stats.internal_nodes * node_type::InternalSize();
1100      }
1101    }
1102    static double average_bytes_per_value() {
1103      const double expected_values_per_node = (kNodeSlots + kMinNodeValues) / 2.0;
1104      return node_type::LeafSize() / expected_values_per_node;
1105    }
1106    double fullness() const {
1107      if (empty()) return 0.0;
1108      return static_cast<double>(size()) / (nodes() * kNodeSlots);
1109    }
1110    double overhead() const {
1111      if (empty()) return 0.0;
1112      return (bytes_used() - size() * sizeof(value_type)) /
1113             static_cast<double>(size());
1114    }
1115    allocator_type get_allocator() const { return allocator(); }
1116   private:
1117    friend struct btree_access;
1118    node_type *root() { return root_; }
1119    const node_type *root() const { return root_; }
1120    node_type *&mutable_root() noexcept { return root_; }
1121    node_type *rightmost() { return rightmost_.template get<2>(); }
1122    const node_type *rightmost() const { return rightmost_.template get<2>(); }
1123    node_type *&mutable_rightmost() noexcept {
1124      return rightmost_.template get<2>();
1125    }
1126    key_compare *mutable_key_comp() noexcept {
1127      return &rightmost_.template get<0>();
1128    }
1129    node_type *leftmost() { return root()->parent(); }
1130    const node_type *leftmost() const { return root()->parent(); }
1131    allocator_type *mutable_allocator() noexcept {
1132      return &rightmost_.template get<1>();
1133    }
1134    const allocator_type &allocator() const noexcept {
1135      return rightmost_.template get<1>();
1136    }
1137    node_type *allocate(size_type size) {
1138      return reinterpret_cast<node_type *>(
1139          absl::container_internal::Allocate<node_type::Alignment()>(
1140              mutable_allocator(), size));
1141    }
1142    node_type *new_internal_node(field_type position, node_type *parent) {
1143      node_type *n = allocate(node_type::InternalSize());
1144      n->init_internal(position, parent);
1145      return n;
1146    }
1147    node_type *new_leaf_node(field_type position, node_type *parent) {
1148      node_type *n = allocate(node_type::LeafSize());
1149      n->init_leaf(position, kNodeSlots, parent);
1150      return n;
1151    }
1152    node_type *new_leaf_root_node(field_type max_count) {
1153      node_type *n = allocate(node_type::LeafSize(max_count));
1154      n->init_leaf(&bsol;*position=*/0, max_count, &bsol;*parent=*/n);
1155      return n;
1156    }
1157    iterator rebalance_after_delete(iterator iter);
1158    void rebalance_or_split(iterator *iter);
1159    void merge_nodes(node_type *left, node_type *right);
1160    bool try_merge_or_rebalance(iterator *iter);
1161    void try_shrink();
1162    iterator internal_end(iterator iter) {
1163      return iter.node_ != nullptr ? iter : end();
1164    }
1165    const_iterator internal_end(const_iterator iter) const {
1166      return iter.node_ != nullptr ? iter : end();
1167    }
1168    template <typename... Args>
1169    iterator internal_emplace(iterator iter, Args &&...args);
1170    template <typename IterType>
1171    static IterType internal_last(IterType iter);
1172    template <typename K>
1173    SearchResult<iterator, is_key_compare_to::value> internal_locate(
1174        const K &key) const;
1175    template <typename K>
1176    SearchResult<iterator, is_key_compare_to::value> internal_lower_bound(
1177        const K &key) const;
1178    template <typename K>
1179    iterator internal_upper_bound(const K &key) const;
1180    template <typename K>
1181    iterator internal_find(const K &key) const;
1182    size_type internal_verify(const node_type *node, const key_type *lo,
1183                              const key_type *hi) const;
1184    node_stats internal_stats(const node_type *node) const {
1185      if (node == nullptr || (node == root() && empty())) {
1186        return node_stats(0, 0);
1187      }
1188      if (node->is_leaf()) {
1189        return node_stats(1, 0);
1190      }
1191      node_stats res(0, 1);
1192      for (int i = node->start(); i <= node->finish(); ++i) {
1193        res += internal_stats(node->child(i));
1194      }
1195      return res;
1196    }
1197    node_type *root_;
1198    absl::container_internal::CompressedTuple<key_compare, allocator_type,
1199                                              node_type *>
1200        rightmost_;
1201    size_type size_;
1202  };
1203  template <typename P>
1204  template <typename... Args>
1205  inline void btree_node<P>::emplace_value(const field_type i,
1206                                           allocator_type *alloc,
1207                                           Args &&...args) {
1208    assert(i >= start());
1209    assert(i <= finish());
1210    if (i < finish()) {
1211      transfer_n_backward(finish() - i, &bsol;*dest_i=*/i + 1, &bsol;*src_i=*/i, this,
1212                          alloc);
1213    }
1214    value_init(static_cast<field_type>(i), alloc, std::forward<Args>(args)...);
1215    set_finish(finish() + 1);
1216    if (is_internal() && finish() > i + 1) {
1217      for (field_type j = finish(); j > i + 1; --j) {
1218        set_child(j, child(j - 1));
1219      }
1220      clear_child(i + 1);
1221    }
1222  }
1223  template <typename P>
1224  inline void btree_node<P>::remove_values(const field_type i,
1225                                           const field_type to_erase,
1226                                           allocator_type *alloc) {
1227    value_destroy_n(i, to_erase, alloc);
1228    const field_type orig_finish = finish();
1229    const field_type src_i = i + to_erase;
1230    transfer_n(orig_finish - src_i, i, src_i, this, alloc);
1231    if (is_internal()) {
1232      for (field_type j = 0; j < to_erase; ++j) {
1233        clear_and_delete(child(i + j + 1), alloc);
1234      }
1235      for (field_type j = i + to_erase + 1; j <= orig_finish; ++j) {
1236        set_child(j - to_erase, child(j));
1237        clear_child(j);
1238      }
1239    }
1240    set_finish(orig_finish - to_erase);
1241  }
1242  template <typename P>
1243  void btree_node<P>::rebalance_right_to_left(field_type to_move,
1244                                              btree_node *right,
1245                                              allocator_type *alloc) {
1246    assert(parent() == right->parent());
1247    assert(position() + 1 == right->position());
1248    assert(right->count() >= count());
1249    assert(to_move >= 1);
1250    assert(to_move <= right->count());
1251    transfer(finish(), position(), parent(), alloc);
1252    transfer_n(to_move - 1, finish() + 1, right->start(), right, alloc);
1253    parent()->transfer(position(), right->start() + to_move - 1, right, alloc);
1254    right->transfer_n(right->count() - to_move, right->start(),
1255                      right->start() + to_move, right, alloc);
1256    if (is_internal()) {
1257      for (field_type i = 0; i < to_move; ++i) {
1258        init_child(finish() + i + 1, right->child(i));
1259      }
1260      for (field_type i = right->start(); i <= right->finish() - to_move; ++i) {
1261        assert(i + to_move <= right->max_count());
1262        right->init_child(i, right->child(i + to_move));
1263        right->clear_child(i + to_move);
1264      }
1265    }
1266    set_finish(finish() + to_move);
1267    right->set_finish(right->finish() - to_move);
1268  }
1269  template <typename P>
1270  void btree_node<P>::rebalance_left_to_right(field_type to_move,
1271                                              btree_node *right,
1272                                              allocator_type *alloc) {
1273    assert(parent() == right->parent());
1274    assert(position() + 1 == right->position());
1275    assert(count() >= right->count());
1276    assert(to_move >= 1);
1277    assert(to_move <= count());
1278    right->transfer_n_backward(right->count(), right->start() + to_move,
1279                               right->start(), right, alloc);
1280    right->transfer(right->start() + to_move - 1, position(), parent(), alloc);
1281    right->transfer_n(to_move - 1, right->start(), finish() - (to_move - 1), this,
1282                      alloc);
1283    parent()->transfer(position(), finish() - to_move, this, alloc);
1284    if (is_internal()) {
1285      for (field_type i = right->finish() + 1; i > right->start(); --i) {
1286        right->init_child(i - 1 + to_move, right->child(i - 1));
1287        right->clear_child(i - 1);
1288      }
1289      for (field_type i = 1; i <= to_move; ++i) {
1290        right->init_child(i - 1, child(finish() - to_move + i));
1291        clear_child(finish() - to_move + i);
1292      }
1293    }
1294    set_finish(finish() - to_move);
1295    right->set_finish(right->finish() + to_move);
1296  }
1297  template <typename P>
1298  void btree_node<P>::split(const int insert_position, btree_node *dest,
1299                            allocator_type *alloc) {
1300    assert(dest->count() == 0);
1301    assert(max_count() == kNodeSlots);
1302    assert(position() + 1 == dest->position());
1303    assert(parent() == dest->parent());
1304    if (insert_position == start()) {
1305      dest->set_finish(dest->start() + finish() - 1);
1306    } else if (insert_position == kNodeSlots) {
1307      dest->set_finish(dest->start());
1308    } else {
1309      dest->set_finish(dest->start() + count() / 2);
1310    }
1311    set_finish(finish() - dest->count());
1312    assert(count() >= 1);
1313    dest->transfer_n(dest->count(), dest->start(), finish(), this, alloc);
1314    --mutable_finish();
1315    parent()->emplace_value(position(), alloc, finish_slot());
1316    value_destroy(finish(), alloc);
1317    parent()->set_child_noupdate_position(position() + 1, dest);
1318    if (is_internal()) {
1319      for (field_type i = dest->start(), j = finish() + 1; i <= dest->finish();
1320           ++i, ++j) {
1321        assert(child(j) != nullptr);
1322        dest->init_child(i, child(j));
1323        clear_child(j);
1324      }
1325    }
1326  }
1327  template <typename P>
1328  void btree_node<P>::merge(btree_node *src, allocator_type *alloc) {
1329    assert(parent() == src->parent());
1330    assert(position() + 1 == src->position());
1331    value_init(finish(), alloc, parent()->slot(position()));
1332    transfer_n(src->count(), finish() + 1, src->start(), src, alloc);
1333    if (is_internal()) {
1334      for (field_type i = src->start(), j = finish() + 1; i <= src->finish();
1335           ++i, ++j) {
1336        init_child(j, src->child(i));
1337        src->clear_child(i);
1338      }
1339    }
1340    set_finish(start() + 1 + count() + src->count());
1341    src->set_finish(src->start());
1342    parent()->remove_values(position(), &bsol;*to_erase=*/1, alloc);
1343  }
1344  template <typename P>
1345  void btree_node<P>::clear_and_delete(btree_node *node, allocator_type *alloc) {
1346    if (node->is_leaf()) {
1347      node->value_destroy_n(node->start(), node->count(), alloc);
1348      deallocate(LeafSize(node->max_count()), node, alloc);
1349      return;
1350    }
1351    if (node->count() == 0) {
1352      deallocate(InternalSize(), node, alloc);
1353      return;
1354    }
1355    btree_node *delete_root_parent = node->parent();
1356    while (node->is_internal()) node = node->start_child();
1357  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1358    btree_node *leftmost_leaf = node;
1359  #endif
1360    size_type pos = node->position();
1361    btree_node *parent = node->parent();
1362    for (;;) {
1363      assert(pos <= parent->finish());
1364      do {
1365        node = parent->child(static_cast<field_type>(pos));
1366        if (node->is_internal()) {
1367          while (node->is_internal()) node = node->start_child();
1368          pos = node->position();
1369          parent = node->parent();
1370        }
1371        node->value_destroy_n(node->start(), node->count(), alloc);
1372  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1373        if (leftmost_leaf != node)
1374  #endif
1375          deallocate(LeafSize(node->max_count()), node, alloc);
1376        ++pos;
1377      } while (pos <= parent->finish());
1378      assert(pos > parent->finish());
1379      do {
1380        node = parent;
1381        pos = node->position();
1382        parent = node->parent();
1383        node->value_destroy_n(node->start(), node->count(), alloc);
1384        deallocate(InternalSize(), node, alloc);
1385        if (parent == delete_root_parent) {
1386  #ifdef ABSL_BTREE_ENABLE_GENERATIONS
1387          deallocate(LeafSize(leftmost_leaf->max_count()), leftmost_leaf, alloc);
1388  #endif
1389          return;
1390        }
1391        ++pos;
1392      } while (pos > parent->finish());
1393    }
1394  }
1395  template <typename N, typename R, typename P>
1396  auto btree_iterator<N, R, P>::distance_slow(const_iterator other) const
1397      -> difference_type {
1398    const_iterator begin = other;
1399    const_iterator end = *this;
1400    assert(begin.node_ != end.node_ || !begin.node_->is_leaf() ||
1401           begin.position_ != end.position_);
1402    const node_type *node = begin.node_;
1403    difference_type count = node->is_leaf() ? -begin.position_ : 0;
1404    if (node->is_internal()) {
1405      ++count;
1406      node = node->child(begin.position_ + 1);
1407    }
1408    while (node->is_internal()) node = node->start_child();
1409    size_type pos = node->position();
1410    const node_type *parent = node->parent();
1411    for (;;) {
1412      assert(pos <= parent->finish());
1413      do {
1414        node = parent->child(static_cast<field_type>(pos));
1415        if (node->is_internal()) {
1416          while (node->is_internal()) node = node->start_child();
1417          pos = node->position();
1418          parent = node->parent();
1419        }
1420        if (node == end.node_) return count + end.position_;
1421        if (parent == end.node_ && pos == static_cast<size_type>(end.position_))
1422          return count + node->count();
1423        count += node->count() + 1;
1424        ++pos;
1425      } while (pos <= parent->finish());
1426      assert(pos > parent->finish());
1427      do {
1428        node = parent;
1429        pos = node->position();
1430        parent = node->parent();
1431        if (parent == end.node_ && pos == static_cast<size_type>(end.position_))
1432          return count - 1;
1433        ++pos;
1434      } while (pos > parent->finish());
1435    }
1436  }
1437  template <typename N, typename R, typename P>
1438  void btree_iterator<N, R, P>::increment_slow() {
1439    if (node_->is_leaf()) {
1440      assert(position_ >= node_->finish());
1441      btree_iterator save(*this);
1442      while (position_ == node_->finish() && !node_->is_root()) {
1443        assert(node_->parent()->child(node_->position()) == node_);
1444        position_ = node_->position();
1445        node_ = node_->parent();
1446      }
1447      if (position_ == node_->finish()) {
1448        *this = save;
1449      }
1450    } else {
1451      assert(position_ < node_->finish());
1452      node_ = node_->child(static_cast<field_type>(position_ + 1));
1453      while (node_->is_internal()) {
1454        node_ = node_->start_child();
1455      }
1456      position_ = node_->start();
1457    }
1458  }
1459  template <typename N, typename R, typename P>
1460  void btree_iterator<N, R, P>::decrement_slow() {
1461    if (node_->is_leaf()) {
1462      assert(position_ <= -1);
1463      btree_iterator save(*this);
1464      while (position_ < node_->start() && !node_->is_root()) {
1465        assert(node_->parent()->child(node_->position()) == node_);
1466        position_ = node_->position() - 1;
1467        node_ = node_->parent();
1468      }
1469      if (position_ < node_->start()) {
1470        *this = save;
1471      }
1472    } else {
1473      assert(position_ >= node_->start());
1474      node_ = node_->child(static_cast<field_type>(position_));
1475      while (node_->is_internal()) {
1476        node_ = node_->child(node_->finish());
1477      }
1478      position_ = node_->finish() - 1;
1479    }
1480  }
1481  template <typename P>
1482  template <typename Btree>
1483  void btree<P>::copy_or_move_values_in_order(Btree &other) {
1484    static_assert(std::is_same<btree, Btree>::value ||
1485                      std::is_same<const btree, Btree>::value,
1486                  "Btree type must be same or const.");
1487    assert(empty());
1488    auto iter = other.begin();
1489    if (iter == other.end()) return;
1490    insert_multi(iter.slot());
1491    ++iter;
1492    for (; iter != other.end(); ++iter) {
1493      internal_emplace(end(), iter.slot());
1494    }
1495  }
1496  template <typename P>
1497  constexpr bool btree<P>::static_assert_validation() {
1498    static_assert(std::is_nothrow_copy_constructible<key_compare>::value,
1499                  "Key comparison must be nothrow copy constructible");
1500    static_assert(std::is_nothrow_copy_constructible<allocator_type>::value,
1501                  "Allocator must be nothrow copy constructible");
1502    static_assert(std::is_trivially_copyable<iterator>::value,
1503                  "iterator not trivially copyable.");
1504    static_assert(
1505        kNodeSlots < (1 << (8 * sizeof(typename node_type::field_type))),
1506        "target node size too large");
1507    static_assert(
1508        compare_has_valid_result_type<key_compare, key_type>(),
1509        "key comparison function must return absl::{weak,strong}_ordering or "
1510        "bool.");
1511    static_assert(node_type::MinimumOverhead() >= sizeof(void *) + 4,
1512                  "node space assumption incorrect");
1513    return true;
1514  }
1515  template <typename P>
1516  template <typename K>
1517  auto btree<P>::lower_bound_equal(const K &key) const
1518      -> std::pair<iterator, bool> {
1519    const SearchResult<iterator, is_key_compare_to::value> res =
1520        internal_lower_bound(key);
1521    const iterator lower = iterator(internal_end(res.value));
1522    const bool equal = res.HasMatch()
1523                           ? res.IsEq()
1524                           : lower != end() && !compare_keys(key, lower.key());
1525    return {lower, equal};
1526  }
1527  template <typename P>
1528  template <typename K>
1529  auto btree<P>::equal_range(const K &key) -> std::pair<iterator, iterator> {
1530    const std::pair<iterator, bool> lower_and_equal = lower_bound_equal(key);
1531    const iterator lower = lower_and_equal.first;
1532    if (!lower_and_equal.second) {
1533      return {lower, lower};
1534    }
1535    const iterator next = std::next(lower);
1536    if (!params_type::template can_have_multiple_equivalent_keys<K>()) {
1537      assert(next == end() || compare_keys(key, next.key()));
1538      return {lower, next};
1539    }
1540    if (next == end() || compare_keys(key, next.key())) return {lower, next};
1541    return {lower, upper_bound(key)};
1542  }
1543  template <typename P>
1544  template <typename K, typename... Args>
1545  auto btree<P>::insert_unique(const K &key, Args &&...args)
1546      -> std::pair<iterator, bool> {
1547    if (empty()) {
1548      mutable_root() = mutable_rightmost() = new_leaf_root_node(1);
1549    }
1550    SearchResult<iterator, is_key_compare_to::value> res = internal_locate(key);
1551    iterator iter = res.value;
1552    if (res.HasMatch()) {
1553      if (res.IsEq()) {
1554        return {iter, false};
1555      }
1556    } else {
1557      iterator last = internal_last(iter);
1558      if (last.node_ && !compare_keys(key, last.key())) {
1559        return {last, false};
1560      }
1561    }
1562    return {internal_emplace(iter, std::forward<Args>(args)...), true};
1563  }
1564  template <typename P>
1565  template <typename K, typename... Args>
1566  inline auto btree<P>::insert_hint_unique(iterator position, const K &key,
1567                                           Args &&...args)
1568      -> std::pair<iterator, bool> {
1569    if (!empty()) {
1570      if (position == end() || compare_keys(key, position.key())) {
1571        if (position == begin() || compare_keys(std::prev(position).key(), key)) {
1572          return {internal_emplace(position, std::forward<Args>(args)...), true};
1573        }
1574      } else if (compare_keys(position.key(), key)) {
1575        ++position;
1576        if (position == end() || compare_keys(key, position.key())) {
1577          return {internal_emplace(position, std::forward<Args>(args)...), true};
1578        }
1579      } else {
1580        return {position, false};
1581      }
1582    }
1583    return insert_unique(key, std::forward<Args>(args)...);
1584  }
1585  template <typename P>
1586  template <typename InputIterator, typename>
1587  void btree<P>::insert_iterator_unique(InputIterator b, InputIterator e, int) {
1588    for (; b != e; ++b) {
1589      insert_hint_unique(end(), params_type::key(*b), *b);
1590    }
1591  }
1592  template <typename P>
1593  template <typename InputIterator>
1594  void btree<P>::insert_iterator_unique(InputIterator b, InputIterator e, char) {
1595    for (; b != e; ++b) {
1596      auto node_handle =
1597          CommonAccess::Construct<node_handle_type>(get_allocator(), *b);
1598      slot_type *slot = CommonAccess::GetSlot(node_handle);
1599      insert_hint_unique(end(), params_type::key(slot), slot);
1600    }
1601  }
1602  template <typename P>
1603  template <typename ValueType>
1604  auto btree<P>::insert_multi(const key_type &key, ValueType &&v) -> iterator {
1605    if (empty()) {
1606      mutable_root() = mutable_rightmost() = new_leaf_root_node(1);
1607    }
1608    iterator iter = internal_upper_bound(key);
1609    if (iter.node_ == nullptr) {
1610      iter = end();
1611    }
1612    return internal_emplace(iter, std::forward<ValueType>(v));
1613  }
1614  template <typename P>
1615  template <typename ValueType>
1616  auto btree<P>::insert_hint_multi(iterator position, ValueType &&v) -> iterator {
1617    if (!empty()) {
1618      const key_type &key = params_type::key(v);
1619      if (position == end() || !compare_keys(position.key(), key)) {
1620        if (position == begin() ||
1621            !compare_keys(key, std::prev(position).key())) {
1622          return internal_emplace(position, std::forward<ValueType>(v));
1623        }
1624      } else {
1625        ++position;
1626        if (position == end() || !compare_keys(position.key(), key)) {
1627          return internal_emplace(position, std::forward<ValueType>(v));
1628        }
1629      }
1630    }
1631    return insert_multi(std::forward<ValueType>(v));
1632  }
1633  template <typename P>
1634  template <typename InputIterator>
1635  void btree<P>::insert_iterator_multi(InputIterator b, InputIterator e) {
1636    for (; b != e; ++b) {
1637      insert_hint_multi(end(), *b);
1638    }
1639  }
1640  template <typename P>
1641  auto btree<P>::operator=(const btree &other) -> btree & {
1642    if (this != &other) {
1643      clear();
1644      *mutable_key_comp() = other.key_comp();
1645      if (absl::allocator_traits<
1646              allocator_type>::propagate_on_container_copy_assignment::value) {
1647        *mutable_allocator() = other.allocator();
1648      }
1649      copy_or_move_values_in_order(other);
1650    }
1651    return *this;
1652  }
1653  template <typename P>
1654  auto btree<P>::operator=(btree &&other) noexcept -> btree & {
1655    if (this != &other) {
1656      clear();
1657      using std::swap;
1658      if (absl::allocator_traits<
1659              allocator_type>::propagate_on_container_copy_assignment::value) {
1660        swap(root_, other.root_);
1661        swap(rightmost_, other.rightmost_);
1662        swap(size_, other.size_);
1663      } else {
1664        if (allocator() == other.allocator()) {
1665          swap(mutable_root(), other.mutable_root());
1666          swap(*mutable_key_comp(), *other.mutable_key_comp());
1667          swap(mutable_rightmost(), other.mutable_rightmost());
1668          swap(size_, other.size_);
1669        } else {
1670          *mutable_key_comp() = other.key_comp();
1671          copy_or_move_values_in_order(other);
1672        }
1673      }
1674    }
1675    return *this;
1676  }
1677  template <typename P>
1678  auto btree<P>::erase(iterator iter) -> iterator {
1679    iter.node_->value_destroy(static_cast<field_type>(iter.position_),
1680                              mutable_allocator());
1681    iter.update_generation();
1682    const bool internal_delete = iter.node_->is_internal();
1683    if (internal_delete) {
1684      iterator internal_iter(iter);
1685      --iter;
1686      assert(iter.node_->is_leaf());
1687      internal_iter.node_->transfer(
1688          static_cast<size_type>(internal_iter.position_),
1689          static_cast<size_type>(iter.position_), iter.node_,
1690          mutable_allocator());
1691    } else {
1692      const field_type transfer_from =
1693          static_cast<field_type>(iter.position_ + 1);
1694      const field_type num_to_transfer = iter.node_->finish() - transfer_from;
1695      iter.node_->transfer_n(num_to_transfer,
1696                             static_cast<size_type>(iter.position_),
1697                             transfer_from, iter.node_, mutable_allocator());
1698    }
1699    iter.node_->set_finish(iter.node_->finish() - 1);
1700    --size_;
1701    iterator res = rebalance_after_delete(iter);
1702    if (internal_delete) {
1703      ++res;
1704    }
1705    return res;
1706  }
1707  template <typename P>
1708  auto btree<P>::rebalance_after_delete(iterator iter) -> iterator {
1709    iterator res(iter);
1710    bool first_iteration = true;
1711    for (;;) {
1712      if (iter.node_ == root()) {
1713        try_shrink();
1714        if (empty()) {
1715          return end();
1716        }
1717        break;
1718      }
1719      if (iter.node_->count() >= kMinNodeValues) {
1720        break;
1721      }
1722      bool merged = try_merge_or_rebalance(&iter);
1723      if (first_iteration) {
1724        res = iter;
1725        first_iteration = false;
1726      }
1727      if (!merged) {
1728        break;
1729      }
1730      iter.position_ = iter.node_->position();
1731      iter.node_ = iter.node_->parent();
1732    }
1733    res.update_generation();
1734    if (res.position_ == res.node_->finish()) {
1735      res.position_ = res.node_->finish() - 1;
1736      ++res;
1737    }
1738    return res;
1739  }
1740  template <typename P>
1741  auto btree<P>::erase_range(iterator begin, iterator end)
1742      -> std::pair<size_type, iterator> {
1743    size_type count = static_cast<size_type>(end - begin);
1744    assert(count >= 0);
1745    if (count == 0) {
1746      return {0, begin};
1747    }
1748    if (static_cast<size_type>(count) == size_) {
1749      clear();
1750      return {count, this->end()};
1751    }
1752    if (begin.node_ == end.node_) {
1753      assert(end.position_ > begin.position_);
1754      begin.node_->remove_values(
1755          static_cast<field_type>(begin.position_),
1756          static_cast<field_type>(end.position_ - begin.position_),
1757          mutable_allocator());
1758      size_ -= count;
1759      return {count, rebalance_after_delete(begin)};
1760    }
1761    const size_type target_size = size_ - count;
1762    while (size_ > target_size) {
1763      if (begin.node_->is_leaf()) {
1764        const size_type remaining_to_erase = size_ - target_size;
1765        const size_type remaining_in_node =
1766            static_cast<size_type>(begin.node_->finish() - begin.position_);
1767        const field_type to_erase = static_cast<field_type>(
1768            (std::min)(remaining_to_erase, remaining_in_node));
1769        begin.node_->remove_values(static_cast<field_type>(begin.position_),
1770                                   to_erase, mutable_allocator());
1771        size_ -= to_erase;
1772        begin = rebalance_after_delete(begin);
1773      } else {
1774        begin = erase(begin);
1775      }
1776    }
1777    begin.update_generation();
1778    return {count, begin};
1779  }
1780  template <typename P>
1781  void btree<P>::clear() {
1782    if (!empty()) {
1783      node_type::clear_and_delete(root(), mutable_allocator());
1784    }
1785    mutable_root() = mutable_rightmost() = EmptyNode();
1786    size_ = 0;
1787  }
1788  template <typename P>
1789  void btree<P>::swap(btree &other) {
1790    using std::swap;
1791    if (absl::allocator_traits<
1792            allocator_type>::propagate_on_container_swap::value) {
1793      swap(rightmost_, other.rightmost_);
1794    } else {
1795      assert(allocator() == other.allocator());
1796      swap(mutable_rightmost(), other.mutable_rightmost());
1797      swap(*mutable_key_comp(), *other.mutable_key_comp());
1798    }
1799    swap(mutable_root(), other.mutable_root());
1800    swap(size_, other.size_);
1801  }
1802  template <typename P>
1803  void btree<P>::verify() const {
1804    assert(root() != nullptr);
1805    assert(leftmost() != nullptr);
1806    assert(rightmost() != nullptr);
1807    assert(empty() || size() == internal_verify(root(), nullptr, nullptr));
1808    assert(leftmost() == (++const_iterator(root(), -1)).node_);
1809    assert(rightmost() == (--const_iterator(root(), root()->finish())).node_);
1810    assert(leftmost()->is_leaf());
1811    assert(rightmost()->is_leaf());
1812  }
1813  template <typename P>
1814  void btree<P>::rebalance_or_split(iterator *iter) {
1815    node_type *&node = iter->node_;
1816    int &insert_position = iter->position_;
1817    assert(node->count() == node->max_count());
1818    assert(kNodeSlots == node->max_count());
1819    node_type *parent = node->parent();
1820    if (node != root()) {
1821      if (node->position() > parent->start()) {
1822        node_type *left = parent->child(node->position() - 1);
1823        assert(left->max_count() == kNodeSlots);
1824        if (left->count() < kNodeSlots) {
1825          field_type to_move =
1826              (kNodeSlots - left->count()) /
1827              (1 + (static_cast<field_type>(insert_position) < kNodeSlots));
1828          to_move = (std::max)(field_type{1}, to_move);
1829          if (static_cast<field_type>(insert_position) - to_move >=
1830                  node->start() ||
1831              left->count() + to_move < kNodeSlots) {
1832            left->rebalance_right_to_left(to_move, node, mutable_allocator());
1833            assert(node->max_count() - node->count() == to_move);
1834            insert_position = static_cast<int>(
1835                static_cast<field_type>(insert_position) - to_move);
1836            if (insert_position < node->start()) {
1837              insert_position = insert_position + left->count() + 1;
1838              node = left;
1839            }
1840            assert(node->count() < node->max_count());
1841            return;
1842          }
1843        }
1844      }
1845      if (node->position() < parent->finish()) {
1846        node_type *right = parent->child(node->position() + 1);
1847        assert(right->max_count() == kNodeSlots);
1848        if (right->count() < kNodeSlots) {
1849          field_type to_move = (kNodeSlots - right->count()) /
1850                               (1 + (insert_position > node->start()));
1851          to_move = (std::max)(field_type{1}, to_move);
1852          if (static_cast<field_type>(insert_position) <=
1853                  node->finish() - to_move ||
1854              right->count() + to_move < kNodeSlots) {
1855            node->rebalance_left_to_right(to_move, right, mutable_allocator());
1856            if (insert_position > node->finish()) {
1857              insert_position = insert_position - node->count() - 1;
1858              node = right;
1859            }
1860            assert(node->count() < node->max_count());
1861            return;
1862          }
1863        }
1864      }
1865      assert(parent->max_count() == kNodeSlots);
1866      if (parent->count() == kNodeSlots) {
1867        iterator parent_iter(parent, node->position());
1868        rebalance_or_split(&parent_iter);
1869        parent = node->parent();
1870      }
1871    } else {
1872      parent = new_internal_node(&bsol;*position=*/0, parent);
1873      parent->set_generation(root()->generation());
1874      parent->init_child(parent->start(), node);
1875      mutable_root() = parent;
1876      assert(parent->start_child()->is_internal() ||
1877             parent->start_child() == rightmost());
1878    }
1879    node_type *split_node;
1880    if (node->is_leaf()) {
1881      split_node = new_leaf_node(node->position() + 1, parent);
1882      node->split(insert_position, split_node, mutable_allocator());
1883      if (rightmost() == node) mutable_rightmost() = split_node;
1884    } else {
1885      split_node = new_internal_node(node->position() + 1, parent);
1886      node->split(insert_position, split_node, mutable_allocator());
1887    }
1888    if (insert_position > node->finish()) {
1889      insert_position = insert_position - node->count() - 1;
1890      node = split_node;
1891    }
1892  }
1893  template <typename P>
1894  void btree<P>::merge_nodes(node_type *left, node_type *right) {
1895    left->merge(right, mutable_allocator());
1896    if (rightmost() == right) mutable_rightmost() = left;
1897  }
1898  template <typename P>
1899  bool btree<P>::try_merge_or_rebalance(iterator *iter) {
1900    node_type *parent = iter->node_->parent();
1901    if (iter->node_->position() > parent->start()) {
1902      node_type *left = parent->child(iter->node_->position() - 1);
1903      assert(left->max_count() == kNodeSlots);
1904      if (1U + left->count() + iter->node_->count() <= kNodeSlots) {
1905        iter->position_ += 1 + left->count();
1906        merge_nodes(left, iter->node_);
1907        iter->node_ = left;
1908        return true;
1909      }
1910    }
1911    if (iter->node_->position() < parent->finish()) {
1912      node_type *right = parent->child(iter->node_->position() + 1);
1913      assert(right->max_count() == kNodeSlots);
1914      if (1U + iter->node_->count() + right->count() <= kNodeSlots) {
1915        merge_nodes(iter->node_, right);
1916        return true;
1917      }
1918      if (right->count() > kMinNodeValues &&
1919          (iter->node_->count() == 0 || iter->position_ > iter->node_->start())) {
1920        field_type to_move = (right->count() - iter->node_->count()) / 2;
1921        to_move =
1922            (std::min)(to_move, static_cast<field_type>(right->count() - 1));
1923        iter->node_->rebalance_right_to_left(to_move, right, mutable_allocator());
1924        return false;
1925      }
1926    }
1927    if (iter->node_->position() > parent->start()) {
1928      node_type *left = parent->child(iter->node_->position() - 1);
1929      if (left->count() > kMinNodeValues &&
1930          (iter->node_->count() == 0 ||
1931           iter->position_ < iter->node_->finish())) {
1932        field_type to_move = (left->count() - iter->node_->count()) / 2;
1933        to_move = (std::min)(to_move, static_cast<field_type>(left->count() - 1));
1934        left->rebalance_left_to_right(to_move, iter->node_, mutable_allocator());
1935        iter->position_ += to_move;
1936        return false;
1937      }
1938    }
1939    return false;
1940  }
1941  template <typename P>
1942  void btree<P>::try_shrink() {
1943    node_type *orig_root = root();
1944    if (orig_root->count() > 0) {
1945      return;
1946    }
1947    if (orig_root->is_leaf()) {
1948      assert(size() == 0);
1949      mutable_root() = mutable_rightmost() = EmptyNode();
1950    } else {
1951      node_type *child = orig_root->start_child();
1952      child->make_root();
1953      mutable_root() = child;
1954    }
1955    node_type::clear_and_delete(orig_root, mutable_allocator());
1956  }
1957  template <typename P>
1958  template <typename IterType>
1959  inline IterType btree<P>::internal_last(IterType iter) {
1960    assert(iter.node_ != nullptr);
1961    while (iter.position_ == iter.node_->finish()) {
1962      iter.position_ = iter.node_->position();
1963      iter.node_ = iter.node_->parent();
1964      if (iter.node_->is_leaf()) {
1965        iter.node_ = nullptr;
1966        break;
1967      }
1968    }
1969    iter.update_generation();
1970    return iter;
1971  }
1972  template <typename P>
1973  template <typename... Args>
1974  inline auto btree<P>::internal_emplace(iterator iter, Args &&...args)
1975      -> iterator {
1976    if (iter.node_->is_internal()) {
1977      --iter;
1978      ++iter.position_;
1979    }
1980    const field_type max_count = iter.node_->max_count();
1981    allocator_type *alloc = mutable_allocator();
1982    const auto transfer_and_delete = [&](node_type *old_node,
1983                                         node_type *new_node) {
1984      new_node->transfer_n(old_node->count(), new_node->start(),
1985                           old_node->start(), old_node, alloc);
1986      new_node->set_finish(old_node->finish());
1987      old_node->set_finish(old_node->start());
1988      new_node->set_generation(old_node->generation());
1989      node_type::clear_and_delete(old_node, alloc);
1990    };
1991    const auto replace_leaf_root_node = [&](field_type new_node_size) {
1992      assert(iter.node_ == root());
1993      node_type *old_root = iter.node_;
1994      node_type *new_root = iter.node_ = new_leaf_root_node(new_node_size);
1995      transfer_and_delete(old_root, new_root);
1996      mutable_root() = mutable_rightmost() = new_root;
1997    };
1998    bool replaced_node = false;
1999    if (iter.node_->count() == max_count) {
2000      if (max_count < kNodeSlots) {
2001        replace_leaf_root_node(static_cast<field_type>(
2002            (std::min)(static_cast<int>(kNodeSlots), 2 * max_count)));
2003        replaced_node = true;
2004      } else {
2005        rebalance_or_split(&iter);
2006      }
2007    }
2008    (void)replaced_node;
2009  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
2010    if (!replaced_node) {
2011      assert(iter.node_->is_leaf());
2012      if (iter.node_->is_root()) {
2013        replace_leaf_root_node(max_count);
2014      } else {
2015        node_type *old_node = iter.node_;
2016        const bool was_rightmost = rightmost() == old_node;
2017        const bool was_leftmost = leftmost() == old_node;
2018        node_type *parent = old_node->parent();
2019        const field_type position = old_node->position();
2020        node_type *new_node = iter.node_ = new_leaf_node(position, parent);
2021        parent->set_child_noupdate_position(position, new_node);
2022        transfer_and_delete(old_node, new_node);
2023        if (was_rightmost) mutable_rightmost() = new_node;
2024        if (was_leftmost) root()->set_parent(new_node);
2025      }
2026    }
2027  #endif
2028    iter.node_->emplace_value(static_cast<field_type>(iter.position_), alloc,
2029                              std::forward<Args>(args)...);
2030    assert(
2031        iter.node_->is_ordered_correctly(static_cast<field_type>(iter.position_),
2032                                         original_key_compare(key_comp())) &&
2033        "If this assert fails, then either (1) the comparator may violate "
2034        "transitivity, i.e. comp(a,b) && comp(b,c) -> comp(a,c) (see "
2035        "https:&bsol;&bsol;en.cppreference.com/w/cpp/named_req/Compare), or (2) a "
2036        "key may have been mutated after it was inserted into the tree.");
2037    ++size_;
2038    iter.update_generation();
2039    return iter;
2040  }
2041  template <typename P>
2042  template <typename K>
2043  inline auto btree<P>::internal_locate(const K &key) const
2044      -> SearchResult<iterator, is_key_compare_to::value> {
2045    iterator iter(const_cast<node_type *>(root()));
2046    for (;;) {
2047      SearchResult<size_type, is_key_compare_to::value> res =
2048          iter.node_->lower_bound(key, key_comp());
2049      iter.position_ = static_cast<int>(res.value);
2050      if (res.IsEq()) {
2051        return {iter, MatchKind::kEq};
2052      }
2053      if (iter.node_->is_leaf()) {
2054        break;
2055      }
2056      iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));
2057    }
2058    return {iter, MatchKind::kNe};
2059  }
2060  template <typename P>
2061  template <typename K>
2062  auto btree<P>::internal_lower_bound(const K &key) const
2063      -> SearchResult<iterator, is_key_compare_to::value> {
2064    if (!params_type::template can_have_multiple_equivalent_keys<K>()) {
2065      SearchResult<iterator, is_key_compare_to::value> ret = internal_locate(key);
2066      ret.value = internal_last(ret.value);
2067      return ret;
2068    }
2069    iterator iter(const_cast<node_type *>(root()));
2070    SearchResult<size_type, is_key_compare_to::value> res;
2071    bool seen_eq = false;
2072    for (;;) {
2073      res = iter.node_->lower_bound(key, key_comp());
2074      iter.position_ = static_cast<int>(res.value);
2075      if (iter.node_->is_leaf()) {
2076        break;
2077      }
2078      seen_eq = seen_eq || res.IsEq();
2079      iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));
2080    }
2081    if (res.IsEq()) return {iter, MatchKind::kEq};
2082    return {internal_last(iter), seen_eq ? MatchKind::kEq : MatchKind::kNe};
2083  }
2084  template <typename P>
2085  template <typename K>
2086  auto btree<P>::internal_upper_bound(const K &key) const -> iterator {
2087    iterator iter(const_cast<node_type *>(root()));
2088    for (;;) {
2089      iter.position_ = static_cast<int>(iter.node_->upper_bound(key, key_comp()));
2090      if (iter.node_->is_leaf()) {
2091        break;
2092      }
2093      iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));
2094    }
2095    return internal_last(iter);
2096  }
2097  template <typename P>
2098  template <typename K>
2099  auto btree<P>::internal_find(const K &key) const -> iterator {
2100    SearchResult<iterator, is_key_compare_to::value> res = internal_locate(key);
2101    if (res.HasMatch()) {
2102      if (res.IsEq()) {
2103        return res.value;
2104      }
2105    } else {
2106      const iterator iter = internal_last(res.value);
2107      if (iter.node_ != nullptr && !compare_keys(key, iter.key())) {
2108        return iter;
2109      }
2110    }
2111    return {nullptr, 0};
2112  }
2113  template <typename P>
2114  typename btree<P>::size_type btree<P>::internal_verify(
2115      const node_type *node, const key_type *lo, const key_type *hi) const {
2116    assert(node->count() > 0);
2117    assert(node->count() <= node->max_count());
2118    if (lo) {
2119      assert(!compare_keys(node->key(node->start()), *lo));
2120    }
2121    if (hi) {
2122      assert(!compare_keys(*hi, node->key(node->finish() - 1)));
2123    }
2124    for (int i = node->start() + 1; i < node->finish(); ++i) {
2125      assert(!compare_keys(node->key(i), node->key(i - 1)));
2126    }
2127    size_type count = node->count();
2128    if (node->is_internal()) {
2129      for (field_type i = node->start(); i <= node->finish(); ++i) {
2130        assert(node->child(i) != nullptr);
2131        assert(node->child(i)->parent() == node);
2132        assert(node->child(i)->position() == i);
2133        count += internal_verify(node->child(i),
2134                                 i == node->start() ? lo : &node->key(i - 1),
2135                                 i == node->finish() ? hi : &node->key(i));
2136      }
2137    }
2138    return count;
2139  }
2140  struct btree_access {
2141    template <typename BtreeContainer, typename Pred>
2142    static auto erase_if(BtreeContainer &container, Pred pred) ->
2143        typename BtreeContainer::size_type {
2144      const auto initial_size = container.size();
2145      auto &tree = container.tree_;
2146      auto *alloc = tree.mutable_allocator();
2147      for (auto it = container.begin(); it != container.end();) {
2148        if (!pred(*it)) {
2149          ++it;
2150          continue;
2151        }
2152        auto *node = it.node_;
2153        if (node->is_internal()) {
2154          it = container.erase(it);
2155          continue;
2156        }
2157        int to_pos = it.position_;
2158        node->value_destroy(it.position_, alloc);
2159        while (++it.position_ < node->finish()) {
2160          it.update_generation();
2161          if (pred(*it)) {
2162            node->value_destroy(it.position_, alloc);
2163          } else {
2164            node->transfer(node->slot(to_pos++), node->slot(it.position_), alloc);
2165          }
2166        }
2167        const int num_deleted = node->finish() - to_pos;
2168        tree.size_ -= num_deleted;
2169        node->set_finish(to_pos);
2170        it.position_ = to_pos;
2171        it = tree.rebalance_after_delete(it);
2172      }
2173      return initial_size - container.size();
2174    }
2175  };
2176  #undef ABSL_BTREE_ENABLE_GENERATIONS
2177  }  
2178  ABSL_NAMESPACE_END
2179  }  
2180  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-marshalling_test.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree.h</div>
                <div class="column column_space"><pre><code>335  TEST(MarshallingTest, TestInt128Parsing) {
336    std::string err;
337    absl::int128 value;
338    absl::int128 zero = 0;
339    absl::int128 one = 1;
340    absl::int128 neg_one = -1;
341    absl::int128 hundred = 100;
342    absl::int128 hundreds_val = 123;
343    absl::int128 neg_thousands_val = -98765;
344    absl::int128 pos_three = 3;
345    EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
346    EXPECT_EQ(value, zero);
347    EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
348    EXPECT_EQ(value, one);
349    EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
350    EXPECT_EQ(value, neg_one);
351    EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
352    EXPECT_EQ(value, hundreds_val);
353    EXPECT_TRUE(absl::ParseFlag("-98765", &value, &err));
354    EXPECT_EQ(value, neg_thousands_val);
355    EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
356    EXPECT_EQ(value, pos_three);
357    EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
358    EXPECT_EQ(value, one);
359    EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
360    EXPECT_EQ(value, one);
361    EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
362    EXPECT_EQ(value, hundred);
363    absl::int128 sixteen = 16;
364    absl::int128 quintillion_val = 1152827684197027293;
365    absl::int128 quintillion_val2 =
</pre></code></div>
                <div class="column column_space"><pre><code>295  class btree_node {
296    using is_key_compare_to = typename Params::is_key_compare_to;
297    using field_type = typename Params::node_count_type;
298    using allocator_type = typename Params::allocator_type;
299    using slot_type = typename Params::slot_type;
300    using original_key_compare = typename Params::original_key_compare;
301   public:
302    using params_type = Params;
303    using key_type = typename Params::key_type;
304    using value_type = typename Params::value_type;
305    using pointer = typename Params::pointer;
306    using const_pointer = typename Params::const_pointer;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    