
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nlpwinlf.cpp</h3>
            <pre><code>1  #include "nlpwinlf.h"
2  void TLfSubst::GetLfSubstV(TLfSubstV& LfSubstV){
3    LfSubstV.Clr();
4    { 
5    PLfSubst LfSubst=TLfSubst::New("He"); LfSubstV.Add(LfSubst);
6    LfSubst->AddTarget("he"); LfSubst->AddTarget("him");
7    LfSubst->AddTarget("his"); LfSubst->AddTarget("himself");
8    LfSubst->AddSelBit("Masc");
9    LfSubst->AddSelBit("Sing");
10    LfSubst->AddSelBit("Humn");
11    }
12    { 
13    PLfSubst LfSubst=TLfSubst::New("She"); LfSubstV.Add(LfSubst);
14    LfSubst->AddTarget("she"); LfSubst->AddTarget("her");
15    LfSubst->AddTarget("hers"); LfSubst->AddTarget("herself");
16    LfSubst->AddSelBit("Fem");
17    LfSubst->AddSelBit("Sing");
18    LfSubst->AddSelBit("Humn");
19    }
20    { 
21    PLfSubst LfSubst=TLfSubst::New("Name"); LfSubstV.Add(LfSubst);
22    LfSubst->AddSelBit("Sing");
23    LfSubst->AddSelBit("PrprN");
24    }
25    { 
26    PLfSubst LfSubst=TLfSubst::New("They"); LfSubstV.Add(LfSubst);
27    LfSubst->AddTarget("they"); LfSubst->AddTarget("their");
28    LfSubst->AddSelBit("Plur");
29    LfSubst->AddSelBit("Humn");
30    }
31  }
32  void TLfSubst::Dump(const bool& DumpP, const TLfSubstV& LfSubstV){
33    if (!DumpP){return;}
34    printf("---Start-----Substitutions-------\n");
35    for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
36      PLfSubst LfSubst=LfSubstV[LfSubstN];
37      printf("%s : %s\n", LfSubst->SubstId.CStr(), LfSubst->SubstStr.CStr());
38    }
39    printf("---End-------Substitutions-------\n");
40  }
41  bool TLfAliasBs::IsGenericWord(const TStr& WordStr) const {
42    if (WordStr.IsChIn('.')){return true;}
43    if (SwSet->IsIn(WordStr)){return true;}
44    if (WordStr=="PRESIDENT"){return true;}
45    if (WordStr=="JUSTICE"){return true;}
46    if (WordStr=="JUDGE"){return true;}
47    if (WordStr=="NIGHT"){return true;}
48    if (WordStr=="U.S."){return true;}
49    if (WordStr=="SOUTH"){return true;}
50    if (WordStr=="NORTH"){return true;}
51    if (WordStr=="WEST"){return true;}
52    if (WordStr=="EAST"){return true;}
53    return false;
54  }
55  void TLfAliasBs::PutAliasStr(const TStr& SrcStr, const TStr& SubstId, TStr& DstStr){
56    TStr SrcUcStr=SrcStr.GetUc();
57    TStrV SrcUcStrV; SrcUcStr.SplitOnWs(SrcUcStrV);
58    for (int SrcUcStrN=0; SrcUcStrN<SrcUcStrV.Len(); SrcUcStrN++){
59      if (IsGenericWord(SrcUcStrV[SrcUcStrN])){
60        SrcUcStrV[SrcUcStrN]="";}
61    }
62    SrcUcStrV.DelAll("");
63    SrcUcStrV.Sort();
64    if (WordStrVToAliasStrH.IsKey(SrcUcStrV)){
65      DstStr=WordStrVToAliasStrH.GetDat(SrcUcStrV);
66      WordStrVToAliasH.GetDat(SrcUcStrV).IncFq();
67    } else {
68      for (int WAStrP=0; WAStrP<WordStrVToAliasStrH.Len(); WAStrP++){
69        TStrV& WordUcStrV=WordStrVToAliasStrH.GetKey(WAStrP);
70        TStr AliasStr=WordStrVToAliasStrH[WAStrP];
71        TStrV IntrsWordStrV; WordUcStrV.Intrs(SrcUcStrV, IntrsWordStrV);
72        if (IntrsWordStrV.Len()>0){
73          AddAlias(SrcUcStrV, SubstId, AliasStr);
74          DstStr=AliasStr;
75          return;
76        }
77      }
78      AddAlias(SrcUcStrV, SubstId, SrcStr);
79      DstStr=SrcStr;
80    }
81  }
82  void TLfAliasBs::UpdateLfSubstV(const TStr& AliasStr, const TLfSubstV& LfSubstV) const {
83    for (int WToAN=0; WToAN<WordStrVToAliasStrH.Len(); WToAN++){
84      if (WordStrVToAliasStrH[WToAN]==AliasStr){
85        TStrV& WordStrV=WordStrVToAliasStrH.GetKey(WToAN);
86        TStr SubstId=WordStrVToAliasH.GetDat(WordStrV).GetSubstId();
87        for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
88          if (LfSubstV[LfSubstN]->SubstId==SubstId){
89            LfSubstV[LfSubstN]->SubstStr=AliasStr;
90          }
91        }
92      }
93    }
94  }
95  void TLfAliasBs::AddAlias(
96   const TStrV& WordStrV, const TStr& SubstId, const TStr& AliasStr){
97    WordStrVToAliasStrH.AddDat(WordStrV, AliasStr);
98    IAssert(!WordStrVToAliasH.IsKey(WordStrV));
99    TLfAlias LfAlias(SubstId);
100    LfAlias.IncFq();
101    WordStrVToAliasH.AddDat(WordStrV, LfAlias);
102  }
103  void TLfAliasBs::MergeAliasBs(const PLfAliasBs& LfAliasBs){
104    int MnAliasFq=2;
105    int MnIntrsLen=2;
106    for (int NewWordStrVN=0; NewWordStrVN<LfAliasBs->WordStrVToAliasH.Len(); NewWordStrVN++){
107      TStrV& NewWordStrV=LfAliasBs->WordStrVToAliasH.GetKey(NewWordStrVN);
108      TStr NewAliasStr=LfAliasBs->WordStrVToAliasStrH.GetDat(NewWordStrV);
109      int NewAliasFq=LfAliasBs->WordStrVToAliasH[NewWordStrVN].GetFq();
110      if (NewAliasFq>=MnAliasFq){
111        if (WordStrVToAliasH.IsKey(NewWordStrV)){
112          WordStrVToAliasH.GetDat(NewWordStrV).IncFq(NewAliasFq);
113        } else {
114          TIntKdV IntrsLen_OldWordStrVNV;
115          for (int OldWordStrVN=0; OldWordStrVN<WordStrVToAliasH.Len(); OldWordStrVN++){
116            TStrV& OldWordStrV=WordStrVToAliasH.GetKey(OldWordStrVN);
117            TStr OldAliasStr=WordStrVToAliasStrH.GetDat(OldWordStrV);
118            TStrV IntrsWordStrV; NewWordStrV.Intrs(OldWordStrV, IntrsWordStrV);
119            if (IntrsWordStrV.Len()>0){
120              IntrsLen_OldWordStrVNV.Add(TIntKd(IntrsWordStrV.Len(), OldWordStrVN));
121            }
122          }
123          IntrsLen_OldWordStrVNV.Sort(false);
124          if (IntrsLen_OldWordStrVNV.Len()==0){
125            TLfAlias NewLfAlias(LfAliasBs->WordStrVToAliasH[NewWordStrVN]);
126            WordStrVToAliasH.AddDat(NewWordStrV, NewLfAlias);
127            WordStrVToAliasStrH.AddDat(NewWordStrV, NewAliasStr);
128          } else
129          if (IntrsLen_OldWordStrVNV.Len()>=MnIntrsLen){
130            int OldWordStrVN=IntrsLen_OldWordStrVNV[0].Dat;
131            TStrV& OldWordStrV=WordStrVToAliasH.GetKey(OldWordStrVN);
132            TStr OldAliasStr=WordStrVToAliasStrH.GetDat(OldWordStrV);
133            TLfAlias NewLfAlias(LfAliasBs->WordStrVToAliasH[NewWordStrVN]);
134            WordStrVToAliasH.AddDat(NewWordStrV, NewLfAlias);
135            WordStrVToAliasStrH.AddDat(NewWordStrV, OldAliasStr);
136          }
137        }
138      }
139    }
140  }
141  void TLfAliasBs::Dump(const bool& DumpP, const int& MnAliasFq) const {
142    if (!DumpP){return;}
143    printf("Alias-Base\n");
144    TStrStrVPrV AliasStrWordStrVV;
145    WordStrVToAliasStrH.GetDatKeyPrV(AliasStrWordStrVV);
146    AliasStrWordStrVV.Sort();
147    for (int AliasN=0; AliasN<AliasStrWordStrVV.Len(); AliasN++){
148      TStr AliasStr=AliasStrWordStrVV[AliasN].Val1;
149      TStrV& WordStrV=AliasStrWordStrVV[AliasN].Val2;
150      TStr SubstId=WordStrVToAliasH.GetDat(WordStrV).GetSubstId();
151      int Fq=WordStrVToAliasH.GetDat(WordStrV).GetFq();
152      if ((MnAliasFq==-1)||(Fq>=MnAliasFq)){
153        printf("%s :", AliasStr.CStr());
154        for (int WordN=0; WordN<WordStrV.Len(); WordN++){
155          printf(" %s", WordStrV[WordN].CStr());}
156        printf(" [%s/%d]\n", SubstId.CStr(), Fq);
157      }
158    }
159    printf("======================\n");
160  }
161  TStrH TLfSpo::UnusableWordStrH;
162  bool TLfSpo::IsUsable() const {
163    if (UnusableWordStrH.Empty()){
164      UnusableWordStrH.AddKey(";");
165      UnusableWordStrH.AddKey(",");
166      UnusableWordStrH.AddKey("_");
167      UnusableWordStrH.AddKey("BEEN");
168      UnusableWordStrH.AddKey("ARE");
169      UnusableWordStrH.AddKey("AREN'T");
170      UnusableWordStrH.AddKey("IS");
171      UnusableWordStrH.AddKey("DID");
172      UnusableWordStrH.AddKey("WAS");
173      UnusableWordStrH.AddKey("WERE");
174      UnusableWordStrH.AddKey("IT");
175      UnusableWordStrH.AddKey("WE");
176      UnusableWordStrH.AddKey("I");
177      UnusableWordStrH.AddKey("YOU");
178      UnusableWordStrH.AddKey("AND");
179      UnusableWordStrH.AddKey("OR");
180      UnusableWordStrH.AddKey("HE");
181      UnusableWordStrH.AddKey("SHE");
182      UnusableWordStrH.AddKey("THIS");
183    }
184    TStr UcSubjStr=SubjStr.GetUc();
185    TStr UcObjStr=ObjStr.GetUc();
186    if ((UnusableWordStrH.IsKey(UcSubjStr))||(UnusableWordStrH.IsKey(UcObjStr))){
187      return false;
188    } else {
189      return true;
190    }
191  }
192  TStr TLfSpo::GetSent() const {
193    TChA SentChA;
194    SentChA+=SubjStr;
195    SentChA+=' ';
196    SentChA+=PredStr;
197    SentChA+=' ';
198    SentChA+=ObjStr;
199    if (SentChA.Len()>0){SentChA.PutCh(0, toupper(SentChA[0]));}
200    if ((SentChA.Len()>0)&&(SentChA.LastCh()!='.')){SentChA+='.';}
201    return SentChA;
202  }
203  TStr TLfSpo::GetLSent() const {
204    TChA SentChA;
205    SentChA+=LSubjStr;
206    SentChA+=' ';
207    SentChA+=PredStr;
208    SentChA+=' ';
209    SentChA+=LObjStr;
210    if (SentChA.Len()>0){
211      SentChA.PutCh(0, toupper(SentChA[0]));}
212    if (SentChA.Len()>0){
213      if ((SentChA.LastCh()==',')||(SentChA.LastCh()==';')){
214        SentChA.PutCh(SentChA.Len()-1, '.');
215      } else
216      if (SentChA.LastCh()!='.'){
217        SentChA+='.';
218      }
219    }
220    return SentChA;
221  }
222  bool TLfTree::IsSubLfTree(const TStr& SelLfTypeNm, const TStr& SelHeadTypeNm,
223   TStr& SubHeadStr, TStr& SubSentStr, PLfTree& SubLfTree) const {
224    for (int ObjLfTreeN=0; ObjLfTreeN<SubLfTreeV.Len(); ObjLfTreeN++){
225      SubLfTree=SubLfTreeV[ObjLfTreeN];
226      if ((!SelLfTypeNm.Empty())&&(SubLfTree->LfTypeNm!=SelLfTypeNm)){continue;}
227      if ((!SelHeadTypeNm.Empty())&&(SubLfTree->HeadTypeNm!=SelHeadTypeNm)){continue;}
228      SubHeadStr=SubLfTree->GetHeadOrSubstStr();
229      SubSentStr=SubLfTree->GetArSentStr();
230      return true;
231    }
232    SubHeadStr=""; SubSentStr=""; SubLfTree=NULL;
233    return false;
234  }
235  bool TLfTree::IsSubLfTree(const TStr& SelLfTypeNm, const TStr& SelHeadTypeNm,
236   TStr& SubHeadStr, TStr& SubSentStr) const {
237    PLfTree SubLfTree;
238    return IsSubLfTree(SelLfTypeNm, SelHeadTypeNm, SubHeadStr, SubSentStr, SubLfTree);
239  }
240  void TLfTree::GetLfSpoV(
241   TLfSpoV& LfSpoV, const int& MxLev,
242   const TStr& UpSubjStr, const TStr& UpLSubjStr) const {
243    if ((MxLev!=-1)&&(Lev>MxLev)){return;}
244    TStr NextUpSubjStr; TStr NextUpLSubjStr;
245    if (LfTypeNm=="Dsub"){
246      NextUpSubjStr=GetHeadOrSubstStr(); NextUpLSubjStr=GetArSentStr();
247    }
248    if (HeadTypeNm!="VERB"){
249      if (LfTypeNm=="Dobj"){&bsol;*NextUpObjStr=GetHeadOrSubstStr();*/}
250      else if (LfTypeNm=="Dind"){&bsol;*NextUpObjStr=GetHeadOrSubstStr();*/}
251    }
252    if (HeadTypeNm=="VERB"){
253      TStr PredStr=GetHeadOrSubstStr();
254      TStr SubjStr; TStr LSubjStr; PLfTree SubjLfTree;
255      if (IsSubLfTree("Dsub", "", SubjStr, LSubjStr, SubjLfTree)){
256        NextUpSubjStr=SubjStr; NextUpLSubjStr=LSubjStr;
257      }
258      TStr ObjStr; TStr LObjStr; PLfTree ObjLfTree;
259      if (IsSubLfTree("Dobj", "", ObjStr, LObjStr, ObjLfTree)){
260      } else
261      if (IsSubLfTree("Dind", "", ObjStr, LObjStr, ObjLfTree)){
262      }
263      if ((!ObjLfTree.Empty())&&(ObjLfTree->HeadTypeNm=="VERB")){
264        TStr SubSubjStr; TStr SubLSubjStr;
265        if (ObjLfTree->IsSubLfTree("Dsub", "", SubSubjStr, SubLSubjStr)){
266          ObjStr=SubSubjStr+" "+ObjStr;}
267        TStr SubObjStr; TStr SubLObjStr; PLfTree SubObjLfTree;
268        if (ObjLfTree->IsSubLfTree("Dobj", "NOUN", SubObjStr, SubLObjStr, SubObjLfTree)){
269          ObjStr=ObjStr+" "+SubObjStr; NextUpSubjStr=""; NextUpLSubjStr="";
270        } else
271        if (ObjLfTree->IsSubLfTree("Dind", "NOUN", SubObjStr, SubLObjStr, SubObjLfTree)){
272          ObjStr=ObjStr+" "+SubObjStr; NextUpSubjStr=""; NextUpLSubjStr="";
273        }
274        ObjLfTree=SubObjLfTree;
275        if (!ObjLfTree.Empty()){
276        }
277      }
278      if ((!SubjLfTree.Empty())&&(!ObjLfTree.Empty())){
279        LfSpoV.Add(TLfSpo::New(LSubjStr, SubjStr, PredStr, ObjStr, LObjStr));
280      }
281      if ((!UpSubjStr.Empty())&&(SubjLfTree.Empty())&&(!ObjLfTree.Empty())){
282        LfSpoV.Add(TLfSpo::New(UpLSubjStr, UpSubjStr, PredStr, ObjStr, LObjStr));
283      }
284    }
285    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
286      PLfTree SubLfTree=SubLfTreeV[SubLfTreeN];
287      SubLfTree->GetLfSpoV(LfSpoV, MxLev, NextUpSubjStr, NextUpLSubjStr);
288    }
289  }
290  void TLfTree::GetLfSpoV(TLfSpoV& LfSpoV, const int& MxLev) const {
291    GetLfSpoV(LfSpoV, MxLev, "", "");
292  }
293  void TLfTree::PutSubst(
294   const TLfSubstV& LfSubstV, const PLfAliasBs& LfAliasBs,
295   TStrPrV& HeadStrSubstStrPrV, const bool& DumpP){
296    TStr HeadUcStr=HeadStr.GetUc();
297    for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
298      PLfSubst LfSubst=LfSubstV[LfSubstN];
299      if ((!BitNmV.Empty())&&(!LfSubst->SelBitNmV.Empty())){
300        bool BitMatchP=true;
301        for (int SelBitN=0; SelBitN<LfSubst->SelBitNmV.Len(); SelBitN++){
302          int BitN=0;
303          while ((BitN<BitNmV.Len())&&(LfSubst->SelBitNmV[SelBitN]!=BitNmV[BitN])){BitN++;}
304          if (BitN==BitNmV.Len()){BitMatchP=false; break;}
305        }
306        if (BitMatchP){
307          if (!LfSubst->TargetStrV.IsIn(HeadUcStr)){
<span onclick='openModal()' class='match'>308            LfAliasBs->PutAliasStr(HeadStr, LfSubst->SubstId, LfSubst->SubstStr);
309            LfAliasBs->UpdateLfSubstV(LfSubst->SubstStr, LfSubstV);
</span>310            HeadSubstStr=LfSubst->SubstStr;
311            HeadStrSubstStrPrV.Add(TStrPr(HeadStr, LfSubst->SubstStr));
312            if (DumpP){
313              printf("New substitution for '%s': '%s' (from '%s')\n",
314               LfSubst->SubstId.CStr(), LfSubst->SubstStr.CStr(), HeadStr.CStr());
315            }
316          }
317        }
318      }
319      if ((!LfSubst->SubstStr.Empty())&&(LfSubst->TargetStrV.IsIn(HeadUcStr))){
320        HeadSubstStr=LfSubst->SubstStr;
321        HeadStrSubstStrPrV.Add(TStrPr(HeadStr, LfSubst->SubstStr));
322        if (DumpP){
323          printf("Substitute head: '%s' --> '%s'\n",
324           HeadStr.CStr(), LfSubst->SubstStr.CStr());
325        }
326      }
327    }
328    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
329      SubLfTreeV[SubLfTreeN]->PutSubst(
330       LfSubstV, LfAliasBs, HeadStrSubstStrPrV, DumpP);
331    }
332    ArSentStr=TLfDoc::GenArSentStr(SentStr, HeadStrSubstStrPrV, false);
333  }
334  void TLfTree::ClrSubst(){
335    HeadSubstStr="";
336    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
337      SubLfTreeV[SubLfTreeN]->ClrSubst();
338    }
339  }
340  PLfTree TLfTree::GetLfTree(const PXmlTok& TreeTok, const int& Lev){
341    if (!TreeTok.Empty()){
342      PLfTree LfTree=TLfTree::New();
343      LfTree->SentStr=TreeTok->GetArgVal("String", "");
344      LfTree->LfTypeNm=TreeTok->GetTagNm();
345      LfTree->Lev=Lev;
346      LfTree->HeadStr=TreeTok->GetArgVal("Head", "");
347      LfTree->HeadTypeNm=TreeTok->GetArgVal("HeadSegType", "");
348      PXmlTok BitsTok;
349      if (TreeTok->IsTagTok("Bits", BitsTok)){
350        int BitToks=BitsTok->GetSubToks();
351        for (int BitTokN=0; BitTokN<BitToks; BitTokN++){
352          PXmlTok BitTok=BitsTok->GetSubTok(BitTokN);
353          if (BitTok->IsTag()){
354            LfTree->BitNmV.Add(BitTok->GetTagNm());
355          }
356        }
357      }
358      int SubTrees=TreeTok->GetSubToks();
359      for (int SubTreeN=0; SubTreeN<SubTrees; SubTreeN++){
360        PXmlTok SubTreeTok=TreeTok->GetSubTok(SubTreeN);
361        PLfTree SubLfTree=GetLfTree(SubTreeTok, Lev+1);
362        if (!SubLfTree.Empty()){
363          LfTree->SubLfTreeV.Add(SubLfTree);}
364      }
365      return LfTree;
366    } else {
367      return NULL;
368    }
369  }
370  void TLfTree::Dump(){
371    if (LfTypeNm=="Bits"){return;}
372    for (int LevN=0; LevN<Lev; LevN++){printf("  ");}
373    if (HeadSubstStr.Empty()){
374      printf("%s:%s/%s\n", HeadStr.CStr(), HeadTypeNm.CStr(), LfTypeNm.CStr());
375    } else {
376      printf("%s[%s]:%s/%s\n",
377       HeadStr.CStr(), HeadSubstStr.CStr(), HeadTypeNm.CStr(), LfTypeNm.CStr());
378    }
379    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
380      SubLfTreeV[SubLfTreeN]->Dump();
381    }
382  }
383  TStr TLfDoc::GenArSentStr(
384   const TStr& SentStr, const TStrPrV& HeadStrSubstStrPrV, const bool& PhraseP){
385    if (HeadStrSubstStrPrV.Empty()){return SentStr;}
386    TStr ArSentStr=SentStr;
387    TStrV UsedSubstStrV;
388    int SentSearchChN=0;
389    for (int HSPrN=0; HSPrN<HeadStrSubstStrPrV.Len(); HSPrN++){
390      TStr HeadStr=HeadStrSubstStrPrV[HSPrN].Val1;
391      TStr SubstStr=HeadStrSubstStrPrV[HSPrN].Val2;
392      if (HeadStr==SubstStr){continue;}
393      if (PhraseP){
394        SubstStr.ChangeChAll(' ', '_');
395        SubstStr.ChangeChAll('.', '_');
396        SubstStr.ChangeChAll(',', '_');
397      }
398      int PrevSentSearchChN=SentSearchChN;
399      forever{
400        SentSearchChN=ArSentStr.SearchStr(HeadStr, SentSearchChN);
401        if (SentSearchChN==-1){break;}
402        char PrevCh=TCh::NullCh;
403        char NextCh=TCh::NullCh;
404        if (SentSearchChN>0){PrevCh=ArSentStr[SentSearchChN-1];}
405        if (SentSearchChN+HeadStr.Len()<ArSentStr.Len()){
406          NextCh=ArSentStr[SentSearchChN+HeadStr.Len()];}
407        if ((!TCh::IsAlpha(PrevCh))&&(!TCh::IsAlpha(NextCh))){break;}
408        else {SentSearchChN++;}
409      }
410      if (SentSearchChN==-1){
411        SentSearchChN=PrevSentSearchChN;
412      } else {
413        if (!UsedSubstStrV.IsIn(SubstStr)){
414          ArSentStr.ChangeStr(HeadStr, SubstStr, SentSearchChN);
415          SentSearchChN+=SubstStr.Len();
416          UsedSubstStrV.Add(SubstStr);
417        }
418      }
419    }
420    {for (int HSPrN=0; HSPrN<HeadStrSubstStrPrV.Len(); HSPrN++){
421      TStr HeadStr=HeadStrSubstStrPrV[HSPrN].Val1;
422      TStr SubstStr=HeadStrSubstStrPrV[HSPrN].Val2;
423      if (HeadStr!=SubstStr){continue;}
424      if (!HeadStr.IsChIn(' ')){continue;}
425      if (PhraseP){
426        SubstStr.ChangeChAll(' ', '_');
427        SubstStr.ChangeChAll('.', '_');
428        SubstStr.ChangeChAll(',', '_');
429      }
430      int SentSearchChN=0;
431      forever{
432        SentSearchChN=ArSentStr.SearchStr(HeadStr, SentSearchChN);
433        if (SentSearchChN==-1){break;}
434        char PrevCh=TCh::NullCh;
435        char NextCh=TCh::NullCh;
436        if (SentSearchChN>0){PrevCh=ArSentStr[SentSearchChN-1];}
437        if (SentSearchChN+HeadStr.Len()<ArSentStr.Len()){
438          NextCh=ArSentStr[SentSearchChN+HeadStr.Len()];}
439        if ((!TCh::IsAlpha(PrevCh))&&(!TCh::IsAlpha(NextCh))){break;}
440        else {SentSearchChN++;}
441      }
442      if (SentSearchChN!=-1){
443        if (!UsedSubstStrV.IsIn(SubstStr)){
444          ArSentStr.ChangeStr(HeadStr, SubstStr, SentSearchChN);
445          UsedSubstStrV.Add(SubstStr);
446        }
447      }
448    }}
449    return ArSentStr;
450  }
451  void TLfDoc::GenHeadsSubst(const PLfAliasBs& CtxLfAliasBs, const bool& DumpP){
452    TLfSubstV LfSubstV; TLfSubst::GetLfSubstV(LfSubstV);
453    PLfAliasBs LfAliasBs=CtxLfAliasBs;
454    if (LfAliasBs.Empty()){
455      LfAliasBs=TLfAliasBs::New();}
456    int Sents=GetSents();
457    for (int SentN=0; SentN<Sents; SentN++){
458      TStr SentStr=GetSentStr(SentN);
459      if (DumpP){
460        printf("=================================\n");
461        printf("Sentence %d: %s\n", SentN, SentStr.CStr());
462        printf("-----------------\n");
463      }
464      PLfTree SentLfTree=GetSentLfTree(SentN);
465      TStrPrV HeadStrSubstStrPrV;
466      SentLfTree->PutSubst(LfSubstV, LfAliasBs, HeadStrSubstStrPrV, DumpP);
467      TStr ArSentStr=GenArSentStr(SentStr, HeadStrSubstStrPrV, true);
468      SentStrArSentStrPrV[SentN].Val2=ArSentStr;
469      if (DumpP){
470        printf("-----------------\n");
471        printf("ArSentence %d: %s\n", SentN, ArSentStr.CStr());
472      }
473      TLfSubst::Dump(DumpP, LfSubstV);
474      LfAliasBs->Dump(DumpP);
475    }
476  }
477  void TLfDoc::ClrHeadsSubst(){
478    int Sents=GetSents();
479    for (int SentN=0; SentN<Sents; SentN++){
480      PLfTree SentLfTree=GetSentLfTree(SentN);
481      SentLfTree->ClrSubst();
482    }
483  }
484  void TLfDoc::Dump(const int& DumpSentN) const {
485    printf("=========================\n");
486    printf("Document: '%s'\n", DocId.CStr());
487    for (int SentN=0; SentN<GetSents(); SentN++){
488      if ((SentN!=-1)&&(SentN!=DumpSentN)){continue;}
489      printf("-------------------------\n");
490      printf("Sentence[%d]: %s\n", SentN, GetSentStr(SentN).CStr());
491      printf("ArSenten[%d]: %s\n", SentN, GetArSentStr(SentN).CStr());
492      printf("-------------------------\n");
493      GetSentLfTree(SentN)->Dump();
494    }
495    printf("=========================\n");
496  }
497  PLfDoc TLfDocBs::GetLfDoc(const TStr& DocId) const {
498    int LfDocs=GetLfDocs();
499    for (int LfDocN=0; LfDocN<LfDocs; LfDocN++){
500      if (GetLfDoc(LfDocN)->DocId==DocId){
501        return GetLfDoc(LfDocN);
502      }
503    }
504    return NULL;
505  }
506  void TLfDocBs::GenHeadsSubst(const bool& DumpP){
507    int LfDocs=GetLfDocs();
508    for (int LfDocN=0; LfDocN<LfDocs; LfDocN++){
509      GetLfDoc(LfDocN)->GenHeadsSubst(NULL, DumpP);
510    }
511  }
512  void TLfDocBs::GenHeadsSubst(const TStrV& DocIdV, const bool& DumpP){
513    TLfAliasBsV LfAliasBsV;
514    for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
515      TStr DocId=DocIdV[DocIdN]; PLfDoc LfDoc;
516      if (IsLfDoc(DocId, LfDoc)){
517        PLfAliasBs LfAliasBs=TLfAliasBs::New();
518        LfDoc->GenHeadsSubst(LfAliasBs, false);
519        LfAliasBsV.Add(LfAliasBs);
520      }
521    }
522    PLfAliasBs TopLfAliasBs=TLfAliasBs::New();
523    for (int LfAliasBsN=0; LfAliasBsN<LfAliasBsV.Len(); LfAliasBsN++){
524      TopLfAliasBs->MergeAliasBs(LfAliasBsV[LfAliasBsN]);
525    }
526    TopLfAliasBs->Dump(DumpP);
527    for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
528      TStr DocId=DocIdV[DocIdN]; PLfDoc LfDoc;
529      if (IsLfDoc(DocId, LfDoc)){
530        LfDoc->ClrHeadsSubst();
531        PLfAliasBs LfAliasBs=TLfAliasBs::New(TopLfAliasBs);
532        LfDoc->GenHeadsSubst(LfAliasBs, false);
533      }
534    }
535  }
536  void TLfDocBs::GetCompClV(const PXmlTok& XmlTok, TStrV& CompClStrV) const {
537    if (XmlTok->IsTag("NP")&&XmlTok->IsArg("name")){
538      if (XmlTok->GetArgVal("name").IsPrefix("COMPCL")){
539        TStr CompClStr=XmlTok->GetArgVal("String");
540        CompClStrV.AddMerged(CompClStr);
541        return;
542      }
543    }
544    int SubToks=XmlTok->GetSubToks();
545    for (int SubTokN=0; SubTokN<SubToks; SubTokN++){
546      GetCompClV(XmlTok->GetSubTok(SubTokN), CompClStrV);
547    }
548  }
549  PLfDocBs TLfDocBs::LoadXml(const TStr& FNm, const bool& DumpP){
550    PLfDocBs LfDocBs=TLfDocBs::New();
551    PSIn XmlSIn=TFIn::New(FNm);
552    TXmlDoc::SkipTopTag(XmlSIn);
553    PXmlDoc XmlDoc; int XmlDocs=0;
554    forever{
555      XmlDocs++; printf("%d\r", XmlDocs);
556      XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
557      if (!XmlDoc->IsOk()){break;}
558      PXmlTok DocTok=XmlDoc->GetTok();
559      IAssert(DocTok->IsTag("DOCUMENT"));
560      TStr DocId=DocTok->GetArgVal("NO");
561      printf("%s: ", DocId.CStr());
562      PLfDoc LfDoc=TLfDoc::New(DocId);
563      LfDocBs->AddLfDoc(LfDoc);
564      int SentToks=DocTok->GetSubToks();
565      for (int SentTokN=0; SentTokN<SentToks; SentTokN++){
566        PXmlTok SentTok=DocTok->GetSubTok(SentTokN);
567        if (!SentTok->IsTag("SENTENCE")){continue;}
568        TStr SentId=SentTok->GetArgVal("ID");
569        printf("[%d]", SentId.GetInt());
570        PXmlTok LfTok=SentTok->GetTagTok("NLP|LogicalForm");
571        TStr SentStr; PLfTree SentLfTree;
572        if (!LfTok.Empty()){
573          SentStr=LfTok->GetArgVal("String");
574          PXmlTok SentTreeTok=SentTok->GetTagTok("NLP|LogicalForm|Sentence");
575          SentLfTree=TLfTree::GetLfTree(SentTreeTok);
576          if (SentLfTree.Empty()){SentLfTree=TLfTree::New();}
577        } else {
578          SentLfTree=TLfTree::New();
579        }
580        LfDoc->AddSent(SentStr, SentLfTree);
581        IAssert(SentId.GetInt()==LfDoc->GetSents()-1);
582      }
583      printf("\n");
584      if (DumpP){LfDoc->Dump();}
585    }
586    return LfDocBs;
587  }
588  PLfDocBs TLfDocBs::LoadBinSet(const TStr& FPath, const TStr& FExt){
589    printf("Loading Logical-Form-Binary-Set...\n");
590    PLfDocBs LfDocBs=TLfDocBs::New();
591    TFFile FFile(FPath, FExt, true); TStr FNm;
592    while (FFile.Next(FNm)){
593      printf("%s\n", FNm.CStr());
594      PLfDocBs LocLfDocBs=TLfDocBs::LoadBin(FNm);
595      LfDocBs->AddLfDocBs(LocLfDocBs);
596    }
597    printf("Done.\n");
598    return LfDocBs;
599  }
600  void TLfDocBs::ConvXmlToLdb(const TStr& FNm, const bool& DumpP){
601    printf("%s\n", FNm.CStr());
602    PLfDocBs LfDocBs=TLfDocBs::LoadXml(FNm, DumpP);
603    LfDocBs->SaveBin(TStr::PutFExt(FNm, ".Ldb"));
604  }
605  void TLfDocBs::ConvSetXmlToLdb(const TStr& FPath, const bool& DumpP){
606    TFFile FFile(FPath, ".xml", false); TStr FNm;
607    while (FFile.Next(FNm)){
608      ConvXmlToLdb(FNm, DumpP);
609    }
610  }
611  void TLfDocBs::Dump() const {
612    for (int LfDocN=0; LfDocN<GetLfDocs(); LfDocN++){
613      GetLfDoc(LfDocN)->Dump();
614    }
615  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nlpwinlf.cpp</h3>
            <pre><code>1  #include "nlpwinlf.h"
2  void TLfSubst::GetLfSubstV(TLfSubstV& LfSubstV){
3    LfSubstV.Clr();
4    { 
5    PLfSubst LfSubst=TLfSubst::New("He"); LfSubstV.Add(LfSubst);
6    LfSubst->AddTarget("he"); LfSubst->AddTarget("him");
7    LfSubst->AddTarget("his"); LfSubst->AddTarget("himself");
8    LfSubst->AddSelBit("Masc");
9    LfSubst->AddSelBit("Sing");
10    LfSubst->AddSelBit("Humn");
11    }
12    { 
13    PLfSubst LfSubst=TLfSubst::New("She"); LfSubstV.Add(LfSubst);
14    LfSubst->AddTarget("she"); LfSubst->AddTarget("her");
15    LfSubst->AddTarget("hers"); LfSubst->AddTarget("herself");
16    LfSubst->AddSelBit("Fem");
17    LfSubst->AddSelBit("Sing");
18    LfSubst->AddSelBit("Humn");
19    }
20    { 
21    PLfSubst LfSubst=TLfSubst::New("Name"); LfSubstV.Add(LfSubst);
22    LfSubst->AddSelBit("Sing");
23    LfSubst->AddSelBit("PrprN");
24    }
25    { 
26    PLfSubst LfSubst=TLfSubst::New("They"); LfSubstV.Add(LfSubst);
27    LfSubst->AddTarget("they"); LfSubst->AddTarget("their");
28    LfSubst->AddSelBit("Plur");
29    LfSubst->AddSelBit("Humn");
30    }
31  }
32  void TLfSubst::Dump(const bool& DumpP, const TLfSubstV& LfSubstV){
33    if (!DumpP){return;}
34    printf("---Start-----Substitutions-------\n");
35    for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
36      PLfSubst LfSubst=LfSubstV[LfSubstN];
37      printf("%s : %s\n", LfSubst->SubstId.CStr(), LfSubst->SubstStr.CStr());
38    }
39    printf("---End-------Substitutions-------\n");
40  }
41  bool TLfAliasBs::IsGenericWord(const TStr& WordStr) const {
42    if (WordStr.IsChIn('.')){return true;}
43    if (SwSet->IsIn(WordStr)){return true;}
44    if (WordStr=="PRESIDENT"){return true;}
45    if (WordStr=="JUSTICE"){return true;}
46    if (WordStr=="JUDGE"){return true;}
47    if (WordStr=="NIGHT"){return true;}
48    if (WordStr=="U.S."){return true;}
49    if (WordStr=="SOUTH"){return true;}
50    if (WordStr=="NORTH"){return true;}
51    if (WordStr=="WEST"){return true;}
52    if (WordStr=="EAST"){return true;}
53    return false;
54  }
55  void TLfAliasBs::PutAliasStr(const TStr& SrcStr, const TStr& SubstId, TStr& DstStr){
56    TStr SrcUcStr=SrcStr.GetUc();
57    TStrV SrcUcStrV; SrcUcStr.SplitOnWs(SrcUcStrV);
58    for (int SrcUcStrN=0; SrcUcStrN<SrcUcStrV.Len(); SrcUcStrN++){
59      if (IsGenericWord(SrcUcStrV[SrcUcStrN])){
60        SrcUcStrV[SrcUcStrN]="";}
61    }
62    SrcUcStrV.DelAll("");
63    SrcUcStrV.Sort();
64    if (WordStrVToAliasStrH.IsKey(SrcUcStrV)){
65      DstStr=WordStrVToAliasStrH.GetDat(SrcUcStrV);
66      WordStrVToAliasH.GetDat(SrcUcStrV).IncFq();
67    } else {
68      for (int WAStrP=0; WAStrP<WordStrVToAliasStrH.Len(); WAStrP++){
69        TStrV& WordUcStrV=WordStrVToAliasStrH.GetKey(WAStrP);
70        TStr AliasStr=WordStrVToAliasStrH[WAStrP];
71        TStrV IntrsWordStrV; WordUcStrV.Intrs(SrcUcStrV, IntrsWordStrV);
72        if (IntrsWordStrV.Len()>0){
73          AddAlias(SrcUcStrV, SubstId, AliasStr);
74          DstStr=AliasStr;
75          return;
76        }
77      }
78      AddAlias(SrcUcStrV, SubstId, SrcStr);
79      DstStr=SrcStr;
80    }
81  }
82  void TLfAliasBs::UpdateLfSubstV(const TStr& AliasStr, const TLfSubstV& LfSubstV) const {
83    for (int WToAN=0; WToAN<WordStrVToAliasStrH.Len(); WToAN++){
84      if (WordStrVToAliasStrH[WToAN]==AliasStr){
85        TStrV& WordStrV=WordStrVToAliasStrH.GetKey(WToAN);
86        TStr SubstId=WordStrVToAliasH.GetDat(WordStrV).GetSubstId();
87        for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
88          if (LfSubstV[LfSubstN]->SubstId==SubstId){
89            LfSubstV[LfSubstN]->SubstStr=AliasStr;
90          }
91        }
92      }
93    }
94  }
95  void TLfAliasBs::AddAlias(
96   const TStrV& WordStrV, const TStr& SubstId, const TStr& AliasStr){
97    WordStrVToAliasStrH.AddDat(WordStrV, AliasStr);
98    IAssert(!WordStrVToAliasH.IsKey(WordStrV));
99    TLfAlias LfAlias(SubstId);
100    LfAlias.IncFq();
101    WordStrVToAliasH.AddDat(WordStrV, LfAlias);
102  }
103  void TLfAliasBs::MergeAliasBs(const PLfAliasBs& LfAliasBs){
104    int MnAliasFq=2;
105    int MnIntrsLen=2;
106    for (int NewWordStrVN=0; NewWordStrVN<LfAliasBs->WordStrVToAliasH.Len(); NewWordStrVN++){
107      TStrV& NewWordStrV=LfAliasBs->WordStrVToAliasH.GetKey(NewWordStrVN);
108      TStr NewAliasStr=LfAliasBs->WordStrVToAliasStrH.GetDat(NewWordStrV);
109      int NewAliasFq=LfAliasBs->WordStrVToAliasH[NewWordStrVN].GetFq();
110      if (NewAliasFq>=MnAliasFq){
111        if (WordStrVToAliasH.IsKey(NewWordStrV)){
112          WordStrVToAliasH.GetDat(NewWordStrV).IncFq(NewAliasFq);
113        } else {
114          TIntKdV IntrsLen_OldWordStrVNV;
115          for (int OldWordStrVN=0; OldWordStrVN<WordStrVToAliasH.Len(); OldWordStrVN++){
116            TStrV& OldWordStrV=WordStrVToAliasH.GetKey(OldWordStrVN);
117            TStr OldAliasStr=WordStrVToAliasStrH.GetDat(OldWordStrV);
118            TStrV IntrsWordStrV; NewWordStrV.Intrs(OldWordStrV, IntrsWordStrV);
119            if (IntrsWordStrV.Len()>0){
120              IntrsLen_OldWordStrVNV.Add(TIntKd(IntrsWordStrV.Len(), OldWordStrVN));
121            }
122          }
123          IntrsLen_OldWordStrVNV.Sort(false);
124          if (IntrsLen_OldWordStrVNV.Len()==0){
125            TLfAlias NewLfAlias(LfAliasBs->WordStrVToAliasH[NewWordStrVN]);
126            WordStrVToAliasH.AddDat(NewWordStrV, NewLfAlias);
127            WordStrVToAliasStrH.AddDat(NewWordStrV, NewAliasStr);
128          } else
129          if (IntrsLen_OldWordStrVNV.Len()>=MnIntrsLen){
130            int OldWordStrVN=IntrsLen_OldWordStrVNV[0].Dat;
131            TStrV& OldWordStrV=WordStrVToAliasH.GetKey(OldWordStrVN);
132            TStr OldAliasStr=WordStrVToAliasStrH.GetDat(OldWordStrV);
133            TLfAlias NewLfAlias(LfAliasBs->WordStrVToAliasH[NewWordStrVN]);
134            WordStrVToAliasH.AddDat(NewWordStrV, NewLfAlias);
135            WordStrVToAliasStrH.AddDat(NewWordStrV, OldAliasStr);
136          }
137        }
138      }
139    }
140  }
141  void TLfAliasBs::Dump(const bool& DumpP, const int& MnAliasFq) const {
142    if (!DumpP){return;}
143    printf("Alias-Base\n");
144    TStrStrVPrV AliasStrWordStrVV;
145    WordStrVToAliasStrH.GetDatKeyPrV(AliasStrWordStrVV);
146    AliasStrWordStrVV.Sort();
147    for (int AliasN=0; AliasN<AliasStrWordStrVV.Len(); AliasN++){
148      TStr AliasStr=AliasStrWordStrVV[AliasN].Val1;
149      TStrV& WordStrV=AliasStrWordStrVV[AliasN].Val2;
150      TStr SubstId=WordStrVToAliasH.GetDat(WordStrV).GetSubstId();
151      int Fq=WordStrVToAliasH.GetDat(WordStrV).GetFq();
152      if ((MnAliasFq==-1)||(Fq>=MnAliasFq)){
153        printf("%s :", AliasStr.CStr());
154        for (int WordN=0; WordN<WordStrV.Len(); WordN++){
155          printf(" %s", WordStrV[WordN].CStr());}
156        printf(" [%s/%d]\n", SubstId.CStr(), Fq);
157      }
158    }
159    printf("======================\n");
160  }
161  TStrH TLfSpo::UnusableWordStrH;
162  bool TLfSpo::IsUsable() const {
163    if (UnusableWordStrH.Empty()){
164      UnusableWordStrH.AddKey(";");
165      UnusableWordStrH.AddKey(",");
166      UnusableWordStrH.AddKey("_");
167      UnusableWordStrH.AddKey("BEEN");
168      UnusableWordStrH.AddKey("ARE");
169      UnusableWordStrH.AddKey("AREN'T");
170      UnusableWordStrH.AddKey("IS");
171      UnusableWordStrH.AddKey("DID");
172      UnusableWordStrH.AddKey("WAS");
173      UnusableWordStrH.AddKey("WERE");
174      UnusableWordStrH.AddKey("IT");
175      UnusableWordStrH.AddKey("WE");
176      UnusableWordStrH.AddKey("I");
177      UnusableWordStrH.AddKey("YOU");
178      UnusableWordStrH.AddKey("AND");
179      UnusableWordStrH.AddKey("OR");
180      UnusableWordStrH.AddKey("HE");
181      UnusableWordStrH.AddKey("SHE");
182      UnusableWordStrH.AddKey("THIS");
183    }
184    TStr UcSubjStr=SubjStr.GetUc();
185    TStr UcObjStr=ObjStr.GetUc();
186    if ((UnusableWordStrH.IsKey(UcSubjStr))||(UnusableWordStrH.IsKey(UcObjStr))){
187      return false;
188    } else {
189      return true;
190    }
191  }
192  TStr TLfSpo::GetSent() const {
193    TChA SentChA;
194    SentChA+=SubjStr;
195    SentChA+=' ';
196    SentChA+=PredStr;
197    SentChA+=' ';
198    SentChA+=ObjStr;
199    if (SentChA.Len()>0){SentChA.PutCh(0, toupper(SentChA[0]));}
200    if ((SentChA.Len()>0)&&(SentChA.LastCh()!='.')){SentChA+='.';}
201    return SentChA;
202  }
203  TStr TLfSpo::GetLSent() const {
204    TChA SentChA;
205    SentChA+=LSubjStr;
206    SentChA+=' ';
207    SentChA+=PredStr;
208    SentChA+=' ';
209    SentChA+=LObjStr;
210    if (SentChA.Len()>0){
211      SentChA.PutCh(0, toupper(SentChA[0]));}
212    if (SentChA.Len()>0){
213      if ((SentChA.LastCh()==',')||(SentChA.LastCh()==';')){
214        SentChA.PutCh(SentChA.Len()-1, '.');
215      } else
216      if (SentChA.LastCh()!='.'){
217        SentChA+='.';
218      }
219    }
220    return SentChA;
221  }
222  bool TLfTree::IsSubLfTree(const TStr& SelLfTypeNm, const TStr& SelHeadTypeNm,
223   TStr& SubHeadStr, TStr& SubSentStr, PLfTree& SubLfTree) const {
224    for (int ObjLfTreeN=0; ObjLfTreeN<SubLfTreeV.Len(); ObjLfTreeN++){
225      SubLfTree=SubLfTreeV[ObjLfTreeN];
226      if ((!SelLfTypeNm.Empty())&&(SubLfTree->LfTypeNm!=SelLfTypeNm)){continue;}
227      if ((!SelHeadTypeNm.Empty())&&(SubLfTree->HeadTypeNm!=SelHeadTypeNm)){continue;}
228      SubHeadStr=SubLfTree->GetHeadOrSubstStr();
229      SubSentStr=SubLfTree->GetArSentStr();
230      return true;
231    }
232    SubHeadStr=""; SubSentStr=""; SubLfTree=NULL;
233    return false;
234  }
235  bool TLfTree::IsSubLfTree(const TStr& SelLfTypeNm, const TStr& SelHeadTypeNm,
236   TStr& SubHeadStr, TStr& SubSentStr) const {
237    PLfTree SubLfTree;
238    return IsSubLfTree(SelLfTypeNm, SelHeadTypeNm, SubHeadStr, SubSentStr, SubLfTree);
239  }
240  void TLfTree::GetLfSpoV(
241   TLfSpoV& LfSpoV, const int& MxLev,
242   const TStr& UpSubjStr, const TStr& UpLSubjStr) const {
243    if ((MxLev!=-1)&&(Lev>MxLev)){return;}
244    TStr NextUpSubjStr; TStr NextUpLSubjStr;
245    if (LfTypeNm=="Dsub"){
246      NextUpSubjStr=GetHeadOrSubstStr(); NextUpLSubjStr=GetArSentStr();
247    }
248    if (HeadTypeNm!="VERB"){
249      if (LfTypeNm=="Dobj"){&bsol;*NextUpObjStr=GetHeadOrSubstStr();*/}
250      else if (LfTypeNm=="Dind"){&bsol;*NextUpObjStr=GetHeadOrSubstStr();*/}
251    }
252    if (HeadTypeNm=="VERB"){
253      TStr PredStr=GetHeadOrSubstStr();
254      TStr SubjStr; TStr LSubjStr; PLfTree SubjLfTree;
255      if (IsSubLfTree("Dsub", "", SubjStr, LSubjStr, SubjLfTree)){
256        NextUpSubjStr=SubjStr; NextUpLSubjStr=LSubjStr;
257      }
258      TStr ObjStr; TStr LObjStr; PLfTree ObjLfTree;
259      if (IsSubLfTree("Dobj", "", ObjStr, LObjStr, ObjLfTree)){
260      } else
261      if (IsSubLfTree("Dind", "", ObjStr, LObjStr, ObjLfTree)){
262      }
263      if ((!ObjLfTree.Empty())&&(ObjLfTree->HeadTypeNm=="VERB")){
264        TStr SubSubjStr; TStr SubLSubjStr;
265        if (ObjLfTree->IsSubLfTree("Dsub", "", SubSubjStr, SubLSubjStr)){
266          ObjStr=SubSubjStr+" "+ObjStr;}
267        TStr SubObjStr; TStr SubLObjStr; PLfTree SubObjLfTree;
268        if (ObjLfTree->IsSubLfTree("Dobj", "NOUN", SubObjStr, SubLObjStr, SubObjLfTree)){
269          ObjStr=ObjStr+" "+SubObjStr; NextUpSubjStr=""; NextUpLSubjStr="";
270        } else
271        if (ObjLfTree->IsSubLfTree("Dind", "NOUN", SubObjStr, SubLObjStr, SubObjLfTree)){
272          ObjStr=ObjStr+" "+SubObjStr; NextUpSubjStr=""; NextUpLSubjStr="";
273        }
274        ObjLfTree=SubObjLfTree;
275        if (!ObjLfTree.Empty()){
276        }
277      }
278      if ((!SubjLfTree.Empty())&&(!ObjLfTree.Empty())){
279        LfSpoV.Add(TLfSpo::New(LSubjStr, SubjStr, PredStr, ObjStr, LObjStr));
280      }
281      if ((!UpSubjStr.Empty())&&(SubjLfTree.Empty())&&(!ObjLfTree.Empty())){
282        LfSpoV.Add(TLfSpo::New(UpLSubjStr, UpSubjStr, PredStr, ObjStr, LObjStr));
283      }
284    }
285    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
286      PLfTree SubLfTree=SubLfTreeV[SubLfTreeN];
287      SubLfTree->GetLfSpoV(LfSpoV, MxLev, NextUpSubjStr, NextUpLSubjStr);
288    }
289  }
290  void TLfTree::GetLfSpoV(TLfSpoV& LfSpoV, const int& MxLev) const {
291    GetLfSpoV(LfSpoV, MxLev, "", "");
292  }
293  void TLfTree::PutSubst(
294   const TLfSubstV& LfSubstV, const PLfAliasBs& LfAliasBs,
295   TStrPrV& HeadStrSubstStrPrV, const bool& DumpP){
296    TStr HeadUcStr=HeadStr.GetUc();
297    for (int LfSubstN=0; LfSubstN<LfSubstV.Len(); LfSubstN++){
298      PLfSubst LfSubst=LfSubstV[LfSubstN];
299      if ((!BitNmV.Empty())&&(!LfSubst->SelBitNmV.Empty())){
300        bool BitMatchP=true;
301        for (int SelBitN=0; SelBitN<LfSubst->SelBitNmV.Len(); SelBitN++){
302          int BitN=0;
303          while ((BitN<BitNmV.Len())&&(LfSubst->SelBitNmV[SelBitN]!=BitNmV[BitN])){BitN++;}
304          if (BitN==BitNmV.Len()){BitMatchP=false; break;}
305        }
306        if (BitMatchP){
307          if (!LfSubst->TargetStrV.IsIn(HeadUcStr)){
<span onclick='openModal()' class='match'>308            LfAliasBs->PutAliasStr(HeadStr, LfSubst->SubstId, LfSubst->SubstStr);
309            LfAliasBs->UpdateLfSubstV(LfSubst->SubstStr, LfSubstV);
</span>310            HeadSubstStr=LfSubst->SubstStr;
311            HeadStrSubstStrPrV.Add(TStrPr(HeadStr, LfSubst->SubstStr));
312            if (DumpP){
313              printf("New substitution for '%s': '%s' (from '%s')\n",
314               LfSubst->SubstId.CStr(), LfSubst->SubstStr.CStr(), HeadStr.CStr());
315            }
316          }
317        }
318      }
319      if ((!LfSubst->SubstStr.Empty())&&(LfSubst->TargetStrV.IsIn(HeadUcStr))){
320        HeadSubstStr=LfSubst->SubstStr;
321        HeadStrSubstStrPrV.Add(TStrPr(HeadStr, LfSubst->SubstStr));
322        if (DumpP){
323          printf("Substitute head: '%s' --> '%s'\n",
324           HeadStr.CStr(), LfSubst->SubstStr.CStr());
325        }
326      }
327    }
328    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
329      SubLfTreeV[SubLfTreeN]->PutSubst(
330       LfSubstV, LfAliasBs, HeadStrSubstStrPrV, DumpP);
331    }
332    ArSentStr=TLfDoc::GenArSentStr(SentStr, HeadStrSubstStrPrV, false);
333  }
334  void TLfTree::ClrSubst(){
335    HeadSubstStr="";
336    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
337      SubLfTreeV[SubLfTreeN]->ClrSubst();
338    }
339  }
340  PLfTree TLfTree::GetLfTree(const PXmlTok& TreeTok, const int& Lev){
341    if (!TreeTok.Empty()){
342      PLfTree LfTree=TLfTree::New();
343      LfTree->SentStr=TreeTok->GetArgVal("String", "");
344      LfTree->LfTypeNm=TreeTok->GetTagNm();
345      LfTree->Lev=Lev;
346      LfTree->HeadStr=TreeTok->GetArgVal("Head", "");
347      LfTree->HeadTypeNm=TreeTok->GetArgVal("HeadSegType", "");
348      PXmlTok BitsTok;
349      if (TreeTok->IsTagTok("Bits", BitsTok)){
350        int BitToks=BitsTok->GetSubToks();
351        for (int BitTokN=0; BitTokN<BitToks; BitTokN++){
352          PXmlTok BitTok=BitsTok->GetSubTok(BitTokN);
353          if (BitTok->IsTag()){
354            LfTree->BitNmV.Add(BitTok->GetTagNm());
355          }
356        }
357      }
358      int SubTrees=TreeTok->GetSubToks();
359      for (int SubTreeN=0; SubTreeN<SubTrees; SubTreeN++){
360        PXmlTok SubTreeTok=TreeTok->GetSubTok(SubTreeN);
361        PLfTree SubLfTree=GetLfTree(SubTreeTok, Lev+1);
362        if (!SubLfTree.Empty()){
363          LfTree->SubLfTreeV.Add(SubLfTree);}
364      }
365      return LfTree;
366    } else {
367      return NULL;
368    }
369  }
370  void TLfTree::Dump(){
371    if (LfTypeNm=="Bits"){return;}
372    for (int LevN=0; LevN<Lev; LevN++){printf("  ");}
373    if (HeadSubstStr.Empty()){
374      printf("%s:%s/%s\n", HeadStr.CStr(), HeadTypeNm.CStr(), LfTypeNm.CStr());
375    } else {
376      printf("%s[%s]:%s/%s\n",
377       HeadStr.CStr(), HeadSubstStr.CStr(), HeadTypeNm.CStr(), LfTypeNm.CStr());
378    }
379    for (int SubLfTreeN=0; SubLfTreeN<SubLfTreeV.Len(); SubLfTreeN++){
380      SubLfTreeV[SubLfTreeN]->Dump();
381    }
382  }
383  TStr TLfDoc::GenArSentStr(
384   const TStr& SentStr, const TStrPrV& HeadStrSubstStrPrV, const bool& PhraseP){
385    if (HeadStrSubstStrPrV.Empty()){return SentStr;}
386    TStr ArSentStr=SentStr;
387    TStrV UsedSubstStrV;
388    int SentSearchChN=0;
389    for (int HSPrN=0; HSPrN<HeadStrSubstStrPrV.Len(); HSPrN++){
390      TStr HeadStr=HeadStrSubstStrPrV[HSPrN].Val1;
391      TStr SubstStr=HeadStrSubstStrPrV[HSPrN].Val2;
392      if (HeadStr==SubstStr){continue;}
393      if (PhraseP){
394        SubstStr.ChangeChAll(' ', '_');
395        SubstStr.ChangeChAll('.', '_');
396        SubstStr.ChangeChAll(',', '_');
397      }
398      int PrevSentSearchChN=SentSearchChN;
399      forever{
400        SentSearchChN=ArSentStr.SearchStr(HeadStr, SentSearchChN);
401        if (SentSearchChN==-1){break;}
402        char PrevCh=TCh::NullCh;
403        char NextCh=TCh::NullCh;
404        if (SentSearchChN>0){PrevCh=ArSentStr[SentSearchChN-1];}
405        if (SentSearchChN+HeadStr.Len()<ArSentStr.Len()){
406          NextCh=ArSentStr[SentSearchChN+HeadStr.Len()];}
407        if ((!TCh::IsAlpha(PrevCh))&&(!TCh::IsAlpha(NextCh))){break;}
408        else {SentSearchChN++;}
409      }
410      if (SentSearchChN==-1){
411        SentSearchChN=PrevSentSearchChN;
412      } else {
413        if (!UsedSubstStrV.IsIn(SubstStr)){
414          ArSentStr.ChangeStr(HeadStr, SubstStr, SentSearchChN);
415          SentSearchChN+=SubstStr.Len();
416          UsedSubstStrV.Add(SubstStr);
417        }
418      }
419    }
420    {for (int HSPrN=0; HSPrN<HeadStrSubstStrPrV.Len(); HSPrN++){
421      TStr HeadStr=HeadStrSubstStrPrV[HSPrN].Val1;
422      TStr SubstStr=HeadStrSubstStrPrV[HSPrN].Val2;
423      if (HeadStr!=SubstStr){continue;}
424      if (!HeadStr.IsChIn(' ')){continue;}
425      if (PhraseP){
426        SubstStr.ChangeChAll(' ', '_');
427        SubstStr.ChangeChAll('.', '_');
428        SubstStr.ChangeChAll(',', '_');
429      }
430      int SentSearchChN=0;
431      forever{
432        SentSearchChN=ArSentStr.SearchStr(HeadStr, SentSearchChN);
433        if (SentSearchChN==-1){break;}
434        char PrevCh=TCh::NullCh;
435        char NextCh=TCh::NullCh;
436        if (SentSearchChN>0){PrevCh=ArSentStr[SentSearchChN-1];}
437        if (SentSearchChN+HeadStr.Len()<ArSentStr.Len()){
438          NextCh=ArSentStr[SentSearchChN+HeadStr.Len()];}
439        if ((!TCh::IsAlpha(PrevCh))&&(!TCh::IsAlpha(NextCh))){break;}
440        else {SentSearchChN++;}
441      }
442      if (SentSearchChN!=-1){
443        if (!UsedSubstStrV.IsIn(SubstStr)){
444          ArSentStr.ChangeStr(HeadStr, SubstStr, SentSearchChN);
445          UsedSubstStrV.Add(SubstStr);
446        }
447      }
448    }}
449    return ArSentStr;
450  }
451  void TLfDoc::GenHeadsSubst(const PLfAliasBs& CtxLfAliasBs, const bool& DumpP){
452    TLfSubstV LfSubstV; TLfSubst::GetLfSubstV(LfSubstV);
453    PLfAliasBs LfAliasBs=CtxLfAliasBs;
454    if (LfAliasBs.Empty()){
455      LfAliasBs=TLfAliasBs::New();}
456    int Sents=GetSents();
457    for (int SentN=0; SentN<Sents; SentN++){
458      TStr SentStr=GetSentStr(SentN);
459      if (DumpP){
460        printf("=================================\n");
461        printf("Sentence %d: %s\n", SentN, SentStr.CStr());
462        printf("-----------------\n");
463      }
464      PLfTree SentLfTree=GetSentLfTree(SentN);
465      TStrPrV HeadStrSubstStrPrV;
466      SentLfTree->PutSubst(LfSubstV, LfAliasBs, HeadStrSubstStrPrV, DumpP);
467      TStr ArSentStr=GenArSentStr(SentStr, HeadStrSubstStrPrV, true);
468      SentStrArSentStrPrV[SentN].Val2=ArSentStr;
469      if (DumpP){
470        printf("-----------------\n");
471        printf("ArSentence %d: %s\n", SentN, ArSentStr.CStr());
472      }
473      TLfSubst::Dump(DumpP, LfSubstV);
474      LfAliasBs->Dump(DumpP);
475    }
476  }
477  void TLfDoc::ClrHeadsSubst(){
478    int Sents=GetSents();
479    for (int SentN=0; SentN<Sents; SentN++){
480      PLfTree SentLfTree=GetSentLfTree(SentN);
481      SentLfTree->ClrSubst();
482    }
483  }
484  void TLfDoc::Dump(const int& DumpSentN) const {
485    printf("=========================\n");
486    printf("Document: '%s'\n", DocId.CStr());
487    for (int SentN=0; SentN<GetSents(); SentN++){
488      if ((SentN!=-1)&&(SentN!=DumpSentN)){continue;}
489      printf("-------------------------\n");
490      printf("Sentence[%d]: %s\n", SentN, GetSentStr(SentN).CStr());
491      printf("ArSenten[%d]: %s\n", SentN, GetArSentStr(SentN).CStr());
492      printf("-------------------------\n");
493      GetSentLfTree(SentN)->Dump();
494    }
495    printf("=========================\n");
496  }
497  PLfDoc TLfDocBs::GetLfDoc(const TStr& DocId) const {
498    int LfDocs=GetLfDocs();
499    for (int LfDocN=0; LfDocN<LfDocs; LfDocN++){
500      if (GetLfDoc(LfDocN)->DocId==DocId){
501        return GetLfDoc(LfDocN);
502      }
503    }
504    return NULL;
505  }
506  void TLfDocBs::GenHeadsSubst(const bool& DumpP){
507    int LfDocs=GetLfDocs();
508    for (int LfDocN=0; LfDocN<LfDocs; LfDocN++){
509      GetLfDoc(LfDocN)->GenHeadsSubst(NULL, DumpP);
510    }
511  }
512  void TLfDocBs::GenHeadsSubst(const TStrV& DocIdV, const bool& DumpP){
513    TLfAliasBsV LfAliasBsV;
514    for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
515      TStr DocId=DocIdV[DocIdN]; PLfDoc LfDoc;
516      if (IsLfDoc(DocId, LfDoc)){
517        PLfAliasBs LfAliasBs=TLfAliasBs::New();
518        LfDoc->GenHeadsSubst(LfAliasBs, false);
519        LfAliasBsV.Add(LfAliasBs);
520      }
521    }
522    PLfAliasBs TopLfAliasBs=TLfAliasBs::New();
523    for (int LfAliasBsN=0; LfAliasBsN<LfAliasBsV.Len(); LfAliasBsN++){
524      TopLfAliasBs->MergeAliasBs(LfAliasBsV[LfAliasBsN]);
525    }
526    TopLfAliasBs->Dump(DumpP);
527    for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
528      TStr DocId=DocIdV[DocIdN]; PLfDoc LfDoc;
529      if (IsLfDoc(DocId, LfDoc)){
530        LfDoc->ClrHeadsSubst();
531        PLfAliasBs LfAliasBs=TLfAliasBs::New(TopLfAliasBs);
532        LfDoc->GenHeadsSubst(LfAliasBs, false);
533      }
534    }
535  }
536  void TLfDocBs::GetCompClV(const PXmlTok& XmlTok, TStrV& CompClStrV) const {
537    if (XmlTok->IsTag("NP")&&XmlTok->IsArg("name")){
538      if (XmlTok->GetArgVal("name").IsPrefix("COMPCL")){
539        TStr CompClStr=XmlTok->GetArgVal("String");
540        CompClStrV.AddMerged(CompClStr);
541        return;
542      }
543    }
544    int SubToks=XmlTok->GetSubToks();
545    for (int SubTokN=0; SubTokN<SubToks; SubTokN++){
546      GetCompClV(XmlTok->GetSubTok(SubTokN), CompClStrV);
547    }
548  }
549  PLfDocBs TLfDocBs::LoadXml(const TStr& FNm, const bool& DumpP){
550    PLfDocBs LfDocBs=TLfDocBs::New();
551    PSIn XmlSIn=TFIn::New(FNm);
552    TXmlDoc::SkipTopTag(XmlSIn);
553    PXmlDoc XmlDoc; int XmlDocs=0;
554    forever{
555      XmlDocs++; printf("%d\r", XmlDocs);
556      XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
557      if (!XmlDoc->IsOk()){break;}
558      PXmlTok DocTok=XmlDoc->GetTok();
559      IAssert(DocTok->IsTag("DOCUMENT"));
560      TStr DocId=DocTok->GetArgVal("NO");
561      printf("%s: ", DocId.CStr());
562      PLfDoc LfDoc=TLfDoc::New(DocId);
563      LfDocBs->AddLfDoc(LfDoc);
564      int SentToks=DocTok->GetSubToks();
565      for (int SentTokN=0; SentTokN<SentToks; SentTokN++){
566        PXmlTok SentTok=DocTok->GetSubTok(SentTokN);
567        if (!SentTok->IsTag("SENTENCE")){continue;}
568        TStr SentId=SentTok->GetArgVal("ID");
569        printf("[%d]", SentId.GetInt());
570        PXmlTok LfTok=SentTok->GetTagTok("NLP|LogicalForm");
571        TStr SentStr; PLfTree SentLfTree;
572        if (!LfTok.Empty()){
573          SentStr=LfTok->GetArgVal("String");
574          PXmlTok SentTreeTok=SentTok->GetTagTok("NLP|LogicalForm|Sentence");
575          SentLfTree=TLfTree::GetLfTree(SentTreeTok);
576          if (SentLfTree.Empty()){SentLfTree=TLfTree::New();}
577        } else {
578          SentLfTree=TLfTree::New();
579        }
580        LfDoc->AddSent(SentStr, SentLfTree);
581        IAssert(SentId.GetInt()==LfDoc->GetSents()-1);
582      }
583      printf("\n");
584      if (DumpP){LfDoc->Dump();}
585    }
586    return LfDocBs;
587  }
588  PLfDocBs TLfDocBs::LoadBinSet(const TStr& FPath, const TStr& FExt){
589    printf("Loading Logical-Form-Binary-Set...\n");
590    PLfDocBs LfDocBs=TLfDocBs::New();
591    TFFile FFile(FPath, FExt, true); TStr FNm;
592    while (FFile.Next(FNm)){
593      printf("%s\n", FNm.CStr());
594      PLfDocBs LocLfDocBs=TLfDocBs::LoadBin(FNm);
595      LfDocBs->AddLfDocBs(LocLfDocBs);
596    }
597    printf("Done.\n");
598    return LfDocBs;
599  }
600  void TLfDocBs::ConvXmlToLdb(const TStr& FNm, const bool& DumpP){
601    printf("%s\n", FNm.CStr());
602    PLfDocBs LfDocBs=TLfDocBs::LoadXml(FNm, DumpP);
603    LfDocBs->SaveBin(TStr::PutFExt(FNm, ".Ldb"));
604  }
605  void TLfDocBs::ConvSetXmlToLdb(const TStr& FPath, const bool& DumpP){
606    TFFile FFile(FPath, ".xml", false); TStr FNm;
607    while (FFile.Next(FNm)){
608      ConvXmlToLdb(FNm, DumpP);
609    }
610  }
611  void TLfDocBs::Dump() const {
612    for (int LfDocN=0; LfDocN<GetLfDocs(); LfDocN++){
613      GetLfDoc(LfDocN)->Dump();
614    }
615  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nlpwinlf.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nlpwinlf.cpp</div>
                </div>
                <div class="column column_space"><pre><code>308            LfAliasBs->PutAliasStr(HeadStr, LfSubst->SubstId, LfSubst->SubstStr);
309            LfAliasBs->UpdateLfSubstV(LfSubst->SubstStr, LfSubstV);
</pre></code></div>
                <div class="column column_space"><pre><code>308            LfAliasBs->PutAliasStr(HeadStr, LfSubst->SubstId, LfSubst->SubstStr);
309            LfAliasBs->UpdateLfSubstV(LfSubst->SubstStr, LfSubstV);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    