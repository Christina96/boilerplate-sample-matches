
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.35881753312946%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dotproductfma.cpp</h3>
            <pre><code>1  #if !defined(__FMA__)
2  #  if defined(__i686__) || defined(__x86_64__)
3  #    error Implementation only for FMA capable architectures
4  #  endif
5  #else
6  #  include <immintrin.h>
7  #  include <cstdint>
8  #  include "dotproduct.h"
9  namespace tesseract {
10  #if defined(FAST_FLOAT)
11  float DotProductFMA(const float *u, const float *v, int n) {
12    const unsigned quot = n / 16;
13    const unsigned rem = n % 16;
14    __m256 t0 = _mm256_setzero_ps();
15    __m256 t1 = _mm256_setzero_ps();
<span onclick='openModal()' class='match'>16    for (unsigned k = 0; k < quot; k++) {
17      __m256 f0 = _mm256_loadu_ps(u);
18      __m256 f1 = _mm256_loadu_ps(v);
19      t0 = _mm256_fmadd_ps(f0, f1, t0);
20      u += 8;
21      v += 8;
22      __m256 f2 = _mm256_loadu_ps(u);
23      __m256 f3 = _mm256_loadu_ps(v);
24      t1 = _mm256_fmadd_ps(f2, f3, t1);
25      u += 8;
26      v += 8;
27    }
</span>28    t0 = _mm256_hadd_ps(t0, t1);
29    alignas(32) float tmp[8];
30    _mm256_store_ps(tmp, t0);
31    float result = tmp[0] + tmp[1] + tmp[2] + tmp[3] + tmp[4] + tmp[5] + tmp[6] + tmp[7];
32    for (unsigned k = 0; k < rem; k++) {
33      result += *u++ * *v++;
34    }
35    return result;
36  }
37  #else
38  double DotProductFMA(const double *u, const double *v, int n) {
39    const unsigned quot = n / 8;
40    const unsigned rem = n % 8;
41    __m256d t0 = _mm256_setzero_pd();
42    __m256d t1 = _mm256_setzero_pd();
43    for (unsigned k = 0; k < quot; k++) {
44      __m256d f0 = _mm256_loadu_pd(u);
45      __m256d f1 = _mm256_loadu_pd(v);
46      t0 = _mm256_fmadd_pd(f0, f1, t0);
47      u += 4;
48      v += 4;
49      __m256d f2 = _mm256_loadu_pd(u);
50      __m256d f3 = _mm256_loadu_pd(v);
51      t1 = _mm256_fmadd_pd(f2, f3, t1);
52      u += 4;
53      v += 4;
54    }
55    t0 = _mm256_hadd_pd(t0, t1);
56    alignas(32) double tmp[4];
57    _mm256_store_pd(tmp, t0);
58    double result = tmp[0] + tmp[1] + tmp[2] + tmp[3];
59    for (unsigned k = 0; k < rem; k++) {
60      result += *u++ * *v++;
61    }
62    return result;
63  }
64  #endif
65  } 
66  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ratngs.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "ratngs.h"
5  #include "blobs.h"
6  #include "matrix.h"
7  #include "normalis.h" 
8  #include "unicharset.h"
9  #include <algorithm>
10  #include <cmath>
11  #include <string>
12  #include <vector>
13  namespace tesseract {
14  const float WERD_CHOICE::kBadRating = 100000.0;
15  const int kMinSubscriptOffset = 20;
16  const int kMinSuperscriptOffset = 20;
17  const int kMaxDropCapBottom = -128;
18  const double kMaxOverlapDenominator = 0.125;
19  const double kMinXHeightMatch = 0.5;
20  const double kMaxBaselineDrift = 0.0625;
21  static const char kPermuterTypeNoPerm[] = "None";
22  static const char kPermuterTypePuncPerm[] = "Punctuation";
23  static const char kPermuterTypeTopPerm[] = "Top Choice";
24  static const char kPermuterTypeLowerPerm[] = "Top Lower Case";
25  static const char kPermuterTypeUpperPerm[] = "Top Upper Case";
26  static const char kPermuterTypeNgramPerm[] = "Ngram";
27  static const char kPermuterTypeNumberPerm[] = "Number";
28  static const char kPermuterTypeUserPatPerm[] = "User Pattern";
29  static const char kPermuterTypeSysDawgPerm[] = "System Dictionary";
30  static const char kPermuterTypeDocDawgPerm[] = "Document Dictionary";
31  static const char kPermuterTypeUserDawgPerm[] = "User Dictionary";
32  static const char kPermuterTypeFreqDawgPerm[] = "Frequent Words Dictionary";
33  static const char kPermuterTypeCompoundPerm[] = "Compound";
34  static const char *const kPermuterTypeNames[] = {
35      kPermuterTypeNoPerm,       
36      kPermuterTypePuncPerm,     
37      kPermuterTypeTopPerm,      
38      kPermuterTypeLowerPerm,    
39      kPermuterTypeUpperPerm,    
40      kPermuterTypeNgramPerm,    
41      kPermuterTypeNumberPerm,   
42      kPermuterTypeUserPatPerm,  
43      kPermuterTypeSysDawgPerm,  
44      kPermuterTypeDocDawgPerm,  
45      kPermuterTypeUserDawgPerm, 
46      kPermuterTypeFreqDawgPerm, 
47      kPermuterTypeCompoundPerm  
48  };
49  BLOB_CHOICE::BLOB_CHOICE(UNICHAR_ID src_unichar_id, 
50                           float src_rating,          
51                           float src_cert,            
52                           int src_script_id,         
53                           float min_xheight,         
54                           float max_xheight,         
55                           float yshift,              
<span onclick='openModal()' class='match'>56                           BlobChoiceClassifier c) {  
57    unichar_id_ = src_unichar_id;
58    rating_ = src_rating;
59    certainty_ = src_cert;
60    fontinfo_id_ = -1;
61    fontinfo_id2_ = -1;
62    script_id_ = src_script_id;
63    min_xheight_ = min_xheight;
64    max_xheight_ = max_xheight;
65    yshift_ = yshift;
66    classifier_ = c;
67  }
</span>68  BLOB_CHOICE::BLOB_CHOICE(const BLOB_CHOICE &other) : ELIST_LINK(other) {
69    unichar_id_ = other.unichar_id();
70    rating_ = other.rating();
71    certainty_ = other.certainty();
72    fontinfo_id_ = other.fontinfo_id();
73    fontinfo_id2_ = other.fontinfo_id2();
74    script_id_ = other.script_id();
75    matrix_cell_ = other.matrix_cell_;
76    min_xheight_ = other.min_xheight_;
77    max_xheight_ = other.max_xheight_;
78    yshift_ = other.yshift();
79    classifier_ = other.classifier_;
80  #ifndef DISABLED_LEGACY_ENGINE
81    fonts_ = other.fonts_;
82  #endif 
83  }
84  BLOB_CHOICE &BLOB_CHOICE::operator=(const BLOB_CHOICE &other) {
85    ELIST_LINK::operator=(other);
86    unichar_id_ = other.unichar_id();
87    rating_ = other.rating();
88    certainty_ = other.certainty();
89    fontinfo_id_ = other.fontinfo_id();
90    fontinfo_id2_ = other.fontinfo_id2();
91    script_id_ = other.script_id();
92    matrix_cell_ = other.matrix_cell_;
93    min_xheight_ = other.min_xheight_;
94    max_xheight_ = other.max_xheight_;
95    yshift_ = other.yshift();
96    classifier_ = other.classifier_;
97  #ifndef DISABLED_LEGACY_ENGINE
98    fonts_ = other.fonts_;
99  #endif 
100    return *this;
101  }
102  bool BLOB_CHOICE::PosAndSizeAgree(const BLOB_CHOICE &other, float x_height, bool debug) const {
103    double baseline_diff = std::fabs(yshift() - other.yshift());
104    if (baseline_diff > kMaxBaselineDrift * x_height) {
105      if (debug) {
106        tprintf("Baseline diff %g for %d v %d\n", baseline_diff, unichar_id_, other.unichar_id_);
107      }
108      return false;
109    }
110    double this_range = max_xheight() - min_xheight();
111    double other_range = other.max_xheight() - other.min_xheight();
112    double denominator =
113        ClipToRange(std::min(this_range, other_range), 1.0, kMaxOverlapDenominator * x_height);
114    double overlap =
115        std::min(max_xheight(), other.max_xheight()) - std::max(min_xheight(), other.min_xheight());
116    overlap /= denominator;
117    if (debug) {
118      tprintf("PosAndSize for %d v %d: bl diff = %g, ranges %g, %g / %g ->%g\n", unichar_id_,
119              other.unichar_id_, baseline_diff, this_range, other_range, denominator, overlap);
120    }
121    return overlap >= kMinXHeightMatch;
122  }
123  BLOB_CHOICE *FindMatchingChoice(UNICHAR_ID char_id, BLOB_CHOICE_LIST *bc_list) {
124    BLOB_CHOICE_IT choice_it(bc_list);
125    for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
126      BLOB_CHOICE *choice = choice_it.data();
127      if (choice->unichar_id() == char_id) {
128        return choice;
129      }
130    }
131    return nullptr;
132  }
133  const char *WERD_CHOICE::permuter_name(uint8_t permuter) {
134    return kPermuterTypeNames[permuter];
135  }
136  const char *ScriptPosToString(enum ScriptPos script_pos) {
137    switch (script_pos) {
138      case SP_NORMAL:
139        return "NORM";
140      case SP_SUBSCRIPT:
141        return "SUB";
142      case SP_SUPERSCRIPT:
143        return "SUPER";
144      case SP_DROPCAP:
145        return "DROPC";
146    }
147    return "SP_UNKNOWN";
148  }
149  WERD_CHOICE::WERD_CHOICE(const char *src_string, const UNICHARSET &unicharset)
150      : unicharset_(&unicharset) {
151    std::vector<UNICHAR_ID> encoding;
152    std::vector<char> lengths;
153    std::string cleaned = unicharset.CleanupString(src_string);
154    if (unicharset.encode_string(cleaned.c_str(), true, &encoding, &lengths, nullptr)) {
155      lengths.push_back('\0');
156      std::string src_lengths = &lengths[0];
157      this->init(cleaned.c_str(), src_lengths.c_str(), 0.0, 0.0, NO_PERM);
158    } else { 
159      this->init(8);
160      this->make_bad();
161    }
162  }
163  void WERD_CHOICE::init(const char *src_string, const char *src_lengths, float src_rating,
164                         float src_certainty, uint8_t src_permuter) {
165    int src_string_len = strlen(src_string);
166    if (src_string_len == 0) {
167      this->init(8);
168    } else {
169      this->init(src_lengths ? strlen(src_lengths) : src_string_len);
170      length_ = reserved_;
171      int offset = 0;
172      for (unsigned i = 0; i < length_; ++i) {
173        int unichar_length = src_lengths ? src_lengths[i] : 1;
174        unichar_ids_[i] = unicharset_->unichar_to_id(src_string + offset, unichar_length);
175        state_[i] = 1;
176        certainties_[i] = src_certainty;
177        offset += unichar_length;
178      }
179    }
180    adjust_factor_ = 1.0f;
181    rating_ = src_rating;
182    certainty_ = src_certainty;
183    permuter_ = src_permuter;
184    dangerous_ambig_found_ = false;
185  }
186  WERD_CHOICE::~WERD_CHOICE() = default;
187  const char *WERD_CHOICE::permuter_name() const {
188    return kPermuterTypeNames[permuter_];
189  }
190  BLOB_CHOICE_LIST *WERD_CHOICE::blob_choices(unsigned index, MATRIX *ratings) const {
191    MATRIX_COORD coord = MatrixCoord(index);
192    BLOB_CHOICE_LIST *result = ratings->get(coord.col, coord.row);
193    if (result == nullptr) {
194      result = new BLOB_CHOICE_LIST;
195      ratings->put(coord.col, coord.row, result);
196    }
197    return result;
198  }
199  MATRIX_COORD WERD_CHOICE::MatrixCoord(unsigned index) const {
200    int col = 0;
201    for (unsigned i = 0; i < index; ++i) {
202      col += state_[i];
203    }
204    int row = col + state_[index] - 1;
205    return MATRIX_COORD(col, row);
206  }
207  void WERD_CHOICE::set_blob_choice(unsigned index, int blob_count, const BLOB_CHOICE *blob_choice) {
208    unichar_ids_[index] = blob_choice->unichar_id();
209    script_pos_[index] = tesseract::SP_NORMAL;
210    state_[index] = blob_count;
211    certainties_[index] = blob_choice->certainty();
212  }
213  bool WERD_CHOICE::contains_unichar_id(UNICHAR_ID unichar_id) const {
214    for (unsigned i = 0; i < length_; ++i) {
215      if (unichar_ids_[i] == unichar_id) {
216        return true;
217      }
218    }
219    return false;
220  }
221  void WERD_CHOICE::remove_unichar_ids(unsigned start, int num) {
222    ASSERT_HOST(start + num <= length_);
223    for (int i = 0; i < num; ++i) {
224      if (start > 0) {
225        state_[start - 1] += state_[start + i];
226      } else if (start + num < length_) {
227        state_[start + num] += state_[start + i];
228      }
229    }
230    for (unsigned i = start; i + num < length_; ++i) {
231      unichar_ids_[i] = unichar_ids_[i + num];
232      script_pos_[i] = script_pos_[i + num];
233      state_[i] = state_[i + num];
234      certainties_[i] = certainties_[i + num];
235    }
236    length_ -= num;
237  }
238  void WERD_CHOICE::reverse_and_mirror_unichar_ids() {
239    for (unsigned i = 0; i < length_ / 2; ++i) {
240      UNICHAR_ID tmp_id = unichar_ids_[i];
241      unichar_ids_[i] = unicharset_->get_mirror(unichar_ids_[length_ - 1 - i]);
242      unichar_ids_[length_ - 1 - i] = unicharset_->get_mirror(tmp_id);
243    }
244    if (length_ % 2 != 0) {
245      unichar_ids_[length_ / 2] = unicharset_->get_mirror(unichar_ids_[length_ / 2]);
246    }
247  }
248  void WERD_CHOICE::punct_stripped(unsigned *start, unsigned *end) const {
249    *start = 0;
250    *end = length();
251    while (*start < length() && unicharset()->get_ispunctuation(unichar_id(*start))) {
252      (*start)++;
253    }
254    while (*end > 0 && unicharset()->get_ispunctuation(unichar_id(*end - 1))) {
255      (*end)--;
256    }
257  }
258  void WERD_CHOICE::GetNonSuperscriptSpan(int *pstart, int *pend) const {
259    int end = length();
260    while (end > 0 && unicharset_->get_isdigit(unichar_ids_[end - 1]) &&
261           BlobPosition(end - 1) == tesseract::SP_SUPERSCRIPT) {
262      end--;
263    }
264    int start = 0;
265    while (start < end && unicharset_->get_isdigit(unichar_ids_[start]) &&
266           BlobPosition(start) == tesseract::SP_SUPERSCRIPT) {
267      start++;
268    }
269    *pstart = start;
270    *pend = end;
271  }
272  WERD_CHOICE WERD_CHOICE::shallow_copy(unsigned start, unsigned end) const {
273    ASSERT_HOST(start <= length_);
274    ASSERT_HOST(end <= length_);
275    if (end < start) {
276      end = start;
277    }
278    WERD_CHOICE retval(unicharset_, end - start);
279    for (auto i = start; i < end; i++) {
280      retval.append_unichar_id_space_allocated(unichar_ids_[i], state_[i], 0.0f, certainties_[i]);
281    }
282    return retval;
283  }
284  bool WERD_CHOICE::has_rtl_unichar_id() const {
285    for (unsigned i = 0; i < length_; ++i) {
286      UNICHARSET::Direction dir = unicharset_->get_direction(unichar_ids_[i]);
287      if (dir == UNICHARSET::U_RIGHT_TO_LEFT || dir == UNICHARSET::U_RIGHT_TO_LEFT_ARABIC) {
288        return true;
289      }
290    }
291    return false;
292  }
293  void WERD_CHOICE::string_and_lengths(std::string *word_str, std::string *word_lengths_str) const {
294    *word_str = "";
295    if (word_lengths_str != nullptr) {
296      *word_lengths_str = "";
297    }
298    for (unsigned i = 0; i < length_; ++i) {
299      const char *ch = unicharset_->id_to_unichar_ext(unichar_ids_[i]);
300      *word_str += ch;
301      if (word_lengths_str != nullptr) {
302        *word_lengths_str += (char)strlen(ch);
303      }
304    }
305  }
306  void WERD_CHOICE::append_unichar_id(UNICHAR_ID unichar_id, int blob_count, float rating,
307                                      float certainty) {
308    if (length_ == reserved_) {
309      this->double_the_size();
310    }
311    this->append_unichar_id_space_allocated(unichar_id, blob_count, rating, certainty);
312  }
313  WERD_CHOICE &WERD_CHOICE::operator+=(const WERD_CHOICE &second) {
314    ASSERT_HOST(unicharset_ == second.unicharset_);
315    while (reserved_ < length_ + second.length()) {
316      this->double_the_size();
317    }
318    const std::vector<UNICHAR_ID> &other_unichar_ids = second.unichar_ids();
319    for (unsigned i = 0; i < second.length(); ++i) {
320      unichar_ids_[length_ + i] = other_unichar_ids[i];
321      state_[length_ + i] = second.state_[i];
322      certainties_[length_ + i] = second.certainties_[i];
323      script_pos_[length_ + i] = second.BlobPosition(i);
324    }
325    length_ += second.length();
326    if (second.adjust_factor_ > adjust_factor_) {
327      adjust_factor_ = second.adjust_factor_;
328    }
329    rating_ += second.rating();            
330    if (second.certainty() < certainty_) { 
331      certainty_ = second.certainty();
332    }
333    if (second.dangerous_ambig_found_) {
334      dangerous_ambig_found_ = true;
335    }
336    if (permuter_ == NO_PERM) {
337      permuter_ = second.permuter();
338    } else if (second.permuter() != NO_PERM && second.permuter() != permuter_) {
339      permuter_ = COMPOUND_PERM;
340    }
341    return *this;
342  }
343  WERD_CHOICE &WERD_CHOICE::operator=(const WERD_CHOICE &source) {
344    while (reserved_ < source.length()) {
345      this->double_the_size();
346    }
347    unicharset_ = source.unicharset_;
348    const std::vector<UNICHAR_ID> &other_unichar_ids = source.unichar_ids();
349    for (unsigned i = 0; i < source.length(); ++i) {
350      unichar_ids_[i] = other_unichar_ids[i];
351      state_[i] = source.state_[i];
352      certainties_[i] = source.certainties_[i];
353      script_pos_[i] = source.BlobPosition(i);
354    }
355    length_ = source.length();
356    adjust_factor_ = source.adjust_factor_;
357    rating_ = source.rating();
358    certainty_ = source.certainty();
359    min_x_height_ = source.min_x_height();
360    max_x_height_ = source.max_x_height();
361    permuter_ = source.permuter();
362    dangerous_ambig_found_ = source.dangerous_ambig_found_;
363    return *this;
364  }
365  void WERD_CHOICE::SetScriptPositions(bool small_caps, TWERD *word, int debug) {
366    for (unsigned i = 0; i < length_; ++i) {
367      script_pos_[i] = tesseract::SP_NORMAL;
368    }
369    if (word->blobs.empty() || word->NumBlobs() != TotalOfStates()) {
370      return;
371    }
372    unsigned position_counts[4] = {0, 0, 0, 0};
373    int chunk_index = 0;
374    for (unsigned blob_index = 0; blob_index < length_; ++blob_index, ++chunk_index) {
375      TBLOB *tblob = word->blobs[chunk_index];
376      int uni_id = unichar_id(blob_index);
377      TBOX blob_box = tblob->bounding_box();
378      if (!state_.empty()) {
379        for (int i = 1; i < state_[blob_index]; ++i) {
380          ++chunk_index;
381          tblob = word->blobs[chunk_index];
382          blob_box += tblob->bounding_box();
383        }
384      }
385      script_pos_[blob_index] = ScriptPositionOf(false, *unicharset_, blob_box, uni_id);
386      if (small_caps && script_pos_[blob_index] != tesseract::SP_DROPCAP) {
387        script_pos_[blob_index] = tesseract::SP_NORMAL;
388      }
389      position_counts[script_pos_[blob_index]]++;
390    }
391    if (4 * position_counts[tesseract::SP_SUBSCRIPT] > 3 * length_ ||
392        4 * position_counts[tesseract::SP_SUPERSCRIPT] > 3 * length_) {
393      if (debug >= 2) {
394        tprintf(
395            "Most characters of %s are subscript or superscript.\n"
396            "That seems wrong, so I'll assume we got the baseline wrong\n",
397            unichar_string().c_str());
398      }
399      for (unsigned i = 0; i < length_; i++) {
400        ScriptPos sp = script_pos_[i];
401        if (sp == tesseract::SP_SUBSCRIPT || sp == tesseract::SP_SUPERSCRIPT) {
402          ASSERT_HOST(position_counts[sp] > 0);
403          position_counts[sp]--;
404          position_counts[tesseract::SP_NORMAL]++;
405          script_pos_[i] = tesseract::SP_NORMAL;
406        }
407      }
408    }
409    if ((debug >= 1 && position_counts[tesseract::SP_NORMAL] < length_) || debug >= 2) {
410      tprintf("SetScriptPosition on %s\n", unichar_string().c_str());
411      int chunk_index = 0;
412      for (unsigned blob_index = 0; blob_index < length_; ++blob_index) {
413        if (debug >= 2 || script_pos_[blob_index] != tesseract::SP_NORMAL) {
414          TBLOB *tblob = word->blobs[chunk_index];
415          ScriptPositionOf(true, *unicharset_, tblob->bounding_box(), unichar_id(blob_index));
416        }
417        chunk_index += state_.empty() ? 1 : state_[blob_index];
418      }
419    }
420  }
421  void WERD_CHOICE::SetAllScriptPositions(tesseract::ScriptPos position) {
422    for (unsigned i = 0; i < length_; ++i) {
423      script_pos_[i] = position;
424    }
425  }
426  ScriptPos WERD_CHOICE::ScriptPositionOf(bool print_debug, const UNICHARSET &unicharset,
427                                          const TBOX &blob_box, UNICHAR_ID unichar_id) {
428    ScriptPos retval = tesseract::SP_NORMAL;
429    int top = blob_box.top();
430    int bottom = blob_box.bottom();
431    int min_bottom, max_bottom, min_top, max_top;
432    unicharset.get_top_bottom(unichar_id, &min_bottom, &max_bottom, &min_top, &max_top);
433    int sub_thresh_top = min_top - kMinSubscriptOffset;
434    int sub_thresh_bot = kBlnBaselineOffset - kMinSubscriptOffset;
435    int sup_thresh_bot = max_bottom + kMinSuperscriptOffset;
436    if (bottom <= kMaxDropCapBottom) {
437      retval = tesseract::SP_DROPCAP;
438    } else if (top < sub_thresh_top && bottom < sub_thresh_bot) {
439      retval = tesseract::SP_SUBSCRIPT;
440    } else if (bottom > sup_thresh_bot) {
441      retval = tesseract::SP_SUPERSCRIPT;
442    }
443    if (print_debug) {
444      const char *pos = ScriptPosToString(retval);
445      tprintf(
446          "%s Character %s[bot:%d top: %d]  "
447          "bot_range[%d,%d]  top_range[%d, %d] "
448          "sub_thresh[bot:%d top:%d]  sup_thresh_bot %d\n",
449          pos, unicharset.id_to_unichar(unichar_id), bottom, top, min_bottom, max_bottom, min_top,
450          max_top, sub_thresh_bot, sub_thresh_top, sup_thresh_bot);
451    }
452    return retval;
453  }
454  int WERD_CHOICE::GetTopScriptID() const {
455    unsigned max_script = unicharset_->get_script_table_size();
456    std::vector<unsigned> sid(max_script);
457    for (unsigned x = 0; x < length_; ++x) {
458      int script_id = unicharset_->get_script(unichar_id(x));
459      sid[script_id]++;
460    }
461    if (unicharset_->han_sid() != unicharset_->null_sid()) {
462      if (unicharset_->hiragana_sid() != unicharset_->null_sid()) {
463        sid[unicharset_->han_sid()] += sid[unicharset_->hiragana_sid()];
464        sid[unicharset_->hiragana_sid()] = 0;
465      }
466      if (unicharset_->katakana_sid() != unicharset_->null_sid()) {
467        sid[unicharset_->han_sid()] += sid[unicharset_->katakana_sid()];
468        sid[unicharset_->katakana_sid()] = 0;
469      }
470    }
471    unsigned max_sid = 0;
472    for (unsigned x = 1; x < max_script; x++) {
473      if (sid[x] >= sid[max_sid]) {
474        max_sid = x;
475      }
476    }
477    if (sid[max_sid] < length_ / 2) {
478      max_sid = unicharset_->null_sid();
479    }
480    return max_sid;
481  }
482  void WERD_CHOICE::UpdateStateForSplit(int blob_position) {
483    int total_chunks = 0;
484    for (unsigned i = 0; i < length_; ++i) {
485      total_chunks += state_[i];
486      if (total_chunks > blob_position) {
487        ++state_[i];
488        return;
489      }
490    }
491  }
492  unsigned WERD_CHOICE::TotalOfStates() const {
493    unsigned total_chunks = 0;
494    for (unsigned i = 0; i < length_; ++i) {
495      total_chunks += state_[i];
496    }
497    return total_chunks;
498  }
499  void WERD_CHOICE::print(const char *msg) const {
500    tprintf("%s : ", msg);
501    for (unsigned i = 0; i < length_; ++i) {
502      tprintf("%s", unicharset_->id_to_unichar(unichar_ids_[i]));
503    }
504    tprintf(" : R=%g, C=%g, F=%g, Perm=%d, xht=[%g,%g], ambig=%d\n", rating_, certainty_,
505            adjust_factor_, permuter_, min_x_height_, max_x_height_, dangerous_ambig_found_);
506    tprintf("pos");
507    for (unsigned i = 0; i < length_; ++i) {
508      tprintf("\t%s", ScriptPosToString(script_pos_[i]));
509    }
510    tprintf("\nstr");
511    for (unsigned i = 0; i < length_; ++i) {
512      tprintf("\t%s", unicharset_->id_to_unichar(unichar_ids_[i]));
513    }
514    tprintf("\nstate:");
515    for (unsigned i = 0; i < length_; ++i) {
516      tprintf("\t%d ", state_[i]);
517    }
518    tprintf("\nC");
519    for (unsigned i = 0; i < length_; ++i) {
520      tprintf("\t%.3f", certainties_[i]);
521    }
522    tprintf("\n");
523  }
524  void WERD_CHOICE::print_state(const char *msg) const {
525    tprintf("%s", msg);
526    for (unsigned i = 0; i < length_; ++i) {
527      tprintf(" %d", state_[i]);
528    }
529    tprintf("\n");
530  }
531  #ifndef GRAPHICS_DISABLED
532  void WERD_CHOICE::DisplaySegmentation(TWERD *word) {
533    const int kNumColors = 6;
534    static ScrollView *segm_window = nullptr;
535    static std::vector<int> prev_drawn_state;
536    bool already_done = prev_drawn_state.size() == length_;
537    if (!already_done) {
538      prev_drawn_state.clear();
539      prev_drawn_state.resize(length_);
540    }
541    for (unsigned i = 0; i < length_; ++i) {
542      if (prev_drawn_state[i] != state_[i]) {
543        already_done = false;
544      }
545      prev_drawn_state[i] = state_[i];
546    }
547    if (already_done || word->blobs.empty()) {
548      return;
549    }
550    if (segm_window == nullptr) {
551      segm_window = new ScrollView("Segmentation", 5, 10, 500, 256, 2000.0, 256.0, true);
552    } else {
553      segm_window->Clear();
554    }
555    TBOX bbox;
556    int blob_index = 0;
557    for (unsigned c = 0; c < length_; ++c) {
558      auto color = static_cast<ScrollView::Color>(c % kNumColors + 3);
559      for (int i = 0; i < state_[c]; ++i, ++blob_index) {
560        TBLOB *blob = word->blobs[blob_index];
561        bbox += blob->bounding_box();
562        blob->plot(segm_window, color, color);
563      }
564    }
565    segm_window->ZoomToRectangle(bbox.left(), bbox.top(), bbox.right(), bbox.bottom());
566    segm_window->Update();
567    segm_window->Wait();
568  }
569  #endif 
570  bool EqualIgnoringCaseAndTerminalPunct(const WERD_CHOICE &word1, const WERD_CHOICE &word2) {
571    const UNICHARSET *uchset = word1.unicharset();
572    if (word2.unicharset() != uchset) {
573      return false;
574    }
575    unsigned w1start, w1end;
576    word1.punct_stripped(&w1start, &w1end);
577    unsigned w2start, w2end;
578    word2.punct_stripped(&w2start, &w2end);
579    if (w1end - w1start != w2end - w2start) {
580      return false;
581    }
582    for (unsigned i = 0; i < w1end - w1start; i++) {
583      if (uchset->to_lower(word1.unichar_id(w1start + i)) !=
584          uchset->to_lower(word2.unichar_id(w2start + i))) {
585        return false;
586      }
587    }
588    return true;
589  }
590  void print_ratings_list(const char *msg, BLOB_CHOICE_LIST *ratings,
591                          const UNICHARSET &current_unicharset) {
592    if (ratings->empty()) {
593      tprintf("%s:<none>\n", msg);
594      return;
595    }
596    if (*msg != '\0') {
597      tprintf("%s\n", msg);
598    }
599    BLOB_CHOICE_IT c_it;
600    c_it.set_to_list(ratings);
601    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
602      c_it.data()->print(&current_unicharset);
603      if (!c_it.at_last()) {
604        tprintf("\n");
605      }
606    }
607    tprintf("\n");
608    fflush(stdout);
609  }
610  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dotproductfma.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ratngs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>16    for (unsigned k = 0; k < quot; k++) {
17      __m256 f0 = _mm256_loadu_ps(u);
18      __m256 f1 = _mm256_loadu_ps(v);
19      t0 = _mm256_fmadd_ps(f0, f1, t0);
20      u += 8;
21      v += 8;
22      __m256 f2 = _mm256_loadu_ps(u);
23      __m256 f3 = _mm256_loadu_ps(v);
24      t1 = _mm256_fmadd_ps(f2, f3, t1);
25      u += 8;
26      v += 8;
27    }
</pre></code></div>
                <div class="column column_space"><pre><code>56                           BlobChoiceClassifier c) {  
57    unichar_id_ = src_unichar_id;
58    rating_ = src_rating;
59    certainty_ = src_cert;
60    fontinfo_id_ = -1;
61    fontinfo_id2_ = -1;
62    script_id_ = src_script_id;
63    min_xheight_ = min_xheight;
64    max_xheight_ = max_xheight;
65    yshift_ = yshift;
66    classifier_ = c;
67  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    