
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bix.cpp</h3>
            <pre><code>1  #include &quot;StdAfx.h&quot;
2  #include &quot;bix.h&quot;
3  #include &quot;book.h&quot;
4  TStr TBixCtx::GetStr() const {
5    TChA ChA;
6    ChA+=TInt::GetStr(SecId);
7    ChA+=&#x27;[&#x27;; ChA+=FSet.GetStr(); ChA+=&#x27;]&#x27;;
8    return ChA;
9  }
10  int TBixCtx::TitleFlagN=0;
11  int TBixCtx::ContinentFlagN=1;
12  int TBixCtx::AreaFlagN=2;
13  PTqlCtxSet TBixCtxSet::GetAndCtxSet(const PTqlCtxSet&amp; CtxSet){
14    TBixCtxSet* DstCtxSet=new TBixCtxSet();
15    TBixCtxV&amp; V1=BixCtxV;
16    TBixCtxV&amp; V2=((TBixCtxSet*)CtxSet())-&gt;BixCtxV;
17    TBixCtxV&amp; DstV=DstCtxSet-&gt;BixCtxV;
18    int N1=0; int N2=0;
19    while ((N1&lt;V1.Len())&amp;&amp;(N2&lt;V2.Len())){
20      TBixCtx&amp; Val1=V1[N1];
21      while ((N2&lt;V2.Len())&amp;&amp;(Val1&gt;V2[N2])){
22        N2++;}
23      if ((N2&lt;V2.Len())&amp;&amp;(Val1==V2[N2])){
24        TBixCtx Val(Val1); Val.Merge(V2[N2]);
25        DstV.Add(Val); N2++;
26      }
27      N1++;
28    }
29    return PTqlCtxSet(DstCtxSet);
30  }
31  PTqlCtxSet TBixCtxSet::GetOrCtxSet(const PTqlCtxSet&amp; CtxSet){
32    TBixCtxSet* DstCtxSet=new TBixCtxSet();
33    TBixCtxV&amp; V1=BixCtxV;
34    TBixCtxV&amp; V2=((TBixCtxSet*)CtxSet())-&gt;BixCtxV;
35    TBixCtxV&amp; DstV=DstCtxSet-&gt;BixCtxV;
36    int N1=0; int N2=0;
37    while ((N1&lt;V1.Len())&amp;&amp;(N2&lt;V2.Len())){
38      TBixCtx&amp; Val1=V1[N1];
39      TBixCtx&amp; Val2=V2[N2];
40      if (Val1&lt;Val2){DstV.Add(Val1); N1++;}
41      else if (Val1&gt;Val2){DstV.Add(Val2); N2++;}
42      else {TBixCtx Val(Val1); Val.Merge(Val2); DstV.Add(Val); N1++; N2++;}
43    }
44    for (int RestN1=N1; RestN1&lt;V1.Len(); RestN1++){DstV.Add(V1[RestN1]);}
45    for (int RestN2=N2; RestN2&lt;V2.Len(); RestN2++){DstV.Add(V2[RestN2]);}
46    return PTqlCtxSet(DstCtxSet);
47  }
48  PTqlCtxSet TBixCtxSet::GetTagCtxSet(const TStr&amp; TagNm){
49    int FlagN=-1;
50    if (TagNm==&quot;title&quot;){FlagN=TBixCtx::TitleFlagN;}
51    if (TagNm==&quot;continent&quot;){FlagN=TBixCtx::ContinentFlagN;}
52    if (TagNm==&quot;area&quot;){FlagN=TBixCtx::AreaFlagN;}
53    if (FlagN==-1){
54      return this;
55    } else {
56      TBixCtxSet* DstCtxSet=new TBixCtxSet();
57      TBixCtxV&amp; V=BixCtxV;
58      TBixCtxV&amp; DstV=DstCtxSet-&gt;BixCtxV;
59      for (int N=0; N&lt;V.Len(); N++){
60        if (V[N].IsFlag(FlagN)){
61          DstV.Add(V[N]);}
62      }
63      return PTqlCtxSet(DstCtxSet);
64    }
65  }
66  PTqlCtxSet TBixCtxSet::GetTitleCtxSet(){
67    TBixCtxSet* DstCtxSet=new TBixCtxSet();
68    TBixCtxV&amp; V=BixCtxV;
69    TBixCtxV&amp; DstV=DstCtxSet-&gt;BixCtxV;
70    for (int N=0; N&lt;V.Len(); N++){
71      if (V[N].IsFlag(TBixCtx::TitleFlagN)){
72        DstV.Add(V[N]);}
73    }
74    return PTqlCtxSet(DstCtxSet);
75  }
76  TStr TBixCtxSet::GetStr() const {
77    TChA ChA;
78    for (int CtxN=0; CtxN&lt;BixCtxV.Len(); CtxN++){
79      if (CtxN&gt;0){ChA+=&#x27; &#x27;;}
80      ChA+=BixCtxV[CtxN].GetStr();
81    }
82    return ChA;
83  }
84  void TBix::MergeBixCtx(const TStr&amp; WordStr, const TBixCtx&amp; BixCtx){
85    int WordToCtxVP;
86    if (WordToCtxVH.IsKey(WordStr, WordToCtxVP)){
87      TBixCtxV&amp; BixCtxV=WordToCtxVH[WordToCtxVP];
88      int BixCtxN;
89      if (BixCtxV.IsIn(BixCtx, BixCtxN)){
90        BixCtxV[BixCtxN].Merge(BixCtx); 
91      } else {
92        WordToCtxVH.AddDat(WordStr).AddMerged(BixCtx);
93      }
94    } else {
95      WordToCtxVH.AddDat(WordStr).AddMerged(BixCtx);
96    }
97  }
98  PTqlCtxSet TBix::GetEmptyCtxSet() const {
99    return PTqlCtxSet(new TBixCtxSet());
100  }
101  PTqlCtxSet TBix::GetCtxSet(
102   const TStr&amp; WordStr, const bool&amp; IsWc, const int&amp; MxWcWords) const {
103    IAssert(Access==faRdOnly);
104    TStr NrWordStr=ChDef-&gt;GetUcStr(WordStr);
105    PTqlCtxSet CtxSet;
106    if (IsWc){
107      int FirstWordN; int WordN=WordV.SearchBin(NrWordStr, FirstWordN);
108      if (WordN==-1){
109        CtxSet=PTqlCtxSet(new TBixCtxSet()); WordN=FirstWordN;
110      } else {
111        CtxSet=PTqlCtxSet(new TBixCtxSet(WordToCtxVH.GetDat(NrWordStr))); WordN++;
112      }
113      int WcWords=0;
114      while ((WordN&lt;WordV.Len())&amp;&amp;(WordV[WordN].IsPrefix(NrWordStr))&amp;&amp;
115       (WcWords&lt;MxWcWords)){
116        TStr PfxNrWordStr=WordV[WordN];
117        PTqlCtxSet SubCtxSet=
118         PTqlCtxSet(new TBixCtxSet(WordToCtxVH.GetDat(PfxNrWordStr)));
119        CtxSet=CtxSet-&gt;GetOrCtxSet(SubCtxSet);
120        WordN++; WcWords++;
121      }
122    } else {
123      int WordP;
124      if (WordToCtxVH.IsKey(NrWordStr, WordP)){
125        CtxSet=PTqlCtxSet(new TBixCtxSet(WordToCtxVH[WordP]));
126      } else {
127        CtxSet=PTqlCtxSet(new TBixCtxSet());
128      }
129    }
130    return CtxSet;
131  }
132  PTqlCtxSet TBix::GetCtxSet(
133   const TStr&amp; TagNm, const TRelOp&amp; RelOp, const TStr&amp; ArgValStr,
134   const int&amp; MxWcWords) const {
135    IAssert(Access==faRdOnly);
136    int ArgVal;
137    if (ArgValStr.IsInt(ArgVal)){
138      TBixCtxV BixCtxV;
139      for (int KeyN=0; KeyN&lt;SecIdKeyNmValTrV.Len(); KeyN++){
140        if (SecIdKeyNmValTrV[KeyN].Val2==TagNm){
141          int KeyVal=SecIdKeyNmValTrV[KeyN].Val3;
142          if (Cmp(RelOp, KeyVal, ArgVal)){
143            int SecId=SecIdKeyNmValTrV[KeyN].Val1;
144            BixCtxV.Add(TBixCtx(SecId));
145          }
146        }
147        if ((MxWcWords!=-1)&amp;&amp;(BixCtxV.Len()&gt;MxWcWords)){break;}
148      }
149      BixCtxV.Merge();
150      PTqlCtxSet CtxSet=PTqlCtxSet(new TBixCtxSet(BixCtxV));
151      return CtxSet;
152    } else {
153      return PTqlCtxSet(new TBixCtxSet());
154    }
155  }
156  void TBix::AddSec(const int&amp; SecId, const TStr&amp; SecStr, const bool&amp; TitleP){
157    IAssert(Access==faCreate);
158    PSIn HtmlSIn=TStrIn::New(SecStr);
159    THtmlLx Lx(HtmlSIn, false);
160    bool InTitleTag=TitleP; bool InContinentTag=false; bool InAreaTag=false;
161    while (Lx.GetSym()!=hsyEof){
162      if ((Lx.Sym==hsyStr)||(Lx.Sym==hsyNum)){
163        TStr WordStr(Lx.UcChA);
164        if (!SwSet-&gt;IsIn(WordStr)){
165          TBixCtx BixCtx(SecId);
166          if (InTitleTag){BixCtx.SetFlag(TBixCtx::TitleFlagN);}
167          if (InContinentTag){BixCtx.SetFlag(TBixCtx::ContinentFlagN);}
168          if (InAreaTag){BixCtx.SetFlag(TBixCtx::AreaFlagN);}
169          MergeBixCtx(WordStr, BixCtx);
170        }
171      } else
172      if ((Lx.Sym==hsyBTag)||(Lx.Sym==hsyETag)){
173        TStr TagNm=Lx.UcChA;
174        if (TagNm==THtmlTok::TitleTagNm){InTitleTag=(Lx.Sym==hsyBTag);}
175        else if (TagNm==ContinentTagNm){InContinentTag=(Lx.Sym==hsyBTag);}
176        else if (TagNm==AreaTagNm){InAreaTag=(Lx.Sym==hsyBTag);}
177      }
178    }
179  }
180  PBixRes TBix::Search(const TStr&amp; QueryStr){
181    PTqlExp TqlExp=TTqlExp::New(QueryStr);
182    PBixRes BixRes;
183    if (TqlExp-&gt;IsOk()){
184      PTqlCtxSet CtxSet=TqlExp-&gt;Eval(*this);
185      BixRes=PBixRes(new TBixRes(this, QueryStr, CtxSet));
186    } else {
187      BixRes=PBixRes(new TBixRes(TqlExp-&gt;GetErrMsg()));
188    }
189    return BixRes;
190  }
191  TBixRes::TBixRes(
192   const PBix&amp; _Bix, const TStr&amp; _QueryStr, const PTqlCtxSet&amp; _CtxSet):
193    Ok(true), MsgStr(TStr::OkStr),
194    Bix(_Bix), QueryStr(_QueryStr), CtxSet(_CtxSet){
195  }
196  void TBixRes::GetHitInfo(
197   const PBook&amp; Book,
198   const int&amp; HitN, const int&amp; MxTitleLen, const int&amp; MxCtxLen,
199   TStr&amp; SecIdStr, TStr&amp; TitleStr, TStr&amp; SecStr, TStr&amp; CtxStr) const {
200    int SecId=CtxSet-&gt;GetCtxSecId(HitN);
201    Book-&gt;GetSecInfo(SecId, SecIdStr, TitleStr, SecStr);
202    PSIn HtmlSIn=TStrIn::New(SecStr);
203    THtmlLx Lx(HtmlSIn);
<span onclick='openModal()' class='match'>204    TChA TitleChA; bool IsTitleComplete=true;
205    TChA CtxChA;
206    TLxSym PrevLxSym=syUndef; TLxSym CurLxSym=syUndef;
207    bool InTitleTag=false;
208    while (((MxCtxLen==-1)||(CtxChA.Len()&lt;MxCtxLen))&amp;&amp;
</span>209     (Lx.GetSym()!=hsyEof)){
210      if ((Lx.Sym==hsyStr)||(Lx.Sym==hsyNum)||(Lx.Sym==hsySSym)){
211        PrevLxSym=CurLxSym;
212        CurLxSym=THtmlDoc::GetLxSym(Lx.Sym, Lx.UcChA);
213        if (InTitleTag){
214          if ((MxTitleLen==-1)||(TitleChA.Len()&lt;MxTitleLen)){
215            if (TLxSymStr::IsSep(PrevLxSym, CurLxSym)){TitleChA+=&#x27; &#x27;;}
216            TitleChA+=Lx.ChA;
217          } else {
218            IsTitleComplete=false;
219          }
220        } else {
221          if (TLxSymStr::IsSep(PrevLxSym, CurLxSym)){CtxChA+=&#x27; &#x27;;}
222          CtxChA+=Lx.ChA;
223        }
224      } else
225      if ((Lx.Sym==hsyBTag)||(Lx.Sym==hsyETag)){
226        if (Lx.UcChA==THtmlTok::TitleTagNm){
227          InTitleTag=(Lx.Sym==hsyBTag); PrevLxSym=syUndef;
228        } else
229        if (Lx.UcChA==THtmlTok::CardTagNm){
230          TitleChA=Lx.GetArg(THtmlTok::TitleArgNm);
231        }
232      }
233    }
234    if (TitleChA.Empty()){TitleChA=TitleStr;}
235    else {if (!IsTitleComplete){TitleChA+=&quot; ...&quot;;}}
236    TitleStr=THtmlLx::GetEscapedStr(TitleChA);
237    if (Lx.Sym!=hsyEof){CtxChA+=&quot; ...&quot;;}
238    CtxStr=THtmlLx::GetEscapedStr(CtxChA);
239    SecStr=THtmlLx::GetEscapedStr(SecStr);
240  }
241  void TBixRes::GetHitSetMnMxHitN(
242   const int&amp; HitSetN, const int&amp; HitSetSecs, int&amp; MnHitN, int&amp; MxHitN) const {
243    IAssert(IsOk());
244    IAssert((HitSetN&gt;0)&amp;&amp;(HitSetSecs&gt;0));
245    MnHitN=(HitSetN-1)*HitSetSecs;
246    MxHitN=MnHitN+HitSetSecs-1;
247    MxHitN=TInt::GetMn(MxHitN, GetHits()-1);
248  }
249  void TBixRes::GetHitSet(
250   const int&amp; HitSetN, const int&amp; HitSetSecs, const int&amp; TocHitSets,
251   const TStr&amp; HitSetUrlFldNm, const PUrlSearchEnv&amp; UrlSearchEnv,
252   TStr&amp; PrevTocUrlStr, TStrPrV&amp; TocNmUrlStrPrV, TStr&amp; NextTocUrlStr) const {
253    PrevTocUrlStr.Clr(); TocNmUrlStrPrV.Clr(); NextTocUrlStr.Clr();
254    IAssert(IsOk());
255    IAssert((HitSetN&gt;0)&amp;&amp;(HitSetSecs&gt;0)&amp;&amp;(TocHitSets&gt;0));
256    if (GetHits()==0){return;}
257    int MnHitSetN=1;
258    int MxHitSetN=(GetHits()-1)/HitSetSecs+1;
259    if ((HitSetN&lt;MnHitSetN)||(MnHitSetN&gt;MxHitSetN)){return;}
260    int MnTocHitSetN=((HitSetN-1)/TocHitSets)*TocHitSets+1;
261    int MxTocHitSetN=MnTocHitSetN+TocHitSets-1;
262    MxTocHitSetN=TInt::GetMn(MxTocHitSetN, MxHitSetN);
263    PUrlSearchEnv HitSetUSE=TUrlSearchEnv::MkClone(UrlSearchEnv);
264    if (HitSetN!=MnHitSetN){
265      HitSetUSE-&gt;AddKeyVal(HitSetUrlFldNm, TInt::GetStr(HitSetN-1));
266      PrevTocUrlStr=TStr(&quot;/&quot;)+HitSetUSE-&gt;GetStr();
267    }
268    for (int TocHitSetN=MnTocHitSetN; TocHitSetN&lt;=MxTocHitSetN; TocHitSetN++){
269      TStr Nm=TInt::GetStr(TocHitSetN);
270      TStr UrlStr;
271      if (TocHitSetN!=HitSetN){
272        HitSetUSE-&gt;AddKeyVal(HitSetUrlFldNm, TInt::GetStr(TocHitSetN));
273        UrlStr=TStr(&quot;/&quot;)+HitSetUSE-&gt;GetStr();
274      }
275      TocNmUrlStrPrV.Add(TStrPr(Nm, UrlStr));
276    }
277    if (HitSetN!=MxHitSetN){
278      HitSetUSE-&gt;AddKeyVal(HitSetUrlFldNm, TInt::GetStr(HitSetN+1));
279      NextTocUrlStr=TStr(&quot;/&quot;)+HitSetUSE-&gt;GetStr();
280    }
281  }
282  TStr TBix::ContinentTagNm=&quot;&lt;CONTINENT&gt;&quot;;
283  TStr TBix::AreaTagNm=&quot;&lt;AREA&gt;&quot;;
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-txtbs.cpp</h3>
            <pre><code>1  TTxtBsRes::TTxtBsRes(
2   const PTxtBs&amp; _TxtBs, const TStr&amp; _WixExpStr, const TBlobPtV&amp; _DocIdV):
3    Ok(true), ErrMsg(&quot;Ok&quot;),
4    TxtBs(_TxtBs), WixExpStr(_WixExpStr), DocIdV(){
5    DocIdV.Gen(_DocIdV.Len());
6    for (int DocIdN=0; DocIdN&lt;_DocIdV.Len(); DocIdN++){
7      DocIdV[DocIdN]=_DocIdV[DocIdN];}
8    DocIdV.Sort(false);
9  }
10  void TTxtBsRes::GetDocInfo(
11   const int&amp; DocIdN, const int&amp; MxDocTitleLen, const int&amp; MxDocCtxLen,
12   TStr&amp; DocNm, TStr&amp; DocTitleStr, TStr&amp; DocStr, TStr&amp; DocCtxStr) const {
13    TMem DocMem; TxtBs-&gt;GetDocNmMem(DocIdV[DocIdN], DocNm, DocMem);
14    DocStr = TStr(DocMem);
15    PSIn HtmlSIn=TStrIn::New(DocStr);
16    THtmlLx Lx(HtmlSIn);
<span onclick='openModal()' class='match'>17    TChA DocTitleChA; bool IsDocTitleComplete=true;
18    TChA DocCtxChA;
19    TLxSym PrevLxSym=syUndef; TLxSym CurLxSym=syUndef;
20    bool InTitleTag=false;
21    while ((DocCtxChA.Len()&lt;MxDocCtxLen)&amp;&amp;(Lx.GetSym()!=hsyEof)){
</span>22      if ((Lx.Sym==hsyStr)||(Lx.Sym==hsyNum)||(Lx.Sym==hsySSym)){
23        PrevLxSym=CurLxSym;
24        CurLxSym=THtmlDoc::GetLxSym(Lx.Sym, Lx.UcChA);
25        if (InTitleTag){
26          if (DocTitleChA.Len()&lt;MxDocTitleLen){
27            if (TLxSymStr::IsSep(PrevLxSym, CurLxSym)){DocTitleChA+=&#x27; &#x27;;}
28            DocTitleChA+=Lx.ChA;
29          } else {
30            IsDocTitleComplete=false;
31          }
32        } else {
33          if (TLxSymStr::IsSep(PrevLxSym, CurLxSym)){DocCtxChA+=&#x27; &#x27;;}
34          DocCtxChA+=Lx.ChA;
35        }
36      } else
37      if ((Lx.Sym==hsyBTag)||(Lx.Sym==hsyETag)){
38        if (Lx.UcChA==THtmlTok::TitleTagNm){
39          InTitleTag=(Lx.Sym==hsyBTag); PrevLxSym=syUndef;
40        } else
41        if (Lx.UcChA==THtmlTok::CardTagNm){
42          DocTitleChA=Lx.GetArg(THtmlTok::TitleArgNm);
43        }
44      }
45    }
46    if (!IsDocTitleComplete){DocTitleChA+=&quot;...&quot;;}
47    if (Lx.Sym!=hsyEof){DocCtxChA+=&quot;...&quot;;}
48    DocTitleStr=THtmlLx::GetEscapedStr(DocTitleChA);
49    DocCtxStr=THtmlLx::GetEscapedStr(DocCtxChA);
50  }
51  void TTxtBsRes::GetHitSetMnMxDocN(
52   const int&amp; HitSetN, const int&amp; HitSetDocs, int&amp; MnDocN, int&amp; MxDocN) const {
53    IAssert(IsOk());
54    IAssert((HitSetN&gt;0)&amp;&amp;(HitSetDocs&gt;0));
55    MnDocN=(HitSetN-1)*HitSetDocs;
56    MxDocN=MnDocN+HitSetDocs-1;
57    MxDocN=TInt::GetMn(MxDocN, GetDocs()-1);
58  }
59  void TTxtBsRes::GetHitSet(
60   const int&amp; HitSetN, const int&amp; HitSetDocs, const int&amp; TocHitSets,
61   const TStr&amp; HitSetUrlFldNm, const PUrlEnv&amp; UrlEnv,
62   TStr&amp; PrevTocUrlStr, TStrPrV&amp; TocNmUrlStrPrV, TStr&amp; NextTocUrlStr) const {
63    PrevTocUrlStr.Clr(); TocNmUrlStrPrV.Clr(); NextTocUrlStr.Clr();
64    IAssert(IsOk());
65    IAssert((HitSetN&gt;0)&amp;&amp;(HitSetDocs&gt;0)&amp;&amp;(TocHitSets&gt;0));
66    if (GetDocs()==0){return;}
67    int MnHitSetN=1;
68    int MxHitSetN=(GetDocs()-1)/HitSetDocs+1;
69    if ((HitSetN&lt;MnHitSetN)||(MnHitSetN&gt;MxHitSetN)){return;}
70    int MnTocHitSetN=((HitSetN-1)/TocHitSets)*TocHitSets+1;
71    int MxTocHitSetN=MnTocHitSetN+TocHitSets-1;
72    MxTocHitSetN=TInt::GetMn(MxTocHitSetN, MxHitSetN);
73    PUrlEnv HitSetUrlEnv=TUrlEnv::MkClone(UrlEnv);
74    if (HitSetN!=MnHitSetN){
75      HitSetUrlEnv-&gt;AddKeyVal(HitSetUrlFldNm, TInt::GetStr(HitSetN-1));
76      PrevTocUrlStr=TStr(&quot;/&quot;)+HitSetUrlEnv-&gt;GetFullUrlStr();
77    }
78    for (int TocHitSetN=MnTocHitSetN; TocHitSetN&lt;=MxTocHitSetN; TocHitSetN++){
79      TStr Nm=TInt::GetStr(TocHitSetN);
80      TStr UrlStr;
81      if (TocHitSetN!=HitSetN){
82        HitSetUrlEnv-&gt;AddKeyVal(HitSetUrlFldNm, TInt::GetStr(TocHitSetN));
83        UrlStr=TStr(&quot;/&quot;)+HitSetUrlEnv-&gt;GetFullUrlStr();
84      }
85      TocNmUrlStrPrV.Add(TStrPr(Nm, UrlStr));
86    }
87    if (HitSetN!=MxHitSetN){
88      HitSetUrlEnv-&gt;AddKeyVal(HitSetUrlFldNm, TInt::GetStr(HitSetN+1));
89      NextTocUrlStr=TStr(&quot;/&quot;)+HitSetUrlEnv-&gt;GetFullUrlStr();
90    }
91  }
92  const TStr TTxtBs::TxtBsFExt=&quot;.tbs&quot;;
93  const TStr TTxtBs::TxtBsDocNmFExt=&quot;.tdn&quot;;
94  const TStr TTxtBs::TxtBsDocDatFExt=&quot;.tdd&quot;;
95  void TTxtBs::GenTxtBsMainFile(const TStr&amp; Nm, const TStr&amp; FPath){
96    TStr TxtBsFNm; TStr TxtBsDocNmFNm; TStr TxtBsDocDatFNm;
97    GetFNms(Nm, FPath, TxtBsFNm, TxtBsDocNmFNm, TxtBsDocDatFNm);
98    PSOut SOut=TFOut::New(TxtBsFNm);
99    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens);
100    Lx.PutUQStr(&quot;Text Base Main File&quot;); Lx.PutLn();
101    Lx.PutVarStr(&quot;Original Name&quot;, Nm, true, false);
102    Lx.PutVarStr(&quot;Original Path&quot;, FPath, true, false);
103    Lx.PutVarStr(&quot;Text-Base-Main&quot;, TxtBsFNm, true, false);
104    Lx.PutVarStr(&quot;Document-Names&quot;, TxtBsDocNmFNm, true, false);
105    Lx.PutVarStr(&quot;Document-Contents&quot;, TxtBsDocDatFNm, true, false);
106    Lx.PutVarStr(&quot;Creation Time&quot;, TSecTm::GetCurTm().GetStr(), true, false);
107  }
108  void TTxtBs::AddToTxtBsMainFile(const TStr&amp; TxtBsFNm, const TStr&amp; MsgStr){
109    PSOut SOut=TFOut::New(TxtBsFNm, true);
110    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens);
111    Lx.PutUQStr(MsgStr);
112    Lx.PutUQStr(TStr(&quot; [&quot;)+TSecTm::GetCurTm().GetStr()+TStr(&quot;]&quot;));
113    Lx.PutLn();
114  }
115  TTxtBs::TTxtBs(const TStr&amp; Nm, const TStr&amp; FPath,
116   const TFAccess&amp; _Access, const TFAccess&amp; _WixAccess, 
117   const int&amp; CacheSize):
118    NrNm(TStr::GetNrFMid(Nm)), NrFPath(TStr::GetNrFPath(FPath)),
119    TxtBsFNm(), Access(_Access), WixAccess(_WixAccess),
120    Wix(), DocNmH(), DocBBs(){
121    TStr TxtBsDocNmFNm; TStr TxtBsDocDatFNm;
122    GetFNms(NrNm, NrFPath, TxtBsFNm, TxtBsDocNmFNm, TxtBsDocDatFNm);
123    int DocNmHPorts;
124    if (Access==faCreate){
125      DocNmHPorts=1000000;
126      GenTxtBsMainFile(NrNm, NrFPath);
127    } else {
128      IAssertR(Exists(NrNm, NrFPath), &quot;[&quot; + NrNm + &quot;, &quot; + NrFPath + &quot;]&quot;);
129      DocNmHPorts=-1;
130      TStr OpenMsgStr=TStr(&quot;Open (&quot;)+TFRnd::GetStrFromFAccess(Access)+&quot;)&quot;;
131      AddToTxtBsMainFile(TxtBsFNm, OpenMsgStr);
132    }
133    if (WixAccess==faUndef){WixAccess=Access;}
134    Wix=PWix(new TWix(Nm, FPath, WixAccess, CacheSize));
135    DocNmH=PDocNmH(new TDocNmH(TxtBsDocNmFNm, Access, DocNmHPorts, 100000000));
136    DocBBs=PBlobBs(new TMBlobBs(TxtBsDocDatFNm, Access));
137  }
138  TTxtBs::~TTxtBs(){
139    AddToTxtBsMainFile(TxtBsFNm, &quot;Close&quot;);
140  }
141  TStr TTxtBs::GetMemUsedStr(){
142    return TStr()+
143     &quot;Wix:[&quot;+Wix-&gt;GetMemUsedStr()+&quot;]&quot;+
144     &quot; DocNmH:&quot;+TInt::GetMegaStr((int)DocNmH-&gt;GetMemUsed());
145  }
146  TBlobPt TTxtBs::AddDocMem(
147   const TStr&amp; UrlStr, const TMem&amp; DocMem, const bool&amp; IndexP){
148    TMOut NmDocSOut(UrlStr.Len()+DocMem.Len()+100);
149    UrlStr.Save(NmDocSOut); DocMem.Save(NmDocSOut);
150    PSIn NmDocSIn=NmDocSOut.GetSIn();
151    TBlobPt DocId=DocBBs-&gt;PutBlob(NmDocSIn);
152    TTxtBsDocFDat FDat(TBlobPt(), TSecTm::GetCurTm(), DocMem.Len(), DocId);
153    DocNmH-&gt;AddFDat(UrlStr, FDat);
154    if (IndexP){
155      PSIn HtmlDocSIn=TStrIn::New(DocMem.GetAsStr());
156      Wix-&gt;AddHtmlDoc(DocId, HtmlDocSIn);
157    }
158    return DocId;
159  }
160  TBlobPt TTxtBs::AddHtmlDoc(
161   const TStr&amp; UrlStr, const PSIn&amp; SIn, const bool&amp; IndexP){
162    TMem DocMem; TMem::LoadMem(SIn, DocMem);
163    return AddDocMem(UrlStr, DocMem, IndexP);
164  }
165  void TTxtBs::GetDocNmStr(const TBlobPt&amp; BlobPt, TStr&amp; DocNm, TStr&amp; DocStr){
166    PSIn NmDocSIn=DocBBs-&gt;GetBlob(BlobPt); 
167    DocNm=TStr(*NmDocSIn); 
168    TMem DocMem=TMem(*NmDocSIn); DocStr=TStr(DocMem); 
169  }
170  void TTxtBs::GetDocNmMem(const TBlobPt&amp; BlobPt, TStr&amp; DocNm, TMem&amp; DocMem){
171    PSIn NmDocSIn=DocBBs-&gt;GetBlob(BlobPt); 
172    DocNm=TStr(*NmDocSIn); 
173    DocMem=TMem(*NmDocSIn); 
174  }
175  TStr TTxtBs::GetDocNm(const TBlobPt&amp; BlobPt){
176    PSIn NmDocSIn=DocBBs-&gt;GetBlob(BlobPt); 
177    return TStr(*NmDocSIn); 
178  }
179  TStr TTxtBs::GetDocStr(const TStr&amp; DocNm){
180    TTxtBsDocFDat DocFDat;
181    DocNmH-&gt;GetFDat(DocNm, DocFDat);
182    TBlobPt DocBPt=DocFDat.DocId;
183    TStr _DocNm; TMem DocMem; GetDocNmMem(DocFDat.DocId, _DocNm, DocMem);
184    return TStr(DocMem);
185  }
186  void TTxtBs::GetDocMem(const TStr&amp; DocNm, TMem&amp; DocMem){
187    TTxtBsDocFDat DocFDat;
188    DocNmH-&gt;GetFDat(DocNm, DocFDat);
189    TBlobPt DocBPt=DocFDat.DocId;
190    TStr _DocNm; GetDocNmMem(DocFDat.DocId, _DocNm, DocMem);
191  }
192  TBlobPt TTxtBs::FFirstDocId(){
193    return DocNmH-&gt;FFirstKeyId();
194  }
195  bool TTxtBs::FNextDocId(TBlobPt&amp; TrvBlobPt, TBlobPt&amp; DocId){
196    TBlobPt KeyId;
197    if (DocNmH-&gt;FNextKeyId(TrvBlobPt, KeyId)){
198      TStr DocNm; TTxtBsDocFDat DocFDat;
199      DocNmH-&gt;GetKeyFDat(KeyId, DocNm, DocFDat);
200      DocId=DocFDat.DocId;
201      return true;
202    } else {
203      return false;
204    }
205  }
206  PTxtBsRes TTxtBs::Search(const TStr&amp; WixExpStr){
207    PWixExp WixExp=PWixExp(new TWixExp(WixExpStr));
208    PTxtBsRes TxtBsRes;
209    if (WixExp-&gt;IsOk()){
210      PWixExpDocIdSet DocIdSet=WixExp-&gt;Eval(Wix);
211      TxtBsRes=PTxtBsRes(new TTxtBsRes(this, WixExpStr, DocIdSet-&gt;GetDocIdV()));
212    } else {
213      TxtBsRes=PTxtBsRes(new TTxtBsRes(WixExp-&gt;GetErrMsg()));
214    }
215    return TxtBsRes;
216  }
217  void TTxtBs::GenIndex(const TStr&amp; Nm, const TStr&amp; FPath, const bool&amp; MemStatP){
218    PTxtBs TxtBs=TTxtBs::New(Nm, FPath, faRdOnly, faCreate);
219    TSecTm StartTm=TSecTm::GetCurTm();
220    TBlobPt TrvBlobPt=TxtBs-&gt;FFirstDocId(); 
221    TBlobPt DocId; int DocN=0; TStr DocNm; TMem DocMem;
222    while (TxtBs-&gt;FNextDocId(TrvBlobPt, DocId)){
223      TxtBs-&gt;GetDocNmMem(DocId, DocNm, DocMem);
224      PSIn DocSIn=TMemIn::New(DocMem);
225      TxtBs-&gt;Wix-&gt;AddHtmlDoc(DocId, DocSIn);
226      DocN++; 
227      if (DocN%100==0){
228        int SecsSf=TSecTm::GetDSecs(StartTm, TSecTm::GetCurTm());
229        if (MemStatP){
230          int64 MemUsed=TxtBs-&gt;GetMemUsed();
231          printf(&quot;%d: MemUsed:%s [%s] / %d secs\n&quot;, DocN,
232           TUInt64::GetMegaStr(MemUsed).CStr(), TxtBs-&gt;GetMemUsedStr().CStr(),
233           SecsSf);
234        } else {
235          printf(&quot;%d docs / %d secs\r&quot;, DocN, SecsSf);
236        }
237      }
238    }
239  }
240  void TTxtBs::SaveTxt(const PSOut&amp; SOut){
241    {TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens);
242    Lx.PutUQStr(&quot;---DocNmH---------------------&quot;); Lx.PutLn();
243    TBlobPt DocNmP=DocNmH-&gt;FFirstKeyId(); TBlobPt NmId;
244    while (DocNmH-&gt;FNextKeyId(DocNmP, NmId)){
245      TStr DocNm; TTxtBsDocFDat FDat;
246      DocNmH-&gt;GetKeyFDat(NmId, DocNm, FDat);
247      Lx.PutVarStr(&quot;DocNm&quot;, DocNm, false);
248      Lx.PutVarStr(&quot;MainNmId&quot;, FDat.MainNmId.GetStr(), false);
249      Lx.PutVarStr(&quot;Time&quot;, FDat.Tm.GetStr(), false);
250      Lx.PutVarInt(&quot;Len&quot;, FDat.Len, false);
251      Lx.PutVarStr(&quot;DocId&quot;, FDat.DocId.GetStr(), false);
252      Lx.PutLn();
253    }
254    Lx.PutUQStr(&quot;------------------------------&quot;); Lx.PutLn();}
255    Wix-&gt;SaveTxt(SOut);
256  }
257  void TTxtBs::GetFNms(
258   const TStr&amp; Nm, const TStr&amp; FPath,
259   TStr&amp; TxtBsFNm, TStr&amp; TxtBsDocNmFNm, TStr&amp; TxtBsDocDatFNm){
260    TStr NrFPath=TStr::GetNrFPath(FPath);
261    TStr NrNm=TStr::GetNrFMid(Nm);
262    TxtBsFNm=NrFPath+NrNm+TxtBsFExt;
263    TxtBsDocNmFNm=NrFPath+NrNm+TxtBsDocNmFExt;
264    TxtBsDocDatFNm=NrFPath+NrNm+TxtBsDocDatFExt;
265  }
266  bool TTxtBs::Exists(const TStr&amp; Nm, const TStr&amp; FPath){
267    TStr TxtBsFNm; TStr TxtBsDocNmFNm; TStr TxtBsDocDatFNm;
268    GetFNms(Nm, FPath, TxtBsFNm, TxtBsDocNmFNm, TxtBsDocDatFNm);
269    return
270     TFile::Exists(TxtBsFNm)&amp;&amp;
271     TFile::Exists(TxtBsDocNmFNm)&amp;&amp;
272     TMBlobBs::Exists(TxtBsDocDatFNm)&amp;&amp;
273     TWix::Exists(Nm, FPath);
274  }
275  void TTxtBs::Del(const TStr&amp; Nm, const TStr&amp; FPath){
276    if (Exists(Nm, FPath)){
277      TStr TxtBsFNm; TStr TxtBsDocNmFNm; TStr TxtBsDocDatFNm;
278      GetFNms(Nm, FPath, TxtBsFNm, TxtBsDocNmFNm, TxtBsDocDatFNm);
279      TFile::Del(TxtBsFNm);
280      TFile::Del(TxtBsDocNmFNm);
281      TFile::Del(TxtBsDocDatFNm);
282      TWix::Del(Nm, FPath);
283    }
284  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bix.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-txtbs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>204    TChA TitleChA; bool IsTitleComplete=true;
205    TChA CtxChA;
206    TLxSym PrevLxSym=syUndef; TLxSym CurLxSym=syUndef;
207    bool InTitleTag=false;
208    while (((MxCtxLen==-1)||(CtxChA.Len()&lt;MxCtxLen))&amp;&amp;
</pre></code></div>
                <div class="column column_space"><pre><code>17    TChA DocTitleChA; bool IsDocTitleComplete=true;
18    TChA DocCtxChA;
19    TLxSym PrevLxSym=syUndef; TLxSym CurLxSym=syUndef;
20    bool InTitleTag=false;
21    while ((DocCtxChA.Len()&lt;MxDocCtxLen)&amp;&amp;(Lx.GetSym()!=hsyEof)){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    